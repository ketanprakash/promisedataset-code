name,version,name.1,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
jEdit,4,org.gjt.sp.jedit.gui.MacrosMenu,6,8,0,10,22,15,1,10,4,2.0,128,0.0,0,0.994206257,0.333333333,1,7,20.33333333,5,2.1667,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.msg.MacrosChanged;
import org.gjt.sp.jedit.*;

public class MacrosMenu extends EnhancedMenu implements EBComponent
{
	public MacrosMenu()
	{
		super(""macros"");
		updateMacrosMenu();
	}

	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	}

	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
	}

	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof MacrosChanged)
			updateMacrosMenu();
	}

	private void updateMacrosMenu()
	{
		
		
		
		for(int i = getMenuComponentCount() - 1; i >= 0; i--)
		{
			if(getMenuComponent(i) instanceof JSeparator)
				break;
			else
				remove(i);
		}

		int count = getMenuComponentCount();

		Vector macroVector = Macros.getMacroHierarchy();
		createMacrosMenu(this,macroVector,0);

		if(count == getMenuComponentCount())
			add(GUIUtilities.loadMenuItem(""no-macros""));
	}

	private void createMacrosMenu(JMenu menu, Vector vector, int start)
	{
		for(int i = start; i < vector.size(); i++)
		{
			Object obj = vector.elementAt(i);
			if(obj instanceof Macros.Macro)
			{
				Macros.Macro macro = (Macros.Macro)obj;
				menu.add(new EnhancedMenuItem(macro.getLabel(),macro));
			}
			else if(obj instanceof Vector)
			{
				Vector subvector = (Vector)obj;
				String name = (String)subvector.elementAt(0);
				JMenu submenu = new JMenu(name);
				createMacrosMenu(submenu,subvector,1);
				if(submenu.getMenuComponentCount() == 0)
				{
					submenu.add(GUIUtilities.loadMenuItem(
						""no-macros""));
				}
				menu.add(submenu);
			}
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.options.ModeOptionPane,12,6,0,7,39,28,3,6,1,0.397727273,573,1.0,2,0.983655275,0.5,1,3,45.41666667,2,1.1667,1,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.FoldHandler;


public class ModeOptionPane extends AbstractOptionPane
{
	
	public ModeOptionPane()
	{
		super(""mode"");
	} 

	
	protected void _init()
	{
		Mode[] modes = jEdit.getModes();
		String[] modeNames = new String[modes.length];
		modeProps = new ModeProperties[modes.length];
		for(int i = 0; i < modes.length; i++)
		{
			modeProps[i] = new ModeProperties(modes[i]);
			modeNames[i] = modes[i].getName();
		}
		mode = new JComboBox(modeNames);
		mode.addActionListener(new ActionHandler());

		addComponent(jEdit.getProperty(""options.mode.mode""),mode);

		useDefaults = new JCheckBox(jEdit.getProperty(""options.mode.useDefaults""));
		useDefaults.addActionListener(new ActionHandler());
		addComponent(useDefaults);

		addComponent(jEdit.getProperty(""options.mode.filenameGlob""),
			filenameGlob = new JTextField());

		addComponent(jEdit.getProperty(""options.mode.firstlineGlob""),
			firstlineGlob = new JTextField());

		addComponent(jEdit.getProperty(""options.editing.noWordSep""),
			noWordSep = new JTextField());

		String[] foldModes = FoldHandler.getFoldModes();
		addComponent(jEdit.getProperty(""options.editing.folding""),
			folding = new JComboBox(foldModes));

		addComponent(jEdit.getProperty(""options.editing.collapseFolds""),
			collapseFolds = new JTextField());

		String[] wrapModes = {
			""none"",
			""soft"",
			""hard""
		};
		addComponent(jEdit.getProperty(""options.editing.wrap""),
			wrap = new JComboBox(wrapModes));

		String[] lineLens = { ""0"", ""72"", ""76"", ""80"" };
		addComponent(jEdit.getProperty(""options.editing.maxLineLen""),
			maxLineLen = new JComboBox(lineLens));
		maxLineLen.setEditable(true);

		String[] tabSizes = { ""2"", ""4"", ""8"" };
		addComponent(jEdit.getProperty(""options.editing.tabSize""),
			tabSize = new JComboBox(tabSizes));
		tabSize.setEditable(true);

		addComponent(jEdit.getProperty(""options.editing.indentSize""),
			indentSize = new JComboBox(tabSizes));
		indentSize.setEditable(true);

		addComponent(noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs"")));

		addComponent(indentOnTab = new JCheckBox(jEdit.getProperty(
			""options.editing.indentOnTab"")));

		addComponent(indentOnEnter = new JCheckBox(jEdit.getProperty(
			""options.editing.indentOnEnter"")));

		selectMode();
	} 

	
	protected void _save()
	{
		saveMode();

		for(int i = 0; i < modeProps.length; i++)
		{
			modeProps[i].save();
		}
	} 

	

	
	private ModeProperties[] modeProps;
	private ModeProperties current;
	private JComboBox mode;
	private JCheckBox useDefaults;
	private JTextField filenameGlob;
	private JTextField firstlineGlob;
	private JTextField noWordSep;
	private JComboBox folding;
	private JTextField collapseFolds;
	private JComboBox wrap;
	private JComboBox maxLineLen;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JCheckBox noTabs;
	private JCheckBox indentOnTab;
	private JCheckBox indentOnEnter;
	

	
	private void saveMode()
	{
		current.useDefaults = useDefaults.isSelected();
		current.filenameGlob = filenameGlob.getText();
		current.firstlineGlob = firstlineGlob.getText();
		current.noWordSep = noWordSep.getText();
		current.folding = (String)folding.getSelectedItem();
		current.collapseFolds = collapseFolds.getText();
		current.wrap = (String)wrap.getSelectedItem();
		current.maxLineLen = (String)maxLineLen.getSelectedItem();
		current.tabSize = (String)tabSize.getSelectedItem();
		current.indentSize = (String)indentSize.getSelectedItem();
		current.noTabs = noTabs.isSelected();
		current.indentOnEnter = indentOnEnter.isSelected();
		current.indentOnTab = indentOnTab.isSelected();
	} 

	
	private void selectMode()
	{
		current = modeProps[mode.getSelectedIndex()];
		current.edited = true;
		current.load();

		useDefaults.setSelected(current.useDefaults);
		filenameGlob.setText(current.filenameGlob);
		firstlineGlob.setText(current.firstlineGlob);
		noWordSep.setText(current.noWordSep);
		folding.setSelectedItem(current.folding);
		collapseFolds.setText(current.collapseFolds);
		wrap.setSelectedItem(current.wrap);
		maxLineLen.setSelectedItem(current.maxLineLen);
		tabSize.setSelectedItem(current.tabSize);
		indentSize.setSelectedItem(current.indentSize);
		noTabs.setSelected(current.noTabs);
		indentOnTab.setSelected(current.indentOnTab);
		indentOnEnter.setSelected(current.indentOnEnter);

		updateEnabled();
	} 

	
	private void updateEnabled()
	{
		boolean enabled = !modeProps[mode.getSelectedIndex()].useDefaults;
		filenameGlob.setEnabled(enabled);
		firstlineGlob.setEnabled(enabled);
		noWordSep.setEnabled(enabled);
		folding.setEnabled(enabled);
		collapseFolds.setEnabled(enabled);
		wrap.setEnabled(enabled);
		maxLineLen.setEnabled(enabled);
		tabSize.setEnabled(enabled);
		indentSize.setEnabled(enabled);
		noTabs.setEnabled(enabled);
		indentOnTab.setEnabled(enabled);
		indentOnEnter.setEnabled(enabled);
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == mode)
			{
				saveMode();
				selectMode();
			}
			else if(evt.getSource() == useDefaults)
			{
				modeProps[mode.getSelectedIndex()].useDefaults =
					useDefaults.isSelected();
				updateEnabled();
			}
		}
	} 

	
	class ModeProperties
	{
		
		Mode mode;
		boolean edited;
		boolean loaded;

		boolean useDefaults;
		String filenameGlob;
		String firstlineGlob;
		String noWordSep;
		String folding;
		String collapseFolds;
		String wrap;
		String maxLineLen;
		String tabSize;
		String indentSize;
		boolean noTabs;
		boolean indentOnTab;
		boolean indentOnEnter;
		

		
		ModeProperties(Mode mode)
		{
			this.mode = mode;
		} 

		
		void load()
		{
			if(loaded)
				return;

			loaded = true;

			mode.loadIfNecessary();

			useDefaults = !jEdit.getBooleanProperty(""mode.""
				+ mode.getName() + "".customSettings"");
			filenameGlob = (String)mode.getProperty(""filenameGlob"");
			firstlineGlob = (String)mode.getProperty(""firstlineGlob"");
			noWordSep = (String)mode.getProperty(""noWordSep"");
			folding = mode.getProperty(""folding"").toString();
			collapseFolds = mode.getProperty(""collapseFolds"").toString();
			wrap = mode.getProperty(""wrap"").toString();
			maxLineLen = mode.getProperty(""maxLineLen"").toString();
			tabSize = mode.getProperty(""tabSize"").toString();
			indentSize = mode.getProperty(""indentSize"").toString();
			noTabs = mode.getBooleanProperty(""noTabs"");
			indentOnTab = mode.getBooleanProperty(""indentOnTab"");
			indentOnEnter = mode.getBooleanProperty(""indentOnEnter"");
		} 

		
		void save()
		{
			
			
			if(!edited)
				return;

			String prefix = ""mode."" + mode.getName() + ""."";
			jEdit.setBooleanProperty(prefix + ""customSettings"",!useDefaults);

			if(useDefaults)
			{
				jEdit.resetProperty(prefix + ""filenameGlob"");
				jEdit.resetProperty(prefix + ""firstlineGlob"");
				jEdit.resetProperty(prefix + ""noWordSep"");
				jEdit.resetProperty(prefix + ""folding"");
				jEdit.resetProperty(prefix + ""collapseFolds"");
				jEdit.resetProperty(prefix + ""wrap"");
				jEdit.resetProperty(prefix + ""maxLineLen"");
				jEdit.resetProperty(prefix + ""tabSize"");
				jEdit.resetProperty(prefix + ""indentSize"");
				jEdit.resetProperty(prefix + ""noTabs"");
				jEdit.resetProperty(prefix + ""indentOnTab"");
				jEdit.resetProperty(prefix + ""indentOnEnter"");
			}
			else
			{
				jEdit.setProperty(prefix + ""filenameGlob"",filenameGlob);
				jEdit.setProperty(prefix + ""firstlineGlob"",firstlineGlob);
				jEdit.setProperty(prefix + ""noWordSep"",noWordSep);
				jEdit.setProperty(prefix + ""folding"",folding);
				jEdit.setProperty(prefix + ""collapseFolds"",collapseFolds);
				jEdit.setProperty(prefix + ""wrap"",wrap);
				jEdit.setProperty(prefix + ""maxLineLen"",maxLineLen);
				jEdit.setProperty(prefix + ""tabSize"",tabSize);
				jEdit.setProperty(prefix + ""indentSize"",indentSize);
				jEdit.setBooleanProperty(prefix + ""noTabs"",noTabs);
				jEdit.setBooleanProperty(prefix + ""indentOnTab"",indentOnTab);
				jEdit.setBooleanProperty(prefix + ""indentOnEnter"",indentOnEnter);
			}
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.OptionsDialog,14,7,0,28,108,69,3,28,8,0.869230769,732,1.0,2,0.98048048,0.174603175,0,0,50.57142857,9,2.1429,2,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.options.*;
import org.gjt.sp.util.Log;


public class OptionsDialog extends EnhancedDialog
	implements ActionListener, TreeSelectionListener
{
	public OptionsDialog(View view)
	{
		super(view, jEdit.getProperty(""options.title""), true);

		view.showWaitCursor();

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		content.setLayout(new BorderLayout());

		JPanel stage = new JPanel(new BorderLayout());
		stage.setBorder(new EmptyBorder(0,6,0,0));
		content.add(stage, BorderLayout.CENTER);

		
		
		currentLabel = new JLabel();
		currentLabel.setHorizontalAlignment(JLabel.LEFT);
		currentLabel.setBorder(BorderFactory.createMatteBorder(0, 0, 1,
			0, Color.black));
		stage.add(currentLabel, BorderLayout.NORTH);

		cardPanel = new JPanel(new CardLayout());
		cardPanel.setBorder(new EmptyBorder(5,0,0,0));
		stage.add(cardPanel, BorderLayout.CENTER);

		paneTree = new JTree(createOptionTreeModel());

		paneTree.setCellRenderer(new PaneNameRenderer());
		paneTree.putClientProperty(""JTree.lineStyle"", ""Angled"");
		paneTree.setShowsRootHandles(true);
		paneTree.setRootVisible(false);
		content.add(new JScrollPane(paneTree,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED),
			BorderLayout.WEST);

		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		getRootPane().setDefaultButton(ok);
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		buttons.add(cancel);
		buttons.add(Box.createHorizontalStrut(6));
		apply = new JButton(jEdit.getProperty(""common.apply""));
		apply.addActionListener(this);
		buttons.add(apply);

		buttons.add(Box.createGlue());

		content.add(buttons, BorderLayout.SOUTH);

		
		
		
		paneTree.getSelectionModel().addTreeSelectionListener(this);

		paneTree.expandPath(new TreePath(
			new Object[] { paneTree.getModel().getRoot(), jEditGroup }));
		paneTree.setSelectionRow(0);

		view.hideWaitCursor();

		pack();
		setLocationRelativeTo(view);
		show();
	}

	public void addOptionGroup(OptionGroup group)
	{
		addOptionGroup(group, pluginsGroup);
	}

	public void addOptionPane(OptionPane pane)
	{
		addOptionPane(pane, pluginsGroup);
	}

	
	public void ok()
	{
		ok(true);
	}

	public void cancel()
	{
		dispose();
	}
	

	public void ok(boolean dispose)
	{
		OptionTreeModel m = (OptionTreeModel) paneTree
			.getModel();
		((OptionGroup) m.getRoot()).save();

		
		jEdit.propertiesChanged();

		
		jEdit.saveSettings();

		
		if(dispose)
			dispose();
	}

	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();

		if(source == ok)
		{
			ok();
		}
		else if(source == cancel)
		{
			cancel();
		}
		else if(source == apply)
		{
			ok(false);
		}
	}

	public void valueChanged(TreeSelectionEvent evt)
	{
		TreePath path = evt.getPath();

		if (path == null || !(path.getLastPathComponent() instanceof
			OptionPane)) return;

		Object[] nodes = path.getPath();

		StringBuffer buf = new StringBuffer();

		OptionPane optionPane = null;
		String name = null;

		int lastIdx = nodes.length - 1;

		for (int i = paneTree.isRootVisible() ? 0 : 1;
			i <= lastIdx; i++)
		{
			if (nodes[i] instanceof OptionPane)
			{
				optionPane = (OptionPane)nodes[i];
				name = optionPane.getName();
			}
			else if (nodes[i] instanceof OptionGroup)
			{
				name = ((OptionGroup)nodes[i]).getName();
			}
			else
			{
				continue;
			}

			if (name != null)
			{
				String label = jEdit.getProperty(""options."" +
					name + "".label"");

				if (label == null)
				{
					buf.append(name);
				}
				else
				{
					buf.append(label);
				}
			}

			if (i != lastIdx) buf.append("": "");
		}

		currentLabel.setText(buf.toString());

		optionPane.init();

		pack();
		((CardLayout)cardPanel.getLayout()).show(cardPanel, name);
	}

	
	private Hashtable panes;
	private JTree paneTree;
	private JPanel cardPanel;
	private JLabel currentLabel;
	private JButton ok;
	private JButton cancel;
	private JButton apply;
	private OptionGroup jEditGroup;
	private OptionGroup pluginsGroup;

	private OptionTreeModel createOptionTreeModel()
	{
		OptionTreeModel paneTreeModel = new OptionTreeModel();
		OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();

		addOptionPane(new OverviewOptionPane(), rootGroup);

		
		jEditGroup = new OptionGroup(""jedit"");

		addOptionPane(new GeneralOptionPane(), jEditGroup);
		addOptionPane(new AppearanceOptionPane(), jEditGroup);
		addOptionPane(new TextAreaOptionPane(), jEditGroup);
		addOptionPane(new GutterOptionPane(), jEditGroup);
		addOptionPane(new ColorOptionPane(), jEditGroup);
		addOptionPane(new StyleOptionPane(), jEditGroup);
		addOptionPane(new LoadSaveOptionPane(), jEditGroup);
		addOptionPane(new EditingOptionPane(), jEditGroup);
		addOptionPane(new ModeOptionPane(), jEditGroup);
		addOptionPane(new ShortcutsOptionPane(), jEditGroup);
		addOptionPane(new DockingOptionPane(), jEditGroup);
		addOptionPane(new ContextOptionPane(), jEditGroup);
		addOptionPane(new ToolBarOptionPane(), jEditGroup);
		addOptionPane(new AbbrevsOptionPane(), jEditGroup);
		addOptionPane(new PrintOptionPane(), jEditGroup);
		addOptionPane(new FirewallOptionPane(), jEditGroup);

		OptionGroup browserGroup = new OptionGroup(""browser"");
		addOptionPane(new BrowserOptionPane(), browserGroup);
		addOptionPane(new BrowserColorsOptionPane(), browserGroup);
		addOptionGroup(browserGroup, jEditGroup);

		addOptionGroup(jEditGroup, rootGroup);

		
		pluginsGroup = new OptionGroup(""plugins"");

		
		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin ep = plugins[i];
			try
			{
				ep.createOptionPanes(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR, ep,
					""Error creating option pane"");
				Log.log(Log.ERROR, ep, t);
			}
		}

		
		if (pluginsGroup.getMemberCount() > 0)
		{
			addOptionGroup(pluginsGroup, rootGroup);
		}

		return paneTreeModel;
	}

	private void addOptionGroup(OptionGroup child, OptionGroup parent)
	{
		Enumeration enum = child.getMembers();

		while (enum.hasMoreElements())
		{
			Object elem = enum.nextElement();

			if (elem instanceof OptionPane)
			{
				addOptionPane((OptionPane) elem, child);
			}
			else if (elem instanceof OptionGroup)
			{
				addOptionGroup((OptionGroup) elem, child);
			}
		}

		parent.addOptionGroup(child);
	}

	private void addOptionPane(OptionPane pane, OptionGroup parent)
	{
		String name = pane.getName();

		cardPanel.add(pane.getComponent(), name);

		parent.addOptionPane(pane);
	}

	class PaneNameRenderer extends DefaultTreeCellRenderer
	{
		public PaneNameRenderer()
		{
			paneFont = UIManager.getFont(""Tree.font"");
			groupFont = paneFont.deriveFont(Font.BOLD);
		}

		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,
				selected,expanded,leaf,row,hasFocus);

			String name = null;

			if (value instanceof OptionGroup)
			{
				name = ((OptionGroup)value).getName();
				this.setFont(groupFont);
			}
			else if (value instanceof OptionPane)
			{
				name = ((OptionPane)value).getName();
				this.setFont(paneFont);
			}

			if (name == null)
			{
				setText(null);
			}
			else
			{
				String label = jEdit.getProperty(""options."" +
					name + "".label"");

				if (label == null)
				{
					
					Log.log(Log.WARNING,this,
						""options."" + name + "".label""
						+ "" property not defined"");
					setText(name);
				}
				else
				{
					setText(label);
				}
			}

			setIcon(null);

			return this;
		}

		private Font paneFont;
		private Font groupFont;
	}

	class OptionTreeModel implements TreeModel
	{
		public void addTreeModelListener(TreeModelListener l)
		{
			listenerList.add(TreeModelListener.class, l);
		}

		public void removeTreeModelListener(TreeModelListener l)
		{
			listenerList.remove(TreeModelListener.class, l);
		}

		public Object getChild(Object parent, int index)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMember(index);
			}
			else
			{
				return null;
			}
		}

		public int getChildCount(Object parent)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMemberCount();
			}
			else
			{
				return 0;
			}
		}

		public int getIndexOfChild(Object parent, Object child)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent)
					.getMemberIndex(child);
			}
			else
			{
				return -1;
			}
		}

		public Object getRoot()
		{
			return root;
		}

		public boolean isLeaf(Object node)
		{
			return node instanceof OptionPane;
		}

		public void valueForPathChanged(TreePath path, Object newValue)
		{
			
		}

		protected void fireNodesChanged(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeNodesChanged(modelEvent);
			}
		}

		protected void fireNodesInserted(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeNodesInserted(modelEvent);
			}
		}

		protected void fireNodesRemoved(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeNodesRemoved(modelEvent);
			}
		}

		protected void fireTreeStructureChanged(Object source,
			Object[] path, int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeStructureChanged(modelEvent);
			}
		}

		private OptionGroup root = new OptionGroup(null);
		private EventListenerList listenerList = new EventListenerList();
	}
}
"
jEdit,4,org.gjt.sp.jedit.buffer.ExplicitFoldHandler,2,2,0,2,6,1,1,2,2,2.0,85,0.0,0,0.875,0.625,0,0,41.5,5,2.5,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;


public class ExplicitFoldHandler extends FoldHandler
{
	
	public ExplicitFoldHandler()
	{
		super(""explicit"");
	} 

	
	
	public int getFoldLevel(Buffer buffer, int lineIndex, Segment seg)
	{
		if(lineIndex == 0)
			return 0;
		else
		{
			int tabSize = buffer.getTabSize();
			int foldLevel = buffer.getFoldLevel(lineIndex - 1);

			buffer.getLineText(lineIndex - 1,seg);

			int offset = seg.offset;
			int count = seg.count;

			int openingBrackets = 0, closingBrackets = 0;
			for(int i = 0; i < count; i++)
			{
				switch(seg.array[offset + i])
				{
				case '{':
					closingBrackets = 0;
					openingBrackets++;
					if(openingBrackets == 3)
					{
						foldLevel += tabSize;
						openingBrackets = 0;
					}
					break;
				case '}':
					openingBrackets = 0;
					closingBrackets++;
					if(closingBrackets == 3)
					{
						if(foldLevel >= tabSize)
							foldLevel -= tabSize;
						closingBrackets = 0;
					}
					break;
				default:
					closingBrackets = openingBrackets = 0;
					break;
				}
			}

			return foldLevel;
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.options.GeneralOptionPane,5,6,0,5,28,0,2,4,1,0.708333333,337,1.0,0,0.993993994,0.5,2,4,64.0,3,1.6,1,"

package org.gjt.sp.jedit.options;

import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;

public class GeneralOptionPane extends AbstractOptionPane
{
	public GeneralOptionPane()
	{
		super(""general"");
	}

	
	protected void _init()
	{
		
		history = new JTextField(jEdit.getProperty(""history""));
		addComponent(jEdit.getProperty(""options.general.history""),history);

		
		saveCaret = new JCheckBox(jEdit.getProperty(
			""options.general.saveCaret""));
		saveCaret.setSelected(jEdit.getBooleanProperty(""saveCaret""));
		addComponent(saveCaret);

		
		sortBuffers = new JCheckBox(jEdit.getProperty(
			""options.general.sortBuffers""));
		sortBuffers.setSelected(jEdit.getBooleanProperty(""sortBuffers""));
		sortBuffers.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				sortByName.setEnabled(sortBuffers.isSelected());
			}
		});

		addComponent(sortBuffers);

		
		sortByName = new JCheckBox(jEdit.getProperty(
			""options.general.sortByName""));
		sortByName.setSelected(jEdit.getBooleanProperty(""sortByName""));
		sortByName.setEnabled(sortBuffers.isSelected());
		addComponent(sortByName);

		
		sortRecent = new JCheckBox(jEdit.getProperty(
			""options.general.sortRecent""));
		sortRecent.setSelected(jEdit.getBooleanProperty(""sortRecent""));
		addComponent(sortRecent);

		
		checkModStatus = new JCheckBox(jEdit.getProperty(
			""options.general.checkModStatus""));
		checkModStatus.setSelected(jEdit.getBooleanProperty(
			""view.checkModStatus""));
		addComponent(checkModStatus);

		
		showFullPath = new JCheckBox(jEdit.getProperty(
			""options.general.showFullPath""));
		showFullPath.setSelected(jEdit.getBooleanProperty(
			""view.showFullPath""));
		addComponent(showFullPath);

		
		showSearchbar = new JCheckBox(jEdit.getProperty(
			""options.general.showSearchbar""));
		showSearchbar.setSelected(jEdit.getBooleanProperty(
			""view.showSearchbar""));
		addComponent(showSearchbar);

		
		beepOnSearchAutoWrap = new JCheckBox(jEdit.getProperty(
			""options.general.beepOnSearchAutoWrap""));
		beepOnSearchAutoWrap.setSelected(jEdit.getBooleanProperty(
			""search.beepOnSearchAutoWrap""));
		addComponent(beepOnSearchAutoWrap);

		
		showBufferSwitcher = new JCheckBox(jEdit.getProperty(
			""options.general.showBufferSwitcher""));
		showBufferSwitcher.setSelected(jEdit.getBooleanProperty(
			""view.showBufferSwitcher""));
		addComponent(showBufferSwitcher);

		
		showTips = new JCheckBox(jEdit.getProperty(
			""options.general.showTips""));
		showTips.setSelected(jEdit.getBooleanProperty(""tip.show""));
		addComponent(showTips);

		
		showSplash = new JCheckBox(jEdit.getProperty(
			""options.general.showSplash""));
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			showSplash.setSelected(true);
		else
			showSplash.setSelected(!new File(settingsDirectory,""nosplash"").exists());
		addComponent(showSplash);
	}

	protected void _save()
	{
		jEdit.setProperty(""history"",history.getText());
		jEdit.setBooleanProperty(""saveCaret"",saveCaret.isSelected());
		jEdit.setBooleanProperty(""sortBuffers"",sortBuffers.isSelected());
		jEdit.setBooleanProperty(""sortByName"",sortByName.isSelected());
		jEdit.setBooleanProperty(""sortRecent"",sortRecent.isSelected());
		jEdit.setBooleanProperty(""view.checkModStatus"",checkModStatus
			.isSelected());
		jEdit.setBooleanProperty(""view.showFullPath"",showFullPath
			.isSelected());
		jEdit.setBooleanProperty(""view.showSearchbar"",showSearchbar
			.isSelected());
		jEdit.setBooleanProperty(""search.beepOnSearchAutoWrap"",beepOnSearchAutoWrap
			.isSelected());
		jEdit.setBooleanProperty(""view.showBufferSwitcher"",
			showBufferSwitcher.isSelected());
		jEdit.setBooleanProperty(""tip.show"",showTips.isSelected());

		
		
		
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			File file = new File(settingsDirectory,""nosplash"");
			if(showSplash.isSelected())
				file.delete();
			else
			{
				try
				{
					FileOutputStream out = new FileOutputStream(file);
					out.write('\n');
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,this,io);
				}
			}
		}
	}

	
	private JTextField history;
	private JCheckBox saveCaret;
	private JCheckBox sortBuffers;
	private JCheckBox sortByName;
	private JCheckBox sortRecent;
	private JCheckBox checkModStatus;
	private JCheckBox showFullPath;
	private JCheckBox showSearchbar;
  private JCheckBox beepOnSearchAutoWrap;
	private JCheckBox showBufferSwitcher;
	private JCheckBox showTips;
	private JCheckBox showSplash;
}
"
jEdit,4,org.gjt.sp.jedit.gui.CurrentDirectoryMenu,2,8,0,11,33,1,3,11,2,2.0,206,0.0,0,0.998835856,0.75,2,4,102.0,16,8.0,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.awt.event.*;
import java.io.File;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;

public class CurrentDirectoryMenu extends EnhancedMenu
{
	
	public CurrentDirectoryMenu()
	{
		super(""current-directory"");
	} 

	
	public void setPopupMenuVisible(boolean b)
	{
		if(b)
		{
			final View view = GUIUtilities.getView(this);

			if(getMenuComponentCount() != 0)
				removeAll();

			final String path = MiscUtilities.getParentOfPath(
				view.getBuffer().getPath());
			JMenuItem mi = new JMenuItem(path);
			mi.setIcon(FileCellRenderer.openDirIcon);

			
			mi.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					VFSBrowser.browseDirectory(view,path);
				}
			}); 

			add(mi);
			addSeparator();

			if(view.getBuffer().getFile() == null)
			{
				mi = new JMenuItem(jEdit.getProperty(
					""current-directory.not-local""));
				mi.setEnabled(false);
				add(mi);
				super.setPopupMenuVisible(b);
				return;
			}

			File dir = new File(path);

			JMenu current = this;

			
			ActionListener listener = new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					jEdit.openFile(view,evt.getActionCommand());
				}
			}; 

			
			String backupPrefix = jEdit.getProperty(""backup.prefix"");
			String backupSuffix = jEdit.getProperty(""backup.suffix"");

			String[] list = dir.list();
			if(list == null || list.length == 0)
			{
				mi = new JMenuItem(jEdit.getProperty(
					""current-directory.no-files""));
				mi.setEnabled(false);
				add(mi);
			}
			else
			{
				MiscUtilities.quicksort(list,
					new MiscUtilities.StringICaseCompare());
				for(int i = 0; i < list.length; i++)
				{
					String name = list[i];

					
					if(name.endsWith("".marks""))
						continue;

					
					if(name.startsWith(""#"") && name.endsWith(""#""))
						continue;

					
					if((backupPrefix.length() != 0
						&& name.startsWith(backupPrefix))
						|| (backupSuffix.length() != 0
						&& name.endsWith(backupSuffix)))
						continue;

					
					File file = new File(path,name);
					if(file.isDirectory())
						continue;

					mi = new JMenuItem(name);
					mi.setActionCommand(file.getPath());
					mi.addActionListener(listener);
					mi.setIcon(FileCellRenderer.fileIcon);

					if(current.getItemCount() >= 20 && i != list.length - 1)
					{
						
						JMenu newCurrent = new JMenu(
							jEdit.getProperty(
							""common.more""));
						current.add(newCurrent);
						current = newCurrent;
					}
					current.add(mi);
				}
			}

		}

		super.setPopupMenuVisible(b);
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.JCheckBoxList,8,5,0,3,33,28,1,2,7,2.0,143,0.0,0,0.992974239,0.5,1,1,16.875,3,1.125,1,"

package org.gjt.sp.jedit.gui;

import javax.swing.table.*;
import javax.swing.*;
import java.util.Vector;


public class JCheckBoxList extends JTable
{
	
	public JCheckBoxList(Object[] items)
	{
		setModel(items);
	}

	
	public JCheckBoxList(Vector items)
	{
		setModel(items);
	}

	
	public void setModel(Object[] items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	}

	
	public void setModel(Vector items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	}

	public Object[] getCheckedValues()
	{
		Vector values = new Vector();
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		for(int i = 0; i < model.items.size(); i++)
		{
			Entry entry = (Entry)model.items.elementAt(i);
			if(entry.checked)
				values.addElement(entry.value);
		}

		Object[] retVal = new Object[values.size()];
		values.copyInto(retVal);
		return retVal;
	}

	public Entry[] getValues()
	{
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		Entry[] retVal = new Entry[model.items.size()];
		model.items.copyInto(retVal);
		return retVal;
	}

	public Object getSelectedValue()
	{
		int row = getSelectedRow();
		if(row == -1)
			return null;
		else
			return getModel().getValueAt(row,1);
	}

	
	private void init()
	{
		getSelectionModel().setSelectionMode(ListSelectionModel
			.SINGLE_SELECTION);
		setShowGrid(false);
		setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
		TableColumn column = getColumnModel().getColumn(0);
		int checkBoxWidth = new JCheckBox().getPreferredSize().width;
		column.setPreferredWidth(checkBoxWidth);
		column.setMinWidth(checkBoxWidth);
		column.setWidth(checkBoxWidth);
		column.setMaxWidth(checkBoxWidth);
		column.setResizable(false);
	}

	public static class Entry
	{
		boolean checked;
		Object value;

		public Entry(boolean checked, Object value)
		{
			this.checked = checked;
			this.value = value;
		}

		public boolean isChecked()
		{
			return checked;
		}

		public Object getValue()
		{
			return value;
		}
	}
}

class CheckBoxListModel extends AbstractTableModel
{
	Vector items;

	CheckBoxListModel(Vector _items)
	{
		items = new Vector(_items.size());
		for(int i = 0; i < _items.size(); i++)
		{
			items.addElement(createEntry(_items.elementAt(i)));
		}
	}

	CheckBoxListModel(Object[] _items)
	{
		items = new Vector(_items.length);
		for(int i = 0; i < _items.length; i++)
		{
			items.addElement(createEntry(_items[i]));
		}
	}

	private JCheckBoxList.Entry createEntry(Object obj)
	{
		if(obj instanceof JCheckBoxList.Entry)
			return (JCheckBoxList.Entry)obj;
		else
			return new JCheckBoxList.Entry(false,obj);
	}

	public int getRowCount()
	{
		return items.size();
	}

	public int getColumnCount()
	{
		return 2;
	}

	public String getColumnName(int col)
	{
		return null;
	}

	public Object getValueAt(int row, int col)
	{
		JCheckBoxList.Entry entry = (JCheckBoxList.Entry)items.elementAt(row);
		switch(col)
		{
		case 0:
			return new Boolean(entry.checked);
		case 1:
			return entry.value;
		default:
			throw new InternalError();
		}
	}

	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
			return Boolean.class;
		case 1:
			return String.class;
		default:
			throw new InternalError();
		}
	}

	public boolean isCellEditable(int row, int col)
	{
		return col == 0;
	}

	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
		{
			((JCheckBoxList.Entry)items.elementAt(row)).checked =
				(value.equals(Boolean.TRUE));
			fireTableRowsUpdated(row,row);
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.options.ColorOptionPane,8,6,0,5,31,20,2,4,1,0.761904762,119,0.666666667,1,0.991017964,0.5,4,12,13.5,1,0.75,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.*;




public class ColorOptionPane extends AbstractOptionPane
{
	public static final EmptyBorder noFocusBorder = new EmptyBorder(1,1,1,1);

	
	public ColorOptionPane()
	{
		super(""color"");
	} 

	

	
	protected void _init()
	{
		setLayout(new BorderLayout());
		add(BorderLayout.CENTER,createColorTableScroller());
	} 

	
	protected void _save()
	{
		colorModel.save();
	} 

	

	
	private ColorTableModel colorModel;
	private JTable colorTable;

	
	private JScrollPane createColorTableScroller()
	{
		colorModel = createColorTableModel();
		colorTable = new JTable(colorModel);
		colorTable.setRowSelectionAllowed(false);
		colorTable.setColumnSelectionAllowed(false);
		colorTable.setCellSelectionEnabled(false);
		colorTable.getTableHeader().setReorderingAllowed(false);
		colorTable.addMouseListener(new MouseHandler());
		TableColumnModel tcm = colorTable.getColumnModel();
 		TableColumn colorColumn = tcm.getColumn(1);
		colorColumn.setCellRenderer(new ColorTableModel.ColorRenderer());
		Dimension d = colorTable.getPreferredSize();
		d.height = Math.min(d.height,100);
		JScrollPane scroller = new JScrollPane(colorTable);
		scroller.setPreferredSize(d);
		return scroller;
	} 

	
	private ColorTableModel createColorTableModel()
	{
		return new ColorTableModel();
	} 

	

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = colorTable.rowAtPoint(evt.getPoint());
			if(row == -1)
				return;

			Color color = JColorChooser.showDialog(
				ColorOptionPane.this,
				jEdit.getProperty(""colorChooser.title""),
				(Color)colorModel.getValueAt(row,1));
			if(color != null)
				colorModel.setValueAt(color,row,1);
		}
	} 
} 


class ColorTableModel extends AbstractTableModel
{
	private Vector colorChoices;

	
	ColorTableModel()
	{
		colorChoices = new Vector(16);
		addColorChoice(""options.color.bgColor"",""view.bgColor"");
		addColorChoice(""options.color.fgColor"",""view.fgColor"");
		addColorChoice(""options.color.caretColor"",""view.caretColor"");
		addColorChoice(""options.color.selectionColor"",
			""view.selectionColor"");
		addColorChoice(""options.color.foldedLineColor"",
			""view.foldedLineColor"");
		addColorChoice(""options.color.lineHighlightColor"",
			""view.lineHighlightColor"");
		addColorChoice(""options.color.bracketHighlightColor"",
			""view.bracketHighlightColor"");
		addColorChoice(""options.color.eolMarkerColor"",
			""view.eolMarkerColor"");
		addColorChoice(""options.color.wrapGuideColor"",
			""view.wrapGuideColor"");
		addColorChoice(""options.color.gutterBgColor"",
			""view.gutter.bgColor"");
		addColorChoice(""options.color.gutterFgColor"",
			""view.gutter.fgColor"");
		addColorChoice(""options.color.gutterHighlightColor"",
			""view.gutter.highlightColor"");
		addColorChoice(""options.color.gutterCurrentLineColor"",
			""view.gutter.currentLineColor"");
		addColorChoice(""options.color.gutterBracketHighlightColor"",
			""view.bracketHighlightColor"");
		addColorChoice(""options.color.gutterMarkerColor"",
			""view.gutter.markerColor"");
		addColorChoice(""options.color.gutterFoldColor"",
			""view.gutter.foldColor"");
		addColorChoice(""options.color.gutterFocusBorderColor"",
			""view.gutter.focusBorderColor"");
		addColorChoice(""options.color.gutterNoFocusBorderColor"",
			""view.gutter.noFocusBorderColor"");
		MiscUtilities.quicksort(colorChoices,new MiscUtilities.StringCompare());
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return colorChoices.size();
	} 

	
	public Object getValueAt(int row, int col)
	{
		ColorChoice ch = (ColorChoice)colorChoices.elementAt(row);
		switch(col)
		{
		case 0:
			return ch.label;
		case 1:
			return ch.color;
		default:
			return null;
		}
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		ColorChoice ch = (ColorChoice)colorChoices.elementAt(row);
		if(col == 1)
			ch.color = (Color)value;
		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.color.object"");
		case 1:
			return jEdit.getProperty(""options.color.color"");
		default:
			return null;
		}
	} 

	
	public void save()
	{
		for(int i = 0; i < colorChoices.size(); i++)
		{
			ColorChoice ch = (ColorChoice)colorChoices
				.elementAt(i);
			jEdit.setColorProperty(ch.property,ch.color);
		}
	} 

	
	private void addColorChoice(String label, String property)
	{
		colorChoices.addElement(new ColorChoice(jEdit.getProperty(label),
			property,jEdit.getColorProperty(property)));
	} 

	
	static class ColorChoice
	{
		String label;
		String property;
		Color color;

		ColorChoice(String label, String property, Color color)
		{
			this.label = label;
			this.property = property;
			this.color = color;
		}

		
		public String toString()
		{
			return label;
		}
	} 

	
	static class ColorRenderer extends JLabel
		implements TableCellRenderer
	{
		
		public ColorRenderer()
		{
			setOpaque(true);
			setBorder(StyleOptionPane.noFocusBorder);
		} 

		
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (isSelected)
			{
				setBackground(table.getSelectionBackground());
				setForeground(table.getSelectionForeground());
			}
			else
			{
				setBackground(table.getBackground());
				setForeground(table.getForeground());
			}

			if (value != null)
				setBackground((Color)value);

			setBorder((cellHasFocus) ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: StyleOptionPane.noFocusBorder);
			return this;
		} 
	} 
} 
"
jEdit,4,org.gjt.sp.jedit.search.BoyerMooreSearchMatcher,7,1,0,6,20,0,1,5,4,0.703703704,347,1.0,1,0.0,0.371428571,0,0,47.28571429,8,3.0,1,"

package org.gjt.sp.jedit.search;


import bsh.NameSpace;
import gnu.regexp.CharIndexed;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.BeanShell;
import org.gjt.sp.util.Log;


public class BoyerMooreSearchMatcher implements SearchMatcher
{
	
	
	public BoyerMooreSearchMatcher(String pattern, String replace,
		boolean ignoreCase, boolean reverseSearch,
		boolean beanshell, String replaceMethod)
	{
		if (ignoreCase)
		{
			this.pattern = pattern.toUpperCase().toCharArray();
		}
		else
		{
			this.pattern = pattern.toCharArray();
		}

		if (reverseSearch)
		{
			char[] tmp = new char[this.pattern.length];
			for (int i = 0; i < tmp.length; i++)
			{
				tmp[i] = this.pattern[this.pattern.length - (i + 1)];
			}
			this.pattern = tmp;
		}

		this.replace = replace;
		this.ignoreCase = ignoreCase;
		this.reverseSearch = reverseSearch;

		if(beanshell && replace != null && replace.length() != 0)
		{
			this.beanshell = true;
			this.replaceMethod = replaceMethod;
			replaceNS = new NameSpace(BeanShell.getNameSpace(),
				""search and replace"");
		}

		generateSkipArray();
		generateSuffixArray();
	} 

	
	
	public int[] nextMatch(CharIndexed text, boolean start, boolean end,
		boolean firstTime)
	{
		int pos = match(text);

		if (pos == -1)
		{
			return null;
		}
		else
		{
			return new int[] { pos, pos + pattern.length };
		}
	} 

	
	
	public String substitute(String text) throws Exception
	{
		if(beanshell)
		{
			replaceNS.setVariable(""_0"",text);
			Object obj = BeanShell.runCachedBlock(replaceMethod,
				null,replaceNS);
			if(obj == null)
				return """";
			else
				return obj.toString();
		}
		else
			return replace;
	} 

	
	
	public int match(CharIndexed text)
	{
		
		int pos;

		
		int anchor = 0;

		
		
		
		
		
		

		
		
		int pattern_end = pattern.length - 1;

		char ch = 0;

		int bad_char;
		int good_suffix;

		
		
		
		
		
		
		
		
		
		
SEARCH:
		while (text.isValid())
		{
			for (pos = pattern_end; pos >= 0; --pos)
			{
				ch = text.charAt(pos);
				if(ignoreCase)
					ch = Character.toUpperCase(ch);

				
				if (ch != pattern[pos])
				{
					

					
					bad_char = pos - skip[getSkipIndex(ch)];

					
					good_suffix = suffix[pos];

					
					
					int skip = (bad_char > good_suffix) ? bad_char : good_suffix;
					anchor += skip;
					text.move(skip);

					
					continue SEARCH;
				}
			}

			
			return anchor;
		}

		
		return -1;
	} 

	
	private char[] pattern;
	private String replace;
	private boolean ignoreCase;
	private boolean reverseSearch;
	private boolean beanshell;
	private String replaceMethod;
	private NameSpace replaceNS;

	
	private int[] skip;
	private int[] suffix;
	

	

	
	
	private void generateSkipArray()
	{
		
		skip = new int[256];

		
		if (pattern.length == 0) return;

		int pos = 0;

		do
		{
			skip[getSkipIndex(pattern[pos])] = pos;
		}
		while (++pos < pattern.length);
	} 

	
	
	private static final int getSkipIndex(char ch)
	{
		return ((int) ch) & 0x000000FF;
	} 

	
	
	private void generateSuffixArray()
	{
		int m = pattern.length;

		int j = m + 1;

		suffix = new int[j];
		int[] tmp = new int[j];
		tmp[m] = j;

		for (int i = m; i > 0; --i)
		{
			while (j <= m && pattern[i - 1] != pattern[j - 1])
			{
				if (suffix[j] == 0)
				{
					suffix[j] = j - i;
				}

				j = tmp[j];
			}

			tmp[i - 1] = --j;
		}

		int k = tmp[0];

		for (j = 0; j <= m; j++)
		{
			
			
			
			if (j > 0)
			{
				suffix[j - 1] = (suffix[j] == 0) ? k : suffix[j];
			}

			if (j == k)
			{
				k = tmp[k];
			}
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.proto.jeditresource.PluginResURLConnection,5,2,0,5,29,2,1,4,4,0.5625,197,1.0,0,0.935483871,0.466666667,1,7,37.6,8,2.2,1,"

package org.gjt.sp.jedit.proto.jeditresource;


import java.io.*;
import java.net.*;
import org.gjt.sp.jedit.*;


public class PluginResURLConnection extends URLConnection
{
	public PluginResURLConnection(URL url)
		throws IOException
	{
		super(url);

		String file = url.getFile();

		int index = file.indexOf('!',0);
		if(index == -1)
		{
			plugin = null;
			resource = file;
		}
		else
		{
			int start;
			if(file.charAt(0) == '/')
				start = 1;
			else
				start = 0;

			plugin = file.substring(start,index);
			resource = file.substring(index + 1);
		}

		if(plugin != null && resource.startsWith(""/""))
			resource = resource.substring(1);
	}

	public void connect() throws IOException
	{
		if(!connected)
		{
			if(plugin == null)
			{
				in = jEdit.class.getResourceAsStream(resource);
			}
			else
			{
				EditPlugin.JAR[] plugins = jEdit.getPluginJARs();
				for(int i = 0; i < plugins.length; i++)
				{
					EditPlugin.JAR jar = plugins[i];
					if(MiscUtilities.getFileName(jar.getPath())
						.equalsIgnoreCase(plugin))
					{
						in = jar.getClassLoader()
							.getResourceAsStream(
							resource);
						break;
					}
				}
			}

			if(in == null)
			{
				throw new IOException(""Resource not found: ""
					+ resource);
			}

			connected = true;
		}
	}

	public InputStream getInputStream()
		throws IOException
	{
		connect();
		return in;
	}

	public String getHeaderField(String name)
	{
		if(name.equals(""content-type""))
		{
			String lcResource = resource.toLowerCase();
			if(lcResource.endsWith("".html""))
				return ""text/html"";
			else if(lcResource.endsWith("".txt""))
				return ""text/plain"";
			else if(lcResource.endsWith("".rtf""))
				return ""text/rtf"";
			else if(lcResource.endsWith("".gif""))
				return ""image/gif"";
			else if(lcResource.endsWith("".jpg"")
				|| lcResource.endsWith("".jpeg""))
				return ""image/jpeg"";
			else
				return null;
		}
		else
			return null;
	}

	
	private InputStream in;
	private String plugin;
	private String resource;
}
"
jEdit,4,org.gjt.sp.jedit.Buffer,150,1,0,117,337,10339,93,46,116,0.936533411,4593,0.760869565,13,0.0,0.080909091,0,0,29.31333333,30,3.44,18,"

package org.gjt.sp.jedit;


import gnu.regexp.*;
import javax.swing.*;
import javax.swing.event.*;
import javax.swing.text.*;
import java.awt.Toolkit;
import java.io.File;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.search.RESearchMatcher;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.*;



public class Buffer implements EBComponent
{
	
	
	public static final String LINESEP = ""lineSeparator"";

	
	public static final String BACKED_UP = ""Buffer__backedUp"";

	
	public static final String CARET = ""Buffer__caret"";
	public static final String SELECTION = ""Buffer__selection"";

	
	public static final String SCROLL_VERT = ""Buffer__scrollVert"";
	public static final String SCROLL_HORIZ = ""Buffer__scrollHoriz"";

	
	public static final String ENCODING = ""encoding"";

	
	public static final String TRAILING_EOL = ""trailingEOL"";

	
	public static final String GZIPPED = ""gzipped"";
	

	

	
	
	public void showInsertFileDialog(View view)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,null,
			VFSBrowser.OPEN_DIALOG,false);

		if(files != null)
			insertFile(view,files[0]);
	} 

	
	
	public void reload(View view)
	{
		if(getFlag(DIRTY))
		{
			String[] args = { name };
			int result = GUIUtilities.confirm(view,""changedreload"",
				args,JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}

		view.getEditPane().saveCaretInfo();
		load(view,true);
	} 

	
	
	public boolean load(final View view, final boolean reload)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}

		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);

		setFlag(LOADING,true);

		
		
		
		if(!getFlag(TEMPORARY))
			EditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));

		final boolean loadAutosave;

		if(reload || !getFlag(NEW_FILE))
		{
			if(file != null)
				modTime = file.lastModified();

			
			if(!reload && autosaveFile != null && autosaveFile.exists())
				loadAutosave = recoverAutosave(view);
			else
			{
				if(autosaveFile != null)
					autosaveFile.delete();
				loadAutosave = false;
			}

			if(!loadAutosave)
			{
				
				
				
				if(!vfs.load(view,this,path))
				{
					setFlag(LOADING,false);
					return false;
				}
			}
		}
		else
			loadAutosave = false;

		
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				String newPath = getStringProperty(
					BufferIORequest.NEW_PATH);
				Segment seg = (Segment)getProperty(
					BufferIORequest.LOAD_DATA);
				IntegerArray endOffsets = (IntegerArray)
					getProperty(BufferIORequest.END_OFFSETS);

				
				
				boolean readOnly = isReadOnly();
				setFlag(READ_ONLY,false);

				
				remove(0,getLength());

				if(seg != null && endOffsets != null)
				{
					
					try
					{
						writeLock();

						
						
						
						contentMgr._setContent(seg.array,seg.count);

						contentInserted(0,seg.count,endOffsets);
					}
					catch(OutOfMemoryError oom)
					{
						Log.log(Log.ERROR,this,oom);
						VFSManager.error(view,path,""out-of-memory-error"",null);
					}
					finally
					{
						writeUnlock();
					}
				}

				setFlag(READ_ONLY,readOnly);

				unsetProperty(BufferIORequest.LOAD_DATA);
				unsetProperty(BufferIORequest.END_OFFSETS);
				unsetProperty(BufferIORequest.NEW_PATH);

				undoMgr.clear();
				undoMgr.setLimit(jEdit.getIntegerProperty(
					""buffer.undoCount"",100));

				if(!getFlag(TEMPORARY))
					finishLoading();

				
				fireContentInserted(0,0,getLineCount(),getLength() - 1);

				setFlag(LOADING,false);

				
				if(reload)
					setDirty(false);

				if(!loadAutosave && newPath != null && !path.equals(newPath))
					setPath(newPath);

				
				

				
				
				
				
				
				
				if(loadAutosave)
					setFlag(DIRTY,true);

				
				if(!getFlag(TEMPORARY))
				{
					EditBus.send(new BufferUpdate(Buffer.this,
						view,BufferUpdate.LOADED));
					EditBus.send(new BufferUpdate(Buffer.this,
						view,BufferUpdate.MARKERS_CHANGED));
				}
			}
		}; 

		if(getFlag(TEMPORARY))
			runnable.run();
		else
			VFSManager.runInAWTThread(runnable);

		return true;
	} 

	
	
	public boolean insertFile(final View view, String path)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}

		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);

		path = MiscUtilities.constructPath(this.path,path);

		Buffer buffer = jEdit.getBuffer(path);
		if(buffer != null)
		{
			view.getTextArea().setSelectedText(
				buffer.getText(0,buffer.getLength()));
			return true;
		}

		VFS vfs = VFSManager.getVFSForPath(path);

		setFlag(IO,true);

		
		
		
		if(!vfs.insert(view,this,path))
		{
			setFlag(IO,false);
			return false;
		}

		
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				setFlag(IO,false);

				SegmentBuffer sbuf = (SegmentBuffer)getProperty(
					BufferIORequest.LOAD_DATA);
				if(sbuf != null)
				{
					unsetProperty(BufferIORequest.LOAD_DATA);

					view.getTextArea().setSelectedText(sbuf.toString());
				}
			}
		});

		return true;
	} 

	
	
	public void autosave()
	{
		if(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)
			|| !getFlag(DIRTY)
			|| getFlag(LOADING)
			|| getFlag(IO))
			return;

		setFlag(AUTOSAVE_DIRTY,false);

		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.AUTOSAVE,null,this,null,
			VFSManager.getFileVFS(),autosaveFile.getPath()));
	} 

	
	
	public boolean saveAs(View view, boolean rename)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,path,
			VFSBrowser.SAVE_DIALOG,false);

		
		
		if(files == null)
			return false;

		return save(view,files[0],rename);
	} 

	
	
	public boolean save(View view, String path)
	{
		return save(view,path,true);
	} 

	
	
	public boolean save(final View view, String path, final boolean rename)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}

		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);

		if(path == null && getFlag(NEW_FILE))
			return saveAs(view,rename);

		if(path == null && file != null)
		{
			long newModTime = file.lastModified();

			if(newModTime != modTime)
			{
				Object[] args = { this.path };
				int result = GUIUtilities.confirm(view,
					""filechanged-save"",args,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.WARNING_MESSAGE);
				if(result != JOptionPane.YES_OPTION)
					return false;
			}
		}

		setFlag(IO,true);
		EditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));

		final String oldPath = this.path;
		final String newPath = (path == null ? this.path : path);

		VFS vfs = VFSManager.getVFSForPath(newPath);

		if(!vfs.save(view,this,newPath))
		{
			setFlag(IO,false);
			return false;
		}

		
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				setFlag(IO,false);
				finishSaving(view,oldPath,newPath,rename,
					getBooleanProperty(BufferIORequest
					.ERROR_OCCURRED));
			}
		});

		return true;
	} 

	
	
	public void checkModTime(View view)
	{
		
		
		
		if(file == null || getFlag(NEW_FILE) || getFlag(IO))
			return;

		boolean newReadOnly = (file.exists() && !file.canWrite());
		if(newReadOnly != getFlag(READ_ONLY))
		{
			setFlag(READ_ONLY,newReadOnly);
			EditBus.send(new BufferUpdate(this,
				view,BufferUpdate.DIRTY_CHANGED));
		}

		if(!jEdit.getBooleanProperty(""view.checkModStatus""))
			return;

		long oldModTime = modTime;
		long newModTime = file.lastModified();

		if(newModTime != oldModTime)
		{
			modTime = newModTime;

			if(!file.exists())
			{
				setFlag(NEW_FILE,true);
				EditBus.send(new BufferUpdate(this,
					view,BufferUpdate.DIRTY_CHANGED));
				Object[] args = { path };
				GUIUtilities.message(view,""filedeleted"",args);
				return;
			}

			String prop = (isDirty() ? ""filechanged-dirty""
				: ""filechanged-focus"");

			Object[] args = { path };
			int result = GUIUtilities.confirm(view,
				prop,args,JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result == JOptionPane.YES_OPTION)
			{
				view.getEditPane().saveCaretInfo();
				load(view,true);
			}
		}
	} 

	

	

	
	
	public long getLastModified()
	{
		return modTime;
	} 

	
	
	public void setLastModified(long modTime)
	{
		this.modTime = modTime;
	} 

	
	
	public VFS getVFS()
	{
		return vfs;
	} 

	
	
	public final File getFile()
	{
		return file;
	} 

	
	
	public final File getAutosaveFile()
	{
		return autosaveFile;
	} 

	
	
	public final String getName()
	{
		return name;
	} 

	
	
	public final String getPath()
	{
		return path;
	} 

	
	
	public final boolean isClosed()
	{
		return getFlag(CLOSED);
	} 

	
	
	public final boolean isLoaded()
	{
		return !getFlag(LOADING);
	} 

	
	
	public final boolean isPerformingIO()
	{
		return getFlag(LOADING) || getFlag(IO);
	} 

	
	
	public final boolean isNewFile()
	{
		return getFlag(NEW_FILE);
	} 

	
	
	public final void setNewFile(boolean newFile)
	{
		setFlag(NEW_FILE,newFile);
		if(!newFile)
			setFlag(UNTITLED,false);
	} 

	
	
	public final boolean isUntitled()
	{
		return getFlag(UNTITLED);
	} 

	
	
	public final boolean isDirty()
	{
		return getFlag(DIRTY);
	} 

	
	
	public final boolean isReadOnly()
	{
		return getFlag(READ_ONLY);
	} 

	
	
	public final boolean isEditable()
	{
		return !(getFlag(READ_ONLY) || getFlag(IO) || getFlag(LOADING));
	} 

	
	
	public final void setReadOnly(boolean readOnly)
	{
		setFlag(READ_ONLY,readOnly);
	} 

	
	
	public void setDirty(boolean d)
	{
		boolean old_d = getFlag(DIRTY);

		if(d)
		{
			if(getFlag(LOADING) || getFlag(READ_ONLY))
				return;
			if(getFlag(DIRTY) && getFlag(AUTOSAVE_DIRTY))
				return;
			setFlag(DIRTY,true);
			setFlag(AUTOSAVE_DIRTY,true);
		}
		else
		{
			setFlag(DIRTY,false);
			setFlag(AUTOSAVE_DIRTY,false);

			
			
			undoMgr.bufferSaved();
		}

		if(d != old_d)
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.DIRTY_CHANGED));
		}
	} 

	
	
	public boolean isTemporary()
	{
		return getFlag(TEMPORARY);
	} 

	
	
	public Icon getIcon()
	{
		if(getFlag(DIRTY))
			return GUIUtilities.DIRTY_BUFFER_ICON;
		else if(getFlag(READ_ONLY))
			return GUIUtilities.READ_ONLY_BUFFER_ICON;
		else if(getFlag(NEW_FILE))
			return GUIUtilities.NEW_BUFFER_ICON;
		else
			return GUIUtilities.NORMAL_BUFFER_ICON;
	} 

	

	

	
	
	public final void readLock()
	{
		lock.readLock();
	} 

	
	
	public final void readUnlock()
	{
		lock.readUnlock();
	} 

	
	
	public final void writeLock()
	{
		lock.writeLock();
	} 

	
	
	public final void writeUnlock()
	{
		lock.writeUnlock();
	} 

	

	

	
	
	public int getLength()
	{
		
		return contentMgr.getLength();
	} 

	
	
	public int getLineCount()
	{
		
		return offsetMgr.getLineCount();
	} 

	
	
	public final int getLineOfOffset(int offset)
	{
		try
		{
			readLock();

			if(offset < 0 || offset > getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			return offsetMgr.getLineOfOffset(offset);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getLineStartOffset(int line)
	{
		try
		{
			readLock();

			if(line < 0 || line >= offsetMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);
			else if(line == 0)
				return 0;

			return offsetMgr.getLineEndOffset(line - 1);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getLineEndOffset(int line)
	{
		try
		{
			readLock();

			if(line < 0 || line >= offsetMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);

			return offsetMgr.getLineEndOffset(line);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getLineLength(int line)
	{
		try
		{
			readLock();

			return getLineEndOffset(line)
				- getLineStartOffset(line) - 1;
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public String getLineText(int lineIndex)
	{
		try
		{
			readLock();

			return getText(getLineStartOffset(lineIndex),
				getLineLength(lineIndex));
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public void getLineText(int lineIndex, Segment segment)
	{
		try
		{
			readLock();

			getText(getLineStartOffset(lineIndex),
				getLineLength(lineIndex),segment);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public String getText(int start, int length)
	{
		try
		{
			readLock();

			if(start < 0 || length < 0
				|| start + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(start + "":"" + length);

			return contentMgr.getText(start,length);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public void getText(int start, int length, Segment seg)
	{
		try
		{
			readLock();

			if(start < 0 || length < 0
				|| start + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(start + "":"" + length);

			contentMgr.getText(start,length,seg);
		}
		finally
		{
			readUnlock();
		}
	} 

	

	

	
	
	public void insert(int offset, String str)
	{
		if(str == null || str.length() == 0)
			return;

		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");

		try
		{
			writeLock();

			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			contentMgr.insert(offset,str);

			integerArray.clear();

			for(int i = 0; i < str.length(); i++)
			{
				if(str.charAt(i) == '\n')
					integerArray.add(i);
			}

			if(!getFlag(UNDO_IN_PROGRESS))
			{
				undoMgr.contentInserted(offset,str.length(),str,
					!getFlag(DIRTY));
			}

			contentInserted(offset,str.length(),integerArray);
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public void insert(int offset, Segment seg)
	{
		if(seg.count == 0)
			return;

		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");

		try
		{
			writeLock();

			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			contentMgr.insert(offset,seg);

			integerArray.clear();

			for(int i = 0; i < seg.count; i++)
			{
				if(seg.array[seg.offset + i] == '\n')
					integerArray.add(i);
			}

			if(!getFlag(UNDO_IN_PROGRESS))
			{
				undoMgr.contentInserted(offset,seg.count,
					seg.toString(),!getFlag(DIRTY));
			}

			contentInserted(offset,seg.count,integerArray);
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public void remove(int offset, int length)
	{
		if(length == 0)
			return;

		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");

		try
		{
			writeLock();

			if(offset < 0 || length < 0
				|| offset + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset + "":"" + length);

			int startLine = offsetMgr.getLineOfOffset(offset);

			contentMgr.getText(offset,length,seg);
			int numLines = 0;
			for(int i = 0; i < seg.count; i++)
			{
				if(seg.array[seg.offset + i] == '\n')
					numLines++;
			}

			if(!getFlag(UNDO_IN_PROGRESS))
			{
				undoMgr.contentRemoved(offset,length,
					seg.toString(),!getFlag(DIRTY));
			}

			contentMgr.remove(offset,length);

			if(lastTokenizedLine >= startLine)
				lastTokenizedLine = -1;

			offsetMgr.contentRemoved(startLine,offset,numLines,length);

			if(numLines > 0)
			{
				for(int i = 0; i < inUseFVMs.length; i++)
				{
					if(inUseFVMs[i] != null)
						inUseFVMs[i]._invalidate(startLine);
				}
			}

			fireContentRemoved(startLine,offset,numLines,length);

			setDirty(true);
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public void removeTrailingWhiteSpace(int[] lines)
	{
		try
		{
			beginCompoundEdit();

			for(int i = 0; i < lines.length; i++)
			{
				int pos, lineStart, lineEnd, tail;

				getLineText(lines[i],seg);

				
				if (seg.count == 0) continue;

				lineStart = seg.offset;
				lineEnd = seg.offset + seg.count - 1;

				for (pos = lineEnd; pos >= lineStart; pos--)
				{
					if (!Character.isWhitespace(seg.array[pos]))
						break;
				}

				tail = lineEnd - pos;

				
				if (tail == 0) continue;

				remove(getLineEndOffset(lines[i]) - 1 - tail,tail);
			}
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public void shiftIndentLeft(int[] lines)
	{
		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		boolean noTabs = getBooleanProperty(""noTabs"");

		try
		{
			beginCompoundEdit();

			for(int i = 0; i < lines.length; i++)
			{
				int lineStart = getLineStartOffset(lines[i]);
				String line = getLineText(lines[i]);
				int whiteSpace = MiscUtilities
					.getLeadingWhiteSpace(line);
				if(whiteSpace == 0)
					continue;
				int whiteSpaceWidth = Math.max(0,MiscUtilities
					.getLeadingWhiteSpaceWidth(line,tabSize)
					- indentSize);
	
				insert(lineStart + whiteSpace,MiscUtilities
					.createWhiteSpace(whiteSpaceWidth,
					(noTabs ? 0 : tabSize)));
				remove(lineStart,whiteSpace);
			}

		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public void shiftIndentRight(int[] lines)
	{
		try
		{
			beginCompoundEdit();

			int tabSize = getTabSize();
			int indentSize = getIndentSize();
			boolean noTabs = getBooleanProperty(""noTabs"");
			for(int i = 0; i < lines.length; i++)
			{
				int lineStart = getLineStartOffset(lines[i]);
				String line = getLineText(lines[i]);
				int whiteSpace = MiscUtilities
					.getLeadingWhiteSpace(line);

				
				
				

				int whiteSpaceWidth = MiscUtilities
					.getLeadingWhiteSpaceWidth(
					line,tabSize) + indentSize;
				insert(lineStart + whiteSpace,MiscUtilities
					.createWhiteSpace(whiteSpaceWidth,
					(noTabs ? 0 : tabSize)));
				remove(lineStart,whiteSpace);
			}
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	

	

	
	
	public void undo(JEditTextArea textArea)
	{
		if(undoMgr == null)
			return;

		if(!isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		try
		{
			writeLock();

			setFlag(UNDO_IN_PROGRESS,true);
			if(!undoMgr.undo(textArea))
				textArea.getToolkit().beep();

			fireTransactionComplete();
		}
		finally
		{
			setFlag(UNDO_IN_PROGRESS,false);

			writeUnlock();
		}
	} 

	
	
	public void redo(JEditTextArea textArea)
	{
		if(undoMgr == null)
			return;

		if(!isEditable())
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}

		try
		{
			writeLock();

			setFlag(UNDO_IN_PROGRESS,true);
			if(!undoMgr.redo(textArea))
				textArea.getToolkit().beep();

			fireTransactionComplete();
		}
		finally
		{
			setFlag(UNDO_IN_PROGRESS,false);

			writeUnlock();
		}
	} 

	
	
	public boolean isTransactionInProgress()
	{
		return getFlag(UNDO_IN_PROGRESS) || insideCompoundEdit();
	} 

	
	
	public void beginCompoundEdit()
	{
		if(getFlag(TEMPORARY))
			return;

		try
		{
			writeLock();

			undoMgr.beginCompoundEdit();
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public void endCompoundEdit()
	{
		if(getFlag(TEMPORARY))
			return;

		try
		{
			writeLock();

			undoMgr.endCompoundEdit();

			fireTransactionComplete();
		}
		finally
		{
			writeUnlock();
		}
	}

	
	
	public boolean insideCompoundEdit()
	{
		return undoMgr.insideCompoundEdit();
	} 

	

	

	
	
	public void addBufferChangeListener(BufferChangeListener listener)
	{
		bufferListeners.addElement(listener);
	} 

	
	
	public void removeBufferChangeListener(BufferChangeListener listener)
	{
		bufferListeners.removeElement(listener);
	} 

	

	

	
	
	public void propertiesChanged()
	{
		parseFully = jEdit.getBooleanProperty(""parseFully"");

		setTokenMarker(mode.getTokenMarker());

		String folding = getStringProperty(""folding"");
		FoldHandler handler = FoldHandler.getFoldHandler(folding);

		if(handler != null)
		{
			setFoldHandler(handler);
		}
		else
		{
			if (folding != null)
				Log.log(Log.WARNING, this, path + "": invalid 'folding' property: "" + folding); 
			setFoldHandler(new DummyFoldHandler());
		}
	} 

	
	
	public int getTabSize()
	{
		return getIntegerProperty(""tabSize"",8);
	} 

	
	
	public final int getIndentSize()
	{
		return getIntegerProperty(""indentSize"",8);
	} 

	
	
	public Object getProperty(Object name)
	{
		
		Object o = properties.get(name);
		if(o != null)
			return o;

		
		if(!(name instanceof String))
			return null;

		
		if(mode != null)
			return mode.getProperty((String)name);
		else
		{
			
			String value = jEdit.getProperty(""buffer."" + name);
			if(value == null)
				return null;

			
			try
			{
				return new Integer(value);
			}
			catch(NumberFormatException nf)
			{
				return value;
			}
		}
	} 

	
	
	public void setProperty(String name, Object value)
	{
		putProperty(name,value);
	} 

	
	
	public void unsetProperty(String name)
	{
		properties.remove(name);
	} 

	
	
	public String getStringProperty(String name)
	{
		Object obj = getProperty(name);
		if(obj != null)
			return obj.toString();
		else
			return null;
	} 

	
	
	public void setStringProperty(String name, String value)
	{
		setProperty(name,value);
	} 

	
	
	public boolean getBooleanProperty(String name)
	{
		Object obj = getProperty(name);
		if(obj instanceof Boolean)
			return ((Boolean)obj).booleanValue();
		else if(""true"".equals(obj) || ""on"".equals(obj) || ""yes"".equals(obj))
			return true;
		else
			return false;
	} 

	
	
	public void setBooleanProperty(String name, boolean value)
	{
		setProperty(name,value ? Boolean.TRUE : Boolean.FALSE);
	} 

	
	
	public int getIntegerProperty(String name, int defaultValue)
	{
		Object obj = getProperty(name);
		if(obj instanceof Number)
			return ((Number)obj).intValue();
		else
		{
			try
			{
				int value = Integer.parseInt(getStringProperty(name));
				properties.put(name,new Integer(value));
				return value;
			}
			catch(Exception e)
			{
				return defaultValue;
			}
		}
	} 

	
	
	public void setIntegerProperty(String name, int value)
	{
		setProperty(name,new Integer(value));
	} 

	
	
	public KeywordMap getKeywordMapAtOffset(int offset)
	{
		return getRuleSetAtOffset(offset).getKeywords();
	} 

	
	
	public String getContextSensitiveProperty(int offset, String name)
	{
		ParserRuleSet rules = getRuleSetAtOffset(offset);

		Object value = null;

		Hashtable rulesetProps = rules.getProperties();
		if(rulesetProps != null)
			value = rulesetProps.get(name);

		if(value == null)
		{
			value = rules.getMode().getProperty(name);

			if(value == null)
				value = mode.getProperty(name);
		}

		if(value == null)
			return null;
		else
			return String.valueOf(value);
	} 

	

	

	
	
	public final Mode getMode()
	{
		return mode;
	} 

	
	
	public void setMode(Mode mode)
	{
		
		if(mode == null)
			throw new NullPointerException(""Mode must be non-null"");

		
		
		
		

		
		if(getProperty(""tabSize"")
			.equals(mode.getProperty(""tabSize"")))
			unsetProperty(""tabSize"");

		if(getProperty(""indentSize"")
			.equals(mode.getProperty(""indentSize"")))
			unsetProperty(""indentSize"");

		if(getProperty(""maxLineLen"")
			.equals(mode.getProperty(""maxLineLen"")))
			unsetProperty(""maxLineLen"");
		

		Mode oldMode = this.mode;

		this.mode = mode;

		
		putProperty(""tabSize"",getProperty(""tabSize""));
		putProperty(""indentSize"",getProperty(""indentSize""));
		putProperty(""maxLineLen"",getProperty(""maxLineLen""));
		

		propertiesChanged(); 

		
		if(oldMode != null && !getFlag(TEMPORARY))
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MODE_CHANGED));
		}
	} 

	
	
	public void setMode()
	{
		String userMode = getStringProperty(""mode"");
		if(userMode != null)
		{
			Mode m = jEdit.getMode(userMode);
			if(m != null)
			{
				setMode(m);
				return;
			}
		}

		String nogzName = name.substring(0,name.length() -
			(name.endsWith("".gz"") ? 3 : 0));
		Mode[] modes = jEdit.getModes();

		String firstLine = getLineText(0);

		for(int i = 0; i < modes.length; i++)
		{
			if(modes[i].accept(nogzName,firstLine))
			{
				setMode(modes[i]);
				return;
			}
		}

		Mode defaultMode = jEdit.getMode(jEdit.getProperty(""buffer.defaultMode""));
		if(defaultMode == null)
			defaultMode = jEdit.getMode(""text"");
		setMode(defaultMode);
	} 

	
	
	public boolean indentLine(int lineIndex, boolean canIncreaseIndent,
		boolean canDecreaseIndent)
	{
		if(lineIndex == 0)
			return false;

		
		String openBrackets = (String)getProperty(""indentOpenBrackets"");
		String closeBrackets = (String)getProperty(""indentCloseBrackets"");
		String _indentPrevLine = (String)getProperty(""indentPrevLine"");
		boolean doubleBracketIndent = getBooleanProperty(""doubleBracketIndent"");
		RE indentPrevLineRE = null;
		if(openBrackets == null)
			openBrackets = """";
		if(closeBrackets == null)
			closeBrackets = """";
		if(_indentPrevLine != null)
		{
			try
			{
				indentPrevLineRE = new RE(_indentPrevLine,
					RE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);
			}
			catch(REException re)
			{
				Log.log(Log.ERROR,this,""Invalid 'indentPrevLine'""
					+ "" regexp: "" + _indentPrevLine);
				Log.log(Log.ERROR,this,re);
			}
		}

		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		boolean noTabs = getBooleanProperty(""noTabs"");

		Element map = getDefaultRootElement();

		String prevLine = null;
		String line = null;

		Element lineElement = map.getElement(lineIndex);
		int start = lineElement.getStartOffset();

		
		line = getText(start,lineElement.getEndOffset() - start - 1);

		for(int i = lineIndex - 1; i >= 0; i--)
		{
			lineElement = map.getElement(i);
			int lineStart = lineElement.getStartOffset();
			int len = lineElement.getEndOffset() - lineStart - 1;
			if(len != 0)
			{
				prevLine = getText(lineStart,len);
				break;
			}
		}

		if(prevLine == null)
			return false;

		
		boolean prevLineMatches = (indentPrevLineRE == null ? false
			: indentPrevLineRE.isMatch(prevLine));

		
		boolean prevLineStart = true; 
		int prevLineIndent = 0; 
		int prevLineBrackets = 0; 
		for(int i = 0; i < prevLine.length(); i++)
		{
			char c = prevLine.charAt(i);
			switch(c)
			{
			case ' ':
				if(prevLineStart)
					prevLineIndent++;
				break;
			case '\t':
				if(prevLineStart)
				{
					prevLineIndent += (tabSize
						- (prevLineIndent
						% tabSize));
				}
				break;
			default:
				prevLineStart = false;
				if(closeBrackets.indexOf(c) != -1)
					prevLineBrackets = Math.max(
						prevLineBrackets-1,0);
				else if(openBrackets.indexOf(c) != -1)
				{
					
					if(!doubleBracketIndent)
						prevLineMatches = false;
					prevLineBrackets++;
				}
				break;
			}
		}

		
		
		
		if(prevLineBrackets == 3)
			prevLineBrackets = 0;

		
		boolean lineStart = true; 
		int lineIndent = 0; 
		int lineWidth = 0; 
		int lineBrackets = 0; 
		int closeBracketIndex = -1; 
			
		for(int i = 0; i < line.length(); i++)
		{
			char c = line.charAt(i);
			switch(c)
			{
			case ' ':
				if(lineStart)
				{
					lineIndent++;
					lineWidth++;
				}
				break;
			case '\t':
				if(lineStart)
				{
					lineIndent += (tabSize
						- (lineIndent
						% tabSize));
					lineWidth++;
				}
				break;
			default:
				lineStart = false;
				if(closeBrackets.indexOf(c) != -1)
				{
					if(lineBrackets == 0)
						closeBracketIndex = i;
					else
						lineBrackets--;
				}
				else if(openBrackets.indexOf(c) != -1)
				{
					if(!doubleBracketIndent)
						prevLineMatches = false;
					lineBrackets++;
				}

				break;
			}
		}

		
		
		
		if(lineBrackets == 3)
		{
			closeBracketIndex = -1;
			lineBrackets = 0;
		}

		if(closeBracketIndex != -1)
		{
			int offset = TextUtilities.findMatchingBracket(
				this,lineIndex,closeBracketIndex);
			if(offset != -1)
			{
				lineElement = map.getElement(map.getElementIndex(
					offset));
				int startOffset = lineElement.getStartOffset();
				String closeLine = getText(startOffset,
					lineElement.getEndOffset() - startOffset - 1);
				prevLineIndent = MiscUtilities
					.getLeadingWhiteSpaceWidth(
					closeLine,tabSize);
			}
			else
				return false;
		}
		else
		{
			prevLineIndent += (prevLineBrackets * indentSize);
		}

		if(prevLineMatches)
			prevLineIndent += indentSize;

		if(!canDecreaseIndent && prevLineIndent <= lineIndent)
			return false;

		if(!canIncreaseIndent && prevLineIndent >= lineIndent)
			return false;

		
		try
		{
			beginCompoundEdit();

			remove(start,lineWidth);
			insert(start,MiscUtilities.createWhiteSpace(
				prevLineIndent,(noTabs ? 0 : tabSize)));
		}
		finally
		{
			endCompoundEdit();
		}

		return true;
	} 

	
	
	public void indentLines(int start, int end)
	{
		try
		{
			beginCompoundEdit();
			for(int i = start; i <= end; i++)
				indentLine(i,true,true);
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public void indentLines(int[] lines)
	{
		try
		{
			beginCompoundEdit();
			for(int i = 0; i < lines.length; i++)
				indentLine(lines[i],true,true);
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public TokenList markTokens(int lineIndex)
	{
		try
		{
			writeLock();

			if(lineIndex < 0 || lineIndex >= offsetMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(lineIndex);

			
			if(lastTokenizedLine == lineIndex)
				return tokenList;

			
			int start, end;
			if(parseFully)
			{
				start = -1;
				end = 0;
			}
			else
			{
				start = Math.max(0,lineIndex - 100) - 1;
				end = Math.max(0,lineIndex - 100);
			}

			for(int i = lineIndex - 1; i > end; i--)
			{
				if(offsetMgr.isLineContextValid(i))
				{
					start = i;
					break;
				}
			}

			for(int i = start + 1; i <= lineIndex; i++)
			{
				getLineText(i,seg);

				TokenMarker.LineContext prevContext = (i == 0 ? null
					: offsetMgr.getLineContext(i - 1));

				
				tokenList.lastToken = null;

				TokenMarker.LineContext context = offsetMgr.getLineContext(i);
				ParserRule oldRule;
				ParserRuleSet oldRules;
				if(context == null)
				{
					oldRule = null;
					oldRules = null;
				}
				else
				{
					oldRule = context.inRule;
					oldRules = context.rules;
				}

				context = tokenMarker.markTokens(prevContext,tokenList,seg);
				offsetMgr.setLineContext(i,context);

				
				
				
				if(oldRule != context.inRule)
					nextLineRequested = true;
				else if(oldRules != context.rules)
					nextLineRequested = true;
				
				
			}

			lastTokenizedLine = lineIndex;

			int lineCount = offsetMgr.getLineCount();
			if(nextLineRequested && lineCount - lineIndex > 1)
			{
				offsetMgr.lineInfoChangedFrom(lineIndex + 1);
			}

			return tokenList;
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public boolean isNextLineRequested()
	{
		boolean retVal = nextLineRequested;
		nextLineRequested = false;
		return retVal;
	} 

	
	
	public TokenMarker getTokenMarker()
	{
		return tokenMarker;
	} 

	

	

	
	
	public void addDocumentListener(DocumentListener l)
	{
		Log.log(Log.WARNING,this,""Document listeners not supported: ""
			+ l.getClass().getName());
	} 

	
	
	public void removeDocumentListener(DocumentListener l)
	{
		Log.log(Log.WARNING,this,""Document listeners not supported: ""
			+ l.getClass().getName());
	} 

	
	
	public void putProperty(Object name, Object value)
	{
		if(value == null)
			properties.remove(name);
		else
			properties.put(name,value);
	} 

	
	
	public void putBooleanProperty(String name, boolean value)
	{
		setBooleanProperty(name,value);
	} 

	
	
	public final boolean isSaving()
	{
		return getFlag(IO);
	} 

	
	
	public void tokenizeLines() {} 

	
	
	public void tokenizeLines(int start, int len)
	{
	} 

	
	
	public boolean isLineVisible(int line)
	{
		return true;
	} 

	
	
	public int getVirtualLineCount()
	{
		return offsetMgr.getLineCount();
	} 

	
	
	public int getPrevVisibleLine(int lineNo)
	{
		return lineNo - 1;
	} 

	
	
	public int getNextVisibleLine(int lineNo)
	{
		if(lineNo >= offsetMgr.getLineCount() - 1)
			return -1;
		else
			return lineNo + 1;
	} 

	
	
	public int virtualToPhysical(int lineNo)
	{
		return lineNo;
	} 

	
	
	public int physicalToVirtual(int lineNo)
	{
		return lineNo;
	} 

	
	
	public Element[] getRootElements()
	{
		return new Element[] { getDefaultRootElement() };
	} 

	
	
	public Element getParagraphElement(int offset)
	{
		return new LineElement(this,getLineOfOffset(offset));
	} 

	
	
	public Element getDefaultRootElement()
	{
		return new RootElement(this);
	} 

	
	
	public void insertString(int offset, String str, AttributeSet attr)
	{
		insert(offset,str);
	} 

	

	

	
	
	public boolean isFoldStart(int line)
	{
		return (line != getLineCount() - 1
			&& getFoldLevel(line) < getFoldLevel(line + 1));
	} 

	
	
	public int getFoldLevel(int line)
	{
		try
		{
			writeLock();

			if(line < 0 || line >= offsetMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);

			if(offsetMgr.isFoldLevelValid(line))
			{
				
				
				return offsetMgr.getFoldLevel(line);
			}
			else
			{
				int start = 0;
				for(int i = line - 1; i >= 0; i--)
				{
					if(offsetMgr.isFoldLevelValid(i))
					{
						start = i + 1;
						break;
					}
				}

				int newFoldLevel = 0;
				boolean changed = false;

				for(int i = start; i <= line; i++)
				{
					newFoldLevel = foldHandler.getFoldLevel(this,i,seg);
					if(newFoldLevel != offsetMgr.getFoldLevel(i))
						changed = true;
					offsetMgr.setFoldLevel(i,newFoldLevel);
				}

				if(changed && !getFlag(INSIDE_INSERT))
				{
					
					fireFoldLevelChanged(start,line);
				}

				return newFoldLevel;
			}
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public int[] getFoldAtLine(int line)
	{
		int start, end;

		if(isFoldStart(line))
		{
			start = line;
			int foldLevel = getFoldLevel(line);

			line++;

			while(getFoldLevel(line) > foldLevel)
			{
				line++;

				if(line == getLineCount())
					break;
			}

			end = line - 1;
		}
		else
		{
			start = line;
			int foldLevel = getFoldLevel(line);
			while(getFoldLevel(start) >= foldLevel)
			{
				if(start == 0)
					break;
				else
					start--;
			}

			end = line;
			while(getFoldLevel(end) >= foldLevel)
			{
				end++;

				if(end == getLineCount())
					break;
			}

			end--;
		}

		while(getLineLength(end) == 0 && end > start)
			end--;

		return new int[] { start, end };
	} 

	

	

	
	
	public Position createPosition(int offset)
	{
		try
		{
			readLock();

			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			return offsetMgr.createPosition(offset);
		}
		finally
		{
			readUnlock();
		}
	} 

	

	

	
	
	public final Vector getMarkers()
	{
		return markers;
	} 

	
	
	public void addOrRemoveMarker(char shortcut, int pos)
	{
		int line = getLineOfOffset(pos);
		if(getMarkerAtLine(line) != null)
			removeMarker(line);
		else
			addMarker(shortcut,pos);
	} 

	
	
	public void addMarker(char shortcut, int pos)
	{
		if(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(""persistentMarkers""))
			setDirty(true);

		Marker markerN = new Marker(this,shortcut,pos);
		boolean added = false;

		
		if(!getFlag(LOADING))
		{
			markerN.createPosition();

			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = (Marker)markers.elementAt(i);
				if(shortcut != '\0' && marker.getShortcut() == shortcut)
					marker.setShortcut('\0');

				if(marker.getPosition() == pos)
				{
					markers.removeElementAt(i);
					i--;
				}
			}

			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = (Marker)markers.elementAt(i);
				if(marker.getPosition() > pos)
				{
					markers.insertElementAt(markerN,i);
					added = true;
					break;
				}
			}
		}

		if(!added)
			markers.addElement(markerN);

		if(!getFlag(LOADING) && !getFlag(TEMPORARY))
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MARKERS_CHANGED));
		}
	} 

	
	
	public Marker getMarkerInRange(int start, int end)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			int pos = marker.getPosition();
			if(pos >= start && pos < end)
				return marker;
		}

		return null;
	} 

	
	
	public Marker getMarkerAtLine(int line)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			if(getLineOfOffset(marker.getPosition()) == line)
				return marker;
		}

		return null;
	} 

	
	
	public void removeMarker(int line)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			if(getLineOfOffset(marker.getPosition()) == line)
			{
				if(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(""persistentMarkers""))
					setDirty(true);

				marker.removePosition();
				markers.removeElementAt(i);
				i--;
			}
		}

		EditBus.send(new BufferUpdate(this,null,
			BufferUpdate.MARKERS_CHANGED));
	} 

	
	
	public void removeAllMarkers()
	{
		if(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(""persistentMarkers""))
			setDirty(true);

		for(int i = 0; i < markers.size(); i++)
			((Marker)markers.elementAt(i)).removePosition();

		markers.removeAllElements();

		EditBus.send(new BufferUpdate(this,null,
			BufferUpdate.MARKERS_CHANGED));
	} 

	
	
	public Marker getMarker(char shortcut)
	{
		Enumeration enum = markers.elements();
		while(enum.hasMoreElements())
		{
			Marker marker = (Marker)enum.nextElement();
			if(marker.getShortcut() == shortcut)
				return marker;
		}
		return null;
	} 

	

	

	
	
	public final Buffer getNext()
	{
		return next;
	} 

	
	
	public final Buffer getPrev()
	{
		return prev;
	} 

	
	
	public final int getIndex()
	{
		int count = 0;
		Buffer buffer = prev;
		for(;;)
		{
			if(buffer == null)
				break;
			count++;
			buffer = buffer.prev;
		}
		return count;
	} 

	
	
	public String toString()
	{
		return name + "" ("" + MiscUtilities.getParentOfPath(path) + "")"";
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof EditPaneUpdate)
		{
			EditPaneUpdate emsg = (EditPaneUpdate)msg;
			if(emsg.getWhat() == EditPaneUpdate.CREATED)
			{
				
			}
			else if(emsg.getWhat() == EditPaneUpdate.DESTROYED)
			{
				JEditTextArea textArea = emsg.getEditPane()
					.getTextArea();
				FoldVisibilityManager mgr = textArea
					.getFoldVisibilityManager();

				for(int i = 0; i < inUseFVMs.length; i++)
				{
					if(mgr == inUseFVMs[i])
					{
						mgr._release();
						inUseFVMs[i] = null;
						break;
					}
				}
			}
		}
	} 

	

	

	
	
	public FoldVisibilityManager _getFoldVisibilityManager(
		JEditTextArea textArea)
	{
		FoldVisibilityManager mgr = new FoldVisibilityManager(this,
			offsetMgr,textArea);

		
		for(int i = 0; i < inUseFVMs.length; i++)
		{
			if(inUseFVMs[i] == null)
			{
				inUseFVMs[i] = mgr;
				mgr._grab(i);
				return mgr;
			}
		}

		
		throw new InternalError(""Too many text areas editing this buffer"");
	} 

	
	
	public void _releaseFoldVisibilityManager(FoldVisibilityManager mgr)
	{
		inUseFVMs[mgr._getIndex()] = null;
		mgr._release();
	} 

	

	
	Buffer prev;
	Buffer next;

	
	Buffer(String path, boolean newFile, boolean temp, Hashtable props)
	{
		properties = ((Hashtable)props.clone());

		
		
		if(getProperty(ENCODING) == null)
			properties.put(ENCODING,System.getProperty(""file.encoding""));
		if(getProperty(LINESEP) == null)
			properties.put(LINESEP,System.getProperty(""line.separator""));

		lock = new ReadWriteLock();
		contentMgr = new ContentManager();
		offsetMgr = new OffsetManager(this);
		integerArray = new IntegerArray();
		undoMgr = new UndoManager(this);
		bufferListeners = new Vector();

		seg = new Segment();
		lastTokenizedLine = -1;
		tokenList = new TokenList();

		inUseFVMs = new FoldVisibilityManager[8];

		setFlag(TEMPORARY,temp);

		markers = new Vector();

		
		setPath(path);

		Mode defaultMode = jEdit.getMode(jEdit.getProperty(""buffer.defaultMode""));
		if(defaultMode == null)
			defaultMode = jEdit.getMode(""text"");
		setMode(defaultMode);

		
		setFlag(UNTITLED,newFile);
		setFlag(NEW_FILE,newFile);

		if(!temp)
			EditBus.addToBus(Buffer.this);
	} 

	
	void commitTemporary()
	{
		setFlag(TEMPORARY,false);
		EditBus.addToBus(this);

		finishLoading();
	} 

	
	void close()
	{
		setFlag(CLOSED,true);

		if(autosaveFile != null)
			autosaveFile.delete();

		EditBus.removeFromBus(this);
	} 

	

	

	

	
	private void setFlag(int flag, boolean value)
	{
		if(value)
			flags |= (1 << flag);
		else
			flags &= ~(1 << flag);
	} 

	
	private boolean getFlag(int flag)
	{
		int mask = (1 << flag);
		return (flags & mask) == mask;
	} 

	
	private static final int CLOSED = 0;
	private static final int LOADING = 1;
	private static final int IO = 2;
	private static final int NEW_FILE = 3;
	private static final int UNTITLED = 4;
	private static final int AUTOSAVE_DIRTY = 5;
	private static final int DIRTY = 6;
	private static final int READ_ONLY = 7;
	private static final int UNDO_IN_PROGRESS = 8;
	private static final int TEMPORARY = 9;
	private static final int INSIDE_INSERT = 10;
	

	private int flags;

	

	
	private VFS vfs;
	private String path;
	private String name;
	private File file;
	private File autosaveFile;
	private long modTime;
	private Mode mode;
	private Hashtable properties;

	private ReadWriteLock lock;
	private ContentManager contentMgr;
	private OffsetManager offsetMgr;
	private IntegerArray integerArray;
	private UndoManager undoMgr;
	private Vector bufferListeners;

	private Vector markers;

	
	private boolean parseFully;
	private TokenMarker tokenMarker;
	private Segment seg;
	private int lastTokenizedLine;
	private boolean nextLineRequested;
	private TokenList tokenList;

	
	private FoldHandler foldHandler;
	private FoldVisibilityManager[] inUseFVMs;

	

	
	private void setPath(String path)
	{
		this.path = path;
		name = MiscUtilities.getFileName(path);

		vfs = VFSManager.getVFSForPath(path);
		if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)
			setReadOnly(true);

		if(vfs instanceof FileVFS)
		{
			file = new File(path);

			
			
			if(autosaveFile != null)
				autosaveFile.delete();
			autosaveFile = new File(file.getParent(),'#' + name + '#');
		}
	} 

	
	private boolean recoverAutosave(final View view)
	{
		if(!autosaveFile.canRead())
			return false;

		
		GUIUtilities.hideSplashScreen();

		final Object[] args = { autosaveFile.getPath() };
		int result = GUIUtilities.confirm(view,""autosave-found"",args,
			JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);

		if(result == JOptionPane.YES_OPTION)
		{
			vfs.load(view,this,autosaveFile.getPath());

			
			
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					GUIUtilities.message(view,""autosave-loaded"",args);
				}
			});

			return true;
		}
		else
			return false;
	} 

	
	private void finishLoading()
	{
		parseBufferLocalProperties();
		setMode();

		if(parseFully)
		{
			for(int i = 0; i < offsetMgr.getLineCount(); i++)
				markTokens(i);
		}
	} 

	
	private void finishSaving(View view, String oldPath, String path,
		boolean rename, boolean error)
	{
		
		
		
		if(!error && !path.equals(oldPath))
		{
			Buffer buffer = jEdit.getBuffer(path);

			if(rename)
			{
				
				if(buffer != null && 
					!buffer.getPath().equals(oldPath))
				{
					buffer.setDirty(false);
					jEdit.closeBuffer(view,buffer);
				}

				setPath(path);
			}
			else
			{
				
				if(buffer != null && 
					!buffer.getPath().equals(oldPath))
				{
					buffer.load(view,true);
				}
			}
		} 

		
		if(rename)
		{
			if(file != null)
				modTime = file.lastModified();

			if(!error)
			{
				
				
				
				
				
				try
				{
					writeLock();

					if(autosaveFile != null)
						autosaveFile.delete();

					setFlag(AUTOSAVE_DIRTY,false);
					setFlag(READ_ONLY,false);
					setFlag(NEW_FILE,false);
					setFlag(UNTITLED,false);
					setFlag(DIRTY,false);

					
					
					
					undoMgr.bufferSaved();
				}
				finally
				{
					writeUnlock();
				}

				parseBufferLocalProperties();

				if(!getPath().equals(oldPath))
				{
					jEdit.updatePosition(Buffer.this);
					setMode();
				}
				else
					propertiesChanged();

				EditBus.send(new BufferUpdate(Buffer.this,
					view,BufferUpdate.DIRTY_CHANGED));

				
				EditBus.send(new BufferUpdate(Buffer.this,
					view,BufferUpdate.SAVED));
			}
		} 
	} 

	
	private void parseBufferLocalProperties()
	{
		
		if(getProperty(""tabSize"")
			.equals(mode.getProperty(""tabSize"")))
			unsetProperty(""tabSize"");

		if(getProperty(""indentSize"")
			.equals(mode.getProperty(""indentSize"")))
			unsetProperty(""indentSize"");

		if(getProperty(""maxLineLen"")
			.equals(mode.getProperty(""maxLineLen"")))
			unsetProperty(""maxLineLen"");
		

		int lastLine = Math.min(9,getLineCount() - 1);
		parseBufferLocalProperties(getText(0,getLineEndOffset(lastLine) - 1));

		
		
		int firstLine = Math.max(lastLine + 1, getLineCount() - 10);
		if(firstLine < getLineCount())
		{
			int length = getLineEndOffset(getLineCount() - 1) 
				- (getLineStartOffset(firstLine) + 1);
			parseBufferLocalProperties(getText(getLineStartOffset(firstLine),length));
		}

		

		
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			int pos = marker.getPosition();
			if(pos > getLength())
				marker.setPosition(getLength());
			marker.removePosition();
			marker.createPosition();
		}
	} 

	
	private void parseBufferLocalProperties(String prop)
	{
		StringBuffer buf = new StringBuffer();
		String name = null;
		boolean escape = false;
		for(int i = 0; i < prop.length(); i++)
		{
			char c = prop.charAt(i);
			switch(c)
			{
			case ':':
				if(escape)
				{
					escape = false;
					buf.append(':');
					break;
				}
				if(name != null)
				{
					String value = buf.toString();
					try
					{
						setProperty(name,new Integer(value));
					}
					catch(NumberFormatException nf)
					{
						setProperty(name,value);
					}
					name = null;
				}
				buf.setLength(0);
				break;
			case '=':
				if(escape)
				{
					escape = false;
					buf.append('=');
					break;
				}
				name = buf.toString();
				buf.setLength(0);
				break;
			case '\\':
				if(escape)
					buf.append('\\');
				escape = !escape;
				break;
			case 'n':
				if(escape)
				{	buf.append('\n');
					escape = false;
					break;
				}
			case 'r':
				if(escape)
				{	buf.append('\r');
					escape = false;
					break;
				}
			case 't':
				if(escape)
				{
					buf.append('\t');
					escape = false;
					break;
				}
			default:
				buf.append(c);
				break;
			}
		}
	} 

	
	private void setTokenMarker(TokenMarker tokenMarker)
	{
		TokenMarker oldTokenMarker = this.tokenMarker;

		this.tokenMarker = tokenMarker;

		
		if(oldTokenMarker != null && tokenMarker != oldTokenMarker)
		{
			offsetMgr.lineInfoChangedFrom(0);
			lastTokenizedLine = -1;
		}
	} 

	
	private void setFoldHandler(FoldHandler foldHandler)
	{
		FoldHandler oldFoldHandler = this.foldHandler;

		
		if(oldFoldHandler != null
			&& oldFoldHandler.getClass() == foldHandler.getClass())
			return;

		this.foldHandler = foldHandler;

		
		if(oldFoldHandler != null)
		{
			offsetMgr.lineInfoChangedFrom(0);

			int collapseFolds = getIntegerProperty(""collapseFolds"",0);
			offsetMgr.expandFolds(collapseFolds);

			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.FOLD_HANDLER_CHANGED));
		}
	} 

	
	private void contentInserted(int offset, int length,
		IntegerArray endOffsets)
	{
		try
		{
			setFlag(INSIDE_INSERT,true);

			int startLine = offsetMgr.getLineOfOffset(offset);
			int numLines = endOffsets.getSize();

			offsetMgr.contentInserted(startLine,offset,numLines,length,
				endOffsets);

			if(numLines > 0)
			{
				
				for(int i = 0; i < inUseFVMs.length; i++)
				{
					if(inUseFVMs[i] != null)
						inUseFVMs[i]._invalidate(startLine);
				}
			}

			if(lastTokenizedLine >= startLine)
				lastTokenizedLine = -1;

			setDirty(true);

			if(!getFlag(LOADING))
				fireContentInserted(startLine,offset,numLines,length);
		}
		finally
		{
			setFlag(INSIDE_INSERT,false);
		}
	} 

	
	private ParserRuleSet getRuleSetAtOffset(int offset)
	{
		int line = getLineOfOffset(offset);
		offset -= getLineStartOffset(line);
		if(offset != 0)
			offset--;

		TokenList tokens = markTokens(line);
		Token token = TextUtilities.getTokenAtOffset(tokens.getFirstToken(),offset);
		return token.rules;
	} 

	

	
	private void fireFoldLevelChanged(int start, int end)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				((BufferChangeListener)bufferListeners.elementAt(i))
					.foldLevelChanged(this,start,end);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event:"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	private void fireContentInserted(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				((BufferChangeListener)bufferListeners.elementAt(i))
					.contentInserted(this,startLine,offset,
					numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event:"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	private void fireContentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				((BufferChangeListener)bufferListeners.elementAt(i))
					.contentRemoved(this,startLine,offset,
					numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event:"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	private void fireTransactionComplete()
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				((BufferChangeListener)bufferListeners.elementAt(i))
					.transactionComplete(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event:"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	

	

	
	
	public static class TokenList
	{
		
		
		public Token getFirstToken()
		{
			return firstToken;
		} 

		
		
		public Token getLastToken()
		{
			return lastToken;
		} 

		
		
		public void addToken(int length, byte id, ParserRuleSet rules)
		{
			if(length == 0 && id != Token.END)
				return;

			if(firstToken == null)
			{
				firstToken = new Token(length,id,rules);
				lastToken = firstToken;
			}
			else if(lastToken == null)
			{
				lastToken = firstToken;
				firstToken.length = length;
				firstToken.id = id;
				firstToken.rules = rules;
			}
			else if(lastToken.id == id && lastToken.rules == rules)
			{
				lastToken.length += length;
			}
			else if(lastToken.next == null)
			{
				lastToken.next = new Token(length,id,rules);
				lastToken.next.prev = lastToken;
				lastToken = lastToken.next;
			}
			else
			{
				lastToken = lastToken.next;
				lastToken.length = length;
				lastToken.id = id;
				lastToken.rules = rules;
			}
		} 

		private Token firstToken;
		private Token lastToken;
	} 
}
"
jEdit,4,org.gjt.sp.jedit.JARClassLoader,14,2,0,14,95,21,8,9,8,0.692307692,973,1.0,1,0.853333333,0.58974359,1,6,68.07142857,11,2.0714,1,"

package org.gjt.sp.jedit;


import java.io.*;
import java.lang.reflect.Modifier;
import java.net.*;
import java.util.*;
import java.util.zip.*;
import org.gjt.sp.jedit.gui.DockableWindowManager;
import org.gjt.sp.util.Log;



public class JARClassLoader extends ClassLoader
{
	
	
	public JARClassLoader()
	{
	} 

	
	public JARClassLoader(String path)
		throws IOException
	{
		zipFile = new ZipFile(path);
		jar = new EditPlugin.JAR(path,this);

		Enumeration entires = zipFile.entries();
		while(entires.hasMoreElements())
		{
			ZipEntry entry = (ZipEntry)entires.nextElement();
			String name = entry.getName();
			String lname = name.toLowerCase();
			if(lname.equals(""actions.xml""))
			{
				jEdit.loadActions(
					path + ""!actions.xml"",
					new BufferedReader(new InputStreamReader(
					zipFile.getInputStream(entry))),
					jar.getActions());
			}
			if(lname.equals(""dockables.xml""))
			{
				DockableWindowManager.loadDockableWindows(
					path + ""!dockables.xml"",
					new BufferedReader(new InputStreamReader(
					zipFile.getInputStream(entry))),
					jar.getActions());
			}
			else if(lname.endsWith("".props""))
				jEdit.loadProps(zipFile.getInputStream(entry),true);
			else if(name.endsWith("".class""))
			{
				classHash.put(MiscUtilities.fileToClass(name),this);

				if(name.endsWith(""Plugin.class""))
					pluginClasses.addElement(name);
			}
		}

		jEdit.addPluginJAR(jar);
	} 

	
	
	public Class loadClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		
		Object obj = classHash.get(clazz);
		if(obj == NO_CLASS)
		{
			
			
			
			throw new ClassNotFoundException(clazz);
		}
		else if(obj instanceof ClassLoader)
		{
			JARClassLoader classLoader = (JARClassLoader)obj;
			return classLoader._loadClass(clazz,resolveIt);
		}

		
		
		try
		{
			Class cls;

			
			ClassLoader parentLoader = getClass().getClassLoader();
			if (parentLoader != null)
				cls = parentLoader.loadClass(clazz);
			else
				cls = findSystemClass(clazz);

			return cls;
		}
		catch(ClassNotFoundException cnf)
		{
			
			
			classHash.put(clazz,NO_CLASS);

			throw cnf;
		}
	} 

	
	public InputStream getResourceAsStream(String name)
	{
		if(zipFile == null)
			return null;

		try
		{
			ZipEntry entry = zipFile.getEntry(name);
			if(entry == null)
				return getSystemResourceAsStream(name);
			else
				return zipFile.getInputStream(entry);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);

			return null;
		}
	} 

	
	public URL getResource(String name)
	{
		if(zipFile == null)
			return null;

		ZipEntry entry = zipFile.getEntry(name);
		if(entry == null)
			return getSystemResource(name);

		try
		{
			return new URL(getResourceAsPath(name));
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			return null;
		}
	} 

	
	public String getResourceAsPath(String name)
	{
		if(zipFile == null)
			return null;

		if(!name.startsWith(""/""))
			name = ""/"" + name;

		return ""jeditresource:/"" + MiscUtilities.getFileName(
			jar.getPath()) + ""!"" + name;
	} 

	
	
	public void closeZipFile()
	{
		if(zipFile == null)
			return;

		try
		{
			zipFile.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
		}

		zipFile = null;
	} 

	
	
	public ZipFile getZipFile()
	{
		return zipFile;
	} 

	
	void startAllPlugins()
	{
		for(int i = 0; i < pluginClasses.size(); i++)
		{
			String name = (String)pluginClasses.elementAt(i);
			name = MiscUtilities.fileToClass(name);

			try
			{
				loadPluginClass(name);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Error while starting plugin "" + name);
				Log.log(Log.ERROR,this,t);

				jar.addPlugin(new EditPlugin.Broken(name));
				String[] args = { t.toString() };
				jEdit.pluginError(jar.getPath(),
					""plugin-error.start-error"",args);
			}
		}
	} 

	

	
	private static final Object NO_CLASS = new Object();

	private static Hashtable classHash = new Hashtable();

	private EditPlugin.JAR jar;
	private Vector pluginClasses = new Vector();
	private ZipFile zipFile;

	
	private void loadPluginClass(String name)
		throws Exception
	{
		
		EditPlugin[] plugins = jEdit.getPlugins();

		for(int i = 0; i < plugins.length; i++)
		{
			if(plugins[i].getClass().getName().equals(name))
			{
				jEdit.pluginError(jar.getPath(),
					""plugin-error.already-loaded"",null);
				return;
			}
		}

		
		if(name.equals(""WheelMousePlugin"")
			&& jEdit.getProperty(""plugin.WheelMousePlugin.version"").equals(""0.5"")
			&& OperatingSystem.hasJava14())
		{
			jar.addPlugin(new EditPlugin.Broken(name));
			jEdit.pluginError(jar.getPath(),""plugin-error.update"",null);
			return;
		}

		
		if(!checkDependencies(name))
		{
			jar.addPlugin(new EditPlugin.Broken(name));
			return;
		}

		
		
		Class clazz = loadClass(name,true);
		int modifiers = clazz.getModifiers();
		if(!Modifier.isInterface(modifiers)
			&& !Modifier.isAbstract(modifiers)
			&& EditPlugin.class.isAssignableFrom(clazz))
		{
			String label = jEdit.getProperty(""plugin.""
				+ name + "".name"");
			String version = jEdit.getProperty(""plugin.""
				+ name + "".version"");

			if(version == null)
			{
				Log.log(Log.ERROR,this,""Plugin "" +
					name + "" needs""
					+ "" 'name' and 'version' properties."");
				jar.addPlugin(new EditPlugin.Broken(name));
				return;
			}

			jar.getActions().setLabel(jEdit.getProperty(
				""action-set.plugin"",
				new String[] { label }));

			Log.log(Log.NOTICE,this,""Starting plugin "" + label
					+ "" (version "" + version + "")"");

			jar.addPlugin((EditPlugin)clazz.newInstance());
		}
	} 

	
	private boolean checkDependencies(String name)
	{
		int i = 0;

		String dep;
		while((dep = jEdit.getProperty(""plugin."" + name + "".depend."" + i++)) != null)
		{
			int index = dep.indexOf(' ');
			if(index == -1)
			{
				Log.log(Log.ERROR,this,name + "" has an invalid""
					+ "" dependency: "" + dep);
				return false;
			}

			String what = dep.substring(0,index);
			String arg = dep.substring(index + 1);

			if(what.equals(""jdk""))
			{
				if(MiscUtilities.compareStrings(
					System.getProperty(""java.version""),
					arg,false) < 0)
				{
					String[] args = { arg,
						System.getProperty(""java.version"") };
					jEdit.pluginError(jar.getPath(),""plugin-error.dep-jdk"",args);
					return false;
				}
			}
			else if(what.equals(""jedit""))
			{
				if(arg.length() != 11)
				{
					Log.log(Log.ERROR,this,""Invalid jEdit version""
						+ "" number: "" + arg);
					return false;
				}

				if(MiscUtilities.compareStrings(
					jEdit.getBuild(),arg,false) < 0)
				{
					String needs = MiscUtilities.buildToVersion(arg);
					String[] args = { needs,
						jEdit.getVersion() };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-jedit"",args);
					return false;
				}
			}
			else if(what.equals(""plugin""))
			{
				int index2 = arg.indexOf(' ');
				if(index2 == -1)
				{
					Log.log(Log.ERROR,this,name 
						+ "" has an invalid dependency: ""
						+ dep + "" (version is missing)"");
					return false;
				}
				
				String plugin = arg.substring(0,index2);
				String needVersion = arg.substring(index2 + 1);
				String currVersion = jEdit.getProperty(""plugin."" 
					+ plugin + "".version"");

				if(currVersion == null)
				{
					String[] args = { needVersion, plugin };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-plugin.no-version"",
						args);
					return false;
				}

				if(MiscUtilities.compareStrings(currVersion,
					needVersion,false) < 0)
				{
					String[] args = { needVersion, plugin, currVersion };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-plugin"",args);
					return false;
				}

				if(jEdit.getPlugin(plugin) instanceof EditPlugin.Broken)
				{
					String[] args = { plugin };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-plugin.broken"",args);
					return false;
				}
			}
			else if(what.equals(""class""))
			{
				try
				{
					loadClass(arg,false);
				}
				catch(Exception e)
				{
					String[] args = { arg };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-class"",args);
					return false;
				}
			}
			else
			{
				Log.log(Log.ERROR,this,name + "" has unknown""
					+ "" dependency: "" + dep);
				return false;
			}
		}

		return true;
	} 

	
	
	private Class _loadClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		Class cls = findLoadedClass(clazz);
		if(cls != null)
		{
			if(resolveIt)
				resolveClass(cls);
			return cls;
		}

		String name = MiscUtilities.classToFile(clazz);

		try
		{
			ZipEntry entry = zipFile.getEntry(name);

			if(entry == null)
				throw new ClassNotFoundException(clazz);

			InputStream in = zipFile.getInputStream(entry);

			int len = (int)entry.getSize();
			byte[] data = new byte[len];
			int success = 0;
			int offset = 0;
			while(success < len)
			{
				len -= success;
				offset += success;
				success = in.read(data,offset,len);
				if(success == -1)
				{
					Log.log(Log.ERROR,this,""Failed to load class ""
						+ clazz + "" from "" + zipFile.getName());
					throw new ClassNotFoundException(clazz);
				}
			}

			cls = defineClass(clazz,data,0,data.length);

			if(resolveIt)
				resolveClass(cls);

			return cls;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);

			throw new ClassNotFoundException(clazz);
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.DefaultInputHandler,11,3,0,8,54,0,2,7,10,0.625,541,1.0,0,0.666666667,0.303030303,1,4,47.81818182,21,5.0909,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.KeyStroke;
import java.awt.event.*;
import java.awt.Toolkit;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class DefaultInputHandler extends InputHandler
{
	
	
	public DefaultInputHandler(View view)
	{
		super(view);

		bindings = currentBindings = new Hashtable();
	} 

	
	
	public DefaultInputHandler(View view, DefaultInputHandler copy)
	{
		super(view);

		bindings = currentBindings = copy.bindings;
	} 

	
	
	public void addKeyBinding(String keyBinding, EditAction action)
	{
	        Hashtable current = bindings;

		StringTokenizer st = new StringTokenizer(keyBinding);
		while(st.hasMoreTokens())
		{
			KeyStroke keyStroke = parseKeyStroke(st.nextToken());
			if(keyStroke == null)
				return;

			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = (Hashtable)o;
				else
				{
					o = new Hashtable();
					current.put(keyStroke,o);
					current = (Hashtable)o;
				}
			}
			else
				current.put(keyStroke,action);
		}
	} 

	
	
	public void removeKeyBinding(String keyBinding)
	{
		throw new InternalError(""Not yet implemented"");
	} 

	
	
	public void removeAllKeyBindings()
	{
		bindings.clear();
	} 

	
	
	public Object getKeyBinding(String keyBinding)
	{
		Hashtable current = bindings;
		StringTokenizer st = new StringTokenizer(keyBinding);

		while(st.hasMoreTokens())
		{
			KeyStroke keyStroke = parseKeyStroke(st.nextToken());
			if(keyStroke == null)
				return null;

			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = (Hashtable)o;
				else
					return o;
			}
			else
			{
				return current.get(keyStroke);
			}
		}

		return null;
	} 

	
	
	public boolean isPrefixActive()
	{
		return bindings != currentBindings;
	} 

	
	
	public void keyPressed(KeyEvent evt)
	{
		int keyCode = evt.getKeyCode();
		int modifiers = evt.getModifiers();

		if(!(evt.isControlDown() || evt.isAltDown() || evt.isMetaDown()))
		{
			
			
			if((keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)
				|| (keyCode >= KeyEvent.VK_0 && keyCode <= KeyEvent.VK_9))
			{
				return;
			}
			else if(keyCode == KeyEvent.VK_SPACE)
			{
				return;
			}
			else if(readNextChar != null)
			{
				if(keyCode == KeyEvent.VK_ESCAPE)
				{
					readNextChar = null;
					view.getStatus().setMessage(null);
				}
				else if(!evt.isActionKey()
					&& keyCode != KeyEvent.VK_TAB
					&& keyCode != KeyEvent.VK_ENTER)
				{
					return;
				}
			}
			else
			{
				
			}
		}

		KeyStroke keyStroke = KeyStroke.getKeyStroke(keyCode,
			modifiers);

		Object o = currentBindings.get(keyStroke);
		if(o == null)
		{
			
			
			
			
			if(currentBindings != bindings)
			{
				Toolkit.getDefaultToolkit().beep();
				
				
				repeatCount = 0;
				repeat = false;
				evt.consume();
				currentBindings = bindings;
			}
			else if(modifiers == 0 && (keyCode == KeyEvent.VK_ENTER
				|| keyCode == KeyEvent.VK_TAB))
			{
				userInput((char)keyCode);
				evt.consume();
			}
		}

		if(readNextChar != null)
		{
			readNextChar = null;
			view.getStatus().setMessage(null);
		}

		if(o instanceof EditAction)
		{
			currentBindings = bindings;
			invokeAction((EditAction)o);
			evt.consume();
		}
		else if(o instanceof Hashtable)
		{
			currentBindings = (Hashtable)o;
			evt.consume();
		}

		if(o == null)
		{
			switch(evt.getKeyCode())
			{
				case KeyEvent.VK_NUMPAD0:   case KeyEvent.VK_NUMPAD1:
				case KeyEvent.VK_NUMPAD2:   case KeyEvent.VK_NUMPAD3:
				case KeyEvent.VK_NUMPAD4:   case KeyEvent.VK_NUMPAD5:
				case KeyEvent.VK_NUMPAD6:   case KeyEvent.VK_NUMPAD7:
				case KeyEvent.VK_NUMPAD8:   case KeyEvent.VK_NUMPAD9:
				case KeyEvent.VK_MULTIPLY:  case KeyEvent.VK_ADD:
				 case KeyEvent.VK_SUBTRACT:
				case KeyEvent.VK_DECIMAL:   case KeyEvent.VK_DIVIDE:
					KeyEventWorkaround.numericKeypadKey();
					break;
			}
		}
	} 

	
	
	public void keyTyped(KeyEvent evt)
	{
		char c = evt.getKeyChar();

		
		if(c == '\b')
			return;

		KeyStroke keyStroke;

		
		
		
		switch(c)
		{
		case ' ':
			keyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_SPACE,
				evt.getModifiers());
			break;
		case '\t':
			keyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
				evt.getModifiers());
			break;
		case '\n':
			keyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,
				evt.getModifiers());
			break;
		default:
			keyStroke = KeyStroke.getKeyStroke(c);
			break;
		}

		Object o = currentBindings.get(keyStroke);

		if(o instanceof Hashtable)
		{
			currentBindings = (Hashtable)o;
		}
		else if(o instanceof EditAction)
		{
			currentBindings = bindings;
			invokeAction((EditAction)o);
		}
		else
		{
			
			currentBindings = bindings;

			if(repeat && Character.isDigit(c))
			{
				repeatCount *= 10;
				repeatCount += (c - '0');
				view.getStatus().setMessage(null);
			}
			else
				userInput(c);
		}
	} 

	
	
	public static KeyStroke parseKeyStroke(String keyStroke)
	{
		if(keyStroke == null)
			return null;
		int modifiers = 0;
		int index = keyStroke.indexOf('+');
		if(index != -1)
		{
			for(int i = 0; i < index; i++)
			{
				switch(Character.toUpperCase(keyStroke
					.charAt(i)))
				{
				case 'A':
					modifiers |= InputEvent.ALT_MASK;
					break;
				case 'C':
					if(OperatingSystem.isMacOS())
						modifiers |= InputEvent.META_MASK;
					else
						modifiers |= InputEvent.CTRL_MASK;
					break;
				case 'M':
					if(OperatingSystem.isMacOS())
						modifiers |= InputEvent.CTRL_MASK;
					else
						modifiers |= InputEvent.META_MASK;
					break;
				case 'S':
					modifiers |= InputEvent.SHIFT_MASK;
					break;
				}
			}
		}
		String key = keyStroke.substring(index + 1);
		if(key.length() == 1)
		{
			char ch = key.charAt(0);
			if(modifiers == 0)
				return KeyStroke.getKeyStroke(ch);
			else
			{
				return KeyStroke.getKeyStroke(Character.toUpperCase(ch),
					modifiers);
			}
		}
		else if(key.length() == 0)
		{
			Log.log(Log.ERROR,DefaultInputHandler.class,
				""Invalid key stroke: "" + keyStroke);
			return null;
		}
		else
		{
			int ch;

			try
			{
				ch = KeyEvent.class.getField(""VK_"".concat(key))
					.getInt(null);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,DefaultInputHandler.class,
					""Invalid key stroke: ""
					+ keyStroke);
				return null;
			}

			return KeyStroke.getKeyStroke(ch,modifiers);
		}
	} 

	
	private Hashtable bindings;
	private Hashtable currentBindings;
	
}
"
jEdit,4,org.gjt.sp.jedit.options.EditingOptionPane,3,6,0,5,24,1,1,4,1,0.5,371,1.0,0,0.996987952,1.0,2,4,118.6666667,3,1.3333,1,"

package org.gjt.sp.jedit.options;

import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.FoldHandler;

public class EditingOptionPane extends AbstractOptionPane
{
	
	public EditingOptionPane()
	{
		super(""editing"");
	} 

	
	protected void _init()
	{
		
		Mode[] modes = jEdit.getModes();
		String defaultModeString = jEdit.getProperty(""buffer.defaultMode"");
		String[] modeNames = new String[modes.length];
		int index = 0;
		for(int i = 0; i < modes.length; i++)
		{
			Mode _mode = modes[i];
			modeNames[i] = _mode.getName();
			if(defaultModeString.equals(_mode.getName()))
				index = i;
		}
		defaultMode = new JComboBox(modeNames);
		defaultMode.setSelectedIndex(index);
		addComponent(jEdit.getProperty(""options.editing.defaultMode""),
			defaultMode);
		

		
		undoCount = new JTextField(jEdit.getProperty(""buffer.undoCount""));
		addComponent(jEdit.getProperty(""options.editing.undoCount""),undoCount);
		

		
		defaultNoWordSep = new JTextField(jEdit.getProperty(""buffer.noWordSep""));
		addComponent(jEdit.getProperty(""options.editing.noWordSep""),defaultNoWordSep);
		

		
		String[] foldModes = FoldHandler.getFoldModes();
		addComponent(jEdit.getProperty(""options.editing.folding""),
			defaultFolding = new JComboBox(foldModes));

		defaultFolding.setSelectedItem(jEdit.getProperty(""buffer.folding""));
		

		
		defaultCollapseFolds = new JTextField(jEdit.getProperty(""buffer.collapseFolds""));
		addComponent(jEdit.getProperty(""options.editing.collapseFolds""),defaultCollapseFolds);
		

		
		String[] wrapModes = {
			""none"",
			""soft"",
			""hard""
		};
		addComponent(jEdit.getProperty(""options.editing.wrap""),
			defaultWrap = new JComboBox(wrapModes));

		defaultWrap.setSelectedItem(jEdit.getProperty(""buffer.wrap""));
		

		
		String[] lineLens = { ""0"", ""72"", ""76"", ""80"" };
		defaultMaxLineLen = new JComboBox(lineLens);
		defaultMaxLineLen.setEditable(true);
		defaultMaxLineLen.setSelectedItem(jEdit.getProperty(""buffer.maxLineLen""));
		addComponent(jEdit.getProperty(""options.editing.maxLineLen""),defaultMaxLineLen);
		

		
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		defaultTabSize = new JComboBox(tabSizes);
		defaultTabSize.setEditable(true);
		defaultTabSize.setSelectedItem(jEdit.getProperty(""buffer.tabSize""));
		addComponent(jEdit.getProperty(""options.editing.tabSize""),defaultTabSize);

		

		
		defaultIndentSize = new JComboBox(tabSizes);
		defaultIndentSize.setEditable(true);
		defaultIndentSize.setSelectedItem(jEdit.getProperty(""buffer.indentSize""));
		addComponent(jEdit.getProperty(""options.editing.indentSize""),defaultIndentSize);
		

		
		defaultNoTabs = new JCheckBox(jEdit.getProperty(""options.editing""
			+ "".noTabs""));
		defaultNoTabs.setSelected(jEdit.getBooleanProperty(""buffer.noTabs""));
		addComponent(defaultNoTabs);
		

		
		defaultIndentOnTab = new JCheckBox(jEdit.getProperty(""options.editing""
			+ "".indentOnTab""));
		defaultIndentOnTab.setSelected(jEdit.getBooleanProperty(""buffer.indentOnTab""));
		addComponent(defaultIndentOnTab);
		

		
		defaultIndentOnEnter = new JCheckBox(jEdit.getProperty(""options.editing""
			+ "".indentOnEnter""));
		defaultIndentOnEnter.setSelected(jEdit.getBooleanProperty(""buffer.indentOnEnter""));
		addComponent(defaultIndentOnEnter);
		
	} 

	
	protected void _save()
	{
		jEdit.setProperty(""buffer.defaultMode"",
			(String)defaultMode.getSelectedItem());
		jEdit.setProperty(""buffer.undoCount"",undoCount.getText());
		jEdit.setProperty(""buffer.noWordSep"",defaultNoWordSep.getText());
		jEdit.setProperty(""buffer.folding"",(String)defaultFolding.getSelectedItem());
		jEdit.setProperty(""buffer.collapseFolds"",defaultCollapseFolds.getText());
		jEdit.setProperty(""buffer.wrap"",(String)defaultWrap.getSelectedItem());
		jEdit.setProperty(""buffer.maxLineLen"",(String)defaultMaxLineLen.getSelectedItem());
		jEdit.setProperty(""buffer.tabSize"",(String)defaultTabSize
			.getSelectedItem());
		jEdit.setProperty(""buffer.indentSize"",(String)defaultIndentSize
			.getSelectedItem());
		jEdit.setBooleanProperty(""buffer.noTabs"",defaultNoTabs.isSelected());
		jEdit.setBooleanProperty(""buffer.indentOnTab"",defaultIndentOnTab
			.isSelected());
		jEdit.setBooleanProperty(""buffer.indentOnEnter"",defaultIndentOnEnter
			.isSelected());
	} 

	
	private JComboBox defaultMode;
	private JTextField undoCount;
	private JTextField defaultNoWordSep;
	private JComboBox defaultFolding;
	private JTextField defaultCollapseFolds;
	private JComboBox defaultWrap;
	private JComboBox defaultMaxLineLen;
	private JComboBox defaultTabSize;
	private JComboBox defaultIndentSize;
	private JCheckBox defaultNoTabs;
	private JCheckBox defaultIndentOnTab;
	private JCheckBox defaultIndentOnEnter;
	
}
"
jEdit,4,org.gjt.sp.jedit.textarea.JEditTextArea,248,4,0,70,482,16336,53,37,193,0.879170739,9106,0.775862069,10,0.724215247,0.076315789,3,14,35.48387097,29,3.2581,23,"

package org.gjt.sp.jedit.textarea;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.text.Segment;
import javax.swing.undo.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.*;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.MultiSelectStatusChanged;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class JEditTextArea extends JComponent
{
	
	
	public JEditTextArea(View view)
	{
		enableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);

		this.view = view;

		
		selection = new Vector();
		chunkCache = new ChunkCache(this);
		painter = new TextAreaPainter(this);
		gutter = new Gutter(view,this);
		bufferHandler = new BufferChangeHandler();
		listenerList = new EventListenerList();
		caretEvent = new MutableCaretEvent();
		bracketLine = bracketPosition = -1;
		blink = true;
		lineSegment = new Segment();
		returnValue = new Point();
		runnables = new ArrayList();
		

		
		setLayout(new ScrollLayout());
		add(LEFT,gutter);
		add(CENTER,painter);
		add(RIGHT,vertical = new JScrollBar(JScrollBar.VERTICAL));
		add(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));

		horizontal.setValues(0,0,0,0);
		

		
		
		
		
		
		if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
		{
			setBorder(new TextAreaBorder());
			vertical.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			horizontal.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			
		}
		

		
		vertical.addAdjustmentListener(new AdjustHandler());
		horizontal.addAdjustmentListener(new AdjustHandler());

		mouseHandler = new MouseHandler();
		painter.addMouseListener(mouseHandler);
		painter.addMouseMotionListener(mouseHandler);

		addFocusListener(new FocusHandler());
		

		
		
		
		focusedComponent = this;
	} 

	

	
	
	public final TextAreaPainter getPainter()
	{
		return painter;
	} 

	
 	
	public final Gutter getGutter()
	{
		return gutter;
	} 

	
	
	public FoldVisibilityManager getFoldVisibilityManager()
	{
		return foldVisibilityManager;
	} 

	
	
	public final boolean isCaretBlinkEnabled()
	{
		return caretBlinks;
	} 

	
	
	public void setCaretBlinkEnabled(boolean caretBlinks)
	{
		this.caretBlinks = caretBlinks;
		if(!caretBlinks)
			blink = false;

		if(buffer != null)
			invalidateLine(caretLine);
	} 

	
	
	public final int getElectricScroll()
	{
		return electricScroll;
	} 

	
	
	public final void setElectricScroll(int electricScroll)
	{
		this.electricScroll = electricScroll;
	} 

	
	
	public final boolean isQuickCopyEnabled()
	{
		return quickCopy;
	} 

	
	
	public final void setQuickCopyEnabled(boolean quickCopy)
	{
		this.quickCopy = quickCopy;
	} 

	
	
	public final Buffer getBuffer()
	{
		return buffer;
	} 

	
	
	public void setBuffer(Buffer buffer)
	{
		if(this.buffer == buffer)
			return;

		try
		{
			bufferChanging = true;

			if(this.buffer != null)
			{
				setFirstLine(0);

				selectNone();
				caretLine = caret = caretScreenLine = 0;
				bracketLine = bracketPosition = -1;

				this.buffer._releaseFoldVisibilityManager(foldVisibilityManager);
				this.buffer.removeBufferChangeListener(bufferHandler);
			}
			this.buffer = buffer;

			buffer.addBufferChangeListener(bufferHandler);
			bufferHandlerInstalled = true;

			foldVisibilityManager = buffer._getFoldVisibilityManager(this);

			chunkCache.setFirstLine(0);
			physFirstLine = foldVisibilityManager.getFirstVisibleLine();

			propertiesChanged();

			recalculateLastPhysicalLine();
		}
		finally
		{
			bufferChanging = false;
		}
	} 

	
	
	public final boolean isEditable()
	{
		return buffer.isEditable();
	} 

	
	
	public final JPopupMenu getRightClickPopup()
	{
		return popup;
	} 

	
	
	public final void setRightClickPopup(JPopupMenu popup)
	{
		this.popup = popup;
	} 

	

	

	
	
	public final int getFirstLine()
	{
		return firstLine;
	} 

	
	
	public void setFirstLine(int firstLine)
	{
		if(firstLine == this.firstLine)
			return;

		_setFirstLine(firstLine);

		view.synchroScrollVertical(this,firstLine);
	} 

	
	public void _setFirstLine(int firstLine)
	{
		firstLine = Math.max(0,Math.min(getVirtualLineCount() - 1,firstLine));
		this.firstLine = firstLine;

		physFirstLine = virtualToPhysical(firstLine);

		maxHorizontalScrollWidth = 0;

		chunkCache.setFirstLine(firstLine);

		recalculateLastPhysicalLine();

		if(this.firstLine != vertical.getValue())
			updateScrollBars();

		painter.repaint();
		gutter.repaint();

		fireScrollEvent(true);
	} 

	
	
	public final int getVisibleLines()
	{
		return visibleLines;
	} 

	
	
	public final int getFirstPhysicalLine()
	{
		return physFirstLine;
	} 

	
	
	public final int getLastPhysicalLine()
	{
		return physLastLine;
	} 

	
	
	public final int getHorizontalOffset()
	{
		return horizontalOffset;
	} 

	
	
	public void setHorizontalOffset(int horizontalOffset)
	{
		if(horizontalOffset == this.horizontalOffset)
			return;
		_setHorizontalOffset(horizontalOffset);

		view.synchroScrollHorizontal(this,horizontalOffset);
	} 

	
	public void _setHorizontalOffset(int horizontalOffset)
	{
		this.horizontalOffset = horizontalOffset;
		if(horizontalOffset != horizontal.getValue())
			updateScrollBars();
		painter.repaint();

		fireScrollEvent(false);
	} 

	
	
	public void updateScrollBars()
	{
		if(vertical != null && visibleLines != 0)
		{
			
			
			int lineCount = getVirtualLineCount();

			
			if(softWrap)
				lineCount += visibleLines - 1;

			if(lineCount < firstLine + visibleLines)
			{
				
				
				int newFirstLine = Math.max(0,lineCount - visibleLines);
				if(newFirstLine != firstLine)
				{
					setFirstLine(newFirstLine);
					return;
				}
			}

			vertical.setValues(firstLine,visibleLines,0,lineCount);
			vertical.setUnitIncrement(2);
			vertical.setBlockIncrement(visibleLines);
		}

		int width = painter.getWidth();
		if(horizontal != null && width != 0)
		{
			maxHorizontalScrollWidth = 0;
			painter.repaint();

			horizontal.setUnitIncrement(painter.getFontMetrics()
				.charWidth('w'));
			horizontal.setBlockIncrement(width / 2);
		}
	} 

	
	
	public void scrollUpLine()
	{
		if(firstLine > 0)
			setFirstLine(firstLine - 1);
		else
			getToolkit().beep();
	} 

	
	
	public void scrollUpPage()
	{
		if(firstLine > 0)
		{
			int newFirstLine = firstLine - visibleLines;
			setFirstLine(newFirstLine);
		}
		else
		{
			getToolkit().beep();
		}
	} 

	
	
	public void scrollDownLine()
	{
		int numLines = getVirtualLineCount();

		if((softWrap && firstLine < numLines) ||
			(firstLine + visibleLines < numLines))
			setFirstLine(firstLine + 1);
		else
			getToolkit().beep();
	} 

	
	
	public void scrollDownPage()
	{
		int numLines = getVirtualLineCount();

		if(firstLine + visibleLines < numLines)
		{
			int newFirstLine = firstLine + visibleLines;
			setFirstLine(newFirstLine + visibleLines < numLines
				? newFirstLine : numLines - visibleLines);
		}
		else
		{
			getToolkit().beep();
		}
	} 

	
	
	public void scrollToCaret(boolean doElectricScroll)
	{
		scrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),
			doElectricScroll);
	} 

	
	
	public void scrollTo(int line, int offset, boolean doElectricScroll)
	{
		int _electricScroll = (doElectricScroll && visibleLines > 6
			? electricScroll : 0);

		
		
		
		if(visibleLines == 0)
		{
			setFirstLine(physicalToVirtual(
				Math.max(0,line - _electricScroll)));
			return;
		}

		
		int screenLine = getScreenLineOfOffset(buffer.getLineStartOffset(line) + offset);
		Point point;
		if(screenLine != -1)
		{
			
			int height = painter.getFontMetrics().getHeight();

			Rectangle rect = new Rectangle(0,height * _electricScroll,
				painter.getWidth() - 5,visibleLines * height
				- height * _electricScroll * 2);

			point = offsetToXY(line,offset,returnValue);
			if(rect.contains(point))
				return;
		}
		else
			point = null;
		

		
		if(line == physLastLine + 1)
		{
			int count = chunkCache.getLineInfosForPhysicalLine(physLastLine).length
				+ chunkCache.getLineInfosForPhysicalLine(physLastLine + 1).length
				+ _electricScroll;
			while(count > 0)
			{
				count -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
				firstLine++;
				physFirstLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);
			}
		}
		else if(screenLine == -1)
		{
			if(line == physLastLine)
			{
				int count = chunkCache.getLineInfosForPhysicalLine(physLastLine).length
					+ _electricScroll;
				while(count > 0)
				{
					count -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
					firstLine++;
					physFirstLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);
				}
			}

			int virtualLine = foldVisibilityManager.physicalToVirtual(line);
			if(virtualLine == firstLine - 1)
			{
				firstLine = Math.max(0,firstLine - _electricScroll - 1);
				physFirstLine = foldVisibilityManager.virtualToPhysical(firstLine);
			}
			else
			{
				
				if(!softWrap && virtualLine >= foldVisibilityManager.getVirtualLineCount()
					- visibleLines / 2)
				{
					firstLine = foldVisibilityManager.getVirtualLineCount()
						- visibleLines;
					physFirstLine = foldVisibilityManager
						.virtualToPhysical(firstLine);
				}
				else
				{
					physFirstLine = line;

					int count = 0;
	
					for(;;)
					{
						if(foldVisibilityManager.isLineVisible(physFirstLine))
						{
							int incr = chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
							if(count + incr > visibleLines / 2)
								break;
							else
								count += incr;
						}

						if(physFirstLine == 0)
							break;
						else
						{
							physFirstLine = foldVisibilityManager
								.getPrevVisibleLine(physFirstLine);
						}
					}

					firstLine = physicalToVirtual(physFirstLine);
				}
			}
		}
		else if(screenLine < _electricScroll && firstLine != 0)
		{
			int count = _electricScroll - screenLine;
			while(count > 0 && firstLine > 0)
			{
				count -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
				firstLine--;
				physFirstLine = foldVisibilityManager.getPrevVisibleLine(physFirstLine);
			}
		}
		else if(screenLine >= visibleLines - _electricScroll)
		{
			int count = _electricScroll - visibleLines + screenLine + 1;
			while(count > 0 && firstLine <= getVirtualLineCount())
			{
				count -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
				firstLine++;
				physFirstLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);
			}
		}

		chunkCache.setFirstLine(firstLine);

		recalculateLastPhysicalLine();

		if(point == null)
		{
			point = offsetToXY(line,offset,returnValue);
			if(point == null)
			{
				
				
				return;
			}
		} 

		
		if(point.x < 0)
		{
			horizontalOffset = Math.min(0,horizontalOffset
				- point.x + charWidth + 5);
		}
		else if(point.x >= painter.getWidth() - charWidth - 5)
		{
			horizontalOffset = horizontalOffset +
				(painter.getWidth() - point.x)
				- charWidth - 5;
		} 

		
		updateScrollBars();
		painter.repaint();
		gutter.repaint();

		view.synchroScrollVertical(this,firstLine);
		view.synchroScrollHorizontal(this,horizontalOffset);

		
		fireScrollEvent(true);
		fireScrollEvent(false);
		
	} 

	
	
	public final void addScrollListener(ScrollListener listener)
	{
		listenerList.add(ScrollListener.class,listener);
	} 

	
	
	public final void removeScrollListener(ScrollListener listener)
	{
		listenerList.remove(ScrollListener.class,listener);
	} 

	

	

	
	
	public int getPhysicalLineOfScreenLine(int screenLine)
	{
		return chunkCache.getLineInfo(screenLine).physicalLine;
	} 

	
	
	public int getScreenLineOfOffset(int offset)
	{
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		return chunkCache.getScreenLineOfOffset(line,offset);
	} 

	
	
	public int getScreenLineStartOffset(int line)
	{
		chunkCache.updateChunksUpTo(line);
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)
			return -1;

		return buffer.getLineStartOffset(lineInfo.physicalLine)
			+ lineInfo.offset;
	} 

	
	
	public int getScreenLineEndOffset(int line)
	{
		chunkCache.updateChunksUpTo(line);
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)
			return -1;

		return buffer.getLineStartOffset(lineInfo.physicalLine)
			+ lineInfo.offset + lineInfo.length;
	} 

	

	

	
	
	public int xyToOffset(int x, int y)
	{
		return xyToOffset(x,y,true);
	} 

	
	
	public int xyToOffset(int x, int y, boolean round)
	{
		FontMetrics fm = painter.getFontMetrics();
		int height = fm.getHeight();
		int line = y / height;

		if(line < 0 || line > visibleLines)
			return -1;

		chunkCache.updateChunksUpTo(line);

		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(!lineInfo.chunksValid)
			System.err.println(""xy to offset: not valid"");

		if(lineInfo.physicalLine == -1)
		{
			return getLineEndOffset(foldVisibilityManager
				.getLastVisibleLine()) - 1;
		}
		else
		{
			int offset = chunkCache.xToOffset(lineInfo.chunks,
				x - horizontalOffset,round);
			if(offset == -1 || offset == lineInfo.offset + lineInfo.length)
				offset = lineInfo.offset + lineInfo.length - 1;

			return getLineStartOffset(lineInfo.physicalLine) + offset;
		}
	} 

	
	
	public Point offsetToXY(int offset)
	{
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		Point retVal = new Point();
		return offsetToXY(line,offset,retVal);
	} 

	
	
	public Point offsetToXY(int line, int offset, Point retVal)
	{
		int screenLine = chunkCache.getScreenLineOfOffset(line,offset);
		if(screenLine == -1)
		{
			if(line < physFirstLine)
				return null;
			
			
			
			
			else if(line >= physLastLine)
				return null;
			else
			{
				throw new InternalError(""line="" + line
					+ "",offset="" + offset
					+ "",screenLine="" + screenLine
					+ "",physFirstLine="" + physFirstLine
					+ "",physLastLine="" + physLastLine);
			}
		}

		FontMetrics fm = painter.getFontMetrics();

		retVal.y = screenLine * fm.getHeight();

		ChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);
		if(!info.chunksValid)
			System.err.println(""offset to xy: not valid"");

		retVal.x = (int)(horizontalOffset + chunkCache.offsetToX(
			info.chunks,offset));

		return retVal;
	} 

	

	

	
	
	public void invalidateScreenLineRange(int start, int end)
	{
		if(chunkCache.needFullRepaint())
		{
			recalculateLastPhysicalLine();
			gutter.repaint();
			painter.repaint();
			return;
		}

		if(start > end)
		{
			int tmp = end;
			end = start;
			start = tmp;
		}

		FontMetrics fm = painter.getFontMetrics();
		int y = start * fm.getHeight();
		int height = (end - start + 1) * fm.getHeight();
		painter.repaint(0,y,painter.getWidth(),height);
		gutter.repaint(0,y,gutter.getWidth(),height);
	} 

	
	
	public void invalidateLine(int line)
	{
		if(line < physFirstLine || line > physLastLine
			|| !foldVisibilityManager.isLineVisible(line))
			return;

		int startLine = -1;
		int endLine = -1;

		for(int i = 0; i <= visibleLines; i++)
		{
			chunkCache.updateChunksUpTo(i);
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);

			if((info.physicalLine >= line || info.physicalLine == -1)
				&& startLine == -1)
			{
				startLine = i;
			}

			if((info.physicalLine >= line && info.lastSubregion)
				|| info.physicalLine == -1)
			{
				endLine = i;
				break;
			}
		}

		if(chunkCache.needFullRepaint())
		{
			recalculateLastPhysicalLine();
			endLine = visibleLines;
		}
		else if(endLine == -1)
			endLine = visibleLines;

		
		

		invalidateScreenLineRange(startLine,endLine);
	} 

	
	
	public void invalidateLineRange(int start, int end)
	{
		if(end < start)
		{
			int tmp = end;
			end = start;
			start = tmp;
		}

		if(end < physFirstLine || start > physLastLine)
			return;

		int startScreenLine = -1;
		int endScreenLine = -1;

		for(int i = 0; i <= visibleLines; i++)
		{
			chunkCache.updateChunksUpTo(i);
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);

			if((info.physicalLine >= start || info.physicalLine == -1)
				&& startScreenLine == -1)
			{
				startScreenLine = i;
			}

			if((info.physicalLine >= end && info.lastSubregion)
				|| info.physicalLine == -1)
			{
				endScreenLine = i;
				break;
			}
		}

		if(startScreenLine == -1)
			startScreenLine = 0;

		if(chunkCache.needFullRepaint())
		{
			recalculateLastPhysicalLine();
			endScreenLine = visibleLines;
		}
		else if(endScreenLine == -1)
			endScreenLine = visibleLines;

		invalidateScreenLineRange(startScreenLine,endScreenLine);
	} 

	
	
	public void invalidateSelectedLines()
	{
		
		invalidateLine(caretLine);

		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			invalidateLineRange(s.startLine,s.endLine);
		}
	} 

	

	

	
	
	public int physicalToVirtual(int line)
	{
		return foldVisibilityManager.physicalToVirtual(line);
	} 

	
	
	public int virtualToPhysical(int line)
	{
		return foldVisibilityManager.virtualToPhysical(line);
	} 

	
	
	public final int getBufferLength()
	{
		return buffer.getLength();
	} 

	
	
	public final int getLineCount()
	{
		return buffer.getLineCount();
	} 

	
	
	public final int getVirtualLineCount()
	{
		return foldVisibilityManager.getVirtualLineCount();
	} 

	
	
	public final int getLineOfOffset(int offset)
	{
		return buffer.getLineOfOffset(offset);
	} 

	
	
	public int getLineStartOffset(int line)
	{
		return buffer.getLineStartOffset(line);
	} 

	
	
	public int getLineEndOffset(int line)
	{
		return buffer.getLineEndOffset(line);
	} 

	
	
	public int getLineLength(int line)
	{
		return buffer.getLineLength(line);
	} 

	
	
	public final String getText(int start, int len)
	{
		return buffer.getText(start,len);
	} 

	
	
	public final void getText(int start, int len, Segment segment)
	{
		buffer.getText(start,len,segment);
	} 

	
	
	public final String getLineText(int lineIndex)
	{
		return buffer.getLineText(lineIndex);
	} 

	
	
	public final void getLineText(int lineIndex, Segment segment)
	{
		buffer.getLineText(lineIndex,segment);
	} 

	
	
	public String getText()
	{
		return buffer.getText(0,buffer.getLength());
	} 

	
	
	public void setText(String text)
	{
		try
		{
			buffer.beginCompoundEdit();
			buffer.remove(0,buffer.getLength());
			buffer.insert(0,text);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	

	

	
	
	public final void selectAll()
	{
		setSelection(new Selection.Range(0,buffer.getLength()));
		moveCaretPosition(buffer.getLength(),true);
	} 

	
	
	public void selectLine()
	{
		int caretLine = getCaretLine();
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine) - 1;
		Selection s = new Selection.Range(start,end);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(end);
	} 

	
	
	public void selectParagraph()
	{
		int caretLine = getCaretLine();

		if(getLineLength(caretLine) == 0)
		{
			view.getToolkit().beep();
			return;
		}

		int start = caretLine;
		int end = caretLine;

		while(start >= 0)
		{
			if(getLineLength(start) == 0)
				break;
			else
				start--;
		}

		while(end < getLineCount())
		{
			if(getLineLength(end) == 0)
				break;
			else
				end++;
		}

		int selectionStart = getLineStartOffset(start + 1);
		int selectionEnd = getLineEndOffset(end - 1) - 1;
		Selection s = new Selection.Range(selectionStart,selectionEnd);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(selectionEnd);
	} 

	
	
	public void selectWord()
	{
		int line = getCaretLine();
		int lineStart = getLineStartOffset(line);
		int offset = getCaretPosition() - lineStart;

		if(getLineLength(line) == 0)
			return;

		String lineText = getLineText(line);
		String noWordSep = buffer.getStringProperty(""noWordSep"");

		if(offset == getLineLength(line))
			offset--;

		int wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);
		int wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);

		Selection s = new Selection.Range(lineStart + wordStart,
			lineStart + wordEnd);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(lineStart + wordEnd);
	} 

	
	
	public void selectToMatchingBracket()
	{
		int offset = caret - buffer.getLineStartOffset(caretLine);

		if(buffer.getLineLength(caretLine) == 0)
			return;

		if(offset == buffer.getLineLength(caretLine))
			offset--;

		int bracket = TextUtilities.findMatchingBracket(buffer,caretLine,offset);

		if(bracket != -1)
		{
			Selection s;

			if(bracket < caret)
				s = new Selection.Range(++bracket,caret);
			else
			{
				moveCaretPosition(caret + 1,false);
				s = new Selection.Range(caret,bracket);
			}

			addToSelection(s);
			return;
		}
	} 

	
	
	public void selectBlock()
	{
		String openBrackets = ""([{"";
		String closeBrackets = "")]}"";

		Selection s = getSelectionAtOffset(caret);
		int start, end;
		if(s == null)
			start = end = caret;
		else
		{
			start = s.start;
			end = s.end;
		}

		String text = getText(0,buffer.getLength());

		
		int count = 1;
		char openBracket = '\0';
		char closeBracket = '\0';

		
		if(start == 0)
		{
			view.getToolkit().beep();
			return;
		}

backward_scan:	while(--start > 0)
		{
			char c = text.charAt(start);
			int index = openBrackets.indexOf(c);
			if(index != -1)
			{
				if(--count == 0)
				{
					openBracket = c;
					closeBracket = closeBrackets.charAt(index);
					break backward_scan;
				}
			}
			else if(closeBrackets.indexOf(c) != -1)
				count++;
		}

		
		count = 1;

		
		if(openBracket == '\0')
		{
			getToolkit().beep();
			return;
		}
		else
		{
forward_scan:		do
			{
				char c = text.charAt(end);
				if(c == closeBracket)
				{
					if(--count == 0)
					{
						end++;
						break forward_scan;
					}
				}
				else if(c == openBracket)
					count++;
			}
			while(++end < buffer.getLength());
		}

		s = new Selection.Range(start,end);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(end);
	} 

	
	
	public final void invertSelection()
	{
		Selection[] newSelection = new Selection[selection.size() + 1];
		int lastOffset = 0;
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			newSelection[i] = new Selection.Range(lastOffset,
				s.getStart());
			lastOffset = s.getEnd();
		}
		newSelection[selection.size()] = new Selection.Range(
			lastOffset,buffer.getLength());
		setSelection(newSelection);
	} 

	
	
	public int getSelectionCount()
	{
		return selection.size();
	} 

	
	
	public Selection[] getSelection()
	{
		Selection[] sel = new Selection[selection.size()];
		selection.copyInto(sel);
		return sel;
	} 

	
	
	public void selectNone()
	{
		setSelection((Selection)null);
	} 

	
	
	public void setSelection(Selection[] selection)
	{
		
		invalidateSelectedLines();

		this.selection.removeAllElements();

		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
				_addToSelection(selection[i]);
		}

		fireCaretEvent();
	} 

	
	
	public void setSelection(Selection selection)
	{
		invalidateSelectedLines();
		this.selection.removeAllElements();

		if(selection != null)
			_addToSelection(selection);

		fireCaretEvent();
	} 

	
	
	public void addToSelection(Selection[] selection)
	{
		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
				_addToSelection(selection[i]);
		}

		
		invalidateLine(caretLine);

		fireCaretEvent();
	} 

	
	
	public void addToSelection(Selection selection)
	{
		_addToSelection(selection);

		
		invalidateLine(caretLine);

		fireCaretEvent();
	} 

	
	
	public Selection getSelectionAtOffset(int offset)
	{
		if(selection != null)
		{
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);
				if(offset >= s.start && offset <= s.end)
					return s;
			}
		}

		return null;
	} 

	
	
	public void removeFromSelection(Selection sel)
	{
		selection.removeElement(sel);
		invalidateLineRange(sel.startLine,sel.endLine);

		
		invalidateLine(caretLine);

		fireCaretEvent();
	} 

	
	
	public void removeFromSelection(int offset)
	{
		Selection sel = getSelectionAtOffset(offset);
		if(sel == null)
			return;

		selection.removeElement(sel);
		invalidateLineRange(sel.startLine,sel.endLine);

		
		invalidateLine(caretLine);

		fireCaretEvent();
	} 

	
	
	public void resizeSelection(int offset, int end, boolean rect)
	{
		Selection s = getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selection.removeElement(s);
		}

		if(end < offset)
		{
			int tmp = offset;
			offset = end;
			end = tmp;
		}

		Selection newSel;
		if(rect)
			newSel = new Selection.Rect(offset,end);
		else
			newSel = new Selection.Range(offset,end);

		_addToSelection(newSel);
		fireCaretEvent();
	} 

	
	
	public void extendSelection(int offset, int end)
	{
		Selection s = getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selection.removeElement(s);

			if(offset == s.start)
			{
				offset = end;
				end = s.end;
			}
			else if(offset == s.end)
			{
				offset = s.start;
			}
		}

		if(end < offset)
		{
			int tmp = end;
			end = offset;
			offset = tmp;
		}

		_addToSelection(new Selection.Range(offset,end));
		fireCaretEvent();
	} 

	
	
	public String getSelectedText(Selection s)
	{
		StringBuffer buf = new StringBuffer();
		getSelectedText(s,buf);
		return buf.toString();
	} 

	
	
	public String getSelectedText(String separator)
	{
		if(selection.size() == 0)
			return null;

		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < selection.size(); i++)
		{
			if(i != 0)
				buf.append(separator);

			getSelectedText((Selection)selection.elementAt(i),buf);
		}

		return buf.toString();
	} 

	
	
	public String getSelectedText()
	{
		return getSelectedText(""\n"");
	} 

	
	
	public void setSelectedText(Selection s, String selectedText)
	{
		if(!isEditable())
		{
			throw new InternalError(""Text component""
				+ "" read only"");
		}

		try
		{
			buffer.beginCompoundEdit();

			if(s instanceof Selection.Rect)
			{
				int start = s.start - getLineStartOffset(s.startLine);
				int end = s.end - getLineStartOffset(s.endLine);

				
				if(end < start)
				{
					int tmp = end;
					end = start;
					start = tmp;
				}

				int lastNewline = 0;
				int currNewline = 0;

				for(int i = s.startLine; i <= s.endLine; i++)
				{
					int lineStart = getLineStartOffset(i);
					int lineEnd = getLineEndOffset(i) - 1;
					int rectStart = Math.min(lineEnd,lineStart + start);

					buffer.remove(rectStart,Math.min(lineEnd - rectStart,
						end - start));

					if(selectedText == null)
						continue;

					currNewline = selectedText.indexOf('\n',lastNewline);
					if(currNewline == -1)
						currNewline = selectedText.length();

					buffer.insert(rectStart,selectedText
						.substring(lastNewline,currNewline));

					lastNewline = Math.min(selectedText.length(),
						currNewline + 1);
				}

				if(selectedText != null &&
					currNewline != selectedText.length())
				{
					int offset = getLineEndOffset(s.endLine) - 1;
					buffer.insert(offset,""\n"");
					buffer.insert(offset + 1,selectedText
						.substring(currNewline + 1));
				}
			}
			else
			{
				buffer.remove(s.start,s.end - s.start);
				if(selectedText != null && selectedText.length() != 0)
				{
					buffer.insert(s.start,selectedText);
				}
			}
		}
		
		
		finally
		{
			buffer.endCompoundEdit();
		}

		
		
	} 

	
	
	public void setSelectedText(String selectedText)
	{
		if(!isEditable())
		{
			throw new InternalError(""Text component""
				+ "" read only"");
		}

		Selection[] selection = getSelection();
		if(selection.length == 0)
		{
			
			buffer.insert(caret,selectedText);
		}
		else
		{
			try
			{
				buffer.beginCompoundEdit();

				for(int i = 0; i < selection.length; i++)
				{
					setSelectedText(selection[i],selectedText);
				}
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}

		selectNone();
	} 

	
	
	public int[] getSelectedLines()
	{
		if(selection.size() == 0)
			return new int[] { caretLine };

		Integer line;

		Hashtable hash = new Hashtable();
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			int endLine = (s.end == getLineStartOffset(s.endLine)
				? s.endLine - 1
				: s.endLine);

			for(int j = s.startLine; j <= endLine; j++)
			{
				line = new Integer(j);
				hash.put(line,line);
			}
		}

		int[] returnValue = new int[hash.size()];
		int i = 0;

		Enumeration keys = hash.keys();
		while(keys.hasMoreElements())
		{
			line = (Integer)keys.nextElement();
			returnValue[i++] = line.intValue();
		}

		Arrays.sort(returnValue);

		return returnValue;
	} 

	
	
	public void showSelectLineRangeDialog()
	{
		new SelectLineRange(view);
	} 

	

	

	
	
	public final void blinkCaret()
	{
		if(caretBlinks)
		{
			blink = !blink;
			invalidateLine(caretLine);
		}
		else
			blink = true;
	} 

	
	
	public void centerCaret()
	{
		int offset = getScreenLineStartOffset(visibleLines / 2);
		if(offset == -1)
			getToolkit().beep();
		else
			setCaretPosition(offset);
	} 

	
	
	public void setCaretPosition(int newCaret)
	{
		invalidateSelectedLines();
		selection.removeAllElements();
		moveCaretPosition(newCaret,true);
	} 

	
	
	public void setCaretPosition(int newCaret, boolean doElectricScroll)
	{
		invalidateSelectedLines();
		selection.removeAllElements();
		moveCaretPosition(newCaret,doElectricScroll);
	} 

	
	
	public void moveCaretPosition(int newCaret)
	{
		moveCaretPosition(newCaret,true);
	} 

	
	
	public void moveCaretPosition(int newCaret, boolean doElectricScroll)
	{
		if(newCaret < 0 || newCaret > buffer.getLength())
		{
			throw new IllegalArgumentException(""caret out of bounds: ""
				+ newCaret);
		}

		
		
		blink = true;
		caretTimer.restart();

		if(caret == newCaret)
		{
			if(focusedComponent == this)
				finishCaretUpdate(doElectricScroll,false);
			return;
		}

		int newCaretLine = getLineOfOffset(newCaret);

		magicCaret = -1;

		if(!foldVisibilityManager.isLineVisible(newCaretLine))
		{
			if(foldVisibilityManager.isNarrowed())
			{
				int collapseFolds = buffer.getIntegerProperty(
					""collapseFolds"",0);
				if(collapseFolds != 0)
					foldVisibilityManager.expandFolds(collapseFolds);
				else
					foldVisibilityManager.expandAllFolds();
			}
			else
				foldVisibilityManager.expandFold(newCaretLine,false);
		}

		if(caretLine == newCaretLine)
		{
			if(caretScreenLine != -1)
				invalidateScreenLineRange(caretScreenLine,caretScreenLine);
		}
		else
		{
			caretScreenLine = chunkCache.getScreenLineOfOffset(newCaretLine,
				newCaret - buffer.getLineStartOffset(newCaretLine));
			invalidateLineRange(caretLine,newCaretLine);
		}

		caret = newCaret;
		caretLine = newCaretLine;

		if(focusedComponent == this)
			finishCaretUpdate(doElectricScroll,true);
	} 

	
	
	public int getCaretPosition()
	{
		return caret;
	} 

	
	
	public int getCaretLine()
	{
		return caretLine;
	} 

	
	
	public final int getMagicCaretPosition()
	{
		if(magicCaret == -1)
		{
			magicCaret = offsetToX(caretLine,caret
				- getLineStartOffset(caretLine));
		}

		return magicCaret;
	} 

	
	
	public final void setMagicCaretPosition(int magicCaret)
	{
		this.magicCaret = magicCaret;
	} 

	
	
	public final void addCaretListener(CaretListener listener)
	{
		listenerList.add(CaretListener.class,listener);
	} 

	
	
	public final void removeCaretListener(CaretListener listener)
	{
		listenerList.remove(CaretListener.class,listener);
	} 

	
	
	public final int getBracketPosition()
	{
		return bracketPosition;
	} 

	
	
	public final int getBracketLine()
	{
		return bracketLine;
	} 

	
	
	public void goToNextBracket(boolean select)
	{
		String text = getText(caret,buffer.getLength() - caret - 1);

		int newCaret = -1;

loop:		for(int i = 0; i < text.length(); i++)
		{
			switch(text.charAt(i))
			{
			case ')': case ']': case '}':
				newCaret = caret + i + 1;
				break loop;
			}
		}

		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	} 

	
	
	public void goToNextCharacter(boolean select)
	{
		if(!select && selection.size() != 0)
		{
			Selection s = getSelectionAtOffset(caret);
			if(s != null)
			{
				if(multi)
				{
					if(caret != s.end)
					{
						moveCaretPosition(s.end);
						return;
					}
				}
				else
				{
					setCaretPosition(s.end);
					return;
				}
			}
		}

		if(caret == buffer.getLength())
			getToolkit().beep();

		int newCaret;

		if(caret == getLineEndOffset(caretLine) - 1)
		{
			int line = foldVisibilityManager.getNextVisibleLine(caretLine);
			if(line == -1)
			{
				getToolkit().beep();
				return;
			}

			newCaret = getLineStartOffset(line);
		}
		else
			newCaret = caret + 1;

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
	} 

	
	
	public void goToNextLine(boolean select)
	{
		ChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(caretLine);

		int caretFromStartOfLine = caret - buffer.getLineStartOffset(caretLine);
		int subregion = getSubregionOfOffset(caretFromStartOfLine,
			lineInfos);

		int magic = this.magicCaret;
		if(magic == -1)
		{
			magic = subregionOffsetToX(lineInfos[subregion],
				caretFromStartOfLine);
		}

		int newCaret;

		if(subregion != lineInfos.length - 1)
		{
			newCaret = buffer.getLineStartOffset(caretLine)
				+ xToSubregionOffset(lineInfos[subregion + 1],magic,
				true);
		}
		else
		{
			int nextLine = foldVisibilityManager.getNextVisibleLine(caretLine);

			if(nextLine == -1)
			{
				int end = getLineEndOffset(caretLine) - 1;
				if(caret == end)
				{
					getToolkit().beep();
					return;
				}
				else
					newCaret = end;
			}
			else
			{
				lineInfos = chunkCache.getLineInfosForPhysicalLine(nextLine);
				newCaret = getLineStartOffset(nextLine)
					+ xToSubregionOffset(lineInfos[0],magic + 1,
					true);
			}
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);

		this.magicCaret = magic;
	} 

	
	
	public void goToNextMarker(boolean select)
	{
		Vector markers = buffer.getMarkers();
		if(markers.size() == 0)
		{
			getToolkit().beep();
			return;
		}

		Marker marker = null;

		for(int i = 0; i < markers.size(); i++)
		{
			Marker _marker = (Marker)markers.get(i);
			if(_marker.getPosition() > caret)
			{
				marker = _marker;
				break;
			}
		}

		if(marker == null)
			marker = (Marker)markers.get(0);

		if(select)
			extendSelection(caret,marker.getPosition());
		else if(!multi)
			selectNone();
		moveCaretPosition(marker.getPosition());
	} 

	
	
	public void goToNextPage(boolean select)
	{
		int lineCount = getVirtualLineCount();

		int magic = getMagicCaretPosition();

		if(firstLine + visibleLines * 2 >= lineCount - 1)
			setFirstLine(lineCount - visibleLines);
		else
			setFirstLine(firstLine + visibleLines);

		int newLine = virtualToPhysical(Math.min(lineCount - 1,
			physicalToVirtual(caretLine) + visibleLines));
		int newCaret = getLineStartOffset(newLine)
			+ xToOffset(newLine,magic + 1);

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);

		setMagicCaretPosition(magic);
	} 

	
	
	public void goToNextParagraph(boolean select)
	{
		int lineNo = getCaretLine();

		int newCaret = getBufferLength();

		boolean foundBlank = false;

loop:		for(int i = lineNo + 1; i < getLineCount(); i++)
		{
			if(!foldVisibilityManager.isLineVisible(i))
				continue;

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineStartOffset(i);
						break loop;
					}
					else
						continue loop;
				}
			}

			foundBlank = true;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToNextWord(boolean select)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);

		if(newCaret == lineText.length())
		{
			int nextLine = foldVisibilityManager.getNextVisibleLine(caretLine);
			if(nextLine == -1)
			{
				getToolkit().beep();
				return;
			}

			newCaret = getLineStartOffset(nextLine);
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			newCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,
				noWordSep) + lineStart;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToPrevBracket(boolean select)
	{
		String text = getText(0,caret);

		int newCaret = -1;

loop:		for(int i = getCaretPosition() - 1; i >= 0; i--)
		{
			switch(text.charAt(i))
			{
			case '(': case '[': case '{':
				newCaret = i;
				break loop;
			}
		}

		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	} 

	
	
	public void goToPrevCharacter(boolean select)
	{
		if(!select && selection.size() != 0)
		{
			Selection s = getSelectionAtOffset(caret);
			if(s != null)
			{
				if(multi)
				{
					if(caret != s.start)
					{
						moveCaretPosition(s.start);
						return;
					}
				}
				else
				{
					setCaretPosition(s.start);
					return;
				}
			}
		}

		int newCaret;

		if(caret == getLineStartOffset(caretLine))
		{
			int line = foldVisibilityManager.getPrevVisibleLine(caretLine);
			if(line == -1)
			{
				getToolkit().beep();
				return;
			}
			newCaret = getLineEndOffset(line) - 1;
		}
		else
			newCaret = caret - 1;

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToPrevLine(boolean select)
	{
		ChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(caretLine);

		int caretFromStartOfLine = caret - buffer.getLineStartOffset(caretLine);
		int subregion = getSubregionOfOffset(caretFromStartOfLine,
			lineInfos);

		int magic = this.magicCaret;
		if(magic == -1)
		{
			magic = subregionOffsetToX(lineInfos[subregion],
				caretFromStartOfLine);
		}

		int newCaret;

		if(subregion != 0)
		{
			newCaret = buffer.getLineStartOffset(caretLine)
				+ xToSubregionOffset(lineInfos[subregion - 1],magic,
				true);
		}
		else
		{
			int prevLine = foldVisibilityManager.getPrevVisibleLine(caretLine);

			if(prevLine == -1)
			{
				int start = getLineStartOffset(caretLine);
				if(caret == start)
				{
					getToolkit().beep();
					return;
				}
				else
					newCaret = start;
			}
			else
			{
				lineInfos = chunkCache.getLineInfosForPhysicalLine(prevLine);
				newCaret = getLineStartOffset(prevLine)
					+ xToSubregionOffset(lineInfos[
					lineInfos.length - 1],magic + 1,
					true);
			}
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);

		this.magicCaret = magic;
	} 

	
	
	public void goToPrevMarker(boolean select)
	{
		Vector markers = buffer.getMarkers();
		if(markers.size() == 0)
		{
			getToolkit().beep();
			return;
		}

		Marker marker = null;
		for(int i = markers.size() - 1; i >= 0; i--)
		{
			Marker _marker = (Marker)markers.elementAt(i);
			if(_marker.getPosition() < caret)
			{
				marker = _marker;
				break;
			}
		}

		if(marker == null)
			marker = (Marker)markers.get(markers.size() - 1);

		if(select)
			extendSelection(caret,marker.getPosition());
		else if(!multi)
			selectNone();
		moveCaretPosition(marker.getPosition());
	} 

	
	
	public void goToPrevPage(boolean select)
	{
		if(firstLine < visibleLines)
			setFirstLine(0);
		else
			setFirstLine(firstLine - visibleLines);

		int magic = getMagicCaretPosition();

		int newLine = virtualToPhysical(Math.max(0,
			physicalToVirtual(caretLine) - visibleLines));
		int newCaret = getLineStartOffset(newLine)
			+ xToOffset(newLine,magic + 1);

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void goToPrevParagraph(boolean select)
	{
		int lineNo = caretLine;
		int newCaret = 0;

		boolean foundBlank = false;

loop:		for(int i = lineNo - 1; i >= 0; i--)
		{
			if(!foldVisibilityManager.isLineVisible(i))
				continue;

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineEndOffset(i) - 1;
						break loop;
					}
					else
						continue loop;
				}
			}

			foundBlank = true;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToPrevWord(boolean select)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);

		if(newCaret == 0)
		{
			if(lineStart == 0)
			{
				view.getToolkit().beep();
				return;
			}
			else
			{
				int prevLine = foldVisibilityManager.getPrevVisibleLine(caretLine);
				if(prevLine == -1)
				{
					getToolkit().beep();
					return;
				}

				newCaret = getLineEndOffset(prevLine) - 1;
			}
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			newCaret = TextUtilities.findWordStart(lineText,newCaret - 1,
				noWordSep) + lineStart;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void smartHome(boolean select)
	{
		if(!jEdit.getBooleanProperty(""view.homeEnd""))
			goToStartOfLine(select);
		else
		{
			switch(view.getInputHandler().getLastActionCount())
			{
			case 1:
				goToStartOfWhiteSpace(select);
				break;
			case 2:
				goToStartOfLine(select);
				break;
			default: 
				goToFirstVisibleLine(select);
				break;
			}
		}
	} 

	
	
	public void smartEnd(boolean select)
	{
		if(!jEdit.getBooleanProperty(""view.homeEnd""))
			goToEndOfLine(select);
		else
		{
			switch(view.getInputHandler().getLastActionCount())
			{
			case 1:
				goToEndOfWhiteSpace(select);
				break;
			case 2:
				goToEndOfLine(select);
				break;
			default: 
				goToLastVisibleLine(select);
				break;
			}
		}
	} 

	
	
	public void goToStartOfLine(boolean select)
	{
		
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToStartOfLine("" + select + "");"");

		Selection s = getSelectionAtOffset(caret);
		int line = (select || s == null
			? caretLine : s.startLine);
		int newCaret = getLineStartOffset(line);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToEndOfLine(boolean select)
	{
		
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToEndOfLine("" + select + "");"");

		Selection s = getSelectionAtOffset(caret);
		int line = (select || s == null
			? caretLine : s.endLine);
		int newCaret = getLineEndOffset(line) - 1;
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);

		
		
		setMagicCaretPosition(Integer.MAX_VALUE);
	} 

	
	
	public void goToStartOfWhiteSpace(boolean select)
	{
		
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToStartOfWhiteSpace("" + select + "");"");

		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null)
		{
			line = caretLine;
			offset = caret - buffer.getLineStartOffset(line);
		}
		else
		{
			line = s.startLine;
			offset = s.start - buffer.getLineStartOffset(line);
		}

		int firstIndent;

		ChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(line);
		int subregion = getSubregionOfOffset(offset,lineInfos);
		if(subregion == 0)
		{
			firstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));
			if(firstIndent == getLineLength(line))
				firstIndent = 0;
			firstIndent += getLineStartOffset(line);
		}
		else
		{
			firstIndent = getLineStartOffset(line)
				+ lineInfos[subregion].offset;
		}

		if(select)
			extendSelection(caret,firstIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstIndent);
	} 

	
	
	public void goToEndOfWhiteSpace(boolean select)
	{
		
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToEndOfWhiteSpace("" + select + "");"");

		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null)
		{
			line = caretLine;
			offset = caret - getLineStartOffset(line);
		}
		else
		{
			line = s.endLine;
			offset = s.end - getLineStartOffset(line);
		}

		int lastIndent;

		ChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(line);
		int subregion = getSubregionOfOffset(offset,lineInfos);
		if(subregion == lineInfos.length - 1)
		{
			lastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));
			if(lastIndent == 0)
				lastIndent = getLineLength(line);
			lastIndent += getLineStartOffset(line);
		}
		else
		{
			lastIndent = getLineStartOffset(line)
				+ lineInfos[subregion].offset
				+ lineInfos[subregion].length - 1;
		}

		if(select)
			extendSelection(caret,lastIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastIndent);
	} 

	
	
	public void goToFirstVisibleLine(boolean select)
	{
		
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToFirstVisibleLine("" + select + "");"");

		int firstVisibleLine = firstLine == 0 ? 0 : electricScroll;
		int firstVisible = getScreenLineStartOffset(firstVisibleLine);
		if(firstVisible == -1)
		{
			firstVisible = getLineStartOffset(foldVisibilityManager
				.getFirstVisibleLine());
		}

		if(select)
			extendSelection(caret,firstVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstVisible);
	} 

	
	
	public void goToLastVisibleLine(boolean select)
	{
		
		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(""textArea.goToLastVisibleLine("" + select + "");"");

		int lastVisible;

		if(firstLine + visibleLines >= getVirtualLineCount())
		{
			lastVisible = getLineEndOffset(foldVisibilityManager
				.getLastVisibleLine()) - 1;
		}
		else
		{
			lastVisible = getScreenLineEndOffset(visibleLines
				- electricScroll - 1) - 1;
			if(lastVisible == -1)
			{
				lastVisible = getLineEndOffset(foldVisibilityManager
					.getLastVisibleLine()) - 1;
			}
		}

		if(select)
			extendSelection(caret,lastVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastVisible);
	} 

	
	
	public void goToBufferStart(boolean select)
	{
		int start = buffer.getLineStartOffset(
			foldVisibilityManager.getFirstVisibleLine());
		if(select)
			extendSelection(caret,start);
		else if(!multi)
			selectNone();
		moveCaretPosition(start);
	} 

	
	
	public void goToBufferEnd(boolean select)
	{
		int end = buffer.getLineEndOffset(
			foldVisibilityManager.getLastVisibleLine()) - 1;
		if(select)
			extendSelection(caret,end);
		else if(!multi)
			selectNone();
		moveCaretPosition(end);
	} 

	
	
	public void goToMatchingBracket()
	{
		if(getLineLength(caretLine) != 0)
		{
			int dot = caret - getLineStartOffset(caretLine);

			int bracket = TextUtilities.findMatchingBracket(
				buffer,caretLine,Math.max(0,dot - 1));
			if(bracket != -1)
			{
				selectNone();
				moveCaretPosition(bracket + 1,false);
				return;
			}
		}

		getToolkit().beep();
	} 

	
	
	public void showGoToLineDialog()
	{
		String line = GUIUtilities.input(view,""goto-line"",null);
		if(line == null)
			return;

		try
		{
			int lineNumber = Integer.parseInt(line) - 1;
			setCaretPosition(getLineStartOffset(lineNumber));
		}
		catch(Exception e)
		{
			getToolkit().beep();
		}
	} 

	

	

	
	
	public void userInput(char ch)
	{
		if(!isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(ch == ' ' && Abbrevs.getExpandOnInput()
			&& Abbrevs.expandAbbrev(view,false))
			return;
		else if(ch == '\t')
		{
			if(selection.size() == 1)
			{
				Selection sel = (Selection)selection.elementAt(0);
				if(sel.startLine == sel.endLine
					&& sel.start != buffer.getLineStartOffset(sel.startLine)
					&& sel.end != buffer.getLineEndOffset(sel.startLine) - 1)
				{
					insertTab();
				}
				else
					shiftIndentRight();
			}
			else if(selection.size() != 0)
				shiftIndentRight();
			else if(buffer.getBooleanProperty(""indentOnTab""))
			{
				
				String text = buffer.getLineText(caretLine);
				int start = buffer.getLineStartOffset(caretLine);
				int whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);

				if(caret - start <= whiteSpace
					&& buffer.indentLine(caretLine,true,false))
					return;
				else
					insertTab();
			}
			else
				insertTab();
			return;
		}
		else if(ch == '\n')
		{
			try
			{
				buffer.beginCompoundEdit();
				setSelectedText(""\n"");
				if(buffer.getBooleanProperty(""indentOnEnter""))
					buffer.indentLine(caretLine,true,false);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
			return;
		}
		else
		{
			String str = String.valueOf(ch);
			if(selection.size() != 0)
			{
				setSelectedText(str);
				return;
			}

			if(ch == ' ')
			{
				if(doWordWrap(true))
					return;
			}
			else
				doWordWrap(false);

			try
			{
				
				
				if(overwrite)
				{
					buffer.beginCompoundEdit();

					int caretLineEnd = getLineEndOffset(caretLine);
					if(caretLineEnd - caret > 1)
						buffer.remove(caret,1);
				}

				buffer.insert(caret,str);
			}
			finally
			{
				if(overwrite)
					buffer.endCompoundEdit();
			}
		}

		
		String indentOpenBrackets = (String)buffer
			.getProperty(""indentOpenBrackets"");
		String indentCloseBrackets = (String)buffer
			.getProperty(""indentCloseBrackets"");
		if((indentCloseBrackets != null
			&& indentCloseBrackets.indexOf(ch) != -1)
			|| (indentOpenBrackets != null
			&& indentOpenBrackets.indexOf(ch) != -1))
		{
			buffer.indentLine(caretLine,false,true);
		}
	} 

	
	
	public final boolean isOverwriteEnabled()
	{
		return overwrite;
	} 

	
	
	public final void setOverwriteEnabled(boolean overwrite)
	{
		blink = true;
		caretTimer.restart();

		this.overwrite = overwrite;
		invalidateLine(caretLine);
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
	} 

	
	
	public final void toggleOverwriteEnabled()
	{
		setOverwriteEnabled(!overwrite);
	} 

	
	
	public void backspace()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(selection.size() != 0)
			setSelectedText(null);
		else
		{
			if(caret == 0)
			{
				getToolkit().beep();
				return;
			}

			buffer.remove(caret - 1,1);
		}
	} 

	
	
	public void backspaceWord()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(selection.size() != 0)
		{
			setSelectedText("""");
			return;
		}

		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;

		String lineText = getLineText(caretLine);

		if(_caret == 0)
		{
			if(lineStart == 0)
			{
				getToolkit().beep();
				return;
			}
			_caret--;
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep);
		}

		buffer.remove(_caret + lineStart,
			caret - (_caret + lineStart));
	} 

	
	
	public void delete()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(selection.size() != 0)
			setSelectedText(null);
		else
		{
			if(caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}

			buffer.remove(caret,1);
		}
	} 

	
	
	public void deleteToEndOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.remove(caret,getLineEndOffset(caretLine)
			- caret - 1);
	} 

	
	
	public void deleteLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine);
		if(end > buffer.getLength())
		{
			if(start != 0)
				start--;
			end--;
		}
		int x = offsetToX(caretLine,caret - start);
		buffer.remove(start,end - start);

		int lastLine = buffer.getLineCount() - 1;
		if(caretLine == lastLine)
		{
			setCaretPosition(buffer.getLineStartOffset(lastLine)
				+ xToOffset(caretLine,x));
		}
		else
		{
			setCaretPosition(start + xToOffset(caretLine,x));
		}
	} 

	
	
	public void deleteParagraph()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		int start = 0, end = buffer.getLength();

loop:		for(int i = caretLine - 1; i >= 0; i--)
		{
			
			

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					continue loop;
				}
			}

			start = getLineStartOffset(i);
			break loop;
		}

loop:		for(int i = caretLine + 1; i < getLineCount(); i++)
		{
			
			

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					continue loop;
				}
			}

			end = getLineEndOffset(i) - 1;
			break loop;
		}

		buffer.remove(start,end - start);
	} 

	
	
	public void deleteToStartOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.remove(getLineStartOffset(caretLine),
			caret - getLineStartOffset(caretLine));
	} 

	
	
	public void deleteWord()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(selection.size() != 0)
		{
			setSelectedText("""");
			return;
		}

		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;

		String lineText = getLineText(caretLine);

		if(_caret == lineText.length())
		{
			if(lineStart + _caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}
			_caret++;
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			_caret = TextUtilities.findWordEnd(lineText,
				_caret+1,noWordSep);
		}

		buffer.remove(caret,(_caret + lineStart) - caret);
	} 

	
	
	public final boolean isMultipleSelectionEnabled()
	{
		return multi;
	} 

	
	
	public final void toggleMultipleSelectionEnabled()
	{
		multi = !multi;
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
	} 

	
	
	public final void setMultipleSelectionEnabled(boolean multi)
	{
		JEditTextArea.multi = multi;
		EditBus.send(new MultiSelectStatusChanged(null));
	}
	

	

	

	
	
	public void goToMarker(char shortcut, boolean select)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}

		int pos = marker.getPosition();

		if(select)
			extendSelection(caret,pos);
		else if(!multi)
			selectNone();
		moveCaretPosition(pos);
	} 

	
	
	public void addMarker()
	{
		
		Selection[] selection = getSelection();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			if(s.startLine != s.endLine)
			{
				if(s.startLine != caretLine)
					buffer.addMarker('\0',s.start);
			}

			if(s.endLine != caretLine)
				buffer.addMarker('\0',s.end);
		}

		
		buffer.addOrRemoveMarker('\0',caret);
	} 

	
	
	public void swapMarkerAndCaret(char shortcut)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}

		int caret = getCaretPosition();

		setCaretPosition(marker.getPosition());
		buffer.addMarker(shortcut,caret);
	} 

	

	

	
	
	public void goToParentFold()
	{
		int line = -1;
		int level = buffer.getFoldLevel(caretLine);
		for(int i = caretLine - 1; i >= 0; i--)
		{
			if(buffer.getFoldLevel(i) < level)
			{
				line = i;
				break;
			}
		}

		if(line == -1)
		{
			getToolkit().beep();
			return;
		}

		int magic = getMagicCaretPosition();

		int newCaret = buffer.getLineStartOffset(line)
			+ xToOffset(line,magic + 1);
		if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void goToNextFold(boolean select)
	{
		int line = caretLine;

		int nextFold = -1;
		for(int i = caretLine + 1; i < buffer.getLineCount(); i++)
		{
			if(buffer.isFoldStart(i)
				&& foldVisibilityManager.isLineVisible(i))
			{
				nextFold = i;
				break;
			}
		}

		if(nextFold == -1)
		{
			getToolkit().beep();
			return;
		}

		int magic = getMagicCaretPosition();

		int newCaret = buffer.getLineStartOffset(nextFold)
			+ xToOffset(nextFold,magic + 1);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void goToPrevFold(boolean select)
	{
		int line = caretLine;

		int prevFold = -1;
		for(int i = caretLine - 1; i >= 0; i--)
		{
			if(buffer.isFoldStart(i)
				&& foldVisibilityManager.isLineVisible(i))
			{
				prevFold = i;
				break;
			}
		}

		if(prevFold == -1)
		{
			getToolkit().beep();
			return;
		}

		int magic = getMagicCaretPosition();

		int newCaret = buffer.getLineStartOffset(prevFold)
			+ xToOffset(prevFold,magic + 1);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void collapseFold()
	{
		int x = offsetToX(caretLine,caret - getLineStartOffset(caretLine));

		foldVisibilityManager.collapseFold(caretLine);

		if(foldVisibilityManager.isLineVisible(caretLine))
			return;

		int line = foldVisibilityManager.getPrevVisibleLine(caretLine);

		if(!multi)
			selectNone();
		moveCaretPosition(buffer.getLineStartOffset(line) + xToOffset(line,x));
	} 

	
	
	public void expandFold(boolean fully)
	{
		int x = offsetToX(caretLine,caret - getLineStartOffset(caretLine));

		int line = foldVisibilityManager.expandFold(caretLine,fully);

		if(line != -1)
		{
			if(!multi)
				selectNone();
			moveCaretPosition(getLineStartOffset(line) + xToOffset(line,x));
		}
	} 

	
	
	public void selectFold()
	{
		selectFold(caretLine);
	} 

	
	
	public void selectFold(int line)
	{
		int[] lines = buffer.getFoldAtLine(line);

		int newCaret = getLineEndOffset(lines[1]) - 1;
		Selection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(newCaret);
	} 

	
	
	public void narrowToFold()
	{
		int[] lines = buffer.getFoldAtLine(caretLine);
		if(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)
			getToolkit().beep();
		else
			foldVisibilityManager.narrow(lines[0],lines[1]);
	} 

	
	
	public void narrowToSelection()
	{
		if(selection.size() != 1)
		{
			getToolkit().beep();
			return;
		}

		Selection sel = (Selection)selection.elementAt(0);
		foldVisibilityManager.narrow(sel.getStartLine(),sel.getEndLine());

		selectNone();
	} 

	
	
	public void addExplicitFold()
	{
		if(!buffer.getStringProperty(""folding"").equals(""explicit""))
		{
			GUIUtilities.error(view,""folding-not-explicit"",null);
			return;
		}

		
		
		String lineComment = buffer.getContextSensitiveProperty(caret,""lineComment"");
		String commentStart = buffer.getContextSensitiveProperty(caret,""commentStart"");
		String commentEnd = buffer.getContextSensitiveProperty(caret,""commentEnd"");

		String start, end;
		if(lineComment != null)
		{
			start = lineComment + ""{{{ \n"";
			end = lineComment + ""}}}"";
		}
		else if(commentStart != null && commentEnd != null)
		{
			start = commentStart + ""{{{  "" + commentEnd + ""\n"";
			end = commentStart + ""}}}"" + commentEnd;
		}
		else
		{
			start = ""{{{ \n"";
			end = ""}}}"";
		}

		try
		{
			buffer.beginCompoundEdit();

			if(selection.size() == 0)
			{
				String line = buffer.getLineText(caretLine);
				String whitespace = line.substring(0,
					MiscUtilities.getLeadingWhiteSpace(line));
				int loc = caret + start.length() - 1;
				start = start + whitespace;
				buffer.insert(caret,start);
				
				buffer.insert(caret,end);
				moveCaretPosition(loc,false);
			}
			else
			{
				int loc = -1;

				for(int i = 0; i < selection.size(); i++)
				{
					Selection s = (Selection)selection.elementAt(i);
					String line = buffer.getLineText(s.startLine);
					String whitespace = line.substring(0,
						MiscUtilities.getLeadingWhiteSpace(line));
					loc = s.start + start.length() - 1;
					buffer.insert(s.start,start + whitespace);
					buffer.insert(s.end,"" "" + end);
				}

				setCaretPosition(loc,false);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	

	

	
	
	public void lineComment()
	{
		String comment = buffer.getContextSensitiveProperty(caret,""lineComment"");
		if(!buffer.isEditable() || comment == null || comment.length() == 0)
		{
			getToolkit().beep();
			return;
		}

		comment = comment + ' ';

		buffer.beginCompoundEdit();

		int[] lines = getSelectedLines();

		try
		{
			for(int i = 0; i < lines.length; i++)
			{
				String text = getLineText(lines[i]);
				buffer.insert(getLineStartOffset(lines[i])
					+ MiscUtilities.getLeadingWhiteSpace(text),
					comment);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		selectNone();
	} 

	
	
	public void rangeComment()
	{
		String commentStart = buffer.getContextSensitiveProperty(caret,""commentStart"");
		String commentEnd = buffer.getContextSensitiveProperty(caret,""commentEnd"");
		if(!buffer.isEditable() || commentStart == null || commentEnd == null
			|| commentStart.length() == 0 || commentEnd.length() == 0)
		{
			getToolkit().beep();
			return;
		}

		commentStart = commentStart + ' ';
		commentEnd = ' ' + commentEnd;

		try
		{
			buffer.beginCompoundEdit();

			Selection[] selection = getSelection();

			if(selection.length == 0)
			{
				int oldCaret = caret;
				buffer.insert(caret,
					commentStart);
				buffer.insert(caret,
					commentEnd);
				setCaretPosition(oldCaret + commentStart.length());
			}

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				if(s instanceof Selection.Range)
				{
					buffer.insert(s.start,
						commentStart);
					buffer.insert(s.end,
						commentEnd);
				}
				else if(s instanceof Selection.Rect)
				{
					for(int j = s.startLine; j <= s.endLine; j++)
					{
						buffer.insert(s.getStart(buffer,j),
							commentStart);
						int end = s.getEnd(buffer,j)
							+ (j == s.endLine
							? 0 : commentStart.length());
						buffer.insert(end,commentEnd);
					}
				}
			}

			selectNone();
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	
	
	public void formatParagraph()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(maxLineLen <= 0)
		{
			getToolkit().beep();
			return;
		}

		Selection[] selection = getSelection();
		if(selection.length != 0)
		{
			buffer.beginCompoundEdit();

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.format(
					getSelectedText(s),maxLineLen));
			}

			buffer.endCompoundEdit();
		}
		else
		{
			int lineNo = getCaretLine();

			int start = 0, end = buffer.getLength();

loop:			for(int i = lineNo - 1; i >= 0; i--)
			{
				getLineText(i,lineSegment);

				for(int j = 0; j < lineSegment.count; j++)
				{
					switch(lineSegment.array[lineSegment.offset + j])
					{
					case ' ':
					case '\t':
						break;
					default:
						continue loop;
					}
				}

				start = getLineStartOffset(i);
				break loop;
			}

loop:			for(int i = lineNo + 1; i < getLineCount(); i++)
			{
				getLineText(i,lineSegment);

				for(int j = 0; j < lineSegment.count; j++)
				{
					switch(lineSegment.array[lineSegment.offset + j])
					{
					case ' ':
					case '\t':
						break;
					default:
						continue loop;
					}
				}

				end = getLineEndOffset(i) - 1;
				break loop;
			}

			try
			{
				buffer.beginCompoundEdit();

				String text = buffer.getText(start,end - start);
				buffer.remove(start,end - start);
				buffer.insert(start,TextUtilities.format(
					text,maxLineLen));
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} 

	
	
	public void spacesToTabs()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.beginCompoundEdit();

		if(selection.length == 0)
		{
			setText(TextUtilities.spacesToTabs(
				getText(), buffer.getTabSize()));
		}
		else
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.spacesToTabs(
					getSelectedText(s),buffer.getTabSize()));
			}
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void tabsToSpaces()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.beginCompoundEdit();

		if(selection.length == 0)
		{
			setText(TextUtilities.tabsToSpaces(
				getText(), buffer.getTabSize()));
		}
		else
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.tabsToSpaces(
					getSelectedText(s),buffer.getTabSize()));
			}
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void toUpperCase()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }

		buffer.beginCompoundEdit();

		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toUpperCase());
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void toLowerCase()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }

		buffer.beginCompoundEdit();

		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toLowerCase());
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void removeTrailingWhiteSpace()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.removeTrailingWhiteSpace(getSelectedLines());
		}
	} 

	
	
	public void indentSelectedLines()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.indentLines(getSelectedLines());
			selectNone();
		}
	} 

	
	
	public void shiftIndentLeft()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.shiftIndentLeft(getSelectedLines());
		}
	} 

	
	
	public void shiftIndentRight()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
			buffer.shiftIndentRight(getSelectedLines());
	} 

	
	
	public void joinLines()
	{
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine);
		if(end > buffer.getLength())
		{
			getToolkit().beep();
			return;
		}
		buffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(
			buffer.getLineText(caretLine + 1)) + 1);

		setCaretPosition(end - 1);
	} 

	
	
	public void showWordCountDialog()
	{
		String selection = getSelectedText();
		if(selection != null)
		{
			doWordCount(view,selection);
			return;
		}

		doWordCount(view,buffer.getText(0,buffer.getLength()));
	} 

	

	

	
	
	public void addNotify()
	{
		super.addNotify();

		ToolTipManager.sharedInstance().registerComponent(painter);
		ToolTipManager.sharedInstance().registerComponent(gutter);

		if(!bufferHandlerInstalled)
		{
			bufferHandlerInstalled = true;
			buffer.addBufferChangeListener(bufferHandler);
		}

		recalculateVisibleLines();
		recalculateLastPhysicalLine();
	} 

	
	
	public void removeNotify()
	{
		super.removeNotify();

		ToolTipManager.sharedInstance().unregisterComponent(painter);
		ToolTipManager.sharedInstance().unregisterComponent(gutter);

		if(focusedComponent == this)
			focusedComponent = null;

		if(bufferHandlerInstalled)
		{
			buffer.removeBufferChangeListener(bufferHandler);
			bufferHandlerInstalled = false;
		}
	} 

	
	
	public boolean hasFocus()
	{
		Component c = this;
		while(!(c instanceof Window))
		{
			if(c == null)
				return false;
			c = c.getParent();
		}

		Component focusOwner = ((Window)c).getFocusOwner();
		boolean hasFocus = (focusOwner == this);
		if(hasFocus && focusedComponent != this)
			focusedComponent = this;
		return hasFocus;
	} 

	
	
	public void grabFocus()
	{
		super.grabFocus();
		
		hasFocus();
	} 

	
	
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} 

	
	public void processKeyEvent(KeyEvent evt)
	{
		evt = KeyEventWorkaround.processKeyEvent(evt);
		if(evt == null)
			return;

		
		if(view.isClosed())
			return;

		InputHandler inputHandler = view.getInputHandler();
		KeyListener keyEventInterceptor = view.getKeyEventInterceptor();
		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyTyped(evt);
			else
				inputHandler.keyTyped(evt);
			break;
		case KeyEvent.KEY_PRESSED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyPressed(evt);
			else
				inputHandler.keyPressed(evt);
			break;
		case KeyEvent.KEY_RELEASED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyReleased(evt);
			else
				inputHandler.keyReleased(evt);
			break;
		}

		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	

	
	
	public void propertiesChanged()
	{
		if(buffer == null)
			return;

		int _tabSize = buffer.getTabSize();
		char[] foo = new char[_tabSize];
		for(int i = 0; i < foo.length; i++)
		{
			foo[i] = ' ';
		}

		tabSize = (float)painter.getFont().getStringBounds(foo,0,_tabSize,
			painter.getFontRenderContext()).getWidth();

		charWidth = (int)Math.round(painter.getFont().getStringBounds(foo,0,1,
			painter.getFontRenderContext()).getWidth());

		String wrap = buffer.getStringProperty(""wrap"");
		softWrap = wrap.equals(""soft"");
		hardWrap = wrap.equals(""hard"");

		maxLineLen = buffer.getIntegerProperty(""maxLineLen"",0);

		if(maxLineLen <= 0)
		{
			if(softWrap)
			{
				wrapToWidth = true;
				wrapMargin = painter.getWidth() - charWidth * 3;
			}
			else
			{
				wrapToWidth = false;
				wrapMargin = 0;
			}
		}
		else
		{
			
			foo = new char[maxLineLen];
			for(int i = 0; i < foo.length; i++)
			{
				foo[i] = ' ';
			}
			wrapToWidth = false;
			wrapMargin = (int)painter.getFont().getStringBounds(
				foo,0,maxLineLen,painter.getFontRenderContext())
				.getWidth();
		}

		maxHorizontalScrollWidth = 0;
		updateScrollBars();

		chunkCache.invalidateAll();
		gutter.repaint();
		painter.repaint();
	} 

	

	
	
	public boolean setOrigin(int firstLine, int horizontalOffset)
	{
		setFirstLine(firstLine);
		setHorizontalOffset(horizontalOffset);
		return true;
	} 

	
	
	public int lineToY(int line)
	{
		FontMetrics fm = painter.getFontMetrics();
		return (line - firstLine) * fm.getHeight()
			- (fm.getLeading() + fm.getDescent());
	} 

	
	
	public int yToLine(int y)
	{
		FontMetrics fm = painter.getFontMetrics();
		int height = fm.getHeight();
		return Math.max(0,Math.min(getVirtualLineCount() - 1,
			y / height + firstLine));
	} 

	
	
	public int offsetToX(int line, int offset)
	{
		ChunkCache.Chunk chunks = chunkCache.getLineInfoBackwardsCompatibility(line).chunks;
		return (int)(horizontalOffset + chunkCache.offsetToX(chunks,offset));
	} 

	
	
	public int xToOffset(int line, int x)
	{
		x -= horizontalOffset;
		ChunkCache.Chunk chunks = chunkCache.getLineInfoBackwardsCompatibility(line).chunks;
		int offset = chunkCache.xToOffset(chunks,x,true);
		if(offset == -1)
			offset = getLineLength(line);
		return offset;
	} 

	
	
	public int xToOffset(int line, int x, boolean round)
	{
		x -= horizontalOffset;
		ChunkCache.Chunk chunks = chunkCache.getLineInfoBackwardsCompatibility(line).chunks;
		int offset = chunkCache.xToOffset(chunks,x,round);
		if(offset == -1)
			offset = getLineLength(line);
		return offset;
	} 

	
	
	public final int getSelectionStart()
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getStart();
	} 

	
	
	public int getSelectionStart(int line)
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getStart(
			buffer,line);
	} 

	
	
	public final int getSelectionStartLine()
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getStartLine();
	} 

	
	
	public final void setSelectionStart(int selectionStart)
	{
		select(selectionStart,getSelectionEnd(),true);
	} 

	
	
	public final int getSelectionEnd()
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getEnd();
	} 

	
	
	public int getSelectionEnd(int line)
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getEnd(
			buffer,line);
	} 

	
	
	public final int getSelectionEndLine()
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getEndLine();
	} 

	
	
	public final void setSelectionEnd(int selectionEnd)
	{
		select(getSelectionStart(),selectionEnd,true);
	} 

	
	
	public final int getMarkPosition()
	{
		Selection s = getSelectionAtOffset(caret);
		if(s == null)
			return caret;

		if(s.start == caret)
			return s.end;
		else if(s.end == caret)
			return s.start;
		else
			return caret;
	} 

	
	
	public final int getMarkLine()
	{
		if(selection.size() != 1)
			return caretLine;

		Selection s = (Selection)selection.elementAt(0);
		if(s.start == caret)
			return s.endLine;
		else if(s.end == caret)
			return s.startLine;
		else
			return caretLine;
	} 

	
	
	public void select(int start, int end)
	{
		select(start,end,true);
	} 

	
	
	public void select(int start, int end, boolean doElectricScroll)
	{
		selectNone();

		int newStart, newEnd;
		if(start < end)
		{
			newStart = start;
			newEnd = end;
		}
		else
		{
			newStart = end;
			newEnd = start;
		}

		setSelection(new Selection.Range(newStart,newEnd));
		moveCaretPosition(end,doElectricScroll);
	} 

	
	
	public boolean isSelectionRectangular()
	{
		Selection s = getSelectionAtOffset(caret);
		if(s == null)
			return false;
		else
			return (s instanceof Selection.Rect);
	} 

	

	

	
	Segment lineSegment;
	MouseHandler mouseHandler;
	ChunkCache chunkCache;

	int maxHorizontalScrollWidth;

	boolean softWrap;
	boolean hardWrap;
	float tabSize;
	int wrapMargin;
	boolean wrapToWidth;
	int charWidth;

	boolean scrollBarsInitialized;

	
	
	Vector selection;

	
	Point returnValue;
	

	
	
	final boolean isCaretVisible()
	{
		return blink && hasFocus();
	} 

	
	
	final boolean isBracketHighlightVisible()
	{
		return bracketLine != -1
			&& hasFocus()
			&& foldVisibilityManager.isLineVisible(bracketLine)
			&& foldVisibilityManager.isLineVisible(caretLine);
	} 

	
	void updateMaxHorizontalScrollWidth()
	{
		int max = chunkCache.getMaxHorizontalScrollWidth();

		if(max != maxHorizontalScrollWidth)
		{
			maxHorizontalScrollWidth = max;
			horizontal.setValues(Math.max(0,
				Math.min(maxHorizontalScrollWidth + charWidth
				- painter.getWidth(),
				-horizontalOffset)),
				painter.getWidth(),
				0,maxHorizontalScrollWidth
				+ charWidth);
		}
	} 

	
	void recalculateVisibleLines()
	{
		if(painter == null)
			return;
		int height = painter.getHeight();
		int lineHeight = painter.getFontMetrics().getHeight();
		visibleLines = height / lineHeight;

		chunkCache.recalculateVisibleLines();
		propertiesChanged();
	} 

	
	void foldStructureChanged()
	{
		chunkCache.invalidateAll();

		
		while(!foldVisibilityManager.isLineVisible(physFirstLine)
			&& physFirstLine != 0)
			physFirstLine--;

		setFirstLine(physicalToVirtual(physFirstLine));

		
		
		updateScrollBars();

		recalculateLastPhysicalLine();

		
		gutter.repaint();
		painter.repaint();
	} 

	
	
	
	 int getSubregionOfOffset(int offset, ChunkCache.LineInfo[] lineInfos)
	{
		
		for(int i = 0; i < lineInfos.length; i++)
		{
			ChunkCache.LineInfo info = lineInfos[i];
			if(offset >= info.offset && offset < info.offset + info.length)
				return i;
		}

		return -1;
	} 

	
	
	
	 int xToSubregionOffset(ChunkCache.LineInfo info, float x,
		boolean round)
	{
		int offset = chunkCache.xToOffset(info.chunks,
			x - horizontalOffset,round);
		if(offset == -1 || offset == info.offset + info.length)
			offset = info.offset + info.length - 1;

		return offset;
	} 

	
	
	
	 int subregionOffsetToX(ChunkCache.LineInfo info, int offset)
	{
		return (int)(horizontalOffset + chunkCache.offsetToX(
			info.chunks,offset));
	} 

	
	
	
	 

	
	
	
	 

	

	

	
	private static String CENTER = ""center"";
	private static String RIGHT = ""right"";
	private static String LEFT = ""left"";
	private static String BOTTOM = ""bottom"";

	private static Timer caretTimer;
	private static JEditTextArea focusedComponent;
	

	
	private View view;
	private Gutter gutter;
	private TextAreaPainter painter;

	private JPopupMenu popup;

	private EventListenerList listenerList;
	private MutableCaretEvent caretEvent;

	private boolean caretBlinks;
	private boolean blink;

	private int firstLine;
	private int physFirstLine;
	private int physLastLine;
	private int screenLastLine;

	private int visibleLines;
	private int electricScroll;

	private int horizontalOffset;

	private boolean quickCopy;

	private JScrollBar vertical;
	private JScrollBar horizontal;

	private boolean bufferChanging;
	private Buffer buffer;
	private FoldVisibilityManager foldVisibilityManager;
	private BufferChangeHandler bufferHandler;
	private boolean bufferHandlerInstalled;

	private int caret;
	private int caretLine;
	private int caretScreenLine;

	private int bracketPosition;
	private int bracketLine;

	private int magicCaret;

	private static boolean multi;
	private boolean overwrite;

	private int maxLineLen;

	
	private boolean queuedRecalcLastPhys;
	private boolean queuedScrollTo;
	private boolean queuedScrollToElectric;
	private boolean queuedFireCaretEvent;
	private ArrayList runnables;
	

	
	private void _addToSelection(Selection addMe)
	{
		
		
		if(addMe.start < 0)
			addMe.start = 0;
		else if(addMe.end > buffer.getLength())
			addMe.end = buffer.getLength();

		if(addMe.start > addMe.end)
		{
			throw new IllegalArgumentException(addMe.start
				+ "" > "" + addMe.end);
		}
		else if(addMe.start == addMe.end)
			return;

		for(int i = 0; i < selection.size(); i++)
		{
			
			
			Selection s = (Selection)selection.elementAt(i);
			if(_selectionsOverlap(s,addMe))
			{
				addMe.start = Math.min(s.start,addMe.start);
				addMe.end = Math.max(s.end,addMe.end);

				selection.removeElement(s);
				i--;
			}
		}

		addMe.startLine = getLineOfOffset(addMe.start);
		addMe.endLine = getLineOfOffset(addMe.end);

		boolean added = false;

		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			if(addMe.start < s.start)
			{
				selection.insertElementAt(addMe,i);
				added = true;
				break;
			}
		}

		if(!added)
			selection.addElement(addMe);

		invalidateLineRange(addMe.startLine,addMe.endLine);
	} 

	
	private boolean _selectionsOverlap(Selection s1, Selection s2)
	{
		if((s1.start >= s2.start && s1.start <= s2.end)
			|| (s1.end >= s2.start && s1.end <= s2.end))
			return true;
		else
			return false;
	} 

	
	private void getSelectedText(Selection s, StringBuffer buf)
	{
		if(s instanceof Selection.Rect)
		{
			
			int start = s.start - getLineStartOffset(s.startLine);
			int end = s.end - getLineStartOffset(s.endLine);

			
			if(end < start)
			{
				int tmp = end;
				end = start;
				start = tmp;
			}

			for(int i = s.startLine; i <= s.endLine; i++)
			{
				int lineStart = getLineStartOffset(i);
				int lineEnd = getLineEndOffset(i) - 1;
				int lineLen = lineEnd - lineStart;

				lineStart = Math.min(lineStart + start,lineEnd);
				lineLen = Math.min(end - start,lineEnd - lineStart);

				getText(lineStart,lineLen,lineSegment);
				buf.append(lineSegment.array,
					lineSegment.offset,
					lineSegment.count);

				if(i != s.endLine)
					buf.append('\n');
			}

		}
		else
		{
			getText(s.start,s.end - s.start,lineSegment);
			buf.append(lineSegment.array,
				lineSegment.offset,
				lineSegment.count);
		}
	} 

	
	
	private void finishCaretUpdate(boolean doElectricScroll,
		boolean fireCaretEvent)
	{
		this.queuedScrollToElectric |= doElectricScroll;
		this.queuedFireCaretEvent |= fireCaretEvent;

		Runnable r = new Runnable()
		{
			public void run()
			{
				scrollToCaret(queuedScrollToElectric);
				updateBracketHighlight();
				if(queuedFireCaretEvent)
					fireCaretEvent();
				queuedScrollTo = queuedScrollToElectric
					= queuedFireCaretEvent = false;
			}
		};

		if(buffer.isTransactionInProgress())
		{
			if(!queuedScrollTo)
			{
				queuedScrollTo = true;
				runnables.add(r);
			}
		}
		else
			r.run();
	} 

	
	private void fireCaretEvent()
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == CaretListener.class)
			{
				((CaretListener)listeners[i+1]).caretUpdate(caretEvent);
			}
		}
	} 

	
	private void fireScrollEvent(boolean vertical)
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == ScrollListener.class)
			{
				if(vertical)
					((ScrollListener)listeners[i+1]).scrolledVertically(this);
				else
					((ScrollListener)listeners[i+1]).scrolledHorizontally(this);
			}
		}
	} 

	
	private void insertTab()
	{
		int tabSize = buffer.getTabSize();
		if(buffer.getBooleanProperty(""noTabs""))
		{
			int lineStart = getLineStartOffset(caretLine);

			String line = getText(lineStart,caret - lineStart);

			int pos = 0;

			for(int i = 0; i < line.length(); i++)
			{
				switch(line.charAt(pos))
				{
				case '\t':
					pos = 0;
					break;
				default:
					if(++pos >= tabSize)
						pos = 0;
					break;
				}
			}

			setSelectedText(MiscUtilities.createWhiteSpace(
				tabSize - pos,0));
		}
		else
			setSelectedText(""\t"");
	} 

	
	private boolean doWordWrap(boolean spaceInserted)
	{
		if(!hardWrap || maxLineLen <= 0)
			return false;

		buffer.getLineText(caretLine,lineSegment);

		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine);
		int len = end - start - 1;

		int caretPos = caret - start;

		
		
		for(int i = caretPos; i < len; i++)
		{
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch != ' ' && ch != '\t')
				return false;
		}

		boolean returnValue = false;

		int tabSize = buffer.getTabSize();

		String wordBreakChars = buffer.getStringProperty(""wordBreakChars"");

		int logicalLength = 0; 
		int lastWordOffset = -1;
		boolean lastWasSpace = true;
		boolean initialWhiteSpace = true;
		int initialWhiteSpaceLength = 0;
		for(int i = 0; i < caretPos; i++)
		{
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch == '\t')
			{
				if(initialWhiteSpace)
					initialWhiteSpaceLength = i + 1;
				logicalLength += tabSize - (logicalLength % tabSize);
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(ch == ' ')
			{
				if(initialWhiteSpace)
					initialWhiteSpaceLength = i + 1;
				logicalLength++;
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)
			{
				initialWhiteSpace = false;
				logicalLength++;
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else
			{
				initialWhiteSpace = false;
				logicalLength++;
				lastWasSpace = false;
			}

			int insertNewLineAt;
			if(spaceInserted && logicalLength == maxLineLen
				&& i == caretPos - 1)
			{
				insertNewLineAt = caretPos;
				returnValue = true;
			}
			else if(logicalLength >= maxLineLen && lastWordOffset != -1)
				insertNewLineAt = lastWordOffset;
			else
				continue;

			try
			{
				buffer.beginCompoundEdit();
				buffer.insert(start + insertNewLineAt,""\n"");
				
				
				buffer.indentLine(caretLine,true,true);
			}
			finally
			{
				buffer.endCompoundEdit();
			}

			
			return returnValue;
		}

		return false;
	} 

	
	private void doWordCount(View view, String text)
	{
		char[] chars = text.toCharArray();
		int characters = chars.length;
		int words;
		if(characters == 0)
			words = 0;
		else
			words = 1;
		int lines = 1;
		boolean word = false;
		for(int i = 0; i < chars.length; i++)
		{
			switch(chars[i])
			{
			case '\r': case '\n':
				lines++;
			case ' ': case '\t':
				if(word)
				{
					words++;
					word = false;
				}
				break;
			default:
				word = true;
				break;
			}
		}
		Object[] args = { new Integer(characters), new Integer(words),
			new Integer(lines) };
		GUIUtilities.message(view,""wordcount"",args);
	} 

	
	private void updateBracketHighlight()
	{
		if(!painter.isBracketHighlightEnabled())
			return;

		if(bracketLine != -1)
			invalidateLineRange(bracketLine,caretLine);

		int offset = caret - getLineStartOffset(caretLine);

		if(offset != 0)
		{
			int bracketOffset = TextUtilities.findMatchingBracket(
				buffer,caretLine,offset - 1,0,buffer.getLineCount() - 1);
			if(bracketOffset != -1)
			{
				bracketLine = getLineOfOffset(bracketOffset);
				bracketPosition = bracketOffset
					- getLineStartOffset(bracketLine);
				invalidateLineRange(bracketLine,caretLine);

				if(bracketLine < physFirstLine
					|| bracketLine > physLastLine)
				{
					showBracketStatusMessage(bracketLine < caretLine);
				}
				return;
			}
		}

		bracketLine = bracketPosition = -1;
	} 

	
	private void showBracketStatusMessage(boolean backward)
	{
		String text = buffer.getLineText(bracketLine).trim();
		if(backward && bracketLine != 0 && text.length() == 1)
		{
			switch(text.charAt(0))
			{
			case '{': case '}':
			case '[': case ']':
			case '(': case ')':
				text = buffer.getLineText(bracketLine - 1).trim()
					+ "" "" + text;
				break;
			}
		}

		
		text = text.replace('\t',' ');

		view.getStatus().setMessageAndClear(jEdit.getProperty(
			""view.status.bracket"",new String[] { text }));
	} 

	
	void recalculateLastPhysicalLine()
	{
		if(softWrap)
		{
			chunkCache.updateChunksUpTo(visibleLines);
			for(int i = visibleLines; i >= 0; i--)
			{
				ChunkCache.LineInfo info = chunkCache.getLineInfo(i);
				if(info.physicalLine != -1)
				{
					physLastLine = info.physicalLine;
					screenLastLine = i;
					break;
				}
			}
		}
		else
		{
			
			int virtLastLine = Math.min(foldVisibilityManager
				.getVirtualLineCount() - 1,
				firstLine + visibleLines);
			screenLastLine = virtLastLine - firstLine;
			physLastLine = foldVisibilityManager.virtualToPhysical(
				virtLastLine);
		}
	} 

	

	

	
	static class TextAreaBorder extends AbstractBorder
	{
		private static final Insets insets = new Insets(1, 1, 2, 2);

		
		public void paintBorder(Component c, Graphics g, int x, int y,
			int width, int height)
		{
			g.translate(x,y);

			g.setColor(MetalLookAndFeel.getControlDarkShadow());
			g.drawRect(0,0,width-2,height-2);

			g.setColor(MetalLookAndFeel.getControlHighlight());
			g.drawLine(width-1,1,width-1,height-1);
			g.drawLine(1,height-1,width-1,height-1);

			g.setColor(MetalLookAndFeel.getControl());
			g.drawLine(width-2,2,width-2,2);
			g.drawLine(1,height-2,1,height-2);

			g.translate(-x,-y);
		} 

		
		public Insets getBorderInsets(Component c)
		{
			return new Insets(1,1,2,2);
		} 
	} 

	
	class ScrollLayout implements LayoutManager
	{
		
		public void addLayoutComponent(String name, Component comp)
		{
			if(name.equals(CENTER))
				center = comp;
			else if(name.equals(RIGHT))
				right = comp;
			else if(name.equals(LEFT))
				left = comp;
			else if(name.equals(BOTTOM))
				bottom = comp;
		} 

		
		public void removeLayoutComponent(Component comp)
		{
			if(center == comp)
				center = null;
			else if(right == comp)
				right = null;
			else if(left == comp)
				left = null;
			else if(bottom == comp)
				bottom = null;
		} 

		
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}

			dim.width = insets.left + insets.right;
			dim.height = insets.top + insets.bottom;

			Dimension leftPref = left.getPreferredSize();
			dim.width += leftPref.width;
			Dimension centerPref = center.getPreferredSize();
			dim.width += centerPref.width;
			dim.height += centerPref.height;
			Dimension rightPref = right.getPreferredSize();
			dim.width += rightPref.width;
			Dimension bottomPref = bottom.getPreferredSize();
			dim.height += bottomPref.height;

			return dim;
		} 

		
		public Dimension minimumLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}

			dim.width = insets.left + insets.right;
			dim.height = insets.top + insets.bottom;

			Dimension leftPref = left.getMinimumSize();
			dim.width += leftPref.width;
			Dimension centerPref = center.getMinimumSize();
			dim.width += centerPref.width; 
			dim.height += centerPref.height;
			Dimension rightPref = right.getMinimumSize();
			dim.width += rightPref.width;
			Dimension bottomPref = bottom.getMinimumSize();
			dim.height += bottomPref.height;

			return dim;
		} 

		
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}

			int itop = insets.top;
			int ileft = insets.left;
			int ibottom = insets.bottom;
			int iright = insets.right;

			int rightWidth = right.getPreferredSize().width;
			int leftWidth = left.getPreferredSize().width;
			int bottomHeight = bottom.getPreferredSize().height;
			int centerWidth = Math.max(0,size.width - leftWidth
				- rightWidth - ileft - iright);
			int centerHeight = Math.max(0,size.height
				- bottomHeight - itop - ibottom);

			left.setBounds(
				ileft,
				itop,
				leftWidth,
				centerHeight);

			center.setBounds(
				ileft + leftWidth,
				itop,
				centerWidth,
				centerHeight);

			right.setBounds(
				ileft + leftWidth + centerWidth,
				itop,
				rightWidth,
				centerHeight);

			bottom.setBounds(
				ileft,
				itop + centerHeight,
				Math.max(0,size.width - rightWidth - ileft - iright),
				bottomHeight);
		} 

		Component center;
		Component left;
		Component right;
		Component bottom;
	} 

	
	static class CaretBlinker implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			if(focusedComponent != null && focusedComponent.hasFocus())
				focusedComponent.blinkCaret();
		} 
	} 

	
	class MutableCaretEvent extends CaretEvent
	{
		
		MutableCaretEvent()
		{
			super(JEditTextArea.this);
		} 

		
		public int getDot()
		{
			return getCaretPosition();
		} 

		
		public int getMark()
		{
			return getMarkPosition();
		} 
	} 

	
	class AdjustHandler implements AdjustmentListener
	{
		
		public void adjustmentValueChanged(final AdjustmentEvent evt)
		{
			if(!scrollBarsInitialized)
				return;

			if(evt.getAdjustable() == vertical)
				setFirstLine(vertical.getValue());
			else
				setHorizontalOffset(-horizontal.getValue());
		} 
	} 

	
	class ComponentHandler extends ComponentAdapter
	{
		
		public void componentResized(ComponentEvent evt)
		{
			
		} 
	} 

	
	class BufferChangeHandler implements BufferChangeListener
	{
		
		public void foldLevelChanged(Buffer buffer, int start, int end)
		{
			if(!bufferChanging && end != 0 && buffer.isLoaded())
			{
				invalidateLineRange(start - 1,end - 1);
			}
		} 

		
		public void contentInserted(Buffer buffer, int startLine, int start,
			int numLines, int length)
		{
			chunkCache.invalidateChunksFromPhys(startLine);

			
			
			if(numLines != 0 || (softWrap
				&& foldVisibilityManager.getLastVisibleLine()
				- numLines <= physLastLine))
			{
				int oldScreenLastLine = screenLastLine;
				recalculateLastPhysicalLine();
				invalidateScreenLineRange(oldScreenLastLine,
					screenLastLine);
			}

			if(!buffer.isLoaded())
				return;

			repaintAndScroll(startLine,numLines);

			
			
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);

				boolean changed = false;

				if((s instanceof Selection.Rect && s.start > start)
					|| (s instanceof Selection.Range && s.start >= start))
				{
					s.start += length;
					s.startLine = getLineOfOffset(s.start);
					changed = true;
				}

				if(s.end >= start)
				{
					s.end += length;
					s.endLine = getLineOfOffset(s.end);
					changed = true;
				}

				if(changed)
					invalidateLineRange(s.startLine,s.endLine);
			}

			if(caret >= start)
				moveCaretPosition(caret + length,true);
			else
			{
				
				moveCaretPosition(caret);
			}
		}
		

		
		public void contentRemoved(Buffer buffer, int startLine, int start,
			int numLines, int length)
		{
			if(!buffer.isLoaded())
				return;

			chunkCache.invalidateChunksFromPhys(startLine);

			
			repaintAndScroll(startLine,-numLines);

			if(numLines != 0 || (softWrap
				&& foldVisibilityManager.getLastVisibleLine()
				+ numLines <= physLastLine))
			{
				Runnable r = new Runnable()
				{
					public void run()
					{
						queuedRecalcLastPhys = false;
						int oldScreenLastLine = screenLastLine;
						recalculateLastPhysicalLine();
						invalidateScreenLineRange(oldScreenLastLine,
							screenLastLine);
					}
				};

				if(buffer.isTransactionInProgress())
				{
					if(!queuedRecalcLastPhys)
					{
						queuedRecalcLastPhys = true;
						runnables.add(r);
					}
				}
				else
					r.run();
			}

			int end = start + length;

			
			
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);

				boolean changed = false;

				if(s.start > start && s.start <= end)
				{
					s.start = start;
					changed = true;
				}
				else if(s.start > end)
				{
					s.start -= length;
					changed = true;
				}

				if(s.end > start && s.end <= end)
				{
					s.end = start;
					changed = true;
				}
				else if(s.end > end)
				{
					s.end -= length;
					changed = true;
				}

				if(s.start == s.end)
				{
					selection.removeElement(s);
					invalidateLineRange(s.startLine,s.endLine);
					i--;
				}
				else if(changed)
				{
					s.startLine = getLineOfOffset(s.start);
					s.endLine = getLineOfOffset(s.end);
					invalidateLineRange(s.startLine,s.endLine);
				}
			}

			if(caret > start && caret <= end)
				moveCaretPosition(start,false);
			else if(caret > end)
				moveCaretPosition(caret - length,false);
			else
			{
				
				moveCaretPosition(caret);
			}
		}
		

		
		public void transactionComplete(Buffer buffer)
		{
			for(int i = 0; i < runnables.size(); i++)
			{
				((Runnable)runnables.get(i)).run();
			}
			runnables.clear();
		} 

		
		private void repaintAndScroll(int startLine, int numLines)
		{
			if(numLines == 0)
				invalidateLine(startLine);
			
			else if(startLine < firstLine)
			{
				setFirstLine(firstLine + numLines);
				
			}
			
			else
			{
				updateScrollBars();
				invalidateScreenLineRange(chunkCache.getScreenLineOfOffset(
					startLine,0),screenLastLine);
			}
		} 
	} 

	
	class FocusHandler implements FocusListener
	{
		
		public void focusGained(FocusEvent evt)
		{
			if(bufferChanging)
				return;

			if(bracketLine != -1)
				invalidateLineRange(bracketLine,caretLine);
			else
				invalidateLine(caretLine);

			
			
			view.updateGutterBorders();
		} 

		
		public void focusLost(FocusEvent evt)
		{
			if(!isShowing())
				return;

			if(bracketLine != -1)
				invalidateLineRange(bracketLine,caretLine);
			else
				invalidateLine(caretLine);
		} 
	} 

	
	class MouseHandler extends MouseInputAdapter
	{
		private int dragStartLine;
		private int dragStartOffset;
		private int dragStart;
		private int clickCount;
		private boolean dragged;
		private boolean quickCopyDrag;
		private boolean clearStatus;

		
		public void mousePressed(MouseEvent evt)
		{
			
			
			view.getInputHandler().resetLastActionCount();

			grabFocus();

			if(GUIUtilities.isPopupTrigger(evt) && popup != null)
			{
				if(popup.isVisible())
					popup.setVisible(false);
				else
				{
					GUIUtilities.showPopupMenu(popup,painter,
						evt.getX()+1,evt.getY()+1);
				}
				return;
			}

			quickCopyDrag = (isQuickCopyEnabled()
				&& (evt.getModifiers() & MouseEvent.BUTTON2_MASK) != 0);
			blink = true;
			invalidateLine(caretLine);

			int x = evt.getX();
			int y = evt.getY();

			dragStart = xyToOffset(x,y,!painter.isBlockCaretEnabled());
			dragStartLine = getLineOfOffset(dragStart);
			dragStartOffset = dragStart - getLineStartOffset(dragStartLine);

			dragged = false;

			clickCount = evt.getClickCount();

			switch(clickCount)
			{
			case 1:
				doSingleClick(evt);
				break;
			case 2:
				doDoubleClick(evt);
				break;
			default: 
				doTripleClick(evt);
				break;
			}
		} 

		
		public void mouseReleased(MouseEvent evt)
		{
			if(getSelectionCount() != 0)
				Registers.setRegister('%',getSelectedText());

			if(dragged)
			{
				
				
				if(quickCopyDrag)
				{
					String text = getSelectedText();
					selectNone();
					setSelectedText(text);
				}
			}
			else if(isQuickCopyEnabled()
				&& (evt.getModifiers() & InputEvent.BUTTON2_MASK) != 0)
			{
				moveCaretPosition(dragStart,false);
				if(!isEditable())
					getToolkit().beep();
				else
					Registers.paste(JEditTextArea.this,'%');
			}

			dragged = false;

			if(clearStatus)
			{
				clearStatus = false;
				view.getStatus().setMessage(null);
			}
		} 

		
		private void doSingleClick(MouseEvent evt)
		{
			

			boolean control = (OperatingSystem.isMacOS() && evt.isMetaDown())
				|| (!OperatingSystem.isMacOS() && evt.isControlDown());

			if(evt.isShiftDown())
			{
				
				resizeSelection(getMarkPosition(),dragStart,control);

				moveCaretPosition(dragStart,false);

				
				dragStartLine = getMarkLine();
				dragStart = getMarkPosition();
				dragStartOffset = dragStart
					- getLineStartOffset(dragStartLine);
			}
			else if(control)
			{
				if(!multi)
					selectNone();

				moveCaretPosition(xyToOffset(evt.getX(),
					evt.getY(),false),false);
				selectToMatchingBracket();
			}
			else
			{
				if(!multi)
					selectNone();

				if(!quickCopyDrag)
					moveCaretPosition(dragStart,false);
			}
		} 

		
		private void doDoubleClick(MouseEvent evt)
		{
			
			if(getLineLength(dragStartLine) == 0)
				return;

			String lineText = getLineText(dragStartLine);
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			if(dragStartOffset == getLineLength(dragStartLine))
				dragStartOffset--;

			int wordStart = TextUtilities.findWordStart(lineText,
				dragStartOffset,noWordSep);
			int wordEnd = TextUtilities.findWordEnd(lineText,
				dragStartOffset+1,noWordSep);

			int lineStart = getLineStartOffset(dragStartLine);
			addToSelection(new Selection.Range(lineStart + wordStart,
				lineStart + wordEnd));

			if(quickCopyDrag)
				quickCopyDrag = false;

			moveCaretPosition(lineStart + wordEnd,false);

			
			
			dragged = true;
		} 

		
		private void doTripleClick(MouseEvent evt)
		{
			int newCaret = getLineEndOffset(dragStartLine);
			addToSelection(new Selection.Range(
				getLineStartOffset(dragStartLine),
				newCaret));

			if(quickCopyDrag)
				quickCopyDrag = false;

			moveCaretPosition(newCaret);
		} 

		
		public void mouseDragged(MouseEvent evt)
		{
			if(GUIUtilities.isPopupTrigger(evt)
				|| (popup != null && popup.isVisible()))
				return;

			if(evt.getY() < 0)
			{
				setFirstLine(getFirstLine() - 2);
			}
			else if(evt.getY() >= getHeight())
			{
				setFirstLine(getFirstLine() + 1);
			}

			boolean rect = (OperatingSystem.isMacOS() && evt.isMetaDown())
					|| (!OperatingSystem.isMacOS() && evt.isControlDown());

			if(quickCopyDrag)
			{
				view.getStatus().setMessage(jEdit.getProperty(
					""view.status.quick-copy""));
				clearStatus = true;
			}
			else if(evt.isControlDown())
			{
				view.getStatus().setMessage(jEdit.getProperty(
					""view.status.rect-select""));
				clearStatus = true;
			}

			switch(clickCount)
			{
			case 1:
				doSingleDrag(evt,rect);
				break;
			case 2:
				doDoubleDrag(evt,rect);
				break;
			default: 
				doTripleDrag(evt,rect);
				break;
			}
		} 

		
		private void doSingleDrag(MouseEvent evt, boolean rect)
		{
			int dot = xyToOffset(evt.getX(),
				Math.max(0,Math.min(painter.getHeight(),evt.getY())),
				!painter.isBlockCaretEnabled());

			dragged = true;

			resizeSelection(dragStart,dot,rect);

			if(quickCopyDrag)
			{
				
				int line = buffer.getLineOfOffset(dot);
				scrollTo(line,dot - buffer.getLineStartOffset(line),false);
			}
			else
			{
				if(dot == caret)
					return;
				moveCaretPosition(dot,false);
			}
		} 

		
		private void doDoubleDrag(MouseEvent evt, boolean rect)
		{
			int markLineStart = getLineStartOffset(dragStartLine);
			int markLineLength = getLineLength(dragStartLine);
			int mark = dragStartOffset;

			int pos = xyToOffset(evt.getX(),
				Math.max(0,Math.min(painter.getHeight(),evt.getY())),
				!painter.isBlockCaretEnabled());
			int line = getLineOfOffset(pos);
			int lineStart = getLineStartOffset(line);
			int lineLength = getLineLength(line);
			int offset = pos - lineStart;

			String lineText = getLineText(line);
			String markLineText = getLineText(dragStartLine);
			String noWordSep = buffer.getStringProperty(""noWordSep"");

			if(markLineStart + dragStartOffset > lineStart + offset)
			{
				if(offset != 0 && offset != lineLength)
				{
					offset = TextUtilities.findWordStart(
						lineText,offset,noWordSep);
				}

				if(markLineLength != 0)
				{
					mark = TextUtilities.findWordEnd(
						markLineText,mark,noWordSep);
				}
			}
			else
			{
				if(offset != 0 && lineLength != 0)
				{
					offset = TextUtilities.findWordEnd(
						lineText,offset,noWordSep);
				}

				if(mark != 0 && mark != markLineLength)
				{
					mark = TextUtilities.findWordStart(
						markLineText,mark,noWordSep);
				}
			}

			if(lineStart + offset == caret)
				return;

			resizeSelection(markLineStart + mark,lineStart + offset,
				rect);
			if(!quickCopyDrag)
				moveCaretPosition(lineStart + offset,false);
		} 

		
		private void doTripleDrag(MouseEvent evt, boolean rect)
		{
			int offset = xyToOffset(evt.getX(),
				Math.max(0,Math.min(painter.getHeight(),evt.getY())),
				false);
			int mouseLine = getLineOfOffset(offset);
			int mark;
			int mouse;
			if(dragStartLine > mouseLine)
			{
				mark = getLineEndOffset(dragStartLine) - 1;
				if(offset == getLineEndOffset(mouseLine) - 1)
					mouse = offset;
				else
					mouse = getLineStartOffset(mouseLine);
			}
			else
			{
				mark = getLineStartOffset(dragStartLine);
				if(offset == getLineStartOffset(mouseLine))
					mouse = offset;
				else if(offset == getLineEndOffset(mouseLine) - 1
					&& mouseLine != getBuffer().getLineCount() - 1)
					mouse = getLineEndOffset(mouseLine);
				else
					mouse = getLineEndOffset(mouseLine) - 1;
			}

			mouse = Math.min(getBuffer().getLength(),mouse);

			if(mouse == caret)
				return;

			dragged = true;

			resizeSelection(mark,mouse,rect);
			moveCaretPosition(mouse,false);
		} 
	} 

	

	
	static
	{
		caretTimer = new Timer(500,new CaretBlinker());
		caretTimer.setInitialDelay(500);
		caretTimer.start();
	} 
}
"
jEdit,4,org.gjt.sp.jedit.pluginmgr.PluginManager,11,6,0,12,63,27,8,8,1,0.775,559,1.0,0,0.984871407,0.363636364,0,0,49.09090909,9,1.6364,0,"

package org.gjt.sp.jedit.pluginmgr;

import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;

public class PluginManager extends JDialog
{
	public PluginManager(Frame frame)
	{
		super(frame,jEdit.getProperty(""plugin-manager.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel caption = new JLabel(jEdit.getProperty(
			""plugin-manager.caption""));
		caption.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,caption);

		tree = new JTree();
		tree.setCellRenderer(new Renderer());
		tree.setRootVisible(false);
		tree.setVisibleRowCount(16);
		tree.addTreeSelectionListener(new TreeHandler());

		JPanel panel = new JPanel(new BorderLayout());

		panel.add(BorderLayout.CENTER,new JScrollPane(tree));

		JPanel panel2 = new JPanel(new BorderLayout());
		panel2.setBorder(new EmptyBorder(6,0,0,0));
		JPanel labelBox = new JPanel(new GridLayout(3,1,0,3));
		labelBox.setBorder(new EmptyBorder(0,0,0,12));
		labelBox.add(new JLabel(jEdit.getProperty(""plugin-manager""
			+ "".info.name""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""plugin-manager""
			+ "".info.author""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""plugin-manager""
			+ "".info.version""),SwingConstants.RIGHT));
		panel2.add(BorderLayout.WEST,labelBox);

		JPanel valueBox = new JPanel(new GridLayout(3,1,0,3));
		valueBox.add(name = new JLabel());
		valueBox.add(author = new JLabel());
		valueBox.add(version = new JLabel());
		panel2.add(BorderLayout.CENTER,valueBox);

		panel.add(BorderLayout.SOUTH,panel2);
		content.add(BorderLayout.CENTER,panel);

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));

		buttons.add(Box.createGlue());
		remove = new JButton(jEdit.getProperty(""plugin-manager""
			+ "".remove""));
		remove.addActionListener(new ActionHandler());
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		update = new JButton(jEdit.getProperty(""plugin-manager""
			+ "".update""));
		update.addActionListener(new ActionHandler());
		buttons.add(update);
		buttons.add(Box.createHorizontalStrut(6));
		install = new JButton(jEdit.getProperty(""plugin-manager""
			+ "".install""));
		install.addActionListener(new ActionHandler());
		buttons.add(install);
		buttons.add(Box.createHorizontalStrut(6));
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		buttons.add(close);
		buttons.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,buttons);

		updateTree();

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		pack();

		setLocationRelativeTo(frame);

		show();
	}

	
	private JTree tree;
	private JLabel name;
	private JLabel author;
	private JLabel version;
	private JButton remove;
	private JButton update;
	private JButton install;
	private JButton close;

	private void updateTree()
	{
		DefaultMutableTreeNode treeRoot = new DefaultMutableTreeNode();
		DefaultTreeModel treeModel = new DefaultTreeModel(treeRoot);

		DefaultMutableTreeNode loadedTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""plugin-manager.loaded""),true);
		DefaultMutableTreeNode notLoadedTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""plugin-manager.not-loaded""),true);
		DefaultMutableTreeNode newTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""plugin-manager.new""),true);

		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin plugin = plugins[i];
			String path = plugin.getJAR().getPath();
			if(!new File(path).exists())
			{
				
				continue;
			}

			if(plugin instanceof EditPlugin.Broken)
			{
				Entry entry = new Entry(path,plugin.getClassName(),true);
				notLoadedTree.add(new DefaultMutableTreeNode(entry));
			}
			else
			{
				Entry entry = new Entry(path,plugin.getClassName(),false);
				loadedTree.add(new DefaultMutableTreeNode(entry));
			}
		}

		if(notLoadedTree.getChildCount() != 0)
			treeRoot.add(notLoadedTree);

		if(loadedTree.getChildCount() != 0)
			treeRoot.add(loadedTree);

		String[] newPlugins = jEdit.getNotLoadedPluginJARs();
		for(int i = 0; i < newPlugins.length; i++)
		{
			Entry entry = new Entry(newPlugins[i],null,false);
			newTree.add(new DefaultMutableTreeNode(entry));
		}

		if(newTree.getChildCount() != 0)
			treeRoot.add(newTree);

		tree.setModel(treeModel);
		for(int i = 0; i < tree.getRowCount(); i++)
			tree.expandRow(i);

		remove.setEnabled(false);

		name.setText(null);
		author.setText(null);
		version.setText(null);
	}

	class Entry
	{
		String clazz;
		String name, version, author;
		Vector jars;
		boolean broken;

		Entry(String path, String clazz, boolean broken)
		{
			Entry.this.clazz = clazz;
			Entry.this.broken = broken;

			jars = new Vector();
			jars.addElement(path);

			if(clazz == null)
				Entry.this.name = path;
			else
			{
				Entry.this.name = jEdit.getProperty(""plugin."" + clazz + "".name"");
				if(name == null)
					name = clazz;

				Entry.this.version = jEdit.getProperty(""plugin."" + clazz
					+ "".version"");

				Entry.this.author = jEdit.getProperty(""plugin."" + clazz
					+ "".author"");

				String jarsProp = jEdit.getProperty(""plugin."" + clazz
					+ "".jars"");

				if(jarsProp != null)
				{
					String directory = MiscUtilities.getParentOfPath(path);

					StringTokenizer st = new StringTokenizer(jarsProp);
					while(st.hasMoreElements())
					{
						jars.addElement(MiscUtilities.constructPath(
							directory,st.nextToken()));
					}
				}
			}
		}

		public String toString()
		{
			return Entry.this.name;
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == close)
				dispose();
			else if(source == remove)
			{
				TreePath[] selected = tree.getSelectionModel()
					.getSelectionPaths();

				StringBuffer buf = new StringBuffer();
				Roster roster = new Roster();
				for(int i = 0; i < selected.length; i++)
				{
					Object last = ((DefaultMutableTreeNode)
						selected[i].getLastPathComponent())
						.getUserObject();
					if(last instanceof Entry)
					{
						Entry entry = (Entry)last;
						for(int j = 0; j < entry.jars.size(); j++)
						{
							String jar = (String)entry.jars.elementAt(j);
							if(buf.length() != 0)
								buf.append('\n');
							buf.append(jar);
							roster.addOperation(new Roster.Remove(jar));
						}
					}
				}

				String[] args = { buf.toString() };
				if(GUIUtilities.confirm(PluginManager.this,
					""plugin-manager.remove-confirm"",args,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.QUESTION_MESSAGE)
					== JOptionPane.YES_OPTION)
				{
					new PluginManagerProgress(PluginManager.this,
						""remove"",roster);
					updateTree();
				}
			}
			else if(source == update)
			{
				PluginList list = new PluginListDownloadProgress(PluginManager.this)
					.getPluginList();
				if(list == null)
					return;

				if(jEdit.getSettingsDirectory() == null)
				{
					GUIUtilities.error(PluginManager.this,
						""no-settings"",null);
					return;
				}

				Vector plugins = new Vector();
				for(int i = 0; i < list.plugins.size(); i++)
				{
					PluginList.Plugin plugin = (PluginList.Plugin)list
						.plugins.elementAt(i);
					PluginList.Branch branch = plugin.getCompatibleBranch();

					if(branch != null
						&& branch.canSatisfyDependencies()
						&& plugin.installedVersion != null
						&& MiscUtilities.compareStrings(branch.version,
						plugin.installedVersion,false) > 0)
						plugins.addElement(plugin);
				}

				if(plugins.size() == 0)
				{
					GUIUtilities.message(PluginManager.this,
						""plugin-manager.up-to-date"",null);
					return;
				}

				Roster roster = new Roster();
				new InstallPluginsDialog(PluginManager.this,
					plugins,InstallPluginsDialog.UPDATE)
					.installPlugins(roster);

				if(roster.isEmpty())
					return;

				new PluginManagerProgress(PluginManager.this,
					""update"",roster);

				updateTree();
			}
			else if(source == install)
			{
				PluginList list = new PluginListDownloadProgress(PluginManager.this)
					.getPluginList();
				if(list == null)
					return;

				if(jEdit.getSettingsDirectory() == null
					&& jEdit.getJEditHome() == null)
				{
					GUIUtilities.error(PluginManager.this,""no-settings"",null);
					return;
				}

				Vector plugins = new Vector();
				for(int i = 0; i < list.plugins.size(); i++)
				{
					PluginList.Plugin plugin = (PluginList.Plugin)list
						.plugins.elementAt(i);
					if(plugin.installed == null
						&& plugin.canBeInstalled())
						plugins.addElement(plugin);
				}

				Roster roster = new Roster();
				new InstallPluginsDialog(PluginManager.this,
					plugins,InstallPluginsDialog.INSTALL)
					.installPlugins(roster);

				if(roster.isEmpty())
					return;

				new PluginManagerProgress(PluginManager.this,
					""install"",roster);

				updateTree();
			}
		}
	}

	class TreeHandler implements TreeSelectionListener
	{
		public void valueChanged(TreeSelectionEvent evt)
		{
			TreePath selection = evt.getPath();
			DefaultMutableTreeNode node;
			if(selection == null)
			{
				node = null;
			}
			else
			{
				node = (DefaultMutableTreeNode)
					selection.getLastPathComponent();
			}

			name.setText(null);
			author.setText(null);
			version.setText(null);

			if(node != null && node.isLeaf()
				&& node.getUserObject() instanceof Entry)
			{
				remove.setEnabled(true);

				Entry entry = (Entry)node.getUserObject();

				if(entry.clazz != null)
				{
					name.setText(entry.name);
					author.setText(entry.author);
					version.setText(entry.version);
				}
			}
			else
				remove.setEnabled(false);
		}
	}

	class Renderer extends DefaultTreeCellRenderer
	{
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,
				selected,expanded,leaf,row,hasFocus);

			setIcon(null);

			return this;
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.Java14,3,1,0,9,19,3,0,9,2,1.0,54,1.0,0,0.0,0.333333333,0,0,16.66666667,3,1.3333,2,"

package org.gjt.sp.jedit;


import javax.swing.*;
import java.awt.datatransfer.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.util.Log;



public class Java14
{
	
	public static void init()
	{
		JFrame.setDefaultLookAndFeelDecorated(
			jEdit.getBooleanProperty(""decorate.frames""));
		JDialog.setDefaultLookAndFeelDecorated(
			jEdit.getBooleanProperty(""decorate.dialogs""));

		KeyboardFocusManager.setCurrentKeyboardFocusManager(
			new MyFocusManager());

		EditBus.addToBus(new EBComponent()
		{
			public void handleMessage(EBMessage msg)
			{
				if(msg instanceof ViewUpdate)
				{
					ViewUpdate vu = (ViewUpdate)msg;
					if(vu.getWhat() == ViewUpdate.CREATED)
					{
						vu.getView().setFocusTraversalPolicy(
							new MyFocusTraversalPolicy());
					}
				}
			}
		});

		Clipboard selection = Toolkit.getDefaultToolkit().getSystemSelection();
		if(selection != null)
		{
			Log.log(Log.DEBUG,Java14.class,""Setting % register""
				+ "" to system selection"");
			Registers.setRegister('%',new Registers.ClipboardRegister(selection));
		}
	} 

	
	static class MyFocusManager extends DefaultKeyboardFocusManager
	{
		MyFocusManager()
		{
			setDefaultFocusTraversalPolicy(new LayoutFocusTraversalPolicy());
		}

		public boolean postProcessKeyEvent(KeyEvent evt)
		{
			if(!evt.isConsumed())
			{
				Component comp = (Component)evt.getSource();
				if(!comp.isShowing())
					return true;

				for(;;)
				{
					if(comp instanceof View)
					{
						((View)comp).processKeyEvent(evt);
						return true;
					}
					else if(comp == null || comp instanceof Window
						|| comp instanceof JEditTextArea)
					{
						break;
					}
					else
						comp = comp.getParent();
				}
			}

			return super.postProcessKeyEvent(evt);
		}
	} 

	
	static class MyFocusTraversalPolicy extends LayoutFocusTraversalPolicy
	{
		public Component getDefaultComponent(Container focusCycleRoot)
		{
			return ((View)focusCycleRoot).getTextArea();
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.EBMessage,6,1,3,31,14,7,31,1,6,0.6,49,1.0,1,0.0,0.583333333,0,0,6.833333333,1,0.8333,1,"

package org.gjt.sp.jedit;

import java.util.Enumeration;
import java.util.Vector;


public abstract class EBMessage
{
	
	public EBMessage(EBComponent source)
	{
		this.source = source;
	}

	
	public EBComponent getSource()
	{
		return source;
	}

	
	public void veto()
	{
		vetoed = true;
	}

	
	public boolean isVetoed()
	{
		return vetoed;
	}

	
	public String toString()
	{
		return getClass().getName() + ""["" + paramString() + ""]"";
	}

	
	public String paramString()
	{
		return ""source="" + source;
	}

	
	private EBComponent source;
	private boolean vetoed;

	
	public static abstract class NonVetoable extends EBMessage
	{
		
		public NonVetoable(EBComponent source)
		{
			super(source);
		}

		
		public void veto()
		{
			throw new InternalError(""Can't veto this message"");
		}
	}

	
















































}
"
jEdit,4,org.gjt.sp.jedit.options.AbbrevsOptionPane,14,6,0,11,77,51,5,10,1,0.817307692,516,1.0,1,0.980740741,0.5,4,12,35.28571429,3,1.4286,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.EditAbbrevDialog;
import org.gjt.sp.jedit.*;




public class AbbrevsOptionPane extends AbstractOptionPane
{
	
	public AbbrevsOptionPane()
	{
		super(""abbrevs"");
	} 

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		JPanel panel = new JPanel(new BorderLayout());

		JPanel panel2 = new JPanel();
		panel2.setLayout(new BoxLayout(panel2,BoxLayout.X_AXIS));
		panel2.setBorder(new EmptyBorder(0,0,6,0));

		panel2.add(Box.createGlue());

		expandOnInput = new JCheckBox(jEdit.getProperty(""options.abbrevs""
			+ "".expandOnInput""),Abbrevs.getExpandOnInput());
		panel2.add(expandOnInput);

		panel2.add(Box.createGlue());

		panel.add(panel2,BorderLayout.NORTH);

		JPanel panel3 = new JPanel();
		panel3.setLayout(new BoxLayout(panel3,BoxLayout.X_AXIS));
		panel3.setBorder(new EmptyBorder(0,0,6,0));
		panel3.add(Box.createGlue());
		JLabel label = new JLabel(jEdit.getProperty(""options.abbrevs.set""));
		label.setBorder(new EmptyBorder(0,0,0,12));
		panel3.add(label);

		Hashtable _modeAbbrevs = Abbrevs.getModeAbbrevs();
		modeAbbrevs = new Hashtable();
		Mode[] modes = jEdit.getModes();
		String[] sets = new String[modes.length + 1];
		sets[0] = ""global"";
		for(int i = 0; i < modes.length; i++)
		{
			String name = modes[i].getName();
			sets[i+1] = name;
			modeAbbrevs.put(name,new AbbrevsModel((Hashtable)_modeAbbrevs.get(name)));
		}

		setsComboBox = new JComboBox(sets);
		ActionHandler actionHandler = new ActionHandler();
		setsComboBox.addActionListener(actionHandler);
		panel3.add(setsComboBox);
		panel3.add(Box.createGlue());
		panel.add(panel3,BorderLayout.SOUTH);

		add(BorderLayout.NORTH,panel);

		globalAbbrevs = new AbbrevsModel(Abbrevs.getGlobalAbbrevs());
		abbrevsTable = new JTable(globalAbbrevs);
		abbrevsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		abbrevsTable.getTableHeader().setReorderingAllowed(false);
		abbrevsTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		abbrevsTable.getSelectionModel().addListSelectionListener(
			new SelectionHandler());
		abbrevsTable.addMouseListener(new TableMouseHandler());
		Dimension d = abbrevsTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(abbrevsTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.CENTER,scroller);

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(6,0,0,0));

		buttons.add(Box.createGlue());
		add = new JButton(jEdit.getProperty(""options.abbrevs.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		edit = new JButton(jEdit.getProperty(""options.abbrevs.edit""));
		edit.addActionListener(actionHandler);
		buttons.add(edit);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new JButton(jEdit.getProperty(""options.abbrevs.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createGlue());

		add(BorderLayout.SOUTH,buttons);

		updateEnabled();
	} 

	
	protected void _save()
	{
		if(abbrevsTable.getCellEditor() != null)
			abbrevsTable.getCellEditor().stopCellEditing();

		Abbrevs.setExpandOnInput(expandOnInput.isSelected());

		Abbrevs.setGlobalAbbrevs(globalAbbrevs.toHashtable());

		Hashtable modeHash = new Hashtable();
		Enumeration keys = modeAbbrevs.keys();
		Enumeration values = modeAbbrevs.elements();
		while(keys.hasMoreElements())
		{
			modeHash.put(keys.nextElement(),((AbbrevsModel)values.nextElement())
				.toHashtable());
		}
		Abbrevs.setModeAbbrevs(modeHash);
	} 

	

	
	private JComboBox setsComboBox;
	private JCheckBox expandOnInput;
	private JTable abbrevsTable;
	private AbbrevsModel globalAbbrevs;
	private Hashtable modeAbbrevs;
	private JButton add;
	private JButton edit;
	private JButton remove;
	

	
	private void updateEnabled()
	{
		int selectedRow = abbrevsTable.getSelectedRow();
		edit.setEnabled(selectedRow != -1);
		remove.setEnabled(selectedRow != -1);
	} 

	
	private void edit()
	{
		AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();

		int row = abbrevsTable.getSelectedRow();

		String abbrev = (String)abbrevsModel.getValueAt(row,0);
		String expansion = (String)abbrevsModel.getValueAt(row,1);
	
		EditAbbrevDialog dialog = new EditAbbrevDialog(
			AbbrevsOptionPane.this,
			abbrev,expansion);
		abbrev = dialog.getAbbrev();
		expansion = dialog.getExpansion();
		if(abbrev != null && expansion != null)
		{
			abbrevsModel.setValueAt(abbrev,row,0);
			abbrevsModel.setValueAt(expansion,row,1);
		}
	} 

	
	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(abbrevsTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				((AbbrevsModel)abbrevsTable.getModel()).sort(0);
				break;
			case 1:
				((AbbrevsModel)abbrevsTable.getModel()).sort(1);
				break;
			}
		}
	} 

	
	class TableMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			if(evt.getClickCount() == 2)
				edit();
		}
	} 

	
	class SelectionHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateEnabled();
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();

			Object source = evt.getSource();
			if(source == setsComboBox)
			{
				String selected = (String)setsComboBox.getSelectedItem();
				if(selected.equals(""global""))
				{
					abbrevsTable.setModel(globalAbbrevs);
				}
				else
				{
					abbrevsTable.setModel((AbbrevsModel)
						modeAbbrevs.get(selected));
				}
				updateEnabled();
			}
			else if(source == add)
			{
				EditAbbrevDialog dialog = new EditAbbrevDialog(
					AbbrevsOptionPane.this,
					null,null);
				String abbrev = dialog.getAbbrev();
				String expansion = dialog.getExpansion();
				if(abbrev != null && abbrev.length() != 0
					&& expansion != null
					&& expansion.length() != 0)
				{
					abbrevsModel.add(abbrev,expansion);
					int index = abbrevsModel.getRowCount() - 1;
					abbrevsTable.getSelectionModel()
						.setSelectionInterval(index,index);
					Rectangle rect = abbrevsTable.getCellRect(
						index,0,true);
					abbrevsTable.scrollRectToVisible(rect);
					updateEnabled();
				}
			}
			else if(source == edit)
			{
				edit();
			}
			else if(source == remove)
			{
				int selectedRow = abbrevsTable.getSelectedRow();
				abbrevsModel.remove(selectedRow);
				updateEnabled();
			}
		}
	} 
} 


class AbbrevsModel extends AbstractTableModel
{
	Vector abbrevs;

	
	AbbrevsModel()
	{
		abbrevs = new Vector();
	} 

	
	AbbrevsModel(Hashtable abbrevHash)
	{
		this();

		if(abbrevHash != null)
		{
			Enumeration abbrevEnum = abbrevHash.keys();
			Enumeration expandEnum = abbrevHash.elements();

			while(abbrevEnum.hasMoreElements())
			{
				abbrevs.addElement(new Abbrev((String)abbrevEnum.nextElement(),
					(String)expandEnum.nextElement()));
			}

			sort(0);
		}
	} 

	
	void sort(int col)
	{
		MiscUtilities.quicksort(abbrevs,new AbbrevCompare(col));
		fireTableDataChanged();
	} 

	
	void add(String abbrev, String expansion)
	{
		abbrevs.addElement(new Abbrev(abbrev,expansion));
		fireTableStructureChanged();
	} 

	
	void remove(int index)
	{
		abbrevs.removeElementAt(index);
		fireTableStructureChanged();
	} 

	
	public Hashtable toHashtable()
	{
		Hashtable hash = new Hashtable();
		for(int i = 0; i < abbrevs.size(); i++)
		{
			Abbrev abbrev = (Abbrev)abbrevs.elementAt(i);
			if(abbrev.abbrev.length() > 0
				&& abbrev.expand.length() > 0)
			{
				hash.put(abbrev.abbrev,abbrev.expand);
			}
		}
		return hash;
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return abbrevs.size();
	} 

	
	public Object getValueAt(int row, int col)
	{
		Abbrev abbrev = (Abbrev)abbrevs.elementAt(row);
		switch(col)
		{
		case 0:
			return abbrev.abbrev;
		case 1:
			return abbrev.expand;
		default:
			return null;
		}
	} 

	
	public boolean isCellEditable(int row, int col)
	{
		return false;
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		if(value == null)
			value = """";

		Abbrev abbrev = (Abbrev)abbrevs.elementAt(row);

		if(col == 0)
			abbrev.abbrev = (String)value;
		else
			abbrev.expand = (String)value;

		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.abbrevs.abbrev"");
		case 1:
			return jEdit.getProperty(""options.abbrevs.expand"");
		default:
			return null;
		}
	} 

	
	class AbbrevCompare implements MiscUtilities.Compare
	{
		int col;

		AbbrevCompare(int col)
		{
			this.col = col;
		}

		public int compare(Object obj1, Object obj2)
		{
			Abbrev a1 = (Abbrev)obj1;
			Abbrev a2 = (Abbrev)obj2;

			if(col == 0)
			{
				String abbrev1 = a1.abbrev.toLowerCase();
				String abbrev2 = a2.abbrev.toLowerCase();

				return MiscUtilities.compareStrings(
					abbrev1,abbrev2,true);
			}
			else
			{
				String expand1 = a1.expand.toLowerCase();
				String expand2 = a2.expand.toLowerCase();

				return MiscUtilities.compareStrings(
					expand1,expand2,true);
			}
		}
	} 
} 


class Abbrev
{
	Abbrev() {}

	Abbrev(String abbrev, String expand)
	{
		this.abbrev = abbrev;
		this.expand = expand;
	}

	String abbrev;
	String expand;
} 
"
jEdit,4,org.gjt.sp.jedit.gui.AboutDialog,3,7,0,5,27,3,1,5,3,1.0,110,1.0,0,0.996946565,0.666666667,0,0,35.33333333,1,0.6667,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;

public class AboutDialog extends EnhancedDialog
{
	public AboutDialog(View view)
	{
		super(view,jEdit.getProperty(""about.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		content.add(BorderLayout.CENTER,new AboutPanel());

		JPanel buttonPanel = new JPanel();
		buttonPanel.setLayout(new BoxLayout(buttonPanel,BoxLayout.X_AXIS));
		buttonPanel.setBorder(new EmptyBorder(12,0,0,0));

		buttonPanel.add(Box.createGlue());
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(close);
		buttonPanel.add(close);
		buttonPanel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttonPanel);

		pack();
		setResizable(false);
		setLocationRelativeTo(view);
		show();
	}

	public void ok()
	{
		dispose();
	}

	public void cancel()
	{
		dispose();
	}

	
	private JButton close;

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			dispose();
		}
	}

	static class AboutPanel extends JComponent
	{
		ImageIcon image;
		Vector text;
		int scrollPosition;
		AnimationThread thread;

		AboutPanel()
		{
			setFont(UIManager.getFont(""Label.font""));
			setForeground(new Color(206,206,229));
			image = new ImageIcon(getClass().getResource(
				""/org/gjt/sp/jedit/icons/about.gif""));
			setBorder(new MatteBorder(1,1,1,1,Color.black));

			text = new Vector(50);
			StringTokenizer st = new StringTokenizer(
				jEdit.getProperty(""about.text""),""\n"");
			while(st.hasMoreTokens())
			{
				text.addElement(st.nextToken());
			}

			scrollPosition = -300;

			thread = new AnimationThread();
		}

		public void paintComponent(Graphics _g)
		{
			Graphics2D g = (Graphics2D)_g;

			image.paintIcon(this,g,1,1);

			FontMetrics fm = g.getFontMetrics();
			int height = fm.getHeight();
			int firstLine = scrollPosition / height;

			int firstLineOffset = height - scrollPosition % height;
			int lastLine = (scrollPosition + 320) / height - 3;

			int y = 50 + firstLineOffset;

			for(int i = firstLine; i <= lastLine; i++)
			{
				if(i >= 0 && i < text.size())
				{
					String line = (String)text.elementAt(i);
					g.drawString(line,130 + (340
						- fm.stringWidth(line)) / 2,y);
				}
				y += fm.getHeight();
			}

			String[] args = { jEdit.getVersion() };
			String version = jEdit.getProperty(""about.version"",args);
			g.drawString(version,130 + (340 - fm.stringWidth(version)) / 2,
				370);
		}

		public Dimension getPreferredSize()
		{
			return new Dimension(1 + image.getIconWidth(),
				1 + image.getIconHeight());
		}

		public void addNotify()
		{
			super.addNotify();
			thread.start();
		}

		public void removeNotify()
		{
			super.removeNotify();
			thread.stop();
		}

		class AnimationThread extends Thread
		{
			AnimationThread()
			{
				super(""About box animation thread"");
				setPriority(Thread.MIN_PRIORITY);
			}

			public void run()
			{
				for(;;)
				{
					long start = System.currentTimeMillis();

					scrollPosition++;

					FontMetrics fm = getFontMetrics(getFont());
					int max = text.size() * fm.getHeight();
					if(scrollPosition > max)
						scrollPosition = -300;

					try
					{
						Thread.sleep(Math.max(0,25 -
							(System.currentTimeMillis() - start)));
					}
					catch(InterruptedException ie)
					{
					}

					repaint();
				}
			}
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.search.SearchDialog,39,7,0,28,155,517,7,26,8,0.828007519,1788,0.892857143,5,0.947750363,0.210526316,4,8,44.12820513,14,2.1282,1,"

package org.gjt.sp.jedit.search;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.util.HashMap;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class SearchDialog extends EnhancedDialog implements EBComponent
{
	
	
	public static final int CURRENT_BUFFER = 0;
	public static final int ALL_BUFFERS = 1;
	public static final int DIRECTORY = 2;
	

	
	
	public static void showSearchDialog(View view, String searchString,
		int searchIn)
	{
		SearchDialog dialog = (SearchDialog)viewHash.get(view);
		if(dialog != null)
		{
			
			if(OperatingSystem.isUnix() && !OperatingSystem.isMacOS())
			{
				dialog.setVisible(false);
				dialog.setVisible(true);
			}

			dialog.setSearchString(searchString,searchIn);
			GUIUtilities.requestFocus(dialog,dialog.find);
			dialog.toFront();
			dialog.requestFocus();
		}
		else
		{
			dialog = new SearchDialog(view,searchString,searchIn);
			viewHash.put(view,dialog);
		}
	} 

	
	
	public SearchDialog(View view, String searchString)
	{
		this(view,searchString,CURRENT_BUFFER);
	} 

	
	
	public SearchDialog(View view, String searchString, int searchIn)
	{
		super(view,jEdit.getProperty(""search.title""),false);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(0,12,12,12));
		setContentPane(content);

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.add(BorderLayout.NORTH,createFieldPanel());
		centerPanel.add(BorderLayout.CENTER,createSearchSettingsPanel());
		content.add(BorderLayout.CENTER,centerPanel);
		content.add(BorderLayout.SOUTH,createMultiFilePanel());

		content.add(BorderLayout.EAST,createButtonsPanel());

		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		wrap.setSelected(SearchAndReplace.getAutoWrapAround());

		if(SearchAndReplace.getReverseSearch())
			searchBack.setSelected(true);
		else
			searchForward.setSelected(true);

		if(SearchAndReplace.getBeanShellReplace())
		{
			replace.setModel(""replace.script"");
			beanShellReplace.setSelected(true);
		}
		else
		{
			replace.setModel(""replace"");
			stringReplace.setSelected(true);
		}

		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();

		if(fileset instanceof DirectoryListSet)
		{
			filter.setText(((DirectoryListSet)fileset)
				.getFileFilter());
			directory.setText(((DirectoryListSet)fileset)
				.getDirectory());
			searchSubDirectories.setSelected(((DirectoryListSet)fileset)
				.isRecursive());
		}
		else
		{
			String path;
			if(view.getBuffer().getVFS() instanceof FileVFS)
			{
				path = MiscUtilities.getParentOfPath(
					view.getBuffer().getPath());
			}
			else
				path = System.getProperty(""user.dir"");
			directory.setText(path);

			if(fileset instanceof AllBufferSet)
			{
				filter.setText(((AllBufferSet)fileset)
					.getFileFilter());
			}
			else
			{
				filter.setText(""*"" + MiscUtilities
					.getFileExtension(view.getBuffer()
					.getName()));
			}

			searchSubDirectories.setSelected(true);
		}

		directory.addCurrentToHistory();

		keepDialog.setSelected(jEdit.getBooleanProperty(
			""search.keepDialog.toggle""));

		setSearchString(searchString,searchIn);

		pack();
		jEdit.unsetProperty(""search.width"");
		jEdit.unsetProperty(""search.d-width"");
		jEdit.unsetProperty(""search.height"");
		jEdit.unsetProperty(""search.d-height"");
		GUIUtilities.loadGeometry(this,""search"");
		show();

		EditBus.addToBus(this);

		GUIUtilities.requestFocus(this,find);
	} 

	
	
	public void setSearchString(String searchString, int searchIn)
	{
		if(searchString == null)
			find.setText(null);
		else
		{
			if(searchString.indexOf('\n') == -1)
			{
				find.setText(searchString);
				find.selectAll();
			}
			else if(searchIn == CURRENT_BUFFER)
			{
				searchSelection.setSelected(true);
				hyperSearch.setSelected(true);
			}
		}

		if(searchIn == CURRENT_BUFFER)
		{
			if(!searchSelection.isSelected())
			{
				
				searchCurrentBuffer.setSelected(true);

				
				hyperSearch.setSelected(jEdit.getBooleanProperty(
					""search.hypersearch.toggle""));
			}
		}
		else if(searchIn == ALL_BUFFERS)
		{
			searchAllBuffers.setSelected(true);
			hyperSearch.setSelected(true);
		}
		else if(searchIn == DIRECTORY)
		{
			hyperSearch.setSelected(true);
			searchDirectory.setSelected(true);
		}

		updateEnabled();
	} 

	
	public void ok()
	{
		try
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

			if(!save())
				return;

			if(hyperSearch.isSelected() || searchSelection.isSelected())
			{
				if(SearchAndReplace.hyperSearch(view,
					searchSelection.isSelected()));
					closeOrKeepDialog();
			}
			else
			{
				if(SearchAndReplace.find(view))
					closeOrKeepDialog();
			}
		}
		finally
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
		}
	} 

	
	public void cancel()
	{
		save();
		GUIUtilities.saveGeometry(this,""search"");
		dispose();
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof SearchSettingsChanged)
		{
			ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
			regexp.setSelected(SearchAndReplace.getRegexp());
		}
		else if(msg instanceof ViewUpdate)
		{
			ViewUpdate vmsg = (ViewUpdate)msg;
			if(vmsg.getView() == view
				&& vmsg.getWhat() == ViewUpdate.CLOSED)
			{
				viewHash.remove(view);
			}
		}
	} 

	
	public void dispose()
	{
		EditBus.removeFromBus(this);
		viewHash.remove(view);
		super.dispose();
	} 

	

	private static HashMap viewHash = new HashMap();

	
	private View view;

	
	private HistoryTextField find, replace;

	private JRadioButton stringReplace, beanShellReplace;

	
	private JCheckBox keepDialog, ignoreCase, regexp, hyperSearch,
		wrap;
	private JRadioButton searchBack, searchForward;
	private JRadioButton searchSelection, searchCurrentBuffer, searchAllBuffers,
		searchDirectory;

	
	private HistoryTextField filter, directory;
	private JCheckBox searchSubDirectories;
	private JButton choose;

	
	private JButton findBtn,  replaceAndFindBtn, replaceAllBtn,
		closeBtn;
	

	
	private JPanel createFieldPanel()
	{
		ButtonActionHandler actionHandler = new ButtonActionHandler();

		JPanel fieldPanel = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,1));
		fieldPanel.setBorder(new EmptyBorder(0,0,12,12));

		JLabel label = new JLabel(jEdit.getProperty(""search.find""));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.find.mnemonic"")
			.charAt(0));
		find = new HistoryTextField(""find"");

		
		Dimension size = find.getPreferredSize();
		size.width = find.getFontMetrics(find.getFont())
			.charWidth('a') * 25;
		find.setPreferredSize(size);

		find.addActionListener(actionHandler);
		label.setLabelFor(find);
		label.setBorder(new EmptyBorder(12,0,2,0));
		fieldPanel.add(label);
		fieldPanel.add(find);

		label = new JLabel(jEdit.getProperty(""search.replace""));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.replace.mnemonic"")
			.charAt(0));
		label.setBorder(new EmptyBorder(12,0,0,0));
		fieldPanel.add(label);

		ButtonGroup grp = new ButtonGroup();
		ReplaceActionHandler replaceActionHandler = new ReplaceActionHandler();

		
		
		
		

		Box replaceModeBox = new Box(BoxLayout.X_AXIS);
		stringReplace = new MyJRadioButton(jEdit.getProperty(
			""search.string-replace-btn""));
		stringReplace.addActionListener(replaceActionHandler);
		grp.add(stringReplace);
		replaceModeBox.add(stringReplace);

		replaceModeBox.add(Box.createHorizontalStrut(12));

		beanShellReplace = new MyJRadioButton(jEdit.getProperty(
			""search.beanshell-replace-btn""));
		beanShellReplace.addActionListener(replaceActionHandler);
		grp.add(beanShellReplace);
		replaceModeBox.add(beanShellReplace);

		fieldPanel.add(replaceModeBox);

		fieldPanel.add(Box.createVerticalStrut(3));

		replace = new HistoryTextField(""replace"");
		replace.addActionListener(actionHandler);
		label.setLabelFor(replace);
		fieldPanel.add(replace);

		return fieldPanel;
	} 

	
	private JPanel createSearchSettingsPanel()
	{
		JPanel searchSettings = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,3));
		searchSettings.setBorder(new EmptyBorder(0,0,12,12));

		SettingsActionHandler actionHandler = new SettingsActionHandler();
		ButtonGroup fileset = new ButtonGroup();
		ButtonGroup direction = new ButtonGroup();

		searchSettings.add(new JLabel(jEdit.getProperty(""search.fileset"")));

		searchSettings.add(new JLabel(jEdit.getProperty(""search.settings"")));

		searchSettings.add(new JLabel(jEdit.getProperty(""search.direction"")));

		searchSelection = new JRadioButton(jEdit.getProperty(""search.selection""));
		searchSelection.setMnemonic(jEdit.getProperty(""search.selection.mnemonic"")
			.charAt(0));
		fileset.add(searchSelection);
		searchSettings.add(searchSelection);
		searchSelection.addActionListener(actionHandler);

		keepDialog = new JCheckBox(jEdit.getProperty(""search.keep""));
		keepDialog.setMnemonic(jEdit.getProperty(""search.keep.mnemonic"")
			.charAt(0));
		searchSettings.add(keepDialog);

		searchBack = new JRadioButton(jEdit.getProperty(""search.back""));
		searchBack.setMnemonic(jEdit.getProperty(""search.back.mnemonic"")
			.charAt(0));
		direction.add(searchBack);
		searchSettings.add(searchBack);
		searchBack.addActionListener(actionHandler);

		searchCurrentBuffer = new JRadioButton(jEdit.getProperty(""search.current""));
		searchCurrentBuffer.setMnemonic(jEdit.getProperty(""search.current.mnemonic"")
			.charAt(0));
		fileset.add(searchCurrentBuffer);
		searchSettings.add(searchCurrentBuffer);
		searchCurrentBuffer.addActionListener(actionHandler);

		ignoreCase = new JCheckBox(jEdit.getProperty(""search.case""));
		ignoreCase.setMnemonic(jEdit.getProperty(""search.case.mnemonic"")
			.charAt(0));
		searchSettings.add(ignoreCase);
		ignoreCase.addActionListener(actionHandler);

		searchForward = new JRadioButton(jEdit.getProperty(""search.forward""));
		searchForward.setMnemonic(jEdit.getProperty(""search.forward.mnemonic"")
			.charAt(0));
		direction.add(searchForward);
		searchSettings.add(searchForward);
		searchForward.addActionListener(actionHandler);

		searchAllBuffers = new JRadioButton(jEdit.getProperty(""search.all""));
		searchAllBuffers.setMnemonic(jEdit.getProperty(""search.all.mnemonic"")
			.charAt(0));
		fileset.add(searchAllBuffers);
		searchSettings.add(searchAllBuffers);
		searchAllBuffers.addActionListener(actionHandler);

		regexp = new JCheckBox(jEdit.getProperty(""search.regexp""));
		regexp.setMnemonic(jEdit.getProperty(""search.regexp.mnemonic"")
			.charAt(0));
		searchSettings.add(regexp);
		regexp.addActionListener(actionHandler);

		wrap = new JCheckBox(jEdit.getProperty(""search.wrap""));
		wrap.setMnemonic(jEdit.getProperty(""search.wrap.mnemonic"")
			.charAt(0));
		searchSettings.add(wrap);
		wrap.addActionListener(actionHandler);

		searchDirectory = new JRadioButton(jEdit.getProperty(""search.directory""));
		searchDirectory.setMnemonic(jEdit.getProperty(""search.directory.mnemonic"")
			.charAt(0));
		fileset.add(searchDirectory);
		searchSettings.add(searchDirectory);
		searchDirectory.addActionListener(actionHandler);

		hyperSearch = new JCheckBox(jEdit.getProperty(""search.hypersearch""));
		hyperSearch.setMnemonic(jEdit.getProperty(""search.hypersearch.mnemonic"")
			.charAt(0));
		searchSettings.add(hyperSearch);
		hyperSearch.addActionListener(actionHandler);

		return searchSettings;
	} 

	
	private JPanel createMultiFilePanel()
	{
		JPanel multifile = new JPanel();

		GridBagLayout layout = new GridBagLayout();
		multifile.setLayout(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = cons.gridwidth = cons.gridheight = 1;
		cons.anchor = GridBagConstraints.WEST;
		cons.fill = GridBagConstraints.HORIZONTAL;

		MultiFileActionHandler actionListener = new MultiFileActionHandler();
		filter = new HistoryTextField(""search.filter"");
		filter.addActionListener(actionListener);

		cons.insets = new Insets(0,0,3,0);

		JLabel label = new JLabel(jEdit.getProperty(""search.filterField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.filterField.mnemonic"")
			.charAt(0));
		label.setLabelFor(filter);
		cons.weightx = 0.0f;
		layout.setConstraints(label,cons);
		multifile.add(label);

		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0f;
		layout.setConstraints(filter,cons);
		multifile.add(filter);

		cons.gridy++;

		directory = new HistoryTextField(""search.directory"");
		directory.addActionListener(actionListener);

		label = new JLabel(jEdit.getProperty(""search.directoryField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));

		label.setDisplayedMnemonic(jEdit.getProperty(""search.directoryField.mnemonic"")
			.charAt(0));
		label.setLabelFor(directory);
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0f;
		layout.setConstraints(label,cons);
		multifile.add(label);

		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0f;
		cons.gridwidth = 2;
		layout.setConstraints(directory,cons);
		multifile.add(directory);

		choose = new JButton(jEdit.getProperty(""search.choose""));
		choose.setMnemonic(jEdit.getProperty(""search.choose.mnemonic"")
			.charAt(0));
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0f;
		cons.gridwidth = 1;
		layout.setConstraints(choose,cons);
		multifile.add(choose);
		choose.addActionListener(actionListener);

		cons.insets = new Insets(0,0,0,0);
		cons.gridy++;
		cons.gridwidth = 4;

		searchSubDirectories = new JCheckBox(jEdit.getProperty(
			""search.subdirs""));
		searchSubDirectories.setMnemonic(jEdit.getProperty(""search.subdirs.mnemonic"")
			.charAt(0));
		layout.setConstraints(searchSubDirectories,cons);
		multifile.add(searchSubDirectories);

		return multifile;
	} 

	
	private Box createButtonsPanel()
	{
		Box box = new Box(BoxLayout.Y_AXIS);

		ButtonActionHandler actionHandler = new ButtonActionHandler();

		box.add(Box.createVerticalStrut(12));

		JPanel grid = new JPanel(new GridLayout(5,1,0,12));

		findBtn = new JButton(jEdit.getProperty(""search.findBtn""));
		getRootPane().setDefaultButton(findBtn);
		grid.add(findBtn);
		findBtn.addActionListener(actionHandler);

		

		replaceAndFindBtn = new JButton(jEdit.getProperty(""search.replaceAndFindBtn""));
		replaceAndFindBtn.setMnemonic(jEdit.getProperty(""search.replaceAndFindBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAndFindBtn);
		replaceAndFindBtn.addActionListener(actionHandler);

		replaceAllBtn = new JButton(jEdit.getProperty(""search.replaceAllBtn""));
		replaceAllBtn.setMnemonic(jEdit.getProperty(""search.replaceAllBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAllBtn);
		replaceAllBtn.addActionListener(actionHandler);

		closeBtn = new JButton(jEdit.getProperty(""common.close""));
		grid.add(closeBtn);
		closeBtn.addActionListener(actionHandler);

		grid.setMaximumSize(grid.getPreferredSize());

		box.add(grid);
		box.add(Box.createGlue());

		return box;
	} 

	
	private void updateEnabled()
	{
		wrap.setEnabled(!hyperSearch.isSelected()
			&& !searchSelection.isSelected());

		boolean reverseEnabled = !hyperSearch.isSelected()
			&& searchCurrentBuffer.isSelected();
		searchBack.setEnabled(reverseEnabled && !regexp.isSelected());
		searchForward.setEnabled(reverseEnabled);
		if(!reverseEnabled)
			searchForward.setSelected(true);

		filter.setEnabled(searchAllBuffers.isSelected()
			|| searchDirectory.isSelected());

		boolean directoryEnabled = searchDirectory.isSelected();

		directory.setEnabled(directoryEnabled);
		choose.setEnabled(directoryEnabled);
		searchSubDirectories.setEnabled(directoryEnabled);

		findBtn.setEnabled(!searchSelection.isSelected()
			|| hyperSearch.isSelected());
		replaceAndFindBtn.setEnabled(!hyperSearch.isSelected()
			&& !searchSelection.isSelected());
	} 

	
	private boolean save()
	{
		String filter = this.filter.getText();
		this.filter.addCurrentToHistory();
		if(filter.length() == 0)
			filter = ""*"";

		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();

		if(searchSelection.isSelected())
			fileset = new CurrentBufferSet();
		else if(searchCurrentBuffer.isSelected())
		{
			fileset = new CurrentBufferSet();

			jEdit.setBooleanProperty(""search.hypersearch.toggle"",
				hyperSearch.isSelected());
		}
		else if(searchAllBuffers.isSelected())
			fileset = new AllBufferSet(filter);
		else if(searchDirectory.isSelected())
		{
			String directory = this.directory.getText();
			this.directory.addCurrentToHistory();
			boolean recurse = searchSubDirectories.isSelected();

			if(fileset instanceof DirectoryListSet)
			{
				DirectoryListSet dset = (DirectoryListSet)fileset;
				if(!dset.getDirectory().equals(directory)
					|| !dset.getFileFilter().equals(filter)
					|| !dset.isRecursive() == recurse)
					fileset = new DirectoryListSet(directory,filter,recurse);
			}
			else
				fileset = new DirectoryListSet(directory,filter,recurse);
		}
		else
		{
			
			fileset = null;
		}

		jEdit.setBooleanProperty(""search.keepDialog.toggle"",
			keepDialog.isSelected());

		boolean ok = true;

		if(fileset.getFileCount() == 0)
		{
			
			GUIUtilities.error(this,""empty-fileset"",null);
			ok = false;
		}
		else
			SearchAndReplace.setSearchFileSet(fileset);

		if(find.getText().length() != 0)
		{
			find.addCurrentToHistory();
			SearchAndReplace.setSearchString(find.getText());
			replace.addCurrentToHistory();

			SearchAndReplace.setReplaceString(replace.getText());
		}
		else
			ok = false;

		return ok;
	} 

	
	private void closeOrKeepDialog()
	{
		if(keepDialog.isSelected())
		{
			
			

			
			
			if(!hyperSearch.isSelected())
			{
				toFront();
				requestFocus();
				find.requestFocus();
			}
			return;
		}
		else
		{
			GUIUtilities.saveGeometry(this,""search"");
			dispose();
		}
	} 

	

	

	

	
	
	
	class MyJRadioButton extends JRadioButton
	{
		MyJRadioButton(String label)
		{
			super(label);
		}

		public boolean isFocusTraversable()
		{
			return false;
		}
	} 

	
	class ReplaceActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			replace.setModel(beanShellReplace.isSelected()
				? ""replace.script""
				: ""replace"");
			SearchAndReplace.setBeanShellReplace(
				beanShellReplace.isSelected());
		}
	} 

	
	class SettingsActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == ignoreCase)
				SearchAndReplace.setIgnoreCase(ignoreCase.isSelected());
			else if(source == regexp)
				SearchAndReplace.setRegexp(regexp.isSelected());
			else if(source == searchBack || source == searchForward)
				SearchAndReplace.setReverseSearch(searchBack.isSelected());
			else if(source == wrap)
				SearchAndReplace.setAutoWrapAround(wrap.isSelected());
			else if(source == searchCurrentBuffer)
				hyperSearch.setSelected(false);
			else if(source == searchSelection
				|| source == searchAllBuffers
				|| source == searchDirectory)
				hyperSearch.setSelected(true);

			updateEnabled();
		}
	} 

	
	class MultiFileActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == choose)
			{
				File dir = new File(directory.getText());
				JFileChooser chooser = new JFileChooser(dir.getParent());
				chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
				chooser.setSelectedFile(dir);

				if(chooser.showOpenDialog(SearchDialog.this)
					== JFileChooser.APPROVE_OPTION)
					directory.setText(chooser.getSelectedFile().getPath());
			}
			else 
			{
				
				
				ok();
			}
		}
	} 

	
	class ButtonActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == closeBtn)
				cancel();
			else if(source == findBtn || source == find
				|| source == replace)
			{
				ok();
			}
			else if(source == replaceAndFindBtn)
			{
				save();
				if(SearchAndReplace.replace(view))
					ok();
				else
					getToolkit().beep();
			}
			else if(source == replaceAllBtn)
			{
				setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

				save();

				if(searchSelection.isSelected())
				{
					if(SearchAndReplace.replace(view))
						closeOrKeepDialog();
					else
						getToolkit().beep();
				}
				else
				{
					if(SearchAndReplace.replaceAll(view))
						closeOrKeepDialog();
					else
						getToolkit().beep();
				}

				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			}
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.search.AllBufferSet,5,2,0,7,24,0,1,6,3,0.625,99,1.0,0,0.636363636,0.6,0,0,18.4,4,1.4,0,"

package org.gjt.sp.jedit.search;


import gnu.regexp.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class AllBufferSet extends BufferListSet
{
	
	
	public AllBufferSet(String glob)
	{
		this.glob = glob;
	} 

	
	
	public String getFileFilter()
	{
		return glob;
	} 

	
	
	public String getCode()
	{
		return ""new AllBufferSet(\"""" + MiscUtilities.charsToEscapes(glob)
			+ ""\"")"";
	} 

	
	private String glob;
	

	
	protected String[] _getFiles()
	{
		Buffer[] buffers = jEdit.getBuffers();
		Vector vector = new Vector(buffers.length);

		RE filter;
		try
		{
			filter = new RE(MiscUtilities.globToRE(glob));
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,DirectoryListSet.class,e);
			return null;
		}

		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if(filter.isMatch(buffer.getName()))
				vector.addElement(buffer.getPath());
		}

		String[] retVal = new String[vector.size()];
		vector.copyInto(retVal);
		return retVal;
	} 
}
"
jEdit,4,org.gjt.sp.jedit.textarea.FoldVisibilityManager,21,1,0,14,53,0,9,7,21,0.492857143,1726,1.0,3,0.0,0.25170068,0,0,80.85714286,31,8.5714,1,"

package org.gjt.sp.jedit.textarea;


import java.awt.Toolkit;
import org.gjt.sp.jedit.buffer.OffsetManager;
import org.gjt.sp.jedit.*;



public class FoldVisibilityManager
{
	
	public FoldVisibilityManager(Buffer buffer, OffsetManager offsetMgr,
		JEditTextArea textArea)
	{
		this.buffer = buffer;
		this.offsetMgr = offsetMgr;
		this.textArea = textArea;
	} 

	
	
	public boolean isNarrowed()
	{
		return narrowed;
	} 

	
	
	public int getVirtualLineCount()
	{
		return offsetMgr.getVirtualLineCount(index);
	} 

	
	
	public final boolean isLineVisible(int line)
	{
		if(line < 0 || line >= offsetMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		try
		{
			buffer.readLock();
			return offsetMgr.isLineVisible(line,index);
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public int getFirstVisibleLine()
	{
		try
		{
			buffer.readLock();

			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				if(offsetMgr.isLineVisible(i,index))
					return i;
			}
		}
		finally
		{
			buffer.readUnlock();
		}

		
		return -1;
	} 

	
	
	public int getLastVisibleLine()
	{
		try
		{
			buffer.readLock();

			for(int i = buffer.getLineCount() - 1; i >= 0; i--)
			{
				if(offsetMgr.isLineVisible(i,index))
					return i;
			}
		}
		finally
		{
			buffer.readUnlock();
		}

		
		return -1;
	} 

	
	
	public int getNextVisibleLine(int line)
	{
		if(line < 0 || line >= offsetMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		try
		{
			buffer.readLock();

			if(line == buffer.getLineCount() - 1)
				return -1;

			for(int i = line + 1; i < buffer.getLineCount(); i++)
			{
				if(offsetMgr.isLineVisible(i,index))
					return i;
			}
			return -1;
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public int getPrevVisibleLine(int line)
	{
		if(line < 0 || line >= offsetMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		try
		{
			buffer.readLock();

			if(line == 0)
				return -1;

			for(int i = line - 1; i >= 0; i--)
			{
				if(offsetMgr.isLineVisible(i,index))
					return i;
			}
			return -1;
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public int physicalToVirtual(int line)
	{
		try
		{
			buffer.readLock();

			if(line < 0)
				throw new ArrayIndexOutOfBoundsException(line + "" < 0"");
			else if(line >= offsetMgr.getLineCount())
			{
				throw new ArrayIndexOutOfBoundsException(line + "" > ""
					+ buffer.getLineCount());
			}

			
			if(getVirtualLineCount() == buffer.getLineCount())
				return line;

			while(!offsetMgr.isLineVisible(line,index) && line > 0)
				line--;

			if(line == 0 && !offsetMgr.isLineVisible(line,index))
			{
				
				return 0;
			}

			if(lastPhysical == line)
			{
				if(lastVirtual < 0 || lastVirtual >= offsetMgr.getVirtualLineCount(index))
				{
					throw new ArrayIndexOutOfBoundsException(
						""cached: "" + lastVirtual);
				}
			}
			else if(line > lastPhysical && lastPhysical != -1)
			{
				for(;;)
				{
					if(lastPhysical == line)
						break;

					if(offsetMgr.isLineVisible(lastPhysical,index))
						lastVirtual++;

					if(lastPhysical == buffer.getLineCount() - 1)
						break;
					else
						lastPhysical++;
				}

				if(lastVirtual < 0 || lastVirtual >= offsetMgr.getVirtualLineCount(index))
				{
					throw new ArrayIndexOutOfBoundsException(
						""fwd scan: "" + lastVirtual);
				}
			}
			else if(line < lastPhysical && lastPhysical - line > line)
			{
				for(;;)
				{
					if(lastPhysical == line)
						break;

					if(offsetMgr.isLineVisible(lastPhysical,index))
						lastVirtual--;

					if(lastPhysical == 0)
						break;
					else
						lastPhysical--;
				}

				if(lastVirtual < 0 || lastVirtual >= offsetMgr.getVirtualLineCount(index))
				{
					throw new ArrayIndexOutOfBoundsException(
						""back scan: "" + lastVirtual);
				}
			}
			else
			{
				lastPhysical = 0;
				
				while(!offsetMgr.isLineVisible(lastPhysical,index))
					lastPhysical++;

				lastVirtual = 0;
				for(;;)
				{
					if(lastPhysical == line)
						break;

					if(offsetMgr.isLineVisible(lastPhysical,index))
						lastVirtual++;

					if(lastPhysical == buffer.getLineCount() - 1)
						break;
					else
						lastPhysical++;
				}

				if(lastVirtual < 0 || lastVirtual >= offsetMgr.getVirtualLineCount(index))
				{
					throw new ArrayIndexOutOfBoundsException(
						""zero scan: "" + lastVirtual);
				}
			}

			return lastVirtual;
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public int virtualToPhysical(int line)
	{
		try
		{
			buffer.readLock();

			if(line < 0)
				throw new ArrayIndexOutOfBoundsException(line + "" < 0"");
			else if(line >= offsetMgr.getVirtualLineCount(index))
			{
				throw new ArrayIndexOutOfBoundsException(line + "" > ""
					+ offsetMgr.getVirtualLineCount(index));
			}

			
			if(getVirtualLineCount() == buffer.getLineCount())
				return line;

			if(lastVirtual == line)
			{
				if(lastPhysical < 0 || lastPhysical >= buffer.getLineCount())
				{
					throw new ArrayIndexOutOfBoundsException(
						""cached: "" + lastPhysical);
				}
			}
			else if(line > lastVirtual && lastVirtual != -1)
			{
				for(;;)
				{
					if(offsetMgr.isLineVisible(lastPhysical,index))
					{
						if(lastVirtual == line)
							break;
						else
							lastVirtual++;
					}

					if(lastPhysical == buffer.getLineCount() - 1)
						break;
					else
						lastPhysical++;
				}

				if(lastPhysical < 0 || lastPhysical >= buffer.getLineCount())
				{
					throw new ArrayIndexOutOfBoundsException(
						""fwd scan: "" + lastPhysical);
				}
			}
			else if(line < lastVirtual && lastVirtual - line > line)
			{
				for(;;)
				{
					if(offsetMgr.isLineVisible(lastPhysical,index))
					{
						if(lastVirtual == line)
							break;
						else
							lastVirtual--;
					}

					if(lastPhysical == 0)
						break;
					else
						lastPhysical--;
				}

				if(lastPhysical < 0 || lastPhysical >= buffer.getLineCount())
				{
					throw new ArrayIndexOutOfBoundsException(
						""back scan: "" + lastPhysical);
				}
			}
			else
			{

				lastPhysical = 0;
				
				while(!offsetMgr.isLineVisible(lastPhysical,index))
					lastPhysical++;

				lastVirtual = 0;
				for(;;)
				{
					if(offsetMgr.isLineVisible(lastPhysical,index))
					{
						if(lastVirtual == line)
							break;
						else
							lastVirtual++;
					}

					if(lastPhysical == buffer.getLineCount() - 1)
						break;
					else
						lastPhysical++;
				}

				if(lastPhysical < 0 || lastPhysical >= buffer.getLineCount())
				{
					throw new ArrayIndexOutOfBoundsException(
						""zero scan: "" + lastPhysical);
				}
			}

			return lastPhysical;
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public void collapseFold(int line)
	{
		int lineCount = buffer.getLineCount();
		int start = 0;
		int end = lineCount - 1;

		try
		{
			buffer.writeLock();

			
			
			if(line != 0
				&& line != buffer.getLineCount() - 1
				&& buffer.isFoldStart(line)
				&& !offsetMgr.isLineVisible(line + 1,index))
			{
				line--;
			}

			int initialFoldLevel = buffer.getFoldLevel(line);

			
			if(line != lineCount - 1
				&& buffer.getFoldLevel(line + 1) > initialFoldLevel)
			{
				
				start = line + 1;

				for(int i = line + 1; i < lineCount; i++)
				{
					if(buffer.getFoldLevel(i) <= initialFoldLevel)
					{
						end = i - 1;
						break;
					}
				}
			}
			else
			{
				boolean ok = false;

				
				for(int i = line - 1; i >= 0; i--)
				{
					if(buffer.getFoldLevel(i) < initialFoldLevel)
					{
						start = i + 1;
						ok = true;
						break;
					}
				}

				if(!ok)
				{
					
					return;
				}

				for(int i = line + 1; i < lineCount; i++)
				{
					if(buffer.getFoldLevel(i) < initialFoldLevel)
					{
						end = i - 1;
						break;
					}
				}
			} 

			
			int delta = (end - start + 1);

			for(int i = start; i <= end; i++)
			{
				if(offsetMgr.isLineVisible(i,index))
					offsetMgr.setLineVisible(i,index,false);
				else
					delta--;
			}

			if(delta == 0)
			{
				
				return;
			}

			offsetMgr.setVirtualLineCount(index,
				offsetMgr.getVirtualLineCount(index)
				- delta);
			
		}
		finally
		{
			buffer.writeUnlock();
		}

		foldStructureChanged();

		int virtualLine = physicalToVirtual(start);
		if(textArea.getFirstLine() > virtualLine)
			textArea.setFirstLine(virtualLine - textArea.getElectricScroll());
	} 

	
	
	public int expandFold(int line, boolean fully)
	{
		
		int returnValue = -1;

		int lineCount = buffer.getLineCount();
		int start = 0;
		int end = lineCount - 1;
		int delta = 0;

		try
		{
			buffer.writeLock();

			int initialFoldLevel = buffer.getFoldLevel(line);

			
			if(line != lineCount - 1
				&& offsetMgr.isLineVisible(line,index)
				&& !offsetMgr.isLineVisible(line + 1,index)
				&& buffer.getFoldLevel(line + 1) > initialFoldLevel)
			{
				
				start = line + 1;

				for(int i = line + 1; i < lineCount; i++)
				{
					if(
						buffer.getFoldLevel(i) <= initialFoldLevel)
					{
						end = i - 1;
						break;
					}
				}
			}
			else
			{
				boolean ok = false;

				
				for(int i = line - 1; i >= 0; i--)
				{
					if(offsetMgr.isLineVisible(i,index) && buffer.getFoldLevel(i) < initialFoldLevel)
					{
						start = i + 1;
						ok = true;
						break;
					}
				}

				if(!ok)
				{
					
					return -1;
				}

				for(int i = line + 1; i < lineCount; i++)
				{
					if((offsetMgr.isLineVisible(i,index) &&
						buffer.getFoldLevel(i) < initialFoldLevel)
						|| i == getLastVisibleLine())
					{
						end = i - 1;
						break;
					}
				}
			} 

			

			
			initialFoldLevel = buffer.getFoldLevel(start);

			for(int i = start; i <= end; i++)
			{
				buffer.getFoldLevel(i);
			}

			for(int i = start; i <= end; i++)
			{
				if(buffer.getFoldLevel(i) > initialFoldLevel)
				{
					if(returnValue == -1
						&& i != 0
						&& buffer.isFoldStart(i - 1))
					{
						returnValue = i - 1;
					}

					if(!offsetMgr.isLineVisible(i,index) && fully)
					{
						delta++;
						offsetMgr.setLineVisible(i,index,true);
					}
				}
				else if(!offsetMgr.isLineVisible(i,index))
				{
					delta++;
					offsetMgr.setLineVisible(i,index,true);
				}
			}

			offsetMgr.setVirtualLineCount(index,
				offsetMgr.getVirtualLineCount(index)
				+ delta);
			

			if(!fully && !offsetMgr.isLineVisible(line,index))
			{
				
				expandFold(line,false);
				return returnValue;
			}
		}
		finally
		{
			buffer.writeUnlock();
		}

		foldStructureChanged();

		int virtualLine = physicalToVirtual(start);
		int firstLine = textArea.getFirstLine();
		int visibleLines = textArea.getVisibleLines();
		if(virtualLine + delta >= firstLine + visibleLines
			&& delta < visibleLines - 1)
		{
			textArea.setFirstLine(virtualLine + delta - visibleLines + 1);
		}

		return returnValue;
	} 

	
	
	public void expandAllFolds()
	{
		try
		{
			buffer.writeLock();

			narrowed = false;

			if(offsetMgr.getVirtualLineCount(index) == buffer.getLineCount())
				return;

			offsetMgr.setVirtualLineCount(index,buffer.getLineCount());
			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				offsetMgr.setLineVisible(i,index,true);
			}
			foldStructureChanged();
		}
		finally
		{
			buffer.writeUnlock();
		}
	} 

	
	
	public void expandFolds(char digit)
	{
		if(digit < '1' || digit > '9')
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		else
			expandFolds((int)(digit - '1') + 1);
	} 

	
	
	public void expandFolds(int foldLevel)
	{
		try
		{
			buffer.writeLock();

			narrowed = false;

			
			
			offsetMgr.setVirtualLineCount(index,buffer.getLineCount());

			int newVirtualLineCount = 0;
			foldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;

			
			boolean seenVisibleLine = false;

			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				if(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)
				{
					seenVisibleLine = true;
					offsetMgr.setLineVisible(i,index,true);
					newVirtualLineCount++;
				}
				else
					offsetMgr.setLineVisible(i,index,false);
			}

			offsetMgr.setVirtualLineCount(index,newVirtualLineCount);
		}
		finally
		{
			buffer.writeUnlock();
		}

		foldStructureChanged();
	} 

	
	
	public void narrow(int start, int end)
	{
		if(start > end || start < 0 || end >= offsetMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(start + "", "" + end);

		
		if(start != offsetMgr.getLineCount() - 1
			&& !offsetMgr.isLineVisible(start + 1,index))
			expandFold(start,false);

		int virtualLineCount = offsetMgr.getVirtualLineCount(index);
		for(int i = 0; i < start; i++)
		{
			if(offsetMgr.isLineVisible(i,index))
			{
				virtualLineCount--;
				offsetMgr.setLineVisible(i,index,false);
			}
		}

		for(int i = end + 1; i < buffer.getLineCount(); i++)
		{
			if(offsetMgr.isLineVisible(i,index))
			{
				virtualLineCount--;
				offsetMgr.setLineVisible(i,index,false);
			}
		}

		offsetMgr.setVirtualLineCount(index,virtualLineCount);

		narrowed = true;

		foldStructureChanged();

		
		
		GUIUtilities.getView(textArea).getStatus().setMessageAndClear(
			jEdit.getProperty(""view.status.narrow""));
	} 

	

	
	
	public final void _grab(int index)
	{
		this.index = index;
		lastPhysical = lastVirtual = -1;
	} 

	
	
	public final void _release()
	{
		index = -1;
	} 

	
	
	public final int _getIndex()
	{
		return index;
	} 

	
	
	public void _invalidate(int startLine)
	{
		if(lastPhysical >= startLine)
			lastPhysical = lastVirtual = -1;
	} 

	

	
	
	public void foldStructureChanged()
	{
		lastPhysical = lastVirtual = -1;
		textArea.foldStructureChanged();
	} 

	

	
	private Buffer buffer;
	private OffsetManager offsetMgr;
	private JEditTextArea textArea;
	private int index;
	private int lastPhysical;
	private int lastVirtual;
	private boolean narrowed;
	

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.BufferSwitcher,4,5,0,6,16,0,4,5,2,0.5,54,1.0,1,0.995856354,0.416666667,0,0,12.0,2,1.0,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;

public class BufferSwitcher extends JComboBox
{
	public BufferSwitcher(EditPane editPane)
	{
		this.editPane = editPane;

		
		setRenderer(new BufferCellRenderer());
		setMaximumRowCount(10);
		addActionListener(new ActionHandler());
	}

	public void updateBufferList()
	{
		
		
		if(jEdit.getBufferCount() == 0)
			return;

		updating = true;
		setModel(new DefaultComboBoxModel(jEdit.getBuffers()));
		setSelectedItem(editPane.getBuffer());
		updating = false;
	}

	
	private EditPane editPane;
	private boolean updating;

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(!updating)
			{
				Buffer buffer = (Buffer)getSelectedItem();
				if(buffer != null)
					editPane.setBuffer(buffer);
			}
		}
	}

	class BufferCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			Buffer buffer = (Buffer)value;
			if(buffer == null)
				setIcon(null);
			else
				setIcon(buffer.getIcon());
			return this;
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.buffer.OffsetManager,28,1,0,7,39,46,3,6,21,0.902777778,1223,1.0,3,0.0,0.254464286,0,0,42.10714286,16,3.0714,7,"

package org.gjt.sp.jedit.buffer;


import javax.swing.text.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.IntegerArray;
import org.gjt.sp.util.Log;



public class OffsetManager
{
	
	public OffsetManager(Buffer buffer)
	{
		this.buffer = buffer;

		lineInfo = new long[1];
		
		lineInfo[0] = 1L | (0xffL << VISIBLE_SHIFT);
		lineContext = new TokenMarker.LineContext[1];
		lineCount = 1;

		positions = new PosBottomHalf[100];

		virtualLineCounts = new int[8];
		for(int i = 0; i < 8; i++)
			virtualLineCounts[i] = 1;
	} 

	
	public final int getLineCount()
	{
		return lineCount;
	} 

	
	public final int getVirtualLineCount(int index)
	{
		return virtualLineCounts[index];
	} 

	
	public final void setVirtualLineCount(int index, int lineCount)
	{
		virtualLineCounts[index] = lineCount;
	} 

	
	public int getLineOfOffset(int offset)
	{
		int start = 0;
		int end = lineCount - 1;

		for(;;)
		{
			switch(end - start)
			{
			case 0:
				if(getLineEndOffset(start) <= offset)
					return start + 1;
				else
					return start;
			case 1:
				if(getLineEndOffset(start) <= offset)
				{
					if(getLineEndOffset(end) <= offset)
						return end + 1;
					else
						return end;
				}
				else
					return start;
			default:
				int pivot = (end + start) / 2;
				int value = getLineEndOffset(pivot);
				if(value == offset)
					return pivot + 1;
				else if(value < offset)
					start = pivot + 1;
				else
					end = pivot - 1;
				break;
			}
		}
	} 

	
	public final int getLineEndOffset(int line)
	{
		return (int)(lineInfo[line] & END_MASK);
	} 

	
	public final boolean isFoldLevelValid(int line)
	{
		return (lineInfo[line] & FOLD_LEVEL_VALID_MASK) != 0;
	} 

	
	public final int getFoldLevel(int line)
	{
		return (int)((lineInfo[line] & FOLD_LEVEL_MASK)
			>> FOLD_LEVEL_SHIFT);
	} 

	
	
	public final void setFoldLevel(int line, int level)
	{
		lineInfo[line] = ((lineInfo[line] & ~FOLD_LEVEL_MASK)
			| ((long)level << FOLD_LEVEL_SHIFT)
			| FOLD_LEVEL_VALID_MASK);
	} 

	
	public final boolean isLineVisible(int line, int index)
	{
		long mask = 1L << (index + VISIBLE_SHIFT);
		return (lineInfo[line] & mask) != 0;
	} 

	
	public final void setLineVisible(int line, int index, boolean visible)
	{
		long mask = 1L << (index + VISIBLE_SHIFT);
		if(visible)
			lineInfo[line] = (lineInfo[line] | mask);
		else
			lineInfo[line] = (lineInfo[line] & ~mask);
	} 

	
	public final int getScreenLineCount(int line)
	{
		return (int)((lineInfo[line] & SCREEN_LINES_MASK)
			>> SCREEN_LINES_SHIFT);
	} 

	
	public final void setScreenLineCount(int line, int count)
	{
		lineInfo[line] = ((lineInfo[line] & ~SCREEN_LINES_MASK)
			| ((long)count << SCREEN_LINES_SHIFT));
	} 

	
	public final boolean isLineContextValid(int line)
	{
		return (lineInfo[line] & CONTEXT_VALID_MASK) != 0;
	} 

	
	public final TokenMarker.LineContext getLineContext(int line)
	{
		return lineContext[line];
	} 

	
	
	public final void setLineContext(int line, TokenMarker.LineContext context)
	{
		lineContext[line] = context;
		lineInfo[line] |= CONTEXT_VALID_MASK;
	} 

	

	
	
	
	

	
	
	
	
	public synchronized Position createPosition(int offset)
	{
		PosBottomHalf bh = null;

		for(int i = 0; i < positionCount; i++)
		{
			PosBottomHalf _bh = positions[i];
			if(_bh.offset == offset)
			{
				bh = _bh;
				break;
			}
			else if(_bh.offset > offset)
			{
				bh = new PosBottomHalf(offset);
				growPositionArray();
				System.arraycopy(positions,i,positions,i+1,
					positionCount - i);
				positionCount++;
				positions[i] = bh;
				break;
			}
		}

		if(bh == null)
		{
			bh = new PosBottomHalf(offset);
			growPositionArray();
			positions[positionCount++] = bh;
		}

		return new PosTopHalf(bh);
	} 

	
	
	public void expandFolds(int foldLevel)
	{
		int newVirtualLineCount = 0;

		if(foldLevel == 0)
		{
			newVirtualLineCount = lineCount;
		}
		else
		{
			foldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;

			
			boolean seenVisibleLine = false;

			for(int i = 0; i < lineCount; i++)
			{
				if(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)
				{
					seenVisibleLine = true;
					lineInfo[i] |= VISIBLE_MASK;
					newVirtualLineCount++;
				}
				else
					lineInfo[i] &= ~VISIBLE_MASK;
			}
		}

		for(int i = 0; i < virtualLineCounts.length; i++)
		{
			virtualLineCounts[i] = newVirtualLineCount;
		}
	} 

	
	public void contentInserted(int startLine, int offset,
		int numLines, int length, IntegerArray endOffsets)
	{
		int endLine = startLine + numLines;

		
		if(numLines > 0)
		{
			lineCount += numLines;

			if(lineInfo.length <= lineCount)
			{
				long[] lineInfoN = new long[(lineCount + 1) * 2];
				System.arraycopy(lineInfo,0,lineInfoN,0,
						 lineInfo.length);
				lineInfo = lineInfoN;

				TokenMarker.LineContext[] lineContextN
					= new TokenMarker.LineContext[(lineCount + 1) * 2];
				System.arraycopy(lineContext,0,lineContextN,0,
						 lineContext.length);
				lineContext = lineContextN;
			}

			System.arraycopy(lineInfo,startLine,lineInfo,
				endLine,lineCount - endLine);
			System.arraycopy(lineContext,startLine,lineContext,
				endLine,lineCount - endLine);

			
			int foldLevel = buffer.getFoldLevel(startLine);
			long visible = (0xffL << VISIBLE_SHIFT);
			if(startLine != 0)
			{
				for(int i = startLine; i > 0; i--)
				{
					if( buffer.getFoldLevel(i) <= foldLevel)
					{
						visible = (lineInfo[i] & VISIBLE_MASK);
						break;
					}
				}
			} 

			for(int i = 0; i < numLines; i++)
			{
				
				
				lineInfo[startLine + i] = (((offset + endOffsets.get(i) + 1)
					& ~(FOLD_LEVEL_VALID_MASK | CONTEXT_VALID_MASK))
					| visible);
			}

			
			if((visible & (1L << (VISIBLE_SHIFT + 0))) != 0)
				virtualLineCounts[0] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 1))) != 0)
				virtualLineCounts[1] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 2))) != 0)
				virtualLineCounts[2] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 3))) != 0)
				virtualLineCounts[3] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 4))) != 0)
				virtualLineCounts[4] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 5))) != 0)
				virtualLineCounts[5] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 6))) != 0)
				virtualLineCounts[6] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 7))) != 0)
				virtualLineCounts[7] += numLines;
			
		} 
		
		for(int i = endLine; i < lineCount; i++)
		{
			setLineEndOffset(i,getLineEndOffset(i) + length);
		} 

		updatePositionsForInsert(offset,length);
	} 

	
	public void contentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		
		for(int i = 0; i < numLines; i++)
		{
			long info = lineInfo[startLine + i];

			
			if((info & (1L << (VISIBLE_SHIFT + 0))) != 0)
				virtualLineCounts[0]--;
			if((info & (1L << (VISIBLE_SHIFT + 1))) != 0)
				virtualLineCounts[1]--;
			if((info & (1L << (VISIBLE_SHIFT + 2))) != 0)
				virtualLineCounts[2]--;
			if((info & (1L << (VISIBLE_SHIFT + 3))) != 0)
				virtualLineCounts[3]--;
			if((info & (1L << (VISIBLE_SHIFT + 4))) != 0)
				virtualLineCounts[4]--;
			if((info & (1L << (VISIBLE_SHIFT + 5))) != 0)
				virtualLineCounts[5]--;
			if((info & (1L << (VISIBLE_SHIFT + 6))) != 0)
				virtualLineCounts[6]--;
			if((info & (1L << (VISIBLE_SHIFT + 7))) != 0)
				virtualLineCounts[7]--;
		} 

		
		if(numLines > 0)
		{
			lineCount -= numLines;
			System.arraycopy(lineInfo,startLine + numLines,lineInfo,
				startLine,lineCount - startLine);
			System.arraycopy(lineContext,startLine + numLines,lineContext,
				startLine,lineCount - startLine);
		} 

		
		for(int i = startLine; i < lineCount; i++)
		{
			setLineEndOffset(i,getLineEndOffset(i) - length);
		} 

		updatePositionsForRemove(offset,length);
	} 

	
	public void lineInfoChangedFrom(int startLine)
	{
		for(int i = startLine; i < lineCount; i++)
		{
			lineInfo[i] &= ~(FOLD_LEVEL_VALID_MASK
				| CONTEXT_VALID_MASK);
			lineContext[i] = null;
		}
	} 

	

	
	private static final long END_MASK = 0x00000000ffffffffL;
	private static final long FOLD_LEVEL_MASK = 0x0000ffff00000000L;
	private static final int FOLD_LEVEL_SHIFT = 32;
	private static final long VISIBLE_MASK = 0x00ff000000000000L;
	private static final int VISIBLE_SHIFT = 48;
	private static final long FOLD_LEVEL_VALID_MASK = (1L<<56);
	private static final long CONTEXT_VALID_MASK = (1L<<57);
	private static final long SCREEN_LINES_MASK = 0x7c00000000000000L;
	private static final long SCREEN_LINES_SHIFT = 58;

	
	private Buffer buffer;
	private long[] lineInfo;
	private TokenMarker.LineContext[] lineContext;

	private int lineCount;

	private PosBottomHalf[] positions;
	private int positionCount;

	private int[] virtualLineCounts;
	

	
	private final void setLineEndOffset(int line, int end)
	{
		lineInfo[line] = ((lineInfo[line] & ~(END_MASK
			| FOLD_LEVEL_VALID_MASK | CONTEXT_VALID_MASK)) | end);
	} 

	
	private void growPositionArray()
	{
		if(positions.length < positionCount + 1)
		{
			PosBottomHalf[] newPositions = new PosBottomHalf[
				(positionCount + 1) * 2];
			System.arraycopy(positions,0,newPositions,0,positionCount);
			positions = newPositions;
		}
	} 

	
	private synchronized void removePosition(PosBottomHalf bh)
	{
		int index = -1;

		for(int i = 0; i < positionCount; i++)
		{
			if(positions[i] == bh)
			{
				index = i;
				break;
			}
		}

		System.arraycopy(positions,index + 1,positions,index,
			positionCount - index - 1);
		positions[--positionCount] = null;
	} 

	
	private void updatePositionsForInsert(int offset, int length)
	{
		if(positionCount == 0)
			return;

		int start = getPositionAtOffset(offset);

		for(int i = start; i < positionCount; i++)
		{
			PosBottomHalf bh = positions[i];
			if(bh.offset < offset)
				Log.log(Log.ERROR,this,""Screwed up: "" + bh.offset);
			else
				bh.offset += length;
		}
	} 

	
	private void updatePositionsForRemove(int offset, int length)
	{
		if(positionCount == 0)
			return;

		int start = getPositionAtOffset(offset);

		for(int i = start; i < positionCount; i++)
		{
			PosBottomHalf bh = positions[i];
			if(bh.offset < offset)
				Log.log(Log.ERROR,this,""Screwed up: "" + bh.offset);
			else if(bh.offset < offset + length)
				bh.offset = offset;
			else
				bh.offset -= length;
		}
	} 

	
	private int getPositionAtOffset(int offset)
	{
		int start = 0;
		int end = positionCount - 1;

		PosBottomHalf bh;

loop:		for(;;)
		{
			switch(end - start)
			{
			case 0:
				bh = positions[start];
				if(bh.offset < offset)
					start++;
				break loop;
			case 1:
				bh = positions[end];
				if(bh.offset < offset)
				{
					start = end + 1;
				}
				else
				{
					bh = positions[start];
					if(bh.offset < offset)
					{
						start++;
					}
				}
				break loop;
			default:
				int pivot = (start + end) / 2;
				bh = positions[pivot];
				if(bh.offset > offset)
					end = pivot - 1;
				else
					start = pivot + 1;
				break;
			}
		}

		return start;
	} 

	

	

	
	static class PosTopHalf implements Position
	{
		PosBottomHalf bh;

		
		PosTopHalf(PosBottomHalf bh)
		{
			this.bh = bh;
			bh.ref();
		} 

		
		public int getOffset()
		{
			return bh.offset;
		} 

		
		public void finalize()
		{
			bh.unref();
		} 
	} 

	
	class PosBottomHalf
	{
		int offset;
		int ref;

		
		PosBottomHalf(int offset)
		{
			this.offset = offset;
		} 

		
		void ref()
		{
			ref++;
		} 

		
		void unref()
		{
			if(--ref == 0)
				removePosition(this);
		} 
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.options.FirewallOptionPane,9,6,0,4,27,10,2,3,3,0.75,181,1.0,0,0.988059701,0.5,2,4,18.44444444,1,0.8889,0,"

package org.gjt.sp.jedit.options;

 
import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import org.gjt.sp.jedit.*;


public class FirewallOptionPane extends AbstractOptionPane {

	
	public FirewallOptionPane()
	{
		super(""firewall"");
	} 

	
	public void _init()
	{
		
		addComponent(cEnabled = new JCheckBox(jEdit.getProperty(
			""options.firewall.enabled"")));
		
		addComponent(jEdit.getProperty(""options.firewall.host""), 
			tHost = new JTextField(jEdit.getProperty(""firewall.host""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.port""), 
			tPort = new JTextField(jEdit.getProperty(""firewall.port""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.user""),
			tUser = new JTextField(jEdit.getProperty(""firewall.user""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.password""),
			tPass = new JPasswordField(jEdit.getProperty(""firewall.password""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.nonProxy""),
			tNonProxy = new JTextField(jEdit.getProperty(""firewall.nonProxyHosts""), 15));

		boolean enabled = jEdit.getBooleanProperty(""firewall.enabled"");
		cEnabled.setSelected(enabled);
		tHost.setEnabled(enabled);
		tPort.setEnabled(enabled);
		tUser.setEnabled(enabled);
		tPass.setEnabled(enabled);
		tNonProxy.setEnabled(enabled);

		cEnabled.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent e) {
				boolean enbld = cEnabled.isSelected();
				cEnabled.setSelected(enbld);
				tHost.setEnabled(enbld);
				tPort.setEnabled(enbld);
				tUser.setEnabled(enbld);
				tPass.setEnabled(enbld);
				tNonProxy.setEnabled(enbld);
			}
		});
	} 

	
	public void _save() {
		jEdit.setBooleanProperty(""firewall.enabled"", cEnabled.isSelected());
		jEdit.setProperty(""firewall.host"", tHost.getText());			
		jEdit.setProperty(""firewall.port"", tPort.getText());
		jEdit.setProperty(""firewall.user"", tUser.getText());
		jEdit.setProperty(""firewall.password"", new String(tPass.getPassword()));
		jEdit.setProperty(""firewall.nonProxyHosts"", tNonProxy.getText());
	} 

	
	private JCheckBox cEnabled;
	private JTextField tHost;
	private JTextField tPort;
	private JTextField tUser;
	private JPasswordField tPass;
	private JTextField tNonProxy;
	
}
"
jEdit,4,org.gjt.sp.jedit.View,57,6,0,132,209,1298,118,37,42,0.948891626,1532,0.482758621,9,0.920114123,0.083102493,1,1,25.36842105,19,2.5439,14,"

package org.gjt.sp.jedit;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.search.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class View extends JFrame implements EBComponent
{
	

	

	
	
	public static final int TOP_GROUP = 0;

	
	public static final int BOTTOM_GROUP = 1;
	public static final int DEFAULT_GROUP = TOP_GROUP;
	

	

	
	
	public static final int TOP_LAYER = Integer.MAX_VALUE;

	
	public static final int DEFAULT_LAYER = 0;

	
	public static final int BOTTOM_LAYER = Integer.MIN_VALUE;

	
	
	public static final int ABOVE_SYSTEM_BAR_LAYER = 150;

	
	public static final int SYSTEM_BAR_LAYER = 100;

	
	public static final int SEARCH_BAR_LAYER = 75;

	
	public static final int BELOW_SEARCH_BAR_LAYER = 50;

	
	
	public static final int ABOVE_STATUS_BAR_LAYER = -50;

	
	public static final int STATUS_BAR_LAYER = -100;

	
	public static final int BELOW_STATUS_BAR_LAYER = -150;
	

	

	
	
	public DockableWindowManager getDockableWindowManager()
	{
		return dockableWindowManager;
	} 

	
	
	public JToolBar getToolBar()
	{
		return toolBar;
	} 

	
	
	public void addToolBar(Component toolBar)
	{
		addToolBar(DEFAULT_GROUP, DEFAULT_LAYER, toolBar);
	} 

	
	
	public void addToolBar(int group, Component toolBar)
	{
		addToolBar(group, DEFAULT_LAYER, toolBar);
	} 

	
	
	public void addToolBar(int group, int layer, Component toolBar)
	{
		toolBarManager.addToolBar(group, layer, toolBar);
		getRootPane().revalidate();
	} 

	
	
	public void removeToolBar(Component toolBar)
	{
		toolBarManager.removeToolBar(toolBar);
		getRootPane().revalidate();
	} 

	
	
	public synchronized void showWaitCursor()
	{
		if(waitCount++ == 0)
		{
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
			setCursor(cursor);
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane editPane = editPanes[i];
				editPane.getTextArea().getPainter()
					.setCursor(cursor);
			}
		}
	} 

	
	
	public synchronized void hideWaitCursor()
	{
		if(waitCount > 0)
			waitCount--;

		if(waitCount == 0)
		{
			
			
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
			setCursor(cursor);
			cursor = Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR);
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane editPane = editPanes[i];
				editPane.getTextArea().getPainter()
					.setCursor(cursor);
			}
		}
	} 

	
	
	public final SearchBar getSearchBar()
	{
		return searchBar;
	} 

	
	
	public StatusBar getStatus()
	{
		return status;
	} 

	

	

	
	
	public KeyListener getKeyEventInterceptor()
	{
		return keyEventInterceptor;
	} 

	
	
	public void setKeyEventInterceptor(KeyListener listener)
	{
		this.keyEventInterceptor = listener;
	} 

	
	
	public InputHandler getInputHandler()
	{
		return inputHandler;
	} 

	
	
	public void setInputHandler(InputHandler inputHandler)
	{
		this.inputHandler = inputHandler;
	} 

	
	
	public Macros.Recorder getMacroRecorder()
	{
		return recorder;
	} 

	
	
	public void setMacroRecorder(Macros.Recorder recorder)
	{
		this.recorder = recorder;
	} 

	
	
	public void processKeyEvent(KeyEvent evt)
	{
		if(isClosed())
			return;

		if(getFocusOwner() instanceof JComponent)
		{
			JComponent comp = (JComponent)getFocusOwner();
			InputMap map = comp.getInputMap();
			ActionMap am = comp.getActionMap();

			if(map != null && am != null && comp.isEnabled())
			{
				Object binding = map.get(KeyStroke.getKeyStrokeForEvent(evt));
				if(binding != null && am.get(binding) != null)
				{
					return;
				}
			}
		}

		if(getFocusOwner() instanceof JTextComponent)
		{
			
			
			if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				switch(evt.getKeyCode())
				{
				case KeyEvent.VK_BACK_SPACE:
				case KeyEvent.VK_TAB:
				case KeyEvent.VK_ENTER:
					return;
				}
			}

			Keymap keymap = ((JTextComponent)getFocusOwner())
				.getKeymap();
			if(keymap.getAction(KeyStroke.getKeyStrokeForEvent(evt)) != null)
				return;
		}

		if(evt.isConsumed())
			return;

		evt = KeyEventWorkaround.processKeyEvent(evt);
		if(evt == null)
			return;

		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			
			if(keyEventInterceptor != null)
				;
			else if(inputHandler.isPrefixActive()
				&& !getTextArea().hasFocus())
				inputHandler.keyTyped(evt);
			break;
		case KeyEvent.KEY_PRESSED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyPressed(evt);
			else
				inputHandler.keyPressed(evt);
			break;
		case KeyEvent.KEY_RELEASED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyReleased(evt);
			else
				inputHandler.keyReleased(evt);
			break;
		}

		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	

	

	
	
	public void splitHorizontally()
	{
		split(JSplitPane.VERTICAL_SPLIT);
	} 

	
	
	public void splitVertically()
	{
		split(JSplitPane.HORIZONTAL_SPLIT);
	} 

	
	
	public void split(int orientation)
	{
		editPane.saveCaretInfo();
		EditPane oldEditPane = editPane;
		setEditPane(createEditPane(oldEditPane.getBuffer()));
		editPane.loadCaretInfo();

		JComponent oldParent = (JComponent)oldEditPane.getParent();

		if(oldParent instanceof JSplitPane)
		{
			JSplitPane oldSplitPane = (JSplitPane)oldParent;
			int dividerPos = oldSplitPane.getDividerLocation();

			Component left = oldSplitPane.getLeftComponent();
			final JSplitPane newSplitPane = new JSplitPane(orientation,
				oldEditPane,editPane);

			if(left == oldEditPane)
				oldSplitPane.setLeftComponent(newSplitPane);
			else
				oldSplitPane.setRightComponent(newSplitPane);

			oldSplitPane.setDividerLocation(dividerPos);

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					newSplitPane.setDividerLocation(0.5);
					editPane.focusOnTextArea();
				}
			});
		}
		else
		{
			JSplitPane newSplitPane = splitPane = new JSplitPane(orientation,
				oldEditPane,editPane);
			newSplitPane.setBorder(null);
			oldParent.add(splitPane);
			oldParent.revalidate();

			Dimension size;
			if(oldParent instanceof JSplitPane)
				size = oldParent.getSize();
			else
				size = oldEditPane.getSize();
			newSplitPane.setDividerLocation(((orientation
				== JSplitPane.VERTICAL_SPLIT) ? size.height
				: size.width) / 2);
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					editPane.focusOnTextArea();
				}
			});
		}
	} 

	
	
	public void unsplit()
	{
		if(splitPane != null)
		{
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane _editPane = editPanes[i];
				if(editPane != _editPane)
					_editPane.close();
			}

			JComponent parent = (JComponent)splitPane.getParent();

			parent.remove(splitPane);
			parent.add(editPane);
			parent.revalidate();

			splitPane = null;
			updateTitle();
		}

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				editPane.focusOnTextArea();
			}
		});
	} 

	
	
	public void nextTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == editPanes.length - 1)
					editPanes[0].focusOnTextArea();
				else
					editPanes[i+1].focusOnTextArea();
				break;
			}
		}
	} 

	
	
	public void prevTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == 0)
					editPanes[editPanes.length - 1].focusOnTextArea();
				else
					editPanes[i-1].focusOnTextArea();
				break;
			}
		}
	} 

	
	
	public JSplitPane getSplitPane()
	{
		return splitPane;
	} 

	
	
	public Buffer getBuffer()
	{
		return editPane.getBuffer();
	} 

	
	
	public void setBuffer(Buffer buffer)
	{
		editPane.setBuffer(buffer);
	} 

	
	
	public JEditTextArea getTextArea()
	{
		return editPane.getTextArea();
	} 

	
	
	public EditPane getEditPane()
	{
		return editPane;
	} 

	
	
	public EditPane[] getEditPanes()
	{
		if(splitPane == null)
		{
			EditPane[] ep = { editPane };
			return ep;
		}
		else
		{
			Vector vec = new Vector();
			getEditPanes(vec,splitPane);
			EditPane[] ep = new EditPane[vec.size()];
			vec.copyInto(ep);
			return ep;
		}
	} 

	
	
	public String getSplitConfig()
	{
		

		StringBuffer splitConfig = new StringBuffer();
		
		
		
			splitConfig.append(getBuffer().getPath());
		return splitConfig.toString();
	} 

	
	
	public void updateGutterBorders()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].getTextArea().getGutter().updateBorder();
	} 

	

	

	
	
	public boolean isSynchroScrollEnabled()
	{
		return synchroScroll;
	} 

	
	
	public void toggleSynchroScrollEnabled()
	{
		setSynchroScrollEnabled(!synchroScroll);
	} 

	
	
	public void setSynchroScrollEnabled(boolean synchroScroll)
	{
		this.synchroScroll = synchroScroll;
		JEditTextArea textArea = getTextArea();
		int firstLine = textArea.getFirstLine();
		int horizontalOffset = textArea.getHorizontalOffset();
		synchroScrollVertical(textArea,firstLine);
		synchroScrollHorizontal(textArea,horizontalOffset);
	} 

	
	
	public void synchroScrollVertical(JEditTextArea textArea, int firstLine)
	{
		if(!synchroScroll)
			return;

		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPanes[i].getTextArea() != textArea)
				editPanes[i].getTextArea()._setFirstLine(firstLine);
		}
	} 

	
	
	public void synchroScrollHorizontal(JEditTextArea textArea, int horizontalOffset)
	{
		if(!synchroScroll)
			return;

		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPanes[i].getTextArea() != textArea)
				editPanes[i].getTextArea()._setHorizontalOffset(horizontalOffset);
		}
	} 

	

	
	
	public void quickIncrementalSearch(boolean word)
	{
		if(searchBar == null)
		{
			getToolkit().beep();
			return;
		}

		JEditTextArea textArea = getTextArea();

		String text = textArea.getSelectedText();
		if(text == null && word)
		{
			textArea.selectWord();
			text = textArea.getSelectedText();
		}
		else if(text != null && text.indexOf('\n') != -1)
			text = null;

		searchBar.setHyperSearch(false);
		searchBar.getField().setText(text);
		searchBar.getField().requestFocus();
		searchBar.getField().selectAll();
	} 

	
	
	public void quickHyperSearch(boolean word)
	{
		JEditTextArea textArea = getTextArea();

		String text = textArea.getSelectedText();
		if(text == null && word)
		{
			textArea.selectWord();
			text = textArea.getSelectedText();
		}

		if(text != null && text.indexOf('\n') == -1)
		{
			HistoryModel.getModel(""find"").addItem(text);
			SearchAndReplace.setSearchString(text);
			SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
			SearchAndReplace.hyperSearch(this);
		}
		else
		{
			if(searchBar == null)
			{
				getToolkit().beep();
				return;
			}

			searchBar.setHyperSearch(true);
			searchBar.getField().setText(null);
			searchBar.getField().requestFocus();
			searchBar.getField().selectAll();
		}
	} 

	
	
	public boolean isClosed()
	{
		return closed;
	} 

	
	
	public View getNext()
	{
		return next;
	} 

	
	
	public View getPrev()
	{
		return prev;
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof SearchSettingsChanged)
		{
			if(searchBar != null)
				searchBar.update();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
		else if(msg instanceof EditPaneUpdate)
			handleEditPaneUpdate((EditPaneUpdate)msg);
		else if(msg instanceof MultiSelectStatusChanged)
			status.updateMiscStatus();
	} 

	
	View prev;
	View next;

	
	View(Buffer buffer, String splitConfig)
	{
		enableEvents(AWTEvent.KEY_EVENT_MASK);

		setIconImage(GUIUtilities.getEditorIcon());

		dockableWindowManager = new DockableWindowManager(this);

		JPanel topToolBars = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,
			1));
		JPanel bottomToolBars = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,
			1));

		toolBarManager = new ToolBarManager(topToolBars, bottomToolBars);

		getContentPane().add(BorderLayout.NORTH,topToolBars);
		getContentPane().add(BorderLayout.CENTER,dockableWindowManager);
		getContentPane().add(BorderLayout.SOUTH,bottomToolBars);

		status = new StatusBar(this);
		addToolBar(BOTTOM_GROUP, STATUS_BAR_LAYER, status);

		setJMenuBar(GUIUtilities.loadMenuBar(""view.mbar""));

		inputHandler = new DefaultInputHandler(this,(DefaultInputHandler)
			jEdit.getInputHandler());

		Component comp = restoreSplitConfig(buffer,splitConfig);
		dockableWindowManager.add(comp);

		status.updateBufferStatus();
		status.updateMiscStatus();

		EditBus.addToBus(this);

		propertiesChanged();

		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowHandler());

		dockableWindowManager.init();
	} 

	
	void close()
	{
		closed = true;

		
		dockableWindowManager.close();

		GUIUtilities.saveGeometry(this,""view"");
		EditBus.removeFromBus(this);
		dispose();

		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].close();

		
		
		toolBarManager = null;
		toolBar = null;
		searchBar = null;
		splitPane = null;
		inputHandler = null;
		recorder = null;

		setContentPane(new JPanel());
	} 

	
	
	void updateTitle()
	{
		Vector buffers = new Vector();
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			Buffer buffer = editPanes[i].getBuffer();
			if(buffers.indexOf(buffer) == -1)
				buffers.addElement(buffer);
		}

		StringBuffer title = new StringBuffer(jEdit.getProperty(""view.title""));
		for(int i = 0; i < buffers.size(); i++)
		{
			if(i != 0)
				title.append("", "");

			Buffer buffer = (Buffer)buffers.elementAt(i);
			title.append((showFullPath && !buffer.isNewFile())
				? buffer.getPath() : buffer.getName());
		}
		setTitle(title.toString());
	} 

	

	

	
	private boolean closed;

	private DockableWindowManager dockableWindowManager;

	private ToolBarManager toolBarManager;

	private JToolBar toolBar;
	private SearchBar searchBar;

	private boolean synchroScroll;

	private EditPane editPane;
	private JSplitPane splitPane;

	private StatusBar status;

	private KeyListener keyEventInterceptor;
	private InputHandler inputHandler;
	private Macros.Recorder recorder;

	private int waitCount;

	private boolean showFullPath;
	

	
	private void getEditPanes(Vector vec, Component comp)
	{
		if(comp instanceof EditPane)
			vec.addElement(comp);
		else if(comp instanceof JSplitPane)
		{
			JSplitPane split = (JSplitPane)comp;
			getEditPanes(vec,split.getLeftComponent());
			getEditPanes(vec,split.getRightComponent());
		}
	} 

	
	
	private void getSplitConfig(JSplitPane splitPane,
		StringBuffer splitConfig)
	{
		Component left = splitPane.getLeftComponent();
		if(left instanceof JSplitPane)
			getSplitConfig((JSplitPane)left,splitConfig);
		else
		{
			splitConfig.append('\t');
			splitConfig.append(((EditPane)left).getBuffer().getPath());
		}

		Component right = splitPane.getRightComponent();
		if(right instanceof JSplitPane)
			getSplitConfig((JSplitPane)right,splitConfig);
		else
		{
			splitConfig.append('\t');
			splitConfig.append(((EditPane)right).getBuffer().getPath());
		}

		splitConfig.append(splitPane.getOrientation()
			== JSplitPane.VERTICAL_SPLIT ? ""\tvertical"" : ""\thorizontal"");
	} 

	
	private Component restoreSplitConfig(Buffer buffer, String splitConfig)
	{
		if(buffer != null)
			return (editPane = createEditPane(buffer));
		else if(splitConfig == null)
			return (editPane = createEditPane(jEdit.getFirstBuffer()));

		Stack stack = new Stack();

		StringTokenizer st = new StringTokenizer(splitConfig,""\t"");

		while(st.hasMoreTokens())
		{
			String token = st.nextToken();
			if(token.equals(""vertical""))
			{
				stack.push(splitPane = new JSplitPane(
					JSplitPane.VERTICAL_SPLIT,
					(Component)stack.pop(),
					(Component)stack.pop()));
				splitPane.setBorder(null);
				splitPane.setDividerLocation(0.5);
			}
			else if(token.equals(""horizontal""))
			{
				stack.push(splitPane = new JSplitPane(
					JSplitPane.HORIZONTAL_SPLIT,
					(Component)stack.pop(),
					(Component)stack.pop()));
				splitPane.setBorder(null);
				splitPane.setDividerLocation(0.5);
			}
			else
			{
				buffer = jEdit.getBuffer(token);
				if(buffer == null)
					buffer = jEdit.getFirstBuffer();

				stack.push(editPane = createEditPane(buffer));
			}
		}

		return (Component)stack.peek();
	} 

	
	
	private void propertiesChanged()
	{
		loadToolBars();

		showFullPath = jEdit.getBooleanProperty(""view.showFullPath"");
		updateTitle();

		dockableWindowManager.propertiesChanged();

		SwingUtilities.updateComponentTreeUI(getRootPane());
	} 

	
	private void loadToolBars()
	{
		if(jEdit.getBooleanProperty(""view.showToolbar""))
		{
			if(toolBar != null)
				toolBarManager.removeToolBar(toolBar);

			toolBar = GUIUtilities.loadToolBar(""view.toolbar"");

			addToolBar(TOP_GROUP, SYSTEM_BAR_LAYER, toolBar);
		}
		else if(toolBar != null)
		{
			removeToolBar(toolBar);
			toolBar = null;
		}

		if(jEdit.getBooleanProperty(""view.showSearchbar""))
		{
			if(searchBar == null)
			{
				searchBar = new SearchBar(this);
				addToolBar(TOP_GROUP, SEARCH_BAR_LAYER, searchBar);
			}
		}
		else if(searchBar != null)
		{
			removeToolBar(searchBar);
			searchBar = null;
		}
	} 

	
	private EditPane createEditPane(Buffer buffer)
	{
		EditPane editPane = new EditPane(this,buffer);
		JEditTextArea textArea = editPane.getTextArea();
		textArea.addFocusListener(new FocusHandler());
		textArea.addCaretListener(new CaretHandler());
		textArea.addScrollListener(new ScrollHandler());
		EditBus.send(new EditPaneUpdate(editPane,EditPaneUpdate.CREATED));
		return editPane;
	} 

	
	private void setEditPane(EditPane editPane)
	{
		this.editPane = editPane;
		status.repaintCaretStatus();
		status.updateBufferStatus();
		status.updateMiscStatus();
	} 

	
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			if(!buffer.isDirty())
			{
				
				
				EditPane[] editPanes = getEditPanes();
				for(int i = 0; i < editPanes.length; i++)
				{
					if(editPanes[i].getBuffer() == buffer)
					{
						updateTitle();
						break;
					}
				}
			}
		}
	} 

	
	private void handleEditPaneUpdate(EditPaneUpdate msg)
	{
		if(msg.getEditPane().getView() == this
			&& msg.getWhat() == EditPaneUpdate.BUFFER_CHANGED)
		{
			status.repaintCaretStatus();
			status.updateBufferStatus();
			status.updateMiscStatus();
		}
	} 

	

	

	
	class CaretHandler implements CaretListener
	{
		public void caretUpdate(CaretEvent evt)
		{
			status.repaintCaretStatus();
			status.updateMiscStatus();
		}
	} 

	
	class FocusHandler extends FocusAdapter
	{
		public void focusGained(FocusEvent evt)
		{
			
			Component comp = (Component)evt.getSource();
			while(!(comp instanceof EditPane))
			{
				if(comp == null)
					return;

				comp = comp.getParent();
			}

			setEditPane((EditPane)comp);
		}
	} 

	
	class ScrollHandler implements ScrollListener
	{
		public void scrolledVertically(JEditTextArea textArea)
		{
			if(getTextArea() == textArea)
				status.repaintCaretStatus();
		}

		public void scrolledHorizontally(JEditTextArea textArea) {}
	} 

	
	class WindowHandler extends WindowAdapter
	{
		public void windowActivated(WindowEvent evt)
		{
			final Vector buffers = new Vector();
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				Buffer buffer = ((EditPane)editPanes[i])
					.getBuffer();
				if(buffers.contains(buffer))
					continue;
				else
					buffers.addElement(buffer);
			}

			
			
			
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					for(int i = 0; i < buffers.size(); i++)
					{
						((Buffer)buffers.elementAt(i))
							.checkModTime(View.this);
					}
				}
			});
		}

		public void windowClosing(WindowEvent evt)
		{
			jEdit.closeView(View.this);
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.io.VFS,32,1,4,31,70,400,24,14,26,0.961876833,504,0.454545455,0,0.0,0.261290323,0,0,14.40625,5,1.5938,0,"

package org.gjt.sp.jedit.io;


import gnu.regexp.*;
import java.awt.Color;
import java.awt.Component;
import java.io.*;
import java.util.Vector;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public abstract class VFS
{
	

	
	public static final int READ_CAP = 1 << 0;

	
	public static final int WRITE_CAP = 1 << 1;

	
	public static final int BROWSE_CAP = 1 << 2;

	
	public static final int DELETE_CAP = 1 << 3;

	
	public static final int RENAME_CAP = 1 << 4;

	
	public static final int MKDIR_CAP = 1 << 5;

	

	
	
	public VFS(String name)
	{
		this.name = name;
	} 

	
	
	public VFS(String name, int caps)
	{
		this.name = name;
		this.caps = caps;
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public int getCapabilities()
	{
		return caps;
	} 

	
	
	public String showBrowseDialog(Object[] session, Component comp)
	{
		return null;
	} 

	
	
	public String getFileName(String path)
	{
		if(path.equals(""/""))
			return path;

		int count = Math.max(0,path.length() - 2);
		int index = Math.max(path.lastIndexOf('/',count),
			path.lastIndexOf(File.separatorChar,count));
		if(index == -1)
			index = path.indexOf(':');

		
		if(index == -1 || index == path.length() - 1)
			return path;

		return path.substring(index + 1);
	} 

	
	
	public String getParentOfPath(String path)
	{
		
		
		int count = Math.max(0,path.length() - 2);
		int index = path.lastIndexOf(File.separatorChar,count);
		if(index == -1)
			index = path.lastIndexOf('/',count);
		if(index == -1)
		{
			
			
			index = path.lastIndexOf(':');
		}

		return path.substring(0,index + 1);
	} 

	
	
	public String constructPath(String parent, String path)
	{
		return parent + path;
	} 

	
	
	public char getFileSeparator()
	{
		return '/';
	} 

	
	
	public void reloadDirectory(String path) {} 

	
	
	public Object createVFSSession(String path, Component comp)
	{
		return new Object();
	} 

	
	
	public boolean load(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.load"",new String[] { name });
			return false;
		}

		Object session = createVFSSession(path,view);
		if(session == null)
			return false;

		if((getCapabilities() & WRITE_CAP) == 0)
			buffer.setReadOnly(true);

		BufferIORequest request = new BufferIORequest(
			BufferIORequest.LOAD,view,buffer,session,this,path);
		if(buffer.isTemporary())
			
			request.run();
		else
			VFSManager.runInWorkThread(request);

		return true;
	} 

	
	
	public boolean save(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & WRITE_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.save"",new String[] { name });
			return false;
		}

		Object session = createVFSSession(path,view);
		if(session == null)
			return false;

		
		if(!path.equals(buffer.getPath()))
			buffer.unsetProperty(Buffer.BACKED_UP);

		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.SAVE,view,buffer,session,this,path));
		return true;
	} 

	
	
	public boolean insert(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.load"",new String[] { name });
			return false;
		}

		Object session = createVFSSession(path,view);
		if(session == null)
			return false;

		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.INSERT,view,buffer,session,this,path));
		return true;
	} 

	

	
	
	public String _canonPath(Object session, String path, Component comp)
		throws IOException
	{
		return path;
	} 

	
	
	public DirectoryEntry[] _listDirectory(Object session, String directory,
		Component comp)
		throws IOException
	{
		VFSManager.error(comp,directory,""vfs.not-supported.list"",new String[] { name });
		return null;
	} 

	
	
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
		throws IOException
	{
		return null;
	} 

	
	
	public static class DirectoryEntry implements Serializable
	{
		
		public static final int FILE = 0;
		public static final int DIRECTORY = 1;
		public static final int FILESYSTEM = 2;
		

		
		public String name;
		public String path;
		public String deletePath;
		public int type;
		public long length;
		public boolean hidden;
		

		
		public DirectoryEntry(String name, String path, String deletePath,
			int type, long length, boolean hidden)
		{
			this.name = name;
			this.path = path;
			this.deletePath = deletePath;
			this.type = type;
			this.length = length;
			this.hidden = hidden;
		} 

		protected boolean colorCalculated;
		protected Color color;

		
		public Color getColor()
		{
			if(!colorCalculated)
			{
				colorCalculated = true;
				color = getDefaultColorFor(name);
			}

			return color;
		} 

		
		public String toString()
		{
			return name;
		} 
	} 

	
	
	public boolean _delete(Object session, String path, Component comp)
		throws IOException
	{
		return false;
	} 

	
	
	public boolean _rename(Object session, String from, String to,
		Component comp) throws IOException
	{
		return false;
	} 

	
	
	public boolean _mkdir(Object session, String directory, Component comp)
		throws IOException
	{
		return false;
	} 

	
	
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
	} 

	
	
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		VFSManager.error(comp,path,""vfs.not-supported.load"",new String[] { name });
		return null;
	} 

	
	
	public OutputStream _createOutputStream(Object session,
		String path, Component comp)
		throws IOException
	{
		VFSManager.error(comp,path,""vfs.not-supported.save"",new String[] { name });
		return null;
	} 

	
	
	public void _saveComplete(Object session, Buffer buffer, Component comp)
		throws IOException {} 

	
	
	public void _endVFSSession(Object session, Component comp)
		throws IOException
	{
	} 

	
	
	public static Color getDefaultColorFor(String name)
	{
		synchronized(lock)
		{
			if(colors == null)
				loadColors();

			for(int i = 0; i < colors.size(); i++)
			{
				ColorEntry entry = (ColorEntry)colors.elementAt(i);
				if(entry.re.isMatch(name))
					return entry.color;
			}

			return null;
		}
	} 

	
	private String name;
	private int caps;
	private static Vector colors;
	private static Object lock = new Object();

	
	static
	{
		EditBus.addToBus(new EBComponent()
		{
			public void handleMessage(EBMessage msg)
			{
				if(msg instanceof PropertiesChanged)
				{
					synchronized(lock)
					{
						colors = null;
					}
				}
			}
		});
	} 

	
	private static void loadColors()
	{
		synchronized(lock)
		{
			colors = new Vector();

			if(!jEdit.getBooleanProperty(""vfs.browser.colorize""))
				return;

			try
			{
				String glob;
				int i = 0;
				while((glob = jEdit.getProperty(""vfs.browser.colors."" + i + "".glob"")) != null)
				{
					colors.addElement(new ColorEntry(
						new RE(MiscUtilities.globToRE(glob)),
						jEdit.getColorProperty(
						""vfs.browser.colors."" + i + "".color"",
						Color.black)));
					i++;
				}
			}
			catch(REException e)
			{
				Log.log(Log.ERROR,VFS.class,""Error loading file list colors:"");
				Log.log(Log.ERROR,VFS.class,e);
			}
		}
	} 

	
	static class ColorEntry
	{
		RE re;
		Color color;

		ColorEntry(RE re, Color color)
		{
			this.re = re;
			this.color = color;
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.JEditMetalTheme,8,3,0,1,14,16,1,1,8,0.714285714,49,1.0,0,0.911392405,1.0,0,0,4.875,1,0.875,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.plaf.metal.*;
import javax.swing.plaf.*;
import javax.swing.*;
import org.gjt.sp.jedit.jEdit;

public class JEditMetalTheme extends DefaultMetalTheme
{
	public String getName()
	{
		return ""jEdit"";
	}

	public ColorUIResource getSystemTextColor()
	{
		return getBlack();
	}

	public FontUIResource getControlTextFont()
	{
		return primaryFont;
	}

	public FontUIResource getSystemTextFont()
	{
		return secondaryFont;
	}

	public FontUIResource getUserTextFont()
	{
		return secondaryFont;
	}

	public FontUIResource getMenuTextFont()
	{
		return primaryFont;
	}

	public void propertiesChanged()
	{
		primaryFont = new FontUIResource(
			jEdit.getFontProperty(""metal.primary.font"",
			super.getControlTextFont()));
		secondaryFont = new FontUIResource(
			jEdit.getFontProperty(""metal.secondary.font"",
			super.getSystemTextFont()));
	}

	
	private FontUIResource primaryFont;
	private FontUIResource secondaryFont;
}
"
jEdit,4,org.gjt.sp.jedit.buffer.BufferChangeAdapter,5,1,0,2,6,10,0,2,5,2.0,12,0.0,0,0.0,0.8,0,0,1.4,1,0.8,0,"

package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.Buffer;


public abstract class BufferChangeAdapter implements BufferChangeListener
{
	
	
	public void foldLevelChanged(Buffer buffer, int start, int end)
	{
	} 

	
	
	public void contentInserted(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	
	public void contentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	
	public void transactionComplete(Buffer buffer) {}
	
}
"
jEdit,4,org.gjt.sp.jedit.io.VFSManager,26,1,0,41,73,217,34,16,18,0.872727273,370,1.0,3,0.0,0.108571429,0,0,12.80769231,8,1.5,1,"

package org.gjt.sp.jedit.io;


import java.util.Enumeration;
import java.util.Hashtable;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.gui.ErrorListDialog;
import org.gjt.sp.jedit.msg.VFSUpdate;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.WorkThreadPool;



public class VFSManager
{
	
	
	public static void init()
	{
		int count = jEdit.getIntegerProperty(""ioThreadCount"",4);
		ioThreadPool = new WorkThreadPool(""jEdit I/O"",count);
		registerVFS(FavoritesVFS.PROTOCOL,new FavoritesVFS());
		if(OperatingSystem.isDOSDerived())
			registerVFS(FileRootsVFS.PROTOCOL,new FileRootsVFS());
	} 

	
	
	public static void start()
	{
		ioThreadPool.start();
	} 

	

	
	
	public static VFS getFileVFS()
	{
		return fileVFS;
	} 

	
	
	public static VFS getUrlVFS()
	{
		return urlVFS;
	} 

	
	
	public static VFS getVFSByName(String name)
	{
		return (VFS)vfsHash.get(name);
	} 

	
	
	public static VFS getVFSForProtocol(String protocol)
	{
		if(protocol.equals(""file""))
			return fileVFS;
		else
		{
			VFS vfs = (VFS)protocolHash.get(protocol);
			if(vfs != null)
				return vfs;
			else
				return urlVFS;
		}
	} 

	
	
	public static VFS getVFSForPath(String path)
	{
		if(MiscUtilities.isURL(path))
			return getVFSForProtocol(MiscUtilities.getProtocolOfURL(path));
		else
			return fileVFS;
	} 

	
	
	public static void registerVFS(String protocol, VFS vfs)
	{
		Log.log(Log.DEBUG,VFSManager.class,""Registered ""
			+ vfs.getName() + "" filesystem for ""
			+ protocol + "" protocol"");
		vfsHash.put(vfs.getName(),vfs);
		protocolHash.put(protocol,vfs);
	} 

	
	
	public static Enumeration getFilesystems()
	{
		return vfsHash.elements();
	} 

	

	

	
	
	public static WorkThreadPool getIOThreadPool()
	{
		return ioThreadPool;
	} 

	
	
	public static void waitForRequests()
	{
		ioThreadPool.waitForRequests();
	} 

	
	
	public static boolean errorOccurred()
	{
		return error;
	} 

	
	
	public static int getRequestCount()
	{
		return ioThreadPool.getRequestCount();
	} 

	
	
	public static void runInAWTThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,true);
	} 

	
	
	public static void runInWorkThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,false);
	} 

	

	
	
	public static void error(final Component comp, final String error, final Object[] args)
	{
		
		if(SwingUtilities.isEventDispatchThread())
		{
			GUIUtilities.error(comp,error,args);
			return;
		}

		
		
		
		
		
		
		VFSManager.error = true;

		runInAWTThread(new Runnable()
		{
			public void run()
			{
				VFSManager.error = false;

				if(comp == null || !comp.isShowing())
					GUIUtilities.error(null,error,args);
				else
					GUIUtilities.error(comp,error,args);
			}
		});
	} 

	
	
	public static void error(Component comp,
		final String path,
		String messageProp,
		Object[] args)
	{
		final Frame frame = JOptionPane.getFrameForComponent(comp);

		synchronized(errorLock)
		{
			error = true;

			errors.addElement(new ErrorListDialog.ErrorEntry(
				path,messageProp,args));

			if(errors.size() == 1)
			{
				final String caption = jEdit.getProperty(
					""ioerror.caption"" + (errors.size() == 1
					? ""-1"" : """"),new Integer[] {
					new Integer(errors.size()) });

				VFSManager.runInAWTThread(new Runnable()
				{
					public void run()
					{
						new ErrorListDialog(
							frame.isShowing()
							? frame
							: jEdit.getFirstView(),
							jEdit.getProperty(""ioerror.title""),
							caption,errors,false);
						errors.removeAllElements();
						error = false;
					}
				});
			}
		}
	} 

	
	
	public static void sendVFSUpdate(VFS vfs, String path, boolean parent)
	{
		if(parent)
		{
			sendVFSUpdate(vfs,vfs.getParentOfPath(path),false);
			sendVFSUpdate(vfs,path,false);
		}
		else
		{
			
			if(path.length() != 1 && (path.endsWith(""/"")
				|| path.endsWith(java.io.File.separator)))
				path = path.substring(0,path.length() - 1);

			synchronized(vfsUpdateLock)
			{
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					VFSUpdate msg = (VFSUpdate)vfsUpdates
						.elementAt(i);
					if(msg.getPath().equals(path))
					{
						
						
						return;
					}
				}

				vfsUpdates.addElement(new VFSUpdate(path));

				if(vfsUpdates.size() == 1)
				{
					
					
					
					VFSManager.runInAWTThread(new SendVFSUpdatesSafely());
				}
			}
		}
	} 

	
	static class SendVFSUpdatesSafely implements Runnable
	{
		public void run()
		{
			synchronized(vfsUpdateLock)
			{
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					EditBus.send((VFSUpdate)vfsUpdates.elementAt(i));
				}

				vfsUpdates.removeAllElements();
			}
		}
	} 

	

	
	private static WorkThreadPool ioThreadPool;
	private static VFS fileVFS;
	private static VFS urlVFS;
	private static Hashtable vfsHash;
	private static Hashtable protocolHash;
	private static boolean error;
	private static Object errorLock;
	private static Vector errors;
	private static Object vfsUpdateLock;
	private static Vector vfsUpdates;
	

	
	static
	{
		errorLock = new Object();
		errors = new Vector();
		fileVFS = new FileVFS();
		urlVFS = new UrlVFS();
		vfsHash = new Hashtable();
		protocolHash = new Hashtable();
		vfsUpdateLock = new Object();
		vfsUpdates = new Vector();
	} 

	private VFSManager() {}
	
}
"
jEdit,4,org.gjt.sp.jedit.gui.BufferOptions,14,7,0,15,81,49,3,14,3,0.884615385,864,1.0,3,0.98048048,0.285714286,1,1,59.42857143,12,1.7143,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.jedit.msg.BufferUpdate;
import org.gjt.sp.jedit.textarea.FoldVisibilityManager;
import org.gjt.sp.jedit.*;



public class BufferOptions extends EnhancedDialog
{
	
	public BufferOptions(View view, Buffer buffer)
	{
		super(view,jEdit.getProperty(""buffer-options.title""),true);
		this.view = view;
		this.buffer = buffer;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		ActionHandler actionListener = new ActionHandler();
		AbstractOptionPane panel = new AbstractOptionPane(null)
		{
			public void addComponent(Component comp)
			{
				super.addComponent(comp);
			}

			public void addComponent(String label, Component comp)
			{
				super.addComponent(label,comp);
			}

			public void addSeparator(String separator)
			{
				super.addSeparator(separator);
			}
		};

		panel.addSeparator(""buffer-options.loading-saving"");

		
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = buffer.getStringProperty(Buffer.LINESEP);
		if(lineSep == null)
			lineSep = System.getProperty(""line.separator"");
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		panel.addComponent(jEdit.getProperty(""buffer-options.lineSeparator""),
			lineSeparator);
		

		
		DefaultComboBoxModel encodings = new DefaultComboBoxModel();
		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			encodings.addElement(st.nextToken());
		}

		encoding = new JComboBox(encodings);
		encoding.setEditable(true);
		encoding.setSelectedItem(buffer.getStringProperty(Buffer.ENCODING));
		panel.addComponent(jEdit.getProperty(""buffer-options.encoding""),
			encoding);
		

		
		gzipped = new JCheckBox(jEdit.getProperty(
			""buffer-options.gzipped""));
		gzipped.setSelected(buffer.getBooleanProperty(Buffer.GZIPPED));
		panel.addComponent(gzipped);
		

		
		trailingEOL = new JCheckBox(jEdit.getProperty(
			""buffer-options.trailingEOL""));
		trailingEOL.setSelected(buffer.getBooleanProperty(Buffer.TRAILING_EOL));
		panel.addComponent(trailingEOL);
		

		panel.addSeparator(""buffer-options.editing"");

		
		modes = jEdit.getModes();
		String bufferMode = buffer.getMode().getName();
		int index = 0;
		String[] modeNames = new String[modes.length];
		for(int i = 0; i < modes.length; i++)
		{
			Mode mode = modes[i];
			modeNames[i] = mode.getName();
			if(bufferMode.equals(mode.getName()))
				index = i;
		}
		mode = new JComboBox(modeNames);
		mode.setSelectedIndex(index);
		mode.addActionListener(actionListener);
		panel.addComponent(jEdit.getProperty(""buffer-options.mode""),mode);
		

		
		String[] foldModes = FoldHandler.getFoldModes();

		folding = new JComboBox(foldModes);
		folding.setSelectedItem(buffer.getStringProperty(""folding""));
		panel.addComponent(jEdit.getProperty(""options.editing.folding""),
			folding);
		

		
		String[] wrapModes = {
			""none"",
			""soft"",
			""hard""
		};

		wrap = new JComboBox(wrapModes);
		wrap.setSelectedItem(buffer.getStringProperty(""wrap""));
		panel.addComponent(jEdit.getProperty(""options.editing.wrap""),
			wrap);
		

		
		String[] lineLengths = { ""0"", ""72"", ""76"", ""80"" };

		maxLineLen = new JComboBox(lineLengths);
		maxLineLen.setEditable(true);
		maxLineLen.setSelectedItem(buffer.getStringProperty(""maxLineLen""));
		panel.addComponent(jEdit.getProperty(""options.editing.maxLineLen""),
			maxLineLen);
		

		
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		tabSize = new JComboBox(tabSizes);
		tabSize.setEditable(true);
		tabSize.setSelectedItem(buffer.getStringProperty(""tabSize""));
		panel.addComponent(jEdit.getProperty(""options.editing.tabSize""),tabSize);
		

		
		indentSize = new JComboBox(tabSizes);
		indentSize.setEditable(true);
		indentSize.setSelectedItem(buffer.getStringProperty(""indentSize""));
		panel.addComponent(jEdit.getProperty(""options.editing.indentSize""),
			indentSize);
		

		
		noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs""));
		noTabs.setSelected(buffer.getBooleanProperty(""noTabs""));
		panel.addComponent(noTabs);
		

		
		indentOnTab = new JCheckBox(jEdit.getProperty(
			""options.editing.indentOnTab""));
		indentOnTab.setSelected(buffer.getBooleanProperty(""indentOnTab""));
		panel.addComponent(indentOnTab);
		

		
		indentOnEnter = new JCheckBox(jEdit.getProperty(
			""options.editing.indentOnEnter""));
		indentOnEnter.setSelected(buffer.getBooleanProperty(""indentOnEnter""));
		panel.addComponent(indentOnEnter);
		

		content.add(BorderLayout.NORTH,panel);

		
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionListener);
		getRootPane().setDefaultButton(ok);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionListener);
		buttons.add(cancel);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);
		

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		int index = mode.getSelectedIndex();
		buffer.setMode(modes[index]);

		index = lineSeparator.getSelectedIndex();
		String lineSep;
		if(index == 0)
			lineSep = ""\n"";
		else if(index == 1)
			lineSep = ""\r\n"";
		else if(index == 2)
			lineSep = ""\r"";
		else
			throw new InternalError();

		String oldLineSep = buffer.getStringProperty(Buffer.LINESEP);
		if(oldLineSep == null)
			oldLineSep = System.getProperty(""line.separator"");
		if(!oldLineSep.equals(lineSep))
		{
			buffer.setStringProperty(""lineSeparator"",lineSep);
			buffer.setDirty(true);
		}

		String encoding = (String)this.encoding.getSelectedItem();
		String oldEncoding = buffer.getStringProperty(Buffer.ENCODING);
		if(!oldEncoding.equals(encoding))
		{
			buffer.setStringProperty(Buffer.ENCODING,encoding);
			buffer.setDirty(true);

			
			EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.ENCODING_CHANGED));
		}

		boolean gzippedValue = gzipped.isSelected();
		boolean oldGzipped = buffer.getBooleanProperty(
			Buffer.GZIPPED);
		if(gzippedValue != oldGzipped)
		{
			buffer.setBooleanProperty(Buffer.GZIPPED,gzippedValue);
			buffer.setDirty(true);
		}

		boolean trailingEOLValue = trailingEOL.isSelected();
		boolean oldTrailingEOL = buffer.getBooleanProperty(
			Buffer.TRAILING_EOL);
		if(trailingEOLValue != oldTrailingEOL)
		{
			buffer.setBooleanProperty(Buffer.TRAILING_EOL,trailingEOLValue);
			buffer.setDirty(true);
		}

		String foldMode = (String)folding.getSelectedItem();
		String oldFoldMode = buffer.getStringProperty(""folding"");
		buffer.setStringProperty(""folding"",foldMode);

		buffer.setStringProperty(""wrap"",(String)wrap.getSelectedItem());

		try
		{
			buffer.setProperty(""maxLineLen"",new Integer(
				maxLineLen.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}

		try
		{
			buffer.setProperty(""tabSize"",new Integer(
				tabSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}

		try
		{
			buffer.setProperty(""indentSize"",new Integer(
				indentSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}

		buffer.setBooleanProperty(""noTabs"",noTabs.isSelected());
		buffer.setBooleanProperty(""indentOnTajb"",indentOnTab.isSelected());
		buffer.setBooleanProperty(""indentOnEnter"",indentOnEnter.isSelected());

		buffer.propertiesChanged();

		View[] views = jEdit.getViews();
		for(int i = 0; i < views.length; i++)
		{
			EditPane[] panes = views[i].getEditPanes();
			for(int j = 0; j < panes.length; j++)
			{
				EditPane pane = panes[j];
				if(pane.getBuffer() == buffer)
					pane.getTextArea().propertiesChanged();
			}
		}

		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

        

	
	private View view;
	private Buffer buffer;
	private Mode[] modes;
	private JComboBox mode;
	private JComboBox lineSeparator;
	private JComboBox encoding;
	private JCheckBox gzipped;
	private JCheckBox trailingEOL;
	private JComboBox folding;
	private JComboBox wrap;
	private JComboBox maxLineLen;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JCheckBox noTabs;
	private JCheckBox indentOnTab;
	private JCheckBox indentOnEnter;
	private JButton ok;
	private JButton cancel;
	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == mode)
			{
				Mode _mode = jEdit.getMode((String)
					mode.getSelectedItem());
				folding.setSelectedItem(_mode.getProperty(
					""folding""));
				wrap.setSelectedItem(_mode.getProperty(
					""wrap""));
				maxLineLen.setSelectedItem(_mode.getProperty(
					""maxLineLen""));
				tabSize.setSelectedItem(_mode.getProperty(
					""tabSize""));
				indentSize.setSelectedItem(_mode.getProperty(
					""indentSize""));
				indentOnTab.setSelected(_mode.getBooleanProperty(
					""indentOnTab""));
				indentOnEnter.setSelected(_mode.getBooleanProperty(
					""indentOnEnter""));
				noTabs.setSelected(_mode.getBooleanProperty(
					""noTabs""));
			}
		} 
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.Registers,13,1,0,9,38,48,4,5,11,0.25,300,1.0,1,0.0,0.305555556,0,0,22.0,8,2.5385,3,"

package org.gjt.sp.jedit;


import javax.swing.text.*;
import java.awt.datatransfer.*;
import java.awt.Toolkit;
import java.io.*;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.util.Log;



public class Registers
{
	
	
	public static void copy(JEditTextArea textArea, char register)
	{
		String selection = textArea.getSelectedText();
		if(selection == null)
			return;

		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);
	} 

	
	
	public static void append(JEditTextArea textArea, char register)
	{
		append(textArea,register,""\n"",false);
	} 

	
	
	public static void append(JEditTextArea textArea, char register,
		String separator)
	{
		append(textArea,register,separator,false);
	} 

	
	
	public static void append(JEditTextArea textArea, char register,
		String separator, boolean cut)
	{
		if(cut && !textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		String selection = textArea.getSelectedText();
		if(selection == null)
			return;

		Register reg = getRegister(register);

		String registerContents = reg.toString();
		if(reg != null && registerContents != null)
		{
			if(registerContents.endsWith(separator))
				selection = registerContents + selection;
			else
				selection = registerContents + separator + selection;
		}

		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);

		if(cut)
			textArea.setSelectedText("""");
	} 

	
	
	public static void cut(JEditTextArea textArea, char register)
	{
		if(textArea.isEditable())
		{
			String selection = textArea.getSelectedText();
			if(selection == null)
				return;

			setRegister(register,selection);
			HistoryModel.getModel(""clipboard"").addItem(selection);

			textArea.setSelectedText("""");
		}
		else
			textArea.getToolkit().beep();
	} 

	
	
	public static void paste(JEditTextArea textArea, char register)
	{
		if(!textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		Register reg = getRegister(register);

		if(reg == null)
		{
			textArea.getToolkit().beep();
			return;
		}
		else
		{
			String selection = reg.toString();
			if(selection == null)
			{
				textArea.getToolkit().beep();
				return;
			}

			
			

			
			int magic = textArea.getMagicCaretPosition();
			textArea.setSelectedText(selection);

			if(textArea.getCaretPosition()
				!= textArea.getLineEndOffset(textArea.getCaretLine()) - 1)
			{
				textArea.setMagicCaretPosition(magic);
			}
			else
			{
				
				
				
			}

			HistoryModel.getModel(""clipboard"").addItem(selection);
		}
	} 

	
	
	public static Register getRegister(char name)
	{
		if(registers == null || name >= registers.length)
			return null;
		else
			return registers[name];
	} 

	
	
	public static void setRegister(char name, Register newRegister)
	{
		if(name >= registers.length)
		{
			Register[] newRegisters = new Register[
				Math.min(1<<16,name * 2)];
			System.arraycopy(registers,0,newRegisters,0,
				registers.length);
			registers = newRegisters;
		}

		registers[name] = newRegister;
	} 

	
	
	public static void setRegister(char name, String value)
	{
		if(name >= registers.length)
		{
			Register[] newRegisters = new Register[
				Math.min(1<<16,name * 2)];
			System.arraycopy(registers,0,newRegisters,0,
				registers.length);
			registers = newRegisters;
			registers[name] = new StringRegister(value);
		}
		else
		{
			Register register = registers[name];

			if(register != null)
				register.setValue(value);
			else
				registers[name] = new StringRegister(value);
		}
	} 

	
	
	public static void clearRegister(char name)
	{
		if(name >= registers.length)
			return;

		Register register = registers[name];
		if(name == '$' || name == '%')
			register.setValue("""");
		else
			registers[name] = null;
	} 

	
	
	public static Register[] getRegisters()
	{
		return registers;
	} 

	
	
	public interface Register
	{
		
		String toString();

		
		void setValue(String value);
	} 

	
	
	public static class ClipboardRegister implements Register
	{
		Clipboard clipboard;

		public ClipboardRegister(Clipboard clipboard)
		{
			this.clipboard = clipboard;
		}

		
		public void setValue(String value)
		{
			StringSelection selection = new StringSelection(value);
			clipboard.setContents(selection,null);
		}

		
		public String toString()
		{
			try
			{
				String selection = (String)(clipboard
					.getContents(this).getTransferData(
					DataFlavor.stringFlavor));

				boolean trailingEOL = (selection.endsWith(""\n"")
					|| selection.endsWith(System.getProperty(
					""line.separator"")));

				
				
				
				BufferedReader in = new BufferedReader(
					new StringReader(selection));
				StringBuffer buf = new StringBuffer();
				String line;
				while((line = in.readLine()) != null)
				{
					buf.append(line);
					buf.append('\n');
				}
				
				if(!trailingEOL)
					buf.setLength(buf.length() - 1);
				return buf.toString();
			}
			catch(Exception e)
			{
				Log.log(Log.NOTICE,this,e);
				return null;
			}
		}
	} 

	
	
	public static class StringRegister implements Register
	{
		private String value;

		
		public StringRegister(String value)
		{
			this.value = value;
		}

		
		public void setValue(String value)
		{
			this.value = value;
		}

		
		public String toString()
		{
			return value;
		}

		
		public void dispose() {}
	} 

	
	private static Register[] registers;

	private Registers() {}

	static
	{
		registers = new Register[256];
		registers['$'] = new ClipboardRegister(Toolkit
			.getDefaultToolkit().getSystemClipboard());
	} 
}
"
jEdit,4,org.gjt.sp.jedit.search.DirectoryListSet,6,2,0,4,13,0,2,2,5,0.4,62,1.0,0,0.583333333,0.444444444,0,0,8.833333333,1,0.8333,0,"

package org.gjt.sp.jedit.search;


import gnu.regexp.RE;
import java.io.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class DirectoryListSet extends BufferListSet
{
	
	public DirectoryListSet(String directory, String glob, boolean recurse)
	{
		this.directory = directory;
		this.glob = glob;
		this.recurse = recurse;
	} 

	
	public String getDirectory()
	{
		return directory;
	} 

	
	public String getFileFilter()
	{
		return glob;
	} 

	
	public boolean isRecursive()
	{
		return recurse;
	} 

	
	public String getCode()
	{
		return ""new DirectoryListSet(\"""" + MiscUtilities.charsToEscapes(directory)
			+ ""\"",\"""" + MiscUtilities.charsToEscapes(glob) + ""\"",""
			+ recurse + "")"";
	} 

	
	protected String[] _getFiles()
	{
		return MiscUtilities.listDirectory(directory,glob,recurse);
	} 

	
	private String directory;
	private String glob;
	private boolean recurse;
	
}
"
jEdit,4,org.gjt.sp.jedit.gui.StatusBar,19,5,0,33,76,119,26,16,11,0.904761905,618,0.857142857,3,0.973174367,0.203007519,3,18,30.78947368,6,1.4211,3,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.text.Segment;
import javax.swing.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.*;
import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



public class StatusBar extends JPanel implements WorkThreadProgressListener
{
	
	public StatusBar(View view)
	{
		super(new BorderLayout(3,3));
		setBorder(BorderFactory.createEmptyBorder(3,0,0,0));

		this.view = view;

		Border border = BorderFactory.createLoweredBevelBorder();

		MouseHandler mouseHandler = new MouseHandler();

		caretStatus = new VICaretStatus();
		caretStatus.setBorder(border);
		caretStatus.setToolTipText(jEdit.getProperty(""view.status.caret-tooltip""));
		caretStatus.addMouseListener(mouseHandler);
		add(BorderLayout.WEST,caretStatus);

		messagePanel = new JPanel();
		messagePanel.setLayout(new BorderLayout(0,0));
		messagePanel.setBorder(border);
		messagePanel.setPreferredSize(caretStatus.getPreferredSize());
		add(BorderLayout.CENTER,messagePanel);

		message = new JLabel();
		message.setBorder(BorderFactory.createEmptyBorder(0,0,0,0));
		setMessageComponent(message);

		Box box = new Box(BoxLayout.X_AXIS);
		mode = new JLabel();
		mode.setBorder(border);
		mode.setToolTipText(jEdit.getProperty(""view.status.mode-tooltip""));
		mode.addMouseListener(mouseHandler);
		box.add(mode);
		box.add(Box.createHorizontalStrut(3));

		encoding = new JLabel();
		encoding.setBorder(border);
		encoding.setToolTipText(jEdit.getProperty(""view.status.encoding-tooltip""));
		encoding.addMouseListener(mouseHandler);
		box.add(encoding);
		box.add(Box.createHorizontalStrut(3));

		FontMetrics fm = getFontMetrics(UIManager.getFont(""Label.font""));

		foldMode = new JLabel();
		foldMode.setHorizontalAlignment(SwingConstants.CENTER);
		foldMode.setBorder(border);
		foldMode.setToolTipText(jEdit.getProperty(""view.status.fold-tooltip""));
		foldMode.addMouseListener(mouseHandler);

		int inc = 0;
		String[] foldModes = FoldHandler.getFoldModes();
		for (int i = 0; i < foldModes.length; i++)
		{
			inc = Math.max(inc, fm.stringWidth(foldModes[i]));
		}

		Dimension dim = foldMode.getPreferredSize();
		dim.width += inc;
		foldMode.setPreferredSize(dim);

		box.add(foldMode);
		box.add(Box.createHorizontalStrut(3));

		multiSelect = new JLabel();
		multiSelect.setHorizontalAlignment(SwingConstants.CENTER);
		multiSelect.setBorder(border);
		multiSelect.setToolTipText(jEdit.getProperty(""view.status.multi-tooltip""));
		multiSelect.addMouseListener(mouseHandler);

		dim = multiSelect.getPreferredSize();
		dim.width += Math.max(fm.stringWidth(""single""),
			fm.stringWidth(""multi""));
		multiSelect.setPreferredSize(dim);

		box.add(multiSelect);
		box.add(Box.createHorizontalStrut(3));

		overwrite = new JLabel();
		overwrite.setHorizontalAlignment(SwingConstants.CENTER);
		overwrite.setBorder(border);
		overwrite.setToolTipText(jEdit.getProperty(""view.status.overwrite-tooltip""));
		overwrite.addMouseListener(mouseHandler);

		dim = overwrite.getPreferredSize();
		dim.width += Math.max(fm.stringWidth(""ovr""),
			fm.stringWidth(""ins""));
		overwrite.setPreferredSize(dim);

		box.add(overwrite);

		box.add(Box.createHorizontalStrut(3));
		memory = new MemoryStatus();
		memory.setBorder(border);
		memory.addMouseListener(mouseHandler);
		box.add(memory);

		
		
		dim = memory.getPreferredSize();
		dim.width += fm.stringWidth(""999Mb/999Mb"");
		dim.height = multiSelect.getPreferredSize().height;
		memory.setPreferredSize(dim);

		add(BorderLayout.EAST,box);
	} 

	
	public void addNotify()
	{
		super.addNotify();
		VFSManager.getIOThreadPool().addProgressListener(this);
	} 

	
	public void removeNotify()
	{
		super.removeNotify();
		VFSManager.getIOThreadPool().removeProgressListener(this);
	} 

	

	
	public void statusUpdate(final WorkThreadPool threadPool, int threadIndex)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				int requestCount = threadPool.getRequestCount();
				if(requestCount == 0)
				{
					setMessageAndClear(jEdit.getProperty(
						""view.status.io.done""));
				}
				else if(requestCount == 1)
				{
					setMessage(jEdit.getProperty(
						""view.status.io-1""));
				}
				else
				{
					Object[] args = { new Integer(requestCount) };
					setMessage(jEdit.getProperty(
						""view.status.io"",args));
				}
			}
		});
	} 

	
	public void progressUpdate(WorkThreadPool threadPool, int threadIndex)
	{
	} 

	

	
	
	public void setMessageAndClear(String message)
	{
		setMessage(message);

		tempTimer = new Timer(0,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				
				if(isShowing())
					setMessage(null);
			}
		});

		tempTimer.setInitialDelay(10000);
		tempTimer.setRepeats(false);
		tempTimer.start();
	} 

	
	public void setMessage(String message)
	{
		if(tempTimer != null)
		{
			tempTimer.stop();
			tempTimer = null;
		}

		setMessageComponent(this.message);

		if(message == null)
		{
			InputHandler inputHandler = view.getInputHandler();
			if(inputHandler.isRepeatEnabled())
			{
				int repeatCount = inputHandler.getRepeatCount();

				this.message.setText(jEdit.getProperty(""view.status.repeat"",
					new Object[] { repeatCount == 1 ? """" : String.valueOf(repeatCount) }));
			}
			else if(view.getMacroRecorder() != null)
				this.message.setText(jEdit.getProperty(""view.status.recording""));
			else
				this.message.setText(null);
		}
		else
			this.message.setText(message);
	} 

	
	public void setMessageComponent(Component comp)
	{
		if (comp == null || messageComp == comp)
		{
			return;
		}

		messageComp = comp;
		messagePanel.add(BorderLayout.CENTER, messageComp);
	} 

	
	public void repaintCaretStatus()
	{
		caretStatus.repaint();
	} 

	
	public void updateBufferStatus()
	{
		Buffer buffer = view.getBuffer();
		mode.setText(buffer.getMode().getName());
		encoding.setText(buffer.getStringProperty(""encoding""));
	} 

	
	public void updateMiscStatus()
	{
		JEditTextArea textArea = view.getTextArea();

		multiSelect.setText(textArea.isMultipleSelectionEnabled()
			? ""multi"" : ""single"");
		overwrite.setText(textArea.isOverwriteEnabled()
			? ""ovr"" : ""ins"");
		foldMode.setText((String)textArea.getBuffer().getProperty(""folding""));
	} 

	
	private View view;
	private VICaretStatus caretStatus;
	private JPanel messagePanel;
	private Component messageComp;
	private JLabel message;
	private JLabel mode;
	private JLabel encoding;
	private JLabel foldMode;
	private JLabel multiSelect;
	private JLabel overwrite;
	private MemoryStatus memory;
	 StringBuffer buf = new StringBuffer();
	private Timer tempTimer;
	

	static final String testStr = ""9999,999-999 99%"";

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			Object source = evt.getSource();
			if(source == caretStatus)
			{
				if(evt.getClickCount() == 2)
					view.getTextArea().showGoToLineDialog();
			}
			else if(source == mode || source == encoding)
			{
				if(evt.getClickCount() == 2)
					new BufferOptions(view,view.getBuffer());
			}
			else if(source == foldMode)
			{
				String text = foldMode.getText();
				String[] foldModes = FoldHandler.getFoldModes();

				for (int i = 0; i < foldModes.length; i++)
				{
					if (text.equals(foldModes[i]))
					{
						i = (i + 1) % foldModes.length;
						text = foldModes[i];
						break;
					}
				}

				JEditTextArea textArea = view.getTextArea();
				Buffer buffer = view.getBuffer();
				buffer.setStringProperty(""folding"",text);
				buffer.propertiesChanged();
			}
			else if(source == multiSelect)
				view.getTextArea().toggleMultipleSelectionEnabled();
			else if(source == overwrite)
				view.getTextArea().toggleOverwriteEnabled();
			else if(source == memory)
			{
				if(evt.getClickCount() == 2)
				{
					jEdit.showMemoryDialog(view);
					memory.repaint();
				}
			}
		}
	} 

	
	class VICaretStatus extends JComponent
	{
		
		public VICaretStatus()
		{
			VICaretStatus.this.setForeground(UIManager.getColor(""Label.foreground""));
			VICaretStatus.this.setBackground(UIManager.getColor(""Label.background""));
			VICaretStatus.this.setFont(UIManager.getFont(""Label.font""));

			Font font = VICaretStatus.this.getFont();
			FontRenderContext frc = new FontRenderContext(null,false,false);

			Rectangle2D bounds = font.getStringBounds(testStr,frc);
			lm = font.getLineMetrics(testStr,frc);

			Dimension size = new Dimension((int)bounds.getWidth(),
				(int)bounds.getHeight());
			VICaretStatus.this.setPreferredSize(size);
		} 

		
		public void paintComponent(Graphics g)
		{
			Buffer buffer = view.getBuffer();

			if(!buffer.isLoaded())
				return;

			JEditTextArea textArea = view.getTextArea();

			int currLine = textArea.getCaretLine();
			int dot = textArea.getCaretPosition()
				- textArea.getLineStartOffset(currLine);
			int virtualPosition = getVirtualPosition(dot,buffer,textArea);

			buf.setLength(0);
			buf.append(Integer.toString(currLine + 1));
			buf.append(',');
			buf.append(Integer.toString(dot + 1));

			if (virtualPosition != dot)
			{
				buf.append('-');
				buf.append(Integer.toString(virtualPosition + 1));
			}

			buf.append(' ');

			int firstLine = textArea.getFirstLine();
			int visible = textArea.getVisibleLines();
			int lineCount = textArea.getVirtualLineCount();

			if (visible >= lineCount)
			{
				buf.append(""All"");
			}
			else if (firstLine == 0)
			{
				buf.append(""Top"");
			}
			else if (firstLine + visible >= lineCount)
			{
				buf.append(""Bot"");
			}
			else
			{
				float percent = (float)firstLine / (float)lineCount
					* 100.0f;
				buf.append(Integer.toString((int)percent));
				buf.append('%');
			}

			g.drawString(buf.toString(),
				VICaretStatus.this.getBorder().getBorderInsets(this).left + 1,
				(int)((VICaretStatus.this.getHeight() - lm.getHeight()) / 2
				+ lm.getAscent()));
		} 

		
		private Segment seg = new Segment();
		private LineMetrics lm;

		
		private int getVirtualPosition(int dot, Buffer buffer, JEditTextArea textArea)
		{
			int line = textArea.getCaretLine();

			textArea.getLineText(line, seg);

			int virtualPosition = 0;
			int tabSize = buffer.getTabSize();

			for (int i = 0; i < seg.count && i < dot; ++i)
			{
				char ch = seg.array[seg.offset + i];

				if (ch == '\t')
				{
					virtualPosition += tabSize
						- (virtualPosition % tabSize);
				}
				else
				{
					++virtualPosition;
				}
			}

			return virtualPosition;
		} 

		
	} 

	
	class MemoryStatus extends JComponent implements ActionListener
	{
		
		public MemoryStatus()
		{
			MemoryStatus.this.setDoubleBuffered(true);
			MemoryStatus.this.setForeground(UIManager.getColor(""Label.foreground""));
			MemoryStatus.this.setBackground(UIManager.getColor(""Label.background""));
			MemoryStatus.this.setFont(UIManager.getFont(""Label.font""));
		} 

		
		public void addNotify()
		{
			super.addNotify();
			timer = new Timer(2000,this);
			timer.start();
			ToolTipManager.sharedInstance().registerComponent(this);
		} 

		
		public void removeNotify()
		{
			timer.stop();
			ToolTipManager.sharedInstance().unregisterComponent(this);
		} 

		
		public String getToolTipText()
		{
			Runtime runtime = Runtime.getRuntime();
			int freeMemory = (int)(runtime.freeMemory() / 1024);
			int totalMemory = (int)(runtime.totalMemory() / 1024);
			int usedMemory = (totalMemory - freeMemory);
			Integer[] args = { new Integer(usedMemory),
				new Integer(totalMemory) };
			return jEdit.getProperty(""view.status.memory-tooltip"",args);
		} 

		
		public void actionPerformed(ActionEvent evt)
		{
			MemoryStatus.this.repaint();
		} 

		
		public void paintComponent(Graphics g)
		{
			Insets insets = MemoryStatus.this.getBorder().getBorderInsets(this);

			Runtime runtime = Runtime.getRuntime();
			int freeMemory = (int)(runtime.freeMemory() / 1024);
			int totalMemory = (int)(runtime.totalMemory() / 1024);
			int usedMemory = (totalMemory - freeMemory);

			int width = MemoryStatus.this.getWidth()
				- insets.left - insets.right;

			float fraction = ((float)usedMemory) / totalMemory;

			g.setColor(UIManager.getColor(""ProgressBar.selectionBackground""));

			g.fillRect(insets.left,insets.top,
				(int)(width * fraction),
				MemoryStatus.this.getHeight()
				- insets.top - insets.bottom);

			String str = (usedMemory / 1024) + ""Mb/""
				+ (totalMemory / 1024) + ""Mb"";
			FontMetrics fm = g.getFontMetrics();

			Graphics g2 = g.create();
			g2.setClip(insets.left,insets.top,
				(int)(width * fraction),
				MemoryStatus.this.getHeight()
				- insets.top - insets.bottom);

			g2.setColor(UIManager.getColor(""ProgressBar.selectionForeground""));

			g2.drawString(str,
				insets.left + (width - fm.stringWidth(str)) / 2,
				insets.top + fm.getAscent());

			g2.dispose();

			g2 = g.create();

			g2.setClip(insets.left + (int)(width * fraction),
				insets.top,MemoryStatus.this.getWidth()
				- insets.left - (int)(width * fraction),
				MemoryStatus.this.getHeight()
				- insets.top - insets.bottom);

			g2.setColor(MemoryStatus.this.getForeground());

			g2.drawString(str,
				insets.left + (width - fm.stringWidth(str)) / 2,
				insets.top + fm.getAscent());

			g2.dispose();
		} 

		private Timer timer;
	} 
}
"
jEdit,4,org.gjt.sp.jedit.Mode,13,1,0,19,33,40,15,6,13,0.733333333,268,1.0,3,0.0,0.338461538,0,0,19.23076923,5,2.1538,2,"

package org.gjt.sp.jedit;


import gnu.regexp.*;
import java.util.Hashtable;
import org.gjt.sp.jedit.syntax.TokenMarker;
import org.gjt.sp.util.Log;



public class Mode
{
	
	
	public Mode(String name)
	{
		this.name = name;
		props = new Hashtable();
	} 

	
	
	public void init()
	{
		try
		{
			String filenameGlob = (String)getProperty(""filenameGlob"");
			if(filenameGlob != null && filenameGlob.length() != 0)
			{
				filenameRE = new RE(MiscUtilities.globToRE(
					filenameGlob),RE.REG_ICASE);
			}

			String firstlineGlob = (String)getProperty(""firstlineGlob"");
			if(firstlineGlob != null && firstlineGlob.length() != 0)
			{
				firstlineRE = new RE(MiscUtilities.globToRE(
					firstlineGlob),RE.REG_ICASE);
			}
		}
		catch(REException re)
		{
			Log.log(Log.ERROR,this,""Invalid filename/firstline""
				+ "" globs in mode "" + name);
			Log.log(Log.ERROR,this,re);
		}
	} 

	
	
	public TokenMarker getTokenMarker()
	{
		loadIfNecessary();
		return marker;
	} 

	
	
	public void setTokenMarker(TokenMarker marker)
	{
		this.marker = marker;
	} 

	
	
	public void loadIfNecessary()
	{
		if(marker == null)
			jEdit.loadMode(this);
	} 

	
	
	public Object getProperty(String key)
	{
		String prefix = ""mode."" + name + ""."";

		
		
			String property = jEdit.getProperty(prefix + key);
			if(property != null && property.length() != 0)
			{
				Object value;
				try
				{
					value = new Integer(property);
				}
				catch(NumberFormatException nf)
				{
					value = property;
				}
				return value;
			}
		

		Object value = props.get(key);
		if(value != null)
			return value;

		String global = jEdit.getProperty(""buffer."" + key);
		if(global != null)
		{
			try
			{
				return new Integer(global);
			}
			catch(NumberFormatException nf)
			{
				return global;
			}
		}
		else
			return null;
	} 

	
	
	public boolean getBooleanProperty(String key)
	{
		Object value = getProperty(key);
		if(""true"".equals(value) || ""on"".equals(value) || ""yes"".equals(value))
			return true;
		else
			return false;
	} 

	
	
	public void setProperty(String key, Object value)
	{
		props.put(key,value);
	} 

	
	
	public void unsetProperty(String key)
	{
		props.remove(key);
	} 

	
	
	public void setProperties(Hashtable props)
	{
		String filenameGlob = (String)getProperty(""filenameGlob"");
		String firstlineGlob = (String)getProperty(""firstlineGlob"");
		this.props = props;
		if(filenameGlob != null)
			props.put(""filenameGlob"",filenameGlob);
		if(firstlineGlob != null)
			props.put(""firstlineGlob"",firstlineGlob);
	} 

	
	
	public boolean accept(String fileName, String firstLine)
	{
		if(filenameRE != null && filenameRE.isMatch(fileName))
			return true;

		if(firstlineRE != null && firstlineRE.isMatch(firstLine))
			return true;

		return false;
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public String toString()
	{
		return getClass().getName() + ""["" + getName() + ""]"";
	} 

	
	private String name;
	private Hashtable props;
	private RE firstlineRE;
	private RE filenameRE;
	private TokenMarker marker;
	
}
"
jEdit,4,org.gjt.sp.jedit.browser.FileCellRenderer,6,6,0,12,35,3,7,5,3,0.711111111,248,0.333333333,0,0.994482759,0.342857143,1,2,38.83333333,10,3.0,0,"

package org.gjt.sp.jedit.browser;


import java.awt.*;
import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.border.*;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.*;


public class FileCellRenderer extends DefaultTreeCellRenderer
{
	public static Icon fileIcon = GUIUtilities.loadIcon(""file.gif"");
	public static Icon dirIcon = GUIUtilities.loadIcon(""closed_folder.gif"");
	public static Icon openDirIcon = GUIUtilities.loadIcon(""open_folder.gif"");
	public static Icon filesystemIcon = GUIUtilities.loadIcon(""drive.gif"");
	public static Icon loadingIcon = GUIUtilities.loadIcon(""drive.gif"");

	
	public FileCellRenderer()
	{
		plainFont = UIManager.getFont(""Tree.font"");
		boldFont = plainFont.deriveFont(Font.BOLD);
		setBorder(new EmptyBorder(1,0,1,0));
	} 

	
	public Component getTreeCellRendererComponent(JTree tree, Object value,
		boolean sel, boolean expanded, boolean leaf, int row,
		boolean focus)
	{
		super.getTreeCellRendererComponent(tree,value,sel,expanded,
			leaf,row,focus);

		DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)value;
		Object userObject = treeNode.getUserObject();
		if(userObject instanceof VFS.DirectoryEntry)
		{
			VFS.DirectoryEntry file = (VFS.DirectoryEntry)userObject;

			underlined = (jEdit.getBuffer(file.path) != null);

			setIcon(showIcons
				? getIconForFile(file,expanded)
				: null);
			setFont(file.type == VFS.DirectoryEntry.FILE
				? plainFont : boldFont);
			setText(file.name);

			if(!sel)
			{
				Color color = file.getColor();

				setForeground(color == null
					? UIManager.getColor(""Tree.foreground"")
					: color);
			}
		}
		else if(userObject instanceof BrowserView.LoadingPlaceholder)
		{
			setIcon(showIcons ? loadingIcon : null);
			setFont(plainFont);
			setText(jEdit.getProperty(""vfs.browser.tree.loading""));
			underlined = false;
		}
		else if(userObject instanceof String)
		{
			setIcon(showIcons ? dirIcon : null);
			setFont(boldFont);
			setText((String)userObject);
			underlined = false;
		}
		else
		{
			
			setIcon(null);
			setText(null);
		}

		return this;
	} 

	
	public void paintComponent(Graphics g)
	{
		if(underlined)
		{
			Font font = getFont();

			FontMetrics fm = getFontMetrics(getFont());
			int x = (getIcon() == null ? 0
				: getIcon().getIconWidth()
				+ getIconTextGap());
			g.setColor(getForeground());
			g.drawLine(x,fm.getAscent() + 2,
				x + fm.stringWidth(getText()),
				fm.getAscent() + 2);
		}

		super.paintComponent(g);
	} 

	
	boolean showIcons;

	
	void propertiesChanged()
	{
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
	} 

	

	

	
	private Font plainFont;
	private Font boldFont;

	private boolean underlined;
	

	
	private Icon getIconForFile(VFS.DirectoryEntry file, boolean expanded)
	{
		if(file.type == VFS.DirectoryEntry.DIRECTORY)
			return (expanded ? openDirIcon : dirIcon);
		else if(file.type == VFS.DirectoryEntry.FILESYSTEM)
			return filesystemIcon;
		else
			return fileIcon;
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.TextUtilities,12,1,0,10,42,66,7,4,12,1.090909091,957,0.428571429,0,0.0,0.239583333,0,0,78.16666667,27,8.4167,3,"

package org.gjt.sp.jedit;


import java.awt.*;
import java.util.*;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.syntax.*;



public class TextUtilities
{
	
	
	public static Token getTokenAtOffset(Token tokens, int offset)
	{
		if(offset == 0 && tokens.id == Token.END)
			return tokens;

		int tokenListOffset = 0;
		for(;;)
		{
			if(tokens.id == Token.END)
				throw new ArrayIndexOutOfBoundsException(""offset > line length"");

			if(tokenListOffset + tokens.length > offset)
				return tokens;
			else
			{
				tokenListOffset += tokens.length;
				tokens = tokens.next;
			}
		}
	} 

	
	
	public static int findMatchingBracket(Buffer buffer, int line, int offset)
	{
		return findMatchingBracket(buffer,line,offset,0,
			buffer.getLineCount() - 1);
	} 

	
	
	public static int findMatchingBracket(Buffer buffer, int line, int offset,
		int startLine, int endLine)
	{
		if(offset < 0 || offset >= buffer.getLineLength(line))
		{
			throw new ArrayIndexOutOfBoundsException(offset + "":""
				+ buffer.getLineLength(line));
		}

		Segment lineText = new Segment();
		buffer.getLineText(line,lineText);

		char c = lineText.array[lineText.offset + offset];
		char cprime; 
		boolean direction; 

		switch(c)
		{
		case '(': cprime = ')'; direction = true;  break;
		case ')': cprime = '('; direction = false; break;
		case '[': cprime = ']'; direction = true;  break;
		case ']': cprime = '['; direction = false; break;
		case '{': cprime = '}'; direction = true;  break;
		case '}': cprime = '{'; direction = false; break;
		default: return -1;
		}

		
		int count = 1;

		Buffer.TokenList tokenList = buffer.markTokens(line);

		
		
		
		byte idOfBracket = getTokenAtOffset(tokenList.getFirstToken(),offset).id;

		boolean haveTokens = true;

		
		if(direction)
		{
			offset++;

			for(;;)
			{
				for(int i = offset; i < lineText.count; i++)
				{
					char ch = lineText.array[lineText.offset + i];
					if(ch == c)
					{
						if(!haveTokens)
						{
							tokenList = buffer.markTokens(line);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenList.getFirstToken(),i).id == idOfBracket)
							count++;
					}
					else if(ch == cprime)
					{
						if(!haveTokens)
						{
							tokenList = buffer.markTokens(line);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenList.getFirstToken(),i).id == idOfBracket)
						{
							count--;
							if(count == 0)
								return buffer.getLineStartOffset(line) + i;
						}
					}
				}

				
				line++;
				if(line > endLine)
					break;
				buffer.getLineText(line,lineText);
				offset = 0;
				haveTokens = false;
				
			}
		} 
		
		else
		{
			offset--;

			for(;;)
			{
				for(int i = offset; i >= 0; i--)
				{
					char ch = lineText.array[lineText.offset + i];
					if(ch == c)
					{
						if(!haveTokens)
						{
							tokenList = buffer.markTokens(line);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenList.getFirstToken(),i).id == idOfBracket)
							count++;
					}
					else if(ch == cprime)
					{
						if(!haveTokens)
						{
							tokenList = buffer.markTokens(line);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenList.getFirstToken(),i).id == idOfBracket)
						{
							count--;
							if(count == 0)
								return buffer.getLineStartOffset(line) + i;
						}
					}
				}

				
				line--;
				if(line < startLine)
					break;
				buffer.getLineText(line,lineText);
				offset = lineText.count - 1;
				haveTokens = false;
				
			}
		} 

		
		return -1;
	} 

	
	
	public static int findWordStart(String line, int pos, String noWordSep)
	{
		char ch = line.charAt(pos);

		if(noWordSep == null)
			noWordSep = """";

		
		int type;
		if(Character.isWhitespace(ch))
			type = WHITESPACE;
		else if(Character.isLetterOrDigit(ch)
			|| noWordSep.indexOf(ch) != -1)
			type = WORD_CHAR;
		else
			type = SYMBOL;
		

		int whiteSpaceEnd = 0;
loop:		for(int i = pos; i >= 0; i--)
		{
			ch = line.charAt(i);
			switch(type)
			{
			
			case WHITESPACE:
				
				if(Character.isWhitespace(ch))
					break;
				else
					return i + 1; 
			
			case WORD_CHAR:
				if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					break;
				}
				else
					return i + 1; 
			
			case SYMBOL:
				
				if(Character.isWhitespace(ch))
				{
					return i + 1;
				}
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					return i + 1;
				}
				else
				{
					break;
				} 
			}
		}

		return whiteSpaceEnd;
	} 

	
	
	public static int findWordEnd(String line, int pos, String noWordSep)
	{
		if(pos != 0)
			pos--;

		char ch = line.charAt(pos);

		if(noWordSep == null)
			noWordSep = """";

		
		int type;
		if(Character.isWhitespace(ch))
			type = WHITESPACE;
		else if(Character.isLetterOrDigit(ch)
			|| noWordSep.indexOf(ch) != -1)
			type = WORD_CHAR;
		else
			type = SYMBOL;
		

		boolean seenWhiteSpace = false;
loop:		for(int i = pos; i < line.length(); i++)
		{
			ch = line.charAt(i);
			switch(type)
			{
			
			case WHITESPACE:
				
				if(Character.isWhitespace(ch))
					break;
				else
					return i; 
			
			case WORD_CHAR:
				if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					break;
				}
				else
					return i; 
			
			case SYMBOL:
				
				if(Character.isWhitespace(ch))
				{
					return i;
				}
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
					return i;
				else
				{
					break;
				} 
			}
		}

		return line.length();
	} 

	
	
	public static boolean regionMatches(boolean ignoreCase, Segment text,
					    int offset, char[] match)
	{
		int length = offset + match.length;
		char[] textArray = text.array;
		if(length > text.offset + text.count)
			return false;
		for(int i = offset, j = 0; i < length; i++, j++)
		{
			char c1 = textArray[i];
			char c2 = match[j];
			if(ignoreCase)
			{
				c1 = Character.toUpperCase(c1);
				c2 = Character.toUpperCase(c2);
			}
			if(c1 != c2)
				return false;
		}
		return true;
	} 

	
	
	public static String spacesToTabs(String in, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		int width = 0;
		int whitespace = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case ' ':
				whitespace++;
				width++;
				break;
			case '\t':
				int tab = tabSize - (width % tabSize);
				width += tab;
				whitespace += tab;
				break;
			case '\n':
				if(whitespace != 0)
				{
					buf.append(MiscUtilities
						.createWhiteSpace(whitespace,tabSize));
				}
				whitespace = 0;
				width = 0;
				buf.append('\n');
				break;
			default:
				if(whitespace != 0)
				{
					buf.append(MiscUtilities
						.createWhiteSpace(whitespace,tabSize));
					whitespace = 0;
				}
				buf.append(in.charAt(i));
				width++;
				break;
			}
		}

		if(whitespace != 0)
		{
			buf.append(MiscUtilities.createWhiteSpace(whitespace,tabSize));
		}

                return buf.toString();
	} 

	
	
	public static String tabsToSpaces(String in, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		int width = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case '\t':
				int count = tabSize - (width % tabSize);
				width += count;
				while(--count >= 0)
					buf.append(' ');
				break;
			case '\n':
				width = 0;
				buf.append(in.charAt(i));
				break;
			default:
				width++;
				buf.append(in.charAt(i));
				break;
                        }
                }
                return buf.toString();
	} 

	
	
	public static String format(String text, int maxLineLength)
	{
		StringBuffer buf = new StringBuffer();
		StringBuffer word = new StringBuffer();
		int lineLength = 0;
		boolean newline = true;
		boolean space = false;
		char[] chars = text.toCharArray();
		for(int i = 0; i < chars.length; i++)
		{
			char c = chars[i];
			switch(c)
			{
			case '\n':
				if(i == 0 || chars.length - i <= 2)
				{
					if(lineLength + word.length() >= maxLineLength)
						buf.append('\n');
					else if(space && word.length() != 0)
						buf.append(' ');
					buf.append(word);
					word.setLength(0);
					buf.append('\n');
					newline = true;
					space = false;
					break;
				}
				else if(newline)
				{
					if(lineLength + word.length() >= maxLineLength)
						buf.append('\n');
					else if(space && word.length() != 0)
						buf.append(' ');
					buf.append(word);
					word.setLength(0);
					buf.append(""\n\n"");
					newline = space = false;
					lineLength = 0;
					break;
				}
				else
					newline = true;
			case ' ':
				if(lineLength + word.length() >= maxLineLength)
				{
					buf.append('\n');
					lineLength = 0;
					newline = true;
				}
				else if(space && lineLength != 0 && word.length() != 0)
				{
					buf.append(' ');
					lineLength++;
					space = false;
				}
				else
					space = true;
				buf.append(word);
				lineLength += word.length();
				word.setLength(0);
				break;
			default:
				newline = false;
				
				
				if(lineLength != 0)
					space = true;
				word.append(c);
				break;
			}
		}
		if(lineLength + word.length() >= maxLineLength)
			buf.append('\n');
		else if(space && word.length() != 0)
			buf.append(' ');
		buf.append(word);
		return buf.toString();
	} 

	
	public static final int MIXED = 0;
	public static final int LOWER_CASE = 1;
	public static final int UPPER_CASE = 2;
	public static final int TITLE_CASE = 3;

	
	public static int getStringCase(String str)
	{
		if(str.length() == 0)
			return MIXED;

		int state = -1;

		char ch = str.charAt(0);
		if(Character.isLetter(ch))
		{
			if(Character.isUpperCase(ch))
				state = UPPER_CASE;
			else
				state = LOWER_CASE;
		}

		for(int i = 1; i < str.length(); i++)
		{
			ch = str.charAt(i);
			if(!Character.isLetter(ch))
				continue;

			switch(state)
			{
			case UPPER_CASE:
				if(Character.isLowerCase(ch))
				{
					if(i == 1)
						state = TITLE_CASE;
					else
						return MIXED;
				}
				break;
			case LOWER_CASE:
			case TITLE_CASE:
				if(Character.isUpperCase(ch))
					return MIXED;
				break;
			}
		}

		return state;
	} 

	
	
	public static String toTitleCase(String str)
	{
		if(str.length() == 0)
			return str;
		else
		{
			return Character.toUpperCase(str.charAt(0))
				+ str.substring(1).toLowerCase();
		}
	} 

	
	private static final int WHITESPACE = 0;
	private static final int WORD_CHAR = 1;
	private static final int SYMBOL = 2;
	
}
"
jEdit,4,org.gjt.sp.jedit.options.TextAreaOptionPane,3,6,0,4,18,1,1,3,3,0.5,302,1.0,1,0.996987952,1.0,2,4,95.33333333,2,1.3333,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;


public class TextAreaOptionPane extends AbstractOptionPane
{
	
	public TextAreaOptionPane()
	{
		super(""textarea"");
	} 

	
	public void _init()
	{
		
		font = new FontSelector(jEdit.getFontProperty(""view.font""));

		addComponent(jEdit.getProperty(""options.textarea.font""),font);

		
		lineHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".lineHighlight""));
		lineHighlight.setSelected(jEdit.getBooleanProperty(""view.lineHighlight""));
		addComponent(lineHighlight);

		
		bracketHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".bracketHighlight""));
		bracketHighlight.setSelected(jEdit.getBooleanProperty(
			""view.bracketHighlight""));
		addComponent(bracketHighlight);

		
		eolMarkers = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".eolMarkers""));
		eolMarkers.setSelected(jEdit.getBooleanProperty(""view.eolMarkers""));
		addComponent(eolMarkers);

		
		wrapGuide = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".wrapGuide""));
		wrapGuide.setSelected(jEdit.getBooleanProperty(""view.wrapGuide""));
		addComponent(wrapGuide);

		
		blinkCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blinkCaret""));
		blinkCaret.setSelected(jEdit.getBooleanProperty(""view.caretBlink""));
		addComponent(blinkCaret);

		
		blockCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blockCaret""));
		blockCaret.setSelected(jEdit.getBooleanProperty(""view.blockCaret""));
		addComponent(blockCaret);

		
		electricBorders = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".electricBorders""));
		electricBorders.setSelected(!""0"".equals(jEdit.getProperty(
			""view.electricBorders"")));
		addComponent(electricBorders);

		
		homeEnd = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".homeEnd""));
		homeEnd.setSelected(jEdit.getBooleanProperty(""view.homeEnd""));
		addComponent(homeEnd);

		
		middleMousePaste = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".middleMousePaste""));
		middleMousePaste.setSelected(jEdit.getBooleanProperty(
			""view.middleMousePaste""));
		addComponent(middleMousePaste);

		
		antiAlias = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".antiAlias""));
		antiAlias.setSelected(jEdit.getBooleanProperty(""view.antiAlias""));
		addComponent(antiAlias);

		
		fracFontMetrics = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".fracFontMetrics""));
		fracFontMetrics.setSelected(jEdit.getBooleanProperty(
			""view.fracFontMetrics""));
		addComponent(fracFontMetrics);

		
		parseFully = new JCheckBox(jEdit.getProperty(
			""options.textarea.parseFully""));
		parseFully.setSelected(jEdit.getBooleanProperty(""parseFully""));
		addComponent(parseFully);
	} 

	
	public void _save()
	{
		jEdit.setFontProperty(""view.font"",font.getFont());

		jEdit.setBooleanProperty(""view.lineHighlight"",lineHighlight
			.isSelected());
		jEdit.setBooleanProperty(""view.bracketHighlight"",bracketHighlight
			.isSelected());
		jEdit.setBooleanProperty(""view.eolMarkers"",eolMarkers
			.isSelected());
		jEdit.setBooleanProperty(""view.wrapGuide"",wrapGuide
			.isSelected());
		jEdit.setBooleanProperty(""view.caretBlink"",blinkCaret.isSelected());
		jEdit.setBooleanProperty(""view.blockCaret"",blockCaret.isSelected());
		jEdit.setIntegerProperty(""view.electricBorders"",electricBorders
			.isSelected() ? 3 : 0);
		jEdit.setBooleanProperty(""view.homeEnd"",homeEnd.isSelected());
		jEdit.setBooleanProperty(""view.middleMousePaste"",
			middleMousePaste.isSelected());
		jEdit.setBooleanProperty(""view.antiAlias"",antiAlias.isSelected());
		jEdit.setBooleanProperty(""view.fracFontMetrics"",fracFontMetrics.isSelected());
		jEdit.setBooleanProperty(""parseFully"",parseFully.isSelected());
	} 

	
	private FontSelector font;
	private JCheckBox lineHighlight;
	private JCheckBox bracketHighlight;
	private JCheckBox eolMarkers;
	private JCheckBox wrapGuide;
	private JCheckBox blinkCaret;
	private JCheckBox blockCaret;
	private JCheckBox electricBorders;
	private JCheckBox homeEnd;
	private JCheckBox middleMousePaste;
	private JCheckBox antiAlias;
	private JCheckBox fracFontMetrics;
	private JCheckBox parseFully;
	
}
"
jEdit,4,org.gjt.sp.util.Log,13,1,0,69,53,38,69,1,7,0.892857143,437,0.571428571,0,0.0,0.178571429,0,0,31.53846154,7,2.3077,0,"

package org.gjt.sp.util;

import javax.swing.text.*;
import java.io.*;
import java.util.StringTokenizer;


public class Log
{
	
	public static final int MAXLINES = 500;

	
	public static final int DEBUG = 1;

	
	public static final int MESSAGE = 3;

	
	public static final int NOTICE = 5;

	
	public static final int WARNING = 7;

	
	public static final int ERROR = 9;

	
	public static void init(boolean stdio, int level)
	{
		if(stdio)
		{
			if(System.out == realOut && System.err == realErr)
			{
				System.setOut(createPrintStream(NOTICE,null));
				System.setErr(createPrintStream(ERROR,null));
			}
		}

		Log.level = level;

		
		log(MESSAGE,Log.class,""When reporting bugs, please""
			+ "" include the following information:"");
		String[] props = {
			""java.version"", ""java.vm.version"", ""java.runtime.version"",
			""java.vendor"", ""java.compiler"", ""os.name"", ""os.version"",
			""os.arch"", ""user.home"", ""java.home"",
			""java.class.path"",
			};
		for(int i = 0; i < props.length; i++)
		{
			log(MESSAGE,Log.class,
				props[i] + ""="" + System.getProperty(props[i]));
		}
	}

	
	public static void setLogWriter(Writer stream)
	{
		if(Log.stream == null && stream != null)
		{
			try
			{
				stream.write(logDocument.getText(0,
					logDocument.getLength()));

				stream.flush();
			}
			catch(Exception e)
			{
				
			}
		}

		Log.stream = stream;
	}

	
	public static Document getLogDocument()
	{
		return logDocument;
	}

	
	public static void flushStream()
	{
		if(stream != null)
		{
			try
			{
				stream.flush();
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	}

	
	public static void closeStream()
	{
		if(stream != null)
		{
			try
			{
				stream.close();
				stream = null;
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	}

	
	public static void log(int urgency, Object source, Object message)
	{
		String _source;
		if(source == null)
		{
			_source = Thread.currentThread().getName();
			if(_source == null)
			{
				_source = Thread.currentThread().getClass().getName();
			}
		}
		else if(source instanceof Class)
			_source = ((Class)source).getName();
		else
			_source = source.getClass().getName();
		int index = _source.lastIndexOf('.');
		if(index != -1)
			_source = _source.substring(index+1);

		if(message instanceof Throwable)
		{
			_logException(urgency,source,(Throwable)message);
		}
		else
		{
			String _message = String.valueOf(message);
			
			
			synchronized(LOCK)
			{
				StringTokenizer st = new StringTokenizer(
					_message,""\r\n"");
				while(st.hasMoreTokens())
				{
					_log(urgency,_source,st.nextToken());
				}
			}
		}
	}

	
	private static Object LOCK = new Object();
	private static Document logDocument;
	private static int level = WARNING;
	private static Writer stream;
	private static String lineSep;
	private static PrintStream realOut;
	private static PrintStream realErr;

	static
	{
		level = WARNING;

		realOut = System.out;
		realErr = System.err;

		logDocument = new PlainDocument();
		lineSep = System.getProperty(""line.separator"");
	}

	private static PrintStream createPrintStream(final int urgency,
		final Object source)
	{
		return new PrintStream(new OutputStream() {
			public void write(int b)
			{
				byte[] barray = { (byte)b };
				write(barray,0,1);
			}

			public void write(byte[] b, int off, int len)
			{
				String str = new String(b,off,len);
				log(urgency,source,str);
			}
		});
	}

	private static void _logException(final int urgency,
		final Object source,
		final Throwable message)
	{
		PrintStream out = createPrintStream(urgency,source);

		synchronized(LOCK)
		{
			message.printStackTrace(out);
		}
	}

	private static void _log(int urgency, String source, String message)
	{
		String urgencyString = ""["" + urgencyToString(urgency) + ""] "";

		String fullMessage = urgencyString + source + "": "" + message;

		try
		{
			logDocument.insertString(logDocument.getLength(),
				fullMessage,null);
			logDocument.insertString(logDocument.getLength(),
				""\n"",null);

			Element map = logDocument.getDefaultRootElement();
			int lines = map.getElementCount();
			if(lines > MAXLINES)
			{
				Element first = map.getElement(0);
				Element last = map.getElement(lines - MAXLINES);
				logDocument.remove(first.getStartOffset(),
					last.getEndOffset());
			}

			if(stream != null)
			{
				stream.write(fullMessage);
				stream.write(lineSep);
			}
		}
		catch(Exception e)
		{
			e.printStackTrace(realErr);
		}

		message = urgencyString +  message + '\n';

		if(urgency >= level)
		{
			if(urgency == ERROR)
				realErr.print(message);
			else
				realOut.print(message);
		}
	}

	private static String urgencyToString(int urgency)
	{
		switch(urgency)
		{
		case DEBUG:
			return ""debug"";
		case MESSAGE:
			return ""message"";
		case NOTICE:
			return ""notice"";
		case WARNING:
			return ""warning"";
		case ERROR:
			return ""error"";
		}

		throw new IllegalArgumentException(""Invalid urgency: "" + urgency);
	}
}
"
jEdit,4,org.gjt.sp.jedit.syntax.KeywordMap,10,1,0,8,28,3,7,2,8,0.583333333,226,1.0,1,0.0,0.35,0,0,21.2,5,1.8,0,"
package org.gjt.sp.jedit.syntax;

import javax.swing.text.Segment;
import java.util.Vector;
import org.gjt.sp.jedit.TextUtilities;


public class KeywordMap
{
	
	public KeywordMap(boolean ignoreCase)
	{
		this(ignoreCase, 52);
		this.ignoreCase = ignoreCase;
		noWordSep = new StringBuffer();
	}

	
	public KeywordMap(boolean ignoreCase, int mapLength)
	{
		this.mapLength = mapLength;
		this.ignoreCase = ignoreCase;
		map = new Keyword[mapLength];
	}

	
	public byte lookup(Segment text, int offset, int length)
	{
		if(length == 0)
			return Token.NULL;
		Keyword k = map[getSegmentMapKey(text, offset, length)];
		while(k != null)
		{
			if(length != k.keyword.length)
			{
				k = k.next;
				continue;
			}
			if(TextUtilities.regionMatches(ignoreCase,text,offset,
				k.keyword))
				return k.id;
			k = k.next;
		}
		return Token.NULL;
	}

	
	public void add(String keyword, byte id)
	{
		int key = getStringMapKey(keyword);

		char[] chars = keyword.toCharArray();

		
		
loop:		for(int i = 0; i < chars.length; i++)
		{
			char ch = chars[i];
			if(!Character.isLetterOrDigit(ch))
			{
				for(int j = 0; j < noWordSep.length(); j++)
				{
					if(noWordSep.charAt(j) == ch)
						continue loop;
				}

				noWordSep.append(ch);
			}
		}

		map[key] = new Keyword(chars,id,map[key]);
	}

	
	public String getNonAlphaNumericChars()
	{
		return noWordSep.toString();
	}

	
	public String[] getKeywords()
	{
		Vector vector = new Vector(100);
		for(int i = 0; i < map.length; i++)
		{
			Keyword keyword = map[i];
			while(keyword != null)
			{
				vector.addElement(new String(keyword.keyword));
				keyword = keyword.next;
			}
		}
		String[] retVal = new String[vector.size()];
		vector.copyInto(retVal);
		return retVal;
	}

	
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	}

	
	public void setIgnoreCase(boolean ignoreCase)
	{
		this.ignoreCase = ignoreCase;
	}

	
	protected int mapLength;

	protected int getStringMapKey(String s)
	{
		return (Character.toUpperCase(s.charAt(0)) +
				Character.toUpperCase(s.charAt(s.length()-1)))
				% mapLength;
	}

	protected int getSegmentMapKey(Segment s, int off, int len)
	{
		return (Character.toUpperCase(s.array[off]) +
				Character.toUpperCase(s.array[off + len - 1]))
				% mapLength;
	}

	
	class Keyword
	{
		public Keyword(char[] keyword, byte id, Keyword next)
		{
			this.keyword = keyword;
			this.id = id;
			this.next = next;
		}

		public char[] keyword;
		public byte id;
		public Keyword next;
	}

	private Keyword[] map;
	private boolean ignoreCase;
	private StringBuffer noWordSep;
}
"
jEdit,4,org.gjt.sp.jedit.options.ContextOptionPane,11,6,0,7,50,25,3,6,1,0.716666667,333,1.0,0,0.985119048,0.5,3,5,28.72727273,6,1.9091,0,"

package org.gjt.sp.jedit.options;

import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;


public class ContextOptionPane extends AbstractOptionPane
{
	public ContextOptionPane()
	{
		super(""context"");
	}

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		JLabel caption = new JLabel(jEdit.getProperty(
			""options.context.caption""));
		add(BorderLayout.NORTH,caption);

		String contextMenu = jEdit.getProperty(""view.context"");
		StringTokenizer st = new StringTokenizer(contextMenu);
		listModel = new DefaultListModel();
		while(st.hasMoreTokens())
		{
			String actionName = (String)st.nextToken();
			if(actionName.equals(""-""))
				listModel.addElement(new ContextOptionPane.MenuItem(""-"",""-""));
			else
			{
				EditAction action = jEdit.getAction(actionName);
				if(action == null)
					continue;
				String label = action.getLabel();
				if(label == null)
					continue;
				listModel.addElement(new ContextOptionPane.MenuItem(actionName,label));
			}
		}
		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());

		add(BorderLayout.CENTER,new JScrollPane(list));

		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.add(Box.createGlue());
		ActionHandler actionHandler = new ActionHandler();
		add = new JButton(jEdit.getProperty(""options.context.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new JButton(jEdit.getProperty(""options.context.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new JButton(jEdit.getProperty(""options.context.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new JButton(jEdit.getProperty(""options.context.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createGlue());

		updateButtons();
		add(BorderLayout.SOUTH,buttons);
	}

	static class MenuItemCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return MiscUtilities.compareStrings(
				((MenuItem)obj1).label,
				((MenuItem)obj2).label,
				true);
		}
	}

	protected void _save()
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');
			buf.append(((MenuItem)listModel.elementAt(i)).actionName);
		}
		jEdit.setProperty(""view.context"",buf.toString());
	}

	
	private DefaultListModel listModel;
	private JList list;
	private JButton add;
	private JButton remove;
	private JButton moveUp, moveDown;

	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
	}

	static class MenuItem
	{
		String actionName;
		String label;

		MenuItem(String actionName, String label)
		{
			this.actionName = actionName;
			this.label = GUIUtilities.prettifyMenuLabel(label);
		}

		public String toString()
		{
			return label;
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == add)
			{
				ContextAddDialog dialog = new ContextAddDialog(
					ContextOptionPane.this);
				String selection = dialog.getSelection();
				if(selection == null)
					return;

				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;

				MenuItem menuItem;
				if(selection.equals(""-""))
					menuItem = new ContextOptionPane.MenuItem(""-"",""-"");
				else
				{
					menuItem = new ContextOptionPane.MenuItem(selection,
						jEdit.getAction(selection)
						.getLabel());
				}

				listModel.insertElementAt(menuItem,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
				list.ensureIndexIsVisible(index - 1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
				list.ensureIndexIsVisible(index+1);
			}
		}
	}

	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	}
}

class ContextAddDialog extends EnhancedDialog
{
	public ContextAddDialog(Component comp)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""options.context.add.title""),
			true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();

		JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));
		typePanel.setBorder(new EmptyBorder(0,0,6,0));
		typePanel.add(new JLabel(
			jEdit.getProperty(""options.context.add.caption"")));

		separator = new JRadioButton(jEdit.getProperty(""options.context""
			+ "".add.separator""));
		separator.addActionListener(actionHandler);
		grp.add(separator);
		typePanel.add(separator);

		action = new JRadioButton(jEdit.getProperty(""options.context""
			+ "".add.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		action.setSelected(true);
		typePanel.add(action);

		content.add(BorderLayout.NORTH,typePanel);

		JPanel actionPanel = new JPanel(new BorderLayout(6,6));

		ActionSet[] actionsList = jEdit.getActionSets();
		Vector vec = new Vector(actionsList.length);
		for(int i = 0; i < actionsList.length; i++)
		{
			ActionSet actionSet = actionsList[i];
			if(actionSet.getActionCount() != 0)
				vec.addElement(actionSet);
		}
		combo = new JComboBox(vec);
		combo.addActionListener(actionHandler);
		actionPanel.add(BorderLayout.NORTH,combo);

		list = new JList();
		list.setVisibleRowCount(8);
		actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));

		content.add(BorderLayout.CENTER,actionPanel);

		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,southPanel);

		updateList();

		pack();
		setLocationRelativeTo(JOptionPane.getFrameForComponent(comp));
		show();
	}

	public void ok()
	{
		isOK = true;
		dispose();
	}

	public void cancel()
	{
		dispose();
	}

	public String getSelection()
	{
		if(!isOK)
			return null;

		if(separator.isSelected())
			return ""-"";
		else if(action.isSelected())
		{
			return ((ContextOptionPane.MenuItem)list.getSelectedValue())
				.actionName;
		}
		else
			throw new InternalError();
	}

	
	private boolean isOK;
	private JRadioButton separator, action;
	private JComboBox combo;
	private JList list;
	private JButton ok, cancel;

	private void updateList()
	{
		ActionSet actionSet = (ActionSet)combo.getSelectedItem();
		EditAction[] actions = actionSet.getActions();
		Vector listModel = new Vector(actions.length);

		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			String label = action.getLabel();
			if(label == null)
				continue;

			listModel.addElement(new ContextOptionPane.MenuItem(
				action.getName(),label));
		}

		MiscUtilities.quicksort(listModel,new ContextOptionPane.MenuItemCompare());

		list.setListData(listModel);
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
			{
				combo.setEnabled(action.isSelected());
				list.setEnabled(action.isSelected());
			}
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == combo)
				updateList();
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.io.UrlVFS,5,2,0,3,17,10,1,3,5,2.0,88,0.0,0,0.84,0.52,1,3,16.6,2,1.0,0,"

package org.gjt.sp.jedit.io;


import java.awt.Component;
import java.io.*;
import java.net.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class UrlVFS extends VFS
{
	
	public UrlVFS()
	{
		super(""url"");
	} 

	
	public int getCapabilities()
	{
		return READ_CAP | WRITE_CAP;
	} 

	
	public String constructPath(String parent, String path)
	{
		if(parent.endsWith(""/""))
			return parent + path;
		else
			return parent + '/' + path;
	} 

	
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		try
		{
			return new URL(path).openStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { mu.getMessage() };
			VFSManager.error(comp,path,""ioerror.badurl"",args);
			return null;
		}
	} 

	
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		try
		{
			return new URL(path).openConnection()
				.getOutputStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { mu.getMessage() };
			VFSManager.error(comp,path,""ioerror.badurl"",args);
			return null;
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.Abbrevs,18,1,0,12,95,43,4,10,9,0.661764706,747,1.0,0,0.0,0.104575163,0,0,40.05555556,17,3.0556,2,"

package org.gjt.sp.jedit;


import javax.swing.text.Element;
import javax.swing.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.gui.AddAbbrevDialog;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class Abbrevs
{
	
	
	public static boolean getExpandOnInput()
	{
		return expandOnInput;
	} 

	
	
	public static void setExpandOnInput(boolean expandOnInput)
	{
		Abbrevs.expandOnInput = expandOnInput;
	} 

	
	
	public static boolean expandAbbrev(View view, boolean add)
	{
		
		Buffer buffer = view.getBuffer();
		JEditTextArea textArea = view.getTextArea();
		if(!buffer.isEditable())
		{
			view.getToolkit().beep();
			return false;
		}

		int line = textArea.getCaretLine();
		int lineStart = buffer.getLineStartOffset(line);
		int caret = textArea.getCaretPosition();

		String lineText = buffer.getLineText(line);
		if(lineText.length() == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		}

		int pos = caret - lineStart;
		if(pos == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		} 

		
		pp.removeAllElements();

		int wordStart;
		String abbrev;

		
		if(lineText.charAt(pos-1) == '#')
		{
			wordStart = lineText.indexOf('#');
			wordStart = TextUtilities.findWordStart(lineText,wordStart,
				buffer.getStringProperty(""noWordSep"") + '#');

			abbrev = lineText.substring(wordStart,pos - 1);

			
			

			int lastIndex = 0;
			for(int i = 0; i < abbrev.length(); i++)
			{
				if(abbrev.charAt(i) == '#')
				{
					pp.addElement(abbrev.substring(lastIndex,i));
					lastIndex = i + 1;
				}
			}

			pp.addElement(abbrev.substring(lastIndex));

			
			abbrev = (String)pp.elementAt(0);
		} 
		
		else
		{
			wordStart = TextUtilities.findWordStart(lineText,pos - 1,
				buffer.getStringProperty(""noWordSep""));

			abbrev = lineText.substring(wordStart,pos);
		} 

		Expansion expand = expandAbbrev(buffer.getMode().getName(),
			abbrev,(buffer.getBooleanProperty(""noTabs"") ?
			buffer.getTabSize() : 0),pp);

		
		if(expand == null)
		{
			if(add)
				new AddAbbrevDialog(view,abbrev);

			return false;
		} 
		
		else
		{
			buffer.beginCompoundEdit();
			try
			{
				
				lineText = buffer.getText(lineStart,wordStart);
				int leadingIndent = MiscUtilities.getLeadingWhiteSpaceWidth(
					lineText,buffer.getTabSize());

				buffer.remove(lineStart + wordStart,pos - wordStart);
				buffer.insert(lineStart + wordStart,expand.text);
				if(expand.caretPosition != -1)
				{
					textArea.setCaretPosition(lineStart + wordStart
						+ expand.caretPosition);
				}

				String whiteSpace = MiscUtilities.createWhiteSpace(
					leadingIndent,buffer.getBooleanProperty(""noTabs"")
					? 0 : buffer.getTabSize());

				
				
				for(int i = line + 1; i <= line + expand.lineCount; i++)
				{
					buffer.insert(buffer.getLineStartOffset(i),
						whiteSpace);
				}
			}
			finally
			{
				buffer.endCompoundEdit();
			}

			return true;
		} 
	} 

	
	
	public static Hashtable getGlobalAbbrevs()
	{
		if(!loaded)
			load();

		return globalAbbrevs;
	} 

	
	
	public static void setGlobalAbbrevs(Hashtable globalAbbrevs)
	{
		abbrevsChanged = true;
		Abbrevs.globalAbbrevs = globalAbbrevs;
	} 

	
	
	public static Hashtable getModeAbbrevs()
	{
		if(!loaded)
			load();

		return modes;
	} 

	
	
	public static void setModeAbbrevs(Hashtable modes)
	{
		abbrevsChanged = true;
		Abbrevs.modes = modes;
	} 

	
	
	public static void addGlobalAbbrev(String abbrev, String expansion)
	{
		if(!loaded)
			load();

		globalAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	} 

	
	
	public static void addModeAbbrev(String mode, String abbrev, String expansion)
	{
		if(!loaded)
			load();

		Hashtable modeAbbrevs = (Hashtable)modes.get(mode);
		if(modeAbbrevs == null)
		{
			modeAbbrevs = new Hashtable();
			modes.put(mode,modeAbbrevs);
		}
		modeAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	} 

	
	static void save()
	{
		jEdit.setBooleanProperty(""view.expandOnInput"",expandOnInput);

		String settings = jEdit.getSettingsDirectory();
		if(abbrevsChanged && settings != null)
		{
			File file1 = new File(MiscUtilities.constructPath(settings,""#abbrevs#save#""));
			File file2 = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			if(file2.exists() && file2.lastModified() != abbrevsModTime)
			{
				Log.log(Log.WARNING,Abbrevs.class,file2 + "" changed on disk;""
					+ "" will not save abbrevs"");
			}
			else
			{
				jEdit.backupSettingsFile(file2);

				try
				{
					saveAbbrevs(new FileWriter(file1));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,Abbrevs.class,""Error while saving "" + file1);
					Log.log(Log.ERROR,Abbrevs.class,e);
				}
				file2.delete();
				file1.renameTo(file2);
				abbrevsModTime = file2.lastModified();
			}
		}
	} 

	

	
	private static boolean loaded;
	private static boolean abbrevsChanged;
	private static long abbrevsModTime;
	private static boolean expandOnInput;
	private static Hashtable globalAbbrevs;
	private static Hashtable modes;
	private static Vector pp = new Vector();
	

	private Abbrevs() {}

	static
	{
		expandOnInput = jEdit.getBooleanProperty(""view.expandOnInput"");
	}

	
	private static void load()
	{
		globalAbbrevs = new Hashtable();
		modes = new Hashtable();

		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			File file = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			abbrevsModTime = file.lastModified();

			try
			{
				loadAbbrevs(new FileReader(file));
				loaded = true;
			}
			catch(FileNotFoundException fnf)
			{
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading "" + file);
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
		}

		
		if(!loaded)
		{
			try
			{
				loadAbbrevs(new InputStreamReader(Abbrevs.class
					.getResourceAsStream(""default.abbrevs"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading default.abbrevs"");
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
			loaded = true;
		}
	} 

	
	private static Expansion expandAbbrev(String mode, String abbrev,
		int softTabSize, Vector pp)
	{
		if(!loaded)
			load();

		
		String expand = null;
		Hashtable modeAbbrevs = (Hashtable)modes.get(mode);
		if(modeAbbrevs != null)
			expand = (String)modeAbbrevs.get(abbrev);

		if(expand == null)
			expand = (String)globalAbbrevs.get(abbrev);

		if(expand == null)
			return null;
		else
			return new Expansion(expand,softTabSize,pp);
	} 

	
	private static void loadAbbrevs(Reader _in) throws Exception
	{
		BufferedReader in = new BufferedReader(_in);

		Hashtable currentAbbrevs = null;

		String line;
		while((line = in.readLine()) != null)
		{
			if(line.length() == 0)
				continue;
			else if(line.startsWith(""["") && line.indexOf('|') == -1)
			{
				if(line.equals(""[global]""))
					currentAbbrevs = globalAbbrevs;
				else
				{
					String mode = line.substring(1,
						line.length() - 1);
					currentAbbrevs = (Hashtable)modes.get(mode);
					if(currentAbbrevs == null)
					{
						currentAbbrevs = new Hashtable();
						modes.put(mode,currentAbbrevs);
					}
				}
			}
			else
			{
				int index = line.indexOf('|');
				currentAbbrevs.put(line.substring(0,index),
					line.substring(index + 1));
			}
		}

		in.close();
	} 

	
	private static void saveAbbrevs(Writer _out) throws Exception
	{
		BufferedWriter out = new BufferedWriter(_out);
		String lineSep = System.getProperty(""line.separator"");

		
		out.write(""[global]"");
		out.write(lineSep);

		saveAbbrevs(out,globalAbbrevs);

		
		Enumeration keys = modes.keys();
		Enumeration values = modes.elements();
		while(keys.hasMoreElements())
		{
			out.write('[');
			out.write((String)keys.nextElement());
			out.write(']');
			out.write(lineSep);
			saveAbbrevs(out,(Hashtable)values.nextElement());
		}

		out.close();
	} 

	
	private static void saveAbbrevs(Writer out, Hashtable abbrevs)
		throws Exception
	{
		String lineSep = System.getProperty(""line.separator"");

		Enumeration keys = abbrevs.keys();
		Enumeration values = abbrevs.elements();
		while(keys.hasMoreElements())
		{
			String abbrev = (String)keys.nextElement();
			out.write(abbrev);
			out.write('|');
			out.write(values.nextElement().toString());
			out.write(lineSep);
		}
	} 

	

	
	static class Expansion
	{
		String text;
		int caretPosition = -1;
		int lineCount;

		
		Expansion(String text, int softTabSize, Vector pp)
		{
			StringBuffer buf = new StringBuffer();
			boolean backslash = false;

			for(int i = 0; i < text.length(); i++)
			{
				char ch = text.charAt(i);
				
				if(backslash)
				{
					backslash = false;

					if(ch == '|')
						caretPosition = buf.length();
					else if(ch == 'n')
					{
						buf.append('\n');
						lineCount++;
					}
					else if(ch == 't')
					{
						if(softTabSize == 0)
							buf.append('\t');
						else
						{
							for(int j = 0; j < softTabSize; j++)
								buf.append(' ');
						}
					}
					else
						buf.append(ch);
				}
				else if(ch == '\\')
					backslash = true;
				
				
				else if(ch == '$')
				{
					if(i != text.length() - 1)
					{
						ch = text.charAt(i + 1);
						if(Character.isDigit(ch) && ch != '0')
						{
							i++;

							int pos = ch - '0';
							if(pos < pp.size())
								buf.append(pp.elementAt(pos));
							else
							{
								
								
								
								buf.append('$');
								buf.append(ch);
							}
						}
						else
						{
							
							
							buf.append('$');
						}
					}
				} 
				else
					buf.append(ch);
			}

			this.text = buf.toString();
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.syntax.XModeHandler,17,2,0,11,72,98,1,11,8,0.879807692,1115,1.0,5,0.448275862,0.264705882,1,2,63.05882353,35,6.2353,3,"

package org.gjt.sp.jedit.syntax;


import com.microstar.xml.*;
import java.io.*;
import java.net.URL;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class XModeHandler extends HandlerBase
{
	
	public XModeHandler (XmlParser parser, String modeName, String path)
	{
		this.modeName = modeName;
		this.parser = parser;
		this.path = path;
		stateStack = new Stack();
	} 

	
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""xmode.dtd"".equals(systemId))
		{
			
			
			
			return new StringReader(""<!-- -->"");

			
		}

		return null;
	} 

	
	public void attribute(String aname, String value, boolean isSpecified)
	{
		String tag = peekElement();
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();

		if (aname == ""NAME"")
		{
			propName = value;
		}
		else if (aname == ""VALUE"")
		{
			propValue = value;
		}
		else if (aname == ""TYPE"")
		{
			lastTokenID = stringToToken(value);
		}
		else if (aname == ""AT_LINE_START"")
		{
			lastAtLineStart = (isSpecified) ? (value == ""TRUE"") :
				false;
		}
		else if (aname == ""NO_LINE_BREAK"")
		{
			lastNoLineBreak = (isSpecified) ? (value == ""TRUE"") :
				false;
		}
		else if (aname == ""NO_WORD_BREAK"")
		{
			lastNoWordBreak = (isSpecified) ? (value == ""TRUE"") :
				false;
		}
		else if (aname == ""EXCLUDE_MATCH"")
		{
			lastExcludeMatch = (isSpecified) ? (value == ""TRUE"") :
				false;
		}
		else if (aname == ""IGNORE_CASE"")
		{
			lastIgnoreCase = (isSpecified) ? (value != ""FALSE"") :
				true;
		}
		else if (aname == ""HIGHLIGHT_DIGITS"")
		{
			lastHighlightDigits = (isSpecified) ? (value != ""FALSE"") :
				false;
		}
		else if (aname == ""AT_CHAR"")
		{
			try
			{
				if (isSpecified) termChar =
					Integer.parseInt(value);
			}
			catch (NumberFormatException e)
			{
				error(""termchar-invalid"",value);
				termChar = -1;
			}
		}
		else if (aname == ""ESCAPE"")
		{
			lastEscape = value;
		}
		else if (aname == ""SET"")
		{
			lastSetName = value;
		}
		else if (aname == ""DELEGATE"")
		{
			lastDelegateSet = value;
		}
		else if (aname == ""DEFAULT"")
		{
			lastDefaultID = stringToToken(value);
		}
	} 

	
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if (""MODE"".equalsIgnoreCase(name)) return;

		error(""doctype-invalid"",name);
	} 

	
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);

		if (tag == ""WHITESPACE"" ||
			tag == ""EOL_SPAN"" ||
			tag == ""MARK_PREVIOUS"" ||
			tag == ""MARK_FOLLOWING"" ||
			tag == ""SEQ"" ||
			tag == ""BEGIN""
		)
		{
			lastStart = text;
		}
		else if (tag == ""END"")
		{
			lastEnd = text;
		}
		else
		{
			lastKeyword = text;
		}
	} 

	
	public void startElement (String tag)
	{
		tag = pushElement(tag);

		if (tag == ""MODE"")
		{
			mode = jEdit.getMode(modeName);
			if (mode == null)
			{
				mode = new Mode(modeName);
				jEdit.addMode(mode);
			}
		}
		else if (tag == ""KEYWORDS"")
		{
			keywords = new KeywordMap(true);
		}
		else if (tag == ""RULES"")
		{
			rules = new ParserRuleSet(lastSetName,mode);
			rules.setIgnoreCase(lastIgnoreCase);
			rules.setHighlightDigits(lastHighlightDigits);
			rules.setEscape(lastEscape);
			rules.setDefault(lastDefaultID);
		}
	} 

	
	public void endElement (String name)
	{
		if (name == null) return;

		String tag = popElement();

		if (name.equalsIgnoreCase(tag))
		{
			
			if (tag == ""MODE"")
			{
				mode.init();
				mode.setTokenMarker(marker);
			} 
			
			else if (tag == ""PROPERTY"")
			{
				props.put(propName,propValue);
			} 
			
			else if (tag == ""PROPS"")
			{
				if(peekElement().equals(""RULES""))
					rules.setProperties(props);
				else
					mode.setProperties(props);

				props = new Hashtable();
			} 
			
			else if (tag == ""KEYWORDS"")
			{
				keywords.setIgnoreCase(lastIgnoreCase);
				lastIgnoreCase = true;
			} 
			
			else if (tag == ""RULES"")
			{
				rules.setKeywords(keywords);
				marker.addRuleSet(lastSetName, rules);
				keywords = null;
				lastSetName = null;
				lastEscape = null;
				lastIgnoreCase = true;
				lastHighlightDigits = false;
				lastDefaultID = Token.NULL;
				rules = null;
			} 
			
			else if (tag == ""TERMINATE"")
			{
				rules.setTerminateChar(termChar);
				termChar = -1;
			} 
			
			else if (tag == ""WHITESPACE"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""WHITESPACE"");
					return;
				}

				rules.addRule(ParserRuleFactory.createWhitespaceRule(
					lastStart));
				lastStart = null;
				lastEnd = null;
			} 
			
			else if (tag == ""EOL_SPAN"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""EOL_SPAN"");
					return;
				}

				rules.addRule(ParserRuleFactory.createEOLSpanRule(
					lastStart,lastTokenID,lastAtLineStart,
					lastExcludeMatch));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastExcludeMatch = false;
			} 
			
			else if (tag == ""MARK_PREVIOUS"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""MARK_PREVIOUS"");
					return;
				}

				rules.addRule(ParserRuleFactory
					.createMarkPreviousRule(lastStart,
					lastTokenID,lastAtLineStart,
					lastExcludeMatch));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastExcludeMatch = false;
			} 
			
			else if (tag == ""MARK_FOLLOWING"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""MARK_FOLLOWING"");
					return;
				}

				rules.addRule(ParserRuleFactory
					.createMarkFollowingRule(lastStart,
					lastTokenID,lastAtLineStart,
					lastExcludeMatch));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastExcludeMatch = false;
			} 
			
			else if (tag == ""SEQ"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""SEQ"");
					return;
				}

				rules.addRule(ParserRuleFactory.createSequenceRule(
					lastStart,lastTokenID,lastAtLineStart));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
			} 
			
			else if (tag == ""END"")
			{
				
				
				

				if (lastDelegateSet == null)
				{
					rules.addRule(ParserRuleFactory
						.createSpanRule(lastStart,
						lastEnd,lastTokenID,
						lastNoLineBreak,
						lastAtLineStart,
						lastExcludeMatch,
						lastNoWordBreak));
				}
				else
				{
					if (lastDelegateSet.indexOf(""::"") == -1)
					{
						lastDelegateSet = modeName + ""::"" + lastDelegateSet;
					}

					rules.addRule(ParserRuleFactory
						.createDelegateSpanRule(
						lastStart,lastEnd,
						lastDelegateSet,
						lastTokenID,lastNoLineBreak,
						lastAtLineStart,
						lastExcludeMatch,
						lastNoWordBreak));
				}
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastNoLineBreak = false;
				lastExcludeMatch = false;
				lastNoWordBreak = false;
				lastDelegateSet = null;
			} 
			
			else if (tag == ""NULL"")
			{
				addKeyword(lastKeyword,Token.NULL);
			}
			else if (tag == ""COMMENT1"")
			{
				addKeyword(lastKeyword,Token.COMMENT1);
			}
			else if (tag == ""COMMENT2"")
			{
				addKeyword(lastKeyword,Token.COMMENT2);
			}
			else if (tag == ""LITERAL1"")
			{
				addKeyword(lastKeyword,Token.LITERAL1);
			}
			else if (tag == ""LITERAL2"")
			{
				addKeyword(lastKeyword,Token.LITERAL2);
			}
			else if (tag == ""LABEL"")
			{
				addKeyword(lastKeyword,Token.LABEL);
			}
			else if (tag == ""KEYWORD1"")
			{
				addKeyword(lastKeyword,Token.KEYWORD1);
			}
			else if (tag == ""KEYWORD2"")
			{
				addKeyword(lastKeyword,Token.KEYWORD2);
			}
			else if (tag == ""KEYWORD3"")
			{
				addKeyword(lastKeyword,Token.KEYWORD3);
			}
			else if (tag == ""FUNCTION"")
			{
				addKeyword(lastKeyword,Token.FUNCTION);
			}
			else if (tag == ""MARKUP"")
			{
				addKeyword(lastKeyword,Token.MARKUP);
			}
			else if (tag == ""OPERATOR"")
			{
				addKeyword(lastKeyword,Token.OPERATOR);
			}
			else if (tag == ""DIGIT"")
			{
				addKeyword(lastKeyword,Token.DIGIT);
			} 
		}
		else
		{
			
			throw new InternalError();
		}
	} 

	
	public void startDocument()
	{
		marker = new TokenMarker();
		marker.setName(modeName);
		props = new Hashtable();

		pushElement(null);
	} 

	

	
	private XmlParser parser;
	private String modeName;
	private String path;

	private TokenMarker marker;
	private KeywordMap keywords;
	private Mode mode;
	private Stack stateStack;
	private String propName;
	private String propValue;
	private Hashtable props;
	private String lastStart;
	private String lastEnd;
	private String lastKeyword;
	private String lastSetName;
	private String lastEscape;
	private String lastDelegateSet;
	private ParserRuleSet rules;
	private byte lastDefaultID = Token.NULL;
	private byte lastTokenID;
	private int termChar = -1;
	private boolean lastNoLineBreak;
	private boolean lastNoWordBreak;
	private boolean lastAtLineStart;
	private boolean lastExcludeMatch;
	private boolean lastIgnoreCase = true;
	private boolean lastHighlightDigits;
	

	
	private byte stringToToken(String value)
	{
		if (value == ""NULL"")
		{
			return Token.NULL;
		}
		else if (value == ""COMMENT1"")
		{
			return Token.COMMENT1;
		}
		else if (value == ""COMMENT2"")
		{
			return Token.COMMENT2;
		}
		else if (value == ""LITERAL1"")
		{
			return Token.LITERAL1;
		}
		else if (value == ""LITERAL2"")
		{
			return Token.LITERAL2;
		}
		else if (value == ""LABEL"")
		{
			return Token.LABEL;
		}
		else if (value == ""KEYWORD1"")
		{
			return Token.KEYWORD1;
		}
		else if (value == ""KEYWORD2"")
		{
			return Token.KEYWORD2;
		}
		else if (value == ""KEYWORD3"")
		{
			return Token.KEYWORD3;
		}
		else if (value == ""FUNCTION"")
		{
			return Token.FUNCTION;
		}
		else if (value == ""MARKUP"")
		{
			return Token.MARKUP;
		}
		else if (value == ""OPERATOR"")
		{
			return Token.OPERATOR;
		}
		else if (value == ""DIGIT"")
		{
			return Token.DIGIT;
		}
		else if (value == ""INVALID"")
		{
			return Token.INVALID;
		}
		else
		{
			error(""token-invalid"",value);
			return Token.NULL;
		}
	} 

	
	private void addKeyword(String k, byte id)
	{
		if(k == null)
		{
			error(""empty-keyword"");
			return;
		}

		if (keywords == null) return;
		keywords.add(k,id);
	} 

	
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();

		stateStack.push(name);

		return name;
	} 

	
	private String peekElement()
	{
		return (String) stateStack.peek();
	} 

	
	private String popElement()
	{
		return (String) stateStack.pop();
	} 

	
	private void error(String msg)
	{
		_error(jEdit.getProperty(""xmode-error."" + msg));
	} 

	
	private void error(String msg, String subst)
	{
		_error(jEdit.getProperty(""xmode-error."" + msg,new String[] { subst }));
	} 

	
	private void error(String msg, Throwable t)
	{
		_error(jEdit.getProperty(""xmode-error."" + msg,new String[] { t.toString() }));
		Log.log(Log.ERROR,this,t);
	} 

	
	private void _error(String msg)
	{
		Object[] args = { path, new Integer(parser.getLineNumber()),
			new Integer(parser.getColumnNumber()), msg };

		GUIUtilities.error(null,""xmode-error"",args);
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.FloatingWindowContainer,8,6,0,5,25,24,3,5,8,0.857142857,74,1.0,2,0.989263804,0.625,1,1,8.0,1,0.875,1,"

package org.gjt.sp.jedit.gui;

import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.image.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public class FloatingWindowContainer extends JFrame implements DockableWindowContainer
{
	public FloatingWindowContainer(DockableWindowManager dockableWindowManager)
	{
		this.dockableWindowManager = dockableWindowManager;
		setIconImage(GUIUtilities.getPluginIcon());
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
	}

	public void register(DockableWindowManager.Entry entry)
	{
		this.entry = entry;
		setTitle(entry.title);

		getContentPane().add(BorderLayout.CENTER,entry.win);

		pack();
		GUIUtilities.loadGeometry(this,entry.name);
		show();
	}

	public void add(DockableWindowManager.Entry entry)
	{
	}

	public void save(DockableWindowManager.Entry entry)
	{
		GUIUtilities.saveGeometry(this,entry.name);
	}

	public void remove(DockableWindowManager.Entry entry)
	{
		super.dispose();
	}

	public void show(final DockableWindowManager.Entry entry)
	{
		toFront();
		requestFocus();
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				entry.win.requestDefaultFocus();
			}
		});
	}

	public boolean isVisible(DockableWindowManager.Entry entry)
	{
		return true;
	}

	public void dispose()
	{
		dockableWindowManager.removeDockableWindow(entry.name);
		
		
	}

	
	private DockableWindowManager dockableWindowManager;
	private DockableWindowManager.Entry entry;
}
"
jEdit,4,org.gjt.sp.jedit.search.BufferListSet,7,1,2,5,11,9,2,3,6,0.5,140,1.0,0,0.0,0.523809524,0,0,18.85714286,9,3.1429,0,"

package org.gjt.sp.jedit.search;


import javax.swing.SwingUtilities;
import java.util.Vector;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public abstract class BufferListSet implements SearchFileSet
{
	
	public String getFirstFile(View view)
	{
		if(files == null)
			files = _getFiles();

		if(files == null || files.length == 0)
			return null;
		else
			return files[0];
	} 

	
	public String getNextFile(View view, String file)
	{
		if(files == null)
			files = _getFiles();

		if(files == null || files.length == 0)
			return null;

		if(file == null)
		{
			file = view.getBuffer().getPath();

			for(int i = 0; i < files.length; i++)
			{
				if(files[i].equals(file))
					return file;
			}

			return getFirstFile(view);
		}
		else
		{
			
			for(int i = 0; i < files.length - 1; i++)
			{
				if(files[i].equals(file))
					return files[i+1];
			}

			return null;
		}
	} 

	
	public String[] getFiles(View view)
	{
		if(files == null)
			files = _getFiles();

		if(files == null || files.length == 0)
			return null;
		else
			return files;
	} 

	
	public int getFileCount()
	{
		if(files == null)
			files = _getFiles();

		if(files == null)
			return 0;
		else
			return files.length;
	} 

	
	public String getCode()
	{
		
		return null;
	} 

	protected abstract String[] _getFiles();

	private String[] files;
}
"
jEdit,4,org.gjt.sp.jedit.syntax.TokenMarker,10,1,0,10,47,21,4,8,7,0.97008547,1529,0.5,2,0.0,0.2875,0,0,149.3,32,8.6,4,"

package org.gjt.sp.jedit.syntax;


import javax.swing.text.Segment;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class TokenMarker
{
	
	public static final int MAJOR_ACTIONS = 0x000000FF;
	public static final int WHITESPACE = 1 << 0;
	public static final int SPAN = 1 << 1;
	public static final int MARK_PREVIOUS = 1 << 2;
	public static final int MARK_FOLLOWING = 1 << 3;
	public static final int EOL_SPAN = 1 << 4;



	

	
	public static final int ACTION_HINTS = 0x0000FF00;
	public static final int EXCLUDE_MATCH = 1 << 8;
	public static final int AT_LINE_START = 1 << 9;
	public static final int NO_LINE_BREAK = 1 << 10;
	public static final int NO_WORD_BREAK = 1 << 11;
	public static final int IS_ESCAPE = 1 << 12;
	public static final int DELEGATE = 1 << 13;


	

	
	public TokenMarker()
	{
		ruleSets = new Hashtable(64);
	} 

	
	public void addRuleSet(String setName, ParserRuleSet rules)
	{
		if (rules == null) return;

		if (setName == null) setName = ""MAIN"";

		ruleSets.put(rulePfx.concat(setName), rules);

		if (setName.equals(""MAIN""))
			mainRuleSet = rules;
	} 

	
	public ParserRuleSet getMainRuleSet()
	{
		return mainRuleSet;
	} 

	
	public ParserRuleSet getRuleSet(String setName)
	{
		ParserRuleSet rules;

		rules = (ParserRuleSet) ruleSets.get(setName);

		if (rules == null && !setName.startsWith(rulePfx))
		{
			int delim = setName.indexOf(""::"");

			String modeName = setName.substring(0, delim);

			Mode mode = jEdit.getMode(modeName);
			if(mode == null)
			{
				Log.log(Log.ERROR,TokenMarker.class,
					""Unknown edit mode: "" + modeName);
				rules = null;
			}
			else
			{
				TokenMarker marker = mode.getTokenMarker();
				rules = marker.getRuleSet(setName);
			}

			
			
			ruleSets.put(setName, rules);
		}

		if (rules == null)
		{
			Log.log(Log.ERROR,this,""Unresolved delegate target: "" + setName);
		}

		return rules;
	} 

	
	public String getName()
	{
		return name;
	} 

	
	public void setName(String name)
	{
		if (name == null) throw new NullPointerException();

		this.name = name;
		rulePfx = name.concat(""::"");
	} 

	
	
	public LineContext markTokens(LineContext prevContext,
		Buffer.TokenList tokenList, Segment line)
	{
		this.context = new LineContext();

		
		if(prevContext == null)
			context.rules = getMainRuleSet();
		else
		{
			context.parent = prevContext.parent;
			context.inRule = prevContext.inRule;
			context.rules = prevContext.rules;
		} 

		lastOffset = lastKeyword = line.offset;
		lineLength = line.count + line.offset;

		int terminateChar = context.rules.getTerminateChar();
		int searchLimit = (terminateChar >= 0 && terminateChar < line.count)
			? line.offset + terminateChar : lineLength;

		escaped = false;

		boolean b;
		boolean tempEscaped;
		Segment tempPattern;
		ParserRule rule;
		LineContext tempContext;

		for(pos = line.offset; pos < searchLimit; pos++)
		{
			
			if (context.parent != null)
			{
				tempContext = context;

				context = context.parent;

				pattern.array = context.inRule.searchChars;
				pattern.count = context.inRule.sequenceLengths[1];
				pattern.offset = context.inRule.sequenceLengths[0];

				b = handleRule(tokenList, line, context.inRule);

				context = tempContext;

				if (!b)
				{
					if (escaped)
					{
						escaped = false;
					}
					else
					{
						if (pos != lastOffset)
						{
							if (context.inRule == null)
							{
								markKeyword(tokenList,line,lastKeyword,pos);

								tokenList.addToken(pos - lastOffset,
									context.rules.getDefault(),
									context.rules);
							}
							else if ((context.inRule.action & (NO_LINE_BREAK | NO_WORD_BREAK)) == 0)
							{
								tokenList.addToken(pos - lastOffset,
									context.inRule.token,
									context.rules);
							}
							else
							{
								tokenList.addToken(pos - lastOffset, Token.INVALID,
									context.rules);
							}
						}

						context = (LineContext)context.parent.clone();

						if ((context.inRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
						{
							tokenList.addToken(pattern.count,
								context.rules.getDefault(),
								context.rules);
						}
						else
						{
							tokenList.addToken(pattern.count,
								context.inRule.token,
								context.rules);
						}

						context.inRule = null;

						lastKeyword = lastOffset = pos + pattern.count;
					}

					pos += (pattern.count - 1); 

					continue;
				}
			} 

			
			if ((rule = context.rules.getEscapeRule()) != null)
			{
				
				tempPattern = pattern;

				
				pattern = context.rules.getEscapePattern();

				tempEscaped = escaped;

				b = handleRule(tokenList, line, rule);

				
				pattern = tempPattern;

				if (!b)
				{
					if (tempEscaped) escaped = false;
					continue;
				}
			} 

			
			rule = context.inRule;
			if(rule != null && (rule.action & SPAN) == SPAN)
			{
				pattern.array = rule.searchChars;
				pattern.count = rule.sequenceLengths[1];
				pattern.offset = rule.sequenceLengths[0];

				
				
				
				if (!handleRule(tokenList,line,rule)
					|| (rule.action & SOFT_SPAN) == 0)
				{
					escaped = false;
					continue;
				}
			} 

			
			rule = context.rules.getRules(line.array[pos]);
			while(rule != null)
			{
				pattern.array = rule.searchChars;

				if (context.inRule == rule && (rule.action & SPAN) == SPAN)
				{
					pattern.count = rule.sequenceLengths[1];
					pattern.offset = rule.sequenceLengths[0];
				}
				else
				{
					pattern.count = rule.sequenceLengths[0];
					pattern.offset = 0;
				}

				
				if (!handleRule(tokenList,line,rule))
					break;

				rule = rule.next;
			} 

			escaped = false;
		}

		
		if(context.inRule == null)
			markKeyword(tokenList, line, lastKeyword, lineLength);
		

		
		if(lastOffset != lineLength)
		{
			if (context.inRule == null)
			{
				tokenList.addToken(lineLength - lastOffset,
					context.rules.getDefault(),
					context.rules);
			}
			else if (
				(context.inRule.action & SPAN) == SPAN &&
				(context.inRule.action & (NO_LINE_BREAK | NO_WORD_BREAK)) != 0
			)
			{
				tokenList.addToken(lineLength - lastOffset,Token.INVALID,
					context.rules);
				context.inRule = null;
			}
			else
			{
				tokenList.addToken(lineLength - lastOffset,
					context.inRule.token,
					context.rules);

				if((context.inRule.action & MARK_FOLLOWING) == MARK_FOLLOWING)
				{
					context.inRule = null;
				}
			}
		} 

		tokenList.addToken(0,Token.END,context.rules);

		return context.intern();
	} 

	
	private static final int SOFT_SPAN = MARK_FOLLOWING | NO_WORD_BREAK;

	
	private String name;
	private String rulePfx;
	private Hashtable ruleSets;
	private ParserRuleSet mainRuleSet;

	private LineContext context;
	private Segment pattern = new Segment(new char[0],0,0);
	private int lastOffset;
	private int lastKeyword;
	private int lineLength;
	private int pos;
	private boolean escaped;
	

	
	
	private boolean handleRule(Buffer.TokenList tokenList, Segment line,
		ParserRule checkRule)
	{
		if (pattern.count == 0) return true;

		if (lineLength - pos < pattern.count) return true;

		char a, b;
		for (int k = 0; k < pattern.count; k++)
		{
			a = pattern.array[pattern.offset + k];
			b = line.array[pos + k];

			
			if (
				!(
					a == b ||
					context.rules.getIgnoreCase() &&
					(
						Character.toLowerCase(a) == b ||
						a == Character.toLowerCase(b)
					)
				)
			) return true;
			
		}

		if (escaped)
		{
			pos += pattern.count - 1;
			return false;
		}
		else if ((checkRule.action & IS_ESCAPE) == IS_ESCAPE)
		{
			escaped = true;
			pos += pattern.count - 1;
			return false;
		}

		
		if (context.inRule != checkRule && context.inRule != null
			&& (context.inRule.action & SOFT_SPAN) != 0)
		{
			if ((context.inRule.action & NO_WORD_BREAK) == NO_WORD_BREAK)
			{
				tokenList.addToken(pos - lastOffset, Token.INVALID,
					context.rules);
			}
			else
			{
				tokenList.addToken(pos - lastOffset,
					context.inRule.token,
					context.rules);
			}
			lastOffset = lastKeyword = pos;
			context.inRule = null;
		} 

		
		if (context.inRule == null)
		{
			if ((checkRule.action & AT_LINE_START) == AT_LINE_START)
			{
				if (
					(((checkRule.action & MARK_PREVIOUS) != 0) ?
					lastKeyword :
					pos) != line.offset
				)
				{
					return true;
				}
			}

			markKeyword(tokenList, line, lastKeyword, pos);

			if ((checkRule.action & MARK_PREVIOUS) != MARK_PREVIOUS)
			{
				lastKeyword = pos + pattern.count;

				if ((checkRule.action & WHITESPACE) == WHITESPACE)
				{
					return false; 
				}

				
				if (lastOffset < pos)
				{
					tokenList.addToken(pos - lastOffset,
						context.rules.getDefault(),
						context.rules);
				}
			}

			switch(checkRule.action & MAJOR_ACTIONS)
			{
			
			case 0:
				
				tokenList.addToken(pattern.count,checkRule.token,
					context.rules);
				lastOffset = pos + pattern.count;

				break;
			
			
			case SPAN:
				context.inRule = checkRule;

				
				if ((checkRule.action & DELEGATE) != DELEGATE)
				{
					if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
					{
						tokenList.addToken(pattern.count,
							context.rules.getDefault(),
							context.rules);
						lastOffset = pos + pattern.count;
					}
					else
					{
						lastOffset = pos;
					}
				} 
				
				else
				{
					String setName = new String(checkRule.searchChars,
						checkRule.sequenceLengths[0] + checkRule.sequenceLengths[1],
						checkRule.sequenceLengths[2]);

					ParserRuleSet delegateSet = getRuleSet(setName);

					if (delegateSet != null)
					{
						if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
						{
							tokenList.addToken(pattern.count,
								context.rules.getDefault(),
								context.rules);
						}
						else
						{
							tokenList.addToken(pattern.count,
								checkRule.token,
								context.rules);
						}
						lastOffset = pos + pattern.count;

						context = new LineContext(delegateSet, context);
					}
				} 

				break;
			
			
			case EOL_SPAN:
				if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
				{
					tokenList.addToken(pattern.count,
						context.rules.getDefault(),
						context.rules);
					tokenList.addToken(lineLength - (pos + pattern.count),
						checkRule.token,context.rules);
				}
				else
				{
					tokenList.addToken(lineLength - pos,
						checkRule.token,context.rules);
				}
				lastOffset = lineLength;
				lastKeyword = lineLength;
				pos = lineLength;

				return false;
			
			
			case MARK_PREVIOUS:
				if (lastKeyword > lastOffset)
				{
					tokenList.addToken(lastKeyword - lastOffset,
						context.rules.getDefault(),
						context.rules);
					lastOffset = lastKeyword;
				}

				if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
				{
					tokenList.addToken(pos - lastOffset,
						checkRule.token,context.rules);
					tokenList.addToken(pattern.count,
						context.rules.getDefault(),
						context.rules);
				}
				else
				{
					tokenList.addToken(pos - lastOffset + pattern.count,
						checkRule.token,context.rules);
				}
				lastOffset = pos + pattern.count;

				break;
			
			
			case MARK_FOLLOWING:
				context.inRule = checkRule;
				if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
				{
					tokenList.addToken(pattern.count,
						context.rules.getDefault(),
						context.rules);
					lastOffset = pos + pattern.count;
				}
				else
				{
					lastOffset = pos;
				}

				break;
			
			default:
				throw new InternalError(""Unhandled major action"");
			}

			lastKeyword = lastOffset;

			pos += (pattern.count - 1); 
			return false; 
		}
		
		
		else if ((checkRule.action & SPAN) == SPAN)
		{
			if ((checkRule.action & DELEGATE) != DELEGATE)
			{
				context.inRule = null;
				if ((checkRule.action & EXCLUDE_MATCH) == EXCLUDE_MATCH)
				{
					tokenList.addToken(pos - lastOffset,
						checkRule.token,context.rules);
					tokenList.addToken(pattern.count,
						context.rules.getDefault(),
						context.rules);
				}
				else
				{
					tokenList.addToken((pos + pattern.count) - lastOffset,
						checkRule.token,context.rules);
				}
				lastKeyword = lastOffset = pos + pattern.count;

				pos += (pattern.count - 1); 
			}

			return false; 
		}

		return true;
	} 

	
	private void markKeyword(Buffer.TokenList tokenList, Segment line,
		int start, int end)
	{
		KeywordMap keywords = context.rules.getKeywords();

		int len = end - start;

		

		
		if(context.rules.getHighlightDigits())
		{
			boolean digit = true;
			char[] array = line.array;
			boolean octal = false;
			boolean hex = false;
			boolean seenSomeDigits = false;
loop:			for(int i = 0; i < len; i++)
			{
				char ch = array[start+i];
				switch(ch)
				{
				case '0':
					if(i == 0)
						octal = true;
					seenSomeDigits = true;
					continue loop;
				case '1': case '2': case '3':
				case '4': case '5': case '6':
				case '7': case '8': case '9':
					seenSomeDigits = true;
					continue loop;
				case 'x': case 'X':
					if(octal && i == 1)
					{
						hex = true;
						continue loop;
					}
					else
						break;
				case 'd': case 'D':
				case 'f': case 'F':
					if(hex)
						continue loop;
					else if(i == len -1 && seenSomeDigits)
						continue loop;
					else
						break;
				case 'l': case 'L':
					if(i == len -1 && seenSomeDigits)
						continue loop;
					else
						break;
				case 'e': case 'E':
					if(seenSomeDigits)
						continue loop;
					else
						break;
				case 'a': case 'A': case 'b': case 'B':
				case 'c': case 'C':
					if(hex)
						continue loop;
					else
						break;
				case '.': case '-':
					
					
					
					
					
					
					

					continue loop;
				default:
					break;
				}

				
				
				digit = false;
				break loop;
			}

			
			
			if(digit && seenSomeDigits)
			{
				if(start != lastOffset)
				{
					tokenList.addToken(start - lastOffset,
						context.rules.getDefault(),
						context.rules);
				}
				tokenList.addToken(len,Token.DIGIT,context.rules);
				lastKeyword = lastOffset = end;

				return;
			}
		} 

		if(keywords != null)
		{
			byte id = keywords.lookup(line, start, len);

			if(id != Token.NULL)
			{
				if(start != lastOffset)
				{
					tokenList.addToken(start - lastOffset,
						context.rules.getDefault(),
						context.rules);
				}
				tokenList.addToken(len,id,context.rules);
				lastKeyword = lastOffset = end;
			}
		}
	} 

	

	
	public static class LineContext
	{
		
		static int count;
		static int countGC;

		public String getAllocationStatistics()
		{
			return ""total: "" + count + "", in core: "" +
				(count - countGC)
				+ "", interned: "" + intern.size();
		} 

		static Hashtable intern = new Hashtable();

		public LineContext parent;
		public ParserRule inRule;
		public ParserRuleSet rules;

		
		public LineContext(ParserRule r, ParserRuleSet rs)
		{
			this();
			inRule = r;
			rules = rs;
		} 

		
		public LineContext(ParserRuleSet rs, LineContext lc)
		{
			this();
			rules = rs;
			parent = (lc == null ? null : (LineContext)lc.clone());
		} 

		
		public LineContext(ParserRule r)
		{
			this();
			inRule = r;
		} 

		
		public LineContext()
		{
			count++;
		} 

		
		public LineContext intern()
		{
			Object obj = intern.get(this);
			if(obj == null)
			{
				intern.put(this,this);
				return this;
			}
			else
				return (LineContext)obj;
		} 

		
		public void finalize()
		{
			countGC++;
		} 

		
		public int hashCode()
		{
			if(inRule != null)
				return inRule.hashCode();
			else if(rules != null)
				return rules.hashCode();
			else
				return 0;
		} 

		
		public boolean equals(Object obj)
		{
			if(obj instanceof LineContext)
			{
				LineContext lc = (LineContext)obj;
				if(lc.parent == null)
				{
					if(parent != null)
						return false;
				}
				else 
				{
					if(parent == null)
						return false;
					else if(!lc.parent.equals(parent))
						return false;
				}

				return lc.inRule == inRule && lc.rules == rules;
			}
			else
				return false;
		} 

		
		public Object clone()
		{
			LineContext lc = new LineContext();
			lc.inRule = inRule;
			lc.rules = rules;
			lc.parent = (parent == null) ? null : (LineContext) parent.clone();

			return lc;
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.textarea.Selection,11,1,2,17,20,33,16,1,8,0.8,90,0.0,0,0.0,0.386363636,0,0,6.818181818,1,0.7273,1,"

package org.gjt.sp.jedit.textarea;

import org.gjt.sp.jedit.Buffer;


public abstract class Selection implements Cloneable
{
	
	
	public int getStart()
	{
		return start;
	} 

	
	
	public int getEnd()
	{
		return end;
	} 

	
	
	public int getStartLine()
	{
		return startLine;
	} 

	
	
	public int getEndLine()
	{
		return endLine;
	} 

	
	
	public abstract int getStart(Buffer buffer, int line);
	

	
	
	public abstract int getEnd(Buffer buffer, int line);
	

	
	public String toString()
	{
		return getClass().getName() + ""[start="" + start
			+ "",end="" + end + "",startLine="" + startLine
			+ "",endLine="" + endLine + ""]"";
	} 

	
	public Object clone()
	{
		try
		{
			return super.clone();
		}
		catch(CloneNotSupportedException e)
		{
			throw new InternalError(""I just drank a whole ""
				+ ""bottle of cough syrup and I feel ""
				+ ""funny!"");
		}
	} 

	
	int start, end, startLine, endLine;
	

	

	
	protected Selection()
	{
	} 

	
	protected Selection(Selection copy)
	{
		start = copy.start;
		end = copy.end;
	} 

	
	protected Selection(int start, int end)
	{
		this.start = start;
		this.end = end;

		
		
		
	} 

	

	
	
	public static class Range extends Selection
	{
		
		public Range()
		{
			super();
		} 

		
		public Range(Selection sel)
		{
			super(sel);
		} 

		
		public Range(int start, int end)
		{
			super(start,end);
		} 

		
		public int getStart(Buffer buffer, int line)
		{
			if(line == startLine)
				return start;
			else
				return buffer.getLineStartOffset(line);
		} 

		
		public int getEnd(Buffer buffer, int line)
		{
			if(line == endLine)
				return end;
			else
				return buffer.getLineEndOffset(line) - 1;
		} 
	} 

	
	
	public static class Rect extends Selection
	{
		
		public Rect()
		{
			super();
		} 

		
		public Rect(Selection sel)
		{
			super(sel);
		} 

		
		public Rect(int start, int end)
		{
			super(start,end);
		} 

		
		public int getStart(Buffer buffer, int line)
		{
			if(line == startLine)
				return start;
			else
			{
				int _start = start - buffer.getLineStartOffset(startLine);
				int _end = end - buffer.getLineStartOffset(endLine);

				return Math.min(buffer.getLineEndOffset(line) - 1,
					buffer.getLineStartOffset(line)
					+ Math.min(_start,_end));
			}
		} 

		
		public int getEnd(Buffer buffer, int line)
		{
			if(line == endLine)
				return end;
			else
			{
				int _start = start - buffer.getLineStartOffset(startLine);
				int _end = end - buffer.getLineStartOffset(endLine);

				return Math.min(buffer.getLineEndOffset(line) - 1,
					buffer.getLineStartOffset(line)
					+ Math.max(_start,_end));
			}
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.syntax.Token,2,1,0,6,7,0,5,1,2,1.761904762,52,0.0,3,0.0,0.625,0,0,14.5,1,0.5,1,"
package org.gjt.sp.jedit.syntax;


public class Token
{
	
	public static final byte NULL = 0;
	public static final byte COMMENT1 = 1;
	public static final byte COMMENT2 = 2;
	public static final byte LITERAL1 = 3;
	public static final byte LITERAL2 = 4;
	public static final byte LABEL = 5;
	public static final byte KEYWORD1 = 6;
	public static final byte KEYWORD2 = 7;
	public static final byte KEYWORD3 = 8;
	public static final byte FUNCTION = 9;
	public static final byte MARKUP = 10;
	public static final byte OPERATOR = 11;
	public static final byte DIGIT = 12;
	public static final byte INVALID = 13; 

	public static final byte ID_COUNT = 14;

	public static final byte END = 127;

	
	
	public int length;

	
	public byte id;

	
	public ParserRuleSet rules;

	
	public Token prev;

	
	public Token next;
	

	
	
	public Token(int length, byte id, ParserRuleSet rules)
	{
		this.length = length;
		this.id = id;
		this.rules = rules;
	} 

	
	
	public String toString()
	{
		return ""[id="" + id + "",length="" + length + ""]"";
	} 
}
"
jEdit,4,org.gjt.sp.jedit.textarea.TextAreaPainter,54,4,0,22,144,1059,13,15,47,0.963481436,1085,0.677419355,4,0.924177396,0.103009259,3,25,18.51851852,7,1.5741,2,"

package org.gjt.sp.jedit.textarea;


import javax.swing.text.*;
import javax.swing.JComponent;
import java.awt.event.MouseEvent;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.HashMap;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;



public class TextAreaPainter extends JComponent implements TabExpander
{
	
	
	public static final int LOWEST_LAYER = Integer.MIN_VALUE;

	
	public static final int BACKGROUND_LAYER = -60;

	
	public static final int LINE_BACKGROUND_LAYER = -50;

	
	public static final int BELOW_SELECTION_LAYER = -40;

	
	public static final int SELECTION_LAYER = -30;

	
	public static final int WRAP_GUIDE_LAYER = -20;

	
	public static final int BELOW_MOST_EXTENSIONS_LAYER = -10;

	
	public static final int DEFAULT_LAYER = 0;

	
	public static final int BRACKET_HIGHLIGHT_LAYER = 100;

	
	public static final int HIGHEST_LAYER = Integer.MAX_VALUE;
	

	
	
	public TextAreaPainter(JEditTextArea textArea)
	{
		enableEvents(AWTEvent.FOCUS_EVENT_MASK
			| AWTEvent.KEY_EVENT_MASK
			| AWTEvent.MOUSE_EVENT_MASK);

		this.textArea = textArea;

		extensionMgr = new ExtensionManager();

		setAutoscrolls(true);
		setOpaque(true);

		setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));

		fontRenderContext = new FontRenderContext(null,false,false);

		addExtension(LINE_BACKGROUND_LAYER,lineBackground
			= new PaintLineBackground());
		addExtension(SELECTION_LAYER,new PaintSelection());
		addExtension(WRAP_GUIDE_LAYER,new WrapGuide());
		addExtension(BRACKET_HIGHLIGHT_LAYER,new BracketHighlight());
	} 

	
	
	public void setBounds(int x, int y, int width, int height)
	{
		if(x == getX() && y == getY() && width == getWidth()
			&& height == getHeight())
		{
			return;
		}

		super.setBounds(x,y,width,height);

		textArea.recalculateVisibleLines();
		textArea.recalculateLastPhysicalLine();
		textArea.propertiesChanged();
		textArea.scrollBarsInitialized = true;
	} 

	
	
	public boolean isManagingFocus()
	{
		return false;
	} 

	
	
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} 

	

	
	
	public final SyntaxStyle[] getStyles()
	{
		return styles;
	} 

	
	
	public final void setStyles(SyntaxStyle[] styles)
	{
		this.styles = styles;
		styles[Token.NULL] = new SyntaxStyle(getForeground(),null,getFont());
		repaint();
	} 

	
	
	public final Color getCaretColor()
	{
		return caretColor;
	} 

	
	
	public final void setCaretColor(Color caretColor)
	{
		this.caretColor = caretColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final Color getSelectionColor()
	{
		return selectionColor;
	} 

	
	
	public final void setSelectionColor(Color selectionColor)
	{
		this.selectionColor = selectionColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateSelectedLines();
	} 

	
	
	public final Color getLineHighlightColor()
	{
		return lineHighlightColor;
	} 

	
	
	public final void setLineHighlightColor(Color lineHighlightColor)
	{
		this.lineHighlightColor = lineHighlightColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final boolean isLineHighlightEnabled()
	{
		return lineHighlight;
	} 

	
	
	public final void setLineHighlightEnabled(boolean lineHighlight)
	{
		this.lineHighlight = lineHighlight;
		if(textArea.getBuffer() != null)
			textArea.invalidateSelectedLines();
	} 

	
	
	public final Color getFoldedLineColor()
	{
		return foldedLineColor;
	} 

	
	
	public final void setFoldedLineColor(Color foldedLineColor)
	{
		this.foldedLineColor = foldedLineColor;
		repaint();
	} 

	
	
	public final Color getBracketHighlightColor()
	{
		return bracketHighlightColor;
	} 

	
	
	public final void setBracketHighlightColor(Color bracketHighlightColor)
	{
		this.bracketHighlightColor = bracketHighlightColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getBracketLine());
	} 

	
	
	public final boolean isBracketHighlightEnabled()
	{
		return bracketHighlight;
	} 

	
	
	public final void setBracketHighlightEnabled(boolean bracketHighlight)
	{
		this.bracketHighlight = bracketHighlight;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getBracketLine());
	} 

	
	
	public final boolean isBlockCaretEnabled()
	{
		return blockCaret;
	} 

	
	
	public final void setBlockCaretEnabled(boolean blockCaret)
	{
		this.blockCaret = blockCaret;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final Color getEOLMarkerColor()
	{
		return eolMarkerColor;
	} 

	
	
	public final void setEOLMarkerColor(Color eolMarkerColor)
	{
		this.eolMarkerColor = eolMarkerColor;
		repaint();
	} 

	
	
	public final boolean getEOLMarkersPainted()
	{
		return eolMarkers;
	} 

	
	
	public final void setEOLMarkersPainted(boolean eolMarkers)
	{
		this.eolMarkers = eolMarkers;
		repaint();
	} 

	
	
	public final Color getWrapGuideColor()
	{
		return wrapGuideColor;
	} 

	
	
	public final void setWrapGuideColor(Color wrapGuideColor)
	{
		this.wrapGuideColor = wrapGuideColor;
		repaint();
	} 

	
	
	public final boolean isWrapGuidePainted()
	{
		return wrapGuide;
	} 

	
	
	public final void setWrapGuidePainted(boolean wrapGuide)
	{
		this.wrapGuide = wrapGuide;
		repaint();
	} 

	
	
	public void setAntiAliasEnabled(boolean antiAlias)
	{
		this.antiAlias = antiAlias;
		updateRenderingHints();
	} 

	
	
	public boolean isAntiAliasEnabled()
	{
		return antiAlias;
	} 

	
	
	public void setFractionalFontMetricsEnabled(boolean fracFontMetrics)
	{
		this.fracFontMetrics = fracFontMetrics;
		updateRenderingHints();
	} 

	
	
	public boolean isFractionalFontMetricsEnabled()
	{
		return fracFontMetrics;
	} 

	
	
	public FontRenderContext getFontRenderContext()
	{
		return fontRenderContext;
	} 

	

	
	
	public void addCustomHighlight(TextAreaHighlight highlight)
	{
		Log.log(Log.WARNING,this,""Old highlighter API not supported: ""
			+ highlight);
	} 

	
	
	public void removeCustomHighlight(TextAreaHighlight highlight)
	{
		Log.log(Log.WARNING,this,""Old highlighter API not supported: ""
			+ highlight);
	} 

	
	
	public void addExtension(TextAreaExtension extension)
	{
		extensionMgr.addExtension(DEFAULT_LAYER,extension);
		repaint();
	} 

	
	
	public void addExtension(int layer, TextAreaExtension extension)
	{
		extensionMgr.addExtension(layer,extension);
		repaint();
	} 

	
	
	public void removeExtension(TextAreaExtension extension)
	{
		extensionMgr.removeExtension(extension);
		repaint();
	} 

	
	
	public String getToolTipText(MouseEvent evt)
	{
		if(!textArea.getBuffer().isLoaded())
			return null;

		return extensionMgr.getToolTipText(evt.getX(),evt.getY());
	} 

	
	
	public FontMetrics getFontMetrics()
	{
		return fm;
	} 

	
	
	public void setFont(Font font)
	{
		super.setFont(font);
		fm = getFontMetrics(font);
		textArea.recalculateVisibleLines();
	} 

	
	
	public void paintComponent(Graphics _gfx)
	{
		long start = System.currentTimeMillis();

		Graphics2D gfx = (Graphics2D)_gfx;
		gfx.setRenderingHints(renderingHints);
		fontRenderContext = gfx.getFontRenderContext();

		Rectangle clipRect = gfx.getClipBounds();

		gfx.setColor(getBackground());
		gfx.fillRect(clipRect.x,clipRect.y,clipRect.width,clipRect.height);

		Buffer buffer = textArea.getBuffer();
		if(!buffer.isLoaded())
			return;

		int x = textArea.getHorizontalOffset();

		int height = fm.getHeight();
		int firstInvalid = clipRect.y / height;
		
		
		
		int lastInvalid = (clipRect.y + clipRect.height - 1) / height;

		textArea.chunkCache.updateChunksUpTo(lastInvalid);

		int lineCount = textArea.getVirtualLineCount();

		int y = (clipRect.y - clipRect.y % height);

		try
		{
			boolean updateMaxHorizontalScrollWidth = false;

			for(int line = firstInvalid; line <= lastInvalid; line++)
			{
				ChunkCache.LineInfo lineInfo = textArea.chunkCache
					.getLineInfo(line);
				if(!lineInfo.chunksValid)
					System.err.println(""text area painter: not valid"");

				lineInfo.width = paintLine(gfx,buffer,lineInfo,line,x,y) - x;
				if(lineInfo.width > textArea.maxHorizontalScrollWidth)
					updateMaxHorizontalScrollWidth = true;

				y += height;
			}

			if(buffer.isNextLineRequested())
			{
				int h = clipRect.y + clipRect.height;
				textArea.chunkCache.invalidateChunksFrom(lastInvalid + 1);
				repaint(0,h,getWidth(),getHeight() - h);
			}

			if(updateMaxHorizontalScrollWidth)
				textArea.updateMaxHorizontalScrollWidth();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,""Error repainting line""
				+ "" range {"" + firstInvalid + "",""
				+ lastInvalid + ""}:"");
			Log.log(Log.ERROR,this,e);
		}

		
		
	} 

	
	
	public float nextTabStop(float x, int tabOffset)
	{
		int ntabs = (int)(x / textArea.tabSize);
		return (ntabs + 1) * textArea.tabSize;
	} 

	
	
	public Dimension getPreferredSize()
	{
		Dimension dim = new Dimension();

		char[] foo = new char[80];
		for(int i = 0; i < foo.length; i++)
			foo[i] = ' ';
		dim.width = (int)(getFont().getStringBounds(foo,0,foo.length,
			fontRenderContext).getWidth());
		dim.height = fm.getHeight() * 25;
		return dim;
	} 

	
	
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	} 

	

	
	private JEditTextArea textArea;

	private SyntaxStyle[] styles;
	private Color caretColor;
	private Color selectionColor;
	private Color lineHighlightColor;
	private Color foldedLineColor;
	private Color bracketHighlightColor;
	private Color eolMarkerColor;
	private Color wrapGuideColor;

	private boolean blockCaret;
	private boolean lineHighlight;
	private boolean bracketHighlight;
	private boolean eolMarkers;
	private boolean wrapGuide;
	private boolean antiAlias;
	private boolean fracFontMetrics;

	
	private FontMetrics fm;

	private ExtensionManager extensionMgr;

	
	
	private PaintLineBackground lineBackground;

	private RenderingHints renderingHints;
	private FontRenderContext fontRenderContext;
	

	
	private void updateRenderingHints()
	{
		HashMap hints = new HashMap();

		if(antiAlias)
		{
			hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		}
		else
		{
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
		}

		hints.put(RenderingHints.KEY_FRACTIONALMETRICS,
			fracFontMetrics ?
				RenderingHints.VALUE_FRACTIONALMETRICS_ON
				: RenderingHints.VALUE_FRACTIONALMETRICS_OFF);

		renderingHints = new RenderingHints(hints);
		fontRenderContext = new FontRenderContext(null,antiAlias,
			fracFontMetrics);
	} 

	
	private int paintLine(Graphics2D gfx, Buffer buffer,
		ChunkCache.LineInfo lineInfo, int screenLine,
		int x, int y)
	{
		int physicalLine = lineInfo.physicalLine;

		if(physicalLine == -1)
			extensionMgr.paintInvalidLine(gfx,screenLine,y);
		else
		{
			int start = textArea.getScreenLineStartOffset(screenLine);
			int end = textArea.getScreenLineEndOffset(screenLine);

			extensionMgr.paintValidLine(gfx,screenLine,physicalLine,
				start,end,y);

			Font defaultFont = getFont();
			Color defaultColor = getForeground();

			gfx.setFont(defaultFont);
			gfx.setColor(defaultColor);

			float baseLine = y + fm.getHeight()
				- fm.getLeading() - fm.getDescent();

			if(lineInfo.chunks != null)
			{
				x += ChunkCache.paintChunkList(
					lineInfo.chunks,gfx,x,baseLine,
					lineBackground.bgColor,true);
			}

			gfx.setFont(defaultFont);
			gfx.setColor(eolMarkerColor);

			if(!lineInfo.lastSubregion)
			{
				gfx.drawString("":"",Math.max(x,
					textArea.getHorizontalOffset()
					+ textArea.wrapMargin + textArea.charWidth),
					baseLine);
				x += textArea.charWidth;
			}
			else if(lineBackground.collapsedFold)
			{
				int nextLine = textArea.getFoldVisibilityManager()
					.getNextVisibleLine(physicalLine);
				if(nextLine == -1)
					nextLine = buffer.getLineCount();

				int count = nextLine - physicalLine - 1;
				String str = "" ["" + count + "" lines]"";
				gfx.drawString(str,x,baseLine);
				x += (int)(getFont().getStringBounds(
					str,fontRenderContext)
					.getWidth());
			}
			else if(eolMarkers)
			{
				gfx.drawString(""."",x,baseLine);
				x += textArea.charWidth;
			}

			paintCaret(gfx,physicalLine,start,end,y,lineBackground.bgColor);
		}

		return x;
	} 

	
	private void paintCaret(Graphics2D gfx, int physicalLine,
		int start, int end, int y, Color bgColor)
	{
		if(!textArea.isCaretVisible())
			return;

		int caret = textArea.getCaretPosition();
		if(caret < start || caret >= end)
			return;

		int offset = caret - textArea.getLineStartOffset(physicalLine);
		textArea.offsetToXY(physicalLine,offset,textArea.returnValue);
		int caretX = textArea.returnValue.x;
		int height = fm.getHeight();

		gfx.setColor(caretColor);

		if(blockCaret)
		{
			
			
			
			Graphics2D blockgfx = (Graphics2D)gfx.create();
			blockgfx.setXORMode(bgColor);

			if(textArea.isOverwriteEnabled())
			{
				blockgfx.fillRect(caretX,y + height - height / 3,
					textArea.charWidth,height / 3);
			}
			else
				blockgfx.fillRect(caretX,y,textArea.charWidth,height);

			blockgfx.dispose();
		}
		else
		{
			if(textArea.isOverwriteEnabled())
			{
				gfx.drawLine(caretX,y + height - 1,
					caretX + textArea.charWidth,y + height - 1);
			}
			else
				gfx.drawLine(caretX,y,caretX,y + height - 1);
		}
	} 

	

	
	class PaintLineBackground extends TextAreaExtension
	{
		boolean collapsedFold;
		Color bgColor;

		
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			
			JEditTextArea textArea = TextAreaPainter.this.textArea;
			Buffer buffer = textArea.getBuffer();

			collapsedFold = (physicalLine < buffer.getLineCount() - 1
				&& buffer.isFoldStart(physicalLine)
				&& !textArea.getFoldVisibilityManager()
				.isLineVisible(physicalLine + 1));

			int caret = textArea.getCaretPosition();
			boolean paintLineHighlight = isLineHighlightEnabled()
				&& caret >= start && caret < end
				&& textArea.selection.size() == 0;

			if(paintLineHighlight)
				bgColor = lineHighlightColor;
			else if(collapsedFold)
				bgColor = foldedLineColor;
			else
				bgColor = getBackground();

			if(paintLineHighlight || collapsedFold)
			{
				gfx.setColor(bgColor);
				gfx.fillRect(0,y,getWidth(),fm.getHeight());
			}
		} 
	} 

	
	class PaintSelection extends TextAreaExtension
	{
		
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(textArea.selection.size() == 0)
				return;

			gfx.setColor(getSelectionColor());
			for(int i = textArea.selection.size() - 1;
				i >= 0; i--)
			{
				paintSelection(gfx,screenLine,
					physicalLine,start,end,y,
					(Selection)textArea.selection
					.get(i));
			}
		} 

		
		private void paintSelection(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y, Selection s)
		{
			if(end <= s.start || start > s.end)
				return;

			int selStartScreenLine = textArea.getScreenLineOfOffset(s.start);
			int selEndScreenLine = textArea.getScreenLineOfOffset(s.end);

			int lineStart = textArea.getLineStartOffset(physicalLine);
			start -= lineStart;
			end -= lineStart;

			int x1, x2;

			if(s instanceof Selection.Rect)
			{
				int lineLen = textArea.getLineLength(physicalLine);

				int startOffset = Math.min(lineLen,
					s.start - textArea.getLineStartOffset(
					s.startLine));
				int endOffset = Math.min(lineLen,
					s.end - textArea.getLineStartOffset(
					s.endLine));

				if(end <= startOffset || start > endOffset)
					return;

				x1 = (startOffset < start ? 0
					: textArea.offsetToXY(physicalLine,startOffset,textArea.returnValue).x);
				x2 = (endOffset > end ? getWidth()
					: textArea.offsetToXY(physicalLine,endOffset,textArea.returnValue).x);

				if(x1 > x2)
				{
					int tmp = x2;
					x2 = x1;
					x1 = tmp;
				}
			}
			else if(selStartScreenLine == selEndScreenLine
				&& selStartScreenLine != -1)
			{
				x1 = textArea.offsetToXY(physicalLine,
					s.start - lineStart,textArea.returnValue).x;
				x2 = textArea.offsetToXY(physicalLine,
					s.end - lineStart,textArea.returnValue).x;
			}
			else if(screenLine == selStartScreenLine)
			{
				x1 = textArea.offsetToXY(physicalLine,
					s.start - lineStart,textArea.returnValue).x;
				x2 = getWidth();
			}
			else if(screenLine == selEndScreenLine)
			{
				x1 = 0;
				x2 = textArea.offsetToXY(physicalLine,
					s.end - lineStart,textArea.returnValue).x;
			}
			else
			{
				x1 = 0;
				x2 = getWidth();
			}

			if(x1 == x2)
				x2++;

			gfx.fillRect(x1,y,x2 - x1,fm.getHeight());
		} 
	} 

	
	class WrapGuide extends TextAreaExtension
	{
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			paintInvalidLine(gfx,screenLine,y);
		}

		public void paintInvalidLine(Graphics2D gfx, int screenLine, int y)
		{
			if(!textArea.wrapToWidth && textArea.wrapMargin != 0
				&& isWrapGuidePainted())
			{
				gfx.setColor(getWrapGuideColor());
				int x = textArea.getHorizontalOffset() + textArea.wrapMargin;
				gfx.drawLine(x,y,x,y + fm.getHeight());
			}
		}

		public String getToolTipText(int x, int y)
		{
			if(!textArea.wrapToWidth && textArea.wrapMargin != 0
				&& isWrapGuidePainted())
			{
				int wrapGuidePos = textArea.wrapMargin
					+ textArea.getHorizontalOffset();
				if(Math.abs(x - wrapGuidePos) < 5)
				{
					return String.valueOf(textArea.getBuffer()
						.getProperty(""maxLineLen""));
				}
			}

			return null;
		}
	} 

	
	class BracketHighlight extends TextAreaExtension
	{
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(!isBracketHighlightEnabled() || !textArea.isBracketHighlightVisible())
				return;

			int bracketLine = textArea.getBracketLine();
			int bracketOffset = textArea.getBracketPosition();
			if(bracketLine == -1 || bracketOffset == -1)
				return;

			int bracketLineStart = textArea.getLineStartOffset(bracketLine);
			if(bracketOffset + bracketLineStart < start
				|| bracketOffset + bracketLineStart >= end)
				return;

			textArea.offsetToXY(bracketLine,bracketOffset,textArea.returnValue);
			gfx.setColor(getBracketHighlightColor());
			
			
			
			gfx.drawRect(textArea.returnValue.x,y,(int)gfx.getFont().getStringBounds(
				""("",getFontRenderContext()).getWidth() - 1,
				fm.getHeight() - 1);
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.options.BrowserColorsOptionPane,9,6,0,8,45,18,4,7,1,0.71875,205,1.0,1,0.988059701,0.5,4,12,21.33333333,2,1.0,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;




public class BrowserColorsOptionPane extends AbstractOptionPane
{
	
	public BrowserColorsOptionPane()
	{
		super(""browser.colors"");
	} 

	

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		colorsModel = new BrowserColorsModel();
		colorsTable = new JTable(colorsModel);
		colorsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		colorsTable.getTableHeader().setReorderingAllowed(false);
		colorsTable.addMouseListener(new MouseHandler());
		colorsTable.getSelectionModel().addListSelectionListener(
			new SelectionHandler());
		TableColumnModel tcm = colorsTable.getColumnModel();
		tcm.getColumn(1).setCellRenderer(new BrowserColorsModel.ColorRenderer());
		Dimension d = colorsTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(colorsTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.CENTER,scroller);

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(6,0,0,0));

		buttons.add(Box.createGlue());
		add = new JButton(jEdit.getProperty(""options.browser.colors.add""));
		add.addActionListener(new ActionHandler());
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new JButton(jEdit.getProperty(""options.browser.colors.remove""));
		remove.addActionListener(new ActionHandler());
		buttons.add(remove);
		buttons.add(Box.createGlue());

		add(BorderLayout.SOUTH,buttons);

		updateEnabled();
	} 

	
	protected void _save()
	{
		colorsModel.save();
	} 

	

	
	private BrowserColorsModel colorsModel;
	private JTable colorsTable;
	private JButton add;
	private JButton remove;

	
	private void updateEnabled()
	{
		int selectedRow = colorsTable.getSelectedRow();
		remove.setEnabled(selectedRow != -1);
	} 

	

	
	class SelectionHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateEnabled();
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == add)
			{
				colorsModel.add();
			}
			else if(source == remove)
			{
				int selectedRow = colorsTable.getSelectedRow();
				colorsModel.remove(selectedRow);
				updateEnabled();
			}
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			Point p = evt.getPoint();
			int row = colorsTable.rowAtPoint(p);
			int column = colorsTable.columnAtPoint(p);
			if(row == -1 || column != 1)
				return;

			Color color = JColorChooser.showDialog(
				BrowserColorsOptionPane.this,
				jEdit.getProperty(""colorChooser.title""),
				(Color)colorsModel.getValueAt(row,1));
			if(color != null)
				colorsModel.setValueAt(color,row,1);
		}
	} 
} 


class BrowserColorsModel extends AbstractTableModel
{
	Vector entries;

	
	BrowserColorsModel()
	{
		entries = new Vector();

		int i = 0;
		String glob;
		while((glob = jEdit.getProperty(""vfs.browser.colors."" + i + "".glob"")) != null)
		{
			entries.addElement(new Entry(glob,
				jEdit.getColorProperty(
				""vfs.browser.colors."" + i + "".color"",
				Color.black)));
			i++;
		}
	} 

	
	void add()
	{
		entries.addElement(new Entry("""",UIManager.getColor(""Tree.foreground"")));
		fireTableRowsInserted(entries.size() - 1,entries.size() - 1);
	} 

	
	void remove(int index)
	{
		entries.removeElementAt(index);
		fireTableRowsDeleted(entries.size(),entries.size());
	} 

	
	void save()
	{
		int i;
		for(i = 0; i < entries.size(); i++)
		{
			Entry entry = (Entry)entries.elementAt(i);
			jEdit.setProperty(""vfs.browser.colors."" + i + "".glob"",
				entry.glob);
			jEdit.setColorProperty(""vfs.browser.colors."" + i + "".color"",
				entry.color);
		}
		jEdit.unsetProperty(""vfs.browser.colors."" + i + "".glob"");
		jEdit.unsetProperty(""vfs.browser.colors."" + i + "".color"");
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return entries.size();
	} 

	
	public Object getValueAt(int row, int col)
	{
		Entry entry = (Entry)entries.elementAt(row);

		switch(col)
		{
		case 0:
			return entry.glob;
		case 1:
			return entry.color;
		default:
			return null;
		}
	} 

	
	public boolean isCellEditable(int row, int col)
	{
		return (col == 0);
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		Entry entry = (Entry)entries.elementAt(row);

		if(col == 0)
			entry.glob = (String)value;
		else
			entry.color = (Color)value;

		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.browser.colors.glob"");
		case 1:
			return jEdit.getProperty(""options.browser.colors.color"");
		default:
			return null;
		}
	} 

	
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
			return String.class;
		case 1:
			return Color.class;
		default:
			throw new InternalError();
		}
	} 

	
	static class Entry
	{
		String glob;
		Color color;

		Entry(String glob, Color color)
		{
			this.glob = glob;
			this.color = color;
		}
	} 

	
	static class ColorRenderer extends JLabel
		implements TableCellRenderer
	{
		
		public ColorRenderer()
		{
			setOpaque(true);
			setBorder(StyleOptionPane.noFocusBorder);
		} 

		
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (isSelected)
			{
				setBackground(table.getSelectionBackground());
				setForeground(table.getSelectionForeground());
			}
			else
			{
				setBackground(table.getBackground());
				setForeground(table.getForeground());
			}

			if (value != null)
				setBackground((Color)value);

			setBorder((cellHasFocus) ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: StyleOptionPane.noFocusBorder);
			return this;
		} 
	} 
} 
"
jEdit,4,org.gjt.sp.jedit.EditBus,11,1,0,27,32,23,22,6,8,0.72,240,1.0,1,0.0,0.16,0,0,20.36363636,5,1.7273,0,"

package org.gjt.sp.jedit;

import java.util.*;
import org.gjt.sp.util.Log;


public class EditBus
{
	
	public static void addToBus(EBComponent comp)
	{
		synchronized(components)
		{
			components.addElement(comp);
			copyComponents = null;
		}
	}

	
	public static void removeFromBus(EBComponent comp)
	{
		synchronized(components)
		{
			components.removeElement(comp);
			copyComponents = null;
		}
	}

	
	public static EBComponent[] getComponents()
	{
		synchronized(components)
		{
			if (copyComponents == null)
			{
				copyComponents = new EBComponent[components.size()];
				components.copyInto(copyComponents);
			}
			return copyComponents;
		}
	}

	
	public static void send(EBMessage message)
	{
		Log.log(Log.DEBUG,EditBus.class,message.toString());

		
		
		EBComponent[] comps = getComponents();

		for(int i = 0; i < comps.length; i++)
		{
			try
			{
				comps[i].handleMessage(message);
				if(message.isVetoed())
					break;
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,EditBus.class,""Exception""
					+ "" while sending message on EditBus:"");
				Log.log(Log.ERROR,EditBus.class,t);
			}
		}
	}

	
	public static Object[] getNamedList(Object tag)
	{
		Object[] list = (Object[])listArrays.get(tag);
		if(list != null)
			return list;

		Vector listVector = (Vector)listVectors.get(tag);
		if(listVector != null)
		{
			list = new Object[listVector.size()];
			listVector.copyInto(list);
			listArrays.put(tag,list);
			return list;
		}

		return null;
	}

	
	public static Enumeration getNamedLists()
	{
		return listVectors.keys();
	}

	
	public static void addToNamedList(Object tag, Object entry)
	{
		if(tag.equals(org.gjt.sp.jedit.gui.DockableWindow.DOCKABLE_WINDOW_LIST))
		{
			
			org.gjt.sp.jedit.gui.DockableWindowManager
				.registerDockableWindow((String)entry,
				null,false,jEdit.getActionSets()[0]);
		}
		else
		{
			Vector listVector = (Vector)listVectors.get(tag);
			if(listVector == null)
			{
				listVector = new Vector();
				listVectors.put(tag,listVector);
			}

			listVector.addElement(entry);
			listArrays.remove(tag);
		}
	}

	
	public static void removeFromNamedList(Object tag, Object entry)
	{
		Vector listVector = (Vector)listVectors.get(tag);
		if(listVector == null)
			return;

		listVector.removeElement(entry);
		listArrays.remove(tag);
	}

	
	private static Vector components = new Vector();
	private static EBComponent[] copyComponents;
	private static Hashtable listVectors = new Hashtable();
	private static Hashtable listArrays = new Hashtable();

	
	private EditBus() {}
}
"
jEdit,4,org.gjt.sp.jedit.gui.VariableGridLayout,17,1,0,2,37,100,2,0,16,0.7,679,0.8,0,0.0,0.323529412,0,0,38.35294118,12,2.0,1,"

package org.gjt.sp.jedit.gui;


import java.awt.*;



public class VariableGridLayout implements LayoutManager2, java.io.Serializable
{

	public static final int FIXED_NUM_ROWS = 1;
	public static final int FIXED_NUM_COLUMNS = 2;


	public VariableGridLayout(int mode, int size, int hgap, int vgap) {
		if (mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS) {
			throw new IllegalArgumentException(""illegal mode; value is "" + mode);
		}
		if (size <= 0) {
			throw new IllegalArgumentException(""size cannot be zero or less; value is "" + size);
		}
		if (hgap < 0) {
			throw new IllegalArgumentException(""hgap cannot be negative; value is "" + hgap);
		}
		if (vgap < 0) {
			throw new IllegalArgumentException(""vgap cannot be negative; value is "" + vgap);
		}
		this.mode = mode;
		this.size = size;
		this.hgap = hgap;
		this.vgap = vgap;
	}


	
	public VariableGridLayout(int mode, int size) {
		this(mode, size, 0, 0);
	}


	
	public VariableGridLayout() {
		this(FIXED_NUM_ROWS, 1, 0, 0);
	}


	
	public void addLayoutComponent(String name, Component component) { }


	
	public void addLayoutComponent(Component component, Object constraints) { }


	
	public void removeLayoutComponent(Component component) { }


	
	public float getLayoutAlignmentX(Container container) {
		return 0.5f;
	}


	
	public float getLayoutAlignmentY(Container container) {
		return 0.5f;
	}


	public Dimension preferredLayoutSize(Container parent) {
		return getLayoutSize(parent, 2);
	}


	public Dimension minimumLayoutSize(Container parent) {
		return getLayoutSize(parent, 0);
	}


	public Dimension maximumLayoutSize(Container parent) {
		return getLayoutSize(parent, 1);
	}


	public void layoutContainer(Container parent) {
		synchronized (parent.getTreeLock()) {
			int ncomponents = parent.getComponentCount();

			if (ncomponents == 0) {
				return;
			}

			
			int total_height = 0;
			for (int r = 0, i = 0; r < nrows; r++) {
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						Dimension d = parent.getComponent(i).getPreferredSize();
						row_heights[r] = Math.max(row_heights[r], d.height);
						col_widths[c] = Math.max(col_widths[c], d.width);
					} else {
						break;
					}
				}
				total_height += row_heights[r];
			}

			int total_width = 0;
			for (int c = 0; c < ncols; c++) {
				total_width += col_widths[c];
			}

			
			Dimension parent_size = parent.getSize();
			Insets insets = parent.getInsets();
			int free_height = parent_size.height - insets.top - insets.bottom - (nrows - 1) * vgap;
			int free_width = parent_size.width - insets.left - insets.right - (ncols - 1) * hgap;

			if (total_height != free_height) {
				double dy = (double)free_height / (double)total_height;
				for (int r = 0; r < nrows; r++) {
					row_heights[r] = (int) ((double)row_heights[r] * dy);
				}
			}

			if (total_width != free_width) {
				double dx = ((double)free_width) / ((double)total_width);
				for (int c = 0; c < ncols; c++) {
					col_widths[c] = (int) ((double)col_widths[c] * dx);
				}
			}

			
			for (int r = 0, y = insets.top, i = 0; r < nrows; y += row_heights[r] + vgap, r++) {
				for (int c = 0, x = insets.left; c < ncols; x += col_widths[c] + hgap, c++, i++) {
					if (i < ncomponents) {
						parent.getComponent(i).setBounds(x, y, col_widths[c], row_heights[r]);
					}
				}
			}

		} 
	}


	public void invalidateLayout(Container container) {
		int ncomponents = container.getComponentCount();
		int old_nrows = nrows;
		int old_ncols = ncols;
		if (this.mode == FIXED_NUM_ROWS) {
			nrows = this.size;
			ncols = (ncomponents + nrows - 1) / nrows;
		} else {
			ncols = this.size;
			nrows = (ncomponents + ncols - 1) / ncols;
		}
		if (old_nrows != nrows) {
			row_heights = new int[nrows];
		}
		if (old_ncols != ncols) {
			col_widths = new int[ncols];
		}
	}


	public int getRows() {
		return nrows;
	}


	public int getColumns() {
		return ncols;
	}


	
	public String toString() {
		return getClass().getName() + ""[mode="" + mode + "",size="" + size
			   + "",hgap="" + hgap + "",vgap="" + vgap + ""]"";
	}


	
	private Dimension getLayoutSize(Container parent, int which) {
		synchronized (parent.getTreeLock()){
			int ncomponents = parent.getComponentCount();
			int h = 0;
			int w = 0;

			for (int r = 0, i = 0; r < nrows; r++) {
				int row_height = 0;
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						switch (which) {
							case 0:
								row_height = Math.max(row_height, parent.getComponent(i).getMinimumSize().height);
								break;
							case 1:
								row_height = Math.max(row_height, parent.getComponent(i).getMaximumSize().height);
								break;
							default:
								row_height = Math.max(row_height, parent.getComponent(i).getPreferredSize().height);
								break;
						}
					} else {
						break;
					}
				}
				h += row_height;
			}

			for (int c = 0; c < ncols; c++) {
				int col_width = 0;
				for (int r = 0; r < nrows; r++) {
					int i = r * ncols + c;
					if (i < ncomponents) {
						switch (which) {
							case 0:
								col_width = Math.max(col_width, parent.getComponent(i).getMinimumSize().width);
								break;
							case 1:
								col_width = Math.max(col_width, parent.getComponent(i).getMaximumSize().width);
								break;
							default:
								col_width = Math.max(col_width, parent.getComponent(i).getPreferredSize().width);
								break;
						}
					} else {
						break;
					}
				}
				w += col_width;
			}

			Insets insets = parent.getInsets();
			return new Dimension(w + insets.left + insets.right + ((ncols - 1) * hgap),
								 h + insets.top + insets.bottom + ((nrows - 1) * vgap));
		}
	}


	private int mode;
	private int size;
	private int hgap;
	private int vgap;
	private transient int nrows = -1;
	private transient int ncols = -1;
	private transient int[] row_heights = null;
	private transient int[] col_widths = null;
}
"
jEdit,4,org.gjt.sp.jedit.options.GutterOptionPane,3,6,0,4,24,1,1,3,3,0.5,230,1.0,1,0.996987952,1.0,2,4,73.0,3,1.6667,1,"

package org.gjt.sp.jedit.options;

import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;

public class GutterOptionPane extends AbstractOptionPane
{
	public GutterOptionPane()
	{
		super(""gutter"");
	}

	public void _init()
	{
		lineNumbersEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.lineNumbers""));
		lineNumbersEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		addComponent(lineNumbersEnabled);

		
		gutterFont = new FontSelector(
			jEdit.getFontProperty(""view.gutter.font"",
			new Font(""Monospaced"",Font.PLAIN,10)));

		addComponent(jEdit.getProperty(""options.gutter.font""),gutterFont);

		gutterBorderWidth = new JTextField(jEdit.getProperty(
			""view.gutter.borderWidth""));
		addComponent(jEdit.getProperty(""options.gutter.borderWidth""),
			gutterBorderWidth);

		gutterHighlightInterval = new JTextField(jEdit.getProperty(
			""view.gutter.highlightInterval""));
		addComponent(jEdit.getProperty(""options.gutter.interval""),
			gutterHighlightInterval);

		String[] alignments = new String[] {
			""Left"", ""Center"", ""Right""
		};
		gutterNumberAlignment = new JComboBox(alignments);
		String alignment = jEdit.getProperty(""view.gutter.numberAlignment"");
		if(""right"".equals(alignment))
			gutterNumberAlignment.setSelectedIndex(2);
		else if(""center"".equals(alignment))
			gutterNumberAlignment.setSelectedIndex(1);
		else
			gutterNumberAlignment.setSelectedIndex(0);
		addComponent(jEdit.getProperty(""options.gutter.numberAlignment""),
			gutterNumberAlignment);

		gutterCurrentLineHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.currentLineHighlight""));
		gutterCurrentLineHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		addComponent(gutterCurrentLineHighlightEnabled);

		gutterBracketHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.bracketHighlight""));
		gutterBracketHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.bracketHighlight""));
		addComponent(gutterBracketHighlightEnabled);

		gutterMarkerHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.markerHighlight""));
		gutterMarkerHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		addComponent(gutterMarkerHighlightEnabled);
	}

	public void _save()
	{
		jEdit.setFontProperty(""view.gutter.font"",gutterFont.getFont());

		jEdit.setProperty(""view.gutter.borderWidth"",
			gutterBorderWidth.getText());
		jEdit.setProperty(""view.gutter.highlightInterval"",
			gutterHighlightInterval.getText());
		String alignment = null;
		switch(gutterNumberAlignment.getSelectedIndex())
		{
		case 2:
			alignment = ""right"";
			break;
		case 1:
			alignment = ""center"";
			break;
		case 0: default:
			alignment = ""left"";
		}
		jEdit.setProperty(""view.gutter.numberAlignment"", alignment);
		jEdit.setBooleanProperty(""view.gutter.lineNumbers"", lineNumbersEnabled
			.isSelected());
		jEdit.setBooleanProperty(""view.gutter.highlightCurrentLine"",
			gutterCurrentLineHighlightEnabled.isSelected());
		jEdit.setBooleanProperty(""view.gutter.bracketHighlight"",
			gutterBracketHighlightEnabled.isSelected());
		jEdit.setBooleanProperty(""view.gutter.markerHighlight"",
			gutterMarkerHighlightEnabled.isSelected());
	}

	
	private FontSelector gutterFont;
	private JTextField gutterBorderWidth;
	private JTextField gutterHighlightInterval;
	private JComboBox gutterNumberAlignment;
	private JCheckBox lineNumbersEnabled;
	private JCheckBox gutterCurrentLineHighlightEnabled;
	private JCheckBox gutterBracketHighlightEnabled;
	private JCheckBox gutterMarkerHighlightEnabled;
}
"
jEdit,4,org.gjt.sp.jedit.options.StyleOptionPane,8,6,0,7,31,20,5,4,1,0.761904762,119,0.666666667,1,0.991017964,0.5,4,12,13.5,1,0.75,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.*;




public class StyleOptionPane extends AbstractOptionPane
{
	public static final EmptyBorder noFocusBorder = new EmptyBorder(1,1,1,1);

	
	public StyleOptionPane()
	{
		super(""style"");
	}
	

	

	
	protected void _init()
	{
		setLayout(new BorderLayout());
		add(BorderLayout.CENTER,createStyleTableScroller());
	} 

	
	protected void _save()
	{
		styleModel.save();
	} 

	

	
	private StyleTableModel styleModel;
	private JTable styleTable;

	
	private JScrollPane createStyleTableScroller()
	{
		styleModel = createStyleTableModel();
		styleTable = new JTable(styleModel);
		styleTable.setRowSelectionAllowed(false);
		styleTable.setColumnSelectionAllowed(false);
		styleTable.setCellSelectionEnabled(false);
		styleTable.getTableHeader().setReorderingAllowed(false);
		styleTable.addMouseListener(new MouseHandler());
		TableColumnModel tcm = styleTable.getColumnModel();
 		TableColumn styleColumn = tcm.getColumn(1);
		styleColumn.setCellRenderer(new StyleTableModel.StyleRenderer());
		Dimension d = styleTable.getPreferredSize();
		d.height = Math.min(d.height,100);
		JScrollPane scroller = new JScrollPane(styleTable);
		scroller.setPreferredSize(d);
		return scroller;
	} 

	
	private StyleTableModel createStyleTableModel()
	{
		return new StyleTableModel();
	} 

	

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = styleTable.rowAtPoint(evt.getPoint());
			if(row == -1)
				return;

			SyntaxStyle style = new StyleEditor(
				StyleOptionPane.this,
				(SyntaxStyle)styleModel.getValueAt(
				row,1)).getStyle();
			if(style != null)
				styleModel.setValueAt(style,row,1);
		}
	} 
} 


class StyleTableModel extends AbstractTableModel
{
	private Vector styleChoices;

	
	StyleTableModel()
	{
		styleChoices = new Vector(13);
		addStyleChoice(""options.style.comment1Style"",""view.style.comment1"");
		addStyleChoice(""options.style.comment2Style"",""view.style.comment2"");
		addStyleChoice(""options.style.literal1Style"",""view.style.literal1"");
		addStyleChoice(""options.style.literal2Style"",""view.style.literal2"");
		addStyleChoice(""options.style.labelStyle"",""view.style.label"");
		addStyleChoice(""options.style.keyword1Style"",""view.style.keyword1"");
		addStyleChoice(""options.style.keyword2Style"",""view.style.keyword2"");
		addStyleChoice(""options.style.keyword3Style"",""view.style.keyword3"");
		addStyleChoice(""options.style.functionStyle"",""view.style.function"");
		addStyleChoice(""options.style.markupStyle"",""view.style.markup"");
		addStyleChoice(""options.style.operatorStyle"",""view.style.operator"");
		addStyleChoice(""options.style.digitStyle"",""view.style.digit"");
		addStyleChoice(""options.style.invalidStyle"",""view.style.invalid"");
		MiscUtilities.quicksort(styleChoices,new MiscUtilities.StringCompare());
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return styleChoices.size();
	} 

	
	public Object getValueAt(int row, int col)
	{
		StyleChoice ch = (StyleChoice)styleChoices.elementAt(row);
		switch(col)
		{
		case 0:
			return ch.label;
		case 1:
			return ch.style;
		default:
			return null;
		}
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		StyleChoice ch = (StyleChoice)styleChoices.elementAt(row);
		if(col == 1)
			ch.style = (SyntaxStyle)value;
		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.style.object"");
		case 1:
			return jEdit.getProperty(""options.style.style"");
		default:
			return null;
		}
	} 

	
	public void save()
	{
		for(int i = 0; i < styleChoices.size(); i++)
		{
			StyleChoice ch = (StyleChoice)styleChoices
				.elementAt(i);
			jEdit.setProperty(ch.property,
				GUIUtilities.getStyleString(ch.style));
		}
	} 

	
	private void addStyleChoice(String label, String property)
	{
		styleChoices.addElement(new StyleChoice(jEdit.getProperty(label),
			property,
			GUIUtilities.parseStyle(jEdit.getProperty(property),
			""Dialog"",12)));
	} 

	
	static class StyleChoice
	{
		String label;
		String property;
		SyntaxStyle style;

		StyleChoice(String label, String property, SyntaxStyle style)
		{
			this.label = label;
			this.property = property;
			this.style = style;
		}

		
		public String toString()
		{
			return label;
		}
	} 

	
	static class StyleRenderer extends JLabel
		implements TableCellRenderer
	{
		
		public StyleRenderer()
		{
			setOpaque(true);
			setBorder(StyleOptionPane.noFocusBorder);
			setText(""Hello World"");
		} 

		
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (value != null)
			{
				SyntaxStyle style = (SyntaxStyle)value;
				setForeground(style.getForegroundColor());
				if (style.getBackgroundColor() != null) 
					setBackground(style.getBackgroundColor());
				else
				{
					
					setBackground(jEdit.getColorProperty(
						""view.bgColor""));
				}
				setFont(style.getFont());
			}

			setBorder((cellHasFocus) ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: StyleOptionPane.noFocusBorder);
			return this;
		} 
	} 
} 


class StyleEditor extends EnhancedDialog implements ActionListener
{
	
	StyleEditor(Component comp, SyntaxStyle style)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""style-editor.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridx = cons.gridy = 0;
		cons.gridwidth = 2;
		cons.gridheight = 1;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = 0.0f;
		cons.insets = new Insets(0,0,12,0);

		italics = new JCheckBox(jEdit.getProperty(""style-editor.italics""));
		italics.setSelected(style.getFont().isItalic());
		layout.setConstraints(italics,cons);
		panel.add(italics);

		cons.gridy++;
		bold = new JCheckBox(jEdit.getProperty(""style-editor.bold""));
		bold.setSelected(style.getFont().isBold());
		layout.setConstraints(bold,cons);
		panel.add(bold);

		cons.gridy++;
		cons.gridwidth = 1;
		Color fg = style.getForegroundColor();
		fgColorCheckBox = new JCheckBox(jEdit.getProperty(""style-editor.fgColor""));
		fgColorCheckBox.setSelected(fg != null);
		fgColorCheckBox.addActionListener(this);
		layout.setConstraints(fgColorCheckBox,cons);
		panel.add(fgColorCheckBox);

		cons.gridx++;
		fgColor = new JButton(""    "");
		fgColor.setEnabled(fg != null);
		fgColor.setRequestFocusEnabled(false);
		fgColor.addActionListener(this);
		fgColor.setMargin(new Insets(0,0,0,0));
		if(fg == null)
			fgColor.setBackground(jEdit.getColorProperty(""view.fgColor""));
		else
			fgColor.setBackground(fg);
		layout.setConstraints(fgColor,cons);
		panel.add(fgColor);

		cons.gridx = 0;
		cons.gridy++;
		Color bg = style.getBackgroundColor();
		bgColorCheckBox = new JCheckBox(jEdit.getProperty(""style-editor.bgColor""));
		bgColorCheckBox.setSelected(bg != null);
		bgColorCheckBox.addActionListener(this);
		layout.setConstraints(bgColorCheckBox,cons);
		panel.add(bgColorCheckBox);

		cons.gridx++;
		bgColor = new JButton(""    "");
		bgColor.setEnabled(bg != null);
		bgColor.setRequestFocusEnabled(false);
		bgColor.addActionListener(this);
		bgColor.setMargin(new Insets(0,0,0,0));
		if(bg == null)
			bgColor.setBackground(jEdit.getColorProperty(""view.bgColor""));
		else
			bgColor.setBackground(bg);
		layout.setConstraints(bgColor,cons);
		panel.add(bgColor);

		content.add(BorderLayout.CENTER,panel);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		box.add(ok = new JButton(jEdit.getProperty(""common.ok"")));
		getRootPane().setDefaultButton(ok);
		ok.addActionListener(this);
		box.add(Box.createHorizontalStrut(6));
		box.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(this);
		box.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,box);

		Dimension screen = getToolkit().getScreenSize();
		pack();
		setLocationRelativeTo(JOptionPane.getFrameForComponent(comp));
		show();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
		else if(source == fgColor || source == bgColor)
		{
			JButton b = (JButton)source;
			Color c = JColorChooser.showDialog(this,
				jEdit.getProperty(""colorChooser.title""),
				b.getBackground());
			if(c != null)
				b.setBackground(c);
		}
		else if(source == fgColorCheckBox)
			fgColor.setEnabled(fgColorCheckBox.isSelected());
		else if(source == bgColorCheckBox)
			bgColor.setEnabled(bgColorCheckBox.isSelected());
	} 

	
	public void ok()
	{
		okClicked = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public SyntaxStyle getStyle()
	{
		if(!okClicked)
			return null;

		Color foreground = (fgColorCheckBox.isSelected()
			? fgColor.getBackground()
			: null);

		Color background = (bgColorCheckBox.isSelected()
			? bgColor.getBackground()
			: null);

		return new SyntaxStyle(foreground,background,
				new Font(""Dialog"",
				(italics.isSelected() ? Font.ITALIC : 0)
				| (bold.isSelected() ? Font.BOLD : 0),
				12));
	} 

	
	private JCheckBox italics;
	private JCheckBox bold;
	private JCheckBox fgColorCheckBox;
	private JButton fgColor;
	private JCheckBox bgColorCheckBox;
	private JButton bgColor;
	private JButton ok;
	private JButton cancel;
	private boolean okClicked;
	
} 
"
jEdit,4,org.gjt.sp.jedit.buffer.DummyFoldHandler,2,2,0,2,3,1,2,2,2,2.0,8,0.0,0,0.875,0.625,0,0,3.0,1,0.5,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;


public class DummyFoldHandler extends FoldHandler
{
	
	public DummyFoldHandler()
	{
		super(""none"");
	}
	

	
	
	public int getFoldLevel(Buffer buffer, int lineIndex, Segment seg)
	{
		return 0;
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.RecentDirectoriesMenu,2,8,0,13,28,1,3,13,2,2.0,120,0.0,0,0.998835856,0.75,3,4,59.0,8,4.0,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.*;


public class RecentDirectoriesMenu extends EnhancedMenu
{
	
	public RecentDirectoriesMenu()
	{
		super(""recent-directories"");
	} 

	
	public void setPopupMenuVisible(boolean b)
	{
		if(b)
		{
			final View view = GUIUtilities.getView(this);

			if(getMenuComponentCount() != 0)
				removeAll();

			
			ActionListener actionListener = new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					VFSBrowser.browseDirectory(view,evt.getActionCommand());

					view.getStatus().setMessage(null);
				}
			}; 

			
			MouseListener mouseListener = new MouseAdapter()
			{
				public void mouseEntered(MouseEvent evt)
				{
					view.getStatus().setMessage(
						((JMenuItem)evt.getSource())
						.getActionCommand());
				}

				public void mouseExited(MouseEvent evt)
				{
					view.getStatus().setMessage(null);
				}
			}; 

			HistoryModel model = HistoryModel.getModel(""vfs.browser.path"");
			if(model.getSize() == 0)
			{
				add(GUIUtilities.loadMenuItem(""no-recent-dirs""));
				super.setPopupMenuVisible(b);
				return;
			}

			boolean sort = jEdit.getBooleanProperty(""sortRecent"");

			Vector menuItems = new Vector();

			for(int i = 0; i < model.getSize(); i++)
			{
				String path = model.getItem(i);
				VFS vfs = VFSManager.getVFSForPath(path);
				JMenuItem menuItem = new JMenuItem(vfs.getFileName(path));
				menuItem.setActionCommand(path);
				menuItem.addActionListener(actionListener);
				menuItem.addMouseListener(mouseListener);
				menuItem.setIcon(FileCellRenderer.dirIcon);

				if(sort)
					menuItems.addElement(menuItem);
				else
					add(menuItem);
			}

			if(sort)
			{
				MiscUtilities.quicksort(menuItems,
					new MiscUtilities.MenuItemCompare());
				for(int i = 0; i < menuItems.size(); i++)
				{
					add((JMenuItem)menuItems.elementAt(i));
				}
			}
		}

		super.setPopupMenuVisible(b);
	} 
}
"
jEdit,4,org.gjt.sp.jedit.buffer.RootElement,11,1,0,2,16,35,1,2,11,0.6,52,1.0,1,0.0,0.424242424,0,0,3.636363636,1,0.9091,0,"

package org.gjt.sp.jedit.buffer;


import javax.swing.text.*;
import org.gjt.sp.jedit.Buffer;



public class RootElement implements Element
{
	
	public RootElement(Buffer buffer)
	{
		this.buffer = buffer;
	} 

	
	public Document getDocument()
	{
		return null;
	} 

	
	public Element getParentElement()
	{
		return null;
	} 

	
	public String getName()
	{
		return null;
	} 

	
	public AttributeSet getAttributes()
	{
		return null;
	} 

	
	public int getStartOffset()
	{
		return 0;
	} 

	
	public int getEndOffset()
	{
		return buffer.getLength() + 1;
	} 

	
	public int getElementIndex(int offset)
	{
		return buffer.getLineOfOffset(offset);
	} 

	
	public int getElementCount()
	{
		return buffer.getLineCount();
	} 

	
	public Element getElement(int line)
	{
		return new LineElement(buffer,line);
	} 

	
	public boolean isLeaf()
	{
		return false;
	} 

	
	private Buffer buffer;
	
} 
"
jEdit,4,org.gjt.sp.jedit.buffer.IndentFoldHandler,2,2,0,2,6,1,1,2,2,2.0,65,0.0,0,0.875,0.625,0,0,31.5,5,2.5,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;


public class IndentFoldHandler extends FoldHandler
{
	public IndentFoldHandler()
	{
		super(""indent"");
	}

	
	
	public int getFoldLevel(Buffer buffer, int lineIndex, Segment seg)
	{
		int tabSize = buffer.getTabSize();

		buffer.getLineText(lineIndex,seg);

		int offset = seg.offset;
		int count = seg.count;

		int whitespace = 0;

		boolean seenNonWhiteSpace = false;

loop:		for(int i = 0; i < count; i++)
		{
			switch(seg.array[offset + i])
			{
			case ' ':
				whitespace++;
				break;
			case '\t':
				whitespace += (tabSize - whitespace % tabSize);
				break;
			default:
				seenNonWhiteSpace = true;
				break loop;
			}
		}

		if(!seenNonWhiteSpace)
		{
			
			if(lineIndex != 0)
				return buffer.getFoldLevel(lineIndex - 1);
			else
				return 0;
		}
			return whitespace;
	} 
}
"
jEdit,4,org.gjt.sp.jedit.BeanShellAction,7,2,0,7,19,5,1,6,7,0.80952381,146,1.0,0,0.7,0.392857143,1,1,18.85714286,2,1.2857,0,"

package org.gjt.sp.jedit;

import java.awt.event.ActionEvent;
import java.awt.*;
import org.gjt.sp.jedit.gui.BeanShellErrorDialog;
import org.gjt.sp.util.Log;

public class BeanShellAction extends EditAction
{
	public BeanShellAction(String name, String code, String isSelected,
		boolean noRepeat, boolean noRecord)
	{
		super(name);

		this.code = code;
		this.isSelected = isSelected;
		this.noRepeat = noRepeat;
		this.noRecord = noRecord;

		
		sanitizedName = name.replace('.','_').replace('-','_');

		
		
		if(isSelected != null)
		{
			String cachedIsSelectedName = ""selected_"" + sanitizedName;
			try
			{
				cachedIsSelected = BeanShell.cacheBlock(cachedIsSelectedName,
					isSelected,true);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);

				new BeanShellErrorDialog(null,e.toString());
			}
		}
	}

	public void invoke(View view)
	{
		try
		{
			if(cachedCode == null)
			{
				String cachedCodeName = ""action_"" + sanitizedName;
				cachedCode = BeanShell.cacheBlock(cachedCodeName,code,true);
			}

			BeanShell.runCachedBlock(cachedCode,view,null);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);

			new BeanShellErrorDialog(view,e.toString());
		}
	}

	public boolean isToggle()
	{
		return isSelected != null;
	}

	public boolean isSelected(View view)
	{
		if(isSelected == null)
			return false;

		try
		{
			return Boolean.TRUE.equals(BeanShell.runCachedBlock(
				cachedIsSelected,view,null));
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);

			new BeanShellErrorDialog(view,e.toString());

			return false;
		}
	}

	public boolean noRepeat()
	{
		return noRepeat;
	}

	public boolean noRecord()
	{
		return noRecord;
	}

	public String getCode()
	{
		return code.trim();
	}

	
	private boolean noRepeat;
	private boolean noRecord;
	private String code;
	private String isSelected;
	private String cachedCode;
	private String cachedIsSelected;
	private String sanitizedName;
}
"
jEdit,4,org.gjt.sp.jedit.textarea.ChunkCache,18,1,0,14,71,27,6,10,5,0.705882353,1598,1.0,2,0.0,0.155555556,0,0,87.38888889,33,7.2222,9,"

package org.gjt.sp.jedit.textarea;


import javax.swing.text.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.*;
import java.util.ArrayList;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;



public class ChunkCache
{
	
	
	public static void lineToChunkList(Segment seg, Token tokens,
		SyntaxStyle[] styles, FontRenderContext fontRenderContext,
		TabExpander e, float wrapMargin, java.util.List out)
	{
		
		if(wrapMargin != 0.0f)
			wrapMargin += 2.0f;

		float x = 0.0f;
		float endX = 0.0f;
		boolean seenNonWhiteSpace = false;
		boolean addedNonWhiteSpace = false;
		boolean lastWasSpace = false;
		float firstNonWhiteSpace = 0.0f;

		Chunk first = null;
		Chunk current = null;
		Chunk end = null;

		int tokenListOffset = 0;

		while(tokens.id != Token.END)
		{
			int flushIndex = tokenListOffset;

			for(int i = tokenListOffset; i < tokenListOffset + tokens.length; i++)
			{
				char ch = seg.array[seg.offset + i];

				if(ch == '\t' || (ch == ' ' && wrapMargin != 0.0f))
				{
					
					
					if(i != flushIndex)
					{
						Chunk newChunk = new Chunk(
							tokens.id,seg,flushIndex,
							i,styles,fontRenderContext);
						if(current != null)
							current.next = newChunk;
						current = newChunk;

						x += newChunk.width;
						lastWasSpace = false;
						seenNonWhiteSpace = true;
					}

					if(end != null
						&& !lastWasSpace
						&& addedNonWhiteSpace
						&& wrapMargin != 0
						&& x > wrapMargin)
					{
						if(first != null)
							out.add(first);
						first = new Chunk(firstNonWhiteSpace,end.offset + 1);
						first.next = end.next;
						end.next = null;

						x = x + firstNonWhiteSpace - endX;
					}

					if(first == null)
						first = current;
					

					
					if(ch == ' ')
					{
						Chunk newChunk = new Chunk(
							tokens.id,seg,i,i + 1,
							styles,fontRenderContext);
						if(first == null)
							first = current = newChunk;
						else
						{
							current.next = newChunk;
							current = newChunk;
						}

						x += current.width;
					} 
					
					else if(ch == '\t')
					{
						Chunk newChunk = new Chunk(
							tokens.id,seg,i,i,
							styles,fontRenderContext);
						if(first == null)
							first = current = newChunk;
						else
						{
							current.next = newChunk;
							current = newChunk;
						}

						float newX = e.nextTabStop(x,i + tokenListOffset);
						current.width = newX - x;
						x = newX;
						current.length = 1;
					} 

					if(first == null)
						first = current;

					end = current;
					endX = x;

					if(flushIndex != i + 1)
						flushIndex = i + 1;

					lastWasSpace = true;
					addedNonWhiteSpace = seenNonWhiteSpace;

					if(!seenNonWhiteSpace)
						firstNonWhiteSpace = x;
				}
				else if(i == tokenListOffset + tokens.length - 1)
				{
					if(flushIndex != i + 1)
					{
						Chunk newChunk = new Chunk(
							tokens.id,seg,flushIndex,
							i + 1,styles,fontRenderContext);
						if(current != null)
							current.next = newChunk;
						current = newChunk;

						x += newChunk.width;
						seenNonWhiteSpace = true;
						lastWasSpace = false;
					}

					if(i == seg.count - 1 && wrapMargin != 0
						&& x > wrapMargin
						&& addedNonWhiteSpace
						&& end != null)
					{
						if(first != null)
							out.add(first);
						first = new Chunk(firstNonWhiteSpace,end.offset + 1);
						first.next = end.next;
						end.next = null;

						x = x + firstNonWhiteSpace - endX;
					}

					if(first == null)
						first = current;

					addedNonWhiteSpace = seenNonWhiteSpace;
				}
			}

			tokenListOffset += tokens.length;
			tokens = tokens.next;
		}

		if(first != null)
			out.add(first);
	} 

	
	
	public static float paintChunkList(Chunk chunks, Graphics2D gfx,
		float x, float y, Color background, boolean glyphVector)
	{
		FontMetrics forBackground = gfx.getFontMetrics();

		float _x = 0.0f;

		Chunk first = chunks;

		Font lastFont = null;
		Color lastColor = null;

		while(chunks != null)
		{
			if(!chunks.inaccessable)
			{
				Font font = chunks.style.getFont();
				Color bgColor = chunks.style.getBackgroundColor();
				if(bgColor != null)
				{
					float x2 = _x + chunks.width;

					
					
					
					
					Graphics2D xorGfx = (Graphics2D)gfx.create();
					xorGfx.setXORMode(background);
					xorGfx.setColor(bgColor);

					xorGfx.fill(new Rectangle2D.Float(
						x + _x,y - forBackground.getAscent(),
						x2 - _x,forBackground.getHeight()));

					xorGfx.dispose();
				}

				if(chunks.str != null)
				{
					gfx.setFont(font);
					gfx.setColor(chunks.style.getForegroundColor());

					if(glyphVector)
						gfx.drawGlyphVector(chunks.text,x + _x,y);
					else
						gfx.drawString(chunks.str,x + _x,y);

					
					
					
				}
			}

			_x += chunks.width;
			chunks = chunks.next;
		}

		return _x;
	} 

	
	
	public static float offsetToX(Chunk chunks, int offset)
	{
		if(chunks != null && offset < chunks.offset)
		{
			throw new ArrayIndexOutOfBoundsException(offset + "" < ""
				+ chunks.offset);
		}

		float x = 0.0f;

		while(chunks != null)
		{
			if(!chunks.inaccessable && offset < chunks.offset + chunks.length)
			{
				if(chunks.text == null)
					break;
				else
				{
					return x + chunks.positions[
						(offset - chunks.offset) * 2];
				}
			}

			x += chunks.width;
			chunks = chunks.next;
		}

		return x;
	} 

	
	
	public static int xToOffset(Chunk chunks, float x, boolean round)
	{
		float _x = 0.0f;

		while(chunks != null)
		{
			if(!chunks.inaccessable && x < _x + chunks.width)
			{
				if(chunks.text == null)
				{
					if(round && _x + chunks.width - x < x - _x)
						return chunks.offset + chunks.length;
					else
						return chunks.offset;
				}
				else
				{
					float xInChunk = x - _x;

					for(int i = 0; i < chunks.length; i++)
					{
						float glyphX = chunks.positions[i*2];
						float nextX = (i == chunks.length - 1
							? chunks.width
							: chunks.positions[i*2+2]);

						if(nextX > xInChunk)
						{
							if(!round || nextX - xInChunk > xInChunk - glyphX)
								return chunks.offset + i;
							else
								return chunks.offset + i + 1;
						}
					}
				}
			}

			_x += chunks.width;
			chunks = chunks.next;
		}

		return -1;
	} 

	
	
	public static class Chunk
	{
		
		public boolean inaccessable;

		public float width;
		public SyntaxStyle style;
		public int offset;
		public int length;
		public String str;
		public GlyphVector text;
		public float[] positions;

		public Chunk next;

		Chunk(float width, int offset)
		{
			inaccessable = true;
			this.width = width;
			this.offset = offset;
		}

		Chunk(int tokenType, Segment seg, int offset, int end,
			SyntaxStyle[] styles, FontRenderContext fontRenderContext)
		{
			style = styles[tokenType];

			if(offset != end)
			{
				length = end - offset;
				str = new String(seg.array,seg.offset + offset,length);

				text = style.getFont().createGlyphVector(
					fontRenderContext,str);
				width = (float)text.getLogicalBounds().getWidth();
				positions = text.getGlyphPositions(0,length,null);
			}

			this.offset = offset;
		}
	} 

	
	ChunkCache(JEditTextArea textArea)
	{
		this.textArea = textArea;
		out = new ArrayList();
	} 

	
	int getMaxHorizontalScrollWidth()
	{
		int max = 0;
		for(int i = 0; i < lineInfo.length; i++)
		{
			LineInfo info = lineInfo[i];
			if(info.chunksValid && info.width > max)
				max = info.width;
		}
		return max;
	} 

	
	int getScreenLineOfOffset(int line, int offset)
	{
		if(line < textArea.getFirstPhysicalLine())
		{
			return -1;
		}
		else if(line > textArea.getLastPhysicalLine())
		{
			return -1;
		}
		else if(!textArea.softWrap)
		{
			return textArea.physicalToVirtual(line)
				- textArea.getFirstLine();
		}
		else
		{
			int screenLine;

			if(line == lastScreenLineP)
			{
				LineInfo last = lineInfo[lastScreenLine];

				if(offset >= last.offset
					&& offset < last.offset + last.length)
				{
					updateChunksUpTo(lastScreenLine);
					return lastScreenLine;
				}
			}

			screenLine = -1;

			
			for(int i = 0; i < lineInfo.length; i++)
			{
				updateChunksUpTo(i);

				LineInfo info = getLineInfo(i);
				if(info.physicalLine > line)
				{
					
					if(i == 0)
						screenLine = 0;
					else
						screenLine = i - 1;
					break;
				}
				else if(info.physicalLine == line)
				{
					if(offset >= info.offset
						&& offset < info.offset + info.length)
					{
						screenLine = i;
						break;
					}
				}
			}

			if(screenLine == -1)
				return -1;
			else
			{
				lastScreenLineP = line;
				lastScreenLine = screenLine;

				return screenLine;
			}
		}
	} 

	
	void recalculateVisibleLines()
	{
		lineInfo = new LineInfo[textArea.getVisibleLines() + 1];
		for(int i = 0; i < lineInfo.length; i++)
			lineInfo[i] = new LineInfo();

		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void setFirstLine(int firstLine)
	{
		if(textArea.softWrap || Math.abs(firstLine - this.firstLine) >= lineInfo.length)
		{
			for(int i = 0; i < lineInfo.length; i++)
			{
				lineInfo[i].chunksValid = false;
			}
		}
		else if(firstLine > this.firstLine)
		{
			System.arraycopy(lineInfo,firstLine - this.firstLine,
				lineInfo,0,lineInfo.length - firstLine
				+ this.firstLine);

			for(int i = lineInfo.length - firstLine
				+ this.firstLine; i < lineInfo.length; i++)
			{
				lineInfo[i] = new LineInfo();
			}
		}
		else if(this.firstLine > firstLine)
		{
			System.arraycopy(lineInfo,0,lineInfo,this.firstLine - firstLine,
				lineInfo.length - this.firstLine + firstLine);

			for(int i = 0; i < this.firstLine - firstLine; i++)
			{
				lineInfo[i] = new LineInfo();
			}
		}

		lastScreenLine = lastScreenLineP = -1;
		this.firstLine = firstLine;
	} 

	
	void invalidateAll()
	{
		for(int i = 0; i < lineInfo.length; i++)
		{
			lineInfo[i].chunksValid = false;
		}

		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void invalidateChunksFrom(int screenLine)
	{
		for(int i = screenLine; i < lineInfo.length; i++)
		{
			lineInfo[i].chunksValid = false;
		}

		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void invalidateChunksFromPhys(int physicalLine)
	{
		for(int i = 0; i < lineInfo.length; i++)
		{
			if(lineInfo[i].physicalLine >= physicalLine)
			{
				invalidateChunksFrom(i);
				break;
			}
		}
	} 

	
	void lineToChunkList(int physicalLine, ArrayList out)
	{
		TextAreaPainter painter = textArea.getPainter();
		Buffer buffer = textArea.getBuffer();

		buffer.getLineText(physicalLine,textArea.lineSegment);

		lineToChunkList(textArea.lineSegment,
			buffer.markTokens(physicalLine).getFirstToken(),
			painter.getStyles(),painter.getFontRenderContext(),
			painter,textArea.softWrap
			? textArea.wrapMargin
			: 0.0f,out);
	} 

	
	void updateChunksUpTo(int lastScreenLine)
	{
		if(!textArea.softWrap)
			return;

		if(lineInfo[lastScreenLine].chunksValid)
			return;

		int firstScreenLine = 0;

		for(int i = lastScreenLine; i >= 0; i--)
		{
			if(lineInfo[i].chunksValid)
			{
				firstScreenLine = i + 1;
				break;
			}
		}

		int physicalLine;

		if(firstScreenLine == 0)
		{
			physicalLine = textArea.getFirstPhysicalLine();
		}
		else
		{
			int prevPhysLine = lineInfo[
				firstScreenLine - 1]
				.physicalLine;
			if(prevPhysLine == -1)
				physicalLine = -1;
			else
			{
				physicalLine = textArea
					.getFoldVisibilityManager()
					.getNextVisibleLine(prevPhysLine);
			}
		}

		
		
		
		

		out.clear();

		int offset = 0;
		int length = 0;

		for(int i = firstScreenLine; i <= lastScreenLine; i++)
		{
			LineInfo info = lineInfo[i];

			Chunk chunks;

			if(out.size() == 0)
			{
				if(physicalLine != -1 && i != firstScreenLine)
				{
					physicalLine = textArea.getFoldVisibilityManager()
						.getNextVisibleLine(physicalLine);
				}

				if(physicalLine == -1)
				{
					info.chunks = null;
					info.chunksValid = true;
					info.physicalLine = -1;
					continue;
				}

				lineToChunkList(physicalLine,out);

				info.firstSubregion = true;

				if(out.size() == 0)
				{
					chunks = null;
					offset = 0;
					length = 1;
				}
				else
				{
					chunks = (Chunk)out.get(0);
					out.remove(0);
					offset = 0;
					if(out.size() != 0)
						length = ((Chunk)out.get(0)).offset - offset;
					else
						length = textArea.getLineLength(physicalLine) - offset + 1;
				}
			}
			else
			{
				info.firstSubregion = false;

				chunks = (Chunk)out.get(0);
				out.remove(0);
				offset = chunks.offset;
				if(out.size() != 0)
					length = ((Chunk)out.get(0)).offset - offset;
				else
					length = textArea.getLineLength(physicalLine) - offset + 1;
			}

			boolean lastSubregion = (out.size() == 0);

			if(i == lastScreenLine
				&& lastScreenLine != lineInfo.length - 1)
			{
				
				if(info.physicalLine != physicalLine
					|| info.lastSubregion != lastSubregion)
				{
					lastScreenLine++;
					needFullRepaint = true;
				}
				else if(out.size() != 0)
					lastScreenLine++;
			}

			info.physicalLine = physicalLine;
			info.lastSubregion = lastSubregion;
			info.offset = offset;
			info.length = length;
			info.chunks = chunks;
			info.chunksValid = true;
		}
	} 

	
	LineInfo getLineInfo(int screenLine)
	{
		LineInfo info = lineInfo[screenLine];

		if(textArea.softWrap)
		{
			if(!info.chunksValid)
				Log.log(Log.ERROR,this,""Not up-to-date: "" + screenLine);
			return info;
		}
		else
		{
			if(!info.chunksValid)
			{
				int virtLine = screenLine + firstLine;
				if(virtLine >= textArea.getVirtualLineCount())
				{
					info.chunks = null;
					info.chunksValid = true;
					info.physicalLine = -1;
				}
				else
				{
					info.physicalLine = textArea.getFoldVisibilityManager()
						.virtualToPhysical(virtLine);

					out.clear();

					lineToChunkList(info.physicalLine,out);

					info.firstSubregion = true;
					info.lastSubregion = true;
					info.offset = 0;
					info.length = textArea.getLineLength(info.physicalLine) + 1;
					info.chunks = (out.size() == 0 ? null :
						(Chunk)out.get(0));
					info.chunksValid = true;
				}
			}

			return info;
		}
	} 

	
	public LineInfo[] getLineInfosForPhysicalLine(int physicalLine)
	{
		out.clear();
		lineToChunkList(physicalLine,out);

		if(out.size() == 0)
			out.add(null);

		LineInfo[] returnValue = new LineInfo[out.size()];

		for(int i = 0; i < out.size(); i++)
		{
			Chunk chunks = (Chunk)out.get(i);
			LineInfo info = new LineInfo();
			info.physicalLine = physicalLine;
			if(i == 0)
			{
				info.firstSubregion = true;
				info.offset = 0;
			}
			else
				info.offset = chunks.offset;

			if(i == out.size() - 1)
			{
				info.lastSubregion = true;
				info.length = textArea.getLineLength(physicalLine)
					- info.offset + 1;
			}
			else
			{
				info.length = ((Chunk)out.get(i + 1)).offset
					- info.offset;
			}

			info.chunksValid = true;
			info.chunks = chunks;

			returnValue[i] = info;
		}

		return returnValue;
	} 

	
	
	boolean needFullRepaint()
	{
		boolean retVal = needFullRepaint;
		needFullRepaint = false;
		return retVal;
	} 

	
	LineInfo getLineInfoBackwardsCompatibility(int physicalLineIndex)
	{
		LineInfo info = new LineInfo();

		out.clear();
		Buffer buffer = textArea.getBuffer();
		buffer.getLineText(physicalLineIndex,textArea.lineSegment);

		TextAreaPainter painter = textArea.getPainter();
		lineToChunkList(textArea.lineSegment,
			buffer.markTokens(physicalLineIndex).getFirstToken(),
			painter.getStyles(),painter.getFontRenderContext(),
			painter,0.0f,out);

		if(out.size() == 0)
			info.chunks = null;
		else
			info.chunks = (Chunk)out.get(0);

		info.physicalLine = physicalLineIndex;
		info.chunksValid = true;

		return info;
	} 

	
	private JEditTextArea textArea;
	private int firstLine;
	private LineInfo[] lineInfo;
	private ArrayList out;

	private int lastScreenLineP;
	private int lastScreenLine;

	private boolean needFullRepaint;
	

	
	static class LineInfo
	{
		int physicalLine;
		int offset;
		int length;
		boolean firstSubregion;
		boolean lastSubregion;
		boolean chunksValid;
		Chunk chunks;
		int width;
	} 
}
"
jEdit,4,org.gjt.sp.util.ReadWriteLock,9,1,0,2,17,2,1,1,6,0.678571429,236,1.0,0,0.0,1.0,0,0,24.44444444,5,2.8889,0,"

package org.gjt.sp.util;

import java.util.Vector;

public class ReadWriteLock
{
	
	public synchronized void readLock()
	{
		
		
		if (activeReaders != 0 || allowRead())
		{
			++activeReaders;
			
			return;
		}
		++waitingReaders;
		while (!allowRead())
		{
			try
			{
				wait();
			}
			catch (InterruptedException e)
			{
				--waitingReaders; 
				Log.log(Log.ERROR,this,e);
				return;
			}
		}
		--waitingReaders;
		++activeReaders;
		readers.addElement(Thread.currentThread());
	} 

	
	public synchronized void readUnlock()
	{
		if(activeReaders == 0)
			throw new InternalError(""Unbalanced readLock()/readUnlock() calls"");

		--activeReaders;
		
		notifyAll();
	} 

	
	public synchronized void writeLock()
	{
		if (writerThread != null)
		{
			
			if (Thread.currentThread() == writerThread)
			{
				
				++lockCount;
				return;
			}
		}
		if (allowWrite())
		{
			claimWriteLock();
			return;
		}

		++waitingWriters;
		while (!allowWrite())
		{
			try
			{
				wait();
			}
			catch (InterruptedException e)
			{
				--waitingWriters;
				Log.log(Log.ERROR,this,e);
				return;
			}
		}
		--waitingWriters;
		claimWriteLock();
	} 

	
	public synchronized void writeUnlock()
	{
		if(activeWriters != 1 || lockCount <= 0)
			throw new InternalError(""Unbalanced writeLock()/writeUnlock() calls"");

		if(Thread.currentThread() != writerThread)
			throw new InternalError(""writeUnlock() from wrong thread"");

		if (--lockCount == 0)
		{
			--activeWriters;
			writerThread = null;
			notifyAll();
		}
	} 

	
	public synchronized boolean isWriteLocked()
	{
		
		return activeWriters == 1;
	} 

	

	
	private int activeReaders;
	private int activeWriters;
	private int waitingReaders;
	private int waitingWriters;
	private Vector readers = new Vector();

	private Thread writerThread;
	private int lockCount;
	

	
	private final boolean allowRead()
	{
		return (Thread.currentThread() == writerThread)
			|| (waitingWriters == 0 && activeWriters == 0);
	} 

	
	private final boolean allowWrite()
	{
		

		return activeReaders == 0 && activeWriters == 0;
	} 

	
	private void claimWriteLock()
	{
		++activeWriters;
		
		writerThread = Thread.currentThread();
		
		lockCount = 1;
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.OpenWithEncodingMenu,1,8,0,4,15,0,2,4,1,2.0,79,0.0,0,1.0,1.0,0,0,78.0,0,0.0,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.Component;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;


public class OpenWithEncodingMenu extends EnhancedMenu
{
	
	public OpenWithEncodingMenu()
	{
		super(""open-encoding"");

		
		ActionListener listener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				Hashtable props = new Hashtable();
				props.put(""encoding"",evt.getActionCommand());
				jEdit.showOpenFileDialog(GUIUtilities.getView(
					(Component)evt.getSource()),props);
			}
		}; 

		
		String systemEncoding = System.getProperty(""file.encoding"");

		JMenuItem mi = new JMenuItem(jEdit.getProperty(""os-encoding""));
		mi.setActionCommand(systemEncoding);
		mi.addActionListener(listener);
		add(mi);

		mi = new JMenuItem(jEdit.getProperty(""jedit-encoding""));
		mi.setActionCommand(jEdit.getProperty(""buffer.encoding"",systemEncoding));
		mi.addActionListener(listener);
		add(mi);

		addSeparator();

		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			mi = new JMenuItem(st.nextToken());
			mi.addActionListener(listener);
			add(mi);
		}

		addSeparator();

		add(GUIUtilities.loadMenuItem(""other-encoding""));
	} 
}
"
jEdit,4,org.gjt.sp.util.WorkRequest,6,1,3,4,12,15,3,1,6,2.0,49,0.0,0,0.0,0.416666667,0,0,7.166666667,2,1.5,0,"

package org.gjt.sp.util;


public abstract class WorkRequest implements Runnable
{
	
	public void setAbortable(boolean abortable)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setAbortable(abortable);
	}

	
	public void setStatus(String status)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setStatus(status);
	}

	
	public void setProgressValue(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressValue(value);
	}

	
	public void setProgressMaximum(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressMaximum(value);
	}
}
"
jEdit,4,org.gjt.sp.jedit.pluginmgr.InstallPluginsDialog,12,7,0,12,92,28,4,11,2,0.843434343,1013,0.888888889,1,0.983433735,0.214285714,0,0,81.91666667,9,2.6667,0,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


class InstallPluginsDialog extends EnhancedDialog
{
	static final int INSTALL = 0;
	static final int UPDATE = 1;

	
	InstallPluginsDialog(JDialog dialog, Vector model, int mode)
	{
		super(JOptionPane.getFrameForComponent(dialog),
			(mode == INSTALL
			? jEdit.getProperty(""install-plugins.title"")
			: jEdit.getProperty(""update-plugins.title"")),true);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel label = new JLabel(jEdit.getProperty(""install-plugins.caption""));
		content.add(BorderLayout.NORTH,label);

		plugins = new JCheckBoxList(model);
		plugins.getSelectionModel().addListSelectionListener(new ListHandler());
		plugins.getModel().addTableModelListener(new TableModelHandler());
		JScrollPane scroller = new JScrollPane(plugins);
		scroller.setPreferredSize(new Dimension(200,0));
		content.add(BorderLayout.WEST,scroller);

		JPanel panel = new JPanel(new BorderLayout());
		panel.setBorder(new TitledBorder(jEdit.getProperty(""install-plugins""
			+ "".plugin-info"")));

		JPanel labelAndValueBox = new JPanel(new BorderLayout());

		JPanel labelBox = new JPanel(new GridLayout(
			(mode == UPDATE ? 7 : 6),1,0,3));
		labelBox.setBorder(new EmptyBorder(0,0,3,12));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.name""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.author""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.size""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.latest-version""),SwingConstants.RIGHT));
		if(mode == UPDATE)
		{
			labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
				+ "".info.installed-version""),SwingConstants.RIGHT));
		}
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.updated""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.description""),SwingConstants.RIGHT));
		labelAndValueBox.add(BorderLayout.WEST,labelBox);

		JPanel valueBox = new JPanel(new GridLayout(
			(mode == UPDATE ? 7 : 6),1,0,3));
		valueBox.setBorder(new EmptyBorder(0,0,3,0));
		valueBox.add(name = new JLabel());
		valueBox.add(author = new JLabel());
		valueBox.add(size = new JLabel());
		valueBox.add(latestVersion = new JLabel());
		if(mode == UPDATE)
			valueBox.add(installedVersion = new JLabel());
		valueBox.add(updated = new JLabel());
		valueBox.add(Box.createGlue());
		labelAndValueBox.add(BorderLayout.CENTER,valueBox);

		panel.add(BorderLayout.NORTH,labelAndValueBox);

		description = new JTextArea(6,50);
		description.setEditable(false);
		description.setLineWrap(true);
		description.setWrapStyleWord(true);

		panel.add(BorderLayout.CENTER,new JScrollPane(description));

		content.add(BorderLayout.CENTER,panel);

		panel = new JPanel(new BorderLayout(12,0));

		JPanel panel2 = new JPanel(new GridLayout((mode == INSTALL ? 4 : 2),1));

		Box totalSizeBox = new Box(BoxLayout.X_AXIS);
		totalSizeBox.add(new JLabel(jEdit.getProperty(""install-plugins.totalSize"")));
		totalSizeBox.add(Box.createHorizontalStrut(12));
		totalSizeBox.add(totalSize = new JLabel());
		panel2.add(totalSizeBox);

		panel2.add(downloadSource = new JCheckBox(
			jEdit.getProperty(""install-plugins.downloadSource"")));
		downloadSource.setSelected(jEdit.getBooleanProperty(""install-plugins""
			+ "".downloadSource.value""));
		downloadSource.addActionListener(new ActionHandler());

		if(mode == INSTALL)
		{
			ButtonGroup grp = new ButtonGroup();
			installUser = new JRadioButton();
			String settings = jEdit.getSettingsDirectory();
			if(settings == null)
			{
				settings = jEdit.getProperty(""install-plugins.none"");
				installUser.setEnabled(false);
			}
			else
			{
				settings = MiscUtilities.constructPath(settings,""jars"");
				installUser.setEnabled(true);
			}
			String[] args = { settings };
			installUser.setText(jEdit.getProperty(""install-plugins.user"",args));
			grp.add(installUser);
			panel2.add(installUser);

			installSystem = new JRadioButton();
			String jEditHome = jEdit.getJEditHome();
			if(jEditHome == null)
			{
				jEditHome = jEdit.getProperty(""install-plugins.none"");
				installSystem.setEnabled(false);
			}
			else
			{
				jEditHome = MiscUtilities.constructPath(jEditHome,""jars"");
				installSystem.setEnabled(true);
			}
			args[0] = jEditHome;
			installSystem.setText(jEdit.getProperty(""install-plugins.system"",args));
			grp.add(installSystem);
			panel2.add(installSystem);

			if(installUser.isEnabled())
				installUser.setSelected(true);
			else
				installSystem.setSelected(true);
		}

		panel.add(BorderLayout.NORTH,panel2);

		Box box = new Box(BoxLayout.X_AXIS);

		box.add(Box.createGlue());
		install = new JButton(jEdit.getProperty(""install-plugins.install""));
		install.setEnabled(false);
		getRootPane().setDefaultButton(install);
		install.addActionListener(new ActionHandler());
		box.add(install);
		box.add(Box.createHorizontalStrut(6));

		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createHorizontalStrut(6));
		box.add(Box.createGlue());

		panel.add(BorderLayout.SOUTH,box);

		content.add(BorderLayout.SOUTH,panel);

		updateTotalSize();

		pack();
		setLocationRelativeTo(dialog);
		show();
	} 

	
	public void ok()
	{
		jEdit.setBooleanProperty(""install-plugins.downloadSource.value"",
			downloadSource.isSelected());
		dispose();
	} 

	
	public void cancel()
	{
		cancelled = true;

		dispose();
	} 

	
	void installPlugins(Roster roster)
	{
		if(cancelled)
			return;

		String installDirectory;
		if(installUser == null || installUser.isSelected())
		{
			installDirectory = MiscUtilities.constructPath(
				jEdit.getSettingsDirectory(),""jars"");
		}
		else
		{
			installDirectory = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""jars"");
		}

		Object[] selected = plugins.getCheckedValues();
		for(int i = 0; i < selected.length; i++)
		{
			PluginList.Plugin plugin = (PluginList.Plugin)selected[i];
			plugin.install(roster,installDirectory,downloadSource.isSelected());
		}
	} 

	

	
	private JCheckBoxList plugins;
	private JLabel name;
	private JLabel author;
	private JLabel size;
	private JLabel latestVersion;
	private JLabel installedVersion;
	private JLabel updated;
	private JTextArea description;
	private JLabel totalSize;
	private JCheckBox downloadSource;
	private JRadioButton installUser;
	private JRadioButton installSystem;

	private JButton install;
	private JButton cancel;

	private boolean cancelled;
	private Thread thread;
	

	
	private void updateInfo()
	{
		Object selected = plugins.getSelectedValue();
		if(selected instanceof PluginList.Plugin)
		{
			PluginList.Plugin plugin = (PluginList.Plugin)selected;
			PluginList.Branch branch = plugin.getCompatibleBranch();
			name.setText(plugin.name);
			author.setText(plugin.author);
			size.setText(String.valueOf(
				(downloadSource.isSelected()
				? branch.downloadSourceSize
				: branch.downloadSize) / 1024) + "" Kb"");
			if(branch.obsolete)
				latestVersion.setText(jEdit.getProperty(
					""install-plugins.info.obsolete""));
			else
				latestVersion.setText(branch.version);
			if(installedVersion != null)
				installedVersion.setText(plugin.installedVersion);
			updated.setText(branch.date);

			ArrayList deps = new ArrayList();
			createDependencyList(branch.deps,deps);
			StringBuffer buf = new StringBuffer();
			for(int i = 0; i < deps.size(); i++)
			{
				buf.append(""\n- "");
				buf.append(deps.get(i));
			}

			description.setText(plugin.description
				+ (buf.length() == 0 ? """"
				: jEdit.getProperty(""install-plugins.info""
				+ "".also-install"") + buf.toString()
				+ (branch.obsolete ? jEdit.getProperty(
				""install-plugins.info.obsolete-text"") : """")));
			description.setCaretPosition(0);
		}
		else
		{
			name.setText(null);
			author.setText(null);
			latestVersion.setText(null);
			if(installedVersion != null)
				installedVersion.setText(null);
			updated.setText(null);
			description.setText(null);
		}
	} 

	
	private void createDependencyList(Vector deps, ArrayList append)
	{
		for(int i = 0; i < deps.size(); i++)
		{
			PluginList.Dependency dep = (PluginList.Dependency)
				deps.elementAt(i);
			if(dep.what.equals(""plugin"")
				&& !dep.isSatisfied())
			{
				if(!append.contains(dep.plugin))
				{
					append.add(dep.plugin);

					PluginList.Branch branch = dep.plugin
						.getCompatibleBranch();
					createDependencyList(branch.deps,append);
				}
			}
		}
	} 

	
	private void updateTotalSize()
	{
		ArrayList selectedPlugins = new ArrayList();

		Object[] selected = plugins.getCheckedValues();
		install.setEnabled(selected.length != 0);

		for(int i = 0; i < selected.length; i++)
		{
			PluginList.Plugin plugin = (PluginList.Plugin)selected[i];
			if(!selectedPlugins.contains(plugin))
				selectedPlugins.add(plugin);

			createDependencyList(plugin.getCompatibleBranch().deps,
				selectedPlugins);
		}

		int _totalSize = 0;
		for(int i = 0; i < selectedPlugins.size(); i++)
		{
			PluginList.Branch branch = ((PluginList.Plugin)
				selectedPlugins.get(i)).getCompatibleBranch();
			_totalSize += (downloadSource.isSelected()
				? branch.downloadSourceSize
				: branch.downloadSize);
		}

		totalSize.setText(String.valueOf(_totalSize / 1024) + "" Kb"");
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == install)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == downloadSource)
			{
				updateInfo();
				updateTotalSize();
			}
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateInfo();
		}
	} 

	
	class TableModelHandler implements TableModelListener
	{
		public void tableChanged(TableModelEvent e)
		{
			updateTotalSize();
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.syntax.ParserRule,1,1,0,6,2,0,6,0,0,2.0,21,0.0,1,0.0,1.0,0,0,15.0,0,0.0,1,"

package org.gjt.sp.jedit.syntax;


public class ParserRule
{
	
	public final char[] searchChars;
	public final int[] sequenceLengths;
	public final int action;
	public final byte token;
	public ParserRule next;

	
	ParserRule(char[] searchChars, int[] sequenceLengths, int action, byte token)
	{
		this.searchChars = searchChars;
		this.sequenceLengths = sequenceLengths;
		this.action = action;
		this.token = token;
	}
}
"
jEdit,4,org.gjt.sp.jedit.gui.SplashScreen,5,3,0,2,41,4,1,1,5,0.65,213,1.0,0,0.987987988,0.7,2,5,40.6,2,1.0,0,"

package org.gjt.sp.jedit.gui;

import java.awt.*;
import java.net.URL;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.Log;


public class SplashScreen extends Canvas
{
	public SplashScreen()
	{
		setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

		image = getToolkit().getImage(
			getClass().getResource(""/org/gjt/sp/jedit/icons/splash.gif""));
		MediaTracker tracker = new MediaTracker(this);
		tracker.addImage(image,0);

		try
		{
			tracker.waitForAll();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}

		win = new Window(new Frame());

		Dimension screen = getToolkit().getScreenSize();
		Dimension size = new Dimension(image.getWidth(this) + 2,
			image.getHeight(this) + 2);
		win.setSize(size);

		win.setLayout(new BorderLayout());
		win.add(BorderLayout.CENTER,this);

		win.setLocation((screen.width - size.width) / 2,
			(screen.height - size.height) / 2);
		win.validate();
		win.show();

		
	}

	public void dispose()
	{
		win.dispose();
	}

	public synchronized void advance()
	{
		progress++;
		repaint();

		
		
		try
		{
			wait();
		}
		catch(InterruptedException ie)
		{
			Log.log(Log.ERROR,this,ie);
		}
	}

	public void update(Graphics g)
	{
		paint(g);
	}

	public synchronized void paint(Graphics g)
	{
		Dimension size = getSize();

		if(offscreenImg == null)
		{
			offscreenImg = createImage(size.width,size.height);
			offscreenGfx = offscreenImg.getGraphics();
		}

		offscreenGfx.setColor(Color.black);
		offscreenGfx.drawRect(0,0,size.width - 1,size.height - 1);

		offscreenGfx.drawImage(image,1,1,this);

		
		offscreenGfx.setColor(new Color(206,206,229));
		offscreenGfx.fillRect(9,199,(384 * progress) / 7,14);

		g.drawImage(offscreenImg,0,0,this);

		notify();
	}

	
	private Window win;
	private Image image;
	private Image offscreenImg;
	private Graphics offscreenGfx;
	private int progress;
}
"
jEdit,4,org.gjt.sp.jedit.options.ShortcutsOptionPane,12,6,0,12,58,38,5,11,1,0.8,306,1.0,1,0.983655275,0.25,4,12,24.08333333,3,1.5833,0,"

package org.gjt.sp.jedit.options;

import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.GrabKeyDialog;
import org.gjt.sp.jedit.*;


public class ShortcutsOptionPane extends AbstractOptionPane
{
	public ShortcutsOptionPane()
	{
		super(""shortcuts"");
	}

	
	protected void _init()
	{
		allBindings = new Vector();

		setLayout(new BorderLayout(12,12));

		initModels();

		selectModel = new JComboBox(models);
		selectModel.addActionListener(new ActionHandler());

		Box north = Box.createHorizontalBox();
		north.add(new JLabel(jEdit.getProperty(
			""options.shortcuts.select.label"")));
		north.add(Box.createHorizontalStrut(6));
		north.add(selectModel);

		keyTable = new JTable(currentModel);
		keyTable.getTableHeader().setReorderingAllowed(false);
		keyTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		keyTable.addMouseListener(new TableMouseHandler());
		Dimension d = keyTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(keyTable);
		scroller.setPreferredSize(d);

		add(BorderLayout.NORTH,north);
		add(BorderLayout.CENTER,scroller);
	}

	protected void _save()
	{
		if(keyTable.getCellEditor() != null)
			keyTable.getCellEditor().stopCellEditing();

		Enumeration e = models.elements();
		while(e.hasMoreElements())
			((ShortcutsModel)e.nextElement()).save();

		Macros.loadMacros();
	}

	private void initModels()
	{
		models = new Vector();
		ActionSet[] actionSets = jEdit.getActionSets();
		for(int i = 0; i < actionSets.length; i++)
		{
			ActionSet actionSet = actionSets[i];
			if(actionSet.getActionCount() != 0)
			{
				models.addElement(createModel(actionSet.getLabel(),
					actionSet.getActions()));
			}
		}
		currentModel = (ShortcutsModel)models.elementAt(0);
	}

	private ShortcutsModel createModel(String modelLabel, EditAction[] actions)
	{
		Vector bindings = new Vector(actions.length);

		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];

			String name = action.getName();
			String label = action.getLabel();
			
			if(label == null)
				continue;

			label = GUIUtilities.prettifyMenuLabel(label);
			addBindings(name,label,bindings);
		}

		return new ShortcutsModel(modelLabel,bindings);
	}

	private void addBindings(String name, String label, Vector bindings)
	{
		GrabKeyDialog.KeyBinding b[] = new GrabKeyDialog.KeyBinding[2];

		b[0] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut""));
		b[1] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut2""));

		bindings.addElement(b);
	}

	private GrabKeyDialog.KeyBinding createBinding(String name,
		String label, String shortcut)
	{
		if(shortcut != null && shortcut.length() == 0)
			shortcut = null;

		GrabKeyDialog.KeyBinding binding
			= new GrabKeyDialog.KeyBinding(name,label,shortcut,false);

		allBindings.addElement(binding);
		return binding;
	}

	
	private JTable keyTable;
	private Vector models;
	private ShortcutsModel currentModel;
	private JComboBox selectModel;
	private Vector allBindings;

	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(keyTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				currentModel.sort(0);
				break;
			case 1:
				currentModel.sort(1);
				break;
			case 2:
				currentModel.sort(2);
				break;
			}
		}
	}

	class TableMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = keyTable.getSelectedRow();
			int col = keyTable.getSelectedColumn();
			if(col != 0 && row != -1)
			{
				 GrabKeyDialog gkd = new GrabKeyDialog(
					ShortcutsOptionPane.this,
					currentModel.getBindingAt(row,col-1),
					allBindings);
				if(gkd.isOK())
					currentModel.setValueAt(
						gkd.getShortcut(),row,col);
			}
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			ShortcutsModel newModel
				= (ShortcutsModel)selectModel.getSelectedItem();

			if(currentModel != newModel)
			{
				currentModel = newModel;
				keyTable.setModel(currentModel);
			}
		}
	}

	class ShortcutsModel extends AbstractTableModel
	{
		private Vector bindings;
		private String name;

		ShortcutsModel(String name, Vector bindings)
		{
			this.name = name;
			this.bindings = bindings;
			sort(0);
		}

		public void sort(int col)
		{
			MiscUtilities.quicksort(bindings,new KeyCompare(col));
			fireTableDataChanged();
		}

		public int getColumnCount()
		{
			return 3;
		}

		public int getRowCount()
		{
			return bindings.size();
		}

		public Object getValueAt(int row, int col)
		{
			switch(col)
			{
			case 0:
				return getBindingAt(row,0).label;
			case 1:
				return getBindingAt(row,0).shortcut;
			case 2:
				return getBindingAt(row,1).shortcut;
			default:
				return null;
			}
		}

		public void setValueAt(Object value, int row, int col)
		{
			if(col == 0)
				return;

			getBindingAt(row,col-1).shortcut = (String)value;

			
			
			fireTableDataChanged();
		}

		public String getColumnName(int index)
		{
			switch(index)
			{
			case 0:
				return jEdit.getProperty(""options.shortcuts.name"");
			case 1:
				return jEdit.getProperty(""options.shortcuts.shortcut1"");
			case 2:
				return jEdit.getProperty(""options.shortcuts.shortcut2"");
			default:
				return null;
			}
		}

		public void save()
		{
			Enumeration enum = bindings.elements();
			while(enum.hasMoreElements())
			{
				GrabKeyDialog.KeyBinding binding[]
					= (GrabKeyDialog.KeyBinding[])
						enum.nextElement();
				jEdit.setProperty(
					binding[0].name + "".shortcut"",
					binding[0].shortcut);
				jEdit.setProperty(
					binding[1].name + "".shortcut2"",
					binding[1].shortcut);
			}
		}

		public GrabKeyDialog.KeyBinding getBindingAt(int row, int nr)
		{
			GrabKeyDialog.KeyBinding binding[]
				= (GrabKeyDialog.KeyBinding[])
					bindings.elementAt(row);
			return binding[nr];
		}

		public String toString()
		{
			return name;
		}

		class KeyCompare implements MiscUtilities.Compare
		{
			int col;

			KeyCompare(int col)
			{
				this.col = col;
			}

			public int compare(Object obj1, Object obj2)
			{
				GrabKeyDialog.KeyBinding[] k1
					= (GrabKeyDialog.KeyBinding[])obj1;
				GrabKeyDialog.KeyBinding[] k2
					= (GrabKeyDialog.KeyBinding[])obj2;

				String label1 = k1[0].label.toLowerCase();
				String label2 = k2[0].label.toLowerCase();

				if(col == 0)
					return MiscUtilities.compareStrings(
						label1,label2,true);
				else
				{
					String shortcut1, shortcut2;

					if(col == 1)
					{
						shortcut1 = k1[0].shortcut;
						shortcut2 = k2[0].shortcut;
					}
					else
					{
						shortcut1 = k1[1].shortcut;
						shortcut2 = k2[1].shortcut;
					}

					if(shortcut1 == null && shortcut2 != null)
						return 1;
					else if(shortcut2 == null && shortcut1 != null)
						return -1;
					else if(shortcut1 == null && shortcut2 == null)
						return MiscUtilities.compareStrings(label1,label2,true);
					else
						return MiscUtilities.compareStrings(shortcut1,shortcut2,true);
				}
			}
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.gui.ViewRegisters,6,7,0,8,46,9,3,8,3,0.8,299,1.0,0,0.992401216,0.388888889,0,0,48.33333333,1,0.8333,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;

public class ViewRegisters extends EnhancedDialog
{
	public ViewRegisters(View view)
	{
		super(view,jEdit.getProperty(""view-registers.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JPanel panel = new JPanel(new BorderLayout());
		panel.setBorder(new EmptyBorder(0,12,0,0));

		JLabel label = new JLabel(jEdit.getProperty(""view-registers.register""));
		label.setBorder(new EmptyBorder(0,0,3,0));
		panel.add(BorderLayout.NORTH,label);

		DefaultListModel registerModel = new DefaultListModel();
		registerList = new JList(registerModel);
		registerList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		registerList.setCellRenderer(new Renderer());

		Registers.Register[] registers = Registers.getRegisters();

		int index = 0;
		for(int i = 0; i < registers.length; i++)
		{
			Registers.Register reg = registers[i];
			if(reg == null)
				continue;

			String value = reg.toString();
			if(value == null || value.length() == 0)
				continue;

			registerModel.addElement(new Character((char)i));
		}

		if(registerModel.getSize() == 0)
			registerModel.addElement(jEdit.getProperty(""view-registers.none""));

		panel.add(BorderLayout.CENTER,new JScrollPane(registerList));

		content.add(BorderLayout.WEST,panel);

		panel = new JPanel(new BorderLayout());
		panel.setBorder(new EmptyBorder(0,12,0,0));

		label = new JLabel(jEdit.getProperty(""view-registers.contents""));
		label.setBorder(new EmptyBorder(0,0,3,0));
		panel.add(BorderLayout.NORTH,label);

		contentTextArea = new JTextArea(10,80);
		contentTextArea.setEditable(false);
		panel.add(BorderLayout.CENTER,new JScrollPane(contentTextArea));
		content.add(BorderLayout.CENTER,panel);

		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		panel.add(Box.createGlue());
		panel.add(close);
		panel.add(Box.createGlue());
		getRootPane().setDefaultButton(close);
		content.add(BorderLayout.SOUTH,panel);

		registerList.addListSelectionListener(new ListHandler());
		registerList.setSelectedIndex(index);

		pack();
		setLocationRelativeTo(view);
		show();
	}

	
	public void ok()
	{
		dispose();
	}

	public void cancel()
	{
		dispose();
	}
	

	
	private JList registerList;
	private JTextArea contentTextArea;
	private JButton close;

	class Renderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,
				index,isSelected,cellHasFocus);

			if(value instanceof Character)
			{
				char name = ((Character)value).charValue();

				String label;

				if(name == '\n')
					label = ""\n"";
				else if(name == '\t')
					label = ""\t"";
				else if(name == '$')
					label = jEdit.getProperty(""view-registers.clipboard"");
				else if(name == '%')
					label = jEdit.getProperty(""view-registers.selection"");
				else
					label = String.valueOf((char)name);

				setText(label);
			}

			return this;
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == close)
				cancel();
		}
	}

	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object value = registerList.getSelectedValue();
			if(!(value instanceof Character))
				return;

			char name = ((Character)value).charValue();

			Registers.Register reg = Registers.getRegister(name);

			if(reg == null)
				return;

			contentTextArea.setText(reg.toString());
			contentTextArea.setCaretPosition(0);
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.browser.BrowserCommandsMenu,6,5,0,11,33,7,5,7,2,0.85,397,1.0,3,0.993055556,0.3,0,0,64.5,2,1.0,2,"

package org.gjt.sp.jedit.browser;


import java.awt.*;
import java.awt.event.*;
import java.util.*;
import javax.swing.*;
import javax.swing.event.*;

import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;



public class BrowserCommandsMenu extends JPopupMenu
{
	
	public BrowserCommandsMenu(VFSBrowser browser, VFS.DirectoryEntry file)
	{
		this.browser = browser;

		if(file != null)
		{
			this.file = file;

			VFS vfs = VFSManager.getVFSForPath(file.deletePath);

			boolean delete = (vfs.getCapabilities() & VFS.DELETE_CAP) != 0;
			boolean rename = (vfs.getCapabilities() & VFS.RENAME_CAP) != 0;

			if(jEdit.getBuffer(file.path) != null)
			{
				if(browser.getMode() == VFSBrowser.BROWSER)
				{
					add(createMenuItem(""open""));
					add(createMenuItem(""open-view""));
					add(createMenuItem(""insert""));
				}
				else
					add(createMenuItem(""choose""));
				add(createMenuItem(""close""));
			}
			else
			{
				if(file.type == VFS.DirectoryEntry.DIRECTORY
					|| file.type == VFS.DirectoryEntry.FILESYSTEM)
				{
					add(createMenuItem(""browse""));
				}
				else if(browser.getMode() != VFSBrowser.BROWSER)
				{
					add(createMenuItem(""choose""));
				}
				
				else
				{
					add(createMenuItem(""open""));
					add(createMenuItem(""open-view""));
					add(createOpenEncodingMenu());
					add(createMenuItem(""insert""));
				}

				if(rename)
					add(createMenuItem(""rename""));
				if(delete)
					add(createMenuItem(""delete""));
			}

			addSeparator();
		}

		add(createMenuItem(""up""));
		add(createMenuItem(""reload""));
		add(createMenuItem(""roots""));
		add(createMenuItem(""home""));
		add(createMenuItem(""synchronize""));
		addSeparator();

		if(browser.getMode() == VFSBrowser.BROWSER)
			add(createMenuItem(""new-file""));

		add(createMenuItem(""new-directory""));

		if(browser.getMode() == VFSBrowser.BROWSER)
		{
			addSeparator();
			add(createMenuItem(""search-in-directory""));
		}

		addSeparator();

		showHiddenFiles = new JCheckBoxMenuItem(
			jEdit.getProperty(""vfs.browser.commands.show-hidden-files.label""));
		showHiddenFiles.setActionCommand(""show-hidden-files"");
		showHiddenFiles.setSelected(browser.getShowHiddenFiles());
		showHiddenFiles.addActionListener(new ActionHandler());
		add(showHiddenFiles);
	} 

	
	public void update()
	{
		showHiddenFiles.setSelected(browser.getShowHiddenFiles());
	} 

	
	private VFSBrowser browser;
	private VFS.DirectoryEntry file;
	private VFS vfs;
	private JCheckBoxMenuItem showHiddenFiles;

	
	private JMenuItem createMenuItem(String name)
	{
		String label = jEdit.getProperty(""vfs.browser.commands."" + name + "".label"");
		JMenuItem mi = new JMenuItem(label);
		mi.setActionCommand(name);
		mi.addActionListener(new ActionHandler());
		return mi;
	} 

	
	private JMenu createOpenEncodingMenu()
	{
		ActionListener listener = new ActionHandler();

		JMenu openEncoding = new JMenu(jEdit.getProperty(""open-encoding.label""));

		
		String systemEncoding = System.getProperty(""file.encoding"");

		JMenuItem mi = new JMenuItem(jEdit.getProperty(""os-encoding""));
		mi.setActionCommand(""open@"" + systemEncoding);
		mi.addActionListener(listener);
		openEncoding.add(mi);

		mi = new JMenuItem(jEdit.getProperty(""jedit-encoding""));
		mi.setActionCommand(""open@"" + jEdit.getProperty(""buffer.encoding"",systemEncoding));
		mi.addActionListener(listener);
		openEncoding.add(mi);

		openEncoding.addSeparator();

		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			String encoding = st.nextToken();
			mi = new JMenuItem(encoding);
			mi.setActionCommand(""open@"" + encoding);
			mi.addActionListener(listener);
			openEncoding.add(mi);
		}

		openEncoding.addSeparator();

		mi = new JMenuItem(jEdit.getProperty(""other-encoding.label""));
		mi.setActionCommand(""other-encoding"");
		mi.addActionListener(listener);
		openEncoding.add(mi);

		return openEncoding;
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			View view = browser.getView();
			String actionCommand = evt.getActionCommand();

			if(actionCommand.startsWith(""open@""))
			{
				
				Hashtable props = new Hashtable();
				props.put(Buffer.ENCODING,actionCommand.substring(5));
				jEdit.openFile(view,null,file.path,false,props);
			}
			else if(actionCommand.equals(""other-encoding""))
			{
				String encoding = GUIUtilities.input(browser,
					""encoding-prompt"",null,
					jEdit.getProperty(""buffer.encoding"",
					System.getProperty(""file.encoding"")));
				if(encoding == null)
					return;
				Hashtable props = new Hashtable();
				props.put(Buffer.ENCODING,encoding);
				jEdit.openFile(view,null,file.path,false,props);
			}
			else if(actionCommand.equals(""open""))
				jEdit.openFile(view,file.path);
			else if(actionCommand.equals(""open-view""))
			{
				Buffer buffer = jEdit.openFile(null,file.path);
				if(buffer != null)
					jEdit.newView(view,buffer);
			}
			else if(actionCommand.equals(""insert""))
				view.getBuffer().insertFile(view,file.path);
			else if(actionCommand.equals(""choose""))
				browser.filesActivated(false,false);
			else if(actionCommand.equals(""close""))
			{
				Buffer buffer = jEdit.getBuffer(file.path);
				if(buffer != null)
					jEdit.closeBuffer(view,buffer);
			}
			else if(actionCommand.equals(""browse""))
				browser.setDirectory(file.path);
			else if(actionCommand.equals(""rename""))
				browser.rename(file.path);
			else if(actionCommand.equals(""delete""))
				browser.delete(file.deletePath);
			else if(actionCommand.equals(""up""))
			{
				String path = browser.getDirectory();
				VFS vfs = VFSManager.getVFSForPath(path);
				browser.setDirectory(vfs.getParentOfPath(path));
			}
			else if(actionCommand.equals(""reload""))
				browser.reloadDirectory();
			else if(actionCommand.equals(""roots""))
				browser.rootDirectory();
			else if(actionCommand.equals(""home""))
				browser.setDirectory(System.getProperty(""user.home""));
			else if(actionCommand.equals(""synchronize""))
			{
				Buffer buffer = browser.getView().getBuffer();
				browser.setDirectory(buffer.getVFS().getParentOfPath(
					buffer.getPath()));
			}
			else if(actionCommand.equals(""new-file""))
				browser.newFile();
			else if(actionCommand.equals(""new-directory""))
				browser.mkdir();
			else if(actionCommand.equals(""search-in-directory""))
				browser.searchInDirectory();
			else if(actionCommand.equals(""show-hidden-files""))
			{
				browser.setShowHiddenFiles(!browser.getShowHiddenFiles());
				browser.reloadDirectory();
			}
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.EnhancedMenu,1,7,6,9,22,0,7,3,1,2.0,95,0.0,0,1.0,1.0,0,0,94.0,0,0.0,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.awt.event.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;

public class EnhancedMenu extends JMenu
{
	public EnhancedMenu(String name)
	{
		String label = jEdit.getProperty(name.concat("".label""));
		if(label == null)
			label = name;

		char mnemonic;
		int index = label.indexOf('$');
		if(index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0,index).concat(label.substring(++index));
		}
		else
			mnemonic = '\0';

		setText(label);
		if(!OperatingSystem.isMacOS())
			setMnemonic(mnemonic);

		String menuItems = jEdit.getProperty(name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					addSeparator();
				else
				{
					if(menuItemName.startsWith(""%""))
						add(GUIUtilities.loadMenu(menuItemName.substring(1)));
					else
						add(GUIUtilities.loadMenuItem(menuItemName));
				}
			}
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.Autosave,4,1,0,3,13,4,1,3,3,0.666666667,62,1.0,0,0.0,0.333333333,0,0,14.25,4,2.25,1,"

package org.gjt.sp.jedit;

import javax.swing.Timer;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;


class Autosave implements ActionListener
{
	public static void setInterval(int interval)
	{
		if(interval == 0)
		{
			if(timer != null)
			{
				timer.stop();
				timer = null;
			}

			return;
		}

		interval *= 1000;

		if(timer == null)
		{
			timer = new Timer(interval,new Autosave());
			timer.start();
		}
		else
			timer.setDelay(interval);
	}

	public static void stop()
	{
		if(timer != null)
			timer.stop();
	}

	public void actionPerformed(ActionEvent evt)
	{
		
		if(jEdit.getFirstView() != null)
			jEdit.saveOpenFiles(jEdit.getFirstView());

		Buffer[] bufferArray = jEdit.getBuffers();
		for(int i = 0; i < bufferArray.length; i++)
			bufferArray[i].autosave();
	}

	
	private static Timer timer;

	private Autosave() {}
}
"
jEdit,4,org.gjt.sp.jedit.gui.CompleteWord,17,5,0,15,90,108,3,15,3,0.75,539,1.0,3,0.974276527,0.22875817,3,4,30.41176471,15,2.5294,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;


public class CompleteWord extends JWindow
{
	
	public static void completeWord(View view)
	{
		JEditTextArea textArea = view.getTextArea();
		Buffer buffer = view.getBuffer();
		int caretLine = textArea.getCaretLine();
		int caret = textArea.getCaretPosition();

		if(!buffer.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);
		String noWordSep = getNonAlphaNumericWordChars(buffer,keywordMap,caret);
		String word = getWordToComplete(buffer,caretLine,caret,noWordSep);
		if(word == null)
		{
			textArea.getToolkit().beep();
			return;
		}

		Vector completions = getCompletions(buffer,word,keywordMap,
			noWordSep,caret);

		if(completions.size() == 0
			|| (completions.size() == 1 &&
			((Completion)completions.get(0)).text.equals(word)))
		{
			textArea.getToolkit().beep();
		}
		
		else if(completions.size() == 1)
		{
			textArea.setSelectedText(completions
				.elementAt(0).toString()
				.substring(word.length()));
		} 
		
		else
		{
			textArea.scrollToCaret(false);
			Point location = textArea.offsetToXY(caret - word.length());
			location.y += textArea.getPainter().getFontMetrics()
				.getHeight();

			SwingUtilities.convertPointToScreen(location,
				textArea.getPainter());
			new CompleteWord(view,word,completions,location);
		} 
	} 

	
	public CompleteWord(View view, String word, Vector completions, Point location)
	{
		super(view);

		this.view = view;
		this.textArea = view.getTextArea();
		this.buffer = view.getBuffer();
		this.word = word;

		words = new JList(completions);
		words.setFont(UIManager.getFont(""TextArea.font""));

		words.setVisibleRowCount(Math.min(completions.size(),8));

		words.addMouseListener(new MouseHandler());
		words.setSelectedIndex(0);
		words.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		words.setCellRenderer(new Renderer());

		
		
		JScrollPane scroller = new JScrollPane(words,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

		getContentPane().add(scroller, BorderLayout.CENTER);

		GUIUtilities.requestFocus(this,words);

		pack();
		setLocation(location);
		show();

		KeyHandler keyHandler = new KeyHandler();
		addKeyListener(keyHandler);
		words.addKeyListener(keyHandler);
		view.setKeyEventInterceptor(keyHandler);
	} 

	
	public void dispose()
	{
		view.setKeyEventInterceptor(null);
		super.dispose();
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				textArea.requestFocus();
			}
		});
	} 

	

	
	private static String getNonAlphaNumericWordChars(Buffer buffer,
		KeywordMap keywordMap, int caret)
	{
		
		
		String noWordSep = buffer.getStringProperty(""noWordSep"");
		if(noWordSep == null)
			noWordSep = """";
		if(keywordMap != null)
		{
			String keywordNoWordSep = keywordMap.getNonAlphaNumericChars();
			if(keywordNoWordSep != null)
				noWordSep = noWordSep + keywordNoWordSep;
		}

		return noWordSep;
	} 

	
	private static String getWordToComplete(Buffer buffer, int caretLine,
		int caret, String noWordSep)
	{
		String line = buffer.getLineText(caretLine);
		int dot = caret - buffer.getLineStartOffset(caretLine);
		if(dot == 0)
			return null;

		char ch = line.charAt(dot-1);
		if(!Character.isLetterOrDigit(ch)
			&& noWordSep.indexOf(ch) == -1)
		{
			
			return null;
		}

		int wordStart = TextUtilities.findWordStart(line,dot-1,noWordSep);
		String word = line.substring(wordStart,dot);
		if(word.length() == 0)
			return null;

		return word;
	} 

	
	private static Vector getCompletions(Buffer buffer, String word,
		KeywordMap keywordMap, String noWordSep, int caret)
	{
		Vector completions = new Vector();

		int wordLen = word.length();

		
		if(keywordMap != null)
		{
			String[] keywords = keywordMap.getKeywords();
			for(int i = 0; i < keywords.length; i++)
			{
				String _keyword = keywords[i];
				if(_keyword.regionMatches(keywordMap.getIgnoreCase(),
					0,word,0,wordLen))
				{
					Completion keyword = new Completion(_keyword,true);
					if(completions.indexOf(keyword) == -1)
						completions.addElement(keyword);
				}
			}
		} 

		
		for(int i = 0; i < buffer.getLineCount(); i++)
		{
			String line = buffer.getLineText(i);
			int start = buffer.getLineStartOffset(i);

			

			if(line.startsWith(word) && caret != start + word.length())
			{
				String _word = completeWord(line,0,noWordSep);
				Completion comp = new Completion(_word,false);

				
				if(completions.indexOf(comp) == -1)
					completions.addElement(comp);
			}

			
			int len = line.length() - word.length();
			for(int j = 0; j < len; j++)
			{
				char c = line.charAt(j);
				if(!Character.isLetterOrDigit(c) && noWordSep.indexOf(c) == -1)
				{
					if(line.regionMatches(j + 1,word,0,wordLen)
						&& caret != start + j + word.length() + 1)
					{
						String _word = completeWord(line,j + 1,noWordSep);
						Completion comp = new Completion(_word,false);

						
						if(completions.indexOf(comp) == -1)
							completions.addElement(comp);
					}
				}
			}
		} 

		
		MiscUtilities.quicksort(completions,new MiscUtilities.StringICaseCompare());

		return completions;
	} 

	
	private static String completeWord(String line, int offset, String noWordSep)
	{
		
		int wordEnd = TextUtilities.findWordEnd(line,offset + 1,noWordSep);
		return line.substring(offset,wordEnd);
	} 

	
	private View view;
	private JEditTextArea textArea;
	private Buffer buffer;
	private String word;
	private JList words;
	

	
	private void insertSelected()
	{
		textArea.setSelectedText(words.getSelectedValue().toString()
			.substring(word.length()));
		dispose();
	} 

	

	
	static class Completion
	{
		String text;
		boolean keyword;

		Completion(String text, boolean keyword)
		{
			this.text = text;
			this.keyword = keyword;
		}

		public String toString()
		{
			return text;
		}

		public boolean equals(Object obj)
		{
			if(obj instanceof Completion)
				return ((Completion)obj).text.equals(text);
			else
				return false;
		}
	} 

	
	static class Renderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list, Object value,
			int index, boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			Completion comp = (Completion)value;
			if(comp.keyword)
				setFont(list.getFont().deriveFont(Font.BOLD));
			else
				setFont(list.getFont());

			return this;
		}
	} 

	
	class KeyHandler extends KeyAdapter
	{
		
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			
			
			case KeyEvent.VK_ENTER:
				insertSelected();
				evt.consume();
				break;
			case KeyEvent.VK_ESCAPE:
				dispose();
				evt.consume();
				break;
			case KeyEvent.VK_UP:
				int selected = words.getSelectedIndex();

				if(selected == 0)
					selected = words.getModel().getSize() - 1;
				else if(getFocusOwner() == words)
					return;
				else
					selected = selected - 1;

				words.setSelectedIndex(selected);
				words.ensureIndexIsVisible(selected);

				evt.consume();
				break;
			case KeyEvent.VK_DOWN:
				 selected = words.getSelectedIndex();

				if(selected == words.getModel().getSize() - 1)
					selected = 0;
				else if(getFocusOwner() == words)
					return;
				else
					selected = selected + 1;

				words.setSelectedIndex(selected);
				words.ensureIndexIsVisible(selected);

				evt.consume();
				break;
			case KeyEvent.VK_BACK_SPACE:
				if(word.length() == 1)
				{
					textArea.backspace();
					evt.consume();
					dispose();
				}
				else
				{
					word = word.substring(0,word.length() - 1);
					textArea.backspace();
					int caret = textArea.getCaretPosition();
					KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);
					String noWordSep = getNonAlphaNumericWordChars(buffer,keywordMap,caret);

					Vector completions = getCompletions(buffer,word,
						keywordMap,noWordSep,caret);

					if(completions.size() == 0)
						dispose();

					words.setListData(completions);
					words.setSelectedIndex(0);

					evt.consume();
				}
				break;
			default:
				if(evt.isActionKey())
				{
					dispose();
					view.processKeyEvent(evt);
				}
				break;
			}
		} 

		
		public void keyTyped(KeyEvent evt)
		{
			char ch = evt.getKeyChar();
			evt = KeyEventWorkaround.processKeyEvent(evt);
			if(evt == null)
				return;
			else if(ch != '\b')
			{
				word = word + ch;
				textArea.userInput(ch);
				int caret = textArea.getCaretPosition();
				KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);
				String noWordSep = getNonAlphaNumericWordChars(buffer,keywordMap,caret);

				Vector completions = getCompletions(buffer,word,keywordMap,
					noWordSep,caret);

				if(completions.size() == 0)
					dispose();

				words.setListData(completions);
				words.setSelectedIndex(0);
			}
		} 
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			insertSelected();
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.search.SearchMatcher,2,1,0,5,2,1,4,1,2,2.0,2,0.0,0,0.0,0.625,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.search;

import gnu.regexp.CharIndexed;
import javax.swing.text.Segment;


public interface SearchMatcher
{
	
	int[] nextMatch(CharIndexed text, boolean start, boolean end,
		boolean firstTime);

	
	String substitute(String text) throws Exception;
}
"
jEdit,4,org.gjt.sp.jedit.msg.EditorExitRequested,2,3,0,5,4,1,1,4,2,2.0,10,0.0,0,0.857142857,0.75,0,0,4.0,1,0.5,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.View;


public class EditorExitRequested extends EBMessage.NonVetoable
{
	
	public EditorExitRequested(View view)
	{
		super(view);
	}

	
	public View getView()
	{
		return (View)getSource();
	}
}
"
jEdit,4,org.gjt.sp.jedit.browser.BrowserIORequest,7,2,0,7,28,0,1,7,3,0.621212121,559,0.636363636,2,0.454545455,0.265306122,0,0,77.28571429,5,3.2857,0,"

package org.gjt.sp.jedit.browser;


import javax.swing.tree.DefaultMutableTreeNode;
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.util.WorkRequest;
import org.gjt.sp.util.WorkThread;



public class BrowserIORequest extends WorkRequest
{
	
	
	public static final int LIST_DIRECTORY = 0;

	
	public static final int DELETE = 1;

	
	public static final int RENAME = 2;

	
	public static final int MKDIR = 3;
	

	
	
	public BrowserIORequest(int type, VFSBrowser browser,
		Object session, VFS vfs, String path1, String path2,
		DefaultMutableTreeNode node)
	{
		this.type = type;
		this.browser = browser;
		this.session = session;
		this.vfs = vfs;
		this.path1 = path1;
		this.path2 = path2;
		this.node = node;
	} 

	
	public void run()
	{
		switch(type)
		{
		case LIST_DIRECTORY:
			listDirectory();
			break;
		case DELETE:
			delete();
			break;
		case RENAME:
			rename();
			break;
		case MKDIR:
			mkdir();
			break;
		}

		if(type != LIST_DIRECTORY)
			browser.endRequest();
	} 

	
	public String toString()
	{
		String typeString;
		switch(type)
		{
		case LIST_DIRECTORY:
			typeString = ""LIST_DIRECTORY"";
			break;
		case DELETE:
			typeString = ""DELETE"";
			break;
		case RENAME:
			typeString = ""RENAME"";
			break;
		case MKDIR:
			typeString = ""MKDIR"";
			break;
		default:
			typeString = ""UNKNOWN!!!"";
			break;
		}

		return getClass().getName() + ""[type="" + typeString
			+ "",vfs="" + vfs + "",path1="" + path1
			+ "",path2="" + path2 + ""]"";
	} 

	

	
	private int type;
	private VFSBrowser browser;
	private Object session;
	private VFS vfs;
	private String path1;
	private String path2;
	private DefaultMutableTreeNode node;
	

	
	private void listDirectory()
	{
		VFS.DirectoryEntry[] directory = null;
		String[] args = { path1 };
		setStatus(jEdit.getProperty(""vfs.status.listing-directory"",args));

		String canonPath = null;

		try
		{
			setAbortable(true);

			canonPath = vfs._canonPath(session,path1,browser);

			directory = vfs._listDirectory(session,canonPath,browser);
		}
		catch(IOException io)
		{
			setAbortable(false);
			String[] pp = { io.toString() };
			VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}

		setAbortable(false);
		browser.directoryLoaded(node,canonPath,directory);
	} 

	
	private void delete()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.deleting"",args));

			try
			{
				path1 = vfs._canonPath(session,path1,browser);


				if(!vfs._delete(session,path1,browser))
					VFSManager.error(browser,path1,""ioerror.delete-error"",null);
			}
			catch(IOException io)
			{
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
	} 

	
	private void rename()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1, path2 };
			setStatus(jEdit.getProperty(""vfs.status.renaming"",args));

			try
			{
				path1 = vfs._canonPath(session,path1,browser);
				path2 = vfs._canonPath(session,path2,browser);

				VFS.DirectoryEntry file = vfs._getDirectoryEntry(
					session,path2,browser);
				if(file != null)
					VFSManager.error(browser,path1,""ioerror.rename-exists"",
						new String[] { path2 });
				else
				{
					if(!vfs._rename(session,path1,path2,browser))
						VFSManager.error(browser,path1,""ioerror.rename-error"",
							new String[] { path2 });
				}
			}
			catch(IOException io)
			{
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
	} 

	
	private void mkdir()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.mkdir"",args));

			try
			{
				path1 = vfs._canonPath(session,path1,browser);

				if(!vfs._mkdir(session,path1,browser))
					VFSManager.error(browser,path1,""ioerror.mkdir-error"",null);
			}
			catch(IOException io)
			{
				args[0] = io.toString();
				VFSManager.error(browser,path1,""ioerror"",args);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				String[] args = { io.toString() };
				VFSManager.error(browser,path1,""ioerror"",args);
			}
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.PanelWindowContainer,21,1,0,17,78,102,11,15,8,0.861538462,528,1.0,3,0.0,0.238095238,0,0,23.52380952,5,1.5714,7,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.plaf.metal.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.AffineTransform;
import java.awt.image.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;



public class PanelWindowContainer implements DockableWindowContainer
{
	
	public PanelWindowContainer(DockableWindowManager wm, String position)
	{
		this.wm = wm;
		this.position = position;

		
		buttons = new JPanel(new ButtonLayout());

		
		
		
		
		

		closeBox = new JButton(GUIUtilities.loadIcon(""closebox.gif""));
		closeBox.setRequestFocusEnabled(false);
		closeBox.setToolTipText(jEdit.getProperty(""view.docking.close-tooltip""));

		
		int left;
		if(position.equals(DockableWindowManager.RIGHT)
			|| position.equals(DockableWindowManager.LEFT))
			left = 1;
		else
			left = 0;

		closeBox.setMargin(new Insets(0,left,0,0));
		buttons.add(closeBox);

		closeBox.addActionListener(new ActionHandler());

		popupButton = new JButton(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
		popupButton.setRequestFocusEnabled(false);
		popupButton.setToolTipText(jEdit.getProperty(""view.docking.menu-tooltip""));
		buttons.add(popupButton);

		popupButton.addMouseListener(new MouseHandler());
		popup = new JPopupMenu();

		buttonGroup = new ButtonGroup();
		
		buttonGroup.add(nullButton = new JToggleButton());
		

		dockables = new Vector();
		dockablePanel = new DockablePanel();

		dimension = jEdit.getIntegerProperty(
			""view.dock."" + position + "".dimension"",0);

		buttons.addMouseListener(new MouseHandler());
	} 

	
	public void register(final DockableWindowManager.Entry entry)
	{
		dockables.addElement(entry);

		
		int rotation;
		if(position.equals(DockableWindowManager.TOP)
			|| position.equals(DockableWindowManager.BOTTOM))
			rotation = RotatedTextIcon.NONE;
		else if(position.equals(DockableWindowManager.LEFT))
			rotation = RotatedTextIcon.CCW;
		else if(position.equals(DockableWindowManager.RIGHT))
			rotation = RotatedTextIcon.CW;
		else
			throw new InternalError(""Invalid position: "" + position);

		JToggleButton button = new JToggleButton();
		button.setMargin(new Insets(0,0,0,0));
		button.setRequestFocusEnabled(false);
		button.setIcon(new RotatedTextIcon(rotation,button.getFont(),
			entry.title));
		button.setActionCommand(entry.name);
		button.addActionListener(new ActionHandler());
		

		buttonGroup.add(button);
		buttons.add(button);

		button.addMouseListener(new MouseHandler());

		
		JMenuItem menuItem = new JMenuItem(entry.title);

		menuItem.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				wm.showDockableWindow(entry.name);
			}
		}); 

		popup.add(menuItem);

		wm.revalidate();
	} 

	
	public void add(DockableWindowManager.Entry entry)
	{
		dockablePanel.add(entry.name,entry.win);
	} 

	
	public void remove(DockableWindowManager.Entry entry)
	{
		int index = dockables.indexOf(entry);
		buttons.remove(index + 2);

		dockables.removeElement(entry);
		if(entry.win != null)
			dockablePanel.remove(entry.win);

		if(current == entry)
		{
			current = null;
			show(null);
		}
		else
			wm.revalidate();
	} 

	
	public void save(DockableWindowManager.Entry entry) {}
	

	
	public void show(final DockableWindowManager.Entry entry)
	{
		if(current == entry)
		{
			if(entry != null)
				entry.win.requestDefaultFocus();
			return;
		}

		if(current == null)
		{
			
			dockablePanel.setBorder(new DockBorder(position));
		}

		if(entry != null)
		{
			this.current = entry;

			dockablePanel.showDockable(entry.name);

			int index = dockables.indexOf(entry);
			((JToggleButton)buttons.getComponent(index + 2)).setSelected(true);

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					entry.win.requestDefaultFocus();
				}
			});
		}
		else
		{
			current = null;
			nullButton.setSelected(true);
			
			dockablePanel.setBorder(null);

			wm.getView().getTextArea().requestFocus();
		}

		wm.revalidate();
		dockablePanel.repaint();
	} 

	
	public boolean isVisible(DockableWindowManager.Entry entry)
	{
		return current == entry;
	} 

	
	public DockableWindowManager.Entry getCurrent()
	{
		return current;
	} 

	

	
	void save()
	{
		jEdit.setIntegerProperty(""view.dock."" + position + "".dimension"",
			dimension);
		if(current == null)
			jEdit.unsetProperty(""view.dock."" + position + "".last"");
		else
		{
			jEdit.setProperty(""view.dock."" + position + "".last"",
				current.name);
		}
	} 

	
	JPanel getButtonBox()
	{
		return buttons;
	} 

	
	DockablePanel getDockablePanel()
	{
		return dockablePanel;
	} 

	
	void setDimension(int dimension)
	{
		if(dimension != 0)
			this.dimension = dimension - SPLITTER_WIDTH - 3;
	} 

	

	
	private static final int SPLITTER_WIDTH = 10;

	private DockableWindowManager wm;
	private String position;
	private JPanel buttons;
	private JButton closeBox;
	private JButton popupButton;
	private ButtonGroup buttonGroup;
	private JToggleButton nullButton;
	private int dimension;
	private Vector dockables;
	private DockablePanel dockablePanel;
	private DockableWindowManager.Entry current;
	private JPopupMenu popup;
	

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == closeBox)
				show(null);
			else
			{
				if(wm.isDockableWindowVisible(evt.getActionCommand()))
					show(null);
				else
					wm.showDockableWindow(evt.getActionCommand());
			}
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mousePressed(MouseEvent evt)
		{
			if(evt.getSource() == popupButton
				|| GUIUtilities.isPopupTrigger(evt))
			{
				if(popup.isVisible())
					popup.setVisible(false);
				else
				{
					GUIUtilities.showPopupMenu(popup,
						(Component)evt.getSource(),
						evt.getX(),evt.getY());
				}
			}
		}
	} 

	
	static class DockBorder implements Border
	{
		String position;
		Insets insets;
		Color color1;
		Color color2;
		Color color3;

		
		DockBorder(String position)
		{
			this.position = position;
			insets = new Insets(
				position.equals(DockableWindowManager.BOTTOM)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManager.RIGHT)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManager.TOP)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManager.LEFT)
					? SPLITTER_WIDTH : 0);
		} 

		
		public void paintBorder(Component c, Graphics g,
			int x, int y, int width, int height)
		{
			updateColors();

			if(color1 == null || color2 == null || color3 == null)
				return;

			if(position.equals(DockableWindowManager.BOTTOM))
				paintHorizBorder(g,x,y,width);
			else if(position.equals(DockableWindowManager.RIGHT))
				paintVertBorder(g,x,y,height);
			else if(position.equals(DockableWindowManager.TOP))
			{
				paintHorizBorder(g,x,y + height
					- SPLITTER_WIDTH,width);
			}
			else if(position.equals(DockableWindowManager.LEFT))
			{
				paintVertBorder(g,x + width
					- SPLITTER_WIDTH,y,height);
			}
		} 

		
		public Insets getBorderInsets(Component c)
		{
			return insets;
		} 

		
		public boolean isBorderOpaque()
		{
			return false;
		} 

		
		private void paintHorizBorder(Graphics g, int x, int y, int width)
		{
			g.setColor(color3);
			g.fillRect(x,y,width,SPLITTER_WIDTH);

			for(int i = 0; i < width / 4 - 1; i++)
			{
				g.setColor(color1);
				g.drawLine(x + i * 4 + 2,y + 3,
					x + i * 4 + 2,y + 3);
				g.setColor(color2);
				g.drawLine(x + i * 4 + 3,y + 4,
					x + i * 4 + 3,y + 4);
				g.setColor(color1);
				g.drawLine(x + i * 4 + 4,y + 5,
					x + i * 4 + 4,y + 5);
				g.setColor(color2);
				g.drawLine(x + i * 4 + 5,y + 6,
					x + i * 4 + 5,y + 6);
			}
		} 

		
		private void paintVertBorder(Graphics g, int x, int y, int height)
		{
			g.setColor(color3);
			g.fillRect(x,y,SPLITTER_WIDTH,height);

			for(int i = 0; i < height / 4 - 1; i++)
			{
				g.setColor(color1);
				g.drawLine(x + 3,y + i * 4 + 2,
					x + 3,y + i * 4 + 2);
				g.setColor(color2);
				g.drawLine(x + 4,y + i * 4 + 3,
					x + 4,y + i * 4 + 3);
				g.setColor(color1);
				g.drawLine(x + 5,y + i * 4 + 4,
					x + 5,y + i * 4 + 4);
				g.setColor(color2);
				g.drawLine(x + 6,y + i * 4 + 5,
					x + 6,y + i * 4 + 5);
			}
		} 

		
		private void updateColors()
		{
			if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
			{
				color1 = MetalLookAndFeel.getControlHighlight();
				color2 = MetalLookAndFeel.getControlDarkShadow();
				color3 = MetalLookAndFeel.getControl();
			}
			else
			{
				color1 = color2 = color3 = null;
			}
		} 
	} 

	
	class RotatedTextIcon implements Icon
	{
		static final int NONE = 0;
		static final int CW = 1;
		static final int CCW = 2;

		int rotate;
		Font font;
		GlyphVector glyphs;
		float width;
		float height;
		float ascent;
		RenderingHints renderHints;

		
		RotatedTextIcon(int rotate, Font font, String text)
		{
			this.rotate = rotate;
			this.font = font;

			FontRenderContext fontRenderContext
				= new FontRenderContext(null,true,true);
			glyphs = font.createGlyphVector(fontRenderContext,text);
			width = (int)glyphs.getLogicalBounds().getWidth() + 4;
			

			LineMetrics lineMetrics = font.getLineMetrics(text,fontRenderContext);
			ascent = lineMetrics.getAscent();
			height = (int)lineMetrics.getHeight();

			renderHints = new RenderingHints(
				RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
			renderHints.put(RenderingHints.KEY_FRACTIONALMETRICS,
				RenderingHints.VALUE_FRACTIONALMETRICS_ON);
			renderHints.put(RenderingHints.KEY_RENDERING,
				RenderingHints.VALUE_RENDER_QUALITY);
		} 

		
		public int getIconWidth()
		{
			return (int)(rotate == RotatedTextIcon.CW
				|| rotate == RotatedTextIcon.CCW
				? height : width);
		} 

		
		public int getIconHeight()
		{
			return (int)(rotate == RotatedTextIcon.CW
				|| rotate == RotatedTextIcon.CCW
				? width : height);
		} 

		
		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			Graphics2D g2d = (Graphics2D)g;
			g2d.setFont(font);
			AffineTransform oldTransform = g2d.getTransform();
			RenderingHints oldHints = g2d.getRenderingHints();

			g2d.setRenderingHints(renderHints);
			g2d.setColor(c.getForeground());

			
			if(rotate == RotatedTextIcon.NONE)
			{
				g2d.drawGlyphVector(glyphs,x + 2,y + ascent);
			} 
			
			else if(rotate == RotatedTextIcon.CW)
			{
				AffineTransform trans = new AffineTransform();
				trans.concatenate(oldTransform);
				trans.translate(x,y + 2);
				trans.rotate(Math.PI / 2,
					height / 2, width / 2);
				g2d.setTransform(trans);
				g2d.drawGlyphVector(glyphs,(height - width) / 2,
					(width - height) / 2
					+ ascent);
			} 
			
			else if(rotate == RotatedTextIcon.CCW)
			{
				AffineTransform trans = new AffineTransform();
				trans.concatenate(oldTransform);
				trans.translate(x,y - 2);
				trans.rotate(Math.PI * 3 / 2,
					height / 2, width / 2);
				g2d.setTransform(trans);
				g2d.drawGlyphVector(glyphs,(height - width) / 2,
					(width - height) / 2
					+ ascent);
			} 

			g2d.setTransform(oldTransform);
			g2d.setRenderingHints(oldHints);
		} 
	} 

	
	class ButtonLayout implements LayoutManager
	{
		
		public void addLayoutComponent(String name, Component comp) {} 

		
		public void removeLayoutComponent(Component comp) {} 

		
		public Dimension preferredLayoutSize(Container parent)
		{
			Component[] comp = parent.getComponents();
			if(comp.length == 2)
			{
				
				return new Dimension(0,0);
			}
			else
			{
				if(position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM))
				{
					return new Dimension(0,comp[2].getPreferredSize().height);
				}
				else
				{
					return new Dimension(comp[2].getPreferredSize().width,0);
				}
			}
		} 

		
		public Dimension minimumLayoutSize(Container parent)
		{
			Component[] comp = parent.getComponents();
			if(comp.length == 2)
			{
				
				return new Dimension(0,0);
			}
			else
			{
				if(position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM))
				{
					return new Dimension(0,comp[2].getMinimumSize().height);
				}
				else
				{
					return new Dimension(comp[2].getMinimumSize().width,0);
				}
			}
		} 

		
		public void layoutContainer(Container parent)
		{
			Component[] comp = parent.getComponents();
			if(comp.length != 2)
			{
				boolean closeBoxSizeSet = false;
				boolean noMore = false;
				popupButton.setVisible(false);

				Dimension parentSize = parent.getSize();
				int pos = 0;
				for(int i = 2; i < comp.length; i++)
				{
					Dimension size = comp[i].getPreferredSize();
					if(position.equals(DockableWindowManager.TOP)
						|| position.equals(DockableWindowManager.BOTTOM))
					{
						if(!closeBoxSizeSet)
						{
							closeBox.setBounds(0,0,size.height,size.height);
							pos += size.height;
							closeBoxSizeSet = true;
						}

						if(noMore || pos + size.width > parentSize.width
							- (i == comp.length - 1
							? 0 : closeBox.getWidth()))
						{
							popupButton.setBounds(
								parentSize.width - size.height,
								0,size.height,size.height);
							popupButton.setVisible(true);
							comp[i].setVisible(false);
							noMore = true;
						}
						else
						{
							comp[i].setBounds(pos,0,size.width,size.height);
							comp[i].setVisible(true);
							pos += size.width;
						}
					}
					else
					{
						if(!closeBoxSizeSet)
						{
							closeBox.setBounds(0,0,size.width,size.width);
							pos += size.width;
							closeBoxSizeSet = true;
						}

						if(noMore || pos + size.height > parentSize.height
							- (i == comp.length - 1
							? 0 : closeBox.getHeight()))
						{
							popupButton.setBounds(
								0,parentSize.height - size.width,
								size.width,size.width);
							popupButton.setVisible(true);
							comp[i].setVisible(false);
							noMore = true;
						}
						else
						{
							comp[i].setBounds(0,pos,size.width,size.height);
							comp[i].setVisible(true);
							pos += size.height;
						}
					}
				}
			}
		} 
	} 

	
	class DockablePanel extends JPanel
	{
		
		DockablePanel()
		{
			super(new CardLayout());

			ResizeMouseHandler resizeMouseHandler = new ResizeMouseHandler();
			addMouseListener(resizeMouseHandler);
			addMouseMotionListener(resizeMouseHandler);
		} 

		
		void showDockable(String name)
		{
			((CardLayout)getLayout()).show(this,name);
		} 

		
		public Dimension getMinimumSize()
		{
			return new Dimension(0,0);
		} 

		
		public Dimension getPreferredSize()
		{
			if(current == null)
				return new Dimension(0,0);
			else
			{
				if(dimension <= 0)
				{
					int width = super.getPreferredSize().width;
					dimension = width - SPLITTER_WIDTH - 3;
				}

				if(position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM))
				{
					return new Dimension(0,
						dimension + SPLITTER_WIDTH + 3);
				}
				else
				{
					return new Dimension(dimension + SPLITTER_WIDTH + 3,
						0);
				}
			}
		} 

		
		class ResizeMouseHandler extends MouseAdapter implements MouseMotionListener
		{
			boolean canDrag;
			int dragStartDimension;
			Point dragStart;

			
			public void mousePressed(MouseEvent evt)
			{
				dragStartDimension = dimension;
				dragStart = evt.getPoint();
			} 

			
			public void mouseMoved(MouseEvent evt)
			{
				Border border = getBorder();
				if(border == null)
				{
					
					return;
				}

				Insets insets = border.getBorderInsets(DockablePanel.this);
				int cursor = Cursor.DEFAULT_CURSOR;
				canDrag = false;
				
				if(position.equals(DockableWindowManager.TOP))
				{
					if(evt.getY() >= getHeight() - insets.bottom)
					{
						cursor = Cursor.N_RESIZE_CURSOR;
						canDrag = true;
					}
				} 
				
				else if(position.equals(DockableWindowManager.LEFT))
				{
					if(evt.getX() >= getWidth() - insets.right)
					{
						cursor = Cursor.W_RESIZE_CURSOR;
						canDrag = true;
					}
				} 
				
				else if(position.equals(DockableWindowManager.BOTTOM))
				{
					if(evt.getY() <= insets.top)
					{
						cursor = Cursor.S_RESIZE_CURSOR;
						canDrag = true;
					}
				} 
				
				else if(position.equals(DockableWindowManager.RIGHT))
				{
					if(evt.getX() <= insets.left)
					{
						cursor = Cursor.E_RESIZE_CURSOR;
						canDrag = true;
					}
				} 

				setCursor(Cursor.getPredefinedCursor(cursor));
			} 

			
			public void mouseDragged(MouseEvent evt)
			{
				if(!canDrag)
					return;

				if(dragStart == null) 
					return;

				
				if(position.equals(DockableWindowManager.TOP))
				{
					dimension = evt.getY()
						+ dragStartDimension
						- dragStart.y;
				} 
				
				else if(position.equals(DockableWindowManager.LEFT))
				{
					dimension = evt.getX()
						+ dragStartDimension
						- dragStart.x;
				} 
				
				else if(position.equals(DockableWindowManager.BOTTOM))
				{
					dimension += (dragStart.y - evt.getY());
				} 
				
				else if(position.equals(DockableWindowManager.RIGHT))
				{
					dimension += (dragStart.x - evt.getX());
				} 

				if(dimension <= 0)
					dimension = dragStartDimension;

				wm.invalidate();
				wm.validate();
			} 

			
			public void mouseExited(MouseEvent evt)
			{
				setCursor(Cursor.getPredefinedCursor(
					Cursor.DEFAULT_CURSOR));
			} 
		} 
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.textarea.ScrollListener,2,1,0,3,2,1,3,1,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.textarea;


public interface ScrollListener extends java.util.EventListener
{
	void scrolledVertically(JEditTextArea textArea);
	void scrolledHorizontally(JEditTextArea textArea);
}
"
jEdit,4,org.gjt.sp.jedit.msg.VFSUpdate,3,2,0,6,9,0,4,2,3,0.0,34,1.0,0,0.714285714,0.666666667,1,1,10.0,1,0.6667,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class VFSUpdate extends EBMessage
{
	
	public VFSUpdate(String path)
	{
		super(null);

		if(path == null)
			throw new NullPointerException(""Path must be non-null"");

		this.path = path;
	}

	
	public String getPath()
	{
		return path;
	}

	public String paramString()
	{
		return super.paramString() + "",path="" + path;
	}

	
	private String path;
}
"
jEdit,4,org.gjt.sp.jedit.print.BufferPrintable,5,1,0,10,47,0,1,9,1,0.710526316,563,1.0,2,0.0,0.416666667,0,0,107.8,1,0.6,3,"

package org.gjt.sp.jedit.print;


import javax.swing.text.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.print.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.ChunkCache;
import org.gjt.sp.jedit.*;


class BufferPrintable implements Printable
{
	
	BufferPrintable(Buffer buffer, Font font, boolean header, boolean footer,
		boolean lineNumbers, boolean color)
	{
		this.buffer = buffer;
		this.font = font;
		this.header = header;
		this.footer = footer;
		this.lineNumbers = lineNumbers;

		styles = GUIUtilities.loadStyles(jEdit.getProperty(""print.font""),
			jEdit.getIntegerProperty(""print.fontsize"",10),color);
		styles[Token.NULL] = new SyntaxStyle(textColor,null,font);

		lineList = new ArrayList();
	} 

	
	public int print(Graphics _gfx, PageFormat pageFormat, int pageIndex)
		throws PrinterException
	{
		if(pageIndex == currentPage)
			currentLine = currentPageStart;
		else
		{
			if(end)
				return NO_SUCH_PAGE;

			currentPageStart = currentLine;
			currentPage = pageIndex;
		}

		double pageX = pageFormat.getImageableX();
		double pageY = pageFormat.getImageableY();
		double pageWidth = pageFormat.getImageableWidth();
		double pageHeight = pageFormat.getImageableHeight();

		Graphics2D gfx = (Graphics2D)_gfx;

		gfx.setFont(font);

		if(header)
		{
			double headerHeight = paintHeader(gfx,pageX,pageY,pageWidth);
			pageY += headerHeight * 2;
			pageHeight -= headerHeight * 2;
		}

		if(footer)
		{
			double footerHeight = paintFooter(gfx,pageX,pageY,pageWidth,
				pageHeight,pageIndex);
			pageHeight -= footerHeight * 2;
		}

		FontRenderContext frc = gfx.getFontRenderContext();

		
		
		int lineNumberDigits = (int)Math.ceil(Math.log(buffer.getLineCount() + 1)
			/ Math.log(10)) + 1;

		
		char[] chars = new char[lineNumberDigits];
		for(int i = 0; i < chars.length; i++)
			chars[i] = ' ';
		double lineNumberWidth = font.getStringBounds(chars,
			0,lineNumberDigits,frc).getWidth();
		

		
		int tabSize = jEdit.getIntegerProperty(""print.tabSize"",8);
		chars = new char[tabSize];
		for(int i = 0; i < chars.length; i++)
			chars[i] = ' ';
		double tabWidth = font.getStringBounds(chars,
			0,tabSize,frc).getWidth();
		PrintTabExpander e = new PrintTabExpander(pageX,tabWidth);
		

		Segment seg = new Segment();
		double y = 0.0;

print_loop:	for(;;)
		{
			
			if(currentLine == lineList.size())
			{
				buffer.getLineText(currentPhysicalLine,seg);
				lm = font.getLineMetrics(seg.array,
					seg.offset,seg.count,frc);

				Token tokens = buffer.markTokens(currentPhysicalLine)
					.getFirstToken();

				lineList.add(new Integer(++currentPhysicalLine));

				ChunkCache.lineToChunkList(seg,tokens,styles,frc,
					e,(float)(pageWidth - lineNumberWidth),
					lineList);
				if(lineList.size() == currentLine + 1)
					lineList.add(null);
			} 

			y += lm.getHeight();
			if(y >= pageHeight)
				break print_loop;

			Object obj = lineList.get(currentLine++);
			if(obj instanceof Integer)
			{
				
				if(lineNumbers)
				{
					gfx.setFont(font);
					gfx.setColor(lineNumberColor);
					String lineNumberString = String.valueOf(obj);
					gfx.drawString(lineNumberString,
						(float)pageX,(float)(pageY + y));
				} 

				obj = lineList.get(currentLine++);
			}

			if(obj != null)
			{
				ChunkCache.Chunk line = (ChunkCache.Chunk)obj;

				ChunkCache.paintChunkList(line,gfx,
					(float)(pageX + lineNumberWidth),
					(float)(pageY + y),
					Color.white,false);
			}

			if(currentPhysicalLine == buffer.getLineCount()
				&& currentLine == lineList.size())
			{
				end = true;
				break print_loop;
			}
		}

		return PAGE_EXISTS;
	} 

	

	
	private static Color headerColor = Color.lightGray;
	private static Color headerTextColor = Color.black;
	private static Color footerColor = Color.lightGray;
	private static Color footerTextColor = Color.black;
	private static Color lineNumberColor = Color.gray;
	private static Color textColor = Color.black;
	

	
	private Buffer buffer;
	private Font font;
	private SyntaxStyle[] styles;
	private boolean header;
	private boolean footer;
	private boolean lineNumbers;

	private int currentPage;
	private int currentPageStart;
	private int currentLine;
	private int currentPhysicalLine;
	private boolean end;

	private LineMetrics lm;
	private ArrayList lineList;
	

	
	private double paintHeader(Graphics2D gfx, double pageX, double pageY,
		double pageWidth)
	{
		String headerText = jEdit.getProperty(""print.headerText"",
			new String[] { buffer.getPath() });
		FontRenderContext frc = gfx.getFontRenderContext();

		gfx.setColor(headerColor);

		Rectangle2D bounds = font.getStringBounds(headerText,frc);

		Rectangle2D headerBounds = new Rectangle2D.Double(
			pageX,pageY,pageWidth,bounds.getHeight());
		gfx.fill(headerBounds);

		gfx.setColor(headerTextColor);

		lm = font.getLineMetrics(headerText,frc);
		gfx.drawString(headerText,
			(float)(pageX + (pageWidth - bounds.getWidth()) / 2),
			(float)(pageY + lm.getAscent()));

		return headerBounds.getHeight();
	}
	

	
	private double paintFooter(Graphics2D gfx, double pageX, double pageY,
		double pageWidth, double pageHeight, int pageIndex)
	{
		String footerText = jEdit.getProperty(""print.footerText"",
			new Object[] { new Date(), new Integer(pageIndex + 1) });
		FontRenderContext frc = gfx.getFontRenderContext();

		gfx.setColor(footerColor);

		Rectangle2D bounds = font.getStringBounds(footerText,frc);
		Rectangle2D footerBounds = new Rectangle2D.Double(
			pageX,pageY + pageHeight - bounds.getHeight(),
			pageWidth,bounds.getHeight());
		gfx.fill(footerBounds);

		gfx.setColor(footerTextColor);

		lm = font.getLineMetrics(footerText,frc);
		gfx.drawString(footerText,
			(float)(pageX + (pageWidth - bounds.getWidth()) / 2),
			(float)(pageY + pageHeight - bounds.getHeight()
			+ lm.getAscent()));

		return footerBounds.getHeight();
	} 

	

	
	static class PrintTabExpander implements TabExpander
	{
		private double pageX;
		private double tabWidth;

		
		public PrintTabExpander(double pageX, double tabWidth)
		{
			this.pageX = pageX;
			this.tabWidth = tabWidth;
		} 

		
		public float nextTabStop(float x, int tabOffset)
		{
			int ntabs = (int)((x - pageX) / tabWidth);
			return (float)((ntabs + 1) * tabWidth + pageX);
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.search.HyperSearchResult,5,1,0,6,17,0,3,3,5,0.65625,96,0.0,1,0.0,0.533333333,0,0,16.6,2,1.0,0,"

package org.gjt.sp.jedit.search;


import javax.swing.text.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;


public class HyperSearchResult
{
	public String path;
	public Buffer buffer;
	public int line;
	public int start;
	public int end;
	public Position startPos;
	public Position endPos;
	public String str; 

	
	public HyperSearchResult(Buffer buffer, int line, int start, int end)
	{
		path = buffer.getPath();
		this.line = line;
		this.start = start;
		this.end = end;

		if(!buffer.isTemporary())
			bufferOpened(buffer);

		str = (line + 1) + "": "" + buffer.getLineText(line)
			.replace('\t',' ').trim();
	} 

	
	public void bufferOpened(Buffer buffer)
	{
		this.buffer = buffer;
		startPos = buffer.createPosition(start);
		endPos = buffer.createPosition(end);
	} 

	
	public void bufferClosed()
	{
		buffer = null;
		startPos = endPos = null;
	} 

	
	public Buffer getBuffer()
	{
		if(buffer == null)
			buffer = jEdit.openFile(null,path);
		return buffer;
	} 

	
	public String toString()
	{
		return str;
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.BeanShellErrorDialog,3,7,0,6,33,3,3,4,3,2.0,180,0.0,0,0.996946565,0.555555556,0,0,59.0,1,0.6667,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;


public class BeanShellErrorDialog extends EnhancedDialog
{
	
	public BeanShellErrorDialog(View view, String message)
	{
		super(view,jEdit.getProperty(""beanshell-error.title""),true);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.errorIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout());

		JPanel caption = new JPanel(new GridLayout(2,1,3,3));
		caption.setBorder(new EmptyBorder(0,0,6,0));
		caption.add(new JLabel(jEdit.getProperty(""beanshell-error.message.1"")));
		caption.add(new JLabel(jEdit.getProperty(""beanshell-error.message.2"")));
		centerPanel.add(BorderLayout.NORTH,caption);

		JTextArea textArea = new JTextArea(10,60);
		textArea.setText(message);
		textArea.setLineWrap(true);
		textArea.setWrapStyleWord(true);
		centerPanel.add(BorderLayout.CENTER,new JScrollPane(textArea));

		content.add(BorderLayout.CENTER,centerPanel);

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		JButton ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		buttons.add(ok);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);

		getRootPane().setDefaultButton(ok);

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			dispose();
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.ActionSet,13,1,0,13,26,0,12,1,12,0.458333333,112,1.0,0,0.0,0.384615385,0,0,7.461538462,2,1.0,3,"

package org.gjt.sp.jedit;

import java.util.*;


public class ActionSet
{
	
	public ActionSet()
	{
		this(null);
	}

	
	public ActionSet(String label)
	{
		this.label = label;
		actions = new Hashtable();
	}

	
	public String getLabel()
	{
		return label;
	}

	
	public void setLabel(String label)
	{
		this.label = label;
	}

	
	public void addAction(EditAction action)
	{
		actions.put(action.getName(),action);
	}

	
	public void removeAction(String name)
	{
		actions.remove(name);
	}

	
	public void removeAllActions()
	{
		actions.clear();
	}

	
	public EditAction getAction(String name)
	{
		return (EditAction)actions.get(name);
	}

	
	public int getActionCount()
	{
		return actions.size();
	}

	
	public EditAction[] getActions()
	{
		EditAction[] retVal = new EditAction[actions.size()];
		Enumeration enum = actions.elements();
		int i = 0;
		while(enum.hasMoreElements())
		{
			retVal[i++] = (EditAction)enum.nextElement();
		}
		return retVal;
	}

	
	public boolean contains(EditAction action)
	{
		return actions.contains(action);
	}

	public String toString()
	{
		return label;
	}

	
	void getActions(Vector vec)
	{
		Enumeration enum = actions.elements();
		int i = 0;
		while(enum.hasMoreElements())
			vec.addElement(enum.nextElement());
	}

	
	private String label;
	private Hashtable actions;
}
"
jEdit,4,org.gjt.sp.jedit.SettingsReloader,3,1,0,6,20,3,1,6,1,2.0,103,0.0,0,0.0,0.555555556,0,0,33.33333333,14,5.3333,1,"

package org.gjt.sp.jedit;

import java.io.File;
import org.gjt.sp.jedit.msg.VFSUpdate;

class SettingsReloader implements EBComponent
{
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof VFSUpdate)
		{
			VFSUpdate vmsg = (VFSUpdate)msg;
			maybeReload(vmsg.getPath());
		}
	}

	private void maybeReload(String path)
	{
		String jEditHome = jEdit.getJEditHome();
		String settingsDirectory = jEdit.getSettingsDirectory();
		String osName = System.getProperty(""os.name"");
		
		if(OperatingSystem.isDOSDerived() || OperatingSystem.isMacOS())
		{
			path = path.toLowerCase();
			if(jEditHome != null)
				jEditHome = jEditHome.toLowerCase();
			if(settingsDirectory != null)
				settingsDirectory = settingsDirectory.toLowerCase();
		}

		if(jEditHome != null && path.startsWith(jEditHome))
			path = path.substring(jEditHome.length());
		else if(settingsDirectory != null && path.startsWith(settingsDirectory))
			path = path.substring(settingsDirectory.length());
		else
		{
			
			
			return;
		}

		if(path.startsWith(File.separator) || path.startsWith(""/""))
			path = path.substring(1);

		if(path.startsWith(""macros""))
			Macros.loadMacros();
		else if(path.endsWith("".xml"") || path.endsWith(""modes"" + File.separator + ""catalog""))
			jEdit.reloadModes();
	}
}
"
jEdit,4,org.gjt.sp.jedit.gui.EnhancedCheckBoxMenuItem,7,7,0,6,40,9,3,5,4,0.611111111,214,1.0,1,0.993811881,0.3,3,13,28.71428571,8,2.1429,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class EnhancedCheckBoxMenuItem extends JCheckBoxMenuItem
{
	
	public EnhancedCheckBoxMenuItem(String label, EditAction action)
	{
		super(label);
		this.action = action;

		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(action));
			shortcutProp1 = action.getName() + "".shortcut"";
			shortcutProp2 = action.getName() + "".shortcut2"";

			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);

		setModel(new Model());
	} 

	
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();

		String shortcut = getShortcut();

		if(shortcut != null)
		{
			d.width += (getFontMetrics(acceleratorFont)
				.stringWidth(shortcut) + 15);
		}
		return d;
	} 

	
	public void paint(Graphics g)
	{
		super.paint(g);

		String shortcut = getShortcut();

		if(shortcut != null)
		{
			g.setFont(acceleratorFont);
			g.setColor(getModel().isArmed() ?
				acceleratorSelectionForeground :
				acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left + 5),
				getFont().getSize() + (insets.top - 1)
				);
		}
	} 

	
	public String getActionCommand()
	{
		return getModel().getActionCommand();
	} 

	

	
	private String shortcutProp1;
	private String shortcutProp2;
	private EditAction action;
	private static Font acceleratorFont;
	private static Color acceleratorForeground;
	private static Color acceleratorSelectionForeground;
	

	
	private String getShortcut()
	{
		if(action == null)
			return null;
		else
		{
			String shortcut1 = jEdit.getProperty(shortcutProp1);
			String shortcut2 = jEdit.getProperty(shortcutProp2);

			if(shortcut1 == null || shortcut1.length() == 0)
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return null;
				else
					return shortcut2;
			}
			else
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return shortcut1;
				else
					return shortcut1 + "" or "" + shortcut2;
			}
		}
	} 

	
	static
	{
		acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
		acceleratorFont = new Font(""Monospaced"",
			acceleratorFont.getStyle(),
			acceleratorFont.getSize());
		acceleratorForeground = UIManager
			.getColor(""MenuItem.acceleratorForeground"");
		acceleratorSelectionForeground = UIManager
			.getColor(""MenuItem.acceleratorSelectionForeground"");
	} 

	

	
	class Model extends DefaultButtonModel
	{
		public boolean isSelected()
		{
			if(!isShowing())
				return false;

			try
			{
				return action.isSelected(GUIUtilities.getView(
					EnhancedCheckBoxMenuItem.this));
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);
				return false;
			}
		}

		public void setSelected(boolean b) {}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseReleased(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}

		public void mouseEntered(MouseEvent evt)
		{
			String msg = action.getMouseOverText();
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
			}
		}

		public void mouseExited(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.jEdit,114,1,0,184,374,5427,157,59,79,0.923830594,5109,1.0,8,0.0,0.051769912,0,0,43.57017544,68,4.0614,15,"

package org.gjt.sp.jedit;


import com.microstar.xml.*;
import javax.swing.plaf.metal.*;
import javax.swing.plaf.FontUIResource;
import javax.swing.text.DefaultEditorKit;
import javax.swing.text.Element;
import javax.swing.text.JTextComponent;
import javax.swing.text.Keymap;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.text.MessageFormat;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.search.SearchAndReplace;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class jEdit
{
	
	
	public static String getVersion()
	{
		return MiscUtilities.buildToVersion(getBuild());
	} 

	
	
	public static String getBuild()
	{
		
		return ""04.00.99.00"";
	} 

	
	
	public static void main(String[] args)
	{
		String javaVersion = System.getProperty(""java.version"");
		if(javaVersion.compareTo(""1.3"") < 0)
		{
			System.err.println(""You are running Java version ""
				+ javaVersion + ""."");
			System.err.println(""jEdit requires Java 1.3 or later."");
			System.exit(1);
		}

		
		int level = Log.WARNING;
		if(args.length >= 1)
		{
			String levelStr = args[0];
			if(levelStr.length() == 1 && Character.isDigit(
				levelStr.charAt(0)))
			{
				level = Integer.parseInt(levelStr);
				args[0] = null;
			}
		}

		boolean endOpts = false;
		settingsDirectory = MiscUtilities.constructPath(
			System.getProperty(""user.home""),"".jedit"");
		String portFile = ""server"";
		boolean restore = true;
		boolean gui = true; 
		boolean noPlugins = false;
		boolean noStartupScripts = false;
		String userDir = System.getProperty(""user.dir"");

		
		String scriptFile = null;

		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.length() == 0)
				args[i] = null;
			else if(arg.startsWith(""-"") && !endOpts)
			{
				if(arg.equals(""--""))
					endOpts = true;
				else if(arg.equals(""-usage""))
				{
					version();
					System.err.println();
					usage();
					System.exit(1);
				}
				else if(arg.equals(""-version""))
				{
					version();
					System.exit(1);
				}
				else if(arg.equals(""-nosettings""))
					settingsDirectory = null;
				else if(arg.startsWith(""-settings=""))
					settingsDirectory = arg.substring(10);
				else if(arg.startsWith(""-noserver""))
					portFile = null;
				else if(arg.equals(""-server""))
					portFile = ""server"";
				else if(arg.startsWith(""-server=""))
					portFile = arg.substring(8);
				else if(arg.startsWith(""-background""))
					background = true;
				else if(arg.equals(""-nogui""))
					gui = false;
				else if(arg.equals(""-norestore""))
					restore = false;
				else if(arg.equals(""-noplugins""))
					noPlugins = true;
				else if(arg.equals(""-nostartupscripts""))
					noStartupScripts = true;
				else if(arg.startsWith(""-run=""))
					scriptFile = arg.substring(5);
				else
				{
					System.err.println(""Unknown option: ""
						+ arg);
					usage();
					System.exit(1);
				}
				args[i] = null;
			}
		} 

		if(settingsDirectory != null && portFile != null)
			portFile = MiscUtilities.constructPath(settingsDirectory,portFile);
		else
			portFile = null;

		Log.init(true,level);

		
		if(portFile != null && new File(portFile).exists())
		{
			int port, key;
			try
			{
				BufferedReader in = new BufferedReader(new FileReader(portFile));
				String check = in.readLine();
				if(!check.equals(""b""))
					throw new Exception(""Wrong port file format"");

				port = Integer.parseInt(in.readLine());
				key = Integer.parseInt(in.readLine());
				in.close();

				Socket socket = new Socket(InetAddress.getByName(""127.0.0.1""),port);
				DataOutputStream out = new DataOutputStream(
					socket.getOutputStream());
				out.writeInt(key);

				String script = makeServerScript(restore,args,scriptFile);

				out.writeUTF(script);

				out.close();

				System.exit(0);
			}
			catch(Exception e)
			{
				
				
				
				Log.log(Log.NOTICE,jEdit.class,""An error occurred""
					+ "" while connecting to the jEdit server instance."");
				Log.log(Log.NOTICE,jEdit.class,""This probably means that""
					+ "" jEdit crashed and/or exited abnormally"");
				Log.log(Log.NOTICE,jEdit.class,""the last time it was run."");
				Log.log(Log.NOTICE,jEdit.class,""If you don't""
					+ "" know what this means, don't worry."");
				Log.log(Log.NOTICE,jEdit.class,e);
			}
		} 

		
		
		if(!new File(settingsDirectory,""nosplash"").exists())
			GUIUtilities.showSplashScreen();

		
		Writer stream;
		if(settingsDirectory != null)
		{
			File _settingsDirectory = new File(settingsDirectory);
			if(!_settingsDirectory.exists())
				_settingsDirectory.mkdirs();
			File _macrosDirectory = new File(settingsDirectory,""macros"");
			if(!_macrosDirectory.exists())
				_macrosDirectory.mkdir();

			String logPath = MiscUtilities.constructPath(
				settingsDirectory,""activity.log"");

			backupSettingsFile(new File(logPath));

			try
			{
				stream = new BufferedWriter(new FileWriter(logPath));
			}
			catch(Exception e)
			{
				e.printStackTrace();
				stream = null;
			}
		}
		else
		{
			stream = null;
		} 

		Log.setLogWriter(stream);

		Log.log(Log.NOTICE,jEdit.class,""jEdit version "" + getVersion());
		Log.log(Log.MESSAGE,jEdit.class,""Settings directory is ""
			+ settingsDirectory);

		
		if(portFile != null)
		{
			server = new EditServer(portFile);
			if(!server.isOK())
				server = null;
		}
		else
		{
			if(background)
			{
				background = false;
				System.err.println(""You cannot specify both the""
					+ "" -background and -noserver switches"");
			}
		} 

		
		initMisc();
		initSystemProperties();
		if(jEditHome != null)
			initSiteProperties();
		GUIUtilities.advanceSplashProgress();

		BeanShell.init();

		initUserProperties();
		initPLAF();

		if(OperatingSystem.hasJava14()
			&& System.getProperty(""jedit.nojava14"") == null)
		{
			try
			{
				ClassLoader loader = jEdit.class.getClassLoader();
				Class clazz;
				if(loader != null)
					clazz = loader.loadClass(""org.gjt.sp.jedit.Java14"");
				else
					clazz = Class.forName(""org.gjt.sp.jedit.Java14"");
				java.lang.reflect.Method meth = clazz
					.getMethod(""init"",new Class[0]);
				meth.invoke(null,new Object[0]);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
				System.exit(1);
			}
		}

		initActions();
		initDockables();

		GUIUtilities.advanceSplashProgress();

		VFSManager.init();

		if(!noPlugins)
			initPlugins();

		if(settingsDirectory != null)
		{
			File history = new File(MiscUtilities.constructPath(
				settingsDirectory,""history""));
			if(history.exists())
				historyModTime = history.lastModified();
			HistoryModel.loadHistory(history);

			File recent = new File(MiscUtilities.constructPath(
				settingsDirectory,""recent.xml""));
			if(recent.exists())
				recentModTime = recent.lastModified();
			BufferHistory.load(recent);
		}

		GUIUtilities.advanceSplashProgress();

		
		sortBuffers = getBooleanProperty(""sortBuffers"");
		sortByName = getBooleanProperty(""sortByName"");

		reloadModes();

		GUIUtilities.advanceSplashProgress();

		SearchAndReplace.load();

		GUIUtilities.advanceSplashProgress();
		

		
		for(int i = 0; i < jars.size(); i++)
		{
			((EditPlugin.JAR)jars.elementAt(i)).getClassLoader()
				.startAllPlugins();
		} 

		
		Macros.loadMacros();

		if(!noStartupScripts && jEditHome != null)
		{
			String path = MiscUtilities.constructPath(jEditHome,""startup"");
			File file = new File(path);
			if(file.exists())
				runStartupScripts(file);
		}

		if(!noStartupScripts && settingsDirectory != null)
		{
			String path = MiscUtilities.constructPath(settingsDirectory,""startup"");
			File file = new File(path);
			if(!file.exists())
				file.mkdirs();
			else
				runStartupScripts(file);
		} 

		
		if(scriptFile != null)
		{
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			BeanShell.runScript(null,scriptFile,null,false);
		} 

		
		propertiesChanged();

		GUIUtilities.advanceSplashProgress();

		
		Buffer buffer = openFiles(null,userDir,args);
		if(buffer != null)
		{
			
			
			gui = true;
		}

		String splitConfig = null;

		if(restore && settingsDirectory != null
			&& jEdit.getBooleanProperty(""restore"")
			&& (bufferCount == 0 || jEdit.getBooleanProperty(""restore.cli"")))
		{
			splitConfig = restoreOpenFiles();
		}

		if(bufferCount == 0 && gui)
			newFile(null);
		

		
		final Buffer _buffer = buffer;
		final String _splitConfig = splitConfig;
		final boolean _gui = gui;

		GUIUtilities.advanceSplashProgress();

		SwingUtilities.invokeLater(new Runnable() {
			public void run()
			{
				EditBus.send(new EditorStarted(null));

				if(_gui)
				{
					View view;
					if(_buffer != null)
						view = newView(null,_buffer);
					else
						view = newView(null,_splitConfig);
				}

				
				VFSManager.start();

				
				if(server != null)
					server.start();

				GUIUtilities.hideSplashScreen();

				Log.log(Log.MESSAGE,jEdit.class,""Startup ""
					+ ""complete"");

				
				if(pluginErrors != null)
				{
					String caption = jEdit.getProperty(
						""plugin-error.caption"" + (pluginErrors.size() == 1
						? ""-1"" : """"),new Integer[] {
						new Integer(pluginErrors.size()) });

					new ErrorListDialog(
						jEdit.getFirstView(),
						jEdit.getProperty(""plugin-error.title""),
						caption,pluginErrors,true);
					pluginErrors.removeAllElements();
				} 
			}
		}); 
	} 

	

	
	
	public static final Properties getProperties()
	{
		return props;
	} 

	
	
	public static final String getProperty(String name)
	{
		return props.getProperty(name);
	} 

	
	
	public static final String getProperty(String name, String def)
	{
		return props.getProperty(name,def);
	} 

	
	
	public static final String getProperty(String name, Object[] args)
	{
		if(name == null)
			return null;
		if(args == null)
			return props.getProperty(name);
		else
		{
			String value = props.getProperty(name);
			if(value == null)
				return null;
			else
				return MessageFormat.format(value,args);
		}
	} 

	
	
	public static final boolean getBooleanProperty(String name)
	{
		return getBooleanProperty(name,false);
	} 

	
	
	public static final boolean getBooleanProperty(String name, boolean def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else if(value.equals(""true"") || value.equals(""yes"")
			|| value.equals(""on""))
			return true;
		else if(value.equals(""false"") || value.equals(""no"")
			|| value.equals(""off""))
			return false;
		else
			return def;
	} 

	
	
	public static final int getIntegerProperty(String name, int def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
		{
			try
			{
				return Integer.parseInt(value);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
		}
	} 

	
	
	public static final Font getFontProperty(String name)
	{
		return getFontProperty(name,null);
	} 

	
	
	public static final Font getFontProperty(String name, Font def)
	{
		String family = getProperty(name);
		String sizeString = getProperty(name + ""size"");
		String styleString = getProperty(name + ""style"");

		if(family == null || sizeString == null || styleString == null)
			return def;
		else
		{
			int size, style;

			try
			{
				size = Integer.parseInt(sizeString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}

			try
			{
				style = Integer.parseInt(styleString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}

			return new Font(family,style,size);
		}
	} 

	
	
	public static Color getColorProperty(String name)
	{
		return getColorProperty(name,Color.black);
	} 

	
	
	public static Color getColorProperty(String name, Color def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
			return GUIUtilities.parseColor(value,def);
	} 

	
	
	public static void setColorProperty(String name, Color value)
	{
		setProperty(name,GUIUtilities.getColorHexString(value));
	} 

	
	
	public static final void setProperty(String name, String value)
	{
		
		if(value == null || value.length() == 0)
		{
			String prop = (String)defaultProps.get(name);
			if(prop == null || prop.length() == 0)
				props.remove(name);
			else
				props.put(name,"""");
		}
		else
		{
			String prop = (String)defaultProps.get(name);
			if(value.equals(prop))
				props.remove(name);
			else
				props.put(name,value);
		}
	} 

	
	
	public static final void setTemporaryProperty(String name, String value)
	{
		props.remove(name);
		defaultProps.put(name,value);
	} 

	
	
	public static final void setBooleanProperty(String name, boolean value)
	{
		setProperty(name,value ? ""true"" : ""false"");
	} 

	
	
	public static final void setIntegerProperty(String name, int value)
	{
		setProperty(name,String.valueOf(value));
	} 

	
	
	public static final void setFontProperty(String name, Font value)
	{
		setProperty(name,value.getFamily());
		setIntegerProperty(name + ""size"",value.getSize());
		setIntegerProperty(name + ""style"",value.getStyle());
	} 

	
	
	public static final void unsetProperty(String name)
	{
		if(defaultProps.get(name) != null)
			props.put(name,"""");
		else
			props.remove(name);
	} 

	
	
	public static final void resetProperty(String name)
	{
		props.remove(name);
	} 

	
	
	public static void propertiesChanged()
	{
		initKeyBindings();

		Autosave.setInterval(getIntegerProperty(""autosave"",30));

		saveCaret = getBooleanProperty(""saveCaret"");

		
		
		

		UIDefaults defaults = UIManager.getDefaults();

		
		Font font = getFontProperty(""view.font"");

		
		defaults.put(""TextArea.font"",font);
		defaults.put(""TextPane.font"",font);

		initProxy();

		EditBus.send(new PropertiesChanged(null));
	} 

	

	

	
	
	public static String[] getNotLoadedPluginJARs()
	{
		Vector returnValue = new Vector();

		if(jEditHome != null)
		{
			String systemPluginDir = MiscUtilities
				.constructPath(jEditHome,""jars"");

			String[] list = new File(systemPluginDir).list();
			if(list != null)
				getNotLoadedPluginJARs(returnValue,systemPluginDir,list);
		}

		if(settingsDirectory != null)
		{
			String userPluginDir = MiscUtilities
				.constructPath(settingsDirectory,""jars"");
			String[] list = new File(userPluginDir).list();
			if(list != null)
			{
				getNotLoadedPluginJARs(returnValue,
					userPluginDir,list);
			}
		}

		String[] _returnValue = new String[returnValue.size()];
		returnValue.copyInto(_returnValue);
		return _returnValue;
	} 

	
	
	public static EditPlugin getPlugin(String name)
	{
		EditPlugin[] plugins = getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			if(plugins[i].getClassName().equals(name))
				return plugins[i];
		}

		return null;
	} 

	
	
	public static EditPlugin[] getPlugins()
	{
		Vector vector = new Vector();
		for(int i = 0; i < jars.size(); i++)
		{
			((EditPlugin.JAR)jars.elementAt(i)).getPlugins(vector);
		}

		EditPlugin[] array = new EditPlugin[vector.size()];
		vector.copyInto(array);
		return array;
	} 

	
	
	public static EditPlugin.JAR[] getPluginJARs()
	{
		EditPlugin.JAR[] array = new EditPlugin.JAR[jars.size()];
		jars.copyInto(array);
		return array;
	} 

	
	
	public static EditPlugin.JAR getPluginJAR(String path)
	{
		for(int i = 0; i < jars.size(); i++)
		{
			EditPlugin.JAR jar = (EditPlugin.JAR)jars.elementAt(i);
			if(jar.getPath().equals(path))
				return jar;
		}

		return null;
	} 

	
	
	public static void addPluginJAR(EditPlugin.JAR plugin)
	{
		addActionSet(plugin.getActions());
		jars.addElement(plugin);
	} 

	

	

	
	
	public static void addActionSet(ActionSet actionSet)
	{
		actionSets.addElement(actionSet);
	} 

	
	
	public static ActionSet[] getActionSets()
	{
		ActionSet[] retVal = new ActionSet[actionSets.size()];
		actionSets.copyInto(retVal);
		return retVal;
	} 

	
	
	public static EditAction getAction(String name)
	{
		for(int i = 0; i < actionSets.size(); i++)
		{
			EditAction action = ((ActionSet)actionSets.elementAt(i))
				.getAction(name);
			if(action != null)
				return action;
		}

		return null;
	} 

	
	
	public static ActionSet getActionSetForAction(EditAction action)
	{
		for(int i = 0; i < actionSets.size(); i++)
		{
			ActionSet set = (ActionSet)actionSets.elementAt(i);
			if(set.contains(action))
				return set;
		}

		return null;
	} 

	
	
	public static EditAction[] getActions()
	{
		Vector vec = new Vector();
		for(int i = 0; i < actionSets.size(); i++)
			((ActionSet)actionSets.elementAt(i)).getActions(vec);

		EditAction[] retVal = new EditAction[vec.size()];
		vec.copyInto(retVal);
		return retVal;
	} 

	

	

	
	
	public static void reloadModes()
	{
		
		modes = new Vector(50);

		
		if(jEditHome == null)
			loadModeCatalog(""/modes/catalog"",true);
		else
		{
			loadModeCatalog(MiscUtilities.constructPath(jEditHome,
				""modes"",""catalog""),false);
		} 

		
		if(settingsDirectory != null)
		{
			File userModeDir = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes""));
			if(!userModeDir.exists())
				userModeDir.mkdirs();

			File userCatalog = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes"",""catalog""));
			if(!userCatalog.exists())
			{
				
				try
				{
					FileWriter out = new FileWriter(userCatalog);
					out.write(jEdit.getProperty(""defaultCatalog""));
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,jEdit.class,io);
				}
			}

			loadModeCatalog(userCatalog.getPath(),false);
		} 

		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			
			
			buffer.setMode();

			buffer = buffer.next;
		}
	} 

	
	
	public static Mode getMode(String name)
	{
		for(int i = 0; i < modes.size(); i++)
		{
			Mode mode = (Mode)modes.elementAt(i);
			if(mode.getName().equals(name))
				return mode;
		}
		return null;
	} 

	
	
	public static Mode[] getModes()
	{
		Mode[] array = new Mode[modes.size()];
		modes.copyInto(array);
		return array;
	} 

	

	

	
	
	public static void showOpenFileDialog(View view)
	{
		showOpenFileDialog(view,null);
	} 

	
	
	public static void showOpenFileWithOtherEncodingDialog(View view)
	{
		String encoding = GUIUtilities.input(view,""encoding-prompt"",null,
			jEdit.getProperty(""buffer.encoding"",
			System.getProperty(""file.encoding"")));
		if(encoding == null)
			return;

		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
		{
			recorder.record(""props = new Hashtable();"");
			recorder.record(""props.put(\""encoding\"",\"""" + encoding + ""\"");"");
			recorder.record(""jEdit.showOpenFileDialog(view,props);"");
		}

		Hashtable props = new Hashtable();
		props.put(Buffer.ENCODING,encoding);
		showOpenFileDialog(view,props);
	} 

	
	
	public static void showOpenFileDialog(View view, Hashtable props)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,null,
			VFSBrowser.OPEN_DIALOG,true);

		Buffer buffer = null;
		if(files != null)
		{
			for(int i = 0; i < files.length; i++)
			{
				Buffer newBuffer = openFile(null,null,files[i],
					false,props);
				if(newBuffer != null)
					buffer = newBuffer;
			}
		}

		if(buffer != null)
			view.setBuffer(buffer);
	} 

	
	
	public static String restoreOpenFiles()
	{
		if(settingsDirectory == null)
			return null;

		File session = new File(MiscUtilities.constructPath(
			settingsDirectory,""session""));

		if(!session.exists())
			return null;

		String splitConfig = null;

		try
		{
			BufferedReader in = new BufferedReader(new FileReader(
				session));

			String line;
			while((line = in.readLine()) != null)
			{
				if(line.startsWith(""splits\t""))
					splitConfig = line.substring(7);
				else
					openFile(null,line);
			}

			in.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,jEdit.class,""Error while loading "" + session);
			Log.log(Log.ERROR,jEdit.class,io);
		}

		return splitConfig;
	} 

	
	
	public static void saveOpenFiles(View view)
	{
		if(settingsDirectory == null)
			return;

		view.getEditPane().saveCaretInfo();
		Buffer current = view.getBuffer();

		File session = new File(MiscUtilities.constructPath(
			settingsDirectory,""session""));

		
		

		try
		{
			String lineSep = System.getProperty(""line.separator"");

			BufferedWriter out = new BufferedWriter(new FileWriter(
				session));
			Buffer buffer = buffersFirst;
			while(buffer != null)
			{
				if(!buffer.isUntitled())
				{
					out.write(buffer.getPath());
					out.write(lineSep);
				}

				buffer = buffer.next;
			}

			out.write(""splits\t"");
			out.write(view.getSplitConfig());
			out.write(lineSep);

			out.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,jEdit.class,""Error while saving "" + session);
			Log.log(Log.ERROR,jEdit.class,io);
		}
	} 

	
	
	public static Buffer openFiles(View view, String parent, String[] args)
	{
		Buffer retVal = null;
		Buffer lastBuffer = null;

		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.startsWith(""+line:"") || arg.startsWith(""+marker:""))
			{
				if(lastBuffer != null)
					gotoMarker(view,lastBuffer,arg);
				continue;
			}

			lastBuffer = openFile(null,parent,arg,false,null);

			if(retVal == null && lastBuffer != null)
				retVal = lastBuffer;
		}

		if(view != null && retVal != null)
			view.setBuffer(retVal);

		return retVal;
	} 

	
	
	public static Buffer openFile(View view, String path)
	{
		return openFile(view,null,path,false,new Hashtable());
	} 

	
	
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile)
	{
		return openFile(view,parent,path,newFile,new Hashtable());
	} 

	
	
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile,
		Hashtable props)
	{
		return openFile(view,parent,path,newFile,props);
	} 

	
	
	public static Buffer openFile(View view, String parent,
		String path, boolean newFile, Hashtable props)
	{
		if(view != null && parent == null)
			parent = MiscUtilities.getParentOfPath(view.getBuffer().getPath());

		if(MiscUtilities.isURL(path))
		{
			if(MiscUtilities.getProtocolOfURL(path).equals(""file""))
				path = path.substring(5);
		}

		path = MiscUtilities.constructPath(parent,path);

		if(!MiscUtilities.isURL(path))
			path = MiscUtilities.canonPath(path);

		synchronized(bufferListLock)
		{
			Buffer buffer = getBuffer(path);
			if(buffer != null)
			{
				if(view != null)
					view.setBuffer(buffer);

				return buffer;
			}

			if(props == null)
				props = new Hashtable();

			BufferHistory.Entry entry = BufferHistory.getEntry(path);

			if(entry != null && saveCaret && props.get(Buffer.CARET) == null)
			{
				int caret = entry.caret;
				props.put(Buffer.CARET,new Integer(entry.caret));
				if(entry.selection != null)
				{
					
					
					props.put(Buffer.SELECTION,entry.getSelection());
				}
			}

			if(entry != null && props.get(Buffer.ENCODING) == null)
			{
				if(entry.encoding != null)
					props.put(Buffer.ENCODING,entry.encoding);
			}

			Buffer newBuffer = new Buffer(path,newFile,false,props);

			if(!newBuffer.load(view,false))
				return null;

			addBufferToList(newBuffer);

			EditBus.send(new BufferUpdate(newBuffer,view,BufferUpdate.CREATED));

			if(view != null)
				view.setBuffer(newBuffer);

			return newBuffer;
		}
	} 

	
	
	public static Buffer openTemporary(View view, String parent,
		String path, boolean newFile)
	{
		if(view != null && parent == null)
			parent = MiscUtilities.getParentOfPath(view.getBuffer().getPath());

		if(MiscUtilities.isURL(path))
		{
			if(MiscUtilities.getProtocolOfURL(path).equals(""file""))
				path = path.substring(5);
		}

		path = MiscUtilities.constructPath(parent,path);

		synchronized(bufferListLock)
		{
			Buffer buffer = getBuffer(path);
			if(buffer != null)
				return buffer;

			buffer = new Buffer(path,newFile,true,new Hashtable());
			if(!buffer.load(view,false))
				return null;
			else
				return buffer;
		}
	} 

	
	
	public static void commitTemporary(Buffer buffer)
	{
		if(!buffer.isTemporary())
			return;

		addBufferToList(buffer);
		buffer.commitTemporary();

		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.CREATED));
	} 

	
	
	public static Buffer newFile(View view)
	{
		String path;

		if(view != null && view.getBuffer() != null)
		{
			path = MiscUtilities.getParentOfPath(view.getBuffer()
				.getPath());
			VFS vfs = VFSManager.getVFSForPath(path);
			
			
			if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)
				path = System.getProperty(""user.home"");
		}
		else
			path = null;

		return newFile(view,path);
	} 

	
	
	public static Buffer newFile(View view, String dir)
	{
		
		
		if(dir != null
			&& buffersFirst != null
			&& buffersFirst == buffersLast
			&& buffersFirst.isUntitled()
			&& !buffersFirst.isDirty())
		{
			closeBuffer(view,buffersFirst);
			
			return buffersFirst;
		}

		
		int untitledCount = 0;
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.getName().startsWith(""Untitled-""))
			{
				try
				{
					untitledCount = Math.max(untitledCount,
						Integer.parseInt(buffer.getName()
						.substring(9)));
				}
				catch(NumberFormatException nf)
				{
				}
			}
			buffer = buffer.next;
		}

		return openFile(view,dir,""Untitled-"" + (untitledCount+1),true,null);
	} 

	

	

	
	
	public static boolean closeBuffer(View view, Buffer buffer)
	{
		
		if(buffer.isPerformingIO())
		{
			VFSManager.waitForRequests();
			if(VFSManager.errorOccurred())
				return false;
		}

		if(buffer.isDirty())
		{
			Object[] args = { buffer.getName() };
			int result = GUIUtilities.confirm(view,""notsaved"",args,
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result == JOptionPane.YES_OPTION)
			{
				if(!buffer.save(view,null,true))
					return false;
			}
			else if(result != JOptionPane.NO_OPTION)
				return false;
		}

		_closeBuffer(view,buffer);

		return true;
	} 

	
	
	public static void _closeBuffer(View view, Buffer buffer)
	{
		if(buffer.isClosed())
		{
			
			
			return;
		}

		if(!buffer.isNewFile())
		{
			view.getEditPane().saveCaretInfo();
			Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
			int caret = (_caret == null ? 0 : _caret.intValue());

			BufferHistory.setEntry(buffer.getPath(),caret,
				(Selection[])buffer.getProperty(Buffer.SELECTION),
				buffer.getStringProperty(Buffer.ENCODING));
		}

		removeBufferFromList(buffer);
		buffer.close();

		EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSED));

		
		if(buffersFirst == null && buffersLast == null)
			newFile(view);
	} 

	
	
	public static boolean closeAllBuffers(View view)
	{
		return closeAllBuffers(view,false);
	} 

	
	
	public static boolean closeAllBuffers(View view, boolean isExiting)
	{
		boolean dirty = false;

		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
			{
				dirty = true;
				break;
			}
			buffer = buffer.next;
		}

		if(dirty)
		{
			boolean ok = new CloseDialog(view).isOK();
			if(!ok)
				return false;
		}

		
		VFSManager.waitForRequests();
		if(VFSManager.errorOccurred())
			return false;

		
		

		buffer = buffersFirst;

		
		buffersFirst = buffersLast = null;
		bufferCount = 0;

		while(buffer != null)
		{
			if(!buffer.isNewFile())
			{
				Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
				int caret = (_caret == null ? 0 : _caret.intValue());
				BufferHistory.setEntry(buffer.getPath(),caret,
					(Selection[])buffer.getProperty(Buffer.SELECTION),
					buffer.getStringProperty(Buffer.ENCODING));
			}

			buffer.close();
			if(!isExiting)
			{
				EditBus.send(new BufferUpdate(buffer,view,
					BufferUpdate.CLOSED));
			}
			buffer = buffer.next;
		}

		if(!isExiting)
			newFile(view);

		return true;
	} 

	
	
	public static void saveAllBuffers(View view, boolean confirm)
	{
		if(confirm)
		{
			int result = GUIUtilities.confirm(view,""saveall"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}

		Buffer current = view.getBuffer();

		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
			{
				if(buffer.isNewFile())
					view.setBuffer(buffer);
				buffer.save(view,null,true);
			}

			buffer = buffer.next;
		}

		view.setBuffer(current);
	} 

	
	
	public static void reloadAllBuffers(final View view, boolean confirm)
	{
		if(confirm)
		{
			int result = GUIUtilities.confirm(view,""reload-all"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}

		
		View _view = viewsFirst;
		while(_view != null)
		{
			EditPane[] panes = _view.getEditPanes();
			for(int i = 0; i < panes.length; i++)
			{
				panes[i].saveCaretInfo();
			}

			_view = _view.next;
		}

		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			buffer.load(view,true);
		}
	} 

	
	
	public static Buffer getBuffer(String path)
	{
		boolean caseInsensitiveFilesystem = (File.separatorChar == '\\'
			|| File.separatorChar == ':' );

		synchronized(bufferListLock)
		{
			Buffer buffer = buffersFirst;
			while(buffer != null)
			{
				String _path = buffer.getPath();
				if(caseInsensitiveFilesystem)
				{
					if(_path.equalsIgnoreCase(path))
						return buffer;
				}
				else
				{
					if(_path.equals(path))
						return buffer;
				}
				buffer = buffer.next;
			}
		}

		return null;
	} 

	
	
	public static Buffer[] getBuffers()
	{
		Buffer[] buffers = new Buffer[bufferCount];
		Buffer buffer = buffersFirst;
		for(int i = 0; i < bufferCount; i++)
		{
			buffers[i] = buffer;
			buffer = buffer.next;
		}
		return buffers;
	} 

	
	
	public static int getBufferCount()
	{
		return bufferCount;
	} 

	
	
	public static Buffer getFirstBuffer()
	{
		return buffersFirst;
	} 

	
	
	public static Buffer getLastBuffer()
	{
		return buffersLast;
	} 

	

	

	
	
	public static InputHandler getInputHandler()
	{
		return inputHandler;
	} 

	
	
	public static View newView(View view, Buffer buffer)
	{
		if(view != null)
		{
			view.showWaitCursor();
			view.getEditPane().saveCaretInfo();
		}

		View newView = new View(buffer,null);

		
		
		
		newView.pack();

		
		
		if(view != null)
		{
			GUIUtilities.saveGeometry(view,""view"");
			view.hideWaitCursor();
		}

		GUIUtilities.loadGeometry(newView,""view"");

		addViewToList(newView);
		EditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));

		GUIUtilities.requestFocus(newView,newView.getTextArea());
		newView.show();

		
		if(newView == viewsFirst)
		{
			
			
			if(settingsDirectory != null && getBooleanProperty(""firstTime""))
				new HelpViewer();
			else if(jEdit.getBooleanProperty(""tip.show""))
				new TipOfTheDay(newView);

			setBooleanProperty(""firstTime"",false);
		}

		return newView;
	} 

	
	
	public static View newView(View view)
	{
		return newView(view,view.getSplitConfig());
	} 

	
	
	public static View newView(View view, String splitConfig)
	{
		if(view != null)
		{
			view.showWaitCursor();
			view.getEditPane().saveCaretInfo();
		}

		View newView = new View(null,splitConfig);

		
		
		
		newView.pack();

		
		
		if(view != null)
		{
			GUIUtilities.saveGeometry(view,""view"");
			view.hideWaitCursor();
		}

		GUIUtilities.loadGeometry(newView,""view"");

		addViewToList(newView);
		EditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));

		GUIUtilities.requestFocus(newView,newView.getTextArea());
		newView.show();

		
		if(newView == viewsFirst)
		{
			
			
			if(settingsDirectory != null && getBooleanProperty(""firstTime""))
				new HelpViewer();
			else if(jEdit.getBooleanProperty(""tip.show""))
				new TipOfTheDay(newView);

			setBooleanProperty(""firstTime"",false);
		}

		return newView;
	} 

	
	
	public static void closeView(View view)
	{
		closeView(view,true);
	} 

	
	
	public static View[] getViews()
	{
		View[] views = new View[viewCount];
		View view = viewsFirst;
		for(int i = 0; i < viewCount; i++)
		{
			views[i] = view;
			view = view.next;
		}
		return views;
	} 

	
	
	public static int getViewCount()
	{
		return viewCount;
	} 

	
	
	public static View getFirstView()
	{
		return viewsFirst;
	} 

	
	
	public static View getLastView()
	{
		return viewsLast;
	} 

	

	

	
	
	public static boolean isBackgroundModeEnabled()
	{
		return background;
	} 

	
	
	public static void showMemoryDialog(View view)
	{
		Runtime rt = Runtime.getRuntime();
		int before = (int) (rt.freeMemory() / 1024);
		System.gc();
		int after = (int) (rt.freeMemory() / 1024);
		int total = (int) (rt.totalMemory() / 1024);

		JProgressBar progress = new JProgressBar(0,total);
		progress.setValue(total - after);
		progress.setStringPainted(true);
		progress.setString(jEdit.getProperty(""memory-status.use"",
			new Object[] { new Integer(total - after),
			new Integer(total) }));

		Object[] message = new Object[4];
		message[0] = getProperty(""memory-status.gc"",
			new Object[] { new Integer(after - before) });
		message[1] = Box.createVerticalStrut(12);
		message[2] = progress;
		message[3] = Box.createVerticalStrut(6);

		JOptionPane.showMessageDialog(view,message,
			jEdit.getProperty(""memory-status.title""),
			JOptionPane.INFORMATION_MESSAGE);
	} 

	
	
	public static String getJEditHome()
	{
		return jEditHome;
	} 

	
	
	public static String getSettingsDirectory()
	{
		return settingsDirectory;
	} 

	
	
	public static void backupSettingsFile(File file)
	{
		if(settingsDirectory == null)
			return;

		String backupDir = MiscUtilities.constructPath(
			settingsDirectory,""settings-backup"");
		File dir = new File(backupDir);
		if(!dir.exists())
			dir.mkdirs();

		
		

		MiscUtilities.saveBackup(file,5,null,""~"",backupDir);
	} 

	
	
	public static void saveSettings()
	{
		if(settingsDirectory != null)
		{
			
			File file1 = new File(MiscUtilities.constructPath(
				settingsDirectory, ""#recent.xml#save#""));
			File file2 = new File(MiscUtilities.constructPath(
				settingsDirectory, ""recent.xml""));
			if(file2.exists() && file2.lastModified() != recentModTime)
			{
				Log.log(Log.WARNING,jEdit.class,file2 + "" changed""
					+ "" on disk; will not save recent files"");
			}
			else
			{
				backupSettingsFile(file2);
				BufferHistory.save(file1);
				file2.delete();
				file1.renameTo(file2);
			}
			recentModTime = file2.lastModified();

			file1 = new File(MiscUtilities.constructPath(
				settingsDirectory, ""#history#save#""));
			file2 = new File(MiscUtilities.constructPath(
				settingsDirectory, ""history""));
			if(file2.exists() && file2.lastModified() != historyModTime)
			{
				Log.log(Log.WARNING,jEdit.class,file2 + "" changed""
					+ "" on disk; will not save history"");
			}
			else
			{
				backupSettingsFile(file2);
				HistoryModel.saveHistory(file1);
				file2.delete();
				file1.renameTo(file2);
			}
			historyModTime = file2.lastModified();

			SearchAndReplace.save();
			Abbrevs.save();
			FavoritesVFS.saveFavorites();

			file1 = new File(MiscUtilities.constructPath(
				settingsDirectory,""#properties#save#""));
			file2 = new File(MiscUtilities.constructPath(
				settingsDirectory,""properties""));
			if(file2.exists() && file2.lastModified() != propsModTime)
			{
				Log.log(Log.WARNING,jEdit.class,file2 + "" changed""
					+ "" on disk; will not save user properties"");
			}
			else
			{
				backupSettingsFile(file2);

				try
				{
					OutputStream out = new FileOutputStream(file1);
					props.store(out,""jEdit properties"");
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,jEdit.class,io);
				}

				file2.delete();
				file1.renameTo(file2);
			}
			propsModTime = file2.lastModified();
		}
	} 

	
	
	public static void exit(View view, boolean reallyExit)
	{
		
		VFSManager.waitForRequests();

		
		EditBus.send(new EditorExitRequested(view));

		
		
		reallyExit |= !background;

		saveOpenFiles(view);

		
		if(!closeAllBuffers(view,reallyExit))
			return;

		
		
		if(!reallyExit)
		{
			
			
			
			view = viewsFirst;
			while(view != null)
			{
				closeView(view,false);
				view = view.next;
			}

			
			
			saveSettings();

			return;
		}

		
		
		
		view.close();

		
		Autosave.stop();

		
		if(server != null)
			server.stopServer();

		
		EditPlugin[] plugins = getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			try
			{
				plugins[i].stop();
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,jEdit.class,""Error while ""
					+ ""stopping plugin:"");
				Log.log(Log.ERROR,jEdit.class,t);
			}
		}

		
		EditBus.send(new EditorExiting(null));

		
		saveSettings();

		
		Log.closeStream();

		
		System.exit(0);
	} 

	

	

	
	
	static void updatePosition(Buffer buffer)
	{
		if(sortBuffers)
		{
			removeBufferFromList(buffer);
			addBufferToList(buffer);
		}
	} 

	
	
	public static void addMode(Mode mode)
	{
		Log.log(Log.DEBUG,jEdit.class,""Adding edit mode ""
			+ mode.getName());

		modes.addElement(mode);
	} 

	
	
	 static void loadMode(Mode mode)
	{
		Object fileName = mode.getProperty(""file"");

		Log.log(Log.NOTICE,jEdit.class,""Loading edit mode "" + fileName);

		XmlParser parser = new XmlParser();
		XModeHandler xmh = new XModeHandler(parser,mode.getName(),fileName.toString());
		parser.setHandler(xmh);
		try
		{
			Reader grammar;
			if(fileName instanceof URL)
			{
				grammar = new BufferedReader(
					new InputStreamReader(
					((URL)fileName).openStream()));
			}
			else
			{
				grammar = new BufferedReader(new FileReader(
					(String)fileName));
			}

			parser.parse(null, null, grammar);
		}
		catch (Throwable e)
		{
			Log.log(Log.ERROR, jEdit.class, e);

			if (e instanceof XmlException)
			{
				XmlException xe = (XmlException) e;
				int line = xe.getLine();
				String message = xe.getMessage();

				Object[] args = { fileName, new Integer(line), message };
				GUIUtilities.error(null,""xmode-parse"",args);
			}

			
			TokenMarker marker = new TokenMarker();
			marker.addRuleSet(""MAIN"",new ParserRuleSet(""MAIN"",mode));
			mode.setTokenMarker(marker);
		}
	} 

	
	
	 static void loadProps(InputStream in, boolean def)
		throws IOException
	{
		in = new BufferedInputStream(in);
		if(def)
			defaultProps.load(in);
		else
			props.load(in);
		in.close();
	} 

	
	
	static boolean loadActions(String path, Reader in, ActionSet actionSet)
	{
		try
		{
			Log.log(Log.DEBUG,jEdit.class,""Loading actions from "" + path);

			ActionListHandler ah = new ActionListHandler(path,actionSet);
			XmlParser parser = new XmlParser();
			parser.setHandler(ah);
			parser.parse(null, null, in);
			return true;
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,jEdit.class,path + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}

		return false;
	} 

	
	static void pluginError(final String path, String messageProp, Object[] args)
	{
		if(pluginErrors == null)
			pluginErrors = new Vector();

		pluginErrors.addElement(new ErrorListDialog.ErrorEntry(
			path,messageProp,args));
	} 

	

	

	
	private static String jEditHome;
	private static String settingsDirectory;
	private static long propsModTime, historyModTime, recentModTime;
	private static Properties defaultProps;
	private static Properties props;
	private static EditServer server;
	private static boolean background;
	private static Vector actionSets;
	private static ActionSet builtInActionSet;
	private static Vector pluginErrors;
	private static Vector jars;
	private static Vector modes;
	private static Vector recent;
	private static boolean saveCaret;
	private static InputHandler inputHandler;
	private static JEditMetalTheme theme;

	
	private static boolean sortBuffers;
	private static boolean sortByName;
	private static int bufferCount;
	private static Buffer buffersFirst;
	private static Buffer buffersLast;

	
	private static Object bufferListLock = new Object();

	
	private static int viewCount;
	private static View viewsFirst;
	private static View viewsLast;
	

	private jEdit() {}

	
	private static void usage()
	{
		System.out.println(""Usage: jedit [<options>] [<files>]"");

		System.out.println(""	<file> +marker:<marker>: Positions caret""
			+ "" at marker <marker>"");
		System.out.println(""	<file> +line:<line>: Positions caret""
			+ "" at line number <line>"");
		System.out.println(""	--: End of options"");
		System.out.println(""	-background: Run in background mode"");
		System.out.println(""	-nogui: Only if running in background mode;""
			+ "" don't open initial view"");
		System.out.println(""	-norestore: Don't restore previously open files"");
		System.out.println(""	-run=<script>: Run the specified BeanShell script"");
		System.out.println(""	-server: Read/write server""
			+ "" info from/to $HOME/.jedit/server"");
		System.out.println(""	-server=<name>: Read/write server""
			+ "" info from/to $HOME/.jedit/<name>"");
		System.out.println(""	-noserver: Don't start edit server"");
		System.out.println(""	-settings=<path>: Load user-specific""
			+ "" settings from <path>"");
		System.out.println(""	-nosettings: Don't load user-specific""
			+ "" settings"");
		System.out.println(""	-noplugins: Don't load any plugins"");
		System.out.println(""	-nostartupscripts: Don't run startup scripts"");
		System.out.println(""	-version: Print jEdit version and exit"");
		System.out.println(""	-usage: Print this message and exit"");
		System.out.println();
		System.out.println(""To set minimum activity log level,""
			+ "" specify a number as the first"");
		System.out.println(""command line parameter""
			+ "" (1-9, 1 = print everything, 9 = fatal errors only)"");
		System.out.println();
		System.out.println(""Report bugs to Slava Pestov <slava@jedit.org>."");
	} 

	
	private static void version()
	{
		System.out.println(""jEdit "" + getVersion());
	} 

	
	
	private static String makeServerScript(boolean restore,
		String[] args, String scriptFile)
	{
		StringBuffer script = new StringBuffer();

		String userDir = System.getProperty(""user.dir"");

		script.append(""parent = \"""");
		script.append(MiscUtilities.charsToEscapes(userDir));
		script.append(""\"";\n"");

		script.append(""args = new String["");
		script.append(args.length);
		script.append(""];\n"");

		for(int i = 0; i < args.length; i++)
		{
			script.append(""args["");
			script.append(i);
			script.append(""] = "");

			if(args[i] == null)
				script.append(""null"");
			else
			{
				script.append('""');
				script.append(MiscUtilities.charsToEscapes(args[i]));
				script.append('""');
			}

			script.append("";\n"");
		}

		script.append(""EditServer.handleClient("" + restore + "",parent,args);\n"");

		if(scriptFile != null)
		{
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			script.append(""BeanShell.runScript(null,\""""
				+ MiscUtilities.charsToEscapes(scriptFile)
				+ ""\"",null,false);\n"");
		}

		return script.toString();
	} 

	
	
	private static void initMisc()
	{
		
		System.getProperties().put(""java.protocol.handler.pkgs"",
			""org.gjt.sp.jedit.proto|"" +
			System.getProperty(""java.protocol.handler.pkgs"",""""));

		
		String userAgent = ""jEdit/"" + getVersion()
			+ "" (Java "" + System.getProperty(""java.version"")
			+ "". "" + System.getProperty(""java.vendor"")
			+ ""; "" + System.getProperty(""os.arch"") + "")"";
		System.getProperties().put(""http.agent"",userAgent);

		inputHandler = new DefaultInputHandler(null);

		
		jEditHome = System.getProperty(""jedit.home"");
		if(jEditHome == null)
		{
			String classpath = System
				.getProperty(""java.class.path"");
			int index = classpath.toLowerCase()
				.indexOf(""jedit.jar"");
			int start = classpath.lastIndexOf(File
				.pathSeparator,index) + 1;
			
			 if(classpath.equalsIgnoreCase(""jedit.jar""))
			{
				jEditHome = System.getProperty(""user.dir"");
			}
			else if(index > start)
			{
				jEditHome = classpath.substring(start,
					index - 1);
			}
			else
			{
				
				
				{
					
					jEditHome = System.getProperty(""user.dir"");

					Log.log(Log.WARNING,jEdit.class,""jedit.jar not in class path!"");
					Log.log(Log.WARNING,jEdit.class,""Assuming jEdit is installed in ""
						+ jEditHome + ""."");
					Log.log(Log.WARNING,jEdit.class,""Override with jedit.home ""
						+ ""system property."");
				}
			}
		}

		Log.log(Log.MESSAGE,jEdit.class,""jEdit home directory is "" + jEditHome);

		
		

		jars = new Vector();

		
		
		EditBus.addToBus(new SettingsReloader());

		
		
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				Thread.currentThread().setContextClassLoader(
					new JARClassLoader());
			}
		});
	} 

	
	
	private static void initSystemProperties()
	{
		defaultProps = props = new Properties();

		try
		{
			loadProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit.props""),true);
			loadProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_gui.props""),true);
			loadProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_keys.props""),true);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,
				""Error while loading system properties!"");
			Log.log(Log.ERROR,jEdit.class,
				""One of the following property files could not be loaded:\n""
				+ ""- jedit.props\n""
				+ ""- jedit_gui.props\n""
				+ ""- jedit_keys.props\n""
				+ ""jedit.jar is probably corrupt."");
			Log.log(Log.ERROR,jEdit.class,e);
			System.exit(1);
		}
	} 

	
	
	private static void initSiteProperties()
	{
		
		

		String siteSettingsDirectory = MiscUtilities.constructPath(
			jEditHome, ""properties"");
		File siteSettings = new File(siteSettingsDirectory);

		if (!(siteSettings.exists() && siteSettings.isDirectory()))
			return;

		String[] snippets = siteSettings.list();
		if (snippets == null)
			return;

		MiscUtilities.quicksort(snippets,
			new MiscUtilities.StringICaseCompare());

		for (int i = 0; i < snippets.length; ++i)
		{
			String snippet = snippets[i];
			if(!snippet.toLowerCase().endsWith("".props""))
				continue;

			try
			{
				String path = MiscUtilities.constructPath(
					siteSettingsDirectory,snippet);
				Log.log(Log.DEBUG,jEdit.class,
					""Loading site snippet: "" + path);

				loadProps(new FileInputStream(new File(path)),true);
			}
			catch(FileNotFoundException fnf)
			{
				Log.log(Log.DEBUG,jEdit.class,fnf);
			}
			catch(IOException e)
			{
				Log.log(Log.ERROR,jEdit.class,""Cannot load site snippet ""
					+ snippet);
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} 

	
	
	private static void initActions()
	{
		actionSets = new Vector();

		Reader in = new BufferedReader(new InputStreamReader(
			jEdit.class.getResourceAsStream(""actions.xml"")));
		builtInActionSet = new ActionSet(jEdit.getProperty(
			""action-set.jEdit""));
		if(!loadActions(""actions.xml"",in,builtInActionSet))
			System.exit(1);
		addActionSet(builtInActionSet);
	} 

	
	
	private static void initDockables()
	{
		Reader in = new BufferedReader(new InputStreamReader(
			jEdit.class.getResourceAsStream(""dockables.xml"")));
		if(!DockableWindowManager.loadDockableWindows(""dockables.xml"",
			in,builtInActionSet))
			System.exit(1);
	} 

	
	
	private static void initPlugins()
	{
		if(jEditHome != null)
			loadPlugins(MiscUtilities.constructPath(jEditHome,""jars""));

		if(settingsDirectory != null)
		{
			File jarsDirectory = new File(settingsDirectory,""jars"");
			if(!jarsDirectory.exists())
				jarsDirectory.mkdir();
			loadPlugins(jarsDirectory.getPath());
		}
	} 

	
	
	private static void initUserProperties()
	{
		props = new Properties(defaultProps);

		if(settingsDirectory != null)
		{
			File file = new File(MiscUtilities.constructPath(
				settingsDirectory,""properties""));
			propsModTime = file.lastModified();

			try
			{
				loadProps(new FileInputStream(file),false);
			}
			catch(FileNotFoundException fnf)
			{
				Log.log(Log.DEBUG,jEdit.class,fnf);
			}
			catch(IOException e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} 

	
	
	private static void initPLAF()
	{
		theme = new JEditMetalTheme();
		theme.propertiesChanged();
		MetalLookAndFeel.setCurrentTheme(theme);

		try
		{
			String lf = getProperty(""lookAndFeel"");
			if(lf != null && lf.length() != 0)
				UIManager.setLookAndFeel(lf);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}

		UIDefaults defaults = UIManager.getDefaults();

		
		if(jEdit.getBooleanProperty(""textColors""))
		{
			Color background = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.bgColor""));
			Color foreground = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.fgColor""));
			Color caretColor = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.caretColor""));
			Color selectionColor = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.selectionColor""));

			String[] prefixes = { ""TextField"", ""TextArea"", ""List"", ""Table"" };
			for(int i = 0; i < prefixes.length; i++)
			{
				String prefix = prefixes[i];
				defaults.put(prefix + "".disabledBackground"",background);
				defaults.put(prefix + "".background"",background);
				defaults.put(prefix + "".disabledForeground"",foreground);
				defaults.put(prefix + "".foreground"",foreground);
				defaults.put(prefix + "".caretForeground"",caretColor);
				defaults.put(prefix + "".selectionForeground"",foreground);
				defaults.put(prefix + "".selectionBackground"",selectionColor);
				
			}

			defaults.put(""Tree.background"",background);
			defaults.put(""Tree.foreground"",foreground);
			defaults.put(""Tree.textBackground"",background);
			defaults.put(""Tree.textForeground"",foreground);
			defaults.put(""Tree.selectionForeground"",foreground);
			defaults.put(""Tree.selectionBackground"",selectionColor);
		}

		defaults.remove(""SplitPane.border"");
		defaults.remove(""SplitPaneDivider.border"");
	} 

	
	
	private static void runStartupScripts(File directory)
	{
		if (!directory.isDirectory())
			return;

		String[] snippets = directory.list();
		if (snippets == null)
			return;

		MiscUtilities.quicksort(snippets,
			new MiscUtilities.StringICaseCompare());

		for(int i = 0; i < snippets.length; ++i)
		{
			String snippet = snippets[i];
			if(!snippet.toLowerCase().endsWith("".bsh""))
				continue;

			String path = new File(directory,snippet).getPath();

			BeanShell.runScript(null,path,null,false);
		}
	} 

	
	private static void initProxy()
	{
		boolean enabled = jEdit.getBooleanProperty(""firewall.enabled"");
		if (!enabled) {
			Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy disabled"");
			System.getProperties().remove(""proxySet"");
			System.getProperties().remove(""proxyHost"");
			System.getProperties().remove(""proxyPort"");
			System.getProperties().remove(""http.proxyHost"");
			System.getProperties().remove(""http.proxyPort"");
			System.getProperties().remove(""http.nonProxyHosts"");
			Authenticator.setDefault(null);
		} else {
			
			String host = jEdit.getProperty(""firewall.host"");
			if (host == null)
				return;

			System.setProperty(""http.proxyHost"", host);
			Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy enabled: "" + host);
			
			String port = jEdit.getProperty(""firewall.port"");
			if (port != null)
				System.setProperty(""http.proxyPort"", port);

			
			String nonProxyHosts = jEdit.getProperty(""firewall.nonProxyHosts"");
			if (nonProxyHosts != null)
				System.setProperty(""http.nonProxyHosts"", nonProxyHosts);

			
			String username = jEdit.getProperty(""firewall.user"");
			String password = jEdit.getProperty(""firewall.password"");

			
			if(password == null)
				password = """";

			if(username == null || username.length()==0)
			{
				Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy without user"");
				Authenticator.setDefault(new FirewallAuthenticator(null));
			}
			else
			{
				Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy user: "" + username);
				PasswordAuthentication pw = new PasswordAuthentication(
					username,password.toCharArray()
				);
				Authenticator.setDefault(new FirewallAuthenticator(pw));
			}
		}
	} 

	
	static class FirewallAuthenticator extends Authenticator
	{
		PasswordAuthentication pw;

		public FirewallAuthenticator(PasswordAuthentication pw)
		{
			this.pw = pw;
		}

		protected PasswordAuthentication getPasswordAuthentication()
		{
			return pw;
		}
	} 

	
	private static void getNotLoadedPluginJARs(Vector returnValue,
		String dir, String[] list)
	{
loop:		for(int i = 0; i < list.length; i++)
		{
			String name = list[i];
			if(!name.toLowerCase().endsWith("".jar""))
				continue loop;

			String path = MiscUtilities.constructPath(dir,name);

			for(int j = 0; j < jars.size(); j++)
			{
				EditPlugin.JAR jar = (EditPlugin.JAR)
					jars.elementAt(j);
				String jarPath = jar.getPath();
				String jarName = MiscUtilities.getFileName(jarPath);

				if(path.equals(jarPath))
					continue loop;
				else if(!new File(jarPath).exists()
					&& name.equals(jarName))
					continue loop;
			}

			returnValue.addElement(path);
		}
	} 

	
	private static void gotoMarker(final View view, final Buffer buffer,
		final String marker)
	{
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				int pos;

				
				if(marker.startsWith(""+line:""))
				{
					try
					{
						int line = Integer.parseInt(marker.substring(6));
						pos = buffer.getLineStartOffset(line - 1);
					}
					catch(Exception e)
					{
						return;
					}
				}
				
				else if(marker.startsWith(""+marker:""))
				{
					if(marker.length() != 9)
						return;

					Marker m = buffer.getMarker(marker.charAt(8));
					if(m == null)
						return;
					pos = m.getPosition();
				}
				
				else
					throw new InternalError();

				if(view != null && view.getBuffer() == buffer)
					view.getTextArea().setCaretPosition(pos);
				else
					buffer.setIntegerProperty(Buffer.CARET,pos);
			}
		});
	} 

	
	private static void addBufferToList(Buffer buffer)
	{
		
		
		if(viewCount <= 1 && buffersFirst != null
			&& buffersFirst == buffersLast
			&& buffersFirst.isUntitled()
			&& !buffersFirst.isDirty())
		{
			Buffer oldBuffersFirst = buffersFirst;
			buffersFirst = buffersLast = buffer;
			EditBus.send(new BufferUpdate(oldBuffersFirst,null,
				BufferUpdate.CLOSED));
			return;
		}

		bufferCount++;

		if(buffersFirst == null)
		{
			buffersFirst = buffersLast = buffer;
			return;
		}
		

		
		else if(sortBuffers)
		{
			String name1 = (sortByName ? buffer.toString()
				: buffer.getPath());

			Buffer _buffer = buffersFirst;
			while(_buffer != null)
			{
				String name2 = (sortByName ? _buffer.toString()
					: _buffer.getPath());
				if(MiscUtilities.compareStrings(name1,name2,true) <= 0)
				{
					buffer.next = _buffer;
					buffer.prev = _buffer.prev;
					_buffer.prev = buffer;
					if(_buffer != buffersFirst)
						buffer.prev.next = buffer;
					else
						buffersFirst = buffer;
					return;
				}

				_buffer = _buffer.next;
			}
		} 

		buffer.prev = buffersLast;
		buffersLast.next = buffer;
		buffersLast = buffer;
	} 

	
	private static void removeBufferFromList(Buffer buffer)
	{
		synchronized(bufferListLock)
		{
			bufferCount--;

			if(buffer == buffersFirst && buffer == buffersLast)
			{
				buffersFirst = buffersLast = null;
				return;
			}

			if(buffer == buffersFirst)
			{
				buffersFirst = buffer.next;
				buffer.next.prev = null;
			}
			else
			{
				buffer.prev.next = buffer.next;
			}

			if(buffer == buffersLast)
			{
				buffersLast = buffersLast.prev;
				buffer.prev.next = null;
			}
			else
			{
				buffer.next.prev = buffer.prev;
			}

			
			
			buffer.next = buffer.prev = null;
		}
	} 

	
	private static void addViewToList(View view)
	{
		viewCount++;

		if(viewsFirst == null)
			viewsFirst = viewsLast = view;
		else
		{
			view.prev = viewsLast;
			viewsLast.next = view;
			viewsLast = view;
		}
	} 

	
	private static void removeViewFromList(View view)
	{
		viewCount--;

		if(viewsFirst == viewsLast)
		{
			viewsFirst = viewsLast = null;
			return;
		}

		if(view == viewsFirst)
		{
			viewsFirst = view.next;
			view.next.prev = null;
		}
		else
		{
			view.prev.next = view.next;
		}

		if(view == viewsLast)
		{
			viewsLast = viewsLast.prev;
			view.prev.next = null;
		}
		else
		{
			view.next.prev = view.prev;
		}
	} 

	
	
	private static void closeView(View view, boolean callExit)
	{
		if(viewsFirst == viewsLast && callExit)
			exit(view,false); 
		else
		{
			EditBus.send(new ViewUpdate(view,ViewUpdate.CLOSED));

			view.close();
			removeViewFromList(view);
		}
	} 

	
	
	private static void loadModeCatalog(String path, boolean resource)
	{
		Log.log(Log.MESSAGE,jEdit.class,""Loading mode catalog file "" + path);

		ModeCatalogHandler handler = new ModeCatalogHandler(
			MiscUtilities.getParentOfPath(path),resource);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		try
		{
			InputStream _in;
			if(resource)
				_in = jEdit.class.getResourceAsStream(path);
			else
				_in = new FileInputStream(path);
			BufferedReader in = new BufferedReader(
				new InputStreamReader(_in));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,jEdit.class,path + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}
	} 

	
	
	private static void loadPlugins(String directory)
	{
		Log.log(Log.NOTICE,jEdit.class,""Loading plugins from ""
			+ directory);

		File file = new File(directory);
		if(!(file.exists() && file.isDirectory()))
			return;
		String[] plugins = file.list();
		if(plugins == null)
			return;

		MiscUtilities.quicksort(plugins,new MiscUtilities.StringICaseCompare());
		for(int i = 0; i < plugins.length; i++)
		{
			String plugin = plugins[i];
			if(!plugin.toLowerCase().endsWith("".jar""))
				continue;

			String path = MiscUtilities.constructPath(directory,plugin);

			if(plugin.equals(""EditBuddy.jar"")
				|| plugin.equals(""PluginManager.jar"")
				|| plugin.equals(""Firewall.jar"")
				|| plugin.equals(""Tidy.jar""))
			{
				pluginError(path,""plugin-error.obsolete"",null);
				continue;
			}

			try
			{
				Log.log(Log.DEBUG,jEdit.class,
					""Scanning JAR file: "" + path);
				new JARClassLoader(path);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,jEdit.class,""Cannot load""
					+ "" plugin "" + plugin);
				Log.log(Log.ERROR,jEdit.class,io);

				String[] args = { io.toString() };
				pluginError(path,""plugin-error.load-error"",args);
			}
		}
	} 

	
	
	private static void initKeyBindings()
	{
		inputHandler.removeAllKeyBindings();

		EditAction[] actions = getActions();
		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];

			String shortcut1 = jEdit.getProperty(action.getName()
				+ "".shortcut"");
			if(shortcut1 != null)
				inputHandler.addKeyBinding(shortcut1,action);

			String shortcut2 = jEdit.getProperty(action.getName()
				+ "".shortcut2"");
			if(shortcut2 != null)
				inputHandler.addKeyBinding(shortcut2,action);
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.io.FileRootsVFS,6,2,0,4,22,13,1,3,5,0.88,150,0.8,0,0.807692308,0.541666667,1,3,23.16666667,4,1.6667,2,"

package org.gjt.sp.jedit.io;


import javax.swing.filechooser.FileSystemView;
import java.awt.Component;
import java.lang.reflect.*;
import java.io.File;
import org.gjt.sp.util.Log;



public class FileRootsVFS extends VFS
{
	public static final String PROTOCOL = ""roots"";

	
	public FileRootsVFS()
	{
		super(""roots"");

		
		try
		{
			method = FileSystemView.class.getMethod(""getSystemDisplayName"",
				new Class[] { java.io.File.class });
			fsView = FileSystemView.getFileSystemView();
			Log.log(Log.DEBUG,this,""FileSystemView.getSystemDisplayName() detected"");
		}
		catch(Exception e)
		{
			Log.log(Log.DEBUG,this,""FileSystemView.getSystemDisplayName() not detected"");
		}
	} 

	
	public int getCapabilities()
	{
		
		
		return 0 ;
	} 

	
	public String getParentOfPath(String path)
	{
		return PROTOCOL + "":"";
	} 

	
	public VFS.DirectoryEntry[] _listDirectory(Object session, String url,
		Component comp)
	{
		File[] roots = File.listRoots();

		if(roots == null)
			return null;

		VFS.DirectoryEntry[] rootDE = new VFS.DirectoryEntry[roots.length];
		for(int i = 0; i < roots.length; i++)
		{
			String name = roots[i].getPath();
			rootDE[i] = _getDirectoryEntry(session,name,comp);
		}

		return rootDE;
	} 

	
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		String name = path;

		if(method != null && !name.startsWith(""A:"") && !name.startsWith(""B:""))
		{
			try
			{
				name = name + "" "" + (String)method.invoke(fsView,
					new Object[] { new File(path) });
			}
			catch(Exception e) {}
		}

		return new VFS.DirectoryEntry(name,path,path,VFS.DirectoryEntry
			.FILESYSTEM,0L,false);
	} 

	
	private FileSystemView fsView;
	private Method method;
	
}
"
jEdit,4,org.gjt.sp.jedit.search.RESearchMatcher,4,1,0,11,28,0,2,9,3,0.611111111,201,0.833333333,3,0.0,0.666666667,0,0,47.75,9,2.5,0,"

package org.gjt.sp.jedit.search;


import bsh.NameSpace;
import gnu.regexp.*;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.BeanShell;
import org.gjt.sp.jedit.MiscUtilities;



public class RESearchMatcher implements SearchMatcher
{
	
	public static final RESyntax RE_SYNTAX_JEDIT
		= new RESyntax(RESyntax.RE_SYNTAX_PERL5)
		.set(RESyntax.RE_CHAR_CLASSES)
		.setLineSeparator(""\n"");

	
	
	public RESearchMatcher(String search, String replace,
		boolean ignoreCase, boolean beanshell,
		String replaceMethod) throws Exception
	{
		if(beanshell && replace != null && replace.length() != 0)
		{
			this.beanshell = true;
			this.replaceMethod = replaceMethod;
			replaceNS = new NameSpace(BeanShell.getNameSpace(),
				""search and replace"");
		}
		else
		{
			
			
			this.replace = MiscUtilities.escapesToChars(replace);
		}

		re = new RE(search,(ignoreCase ? RE.REG_ICASE : 0)
			| RE.REG_MULTILINE,RE_SYNTAX_JEDIT);
	} 

	
	
	public int[] nextMatch(CharIndexed text, boolean start, boolean end,
		boolean firstTime)
	{
		int flags = 0;

		
		
		if(!start)
			flags |= RE.REG_NOTBOL;
		
		
		if(!end)
			flags |= RE.REG_NOTEOL;

		REMatch match = re.getMatch(text,0,flags);
		if(match == null)
			return null;

		int _start = match.getStartIndex();
		int _end = match.getEndIndex();

		
		
		
		if(!firstTime && _start == 0 && _end == 0)
		{
			text.move(1);

			if(text.charAt(0) == CharIndexed.OUT_OF_BOUNDS)
			{
				
				return null;
			}

			match = re.getMatch(text,0,flags | RE.REG_NOTBOL);
			if(match == null)
				return null;
			else
			{
				_start = match.getStartIndex() + 1;
				_end = match.getEndIndex() + 1;
			}
		}

		int[] result = { _start, _end };
		return result;
	} 

	
	
	public String substitute(String text) throws Exception
	{
		REMatch match = re.getMatch(text);
		if(match == null)
			return null;

		if(beanshell)
		{
			int count = re.getNumSubs();
			for(int i = 0; i <= count; i++)
				replaceNS.setVariable(""_"" + i,match.toString(i));

			Object obj = BeanShell.runCachedBlock(replaceMethod,
				null,replaceNS);
			if(obj == null)
				return """";
			else
				return obj.toString();
		}
		else
			return match.substituteInto(replace);
	} 

	
	private String replace;
	private RE re;
	private boolean beanshell;
	private String replaceMethod;
	private NameSpace replaceNS;
	
}
"
jEdit,4,org.gjt.sp.jedit.search.HyperSearchRequest,9,2,0,18,44,14,4,18,2,0.75,352,1.0,4,0.384615385,0.234567901,1,1,37.44444444,11,2.7778,0,"

package org.gjt.sp.jedit.search;


import javax.swing.text.Segment;
import javax.swing.tree.*;
import javax.swing.SwingUtilities;
import org.gjt.sp.jedit.textarea.Selection;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.View;
import org.gjt.sp.util.*;


public class HyperSearchRequest extends WorkRequest
{
	
	public HyperSearchRequest(View view, SearchMatcher matcher,
		HyperSearchResults results, Selection[] selection)
	{
		this.view = view;
		this.matcher = matcher;

		this.results = results;
		this.resultTreeModel = results.getTreeModel();
		this.resultTreeRoot = (DefaultMutableTreeNode)resultTreeModel
			.getRoot();

		this.selection = selection;
	} 

	
	public void run()
	{
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		setProgressMaximum(fileset.getFileCount());
		setStatus(jEdit.getProperty(""hypersearch.status""));

		int resultCount = 0;
		int bufferCount = 0;

		String[] files = fileset.getFiles(view);

		try
		{
			if(selection != null)
			{
				Buffer buffer = jEdit.openTemporary(null,null,files[0],false);
				if(buffer == null)
					return;

				bufferCount = 1;
				resultCount = searchInSelection(buffer);
			}
			else
			{
				int current = 0;

loop:				for(int i = 0; i < files.length; i++)
				{
					setProgressValue(++current);

					Buffer buffer = jEdit.openTemporary(null,null,files[i],false);
					if(buffer == null)
						continue loop;

					int thisResultCount = doHyperSearch(buffer,
						0,buffer.getLength());
					if(thisResultCount != 0)
					{
						bufferCount++;
						resultCount += thisResultCount;
					}
				};
			}
		}
		catch(final Exception e)
		{
			Log.log(Log.ERROR,this,e);
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					GUIUtilities.error(view,""searcherror"",
						new String[] { e.toString() });
				}
			});
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			final int _resultCount = resultCount;
			final int _bufferCount = bufferCount;
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					results.searchDone(_resultCount,_bufferCount);
				}
			});
		}
	} 

	

	
	private View view;
	private SearchMatcher matcher;
	private HyperSearchResults results;
	private DefaultTreeModel resultTreeModel;
	private DefaultMutableTreeNode resultTreeRoot;
	private Selection[] selection;
	

	
	private int searchInSelection(Buffer buffer) throws Exception
	{
		setAbortable(false);

		final DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode(
			buffer.getPath());

		int resultCount = 0;

		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			resultCount += doHyperSearch(buffer,s.getStart(),s.getEnd());
		}

		setAbortable(true);

		return resultCount;
	} 

	
	private int doHyperSearch(Buffer buffer, int start, int end)
		throws Exception
	{
		setAbortable(false);

		final DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode(
			buffer.getPath());

		int resultCount = doHyperSearch(buffer,start,end,bufferNode);

		if(resultCount != 0)
		{
			resultTreeRoot.insert(bufferNode,resultTreeRoot.getChildCount());

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					resultTreeModel.reload(resultTreeRoot);
				}
			});
		}

		setAbortable(true);

		return resultCount;
	} 

	
	private int doHyperSearch(Buffer buffer, int start, int end,
		DefaultMutableTreeNode bufferNode)
	{
		int resultCount = 0;

		try
		{
			buffer.readLock();

			Segment text = new Segment();
			int offset = start;
			int length = end;
			int line = -1;

loop:			for(int counter = 0; ; counter++)
			{
				buffer.getText(offset,length - offset,text);
				int[] match = matcher.nextMatch(
					new CharIndexedSegment(text,false),
					offset == 0,length == buffer.getLength(),
					counter == 0);
				if(match == null)
					break loop;

				int matchStart = offset + match[0];
				int matchEnd = offset + match[1];

				offset += match[1];

				int newLine = buffer.getLineOfOffset(offset);
				if(line == newLine)
				{
					
					
					continue loop;
				}

				line = newLine;

				resultCount++;

				bufferNode.add(new DefaultMutableTreeNode(
					new HyperSearchResult(buffer,line,
					matchStart,matchEnd),false));
			}
		}
		finally
		{
			buffer.readUnlock();
		}

		return resultCount;
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.textarea.ExtensionManager,6,1,0,5,18,0,2,3,0,0.0,176,1.0,0,0.0,0.583333333,0,0,28.16666667,3,2.1667,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;
import java.util.ArrayList;
import org.gjt.sp.util.Log;

class ExtensionManager
{
	
	void addExtension(int layer, TextAreaExtension ext)
	{
		Entry entry = new Entry(layer,ext);

		for(int i = 0; i < extensions.size(); i++)
		{
			int _layer = ((Entry)extensions.get(i)).layer;
			if(layer < _layer)
			{
				extensions.add(i,entry);
				return;
			}
		}

		extensions.add(entry);
	} 

	
	void removeExtension(TextAreaExtension ext)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			Entry entry = (Entry)extensions.get(i);
			if(entry.ext == ext)
			{
				extensions.remove(i);
				return;
			}
		}
	} 

	
	void paintValidLine(Graphics2D gfx, int screenLine,
		int physicalLine, int start, int end, int y)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			TextAreaExtension ext = ((Entry)extensions.get(i)).ext;
			try
			{
				ext.paintValidLine(gfx,screenLine,
					physicalLine,start,end,y);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);

				
				
				extensions.remove(i);
				i--;
			}
		}
	} 

	
	void paintInvalidLine(Graphics2D gfx, int screenLine,
		int y)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			TextAreaExtension ext = ((Entry)extensions.get(i)).ext;
			try
			{
				ext.paintInvalidLine(gfx,screenLine,y);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);

				
				
				extensions.remove(i);
				i--;
			}
		}
	} 

	
	String getToolTipText(int x, int y)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			TextAreaExtension ext = ((Entry)extensions.get(i)).ext;
			String toolTip = ext.getToolTipText(x,y);
			if(toolTip != null)
				return toolTip;
		}

		return null;
	} 

	
	private ArrayList extensions = new ArrayList();
	

	
	static class Entry
	{
		int layer;
		TextAreaExtension ext;

		Entry(int layer, TextAreaExtension ext)
		{
			this.layer = layer;
			this.ext = ext;
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.InputHandler,18,2,1,15,53,71,9,10,16,0.789915966,466,1.0,2,0.15,0.208333333,0,0,24.5,14,2.5556,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.JOptionPane;
import javax.swing.JPopupMenu;
import java.awt.event.*;
import java.awt.Component;
import java.util.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public abstract class InputHandler extends KeyAdapter
{
	
	
	public InputHandler(View view)
	{
		this.view = view;
	} 

	
	
	public void processKeyEvent(KeyEvent evt)
	{
		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			keyTyped(evt);
			break;
		case KeyEvent.KEY_PRESSED:
			keyPressed(evt);
			break;
		case KeyEvent.KEY_RELEASED:
			keyReleased(evt);
			break;
		}
	} 

	
	
	public abstract void addKeyBinding(String keyBinding, EditAction action);
	

	
	
	public abstract void removeKeyBinding(String keyBinding);
	

	
	
	public abstract void removeAllKeyBindings();
	

	
	
	public boolean isPrefixActive()
	{
		return false;
	} 

	
	
	public boolean isRepeatEnabled()
	{
		return repeat;
	} 

	
	
	public void setRepeatEnabled(boolean repeat)
	{
		boolean oldRepeat = this.repeat;
		this.repeat = repeat;
		repeatCount = 0;
		if(oldRepeat != repeat)
			view.getStatus().setMessage(null);
	} 

	
	
	public int getRepeatCount()
	{
		return (repeat && repeatCount > 0 ? repeatCount : 1);
	} 

	
	
	public void setRepeatCount(int repeatCount)
	{
		boolean oldRepeat = this.repeat;
		repeat = true;
		this.repeatCount = repeatCount;
		if(oldRepeat != repeat)
			view.getStatus().setMessage(null);
	} 

	
	
	public EditAction getLastAction()
	{
		return lastAction;
	} 

	
	
	public int getLastActionCount()
	{
		return lastActionCount;
	} 

	
	
	public void readNextChar(String msg, String code)
	{
		view.getStatus().setMessage(msg);
		readNextChar = code;
	} 

	
	
	public void readNextChar(String code)
	{
		readNextChar = code;
	} 

	
	
	public void resetLastActionCount()
	{
		lastAction = null;
		lastActionCount = 0;
	} 

	
	
	public void invokeAction(EditAction action)
	{
		Buffer buffer = view.getBuffer();

		

		
		if(lastAction == action)
			lastActionCount++;
		else
		{
			lastAction = action;
			lastActionCount = 1;
		}

		
		boolean _repeat = repeat;
		int _repeatCount = getRepeatCount();

		
		if(action.noRepeat() || _repeatCount == 1)
			action.invoke(view);
		else
		{
			
			if(_repeatCount > REPEAT_COUNT_THRESHOLD)
			{
				String label = action.getLabel();
				if(label == null)
					label = action.getName();
				else
					label = GUIUtilities.prettifyMenuLabel(label);

				Object[] pp = { label, new Integer(_repeatCount) };

				if(GUIUtilities.confirm(view,""large-repeat-count"",pp,
					JOptionPane.WARNING_MESSAGE,
					JOptionPane.YES_NO_OPTION)
					!= JOptionPane.YES_OPTION)
				{
					repeat = false;
					repeatCount = 0;
					view.getStatus().setMessage(null);
					return;
				}
			}

			try
			{
				buffer.beginCompoundEdit();

				for(int i = 0; i < _repeatCount; i++)
					action.invoke(view);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}

		Macros.Recorder recorder = view.getMacroRecorder();

		if(recorder != null && !action.noRecord())
			recorder.record(_repeatCount,action.getCode());

		
		
		if(_repeat)
		{
			
			
			if(readNextChar != null)
				return;

			repeat = false;
			repeatCount = 0;
			view.getStatus().setMessage(null);
		}
	} 

	
	private static final int REPEAT_COUNT_THRESHOLD = 20;

	
	protected View view;
	protected boolean repeat;
	protected int repeatCount;

	protected EditAction lastAction;
	protected int lastActionCount;

	protected String readNextChar;
	

	
	protected void userInput(char ch)
	{
		lastAction = null;

		if(readNextChar != null)
			invokeReadNextChar(ch);
		else
		{
			JEditTextArea textArea = view.getTextArea();

			Buffer buffer = view.getBuffer();
			

			int _repeatCount = getRepeatCount();
			if(_repeatCount == 1)
				textArea.userInput(ch);
			else
			{
				
				if(_repeatCount > REPEAT_COUNT_THRESHOLD)
				{
					Object[] pp = { String.valueOf(ch),
						new Integer(_repeatCount) };

					if(GUIUtilities.confirm(view,
						""large-repeat-count.user-input"",pp,
						JOptionPane.WARNING_MESSAGE,
						JOptionPane.YES_NO_OPTION)
						!= JOptionPane.YES_OPTION)
					{
						repeat = false;
						repeatCount = 0;
						view.getStatus().setMessage(null);
						return;
					}
				}

				for(int i = 0; i < _repeatCount; i++)
					textArea.userInput(ch);
			}

			Macros.Recorder recorder = view.getMacroRecorder();

			if(recorder != null)
				recorder.record(_repeatCount,ch);
		}

		setRepeatEnabled(false);
	} 

	
	protected void invokeReadNextChar(char ch)
	{
		Buffer buffer = view.getBuffer();

		

		String charStr = MiscUtilities.charsToEscapes(String.valueOf(ch));

		
		int index;
		while((index = readNextChar.indexOf(""__char__"")) != -1)
		{
			readNextChar = readNextChar.substring(0,index)
				+ '\'' + charStr + '\''
				+ readNextChar.substring(index + 8);
		}

		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(getRepeatCount(),readNextChar);

		if(getRepeatCount() != 1)
		{
			try
			{
				buffer.beginCompoundEdit();

				BeanShell.eval(view,BeanShell.getNameSpace(),
					""for(int i = 1; i < ""
					+ getRepeatCount() + ""; i++)\n{\n""
					+ readNextChar + ""\n}"");
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		else
			BeanShell.eval(view,BeanShell.getNameSpace(),readNextChar);

		readNextChar = null;

		view.getStatus().setMessage(null);
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.print.BufferPrinter,4,1,0,6,22,4,0,6,3,0.833333333,118,1.0,0,0.0,0.3,0,0,28.0,5,2.25,0,"

package org.gjt.sp.jedit.print;


import java.awt.print.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class BufferPrinter
{
	
	public static void pageSetup(View view)
	{
		PrinterJob job = PrinterJob.getPrinterJob();
		if(format == null)
			format = job.defaultPage();

		PageFormat newFormat = job.pageDialog(format);
		if(newFormat != null)
			format = newFormat;
	} 

	
	public static void print(View view, Buffer buffer, boolean selection)
	{
		PrinterJob job = PrinterJob.getPrinterJob();
		if(format == null)
			format = job.defaultPage();

		Font font = jEdit.getFontProperty(""print.font"");
		boolean header = jEdit.getBooleanProperty(""print.header"");
		boolean footer = jEdit.getBooleanProperty(""print.footer"");
		boolean lineNumbers = jEdit.getBooleanProperty(""print.lineNumbers"");
		boolean color = jEdit.getBooleanProperty(""print.color"");

		job.setJobName(buffer.getPath());

		job.setPrintable(new BufferPrintable(buffer,font,header,footer,
			lineNumbers,color),format);

		if(!job.printDialog())
			return;

		try
		{
			job.print();
		}
		catch(PrinterAbortException ae)
		{
			Log.log(Log.DEBUG,BufferPrinter.class,ae);
		}
		catch(PrinterException e)
		{
			Log.log(Log.ERROR,BufferPrinter.class,e);
			String[] args = { e.toString() };
			GUIUtilities.error(view,""print-error"",args);
		}
	} 

	
	private static PageFormat format;
	
}
"
jEdit,4,org.gjt.sp.jedit.syntax.ParserRuleFactory,11,1,0,3,16,55,2,1,9,2.0,456,0.0,0,0.0,0.363636364,0,0,40.45454545,6,3.5455,0,"

package org.gjt.sp.jedit.syntax;


public class ParserRuleFactory
{
	
	public static final ParserRule createSpanRule(String begin, String end,
		byte id, boolean noLineBreak, boolean atLineStart,
		boolean excludeMatch, boolean noWordBreak)
	{
		int ruleAction = TokenMarker.SPAN |
			((noLineBreak) ? TokenMarker.NO_LINE_BREAK : 0) |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0) |
			((noWordBreak) ? TokenMarker.NO_WORD_BREAK : 0);

		String[] strings = new String[2];
		strings[0] = begin;
		strings[1] = end;

		int[] ruleSeqLengths = getStringLengthArray(strings);
		char[] ruleChars = getCharArray(strings, ruleSeqLengths);

		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}

	public static final ParserRule createDelegateSpanRule(String begin, String end,
		String delegateSet, byte id, boolean noLineBreak, boolean atLineStart,
		boolean excludeMatch, boolean noWordBreak)
	{
		int ruleAction = TokenMarker.SPAN |
			TokenMarker.DELEGATE |
			((noLineBreak) ? TokenMarker.NO_LINE_BREAK : 0) |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0) |
			((noWordBreak) ? TokenMarker.NO_WORD_BREAK : 0);

		String[] strings = new String[3];
		strings[0] = begin;
		strings[1] = end;
		strings[2] = delegateSet;

		int[] ruleSeqLengths = getStringLengthArray(strings);
		char[] ruleChars = getCharArray(strings, ruleSeqLengths);

		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}

	public static final ParserRule createEOLSpanRule(String seq, byte id,
		boolean atLineStart, boolean excludeMatch)
	{
		int ruleAction = TokenMarker.EOL_SPAN |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0);

		String[] strings = new String[1];
		strings[0] = seq;

		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}

		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}

	public static final ParserRule createMarkPreviousRule(String seq, byte id,
		boolean atLineStart, boolean excludeMatch)
	{
		int ruleAction = TokenMarker.MARK_PREVIOUS |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0);

		String[] strings = new String[1];
		strings[0] = seq;

		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}

		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}

	public static final ParserRule createMarkFollowingRule(String seq, byte id,
		boolean atLineStart, boolean excludeMatch)
	{
		int ruleAction = TokenMarker.MARK_FOLLOWING |
			((atLineStart) ? TokenMarker.AT_LINE_START : 0) |
			((excludeMatch) ? TokenMarker.EXCLUDE_MATCH : 0);

		String[] strings = new String[1];
		strings[0] = seq;

		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}

		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}

	public static final ParserRule createSequenceRule(String seq, byte id, boolean atLineStart)
	{
		int ruleAction = ((atLineStart) ? TokenMarker.AT_LINE_START : 0);

		String[] strings = new String[1];
		strings[0] = seq;

		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}

		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, id);
	}

	public static final ParserRule createEscapeRule(String seq)
	{
		int ruleAction = TokenMarker.IS_ESCAPE;

		String[] strings = new String[1];
		strings[0] = seq;

		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}

		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, Token.NULL);
	}

	public static final ParserRule createWhitespaceRule(String seq)
	{
		int ruleAction = TokenMarker.WHITESPACE;

		String[] strings = new String[1];
		strings[0] = seq;

		int[] ruleSeqLengths = new int[1];
		char[] ruleChars;
		if (seq != null)
		{
			ruleSeqLengths[0] = seq.length();
			ruleChars = seq.toCharArray();
		}
		else
		{
			ruleChars = new char[0];
		}

		return new ParserRule(ruleChars, ruleSeqLengths, ruleAction, Token.NULL);
	}

	
	private static char[] getCharArray(String[] strings, int[] lengthArray)
	{
		if (lengthArray == null || lengthArray.length == 0) return new char[0];

		char[] chars;
	
		int charArrayLength = 0;

		for (int i = 0; i < lengthArray.length; i++)
		{
			charArrayLength += lengthArray[i];
		}

		chars = new char[charArrayLength];

		int copyOffset = 0;

		for (int i = 0; i < strings.length; i++)
		{
			if (strings[i] != null)
			{
				System.arraycopy(strings[i].toCharArray(),0,chars,copyOffset,lengthArray[i]);
				copyOffset += lengthArray[i];
			}
		}

		return chars;
	}

	private static int[] getStringLengthArray(String[] strings)
	{
		int[] stringLengthArray;

		if (strings == null) return new int[0];

		stringLengthArray = new int[strings.length];

		for (int i = 0; i < strings.length; i++)
		{
			if (strings[i] != null)
			{
				stringLengthArray[i] = strings[i].length();
			}
		}

		return stringLengthArray;
	}
}
"
jEdit,4,org.gjt.sp.jedit.BufferHistory,13,1,0,11,61,44,4,10,6,0.833333333,488,1.0,0,0.0,0.180555556,0,0,36.15384615,6,2.6154,1,"

package org.gjt.sp.jedit;

import com.microstar.xml.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;

public class BufferHistory
{
	public static Entry getEntry(String path)
	{
		Enumeration enum = history.elements();
		while(enum.hasMoreElements())
		{
			Entry entry = (Entry)enum.nextElement();
			if(pathsCaseInsensitive)
			{
				if(entry.path.equalsIgnoreCase(path))
					return entry;
			}
			else
			{
				if(entry.path.equals(path))
					return entry;
			}
		}

		return null;
	}

	public static void setEntry(String path, int caret, Selection[] selection,
		String encoding)
	{
		removeEntry(path);
		addEntry(new Entry(path,caret,selectionToString(selection),encoding));
	}

	public static Vector getBufferHistory()
	{
		return history;
	}

	public static void load(File file)
	{
		max = jEdit.getIntegerProperty(""recentFiles"",50);

		Log.log(Log.MESSAGE,jEdit.class,""Loading recent file list "" + file);

		RecentHandler handler = new RecentHandler();
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		try
		{
			BufferedReader in = new BufferedReader(new FileReader(file));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,BufferHistory.class,file + "":"" + line
				+ "": "" + message);
		}
		catch(FileNotFoundException fnf)
		{
			Log.log(Log.DEBUG,BufferHistory.class,fnf);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
	}

	public static void save(File file)
	{
		String lineSep = System.getProperty(""line.separator"");

		try
		{
			BufferedWriter out = new BufferedWriter(
				new FileWriter(file));

			out.write(""<?xml version=\""1.0\""?>"");
			out.write(lineSep);
			out.write(""<!DOCTYPE RECENT SYSTEM \""recent.dtd\"">"");
			out.write(lineSep);
			out.write(""<RECENT>"");
			out.write(lineSep);

			Enumeration enum = history.elements();
			while(enum.hasMoreElements())
			{
				out.write(""<ENTRY>"");
				out.write(lineSep);

				Entry entry = (Entry)enum.nextElement();

				out.write(""<PATH><![CDATA["");
				out.write(entry.path);
				out.write(""]]></PATH>"");
				out.write(lineSep);

				out.write(""<CARET>"");
				out.write(String.valueOf(entry.caret));
				out.write(""</CARET>"");
				out.write(lineSep);

				if(entry.selection != null
					&& entry.selection.length() > 0)
				{
					out.write(""<SELECTION>"");
					out.write(entry.selection);
					out.write(""</SELECTION>"");
					out.write(lineSep);
				}

				if(entry.encoding != null)
				{
					out.write(""<ENCODING>"");
					out.write(entry.encoding);
					out.write(""</ENCODING>"");
					out.write(lineSep);
				}

				out.write(""</ENTRY>"");
				out.write(lineSep);
			}

			out.write(""</RECENT>"");
			out.write(lineSep);

			out.close();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
	}

	
	private static Vector history;
	private static boolean pathsCaseInsensitive;
	private static int max;

	static
	{
		history = new Vector();
		pathsCaseInsensitive = (File.separatorChar == '\\'
			|| File.separatorChar == ':');
	}

	 static void addEntry(Entry entry)
	{
		history.addElement(entry);
		while(history.size() > max)
			history.removeElementAt(0);
	}

	 static void removeEntry(String path)
	{
		Enumeration enum = history.elements();
		for(int i = 0; i < history.size(); i++)
		{
			Entry entry = (Entry)history.elementAt(i);
			if(entry.path.equals(path))
			{
				history.removeElementAt(i);
				return;
			}
		}
	}

	private static String selectionToString(Selection[] s)
	{
		if(s == null)
			return null;

		StringBuffer buf = new StringBuffer();

		for(int i = 0; i < s.length; i++)
		{
			if(i != 0)
				buf.append(' ');

			Selection sel = s[i];
			if(sel instanceof Selection.Range)
				buf.append(""range "");
			else 
				buf.append(""rect "");
			buf.append(sel.getStart());
			buf.append(' ');
			buf.append(sel.getEnd());
		}

		return buf.toString();
	}

	private static Selection[] stringToSelection(String s)
	{
		if(s == null)
			return null;

		Vector selection = new Vector();
		StringTokenizer st = new StringTokenizer(s);

		while(st.hasMoreTokens())
		{
			String type = st.nextToken();
			int start = Integer.parseInt(st.nextToken());
			int end = Integer.parseInt(st.nextToken());
			if(end < start)
			{
				
				
				
				continue;
			}

			Selection sel;
			if(type.equals(""range""))
				sel = new Selection.Range(start,end);
			else 
				sel = new Selection.Rect(start,end);

			selection.addElement(sel);
		}

		Selection[] returnValue = new Selection[selection.size()];
		selection.copyInto(returnValue);
		return returnValue;
	}

	public static class Entry
	{
		public String path;
		public int caret;
		public String selection;
		public String encoding;

		public Selection[] getSelection()
		{
			return stringToSelection(selection);
		}

		public Entry(String path, int caret, String selection, String encoding)
		{
			this.path = path;
			this.caret = caret;
			this.selection = selection;
			this.encoding = encoding;
		}
	}

	static class RecentHandler extends HandlerBase
	{
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""recent.dtd"".equals(systemId))
			{
				
				
				
				return new StringReader(""<!-- -->"");

				
			}

			return null;
		}

		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""RECENT"".equals(name))
				return;

			Log.log(Log.ERROR,this,""recent.xml: DOCTYPE must be RECENT"");
		}

		public void endElement(String name)
		{
			if(name.equals(""ENTRY""))
			{
				addEntry(new Entry(path,caret,selection,encoding));
				path = null;
				caret = 0;
				selection = null;
				encoding = null;
			}
			else if(name.equals(""PATH""))
				path = charData;
			else if(name.equals(""CARET""))
				caret = Integer.parseInt(charData);
			else if(name.equals(""SELECTION""))
				selection = charData;
			else if(name.equals(""ENCODING""))
				encoding = charData;
		}

		public void charData(char[] ch, int start, int length)
		{
			charData = new String(ch,start,length);
		}

		

		
		private String path;
		private int caret;
		private String selection;
		private String encoding;
		private String charData;
	}
}
"
jEdit,4,org.gjt.sp.jedit.gui.EditAbbrevDialog,7,6,0,6,38,0,4,4,3,0.766666667,196,1.0,1,0.99086758,0.285714286,0,0,26.28571429,2,1.1429,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public class EditAbbrevDialog extends JDialog
{
	
	public EditAbbrevDialog(Component comp, String abbrev, String expansion)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""edit-abbrev.title""),true);

		this.comp = comp;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		editor = new AbbrevEditor();
		editor.setAbbrev(abbrev);
		editor.setExpansion(expansion);
		editor.setBorder(new EmptyBorder(0,0,12,0));
		content.add(BorderLayout.CENTER,editor);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		box.add(ok);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);

		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(comp);
		show();
	} 

	
	public String getAbbrev()
	{
		if(!isOK)
			return null;

		return editor.getAbbrev();
	} 

	
	public String getExpansion()
	{
		if(!isOK)
			return null;

		return editor.getExpansion();
	} 

	
	private Component comp;
	private AbbrevEditor editor;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;
	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(editor.getAbbrev() == null
					|| editor.getAbbrev().length() == 0)
				{
					getToolkit().beep();
					return;
				}

				isOK = true;
			}

			dispose();
		}
	} 

	
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.SelectLineRange,5,7,0,8,49,2,1,8,4,0.5,362,1.0,1,0.99391172,0.466666667,0,0,70.4,4,1.8,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;


public class SelectLineRange extends EnhancedDialog implements ActionListener
{
	
	public SelectLineRange(View view)
	{
		super(view,jEdit.getProperty(""selectlinerange.title""),true);
		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,0));
		setContentPane(content);

		JLabel label = new JLabel(jEdit.getProperty(
			""selectlinerange.caption""));
		label.setBorder(new EmptyBorder(0,0,6,12));
		content.add(BorderLayout.NORTH,label);

		JPanel panel = createFieldPanel();

		content.add(BorderLayout.CENTER,panel);

		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(6,0,0,12));
		panel.add(Box.createGlue());
		panel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		getRootPane().setDefaultButton(ok);
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		panel.add(cancel);
		panel.add(Box.createGlue());

		content.add(panel,BorderLayout.SOUTH);

		GUIUtilities.requestFocus(this,startField);

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		int startLine;
		int endLine;

		try
		{
			startLine = Integer.parseInt(startField.getText()) - 1;
			endLine = Integer.parseInt(endField.getText()) - 1;
		}
		catch(NumberFormatException nf)
		{
			getToolkit().beep();
			return;
		}

		Buffer buffer = view.getBuffer();

		if(startLine < 0 || endLine >= buffer.getLineCount()
			|| startLine > endLine)
		{
			getToolkit().beep();
			return;
		}

		JEditTextArea textArea = view.getTextArea();
		textArea.setSelection(new Selection.Range(
			buffer.getLineStartOffset(startLine),
			buffer.getLineEndOffset(endLine) - 1));
		textArea.moveCaretPosition(buffer.getLineEndOffset(endLine) - 1);

		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
	} 

	

	
	private View view;
	private JTextField startField;
	private JTextField endField;
	private JButton ok;
	private JButton cancel;
	

	
	private JPanel createFieldPanel()
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.insets = new Insets(0,0,6,12);
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		JLabel label = new JLabel(jEdit.getProperty(""selectlinerange.start""),
			SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);

		startField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(startField,cons);
		panel.add(startField);

		label = new JLabel(jEdit.getProperty(""selectlinerange.end""),
			SwingConstants.RIGHT);
		cons.gridx = 0;
		cons.weightx = 0.0f;
		cons.gridy = 1;
		layout.setConstraints(label,cons);
		panel.add(label);

		endField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(endField,cons);
		panel.add(endField);

		return panel;
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.io.FavoritesVFS,11,2,0,6,31,11,4,4,10,0.725,232,0.75,1,0.7,0.425,1,3,19.72727273,3,1.5455,0,"

package org.gjt.sp.jedit.io;


import java.awt.Component;
import java.util.ArrayList;
import org.gjt.sp.jedit.jEdit;



public class FavoritesVFS extends VFS
{
	public static final String PROTOCOL = ""favorites"";

	
	public FavoritesVFS()
	{
		super(""favorites"");

		
		instance = this;
	} 

	
	public int getCapabilities()
	{
		
		
		return  DELETE_CAP;
	} 

	
	public String getParentOfPath(String path)
	{
		return PROTOCOL + "":"";
	} 

	
	public VFS.DirectoryEntry[] _listDirectory(Object session, String url,
		Component comp)
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();

			VFS.DirectoryEntry[] retVal = new VFS.DirectoryEntry[favorites.size()];
			for(int i = 0; i < retVal.length; i++)
			{
				String favorite = (String)favorites.get(i);
				retVal[i] = _getDirectoryEntry(session,favorite,comp);
			}
			return retVal;
		}
	} 

	
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		return new VFS.DirectoryEntry(path,path,""favorites:"" + path,
					VFS.DirectoryEntry.DIRECTORY,
					0L,false);
	} 

	
	public boolean _delete(Object session, String path, Component comp)
	{
		synchronized(lock)
		{
			path = path.substring(PROTOCOL.length() + 1);
			favorites.remove(path);

			VFSManager.sendVFSUpdate(this,PROTOCOL + "":"",false);
		}

		return true;
	} 

	
	public static void loadFavorites()
	{
		favorites = new ArrayList();

		synchronized(lock)
		{
			String favorite;
			int i = 0;
			while((favorite = jEdit.getProperty(""vfs.favorite."" + i)) != null)
			{
				favorites.add(favorite);
				i++;
			}
		}
	} 

	
	public static void addToFavorites(String path)
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();

			if(!favorites.contains(path))
				favorites.add(path);

			VFSManager.sendVFSUpdate(instance,PROTOCOL + "":"",false);
		}
	} 

	
	public static void saveFavorites()
	{
		synchronized(lock)
		{
			if(favorites == null)
				return;

			for(int i = 0; i < favorites.size(); i++)
			{
				jEdit.setProperty(""vfs.favorite."" + i,
					(String)favorites.get(i));
			}
			jEdit.unsetProperty(""vfs.favorite."" + favorites.size());
		}
	} 

	
	public static Object[] getFavorites()
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();

			return favorites.toArray();
		}
	} 

	
	private static FavoritesVFS instance;
	private static Object lock = new Object();
	private static ArrayList favorites;
	
}
"
jEdit,4,org.gjt.sp.jedit.ModeCatalogHandler,6,2,0,5,25,3,1,5,4,0.771428571,215,1.0,0,0.722222222,0.722222222,1,3,33.66666667,7,3.0,0,"

package org.gjt.sp.jedit;

import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;

class ModeCatalogHandler extends HandlerBase
{
	ModeCatalogHandler(String directory, boolean resource)
	{
		this.directory = directory;
		this.resource = resource;
	}

	public Object resolveEntity(String publicId, String systemId)
	{
		if(""catalog.dtd"".equals(systemId))
		{
			
			
			
			return new StringReader(""<!-- -->"");

			
		}

		return null;
	}

	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();

		if(aname == ""NAME"")
			modeName = value;
		else if(aname == ""FILE"")
		{
			if(value == null)
			{
				Log.log(Log.ERROR,this,directory + ""catalog:""
					+ "" mode "" + modeName + "" doesn't have""
					+ "" a FILE attribute"");
			}
			else
				file = value;
		}
		else if(aname == ""FILE_NAME_GLOB"")
			filenameGlob = value;
		else if(aname == ""FIRST_LINE_GLOB"")
			firstlineGlob = value;
	}

	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		
		
		

		
		
		
		if(""CATALOG"".equals(name) || ""MODES"".equals(name))
			return;

		Log.log(Log.ERROR,this,directory + ""catalog: DOCTYPE must be CATALOG"");
	}

	public void endElement(String name)
	{
		if(name.equals(""MODE""))
		{
			Mode mode = jEdit.getMode(modeName);
			if(mode == null)
			{
				mode = new Mode(modeName);
				jEdit.addMode(mode);
			}

			Object path;
			if(resource)
				path = jEdit.class.getResource(directory + file);
			else
				path = MiscUtilities.constructPath(directory,file);
			mode.setProperty(""file"",path);

			if(filenameGlob != null)
				mode.setProperty(""filenameGlob"",filenameGlob);
			else
				mode.unsetProperty(""filenameGlob"");

			if(firstlineGlob != null)
				mode.setProperty(""firstlineGlob"",firstlineGlob);
			else
				mode.unsetProperty(""firstlineGlob"");

			mode.init();

			modeName = file = filenameGlob = firstlineGlob = null;
		}
	}

	

	
	private String directory;
	private boolean resource;

	private String modeName;
	private String file;
	private String filenameGlob;
	private String firstlineGlob;
}
"
jEdit,4,org.gjt.sp.jedit.textarea.TextAreaHighlight,2,1,0,2,2,1,2,0,2,2.0,2,0.0,0,0.0,0.625,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics;
import java.awt.event.MouseEvent;


public interface TextAreaHighlight
{
	
	void paintHighlight(Graphics gfx, int line, int y);

	
	String getToolTipText(MouseEvent evt);
}
"
jEdit,4,org.gjt.sp.jedit.gui.ToolBarManager,5,1,0,3,23,0,1,2,3,0.375,239,1.0,0,0.0,0.5,0,0,46.0,6,3.0,0,"

package org.gjt.sp.jedit.gui;

import java.awt.*;
import java.util.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;

public class ToolBarManager
{
	
	public ToolBarManager(Container top, Container bottom)
	{
		this.top = top;
		this.bottom = bottom;
	} 

	
	public void addToolBar(int group, int layer, Component toolbar)
	{
		Entry entry = new Entry(layer, toolbar);

		if (group == View.TOP_GROUP)
			addToolBar(top, topToolBars, entry);
		else if (group == View.BOTTOM_GROUP)
			addToolBar(bottom, bottomToolBars, entry);
		else
			throw new InternalError(""Invalid tool bar group"");
	} 

	
	public void removeToolBar(Component toolbar)
	{
		removeToolBar(top, topToolBars, toolbar);
		removeToolBar(bottom, bottomToolBars, toolbar);
	} 

	

	
	private Container top;
	private Container bottom;

	private ArrayList topToolBars = new ArrayList();
	private ArrayList bottomToolBars = new ArrayList();
	

	
	private void addToolBar(Container group, ArrayList toolbars,
		Entry entry)
	{
		
		for(int i = 0; i < toolbars.size(); i++)
		{
			if(entry.layer > ((Entry)toolbars.get(i)).layer)
			{
				toolbars.add(i,entry);
				group.add(entry.toolbar,i);
				return;
			}
		}

		
		toolbars.add(entry);

		Component comp = entry.toolbar;
		
		if(OperatingSystem.isMacOS() && group == bottom)
		{
			Box box = new Box(BoxLayout.X_AXIS);
			box.add(comp);
			box.add(Box.createHorizontalStrut(18));
			group.add(box);

			
			
			int nComps = group.getComponentCount();
			if(nComps > 1)
			{
				box = (Box)group.getComponent(nComps - 2);
				group.remove(nComps - 2);
				group.add(box.getComponent(0),nComps - 2);
			}
		}
		else
		{
			group.add(comp);
		}
	} 

	
	private void removeToolBar(Container group, ArrayList toolbars,
		Component toolbar)
	{
		for(int i = 0; i < toolbars.size(); i++)
		{
			if(toolbar == ((Entry)toolbars.get(i)).toolbar)
			{
				if(OperatingSystem.isMacOS() && group == bottom
					&& i == toolbars.size() - 1)
				{
					
					Box box = (Box)group.getComponent(i);
					group.remove(i);

					if (toolbars.size() > 1)
					{
						
						box.remove(0);

						
						toolbar = group.getComponent(i - 1);
						group.remove(i - 1);

						
						box.add(toolbar,0);

						
						group.add(box);
					}
				}
				else
				{
					group.remove(toolbar);
				}

				toolbars.remove(i);

				return;
			}
		}
	} 

	

	
	static class Entry
	{
		int layer;
		Component toolbar;

		Entry(int layer, Component toolbar)
		{
			this.layer = layer;
			this.toolbar = toolbar;
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.EBPlugin,2,2,0,4,3,1,1,3,1,2.0,6,0.0,0,0.9,0.75,0,0,2.0,1,0.5,0,"

package org.gjt.sp.jedit;

import java.util.Vector;
import org.gjt.sp.jedit.gui.OptionsDialog;


public abstract class EBPlugin extends EditPlugin implements EBComponent
{
	
	public void handleMessage(EBMessage message) {}

	
	protected EBPlugin() {}
}
"
jEdit,4,org.gjt.sp.jedit.MiscUtilities,37,1,0,69,102,660,64,10,33,0.944444444,1578,1.0,0,0.0,0.122850123,0,0,41.62162162,17,4.2162,5,"

package org.gjt.sp.jedit;


import gnu.regexp.RE;
import javax.swing.JMenuItem;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.util.Log;



public class MiscUtilities
{
	

	
	
	public static String canonPath(String path)
	{
		if(File.separatorChar == '\\')
		{
			
			path = path.replace('/','\\');
		}

		if(path.startsWith(""~"" + File.separator))
		{
			path = path.substring(2);
			String home = System.getProperty(""user.home"");

			if(home.endsWith(File.separator))
				return home + path;
			else
				return home + File.separator + path;
		}
		else if(path.equals(""~""))
			return System.getProperty(""user.home"");
		else
			return path;
	} 

	
	
	public static String constructPath(String parent, String path)
	{
		if(MiscUtilities.isURL(path))
			return path;
		else if(path.startsWith(""~""))
			return path;
		else
		{
			
			if(OperatingSystem.isDOSDerived())
			{
				if(path.length() == 2 && path.charAt(1) == ':')
					return path;
				else if(path.length() > 2 && path.charAt(1) == ':')
				{
					if(path.charAt(2) != '\\')
					{
						path = path.substring(0,2) + '\\'
							+ path.substring(2);
					}

					return resolveSymlinks(path);
				}
				else if(path.startsWith(""\\\\""))
					return resolveSymlinks(path);
			}
			else if(OperatingSystem.isUnix())
			{
				
				if(path.length() > 0 && path.charAt(0) == '/')
					return resolveSymlinks(path);
			}
		}

		if(parent == null)
			parent = System.getProperty(""user.dir"");

		if(OperatingSystem.isDOSDerived() && path.startsWith(""\\""))
			parent = parent.substring(0,2);
		
		VFS vfs = VFSManager.getVFSForPath(parent);
		return vfs.constructPath(parent,path);
	} 

	
	
	public static String constructPath(String parent,
		String path1, String path2)
	{
		return constructPath(constructPath(parent,path1),path2);
	} 

	
	
	public static String concatPath(String parent, String path)
	{
		parent = canonPath(parent);
		path = canonPath(path);

		
		if (path.startsWith(File.separator))
			path = path.substring(1);
		else if ((path.length() >= 3) && (path.charAt(1) == ':'))
			path = path.replace(':', File.separatorChar);

		if (parent == null)
			parent = System.getProperty(""user.dir"");

		if (parent.endsWith(File.separator))
			return parent + path;
		else
			return parent + File.separator + path;
	} 

	
	
	public static String getFileExtension(String name)
	{
		int index = name.indexOf('.');
		if(index == -1)
			return """";
		else
			return name.substring(index);
	} 

	
	
	public static String getFileName(String path)
	{
		return VFSManager.getVFSForPath(path).getFileName(path);
	} 

	
	
	public static String getFileNameNoExtension(String path)
	{
		String name = getFileName(path);
		int index = name.lastIndexOf('.');
		if(index == -1)
			return name;
		else
			return name.substring(0,index);
	} 

	
	
	public static String getFileParent(String path)
	{
		return getParentOfPath(path);
	} 

	
	
	public static String getParentOfPath(String path)
	{
		return VFSManager.getVFSForPath(path).getParentOfPath(path);
	} 

	
	
	public static String getFileProtocol(String url)
	{
		return getProtocolOfURL(url);
	} 

	
	
	public static String getProtocolOfURL(String url)
	{
		return url.substring(0,url.indexOf(':'));
	} 

	
	
	public static boolean isURL(String str)
	{
		int fsIndex = Math.max(str.indexOf(File.separatorChar),
			str.indexOf('/'));
		if(fsIndex == 0) 
			return false;
		else if(fsIndex == 2) 
			return false;

		int cIndex = str.indexOf(':');
		if(cIndex <= 1) 
			return false;
		else if(fsIndex != -1 && cIndex > fsIndex) 
			return false;

		return true;
	} 

	
	
	public static void saveBackup(File file, int backups,
		String backupPrefix, String backupSuffix,
		String backupDirectory)
	{
		if(backupPrefix == null)
			backupPrefix = """";
		if(backupSuffix == null)
			backupSuffix = """";

		String name = file.getName();

		
		if(backups == 1)
		{
			file.renameTo(new File(backupDirectory,
				backupPrefix + name + backupSuffix));
		}
		
		else
		{
			new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ backups + backupSuffix).delete();

			for(int i = backups - 1; i > 0; i--)
			{
				File backup = new File(backupDirectory,
					backupPrefix + name + backupSuffix
					+ i + backupSuffix);

				backup.renameTo(new File(backupDirectory,
					backupPrefix + name + backupSuffix
					+ (i+1) + backupSuffix));
			}

			file.renameTo(new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ ""1"" + backupSuffix));
		}
	} 

	

	

	
	
	public static int getLeadingWhiteSpace(String str)
	{
		int whitespace = 0;
loop:		for(;whitespace < str.length();)
		{
			switch(str.charAt(whitespace))
			{
			case ' ': case '\t':
				whitespace++;
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} 

	
	
	public static int getTrailingWhiteSpace(String str)
	{
		int whitespace = 0;
loop:		for(int i = str.length() - 1; i >= 0; i--)
		{
			switch(str.charAt(i))
			{
			case ' ': case '\t':
				whitespace++;
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} 

	
	
	public static int getLeadingWhiteSpaceWidth(String str, int tabSize)
	{
		int whitespace = 0;
loop:		for(int i = 0; i < str.length(); i++)
		{
			switch(str.charAt(i))
			{
			case ' ':
				whitespace++;
				break;
			case '\t':
				whitespace += (tabSize - whitespace % tabSize);
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} 

	
	
	public static String createWhiteSpace(int len, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		if(tabSize == 0)
		{
			while(len-- > 0)
				buf.append(' ');
		}
		else
		{
			int count = len / tabSize;
			while(count-- > 0)
				buf.append('\t');
			count = len % tabSize;
			while(count-- > 0)
				buf.append(' ');
		}
		return buf.toString();
	} 

	
	
	public static String globToRE(String glob)
	{
		StringBuffer buf = new StringBuffer();
		boolean backslash = false;
		boolean insideGroup = false;
		boolean insideNegativeLookahead = false;

		for(int i = 0; i < glob.length(); i++)
		{
			char c = glob.charAt(i);
			if(backslash)
			{
				buf.append('\\');
				buf.append(c);
				backslash = false;
				continue;
			}

			switch(c)
			{
			case '\\':
				backslash = true;
				break;
			case '?':
				buf.append('.');
				break;
			case '.':
				buf.append(""\\."");
				break;
			case '*':
				buf.append("".*"");
				break;
			case '{':
				buf.append('(');
				if(i + 1 != glob.length() && glob.charAt(i + 1) == '!')
				{
					buf.append('?');
					insideNegativeLookahead = true;
				}
				else
					insideGroup = true;
				break;
			case ',':
				if(insideGroup)
				{
					if(insideNegativeLookahead)
					{
						buf.append("").*"");
						insideNegativeLookahead = false;
					}
					buf.append('|');
				}
				else
					buf.append(',');
				break;
			case '}':
				if(insideNegativeLookahead)
				{
					buf.append("").*"");
					insideNegativeLookahead = false;
				}
				else if(insideGroup)
				{
					buf.append(')');
					insideGroup = false;
				}
				else
					buf.append('}');
				break;
			default:
				buf.append(c);
			}
		}

		return buf.toString();
	} 

	
	
	public static String escapesToChars(String str)
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			switch(c)
			{
			case '\\':
				if(i == str.length() - 1)
				{
					buf.append('\\');
					break;
				}
				c = str.charAt(++i);
				switch(c)
				{
				case 'n':
					buf.append('\n');
					break;
				case 't':
					buf.append('\t');
					break;
				default:
					buf.append(c);
					break;
				}
				break;
			default:
				buf.append(c);
			}
		}
		return buf.toString();
	} 

	
	
	public static String charsToEscapes(String str)
	{
		return charsToEscapes(str,false);
	} 

	
	
	public static String charsToEscapes(String str, boolean history)
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			switch(c)
			{
			case '\n':
				buf.append(""\\n"");
				break;
			case '\t':
				buf.append(""\\t"");
				break;
			case '[':
				if(history)
					buf.append(""\\["");
				else
					buf.append(c);
				break;
			case ']':
				if(history)
					buf.append(""\\]"");
				else
					buf.append(c);
				break;
			case '""':
				if(history)
					buf.append(c);
				else
					buf.append(""\\\"""");
				break;
			case '\'':
				if(history)
					buf.append(c);
				else
					buf.append(""\\\'"");
				break;
			case '\\':
				buf.append(""\\\\"");
				break;
			default:
				buf.append(c);
				break;
			}
		}
		return buf.toString();
	} 

	
	
	public static int compareVersions(String v1, String v2)
	{
		return compareStrings(v1,v2,false);
	} 

	
	
	public static int compareStrings(String str1, String str2, boolean ignoreCase)
	{
		char[] char1 = str1.toCharArray();
		char[] char2 = str2.toCharArray();

		int len = Math.min(char1.length,char2.length);

		for(int i = 0, j = 0; i < len && j < len; i++, j++)
		{
			char ch1 = char1[i];
			char ch2 = char2[j];
			if(Character.isDigit(ch1) && Character.isDigit(ch2)
				&& ch1 != '0' && ch2 != '0')
			{
				int _i = i + 1;
				int _j = j + 1;

				for(; _i < char1.length; _i++)
				{
					if(!Character.isDigit(char1[_i]))
					{
						
						break;
					}
				}

				for(; _j < char2.length; _j++)
				{
					if(!Character.isDigit(char2[_j]))
					{
						
						break;
					}
				}

				int len1 = _i - i;
				int len2 = _j - j;
				if(len1 > len2)
					return 1;
				else if(len1 < len2)
					return -1;
				else
				{
					for(int k = 0; k < len1; k++)
					{
						ch1 = char1[i + k];
						ch2 = char2[j + k];
						if(ch1 != ch2)
							return ch1 - ch2;
					}
				}

				i = _i - 1;
				j = _j - 1;
			}
			else
			{
				if(ignoreCase)
				{
					ch1 = Character.toLowerCase(ch1);
					ch2 = Character.toLowerCase(ch2);
				}

				if(ch1 != ch2)
					return ch1 - ch2;
			}
		}

		return char1.length - char2.length;
	} 

	

	

	
	
	public static void quicksort(Object[] obj, Comparator compare)
	{
		Arrays.sort(obj,compare);
	} 

	
	
	public static void quicksort(Vector vector, Comparator compare)
	{
		Collections.sort(vector,compare);
	} 

	
	
	public static void quicksort(List list, Comparator compare)
	{
		Collections.sort(list,compare);
	} 

	
	
	public static void quicksort(Object[] obj, Compare compare)
	{
		Arrays.sort(obj,compare);
	} 

	
	
	public static void quicksort(Vector vector, Compare compare)
	{
		Collections.sort(vector,compare);
	} 

	
	
	public interface Compare extends Comparator
	{
		int compare(Object obj1, Object obj2);
	} 

	
	
	public static class StringCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return compareStrings(obj1.toString(),
				obj2.toString(),false);
		}
	} 

	
	
	public static class StringICaseCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return compareStrings(obj1.toString(),
				obj2.toString(),true);
		}
	} 

	
	public static class MenuItemCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return compareStrings(((JMenuItem)obj1).getText(),
				((JMenuItem)obj2).getText(),true);
		}
	} 

	

	
	
	public static String fileToClass(String name)
	{
		char[] clsName = name.toCharArray();
		for(int i = clsName.length - 6; i >= 0; i--)
			if(clsName[i] == '/')
				clsName[i] = '.';
		return new String(clsName,0,clsName.length - 6);
	} 

	
	
	public static String classToFile(String name)
	{
		return name.replace('.','/').concat("".class"");
	} 

	
	
	public static String buildToVersion(String build)
	{
		if(build.length() != 11)
			return ""<unknown version: "" + build + "">"";
		
		int major = Integer.parseInt(build.substring(0,2));
		
		int minor = Integer.parseInt(build.substring(3,5));
		
		int beta = Integer.parseInt(build.substring(6,8));
		
		int bugfix = Integer.parseInt(build.substring(9,11));

		return """" + major + ""."" + minor
			+ (beta != 99 ? ""pre"" + beta :
			(bugfix != 0 ? ""."" + bugfix : ""final""));
	} 

	
	
	public static boolean isToolsJarAvailable()
	{
		Log.log(Log.DEBUG, MiscUtilities.class,""Searching for tools.jar..."");

		Vector paths = new Vector();

		
		paths.addElement(""System classpath: ""
			+ System.getProperty(""java.class.path""));

		try
		{
			
			
			try
			{
				Class.forName(""sun.tools.javac.Main"");
			}
			catch(ClassNotFoundException e1)
			{
				Class.forName(""com.sun.tools.javac.Main"");
			}
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- is in classpath. Fine."");
			return true;
		}
		catch(ClassNotFoundException e)
		{
			
			
		} 

		
		String settingsDir = jEdit.getSettingsDirectory();
		if(settingsDir != null)
		{
			String toolsPath = constructPath(settingsDir, ""jars"",
				""tools.jar"");
			paths.addElement(toolsPath);
			if(new File(toolsPath).exists())
			{
				Log.log(Log.DEBUG, MiscUtilities.class,
					""- is in the user's jars folder. Fine."");
				
				return true;
			}
		} 

		
		String jEditDir = jEdit.getJEditHome();
		if(jEditDir != null)
		{
			String toolsPath = constructPath(jEditDir, ""jars"", ""tools.jar"");
			paths.addElement(toolsPath);
			if(new File(toolsPath).exists())
			{
				Log.log(Log.DEBUG, MiscUtilities.class,
					""- is in jEdit's system jars folder. Fine."");
				
				return true;
			}
		} 

		
		String toolsPath = System.getProperty(""java.home"");
		if(toolsPath.toLowerCase().endsWith(File.separator + ""jre""))
			toolsPath = toolsPath.substring(0, toolsPath.length() - 4);
		toolsPath = constructPath(toolsPath, ""lib"", ""tools.jar"");
		paths.addElement(toolsPath);

		if(!(new File(toolsPath).exists()))
		{
			Log.log(Log.WARNING, MiscUtilities.class,
				""Could not find tools.jar.\n""
				+ ""I checked the following locations:\n""
				+ paths.toString());
			return false;
		} 

		
		EditPlugin.JAR jar = jEdit.getPluginJAR(toolsPath);
		if(jar == null)
		{
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- adding "" + toolsPath + "" to jEdit plugins."");
			try
			{
				jEdit.addPluginJAR(new EditPlugin.JAR(toolsPath,
					new JARClassLoader(toolsPath)));
			}
			catch(IOException ioex)
			{
				Log.log(Log.ERROR, MiscUtilities.class,
					""- I/O error loading "" + toolsPath);
				Log.log(Log.ERROR, MiscUtilities.class, ioex);
				return false;
			}
		}
		else
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- has been loaded before."");
		

		return true;
	} 

	
	
	public static String[] listDirectory(String directory, String glob,
		boolean recurse)
	{
		Log.log(Log.DEBUG,MiscUtilities.class,""Listing "" + directory);
		Vector files = new Vector(100);

		RE filter;
		try
		{
			filter = new RE(globToRE(glob));
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,MiscUtilities.class,e);
			return null;
		}

		listDirectory(new Vector(),files,new File(directory),filter,recurse);

		String[] retVal = new String[files.size()];
		files.copyInto(retVal);

		quicksort(retVal,new StringICaseCompare());

		return retVal;
	} 

	
	private MiscUtilities() {}

	
	private static void listDirectory(Vector stack, Vector files,
		File directory, RE filter, boolean recurse)
	{
		if(stack.contains(directory))
		{
			Log.log(Log.ERROR,MiscUtilities.class,
				""Recursion in listDirectory(): ""
				+ directory.getPath());
			return;
		}
		else
			stack.addElement(directory);

		File[] _files = directory.listFiles();
		if(_files == null)
			return;

		for(int i = 0; i < _files.length; i++)
		{
			File file = _files[i];
			if(file.isDirectory())
			{
				if(recurse)
				{
					
					try
					{
						file = new File(file.getCanonicalPath());
					}
					catch(IOException io)
					{
					}

					listDirectory(stack,files,file,filter,recurse);
				}
			}
			else
			{
				if(!filter.isMatch(file.getName()))
					continue;

				String path = file.getPath();
				Log.log(Log.DEBUG,MiscUtilities.class,path);

				files.addElement(path);
			}
		}
	} 

	
	private static String resolveSymlinks(String path)
	{
		try
		{
			return new File(path).getCanonicalPath();
		}
		catch(IOException io)
		{
			return path;
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.textarea.Gutter,43,4,0,15,111,759,6,14,37,0.956190476,981,0.88,3,0.938953488,0.121645796,3,17,21.23255814,31,1.8837,2,"

package org.gjt.sp.jedit.textarea;


import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class Gutter extends JComponent implements SwingConstants
{
	
	
	public static final int LOWEST_LAYER = Integer.MIN_VALUE;

	
	public static final int DEFAULT_LAYER = 0;

	
	public static final int HIGHEST_LAYER = Integer.MAX_VALUE;
	

	
	public Gutter(View view, JEditTextArea textArea)
	{
		this.view = view;
		this.textArea = textArea;

		setAutoscrolls(true);
		setOpaque(true);

		extensionMgr = new ExtensionManager();

		MouseHandler ml = new MouseHandler();
		addMouseListener(ml);
		addMouseMotionListener(ml);

		addExtension(new MarkerHighlight());
	} 

	
	public void paintComponent(Graphics _gfx)
	{
		Graphics2D gfx = (Graphics2D)_gfx;

		
		Rectangle clip = gfx.getClipBounds();
		gfx.setColor(getBackground());
		gfx.fillRect(clip.x, clip.y, clip.width, clip.height);

		
		if (!textArea.getBuffer().isLoaded())
			return;

		
		int lineHeight = textArea.getPainter().getFontMetrics()
			.getHeight();

		int firstLine = clip.y / lineHeight;
		int lastLine = (clip.y + clip.height - 1) / lineHeight;

		FontMetrics pfm = textArea.getPainter().getFontMetrics();
		Color fg = getForeground();

		int baseline = (int)((this.baseline + lineHeight
			- pfm.getDescent()) / 2.0);

		boolean highlightCurrentLine = currentLineHighlightEnabled
			&& textArea.selection.size() == 0;

		int y = (clip.y - clip.y % lineHeight);

		Buffer buffer = textArea.getBuffer();
		textArea.chunkCache.updateChunksUpTo(lastLine);

		for (int line = firstLine; line <= lastLine;
			line++, y += lineHeight)
		{
			ChunkCache.LineInfo info = textArea.chunkCache.getLineInfo(line);
			if(!info.chunksValid)
				System.err.println(""gutter paint: not valid"");
			int physicalLine = info.physicalLine;

			
			if(physicalLine != -1)
			{
				int start = textArea.getScreenLineStartOffset(line);
				int end = textArea.getScreenLineEndOffset(line);

				extensionMgr.paintValidLine(gfx,line,physicalLine,start,end,y);
			}
			else
				extensionMgr.paintInvalidLine(gfx,line,y);
			

			
			if(physicalLine == -1)
				return;

			
			if(info.firstSubregion
				&& physicalLine != buffer.getLineCount() - 1
				&& buffer.isFoldStart(physicalLine))
			{
				int _y = y + lineHeight / 2;
				gfx.setColor(foldColor);
				if(textArea.getFoldVisibilityManager()
					.isLineVisible(physicalLine + 1))
				{
					gfx.drawLine(1,_y - 3,10,_y - 3);
					gfx.drawLine(2,_y - 2,9,_y - 2);
					gfx.drawLine(3,_y - 1,8,_y - 1);
					gfx.drawLine(4,_y,7,_y);
					gfx.drawLine(5,_y + 1,6,_y + 1);
				}
				else
				{
					gfx.drawLine(4,_y - 5,4,_y + 4);
					gfx.drawLine(5,_y - 4,5,_y + 3);
					gfx.drawLine(6,_y - 3,6,_y + 2);
					gfx.drawLine(7,_y - 2,7,_y + 1);
					gfx.drawLine(8,_y - 1,8,_y);
				}
			} 
			
			else if(bracketHighlight)
			{
				int bracketLine = textArea.getBracketLine();
				int caretLine = textArea.getCaretLine();

				if(textArea.isBracketHighlightVisible()
					&& physicalLine >= Math.min(caretLine,bracketLine)
					&& physicalLine <= Math.max(caretLine,bracketLine))
				{
					int caretScreenLine;
					if(caretLine > textArea.getLastPhysicalLine())
						caretScreenLine = Integer.MAX_VALUE;
					else
					{
						caretScreenLine = textArea
							.getScreenLineOfOffset(
							textArea.getCaretPosition());
					}

					int bracketScreenLine;
					if(bracketLine > textArea.getLastPhysicalLine())
						bracketScreenLine = Integer.MAX_VALUE;
					else
					{
						bracketScreenLine = textArea.chunkCache
							.getScreenLineOfOffset(
							bracketLine,
							textArea.getBracketPosition());
					}

					if(caretScreenLine > bracketScreenLine)
					{
						int tmp = caretScreenLine;
						caretScreenLine = bracketScreenLine;
						bracketScreenLine = tmp;
					}

					gfx.setColor(bracketHighlightColor);
					if(bracketScreenLine == caretScreenLine)
					{
						
					}
					else if(line == caretScreenLine)
					{
						gfx.fillRect(5,
							y
							+ lineHeight / 2,
							5,
							2);
						gfx.fillRect(5,
							y
							+ lineHeight / 2,
							2,
							lineHeight - lineHeight / 2);
					}
					else if(line == bracketScreenLine)
					{
						gfx.fillRect(5,
							y,
							2,
							lineHeight / 2);
						gfx.fillRect(5,
							y + lineHeight / 2,
							5,
							2);
					}
					else if(line > caretScreenLine
						&& line < bracketScreenLine)
					{
						gfx.fillRect(5,
							y,
							2,
							lineHeight);
					}
				}
			} 

			
			if(info.firstSubregion && expanded)
			{
				String number = Integer.toString(physicalLine + 1);

				int offset;
				switch (alignment)
				{
				case RIGHT:
					offset = gutterSize.width - collapsedSize.width
						- (fm.stringWidth(number) + 1);
					break;
				case CENTER:
					offset = ((gutterSize.width - collapsedSize.width)
						- fm.stringWidth(number)) / 2;
					break;
				case LEFT: default:
					offset = 0;
					break;
				}

				if (physicalLine == textArea.getCaretLine() && highlightCurrentLine)
				{
					gfx.setColor(currentLineHighlight);
				}
				else if (interval > 1 && (line
					+ textArea.getFirstLine() + 1)
					% interval == 0)
					gfx.setColor(intervalHighlight);
				else
					gfx.setColor(fg);

				gfx.drawString(number, FOLD_MARKER_SIZE + offset,
					baseline + y);
			} 
		}
	} 

	
	
	public void addCustomHighlight(TextAreaHighlight highlight)
	{
		Log.log(Log.WARNING,this,""Old highlighter API not supported: ""
			+ highlight);
	} 

	
	
	public void removeCustomHighlight(TextAreaHighlight highlight)
	{
		Log.log(Log.WARNING,this,""Old highlighter API not supported: ""
			+ highlight);
	} 

	
	
	public void addExtension(TextAreaExtension extension)
	{
		extensionMgr.addExtension(DEFAULT_LAYER,extension);
		repaint();
	} 

	
	
	public void addExtension(int layer, TextAreaExtension extension)
	{
		extensionMgr.addExtension(layer,extension);
		repaint();
	} 

	
	
	public void removeExtension(TextAreaExtension extension)
	{
		extensionMgr.removeExtension(extension);
		repaint();
	} 

	
	
	public String getToolTipText(MouseEvent evt)
	{
		if(!textArea.getBuffer().isLoaded())
			return null;

		return extensionMgr.getToolTipText(evt.getX(),evt.getY());
	} 

	
	
	public void setBorder(int width, Color color1, Color color2, Color color3)
	{
		this.borderWidth = width;

		focusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color1));
		noFocusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color2));
		updateBorder();
	} 

	
	
	public void updateBorder()
	{
		
		
		
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(view.getEditPane() == null)
					return;

				if(view.getEditPane().getTextArea() == textArea)
					setBorder(focusBorder);
				else
					setBorder(noFocusBorder);
			}
		});
	} 

	
	
	public void setBorder(Border border)
	{
		super.setBorder(border);

		if (border == null)
		{
			collapsedSize.width = 0;
			collapsedSize.height = 0;
		}
		else
		{
			Insets insets = border.getBorderInsets(this);
			collapsedSize.width = FOLD_MARKER_SIZE + insets.right;
			collapsedSize.height = gutterSize.height
				= insets.top + insets.bottom;
			gutterSize.width = FOLD_MARKER_SIZE + insets.right
				+ fm.stringWidth(""12345"");
		}

		revalidate();
	} 

	
	
	public void setFont(Font font)
	{
		super.setFont(font);

		fm = getFontMetrics(font);

		baseline = fm.getAscent();

		Border border = getBorder();
		if(border != null)
		{
			gutterSize.width = FOLD_MARKER_SIZE
				+ border.getBorderInsets(this).right
				+ fm.stringWidth(""12345"");
			revalidate();
		}
	} 

	

	
	
	public Color getHighlightedForeground()
	{
		return intervalHighlight;
	} 

	
	public void setHighlightedForeground(Color highlight)
	{
		intervalHighlight = highlight;
	} 

	
	public Color getCurrentLineForeground()
 	{
		return currentLineHighlight;
	} 

	
	public void setCurrentLineForeground(Color highlight)
	{
		currentLineHighlight = highlight;
 	} 

	
	public Color getFoldColor()
 	{
		return foldColor;
	} 

	
	public void setFoldColor(Color foldColor)
	{
		this.foldColor = foldColor;
 	} 

	
	
	public Dimension getPreferredSize()
	{
		if (expanded)
			return gutterSize;
		else
			return collapsedSize;
	} 

	
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	} 

	
	
	public int getLineNumberAlignment()
	{
		return alignment;
	} 

	
	
	public void setLineNumberAlignment(int alignment)
	{
		if (this.alignment == alignment) return;

		this.alignment = alignment;

		repaint();
	} 

	
	
	public boolean isExpanded()
	{
		return expanded;
	} 

	
	
	public void setExpanded(boolean expanded)
	{
		if (this.expanded == expanded) return;

		this.expanded = expanded;

		textArea.revalidate();
	} 

	
	
	public void toggleExpanded()
	{
		setExpanded(!expanded);
	} 

	
	
	public int getHighlightInterval()
	{
		return interval;
	} 

	
	
	public void setHighlightInterval(int interval)
	{
		if (interval <= 1) interval = 0;
		this.interval = interval;
		repaint();
	} 

	
	public boolean isCurrentLineHighlightEnabled()
	{
		return currentLineHighlightEnabled;
	} 

	
	public void setCurrentLineHighlightEnabled(boolean enabled)
	{
		if (currentLineHighlightEnabled == enabled) return;

		currentLineHighlightEnabled = enabled;

		repaint();
	} 

	
	
	public final Color getBracketHighlightColor()
	{
		return bracketHighlightColor;
	} 

	
	
	public final void setBracketHighlightColor(Color bracketHighlightColor)
	{
		this.bracketHighlightColor = bracketHighlightColor;
		repaint();
	} 

	
	
	public final boolean isBracketHighlightEnabled()
	{
		return bracketHighlight;
	} 

	
	
	public final void setBracketHighlightEnabled(boolean bracketHighlight)
	{
		this.bracketHighlight = bracketHighlight;
		repaint();
	} 

	
	public Color getMarkerHighlightColor()
	{
		return markerHighlightColor;
	} 

	
	public void setMarkerHighlightColor(Color markerHighlightColor)
	{
		this.markerHighlightColor = markerHighlightColor;
	} 

	
	public boolean isMarkerHighlightEnabled()
	{
		return markerHighlight;
	} 

	
	public void setMarkerHighlightEnabled(boolean markerHighlight)
	{
		this.markerHighlight = markerHighlight;
	} 

	

	
	private static final int FOLD_MARKER_SIZE = 12;

	private View view;
	private JEditTextArea textArea;

	private ExtensionManager extensionMgr;

	private int baseline;

	private Dimension gutterSize = new Dimension(0,0);
	private Dimension collapsedSize = new Dimension(0,0);

	private Color intervalHighlight;
	private Color currentLineHighlight;
	private Color foldColor;

	private FontMetrics fm;

	private int alignment;

	private int interval;
	private boolean currentLineHighlightEnabled;
	private boolean expanded;

	private boolean bracketHighlight;
	private Color bracketHighlightColor;

	private boolean markerHighlight;
	private Color markerHighlightColor;

	private int borderWidth;
	private Border focusBorder, noFocusBorder;
	

	
	class MouseHandler extends MouseInputAdapter
	{
		boolean drag;
		int toolTipInitialDelay, toolTipReshowDelay;

		
		public void mouseEntered(MouseEvent e)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			toolTipInitialDelay = ttm.getInitialDelay();
			toolTipReshowDelay = ttm.getReshowDelay();
			ttm.setInitialDelay(0);
			ttm.setReshowDelay(0);
		} 

		
		public void mouseExited(MouseEvent evt)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			ttm.setInitialDelay(toolTipInitialDelay);
			ttm.setReshowDelay(toolTipReshowDelay);
		} 

		
		public void mousePressed(MouseEvent e)
		{
			if(GUIUtilities.isPopupTrigger(e)
				|| e.getX() >= getWidth() - borderWidth * 2)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mousePressed(e);
				drag = true;
			}
			else
			{
				Buffer buffer = textArea.getBuffer();

				int screenLine = e.getY() / textArea.getPainter()
					.getFontMetrics().getHeight();
				textArea.chunkCache.updateChunksUpTo(screenLine);

				int line = textArea.chunkCache.getLineInfo(screenLine)
					.physicalLine;

				if(line == -1)
					return;

				FoldVisibilityManager foldVisibilityManager
					= textArea.getFoldVisibilityManager();

				
				if(buffer.isFoldStart(line))
				{
					if(e.isControlDown())
					{
						foldVisibilityManager
							.expandFold(line,true);
						textArea.selectFold(line);
					}
					else if(foldVisibilityManager
						.isLineVisible(line + 1))
					{
						foldVisibilityManager
							.collapseFold(line);
					}
					else
					{
						foldVisibilityManager
							.expandFold(line,
							e.isShiftDown());
					}
				} 
				
				else if(bracketHighlight)
				{
					if(textArea.isBracketHighlightVisible())
					{
						int bracketLine = textArea.getBracketLine();
						int caretLine = textArea.getCaretLine();
						if(caretLine != bracketLine)
						{
							if(caretLine > bracketLine)
							{
								int tmp = caretLine;
								caretLine = bracketLine;
								bracketLine = tmp;
							}

							if(line >= caretLine
								&& line <= bracketLine)
							{
								if(e.isControlDown())
									textArea.selectToMatchingBracket();
								else
									textArea.goToMatchingBracket();
							}
						}
					}
				} 
			}
		} 

		
		public void mouseDragged(MouseEvent e)
		{
			if(drag )
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseDragged(e);
			}
		} 

		
		public void mouseReleased(MouseEvent e)
		{
			if(drag && e.getX() >= getWidth() - borderWidth * 2)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseReleased(e);
			}

			drag = false;
		} 
	} 

	
	class MarkerHighlight extends TextAreaExtension
	{
		
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(isMarkerHighlightEnabled())
			{
				Buffer buffer = textArea.getBuffer();
				if(buffer.getMarkerInRange(start,end) != null)
				{
					gfx.setColor(getMarkerHighlightColor());
					FontMetrics fm = textArea.getPainter().getFontMetrics();
					gfx.fillRect(0,y,textArea.getGutter()
						.getWidth(),fm.getHeight());
				}
			}
		} 

		
		public String getToolTipText(int x, int y)
		{
			if(isMarkerHighlightEnabled())
			{
				int start = textArea.xyToOffset(0,y);
				if(start == -1)
					return null;

				int end = textArea.getScreenLineEndOffset(
					textArea.getScreenLineOfOffset(start));

				Marker marker = textArea.getBuffer().getMarkerInRange(start,end);
				if(marker != null)
				{
					char shortcut = marker.getShortcut();
					if(shortcut == '\0')
						return jEdit.getProperty(""view.gutter.marker.no-name"");
					else
					{
						String[] args = { String.valueOf(shortcut) };
						return jEdit.getProperty(""view.gutter.marker"",args);
					}
				}
			}

			return null;
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.HelpViewer,18,6,0,22,131,113,8,22,6,0.764705882,844,1.0,0,0.977272727,0.194444444,3,6,45.33333333,8,1.6111,0,"

package org.gjt.sp.jedit.gui;


import com.microstar.xml.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.text.html.*;
import javax.swing.text.Document;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.FileCellRenderer; 
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class HelpViewer extends JFrame implements EBComponent
{
	
	
	public HelpViewer()
	{
		this(""welcome.html"");
	} 

	
	
	public HelpViewer(URL url)
	{
		this(url.toString());
	} 

	
	
	public HelpViewer(String url)
	{
		super(jEdit.getProperty(""helpviewer.title""));

		setIconImage(GUIUtilities.getEditorIcon());

		try
		{
			baseURL = new File(MiscUtilities.constructPath(
				jEdit.getJEditHome(),""doc"")).toURL().toString();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			
		}

		history = new String[25];
		nodes = new Hashtable();

		ActionHandler actionListener = new ActionHandler();

		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.putClientProperty(""JToolBar.isRollover"",Boolean.TRUE);

		JLabel label = new JLabel(jEdit.getProperty(""helpviewer.url""));
		label.setBorder(new EmptyBorder(0,12,0,12));
		toolBar.add(label);
		Box box = new Box(BoxLayout.Y_AXIS);
		box.add(Box.createGlue());
		urlField = new JTextField();
		urlField.addKeyListener(new KeyHandler());
		Dimension dim = urlField.getPreferredSize();
		dim.width = Integer.MAX_VALUE;
		urlField.setMaximumSize(dim);
		box.add(urlField);
		box.add(Box.createGlue());
		toolBar.add(box);

		toolBar.add(Box.createHorizontalStrut(6));

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(0,12,0,0));
		back = new JButton(GUIUtilities.loadIcon(""Back24.gif""));
		back.setToolTipText(jEdit.getProperty(""helpviewer.back""));
		back.addActionListener(actionListener);
		back.setRequestFocusEnabled(false);
		toolBar.add(back);
		forward = new JButton(GUIUtilities.loadIcon(""Forward24.gif""));
		forward.addActionListener(actionListener);
		forward.setToolTipText(jEdit.getProperty(""helpviewer.forward""));
		forward.setRequestFocusEnabled(false);
		toolBar.add(forward);
		back.setPreferredSize(forward.getPreferredSize());

		getContentPane().add(BorderLayout.NORTH,toolBar);

		createTOC();

		toc = new TOCTree(tocModel);
		toc.putClientProperty(""JTree.lineStyle"", ""Angled"");
		toc.setCellRenderer(new TOCCellRenderer());
		toc.setEditable(false);
		toc.setRootVisible(false);
		toc.setShowsRootHandles(true);

		DefaultMutableTreeNode node = (DefaultMutableTreeNode)
			nodes.get(""users-guide/using-jedit-part.html"");
		if(node != null)
			toc.expandPath(new TreePath(node.getPath()));

		viewer = new JEditorPane();
		viewer.setEditable(false);
		viewer.addHyperlinkListener(new LinkHandler());
		viewer.setFont(new Font(""Monospaced"",Font.PLAIN,12));

		final JSplitPane splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
			new JScrollPane(toc),new JScrollPane(viewer));
		splitter.setBorder(null);

		getContentPane().add(BorderLayout.CENTER,splitter);

		gotoURL(url,true);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		getRootPane().setPreferredSize(new Dimension(800,500));

		pack();
		GUIUtilities.loadGeometry(this,""helpviewer"");

		EditBus.addToBus(this);

		show();

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				splitter.setDividerLocation(250);
			}
		});
	} 

	
	
	public void gotoURL(String url, boolean addToHistory)
	{
		String shortURL;
		if(MiscUtilities.isURL(url))
		{
			if(url.startsWith(baseURL))
			{
				shortURL = url.substring(baseURL.length());
				if(shortURL.startsWith(""/""))
					shortURL = shortURL.substring(1);
			}
			else
			{
				shortURL = null;
			}
		}
		else
		{
			shortURL = url;
			if(baseURL.endsWith(""/""))
				url = baseURL + url;
			else
				url = baseURL + '/' + url;
		}

		
		
		viewer.setCursor(Cursor.getDefaultCursor());

		int index = url.indexOf('#');

		URL _url = null;
		try
		{
			_url = new URL(url);

			urlField.setText(_url.toString());
			viewer.setPage(_url);
			if(addToHistory)
			{
				history[historyPos] = url;
				if(historyPos + 1 == history.length)
				{
					System.arraycopy(history,1,history,
						0,history.length - 1);
					history[historyPos] = null;
				}
				else
					historyPos++;
			}
		}
		catch(MalformedURLException mf)
		{
			Log.log(Log.ERROR,this,mf);
			String[] args = { url, mf.getMessage() };
			GUIUtilities.error(this,""badurl"",args);
			return;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			String[] args = { url, io.toString() };
			GUIUtilities.error(this,""read-error"",args);
			return;
		}

		
		if(shortURL != null)
		{
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)nodes.get(shortURL);

			if(node == null)
				return;

			TreePath path = new TreePath(tocModel.getPathToRoot(node));
			toc.expandPath(path);
			toc.setSelectionPath(path);
			toc.scrollPathToVisible(path);
		}
	} 

	
	public void dispose()
	{
		EditBus.removeFromBus(this);
		GUIUtilities.saveGeometry(this,""helpviewer"");
		super.dispose();
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			SwingUtilities.updateComponentTreeUI(getRootPane());
	} 

	

	
	private String baseURL;
	private JButton back;
	private JButton forward;
	private DefaultTreeModel tocModel;
	private JTree toc;
	
	private Hashtable nodes;
	private JEditorPane viewer;
	private JTextField urlField;
	private String[] history;
	private int historyPos;
	

	
	private void createTOC()
	{
		DefaultMutableTreeNode root = new DefaultMutableTreeNode();

		root.add(createNode(""welcome.html"",
			jEdit.getProperty(""helpviewer.toc.welcome"")));

		root.add(createNode(""README.txt"",
			jEdit.getProperty(""helpviewer.toc.readme"")));
		root.add(createNode(""NEWS.txt"",
			jEdit.getProperty(""helpviewer.toc.news"")));
		root.add(createNode(""TODO.txt"",
			jEdit.getProperty(""helpviewer.toc.todo"")));
		root.add(createNode(""CHANGES.txt"",
			jEdit.getProperty(""helpviewer.toc.changes"")));
		root.add(createNode(""COPYING.txt"",
			jEdit.getProperty(""helpviewer.toc.copying"")));
		root.add(createNode(""COPYING.DOC.txt"",
			jEdit.getProperty(""helpviewer.toc.copying-doc"")));

		loadTOC(root,""users-guide/toc.xml"");
		loadTOC(root,""FAQ/toc.xml"");

		DefaultMutableTreeNode pluginDocs = new DefaultMutableTreeNode(
			jEdit.getProperty(""helpviewer.toc.plugins""),true);

		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin plugin = plugins[i];
			EditPlugin.JAR jar = plugin.getJAR();
			if(jar == null)
				continue;

			String name = plugin.getClassName();

			String docs = jEdit.getProperty(""plugin."" + name + "".docs"");
			String label = jEdit.getProperty(""plugin."" + name + "".name"");
			if(docs != null)
			{
				if(label != null && docs != null)
				{
					URL url = jar.getClassLoader()
						.getResource(docs);
					if(url != null)
					{
						pluginDocs.add(createNode(
							url.toString(),label));
					}
				}
			}
		}

		if(pluginDocs.getChildCount() != 0)
			root.add(pluginDocs);

		tocModel = new DefaultTreeModel(root);
	} 

	
	private void loadTOC(DefaultMutableTreeNode root, String path)
	{
		TOCHandler h = new TOCHandler(root,MiscUtilities.getParentOfPath(path));
		XmlParser parser = new XmlParser();
		parser.setHandler(h);

		try
		{
			parser.parse(null, null, new InputStreamReader(
				new URL(baseURL + '/' + path).openStream()));
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,this,path + ':' + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.NOTICE,this,e);
		}
	} 

	
	private DefaultMutableTreeNode createNode(String href, String title)
	{
		DefaultMutableTreeNode node = new DefaultMutableTreeNode(
			new HelpNode(href,title),true);
		nodes.put(href,node);
		return node;
	} 

	

	

	
	static class HelpNode
	{
		String href, title;

		
		HelpNode(String href, String title)
		{
			this.href = href;
			this.title = title;
		} 

		
		public String toString()
		{
			return title;
		} 
	} 

	
	class TOCHandler extends HandlerBase
	{
		String dir;

		
		TOCHandler(DefaultMutableTreeNode root, String dir)
		{
			nodes = new Stack();
			node = root;
			this.dir = dir;
		} 

		
		public void attribute(String aname, String value, boolean isSpecified)
		{
			if(aname.equals(""HREF""))
				href = value;
		} 

		
		public void charData(char[] c, int off, int len)
		{
			if(tag.equals(""TITLE""))
			{
				StringBuffer buf = new StringBuffer();
				for(int i = 0; i < len; i++)
				{
					char ch = c[off + i];
					if(ch == ' ' || !Character.isWhitespace(ch))
						buf.append(ch);
				}
				title = buf.toString();
			}
		} 

		
		public void startElement(String name)
		{
			tag = name;
		} 

		
		public void endElement(String name)
		{
			if(name == null)
				return;

			if(name.equals(""TITLE""))
			{
				DefaultMutableTreeNode newNode = createNode(
					dir + href,title);
				node.add(newNode);
				nodes.push(node);
				node = newNode;
			}
			else if(name.equals(""ENTRY""))
				node = (DefaultMutableTreeNode)nodes.pop();
		} 

		
		private String tag;
		private String title;
		private String href;
		private DefaultMutableTreeNode node;
		private Stack nodes;
		
	} 

	
	class TOCTree extends JTree
	{
		
		TOCTree(TreeModel model)
		{
			super(model);
			ToolTipManager.sharedInstance().registerComponent(this);
		} 

		
		public final String getToolTipText(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
					return path.getLastPathComponent().toString();
			}
			return null;
		} 

		
		public final Point getToolTipLocation(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
				{
					return new Point(cellRect.x + 14, cellRect.y);
				}
			}
			return null;
		} 

		
		protected void processMouseEvent(MouseEvent evt)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();

			switch(evt.getID())
			{
			case MouseEvent.MOUSE_ENTERED:
				toolTipInitialDelay = ttm.getInitialDelay();
				toolTipReshowDelay = ttm.getReshowDelay();
				ttm.setInitialDelay(200);
				ttm.setReshowDelay(0);
				super.processMouseEvent(evt);
				break;
			case MouseEvent.MOUSE_EXITED:
				ttm.setInitialDelay(toolTipInitialDelay);
				ttm.setReshowDelay(toolTipReshowDelay);
				super.processMouseEvent(evt);
				break;
			case MouseEvent.MOUSE_CLICKED:
				TreePath path = getPathForLocation(evt.getX(),evt.getY());
				if(path != null)
				{
					if(!isPathSelected(path))
						setSelectionPath(path);

					Object obj = ((DefaultMutableTreeNode)
						path.getLastPathComponent())
						.getUserObject();
					if(!(obj instanceof HelpNode))
					{
						toc.expandPath(path);
						return;
					}

					HelpNode node = (HelpNode)obj;

					gotoURL(node.href,true);
				}

				super.processMouseEvent(evt);
				break;
			default:
				super.processMouseEvent(evt);
				break;
			}
		} 

		
		private int toolTipInitialDelay = -1;
		private int toolTipReshowDelay = -1;

		
		private boolean cellRectIsVisible(Rectangle cellRect)
		{
			Rectangle vr = TOCTree.this.getVisibleRect();
			return vr.contains(cellRect.x,cellRect.y) &&
				vr.contains(cellRect.x + cellRect.width,
				cellRect.y + cellRect.height);
		} 

		
	} 

	
	class TOCCellRenderer extends DefaultTreeCellRenderer
	{
		EmptyBorder border = new EmptyBorder(1,0,1,1);

		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean focus)
		{
			super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,focus);
			setIcon(leaf ? FileCellRenderer.fileIcon
				: (expanded ? FileCellRenderer.openDirIcon
				: FileCellRenderer.dirIcon));
			setBorder(border);

			return this;
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == back)
			{
				if(historyPos <= 1)
					getToolkit().beep();
				else
				{
					String url = history[--historyPos - 1];
					gotoURL(url,false);
				}
			}
			else if(source == forward)
			{
				if(history.length - historyPos <= 1)
					getToolkit().beep();
				else
				{
					String url = history[historyPos];
					if(url == null)
						getToolkit().beep();
					else
					{
						historyPos++;
						gotoURL(url,false);
					}
				}
			}
		} 
	} 

	
	class LinkHandler implements HyperlinkListener
	{
		
		public void hyperlinkUpdate(HyperlinkEvent evt)
		{
			if(evt.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
			{
				if(evt instanceof HTMLFrameHyperlinkEvent)
				{
					((HTMLDocument)viewer.getDocument())
						.processHTMLFrameHyperlinkEvent(
						(HTMLFrameHyperlinkEvent)evt);
				}
				else
				{
					URL url = evt.getURL();
					if(url != null)
						gotoURL(url.toString(),true);
				}
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.ENTERED) {
				viewer.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.EXITED) {
				viewer.setCursor(Cursor.getDefaultCursor());
			}
		} 
	} 

	
	class KeyHandler extends KeyAdapter
	{
		
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				gotoURL(urlField.getText(),true);
			}
		} 
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.msg.CreateDockableWindow,7,2,0,5,15,9,1,4,7,0.722222222,64,1.0,1,0.454545455,0.357142857,1,1,7.714285714,1,0.8571,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.gui.DockableWindow;
import org.gjt.sp.jedit.*;


public class CreateDockableWindow extends EBMessage
{
	
	public CreateDockableWindow(View view, String name, String position)
	{
		super(view);

		if(name == null)
			throw new NullPointerException(""Name must be non-null"");

		this.name = name;
		this.position = position;
	}

	
	public View getView()
	{
		return (View)getSource();
	}

	
	public String getDockableWindowName()
	{
		return name;
	}

	
	public void setDockableWindow(DockableWindow win)
	{
		this.win = win;
		veto();
	}

	
	public DockableWindow getDockableWindow()
	{
		return win;
	}

	
	public String getPosition()
	{
		return position;
	}

	public String paramString()
	{
		return super.paramString() + "",name="" + name + "",position=""
			+ position;
	}

	
	private String name;
	private String position;
	private DockableWindow win;
}
"
jEdit,4,org.gjt.sp.jedit.gui.GrabKeyDialog,25,6,0,9,75,258,4,8,8,0.818181818,530,1.0,3,0.96731055,0.152727273,1,1,19.76,8,1.64,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.lang.reflect.Field;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class GrabKeyDialog extends JDialog
{
	
	public static void keyboardTest(View view)
	{
		Buffer buffer = jEdit.newFile(view);
		new GrabKeyDialog(view,null,null,buffer);
	} 

	
	
	public GrabKeyDialog(Component comp, KeyBinding binding,
		Vector allBindings)
	{
		this(comp,binding,allBindings,null);
	} 

	
	
	public GrabKeyDialog(Component comp, Buffer debugBuffer)
	{
		this(comp,null,null,debugBuffer);
	} 

	
	
	public GrabKeyDialog(Component comp, KeyBinding binding,
		Vector allBindings, Buffer debugBuffer)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""grab-key.title""),true);
		this.binding = binding;
		this.allBindings = allBindings;
		this.debugBuffer = debugBuffer;

		enableEvents(AWTEvent.KEY_EVENT_MASK);

		
		
		JPanel content = new JPanel(new GridLayout(0,1,0,6))
		{
			
			public boolean isManagingFocus()
			{
				return false;
			}

			
			public boolean getFocusTraversalKeysEnabled()
			{
				return false;
			}
		};
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel label = new JLabel(
			debugBuffer == null ? jEdit.getProperty(
			""grab-key.caption"",new String[] { binding.label })
			: jEdit.getProperty(""grab-key.keyboard-test""));

		Box input = Box.createHorizontalBox();

		shortcut = new InputPane();
		input.add(shortcut);
		input.add(Box.createHorizontalStrut(12));

		clear = new JButton(jEdit.getProperty(""grab-key.clear""));
		clear.addActionListener(new ActionHandler());
		input.add(clear);

		assignedTo = new JLabel();
		if(debugBuffer == null)
			updateAssignedTo(null);

		Box buttons = Box.createHorizontalBox();
		buttons.add(Box.createGlue());

		if(debugBuffer == null)
		{
			ok = new JButton(jEdit.getProperty(""common.ok""));
			ok.addActionListener(new ActionHandler());
			buttons.add(ok);
			buttons.add(Box.createHorizontalStrut(12));

			if(binding.isAssigned()) {
				
				remove = new JButton(jEdit.getProperty(""grab-key.remove""));
				remove.addActionListener(new ActionHandler());
				buttons.add(remove);
				buttons.add(Box.createHorizontalStrut(12));
			}
		}

		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);
		buttons.add(Box.createGlue());

		content.add(label);
		content.add(input);
		if(debugBuffer == null)
			content.add(assignedTo);
		content.add(buttons);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		pack();
		setLocationRelativeTo(comp);
		setResizable(false);
		show();
	} 

	
	
	public String getShortcut()
	{
		if(isOK)
			return shortcut.getText();
		else
			return null;
	} 

	
	
	public boolean isOK()
	{
		return isOK;
	} 

	
	
	public boolean isManagingFocus()
	{
		return false;
	} 

	
	
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} 

	
	protected void processKeyEvent(KeyEvent evt)
	{
		shortcut.processKeyEvent(evt);
	} 

	

	
	private InputPane shortcut; 
	private JLabel assignedTo;
	private JButton ok;
	private JButton remove;
	private JButton cancel;
	private JButton clear;
	private boolean isOK;
	private KeyBinding binding;
	private Vector allBindings;
	private Buffer debugBuffer;
	

	
	private String getSymbolicName(int keyCode)
	{
		if(keyCode == KeyEvent.VK_UNDEFINED)
			return null;
		

		if(keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)
			return String.valueOf(Character.toLowerCase((char)keyCode));

		try
		{
			Field[] fields = KeyEvent.class.getFields();
			for(int i = 0; i < fields.length; i++)
			{
				Field field = fields[i];
				String name = field.getName();
				if(name.startsWith(""VK_"")
					&& field.getInt(null) == keyCode)
				{
					return name.substring(3);
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}

		return null;
	} 

	
	private void updateAssignedTo(String shortcut)
	{
		String text = jEdit.getProperty(""grab-key.assigned-to.none"");
		KeyBinding kb = getKeyBinding(shortcut);

		if(kb != null)
			if(kb.isPrefix)
				text = jEdit.getProperty(
					""grab-key.assigned-to.prefix"",
					new String[] { shortcut });
			else
				text = kb.label;

		if(ok != null)
			ok.setEnabled(kb == null || !kb.isPrefix);

		assignedTo.setText(
			jEdit.getProperty(""grab-key.assigned-to"",
				new String[] { text }));
	} 

	
	private KeyBinding getKeyBinding(String shortcut)
	{
		if(shortcut == null || shortcut.length() == 0)
			return null;

		String spacedShortcut = shortcut + "" "";
		Enumeration enum = allBindings.elements();

		while(enum.hasMoreElements())
		{
			KeyBinding kb = (KeyBinding)enum.nextElement();

			if(!kb.isAssigned())
				continue;

			String spacedKbShortcut = kb.shortcut + "" "";

			
			if(spacedShortcut.startsWith(spacedKbShortcut))
				return kb;

			
			if(spacedKbShortcut.startsWith(spacedShortcut))
			{
				
				
				return new KeyBinding(kb.name,kb.label,
					shortcut,true);
			}
		}

		return null;
	} 

	

	
	
	public static class KeyBinding
	{
		public KeyBinding(String name, String label,
			String shortcut, boolean isPrefix)
		{
			this.name = name;
			this.label = label;
			this.shortcut = shortcut;
			this.isPrefix = isPrefix;
		}

		public String name;
		public String label;
		public String shortcut;
		public boolean isPrefix;

		public boolean isAssigned()
		{
			return shortcut != null && shortcut.length() > 0;
		}
	} 

	
	class InputPane extends JTextField
	{
		
		
		public boolean getFocusTraversalKeysEnabled()
		{
			return false;
		} 

		
		protected void processKeyEvent(KeyEvent _evt)
		{
			KeyEvent evt = KeyEventWorkaround.processKeyEvent(_evt);
			if(evt == null)
			{
				if(debugBuffer != null)
				{
					debugBuffer.insert(debugBuffer.getLength(),
						""Event "" + _evt + "" filtered\n"");
				}
				return;
			}
			else
			{
				if(debugBuffer != null)
				{
					debugBuffer.insert(debugBuffer.getLength(),
						""Event "" + _evt + "" passed\n"");
				}
			}

			evt.consume();

			StringBuffer keyString = new StringBuffer(getText());

			if(getDocument().getLength() != 0)
				keyString.append(' ');

			if(evt.getID() == KeyEvent.KEY_TYPED)
			{
				if(!Character.isLetterOrDigit(evt.getKeyChar()))
					return;

				keyString.append(evt.getKeyChar());
			}
			else if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				boolean appendPlus = false;

				
				
				
				if(evt.isControlDown())
				{
					keyString.append(OperatingSystem.isMacOS()
						? 'M' : 'C');
					appendPlus = true;
				}

				if(evt.isAltDown())
				{
					keyString.append('A');
					appendPlus = true;
				}

				if(evt.isMetaDown())
				{
					keyString.append(OperatingSystem.isMacOS()
						? 'C' : 'M');
					appendPlus = true;
				}

				if(evt.isShiftDown())
				{
					keyString.append('S');
					appendPlus = true;
				}

				if(appendPlus)
					keyString.append('+');

				int keyCode = evt.getKeyCode();

				if(((keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)
					|| (keyCode >= KeyEvent.VK_0 && keyCode <= KeyEvent.VK_9))
					&& !evt.isAltDown()
					&& !evt.isControlDown()
					&& !evt.isMetaDown()
					&& !evt.isShiftDown())
				{
					
					return;
				}

				String symbolicName = getSymbolicName(keyCode);

				if(symbolicName == null)
					return;

				keyString.append(symbolicName);
			}
			else if(evt.getID() == KeyEvent.KEY_RELEASED)
				return;

			setText(keyString.toString());
			if(debugBuffer == null)
				updateAssignedTo(keyString.toString());
		} 
	} 

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(canClose())
					dispose();
			}
			else if(evt.getSource() == remove)
			{
				shortcut.setText(null);
				isOK = true;
				dispose();
			}
			else if(evt.getSource() == cancel)
				dispose();
			else if(evt.getSource() == clear)
			{
				shortcut.setText(null);
				if(debugBuffer == null)
					updateAssignedTo(null);
			}
		} 

		
		private boolean canClose()
		{
			String shortcutString = shortcut.getText();
			if(shortcutString.length() == 0
				&& binding.isAssigned())
			{
				
				int answer = GUIUtilities.confirm(
					GrabKeyDialog.this,
					""grab-key.remove-ask"",
					null,
					JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.QUESTION_MESSAGE);
				if(answer == JOptionPane.YES_OPTION)
				{
					shortcut.setText(null);
					isOK = true;
				}
				else if(answer == JOptionPane.CANCEL_OPTION)
					return false;
				return true;
			}

			
			KeyBinding other = getKeyBinding(shortcutString);
			if(other == null || other == binding)
			{
				isOK = true;
				return true;
			}

			
			if(other.name == binding.name)
			{
				
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.duplicate-alt-shortcut"",
					null);
				return false;
			}

			
			if(other.isPrefix)
			{
				
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.prefix-shortcut"",
					null);
				return false;
			}

			
			int answer = GUIUtilities.confirm(GrabKeyDialog.this,
				""grab-key.duplicate-shortcut"",
				new Object[] { other.label },
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(answer == JOptionPane.YES_OPTION)
			{
				if(other.shortcut != null
					&& shortcutString.startsWith(other.shortcut))
				{
					other.shortcut = null;
				}
				isOK = true;
				return true;
			}
			else if(answer == JOptionPane.CANCEL_OPTION)
				return false;

			return true;
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.GUIUtilities,41,1,0,86,152,802,74,23,35,0.94375,1670,0.375,1,0.0,0.119642857,0,0,39.53658537,16,3.122,2,"

package org.gjt.sp.jedit;


import gnu.regexp.REException;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.util.Log;



public class GUIUtilities
{
	
	public static final Icon NEW_BUFFER_ICON = loadIcon(""new.gif"");
	public static final Icon DIRTY_BUFFER_ICON = loadIcon(""dirty.gif"");
	public static final Icon READ_ONLY_BUFFER_ICON = loadIcon(""readonly.gif"");
	public static final Icon NORMAL_BUFFER_ICON = loadIcon(""normal.gif"");
	public static final Icon WINDOW_ICON = loadIcon(""jedit-icon.gif"");
	

	

	
	
	public static Icon loadIcon(String iconName)
	{
		if(icons == null)
			icons = new Hashtable();

		
		Icon icon = (Icon)icons.get(iconName);
		if(icon != null)
			return icon;

		
		if(iconName.startsWith(""file:""))
		{
			icon = new ImageIcon(iconName.substring(5));
		}
		else
		{
			URL url = GUIUtilities.class.getResource(
				""/org/gjt/sp/jedit/icons/"" + iconName);
			if(url == null)
			{
				Log.log(Log.ERROR,GUIUtilities.class,
					""Icon not found: "" + iconName);
				return null;
			}

			icon = new ImageIcon(url);
		}

		icons.put(iconName,icon);
		return icon;
	} 

	
	
	public static Image getEditorIcon()
	{
		return ((ImageIcon)WINDOW_ICON).getImage();
	} 

	
	
	public static Image getPluginIcon()
	{
		return ((ImageIcon)WINDOW_ICON).getImage();
	} 

	

	

	
	
	public static JMenuBar loadMenuBar(String name)
	{
		String menus = jEdit.getProperty(name);
		StringTokenizer st = new StringTokenizer(menus);

		JMenuBar mbar = new JMenuBar();

		while(st.hasMoreTokens())
		{
			String menu = st.nextToken();
			if(menu.equals(""plugins""))
				loadPluginsMenu(mbar);
			else
				mbar.add(loadMenu(menu));
		}

		return mbar;
	} 

	
	
	public static JMenu loadMenu(View view, String name)
	{
		return loadMenu(name);
	} 

	
	
	public static JMenu loadMenu(String name)
	{
		if(name.equals(""open-encoding""))
			return new OpenWithEncodingMenu();
		else if(name.equals(""recent-files""))
			return new RecentFilesMenu();
		else if(name.equals(""recent-directories""))
			return new RecentDirectoriesMenu();
		else if(name.equals(""current-directory""))
			return new CurrentDirectoryMenu();
		else if(name.equals(""markers""))
			return new MarkersMenu();
		else if(name.equals(""macros""))
			return new MacrosMenu();
		else
			return new EnhancedMenu(name);
	} 

	
	
	public static JPopupMenu loadPopupMenu(String name)
	{
		JPopupMenu menu = new JPopupMenu();

		String menuItems = jEdit.getProperty(name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					menu.addSeparator();
				else
				{
					if(menuItemName.startsWith(""%""))
						menu.add(loadMenu(menuItemName.substring(1)));
					else
						menu.add(loadMenuItem(menuItemName,false));
				}
			}
		}

		return menu;
	} 

	
	
	public static JMenuItem loadMenuItem(String name)
	{
		return loadMenuItem(name,true);
	} 

	
	
	public static JMenuItem loadMenuItem(String name, boolean setMnemonic)
	{
		EditAction action = jEdit.getAction(name);
		String label = (action == null ?
			jEdit.getProperty(name + "".label"")
			: action.getLabel());
		if(label == null)
			label = name;

		char mnemonic;
		int index = label.indexOf('$');
		if(index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0,index).concat(label.substring(++index));
		}
		else
			mnemonic = '\0';

		JMenuItem mi;
		if(action != null && action.isToggle())
			mi = new EnhancedCheckBoxMenuItem(label,action);
		else
			mi = new EnhancedMenuItem(label,action);

		if(!OperatingSystem.isMacOS() && setMnemonic && mnemonic != '\0')
			mi.setMnemonic(mnemonic);

		return mi;
	} 

	
	
	public static JToolBar loadToolBar(String name)
	{
		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.putClientProperty(""JToolBar.isRollover"",Boolean.TRUE);

		String buttons = jEdit.getProperty(name);
		if(buttons != null)
		{
			StringTokenizer st = new StringTokenizer(buttons);
			while(st.hasMoreTokens())
			{
				String button = st.nextToken();
				if(button.equals(""-""))
					toolBar.addSeparator();
				else
				{
					JButton b = loadToolButton(button);
					if(b != null)
						toolBar.add(b);
				}
			}
		}

		return toolBar;
	} 

	
	
	public static EnhancedButton loadToolButton(String name)
	{
		EditAction action = jEdit.getAction(name);
		String label = (action == null
			? jEdit.getProperty(name + "".label"")
			: action.getLabel());

		if(label == null)
			label = name;

		Icon icon;
		String iconName = jEdit.getProperty(name + "".icon"");
		if(iconName == null)
			return null;
		else
		{
			icon = loadIcon(iconName);
			if(icon == null)
				return null;
		}

		String toolTip = prettifyMenuLabel(label);
		String shortcut1 = jEdit.getProperty(name + "".shortcut"");
		String shortcut2 = jEdit.getProperty(name + "".shortcut2"");
		if(shortcut1 != null || shortcut2 != null)
		{
			toolTip = toolTip + "" (""
				+ (shortcut1 != null
				? shortcut1 : """")
				+ ((shortcut1 != null && shortcut2 != null)
				? "" or "" : """")
				+ (shortcut2 != null
				? shortcut2
				: """") + "")"";
		}

		return new EnhancedButton(icon,toolTip,action);
	} 

	
	
	public static String prettifyMenuLabel(String label)
	{
		int index = label.indexOf('$');
		if(index != -1)
		{
			label = label.substring(0,index)
				.concat(label.substring(index + 1));
		}
		return label;
	} 

	

	

	
	
	public static void message(Component comp, String name, Object[] args)
	{
		hideSplashScreen();

		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.INFORMATION_MESSAGE);
	} 

	
	
	public static void error(Component comp, String name, Object[] args)
	{
		hideSplashScreen();

		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.ERROR_MESSAGE);
	} 

	
	
	public static String input(Component comp, String name, Object def)
	{
		return input(comp,name,null,def);
	} 

	
	
	public static String inputProperty(Component comp, String name,
		String def)
	{
		return inputProperty(comp,name,null,def);
	} 

	
	
	public static String input(Component comp, String name,
		Object[] args, Object def)
	{
		hideSplashScreen();

		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,null,null,def);
		return retVal;
	} 

	
	
	public static String inputProperty(Component comp, String name,
		Object[] args, String def)
	{
		hideSplashScreen();

		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,
			null,null,jEdit.getProperty(def));
		if(retVal != null)
			jEdit.setProperty(def,retVal);
		return retVal;
	} 

	
	
	public static int confirm(Component comp, String name,
		Object[] args, int buttons, int type)
	{
		hideSplashScreen();

		return JOptionPane.showConfirmDialog(comp,
			jEdit.getProperty(name + "".message"",args),
			jEdit.getProperty(name + "".title""),buttons,type);
	} 

	
	
	public static String[] showVFSFileDialog(View view, String path,
		int type, boolean multipleSelection)
	{
		hideSplashScreen();

		VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(
			view,path,type,multipleSelection);
		String[] selectedFiles = fileChooser.getSelectedFiles();
		if(selectedFiles == null)
			return null;

		return selectedFiles;
	} 

	

	

	
	
	public static Color parseColor(String name)
	{
		return parseColor(name, Color.black);
	} 

	
	public static Color parseColor(String name, Color defaultColor)
	{
		if(name == null)
			return defaultColor;
		else if(name.startsWith(""#""))
		{
			try
			{
				return Color.decode(name);
			}
			catch(NumberFormatException nf)
			{
				return defaultColor;
			}
		}
		else if(""red"".equals(name))
			return Color.red;
		else if(""green"".equals(name))
			return Color.green;
		else if(""blue"".equals(name))
			return Color.blue;
		else if(""yellow"".equals(name))
			return Color.yellow;
		else if(""orange"".equals(name))
			return Color.orange;
		else if(""white"".equals(name))
			return Color.white;
		else if(""lightGray"".equals(name))
			return Color.lightGray;
		else if(""gray"".equals(name))
			return Color.gray;
		else if(""darkGray"".equals(name))
			return Color.darkGray;
		else if(""black"".equals(name))
			return Color.black;
		else if(""cyan"".equals(name))
			return Color.cyan;
		else if(""magenta"".equals(name))
			return Color.magenta;
		else if(""pink"".equals(name))
			return Color.pink;
		else
			return defaultColor;
	} 

	
	
	public static String getColorHexString(Color c)
	{
		String colString = Integer.toHexString(c.getRGB() & 0xffffff);
		return ""#000000"".substring(0,7 - colString.length()).concat(colString);
	} 

	
	
	public static SyntaxStyle parseStyle(String str, String family, int size)
		throws IllegalArgumentException
	{
		return parseStyle(str,family,size,true);
	} 

	
	
	public static SyntaxStyle parseStyle(String str, String family, int size,
		boolean color)
		throws IllegalArgumentException
	{
		Color fgColor = Color.black;
		Color bgColor = null;
		boolean italic = false;
		boolean bold = false;
		StringTokenizer st = new StringTokenizer(str);
		while(st.hasMoreTokens())
		{
			String s = st.nextToken();
			if(s.startsWith(""color:""))
			{
				if(color)
					fgColor = GUIUtilities.parseColor(s.substring(6), Color.black);
			}
			else if(s.startsWith(""bgColor:""))
			{
				if(color)
					bgColor = GUIUtilities.parseColor(s.substring(8), null);
			}
			else if(s.startsWith(""style:""))
			{
				for(int i = 6; i < s.length(); i++)
				{
					if(s.charAt(i) == 'i')
						italic = true;
					else if(s.charAt(i) == 'b')
						bold = true;
					else
						throw new IllegalArgumentException(
							""Invalid style: "" + s);
				}
			}
			else
				throw new IllegalArgumentException(
					""Invalid directive: "" + s);
		}
		return new SyntaxStyle(fgColor,bgColor,
			new Font(family,
			(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0),
			size));
	} 

	
	
	public static String getStyleString(SyntaxStyle style)
	{
		StringBuffer buf = new StringBuffer();

		if(style.getForegroundColor() != null)
		{
			buf.append(""color:"" + getColorHexString(style.getForegroundColor()));
		}

		if(style.getBackgroundColor() != null) 
		{
			buf.append("" bgColor:"" + getColorHexString(style.getBackgroundColor()));
		}
		if(!style.getFont().isPlain())
		{
			buf.append("" style:"" + (style.getFont().isItalic() ? ""i"" : """")
				+ (style.getFont().isBold() ? ""b"" : """"));
		}

		return buf.toString();
	} 

	
	
	public static SyntaxStyle[] loadStyles(String family, int size)
	{
		return loadStyles(family,size,true);
	} 

	
	
	public static SyntaxStyle[] loadStyles(String family, int size, boolean color)
	{
		SyntaxStyle[] styles = new SyntaxStyle[Token.ID_COUNT];

		try
		{
			styles[Token.COMMENT1] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.comment1""),
				family,size,color);
			styles[Token.COMMENT2] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.comment2""),
				family, size,color);
			styles[Token.LITERAL1] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.literal1""),
				family,size,color);
			styles[Token.LITERAL2] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.literal2""),
				family,size,color);
			styles[Token.LABEL] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.label""),
				family,size,color);
			styles[Token.KEYWORD1] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.keyword1""),
				family,size,color);
			styles[Token.KEYWORD2] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.keyword2""),
				family,size,color);
			styles[Token.KEYWORD3] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.keyword3""),
				family,size,color);
			styles[Token.FUNCTION] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.function""),
				family,size,color);
			styles[Token.MARKUP] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.markup""),
				family,size,color);
			styles[Token.OPERATOR] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.operator""),
				family,size,color);
			styles[Token.DIGIT] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.digit""),
				family,size,color);
			styles[Token.INVALID] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.invalid""),
				family,size,color);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,GUIUtilities.class,e);
		}

		return styles;
	} 

	

	

	
	
	public static void loadGeometry(Window win, String name)
	{
		
		
		
		int x, y, width, height, adjust_x, adjust_y, adjust_width,
			adjust_height;

		Dimension size = win.getSize();

		width = jEdit.getIntegerProperty(name + "".width"",size.width);
		height = jEdit.getIntegerProperty(name + "".height"",size.height);

		Component parent = win.getParent();
		if(parent == null)
		{
			Dimension screen = win.getToolkit().getScreenSize();
			x = (screen.width - width) / 2;
			y = (screen.height - height) / 2;
		}
		else
		{
			Rectangle bounds = parent.getBounds();
			x = bounds.x + (bounds.width - width) / 2;
			y = bounds.y + (bounds.height - height) / 2;
		}

		x = jEdit.getIntegerProperty(name + "".x"",x);
		y = jEdit.getIntegerProperty(name + "".y"",y);

		adjust_x = jEdit.getIntegerProperty(name + "".dx"",0);
		adjust_y = jEdit.getIntegerProperty(name + "".dy"",0);
		adjust_width = jEdit.getIntegerProperty(name + "".d-width"",0);
		adjust_height = jEdit.getIntegerProperty(name + "".d-height"",0);

		Rectangle desired = new Rectangle(x,y,width,height);
		Rectangle required = new Rectangle(x - adjust_x,
			y - adjust_y,width - adjust_width,
			height - adjust_height);




		win.setBounds(required);

		
			
			
			
		
			
			
		
		
			win.setBounds(desired);
	} 

	
	 

	
	
	public static void saveGeometry(Window win, String name)
	{
		Rectangle bounds = win.getBounds();
		jEdit.setIntegerProperty(name + "".x"",bounds.x);
		jEdit.setIntegerProperty(name + "".y"",bounds.y);
		jEdit.setIntegerProperty(name + "".width"",bounds.width);
		jEdit.setIntegerProperty(name + "".height"",bounds.height);
	} 

	

	
	
	public static void hideSplashScreen()
	{
		if(splash != null)
		{
			splash.dispose();
			splash = null;
		}
	} 

	
	
	public static void requestFocus(final Window win, final Component comp)
	{
		win.addWindowListener(new WindowAdapter()
		{
			public void windowActivated(WindowEvent evt)
			{
				comp.requestFocus();
				win.removeWindowListener(this);
			}
		});
	} 

	
	
	public static boolean isPopupTrigger(MouseEvent evt)
	{
		if(OperatingSystem.isMacOS())
			return evt.isControlDown();
		else
			return ((evt.getModifiers() & InputEvent.BUTTON3_MASK) != 0);
	} 

	
	
	public static void showPopupMenu(JPopupMenu popup, Component comp,
		int x, int y)
	{
		Point p = new Point(x,y);
		SwingUtilities.convertPointToScreen(p,comp);

		Dimension size = popup.getPreferredSize();

		Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();

		boolean horiz = false;
		boolean vert = false;

		
		int origX = x;

		if(p.x + size.width > screen.width
			&& size.width < screen.width)
		{
			x += (screen.width - p.x - size.width);
			horiz = true;
		}

		if(p.y + size.height > screen.height
			&& size.height < screen.height)
		{
			y += (screen.height - p.y - size.height);
			vert = true;
		}

		
		
		
		
		
		if(horiz && vert)
		{
			x = origX - size.width - 2;
		}

		popup.show(comp,x,y);
	} 

	
	
	public static View getView(Component comp)
	{
		for(;;)
		{
			if(comp instanceof JComponent)
			{
				Component real = (Component)((JComponent)comp)
					.getClientProperty(""KORTE_REAL_FRAME"");
				if(real != null)
					comp = real;
			}

			if(comp instanceof View)
				return (View)comp;
			else if(comp instanceof JPopupMenu)
				comp = ((JPopupMenu)comp).getInvoker();
			else if(comp != null)
				comp = comp.getParent();
			else
				break;
		}
		return null;
	} 

	

	
	static void showSplashScreen()
	{
		splash = new SplashScreen();
	} 

	
	static void advanceSplashProgress()
	{
		if(splash != null)
			splash.advance();
	} 

	

	
	private static SplashScreen splash;
	private static Hashtable icons;

	private GUIUtilities() {}

	
	private static void loadPluginsMenu(JMenuBar mbar)
	{
		
		Vector pluginMenuItems = new Vector();

		EditPlugin[] pluginArray = jEdit.getPlugins();
		for(int i = 0; i < pluginArray.length; i++)
		{
			try
			{
				EditPlugin plugin = pluginArray[i];
				plugin.createMenuItems(pluginMenuItems);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,GUIUtilities.class,
					""Error creating menu items""
					+ "" for plugin"");
				Log.log(Log.ERROR,GUIUtilities.class,t);
			}
		}

		JMenu menu = new EnhancedMenu(""plugins"");

		if(pluginMenuItems.isEmpty())
		{
			menu.add(GUIUtilities.loadMenuItem(""no-plugins""));
			mbar.add(menu);
			return;
		}

		
		MiscUtilities.quicksort(pluginMenuItems,
			new MiscUtilities.MenuItemCompare());

		if(pluginMenuItems.size() < 20)
		{
			for(int i = 0; i < pluginMenuItems.size(); i++)
			{
				menu.add((JMenuItem)pluginMenuItems.get(i));
			}
			mbar.add(menu);
		}
		else
		{
			int menuCount = 1;

			menu.setText(menu.getText() + "" "" + menuCount);

			for(int i = 0; i < pluginMenuItems.size(); i++)
			{
				menu.add((JMenuItem)pluginMenuItems.get(i));
				if(menu.getMenuComponentCount() == 20)
				{
					mbar.add(menu);
					menu = new JMenu(String.valueOf(
						++menuCount));
				}
			}

			if(menu.getMenuComponentCount() != 0)
				mbar.add(menu);
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.EBComponent,1,1,0,36,1,0,36,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit;


public interface EBComponent
{
	
	void handleMessage(EBMessage message);
}
"
jEdit,4,org.gjt.sp.jedit.gui.KeyEventWorkaround,4,1,0,6,16,0,5,1,3,1.095238095,222,1.0,0,0.0,0.333333333,0,0,52.75,60,20.0,0,"

package org.gjt.sp.jedit.gui;


import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.OperatingSystem;



public class KeyEventWorkaround
{
	
	public static KeyEvent processKeyEvent(KeyEvent evt)
	{
		int keyCode = evt.getKeyCode();
		char ch = evt.getKeyChar();

		switch(evt.getID())
		{
		
		case KeyEvent.KEY_PRESSED:
			
			switch(keyCode)
			{
			case KeyEvent.VK_ALT:
			case KeyEvent.VK_ALT_GRAPH:
			case KeyEvent.VK_CONTROL:
			case KeyEvent.VK_SHIFT:
			case KeyEvent.VK_META:
			case KeyEvent.VK_DEAD_GRAVE:
			case KeyEvent.VK_DEAD_ACUTE:
			case KeyEvent.VK_DEAD_CIRCUMFLEX:
			case KeyEvent.VK_DEAD_TILDE:
			case KeyEvent.VK_DEAD_MACRON:
			case KeyEvent.VK_DEAD_BREVE:
			case KeyEvent.VK_DEAD_ABOVEDOT:
			case KeyEvent.VK_DEAD_DIAERESIS:
			case KeyEvent.VK_DEAD_ABOVERING:
			case KeyEvent.VK_DEAD_DOUBLEACUTE:
			case KeyEvent.VK_DEAD_CARON:
			case KeyEvent.VK_DEAD_CEDILLA:
			case KeyEvent.VK_DEAD_OGONEK:
			case KeyEvent.VK_DEAD_IOTA:
			case KeyEvent.VK_DEAD_VOICED_SOUND:
			case KeyEvent.VK_DEAD_SEMIVOICED_SOUND:
			case '\0':
				return null;
			default:
				switch(keyCode)
				{
					case KeyEvent.VK_NUMPAD0:   case KeyEvent.VK_NUMPAD1:
					case KeyEvent.VK_NUMPAD2:   case KeyEvent.VK_NUMPAD3:
					case KeyEvent.VK_NUMPAD4:   case KeyEvent.VK_NUMPAD5:
					case KeyEvent.VK_NUMPAD6:   case KeyEvent.VK_NUMPAD7:
					case KeyEvent.VK_NUMPAD8:   case KeyEvent.VK_NUMPAD9:
					case KeyEvent.VK_MULTIPLY:  case KeyEvent.VK_ADD:
					 case KeyEvent.VK_SUBTRACT:
					case KeyEvent.VK_DECIMAL:   case KeyEvent.VK_DIVIDE:
						last = LAST_NUMKEYPAD;
						lastKeyTime = System.currentTimeMillis();
						return evt;
				}

				if(!OperatingSystem.isMacOS())
					handleBrokenKeys(evt,keyCode);
				else
					last = LAST_NOTHING;
				break;
			}

			return evt;
		
		
		case KeyEvent.KEY_TYPED:
			
			
			if((ch < 0x20 || ch == 0x7f || ch == 0xff) && ch != '\b')
				return null;

			
			
			if(OperatingSystem.isMacOS())
			{
				if(evt.isControlDown() || evt.isMetaDown())
					return null;
			}
			else
			{
				if((evt.isControlDown() ^ evt.isAltDown())
					|| evt.isMetaDown())
					return null;
			}

			
			
			
			if(last == LAST_MOD)
			{
				switch(ch)
				{
				case 'B':
				case 'M':
				case 'X':
				case 'c':
				case '!':
				case ',':
				case '?':
					last = LAST_NOTHING;
					return null;
				}
			}

			
			
			if(last == LAST_NUMKEYPAD && System.currentTimeMillis()
				- lastKeyTime < 750)
			{
				last = LAST_NOTHING;
				if((ch >= '0' && ch <= '9') || ch == '.'
					|| ch == '/' || ch == '*'
					|| ch == '-' || ch == '+')
				{
					return null;
				}
			}
			
			
			else if(last == LAST_BROKEN && System.currentTimeMillis()
				- lastKeyTime < 750 && !Character.isLetter(ch))
			{
				last = LAST_NOTHING;
				return null;
			}
			
			else if(last == LAST_ALT && System.currentTimeMillis()
				- lastKeyTime < 750)
			{
				last = LAST_NOTHING;
				return null;
			}

			return evt;
		
		
		case KeyEvent.KEY_RELEASED:
			if(keyCode == KeyEvent.VK_ALT)
			{
				
				
				if(OperatingSystem.isWindows()
					&& OperatingSystem.hasJava14())
					last = LAST_MOD;
			}
			return evt;
		
		default:
			return evt;
		}
	} 

	
	
	public static void numericKeypadKey()
	{
		last = LAST_NOTHING;
	} 

	

	
	private static long lastKeyTime;

	private static int last;
	private static final int LAST_NOTHING = 0;
	private static final int LAST_ALT = 1;
	private static final int LAST_BROKEN = 2;
	private static final int LAST_NUMKEYPAD = 3;
	private static final int LAST_MOD = 4;
	

	
	private static void handleBrokenKeys(KeyEvent evt, int keyCode)
	{
		if(evt.isAltDown() && evt.isControlDown()
			&& !evt.isMetaDown())
		{
			last = LAST_NOTHING;
			return;
		}
		else if(!(evt.isAltDown() || evt.isControlDown() || evt.isMetaDown()))
		{
			last = LAST_NOTHING;
			return;
		}

		if(evt.isAltDown())
			last = LAST_ALT;

		switch(keyCode)
		{
			case KeyEvent.VK_LEFT:      case KeyEvent.VK_RIGHT:
			case KeyEvent.VK_UP:        case KeyEvent.VK_DOWN:
			case KeyEvent.VK_DELETE:    case KeyEvent.VK_BACK_SPACE:
			case KeyEvent.VK_TAB:       case KeyEvent.VK_ENTER:
				last = LAST_NOTHING;
				break;
			default:
				if(keyCode < KeyEvent.VK_A || keyCode > KeyEvent.VK_Z)
					last = LAST_BROKEN;
				else
					last = LAST_NOTHING;
				break;
		}

		lastKeyTime = System.currentTimeMillis();
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.PastePrevious,12,7,0,7,58,52,1,7,10,0.709090909,284,1.0,2,0.983433735,0.277777778,0,0,22.25,3,1.3333,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;


public class PastePrevious extends EnhancedDialog
implements ActionListener, ListSelectionListener, MouseListener
{
	
	public PastePrevious(View view)
	{
		super(view,jEdit.getProperty(""pasteprev.title""),true);
		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		clipHistory = HistoryModel.getModel(""clipboard"");

		clips = new JList(new AbstractListModel() {
			public int getSize()
			{
				return clipHistory.getSize();
			}

			public Object getElementAt(int index)
			{
				StringBuffer buf = new StringBuffer();
				String item = clipHistory.getItem(index);
				boolean ws = true;
				for(int i = 0; i < item.length(); i++)
				{
					char ch = item.charAt(i);
					if(Character.isWhitespace(ch))
					{
						if(ws)
							;
						else
						{
							buf.append(' ');
							ws = true;
						}
					}
					else
					{
						ws = false;
						buf.append(ch);
					}
				}
				return buf.toString();
			}
		});

		clips.setVisibleRowCount(16);

		clips.addMouseListener(this);
		clips.addListSelectionListener(this);

		insert = new JButton(jEdit.getProperty(""pasteprev.insert""));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));

		JLabel label = new JLabel(jEdit.getProperty(""pasteprev.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,label);

		JScrollPane scroller = new JScrollPane(clips);
		Dimension dim = scroller.getPreferredSize();
		scroller.setPreferredSize(new Dimension(640,dim.height));

		content.add(scroller, BorderLayout.CENTER);

		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		panel.add(Box.createGlue());
		panel.add(insert);
		panel.add(Box.createHorizontalStrut(6));
		panel.add(cancel);
		panel.add(Box.createGlue());
		content.add(panel, BorderLayout.SOUTH);

		if(clipHistory.getSize() >= 1)
			clips.setSelectedIndex(0);
		updateButtons();

		getRootPane().setDefaultButton(insert);
		insert.addActionListener(this);
		cancel.addActionListener(this);

		GUIUtilities.requestFocus(this,clips);

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		int selected = clips.getSelectedIndex();

		if(selected == -1)
		{
			view.getToolkit().beep();
			return;
		}

		String clip = clipHistory.getItem(selected);
		view.getTextArea().setSelectedText(clip);

		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == insert)
			ok();
		else if(source == cancel)
			cancel();
	} 

	
	public void mouseClicked(MouseEvent evt)
	{
		if(evt.getClickCount() == 2)
			ok();
	} 

	
	public void mouseEntered(MouseEvent evt) {}
	public void mouseExited(MouseEvent evt) {}
	public void mousePressed(MouseEvent evt) {}
	public void mouseReleased(MouseEvent evt) {} 

	
	public void valueChanged(ListSelectionEvent evt)
	{
		updateButtons();
	} 

	

	
	private View view;
	private JList clips;
	private HistoryModel clipHistory;
	private JButton insert;
	private JButton cancel;
	

	
	private void updateButtons()
	{
		int selected = clips.getSelectedIndex();
		insert.setEnabled(selected != -1);
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.EditPane,19,5,0,30,126,53,17,20,12,0.537037037,781,1.0,5,0.973174367,0.210526316,1,1,39.78947368,22,3.0526,3,"

package org.gjt.sp.jedit;


import javax.swing.event.*;
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class EditPane extends JPanel implements EBComponent
{
	
	
	public View getView()
	{
		return view;
	} 

	
	
	public Buffer getBuffer()
	{
		return buffer;
	} 

	
	
	public void setBuffer(final Buffer buffer)
	{
		if(this.buffer == buffer)
			return;

		if(buffer.insideCompoundEdit())
			buffer.endCompoundEdit();

		recentBuffer = this.buffer;
		if(recentBuffer != null)
			saveCaretInfo();
		this.buffer = buffer;

		textArea.setBuffer(buffer);

		if(!init)
		{
			view.updateTitle();

			if(bufferSwitcher != null)
			{
				if(bufferSwitcher.getSelectedItem() != buffer)
					bufferSwitcher.setSelectedItem(buffer);
			}

			EditBus.send(new EditPaneUpdate(this,EditPaneUpdate
				.BUFFER_CHANGED));
		}

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				
				if(view.getEditPane() == EditPane.this
					&& (bufferSwitcher == null
					|| !bufferSwitcher.isPopupVisible()))
				{
					focusOnTextArea();
				}
			}
		});

		
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				loadCaretInfo();
				buffer.checkModTime(view);
			}
		};

		if(buffer.isPerformingIO())
			VFSManager.runInAWTThread(runnable);
		else
			runnable.run();
	} 

	
	
	public void prevBuffer()
	{
		Buffer buffer = this.buffer.getPrev();
		if(buffer == null)
			setBuffer(jEdit.getLastBuffer());
		else
			setBuffer(buffer);
	} 

	
	
	public void nextBuffer()
	{
		Buffer buffer = this.buffer.getNext();
		if(buffer == null)
			setBuffer(jEdit.getFirstBuffer());
		else
			setBuffer(buffer);
	} 

	
	
	public void recentBuffer()
	{
		if(recentBuffer != null)
			setBuffer(recentBuffer);
		else
			getToolkit().beep();
	} 

	
	
	public void focusOnTextArea()
	{
		textArea.grabFocus();
		
		





	} 

	
	
	public JEditTextArea getTextArea()
	{
		return textArea;
	} 

	
	
	public void saveCaretInfo()
	{
		buffer.setIntegerProperty(Buffer.CARET,
			textArea.getCaretPosition());

		

		buffer.setIntegerProperty(Buffer.SCROLL_VERT,
			textArea.getFirstPhysicalLine());
		buffer.setIntegerProperty(Buffer.SCROLL_HORIZ,
			textArea.getHorizontalOffset());
	} 

	
	
	public void loadCaretInfo()
	{
		Integer caret = (Integer)buffer.getProperty(Buffer.CARET);
		

		Integer firstLine = (Integer)buffer.getProperty(Buffer.SCROLL_VERT);
		Integer horizontalOffset = (Integer)buffer.getProperty(Buffer.SCROLL_HORIZ);

		if(caret != null)
		{
			textArea.setCaretPosition(Math.min(caret.intValue(),
				buffer.getLength()));
		}

		

		if(firstLine != null)
			textArea.setFirstLine(textArea.physicalToVirtual(firstLine.intValue()));

		if(horizontalOffset != null)
			textArea.setHorizontalOffset(horizontalOffset.intValue());

		
		view.getStatus().setMessage(null);
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
		{
			propertiesChanged();
			loadBufferSwitcher();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
	} 

	
	
	public final Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} 

	

	
	EditPane(View view, Buffer buffer)
	{
		super(new BorderLayout());

		init = true;

		this.view = view;

		EditBus.addToBus(this);

		textArea = new JEditTextArea(view);

		add(BorderLayout.CENTER,textArea);

		propertiesChanged();

		if(buffer == null)
			setBuffer(jEdit.getFirstBuffer());
		else
			setBuffer(buffer);

		loadBufferSwitcher();

		init = false;
	} 

	
	void close()
	{
		saveCaretInfo();
		EditBus.send(new EditPaneUpdate(this,EditPaneUpdate.DESTROYED));
		EditBus.removeFromBus(this);
	} 

	

	

	
	private boolean init;
	private View view;
	private Buffer buffer;
	private Buffer recentBuffer;
	private BufferSwitcher bufferSwitcher;
	private JEditTextArea textArea;
	

	
	private void propertiesChanged()
	{
		TextAreaPainter painter = textArea.getPainter();

		painter.setFont(UIManager.getFont(""TextArea.font""));
		painter.setBracketHighlightEnabled(jEdit.getBooleanProperty(
			""view.bracketHighlight""));
		painter.setBracketHighlightColor(
			jEdit.getColorProperty(""view.bracketHighlightColor""));
		painter.setEOLMarkersPainted(jEdit.getBooleanProperty(
			""view.eolMarkers""));
		painter.setEOLMarkerColor(
			jEdit.getColorProperty(""view.eolMarkerColor""));
		painter.setWrapGuidePainted(jEdit.getBooleanProperty(
			""view.wrapGuide""));
		painter.setWrapGuideColor(
			jEdit.getColorProperty(""view.wrapGuideColor""));
		painter.setCaretColor(
			jEdit.getColorProperty(""view.caretColor""));
		painter.setSelectionColor(
			jEdit.getColorProperty(""view.selectionColor""));
		painter.setBackground(
			jEdit.getColorProperty(""view.bgColor""));
		painter.setForeground(
			jEdit.getColorProperty(""view.fgColor""));
		painter.setBlockCaretEnabled(jEdit.getBooleanProperty(
			""view.blockCaret""));
		painter.setFoldedLineColor(
			jEdit.getColorProperty(""view.foldedLineColor""));
		painter.setLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.lineHighlight""));
		painter.setLineHighlightColor(
			jEdit.getColorProperty(""view.lineHighlightColor""));
		painter.setAntiAliasEnabled(jEdit.getBooleanProperty(
			""view.antiAlias""));
		painter.setFractionalFontMetricsEnabled(jEdit.getBooleanProperty(
			""view.fracFontMetrics""));
		painter.setStyles(GUIUtilities.loadStyles(
			jEdit.getProperty(""view.font""),
			jEdit.getIntegerProperty(""view.fontsize"",12)));

		Gutter gutter = textArea.getGutter();
		gutter.setExpanded(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		int interval = jEdit.getIntegerProperty(
			""view.gutter.highlightInterval"",5);
		gutter.setHighlightInterval(interval);
		gutter.setCurrentLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		gutter.setBracketHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.bracketHighlight""));
		gutter.setBracketHighlightColor(
			jEdit.getColorProperty(""view.gutter.bracketHighlightColor""));
		gutter.setBackground(
			jEdit.getColorProperty(""view.gutter.bgColor""));
		gutter.setForeground(
			jEdit.getColorProperty(""view.gutter.fgColor""));
		gutter.setHighlightedForeground(
			jEdit.getColorProperty(""view.gutter.highlightColor""));
		gutter.setFoldColor(
			jEdit.getColorProperty(""view.gutter.foldColor""));
		gutter.setMarkerHighlightColor(
			jEdit.getColorProperty(""view.gutter.markerColor""));
		gutter.setMarkerHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		gutter.setCurrentLineForeground(
			jEdit.getColorProperty(""view.gutter.currentLineColor""));
		String alignment = jEdit.getProperty(
			""view.gutter.numberAlignment"");
		if (""right"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.RIGHT);
		}
		else if (""center"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.CENTER);
		}
		else 
		{
			gutter.setLineNumberAlignment(Gutter.LEFT);
		}

		gutter.setFont(jEdit.getFontProperty(""view.gutter.font""));

		int width = jEdit.getIntegerProperty(
			""view.gutter.borderWidth"",3);
		gutter.setBorder(width,
			jEdit.getColorProperty(""view.gutter.focusBorderColor""),
			jEdit.getColorProperty(""view.gutter.noFocusBorderColor""),
			textArea.getPainter().getBackground());

		textArea.setCaretBlinkEnabled(jEdit.getBooleanProperty(
			""view.caretBlink""));

		textArea.setElectricScroll(jEdit.getIntegerProperty(
			""view.electricBorders"",0));

		
		textArea.setRightClickPopup(GUIUtilities
			.loadPopupMenu(""view.context""));

		
		textArea.setQuickCopyEnabled(jEdit.getBooleanProperty(
			""view.middleMousePaste""));

		textArea.propertiesChanged();
	} 

	
	private void loadBufferSwitcher()
	{
		if(jEdit.getBooleanProperty(""view.showBufferSwitcher""))
		{
			if(bufferSwitcher == null)
			{
				bufferSwitcher = new BufferSwitcher(this);
				add(BorderLayout.NORTH,bufferSwitcher);
				bufferSwitcher.updateBufferList();
				revalidate();
			}
		}
		else if(bufferSwitcher != null)
		{
			remove(bufferSwitcher);
			revalidate();
			bufferSwitcher = null;
		}
	} 

	
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer _buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.CREATED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();

			
			if(buffer.isClosed())
			{
				setBuffer(jEdit.getFirstBuffer());
				
				
				recentBuffer = null;
			}
		}
		else if(msg.getWhat() == BufferUpdate.CLOSED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();

			if(_buffer == buffer)
			{
				Buffer newBuffer = (recentBuffer != null ?
					recentBuffer : _buffer.getPrev());
				if(newBuffer != null && !newBuffer.isClosed())
					setBuffer(newBuffer);
				else if(jEdit.getBufferCount() != 0)
					setBuffer(jEdit.getFirstBuffer());

				recentBuffer = null;
			}
			else if(_buffer == recentBuffer)
				recentBuffer = null;
		}
		else if(msg.getWhat() == BufferUpdate.LOAD_STARTED)
		{
			if(_buffer == buffer)
			{
				textArea.setCaretPosition(0);
				textArea.getPainter().repaint();
			}
		}
		else if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			if(_buffer == buffer)
			{
				if(bufferSwitcher != null)
				{
					if(buffer.isDirty())
						bufferSwitcher.repaint();
					else
						bufferSwitcher.updateBufferList();
				}
			}
		}
		else if(msg.getWhat() == BufferUpdate.LOADED)
		{
			if(_buffer == buffer)
			{
				textArea.repaint();
				textArea.updateScrollBars();
				if(bufferSwitcher != null)
					bufferSwitcher.updateBufferList();

				if(view.getEditPane() == this)
				{
					StatusBar status = view.getStatus();
					status.repaintCaretStatus();
					status.updateBufferStatus();
					status.updateMiscStatus();
				}

				loadCaretInfo();
			}

		}
		else if(msg.getWhat() == BufferUpdate.MARKERS_CHANGED)
		{
			if(_buffer == buffer)
				textArea.getGutter().repaint();
		}
		else if(msg.getWhat() == BufferUpdate.MODE_CHANGED)
		{
			if(_buffer == buffer)
			{
				textArea.propertiesChanged();

				if(view.getEditPane() == this)
					view.getStatus().updateBufferStatus();
			}
		}
		else if(msg.getWhat() == BufferUpdate.ENCODING_CHANGED)
		{
			if(_buffer == buffer)
			{
				if(view.getEditPane() == this)
					view.getStatus().updateBufferStatus();
			}
		}
		else if(msg.getWhat() == BufferUpdate.FOLD_HANDLER_CHANGED)
		{
			if(_buffer == buffer)
			{
				textArea.getFoldVisibilityManager()
					.foldStructureChanged();
				textArea.repaint();

				if(view.getEditPane() == this)
					view.getStatus().updateMiscStatus();
			}
		}
		else if(msg.getWhat() == BufferUpdate.SAVED)
		{
			if(_buffer == buffer)
				textArea.propertiesChanged();
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.search.CurrentBufferSet,6,1,0,6,9,15,4,3,6,2.0,34,0.0,0,0.0,0.555555556,0,0,4.666666667,2,1.0,0,"

package org.gjt.sp.jedit.search;

import org.gjt.sp.jedit.*;


public class CurrentBufferSet implements SearchFileSet
{
	
	public String getFirstFile(View view)
	{
		return view.getBuffer().getPath();
	} 

	
	public String getNextFile(View view, String file)
	{
		if(file == null)
			return view.getBuffer().getPath();
		else
			return null;
	} 

	
	public String[] getFiles(View view)
	{
		return new String[] { view.getBuffer().getPath() };
	} 

	
	public int getFileCount()
	{
		return 1;
	} 

	
	public String getCode()
	{
		return ""new CurrentBufferSet()"";
	} 
}
"
jEdit,4,org.gjt.sp.jedit.search.SearchBar,17,5,0,16,73,76,5,16,4,0.78125,412,1.0,2,0.976083707,0.341176471,2,5,22.76470588,9,1.4118,2,"

package org.gjt.sp.jedit.search;


import java.awt.event.*;
import java.awt.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.HistoryTextField;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;


public class SearchBar extends JPanel
{
	
	public SearchBar(final View view)
	{
		setLayout(new BoxLayout(this,BoxLayout.X_AXIS));

		this.view = view;

		add(Box.createHorizontalStrut(2));

		JLabel label = new JLabel(jEdit.getProperty(""view.search.find""));
		add(label);
		add(Box.createHorizontalStrut(12));
		add(find = new HistoryTextField(""find""));
		find.setSelectAllOnFocus(true);
		Dimension max = find.getPreferredSize();
		max.width = Integer.MAX_VALUE;
		find.setMaximumSize(max);
		ActionHandler actionHandler = new ActionHandler();
		find.addKeyListener(new KeyHandler());
		find.addActionListener(actionHandler);
		find.getDocument().addDocumentListener(new DocumentHandler());

		Insets margin = new Insets(1,1,1,1);

		add(Box.createHorizontalStrut(12));
		add(ignoreCase = new JCheckBox(jEdit.getProperty(
			""search.case"")));
		ignoreCase.addActionListener(actionHandler);
		ignoreCase.setMargin(margin);
		add(Box.createHorizontalStrut(2));
		add(regexp = new JCheckBox(jEdit.getProperty(
			""search.regexp"")));
		regexp.addActionListener(actionHandler);
		regexp.setMargin(margin);
		add(Box.createHorizontalStrut(2));
		add(hyperSearch = new JCheckBox(jEdit.getProperty(
			""search.hypersearch"")));
		hyperSearch.addActionListener(actionHandler);
		hyperSearch.setMargin(margin);

		update();

		
		timer = new Timer(0,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(!incrementalSearch(searchStart,searchReverse))
				{
					if(!incrementalSearch(
						(searchReverse
						? view.getBuffer().getLength()
						: 0),searchReverse))
					{
						
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(
							""view.status.search-not-found""));
					}
				}
			}
		}); 
	} 

	
	public HistoryTextField getField()
	{
		return find;
	} 

	
	public void setHyperSearch(boolean hyperSearch)
	{
		jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",hyperSearch);
		this.hyperSearch.setSelected(hyperSearch);
	} 

	
	public void update()
	{
		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		hyperSearch.setSelected(jEdit.getBooleanProperty(
			""view.search.hypersearch.toggle""));
	} 

	

	
	private View view;
	private HistoryTextField find;
	private JCheckBox ignoreCase, regexp, hyperSearch;
	private Timer timer;
	private int searchStart;
	private boolean searchReverse;
	

	
	private void find(boolean reverse)
	{
		timer.stop();

		String text = find.getText();
		
		if(text.length() == 0)
		{
			jEdit.setBooleanProperty(""search.hypersearch.toggle"",
				hyperSearch.isSelected());
			new SearchDialog(view,null);
		} 
		
		else if(hyperSearch.isSelected())
		{
			find.setText(null);
			SearchAndReplace.setSearchString(text);
			SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
			SearchAndReplace.hyperSearch(view);
		} 
		
		else
		{
			
			
			int start;
			JEditTextArea textArea = view.getTextArea();
			Selection s = textArea.getSelectionAtOffset(
				textArea.getCaretPosition());
			if(s == null)
				start = textArea.getCaretPosition();
			else if(reverse)
				start = s.getStart();
			else
				start = s.getEnd();

			if(!incrementalSearch(start,reverse))
			{
				
				
				if(!incrementalSearch(reverse
					? view.getBuffer().getLength()
					: 0,reverse))
				{
					
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(
						""view.status.search-not-found""));
				}
				else
				{
					
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(""view.status.auto-wrap""));
					
					if(jEdit.getBooleanProperty(""search.beepOnSearchAutoWrap""))
					{
						getToolkit().beep();
					}
				}
			}
		} 
	} 

	
	private boolean incrementalSearch(int start, boolean reverse)
	{
		
		SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
		SearchAndReplace.setSearchString(find.getText());
		SearchAndReplace.setReverseSearch(reverse);

		try
		{
			if(SearchAndReplace.find(view,view.getBuffer(),start))
				return true;
		}
		catch(Exception e)
		{
			Log.log(Log.DEBUG,this,e);

			
			
			
			return true;
		}

		return false;
	} 

	
	private void timerIncrementalSearch(int start, boolean reverse)
	{
		this.searchStart = start;
		this.searchReverse = reverse;

		timer.stop();
		timer.setRepeats(false);
		timer.setInitialDelay(150);
		timer.start();
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(evt.getSource() == find)
				find(false);
			else if(evt.getSource() == hyperSearch)
			{
				jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",
					hyperSearch.isSelected());
				update();
			}
			else if(evt.getSource() == ignoreCase)
			{
				SearchAndReplace.setIgnoreCase(ignoreCase
					.isSelected());
			}
			else if(evt.getSource() == regexp)
			{
				SearchAndReplace.setRegexp(regexp
					.isSelected());
			}
		} 
	} 

	
	class DocumentHandler implements DocumentListener
	{
		
		public void insertUpdate(DocumentEvent evt)
		{
			
			
			
			if(!hyperSearch.isSelected())
			{
				int start;
				JEditTextArea textArea = view.getTextArea();
				Selection s = textArea.getSelectionAtOffset(
					textArea.getCaretPosition());
				if(s == null)
					start = textArea.getCaretPosition();
				else
					start = s.getStart();

				timerIncrementalSearch(start,false);
			}
		} 

		
		public void removeUpdate(DocumentEvent evt)
		{
			
			if(!hyperSearch.isSelected())
			{
				String text = find.getText();
				if(text.length() != 0)
				{
					
					
					
					
					if(regexp.isSelected())
					{
						
						
						
						timerIncrementalSearch(0,false);
					}
					else
					{
						int start;
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else
							start = s.getStart();
						timerIncrementalSearch(start,true);
					}
				}
			}
		} 

		
		public void changedUpdate(DocumentEvent evt) {}
		
	} 

	
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_LEFT:
			case KeyEvent.VK_RIGHT:
				if(!hyperSearch.isSelected())
				{
					evt.consume();
					view.getEditPane().focusOnTextArea();
					view.getEditPane().getTextArea()
						.processKeyEvent(evt);
				}
				break;
			case KeyEvent.VK_ESCAPE:
				evt.consume();
				view.getEditPane().focusOnTextArea();
				break;
			case KeyEvent.VK_ENTER:
				if(evt.isShiftDown())
				{
					evt.consume();
					
					
					find(regexp.isSelected() ? false : true);
				}
				break;
			}
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.CloseDialog,15,7,0,7,55,77,3,7,4,0.888888889,359,0.888888889,1,0.979010495,0.283333333,0,0,22.33333333,3,1.0667,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;


public class CloseDialog extends EnhancedDialog
{
	
	public CloseDialog(View view)
	{
		super(view,jEdit.getProperty(""close.title""),true);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.warningIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout());

		JLabel label = new JLabel(jEdit.getProperty(""close.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);

		bufferList = new JList(bufferModel = new DefaultListModel());
		bufferList.setVisibleRowCount(10);
		bufferList.addListSelectionListener(new ListHandler());

		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if(buffer.isDirty())
			{
				bufferModel.addElement(buffer.getPath());
			}
		}

		centerPanel.add(BorderLayout.CENTER,new JScrollPane(bufferList));

		content.add(BorderLayout.CENTER,centerPanel);

		ActionHandler actionListener = new ActionHandler();

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		buttons.add(selectAll = new JButton(jEdit.getProperty(""close.selectAll"")));
		selectAll.setMnemonic(jEdit.getProperty(""close.selectAll.mnemonic"").charAt(0));
		selectAll.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(save = new JButton(jEdit.getProperty(""close.save"")));
		save.setMnemonic(jEdit.getProperty(""close.save.mnemonic"").charAt(0));
		save.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(discard = new JButton(jEdit.getProperty(""close.discard"")));
		discard.setMnemonic(jEdit.getProperty(""close.discard.mnemonic"").charAt(0));
		discard.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(actionListener);
		buttons.add(Box.createGlue());

		bufferList.setSelectedIndex(0);

		content.add(BorderLayout.SOUTH,buttons);

		GUIUtilities.requestFocus(this,bufferList);

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public boolean isOK()
	{
		return ok;
	} 

	
	public void ok()
	{
		
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	private View view;
	private JList bufferList;
	private DefaultListModel bufferModel;
	private JButton selectAll;
	private JButton save;
	private JButton discard;
	private JButton cancel;

	private boolean ok; 

	boolean selectAllFlag;

	private void updateButtons()
	{
		int index = bufferList.getSelectedIndex();
		save.getModel().setEnabled(index != -1);
		discard.getModel().setEnabled(index != -1);
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == selectAll)
			{
				
				
				try
				{
					selectAllFlag = true;

					bufferList.setSelectionInterval(0,
						bufferModel.getSize() - 1);
				}
				finally
				{
					selectAllFlag = false;
				}
				bufferList.requestFocus();
			}
			else if(source == save)
			{
				Object[] paths = bufferList.getSelectedValues();

				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					if(!buffer.save(view,null,true))
						return;
					VFSManager.waitForRequests();
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}

				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
				else
				{
					bufferList.setSelectedIndex(0);
					bufferList.requestFocus();
				}
			}
			else if(source == discard)
			{
				Object[] paths = bufferList.getSelectedValues();

				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}

				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
				else
				{
					bufferList.setSelectedIndex(0);
					bufferList.requestFocus();
				}
			}
			else if(source == cancel)
				cancel();
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			if(selectAllFlag)
				return;

			int index = bufferList.getSelectedIndex();
			if(index != -1)
				view.setBuffer(jEdit.getBuffer((String)
					bufferModel.getElementAt(index)));

			updateButtons();
		}
	} 
}
"
jEdit,4,org.gjt.sp.util.SegmentBuffer,4,2,0,2,6,6,2,0,3,2.0,83,0.0,0,0.842105263,0.5625,1,11,19.75,3,1.25,0,"

package org.gjt.sp.util;

import javax.swing.text.Segment;


public class SegmentBuffer extends Segment
{
	
	public SegmentBuffer(int capacity)
	{
		ensureCapacity(capacity);
	} 

	
	public void append(char ch)
	{
		ensureCapacity(count + 1);
		array[offset + count] = ch;
		count++;
	} 

	
	public void append(char[] text, int off, int len)
	{
		ensureCapacity(count + len);
		System.arraycopy(text,off,array,count,len);
		count += len;
	} 

	

	
	private void ensureCapacity(int capacity)
	{
		if(array == null)
			array = new char[capacity];
		else if(capacity >= array.length)
		{
			char[] arrayN = new char[capacity * 2];
			System.arraycopy(array,0,arrayN,0,count);
			array = arrayN;
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.BeanShell,22,1,0,29,94,139,10,21,17,0.785714286,853,1.0,3,0.0,0.227272727,0,0,37.5,14,2.0909,2,"

package org.gjt.sp.jedit;


import bsh.*;
import javax.swing.text.Segment;
import javax.swing.JFileChooser;
import java.lang.reflect.InvocationTargetException;
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.BeanShellErrorDialog;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;


public class BeanShell
{
	
	
	public static void evalSelection(View view, JEditTextArea textArea)
	{
		String command = textArea.getSelectedText();
		if(command == null)
		{
			view.getToolkit().beep();
			return;
		}
		Object returnValue = eval(view,global,command);
		if(returnValue != null)
			textArea.setSelectedText(returnValue.toString());
	} 

	
	
	public static void showEvaluateDialog(View view)
	{
		String command = GUIUtilities.input(view,""beanshell-eval-input"",null);
		if(command != null)
		{
			if(!command.endsWith("";""))
				command = command + "";"";

			int repeat = view.getInputHandler().getRepeatCount();

			if(view.getMacroRecorder() != null)
			{
				view.getMacroRecorder().record(repeat,command);
			}

			Object returnValue = null;
			try
			{
				for(int i = 0; i < repeat; i++)
				{
					returnValue = _eval(view,global,command);
				}
			}
			catch(Throwable e)
			{
				Log.log(Log.ERROR,BeanShell.class,e);

				handleException(view,null,e);
			}

			if(returnValue != null)
			{
				String[] args = { returnValue.toString() };
				GUIUtilities.message(view,""beanshell-eval"",args);
			}
		}
	} 

	
	
	public static void showEvaluateLinesDialog(View view)
	{
		String command = GUIUtilities.input(view,""beanshell-eval-line"",null);

		JEditTextArea textArea = view.getTextArea();
		Buffer buffer = view.getBuffer();

		Selection[] selection = textArea.getSelection();
		if(selection.length == 0 || command == null || command.length() == 0)
		{
			view.getToolkit().beep();
			return;
		}

		if(!command.endsWith("";""))
			command = command + "";"";

		if(view.getMacroRecorder() != null)
			view.getMacroRecorder().record(1,command);

		try
		{
			buffer.beginCompoundEdit();

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				for(int j = s.getStartLine(); j <= s.getEndLine(); j++)
				{
					
					
					if(s.getEnd() == textArea.getLineStartOffset(j))
						break;

					global.setVariable(""line"",new Integer(j));
					global.setVariable(""index"",new Integer(
						j - s.getStartLine()));
					int start = s.getStart(buffer,j);
					int end = s.getEnd(buffer,j);
					String text = buffer.getText(start,
						end - start);
					global.setVariable(""text"",text);

					Object returnValue = _eval(view,global,command);
					if(returnValue != null)
					{
						buffer.remove(start,end - start);
						buffer.insert(start,
							returnValue.toString());
					}
				}
			}
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);

			handleException(view,null,e);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		textArea.selectNone();
	} 

	
	
	public static void showRunScriptDialog(View view)
	{
		Macros.showRunScriptDialog(view);
	} 

	
	
	public static void runScript(View view, String path, Reader in,
		boolean ownNamespace)
	{
		try
		{
			_runScript(view,path,in,ownNamespace);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);

			handleException(view,path,e);
		}
	} 

	
	
	public static void _runScript(View view, String path, Reader in,
		boolean ownNamespace) throws Exception
	{
		Log.log(Log.MESSAGE,BeanShell.class,""Running script "" + path);

		NameSpace namespace;
		if(ownNamespace)
			namespace = new NameSpace(global,""script namespace"");
		else
			namespace = global;

		Interpreter interp = createInterpreter(namespace);

		VFS vfs = null;
		Object session = null;

		try
		{
			if(in == null)
			{
				Buffer buffer = jEdit.getBuffer(path);

				vfs = VFSManager.getVFSForPath(path);
				session = vfs.createVFSSession(path,view);
				if(session == null)
				{
					
					return;
				}

				if(buffer != null)
				{
					if(!buffer.isLoaded())
						VFSManager.waitForRequests();

					in = new StringReader(buffer.getText(0,
						buffer.getLength()));
				}
				else
				{
					in = new BufferedReader(new InputStreamReader(
						vfs._createInputStream(session,
						path,false,view)));
				}
			}

			if(view != null)
			{
				EditPane editPane = view.getEditPane();
				interp.set(""view"",view);
				interp.set(""editPane"",editPane);
				interp.set(""buffer"",editPane.getBuffer());
				interp.set(""textArea"",editPane.getTextArea());
			}

			running = true;

			interp.eval(in,namespace,path);
		}
		catch(Exception e)
		{
			unwrapException(e);
		}
		finally
		{
			running = false;

			if(session != null)
			{
				try
				{
					vfs._endVFSSession(session,view);
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,BeanShell.class,io);
					GUIUtilities.error(view,""read-error"",
						new String[] { path, io.toString() });
				}
			}
		}
	} 

	
	
	public static Object eval(View view, NameSpace namespace, String command)
	{
		try
		{
			return _eval(view,namespace,command);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);

			handleException(view,null,e);
		}

		return null;
	} 

	
	
	public static Object _eval(View view, NameSpace namespace, String command)
		throws Exception
	{
		Interpreter interp = createInterpreter(namespace);

		try
		{
			if(view != null)
			{
				EditPane editPane = view.getEditPane();
				interp.set(""view"",view);
				interp.set(""editPane"",editPane);
				interp.set(""buffer"",editPane.getBuffer());
				interp.set(""textArea"",editPane.getTextArea());
			}

			return interp.eval(command);
		}
		catch(Exception e)
		{
			unwrapException(e);
			
			return null;
		}
	} 

	
	
	public static String cacheBlock(String id, String code,
		boolean childNamespace) throws Exception
	{
		String name;
		if(id == null)
			name = ""b_"" + (cachedBlockCounter++);
		else
			name = ""b_"" + id;

		code = ""setNameSpace(__cruft.namespace);\n""
			+ name
			+ ""(ns) {\n""
			+ ""setNameSpace(ns);""
			+ code
			+ ""\n}"";

		_eval(null,global,code);

		return name;
	} 

	
	
	public static Object runCachedBlock(String id, View view, NameSpace namespace)
		throws Exception
	{
		if(namespace == null)
			namespace = global;

		Object[] args = { namespace };

		try
		{
			if(view != null)
			{
				namespace.setVariable(""view"",view);
				EditPane editPane = view.getEditPane();
				namespace.setVariable(""editPane"",editPane);
				namespace.setVariable(""buffer"",editPane.getBuffer());
				namespace.setVariable(""textArea"",editPane.getTextArea());
			}

			Object retVal = internal.invokeMethod(id,args,interpForMethods);
			if(retVal instanceof Primitive)
			{
				if(retVal == Primitive.VOID)
					return null;
				else
					return ((Primitive)retVal).getValue();
			}
			else
				return retVal;
		}
		catch(Exception e)
		{
			unwrapException(e);
			
			return null;
		}
		finally
		{
			try
			{
				namespace.setVariable(""view"",null);
				namespace.setVariable(""editPane"",null);
				namespace.setVariable(""buffer"",null);
				namespace.setVariable(""textArea"",null);
			}
			catch(EvalError e)
			{
				
			}
		}
	} 

	
	
	public static boolean isScriptRunning()
	{
		return running;
	} 

	
	
	public static NameSpace getNameSpace()
	{
		return global;
	} 

	

	
	
	public static void runScript(View view, String path,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		runScript(view,path,null,ownNamespace);
	} 

	
	
	public static void runScript(View view, String path, Reader in,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		runScript(view,path,in,ownNamespace);
	} 

	
	
	public static Object eval(View view, String command,
		boolean rethrowBshErrors)
	{
		return eval(view,global,command);
	} 

	
	
	public static Object eval(View view, NameSpace namespace,
		String command, boolean rethrowBshErrors)
	{
		return eval(view,namespace,command);
	} 

	

	

	
	static void init()
	{
		BshClassManager.setClassLoader(new JARClassLoader());

		global = new NameSpace(""jEdit embedded BeanShell interpreter"");
		global.importPackage(""org.gjt.sp.jedit"");
		global.importPackage(""org.gjt.sp.jedit.browser"");
		global.importPackage(""org.gjt.sp.jedit.gui"");
		global.importPackage(""org.gjt.sp.jedit.io"");
		global.importPackage(""org.gjt.sp.jedit.msg"");
		global.importPackage(""org.gjt.sp.jedit.options"");
		global.importPackage(""org.gjt.sp.jedit.pluginmgr"");
		global.importPackage(""org.gjt.sp.jedit.print"");
		global.importPackage(""org.gjt.sp.jedit.search"");
		global.importPackage(""org.gjt.sp.jedit.syntax"");
		global.importPackage(""org.gjt.sp.jedit.textarea"");
		global.importPackage(""org.gjt.sp.util"");

		interpForMethods = createInterpreter(global);

		internal = (NameSpace)eval(null,""__cruft = object();__cruft.namespace;"",false);

		Log.log(Log.DEBUG,BeanShell.class,""BeanShell interpreter version ""
			+ Interpreter.VERSION);
	} 

	

	

	
	private static Interpreter interpForMethods;
	private static NameSpace global;
	private static NameSpace internal;
	private static boolean running;
	private static int cachedBlockCounter;
	

	
	
	private static void unwrapException(Exception e) throws Exception
	{
		if(e instanceof TargetError)
		{
			Throwable t = ((TargetError)e).getTarget();
			if(t instanceof Exception)
				throw (Exception)t;
			else if(t instanceof Error)
				throw (Error)t;
		}

		if(e instanceof InvocationTargetException)
		{
			Throwable t = ((InvocationTargetException)e).getTargetException();
			if(t instanceof Exception)
				throw (Exception)t;
			else if(t instanceof Error)
				throw (Error)t;
		}

		throw e;
	} 

	
	private static void handleException(View view, String path, Throwable t)
	{
		if(t instanceof IOException)
		{
			VFSManager.error(view,path,""ioerror.read-error"",
				new String[] { t.toString() });
		}
		else
			new BeanShellErrorDialog(view,t.toString());
	} 

	
	private static Interpreter createInterpreter(NameSpace nameSpace)
	{
		return new Interpreter(null,System.out,System.err,false,nameSpace);
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.msg.EditPaneUpdate,5,3,0,6,13,4,3,4,4,0.875,50,0.25,0,0.666666667,0.5,1,1,8.2,1,0.6,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;


public class EditPaneUpdate extends EBMessage.NonVetoable
{
	
	public static final Object CREATED = ""CREATED"";

	
	public static final Object DESTROYED = ""DESTROYED"";

	
	public static final Object BUFFER_CHANGED = ""BUFFER_CHANGED"";

	
	public EditPaneUpdate(EditPane editPane, Object what)
	{
		super(editPane);

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
	}

	
	public Object getWhat()
	{
		return what;
	}

	
	public EditPane getEditPane()
	{
		return (EditPane)getSource();
	}

	public String paramString()
	{
		return super.paramString() + "",what="" + what;
	}

	
	private Object what;
}
"
jEdit,4,org.gjt.sp.jedit.buffer.UndoManager,13,1,0,8,31,14,6,7,11,0.666666667,485,1.0,3,0.0,0.230769231,0,0,35.69230769,11,3.3077,3,"

package org.gjt.sp.jedit.buffer;


import java.util.ArrayList;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;


public class UndoManager
{
	
	public UndoManager(Buffer buffer)
	{
		this.buffer = buffer;
		undos = new ArrayList(100);
	} 

	
	public void setLimit(int limit)
	{
		this.limit = limit;
	} 

	
	public void clear()
	{
		undos.clear();
		undoPos = undoCount = 0;
	} 

	
	public boolean undo(JEditTextArea textArea)
	{
		if(insideCompoundEdit())
			throw new InternalError(""Unbalanced begin/endCompoundEdit()"");

		if(undoPos == 0)
			return false;
		else
		{
			Edit edit = (Edit)undos.get(--undoPos);
			int caret = edit.undo();
			if(caret != -1)
				textArea.setCaretPosition(caret);
			return true;
		}
	} 

	
	public boolean redo(JEditTextArea textArea)
	{
		if(insideCompoundEdit())
			throw new InternalError(""Unbalanced begin/endCompoundEdit()"");

		if(undoPos == undoCount)
			return false;
		else
		{
			Edit edit = (Edit)undos.get(undoPos++);
			int caret = edit.redo();
			if(caret != -1)
				textArea.setCaretPosition(caret);
			return true;
		}
	} 

	
	public void beginCompoundEdit()
	{
		if(compoundEditCount == 0)
			compoundEdit = new CompoundEdit();

		compoundEditCount++;
	} 

	
	public void endCompoundEdit()
	{
		if(compoundEditCount == 0)
		{
			Log.log(Log.WARNING,this,new Exception(""Unbalanced begin/endCompoundEdit()""));
			return;
		}
		else if(compoundEditCount == 1)
		{
			switch(compoundEdit.undos.size())
			{
			case 0:
				;
				break;
			case 1:
				addEdit((Edit)compoundEdit.undos.get(0));
				break;
			default:
				addEdit(compoundEdit);
			}

			compoundEdit = null;
		}

		compoundEditCount--;
	} 

	
	public boolean insideCompoundEdit()
	{
		return compoundEditCount != 0;
	} 

	
	public void contentInserted(int offset, int length, String text, boolean clearDirty)
	{
		Edit toMerge = null;
		if(compoundEdit != null)
		{
			int size = compoundEdit.undos.size();
			if(size != 0)
				toMerge = (Edit)compoundEdit.undos.get(size - 1);
		}
		else
		{
			if(undoPos != 0)
				toMerge = (Edit)undos.get(undoPos - 1);
		}

		if(!clearDirty && toMerge instanceof Insert)
		{
			Insert ins = (Insert)toMerge;
			if(ins.offset == offset)
			{
				ins.str = text.concat(ins.str);
				ins.length += length;
				return;
			}
			else if(ins.offset + ins.length == offset)
			{
				ins.str = ins.str.concat(text);
				ins.length += length;
				return;
			}
		}

		Insert ins = new Insert(offset,length,text,clearDirty);
		if(clearDirty)
		{
			if(clearDirtyEdit != null)
				clearDirtyEdit.clearDirty = false;
			clearDirtyEdit = ins;
		}

		if(compoundEdit != null)
			compoundEdit.undos.add(ins);
		else
			addEdit(ins);
	} 

	
	public void contentRemoved(int offset, int length, String text, boolean clearDirty)
	{
		Edit toMerge = null;
		if(compoundEdit != null)
		{
			int size = compoundEdit.undos.size();
			if(size != 0)
				toMerge = (Edit)compoundEdit.undos.get(size - 1);
		}
		else
		{
			if(undoPos != 0)
				toMerge = (Edit)undos.get(undoPos - 1);
		}

		if(!clearDirty && toMerge instanceof Remove)
		{
			Remove rem = (Remove)toMerge;
			if(rem.offset == offset)
			{
				rem.str = rem.str.concat(text);
				rem.length += length;
				return;
			}
			else if(rem.offset + rem.length == offset)
			{
				rem.str = text.concat(rem.str);
				rem.length += length;
				return;
			}
			else if(offset + length == rem.offset)
			{
				rem.str = text.concat(rem.str);
				rem.length += length;
				rem.offset = offset;
				return;
			}
		}

		Remove rem = new Remove(offset,length,text,clearDirty);
		if(clearDirty)
		{
			if(clearDirtyEdit != null)
				clearDirtyEdit.clearDirty = false;
			clearDirtyEdit = rem;
		}

		if(compoundEdit != null)
			compoundEdit.undos.add(rem);
		else
			addEdit(rem);
	} 

	
	public void bufferSaved()
	{
		if(clearDirtyEdit != null)
		{
			clearDirtyEdit.clearDirty = false;
			clearDirtyEdit = null;
		}
	} 

	

	
	private Buffer buffer;
	private ArrayList undos;
	private int limit;
	private int undoPos;
	private int undoCount;
	private int compoundEditCount;
	private CompoundEdit compoundEdit;
	private Edit clearDirtyEdit;
	

	
	private void addEdit(Edit edit)
	{
		undos.add(undoPos++,edit);

		if(undos.size() > limit)
		{
			undos.remove(0);
			undoPos--;
		}

		undoCount = undoPos;
	} 

	

	

	
	abstract class Edit
	{
		
		abstract int undo();
		

		
		abstract int redo();
		

		boolean clearDirty;
	} 

	
	class Insert extends Edit
	{
		
		Insert(int offset, int length, String str, boolean clearDirty)
		{
			this.offset = offset;
			this.length = length;
			this.str = str;
			this.clearDirty = clearDirty;
		} 

		
		int undo()
		{
			buffer.remove(offset,length);
			if(clearDirty)
				buffer.setDirty(false);
			return offset;
		} 

		
		int redo()
		{
			buffer.insert(offset,str);
			return offset + length;
		} 

		int offset;
		int length;
		String str;
	} 

	
	class Remove extends Edit
	{
		
		Remove(int offset, int length, String str, boolean clearDirty)
		{
			this.offset = offset;
			this.length = length;
			this.str = str;
			this.clearDirty = clearDirty;
		} 

		
		int undo()
		{
			buffer.insert(offset,str);
			if(clearDirty)
				buffer.setDirty(false);
			return offset + length;
		} 

		
		int redo()
		{
			buffer.remove(offset,length);
			return offset;
		} 

		int offset;
		int length;
		String str;
	} 

	
	class CompoundEdit extends Edit
	{
		
		public int undo()
		{
			int retVal = -1;
			for(int i = undos.size() - 1; i >= 0; i--)
			{
				retVal = ((Edit)undos.get(i)).undo();
			}
			return retVal;
		} 

		
		public int redo()
		{
			int retVal = -1;
			for(int i = 0; i < undos.size(); i++)
			{
				retVal = ((Edit)undos.get(i)).redo();
			}
			return retVal;
		} 

		ArrayList undos = new ArrayList();
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.EditAction,12,1,4,28,18,54,27,3,12,0.727272727,49,1.0,0,0.0,0.3125,0,0,3.0,1,0.9167,2,"

package org.gjt.sp.jedit;


import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.Component;
import org.gjt.sp.util.Log;



public abstract class EditAction
{
	
	
	public EditAction(String name)
	{
		this.name = name;
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public String getLabel()
	{
		return jEdit.getProperty(name + "".label"");
	} 

	
	
	public String getMouseOverText()
	{
		return null;
	} 

	
	
	public abstract void invoke(View view);
	

	
	
	public static View getView(Component comp)
	{
		
		return GUIUtilities.getView(comp);
	} 

	
	
	public boolean isToggle()
	{
		return false;
	} 

	
	
	public boolean isSelected(View view)
	{
		return false;
	} 

	
	
	public boolean noRepeat()
	{
		return false;
	} 

	
	
	public boolean noRecord()
	{
		return false;
	} 

	
	
	public abstract String getCode();
	

	
	public String toString()
	{
		return name;
	} 

	
	private String name;
	

	
	
	public static class Wrapper implements ActionListener
	{
		public Wrapper(EditAction action)
		{
			this.action = action;
		}

		
		public void actionPerformed(ActionEvent evt)
		{
			
			GUIUtilities.getView((Component)evt.getSource())
				.getInputHandler().invokeAction(action);
		}

		private EditAction action;
	} 
}
"
jEdit,4,org.gjt.sp.jedit.EditServer,6,2,0,8,54,7,3,7,3,0.75,336,1.0,0,0.924242424,0.305555556,0,0,54.33333333,12,3.6667,2,"

package org.gjt.sp.jedit;


import javax.swing.SwingUtilities;
import java.io.*;
import java.net.*;
import java.util.Random;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.util.Log;



public class EditServer extends Thread
{
	
	EditServer(String portFile)
	{
		super(""jEdit server daemon ["" + portFile + ""]"");
		setDaemon(true);
		this.portFile = portFile;

		try
		{
			
			
			
			
			
			if(OperatingSystem.isUnix())
			{
				new File(portFile).createNewFile();
				FileVFS.setPermissions(portFile,0600);
			}

			
			
			socket = new ServerSocket(0, 2,
				InetAddress.getByName(""127.0.0.1""));
			authKey = Math.abs(new Random().nextInt());
			int port = socket.getLocalPort();

			FileWriter out = new FileWriter(portFile);
			out.write(""b\n"");
			out.write(String.valueOf(port));
			out.write(""\n"");
			out.write(String.valueOf(authKey));
			out.write(""\n"");
			out.close();

			Log.log(Log.DEBUG,this,""jEdit server started on port ""
				+ socket.getLocalPort());
			Log.log(Log.DEBUG,this,""Authorization key is ""
				+ authKey);

			ok = true;
		}
		catch(IOException io)
		{
			
			Log.log(Log.NOTICE,this,io);
		}
	} 

	
	public boolean isOK()
	{
		return ok;
	} 

	
	public void run()
	{
		boolean abort = false;

		for(;;)
		{
			if(abort)
				return;

			Socket client = null;
			try
			{
				client = socket.accept();

				
				
				
				client.setSoTimeout(1000);

				Log.log(Log.MESSAGE,this,client + "": connected"");

				DataInputStream in = new DataInputStream(
					client.getInputStream());

				if(!handleClient(client,in))
					abort = true;
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
				abort = true;
			}
			finally
			{
				if(client != null)
				{
					try
					{
						client.close();
					}
					catch(Exception e)
					{
						Log.log(Log.ERROR,this,e);
					}

					client = null;
				}
			}
		}
	} 

	
	
	public static void handleClient(boolean restore, String parent,
		String[] args)
	{
		String splitConfig = null;

		boolean newView = jEdit.getBooleanProperty(""client.newView"");

		
		if(jEdit.getFirstView() == null || newView)
		{
			
			
			

			Buffer buffer = jEdit.openFiles(null,parent,args);

			if(restore)
			{
				if(jEdit.getFirstBuffer() == null
					|| (jEdit.getFirstBuffer().isUntitled()
					&& jEdit.getBufferCount() == 1))
					splitConfig = jEdit.restoreOpenFiles();
				else if(jEdit.getBooleanProperty(""restore.cli""))
				{
					
					jEdit.restoreOpenFiles();
				}
			}

			
			
			if(jEdit.getFirstBuffer() == null
					|| (jEdit.getFirstBuffer().isUntitled()
                                        && jEdit.getBufferCount() == 1))
				buffer = jEdit.newFile(null);

			if(splitConfig != null)
				jEdit.newView(null,splitConfig);
			else
				jEdit.newView(null,buffer);
		}
		else
		{
			
			View view = jEdit.getFirstView();

			jEdit.openFiles(view,parent,args);

			
			view.setState(java.awt.Frame.NORMAL);
			view.requestFocus();
			view.toFront();

			
			return;
		}
	} 

	
	void stopServer()
	{
		stop();
		new File(portFile).delete();
	} 

	

	
	private String portFile;
	private ServerSocket socket;
	private int authKey;
	private boolean ok;
	

	
	private boolean handleClient(Socket client, DataInputStream in)
		throws Exception
	{
		int key = in.readInt();
		if(key != authKey)
		{
			Log.log(Log.ERROR,this,client + "": wrong""
				+ "" authorization key (got "" + key
				+ "", expected "" + authKey + "")"");
			in.close();
			client.close();

			return false;
		}
		else
		{
			
			client.setSoTimeout(0);

			Log.log(Log.DEBUG,this,client + "": authenticated""
				+ "" successfully"");

			final String script = in.readUTF();
			Log.log(Log.DEBUG,this,script);

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					BeanShell.eval(null,BeanShell.getNameSpace(),
						script);
				}
			});

			return true;
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.msg.MacrosChanged,1,3,0,4,2,0,2,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class MacrosChanged extends EBMessage.NonVetoable
{
	
	public MacrosChanged(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4,org.gjt.sp.jedit.search.CharIndexedSegment,4,1,0,3,5,0,2,1,3,0.111111111,94,1.0,0,0.0,0.5,0,0,21.75,4,2.5,0,"
package org.gjt.sp.jedit.search;


import java.io.Serializable;
import javax.swing.text.Segment;
import gnu.regexp.*;
 

public class CharIndexedSegment implements CharIndexed, Serializable
{
	
	CharIndexedSegment(Segment seg, boolean reverse)
	{
		this.seg = seg;
		m_index = (reverse ? seg.count - 1 : 0);
		this.reverse = reverse;
	} 

	
	public char charAt(int index)
	{
		if(reverse)
			index = -index;

		return ((m_index + index) < seg.count && m_index + index >= 0)
			? seg.array[seg.offset + m_index + index]
			: CharIndexed.OUT_OF_BOUNDS;
	} 

	
	public boolean isValid()
	{
		return (m_index >=0 && m_index < seg.count);
	} 

	
	public boolean move(int index)
	{
		if(reverse)
			index = -index;

		return ((m_index += index) < seg.count);
	} 

	
	private Segment seg;
	private int m_index;
	private boolean reverse;
	
}
"
jEdit,4,org.gjt.sp.jedit.pluginmgr.PluginManagerProgress,19,6,0,14,64,125,13,9,8,0.916666667,342,1.0,1,0.97309417,0.203947368,3,6,16.47368421,3,1.0526,1,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public class PluginManagerProgress extends JDialog
{
	
	public PluginManagerProgress(JDialog dialog, String type, Roster roster)
	{
		super(JOptionPane.getFrameForComponent(dialog),
			jEdit.getProperty(""plugin-manager.progress.""
			+ type + ""-task""),true);

		this.dialog = dialog;
		this.roster = roster;
		this.type = type;

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		globalProgress = new JProgressBar();
		globalProgress.setStringPainted(true);
		globalProgress.setString(jEdit.getProperty(""plugin-manager.progress.""
			+ type + ""-task""));

		count = roster.getOperationCount();

		globalProgress.setMaximum(count);
		content.add(BorderLayout.NORTH,globalProgress);

		localProgress = new JProgressBar();
		localProgress.setStringPainted(true);
		content.add(BorderLayout.CENTER,localProgress);

		stop = new JButton(jEdit.getProperty(""plugin-manager.progress.stop""));
		stop.addActionListener(new ActionHandler());
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.add(Box.createGlue());
		panel.add(stop);
		panel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,panel);

		addWindowListener(new WindowHandler());

		pack();

		Dimension screen = getToolkit().getScreenSize();
		Dimension size = getSize();
		size.width = Math.max(size.width,500);
		setSize(size);
		setLocationRelativeTo(dialog);

		show();
	} 

	
	public void removing(String plugin)
	{
		String[] args = { plugin };
		showMessage(jEdit.getProperty(""plugin-manager.progress.removing"",args));
		stop.setEnabled(true);
	} 

	
	public void downloading(String plugin)
	{
		String[] args = { plugin };
		showMessage(jEdit.getProperty(""plugin-manager.progress.downloading"",args));
		stop.setEnabled(true);
	} 

	
	public void installing(String plugin)
	{
		String[] args = { plugin };
		showMessage(jEdit.getProperty(""plugin-manager.progress.installing"",args));
		stop.setEnabled(false);
	} 

	
	public void setMaximum(final int total)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				localProgress.setMaximum(total);
			}
		});
	} 

	
	public void setValue(final int value)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				localProgress.setValue(value);
			}
		});
	} 

	
	public void done(final boolean ok)
	{
		this.ok |= ok;

		try
		{
			if(!ok || done == count)
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						dispose();
						if(ok)
						{
							GUIUtilities.message(dialog,
								""plugin-manager."" + type
								+ ""-done"",null);
						}
						else
						{
							

							
							
						}
					}
				});
			}
			else
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						globalProgress.setValue(done++);
						localProgress.setValue(0);
					}
				});
			}
		}
		catch(Exception e)
		{
		}
	} 

	
	public boolean isOK()
	{
		return ok;
	} 

	

	
	private JDialog dialog;

	private Thread thread;

	private String type;

	private JProgressBar globalProgress, localProgress;
	private JButton stop;
	private int count;
	private int done = 1;

	private boolean ok;

	private Roster roster;
	

	
	private void showMessage(final String msg)
	{
		try
		{
			SwingUtilities.invokeAndWait(new Runnable()
			{
				public void run()
				{
					localProgress.setString(msg);
				}
			});
		}
		catch(Exception e)
		{
		}

		Thread.yield();
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == stop)
			{
				thread.stop();
				dispose();
			}
		}
	} 

	
	class WindowHandler extends WindowAdapter
	{
		boolean done;

		public void windowOpened(WindowEvent evt)
		{
			if(done)
				return;

			done = true;
			thread = new RosterThread();
			thread.start();
		}

		public void windowClosing(WindowEvent evt)
		{
			thread.stop();
			dispose();
		}
	} 

	
	class RosterThread extends Thread
	{
		RosterThread()
		{
			super(""Plugin manager thread"");
		}

		public void run()
		{
			roster.performOperations(PluginManagerProgress.this);
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.AddAbbrevDialog,5,6,0,7,32,2,3,6,1,0.8,202,1.0,2,0.99389313,0.35,0,0,38.4,1,0.8,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;

public class AddAbbrevDialog extends JDialog
{
	public AddAbbrevDialog(View view, String abbrev)
	{
		super(view,jEdit.getProperty(""add-abbrev.title""),true);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		editor = new AbbrevEditor();
		editor.setAbbrev(abbrev);
		editor.setBorder(new EmptyBorder(6,0,12,0));
		content.add(BorderLayout.CENTER,editor);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		global = new JButton(jEdit.getProperty(""add-abbrev.global""));
		global.addActionListener(new ActionHandler());
		box.add(global);
		box.add(Box.createHorizontalStrut(6));
		modeSpecific = new JButton(jEdit.getProperty(""add-abbrev.mode""));
		modeSpecific.addActionListener(new ActionHandler());
		box.add(modeSpecific);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);

		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		if(abbrev == null)
			GUIUtilities.requestFocus(this,editor.getAbbrevField());
		else
			GUIUtilities.requestFocus(this,editor.getBeforeCaretTextArea());

		pack();
		setLocationRelativeTo(view);
		show();
	}

	
	private View view;
	private AbbrevEditor editor;
	private JButton global;
	private JButton modeSpecific;
	private JButton cancel;

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == global)
			{
				String _abbrev = editor.getAbbrev();
				if(_abbrev == null || _abbrev.length() == 0)
				{
					getToolkit().beep();
					return;
				}
				Abbrevs.addGlobalAbbrev(_abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}
			else if(source == modeSpecific)
			{
				String _abbrev = editor.getAbbrev();
				if(_abbrev == null || _abbrev.length() == 0)
				{
					getToolkit().beep();
					return;
				}
				Abbrevs.addModeAbbrev(view.getBuffer().getMode().getName(),
					_abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}

			dispose();
		}
	}

	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.options.AppearanceOptionPane,5,6,0,6,34,4,2,5,1,0.464285714,239,1.0,2,0.993993994,0.5,2,4,45.4,4,1.8,1,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class AppearanceOptionPane extends AbstractOptionPane
{
	
	public AppearanceOptionPane()
	{
		super(""appearance"");
	} 

	
	protected void _init()
	{
		
		addComponent(new JLabel(jEdit.getProperty(""options.appearance.lf.note"")));

		lfs = UIManager.getInstalledLookAndFeels();
		String[] names = new String[lfs.length];
		String lf = UIManager.getLookAndFeel().getClass().getName();
		int index = 0;
		for(int i = 0; i < names.length; i++)
		{
			names[i] = lfs[i].getName();
			if(lf.equals(lfs[i].getClassName()))
				index = i;
		}

		lookAndFeel = new JComboBox(names);
		lookAndFeel.setSelectedIndex(index);
		lookAndFeel.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				updateEnabled();
			}
		});

		addComponent(jEdit.getProperty(""options.appearance.lf""),
			lookAndFeel);

		
		primaryFont = new FontSelector(jEdit.getFontProperty(
			""metal.primary.font""));
		addComponent(jEdit.getProperty(""options.appearance.primaryFont""),
			primaryFont);

		
		secondaryFont = new FontSelector(jEdit.getFontProperty(
			""metal.secondary.font""));
		addComponent(jEdit.getProperty(""options.appearance.secondaryFont""),
			secondaryFont);

		updateEnabled();

		
		textColors = new JCheckBox(jEdit.getProperty(
			""options.appearance.textColors""));
		textColors.setSelected(jEdit.getBooleanProperty(""textColors""));
		addComponent(textColors);

		
		decorateFrames = new JCheckBox(jEdit.getProperty(
			""options.appearance.decorateFrames""));
		decorateFrames.setSelected(jEdit.getBooleanProperty(""decorate.frames""));

		
		decorateDialogs = new JCheckBox(jEdit.getProperty(
			""options.appearance.decorateDialogs""));
		decorateDialogs.setSelected(jEdit.getBooleanProperty(""decorate.dialogs""));

		if(OperatingSystem.hasJava14())
		{
			addComponent(decorateFrames);
			addComponent(decorateDialogs);
		}
	} 

	
	protected void _save()
	{
		String lf = lfs[lookAndFeel.getSelectedIndex()].getClassName();
		jEdit.setProperty(""lookAndFeel"",lf);
		jEdit.setFontProperty(""metal.primary.font"",primaryFont.getFont());
		jEdit.setFontProperty(""metal.secondary.font"",secondaryFont.getFont());
		jEdit.setBooleanProperty(""textColors"",textColors.isSelected());
		jEdit.setBooleanProperty(""decorate.frames"",decorateFrames.isSelected());
		jEdit.setBooleanProperty(""decorate.dialogs"",decorateDialogs.isSelected());
	} 

	

	
	private UIManager.LookAndFeelInfo[] lfs;
	private JComboBox lookAndFeel;
	private FontSelector primaryFont;
	private FontSelector secondaryFont;
	private JCheckBox textColors;
	private JCheckBox decorateFrames;
	private JCheckBox decorateDialogs;
	

	
	private void updateEnabled()
	{
		String className = lfs[lookAndFeel.getSelectedIndex()]
			.getClassName();

		if(className.equals(""javax.swing.plaf.metal.MetalLookAndFeel"")
			|| className.equals(""com.incors.plaf.kunststoff.KunststoffLookAndFeel""))
		{
			primaryFont.setEnabled(true);
			secondaryFont.setEnabled(true);
		}
		else
		{
			primaryFont.setEnabled(false);
			secondaryFont.setEnabled(false);
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.RecentFilesMenu,2,8,0,14,28,1,3,14,2,2.0,133,0.0,0,0.998835856,0.75,2,3,65.5,8,4.0,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.browser.FileCellRenderer;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.*;


public class RecentFilesMenu extends EnhancedMenu
{
	
	public RecentFilesMenu()
	{
		super(""recent-files"");
	} 

	
	public void setPopupMenuVisible(boolean b)
	{
		if(b)
		{
			final View view = GUIUtilities.getView(this);

			if(getMenuComponentCount() != 0)
				removeAll();

			
			ActionListener actionListener = new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					jEdit.openFile(view,evt.getActionCommand());
					view.getStatus().setMessage(null);
				}
			}; 

			
			MouseListener mouseListener = new MouseAdapter()
			{
				public void mouseEntered(MouseEvent evt)
				{
					view.getStatus().setMessage(
						((JMenuItem)evt.getSource())
						.getActionCommand());
				}

				public void mouseExited(MouseEvent evt)
				{
					view.getStatus().setMessage(null);
				}
			}; 

			Vector recentVector = BufferHistory.getBufferHistory();

			if(recentVector.size() == 0)
			{
				add(GUIUtilities.loadMenuItem(""no-recent-files""));
				super.setPopupMenuVisible(b);
				return;
			}

			Vector menuItems = new Vector();
			boolean sort = jEdit.getBooleanProperty(""sortRecent"");

			
			int recentFileCount = Math.min(recentVector.size(),
				jEdit.getIntegerProperty(""history"",25));

			for(int i = recentVector.size() - 1;
				i >= recentVector.size() - recentFileCount;
				i--)
			{
				String path = ((BufferHistory.Entry)recentVector
					.elementAt(i)).path;
				VFS vfs = VFSManager.getVFSForPath(path);
				JMenuItem menuItem = new JMenuItem(vfs.getFileName(path));
				menuItem.setActionCommand(path);
				menuItem.addActionListener(actionListener);
				menuItem.addMouseListener(mouseListener);
				menuItem.setIcon(FileCellRenderer.fileIcon);

				if(sort)
					menuItems.addElement(menuItem);
				else
					add(menuItem);
			}

			if(sort)
			{
				MiscUtilities.quicksort(menuItems,
					new MiscUtilities.MenuItemCompare());
				for(int i = 0; i < menuItems.size(); i++)
				{
					add((JMenuItem)menuItems.elementAt(i));
				}
			}
		}

		super.setPopupMenuVisible(b);
	} 
}
"
jEdit,4,org.gjt.sp.jedit.proto.jeditresource.Handler,2,2,0,1,5,1,0,1,2,2.0,14,0.0,0,0.923076923,0.75,0,0,6.0,1,0.5,0,"

package org.gjt.sp.jedit.proto.jeditresource;

import java.io.IOException;
import java.net.*;

public class Handler extends URLStreamHandler
{
	public URLConnection openConnection(URL url)
		throws IOException
	{
		PluginResURLConnection c = new PluginResURLConnection(url);
		c.connect();
		return c;
	}
}
"
jEdit,4,org.gjt.sp.jedit.options.BrowserOptionPane,3,6,0,3,17,1,1,2,3,0.5,307,1.0,0,0.996987952,1.0,2,4,98.0,5,2.0,1,"

package org.gjt.sp.jedit.options;


import javax.swing.table.*;
import javax.swing.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;


public class BrowserOptionPane extends AbstractOptionPane
{
	
	public BrowserOptionPane()
	{
		super(""browser.general"");
	} 

	
	public void _init()
	{
		
		String[] dirs = {
			jEdit.getProperty(""options.browser.general.defaultPath.buffer""),
			jEdit.getProperty(""options.browser.general.defaultPath.home""),
			jEdit.getProperty(""options.browser.general.defaultPath.favorites""),
			jEdit.getProperty(""options.browser.general.defaultPath.last"")
		};

		defaultDirectory = new JComboBox(dirs);
		String defaultDir = jEdit.getProperty(""vfs.browser.defaultPath"");
		if(""buffer"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(0);
		else if(""home"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(1);
		else if(""favorites"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(2);
		else if(""last"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(3);
		addComponent(jEdit.getProperty(""options.browser.general.defaultPath""),
			defaultDirectory);

		
		showToolbar = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showToolbar""));
		showToolbar.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showToolbar""));
		addComponent(showToolbar);

		
		showIcons = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showIcons""));
		showIcons.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showIcons""));
		addComponent(showIcons);

		
		showHiddenFiles = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showHiddenFiles""));
		showHiddenFiles.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showHiddenFiles""));
		addComponent(showHiddenFiles);

		
		sortFiles = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.sortFiles""));
		sortFiles.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortFiles""));
		addComponent(sortFiles);

		
		sortIgnoreCase = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.sortIgnoreCase""));
		sortIgnoreCase.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortIgnoreCase""));
		addComponent(sortIgnoreCase);

		
		sortMixFilesAndDirs = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.sortMixFilesAndDirs""));
		sortMixFilesAndDirs.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortMixFilesAndDirs""));
		addComponent(sortMixFilesAndDirs);

		
		doubleClickClose = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.doubleClickClose""));
		doubleClickClose.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".doubleClickClose""));
		addComponent(doubleClickClose);

		
		currentBufferFilter = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.currentBufferFilter""));
		currentBufferFilter.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".currentBufferFilter""));
		addComponent(currentBufferFilter);

		
		splitHorizontally = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.splitHorizontally""));
		splitHorizontally.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".splitHorizontally""));
		addComponent(splitHorizontally);
	} 

	
	public void _save()
	{
		String[] dirs = { ""buffer"", ""home"", ""favorites"", ""last"" };
		jEdit.setProperty(""vfs.browser.defaultPath"",dirs[defaultDirectory
			.getSelectedIndex()]);
		jEdit.setBooleanProperty(""vfs.browser.showToolbar"",
			showToolbar.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showIcons"",
			showIcons.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showHiddenFiles"",
			showHiddenFiles.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortFiles"",
			sortFiles.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortIgnoreCase"",
			sortIgnoreCase.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortMixFilesAndDirs"",
			sortMixFilesAndDirs.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.doubleClickClose"",
			doubleClickClose.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.currentBufferFilter"",
			currentBufferFilter.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.splitHorizontally"",
			splitHorizontally.isSelected());
	} 

	
	private JComboBox defaultDirectory;
	private JCheckBox showToolbar;
	private JCheckBox showIcons;
	private JCheckBox showHiddenFiles;
	private JCheckBox sortFiles;
	private JCheckBox sortIgnoreCase;
	private JCheckBox sortMixFilesAndDirs;
	private JCheckBox doubleClickClose;
	private JCheckBox currentBufferFilter;
	private JCheckBox splitHorizontally;
	
}
"
jEdit,4,org.gjt.sp.jedit.buffer.FoldHandler,9,1,3,10,25,22,9,5,6,0.583333333,121,1.0,0,0.0,0.208333333,0,0,12.11111111,3,1.3333,0,"

package org.gjt.sp.jedit.buffer;

import java.util.*;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;


public abstract class FoldHandler
{
	
	
	public String getName()
	{
		return name;
	}
	

	
	
	public abstract int getFoldLevel(Buffer buffer, int lineIndex, Segment seg);
	

	
	
	public static void registerFoldHandler(FoldHandler handler)
	{
		if (getFoldHandler(handler.getName()) != null)
		{
			Log.log(Log.ERROR, FoldHandler.class, ""Cannot register more than one fold handler with the same name"");
			return;
		}

		foldHandlers.add(handler);
	}
	

	
	
	public static FoldHandler[] getFoldHandlers()
	{
		FoldHandler[] handlers = new FoldHandler[foldHandlers.size()];
		return (FoldHandler[])foldHandlers.toArray(handlers);
	}
	

	
	
	public static FoldHandler getFoldHandler(String name)
	{
		FoldHandler handler;

		Iterator i = foldHandlers.iterator();
		while (i.hasNext())
		{
			handler = (FoldHandler)i.next();
			if (name.equals(handler.getName())) return handler;
		}

		return null;
	}
	

	
	
	public static String[] getFoldModes()
	{
		FoldHandler[] handlers = getFoldHandlers();
		String[] foldModes = new String[handlers.length];

		for (int i = 0; i < foldModes.length; i++)
		{
			foldModes[i] = handlers[i].getName();
		}

		return foldModes;
	}
	

	
	protected FoldHandler(String name)
	{
		this.name = name;
	}
	

	
	private String name;

	private static ArrayList foldHandlers;
	

	
	static
	{
		foldHandlers = new ArrayList();
		registerFoldHandler(new DummyFoldHandler());
		registerFoldHandler(new IndentFoldHandler());
		registerFoldHandler(new ExplicitFoldHandler());
	}
	
}
"
jEdit,4,org.gjt.sp.jedit.gui.HistoryModel,10,1,0,12,46,17,10,3,8,0.622222222,296,1.0,0,0.0,0.35,0,0,28.1,10,2.8,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.util.Log;


public class HistoryModel
{
	
	public HistoryModel(String name)
	{
		this.name = name;

		max = jEdit.getIntegerProperty(""history"",25);
		data = new Vector(max);
	}

	
	public void addItem(String text)
	{
		if(text == null || text.length() == 0)
			return;

		int index = data.indexOf(text);
		if(index != -1)
			data.removeElementAt(index);

		data.insertElementAt(text,0);

		while(getSize() > max)
			data.removeElementAt(data.size() - 1);
	}

	
	public String getItem(int index)
	{
		return (String)data.elementAt(index);
	}

	
	public int getSize()
	{
		return data.size();
	}

	
	public String getName()
	{
		return name;
	}

	
	public static HistoryModel getModel(String name)
	{
		if(models == null)
			models = new Hashtable();

		HistoryModel model = (HistoryModel)models.get(name);
		if(model == null)
		{
			model = new HistoryModel(name);
			models.put(name,model);
		}

		return model;
	}

	
	public static void loadHistory(File file)
	{
		if(models == null)
			models = new Hashtable();

		try
		{
			BufferedReader in = new BufferedReader(new FileReader(file));

			HistoryModel currentModel = null;
			String line;

			while((line = in.readLine()) != null)
			{
				if(line.startsWith(""["") && line.endsWith(""]""))
				{
					if(currentModel != null)
					{
						models.put(currentModel.getName(),
							currentModel);
					}
					currentModel = new HistoryModel(line
						.substring(1,line.length() - 1));
				}
				else if(currentModel == null)
				{
					throw new IOException(""History data starts""
						+ "" before model name"");
				}
				else
				{
					currentModel.addItemToEnd(MiscUtilities
						.escapesToChars(line));
				}
			}

			if(currentModel != null)
			{
				models.put(currentModel.getName(),currentModel);
			}

			in.close();
		}
		catch(FileNotFoundException fnf)
		{
			Log.log(Log.DEBUG,HistoryModel.class,fnf);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
	}

	
	public static void saveHistory(File file)
	{
		String lineSep = System.getProperty(""line.separator"");
		try
		{
			BufferedWriter out = new BufferedWriter(
				new FileWriter(file));

			if(models == null)
			{
				out.close();
				return;
			}

			Enumeration modelEnum = models.elements();
			while(modelEnum.hasMoreElements())
			{
				HistoryModel model = (HistoryModel)modelEnum
					.nextElement();

				out.write('[');
				out.write(model.getName());
				out.write(']');
				out.write(lineSep);

				for(int i = 0; i < model.getSize(); i++)
				{
					out.write(MiscUtilities.charsToEscapes(
						model.getItem(i),true));
					out.write(lineSep);
				}
			}

			out.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
	}

	
	private String name;
	private int max;
	private Vector data;
	private static Hashtable models;

	private void addItemToEnd(String item)
	{
		data.addElement(item);
	}
}
"
jEdit,4,org.gjt.sp.jedit.gui.DockableWindowContainer,6,1,0,4,6,15,4,1,6,2.0,6,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.image.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public interface DockableWindowContainer
{
	void register(DockableWindowManager.Entry entry);
	void add(DockableWindowManager.Entry entry);
	void remove(DockableWindowManager.Entry entry);
	void save(DockableWindowManager.Entry entry);
	void show(DockableWindowManager.Entry entry);
	boolean isVisible(DockableWindowManager.Entry entry);
}
"
jEdit,4,org.gjt.sp.jedit.msg.MultiSelectStatusChanged,1,3,0,4,2,0,2,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,1,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class MultiSelectStatusChanged extends EBMessage.NonVetoable
{
	
	public MultiSelectStatusChanged(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4,org.gjt.sp.jedit.EditPlugin,9,1,2,10,12,30,10,2,7,0.75,31,1.0,1,0.0,0.266666667,0,0,2.333333333,1,0.8889,0,"

package org.gjt.sp.jedit;

import java.util.Vector;
import org.gjt.sp.jedit.gui.OptionsDialog;


public abstract class EditPlugin
{
	
	public String getClassName()
	{
		return getClass().getName();
	}

	
	public void start() {}

	
	public void stop() {}

	
	public void createMenuItems(Vector menuItems) {}

	
	public void createOptionPanes(OptionsDialog optionsDialog) {}

	
	public EditPlugin.JAR getJAR()
	{
		return jar;
	}

	
	public static class Broken extends EditPlugin
	{
		public String getClassName()
		{
			return clazz;
		}

		
		Broken(String clazz)
		{
			this.clazz = clazz;
		}

		
		private String clazz;
	}

	
	public static class JAR
	{
		public String getPath()
		{
			return path;
		}

		public JARClassLoader getClassLoader()
		{
			return classLoader;
		}

		public ActionSet getActions()
		{
			return actions;
		}

		public void addPlugin(EditPlugin plugin)
		{
			plugin.jar = JAR.this;

			
			
			
			plugin.start();

			if(plugin instanceof EBPlugin)
				EditBus.addToBus((EBPlugin)plugin);

			plugins.addElement(plugin);
		}

		public EditPlugin[] getPlugins()
		{
			EditPlugin[] array = new EditPlugin[plugins.size()];
			plugins.copyInto(array);
			return array;
		}

		public JAR(String path, JARClassLoader classLoader)
		{
			this.path = path;
			this.classLoader = classLoader;
			plugins = new Vector();
			actions = new ActionSet();
		}

		
		void getPlugins(Vector vector)
		{
			for(int i = 0; i < plugins.size(); i++)
			{
				vector.addElement(plugins.elementAt(i));
			}
		}

		
		private String path;
		private JARClassLoader classLoader;
		private Vector plugins;
		private ActionSet actions;
	}

	
	private EditPlugin.JAR jar;
}
"
jEdit,4,org.gjt.sp.jedit.browser.VFSBrowser,65,5,0,52,205,1652,26,37,27,0.941761364,1871,0.878787879,5,0.910739191,0.115384615,3,12,27.27692308,12,2.2462,9,"

package org.gjt.sp.jedit.browser;


import gnu.regexp.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.search.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class VFSBrowser extends JPanel implements EBComponent
{
	public static final String NAME = ""vfs.browser"";

	
	
	public static final int OPEN_DIALOG = 0;

	
	public static final int SAVE_DIALOG = 1;

	
	public static final int BROWSER = 2;
	

	
	
	public static void browseDirectory(View view, String path)
	{
		DockableWindowManager wm = view.getDockableWindowManager();
		VFSBrowser browser = (VFSBrowser)wm.getDockable(NAME);
		if(browser != null)
		{
			wm.showDockableWindow(NAME);
			browser.setDirectory(path);
		}
		else
		{
			if(path != null)
			{
				
				jEdit.setTemporaryProperty(""vfs.browser.path.tmp"",path);
			}
			wm.addDockableWindow(""vfs.browser"");
			jEdit.unsetProperty(""vfs.browser.path.tmp"");
		}
	} 

	
	
	public VFSBrowser(View view, String path, int mode, boolean multipleSelection,
		boolean floating)
	{
		super(new BorderLayout());

		listenerList = new EventListenerList();

		this.mode = mode;
		this.multipleSelection = multipleSelection;
		this.floating = floating;
		this.view = view;

		ActionHandler actionHandler = new ActionHandler();

		Box topBox = new Box(BoxLayout.Y_AXIS);

		
		
		
		
		
		toolbarBox = new Box(mode == BROWSER
			? BoxLayout.Y_AXIS
			: BoxLayout.X_AXIS);
		JToolBar menuBar = createMenuBar();
		if(mode == BROWSER)
			menuBar.add(Box.createGlue());
		toolbarBox.add(menuBar);
		if(mode != BROWSER)
		{
			toolbarBox.add(Box.createHorizontalStrut(6));
			toolbarBox.add(createToolBar());
			toolbarBox.add(Box.createGlue());
		}

		topBox.add(toolbarBox);

		GridBagLayout layout = new GridBagLayout();
		JPanel pathAndFilterPanel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.EAST;
		JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.path""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		pathAndFilterPanel.add(label);

		pathField = new HistoryTextField(""vfs.browser.path"");
		pathField.setInstantPopups(true);
		pathField.setEnterAddsToHistory(false);
		pathField.setSelectAllOnFocus(true);

		if(floating)
		{
			label.setDisplayedMnemonic(jEdit.getProperty(
				""vfs.browser.path.mnemonic"").charAt(0));
			label.setLabelFor(pathField);
		}

		
		
		
		Dimension prefSize = pathField.getPreferredSize();
		prefSize.width = 0;
		pathField.setPreferredSize(prefSize);
		pathField.addActionListener(actionHandler);
		cons.gridx = 1;
		cons.weightx = 1.0f;

		layout.setConstraints(pathField,cons);
		pathAndFilterPanel.add(pathField);

		filterCheckbox = new JCheckBox(jEdit.getProperty(""vfs.browser.filter""));
		filterCheckbox.setMargin(new Insets(0,0,0,0));
		filterCheckbox.setRequestFocusEnabled(false);
		filterCheckbox.setBorder(new EmptyBorder(0,0,0,12));
		filterCheckbox.setSelected(mode != BROWSER ||
			jEdit.getBooleanProperty(""vfs.browser.filter-enabled""));

		filterCheckbox.addActionListener(actionHandler);
		cons.gridx = 0;
		cons.weightx = 0.0f;
		cons.gridy = 1;
		layout.setConstraints(filterCheckbox,cons);
		pathAndFilterPanel.add(filterCheckbox);

		filterField = new HistoryTextField(""vfs.browser.filter"");
		filterField.setInstantPopups(true);
		filterField.setSelectAllOnFocus(true);
		filterField.addActionListener(actionHandler);

		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(filterField,cons);
		pathAndFilterPanel.add(filterField);

		topBox.add(pathAndFilterPanel);
		add(BorderLayout.NORTH,topBox);

		boolean splitHorizontally = false;
		if(jEdit.getBooleanProperty(""vfs.browser.splitHorizontally"") && mode != BROWSER)
			splitHorizontally = true;
		add(BorderLayout.CENTER,browserView = new BrowserView(this,splitHorizontally));

		propertiesChanged();

		HistoryModel filterModel = HistoryModel.getModel(""vfs.browser.filter"");
		String filter;
		if(mode == BROWSER || view == null || !jEdit.getBooleanProperty(
			""vfs.browser.currentBufferFilter""))
		{
			filter = jEdit.getProperty(""vfs.browser.last-filter"");
			if(filter == null)
				filter = jEdit.getProperty(""vfs.browser.default-filter"");
		}
		else
		{
			String name = view.getBuffer().getName();
			int index = name.lastIndexOf('.');

			if(index == -1)
				filter = jEdit.getProperty(""vfs.browser.default-filter"");
			else
			{
				String ext = name.substring(index);
				filter = ""*"" + ext;
			}
		}

		filterField.setText(filter);
		filterField.addCurrentToHistory();

		updateFilterEnabled();

		
		if(path == null)
			path = jEdit.getProperty(""vfs.browser.path.tmp"");

		if(path == null || path.length() == 0)
		{
			String userHome = System.getProperty(""user.home"");
			String defaultPath = jEdit.getProperty(""vfs.browser.defaultPath"");
			if(defaultPath.equals(""home""))
				path = userHome;
			else if(defaultPath.equals(""buffer""))
			{
				if(view != null)
				{
					Buffer buffer = view.getBuffer();
					path = buffer.getVFS().getParentOfPath(
						buffer.getPath());
				}
				else
					path = userHome;
			}
			else if(defaultPath.equals(""last""))
			{
				HistoryModel pathModel = HistoryModel.getModel(""vfs.browser.path"");
				if(pathModel.getSize() == 0)
					path = ""~"";
				else
					path = pathModel.getItem(0);
			}
			else if(defaultPath.equals(""favorites""))
				path = ""favorites:"";
			else
			{
				
				path = userHome;
			}
		}

		final String _path = path;

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				setDirectory(_path);
			}
		});
	} 

	
	public boolean requestDefaultFocus()
	{
		return browserView.requestDefaultFocus();
	} 

	
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	} 

	
	public void removeNotify()
	{
		super.removeNotify();
		jEdit.setBooleanProperty(""vfs.browser.filter-enabled"",
			filterCheckbox.isSelected());
		if(mode == BROWSER || !jEdit.getBooleanProperty(
			""vfs.browser.currentBufferFilter""))
		{
			jEdit.setProperty(""vfs.browser.last-filter"",
				filterField.getText());
		}
		EditBus.removeFromBus(this);
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof ViewUpdate)
			handleViewUpdate((ViewUpdate)msg);
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
		else if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof VFSUpdate)
		{
			
			
			
			
			
			
			
			
			if(requestRunning)
				return;

			
			
			
			
			if(path != null)
			{
				try
				{
					requestRunning = true;

					browserView.maybeReloadDirectory(((VFSUpdate)msg).getPath());
				}
				finally
				{
					VFSManager.runInAWTThread(new Runnable()
					{
						public void run()
						{
							requestRunning = false;
						}
					});
				}
			}
		}
	} 

	
	public View getView()
	{
		return view;
	} 

	
	public int getMode()
	{
		return mode;
	} 

	
	public boolean isMultipleSelectionEnabled()
	{
		return multipleSelection;
	} 

	
	public boolean getShowHiddenFiles()
	{
		return showHiddenFiles;
	} 

	
	public void setShowHiddenFiles(boolean showHiddenFiles)
	{
		this.showHiddenFiles = showHiddenFiles;
	} 

	
	
	public String getFilenameFilter()
	{
		if(filterCheckbox.isSelected())
		{
			String filter = filterField.getText();
			if(filter.length() == 0)
				return ""*"";
			else
				return filter;
		}
		else
			return ""*"";
	} 

	
	public void setFilenameFilter(String filter)
	{
		if(filter == null || filter.length() == 0 || filter.equals(""*""))
			filterCheckbox.setSelected(false);
		else
		{
			filterCheckbox.setSelected(true);
			filterField.setText(filter);
		}
	} 

	
	public HistoryTextField getDirectoryField()
	{
		return pathField;
	} 

	
	public String getDirectory()
	{
		return path;
	} 

	
	public void setDirectory(String path)
	{

		if(path.startsWith(""file:""))
			path = path.substring(5);

		String strippedPath;
		if(path.length() != 1 && (path.endsWith(""/"")
			|| path.endsWith(java.io.File.separator)))
			strippedPath = path.substring(0,path.length() - 1);
		else
			strippedPath = path;

		pathField.setText(strippedPath);

		if(!startRequest())
			return;

		browserView.loadDirectory(path);

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} 

	
	
	public void rootDirectory()
	{
		if(OperatingSystem.isDOSDerived())
			setDirectory(FileRootsVFS.PROTOCOL + "":"");
		else
			setDirectory(""/"");
	} 

	
	public void reloadDirectory()
	{
		
		VFSManager.getVFSForPath(path).reloadDirectory(path);

		browserView.loadDirectory(path);
	} 

	
	public void delete(String path)
	{
		if(MiscUtilities.isURL(path) && FavoritesVFS.PROTOCOL.equals(
			MiscUtilities.getProtocolOfURL(path)))
		{
			Object[] args = { path.substring(FavoritesVFS.PROTOCOL.length() + 1) };
			int result = GUIUtilities.confirm(this,
				""vfs.browser.delete-favorites"",args,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}
		else
		{
			Object[] args = { path };
			int result = GUIUtilities.confirm(this,
				""vfs.browser.delete-confirm"",args,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}

		VFS vfs = VFSManager.getVFSForPath(path);

		Object session = vfs.createVFSSession(path,this);
		if(session == null)
			return;

		if(!startRequest())
			return;

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.DELETE,this,
			session,vfs,path,null,null));
	} 

	
	public void rename(String from)
	{
		VFS vfs = VFSManager.getVFSForPath(from);

		String filename = vfs.getFileName(from);
		String[] args = { filename };
		String to = GUIUtilities.input(this,""vfs.browser.rename"",
			args,filename);
		if(to == null)
			return;

		to = MiscUtilities.constructPath(vfs.getParentOfPath(from),to);

		Object session = vfs.createVFSSession(from,this);
		if(session == null)
			return;

		if(!startRequest())
			return;

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.RENAME,this,
			session,vfs,from,to,null));
	} 

	
	public void mkdir()
	{
		String newDirectory = GUIUtilities.input(this,""vfs.browser.mkdir"",null);
		if(newDirectory == null)
			return;

		
		
		VFS.DirectoryEntry[] selected = getSelectedFiles();
		String parent;
		if(selected.length == 0)
			parent = path;
		else if(selected[0].type == VFS.DirectoryEntry.FILE)
		{
			parent = selected[0].path;
			parent = VFSManager.getVFSForPath(parent)
				.getParentOfPath(parent);
		}
		else
			parent = selected[0].path;

		VFS vfs = VFSManager.getVFSForPath(parent);

		
		newDirectory = MiscUtilities.constructPath(parent,newDirectory);

		Object session = vfs.createVFSSession(newDirectory,this);
		if(session == null)
			return;

		if(!startRequest())
			return;

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.MKDIR,this,
			session,vfs,newDirectory,null,null));
	} 

	
	
	public void newFile()
	{
		VFS.DirectoryEntry[] selected = getSelectedFiles();
		if(selected.length >= 1)
		{
			VFS.DirectoryEntry file = selected[0];
			if(file.type == VFS.DirectoryEntry.DIRECTORY)
				jEdit.newFile(view,file.path);
			else
			{
				VFS vfs = VFSManager.getVFSForPath(file.path);
				jEdit.newFile(view,vfs.getParentOfPath(file.path));
			}
		}
		else
			jEdit.newFile(view,path);
	} 

	
	
	public void searchInDirectory()
	{
		String path, filter;

		VFS.DirectoryEntry[] selected = getSelectedFiles();
		if(selected.length >= 1)
		{
			VFS.DirectoryEntry file = selected[0];
			if(file.type == VFS.DirectoryEntry.DIRECTORY)
			{
				path = file.path;
				filter = getFilenameFilter();
			}
			else
			{
				VFS vfs = VFSManager.getVFSForPath(file.path);
				path = vfs.getParentOfPath(file.path);
				String name = MiscUtilities.getFileName(file.path);
				String ext = MiscUtilities.getFileExtension(name);
				filter = (ext == null || ext.length() == 0
					? getFilenameFilter()
					: ""*"" + ext);
			}
		}
		else
		{
			path = this.path;
			filter = getFilenameFilter();
		}

		if(!(VFSManager.getVFSForPath(path) instanceof FileVFS))
		{
			getToolkit().beep();
			return;
		}

		SearchAndReplace.setSearchFileSet(new DirectoryListSet(
			path,filter,true));
		new SearchDialog(view,null,SearchDialog.DIRECTORY);
	} 

	
	public BrowserView getBrowserView()
	{
		return browserView;
	} 

	
	public VFS.DirectoryEntry[] getSelectedFiles()
	{
		return browserView.getSelectedFiles();
	} 

	
	public void addBrowserListener(BrowserListener l)
	{
		listenerList.add(BrowserListener.class,l);
	} 

	
	public void removeBrowserListener(BrowserListener l)
	{
		listenerList.remove(BrowserListener.class,l);
	} 

	

	
	void loadDirectory(DefaultMutableTreeNode node, String path, boolean root)
	{
		loadingRoot = root;

		try
		{
			String filter = filterField.getText();
			if(filter.length() == 0)
				filter = ""*"";
			filenameFilter = new RE(MiscUtilities.globToRE(filter),RE.REG_ICASE);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,VFSBrowser.this,e);
			String[] args = { filterField.getText(),
				e.getMessage() };
			GUIUtilities.error(this,""vfs.browser.bad-filter"",args);
		}

		path = MiscUtilities.constructPath(this.path,path);
		VFS vfs = VFSManager.getVFSForPath(path);

		Object session = vfs.createVFSSession(path,this);
		if(session == null)
			return;

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.LIST_DIRECTORY,this,
			session,vfs,path,null,node));
	} 

	
	void directoryLoaded(final DefaultMutableTreeNode node, final String path,
		final VFS.DirectoryEntry[] list)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(loadingRoot)
				{
					
					VFSBrowser.this.path = path;
					if(!pathField.getText().equals(path))
						pathField.setText(path);
					pathField.addCurrentToHistory();
				}

				boolean filterEnabled = filterCheckbox.isSelected();

				Vector directoryVector = new Vector();

				int directories = 0;
				int files = 0;
				int invisible = 0;

				if(list != null)
				{
					for(int i = 0; i < list.length; i++)
					{
						VFS.DirectoryEntry file = list[i];
						if(file.hidden && !showHiddenFiles)
						{
							invisible++;
							continue;
						}

						if(file.type == VFS.DirectoryEntry.FILE
							&& filterEnabled
							&& filenameFilter != null
							&& !filenameFilter.isMatch(file.name))
						{
							invisible++;
							continue;
						}

						if(file.type == VFS.DirectoryEntry.FILE)
							files++;
						else
							directories++;

						directoryVector.addElement(file);
					}

					if(sortFiles)
					{
						MiscUtilities.quicksort(directoryVector,
							new FileCompare());
					}
				}

				browserView.directoryLoaded(node,path,
					directoryVector);
			}
		});
	} 

	
	class FileCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			VFS.DirectoryEntry file1 = (VFS.DirectoryEntry)obj1;
			VFS.DirectoryEntry file2 = (VFS.DirectoryEntry)obj2;

			if(!sortMixFilesAndDirs)
			{
				if(file1.type != file2.type)
					return file2.type - file1.type;
			}

			return MiscUtilities.compareStrings(file1.name,
				file2.name,sortIgnoreCase);
		}
	} 

	
	void filesSelected()
	{
		VFS.DirectoryEntry[] selectedFiles = browserView.getSelectedFiles();

		if(mode == BROWSER)
		{
			for(int i = 0; i < selectedFiles.length; i++)
			{
				VFS.DirectoryEntry file = selectedFiles[i];
				Buffer buffer = jEdit.getBuffer(file.path);
				if(buffer != null && view != null)
					view.setBuffer(buffer);
			}
		}

		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesSelected(this,selectedFiles);
			}
		}
	} 

	
	
	void filesActivated(boolean newView, boolean canDoubleClickClose)
	{
		VFS.DirectoryEntry[] selectedFiles = browserView.getSelectedFiles();

		for(int i = 0; i < selectedFiles.length; i++)
		{
			VFS.DirectoryEntry file = selectedFiles[i];

			if(file.type == VFS.DirectoryEntry.DIRECTORY
				|| file.type == VFS.DirectoryEntry.FILESYSTEM)
				setDirectory(file.path);
			else if(mode == BROWSER)
			{
				Buffer buffer = jEdit.getBuffer(file.path);
				if(buffer == null)
					buffer = jEdit.openFile(null,file.path);
				else if(doubleClickClose && canDoubleClickClose)
				{
					jEdit.closeBuffer(view,buffer);
					break;
				}

				if(buffer != null)
				{
					if(newView)
						view = jEdit.newView(null,buffer);
					else
						view.setBuffer(buffer);
				}
			}
			else
			{
				
				
				
			}
		}

		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesActivated(this,selectedFiles);
			}
		}
	} 

	
	void endRequest()
	{
		requestRunning = false;
	} 

	

	

	
	private EventListenerList listenerList;
	private View view;
	private boolean floating;
	private String path;
	private HistoryTextField pathField;
	private JCheckBox filterCheckbox;
	private HistoryTextField filterField;
	private Box toolbarBox;
	private JToolBar toolbar;
	private JButton up, reload, roots, home, synchronize,
		newFile, newDirectory, searchInDirectory;
	private BrowserView browserView;
	private RE filenameFilter;
	private int mode;
	private boolean multipleSelection;

	private boolean showHiddenFiles;
	private boolean sortFiles;
	private boolean sortMixFilesAndDirs;
	private boolean sortIgnoreCase;
	private boolean doubleClickClose;

	private boolean requestRunning;
	private boolean loadingRoot;
	

	
	private JToolBar createMenuBar()
	{
		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.putClientProperty(""JToolBar.isRollover"",Boolean.TRUE);

		toolBar.add(new CommandsMenuButton());
		toolBar.add(Box.createHorizontalStrut(3));
		toolBar.add(new PluginsMenuButton());
		toolBar.add(Box.createHorizontalStrut(3));
		toolBar.add(new FavoritesMenuButton());

		return toolBar;
	} 

	
	private JToolBar createToolBar()
	{
		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);
		toolBar.putClientProperty(""JToolBar.isRollover"",Boolean.TRUE);

		toolBar.add(up = createToolButton(""up""));
		toolBar.add(reload = createToolButton(""reload""));
		toolBar.add(roots = createToolButton(""roots""));
		toolBar.add(home = createToolButton(""home""));
		toolBar.add(synchronize = createToolButton(""synchronize""));
		if(mode == BROWSER)
			toolBar.add(newFile = createToolButton(""new-file""));
		toolBar.add(newDirectory = createToolButton(""new-directory""));
		if(mode == BROWSER)
			toolBar.add(searchInDirectory = createToolButton(""search-in-directory""));

		return toolBar;
	} 

	
	private JButton createToolButton(String name)
	{
		JButton button = new JButton();
		String prefix = ""vfs.browser.commands."";

		String iconName = jEdit.getProperty(
			prefix + name + "".icon"");
		if(iconName != null)
		{
			Icon icon = GUIUtilities.loadIcon(iconName);
			if(icon != null)
				button.setIcon(icon);
			else
			{
				Log.log(Log.ERROR,this,""Missing icon: ""
					+ iconName);
			}
		}
		else
			Log.log(Log.ERROR,this,""Missing icon name: "" + name);

		button.setToolTipText(jEdit.getProperty(prefix + name + "".label""));

		button.setRequestFocusEnabled(false);
		button.setMargin(new Insets(0,0,0,0));
		button.addActionListener(new ActionHandler());

		return button;
	} 

	
	private void handleViewUpdate(ViewUpdate vmsg)
	{
		if(vmsg.getWhat() == ViewUpdate.CLOSED
			&& vmsg.getView() == view)
			view = null;
	} 

	
	private void handleBufferUpdate(BufferUpdate bmsg)
	{
		if(bmsg.getWhat() == BufferUpdate.CREATED
			|| bmsg.getWhat() == BufferUpdate.CLOSED)
			browserView.updateFileView();
		else if(bmsg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			
			
			
			if(!bmsg.getBuffer().isDirty())
				browserView.updateFileView();
		}
	} 

	
	private void propertiesChanged()
	{
		showHiddenFiles = jEdit.getBooleanProperty(""vfs.browser.showHiddenFiles"");
		sortFiles = jEdit.getBooleanProperty(""vfs.browser.sortFiles"");
		sortMixFilesAndDirs = jEdit.getBooleanProperty(""vfs.browser.sortMixFilesAndDirs"");
		sortIgnoreCase = jEdit.getBooleanProperty(""vfs.browser.sortIgnoreCase"");
		doubleClickClose = jEdit.getBooleanProperty(""vfs.browser.doubleClickClose"");

		browserView.propertiesChanged();

		if(mode == BROWSER)
		{
			boolean showToolbar = jEdit.getBooleanProperty(""vfs.browser.showToolbar"");
			if(showToolbar && toolbar == null)
			{
				toolbar = createToolBar();
				toolbar.add(Box.createGlue());
				toolbarBox.add(toolbar);
				revalidate();
			}
			else if(!showToolbar && toolbar != null)
			{
				toolbarBox.remove(toolbar);
				toolbar = null;
				revalidate();
			}
		}

		if(path != null)
			reloadDirectory();
	} 

	

	
	private boolean startRequest()
	{
		if(requestRunning)
		{
			
			Log.log(Log.DEBUG,this,new Throwable(""For debugging purposes""));

			GUIUtilities.error(this,""browser-multiple-io"",null);
			return false;
		}
		else
		{
			requestRunning = true;
			return true;
		}
	} 

	
	private void updateFilterEnabled()
	{
		filterField.setEnabled(filterCheckbox.isSelected());
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == pathField || source == filterField
				|| source == filterCheckbox)
			{
				updateFilterEnabled();

				String path = pathField.getText();
				if(path != null)
					setDirectory(path);

				browserView.requestDefaultFocus();
			}
			else if(source == up)
			{
				VFS vfs = VFSManager.getVFSForPath(path);
				setDirectory(vfs.getParentOfPath(path));
			}
			else if(source == reload)
				reloadDirectory();
			else if(source == roots)
				rootDirectory();
			else if(source == home)
				setDirectory(System.getProperty(""user.home""));
			else if(source == synchronize)
			{
				Buffer buffer = view.getBuffer();
				setDirectory(buffer.getVFS().getParentOfPath(
					buffer.getPath()));
			}
			else if(source == newFile)
				newFile();
			else if(source == newDirectory)
				mkdir();
			else if(source == searchInDirectory)
				searchInDirectory();
		}
	} 

	
	class CommandsMenuButton extends JButton
	{
		
		CommandsMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.commands.label""));
			setIcon(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
			setHorizontalTextPosition(SwingConstants.LEADING);

			popup = new BrowserCommandsMenu(VFSBrowser.this,null);

			CommandsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(0,0,0,0));
			CommandsMenuButton.this.addMouseListener(new MouseHandler());
		} 

		BrowserCommandsMenu popup;

		
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(!popup.isVisible())
				{
					
					popup.update();

					GUIUtilities.showPopupMenu(
						popup,CommandsMenuButton.this,0,
						CommandsMenuButton.this.getHeight());
				}
				else
				{
					popup.setVisible(false);
				}
			}
		} 
	} 

	
	class PluginsMenuButton extends JButton
	{
		
		PluginsMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.plugins.label""));
			setIcon(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
			setHorizontalTextPosition(SwingConstants.LEADING);

			PluginsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(0,0,0,0));
			PluginsMenuButton.this.addMouseListener(new MouseHandler());

			popup = new JPopupMenu();
			ActionHandler actionHandler = new ActionHandler();

			JMenuItem mi = new JMenuItem(jEdit.getProperty(
				""vfs.browser.plugins.plugin-manager.label""));
			mi.setActionCommand(""plugin-manager"");
			mi.addActionListener(actionHandler);

			popup.add(mi);
			popup.addSeparator();

			
			Vector vec = new Vector();
			Enumeration enum = VFSManager.getFilesystems();

			while(enum.hasMoreElements())
			{
				VFS vfs = (VFS)enum.nextElement();
				if((vfs.getCapabilities() & VFS.BROWSE_CAP) == 0)
					continue;

				JMenuItem menuItem = new JMenuItem(jEdit.getProperty(
					""vfs."" + vfs.getName() + "".label""));
				menuItem.setActionCommand(vfs.getName());
				menuItem.addActionListener(actionHandler);
				vec.addElement(menuItem);
			}

			if(vec.size() != 0)
			{
				MiscUtilities.quicksort(vec,new MiscUtilities.MenuItemCompare());
				for(int i = 0; i < vec.size(); i++)
					popup.add((JMenuItem)vec.elementAt(i));
			}
			else
			{
				mi = new JMenuItem(jEdit.getProperty(
					""vfs.browser.plugins.no-plugins.label""));
				mi.setEnabled(false);
				popup.add(mi);
			}
		} 

		JPopupMenu popup;

		
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(evt.getActionCommand().equals(""plugin-manager""))
				{
					new org.gjt.sp.jedit.pluginmgr.PluginManager(
						JOptionPane.getFrameForComponent(
						VFSBrowser.this));
				}
				else
				{
					VFS vfs = VFSManager.getVFSByName(evt.getActionCommand());
					String directory = vfs.showBrowseDialog(null,
						VFSBrowser.this);
					if(directory != null)
						setDirectory(directory);
				}
			}
		} 

		
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(!popup.isVisible())
				{
					GUIUtilities.showPopupMenu(
						popup,PluginsMenuButton.this,0,
						PluginsMenuButton.this.getHeight());
				}
				else
				{
					popup.setVisible(false);
				}
			}
		} 
	} 

	
	class FavoritesMenuButton extends JButton
	{
		
		FavoritesMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.favorites.label""));
			setIcon(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
			setHorizontalTextPosition(SwingConstants.LEADING);

			FavoritesMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(0,0,0,0));
			FavoritesMenuButton.this.addMouseListener(new MouseHandler());
		} 

		JPopupMenu popup;

		
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				String actionCommand = evt.getActionCommand();
				if(actionCommand.equals(""add-to-favorites""))
				{
					
					
					Vector toAdd = new Vector();
					VFS.DirectoryEntry[] selected = getSelectedFiles();
					for(int i = 0; i < selected.length; i++)
					{
						VFS.DirectoryEntry file = selected[i];
						if(file.type == VFS.DirectoryEntry.FILE)
						{
							toAdd.addElement(MiscUtilities
								.getParentOfPath(file.path));
						}
						else
							toAdd.addElement(file.path);
					}

					if(toAdd.size() != 0)
					{
						for(int i = 0; i < toAdd.size(); i++)
						{
							FavoritesVFS.addToFavorites((String)toAdd.elementAt(i));
						}
					}
					else
					{
						if(path.equals(FavoritesVFS.PROTOCOL + "":""))
						{
							GUIUtilities.error(VFSBrowser.this,
								""vfs.browser.recurse-favorites"",
								null);
						}
						else
						{
							FavoritesVFS.addToFavorites(path);
						}
					}
				}
				else
					setDirectory(actionCommand);
			}
		} 

		
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(popup == null || !popup.isVisible())
				{
					popup = new JPopupMenu();
					ActionHandler actionHandler = new ActionHandler();

					JMenuItem mi = new JMenuItem(
						jEdit.getProperty(
						""vfs.browser.favorites""
						+ "".add-to-favorites.label""));
					mi.setActionCommand(""add-to-favorites"");
					mi.addActionListener(actionHandler);
					popup.add(mi);

					mi = new JMenuItem(
						jEdit.getProperty(
						""vfs.browser.favorites""
						+ "".edit-favorites.label""));
					mi.setActionCommand(""favorites:"");
					mi.addActionListener(actionHandler);
					popup.add(mi);

					popup.addSeparator();

					Object[] favorites = FavoritesVFS.getFavorites();
					if(favorites.length == 0)
					{
						mi = new JMenuItem(
							jEdit.getProperty(
							""vfs.browser.favorites""
							+ "".no-favorites.label""));
						mi.setEnabled(false);
						popup.add(mi);
					}
					else
					{
						MiscUtilities.quicksort(favorites,
							new MiscUtilities.StringICaseCompare());
						for(int i = 0; i < favorites.length; i++)
						{
							mi = new JMenuItem(favorites[i].toString());
							mi.setIcon(FileCellRenderer.dirIcon);
							mi.addActionListener(actionHandler);
							popup.add(mi);
						}
					}

					GUIUtilities.showPopupMenu(
						popup,FavoritesMenuButton.this,0,
						FavoritesMenuButton.this.getHeight());
				}
				else
				{
					popup.setVisible(false);
					popup = null;
				}
			}
		} 
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.options.DockingOptionPane,5,6,0,6,42,6,2,5,3,0.75,206,1.0,1,0.993993994,1.0,2,4,39.4,2,1.0,0,"

package org.gjt.sp.jedit.options;


import javax.swing.table.*;
import javax.swing.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;



public class DockingOptionPane extends AbstractOptionPane
{
	
	public DockingOptionPane()
	{
		super(""docking"");
	} 

	
	public void _init()
	{
		Box box = new Box(BoxLayout.X_AXIS);
		ButtonGroup grp = new ButtonGroup();

		layout1 = new JToggleButton(GUIUtilities.loadIcon(""dock_layout1.gif""));
		grp.add(layout1);
		box.add(layout1);

		box.add(Box.createHorizontalStrut(6));

		layout2 = new JToggleButton(GUIUtilities.loadIcon(""dock_layout2.gif""));
		grp.add(layout2);
		box.add(layout2);

		if(jEdit.getBooleanProperty(""view.docking.alternateLayout""))
			layout2.setSelected(true);
		else
			layout1.setSelected(true);

		addComponent(jEdit.getProperty(""options.docking.layout""),box);

		addComponent(Box.createVerticalStrut(6));

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = 3;
		cons.gridwidth = cons.gridheight = GridBagConstraints.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = cons.weighty = 1.0f;

		JScrollPane windowScroller = createWindowTableScroller();
		gridBag.setConstraints(windowScroller,cons);
		add(windowScroller);
	} 

	
	public void _save()
	{
		jEdit.setBooleanProperty(""view.docking.alternateLayout"",
			layout2.isSelected());
		windowModel.save();
	} 

	

	
	private JToggleButton layout1;
	private JToggleButton layout2;
	private JTable windowTable;
	private WindowTableModel windowModel;
	

	
	private JScrollPane createWindowTableScroller()
	{
		windowModel = createWindowModel();
		windowTable = new JTable(windowModel);
		windowTable.getTableHeader().setReorderingAllowed(false);
		windowTable.setColumnSelectionAllowed(false);
		windowTable.setRowSelectionAllowed(false);
		windowTable.setCellSelectionEnabled(false);

		DockPositionCellRenderer comboBox = new DockPositionCellRenderer();
		windowTable.setRowHeight(comboBox.getPreferredSize().height);
		TableColumn column = windowTable.getColumnModel().getColumn(1);
		column.setCellRenderer(comboBox);
		column.setCellEditor(new DefaultCellEditor(new DockPositionCellRenderer()));

		Dimension d = windowTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(windowTable);
		scroller.setPreferredSize(d);
		return scroller;
	} 

	
	private WindowTableModel createWindowModel()
	{
		return new WindowTableModel();
	} 

	

	
	class DockPositionCellRenderer extends JComboBox
		implements TableCellRenderer
	{
		DockPositionCellRenderer()
		{
			super(new String[] {
				DockableWindowManager.FLOATING,
				DockableWindowManager.TOP,
				DockableWindowManager.LEFT,
				DockableWindowManager.BOTTOM,
				DockableWindowManager.RIGHT
			});
			setRequestFocusEnabled(false);
		}

		public Component getTableCellRendererComponent(JTable table,
			Object value, boolean isSelected, boolean hasFocus,
			int row, int column)
		{
			setSelectedItem(value);
			return this;
		}
	} 
} 


class WindowTableModel extends AbstractTableModel
{
	private Vector windows;

	
	WindowTableModel()
	{
		windows = new Vector();

		
		Object[] list = EditBus.getNamedList(DockableWindow.DOCKABLE_WINDOW_LIST);
		if(list != null)
		{
			for(int i = 0; i < list.length; i++)
			{
				windows.addElement(new Entry((String)list[i]));
			}
		}
		

		String[] dockables = DockableWindowManager.getRegisteredDockableWindows();
		for(int i = 0; i < dockables.length; i++)
		{
			windows.addElement(new Entry(dockables[i]));
		}

		sort();
	} 

	
	public void sort()
	{
		MiscUtilities.quicksort(windows,new WindowCompare());
		fireTableDataChanged();
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return windows.size();
	} 

	
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
		case 1:
			return String.class;
		default:
			throw new InternalError();
		}
	} 

	
	public Object getValueAt(int row, int col)
	{
		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 0:
			return window.title;
		case 1:
			return window.dockPosition;
		default:
			throw new InternalError();
		}
	} 

	
	public boolean isCellEditable(int row, int col)
	{
		return (col != 0);
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
			return;

		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 1:
			window.dockPosition = (String)value;
			break;
		default:
			throw new InternalError();
		}

		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.docking.title"");
		case 1:
			return jEdit.getProperty(""options.docking.dockPosition"");
		default:
			throw new InternalError();
		}
	} 

	
	public void save()
	{
		for(int i = 0; i < windows.size(); i++)
		{
			((Entry)windows.elementAt(i)).save();
		}
	} 

	
	class Entry
	{
		String name;
		String title;
		String dockPosition;

		Entry(String name)
		{
			this.name = name;
			title = jEdit.getProperty(name + "".title"");
			if(title == null)
				title = name;

			dockPosition = jEdit.getProperty(name + "".dock-position"");
			if(dockPosition == null)
				dockPosition = DockableWindowManager.FLOATING;
		}

		void save()
		{
			jEdit.setProperty(name + "".dock-position"",dockPosition);
		}
	} 

	
	class WindowCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			Entry e1 = (Entry)obj1;
			Entry e2 = (Entry)obj2;

			return MiscUtilities.compareStrings(
				e1.title,e2.title,true);
		}
	} 
} 
"
jEdit,4,org.gjt.sp.jedit.browser.BrowserView,25,5,0,18,123,122,11,14,11,0.818452381,797,1.0,3,0.964549483,0.195555556,1,4,30.32,12,2.28,4,"

package org.gjt.sp.jedit.browser;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;



public class BrowserView extends JPanel
{
	
	public BrowserView(VFSBrowser browser, final boolean splitHorizontally)
	{
		this.browser = browser;
		this.splitHorizontally = splitHorizontally;

		parentModel = new DefaultListModel();
		parentDirectories = new JList(parentModel);

		parentDirectories.getSelectionModel().setSelectionMode(
			TreeSelectionModel.SINGLE_TREE_SELECTION);

		parentDirectories.setCellRenderer(new ParentDirectoryRenderer());
		parentDirectories.setVisibleRowCount(5);
		parentDirectories.addMouseListener(new MouseHandler());

		rootNode = new DefaultMutableTreeNode(null,true);
		model = new DefaultTreeModel(rootNode,true);

		tree = new BrowserJTree(model);
		tree.setCellRenderer(renderer);
		tree.setEditable(false);
		tree.addTreeExpansionListener(new TreeHandler());
		tree.putClientProperty(""JTree.lineStyle"", ""Angled"");
		tree.setRootVisible(false);
		tree.setShowsRootHandles(true);
		tree.setVisibleRowCount(12);

		final JScrollPane parentScroller = new JScrollPane(parentDirectories);
		parentScroller.setMinimumSize(new Dimension(0,0));
		JScrollPane treeScroller = new JScrollPane(tree);
		treeScroller.setMinimumSize(new Dimension(0,0));
		splitPane = new JSplitPane( 
			splitHorizontally ? JSplitPane.HORIZONTAL_SPLIT : JSplitPane.VERTICAL_SPLIT,
			parentScroller,treeScroller);

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				String prop = splitHorizontally ? ""vfs.browser.horizontalSplitter"" : ""vfs.browser.splitter"";
				int loc = jEdit.getIntegerProperty(prop,-1);
				if(loc == -1)
					loc = parentScroller.getPreferredSize().height;

				splitPane.setDividerLocation(loc);
				parentDirectories.ensureIndexIsVisible(
					parentDirectories.getModel()
					.getSize());
			}
		});

		tmpExpanded = new Hashtable();

		if(browser.isMultipleSelectionEnabled())
			tree.getSelectionModel().setSelectionMode(
				TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);
		else
			tree.getSelectionModel().setSelectionMode(
				TreeSelectionModel.SINGLE_TREE_SELECTION);

		setLayout(new BorderLayout());

		add(BorderLayout.CENTER,splitPane);

		propertiesChanged();
	} 

	
	public boolean requestDefaultFocus()
	{
		tree.requestFocus();
		return true;
	} 

	
	public void removeNotify()
	{
		String prop = splitHorizontally ? ""vfs.browser.horizontalSplitter"" : ""vfs.browser.splitter"";
		jEdit.setIntegerProperty(prop,splitPane.getDividerLocation());

		super.removeNotify();
	} 

	
	public VFS.DirectoryEntry[] getSelectedFiles()
	{
		Vector selected = new Vector(tree.getSelectionCount());
		TreePath[] paths = tree.getSelectionPaths();
		if(paths == null)
			return new VFS.DirectoryEntry[0];

		for(int i = 0; i < paths.length; i++)
		{
			DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
				paths[i].getLastPathComponent();
			Object obj = treeNode.getUserObject();
			if(obj instanceof VFS.DirectoryEntry)
				selected.addElement(obj);
		}

		VFS.DirectoryEntry[] retVal = new VFS.DirectoryEntry[selected.size()];
		selected.copyInto(retVal);
		return retVal;
	} 

	
	public void selectNone()
	{
		tree.setSelectionPaths(new TreePath[0]);
	} 

	
	public void directoryLoaded(DefaultMutableTreeNode node,
		String path, Vector directory)
	{
		if(node == rootNode)
		{
			parentModel.removeAllElements();
			String parent = path;

			if(parent.length() != 1 && (parent.endsWith(""/"")
				|| parent.endsWith(File.separator)))
				parent = parent.substring(0,parent.length() - 1);

			for(;;)
			{
				parentModel.insertElementAt(parent,0);
				String newParent = MiscUtilities.getParentOfPath(parent);
				if(newParent.length() != 1 && (newParent.endsWith(""/"")
					|| newParent.endsWith(File.separator)))
					newParent = newParent.substring(0,newParent.length() - 1);

				if(newParent == null || parent.equals(newParent))
					break;
				else
					parent = newParent;
			}

			int index = parentModel.getSize() - 1;
			parentDirectories.setSelectedIndex(index);
			parentDirectories.ensureIndexIsVisible(parentModel.getSize() - 1);
		}

		node.removeAllChildren();

		Vector toExpand = new Vector();

		if(directory != null)
		{
			for(int i = 0; i < directory.size(); i++)
			{
				VFS.DirectoryEntry file = (VFS.DirectoryEntry)
					directory.elementAt(i);
				boolean allowsChildren = (file.type != VFS.DirectoryEntry.FILE);
				DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(file,allowsChildren);
				node.add(newNode);
				if(tmpExpanded.get(file.path) != null)
					toExpand.addElement(new TreePath(newNode.getPath()));
			}
		}

		
		model.reload(node);
		tree.expandPath(new TreePath(node.getPath()));

		
		for(int i = 0; i < toExpand.size(); i++)
		{
			TreePath treePath = (TreePath)toExpand.elementAt(i);
			tree.expandPath(treePath);
		}

		timer.stop();
		typeSelectBuffer.setLength(0);
	} 

	
	public void updateFileView()
	{
		tree.repaint();
	} 

	
	public void loadDirectory(String path)
	{
		
		tmpExpanded.clear();
		loadDirectory(rootNode,path,false);
	} 

	
	public void maybeReloadDirectory(String path)
	{
		tmpExpanded.clear();

		
		
		
		
		
		
		
		
		
		
		
		String browserDir = browser.getDirectory();
		if(browserDir.startsWith(FavoritesVFS.PROTOCOL))
			maybeReloadDirectory(rootNode,path);
		else if(browserDir.startsWith(FileRootsVFS.PROTOCOL))
		{
			if(!MiscUtilities.isURL(path) || MiscUtilities.getProtocolOfURL(path)
				.equals(""file""))
				maybeReloadDirectory(rootNode,path);
		}
		else if(path.startsWith(browserDir))
			maybeReloadDirectory(rootNode,path);
	} 

	
	public Component getDefaultFocusComponent()
	{
		return tree;
	} 

	
	public void propertiesChanged()
	{
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
		renderer.propertiesChanged();

		tree.setRowHeight(renderer.getTreeCellRendererComponent(
			tree,new DefaultMutableTreeNode(""foo""),
			false,false,false,0,false).getSize().height);

		splitPane.setBorder(null);
	} 

	

	
	private VFSBrowser browser;

	private JSplitPane splitPane;
	private JList parentDirectories;
	private DefaultListModel parentModel;
	private JTree tree;
	private Hashtable tmpExpanded;
	private DefaultTreeModel model;
	private DefaultMutableTreeNode rootNode;
	private BrowserCommandsMenu popup;
	private boolean showIcons;
	private boolean splitHorizontally;

	private FileCellRenderer renderer = new FileCellRenderer();

	private StringBuffer typeSelectBuffer = new StringBuffer();
	private Timer timer = new Timer(0,new ClearTypeSelect());
	

	
	private boolean maybeReloadDirectory(DefaultMutableTreeNode node, String path)
	{
		
		if(!tree.isExpanded(new TreePath(node.getPath())))
			return false;

		if(node == rootNode && path.equals(browser.getDirectory()))
		{
			loadDirectory(rootNode,path,false);
			return true;
		}

		Object userObject = node.getUserObject();
		if(userObject instanceof VFS.DirectoryEntry)
		{
			VFS.DirectoryEntry file = (VFS.DirectoryEntry)userObject;

			
			if(file.type == VFS.DirectoryEntry.FILE)
				return false;

			if(path.equals(file.path))
			{
				loadDirectory(node,path,false);
				return true;
			}
		}

		if(node.getChildCount() != 0)
		{
			Enumeration children = node.children();
			while(children.hasMoreElements())
			{
				DefaultMutableTreeNode child = (DefaultMutableTreeNode)
					children.nextElement();
				if(maybeReloadDirectory(child,path))
					return true;
			}
		}

		return false;
	} 

	
	private void loadDirectory(DefaultMutableTreeNode node, String path,
		boolean showLoading)
	{
		int rowCount = tree.getRowCount();
		for(int i = 0; i < rowCount; i++)
		{
			TreePath treePath = tree.getPathForRow(i);
			if(tree.isExpanded(treePath))
			{
				DefaultMutableTreeNode _node = (DefaultMutableTreeNode)
					treePath.getLastPathComponent();
				VFS.DirectoryEntry file = ((VFS.DirectoryEntry)
					_node.getUserObject());

				tmpExpanded.put(file.path,file.path);
			}
		}

		if(node == rootNode)
		{
			parentModel.removeAllElements();
			parentModel.addElement(new LoadingPlaceholder());
		}

		if(showLoading)
		{
			node.removeAllChildren();
			node.add(new DefaultMutableTreeNode(new LoadingPlaceholder(),false));
			model.reload(node);
		}

		browser.loadDirectory(node,path,node == rootNode);
	} 

	
	private void showFilePopup(VFS.DirectoryEntry file, Point point)
	{
		popup = new BrowserCommandsMenu(browser,file);
		GUIUtilities.showPopupMenu(popup,tree,point.x+1,point.y+1);
	} 

	

	

	
	class ClearTypeSelect implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			typeSelectBuffer.setLength(0);
			browser.filesSelected();
		}
	} 

	
	class ParentDirectoryRenderer extends DefaultListCellRenderer
	{
		Font plainFont, boldFont;

		ParentDirectoryRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			boldFont = new Font(plainFont.getName(),Font.BOLD,plainFont.getSize());
		}

		public Component getListCellRendererComponent(
			JList list,
			Object value,
			int index,
			boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			ParentDirectoryRenderer.this.setBorder(new EmptyBorder(
				1,index * 10 + 1,1,1));

			if(value instanceof LoadingPlaceholder)
			{
				ParentDirectoryRenderer.this.setFont(plainFont);

				setIcon(showIcons ? FileCellRenderer.loadingIcon : null);
				setText(jEdit.getProperty(""vfs.browser.tree.loading""));
			}
			else
			{
				ParentDirectoryRenderer.this.setFont(boldFont);

				setIcon(showIcons ? FileCellRenderer.openDirIcon : null);
				setText(MiscUtilities.getFileName(value.toString()));
			}

			return this;
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			
			if(evt.getClickCount() == 2)
				return;

			int row = parentDirectories.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Object obj = parentModel.getElementAt(row);
				if(obj instanceof String)
				{
					browser.setDirectory((String)obj);
					requestDefaultFocus();
				}
			}
		}
	} 

	
	class BrowserJTree extends JTree
	{
		
		BrowserJTree(TreeModel model)
		{
			super(model);
			ToolTipManager.sharedInstance().registerComponent(this);
		} 

		
		public final String getToolTipText(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
					return path.getLastPathComponent().toString();
			}
			return null;
		} 

		
		public final Point getToolTipLocation(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
				{
					return new Point(cellRect.x + (showIcons ? 14 : - 4),
						cellRect.y);
				}
			}
			return null;
		} 

		
		protected void processKeyEvent(KeyEvent evt)
		{
			
			
			
			
			
			

			if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				switch(evt.getKeyCode())
				{
				case KeyEvent.VK_ENTER:
					browser.filesActivated(evt.isShiftDown(),false);
					evt.consume();
					break;
				case KeyEvent.VK_LEFT:
					String directory = browser.getDirectory();
					browser.setDirectory(MiscUtilities
						.getParentOfPath(directory));
					evt.consume();
					break;
				}
			}
			else if(evt.getID() == KeyEvent.KEY_TYPED)
			{
				if(evt.isControlDown() || evt.isAltDown()
					|| evt.isMetaDown())
				{
					return;
				}

				switch(evt.getKeyChar())
				{
				case '~':
					browser.setDirectory(System.getProperty(""user.home""));
					break;
				case '/':
					browser.rootDirectory();
					break;
				case '-':
					View view = browser.getView();
					Buffer buffer = view.getBuffer();
					browser.setDirectory(MiscUtilities.getParentOfPath(
						buffer.getPath()));
					break;
				default:
					typeSelectBuffer.append(evt.getKeyChar());
					doTypeSelect(typeSelectBuffer.toString());

					timer.stop();
					timer.setInitialDelay(750);
					timer.setRepeats(false);
					timer.start();
					break;
				}

				return;
			}

			if(!evt.isConsumed())
				super.processKeyEvent(evt);
		} 

		
		protected void processMouseEvent(MouseEvent evt)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();

			switch(evt.getID())
			{
			
			case MouseEvent.MOUSE_ENTERED:
				toolTipInitialDelay = ttm.getInitialDelay();
				toolTipReshowDelay = ttm.getReshowDelay();
				ttm.setInitialDelay(200);
				ttm.setReshowDelay(0);
				super.processMouseEvent(evt);
				break; 
			
			case MouseEvent.MOUSE_EXITED:
				ttm.setInitialDelay(toolTipInitialDelay);
				ttm.setReshowDelay(toolTipReshowDelay);
				super.processMouseEvent(evt);
				break; 
			
			case MouseEvent.MOUSE_CLICKED:
				if((evt.getModifiers() & MouseEvent.BUTTON2_MASK) != 0)
				{
					TreePath path = getPathForLocation(evt.getX(),evt.getY());
					if(path == null)
					{
						super.processMouseEvent(evt);
						break;
					}

					if(!isPathSelected(path))
						setSelectionPath(path);

					browser.filesActivated(evt.isShiftDown(),true);
					break;
				}
				else if((evt.getModifiers() & MouseEvent.BUTTON1_MASK) != 0)
				{
					TreePath path = getPathForLocation(evt.getX(),evt.getY());
					if(path == null)
					{
						super.processMouseEvent(evt);
						break;
					}

					if(!isPathSelected(path))
						setSelectionPath(path);

					if(evt.getClickCount() == 1)
					{
						browser.filesSelected();
						super.processMouseEvent(evt);
					}
					if(evt.getClickCount() == 2)
					{
						
						
						
						browser.filesActivated(evt.isShiftDown(),true);
						break;
					}
				}
				else if(GUIUtilities.isPopupTrigger(evt))
					; 

				super.processMouseEvent(evt);
				break; 
			
			case MouseEvent.MOUSE_PRESSED:
				if((evt.getModifiers() & MouseEvent.BUTTON1_MASK) != 0)
				{
					if(popup != null && popup.isVisible())
						popup.setVisible(false);

					if(evt.getClickCount() == 2)
						break;
				}
				else if(GUIUtilities.isPopupTrigger(evt))
				{
					if(popup != null && popup.isVisible())
					{
						popup.setVisible(false);
						break;
					}

					TreePath path = getPathForLocation(evt.getX(),evt.getY());
					if(path == null)
						showFilePopup(null,evt.getPoint());
					else
					{
						setSelectionPath(path);
						browser.filesSelected();

						Object userObject = ((DefaultMutableTreeNode)path
							.getLastPathComponent()).getUserObject();
						if(userObject instanceof VFS.DirectoryEntry)
						{
							VFS.DirectoryEntry file = (VFS.DirectoryEntry)
								userObject;
							showFilePopup(file,evt.getPoint());
						}
						else
							showFilePopup(null,evt.getPoint());
					}

					break;
				}

				super.processMouseEvent(evt);
				break; 
			
			case MouseEvent.MOUSE_RELEASED:
				if(evt.getClickCount() != 2)
					super.processMouseEvent(evt);
				break; 
			default:
				super.processMouseEvent(evt);
				break;
			}
		} 

		
		private int toolTipInitialDelay = -1;
		private int toolTipReshowDelay = -1;

		
		private boolean cellRectIsVisible(Rectangle cellRect)
		{
			Rectangle vr = BrowserJTree.this.getVisibleRect();
			return vr.contains(cellRect.x,cellRect.y) &&
				vr.contains(cellRect.x + cellRect.width,
				cellRect.y + cellRect.height);
		} 

		
		private void doTypeSelect(String str)
		{
			if(getSelectionCount() == 0)
				doTypeSelect(str,0,getRowCount());
			else
			{
				int start = getMaxSelectionRow();
				boolean retVal = doTypeSelect(str,start,getRowCount());

				if(!retVal)
				{
					
					
					doTypeSelect(str,0,start);
				}
			}
		} 

		
		private boolean doTypeSelect(String str, int start, int end)
		{
			for(int i = start; i < end; i++)
			{
				DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
					getPathForRow(i).getLastPathComponent();
				Object obj = treeNode.getUserObject();
				if(obj instanceof VFS.DirectoryEntry)
				{
					VFS.DirectoryEntry file = (VFS.DirectoryEntry)obj;
					if(file.name.regionMatches(true,0,str,0,str.length()))
					{
						setSelectionRow(i);
						scrollRowToVisible(i);
						return true;
					}
				}
			}

			return false;
		} 

		
	} 

	
	class TreeHandler implements TreeExpansionListener
	{
		
		public void treeExpanded(TreeExpansionEvent evt)
		{
			TreePath path = evt.getPath();
			DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			Object userObject = treeNode.getUserObject();
			if(userObject instanceof VFS.DirectoryEntry)
			{
				loadDirectory(treeNode,((VFS.DirectoryEntry)
					userObject).path,true);
			}
		} 

		
		public void treeCollapsed(TreeExpansionEvent evt)
		{
			TreePath path = evt.getPath();
			DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			if(treeNode.getUserObject() instanceof VFS.DirectoryEntry)
			{
				
				
				
				treeNode.removeAllChildren();
				treeNode.add(new DefaultMutableTreeNode(new LoadingPlaceholder(),false));
				model.reload(treeNode);
			}
		} 
	} 

	static class LoadingPlaceholder {}
	
}
"
jEdit,4,org.gjt.sp.jedit.options.PrintOptionPane,3,6,0,4,21,1,1,3,1,0.5,159,1.0,1,0.996987952,1.0,1,3,50.0,1,0.6667,1,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;


public class PrintOptionPane extends AbstractOptionPane
{
	
	public PrintOptionPane()
	{
		super(""print"");
	} 

	
	protected void _init()
	{
		
		font = new FontSelector(jEdit.getFontProperty(""print.font""));
		addComponent(jEdit.getProperty(""options.print.font""),font);

		
		printHeader = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".header""));
		printHeader.setSelected(jEdit.getBooleanProperty(""print.header""));
		addComponent(printHeader);

		
		printFooter = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".footer""));
		printFooter.setSelected(jEdit.getBooleanProperty(""print.footer""));
		addComponent(printFooter);

		
		printLineNumbers = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".lineNumbers""));
		printLineNumbers.setSelected(jEdit.getBooleanProperty(""print.lineNumbers""));
		addComponent(printLineNumbers);

		
		color = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".color""));
		color.setSelected(jEdit.getBooleanProperty(""print.color""));
		addComponent(color);

		
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		tabSize = new JComboBox(tabSizes);
		tabSize.setEditable(true);
		tabSize.setSelectedItem(jEdit.getProperty(""print.tabSize""));
		addComponent(jEdit.getProperty(""options.print.tabSize""),tabSize);
	} 

	
	protected void _save()
	{
		jEdit.setFontProperty(""print.font"",font.getFont());
		jEdit.setBooleanProperty(""print.header"",printHeader.isSelected());
		jEdit.setBooleanProperty(""print.footer"",printFooter.isSelected());
		jEdit.setBooleanProperty(""print.lineNumbers"",printLineNumbers.isSelected());
		jEdit.setBooleanProperty(""print.color"",color.isSelected());
		jEdit.setProperty(""print.tabSize"",(String)tabSize.getSelectedItem());
	} 

	
	private FontSelector font;
	private JCheckBox printHeader;
	private JCheckBox printFooter;
	private JCheckBox printLineNumbers;
	private JCheckBox color;
	private JComboBox tabSize;
	
}
"
jEdit,4,org.gjt.sp.util.WorkThread,14,2,0,7,35,37,4,4,11,0.760683761,304,1.0,1,0.824324324,0.224489796,0,0,20.07142857,8,1.7143,1,"

package org.gjt.sp.util;


public class WorkThread extends Thread
{
	public WorkThread(WorkThreadPool pool, ThreadGroup group, String name)
	{
		super(group, name);
		setDaemon(true);
		setPriority(4);

		this.pool = pool;
	}

	
	public void setAbortable(boolean abortable)
	{
		synchronized(abortLock)
		{
			this.abortable = abortable;
			if(aborted)
				stop(new Abort());
		}
	}

	
	public boolean isRequestRunning()
	{
		return requestRunning;
	}

	
	public String getStatus()
	{
		return status;
	}

	
	public void setStatus(String status)
	{
		this.status = status;
		pool.fireProgressChanged(this);
	}

	
	public int getProgressValue()
	{
		return progressValue;
	}

	
	public void setProgressValue(int progressValue)
	{
		this.progressValue = progressValue;
		pool.fireProgressChanged(this);
	}

	
	public int getProgressMaximum()
	{
		return progressMaximum;
	}

	
	public void setProgressMaximum(int progressMaximum)
	{
		this.progressMaximum = progressMaximum;
		pool.fireProgressChanged(this);
	}

	
	public void abortCurrentRequest()
	{
		synchronized(abortLock)
		{
			if(abortable && !aborted)
				stop(new Abort());
			aborted = true;
		}
	}

	public void run()
	{
		Log.log(Log.DEBUG,this,""Work request thread starting ["" + getName() + ""]"");

		for(;;)
		{
			doRequests();
		}
	}

	
	private WorkThreadPool pool;
	private Object abortLock = new Object();
	private boolean requestRunning;
	private boolean abortable;
	private boolean aborted;
	private String status;
	private int progressValue;
	private int progressMaximum;

	private void doRequests()
	{
		WorkThreadPool.Request request;
		for(;;)
		{
			request = pool.getNextRequest();
			if(request == null)
				break;
			else
			{
				requestRunning = true;
				pool.fireStatusChanged(this);
				doRequest(request);
				requestRunning = false;
			}
		}

		pool.fireStatusChanged(this);

		synchronized(pool.waitForAllLock)
		{
			
			pool.waitForAllLock.notifyAll();
		}

		synchronized(pool.lock)
		{
			
			try
			{
				pool.lock.wait();
			}
			catch(InterruptedException ie)
			{
				Log.log(Log.ERROR,this,ie);
			}
		}
	}

	private void doRequest(WorkThreadPool.Request request)
	{


		try
		{
			request.run.run();
		}
		catch(Abort a)
		{
			Log.log(Log.ERROR,WorkThread.class,""Unhandled abort"");
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception ""
				+ ""in work thread:"");
			Log.log(Log.ERROR,WorkThread.class,t);
		}
		finally
		{
			synchronized(abortLock)
			{
				aborted = abortable = false;
			}
			status = null;
			progressValue = progressMaximum = 0;
			pool.requestDone();
			pool.fireStatusChanged(this);
		}
	}

	public static class Abort extends Error
	{
		public Abort()
		{
			super(""Work request aborted"");
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.msg.PropertiesChanged,1,3,0,9,2,0,7,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class PropertiesChanged extends EBMessage.NonVetoable
{
	
	public PropertiesChanged(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4,org.gjt.sp.jedit.AbstractOptionPane,10,5,20,23,27,29,21,2,8,0.805555556,285,1.0,0,0.986404834,0.5,0,0,27.1,2,1.1,0,"

package org.gjt.sp.jedit;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;



public abstract class AbstractOptionPane extends JPanel implements OptionPane
{
	
	
	public AbstractOptionPane(String name)
	{
		this.name = name;
		setLayout(gridBag = new GridBagLayout());
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public Component getComponent()
	{
		return this;
	} 

	
	public void init()
	{
		if(!initialized)
		{
			initialized = true;
			_init();
		}
	} 

	
	public void save()
	{
		if(initialized)
			_save();
	} 

	

	
	
	protected boolean initialized;

	
	protected GridBagLayout gridBag;

	
	protected int y;
	

	
	protected void _init() {}

	
	protected void _save() {}

	
	
	public void addComponent(String label, Component comp)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = 1;
		cons.weightx = 0.0f;
		cons.insets = new Insets(1,0,1,0);
		cons.fill = GridBagConstraints.BOTH;

		JLabel l = new JLabel(label,SwingConstants.RIGHT);
		l.setBorder(new EmptyBorder(0,0,0,12));
		gridBag.setConstraints(l,cons);
		add(l);

		cons.gridx = 1;
		cons.weightx = 1.0f;
		gridBag.setConstraints(comp,cons);
		add(comp);
	} 

	
	
	public void addComponent(Component comp)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.NONE;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);

		gridBag.setConstraints(comp,cons);
		add(comp);
	} 

	
	
	public void addSeparator(String label)
	{
		Box box = new Box(BoxLayout.X_AXIS);
		Box box2 = new Box(BoxLayout.Y_AXIS);
		box2.add(Box.createGlue());
		box2.add(new JSeparator(JSeparator.HORIZONTAL));
		box2.add(Box.createGlue());
		box.add(box2);
		JLabel l = new JLabel(jEdit.getProperty(label));
		l.setMaximumSize(l.getPreferredSize());
		box.add(l);
		Box box3 = new Box(BoxLayout.Y_AXIS);
		box3.add(Box.createGlue());
		box3.add(new JSeparator(JSeparator.HORIZONTAL));
		box3.add(Box.createGlue());
		box.add(box3);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);

		gridBag.setConstraints(box,cons);
		add(box);
	} 

	

	
	private String name;
	
}
"
jEdit,4,org.gjt.sp.jedit.gui.ErrorListCellRenderer,4,4,0,2,24,0,1,1,3,0.444444444,195,1.0,0,0.995377504,0.375,1,3,46.25,2,1.25,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;


class ErrorListCellRenderer extends JComponent implements ListCellRenderer
{
	
	ErrorListCellRenderer()
	{
		plainFont = UIManager.getFont(""Label.font"");
		boldFont = new Font(plainFont.getName(),Font.BOLD,plainFont.getSize());
		plainFM = getFontMetrics(plainFont);
		boldFM = getFontMetrics(boldFont);

		setBorder(new EmptyBorder(2,2,2,2));
	} 

	
	public Component getListCellRendererComponent(JList list, Object value,
		int index, boolean isSelected, boolean cellHasFocus)
	{
		ErrorListDialog.ErrorEntry entry = (ErrorListDialog.ErrorEntry)value;
		this.path = entry.path + "":"";
		this.messages = entry.messages;
		return this;
	} 

	
	public Dimension getPreferredSize()
	{
		int width = boldFM.stringWidth(path);
		int height = boldFM.getHeight();
		for(int i = 0; i < messages.length; i++)
		{
			width = Math.max(plainFM.stringWidth(messages[i]),width);
			height += plainFM.getHeight();
		}

		Insets insets = getBorder().getBorderInsets(this);
		width += insets.left + insets.right;
		height += insets.top + insets.bottom;

		return new Dimension(width,height);
	} 

	
	public void paintComponent(Graphics g)
	{
		Insets insets = getBorder().getBorderInsets(this);
		g.setFont(boldFont);
		g.drawString(path,insets.left,insets.top + boldFM.getAscent());
		int y = insets.top + boldFM.getHeight() + 2;
		g.setFont(plainFont);
		for(int i = 0; i < messages.length; i++)
		{
			g.drawString(messages[i],insets.left,y + plainFM.getAscent());
			y += plainFM.getHeight();
		}
	} 

	
	private String path;
	private String[] messages;
	private Font plainFont;
	private Font boldFont;
	private FontMetrics plainFM;
	private FontMetrics boldFM;
	
}
"
jEdit,4,org.gjt.sp.jedit.io.BufferIORequest,11,2,0,13,104,11,2,13,3,0.914285714,1460,0.333333333,3,0.333333333,0.236363636,0,0,129.8181818,19,5.4545,0,"

package org.gjt.sp.jedit.io;


import javax.swing.text.Segment;
import java.io.*;
import java.util.zip.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



public class BufferIORequest extends WorkRequest
{
	
	
	public static final int IOBUFSIZE = 32768;

	
	public static final int PROGRESS_INTERVAL = 300;

	public static final String LOAD_DATA = ""BufferIORequest__loadData"";
	public static final String END_OFFSETS = ""BufferIORequest__endOffsets"";
	public static final String NEW_PATH = ""BufferIORequest__newPath"";

	
	public static final String ERROR_OCCURRED = ""BufferIORequest__error"";

	
	public static final int LOAD = 0;

	
	public static final int SAVE = 1;

	
	public static final int AUTOSAVE = 2;

	
	public static final int INSERT = 3;

	
	public static final int GZIP_MAGIC_1 = 0x1f;
	public static final int GZIP_MAGIC_2 = 0x8b;
	public static final int UNICODE_MAGIC_1 = 0xfe;
	public static final int UNICODE_MAGIC_2 = 0xff;
	

	
	
	public BufferIORequest(int type, View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		this.type = type;
		this.view = view;
		this.buffer = buffer;
		this.session = session;
		this.vfs = vfs;
		this.path = path;

		markersPath = vfs.getParentOfPath(path)
			+ '.' + vfs.getFileName(path)
			+ "".marks"";
	} 

	
	public void run()
	{
		switch(type)
		{
		case LOAD:
			load();
			break;
		case SAVE:
			save();
			break;
		case AUTOSAVE:
			autosave();
			break;
		case INSERT:
			insert();
			break;
		}
	} 

	
	public String toString()
	{
		String typeString;
		switch(type)
		{
		case LOAD:
			typeString = ""LOAD"";
			break;
		case SAVE:
			typeString = ""SAVE"";
			break;
		case AUTOSAVE:
			typeString = ""AUTOSAVE"";
			break;
		default:
			typeString = ""UNKNOWN!!!"";
		}

		return getClass().getName() + ""[type="" + typeString
			+ "",buffer="" + buffer + ""]"";
	} 

	

	
	private int type;
	private View view;
	private Buffer buffer;
	private Object session;
	private VFS vfs;
	private String path;
	private String markersPath;
	

	
	private void load()
	{
		InputStream in = null;

		try
		{
			try
			{
				String[] args = { vfs.getFileName(path) };
				setStatus(jEdit.getProperty(""vfs.status.load"",args));
				setAbortable(true);
				setProgressValue(0);

				path = vfs._canonPath(session,path,view);

				VFS.DirectoryEntry entry = vfs._getDirectoryEntry(
					session,path,view);
				long length;
				if(entry != null)
					length = entry.length;
				else
					length = 0L;

				in = vfs._createInputStream(session,path,false,view);
				if(in == null)
				{
					System.err.println(""in = null"");
					return;
				}

				in = new BufferedInputStream(in);

				if(in.markSupported())
				{
					in.mark(2);
					int b1 = in.read();
					int b2 = in.read();
					in.reset();

					if(b1 == GZIP_MAGIC_1 && b2 == GZIP_MAGIC_2)
					{
						in = new GZIPInputStream(in);
						buffer.setBooleanProperty(Buffer.GZIPPED,true);
					}
					else if((b1 == UNICODE_MAGIC_1 && b2 == UNICODE_MAGIC_2)
						|| (b1 == UNICODE_MAGIC_2 && b2 == UNICODE_MAGIC_1))
					{
						buffer.setProperty(Buffer.ENCODING,""Unicode"");
					}
				}
				else if(path.toLowerCase().endsWith("".gz""))
					in = new GZIPInputStream(in);

				read(buffer,in,length);
				buffer.setNewFile(false);
			}
			catch(CharConversionException ch)
			{
				Log.log(Log.ERROR,this,ch);
				Object[] pp = { buffer.getProperty(Buffer.ENCODING),
					ch.toString() };
				VFSManager.error(view,path,""ioerror.encoding-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				Object[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(OutOfMemoryError oom)
			{
				Log.log(Log.ERROR,this,oom);
				VFSManager.error(view,path,""out-of-memory-error"",null);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}

			if(jEdit.getBooleanProperty(""persistentMarkers""))
			{
				try
				{
					String[] args = { vfs.getFileName(path) };
					setStatus(jEdit.getProperty(""vfs.status.load-markers"",args));
					setAbortable(true);

					in = vfs._createInputStream(session,markersPath,true,view);
					if(in != null)
						readMarkers(buffer,in);
				}
				catch(IOException io)
				{
					
				}
			}
		}
		catch(WorkThread.Abort a)
		{
			if(in != null)
			{
				try
				{
					in.close();
				}
				catch(IOException io)
				{
				}
			}

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} 

	
	private void read(Buffer buffer, InputStream _in, long length)
		throws IOException
	{
		IntegerArray endOffsets = new IntegerArray();

		
		boolean trackProgress = (length != 0);
		File file = buffer.getFile();

		setProgressValue(0);
		setProgressMaximum((int)length);

		
		
		if(length == 0)
			length = IOBUFSIZE;

		SegmentBuffer seg = new SegmentBuffer((int)length + 1);

		InputStreamReader in = new InputStreamReader(_in,
			buffer.getStringProperty(Buffer.ENCODING));
		char[] buf = new char[IOBUFSIZE];

		
		
		
		
		int len;

		
		
		boolean CRLF = false;

		
		boolean CROnly = false;

		
		
		
		boolean lastWasCR = false;

		
		
		int lineCount = 0;

		while((len = in.read(buf,0,buf.length)) != -1)
		{
			
			
			
			int lastLine = 0;

			for(int i = 0; i < len; i++)
			{
				
				switch(buf[i])
				{
				case '\r':
					
					
					
					
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
					}
					
					
					
					else
					{
						lastWasCR = true;
					}

					
					seg.append(buf,lastLine,i -
						lastLine);
					endOffsets.add(seg.count);
					seg.append('\n');
					if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
						setProgressValue(seg.count);

					
					
					lastLine = i + 1;
					break;
				case '\n':
					
					
					
					
					
					
					
					if(lastWasCR)
					{
						CROnly = false;
						CRLF = true;
						lastWasCR = false;
						
						
						
						
						lastLine = i + 1;
					}
					
					
					
					
					else
					{
						CROnly = false;
						CRLF = false;
						seg.append(buf,lastLine,
							i - lastLine);
						endOffsets.add(seg.count);
						seg.append('\n');
						if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
							setProgressValue(seg.count);
						lastLine = i + 1;
					}
					break;
				default:
					
					
					
					
					
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
						lastWasCR = false;
					}
					break;
				}
			}

			if(trackProgress)
				setProgressValue(seg.count);

			
			seg.append(buf,lastLine,len - lastLine);
		}

		setAbortable(false);

		String lineSeparator;
		if(CRLF)
			lineSeparator = ""\r\n"";
		else if(CROnly)
			lineSeparator = ""\r"";
		else
			lineSeparator = ""\n"";

		in.close();

		
		int bufferLength = seg.count;
		if(bufferLength != 0)
		{
			char ch = seg.array[bufferLength - 1];
			if(ch == 0x1a )
				seg.count--;
		}

		buffer.setBooleanProperty(Buffer.TRAILING_EOL,false);
		if(bufferLength != 0)
		{
			char ch = seg.array[bufferLength - 1];
			if(ch == '\n')
			{
				buffer.setBooleanProperty(Buffer.TRAILING_EOL,true);
				seg.count--;
				endOffsets.setSize(endOffsets.getSize() - 1);
			}
		}

		
		
		
		buffer.setProperty(LOAD_DATA,seg);
		buffer.setProperty(END_OFFSETS,endOffsets);
		buffer.setProperty(NEW_PATH,path);
		buffer.setProperty(Buffer.LINESEP,lineSeparator);
	} 

	
	private void readMarkers(Buffer buffer, InputStream _in)
		throws IOException
	{
		
		buffer.removeAllMarkers();

		BufferedReader in = new BufferedReader(new InputStreamReader(_in));

		String line;
		while((line = in.readLine()) != null)
		{
			
			if(!line.startsWith(""!""))
				continue;

			char shortcut = line.charAt(1);
			int start = line.indexOf(';');
			int end = line.indexOf(';',start + 1);
			int position = Integer.parseInt(line.substring(start + 1,end));
			buffer.addMarker(shortcut,position);
		}

		in.close();
	} 

	
	private void save()
	{
		OutputStream out = null;

		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.save"",args));

			
			setAbortable(true);

			try
			{
				path = vfs._canonPath(session,path,view);

				buffer.readLock();

				
				if(buffer.getProperty(Buffer.BACKED_UP) == null 
					|| jEdit.getBooleanProperty(""backupEverySave""))
				{
					vfs._backup(session,path,view);
					buffer.setBooleanProperty(Buffer.BACKED_UP,true);
				}

				
				String savePath;

				boolean twoStageSave = (vfs.getCapabilities() & VFS.RENAME_CAP) != 0
					&& jEdit.getBooleanProperty(""twoStageSave"");
				if(twoStageSave)
				{
					savePath = MiscUtilities.constructPath(
						vfs.getParentOfPath(path),
						'#' + vfs.getFileName(path)
						+ ""#save#"");
				}
				else
					savePath = path;

				out = vfs._createOutputStream(session,savePath,view);
				if(out != null)
				{
					
					
					
					if(savePath.endsWith("".gz""))
						buffer.setBooleanProperty(Buffer.GZIPPED,true);

					if(buffer.getBooleanProperty(Buffer.GZIPPED))
						out = new GZIPOutputStream(out);

					write(buffer,out);

					if(twoStageSave)
					{
						if(!vfs._rename(session,savePath,path,view))
							throw new IOException(path);
					}
				}
				else
					buffer.setBooleanProperty(ERROR_OCCURRED,true);

				
				
				if((vfs.getCapabilities() & VFS.DELETE_CAP) != 0)
				{
					if(jEdit.getBooleanProperty(""persistentMarkers"")
						&& buffer.getMarkers().size() != 0)
					{
						setStatus(jEdit.getProperty(""vfs.status.save-markers"",args));
						setProgressValue(0);
						out = vfs._createOutputStream(session,markersPath,view);
						if(out != null)
							writeMarkers(buffer,out);
					}
					else
						vfs._delete(session,markersPath,view);
				}
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.write-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			finally
			{
				buffer.readUnlock();
			}
		}
		catch(WorkThread.Abort a)
		{
			if(out != null)
			{
				try
				{
					out.close();
				}
				catch(IOException io)
				{
				}
			}

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._saveComplete(session,buffer,view);
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.write-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} 

	
	private void autosave()
	{
		OutputStream out = null;

		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.autosave"",args));

			
			setAbortable(true);

			try
			{
				

				if(!buffer.isDirty())
				{
					
					
					return;
				}

				out = vfs._createOutputStream(session,path,view);
				if(out == null)
					return;

				write(buffer,out);
			}
			catch(Exception e)
			{
			}
			finally
			{
				
			}
		}
		catch(WorkThread.Abort a)
		{
			if(out != null)
			{
				try
				{
					out.close();
				}
				catch(IOException io)
				{
				}
			}
		}
	} 

	
	private void write(Buffer buffer, OutputStream _out)
		throws IOException
	{
		BufferedWriter out = new BufferedWriter(
			new OutputStreamWriter(_out,
				buffer.getStringProperty(Buffer.ENCODING)),
				IOBUFSIZE);
		Segment lineSegment = new Segment();
		String newline = buffer.getStringProperty(Buffer.LINESEP);
		if(newline == null)
			newline = System.getProperty(""line.separator"");

		setProgressMaximum(buffer.getLineCount() / PROGRESS_INTERVAL);
		setProgressValue(0);

		int i = 0;
		while(i < buffer.getLineCount())
		{
			buffer.getLineText(i,lineSegment);
			out.write(lineSegment.array,lineSegment.offset,
				lineSegment.count);

			if(i != buffer.getLineCount() - 1
				|| buffer.getBooleanProperty(Buffer.TRAILING_EOL))
			{
				out.write(newline);
			}

			if(++i % PROGRESS_INTERVAL == 0)
				setProgressValue(i / PROGRESS_INTERVAL);
		}
		out.close();
	} 

	
	private void writeMarkers(Buffer buffer, OutputStream out)
		throws IOException
	{
		Writer o = new BufferedWriter(new OutputStreamWriter(out));
		Vector markers = buffer.getMarkers();
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			o.write('!');
			o.write(marker.getShortcut());
			o.write(';');

			String pos = String.valueOf(marker.getPosition());
			o.write(pos);
			o.write(';');
			o.write(pos);
			o.write('\n');
		}
		o.close();
	} 

	
	private void insert()
	{
		InputStream in = null;

		try
		{
			try
			{
				String[] args = { vfs.getFileName(path) };
				setStatus(jEdit.getProperty(""vfs.status.load"",args));
				setAbortable(true);

				path = vfs._canonPath(session,path,view);

				VFS.DirectoryEntry entry = vfs._getDirectoryEntry(
					session,path,view);
				long length;
				if(entry != null)
					length = entry.length;
				else
					length = 0L;

				in = vfs._createInputStream(session,path,false,view);
				if(in == null)
					return;

				if(path.endsWith("".gz""))
					in = new GZIPInputStream(in);

				read(buffer,in,length);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
		catch(WorkThread.Abort a)
		{
			if(in != null)
			{
				try
				{
					in.close();
				}
				catch(IOException io)
				{
				}
			}

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.Macros,28,1,0,25,104,312,7,21,22,0.875,721,1.0,2,0.0,0.114478114,0,0,24.46428571,8,2.25,4,"

package org.gjt.sp.jedit;


import gnu.regexp.RE;
import javax.swing.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.util.Log;



public class Macros
{
	
	
	public static void message(Component comp, String message)
	{
		GUIUtilities.hideSplashScreen();

		JOptionPane.showMessageDialog(comp,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.INFORMATION_MESSAGE);
	} 

	
	
	public static void error(Component comp, String message)
	{
		GUIUtilities.hideSplashScreen();

		JOptionPane.showMessageDialog(comp,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.ERROR_MESSAGE);
	} 

	
	
	public static String input(Component comp, String prompt)
	{
		GUIUtilities.hideSplashScreen();

		return input(comp,prompt,null);
	} 

	
	
	public static String input(Component comp, String prompt, String defaultValue)
	{
		GUIUtilities.hideSplashScreen();

		return (String)JOptionPane.showInputDialog(comp,prompt,
			jEdit.getProperty(""macro-input.title""),
			JOptionPane.QUESTION_MESSAGE,null,null,defaultValue);
	} 

	
	
	public static int confirm(Component comp, String prompt, int buttons)
	{
		GUIUtilities.hideSplashScreen();

		return JOptionPane.showConfirmDialog(comp,prompt,
			jEdit.getProperty(""macro-confirm.title""),buttons,
			JOptionPane.QUESTION_MESSAGE);
	} 

	
	
	public static int confirm(Component comp, String prompt, int buttons, int type)
	{
		GUIUtilities.hideSplashScreen();

		return JOptionPane.showConfirmDialog(comp,prompt,
			jEdit.getProperty(""macro-confirm.title""),buttons,type);
	} 

	
	
	public static void browseSystemMacros(View view)
	{
		if(systemMacroPath == null)
		{
			GUIUtilities.error(view,""no-webstart"",null);
			return;
		}

		VFSBrowser.browseDirectory(view,systemMacroPath);
	} 

	
	
	public static void browseUserMacros(View view)
	{
		if(userMacroPath == null)
		{
			GUIUtilities.error(view,""no-settings"",null);
			return;
		}

		VFSBrowser.browseDirectory(view,userMacroPath);
	} 

	
	
	public static void loadMacros()
	{
		macroActionSet.removeAllActions();
		macroHierarchy.removeAllElements();
		macroHash.clear();

		if(jEdit.getJEditHome() != null)
		{
			systemMacroPath = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""macros"");
			loadMacros(macroHierarchy,"""",new File(systemMacroPath));
		}

		String settings = jEdit.getSettingsDirectory();

		if(settings != null)
		{
			userMacroPath = MiscUtilities.constructPath(
				settings,""macros"");
			loadMacros(macroHierarchy,"""",new File(userMacroPath));
		}

		EditBus.send(new MacrosChanged(null));
	} 

	
	
	public static void registerHandler(Handler handler)
	{
		if (getHandler(handler.getName()) != null)
		{
			Log.log(Log.ERROR, Macros.class, ""Cannot register more than one macro handler with the same name"");
			return;
		}

		Log.log(Log.DEBUG,Macros.class,""Registered "" + handler.getName()
			+ "" macro handler"");
		macroHandlers.add(handler);
	} 

	
	
	public static Handler[] getHandlers()
	{
		Handler[] handlers = new Handler[macroHandlers.size()];
		return (Handler[])macroHandlers.toArray(handlers);
	} 

	
	
	public static Handler getHandler(String name)
	{
		Handler handler = null;
		for (int i = 0; i < macroHandlers.size(); i++)
		{
			handler = (Handler)macroHandlers.get(i);
			if (handler.getName().equals(name)) return handler;
		}

		return null;
	}
	

	
	
	public static Vector getMacroHierarchy()
	{
		return macroHierarchy;
	} 

	
	
	public static ActionSet getMacroActionSet()
	{
		return macroActionSet;
	} 

	
	
	public static Macro getMacro(String macro)
	{
		return (Macro)macroHash.get(macro);
	} 

	
	
	public static class Macro extends EditAction
	{
		
		public Macro(Handler handler, String name, String label, String path)
		{
			super(name);
			this.handler = handler;
			this.label = label;
			this.path = path;
		} 

		
		public Handler getHandler()
		{
			return handler;
		}
		

		
		public String getLabel()
		{
			return label;
		} 

		
		public String getMouseOverText()
		{
			return handler.getLabel() + "" - "" + path;
		} 

		
		public String getPath()
		{
			return path;
		} 

		
		public void invoke(View view)
		{
			lastMacro = this;
			Buffer buffer = view.getBuffer();

			try
			{
				buffer.beginCompoundEdit();

				handler.runMacro(view, this);
			}
			finally
			{
				
				if(buffer.insideCompoundEdit())
					buffer.endCompoundEdit();
			}
		} 

		
		public String getCode()
		{
			return ""Macros.getMacro(\"""" + getName() + ""\"").invoke(view);"";
		} 

		
		public static String macroNameToLabel(String macroName)
		{
			int index = macroName.lastIndexOf('/');
			return macroName.substring(index + 1).replace('_', ' ');
		}
		

		
		private Handler handler;
		private String path;
		private String label;
		
	} 

	
	
	public static void recordTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();

		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}
		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}

		Buffer buffer = jEdit.openFile(null,settings + File.separator
			+ ""macros"",""Temporary_Macro.bsh"",true,null);

		if(buffer == null)
			return;

		buffer.remove(0,buffer.getLength());
		buffer.insert(0,jEdit.getProperty(""macro.temp.header""));

		recordMacro(view,buffer,true);
	} 

	
	
	public static void recordMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();

		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}

		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}

		String name = GUIUtilities.input(view,""record"",null);
		if(name == null)
			return;

		name = name.replace(' ','_');

		Buffer buffer = jEdit.openFile(null,null,
			MiscUtilities.constructPath(settings,""macros"",
			name + "".bsh""),true,null);

		if(buffer == null)
			return;

		buffer.remove(0,buffer.getLength());
		buffer.insert(0,jEdit.getProperty(""macro.header""));

		recordMacro(view,buffer,false);
	} 

	
	
	public static void stopRecording(View view)
	{
		InputHandler inputHandler = view.getInputHandler();
		Recorder recorder = view.getMacroRecorder();

		if(recorder == null)
			GUIUtilities.error(view,""macro-not-recording"",null);
		else
		{
			view.setMacroRecorder(null);
			if(!recorder.temporary)
				view.setBuffer(recorder.buffer);
			recorder.dispose();
		}
	} 

	
	
	public static void runTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();

		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}

		String path = MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(),""macros"",
			""Temporary_Macro.bsh"");

		Handler handler = getHandler(""beanshell"");
		Macro temp = handler.createMacro(path,path);

		Buffer buffer = view.getBuffer();

		try
		{
			buffer.beginCompoundEdit();
			temp.invoke(view);
		}
		finally
		{
			
			if(buffer.insideCompoundEdit())
				buffer.endCompoundEdit();
		}
	} 

	
	
	public static void runLastMacro(View view)
	{
		if(lastMacro == null)
			view.getToolkit().beep();
		else
			lastMacro.invoke(view);
	} 

	
	
	public static void showRunScriptDialog(View view)
	{
		String[] paths = GUIUtilities.showVFSFileDialog(view,
			null,JFileChooser.OPEN_DIALOG,true);
		if(paths != null)
		{
			Buffer buffer = view.getBuffer();
			try
			{
				buffer.beginCompoundEdit();

file_loop:			for(int i = 0; i < paths.length; i++)
				{
					String path = paths[i];

					Handler handler;

					for (int j = 0; j < macroHandlers.size(); j++)
					{
						handler = (Handler)macroHandlers.get(j);

						if (handler.accept(path))
						{
							Macro macro = handler.createMacro(path,path);
							macro.invoke(view);
							continue file_loop;
						}
					}

					
					
					
					Log.log(Log.WARNING,Macros.class,path +
						"": Cannot find a suitable macro handler""
						+ "", assuming BeanShell"");
					getHandler(""beanshell"").createMacro(
						path,path).invoke(view);
				}
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} 

	

	
	private static String systemMacroPath;
	private static String userMacroPath;

	private static ArrayList macroHandlers;

	private static ActionSet macroActionSet;
	private static Vector macroHierarchy;
	private static Hashtable macroHash;
	private static Macro lastMacro;
	

	
	static
	{
		macroHandlers = new ArrayList();
		registerHandler(new BeanShellHandler());
		macroActionSet = new ActionSet(jEdit.getProperty(""action-set.macros""));
		jEdit.addActionSet(macroActionSet);
		macroHierarchy = new Vector();
		macroHash = new Hashtable();
	} 

	
	private static void loadMacros(Vector vector, String path, File directory)
	{
		File[] macroFiles = directory.listFiles();
		if(macroFiles == null || macroFiles.length == 0)
			return;

		MiscUtilities.quicksort(macroFiles,new MiscUtilities.StringICaseCompare());

		for(int i = 0; i < macroFiles.length; i++)
		{
			File file = macroFiles[i];
			String fileName = file.getName();
			if(file.isHidden())
			{
				
				continue;
			}
			else if(file.isDirectory())
			{
				Vector submenu = new Vector();
				submenu.addElement(fileName.replace('_',' '));
				loadMacros(submenu,path + fileName + '/',file);
				if(submenu.size() != 1)
					vector.addElement(submenu);
			}
			else
			{
				Handler handler;
				for (int j = 0; j < macroHandlers.size(); j++)
				{
					handler = (Handler)macroHandlers.get(j);
					try
					{
						if (handler.accept(fileName))
						{
							Macro newMacro = handler.createMacro(
								path + fileName, file.getPath());
							vector.addElement(newMacro);
							macroActionSet.addAction(newMacro);
							macroHash.put(newMacro.getName(),newMacro);
							break;
						}
					}
					catch (Exception e)
					{
						Log.log(Log.ERROR, Macros.class, e);
						macroHandlers.remove(handler);
						j--;
						continue;
					}
				}
			}
		}
	} 

	
	
	private static void recordMacro(View view, Buffer buffer, boolean temporary)
	{
		Handler handler = getHandler(""beanshell"");
		String path = buffer.getPath();
		lastMacro = handler.createMacro(path,path);

		view.setMacroRecorder(new Recorder(view,buffer,temporary));

		
		
		view.getStatus().setMessage(null);
	} 

	

	
	public static class Recorder implements EBComponent
	{
		View view;
		Buffer buffer;
		boolean temporary;

		boolean lastWasInput;

		
		public Recorder(View view, Buffer buffer, boolean temporary)
		{
			this.view = view;
			this.buffer = buffer;
			this.temporary = temporary;
			EditBus.addToBus(this);
		} 

		
		public void record(String code)
		{
			if(lastWasInput)
			{
				lastWasInput = false;
				append(""\"");"");
			}

			append(""\n"");
			append(code);
		} 

		
		public void record(int repeat, String code)
		{
			if(repeat == 1)
				record(code);
			else
			{
				record(""for(int i = 1; i <= "" + repeat + ""; i++)\n""
					+ ""{\n""
					+ code + ""\n""
					+ ""}"");
			}
		} 

		
		public void record(int repeat, char ch)
		{
			
			
			if(ch == '\n')
				record(repeat,""textArea.userInput(\'\\n\');"");
			else if(ch == '\t')
				record(repeat,""textArea.userInput(\'\\t\');"");
			else
			{
				StringBuffer buf = new StringBuffer();
				for(int i = 0; i < repeat; i++)
					buf.append(ch);
				String charStr = MiscUtilities.charsToEscapes(buf.toString());

				if(lastWasInput)
					append(charStr);
				else
				{
					append(""\ntextArea.setSelectedText(\"""" + charStr);
					lastWasInput = true;
				}
			}
		} 

		
		public void handleMessage(EBMessage msg)
		{
			if(msg instanceof BufferUpdate)
			{
				BufferUpdate bmsg = (BufferUpdate)msg;
				if(bmsg.getWhat() == BufferUpdate.CLOSED)
				{
					if(bmsg.getBuffer() == buffer)
						stopRecording(view);
				}
			}
		} 

		
		private void append(String str)
		{
			buffer.insert(buffer.getLength(),str);
		} 

		
		private void dispose()
		{
			if(lastWasInput)
			{
				lastWasInput = false;
				append(""\"");"");
			}

			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				buffer.indentLine(i,true,true);
			}

			EditBus.removeFromBus(this);

			
			
			view.getStatus().setMessage(null);
		} 
	} 

	
	
	public static abstract class Handler
	{
		
		public String getName()
		{
			return name;
		} 

		
		public String getLabel()
		{
			return label;
		} 

		
		public boolean accept(String name)
		{
			return filter.isMatch(name);
		} 

		
		public abstract Macro createMacro(String macroName, String path);
		

		
		public abstract void runMacro(View view, Macro macro);
		

		
		protected Handler(String name)
		{
			this.name = name;
			label = jEdit.getProperty(""macro-handler.""
				+ name + "".label"", name);
			try
			{
				filter = new RE(MiscUtilities.globToRE(
					jEdit.getProperty(
					""macro-handler."" + name + "".glob"")));
			}
			catch (Exception e)
			{
				throw new InternalError(""Missing or invalid glob for handler "" + name);
			}
		} 

		
		private String name;
		private String label;
		private RE filter;
		
	}
	

	
	static class BeanShellHandler extends Handler
	{
		
		BeanShellHandler()
		{
			super(""beanshell"");
		}
		

		
		public Macro createMacro(String macroName, String path)
		{
			
			macroName = macroName.substring(0, macroName.length() - 4);

			return new Macro(this, macroName,
				Macro.macroNameToLabel(macroName), path);
		}
		

		
		public void runMacro(View view, Macro macro)
		{
			BeanShell.runScript(view,macro.getPath(),null,true);
		}
		
	}
	
}
"
jEdit,4,org.gjt.sp.jedit.buffer.BufferChangeListener,4,1,0,4,4,6,4,1,4,2.0,4,0.0,0,0.0,0.916666667,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.Buffer;


public interface BufferChangeListener
{
	
	
	void foldLevelChanged(Buffer buffer, int startLine, int endLine);
	

	
	
	void contentInserted(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void contentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void transactionComplete(Buffer buffer);
	
}
"
jEdit,4,org.gjt.sp.jedit.options.OverviewOptionPane,3,6,0,3,16,3,1,2,3,2.0,50,0.0,0,0.996987952,1.0,2,4,15.66666667,1,0.6667,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.*;
import java.io.IOException;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class OverviewOptionPane extends AbstractOptionPane
{
	
	public OverviewOptionPane()
	{
		super(""overview"");
	} 

	
	public void _init()
	{
		setLayout(new BorderLayout());
		JEditorPane ep = new JEditorPane();
		try
		{
			ep.setPage(getClass().getResource(""overview.html""));
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
		}
		ep.setEditable(false);
		JScrollPane scroller = new JScrollPane(ep);
		scroller.setPreferredSize(new Dimension(400,0));
		add(BorderLayout.CENTER,scroller);
	} 

	
	public void _save() {}
	
}
"
jEdit,4,org.gjt.sp.jedit.gui.FontSelector,3,6,0,6,18,3,5,2,1,2.0,67,0.0,0,0.997382199,0.444444444,0,0,21.33333333,2,1.0,0,"

package org.gjt.sp.jedit.gui;


import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.jEdit;




public class FontSelector extends JButton
{
	
	public FontSelector(Font font)
	{
		setFont(font);

		updateText();

		setRequestFocusEnabled(false);

		addActionListener(new ActionHandler());
	} 

	
	private void updateText()
	{
		Font font = getFont();
		String styleString;
		switch(font.getStyle())
		{
		case Font.PLAIN:
			styleString = jEdit.getProperty(""font-selector.plain"");
			break;
		case Font.BOLD:
			styleString = jEdit.getProperty(""font-selector.bold"");
			break;
		case Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.italic"");
			break;
		case Font.BOLD | Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.bolditalic"");
			break;
		default:
			styleString = ""UNKNOWN!!!???"";
			break;
		}

		setText(font.getName() + "" "" + font.getSize() + "" "" + styleString);
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Font font = new FontSelectorDialog(FontSelector.this,getFont())
				.getSelectedFont();
			if(font != null)
			{
				setFont(font);
				updateText();
			}
		}
	} 
} 


class FontSelectorDialog extends EnhancedDialog
{
	
	public FontSelectorDialog(Component comp, Font font)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""font-selector.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JPanel listPanel = new JPanel(new GridLayout(1,3,6,6));

		JPanel familyPanel = createTextFieldAndListPanel(
			""font-selector.family"",
			familyField = new JTextField(),
			familyList = new JList(getFontList()));
		listPanel.add(familyPanel);

		String[] sizes = { ""9"", ""10"", ""12"", ""14"", ""16"", ""18"", ""24"" };
		JPanel sizePanel = createTextFieldAndListPanel(
			""font-selector.size"",
			sizeField = new JTextField(),
			sizeList = new JList(sizes));
		listPanel.add(sizePanel);

		String[] styles = {
			jEdit.getProperty(""font-selector.plain""),
			jEdit.getProperty(""font-selector.bold""),
			jEdit.getProperty(""font-selector.italic""),
			jEdit.getProperty(""font-selector.bolditalic"")
		};

		JPanel stylePanel = createTextFieldAndListPanel(
			""font-selector.style"",
			styleField = new JTextField(),
			styleList = new JList(styles));
		styleField.setEditable(false);
		listPanel.add(stylePanel);

		familyList.setSelectedValue(font.getFamily(),true);
		familyField.setText(font.getFamily());
		sizeList.setSelectedValue(String.valueOf(font.getSize()),true);
		sizeField.setText(String.valueOf(font.getSize()));
		styleList.setSelectedIndex(font.getStyle());
		styleField.setText((String)styleList.getSelectedValue());

		ListHandler listHandler = new ListHandler();
		familyList.addListSelectionListener(listHandler);
		sizeList.addListSelectionListener(listHandler);
		styleList.addListSelectionListener(listHandler);

		content.add(BorderLayout.NORTH,listPanel);

		preview = new JLabel(jEdit.getProperty(""font-selector.long-text""));
		preview.setBorder(new TitledBorder(jEdit.getProperty(
			""font-selector.preview"")));

		updatePreview();

		Dimension prefSize = preview.getPreferredSize();
		prefSize.height = 50;
		preview.setPreferredSize(prefSize);

		content.add(BorderLayout.CENTER,preview);

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		buttons.add(ok);

		buttons.add(Box.createHorizontalStrut(6));

		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);

		buttons.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,buttons);

		pack();
		setLocationRelativeTo(JOptionPane.getFrameForComponent(comp));
		show();
	} 

	
	public void ok()
	{
		isOK = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public Font getSelectedFont()
	{
		if(!isOK)
			return null;

		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 12;
		}

		return new Font(familyField.getText(),styleList
			.getSelectedIndex(),size);
	} 

	

	
	private boolean isOK;
	private JTextField familyField;
	private JList familyList;
	private JTextField sizeField;
	private JList sizeList;
	private JTextField styleField;
	private JList styleList;
	private JLabel preview;
	private JButton ok;
	private JButton cancel;
	

	
	private static final String[] HIDEFONTS = {
		"".bold"",
		"".italic""
	};

	
	private String[] getFontList()
	{
		String[] nameArray = GraphicsEnvironment
			.getLocalGraphicsEnvironment()
			.getAvailableFontFamilyNames();
		Vector nameVector = new Vector(nameArray.length);

		for(int i = 0, j; i < nameArray.length; i++)
		{
			for(j = 0; j < HIDEFONTS.length; j++)
			{
				if(nameArray[i].indexOf(HIDEFONTS[j]) >= 0)
					break;
			}

			if(j == HIDEFONTS.length)
				nameVector.addElement(nameArray[i]);
		}

		String[] _array = new String[nameVector.size()];
		nameVector.copyInto(_array);
		return _array;
	} 

	
	private JPanel createTextFieldAndListPanel(String label,
		JTextField textField, JList list)
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridx = cons.gridy = 0;
		cons.gridwidth = cons.gridheight = 1;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = 1.0f;

		JLabel _label = new JLabel(jEdit.getProperty(label));
		layout.setConstraints(_label,cons);
		panel.add(_label);

		cons.gridy = 1;
		Component vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);

		cons.gridy = 2;
		layout.setConstraints(textField,cons);
		panel.add(textField);

		cons.gridy = 3;
		vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);

		cons.gridy = 4;
		cons.gridheight = GridBagConstraints.REMAINDER;
		cons.weighty = 1.0f;
		JScrollPane scroller = new JScrollPane(list);
		layout.setConstraints(scroller,cons);
		panel.add(scroller);

		return panel;
	} 

	
	private void updatePreview()
	{
		String family = familyField.getText();
		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 12;
		}
		int style = styleList.getSelectedIndex();

		preview.setFont(new Font(family,style,size));
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				ok();
			else if(evt.getSource() == cancel)
				cancel();
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object source = evt.getSource();
			if(source == familyList)
			{
				String family = (String)familyList.getSelectedValue();
				if(family != null)
					familyField.setText(family);
			}
			else if(source == sizeList)
			{
				String size = (String)sizeList.getSelectedValue();
				if(size != null)
					sizeField.setText(size);
			}
			else if(source == styleList)
			{
				String style = (String)styleList.getSelectedValue();
				if(style != null)
					styleField.setText(style);
			}

			updatePreview();
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.textarea.TextAreaExtension,4,1,5,9,5,6,9,0,4,2.0,11,0.0,0,0.0,0.75,0,0,1.75,1,0.75,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;


public abstract class TextAreaExtension
{
	
	
	public void paintValidLine(Graphics2D gfx, int screenLine,
		int physicalLine, int start, int end, int y) {} 

	
	
	public void paintInvalidLine(Graphics2D gfx, int screenLine,
		int y) {} 

	
	
	public String getToolTipText(int x, int y)
	{
		return null;
	} 
}
"
jEdit,4,org.gjt.sp.jedit.search.SearchAndReplace,33,1,0,36,121,228,10,29,30,0.646875,1520,1.0,2,0.0,0.136363636,0,0,44.75757576,27,3.7879,1,"

package org.gjt.sp.jedit.search;


import javax.swing.text.Segment;
import javax.swing.JOptionPane;
import java.awt.Component;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class SearchAndReplace
{
	

	
	
	public static void setSearchString(String search)
	{
		if(search.equals(SearchAndReplace.search))
			return;

		SearchAndReplace.search = search;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static String getSearchString()
	{
		return search;
	} 

	
	
	public static void setReplaceString(String replace)
	{
		if(replace.equals(SearchAndReplace.replace))
			return;

		SearchAndReplace.replace = replace;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static String getReplaceString()
	{
		return replace;
	} 

	
	
	public static void setIgnoreCase(boolean ignoreCase)
	{
		if(ignoreCase == SearchAndReplace.ignoreCase)
			return;

		SearchAndReplace.ignoreCase = ignoreCase;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getIgnoreCase()
	{
		return ignoreCase;
	} 

	
	
	public static void setRegexp(boolean regexp)
	{
		if(regexp == SearchAndReplace.regexp)
			return;

		SearchAndReplace.regexp = regexp;
		if(regexp && reverse)
			reverse = false;

		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getRegexp()
	{
		return regexp;
	} 

	
	
	public static void setReverseSearch(boolean reverse)
	{
		if(reverse == SearchAndReplace.reverse)
			return;

		SearchAndReplace.reverse = (regexp ? false : reverse);

		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getReverseSearch()
	{
		return reverse;
	} 

	
	
	public static void setBeanShellReplace(boolean beanshell)
	{
		if(beanshell == SearchAndReplace.beanshell)
			return;

		SearchAndReplace.beanshell = beanshell;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getBeanShellReplace()
	{
		return beanshell;
	} 

	
	
	public static void setAutoWrapAround(boolean wrap)
	{
		if(wrap == SearchAndReplace.wrap)
			return;

		SearchAndReplace.wrap = wrap;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getAutoWrapAround()
	{
		return wrap;
	} 

	
	
	public static void setSearchMatcher(SearchMatcher matcher)
	{
		SearchAndReplace.matcher = matcher;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static SearchMatcher getSearchMatcher()
		throws Exception
	{
		return getSearchMatcher(true);
	} 

	
	
	public static SearchMatcher getSearchMatcher(boolean reverseOK)
		throws Exception
	{
		reverseOK &= (fileset instanceof CurrentBufferSet);

		if(matcher != null && (reverseOK || !reverse))
			return matcher;

		if(search == null || """".equals(search))
			return null;

		
		String replace = (SearchAndReplace.replace == null ? """" : SearchAndReplace.replace);

		String replaceMethod;
		if(beanshell && replace.length() != 0)
		{
			replaceMethod = BeanShell.cacheBlock(""replace"",""return (""
				+ replace + "");"",false);
		}
		else
			replaceMethod = null;

		if(regexp)
			matcher = new RESearchMatcher(search,replace,ignoreCase,
				beanshell,replaceMethod);
		else
		{
			matcher = new BoyerMooreSearchMatcher(search,replace,
				ignoreCase,reverse && reverseOK,beanshell,
				replaceMethod);
		}

		return matcher;
	} 

	
	
	public static void setSearchFileSet(SearchFileSet fileset)
	{
		SearchAndReplace.fileset = fileset;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static SearchFileSet getSearchFileSet()
	{
		return fileset;
	} 

	

	

	
	
	public static boolean hyperSearch(View view)
	{
		return hyperSearch(view,false);
	} 

	
	
	public static boolean hyperSearch(View view, boolean selection)
	{
		record(view,""hyperSearch(view,"" + selection + "")"",false,
			!selection);

		view.getDockableWindowManager().addDockableWindow(
			HyperSearchResults.NAME);
		final HyperSearchResults results = (HyperSearchResults)
			view.getDockableWindowManager()
			.getDockable(HyperSearchResults.NAME);
		results.searchStarted();

		try
		{
			SearchMatcher matcher = getSearchMatcher(false);
			if(matcher == null)
			{
				view.getToolkit().beep();
				results.searchDone(0,0);
				return false;
			}

			Selection[] s;
			if(selection)
			{
				s = view.getTextArea().getSelection();
				if(s == null)
				{
					results.searchDone(0,0);
					return false;
				}
			}
			else
				s = null;
			VFSManager.runInWorkThread(new HyperSearchRequest(view,
				matcher,results,s));
			return true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
			return false;
		}
	} 

	
	
	public static boolean find(View view)
	{
		boolean repeat = false;
		String path = fileset.getNextFile(view,null);
		if(path == null)
			return false;

		try
		{
			SearchMatcher matcher = getSearchMatcher(true);
			if(matcher == null)
			{
				view.getToolkit().beep();
				return false;
			}

			record(view,""find(view)"",false,true);

			view.showWaitCursor();

loop:			for(;;)
			{
				while(path != null)
				{
					Buffer buffer = jEdit.openTemporary(
						view,null,path,false);

					
					path = fileset.getNextFile(view,path);

					if(buffer == null)
						continue loop;

					
					if(!buffer.isLoaded())
						VFSManager.waitForRequests();

					int start;

					if(view.getBuffer() == buffer && !repeat)
					{
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else if(reverse)
							start = s.getStart();
						else
							start = s.getEnd();
					}
					else if(reverse)
						start = buffer.getLength();
					else
						start = 0;

					if(find(view,buffer,start,repeat))
						return true;
				}

				if(repeat)
				{
					if(!BeanShell.isScriptRunning())
					{
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(""view.status.search-not-found""));

						view.getToolkit().beep();
					}
					return false;
				}

				boolean restart;

				if(BeanShell.isScriptRunning())
				{
					restart = true;
				}
				else if(wrap)
				{
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(""view.status.auto-wrap""));
					
					if(jEdit.getBooleanProperty(""search.beepOnSearchAutoWrap""))
					{
						view.getToolkit().beep();
					}
					restart = true;
				}
				else
				{
					Integer[] args = { new Integer(reverse ? 1 : 0) };
					int result = GUIUtilities.confirm(view,
						""keepsearching"",args,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					restart = (result == JOptionPane.YES_OPTION);
				}

				if(restart)
				{
					
					path = fileset.getFirstFile(view);
					repeat = true;
				}
				else
					break loop;
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
		}
		finally
		{
			view.hideWaitCursor();
		}

		return false;
	} 

	
	
	public static boolean find(View view, Buffer buffer, int start)
		throws Exception
	{
		return find(view,buffer,start,false);
	} 

	
	
	public static boolean find(View view, Buffer buffer, int start,
		boolean firstTime) throws Exception
	{
		SearchMatcher matcher = getSearchMatcher(true);
		if(matcher == null)
		{
			view.getToolkit().beep();
			return false;
		}

		Segment text = new Segment();
		if(reverse)
			buffer.getText(0,start,text);
		else
			buffer.getText(start,buffer.getLength() - start,text);

		
		
		
		
		
		int[] match = matcher.nextMatch(new CharIndexedSegment(text,reverse),
			start == 0,true,firstTime);

		if(match != null)
		{
			jEdit.commitTemporary(buffer);
			view.setBuffer(buffer);
			JEditTextArea textArea = view.getTextArea();

			if(reverse)
			{
				textArea.setSelection(new Selection.Range(
					start - match[1],
					start - match[0]));
				textArea.moveCaretPosition(start - match[1]);
			}
			else
			{
				textArea.setSelection(new Selection.Range(
					start + match[0],
					start + match[1]));
				textArea.moveCaretPosition(start + match[1]);
			}

			return true;
		}
		else
			return false;
	} 

	
	
	public static boolean replace(View view)
	{
		JEditTextArea textArea = view.getTextArea();

		Buffer buffer = view.getBuffer();
		if(!buffer.isEditable())
			return false;

		boolean smartCaseReplace = (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);

		Selection[] selection = textArea.getSelection();
		if(selection.length == 0)
		{
			view.getToolkit().beep();
			return false;
		}

		record(view,""replace(view)"",true,false);

		try
		{
			buffer.beginCompoundEdit();

			SearchMatcher matcher = getSearchMatcher(false);
			if(matcher == null)
				return false;

			int retVal = 0;

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];

				
				int start = s.getStart();

				if(s instanceof Selection.Range)
				{
					retVal += _replace(view,buffer,matcher,
						s.getStart(),s.getEnd(),
						smartCaseReplace);

					textArea.removeFromSelection(s);
					textArea.addToSelection(new Selection.Range(
						start,s.getEnd()));
				}
				else if(s instanceof Selection.Rect)
				{
					for(int j = s.getStartLine(); j <= s.getEndLine(); j++)
					{
						retVal += _replace(view,buffer,matcher,
							s.getStart(buffer,j),s.getEnd(buffer,j),
							smartCaseReplace);
					}
					textArea.addToSelection(new Selection.Rect(
						start,s.getEnd()));
				}
			}

			Selection s = textArea.getSelectionAtOffset(
				textArea.getCaretPosition());
			if(s != null)
				textArea.moveCaretPosition(s.getEnd());

			if(retVal == 0)
			{
				view.getToolkit().beep();
				return false;
			}

			return true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		return false;
	} 

	
	
	public static boolean replace(View view, Buffer buffer, int start, int end)
	{
		if(!buffer.isEditable())
			return false;

		boolean smartCaseReplace = (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);

		JEditTextArea textArea = view.getTextArea();

		try
		{
			buffer.beginCompoundEdit();

			SearchMatcher matcher = getSearchMatcher(false);
			if(matcher == null)
				return false;

			int retVal = 0;

			retVal += _replace(view,buffer,matcher,start,end,
				smartCaseReplace);

			if(retVal != 0)
				return true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		return false;
	} 

	
	
	public static boolean replaceAll(View view)
	{
		int fileCount = 0;
		int occurCount = 0;

		record(view,""replaceAll(view)"",true,true);

		view.showWaitCursor();

		boolean smartCaseReplace = (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);

		try
		{
			SearchMatcher matcher = getSearchMatcher(false);
			if(matcher == null)
				return false;

			String path = fileset.getFirstFile(view);
loop:			while(path != null)
			{
				Buffer buffer = jEdit.openTemporary(
					view,null,path,false);

				
				path = fileset.getNextFile(view,path);

				if(buffer == null)
					continue loop;

				
				if(buffer.isPerformingIO())
					VFSManager.waitForRequests();

				if(!buffer.isEditable())
					continue loop;

				
				
				int retVal = 0;

				try
				{
					buffer.beginCompoundEdit();
					retVal = _replace(view,buffer,matcher,
						0,buffer.getLength(),
						smartCaseReplace);
				}
				finally
				{
					buffer.endCompoundEdit();
				}

				if(retVal != 0)
				{
					fileCount++;
					occurCount += retVal;
					jEdit.commitTemporary(buffer);
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(view,""searcherror"",args);
		}
		finally
		{
			view.hideWaitCursor();
		}

		
		if(!BeanShell.isScriptRunning())
		{
			Object[] args = { new Integer(occurCount),
				new Integer(fileCount) };
			view.getStatus().setMessageAndClear(jEdit.getProperty(
				""view.status.replace-all"",args));
			if(occurCount == 0)
				view.getToolkit().beep();
		}

		return (fileCount != 0);
	} 

	

	
	
	public static void load()
	{
		search = jEdit.getProperty(""search.find.value"");
		replace = jEdit.getProperty(""search.replace.value"");
		ignoreCase = jEdit.getBooleanProperty(""search.ignoreCase.toggle"");
		regexp = jEdit.getBooleanProperty(""search.regexp.toggle"");
		beanshell = jEdit.getBooleanProperty(""search.beanshell.toggle"");
		wrap = jEdit.getBooleanProperty(""search.wrap.toggle"");

		fileset = new CurrentBufferSet();

		
		
		
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static void save()
	{
		jEdit.setProperty(""search.find.value"",search);
		jEdit.setProperty(""search.replace.value"",replace);
		jEdit.setBooleanProperty(""search.ignoreCase.toggle"",ignoreCase);
		jEdit.setBooleanProperty(""search.regexp.toggle"",regexp);
		jEdit.setBooleanProperty(""search.beanshell.toggle"",beanshell);
		jEdit.setBooleanProperty(""search.wrap.toggle"",wrap);
	} 

	

	
	private static String search;
	private static String replace;
	private static boolean regexp;
	private static boolean ignoreCase;
	private static boolean reverse;
	private static boolean beanshell;
	private static boolean wrap;
	private static SearchMatcher matcher;
	private static SearchFileSet fileset;
	

	
	private static void record(View view, String action,
		boolean replaceAction, boolean recordFileSet)
	{
		Macros.Recorder recorder = view.getMacroRecorder();

		if(recorder != null)
		{
			recorder.record(""SearchAndReplace.setSearchString(\""""
				+ MiscUtilities.charsToEscapes(search) + ""\"");"");

			if(replaceAction)
			{
				recorder.record(""SearchAndReplace.setReplaceString(\""""
					+ MiscUtilities.charsToEscapes(replace) + ""\"");"");
				recorder.record(""SearchAndReplace.setBeanShellReplace(""
					+ beanshell + "");"");
			}
			else
			{
				
				recorder.record(""SearchAndReplace.setAutoWrapAround(""
					+ wrap + "");"");
				recorder.record(""SearchAndReplace.setReverseSearch(""
					+ reverse + "");"");
			}

			recorder.record(""SearchAndReplace.setIgnoreCase(""
				+ ignoreCase + "");"");
			recorder.record(""SearchAndReplace.setRegexp(""
				+ regexp + "");"");

			if(recordFileSet)
			{
				recorder.record(""SearchAndReplace.setSearchFileSet(""
					+ fileset.getCode() + "");"");
			}

			recorder.record(""SearchAndReplace."" + action + "";"");
		}
	} 

	
	
	private static int _replace(View view, Buffer buffer,
		SearchMatcher matcher, int start, int end,
		boolean smartCaseReplace)
		throws Exception
	{
		int occurCount = 0;

		boolean endOfLine = (buffer.getLineEndOffset(
			buffer.getLineOfOffset(end)) - 1 == end);

		Segment text = new Segment();
		int offset = start;
loop:		for(int counter = 0; ; counter++)
		{
			buffer.getText(offset,end - offset,text);

			boolean startOfLine = (buffer.getLineStartOffset(
				buffer.getLineOfOffset(offset)) == offset);

			int[] occur = matcher.nextMatch(
				new CharIndexedSegment(text,false),
				startOfLine,endOfLine,counter == 0);
			if(occur == null)
				break loop;
			int _start = occur[0];
			int _length = occur[1] - occur[0];

			String found = new String(text.array,text.offset + _start,_length);
			String subst = matcher.substitute(found);
			if(smartCaseReplace && ignoreCase)
			{
				int strCase = TextUtilities.getStringCase(found);
				if(strCase == TextUtilities.LOWER_CASE)
					subst = subst.toLowerCase();
				else if(strCase == TextUtilities.UPPER_CASE)
					subst = subst.toUpperCase();
				else if(strCase == TextUtilities.TITLE_CASE)
					subst = TextUtilities.toTitleCase(subst);
			}

			if(subst != null)
			{
				buffer.remove(offset + _start,_length);
				buffer.insert(offset + _start,subst);
				occurCount++;
				offset += _start + subst.length();

				end += (subst.length() - found.length());
			}
			else
				offset += _start + _length;
		}

		return occurCount;
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.syntax.SyntaxStyle,4,1,0,11,5,0,11,0,4,0.666666667,28,1.0,0,0.0,0.5,0,0,5.25,1,0.75,1,"
package org.gjt.sp.jedit.syntax;

import java.awt.Font;
import java.awt.Color;


public class SyntaxStyle
{
	
	public SyntaxStyle(Color fgColor, Color bgColor, Font font)
	{
		this.fgColor = fgColor;
		this.bgColor = bgColor;
		this.font = font;
	}

	
	public Color getForegroundColor()
	{
		return fgColor;
	}

	
	public Color getBackgroundColor()
	{
		return bgColor;
	}

	
	public Font getFont()
	{
		return font;
	}

	
	private Color fgColor;
	private Color bgColor;
	private Font font;
}
"
jEdit,4,org.gjt.sp.jedit.Marker,7,1,0,7,10,0,7,1,2,0.625,64,1.0,1,0.0,0.428571429,0,0,7.571428571,2,1.1429,0,"

package org.gjt.sp.jedit;

import javax.swing.text.Position;
import org.gjt.sp.util.Log;


public class Marker
{
	
	
	public char getShortcut()
	{
		return shortcut;
	} 

	
	
	public int getPosition()
	{
		return (position == null ? pos : position.getOffset());
	} 

	

	
	Marker(Buffer buffer, char shortcut, int position)
	{
		this.buffer = buffer;
		this.shortcut = shortcut;
		this.pos = position;
	} 

	
	
	void setShortcut(char shortcut)
	{
		this.shortcut = shortcut;
	} 

	
	void createPosition()
	{
		position = buffer.createPosition(pos);
	} 

	
	void removePosition()
	{
		
		if(position != null)
		{
			pos = position.getOffset();
			position = null;
		}
	} 

	
	
	void setPosition(int pos)
	{
		this.pos = pos;
	} 

	

	
	private Buffer buffer;
	private char shortcut;
	private int pos;
	private Position position;
	
}
"
jEdit,4,org.gjt.sp.jedit.msg.EditorExiting,1,3,0,3,2,0,1,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class EditorExiting extends EBMessage.NonVetoable
{
	
	public EditorExiting(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4,org.gjt.sp.jedit.pluginmgr.PluginListHandler,12,2,0,7,36,36,1,7,8,0.869565217,492,1.0,4,0.541666667,0.319444444,1,3,38.08333333,13,3.5833,0,"

package org.gjt.sp.jedit.pluginmgr;

import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;

class PluginListHandler extends HandlerBase
{
	PluginListHandler(PluginList pluginList, String path)
	{
		this.pluginList = pluginList;
		this.path = path;
		stateStack = new Stack();
	}

	public Object resolveEntity(String publicId, String systemId)
	{
		if(""plugins.dtd"".equals(systemId))
		{
			
			
			
			return new StringReader(""<!-- -->"");

			
		}

		return null;
	}

	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();

		if(aname == ""NAME"")
			name = value;
		else if(aname == ""JAR"")
			jar = value;
		else if(aname == ""VERSION"")
			version = value;
		else if(aname == ""DATE"")
			date = value;
		else if(aname == ""OBSOLETE"")
			obsolete = (""TRUE"".equals(value));
		else if(aname == ""WHAT"")
			depWhat = value;
		else if(aname == ""FROM"")
			depFrom = value;
		else if(aname == ""TO"")
			depTo = value;
		else if(aname == ""PLUGIN"")
			depPlugin = value;
		else if(aname == ""SIZE"")
			size = Integer.parseInt(value);
	}

	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""PLUGINS"".equals(name))
			return;

		Log.log(Log.ERROR,this,path + "": DOCTYPE must be PLUGINS"");
	}

	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);

		if(tag == ""DESCRIPTION"")
		{
			description = text;
		}
		else if(tag == ""PLUGIN_SET_ENTRY"")
			pluginSetEntry = text;
		else if(tag == ""AUTHOR"")
		{
			if(author != null && author.length() != 0)
				author = author + "", "" + text;
			else
				author = text;
		}
		else if(tag == ""DOWNLOAD"")
			download = text;
		else if(tag == ""DOWNLOAD_SOURCE"")
			downloadSource = text;
	}

	public void startElement(String tag)
	{
		tag = pushElement(tag);

		if(tag == ""PLUGIN_SET"")
		{
			description = null;
			pluginSet = new PluginList.PluginSet();
		}
		else if(tag == ""PLUGIN"")
		{
			description = null;
			author = null;
			branch = null;
			plugin = new PluginList.Plugin();
		}
		else if(tag == ""BRANCH"")
		{
			download = null;
			branch = new PluginList.Branch();
		}
		else if(tag == ""DOWNLOAD"")
			downloadSize = size;
		else if(tag == ""DOWNLOAD_SOURCE"")
			downloadSourceSize = size;
	}

	public void endElement(String tag)
	{
		if(tag == null)
			return;
		else
			tag = tag.intern();

		popElement();

		if(tag == ""PLUGIN_SET"")
		{
			pluginList.addPluginSet(pluginSet);
			pluginSet = null;
			pluginSetEntry = null;
		}
		else if(tag == ""PLUGIN_SET_ENTRY"")
		{
			pluginSet.plugins.addElement(pluginSetEntry);
			pluginSetEntry = null;
		}
		else if(tag == ""PLUGIN"")
		{
			plugin.jar = jar;
			plugin.name = name;
			plugin.author = author;
			plugin.description = description;
			pluginList.addPlugin(plugin);
			jar = null;
			name = null;
			author = null;
		}
		else if(tag == ""BRANCH"")
		{
			branch.version = version;
			branch.date = date;
			branch.download = download;
			branch.downloadSize = downloadSize;
			branch.downloadSource = downloadSource;
			branch.downloadSourceSize = downloadSourceSize;
			branch.obsolete = obsolete;
			plugin.branches.addElement(branch);
			version = null;
			download = null;
			obsolete = false;
		}
		else if(tag == ""DEPEND"")
		{
			PluginList.Dependency dep = new PluginList.Dependency(
				depWhat,depFrom,depTo,depPlugin);
			branch.deps.addElement(dep);
			depWhat = null;
			depFrom = null;
			depTo = null;
			depPlugin = null;
		}
	}

	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}

	public void endDocument()
	{
		pluginList.finished();
	}
	

	
	private String path;

	private PluginList pluginList;

	private PluginList.PluginSet pluginSet;
	private String pluginSetEntry;

	private PluginList.Plugin plugin;
	private String jar;
	private String author;

	private PluginList.Branch branch;
	private boolean obsolete;
	private String version;
	private String date;
	private String download;
	private int downloadSize;
	private String downloadSource;
	private int downloadSourceSize;
	private int size;
	private String depWhat;
	private String depFrom;
	private String depTo;
	private String depPlugin;

	private String name;
	private String description;

	private Stack stateStack;

	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();

		stateStack.push(name);

		return name;
	}

	private String peekElement()
	{
		return (String) stateStack.peek();
	}

	private String popElement()
	{
		return (String) stateStack.pop();
	}
}
"
jEdit,4,org.gjt.sp.jedit.msg.SearchSettingsChanged,1,3,0,5,2,0,3,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class SearchSettingsChanged extends EBMessage.NonVetoable
{
	
	public SearchSettingsChanged(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4,org.gjt.sp.jedit.gui.HistoryTextField,28,6,0,19,89,206,16,6,15,0.772486772,614,1.0,1,0.970588235,0.219387755,3,7,20.67857143,12,2.25,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.AbstractBorder;
import javax.swing.border.CompoundBorder;
import javax.swing.event.MouseInputAdapter;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;



public class HistoryTextField extends JTextField
{
	
	
	public HistoryTextField()
	{
		this(null);
	} 

	
	
	public HistoryTextField(String name)
	{
		this(name,false,true);
	} 

	
	
	public HistoryTextField(String name, boolean instantPopups)
	{
		this(name,instantPopups,true);
	} 

	
	
	public HistoryTextField(String name, boolean instantPopups,
		boolean enterAddsToHistory)
	{
		setBorder(new CompoundBorder(getBorder(),new HistoryBorder()));

		if(name != null)
			historyModel = HistoryModel.getModel(name);

		MouseHandler mouseHandler = new MouseHandler();
		addMouseListener(mouseHandler);
		addMouseMotionListener(mouseHandler);

		this.instantPopups = instantPopups;
		this.enterAddsToHistory = enterAddsToHistory;

		index = -1;
	} 

	
	
	public void setInstantPopups(boolean instantPopups)
	{
		this.instantPopups = instantPopups;
	} 

	
	
	public boolean getInstantPopups()
	{
		return instantPopups;
	} 

	
	
	public void setEnterAddsToHistory(boolean enterAddsToHistory)
	{
		this.enterAddsToHistory = enterAddsToHistory;
	} 

	
	
	public boolean setEnterAddsToHistory()
	{
		return enterAddsToHistory;
	} 

	
	
	public void setSelectAllOnFocus(boolean selectAllOnFocus)
	{
		this.selectAllOnFocus = selectAllOnFocus;
	} 

	
	
	public boolean setSelectAllOnFocus()
	{
		return selectAllOnFocus;
	} 

	
	
	public void setModel(String name)
	{
		if(name == null)
			historyModel = null;
		else
			historyModel = HistoryModel.getModel(name);
		index = -1;
		repaint();
	} 

	
	
	public void addCurrentToHistory()
	{
		if(historyModel != null)
			historyModel.addItem(getText());
		index = 0;
	} 

	
	
	public void setText(String text)
	{
		super.setText(text);
		index = -1;
	} 

	
	
	public HistoryModel getModel()
	{
		return historyModel;
	} 

	
	
	public void fireActionPerformed()
	{
		super.fireActionPerformed();
	} 

	

	
	protected void processKeyEvent(KeyEvent evt)
	{
		if(!isEnabled())
			return;

		

		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				if(enterAddsToHistory)
					addCurrentToHistory();

				if(evt.getModifiers() == 0)
				{
					fireActionPerformed();
					evt.consume();
				}
			}
			else if(evt.getKeyCode() == KeyEvent.VK_UP)
			{
				if(evt.isShiftDown())
					doBackwardSearch();
				else
					historyPrevious();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_DOWN)
			{
				if(evt.isShiftDown())
					doForwardSearch();
				else
					historyNext();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_TAB
				&& evt.isControlDown())
			{
				doBackwardSearch();
				evt.consume();
			}
		}

		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	
	protected void processMouseEvent(MouseEvent evt)
	{
		if(!isEnabled())
			return;

		switch(evt.getID())
		{
		case MouseEvent.MOUSE_PRESSED:
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);

			if(evt.getX() >= getWidth() - insets.right
				|| GUIUtilities.isPopupTrigger(evt))
			{
				if(evt.isShiftDown())
					showPopupMenu(getText().substring(0,
						getSelectionStart()),0,getHeight());
				else
					showPopupMenu("""",0,getHeight());
			}
			else
				super.processMouseEvent(evt);

			break;
		case MouseEvent.MOUSE_EXITED:
			setCursor(Cursor.getDefaultCursor());
			super.processMouseEvent(evt);
			break;
		default:
			super.processMouseEvent(evt);
			break;
		}
	} 

	

	

	
	private HistoryModel historyModel;
	private JPopupMenu popup;
	private boolean instantPopups;
	private boolean enterAddsToHistory;
	private boolean selectAllOnFocus;
	private String current;
	private int index;
	

	
	private void doBackwardSearch()
	{
		if(historyModel == null)
			return;

		if(getSelectionEnd() != getDocument().getLength())
		{
			setCaretPosition(getDocument().getLength());
		}

		String text = getText().substring(0,getSelectionStart());
		if(text == null)
		{
			historyPrevious();
			return;
		}

		for(int i = index + 1; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				replaceSelection(item.substring(text.length()));
				select(text.length(),getDocument().getLength());
				index = i;
				return;
			}
		}

		getToolkit().beep();
	} 

	
	private void doForwardSearch()
	{
		if(historyModel == null)
			return;

		if(getSelectionEnd() != getDocument().getLength())
		{
			setCaretPosition(getDocument().getLength());
		}

		String text = getText().substring(0,getSelectionStart());
		if(text == null)
		{
			historyNext();
			return;
		}

		for(int i = index - 1; i >= 0; i--)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				replaceSelection(item.substring(text.length()));
				select(text.length(),getDocument().getLength());
				index = i;
				return;
			}
		}

		getToolkit().beep();
	} 

	
	private void historyPrevious()
	{
		if(historyModel == null)
			return;

		if(index == historyModel.getSize() - 1)
			getToolkit().beep();
		else if(index == -1)
		{
			current = getText();
			setText(historyModel.getItem(0));
			index = 0;
		}
		else
		{
			
			int newIndex = index + 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	} 

	
	private void historyNext()
	{
		if(historyModel == null)
			return;

		if(index == -1)
			getToolkit().beep();
		else if(index == 0)
			setText(current);
		else
		{
			
			int newIndex = index - 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	} 

	
	private void showPopupMenu(String text, int x, int y)
	{
		if(historyModel == null)
			return;

		requestFocus();

		if(popup != null && popup.isVisible())
		{
			popup.setVisible(false);
			return;
		}

		ActionHandler actionListener = new ActionHandler();

		popup = new JPopupMenu();
		JMenuItem caption = new JMenuItem(jEdit.getProperty(
			""history.caption""));
		caption.getModel().setEnabled(false);
 		popup.add(caption);
 		popup.addSeparator();

		for(int i = 0; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				JMenuItem menuItem = new JMenuItem(item);
				menuItem.setActionCommand(String.valueOf(i));
				menuItem.addActionListener(actionListener);
				popup.add(menuItem);
			}
		}

		GUIUtilities.showPopupMenu(popup,this,x,y);
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			int ind = Integer.parseInt(evt.getActionCommand());
			if(ind == -1)
			{
				if(index != -1)
					setText(current);
			}
			else
			{
				setText(historyModel.getItem(ind));
				index = ind;
			}
			if(instantPopups)
			{
				addCurrentToHistory();
				fireActionPerformed();
			}
		}
	} 

	
	class MouseHandler extends MouseInputAdapter
	{
		boolean selectAll;

		
		public void mousePressed(MouseEvent evt)
		{
			selectAll = (!hasFocus() && selectAllOnFocus);
		} 

		
		public void mouseReleased(MouseEvent evt)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					if(selectAll)
						selectAll();
				}
			});
		} 

		
		public void mouseMoved(MouseEvent evt)
		{
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);

			if(evt.getX() >= getWidth() - insets.right)
				setCursor(Cursor.getDefaultCursor());
			else
				setCursor(Cursor.getPredefinedCursor(
					Cursor.TEXT_CURSOR));
		} 

		
		public void mouseDragged(MouseEvent evt)
		{
			selectAll = false;
		} 
	} 

	
	static class HistoryBorder extends AbstractBorder
	{
		static final int WIDTH = 16;

		public void paintBorder(Component c, Graphics g,
			int x, int y, int w, int h)
		{
			g.translate(x+w-WIDTH,y-1);

			
			
			
			
			
			

			
			int w2 = WIDTH/2;
			int h2 = h/2;
			g.setColor(UIManager.getColor(c.isEnabled()
				&& ((HistoryTextField)c).getModel() != null
				? ""Menu.foreground"" : ""Menu.disabledForeground""));
			g.drawLine(w2-5,h2-2,w2+4,h2-2);
			g.drawLine(w2-4,h2-1,w2+3,h2-1);
			g.drawLine(w2-3,h2  ,w2+2,h2  );
			g.drawLine(w2-2,h2+1,w2+1,h2+1);
			g.drawLine(w2-1,h2+2,w2  ,h2+2);

			g.translate(-(x+w-WIDTH),-(y-1));
		}

		public Insets getBorderInsets(Component c)
		{
			return new Insets(0,0,0,WIDTH);
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.util.IntegerArray,6,1,0,4,8,0,4,0,6,0.5,66,1.0,0,0.0,0.75,0,0,9.666666667,2,1.0,0,"

package org.gjt.sp.util;


public class IntegerArray
{
	
	public IntegerArray()
	{
		array = new int[100];
	} 

	
	public void add(int num)
	{
		if(len >= array.length)
		{
			int[] arrayN = new int[len * 2];
			System.arraycopy(array,0,arrayN,0,len);
			array = arrayN;
		}

		array[len++] = num;
	} 

	
	public final int get(int index)
	{
		return array[index];
	} 

	
	public final int getSize()
	{
		return len;
	} 

	
	public final void setSize(int len)
	{
		this.len = len;
	} 

	
	public final void clear()
	{
		len = 0;
	} 

	
	private int[] array;
	private int len;
	
}
"
jEdit,4,org.gjt.sp.jedit.OptionGroup,9,1,0,5,20,0,3,2,9,0.5,111,1.0,0,0.0,0.259259259,0,0,11.11111111,3,1.5556,0,"

package org.gjt.sp.jedit;

import java.util.Enumeration;
import java.util.Vector;

import org.gjt.sp.util.Log;

public class OptionGroup
{
	public OptionGroup(String name)
	{
		this.name = name;
		members = new Vector();
	}

	public String getName()
	{
		return name;
	}

	public void addOptionGroup(OptionGroup group)
	{
		if (members.indexOf(group) != -1) return;

		members.addElement(group);
	}

	public void addOptionPane(OptionPane pane)
	{
		if (members.indexOf(pane) != -1) return;

		members.addElement(pane);
	}

	public Enumeration getMembers()
	{
		return members.elements();
	}

	public Object getMember(int index)
	{
		return (index >= 0 && index < members.size())
			? members.elementAt(index) : null;
	}

	public int getMemberIndex(Object member)
	{
		return members.indexOf(member);
	}

	public int getMemberCount()
	{
		return members.size();
	}

	public void save()
	{
		Enumeration enum = members.elements();

		while (enum.hasMoreElements())
		{
			Object elem = enum.nextElement();
			try
			{
				if (elem instanceof OptionPane)
				{
					((OptionPane)elem).save();
				}
				else if (elem instanceof OptionGroup)
				{
					((OptionGroup)elem).save();
				}
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR, elem,
					""Error saving option pane"");
				Log.log(Log.ERROR, elem, t);
			}
		}
	}

	private String name;
	private Vector members;
}
"
jEdit,4,org.gjt.sp.jedit.OptionPane,4,1,0,5,4,6,5,0,4,2.0,4,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit;

import java.awt.Component;


public interface OptionPane
{
	
	String getName();

	
	Component getComponent();

	
	void init();

	
	void save();
}
"
jEdit,4,org.gjt.sp.jedit.gui.ErrorListDialog,5,7,0,6,39,6,3,4,3,0.75,214,1.0,0,0.99391172,0.3,3,6,41.4,1,0.8,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;


public class ErrorListDialog extends EnhancedDialog
{
	
	public static class ErrorEntry
	{
		String path;
		String[] messages;

		public ErrorEntry(String path, String messageProp, Object[] args)
		{
			this.path = path;

			String message = jEdit.getProperty(messageProp,args);
			if(message == null)
				message = ""Undefined property: "" + messageProp;

			Vector tokenizedMessage = new Vector();
			int lastIndex = -1;
			for(int i = 0; i < message.length(); i++)
			{
				if(message.charAt(i) == '\n')
				{
					tokenizedMessage.addElement(message.substring(
						lastIndex + 1,i));
					lastIndex = i;
				}
			}

			if(lastIndex != message.length())
			{
				tokenizedMessage.addElement(message.substring(
					lastIndex + 1));
			}

			messages = new String[tokenizedMessage.size()];
			tokenizedMessage.copyInto(messages);
		}
	} 

	
	public ErrorListDialog(Frame frame, String title, String caption,
		Vector messages, boolean showPluginMgrButton)
	{
		super(frame,title,true);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.errorIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout());

		JLabel label = new JLabel(caption);
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);

		JList errors = new JList(messages);
		errors.setCellRenderer(new ErrorListCellRenderer());
		errors.setVisibleRowCount(Math.min(messages.size(),4));

		
		
		JScrollPane scrollPane = new JScrollPane(errors,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
		Dimension size = scrollPane.getPreferredSize();
		size.width = Math.min(size.width,400);
		scrollPane.setPreferredSize(size);

		centerPanel.add(BorderLayout.CENTER,scrollPane);

		content.add(BorderLayout.CENTER,centerPanel);

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());

		if(showPluginMgrButton)
		{
			pluginMgr = new JButton(jEdit.getProperty(""error-list.plugin-manager""));
			pluginMgr.addActionListener(new ActionHandler());
			buttons.add(pluginMgr);
			buttons.add(Box.createHorizontalStrut(6));
		}

		buttons.add(ok);

		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);

		getRootPane().setDefaultButton(ok);

		pack();
		setLocationRelativeTo(frame);
		show();
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	private JButton ok, pluginMgr;
	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				dispose();
			else if(evt.getSource() == pluginMgr)
			{
				new org.gjt.sp.jedit.pluginmgr.PluginManager(
					JOptionPane.getFrameForComponent(
					ErrorListDialog.this));
			}
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.EnhancedMenuItem,6,6,0,6,36,3,3,4,3,0.533333333,203,1.0,1,0.994993742,0.32,2,11,31.83333333,8,2.3333,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;



public class EnhancedMenuItem extends JMenuItem
{
	
	
	public EnhancedMenuItem(String label, EditAction action)
	{
		super(label);

		this.action = action;

		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(action));
			shortcutProp1 = action.getName() + "".shortcut"";
			shortcutProp2 = action.getName() + "".shortcut2"";

			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);
	} 

	
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();

		String shortcut = getShortcut();

		if(shortcut != null)
		{
			d.width += (getFontMetrics(acceleratorFont)
				.stringWidth(shortcut) + 15);
		}
		return d;
	} 

	
	public void paint(Graphics g)
	{
		super.paint(g);

		String shortcut = getShortcut();

		if(shortcut != null)
		{
			g.setFont(acceleratorFont);
			g.setColor(getModel().isArmed() ?
				acceleratorSelectionForeground :
				acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left + 5),
				getFont().getSize() + (insets.top - 1)
				);
		}
	} 

	

	
	private String shortcutProp1;
	private String shortcutProp2;
	private EditAction action;
	private static Font acceleratorFont;
	private static Color acceleratorForeground;
	private static Color acceleratorSelectionForeground;
	

	
	private String getShortcut()
	{
		if(action == null)
			return null;
		else
		{
			String shortcut1 = jEdit.getProperty(shortcutProp1);
			String shortcut2 = jEdit.getProperty(shortcutProp2);

			if(shortcut1 == null || shortcut1.length() == 0)
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return null;
				else
					return shortcut2;
			}
			else
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return shortcut1;
				else
					return shortcut1 + "" or "" + shortcut2;
			}
		}
	} 

	
	static
	{
		acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
		acceleratorFont = new Font(""Monospaced"",
			acceleratorFont.getStyle(),
			acceleratorFont.getSize());
		acceleratorForeground = UIManager
			.getColor(""MenuItem.acceleratorForeground"");
		acceleratorSelectionForeground = UIManager
			.getColor(""MenuItem.acceleratorSelectionForeground"");
	} 

	

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseReleased(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}

		public void mouseEntered(MouseEvent evt)
		{
			String msg = action.getMouseOverText();
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
			}
		}

		public void mouseExited(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.browser.BrowserListener,2,1,0,4,2,1,3,2,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.browser;

import java.util.EventListener;

import org.gjt.sp.jedit.io.VFS;


public interface BrowserListener extends EventListener
{
	
	void filesSelected(VFSBrowser browser, VFS.DirectoryEntry[] files);

	
	void filesActivated(VFSBrowser browser, VFS.DirectoryEntry[] files);
}
"
jEdit,4,org.gjt.sp.jedit.buffer.ContentManager,10,1,0,2,16,0,2,0,8,0.222222222,388,1.0,0,0.0,0.44,0,0,37.4,6,2.3,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;


public class ContentManager
{
	
	public ContentManager()
	{
		text = new char[1024];
	} 

	
	public final int getLength()
	{
		return length;
	} 

	
	public String getText(int start, int len)
	{
		if(start >= gapStart)
			return new String(text,start + gapEnd - gapStart,len);
		else if(start + len <= gapStart)
			return new String(text,start,len);
		else
		{
			return new String(text,start,gapStart - start)
				.concat(new String(text,gapEnd,start + len - gapStart));
		}
	} 

	
	public void getText(int start, int len, Segment seg)
	{
		if(start >= gapStart)
		{
			seg.array = text;
			seg.offset = start + gapEnd - gapStart;
			seg.count = len;
		}
		else if(start + len <= gapStart)
		{
			seg.array = text;
			seg.offset = start;
			seg.count = len;
		}
		else
		{
			seg.array = new char[len];

			
			System.arraycopy(text,start,seg.array,0,gapStart - start);

			
			System.arraycopy(text,gapEnd,seg.array,gapStart - start,
				len + start - gapStart);

			seg.offset = 0;
			seg.count = len;
		}
	} 

	
	public void insert(int start, String str)
	{
		int len = str.length();
		if(gapStart != start || gapEnd - gapStart < len)
		{
			ensureCapacity(length + len + 200);
			close(start,start + len + 200);
		}
		str.getChars(0,len,text,start);
		gapStart += len;
		length += len;
	} 

	
	public void insert(int start, Segment seg)
	{
		if(gapStart != start || gapEnd - gapStart < seg.count)
		{
			ensureCapacity(length + seg.count + 200);
			close(start,start + seg.count + 200);
		}
		System.arraycopy(seg.array,seg.offset,text,start,seg.count);
		gapStart += seg.count;
		length += seg.count;
	} 

	
	public void _setContent(char[] text, int length)
	{
		this.text = text;
		this.gapStart = this.gapEnd = 0;
		this.length = length;
	} 

	
	public void remove(int start, int len)
	{
		close(start,start);
		gapEnd += len;
		length -= len;
	} 

	
	private char[] text;
	private int gapStart;
	private int gapEnd;
	private int length;

	
	private void close(int newStart, int newEnd)
	{
		
		if(gapStart == newStart)
		{
			System.arraycopy(text,gapEnd,text,newEnd,length - gapStart);
		}
		else
		{
			if(gapStart != gapEnd && gapStart != length)
			{
				System.arraycopy(text,gapEnd,text,gapStart,
					length - gapStart);
			}

			if(newStart != newEnd && newStart != length)
			{
				System.arraycopy(text,newStart,text,newEnd,
					length - newStart);
			}
		}

		gapStart = newStart;
		gapEnd = newEnd;
	} 

	
	private void ensureCapacity(int capacity)
	{
		if(capacity >= text.length)
		{
			char[] textN = new char[capacity * 2];
			System.arraycopy(text,0,textN,0,length + (gapEnd - gapStart));
			text = textN;
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.util.WorkThreadPool,22,1,0,14,52,107,13,5,9,0.866071429,648,0.8125,5,0.0,0.166666667,0,0,27.72727273,12,2.9545,0,"

package org.gjt.sp.util;


import javax.swing.event.EventListenerList;
import javax.swing.SwingUtilities;



public class WorkThreadPool
{
	
	
	public WorkThreadPool(String name, int count)
	{
		listenerList = new EventListenerList();

		if(count != 0)
		{
			threadGroup = new ThreadGroup(name);
			threads = new WorkThread[count];
			for(int i = 0; i < threads.length; i++)
			{
				threads[i] = new WorkThread(this,threadGroup,name + "" #"" + (i+1));
			}
		}
		else
			Log.log(Log.WARNING,this,""Async I/O disabled"");
	} 

	
	
	public void start()
	{
		synchronized(lock)
		{
			started = true;

			if(awtRequestCount != 0 && requestCount == 0)
				queueAWTRunner();
		}

		if(threads != null)
		{
			for(int i = 0; i < threads.length; i++)
			{
				threads[i].start();
			}
		}
	} 

	
	
	public void addWorkRequest(Runnable run, boolean inAWT)
	{
		if(threads == null)
		{
			run.run();
			return;
		}

		synchronized(lock)
		{
			
			if(started && inAWT && requestCount == 0 && awtRequestCount == 0)
			{


				if(SwingUtilities.isEventDispatchThread())
					run.run();
				else
					SwingUtilities.invokeLater(run);

				return;
			} 

			Request request = new Request(run);

			
			if(inAWT)
			{
				if(firstAWTRequest == null && lastAWTRequest == null)
					firstAWTRequest = lastAWTRequest = request;
				else
				{
					lastAWTRequest.next = request;
					lastAWTRequest = request;
				}

				awtRequestCount++;

				
				
				
				if(started && requestCount == 0)
					queueAWTRunner();
			} 
			
			else
			{
				if(firstRequest == null && lastRequest == null)
					firstRequest = lastRequest = request;
				else
				{
					lastRequest.next = request;
					lastRequest = request;
				}

				requestCount++;
			} 

			lock.notify();
		}
	} 

	
	
	public void waitForRequests()
	{
		if(threads == null)
			return;

		synchronized(waitForAllLock)
		{
			while(requestCount != 0)
			{
				try
				{
					waitForAllLock.wait();
				}
				catch(InterruptedException ie)
				{
					Log.log(Log.ERROR,this,ie);
				}
			}
		}

		if(SwingUtilities.isEventDispatchThread())
		{
			
			doAWTRequests();
		}
		else
		{
			try
			{
				SwingUtilities.invokeAndWait(new RunRequestsInAWTThread());
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
		}
	} 

	
	
	public int getRequestCount()
	{
		return requestCount;
	} 

	
	
	public int getThreadCount()
	{
		if(threads == null)
			return 0;
		else
			return threads.length;
	} 

	
	
	public WorkThread getThread(int index)
	{
		return threads[index];
	} 

	
	
	public void addProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.add(WorkThreadProgressListener.class,listener);
	} 

	
	
	public void removeProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.remove(WorkThreadProgressListener.class,listener);
	} 

	
	Object lock = new String(""Work thread pool request queue lock"");
	Object waitForAllLock = new String(""Work thread pool waitForAll() notifier"");

	
	void fireStatusChanged(WorkThread thread)
	{
		final Object[] listeners = listenerList.getListenerList();
		if(listeners.length != 0)
		{
			int index = 0;
			for(int i = 0; i < threads.length; i++)
			{
				if(threads[i] == thread)
				{
					index = i;
					break;
				}
			}

			for(int i = listeners.length - 2; i >= 0; i--)
			{
				if(listeners[i] == WorkThreadProgressListener.class)
				{
					((WorkThreadProgressListener)listeners[i+1])
						.statusUpdate(WorkThreadPool.this,index);
				}
			}
		}
	} 

	
	void fireProgressChanged(WorkThread thread)
	{
		final Object[] listeners = listenerList.getListenerList();
		if(listeners.length != 0)
		{
			int index = 0;
			for(int i = 0; i < threads.length; i++)
			{
				if(threads[i] == thread)
				{
					index = i;
					break;
				}
			}

			for(int i = listeners.length - 2; i >= 0; i--)
			{
				if(listeners[i] == WorkThreadProgressListener.class)
				{
					((WorkThreadProgressListener)listeners[i+1])
						.progressUpdate(WorkThreadPool.this,index);
				}
			}
		}
	} 

	
	void requestDone()
	{
		synchronized(lock)
		{
			requestCount--;

			if(requestCount == 0 && firstAWTRequest != null)
				queueAWTRunner();
		}
	} 

	
	Request getNextRequest()
	{
		synchronized(lock)
		{
			Request request = firstRequest;
			if(request == null)
				return null;

			firstRequest = firstRequest.next;
			if(firstRequest == null)
				lastRequest = null;

			if(request.alreadyRun)
				throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
			request.alreadyRun = true;

			

			return request;
		}
	} 

	

	

	
	private boolean started;
	private ThreadGroup threadGroup;
	private WorkThread[] threads;

	
	private Request firstRequest;
	private Request lastRequest;
	private int requestCount;

	
	private boolean awtRunnerQueued;
	private Request firstAWTRequest;
	private Request lastAWTRequest;
	private int awtRequestCount;

	private EventListenerList listenerList;
	

	
	private void doAWTRequests()
	{
		while(firstAWTRequest != null)
		{
			doAWTRequest(getNextAWTRequest());
		}
	} 

	
	private void doAWTRequest(Request request)
	{


		try
		{
			request.run.run();
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception ""
				+ ""in AWT thread:"");
			Log.log(Log.ERROR,WorkThread.class,t);
		}

		awtRequestCount--;
	} 

	
	private void queueAWTRunner()
	{
		if(!awtRunnerQueued)
		{
			awtRunnerQueued = true;
			SwingUtilities.invokeLater(new RunRequestsInAWTThread());

		}
	} 

	
	private Request getNextAWTRequest()
	{
		Request request = firstAWTRequest;
		firstAWTRequest = firstAWTRequest.next;
		if(firstAWTRequest == null)
			lastAWTRequest = null;

		if(request.alreadyRun)
			throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
		request.alreadyRun = true;

		

		return request;
	} 

	

	static int ID;

	
	static class Request
	{
		int id = ++ID;

		Runnable run;

		boolean alreadyRun;

		Request next;

		Request(Runnable run)
		{
			this.run = run;
		}

		public String toString()
		{
			return ""[id="" + id + "",run="" + run + ""]"";
		}
	} 

	
	class RunRequestsInAWTThread implements Runnable
	{
		public void run()
		{
			synchronized(lock)
			{
				awtRunnerQueued = false;
				if(requestCount == 0)
					doAWTRequests();
			}
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.DockableWindow,2,1,0,3,2,1,3,0,2,2.0,3,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.gui;

import java.awt.Component;


public interface DockableWindow
{
	
	String DOCKABLE_WINDOW_LIST = ""DOCKABLE_WINDOWS"";

	
	String getName();

	
	Component getComponent();
}
"
jEdit,4,org.gjt.sp.jedit.gui.EnhancedDialog,3,6,17,20,13,3,20,3,3,1.0,43,1.0,1,0.996937213,0.5,0,0,13.0,1,0.6667,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.awt.event.*;
import java.awt.*;


public abstract class EnhancedDialog extends JDialog
{
	public EnhancedDialog(Frame parent, String title, boolean modal)
	{
		super(parent,title,modal);

		((Container)getLayeredPane()).addContainerListener(
			new ContainerHandler());
		getContentPane().addContainerListener(new ContainerHandler());

		keyHandler = new KeyHandler();
		addKeyListener(keyHandler);
		addWindowListener(new WindowHandler());

		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
	}

	public abstract void ok();
	public abstract void cancel();

	
	protected KeyHandler keyHandler;

	
	class ContainerHandler extends ContainerAdapter
	{
		public void componentAdded(ContainerEvent evt)
		{
			componentAdded(evt.getChild());
		}

		public void componentRemoved(ContainerEvent evt)
		{
			componentRemoved(evt.getChild());
		}

		private void componentAdded(Component comp)
		{
			comp.addKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.addContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentAdded(comps[i]);
				}
			}
		}

		private void componentRemoved(Component comp)
		{
			comp.removeKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.removeContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentRemoved(comps[i]);
				}
			}
		}
	}

	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.isConsumed())
				return;

			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				
				Component comp = getFocusOwner();
				while(comp != null)
				{
					if(comp instanceof JComboBox)
					{
						JComboBox combo = (JComboBox)comp;
						if(combo.isEditable())
						{
							Object selected = combo.getEditor().getItem();
							if(selected != null)
								combo.setSelectedItem(selected);
						}
						break;
					}

					comp = comp.getParent();
				}

				ok();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
			{
				cancel();
				evt.consume();
			}
		}
	}

	class WindowHandler extends WindowAdapter
	{
		public void windowClosing(WindowEvent evt)
		{
			cancel();
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.msg.ViewUpdate,5,3,0,8,13,4,4,4,4,0.833333333,47,0.333333333,0,0.666666667,0.5,1,1,7.8,1,0.6,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;


public class ViewUpdate extends EBMessage.NonVetoable
{
	
	public static final Object CREATED = ""CREATED"";

	
	public static final Object CLOSED = ""CLOSED"";

	
	public ViewUpdate(View view, Object what)
	{
		super(view);

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
	}

	
	public Object getWhat()
	{
		return what;
	}

	
	public View getView()
	{
		return (View)getSource();
	}

	public String paramString()
	{
		return super.paramString() + "",what="" + what;
	}

	
	private Object what;
}
"
jEdit,4,org.gjt.sp.jedit.gui.TipOfTheDay,8,7,0,6,58,20,2,6,3,0.8,293,1.0,0,0.989393939,0.375,3,6,35.0,5,1.375,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import java.net.URL;
import java.util.Random;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class TipOfTheDay extends EnhancedDialog
{
	
	public TipOfTheDay(View view)
	{
		super(view,jEdit.getProperty(""tip.title""),false);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel label = new JLabel(jEdit.getProperty(""tip.caption""));
		label.setFont(new Font(""SansSerif"",Font.PLAIN,24));
		label.setForeground(UIManager.getColor(""Button.foreground""));
		content.add(BorderLayout.NORTH,label);

		tipText = new JEditorPane();
		tipText.setEditable(false);
		tipText.setContentType(""text/html"");

		nextTip();

		JScrollPane scroller = new JScrollPane(tipText);
		scroller.setPreferredSize(new Dimension(150,150));
		content.add(BorderLayout.CENTER,scroller);

		ActionHandler actionHandler = new ActionHandler();

		Box buttons = new Box(BoxLayout.X_AXIS);

		showNextTime = new JCheckBox(jEdit.getProperty(""tip.show-next-time""),
			jEdit.getBooleanProperty(""tip.show""));
		showNextTime.addActionListener(actionHandler);
		buttons.add(showNextTime);

		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(Box.createGlue());

		nextTip = new JButton(jEdit.getProperty(""tip.next-tip""));
		nextTip.addActionListener(actionHandler);
		buttons.add(nextTip);

		buttons.add(Box.createHorizontalStrut(6));

		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(actionHandler);
		buttons.add(close);
		content.getRootPane().setDefaultButton(close);

		Dimension dim = nextTip.getPreferredSize();
		dim.width = Math.max(dim.width,close.getPreferredSize().width);
		nextTip.setPreferredSize(dim);
		close.setPreferredSize(dim);

		content.add(BorderLayout.SOUTH,buttons);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	

	
	private JCheckBox showNextTime;
	private JButton nextTip, close;
	private JEditorPane tipText;
	private int currentTip = -1;
	

	
	private void nextTip()
	{
		File[] tips = new File(MiscUtilities.constructPath(
			jEdit.getJEditHome(),""doc"",""tips"")).listFiles();
		if(tips == null || tips.length == 0)
		{
			tipText.setText(jEdit.getProperty(""tip.not-found""));
			return;
		}

		int count = tips.length;

		
		
		int tipToShow = currentTip;
		while(tipToShow == currentTip || !tips[tipToShow].getName().endsWith("".html""))
			tipToShow = Math.abs(new Random().nextInt()) % count;
		try
		{
			tipText.setPage(tips[tipToShow].toURL());
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == showNextTime)
			{
				jEdit.setBooleanProperty(""tip.show"",showNextTime
					.isSelected());
			}
			else if(source == nextTip)
				nextTip();
			else if(source == close)
				dispose();
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.OperatingSystem,11,1,0,18,24,11,17,1,9,0.977777778,170,1.0,0,0.0,0.1,0,0,13.63636364,3,1.7273,0,"

package org.gjt.sp.jedit;

import java.io.File;
import org.gjt.sp.util.Log;


public class OperatingSystem
{
	
	
	public static final boolean isDOSDerived()
	{
		return isWindows() || isOS2();
	} 

	
	
	public static final boolean isWindows()
	{
		return os == WINDOWS_9x || os == WINDOWS_NT;
	} 

	
	
	public static final boolean isWindows9x()
	{
		return os == WINDOWS_9x;
	} 

	
	
	public static final boolean isWindowsNT()
	{
		return os == WINDOWS_NT;
	} 

	
	
	public static final boolean isOS2()
	{
		return os == OS2;
	} 

	
	
	public static final boolean isUnix()
	{
		return os == UNIX || os == MAC_OS_X;
	} 

	
	
	public static final boolean isMacOS()
	{
		return os == MAC_OS_X;
	} 

	
	
	public static final boolean hasJava14()
	{
		return java14;
	} 

	
	private static final int UNIX = 0x31337;
	private static final int WINDOWS_9x = 0x640;
	private static final int WINDOWS_NT = 0x666;
	private static final int OS2 = 0xDEAD;
	private static final int MAC_OS_X = 0xABC;
	private static final int UNKNOWN = 0xBAD;

	private static int os;
	private static boolean java14;

	
	static
	{
		String osName = System.getProperty(""os.name"");
		if(osName.indexOf(""Windows 9"") != -1
			|| osName.indexOf(""Windows ME"") != -1)
		{
			os = WINDOWS_9x;
		}
		else if(osName.indexOf(""Windows"") != -1)
		{
			os = WINDOWS_NT;
		}
		else if(osName.indexOf(""OS/2"") != -1)
		{
			os = OS2;
		}
		else if(File.separatorChar == '/'
			&& new File(""/dev"").isDirectory())
		{
			if(osName.indexOf(""Mac OS X"") != -1)
				os = MAC_OS_X;
			else
				os = UNIX;
		}
		else
		{
			os = UNKNOWN;
			Log.log(Log.WARNING,OperatingSystem.class,
				""Unknown operating system: "" + osName);
		}

		if(System.getProperty(""java.version"").compareTo(""1.4"") >= 0)
			java14 = true;
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.DockableWindowManager,28,5,0,27,78,230,17,17,20,0.925925926,697,0.642857143,5,0.961708395,0.206349206,0,0,23.39285714,11,2.2143,6,"

package org.gjt.sp.jedit.gui;


import bsh.EvalError;
import com.microstar.xml.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.msg.CreateDockableWindow;
import org.gjt.sp.jedit.search.HyperSearchResults;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import java.util.*;



public class DockableWindowManager extends JPanel
{
	

	
	
	public static final String FLOATING = ""floating"";

	
	public static final String TOP = ""top"";

	
	public static final String LEFT = ""left"";

	
	public static final String BOTTOM = ""bottom"";

	
	public static final String RIGHT = ""right"";
	

	
	
	public static boolean loadDockableWindows(String path, Reader in, ActionSet actionSet)
	{
		try
		{
			Log.log(Log.DEBUG,jEdit.class,""Loading dockables from "" + path);

			DockableListHandler dh = new DockableListHandler(path,actionSet);
			XmlParser parser = new XmlParser();
			parser.setHandler(dh);
			parser.parse(null, null, in);
			return true;
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,jEdit.class,path + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}

		return false;
	} 

	
	public static void registerDockableWindow(String name, String code,
		boolean actions, ActionSet actionSet)
	{
		dockableWindowFactories.addElement(new Factory(name,code,
			actions,actionSet));
	} 

	
	public static String[] getRegisteredDockableWindows()
	{
		String[] retVal = new String[dockableWindowFactories.size()];
		for(int i = 0; i < dockableWindowFactories.size(); i++)
		{
			retVal[i] = ((Factory)dockableWindowFactories.elementAt(i)).name;
		}
		return retVal;
	} 

	
	static class DockableListHandler extends HandlerBase
	{
		
		DockableListHandler(String path, ActionSet actionSet)
		{
			this.path = path;
			this.actionSet = actionSet;
			stateStack = new Stack();
			actions = true;
		} 

		
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""dockables.dtd"".equals(systemId))
			{
				
				
				
				return new StringReader(""<!-- -->"");

				
			}

			return null;
		} 

		
		public void attribute(String aname, String value, boolean isSpecified)
		{
			aname = (aname == null) ? null : aname.intern();
			value = (value == null) ? null : value.intern();

			if(aname == ""NAME"")
				dockableName = value;
			else if(aname == ""NO_ACTIONS"")
				actions = (value == ""FALSE"");
		} 

		
		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""DOCKABLES"".equals(name))
				return;

			Log.log(Log.ERROR,this,path + "": DOCTYPE must be DOCKABLES"");
		} 

		
		public void charData(char[] c, int off, int len)
		{
			String tag = peekElement();
			String text = new String(c, off, len);

			if (tag == ""DOCKABLE"")
			{
				code = text;
			}
		} 

		
		public void startElement(String tag)
		{
			tag = pushElement(tag);
		} 

		
		public void endElement(String name)
		{
			if(name == null)
				return;

			String tag = peekElement();

			if(name.equals(tag))
			{
				if(tag == ""DOCKABLE"")
				{
					registerDockableWindow(dockableName,
						code,actions,actionSet);
					
					
					actions = true;
				}

				popElement();
			}
			else
			{
				
				throw new InternalError();
			}
		} 

		
		public void startDocument()
		{
			try
			{
				pushElement(null);
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		} 

		

		
		private String path;
		private ActionSet actionSet;

		private String dockableName;
		private String code;
		private boolean actions;

		private Stack stateStack;
		

		
		private String pushElement(String name)
		{
			name = (name == null) ? null : name.intern();

			stateStack.push(name);

			return name;
		} 

		
		private String peekElement()
		{
			return (String) stateStack.peek();
		} 

		
		private String popElement()
		{
			return (String) stateStack.pop();
		} 

		
	} 

	
	static class Factory
	{
		String name;
		String code;

		
		Factory(String name, String code, boolean actions, ActionSet actionSet)
		{
			this.name = name;
			this.code = code;
			if(actions)
			{
				actionSet.addAction(new OpenAction());
				actionSet.addAction(new ToggleAction());
			}
		} 

		
		JComponent createDockableWindow(View view, String position)
		{
			
			if(code == null)
			{
				CreateDockableWindow msg = new CreateDockableWindow(view,name,
					position);
				EditBus.send(msg);

				DockableWindow win = msg.getDockableWindow();
				if(win == null)
				{
					Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
					return null;
				}
				return (JComponent)win.getComponent();
			}
			
			else
			{
				try
				{
					BeanShell.getNameSpace().setVariable(
						""position"",position);
				}
				catch(EvalError e)
				{
					Log.log(Log.ERROR,this,e);
				}
				JComponent win = (JComponent)BeanShell.eval(view,
					BeanShell.getNameSpace(),code);
				return win;
			}
		} 

		
		class OpenAction extends EditAction
		{
			
			OpenAction()
			{
				super(name);
			} 

			
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.showDockableWindow(name);
			} 

			
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".showDockableWindow(\"""" + name + ""\"");"";
			} 
		} 

		
		class ToggleAction extends EditAction
		{
			
			ToggleAction()
			{
				super(name + ""-toggle"");
			} 

			
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.toggleDockableWindow(name);
			} 

			
			public boolean isToggle()
			{
				return true;
			} 

			
			public boolean isSelected(View view)
			{
				return view.getDockableWindowManager()
					.isDockableWindowVisible(name);
			} 

			
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".toggleDockableWindow(\"""" + name + ""\"");"";
			} 
		} 
	} 

	private static Vector dockableWindowFactories;

	
	static
	{
		dockableWindowFactories = new Vector();
	} 

	

	

	
	
	public DockableWindowManager(View view)
	{
		setLayout(new DockableLayout());
		this.view = view;
		windows = new Hashtable();

		top = new PanelWindowContainer(this,TOP);
		left = new PanelWindowContainer(this,LEFT);
		bottom = new PanelWindowContainer(this,BOTTOM);
		right = new PanelWindowContainer(this,RIGHT);

		add(DockableLayout.TOP_BUTTONS,top.getButtonBox());
		add(DockableLayout.LEFT_BUTTONS,left.getButtonBox());
		add(DockableLayout.BOTTOM_BUTTONS,bottom.getButtonBox());
		add(DockableLayout.RIGHT_BUTTONS,right.getButtonBox());

		add(TOP,top.getDockablePanel());
		add(LEFT,left.getDockablePanel());
		add(BOTTOM,bottom.getDockablePanel());
		add(RIGHT,right.getDockablePanel());
	} 

	
	
	public void init()
	{
		for(int i = 0; i < dockableWindowFactories.size(); i++)
		{
			Factory factory = (Factory)
				dockableWindowFactories.elementAt(i);
			Entry entry = new Entry(factory);
			windows.put(factory.name,entry);
		}

		String lastTop = jEdit.getProperty(""view.dock.top.last"");
		if(lastTop != null)
			showDockableWindow(lastTop);

		String lastLeft = jEdit.getProperty(""view.dock.left.last"");
		if(lastLeft != null)
			showDockableWindow(lastLeft);

		String lastBottom = jEdit.getProperty(""view.dock.bottom.last"");
		if(lastBottom != null)
			showDockableWindow(lastBottom);

		String lastRight = jEdit.getProperty(""view.dock.right.last"");
		if(lastRight != null)
			showDockableWindow(lastRight);
	} 

	
	
	public View getView()
	{
		return view;
	} 

	
	
	public void showDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return;
		}

		if(entry.win == null)
			entry.open();

		if(entry.win != null)
			entry.container.show(entry);
		else
			;
	} 

	
	
	public void addDockableWindow(String name)
	{
		showDockableWindow(name);
	} 

	
	
	public void removeDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""This DockableWindowManager""
				+ "" does not have a window named "" + name);
			return;
		}

		if(entry.win == null)
			return;

		if(entry.container instanceof FloatingWindowContainer)
		{
			entry.container.save(entry);
			entry.container.remove(entry);
			entry.container = null;
			entry.win = null;
		}
		else
			entry.container.show(null);
	} 

	
	
	public void toggleDockableWindow(String name)
	{
		if(isDockableWindowVisible(name))
			removeDockableWindow(name);
		else
			addDockableWindow(name);
	} 

	
	
	public DockableWindow getDockableWindow(String name)
	{
		if(BeanShell.isScriptRunning())
		{
			Log.log(Log.WARNING,this,""You are using the""
				+ "" DockableWindowManager.getDockableWindow() method in"");
			Log.log(Log.WARNING,this,""your macro."");
			Log.log(Log.WARNING,this,""This method is deprecated and will""
				+ "" be removed in a future jEdit"");
			Log.log(Log.WARNING,this,""version, because it cannot be used""
				+ "" with newer plugins."");
			Log.log(Log.WARNING,this,""Modify the macro to call""
				+ "" DockableWindowManager.getDockable() instead."");
		}

		
		Component comp = getDockable(name);
		if(comp instanceof DockableWindow)
			return (DockableWindow)comp;
		else
			return null;
	} 

	
	
	public JComponent getDockable(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null || entry.win == null)
			return null;
		else
			return entry.win;
	} 

	
	
	public boolean isDockableWindowVisible(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null || entry.win == null)
			return false;
		else
			return entry.container.isVisible(entry);
	} 

	
	
	public boolean isDockableWindowDocked(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
			return false;
		else
			return (entry.position != FLOATING);
	} 

	
	
	public void close()
	{
		top.save();
		left.save();
		bottom.save();
		right.save();

		Enumeration enum = windows.elements();
		while(enum.hasMoreElements())
		{
			Entry entry = (Entry)enum.nextElement();
			if(entry.win != null)
				entry.remove();
		}
	} 

	
	public PanelWindowContainer getTopDockingArea()
	{
		return top;
	} 

	
	public PanelWindowContainer getLeftDockingArea()
	{
		return left;
	} 

	
	public PanelWindowContainer getBottomDockingArea()
	{
		return bottom;
	} 

	
	public PanelWindowContainer getRightDockingArea()
	{
		return right;
	} 

	
	
	public void propertiesChanged()
	{
		alternateLayout = jEdit.getBooleanProperty(""view.docking.alternateLayout"");

		Enumeration enum = windows.elements();
		while(enum.hasMoreElements())
		{
			Entry entry = (Entry)enum.nextElement();
			String position = entry.position;
			String newPosition = jEdit.getProperty(entry.name
				+ "".dock-position"");
			if(newPosition != null 
				&& !newPosition.equals(position))
			{
				entry.position = newPosition;
				if(entry.container != null)
				{
					entry.container.remove(entry);
					entry.container = null;
					entry.win = null;
				}

				if(newPosition.equals(FLOATING))
					;
				else
				{
					if(newPosition.equals(TOP))
						entry.container = top;
					else if(newPosition.equals(LEFT))
						entry.container = left;
					else if(newPosition.equals(BOTTOM))
						entry.container = bottom;
					else if(newPosition.equals(RIGHT))
						entry.container = right;
					else
						throw new InternalError(""Unknown position: "" + newPosition);

					entry.container.register(entry);
				}
			}

			if(entry.container instanceof FloatingWindowContainer)
			{
				SwingUtilities.updateComponentTreeUI(((JFrame)entry.container)
					.getRootPane());
			}
		}

		revalidate();
	} 

	

	
	private View view;
	private Hashtable windows;
	private boolean alternateLayout;
	private PanelWindowContainer left;
	private PanelWindowContainer right;
	private PanelWindowContainer top;
	private PanelWindowContainer bottom;
	

	

	

	
	class DockableLayout implements LayoutManager2
	{
		
		
		static final String CENTER = BorderLayout.CENTER;

		static final String TOP_BUTTONS = ""top-buttons"";
		static final String LEFT_BUTTONS = ""left-buttons"";
		static final String BOTTOM_BUTTONS = ""bottom-buttons"";
		static final String RIGHT_BUTTONS = ""right-buttons"";

		Component center;
		Component top, left, bottom, right;
		Component topButtons, leftButtons, bottomButtons, rightButtons;

		
		public void addLayoutComponent(String name, Component comp)
		{
			addLayoutComponent(comp,name);
		} 

		
		public void addLayoutComponent(Component comp, Object cons)
		{
			if(cons == null || CENTER.equals(cons))
				center = comp;
			else if(TOP.equals(cons))
				top = comp;
			else if(LEFT.equals(cons))
				left = comp;
			else if(BOTTOM.equals(cons))
				bottom = comp;
			else if(RIGHT.equals(cons))
				right = comp;
			else if(TOP_BUTTONS.equals(cons))
				topButtons = comp;
			else if(LEFT_BUTTONS.equals(cons))
				leftButtons = comp;
			else if(BOTTOM_BUTTONS.equals(cons))
				bottomButtons = comp;
			else if(RIGHT_BUTTONS.equals(cons))
				rightButtons = comp;
		} 

		
		public void removeLayoutComponent(Component comp)
		{
			if(center == comp)
				center = null;
			else
			{
				
				
			}
		} 

		
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension prefSize = new Dimension(0,0);
			Dimension _top = top.getPreferredSize();
			Dimension _left = left.getPreferredSize();
			Dimension _bottom = bottom.getPreferredSize();
			Dimension _right = right.getPreferredSize();
			Dimension _topButtons = topButtons.getPreferredSize();
			Dimension _leftButtons = leftButtons.getPreferredSize();
			Dimension _bottomButtons = bottomButtons.getPreferredSize();
			Dimension _rightButtons = rightButtons.getPreferredSize();
			Dimension _center = (center == null
				? new Dimension(0,0)
				: center.getPreferredSize());

			prefSize.height = _top.height + _bottom.height + _center.height
				+ _topButtons.height + _bottomButtons.height;
			prefSize.width = _left.width + _right.width + _center.width
				+ _leftButtons.width + _rightButtons.width;

			return prefSize;
		} 

		
		public Dimension minimumLayoutSize(Container parent)
		{
			Dimension minSize = new Dimension(0,0);
			Dimension _top = top.getMinimumSize();
			Dimension _left = left.getMinimumSize();
			Dimension _bottom = bottom.getMinimumSize();
			Dimension _right = right.getMinimumSize();
			Dimension _topButtons = topButtons.getMinimumSize();
			Dimension _leftButtons = leftButtons.getMinimumSize();
			Dimension _bottomButtons = bottomButtons.getMinimumSize();
			Dimension _rightButtons = rightButtons.getMinimumSize();
			Dimension _center = (center == null
				? new Dimension(0,0)
				: center.getMinimumSize());

			minSize.height = _top.height + _bottom.height + _center.height
				+ _topButtons.height + _bottomButtons.height;
			minSize.width = _left.width + _right.width + _center.width
				+ _leftButtons.width + _rightButtons.width;

			return minSize;
		} 

		
		public Dimension maximumLayoutSize(Container parent)
		{
			return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);
		} 

		
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();

			Dimension _topButtons = topButtons.getPreferredSize();
			Dimension _leftButtons = leftButtons.getPreferredSize();
			Dimension _bottomButtons = bottomButtons.getPreferredSize();
			Dimension _rightButtons = rightButtons.getPreferredSize();
			Dimension _center = (center == null
				? new Dimension(0,0)
				: center.getPreferredSize());

			int _width = size.width - _leftButtons.width - _rightButtons.width;
			int _height = size.height - _topButtons.height - _bottomButtons.height;

			Dimension _top = top.getPreferredSize();
			Dimension _left = left.getPreferredSize();
			Dimension _bottom = bottom.getPreferredSize();
			Dimension _right = right.getPreferredSize();

			int topHeight = Math.min(Math.max(0,_height - _bottom.height),_top.height);
			int leftWidth = Math.min(Math.max(0,_width - _right.width),_left.width);
			int bottomHeight = Math.min(Math.max(0,_height - topHeight),_bottom.height);
			int rightWidth = Math.min(Math.max(0,_width - leftWidth),_right.width);

			DockableWindowManager.this.top.setDimension(topHeight);
			DockableWindowManager.this.left.setDimension(leftWidth);
			DockableWindowManager.this.bottom.setDimension(bottomHeight);
			DockableWindowManager.this.right.setDimension(rightWidth);

			if(alternateLayout)
			{
				topButtons.setBounds(
					_leftButtons.width,
					0,
					_width,
					_topButtons.height);

				leftButtons.setBounds(
					0,
					_topButtons.height + _top.height,
					_leftButtons.width,
					_height - _top.height - _bottom.height);

				bottomButtons.setBounds(
					_leftButtons.width,
					size.height - _bottomButtons.height,
					_width,
					_bottomButtons.height);

				rightButtons.setBounds(
					size.width - _rightButtons.width,
					_topButtons.height + _top.height,
					_rightButtons.width,
					_height - _top.height - _bottom.height);

				top.setBounds(
					_leftButtons.width,
					_topButtons.height,
					_width,
					topHeight);

				bottom.setBounds(
					_leftButtons.width,
					size.height - bottomHeight - _bottomButtons.height,
					_width,
					bottomHeight);

				left.setBounds(
					_leftButtons.width,
					_topButtons.height + topHeight,
					leftWidth,
					_height - topHeight - bottomHeight);

				right.setBounds(
					size.width - rightWidth - _rightButtons.width,
					_topButtons.height + topHeight,
					rightWidth,
					_height - topHeight - bottomHeight);
			}
			else
			{
				topButtons.setBounds(
					_leftButtons.width + leftWidth,
					0,
					_width - leftWidth - rightWidth,
					_topButtons.height);

				leftButtons.setBounds(
					0,
					_topButtons.height,
					_leftButtons.width,
					_height);

				bottomButtons.setBounds(
					_leftButtons.width + leftWidth,
					size.height - _bottomButtons.height,
					_width - leftWidth - rightWidth,
					_bottomButtons.height);

				rightButtons.setBounds(
					size.width - _rightButtons.width,
					_topButtons.height,
					_rightButtons.width,
					_height);

				top.setBounds(
					_leftButtons.width + leftWidth,
					_topButtons.height,
					_width - leftWidth - rightWidth,
					topHeight);
				bottom.setBounds(
					_leftButtons.width + leftWidth,
					size.height - bottomHeight - _bottomButtons.height,
					_width - leftWidth - rightWidth,
					bottomHeight);

				left.setBounds(
					_leftButtons.width,
					_topButtons.height,
					leftWidth,
					_height);

				right.setBounds(
					size.width - rightWidth - _rightButtons.width,
					_topButtons.height,
					rightWidth,
					_height);
			}

			if(center != null)
			{
				center.setBounds(
					_leftButtons.width + _left.width,
					_topButtons.height + _top.height,
					_width - _left.width - _right.width,
					_height - _top.height - _bottom.height);
			}
		} 

		
		public float getLayoutAlignmentX(Container target)
		{
			return 0.5f;
		} 

		
		public float getLayoutAlignmentY(Container target)
		{
			return 0.5f;
		} 

		
		public void invalidateLayout(Container target) {}
		
	} 

	
	class Entry
	{
		Factory factory;
		String name;
		String position;
		String title;

		DockableWindowContainer container;

		
		JComponent win;

		
		Entry(Factory factory)
		{
			this.factory = factory;
			this.name = factory.name;
			this.position = jEdit.getProperty(name + "".dock-position"",
				FLOATING);
			title = jEdit.getProperty(name + "".title"");
			if(title == null)
			{
				Log.log(Log.WARNING,this,name + "".title property""
					+ "" not defined"");
				title = name;
			}

			if(position == null)
				position = FLOATING;

			if(position.equals(FLOATING))
				;
			else
			{
				if(position.equals(TOP))
					container = top;
				else if(position.equals(LEFT))
					container = left;
				else if(position.equals(BOTTOM))
					container = bottom;
				else if(position.equals(RIGHT))
					container = right;
				else
					throw new InternalError(""Unknown position: "" + position);

				container.register(this);
			}
		} 

		
		void open()
		{
			win = factory.createDockableWindow(view,position);
			if(win == null)
			{
				
				return;
			}

			Log.log(Log.DEBUG,this,""Adding "" + name + "" with position "" + position);

			if(position.equals(FLOATING))
			{
				container = new FloatingWindowContainer(
					DockableWindowManager.this);
				container.register(this);
			}

			container.add(this);
		} 

		
		void remove()
		{
			Log.log(Log.DEBUG,this,""Removing "" + name + "" from ""
				+ container);

			container.save(this);
			container.remove(this);

			if(container instanceof FloatingWindowContainer)
				container = null;

			win = null;
		} 
	} 
}
"
jEdit,4,org.gjt.sp.jedit.pluginmgr.PluginList,5,1,0,11,27,0,4,8,0,0.5,158,0.0,0,0.0,0.466666667,0,0,30.0,5,1.8,2,"

package org.gjt.sp.jedit.pluginmgr;

import com.microstar.xml.*;
import java.io.*;
import java.net.URL;
import java.util.Hashtable;
import java.util.Vector;
import java.util.zip.GZIPInputStream;
import org.gjt.sp.util.Log;
import org.gjt.sp.jedit.*;


class PluginList
{
	Vector plugins;
	Hashtable pluginHash;
	Vector pluginSets;

	PluginList() throws Exception
	{
		plugins = new Vector();
		pluginHash = new Hashtable();
		pluginSets = new Vector();

		String path = jEdit.getProperty(""plugin-manager.url"");
		PluginListHandler handler = new PluginListHandler(this,path);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);

		parser.parse(null,null,new BufferedReader(new InputStreamReader(
			new GZIPInputStream(new URL(path).openStream()),""UTF8"")));
	}

	void addPlugin(Plugin plugin)
	{
		plugin.checkIfInstalled();
		plugins.addElement(plugin);
		pluginHash.put(plugin.name,plugin);
	}

	void addPluginSet(PluginSet set)
	{
		pluginSets.addElement(set);
	}

	void finished()
	{
		
		
		for(int i = 0; i < plugins.size(); i++)
		{
			Plugin plugin = (Plugin)plugins.elementAt(i);
			for(int j = 0; j < plugin.branches.size(); j++)
			{
				Branch branch = (Branch)plugin.branches.elementAt(j);
				for(int k = 0; k < branch.deps.size(); k++)
				{
					Dependency dep = (Dependency)branch.deps.elementAt(k);
					if(dep.what.equals(""plugin""))
						dep.plugin = (Plugin)pluginHash.get(dep.pluginName);
				}
			}
		}
	}

	void dump()
	{
		for(int i = 0; i < plugins.size(); i++)
		{
			System.err.println((Plugin)plugins.elementAt(i));
			System.err.println();
		}
	}

	static class PluginSet
	{
		String name;
		String description;
		Vector plugins = new Vector();

		void install(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			for(int i = 0; i < plugins.size(); i++)
			{
				Plugin plugin = (Plugin)plugins.elementAt(i);
				if(plugin.canBeInstalled())
				{
					plugin.install(roster,installDirectory,
						downloadSource);
				}
			}
		}

		public String toString()
		{
			return plugins.toString();
		}
	}

	static class Plugin
	{
		String jar;
		String name;
		String description;
		String author;
		Vector branches = new Vector();
		String installed;
		String installedVersion;

		void checkIfInstalled()
		{
			
			
			EditPlugin.JAR[] jars = jEdit.getPluginJARs();
			for(int i = 0; i < jars.length; i++)
			{
				String path = jars[i].getPath();
				if(!new File(path).exists())
					continue;

				if(MiscUtilities.getFileName(path).equals(jar))
				{
					installed = path;

					EditPlugin[] plugins = jars[i].getPlugins();
					if(plugins.length >= 1)
					{
						installedVersion = jEdit.getProperty(
							""plugin."" + plugins[0].getClassName()
							+ "".version"");
					}
					break;
				}
			}

			String[] notLoaded = jEdit.getNotLoadedPluginJARs();
			for(int i = 0; i < notLoaded.length; i++)
			{
				String path = notLoaded[i];

				if(MiscUtilities.getFileName(path).equals(jar))
				{
					installed = path;
					break;
				}
			}
		}

		
		Branch getCompatibleBranch()
		{
			for(int i = 0; i < branches.size(); i++)
			{
				Branch branch = (Branch)branches.elementAt(i);
				if(branch.canSatisfyDependencies())
					return branch;
			}

			return null;
		}

		boolean canBeInstalled()
		{
			Branch branch = getCompatibleBranch();
			return branch != null && !branch.obsolete
				&& branch.canSatisfyDependencies();
		}

		void install(Roster roster, String installDirectory, boolean downloadSource)
		{
			if(installed != null)
				roster.addOperation(new Roster.Remove(installed));

			Branch branch = getCompatibleBranch();
			if(branch.obsolete)
				return;

			branch.satisfyDependencies(roster,installDirectory,
				downloadSource);

			if(installed != null)
			{
				installDirectory = MiscUtilities.getParentOfPath(
					installed);
			}

			roster.addOperation(new Roster.Install((downloadSource
				? branch.downloadSource : branch.download),
				installDirectory));

		}

		public String toString()
		{
			return name;
		}
	}

	static class Branch
	{
		String version;
		String date;
		int downloadSize;
		String download;
		int downloadSourceSize;
		String downloadSource;
		boolean obsolete;
		Vector deps = new Vector();

		boolean canSatisfyDependencies()
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = (Dependency)deps.elementAt(i);
				if(!dep.canSatisfy())
					return false;
			}

			return true;
		}

		void satisfyDependencies(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = (Dependency)deps.elementAt(i);
				dep.satisfy(roster,installDirectory,downloadSource);
			}
		}

		public String toString()
		{
			return ""[version="" + version + "",download="" + download
				+ "",obsolete="" + obsolete + "",deps="" + deps + ""]"";
		}
	}

	static class Dependency
	{
		String what;
		String from;
		String to;
		
		String pluginName;
		Plugin plugin;

		Dependency(String what, String from, String to, String pluginName)
		{
			this.what = what;
			this.from = from;
			this.to = to;
			this.pluginName = pluginName;
		}

		boolean isSatisfied()
		{
			if(what.equals(""plugin""))
			{
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					Branch branch = (Branch)plugin.branches
						.elementAt(i);
					if(plugin.installedVersion != null
						&&
					(from == null || MiscUtilities.compareStrings(
						plugin.installedVersion,from,false) >= 0)
						&&
					   (to == null || MiscUtilities.compareStrings(
					   	plugin.installedVersion,to,false) <= 0))
					{
						return true;
					}
				}

				return false;
			}
			else if(what.equals(""jdk""))
			{
				String javaVersion = System.getProperty(""java.version"").substring(0,3);

				if((from == null || MiscUtilities.compareStrings(
					javaVersion,from,false) >= 0)
					&&
				   (to == null || MiscUtilities.compareStrings(
				   	javaVersion,to,false) <= 0))
					return true;
				else
					return false;
			}
			else if(what.equals(""jedit""))
			{
				String build = jEdit.getBuild();

				if((from == null || MiscUtilities.compareStrings(
					build,from,false) >= 0)
					&&
				   (to == null || MiscUtilities.compareStrings(
				   	build,to,false) <= 0))
					return true;
				else
					return false;
			}
			else
			{
				Log.log(Log.ERROR,this,""Invalid dependency: "" + what);
				return false;
			}
		}

		boolean canSatisfy()
		{
			if(isSatisfied())
				return true;
			else if(what.equals(""plugin""))
			{
				return plugin.canBeInstalled();
			}
			else
				return false;
		}

		void satisfy(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			if(what.equals(""plugin""))
			{
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					Branch branch = (Branch)plugin.branches
						.elementAt(i);
					if((plugin.installedVersion == null
						||
					MiscUtilities.compareStrings(
						plugin.installedVersion,branch.version,false) < 0)
						&&
					(from == null || MiscUtilities.compareStrings(
						branch.version,from,false) >= 0)
						&&
					   (to == null || MiscUtilities.compareStrings(
					   	branch.version,to,false) <= 0))
					{
						plugin.install(roster,installDirectory,
							downloadSource);
						return;
					}
				}
			}
		}

		public String toString()
		{
			return ""[what="" + what + "",from="" + from
				+ "",to="" + to + "",plugin="" + plugin + ""]"";
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.gui.AbbrevEditor,8,5,0,5,31,0,4,1,8,0.571428571,418,1.0,0,0.989393939,0.625,0,0,50.875,12,3.0,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public class AbbrevEditor extends JPanel
{
	
	public AbbrevEditor()
	{
		GridBagLayout layout = new GridBagLayout();
		setLayout(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.anchor = cons.WEST;
		cons.fill = cons.BOTH;
		cons.weightx = 0.0f;
		cons.gridx = 1;
		cons.gridy = 1;

		JLabel label = new JLabel(jEdit.getProperty(""abbrev-editor.abbrev""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		add(label);
		cons.gridx++;
		cons.weightx = 1.0f;
		abbrev = new JTextField();
		layout.setConstraints(abbrev,cons);
		add(abbrev);

		cons.gridx = 1;
		cons.weightx = 0.0f;
		cons.gridwidth = 2;

		cons.gridy++;
		label = new JLabel(jEdit.getProperty(""abbrev-editor.before""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);

		cons.gridy++;
		cons.weighty = 1.0f;
		beforeCaret = new JTextArea(4,40);
		JScrollPane scroller = new JScrollPane(beforeCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);

		cons.gridy++;
		cons.weighty = 0.0f;
		label = new JLabel(jEdit.getProperty(""abbrev-editor.after""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);

		cons.gridy++;
		cons.weighty = 1.0f;
		afterCaret = new JTextArea(4,40);
		scroller = new JScrollPane(afterCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);
	} 

	
	public String getAbbrev()
	{
		return abbrev.getText();
	} 

	
	public void setAbbrev(String abbrev)
	{
		this.abbrev.setText(abbrev);
	} 

	
	public String getExpansion()
	{
		StringBuffer buf = new StringBuffer();

		String beforeCaretText = beforeCaret.getText();
		String afterCaretText = afterCaret.getText();

		for(int i = 0; i < beforeCaretText.length(); i++)
		{
			char ch = beforeCaretText.charAt(i);
			switch(ch)
			{
			case '\n':
				buf.append(""\\n"");
				break;
			case '\t':
				buf.append(""\\t"");
				break;
			case '\\':
				buf.append(""\\\\"");
				break;
			default:
				buf.append(ch);
				break;
			}
		}

		if(afterCaretText.length() != 0)
		{
			buf.append(""\\|"");

			for(int i = 0; i < afterCaretText.length(); i++)
			{
				char ch = afterCaretText.charAt(i);
				switch(ch)
				{
				case '\n':
					buf.append(""\\n"");
					break;
				case '\t':
					buf.append(""\\t"");
					break;
				case '\\':
					buf.append(""\\\\"");
					break;
				default:
					buf.append(ch);
					break;
				}
			}
		}

		return buf.toString();
	} 

	
	public void setExpansion(String expansion)
	{
		if(expansion == null)
		{
			beforeCaret.setText(null);
			afterCaret.setText(null);
			return;
		}

		String beforeCaretText = null;
		String afterCaretText = null;
		StringBuffer buf = new StringBuffer();

		for(int i = 0; i < expansion.length(); i++)
		{
			char ch = expansion.charAt(i);

			if(ch == '\\' && i != expansion.length() - 1)
			{
				ch = expansion.charAt(++i);
				switch(ch)
				{
				case 't':
					buf.append('\t');
					break;
				case 'n':
					buf.append('\n');
					break;
				case '|':
					beforeCaretText = buf.toString();
					buf.setLength(0);
					break;
				default:
					buf.append(ch);
					break;
				}
			}
			else
				buf.append(ch);
		}

		if(beforeCaretText == null)
			beforeCaretText = buf.toString();
		else
			afterCaretText = buf.toString();

		beforeCaret.setText(beforeCaretText);
		afterCaret.setText(afterCaretText);
	} 

	
	public JTextField getAbbrevField()
	{
		return abbrev;
	} 

	
	public JTextArea getBeforeCaretTextArea()
	{
		return beforeCaret;
	} 

	
	public JTextArea getAfterCaretTextArea()
	{
		return afterCaret;
	} 

	
	private JTextField abbrev;
	private JTextArea beforeCaret, afterCaret;
	
}
"
jEdit,4,org.gjt.sp.jedit.gui.EnhancedButton,3,6,0,4,13,1,2,3,2,0.5,54,1.0,1,0.997382199,0.4,1,1,16.66666667,1,0.6667,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.EditAction;
import org.gjt.sp.jedit.GUIUtilities;


public class EnhancedButton extends JButton
{
	
	public EnhancedButton(Icon icon, String toolTip, EditAction action)
	{
		super(icon);

		this.action = action;

		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(action));
			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);

		setToolTipText(toolTip);

		Insets zeroInsets = new Insets(0,0,0,0);
		setMargin(zeroInsets);
		setRequestFocusEnabled(false);
	} 

	
	public boolean isFocusTraversable()
	{
		return false;
	} 

	
	private EditAction action;
	

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseEntered(MouseEvent evt)
		{
			String msg = action.getMouseOverText();
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
			}
		}

		public void mouseExited(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.options.ToolBarOptionPane,12,6,0,10,65,34,3,9,1,0.784090909,448,1.0,0,0.983655275,0.5,3,5,35.66666667,8,2.0833,2,"

package org.gjt.sp.jedit.options;

import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class ToolBarOptionPane extends AbstractOptionPane
{
	public ToolBarOptionPane()
	{
		super(""toolbar"");
	}

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		JPanel panel = new JPanel(new GridLayout(2,1));

		
		showToolbar = new JCheckBox(jEdit.getProperty(
			""options.toolbar.showToolbar""));
		showToolbar.setSelected(jEdit.getBooleanProperty(""view.showToolbar""));
		panel.add(showToolbar);

		panel.add(new JLabel(jEdit.getProperty(
			""options.toolbar.caption"")));

		add(BorderLayout.NORTH,panel);

		String toolbar = jEdit.getProperty(""view.toolbar"");
		StringTokenizer st = new StringTokenizer(toolbar);
		listModel = new DefaultListModel();
		while(st.hasMoreTokens())
		{
			String actionName = (String)st.nextToken();
			if(actionName.equals(""-""))
				listModel.addElement(new ToolBarOptionPane.Button(""-"",null,null,""-""));
			else
			{
				EditAction action = jEdit.getAction(actionName);
				if(action == null)
					continue;
				String label = action.getLabel();
				if(label == null)
					continue;

				Icon icon;
				String iconName;
				if(actionName.equals(""-""))
				{
					iconName = null;
					icon = null;
				}
				else
				{
					iconName = jEdit.getProperty(actionName + "".icon"");
					if(iconName == null)
						continue;

					icon = GUIUtilities.loadIcon(iconName);
				}
				listModel.addElement(new Button(actionName,iconName,icon,label));
			}
		}

		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());
		list.setCellRenderer(new ButtonCellRenderer());

		add(BorderLayout.CENTER,new JScrollPane(list));

		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.add(Box.createGlue());
		ActionHandler actionHandler = new ActionHandler();
		add = new JButton(jEdit.getProperty(""options.toolbar.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new JButton(jEdit.getProperty(""options.toolbar.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new JButton(jEdit.getProperty(""options.toolbar.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new JButton(jEdit.getProperty(""options.toolbar.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createGlue());

		updateButtons();
		add(BorderLayout.SOUTH,buttons);

		
		iconList = new DefaultComboBoxModel();
		st = new StringTokenizer(jEdit.getProperty(""icons""));
		while(st.hasMoreElements())
		{
			String icon = st.nextToken();
			iconList.addElement(new IconListEntry(
				GUIUtilities.loadIcon(icon),icon));
		}
	}

	static class ButtonCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return MiscUtilities.compareStrings(
				((Button)obj1).label,
				((Button)obj2).label,
				true);
		}
	}

	protected void _save()
	{
		jEdit.setBooleanProperty(""view.showToolbar"",showToolbar
			.isSelected());

		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');
			Button button = (Button)listModel.elementAt(i);
			buf.append(button.actionName);
			jEdit.setProperty(button.actionName + "".icon"",button.iconName);
		}
		jEdit.setProperty(""view.toolbar"",buf.toString());
	}

	
	private JCheckBox showToolbar;
	private DefaultListModel listModel;
	private JList list;
	private JButton add;
	private JButton remove;
	private JButton moveUp, moveDown;

	private DefaultComboBoxModel iconList;

	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
	}

	static class Button
	{
		String actionName;
		String iconName;
		Icon icon;
		String label;

		Button(String actionName, String iconName, Icon icon, String label)
		{
			this.actionName = actionName;
			this.iconName = iconName;
			this.icon = icon;
			this.label = GUIUtilities.prettifyMenuLabel(label);
		}

		public String toString()
		{
			return label;
		}
	}

	static class IconListEntry
	{
		Icon icon;
		String name;

		IconListEntry(Icon icon, String name)
		{
			this.icon = icon;
			this.name = name;
		}
	}

	static class ButtonCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			Button button = (Button)value;
			setIcon(button.icon);

			return this;
		}
	}

	static class IconCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			IconListEntry icon = (IconListEntry)value;
			setText(icon.name);
			setIcon(icon.icon);

			return this;
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == add)
			{
				ToolBarEditDialog dialog = new ToolBarEditDialog(
					ToolBarOptionPane.this,iconList,null);
				Button selection = dialog.getSelection();
				if(selection == null)
					return;

				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;

				listModel.insertElementAt(selection,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
				list.ensureIndexIsVisible(index-1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
				list.ensureIndexIsVisible(index+1);
			}
		}
	}

	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	}
}

class ToolBarEditDialog extends EnhancedDialog
{
	public ToolBarEditDialog(Component comp,
		DefaultComboBoxModel iconListModel,
		ToolBarOptionPane.Button current)
	{
		super(JOptionPane.getFrameForComponent(comp),
			jEdit.getProperty(""options.toolbar.edit.title""),
			true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();

		JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));
		typePanel.setBorder(new EmptyBorder(0,0,6,0));
		typePanel.add(new JLabel(
			jEdit.getProperty(""options.toolbar.edit.caption"")));

		separator = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".edit.separator""));
		separator.addActionListener(actionHandler);
		grp.add(separator);
		typePanel.add(separator);

		action = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".edit.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		action.setSelected(true);
		typePanel.add(action);

		content.add(BorderLayout.NORTH,typePanel);

		JPanel actionPanel = new JPanel(new BorderLayout(6,6));

		ActionSet[] actionsList = jEdit.getActionSets();
		Vector vec = new Vector(actionsList.length);
		for(int i = 0; i < actionsList.length; i++)
		{
			ActionSet actionSet = actionsList[i];
			if(actionSet.getActionCount() != 0)
				vec.addElement(actionSet);
		}
		combo = new JComboBox(vec);
		combo.addActionListener(actionHandler);
		actionPanel.add(BorderLayout.NORTH,combo);

		list = new JList();
		list.setVisibleRowCount(8);
		actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));

		
		JPanel iconPanel = new JPanel(new BorderLayout(0,3));
		JPanel labelPanel = new JPanel(new GridLayout(2,1));
		labelPanel.setBorder(new EmptyBorder(0,0,0,12));
		JPanel compPanel = new JPanel(new GridLayout(2,1));
		grp = new ButtonGroup();
		labelPanel.add(builtin = new JRadioButton(jEdit.getProperty(
			""options.toolbar.edit.builtin"")));
		builtin.addActionListener(actionHandler);
		builtin.setSelected(true);
		grp.add(builtin);
		labelPanel.add(file = new JRadioButton(jEdit.getProperty(
			""options.toolbar.edit.file"")));
		grp.add(file);
		file.addActionListener(actionHandler);
		iconPanel.add(BorderLayout.WEST,labelPanel);
		builtinCombo = new JComboBox(iconListModel);
		builtinCombo.setRenderer(new ToolBarOptionPane.IconCellRenderer());
		compPanel.add(builtinCombo);

		fileButton = new JButton(jEdit.getProperty(""options.toolbar.edit.no-icon""));
		fileButton.setMargin(new Insets(1,1,1,1));
		fileButton.setIcon(GUIUtilities.loadIcon(""Blank24.gif""));
		fileButton.setHorizontalAlignment(SwingConstants.LEFT);
		fileButton.addActionListener(actionHandler);
		compPanel.add(fileButton);
		iconPanel.add(BorderLayout.CENTER,compPanel);
		actionPanel.add(BorderLayout.SOUTH,iconPanel);

		content.add(BorderLayout.CENTER,actionPanel);

		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,southPanel);

		updateEnabled();
		updateList();

		pack();
		setLocationRelativeTo(JOptionPane.getFrameForComponent(comp));
		show();
	}

	public void ok()
	{
		isOK = true;
		dispose();
	}

	public void cancel()
	{
		dispose();
	}

	public ToolBarOptionPane.Button getSelection()
	{
		if(!isOK)
			return null;

		if(separator.isSelected())
			return new ToolBarOptionPane.Button(""-"",null,null,""-"");
		else
		{
			Icon icon;
			String iconName;
			if(builtin.isSelected())
			{
				ToolBarOptionPane.IconListEntry selectedIcon =
					(ToolBarOptionPane.IconListEntry)
					builtinCombo.getSelectedItem();
				icon = selectedIcon.icon;
				iconName = selectedIcon.name;
			}
			else
			{
				icon = fileButton.getIcon();
				iconName = fileIcon;
				if(iconName == null)
					iconName = ""Blank24.gif"";
			}

			String label;
			String actionName;
			if(action.isSelected())
			{
				ToolBarOptionPane.Button button =
					(ToolBarOptionPane.Button)list
					.getSelectedValue();
				label = button.label;
				actionName = button.actionName;
			}
			else
				throw new InternalError();

			return new ToolBarOptionPane.Button(actionName,
				iconName,icon,label);
		}
	}

	
	private boolean isOK;
	private JRadioButton separator, action;
	private JComboBox combo;
	private JList list;
	private JRadioButton builtin;
	private JComboBox builtinCombo;
	private JRadioButton file;
	private JButton fileButton;
	private String fileIcon;
	private JButton ok, cancel;

	private void updateEnabled()
	{
		combo.setEnabled(action.isSelected());
		list.setEnabled(action.isSelected());

		boolean iconControlsEnabled = !separator.isSelected();
		builtin.setEnabled(iconControlsEnabled);
		file.setEnabled(iconControlsEnabled);
		builtinCombo.setEnabled(iconControlsEnabled && builtin.isSelected());
		fileButton.setEnabled(iconControlsEnabled && file.isSelected());
	}

	private void updateList()
	{
		ActionSet actionSet = (ActionSet)combo.getSelectedItem();
		EditAction[] actions = actionSet.getActions();
		Vector listModel = new Vector(actions.length);

		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			String label = action.getLabel();
			if(label == null)
				continue;

			listModel.addElement(new ToolBarOptionPane.Button(
				action.getName(),null,null,label));
		}

		MiscUtilities.quicksort(listModel,new ToolBarOptionPane.ButtonCompare());
		list.setListData(listModel);
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
				updateEnabled();
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == combo)
				updateList();
			else if(source == fileButton)
			{
				String directory;
				if(fileIcon == null)
					directory = null;
				else
					directory = MiscUtilities.getParentOfPath(fileIcon);
				String paths[] = GUIUtilities.showVFSFileDialog(null,directory,
					VFSBrowser.OPEN_DIALOG,false);
				if(paths == null)
					return;

				fileIcon = ""file:"" + paths[0];

				try
				{
					fileButton.setIcon(new ImageIcon(new URL(
						fileIcon)));
				}
				catch(MalformedURLException mf)
				{
					Log.log(Log.ERROR,this,mf);
				}
				fileButton.setText(MiscUtilities.getFileName(fileIcon));
			}
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.ActionListHandler,11,2,0,6,28,31,1,5,7,0.8,222,1.0,1,0.565217391,0.333333333,1,3,18.45454545,8,2.2727,0,"

package org.gjt.sp.jedit;


import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;


class ActionListHandler extends HandlerBase
{
	
	ActionListHandler(String path, ActionSet actionSet)
	{
		this.path = path;
		this.actionSet = actionSet;
		stateStack = new Stack();
	} 

	
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""actions.dtd"".equals(systemId))
		{
			
			
			
			return new StringReader(""<!-- -->"");

			
		}

		return null;
	} 

	
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();

		if(aname == ""NAME"")
			actionName = value;
		else if(aname == ""NO_REPEAT"")
			noRepeat = (value == ""TRUE"");
		else if(aname == ""NO_RECORD"")
			noRecord = (value == ""TRUE"");
	} 

	
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""ACTIONS"".equals(name))
			return;

		Log.log(Log.ERROR,this,path + "": DOCTYPE must be ACTIONS"");
	} 

	
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);

		if (tag == ""CODE"")
		{
			code = text;
		}
		else if (tag == ""IS_SELECTED"")
		{
			isSelected = text;
		}
	} 

	
	public void startElement(String tag)
	{
		tag = pushElement(tag);

		if (tag == ""ACTION"")
		{
			code = null;
			isSelected = null;
		}
	} 

	
	public void endElement(String name)
	{
		if(name == null)
			return;

		String tag = peekElement();

		if(name.equals(tag))
		{
			if(tag == ""ACTION"")
			{
				actionSet.addAction(new BeanShellAction(actionName,
					code,isSelected,noRepeat,noRecord));
				noRepeat = noRecord = false;
			}

			popElement();
		}
		else
		{
			
			throw new InternalError();
		}
	} 

	
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	} 

	

	
	private String path;
	private ActionSet actionSet;

	private String actionName;
	private String code;
	private String isSelected;

	private boolean noRepeat;
	private boolean noRecord;

	private Stack stateStack;
	

	
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();

		stateStack.push(name);

		return name;
	} 

	
	private String peekElement()
	{
		return (String) stateStack.peek();
	} 

	
	private String popElement()
	{
		return (String) stateStack.pop();
	} 
}
"
jEdit,4,org.gjt.sp.jedit.gui.MarkersMenu,2,8,0,8,24,1,2,8,2,2.0,126,0.0,0,0.998835856,0.75,3,4,62.0,9,4.5,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class MarkersMenu extends EnhancedMenu
{
	
	public MarkersMenu()
	{
		super(""markers"");
	} 

	
	public void setPopupMenuVisible(boolean b)
	{
		if(b)
		{
			final View view = GUIUtilities.getView(this);

			if(getMenuComponentCount() != 0)
			{
				for(int i = getMenuComponentCount() - 1;
					i >= 0;
					i--)
				{
					Component comp = getMenuComponent(i);
					if(comp instanceof JSeparator)
						break;
					else
						remove(comp);
				}
			}

			Buffer buffer = view.getBuffer();

			Vector markers = buffer.getMarkers();

			if(markers.size() == 0)
			{
				JMenuItem mi = new JMenuItem(jEdit.getProperty(
					""no-markers.label""));
				mi.setEnabled(false);
				add(mi);
				super.setPopupMenuVisible(b);
				return;
			}

			JMenu current = this;

			for(int i = 0; i < markers.size(); i++)
			{
				final Marker marker = (Marker)markers.elementAt(i);
				int lineNo = buffer.getLineOfOffset(marker.getPosition());

				if(current.getItemCount() >= 20 && i != markers.size() - 1)
				{
					
					JMenu newCurrent = new JMenu(
						jEdit.getProperty(
						""common.more""));
					current.add(newCurrent);
					current = newCurrent;
				}

				JMenuItem mi = new MarkersMenuItem(buffer,
					lineNo,marker.getShortcut());
				mi.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent evt)
					{
						view.getTextArea().setCaretPosition(
							marker.getPosition());
					}
				});
				current.add(mi);
			}
		}

		super.setPopupMenuVisible(b);
	} 

	
	static class MarkersMenuItem extends JMenuItem
	{
		
		MarkersMenuItem(Buffer buffer, int lineNo, char shortcut)
		{
			String text = buffer.getLineText(lineNo).trim();
			if(text.length() == 0)
				text = jEdit.getProperty(""markers.blank-line"");
			setText(lineNo + "": "" + text);

			shortcutProp = ""goto-marker.shortcut"";
			MarkersMenuItem.this.shortcut = shortcut;
		} 

		
		public Dimension getPreferredSize()
		{
			Dimension d = super.getPreferredSize();

			String shortcut = getShortcut();

			if(shortcut != null)
			{
				d.width += (getFontMetrics(acceleratorFont)
					.stringWidth(shortcut) + 15);
			}
			return d;
		} 

		
		public void paint(Graphics g)
		{
			super.paint(g);

			String shortcut = getShortcut();

			if(shortcut != null)
			{
				g.setFont(acceleratorFont);
				g.setColor(getModel().isArmed() ?
					acceleratorSelectionForeground :
					acceleratorForeground);
				FontMetrics fm = g.getFontMetrics();
				Insets insets = getInsets();
				g.drawString(shortcut,getWidth() - (fm.stringWidth(
					shortcut) + insets.right + insets.left + 5),
					getFont().getSize() + (insets.top - 1)
					);
			}
		} 

		
		private String shortcutProp;
		private char shortcut;
		private static Font acceleratorFont;
		private static Color acceleratorForeground;
		private static Color acceleratorSelectionForeground;

		
		private String getShortcut()
		{
			if(shortcut == '\0')
				return null;
			else
			{
				String shortcutPrefix = jEdit.getProperty(shortcutProp);

				if(shortcutPrefix == null)
					return null;
				else
				{
					return shortcutPrefix + "" "" + shortcut;
				}
			}
		} 

		
		static
		{
			acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
			acceleratorFont = new Font(""Monospaced"",
				acceleratorFont.getStyle(),
				acceleratorFont.getSize());
			acceleratorForeground = UIManager
				.getColor(""MenuItem.acceleratorForeground"");
			acceleratorSelectionForeground = UIManager
				.getColor(""MenuItem.acceleratorSelectionForeground"");
		} 

		
	} 
}
"
jEdit,4,org.gjt.sp.jedit.browser.VFSFileChooserDialog,13,7,0,17,86,48,5,17,7,0.869047619,530,1.0,1,0.981954887,0.241758242,4,7,39.23076923,10,2.0769,6,"

package org.gjt.sp.jedit.browser;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.Vector;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



public class VFSFileChooserDialog extends EnhancedDialog
implements WorkThreadProgressListener
{
	
	public VFSFileChooserDialog(View view, String path,
		int mode, boolean multipleSelection)
	{
		super(view,jEdit.getProperty(""vfs.browser.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		String name;
		if(path == null || path.endsWith(File.separator) || path.endsWith(""/""))
			name = null;
		else
		{
			VFS vfs = VFSManager.getVFSForPath(path);
			name = vfs.getFileName(path);
			path = vfs.getParentOfPath(path);
		}

		browser = new VFSBrowser(view,path,mode,multipleSelection,true);
		browser.addBrowserListener(new BrowserHandler());
		content.add(BorderLayout.CENTER,browser);

		JPanel bottomPanel = new JPanel(new BorderLayout());

		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));

		JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.dialog.filename""));
		panel.add(label);
		panel.add(Box.createHorizontalStrut(12));

		filenameField = new JTextField();
		filenameField.setText(name);
		filenameField.addKeyListener(new KeyHandler());
		filenameField.selectAll();
		label.setDisplayedMnemonic(jEdit.getProperty(
			""vfs.browser.dialog.filename.mnemonic"").charAt(0));
		label.setLabelFor(filenameField);
		Dimension dim = filenameField.getPreferredSize();
		dim.width = Integer.MAX_VALUE;
		filenameField.setMaximumSize(dim);
		Box box = new Box(BoxLayout.Y_AXIS);
		box.add(Box.createGlue());
		box.add(filenameField);
		box.add(Box.createGlue());
		panel.add(box);

		panel.add(Box.createHorizontalStrut(12));

		if(mode == VFSBrowser.BROWSER || mode == VFSBrowser.OPEN_DIALOG)
		{
			GUIUtilities.requestFocus(this,browser.getBrowserView()
				.getDefaultFocusComponent());
		}
		else
		{
			GUIUtilities.requestFocus(this,filenameField);
		}

		ok = new JButton(jEdit.getProperty(""vfs.browser.dialog.""
			+ (mode == VFSBrowser.OPEN_DIALOG ? ""open"" : ""save"")));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		panel.add(cancel);

		bottomPanel.add(BorderLayout.NORTH,panel);

		status = new JLabel("" "");
		status.setBorder(new EmptyBorder(12,0,0,0));
		bottomPanel.add(BorderLayout.SOUTH,status);
		content.add(BorderLayout.SOUTH,bottomPanel);

		VFSManager.getIOThreadPool().addProgressListener(this);

		pack();
		GUIUtilities.loadGeometry(this,""vfs.browser.dialog"");
		show();
	} 

	
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,""vfs.browser.dialog"");
		VFSManager.getIOThreadPool().removeProgressListener(this);
		super.dispose();
	} 

	
	public void ok()
	{
		VFS.DirectoryEntry[] files = browser.getSelectedFiles();

		String directory = browser.getDirectory();

		if(files.length == 0)
		{
			filename = filenameField.getText();

			if(filename.length() == 0)
			{
				getToolkit().beep();
				return;
			}
		}
		else
		{
			for(int i = 0; i < files.length; i++)
			{
				VFS.DirectoryEntry file = files[i];
				if(file.type == VFS.DirectoryEntry.FILESYSTEM
					|| file.type == VFS.DirectoryEntry.DIRECTORY)
				{
					browser.setDirectory(file.path);
					return;
				}
				else if(browser.getMode() == VFSBrowser.SAVE_DIALOG)
					filename = file.path;
			}
		}

		if(browser.getMode() == VFSBrowser.SAVE_DIALOG)
		{
			if(!MiscUtilities.isURL(directory)
				&& !MiscUtilities.isURL(filename))
			{
				filename = MiscUtilities.constructPath(directory,
					MiscUtilities.canonPath(filename));

				if(doFileExistsWarning(filename))
					return;
			}
		}

		isOK = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public String[] getSelectedFiles()
	{
		if(!isOK)
			return null;

		if(filename != null)
		{
			String path = browser.getDirectory();
			return new String[] { MiscUtilities.constructPath(
				path,filename) };
		}
		else
		{
			Vector vector = new Vector();
			VFS.DirectoryEntry[] selectedFiles = browser.getSelectedFiles();
			for(int i = 0; i < selectedFiles.length; i++)
			{
				VFS.DirectoryEntry file =  selectedFiles[i];
				if(file.type == VFS.DirectoryEntry.FILE)
					vector.addElement(file.path);
			}
			String[] retVal = new String[vector.size()];
			vector.copyInto(retVal);
			return retVal;
		}
	} 

	

	
	public void statusUpdate(final WorkThreadPool threadPool, int threadIndex)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				int requestCount = threadPool.getRequestCount();
				if(requestCount == 0)
				{
					status.setText(jEdit.getProperty(
						""view.status.io.done""));
				}
				else if(requestCount == 1)
				{
					status.setText(jEdit.getProperty(
						""view.status.io-1""));
				}
				else
				{
					Object[] args = { new Integer(requestCount) };
					status.setText(jEdit.getProperty(
						""view.status.io"",args));
				}
			}
		});
	} 

	
	public void progressUpdate(WorkThreadPool threadPool, int threadIndex)
	{
	} 

	

	

	
	private VFSBrowser browser;
	private JTextField filenameField;
	private JLabel status;
	private String filename;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;
	

	
	private boolean doFileExistsWarning(String filename)
	{
		if(new File(filename).exists())
		{
			String[] args = { MiscUtilities.getFileName(filename) };
			int result = GUIUtilities.confirm(browser,
				""fileexists"",args,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return true;
		}

		return false;
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(!browser.getDirectory().equals(
					browser.getDirectoryField().getText()))
				{
					browser.setDirectory(browser.getDirectoryField().getText());
					return;
				}

				ok();
			}
			else if(evt.getSource() == cancel)
				cancel();
		}
	} 

	
	class BrowserHandler implements BrowserListener
	{
		
		public void filesSelected(VFSBrowser browser, VFS.DirectoryEntry[] files)
		{
			if(files.length == 0)
				return;
			else if(files.length == 1)
			{
				VFS.DirectoryEntry file = files[0];
				if(file.type == VFS.DirectoryEntry.FILE)
				{
					String path = file.path;
					String directory = browser.getDirectory();
					VFS vfs = VFSManager.getVFSForPath(directory);
					String parent = vfs.getParentOfPath(path);
					if(parent.endsWith(""/"") || parent.endsWith(File.separator))
						parent = parent.substring(0,parent.length() - 1);
					if(parent.equals(directory))
						path = file.name;

					filenameField.setText(path);
				}
			}
			else
			{
				filenameField.setText(null);
			}
		} 

		
		public void filesActivated(VFSBrowser browser, VFS.DirectoryEntry[] files)
		{
			for(int i = 0; i < files.length; i++)
			{
				VFS.DirectoryEntry file = files[i];
				if(file.type == VFS.DirectoryEntry.FILESYSTEM
					|| file.type == VFS.DirectoryEntry.DIRECTORY)
				{
					
					
					return;
				}
			}

			ok();
		} 
	} 

	
	class KeyHandler extends KeyAdapter
	{
		
		public void keyPressed(KeyEvent evt)
		{
			browser.getBrowserView().selectNone();
		} 
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.gui.LogViewer,4,5,0,5,26,0,2,5,1,0.666666667,112,1.0,0,0.995426829,0.416666667,0,0,26.25,1,0.75,3,"

package org.gjt.sp.jedit.gui;

import java.awt.BorderLayout;
import java.awt.Component;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;

public class LogViewer extends JPanel
{
	public LogViewer()
	{
		super(new BorderLayout());

		Box captionBox = Box.createHorizontalBox();

		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			String[] args = { MiscUtilities.constructPath(
				settingsDirectory, ""activity.log"") };
			JLabel label = new JLabel(jEdit.getProperty(
				""log-viewer.caption"",args));
			captionBox.add(label);
		}

		captionBox.add(Box.createHorizontalGlue());

		tailIsOn = jEdit.getBooleanProperty(""log-viewer.tail"", false);
		tail = new JCheckBox(
			jEdit.getProperty(""log-viewer.tail.label""),tailIsOn);
		tail.addActionListener(new ActionHandler());
		captionBox.add(tail);

		textArea = new JTextArea(24,80);
		textArea.setDocument(Log.getLogDocument());
		textArea.getDocument().addDocumentListener(
			new DocumentHandler());
		

		add(BorderLayout.NORTH,captionBox);
		add(BorderLayout.CENTER,new JScrollPane(textArea));
	}

	private JTextArea textArea;
	private JCheckBox tail;
	private boolean tailIsOn;

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent e)
		{
			tailIsOn = !tailIsOn;
			jEdit.setBooleanProperty(""log-viewer.tail"",tailIsOn);
			if(tailIsOn)
				textArea.setCaretPosition(
					textArea.getDocument().getLength());
		}
	}

	class DocumentHandler implements DocumentListener
	{
		public void insertUpdate(DocumentEvent e)
		{
			if(tailIsOn)
				textArea.setCaretPosition(
					textArea.getDocument().getLength());
		}

		public void changedUpdate(DocumentEvent e) {}
		public void removeUpdate(DocumentEvent e) {}
	}
}
"
jEdit,4,org.gjt.sp.jedit.io.FileVFS,21,2,0,12,94,210,5,9,20,1.0,760,0.5,0,0.512195122,0.380952381,1,3,35.0952381,16,3.381,0,"

package org.gjt.sp.jedit.io;


import java.awt.Component;
import java.io.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class FileVFS extends VFS
{
	public static final String PERMISSIONS_PROPERTY = ""FileVFS__perms"";

	
	public FileVFS()
	{
		super(""file"");
	} 

	
	public int getCapabilities()
	{
		return READ_CAP | WRITE_CAP | BROWSE_CAP | DELETE_CAP
			| RENAME_CAP | MKDIR_CAP;
	} 

	
	public String getParentOfPath(String path)
	{
		if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return FileRootsVFS.PROTOCOL + "":"";
			else if(path.length() == 3 && path.endsWith("":\\""))
				return FileRootsVFS.PROTOCOL + "":"";
			else if(path.startsWith(""\\\\"") && path.indexOf('\\',2) == -1)
				return path;
		}

		return super.getParentOfPath(path);
	} 

	
	public String constructPath(String parent, String path)
	{
		if(parent.endsWith(File.separator))
			path = parent + path;
		else
			path = parent + File.separator + path;

		try
		{
			return new File(path).getCanonicalPath();
		}
		catch(IOException io)
		{
			return path;
		}
	} 

	
	public char getFileSeparator()
	{
		return File.separatorChar;
	} 

	
	public boolean load(View view, Buffer buffer, String path)
	{
		File file = new File(MiscUtilities.canonPath(path));

		
		if(!file.exists())
		{
			buffer.setNewFile(true);
			return true;
		}
		else
			buffer.setReadOnly(!file.canWrite());

		if(file.isDirectory())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.open-directory"",null);
			buffer.setNewFile(false);
			return false;
		}

		if(!file.canRead())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.no-read"",null);
			buffer.setNewFile(false);
			return false;
		} 

		return super.load(view,buffer,path);
	} 

	
	public boolean save(View view, Buffer buffer, String path)
	{
		
		
		File file = new File(path);

		

		
		
		if(file.isDirectory())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.save-directory"",null);
			return false;
		}

		
		if((file.exists() && !file.canWrite())
			|| (!file.exists() && !new File(file.getParent()).canWrite()))
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.no-write"",null);
			return false;
		} 

		
		if(OperatingSystem.isUnix())
		{
			int permissions = getPermissions(buffer.getPath());
			Log.log(Log.DEBUG,this,buffer.getPath() + "" has permissions 0""
				+ Integer.toString(permissions,8));
			buffer.setIntegerProperty(PERMISSIONS_PROPERTY,permissions);
		} 

		return super.save(view,buffer,path);
	} 

	
	public boolean insert(View view, Buffer buffer, String path)
	{
		File file = new File(path);

		
		if(!file.exists())
			return false;

		if(file.isDirectory())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.open-directory"",null);
			return false;
		}

		if(!file.canRead())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.no-read"",null);
			return false;
		} 

		return super.insert(view,buffer,path);
	} 

	
	
	public String _canonPath(Object session, String path, Component comp)
		throws IOException
	{
		return MiscUtilities.canonPath(path);
	} 

	
	public VFS.DirectoryEntry[] _listDirectory(Object session, String path,
		Component comp)
	{
		
		
		if(OperatingSystem.isWindows())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				path = path.concat(File.separator);
		} 

		File directory = new File(path);
		File[] list = directory.listFiles();
		if(list == null)
		{
			VFSManager.error(comp,path,""ioerror.directory-error-nomsg"",null);
			return null;
		}

		Vector list2 = new Vector();
		for(int i = 0; i < list.length; i++)
		{
			File file = list[i];

			int type;
			if(file.isDirectory())
				type = VFS.DirectoryEntry.DIRECTORY;
			else
				type = VFS.DirectoryEntry.FILE;

			list2.add(new VFS.DirectoryEntry(file.getName(),
				file.getPath(),file.getPath(),type,
				file.length(),file.isHidden()));
		}

		VFS.DirectoryEntry[] retVal = new VFS.DirectoryEntry[list2.size()];
		list2.copyInto(retVal);
		return retVal;
	} 

	
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		
		
		if(path.endsWith(""/"") || path.endsWith(File.separator))
			path = path.substring(0,path.length() - 1);

		File file = new File(path);
		if(!file.exists())
			return null;

		int type;
		if(file.isDirectory())
			type = VFS.DirectoryEntry.DIRECTORY;
		else
			type = VFS.DirectoryEntry.FILE;

		return new VFS.DirectoryEntry(file.getName(),path,path,type,
			file.length(),file.isHidden());
	} 

	
	public boolean _delete(Object session, String path, Component comp)
	{
		boolean retVal = new File(path).delete();
		if(retVal)
			VFSManager.sendVFSUpdate(this,path,true);
		return retVal;
	} 

	
	public boolean _rename(Object session, String from, String to,
		Component comp)
	{
		File _to = new File(to);

		
		if(!from.equalsIgnoreCase(to))
			_to.delete();

		boolean retVal = new File(from).renameTo(_to);
		VFSManager.sendVFSUpdate(this,from,true);
		VFSManager.sendVFSUpdate(this,to,true);
		return retVal;
	} 

	
	public boolean _mkdir(Object session, String directory, Component comp)
	{
		boolean retVal = new File(directory).mkdirs();
		VFSManager.sendVFSUpdate(this,directory,true);
		return retVal;
	} 

	
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
		
		int backups = jEdit.getIntegerProperty(""backups"",1);

		if(backups == 0)
			return;

		String backupPrefix = jEdit.getProperty(""backup.prefix"");
		String backupSuffix = jEdit.getProperty(""backup.suffix"");

		String backupDirectory = MiscUtilities.canonPath(
			jEdit.getProperty(""backup.directory""));

		File file = new File(path);

		
		
		if(backupDirectory == null || backupDirectory.length() == 0)
			backupDirectory = file.getParent();
		else
		{
			backupDirectory = MiscUtilities.constructPath(
				System.getProperty(""user.home""),backupDirectory);

			
			
			backupDirectory = MiscUtilities.concatPath(
				backupDirectory,file.getParent());

			File dir = new File(backupDirectory);

			if (!dir.exists())
				dir.mkdirs();
		}

		MiscUtilities.saveBackup(file,backups,backupPrefix,
			backupSuffix,backupDirectory);
	} 

	
	public InputStream _createInputStream(Object session, String path,
		boolean ignoreErrors, Component comp) throws IOException
	{
		try
		{
			return new FileInputStream(path);
		}
		catch(IOException io)
		{
			if(ignoreErrors)
				return null;
			else
				throw io;
		}
	} 

	
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		OutputStream retVal = new FileOutputStream(path);

		
		
		
		return retVal;
	} 

	
	public void _saveComplete(Object session, Buffer buffer, Component comp)
	{
		int permissions = buffer.getIntegerProperty(PERMISSIONS_PROPERTY,0);
		setPermissions(buffer.getPath(),permissions);
	} 

	

	

	
	
	public static int getPermissions(String path)
	{
		int permissions = 0;

		if(OperatingSystem.isUnix())
		{
			String[] cmdarray = { ""ls"", ""-ld"", path };

			try
			{
				Process process = Runtime.getRuntime().exec(cmdarray);

				BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));

				String output = reader.readLine();

				if(output != null)
				{
					String s = output.substring(1, 10);

					if(s.length() == 9)
					{
						if(s.charAt(0) == 'r')
							permissions += 0400;
						if(s.charAt(1) == 'w')
							permissions += 0200;
						if(s.charAt(2) == 'x')
							permissions += 0100;
						else if(s.charAt(2) == 's')
							permissions += 04100;
						else if(s.charAt(2) == 'S')
							permissions += 04000;
						if(s.charAt(3) == 'r')
							permissions += 040;
						if(s.charAt(4) == 'w')
							permissions += 020;
						if(s.charAt(5) == 'x')
							permissions += 010;
						else if(s.charAt(5) == 's')
							permissions += 02010;
						else if(s.charAt(5) == 'S')
							permissions += 02000;
						if(s.charAt(6) == 'r')
							permissions += 04;
						if(s.charAt(7) == 'w')
							permissions += 02;
						if(s.charAt(8) == 'x')
							permissions += 01;
						else if(s.charAt(8) == 't')
							permissions += 01001;
						else if(s.charAt(8) == 'T')
							permissions += 01000;
					}
				}
			}

			
			
			
			catch (Throwable t)
			{
			}
		}

		return permissions;
	} 

	
	
	public static void setPermissions(String path, int permissions)
	{
		if(permissions != 0)
		{
			if(OperatingSystem.isUnix())
			{
				String[] cmdarray = { ""chmod"", Integer.toString(permissions, 8), path };

				try
				{
					Process process = Runtime.getRuntime().exec(cmdarray);
					process.getInputStream().close();
					process.getOutputStream().close();
					process.getErrorStream().close();
					int exitCode = process.waitFor();
					if(exitCode != 0)
						Log.log(Log.NOTICE,FileVFS.class,""chmod exited with code "" + exitCode);
				}

				
				
				
				catch (Throwable t)
				{
				}
			}
		}
	} 

	
}
"
jEdit,4,org.gjt.sp.jedit.options.LoadSaveOptionPane,5,6,0,4,35,0,2,3,3,0.714285714,404,1.0,0,0.993993994,0.5,3,5,77.0,5,1.8,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;


public class LoadSaveOptionPane extends AbstractOptionPane
{
	
	public LoadSaveOptionPane()
	{
		super(""loadsave"");
	} 

	
	public void _init()
	{
		
		autosave = new JTextField(jEdit.getProperty(""autosave""));
		addComponent(jEdit.getProperty(""options.loadsave.autosave""),autosave);

		
		backups = new JTextField(jEdit.getProperty(""backups""));
		addComponent(jEdit.getProperty(""options.loadsave.backups""),backups);

		
		backupDirectory = new JTextField(jEdit.getProperty(
			""backup.directory""));
		addComponent(jEdit.getProperty(""options.loadsave.backupDirectory""),
			backupDirectory);

		
		backupPrefix = new JTextField(jEdit.getProperty(""backup.prefix""));
		addComponent(jEdit.getProperty(""options.loadsave.backupPrefix""),
			backupPrefix);

		
		backupSuffix = new JTextField(jEdit.getProperty(
			""backup.suffix""));
		addComponent(jEdit.getProperty(""options.loadsave.backupSuffix""),
			backupSuffix);

		
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = jEdit.getProperty(""buffer.lineSeparator"",
			System.getProperty(""line.separator""));
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		addComponent(jEdit.getProperty(""options.loadsave.lineSeparator""),
			lineSeparator);

		
		DefaultComboBoxModel encodings = new DefaultComboBoxModel();
		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			encodings.addElement(st.nextToken());
		}

		encoding = new JComboBox(encodings);
		encoding.setEditable(true);
		encoding.setSelectedItem(jEdit.getProperty(""buffer.encoding"",
			System.getProperty(""file.encoding"")));
		addComponent(jEdit.getProperty(""options.loadsave.encoding""),encoding);

		
		ioThreadCount = new JTextField(jEdit.getProperty(""ioThreadCount""));
		addComponent(jEdit.getProperty(""options.loadsave.ioThreadCount""),
			ioThreadCount);

		
		restore = new JCheckBox(jEdit.getProperty(
			""options.loadsave.restore""));
		restore.setSelected(jEdit.getBooleanProperty(""restore""));
		restore.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				restoreCLI.setEnabled(restore.isSelected());
			}
		});

		addComponent(restore);
		restoreCLI = new JCheckBox(jEdit.getProperty(
			""options.loadsave.restore.cli""));
		restoreCLI.setSelected(jEdit.getBooleanProperty(""restore.cli""));
		restoreCLI.setEnabled(restore.isSelected());
		addComponent(restoreCLI);

		
		newView = new JCheckBox(jEdit.getProperty(
			""options.loadsave.newView""));
		newView.setSelected(jEdit.getBooleanProperty(""client.newView""));
		addComponent(newView);

		
		persistentMarkers = new JCheckBox(jEdit.getProperty(
			""options.loadsave.persistentMarkers""));
		persistentMarkers.setSelected(jEdit.getBooleanProperty(
			""persistentMarkers""));
		addComponent(persistentMarkers);

		
		twoStageSave = new JCheckBox(jEdit.getProperty(
			""options.loadsave.twoStageSave""));
		twoStageSave.setSelected(jEdit.getBooleanProperty(
			""twoStageSave""));
		addComponent(twoStageSave);

		
		backupEverySave = new JCheckBox(jEdit.getProperty(
			""options.loadsave.backupEverySave""));
		backupEverySave.setSelected(jEdit.getBooleanProperty(""backupEverySave""));
		addComponent(backupEverySave);

	} 

	
	public void _save()
	{
		jEdit.setProperty(""autosave"",autosave.getText());
		jEdit.setProperty(""backups"",backups.getText());
		jEdit.setProperty(""backup.directory"",backupDirectory.getText());
		jEdit.setProperty(""backup.prefix"",backupPrefix.getText());
		jEdit.setProperty(""backup.suffix"",backupSuffix.getText());
		String lineSep = null;
		switch(lineSeparator.getSelectedIndex())
		{
		case 0:
			lineSep = ""\n"";
			break;
		case 1:
			lineSep = ""\r\n"";
			break;
		case 2:
			lineSep = ""\r"";
			break;
		}
		jEdit.setProperty(""buffer.lineSeparator"",lineSep);
		jEdit.setProperty(""buffer.encoding"",(String)
			encoding.getSelectedItem());
		jEdit.setProperty(""ioThreadCount"",ioThreadCount.getText());
		jEdit.setBooleanProperty(""restore"",restore.isSelected());
		jEdit.setBooleanProperty(""restore.cli"",restoreCLI.isSelected());
		jEdit.setBooleanProperty(""client.newView"",newView.isSelected());
		jEdit.setBooleanProperty(""persistentMarkers"",
			persistentMarkers.isSelected());
		jEdit.setBooleanProperty(""twoStageSave"",twoStageSave.isSelected());
		jEdit.setBooleanProperty(""backupEverySave"", backupEverySave.isSelected());
	} 

	
	private JTextField autosave;
	private JTextField backups;
	private JTextField backupDirectory;
	private JTextField backupPrefix;
	private JTextField backupSuffix;
	private JComboBox lineSeparator;
	private JComboBox encoding;
	private JTextField ioThreadCount;
	private JCheckBox restore;
	private JCheckBox restoreCLI;
	private JCheckBox newView;
	private JCheckBox persistentMarkers;
	private JCheckBox twoStageSave;
	private JCheckBox backupEverySave;
	
}
"
jEdit,4,org.gjt.sp.jedit.msg.EditorStarted,1,3,0,3,2,0,1,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class EditorStarted extends EBMessage.NonVetoable
{
	
	public EditorStarted(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4,org.gjt.sp.util.WorkThreadProgressListener,2,1,0,5,2,1,5,1,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.util;

import java.util.EventListener;


public interface WorkThreadProgressListener extends EventListener
{
	
	void statusUpdate(WorkThreadPool threadPool, int threadIndex);

	
	void progressUpdate(WorkThreadPool threadPool, int threadIndex);
}
"
jEdit,4,org.gjt.sp.jedit.syntax.ParserRuleSet,20,1,0,11,30,152,7,4,20,0.935222672,212,1.0,5,0.0,0.155,0,0,8.95,3,1.2,1,"

package org.gjt.sp.jedit.syntax;

import java.util.*;
import org.gjt.sp.jedit.Mode;
import javax.swing.text.Segment;


public class ParserRuleSet
{
	
	public ParserRuleSet(String name, Mode mode)
	{
		this.name = name;
		this.mode = mode;
		ruleMapFirst = new ParserRule[RULE_BUCKET_COUNT];
		ruleMapLast = new ParserRule[RULE_BUCKET_COUNT];
	} 

	
	public Mode getMode()
	{
		return mode;
	} 

	
	public Hashtable getProperties()
	{
		return props;
	} 

	
	public void setProperties(Hashtable props)
	{
		this.props = props;
	} 

	
	public void addRule(ParserRule r)
	{
		int key = Character.toUpperCase(r.searchChars[0])
			% RULE_BUCKET_COUNT;
		ParserRule last = ruleMapLast[key];
		if(last == null)
			ruleMapFirst[key] = ruleMapLast[key] = r;
		else
		{
			last.next = r;
			ruleMapLast[key] = r;
		}
	} 

	
	public ParserRule getRules(char ch)
	{
		int key = Character.toUpperCase(ch) % RULE_BUCKET_COUNT;
		return ruleMapFirst[key];
	} 

	
	public int getTerminateChar()
	{
		return terminateChar;
	} 

	
	public void setTerminateChar(int atChar)
	{
		terminateChar = (atChar >= 0) ? atChar : -1;
	} 

	
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	} 

	
	public void setIgnoreCase(boolean b)
	{
		ignoreCase = b;
	} 

	
	public KeywordMap getKeywords()
	{
		return keywords;
	} 

	
	public void setKeywords(KeywordMap km)
	{
		keywords = km;
	} 

	
	public boolean getHighlightDigits()
	{
		return highlightDigits;
	} 

	
	public void setHighlightDigits(boolean highlightDigits)
	{
		this.highlightDigits = highlightDigits;
	} 

	
	public ParserRule getEscapeRule()
	{
		return escapeRule;
	} 

	
	public Segment getEscapePattern()
	{
		if (escapePattern == null && escapeRule != null)
		{
			escapePattern = new Segment(escapeRule.searchChars, 0,
				escapeRule.sequenceLengths[0]);
		}
		return escapePattern;
	} 

	
	public void setEscape(String esc)
	{
		if (esc == null)
		{
			escapeRule = null;
		}
		else
		{
			escapeRule = ParserRuleFactory.createEscapeRule(esc);
		}
		escapePattern = null;
	} 

	
	public byte getDefault()
	{
		return defaultToken;
	} 

	
	public void setDefault(byte def)
	{
		defaultToken = def;
	} 

	
	public String toString()
	{
		return getClass().getName() + ""["" + mode.getName() + ""::""
			+ name + ""]"";
	} 

	
	private static final int RULE_BUCKET_COUNT = 32;

	private String name;
	private Mode mode;
	private Hashtable props;

	private KeywordMap keywords;

	private ParserRule[] ruleMapFirst;
	private ParserRule[] ruleMapLast;

	private ParserRule escapeRule;
	private Segment escapePattern;
	private int terminateChar = -1;
	private boolean ignoreCase = true;
	private boolean highlightDigits;
	private byte defaultToken;
	
}
"
jEdit,4,org.gjt.sp.jedit.gui.IOProgressMonitor,5,6,0,10,33,4,5,7,2,0.666666667,142,1.0,2,0.993836672,0.5,1,1,26.8,1,0.8,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;

public class IOProgressMonitor extends JFrame
{
	public IOProgressMonitor()
	{
		super(jEdit.getProperty(""io-progress-monitor.title""));

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		caption = new JLabel();
		updateCaption();
		content.add(BorderLayout.NORTH,caption);

		Box threadBox = new Box(BoxLayout.Y_AXIS);
		threads = new ThreadProgress[VFSManager.getIOThreadPool()
			.getThreadCount()];
		for(int i = 0; i < threads.length; i++)
		{
			threadBox.add(Box.createVerticalStrut(6));

			threads[i] = new ThreadProgress(i);
			threadBox.add(threads[i]);
		}

		content.add(BorderLayout.CENTER,threadBox);

		workThreadHandler = new WorkThreadHandler();
		VFSManager.getIOThreadPool().addProgressListener(workThreadHandler);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		pack();
		GUIUtilities.loadGeometry(this,""io-progress-monitor"");
		show();
	}

	public void dispose()
	{
		GUIUtilities.saveGeometry(this,""io-progress-monitor"");
		VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);
		super.dispose();
	}

	
	private JLabel caption;
	private ThreadProgress[] threads;
	private WorkThreadHandler workThreadHandler;

	private void updateCaption()
	{
		String[] args = { String.valueOf(VFSManager.getIOThreadPool()
			.getRequestCount()) };
		caption.setText(jEdit.getProperty(""io-progress-monitor.caption"",args));
	}

	class WorkThreadHandler implements WorkThreadProgressListener
	{
		public void statusUpdate(final WorkThreadPool pool, final int index)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					updateCaption();
					threads[index].update();
				}
			});
		}

		public void progressUpdate(final WorkThreadPool pool, final int index)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					updateCaption();
					threads[index].update();
				}
			});
		}
	}

	class ThreadProgress extends JPanel
	{
		public ThreadProgress(int index)
		{
			super(new BorderLayout());

			this.index = index;

			JPanel box = new JPanel();
			box.setBorder(new EmptyBorder(0,0,0,12));
			box.setLayout(new BoxLayout(box,BoxLayout.Y_AXIS));
			box.add(Box.createGlue());
			box.add(progress = new JProgressBar());
			progress.setStringPainted(true);
			box.add(Box.createGlue());
			ThreadProgress.this.add(BorderLayout.CENTER,box);

			abort = new JButton(jEdit.getProperty(""io-progress-monitor.abort""));
			abort.addActionListener(new ActionHandler());
			ThreadProgress.this.add(BorderLayout.EAST,abort);

			update();
		}

		public void update()
		{
			WorkThread thread = VFSManager.getIOThreadPool().getThread(index);
			if(thread.isRequestRunning())
			{
				abort.setEnabled(true);
				progress.setString(thread.getStatus());
				progress.setMaximum(thread.getProgressMaximum());
				progress.setValue(thread.getProgressValue());
			}
			else
			{
				abort.setEnabled(false);
				progress.setString(jEdit.getProperty(""io-progress-monitor""
					+ "".idle""));
				progress.setValue(0);
			}
		}

		
		private int index;
		private JProgressBar progress;
		private JButton abort;

		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(evt.getSource() == abort)
				{
					int result = GUIUtilities.confirm(
						IOProgressMonitor.this,""abort"",null,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					if(result == JOptionPane.YES_OPTION)
					{
						VFSManager.getIOThreadPool().getThread(index)
							.abortCurrentRequest();
					}
				}
			}
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.pluginmgr.PluginListDownloadProgress,7,6,0,7,32,11,4,6,0,0.777777778,137,1.0,3,0.99086758,0.285714286,0,0,18.14285714,1,0.8571,0,"

package org.gjt.sp.jedit.pluginmgr;

import com.microstar.xml.XmlException;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.InterruptedIOException;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;

class PluginListDownloadProgress extends JDialog
{
	PluginListDownloadProgress(PluginManager window)
	{
		super(JOptionPane.getFrameForComponent(window),
			jEdit.getProperty(""plugin-list.progress.title""),true);

		this.window = window;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel caption = new JLabel(jEdit.getProperty(""plugin-list.progress.caption""));
		caption.setBorder(new EmptyBorder(0,0,12,0));
		content.add(BorderLayout.NORTH,caption);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		JButton stop = new JButton(jEdit.getProperty(""plugin-list.progress.stop""));
		stop.addActionListener(new ActionHandler());
		stop.setMaximumSize(stop.getPreferredSize());
		box.add(stop);
		box.add(Box.createGlue());
		content.add(BorderLayout.CENTER,box);

		addWindowListener(new WindowHandler());
		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		pack();
		setLocationRelativeTo(window);
		setResizable(false);
		show();
	}

	PluginList getPluginList()
	{
		return list;
	}

	
	private PluginManager window;
	private PluginList list;
	private DownloadThread thread;

	class DownloadThread extends Thread
	{
		public void run()
		{
			try
			{
				list = new PluginList();
				dispose();
			}
			catch(XmlException xe)
			{
				dispose();

				int line = xe.getLine();
				String path = jEdit.getProperty(""plugin-manager.url"");
				String message = xe.getMessage();
				Log.log(Log.ERROR,this,path + "":"" + line
					+ "": "" + message);
				String[] pp = { path, String.valueOf(line), message };
				GUIUtilities.error(window,""plugin-list.xmlerror"",pp);
			}
			catch(Exception e)
			{
				dispose();

				Log.log(Log.ERROR,this,e);
				String[] pp = { e.toString() };
				GUIUtilities.error(window,""plugin-list.ioerror"",pp);
			}
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			thread.stop();
			dispose();
		}
	}

	class WindowHandler extends WindowAdapter
	{
		boolean done;

		public void windowOpened(WindowEvent evt)
		{
			if(done)
				return;

			done = true;
			thread = new DownloadThread();
			thread.start();
		}

		public void windowClosing(WindowEvent evt)
		{
			thread.stop();
		}
	}
}
"
jEdit,4,org.gjt.sp.jedit.buffer.LineElement,11,1,0,2,14,49,2,1,11,0.8,50,1.0,1,0.0,0.454545455,0,0,3.363636364,1,0.9091,0,"

package org.gjt.sp.jedit.buffer;


import javax.swing.text.*;
import org.gjt.sp.jedit.Buffer;



public class LineElement implements Element
{
	
	public LineElement(Buffer buffer, int line)
	{
		this.buffer = buffer;
		this.line = line;
	} 

	
	public Document getDocument()
	{
		return null;
	} 

	
	public Element getParentElement()
	{
		return null;
	} 

	
	public String getName()
	{
		return null;
	} 

	
	public AttributeSet getAttributes()
	{
		return null;
	} 

	
	public int getStartOffset()
	{
		return buffer.getLineStartOffset(line);
	} 

	
	public int getEndOffset()
	{
		return buffer.getLineEndOffset(line);
	} 

	
	public int getElementIndex(int offset)
	{
		return 0;
	} 

	
	public int getElementCount()
	{
		return 0;
	} 

	
	public Element getElement(int line)
	{
		return null;
	} 

	
	public boolean isLeaf()
	{
		return true;
	} 

	
	private Buffer buffer;
	private int line;
	
} 
"
jEdit,4,org.gjt.sp.jedit.msg.BufferUpdate,6,3,0,12,14,5,9,5,5,0.938461538,87,0.153846154,1,0.6,0.4,1,1,11.33333333,1,0.6667,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class BufferUpdate extends EBMessage.NonVetoable
{
	
	
	public static final Object CREATED = ""CREATED"";

	
	public static final Object LOAD_STARTED = ""LOAD_STARTED"";

	
	public static final Object LOADED = ""LOADED"";

	
	public static final Object CLOSED = ""CLOSED"";

	
	public static final Object DIRTY_CHANGED = ""DIRTY_CHANGED"";

	
	public static final Object MARKERS_CHANGED = ""MARKERS_CHANGED"";

	
	public static final Object MODE_CHANGED = ""MODE_CHANGED"";

	
	public static final Object ENCODING_CHANGED = ""ENCODING_CHANGED"";

	
	public static final Object FOLD_HANDLER_CHANGED = ""FOLD_HANDLER_CHANGED"";

	
	public static final Object SAVING = ""SAVING"";

	
	public static final Object SAVED = ""SAVED"";
	

	
	
	public BufferUpdate(Buffer buffer, View view, Object what)
	{
		super(buffer);

		this.view = view;

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
	} 

	
	
	public Object getWhat()
	{
		return what;
	} 

	
	
	public Buffer getBuffer()
	{
		return (Buffer)getSource();
	} 

	
	
	public View getView()
	{
		return view;
	} 

	
	public String paramString()
	{
		return super.paramString() + "",what="" + what
			+ "",view="" + view;
	} 

	
	private Object what;
	private View view;
	
}
"
jEdit,4,org.gjt.sp.jedit.search.SearchFileSet,5,1,0,8,5,10,8,1,5,2.0,5,0.0,0,0.0,0.6,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.search;

import org.gjt.sp.jedit.*;


public interface SearchFileSet
{
	
	String getFirstFile(View view);

	
	String getNextFile(View view, String path);

	
	String[] getFiles(View view);

	
	int getFileCount();

	
	String getCode();
}
"
jEdit,4,org.gjt.sp.jedit.pluginmgr.Roster,5,1,0,9,14,0,8,2,0,0.0,82,1.0,0,0.0,0.466666667,0,0,15.2,4,2.0,1,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import java.awt.Component;
import java.io.*;
import java.net.*;
import java.util.zip.*;
import java.util.*;
import org.gjt.sp.jedit.io.VFSManager; 
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


class Roster
{
	
	Roster()
	{
		operations = new Vector();
	} 

	
	void addOperation(Operation op)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			if(operations.elementAt(i).equals(op))
				return;
		}

		operations.addElement(op);
	} 

	
	int getOperationCount()
	{
		return operations.size();
	} 

	
	boolean isEmpty()
	{
		return operations.size() == 0;
	} 

	
	boolean performOperations(PluginManagerProgress progress)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			Operation op = (Operation)operations.elementAt(i);
			if(op.perform(progress))
				progress.done(true);
			else
			{
				progress.done(false);
				return false;
			}

			if(Thread.interrupted())
				return false;
		}

		return true;
	} 

	
	private Vector operations;

	static interface Operation
	{
		boolean perform(PluginManagerProgress progress);
		boolean equals(Object o);
	} 

	
	static class Remove implements Operation
	{
		Remove(String plugin)
		{
			this.plugin = plugin;
		}

		public boolean perform(PluginManagerProgress progress)
		{
			progress.removing(MiscUtilities.getFileName(plugin));

			
			EditPlugin.JAR jar = jEdit.getPluginJAR(plugin);
			if(jar != null)
				jar.getClassLoader().closeZipFile();

			
			File jarFile = new File(plugin);
			File srcFile = new File(plugin.substring(0,plugin.length() - 4));

			boolean ok = true;
			ok &= deleteRecursively(jarFile);

			if(srcFile.exists())
				ok &= deleteRecursively(srcFile);

			String[] args = { plugin };
			if(!ok)
				GUIUtilities.error(progress,""plugin-manager.remove-failed"",args);
			return ok;
		}

		public boolean equals(Object o)
		{
			if(o instanceof Remove
				&& ((Remove)o).plugin.equals(plugin))
				return true;
			else
				return false;
		}

		
		private String plugin;

		private boolean deleteRecursively(File file)
		{
			Log.log(Log.NOTICE,this,""Deleting "" + file + "" recursively"");

			boolean ok = true;

			if(file.isDirectory())
			{
				String path = file.getPath();
				String[] children = file.list();
				for(int i = 0; i < children.length; i++)
				{
					ok &= deleteRecursively(new File(path,children[i]));
				}
			}

			ok &= file.delete();

			return ok;
		}
	} 

	
	static class Install implements Operation
	{
		Install(String url, String installDirectory)
		{
			
			if(url == null)
				throw new NullPointerException();

			this.url = url;
			this.installDirectory = installDirectory;
		}

		public boolean perform(final PluginManagerProgress progress)
		{
			try
			{
				String fileName = MiscUtilities.getFileName(url);
				progress.downloading(fileName);
				String path = download(progress,fileName,url);
				if(path == null)
				{
					
					return false;
				}

				progress.installing(fileName);
				install(progress,path,installDirectory);

				return true;
			}
			catch(InterruptedIOException iio)
			{
				
				return false;
			}
			catch(final IOException io)
			{
				Log.log(Log.ERROR,this,io);

				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						String[] args = { io.getMessage() };
						GUIUtilities.error(null,""ioerror"",args);
					}
				});

				return false;
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);

				return false;
			}
		}

		public boolean equals(Object o)
		{
			if(o instanceof Install
				&& ((Install)o).url.equals(url))
			{
				
				return true;
			}
			else
				return false;
		}

		
		private String url;
		private String installDirectory;

		private String download(PluginManagerProgress progress,
			String fileName, String url) throws Exception
		{
			URLConnection conn = new URL(url).openConnection();
			progress.setMaximum(Math.max(0,conn.getContentLength()));

			String path = MiscUtilities.constructPath(getDownloadDir(),fileName);

			if(!copy(progress,conn.getInputStream(),
				new FileOutputStream(path),true,true))
				return null;

			return path;
		}

		private boolean install(PluginManagerProgress progress,
			String path, String dir) throws Exception
		{
			progress.setMaximum(1);

			ZipFile zipFile = new ZipFile(path);
			Enumeration enum = zipFile.entries();
			while(enum.hasMoreElements())
			{
				ZipEntry entry = (ZipEntry)enum.nextElement();
				String name = entry.getName().replace('/',File.separatorChar);
				File file = new File(dir,name);
				if(entry.isDirectory())
					file.mkdirs();
				else
				{
					new File(file.getParent()).mkdirs();
					copy(progress,zipFile.getInputStream(entry),
						new FileOutputStream(file),false,false);
				}
			}

			new File(path).delete();

			progress.setValue(1);

			return true;
		}

		private boolean copy(PluginManagerProgress progress,
			InputStream in, OutputStream out, boolean canStop,
			boolean doProgress) throws Exception
		{
			in = new BufferedInputStream(in);
			out = new BufferedOutputStream(out);

			byte[] buf = new byte[4096];
			int copied = 0;
loop:			for(;;)
			{
				int count = in.read(buf,0,buf.length);
				if(count == -1)
					break loop;

				if(doProgress)
				{
					copied += count;
					progress.setValue(copied);
				}

				out.write(buf,0,count);
				if(canStop && Thread.interrupted())
				{
					in.close();
					out.close();
					return false;
				}
			}

			in.close();
			out.close();
			return true;
		}

		static File downloadDir;

		static String getDownloadDir()
		{
			if(downloadDir == null)
			{
				String settings = jEdit.getSettingsDirectory();
				if(settings == null)
					settings = System.getProperty(""user.home"");
				downloadDir = new File(MiscUtilities.constructPath(
					settings,""PluginManager.download""));
				downloadDir.mkdirs();
			}

			return downloadDir.getPath();
		}
	} 
}
"
jEdit,4,org.gjt.sp.jedit.search.HyperSearchResults,14,5,0,19,67,55,10,16,8,0.820512821,361,0.833333333,1,0.98048048,0.257142857,3,12,24.35714286,10,1.8571,2,"

package org.gjt.sp.jedit.search;


import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.jedit.View;
import org.gjt.sp.util.Log;



public class HyperSearchResults extends JPanel implements EBComponent
{
	public static final String NAME = ""hypersearch-results"";

	
	public HyperSearchResults(View view)
	{
		super(new BorderLayout());

		this.view = view;

		caption = new JLabel();
		updateCaption(0,0);
		add(BorderLayout.NORTH, caption);

		resultTreeRoot = new DefaultMutableTreeNode();
		resultTreeModel = new DefaultTreeModel(resultTreeRoot);
		resultTree = new JTree(resultTreeModel);
		resultTree.setCellRenderer(new ResultCellRenderer());
		resultTree.setVisibleRowCount(16);
		resultTree.setRootVisible(false);
		resultTree.setShowsRootHandles(true);
		resultTree.putClientProperty(""JTree.lineStyle"", ""Angled"");
		resultTree.setEditable(false);

		resultTree.addTreeSelectionListener(new TreeSelectionHandler());
		resultTree.addKeyListener(new KeyHandler());
		resultTree.addMouseListener(new MouseHandler());

		JScrollPane scrollPane = new JScrollPane(resultTree);
		Dimension dim = scrollPane.getPreferredSize();
		dim.width = 400;
		scrollPane.setPreferredSize(dim);
		add(BorderLayout.CENTER, scrollPane);
	} 

	
	public boolean requestDefaultFocus()
	{
		resultTree.grabFocus();
		return true;
	} 

	
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	} 

	
	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof BufferUpdate)
		{
			BufferUpdate bmsg = (BufferUpdate)msg;
			Buffer buffer = bmsg.getBuffer();
			if(bmsg.getWhat() == BufferUpdate.LOADED)
			{
				for(int i = resultTreeRoot.getChildCount() - 1; i >= 0; i--)
				{
					DefaultMutableTreeNode bufferNode = (DefaultMutableTreeNode)
						resultTreeRoot.getChildAt(i);

					for(int j = bufferNode.getChildCount() - 1;
						j >= 0; j--)
					{
						HyperSearchResult result = (HyperSearchResult)
							((DefaultMutableTreeNode)bufferNode
							.getChildAt(j)).getUserObject();
						if(buffer.getPath().equals(result.path))
							result.bufferOpened(buffer);
					}
				}
			}
			else if(bmsg.getWhat() == BufferUpdate.CLOSED)
			{
				for(int i = resultTreeRoot.getChildCount() - 1; i >= 0; i--)
				{
					DefaultMutableTreeNode bufferNode = (DefaultMutableTreeNode)
						resultTreeRoot.getChildAt(i);

					for(int j = bufferNode.getChildCount() - 1;
						j >= 0; j--)
					{
						HyperSearchResult result = (HyperSearchResult)
							((DefaultMutableTreeNode)bufferNode
							.getChildAt(j)).getUserObject();
						if(buffer.getPath().equals(result.path))
							result.bufferClosed();
					}
				}
			}
		}
	} 

	
	public DefaultTreeModel getTreeModel()
	{
		return resultTreeModel;
	} 

	
	public void searchStarted()
	{
		caption.setText(jEdit.getProperty(""hypersearch-results.searching""));
		resultTreeRoot.removeAllChildren();
		resultTreeModel.reload(resultTreeRoot);
	} 

	
	public void searchDone(int resultCount, int bufferCount)
	{
		updateCaption(resultCount,bufferCount);

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				for(int i = 0; i < resultTreeRoot.getChildCount(); i++)
				{
					resultTree.expandPath(new TreePath(
						((DefaultMutableTreeNode)
						resultTreeRoot.getChildAt(i))
						.getPath()));
				}
			}
		});
	} 

	
	private View view;

	private JLabel caption;
	private JTree resultTree;
	private DefaultMutableTreeNode resultTreeRoot;
	private DefaultTreeModel resultTreeModel;

	
	private void goToSelectedNode()
	{
		TreePath path = resultTree.getSelectionPath();
		if(path == null)
			return;

		Object value = ((DefaultMutableTreeNode)path
			.getLastPathComponent()).getUserObject();

		if(value instanceof String)
		{
			Buffer buffer = jEdit.openFile(view,(String)value);
			if(buffer == null)
				return;

			view.setBuffer(buffer);

			
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					resultTree.requestFocus();
				}
			});
		}
		else
		{
			final HyperSearchResult result = (HyperSearchResult)value;
			final Buffer buffer = result.getBuffer();

			if(buffer == null)
				return;

			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					int start = result.startPos.getOffset();
					int end = result.endPos.getOffset();
					Selection s = new Selection.Range(start,end);
					view.setBuffer(buffer);
					JEditTextArea textArea = view.getTextArea();
					if(textArea.isMultipleSelectionEnabled())
						textArea.addToSelection(s);
					else
						textArea.setSelection(s);

					textArea.moveCaretPosition(end);
				}
			});
		}
	} 

	
	private void updateCaption(int resultCount, int bufferCount)
	{
		Object[] pp = { new Integer(resultCount), new Integer(bufferCount) };
		caption.setText(jEdit.getProperty(""hypersearch-results.caption"",pp));
	} 

	

	
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
				goToSelectedNode();
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			TreePath path1 = resultTree.getPathForLocation(
				evt.getX(),evt.getY());
			if(path1 == null)
				return;

			resultTree.setSelectionPath(path1);
			goToSelectedNode();

			view.toFront();
			view.requestFocus();
			view.getTextArea().requestFocus();
		}
	} 

	
	class TreeSelectionHandler implements TreeSelectionListener
	{
		public void valueChanged(TreeSelectionEvent evt)
		{
			goToSelectedNode();
		}
	} 

	
	class ResultCellRenderer extends DefaultTreeCellRenderer
	{
		Font plainFont, boldFont;

		
		ResultCellRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			boldFont = new Font(plainFont.getName(),Font.BOLD,
				plainFont.getSize());
		} 

		
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			Component comp = super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,hasFocus);
			setIcon(null);
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;
			if(node.getUserObject() instanceof String)
			{
				
				ResultCellRenderer.this.setFont(boldFont);
				int count = node.getChildCount();
				if(count == 1)
				{
					setText(jEdit.getProperty(""hypersearch-results""
						+ "".file-caption1"",new Object[] {
						node.getUserObject()
						}));
				}
				else
				{
					setText(jEdit.getProperty(""hypersearch-results""
						+ "".file-caption"",new Object[] {
						node.getUserObject(),
						new Integer(count)
						}));
				}
			}
			else
			{
				ResultCellRenderer.this.setFont(plainFont);
			}

			return this;
		} 
	} 
}
"
