name,version,name.1,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
jEdit,4.1,org.gjt.sp.jedit.syntax.SoftWrapTokenHandler,4,3,0,8,12,0,2,6,4,0.625,182,1.0,1,0.833333333,0.325,1,4,42.5,12,3.5,0,"

package org.gjt.sp.jedit.syntax;


import javax.swing.text.*;
import java.awt.font.*;
import java.util.List;
import org.gjt.sp.jedit.syntax.*;



public class SoftWrapTokenHandler extends DisplayTokenHandler
{
	
	public void init(Segment seg, SyntaxStyle[] styles,
		FontRenderContext fontRenderContext,
		TabExpander expander, List out,
		float wrapMargin)
	{
		super.init(seg,styles,fontRenderContext,expander);

		
		this.wrapMargin = wrapMargin += 2.0f;

		this.out = out;
		initialSize = out.size();

		seenNonWhitespace = addedNonWhitespace = false;
		endX = endOfWhitespace = 0.0f;
		end = null;
	} 

	
	
	public List getChunkList()
	{
		return out;
	} 

	
	
	public void handleToken(byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		Token token = createToken(id,offset,length,context);
		if(token != null)
		{
			addToken(token,context);

			if(id == Token.WHITESPACE
				|| id == Token.TAB)
			{
				if(!seenNonWhitespace)
				{
					endOfWhitespace = x;
				}
			}
			else
				seenNonWhitespace = true;

			if(out.size() == initialSize)
				out.add(firstToken);
			else if(id == Token.WHITESPACE
				|| id == Token.TAB)
			{
				if(out.size() != initialSize)
				{
					end = lastToken;
					endX = x;
				}
			}
			else if(x > wrapMargin && end != null
				&& addedNonWhitespace)
			{
				Chunk blankSpace = new Chunk(endOfWhitespace,
					end.offset + end.length,
					getParserRuleSet(context));

				blankSpace.next = end.next;
				end.next = null;

				x = x - endX + endOfWhitespace;

				out.add(blankSpace);

				end = null;
				endX = x;
			}

			addedNonWhitespace = seenNonWhitespace;
		}
	} 

	
	private List out;
	private float wrapMargin;
	private float endX;
	private Token end;

	private boolean seenNonWhitespace;
	private boolean addedNonWhitespace;
	private float endOfWhitespace;

	private int initialSize;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.GrabKeyDialog,23,6,0,8,74,217,4,7,6,0.842975207,521,0.909090909,3,0.96875,0.166007905,3,4,21.17391304,8,1.9565,4,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.lang.reflect.Field;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class GrabKeyDialog extends JDialog
{
	
	
	public GrabKeyDialog(Dialog parent, KeyBinding binding,
		Vector allBindings, Buffer debugBuffer)
	{
		super(parent,jEdit.getProperty(""grab-key.title""),true);

		init(binding,allBindings,debugBuffer);
	} 

	
	
	public GrabKeyDialog(Frame parent, KeyBinding binding,
		Vector allBindings, Buffer debugBuffer)
	{
		super(parent,jEdit.getProperty(""grab-key.title""),true);

		init(binding,allBindings,debugBuffer);
	} 

	
	
	public String getShortcut()
	{
		if(isOK)
			return shortcut.getText();
		else
			return null;
	} 

	
	
	public boolean isOK()
	{
		return isOK;
	} 

	
	
	public boolean isManagingFocus()
	{
		return false;
	} 

	
	
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} 

	
	protected void processKeyEvent(KeyEvent evt)
	{
		shortcut.processKeyEvent(evt);
	} 

	

	
	private InputPane shortcut; 
	private JLabel assignedTo;
	private JButton ok;
	private JButton remove;
	private JButton cancel;
	private JButton clear;
	private boolean isOK;
	private KeyBinding binding;
	private Vector allBindings;
	private Buffer debugBuffer;
	

	
	private void init(KeyBinding binding, Vector allBindings, Buffer debugBuffer)
	{
		this.binding = binding;
		this.allBindings = allBindings;
		this.debugBuffer = debugBuffer;

		enableEvents(AWTEvent.KEY_EVENT_MASK);

		
		
		JPanel content = new JPanel(new GridLayout(0,1,0,6))
		{
			
			public boolean isManagingFocus()
			{
				return false;
			}

			
			public boolean getFocusTraversalKeysEnabled()
			{
				return false;
			}
		};
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel label = new JLabel(
			debugBuffer == null ? jEdit.getProperty(
			""grab-key.caption"",new String[] { binding.label })
			: jEdit.getProperty(""grab-key.keyboard-test""));

		Box input = Box.createHorizontalBox();

		shortcut = new InputPane();
		input.add(shortcut);
		input.add(Box.createHorizontalStrut(12));

		clear = new JButton(jEdit.getProperty(""grab-key.clear""));
		clear.addActionListener(new ActionHandler());
		input.add(clear);

		assignedTo = new JLabel();
		if(debugBuffer == null)
			updateAssignedTo(null);

		Box buttons = Box.createHorizontalBox();
		buttons.add(Box.createGlue());

		if(debugBuffer == null)
		{
			ok = new JButton(jEdit.getProperty(""common.ok""));
			ok.addActionListener(new ActionHandler());
			buttons.add(ok);
			buttons.add(Box.createHorizontalStrut(12));

			if(binding.isAssigned()) {
				
				remove = new JButton(jEdit.getProperty(""grab-key.remove""));
				remove.addActionListener(new ActionHandler());
				buttons.add(remove);
				buttons.add(Box.createHorizontalStrut(12));
			}
		}

		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);
		buttons.add(Box.createGlue());

		content.add(label);
		content.add(input);
		if(debugBuffer == null)
			content.add(assignedTo);
		content.add(buttons);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		pack();
		setLocationRelativeTo(getParent());
		setResizable(false);
		show();
	} 

	
	private String getSymbolicName(int keyCode)
	{
		if(keyCode == KeyEvent.VK_UNDEFINED)
			return null;
		

		if(keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)
			return String.valueOf(Character.toLowerCase((char)keyCode));

		try
		{
			Field[] fields = KeyEvent.class.getFields();
			for(int i = 0; i < fields.length; i++)
			{
				Field field = fields[i];
				String name = field.getName();
				if(name.startsWith(""VK_"")
					&& field.getInt(null) == keyCode)
				{
					return name.substring(3);
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}

		return null;
	} 

	
	private void updateAssignedTo(String shortcut)
	{
		String text = jEdit.getProperty(""grab-key.assigned-to.none"");
		KeyBinding kb = getKeyBinding(shortcut);

		if(kb != null)
			if(kb.isPrefix)
				text = jEdit.getProperty(
					""grab-key.assigned-to.prefix"",
					new String[] { shortcut });
			else
				text = kb.label;

		if(ok != null)
			ok.setEnabled(kb == null || !kb.isPrefix);

		assignedTo.setText(
			jEdit.getProperty(""grab-key.assigned-to"",
				new String[] { text }));
	} 

	
	private KeyBinding getKeyBinding(String shortcut)
	{
		if(shortcut == null || shortcut.length() == 0)
			return null;

		String spacedShortcut = shortcut + "" "";
		Enumeration enum = allBindings.elements();

		while(enum.hasMoreElements())
		{
			KeyBinding kb = (KeyBinding)enum.nextElement();

			if(!kb.isAssigned())
				continue;

			String spacedKbShortcut = kb.shortcut + "" "";

			
			if(spacedShortcut.startsWith(spacedKbShortcut))
				return kb;

			
			if(spacedKbShortcut.startsWith(spacedShortcut))
			{
				
				
				return new KeyBinding(kb.name,kb.label,
					shortcut,true);
			}
		}

		return null;
	} 

	

	
	
	public static class KeyBinding
	{
		public KeyBinding(String name, String label,
			String shortcut, boolean isPrefix)
		{
			this.name = name;
			this.label = label;
			this.shortcut = shortcut;
			this.isPrefix = isPrefix;
		}

		public String name;
		public String label;
		public String shortcut;
		public boolean isPrefix;

		public boolean isAssigned()
		{
			return shortcut != null && shortcut.length() > 0;
		}
	} 

	
	class InputPane extends JTextField
	{
		
		
		public boolean getFocusTraversalKeysEnabled()
		{
			return false;
		} 

		
		protected void processKeyEvent(KeyEvent _evt)
		{
			KeyEvent evt = KeyEventWorkaround.processKeyEvent(_evt);
			if(evt == null)
			{
				if(debugBuffer != null)
				{
					debugBuffer.insert(debugBuffer.getLength(),
						""Event "" + _evt + "" filtered\n"");
				}
				return;
			}
			else
			{
				if(debugBuffer != null)
				{
					debugBuffer.insert(debugBuffer.getLength(),
						""Event "" + _evt + "" passed\n"");
				}
			}

			evt.consume();

			StringBuffer keyString = new StringBuffer(getText());

			if(getDocument().getLength() != 0)
				keyString.append(' ');

			if(evt.getID() == KeyEvent.KEY_TYPED)
			{
				if(!Character.isLetterOrDigit(evt.getKeyChar())
					&& !Character.isUpperCase(evt.getKeyChar()))
					return;

				keyString.append(evt.getKeyChar());
			}
			else if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				String modifiers = DefaultInputHandler
					.getModifierString(evt);
				if(modifiers.length() != 0)
				{
					keyString.append(modifiers);
					keyString.append('+');
				}

				int keyCode = evt.getKeyCode();

				if(((keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)
					|| (keyCode >= KeyEvent.VK_0 && keyCode <= KeyEvent.VK_9))
					&& modifiers.length() == 0)
				{
					
					return;
				}

				String symbolicName = getSymbolicName(keyCode);

				if(symbolicName == null)
					return;

				keyString.append(symbolicName);
			}
			else if(evt.getID() == KeyEvent.KEY_RELEASED)
				return;

			setText(keyString.toString());
			if(debugBuffer == null)
				updateAssignedTo(keyString.toString());
		} 
	} 

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(canClose())
					dispose();
			}
			else if(evt.getSource() == remove)
			{
				shortcut.setText(null);
				isOK = true;
				dispose();
			}
			else if(evt.getSource() == cancel)
				dispose();
			else if(evt.getSource() == clear)
			{
				shortcut.setText(null);
				if(debugBuffer == null)
					updateAssignedTo(null);
				shortcut.requestFocus();
			}
		} 

		
		private boolean canClose()
		{
			String shortcutString = shortcut.getText();
			if(shortcutString.length() == 0
				&& binding.isAssigned())
			{
				
				int answer = GUIUtilities.confirm(
					GrabKeyDialog.this,
					""grab-key.remove-ask"",
					null,
					JOptionPane.YES_NO_CANCEL_OPTION,
					JOptionPane.QUESTION_MESSAGE);
				if(answer == JOptionPane.YES_OPTION)
				{
					shortcut.setText(null);
					isOK = true;
				}
				else if(answer == JOptionPane.CANCEL_OPTION)
					return false;
				return true;
			}

			
			KeyBinding other = getKeyBinding(shortcutString);
			if(other == null || other == binding)
			{
				isOK = true;
				return true;
			}

			
			if(other.name == binding.name)
			{
				
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.duplicate-alt-shortcut"",
					null);
				return false;
			}

			
			if(other.isPrefix)
			{
				
				GUIUtilities.error(GrabKeyDialog.this,
					""grab-key.prefix-shortcut"",
					null);
				return false;
			}

			
			int answer = GUIUtilities.confirm(GrabKeyDialog.this,
				""grab-key.duplicate-shortcut"",
				new Object[] { other.label },
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(answer == JOptionPane.YES_OPTION)
			{
				if(other.shortcut != null
					&& shortcutString.startsWith(other.shortcut))
				{
					other.shortcut = null;
				}
				isOK = true;
				return true;
			}
			else if(answer == JOptionPane.CANCEL_OPTION)
				return false;

			return true;
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.GUIUtilities,47,1,0,101,173,1049,88,23,41,0.949275362,2031,0.222222222,1,0.0,0.118012422,0,0,42.0212766,16,3.7021,3,"

package org.gjt.sp.jedit;


import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.syntax.Token;
import org.gjt.sp.util.Log;



public class GUIUtilities
{
	
	public static final Icon NEW_BUFFER_ICON = loadIcon(""new.gif"");
	public static final Icon DIRTY_BUFFER_ICON = loadIcon(""dirty.gif"");
	public static final Icon READ_ONLY_BUFFER_ICON = loadIcon(""readonly.gif"");
	public static final Icon NORMAL_BUFFER_ICON = loadIcon(""normal.gif"");
	public static final Icon WINDOW_ICON = loadIcon(""jedit-icon.gif"");
	

	

	
	
	public static Icon loadIcon(String iconName)
	{
		if(icons == null)
			icons = new Hashtable();

		
		Icon icon = (Icon)icons.get(iconName);
		if(icon != null)
			return icon;

		
		if(iconName.startsWith(""file:""))
		{
			icon = new ImageIcon(iconName.substring(5));
		}
		else
		{
			URL url = GUIUtilities.class.getResource(
				""/org/gjt/sp/jedit/icons/"" + iconName);
			if(url == null)
			{
				Log.log(Log.ERROR,GUIUtilities.class,
					""Icon not found: "" + iconName);
				return null;
			}

			icon = new ImageIcon(url);
		}

		icons.put(iconName,icon);
		return icon;
	} 

	
	
	public static Image getEditorIcon()
	{
		return ((ImageIcon)WINDOW_ICON).getImage();
	} 

	
	
	public static Image getPluginIcon()
	{
		return ((ImageIcon)WINDOW_ICON).getImage();
	} 

	

	

	
	
	public static JMenuBar loadMenuBar(String name)
	{
		String menus = jEdit.getProperty(name);
		StringTokenizer st = new StringTokenizer(menus);

		JMenuBar mbar = new JMenuBar();

		while(st.hasMoreTokens())
		{
			String menu = st.nextToken();
			if(menu.equals(""plugins""))
				loadPluginsMenu(mbar);
			else
				mbar.add(loadMenu(menu));
		}

		return mbar;
	} 

	
	
	public static JMenu loadMenu(View view, String name)
	{
		return loadMenu(name);
	} 

	
	
	public static JMenu loadMenu(String name)
	{
		if(name.equals(""recent-files""))
			return new RecentFilesMenu();
		else if(name.equals(""recent-directories""))
			return new RecentDirectoriesMenu();
		else if(name.equals(""current-directory""))
			return new DirectoryMenu(""current-directory"",null);
		else if(name.equals(""markers""))
			return new MarkersMenu();
		else if(name.equals(""jedit-directory""))
			return new DirectoryMenu(""jedit-directory"",jEdit.getJEditHome());
		else if(name.equals(""settings-directory""))
		{
			String settings = jEdit.getSettingsDirectory();
			if(settings == null)
				settings = jEdit.getJEditHome();
			return new DirectoryMenu(""settings-directory"",settings);
		}
		else if(name.equals(""macros""))
			return new MacrosMenu();
		else
			return new EnhancedMenu(name);
	} 

	
	
	public static JPopupMenu loadPopupMenu(String name)
	{
		JPopupMenu menu = new JPopupMenu();

		String menuItems = jEdit.getProperty(name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					menu.addSeparator();
				else
				{
					if(menuItemName.startsWith(""%""))
						menu.add(loadMenu(menuItemName.substring(1)));
					else
						menu.add(loadMenuItem(menuItemName,false));
				}
			}
		}

		return menu;
	} 

	
	
	public static JMenuItem loadMenuItem(String name)
	{
		return loadMenuItem(name,true);
	} 

	
	
	public static JMenuItem loadMenuItem(String name, boolean setMnemonic)
	{
		EditAction action = jEdit.getAction(name);
		String label = (action == null ?
			jEdit.getProperty(name + "".label"")
			: action.getLabel());
		if(label == null)
			label = name;

		char mnemonic;
		int index = label.indexOf('$');
		if(index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0,index).concat(label.substring(++index));
		}
		else
			mnemonic = '\0';

		JMenuItem mi;
		if(action != null && action.isToggle())
			mi = new EnhancedCheckBoxMenuItem(label,action);
		else
			mi = new EnhancedMenuItem(label,action);

		if(!OperatingSystem.isMacOS() && setMnemonic && mnemonic != '\0')
			mi.setMnemonic(mnemonic);

		return mi;
	} 

	
	
	public static JToolBar loadToolBar(String name)
	{
		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);

		String buttons = jEdit.getProperty(name);
		if(buttons != null)
		{
			StringTokenizer st = new StringTokenizer(buttons);
			while(st.hasMoreTokens())
			{
				String button = st.nextToken();
				if(button.equals(""-""))
					toolBar.addSeparator();
				else
				{
					JButton b = loadToolButton(button);
					if(b != null)
						toolBar.add(b);
				}
			}
		}

		return toolBar;
	} 

	
	
	public static EnhancedButton loadToolButton(String name)
	{
		EditAction action = jEdit.getAction(name);
		String label = (action == null
			? jEdit.getProperty(name + "".label"")
			: action.getLabel());

		if(label == null)
			label = name;

		Icon icon;
		String iconName = jEdit.getProperty(name + "".icon"");
		if(iconName == null)
			icon = loadIcon(""BrokenImage.png"");
		else
		{
			icon = loadIcon(iconName);
			if(icon == null)
				icon = loadIcon(""BrokenImage.png"");
		}

		String toolTip = prettifyMenuLabel(label);
		String shortcut1 = jEdit.getProperty(name + "".shortcut"");
		String shortcut2 = jEdit.getProperty(name + "".shortcut2"");
		if(shortcut1 != null || shortcut2 != null)
		{
			toolTip = toolTip + "" (""
				+ (shortcut1 != null
				? shortcut1 : """")
				+ ((shortcut1 != null && shortcut2 != null)
				? "" or "" : """")
				+ (shortcut2 != null
				? shortcut2
				: """") + "")"";
		}

		return new EnhancedButton(icon,toolTip,action);
	} 

	
	
	public static String prettifyMenuLabel(String label)
	{
		int index = label.indexOf('$');
		if(index != -1)
		{
			label = label.substring(0,index)
				.concat(label.substring(index + 1));
		}
		return label;
	} 

	

	

	
	
	public static void message(Component comp, String name, Object[] args)
	{
		hideSplashScreen();

		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.INFORMATION_MESSAGE);
	} 

	
	
	public static void error(Component comp, String name, Object[] args)
	{
		hideSplashScreen();

		JOptionPane.showMessageDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title""),args),
			JOptionPane.ERROR_MESSAGE);
	} 

	
	
	public static String input(Component comp, String name, Object def)
	{
		return input(comp,name,null,def);
	} 

	
	
	public static String inputProperty(Component comp, String name,
		String def)
	{
		return inputProperty(comp,name,null,def);
	} 

	
	
	public static String input(Component comp, String name,
		Object[] args, Object def)
	{
		hideSplashScreen();

		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,null,null,def);
		return retVal;
	} 

	
	
	public static String inputProperty(Component comp, String name,
		Object[] args, String def)
	{
		hideSplashScreen();

		String retVal = (String)JOptionPane.showInputDialog(comp,
			jEdit.getProperty(name.concat("".message""),args),
			jEdit.getProperty(name.concat("".title"")),
			JOptionPane.QUESTION_MESSAGE,
			null,null,jEdit.getProperty(def));
		if(retVal != null)
			jEdit.setProperty(def,retVal);
		return retVal;
	} 

	
	
	public static int confirm(Component comp, String name,
		Object[] args, int buttons, int type)
	{
		hideSplashScreen();

		return JOptionPane.showConfirmDialog(comp,
			jEdit.getProperty(name + "".message"",args),
			jEdit.getProperty(name + "".title""),buttons,type);
	} 

	
	
	public static String[] showVFSFileDialog(View view, String path,
		int type, boolean multipleSelection)
	{
		hideSplashScreen();

		VFSFileChooserDialog fileChooser = new VFSFileChooserDialog(
			view,path,type,multipleSelection);
		String[] selectedFiles = fileChooser.getSelectedFiles();
		if(selectedFiles == null)
			return null;

		return selectedFiles;
	} 

	

	

	
	
	public static Color parseColor(String name)
	{
		return parseColor(name, Color.black);
	} 

	
	public static Color parseColor(String name, Color defaultColor)
	{
		if(name == null)
			return defaultColor;
		else if(name.startsWith(""#""))
		{
			try
			{
				return Color.decode(name);
			}
			catch(NumberFormatException nf)
			{
				return defaultColor;
			}
		}
		else if(""red"".equals(name))
			return Color.red;
		else if(""green"".equals(name))
			return Color.green;
		else if(""blue"".equals(name))
			return Color.blue;
		else if(""yellow"".equals(name))
			return Color.yellow;
		else if(""orange"".equals(name))
			return Color.orange;
		else if(""white"".equals(name))
			return Color.white;
		else if(""lightGray"".equals(name))
			return Color.lightGray;
		else if(""gray"".equals(name))
			return Color.gray;
		else if(""darkGray"".equals(name))
			return Color.darkGray;
		else if(""black"".equals(name))
			return Color.black;
		else if(""cyan"".equals(name))
			return Color.cyan;
		else if(""magenta"".equals(name))
			return Color.magenta;
		else if(""pink"".equals(name))
			return Color.pink;
		else
			return defaultColor;
	} 

	
	
	public static String getColorHexString(Color c)
	{
		String colString = Integer.toHexString(c.getRGB() & 0xffffff);
		return ""#000000"".substring(0,7 - colString.length()).concat(colString);
	} 

	
	
	public static SyntaxStyle parseStyle(String str, String family, int size)
		throws IllegalArgumentException
	{
		return parseStyle(str,family,size,true);
	} 

	
	
	public static SyntaxStyle parseStyle(String str, String family, int size,
		boolean color)
		throws IllegalArgumentException
	{
		Color fgColor = Color.black;
		Color bgColor = null;
		boolean italic = false;
		boolean bold = false;
		StringTokenizer st = new StringTokenizer(str);
		while(st.hasMoreTokens())
		{
			String s = st.nextToken();
			if(s.startsWith(""color:""))
			{
				if(color)
					fgColor = GUIUtilities.parseColor(s.substring(6), Color.black);
			}
			else if(s.startsWith(""bgColor:""))
			{
				if(color)
					bgColor = GUIUtilities.parseColor(s.substring(8), null);
			}
			else if(s.startsWith(""style:""))
			{
				for(int i = 6; i < s.length(); i++)
				{
					if(s.charAt(i) == 'i')
						italic = true;
					else if(s.charAt(i) == 'b')
						bold = true;
					else
						throw new IllegalArgumentException(
							""Invalid style: "" + s);
				}
			}
			else
				throw new IllegalArgumentException(
					""Invalid directive: "" + s);
		}
		return new SyntaxStyle(fgColor,bgColor,
			new Font(family,
			(italic ? Font.ITALIC : 0) | (bold ? Font.BOLD : 0),
			size));
	} 

	
	
	public static String getStyleString(SyntaxStyle style)
	{
		StringBuffer buf = new StringBuffer();

		if(style.getForegroundColor() != null)
		{
			buf.append(""color:"" + getColorHexString(style.getForegroundColor()));
		}

		if(style.getBackgroundColor() != null) 
		{
			buf.append("" bgColor:"" + getColorHexString(style.getBackgroundColor()));
		}
		if(!style.getFont().isPlain())
		{
			buf.append("" style:"" + (style.getFont().isItalic() ? ""i"" : """")
				+ (style.getFont().isBold() ? ""b"" : """"));
		}

		return buf.toString();
	} 

	
	
	public static SyntaxStyle[] loadStyles(String family, int size)
	{
		return loadStyles(family,size,true);
	} 

	
	
	public static SyntaxStyle[] loadStyles(String family, int size, boolean color)
	{
		SyntaxStyle[] styles = new SyntaxStyle[Token.ID_COUNT];

		try
		{
			styles[Token.COMMENT1] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.comment1""),
				family,size,color);
			styles[Token.COMMENT2] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.comment2""),
				family, size,color);
			styles[Token.LITERAL1] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.literal1""),
				family,size,color);
			styles[Token.LITERAL2] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.literal2""),
				family,size,color);
			styles[Token.LABEL] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.label""),
				family,size,color);
			styles[Token.KEYWORD1] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.keyword1""),
				family,size,color);
			styles[Token.KEYWORD2] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.keyword2""),
				family,size,color);
			styles[Token.KEYWORD3] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.keyword3""),
				family,size,color);
			styles[Token.FUNCTION] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.function""),
				family,size,color);
			styles[Token.MARKUP] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.markup""),
				family,size,color);
			styles[Token.OPERATOR] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.operator""),
				family,size,color);
			styles[Token.DIGIT] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.digit""),
				family,size,color);
			styles[Token.INVALID] = GUIUtilities.parseStyle(
				jEdit.getProperty(""view.style.invalid""),
				family,size,color);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,GUIUtilities.class,e);
		}

		return styles;
	} 

	

	

	
	
	public static void loadGeometry(Window win, String name)
	{
		int x, y, width, height;

		Dimension size = win.getSize();
		Dimension screen = win.getToolkit().getScreenSize();

		width = jEdit.getIntegerProperty(name + "".width"",size.width);
		height = jEdit.getIntegerProperty(name + "".height"",size.height);

		Component parent = win.getParent();
		if(parent == null)
		{
			x = (screen.width - width) / 2;
			y = (screen.height - height) / 2;
		}
		else
		{
			Rectangle bounds = parent.getBounds();
			x = bounds.x + (bounds.width - width) / 2;
			y = bounds.y + (bounds.height - height) / 2;
		}

		x = jEdit.getIntegerProperty(name + "".x"",x);
		y = jEdit.getIntegerProperty(name + "".y"",y);

		
		Rectangle osbounds = OperatingSystem.getScreenBounds();
		
		if(x < osbounds.x || x+width > osbounds.width)
		{
			if (width > osbounds.width)
				width = osbounds.width;
			x = (osbounds.width - width) / 2;
		}
		if(y < osbounds.y || y+height > osbounds.height)
		{
			if (height >= osbounds.height)
				height = osbounds.height;
			y = (osbounds.height - height) / 2;
		}

		Rectangle desired = new Rectangle(x,y,width,height);
		win.setBounds(desired);

		if((win instanceof Frame) && OperatingSystem.hasJava14())
		{
			int extState = jEdit.getIntegerProperty(name +
				"".extendedState"", Frame.NORMAL);

			try
			{
				java.lang.reflect.Method meth =
					Frame.class.getMethod(""setExtendedState"",
					new Class[] {int.class});

				meth.invoke(win, new Object[] {
					new Integer(extState)});
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,GUIUtilities.class,e);
			}
		}
	} 

	
	
	public static void saveGeometry(Window win, String name)
	{
		if((win instanceof Frame) && OperatingSystem.hasJava14())
		{
			try
			{
				java.lang.reflect.Method meth =
					Frame.class.getMethod(""getExtendedState"",
					new Class[0]);

				Integer extState = (Integer)meth.invoke(win,
					new Object[0]);

				jEdit.setIntegerProperty(name + "".extendedState"",
					extState.intValue());

				if(extState.intValue() != Frame.NORMAL)
					return;
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,GUIUtilities.class,e);
			}
		}

		Rectangle bounds = win.getBounds();
		jEdit.setIntegerProperty(name + "".x"",bounds.x);
		jEdit.setIntegerProperty(name + "".y"",bounds.y);
		jEdit.setIntegerProperty(name + "".width"",bounds.width);
		jEdit.setIntegerProperty(name + "".height"",bounds.height);
	} 

	

	
	
	public static void hideSplashScreen()
	{
		if(splash != null)
		{
			splash.dispose();
			splash = null;
		}
	} 

	
	
	public static JComponent createMultilineLabel(String str)
	{
		JPanel panel = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,1,1,1));
		int lastOffset = 0;
		for(;;)
		{
			int index = str.indexOf('\n',lastOffset);
			if(index == -1)
				break;
			else
			{
				panel.add(new JLabel(str.substring(lastOffset,index)));
				lastOffset = index + 1;
			}
		}

		if(lastOffset != str.length())
			panel.add(new JLabel(str.substring(lastOffset)));

		return panel;
	} 

	
	
	public static void requestFocus(final Window win, final Component comp)
	{
		win.addWindowListener(new WindowAdapter()
		{
			public void windowActivated(WindowEvent evt)
			{
				comp.requestFocus();
				win.removeWindowListener(this);
			}
		});
	} 

	
	
	public static boolean isPopupTrigger(MouseEvent evt)
	{
		return isRightButton(evt.getModifiers());
	} 

	
	
	public static boolean isMiddleButton(int modifiers)
	{
		if (OperatingSystem.isMacOS())
		{
			if((modifiers & MouseEvent.BUTTON1_MASK) != 0)
				return ((modifiers & MouseEvent.META_MASK) != 0);
			if(!OperatingSystem.hasJava14())
				return ((modifiers & MouseEvent.BUTTON3_MASK) != 0);
			else
				return ((modifiers & MouseEvent.BUTTON2_MASK) != 0);
		}
		else
			return ((modifiers & MouseEvent.BUTTON2_MASK) != 0);
	} 

	
	
	public static boolean isRightButton(int modifiers)
	{
		if (OperatingSystem.isMacOS())
		{
			if((modifiers & MouseEvent.BUTTON1_MASK) != 0)
				return ((modifiers & MouseEvent.CTRL_MASK) != 0);
			if(!OperatingSystem.hasJava14())
				return ((modifiers & MouseEvent.BUTTON2_MASK) != 0);
			else
				return ((modifiers & MouseEvent.BUTTON3_MASK) != 0);
		}
		else
			return ((modifiers & MouseEvent.BUTTON3_MASK) != 0);
	} 

	
	
	public static void showPopupMenu(JPopupMenu popup, Component comp,
		int x, int y)
	{
		showPopupMenu(popup,comp,x,y,true);
	} 

	
	
	public static void showPopupMenu(JPopupMenu popup, Component comp,
		int x, int y, boolean point)
	{
		int offsetX = 0;
		int offsetY = 0;

		int extraOffset = (point ? 1 : 0);

		Component win = comp;
		while(!(win instanceof Window || win == null))
		{
			offsetX += win.getX();
			offsetY += win.getY();
			win = win.getParent();
		}

		if(win != null)
		{
			Dimension size = popup.getPreferredSize();

			Rectangle screenSize = win.getGraphicsConfiguration()
				.getBounds();

			if(x + offsetX + size.width + win.getX() > screenSize.width
				&& x + offsetX + win.getX() >= size.width)
			{
				
				if(point)
					x -= (size.width + extraOffset);
				else
					x = (win.getWidth() - size.width - offsetX + extraOffset);
			}
			else
			{
				x += extraOffset;
			}

			
			
			
			if(y + offsetY + size.height + win.getY() > screenSize.height
				&& y + offsetY + win.getY() >= size.height)
			{
				
				if(point)
					y = (win.getHeight() - size.height - offsetY + extraOffset);
				else
					y = comp.getY() - size.height - 1;
			}
			else
			{
				y += extraOffset;
			}

			popup.show(comp,x,y);
		}
		else
			popup.show(comp,x + extraOffset,y + extraOffset);

	} 

	
	
	public static boolean isAncestorOf(Component comp1, Component comp2)
	{
		while(comp2 != null)
		{
			if(comp1 == comp2)
				return true;
			else
				comp2 = comp2.getParent();
		}

		return false;
	} 

	
	
	public static JDialog getParentDialog(Component c)
	{
		Component p = c.getParent();
		while (p != null && !(p instanceof JDialog))
			p = p.getParent();

		return (p instanceof JDialog) ? (JDialog) p : null;
	} 

	
	
	public static View getView(Component comp)
	{
		for(;;)
		{
			if(comp instanceof JComponent)
			{
				Component real = (Component)((JComponent)comp)
					.getClientProperty(""KORTE_REAL_FRAME"");
				if(real != null)
					comp = real;
			}

			if(comp instanceof View)
				return (View)comp;
			else if(comp instanceof JPopupMenu)
				comp = ((JPopupMenu)comp).getInvoker();
			else if(comp != null)
				comp = comp.getParent();
			else
				break;
		}
		return null;
	} 

	

	
	static void showSplashScreen()
	{
		splash = new SplashScreen();
	} 

	
	static void advanceSplashProgress()
	{
		if(splash != null)
			splash.advance();
	} 

	

	
	private static SplashScreen splash;
	private static Hashtable icons;

	private GUIUtilities() {}

	
	private static void loadPluginsMenu(JMenuBar mbar)
	{
		
		Vector pluginMenuItems = new Vector();

		EditPlugin[] pluginArray = jEdit.getPlugins();
		for(int i = 0; i < pluginArray.length; i++)
		{
			try
			{
				EditPlugin plugin = pluginArray[i];
				plugin.createMenuItems(pluginMenuItems);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,GUIUtilities.class,
					""Error creating menu items""
					+ "" for plugin"");
				Log.log(Log.ERROR,GUIUtilities.class,t);
			}
		}

		JMenu menu = new EnhancedMenu(""plugins"");
		((EnhancedMenu)menu).init();

		if(pluginMenuItems.isEmpty())
		{
			menu.add(GUIUtilities.loadMenuItem(""no-plugins""));
			mbar.add(menu);
			return;
		}

		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);

		
		MiscUtilities.quicksort(pluginMenuItems,
			new MiscUtilities.MenuItemCompare());

		if(pluginMenuItems.size() < maxItems)
		{
			for(int i = 0; i < pluginMenuItems.size(); i++)
			{
				menu.add((JMenuItem)pluginMenuItems.get(i));
			}
			mbar.add(menu);
		}
		else
		{
			int menuCount = 1;

			menu.setText(menu.getText() + "" "" + menuCount);

			for(int i = 0; i < pluginMenuItems.size(); i++)
			{
				menu.add((JMenuItem)pluginMenuItems.get(i));
				if(menu.getMenuComponentCount() == maxItems)
				{
					mbar.add(menu);
					menu = new JMenu(String.valueOf(
						++menuCount));
				}
			}

			if(menu.getMenuComponentCount() != 0)
				mbar.add(menu);
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.EBComponent,1,1,0,32,1,0,32,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit;


public interface EBComponent
{
	
	void handleMessage(EBMessage message);
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.KeyEventWorkaround,4,1,0,6,16,0,5,1,3,1.095238095,218,1.0,0,0.0,0.333333333,0,0,51.75,62,20.5,4,"

package org.gjt.sp.jedit.gui;


import java.awt.event.*;
import org.gjt.sp.jedit.OperatingSystem;



public class KeyEventWorkaround
{
	
	public static KeyEvent processKeyEvent(KeyEvent evt)
	{
		int keyCode = evt.getKeyCode();
		char ch = evt.getKeyChar();

		switch(evt.getID())
		{
		
		case KeyEvent.KEY_PRESSED:
			
			switch(keyCode)
			{
			case KeyEvent.VK_ALT:
			case KeyEvent.VK_ALT_GRAPH:
			case KeyEvent.VK_CONTROL:
			case KeyEvent.VK_SHIFT:
			case KeyEvent.VK_META:
			case KeyEvent.VK_DEAD_GRAVE:
			case KeyEvent.VK_DEAD_ACUTE:
			case KeyEvent.VK_DEAD_CIRCUMFLEX:
			case KeyEvent.VK_DEAD_TILDE:
			case KeyEvent.VK_DEAD_MACRON:
			case KeyEvent.VK_DEAD_BREVE:
			case KeyEvent.VK_DEAD_ABOVEDOT:
			case KeyEvent.VK_DEAD_DIAERESIS:
			case KeyEvent.VK_DEAD_ABOVERING:
			case KeyEvent.VK_DEAD_DOUBLEACUTE:
			case KeyEvent.VK_DEAD_CARON:
			case KeyEvent.VK_DEAD_CEDILLA:
			case KeyEvent.VK_DEAD_OGONEK:
			case KeyEvent.VK_DEAD_IOTA:
			case KeyEvent.VK_DEAD_VOICED_SOUND:
			case KeyEvent.VK_DEAD_SEMIVOICED_SOUND:
			case '\0':
				return null;
			default:
				switch(keyCode)
				{
					case KeyEvent.VK_NUMPAD0:   case KeyEvent.VK_NUMPAD1:
					case KeyEvent.VK_NUMPAD2:   case KeyEvent.VK_NUMPAD3:
					case KeyEvent.VK_NUMPAD4:   case KeyEvent.VK_NUMPAD5:
					case KeyEvent.VK_NUMPAD6:   case KeyEvent.VK_NUMPAD7:
					case KeyEvent.VK_NUMPAD8:   case KeyEvent.VK_NUMPAD9:
					case KeyEvent.VK_MULTIPLY:  case KeyEvent.VK_ADD:
					 case KeyEvent.VK_SUBTRACT:
					case KeyEvent.VK_DECIMAL:   case KeyEvent.VK_DIVIDE:
						last = LAST_NUMKEYPAD;
						lastKeyTime = System.currentTimeMillis();
						return evt;
				}

				if(!OperatingSystem.isMacOS())
					handleBrokenKeys(evt,keyCode);
				else
					last = LAST_NOTHING;
				break;
			}

			return evt;
		
		
		case KeyEvent.KEY_TYPED:
			
			
			if((ch < 0x20 || ch == 0x7f || ch == 0xff) && ch != '\b')
				return null;

			
			
			if(OperatingSystem.isMacOS())
			{
				if(evt.isControlDown() || evt.isMetaDown())
					return null;
			}
			else
			{
				if((evt.isControlDown() ^ evt.isAltDown())
					|| evt.isMetaDown())
					return null;
			}

			
			
			
			if(last == LAST_MOD)
			{
				switch(ch)
				{
				case 'B':
				case 'M':
				case 'X':
				case 'c':
				case '!':
				case ',':
				case '?':
					last = LAST_NOTHING;
					return null;
				}
			}

			
			
			if(last == LAST_NUMKEYPAD && System.currentTimeMillis()
				- lastKeyTime < 750)
			{
				last = LAST_NOTHING;
				if((ch >= '0' && ch <= '9') || ch == '.'
					|| ch == '/' || ch == '*'
					|| ch == '-' || ch == '+')
				{
					return null;
				}
			}
			
			
			else if(last == LAST_BROKEN && System.currentTimeMillis()
				- lastKeyTime < 750 && !Character.isLetter(ch))
			{
				last = LAST_NOTHING;
				return null;
			}
			
			else if(last == LAST_ALT && System.currentTimeMillis()
				- lastKeyTime < 750)
			{
				last = LAST_NOTHING;
				return null;
			}

			return evt;
		
		
		case KeyEvent.KEY_RELEASED:
			if(keyCode == KeyEvent.VK_ALT)
			{
				
				
				if(OperatingSystem.isWindows()
					&& OperatingSystem.hasJava14())
					last = LAST_MOD;
			}
			return evt;
		
		default:
			return evt;
		}
	} 

	
	
	public static void numericKeypadKey()
	{
		last = LAST_NOTHING;
	} 

	

	
	private static long lastKeyTime;

	private static int last;
	private static final int LAST_NOTHING = 0;
	private static final int LAST_ALT = 1;
	private static final int LAST_BROKEN = 2;
	private static final int LAST_NUMKEYPAD = 3;
	private static final int LAST_MOD = 4;
	

	
	private static void handleBrokenKeys(KeyEvent evt, int keyCode)
	{
		if(evt.isAltDown() && evt.isControlDown()
			&& !evt.isMetaDown())
		{
			last = LAST_NOTHING;
			return;
		}
		else if(!(evt.isAltDown() || evt.isControlDown() || evt.isMetaDown()))
		{
			last = LAST_NOTHING;
			return;
		}

		if(evt.isAltDown())
			last = LAST_ALT;

		switch(keyCode)
		{
			case KeyEvent.VK_LEFT:      case KeyEvent.VK_RIGHT:
			case KeyEvent.VK_UP:        case KeyEvent.VK_DOWN:
			case KeyEvent.VK_DELETE:    case KeyEvent.VK_BACK_SPACE:
			case KeyEvent.VK_TAB:       case KeyEvent.VK_ENTER:
				last = LAST_NOTHING;
				break;
			default:
				if(keyCode < KeyEvent.VK_A || keyCode > KeyEvent.VK_Z)
					last = LAST_BROKEN;
				else
					last = LAST_NOTHING;
				break;
		}

		lastKeyTime = System.currentTimeMillis();
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.EditPane,21,5,0,36,139,74,23,21,14,0.566666667,785,1.0,5,0.970282318,0.206349206,1,1,36.0952381,29,3.2381,4,"

package org.gjt.sp.jedit;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.options.GlobalOptions;
import org.gjt.sp.jedit.textarea.*;



public class EditPane extends JPanel implements EBComponent
{
	
	
	public View getView()
	{
		return view;
	} 

	
	
	public Buffer getBuffer()
	{
		return buffer;
	} 

	
	
	public void setBuffer(final Buffer buffer)
	{
		if(this.buffer == buffer)
			return;

		
		

		recentBuffer = this.buffer;
		if(recentBuffer != null)
			saveCaretInfo();
		this.buffer = buffer;

		textArea.setBuffer(buffer);

		if(!init)
		{
			view.updateTitle();

			if(bufferSwitcher != null)
			{
				if(bufferSwitcher.getSelectedItem() != buffer)
					bufferSwitcher.setSelectedItem(buffer);
			}

			EditBus.send(new EditPaneUpdate(this,EditPaneUpdate
				.BUFFER_CHANGED));
		}

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				
				if(view.getEditPane() == EditPane.this
					&& (bufferSwitcher == null
					|| !bufferSwitcher.isPopupVisible()))
				{
					focusOnTextArea();
				}
			}
		});

		
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				loadCaretInfo();
				buffer.checkModTime(EditPane.this);
			}
		};

		if(buffer.isPerformingIO())
			VFSManager.runInAWTThread(runnable);
		else
			runnable.run();
	} 

	
	
	public void prevBuffer()
	{
		Buffer buffer = this.buffer.getPrev();
		if(buffer == null)
			setBuffer(jEdit.getLastBuffer());
		else
			setBuffer(buffer);
	} 

	
	
	public void nextBuffer()
	{
		Buffer buffer = this.buffer.getNext();
		if(buffer == null)
			setBuffer(jEdit.getFirstBuffer());
		else
			setBuffer(buffer);
	} 

	
	
	public void recentBuffer()
	{
		if(recentBuffer != null)
			setBuffer(recentBuffer);
		else
			getToolkit().beep();
	} 

	
	
	public void focusOnTextArea()
	{
		textArea.grabFocus();
		
		





	} 

	
	
	public JEditTextArea getTextArea()
	{
		return textArea;
	} 

	
	
	public BufferSwitcher getBufferSwitcher()
	{
		return bufferSwitcher;
	} 

	
	
	public void showBufferSwitcher()
	{
		if(bufferSwitcher == null)
			getToolkit().beep();
		else
		{
			bufferSwitcher.requestFocus();
			bufferSwitcher.showPopup();
		}
	} 

	
	
	public void saveCaretInfo()
	{
		buffer.setIntegerProperty(Buffer.CARET,
			textArea.getCaretPosition());

		

		buffer.setIntegerProperty(Buffer.SCROLL_VERT,
			textArea.getFirstPhysicalLine());
		buffer.setIntegerProperty(Buffer.SCROLL_HORIZ,
			textArea.getHorizontalOffset());
	} 

	
	
	public void loadCaretInfo()
	{
		Integer caret = (Integer)buffer.getProperty(Buffer.CARET);
		

		Integer firstLine = (Integer)buffer.getProperty(Buffer.SCROLL_VERT);
		Integer horizontalOffset = (Integer)buffer.getProperty(Buffer.SCROLL_HORIZ);

		if(caret != null)
		{
			textArea.setCaretPosition(Math.min(caret.intValue(),
				buffer.getLength()));
		}

		

		if(firstLine != null)
			textArea.setFirstLine(textArea.physicalToVirtual(firstLine.intValue()));

		if(horizontalOffset != null)
			textArea.setHorizontalOffset(horizontalOffset.intValue());

		
		view.getStatus().setMessage(null);
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
		{
			propertiesChanged();
			loadBufferSwitcher();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
	} 

	
	
	public final Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} 

	

	
	EditPane(View view, Buffer buffer)
	{
		super(new BorderLayout());

		init = true;

		this.view = view;

		EditBus.addToBus(this);

		textArea = new JEditTextArea(view);

		add(BorderLayout.CENTER,textArea);

		propertiesChanged();

		if(buffer == null)
			setBuffer(jEdit.getFirstBuffer());
		else
			setBuffer(buffer);

		loadBufferSwitcher();

		init = false;
	} 

	
	void close()
	{
		saveCaretInfo();
		EditBus.send(new EditPaneUpdate(this,EditPaneUpdate.DESTROYED));
		EditBus.removeFromBus(this);
	} 

	

	

	
	private boolean init;
	private View view;
	private Buffer buffer;
	private Buffer recentBuffer;
	private BufferSwitcher bufferSwitcher;
	private JEditTextArea textArea;
	

	
	private void propertiesChanged()
	{
		TextAreaPainter painter = textArea.getPainter();

		painter.setFont(UIManager.getFont(""TextArea.font""));
		painter.setBracketHighlightEnabled(jEdit.getBooleanProperty(
			""view.bracketHighlight""));
		painter.setBracketHighlightColor(
			jEdit.getColorProperty(""view.bracketHighlightColor""));
		painter.setEOLMarkersPainted(jEdit.getBooleanProperty(
			""view.eolMarkers""));
		painter.setEOLMarkerColor(
			jEdit.getColorProperty(""view.eolMarkerColor""));
		painter.setWrapGuidePainted(jEdit.getBooleanProperty(
			""view.wrapGuide""));
		painter.setWrapGuideColor(
			jEdit.getColorProperty(""view.wrapGuideColor""));
		painter.setCaretColor(
			jEdit.getColorProperty(""view.caretColor""));
		painter.setSelectionColor(
			jEdit.getColorProperty(""view.selectionColor""));
		painter.setBackground(
			jEdit.getColorProperty(""view.bgColor""));
		painter.setForeground(
			jEdit.getColorProperty(""view.fgColor""));
		painter.setBlockCaretEnabled(jEdit.getBooleanProperty(
			""view.blockCaret""));
		painter.setLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.lineHighlight""));
		painter.setLineHighlightColor(
			jEdit.getColorProperty(""view.lineHighlightColor""));
		painter.setAntiAliasEnabled(jEdit.getBooleanProperty(
			""view.antiAlias""));
		painter.setFractionalFontMetricsEnabled(jEdit.getBooleanProperty(
			""view.fracFontMetrics""));
		painter.setStyles(GUIUtilities.loadStyles(
			jEdit.getProperty(""view.font""),
			jEdit.getIntegerProperty(""view.fontsize"",12)));

		painter.setFoldLineStyle(GUIUtilities.parseStyle(
			jEdit.getProperty(""view.style.foldLine""),
			jEdit.getProperty(""view.font""),
			jEdit.getIntegerProperty(""view.fontsize"",12)));
		Gutter gutter = textArea.getGutter();
		gutter.setExpanded(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		int interval = jEdit.getIntegerProperty(
			""view.gutter.highlightInterval"",5);
		gutter.setHighlightInterval(interval);
		gutter.setCurrentLineHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		gutter.setBracketHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.bracketHighlight""));
		gutter.setBracketHighlightColor(
			jEdit.getColorProperty(""view.gutter.bracketHighlightColor""));
		gutter.setBackground(
			jEdit.getColorProperty(""view.gutter.bgColor""));
		gutter.setForeground(
			jEdit.getColorProperty(""view.gutter.fgColor""));
		gutter.setHighlightedForeground(
			jEdit.getColorProperty(""view.gutter.highlightColor""));
		gutter.setFoldColor(
			jEdit.getColorProperty(""view.gutter.foldColor""));
		gutter.setMarkerHighlightColor(
			jEdit.getColorProperty(""view.gutter.markerColor""));
		gutter.setMarkerHighlightEnabled(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		gutter.setCurrentLineForeground(
			jEdit.getColorProperty(""view.gutter.currentLineColor""));
		String alignment = jEdit.getProperty(
			""view.gutter.numberAlignment"");
		if (""right"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.RIGHT);
		}
		else if (""center"".equals(alignment))
		{
			gutter.setLineNumberAlignment(Gutter.CENTER);
		}
		else 
		{
			gutter.setLineNumberAlignment(Gutter.LEFT);
		}

		gutter.setFont(jEdit.getFontProperty(""view.gutter.font""));

		int width = jEdit.getIntegerProperty(
			""view.gutter.borderWidth"",3);
		gutter.setBorder(width,
			jEdit.getColorProperty(""view.gutter.focusBorderColor""),
			jEdit.getColorProperty(""view.gutter.noFocusBorderColor""),
			textArea.getPainter().getBackground());

		textArea.setCaretBlinkEnabled(jEdit.getBooleanProperty(
			""view.caretBlink""));

		textArea.setElectricScroll(jEdit.getIntegerProperty(
			""view.electricBorders"",0));

		
		JPopupMenu popup = GUIUtilities.loadPopupMenu(""view.context"");
		JMenuItem customize = new JMenuItem(jEdit.getProperty(
			""view.context.customize""));
		customize.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				new GlobalOptions(view,""context"");
			}
		});
		popup.addSeparator();
		popup.add(customize);
		textArea.setRightClickPopup(popup);

		
		textArea.setQuickCopyEnabled(jEdit.getBooleanProperty(
			""view.middleMousePaste""));

		textArea.propertiesChanged();
	} 

	
	private void loadBufferSwitcher()
	{
		if(jEdit.getBooleanProperty(""view.showBufferSwitcher""))
		{
			if(bufferSwitcher == null)
			{
				bufferSwitcher = new BufferSwitcher(this);
				add(BorderLayout.NORTH,bufferSwitcher);
				bufferSwitcher.updateBufferList();
				revalidate();
			}
		}
		else if(bufferSwitcher != null)
		{
			remove(bufferSwitcher);
			revalidate();
			bufferSwitcher = null;
		}
	} 

	
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer _buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.CREATED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();

			
			if(buffer.isClosed())
			{
				setBuffer(jEdit.getFirstBuffer());
				
				
				recentBuffer = null;
			}
		}
		else if(msg.getWhat() == BufferUpdate.CLOSED)
		{
			if(bufferSwitcher != null)
				bufferSwitcher.updateBufferList();

			if(_buffer == buffer)
			{
				Buffer newBuffer = (recentBuffer != null ?
					recentBuffer : _buffer.getPrev());
				if(newBuffer != null && !newBuffer.isClosed())
					setBuffer(newBuffer);
				else if(jEdit.getBufferCount() != 0)
					setBuffer(jEdit.getFirstBuffer());

				recentBuffer = null;
			}
			else if(_buffer == recentBuffer)
				recentBuffer = null;
		}
		else if(msg.getWhat() == BufferUpdate.LOAD_STARTED)
		{
			if(_buffer == buffer)
			{
				textArea.setCaretPosition(0);
				textArea.getPainter().repaint();
			}
		}
		else if(msg.getWhat() == BufferUpdate.LOADED)
		{
			if(_buffer == buffer)
			{
				textArea.repaint();
				textArea.updateScrollBars();
				if(bufferSwitcher != null)
					bufferSwitcher.updateBufferList();

				if(view.getEditPane() == this)
				{
					StatusBar status = view.getStatus();
					status.updateCaretStatus();
					status.updateBufferStatus();
					status.updateMiscStatus();
				}

				loadCaretInfo();
			}

		}
		else if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			if(_buffer == buffer)
			{
				if(bufferSwitcher != null)
				{
					if(buffer.isDirty())
						bufferSwitcher.repaint();
					else
						bufferSwitcher.updateBufferList();
				}
			}
		}
		else if(msg.getWhat() == BufferUpdate.MARKERS_CHANGED)
		{
			if(_buffer == buffer)
				textArea.getGutter().repaint();
		}
		else if(msg.getWhat() == BufferUpdate.PROPERTIES_CHANGED)
		{
			if(_buffer == buffer)
			{
				textArea.getFoldVisibilityManager()
					.foldStructureChanged();
				textArea.propertiesChanged();
				textArea.repaint();

				if(view.getEditPane() == this)
					view.getStatus().updateBufferStatus();
			}
		}
		else if(msg.getWhat() == BufferUpdate.SAVED)
		{
			if(_buffer == buffer)
				textArea.propertiesChanged();
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.options.SyntaxHiliteOptionPane,8,6,0,6,31,20,4,4,1,0.761904762,121,0.666666667,1,0.991111111,0.5,4,12,13.75,1,0.75,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.syntax.SyntaxStyle;
import org.gjt.sp.jedit.gui.ColorWellButton;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.*;




public class SyntaxHiliteOptionPane extends AbstractOptionPane
{
	public static final EmptyBorder noFocusBorder = new EmptyBorder(1,1,1,1);

	
	public SyntaxHiliteOptionPane()
	{
		super(""syntax"");
	}
	

	

	
	protected void _init()
	{
		setLayout(new BorderLayout(6,6));

		add(BorderLayout.CENTER,createStyleTableScroller());
	} 

	
	protected void _save()
	{
		styleModel.save();
	} 

	

	
	private StyleTableModel styleModel;
	private JTable styleTable;

	
	private JScrollPane createStyleTableScroller()
	{
		styleModel = createStyleTableModel();
		styleTable = new JTable(styleModel);
		styleTable.setRowSelectionAllowed(false);
		styleTable.setColumnSelectionAllowed(false);
		styleTable.setCellSelectionEnabled(false);
		styleTable.getTableHeader().setReorderingAllowed(false);
		styleTable.addMouseListener(new MouseHandler());
		TableColumnModel tcm = styleTable.getColumnModel();
 		TableColumn styleColumn = tcm.getColumn(1);
		styleColumn.setCellRenderer(new StyleTableModel.StyleRenderer());
		Dimension d = styleTable.getPreferredSize();
		d.height = Math.min(d.height,100);
		JScrollPane scroller = new JScrollPane(styleTable);
		scroller.setPreferredSize(d);
		return scroller;
	} 

	
	private StyleTableModel createStyleTableModel()
	{
		return new StyleTableModel();
	} 

	

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = styleTable.rowAtPoint(evt.getPoint());
			if(row == -1)
				return;

			SyntaxStyle style = new StyleEditor(
				SyntaxHiliteOptionPane.this,
				(SyntaxStyle)styleModel.getValueAt(
				row,1)).getStyle();
			if(style != null)
				styleModel.setValueAt(style,row,1);
		}
	} 
} 


class StyleTableModel extends AbstractTableModel
{
	private Vector styleChoices;

	
	StyleTableModel()
	{
		styleChoices = new Vector(13);
		addStyleChoice(""options.syntax.comment1Style"",""view.style.comment1"");
		addStyleChoice(""options.syntax.comment2Style"",""view.style.comment2"");
		addStyleChoice(""options.syntax.literal1Style"",""view.style.literal1"");
		addStyleChoice(""options.syntax.literal2Style"",""view.style.literal2"");
		addStyleChoice(""options.syntax.labelStyle"",""view.style.label"");
		addStyleChoice(""options.syntax.keyword1Style"",""view.style.keyword1"");
		addStyleChoice(""options.syntax.keyword2Style"",""view.style.keyword2"");
		addStyleChoice(""options.syntax.keyword3Style"",""view.style.keyword3"");
		addStyleChoice(""options.syntax.functionStyle"",""view.style.function"");
		addStyleChoice(""options.syntax.markupStyle"",""view.style.markup"");
		addStyleChoice(""options.syntax.operatorStyle"",""view.style.operator"");
		addStyleChoice(""options.syntax.digitStyle"",""view.style.digit"");
		addStyleChoice(""options.syntax.invalidStyle"",""view.style.invalid"");
		addStyleChoice(""options.syntax.foldLine"",""view.style.foldLine"");
		MiscUtilities.quicksort(styleChoices,new MiscUtilities.StringCompare());
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return styleChoices.size();
	} 

	
	public Object getValueAt(int row, int col)
	{
		StyleChoice ch = (StyleChoice)styleChoices.elementAt(row);
		switch(col)
		{
		case 0:
			return ch.label;
		case 1:
			return ch.style;
		default:
			return null;
		}
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		StyleChoice ch = (StyleChoice)styleChoices.elementAt(row);
		if(col == 1)
			ch.style = (SyntaxStyle)value;
		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.syntax.object"");
		case 1:
			return jEdit.getProperty(""options.syntax.style"");
		default:
			return null;
		}
	} 

	
	public void save()
	{
		for(int i = 0; i < styleChoices.size(); i++)
		{
			StyleChoice ch = (StyleChoice)styleChoices
				.elementAt(i);
			jEdit.setProperty(ch.property,
				GUIUtilities.getStyleString(ch.style));
		}
	} 

	
	private void addStyleChoice(String label, String property)
	{
		styleChoices.addElement(new StyleChoice(jEdit.getProperty(label),
			property,
			GUIUtilities.parseStyle(jEdit.getProperty(property),
			""Dialog"",12)));
	} 

	
	static class StyleChoice
	{
		String label;
		String property;
		SyntaxStyle style;

		StyleChoice(String label, String property, SyntaxStyle style)
		{
			this.label = label;
			this.property = property;
			this.style = style;
		}

		
		public String toString()
		{
			return label;
		}
	} 

	
	static class StyleRenderer extends JLabel
		implements TableCellRenderer
	{
		
		public StyleRenderer()
		{
			setOpaque(true);
			setBorder(SyntaxHiliteOptionPane.noFocusBorder);
			setText(""Hello World"");
		} 

		
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (value != null)
			{
				SyntaxStyle style = (SyntaxStyle)value;
				setForeground(style.getForegroundColor());
				if (style.getBackgroundColor() != null) 
					setBackground(style.getBackgroundColor());
				else
				{
					
					setBackground(jEdit.getColorProperty(
						""view.bgColor""));
				}
				setFont(style.getFont());
			}

			setBorder((cellHasFocus) ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: SyntaxHiliteOptionPane.noFocusBorder);
			return this;
		} 
	} 
} 


class StyleEditor extends EnhancedDialog implements ActionListener
{
	
	StyleEditor(Component comp, SyntaxStyle style)
	{
		super(GUIUtilities.getParentDialog(comp),
			jEdit.getProperty(""style-editor.title""),true);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridx = cons.gridy = 0;
		cons.gridwidth = 2;
		cons.gridheight = 1;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = 0.0f;

		italics = new JCheckBox(jEdit.getProperty(""style-editor.italics""));
		italics.setSelected(style.getFont().isItalic());
		layout.setConstraints(italics,cons);
		panel.add(italics);

		cons.gridy++;
		bold = new JCheckBox(jEdit.getProperty(""style-editor.bold""));
		bold.setSelected(style.getFont().isBold());
		layout.setConstraints(bold,cons);
		panel.add(bold);

		cons.gridy++;
		cons.gridwidth = 1;
		Color fg = style.getForegroundColor();

		fgColorCheckBox = new JCheckBox(jEdit.getProperty(""style-editor.fgColor""));
		fgColorCheckBox.setSelected(fg != null);
		fgColorCheckBox.addActionListener(this);
		fgColorCheckBox.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(fgColorCheckBox,cons);
		panel.add(fgColorCheckBox);

		cons.gridx++;
		fgColor = new ColorWellButton(fg);
		fgColor.setEnabled(fg != null);
		layout.setConstraints(fgColor,cons);
		panel.add(fgColor);

		cons.gridx = 0;
		cons.gridy++;
		Color bg = style.getBackgroundColor();
		bgColorCheckBox = new JCheckBox(jEdit.getProperty(""style-editor.bgColor""));
		bgColorCheckBox.setSelected(bg != null);
		bgColorCheckBox.addActionListener(this);
		bgColorCheckBox.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(bgColorCheckBox,cons);
		panel.add(bgColorCheckBox);

		cons.gridx++;
		bgColor = new ColorWellButton(bg);
		bgColor.setEnabled(bg != null);
		layout.setConstraints(bgColor,cons);
		panel.add(bgColor);

		content.add(BorderLayout.CENTER,panel);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		box.add(ok = new JButton(jEdit.getProperty(""common.ok"")));
		getRootPane().setDefaultButton(ok);
		ok.addActionListener(this);
		box.add(Box.createHorizontalStrut(6));
		box.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(this);
		box.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,box);

		pack();
		setLocationRelativeTo(GUIUtilities.getParentDialog(comp));

		setResizable(false);
		show();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
		else if(source == fgColorCheckBox)
			fgColor.setEnabled(fgColorCheckBox.isSelected());
		else if(source == bgColorCheckBox)
			bgColor.setEnabled(bgColorCheckBox.isSelected());
	} 

	
	public void ok()
	{
		okClicked = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public SyntaxStyle getStyle()
	{
		if(!okClicked)
			return null;

		Color foreground = (fgColorCheckBox.isSelected()
			? fgColor.getSelectedColor()
			: null);

		Color background = (bgColorCheckBox.isSelected()
			? bgColor.getSelectedColor()
			: null);

		return new SyntaxStyle(foreground,background,
				new Font(""Dialog"",
				(italics.isSelected() ? Font.ITALIC : 0)
				| (bold.isSelected() ? Font.BOLD : 0),
				12));
	} 

	
	private JCheckBox italics;
	private JCheckBox bold;
	private JCheckBox fgColorCheckBox;
	private ColorWellButton fgColor;
	private JCheckBox bgColorCheckBox;
	private ColorWellButton bgColor;
	private JButton ok;
	private JButton cancel;
	private boolean okClicked;
	
} 
"
jEdit,4.1,org.gjt.sp.jedit.EBMessage,6,1,11,31,13,9,31,1,6,0.4,45,1.0,1,0.0,0.583333333,0,0,6.333333333,1,0.8333,0,"

package org.gjt.sp.jedit;


public abstract class EBMessage
{
	
	
	public EBMessage(EBComponent source)
	{
		this.source = source;
	} 

	
	
	public EBComponent getSource()
	{
		return source;
	} 

	
	
	public String toString()
	{
		return getClass().getName() + ""["" + paramString() + ""]"";
	} 

	
	
	public String paramString()
	{
		return ""source="" + source;
	} 

	
	private EBComponent source;
	

	
	
	public void veto()
	{
	}

	
	public boolean isVetoed()
	{
		return false;
	}

	
	public static abstract class NonVetoable extends EBMessage
	{
		
		public NonVetoable(EBComponent source)
		{
			super(source);
		}

		
		public void veto()
		{
			throw new InternalError(""Can't veto this message"");
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.options.AbbrevsOptionPane,14,6,0,14,87,51,5,13,1,0.817307692,497,1.0,1,0.980938416,0.5,4,12,33.92857143,3,1.4286,2,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;




public class AbbrevsOptionPane extends AbstractOptionPane
{
	
	public AbbrevsOptionPane()
	{
		super(""abbrevs"");
	} 

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		JPanel panel = new JPanel(new BorderLayout(6,6));

		expandOnInput = new JCheckBox(jEdit.getProperty(""options.abbrevs""
			+ "".expandOnInput""),Abbrevs.getExpandOnInput());

		panel.add(expandOnInput,BorderLayout.NORTH);

		JPanel panel2 = new JPanel();
		panel2.setLayout(new BoxLayout(panel2,BoxLayout.X_AXIS));
		panel2.setBorder(new EmptyBorder(0,0,6,0));
		panel2.add(Box.createGlue());
		JLabel label = new JLabel(jEdit.getProperty(""options.abbrevs.set""));
		label.setBorder(new EmptyBorder(0,0,0,12));
		panel2.add(label);

		Hashtable _modeAbbrevs = Abbrevs.getModeAbbrevs();
		modeAbbrevs = new Hashtable();
		Mode[] modes = jEdit.getModes();
		String[] sets = new String[modes.length + 1];
		sets[0] = ""global"";
		for(int i = 0; i < modes.length; i++)
		{
			String name = modes[i].getName();
			sets[i+1] = name;
			modeAbbrevs.put(name,new AbbrevsModel((Hashtable)_modeAbbrevs.get(name)));
		}

		setsComboBox = new JComboBox(sets);
		ActionHandler actionHandler = new ActionHandler();
		setsComboBox.addActionListener(actionHandler);
		panel2.add(setsComboBox);
		panel2.add(Box.createGlue());
		panel.add(panel2,BorderLayout.SOUTH);

		add(BorderLayout.NORTH,panel);

		globalAbbrevs = new AbbrevsModel(Abbrevs.getGlobalAbbrevs());
		abbrevsTable = new JTable(globalAbbrevs);
		abbrevsTable.getColumnModel().getColumn(1).setCellRenderer(
			new Renderer());
		abbrevsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		abbrevsTable.getTableHeader().setReorderingAllowed(false);
		abbrevsTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		abbrevsTable.getSelectionModel().addListSelectionListener(
			new SelectionHandler());
		abbrevsTable.addMouseListener(new TableMouseHandler());
		Dimension d = abbrevsTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(abbrevsTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.CENTER,scroller);

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(6,0,0,0));

		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""options.abbrevs.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""options.abbrevs.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		edit = new RolloverButton(GUIUtilities.loadIcon(""ButtonProperties.png""));
		edit.setToolTipText(jEdit.getProperty(""options.abbrevs.edit""));
		edit.addActionListener(actionHandler);
		buttons.add(edit);
		buttons.add(Box.createGlue());

		add(BorderLayout.SOUTH,buttons);

		updateEnabled();
	} 

	
	protected void _save()
	{
		if(abbrevsTable.getCellEditor() != null)
			abbrevsTable.getCellEditor().stopCellEditing();

		Abbrevs.setExpandOnInput(expandOnInput.isSelected());

		Abbrevs.setGlobalAbbrevs(globalAbbrevs.toHashtable());

		Hashtable modeHash = new Hashtable();
		Enumeration keys = modeAbbrevs.keys();
		Enumeration values = modeAbbrevs.elements();
		while(keys.hasMoreElements())
		{
			modeHash.put(keys.nextElement(),((AbbrevsModel)values.nextElement())
				.toHashtable());
		}
		Abbrevs.setModeAbbrevs(modeHash);
	} 

	

	
	private JComboBox setsComboBox;
	private JCheckBox expandOnInput;
	private JTable abbrevsTable;
	private AbbrevsModel globalAbbrevs;
	private Hashtable modeAbbrevs;
	private JButton add;
	private JButton edit;
	private JButton remove;
	

	
	private void updateEnabled()
	{
		int selectedRow = abbrevsTable.getSelectedRow();
		edit.setEnabled(selectedRow != -1);
		remove.setEnabled(selectedRow != -1);
	} 

	
	private void edit()
	{
		AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();

		int row = abbrevsTable.getSelectedRow();

		String abbrev = (String)abbrevsModel.getValueAt(row,0);
		String expansion = (String)abbrevsModel.getValueAt(row,1);

		EditAbbrevDialog dialog = new EditAbbrevDialog(
			GUIUtilities.getParentDialog(AbbrevsOptionPane.this),
			abbrev,expansion);
		abbrev = dialog.getAbbrev();
		expansion = dialog.getExpansion();
		if(abbrev != null && expansion != null)
		{
			abbrevsModel.setValueAt(abbrev,row,0);
			abbrevsModel.setValueAt(expansion,row,1);
		}
	} 

	

	
	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(abbrevsTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				((AbbrevsModel)abbrevsTable.getModel()).sort(0);
				break;
			case 1:
				((AbbrevsModel)abbrevsTable.getModel()).sort(1);
				break;
			}
		}
	} 

	
	class TableMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			if(evt.getClickCount() == 2)
				edit();
		}
	} 

	
	class SelectionHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateEnabled();
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			AbbrevsModel abbrevsModel = (AbbrevsModel)abbrevsTable.getModel();

			Object source = evt.getSource();
			if(source == setsComboBox)
			{
				String selected = (String)setsComboBox.getSelectedItem();
				if(selected.equals(""global""))
				{
					abbrevsTable.setModel(globalAbbrevs);
				}
				else
				{
					abbrevsTable.setModel((AbbrevsModel)
						modeAbbrevs.get(selected));
				}
				updateEnabled();
			}
			else if(source == add)
			{
				EditAbbrevDialog dialog = new EditAbbrevDialog(
					GUIUtilities.getParentDialog(AbbrevsOptionPane.this),
					null,null);
				String abbrev = dialog.getAbbrev();
				String expansion = dialog.getExpansion();
				if(abbrev != null && abbrev.length() != 0
					&& expansion != null
					&& expansion.length() != 0)
				{
					abbrevsModel.add(abbrev,expansion);
					int index = abbrevsModel.getRowCount() - 1;
					abbrevsTable.getSelectionModel()
						.setSelectionInterval(index,index);
					Rectangle rect = abbrevsTable.getCellRect(
						index,0,true);
					abbrevsTable.scrollRectToVisible(rect);
					updateEnabled();
				}
			}
			else if(source == edit)
			{
				edit();
			}
			else if(source == remove)
			{
				int selectedRow = abbrevsTable.getSelectedRow();
				abbrevsModel.remove(selectedRow);
				updateEnabled();
			}
		}
	} 

	
	static class Renderer extends DefaultTableCellRenderer
	{
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			String valueStr = value.toString();

			
			
			if(valueStr.toLowerCase().startsWith(""<html>""))
				valueStr = "" "" + valueStr;
			return super.getTableCellRendererComponent(table,valueStr,
				isSelected,cellHasFocus,row,col);
		}
	} 
} 


class AbbrevsModel extends AbstractTableModel
{
	Vector abbrevs;

	
	AbbrevsModel()
	{
		abbrevs = new Vector();
	} 

	
	AbbrevsModel(Hashtable abbrevHash)
	{
		this();

		if(abbrevHash != null)
		{
			Enumeration abbrevEnum = abbrevHash.keys();
			Enumeration expandEnum = abbrevHash.elements();

			while(abbrevEnum.hasMoreElements())
			{
				abbrevs.addElement(new Abbrev((String)abbrevEnum.nextElement(),
					(String)expandEnum.nextElement()));
			}

			sort(0);
		}
	} 

	
	void sort(int col)
	{
		MiscUtilities.quicksort(abbrevs,new AbbrevCompare(col));
		fireTableDataChanged();
	} 

	
	void add(String abbrev, String expansion)
	{
		abbrevs.addElement(new Abbrev(abbrev,expansion));
		fireTableStructureChanged();
	} 

	
	void remove(int index)
	{
		abbrevs.removeElementAt(index);
		fireTableStructureChanged();
	} 

	
	public Hashtable toHashtable()
	{
		Hashtable hash = new Hashtable();
		for(int i = 0; i < abbrevs.size(); i++)
		{
			Abbrev abbrev = (Abbrev)abbrevs.elementAt(i);
			if(abbrev.abbrev.length() > 0
				&& abbrev.expand.length() > 0)
			{
				hash.put(abbrev.abbrev,abbrev.expand);
			}
		}
		return hash;
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return abbrevs.size();
	} 

	
	public Object getValueAt(int row, int col)
	{
		Abbrev abbrev = (Abbrev)abbrevs.elementAt(row);
		switch(col)
		{
		case 0:
			return abbrev.abbrev;
		case 1:
			return abbrev.expand;
		default:
			return null;
		}
	} 

	
	public boolean isCellEditable(int row, int col)
	{
		return false;
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		if(value == null)
			value = """";

		Abbrev abbrev = (Abbrev)abbrevs.elementAt(row);

		if(col == 0)
			abbrev.abbrev = (String)value;
		else
			abbrev.expand = (String)value;

		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.abbrevs.abbrev"");
		case 1:
			return jEdit.getProperty(""options.abbrevs.expand"");
		default:
			return null;
		}
	} 

	
	class AbbrevCompare implements MiscUtilities.Compare
	{
		int col;

		AbbrevCompare(int col)
		{
			this.col = col;
		}

		public int compare(Object obj1, Object obj2)
		{
			Abbrev a1 = (Abbrev)obj1;
			Abbrev a2 = (Abbrev)obj2;

			if(col == 0)
			{
				String abbrev1 = a1.abbrev.toLowerCase();
				String abbrev2 = a2.abbrev.toLowerCase();

				return MiscUtilities.compareStrings(
					abbrev1,abbrev2,true);
			}
			else
			{
				String expand1 = a1.expand.toLowerCase();
				String expand2 = a2.expand.toLowerCase();

				return MiscUtilities.compareStrings(
					expand1,expand2,true);
			}
		}
	} 
} 


class Abbrev
{
	Abbrev() {}

	Abbrev(String abbrev, String expand)
	{
		this.abbrev = abbrev;
		this.expand = expand;
	}

	String abbrev;
	String expand;
} 
"
jEdit,4.1,org.gjt.sp.jedit.gui.AboutDialog,3,7,0,5,27,3,1,5,3,1.0,110,1.0,0,0.996960486,0.666666667,0,0,35.33333333,1,0.6667,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;


public class AboutDialog extends EnhancedDialog
{
	
	public AboutDialog(View view)
	{
		super(view,jEdit.getProperty(""about.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		content.add(BorderLayout.CENTER,new AboutPanel());

		JPanel buttonPanel = new JPanel();
		buttonPanel.setLayout(new BoxLayout(buttonPanel,BoxLayout.X_AXIS));
		buttonPanel.setBorder(new EmptyBorder(12,0,0,0));

		buttonPanel.add(Box.createGlue());
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(close);
		buttonPanel.add(close);
		buttonPanel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttonPanel);

		pack();
		setResizable(false);
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	private JButton close;

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			dispose();
		}
	} 

	
	static class AboutPanel extends JComponent
	{
		ImageIcon image;
		Vector text;
		int scrollPosition;
		AnimationThread thread;
		int maxWidth;
		FontMetrics fm;

		public static int TOP = 120;
		public static int BOTTOM = 30;

		AboutPanel()
		{
			setFont(UIManager.getFont(""Label.font""));
			fm = getFontMetrics(getFont());

			setForeground(new Color(96,96,96));
			image = new ImageIcon(getClass().getResource(
				""/org/gjt/sp/jedit/icons/about.png""));

			setBorder(new MatteBorder(1,1,1,1,Color.gray));

			text = new Vector(50);
			StringTokenizer st = new StringTokenizer(
				jEdit.getProperty(""about.text""),""\n"");
			while(st.hasMoreTokens())
			{
				String line = st.nextToken();
				text.addElement(line);
				maxWidth = Math.max(maxWidth,
					fm.stringWidth(line) + 10);
			}

			scrollPosition = -250;

			thread = new AnimationThread();
		}

		public void paintComponent(Graphics g)
		{
			g.setColor(new Color(96,96,96));
			image.paintIcon(this,g,1,1);

			FontMetrics fm = g.getFontMetrics();

			String[] args = { jEdit.getVersion() };
			String version = jEdit.getProperty(""about.version"",args);
			g.drawString(version,(getWidth() - fm.stringWidth(version)) / 2,
				getHeight() - 5);

			g = g.create((getWidth() - maxWidth) / 2,TOP,maxWidth,
				getHeight() - TOP - BOTTOM);

			int height = fm.getHeight();
			int firstLine = scrollPosition / height;

			int firstLineOffset = height - scrollPosition % height;
			int lines = (getHeight() - TOP - BOTTOM) / height;

			int y = firstLineOffset;

			for(int i = 0; i <= lines; i++)
			{
				if(i + firstLine >= 0 && i + firstLine < text.size())
				{
					String line = (String)text.get(i + firstLine);
					g.drawString(line,(maxWidth - fm.stringWidth(line))/2,y);
				}
				y += fm.getHeight();
			}
		}

		public Dimension getPreferredSize()
		{
			return new Dimension(1 + image.getIconWidth(),
				1 + image.getIconHeight());
		}

		public void addNotify()
		{
			super.addNotify();
			thread.start();
		}

		public void removeNotify()
		{
			super.removeNotify();
			thread.kill();
		}

		class AnimationThread extends Thread
		{
			private boolean running = true;
		
			AnimationThread()
			{
				super(""About box animation thread"");
				setPriority(Thread.MIN_PRIORITY);
			}
			
			public void kill()
			{
				running = false;
			}

			public void run()
			{
				FontMetrics fm = getFontMetrics(getFont());
				int max = (text.size() * fm.getHeight());

				while (running)
				{
					scrollPosition += 2;

					if(scrollPosition > max)
						scrollPosition = -250;

					try
					{
						Thread.sleep(100);
					}
					catch(Exception e)
					{
					}

					repaint(getWidth() / 2 - maxWidth,
						TOP,maxWidth * 2,
						getHeight() - TOP - BOTTOM);
				}
			}
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.util.SegmentBuffer,4,2,0,2,6,0,2,0,3,2.0,83,0.0,0,0.842105263,0.5625,1,11,19.75,3,1.25,0,"

package org.gjt.sp.util;

import javax.swing.text.Segment;


public class SegmentBuffer extends Segment
{
	
	public SegmentBuffer(int capacity)
	{
		ensureCapacity(capacity);
	} 

	
	public void append(char ch)
	{
		ensureCapacity(count + 1);
		array[offset + count] = ch;
		count++;
	} 

	
	public void append(char[] text, int off, int len)
	{
		ensureCapacity(count + len);
		System.arraycopy(text,off,array,count,len);
		count += len;
	} 

	

	
	private void ensureCapacity(int capacity)
	{
		if(array == null)
			array = new char[capacity];
		else if(capacity >= array.length)
		{
			char[] arrayN = new char[capacity * 2];
			System.arraycopy(array,0,arrayN,0,count);
			array = arrayN;
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.BeanShell,22,1,0,29,95,137,9,22,16,0.785714286,1219,0.666666667,2,0.0,0.20952381,0,0,54.13636364,14,2.0455,2,"

package org.gjt.sp.jedit;


import bsh.*;
import java.lang.reflect.InvocationTargetException;
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.BeanShellErrorDialog;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class BeanShell
{
	
	
	public static void evalSelection(View view, JEditTextArea textArea)
	{
		String command = textArea.getSelectedText();
		if(command == null)
		{
			view.getToolkit().beep();
			return;
		}
		Object returnValue = eval(view,global,command);
		if(returnValue != null)
			textArea.setSelectedText(returnValue.toString());
	} 

	
	
	public static void showEvaluateDialog(View view)
	{
		String command = GUIUtilities.input(view,""beanshell-eval-input"",null);
		if(command != null)
		{
			if(!command.endsWith("";""))
				command = command + "";"";

			int repeat = view.getInputHandler().getRepeatCount();

			if(view.getMacroRecorder() != null)
			{
				view.getMacroRecorder().record(repeat,command);
			}

			Object returnValue = null;
			try
			{
				for(int i = 0; i < repeat; i++)
				{
					returnValue = _eval(view,global,command);
				}
			}
			catch(Throwable e)
			{
				Log.log(Log.ERROR,BeanShell.class,e);

				handleException(view,null,e);
			}

			if(returnValue != null)
			{
				String[] args = { returnValue.toString() };
				GUIUtilities.message(view,""beanshell-eval"",args);
			}
		}
	} 

	
	
	public static void showEvaluateLinesDialog(View view)
	{
		String command = GUIUtilities.input(view,""beanshell-eval-line"",null);

		JEditTextArea textArea = view.getTextArea();
		Buffer buffer = view.getBuffer();

		if(command == null || command.length() == 0)
			return;

		Selection[] selection = textArea.getSelection();
		if(selection.length == 0)
		{
			view.getToolkit().beep();
			return;
		}

		if(!command.endsWith("";""))
			command = command + "";"";

		if(view.getMacroRecorder() != null)
			view.getMacroRecorder().record(1,command);

		try
		{
			buffer.beginCompoundEdit();

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				for(int j = s.getStartLine(); j <= s.getEndLine(); j++)
				{
					
					
					if(s.getEnd() == textArea.getLineStartOffset(j))
						break;

					global.setVariable(""line"",new Integer(j));
					global.setVariable(""index"",new Integer(
						j - s.getStartLine()));
					int start = s.getStart(buffer,j);
					int end = s.getEnd(buffer,j);
					String text = buffer.getText(start,
						end - start);
					global.setVariable(""text"",text);

					Object returnValue = _eval(view,global,command);
					if(returnValue != null)
					{
						buffer.remove(start,end - start);
						buffer.insert(start,
							returnValue.toString());
					}
				}
			}
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);

			handleException(view,null,e);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		textArea.selectNone();
	} 

	
	
	public static void runScript(View view, String path, Reader in,
		boolean ownNamespace)
	{
		try
		{
			_runScript(view,path,in,ownNamespace);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);

			handleException(view,path,e);
		}
	} 

	
	
	public static void _runScript(View view, String path, Reader in,
		boolean ownNamespace) throws Exception
	{
		Log.log(Log.MESSAGE,BeanShell.class,""Running script "" + path);

		NameSpace namespace;
		if(ownNamespace)
			namespace = new NameSpace(global,""script namespace"");
		else
			namespace = global;

		Interpreter interp = createInterpreter(namespace);

		VFS vfs = null;
		Object session = null;

		try
		{
			if(in == null)
			{
				Buffer buffer = jEdit.getBuffer(path);

				vfs = VFSManager.getVFSForPath(path);
				session = vfs.createVFSSession(path,view);
				if(session == null)
				{
					
					return;
				}

				if(buffer != null)
				{
					if(!buffer.isLoaded())
						VFSManager.waitForRequests();

					in = new StringReader(buffer.getText(0,
						buffer.getLength()));
				}
				else
				{
					in = new BufferedReader(new InputStreamReader(
						vfs._createInputStream(session,
						path,false,view)));
				}
			}

			if(view != null)
			{
				interp.set(""view"",view);
				EditPane editPane = view.getEditPane();
				interp.set(""editPane"",editPane);
				interp.set(""buffer"",editPane.getBuffer());
				interp.set(""textArea"",editPane.getTextArea());
			}

			interp.set(""scriptPath"",path);

			running = true;

			interp.eval(in,namespace,path);
		}
		catch(Exception e)
		{
			unwrapException(e);
		}
		finally
		{
			running = false;

			if(session != null)
			{
				try
				{
					vfs._endVFSSession(session,view);
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,BeanShell.class,io);
					GUIUtilities.error(view,""read-error"",
						new String[] { path, io.toString() });
				}
			}

			try
			{
				
				if(!ownNamespace)
				{
					if(view != null)
					{
						interp.unset(""view"");
						interp.unset(""editPane"");
						interp.unset(""buffer"");
						interp.unset(""textArea"");
					}

					interp.unset(""scriptPath"");
				}
			}
			catch(EvalError e)
			{
				
			}
		}
	} 

	
	
	public static Object eval(View view, NameSpace namespace, String command)
	{
		try
		{
			return _eval(view,namespace,command);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,BeanShell.class,e);

			handleException(view,null,e);
		}

		return null;
	} 

	
	
	public static Object _eval(View view, NameSpace namespace, String command)
		throws Exception
	{
		Interpreter interp = createInterpreter(namespace);

		try
		{
			if(view != null)
			{
				EditPane editPane = view.getEditPane();
				interp.set(""view"",view);
				interp.set(""editPane"",editPane);
				interp.set(""buffer"",editPane.getBuffer());
				interp.set(""textArea"",editPane.getTextArea());
			}

			return interp.eval(command);
		}
		catch(Exception e)
		{
			unwrapException(e);
			
			return null;
		}
		finally
		{
			try
			{
				if(view != null)
				{
					interp.unset(""view"");
					interp.unset(""editPane"");
					interp.unset(""buffer"");
					interp.unset(""textArea"");
				}
			}
			catch(EvalError e)
			{
				
			}
		}
	} 

	
	
	public static BshMethod cacheBlock(String id, String code, boolean namespace)
		throws Exception
	{
		String name = ""__internal_"" + id;

		
		if(namespace)
		{
			_eval(null,global,name + ""(ns) {\nthis.callstack.set(0,ns);\n"" + code + ""\n}"");
			return global.getMethod(name,new Class[] { NameSpace.class });
		}
		else
		{
			_eval(null,global,name + ""() {\n"" + code + ""\n}"");
			return global.getMethod(name,new Class[0]);
		}
	} 

	
	
	public static Object runCachedBlock(BshMethod method, View view,
		NameSpace namespace) throws Exception
	{
		boolean useNamespace;
		if(namespace == null)
		{
			useNamespace = false;
			namespace = global;
		}
		else
			useNamespace = true;

		try
		{
			if(view != null)
			{
				namespace.setVariable(""view"",view);
				EditPane editPane = view.getEditPane();
				namespace.setVariable(""editPane"",editPane);
				namespace.setVariable(""buffer"",editPane.getBuffer());
				namespace.setVariable(""textArea"",editPane.getTextArea());
			}

			Object retVal = method.invoke(useNamespace
				? new Object[] { namespace }
				: NO_ARGS,
				interpForMethods,new CallStack());
			if(retVal instanceof Primitive)
			{
				if(retVal == Primitive.VOID)
					return null;
				else
					return ((Primitive)retVal).getValue();
			}
			else
				return retVal;
		}
		catch(Exception e)
		{
			unwrapException(e);
			
			return null;
		}
		finally
		{
			if(view != null)
			{
				try
				{
					namespace.setVariable(""view"",null);
					namespace.setVariable(""editPane"",null);
					namespace.setVariable(""buffer"",null);
					namespace.setVariable(""textArea"",null);
				}
				catch(EvalError e)
				{
					
				}
			}
		}
	} 

	
	
	public static boolean isScriptRunning()
	{
		return running;
	} 

	
	
	public static NameSpace getNameSpace()
	{
		return global;
	} 

	

	
	
	public static void runScript(View view, String path,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		runScript(view,path,null,ownNamespace);
	} 

	
	
	public static void runScript(View view, String path, Reader in,
		boolean ownNamespace, boolean rethrowBshErrors)
	{
		runScript(view,path,in,ownNamespace);
	} 

	
	
	public static Object eval(View view, String command,
		boolean rethrowBshErrors)
	{
		return eval(view,global,command);
	} 

	
	
	public static Object eval(View view, NameSpace namespace,
		String command, boolean rethrowBshErrors)
	{
		return eval(view,namespace,command);
	} 

	

	

	
	static void init()
	{
		BshClassManager.setClassLoader(new JARClassLoader());

		global = new NameSpace(""jEdit embedded BeanShell interpreter"");
		global.importPackage(""org.gjt.sp.jedit"");
		global.importPackage(""org.gjt.sp.jedit.browser"");
		global.importPackage(""org.gjt.sp.jedit.buffer"");
		global.importPackage(""org.gjt.sp.jedit.gui"");
		global.importPackage(""org.gjt.sp.jedit.help"");
		global.importPackage(""org.gjt.sp.jedit.io"");
		global.importPackage(""org.gjt.sp.jedit.msg"");
		global.importPackage(""org.gjt.sp.jedit.options"");
		global.importPackage(""org.gjt.sp.jedit.pluginmgr"");
		global.importPackage(""org.gjt.sp.jedit.print"");
		global.importPackage(""org.gjt.sp.jedit.search"");
		global.importPackage(""org.gjt.sp.jedit.syntax"");
		global.importPackage(""org.gjt.sp.jedit.textarea"");
		global.importPackage(""org.gjt.sp.util"");

		interpForMethods = createInterpreter(global);

		Log.log(Log.DEBUG,BeanShell.class,""BeanShell interpreter version ""
			+ Interpreter.VERSION);
	} 

	

	

	
	private static final Object[] NO_ARGS = new Object[0];
	private static Interpreter interpForMethods;
	private static NameSpace global;
	private static boolean running;
	

	
	
	private static void unwrapException(Exception e) throws Exception
	{
		if(e instanceof TargetError)
		{
			Throwable t = ((TargetError)e).getTarget();
			if(t instanceof Exception)
				throw (Exception)t;
			else if(t instanceof Error)
				throw (Error)t;
		}

		if(e instanceof InvocationTargetException)
		{
			Throwable t = ((InvocationTargetException)e).getTargetException();
			if(t instanceof Exception)
				throw (Exception)t;
			else if(t instanceof Error)
				throw (Error)t;
		}

		throw e;
	} 

	
	private static void handleException(View view, String path, Throwable t)
	{
		if(t instanceof IOException)
		{
			VFSManager.error(view,path,""ioerror.read-error"",
				new String[] { t.toString() });
		}
		else
			new BeanShellErrorDialog(view,t);
	} 

	
	private static Interpreter createInterpreter(NameSpace nameSpace)
	{
		return new Interpreter(null,System.out,System.err,false,nameSpace);
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.msg.EditPaneUpdate,5,2,0,6,13,4,4,3,4,0.875,52,0.25,0,0.5,0.5,1,1,8.6,1,0.6,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class EditPaneUpdate extends EBMessage
{
	
	public static final Object CREATED = ""CREATED"";

	
	public static final Object DESTROYED = ""DESTROYED"";

	
	public static final Object BUFFER_CHANGED = ""BUFFER_CHANGED"";

	
	public EditPaneUpdate(EditPane editPane, Object what)
	{
		super(editPane);

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
	}

	
	public Object getWhat()
	{
		return what;
	}

	
	public EditPane getEditPane()
	{
		return (EditPane)getSource();
	}

	public String paramString()
	{
		return ""what="" + what + "","" + super.paramString();
	}

	
	private Object what;
}
"
jEdit,4.1,org.gjt.sp.jedit.help.HelpTOCPanel,7,5,0,15,59,5,4,15,2,0.633333333,389,1.0,1,0.990895296,0.371428571,0,0,53.85714286,8,2.0,0,"

package org.gjt.sp.jedit.help;


import com.microstar.xml.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.io.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.FileCellRenderer; 
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


class HelpTOCPanel extends JPanel
{
	
	public HelpTOCPanel(HelpViewer helpViewer)
	{
		super(new BorderLayout());

		this.helpViewer = helpViewer;
		nodes = new Hashtable();

		createTOC();

		toc = new TOCTree(tocModel);

		
		if(!OperatingSystem.isMacOSLF())
			toc.putClientProperty(""JTree.lineStyle"", ""Angled"");

		toc.setCellRenderer(new TOCCellRenderer());
		toc.setEditable(false);
		toc.setRootVisible(false);
		toc.setShowsRootHandles(true);

		for(int i = 0; i <tocRoot.getChildCount(); i++)
		{
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)
				tocRoot.getChildAt(i);
			toc.expandPath(new TreePath(node.getPath()));
		}

		add(BorderLayout.CENTER,new JScrollPane(toc));
	} 

	
	public void selectNode(String shortURL)
	{
		DefaultMutableTreeNode node = (DefaultMutableTreeNode)nodes.get(shortURL);

		if(node == null)
			return;

		TreePath path = new TreePath(tocModel.getPathToRoot(node));
		toc.expandPath(path);
		toc.setSelectionPath(path);
		toc.scrollPathToVisible(path);
	} 

	
	private HelpViewer helpViewer;
	private DefaultTreeModel tocModel;
	private DefaultMutableTreeNode tocRoot;
	private JTree toc;
	private Hashtable nodes;

	
	private DefaultMutableTreeNode createNode(String href, String title)
	{
		DefaultMutableTreeNode node = new DefaultMutableTreeNode(
			new HelpNode(href,title),true);
		nodes.put(href,node);
		return node;
	} 

	
	private void createTOC()
	{
		tocRoot = new DefaultMutableTreeNode();

		tocRoot.add(createNode(""welcome.html"",
			jEdit.getProperty(""helpviewer.toc.welcome"")));

		tocRoot.add(createNode(""README.txt"",
			jEdit.getProperty(""helpviewer.toc.readme"")));
		tocRoot.add(createNode(""NEWS.txt"",
			jEdit.getProperty(""helpviewer.toc.news"")));
		tocRoot.add(createNode(""CHANGES.txt"",
			jEdit.getProperty(""helpviewer.toc.changes"")));
		tocRoot.add(createNode(""TODO.txt"",
			jEdit.getProperty(""helpviewer.toc.todo"")));
		tocRoot.add(createNode(""COPYING.txt"",
			jEdit.getProperty(""helpviewer.toc.copying"")));
		tocRoot.add(createNode(""COPYING.DOC.txt"",
			jEdit.getProperty(""helpviewer.toc.copying-doc"")));

		loadTOC(tocRoot,""users-guide/toc.xml"");
		loadTOC(tocRoot,""FAQ/toc.xml"");
		loadTOC(tocRoot,""api/toc.xml"");

		DefaultMutableTreeNode pluginTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""helpviewer.toc.plugins""),true);

		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin plugin = plugins[i];
			EditPlugin.JAR jar = plugin.getJAR();
			if(jar == null)
				continue;

			String name = plugin.getClassName();

			String docs = jEdit.getProperty(""plugin."" + name + "".docs"");
			String label = jEdit.getProperty(""plugin."" + name + "".name"");
			if(docs != null)
			{
				if(label != null && docs != null)
				{
					URL url = jar.getClassLoader()
						.getResource(docs);
					if(url != null)
					{
						pluginTree.add(createNode(
							url.toString(),label));
					}
				}
			}
		}

		if(pluginTree.getChildCount() != 0)
			tocRoot.add(pluginTree);
		else
		{
			
			pluginTree = null;
		}

		tocModel = new DefaultTreeModel(tocRoot);
	} 

	
	private void loadTOC(DefaultMutableTreeNode root, String path)
	{
		TOCHandler h = new TOCHandler(root,MiscUtilities.getParentOfPath(path));
		XmlParser parser = new XmlParser();
		parser.setHandler(h);

		try
		{
			parser.parse(null, null, new InputStreamReader(
				new URL(helpViewer.getBaseURL()
				+ '/' + path).openStream()));
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,this,path + ':' + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.NOTICE,this,e);
		}
	} 

	

	
	static class HelpNode
	{
		String href, title;

		
		HelpNode(String href, String title)
		{
			this.href = href;
			this.title = title;
		} 

		
		public String toString()
		{
			return title;
		} 
	} 

	
	class TOCHandler extends HandlerBase
	{
		String dir;

		
		TOCHandler(DefaultMutableTreeNode root, String dir)
		{
			nodes = new Stack();
			node = root;
			this.dir = dir;
		} 

		
		public void attribute(String aname, String value, boolean isSpecified)
		{
			if(aname.equals(""HREF""))
				href = value;
		} 

		
		public void charData(char[] c, int off, int len)
		{
			if(tag.equals(""TITLE""))
			{
				StringBuffer buf = new StringBuffer();
				for(int i = 0; i < len; i++)
				{
					char ch = c[off + i];
					if(ch == ' ' || !Character.isWhitespace(ch))
						buf.append(ch);
				}
				title = buf.toString();
			}
		} 

		
		public void startElement(String name)
		{
			tag = name;
		} 

		
		public void endElement(String name)
		{
			if(name == null)
				return;

			if(name.equals(""TITLE""))
			{
				DefaultMutableTreeNode newNode = createNode(
					dir + href,title);
				node.add(newNode);
				nodes.push(node);
				node = newNode;
			}
			else if(name.equals(""ENTRY""))
				node = (DefaultMutableTreeNode)nodes.pop();
		} 

		
		private String tag;
		private String title;
		private String href;
		private DefaultMutableTreeNode node;
		private Stack nodes;
		
	} 

	
	class TOCTree extends JTree
	{
		
		TOCTree(TreeModel model)
		{
			super(model);
			ToolTipManager.sharedInstance().registerComponent(this);
		} 

		
		public final String getToolTipText(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
					return path.getLastPathComponent().toString();
			}
			return null;
		} 

		
		 

		
		protected void processMouseEvent(MouseEvent evt)
		{
			

			switch(evt.getID())
			{
			
			case MouseEvent.MOUSE_CLICKED:
				TreePath path = getPathForLocation(evt.getX(),evt.getY());
				if(path != null)
				{
					if(!isPathSelected(path))
						setSelectionPath(path);

					Object obj = ((DefaultMutableTreeNode)
						path.getLastPathComponent())
						.getUserObject();
					if(!(obj instanceof HelpNode))
					{
						this.expandPath(path);
						return;
					}

					HelpNode node = (HelpNode)obj;

					helpViewer.gotoURL(node.href,true);
				}

				super.processMouseEvent(evt);
				break;
			default:
				super.processMouseEvent(evt);
				break;
			}
		} 

		
		private int toolTipInitialDelay = -1;
		private int toolTipReshowDelay = -1;

		
		private boolean cellRectIsVisible(Rectangle cellRect)
		{
			Rectangle vr = TOCTree.this.getVisibleRect();
			return vr.contains(cellRect.x,cellRect.y) &&
				vr.contains(cellRect.x + cellRect.width,
				cellRect.y + cellRect.height);
		} 

		
	} 

	
	class TOCCellRenderer extends DefaultTreeCellRenderer
	{
		EmptyBorder border = new EmptyBorder(1,0,1,1);

		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean focus)
		{
			super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,focus);
			setIcon(leaf ? FileCellRenderer.fileIcon
				: (expanded ? FileCellRenderer.openDirIcon
				: FileCellRenderer.dirIcon));
			setBorder(border);

			return this;
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.search.AllBufferSet,4,2,0,7,20,0,1,6,3,0.0,79,1.0,0,0.7,0.5,1,1,18.5,3,1.25,0,"

package org.gjt.sp.jedit.search;


import gnu.regexp.*;
import java.awt.Component;
import java.util.ArrayList;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class AllBufferSet extends BufferListSet
{
	
	
	public AllBufferSet(String glob)
	{
		this.glob = glob;
	} 

	
	
	public String getFileFilter()
	{
		return glob;
	} 

	
	
	public String getCode()
	{
		return ""new AllBufferSet(\"""" + MiscUtilities.charsToEscapes(glob)
			+ ""\"")"";
	} 

	
	private String glob;
	

	
	protected String[] _getFiles(Component comp)
	{
		Buffer[] buffers = jEdit.getBuffers();
		ArrayList returnValue = new ArrayList(buffers.length);

		RE filter;
		try
		{
			filter = new RE(MiscUtilities.globToRE(glob));
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			return null;
		}

		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if(filter.isMatch(buffer.getName()))
				returnValue.add(buffer.getPath());
		}

		return (String[])returnValue.toArray(new String[returnValue.size()]);
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.UndoManager,14,1,0,8,32,29,6,7,11,0.653846154,485,1.0,3,0.0,0.223214286,0,0,33.07142857,8,3.5,1,"

package org.gjt.sp.jedit.buffer;


import java.util.ArrayList;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;



public class UndoManager
{
	
	public UndoManager(Buffer buffer)
	{
		this.buffer = buffer;
		undos = new ArrayList(100);
	} 

	
	public void setLimit(int limit)
	{
		this.limit = limit;
	} 

	
	public void clear()
	{
		undos.clear();
		undoPos = undoCount = 0;
	} 

	
	public boolean undo(JEditTextArea textArea)
	{
		if(insideCompoundEdit())
			throw new InternalError(""Unbalanced begin/endCompoundEdit()"");

		if(undoPos == 0)
			return false;
		else
		{
			Edit edit = (Edit)undos.get(--undoPos);
			int caret = edit.undo();
			if(caret != -1)
				textArea.setCaretPosition(caret);
			return true;
		}
	} 

	
	public boolean redo(JEditTextArea textArea)
	{
		if(insideCompoundEdit())
			throw new InternalError(""Unbalanced begin/endCompoundEdit()"");

		if(undoPos == undoCount)
			return false;
		else
		{
			Edit edit = (Edit)undos.get(undoPos++);
			int caret = edit.redo();
			if(caret != -1)
				textArea.setCaretPosition(caret);
			return true;
		}
	} 

	
	public void beginCompoundEdit()
	{
		if(compoundEditCount == 0)
			compoundEdit = new CompoundEdit();

		compoundEditCount++;
	} 

	
	public void endCompoundEdit()
	{
		if(compoundEditCount == 0)
		{
			Log.log(Log.WARNING,this,new Exception(""Unbalanced begin/endCompoundEdit()""));
			return;
		}
		else if(compoundEditCount == 1)
		{
			switch(compoundEdit.undos.size())
			{
			case 0:
				;
				break;
			case 1:
				addEdit((Edit)compoundEdit.undos.get(0));
				break;
			default:
				addEdit(compoundEdit);
			}

			compoundEdit = null;
		}

		compoundEditCount--;
	} 

	
	public boolean insideCompoundEdit()
	{
		return compoundEditCount != 0;
	} 

	
	public void contentInserted(int offset, int length, String text, boolean clearDirty)
	{
		Edit toMerge = getLastEdit();

		if(!clearDirty && toMerge instanceof Insert)
		{
			Insert ins = (Insert)toMerge;
			if(ins.offset == offset)
			{
				ins.str = text.concat(ins.str);
				ins.length += length;
				return;
			}
			else if(ins.offset + ins.length == offset)
			{
				ins.str = ins.str.concat(text);
				ins.length += length;
				return;
			}
		}

		Insert ins = new Insert(offset,length,text,clearDirty);
		if(clearDirty)
		{
			if(clearDirtyEdit != null)
				clearDirtyEdit.clearDirty = false;
			clearDirtyEdit = ins;
		}

		if(compoundEdit != null)
			compoundEdit.undos.add(ins);
		else
			addEdit(ins);
	} 

	
	public void contentRemoved(int offset, int length, String text, boolean clearDirty)
	{
		Edit toMerge = getLastEdit();

		if(!clearDirty && toMerge instanceof Remove)
		{
			Remove rem = (Remove)toMerge;
			if(rem.offset == offset)
			{
				rem.str = rem.str.concat(text);
				rem.length += length;
				return;
			}
			else if(offset + length == rem.offset)
			{
				rem.str = text.concat(rem.str);
				rem.length += length;
				rem.offset = offset;
				return;
			}
		}

		Remove rem = new Remove(offset,length,text,clearDirty);
		if(clearDirty)
		{
			if(clearDirtyEdit != null)
				clearDirtyEdit.clearDirty = false;
			clearDirtyEdit = rem;
		}

		if(compoundEdit != null)
			compoundEdit.undos.add(rem);
		else
			addEdit(rem);
	} 

	
	public void bufferSaved()
	{
		if(clearDirtyEdit != null)
		{
			clearDirtyEdit.clearDirty = false;
			clearDirtyEdit = null;
		}
	} 

	

	
	private Buffer buffer;
	private ArrayList undos;
	private int limit;
	private int undoPos;
	private int undoCount;
	private int compoundEditCount;
	private CompoundEdit compoundEdit;
	private Edit clearDirtyEdit;
	

	
	private void addEdit(Edit edit)
	{
		
		undos.add(undoPos++,edit);

		for(int i = undoCount - 1; i >= undoPos; i--)
		{
			
			undos.remove(i);
		}

		if(undoPos > limit)
		{
			
			undos.remove(0);
			undoPos--;
		}

		undoCount = undoPos;
	} 

	
	private Edit getLastEdit()
	{
		if(compoundEdit != null)
		{
			int size = compoundEdit.undos.size();
			if(size != 0)
				return (Edit)compoundEdit.undos.get(size - 1);
			else
				return null;
		}
		else if(undoCount != 0 && undoPos != 0)
		{
			Edit e = (Edit)undos.get(undoPos - 1);
			if(e instanceof CompoundEdit)
			{
				CompoundEdit c = (CompoundEdit)e;
				return (Edit)c.undos.get(c.undos.size() - 1);
			}
		}

		if(undoPos != 0)
			return (Edit)undos.get(undoPos - 1);
		else
			return null;
	} 

	

	

	
	abstract class Edit
	{
		
		abstract int undo();
		

		
		abstract int redo();
		

		boolean clearDirty;
	} 

	
	class Insert extends Edit
	{
		
		Insert(int offset, int length, String str, boolean clearDirty)
		{
			this.offset = offset;
			this.length = length;
			this.str = str;
			this.clearDirty = clearDirty;
		} 

		
		int undo()
		{
			buffer.remove(offset,length);
			if(clearDirty)
				buffer.setDirty(false);
			return offset;
		} 

		
		int redo()
		{
			buffer.insert(offset,str);
			return offset + length;
		} 

		int offset;
		int length;
		String str;
	} 

	
	class Remove extends Edit
	{
		
		Remove(int offset, int length, String str, boolean clearDirty)
		{
			this.offset = offset;
			this.length = length;
			this.str = str;
			this.clearDirty = clearDirty;
		} 

		
		int undo()
		{
			buffer.insert(offset,str);
			if(clearDirty)
				buffer.setDirty(false);
			return offset + length;
		} 

		
		int redo()
		{
			buffer.remove(offset,length);
			return offset;
		} 

		int offset;
		int length;
		String str;
	} 

	
	class CompoundEdit extends Edit
	{
		
		public int undo()
		{
			int retVal = -1;
			for(int i = undos.size() - 1; i >= 0; i--)
			{
				retVal = ((Edit)undos.get(i)).undo();
			}
			return retVal;
		} 

		
		public int redo()
		{
			int retVal = -1;
			for(int i = 0; i < undos.size(); i++)
			{
				retVal = ((Edit)undos.get(i)).redo();
			}
			return retVal;
		} 

		ArrayList undos = new ArrayList();
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.BufferSwitcher,4,5,0,6,17,0,4,5,2,0.5,61,1.0,1,0.995856354,0.416666667,0,0,13.75,2,1.0,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;

public class BufferSwitcher extends JComboBox
{
	public BufferSwitcher(EditPane editPane)
	{
		this.editPane = editPane;

		
		setRenderer(new BufferCellRenderer());
		setMaximumRowCount(jEdit.getIntegerProperty(""bufferSwitcher.maxRowCount"",10));
		addActionListener(new ActionHandler());
	}

	public void updateBufferList()
	{
		
		
		if(jEdit.getBufferCount() == 0)
			return;

		updating = true;
		setMaximumRowCount(jEdit.getIntegerProperty(""bufferSwitcher.maxRowCount"",10));
		setModel(new DefaultComboBoxModel(jEdit.getBuffers()));
		setSelectedItem(editPane.getBuffer());
		updating = false;
	}

	
	private EditPane editPane;
	private boolean updating;

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(!updating)
			{
				Buffer buffer = (Buffer)getSelectedItem();
				if(buffer != null)
					editPane.setBuffer(buffer);
			}
		}
	}

	class BufferCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);
			Buffer buffer = (Buffer)value;
			if(buffer == null)
				setIcon(null);
			else
				setIcon(buffer.getIcon());
			return this;
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.OffsetManager,27,1,0,7,39,87,3,6,19,0.873931624,1342,1.0,3,0.0,0.230452675,0,0,48.03703704,15,3.9259,1,"

package org.gjt.sp.jedit.buffer;


import javax.swing.text.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.IntegerArray;
import org.gjt.sp.util.Log;



public class OffsetManager
{
	
	public OffsetManager(Buffer buffer)
	{
		this.buffer = buffer;

		lineInfo = new long[1];
		
		lineInfo[0] = 1L | (0xffL << VISIBLE_SHIFT);
		lineContext = new TokenMarker.LineContext[1];
		lineCount = 1;

		positions = new PosBottomHalf[100];

		virtualLineCounts = new int[8];
		for(int i = 0; i < 8; i++)
			virtualLineCounts[i] = 1;

		gapLine = -1;
	} 

	
	public final int getLineCount()
	{
		return lineCount;
	} 

	
	public final int getVirtualLineCount(int index)
	{
		return virtualLineCounts[index];
	} 

	
	public final void setVirtualLineCount(int index, int lineCount)
	{
		virtualLineCounts[index] = lineCount;
	} 

	
	public int getLineOfOffset(int offset)
	{
		int start = 0;
		int end = lineCount - 1;

		for(;;)
		{
			switch(end - start)
			{
			case 0:
				if(getLineEndOffset(start) <= offset)
					return start + 1;
				else
					return start;
			case 1:
				if(getLineEndOffset(start) <= offset)
				{
					if(getLineEndOffset(end) <= offset)
						return end + 1;
					else
						return end;
				}
				else
					return start;
			default:
				int pivot = (end + start) / 2;
				int value = getLineEndOffset(pivot);
				if(value == offset)
					return pivot + 1;
				else if(value < offset)
					start = pivot + 1;
				else
					end = pivot - 1;
				break;
			}
		}
	} 

	
	public final int getLineEndOffset(int line)
	{
		int end = (int)(lineInfo[line] & END_MASK);
		if(gapLine != -1 && line >= gapLine)
			return end + gapWidth;
		else
			return end;
	} 

	
	public final boolean isFoldLevelValid(int line)
	{
		if(gapLine != -1 && line >= gapLine)
			return false;

		return (lineInfo[line] & FOLD_LEVEL_VALID_MASK) != 0;
	} 

	
	public final int getFoldLevel(int line)
	{
		return (int)((lineInfo[line] & FOLD_LEVEL_MASK)
			>> FOLD_LEVEL_SHIFT);
	} 

	
	
	public final void setFoldLevel(int line, int level)
	{
		if(gapLine != -1 && line >= gapLine)
			moveGap(line + 1,0,""setFoldLevel"");

		lineInfo[line] = ((lineInfo[line] & ~FOLD_LEVEL_MASK)
			| ((long)level << FOLD_LEVEL_SHIFT)
			| FOLD_LEVEL_VALID_MASK);
	} 

	
	public final boolean isLineVisible(int line, int index)
	{
		long mask = 1L << (index + VISIBLE_SHIFT);
		return (lineInfo[line] & mask) != 0;
	} 

	
	public final void setLineVisible(int line, int index, boolean visible)
	{
		long mask = 1L << (index + VISIBLE_SHIFT);
		if(visible)
			lineInfo[line] = (lineInfo[line] | mask);
		else
			lineInfo[line] = (lineInfo[line] & ~mask);
	} 

	

	
	public final boolean isLineContextValid(int line)
	{
		if(gapLine != -1 && line >= gapLine)
			return false;

		return (lineInfo[line] & CONTEXT_VALID_MASK) != 0;
	} 

	
	public final TokenMarker.LineContext getLineContext(int line)
	{
		return lineContext[line];
	} 

	
	
	public final void setLineContext(int line, TokenMarker.LineContext context)
	{
		if(gapLine != -1 && line >= gapLine)
			moveGap(line + 1,0,""setLineContext"");

		lineContext[line] = context;
		lineInfo[line] |= CONTEXT_VALID_MASK;
	} 

	

	
	
	
	

	
	
	
	
	public synchronized Position createPosition(int offset)
	{
		PosBottomHalf bh = null;

		for(int i = 0; i < positionCount; i++)
		{
			PosBottomHalf _bh = positions[i];
			if(_bh.offset == offset)
			{
				bh = _bh;
				break;
			}
			else if(_bh.offset > offset)
			{
				bh = new PosBottomHalf(offset);
				growPositionArray();
				System.arraycopy(positions,i,positions,i+1,
					positionCount - i);
				positionCount++;
				positions[i] = bh;
				break;
			}
		}

		if(bh == null)
		{
			bh = new PosBottomHalf(offset);
			growPositionArray();
			positions[positionCount++] = bh;
		}

		return new PosTopHalf(bh);
	} 

	
	
	public void expandFolds(int foldLevel)
	{
		int newVirtualLineCount = 0;

		if(foldLevel == 0)
		{
			newVirtualLineCount = lineCount;

			for(int i = 0; i < lineCount; i++)
				lineInfo[i] |= VISIBLE_MASK;
		}
		else
		{
			foldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;

			
			boolean seenVisibleLine = false;

			for(int i = 0; i < lineCount; i++)
			{
				if(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)
				{
					seenVisibleLine = true;
					lineInfo[i] |= VISIBLE_MASK;
					newVirtualLineCount++;
				}
				else
					lineInfo[i] &= ~VISIBLE_MASK;
			}
		}

		for(int i = 0; i < virtualLineCounts.length; i++)
		{
			virtualLineCounts[i] = newVirtualLineCount;
		}
	} 

	
	public void contentInserted(int startLine, int offset,
		int numLines, int length, IntegerArray endOffsets)
	{
		int endLine = startLine + numLines;

		
		if(numLines > 0)
		{
			moveGap(-1,0,""contentInserted"");

			lineCount += numLines;

			if(lineInfo.length <= lineCount)
			{
				long[] lineInfoN = new long[(lineCount + 1) * 2];
				System.arraycopy(lineInfo,0,lineInfoN,0,
						 lineInfo.length);
				lineInfo = lineInfoN;

				TokenMarker.LineContext[] lineContextN
					= new TokenMarker.LineContext[(lineCount + 1) * 2];
				System.arraycopy(lineContext,0,lineContextN,0,
						 lineContext.length);
				lineContext = lineContextN;
			}

			System.arraycopy(lineInfo,startLine,lineInfo,
				endLine,lineCount - endLine);
			System.arraycopy(lineContext,startLine,lineContext,
				endLine,lineCount - endLine);

			
			int foldLevel = buffer.getFoldLevel(startLine);
			long visible = (0xffL << VISIBLE_SHIFT);
			if(startLine != 0)
			{
				for(int i = startLine; i > 0; i--)
				{
					if( buffer.getFoldLevel(i) <= foldLevel)
					{
						visible = (lineInfo[i] & VISIBLE_MASK);
						break;
					}
				}
			} 

			for(int i = 0; i < numLines; i++)
			{
				
				
				lineInfo[startLine + i] = (offset
					+ endOffsets.get(i) + 1)
					| visible;
			}

			
			if((visible & (1L << (VISIBLE_SHIFT + 0))) != 0)
				virtualLineCounts[0] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 1))) != 0)
				virtualLineCounts[1] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 2))) != 0)
				virtualLineCounts[2] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 3))) != 0)
				virtualLineCounts[3] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 4))) != 0)
				virtualLineCounts[4] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 5))) != 0)
				virtualLineCounts[5] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 6))) != 0)
				virtualLineCounts[6] += numLines;
			if((visible & (1L << (VISIBLE_SHIFT + 7))) != 0)
				virtualLineCounts[7] += numLines;
			
		} 

		moveGap(endLine,length,""contentInserted"");

		updatePositionsForInsert(offset,length);
	} 

	
	public void contentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		
		for(int i = 0; i < numLines; i++)
		{
			long info = lineInfo[startLine + i];

			
			if((info & (1L << (VISIBLE_SHIFT + 0))) != 0)
				virtualLineCounts[0]--;
			if((info & (1L << (VISIBLE_SHIFT + 1))) != 0)
				virtualLineCounts[1]--;
			if((info & (1L << (VISIBLE_SHIFT + 2))) != 0)
				virtualLineCounts[2]--;
			if((info & (1L << (VISIBLE_SHIFT + 3))) != 0)
				virtualLineCounts[3]--;
			if((info & (1L << (VISIBLE_SHIFT + 4))) != 0)
				virtualLineCounts[4]--;
			if((info & (1L << (VISIBLE_SHIFT + 5))) != 0)
				virtualLineCounts[5]--;
			if((info & (1L << (VISIBLE_SHIFT + 6))) != 0)
				virtualLineCounts[6]--;
			if((info & (1L << (VISIBLE_SHIFT + 7))) != 0)
				virtualLineCounts[7]--;
		} 

		
		if(numLines > 0)
		{
			moveGap(-1,0,""contentRemoved"");

			lineCount -= numLines;
			System.arraycopy(lineInfo,startLine + numLines,lineInfo,
				startLine,lineCount - startLine);
			System.arraycopy(lineContext,startLine + numLines,lineContext,
				startLine,lineCount - startLine);
		} 

		moveGap(startLine,-length,""contentRemoved"");

		updatePositionsForRemove(offset,length);
	} 

	
	public void lineInfoChangedFrom(int startLine)
	{
		moveGap(startLine,0,""lineInfoChangedFrom"");
	} 

	

	
	private static final long END_MASK = 0x00000000ffffffffL;
	private static final long FOLD_LEVEL_MASK = 0x0000ffff00000000L;
	private static final int FOLD_LEVEL_SHIFT = 32;
	private static final long VISIBLE_MASK = 0x00ff000000000000L;
	private static final int VISIBLE_SHIFT = 48;
	private static final long FOLD_LEVEL_VALID_MASK = (1L<<56);
	private static final long CONTEXT_VALID_MASK = (1L<<57);
	private static final long SCREEN_LINES_MASK = 0x7c00000000000000L;
	private static final long SCREEN_LINES_SHIFT = 58;

	
	private Buffer buffer;
	private long[] lineInfo;
	private TokenMarker.LineContext[] lineContext;

	private int lineCount;

	private PosBottomHalf[] positions;
	private int positionCount;

	private int[] virtualLineCounts;

	
	private int gapLine;
	private int gapWidth;
	

	
	private final void setLineEndOffset(int line, int end)
	{
		lineInfo[line] = ((lineInfo[line] & ~(END_MASK
			| FOLD_LEVEL_VALID_MASK | CONTEXT_VALID_MASK)) | end);
		
		
		
	} 

	
	private final void moveGap(int newGapLine, int newGapWidth, String method)
	{
		if(gapLine == -1)
			gapWidth = newGapWidth;
		else if(newGapLine == -1)
		{
			
			{
				
				
				for(int i = gapLine; i < lineCount; i++)
					setLineEndOffset(i,getLineEndOffset(i));
			}

			gapWidth = newGapWidth;
		}
		else if(newGapLine < gapLine)
		{
			
			{
				
				
				for(int i = newGapLine; i < gapLine; i++)
					setLineEndOffset(i,getLineEndOffset(i) - gapWidth);
			}
			gapWidth += newGapWidth;
		}
		else 
		{
			
			{
				
				
				for(int i = gapLine; i < newGapLine; i++)
					setLineEndOffset(i,getLineEndOffset(i));
			}

			gapWidth += newGapWidth;
		}

		if(newGapLine == lineCount)
			gapLine = -1;
		else
			gapLine = newGapLine;
	} 

	
	private void growPositionArray()
	{
		if(positions.length < positionCount + 1)
		{
			PosBottomHalf[] newPositions = new PosBottomHalf[
				(positionCount + 1) * 2];
			System.arraycopy(positions,0,newPositions,0,positionCount);
			positions = newPositions;
		}
	} 

	
	private synchronized void removePosition(PosBottomHalf bh)
	{
		int index = -1;

		for(int i = 0; i < positionCount; i++)
		{
			if(positions[i] == bh)
			{
				index = i;
				break;
			}
		}

		System.arraycopy(positions,index + 1,positions,index,
			positionCount - index - 1);
		positions[--positionCount] = null;
	} 

	
	private void updatePositionsForInsert(int offset, int length)
	{
		if(positionCount == 0)
			return;

		int start = getPositionAtOffset(offset);

		for(int i = start; i < positionCount; i++)
		{
			PosBottomHalf bh = positions[i];
			if(bh.offset < offset)
				Log.log(Log.ERROR,this,""Screwed up: "" + bh.offset);
			else
				bh.offset += length;
		}
	} 

	
	private void updatePositionsForRemove(int offset, int length)
	{
		if(positionCount == 0)
			return;

		int start = getPositionAtOffset(offset);

		for(int i = start; i < positionCount; i++)
		{
			PosBottomHalf bh = positions[i];
			if(bh.offset < offset)
				Log.log(Log.ERROR,this,""Screwed up: "" + bh.offset);
			else if(bh.offset < offset + length)
				bh.offset = offset;
			else
				bh.offset -= length;
		}
	} 

	
	private int getPositionAtOffset(int offset)
	{
		int start = 0;
		int end = positionCount - 1;

		PosBottomHalf bh;

loop:		for(;;)
		{
			switch(end - start)
			{
			case 0:
				bh = positions[start];
				if(bh.offset < offset)
					start++;
				break loop;
			case 1:
				bh = positions[end];
				if(bh.offset < offset)
				{
					start = end + 1;
				}
				else
				{
					bh = positions[start];
					if(bh.offset < offset)
					{
						start++;
					}
				}
				break loop;
			default:
				int pivot = (start + end) / 2;
				bh = positions[pivot];
				if(bh.offset > offset)
					end = pivot - 1;
				else
					start = pivot + 1;
				break;
			}
		}

		return start;
	} 

	

	

	
	static class PosTopHalf implements Position
	{
		PosBottomHalf bh;

		
		PosTopHalf(PosBottomHalf bh)
		{
			this.bh = bh;
			bh.ref();
		} 

		
		public int getOffset()
		{
			return bh.offset;
		} 

		
		public void finalize()
		{
			bh.unref();
		} 
	} 

	
	class PosBottomHalf
	{
		int offset;
		int ref;

		
		PosBottomHalf(int offset)
		{
			this.offset = offset;
		} 

		
		void ref()
		{
			ref++;
		} 

		
		void unref()
		{
			if(--ref == 0)
				removePosition(this);
		} 
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.TokenHandler,1,1,0,8,1,0,7,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.syntax;


public interface TokenHandler
{
	
	public void handleToken(byte id, int offset, int length,
		TokenMarker.LineContext context);
}
"
jEdit,4.1,org.gjt.sp.jedit.msg.MacrosChanged,1,2,0,4,2,0,2,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class MacrosChanged extends EBMessage
{
	
	public MacrosChanged(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.search.CharIndexedSegment,6,1,0,4,7,0,3,1,6,0.133333333,118,1.0,0,0.0,0.5,0,0,18.16666667,4,2.0,0,"
package org.gjt.sp.jedit.search;


import java.io.Serializable;
import javax.swing.text.Segment;
import gnu.regexp.*;



public class CharIndexedSegment implements CharIndexed, Serializable
{
	
	
	public CharIndexedSegment(Segment seg, int index)
	{
		this.seg = seg;
		m_index = index;
	} 

	
	
	public CharIndexedSegment(Segment seg, boolean reverse)
	{
		this.seg = seg;
		m_index = (reverse ? seg.count - 1 : 0);
		this.reverse = reverse;
	} 

	
	public char charAt(int index)
	{
		if(reverse)
			index = -index;

		return ((m_index + index) < seg.count && m_index + index >= 0)
			? seg.array[seg.offset + m_index + index]
			: CharIndexed.OUT_OF_BOUNDS;
	} 

	
	public boolean isValid()
	{
		return (m_index >=0 && m_index < seg.count);
	} 

	
	public void reset()
	{
		m_index = (reverse ? seg.count - 1 : 0);
	} 

	
	public boolean move(int index)
	{
		if(reverse)
			index = -index;

		return ((m_index += index) < seg.count);
	} 

	
	private Segment seg;
	private int m_index;
	private boolean reverse;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.pluginmgr.PluginManagerProgress,19,6,0,12,60,125,11,8,7,0.916666667,336,1.0,1,0.97309417,0.197368421,3,6,16.15789474,3,1.0526,0,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


class PluginManagerProgress extends JDialog
{
	
	public PluginManagerProgress(JDialog dialog, String type, Roster roster)
	{
		super(dialog,
			jEdit.getProperty(""plugin-manager.progress.""
			+ type + ""-task""),true);

		this.dialog = dialog;
		this.roster = roster;
		this.type = type;

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		progress = new JProgressBar();
		progress.setStringPainted(true);
		progress.setString(jEdit.getProperty(""plugin-manager.progress.""
			+ type + ""-task""));

		int maximum = 0;
		count = roster.getOperationCount();
		for(int i = 0; i < count; i++)
		{
			maximum += roster.getOperation(i).getMaximum();
		}

		progress.setMaximum(maximum);
		content.add(BorderLayout.CENTER,progress);

		stop = new JButton(jEdit.getProperty(""plugin-manager.progress.stop""));
		stop.addActionListener(new ActionHandler());
		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.add(Box.createGlue());
		panel.add(stop);
		panel.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,panel);

		addWindowListener(new WindowHandler());

		pack();

		Dimension size = getSize();
		size.width = Math.max(size.width,500);
		setSize(size);
		setLocationRelativeTo(dialog);

		show();
	} 

	
	public void removing(String plugin)
	{
		String[] args = { plugin };
		showMessage(jEdit.getProperty(""plugin-manager.progress.removing"",args));
		stop.setEnabled(true);
	} 

	
	public void downloading(String plugin)
	{
		String[] args = { plugin };
		showMessage(jEdit.getProperty(""plugin-manager.progress.downloading"",args));
		stop.setEnabled(true);
	} 

	
	public void installing(String plugin)
	{
		String[] args = { plugin };
		showMessage(jEdit.getProperty(""plugin-manager.progress.installing"",args));
		stop.setEnabled(false);
	} 

	
	public void setValue(final int value)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				progress.setValue(valueSoFar + value);
			}
		});
	} 

	
	public void done(final boolean ok)
	{
		this.ok |= ok;

		try
		{
			if(!ok || done == count)
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						dispose();
						if(ok)
						{
							GUIUtilities.message(dialog,
								""plugin-manager."" + type
								+ ""-done"",null);
						}
						else
						{
							

							
							
						}
					}
				});
			}
			else
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						valueSoFar += roster.getOperation(done - 1)
							.getMaximum();
						progress.setValue(valueSoFar);
						done++;
					}
				});
			}
		}
		catch(Exception e)
		{
		}
	} 

	
	public boolean isOK()
	{
		return ok;
	} 

	

	
	private JDialog dialog;

	private Thread thread;

	private String type;

	private JProgressBar progress;
	private JButton stop;
	private int count;
	private int done = 1;

	
	private int valueSoFar;

	private boolean ok;

	private Roster roster;
	

	
	private void showMessage(final String msg)
	{
		
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == stop)
			{
				thread.stop();
				dispose();
			}
		}
	} 

	
	class WindowHandler extends WindowAdapter
	{
		boolean done;

		public void windowOpened(WindowEvent evt)
		{
			if(done)
				return;

			done = true;
			thread = new RosterThread();
			thread.start();
		}

		public void windowClosing(WindowEvent evt)
		{
			thread.stop();
			dispose();
		}
	} 

	
	class RosterThread extends Thread
	{
		RosterThread()
		{
			super(""Plugin manager thread"");
		}

		public void run()
		{
			roster.performOperations(PluginManagerProgress.this);
		}
	} 

	

}
"
jEdit,4.1,org.gjt.sp.jedit.gui.AddAbbrevDialog,5,6,0,7,34,2,3,6,1,0.8,202,1.0,2,0.99389313,0.35,0,0,38.4,1,0.8,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;

public class AddAbbrevDialog extends JDialog
{
	public AddAbbrevDialog(View view, String abbrev)
	{
		super(view,jEdit.getProperty(""add-abbrev.title""),true);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		editor = new AbbrevEditor();
		editor.setAbbrev(abbrev);
		editor.setBorder(new EmptyBorder(6,0,12,0));
		content.add(BorderLayout.CENTER,editor);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		global = new JButton(jEdit.getProperty(""add-abbrev.global""));
		global.addActionListener(new ActionHandler());
		box.add(global);
		box.add(Box.createHorizontalStrut(6));
		modeSpecific = new JButton(jEdit.getProperty(""add-abbrev.mode""));
		modeSpecific.addActionListener(new ActionHandler());
		box.add(modeSpecific);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);

		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		if(abbrev == null)
			GUIUtilities.requestFocus(this,editor.getAbbrevField());
		else
			GUIUtilities.requestFocus(this,editor.getBeforeCaretTextArea());

		pack();
		setLocationRelativeTo(view);
		show();
	}

	
	private View view;
	private AbbrevEditor editor;
	private JButton global;
	private JButton modeSpecific;
	private JButton cancel;

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == global)
			{
				String _abbrev = editor.getAbbrev();
				if(_abbrev == null || _abbrev.length() == 0)
				{
					getToolkit().beep();
					return;
				}
				Abbrevs.addGlobalAbbrev(_abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}
			else if(source == modeSpecific)
			{
				String _abbrev = editor.getAbbrev();
				if(_abbrev == null || _abbrev.length() == 0)
				{
					getToolkit().beep();
					return;
				}
				Abbrevs.addModeAbbrev(view.getBuffer().getMode().getName(),
					_abbrev,editor.getExpansion());
				Abbrevs.expandAbbrev(view,false);
			}

			dispose();
		}
	}

	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.proto.jeditresource.Handler,2,2,0,1,5,1,0,1,2,2.0,14,0.0,0,0.923076923,0.75,0,0,6.0,1,0.5,0,"

package org.gjt.sp.jedit.proto.jeditresource;

import java.io.IOException;
import java.net.*;

public class Handler extends URLStreamHandler
{
	public URLConnection openConnection(URL url)
		throws IOException
	{
		PluginResURLConnection c = new PluginResURLConnection(url);
		c.connect();
		return c;
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.FoldHandler,11,1,3,7,29,33,6,5,8,0.633333333,141,0.666666667,0,0.0,0.185714286,0,0,11.54545455,3,1.4545,1,"

package org.gjt.sp.jedit.buffer;

import java.util.*;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;


public abstract class FoldHandler
{
	
	
	public String getName()
	{
		return name;
	}
	

	
	
	public abstract int getFoldLevel(Buffer buffer, int lineIndex, Segment seg);
	

	
	
	public boolean equals(Object o)
	{
		
		if(o == null)
			return false;
		else
			return getClass() == o.getClass();
	} 

	
	
	public static void registerFoldHandler(FoldHandler handler)
	{
		if (getFoldHandler(handler.getName()) != null)
		{
			Log.log(Log.ERROR, FoldHandler.class, ""Cannot register more than one fold handler with the same name"");
			return;
		}

		foldHandlers.add(handler);
	}
	

	
	
	public static void unregisterFoldHandler(FoldHandler handler)
	{
		foldHandlers.remove(handler);
	}
	

	
	
	public static FoldHandler[] getFoldHandlers()
	{
		FoldHandler[] handlers = new FoldHandler[foldHandlers.size()];
		return (FoldHandler[])foldHandlers.toArray(handlers);
	}
	

	
	
	public static FoldHandler getFoldHandler(String name)
	{
		FoldHandler handler;

		Iterator i = foldHandlers.iterator();
		while (i.hasNext())
		{
			handler = (FoldHandler)i.next();
			if (name.equals(handler.getName())) return handler;
		}

		return null;
	}
	

	
	
	public static String[] getFoldModes()
	{
		FoldHandler[] handlers = getFoldHandlers();
		String[] foldModes = new String[handlers.length];

		for (int i = 0; i < foldModes.length; i++)
		{
			foldModes[i] = handlers[i].getName();
		}

		return foldModes;
	}
	

	
	protected FoldHandler(String name)
	{
		this.name = name;
	}
	

	
	private String name;

	private static ArrayList foldHandlers;
	

	
	static
	{
		foldHandlers = new ArrayList();
		registerFoldHandler(new DummyFoldHandler());
		registerFoldHandler(new IndentFoldHandler());
		registerFoldHandler(new ExplicitFoldHandler());
	}
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.HistoryModel,9,1,0,12,45,8,10,3,8,0.6875,294,0.833333333,0,0.0,0.333333333,0,0,31.0,10,3.0,2,"

package org.gjt.sp.jedit.gui;


import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.MiscUtilities;
import org.gjt.sp.util.Log;



public class HistoryModel
{
	
	
	public HistoryModel(String name)
	{
		this.name = name;

		max = jEdit.getIntegerProperty(""history"",25);
		data = new Vector(max);
	} 

	
	
	public void addItem(String text)
	{
		if(text == null || text.length() == 0)
			return;

		int index = data.indexOf(text);
		if(index != -1)
			data.removeElementAt(index);

		data.insertElementAt(text,0);

		while(getSize() > max)
			data.removeElementAt(data.size() - 1);
	} 

	
	
	public String getItem(int index)
	{
		return (String)data.elementAt(index);
	} 

	
	
	public int getSize()
	{
		return data.size();
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public static HistoryModel getModel(String name)
	{
		if(models == null)
			models = new Hashtable();

		HistoryModel model = (HistoryModel)models.get(name);
		if(model == null)
		{
			model = new HistoryModel(name);
			models.put(name,model);
		}

		return model;
	} 

	
	
	public static void loadHistory(File file)
	{
		if(models == null)
			models = new Hashtable();

		try
		{
			BufferedReader in = new BufferedReader(new FileReader(file));

			HistoryModel currentModel = null;
			String line;

			while((line = in.readLine()) != null)
			{
				if(line.startsWith(""["") && line.endsWith(""]""))
				{
					if(currentModel != null)
					{
						models.put(currentModel.getName(),
							currentModel);
					}
					currentModel = new HistoryModel(line
						.substring(1,line.length() - 1));
				}
				else if(currentModel == null)
				{
					throw new IOException(""History data starts""
						+ "" before model name"");
				}
				else
				{
					currentModel.data.addElement(MiscUtilities
						.escapesToChars(line));
				}
			}

			if(currentModel != null)
			{
				models.put(currentModel.getName(),currentModel);
			}

			in.close();
		}
		catch(FileNotFoundException fnf)
		{
			Log.log(Log.DEBUG,HistoryModel.class,fnf);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
	} 

	
	
	public static void saveHistory(File file)
	{
		String lineSep = System.getProperty(""line.separator"");
		try
		{
			BufferedWriter out = new BufferedWriter(
				new FileWriter(file));

			if(models == null)
			{
				out.close();
				return;
			}

			Enumeration modelEnum = models.elements();
			while(modelEnum.hasMoreElements())
			{
				HistoryModel model = (HistoryModel)modelEnum
					.nextElement();

				out.write('[');
				out.write(model.getName());
				out.write(']');
				out.write(lineSep);

				for(int i = 0; i < model.getSize(); i++)
				{
					out.write(MiscUtilities.charsToEscapes(
						model.getItem(i),
						TO_ESCAPE));
					out.write(lineSep);
				}
			}

			out.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,HistoryModel.class,io);
		}
	} 

	
	private static final String TO_ESCAPE = ""\n\t\\\""'[]"";
	private String name;
	private int max;
	private Vector data;
	private static Hashtable models;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.TextUtilities,15,1,0,12,50,105,8,5,14,1.071428571,913,0.428571429,0,0.0,0.237037037,0,0,59.4,29,7.2667,0,"

package org.gjt.sp.jedit;


import java.util.*;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.syntax.*;



public class TextUtilities
{
	
	
	public static Token getTokenAtOffset(Token tokens, int offset)
	{
		if(offset == 0 && tokens.id == Token.END)
			return tokens;

		for(;;)
		{
			if(tokens.id == Token.END)
				throw new ArrayIndexOutOfBoundsException(""offset > line length"");

			if(tokens.offset + tokens.length > offset)
				return tokens;
			else
				tokens = tokens.next;
		}
	} 

	
	
	public static int findMatchingBracket(Buffer buffer, int line, int offset)
	{
		if(offset < 0 || offset >= buffer.getLineLength(line))
		{
			throw new ArrayIndexOutOfBoundsException(offset + "":""
				+ buffer.getLineLength(line));
		}

		Segment lineText = new Segment();
		buffer.getLineText(line,lineText);

		char c = lineText.array[lineText.offset + offset];
		char cprime; 
		boolean direction; 

		switch(c)
		{
		case '(': cprime = ')'; direction = true;  break;
		case ')': cprime = '('; direction = false; break;
		case '[': cprime = ']'; direction = true;  break;
		case ']': cprime = '['; direction = false; break;
		case '{': cprime = '}'; direction = true;  break;
		case '}': cprime = '{'; direction = false; break;
		default: return -1;
		}

		
		int count = 1;

		DefaultTokenHandler tokenHandler = new DefaultTokenHandler();
		buffer.markTokens(line,tokenHandler);

		
		
		
		byte idOfBracket = getTokenAtOffset(tokenHandler.getTokens(),offset).id;

		boolean haveTokens = true;

		
		if(direction)
		{
			offset++;

			for(;;)
			{
				for(int i = offset; i < lineText.count; i++)
				{
					char ch = lineText.array[lineText.offset + i];
					if(ch == c)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
							count++;
					}
					else if(ch == cprime)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
						{
							count--;
							if(count == 0)
								return buffer.getLineStartOffset(line) + i;
						}
					}
				}

				
				line++;
				if(line >= buffer.getLineCount())
					break;
				buffer.getLineText(line,lineText);
				offset = 0;
				haveTokens = false;
				
			}
		} 
		
		else
		{
			offset--;

			for(;;)
			{
				for(int i = offset; i >= 0; i--)
				{
					char ch = lineText.array[lineText.offset + i];
					if(ch == c)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
							count++;
					}
					else if(ch == cprime)
					{
						if(!haveTokens)
						{
							tokenHandler.init();
							buffer.markTokens(line,tokenHandler);
							haveTokens = true;
						}
						if(getTokenAtOffset(tokenHandler.getTokens(),i).id == idOfBracket)
						{
							count--;
							if(count == 0)
								return buffer.getLineStartOffset(line) + i;
						}
					}
				}

				
				line--;
				if(line < 0)
					break;
				buffer.getLineText(line,lineText);
				offset = lineText.count - 1;
				haveTokens = false;
				
			}
		} 

		
		return -1;
	} 

	
	
	public static int findMatchingBracketFuzzy(Buffer buffer, int line, int offset)
	{
		int result = findMatchingBracket(buffer,line,offset);
		if((result == -1)&&(offset + 1 < buffer.getLineLength(line)))
		{
			return findMatchingBracket(buffer,line,offset + 1);
		}
		else{
			return result;	
		}
	} 

	
	
	public static int findWordStart(String line, int pos, String noWordSep)
	{
		return findWordStart(line, pos, noWordSep, true);
	} 

	
	
	public static int findWordStart(String line, int pos, String noWordSep,
					boolean joinNonWordChars)
	{
		char ch = line.charAt(pos);

		if(noWordSep == null)
			noWordSep = """";

		
		int type;
		if(Character.isWhitespace(ch))
			type = WHITESPACE;
		else if(Character.isLetterOrDigit(ch)
			|| noWordSep.indexOf(ch) != -1)
			type = WORD_CHAR;
		else
			type = SYMBOL;
		

		int whiteSpaceEnd = 0;
loop:		for(int i = pos; i >= 0; i--)
		{
			ch = line.charAt(i);
			switch(type)
			{
			
			case WHITESPACE:
				
				if(Character.isWhitespace(ch))
					break;
				else
					return i + 1; 
			
			case WORD_CHAR:
				if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					break;
				}
				else
					return i + 1; 
			
			case SYMBOL:
				if(!joinNonWordChars && pos!=i) return i + 1;
				
				if(Character.isWhitespace(ch))
				{
					return i + 1;
				}
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					return i + 1;
				}
				else
				{
					break;
				} 
			}
		}

		return whiteSpaceEnd;
	} 

	
	
	public static int findWordEnd(String line, int pos, String noWordSep)
	{
		return findWordEnd(line, pos, noWordSep, true);
	} 

	
	
	public static int findWordEnd(String line, int pos, String noWordSep,
					boolean joinNonWordChars)
	{
		if(pos != 0)
			pos--;

		char ch = line.charAt(pos);

		if(noWordSep == null)
			noWordSep = """";

		
		int type;
		if(Character.isWhitespace(ch))
			type = WHITESPACE;
		else if(Character.isLetterOrDigit(ch)
			|| noWordSep.indexOf(ch) != -1)
			type = WORD_CHAR;
		else
			type = SYMBOL;
		

loop:		for(int i = pos; i < line.length(); i++)
		{
			ch = line.charAt(i);
			switch(type)
			{
			
			case WHITESPACE:
				
				if(Character.isWhitespace(ch))
					break;
				else
					return i; 
			
			case WORD_CHAR:
				if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
				{
					break;
				}
				else
					return i; 
			
			case SYMBOL:
				if(!joinNonWordChars && i!=pos) return i;
				
				if(Character.isWhitespace(ch))
				{
					return i;
				}
				else if(Character.isLetterOrDigit(ch) ||
					noWordSep.indexOf(ch) != -1)
					return i;
				else
				{
					break;
				} 
			}
		}

		return line.length();
	} 

	
	
	public static boolean regionMatches(boolean ignoreCase, Segment text,
		int offset, char[] match)
	{
		int length = offset + match.length;
		if(length > text.offset + text.count)
			return false;
		char[] textArray = text.array;
		for(int i = offset, j = 0; i < length; i++, j++)
		{
			char c1 = textArray[i];
			char c2 = match[j];
			if(ignoreCase)
			{
				c1 = Character.toUpperCase(c1);
				c2 = Character.toUpperCase(c2);
			}
			if(c1 != c2)
				return false;
		}
		return true;
	} 

	
	
	public static String spacesToTabs(String in, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		int width = 0;
		int whitespace = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case ' ':
				whitespace++;
				width++;
				break;
			case '\t':
				int tab = tabSize - (width % tabSize);
				width += tab;
				whitespace += tab;
				break;
			case '\n':
				if(whitespace != 0)
				{
					buf.append(MiscUtilities
						.createWhiteSpace(whitespace,tabSize));
				}
				whitespace = 0;
				width = 0;
				buf.append('\n');
				break;
			default:
				if(whitespace != 0)
				{
					buf.append(MiscUtilities
						.createWhiteSpace(whitespace,tabSize));
					whitespace = 0;
				}
				buf.append(in.charAt(i));
				width++;
				break;
			}
		}

		if(whitespace != 0)
		{
			buf.append(MiscUtilities.createWhiteSpace(whitespace,tabSize));
		}

                return buf.toString();
	} 

	
	
	public static String tabsToSpaces(String in, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		int width = 0;
		for(int i = 0; i < in.length(); i++)
		{
			switch(in.charAt(i))
			{
			case '\t':
				int count = tabSize - (width % tabSize);
				width += count;
				while(--count >= 0)
					buf.append(' ');
				break;
			case '\n':
				width = 0;
				buf.append(in.charAt(i));
				break;
			default:
				width++;
				buf.append(in.charAt(i));
				break;
                        }
                }
                return buf.toString();
	} 

	
	
	public static String format(String text, int maxLineLength, int tabSize)
	{
		StringBuffer buf = new StringBuffer();

		int index = 0;

		for(;;)
		{
			int newIndex = text.indexOf(""\n\n"",index);
			if(newIndex == -1)
				break;

			formatParagraph(text.substring(index,newIndex),
				maxLineLength,tabSize,buf);
			buf.append(""\n\n"");
			index = newIndex + 2;
		}

		if(index != text.length())
		{
			formatParagraph(text.substring(index),
				maxLineLength,tabSize,buf);
		}

		return buf.toString();
	} 

	
	public static final int MIXED = 0;
	public static final int LOWER_CASE = 1;
	public static final int UPPER_CASE = 2;
	public static final int TITLE_CASE = 3;

	
	public static int getStringCase(String str)
	{
		if(str.length() == 0)
			return MIXED;

		int state = -1;

		char ch = str.charAt(0);
		if(Character.isLetter(ch))
		{
			if(Character.isUpperCase(ch))
				state = UPPER_CASE;
			else
				state = LOWER_CASE;
		}

		for(int i = 1; i < str.length(); i++)
		{
			ch = str.charAt(i);
			if(!Character.isLetter(ch))
				continue;

			switch(state)
			{
			case UPPER_CASE:
				if(Character.isLowerCase(ch))
				{
					if(i == 1)
						state = TITLE_CASE;
					else
						return MIXED;
				}
				break;
			case LOWER_CASE:
			case TITLE_CASE:
				if(Character.isUpperCase(ch))
					return MIXED;
				break;
			}
		}

		return state;
	} 

	
	
	public static String toTitleCase(String str)
	{
		if(str.length() == 0)
			return str;
		else
		{
			return Character.toUpperCase(str.charAt(0))
				+ str.substring(1).toLowerCase();
		}
	} 

	
	private static final int WHITESPACE = 0;
	private static final int WORD_CHAR = 1;
	private static final int SYMBOL = 2;

	
	private static void formatParagraph(String text, int maxLineLength,
		int tabSize, StringBuffer buf)
	{
		
		int leadingWhitespaceCount = MiscUtilities.getLeadingWhiteSpace(text);
		String leadingWhitespace = text.substring(0,leadingWhitespaceCount);
		int leadingWhitespaceWidth = MiscUtilities.getLeadingWhiteSpaceWidth(text,tabSize);

		buf.append(leadingWhitespace);

		int lineLength = leadingWhitespaceWidth;
		StringTokenizer st = new StringTokenizer(text);
		while(st.hasMoreTokens())
		{
			String word = st.nextToken();
			if(lineLength == leadingWhitespaceWidth)
			{
				
			}
			else if(lineLength + word.length() + 1 > maxLineLength)
			{
				buf.append('\n');
				buf.append(leadingWhitespace);
				lineLength = leadingWhitespaceWidth;
			}
			else
			{
				buf.append(' ');
				lineLength++;
			}
			buf.append(word);
			lineLength += word.length();
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.EditPlugin,8,1,2,11,11,26,10,2,7,0.857142857,28,1.0,1,0.0,0.275,0,0,2.375,1,0.875,0,"

package org.gjt.sp.jedit;

import java.util.Vector;
import java.util.zip.ZipFile;
import org.gjt.sp.jedit.gui.OptionsDialog;
import org.gjt.sp.util.Log;


public abstract class EditPlugin
{
	
	
	public void start() {}
	

	
	
	public void stop() {} 

	
	
	public void createMenuItems(Vector menuItems) {} 

	
	
	public void createOptionPanes(OptionsDialog optionsDialog) {} 

	
	
	public String getClassName()
	{
		return getClass().getName();
	} 

	
	
	public EditPlugin.JAR getJAR()
	{
		return jar;
	} 

	
	
	public static class Broken extends EditPlugin
	{
		public String getClassName()
		{
			return clazz;
		}

		
		Broken(String clazz)
		{
			this.clazz = clazz;
		}

		
		private String clazz;
	} 

	
	
	public static class JAR
	{
		public String getPath()
		{
			return path;
		}

		public ZipFile getZipFile()
		{
			return classLoader.getZipFile();
		}

		public JARClassLoader getClassLoader()
		{
			return classLoader;
		}

		public ActionSet getActions()
		{
			return actions;
		}

		public void addPlugin(EditPlugin plugin)
		{
			plugin.jar = JAR.this;

			long start = System.currentTimeMillis();

			try
			{
				
				
				
				plugin.start();
			}
			finally
			{
				Log.log(Log.DEBUG,this,""-- startup took "" +
					(System.currentTimeMillis() - start)
					+ "" milliseconds"");
			}

			if(plugin instanceof EBPlugin)
				EditBus.addToBus((EBPlugin)plugin);

			plugins.addElement(plugin);
		}

		public EditPlugin[] getPlugins()
		{
			EditPlugin[] array = new EditPlugin[plugins.size()];
			plugins.copyInto(array);
			return array;
		}

		public JAR(String path, JARClassLoader classLoader)
		{
			this.path = path;
			this.classLoader = classLoader;
			plugins = new Vector();
			actions = new ActionSet();
		}

		
		void getPlugins(Vector vector)
		{
			for(int i = 0; i < plugins.size(); i++)
			{
				vector.addElement(plugins.elementAt(i));
			}
		}

		
		private String path;
		private JARClassLoader classLoader;
		private Vector plugins;
		private ActionSet actions;
	} 

	
	private EditPlugin.JAR jar;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.browser.VFSBrowser,64,5,0,51,212,1606,26,36,29,0.94235589,1917,0.684210526,5,0.913286713,0.1390625,3,12,28.359375,21,2.3594,8,"

package org.gjt.sp.jedit.browser;


import gnu.regexp.*;
import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.search.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class VFSBrowser extends JPanel implements EBComponent
{
	public static final String NAME = ""vfs.browser"";

	
	
	public static final int OPEN_DIALOG = 0;

	
	public static final int SAVE_DIALOG = 1;
	
	public static final int BROWSER_DIALOG = 4;
	
	public static final int CHOOSE_DIRECTORY_DIALOG = 3;

	
	public static final int BROWSER = 2;
	

	
	
	public static void browseDirectoryInNewWindow(View view, String path)
	{
		DockableWindowManager wm = view.getDockableWindowManager();
		if(path != null)
		{
			
			jEdit.setTemporaryProperty(""vfs.browser.path.tmp"",path);
		}
		wm.floatDockableWindow(""vfs.browser"");
		jEdit.unsetProperty(""vfs.browser.path.tmp"");
	} 

	
	
	public static void browseDirectory(View view, String path)
	{
		DockableWindowManager wm = view.getDockableWindowManager();
		VFSBrowser browser = (VFSBrowser)wm.getDockable(NAME);
		if(browser != null)
		{
			wm.showDockableWindow(NAME);
			browser.setDirectory(path);
		}
		else
		{
			if(path != null)
			{
				
				jEdit.setTemporaryProperty(""vfs.browser.path.tmp"",path);
			}
			wm.addDockableWindow(""vfs.browser"");
			jEdit.unsetProperty(""vfs.browser.path.tmp"");
		}
	} 

	
	
	public VFSBrowser(View view)
	{
		this(view,null,BROWSER,true,false);
	} 

	
	
	public VFSBrowser(View view, String path, int mode, boolean multipleSelection,
		boolean floating)
	{
		super(new BorderLayout());

		listenerList = new EventListenerList();

		this.mode = mode;
		this.multipleSelection = multipleSelection;
		this.floating = floating;
		this.view = view;

		currentEncoding = jEdit.getProperty(""buffer.encoding"",
			System.getProperty(""file.encoding""));

		ActionHandler actionHandler = new ActionHandler();

		Box topBox = new Box(BoxLayout.Y_AXIS);

		
		
		
		
		
		toolbarBox = new Box(mode == BROWSER
			? BoxLayout.Y_AXIS
			: BoxLayout.X_AXIS);
		JPanel menuBar = createMenuBar();
		if(mode == BROWSER)
			menuBar.add(Box.createGlue());
		toolbarBox.add(menuBar);
		if(mode != BROWSER)
		{
			toolbarBox.add(Box.createHorizontalStrut(6));
			toolbarBox.add(createToolBar());
			toolbarBox.add(Box.createGlue());
		}

		topBox.add(toolbarBox);

		GridBagLayout layout = new GridBagLayout();
		JPanel pathAndFilterPanel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.EAST;
		JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.path""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		pathAndFilterPanel.add(label);

		pathField = new HistoryTextField(""vfs.browser.path"");
		pathField.setInstantPopups(true);
		pathField.setEnterAddsToHistory(false);
		pathField.setSelectAllOnFocus(true);

		if(floating)
		{
			label.setDisplayedMnemonic(jEdit.getProperty(
				""vfs.browser.path.mnemonic"").charAt(0));
			label.setLabelFor(pathField);
		}

		
		
		
		Dimension prefSize = pathField.getPreferredSize();
		prefSize.width = 0;
		pathField.setPreferredSize(prefSize);
		pathField.addActionListener(actionHandler);
		cons.gridx = 1;
		cons.weightx = 1.0f;

		layout.setConstraints(pathField,cons);
		pathAndFilterPanel.add(pathField);

		filterCheckbox = new JCheckBox(jEdit.getProperty(""vfs.browser.filter""));
		filterCheckbox.setMargin(new Insets(0,0,0,0));
		filterCheckbox.setRequestFocusEnabled(false);
		filterCheckbox.setBorder(new EmptyBorder(0,0,0,12));
		filterCheckbox.setSelected(jEdit.getBooleanProperty(
			""vfs.browser.filter-enabled""));

		filterCheckbox.addActionListener(actionHandler);

		if(mode != CHOOSE_DIRECTORY_DIALOG)
		{
			cons.gridx = 0;
			cons.weightx = 0.0f;
			cons.gridy = 1;
			layout.setConstraints(filterCheckbox,cons);
			pathAndFilterPanel.add(filterCheckbox);
		}

		filterField = new HistoryTextField(""vfs.browser.filter"");
		filterField.setInstantPopups(true);
		filterField.setSelectAllOnFocus(true);
		filterField.addActionListener(actionHandler);

		if(mode != CHOOSE_DIRECTORY_DIALOG)
		{
			cons.gridx = 1;
			cons.weightx = 1.0f;
			layout.setConstraints(filterField,cons);
			pathAndFilterPanel.add(filterField);
		}

		topBox.add(pathAndFilterPanel);
		add(BorderLayout.NORTH,topBox);

		boolean splitHorizontally = false;
		if(jEdit.getBooleanProperty(""vfs.browser.splitHorizontally"") && mode != BROWSER)
			splitHorizontally = true;
		add(BorderLayout.CENTER,browserView = new BrowserView(this,splitHorizontally));

		propertiesChanged();

		String filter = jEdit.getProperty(""vfs.browser.last-filter"");
		if(filter == null)
			filter = jEdit.getProperty(""vfs.browser.default-filter"");

		filterField.setText(filter);
		filterField.addCurrentToHistory();

		updateFilterEnabled();

		
		if(path == null)
			path = jEdit.getProperty(""vfs.browser.path.tmp"");

		if(path == null || path.length() == 0)
		{
			String userHome = System.getProperty(""user.home"");
			String defaultPath = jEdit.getProperty(""vfs.browser.defaultPath"");
			if(defaultPath.equals(""home""))
				path = userHome;
			else if(defaultPath.equals(""buffer""))
			{
				if(view != null)
				{
					Buffer buffer = view.getBuffer();
					path = buffer.getDirectory();
				}
				else
					path = userHome;
			}
			else if(defaultPath.equals(""last""))
			{
				HistoryModel pathModel = HistoryModel.getModel(""vfs.browser.path"");
				if(pathModel.getSize() == 0)
					path = ""~"";
				else
					path = pathModel.getItem(0);
			}
			else if(defaultPath.equals(""favorites""))
				path = ""favorites:"";
			else
			{
				
				path = userHome;
			}
		}

		final String _path = path;

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				setDirectory(_path);
			}
		});
	} 

	
	public boolean requestDefaultFocus()
	{
		browserView.focusOnFileView();
		return true;
	} 

	
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	} 

	
	public void removeNotify()
	{
		super.removeNotify();
		jEdit.setBooleanProperty(""vfs.browser.filter-enabled"",
			filterCheckbox.isSelected());
		if(mode == BROWSER || !jEdit.getBooleanProperty(
			""vfs.browser.currentBufferFilter""))
		{
			jEdit.setProperty(""vfs.browser.last-filter"",
				filterField.getText());
		}
		EditBus.removeFromBus(this);
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof BufferUpdate)
		{
			BufferUpdate bmsg = (BufferUpdate)msg;
			if(bmsg.getWhat() == BufferUpdate.CREATED
				|| bmsg.getWhat() == BufferUpdate.CLOSED)
				browserView.updateFileView();
			
			
			
		}
		else if(msg instanceof VFSUpdate)
		{
			maybeReloadDirectory(((VFSUpdate)msg).getPath());
		}
	} 

	
	public View getView()
	{
		return view;
	} 

	
	public int getMode()
	{
		return mode;
	} 

	
	public boolean isMultipleSelectionEnabled()
	{
		return multipleSelection;
	} 

	
	public boolean getShowHiddenFiles()
	{
		return showHiddenFiles;
	} 

	
	public void setShowHiddenFiles(boolean showHiddenFiles)
	{
		this.showHiddenFiles = showHiddenFiles;
	} 

	
	
	public String getFilenameFilter()
	{
		if(filterCheckbox.isSelected())
		{
			String filter = filterField.getText();
			if(filter.length() == 0)
				return ""*"";
			else
				return filter;
		}
		else
			return ""*"";
	} 

	
	public void setFilenameFilter(String filter)
	{
		if(filter == null || filter.length() == 0 || filter.equals(""*""))
			filterCheckbox.setSelected(false);
		else
		{
			filterCheckbox.setSelected(true);
			filterField.setText(filter);
		}
	} 

	
	public HistoryTextField getDirectoryField()
	{
		return pathField;
	} 

	
	public String getDirectory()
	{
		return path;
	} 

	
	public void setDirectory(String path)
	{
		if(path.startsWith(""file:""))
			path = path.substring(5);

		String strippedPath;
		if(path.length() != 1 && (path.endsWith(""/"")
			|| path.endsWith(java.io.File.separator)))
			strippedPath = path.substring(0,path.length() - 1);
		else
			strippedPath = path;

		pathField.setText(strippedPath);

		if(!startRequest())
			return;

		updateFilenameFilter();
		browserView.loadDirectory(path);
		this.path = strippedPath;

		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				endRequest();
			}
		});
	} 

	
	
	public void rootDirectory()
	{
		if(VFSManager.getVFSByName(""roots"") != null)
			setDirectory(FileRootsVFS.PROTOCOL + "":"");
		else
			setDirectory(""/"");
	} 

	
	public void reloadDirectory()
	{
		
		VFSManager.getVFSForPath(path).reloadDirectory(path);

		updateFilenameFilter();
		browserView.loadDirectory(path);
	} 

	
	
	public void delete(VFS.DirectoryEntry[] files)
	{
		String dialogType;

		if(MiscUtilities.isURL(files[0].deletePath)
			&& FavoritesVFS.PROTOCOL.equals(
			MiscUtilities.getProtocolOfURL(files[0].deletePath)))
		{
			dialogType = ""vfs.browser.delete-favorites"";
		}
		else
		{
			dialogType = ""vfs.browser.delete-confirm"";
		}

		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < files.length; i++)
		{
			buf.append(files[i].path);
			buf.append('\n');
		}

		Object[] args = { buf.toString() };
		int result = GUIUtilities.confirm(this,dialogType,args,
			JOptionPane.YES_NO_OPTION,
			JOptionPane.WARNING_MESSAGE);
		if(result != JOptionPane.YES_OPTION)
			return;

		VFS vfs = VFSManager.getVFSForPath(files[0].deletePath);

		if(!startRequest())
			return;

		for(int i = 0; i < files.length; i++)
		{
			Object session = vfs.createVFSSession(files[i].deletePath,this);
			if(session == null)
				continue;

			VFSManager.runInWorkThread(new BrowserIORequest(
				BrowserIORequest.DELETE,this,
				session,vfs,files[i].deletePath,
				null,null,false));
		}
	} 

	
	public void rename(String from)
	{
		VFS vfs = VFSManager.getVFSForPath(from);

		String filename = vfs.getFileName(from);
		String[] args = { filename };
		String to = GUIUtilities.input(this,""vfs.browser.rename"",
			args,filename);
		if(to == null)
			return;

		to = MiscUtilities.constructPath(vfs.getParentOfPath(from),to);

		Object session = vfs.createVFSSession(from,this);
		if(session == null)
			return;

		if(!startRequest())
			return;

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.RENAME,this,
			session,vfs,from,to,null,false));
	} 

	
	public void mkdir()
	{
		String newDirectory = GUIUtilities.input(this,""vfs.browser.mkdir"",null);
		if(newDirectory == null)
			return;

		
		
		VFS.DirectoryEntry[] selected = getSelectedFiles();
		String parent;
		if(selected.length == 0)
			parent = path;
		else if(selected[0].type == VFS.DirectoryEntry.FILE)
		{
			parent = selected[0].path;
			parent = VFSManager.getVFSForPath(parent)
				.getParentOfPath(parent);
		}
		else
			parent = selected[0].path;

		VFS vfs = VFSManager.getVFSForPath(parent);

		
		newDirectory = MiscUtilities.constructPath(parent,newDirectory);

		Object session = vfs.createVFSSession(newDirectory,this);
		if(session == null)
			return;

		if(!startRequest())
			return;

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.MKDIR,this,
			session,vfs,newDirectory,null,null,false));
	} 

	
	
	public void newFile()
	{
		VFS.DirectoryEntry[] selected = getSelectedFiles();
		if(selected.length >= 1)
		{
			VFS.DirectoryEntry file = selected[0];
			if(file.type == VFS.DirectoryEntry.DIRECTORY)
				jEdit.newFile(view,file.path);
			else
			{
				VFS vfs = VFSManager.getVFSForPath(file.path);
				jEdit.newFile(view,vfs.getParentOfPath(file.path));
			}
		}
		else
			jEdit.newFile(view,path);
	} 

	
	
	public void searchInDirectory()
	{
		String path, filter;

		VFS.DirectoryEntry[] selected = getSelectedFiles();
		if(selected.length >= 1)
		{
			VFS.DirectoryEntry file = selected[0];
			if(file.type == VFS.DirectoryEntry.DIRECTORY)
			{
				path = file.path;
				filter = getFilenameFilter();
			}
			else
			{
				VFS vfs = VFSManager.getVFSForPath(file.path);
				path = vfs.getParentOfPath(file.path);
				String name = MiscUtilities.getFileName(file.path);
				String ext = MiscUtilities.getFileExtension(name);
				filter = (ext == null || ext.length() == 0
					? getFilenameFilter()
					: ""*"" + ext);
			}
		}
		else
		{
			path = this.path;
			filter = getFilenameFilter();
		}

		if(path.endsWith(""/"") || path.endsWith(File.separator))
			path = path.substring(0,path.length() - 1);

		SearchAndReplace.setSearchFileSet(new DirectoryListSet(
			path,filter,true));
		new SearchDialog(view,null,SearchDialog.DIRECTORY);
	} 

	
	public BrowserView getBrowserView()
	{
		return browserView;
	} 

	
	public VFS.DirectoryEntry[] getSelectedFiles()
	{
		return browserView.getSelectedFiles();
	} 

	
	public void addBrowserListener(BrowserListener l)
	{
		listenerList.add(BrowserListener.class,l);
	} 

	
	public void removeBrowserListener(BrowserListener l)
	{
		listenerList.remove(BrowserListener.class,l);
	} 

	
	String currentEncoding;

	
	void updateFilenameFilter()
	{
		try
		{
			String filter = filterField.getText();
			if(filter.length() == 0)
				filter = ""*"";
			filenameFilter = new RE(MiscUtilities.globToRE(filter),RE.REG_ICASE);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,VFSBrowser.this,e);
			String[] args = { filterField.getText(),
				e.getMessage() };
			GUIUtilities.error(this,""vfs.browser.bad-filter"",args);
		}
	} 

	
	void directoryLoaded(final DefaultMutableTreeNode node,
		final boolean loadingRoot, final String path,
		final VFS.DirectoryEntry[] list)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(loadingRoot)
				{
					
					VFSBrowser.this.path = path;
					if(!pathField.getText().equals(path))
						pathField.setText(path);
					pathField.addCurrentToHistory();
				}

				boolean filterEnabled = filterCheckbox.isSelected();

				Vector directoryVector = new Vector();

				int directories = 0;
				int files = 0;
				int invisible = 0;

				if(list != null)
				{
					for(int i = 0; i < list.length; i++)
					{
						VFS.DirectoryEntry file = list[i];
						if(file.hidden && !showHiddenFiles)
						{
							invisible++;
							continue;
						}

						if(file.type == VFS.DirectoryEntry.FILE
							&& mode == CHOOSE_DIRECTORY_DIALOG)
						{
							invisible++;
							continue;
						}

						if(file.type == VFS.DirectoryEntry.FILE
							&& filterEnabled
							&& filenameFilter != null
							&& !filenameFilter.isMatch(file.name))
						{
							invisible++;
							continue;
						}

						if(file.type == VFS.DirectoryEntry.FILE)
							files++;
						else
							directories++;

						directoryVector.addElement(file);
					}

					MiscUtilities.quicksort(directoryVector,
						new FileCompare());
				}

				browserView.directoryLoaded(node,path,
					directoryVector);

				
				

				
				
				

				
				
				
				if(mode == CHOOSE_DIRECTORY_DIALOG)
					filesSelected();
			}
		});
	} 

	
	class FileCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			VFS.DirectoryEntry file1 = (VFS.DirectoryEntry)obj1;
			VFS.DirectoryEntry file2 = (VFS.DirectoryEntry)obj2;

			if(!sortMixFilesAndDirs)
			{
				if(file1.type != file2.type)
					return file2.type - file1.type;
			}

			return MiscUtilities.compareStrings(file1.name,
				file2.name,sortIgnoreCase);
		}
	} 

	
	void filesSelected()
	{
		VFS.DirectoryEntry[] selectedFiles = browserView.getSelectedFiles();

		if(mode == BROWSER)
		{
			for(int i = 0; i < selectedFiles.length; i++)
			{
				VFS.DirectoryEntry file = selectedFiles[i];
				Buffer buffer = jEdit.getBuffer(file.path);
				if(buffer != null && view != null)
					view.setBuffer(buffer);
			}
		}

		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesSelected(this,selectedFiles);
			}
		}
	} 

	
	
	static final int M_OPEN = 0;
	static final int M_OPEN_NEW_VIEW = 1;
	static final int M_OPEN_NEW_PLAIN_VIEW = 2;
	static final int M_OPEN_NEW_SPLIT = 3;
	void filesActivated(int mode, boolean canDoubleClickClose)
	{
		VFS.DirectoryEntry[] selectedFiles = browserView.getSelectedFiles();

		Buffer buffer = null;

check_selected: for(int i = 0; i < selectedFiles.length; i++)
		{
			VFS.DirectoryEntry file = selectedFiles[i];

			if(file.type == VFS.DirectoryEntry.DIRECTORY
				|| file.type == VFS.DirectoryEntry.FILESYSTEM)
			{
				if(mode == M_OPEN_NEW_VIEW && this.mode == BROWSER)
					browseDirectoryInNewWindow(view,file.path);
				else
					setDirectory(file.path);
			}
			else if(this.mode == BROWSER || this.mode == BROWSER_DIALOG)
			{
				Buffer _buffer = jEdit.getBuffer(file.path);
				if(_buffer == null)
				{
					Hashtable props = new Hashtable();
					props.put(Buffer.ENCODING,currentEncoding);
					_buffer = jEdit.openFile(null,null,file.path,
						false,props);
				}
				else if(doubleClickClose && canDoubleClickClose
					&& this.mode != BROWSER_DIALOG
					&& selectedFiles.length == 1)
				{
					
					
					EditPane[] editPanes = view.getEditPanes();
					for(int j = 0; j < editPanes.length; j++)
					{
						if(editPanes[j].getBuffer() == _buffer)
						{
							jEdit.closeBuffer(view,_buffer);
							return;
						}
					}
				}

				if(_buffer != null)
					buffer = _buffer;
			}
			else
			{
				
				
				
			}
		}

		if(buffer != null)
		{
			switch(mode)
			{
			case M_OPEN:
				view.setBuffer(buffer);
				break;
			case M_OPEN_NEW_VIEW:
				jEdit.newView(view,buffer,false);
				break;
			case M_OPEN_NEW_PLAIN_VIEW:
				jEdit.newView(view,buffer,true);
				break;
			case M_OPEN_NEW_SPLIT:
				view.splitHorizontally().setBuffer(buffer);
				break;
			}
		}

		Object[] listeners = listenerList.getListenerList();
		for(int i = 0; i < listeners.length; i++)
		{
			if(listeners[i] == BrowserListener.class)
			{
				BrowserListener l = (BrowserListener)listeners[i+1];
				l.filesActivated(this,selectedFiles);
			}
		}
	} 

	
	void endRequest()
	{
		requestRunning = false;
	} 

	

	

	
	private EventListenerList listenerList;
	private View view;
	private boolean floating;
	private String path;
	private HistoryTextField pathField;
	private JCheckBox filterCheckbox;
	private HistoryTextField filterField;
	private Box toolbarBox;
	private JToolBar toolbar;
	private JButton up, reload, roots, home, synchronize,
		newFile, newDirectory, searchInDirectory;
	private BrowserView browserView;
	private RE filenameFilter;
	private int mode;
	private boolean multipleSelection;

	private boolean showHiddenFiles;
	private boolean sortMixFilesAndDirs;
	private boolean sortIgnoreCase;
	private boolean doubleClickClose;

	private boolean requestRunning;
	

	
	private JPanel createMenuBar()
	{
		JPanel menuBar = new JPanel();
		menuBar.setLayout(new BoxLayout(menuBar,BoxLayout.X_AXIS));
		menuBar.setBorder(new EmptyBorder(0,0,1,0));

		menuBar.add(new CommandsMenuButton());
		menuBar.add(Box.createHorizontalStrut(3));
		menuBar.add(new PluginsMenuButton());
		menuBar.add(Box.createHorizontalStrut(3));
		menuBar.add(new FavoritesMenuButton());

		return menuBar;
	} 

	
	private JToolBar createToolBar()
	{
		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);

		toolBar.add(up = createToolButton(""up""));
		toolBar.add(reload = createToolButton(""reload""));
		toolBar.add(roots = createToolButton(""roots""));
		toolBar.add(home = createToolButton(""home""));
		toolBar.add(synchronize = createToolButton(""synchronize""));
		if(mode == BROWSER)
			toolBar.add(newFile = createToolButton(""new-file""));
		toolBar.add(newDirectory = createToolButton(""new-directory""));
		if(mode == BROWSER)
			toolBar.add(searchInDirectory = createToolButton(""search-in-directory""));

		return toolBar;
	} 

	
	private JButton createToolButton(String name)
	{
		JButton button = new RolloverButton();
		String prefix = ""vfs.browser.commands."";

		String iconName = jEdit.getProperty(
			prefix + name + "".icon"");
		if(iconName != null)
		{
			Icon icon = GUIUtilities.loadIcon(iconName);
			if(icon != null)
				button.setIcon(icon);
			else
			{
				Log.log(Log.ERROR,this,""Missing icon: ""
					+ iconName);
			}
		}
		else
			Log.log(Log.ERROR,this,""Missing icon name: "" + name);

		button.setToolTipText(jEdit.getProperty(prefix + name + "".label""));

		button.addActionListener(new ActionHandler());

		return button;
	} 

	
	private void propertiesChanged()
	{
		showHiddenFiles = jEdit.getBooleanProperty(""vfs.browser.showHiddenFiles"");
		sortMixFilesAndDirs = jEdit.getBooleanProperty(""vfs.browser.sortMixFilesAndDirs"");
		sortIgnoreCase = jEdit.getBooleanProperty(""vfs.browser.sortIgnoreCase"");
		doubleClickClose = jEdit.getBooleanProperty(""vfs.browser.doubleClickClose"");

		browserView.propertiesChanged();

		if(mode == BROWSER)
		{
			boolean showToolbar = jEdit.getBooleanProperty(""vfs.browser.showToolbar"");
			if(showToolbar && toolbar == null)
			{
				toolbar = createToolBar();
				toolbar.add(Box.createGlue());
				toolbarBox.add(toolbar,0);
				revalidate();
			}
			else if(!showToolbar && toolbar != null)
			{
				toolbarBox.remove(toolbar);
				toolbar = null;
				revalidate();
			}
		}

		if(path != null)
			reloadDirectory();
	} 

	

	
	private boolean startRequest()
	{
		if(requestRunning)
		{
			
			Log.log(Log.DEBUG,this,new Throwable(""For debugging purposes""));

			GUIUtilities.error(this,""browser-multiple-io"",null);
			return false;
		}
		else
		{
			requestRunning = true;
			return true;
		}
	} 

	
	private void updateFilterEnabled()
	{
		filterField.setEnabled(filterCheckbox.isSelected());
	} 

	
	private void maybeReloadDirectory(String dir)
	{
		
		
		
		
		
		
		
		
		if(requestRunning)
			return;

		
		
		
		
		if(path != null)
		{
			try
			{
				requestRunning = true;

				browserView.maybeReloadDirectory(dir);
			}
			finally
			{
				VFSManager.runInAWTThread(new Runnable()
				{
					public void run()
					{
						requestRunning = false;
					}
				});
			}
		}
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == pathField || source == filterField
				|| source == filterCheckbox)
			{
				updateFilterEnabled();

				String path = pathField.getText();
				if(path != null)
					setDirectory(path);

				browserView.focusOnFileView();
			}
			else if(source == up)
			{
				VFS vfs = VFSManager.getVFSForPath(path);
				setDirectory(vfs.getParentOfPath(path));
			}
			else if(source == reload)
				reloadDirectory();
			else if(source == roots)
				rootDirectory();
			else if(source == home)
				setDirectory(System.getProperty(""user.home""));
			else if(source == synchronize)
			{
				Buffer buffer = view.getBuffer();
				setDirectory(buffer.getDirectory());
			}
			else if(source == newFile)
				newFile();
			else if(source == newDirectory)
				mkdir();
			else if(source == searchInDirectory)
				searchInDirectory();
		}
	} 

	
	class CommandsMenuButton extends JButton
	{
		
		CommandsMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.commands.label""));
			setIcon(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
			setHorizontalTextPosition(SwingConstants.LEADING);

			popup = new BrowserCommandsMenu(VFSBrowser.this,null);

			CommandsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			CommandsMenuButton.this.addMouseListener(new MouseHandler());

			if(OperatingSystem.isMacOSLF())
				CommandsMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		} 

		BrowserCommandsMenu popup;

		
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(!popup.isVisible())
				{
					
					popup.update();

					GUIUtilities.showPopupMenu(
						popup,CommandsMenuButton.this,0,
						CommandsMenuButton.this.getHeight(),
						false);
				}
				else
				{
					popup.setVisible(false);
				}
			}
		} 
	} 

	
	class PluginsMenuButton extends JButton
	{
		
		PluginsMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.plugins.label""));
			setIcon(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
			setHorizontalTextPosition(SwingConstants.LEADING);

			PluginsMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			PluginsMenuButton.this.addMouseListener(new MouseHandler());

			popup = new JPopupMenu();
			ActionHandler actionHandler = new ActionHandler();

			JMenuItem mi = new JMenuItem(jEdit.getProperty(
				""vfs.browser.plugins.plugin-manager.label""));
			mi.setActionCommand(""plugin-manager"");
			mi.addActionListener(actionHandler);

			popup.add(mi);
			popup.addSeparator();

			
			Vector vec = new Vector();
			Enumeration enum = VFSManager.getFilesystems();

			while(enum.hasMoreElements())
			{
				VFS vfs = (VFS)enum.nextElement();
				if((vfs.getCapabilities() & VFS.BROWSE_CAP) == 0)
					continue;

				JMenuItem menuItem = new JMenuItem(jEdit.getProperty(
					""vfs."" + vfs.getName() + "".label""));
				menuItem.setActionCommand(vfs.getName());
				menuItem.addActionListener(actionHandler);
				vec.addElement(menuItem);
			}

			if(vec.size() != 0)
			{
				MiscUtilities.quicksort(vec,new MiscUtilities.MenuItemCompare());
				for(int i = 0; i < vec.size(); i++)
					popup.add((JMenuItem)vec.elementAt(i));
			}
			else
			{
				mi = new JMenuItem(jEdit.getProperty(
					""vfs.browser.plugins.no-plugins.label""));
				mi.setEnabled(false);
				popup.add(mi);
			}

			if(OperatingSystem.isMacOSLF())
				PluginsMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		} 

		JPopupMenu popup;

		
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(evt.getActionCommand().equals(""plugin-manager""))
				{
					new org.gjt.sp.jedit.pluginmgr.PluginManager(
						JOptionPane.getFrameForComponent(
						VFSBrowser.this));
				}
				else
				{
					VFS vfs = VFSManager.getVFSByName(evt.getActionCommand());
					String directory = vfs.showBrowseDialog(null,
						VFSBrowser.this);
					if(directory != null)
						setDirectory(directory);
				}
			}
		} 

		
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(!popup.isVisible())
				{
					GUIUtilities.showPopupMenu(
						popup,PluginsMenuButton.this,0,
						PluginsMenuButton.this.getHeight(),
						false);
				}
				else
				{
					popup.setVisible(false);
				}
			}
		} 
	} 

	
	class FavoritesMenuButton extends JButton
	{
		
		FavoritesMenuButton()
		{
			setText(jEdit.getProperty(""vfs.browser.favorites.label""));
			setIcon(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
			setHorizontalTextPosition(SwingConstants.LEADING);

			FavoritesMenuButton.this.setRequestFocusEnabled(false);
			setMargin(new Insets(1,1,1,1));
			FavoritesMenuButton.this.addMouseListener(new MouseHandler());

			if(OperatingSystem.isMacOSLF())
				FavoritesMenuButton.this.putClientProperty(""JButton.buttonType"",""toolbar"");
		} 

		JPopupMenu popup;

		
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				String actionCommand = evt.getActionCommand();
				if(actionCommand.equals(""add-to-favorites""))
				{
					
					
					Vector toAdd = new Vector();
					VFS.DirectoryEntry[] selected = getSelectedFiles();
					for(int i = 0; i < selected.length; i++)
					{
						VFS.DirectoryEntry file = selected[i];
						if(file.type == VFS.DirectoryEntry.FILE)
						{
							toAdd.addElement(MiscUtilities
								.getParentOfPath(file.path));
						}
						else
							toAdd.addElement(file.path);
					}

					if(toAdd.size() != 0)
					{
						for(int i = 0; i < toAdd.size(); i++)
						{
							FavoritesVFS.addToFavorites((String)toAdd.elementAt(i));
						}
					}
					else
					{
						if(path.equals(FavoritesVFS.PROTOCOL + "":""))
						{
							GUIUtilities.error(VFSBrowser.this,
								""vfs.browser.recurse-favorites"",
								null);
						}
						else
						{
							FavoritesVFS.addToFavorites(path);
						}
					}
				}
				else
					setDirectory(actionCommand);
			}
		} 

		
		class MouseHandler extends MouseAdapter
		{
			public void mousePressed(MouseEvent evt)
			{
				if(popup == null || !popup.isVisible())
				{
					popup = new JPopupMenu();
					ActionHandler actionHandler = new ActionHandler();

					JMenuItem mi = new JMenuItem(
						jEdit.getProperty(
						""vfs.browser.favorites""
						+ "".add-to-favorites.label""));
					mi.setActionCommand(""add-to-favorites"");
					mi.addActionListener(actionHandler);
					popup.add(mi);

					mi = new JMenuItem(
						jEdit.getProperty(
						""vfs.browser.favorites""
						+ "".edit-favorites.label""));
					mi.setActionCommand(""favorites:"");
					mi.addActionListener(actionHandler);
					popup.add(mi);

					popup.addSeparator();

					Object[] favorites = FavoritesVFS.getFavorites();
					if(favorites.length == 0)
					{
						mi = new JMenuItem(
							jEdit.getProperty(
							""vfs.browser.favorites""
							+ "".no-favorites.label""));
						mi.setEnabled(false);
						popup.add(mi);
					}
					else
					{
						MiscUtilities.quicksort(favorites,
							new MiscUtilities.StringICaseCompare());
						for(int i = 0; i < favorites.length; i++)
						{
							mi = new JMenuItem(favorites[i].toString());
							mi.setIcon(FileCellRenderer.dirIcon);
							mi.addActionListener(actionHandler);
							popup.add(mi);
						}
					}

					GUIUtilities.showPopupMenu(
						popup,FavoritesMenuButton.this,0,
						FavoritesMenuButton.this.getHeight(),
						false);
				}
				else
				{
					popup.setVisible(false);
					popup = null;
				}
			}
		} 
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.options.DockingOptionPane,12,6,0,8,49,40,3,7,3,0.858585859,342,1.0,1,0.983823529,0.5,4,10,26.75,5,1.5,1,"

package org.gjt.sp.jedit.options;


import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;



public class DockingOptionPane extends AbstractOptionPane
{
	
	public DockingOptionPane()
	{
		super(""docking"");
	} 

	
	public void _init()
	{
		addSeparator(""options.docking.viewLayout"");

		layoutIcon1 = GUIUtilities.loadIcon(""dock_layout1.png"");
		layoutIcon2 = GUIUtilities.loadIcon(""dock_layout2.png"");
		layoutIcon3 = GUIUtilities.loadIcon(""dock_layout3.png"");
		layoutIcon4 = GUIUtilities.loadIcon(""dock_layout4.png"");

		JPanel layoutPanel = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,1,
			6,6));

		if(jEdit.getBooleanProperty(""view.docking.alternateLayout""))
		{
			layout = new JLabel(jEdit.getBooleanProperty(
				""view.toolbar.alternateLayout"")
				? layoutIcon4 : layoutIcon2);
		}
		else
		{
			layout = new JLabel(jEdit.getBooleanProperty(
				""view.toolbar.alternateLayout"")
				? layoutIcon3 : layoutIcon1);
		}

		layoutPanel.add(layout);

		layoutPanel.add(alternateDockingLayout = new JButton(jEdit.getProperty(
			""options.docking.alternateDockingLayout"")));
		alternateDockingLayout.addActionListener(new ActionHandler());
		layoutPanel.add(alternateToolBarLayout = new JButton(jEdit.getProperty(
			""options.docking.alternateToolBarLayout"")));
		alternateToolBarLayout.addActionListener(new ActionHandler());

		
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridwidth = GridBagConstraints.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = 1.0f;
		gridBag.setConstraints(layoutPanel,cons);
		add(layoutPanel);

		addSeparator(""options.docking.windowDocking"");

		cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridwidth = cons.gridheight = GridBagConstraints.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = cons.weighty = 1.0f;

		JScrollPane windowScroller = createWindowTableScroller();
		gridBag.setConstraints(windowScroller,cons);
		add(windowScroller);
	} 

	
	public void _save()
	{
		jEdit.setBooleanProperty(""view.docking.alternateLayout"",
			layout.getIcon() == layoutIcon2
			|| layout.getIcon() == layoutIcon4);
		jEdit.setBooleanProperty(""view.toolbar.alternateLayout"",
			layout.getIcon() == layoutIcon3
			|| layout.getIcon() == layoutIcon4);
		windowModel.save();
	} 

	

	
	private JLabel layout;
	private Icon layoutIcon1, layoutIcon2, layoutIcon3, layoutIcon4;
	private JButton alternateDockingLayout, alternateToolBarLayout;
	private JTable windowTable;
	private WindowTableModel windowModel;
	

	
	private JScrollPane createWindowTableScroller()
	{
		windowModel = createWindowModel();
		windowTable = new JTable(windowModel);
		windowTable.getTableHeader().setReorderingAllowed(false);
		windowTable.setColumnSelectionAllowed(false);
		windowTable.setRowSelectionAllowed(false);
		windowTable.setCellSelectionEnabled(false);

		DockPositionCellRenderer comboBox = new DockPositionCellRenderer();
		windowTable.setRowHeight(comboBox.getPreferredSize().height);
		TableColumn column = windowTable.getColumnModel().getColumn(1);
		column.setCellRenderer(comboBox);
		column.setCellEditor(new DefaultCellEditor(new DockPositionCellRenderer()));

		Dimension d = windowTable.getPreferredSize();
		d.height = Math.min(d.height,50);
		JScrollPane scroller = new JScrollPane(windowTable);
		scroller.setPreferredSize(d);
		return scroller;
	} 

	
	private WindowTableModel createWindowModel()
	{
		return new WindowTableModel();
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == alternateDockingLayout)
			{
				if(layout.getIcon() == layoutIcon1)
					layout.setIcon(layoutIcon2);
				else if(layout.getIcon() == layoutIcon2)
					layout.setIcon(layoutIcon1);
				else if(layout.getIcon() == layoutIcon3)
					layout.setIcon(layoutIcon4);
				else if(layout.getIcon() == layoutIcon4)
					layout.setIcon(layoutIcon3);
			}
			else if(evt.getSource() == alternateToolBarLayout)
			{
				if(layout.getIcon() == layoutIcon1)
					layout.setIcon(layoutIcon3);
				else if(layout.getIcon() == layoutIcon3)
					layout.setIcon(layoutIcon1);
				else if(layout.getIcon() == layoutIcon2)
					layout.setIcon(layoutIcon4);
				else if(layout.getIcon() == layoutIcon4)
					layout.setIcon(layoutIcon2);
			}
		}
	} 

	
	class DockPositionCellRenderer extends JComboBox
		implements TableCellRenderer
	{
		DockPositionCellRenderer()
		{
			super(new String[] {
				DockableWindowManager.FLOATING,
				DockableWindowManager.TOP,
				DockableWindowManager.LEFT,
				DockableWindowManager.BOTTOM,
				DockableWindowManager.RIGHT
			});
			DockPositionCellRenderer.this.setRequestFocusEnabled(false);
		}

		public Component getTableCellRendererComponent(JTable table,
			Object value, boolean isSelected, boolean hasFocus,
			int row, int column)
		{
			setSelectedItem(value);
			return this;
		}
	} 
} 


class WindowTableModel extends AbstractTableModel
{
	private Vector windows;

	
	WindowTableModel()
	{
		windows = new Vector();

		String[] dockables = DockableWindowManager.getRegisteredDockableWindows();
		for(int i = 0; i < dockables.length; i++)
		{
			windows.addElement(new Entry(dockables[i]));
		}

		sort();
	} 

	
	public void sort()
	{
		MiscUtilities.quicksort(windows,new WindowCompare());
		fireTableDataChanged();
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return windows.size();
	} 

	
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
		case 1:
			return String.class;
		default:
			throw new InternalError();
		}
	} 

	
	public Object getValueAt(int row, int col)
	{
		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 0:
			return window.title;
		case 1:
			return window.dockPosition;
		default:
			throw new InternalError();
		}
	} 

	
	public boolean isCellEditable(int row, int col)
	{
		return (col != 0);
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
			return;

		Entry window = (Entry)windows.elementAt(row);
		switch(col)
		{
		case 1:
			window.dockPosition = (String)value;
			break;
		default:
			throw new InternalError();
		}

		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.docking.title"");
		case 1:
			return jEdit.getProperty(""options.docking.dockPosition"");
		default:
			throw new InternalError();
		}
	} 

	
	public void save()
	{
		for(int i = 0; i < windows.size(); i++)
		{
			((Entry)windows.elementAt(i)).save();
		}
	} 

	
	class Entry
	{
		String name;
		String title;
		String dockPosition;

		Entry(String name)
		{
			this.name = name;
			title = jEdit.getProperty(name + "".title"");
			if(title == null)
				title = name;

			dockPosition = jEdit.getProperty(name + "".dock-position"");
			if(dockPosition == null)
				dockPosition = DockableWindowManager.FLOATING;
		}

		void save()
		{
			jEdit.setProperty(name + "".dock-position"",dockPosition);
		}
	} 

	
	class WindowCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			Entry e1 = (Entry)obj1;
			Entry e2 = (Entry)obj2;

			return MiscUtilities.compareStrings(
				e1.title,e2.title,true);
		}
	} 
} 
"
jEdit,4.1,org.gjt.sp.jedit.syntax.KeywordMap,10,1,0,8,28,3,7,2,8,0.666666667,230,1.0,1,0.0,0.35,0,0,21.5,5,1.8,1,"
package org.gjt.sp.jedit.syntax;

import javax.swing.text.Segment;
import java.util.Vector;
import org.gjt.sp.jedit.TextUtilities;


public class KeywordMap
{
	
	
	public KeywordMap(boolean ignoreCase)
	{
		this(ignoreCase, 52);
		this.ignoreCase = ignoreCase;
		noWordSep = new StringBuffer();
	} 

	
	
	public KeywordMap(boolean ignoreCase, int mapLength)
	{
		this.mapLength = mapLength;
		this.ignoreCase = ignoreCase;
		map = new Keyword[mapLength];
	} 

	
	
	public byte lookup(Segment text, int offset, int length)
	{
		if(length == 0)
			return Token.NULL;
		Keyword k = map[getSegmentMapKey(text, offset, length)];
		while(k != null)
		{
			if(length != k.keyword.length)
			{
				k = k.next;
				continue;
			}
			if(TextUtilities.regionMatches(ignoreCase,text,offset,
				k.keyword))
				return k.id;
			k = k.next;
		}
		return Token.NULL;
	} 

	
	
	public void add(String keyword, byte id)
	{
		int key = getStringMapKey(keyword);

		char[] chars = keyword.toCharArray();

		
		
loop:		for(int i = 0; i < chars.length; i++)
		{
			char ch = chars[i];
			if(!Character.isLetterOrDigit(ch))
			{
				for(int j = 0; j < noWordSep.length(); j++)
				{
					if(noWordSep.charAt(j) == ch)
						continue loop;
				}

				noWordSep.append(ch);
			}
		}

		noWordSepStr = null;
		map[key] = new Keyword(chars,id,map[key]);
	} 

	
	
	public String getNonAlphaNumericChars()
	{
		return noWordSep.toString();
	} 

	
	
	public String[] getKeywords()
	{
		Vector vector = new Vector(100);
		for(int i = 0; i < map.length; i++)
		{
			Keyword keyword = map[i];
			while(keyword != null)
			{
				vector.addElement(new String(keyword.keyword));
				keyword = keyword.next;
			}
		}
		String[] retVal = new String[vector.size()];
		vector.copyInto(retVal);
		return retVal;
	} 

	
	
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	} 

	
	
	public void setIgnoreCase(boolean ignoreCase)
	{
		this.ignoreCase = ignoreCase;
	} 

	

	
	private int mapLength;
	private Keyword[] map;
	private boolean ignoreCase;
	private StringBuffer noWordSep;
	private String noWordSepStr;
	

	
	private int getStringMapKey(String s)
	{
		return (Character.toUpperCase(s.charAt(0)) +
				Character.toUpperCase(s.charAt(s.length()-1)))
				% mapLength;
	} 

	
	protected int getSegmentMapKey(Segment s, int off, int len)
	{
		return (Character.toUpperCase(s.array[off]) +
				Character.toUpperCase(s.array[off + len - 1]))
				% mapLength;
	} 

	

	
	class Keyword
	{
		public Keyword(char[] keyword, byte id, Keyword next)
		{
			this.keyword = keyword;
			this.id = id;
			this.next = next;
		}

		public char[] keyword;
		public byte id;
		public Keyword next;
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.JARClassLoader,16,2,0,14,111,24,8,9,8,0.818181818,1304,0.636363636,1,0.831168831,0.373333333,1,7,79.8125,14,2.6875,1,"

package org.gjt.sp.jedit;


import java.io.*;
import java.lang.reflect.Modifier;
import java.net.*;
import java.util.*;
import java.util.jar.*;
import java.util.zip.*;
import org.gjt.sp.jedit.gui.DockableWindowManager;
import org.gjt.sp.util.Log;



public class JARClassLoader extends ClassLoader
{
	
	
	public JARClassLoader()
	{
	} 

	
	public static long scanTime;
	public static long startTime;

	public JARClassLoader(String path)
		throws IOException
	{
		long time = System.currentTimeMillis();

		this.path = path;
		zipFile = new JarFile(path);
		definePackages();

		jar = new EditPlugin.JAR(path,this);

		Enumeration entires = zipFile.entries();
		while(entires.hasMoreElements())
		{
			ZipEntry entry = (ZipEntry)entires.nextElement();
			String name = entry.getName();
			String lname = name.toLowerCase();
			if(lname.equals(""actions.xml""))
				pluginResources.add(entry);
			if(lname.equals(""dockables.xml""))
				pluginResources.add(entry);
			else if(lname.endsWith("".props""))
				jEdit.loadProps(zipFile.getInputStream(entry),true);
			else if(name.endsWith("".class""))
			{
				classHash.put(MiscUtilities.fileToClass(name),this);

				if(name.endsWith(""Plugin.class""))
					pluginClasses.add(name);
			}
		}

		jEdit.addPluginJAR(jar);

		scanTime += (System.currentTimeMillis() - time);
	} 

	
	
	public Class loadClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		
		Object obj = classHash.get(clazz);
		if(obj == NO_CLASS)
		{
			
			
			
			throw new ClassNotFoundException(clazz);
		}
		else if(obj instanceof ClassLoader)
		{
			JARClassLoader classLoader = (JARClassLoader)obj;
			return classLoader._loadClass(clazz,resolveIt);
		}

		
		
		try
		{
			Class cls;

			
			ClassLoader parentLoader = getClass().getClassLoader();
			if (parentLoader != null)
				cls = parentLoader.loadClass(clazz);
			else
				cls = findSystemClass(clazz);

			return cls;
		}
		catch(ClassNotFoundException cnf)
		{
			
			
			classHash.put(clazz,NO_CLASS);

			throw cnf;
		}
	} 

	
	public InputStream getResourceAsStream(String name)
	{
		if(zipFile == null)
			return null;

		try
		{
			ZipEntry entry = zipFile.getEntry(name);
			if(entry == null)
				return getSystemResourceAsStream(name);
			else
				return zipFile.getInputStream(entry);
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);

			return null;
		}
	} 

	
	public URL getResource(String name)
	{
		if(zipFile == null)
			return null;

		ZipEntry entry = zipFile.getEntry(name);
		if(entry == null)
			return getSystemResource(name);

		try
		{
			return new URL(getResourceAsPath(name));
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			return null;
		}
	} 

	
	public String getResourceAsPath(String name)
	{
		if(zipFile == null)
			return null;

		if(!name.startsWith(""/""))
			name = ""/"" + name;

		return ""jeditresource:/"" + MiscUtilities.getFileName(
			jar.getPath()) + ""!"" + name;
	} 

	
	
	public void closeZipFile()
	{
		if(zipFile == null)
			return;

		try
		{
			zipFile.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
		}

		zipFile = null;
	} 

	
	
	public ZipFile getZipFile()
	{
		return zipFile;
	} 

	
	void startAllPlugins()
	{
		long time = System.currentTimeMillis();

		boolean ok = true;

		for(int i = 0; i < pluginClasses.size(); i++)
		{
			String name = (String)pluginClasses.get(i);
			name = MiscUtilities.fileToClass(name);

			try
			{
				ok &= loadPluginClass(name);
			}
			catch(Throwable t)
			{
				ok = false;

				Log.log(Log.ERROR,this,""Error while starting plugin "" + name);
				Log.log(Log.ERROR,this,t);

				jar.addPlugin(new EditPlugin.Broken(name));
				String[] args = { t.toString() };
				jEdit.pluginError(jar.getPath(),
					""plugin-error.start-error"",args);
			}
		}

		startTime += (System.currentTimeMillis() - time);
		time = System.currentTimeMillis();

		if(!ok)
		{
			
			return;
		}

		try
		{
			for(int i = 0; i < pluginResources.size(); i++)
			{
				ZipEntry entry = (ZipEntry)pluginResources.get(i);
				String name = entry.getName();
				if(name.equalsIgnoreCase(""actions.xml""))
				{
					jEdit.loadActions(
						path + ""!actions.xml"",
						new BufferedReader(new InputStreamReader(
						zipFile.getInputStream(entry))),
						jar.getActions());
				}
				else if(name.equalsIgnoreCase(""dockables.xml""))
				{
					DockableWindowManager.loadDockableWindows(
						path + ""!dockables.xml"",
						new BufferedReader(new InputStreamReader(
						zipFile.getInputStream(entry))),
						jar.getActions());
				}
			}
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,jEdit.class,""Cannot load""
				+ "" plugin "" + MiscUtilities.getFileName(path));
			Log.log(Log.ERROR,jEdit.class,io);

			String[] args = { io.toString() };
			jEdit.pluginError(path,""plugin-error.load-error"",args);
		}

		scanTime += (System.currentTimeMillis() - time);
	} 

	

	
	private static final Object NO_CLASS = new Object();

	private static Hashtable classHash = new Hashtable();

	private String path;

	private EditPlugin.JAR jar;
	private ArrayList pluginResources = new ArrayList();
	private ArrayList pluginClasses = new ArrayList();
	private JarFile zipFile;

	
	private boolean loadPluginClass(String name)
		throws Exception
	{
		
		EditPlugin[] plugins = jEdit.getPlugins();

		for(int i = 0; i < plugins.length; i++)
		{
			if(plugins[i].getClass().getName().equals(name))
			{
				jEdit.pluginError(jar.getPath(),
					""plugin-error.already-loaded"",null);
				return false;
			}
		}

		
		if(name.equals(""WheelMousePlugin"")
			&& OperatingSystem.hasJava14())
		{
			jar.addPlugin(new EditPlugin.Broken(name));
			jEdit.pluginError(jar.getPath(),""plugin-error.obsolete"",null);
			return false;
		}

		
		if(!checkDependencies(name))
		{
			jar.addPlugin(new EditPlugin.Broken(name));
			return false;
		}

		
		
		Class clazz = loadClass(name,true);
		int modifiers = clazz.getModifiers();
		if(!Modifier.isInterface(modifiers)
			&& !Modifier.isAbstract(modifiers)
			&& EditPlugin.class.isAssignableFrom(clazz))
		{
			String label = jEdit.getProperty(""plugin.""
				+ name + "".name"");
			String version = jEdit.getProperty(""plugin.""
				+ name + "".version"");

			if(version == null)
			{
				Log.log(Log.ERROR,this,""Plugin "" +
					name + "" needs""
					+ "" 'name' and 'version' properties."");
				jar.addPlugin(new EditPlugin.Broken(name));
				return false;
			}

			jar.getActions().setLabel(jEdit.getProperty(
				""action-set.plugin"",
				new String[] { label }));
			Log.log(Log.NOTICE,this,""Starting plugin "" + label
				+ "" (version "" + version + "")"");

			jar.addPlugin((EditPlugin)clazz.newInstance());
			return true;
		}
		else
		{
			
			return true;
		}
	} 

	
	private boolean checkDependencies(String name)
	{
		int i = 0;

		boolean ok = true;

		String dep;
		while((dep = jEdit.getProperty(""plugin."" + name + "".depend."" + i++)) != null)
		{
			int index = dep.indexOf(' ');
			if(index == -1)
			{
				Log.log(Log.ERROR,this,name + "" has an invalid""
					+ "" dependency: "" + dep);
				return false;
			}

			String what = dep.substring(0,index);
			String arg = dep.substring(index + 1);

			if(what.equals(""jdk""))
			{
				if(MiscUtilities.compareStrings(
					System.getProperty(""java.version""),
					arg,false) < 0)
				{
					String[] args = { arg,
						System.getProperty(""java.version"") };
					jEdit.pluginError(jar.getPath(),""plugin-error.dep-jdk"",args);
					ok = false;
				}
			}
			else if(what.equals(""jedit""))
			{
				if(arg.length() != 11)
				{
					Log.log(Log.ERROR,this,""Invalid jEdit version""
						+ "" number: "" + arg);
					ok = false;
				}

				if(MiscUtilities.compareStrings(
					jEdit.getBuild(),arg,false) < 0)
				{
					String needs = MiscUtilities.buildToVersion(arg);
					String[] args = { needs,
						jEdit.getVersion() };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-jedit"",args);
					ok = false;
				}
			}
			else if(what.equals(""plugin""))
			{
				int index2 = arg.indexOf(' ');
				if(index2 == -1)
				{
					Log.log(Log.ERROR,this,name 
						+ "" has an invalid dependency: ""
						+ dep + "" (version is missing)"");
					return false;
				}
				
				String plugin = arg.substring(0,index2);
				String needVersion = arg.substring(index2 + 1);
				String currVersion = jEdit.getProperty(""plugin."" 
					+ plugin + "".version"");

				if(currVersion == null)
				{
					String[] args = { needVersion, plugin };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-plugin.no-version"",
						args);
					ok = false;
				}
				else if(MiscUtilities.compareStrings(currVersion,
					needVersion,false) < 0)
				{
					String[] args = { needVersion, plugin, currVersion };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-plugin"",args);
					ok = false;
				}
				else if(jEdit.getPlugin(plugin) instanceof EditPlugin.Broken)
				{
					String[] args = { plugin };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-plugin.broken"",args);
					ok = false;
				}
			}
			else if(what.equals(""class""))
			{
				try
				{
					loadClass(arg,false);
				}
				catch(Exception e)
				{
					String[] args = { arg };
					jEdit.pluginError(jar.getPath(),
						""plugin-error.dep-class"",args);
					ok = false;
				}
			}
			else
			{
				Log.log(Log.ERROR,this,name + "" has unknown""
					+ "" dependency: "" + dep);
				return false;
			}
		}

		return ok;
	} 

	
	
	private Class _loadClass(String clazz, boolean resolveIt)
		throws ClassNotFoundException
	{
		Class cls = findLoadedClass(clazz);
		if(cls != null)
		{
			if(resolveIt)
				resolveClass(cls);
			return cls;
		}

		String name = MiscUtilities.classToFile(clazz);

		try
		{
			ZipEntry entry = zipFile.getEntry(name);

			if(entry == null)
				throw new ClassNotFoundException(clazz);

			InputStream in = zipFile.getInputStream(entry);

			int len = (int)entry.getSize();
			byte[] data = new byte[len];
			int success = 0;
			int offset = 0;
			while(success < len)
			{
				len -= success;
				offset += success;
				success = in.read(data,offset,len);
				if(success == -1)
				{
					Log.log(Log.ERROR,this,""Failed to load class ""
						+ clazz + "" from "" + zipFile.getName());
					throw new ClassNotFoundException(clazz);
				}
			}

			cls = defineClass(clazz,data,0,data.length);

			if(resolveIt)
				resolveClass(cls);

			return cls;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);

			throw new ClassNotFoundException(clazz);
		}
	} 

	
	
	private void definePackages()
	{
		try
		{
			Manifest manifest = zipFile.getManifest();

			if(manifest != null)
			{
				Map entries = manifest.getEntries();
				Iterator i = entries.keySet().iterator();

				while(i.hasNext())
				{
					String path = (String)i.next();

					if(!path.endsWith("".class""))
					{
						String name = path.replace('/', '.');

						if(name.endsWith("".""))
							name = name.substring(0, name.length() - 1);

						
						definePackage(path,name,manifest,null);
					}
				}
			}
		}
		catch (Exception ex)
		{
			
			Log.log(Log.ERROR, this,""Error extracting manifest info ""
				+ ""for file "" + zipFile);
			Log.log(Log.ERROR, this, ex);
		}
	} 

	
	
	private Package definePackage(String path, String name, Manifest man,
		URL url) throws IllegalArgumentException
	{
		String specTitle = null;
		String specVersion = null;
		String specVendor = null;
		String implTitle = null;
		String implVersion = null;
		String implVendor = null;
		String sealed = null;
		URL sealBase = null;

		Attributes attr = man.getAttributes(path);

		if(attr != null)
		{
			specTitle = attr.getValue(
				Attributes.Name.SPECIFICATION_TITLE);
			specVersion = attr.getValue(
				Attributes.Name.SPECIFICATION_VERSION);
			specVendor = attr.getValue(
				Attributes.Name.SPECIFICATION_VENDOR);
			implTitle = attr.getValue(
				Attributes.Name.IMPLEMENTATION_TITLE);
			implVersion = attr.getValue(
				Attributes.Name.IMPLEMENTATION_VERSION);
			implVendor = attr.getValue(
				Attributes.Name.IMPLEMENTATION_VENDOR);
			sealed = attr.getValue(Attributes.Name.SEALED);
		}

		attr = man.getMainAttributes();

		if (attr != null)
		{
			if (specTitle == null)
			{
				specTitle = attr.getValue(
					Attributes.Name.SPECIFICATION_TITLE);
			}

			if (specVersion == null)
			{
				specVersion = attr.getValue(
					Attributes.Name.SPECIFICATION_VERSION);
			}

			if (specVendor == null)
			{
				specVendor = attr.getValue(
					Attributes.Name.SPECIFICATION_VENDOR);
			}

			if (implTitle == null)
			{
				implTitle = attr.getValue(
					Attributes.Name.IMPLEMENTATION_TITLE);
			}

			if (implVersion == null)
			{
				implVersion = attr.getValue(
					Attributes.Name.IMPLEMENTATION_VERSION);
			}

			if (implVendor == null)
			{
				implVendor = attr.getValue(
					Attributes.Name.IMPLEMENTATION_VENDOR);
			}

			if (sealed == null)
			{
				sealed = attr.getValue(Attributes.Name.SEALED);
			}
		}

		
		

		return super.definePackage(name, specTitle, specVersion, specVendor,
			implTitle, implVersion, implVendor,
			sealBase);
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.EnhancedDialog,5,6,19,22,16,10,22,3,4,0.5,56,1.0,1,0.995412844,0.44,0,0,10.0,1,0.6,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.awt.event.*;
import java.awt.*;


public abstract class EnhancedDialog extends JDialog
{
	public EnhancedDialog(Frame parent, String title, boolean modal)
	{
		super(parent,title,modal);
		_init();
	}
	
	public EnhancedDialog(Dialog parent, String title, boolean modal)
	{
		super(parent,title,modal);
		_init();
	}

	public abstract void ok();
	public abstract void cancel();

	
	
	private void _init() {
		((Container)getLayeredPane()).addContainerListener(
			new ContainerHandler());
		getContentPane().addContainerListener(new ContainerHandler());

		keyHandler = new KeyHandler();
		addKeyListener(keyHandler);
		addWindowListener(new WindowHandler());

		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
	}

	
	
	
	protected KeyHandler keyHandler;

	
	class ContainerHandler extends ContainerAdapter
	{
		public void componentAdded(ContainerEvent evt)
		{
			componentAdded(evt.getChild());
		}

		public void componentRemoved(ContainerEvent evt)
		{
			componentRemoved(evt.getChild());
		}

		private void componentAdded(Component comp)
		{
			comp.addKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.addContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentAdded(comps[i]);
				}
			}
		}

		private void componentRemoved(Component comp)
		{
			comp.removeKeyListener(keyHandler);
			if(comp instanceof Container)
			{
				Container cont = (Container)comp;
				cont.removeContainerListener(this);
				Component[] comps = cont.getComponents();
				for(int i = 0; i < comps.length; i++)
				{
					componentRemoved(comps[i]);
				}
			}
		}
	}

	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.isConsumed())
				return;

			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				
				Component comp = getFocusOwner();
				while(comp != null)
				{
					if(comp instanceof JComboBox)
					{
						JComboBox combo = (JComboBox)comp;
						if(combo.isEditable())
						{
							Object selected = combo.getEditor().getItem();
							if(selected != null)
								combo.setSelectedItem(selected);
						}
						break;
					}

					comp = comp.getParent();
				}

				ok();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
			{
				cancel();
				evt.consume();
			}
		}
	}

	class WindowHandler extends WindowAdapter
	{
		public void windowClosing(WindowEvent evt)
		{
			cancel();
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.browser.BrowserView,28,5,0,25,136,184,14,20,12,0.831908832,868,1.0,4,0.960294118,0.145604396,1,4,29.53571429,15,2.3571,4,"

package org.gjt.sp.jedit.browser;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;



class BrowserView extends JPanel
{
	
	public BrowserView(VFSBrowser browser, final boolean splitHorizontally)
	{
		this.browser = browser;
		this.splitHorizontally = splitHorizontally;

		parentDirectories = new JList();

		parentDirectories.getSelectionModel().setSelectionMode(
			TreeSelectionModel.SINGLE_TREE_SELECTION);

		parentDirectories.setCellRenderer(new ParentDirectoryRenderer());
		parentDirectories.setVisibleRowCount(5);
		parentDirectories.addMouseListener(new MouseHandler());

		rootNode = new DefaultMutableTreeNode(null,true);
		model = new DefaultTreeModel(rootNode,true);

		tree = new BrowserJTree(model);
		tree.setCellRenderer(renderer);
		tree.setEditable(false);
		tree.addTreeExpansionListener(new TreeHandler());

		
		if(!OperatingSystem.isMacOSLF())
			tree.putClientProperty(""JTree.lineStyle"", ""Angled"");

		tree.setRootVisible(false);
		tree.setShowsRootHandles(true);
		tree.setVisibleRowCount(12);

		final JScrollPane parentScroller = new JScrollPane(parentDirectories);
		parentScroller.setMinimumSize(new Dimension(0,0));
		JScrollPane treeScroller = new JScrollPane(tree);
		treeScroller.setMinimumSize(new Dimension(0,0));
		splitPane = new JSplitPane(
			splitHorizontally ? JSplitPane.HORIZONTAL_SPLIT : JSplitPane.VERTICAL_SPLIT,
			parentScroller,treeScroller);
		splitPane.setOneTouchExpandable(true);

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				String prop = splitHorizontally ? ""vfs.browser.horizontalSplitter"" : ""vfs.browser.splitter"";
				int loc = jEdit.getIntegerProperty(prop,-1);
				if(loc == -1)
					loc = parentScroller.getPreferredSize().height;

				splitPane.setDividerLocation(loc);
				parentDirectories.ensureIndexIsVisible(
					parentDirectories.getModel()
					.getSize());
			}
		});

		tmpExpanded = new Hashtable();

		if(browser.isMultipleSelectionEnabled())
			tree.getSelectionModel().setSelectionMode(
				TreeSelectionModel.DISCONTIGUOUS_TREE_SELECTION);
		else
			tree.getSelectionModel().setSelectionMode(
				TreeSelectionModel.SINGLE_TREE_SELECTION);

		setLayout(new BorderLayout());

		add(BorderLayout.CENTER,splitPane);

		propertiesChanged();
	} 

	
	public void focusOnFileView()
	{
		tree.requestFocus();
	} 

	
	public void removeNotify()
	{
		String prop = splitHorizontally ? ""vfs.browser.horizontalSplitter"" : ""vfs.browser.splitter"";
		jEdit.setIntegerProperty(prop,splitPane.getDividerLocation());

		super.removeNotify();
	} 

	
	public VFS.DirectoryEntry[] getSelectedFiles()
	{
		Vector selected = new Vector(tree.getSelectionCount());
		TreePath[] paths = tree.getSelectionPaths();
		if(paths == null)
			return new VFS.DirectoryEntry[0];

		for(int i = 0; i < paths.length; i++)
		{
			DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
				paths[i].getLastPathComponent();
			Object obj = treeNode.getUserObject();
			if(obj instanceof VFS.DirectoryEntry)
				selected.addElement(obj);
		}

		VFS.DirectoryEntry[] retVal = new VFS.DirectoryEntry[selected.size()];
		selected.copyInto(retVal);
		return retVal;
	} 

	
	public void selectNone()
	{
		tree.setSelectionPaths(new TreePath[0]);
	} 

	
	public void loadDirectory(String path)
	{
		
		tmpExpanded.clear();
		loadDirectory(rootNode,path,false);
	} 

	
	public void directoryLoaded(DefaultMutableTreeNode node,
		String path, Vector directory)
	{
		if(node == rootNode)
		{
			DefaultListModel parentList = new DefaultListModel();

			String parent = path;

			if(parent.length() != 1 && (parent.endsWith(""/"")
				|| parent.endsWith(File.separator)))
				parent = parent.substring(0,parent.length() - 1);

			for(;;)
			{
				VFS _vfs = VFSManager.getVFSForPath(
					parent);
				
				
				
				
				parentList.insertElementAt(new VFS.DirectoryEntry(
					_vfs.getFileName(parent),
					parent,parent,
					VFS.DirectoryEntry.DIRECTORY,
					0L,false),0);
				String newParent = _vfs.getParentOfPath(parent);
				if(newParent.length() != 1 && (newParent.endsWith(""/"")
					|| newParent.endsWith(File.separator)))
					newParent = newParent.substring(0,newParent.length() - 1);

				if(newParent == null || parent.equals(newParent))
					break;
				else
					parent = newParent;
			}

			parentDirectories.setModel(parentList);
			int index = parentList.getSize() - 1;
			parentDirectories.setSelectedIndex(index);
			parentDirectories.ensureIndexIsVisible(index);
		}

		node.removeAllChildren();

		Vector toExpand = new Vector();

		if(directory != null)
		{
			for(int i = 0; i < directory.size(); i++)
			{
				VFS.DirectoryEntry file = (VFS.DirectoryEntry)
					directory.elementAt(i);
				boolean allowsChildren = (file.type != VFS.DirectoryEntry.FILE);
				DefaultMutableTreeNode newNode = new DefaultMutableTreeNode(file,allowsChildren);
				node.add(newNode);
				if(tmpExpanded.get(file.path) != null)
				{
					tmpExpanded.remove(file.path);
					toExpand.addElement(new TreePath(newNode.getPath()));
				}
			}
		}

		
		model.reload(node);
		tree.expandPath(new TreePath(node.getPath()));

		
		for(int i = 0; i < toExpand.size(); i++)
		{
			TreePath treePath = (TreePath)toExpand.elementAt(i);
			tree.expandPath(treePath);
		}

		timer.stop();
		typeSelectBuffer.setLength(0);
	} 

	
	public void updateFileView()
	{
		tree.repaint();
	} 

	
	public void maybeReloadDirectory(String path)
	{
		tmpExpanded.clear();

		
		
		
		
		
		
		
		
		
		
		
		String browserDir = browser.getDirectory();
		if(browserDir.startsWith(FavoritesVFS.PROTOCOL))
			maybeReloadDirectory(rootNode,path);
		else if(browserDir.startsWith(FileRootsVFS.PROTOCOL))
		{
			if(!MiscUtilities.isURL(path) || MiscUtilities.getProtocolOfURL(path)
				.equals(""file""))
				maybeReloadDirectory(rootNode,path);
		}
		else if(path.startsWith(browserDir))
			maybeReloadDirectory(rootNode,path);
	} 

	
	public Component getDefaultFocusComponent()
	{
		return tree;
	} 

	
	public void propertiesChanged()
	{
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
		renderer.propertiesChanged();

		tree.setRowHeight(renderer.getTreeCellRendererComponent(
			tree,new DefaultMutableTreeNode(""foo""),
			false,false,false,0,false).getSize().height);

		splitPane.setBorder(null);
	} 

	
	public BrowserJTree getTree()
	{
		return tree;
	} 

	

	
	private VFSBrowser browser;

	private JSplitPane splitPane;
	private JList parentDirectories;
	private BrowserJTree tree;
	private Hashtable tmpExpanded;
	private DefaultTreeModel model;
	private DefaultMutableTreeNode rootNode;
	private BrowserCommandsMenu popup;
	private boolean showIcons;
	private boolean splitHorizontally;

	private FileCellRenderer renderer = new FileCellRenderer();

	private StringBuffer typeSelectBuffer = new StringBuffer();
	private Timer timer = new Timer(0,new ClearTypeSelect());
	

	
	private boolean maybeReloadDirectory(DefaultMutableTreeNode node, String path)
	{
		
		if(!tree.isExpanded(new TreePath(node.getPath())))
			return false;

		if(node == rootNode && path.equals(browser.getDirectory()))
		{
			loadDirectory(rootNode,path,false);
			return true;
		}

		Object userObject = node.getUserObject();
		if(userObject instanceof VFS.DirectoryEntry)
		{
			VFS.DirectoryEntry file = (VFS.DirectoryEntry)userObject;

			
			if(file.type == VFS.DirectoryEntry.FILE)
				return false;

			if(path.equals(file.path))
			{
				loadDirectory(node,path,false);
				return true;
			}
		}

		if(node.getChildCount() != 0)
		{
			Enumeration children = node.children();
			while(children.hasMoreElements())
			{
				DefaultMutableTreeNode child = (DefaultMutableTreeNode)
					children.nextElement();
				if(maybeReloadDirectory(child,path))
					return true;
			}
		}

		return false;
	} 

	
	private void loadDirectory(DefaultMutableTreeNode node, String path,
		boolean showLoading)
	{
		saveExpansionState(node);

		path = MiscUtilities.constructPath(browser.getDirectory(),path);
		VFS vfs = VFSManager.getVFSForPath(path);

		Object session = vfs.createVFSSession(path,this);
		if(session == null)
			return;

		if(node == rootNode)
		{
			setListModel(parentDirectories,new Object[] {
				new LoadingPlaceholder() });
		}

		if(showLoading)
		{
			node.removeAllChildren();
			node.add(new DefaultMutableTreeNode(new LoadingPlaceholder(),false));
			model.reload(node);
		}

		VFSManager.runInWorkThread(new BrowserIORequest(
			BrowserIORequest.LIST_DIRECTORY,browser,
			session,vfs,path,null,node,node == rootNode));
	} 

	
	private void saveExpansionState(DefaultMutableTreeNode node)
	{
		for(int i = 0; i < node.getChildCount(); i++)
		{
			DefaultMutableTreeNode child = (DefaultMutableTreeNode)
				node.getChildAt(i);

			TreePath treePath = new TreePath(child.getPath());

			if(tree.isExpanded(treePath))
			{
				VFS.DirectoryEntry file = ((VFS.DirectoryEntry)
					child.getUserObject());

				tmpExpanded.put(file.path,file.path);

				if(file.type != VFS.DirectoryEntry.FILE)
					saveExpansionState(child);
			}
		}
	} 

	
	private void showFilePopup(VFS.DirectoryEntry[] files, Component comp,
		Point point)
	{
		popup = new BrowserCommandsMenu(browser,files);
		
		
		
		popup.addPopupMenuListener(new PopupMenuListener()
		{
			public void popupMenuCanceled(PopupMenuEvent e) {}

			public void popupMenuWillBecomeVisible(PopupMenuEvent e) {}

			public void popupMenuWillBecomeInvisible(PopupMenuEvent e)
			{
				int index = parentDirectories.getModel().getSize() - 1;
				parentDirectories.setSelectedIndex(index);
			}
		});
		GUIUtilities.showPopupMenu(popup,comp,point.x,point.y);
	} 

	
	
	private void setListModel(JList list, final Object[] model)
	{
		list.setModel(new AbstractListModel()
		{
			public int getSize() { return model.length; }
			public Object getElementAt(int i) { return model[i]; }
		});
	} 

	

	

	
	class ClearTypeSelect implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			typeSelectBuffer.setLength(0);
			browser.filesSelected();
		}
	} 

	
	class ParentDirectoryRenderer extends DefaultListCellRenderer
	{
		Font plainFont, boldFont;

		ParentDirectoryRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			boldFont = new Font(plainFont.getName(),Font.BOLD,plainFont.getSize());
		}

		public Component getListCellRendererComponent(
			JList list,
			Object value,
			int index,
			boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			ParentDirectoryRenderer.this.setBorder(new EmptyBorder(
				1,index * 5 + 1,1,1));

			if(value instanceof LoadingPlaceholder)
			{
				ParentDirectoryRenderer.this.setFont(plainFont);

				setIcon(showIcons ? FileCellRenderer.loadingIcon : null);
				setText(jEdit.getProperty(""vfs.browser.tree.loading""));
			}
			else if(value instanceof VFS.DirectoryEntry)
			{
				VFS.DirectoryEntry dirEntry = (VFS.DirectoryEntry)value;
				ParentDirectoryRenderer.this.setFont(boldFont);

				setIcon(showIcons ? FileCellRenderer.getIconForFile(dirEntry,true)
					: null);
				setText(dirEntry.name);
			}
			else if(value == null)
				setText(""VFS does not follow VFS API"");

			return this;
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mousePressed(MouseEvent evt)
		{
			int row = parentDirectories.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Object obj = parentDirectories.getModel()
					.getElementAt(row);
				if(obj instanceof VFS.DirectoryEntry)
				{
					VFS.DirectoryEntry dirEntry = ((VFS.DirectoryEntry)obj);
					if(GUIUtilities.isPopupTrigger(evt))
					{
						if(popup != null && popup.isVisible())
						{
							popup.setVisible(false);
							popup = null;
						}
						else
						{
							parentDirectories.setSelectedIndex(row);
							showFilePopup(new VFS.DirectoryEntry[] {
								dirEntry },parentDirectories,
								evt.getPoint());
						}
					}
				}
			}
		}

		public void mouseReleased(MouseEvent evt)
		{
			if(evt.getClickCount() % 2 != 0 &&
				!GUIUtilities.isMiddleButton(evt.getModifiers()))
				return;

			int row = parentDirectories.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Object obj = parentDirectories.getModel()
					.getElementAt(row);
				if(obj instanceof VFS.DirectoryEntry)
				{
					VFS.DirectoryEntry dirEntry = ((VFS.DirectoryEntry)obj);
					if(!GUIUtilities.isPopupTrigger(evt))
					{
						browser.setDirectory(dirEntry.path);
						focusOnFileView();
					}
				}
			}
		}
	} 

	
	class BrowserJTree extends JTree
	{
		
		BrowserJTree(TreeModel model)
		{
			super(model);
			ToolTipManager.sharedInstance().registerComponent(this);
		} 

		
		public final String getToolTipText(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
					return path.getLastPathComponent().toString();
			}
			return null;
		} 

		/* 
		public final Point getToolTipLocation(MouseEvent evt)
		{
			TreePath path = getPathForLocation(evt.getX(), evt.getY());
			if(path != null)
			{
				Rectangle cellRect = getPathBounds(path);
				if(cellRect != null && !cellRectIsVisible(cellRect))
				{
					return new Point(cellRect.x + (showIcons ? 14 : - 4),
						cellRect.y);
				}
			}
			return null;
		} 

		
		public void processKeyEvent(KeyEvent evt)
		{
			
			
			
			
			
			

			if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				switch(evt.getKeyCode())
				{
				case KeyEvent.VK_UP:
				case KeyEvent.VK_DOWN:
					super.processKeyEvent(evt);
					if(browser.getMode() != VFSBrowser.BROWSER)
						browser.filesSelected();
					break;
				case KeyEvent.VK_ENTER:
					browser.filesActivated((evt.isShiftDown()
						? VFSBrowser.M_OPEN_NEW_VIEW
						: VFSBrowser.M_OPEN),false);
					evt.consume();
					break;
				case KeyEvent.VK_LEFT:
					String directory = browser.getDirectory();
					browser.setDirectory(MiscUtilities
						.getParentOfPath(directory));
					evt.consume();
					break;
				}
			}
			else if(evt.getID() == KeyEvent.KEY_TYPED)
			{
				if(evt.isControlDown() || evt.isAltDown()
					|| evt.isMetaDown())
				{
					return;
				}

				
				if(evt.isShiftDown() && evt.getKeyChar() == '\n')
					return;

				switch(evt.getKeyChar())
				{
				case '~':
					browser.setDirectory(System.getProperty(""user.home""));
					break;
				case '/':
					browser.rootDirectory();
					break;
				case '-':
					View view = browser.getView();
					Buffer buffer = view.getBuffer();
					browser.setDirectory(buffer.getDirectory());
					break;
				default:
					typeSelectBuffer.append(evt.getKeyChar());
					doTypeSelect(typeSelectBuffer.toString(),true);

					timer.stop();
					timer.setInitialDelay(750);
					timer.setRepeats(false);
					timer.start();
					break;
				}

				return;
			}

			if(!evt.isConsumed())
				super.processKeyEvent(evt);
		} 

		
		protected void processMouseEvent(MouseEvent evt)
		{
			

			TreePath path = getPathForLocation(evt.getX(),evt.getY());

			switch(evt.getID())
			{
			/* 
			case MouseEvent.MOUSE_ENTERED:
				toolTipInitialDelay = ttm.getInitialDelay();
				toolTipReshowDelay = ttm.getReshowDelay();
				ttm.setInitialDelay(200);
				ttm.setReshowDelay(0);
				super.processMouseEvent(evt);
				break; 
			
			case MouseEvent.MOUSE_EXITED:
				ttm.setInitialDelay(toolTipInitialDelay);
				ttm.setReshowDelay(toolTipReshowDelay);
				super.processMouseEvent(evt);
				break; 
			
			case MouseEvent.MOUSE_CLICKED:
				if(path != null)
				{
					
					
					if((evt.getModifiers() & MouseEvent.BUTTON1_MASK) != 0
						&& evt.getClickCount() % 2 == 0)
					{
						setSelectionPath(path);

						
						
						
						browser.filesActivated((evt.isShiftDown()
							? VFSBrowser.M_OPEN_NEW_VIEW
							: VFSBrowser.M_OPEN),true);
						break;
					}
					else if(GUIUtilities.isMiddleButton(evt.getModifiers()))
					{
						browser.filesActivated((evt.isShiftDown()
							? VFSBrowser.M_OPEN_NEW_VIEW
							: VFSBrowser.M_OPEN),true);
					}
					else if((evt.getModifiers() & MouseEvent.BUTTON1_MASK) != 0)
					{
						if(!isPathSelected(path))
							setSelectionPath(path);
					}

					super.processMouseEvent(evt);
					break;
				}
				else if(GUIUtilities.isPopupTrigger(evt))
					break;
			
			
			case MouseEvent.MOUSE_PRESSED:
				if((evt.getModifiers() & MouseEvent.BUTTON1_MASK) != 0)
				{
					if(evt.getClickCount() % 2 == 0)
						break;
				}

				if(GUIUtilities.isMiddleButton(evt.getModifiers()))
				{
					if(!isPathSelected(path))
						setSelectionPath(path);
				}
				else if(GUIUtilities.isPopupTrigger(evt))
				{
					if(popup != null && popup.isVisible())
					{
						popup.setVisible(false);
						popup = null;
						break;
					}

					if(path == null)
						showFilePopup(null,this,evt.getPoint());
					else
					{
						if(!isPathSelected(path))
							setSelectionPath(path);

						showFilePopup(getSelectedFiles(),this,evt.getPoint());
					}

					break;
				}

				super.processMouseEvent(evt);
				break;
			
			
			case MouseEvent.MOUSE_RELEASED:
				if(!GUIUtilities.isPopupTrigger(evt)
					&& path != null)
				{
					browser.filesSelected();
				}

				if(evt.getClickCount() % 2 != 0)
					super.processMouseEvent(evt);

				break;
			
			default:
				super.processMouseEvent(evt);
				break;
			}
		} 

		
		private int toolTipInitialDelay = -1;
		private int toolTipReshowDelay = -1;

		
		private boolean cellRectIsVisible(Rectangle cellRect)
		{
			Rectangle vr = BrowserJTree.this.getVisibleRect();
			return vr.contains(cellRect.x,cellRect.y) &&
				vr.contains(cellRect.x + cellRect.width,
				cellRect.y + cellRect.height);
		} 

		
		void doTypeSelect(String str, boolean ignoreCase)
		{
			if(getSelectionCount() == 0)
				doTypeSelect(str,0,getRowCount(),ignoreCase);
			else
			{
				int start = getMaxSelectionRow();
				boolean retVal = doTypeSelect(str,start,getRowCount(),
					ignoreCase);

				if(!retVal)
				{
					
					
					doTypeSelect(str,0,start,ignoreCase);
				}
			}
		} 

		
		private boolean doTypeSelect(String str, int start, int end,
			boolean ignoreCase)
		{
			for(int i = start; i < end; i++)
			{
				DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
					getPathForRow(i).getLastPathComponent();
				Object obj = treeNode.getUserObject();
				if(obj instanceof VFS.DirectoryEntry)
				{
					VFS.DirectoryEntry file = (VFS.DirectoryEntry)obj;
					String matchAgainst = (MiscUtilities.isAbsolutePath(str)
						? file.path : file.name);
					if(matchAgainst.regionMatches(ignoreCase,
						0,str,0,str.length()))
					{
						setSelectionRow(i);
						scrollRowToVisible(i);
						return true;
					}
				}
			}

			return false;
		} 

		
	} 

	
	class TreeHandler implements TreeExpansionListener
	{
		
		public void treeExpanded(TreeExpansionEvent evt)
		{
			TreePath path = evt.getPath();
			DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			Object userObject = treeNode.getUserObject();
			if(userObject instanceof VFS.DirectoryEntry)
			{
				loadDirectory(treeNode,((VFS.DirectoryEntry)
					userObject).path,true);
			}
		} 

		
		public void treeCollapsed(TreeExpansionEvent evt)
		{
			TreePath path = evt.getPath();
			DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)
				path.getLastPathComponent();
			if(treeNode.getUserObject() instanceof VFS.DirectoryEntry)
			{
				
				
				
				treeNode.removeAllChildren();
				treeNode.add(new DefaultMutableTreeNode(new LoadingPlaceholder(),false));
				model.reload(treeNode);
			}
		} 
	} 

	static class LoadingPlaceholder {}
	
}
"
jEdit,4.1,org.gjt.sp.jedit.msg.PropertiesChanged,1,2,0,8,2,0,6,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class PropertiesChanged extends EBMessage
{
	
	public PropertiesChanged(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.AbstractOptionPane,14,5,17,20,32,67,18,2,12,0.711538462,395,1.0,0,0.98048048,0.446428571,0,0,26.92857143,2,1.2143,0,"

package org.gjt.sp.jedit;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;






public class AbstractOptionPane extends JPanel implements OptionPane
{
	
	
	public AbstractOptionPane(String name)
	{
		this.name = name;
		setLayout(gridBag = new GridBagLayout());
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public Component getComponent()
	{
		return this;
	} 

	
	
	
	public void init()
	{
		if(!initialized)
		{
			initialized = true;
			_init();
		}
	} 

	
	
	
	public void save()
	{
		if(initialized)
			_save();
	} 

	
	
	public void addComponent(String label, Component comp)
	{
		JLabel l = new JLabel(label);
		l.setBorder(new EmptyBorder(0,0,0,12));
		addComponent(l,comp,GridBagConstraints.BOTH);
	} 

	
	
	public void addComponent(String label, Component comp, int fill)
	{
		JLabel l = new JLabel(label);
		l.setBorder(new EmptyBorder(0,0,0,12));
		addComponent(l,comp,fill);
	} 

	
	
	public void addComponent(Component comp1, Component comp2)
	{
		addComponent(comp1,comp2,GridBagConstraints.BOTH);
	} 

	
	
	public void addComponent(Component comp1, Component comp2, int fill)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = 1;
		cons.weightx = 0.0f;
		cons.insets = new Insets(1,0,1,0);
		cons.fill = GridBagConstraints.BOTH;

		gridBag.setConstraints(comp1,cons);
		add(comp1);

		cons.fill = fill;
		cons.gridx = 1;
		cons.weightx = 1.0f;
		gridBag.setConstraints(comp2,cons);
		add(comp2);
	} 

	
	
	public void addComponent(Component comp)
	{
		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.NONE;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);

		gridBag.setConstraints(comp,cons);
		add(comp);
	} 

	
	
	public void addSeparator()
	{
		if(y != 0)
			addComponent(Box.createVerticalStrut(6));

		JSeparator sep = new JSeparator(JSeparator.HORIZONTAL);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);

		gridBag.setConstraints(sep,cons);
		add(sep);
	} 

	
	
	public void addSeparator(String label)
	{
		if(y != 0)
			addComponent(Box.createVerticalStrut(6));

		Box box = new Box(BoxLayout.X_AXIS);
		Box box2 = new Box(BoxLayout.Y_AXIS);
		box2.add(Box.createGlue());
		box2.add(new JSeparator(JSeparator.HORIZONTAL));
		box2.add(Box.createGlue());
		box.add(box2);
		JLabel l = new JLabel(jEdit.getProperty(label));
		l.setMaximumSize(l.getPreferredSize());
		box.add(l);
		Box box3 = new Box(BoxLayout.Y_AXIS);
		box3.add(Box.createGlue());
		box3.add(new JSeparator(JSeparator.HORIZONTAL));
		box3.add(Box.createGlue());
		box.add(box3);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = y++;
		cons.gridheight = 1;
		cons.gridwidth = cons.REMAINDER;
		cons.fill = GridBagConstraints.BOTH;
		cons.anchor = GridBagConstraints.WEST;
		cons.weightx = 1.0f;
		cons.insets = new Insets(1,0,1,0);

		gridBag.setConstraints(box,cons);
		add(box);
	} 

	
	
	protected boolean initialized;

	
	protected GridBagLayout gridBag;

	
	protected int y;

	
	protected void _init() {}

	
	protected void _save() {}
	

	
	private String name;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.ErrorListCellRenderer,4,4,0,2,24,0,1,1,3,0.444444444,195,1.0,0,0.995377504,0.375,1,3,46.25,2,1.25,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;


class ErrorListCellRenderer extends JComponent implements ListCellRenderer
{
	
	ErrorListCellRenderer()
	{
		plainFont = UIManager.getFont(""Label.font"");
		boldFont = new Font(plainFont.getName(),Font.BOLD,plainFont.getSize());
		plainFM = getFontMetrics(plainFont);
		boldFM = getFontMetrics(boldFont);

		setBorder(new EmptyBorder(2,2,2,2));
	} 

	
	public Component getListCellRendererComponent(JList list, Object value,
		int index, boolean isSelected, boolean cellHasFocus)
	{
		ErrorListDialog.ErrorEntry entry = (ErrorListDialog.ErrorEntry)value;
		this.path = entry.path + "":"";
		this.messages = entry.messages;
		return this;
	} 

	
	public Dimension getPreferredSize()
	{
		int width = boldFM.stringWidth(path);
		int height = boldFM.getHeight();
		for(int i = 0; i < messages.length; i++)
		{
			width = Math.max(plainFM.stringWidth(messages[i]),width);
			height += plainFM.getHeight();
		}

		Insets insets = getBorder().getBorderInsets(this);
		width += insets.left + insets.right;
		height += insets.top + insets.bottom;

		return new Dimension(width,height);
	} 

	
	public void paintComponent(Graphics g)
	{
		Insets insets = getBorder().getBorderInsets(this);
		g.setFont(boldFont);
		g.drawString(path,insets.left,insets.top + boldFM.getAscent());
		int y = insets.top + boldFM.getHeight() + 2;
		g.setFont(plainFont);
		for(int i = 0; i < messages.length; i++)
		{
			g.drawString(messages[i],insets.left,y + plainFM.getAscent());
			y += plainFM.getHeight();
		}
	} 

	
	private String path;
	private String[] messages;
	private Font plainFont;
	private Font boldFont;
	private FontMetrics plainFM;
	private FontMetrics boldFM;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.Macros,27,1,0,20,102,291,6,17,22,0.875,755,0.875,2,0.0,0.125874126,0,0,26.66666667,12,2.5185,1,"

package org.gjt.sp.jedit;


import gnu.regexp.RE;
import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.util.Log;



public class Macros
{
	
	
	public static void showRunScriptDialog(View view)
	{
		String[] paths = GUIUtilities.showVFSFileDialog(view,
			null,JFileChooser.OPEN_DIALOG,true);
		if(paths != null)
		{
			Buffer buffer = view.getBuffer();
			try
			{
				buffer.beginCompoundEdit();

file_loop:			for(int i = 0; i < paths.length; i++)
					runScript(view,paths[i],false);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} 

	
	
	public static void runScript(View view, String path, boolean ignoreUnknown)
	{
		Handler handler = getHandlerForPathName(path);
		if(handler != null)
		{
			try
			{
				Macro newMacro = handler.createMacro(
					MiscUtilities.getFileName(path), path);
				newMacro.invoke(view);
			}
			catch (Exception e)
			{
				Log.log(Log.ERROR, Macros.class, e);
				return;
			}
			return;
		}

		
		
		
		if(ignoreUnknown)
		{
			Log.log(Log.NOTICE,Macros.class,path +
				"": Cannot find a suitable macro handler"");
		}
		else
		{
			Log.log(Log.ERROR,Macros.class,path +
				"": Cannot find a suitable macro handler, ""
				+ ""assuming BeanShell"");
			getHandler(""beanshell"").createMacro(
				path,path).invoke(view);
		}
	} 

	
	
	public static void message(Component comp, String message)
	{
		GUIUtilities.hideSplashScreen();

		JOptionPane.showMessageDialog(comp,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.INFORMATION_MESSAGE);
	} 

	
	
	public static void error(Component comp, String message)
	{
		GUIUtilities.hideSplashScreen();

		JOptionPane.showMessageDialog(comp,message,
			jEdit.getProperty(""macro-message.title""),
			JOptionPane.ERROR_MESSAGE);
	} 

	
	
	public static String input(Component comp, String prompt)
	{
		GUIUtilities.hideSplashScreen();

		return input(comp,prompt,null);
	} 

	
	
	public static String input(Component comp, String prompt, String defaultValue)
	{
		GUIUtilities.hideSplashScreen();

		return (String)JOptionPane.showInputDialog(comp,prompt,
			jEdit.getProperty(""macro-input.title""),
			JOptionPane.QUESTION_MESSAGE,null,null,defaultValue);
	} 

	
	
	public static int confirm(Component comp, String prompt, int buttons)
	{
		GUIUtilities.hideSplashScreen();

		return JOptionPane.showConfirmDialog(comp,prompt,
			jEdit.getProperty(""macro-confirm.title""),buttons,
			JOptionPane.QUESTION_MESSAGE);
	} 

	
	
	public static int confirm(Component comp, String prompt, int buttons, int type)
	{
		GUIUtilities.hideSplashScreen();

		return JOptionPane.showConfirmDialog(comp,prompt,
			jEdit.getProperty(""macro-confirm.title""),buttons,type);
	} 

	
	
	public static void loadMacros()
	{
		macroActionSet.removeAllActions();
		macroHierarchy.removeAllElements();
		macroHash.clear();

		if(jEdit.getJEditHome() != null)
		{
			systemMacroPath = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""macros"");
			loadMacros(macroHierarchy,"""",new File(systemMacroPath));
		}

		String settings = jEdit.getSettingsDirectory();

		if(settings != null)
		{
			userMacroPath = MiscUtilities.constructPath(
				settings,""macros"");
			loadMacros(macroHierarchy,"""",new File(userMacroPath));
		}

		EditBus.send(new MacrosChanged(null));
	} 

	
	
	public static void registerHandler(Handler handler)
	{
		if (getHandler(handler.getName()) != null)
		{
			Log.log(Log.ERROR, Macros.class, ""Cannot register more than one macro handler with the same name"");
			return;
		}

		Log.log(Log.DEBUG,Macros.class,""Registered "" + handler.getName()
			+ "" macro handler"");
		macroHandlers.add(handler);
	} 

	
	
	public static Handler[] getHandlers()
	{
		Handler[] handlers = new Handler[macroHandlers.size()];
		return (Handler[])macroHandlers.toArray(handlers);
	} 

	
	
	public static Handler getHandlerForPathName(String pathName)
	{
		for (int i = 0; i < macroHandlers.size(); i++)
		{
			Handler handler = (Handler)macroHandlers.get(i);
			if (handler.accept(pathName))
				return handler;
		}

		return null;
	} 

	
	
	public static Handler getHandler(String name)
	{
		Handler handler = null;
		for (int i = 0; i < macroHandlers.size(); i++)
		{
			handler = (Handler)macroHandlers.get(i);
			if (handler.getName().equals(name)) return handler;
		}

		return null;
	}
	

	
	
	public static Vector getMacroHierarchy()
	{
		return macroHierarchy;
	} 

	
	
	public static ActionSet getMacroActionSet()
	{
		return macroActionSet;
	} 

	
	
	public static Macro getMacro(String macro)
	{
		return (Macro)macroHash.get(macro);
	} 

	
	
	public static class Macro extends EditAction
	{
		
		public Macro(Handler handler, String name, String label, String path)
		{
			
			
			
			super(name.replace(' ','_'));
			this.handler = handler;
			this.label = label;
			this.path = path;
		} 

		
		public Handler getHandler()
		{
			return handler;
		}
		

		
		public String getLabel()
		{
			return label;
		} 

		
		public String getMouseOverText()
		{
			return handler.getLabel() + "" - "" + path;
		} 

		
		public String getPath()
		{
			return path;
		} 

		
		public void invoke(View view)
		{
			lastMacro = this;

			if(view == null)
				handler.runMacro(null,this);
			else
			{
				Buffer buffer = view.getBuffer();

				try
				{
					buffer.beginCompoundEdit();
					handler.runMacro(view,this);
				}
				finally
				{
					buffer.endCompoundEdit();
				}
			}
		} 

		
		public String getCode()
		{
			return ""Macros.getMacro(\"""" + getName() + ""\"").invoke(view);"";
		} 

		
		public static String macroNameToLabel(String macroName)
		{
			int index = macroName.lastIndexOf('/');
			return macroName.substring(index + 1).replace('_', ' ');
		}
		

		
		private Handler handler;
		private String path;
		private String label;
		
	} 

	
	
	public static void recordTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();

		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}
		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}

		Buffer buffer = jEdit.openFile(null,settings + File.separator
			+ ""macros"",""Temporary_Macro.bsh"",true,null);

		if(buffer == null)
			return;

		buffer.remove(0,buffer.getLength());
		buffer.insert(0,jEdit.getProperty(""macro.temp.header""));

		recordMacro(view,buffer,true);
	} 

	
	
	public static void recordMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();

		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}

		if(view.getMacroRecorder() != null)
		{
			GUIUtilities.error(view,""already-recording"",new String[0]);
			return;
		}

		String name = GUIUtilities.input(view,""record"",null);
		if(name == null)
			return;

		name = name.replace(' ','_');

		Buffer buffer = jEdit.openFile(null,null,
			MiscUtilities.constructPath(settings,""macros"",
			name + "".bsh""),true,null);

		if(buffer == null)
			return;

		buffer.remove(0,buffer.getLength());
		buffer.insert(0,jEdit.getProperty(""macro.header""));

		recordMacro(view,buffer,false);
	} 

	
	
	public static void stopRecording(View view)
	{
		Recorder recorder = view.getMacroRecorder();

		if(recorder == null)
			GUIUtilities.error(view,""macro-not-recording"",null);
		else
		{
			view.setMacroRecorder(null);
			if(!recorder.temporary)
				view.setBuffer(recorder.buffer);
			recorder.dispose();
		}
	} 

	
	
	public static void runTemporaryMacro(View view)
	{
		String settings = jEdit.getSettingsDirectory();

		if(settings == null)
		{
			GUIUtilities.error(view,""no-settings"",new String[0]);
			return;
		}

		String path = MiscUtilities.constructPath(
			jEdit.getSettingsDirectory(),""macros"",
			""Temporary_Macro.bsh"");

		Handler handler = getHandler(""beanshell"");
		Macro temp = handler.createMacro(path,path);

		Buffer buffer = view.getBuffer();

		try
		{
			buffer.beginCompoundEdit();
			temp.invoke(view);
		}
		finally
		{
			
			if(buffer.insideCompoundEdit())
				buffer.endCompoundEdit();
		}
	} 

	
	
	public static void runLastMacro(View view)
	{
		if(lastMacro == null)
			view.getToolkit().beep();
		else
			lastMacro.invoke(view);
	} 

	

	
	private static String systemMacroPath;
	private static String userMacroPath;

	private static ArrayList macroHandlers;

	private static ActionSet macroActionSet;
	private static Vector macroHierarchy;
	private static Hashtable macroHash;
	private static Macro lastMacro;
	

	
	static
	{
		macroHandlers = new ArrayList();
		registerHandler(new BeanShellHandler());
		macroActionSet = new ActionSet(jEdit.getProperty(""action-set.macros""));
		jEdit.addActionSet(macroActionSet);
		macroHierarchy = new Vector();
		macroHash = new Hashtable();
	} 

	
	private static void loadMacros(Vector vector, String path, File directory)
	{
		File[] macroFiles = directory.listFiles();
		if(macroFiles == null || macroFiles.length == 0)
			return;

		for(int i = 0; i < macroFiles.length; i++)
		{
			File file = macroFiles[i];
			String fileName = file.getName();
			if(file.isHidden())
			{
				
				continue;
			}
			else if(file.isDirectory())
			{
				String submenuName = fileName.replace('_',' ');
				Vector submenu = null;
				
				for(int j = 0; j < vector.size(); j++)
				{
					Object obj = vector.get(j);
					if(obj instanceof Vector)
					{
						Vector vec = (Vector)obj;
						if(((String)vec.get(0)).equals(submenuName))
						{
							submenu = vec;
							break;
						}
					}
				} 
				if(submenu == null)
				{
					submenu = new Vector();
					submenu.addElement(submenuName);
					vector.addElement(submenu);
				}

				loadMacros(submenu,path + fileName + '/',file);
			}
			else
			{
				Handler handler = getHandlerForPathName(file.getPath());

				if(handler == null)
					continue;

				try
				{
					Macro newMacro = handler.createMacro(
						path + fileName, file.getPath());
					vector.addElement(newMacro);
					macroActionSet.addAction(newMacro);
					macroHash.put(newMacro.getName(),newMacro);
				}
				catch (Exception e)
				{
					Log.log(Log.ERROR, Macros.class, e);
					macroHandlers.remove(handler);
				}
			}
		}
	} 

	
	
	private static void recordMacro(View view, Buffer buffer, boolean temporary)
	{
		Handler handler = getHandler(""beanshell"");
		String path = buffer.getPath();
		lastMacro = handler.createMacro(path,path);

		view.setMacroRecorder(new Recorder(view,buffer,temporary));

		
		
		view.getStatus().setMessage(null);
	} 

	

	
	
	public static class Recorder implements EBComponent
	{
		View view;
		Buffer buffer;
		boolean temporary;

		boolean lastWasInput;

		
		public Recorder(View view, Buffer buffer, boolean temporary)
		{
			this.view = view;
			this.buffer = buffer;
			this.temporary = temporary;
			EditBus.addToBus(this);
		} 

		
		public void record(String code)
		{
			if(lastWasInput)
			{
				lastWasInput = false;
				append(""\"");"");
			}

			append(""\n"");
			append(code);
		} 

		
		public void record(int repeat, String code)
		{
			if(repeat == 1)
				record(code);
			else
			{
				record(""for(int i = 1; i <= "" + repeat + ""; i++)\n""
					+ ""{\n""
					+ code + ""\n""
					+ ""}"");
			}
		} 

		
		public void record(int repeat, char ch)
		{
			
			
			if(ch == '\n')
				record(repeat,""textArea.userInput(\'\\n\');"");
			else if(ch == '\t')
				record(repeat,""textArea.userInput(\'\\t\');"");
			else
			{
				StringBuffer buf = new StringBuffer();
				for(int i = 0; i < repeat; i++)
					buf.append(ch);
				String charStr = MiscUtilities.charsToEscapes(buf.toString());

				if(lastWasInput)
					append(charStr);
				else
				{
					append(""\ntextArea.setSelectedText(\"""" + charStr);
					lastWasInput = true;
				}
			}
		} 

		
		public void handleMessage(EBMessage msg)
		{
			if(msg instanceof BufferUpdate)
			{
				BufferUpdate bmsg = (BufferUpdate)msg;
				if(bmsg.getWhat() == BufferUpdate.CLOSED)
				{
					if(bmsg.getBuffer() == buffer)
						stopRecording(view);
				}
			}
		} 

		
		private void append(String str)
		{
			buffer.insert(buffer.getLength(),str);
		} 

		
		private void dispose()
		{
			if(lastWasInput)
			{
				lastWasInput = false;
				append(""\"");"");
			}

			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				buffer.indentLine(i,true,true);
			}

			EditBus.removeFromBus(this);

			
			
			view.getStatus().setMessage(null);
		} 
	} 

	
	
	public static abstract class Handler
	{
		
		public String getName()
		{
			return name;
		} 

		
		public String getLabel()
		{
			return label;
		} 

		
		public boolean accept(String path)
		{
			return filter.isMatch(MiscUtilities.getFileName(path));
		} 

		
		public abstract Macro createMacro(String macroName, String path);
		

		
		
		public abstract void runMacro(View view, Macro macro);
		

		
		
		public void runMacro(View view, Macro macro, boolean ownNamespace)
		{
			runMacro(view,macro);
		} 

		
		protected Handler(String name)
		{
			this.name = name;
			label = jEdit.getProperty(""macro-handler.""
				+ name + "".label"", name);
			try
			{
				filter = new RE(MiscUtilities.globToRE(
					jEdit.getProperty(
					""macro-handler."" + name + "".glob"")));
			}
			catch (Exception e)
			{
				throw new InternalError(""Missing or invalid glob for handler "" + name);
			}
		} 

		
		private String name;
		private String label;
		private RE filter;
		
	} 

	
	static class BeanShellHandler extends Handler
	{
		
		BeanShellHandler()
		{
			super(""beanshell"");
		} 

		
		public Macro createMacro(String macroName, String path)
		{
			
			macroName = macroName.substring(0, macroName.length() - 4);

			return new Macro(this, macroName,
				Macro.macroNameToLabel(macroName), path);
		} 

		
		public void runMacro(View view, Macro macro)
		{
			BeanShell.runScript(view,macro.getPath(),null,true);
		} 

		
		public void runMacro(View view, Macro macro, boolean ownNamespace)
		{
			BeanShell.runScript(view,macro.getPath(),null,ownNamespace);
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.search.BufferListSet,8,1,2,5,12,8,2,3,7,0.428571429,149,1.0,0,0.0,0.4375,0,0,17.5,9,2.875,1,"

package org.gjt.sp.jedit.search;


import java.awt.Component;
import org.gjt.sp.jedit.View;



public abstract class BufferListSet implements SearchFileSet
{
	
	public synchronized String getFirstFile(View view)
	{
		if(files == null)
			files = _getFiles(view);

		if(files == null || files.length == 0)
			return null;
		else
			return files[0];
	} 

	
	public synchronized String getNextFile(View view, String file)
	{
		if(files == null)
			files = _getFiles(view);

		if(files == null || files.length == 0)
			return null;

		if(file == null)
		{
			file = view.getBuffer().getPath();

			for(int i = 0; i < files.length; i++)
			{
				if(files[i].equals(file))
					return file;
			}

			return getFirstFile(view);
		}
		else
		{
			
			for(int i = 0; i < files.length - 1; i++)
			{
				if(files[i].equals(file))
					return files[i+1];
			}

			return null;
		}
	} 

	
	public synchronized String[] getFiles(View view)
	{
		if(files == null)
			files = _getFiles(view);

		if(files == null || files.length == 0)
			return null;
		else
			return files;
	} 

	
	public synchronized int getFileCount(View view)
	{
		if(files == null)
			files = _getFiles(view);

		if(files == null)
			return 0;
		else
			return files.length;
	} 

	
	public String getCode()
	{
		
		return null;
	} 

	
	public void invalidateCachedList()
	{
		files = null;
	} 

	protected abstract String[] _getFiles(Component comp);

	private String[] files;
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.DefaultTokenHandler,7,1,2,9,10,15,4,5,4,0.583333333,81,1.0,2,0.0,0.457142857,0,0,10.28571429,3,1.4286,0,"

package org.gjt.sp.jedit.syntax;


public class DefaultTokenHandler implements TokenHandler
{
	
	
	public void init()
	{
		lastToken = firstToken = null;
	} 

	
	
	public Token getTokens()
	{
		return firstToken;
	} 

	
	
	public void handleToken(byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		Token token = createToken(id,offset,length,context);
		if(token != null)
			addToken(token,context);
	} 

	
	protected Token firstToken, lastToken;

	
	protected ParserRuleSet getParserRuleSet(TokenMarker.LineContext context)
	{
		while(context != null)
		{
			if(context.rules.getMode() != null)
				return context.rules;

			context = context.parent;
		}

		return null;
	} 

	
	protected Token createToken(byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		return new Token(id,offset,length,getParserRuleSet(context));
	} 

	
	protected void addToken(Token token, TokenMarker.LineContext context)
	{
		if(firstToken == null)
		{
			firstToken = lastToken = token;
		}
		else
		{
			lastToken.next = token;
			lastToken = lastToken.next;
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.textarea.TextAreaExtension,4,1,5,9,5,6,9,0,4,2.0,11,0.0,0,0.0,0.75,0,0,1.75,1,0.75,0,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;


public abstract class TextAreaExtension
{
	
	
	public void paintValidLine(Graphics2D gfx, int screenLine,
		int physicalLine, int start, int end, int y) {} 

	
	
	public void paintInvalidLine(Graphics2D gfx, int screenLine,
		int y) {} 

	
	
	public String getToolTipText(int x, int y)
	{
		return null;
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.search.SearchAndReplace,32,1,0,38,123,210,11,31,29,0.683870968,1566,0.9,2,0.0,0.13671875,0,0,47.625,31,4.25,3,"

package org.gjt.sp.jedit.search;


import bsh.BshMethod;
import java.awt.Component;
import javax.swing.JOptionPane;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class SearchAndReplace
{
	

	
	
	public static void setSearchString(String search)
	{
		if(search.equals(SearchAndReplace.search))
			return;

		SearchAndReplace.search = search;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static String getSearchString()
	{
		return search;
	} 

	
	
	public static void setReplaceString(String replace)
	{
		if(replace.equals(SearchAndReplace.replace))
			return;

		SearchAndReplace.replace = replace;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static String getReplaceString()
	{
		return replace;
	} 

	
	
	public static void setIgnoreCase(boolean ignoreCase)
	{
		if(ignoreCase == SearchAndReplace.ignoreCase)
			return;

		SearchAndReplace.ignoreCase = ignoreCase;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getIgnoreCase()
	{
		return ignoreCase;
	} 

	
	
	public static void setRegexp(boolean regexp)
	{
		if(regexp == SearchAndReplace.regexp)
			return;

		SearchAndReplace.regexp = regexp;
		if(regexp && reverse)
			reverse = false;

		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getRegexp()
	{
		return regexp;
	} 

	
	
	public static void setReverseSearch(boolean reverse)
	{
		if(reverse == SearchAndReplace.reverse)
			return;

		SearchAndReplace.reverse = (regexp ? false : reverse);

		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getReverseSearch()
	{
		return reverse;
	} 

	
	
	public static void setBeanShellReplace(boolean beanshell)
	{
		if(beanshell == SearchAndReplace.beanshell)
			return;

		SearchAndReplace.beanshell = beanshell;
		matcher = null;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getBeanShellReplace()
	{
		return beanshell;
	} 

	
	
	public static void setAutoWrapAround(boolean wrap)
	{
		if(wrap == SearchAndReplace.wrap)
			return;

		SearchAndReplace.wrap = wrap;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static boolean getAutoWrapAround()
	{
		return wrap;
	} 

	
	
	public static void setSearchMatcher(SearchMatcher matcher)
	{
		SearchAndReplace.matcher = matcher;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static SearchMatcher getSearchMatcher()
		throws Exception
	{
		if(matcher != null)
			return matcher;

		if(search == null || """".equals(search))
			return null;

		
		String replace = (SearchAndReplace.replace == null ? """" : SearchAndReplace.replace);

		BshMethod replaceMethod;
		if(beanshell && replace.length() != 0)
		{
			replaceMethod = BeanShell.cacheBlock(""replace"",""return (""
				+ replace + "");"",true);
		}
		else
			replaceMethod = null;

		if(regexp)
			matcher = new RESearchMatcher(search,replace,ignoreCase,
				beanshell,replaceMethod);
		else
		{
			matcher = new BoyerMooreSearchMatcher(search,replace,
				ignoreCase,beanshell,replaceMethod);
		}

		return matcher;
	} 

	
	
	public static void setSearchFileSet(SearchFileSet fileset)
	{
		SearchAndReplace.fileset = fileset;

		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static SearchFileSet getSearchFileSet()
	{
		return fileset;
	} 

	

	

	
	
	public static boolean hyperSearch(View view)
	{
		return hyperSearch(view,false);
	} 

	
	
	public static boolean hyperSearch(View view, boolean selection)
	{
		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;

		record(view,""hyperSearch(view,"" + selection + "")"",false,
			!selection);

		view.getDockableWindowManager().addDockableWindow(
			HyperSearchResults.NAME);
		final HyperSearchResults results = (HyperSearchResults)
			view.getDockableWindowManager()
			.getDockable(HyperSearchResults.NAME);
		results.searchStarted();

		try
		{
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
			{
				view.getToolkit().beep();
				results.searchFailed();
				return false;
			}

			Selection[] s;
			if(selection)
			{
				s = view.getTextArea().getSelection();
				if(s == null)
				{
					results.searchFailed();
					return false;
				}
			}
			else
				s = null;
			VFSManager.runInWorkThread(new HyperSearchRequest(view,
				matcher,results,s));
			return true;
		}
		catch(Exception e)
		{
			results.searchFailed();
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(comp,""searcherror"",args);
			return false;
		}
	} 

	
	
	public static boolean find(View view)
	{
		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;

		boolean repeat = false;
		String path = fileset.getNextFile(view,null);
		if(path == null)
		{
			GUIUtilities.error(comp,""empty-fileset"",null);
			return false;
		}

		try
		{
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
			{
				view.getToolkit().beep();
				return false;
			}

			record(view,""find(view)"",false,true);

			view.showWaitCursor();

			boolean _reverse = reverse && fileset instanceof CurrentBufferSet;

loop:			for(;;)
			{
				while(path != null)
				{
					Buffer buffer = jEdit.openTemporary(
						view,null,path,false);

					
					path = fileset.getNextFile(view,path);

					if(buffer == null)
						continue loop;

					
					if(!buffer.isLoaded())
						VFSManager.waitForRequests();

					int start;

					if(view.getBuffer() == buffer && !repeat)
					{
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else if(_reverse)
							start = s.getStart();
						else
							start = s.getEnd();
					}
					else if(_reverse)
						start = buffer.getLength();
					else
						start = 0;

					if(find(view,buffer,start,repeat,_reverse))
						return true;
				}

				if(repeat)
				{
					if(!BeanShell.isScriptRunning())
					{
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(""view.status.search-not-found""));

						view.getToolkit().beep();
					}
					return false;
				}

				boolean restart;

				if(BeanShell.isScriptRunning())
				{
					restart = true;
				}
				else if(wrap)
				{
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(""view.status.auto-wrap""));
					
					if(jEdit.getBooleanProperty(""search.beepOnSearchAutoWrap""))
					{
						view.getToolkit().beep();
					}
					restart = true;
				}
				else
				{
					Integer[] args = { new Integer(_reverse ? 1 : 0) };
					int result = GUIUtilities.confirm(comp,
						""keepsearching"",args,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					restart = (result == JOptionPane.YES_OPTION);
				}

				if(restart)
				{
					
					path = fileset.getFirstFile(view);
					repeat = true;
				}
				else
					break loop;
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(comp,""searcherror"",args);
		}
		finally
		{
			view.hideWaitCursor();
		}

		return false;
	} 

	
	
	public static boolean find(View view, Buffer buffer, int start)
		throws Exception
	{
		return find(view,buffer,start,false,false);
	} 

	
	
	public static boolean find(View view, Buffer buffer, int start,
		boolean firstTime, boolean reverse) throws Exception
	{
		SearchMatcher matcher = getSearchMatcher();
		if(matcher == null)
		{
			view.getToolkit().beep();
			return false;
		}

		Segment text = new Segment();
		if(reverse)
			buffer.getText(0,start,text);
		else
			buffer.getText(start,buffer.getLength() - start,text);

		
		
		
		
		
		int[] match = matcher.nextMatch(new CharIndexedSegment(text,reverse),
			start == 0,true,firstTime,reverse);

		if(match != null)
		{
			jEdit.commitTemporary(buffer);
			view.setBuffer(buffer);
			JEditTextArea textArea = view.getTextArea();

			if(reverse)
			{
				textArea.setSelection(new Selection.Range(
					start - match[1],
					start - match[0]));
				textArea.moveCaretPosition(start - match[1]);
			}
			else
			{
				textArea.setSelection(new Selection.Range(
					start + match[0],
					start + match[1]));
				textArea.moveCaretPosition(start + match[1]);
			}

			return true;
		}
		else
			return false;
	} 

	
	
	public static boolean replace(View view)
	{
		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;

		JEditTextArea textArea = view.getTextArea();

		Buffer buffer = view.getBuffer();
		if(!buffer.isEditable())
			return false;

		boolean smartCaseReplace = (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);

		Selection[] selection = textArea.getSelection();
		if(selection.length == 0)
		{
			view.getToolkit().beep();
			return false;
		}

		record(view,""replace(view)"",true,false);

		
		int caret = textArea.getCaretPosition();
		Selection s = textArea.getSelectionAtOffset(caret);
		if(s != null)
			caret = s.getStart();

		try
		{
			buffer.beginCompoundEdit();

			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
				return false;

			int retVal = 0;

			for(int i = 0; i < selection.length; i++)
			{
				s = selection[i];

				
				int start = s.getStart();

				if(s instanceof Selection.Range)
				{
					retVal += _replace(view,buffer,matcher,
						s.getStart(),s.getEnd(),
						smartCaseReplace);

					textArea.removeFromSelection(s);
					textArea.addToSelection(new Selection.Range(
						start,s.getEnd()));
				}
				else if(s instanceof Selection.Rect)
				{
					for(int j = s.getStartLine(); j <= s.getEndLine(); j++)
					{
						retVal += _replace(view,buffer,matcher,
							s.getStart(buffer,j),s.getEnd(buffer,j),
							smartCaseReplace);
					}
					textArea.addToSelection(new Selection.Rect(
						start,s.getEnd()));
				}
			}

			if(reverse)
			{
				
				
				textArea.moveCaretPosition(caret);
			}
			else
			{
				s = textArea.getSelectionAtOffset(
					textArea.getCaretPosition());
				if(s != null)
					textArea.moveCaretPosition(s.getEnd());
			}

			if(retVal == 0)
			{
				view.getToolkit().beep();
				return false;
			}

			return true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(comp,""searcherror"",args);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		return false;
	} 

	
	
	public static boolean replace(View view, Buffer buffer, int start, int end)
	{
		if(!buffer.isEditable())
			return false;

		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;

		boolean smartCaseReplace = (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);

		try
		{
			buffer.beginCompoundEdit();

			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
				return false;

			int retVal = 0;

			retVal += _replace(view,buffer,matcher,start,end,
				smartCaseReplace);

			if(retVal != 0)
				return true;
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(comp,""searcherror"",args);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		return false;
	} 

	
	
	public static boolean replaceAll(View view)
	{
		
		Component comp = SearchDialog.getSearchDialog(view);
		if(comp == null)
			comp = view;

		int fileCount = 0;
		int occurCount = 0;

		if(fileset.getFileCount(view) == 0)
		{
			GUIUtilities.error(comp,""empty-fileset"",null);
			return false;
		}

		record(view,""replaceAll(view)"",true,true);

		view.showWaitCursor();

		boolean smartCaseReplace = (replace != null
			&& TextUtilities.getStringCase(replace)
			== TextUtilities.LOWER_CASE);

		try
		{
			SearchMatcher matcher = getSearchMatcher();
			if(matcher == null)
				return false;

			String path = fileset.getFirstFile(view);
loop:			while(path != null)
			{
				Buffer buffer = jEdit.openTemporary(
					view,null,path,false);

				
				path = fileset.getNextFile(view,path);

				if(buffer == null)
					continue loop;

				
				if(buffer.isPerformingIO())
					VFSManager.waitForRequests();

				if(!buffer.isEditable())
					continue loop;

				
				
				int retVal = 0;

				try
				{
					buffer.beginCompoundEdit();
					retVal = _replace(view,buffer,matcher,
						0,buffer.getLength(),
						smartCaseReplace);
				}
				finally
				{
					buffer.endCompoundEdit();
				}

				if(retVal != 0)
				{
					fileCount++;
					occurCount += retVal;
					jEdit.commitTemporary(buffer);
				}
			}
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,SearchAndReplace.class,e);
			Object[] args = { e.getMessage() };
			if(args[0] == null)
				args[0] = e.toString();
			GUIUtilities.error(comp,""searcherror"",args);
		}
		finally
		{
			view.hideWaitCursor();
		}

		
		if(!BeanShell.isScriptRunning())
		{
			Object[] args = { new Integer(occurCount),
				new Integer(fileCount) };
			view.getStatus().setMessageAndClear(jEdit.getProperty(
				""view.status.replace-all"",args));
			if(occurCount == 0)
				view.getToolkit().beep();
		}

		return (fileCount != 0);
	} 

	

	
	
	public static void load()
	{
		search = jEdit.getProperty(""search.find.value"");
		replace = jEdit.getProperty(""search.replace.value"");
		ignoreCase = jEdit.getBooleanProperty(""search.ignoreCase.toggle"");
		regexp = jEdit.getBooleanProperty(""search.regexp.toggle"");
		beanshell = jEdit.getBooleanProperty(""search.beanshell.toggle"");
		wrap = jEdit.getBooleanProperty(""search.wrap.toggle"");

		fileset = new CurrentBufferSet();

		
		
		
		matcher = null;
		EditBus.send(new SearchSettingsChanged(null));
	} 

	
	
	public static void save()
	{
		jEdit.setProperty(""search.find.value"",search);
		jEdit.setProperty(""search.replace.value"",replace);
		jEdit.setBooleanProperty(""search.ignoreCase.toggle"",ignoreCase);
		jEdit.setBooleanProperty(""search.regexp.toggle"",regexp);
		jEdit.setBooleanProperty(""search.beanshell.toggle"",beanshell);
		jEdit.setBooleanProperty(""search.wrap.toggle"",wrap);
	} 

	

	
	private static String search;
	private static String replace;
	private static boolean regexp;
	private static boolean ignoreCase;
	private static boolean reverse;
	private static boolean beanshell;
	private static boolean wrap;
	private static SearchMatcher matcher;
	private static SearchFileSet fileset;
	

	
	private static void record(View view, String action,
		boolean replaceAction, boolean recordFileSet)
	{
		Macros.Recorder recorder = view.getMacroRecorder();

		if(recorder != null)
		{
			recorder.record(""SearchAndReplace.setSearchString(\""""
				+ MiscUtilities.charsToEscapes(search) + ""\"");"");

			if(replaceAction)
			{
				recorder.record(""SearchAndReplace.setReplaceString(\""""
					+ MiscUtilities.charsToEscapes(replace) + ""\"");"");
				recorder.record(""SearchAndReplace.setBeanShellReplace(""
					+ beanshell + "");"");
			}
			else
			{
				
				recorder.record(""SearchAndReplace.setAutoWrapAround(""
					+ wrap + "");"");
				recorder.record(""SearchAndReplace.setReverseSearch(""
					+ reverse + "");"");
			}

			recorder.record(""SearchAndReplace.setIgnoreCase(""
				+ ignoreCase + "");"");
			recorder.record(""SearchAndReplace.setRegexp(""
				+ regexp + "");"");

			if(recordFileSet)
			{
				recorder.record(""SearchAndReplace.setSearchFileSet(""
					+ fileset.getCode() + "");"");
			}

			recorder.record(""SearchAndReplace."" + action + "";"");
		}
	} 

	
	
	private static int _replace(View view, Buffer buffer,
		SearchMatcher matcher, int start, int end,
		boolean smartCaseReplace)
		throws Exception
	{
		int occurCount = 0;

		boolean endOfLine = (buffer.getLineEndOffset(
			buffer.getLineOfOffset(end)) - 1 == end);

		Segment text = new Segment();
		int offset = start;
loop:		for(int counter = 0; ; counter++)
		{
			buffer.getText(offset,end - offset,text);

			boolean startOfLine = (buffer.getLineStartOffset(
				buffer.getLineOfOffset(offset)) == offset);

			int[] occur = matcher.nextMatch(
				new CharIndexedSegment(text,false),
				startOfLine,endOfLine,counter == 0,
				false);
			if(occur == null)
				break loop;
			int _start = occur[0];
			int _length = occur[1] - occur[0];

			String found = new String(text.array,text.offset + _start,_length);
			String subst = matcher.substitute(found);
			if(smartCaseReplace && ignoreCase)
			{
				int strCase = TextUtilities.getStringCase(found);
				if(strCase == TextUtilities.LOWER_CASE)
					subst = subst.toLowerCase();
				else if(strCase == TextUtilities.UPPER_CASE)
					subst = subst.toUpperCase();
				else if(strCase == TextUtilities.TITLE_CASE)
					subst = TextUtilities.toTitleCase(subst);
			}

			if(subst != null)
			{
				buffer.remove(offset + _start,_length);
				buffer.insert(offset + _start,subst);
				occurCount++;
				offset += _start + subst.length();

				end += (subst.length() - found.length());
			}
			else
				offset += _start + _length;
		}

		return occurCount;
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.help.HelpViewer,15,6,0,13,97,65,9,11,6,0.738095238,512,1.0,1,0.98173516,0.253333333,1,1,32.53333333,8,1.2667,0,"

package org.gjt.sp.jedit.help;


import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.text.html.*;
import java.awt.*;
import java.awt.event.*;
import java.beans.*;
import java.io.*;
import java.net.*;
import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class HelpViewer extends JFrame 
{
	
	
	public HelpViewer()
	{
		this(""welcome.html"");
	} 

	
	
	public HelpViewer(URL url)
	{
		this(url.toString());
	} 

	
	
	public HelpViewer(String url)
	{
		super(jEdit.getProperty(""helpviewer.title""));

		setIconImage(GUIUtilities.getEditorIcon());

		try
		{
			baseURL = new File(MiscUtilities.constructPath(
				jEdit.getJEditHome(),""doc"")).toURL().toString();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			
		}

		history = new String[25];

		ActionHandler actionListener = new ActionHandler();

		JTabbedPane tabs = new JTabbedPane();
		tabs.addTab(jEdit.getProperty(""helpviewer.toc.label""),
			toc = new HelpTOCPanel(this));
		tabs.addTab(jEdit.getProperty(""helpviewer.search.label""),
			new HelpSearchPanel(this));
		tabs.setMinimumSize(new Dimension(0,0));

		JPanel rightPanel = new JPanel(new BorderLayout());

		JToolBar toolBar = new JToolBar();
		toolBar.setFloatable(false);

		toolBar.add(title = new JLabel());
		toolBar.add(Box.createGlue());

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(0,12,0,0));
		back = new RolloverButton(GUIUtilities.loadIcon(
			jEdit.getProperty(""helpviewer.back.icon"")));
		back.setToolTipText(jEdit.getProperty(""helpviewer.back.label""));
		back.addActionListener(actionListener);
		toolBar.add(back);
		forward = new RolloverButton(GUIUtilities.loadIcon(
			jEdit.getProperty(""helpviewer.forward.icon"")));
		forward.addActionListener(actionListener);
		forward.setToolTipText(jEdit.getProperty(""helpviewer.forward.label""));
		toolBar.add(forward);
		back.setPreferredSize(forward.getPreferredSize());

		rightPanel.add(BorderLayout.NORTH,toolBar);

		viewer = new JEditorPane();
		viewer.setEditable(false);
		viewer.addHyperlinkListener(new LinkHandler());
		viewer.setFont(new Font(""Monospaced"",Font.PLAIN,12));
		viewer.addPropertyChangeListener(new PropertyChangeHandler());

		rightPanel.add(BorderLayout.CENTER,new JScrollPane(viewer));

		splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
			tabs,rightPanel);
		splitter.setBorder(null);

		getContentPane().add(BorderLayout.CENTER,splitter);

		gotoURL(url,true);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		getRootPane().setPreferredSize(new Dimension(800,400));

		pack();
		GUIUtilities.loadGeometry(this,""helpviewer"");

		

		show();

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				splitter.setDividerLocation(jEdit.getIntegerProperty(
					""helpviewer.splitter"",250));
				viewer.requestFocus();
			}
		});
	} 

	
	
	public void gotoURL(String url, boolean addToHistory)
	{
		
		
		String shortURL;
		if(MiscUtilities.isURL(url))
		{
			if(url.startsWith(baseURL))
			{
				shortURL = url.substring(baseURL.length());
				if(shortURL.startsWith(""/""))
					shortURL = shortURL.substring(1);
			}
			else
			{
				shortURL = url;
			}
		}
		else
		{
			shortURL = url;
			if(baseURL.endsWith(""/""))
				url = baseURL + url;
			else
				url = baseURL + '/' + url;
		}

		
		
		viewer.setCursor(Cursor.getDefaultCursor());

		URL _url = null;
		try
		{
			_url = new URL(url);

			if(!_url.equals(viewer.getPage()))
				title.setText(jEdit.getProperty(""helpviewer.loading""));
			else
			{
				
			}

			viewer.setPage(_url);
			if(addToHistory)
			{
				history[historyPos] = url;
				if(historyPos + 1 == history.length)
				{
					System.arraycopy(history,1,history,
						0,history.length - 1);
					history[historyPos] = null;
				}
				else
					historyPos++;
			}
		}
		catch(MalformedURLException mf)
		{
			Log.log(Log.ERROR,this,mf);
			String[] args = { url, mf.getMessage() };
			GUIUtilities.error(this,""badurl"",args);
			return;
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,this,io);
			String[] args = { url, io.toString() };
			GUIUtilities.error(this,""read-error"",args);
			return;
		}

		
		if(shortURL != null)
			toc.selectNode(shortURL);
	} 

	
	public void dispose()
	{
		
		jEdit.setIntegerProperty(""helpviewer.splitter"",
			splitter.getDividerLocation());
		GUIUtilities.saveGeometry(this,""helpviewer"");
		super.dispose();
	} 

	
	 

	
	public String getBaseURL()
	{
		return baseURL;
	} 

	
	private String baseURL;
	private JButton back;
	private JButton forward;
	private JEditorPane viewer;
	private JLabel title;
	private JSplitPane splitter;
	private String[] history;
	private int historyPos;
	private HelpTOCPanel toc;
	

	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == back)
			{
				if(historyPos <= 1)
					getToolkit().beep();
				else
				{
					String url = history[--historyPos - 1];
					gotoURL(url,false);
				}
			}
			else if(source == forward)
			{
				if(history.length - historyPos <= 1)
					getToolkit().beep();
				else
				{
					String url = history[historyPos];
					if(url == null)
						getToolkit().beep();
					else
					{
						historyPos++;
						gotoURL(url,false);
					}
				}
			}
		} 
	} 

	
	class LinkHandler implements HyperlinkListener
	{
		
		public void hyperlinkUpdate(HyperlinkEvent evt)
		{
			if(evt.getEventType() == HyperlinkEvent.EventType.ACTIVATED)
			{
				if(evt instanceof HTMLFrameHyperlinkEvent)
				{
					((HTMLDocument)viewer.getDocument())
						.processHTMLFrameHyperlinkEvent(
						(HTMLFrameHyperlinkEvent)evt);
				}
				else
				{
					URL url = evt.getURL();
					if(url != null)
						gotoURL(url.toString(),true);
				}
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.ENTERED) {
				viewer.setCursor(Cursor.getPredefinedCursor(Cursor.HAND_CURSOR));
			}
			else if (evt.getEventType() == HyperlinkEvent.EventType.EXITED) {
				viewer.setCursor(Cursor.getDefaultCursor());
			}
		} 
	} 

	
	class PropertyChangeHandler implements PropertyChangeListener
	{
		public void propertyChange(PropertyChangeEvent evt)
		{
			if(""page"".equals(evt.getPropertyName()))
			{
				String titleStr = (String)viewer.getDocument()
					.getProperty(""title"");
				if(titleStr == null)
				{
					titleStr = MiscUtilities.getFileName(
						viewer.getPage().toString());
				}
				title.setText(titleStr);
			}
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.options.BrowserColorsOptionPane,9,6,0,10,48,18,4,9,1,0.71875,210,1.0,1,0.988183161,0.5,4,12,21.88888889,2,1.0,0,"

package org.gjt.sp.jedit.options;


import javax.swing.border.EmptyBorder;
import javax.swing.event.*;
import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.RolloverButton;
import org.gjt.sp.jedit.*;




public class BrowserColorsOptionPane extends AbstractOptionPane
{
	
	public BrowserColorsOptionPane()
	{
		super(""browser.colors"");
	} 

	

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		colorsModel = new BrowserColorsModel();
		colorsTable = new JTable(colorsModel);
		colorsTable.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
		colorsTable.getTableHeader().setReorderingAllowed(false);
		colorsTable.addMouseListener(new MouseHandler());
		colorsTable.getSelectionModel().addListSelectionListener(
			new SelectionHandler());
		TableColumnModel tcm = colorsTable.getColumnModel();
		tcm.getColumn(1).setCellRenderer(new BrowserColorsModel.ColorRenderer());
		Dimension d = colorsTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(colorsTable);
		scroller.setPreferredSize(d);
		add(BorderLayout.CENTER,scroller);

		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		ActionHandler actionHandler = new ActionHandler();
		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""options.browser.colors.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""options.browser.colors.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createGlue());

		add(BorderLayout.SOUTH,buttons);

		updateEnabled();
	} 

	
	protected void _save()
	{
		colorsModel.save();
	} 

	

	
	private BrowserColorsModel colorsModel;
	private JTable colorsTable;
	private JButton add;
	private JButton remove;

	
	private void updateEnabled()
	{
		int selectedRow = colorsTable.getSelectedRow();
		remove.setEnabled(selectedRow != -1);
	} 

	

	
	class SelectionHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateEnabled();
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == add)
			{
				colorsModel.add();
			}
			else if(source == remove)
			{
				int selectedRow = colorsTable.getSelectedRow();
				colorsModel.remove(selectedRow);
				updateEnabled();
			}
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			Point p = evt.getPoint();
			int row = colorsTable.rowAtPoint(p);
			int column = colorsTable.columnAtPoint(p);
			if(row == -1 || column != 1)
				return;

			Color color = JColorChooser.showDialog(
				BrowserColorsOptionPane.this,
				jEdit.getProperty(""colorChooser.title""),
				(Color)colorsModel.getValueAt(row,1));
			if(color != null)
				colorsModel.setValueAt(color,row,1);
		}
	} 
} 


class BrowserColorsModel extends AbstractTableModel
{
	Vector entries;

	
	BrowserColorsModel()
	{
		entries = new Vector();

		int i = 0;
		String glob;
		while((glob = jEdit.getProperty(""vfs.browser.colors."" + i + "".glob"")) != null)
		{
			entries.addElement(new Entry(glob,
				jEdit.getColorProperty(
				""vfs.browser.colors."" + i + "".color"",
				Color.black)));
			i++;
		}
	} 

	
	void add()
	{
		entries.addElement(new Entry("""",UIManager.getColor(""Tree.foreground"")));
		fireTableRowsInserted(entries.size() - 1,entries.size() - 1);
	} 

	
	void remove(int index)
	{
		entries.removeElementAt(index);
		fireTableRowsDeleted(entries.size(),entries.size());
	} 

	
	void save()
	{
		int i;
		for(i = 0; i < entries.size(); i++)
		{
			Entry entry = (Entry)entries.elementAt(i);
			jEdit.setProperty(""vfs.browser.colors."" + i + "".glob"",
				entry.glob);
			jEdit.setColorProperty(""vfs.browser.colors."" + i + "".color"",
				entry.color);
		}
		jEdit.unsetProperty(""vfs.browser.colors."" + i + "".glob"");
		jEdit.unsetProperty(""vfs.browser.colors."" + i + "".color"");
	} 

	
	public int getColumnCount()
	{
		return 2;
	} 

	
	public int getRowCount()
	{
		return entries.size();
	} 

	
	public Object getValueAt(int row, int col)
	{
		Entry entry = (Entry)entries.elementAt(row);

		switch(col)
		{
		case 0:
			return entry.glob;
		case 1:
			return entry.color;
		default:
			return null;
		}
	} 

	
	public boolean isCellEditable(int row, int col)
	{
		return (col == 0);
	} 

	
	public void setValueAt(Object value, int row, int col)
	{
		Entry entry = (Entry)entries.elementAt(row);

		if(col == 0)
			entry.glob = (String)value;
		else
			entry.color = (Color)value;

		fireTableRowsUpdated(row,row);
	} 

	
	public String getColumnName(int index)
	{
		switch(index)
		{
		case 0:
			return jEdit.getProperty(""options.browser.colors.glob"");
		case 1:
			return jEdit.getProperty(""options.browser.colors.color"");
		default:
			return null;
		}
	} 

	
	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
			return String.class;
		case 1:
			return Color.class;
		default:
			throw new InternalError();
		}
	} 

	
	static class Entry
	{
		String glob;
		Color color;

		Entry(String glob, Color color)
		{
			this.glob = glob;
			this.color = color;
		}
	} 

	
	static class ColorRenderer extends JLabel
		implements TableCellRenderer
	{
		
		public ColorRenderer()
		{
			setOpaque(true);
			setBorder(SyntaxHiliteOptionPane.noFocusBorder);
		} 

		
		public Component getTableCellRendererComponent(
			JTable table,
			Object value,
			boolean isSelected,
			boolean cellHasFocus,
			int row,
			int col)
		{
			if (isSelected)
			{
				setBackground(table.getSelectionBackground());
				setForeground(table.getSelectionForeground());
			}
			else
			{
				setBackground(table.getBackground());
				setForeground(table.getForeground());
			}

			if (value != null)
				setBackground((Color)value);

			setBorder((cellHasFocus) ? UIManager.getBorder(
				""Table.focusCellHighlightBorder"")
				: SyntaxHiliteOptionPane.noFocusBorder);
			return this;
		} 
	} 
} 
"
jEdit,4.1,org.gjt.sp.jedit.EditBus,7,1,0,21,19,9,18,3,4,0.611111111,141,0.666666667,1,0.0,0.208333333,0,0,18.71428571,5,1.4286,0,"

package org.gjt.sp.jedit;

import java.util.*;
import org.gjt.sp.util.Log;


public class EditBus
{
	
	
	public static void addToBus(EBComponent comp)
	{
		synchronized(components)
		{
			components.add(comp);
			copyComponents = null;
		}
	} 

	
	
	public static void removeFromBus(EBComponent comp)
	{
		synchronized(components)
		{
			components.remove(comp);
			copyComponents = null;
		}
	} 

	
	
	public static EBComponent[] getComponents()
	{
		synchronized(components)
		{
			if (copyComponents == null)
			{
				copyComponents = (EBComponent[])components.toArray(
					new EBComponent[components.size()]);
			}
			return copyComponents;
		}
	} 

	
	 

	
	
	public static void send(EBMessage message)
	{
		Log.log(Log.DEBUG,EditBus.class,message.toString());

		
		
		EBComponent[] comps = getComponents();

		for(int i = 0; i < comps.length; i++)
		{
			try
			{
				comps[i].handleMessage(message);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,EditBus.class,""Exception""
					+ "" while sending message on EditBus:"");
				Log.log(Log.ERROR,EditBus.class,t);
			}
		}
	} 

	
	private static ArrayList components = new ArrayList();
	private static EBComponent[] copyComponents;

	
	private EditBus() {}
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.VariableGridLayout,17,1,0,4,36,100,4,0,16,0.7,679,0.8,0,0.0,0.323529412,0,0,38.35294118,13,2.4118,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;



public class VariableGridLayout implements LayoutManager2, java.io.Serializable
{

	public static final int FIXED_NUM_ROWS = 1;
	public static final int FIXED_NUM_COLUMNS = 2;


	public VariableGridLayout(int mode, int size, int hgap, int vgap) {
		if (mode != FIXED_NUM_ROWS && mode != FIXED_NUM_COLUMNS) {
			throw new IllegalArgumentException(""illegal mode; value is "" + mode);
		}
		if (size <= 0) {
			throw new IllegalArgumentException(""size cannot be zero or less; value is "" + size);
		}
		if (hgap < 0) {
			throw new IllegalArgumentException(""hgap cannot be negative; value is "" + hgap);
		}
		if (vgap < 0) {
			throw new IllegalArgumentException(""vgap cannot be negative; value is "" + vgap);
		}
		this.mode = mode;
		this.size = size;
		this.hgap = hgap;
		this.vgap = vgap;
	}


	
	public VariableGridLayout(int mode, int size) {
		this(mode, size, 0, 0);
	}


	
	public VariableGridLayout() {
		this(FIXED_NUM_ROWS, 1, 0, 0);
	}


	
	public void addLayoutComponent(String name, Component component) { }


	
	public void addLayoutComponent(Component component, Object constraints) { }


	
	public void removeLayoutComponent(Component component) { }


	
	public float getLayoutAlignmentX(Container container) {
		return 0.5f;
	}


	
	public float getLayoutAlignmentY(Container container) {
		return 0.5f;
	}


	public Dimension preferredLayoutSize(Container parent) {
		return getLayoutSize(parent, 2);
	}


	public Dimension minimumLayoutSize(Container parent) {
		return getLayoutSize(parent, 0);
	}


	public Dimension maximumLayoutSize(Container parent) {
		return getLayoutSize(parent, 1);
	}


	public void layoutContainer(Container parent) {
		synchronized (parent.getTreeLock()) {
			int ncomponents = parent.getComponentCount();

			if (ncomponents == 0) {
				return;
			}

			
			int total_height = 0;
			for (int r = 0, i = 0; r < nrows; r++) {
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						Dimension d = parent.getComponent(i).getPreferredSize();
						row_heights[r] = Math.max(row_heights[r], d.height);
						col_widths[c] = Math.max(col_widths[c], d.width);
					} else {
						break;
					}
				}
				total_height += row_heights[r];
			}

			int total_width = 0;
			for (int c = 0; c < ncols; c++) {
				total_width += col_widths[c];
			}

			
			Dimension parent_size = parent.getSize();
			Insets insets = parent.getInsets();
			int free_height = parent_size.height - insets.top - insets.bottom - (nrows - 1) * vgap;
			int free_width = parent_size.width - insets.left - insets.right - (ncols - 1) * hgap;

			if (total_height != free_height) {
				double dy = (double)free_height / (double)total_height;
				for (int r = 0; r < nrows; r++) {
					row_heights[r] = (int) ((double)row_heights[r] * dy);
				}
			}

			if (total_width != free_width) {
				double dx = ((double)free_width) / ((double)total_width);
				for (int c = 0; c < ncols; c++) {
					col_widths[c] = (int) ((double)col_widths[c] * dx);
				}
			}

			
			for (int r = 0, y = insets.top, i = 0; r < nrows; y += row_heights[r] + vgap, r++) {
				for (int c = 0, x = insets.left; c < ncols; x += col_widths[c] + hgap, c++, i++) {
					if (i < ncomponents) {
						parent.getComponent(i).setBounds(x, y, col_widths[c], row_heights[r]);
					}
				}
			}

		} 
	}


	public void invalidateLayout(Container container) {
		int ncomponents = container.getComponentCount();
		int old_nrows = nrows;
		int old_ncols = ncols;
		if (this.mode == FIXED_NUM_ROWS) {
			nrows = this.size;
			ncols = (ncomponents + nrows - 1) / nrows;
		} else {
			ncols = this.size;
			nrows = (ncomponents + ncols - 1) / ncols;
		}
		if (old_nrows != nrows) {
			row_heights = new int[nrows];
		}
		if (old_ncols != ncols) {
			col_widths = new int[ncols];
		}
	}


	public int getRows() {
		return nrows;
	}


	public int getColumns() {
		return ncols;
	}


	
	public String toString() {
		return getClass().getName() + ""[mode="" + mode + "",size="" + size
			   + "",hgap="" + hgap + "",vgap="" + vgap + ""]"";
	}


	
	private Dimension getLayoutSize(Container parent, int which) {
		synchronized (parent.getTreeLock()){
			int ncomponents = parent.getComponentCount();
			int h = 0;
			int w = 0;

			for (int r = 0, i = 0; r < nrows; r++) {
				int row_height = 0;
				for (int c = 0; c < ncols; c++, i++) {
					if (i < ncomponents) {
						switch (which) {
							case 0:
								row_height = Math.max(row_height, parent.getComponent(i).getMinimumSize().height);
								break;
							case 1:
								row_height = Math.max(row_height, parent.getComponent(i).getMaximumSize().height);
								break;
							default:
								row_height = Math.max(row_height, parent.getComponent(i).getPreferredSize().height);
								break;
						}
					} else {
						break;
					}
				}
				h += row_height;
			}

			for (int c = 0; c < ncols; c++) {
				int col_width = 0;
				for (int r = 0; r < nrows; r++) {
					int i = r * ncols + c;
					if (i < ncomponents) {
						switch (which) {
							case 0:
								col_width = Math.max(col_width, parent.getComponent(i).getMinimumSize().width);
								break;
							case 1:
								col_width = Math.max(col_width, parent.getComponent(i).getMaximumSize().width);
								break;
							default:
								col_width = Math.max(col_width, parent.getComponent(i).getPreferredSize().width);
								break;
						}
					} else {
						break;
					}
				}
				w += col_width;
			}

			Insets insets = parent.getInsets();
			return new Dimension(w + insets.left + insets.right + ((ncols - 1) * hgap),
								 h + insets.top + insets.bottom + ((nrows - 1) * vgap));
		}
	}


	private int mode;
	private int size;
	private int hgap;
	private int vgap;
	private transient int nrows = -1;
	private transient int ncols = -1;
	private transient int[] row_heights = null;
	private transient int[] col_widths = null;
}
"
jEdit,4.1,org.gjt.sp.jedit.options.GutterOptionPane,4,6,0,5,39,0,1,4,3,0.7,507,1.0,10,0.997019374,1.0,3,5,120.75,6,2.0,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;


public class GutterOptionPane extends AbstractOptionPane
{
	
	public GutterOptionPane()
	{
		super(""gutter"");
	} 

	
	public void _init()
	{
		
		lineNumbersEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.lineNumbers""));
		lineNumbersEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.lineNumbers""));
		addComponent(lineNumbersEnabled);

		
		gutterFont = new FontSelector(
			jEdit.getFontProperty(""view.gutter.font"",
			new Font(""Monospaced"",Font.PLAIN,10)));

		addComponent(jEdit.getProperty(""options.gutter.font""),gutterFont);

		
		addComponent(jEdit.getProperty(""options.gutter.foreground""),
			gutterForeground = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.fgColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.gutter.background""),
			gutterBackground = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.bgColor"")),
			GridBagConstraints.VERTICAL);

		
		

		
		

		
		gutterCurrentLineHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.currentLineHighlight""));
		gutterCurrentLineHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.highlightCurrentLine""));
		addComponent(gutterCurrentLineHighlightEnabled,
			gutterCurrentLineHighlight = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.currentLineColor"")),
			GridBagConstraints.VERTICAL);

		
		gutterHighlightInterval = new JTextField(jEdit.getProperty(
			""view.gutter.highlightInterval""),3);

		Box gutterHighlightBox = new Box(BoxLayout.X_AXIS);
		gutterHighlightBox.add(new JLabel(jEdit.getProperty(
			""options.gutter.interval-1"")));
		gutterHighlightBox.add(Box.createHorizontalStrut(3));
		gutterHighlightBox.add(gutterHighlightInterval);
		gutterHighlightBox.add(Box.createHorizontalStrut(3));
		gutterHighlightBox.add(new JLabel(jEdit.getProperty(
			""options.gutter.interval-2"")));
		gutterHighlightBox.add(Box.createHorizontalStrut(12));

		addComponent(gutterHighlightBox,gutterHighlightColor
			= new ColorWellButton(jEdit.getColorProperty(
			""view.gutter.bracketHighlightColor"")),
			GridBagConstraints.VERTICAL);

		
		gutterBracketHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.bracketHighlight""));
		gutterBracketHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.bracketHighlight""));
		addComponent(gutterBracketHighlightEnabled,
			gutterBracketHighlight = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.bracketHighlightColor"")),
			GridBagConstraints.VERTICAL);

		
		gutterMarkerHighlightEnabled = new JCheckBox(jEdit.getProperty(
			""options.gutter.markerHighlight""));
		gutterMarkerHighlightEnabled.setSelected(jEdit.getBooleanProperty(
			""view.gutter.markerHighlight""));
		addComponent(gutterMarkerHighlightEnabled,
			gutterMarkerHighlight = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.markerColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.gutter.foldColor""),
			gutterFoldMarkers = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.foldColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.gutter.focusBorderColor""),
			gutterFocusBorder = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.focusBorderColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.gutter.noFocusBorderColor""),
			gutterNoFocusBorder = new ColorWellButton(
			jEdit.getColorProperty(""view.gutter.noFocusBorderColor"")),
			GridBagConstraints.VERTICAL);

		
		addSeparator(""options.gutter.actions"");

		int c = clickActionKeys.length;
		String[] clickActionNames = new String[c];
		for(int i = 0; i < c; i++)
		{
			clickActionNames[i] = jEdit.getProperty(
				""options.gutter.""+clickActionKeys[i]);
		}

		c = clickModifierKeys.length;
		String[] clickModifierNames = new String[c];
		for(int i = 0; i < c; i++)
		{
			clickModifierNames[i] = jEdit.getProperty(
				""options.gutter.""+clickModifierKeys[i]);
		}

		gutterClickActions = new JComboBox[c];

		for(int i = 0; i < c; i++)
		{
			JComboBox cb = new JComboBox(clickActionNames);
			gutterClickActions[i] = cb;

			String val = jEdit.getProperty(""view.gutter.""+clickModifierKeys[i]);
			for(int j = 0; j < clickActionKeys.length; j++)
			{
				if(val.equals(clickActionKeys[j]))
				{
					cb.setSelectedIndex(j);
				}
			}

			addComponent(clickModifierNames[i],cb);
		}
	} 

	
	public void _save()
	{
		jEdit.setBooleanProperty(""view.gutter.lineNumbers"", lineNumbersEnabled
			.isSelected());

		jEdit.setFontProperty(""view.gutter.font"",gutterFont.getFont());
		jEdit.setColorProperty(""view.gutter.fgColor"",gutterForeground
			.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.bgColor"",gutterBackground
			.getSelectedColor());

		

		jEdit.setBooleanProperty(""view.gutter.highlightCurrentLine"",
			gutterCurrentLineHighlightEnabled.isSelected());
		jEdit.setColorProperty(""view.gutter.currentLineColor"",
			gutterCurrentLineHighlight.getSelectedColor());
		jEdit.setProperty(""view.gutter.highlightInterval"",
			gutterHighlightInterval.getText());
		jEdit.setColorProperty(""view.gutter.highlightColor"",
			gutterHighlightColor.getSelectedColor());

		jEdit.setBooleanProperty(""view.gutter.bracketHighlight"",
			gutterBracketHighlightEnabled.isSelected());
		jEdit.setColorProperty(""view.gutter.bracketHighlightColor"",
			gutterBracketHighlight.getSelectedColor());
		jEdit.setBooleanProperty(""view.gutter.markerHighlight"",
			gutterMarkerHighlightEnabled.isSelected());
		jEdit.setColorProperty(""view.gutter.markerColor"",
			gutterMarkerHighlight.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.foldColor"",
			gutterFoldMarkers.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.focusBorderColor"",
			gutterFocusBorder.getSelectedColor());
		jEdit.setColorProperty(""view.gutter.noFocusBorderColor"",
			gutterNoFocusBorder.getSelectedColor());

		int c = clickModifierKeys.length;
		for(int i = 0; i < c; i++)
		{
			int idx = gutterClickActions[i].getSelectedIndex();
			jEdit.setProperty(""view.gutter.""+clickModifierKeys[i],
				clickActionKeys[idx]);
		}
	} 

	
	private FontSelector gutterFont;
	private ColorWellButton gutterForeground;
	private ColorWellButton gutterBackground;
	private JTextField gutterBorderWidth;
	private JTextField gutterHighlightInterval;
	private ColorWellButton gutterHighlightColor;
	private JComboBox gutterNumberAlignment;
	private JCheckBox lineNumbersEnabled;
	private JCheckBox gutterCurrentLineHighlightEnabled;
	private ColorWellButton gutterCurrentLineHighlight;
	private JCheckBox gutterBracketHighlightEnabled;
	private ColorWellButton gutterBracketHighlight;
	private JCheckBox gutterMarkerHighlightEnabled;
	private ColorWellButton gutterMarkerHighlight;
	private ColorWellButton gutterFoldMarkers;
	private ColorWellButton gutterFocusBorder;
	private ColorWellButton gutterNoFocusBorder;

	private JComboBox[] gutterClickActions;

	
	private static final String[] clickActionKeys = new String[] {
		""toggleFold"",
		""toggleFoldFully"" 
	};
	
	private static final String[] clickModifierKeys = new String[] {
		""gutterClick"",
		""gutterShiftClick"" 
	}; 
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.DummyFoldHandler,2,2,0,2,3,1,2,2,2,2.0,8,0.0,0,0.888888889,0.625,0,0,3.0,1,0.5,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;


public class DummyFoldHandler extends FoldHandler
{
	
	public DummyFoldHandler()
	{
		super(""none"");
	}
	

	
	
	public int getFoldLevel(Buffer buffer, int lineIndex, Segment seg)
	{
		return 0;
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.RecentDirectoriesMenu,4,8,0,13,30,6,3,13,4,2.0,119,0.0,0,0.996515679,0.875,0,0,28.75,7,2.25,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.*;


public class RecentDirectoriesMenu extends EnhancedMenu
{
	
	public RecentDirectoriesMenu()
	{
		super(""recent-directories"");
	} 

	
	public void menuSelected(MenuEvent evt)
	{
		super.menuSelected(evt);
		final View view = GUIUtilities.getView(this);

		if(getMenuComponentCount() != 0)
			removeAll();

		
		ActionListener actionListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				VFSBrowser.browseDirectory(view,evt.getActionCommand());

				view.getStatus().setMessage(null);
			}
		}; 

		
		MouseListener mouseListener = new MouseAdapter()
		{
			public void mouseEntered(MouseEvent evt)
			{
				view.getStatus().setMessage(
					((JMenuItem)evt.getSource())
					.getActionCommand());
			}

			public void mouseExited(MouseEvent evt)
			{
				view.getStatus().setMessage(null);
			}
		}; 

		HistoryModel model = HistoryModel.getModel(""vfs.browser.path"");
		if(model.getSize() == 0)
		{
			add(GUIUtilities.loadMenuItem(""no-recent-dirs""));
			return;
		}

		boolean sort = jEdit.getBooleanProperty(""sortRecent"");

		Vector menuItems = new Vector();

		for(int i = 0; i < model.getSize(); i++)
		{
			String path = model.getItem(i);
			VFS vfs = VFSManager.getVFSForPath(path);
			JMenuItem menuItem = new JMenuItem(vfs.getFileName(path));
			menuItem.setActionCommand(path);
			menuItem.addActionListener(actionListener);
			menuItem.addMouseListener(mouseListener);
			menuItem.setIcon(FileCellRenderer.dirIcon);

			if(sort)
				menuItems.addElement(menuItem);
			else
				add(menuItem);
		}

		if(sort)
		{
			MiscUtilities.quicksort(menuItems,
				new MiscUtilities.MenuItemCompare());
			for(int i = 0; i < menuItems.size(); i++)
			{
				add((JMenuItem)menuItems.elementAt(i));
			}
		}
	} 

	public void menuDeselected(MenuEvent e) {}

	public void menuCanceled(MenuEvent e) {}
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.RootElement,11,1,0,2,16,35,1,2,11,0.6,52,1.0,1,0.0,0.424242424,0,0,3.636363636,1,0.9091,0,"

package org.gjt.sp.jedit.buffer;


import javax.swing.text.*;
import org.gjt.sp.jedit.Buffer;



public class RootElement implements Element
{
	
	public RootElement(Buffer buffer)
	{
		this.buffer = buffer;
	} 

	
	public Document getDocument()
	{
		return null;
	} 

	
	public Element getParentElement()
	{
		return null;
	} 

	
	public String getName()
	{
		return null;
	} 

	
	public AttributeSet getAttributes()
	{
		return null;
	} 

	
	public int getStartOffset()
	{
		return 0;
	} 

	
	public int getEndOffset()
	{
		return buffer.getLength() + 1;
	} 

	
	public int getElementIndex(int offset)
	{
		return buffer.getLineOfOffset(offset);
	} 

	
	public int getElementCount()
	{
		return buffer.getLineCount();
	} 

	
	public Element getElement(int line)
	{
		return new LineElement(buffer,line);
	} 

	
	public boolean isLeaf()
	{
		return false;
	} 

	
	private Buffer buffer;
	
} 
"
jEdit,4.1,org.gjt.sp.jedit.options.StatusBarOptionPane,5,6,0,5,22,4,2,4,1,0.25,353,1.0,2,0.994056464,0.5,1,3,67.2,5,1.6,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.ColorWellButton;
import org.gjt.sp.jedit.*;


public class StatusBarOptionPane extends AbstractOptionPane
{
	
	public StatusBarOptionPane()
	{
		super(""status"");
	} 

	
	protected void _init()
	{
		
		statusVisible = new JCheckBox(jEdit.getProperty(
			""options.status.visible""));
		statusVisible.setSelected(jEdit.getBooleanProperty(
			""view.status.visible""));
		statusVisible.addActionListener(new ActionHandler());
		addComponent(statusVisible);

		
		showCaretStatus = new JCheckBox(jEdit.getProperty(
			""options.status.show-caret-status""));
		showCaretStatus.setSelected(jEdit.getBooleanProperty(
			""view.status.show-caret-status""));
		addComponent(showCaretStatus);

		
		showEditMode = new JCheckBox(jEdit.getProperty(
			""options.status.show-edit-mode""));
		showEditMode.setSelected(jEdit.getBooleanProperty(
			""view.status.show-edit-mode""));
		addComponent(showEditMode);

		
		showFoldMode = new JCheckBox(jEdit.getProperty(
			""options.status.show-fold-mode""));
		showFoldMode.setSelected(jEdit.getBooleanProperty(
			""view.status.show-fold-mode""));
		addComponent(showFoldMode);

		
		showEncoding = new JCheckBox(jEdit.getProperty(
			""options.status.show-encoding""));
		showEncoding.setSelected(jEdit.getBooleanProperty(
			""view.status.show-encoding""));
		addComponent(showEncoding);

		
		showWrap = new JCheckBox(jEdit.getProperty(
			""options.status.show-wrap""));
		showWrap.setSelected(jEdit.getBooleanProperty(
			""view.status.show-wrap""));
		addComponent(showWrap);

		
		showMultiSelect = new JCheckBox(jEdit.getProperty(
			""options.status.show-multi-select""));
		showMultiSelect.setSelected(jEdit.getBooleanProperty(
			""view.status.show-multi-select""));
		addComponent(showMultiSelect);

		
		showOverwrite = new JCheckBox(jEdit.getProperty(
			""options.status.show-overwrite""));
		showOverwrite.setSelected(jEdit.getBooleanProperty(
			""view.status.show-overwrite""));
		addComponent(showOverwrite);

		
		showLineSeperator = new JCheckBox(jEdit.getProperty(
			""options.status.show-line-seperator""));
		showLineSeperator.setSelected(jEdit.getBooleanProperty(
			""view.status.show-line-seperator""));
		addComponent(showLineSeperator);

		
		showMemory = new JCheckBox(jEdit.getProperty(
			""options.status.show-memory""));
		showMemory.setSelected(jEdit.getBooleanProperty(
			""view.status.show-memory""));
		showMemory.addActionListener(new ActionHandler());
		addComponent(showMemory);

		
		addComponent(jEdit.getProperty(""options.status.memory.foreground""),
			memForegroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.memory.foreground"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.status.memory.background""),
			memBackgroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.status.memory.background"")),
			GridBagConstraints.VERTICAL);

		updateEnabled();
	} 

	
	protected void _save()
	{
		jEdit.setBooleanProperty(""view.status.visible"",
			statusVisible.isSelected());
		jEdit.setBooleanProperty(""view.status.show-caret-status"",
			showCaretStatus.isSelected());
		jEdit.setBooleanProperty(""view.status.show-edit-mode"",
			showEditMode.isSelected());
		jEdit.setBooleanProperty(""view.status.show-fold-mode"",
			showFoldMode.isSelected());
		jEdit.setBooleanProperty(""view.status.show-encoding"",
			showEncoding.isSelected());
		jEdit.setBooleanProperty(""view.status.show-wrap"",
			showWrap.isSelected());
		jEdit.setBooleanProperty(""view.status.show-multi-select"",
			showMultiSelect.isSelected());
		jEdit.setBooleanProperty(""view.status.show-overwrite"",
			showOverwrite.isSelected());
		jEdit.setBooleanProperty(""view.status.show-line-seperator"",
			showLineSeperator.isSelected());
		jEdit.setBooleanProperty(""view.status.show-memory"",
			showMemory.isSelected());
		jEdit.setColorProperty(""view.status.memory.foreground"",memForegroundColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.status.memory.background"",memBackgroundColor
			.getSelectedColor());
	} 

	
	private JCheckBox statusVisible;
	private JCheckBox showCaretStatus;
	private JCheckBox showEditMode;
	private JCheckBox showFoldMode;
	private JCheckBox showEncoding;
	private JCheckBox showWrap;
	private JCheckBox showMultiSelect;
	private JCheckBox showOverwrite;
	private JCheckBox showLineSeperator;
	private JCheckBox showMemory;
	private ColorWellButton memForegroundColor;
	private ColorWellButton memBackgroundColor;

	private void updateEnabled()
	{
		boolean enabled = statusVisible.isSelected();
		showCaretStatus.setEnabled(enabled);
		showEditMode.setEnabled(enabled);
		showFoldMode.setEnabled(enabled);
		showEncoding.setEnabled(enabled);
		showWrap.setEnabled(enabled);
		showMultiSelect.setEnabled(enabled);
		showOverwrite.setEnabled(enabled);
		showLineSeperator.setEnabled(enabled);
		showMemory.setEnabled(enabled);
		memForegroundColor.setEnabled(enabled && showMemory.isSelected());
		memBackgroundColor.setEnabled(enabled && showMemory.isSelected());
	}
	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			updateEnabled();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.options.AppearanceOptionPane,5,6,0,7,36,4,2,6,1,0.464285714,247,1.0,2,0.994056464,0.5,2,4,47.0,4,1.8,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.event.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;


public class AppearanceOptionPane extends AbstractOptionPane
{
	
	public AppearanceOptionPane()
	{
		super(""appearance"");
	} 

	
	protected void _init()
	{
		
		addComponent(new JLabel(jEdit.getProperty(""options.appearance.lf.note"")));

		lfs = UIManager.getInstalledLookAndFeels();
		String[] names = new String[lfs.length];
		String lf = UIManager.getLookAndFeel().getClass().getName();
		int index = 0;
		for(int i = 0; i < names.length; i++)
		{
			names[i] = lfs[i].getName();
			if(lf.equals(lfs[i].getClassName()))
				index = i;
		}

		lookAndFeel = new JComboBox(names);
		lookAndFeel.setSelectedIndex(index);
		lookAndFeel.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				updateEnabled();
			}
		});

		addComponent(jEdit.getProperty(""options.appearance.lf""),
			lookAndFeel);

		
		primaryFont = new FontSelector(jEdit.getFontProperty(
			""metal.primary.font""));
		addComponent(jEdit.getProperty(""options.appearance.primaryFont""),
			primaryFont);

		
		secondaryFont = new FontSelector(jEdit.getFontProperty(
			""metal.secondary.font""));
		addComponent(jEdit.getProperty(""options.appearance.secondaryFont""),
			secondaryFont);

		updateEnabled();

		addSeparator(""options.appearance.experimental.label"");
		addComponent(GUIUtilities.createMultilineLabel(
			jEdit.getProperty(""options.appearance.experimental.caption"")));

		
		textColors = new JCheckBox(jEdit.getProperty(
			""options.appearance.textColors""));
		textColors.setSelected(jEdit.getBooleanProperty(""textColors""));
		addComponent(textColors);

		
		decorateFrames = new JCheckBox(jEdit.getProperty(
			""options.appearance.decorateFrames""));
		decorateFrames.setSelected(jEdit.getBooleanProperty(""decorate.frames""));

		
		decorateDialogs = new JCheckBox(jEdit.getProperty(
			""options.appearance.decorateDialogs""));
		decorateDialogs.setSelected(jEdit.getBooleanProperty(""decorate.dialogs""));

		if(OperatingSystem.hasJava14())
		{
			addComponent(decorateFrames);
			addComponent(decorateDialogs);
		}
	} 

	
	protected void _save()
	{
		String lf = lfs[lookAndFeel.getSelectedIndex()].getClassName();
		jEdit.setProperty(""lookAndFeel"",lf);
		jEdit.setFontProperty(""metal.primary.font"",primaryFont.getFont());
		jEdit.setFontProperty(""metal.secondary.font"",secondaryFont.getFont());
		jEdit.setBooleanProperty(""textColors"",textColors.isSelected());
		jEdit.setBooleanProperty(""decorate.frames"",decorateFrames.isSelected());
		jEdit.setBooleanProperty(""decorate.dialogs"",decorateDialogs.isSelected());
	} 

	

	
	private UIManager.LookAndFeelInfo[] lfs;
	private JComboBox lookAndFeel;
	private FontSelector primaryFont;
	private FontSelector secondaryFont;
	private JCheckBox textColors;
	private JCheckBox decorateFrames;
	private JCheckBox decorateDialogs;
	

	
	private void updateEnabled()
	{
		String className = lfs[lookAndFeel.getSelectedIndex()]
			.getClassName();

		if(className.equals(""javax.swing.plaf.metal.MetalLookAndFeel"")
			|| className.equals(""com.incors.plaf.kunststoff.KunststoffLookAndFeel""))
		{
			primaryFont.setEnabled(true);
			secondaryFont.setEnabled(true);
		}
		else
		{
			primaryFont.setEnabled(false);
			secondaryFont.setEnabled(false);
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.RecentFilesMenu,4,8,0,14,30,6,3,14,4,2.0,132,0.0,0,0.996515679,0.875,0,0,32.0,7,2.25,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.browser.FileCellRenderer;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.*;


public class RecentFilesMenu extends EnhancedMenu
{
	
	public RecentFilesMenu()
	{
		super(""recent-files"");
	} 

	
	public void menuSelected(MenuEvent evt)
	{
		super.menuSelected(evt);
		final View view = GUIUtilities.getView(this);

		if(getMenuComponentCount() != 0)
			removeAll();

		
		ActionListener actionListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				jEdit.openFile(view,evt.getActionCommand());
				view.getStatus().setMessage(null);
			}
		}; 

		
		MouseListener mouseListener = new MouseAdapter()
		{
			public void mouseEntered(MouseEvent evt)
			{
				view.getStatus().setMessage(
					((JMenuItem)evt.getSource())
					.getActionCommand());
			}

			public void mouseExited(MouseEvent evt)
			{
				view.getStatus().setMessage(null);
			}
		}; 

		Vector recentVector = BufferHistory.getBufferHistory();

		if(recentVector.size() == 0)
		{
			add(GUIUtilities.loadMenuItem(""no-recent-files""));
			return;
		}

		Vector menuItems = new Vector();
		boolean sort = jEdit.getBooleanProperty(""sortRecent"");

		
		int recentFileCount = Math.min(recentVector.size(),
			jEdit.getIntegerProperty(""history"",25));

		for(int i = recentVector.size() - 1;
			i >= recentVector.size() - recentFileCount;
			i--)
		{
			String path = ((BufferHistory.Entry)recentVector
				.elementAt(i)).path;
			VFS vfs = VFSManager.getVFSForPath(path);
			JMenuItem menuItem = new JMenuItem(vfs.getFileName(path));
			menuItem.setActionCommand(path);
			menuItem.addActionListener(actionListener);
			menuItem.addMouseListener(mouseListener);
			menuItem.setIcon(FileCellRenderer.fileIcon);

			if(sort)
				menuItems.addElement(menuItem);
			else
				add(menuItem);
		}

		if(sort)
		{
			MiscUtilities.quicksort(menuItems,
				new MiscUtilities.MenuItemCompare());
			for(int i = 0; i < menuItems.size(); i++)
			{
				add((JMenuItem)menuItems.elementAt(i));
			}
		}
	} 

	public void menuDeselected(MenuEvent e) {}

	public void menuCanceled(MenuEvent e) {}
}
"
jEdit,4.1,org.gjt.sp.jedit.io.VFSManager,25,1,0,48,72,200,41,16,18,0.871212121,375,0.909090909,3,0.0,0.113095238,0,0,13.56,8,1.56,1,"

package org.gjt.sp.jedit.io;


import java.util.Enumeration;
import java.util.Hashtable;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.gui.ErrorListDialog;
import org.gjt.sp.jedit.msg.VFSUpdate;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.util.WorkThreadPool;



public class VFSManager
{
	
	
	public static void init()
	{
		int count = jEdit.getIntegerProperty(""ioThreadCount"",4);
		ioThreadPool = new WorkThreadPool(""jEdit I/O"",count);
		registerVFS(FavoritesVFS.PROTOCOL,new FavoritesVFS());
		if(OperatingSystem.isDOSDerived() || OperatingSystem.isMacOS())
			registerVFS(FileRootsVFS.PROTOCOL,new FileRootsVFS());
	} 

	
	
	public static void start()
	{
		ioThreadPool.start();
	} 

	

	
	
	public static VFS getFileVFS()
	{
		return fileVFS;
	} 

	
	
	public static VFS getUrlVFS()
	{
		return urlVFS;
	} 

	
	
	public static VFS getVFSByName(String name)
	{
		return (VFS)vfsHash.get(name);
	} 

	
	
	public static VFS getVFSForProtocol(String protocol)
	{
		if(protocol.equals(""file""))
			return fileVFS;
		else
		{
			VFS vfs = (VFS)protocolHash.get(protocol);
			if(vfs != null)
				return vfs;
			else
				return urlVFS;
		}
	} 

	
	
	public static VFS getVFSForPath(String path)
	{
		if(MiscUtilities.isURL(path))
			return getVFSForProtocol(MiscUtilities.getProtocolOfURL(path));
		else
			return fileVFS;
	} 

	
	
	public static void registerVFS(String protocol, VFS vfs)
	{
		Log.log(Log.DEBUG,VFSManager.class,""Registered ""
			+ vfs.getName() + "" filesystem for ""
			+ protocol + "" protocol"");
		vfsHash.put(vfs.getName(),vfs);
		protocolHash.put(protocol,vfs);
	} 

	
	
	public static Enumeration getFilesystems()
	{
		return vfsHash.elements();
	} 

	

	

	
	
	public static WorkThreadPool getIOThreadPool()
	{
		return ioThreadPool;
	} 

	
	
	public static void waitForRequests()
	{
		ioThreadPool.waitForRequests();
	} 

	
	
	public static boolean errorOccurred()
	{
		return error;
	} 

	
	
	public static int getRequestCount()
	{
		return ioThreadPool.getRequestCount();
	} 

	
	
	public static void runInAWTThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,true);
	} 

	
	
	public static void runInWorkThread(Runnable run)
	{
		ioThreadPool.addWorkRequest(run,false);
	} 

	

	
	
	public static void error(final Component comp, final String error, final Object[] args)
	{
		
		if(SwingUtilities.isEventDispatchThread())
		{
			GUIUtilities.error(comp,error,args);
			return;
		}

		
		
		
		
		
		
		VFSManager.error = true;

		runInAWTThread(new Runnable()
		{
			public void run()
			{
				VFSManager.error = false;

				if(comp == null || !comp.isShowing())
					GUIUtilities.error(null,error,args);
				else
					GUIUtilities.error(comp,error,args);
			}
		});
	} 

	
	
	public static void error(Component comp,
		final String path,
		String messageProp,
		Object[] args)
	{
		final Frame frame = JOptionPane.getFrameForComponent(comp);

		synchronized(errorLock)
		{
			error = true;

			errors.addElement(new ErrorListDialog.ErrorEntry(
				path,messageProp,args));

			if(errors.size() == 1)
			{
				final String caption = jEdit.getProperty(
					""ioerror.caption"" + (errors.size() == 1
					? ""-1"" : """"),new Integer[] {
					new Integer(errors.size()) });

				VFSManager.runInAWTThread(new Runnable()
				{
					public void run()
					{
						new ErrorListDialog(
							frame.isShowing()
							? frame
							: jEdit.getFirstView(),
							jEdit.getProperty(""ioerror.title""),
							caption,errors,false);
						errors.removeAllElements();
						error = false;
					}
				});
			}
		}
	} 

	
	
	public static void sendVFSUpdate(VFS vfs, String path, boolean parent)
	{
		if(parent)
		{
			sendVFSUpdate(vfs,vfs.getParentOfPath(path),false);
			sendVFSUpdate(vfs,path,false);
		}
		else
		{
			
			if(path.length() != 1 && (path.endsWith(""/"")
				|| path.endsWith(java.io.File.separator)))
				path = path.substring(0,path.length() - 1);

			synchronized(vfsUpdateLock)
			{
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					VFSUpdate msg = (VFSUpdate)vfsUpdates
						.elementAt(i);
					if(msg.getPath().equals(path))
					{
						
						
						return;
					}
				}

				vfsUpdates.addElement(new VFSUpdate(path));

				if(vfsUpdates.size() == 1)
				{
					
					
					
					VFSManager.runInAWTThread(new SendVFSUpdatesSafely());
				}
			}
		}
	} 

	
	static class SendVFSUpdatesSafely implements Runnable
	{
		public void run()
		{
			synchronized(vfsUpdateLock)
			{
				for(int i = 0; i < vfsUpdates.size(); i++)
				{
					EditBus.send((VFSUpdate)vfsUpdates.elementAt(i));
				}

				vfsUpdates.removeAllElements();
			}
		}
	} 

	

	
	private static WorkThreadPool ioThreadPool;
	private static VFS fileVFS;
	private static VFS urlVFS;
	private static Hashtable vfsHash;
	private static Hashtable protocolHash;
	private static boolean error;
	private static Object errorLock;
	private static Vector errors;
	private static Object vfsUpdateLock;
	private static Vector vfsUpdates;
	

	
	static
	{
		errorLock = new Object();
		errors = new Vector();
		fileVFS = new FileVFS();
		urlVFS = new UrlVFS();
		vfsHash = new Hashtable();
		protocolHash = new Hashtable();
		vfsUpdateLock = new Object();
		vfsUpdates = new Vector();
	} 

	private VFSManager() {}
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.ErrorListDialog,5,7,0,6,40,6,3,4,3,0.75,214,1.0,0,0.993939394,0.3,2,5,41.4,1,0.8,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import javax.swing.*;
import javax.swing.border.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class ErrorListDialog extends EnhancedDialog
{
	
	public static class ErrorEntry
	{
		String path;
		String[] messages;

		public ErrorEntry(String path, String messageProp, Object[] args)
		{
			this.path = path;

			String message = jEdit.getProperty(messageProp,args);
			if(message == null)
				message = ""Undefined property: "" + messageProp;

			Log.log(Log.ERROR,this,path + "":"");
			Log.log(Log.ERROR,this,message);

			Vector tokenizedMessage = new Vector();
			int lastIndex = -1;
			for(int i = 0; i < message.length(); i++)
			{
				if(message.charAt(i) == '\n')
				{
					tokenizedMessage.addElement(message.substring(
						lastIndex + 1,i));
					lastIndex = i;
				}
			}

			if(lastIndex != message.length())
			{
				tokenizedMessage.addElement(message.substring(
					lastIndex + 1));
			}

			messages = new String[tokenizedMessage.size()];
			tokenizedMessage.copyInto(messages);
		}
	} 

	
	public ErrorListDialog(Frame frame, String title, String caption,
		Vector messages, boolean showPluginMgrButton)
	{
		super(frame,title,true);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.errorIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout());

		JLabel label = new JLabel(caption);
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);

		JList errors = new JList(messages);
		errors.setCellRenderer(new ErrorListCellRenderer());
		errors.setVisibleRowCount(Math.min(messages.size(),4));

		
		
		JScrollPane scrollPane = new JScrollPane(errors,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_ALWAYS);
		Dimension size = scrollPane.getPreferredSize();
		size.width = Math.min(size.width,400);
		scrollPane.setPreferredSize(size);

		centerPanel.add(BorderLayout.CENTER,scrollPane);

		content.add(BorderLayout.CENTER,centerPanel);

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());

		if(showPluginMgrButton)
		{
			pluginMgr = new JButton(jEdit.getProperty(""error-list.plugin-manager""));
			pluginMgr.addActionListener(new ActionHandler());
			buttons.add(pluginMgr);
			buttons.add(Box.createHorizontalStrut(6));
		}

		buttons.add(ok);

		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);

		getRootPane().setDefaultButton(ok);

		pack();
		setLocationRelativeTo(frame);
		show();
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	private JButton ok, pluginMgr;
	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				dispose();
			else if(evt.getSource() == pluginMgr)
			{
				new org.gjt.sp.jedit.pluginmgr.PluginManager(
					JOptionPane.getFrameForComponent(
					ErrorListDialog.this));
			}
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.EnhancedMenuItem,6,6,0,7,37,3,3,5,3,0.533333333,214,1.0,1,0.994993742,0.32,2,11,33.66666667,8,2.5,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;



public class EnhancedMenuItem extends JMenuItem
{
	
	
	public EnhancedMenuItem(String label, EditAction action)
	{
		super(label);

		this.action = action;

		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(action));
			shortcutProp1 = action.getName() + "".shortcut"";
			shortcutProp2 = action.getName() + "".shortcut2"";

			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);
	} 

	
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();

		String shortcut = getShortcut();

		if(shortcut != null)
		{
			d.width += (getFontMetrics(acceleratorFont)
				.stringWidth(shortcut) + 15);
		}
		return d;
	} 

	
	public void paint(Graphics g)
	{
		super.paint(g);

		String shortcut = getShortcut();

		if(shortcut != null)
		{
			g.setFont(acceleratorFont);
			g.setColor(getModel().isArmed() ?
				acceleratorSelectionForeground :
				acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left + 5),
				getFont().getSize() + (insets.top - 
				(OperatingSystem.isMacOSLF() ? 0 : 1))
				);
		}
	} 

	

	
	private String shortcutProp1;
	private String shortcutProp2;
	private EditAction action;
	private static Font acceleratorFont;
	private static Color acceleratorForeground;
	private static Color acceleratorSelectionForeground;
	

	
	private String getShortcut()
	{
		if(action == null)
			return null;
		else
		{
			String shortcut1 = jEdit.getProperty(shortcutProp1);
			String shortcut2 = jEdit.getProperty(shortcutProp2);

			if(shortcut1 == null || shortcut1.length() == 0)
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return null;
				else
					return shortcut2;
			}
			else
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return shortcut1;
				else
					return shortcut1 + "" or "" + shortcut2;
			}
		}
	} 

	
	static
	{
		String shortcutFont;
		if (OperatingSystem.isMacOSLF())
			shortcutFont = ""Lucida Grande"";
		else
			shortcutFont = ""Monospaced"";
		
		acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
		acceleratorFont = new Font(shortcutFont,
			acceleratorFont.getStyle(),
			acceleratorFont.getSize());
		acceleratorForeground = UIManager
			.getColor(""MenuItem.acceleratorForeground"");
		acceleratorSelectionForeground = UIManager
			.getColor(""MenuItem.acceleratorSelectionForeground"");
	} 

	

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseReleased(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}

		public void mouseEntered(MouseEvent evt)
		{
			String msg = action.getMouseOverText();
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
			}
		}

		public void mouseExited(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.ParserRule,11,1,0,9,20,53,5,6,10,0.782608696,477,0.043478261,2,0.0,0.373737374,0,0,40.27272727,7,3.0909,0,"

package org.gjt.sp.jedit.syntax;

import gnu.regexp.*;
import org.gjt.sp.jedit.search.RESearchMatcher;


public class ParserRule
{
	
	public static final int MAJOR_ACTIONS = 0x000000FF;
	public static final int SEQ = 0;
	public static final int SPAN = 1 << 1;
	public static final int MARK_PREVIOUS = 1 << 2;
	public static final int MARK_FOLLOWING = 1 << 3;
	public static final int EOL_SPAN = 1 << 4;



	

	
	public static final int ACTION_HINTS = 0x0000FF00;
	public static final int EXCLUDE_MATCH = 1 << 8;
	public static final int AT_LINE_START = 1 << 9;
	public static final int AT_WHITESPACE_END = 1 << 10;
	public static final int AT_WORD_START = 1 << 11;
	public static final int NO_LINE_BREAK = 1 << 12;
	public static final int NO_WORD_BREAK = 1 << 13;
	public static final int IS_ESCAPE = 1 << 14;
	public static final int REGEXP = 1 << 15;
	

	
	public final char hashChar;
	public final char[] start;
	
	public final RE startRegexp;

	public final char[] end;


	public final int action;
	public final byte token;

	public ParserRule next;
	

	
	
	public ParserRuleSet getDelegateRuleSet(TokenMarker tokenMarker)
	{
		
		if(delegate == null)
		{
			if((action & MAJOR_ACTIONS) == SEQ)
				return null;
			else
				return ParserRuleSet.getStandardRuleSet(token);
		}
		else
		{
			ParserRuleSet delegateSet = tokenMarker.getRuleSet(delegate);
			if(delegateSet == null)
			{
				return ParserRuleSet.getStandardRuleSet(
					Token.NULL);
			}
			else
				return delegateSet;
		}
	} 

	
	public static final ParserRule createSequenceRule(String seq,
		String delegate, byte id, boolean atLineStart,
		boolean atWhitespaceEnd, boolean atWordStart)
	{
		int ruleAction = SEQ |
			((atLineStart) ? AT_LINE_START : 0) |
			((atWhitespaceEnd) ? AT_WHITESPACE_END : 0) |
			((atWordStart) ? AT_WORD_START : 0);

		return new ParserRule(ruleAction, seq.charAt(0),
			seq.toCharArray(), null, null,
			delegate, id);
	} 

	
	public static final ParserRule createRegexpSequenceRule(char hashChar,
		String seq, String delegate, byte id, boolean atLineStart,
		boolean atWhitespaceEnd, boolean atWordStart, boolean ignoreCase)
		throws REException
	{
		int ruleAction = SEQ | REGEXP |
			((atLineStart) ? AT_LINE_START : 0) |
			((atWhitespaceEnd) ? AT_WHITESPACE_END : 0) |
			((atWordStart) ? AT_WORD_START : 0);

		return new ParserRule(ruleAction, hashChar,
			null, new RE(""\\A"" + seq,(ignoreCase ? RE.REG_ICASE : 0),
			RESearchMatcher.RE_SYNTAX_JEDIT),
			null, delegate, id);
	} 

	
	public static final ParserRule createSpanRule(String begin, String end,
		String delegate, byte id, boolean noLineBreak,
		boolean atLineStart, boolean atWhitespaceEnd, boolean atWordStart,
		boolean excludeMatch, boolean noWordBreak)
	{
		int ruleAction = SPAN |
			((noLineBreak) ? NO_LINE_BREAK : 0) |
			((atLineStart) ? AT_LINE_START : 0) |
			((atWhitespaceEnd) ? AT_WHITESPACE_END : 0) |
			((atWordStart) ? AT_WORD_START : 0) |
			((excludeMatch) ? EXCLUDE_MATCH : 0) |
			((noWordBreak) ? NO_WORD_BREAK : 0);

		return new ParserRule(ruleAction, begin.charAt(0),
			begin.toCharArray(), null,
			end.toCharArray(), delegate, id);
	} 

	
	public static final ParserRule createRegexpSpanRule(char hashChar,
		String begin, String end, String delegate, byte id,
		boolean noLineBreak, boolean atLineStart,
		boolean atWhitespaceEnd, boolean atWordStart,
		boolean excludeMatch, boolean noWordBreak, boolean ignoreCase)
		throws REException
	{
		int ruleAction = SPAN | REGEXP |
			((noLineBreak) ? NO_LINE_BREAK : 0) |
			((atLineStart) ? AT_LINE_START : 0) |
			((atWhitespaceEnd) ? AT_WHITESPACE_END : 0) |
			((atWordStart) ? AT_WORD_START : 0) |
			((excludeMatch) ? EXCLUDE_MATCH : 0) |
			((noWordBreak) ? NO_WORD_BREAK : 0);

		return new ParserRule(ruleAction, hashChar,
			null, new RE(""\\A"" + begin,(ignoreCase ? RE.REG_ICASE : 0),
			RESearchMatcher.RE_SYNTAX_JEDIT),
			end.toCharArray(), delegate, id);
	} 

	
	public static final ParserRule createEOLSpanRule(String seq,
		String delegate, byte id, boolean atLineStart,
		boolean atWhitespaceEnd, boolean atWordStart,
		boolean excludeMatch)
	{
		int ruleAction = EOL_SPAN |
			((atLineStart) ? AT_LINE_START : 0) |
			((atWhitespaceEnd) ? AT_WHITESPACE_END : 0) |
			((atWordStart) ? AT_WORD_START : 0) |
			((excludeMatch) ? EXCLUDE_MATCH : 0)
			| NO_LINE_BREAK;

		return new ParserRule(ruleAction, seq.charAt(0),
			seq.toCharArray(), null, null,
			delegate, id);
	} 

	
	public static final ParserRule createRegexpEOLSpanRule(
		char hashChar, String seq, String delegate, byte id,
		boolean atLineStart, boolean atWhitespaceEnd, boolean atWordStart,
		boolean excludeMatch, boolean ignoreCase)
		throws REException
	{
		int ruleAction = EOL_SPAN | REGEXP |
			((atLineStart) ? AT_LINE_START : 0) |
			((atWhitespaceEnd) ? AT_WHITESPACE_END : 0) |
			((atWordStart) ? AT_WORD_START : 0) |
			((excludeMatch) ? EXCLUDE_MATCH : 0)
			| NO_LINE_BREAK;

		return new ParserRule(ruleAction, hashChar,
			null, new RE(""\\A"" + seq,(ignoreCase ? RE.REG_ICASE : 0),
			RESearchMatcher.RE_SYNTAX_JEDIT), null,
			delegate, id);
	} 

	
	public static final ParserRule createMarkFollowingRule(String seq,
		byte id, boolean atLineStart, boolean atWhitespaceEnd,
		boolean atWordStart, boolean excludeMatch)
	{
		int ruleAction = MARK_FOLLOWING |
			((atLineStart) ? AT_LINE_START : 0) |
			((atWhitespaceEnd) ? AT_WHITESPACE_END : 0) |
			((atWordStart) ? AT_WORD_START : 0) |
			((excludeMatch) ? EXCLUDE_MATCH : 0);

		return new ParserRule(ruleAction, seq.charAt(0),
			seq.toCharArray(), null, null,
			null, id);
	} 

	
	public static final ParserRule createMarkPreviousRule(String seq,
		byte id, boolean atLineStart, boolean atWhitespaceEnd,
		boolean atWordStart, boolean excludeMatch)
	{
		int ruleAction = MARK_PREVIOUS |
			((atLineStart) ? AT_LINE_START : 0) |
			((atWhitespaceEnd) ? AT_WHITESPACE_END : 0) |
			((atWordStart) ? AT_WORD_START : 0) |
			((excludeMatch) ? EXCLUDE_MATCH : 0);

		return new ParserRule(ruleAction, seq.charAt(0),
			seq.toCharArray(), null, null,
			null, id);
	} 

	
	public static final ParserRule createEscapeRule(String seq)
	{
		int ruleAction = IS_ESCAPE;

		return new ParserRule(ruleAction, seq.charAt(0),
			seq.toCharArray(), null, null,
			null, Token.NULL);
	} 

	
	private String delegate;

	private ParserRule(int action, char hashChar, char[] start,
		RE startRegexp, char[] end, String delegate, byte token)
	{
		this.hashChar = hashChar;
		this.start = start;
		this.startRegexp = startRegexp;
		this.end = end;
		this.delegate = delegate;
		this.action = action;
		this.token = token;
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.SplashScreen,5,3,0,3,56,2,1,2,5,0.642857143,289,1.0,0,0.987987988,0.7,2,6,55.4,2,1.0,2,"

package org.gjt.sp.jedit.gui;

import java.awt.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.Log;


public class SplashScreen extends Canvas
{
	public SplashScreen()
	{
		setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
		setBackground(Color.white);

		Font font = new Font(""Dialog"",Font.PLAIN,10);
		setFont(font);
		fm = getFontMetrics(font);

		image = getToolkit().getImage(
			getClass().getResource(""/org/gjt/sp/jedit/icons/splash.png""));
		MediaTracker tracker = new MediaTracker(this);
		tracker.addImage(image,0);

		try
		{
			tracker.waitForAll();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}

		win = new Window(new Frame());

		Dimension screen = getToolkit().getScreenSize();
		Dimension size = new Dimension(image.getWidth(this) + 2,
			image.getHeight(this) + 2 + PROGRESS_HEIGHT);
		win.setSize(size);

		win.setLayout(new BorderLayout());
		win.add(BorderLayout.CENTER,this);

		win.setLocation((screen.width - size.width) / 2,
			(screen.height - size.height) / 2);
		win.validate();
		win.show();

		
	}

	public void dispose()
	{
		win.dispose();
	}

	public synchronized void advance()
	{
		progress++;
		repaint();

		
		
		try
		{
			wait();
		}
		catch(InterruptedException ie)
		{
			Log.log(Log.ERROR,this,ie);
		}
	}

	public void update(Graphics g)
	{
		paint(g);
	}

	public synchronized void paint(Graphics g)
	{
		Dimension size = getSize();

		if(offscreenImg == null)
		{
			offscreenImg = createImage(size.width,size.height);
			offscreenGfx = offscreenImg.getGraphics();
			offscreenGfx.setFont(getFont());
		}

		offscreenGfx.setColor(Color.gray);
		offscreenGfx.drawRect(0,0,size.width - 1,size.height - 1);

		offscreenGfx.drawImage(image,1,1,this);

		
		offscreenGfx.setColor(new Color(168,173,189));
		offscreenGfx.fillRect(1,image.getHeight(this) + 1,
			((win.getWidth() - 2) * progress) / 6,PROGRESS_HEIGHT);

		offscreenGfx.setColor(Color.gray);

		String str = ""Version "" + jEdit.getVersion();

		offscreenGfx.drawString(str,
			(getWidth() - fm.stringWidth(str)) / 2,
			image.getHeight(this)+1 - fm.getDescent() - 10);

		g.drawImage(offscreenImg,0,0,this);

		notify();
	}

	
	private FontMetrics fm;
	private Window win;
	private Image image;
	private Image offscreenImg;
	private Graphics offscreenGfx;
	private int progress;
	private static final int PROGRESS_HEIGHT = 20;
}
"
jEdit,4.1,org.gjt.sp.jedit.options.ShortcutsOptionPane,12,6,0,12,59,38,5,11,1,0.8,307,1.0,1,0.983823529,0.25,4,12,24.16666667,3,1.5833,1,"

package org.gjt.sp.jedit.options;

import javax.swing.table.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.GrabKeyDialog;
import org.gjt.sp.jedit.*;


public class ShortcutsOptionPane extends AbstractOptionPane
{
	public ShortcutsOptionPane()
	{
		super(""shortcuts"");
	}

	
	protected void _init()
	{
		allBindings = new Vector();

		setLayout(new BorderLayout(12,12));

		initModels();

		selectModel = new JComboBox(models);
		selectModel.addActionListener(new ActionHandler());

		Box north = Box.createHorizontalBox();
		north.add(new JLabel(jEdit.getProperty(
			""options.shortcuts.select.label"")));
		north.add(Box.createHorizontalStrut(6));
		north.add(selectModel);

		keyTable = new JTable(currentModel);
		keyTable.getTableHeader().setReorderingAllowed(false);
		keyTable.getTableHeader().addMouseListener(new HeaderMouseHandler());
		keyTable.addMouseListener(new TableMouseHandler());
		Dimension d = keyTable.getPreferredSize();
		d.height = Math.min(d.height,200);
		JScrollPane scroller = new JScrollPane(keyTable);
		scroller.setPreferredSize(d);

		add(BorderLayout.NORTH,north);
		add(BorderLayout.CENTER,scroller);
	}

	protected void _save()
	{
		if(keyTable.getCellEditor() != null)
			keyTable.getCellEditor().stopCellEditing();

		Enumeration e = models.elements();
		while(e.hasMoreElements())
			((ShortcutsModel)e.nextElement()).save();

		Macros.loadMacros();
	}

	private void initModels()
	{
		models = new Vector();
		ActionSet[] actionSets = jEdit.getActionSets();
		for(int i = 0; i < actionSets.length; i++)
		{
			ActionSet actionSet = actionSets[i];
			if(actionSet.getActionCount() != 0)
			{
				models.addElement(createModel(actionSet.getLabel(),
					actionSet.getActions()));
			}
		}
		currentModel = (ShortcutsModel)models.elementAt(0);
	}

	private ShortcutsModel createModel(String modelLabel, EditAction[] actions)
	{
		Vector bindings = new Vector(actions.length);

		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];

			String name = action.getName();
			String label = action.getLabel();
			
			if(label == null)
				continue;

			label = GUIUtilities.prettifyMenuLabel(label);
			addBindings(name,label,bindings);
		}

		return new ShortcutsModel(modelLabel,bindings);
	}

	private void addBindings(String name, String label, Vector bindings)
	{
		GrabKeyDialog.KeyBinding b[] = new GrabKeyDialog.KeyBinding[2];

		b[0] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut""));
		b[1] = createBinding(name,label,
			jEdit.getProperty(name + "".shortcut2""));

		bindings.addElement(b);
	}

	private GrabKeyDialog.KeyBinding createBinding(String name,
		String label, String shortcut)
	{
		if(shortcut != null && shortcut.length() == 0)
			shortcut = null;

		GrabKeyDialog.KeyBinding binding
			= new GrabKeyDialog.KeyBinding(name,label,shortcut,false);

		allBindings.addElement(binding);
		return binding;
	}

	
	private JTable keyTable;
	private Vector models;
	private ShortcutsModel currentModel;
	private JComboBox selectModel;
	private Vector allBindings;

	class HeaderMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			switch(keyTable.getTableHeader().columnAtPoint(evt.getPoint()))
			{
			case 0:
				currentModel.sort(0);
				break;
			case 1:
				currentModel.sort(1);
				break;
			case 2:
				currentModel.sort(2);
				break;
			}
		}
	}

	class TableMouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			int row = keyTable.getSelectedRow();
			int col = keyTable.getSelectedColumn();
			if(col != 0 && row != -1)
			{
				 GrabKeyDialog gkd = new GrabKeyDialog(
					GUIUtilities.getParentDialog(
					ShortcutsOptionPane.this),
					currentModel.getBindingAt(row,col-1),
					allBindings,null);
				if(gkd.isOK())
					currentModel.setValueAt(
						gkd.getShortcut(),row,col);
			}
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			ShortcutsModel newModel
				= (ShortcutsModel)selectModel.getSelectedItem();

			if(currentModel != newModel)
			{
				currentModel = newModel;
				keyTable.setModel(currentModel);
			}
		}
	}

	class ShortcutsModel extends AbstractTableModel
	{
		private Vector bindings;
		private String name;

		ShortcutsModel(String name, Vector bindings)
		{
			this.name = name;
			this.bindings = bindings;
			sort(0);
		}

		public void sort(int col)
		{
			MiscUtilities.quicksort(bindings,new KeyCompare(col));
			fireTableDataChanged();
		}

		public int getColumnCount()
		{
			return 3;
		}

		public int getRowCount()
		{
			return bindings.size();
		}

		public Object getValueAt(int row, int col)
		{
			switch(col)
			{
			case 0:
				return getBindingAt(row,0).label;
			case 1:
				return getBindingAt(row,0).shortcut;
			case 2:
				return getBindingAt(row,1).shortcut;
			default:
				return null;
			}
		}

		public void setValueAt(Object value, int row, int col)
		{
			if(col == 0)
				return;

			getBindingAt(row,col-1).shortcut = (String)value;

			
			
			fireTableDataChanged();
		}

		public String getColumnName(int index)
		{
			switch(index)
			{
			case 0:
				return jEdit.getProperty(""options.shortcuts.name"");
			case 1:
				return jEdit.getProperty(""options.shortcuts.shortcut1"");
			case 2:
				return jEdit.getProperty(""options.shortcuts.shortcut2"");
			default:
				return null;
			}
		}

		public void save()
		{
			Enumeration enum = bindings.elements();
			while(enum.hasMoreElements())
			{
				GrabKeyDialog.KeyBinding binding[]
					= (GrabKeyDialog.KeyBinding[])
						enum.nextElement();
				jEdit.setProperty(
					binding[0].name + "".shortcut"",
					binding[0].shortcut);
				jEdit.setProperty(
					binding[1].name + "".shortcut2"",
					binding[1].shortcut);
			}
		}

		public GrabKeyDialog.KeyBinding getBindingAt(int row, int nr)
		{
			GrabKeyDialog.KeyBinding binding[]
				= (GrabKeyDialog.KeyBinding[])
					bindings.elementAt(row);
			return binding[nr];
		}

		public String toString()
		{
			return name;
		}

		class KeyCompare implements MiscUtilities.Compare
		{
			int col;

			KeyCompare(int col)
			{
				this.col = col;
			}

			public int compare(Object obj1, Object obj2)
			{
				GrabKeyDialog.KeyBinding[] k1
					= (GrabKeyDialog.KeyBinding[])obj1;
				GrabKeyDialog.KeyBinding[] k2
					= (GrabKeyDialog.KeyBinding[])obj2;

				String label1 = k1[0].label.toLowerCase();
				String label2 = k2[0].label.toLowerCase();

				if(col == 0)
					return MiscUtilities.compareStrings(
						label1,label2,true);
				else
				{
					String shortcut1, shortcut2;

					if(col == 1)
					{
						shortcut1 = k1[0].shortcut;
						shortcut2 = k2[0].shortcut;
					}
					else
					{
						shortcut1 = k1[1].shortcut;
						shortcut2 = k2[1].shortcut;
					}

					if(shortcut1 == null && shortcut2 != null)
						return 1;
					else if(shortcut2 == null && shortcut1 != null)
						return -1;
					else if(shortcut1 == null && shortcut2 == null)
						return MiscUtilities.compareStrings(label1,label2,true);
					else
						return MiscUtilities.compareStrings(shortcut1,shortcut2,true);
				}
			}
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.ViewRegisters,6,7,0,8,47,9,3,8,3,0.8,299,1.0,0,0.992435703,0.388888889,0,0,48.33333333,1,0.8333,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;

public class ViewRegisters extends EnhancedDialog
{
	public ViewRegisters(View view)
	{
		super(view,jEdit.getProperty(""view-registers.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JPanel panel = new JPanel(new BorderLayout());
		panel.setBorder(new EmptyBorder(0,12,0,0));

		JLabel label = new JLabel(jEdit.getProperty(""view-registers.register""));
		label.setBorder(new EmptyBorder(0,0,3,0));
		panel.add(BorderLayout.NORTH,label);

		DefaultListModel registerModel = new DefaultListModel();
		registerList = new JList(registerModel);
		registerList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		registerList.setCellRenderer(new Renderer());

		Registers.Register[] registers = Registers.getRegisters();

		int index = 0;
		for(int i = 0; i < registers.length; i++)
		{
			Registers.Register reg = registers[i];
			if(reg == null)
				continue;

			String value = reg.toString();
			if(value == null || value.length() == 0)
				continue;

			registerModel.addElement(new Character((char)i));
		}

		if(registerModel.getSize() == 0)
			registerModel.addElement(jEdit.getProperty(""view-registers.none""));

		panel.add(BorderLayout.CENTER,new JScrollPane(registerList));

		content.add(BorderLayout.WEST,panel);

		panel = new JPanel(new BorderLayout());
		panel.setBorder(new EmptyBorder(0,12,0,0));

		label = new JLabel(jEdit.getProperty(""view-registers.contents""));
		label.setBorder(new EmptyBorder(0,0,3,0));
		panel.add(BorderLayout.NORTH,label);

		contentTextArea = new JTextArea(10,80);
		contentTextArea.setEditable(false);
		panel.add(BorderLayout.CENTER,new JScrollPane(contentTextArea));
		content.add(BorderLayout.CENTER,panel);

		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		panel.add(Box.createGlue());
		panel.add(close);
		panel.add(Box.createGlue());
		getRootPane().setDefaultButton(close);
		content.add(BorderLayout.SOUTH,panel);

		registerList.addListSelectionListener(new ListHandler());
		registerList.setSelectedIndex(index);

		pack();
		setLocationRelativeTo(view);
		show();
	}

	
	public void ok()
	{
		dispose();
	}

	public void cancel()
	{
		dispose();
	}
	

	
	private JList registerList;
	private JTextArea contentTextArea;
	private JButton close;

	class Renderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list, Object value, int index,
			boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,
				index,isSelected,cellHasFocus);

			if(value instanceof Character)
			{
				char name = ((Character)value).charValue();

				String label;

				if(name == '\n')
					label = ""\n"";
				else if(name == '\t')
					label = ""\t"";
				else if(name == '$')
					label = jEdit.getProperty(""view-registers.clipboard"");
				else if(name == '%')
					label = jEdit.getProperty(""view-registers.selection"");
				else
					label = String.valueOf((char)name);

				setText(label);
			}

			return this;
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == close)
				cancel();
		}
	}

	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object value = registerList.getSelectedValue();
			if(!(value instanceof Character))
				return;

			char name = ((Character)value).charValue();

			Registers.Register reg = Registers.getRegister(name);

			if(reg == null)
				return;

			contentTextArea.setText(reg.toString());
			contentTextArea.setCaretPosition(0);
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.browser.BrowserCommandsMenu,6,5,0,12,45,5,6,7,2,0.828571429,536,1.0,3,0.993055556,0.3,0,0,87.16666667,3,1.5,0,"

package org.gjt.sp.jedit.browser;


import java.awt.event.*;
import java.util.*;
import javax.swing.*;

import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;



public class BrowserCommandsMenu extends JPopupMenu
{
	
	public BrowserCommandsMenu(VFSBrowser browser, VFS.DirectoryEntry[] files)
	{
		this.browser = browser;

		if(files != null)
		{
			this.files = files;

			VFS vfs = VFSManager.getVFSForPath(files[0].deletePath);
			int type = files[0].type;
			boolean fileOpen = (jEdit.getBuffer(files[0].path) != null);
			boolean delete = !fileOpen && (vfs.getCapabilities() & VFS.DELETE_CAP) != 0;
			boolean rename = !fileOpen && (vfs.getCapabilities() & VFS.RENAME_CAP) != 0;

			for(int i = 1; i < files.length; i++)
			{
				VFS.DirectoryEntry file = files[i];

				VFS _vfs = VFSManager.getVFSForPath(file.deletePath);
				delete &= (vfs == _vfs) && (_vfs.getCapabilities()
					& VFS.DELETE_CAP) != 0;

				if(type == file.type)
					;
				else
				{
					
					
					type = -1;
				}

				
				rename = false;

				
				
				if(jEdit.getBuffer(file.path) != null)
					fileOpen = true;
			}

			if(type == VFS.DirectoryEntry.DIRECTORY
				|| type == VFS.DirectoryEntry.FILESYSTEM)
			{
				if(files.length == 1)
					add(createMenuItem(""browse""));
				if(browser.getMode() == VFSBrowser.BROWSER)
					add(createMenuItem(""browse-window""));
			}
			else if(type == VFS.DirectoryEntry.FILE
				&& (browser.getMode() == VFSBrowser.BROWSER
				|| browser.getMode() == VFSBrowser.BROWSER_DIALOG))
			{
				add(createMenuItem(""open""));
				JMenu openIn = new JMenu(jEdit.getProperty(
					""vfs.browser.commands.open-in.label""));
				openIn.add(createMenuItem(""open-view""));
				openIn.add(createMenuItem(""open-plain-view""));
				openIn.add(createMenuItem(""open-split""));
				add(openIn);
				add(createMenuItem(""insert""));

				if(fileOpen)
					add(createMenuItem(""close""));
			}
			else if(type != -1)
				add(createMenuItem(""choose""));

			if(rename)
				add(createMenuItem(""rename""));
			if(delete)
				add(createMenuItem(""delete""));

			addSeparator();
		}

		add(createMenuItem(""up""));
		add(createMenuItem(""reload""));
		add(createMenuItem(""roots""));
		add(createMenuItem(""home""));
		add(createMenuItem(""synchronize""));
		addSeparator();

		if(browser.getMode() == VFSBrowser.BROWSER)
			add(createMenuItem(""new-file""));

		add(createMenuItem(""new-directory""));

		if(browser.getMode() == VFSBrowser.BROWSER)
		{
			addSeparator();
			add(createMenuItem(""search-in-directory""));
		}

		addSeparator();

		showHiddenFiles = new JCheckBoxMenuItem(
			jEdit.getProperty(""vfs.browser.commands.show-hidden-files.label""));
		showHiddenFiles.setActionCommand(""show-hidden-files"");
		showHiddenFiles.addActionListener(new ActionHandler());
		add(showHiddenFiles);

		if(browser.getMode() == VFSBrowser.BROWSER
			|| browser.getMode() == VFSBrowser.BROWSER_DIALOG)
		{
			addSeparator();
			add(createEncodingMenu());
		}

		update();
	} 

	
	public void update()
	{
		showHiddenFiles.setSelected(browser.getShowHiddenFiles());
		if(encodingMenuItems != null)
		{
			JRadioButtonMenuItem mi = (JRadioButtonMenuItem)
				encodingMenuItems.get(browser.currentEncoding);
			if(mi != null)
			{
				mi.setSelected(true);
				otherEncoding.setText(jEdit.getProperty(
					""vfs.browser.commands.other-encoding.label""));
			}
			else
			{
				otherEncoding.setSelected(true);
				otherEncoding.setText(jEdit.getProperty(
					""vfs.browser.commands.other-encoding-2.label"",
					new String[] { browser.currentEncoding }));
			}
		}
	} 

	
	private VFSBrowser browser;
	private VFS.DirectoryEntry[] files;
	private VFS vfs;
	private JCheckBoxMenuItem showHiddenFiles;
	private HashMap encodingMenuItems;
	private JRadioButtonMenuItem defaultEncoding;
	private JRadioButtonMenuItem otherEncoding;

	
	private JMenuItem createMenuItem(String name)
	{
		String label = jEdit.getProperty(""vfs.browser.commands."" + name + "".label"");
		JMenuItem mi = new JMenuItem(label);
		mi.setActionCommand(name);
		mi.addActionListener(new ActionHandler());
		return mi;
	} 

	
	private JMenu createEncodingMenu()
	{
		ActionHandler actionHandler = new ActionHandler();

		encodingMenuItems = new HashMap();
		JMenu encodingMenu = new JMenu(jEdit.getProperty(
			""vfs.browser.commands.encoding.label""));

		ButtonGroup grp = new ButtonGroup();

		StringTokenizer st = new StringTokenizer(
			jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			String encoding = st.nextToken();
			JRadioButtonMenuItem mi = new JRadioButtonMenuItem(encoding);
			mi.setActionCommand(""encoding@"" + encoding);
			mi.addActionListener(actionHandler);
			grp.add(mi);
			encodingMenuItems.put(encoding,mi);
			encodingMenu.add(mi);
		}

		String systemEncoding = System.getProperty(""file.encoding"");
		if(encodingMenuItems.get(systemEncoding) == null)
		{
			JRadioButtonMenuItem mi = new JRadioButtonMenuItem(
				systemEncoding);
			mi.setActionCommand(""encoding@"" + systemEncoding);
			mi.addActionListener(actionHandler);
			grp.add(mi);
			encodingMenuItems.put(systemEncoding,mi);
			encodingMenu.add(mi);
		}

		encodingMenu.addSeparator();

		otherEncoding = new JRadioButtonMenuItem();
		otherEncoding.setActionCommand(""other-encoding"");
		otherEncoding.addActionListener(actionHandler);
		grp.add(otherEncoding);
		encodingMenu.add(otherEncoding);

		return encodingMenu;
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			View view = browser.getView();
			String actionCommand = evt.getActionCommand();

			if(actionCommand.equals(""other-encoding""))
			{
				String encoding = GUIUtilities.input(browser,
					""encoding-prompt"",null,
					jEdit.getProperty(""buffer.encoding"",
					System.getProperty(""file.encoding"")));
				if(encoding == null)
					return;
				browser.currentEncoding = encoding;
			}
			else if(actionCommand.startsWith(""encoding@""))
			{
				browser.currentEncoding = actionCommand.substring(9);
			}
			else if(actionCommand.equals(""open""))
				browser.filesActivated(VFSBrowser.M_OPEN,false);
			else if(actionCommand.equals(""open-view""))
				browser.filesActivated(VFSBrowser.M_OPEN_NEW_VIEW,false);
			else if(actionCommand.equals(""open-plain-view""))
				browser.filesActivated(VFSBrowser.M_OPEN_NEW_PLAIN_VIEW,false);
			else if(actionCommand.equals(""open-split""))
				browser.filesActivated(VFSBrowser.M_OPEN_NEW_SPLIT,false);
			else if(actionCommand.equals(""insert""))
			{
				for(int i = 0; i < files.length; i++)
				{
					view.getBuffer().insertFile(view,files[i].path);
				}
			}
			else if(actionCommand.equals(""choose""))
				browser.filesActivated(VFSBrowser.M_OPEN,false);
			else if(actionCommand.equals(""close""))
			{
				for(int i = 0; i < files.length; i++)
				{
					Buffer buffer = jEdit.getBuffer(files[i].path);
					if(buffer != null)
						jEdit.closeBuffer(view,buffer);
				}
			}
			else if(actionCommand.equals(""browse""))
				browser.setDirectory(files[0].path);
			else if(actionCommand.equals(""browse-window""))
			{
				for(int i = 0; i < files.length; i++)
				{
					VFSBrowser.browseDirectoryInNewWindow(view,
						files[i].path);
				}
			}
			else if(actionCommand.equals(""rename""))
				browser.rename(files[0].path);
			else if(actionCommand.equals(""delete""))
				browser.delete(files);
			else if(actionCommand.equals(""up""))
			{
				String path = browser.getDirectory();
				VFS vfs = VFSManager.getVFSForPath(path);
				browser.setDirectory(vfs.getParentOfPath(path));
			}
			else if(actionCommand.equals(""reload""))
				browser.reloadDirectory();
			else if(actionCommand.equals(""roots""))
				browser.rootDirectory();
			else if(actionCommand.equals(""home""))
				browser.setDirectory(System.getProperty(""user.home""));
			else if(actionCommand.equals(""synchronize""))
			{
				Buffer buffer = browser.getView().getBuffer();
				browser.setDirectory(buffer.getDirectory());
			}
			else if(actionCommand.equals(""new-file""))
				browser.newFile();
			else if(actionCommand.equals(""new-directory""))
				browser.mkdir();
			else if(actionCommand.equals(""search-in-directory""))
				browser.searchInDirectory();
			else if(actionCommand.equals(""show-hidden-files""))
			{
				browser.setShowHiddenFiles(!browser.getShowHiddenFiles());
				browser.reloadDirectory();
			}
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.EnhancedMenu,5,7,5,8,27,8,6,3,5,0.625,121,1.0,0,0.995359629,0.6,2,2,22.8,6,1.8,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.event.*;
import javax.swing.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;


public class EnhancedMenu extends JMenu implements MenuListener
{
	
	public EnhancedMenu(String name)
	{
		this._name = name;
		String label = jEdit.getProperty(name.concat("".label""));
		if(label == null)
			label = name;

		char mnemonic;
		int index = label.indexOf('$');
		if(index != -1 && label.length() - index > 1)
		{
			mnemonic = Character.toLowerCase(label.charAt(index + 1));
			label = label.substring(0,index).concat(label.substring(++index));
		}
		else
			mnemonic = '\0';

		setText(label);
		if(!OperatingSystem.isMacOS())
			setMnemonic(mnemonic);

		addMenuListener(this);
		
	} 

	
	public void menuSelected(MenuEvent evt)
	{
		init();
	} 

	public void menuDeselected(MenuEvent e) {}

	public void menuCanceled(MenuEvent e) {}

	
	public void init()
	{
		if(initialized)
			return;

		initialized = true;

		String menuItems = jEdit.getProperty(_name);
		if(menuItems != null)
		{
			StringTokenizer st = new StringTokenizer(menuItems);
			while(st.hasMoreTokens())
			{
				String menuItemName = st.nextToken();
				if(menuItemName.equals(""-""))
					addSeparator();
				else
				{
					if(menuItemName.startsWith(""%""))
						add(GUIUtilities.loadMenu(menuItemName.substring(1)));
					else
						add(GUIUtilities.loadMenuItem(menuItemName));
				}
			}
		}
	} 

	protected String _name;
	protected boolean initialized;
}
"
jEdit,4.1,org.gjt.sp.jedit.options.GlobalOptions,6,8,0,27,35,13,3,24,4,0.933333333,233,1.0,3,0.997028232,0.5,1,1,37.33333333,3,0.6667,0,"

package org.gjt.sp.jedit.options;


import java.awt.Dialog;
import java.awt.Frame;
import org.gjt.sp.jedit.gui.OptionsDialog;
import org.gjt.sp.jedit.options.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class GlobalOptions extends OptionsDialog
{
	
	public GlobalOptions(Frame frame)
	{
		super(frame,""options"",jEdit.getProperty(""options.last""));
	} 

	
	public GlobalOptions(Frame frame, String pane)
	{
		super(frame,""options"",pane);
	} 

	
	public GlobalOptions(Dialog dialog)
	{
		super(dialog,""options"",jEdit.getProperty(""options.last""));
	} 

	
	public GlobalOptions(Dialog dialog, String pane)
	{
		super(dialog,""options"",pane);
	} 

	
	protected OptionTreeModel createOptionTreeModel()
	{
		OptionTreeModel paneTreeModel = new OptionTreeModel();
		OptionGroup rootGroup = (OptionGroup) paneTreeModel.getRoot();

		
		jEditGroup = new OptionGroup(""jedit"");

		addOptionPane(new AbbrevsOptionPane(), jEditGroup);
		addOptionPane(new AppearanceOptionPane(), jEditGroup);
		addOptionPane(new ContextOptionPane(), jEditGroup);
		addOptionPane(new DockingOptionPane(), jEditGroup);
		addOptionPane(new EditingOptionPane(), jEditGroup);
		addOptionPane(new GeneralOptionPane(), jEditGroup);
		addOptionPane(new GutterOptionPane(), jEditGroup);
		addOptionPane(new LoadSaveOptionPane(), jEditGroup);
		addOptionPane(new PrintOptionPane(), jEditGroup);
		addOptionPane(new FirewallOptionPane(), jEditGroup);
		addOptionPane(new ShortcutsOptionPane(), jEditGroup);
		addOptionPane(new StatusBarOptionPane(), jEditGroup);
		addOptionPane(new SyntaxHiliteOptionPane(), jEditGroup);
		addOptionPane(new TextAreaOptionPane(), jEditGroup);
		addOptionPane(new ToolBarOptionPane(), jEditGroup);
		addOptionGroup(jEditGroup, rootGroup);

		browserGroup = new OptionGroup(""browser"");
		addOptionPane(new BrowserColorsOptionPane(), browserGroup);
		addOptionPane(new BrowserOptionPane(), browserGroup);
		addOptionGroup(browserGroup, rootGroup);

		
		pluginsGroup = new OptionGroup(""plugins"");

		
		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin ep = plugins[i];
			try
			{
				ep.createOptionPanes(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR, ep,
					""Error creating option pane"");
				Log.log(Log.ERROR, ep, t);
			}
		}

		
		if (pluginsGroup.getMemberCount() > 0)
		{
			addOptionGroup(pluginsGroup, rootGroup);
		}

		return paneTreeModel;
	} 

	
	protected OptionGroup getDefaultGroup()
	{
		return pluginsGroup;
	} 

	
	private OptionGroup jEditGroup;
	private OptionGroup browserGroup;
	private OptionGroup pluginsGroup;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.search.SearchMatcher,2,1,0,5,2,1,4,1,2,2.0,2,0.0,0,0.0,0.625,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.search;

import gnu.regexp.CharIndexed;


public interface SearchMatcher
{
	
	int[] nextMatch(CharIndexed text, boolean start, boolean end,
		boolean firstTime, boolean reverse);

	
	String substitute(String text) throws Exception;
}
"
jEdit,4.1,org.gjt.sp.jedit.msg.EditorExitRequested,2,2,0,4,4,1,1,3,2,2.0,10,0.0,0,0.75,0.75,0,0,4.0,1,0.5,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBMessage;
import org.gjt.sp.jedit.View;


public class EditorExitRequested extends EBMessage
{
	
	public EditorExitRequested(View view)
	{
		super(view);
	}

	
	public View getView()
	{
		return (View)getSource();
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.browser.BrowserIORequest,7,2,0,9,29,0,2,8,3,0.625,879,0.666666667,2,0.5,0.25,0,0,122.8571429,3,1.4286,2,"

package org.gjt.sp.jedit.browser;


import javax.swing.tree.DefaultMutableTreeNode;
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.util.*;



class BrowserIORequest extends WorkRequest
{
	
	
	public static final int LIST_DIRECTORY = 0;

	
	public static final int DELETE = 1;

	
	public static final int RENAME = 2;

	
	public static final int MKDIR = 3;
	

	
	
	public BrowserIORequest(int type, VFSBrowser browser,
		Object session, VFS vfs, String path1, String path2,
		DefaultMutableTreeNode node, boolean loadingRoot)
	{
		this.type = type;
		this.browser = browser;
		this.session = session;
		this.vfs = vfs;
		this.path1 = path1;
		this.path2 = path2;
		this.node = node;
		this.loadingRoot = loadingRoot;
	} 

	
	public void run()
	{
		switch(type)
		{
		case LIST_DIRECTORY:
			listDirectory();
			break;
		case DELETE:
			delete();
			break;
		case RENAME:
			rename();
			break;
		case MKDIR:
			mkdir();
			break;
		}

		if(type != LIST_DIRECTORY)
			browser.endRequest();
	} 

	
	public String toString()
	{
		String typeString;
		switch(type)
		{
		case LIST_DIRECTORY:
			typeString = ""LIST_DIRECTORY"";
			break;
		case DELETE:
			typeString = ""DELETE"";
			break;
		case RENAME:
			typeString = ""RENAME"";
			break;
		case MKDIR:
			typeString = ""MKDIR"";
			break;
		default:
			typeString = ""UNKNOWN!!!"";
			break;
		}

		return getClass().getName() + ""[type="" + typeString
			+ "",vfs="" + vfs + "",path1="" + path1
			+ "",path2="" + path2 + ""]"";
	} 

	

	
	private int type;
	private VFSBrowser browser;
	private Object session;
	private VFS vfs;
	private String path1;
	private String path2;
	private DefaultMutableTreeNode node;
	private boolean loadingRoot;
	

	
	private void listDirectory()
	{
		VFS.DirectoryEntry[] directory = null;

		String[] args = { path1 };
		setStatus(jEdit.getProperty(""vfs.status.listing-directory"",args));

		String canonPath = path1;

		try
		{
			setAbortable(true);

			canonPath = vfs._canonPath(session,path1,browser);
			directory = vfs._listDirectory(session,canonPath,browser);
		}
		catch(IOException io)
		{
			setAbortable(false);
			Log.log(Log.ERROR,this,io);
			String[] pp = { io.toString() };
			VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}

		setAbortable(false);

		browser.directoryLoaded(node,loadingRoot,canonPath,directory);
	} 

	
	private void delete()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.deleting"",args));

			try
			{
				path1 = vfs._canonPath(session,path1,browser);


				if(!vfs._delete(session,path1,browser))
					VFSManager.error(browser,path1,""ioerror.delete-error"",null);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
	} 

	
	private void rename()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1, path2 };
			setStatus(jEdit.getProperty(""vfs.status.renaming"",args));

			try
			{
				path1 = vfs._canonPath(session,path1,browser);
				path2 = vfs._canonPath(session,path2,browser);

				VFS.DirectoryEntry file = vfs._getDirectoryEntry(
					session,path2,browser);
				if(file != null)
					VFSManager.error(browser,path1,""ioerror.rename-exists"",
						new String[] { path2 });
				else
				{
					if(!vfs._rename(session,path1,path2,browser))
						VFSManager.error(browser,path1,""ioerror.rename-error"",
							new String[] { path2 });
				}
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(browser,path1,""ioerror.directory-error"",pp);
			}
		}
	} 

	
	private void mkdir()
	{
		try
		{
			setAbortable(true);
			String[] args = { path1 };
			setStatus(jEdit.getProperty(""vfs.status.mkdir"",args));

			try
			{
				path1 = vfs._canonPath(session,path1,browser);

				if(!vfs._mkdir(session,path1,browser))
					VFSManager.error(browser,path1,""ioerror.mkdir-error"",null);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				args[0] = io.toString();
				VFSManager.error(browser,path1,""ioerror"",args);
			}
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,browser);
			}
			catch(IOException io)
			{
				setAbortable(false);
				Log.log(Log.ERROR,this,io);
				String[] args = { io.toString() };
				VFSManager.error(browser,path1,""ioerror"",args);
			}
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.BufferIORequest,11,2,0,12,108,11,2,12,3,0.914285714,1839,0.333333333,3,0.375,0.236363636,0,0,164.2727273,20,5.0909,4,"

package org.gjt.sp.jedit.buffer;


import javax.swing.text.Segment;
import java.io.*;
import java.util.zip.*;
import java.util.Vector;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



public class BufferIORequest extends WorkRequest
{
	
	
	public static final int IOBUFSIZE = 32768;

	
	public static final int PROGRESS_INTERVAL = 300;

	public static final String LOAD_DATA = ""BufferIORequest__loadData"";
	public static final String END_OFFSETS = ""BufferIORequest__endOffsets"";
	public static final String NEW_PATH = ""BufferIORequest__newPath"";

	
	public static final String ERROR_OCCURRED = ""BufferIORequest__error"";

	
	public static final int LOAD = 0;

	
	public static final int SAVE = 1;

	
	public static final int AUTOSAVE = 2;

	
	public static final int INSERT = 3;

	
	public static final int GZIP_MAGIC_1 = 0x1f;
	public static final int GZIP_MAGIC_2 = 0x8b;
	public static final int UNICODE_MAGIC_1 = 0xfe;
	public static final int UNICODE_MAGIC_2 = 0xff;
	

	
	
	public BufferIORequest(int type, View view, Buffer buffer,
		Object session, VFS vfs, String path)
	{
		this.type = type;
		this.view = view;
		this.buffer = buffer;
		this.session = session;
		this.vfs = vfs;
		this.path = path;

		markersPath = vfs.getParentOfPath(path)
			+ '.' + vfs.getFileName(path)
			+ "".marks"";
	} 

	
	public void run()
	{
		switch(type)
		{
		case LOAD:
			load();
			break;
		case SAVE:
			save();
			break;
		case AUTOSAVE:
			autosave();
			break;
		case INSERT:
			insert();
			break;
		}
	} 

	
	public String toString()
	{
		String typeString;
		switch(type)
		{
		case LOAD:
			typeString = ""LOAD"";
			break;
		case SAVE:
			typeString = ""SAVE"";
			break;
		case AUTOSAVE:
			typeString = ""AUTOSAVE"";
			break;
		default:
			typeString = ""UNKNOWN!!!"";
		}

		return getClass().getName() + ""[type="" + typeString
			+ "",buffer="" + buffer + ""]"";
	} 

	

	
	private int type;
	private View view;
	private Buffer buffer;
	private Object session;
	private VFS vfs;
	private String path;
	private String markersPath;
	

	
	private void load()
	{
		InputStream in = null;

		try
		{
			try
			{
				String[] args = { vfs.getFileName(path) };
				setAbortable(true);
				if(!buffer.isTemporary())
				{
					setStatus(jEdit.getProperty(""vfs.status.load"",args));
					setProgressValue(0);
				}

				path = vfs._canonPath(session,path,view);

				VFS.DirectoryEntry entry = vfs._getDirectoryEntry(
					session,path,view);
				long length;
				if(entry != null)
					length = entry.length;
				else
					length = 0L;

				in = vfs._createInputStream(session,path,false,view);
				if(in == null)
					return;

				in = new BufferedInputStream(in);

				if(in.markSupported())
				{
					in.mark(2);
					int b1 = in.read();
					int b2 = in.read();
					in.reset();

					if(b1 == GZIP_MAGIC_1 && b2 == GZIP_MAGIC_2)
					{
						in = new GZIPInputStream(in);
						buffer.setBooleanProperty(Buffer.GZIPPED,true);
					}
					else if((b1 == UNICODE_MAGIC_1 && b2 == UNICODE_MAGIC_2)
						|| (b1 == UNICODE_MAGIC_2 && b2 == UNICODE_MAGIC_1))
					{
						buffer.setProperty(Buffer.ENCODING,""Unicode"");
					}
				}
				else if(path.toLowerCase().endsWith("".gz""))
					in = new GZIPInputStream(in);

				read(buffer,in,length);
				buffer.setNewFile(false);
			}
			catch(CharConversionException ch)
			{
				Log.log(Log.ERROR,this,ch);
				Object[] pp = { buffer.getProperty(Buffer.ENCODING),
					ch.toString() };
				VFSManager.error(view,path,""ioerror.encoding-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(UnsupportedEncodingException uu)
			{
				Log.log(Log.ERROR,this,uu);
				Object[] pp = { buffer.getProperty(Buffer.ENCODING),
					uu.toString() };
				VFSManager.error(view,path,""ioerror.encoding-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				Object[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(OutOfMemoryError oom)
			{
				Log.log(Log.ERROR,this,oom);
				VFSManager.error(view,path,""out-of-memory-error"",null);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}

			if(jEdit.getBooleanProperty(""persistentMarkers""))
			{
				try
				{
					String[] args = { vfs.getFileName(path) };
					if(!buffer.isTemporary())
						setStatus(jEdit.getProperty(""vfs.status.load-markers"",args));
					setAbortable(true);

					in = vfs._createInputStream(session,markersPath,true,view);
					if(in != null)
						readMarkers(buffer,in);
				}
				catch(IOException io)
				{
					
				}
			}
		}
		catch(WorkThread.Abort a)
		{
			if(in != null)
			{
				try
				{
					in.close();
				}
				catch(IOException io)
				{
				}
			}

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} 

	
	private void read(Buffer buffer, InputStream _in, long length)
		throws IOException
	{
		IntegerArray endOffsets = new IntegerArray();

		
		boolean trackProgress = (!buffer.isTemporary() && length != 0);

		if(trackProgress)
		{
			setProgressValue(0);
			setProgressMaximum((int)length);
		}

		
		
		if(length == 0)
			length = IOBUFSIZE;

		SegmentBuffer seg = new SegmentBuffer((int)length + 1);

		InputStreamReader in = new InputStreamReader(_in,
			buffer.getStringProperty(Buffer.ENCODING));
		char[] buf = new char[IOBUFSIZE];

		
		
		
		
		int len;

		
		
		boolean CRLF = false;

		
		boolean CROnly = false;

		
		
		
		boolean lastWasCR = false;

		
		
		int lineCount = 0;

		while((len = in.read(buf,0,buf.length)) != -1)
		{
			
			
			
			int lastLine = 0;

			for(int i = 0; i < len; i++)
			{
				
				switch(buf[i])
				{
				case '\r':
					
					
					
					
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
					}
					
					
					
					else
					{
						lastWasCR = true;
					}

					
					seg.append(buf,lastLine,i -
						lastLine);
					endOffsets.add(seg.count);
					seg.append('\n');
					if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
						setProgressValue(seg.count);

					
					
					lastLine = i + 1;
					break;
				case '\n':
					
					
					
					
					
					
					
					if(lastWasCR)
					{
						CROnly = false;
						CRLF = true;
						lastWasCR = false;
						
						
						
						
						lastLine = i + 1;
					}
					
					
					
					
					else
					{
						CROnly = false;
						CRLF = false;
						seg.append(buf,lastLine,
							i - lastLine);
						endOffsets.add(seg.count);
						seg.append('\n');
						if(trackProgress && lineCount++ % PROGRESS_INTERVAL == 0)
							setProgressValue(seg.count);
						lastLine = i + 1;
					}
					break;
				default:
					
					
					
					
					
					if(lastWasCR)
					{
						CROnly = true;
						CRLF = false;
						lastWasCR = false;
					}
					break;
				}
			}

			if(trackProgress)
				setProgressValue(seg.count);

			
			seg.append(buf,lastLine,len - lastLine);
		}

		setAbortable(false);

		String lineSeparator;
		if(CRLF)
			lineSeparator = ""\r\n"";
		else if(CROnly)
			lineSeparator = ""\r"";
		else
			lineSeparator = ""\n"";

		in.close();

		
		int bufferLength = seg.count;
		if(bufferLength != 0)
		{
			char ch = seg.array[bufferLength - 1];
			if(ch == 0x1a )
				seg.count--;
		}

		buffer.setBooleanProperty(Buffer.TRAILING_EOL,false);
		if(bufferLength != 0 && jEdit.getBooleanProperty(""stripTrailingEOL""))
		{
			char ch = seg.array[bufferLength - 1];
			if(ch == '\n')
			{
				buffer.setBooleanProperty(Buffer.TRAILING_EOL,true);
				seg.count--;
				endOffsets.setSize(endOffsets.getSize() - 1);
			}
		}

		
		
		
		buffer.setProperty(LOAD_DATA,seg);
		buffer.setProperty(END_OFFSETS,endOffsets);
		buffer.setProperty(NEW_PATH,path);
		buffer.setProperty(Buffer.LINESEP,lineSeparator);
	} 

	
	private void readMarkers(Buffer buffer, InputStream _in)
		throws IOException
	{
		
		buffer.removeAllMarkers();

		BufferedReader in = new BufferedReader(new InputStreamReader(_in));

		String line;
		while((line = in.readLine()) != null)
		{
			
			if(!line.startsWith(""!""))
				continue;

			char shortcut = line.charAt(1);
			int start = line.indexOf(';');
			int end = line.indexOf(';',start + 1);
			int position = Integer.parseInt(line.substring(start + 1,end));
			buffer.addMarker(shortcut,position);
		}

		in.close();
	} 

	
	private void save()
	{
		OutputStream out = null;

		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.save"",args));

			
			setAbortable(true);

			try
			{
				path = vfs._canonPath(session,path,view);

				buffer.readLock();

				
				if(buffer.getProperty(Buffer.BACKED_UP) == null
					|| jEdit.getBooleanProperty(""backupEverySave""))
				{
					vfs._backup(session,path,view);
					buffer.setBooleanProperty(Buffer.BACKED_UP,true);
				}

				
				String savePath;

				boolean twoStageSave = (vfs.getCapabilities() & VFS.RENAME_CAP) != 0
					&& jEdit.getBooleanProperty(""twoStageSave"");
				if(twoStageSave)
					savePath = vfs.getTwoStageSaveName(path);
				else
					savePath = path;

				out = vfs._createOutputStream(session,savePath,view);
				if(out != null)
				{
					
					
					
					if(savePath.endsWith("".gz""))
						buffer.setBooleanProperty(Buffer.GZIPPED,true);

					if(buffer.getBooleanProperty(Buffer.GZIPPED))
						out = new GZIPOutputStream(out);

					write(buffer,out);

					if(twoStageSave)
					{
						if(!vfs._rename(session,savePath,path,view))
							throw new IOException(savePath);
					}

					
					
					if((vfs.getCapabilities() & VFS.DELETE_CAP) != 0)
					{
						if(jEdit.getBooleanProperty(""persistentMarkers"")
							&& buffer.getMarkers().size() != 0)
						{
							setStatus(jEdit.getProperty(""vfs.status.save-markers"",args));
							setProgressValue(0);
							out = vfs._createOutputStream(session,markersPath,view);
							if(out != null)
								writeMarkers(buffer,out);
						}
						else
							vfs._delete(session,markersPath,view);
					}
				}
				else
					buffer.setBooleanProperty(ERROR_OCCURRED,true);

				if(!twoStageSave)
					VFSManager.sendVFSUpdate(vfs,path,true);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.write-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			finally
			{
				buffer.readUnlock();
			}
		}
		catch(WorkThread.Abort a)
		{
			if(out != null)
			{
				try
				{
					out.close();
				}
				catch(IOException io)
				{
				}
			}

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._saveComplete(session,buffer,path,view);
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.write-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} 

	
	private void autosave()
	{
		OutputStream out = null;

		try
		{
			String[] args = { vfs.getFileName(path) };
			setStatus(jEdit.getProperty(""vfs.status.autosave"",args));

			
			setAbortable(true);

			try
			{
				

				if(!buffer.isDirty())
				{
					
					
					return;
				}

				out = vfs._createOutputStream(session,path,view);
				if(out == null)
					return;

				write(buffer,out);
			}
			catch(Exception e)
			{
			}
			finally
			{
				
			}
		}
		catch(WorkThread.Abort a)
		{
			if(out != null)
			{
				try
				{
					out.close();
				}
				catch(IOException io)
				{
				}
			}
		}
	} 

	
	private void write(Buffer buffer, OutputStream _out)
		throws IOException
	{
		BufferedWriter out = new BufferedWriter(
			new OutputStreamWriter(_out,
				buffer.getStringProperty(Buffer.ENCODING)),
				IOBUFSIZE);
		Segment lineSegment = new Segment();
		String newline = buffer.getStringProperty(Buffer.LINESEP);
		if(newline == null)
			newline = System.getProperty(""line.separator"");

		setProgressMaximum(buffer.getLineCount() / PROGRESS_INTERVAL);
		setProgressValue(0);

		int i = 0;
		while(i < buffer.getLineCount())
		{
			buffer.getLineText(i,lineSegment);
			out.write(lineSegment.array,lineSegment.offset,
				lineSegment.count);

			if(i != buffer.getLineCount() - 1)
			{
				out.write(newline);
			}

			if(++i % PROGRESS_INTERVAL == 0)
				setProgressValue(i / PROGRESS_INTERVAL);
		}

		if(jEdit.getBooleanProperty(""stripTrailingEOL"")
			&& buffer.getBooleanProperty(Buffer.TRAILING_EOL))
		{
			out.write(newline);
		}

		out.close();
	} 

	
	private void writeMarkers(Buffer buffer, OutputStream out)
		throws IOException
	{
		Writer o = new BufferedWriter(new OutputStreamWriter(out));
		Vector markers = buffer.getMarkers();
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			o.write('!');
			o.write(marker.getShortcut());
			o.write(';');

			String pos = String.valueOf(marker.getPosition());
			o.write(pos);
			o.write(';');
			o.write(pos);
			o.write('\n');
		}
		o.close();
	} 

	
	private void insert()
	{
		InputStream in = null;

		try
		{
			try
			{
				String[] args = { vfs.getFileName(path) };
				setStatus(jEdit.getProperty(""vfs.status.load"",args));
				setAbortable(true);

				path = vfs._canonPath(session,path,view);

				VFS.DirectoryEntry entry = vfs._getDirectoryEntry(
					session,path,view);
				long length;
				if(entry != null)
					length = entry.length;
				else
					length = 0L;

				in = vfs._createInputStream(session,path,false,view);
				if(in == null)
					return;

				if(path.endsWith("".gz""))
					in = new GZIPInputStream(in);

				read(buffer,in,length);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
		catch(WorkThread.Abort a)
		{
			if(in != null)
			{
				try
				{
					in.close();
				}
				catch(IOException io)
				{
				}
			}

			buffer.setBooleanProperty(ERROR_OCCURRED,true);
		}
		finally
		{
			try
			{
				vfs._endVFSSession(session,view);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,this,io);
				String[] pp = { io.toString() };
				VFSManager.error(view,path,""ioerror.read-error"",pp);

				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
			catch(WorkThread.Abort a)
			{
				buffer.setBooleanProperty(ERROR_OCCURRED,true);
			}
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.DirectoryMenu,4,8,0,13,39,4,3,13,4,0.666666667,237,1.0,0,0.996515679,0.666666667,0,0,58.0,19,5.25,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.io.File;
import org.gjt.sp.jedit.browser.*;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.jedit.*;


public class DirectoryMenu extends EnhancedMenu
{
	
	public DirectoryMenu(String name, String dir)
	{
		super(name);
		this.dir = dir;
	} 

	
	public void menuSelected(MenuEvent evt)
	{
		super.menuSelected(evt);

		final View view = GUIUtilities.getView(this);

		if(getMenuComponentCount() != 0)
			removeAll();

		final String path;
		if(dir == null)
		{
			path = view.getBuffer().getDirectory();
		}
		else
			path = dir;

		JMenuItem mi = new JMenuItem(path + "":"");
		mi.setActionCommand(path);
		mi.setIcon(FileCellRenderer.openDirIcon);

		
		ActionListener fileListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				jEdit.openFile(view,evt.getActionCommand());
			}
		};

		ActionListener dirListener = new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				VFSBrowser.browseDirectory(view,
					evt.getActionCommand());
			}
		}; 

		mi.addActionListener(dirListener);

		add(mi);
		addSeparator();

		if(dir == null && !(view.getBuffer().getVFS() instanceof FileVFS))
		{
			mi = new JMenuItem(jEdit.getProperty(
				""directory.not-local""));
			mi.setEnabled(false);
			add(mi);
			return;
		}

		File directory = new File(path);

		JMenu current = this;

		
		String backupPrefix = jEdit.getProperty(""backup.prefix"");
		String backupSuffix = jEdit.getProperty(""backup.suffix"");

		File[] list = directory.listFiles();
		if(list == null || list.length == 0)
		{
			mi = new JMenuItem(jEdit.getProperty(
				""directory.no-files""));
			mi.setEnabled(false);
			add(mi);
		}
		else
		{
			int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);

			MiscUtilities.quicksort(list,
				new MiscUtilities.StringICaseCompare());
			for(int i = 0; i < list.length; i++)
			{
				File file = list[i];

				String name = file.getName();

				
				if(name.endsWith("".marks""))
					continue;

				
				if(name.startsWith(""#"") && name.endsWith(""#""))
					continue;

				
				if((backupPrefix.length() != 0
					&& name.startsWith(backupPrefix))
					|| (backupSuffix.length() != 0
					&& name.endsWith(backupSuffix)))
					continue;

				
				
				

				mi = new JMenuItem(name);
				mi.setActionCommand(file.getPath());
				mi.addActionListener(file.isDirectory()
					? dirListener
					: fileListener);
				mi.setIcon(file.isDirectory()
					? FileCellRenderer.dirIcon
					: FileCellRenderer.fileIcon);

				if(current.getItemCount() >= maxItems && i != list.length - 1)
				{
					
					JMenu newCurrent = new JMenu(
						jEdit.getProperty(
						""common.more""));
					current.add(newCurrent);
					current = newCurrent;
				}
				current.add(mi);
			}
		}
	} 

	public void menuDeselected(MenuEvent e) {}

	public void menuCanceled(MenuEvent e) {}

	
	private String dir;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.ColorWellButton,3,6,0,8,14,3,6,3,3,2.0,46,0.0,0,0.997382199,0.833333333,0,0,14.33333333,1,0.6667,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.OperatingSystem;



public class ColorWellButton extends JButton
{
	
	public ColorWellButton(Color color)
	{
		setIcon(new ColorWell(color));
		setMargin(new Insets(2,2,2,2));
		addActionListener(new ActionHandler());

		
		if(OperatingSystem.isMacOSLF())
			putClientProperty(""JButton.buttonType"",""toolbar"");
	} 

	
	public Color getSelectedColor()
	{
		return ((ColorWell)getIcon()).color;
	} 

	
	public void setSelectedColor(Color color)
	{
		((ColorWell)getIcon()).color = color;
		repaint();
	} 

	
	static class ColorWell implements Icon
	{
		Color color;

		ColorWell(Color color)
		{
			this.color = color;
		}

		public int getIconWidth()
		{
			return 35;
		}

		public int getIconHeight()
		{
			return 10;
		}

		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			if(color == null)
				return;

			g.setColor(color);
			g.fillRect(x,y,getIconWidth(),getIconHeight());
			g.setColor(color.darker());
			g.drawRect(x,y,getIconWidth()-1,getIconHeight()-1);
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			JDialog parent = GUIUtilities.getParentDialog(ColorWellButton.this);
			JDialog dialog;
			if (parent != null)
			{
				dialog = new ColorPickerDialog(parent,
					jEdit.getProperty(""colorChooser.title""),
					true);
			}
			else
			{
				dialog = new ColorPickerDialog(
					JOptionPane.getFrameForComponent(
					ColorWellButton.this),
					jEdit.getProperty(""colorChooser.title""),
					true);
			}
			dialog.pack();
			dialog.show();
		}
	} 

	
	
	private class ColorPickerDialog extends EnhancedDialog implements ActionListener
	{
		public ColorPickerDialog(Frame parent, String title, boolean modal)
		{
			super(parent,title,modal);

			init();
		}

		public ColorPickerDialog(Dialog parent, String title, boolean modal)
		{
			super(parent,title,modal);

			getContentPane().setLayout(new BorderLayout());

			init();
		}

		public void ok()
		{
			Color c = chooser.getColor();
			if (c != null)
				setSelectedColor(c);
			setVisible(false);
		}

		public void cancel()
		{
			setVisible(false);
		}

		public void actionPerformed(ActionEvent evt)
		{
			if (evt.getSource() == ok)
				ok();
			else
				cancel();
		}

		
		private JColorChooser chooser;
		private JButton ok;
		private JButton cancel;

		private void init()
		{
			Color c = getSelectedColor();
			if(c == null)
				chooser = new JColorChooser();
			else
				chooser = new JColorChooser(c);

			getContentPane().add(BorderLayout.CENTER, chooser);

			Box buttons = new Box(BoxLayout.X_AXIS);
			buttons.add(Box.createGlue());

			ok = new JButton(jEdit.getProperty(""common.ok""));
			ok.addActionListener(this);
			buttons.add(ok);
			buttons.add(Box.createHorizontalStrut(6));
			getRootPane().setDefaultButton(ok);
			cancel = new JButton(jEdit.getProperty(""common.cancel""));
			cancel.addActionListener(this);
			buttons.add(cancel);
			buttons.add(Box.createGlue());

			getContentPane().add(BorderLayout.SOUTH, buttons);
			pack();
			setLocationRelativeTo(getParent());
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.pluginmgr.PluginList,5,1,0,12,27,0,5,8,0,0.5,158,0.0,0,0.0,0.466666667,0,0,30.0,5,1.8,0,"

package org.gjt.sp.jedit.pluginmgr;

import com.microstar.xml.*;
import java.io.*;
import java.net.URL;
import java.util.Hashtable;
import java.util.Vector;
import java.util.zip.GZIPInputStream;
import org.gjt.sp.util.Log;
import org.gjt.sp.jedit.*;


class PluginList
{
	Vector plugins;
	Hashtable pluginHash;
	Vector pluginSets;

	PluginList() throws Exception
	{
		plugins = new Vector();
		pluginHash = new Hashtable();
		pluginSets = new Vector();

		String path = jEdit.getProperty(""plugin-manager.url"");
		PluginListHandler handler = new PluginListHandler(this,path);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);

		parser.parse(null,null,new BufferedReader(new InputStreamReader(
			new GZIPInputStream(new URL(path).openStream()),""UTF8"")));
	}

	void addPlugin(Plugin plugin)
	{
		plugin.checkIfInstalled();
		plugins.addElement(plugin);
		pluginHash.put(plugin.name,plugin);
	}

	void addPluginSet(PluginSet set)
	{
		pluginSets.addElement(set);
	}

	void finished()
	{
		
		
		for(int i = 0; i < plugins.size(); i++)
		{
			Plugin plugin = (Plugin)plugins.elementAt(i);
			for(int j = 0; j < plugin.branches.size(); j++)
			{
				Branch branch = (Branch)plugin.branches.elementAt(j);
				for(int k = 0; k < branch.deps.size(); k++)
				{
					Dependency dep = (Dependency)branch.deps.elementAt(k);
					if(dep.what.equals(""plugin""))
						dep.plugin = (Plugin)pluginHash.get(dep.pluginName);
				}
			}
		}
	}

	void dump()
	{
		for(int i = 0; i < plugins.size(); i++)
		{
			System.err.println((Plugin)plugins.elementAt(i));
			System.err.println();
		}
	}

	static class PluginSet
	{
		String name;
		String description;
		Vector plugins = new Vector();

		public String toString()
		{
			return plugins.toString();
		}
	}

	static class Plugin
	{
		String jar;
		String name;
		String description;
		String author;
		Vector branches = new Vector();
		String installed;
		String installedVersion;

		void checkIfInstalled()
		{
			
			
			EditPlugin.JAR[] jars = jEdit.getPluginJARs();
			for(int i = 0; i < jars.length; i++)
			{
				String path = jars[i].getPath();
				if(!new File(path).exists())
					continue;

				if(MiscUtilities.getFileName(path).equals(jar))
				{
					installed = path;

					EditPlugin[] plugins = jars[i].getPlugins();
					if(plugins.length >= 1)
					{
						installedVersion = jEdit.getProperty(
							""plugin."" + plugins[0].getClassName()
							+ "".version"");
					}
					break;
				}
			}

			String[] notLoaded = jEdit.getNotLoadedPluginJARs();
			for(int i = 0; i < notLoaded.length; i++)
			{
				String path = notLoaded[i];

				if(MiscUtilities.getFileName(path).equals(jar))
				{
					installed = path;
					break;
				}
			}
		}

		
		Branch getCompatibleBranch()
		{
			for(int i = 0; i < branches.size(); i++)
			{
				Branch branch = (Branch)branches.elementAt(i);
				if(branch.canSatisfyDependencies())
					return branch;
			}

			return null;
		}

		boolean canBeInstalled()
		{
			Branch branch = getCompatibleBranch();
			return branch != null && !branch.obsolete
				&& branch.canSatisfyDependencies();
		}

		void install(Roster roster, String installDirectory, boolean downloadSource)
		{
			if(installed != null)
				roster.addOperation(new Roster.Remove(installed));

			Branch branch = getCompatibleBranch();
			if(branch.obsolete)
				return;

			branch.satisfyDependencies(roster,installDirectory,
				downloadSource);

			if(installed != null)
			{
				installDirectory = MiscUtilities.getParentOfPath(
					installed);
			}

			roster.addOperation(new Roster.Install(
				(downloadSource ? branch.downloadSource : branch.download),
				installDirectory,
				(downloadSource ? branch.downloadSourceSize : branch.downloadSize)));

		}

		public String toString()
		{
			return name;
		}
	}

	static class Branch
	{
		String version;
		String date;
		int downloadSize;
		String download;
		int downloadSourceSize;
		String downloadSource;
		boolean obsolete;
		Vector deps = new Vector();

		boolean canSatisfyDependencies()
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = (Dependency)deps.elementAt(i);
				if(!dep.canSatisfy())
					return false;
			}

			return true;
		}

		void satisfyDependencies(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			for(int i = 0; i < deps.size(); i++)
			{
				Dependency dep = (Dependency)deps.elementAt(i);
				dep.satisfy(roster,installDirectory,downloadSource);
			}
		}

		public String toString()
		{
			return ""[version="" + version + "",download="" + download
				+ "",obsolete="" + obsolete + "",deps="" + deps + ""]"";
		}
	}

	static class Dependency
	{
		String what;
		String from;
		String to;
		
		String pluginName;
		Plugin plugin;

		Dependency(String what, String from, String to, String pluginName)
		{
			this.what = what;
			this.from = from;
			this.to = to;
			this.pluginName = pluginName;
		}

		boolean isSatisfied()
		{
			if(what.equals(""plugin""))
			{
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					if(plugin.installedVersion != null
						&&
					(from == null || MiscUtilities.compareStrings(
						plugin.installedVersion,from,false) >= 0)
						&&
					   (to == null || MiscUtilities.compareStrings(
					   	plugin.installedVersion,to,false) <= 0))
					{
						return true;
					}
				}

				return false;
			}
			else if(what.equals(""jdk""))
			{
				String javaVersion = System.getProperty(""java.version"").substring(0,3);

				if((from == null || MiscUtilities.compareStrings(
					javaVersion,from,false) >= 0)
					&&
				   (to == null || MiscUtilities.compareStrings(
				   	javaVersion,to,false) <= 0))
					return true;
				else
					return false;
			}
			else if(what.equals(""jedit""))
			{
				String build = jEdit.getBuild();

				if((from == null || MiscUtilities.compareStrings(
					build,from,false) >= 0)
					&&
				   (to == null || MiscUtilities.compareStrings(
				   	build,to,false) <= 0))
					return true;
				else
					return false;
			}
			else
			{
				Log.log(Log.ERROR,this,""Invalid dependency: "" + what);
				return false;
			}
		}

		boolean canSatisfy()
		{
			if(isSatisfied())
				return true;
			else if(what.equals(""plugin""))
			{
				return plugin.canBeInstalled();
			}
			else
				return false;
		}

		void satisfy(Roster roster, String installDirectory,
			boolean downloadSource)
		{
			if(what.equals(""plugin""))
			{
				for(int i = 0; i < plugin.branches.size(); i++)
				{
					Branch branch = (Branch)plugin.branches
						.elementAt(i);
					if((plugin.installedVersion == null
						||
					MiscUtilities.compareStrings(
						plugin.installedVersion,branch.version,false) < 0)
						&&
					(from == null || MiscUtilities.compareStrings(
						branch.version,from,false) >= 0)
						&&
					   (to == null || MiscUtilities.compareStrings(
					   	branch.version,to,false) <= 0))
					{
						plugin.install(roster,installDirectory,
							downloadSource);
						return;
					}
				}
			}
		}

		public String toString()
		{
			return ""[what="" + what + "",from="" + from
				+ "",to="" + to + "",plugin="" + plugin + ""]"";
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.AbbrevEditor,8,5,0,5,33,0,4,1,8,0.571428571,419,1.0,0,0.989393939,0.625,0,0,51.0,12,3.375,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public class AbbrevEditor extends JPanel
{
	
	public AbbrevEditor()
	{
		GridBagLayout layout = new GridBagLayout();
		setLayout(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.anchor = cons.WEST;
		cons.fill = cons.BOTH;
		cons.weightx = 0.0f;
		cons.gridx = 1;
		cons.gridy = 1;

		JLabel label = new JLabel(jEdit.getProperty(""abbrev-editor.abbrev""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		layout.setConstraints(label,cons);
		add(label);
		cons.gridx++;
		cons.weightx = 1.0f;
		abbrev = new JTextField();
		layout.setConstraints(abbrev,cons);
		add(abbrev);

		cons.gridx = 1;
		cons.weightx = 0.0f;
		cons.gridwidth = 2;

		cons.gridy++;
		label = new JLabel(jEdit.getProperty(""abbrev-editor.before""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);

		cons.gridy++;
		cons.weighty = 1.0f;
		beforeCaret = new JTextArea(4,40);
		JScrollPane scroller = new JScrollPane(beforeCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);

		cons.gridy++;
		cons.weighty = 0.0f;
		label = new JLabel(jEdit.getProperty(""abbrev-editor.after""));
		label.setBorder(new EmptyBorder(6,0,3,0));
		layout.setConstraints(label,cons);
		add(label);

		cons.gridy++;
		cons.weighty = 1.0f;
		afterCaret = new JTextArea(4,40);
		scroller = new JScrollPane(afterCaret);
		layout.setConstraints(scroller,cons);
		add(scroller);
	} 

	
	public String getAbbrev()
	{
		return abbrev.getText();
	} 

	
	public void setAbbrev(String abbrev)
	{
		this.abbrev.setText(abbrev);
	} 

	
	public String getExpansion()
	{
		StringBuffer buf = new StringBuffer();

		String beforeCaretText = beforeCaret.getText();
		String afterCaretText = afterCaret.getText();

		for(int i = 0; i < beforeCaretText.length(); i++)
		{
			char ch = beforeCaretText.charAt(i);
			switch(ch)
			{
			case '\n':
				buf.append(""\\n"");
				break;
			case '\t':
				buf.append(""\\t"");
				break;
			case '\\':
				buf.append(""\\\\"");
				break;
			default:
				buf.append(ch);
				break;
			}
		}

		if(afterCaretText.length() != 0)
		{
			buf.append(""\\|"");

			for(int i = 0; i < afterCaretText.length(); i++)
			{
				char ch = afterCaretText.charAt(i);
				switch(ch)
				{
				case '\n':
					buf.append(""\\n"");
					break;
				case '\t':
					buf.append(""\\t"");
					break;
				case '\\':
					buf.append(""\\\\"");
					break;
				default:
					buf.append(ch);
					break;
				}
			}
		}

		return buf.toString();
	} 

	
	public void setExpansion(String expansion)
	{
		if(expansion == null)
		{
			beforeCaret.setText(null);
			afterCaret.setText(null);
			return;
		}

		String beforeCaretText = null;
		String afterCaretText = null;
		StringBuffer buf = new StringBuffer();

		for(int i = 0; i < expansion.length(); i++)
		{
			char ch = expansion.charAt(i);

			if(ch == '\\' && i != expansion.length() - 1)
			{
				ch = expansion.charAt(++i);
				switch(ch)
				{
				case 't':
					buf.append('\t');
					break;
				case 'n':
					buf.append('\n');
					break;
				case '|':
					beforeCaretText = buf.toString();
					buf.setLength(0);
					break;
				default:
					buf.append(ch);
					break;
				}
			}
			else
				buf.append(ch);
		}

		if(beforeCaretText == null)
			beforeCaretText = buf.toString();
		else
			afterCaretText = buf.toString();

		beforeCaret.setText(beforeCaretText);
		afterCaret.setText(afterCaretText);
	} 

	
	public JTextField getAbbrevField()
	{
		return abbrev;
	} 

	
	public JTextArea getBeforeCaretTextArea()
	{
		return beforeCaret;
	} 

	
	public JTextArea getAfterCaretTextArea()
	{
		return afterCaret;
	} 

	
	private JTextField abbrev;
	private JTextArea beforeCaret, afterCaret;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.EnhancedButton,3,7,0,5,10,1,2,4,2,0.5,40,1.0,1,0.99739922,0.4,1,1,12.0,1,0.6667,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.EditAction;
import org.gjt.sp.jedit.GUIUtilities;


public class EnhancedButton extends RolloverButton
{
	
	public EnhancedButton(Icon icon, String toolTip, EditAction action)
	{
		super(icon);

		this.action = action;

		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(action));
			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);

		setToolTipText(toolTip);
	} 

	
	public boolean isFocusTraversable()
	{
		return false;
	} 

	
	private EditAction action;
	

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseEntered(MouseEvent evt)
		{
			String msg = action.getMouseOverText();
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
			}
		}

		public void mouseExited(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.print.BufferPrinter1_4,7,1,0,7,52,1,0,7,4,0.714285714,343,0.285714286,0,0.0,0.2,0,0,47.0,11,3.5714,0,"

package org.gjt.sp.jedit.print;


import javax.print.attribute.*;
import javax.print.attribute.standard.*;
import java.awt.print.*;
import java.awt.*;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import org.gjt.sp.jedit.io.VFSManager;


public class BufferPrinter1_4
{
	
	private static PrinterJob getPrintJob(String jobName)
	{
		job = PrinterJob.getPrinterJob();

		format = new HashPrintRequestAttributeSet();

		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			String printSpecPath = MiscUtilities.constructPath(
				settings, ""printspec"");
			File filePrintSpec = new File(printSpecPath);

			if (filePrintSpec.exists())
			{
				try
				{
					FileInputStream fileIn = new FileInputStream(filePrintSpec);
					ObjectInputStream obIn = new ObjectInputStream(fileIn);
					format = (HashPrintRequestAttributeSet)obIn.readObject();
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,BufferPrinter1_4.class,e);
				}
				
				if(jEdit.getBooleanProperty(""print.color""))
					format.add(Chromaticity.COLOR);
				else
					format.add(Chromaticity.MONOCHROME);

				
				format.add(new JobName(jobName, null));
			}
		}

		return job;
	} 

	
	public static void pageSetup(View view)
	{
		PrinterJob prnJob = getPrintJob(""PageSetupOnly"");
		if(prnJob.pageDialog(format)!=null)
			savePrintSpec();
	} 

	
	public static void print(final View view, final Buffer buffer, boolean selection)
	{
		job = getPrintJob(buffer.getPath());

		boolean header = jEdit.getBooleanProperty(""print.header"");
		boolean footer = jEdit.getBooleanProperty(""print.footer"");
		boolean lineNumbers = jEdit.getBooleanProperty(""print.lineNumbers"");
		boolean color = jEdit.getBooleanProperty(""print.color"");
		Font font = jEdit.getFontProperty(""print.font"");

		BufferPrintable printable = new BufferPrintable(job,format,view,
			buffer,font,header,footer,lineNumbers,color);
		job.setPrintable(printable);

		if(!job.printDialog(format))
			return;

		savePrintSpec();

		VFSManager.runInWorkThread(printable);
	} 

	
	public static PageFormat getPageFormat()
	{
		
		PrinterJob prnJob=getPrintJob("" "");
		PageFormat pf=prnJob.defaultPage();
		Paper pap=pf.getPaper();

		MediaSizeName media=(MediaSizeName)format.get(
		                            Media.class);
		MediaSize ms=MediaSize.getMediaSizeForName(media);

		MediaPrintableArea mediaarea=(MediaPrintableArea)format.get(
		                                     MediaPrintableArea.class);
		if(mediaarea!=null)
			pap.setImageableArea((double)(mediaarea.getX(MediaPrintableArea.INCH)*72),
			                     (double)(mediaarea.getY(MediaPrintableArea.INCH)*72),
			                     (double)(mediaarea.getWidth(MediaPrintableArea.INCH)*72),
			                     (double)(mediaarea.getHeight(MediaPrintableArea.INCH)*72));
		if(ms!=null)
			pap.setSize((double)(ms.getX(MediaSize.INCH)*72),
			            (double)(ms.getY(MediaSize.INCH)*72));
		pf.setPaper(pap);

		OrientationRequested orientation=(OrientationRequested)format.get(
		                                         OrientationRequested.class);
		if(orientation!=null)
		{
			if(orientation.getValue()==OrientationRequested.LANDSCAPE.getValue())
			{
				pf.setOrientation(PageFormat.LANDSCAPE);
			}
			else if(orientation.getValue()==OrientationRequested.REVERSE_LANDSCAPE.getValue())
			{
				pf.setOrientation(PageFormat.REVERSE_LANDSCAPE);
			}
			else if(orientation.getValue()==OrientationRequested.PORTRAIT.getValue())
			{
				pf.setOrientation(PageFormat.PORTRAIT);
			}
			else if(orientation.getValue()==OrientationRequested.REVERSE_PORTRAIT.getValue())
			{
				
				
				
				pf.setOrientation(PageFormat.PORTRAIT);
			}
		}
		return pf;
	} 

	
	private static void savePrintSpec()
	{
		String settings = jEdit.getSettingsDirectory();
		if(settings == null)
			return;

		String printSpecPath = MiscUtilities.constructPath(
			settings, ""printspec"");
		File filePrintSpec = new File(printSpecPath);

		try
		{
			FileOutputStream fileOut=new FileOutputStream(filePrintSpec);
			ObjectOutputStream obOut=new ObjectOutputStream(fileOut);
			obOut.writeObject(format);
			
			Chromaticity cc=(Chromaticity)format.get(Chromaticity.class);
			if (cc!=null)
				jEdit.setBooleanProperty(""print.color"",
					cc.getValue()==Chromaticity.COLOR.getValue());
		}
		catch(Exception e)
		{
			e.printStackTrace();
		}
	}
	

	
	private static PrintRequestAttributeSet format;
	private static PrinterJob job;
	
}

"
jEdit,4.1,org.gjt.sp.jedit.options.ToolBarOptionPane,13,6,0,11,68,42,3,10,1,0.796296296,512,1.0,5,0.982378855,0.5,3,5,37.69230769,9,2.1538,1,"

package org.gjt.sp.jedit.options;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.net.*;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;




public class ToolBarOptionPane extends AbstractOptionPane
{
	
	public ToolBarOptionPane()
	{
		super(""toolbar"");
	} 

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		JPanel panel = new JPanel(new GridLayout(2,1));

		
		showToolbar = new JCheckBox(jEdit.getProperty(
			""options.toolbar.showToolbar""));
		showToolbar.setSelected(jEdit.getBooleanProperty(""view.showToolbar""));
		panel.add(showToolbar);

		panel.add(new JLabel(jEdit.getProperty(
			""options.toolbar.caption"")));

		add(BorderLayout.NORTH,panel);

		String toolbar = jEdit.getProperty(""view.toolbar"");
		StringTokenizer st = new StringTokenizer(toolbar);
		listModel = new DefaultListModel();
		while(st.hasMoreTokens())
		{
			String actionName = (String)st.nextToken();
			if(actionName.equals(""-""))
				listModel.addElement(new ToolBarOptionPane.Button(""-"",null,null,""-""));
			else
			{
				EditAction action = jEdit.getAction(actionName);
				if(action == null)
					continue;
				String label = action.getLabel();
				if(label == null)
					continue;

				Icon icon;
				String iconName;
				if(actionName.equals(""-""))
				{
					iconName = null;
					icon = null;
				}
				else
				{
					iconName = jEdit.getProperty(actionName + "".icon"");
					if(iconName == null)
						icon = GUIUtilities.loadIcon(""BrokenImage.png"");
					else
					{
						icon = GUIUtilities.loadIcon(iconName);
						if(icon == null)
							icon = GUIUtilities.loadIcon(""BrokenImage.png"");
					}
				}
				listModel.addElement(new Button(actionName,iconName,icon,label));
			}
		}

		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());
		list.setCellRenderer(new ButtonCellRenderer());

		add(BorderLayout.CENTER,new JScrollPane(list));

		
		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		ActionHandler actionHandler = new ActionHandler();
		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""options.toolbar.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""options.toolbar.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new RolloverButton(GUIUtilities.loadIcon(""ArrowU.png""));
		moveUp.setToolTipText(jEdit.getProperty(""options.toolbar.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new RolloverButton(GUIUtilities.loadIcon(""ArrowD.png""));
		moveDown.setToolTipText(jEdit.getProperty(""options.toolbar.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createHorizontalStrut(6));
		edit = new RolloverButton(GUIUtilities.loadIcon(""ButtonProperties.png""));
		edit.setToolTipText(jEdit.getProperty(""options.toolbar.edit""));
		edit.addActionListener(actionHandler);
		buttons.add(edit);
		buttons.add(Box.createGlue());
		

		updateButtons();
		add(BorderLayout.SOUTH,buttons);

		
		iconList = new DefaultComboBoxModel();
		st = new StringTokenizer(jEdit.getProperty(""icons""));
		while(st.hasMoreElements())
		{
			String icon = st.nextToken();
			iconList.addElement(new IconListEntry(
				GUIUtilities.loadIcon(icon),icon));
		} 
	} 

	
	protected void _save()
	{
		jEdit.setBooleanProperty(""view.showToolbar"",showToolbar
			.isSelected());

		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');
			Button button = (Button)listModel.elementAt(i);
			buf.append(button.actionName);
			jEdit.setProperty(button.actionName + "".icon"",button.iconName);
		}
		jEdit.setProperty(""view.toolbar"",buf.toString());
	} 

	

	
	private JCheckBox showToolbar;
	private DefaultListModel listModel;
	private JList list;
	private RolloverButton add;
	private RolloverButton remove;
	private RolloverButton moveUp, moveDown;
	private RolloverButton edit;

	private DefaultComboBoxModel iconList;
	

	
	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
		edit.setEnabled(index != -1);
	} 

	

	

	
	static class ButtonCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return MiscUtilities.compareStrings(
				((Button)obj1).label,
				((Button)obj2).label,
				true);
		}
	} 

	
	static class Button
	{
		String actionName;
		String iconName;
		Icon icon;
		String label;

		Button(String actionName, String iconName, Icon icon, String label)
		{
			this.actionName = actionName;
			this.iconName = iconName;
			this.icon = icon;
			this.label = GUIUtilities.prettifyMenuLabel(label);
		}

		public String toString()
		{
			return label;
		}

		public boolean equals(Object o)
		{
			if(o instanceof Button)
				return ((Button)o).actionName.equals(actionName);
			else
				return false;
		}
	} 

	
	static class IconListEntry
	{
		Icon icon;
		String name;

		IconListEntry(Icon icon, String name)
		{
			this.icon = icon;
			this.name = name;
		}

		public String toString()
		{
			return name;
		}
	} 

	
	static class ButtonCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			Button button = (Button)value;
			setIcon(button.icon);

			return this;
		}
	} 

	
	static class IconCellRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list,
			Object value, int index, boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			IconListEntry icon = (IconListEntry)value;
			setIcon(icon.icon);

			return this;
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == add)
			{
				ToolBarEditDialog dialog = new ToolBarEditDialog(
					ToolBarOptionPane.this,iconList,null);
				Button selection = dialog.getSelection();
				if(selection == null)
					return;

				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;

				listModel.insertElementAt(selection,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
				list.ensureIndexIsVisible(index-1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
				list.ensureIndexIsVisible(index+1);
			}
			else if(source == edit)
			{
				ToolBarEditDialog dialog = new ToolBarEditDialog(
					ToolBarOptionPane.this,iconList,
					(Button)list.getSelectedValue());
				Button selection = dialog.getSelection();
				if(selection == null)
					return;

				int index = list.getSelectedIndex();

				listModel.setElementAt(selection,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	} 

	
} 


class ToolBarEditDialog extends EnhancedDialog
{
	
	public ToolBarEditDialog(Component comp,
		DefaultComboBoxModel iconListModel,
		ToolBarOptionPane.Button current)
	{
		super(GUIUtilities.getParentDialog(comp),
			jEdit.getProperty(""options.toolbar.edit.title""),
			true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();

		JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));
		typePanel.setBorder(new EmptyBorder(0,0,6,0));
		typePanel.add(new JLabel(
			jEdit.getProperty(""options.toolbar.edit.caption"")));

		separator = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".edit.separator""));
		separator.addActionListener(actionHandler);
		grp.add(separator);
		typePanel.add(separator);

		action = new JRadioButton(jEdit.getProperty(""options.toolbar""
			+ "".edit.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		typePanel.add(action);

		content.add(BorderLayout.NORTH,typePanel);

		JPanel actionPanel = new JPanel(new BorderLayout(6,6));

		ActionSet[] actionsList = jEdit.getActionSets();
		Vector vec = new Vector(actionsList.length);
		for(int i = 0; i < actionsList.length; i++)
		{
			ActionSet actionSet = actionsList[i];
			if(actionSet.getActionCount() != 0)
				vec.addElement(actionSet);
		}
		combo = new JComboBox(vec);
		combo.addActionListener(actionHandler);
		actionPanel.add(BorderLayout.NORTH,combo);

		list = new JList();
		list.setVisibleRowCount(8);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));

		
		JPanel iconPanel = new JPanel(new BorderLayout(0,3));
		JPanel labelPanel = new JPanel(new GridLayout(2,1));
		labelPanel.setBorder(new EmptyBorder(0,0,0,12));
		JPanel compPanel = new JPanel(new GridLayout(2,1));
		grp = new ButtonGroup();
		labelPanel.add(builtin = new JRadioButton(jEdit.getProperty(
			""options.toolbar.edit.builtin"")));
		builtin.addActionListener(actionHandler);
		grp.add(builtin);
		labelPanel.add(file = new JRadioButton(jEdit.getProperty(
			""options.toolbar.edit.file"")));
		grp.add(file);
		file.addActionListener(actionHandler);
		iconPanel.add(BorderLayout.WEST,labelPanel);
		builtinCombo = new JComboBox(iconListModel);
		builtinCombo.setRenderer(new ToolBarOptionPane.IconCellRenderer());
		compPanel.add(builtinCombo);

		fileButton = new JButton(jEdit.getProperty(""options.toolbar.edit.no-icon""));
		fileButton.setMargin(new Insets(1,1,1,1));
		fileButton.setIcon(GUIUtilities.loadIcon(""Blank24.gif""));
		fileButton.setHorizontalAlignment(SwingConstants.LEFT);
		fileButton.addActionListener(actionHandler);
		compPanel.add(fileButton);
		iconPanel.add(BorderLayout.CENTER,compPanel);
		actionPanel.add(BorderLayout.SOUTH,iconPanel);

		content.add(BorderLayout.CENTER,actionPanel);

		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,southPanel);

		if(current == null)
		{
			action.setSelected(true);
			builtin.setSelected(true);
			updateList();
		}
		else
		{
			if(current.actionName.equals(""-""))
			{
				separator.setSelected(true);
				builtin.setSelected(true);
			}
			else
			{
				action.setSelected(true);
				ActionSet set = jEdit.getActionSetForAction(
					jEdit.getAction(current.actionName));
				combo.setSelectedItem(set);
				updateList();
				list.setSelectedValue(current,true);

				if(MiscUtilities.isURL(current.iconName))
				{
					file.setSelected(true);
					fileIcon = current.iconName;
					try
					{
						fileButton.setIcon(new ImageIcon(new URL(
							fileIcon)));
					}
					catch(MalformedURLException mf)
					{
						Log.log(Log.ERROR,this,mf);
					}
					fileButton.setText(MiscUtilities.getFileName(fileIcon));
				}
				else
				{
					String iconName = MiscUtilities.getFileName(current.iconName);
					builtin.setSelected(true);
					ListModel model = builtinCombo.getModel();
					for(int i = 0; i < model.getSize(); i++)
					{
						ToolBarOptionPane.IconListEntry entry
							= (ToolBarOptionPane.IconListEntry)
							model.getElementAt(i);
						if(entry.name.equals(iconName))
						{
							builtinCombo.setSelectedIndex(i);
							break;
						}
					}
				}
			}
		}

		updateEnabled();

		pack();
		setLocationRelativeTo(GUIUtilities.getParentDialog(comp));
		show();
	} 

	
	public void ok()
	{
		isOK = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public ToolBarOptionPane.Button getSelection()
	{
		if(!isOK)
			return null;

		if(separator.isSelected())
			return new ToolBarOptionPane.Button(""-"",null,null,""-"");
		else
		{
			Icon icon;
			String iconName;
			if(builtin.isSelected())
			{
				ToolBarOptionPane.IconListEntry selectedIcon =
					(ToolBarOptionPane.IconListEntry)
					builtinCombo.getSelectedItem();
				icon = selectedIcon.icon;
				iconName = selectedIcon.name;
			}
			else
			{
				icon = fileButton.getIcon();
				iconName = fileIcon;
				if(iconName == null)
					iconName = ""Blank24.gif"";
			}

			String label;
			String actionName;
			if(action.isSelected())
			{
				ToolBarOptionPane.Button button =
					(ToolBarOptionPane.Button)list
					.getSelectedValue();
				label = button.label;
				actionName = button.actionName;
			}
			else
				throw new InternalError();

			return new ToolBarOptionPane.Button(actionName,
				iconName,icon,label);
		}
	} 

	

	
	private boolean isOK;
	private JRadioButton separator, action;
	private JComboBox combo;
	private JList list;
	private JRadioButton builtin;
	private JComboBox builtinCombo;
	private JRadioButton file;
	private JButton fileButton;
	private String fileIcon;
	private JButton ok, cancel;
	

	
	private void updateEnabled()
	{
		combo.setEnabled(action.isSelected());
		list.setEnabled(action.isSelected());

		boolean iconControlsEnabled = !separator.isSelected();
		builtin.setEnabled(iconControlsEnabled);
		file.setEnabled(iconControlsEnabled);
		builtinCombo.setEnabled(iconControlsEnabled && builtin.isSelected());
		fileButton.setEnabled(iconControlsEnabled && file.isSelected());
	} 

	
	private void updateList()
	{
		ActionSet actionSet = (ActionSet)combo.getSelectedItem();
		EditAction[] actions = actionSet.getActions();
		Vector listModel = new Vector(actions.length);

		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			String label = action.getLabel();
			if(label == null)
				continue;

			listModel.addElement(new ToolBarOptionPane.Button(
				action.getName(),null,null,label));
		}

		MiscUtilities.quicksort(listModel,new ToolBarOptionPane.ButtonCompare());
		list.setListData(listModel);
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
				updateEnabled();
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == combo)
				updateList();
			else if(source == fileButton)
			{
				String directory;
				if(fileIcon == null)
					directory = null;
				else
					directory = MiscUtilities.getParentOfPath(fileIcon);
				String paths[] = GUIUtilities.showVFSFileDialog(null,directory,
					VFSBrowser.OPEN_DIALOG,false);
				if(paths == null)
					return;

				fileIcon = ""file:"" + paths[0];

				try
				{
					fileButton.setIcon(new ImageIcon(new URL(
						fileIcon)));
				}
				catch(MalformedURLException mf)
				{
					Log.log(Log.ERROR,this,mf);
				}
				fileButton.setText(MiscUtilities.getFileName(fileIcon));
			}
		}
	} 
} 
"
jEdit,4.1,org.gjt.sp.jedit.ActionListHandler,11,2,0,6,28,31,1,5,7,0.8,223,1.0,1,0.565217391,0.333333333,1,3,18.54545455,8,2.2727,0,"

package org.gjt.sp.jedit;


import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;


class ActionListHandler extends HandlerBase
{
	
	ActionListHandler(String path, ActionSet actionSet)
	{
		this.path = path;
		this.actionSet = actionSet;
		stateStack = new Stack();
	} 

	
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""actions.dtd"".equals(systemId))
		{
			
			
			
			return new StringReader(""<!-- -->"");

			
		}

		return null;
	} 

	
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();

		if(aname == ""NAME"")
			actionName = value;
		else if(aname == ""NO_REPEAT"")
			noRepeat = (value == ""TRUE"");
		else if(aname == ""NO_RECORD"")
			noRecord = (value == ""TRUE"");
	} 

	
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""ACTIONS"".equals(name))
			return;

		Log.log(Log.ERROR,this,path + "": DOCTYPE must be ACTIONS"");
	} 

	
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);

		if (tag == ""CODE"")
		{
			code = text;
		}
		else if (tag == ""IS_SELECTED"")
		{
			isSelected = text;
		}
	} 

	
	public void startElement(String tag)
	{
		tag = pushElement(tag);

		if (tag == ""ACTION"")
		{
			code = null;
			isSelected = null;
		}
	} 

	
	public void endElement(String name)
	{
		if(name == null)
			return;

		String tag = peekElement();

		if(name.equals(tag))
		{
			if(tag == ""ACTION"")
			{
				actionSet.addAction(new BeanShellAction(actionName,
					code,isSelected,noRepeat,noRecord));
				noRepeat = noRecord = false;
			}

			popElement();
		}
		else
		{
			
			throw new InternalError();
		}
	} 

	
	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	} 

	

	
	private String path;
	private ActionSet actionSet;

	private String actionName;
	private String code;
	private String isSelected;

	private boolean noRepeat;
	private boolean noRecord;

	private Stack stateStack;
	

	
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();

		stateStack.push(name);

		return name;
	} 

	
	private String peekElement()
	{
		return (String) stateStack.peek();
	} 

	
	private String popElement()
	{
		return (String) stateStack.pop();
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.MarkersMenu,4,8,0,8,28,6,2,8,4,2.0,129,0.0,0,0.996515679,0.875,0,0,31.25,8,2.5,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;


public class MarkersMenu extends EnhancedMenu
{
	
	public MarkersMenu()
	{
		super(""markers"");
	} 

	
	public void menuSelected(MenuEvent evt)
	{
		super.menuSelected(evt);
		final View view = GUIUtilities.getView(this);

		if(getMenuComponentCount() != 0)
		{
			for(int i = getMenuComponentCount() - 1;
				i >= 0;
				i--)
			{
				Component comp = getMenuComponent(i);
				if(comp instanceof JSeparator)
					break;
				else
					remove(comp);
			}
		}

		Buffer buffer = view.getBuffer();

		Vector markers = buffer.getMarkers();

		if(markers.size() == 0)
		{
			JMenuItem mi = new JMenuItem(jEdit.getProperty(
				""no-markers.label""));
			mi.setEnabled(false);
			add(mi);
			return;
		}

		int maxItems = jEdit.getIntegerProperty(""menu.spillover"",20);

		JMenu current = this;

		for(int i = 0; i < markers.size(); i++)
		{
			final Marker marker = (Marker)markers.elementAt(i);
			int lineNo = buffer.getLineOfOffset(marker.getPosition());

			if(current.getItemCount() >= maxItems && i != markers.size() - 1)
			{
				
				JMenu newCurrent = new JMenu(
					jEdit.getProperty(
					""common.more""));
				current.add(newCurrent);
				current = newCurrent;
			}

			JMenuItem mi = new MarkersMenuItem(buffer,
				lineNo,marker.getShortcut());
			mi.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					view.getTextArea().setCaretPosition(
						marker.getPosition());
				}
			});
			current.add(mi);
		}
	} 

	public void menuDeselected(MenuEvent e) {}

	public void menuCanceled(MenuEvent e) {}

	
	static class MarkersMenuItem extends JMenuItem
	{
		
		MarkersMenuItem(Buffer buffer, int lineNo, char shortcut)
		{
			String text = buffer.getLineText(lineNo).trim();
			if(text.length() == 0)
				text = jEdit.getProperty(""markers.blank-line"");
			setText((lineNo + 1) + "": "" + text);

			shortcutProp = ""goto-marker.shortcut"";
			MarkersMenuItem.this.shortcut = shortcut;
		} 

		
		public Dimension getPreferredSize()
		{
			Dimension d = super.getPreferredSize();

			String shortcut = getShortcut();

			if(shortcut != null)
			{
				d.width += (getFontMetrics(acceleratorFont)
					.stringWidth(shortcut) + 15);
			}
			return d;
		} 

		
		public void paint(Graphics g)
		{
			super.paint(g);

			String shortcut = getShortcut();

			if(shortcut != null)
			{
				g.setFont(acceleratorFont);
				g.setColor(getModel().isArmed() ?
					acceleratorSelectionForeground :
					acceleratorForeground);
				FontMetrics fm = g.getFontMetrics();
				Insets insets = getInsets();
				g.drawString(shortcut,getWidth() - (fm.stringWidth(
					shortcut) + insets.right + insets.left + 5),
					getFont().getSize() + (insets.top - 1)
					);
			}
		} 

		
		private String shortcutProp;
		private char shortcut;
		private static Font acceleratorFont;
		private static Color acceleratorForeground;
		private static Color acceleratorSelectionForeground;

		
		private String getShortcut()
		{
			if(shortcut == '\0')
				return null;
			else
			{
				String shortcutPrefix = jEdit.getProperty(shortcutProp);

				if(shortcutPrefix == null)
					return null;
				else
				{
					return shortcutPrefix + "" "" + shortcut;
				}
			}
		} 

		
		static
		{
			acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
			acceleratorFont = new Font(""Monospaced"",
				acceleratorFont.getStyle(),
				acceleratorFont.getSize());
			acceleratorForeground = UIManager
				.getColor(""MenuItem.acceleratorForeground"");
			acceleratorSelectionForeground = UIManager
				.getColor(""MenuItem.acceleratorSelectionForeground"");
		} 

		
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.browser.VFSFileChooserDialog,10,7,0,19,90,15,6,18,5,0.793650794,606,1.0,2,0.986466165,0.25,3,6,58.9,17,3.4,1,"

package org.gjt.sp.jedit.browser;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.*;
import org.gjt.sp.jedit.gui.EnhancedDialog;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



public class VFSFileChooserDialog extends EnhancedDialog
{
	
	public VFSFileChooserDialog(View view, String path,
		int mode, boolean multipleSelection)
	{
		super(view,jEdit.getProperty(""vfs.browser.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		String name;
		if(mode == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
			name = null;
		else if(path == null || path.endsWith(File.separator)
			|| path.endsWith(""/""))
		{
			name = null;
		}
		else
		{
			VFS vfs = VFSManager.getVFSForPath(path);
			name = vfs.getFileName(path);
			path = vfs.getParentOfPath(path);
		}

		browser = new VFSBrowser(view,path,mode,multipleSelection,true);
		browser.addBrowserListener(new BrowserHandler());
		content.add(BorderLayout.CENTER,browser);

		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));

		filenameField = new JTextField();
		filenameField.setText(name);
		filenameField.addKeyListener(new KeyHandler());
		filenameField.selectAll();
		Dimension dim = filenameField.getPreferredSize();
		dim.width = Integer.MAX_VALUE;
		filenameField.setMaximumSize(dim);
		Box box = new Box(BoxLayout.Y_AXIS);
		box.add(Box.createGlue());
		box.add(filenameField);
		box.add(Box.createGlue());

		if(mode != VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
		{
			JLabel label = new JLabel(jEdit.getProperty(""vfs.browser.dialog.filename""));
			label.setDisplayedMnemonic(jEdit.getProperty(
				""vfs.browser.dialog.filename.mnemonic"").charAt(0));
			label.setLabelFor(filenameField);
			panel.add(label);
			panel.add(Box.createHorizontalStrut(12));

			panel.add(box);

			panel.add(Box.createHorizontalStrut(12));
		}
		else
			panel.add(Box.createGlue());

		if(mode == VFSBrowser.BROWSER || mode == VFSBrowser.OPEN_DIALOG
			|| mode == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
		{
			GUIUtilities.requestFocus(this,browser.getBrowserView()
				.getDefaultFocusComponent());
		}
		else
		{
			GUIUtilities.requestFocus(this,filenameField);
		}

		ok = new JButton();
		getRootPane().setDefaultButton(ok);

		switch(mode)
		{
		case VFSBrowser.OPEN_DIALOG:
		case VFSBrowser.BROWSER_DIALOG:
			ok.setText(jEdit.getProperty(""vfs.browser.dialog.open""));
			break;
		case VFSBrowser.CHOOSE_DIRECTORY_DIALOG:
			ok.setText(jEdit.getProperty(""vfs.browser.dialog.choose-dir""));
			
			dim = ok.getPreferredSize();
			ok.setPreferredSize(dim);
			break;
		case VFSBrowser.SAVE_DIALOG:
			ok.setText(jEdit.getProperty(""vfs.browser.dialog.save""));
			break;
		}

		ok.addActionListener(new ActionHandler());
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		panel.add(cancel);

		content.add(BorderLayout.SOUTH,panel);

		VFSManager.getIOThreadPool().addProgressListener(
			workThreadHandler = new WorkThreadHandler());

		pack();
		GUIUtilities.loadGeometry(this,""vfs.browser.dialog"");
		show();
	} 

	
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,""vfs.browser.dialog"");
		VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);
		super.dispose();
	} 

	
	public void ok()
	{
		VFS.DirectoryEntry[] files = browser.getSelectedFiles();

		String directory = browser.getDirectory();
		filename = filenameField.getText();

		if(files.length == 0)
		{
			if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
			{
				filename = browser.getDirectory();
			}
			else
			{
				if(filename.length() == 0)
				{
					getToolkit().beep();
					return;
				}
				else if(browser.getMode() == VFSBrowser.BROWSER_DIALOG)
				{
					Hashtable props = new Hashtable();
					props.put(Buffer.ENCODING,browser.currentEncoding);
					jEdit.openFile(browser.getView(),
						browser.getDirectory(),
						filename,false,props);
					dispose();
					return;
				}
			}
		}
		else
		{
			for(int i = 0; i < files.length; i++)
			{
				VFS.DirectoryEntry file = files[i];
				if(file.type == VFS.DirectoryEntry.FILESYSTEM
					|| file.type == VFS.DirectoryEntry.DIRECTORY)
				{
					browser.setDirectory(file.path);
					if(file.name.equals(filename))
						filenameField.setText(null);
					return;
				}
				else if(browser.getMode() == VFSBrowser.SAVE_DIALOG
					&& (filename == null || filename.length() == 0))
					filename = file.path;
			}
		}

		if(browser.getMode() == VFSBrowser.SAVE_DIALOG)
		{
			if(!MiscUtilities.isURL(directory)
				&& !MiscUtilities.isURL(filename))
			{
				filename = MiscUtilities.constructPath(directory,
					MiscUtilities.canonPath(filename));

				if(doFileExistsWarning(filename))
					return;
			}
		}
		else if(browser.getMode() == VFSBrowser.BROWSER_DIALOG)
		{
			browser.filesActivated(VFSBrowser.M_OPEN,false);
		}

		isOK = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public String[] getSelectedFiles()
	{
		if(!isOK)
			return null;

		if(filename != null && filename.length() != 0)
		{
			String path = browser.getDirectory();
			return new String[] { MiscUtilities.constructPath(
				path,filename) };
		}
		else
		{
			Vector vector = new Vector();
			VFS.DirectoryEntry[] selectedFiles = browser.getSelectedFiles();
			for(int i = 0; i < selectedFiles.length; i++)
			{
				VFS.DirectoryEntry file =  selectedFiles[i];
				if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
				{
					if(file.type != VFS.DirectoryEntry.FILE)
						vector.addElement(file.path);
				}
				else
				{
					if(file.type == VFS.DirectoryEntry.FILE)
						vector.addElement(file.path);
				}
			}
			String[] retVal = new String[vector.size()];
			vector.copyInto(retVal);
			return retVal;
		}
	} 

	

	
	private VFSBrowser browser;
	private JTextField filenameField;
	private String filename;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;
	private WorkThreadHandler workThreadHandler;
	

	
	private boolean doFileExistsWarning(String filename)
	{
		if(new File(filename).exists())
		{
			String[] args = { MiscUtilities.getFileName(filename) };
			int result = GUIUtilities.confirm(browser,
				""fileexists"",args,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return true;
		}

		return false;
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(!browser.getDirectory().equals(
					browser.getDirectoryField().getText()))
				{
					browser.setDirectory(browser.getDirectoryField().getText());
				}
				else
					ok();
			}
			else if(evt.getSource() == cancel)
				cancel();
		}
	} 

	
	class BrowserHandler implements BrowserListener
	{
		
		public void filesSelected(VFSBrowser browser, VFS.DirectoryEntry[] files)
		{
			if(files.length == 0)
			{
				if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
				{
					ok.setText(jEdit.getProperty(
						""vfs.browser.dialog.choose-dir""));
				}
				return;
			}
			else if(files.length == 1)
			{
				if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
				{
					ok.setText(jEdit.getProperty(
						""vfs.browser.dialog.open""));
				}

				VFS.DirectoryEntry file = files[0];
				if(file.type == VFS.DirectoryEntry.FILE)
				{
					String path = file.path;
					String directory = browser.getDirectory();
					VFS vfs = VFSManager.getVFSForPath(directory);
					String parent = vfs.getParentOfPath(path);
					if(parent.endsWith(""/"") || parent.endsWith(File.separator))
						parent = parent.substring(0,parent.length() - 1);
					if(parent.equals(directory))
						path = file.name;

					filenameField.setText(path);
					filenameField.selectAll();
				}
			}
			else
			{
				if(browser.getMode() == VFSBrowser.CHOOSE_DIRECTORY_DIALOG)
				{
					ok.setText(jEdit.getProperty(
						""vfs.browser.dialog.open""));
				}

				filenameField.setText(null);
			}
		} 

		
		public void filesActivated(VFSBrowser browser, VFS.DirectoryEntry[] files)
		{
			for(int i = 0; i < files.length; i++)
			{
				VFS.DirectoryEntry file = files[i];
				if(file.type == VFS.DirectoryEntry.FILESYSTEM
					|| file.type == VFS.DirectoryEntry.DIRECTORY)
				{
					if(file.name.equals(filenameField.getText()))
						filenameField.setText(null);

					
					
					return;
				}
			}

			if(browser.getMode() == VFSBrowser.BROWSER_DIALOG)
				dispose();
			else
				ok();
		} 
	} 

	
	class KeyHandler extends KeyAdapter
	{
		
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_LEFT:
				if(filenameField.getCaretPosition() == 0)
					browser.getBrowserView().getTree().processKeyEvent(evt);
				break;
			case KeyEvent.VK_UP:
			case KeyEvent.VK_DOWN:
				browser.getBrowserView().getTree().processKeyEvent(evt);
				break;
			}
		} 

		
		public void keyTyped(KeyEvent evt)
		{
			char ch = evt.getKeyChar();
			if(ch < 0x20 || ch == 0x7f || ch == 0xff)
				return;

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					String currentText = filenameField.getText();
					int caret = filenameField.getCaretPosition();

					BrowserView view = browser.getBrowserView();
					view.selectNone();
					view.getTree().doTypeSelect(
						currentText,
						false);
					VFS.DirectoryEntry[] files =
						view.getSelectedFiles();
					if(files.length != 0)
					{
						String path = files[0].path;
						String name = files[0].name;
						String parent = MiscUtilities.getParentOfPath(path);
						if(parent.endsWith(""/"") || parent.endsWith(File.separator))
							parent = parent.substring(0,parent.length() - 1);

						String newText;
						if(MiscUtilities.isAbsolutePath(currentText)
							&& !currentText.startsWith(browser.getDirectory()))
						{
							newText = path;
						}
						else
						{
							if(MiscUtilities.isAbsolutePath(currentText))
								caret -= MiscUtilities.getParentOfPath(currentText).length();
							if(parent.equals(browser.getDirectory()))
								newText = name;
							else
							{
								caret += parent.length() + 1;
								newText = path;
							}
						}

						filenameField.setText(newText);
						filenameField.setCaretPosition(
							newText.length());
						filenameField.moveCaretPosition(
							caret);
					}
				}
			});
		} 
	} 

	
	class WorkThreadHandler implements WorkThreadProgressListener
	{
		
		public void statusUpdate(WorkThreadPool threadPool, int threadIndex)
		{
			
			synchronized(VFSFileChooserDialog.this)
			{
				int requestCount = threadPool.getRequestCount();
				if(requestCount == 0)
				{
					getContentPane().setCursor(
						Cursor.getDefaultCursor());
				}
				else if(requestCount >= 1)
				{
					getContentPane().setCursor(
						Cursor.getPredefinedCursor(
						Cursor.WAIT_CURSOR));
				}
			}
		} 

		
		public void progressUpdate(WorkThreadPool threadPool, int threadIndex)
		{
		} 
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.HistoryTextField,28,6,0,21,91,206,18,6,15,0.772486772,615,1.0,1,0.970588235,0.219387755,3,7,20.71428571,13,2.3571,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.Border;
import javax.swing.border.AbstractBorder;
import javax.swing.border.CompoundBorder;
import javax.swing.event.MouseInputAdapter;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;



public class HistoryTextField extends JTextField
{
	
	
	public HistoryTextField()
	{
		this(null);
	} 

	
	
	public HistoryTextField(String name)
	{
		this(name,false,true);
	} 

	
	
	public HistoryTextField(String name, boolean instantPopups)
	{
		this(name,instantPopups,true);
	} 

	
	
	public HistoryTextField(String name, boolean instantPopups,
		boolean enterAddsToHistory)
	{
		setBorder(new CompoundBorder(getBorder(),new HistoryBorder()));

		if(name != null)
			historyModel = HistoryModel.getModel(name);

		MouseHandler mouseHandler = new MouseHandler();
		addMouseListener(mouseHandler);
		addMouseMotionListener(mouseHandler);

		this.instantPopups = instantPopups;
		this.enterAddsToHistory = enterAddsToHistory;

		index = -1;
	} 

	
	
	public void setInstantPopups(boolean instantPopups)
	{
		this.instantPopups = instantPopups;
	} 

	
	
	public boolean getInstantPopups()
	{
		return instantPopups;
	} 

	
	
	public void setEnterAddsToHistory(boolean enterAddsToHistory)
	{
		this.enterAddsToHistory = enterAddsToHistory;
	} 

	
	
	public boolean setEnterAddsToHistory()
	{
		return enterAddsToHistory;
	} 

	
	
	public void setSelectAllOnFocus(boolean selectAllOnFocus)
	{
		this.selectAllOnFocus = selectAllOnFocus;
	} 

	
	
	public boolean setSelectAllOnFocus()
	{
		return selectAllOnFocus;
	} 

	
	
	public void setModel(String name)
	{
		if(name == null)
			historyModel = null;
		else
			historyModel = HistoryModel.getModel(name);
		index = -1;
		repaint();
	} 

	
	
	public void addCurrentToHistory()
	{
		if(historyModel != null)
			historyModel.addItem(getText());
		index = 0;
	} 

	
	
	public void setText(String text)
	{
		super.setText(text);
		index = -1;
	} 

	
	
	public HistoryModel getModel()
	{
		return historyModel;
	} 

	
	
	public void fireActionPerformed()
	{
		super.fireActionPerformed();
	} 

	

	
	protected void processKeyEvent(KeyEvent evt)
	{
		if(!isEnabled())
			return;

		

		if(evt.getID() == KeyEvent.KEY_PRESSED)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				if(enterAddsToHistory)
					addCurrentToHistory();

				if(evt.getModifiers() == 0)
				{
					fireActionPerformed();
					evt.consume();
				}
			}
			else if(evt.getKeyCode() == KeyEvent.VK_UP)
			{
				if(evt.isShiftDown())
					doBackwardSearch();
				else
					historyPrevious();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_DOWN)
			{
				if(evt.isShiftDown())
					doForwardSearch();
				else
					historyNext();
				evt.consume();
			}
			else if(evt.getKeyCode() == KeyEvent.VK_TAB
				&& evt.isControlDown())
			{
				doBackwardSearch();
				evt.consume();
			}
		}

		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	
	protected void processMouseEvent(MouseEvent evt)
	{
		if(!isEnabled())
			return;

		switch(evt.getID())
		{
		case MouseEvent.MOUSE_PRESSED:
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);

			if(evt.getX() >= getWidth() - insets.right
				|| GUIUtilities.isPopupTrigger(evt))
			{
				if(evt.isShiftDown())
					showPopupMenu(getText().substring(0,
						getSelectionStart()),0,getHeight());
				else
					showPopupMenu("""",0,getHeight());
			}
			else
				super.processMouseEvent(evt);

			break;
		case MouseEvent.MOUSE_EXITED:
			setCursor(Cursor.getDefaultCursor());
			super.processMouseEvent(evt);
			break;
		default:
			super.processMouseEvent(evt);
			break;
		}
	} 

	

	

	
	private HistoryModel historyModel;
	private JPopupMenu popup;
	private boolean instantPopups;
	private boolean enterAddsToHistory;
	private boolean selectAllOnFocus;
	private String current;
	private int index;
	

	
	private void doBackwardSearch()
	{
		if(historyModel == null)
			return;

		if(getSelectionEnd() != getDocument().getLength())
		{
			setCaretPosition(getDocument().getLength());
		}

		String text = getText().substring(0,getSelectionStart());
		if(text == null)
		{
			historyPrevious();
			return;
		}

		for(int i = index + 1; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				replaceSelection(item.substring(text.length()));
				select(text.length(),getDocument().getLength());
				index = i;
				return;
			}
		}

		getToolkit().beep();
	} 

	
	private void doForwardSearch()
	{
		if(historyModel == null)
			return;

		if(getSelectionEnd() != getDocument().getLength())
		{
			setCaretPosition(getDocument().getLength());
		}

		String text = getText().substring(0,getSelectionStart());
		if(text == null)
		{
			historyNext();
			return;
		}

		for(int i = index - 1; i >= 0; i--)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				replaceSelection(item.substring(text.length()));
				select(text.length(),getDocument().getLength());
				index = i;
				return;
			}
		}

		getToolkit().beep();
	} 

	
	private void historyPrevious()
	{
		if(historyModel == null)
			return;

		if(index == historyModel.getSize() - 1)
			getToolkit().beep();
		else if(index == -1)
		{
			current = getText();
			setText(historyModel.getItem(0));
			index = 0;
		}
		else
		{
			
			int newIndex = index + 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	} 

	
	private void historyNext()
	{
		if(historyModel == null)
			return;

		if(index == -1)
			getToolkit().beep();
		else if(index == 0)
			setText(current);
		else
		{
			
			int newIndex = index - 1;
			setText(historyModel.getItem(newIndex));
			index = newIndex;
		}
	} 

	
	private void showPopupMenu(String text, int x, int y)
	{
		if(historyModel == null)
			return;

		requestFocus();

		if(popup != null && popup.isVisible())
		{
			popup.setVisible(false);
			return;
		}

		ActionHandler actionListener = new ActionHandler();

		popup = new JPopupMenu();
		JMenuItem caption = new JMenuItem(jEdit.getProperty(
			""history.caption""));
		caption.getModel().setEnabled(false);
 		popup.add(caption);
 		popup.addSeparator();

		for(int i = 0; i < historyModel.getSize(); i++)
		{
			String item = historyModel.getItem(i);
			if(item.startsWith(text))
			{
				JMenuItem menuItem = new JMenuItem(item);
				menuItem.setActionCommand(String.valueOf(i));
				menuItem.addActionListener(actionListener);
				popup.add(menuItem);
			}
		}

		GUIUtilities.showPopupMenu(popup,this,x,y,false);
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			int ind = Integer.parseInt(evt.getActionCommand());
			if(ind == -1)
			{
				if(index != -1)
					setText(current);
			}
			else
			{
				setText(historyModel.getItem(ind));
				index = ind;
			}
			if(instantPopups)
			{
				addCurrentToHistory();
				fireActionPerformed();
			}
		}
	} 

	
	class MouseHandler extends MouseInputAdapter
	{
		boolean selectAll;

		
		public void mousePressed(MouseEvent evt)
		{
			selectAll = (!hasFocus() && selectAllOnFocus);
		} 

		
		public void mouseReleased(MouseEvent evt)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					if(selectAll)
						selectAll();
				}
			});
		} 

		
		public void mouseMoved(MouseEvent evt)
		{
			Border border = getBorder();
			Insets insets = border.getBorderInsets(HistoryTextField.this);

			if(evt.getX() >= getWidth() - insets.right)
				setCursor(Cursor.getDefaultCursor());
			else
				setCursor(Cursor.getPredefinedCursor(
					Cursor.TEXT_CURSOR));
		} 

		
		public void mouseDragged(MouseEvent evt)
		{
			selectAll = false;
		} 
	} 

	
	static class HistoryBorder extends AbstractBorder
	{
		static final int WIDTH = 16;

		public void paintBorder(Component c, Graphics g,
			int x, int y, int w, int h)
		{
			g.translate(x+w-WIDTH,y-1);

			
			
			
			
			
			

			
			int w2 = WIDTH/2;
			int h2 = h/2;
			g.setColor(UIManager.getColor(c.isEnabled()
				&& ((HistoryTextField)c).getModel() != null
				? ""TextField.foreground"" : ""TextField.disabledForeground""));
			g.drawLine(w2-5,h2-2,w2+4,h2-2);
			g.drawLine(w2-4,h2-1,w2+3,h2-1);
			g.drawLine(w2-3,h2  ,w2+2,h2  );
			g.drawLine(w2-2,h2+1,w2+1,h2+1);
			g.drawLine(w2-1,h2+2,w2  ,h2+2);

			g.translate(-(x+w-WIDTH),-(y-1));
		}

		public Insets getBorderInsets(Component c)
		{
			return new Insets(0,0,0,WIDTH);
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.util.IntegerArray,6,1,0,4,8,0,4,0,6,0.5,66,1.0,0,0.0,0.75,0,0,9.666666667,2,1.0,0,"

package org.gjt.sp.util;


public class IntegerArray
{
	
	public IntegerArray()
	{
		array = new int[1000];
	} 

	
	public void add(int num)
	{
		if(len >= array.length)
		{
			int[] arrayN = new int[len * 2];
			System.arraycopy(array,0,arrayN,0,len);
			array = arrayN;
		}

		array[len++] = num;
	} 

	
	public final int get(int index)
	{
		return array[index];
	} 

	
	public final int getSize()
	{
		return len;
	} 

	
	public final void setSize(int len)
	{
		this.len = len;
	} 

	
	public final void clear()
	{
		len = 0;
	} 

	
	private int[] array;
	private int len;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.LogViewer,5,5,0,5,28,0,2,5,2,0.666666667,119,1.0,0,0.99391172,0.4,0,0,22.2,1,0.8,1,"

package org.gjt.sp.jedit.gui;


import java.awt.BorderLayout;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import javax.swing.*;
import javax.swing.event.DocumentEvent;
import javax.swing.event.DocumentListener;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class LogViewer extends JPanel
{
	
	public LogViewer()
	{
		super(new BorderLayout());

		Box captionBox = Box.createHorizontalBox();

		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			String[] args = { MiscUtilities.constructPath(
				settingsDirectory, ""activity.log"") };
			JLabel label = new JLabel(jEdit.getProperty(
				""log-viewer.caption"",args));
			captionBox.add(label);
		}

		captionBox.add(Box.createHorizontalGlue());

		tailIsOn = jEdit.getBooleanProperty(""log-viewer.tail"", false);
		tail = new JCheckBox(
			jEdit.getProperty(""log-viewer.tail.label""),tailIsOn);
		tail.addActionListener(new ActionHandler());
		captionBox.add(tail);

		textArea = new JTextArea(24,80);
		textArea.setDocument(Log.getLogDocument());
		textArea.getDocument().addDocumentListener(
			new DocumentHandler());
		

		add(BorderLayout.NORTH,captionBox);
		add(BorderLayout.CENTER,new JScrollPane(textArea));
	} 

	
	public boolean requestDefaultFocus()
	{
		textArea.requestFocus();
		return true;
	} 

	
	private JTextArea textArea;
	private JCheckBox tail;
	private boolean tailIsOn;
	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent e)
		{
			tailIsOn = !tailIsOn;
			jEdit.setBooleanProperty(""log-viewer.tail"",tailIsOn);
			if(tailIsOn)
				textArea.setCaretPosition(
					textArea.getDocument().getLength());
		}
	} 

	
	class DocumentHandler implements DocumentListener
	{
		public void insertUpdate(DocumentEvent e)
		{
			if(tailIsOn)
				textArea.setCaretPosition(
					textArea.getDocument().getLength());
		}

		public void changedUpdate(DocumentEvent e) {}
		public void removeUpdate(DocumentEvent e) {}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.io.FileVFS,20,2,0,11,91,190,4,9,19,1.0,690,0.0,0,0.672413793,0.4,2,3,33.4,8,3.0,4,"

package org.gjt.sp.jedit.io;


import java.awt.Component;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class FileVFS extends VFS
{
	public static final String PERMISSIONS_PROPERTY = ""FileVFS__perms"";

	
	public FileVFS()
	{
		super(""file"",READ_CAP | WRITE_CAP | BROWSE_CAP | DELETE_CAP
			| RENAME_CAP | MKDIR_CAP | LOW_LATENCY_CAP);
	} 

	
	public String getParentOfPath(String path)
	{
		if(OperatingSystem.isDOSDerived())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				return FileRootsVFS.PROTOCOL + "":"";
			else if(path.length() == 3 && path.endsWith("":\\""))
				return FileRootsVFS.PROTOCOL + "":"";
			else if(path.startsWith(""\\\\"") && path.indexOf('\\',2) == -1)
				return path;
		}

		return super.getParentOfPath(path);
	} 

	
	public String constructPath(String parent, String path)
	{
		if(parent.endsWith(File.separator))
			path = parent + path;
		else
			path = parent + File.separator + path;

		try
		{
			return new File(path).getCanonicalPath();
		}
		catch(IOException io)
		{
			return path;
		}
	} 

	
	public char getFileSeparator()
	{
		return File.separatorChar;
	} 

	
	public boolean load(View view, Buffer buffer, String path)
	{
		File file = new File(MiscUtilities.canonPath(path));

		
		if(!file.exists())
		{
			buffer.setNewFile(true);
			return true;
		}
		else
			buffer.setReadOnly(!file.canWrite());

		if(file.isDirectory())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.open-directory"",null);
			buffer.setNewFile(false);
			return false;
		}

		if(!file.canRead())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.no-read"",null);
			buffer.setNewFile(false);
			return false;
		} 

		return super.load(view,buffer,path);
	} 

	
	public boolean save(View view, Buffer buffer, String path)
	{
		
		
		File file = new File(path);

		

		
		
		if(file.isDirectory())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.save-directory"",null);
			return false;
		}

		
		if((file.exists() && !file.canWrite())
			|| (!file.exists() && !new File(file.getParent()).canWrite()))
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.no-write"",null);
			return false;
		} 

		
		if(OperatingSystem.isUnix())
		{
			int permissions = getPermissions(buffer.getPath());
			Log.log(Log.DEBUG,this,buffer.getPath() + "" has permissions 0""
				+ Integer.toString(permissions,8));
			buffer.setIntegerProperty(PERMISSIONS_PROPERTY,permissions);
		} 

		return super.save(view,buffer,path);
	} 

	
	public boolean insert(View view, Buffer buffer, String path)
	{
		File file = new File(path);

		
		if(!file.exists())
			return false;

		if(file.isDirectory())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.open-directory"",null);
			return false;
		}

		if(!file.canRead())
		{
			VFSManager.error(view,file.getPath(),
				""ioerror.no-read"",null);
			return false;
		} 

		return super.insert(view,buffer,path);
	} 

	
	
	public String _canonPath(Object session, String path, Component comp)
		throws IOException
	{
		return MiscUtilities.canonPath(path);
	} 

	
	public VFS.DirectoryEntry[] _listDirectory(Object session, String path,
		Component comp)
	{
		
		
		if(OperatingSystem.isWindows())
		{
			if(path.length() == 2 && path.charAt(1) == ':')
				path = path.concat(File.separator);
		} 

		File directory = new File(path);
		File[] list = directory.listFiles();
		if(list == null)
		{
			VFSManager.error(comp,path,""ioerror.directory-error-nomsg"",null);
			return null;
		}

		VFS.DirectoryEntry[] list2 = new VFS.DirectoryEntry[list.length];
		for(int i = 0; i < list.length; i++)
		{
			File file = list[i];

			int type;
			if(file.isDirectory())
				type = VFS.DirectoryEntry.DIRECTORY;
			else
				type = VFS.DirectoryEntry.FILE;

			list2[i] = new VFS.DirectoryEntry(file.getName(),
				file.getPath(),file.getPath(),type,
				file.length(),file.isHidden());
		}

		return list2;
	} 

	
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		if(path.equals(""/"") && OperatingSystem.isUnix())
		{
			return new VFS.DirectoryEntry(path,path,path,
				VFS.DirectoryEntry.DIRECTORY,0L,false);
		}

		
		
		if(path.endsWith(""/"") || path.endsWith(File.separator))
			path = path.substring(0,path.length() - 1);

		File file = new File(path);
		if(!file.exists())
			return null;

		int type;
		if(file.isDirectory())
			type = VFS.DirectoryEntry.DIRECTORY;
		else
			type = VFS.DirectoryEntry.FILE;

		return new VFS.DirectoryEntry(file.getName(),path,path,type,
			file.length(),file.isHidden());
	} 

	
	public boolean _delete(Object session, String path, Component comp)
	{
		boolean retVal = new File(path).delete();
		if(retVal)
			VFSManager.sendVFSUpdate(this,path,true);
		return retVal;
	} 

	
	public boolean _rename(Object session, String from, String to,
		Component comp)
	{
		File _to = new File(to);

		
		if(!from.equalsIgnoreCase(to))
			_to.delete();

		boolean retVal = new File(from).renameTo(_to);
		VFSManager.sendVFSUpdate(this,from,true);
		VFSManager.sendVFSUpdate(this,to,true);
		return retVal;
	} 

	
	public boolean _mkdir(Object session, String directory, Component comp)
	{
		String parent = getParentOfPath(directory);
		if(!new File(parent).exists())
		{
			if(!_mkdir(session,parent,comp))
				return false;
		}

		boolean retVal = new File(directory).mkdir();
		VFSManager.sendVFSUpdate(this,directory,true);
		return retVal;
	} 

	
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
		
		int backups = jEdit.getIntegerProperty(""backups"",1);

		if(backups == 0)
			return;

		String backupPrefix = jEdit.getProperty(""backup.prefix"");
		String backupSuffix = jEdit.getProperty(""backup.suffix"");

		String backupDirectory = MiscUtilities.canonPath(
			jEdit.getProperty(""backup.directory""));

		File file = new File(path);

		
		
		if(backupDirectory == null || backupDirectory.length() == 0)
			backupDirectory = file.getParent();
		else
		{
			backupDirectory = MiscUtilities.constructPath(
				System.getProperty(""user.home""),backupDirectory);

			
			
			backupDirectory = MiscUtilities.concatPath(
				backupDirectory,file.getParent());

			File dir = new File(backupDirectory);

			if (!dir.exists())
				dir.mkdirs();
		}

		MiscUtilities.saveBackup(file,backups,backupPrefix,
			backupSuffix,backupDirectory);
	} 

	
	public InputStream _createInputStream(Object session, String path,
		boolean ignoreErrors, Component comp) throws IOException
	{
		try
		{
			return new FileInputStream(path);
		}
		catch(IOException io)
		{
			if(ignoreErrors)
				return null;
			else
				throw io;
		}
	} 

	
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		OutputStream retVal = new FileOutputStream(path);

		
		
		
		return retVal;
	} 

	
	public void _saveComplete(Object session, Buffer buffer, String path,
		Component comp)
	{
		int permissions = buffer.getIntegerProperty(PERMISSIONS_PROPERTY,0);
		setPermissions(path,permissions);
	} 

	

	

	
	
	public static int getPermissions(String path)
	{
		int permissions = 0;

		if(OperatingSystem.isUnix())
		{
			String[] cmdarray = { ""ls"", ""-ld"", path };

			try
			{
				Process process = Runtime.getRuntime().exec(cmdarray);

				BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));

				String output = reader.readLine();

				if(output != null)
				{
					String s = output.substring(1, 10);

					permissions = MiscUtilities
						.parsePermissions(s);
				}
			}

			
			
			
			catch (Throwable t)
			{
			}
		}

		return permissions;
	} 

	
	
	public static void setPermissions(String path, int permissions)
	{
		if(permissions != 0)
		{
			if(OperatingSystem.isUnix())
			{
				String[] cmdarray = { ""chmod"", Integer.toString(permissions, 8), path };

				try
				{
					Process process = Runtime.getRuntime().exec(cmdarray);
					process.getInputStream().close();
					process.getOutputStream().close();
					process.getErrorStream().close();
					int exitCode = process.waitFor();
					if(exitCode != 0)
						Log.log(Log.NOTICE,FileVFS.class,""chmod exited with code "" + exitCode);
				}

				
				
				
				catch (Throwable t)
				{
				}
			}
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.options.LoadSaveOptionPane,5,6,0,4,35,0,2,3,3,0.714285714,406,1.0,0,0.994056464,0.5,3,5,77.4,5,1.8,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.event.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;


public class LoadSaveOptionPane extends AbstractOptionPane
{
	
	public LoadSaveOptionPane()
	{
		super(""loadsave"");
	} 

	
	public void _init()
	{
		
		autosave = new JTextField(jEdit.getProperty(""autosave""));
		addComponent(jEdit.getProperty(""options.loadsave.autosave""),autosave);

		
		backups = new JTextField(jEdit.getProperty(""backups""));
		addComponent(jEdit.getProperty(""options.loadsave.backups""),backups);

		
		backupDirectory = new JTextField(jEdit.getProperty(
			""backup.directory""));
		addComponent(jEdit.getProperty(""options.loadsave.backupDirectory""),
			backupDirectory);

		
		backupPrefix = new JTextField(jEdit.getProperty(""backup.prefix""));
		addComponent(jEdit.getProperty(""options.loadsave.backupPrefix""),
			backupPrefix);

		
		backupSuffix = new JTextField(jEdit.getProperty(
			""backup.suffix""));
		addComponent(jEdit.getProperty(""options.loadsave.backupSuffix""),
			backupSuffix);

		
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = jEdit.getProperty(""buffer.lineSeparator"",
			System.getProperty(""line.separator""));
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		addComponent(jEdit.getProperty(""options.loadsave.lineSeparator""),
			lineSeparator);

		
		DefaultComboBoxModel encodings = new DefaultComboBoxModel();
		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			encodings.addElement(st.nextToken());
		}

		encoding = new JComboBox(encodings);
		encoding.setEditable(true);
		encoding.setSelectedItem(jEdit.getProperty(""buffer.encoding"",
			System.getProperty(""file.encoding"")));
		addComponent(jEdit.getProperty(""options.loadsave.encoding""),encoding);

		
		restore = new JCheckBox(jEdit.getProperty(
			""options.loadsave.restore""));
		restore.setSelected(jEdit.getBooleanProperty(""restore""));
		restore.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				restoreCLI.setEnabled(restore.isSelected());
			}
		});

		addComponent(restore);
		restoreCLI = new JCheckBox(jEdit.getProperty(
			""options.loadsave.restore.cli""));
		restoreCLI.setSelected(jEdit.getBooleanProperty(""restore.cli""));
		restoreCLI.setEnabled(restore.isSelected());
		addComponent(restoreCLI);

		
		newView = new JCheckBox(jEdit.getProperty(
			""options.loadsave.newView""));
		newView.setSelected(jEdit.getBooleanProperty(""client.newView""));
		addComponent(newView);

		
		persistentMarkers = new JCheckBox(jEdit.getProperty(
			""options.loadsave.persistentMarkers""));
		persistentMarkers.setSelected(jEdit.getBooleanProperty(
			""persistentMarkers""));
		addComponent(persistentMarkers);

		
		twoStageSave = new JCheckBox(jEdit.getProperty(
			""options.loadsave.twoStageSave""));
		twoStageSave.setSelected(jEdit.getBooleanProperty(
			""twoStageSave""));
		addComponent(twoStageSave);

		
		backupEverySave = new JCheckBox(jEdit.getProperty(
			""options.loadsave.backupEverySave""));
		backupEverySave.setSelected(jEdit.getBooleanProperty(""backupEverySave""));
		addComponent(backupEverySave);

		
		stripTrailingEOL = new JCheckBox(jEdit.getProperty(
			""options.loadsave.stripTrailingEOL""));
		stripTrailingEOL.setSelected(jEdit.getBooleanProperty(""stripTrailingEOL""));
		addComponent(stripTrailingEOL);

	} 

	
	public void _save()
	{
		jEdit.setProperty(""autosave"",autosave.getText());
		jEdit.setProperty(""backups"",backups.getText());
		jEdit.setProperty(""backup.directory"",backupDirectory.getText());
		jEdit.setProperty(""backup.prefix"",backupPrefix.getText());
		jEdit.setProperty(""backup.suffix"",backupSuffix.getText());
		String lineSep = null;
		switch(lineSeparator.getSelectedIndex())
		{
		case 0:
			lineSep = ""\n"";
			break;
		case 1:
			lineSep = ""\r\n"";
			break;
		case 2:
			lineSep = ""\r"";
			break;
		}
		jEdit.setProperty(""buffer.lineSeparator"",lineSep);
		jEdit.setProperty(""buffer.encoding"",(String)
			encoding.getSelectedItem());
		jEdit.setBooleanProperty(""restore"",restore.isSelected());
		jEdit.setBooleanProperty(""restore.cli"",restoreCLI.isSelected());
		jEdit.setBooleanProperty(""client.newView"",newView.isSelected());
		jEdit.setBooleanProperty(""persistentMarkers"",
			persistentMarkers.isSelected());
		jEdit.setBooleanProperty(""twoStageSave"",twoStageSave.isSelected());
		jEdit.setBooleanProperty(""backupEverySave"", backupEverySave.isSelected());
		jEdit.setBooleanProperty(""stripTrailingEOL"", stripTrailingEOL.isSelected());
	} 

	
	private JTextField autosave;
	private JTextField backups;
	private JTextField backupDirectory;
	private JTextField backupPrefix;
	private JTextField backupSuffix;
	private JComboBox lineSeparator;
	private JComboBox encoding;
	private JCheckBox restore;
	private JCheckBox restoreCLI;
	private JCheckBox newView;
	private JCheckBox persistentMarkers;
	private JCheckBox twoStageSave;
	private JCheckBox backupEverySave;
	private JCheckBox stripTrailingEOL;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.msg.EditorStarted,1,2,0,3,2,0,1,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class EditorStarted extends EBMessage
{
	
	public EditorStarted(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4.1,org.gjt.sp.util.WorkThreadProgressListener,2,1,0,6,2,1,6,1,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.util;

import java.util.EventListener;


public interface WorkThreadProgressListener extends EventListener
{
	
	void statusUpdate(WorkThreadPool threadPool, int threadIndex);

	
	void progressUpdate(WorkThreadPool threadPool, int threadIndex);
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.ParserRuleSet,27,1,0,14,36,293,11,4,26,0.925339367,293,1.0,7,0.0,0.136363636,0,0,9.222222222,4,1.1481,1,"

package org.gjt.sp.jedit.syntax;


import gnu.regexp.RE;
import java.util.*;
import org.gjt.sp.jedit.Mode;



public class ParserRuleSet
{
	
	
	public static ParserRuleSet getStandardRuleSet(byte id)
	{
		return standard[id];
	} 

	
	public ParserRuleSet(String name, Mode mode)
	{
		this.name = name;
		this.mode = mode;
		ruleMapFirst = new ParserRule[RULE_BUCKET_COUNT];
		ruleMapLast = new ParserRule[RULE_BUCKET_COUNT];
	} 

	
	public String getName()
	{
		return name;
	} 

	
	public Mode getMode()
	{
		return mode;
	} 

	
	public Hashtable getProperties()
	{
		return props;
	} 

	
	public void setProperties(Hashtable props)
	{
		this.props = props;
		_noWordSep = null;
	} 

	
	public void addRule(ParserRule r)
	{
		ruleCount++;

		int key = Character.toUpperCase(r.hashChar)
			% RULE_BUCKET_COUNT;
		ParserRule last = ruleMapLast[key];
		if(last == null)
			ruleMapFirst[key] = ruleMapLast[key] = r;
		else
		{
			last.next = r;
			ruleMapLast[key] = r;
		}
	} 

	
	public ParserRule getRules(char ch)
	{
		int key = Character.toUpperCase(ch) % RULE_BUCKET_COUNT;
		return ruleMapFirst[key];
	} 

	
	public int getRuleCount()
	{
		return ruleCount;
	} 

	
	public int getTerminateChar()
	{
		return terminateChar;
	} 

	
	public void setTerminateChar(int atChar)
	{
		terminateChar = (atChar >= 0) ? atChar : -1;
	} 

	
	public boolean getIgnoreCase()
	{
		return ignoreCase;
	} 

	
	public void setIgnoreCase(boolean b)
	{
		ignoreCase = b;
	} 

	
	public KeywordMap getKeywords()
	{
		return keywords;
	} 

	
	public void setKeywords(KeywordMap km)
	{
		keywords = km;
		_noWordSep = null;
	} 

	
	public boolean getHighlightDigits()
	{
		return highlightDigits;
	} 

	
	public void setHighlightDigits(boolean highlightDigits)
	{
		this.highlightDigits = highlightDigits;
	} 

	
	public RE getDigitRegexp()
	{
		return digitRE;
	} 

	
	public void setDigitRegexp(RE digitRE)
	{
		this.digitRE = digitRE;
	} 

	
	public ParserRule getEscapeRule()
	{
		return escapeRule;
	} 

	
	public void setEscapeRule(ParserRule escapeRule)
	{
		addRule(escapeRule);
		this.escapeRule = escapeRule;
	} 

	
	public byte getDefault()
	{
		return defaultToken;
	} 

	
	public void setDefault(byte def)
	{
		defaultToken = def;
	} 

	
	public String getNoWordSep()
	{
		if(_noWordSep == null)
		{
			_noWordSep = noWordSep;
			if(noWordSep == null)
				noWordSep = """";
			if(keywords != null)
				noWordSep += keywords.getNonAlphaNumericChars();
		}
		return noWordSep;
	} 

	
	public void setNoWordSep(String noWordSep)
	{
		this.noWordSep = noWordSep;
		_noWordSep = null;
	} 

	
	public String toString()
	{
		return getClass().getName() + ""["" + (mode == null ? """"
			: mode.getName()) + ""::""
			+ name + ""]"";
	} 

	
	private static ParserRuleSet[] standard;

	static
	{
		standard = new ParserRuleSet[Token.ID_COUNT];
		for(byte i = 0; i < standard.length; i++)
		{
			standard[i] = new ParserRuleSet(null,null);
			standard[i].setDefault(i);
		}
	}

	private static final int RULE_BUCKET_COUNT = 128;

	private String name;
	private Mode mode;
	private Hashtable props;

	private KeywordMap keywords;

	private int ruleCount;

	private ParserRule[] ruleMapFirst;
	private ParserRule[] ruleMapLast;

	private int terminateChar = -1;
	private boolean ignoreCase = true;
	private byte defaultToken;
	private ParserRule escapeRule;

	private boolean highlightDigits;
	private RE digitRE;

	private String _noWordSep;
	private String noWordSep;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.search.RESearchMatcher,4,1,0,14,29,0,4,10,3,0.619047619,207,0.857142857,4,0.0,0.6,0,0,49.0,9,2.5,0,"

package org.gjt.sp.jedit.search;


import bsh.BshMethod;
import bsh.NameSpace;
import gnu.regexp.*;
import org.gjt.sp.jedit.BeanShell;
import org.gjt.sp.jedit.MiscUtilities;



public class RESearchMatcher implements SearchMatcher
{
	
	public static final RESyntax RE_SYNTAX_JEDIT
		= new RESyntax(RESyntax.RE_SYNTAX_PERL5)
		.set(RESyntax.RE_CHAR_CLASSES)
		.setLineSeparator(""\n"");

	
	
	public RESearchMatcher(String search, String replace,
		boolean ignoreCase, boolean beanshell,
		BshMethod replaceMethod) throws Exception
	{
		if(beanshell && replaceMethod != null && replace.length() != 0)
		{
			this.beanshell = true;
			this.replaceMethod = replaceMethod;
			replaceNS = new NameSpace(BeanShell.getNameSpace(),
				""search and replace"");
		}
		else
		{
			
			
			this.replace = MiscUtilities.escapesToChars(replace);
		}

		re = new RE(search,(ignoreCase ? RE.REG_ICASE : 0)
			| RE.REG_MULTILINE,RE_SYNTAX_JEDIT);

		returnValue = new int[2];
	} 

	
	
	public int[] nextMatch(CharIndexed text, boolean start, boolean end,
		boolean firstTime, boolean reverse)
	{
		int flags = 0;

		
		
		if(!start)
			flags |= RE.REG_NOTBOL;
		
		
		if(!end)
			flags |= RE.REG_NOTEOL;

		REMatch match = re.getMatch(text,0,flags);
		if(match == null)
			return null;

		int _start = match.getStartIndex();
		int _end = match.getEndIndex();

		
		
		
		if(!firstTime && _start == 0 && _end == 0)
		{
			text.move(1);

			if(text.charAt(0) == CharIndexed.OUT_OF_BOUNDS)
			{
				
				return null;
			}

			match = re.getMatch(text,0,flags | RE.REG_NOTBOL);
			if(match == null)
				return null;
			else
			{
				_start = match.getStartIndex() + 1;
				_end = match.getEndIndex() + 1;
			}
		}

		returnValue[0] = _start;
		returnValue[1] = _end;
		return returnValue;
	} 

	
	
	public String substitute(String text) throws Exception
	{
		REMatch match = re.getMatch(text);
		if(match == null)
			return null;

		if(beanshell)
		{
			int count = re.getNumSubs();
			for(int i = 0; i <= count; i++)
				replaceNS.setVariable(""_"" + i,match.toString(i));

			Object obj = BeanShell.runCachedBlock(replaceMethod,
				null,replaceNS);
			if(obj == null)
				return """";
			else
				return obj.toString();
		}
		else
			return match.substituteInto(replace);
	} 

	
	private String replace;
	private RE re;
	private boolean beanshell;
	private BshMethod replaceMethod;
	private NameSpace replaceNS;
	private int[] returnValue;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.search.HyperSearchRequest,9,2,0,19,52,16,4,19,2,0.770833333,404,1.0,4,0.428571429,0.24691358,0,0,43.22222222,11,2.7778,0,"

package org.gjt.sp.jedit.search;


import javax.swing.text.Segment;
import javax.swing.tree.*;
import javax.swing.SwingUtilities;
import org.gjt.sp.jedit.textarea.Selection;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.GUIUtilities;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.View;
import org.gjt.sp.util.*;


class HyperSearchRequest extends WorkRequest
{
	
	public HyperSearchRequest(View view, SearchMatcher matcher,
		HyperSearchResults results, Selection[] selection)
	{
		this.view = view;
		this.matcher = matcher;

		this.results = results;
		this.searchString = SearchAndReplace.getSearchString();
		this.rootSearchNode = new DefaultMutableTreeNode(searchString);

		this.selection = selection;
	} 

	
	public void run()
	{
		setStatus(jEdit.getProperty(""hypersearch-status""));

		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		String[] files = fileset.getFiles(view);
		if(files == null || files.length == 0)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					GUIUtilities.error(view,""empty-fileset"",null);
				}
			});
			return;
		}

		setProgressMaximum(fileset.getFileCount(view));

		
		

		
		long lastStatusTime = 0;

		try
		{
			if(selection != null)
			{
				Buffer buffer = view.getBuffer();

				searchInSelection(buffer);
			}
			else
			{
				int current = 0;

loop:				for(int i = 0; i < files.length; i++)
				{
					String file = files[i];
					current++;

					long currentTime = System.currentTimeMillis();
					if(currentTime - lastStatusTime > 500)
					{
						setStatus(jEdit.getProperty(""hypersearch-status-file"",
							new String[] { file }));
						setProgressValue(current);
						lastStatusTime = currentTime;
					}

					Buffer buffer = jEdit.openTemporary(null,null,file,false);
					if(buffer == null)
						continue loop;

					doHyperSearch(buffer);
				};
			}
		}
		catch(final Exception e)
		{
			Log.log(Log.ERROR,this,e);
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					GUIUtilities.error(view,""searcherror"",
						new String[] { e.toString() });
				}
			});
		}
		catch(WorkThread.Abort a)
		{
		}
		finally
		{
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					results.searchDone(rootSearchNode);
				}
			});
		}
	} 

	

	
	private View view;
	private SearchMatcher matcher;
	private HyperSearchResults results;
	private DefaultMutableTreeNode rootSearchNode;
	private Selection[] selection;
	private String searchString;
	

	
	private int searchInSelection(Buffer buffer) throws Exception
	{
		setAbortable(false);

		int resultCount = 0;

		try
		{
			buffer.readLock();

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				if(s instanceof Selection.Rect)
				{
					for(int j = s.getStartLine();
						j <= s.getEndLine(); j++)
					{
						resultCount += doHyperSearch(buffer,
							s.getStart(buffer,j),
							s.getEnd(buffer,j));
					}
				}
				else
				{
					resultCount += doHyperSearch(buffer,
						s.getStart(),s.getEnd());
				}
			}
		}
		finally
		{
			buffer.readUnlock();
		}

		setAbortable(true);

		return resultCount;
	} 

	
	private int doHyperSearch(Buffer buffer)
		throws Exception
	{
		return doHyperSearch(buffer, 0, buffer.getLength());
	} 

	
	private int doHyperSearch(Buffer buffer, int start, int end)
		throws Exception
	{
		setAbortable(false);

		final DefaultMutableTreeNode bufferNode = new DefaultMutableTreeNode(
			buffer.getPath());

		int resultCount = doHyperSearch(buffer,start,end,bufferNode);

		if(resultCount != 0)
		{
			rootSearchNode.insert(bufferNode,rootSearchNode.getChildCount());
		}

		setAbortable(true);

		return resultCount;
	} 

	
	private int doHyperSearch(Buffer buffer, int start, int end,
		DefaultMutableTreeNode bufferNode)
	{
		int resultCount = 0;

		try
		{
			buffer.readLock();

			boolean endOfLine = (buffer.getLineEndOffset(
				buffer.getLineOfOffset(end)) - 1 == end);

			Segment text = new Segment();
			int offset = start;
			int line = -1;

loop:			for(int counter = 0; ; counter++)
			{
				boolean startOfLine = (buffer.getLineStartOffset(
					buffer.getLineOfOffset(offset)) == offset);

				buffer.getText(offset,end - offset,text);
				int[] match = matcher.nextMatch(
					new CharIndexedSegment(text,false),
					startOfLine,endOfLine,counter == 0,
					false);
				if(match == null)
					break loop;

				int matchStart = offset + match[0];
				int matchEnd = offset + match[1];

				offset += match[1];

				int newLine = buffer.getLineOfOffset(offset);
				if(line == newLine)
				{
					
					
					continue loop;
				}

				line = newLine;

				resultCount++;

				bufferNode.add(new DefaultMutableTreeNode(
					new HyperSearchResult(buffer,line,
					matchStart,matchEnd),false));
			}
		}
		finally
		{
			buffer.readUnlock();
		}

		return resultCount;
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.textarea.ExtensionManager,7,1,0,5,19,0,2,3,0,0.0,204,1.0,0,0.0,0.535714286,0,0,28.0,3,2.1429,1,"

package org.gjt.sp.jedit.textarea;

import java.awt.Graphics2D;
import java.util.ArrayList;
import org.gjt.sp.util.Log;

class ExtensionManager
{
	
	void addExtension(int layer, TextAreaExtension ext)
	{
		Entry entry = new Entry(layer,ext);

		for(int i = 0; i < extensions.size(); i++)
		{
			int _layer = ((Entry)extensions.get(i)).layer;
			if(layer < _layer)
			{
				extensions.add(i,entry);
				return;
			}
		}

		extensions.add(entry);
	} 

	
	void removeExtension(TextAreaExtension ext)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			Entry entry = (Entry)extensions.get(i);
			if(entry.ext == ext)
			{
				extensions.remove(i);
				return;
			}
		}
	} 

	
	TextAreaExtension[] getExtensions()
	{
		TextAreaExtension[] retVal = new TextAreaExtension[
			extensions.size()];
		for(int i = 0; i < extensions.size(); i++)
		{
			retVal[i] = ((Entry)extensions.get(i)).ext;
		}
		return retVal;
	} 

	
	void paintValidLine(Graphics2D gfx, int screenLine,
		int physicalLine, int start, int end, int y)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			TextAreaExtension ext = ((Entry)extensions.get(i)).ext;
			try
			{
				ext.paintValidLine(gfx,screenLine,
					physicalLine,start,end,y);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);

				
				
				extensions.remove(i);
				i--;
			}
		}
	} 

	
	void paintInvalidLine(Graphics2D gfx, int screenLine,
		int y)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			TextAreaExtension ext = ((Entry)extensions.get(i)).ext;
			try
			{
				ext.paintInvalidLine(gfx,screenLine,y);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);

				
				
				extensions.remove(i);
				i--;
			}
		}
	} 

	
	String getToolTipText(int x, int y)
	{
		for(int i = 0; i < extensions.size(); i++)
		{
			TextAreaExtension ext = ((Entry)extensions.get(i)).ext;
			String toolTip = ext.getToolTipText(x,y);
			if(toolTip != null)
				return toolTip;
		}

		return null;
	} 

	
	private ArrayList extensions = new ArrayList();
	

	
	static class Entry
	{
		int layer;
		TextAreaExtension ext;

		Entry(int layer, TextAreaExtension ext)
		{
			this.layer = layer;
			this.ext = ext;
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.InputHandler,18,2,1,14,54,71,8,10,16,0.789915966,460,1.0,2,0.15,0.208333333,0,0,24.16666667,14,2.5556,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.JOptionPane;
import java.awt.event.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.*;



public abstract class InputHandler extends KeyAdapter
{
	
	
	public InputHandler(View view)
	{
		this.view = view;
	} 

	
	
	public void processKeyEvent(KeyEvent evt)
	{
		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			keyTyped(evt);
			break;
		case KeyEvent.KEY_PRESSED:
			keyPressed(evt);
			break;
		case KeyEvent.KEY_RELEASED:
			keyReleased(evt);
			break;
		}
	} 

	
	
	public abstract void addKeyBinding(String keyBinding, EditAction action);
	

	
	
	public abstract void removeKeyBinding(String keyBinding);
	

	
	
	public abstract void removeAllKeyBindings();
	

	
	
	public boolean isPrefixActive()
	{
		return false;
	} 

	
	
	public boolean isRepeatEnabled()
	{
		return repeat;
	} 

	
	
	public void setRepeatEnabled(boolean repeat)
	{
		boolean oldRepeat = this.repeat;
		this.repeat = repeat;
		repeatCount = 0;
		if(oldRepeat != repeat)
			view.getStatus().setMessage(null);
	} 

	
	
	public int getRepeatCount()
	{
		return (repeat && repeatCount > 0 ? repeatCount : 1);
	} 

	
	
	public void setRepeatCount(int repeatCount)
	{
		boolean oldRepeat = this.repeat;
		repeat = true;
		this.repeatCount = repeatCount;
		if(oldRepeat != repeat)
			view.getStatus().setMessage(null);
	} 

	
	
	public EditAction getLastAction()
	{
		return lastAction;
	} 

	
	
	public int getLastActionCount()
	{
		return lastActionCount;
	} 

	
	
	public void readNextChar(String msg, String code)
	{
		view.getStatus().setMessage(msg);
		readNextChar = code;
	} 

	
	
	public void readNextChar(String code)
	{
		readNextChar = code;
	} 

	
	
	public void resetLastActionCount()
	{
		lastAction = null;
		lastActionCount = 0;
	} 

	
	
	public void invokeAction(EditAction action)
	{
		Buffer buffer = view.getBuffer();

		

		
		if(lastAction == action)
			lastActionCount++;
		else
		{
			lastAction = action;
			lastActionCount = 1;
		}

		
		boolean _repeat = repeat;
		int _repeatCount = getRepeatCount();

		
		if(action.noRepeat() || _repeatCount == 1)
			action.invoke(view);
		else
		{
			
			if(_repeatCount > REPEAT_COUNT_THRESHOLD)
			{
				String label = action.getLabel();
				if(label == null)
					label = action.getName();
				else
					label = GUIUtilities.prettifyMenuLabel(label);

				Object[] pp = { label, new Integer(_repeatCount) };

				if(GUIUtilities.confirm(view,""large-repeat-count"",pp,
					JOptionPane.WARNING_MESSAGE,
					JOptionPane.YES_NO_OPTION)
					!= JOptionPane.YES_OPTION)
				{
					repeat = false;
					repeatCount = 0;
					view.getStatus().setMessage(null);
					return;
				}
			}

			try
			{
				buffer.beginCompoundEdit();

				for(int i = 0; i < _repeatCount; i++)
					action.invoke(view);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}

		Macros.Recorder recorder = view.getMacroRecorder();

		if(recorder != null && !action.noRecord())
			recorder.record(_repeatCount,action.getCode());

		
		
		if(_repeat)
		{
			
			
			if(readNextChar != null)
				return;

			repeat = false;
			repeatCount = 0;
			view.getStatus().setMessage(null);
		}
	} 

	
	private static final int REPEAT_COUNT_THRESHOLD = 20;

	
	protected View view;
	protected boolean repeat;
	protected int repeatCount;

	protected EditAction lastAction;
	protected int lastActionCount;

	protected String readNextChar;
	

	
	protected void userInput(char ch)
	{
		lastAction = null;

		if(readNextChar != null)
			invokeReadNextChar(ch);
		else
		{
			JEditTextArea textArea = view.getTextArea();

			

			int _repeatCount = getRepeatCount();
			if(_repeatCount == 1)
				textArea.userInput(ch);
			else
			{
				
				if(_repeatCount > REPEAT_COUNT_THRESHOLD)
				{
					Object[] pp = { String.valueOf(ch),
						new Integer(_repeatCount) };

					if(GUIUtilities.confirm(view,
						""large-repeat-count.user-input"",pp,
						JOptionPane.WARNING_MESSAGE,
						JOptionPane.YES_NO_OPTION)
						!= JOptionPane.YES_OPTION)
					{
						repeat = false;
						repeatCount = 0;
						view.getStatus().setMessage(null);
						return;
					}
				}

				for(int i = 0; i < _repeatCount; i++)
					textArea.userInput(ch);
			}

			Macros.Recorder recorder = view.getMacroRecorder();

			if(recorder != null)
				recorder.record(_repeatCount,ch);
		}

		setRepeatEnabled(false);
	} 

	
	protected void invokeReadNextChar(char ch)
	{
		Buffer buffer = view.getBuffer();

		

		String charStr = MiscUtilities.charsToEscapes(String.valueOf(ch));

		
		int index;
		while((index = readNextChar.indexOf(""__char__"")) != -1)
		{
			readNextChar = readNextChar.substring(0,index)
				+ '\'' + charStr + '\''
				+ readNextChar.substring(index + 8);
		}

		Macros.Recorder recorder = view.getMacroRecorder();
		if(recorder != null)
			recorder.record(getRepeatCount(),readNextChar);

		if(getRepeatCount() != 1)
		{
			try
			{
				buffer.beginCompoundEdit();

				BeanShell.eval(view,BeanShell.getNameSpace(),
					""for(int i = 1; i < ""
					+ getRepeatCount() + ""; i++)\n{\n""
					+ readNextChar + ""\n}"");
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
		else
			BeanShell.eval(view,BeanShell.getNameSpace(),readNextChar);

		readNextChar = null;

		view.getStatus().setMessage(null);
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.pluginmgr.Roster,6,1,0,9,16,0,8,2,1,0.0,89,1.0,0,0.0,0.375,0,0,13.66666667,4,1.8333,1,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.SwingUtilities;
import java.io.*;
import java.net.*;
import java.util.zip.*;
import java.util.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


class Roster
{
	
	Roster()
	{
		operations = new Vector();
	} 

	
	void addOperation(Operation op)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			if(operations.elementAt(i).equals(op))
				return;
		}

		operations.addElement(op);
	} 

	
	public Operation getOperation(int i)
	{
		return (Operation)operations.get(i);
	} 

	
	int getOperationCount()
	{
		return operations.size();
	} 

	
	boolean isEmpty()
	{
		return operations.size() == 0;
	} 

	
	boolean performOperations(PluginManagerProgress progress)
	{
		for(int i = 0; i < operations.size(); i++)
		{
			Operation op = (Operation)operations.elementAt(i);
			if(op.perform(progress))
				progress.done(true);
			else
			{
				progress.done(false);
				return false;
			}

			if(Thread.interrupted())
				return false;
		}

		return true;
	} 

	
	private Vector operations;
	

	static interface Operation
	{
		boolean perform(PluginManagerProgress progress);
		boolean equals(Object o);
		int getMaximum();
	}

	
	static class Remove implements Operation
	{
		Remove(String plugin)
		{
			this.plugin = plugin;
		}

		public int getMaximum()
		{
			return 1;
		}

		public boolean perform(PluginManagerProgress progress)
		{
			progress.removing(MiscUtilities.getFileName(plugin));

			
			EditPlugin.JAR jar = jEdit.getPluginJAR(plugin);
			if(jar != null)
				jar.getClassLoader().closeZipFile();

			
			File jarFile = new File(plugin);
			File srcFile = new File(plugin.substring(0,plugin.length() - 4));

			boolean ok = true;
			Log.log(Log.NOTICE,this,""Deleting "" + jarFile + "" recursively"");

			ok &= jarFile.delete();

			if(srcFile.exists())
				ok &= deleteRecursively(srcFile);

			String[] args = { plugin };
			if(!ok)
				GUIUtilities.error(progress,""plugin-manager.remove-failed"",args);
			return ok;
		}

		public boolean equals(Object o)
		{
			if(o instanceof Remove
				&& ((Remove)o).plugin.equals(plugin))
				return true;
			else
				return false;
		}

		
		private String plugin;

		private boolean deleteRecursively(File file)
		{
			Log.log(Log.NOTICE,this,""Deleting "" + file + "" recursively"");

			boolean ok = true;

			if(file.isDirectory())
			{
				String path = file.getPath();
				String[] children = file.list();
				for(int i = 0; i < children.length; i++)
				{
					ok &= deleteRecursively(new File(path,children[i]));
				}
			}

			ok &= file.delete();

			return ok;
		}
	} 

	
	static class Install implements Operation
	{
		int size;

		Install(String url, String installDirectory, int size)
		{
			
			if(url == null)
				throw new NullPointerException();

			this.url = url;
			this.installDirectory = installDirectory;
			this.size = size;
		}

		public int getMaximum()
		{
			return size;
		}

		public boolean perform(final PluginManagerProgress progress)
		{
			try
			{
				String fileName = MiscUtilities.getFileName(url);
				progress.downloading(fileName);
				String path = download(progress,fileName,url);
				if(path == null)
				{
					
					return false;
				}

				progress.installing(fileName);
				install(progress,path,installDirectory);

				return true;
			}
			catch(InterruptedIOException iio)
			{
				
				return false;
			}
			catch(final IOException io)
			{
				Log.log(Log.ERROR,this,io);

				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						String[] args = { io.getMessage() };
						GUIUtilities.error(null,""ioerror"",args);
					}
				});

				return false;
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);

				return false;
			}
		}

		public boolean equals(Object o)
		{
			if(o instanceof Install
				&& ((Install)o).url.equals(url))
			{
				
				return true;
			}
			else
				return false;
		}

		
		private String url;
		private String installDirectory;

		private String download(PluginManagerProgress progress,
			String fileName, String url) throws Exception
		{
			URLConnection conn = new URL(url).openConnection();

			String path = MiscUtilities.constructPath(getDownloadDir(),fileName);

			if(!copy(progress,conn.getInputStream(),
				new FileOutputStream(path),true,true))
				return null;

			return path;
		}

		private boolean install(PluginManagerProgress progress,
			String path, String dir) throws Exception
		{
			ZipFile zipFile = new ZipFile(path);

			try
			{
				Enumeration enum = zipFile.entries();
				while(enum.hasMoreElements())
				{
					ZipEntry entry = (ZipEntry)enum.nextElement();
					String name = entry.getName().replace('/',File.separatorChar);
					File file = new File(dir,name);
					if(entry.isDirectory())
						file.mkdirs();
					else
					{
						new File(file.getParent()).mkdirs();
						copy(progress,zipFile.getInputStream(entry),
							new FileOutputStream(file),false,false);
					}
				}
			}
			finally
			{
				zipFile.close();
				new File(path).delete();
			}

			progress.setValue(1);

			return true;
		}

		private boolean copy(PluginManagerProgress progress,
			InputStream in, OutputStream out, boolean canStop,
			boolean doProgress) throws Exception
		{
			in = new BufferedInputStream(in);
			out = new BufferedOutputStream(out);

			byte[] buf = new byte[4096];
			int copied = 0;
loop:			for(;;)
			{
				int count = in.read(buf,0,buf.length);
				if(count == -1)
					break loop;

				if(doProgress)
				{
					copied += count;
					progress.setValue(copied);
				}

				out.write(buf,0,count);
				if(canStop && Thread.interrupted())
				{
					in.close();
					out.close();
					return false;
				}
			}

			in.close();
			out.close();
			return true;
		}

		static File downloadDir;

		static String getDownloadDir()
		{
			if(downloadDir == null)
			{
				String settings = jEdit.getSettingsDirectory();
				if(settings == null)
					settings = System.getProperty(""user.home"");
				downloadDir = new File(MiscUtilities.constructPath(
					settings,""PluginManager.download""));
				downloadDir.mkdirs();
			}

			return downloadDir.getPath();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.search.HyperSearchResults,17,5,0,25,77,60,14,20,10,0.794642857,429,0.857142857,1,0.976083707,0.235294118,3,12,23.82352941,9,1.8824,3,"

package org.gjt.sp.jedit.search;


import javax.swing.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;



public class HyperSearchResults extends JPanel implements EBComponent
{
	public static final String NAME = ""hypersearch-results"";

	
	public HyperSearchResults(View view)
	{
		super(new BorderLayout());

		this.view = view;

		caption = new JLabel();

		JPanel topPanel = new JPanel(new BorderLayout());
		topPanel.add(BorderLayout.CENTER,caption);
		multi = new JCheckBox(jEdit.getProperty(""hypersearch-results.multi""));
		topPanel.add(BorderLayout.EAST,multi);
		multi.addActionListener(new ActionHandler());
		add(BorderLayout.NORTH, topPanel);

		resultTreeRoot = new DefaultMutableTreeNode();
		resultTreeModel = new DefaultTreeModel(resultTreeRoot);
		resultTree = new JTree(resultTreeModel);
		resultTree.setCellRenderer(new ResultCellRenderer());
		resultTree.setVisibleRowCount(16);
		resultTree.setRootVisible(false);
		resultTree.setShowsRootHandles(true);

		
		if(!OperatingSystem.isMacOSLF())
			resultTree.putClientProperty(""JTree.lineStyle"", ""Angled"");

		resultTree.setEditable(false);

		resultTree.addKeyListener(new KeyHandler());
		resultTree.addMouseListener(new MouseHandler());

		JScrollPane scrollPane = new JScrollPane(resultTree);
		Dimension dim = scrollPane.getPreferredSize();
		dim.width = 400;
		scrollPane.setPreferredSize(dim);
		add(BorderLayout.CENTER, scrollPane);
	} 

	
	public boolean requestDefaultFocus()
	{
		resultTree.grabFocus();
		return true;
	} 

	
	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
		multi.setSelected(jEdit.getBooleanProperty(""hypersearch-results.multi-toggle""));
	} 

	
	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
		jEdit.setBooleanProperty(""hypersearch-results.multi-toggle"",multi.isSelected());
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof BufferUpdate)
		{
			BufferUpdate bmsg = (BufferUpdate)msg;
			Buffer buffer = bmsg.getBuffer();
			Object what = bmsg.getWhat();
			if(what == BufferUpdate.LOADED ||
				what == BufferUpdate.CLOSED)
			{
				ResultVisitor visitor = null;
				if (what == BufferUpdate.LOADED)
				{
					visitor = new BufferLoadedVisitor();
				}
				else 
				{
					visitor = new BufferClosedVisitor();
				}
				
				
				for(int i = resultTreeRoot.getChildCount() - 1; i >= 0; i--)
				{
					DefaultMutableTreeNode searchNode = (DefaultMutableTreeNode)
						resultTreeRoot.getChildAt(i);
					for(int j = searchNode.getChildCount() - 1;
						j >= 0; j--)
					{

						DefaultMutableTreeNode bufferNode = (DefaultMutableTreeNode)
							searchNode.getChildAt(j);

						for(int k = bufferNode.getChildCount() - 1;
							k >= 0; k--)
						{
							Object userObject =
								((DefaultMutableTreeNode)bufferNode
								.getChildAt(k)).getUserObject();
							HyperSearchResult result = (HyperSearchResult)
									userObject;

							if(buffer.getPath().equals(result.path))
								visitor.visit(buffer,result);
						}
					}
				}
			}
		}
	} 

	
	public DefaultTreeModel getTreeModel()
	{
		return resultTreeModel;
	} 

	
	
	public JTree getTree()
	{
		return resultTree;
	} 

	
	public void searchStarted()
	{
		caption.setText(jEdit.getProperty(""hypersearch-results.searching""));
	} 

	
	public void searchFailed()
	{
		caption.setText(jEdit.getProperty(""hypersearch-results.no-results""));

		
		for(int i = 0; i < resultTreeRoot.getChildCount(); i++)
		{
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)
				resultTreeRoot.getChildAt(i);
			resultTree.collapsePath(new TreePath(new Object[] {
				resultTreeRoot, node }));
		}
	} 

	
	public void searchDone(final DefaultMutableTreeNode searchNode)
	{
		final int nodeCount = searchNode.getChildCount();
		if (nodeCount < 1)
		{
			searchFailed();
			return;
		}

		caption.setText(jEdit.getProperty(""hypersearch-results.done""));

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(!multi.isSelected())
				{
					for(int i = 0; i < resultTreeRoot.getChildCount(); i++)
					{
						resultTreeRoot.remove(0);
					}
				}

				resultTreeRoot.add(searchNode);
				resultTreeModel.reload(resultTreeRoot);

				TreePath lastNode = null;

				for(int i = 0; i < nodeCount; i++)
				{
					lastNode = new TreePath(
						((DefaultMutableTreeNode)
						searchNode.getChildAt(i))
						.getPath());

					resultTree.expandPath(lastNode);
				}

				resultTree.scrollPathToVisible(
					new TreePath(new Object[] {
					resultTreeRoot,searchNode }));
			}
		});
	} 

	
	private View view;

	private JLabel caption;
	private JTree resultTree;
	private DefaultMutableTreeNode resultTreeRoot;
	private DefaultTreeModel resultTreeModel;

	private JCheckBox multi;

	
	private void goToSelectedNode()
	{
		TreePath path = resultTree.getSelectionPath();
		if(path == null)
			return;

		DefaultMutableTreeNode node = (DefaultMutableTreeNode)path
			.getLastPathComponent();
		Object value = node.getUserObject();

		if(node.getParent() == resultTreeRoot)
		{
			
		}
		else if(value instanceof String)
		{
			Buffer buffer = jEdit.openFile(view,(String)value);
			if(buffer == null)
				return;

			view.setBuffer(buffer);

			
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					resultTree.requestFocus();
				}
			});
		}
		else if (value instanceof HyperSearchResult)
		{
			final HyperSearchResult result = (HyperSearchResult)value;
			final Buffer buffer = result.getBuffer();

			if(buffer == null)
				return;

			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					int start = result.startPos.getOffset();
					int end = result.endPos.getOffset();
					Selection s = new Selection.Range(start,end);
					view.setBuffer(buffer);
					JEditTextArea textArea = view.getTextArea();
					if(textArea.isMultipleSelectionEnabled())
						textArea.addToSelection(s);
					else
						textArea.setSelection(s);

					textArea.moveCaretPosition(end);
				}
			});
		}
	} 

	

	
	public class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(!multi.isSelected())
			{
				for(int i = resultTreeRoot.getChildCount() - 2; i >= 0; i--)
				{
					resultTreeModel.removeNodeFromParent(
						(MutableTreeNode)resultTreeRoot
						.getChildAt(i));
				}
			}
		}
	} 

	
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ENTER)
			{
				goToSelectedNode();

				
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						resultTree.requestFocus();
					}
				});

				evt.consume();
			}
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		
		public void mousePressed(MouseEvent evt)
		{
			if(evt.isConsumed())
				return;

			TreePath path1 = resultTree.getPathForLocation(
				evt.getX(),evt.getY());
			if(path1 == null)
				return;

			resultTree.setSelectionPath(path1);
			if (GUIUtilities.isPopupTrigger(evt))
				showPopupMenu(evt);
			else
			{
				goToSelectedNode();

				view.toFront();
				view.requestFocus();
				view.getTextArea().requestFocus();
			}
		} 

		
		private JPopupMenu popupMenu;

		
		private void showPopupMenu(MouseEvent evt)
		{
			if (popupMenu == null)
			{
				popupMenu = new JPopupMenu();
				popupMenu.add(new RemoveTreeNodeAction());
			}

			GUIUtilities.showPopupMenu(popupMenu,evt.getComponent(),
				evt.getX(),evt.getY());
			evt.consume();
		} 

		
	} 

	
	class RemoveTreeNodeAction extends AbstractAction
	{
		public RemoveTreeNodeAction()
		{
			super(jEdit.getProperty(""hypersearch-results.remove-node""));
		}

		public void actionPerformed(ActionEvent evt)
		{
			TreePath path = resultTree.getSelectionPath();
			if(path == null)
				return;

			MutableTreeNode value = (MutableTreeNode)path
				.getLastPathComponent();
			resultTreeModel.removeNodeFromParent(value);
		}
	}

	
	class ResultCellRenderer extends DefaultTreeCellRenderer
	{
		Font plainFont, boldFont;

		
		ResultCellRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			boldFont = new Font(plainFont.getName(),Font.BOLD,
				plainFont.getSize());
		} 

		
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean sel, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			Component comp = super.getTreeCellRendererComponent(tree,value,sel,
				expanded,leaf,row,hasFocus);
			setIcon(null);
			DefaultMutableTreeNode node = (DefaultMutableTreeNode)value;

			if (node.getParent() == resultTreeRoot)
			{
				ResultCellRenderer.this.setFont(boldFont);
				int bufferCount = node.getChildCount();
				int resultCount = 0;
				for (int i = 0; i < bufferCount; i++)
				{
					resultCount += node.getChildAt(i).getChildCount();
				}
				Object[] pp = { node.toString(), new Integer(resultCount), new Integer(bufferCount) };
				setText(jEdit.getProperty(""hypersearch-results.result-caption"",pp));
			}
			else if(node.getUserObject() instanceof String)
			{
				
				ResultCellRenderer.this.setFont(boldFont);
				int count = node.getChildCount();
				if(count == 1)
				{
					setText(jEdit.getProperty(""hypersearch-results""
						+ "".file-caption1"",new Object[] {
						node.getUserObject()
						}));
				}
				else
				{
					setText(jEdit.getProperty(""hypersearch-results""
						+ "".file-caption"",new Object[] {
						node.getUserObject(),
						new Integer(count)
						}));
				}
			}
			else
			{
				ResultCellRenderer.this.setFont(plainFont);
			}

			return this;
		} 
	} 

	
	
	

	
	interface ResultVisitor
	{
		public void visit(Buffer buffer, HyperSearchResult result);
	} 

	
	class BufferLoadedVisitor implements ResultVisitor
	{
		public void visit(Buffer buffer, HyperSearchResult result)
		{
			result.bufferOpened(buffer);
		}
	} 

	
	class BufferClosedVisitor implements ResultVisitor
	{
		public void visit(Buffer buffer, HyperSearchResult result)
		{
			result.bufferClosed();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.MacrosMenu,7,8,0,11,31,21,1,11,5,2.0,157,0.0,0,0.993055556,0.314285714,1,7,21.42857143,6,2.2857,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.*;
import java.util.Collections;
import java.util.Vector;
import org.gjt.sp.jedit.msg.MacrosChanged;
import org.gjt.sp.jedit.*;

public class MacrosMenu extends EnhancedMenu implements EBComponent
{
	public MacrosMenu()
	{
		super(""macros"");
		updateMacrosMenu();
	}

	public void addNotify()
	{
		super.addNotify();
		EditBus.addToBus(this);
	}

	public void removeNotify()
	{
		super.removeNotify();
		EditBus.removeFromBus(this);
	}

	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof MacrosChanged)
			updateMacrosMenu();
	}

	public void init()
	{
		super.init();
		updateMacrosMenu();
	}

	private void updateMacrosMenu()
	{
		if(!initialized)
			return;

		
		
		
		for(int i = getMenuComponentCount() - 1; i >= 0; i--)
		{
			if(getMenuComponent(i) instanceof JSeparator)
				break;
			else
				remove(i);
		}

		int count = getMenuComponentCount();

		Vector macroVector = Macros.getMacroHierarchy();
		createMacrosMenu(this,macroVector,0);

		if(count == getMenuComponentCount())
			add(GUIUtilities.loadMenuItem(""no-macros""));
	}

	private void createMacrosMenu(JMenu menu, Vector vector, int start)
	{
		Vector menuItems = new Vector();

		for(int i = start; i < vector.size(); i++)
		{
			Object obj = vector.elementAt(i);
			if(obj instanceof Macros.Macro)
			{
				Macros.Macro macro = (Macros.Macro)obj;
				menuItems.add(new EnhancedMenuItem(macro.getLabel(),macro));
			}
			else if(obj instanceof Vector)
			{
				Vector subvector = (Vector)obj;
				String name = (String)subvector.elementAt(0);
				JMenu submenu = new JMenu(name);
				createMacrosMenu(submenu,subvector,1);
				if(submenu.getMenuComponentCount() != 0)
					menuItems.add(submenu);
			}
		}

		Collections.sort(menuItems,new MiscUtilities.MenuItemCompare());
		for(int i = 0; i < menuItems.size(); i++)
		{
			menu.add((JMenuItem)menuItems.get(i));
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.io.FavoritesVFS,10,2,0,6,30,1,4,4,9,0.694444444,246,0.75,1,0.829787234,0.444444444,1,1,23.2,3,1.6,0,"

package org.gjt.sp.jedit.io;


import java.awt.Component;
import java.util.ArrayList;
import org.gjt.sp.jedit.jEdit;



public class FavoritesVFS extends VFS
{
	public static final String PROTOCOL = ""favorites"";

	
	public FavoritesVFS()
	{
		
		
		super(""favorites"",DELETE_CAP | LOW_LATENCY_CAP);

		
		instance = this;
	} 

	
	public String getParentOfPath(String path)
	{
		return PROTOCOL + "":"";
	} 

	
	public VFS.DirectoryEntry[] _listDirectory(Object session, String url,
		Component comp)
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();

			VFS.DirectoryEntry[] retVal = new VFS.DirectoryEntry[favorites.size()];
			for(int i = 0; i < retVal.length; i++)
			{
				String favorite = (String)favorites.get(i);
				retVal[i] = _getDirectoryEntry(session,favorite,comp);
			}
			return retVal;
		}
	} 

	
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		return new VFS.DirectoryEntry(path,path,""favorites:"" + path,
					VFS.DirectoryEntry.DIRECTORY,
					0L,false);
	} 

	
	public boolean _delete(Object session, String path, Component comp)
	{
		synchronized(lock)
		{
			path = path.substring(PROTOCOL.length() + 1);
			favorites.remove(path);

			VFSManager.sendVFSUpdate(this,PROTOCOL + "":"",false);
		}

		return true;
	} 

	
	public static void loadFavorites()
	{
		favorites = new ArrayList();

		synchronized(lock)
		{
			String favorite;
			int i = 0;
			while((favorite = jEdit.getProperty(""vfs.favorite."" + i)) != null)
			{
				favorites.add(favorite);
				i++;
			}
		}
	} 

	
	public static void addToFavorites(String path)
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();

			if(!favorites.contains(path))
				favorites.add(path);

			VFSManager.sendVFSUpdate(instance,PROTOCOL + "":"",false);
		}
	} 

	
	public static void saveFavorites()
	{
		synchronized(lock)
		{
			if(favorites == null)
				return;

			for(int i = 0; i < favorites.size(); i++)
			{
				jEdit.setProperty(""vfs.favorite."" + i,
					(String)favorites.get(i));
			}
			jEdit.unsetProperty(""vfs.favorite."" + favorites.size());
		}
	} 

	
	public static Object[] getFavorites()
	{
		synchronized(lock)
		{
			if(favorites == null)
				loadFavorites();

			return favorites.toArray();
		}
	} 

	
	private static FavoritesVFS instance;
	private static Object lock = new Object();
	private static ArrayList favorites;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.ModeCatalogHandler,6,2,0,5,25,3,1,5,4,0.771428571,215,0.857142857,0,0.722222222,0.722222222,1,3,33.66666667,7,3.0,0,"

package org.gjt.sp.jedit;

import com.microstar.xml.*;
import java.io.*;
import org.gjt.sp.util.Log;

class ModeCatalogHandler extends HandlerBase
{
	ModeCatalogHandler(String directory, boolean resource)
	{
		this.directory = directory;
		this.resource = resource;
	}

	public Object resolveEntity(String publicId, String systemId)
	{
		if(""catalog.dtd"".equals(systemId))
		{
			
			
			
			return new StringReader(""<!-- -->"");

			
		}

		return null;
	}

	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();

		if(aname == ""NAME"")
			modeName = value;
		else if(aname == ""FILE"")
		{
			if(value == null)
			{
				Log.log(Log.ERROR,this,directory + ""catalog:""
					+ "" mode "" + modeName + "" doesn't have""
					+ "" a FILE attribute"");
			}
			else
				file = value;
		}
		else if(aname == ""FILE_NAME_GLOB"")
			filenameGlob = value;
		else if(aname == ""FIRST_LINE_GLOB"")
			firstlineGlob = value;
	}

	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		
		
		

		
		
		
		if(""CATALOG"".equals(name) || ""MODES"".equals(name))
			return;

		Log.log(Log.ERROR,this,directory + ""catalog: DOCTYPE must be CATALOG"");
	}

	public void endElement(String name)
	{
		if(name.equals(""MODE""))
		{
			Mode mode = jEdit.getMode(modeName);
			if(mode == null)
			{
				mode = new Mode(modeName);
				jEdit.addMode(mode);
			}

			Object path;
			if(resource)
				path = jEdit.class.getResource(directory + file);
			else
				path = MiscUtilities.constructPath(directory,file);
			mode.setProperty(""file"",path);

			if(filenameGlob != null)
				mode.setProperty(""filenameGlob"",filenameGlob);
			else
				mode.unsetProperty(""filenameGlob"");

			if(firstlineGlob != null)
				mode.setProperty(""firstlineGlob"",firstlineGlob);
			else
				mode.unsetProperty(""firstlineGlob"");

			mode.init();

			modeName = file = filenameGlob = firstlineGlob = null;
		}
	}

	

	
	private String directory;
	private boolean resource;

	private String modeName;
	private String file;
	private String filenameGlob;
	private String firstlineGlob;
}
"
jEdit,4.1,org.gjt.sp.jedit.EBPlugin,2,2,0,6,9,1,1,5,1,2.0,24,0.0,0,0.954545455,0.75,0,0,11.0,1,0.5,0,"

package org.gjt.sp.jedit;

import org.gjt.sp.util.Log;


public abstract class EBPlugin extends EditPlugin implements EBComponent
{
	
	
	public void handleMessage(EBMessage message)
	{
		Log.log(Log.WARNING,this,getClassName() + "" should extend""
			+ "" EditPlugin not EBPlugin since it has an empty""
			+ "" handleMessage()"");
		EditBus.removeFromBus(this);
	}

	
	protected EBPlugin() {}
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.JCheckBoxList,10,5,0,7,42,43,4,5,9,0.666666667,219,1.0,0,0.990654206,0.375,1,1,20.8,4,1.6,0,"

package org.gjt.sp.jedit.gui;


import java.awt.Component;
import java.awt.Font;
import java.util.Vector;
import javax.swing.*;
import javax.swing.table.*;



public class JCheckBoxList extends JTable
{
	
	
	public JCheckBoxList(Object[] items)
	{
		setModel(items);
	} 

	
	
	public JCheckBoxList(Vector items)
	{
		setModel(items);
	} 

	
	
	public void setModel(Object[] items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	} 

	
	
	public void setModel(Vector items)
	{
		setModel(new CheckBoxListModel(items));
		init();
	} 

	
	public Object[] getCheckedValues()
	{
		Vector values = new Vector();
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		for(int i = 0; i < model.items.size(); i++)
		{
			Entry entry = (Entry)model.items.elementAt(i);
			if(entry.checked && !entry.caption)
				values.addElement(entry.value);
		}

		Object[] retVal = new Object[values.size()];
		values.copyInto(retVal);
		return retVal;
	} 

	
	public void selectAll()
	{
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		for(int i = 0; i < model.items.size(); i++)
		{
			Entry entry = (Entry)model.items.elementAt(i);
			if(!entry.caption)
				entry.checked = true;
		}

		model.fireTableRowsUpdated(0,model.getRowCount());
	} 

	
	public Entry[] getValues()
	{
		CheckBoxListModel model = (CheckBoxListModel)getModel();
		Entry[] retVal = new Entry[model.items.size()];
		model.items.copyInto(retVal);
		return retVal;
	} 

	
	public Object getSelectedValue()
	{
		int row = getSelectedRow();
		if(row == -1)
			return null;
		else
			return getModel().getValueAt(row,1);
	} 

	
	public TableCellRenderer getCellRenderer(int row, int column)
	{
		if(column == 0)
		{
			Entry entry = (Entry)((CheckBoxListModel)getModel()).items.get(row);
			if(entry.caption)
				return dummy;
		}

		return super.getCellRenderer(row,column);
	} 

	
	private TableCellRenderer dummy;

	
	private void init()
	{
		dummy = new DummyRenderer();
		getSelectionModel().setSelectionMode(ListSelectionModel
			.SINGLE_SELECTION);
		setShowGrid(false);
		setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);
		TableColumn column = getColumnModel().getColumn(0);
		int checkBoxWidth = new JCheckBox().getPreferredSize().width;
		column.setPreferredWidth(checkBoxWidth);
		column.setMinWidth(checkBoxWidth);
		column.setWidth(checkBoxWidth);
		column.setMaxWidth(checkBoxWidth);
		column.setResizable(false);

		column = getColumnModel().getColumn(1);
		column.setCellRenderer(new LabelRenderer());
	} 

	

	
	
	public static class Entry
	{
		boolean checked;
		boolean caption;
		Object value;

		public Entry(Object value)
		{
			this.caption = true;
			this.value = value;
		}

		public Entry(boolean checked, Object value)
		{
			this.checked = checked;
			this.value = value;
		}

		public boolean isChecked()
		{
			return checked;
		}

		public Object getValue()
		{
			return value;
		}
	} 

	
	private class DummyRenderer extends DefaultTableCellRenderer
	{
		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			return super.getTableCellRendererComponent(table,null ,
				isSelected,false ,row,column);
		}
	} 

	
	private class LabelRenderer extends DefaultTableCellRenderer
	{
		Font plainFont, boldFont;

		LabelRenderer()
		{
			plainFont = UIManager.getFont(""Tree.font"");
			boldFont = plainFont.deriveFont(Font.BOLD);
		}

		public Component getTableCellRendererComponent(JTable table, Object value,
			boolean isSelected, boolean hasFocus, int row, int column)
		{
			super.getTableCellRendererComponent(table,value,isSelected,
				hasFocus,row,column);

			Entry entry = (Entry)((CheckBoxListModel)getModel()).items.get(row);
			if(entry.caption)
				setFont(boldFont);
			else
				setFont(plainFont);
			return this;
		}
	} 
}

class CheckBoxListModel extends AbstractTableModel
{
	Vector items;

	CheckBoxListModel(Vector _items)
	{
		items = new Vector(_items.size());
		for(int i = 0; i < _items.size(); i++)
		{
			items.addElement(createEntry(_items.elementAt(i)));
		}
	}

	CheckBoxListModel(Object[] _items)
	{
		items = new Vector(_items.length);
		for(int i = 0; i < _items.length; i++)
		{
			items.addElement(createEntry(_items[i]));
		}
	}

	private JCheckBoxList.Entry createEntry(Object obj)
	{
		if(obj instanceof JCheckBoxList.Entry)
			return (JCheckBoxList.Entry)obj;
		else
			return new JCheckBoxList.Entry(false,obj);
	}

	public int getRowCount()
	{
		return items.size();
	}

	public int getColumnCount()
	{
		return 2;
	}

	public String getColumnName(int col)
	{
		return null;
	}

	public Object getValueAt(int row, int col)
	{
		JCheckBoxList.Entry entry = (JCheckBoxList.Entry)items.elementAt(row);
		switch(col)
		{
		case 0:
			return new Boolean(entry.checked);
		case 1:
			return entry.value;
		default:
			throw new InternalError();
		}
	}

	public Class getColumnClass(int col)
	{
		switch(col)
		{
		case 0:
			return Boolean.class;
		case 1:
			return String.class;
		default:
			throw new InternalError();
		}
	}

	public boolean isCellEditable(int row, int col)
	{
		JCheckBoxList.Entry entry = (JCheckBoxList.Entry)items.elementAt(row);
		return col == 0 && !entry.caption;
	}

	public void setValueAt(Object value, int row, int col)
	{
		if(col == 0)
		{
			JCheckBoxList.Entry entry = (JCheckBoxList.Entry)items.elementAt(row);
			if(!entry.caption)
			{
				entry.checked = (value.equals(Boolean.TRUE));
				fireTableRowsUpdated(row,row);
			}
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.search.BoyerMooreSearchMatcher,7,1,0,7,20,0,1,6,4,0.736111111,392,1.0,2,0.0,0.404761905,0,0,53.28571429,11,4.2857,1,"

package org.gjt.sp.jedit.search;


import bsh.BshMethod;
import bsh.NameSpace;
import gnu.regexp.CharIndexed;
import org.gjt.sp.jedit.BeanShell;



public class BoyerMooreSearchMatcher implements SearchMatcher
{
	
	
	public BoyerMooreSearchMatcher(String pattern, String replace,
		boolean ignoreCase, boolean beanshell, BshMethod replaceMethod)
	{
		if (ignoreCase)
			this.pattern = pattern.toUpperCase().toCharArray();
		else
			this.pattern = pattern.toCharArray();

		this.replace = replace;
		this.ignoreCase = ignoreCase;

		if(beanshell && replaceMethod != null && replace.length() != 0)
		{
			this.beanshell = true;
			this.replaceMethod = replaceMethod;
			replaceNS = new NameSpace(BeanShell.getNameSpace(),
				""search and replace"");
		}

		pattern_end = this.pattern.length - 1;

		returnValue = new int[2];
	} 

	
	
	public int[] nextMatch(CharIndexed text, boolean start, boolean end,
		boolean firstTime, boolean reverse)
	{
		int pos = match(text,reverse);

		if (pos == -1)
		{
			return null;
		}
		else
		{
			returnValue[0] = pos;
			returnValue[1] = pos + pattern.length;
			return returnValue;
		}
	} 

	
	
	public String substitute(String text) throws Exception
	{
		if(beanshell)
		{
			replaceNS.setVariable(""_0"",text);
			Object obj = BeanShell.runCachedBlock(replaceMethod,
				null,replaceNS);
			if(obj == null)
				return """";
			else
				return obj.toString();
		}
		else
			return replace;
	} 

	
	
	public int match(CharIndexed text, boolean reverse)
	{
		
		
		
		int[] skip, suffix;
		if(reverse)
		{
			if(back_skip == null)
			{
				back_skip = generateSkipArray(true);
				back_suffix = generateSuffixArray(true);
			}
			skip = back_skip;
			suffix = back_suffix;
		}
		else
		{
			if(fwd_skip == null)
			{
				fwd_skip = generateSkipArray(false);
				fwd_suffix = generateSuffixArray(false);
			}
			skip = fwd_skip;
			suffix = fwd_suffix;
		} 

		
		int pos;

		
		int anchor = 0;

		
		
		
		
		
		

		char ch = 0;

		int bad_char;
		int good_suffix;

		
		
		
		
		
		
		
		
		
		
SEARCH:
		while (text.isValid())
		{
			for (pos = pattern_end; pos >= 0; --pos)
			{
				ch = text.charAt(pos);
				if(ignoreCase)
					ch = Character.toUpperCase(ch);

				
				if ((reverse ? ch != pattern[pattern_end - pos]
					: ch != pattern[pos]))
				{
					

					
					bad_char = pos - skip[getSkipIndex(ch)];

					
					good_suffix = suffix[pos];

					
					
					int skip_index = (bad_char > good_suffix) ? bad_char : good_suffix;
					anchor += skip_index;
					text.move(skip_index);

					
					continue SEARCH;
				}
			}

			
			return anchor;
		}

		
		return -1;
	} 

	
	private char[] pattern;
	private int pattern_end;
	private String replace;
	private boolean ignoreCase;
	private boolean beanshell;
	private BshMethod replaceMethod;
	private NameSpace replaceNS;

	
	private int[] fwd_skip;
	private int[] fwd_suffix;
	private int[] back_skip;
	private int[] back_suffix;

	private int[] returnValue;
	

	

	
	
	private int[] generateSkipArray(boolean reverse)
	{
		
		int[] skip = new int[256];

		
		if (pattern.length == 0)
			return skip;

		int pos = 0;

		do
		{
			skip[getSkipIndex(pattern[reverse ? pattern_end - pos : pos])] = pos;
		}
		while (++pos < pattern.length);

		return skip;
	} 

	
	
	private static final int getSkipIndex(char ch)
	{
		return ((int) ch) & 0x000000FF;
	} 

	
	
	private int[] generateSuffixArray(boolean reverse)
	{
		int m = pattern.length;

		int j = m + 1;

		int[] suffix = new int[j];
		int[] tmp = new int[j];
		tmp[m] = j;

		for (int i = m; i > 0; --i)
		{
			while (j <= m && pattern[reverse ? pattern_end - i + 1 : i - 1]
				!= pattern[reverse ? pattern_end - j + 1 : j - 1])
			{
				if (suffix[j] == 0)
				{
					suffix[j] = j - i;
				}

				j = tmp[j];
			}

			tmp[i - 1] = --j;
		}

		int k = tmp[0];

		for (j = 0; j <= m; j++)
		{
			
			
			
			if (j > 0)
			{
				suffix[j - 1] = (suffix[j] == 0) ? k : suffix[j];
			}

			if (j == k)
			{
				k = tmp[k];
			}
		}

		return suffix;
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.proto.jeditresource.PluginResURLConnection,5,2,0,5,29,2,1,4,4,0.5625,198,0.75,0,0.935483871,0.466666667,1,7,37.8,8,2.2,0,"

package org.gjt.sp.jedit.proto.jeditresource;


import java.io.*;
import java.net.*;
import org.gjt.sp.jedit.*;


public class PluginResURLConnection extends URLConnection
{
	public PluginResURLConnection(URL url)
		throws IOException
	{
		super(url);

		String file = url.getFile();

		int index = file.indexOf('!',0);
		if(index == -1)
		{
			plugin = null;
			resource = file;
		}
		else
		{
			int start;
			if(file.charAt(0) == '/')
				start = 1;
			else
				start = 0;

			plugin = file.substring(start,index);
			resource = file.substring(index + 1);
		}

		if(plugin != null && resource.startsWith(""/""))
			resource = resource.substring(1);
	}

	public void connect() throws IOException
	{
		if(!connected)
		{
			if(plugin == null)
			{
				in = jEdit.class.getResourceAsStream(resource);
			}
			else
			{
				EditPlugin.JAR[] plugins = jEdit.getPluginJARs();
				for(int i = 0; i < plugins.length; i++)
				{
					EditPlugin.JAR jar = plugins[i];
					if(MiscUtilities.getFileName(jar.getPath())
						.equalsIgnoreCase(plugin))
					{
						in = jar.getClassLoader()
							.getResourceAsStream(
							resource);
						break;
					}
				}
			}

			if(in == null)
			{
				throw new IOException(""Resource not found: ""
					+ resource);
			}

			connected = true;
		}
	}

	public InputStream getInputStream()
		throws IOException
	{
		connect();
		return in;
	}

	public String getHeaderField(String name)
	{
		if(name.equals(""content-type""))
		{
			String lcResource = resource.toLowerCase();
			if(lcResource.endsWith("".html""))
				return ""text/html"";
			else if(lcResource.endsWith("".txt""))
				return ""text/plain"";
			else if(lcResource.endsWith("".rtf""))
				return ""text/rtf"";
			else if(lcResource.endsWith("".gif""))
				return ""image/gif"";
			else if(lcResource.endsWith("".jpg"")
				|| lcResource.endsWith("".jpeg""))
				return ""image/jpeg"";
			else
				return null;
		}
		else
			return null;
	}

	
	private InputStream in;
	private String plugin;
	private String resource;
}
"
jEdit,4.1,org.gjt.sp.jedit.options.EditingOptionPane,12,6,0,7,44,26,3,6,1,0.449197861,650,1.0,3,0.983823529,0.5,1,3,51.75,3,1.3333,1,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.FoldHandler;


public class EditingOptionPane extends AbstractOptionPane
{
	
	public EditingOptionPane()
	{
		super(""editing"");
	} 

	
	protected void _init()
	{
		Mode[] modes = jEdit.getModes();

		defaultMode = new JComboBox(modes);
		defaultMode.setSelectedItem(jEdit.getMode(
			jEdit.getProperty(""buffer.defaultMode"")));
		addComponent(jEdit.getProperty(""options.editing.defaultMode""),
			defaultMode);

		undoCount = new JTextField(jEdit.getProperty(""buffer.undoCount""));
		addComponent(jEdit.getProperty(""options.editing.undoCount""),undoCount);

		addSeparator();

		global = new ModeProperties();
		modeProps = new ModeProperties[modes.length];

		String[] modeNames = new String[modes.length + 1];
		modeNames[0] = jEdit.getProperty(""options.editing.global"");

		for(int i = 0; i < modes.length; i++)
		{
			modeProps[i] = new ModeProperties(modes[i]);
			modeNames[i + 1] = modes[i].getName();
		}

		mode = new JComboBox(modeNames);
		mode.addActionListener(new ActionHandler());

		addComponent(jEdit.getProperty(""options.editing.mode""),mode);

		useDefaults = new JCheckBox(jEdit.getProperty(""options.editing.useDefaults""));
		useDefaults.addActionListener(new ActionHandler());
		addComponent(useDefaults);

		addComponent(jEdit.getProperty(""options.editing.noWordSep""),
			noWordSep = new JTextField());

		String[] foldModes = FoldHandler.getFoldModes();
		addComponent(jEdit.getProperty(""options.editing.folding""),
			folding = new JComboBox(foldModes));

		addComponent(jEdit.getProperty(""options.editing.collapseFolds""),
			collapseFolds = new JTextField());

		String[] wrapModes = {
			""none"",
			""soft"",
			""hard""
		};
		addComponent(jEdit.getProperty(""options.editing.wrap""),
			wrap = new JComboBox(wrapModes));

		String[] lineLens = { ""0"", ""72"", ""76"", ""80"" };
		addComponent(jEdit.getProperty(""options.editing.maxLineLen""),
			maxLineLen = new JComboBox(lineLens));
		maxLineLen.setEditable(true);

		String[] tabSizes = { ""2"", ""4"", ""8"" };
		addComponent(jEdit.getProperty(""options.editing.tabSize""),
			tabSize = new JComboBox(tabSizes));
		tabSize.setEditable(true);

		addComponent(jEdit.getProperty(""options.editing.indentSize""),
			indentSize = new JComboBox(tabSizes));
		indentSize.setEditable(true);

		addComponent(noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs"")));

		addComponent(jEdit.getProperty(""options.editing.filenameGlob""),
			filenameGlob = new JTextField());

		addComponent(jEdit.getProperty(""options.editing.firstlineGlob""),
			firstlineGlob = new JTextField());

		selectMode();
	} 

	
	protected void _save()
	{
		jEdit.setProperty(""buffer.defaultMode"",
			((Mode)defaultMode.getSelectedItem()).getName());
		jEdit.setProperty(""buffer.undoCount"",undoCount.getText());

		saveMode();

		global.save();

		for(int i = 0; i < modeProps.length; i++)
		{
			modeProps[i].save();
		}
	} 

	

	
	private JComboBox defaultMode;
	private JTextField undoCount;
	private ModeProperties global;
	private ModeProperties[] modeProps;
	private ModeProperties current;
	private JComboBox mode;
	private JCheckBox useDefaults;
	private JTextField filenameGlob;
	private JTextField firstlineGlob;
	private JTextField noWordSep;
	private JComboBox folding;
	private JTextField collapseFolds;
	private JComboBox wrap;
	private JComboBox maxLineLen;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JCheckBox noTabs;
	

	
	private void saveMode()
	{
		current.useDefaults = useDefaults.isSelected();
		current.filenameGlob = filenameGlob.getText();
		current.firstlineGlob = firstlineGlob.getText();
		current.noWordSep = noWordSep.getText();
		current.folding = (String)folding.getSelectedItem();
		current.collapseFolds = collapseFolds.getText();
		current.wrap = (String)wrap.getSelectedItem();
		current.maxLineLen = (String)maxLineLen.getSelectedItem();
		current.tabSize = (String)tabSize.getSelectedItem();
		current.indentSize = (String)indentSize.getSelectedItem();
		current.noTabs = noTabs.isSelected();
	} 

	
	private void selectMode()
	{
		int index = mode.getSelectedIndex();
		current = (index == 0 ? global : modeProps[index - 1]);
		current.edited = true;
		current.load();

		useDefaults.setSelected(current.useDefaults);
		filenameGlob.setText(current.filenameGlob);
		firstlineGlob.setText(current.firstlineGlob);
		noWordSep.setText(current.noWordSep);
		folding.setSelectedItem(current.folding);
		collapseFolds.setText(current.collapseFolds);
		wrap.setSelectedItem(current.wrap);
		maxLineLen.setSelectedItem(current.maxLineLen);
		tabSize.setSelectedItem(current.tabSize);
		indentSize.setSelectedItem(current.indentSize);
		noTabs.setSelected(current.noTabs);

		updateEnabled();
	} 

	
	private void updateEnabled()
	{
		if(current == global)
		{
			useDefaults.setEnabled(false);
			filenameGlob.setEnabled(false);
			firstlineGlob.setEnabled(false);
			noWordSep.setEnabled(true);
			folding.setEnabled(true);
			collapseFolds.setEnabled(true);
			wrap.setEnabled(true);
			maxLineLen.setEnabled(true);
			tabSize.setEnabled(true);
			indentSize.setEnabled(true);
			noTabs.setEnabled(true);
		}
		else
		{
			useDefaults.setEnabled(true);
			boolean enabled = !modeProps[mode.getSelectedIndex() - 1].useDefaults;
			filenameGlob.setEnabled(enabled);
			firstlineGlob.setEnabled(enabled);
			noWordSep.setEnabled(enabled);
			folding.setEnabled(enabled);
			collapseFolds.setEnabled(enabled);
			wrap.setEnabled(enabled);
			maxLineLen.setEnabled(enabled);
			tabSize.setEnabled(enabled);
			indentSize.setEnabled(enabled);
			noTabs.setEnabled(enabled);
		}
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == mode)
			{
				saveMode();
				selectMode();
			}
			else if(evt.getSource() == useDefaults)
			{
				modeProps[mode.getSelectedIndex() - 1].useDefaults =
					useDefaults.isSelected();
				updateEnabled();
			}
		}
	} 

	
	class ModeProperties
	{
		
		Mode mode;
		boolean edited;
		boolean loaded;

		boolean useDefaults;
		String filenameGlob;
		String firstlineGlob;
		String noWordSep;
		String folding;
		String collapseFolds;
		String wrap;
		String maxLineLen;
		String tabSize;
		String indentSize;
		boolean noTabs;
		

		
		ModeProperties()
		{
		} 

		
		ModeProperties(Mode mode)
		{
			this.mode = mode;
		} 

		
		void load()
		{
			if(loaded)
				return;

			loaded = true;

			if(mode != null)
			{
				mode.loadIfNecessary();

				useDefaults = !jEdit.getBooleanProperty(""mode.""
					+ mode.getName() + "".customSettings"");
				filenameGlob = (String)mode.getProperty(""filenameGlob"");
				firstlineGlob = (String)mode.getProperty(""firstlineGlob"");
				noWordSep = (String)mode.getProperty(""noWordSep"");
				folding = mode.getProperty(""folding"").toString();
				collapseFolds = mode.getProperty(""collapseFolds"").toString();
				wrap = mode.getProperty(""wrap"").toString();
				maxLineLen = mode.getProperty(""maxLineLen"").toString();
				tabSize = mode.getProperty(""tabSize"").toString();
				indentSize = mode.getProperty(""indentSize"").toString();
				noTabs = mode.getBooleanProperty(""noTabs"");
			}
			else
			{
				noWordSep = jEdit.getProperty(""buffer.noWordSep"");
				folding = jEdit.getProperty(""buffer.folding"");
				collapseFolds = jEdit.getProperty(""buffer.collapseFolds"");
				wrap = jEdit.getProperty(""buffer.wrap"");
				maxLineLen = jEdit.getProperty(""buffer.maxLineLen"");
				tabSize = jEdit.getProperty(""buffer.tabSize"");
				indentSize = jEdit.getProperty(""buffer.indentSize"");
				noTabs = jEdit.getBooleanProperty(""buffer.noTabs"");
			}
		} 

		
		void save()
		{
			
			
			if(!edited)
				return;

			String prefix;
			if(mode != null)
			{
				prefix = ""mode."" + mode.getName() + ""."";
				jEdit.setBooleanProperty(prefix + ""customSettings"",!useDefaults);

				
				
				String oldFilenameGlob = (String)mode.getProperty(""filenameGlob"");
				String oldFirstlineGlob = (String)mode.getProperty(""firstlineGlob"");
				if(useDefaults)
				{
					jEdit.resetProperty(prefix + ""filenameGlob"");
					jEdit.resetProperty(prefix + ""firstlineGlob"");
					jEdit.resetProperty(prefix + ""noWordSep"");
					jEdit.resetProperty(prefix + ""folding"");
					jEdit.resetProperty(prefix + ""collapseFolds"");
					jEdit.resetProperty(prefix + ""wrap"");
					jEdit.resetProperty(prefix + ""maxLineLen"");
					jEdit.resetProperty(prefix + ""tabSize"");
					jEdit.resetProperty(prefix + ""indentSize"");
					jEdit.resetProperty(prefix + ""noTabs"");
	
					if(!(MiscUtilities.stringsEqual(oldFilenameGlob,
						(String)mode.getProperty(""filenameGlob""))
						&& MiscUtilities.stringsEqual(oldFirstlineGlob,
						(String)mode.getProperty(""firstlineGlob""))))
					{
						mode.init();
					}

					return;
				}
				else
				{
					jEdit.setProperty(prefix + ""filenameGlob"",filenameGlob);
					jEdit.setProperty(prefix + ""firstlineGlob"",firstlineGlob);

					if(!(MiscUtilities.stringsEqual(oldFilenameGlob,
						filenameGlob)
						&& MiscUtilities.stringsEqual(oldFirstlineGlob,
						firstlineGlob)))
					{
						mode.init();
					}
				}
			}
			else
			{
				prefix = ""buffer."";
			}

			jEdit.setProperty(prefix + ""noWordSep"",noWordSep);
			jEdit.setProperty(prefix + ""folding"",folding);
			jEdit.setProperty(prefix + ""collapseFolds"",collapseFolds);
			jEdit.setProperty(prefix + ""wrap"",wrap);
			jEdit.setProperty(prefix + ""maxLineLen"",maxLineLen);
			jEdit.setProperty(prefix + ""tabSize"",tabSize);
			jEdit.setProperty(prefix + ""indentSize"",indentSize);
			jEdit.setBooleanProperty(prefix + ""noTabs"",noTabs);
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.textarea.JEditTextArea,239,4,0,66,478,13445,52,34,195,0.887105662,9017,0.639344262,10,0.731596829,0.080053074,3,19,36.47280335,32,3.5774,15,"

package org.gjt.sp.jedit.textarea;


import java.awt.*;
import java.awt.event.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.plaf.metal.MetalLookAndFeel;
import javax.swing.text.Position;
import javax.swing.text.Segment;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.util.Log;



public class JEditTextArea extends JComponent
{
	
	
	public JEditTextArea(View view)
	{
		enableEvents(AWTEvent.FOCUS_EVENT_MASK | AWTEvent.KEY_EVENT_MASK);

		this.view = view;

		
		selection = new Vector();
		chunkCache = new ChunkCache(this);
		painter = new TextAreaPainter(this);
		gutter = new Gutter(view,this);
		bufferHandler = new BufferChangeHandler();
		listenerList = new EventListenerList();
		caretEvent = new MutableCaretEvent();
		bracketLine = bracketPosition = -1;
		blink = true;
		lineSegment = new Segment();
		returnValue = new Point();
		runnables = new ArrayList();
		

		
		setLayout(new ScrollLayout());
		add(LEFT,gutter);
		add(CENTER,painter);
		add(RIGHT,vertical = new JScrollBar(JScrollBar.VERTICAL));
		add(BOTTOM,horizontal = new JScrollBar(JScrollBar.HORIZONTAL));

		horizontal.setValues(0,0,0,0);
		

		
		
		
		
		
		if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
		{
			setBorder(new TextAreaBorder());
			vertical.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			horizontal.putClientProperty(""JScrollBar.isFreeStanding"",
				Boolean.FALSE);
			
		}
		

		
		vertical.addAdjustmentListener(new AdjustHandler());
		horizontal.addAdjustmentListener(new AdjustHandler());

		mouseHandler = new MouseHandler();
		painter.addMouseListener(mouseHandler);
		painter.addMouseMotionListener(mouseHandler);

		addFocusListener(new FocusHandler());
		

		
		
		
		focusedComponent = this;
	} 

	

	
	
	public final TextAreaPainter getPainter()
	{
		return painter;
	} 

	
 	
	public final Gutter getGutter()
	{
		return gutter;
	} 

	
	
	public FoldVisibilityManager getFoldVisibilityManager()
	{
		return foldVisibilityManager;
	} 

	
	
	public final boolean isCaretBlinkEnabled()
	{
		return caretBlinks;
	} 

	
	
	public void setCaretBlinkEnabled(boolean caretBlinks)
	{
		this.caretBlinks = caretBlinks;
		if(!caretBlinks)
			blink = false;

		if(buffer != null)
			invalidateLine(caretLine);
	} 

	
	
	public final int getElectricScroll()
	{
		return electricScroll;
	} 

	
	
	public final void setElectricScroll(int electricScroll)
	{
		this.electricScroll = electricScroll;
	} 

	
	
	public final boolean isQuickCopyEnabled()
	{
		return quickCopy;
	} 

	
	
	public final void setQuickCopyEnabled(boolean quickCopy)
	{
		this.quickCopy = quickCopy;
	} 

	
	
	public final Buffer getBuffer()
	{
		return buffer;
	} 

	
	
	public void setBuffer(Buffer buffer)
	{
		if(this.buffer == buffer)
			return;

		try
		{
			bufferChanging = true;

			if(this.buffer != null)
			{
				
				

				selectNone();
				caretLine = caret = caretScreenLine = 0;
				bracketLine = bracketPosition = -1;

				this.buffer._releaseFoldVisibilityManager(foldVisibilityManager);
				this.buffer.removeBufferChangeListener(bufferHandler);
			}
			this.buffer = buffer;

			foldVisibilityManager = buffer._getFoldVisibilityManager(this);

			buffer.addBufferChangeListener(bufferHandler);
			bufferHandlerInstalled = true;

			firstLine = 0;
			maxHorizontalScrollWidth = 0;
			physFirstLine = foldVisibilityManager.getFirstVisibleLine();
			chunkCache.setFirstLine(0,physFirstLine,true);

			propertiesChanged();

			recalculateLastPhysicalLine();

			painter.repaint();
			gutter.repaint();

			updateScrollBars();
			fireScrollEvent(true);
		}
		finally
		{
			bufferChanging = false;
		}
	} 

	
	
	public final boolean isEditable()
	{
		return buffer.isEditable();
	} 

	
	
	public final JPopupMenu getRightClickPopup()
	{
		return popup;
	} 

	
	
	public final void setRightClickPopup(JPopupMenu popup)
	{
		this.popup = popup;
	} 

	

	

	
	
	public final int getFirstLine()
	{
		return firstLine;
	} 

	
	
	public void setFirstLine(int firstLine)
	{
		if(firstLine == this.firstLine)
			return;

		_setFirstLine(firstLine);

		view.synchroScrollVertical(this,firstLine);
	} 

	
	public void _setFirstLine(int firstLine)
	{
		firstLine = Math.max(0,Math.min(getVirtualLineCount() - 1,firstLine));
		this.firstLine = firstLine;

		physFirstLine = virtualToPhysical(firstLine);

		maxHorizontalScrollWidth = 0;

		chunkCache.setFirstLine(firstLine,physFirstLine,false);

		recalculateLastPhysicalLine();

		painter.repaint();
		gutter.repaint();

		if(this.firstLine != vertical.getValue())
			updateScrollBars();

		fireScrollEvent(true);
	} 

	
	
	public final int getVisibleLines()
	{
		return visibleLines;
	} 

	
	
	public final int getFirstPhysicalLine()
	{
		return physFirstLine;
	} 

	
	
	public final int getLastPhysicalLine()
	{
		return physLastLine;
	} 

	
	
	public final int getHorizontalOffset()
	{
		return horizontalOffset;
	} 

	
	
	public void setHorizontalOffset(int horizontalOffset)
	{
		if(horizontalOffset == this.horizontalOffset)
			return;
		_setHorizontalOffset(horizontalOffset);

		view.synchroScrollHorizontal(this,horizontalOffset);
	} 

	
	public void _setHorizontalOffset(int horizontalOffset)
	{
		this.horizontalOffset = horizontalOffset;
		if(horizontalOffset != horizontal.getValue())
			updateScrollBars();
		painter.repaint();

		fireScrollEvent(false);
	} 

	
	
	public void updateScrollBars()
	{
		if(vertical != null && visibleLines != 0)
		{
			
			
			int lineCount = getVirtualLineCount();

			
			if(softWrap)
				lineCount += visibleLines - 1;

			if(lineCount < firstLine + visibleLines)
			{
				
				
				int newFirstLine = Math.max(0,lineCount - visibleLines);
				if(newFirstLine != firstLine)
				{
					setFirstLine(newFirstLine);
					return;
				}
			}

			vertical.setValues(firstLine,visibleLines,0,lineCount);
			vertical.setUnitIncrement(2);
			vertical.setBlockIncrement(visibleLines);
		}

		int width = painter.getWidth();
		if(horizontal != null && width != 0)
		{
			maxHorizontalScrollWidth = 0;
			painter.repaint();

			horizontal.setUnitIncrement(painter.getFontMetrics()
				.charWidth('w'));
			horizontal.setBlockIncrement(width / 2);
		}
	} 

	
	
	public void scrollUpLine()
	{
		if(firstLine > 0)
			setFirstLine(firstLine - 1);
		
		
	} 

	
	
	public void scrollUpPage()
	{
		if(firstLine > 0)
		{
			int newFirstLine;
			if(softWrap)
			{
				newFirstLine = firstLine;
				int screenLineCount = 0;
				while(--newFirstLine >= 0)
				{
					int lines = chunkCache
						.getLineInfosForPhysicalLine(
						newFirstLine).length;
					if(screenLineCount + lines >= visibleLines)
						break;
					else
						screenLineCount += lines;
				}
			}
			else
			{
				newFirstLine = firstLine - visibleLines;
			}
			setFirstLine(newFirstLine);
		}
		
	} 

	
	
	public void scrollDownLine()
	{
		int numLines = getVirtualLineCount();

		if((softWrap && firstLine + 1 < numLines) ||
			(firstLine + visibleLines < numLines))
			setFirstLine(firstLine + 1);
		
		
	} 

	
	
	public void scrollDownPage()
	{
		int numLines = getVirtualLineCount();

		if((softWrap && firstLine + 1 < numLines) ||
			(firstLine + visibleLines < numLines))
		{
			setFirstLine(physicalToVirtual(physLastLine));
		}
		
		
	} 

	
	
	public void scrollToCaret(boolean doElectricScroll)
	{
		scrollTo(caretLine,caret - buffer.getLineStartOffset(caretLine),
			doElectricScroll);
	} 

	
	
	public void scrollTo(int line, int offset, boolean doElectricScroll)
	{
		int extraEndVirt;
		int lineLength = buffer.getLineLength(line);
		if(offset > lineLength)
		{
			extraEndVirt = charWidth * (offset - lineLength);
			offset = lineLength;
		}
		else
			extraEndVirt = 0;

		int _electricScroll = (doElectricScroll
			&& visibleLines > electricScroll * 2
			? electricScroll : 0);

		
		
		
		if(visibleLines == 0)
		{
			setFirstLine(physicalToVirtual(
				Math.max(0,line - _electricScroll)));
			return;
		}

		
		int screenLine = getScreenLineOfOffset(buffer.getLineStartOffset(line) + offset);
		Point point;
		if(screenLine != -1)
		{
			
			int height = painter.getFontMetrics().getHeight();

			int y1 = (firstLine == 0 ? 0 : height * _electricScroll);
			int y2 = (visibleLines + firstLine == getVirtualLineCount()
				? 0 : height * _electricScroll);

			Rectangle rect = new Rectangle(0,y1,
				painter.getWidth() - 5,visibleLines * height
				- y1 - y2);

			point = offsetToXY(line,offset,returnValue);
			point.x += extraEndVirt;
			if(rect.contains(point))
				return;
		}
		else
			point = null;
		

		
		if(line == physLastLine + 1)
		{
			int count = chunkCache.getLineInfosForPhysicalLine(physLastLine).length
				+ chunkCache.getLineInfosForPhysicalLine(physLastLine + 1).length
				+ _electricScroll;
			while(count > 0)
			{
				count -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
				firstLine++;
				physFirstLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);
			}
		}
		else if(screenLine == -1)
		{
			if(line == physLastLine)
			{
				int count = chunkCache.getLineInfosForPhysicalLine(physLastLine).length
					+ _electricScroll;
				while(count > 0)
				{
					count -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
					firstLine++;
					int nextLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);
					if(nextLine == -1)
						break;
					else
						physFirstLine = nextLine;
				}
			}

			int virtualLine = foldVisibilityManager.physicalToVirtual(line);
			if(virtualLine == firstLine - 1)
			{
				firstLine = Math.max(0,firstLine - _electricScroll - 1);
				physFirstLine = foldVisibilityManager.virtualToPhysical(firstLine);
			}
			else
			{
				
				if(!softWrap && virtualLine >= foldVisibilityManager.getVirtualLineCount()
					- visibleLines / 2)
				{
					firstLine = foldVisibilityManager.getVirtualLineCount()
						- visibleLines;
					physFirstLine = foldVisibilityManager
						.virtualToPhysical(firstLine);
				}
				else
				{
					physFirstLine = line;

					int count = 0;

					for(;;)
					{
						if(foldVisibilityManager.isLineVisible(physFirstLine))
						{
							int incr = chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
							if(count + incr > visibleLines / 2)
								break;
							else
								count += incr;
						}

						int prevLine = foldVisibilityManager
							.getPrevVisibleLine(physFirstLine);
						if(prevLine == -1)
							break;
						else
							physFirstLine = prevLine;
					}

					firstLine = physicalToVirtual(physFirstLine);
				}
			}
		}
		else if(screenLine < _electricScroll && firstLine != 0)
		{
			int count = _electricScroll - screenLine;
			while(count > 0 && firstLine > 0)
			{
				count -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
				firstLine--;
				physFirstLine = foldVisibilityManager.getPrevVisibleLine(physFirstLine);
			}
		}
		else if(screenLine >= visibleLines - _electricScroll)
		{
			int count = _electricScroll - visibleLines + screenLine + 1;
			while(count > 0 && firstLine <= getVirtualLineCount())
			{
				count -= chunkCache.getLineInfosForPhysicalLine(physFirstLine).length;
				firstLine++;
				physFirstLine = foldVisibilityManager.getNextVisibleLine(physFirstLine);
			}
		}

		chunkCache.setFirstLine(firstLine,physFirstLine,false);

		recalculateLastPhysicalLine();

		if(point == null)
		{
			point = offsetToXY(line,offset,returnValue);
			if(point == null)
			{
				
				
				return;
			}
			else
				point.x += extraEndVirt;
		} 

		
		if(point.x < 0)
		{
			horizontalOffset = Math.min(0,horizontalOffset
				- point.x + charWidth + 5);
		}
		else if(point.x >= painter.getWidth() - charWidth - 5)
		{
			horizontalOffset = horizontalOffset +
				(painter.getWidth() - point.x)
				- charWidth - 5;
		} 

		
		updateScrollBars();
		painter.repaint();
		gutter.repaint();

		view.synchroScrollVertical(this,firstLine);
		view.synchroScrollHorizontal(this,horizontalOffset);

		
		fireScrollEvent(true);
		fireScrollEvent(false);
		
	} 

	
	
	public final void addScrollListener(ScrollListener listener)
	{
		listenerList.add(ScrollListener.class,listener);
	} 

	
	
	public final void removeScrollListener(ScrollListener listener)
	{
		listenerList.remove(ScrollListener.class,listener);
	} 

	

	

	
	
	public int getPhysicalLineOfScreenLine(int screenLine)
	{
		chunkCache.updateChunksUpTo(screenLine);
		return chunkCache.getLineInfo(screenLine).physicalLine;
	} 

	
	
	public int getScreenLineOfOffset(int offset)
	{
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		return chunkCache.getScreenLineOfOffset(line,offset);
	} 

	
	
	public int getScreenLineStartOffset(int line)
	{
		chunkCache.updateChunksUpTo(line);
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)
			return -1;

		return buffer.getLineStartOffset(lineInfo.physicalLine)
			+ lineInfo.offset;
	} 

	
	
	public int getScreenLineEndOffset(int line)
	{
		chunkCache.updateChunksUpTo(line);
		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(lineInfo.physicalLine == -1)
			return -1;

		return buffer.getLineStartOffset(lineInfo.physicalLine)
			+ lineInfo.offset + lineInfo.length;
	} 

	

	

	
	
	public int xyToOffset(int x, int y)
	{
		return xyToOffset(x,y,true);
	} 

	
	
	public int xyToOffset(int x, int y, boolean round)
	{
		FontMetrics fm = painter.getFontMetrics();
		int height = fm.getHeight();
		int line = y / height;

		if(line < 0 || line > visibleLines)
			return -1;

		chunkCache.updateChunksUpTo(line);

		ChunkCache.LineInfo lineInfo = chunkCache.getLineInfo(line);
		if(!lineInfo.chunksValid)
			System.err.println(""xy to offset: not valid"");

		if(lineInfo.physicalLine == -1)
		{
			return getLineEndOffset(foldVisibilityManager
				.getLastVisibleLine()) - 1;
		}
		else
		{
			int offset = Chunk.xToOffset(lineInfo.chunks,
				x - horizontalOffset,round);
			if(offset == -1 || offset == lineInfo.offset + lineInfo.length)
				offset = lineInfo.offset + lineInfo.length - 1;

			return getLineStartOffset(lineInfo.physicalLine) + offset;
		}
	} 

	
	
	public Point offsetToXY(int offset)
	{
		int line = buffer.getLineOfOffset(offset);
		offset -= buffer.getLineStartOffset(line);
		Point retVal = new Point();
		return offsetToXY(line,offset,retVal);
	} 

	
	
	public Point offsetToXY(int line, int offset, Point retVal)
	{
		int screenLine = chunkCache.getScreenLineOfOffset(line,offset);
		if(screenLine == -1)
		{
			if(line < physFirstLine)
				return null;
			
			
			
			
			else if(line >= physLastLine)
				return null;
			else
			{
				throw new InternalError(""line="" + line
					+ "",offset="" + offset
					+ "",screenLine="" + screenLine
					+ "",physFirstLine="" + physFirstLine
					+ "",physLastLine="" + physLastLine);
			}
		}

		FontMetrics fm = painter.getFontMetrics();

		retVal.y = screenLine * fm.getHeight();

		chunkCache.updateChunksUpTo(screenLine);
		ChunkCache.LineInfo info = chunkCache.getLineInfo(screenLine);
		if(!info.chunksValid)
			System.err.println(""offset to xy: not valid"");

		retVal.x = (int)(horizontalOffset + Chunk.offsetToX(
			info.chunks,offset));

		return retVal;
	} 

	

	

	
	
	public void invalidateScreenLineRange(int start, int end)
	{
		
		
		if(chunkCache.needFullRepaint())
		{
			recalculateLastPhysicalLine();
			gutter.repaint();
			painter.repaint();
			return;
		}

		if(start > end)
		{
			int tmp = end;
			end = start;
			start = tmp;
		}

		FontMetrics fm = painter.getFontMetrics();
		int y = start * fm.getHeight();
		int height = (end - start + 1) * fm.getHeight();
		painter.repaint(0,y,painter.getWidth(),height);
		gutter.repaint(0,y,gutter.getWidth(),height);
	} 

	
	
	public void invalidateLine(int line)
	{
		if(line < physFirstLine || line > physLastLine
			|| !foldVisibilityManager.isLineVisible(line))
			return;

		int startLine = -1;
		int endLine = -1;

		for(int i = 0; i <= visibleLines; i++)
		{
			chunkCache.updateChunksUpTo(i);
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);

			if((info.physicalLine >= line || info.physicalLine == -1)
				&& startLine == -1)
			{
				startLine = i;
			}

			if((info.physicalLine >= line && info.lastSubregion)
				|| info.physicalLine == -1)
			{
				endLine = i;
				break;
			}
		}

		if(chunkCache.needFullRepaint())
		{
			recalculateLastPhysicalLine();
			endLine = visibleLines;
		}
		else if(endLine == -1)
			endLine = visibleLines;

		
		

		invalidateScreenLineRange(startLine,endLine);
	} 

	
	
	public void invalidateLineRange(int start, int end)
	{
		if(end < start)
		{
			int tmp = end;
			end = start;
			start = tmp;
		}

		if(end < physFirstLine || start > physLastLine)
			return;

		int startScreenLine = -1;
		int endScreenLine = -1;

		for(int i = 0; i <= visibleLines; i++)
		{
			chunkCache.updateChunksUpTo(i);
			ChunkCache.LineInfo info = chunkCache.getLineInfo(i);

			if((info.physicalLine >= start || info.physicalLine == -1)
				&& startScreenLine == -1)
			{
				startScreenLine = i;
			}

			if((info.physicalLine >= end && info.lastSubregion)
				|| info.physicalLine == -1)
			{
				endScreenLine = i;
				break;
			}
		}

		if(startScreenLine == -1)
			startScreenLine = 0;

		if(chunkCache.needFullRepaint())
		{
			recalculateLastPhysicalLine();
			endScreenLine = visibleLines;
		}
		else if(endScreenLine == -1)
			endScreenLine = visibleLines;

		invalidateScreenLineRange(startScreenLine,endScreenLine);
	} 

	
	
	public void invalidateSelectedLines()
	{
		
		invalidateLine(caretLine);

		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			invalidateLineRange(s.startLine,s.endLine);
		}
	} 

	

	

	
	
	public int physicalToVirtual(int line)
	{
		return foldVisibilityManager.physicalToVirtual(line);
	} 

	
	
	public int virtualToPhysical(int line)
	{
		return foldVisibilityManager.virtualToPhysical(line);
	} 

	
	
	public final int getBufferLength()
	{
		return buffer.getLength();
	} 

	
	
	public final int getLineCount()
	{
		return buffer.getLineCount();
	} 

	
	
	public final int getVirtualLineCount()
	{
		return foldVisibilityManager.getVirtualLineCount();
	} 

	
	
	public final int getLineOfOffset(int offset)
	{
		return buffer.getLineOfOffset(offset);
	} 

	
	
	public int getLineStartOffset(int line)
	{
		return buffer.getLineStartOffset(line);
	} 

	
	
	public int getLineEndOffset(int line)
	{
		return buffer.getLineEndOffset(line);
	} 

	
	
	public int getLineLength(int line)
	{
		return buffer.getLineLength(line);
	} 

	
	
	public final String getText(int start, int len)
	{
		return buffer.getText(start,len);
	} 

	
	
	public final void getText(int start, int len, Segment segment)
	{
		buffer.getText(start,len,segment);
	} 

	
	
	public final String getLineText(int lineIndex)
	{
		return buffer.getLineText(lineIndex);
	} 

	
	
	public final void getLineText(int lineIndex, Segment segment)
	{
		buffer.getLineText(lineIndex,segment);
	} 

	
	
	public String getText()
	{
		return buffer.getText(0,buffer.getLength());
	} 

	
	
	public void setText(String text)
	{
		try
		{
			buffer.beginCompoundEdit();
			buffer.remove(0,buffer.getLength());
			buffer.insert(0,text);
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	

	

	
	
	public final void selectAll()
	{
		setSelection(new Selection.Range(0,buffer.getLength()));
		moveCaretPosition(buffer.getLength(),true);
	} 

	
	
	public void selectLine()
	{
		int caretLine = getCaretLine();
		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine) - 1;
		Selection s = new Selection.Range(start,end);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(end);
	} 

	
	
	public void selectParagraph()
	{
		int caretLine = getCaretLine();

		if(getLineLength(caretLine) == 0)
		{
			view.getToolkit().beep();
			return;
		}

		int start = caretLine;
		int end = caretLine;

		while(start >= 0)
		{
			if(getLineLength(start) == 0)
				break;
			else
				start--;
		}

		while(end < getLineCount())
		{
			if(getLineLength(end) == 0)
				break;
			else
				end++;
		}

		int selectionStart = getLineStartOffset(start + 1);
		int selectionEnd = getLineEndOffset(end - 1) - 1;
		Selection s = new Selection.Range(selectionStart,selectionEnd);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(selectionEnd);
	} 

	
	
	
	
	public void selectWord()
	{
		int line = getCaretLine();
		int lineStart = getLineStartOffset(line);
		int offset = getCaretPosition() - lineStart;

		if(getLineLength(line) == 0)
			return;

		String lineText = getLineText(line);
		String noWordSep = buffer.getStringProperty(""noWordSep"");

		if(offset == getLineLength(line))
			offset--;

		int wordStart = TextUtilities.findWordStart(lineText,offset,noWordSep);
		int wordEnd = TextUtilities.findWordEnd(lineText,offset+1,noWordSep);

		Selection s = new Selection.Range(lineStart + wordStart,
			lineStart + wordEnd);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(lineStart + wordEnd);
	} 

	
	
	public boolean selectToMatchingBracket(int position)
	{
		int positionLine = buffer.getLineOfOffset(position);
		int lineOffset = position - buffer.getLineStartOffset(positionLine);

		int bracket = TextUtilities.findMatchingBracket(buffer,positionLine,lineOffset);
		
		if(bracket != -1)
		{
			Selection s;

			if(bracket < position)
			{
				moveCaretPosition(position,false);
				s = new Selection.Range(++bracket,position);
			}
			else
			{
				moveCaretPosition(position + 1,false);
				s = new Selection.Range(position + 1,bracket);
			}

			if(!multi)
				selectNone();

			addToSelection(s);
			return true;
		}
		
		return false;
	} 

	
	
	public void selectToMatchingBracket()
	{
		
		int caret = this.caret;

		int offset = caret - buffer.getLineStartOffset(caretLine);

		if(buffer.getLineLength(caretLine) == 0)
			return;

		if(offset == buffer.getLineLength(caretLine))
			caret--;
		
		selectToMatchingBracket(caret);
	} 

	
	
	public void selectBlock()
	{
		String openBrackets = ""([{"";
		String closeBrackets = "")]}"";

		Selection s = getSelectionAtOffset(caret);
		int start, end;
		if(s == null)
			start = end = caret;
		else
		{
			start = s.start;
			end = s.end;
		}

		String text = getText(0,buffer.getLength());

		
		int count = 1;
		char openBracket = '\0';
		char closeBracket = '\0';

		
		if(start == 0)
		{
			view.getToolkit().beep();
			return;
		}

backward_scan:	while(--start > 0)
		{
			char c = text.charAt(start);
			int index = openBrackets.indexOf(c);
			if(index != -1)
			{
				if(--count == 0)
				{
					openBracket = c;
					closeBracket = closeBrackets.charAt(index);
					break backward_scan;
				}
			}
			else if(closeBrackets.indexOf(c) != -1)
				count++;
		}

		
		count = 1;

		
		if(openBracket == '\0')
		{
			getToolkit().beep();
			return;
		}
		else
		{
forward_scan:		do
			{
				char c = text.charAt(end);
				if(c == closeBracket)
				{
					if(--count == 0)
					{
						end++;
						break forward_scan;
					}
				}
				else if(c == openBracket)
					count++;
			}
			while(++end < buffer.getLength());
		}

		s = new Selection.Range(start,end);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(end);
	} 

	
	
	public final void invertSelection()
	{
		Selection[] newSelection = new Selection[selection.size() + 1];
		int lastOffset = 0;
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			newSelection[i] = new Selection.Range(lastOffset,
				s.getStart());
			lastOffset = s.getEnd();
		}
		newSelection[selection.size()] = new Selection.Range(
			lastOffset,buffer.getLength());
		setSelection(newSelection);
	} 

	
	
	public int getSelectionCount()
	{
		return selection.size();
	} 

	
	
	public Selection[] getSelection()
	{
		Selection[] sel = new Selection[selection.size()];
		selection.copyInto(sel);
		return sel;
	} 

	
	
	public void selectNone()
	{
		setSelection((Selection)null);
	} 

	
	
	public void setSelection(Selection[] selection)
	{
		
		invalidateSelectedLines();

		this.selection.removeAllElements();

		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
				_addToSelection(selection[i]);
		}

		fireCaretEvent();
	} 

	
	
	public void setSelection(Selection selection)
	{
		invalidateSelectedLines();
		this.selection.removeAllElements();

		if(selection != null)
			_addToSelection(selection);

		fireCaretEvent();
	} 

	
	
	public void addToSelection(Selection[] selection)
	{
		if(selection != null)
		{
			for(int i = 0; i < selection.length; i++)
				_addToSelection(selection[i]);
		}

		
		invalidateLine(caretLine);

		fireCaretEvent();
	} 

	
	
	public void addToSelection(Selection selection)
	{
		_addToSelection(selection);

		
		invalidateLine(caretLine);

		fireCaretEvent();
	} 

	
	
	public Selection getSelectionAtOffset(int offset)
	{
		if(selection != null)
		{
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);
				if(offset >= s.start && offset <= s.end)
					return s;
			}
		}

		return null;
	} 

	
	
	public void removeFromSelection(Selection sel)
	{
		selection.removeElement(sel);
		invalidateLineRange(sel.startLine,sel.endLine);

		
		invalidateLine(caretLine);

		fireCaretEvent();
	} 

	
	public void removeFromSelection(int offset)
	{
		Selection sel = getSelectionAtOffset(offset);
		if(sel == null)
			return;

		selection.removeElement(sel);
		invalidateLineRange(sel.startLine,sel.endLine);

		
		invalidateLine(caretLine);

		fireCaretEvent();
	} 

	
	
	public void resizeSelection(int offset, int end, int extraEndVirt,
		boolean rect)
	{
		Selection s = getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selection.removeElement(s);
		}

		boolean reversed = false;
		if(end < offset)
		{
			int tmp = offset;
			offset = end;
			end = tmp;
			reversed = true;
		}

		Selection newSel;
		if(rect)
		{
			Selection.Rect rectSel = new Selection.Rect(offset,end);
			if(reversed)
				rectSel.extraStartVirt = extraEndVirt;
			else
				rectSel.extraEndVirt = extraEndVirt;
			newSel = rectSel;
		}
		else
			newSel = new Selection.Range(offset,end);

		_addToSelection(newSel);
		fireCaretEvent();
	} 

	
	
	public void extendSelection(int offset, int end)
	{
		Selection s = getSelectionAtOffset(offset);
		if(s != null)
		{
			invalidateLineRange(s.startLine,s.endLine);
			selection.removeElement(s);

			if(offset == s.start)
			{
				offset = end;
				end = s.end;
			}
			else if(offset == s.end)
			{
				offset = s.start;
			}
		}

		if(end < offset)
		{
			int tmp = end;
			end = offset;
			offset = tmp;
		}

		_addToSelection(new Selection.Range(offset,end));
		fireCaretEvent();
	} 

	
	
	public String getSelectedText(Selection s)
	{
		StringBuffer buf = new StringBuffer();
		s.getText(buffer,buf);
		return buf.toString();
	} 

	
	
	public String getSelectedText(String separator)
	{
		if(selection.size() == 0)
			return null;

		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < selection.size(); i++)
		{
			if(i != 0)
				buf.append(separator);

			((Selection)selection.elementAt(i)).getText(buffer,buf);
		}

		return buf.toString();
	} 

	
	
	public String getSelectedText()
	{
		return getSelectedText(""\n"");
	} 

	
	
	public void setSelectedText(Selection s, String selectedText)
	{
		if(!isEditable())
		{
			throw new InternalError(""Text component""
				+ "" read only"");
		}

		try
		{
			buffer.beginCompoundEdit();

			moveCaretPosition(s.setText(buffer,selectedText));
		}
		
		
		finally
		{
			buffer.endCompoundEdit();
		}

		
		
	} 

	
	
	public void setSelectedText(String selectedText)
	{
		if(!isEditable())
		{
			throw new InternalError(""Text component""
				+ "" read only"");
		}

		Selection[] selection = getSelection();
		if(selection.length == 0)
		{
			
			buffer.insert(caret,selectedText);
		}
		else
		{
			try
			{
				int newCaret = -1;

				buffer.beginCompoundEdit();

				for(int i = 0; i < selection.length; i++)
				{
					newCaret = selection[i].setText(buffer,selectedText);
				}

				moveCaretPosition(newCaret);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}

		selectNone();
	} 

	
	
	public int[] getSelectedLines()
	{
		if(selection.size() == 0)
			return new int[] { caretLine };

		Integer line;

		Hashtable hash = new Hashtable();
		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			int endLine = (s.end == getLineStartOffset(s.endLine)
				? s.endLine - 1
				: s.endLine);

			for(int j = s.startLine; j <= endLine; j++)
			{
				line = new Integer(j);
				hash.put(line,line);
			}
		}

		int[] returnValue = new int[hash.size()];
		int i = 0;

		Enumeration keys = hash.keys();
		while(keys.hasMoreElements())
		{
			line = (Integer)keys.nextElement();
			returnValue[i++] = line.intValue();
		}

		Arrays.sort(returnValue);

		return returnValue;
	} 

	
	
	public void showSelectLineRangeDialog()
	{
		new SelectLineRange(view);
	} 

	

	

	
	
	public final void blinkCaret()
	{
		if(caretBlinks)
		{
			blink = !blink;
			invalidateLine(caretLine);
		}
		else
			blink = true;
	} 

	
	
	public void centerCaret()
	{
		int offset = getScreenLineStartOffset(visibleLines / 2);
		if(offset == -1)
			getToolkit().beep();
		else
			setCaretPosition(offset);
	} 

	
	
	public void setCaretPosition(int newCaret)
	{
		invalidateSelectedLines();
		selection.removeAllElements();
		moveCaretPosition(newCaret,true);
	} 

	
	
	public void setCaretPosition(int newCaret, boolean doElectricScroll)
	{
		invalidateSelectedLines();
		selection.removeAllElements();
		moveCaretPosition(newCaret,doElectricScroll);
	} 

	
	
	public void moveCaretPosition(int newCaret)
	{
		moveCaretPosition(newCaret,true);
	} 

	
	
	public void moveCaretPosition(int newCaret, boolean doElectricScroll)
	{
		if(newCaret < 0 || newCaret > buffer.getLength())
		{
			throw new IllegalArgumentException(""caret out of bounds: ""
				+ newCaret);
		}

		if(caret == newCaret)
		{
			if(view.getTextArea() == this)
				finishCaretUpdate(doElectricScroll,false);
		}
		else
		{
			int newCaretLine = getLineOfOffset(newCaret);

			magicCaret = -1;

			if(!foldVisibilityManager.isLineVisible(newCaretLine))
			{
				if(foldVisibilityManager.isNarrowed())
				{
					int collapseFolds = buffer.getIntegerProperty(
						""collapseFolds"",0);
					if(collapseFolds != 0)
					{
						foldVisibilityManager.expandFolds(collapseFolds);
						foldVisibilityManager.expandFold(newCaretLine,false);
					}
					else
						foldVisibilityManager.expandAllFolds();
				}
				else
					foldVisibilityManager.expandFold(newCaretLine,false);
			}

			if(caretLine == newCaretLine)
			{
				if(caretScreenLine != -1)
					invalidateScreenLineRange(caretScreenLine,caretScreenLine);
			}
			else
			{
				int newCaretScreenLine = chunkCache.getScreenLineOfOffset(newCaretLine,
					newCaret - buffer.getLineStartOffset(newCaretLine));
				if(caretScreenLine == -1)
					invalidateScreenLineRange(newCaretScreenLine,newCaretScreenLine);
				else
					invalidateScreenLineRange(caretScreenLine,newCaretScreenLine);
				caretScreenLine = newCaretScreenLine;
			}

			caret = newCaret;
			caretLine = newCaretLine;

			if(view.getTextArea() == this)
				finishCaretUpdate(doElectricScroll,true);
		}
	} 

	
	
	public int getCaretPosition()
	{
		return caret;
	} 

	
	
	public int getCaretLine()
	{
		return caretLine;
	} 

	
	
	public final int getMagicCaretPosition()
	{
		if(magicCaret == -1)
		{
			magicCaret = offsetToX(caretLine,caret
				- getLineStartOffset(caretLine));
		}

		return magicCaret;
	} 

	
	
	public final void setMagicCaretPosition(int magicCaret)
	{
		this.magicCaret = magicCaret;
	} 

	
	
	public final void addCaretListener(CaretListener listener)
	{
		listenerList.add(CaretListener.class,listener);
	} 

	
	
	public final void removeCaretListener(CaretListener listener)
	{
		listenerList.remove(CaretListener.class,listener);
	} 

	
	
	public final int getBracketPosition()
	{
		return bracketPosition;
	} 

	
	
	public final int getBracketLine()
	{
		return bracketLine;
	} 

	
	
	public void goToNextBracket(boolean select)
	{
		String text = getText(caret,buffer.getLength() - caret - 1);

		int newCaret = -1;

loop:		for(int i = 0; i < text.length(); i++)
		{
			switch(text.charAt(i))
			{
			case ')': case ']': case '}':
				newCaret = caret + i + 1;
				break loop;
			}
		}

		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	} 

	
	
	public void goToNextCharacter(boolean select)
	{
		if(!select && selection.size() != 0)
		{
			Selection s = getSelectionAtOffset(caret);
			if(s != null)
			{
				if(multi)
				{
					if(caret != s.end)
					{
						moveCaretPosition(s.end);
						return;
					}
				}
				else
				{
					setCaretPosition(s.end);
					return;
				}
			}
		}

		if(caret == buffer.getLength())
			getToolkit().beep();

		int newCaret;

		if(caret == getLineEndOffset(caretLine) - 1)
		{
			int line = foldVisibilityManager.getNextVisibleLine(caretLine);
			if(line == -1)
			{
				getToolkit().beep();
				return;
			}

			newCaret = getLineStartOffset(line);
		}
		else
			newCaret = caret + 1;

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
	} 

	
	
	public void goToNextLine(boolean select)
	{
		ChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(caretLine);

		int caretFromStartOfLine = caret - buffer.getLineStartOffset(caretLine);
		int subregion = getSubregionOfOffset(caretFromStartOfLine,
			lineInfos);

		int magic = this.magicCaret;
		if(magic == -1)
		{
			magic = subregionOffsetToX(lineInfos[subregion],
				caretFromStartOfLine);
		}

		int newCaret;

		if(subregion != lineInfos.length - 1)
		{
			newCaret = buffer.getLineStartOffset(caretLine)
				+ xToSubregionOffset(lineInfos[subregion + 1],magic,
				true);
		}
		else
		{
			int nextLine = foldVisibilityManager.getNextVisibleLine(caretLine);

			if(nextLine == -1)
			{
				int end = getLineEndOffset(caretLine) - 1;
				if(caret == end)
				{
					getToolkit().beep();
					return;
				}
				else
					newCaret = end;
			}
			else
			{
				lineInfos = chunkCache.getLineInfosForPhysicalLine(nextLine);
				newCaret = getLineStartOffset(nextLine)
					+ xToSubregionOffset(lineInfos[0],magic + 1,
					true);
			}
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);

		this.magicCaret = magic;
	} 

	
	
	public void goToNextMarker(boolean select)
	{
		Vector markers = buffer.getMarkers();
		if(markers.size() == 0)
		{
			getToolkit().beep();
			return;
		}

		Marker marker = null;

		for(int i = 0; i < markers.size(); i++)
		{
			Marker _marker = (Marker)markers.get(i);
			if(_marker.getPosition() > caret)
			{
				marker = _marker;
				break;
			}
		}

		if(marker == null)
			marker = (Marker)markers.get(0);

		if(select)
			extendSelection(caret,marker.getPosition());
		else if(!multi)
			selectNone();
		moveCaretPosition(marker.getPosition());
	} 

	
	
	public void goToNextPage(boolean select)
	{
		int lineCount = getVirtualLineCount();

		int magic = getMagicCaretPosition();

		if(firstLine + visibleLines * 2 >= lineCount - 1)
			setFirstLine(lineCount - visibleLines);
		else
			setFirstLine(firstLine + visibleLines);

		int newLine = virtualToPhysical(Math.min(lineCount - 1,
			physicalToVirtual(caretLine) + visibleLines));
		int newCaret = getLineStartOffset(newLine)
			+ xToOffset(newLine,magic + 1);

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);

		setMagicCaretPosition(magic);
	} 

	
	
	public void goToNextParagraph(boolean select)
	{
		int lineNo = getCaretLine();

		int newCaret = getBufferLength();

		boolean foundBlank = false;

loop:		for(int i = lineNo + 1; i < getLineCount(); i++)
		{
			if(!foldVisibilityManager.isLineVisible(i))
				continue;

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineStartOffset(i);
						break loop;
					}
					else
						continue loop;
				}
			}

			foundBlank = true;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToNextWord(boolean select)
	{
		goToNextWord(select,false);
	} 

	
	
	public void goToNextWord(boolean select, boolean stdNextPrevWord)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);

		if(newCaret == lineText.length())
		{
			int nextLine = foldVisibilityManager.getNextVisibleLine(caretLine);
			if(nextLine == -1)
			{
				getToolkit().beep();
				return;
			}

			newCaret = getLineStartOffset(nextLine);
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			newCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,
				noWordSep);
			if(stdNextPrevWord)
			{
				while((newCaret < lineText.length()) && Character.isWhitespace(lineText.charAt(newCaret)))
					newCaret = TextUtilities.findWordEnd(lineText,newCaret + 1,
						noWordSep);
			}

			newCaret += lineStart;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToPrevBracket(boolean select)
	{
		String text = getText(0,caret);

		int newCaret = -1;

loop:		for(int i = getCaretPosition() - 1; i >= 0; i--)
		{
			switch(text.charAt(i))
			{
			case '(': case '[': case '{':
				newCaret = i;
				break loop;
			}
		}

		if(newCaret == -1)
			getToolkit().beep();
		else
		{
			if(select)
				extendSelection(caret,newCaret);
			else if(!multi)
				selectNone();
			moveCaretPosition(newCaret);
		}
	} 

	
	
	public void goToPrevCharacter(boolean select)
	{
		if(!select && selection.size() != 0)
		{
			Selection s = getSelectionAtOffset(caret);
			if(s != null)
			{
				if(multi)
				{
					if(caret != s.start)
					{
						moveCaretPosition(s.start);
						return;
					}
				}
				else
				{
					setCaretPosition(s.start);
					return;
				}
			}
		}

		int newCaret;

		if(caret == getLineStartOffset(caretLine))
		{
			int line = foldVisibilityManager.getPrevVisibleLine(caretLine);
			if(line == -1)
			{
				getToolkit().beep();
				return;
			}
			newCaret = getLineEndOffset(line) - 1;
		}
		else
			newCaret = caret - 1;

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToPrevLine(boolean select)
	{
		ChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(caretLine);

		int caretFromStartOfLine = caret - buffer.getLineStartOffset(caretLine);
		int subregion = getSubregionOfOffset(caretFromStartOfLine,
			lineInfos);

		int magic = this.magicCaret;
		if(magic == -1)
		{
			magic = subregionOffsetToX(lineInfos[subregion],
				caretFromStartOfLine);
		}

		int newCaret;

		if(subregion != 0)
		{
			newCaret = buffer.getLineStartOffset(caretLine)
				+ xToSubregionOffset(lineInfos[subregion - 1],magic,
				true);
		}
		else
		{
			int prevLine = foldVisibilityManager.getPrevVisibleLine(caretLine);

			if(prevLine == -1)
			{
				int start = getLineStartOffset(caretLine);
				if(caret == start)
				{
					getToolkit().beep();
					return;
				}
				else
					newCaret = start;
			}
			else
			{
				lineInfos = chunkCache.getLineInfosForPhysicalLine(prevLine);
				newCaret = getLineStartOffset(prevLine)
					+ xToSubregionOffset(lineInfos[
					lineInfos.length - 1],magic + 1,
					true);
			}
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);

		this.magicCaret = magic;
	} 

	
	
	public void goToPrevMarker(boolean select)
	{
		Vector markers = buffer.getMarkers();
		if(markers.size() == 0)
		{
			getToolkit().beep();
			return;
		}

		Marker marker = null;
		for(int i = markers.size() - 1; i >= 0; i--)
		{
			Marker _marker = (Marker)markers.elementAt(i);
			if(_marker.getPosition() < caret)
			{
				marker = _marker;
				break;
			}
		}

		if(marker == null)
			marker = (Marker)markers.get(markers.size() - 1);

		if(select)
			extendSelection(caret,marker.getPosition());
		else if(!multi)
			selectNone();
		moveCaretPosition(marker.getPosition());
	} 

	
	
	public void goToPrevPage(boolean select)
	{
		if(firstLine < visibleLines)
			setFirstLine(0);
		else
			setFirstLine(firstLine - visibleLines);

		int magic = getMagicCaretPosition();

		int newLine = virtualToPhysical(Math.max(0,
			physicalToVirtual(caretLine) - visibleLines));
		int newCaret = getLineStartOffset(newLine)
			+ xToOffset(newLine,magic + 1);

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void goToPrevParagraph(boolean select)
	{
		int lineNo = caretLine;
		int newCaret = 0;

		boolean foundBlank = false;

loop:		for(int i = lineNo - 1; i >= 0; i--)
		{
			if(!foldVisibilityManager.isLineVisible(i))
				continue;

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					if(foundBlank)
					{
						newCaret = getLineEndOffset(i) - 1;
						break loop;
					}
					else
						continue loop;
				}
			}

			foundBlank = true;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToPrevWord(boolean select)
	{
		goToPrevWord(select,false);
	} 

	
	
	public void goToPrevWord(boolean select, boolean stdNextPrevWord)
	{
		int lineStart = getLineStartOffset(caretLine);
		int newCaret = caret - lineStart;
		String lineText = getLineText(caretLine);

		if(newCaret == 0)
		{
			if(lineStart == 0)
			{
				view.getToolkit().beep();
				return;
			}
			else
			{
				int prevLine = foldVisibilityManager.getPrevVisibleLine(caretLine);
				if(prevLine == -1)
				{
					getToolkit().beep();
					return;
				}

				newCaret = getLineEndOffset(prevLine) - 1;
			}
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			newCaret = TextUtilities.findWordStart(lineText,newCaret - 1,
				noWordSep);
			if(stdNextPrevWord)
			{
				while((newCaret > 0) && Character.isWhitespace(lineText.charAt(newCaret)))
					newCaret = TextUtilities.findWordStart(lineText,newCaret - 1,
						noWordSep);
			}
			
			newCaret += lineStart;
		}

		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void smartHome(boolean select)
	{
		Macros.Recorder recorder = view.getMacroRecorder();

		switch(view.getInputHandler().getLastActionCount())
		{
		case 1:
			if(recorder != null)
				recorder.record(""textArea.goToStartOfWhiteSpace("" + select + "");"");

			goToStartOfWhiteSpace(select);
			break;
		case 2:
			if(recorder != null)
				recorder.record(""textArea.goToStartOfLine("" + select + "");"");

			goToStartOfLine(select);
			break;
		default: 
			if(recorder != null)
				recorder.record(""textArea.goToFirstVisibleLine("" + select + "");"");

			goToFirstVisibleLine(select);
			break;
		}
	} 

	
	
	public void smartEnd(boolean select)
	{
		Macros.Recorder recorder = view.getMacroRecorder();

		switch(view.getInputHandler().getLastActionCount())
		{
		case 1:
			if(recorder != null)
				recorder.record(""textArea.goToEndOfWhiteSpace("" + select + "");"");

			goToEndOfWhiteSpace(select);
			break;
		case 2:
			if(recorder != null)
				recorder.record(""textArea.goToEndOfLine("" + select + "");"");

			goToEndOfLine(select);
			break;
		default: 
			if(recorder != null)
				recorder.record(""textArea.goToLastVisibleLine("" + select + "");"");
			goToLastVisibleLine(select);
			break;
		}
	} 

	
	
	public void goToStartOfLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line = (select || s == null
			? caretLine : s.startLine);
		int newCaret = getLineStartOffset(line);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);
	} 

	
	
	public void goToEndOfLine(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line = (select || s == null
			? caretLine : s.endLine);
		int newCaret = getLineEndOffset(line) - 1;
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();
		moveCaretPosition(newCaret);

		
		
		
	} 

	
	
	public void goToStartOfWhiteSpace(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null)
		{
			line = caretLine;
			offset = caret - buffer.getLineStartOffset(line);
		}
		else
		{
			line = s.startLine;
			offset = s.start - buffer.getLineStartOffset(line);
		}

		int firstIndent;

		ChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(line);
		int subregion = getSubregionOfOffset(offset,lineInfos);
		if(subregion == 0)
		{
			firstIndent = MiscUtilities.getLeadingWhiteSpace(getLineText(line));
			if(firstIndent == getLineLength(line))
				firstIndent = 0;
			firstIndent += getLineStartOffset(line);
		}
		else
		{
			firstIndent = getLineStartOffset(line)
				+ lineInfos[subregion].offset;
		}

		if(select)
			extendSelection(caret,firstIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstIndent);
	} 

	
	
	public void goToEndOfWhiteSpace(boolean select)
	{
		Selection s = getSelectionAtOffset(caret);
		int line, offset;
		if(select || s == null)
		{
			line = caretLine;
			offset = caret - getLineStartOffset(line);
		}
		else
		{
			line = s.endLine;
			offset = s.end - getLineStartOffset(line);
		}

		int lastIndent;

		ChunkCache.LineInfo[] lineInfos = chunkCache.getLineInfosForPhysicalLine(line);
		int subregion = getSubregionOfOffset(offset,lineInfos);
		if(subregion == lineInfos.length - 1)
		{
			lastIndent = getLineLength(line) - MiscUtilities.getTrailingWhiteSpace(getLineText(line));
			if(lastIndent == 0)
				lastIndent = getLineLength(line);
			lastIndent += getLineStartOffset(line);
		}
		else
		{
			lastIndent = getLineStartOffset(line)
				+ lineInfos[subregion].offset
				+ lineInfos[subregion].length - 1;
		}

		if(select)
			extendSelection(caret,lastIndent);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastIndent);
	} 

	
	
	public void goToFirstVisibleLine(boolean select)
	{
		int firstVisibleLine = firstLine == 0 ? 0 : electricScroll;
		int firstVisible = getScreenLineStartOffset(firstVisibleLine);
		if(firstVisible == -1)
		{
			firstVisible = getLineStartOffset(foldVisibilityManager
				.getFirstVisibleLine());
		}

		if(select)
			extendSelection(caret,firstVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(firstVisible);
	} 

	
	
	public void goToLastVisibleLine(boolean select)
	{
		int lastVisible;

		if(firstLine + visibleLines >= getVirtualLineCount())
		{
			lastVisible = getLineEndOffset(foldVisibilityManager
				.getLastVisibleLine()) - 1;
		}
		else
		{
			lastVisible = getScreenLineEndOffset(visibleLines
				- electricScroll - 1) - 1;
			if(lastVisible == -1)
			{
				lastVisible = getLineEndOffset(foldVisibilityManager
					.getLastVisibleLine()) - 1;
			}
		}

		if(select)
			extendSelection(caret,lastVisible);
		else if(!multi)
			selectNone();
		moveCaretPosition(lastVisible);
	} 

	
	
	public void goToBufferStart(boolean select)
	{
		int start = buffer.getLineStartOffset(
			foldVisibilityManager.getFirstVisibleLine());
		if(select)
			extendSelection(caret,start);
		else if(!multi)
			selectNone();
		moveCaretPosition(start);
	} 

	
	
	public void goToBufferEnd(boolean select)
	{
		int end = buffer.getLineEndOffset(
			foldVisibilityManager.getLastVisibleLine()) - 1;
		if(select)
			extendSelection(caret,end);
		else if(!multi)
			selectNone();
		moveCaretPosition(end);
	} 

	
	
	public void goToMatchingBracket()
	{
		if(getLineLength(caretLine) != 0)
		{
			int dot = caret - getLineStartOffset(caretLine);

			int bracket = TextUtilities.findMatchingBracketFuzzy(
				buffer,caretLine,Math.max(0,dot - 1));
			if(bracket != -1)
			{
				selectNone();
				moveCaretPosition(bracket + 1,false);
				return;
			}
		}

		getToolkit().beep();
	} 

	
	
	public void showGoToLineDialog()
	{
		String line = GUIUtilities.input(view,""goto-line"",null);
		if(line == null)
			return;

		try
		{
			int lineNumber = Integer.parseInt(line) - 1;
			setCaretPosition(getLineStartOffset(lineNumber));
		}
		catch(Exception e)
		{
			getToolkit().beep();
		}
	} 

	

	

	
	
	public void userInput(char ch)
	{
		if(!isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(ch == ' ' && Abbrevs.getExpandOnInput()
			&& Abbrevs.expandAbbrev(view,false))
			return;
		else if(ch == '\t')
		{
			if(selection.size() == 1)
			{
				Selection sel = (Selection)selection.elementAt(0);
				if(sel.startLine == sel.endLine
					&& (sel.start != buffer.getLineStartOffset(sel.startLine)
					|| sel.end != buffer.getLineEndOffset(sel.startLine) - 1))
				{
					insertTab();
				}
				else
					shiftIndentRight();
			}
			else if(selection.size() != 0)
				shiftIndentRight();
			else
				insertTab();
			return;
		}
		else
		{
			boolean indent;

			
			String indentOpenBrackets = (String)buffer
				.getProperty(""indentOpenBrackets"");
			String indentCloseBrackets = (String)buffer
				.getProperty(""indentCloseBrackets"");
			if((indentCloseBrackets != null
				&& indentCloseBrackets.indexOf(ch) != -1)
				|| (indentOpenBrackets != null
				&& indentOpenBrackets.indexOf(ch) != -1))
			{
				indent = true;
			}
			else
			{
				indent = false;
			}

			String str = String.valueOf(ch);
			if(selection.size() != 0)
			{
				setSelectedText(str);
				return;
			}

			if(ch == ' ')
			{
				if(doWordWrap(true))
					return;
			}
			else
				doWordWrap(false);

			try
			{
				
				
				if(overwrite || indent)
					buffer.beginCompoundEdit();

				if(overwrite)
				{
					int caretLineEnd = getLineEndOffset(caretLine);
					if(caretLineEnd - caret > 1)
						buffer.remove(caret,1);
				}

				buffer.insert(caret,str);

				if(indent)
					buffer.indentLine(caretLine,false,true);
			}
			finally
			{
				if(overwrite || indent)
					buffer.endCompoundEdit();
			}

		}
	} 

	
	
	public final boolean isOverwriteEnabled()
	{
		return overwrite;
	} 

	
	
	public final void setOverwriteEnabled(boolean overwrite)
	{
		blink = true;
		caretTimer.restart();

		this.overwrite = overwrite;
		invalidateLine(caretLine);
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
	} 

	
	
	public final void toggleOverwriteEnabled()
	{
		setOverwriteEnabled(!overwrite);
		if(view.getStatus() != null)
		{
			view.getStatus().setMessageAndClear(
				jEdit.getProperty(""view.status.overwrite-changed"",
				new Integer[] { new Integer(overwrite ? 1 : 0) }));
		}
	} 

	
	
	public void backspace()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(selection.size() != 0)
			setSelectedText(null);
		else
		{
			if(caret == 0)
			{
				getToolkit().beep();
				return;
			}

			buffer.remove(caret - 1,1);
		}
	} 

	
	
	public void backspaceWord()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(selection.size() != 0)
		{
			setSelectedText("""");
			return;
		}

		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;

		String lineText = getLineText(caretLine);

		if(_caret == 0)
		{
			if(lineStart == 0)
			{
				getToolkit().beep();
				return;
			}
			_caret--;
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			_caret = TextUtilities.findWordStart(lineText,_caret-1,noWordSep);
		}

		buffer.remove(_caret + lineStart,
			caret - (_caret + lineStart));
	} 

	
	
	public void delete()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(selection.size() != 0)
			setSelectedText(null);
		else
		{
			if(caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}

			buffer.remove(caret,1);
		}
	} 

	
	
	public void deleteToEndOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.remove(caret,getLineEndOffset(caretLine)
			- caret - 1);
	} 

	
	
	public void deleteLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine);
		if(end > buffer.getLength())
		{
			if(start != 0)
				start--;
			end--;
		}
		int x = offsetToX(caretLine,caret - start);

		
		
		try
		{
			buffer.beginCompoundEdit();
			buffer.remove(start,end - start);
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		int lastLine = buffer.getLineCount() - 1;
		if(caretLine == lastLine)
		{
			setCaretPosition(buffer.getLineStartOffset(lastLine)
				+ xToOffset(caretLine,x));
		}
		else
		{
			setCaretPosition(start + xToOffset(caretLine,x));
		}
	} 

	
	
	public void deleteParagraph()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		int start = 0, end = buffer.getLength();

loop:		for(int i = caretLine - 1; i >= 0; i--)
		{
			
			

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					continue loop;
				}
			}

			start = getLineStartOffset(i);
			break loop;
		}

loop:		for(int i = caretLine + 1; i < getLineCount(); i++)
		{
			
			

			getLineText(i,lineSegment);

			for(int j = 0; j < lineSegment.count; j++)
			{
				switch(lineSegment.array[lineSegment.offset + j])
				{
				case ' ':
				case '\t':
					break;
				default:
					continue loop;
				}
			}

			end = getLineEndOffset(i) - 1;
			break loop;
		}

		buffer.remove(start,end - start);
	} 

	
	
	public void deleteToStartOfLine()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.remove(getLineStartOffset(caretLine),
			caret - getLineStartOffset(caretLine));
	} 

	
	
	public void deleteWord()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(selection.size() != 0)
		{
			setSelectedText("""");
			return;
		}

		int lineStart = getLineStartOffset(caretLine);
		int _caret = caret - lineStart;

		String lineText = getLineText(caretLine);

		if(_caret == lineText.length())
		{
			if(lineStart + _caret == buffer.getLength())
			{
				getToolkit().beep();
				return;
			}
			_caret++;
		}
		else
		{
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			_caret = TextUtilities.findWordEnd(lineText,
				_caret+1,noWordSep);
		}

		buffer.remove(caret,(_caret + lineStart) - caret);
	} 

	
	
	public final boolean isMultipleSelectionEnabled()
	{
		return multi;
	} 

	
	
	public final void toggleMultipleSelectionEnabled()
	{
		setMultipleSelectionEnabled(!multi);
		if(view.getStatus() != null)
		{
			view.getStatus().setMessageAndClear(
				jEdit.getProperty(""view.status.multi-changed"",
				new Integer[] { new Integer(multi ? 1 : 0) }));
		}
	} 

	
	
	public final void setMultipleSelectionEnabled(boolean multi)
	{
		this.multi = multi;
		if(view.getStatus() != null)
			view.getStatus().updateMiscStatus();
	} 

	

	

	
	
	public void goToMarker(char shortcut, boolean select)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}

		int pos = marker.getPosition();

		if(select)
			extendSelection(caret,pos);
		else if(!multi)
			selectNone();
		moveCaretPosition(pos);
	} 

	
	
	public void addMarker()
	{
		
		Selection[] selection = getSelection();
		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			if(s.startLine != s.endLine)
			{
				if(s.startLine != caretLine)
					buffer.addMarker('\0',s.start);
			}

			if(s.endLine != caretLine)
				buffer.addMarker('\0',s.end);
		}

		
		buffer.addOrRemoveMarker('\0',caret);
	} 

	
	
	public void swapMarkerAndCaret(char shortcut)
	{
		Marker marker = buffer.getMarker(shortcut);
		if(marker == null)
		{
			getToolkit().beep();
			return;
		}

		int caret = getCaretPosition();

		setCaretPosition(marker.getPosition());
		buffer.addMarker(shortcut,caret);
	} 

	

	

	
	
	public void goToParentFold()
	{
		int line = -1;
		int level = buffer.getFoldLevel(caretLine);
		for(int i = caretLine - 1; i >= 0; i--)
		{
			if(buffer.getFoldLevel(i) < level)
			{
				line = i;
				break;
			}
		}

		if(line == -1)
		{
			getToolkit().beep();
			return;
		}

		int magic = getMagicCaretPosition();

		int newCaret = buffer.getLineStartOffset(line)
			+ xToOffset(line,magic + 1);
		if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void goToNextFold(boolean select)
	{
		int nextFold = -1;
		for(int i = caretLine + 1; i < buffer.getLineCount(); i++)
		{
			if(buffer.isFoldStart(i)
				&& foldVisibilityManager.isLineVisible(i))
			{
				nextFold = i;
				break;
			}
		}

		if(nextFold == -1)
		{
			getToolkit().beep();
			return;
		}

		int magic = getMagicCaretPosition();

		int newCaret = buffer.getLineStartOffset(nextFold)
			+ xToOffset(nextFold,magic + 1);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void goToPrevFold(boolean select)
	{
		int prevFold = -1;
		for(int i = caretLine - 1; i >= 0; i--)
		{
			if(buffer.isFoldStart(i)
				&& foldVisibilityManager.isLineVisible(i))
			{
				prevFold = i;
				break;
			}
		}

		if(prevFold == -1)
		{
			getToolkit().beep();
			return;
		}

		int magic = getMagicCaretPosition();

		int newCaret = buffer.getLineStartOffset(prevFold)
			+ xToOffset(prevFold,magic + 1);
		if(select)
			extendSelection(caret,newCaret);
		else if(!multi)
			selectNone();

		moveCaretPosition(newCaret);
		setMagicCaretPosition(magic);
	} 

	
	
	public void collapseFold()
	{
		int x = offsetToX(caretLine,caret - getLineStartOffset(caretLine));

		foldVisibilityManager.collapseFold(caretLine);

		if(foldVisibilityManager.isLineVisible(caretLine))
			return;

		int line = foldVisibilityManager.getPrevVisibleLine(caretLine);

		if(!multi)
			selectNone();
		moveCaretPosition(buffer.getLineStartOffset(line) + xToOffset(line,x));
	} 

	
	
	public void expandFold(boolean fully)
	{
		int x = offsetToX(caretLine,caret - getLineStartOffset(caretLine));

		int line = foldVisibilityManager.expandFold(caretLine,fully);

		if(!fully && line != -1)
		{
			if(!multi)
				selectNone();
			moveCaretPosition(getLineStartOffset(line) + xToOffset(line,x));
		}
	} 

	
	
	public void selectFold()
	{
		selectFold(caretLine);
	} 

	
	
	public void selectFold(int line)
	{
		int[] lines = buffer.getFoldAtLine(line);

		int newCaret = getLineEndOffset(lines[1]) - 1;
		Selection s = new Selection.Range(getLineStartOffset(lines[0]),newCaret);
		if(multi)
			addToSelection(s);
		else
			setSelection(s);
		moveCaretPosition(newCaret);
	} 

	
	
	public void narrowToFold()
	{
		int[] lines = buffer.getFoldAtLine(caretLine);
		if(lines[0] == 0 && lines[1] == buffer.getLineCount() - 1)
			getToolkit().beep();
		else
			foldVisibilityManager.narrow(lines[0],lines[1]);
	} 

	
	
	public void narrowToSelection()
	{
		if(selection.size() != 1)
		{
			getToolkit().beep();
			return;
		}

		Selection sel = (Selection)selection.elementAt(0);
		foldVisibilityManager.narrow(sel.getStartLine(),sel.getEndLine());

		selectNone();
	} 

	
	
	public void addExplicitFold()
	{
		if(!buffer.getStringProperty(""folding"").equals(""explicit""))
		{
			GUIUtilities.error(view,""folding-not-explicit"",null);
			return;
		}

		
		
		String lineComment = buffer.getContextSensitiveProperty(caret,""lineComment"");
		String commentStart = buffer.getContextSensitiveProperty(caret,""commentStart"");
		String commentEnd = buffer.getContextSensitiveProperty(caret,""commentEnd"");

		String start, end;
		if(lineComment != null)
		{
			start = lineComment + ""{{{ \n"";
			end = lineComment + ""}}}"";
		}
		else if(commentStart != null && commentEnd != null)
		{
			start = commentStart + ""{{{  "" + commentEnd + ""\n"";
			end = commentStart + ""}}}"" + commentEnd;
		}
		else
		{
			start = ""{{{ \n"";
			end = ""}}}"";
		}

		try
		{
			buffer.beginCompoundEdit();

			if(selection.size() == 0)
			{
				String line = buffer.getLineText(caretLine);
				String whitespace = line.substring(0,
					MiscUtilities.getLeadingWhiteSpace(line));
				int loc = caret + start.length() - 1;
				start = start + whitespace;
				buffer.insert(caret,start);
				
				buffer.insert(caret,end);
				moveCaretPosition(loc,false);
			}
			else
			{
				int loc = -1;

				for(int i = 0; i < selection.size(); i++)
				{
					Selection s = (Selection)selection.elementAt(i);
					String line = buffer.getLineText(s.startLine);
					String whitespace = line.substring(0,
						MiscUtilities.getLeadingWhiteSpace(line));
					loc = s.start + start.length() - 1;
					buffer.insert(s.start,start + whitespace);
					buffer.insert(s.end,"" "" + end);
				}

				setCaretPosition(loc,false);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	

	

	
	
	public void lineComment()
	{
		String comment = buffer.getContextSensitiveProperty(caret,""lineComment"");
		if(!buffer.isEditable() || comment == null || comment.length() == 0)
		{
			getToolkit().beep();
			return;
		}

		comment = comment + ' ';

		buffer.beginCompoundEdit();

		int[] lines = getSelectedLines();

		try
		{
			for(int i = 0; i < lines.length; i++)
			{
				String text = getLineText(lines[i]);
				buffer.insert(getLineStartOffset(lines[i])
					+ MiscUtilities.getLeadingWhiteSpace(text),
					comment);
			}
		}
		finally
		{
			buffer.endCompoundEdit();
		}

		selectNone();
	} 

	
	
	public void rangeComment()
	{
		String commentStart = buffer.getContextSensitiveProperty(caret,""commentStart"");
		String commentEnd = buffer.getContextSensitiveProperty(caret,""commentEnd"");
		if(!buffer.isEditable() || commentStart == null || commentEnd == null
			|| commentStart.length() == 0 || commentEnd.length() == 0)
		{
			getToolkit().beep();
			return;
		}

		commentStart = commentStart + ' ';
		commentEnd = ' ' + commentEnd;

		try
		{
			buffer.beginCompoundEdit();

			Selection[] selection = getSelection();

			if(selection.length == 0)
			{
				int oldCaret = caret;
				buffer.insert(caret,commentStart);
				buffer.insert(caret,commentEnd);
				setCaretPosition(oldCaret + commentStart.length());
			}

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				if(s instanceof Selection.Range)
				{
					buffer.insert(s.start,commentStart);
					buffer.insert(s.end,commentEnd);
				}
				else if(s instanceof Selection.Rect)
				{
					Selection.Rect rect = (Selection.Rect)s;
					int start = rect.getStartColumn(buffer);
					int end = rect.getEndColumn(buffer);

					for(int j = s.startLine; j <= s.endLine; j++)
					{
						buffer.insertAtColumn(j,end,
							commentEnd);
						buffer.insertAtColumn(j,start,
							commentStart);
					}
				}
			}

			selectNone();
		}
		finally
		{
			buffer.endCompoundEdit();
		}
	} 

	
	
	public void formatParagraph()
	{
		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(maxLineLen <= 0)
		{
			getToolkit().beep();
			return;
		}

		Selection[] selection = getSelection();
		if(selection.length != 0)
		{
			buffer.beginCompoundEdit();

			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.format(
					getSelectedText(s),maxLineLen,
					buffer.getTabSize()));
			}

			buffer.endCompoundEdit();
		}
		else
		{
			int lineNo = getCaretLine();

			int start = 0, end = buffer.getLength();

loop:			for(int i = lineNo - 1; i >= 0; i--)
			{
				getLineText(i,lineSegment);

				for(int j = 0; j < lineSegment.count; j++)
				{
					switch(lineSegment.array[lineSegment.offset + j])
					{
					case ' ':
					case '\t':
						break;
					default:
						continue loop;
					}
				}

				start = getLineEndOffset(i);
				break loop;
			}

loop:			for(int i = lineNo + 1; i < getLineCount(); i++)
			{
				getLineText(i,lineSegment);

				for(int j = 0; j < lineSegment.count; j++)
				{
					switch(lineSegment.array[lineSegment.offset + j])
					{
					case ' ':
					case '\t':
						break;
					default:
						continue loop;
					}
				}

				end = getLineStartOffset(i) - 1;
				break loop;
			}

			try
			{
				buffer.beginCompoundEdit();

				String text = buffer.getText(start,end - start);
				buffer.remove(start,end - start);
				buffer.insert(start,TextUtilities.format(
					text,maxLineLen,buffer.getTabSize()));
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} 

	
	
	public void spacesToTabs()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.beginCompoundEdit();

		if(selection.length == 0)
		{
			setText(TextUtilities.spacesToTabs(
				getText(), buffer.getTabSize()));
		}
		else
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.spacesToTabs(
					getSelectedText(s),buffer.getTabSize()));
			}
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void tabsToSpaces()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable())
		{
			getToolkit().beep();
			return;
		}

		buffer.beginCompoundEdit();

		if(selection.length == 0)
		{
			setText(TextUtilities.tabsToSpaces(
				getText(), buffer.getTabSize()));
		}
		else
		{
			for(int i = 0; i < selection.length; i++)
			{
				Selection s = selection[i];
				setSelectedText(s,TextUtilities.tabsToSpaces(
					getSelectedText(s),buffer.getTabSize()));
			}
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void toUpperCase()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }

		buffer.beginCompoundEdit();

		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toUpperCase());
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void toLowerCase()
	{
		Selection[] selection = getSelection();

		if(!buffer.isEditable() || selection.length == 0)
                {
                	getToolkit().beep();
                	return;
                }

		buffer.beginCompoundEdit();

		for(int i = 0; i < selection.length; i++)
		{
			Selection s = selection[i];
			setSelectedText(s,getSelectedText(s).toLowerCase());
		}

		buffer.endCompoundEdit();
	} 

	
	
	public void removeTrailingWhiteSpace()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.removeTrailingWhiteSpace(getSelectedLines());
		}
	} 

	
	public void insertEnterAndIndent()
	{
		if(!isEditable())
			getToolkit().beep();
		else
		{
			try
			{
				buffer.beginCompoundEdit();
				setSelectedText(""\n"");
				buffer.indentLine(caretLine,true,false);
			}
			finally
			{
				buffer.endCompoundEdit();
			}
		}
	} 

	
	public void insertTabAndIndent()
	{
		if(!isEditable())
		{
			getToolkit().beep();
			return;
		}

		if(selection.size() == 0)
		{
			
			String text = buffer.getLineText(caretLine);
			int start = buffer.getLineStartOffset(caretLine);
			int whiteSpace = MiscUtilities.getLeadingWhiteSpace(text);

			if(caret - start <= whiteSpace
				&& buffer.indentLine(caretLine,true,false))
				return;
		}

		userInput('\t');
	} 

	
	
	public void indentSelectedLines()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.indentLines(getSelectedLines());
			selectNone();
		}
	} 

	
	
	public void shiftIndentLeft()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
		{
			buffer.shiftIndentLeft(getSelectedLines());
		}
	} 

	
	
	public void shiftIndentRight()
	{
		if(!buffer.isEditable())
			getToolkit().beep();
		else
			buffer.shiftIndentRight(getSelectedLines());
	} 

	
	
	public void joinLines()
	{
		int end = getLineEndOffset(caretLine);
		if(end > buffer.getLength())
		{
			getToolkit().beep();
			return;
		}
		buffer.remove(end - 1,MiscUtilities.getLeadingWhiteSpace(
			buffer.getLineText(caretLine + 1)) + 1);

		setCaretPosition(end - 1);
	} 

	
	
	public void showWordCountDialog()
	{
		String selection = getSelectedText();
		if(selection != null)
		{
			doWordCount(view,selection);
			return;
		}

		doWordCount(view,buffer.getText(0,buffer.getLength()));
	} 

	

	

	
	
	public void addNotify()
	{
		super.addNotify();

		ToolTipManager.sharedInstance().registerComponent(painter);
		ToolTipManager.sharedInstance().registerComponent(gutter);

		if(!bufferHandlerInstalled)
		{
			bufferHandlerInstalled = true;
			buffer.addBufferChangeListener(bufferHandler);
		}

		recalculateVisibleLines();
		recalculateLastPhysicalLine();
	} 

	
	
	public void removeNotify()
	{
		super.removeNotify();

		ToolTipManager.sharedInstance().unregisterComponent(painter);
		ToolTipManager.sharedInstance().unregisterComponent(gutter);

		if(focusedComponent == this)
			focusedComponent = null;

		if(bufferHandlerInstalled)
		{
			buffer.removeBufferChangeListener(bufferHandler);
			bufferHandlerInstalled = false;
		}
	} 

	
	
	public boolean hasFocus()
	{
		Component c = this;
		while(!(c instanceof Window))
		{
			if(c == null)
				return false;
			c = c.getParent();
		}

		Component focusOwner = ((Window)c).getFocusOwner();
		boolean hasFocus = (focusOwner == this);
		if(hasFocus)
			focusedComponent = this;
		return hasFocus;
	} 

	
	
	public void grabFocus()
	{
		super.grabFocus();
		
		hasFocus();
	} 

	
	
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} 

	
	
	long time;
	boolean timing;
	public void processKeyEvent(KeyEvent evt)
	{
		time = System.currentTimeMillis();

		evt = KeyEventWorkaround.processKeyEvent(evt);
		if(evt == null)
			return;

		
		if(view.isClosed())
			return;

		InputHandler inputHandler = view.getInputHandler();
		KeyListener keyEventInterceptor = view.getKeyEventInterceptor();
		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyTyped(evt);
			else
				inputHandler.keyTyped(evt);
			break;
		case KeyEvent.KEY_PRESSED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyPressed(evt);
			else
				inputHandler.keyPressed(evt);
			break;
		case KeyEvent.KEY_RELEASED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyReleased(evt);
			else
				inputHandler.keyReleased(evt);
			break;
		}

		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	

	
	
	public void propertiesChanged()
	{
		if(buffer == null)
			return;

		int _tabSize = buffer.getTabSize();
		char[] foo = new char[_tabSize];
		for(int i = 0; i < foo.length; i++)
		{
			foo[i] = ' ';
		}

		tabSize = (float)painter.getFont().getStringBounds(foo,0,_tabSize,
			painter.getFontRenderContext()).getWidth();

		charWidth = (int)Math.round(painter.getFont().getStringBounds(foo,0,1,
			painter.getFontRenderContext()).getWidth());

		String wrap = buffer.getStringProperty(""wrap"");
		softWrap = wrap.equals(""soft"");
		hardWrap = wrap.equals(""hard"");

		maxLineLen = buffer.getIntegerProperty(""maxLineLen"",0);

		if(maxLineLen <= 0)
		{
			if(softWrap)
			{
				wrapToWidth = true;
				wrapMargin = painter.getWidth() - charWidth * 3;
			}
			else
			{
				wrapToWidth = false;
				wrapMargin = 0;
			}
		}
		else
		{
			
			foo = new char[maxLineLen];
			for(int i = 0; i < foo.length; i++)
			{
				foo[i] = ' ';
			}
			wrapToWidth = false;
			wrapMargin = (int)painter.getFont().getStringBounds(
				foo,0,maxLineLen,painter.getFontRenderContext())
				.getWidth();
		}

		monospacedHack = jEdit.getBooleanProperty(""view.monospacedHack"");

		maxHorizontalScrollWidth = 0;
		updateScrollBars();

		chunkCache.invalidateAll();
		gutter.repaint();
		painter.repaint();
	} 

	

	
	
	public int offsetToX(int line, int offset)
	{
		Chunk chunks = chunkCache.lineToChunkList(line);
		return (int)(horizontalOffset + Chunk.offsetToX(chunks,offset));
	} 

	
	
	public int xToOffset(int line, int x)
	{
		x -= horizontalOffset;
		Chunk chunks = chunkCache.lineToChunkList(line);
		int offset = Chunk.xToOffset(chunks,x,true);
		if(offset == -1)
			offset = getLineLength(line);
		return offset;
	} 

	
	
	public int xToOffset(int line, int x, boolean round)
	{
		x -= horizontalOffset;
		Chunk chunks = chunkCache.lineToChunkList(line);
		int offset = Chunk.xToOffset(chunks,x,round);
		if(offset == -1)
			offset = getLineLength(line);
		return offset;
	} 

	
	
	public final int getSelectionStart()
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getStart();
	} 

	
	
	public int getSelectionStart(int line)
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getStart(
			buffer,line);
	} 

	
	
	public final int getSelectionStartLine()
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getStartLine();
	} 

	
	
	public final void setSelectionStart(int selectionStart)
	{
		select(selectionStart,getSelectionEnd(),true);
	} 

	
	
	public final int getSelectionEnd()
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getEnd();
	} 

	
	
	public int getSelectionEnd(int line)
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getEnd(
			buffer,line);
	} 

	
	
	public final int getSelectionEndLine()
	{
		if(selection.size() != 1)
			return caret;

		return ((Selection)selection.elementAt(0)).getEndLine();
	} 

	
	
	public final void setSelectionEnd(int selectionEnd)
	{
		select(getSelectionStart(),selectionEnd,true);
	} 

	
	
	public final int getMarkPosition()
	{
		Selection s = getSelectionAtOffset(caret);
		if(s == null)
			return caret;

		if(s.start == caret)
			return s.end;
		else if(s.end == caret)
			return s.start;
		else
			return caret;
	} 

	
	
	public final int getMarkLine()
	{
		if(selection.size() != 1)
			return caretLine;

		Selection s = (Selection)selection.elementAt(0);
		if(s.start == caret)
			return s.endLine;
		else if(s.end == caret)
			return s.startLine;
		else
			return caretLine;
	} 

	
	
	public void select(int start, int end)
	{
		select(start,end,true);
	} 

	
	
	public void select(int start, int end, boolean doElectricScroll)
	{
		selectNone();

		int newStart, newEnd;
		if(start < end)
		{
			newStart = start;
			newEnd = end;
		}
		else
		{
			newStart = end;
			newEnd = start;
		}

		setSelection(new Selection.Range(newStart,newEnd));
		moveCaretPosition(end,doElectricScroll);
	} 

	
	
	public boolean isSelectionRectangular()
	{
		Selection s = getSelectionAtOffset(caret);
		if(s == null)
			return false;
		else
			return (s instanceof Selection.Rect);
	} 

	

	

	
	Segment lineSegment;
	MouseHandler mouseHandler;
	ChunkCache chunkCache;

	int maxHorizontalScrollWidth;

	boolean softWrap;
	boolean hardWrap;
	float tabSize;
	int wrapMargin;
	boolean wrapToWidth;
	int charWidth;
	boolean monospacedHack;

	boolean scrollBarsInitialized;

	
	
	
	
	
	
	boolean queuedScrollTo;
	boolean queuedScrollToElectric;
	boolean queuedFireCaretEvent;
	ArrayList runnables;

	
	
	Vector selection;

	
	Point returnValue;
	

	
	
	final boolean isCaretVisible()
	{
		return blink && hasFocus();
	} 

	
	
	final boolean isBracketHighlightVisible()
	{
		return bracketLine != -1
			&& hasFocus()
			&& foldVisibilityManager.isLineVisible(bracketLine)
			&& foldVisibilityManager.isLineVisible(caretLine);
	} 

	
	void updateMaxHorizontalScrollWidth()
	{
		int max = chunkCache.getMaxHorizontalScrollWidth();

		if(max != maxHorizontalScrollWidth)
		{
			maxHorizontalScrollWidth = max;
			horizontal.setValues(Math.max(0,
				Math.min(maxHorizontalScrollWidth + charWidth
				- painter.getWidth(),
				-horizontalOffset)),
				painter.getWidth(),
				0,maxHorizontalScrollWidth
				+ charWidth);
		}
	} 

	
	void recalculateVisibleLines()
	{
		if(painter == null)
			return;
		int height = painter.getHeight();
		int lineHeight = painter.getFontMetrics().getHeight();
		visibleLines = height / lineHeight;
		lastLinePartial = (height % lineHeight != 0);

		chunkCache.recalculateVisibleLines();
		propertiesChanged();
	} 

	
	void foldStructureChanged()
	{
		chunkCache.invalidateAll();

		

		physFirstLine = virtualToPhysical(Math.min(foldVisibilityManager
			.getVirtualLineCount() - 1,firstLine));
		setFirstLine(physicalToVirtual(physFirstLine));

		
		
		updateScrollBars();

		recalculateLastPhysicalLine();

		
		gutter.repaint();
		painter.repaint();
	} 

	
	
	
	 int getSubregionOfOffset(int offset, ChunkCache.LineInfo[] lineInfos)
	{
		
		for(int i = 0; i < lineInfos.length; i++)
		{
			ChunkCache.LineInfo info = lineInfos[i];
			if(offset >= info.offset && offset < info.offset + info.length)
				return i;
		}

		return -1;
	} 

	
	
	
	 int xToSubregionOffset(ChunkCache.LineInfo info, float x,
		boolean round)
	{
		int offset = Chunk.xToOffset(info.chunks,
			x - horizontalOffset,round);
		if(offset == -1 || offset == info.offset + info.length)
			offset = info.offset + info.length - 1;

		return offset;
	} 

	
	
	
	 int subregionOffsetToX(ChunkCache.LineInfo info, int offset)
	{
		return (int)(horizontalOffset + Chunk.offsetToX(
			info.chunks,offset));
	} 

	
	
	
	 

	
	
	
	 

	

	

	
	private static String CENTER = ""center"";
	private static String RIGHT = ""right"";
	private static String LEFT = ""left"";
	private static String BOTTOM = ""bottom"";

	private static Timer caretTimer;
	private static JEditTextArea focusedComponent;
	

	
	private View view;
	private Gutter gutter;
	private TextAreaPainter painter;

	private JPopupMenu popup;

	private EventListenerList listenerList;
	private MutableCaretEvent caretEvent;

	private boolean caretBlinks;
	private boolean blink;

	private int firstLine;
	private int physFirstLine;
	private int physLastLine;
	private int screenLastLine;
	private boolean lastLinePartial;

	private int visibleLines;
	private int electricScroll;

	private int horizontalOffset;

	private boolean quickCopy;

	private JScrollBar vertical;
	private JScrollBar horizontal;

	private boolean bufferChanging;
	private Buffer buffer;
	private FoldVisibilityManager foldVisibilityManager;
	private BufferChangeHandler bufferHandler;
	private boolean bufferHandlerInstalled;

	private int caret;
	private int caretLine;
	private int caretScreenLine;

	private int bracketPosition;
	private int bracketLine;

	private int magicCaret;

	private boolean multi;
	private boolean overwrite;

	private int maxLineLen;
	

	
	private void _addToSelection(Selection addMe)
	{
		if(addMe.start > addMe.end)
		{
			throw new IllegalArgumentException(addMe.start
				+ "" > "" + addMe.end);
		}
		else if(addMe.start == addMe.end)
		{
			if(addMe instanceof Selection.Range)
				return;
			else if(addMe instanceof Selection.Rect)
			{
				if(((Selection.Rect)addMe).extraEndVirt == 0)
					return;
			}
		}

		for(int i = 0; i < selection.size(); i++)
		{
			
			
			Selection s = (Selection)selection.elementAt(i);
			if(s.overlaps(addMe))
			{
				addMe.start = Math.min(s.start,addMe.start);
				addMe.end = Math.max(s.end,addMe.end);

				selection.removeElement(s);
				i--;
			}
		}

		addMe.startLine = getLineOfOffset(addMe.start);
		addMe.endLine = getLineOfOffset(addMe.end);

		boolean added = false;

		for(int i = 0; i < selection.size(); i++)
		{
			Selection s = (Selection)selection.elementAt(i);
			if(addMe.start < s.start)
			{
				selection.insertElementAt(addMe,i);
				added = true;
				break;
			}
		}

		if(!added)
			selection.addElement(addMe);

		invalidateLineRange(addMe.startLine,addMe.endLine);
	} 

	
	
	private void finishCaretUpdate(boolean doElectricScroll,
		boolean fireCaretEvent)
	{
		if(queuedScrollTo)
			return;

		this.queuedScrollToElectric |= doElectricScroll;
		this.queuedFireCaretEvent |= fireCaretEvent;

		Runnable r = new Runnable()
		{
			public void run()
			{
				
				
				blink = true;
				caretTimer.restart();

				scrollToCaret(queuedScrollToElectric);
				updateBracketHighlight();
				if(queuedFireCaretEvent)
					fireCaretEvent();
				queuedScrollTo = queuedScrollToElectric
					= queuedFireCaretEvent = false;
			}
		};

		if(buffer.isTransactionInProgress())
		{
			queuedScrollTo = true;
			runnables.add(r);
		}
		else
			r.run();
	} 

	
	private void fireCaretEvent()
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == CaretListener.class)
			{
				try
				{
					((CaretListener)listeners[i+1]).caretUpdate(caretEvent);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	} 

	
	private void fireScrollEvent(boolean vertical)
	{
		Object[] listeners = listenerList.getListenerList();
		for(int i = listeners.length - 2; i >= 0; i--)
		{
			if(listeners[i] == ScrollListener.class)
			{
				try
				{
					if(vertical)
						((ScrollListener)listeners[i+1]).scrolledVertically(this);
					else
						((ScrollListener)listeners[i+1]).scrolledHorizontally(this);
				}
				catch(Throwable t)
				{
					Log.log(Log.ERROR,this,t);
				}
			}
		}
	} 

	
	private void insertTab()
	{
		int tabSize = buffer.getTabSize();
		if(buffer.getBooleanProperty(""noTabs""))
		{
			int lineStart = getLineStartOffset(caretLine);

			String line = getText(lineStart,caret - lineStart);

			int pos = 0;

			for(int i = 0; i < line.length(); i++)
			{
				switch(line.charAt(pos))
				{
				case '\t':
					pos = 0;
					break;
				default:
					if(++pos >= tabSize)
						pos = 0;
					break;
				}
			}

			setSelectedText(MiscUtilities.createWhiteSpace(
				tabSize - pos,0));
		}
		else
			setSelectedText(""\t"");
	} 

	
	private boolean doWordWrap(boolean spaceInserted)
	{
		if(!hardWrap || maxLineLen <= 0)
			return false;

		buffer.getLineText(caretLine,lineSegment);

		int start = getLineStartOffset(caretLine);
		int end = getLineEndOffset(caretLine);
		int len = end - start - 1;

		int caretPos = caret - start;

		
		
		for(int i = caretPos; i < len; i++)
		{
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch != ' ' && ch != '\t')
				return false;
		}

		boolean returnValue = false;

		int tabSize = buffer.getTabSize();

		String wordBreakChars = buffer.getStringProperty(""wordBreakChars"");

		int logicalLength = 0; 
		int lastWordOffset = -1;
		boolean lastWasSpace = true;
		for(int i = 0; i < caretPos; i++)
		{
			char ch = lineSegment.array[lineSegment.offset + i];
			if(ch == '\t')
			{
				logicalLength += tabSize - (logicalLength % tabSize);
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(ch == ' ')
			{
				logicalLength++;
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else if(wordBreakChars != null && wordBreakChars.indexOf(ch) != -1)
			{
				logicalLength++;
				if(!lastWasSpace && logicalLength <= maxLineLen)
				{
					lastWordOffset = i;
					lastWasSpace = true;
				}
			}
			else
			{
				logicalLength++;
				lastWasSpace = false;
			}

			int insertNewLineAt;
			if(spaceInserted && logicalLength == maxLineLen
				&& i == caretPos - 1)
			{
				insertNewLineAt = caretPos;
				returnValue = true;
			}
			else if(logicalLength >= maxLineLen && lastWordOffset != -1)
				insertNewLineAt = lastWordOffset;
			else
				continue;

			try
			{
				buffer.beginCompoundEdit();
				buffer.insert(start + insertNewLineAt,""\n"");
				
				
				buffer.indentLine(caretLine,true,true);
			}
			finally
			{
				buffer.endCompoundEdit();
			}

			
			return returnValue;
		}

		return false;
	} 

	
	private void doWordCount(View view, String text)
	{
		char[] chars = text.toCharArray();
		int characters = chars.length;
		int words;
		if(characters == 0)
			words = 0;
		else
			words = 1;
		int lines = 1;
		boolean word = false;
		for(int i = 0; i < chars.length; i++)
		{
			switch(chars[i])
			{
			case '\r': case '\n':
				lines++;
			case ' ': case '\t':
				if(word)
				{
					words++;
					word = false;
				}
				break;
			default:
				word = true;
				break;
			}
		}
		Object[] args = { new Integer(characters), new Integer(words),
			new Integer(lines) };
		GUIUtilities.message(view,""wordcount"",args);
	} 

	
	private void updateBracketHighlight()
	{
		if(!painter.isBracketHighlightEnabled())
			return;

		if(bracketLine != -1)
			invalidateLineRange(bracketLine,caretLine);

		int offset = caret - getLineStartOffset(caretLine);

		if(offset != 0)
		{
			int bracketOffset = TextUtilities.findMatchingBracketFuzzy(
				buffer,caretLine,offset - 1);
			if(bracketOffset != -1)
			{
				bracketLine = getLineOfOffset(bracketOffset);
				bracketPosition = bracketOffset
					- getLineStartOffset(bracketLine);
				invalidateLineRange(bracketLine,caretLine);

				if(bracketLine < physFirstLine
					|| bracketLine > physLastLine)
				{
					showBracketStatusMessage(bracketLine < caretLine);
				}
				return;
			}
		}

		bracketLine = bracketPosition = -1;
	} 

	
	private void showBracketStatusMessage(boolean backward)
	{
		String text = buffer.getLineText(bracketLine).trim();
		if(backward && bracketLine != 0 && text.length() == 1)
		{
			switch(text.charAt(0))
			{
			case '{': case '}':
			case '[': case ']':
			case '(': case ')':
				text = buffer.getLineText(bracketLine - 1).trim()
					+ "" "" + text;
				break;
			}
		}

		
		text = text.replace('\t',' ');

		view.getStatus().setMessageAndClear(jEdit.getProperty(
			""view.status.bracket"",new String[] { text }));
	} 

	
	void recalculateLastPhysicalLine()
	{
		if(softWrap)
		{
			chunkCache.updateChunksUpTo(visibleLines);
			for(int i = visibleLines; i >= 0; i--)
			{
				ChunkCache.LineInfo info = chunkCache.getLineInfo(i);
				if(info.physicalLine != -1)
				{
					physLastLine = info.physicalLine;
					screenLastLine = i;
					break;
				}
			}
		}
		else
		{
			
			int virtLastLine = Math.min(foldVisibilityManager
				.getVirtualLineCount() - 1,
				firstLine + visibleLines);
			screenLastLine = virtLastLine - firstLine;
			physLastLine = foldVisibilityManager.virtualToPhysical(
				virtLastLine);
		}
	} 

	

	

	
	static class TextAreaBorder extends AbstractBorder
	{
		private static final Insets insets = new Insets(1, 1, 2, 2);

		
		public void paintBorder(Component c, Graphics g, int x, int y,
			int width, int height)
		{
			g.translate(x,y);

			g.setColor(MetalLookAndFeel.getControlDarkShadow());
			g.drawRect(0,0,width-2,height-2);

			g.setColor(MetalLookAndFeel.getControlHighlight());
			g.drawLine(width-1,1,width-1,height-1);
			g.drawLine(1,height-1,width-1,height-1);

			g.setColor(MetalLookAndFeel.getControl());
			g.drawLine(width-2,2,width-2,2);
			g.drawLine(1,height-2,1,height-2);

			g.translate(-x,-y);
		} 

		
		public Insets getBorderInsets(Component c)
		{
			return new Insets(1,1,2,2);
		} 
	} 

	
	class ScrollLayout implements LayoutManager
	{
		
		public void addLayoutComponent(String name, Component comp)
		{
			if(name.equals(CENTER))
				center = comp;
			else if(name.equals(RIGHT))
				right = comp;
			else if(name.equals(LEFT))
				left = comp;
			else if(name.equals(BOTTOM))
				bottom = comp;
		} 

		
		public void removeLayoutComponent(Component comp)
		{
			if(center == comp)
				center = null;
			else if(right == comp)
				right = null;
			else if(left == comp)
				left = null;
			else if(bottom == comp)
				bottom = null;
		} 

		
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}

			dim.width = insets.left + insets.right;
			dim.height = insets.top + insets.bottom;

			Dimension leftPref = left.getPreferredSize();
			dim.width += leftPref.width;
			Dimension centerPref = center.getPreferredSize();
			dim.width += centerPref.width;
			dim.height += centerPref.height;
			Dimension rightPref = right.getPreferredSize();
			dim.width += rightPref.width;
			Dimension bottomPref = bottom.getPreferredSize();
			dim.height += bottomPref.height;

			return dim;
		} 

		
		public Dimension minimumLayoutSize(Container parent)
		{
			Dimension dim = new Dimension();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}

			dim.width = insets.left + insets.right;
			dim.height = insets.top + insets.bottom;

			Dimension leftPref = left.getMinimumSize();
			dim.width += leftPref.width;
			Dimension centerPref = center.getMinimumSize();
			dim.width += centerPref.width; 
			dim.height += centerPref.height;
			Dimension rightPref = right.getMinimumSize();
			dim.width += rightPref.width;
			Dimension bottomPref = bottom.getMinimumSize();
			dim.height += bottomPref.height;

			return dim;
		} 

		
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();
			Border border = getBorder();
			Insets insets;
			if(border == null)
				insets = new Insets(0,0,0,0);
			else
			{
				insets = getBorder().getBorderInsets(
					JEditTextArea.this);
			}

			int itop = insets.top;
			int ileft = insets.left;
			int ibottom = insets.bottom;
			int iright = insets.right;

			int rightWidth = right.getPreferredSize().width;
			int leftWidth = left.getPreferredSize().width;
			int bottomHeight = bottom.getPreferredSize().height;
			int centerWidth = Math.max(0,size.width - leftWidth
				- rightWidth - ileft - iright);
			int centerHeight = Math.max(0,size.height
				- bottomHeight - itop - ibottom);

			left.setBounds(
				ileft,
				itop,
				leftWidth,
				centerHeight);

			center.setBounds(
				ileft + leftWidth,
				itop,
				centerWidth,
				centerHeight);

			right.setBounds(
				ileft + leftWidth + centerWidth,
				itop,
				rightWidth,
				centerHeight);

			bottom.setBounds(
				ileft,
				itop + centerHeight,
				Math.max(0,size.width - rightWidth - ileft - iright),
				bottomHeight);
		} 

		Component center;
		Component left;
		Component right;
		Component bottom;
	} 

	
	static class CaretBlinker implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			if(focusedComponent != null && focusedComponent.hasFocus())
				focusedComponent.blinkCaret();
		} 
	} 

	
	class MutableCaretEvent extends CaretEvent
	{
		
		MutableCaretEvent()
		{
			super(JEditTextArea.this);
		} 

		
		public int getDot()
		{
			return getCaretPosition();
		} 

		
		public int getMark()
		{
			return getMarkPosition();
		} 
	} 

	
	class AdjustHandler implements AdjustmentListener
	{
		
		public void adjustmentValueChanged(final AdjustmentEvent evt)
		{
			if(!scrollBarsInitialized)
				return;

			if(evt.getAdjustable() == vertical)
				setFirstLine(vertical.getValue());
			else
				setHorizontalOffset(-horizontal.getValue());
		} 
	} 

	
	
	class BufferChangeHandler implements BufferChangeListener
	{
		boolean delayedUpdate;
		boolean delayedMultilineUpdate;
		int delayedRepaintStart;
		int delayedRepaintEnd;
		boolean delayedRecalculateLastPhysicalLine;
		
		
		
		Position holdPosition;

		
		public void foldLevelChanged(Buffer buffer, int start, int end)
		{
			if(!bufferChanging && end != 0 && buffer.isLoaded())
			{
				invalidateLineRange(start - 1,end - 1);
			}
		} 

		
		public void contentInserted(Buffer buffer, int startLine, int start,
			int numLines, int length)
		{
			
			
			
			chunkCache.invalidateChunksFromPhys(startLine);

			_recalculateLastPhysicalLine(numLines);

			if(!buffer.isLoaded())
				return;

			repaintAndScroll(startLine,numLines);

			
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);

				boolean changed = false;

				if((s instanceof Selection.Rect && s.start > start)
					|| (s instanceof Selection.Range && s.start >= start))
				{
					s.start += length;
					if(numLines != 0)
						s.startLine = getLineOfOffset(s.start);
					changed = true;
				}

				if(s.end >= start)
				{
					s.end += length;
					if(numLines != 0)
						s.endLine = getLineOfOffset(s.end);
					changed = true;
				}

				if(changed)
				{
					delayedRepaintStart = Math.min(
						delayedRepaintStart,
						s.startLine);
					delayedRepaintEnd = Math.max(
						delayedRepaintEnd,
						s.endLine);
				}
			} 

			
			
			if(!buffer.isTransactionInProgress())
				transactionComplete(buffer);

			if(caret >= start)
				moveCaretPosition(caret + length,true);
			else
			{
				
				moveCaretPosition(caret);
			}
		}
		

		
		public void contentRemoved(Buffer buffer, int startLine, int start,
			int numLines, int length)
		{
			
			
			
			chunkCache.invalidateChunksFromPhys(startLine);

			if(!buffer.isLoaded())
				return;

			
			repaintAndScroll(startLine,-numLines);
			_recalculateLastPhysicalLine(-numLines);

			int end = start + length;

			
			for(int i = 0; i < selection.size(); i++)
			{
				Selection s = (Selection)selection.elementAt(i);

				boolean changed = false;

				if(s.start > start && s.start <= end)
				{
					s.start = start;
					changed = true;
				}
				else if(s.start > end)
				{
					s.start -= length;
					changed = true;
				}

				if(s.end > start && s.end <= end)
				{
					s.end = start;
					changed = true;
				}
				else if(s.end > end)
				{
					s.end -= length;
					changed = true;
				}

				if(s.start == s.end)
				{
					selection.removeElement(s);
					delayedRepaintStart = Math.min(
						delayedRepaintStart,
						s.startLine);
					delayedRepaintEnd = Math.max(
						delayedRepaintEnd,
						s.endLine);
					i--;
				}
				else if(changed)
				{
					if(numLines != 0)
					{
						s.startLine = getLineOfOffset(s.start);
						s.endLine = getLineOfOffset(s.end);
					}
					delayedRepaintStart = Math.min(
						delayedRepaintStart,
						s.startLine);
					delayedRepaintEnd = Math.max(
						delayedRepaintEnd,
						s.endLine);
				}
			} 

			
			
			
			int oldFirstLine = getFirstLine();

			if(caret > start && caret <= end)
				moveCaretPosition(start,false);
			else if(caret > end)
				moveCaretPosition(caret - length,false);
			else
			{
				
				moveCaretPosition(caret);
			}

			if(getFirstLine() != oldFirstLine)
			{
				
				holdPosition = null;
			}

			
			if(!buffer.isTransactionInProgress())
				transactionComplete(buffer);
		}
		

		
		public void transactionComplete(Buffer buffer)
		{
			if(delayedUpdate)
			{
				

				if(holdPosition != null)
				{
					setFirstLine(physicalToVirtual(
						getBuffer().getLineOfOffset(
						holdPosition.getOffset())));
					holdPosition = null;
				}

				if(delayedMultilineUpdate)
				{
					updateScrollBars();
					invalidateScreenLineRange(chunkCache
						.getScreenLineOfOffset(
						delayedRepaintStart,0),
						screenLastLine);
					delayedMultilineUpdate = false;
				}
				else
				{
					invalidateLineRange(delayedRepaintStart,
						delayedRepaintEnd);
				}

				delayedUpdate = false;
			}

			if(delayedRecalculateLastPhysicalLine)
			{
				int oldScreenLastLine = screenLastLine;
				recalculateLastPhysicalLine();
				invalidateScreenLineRange(oldScreenLastLine,
					screenLastLine);
				delayedRecalculateLastPhysicalLine = false;
			}

			for(int i = 0; i < runnables.size(); i++)
				((Runnable)runnables.get(i)).run();
			runnables.clear();
		} 

		
		private void _recalculateLastPhysicalLine(int numLines)
		{
			
			
			if(numLines != 0 || (softWrap && getFoldVisibilityManager()
				.getLastVisibleLine() - numLines <= getLastPhysicalLine()))
			{
				delayedRecalculateLastPhysicalLine = true;
			}
		} 

		
		private void repaintAndScroll(int startLine, int numLines)
		{
			if(numLines != 0)
				delayedMultilineUpdate = true;

			if(!delayedUpdate)
			{
				delayedRepaintStart = startLine;
				delayedRepaintEnd = startLine;
				delayedUpdate = true;
			}
			else
			{
				delayedRepaintStart = Math.min(
					delayedRepaintStart,
					startLine);
				delayedRepaintEnd = Math.max(
					delayedRepaintEnd,
					startLine);
			}

			
			
			
			
			if(holdPosition != null)
				return;
			if(startLine < getFirstPhysicalLine())
			{
				if(startLine < getFoldVisibilityManager().getFirstVisibleLine())
				{
					
					physFirstLine = virtualToPhysical(firstLine);
					delayedRecalculateLastPhysicalLine = true;
					return;
				}

				int virtStartLine = physicalToVirtual(startLine);

				int pos;

				int virtLine = getFirstLine() + physicalToVirtual(
					Math.max(0,startLine + numLines))
					- virtStartLine;
				if(virtLine < 0)
					pos = 0;
				else if(virtLine >= getVirtualLineCount())
					pos = getBufferLength();
				else
				{
					pos = buffer.getLineStartOffset(
						virtualToPhysical(virtLine));
				}

				holdPosition = buffer.createPosition(pos);
			}
		} 
	} 

	
	class FocusHandler implements FocusListener
	{
		
		public void focusGained(FocusEvent evt)
		{
			if(bufferChanging)
				return;

			if(bracketLine != -1)
				invalidateLineRange(bracketLine,caretLine);
			else
				invalidateLine(caretLine);

			
			
			view.updateGutterBorders();
		} 

		
		public void focusLost(FocusEvent evt)
		{
			if(!isShowing())
				return;

			if(bracketLine != -1)
				invalidateLineRange(bracketLine,caretLine);
			else
				invalidateLine(caretLine);
		} 
	} 

	
	class MouseHandler extends MouseInputAdapter
	{
		private int dragStartLine;
		private int dragStartOffset;
		private int dragStart;
		private int clickCount;
		private boolean dragged;
		private boolean quickCopyDrag;
		private boolean clearStatus;
		private boolean control;

		
		public void mousePressed(MouseEvent evt)
		{
			control = (OperatingSystem.isMacOS() && evt.isMetaDown())
				|| (!OperatingSystem.isMacOS() && evt.isControlDown());

			
			
			view.getInputHandler().resetLastActionCount();

			grabFocus();

			if(GUIUtilities.isPopupTrigger(evt) && popup != null)
			{
				if(popup.isVisible())
					popup.setVisible(false);
				else
				{
					GUIUtilities.showPopupMenu(popup,painter,
						evt.getX(),evt.getY());
				}
				return;
			}

			quickCopyDrag = (isQuickCopyEnabled()
				&& GUIUtilities.isMiddleButton(evt.getModifiers()));
			blink = true;
			invalidateLine(caretLine);

			int x = evt.getX();
			int y = evt.getY();

			dragStart = xyToOffset(x,y,!(painter.isBlockCaretEnabled()
				|| isOverwriteEnabled()));
			dragStartLine = getLineOfOffset(dragStart);
			dragStartOffset = dragStart - getLineStartOffset(dragStartLine);

			dragged = false;

			clickCount = evt.getClickCount();

			switch(clickCount)
			{
			case 1:
				doSingleClick(evt);
				break;
			case 2:
				doDoubleClick(evt);
				break;
			default: 
				doTripleClick(evt);
				break;
			}
		} 

		
		private void doSingleClick(MouseEvent evt)
		{
			

			if(evt.isShiftDown())
			{
				float dragStartLineWidth = offsetToXY(dragStartLine,
					getLineLength(dragStartLine),returnValue).x;
				int extraEndVirt;
				int x = evt.getX();
				if(x > dragStartLineWidth)
				{
					extraEndVirt = (int)((x - dragStartLineWidth)
						/ charWidth);
					if(x % charWidth  > charWidth / 2)
						extraEndVirt++;
				}
				else
					extraEndVirt = 0;

				
				resizeSelection(getMarkPosition(),dragStart,extraEndVirt,control);

				moveCaretPosition(dragStart,false);

				
				dragStartLine = getMarkLine();
				dragStart = getMarkPosition();
				dragStartOffset = dragStart
					- getLineStartOffset(dragStartLine);
			}
			else
			{
				if(!(multi || quickCopyDrag))
					selectNone();

				if(!quickCopyDrag)
					moveCaretPosition(dragStart,false);
			}
		} 

		
		private void doDoubleClick(MouseEvent evt)
		{
			
			if(getLineLength(dragStartLine) == 0)
				return;

			String lineText = getLineText(dragStartLine);
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			if(dragStartOffset == getLineLength(dragStartLine))
				dragStartOffset--;

			boolean joinNonWordChars =
				jEdit.getBooleanProperty(""view.joinNonWordChars"");
			int wordStart = TextUtilities.findWordStart(lineText,
				dragStartOffset,noWordSep,joinNonWordChars);
			int wordEnd = TextUtilities.findWordEnd(lineText,
				dragStartOffset+1,noWordSep,joinNonWordChars);

			int lineStart = getLineStartOffset(dragStartLine);
			addToSelection(new Selection.Range(lineStart + wordStart,
				lineStart + wordEnd));

			if(quickCopyDrag)
				quickCopyDrag = false;

			moveCaretPosition(lineStart + wordEnd,false);

			
			
			dragged = true;
		} 

		
		private void doTripleClick(MouseEvent evt)
		{
			int newCaret = getLineEndOffset(dragStartLine);
			if(dragStartLine == buffer.getLineCount() - 1)
				newCaret--;

			addToSelection(new Selection.Range(
				getLineStartOffset(dragStartLine),
				newCaret));

			if(quickCopyDrag)
				quickCopyDrag = false;

			moveCaretPosition(newCaret);
		} 

		
		public void mouseDragged(MouseEvent evt)
		{
			if(GUIUtilities.isPopupTrigger(evt)
				|| (popup != null && popup.isVisible()))
				return;

			if(evt.getY() < 0)
			{
				setFirstLine(getFirstLine() - 2);
			}
			else if(evt.getY() >= getHeight())
			{
				setFirstLine(getFirstLine() + 1);
			}

			if(quickCopyDrag)
			{
				view.getStatus().setMessage(jEdit.getProperty(
					""view.status.quick-copy""));
				clearStatus = true;
			}
			else if(control)
			{
				view.getStatus().setMessage(jEdit.getProperty(
					""view.status.rect-select""));
				clearStatus = true;
			}

			switch(clickCount)
			{
			case 1:
				doSingleDrag(evt,control);
				break;
			case 2:
				doDoubleDrag(evt);
				break;
			default: 
				doTripleDrag(evt);
				break;
			}
		} 

		
		private void doSingleDrag(MouseEvent evt, boolean rect)
		{
			dragged = true;

			int x = evt.getX();
			int dot = xyToOffset(x,
				Math.max(0,Math.min(painter.getHeight(),evt.getY())),
				(!painter.isBlockCaretEnabled()
				&& !isOverwriteEnabled())
				|| quickCopyDrag);
			int dotLine = buffer.getLineOfOffset(dot);
			int extraEndVirt = 0;

			if(dotLine != physLastLine || chunkCache.getLineInfo(
				screenLastLine).lastSubregion)
			{
				float dotLineWidth = offsetToXY(dotLine,getLineLength(dotLine),
					returnValue).x;
				if(x > dotLineWidth)
				{
					extraEndVirt = (int)((x - dotLineWidth) / charWidth);
					if(x % charWidth  > charWidth / 2)
						extraEndVirt++;
				}
			}

			resizeSelection(dragStart,dot,extraEndVirt,rect);

			if(quickCopyDrag)
			{
				
				scrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine),false);
			}
			else
			{
				if(dot != caret)
					moveCaretPosition(dot,false);
				if(rect && extraEndVirt != 0)
				{
					scrollTo(dotLine,dot - buffer.getLineStartOffset(dotLine)
						+ extraEndVirt,false);
				}
			}
		} 

		
		private void doDoubleDrag(MouseEvent evt)
		{
			int markLineStart = getLineStartOffset(dragStartLine);
			int markLineLength = getLineLength(dragStartLine);
			int mark = dragStartOffset;

			int pos = xyToOffset(evt.getX(),
				Math.max(0,Math.min(painter.getHeight(),evt.getY())),
				!(painter.isBlockCaretEnabled() || isOverwriteEnabled()));
			int line = getLineOfOffset(pos);
			int lineStart = getLineStartOffset(line);
			int lineLength = getLineLength(line);
			int offset = pos - lineStart;

			String lineText = getLineText(line);
			String markLineText = getLineText(dragStartLine);
			String noWordSep = buffer.getStringProperty(""noWordSep"");
			boolean joinNonWordChars =
				jEdit.getBooleanProperty(""view.joinNonWordChars"");

			if(markLineStart + dragStartOffset > lineStart + offset)
			{
				if(offset != 0 && offset != lineLength)
				{
					offset = TextUtilities.findWordStart(
						lineText,offset,noWordSep,
						joinNonWordChars);
				}

				if(markLineLength != 0)
				{
					mark = TextUtilities.findWordEnd(
						markLineText,mark,noWordSep,
						joinNonWordChars);
				}
			}
			else
			{
				if(offset != 0 && lineLength != 0)
				{
					offset = TextUtilities.findWordEnd(
						lineText,offset,noWordSep,
						joinNonWordChars);
				}

				if(mark != 0 && mark != markLineLength)
				{
					mark = TextUtilities.findWordStart(
						markLineText,mark,noWordSep,
						joinNonWordChars);
				}
			}

			if(lineStart + offset == caret)
				return;

			resizeSelection(markLineStart + mark,lineStart + offset,
				0,false);
			if(!quickCopyDrag)
				moveCaretPosition(lineStart + offset,false);
		} 

		
		private void doTripleDrag(MouseEvent evt)
		{
			int offset = xyToOffset(evt.getX(),
				Math.max(0,Math.min(painter.getHeight(),evt.getY())),
				false);
			int mouseLine = getLineOfOffset(offset);
			int mark;
			int mouse;
			if(dragStartLine > mouseLine)
			{
				mark = getLineEndOffset(dragStartLine) - 1;
				if(offset == getLineEndOffset(mouseLine) - 1)
					mouse = offset;
				else
					mouse = getLineStartOffset(mouseLine);
			}
			else
			{
				mark = getLineStartOffset(dragStartLine);
				if(offset == getLineStartOffset(mouseLine))
					mouse = offset;
				else if(offset == getLineEndOffset(mouseLine) - 1
					&& mouseLine != getBuffer().getLineCount() - 1)
					mouse = getLineEndOffset(mouseLine);
				else
					mouse = getLineEndOffset(mouseLine) - 1;
			}

			mouse = Math.min(getBuffer().getLength(),mouse);

			if(mouse == caret)
				return;

			dragged = true;

			resizeSelection(mark,mouse,0,false);
			moveCaretPosition(mouse,false);
		} 

		
		public void mouseReleased(MouseEvent evt)
		{
			if(control && !dragged)
			{
				int offset = xyToOffset(evt.getX(),evt.getY(),false);
				if(offset != buffer.getLength())
				{
					buffer.getText(offset,1,lineSegment);
					switch(lineSegment.array[lineSegment.offset])
					{
					case '(': case '[': case '{':
					case ')': case ']': case '}':
						moveCaretPosition(offset,false);
						selectToMatchingBracket();
						return;
					}
				}
			}

			
			
			Selection sel = getSelectionAtOffset(dragStart);
			if(sel != null)
				Registers.setRegister('%',getSelectedText(sel));

			if(dragged && sel != null)
			{
				if(quickCopyDrag)
				{
					removeFromSelection(sel);
					Registers.paste(JEditTextArea.this,'%',
						sel instanceof Selection.Rect);
				}
				else
					Registers.setRegister('%',getSelectedText());
			}
			else if(isQuickCopyEnabled()
				&& GUIUtilities.isMiddleButton(evt.getModifiers()))
			{
				setCaretPosition(dragStart,false);
				if(!isEditable())
					getToolkit().beep();
				else
					Registers.paste(JEditTextArea.this,'%',control);
			}

			dragged = false;

			if(clearStatus)
			{
				clearStatus = false;
				view.getStatus().setMessage(null);
			}
		} 
	} 

	

	
	static
	{
		caretTimer = new Timer(500,new CaretBlinker());
		caretTimer.setInitialDelay(500);
		caretTimer.start();
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.pluginmgr.PluginManager,15,7,0,14,71,77,8,11,3,0.849206349,584,1.0,1,0.979104478,0.355555556,0,0,37.33333333,9,1.5333,0,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.File;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;



public class PluginManager extends EnhancedDialog
{
	
	public PluginManager(Frame frame)
	{
		super(frame,jEdit.getProperty(""plugin-manager.title""),true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel caption = new JLabel(jEdit.getProperty(
			""plugin-manager.caption""));
		caption.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,caption);

		tree = new JTree();
		tree.setCellRenderer(new Renderer());
		tree.setRootVisible(false);
		tree.setVisibleRowCount(16);
		tree.addTreeSelectionListener(new TreeHandler());

		JPanel panel = new JPanel(new BorderLayout());

		panel.add(BorderLayout.CENTER,new JScrollPane(tree));

		JPanel panel2 = new JPanel(new BorderLayout());
		panel2.setBorder(new EmptyBorder(6,0,0,0));
		JPanel labelBox = new JPanel(new GridLayout(3,1,0,3));
		labelBox.setBorder(new EmptyBorder(0,0,0,12));
		labelBox.add(new JLabel(jEdit.getProperty(""plugin-manager""
			+ "".info.name""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""plugin-manager""
			+ "".info.author""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""plugin-manager""
			+ "".info.version""),SwingConstants.RIGHT));
		panel2.add(BorderLayout.WEST,labelBox);

		JPanel valueBox = new JPanel(new GridLayout(3,1,0,3));
		valueBox.add(name = new JLabel());
		valueBox.add(author = new JLabel());
		valueBox.add(version = new JLabel());
		panel2.add(BorderLayout.CENTER,valueBox);

		panel.add(BorderLayout.SOUTH,panel2);
		content.add(BorderLayout.CENTER,panel);

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));

		buttons.add(Box.createGlue());
		remove = new JButton(jEdit.getProperty(""plugin-manager""
			+ "".remove""));
		remove.addActionListener(new ActionHandler());
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		update = new JButton(jEdit.getProperty(""plugin-manager""
			+ "".update""));
		update.addActionListener(new ActionHandler());
		buttons.add(update);
		buttons.add(Box.createHorizontalStrut(6));
		install = new JButton(jEdit.getProperty(""plugin-manager""
			+ "".install""));
		install.addActionListener(new ActionHandler());
		buttons.add(install);
		buttons.add(Box.createHorizontalStrut(6));
		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(new ActionHandler());
		buttons.add(close);
		buttons.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,buttons);

		updateTree();

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);

		pack();

		setLocationRelativeTo(frame);

		show();
	} 

	
	public void ok()
	{
		
	} 

	
	public void cancel()
	{
		dispose();
	} 

	

	
	private JTree tree;
	private JLabel name;
	private JLabel author;
	private JLabel version;
	private JButton remove;
	private JButton update;
	private JButton install;
	private JButton close;
	private PluginList pluginList;
	

	
	private PluginList getPluginList()
	{
		if(pluginList == null)
		{
			pluginList = new PluginListDownloadProgress(PluginManager.this)
				.getPluginList();
		}

		return pluginList;
	}
	
	private void updateTree()
	{
		DefaultMutableTreeNode treeRoot = new DefaultMutableTreeNode();
		DefaultTreeModel treeModel = new DefaultTreeModel(treeRoot);

		DefaultMutableTreeNode loadedTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""plugin-manager.loaded""),true);
		DefaultMutableTreeNode notLoadedTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""plugin-manager.not-loaded""),true);
		DefaultMutableTreeNode newTree = new DefaultMutableTreeNode(
			jEdit.getProperty(""plugin-manager.new""),true);

		EditPlugin[] plugins = jEdit.getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			EditPlugin plugin = plugins[i];
			String path = plugin.getJAR().getPath();
			if(!new File(path).exists())
			{
				
				continue;
			}

			if(plugin instanceof EditPlugin.Broken)
			{
				Entry entry = new Entry(path,plugin.getClassName(),true);
				notLoadedTree.add(new DefaultMutableTreeNode(entry));
			}
			else
			{
				Entry entry = new Entry(path,plugin.getClassName(),false);
				loadedTree.add(new DefaultMutableTreeNode(entry));
			}
		}

		if(notLoadedTree.getChildCount() != 0)
			treeRoot.add(notLoadedTree);

		if(loadedTree.getChildCount() != 0)
			treeRoot.add(loadedTree);

		String[] newPlugins = jEdit.getNotLoadedPluginJARs();
		for(int i = 0; i < newPlugins.length; i++)
		{
			Entry entry = new Entry(newPlugins[i],null,false);
			newTree.add(new DefaultMutableTreeNode(entry));
		}

		if(newTree.getChildCount() != 0)
			treeRoot.add(newTree);

		tree.setModel(treeModel);
		for(int i = 0; i < tree.getRowCount(); i++)
			tree.expandRow(i);

		remove.setEnabled(false);

		name.setText(null);
		author.setText(null);
		version.setText(null);
	} 

	

	

	
	class Entry
	{
		String clazz;
		String name, version, author;
		Vector jars;
		boolean broken;

		Entry(String path, String clazz, boolean broken)
		{
			Entry.this.clazz = clazz;
			Entry.this.broken = broken;

			jars = new Vector();
			jars.addElement(path);

			if(clazz == null)
				Entry.this.name = path;
			else
			{
				Entry.this.name = jEdit.getProperty(""plugin."" + clazz + "".name"");
				if(name == null)
					name = clazz;

				Entry.this.version = jEdit.getProperty(""plugin."" + clazz
					+ "".version"");

				Entry.this.author = jEdit.getProperty(""plugin."" + clazz
					+ "".author"");

				String jarsProp = jEdit.getProperty(""plugin."" + clazz
					+ "".jars"");

				if(jarsProp != null)
				{
					String directory = MiscUtilities.getParentOfPath(path);

					StringTokenizer st = new StringTokenizer(jarsProp);
					while(st.hasMoreElements())
					{
						jars.addElement(MiscUtilities.constructPath(
							directory,st.nextToken()));
					}
				}
			}
		}

		public String toString()
		{
			return Entry.this.name;
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == close)
				dispose();
			else if(source == remove)
			{
				TreePath[] selected = tree.getSelectionModel()
					.getSelectionPaths();

				StringBuffer buf = new StringBuffer();
				Roster roster = new Roster();
				for(int i = 0; i < selected.length; i++)
				{
					Object last = ((DefaultMutableTreeNode)
						selected[i].getLastPathComponent())
						.getUserObject();
					if(last instanceof Entry)
					{
						Entry entry = (Entry)last;
						for(int j = 0; j < entry.jars.size(); j++)
						{
							String jar = (String)entry.jars.elementAt(j);
							if(buf.length() != 0)
								buf.append('\n');
							buf.append(jar);
							roster.addOperation(new Roster.Remove(jar));
						}
					}
				}

				String[] args = { buf.toString() };
				if(GUIUtilities.confirm(PluginManager.this,
					""plugin-manager.remove-confirm"",args,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.QUESTION_MESSAGE)
					== JOptionPane.YES_OPTION)
				{
					new PluginManagerProgress(PluginManager.this,
						""remove"",roster);
					updateTree();
				}
			}
			else if(source == update)
			{
				if(jEdit.getSettingsDirectory() == null)
				{
					GUIUtilities.error(PluginManager.this,
						""no-settings"",null);
					return;
				}

				PluginList list = getPluginList();
				if(list == null)
					return;

				Vector plugins = new Vector();
				for(int i = 0; i < list.pluginSets.size(); i++)
				{
					PluginList.PluginSet set = (PluginList.PluginSet)
						list.pluginSets.get(i);
					boolean addedSetLabel = false;
					for(int j = 0; j < set.plugins.size(); j++)
					{
						PluginList.Plugin plugin = (PluginList.Plugin)
							list.pluginHash.get(set.plugins.get(j));
						PluginList.Branch branch = plugin.getCompatibleBranch();

						if(branch != null
							&& branch.canSatisfyDependencies()
							&& plugin.installedVersion != null
							&& MiscUtilities.compareStrings(branch.version,
							plugin.installedVersion,false) > 0)
						{
							
							
							if(!addedSetLabel)
							{
								plugins.add(new JCheckBoxList.Entry(set.name + "":""));
								addedSetLabel = true;
							}

							plugins.addElement(plugin);
						}
					}
				}

				if(plugins.size() == 0)
				{
					GUIUtilities.message(PluginManager.this,
						""plugin-manager.up-to-date"",null);
					return;
				}

				Roster roster = new Roster();
				new InstallPluginsDialog(PluginManager.this,
					plugins,InstallPluginsDialog.UPDATE)
					.installPlugins(roster);

				if(roster.isEmpty())
					return;

				new PluginManagerProgress(PluginManager.this,
					""update"",roster);

				updateTree();
			}
			else if(source == install)
			{
				if(jEdit.getSettingsDirectory() == null
					&& jEdit.getJEditHome() == null)
				{
					GUIUtilities.error(PluginManager.this,""no-settings"",null);
					return;
				}

				PluginList list = getPluginList();
				if(list == null)
					return;

				Vector plugins = new Vector();
				for(int i = 0; i < list.pluginSets.size(); i++)
				{
					PluginList.PluginSet set = (PluginList.PluginSet)
						list.pluginSets.get(i);
					boolean addedSetLabel = false;
					for(int j = 0; j < set.plugins.size(); j++)
					{
						PluginList.Plugin plugin = (PluginList.Plugin)
							list.pluginHash.get(set.plugins.get(j));
						if(plugin.installed == null
							&& plugin.canBeInstalled())
						{
							
							
							if(!addedSetLabel)
							{
								plugins.add(new JCheckBoxList.Entry(set.name + "":""));
								addedSetLabel = true;
							}

							plugins.addElement(plugin);
						}
					}
				}

				Roster roster = new Roster();
				new InstallPluginsDialog(PluginManager.this,
					plugins,InstallPluginsDialog.INSTALL)
					.installPlugins(roster);

				if(roster.isEmpty())
					return;

				new PluginManagerProgress(PluginManager.this,
					""install"",roster);

				updateTree();
			}
		}
	} 

	
	class TreeHandler implements TreeSelectionListener
	{
		public void valueChanged(TreeSelectionEvent evt)
		{
			TreePath selection = evt.getPath();
			DefaultMutableTreeNode node;
			if(selection == null)
			{
				node = null;
			}
			else
			{
				node = (DefaultMutableTreeNode)
					selection.getLastPathComponent();
			}

			name.setText(null);
			author.setText(null);
			version.setText(null);

			if(node != null && node.isLeaf()
				&& node.getUserObject() instanceof Entry)
			{
				remove.setEnabled(true);

				Entry entry = (Entry)node.getUserObject();

				if(entry.clazz != null)
				{
					name.setText(entry.name);
					author.setText(entry.author);
					version.setText(entry.version);
				}
			}
			else
				remove.setEnabled(false);
		}
	} 

	
	class Renderer extends DefaultTreeCellRenderer
	{
		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,
				selected,expanded,leaf,row,hasFocus);

			setIcon(null);

			return this;
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.PastePrevious,12,7,0,7,59,52,1,7,10,0.709090909,284,1.0,2,0.983508246,0.277777778,0,0,22.25,3,1.3333,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.*;


public class PastePrevious extends EnhancedDialog
implements ActionListener, ListSelectionListener, MouseListener
{
	
	public PastePrevious(View view)
	{
		super(view,jEdit.getProperty(""pasteprev.title""),true);
		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		clipHistory = HistoryModel.getModel(""clipboard"");

		clips = new JList(new AbstractListModel() {
			public int getSize()
			{
				return clipHistory.getSize();
			}

			public Object getElementAt(int index)
			{
				StringBuffer buf = new StringBuffer();
				String item = clipHistory.getItem(index);
				
				
				if(item.toLowerCase().startsWith(""<html>""))
					buf.append(' ');
				boolean ws = true;
				for(int i = 0; i < item.length(); i++)
				{
					char ch = item.charAt(i);
					if(Character.isWhitespace(ch))
					{
						if(ws)
							;
						else
						{
							buf.append(' ');
							ws = true;
						}
					}
					else
					{
						ws = false;
						buf.append(ch);
					}
				}
				return buf.toString();
			}
		});

		clips.setVisibleRowCount(16);

		clips.addMouseListener(this);
		clips.addListSelectionListener(this);

		insert = new JButton(jEdit.getProperty(""pasteprev.insert""));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));

		JLabel label = new JLabel(jEdit.getProperty(""pasteprev.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		content.add(BorderLayout.NORTH,label);

		JScrollPane scroller = new JScrollPane(clips);
		Dimension dim = scroller.getPreferredSize();
		scroller.setPreferredSize(new Dimension(640,dim.height));

		content.add(scroller, BorderLayout.CENTER);

		JPanel panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(12,0,0,0));
		panel.add(Box.createGlue());
		panel.add(insert);
		panel.add(Box.createHorizontalStrut(6));
		panel.add(cancel);
		panel.add(Box.createGlue());
		content.add(panel, BorderLayout.SOUTH);

		if(clipHistory.getSize() >= 1)
			clips.setSelectedIndex(0);
		updateButtons();

		getRootPane().setDefaultButton(insert);
		insert.addActionListener(this);
		cancel.addActionListener(this);

		GUIUtilities.requestFocus(this,clips);

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		int selected = clips.getSelectedIndex();

		if(selected == -1)
		{
			view.getToolkit().beep();
			return;
		}

		String clip = clipHistory.getItem(selected);
		view.getTextArea().setSelectedText(clip);

		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == insert)
			ok();
		else if(source == cancel)
			cancel();
	} 

	
	public void mouseClicked(MouseEvent evt)
	{
		if(evt.getClickCount() == 2)
			ok();
	} 

	
	public void mouseEntered(MouseEvent evt) {}
	public void mouseExited(MouseEvent evt) {}
	public void mousePressed(MouseEvent evt) {}
	public void mouseReleased(MouseEvent evt) {}
	

	
	public void valueChanged(ListSelectionEvent evt)
	{
		updateButtons();
	} 

	

	
	private View view;
	private JList clips;
	private HistoryModel clipHistory;
	private JButton insert;
	private JButton cancel;
	

	
	private void updateButtons()
	{
		int selected = clips.getSelectedIndex();
		insert.setEnabled(selected != -1);
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.Java14,3,1,0,9,19,3,0,9,1,1.0,54,0.0,0,0.0,0.333333333,0,0,16.66666667,3,1.3333,9,"

package org.gjt.sp.jedit;


import javax.swing.*;
import java.awt.datatransfer.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.textarea.JEditTextArea;
import org.gjt.sp.jedit.EditBus;
import org.gjt.sp.util.Log;



class Java14
{
	
	public static void init()
	{
		JFrame.setDefaultLookAndFeelDecorated(
			jEdit.getBooleanProperty(""decorate.frames""));
		JDialog.setDefaultLookAndFeelDecorated(
			jEdit.getBooleanProperty(""decorate.dialogs""));

		KeyboardFocusManager.setCurrentKeyboardFocusManager(
			new MyFocusManager());

		EditBus.addToBus(new EBComponent()
		{
			public void handleMessage(EBMessage msg)
			{
				if(msg instanceof ViewUpdate)
				{
					ViewUpdate vu = (ViewUpdate)msg;
					if(vu.getWhat() == ViewUpdate.CREATED)
					{
						vu.getView().setFocusTraversalPolicy(
							new MyFocusTraversalPolicy());
					}
				}
				else if(msg instanceof EditPaneUpdate)
				{
					EditPaneUpdate eu = (EditPaneUpdate)msg;
					if(eu.getWhat() == EditPaneUpdate.CREATED)
					{
						eu.getEditPane().getTextArea()
							.addMouseWheelListener(
							new MouseWheelHandler());
					}
				}
			}
		});

		Clipboard selection = Toolkit.getDefaultToolkit().getSystemSelection();
		if(selection != null)
		{
			Log.log(Log.DEBUG,Java14.class,""Setting % register""
				+ "" to system selection"");
			Registers.setRegister('%',new Registers.ClipboardRegister(selection));
		}
	} 

	
	static class MyFocusManager extends DefaultKeyboardFocusManager
	{
		MyFocusManager()
		{
			setDefaultFocusTraversalPolicy(new LayoutFocusTraversalPolicy());
		}

		public boolean postProcessKeyEvent(KeyEvent evt)
		{
			if(!evt.isConsumed())
			{
				Component comp = (Component)evt.getSource();
				if(!comp.isShowing())
					return true;

				for(;;)
				{
					if(comp instanceof View)
					{
						((View)comp).processKeyEvent(evt);
						return true;
					}
					else if(comp == null || comp instanceof Window
						|| comp instanceof JEditTextArea)
					{
						break;
					}
					else
						comp = comp.getParent();
				}
			}

			return super.postProcessKeyEvent(evt);
		}
	} 

	
	static class MyFocusTraversalPolicy extends LayoutFocusTraversalPolicy
	{
		public Component getDefaultComponent(Container focusCycleRoot)
		{
			return GUIUtilities.getView(focusCycleRoot).getTextArea();
		}
	} 

	
	static class MouseWheelHandler implements MouseWheelListener
	{
		public void mouseWheelMoved(MouseWheelEvent e)
		{
			JEditTextArea textArea = (JEditTextArea)e.getSource();

			
			if(e.isAltDown())
			{
				moveCaret(textArea,e.getWheelRotation(),
					e.isShiftDown() || e.isControlDown());
			}
			else if(e.isShiftDown())
				scrollPage(textArea,e.getWheelRotation());
			else if(e.isControlDown())
				scrollLine(textArea,e.getWheelRotation());
			else if(e.getScrollType() == MouseWheelEvent.WHEEL_UNIT_SCROLL)
				scrollLine(textArea,e.getUnitsToScroll());
			else
				scrollLine(textArea,3 * e.getWheelRotation());
		}

		private void scrollLine(JEditTextArea textArea, int amt)
		{
			int newpos = textArea.getFirstLine() + amt;
			newpos = Math.max(newpos, 0);
			newpos = Math.min(newpos, textArea.getVirtualLineCount());
			textArea.setFirstLine(newpos);
		}

		private void scrollPage(JEditTextArea textArea, int amt)
		{
			if(amt > 0)
				textArea.scrollDownPage();
			else
				textArea.scrollUpPage();
		}

		private void moveCaret(JEditTextArea textArea, int amt, boolean select)
		{
			if (amt < 0)
				textArea.goToPrevLine(select);
			else
				textArea.goToNextLine(select);
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.search.CurrentBufferSet,6,1,0,6,9,15,4,3,6,2.0,34,0.0,0,0.0,0.611111111,0,0,4.666666667,2,1.0,0,"

package org.gjt.sp.jedit.search;

import org.gjt.sp.jedit.*;


public class CurrentBufferSet implements SearchFileSet
{
	
	public String getFirstFile(View view)
	{
		return view.getBuffer().getPath();
	} 

	
	public String getNextFile(View view, String file)
	{
		if(file == null)
			return view.getBuffer().getPath();
		else
			return null;
	} 

	
	public String[] getFiles(View view)
	{
		return new String[] { view.getBuffer().getPath() };
	} 

	
	public int getFileCount(View view)
	{
		return 1;
	} 

	
	public String getCode()
	{
		return ""new CurrentBufferSet()"";
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.search.SearchBar,19,5,0,20,83,105,8,17,4,0.822222222,477,1.0,3,0.973174367,0.336842105,2,5,23.57894737,10,1.4211,1,"

package org.gjt.sp.jedit.search;


import java.awt.event.*;
import java.awt.*;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class SearchBar extends JPanel
{
	
	public SearchBar(final View view, boolean temp)
	{
		setLayout(new BoxLayout(this,BoxLayout.X_AXIS));

		this.view = view;

		add(Box.createHorizontalStrut(2));

		JLabel label = new JLabel(jEdit.getProperty(""view.search.find""));
		add(label);
		add(Box.createHorizontalStrut(12));
		add(find = new HistoryTextField(""find""));
		find.setSelectAllOnFocus(true);
		Dimension max = find.getPreferredSize();
		max.width = Integer.MAX_VALUE;
		find.setMaximumSize(max);
		ActionHandler actionHandler = new ActionHandler();
		find.addKeyListener(new KeyHandler());
		find.addActionListener(actionHandler);
		find.getDocument().addDocumentListener(new DocumentHandler());

		Insets margin = new Insets(1,1,1,1);

		add(Box.createHorizontalStrut(12));
		add(ignoreCase = new JCheckBox(jEdit.getProperty(
			""search.case"")));
		ignoreCase.addActionListener(actionHandler);
		ignoreCase.setMargin(margin);
		ignoreCase.setRequestFocusEnabled(false);
		add(Box.createHorizontalStrut(2));
		add(regexp = new JCheckBox(jEdit.getProperty(
			""search.regexp"")));
		regexp.addActionListener(actionHandler);
		regexp.setMargin(margin);
		regexp.setRequestFocusEnabled(false);
		add(Box.createHorizontalStrut(2));
		add(hyperSearch = new JCheckBox(jEdit.getProperty(
			""search.hypersearch"")));
		hyperSearch.addActionListener(actionHandler);
		hyperSearch.setMargin(margin);
		hyperSearch.setRequestFocusEnabled(false);

		if(temp)
		{
			close = new RolloverButton(new ImageIcon(
				getClass().getResource(
				""/org/gjt/sp/jedit/icons/closebox.gif"")));
			close.addActionListener(actionHandler);
			close.setToolTipText(jEdit.getProperty(
				""view.search.close-tooltip""));
			add(close);
		}

		update();

		
		timer = new Timer(0,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(!incrementalSearch(searchStart,searchReverse))
				{
					if(!incrementalSearch(
						(searchReverse
						? view.getBuffer().getLength()
						: 0),searchReverse))
					{
						
						view.getStatus().setMessageAndClear(
							jEdit.getProperty(
							""view.status.search-not-found""));
					}
				}
			}
		}); 

		
		this.temp = temp;
	} 

	
	public HistoryTextField getField()
	{
		return find;
	} 

	
	public void setHyperSearch(boolean hyperSearch)
	{
		jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",hyperSearch);
		this.hyperSearch.setSelected(hyperSearch);
	} 

	
	public void update()
	{
		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		hyperSearch.setSelected(jEdit.getBooleanProperty(
			""view.search.hypersearch.toggle""));
	} 

	

	
	private View view;
	private HistoryTextField find;
	private JCheckBox ignoreCase, regexp, hyperSearch;
	private Timer timer;

	
	private RolloverButton close;

	private int searchStart;
	private boolean searchReverse;
	private boolean temp;
	

	
	private void find(boolean reverse)
	{
		timer.stop();

		String text = find.getText();
		
		if(text.length() == 0)
		{
			jEdit.setBooleanProperty(""search.hypersearch.toggle"",
				hyperSearch.isSelected());
			new SearchDialog(view,null);
		} 
		
		else if(hyperSearch.isSelected())
		{
			if(temp)
			{
				view.removeToolBar(SearchBar.this);
			}
                        else
				find.setText(null);

			SearchAndReplace.setSearchString(text);
			SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
			SearchAndReplace.hyperSearch(view);
		} 
		
		else
		{
			
			
			int start;
			JEditTextArea textArea = view.getTextArea();
			Selection s = textArea.getSelectionAtOffset(
				textArea.getCaretPosition());
			if(s == null)
				start = textArea.getCaretPosition();
			else if(reverse)
				start = s.getStart();
			else
				start = s.getEnd();

			if(!incrementalSearch(start,reverse))
			{
				
				
				if(!incrementalSearch(reverse
					? view.getBuffer().getLength()
					: 0,reverse))
				{
					
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(
						""view.status.search-not-found""));
				}
				else
				{
					
					view.getStatus().setMessageAndClear(
						jEdit.getProperty(""view.status.auto-wrap""));
					
					if(jEdit.getBooleanProperty(""search.beepOnSearchAutoWrap""))
					{
						getToolkit().beep();
					}
				}
			}
		} 
	} 

	
	private boolean incrementalSearch(int start, boolean reverse)
	{
		
		SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
		SearchAndReplace.setSearchString(find.getText());
		SearchAndReplace.setReverseSearch(reverse);

		try
		{
			if(SearchAndReplace.find(view,view.getBuffer(),start,false,reverse))
				return true;
		}
		catch(Exception e)
		{
			Log.log(Log.DEBUG,this,e);

			
			
			
			return true;
		}

		return false;
	} 

	
	private void timerIncrementalSearch(int start, boolean reverse)
	{
		this.searchStart = start;
		this.searchReverse = reverse;

		timer.stop();
		timer.setRepeats(false);
		timer.setInitialDelay(150);
		timer.start();
	} 

	

	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == find)
				find(false);
			else if(source == hyperSearch)
			{
				jEdit.setBooleanProperty(""view.search.hypersearch.toggle"",
					hyperSearch.isSelected());
				update();
			}
			else if(source == ignoreCase)
			{
				SearchAndReplace.setIgnoreCase(ignoreCase
					.isSelected());
			}
			else if(source == regexp)
			{
				SearchAndReplace.setRegexp(regexp
					.isSelected());
			}
			else if(source == close)
			{
				view.removeToolBar(SearchBar.this);
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						view.getEditPane().focusOnTextArea();
					}
				});
			}
		} 
	} 

	
	class DocumentHandler implements DocumentListener
	{
		
		public void insertUpdate(DocumentEvent evt)
		{
			
			
			
			if(!hyperSearch.isSelected())
			{
				int start;
				JEditTextArea textArea = view.getTextArea();
				Selection s = textArea.getSelectionAtOffset(
					textArea.getCaretPosition());
				if(s == null)
					start = textArea.getCaretPosition();
				else
					start = s.getStart();

				timerIncrementalSearch(start,false);
			}
		} 

		
		public void removeUpdate(DocumentEvent evt)
		{
			
			if(!hyperSearch.isSelected())
			{
				String text = find.getText();
				if(text.length() != 0)
				{
					
					
					
					
					if(regexp.isSelected())
					{
						
						
						
						timerIncrementalSearch(0,false);
					}
					else
					{
						int start;
						JEditTextArea textArea = view.getTextArea();
						Selection s = textArea.getSelectionAtOffset(
							textArea.getCaretPosition());
						if(s == null)
							start = textArea.getCaretPosition();
						else
							start = s.getStart();
						timerIncrementalSearch(start,true);
					}
				}
			}
		} 

		
		public void changedUpdate(DocumentEvent evt) {}
		
	} 

	
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_LEFT:
			case KeyEvent.VK_RIGHT:
				if(!hyperSearch.isSelected())
				{
					if(temp)
					{
						view.removeToolBar(SearchBar.this);
					}

					evt.consume();
					SwingUtilities.invokeLater(new Runnable()
					{
						public void run()
						{
							view.getEditPane().focusOnTextArea();
						}
					});
					view.getEditPane().getTextArea()
						.processKeyEvent(evt);
				}
				break;
			case KeyEvent.VK_ESCAPE:
				if(temp)
				{
					view.removeToolBar(SearchBar.this);
				}
				evt.consume();
				SwingUtilities.invokeLater(new Runnable()
				{
					public void run()
					{
						view.getEditPane().focusOnTextArea();
					}
				});
				break;
			case KeyEvent.VK_ENTER:
				if(evt.isShiftDown())
				{
					evt.consume();
					
					
					find(regexp.isSelected() ? false : true);
				}
				break;
			}
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.CloseDialog,14,7,0,7,55,67,3,7,4,0.888888889,356,0.888888889,1,0.980568012,0.285714286,0,0,23.78571429,3,1.0714,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.buffer.BufferIORequest;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;


public class CloseDialog extends EnhancedDialog
{
	
	public CloseDialog(View view)
	{
		super(view,jEdit.getProperty(""close.title""),true);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.warningIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout());

		JLabel label = new JLabel(jEdit.getProperty(""close.caption""));
		label.setBorder(new EmptyBorder(0,0,6,0));
		centerPanel.add(BorderLayout.NORTH,label);

		bufferList = new JList(bufferModel = new DefaultListModel());
		bufferList.setVisibleRowCount(10);
		bufferList.addListSelectionListener(new ListHandler());

		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			if(buffer.isDirty())
			{
				bufferModel.addElement(buffer.getPath());
			}
		}

		centerPanel.add(BorderLayout.CENTER,new JScrollPane(bufferList));

		content.add(BorderLayout.CENTER,centerPanel);

		ActionHandler actionListener = new ActionHandler();

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		buttons.add(selectAll = new JButton(jEdit.getProperty(""close.selectAll"")));
		selectAll.setMnemonic(jEdit.getProperty(""close.selectAll.mnemonic"").charAt(0));
		selectAll.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(save = new JButton(jEdit.getProperty(""close.save"")));
		save.setMnemonic(jEdit.getProperty(""close.save.mnemonic"").charAt(0));
		save.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(discard = new JButton(jEdit.getProperty(""close.discard"")));
		discard.setMnemonic(jEdit.getProperty(""close.discard.mnemonic"").charAt(0));
		discard.addActionListener(actionListener);
		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(cancel = new JButton(jEdit.getProperty(""common.cancel"")));
		cancel.addActionListener(actionListener);
		buttons.add(Box.createGlue());

		bufferList.setSelectedIndex(0);

		content.add(BorderLayout.SOUTH,buttons);

		GUIUtilities.requestFocus(this,bufferList);

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public boolean isOK()
	{
		return ok;
	} 

	
	public void ok()
	{
		
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	private View view;
	private JList bufferList;
	private DefaultListModel bufferModel;
	private JButton selectAll;
	private JButton save;
	private JButton discard;
	private JButton cancel;

	private boolean ok; 

	boolean selectAllFlag;

	private void updateButtons()
	{
		int index = bufferList.getSelectedIndex();
		save.getModel().setEnabled(index != -1);
		discard.getModel().setEnabled(index != -1);
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == selectAll)
			{
				
				
				try
				{
					selectAllFlag = true;

					bufferList.setSelectionInterval(0,
						bufferModel.getSize() - 1);
				}
				finally
				{
					selectAllFlag = false;
				}
				bufferList.requestFocus();
			}
			else if(source == save)
			{
				Object[] paths = bufferList.getSelectedValues();

				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					if(!buffer.save(view,null,true))
						return;
					VFSManager.waitForRequests();
					if(buffer.getBooleanProperty(BufferIORequest
						.ERROR_OCCURRED))
						return;
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}

				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
				else
				{
					bufferList.setSelectedIndex(0);
					bufferList.requestFocus();
				}
			}
			else if(source == discard)
			{
				Object[] paths = bufferList.getSelectedValues();

				for(int i = 0; i < paths.length; i++)
				{
					String path = (String)paths[i];
					Buffer buffer = jEdit.getBuffer(path);
					jEdit._closeBuffer(view,buffer);
					bufferModel.removeElement(path);
				}

				if(bufferModel.getSize() == 0)
				{
					ok = true;
					dispose();
				}
				else
				{
					bufferList.setSelectedIndex(0);
					bufferList.requestFocus();
				}
			}
			else if(source == cancel)
				cancel();
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			if(selectAllFlag)
				return;

			int index = bufferList.getSelectedIndex();
			if(index != -1)
				view.setBuffer(jEdit.getBuffer((String)
					bufferModel.getElementAt(index)));

			updateButtons();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.AnimatedIcon,13,2,0,1,20,30,1,1,9,0.805555556,115,1.0,0,0.571428571,0.269230769,0,0,7.384615385,2,1.0769,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.awt.event.*;
import javax.swing.*;



public class AnimatedIcon extends ImageIcon
{
	
	
	public AnimatedIcon(Image icon, Image[] frames, int rate, Component host)
	{
		super(icon);
		this.icon = icon;
		this.frames = frames;
		delay = 1000/rate;
		this.host = host;
	} 

	
	public Image[] getFrames()
	{
		return frames;
	} 

	
	public Image getIcon()
	{
		return icon;
	} 

	
	public int getRate()
	{
		return 1000/delay;
	} 

	
	public void setFrames(Image[] frames)
	{
		this.frames = frames;
	} 

	
	public void setIcon(Image icon)
	{
		this.icon = icon;
	} 

	
	public void setRate(int rate)
	{
		delay = 1000/rate;
	} 

	
	
	public void start()
	{
		if(timer != null)
			return;

		timer = new Timer(delay,new Animator());
		timer.start();
	} 

	
	
	public void stop()
	{
		current = 0;
		if(timer != null)
		{
			timer.stop();
			timer = null;
		}

		setImage(icon);
		host.repaint();
	} 

	
	private Image[] frames;
	private int current;
	private int delay;
	private Timer timer;
	private Component host;
	private Image icon;
	

	
	class Animator implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			current = (current + 1) % frames.length;
			setImage(frames[current]);
			host.repaint();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.search.SearchDialog,40,7,0,28,162,542,8,26,9,0.831501832,1807,0.892857143,5,0.946608947,0.186813187,2,3,43.475,15,2.175,7,"

package org.gjt.sp.jedit.search;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.util.HashMap;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.msg.SearchSettingsChanged;
import org.gjt.sp.jedit.msg.ViewUpdate;
import org.gjt.sp.jedit.*;



public class SearchDialog extends EnhancedDialog implements EBComponent
{
	
	
	public static final int CURRENT_BUFFER = 0;
	public static final int ALL_BUFFERS = 1;
	public static final int DIRECTORY = 2;
	

	
	public static SearchDialog getSearchDialog(View view)
	{
		return (SearchDialog)viewHash.get(view);
	} 

	
	
	public static void showSearchDialog(View view, String searchString,
		int searchIn)
	{
		SearchDialog dialog = (SearchDialog)viewHash.get(view);
		if(dialog != null)
		{
			
			if(OperatingSystem.isUnix() && !OperatingSystem.isMacOS())
			{
				dialog.setVisible(false);
				dialog.setVisible(true);
			}

			dialog.setSearchString(searchString,searchIn);
			GUIUtilities.requestFocus(dialog,dialog.find);
			dialog.toFront();
			dialog.requestFocus();
		}
		else
		{
			dialog = new SearchDialog(view,searchString,searchIn);
			viewHash.put(view,dialog);
		}
	} 

	
	
	public SearchDialog(View view, String searchString)
	{
		this(view,searchString,CURRENT_BUFFER);
	} 

	
	
	public SearchDialog(View view, String searchString, int searchIn)
	{
		super(view,jEdit.getProperty(""search.title""),false);

		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(0,12,12,12));
		setContentPane(content);

		JPanel centerPanel = new JPanel(new BorderLayout());
		centerPanel.add(BorderLayout.NORTH,createFieldPanel());
		centerPanel.add(BorderLayout.CENTER,createSearchSettingsPanel());
		content.add(BorderLayout.CENTER,centerPanel);
		content.add(BorderLayout.SOUTH,createMultiFilePanel());

		content.add(BorderLayout.EAST,createButtonsPanel());

		ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
		regexp.setSelected(SearchAndReplace.getRegexp());
		wrap.setSelected(SearchAndReplace.getAutoWrapAround());

		if(SearchAndReplace.getReverseSearch())
			searchBack.setSelected(true);
		else
			searchForward.setSelected(true);

		if(SearchAndReplace.getBeanShellReplace())
		{
			replace.setModel(""replace.script"");
			beanShellReplace.setSelected(true);
		}
		else
		{
			replace.setModel(""replace"");
			stringReplace.setSelected(true);
		}

		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();

		if(fileset instanceof DirectoryListSet)
		{
			filter.setText(((DirectoryListSet)fileset)
				.getFileFilter());
			directory.setText(((DirectoryListSet)fileset)
				.getDirectory());
			searchSubDirectories.setSelected(((DirectoryListSet)fileset)
				.isRecursive());
		}
		else
		{
			String path = view.getBuffer().getDirectory();

			if(path.endsWith(""/"") || path.endsWith(File.separator))
				path = path.substring(0,path.length() - 1);

			directory.setText(path);

			if(fileset instanceof AllBufferSet)
			{
				filter.setText(((AllBufferSet)fileset)
					.getFileFilter());
			}
			else
			{
				filter.setText(""*"" + MiscUtilities
					.getFileExtension(view.getBuffer()
					.getName()));
			}

			searchSubDirectories.setSelected(true);
		}

		directory.addCurrentToHistory();

		keepDialog.setSelected(jEdit.getBooleanProperty(
			""search.keepDialog.toggle""));

		setSearchString(searchString,searchIn);

		pack();
		jEdit.unsetProperty(""search.width"");
		jEdit.unsetProperty(""search.d-width"");
		jEdit.unsetProperty(""search.height"");
		jEdit.unsetProperty(""search.d-height"");
		GUIUtilities.loadGeometry(this,""search"");
		show();

		EditBus.addToBus(this);

		GUIUtilities.requestFocus(this,find);
	} 

	
	
	public void setSearchString(String searchString, int searchIn)
	{
		if(searchString == null)
			find.setText(null);
		else
		{
			if(searchString.indexOf('\n') == -1)
			{
				find.setText(searchString);
				find.selectAll();
			}
			else if(searchIn == CURRENT_BUFFER)
			{
				searchSelection.setSelected(true);
				hyperSearch.setSelected(true);
			}
		}

		if(searchIn == CURRENT_BUFFER)
		{
			if(!searchSelection.isSelected())
			{
				
				searchCurrentBuffer.setSelected(true);

				
				hyperSearch.setSelected(jEdit.getBooleanProperty(
					""search.hypersearch.toggle""));
			}
		}
		else if(searchIn == ALL_BUFFERS)
		{
			searchAllBuffers.setSelected(true);
			hyperSearch.setSelected(true);
		}
		else if(searchIn == DIRECTORY)
		{
			hyperSearch.setSelected(true);
			searchDirectory.setSelected(true);
		}

		updateEnabled();
	} 

	
	public void ok()
	{
		try
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

			if(!save(false))
				return;

			if(hyperSearch.isSelected() || searchSelection.isSelected())
			{
				if(SearchAndReplace.hyperSearch(view,
					searchSelection.isSelected()))
					closeOrKeepDialog();
			}
			else
			{
				if(SearchAndReplace.find(view))
					closeOrKeepDialog();
				else
				{
					toFront();
					requestFocus();
					find.requestFocus();
				}
			}
		}
		finally
		{
			setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
		}
	} 

	
	public void cancel()
	{
		save(true);
		GUIUtilities.saveGeometry(this,""search"");
		dispose();
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof SearchSettingsChanged)
		{
			ignoreCase.setSelected(SearchAndReplace.getIgnoreCase());
			regexp.setSelected(SearchAndReplace.getRegexp());
		}
		else if(msg instanceof ViewUpdate)
		{
			ViewUpdate vmsg = (ViewUpdate)msg;
			if(vmsg.getView() == view
				&& vmsg.getWhat() == ViewUpdate.CLOSED)
			{
				viewHash.remove(view);
			}
		}
	} 

	
	public void dispose()
	{
		EditBus.removeFromBus(this);
		viewHash.remove(view);
		super.dispose();
	} 

	

	private static HashMap viewHash = new HashMap();

	
	private View view;

	
	private HistoryTextField find, replace;

	private JRadioButton stringReplace, beanShellReplace;

	
	private JCheckBox keepDialog, ignoreCase, regexp, hyperSearch,
		wrap;
	private JRadioButton searchBack, searchForward;
	private JRadioButton searchSelection, searchCurrentBuffer, searchAllBuffers,
		searchDirectory;

	
	private HistoryTextField filter, directory;
	private JCheckBox searchSubDirectories;
	private JButton choose;

	
	private JButton findBtn,  replaceAndFindBtn, replaceAllBtn,
		closeBtn;
	

	
	private JPanel createFieldPanel()
	{
		ButtonActionHandler actionHandler = new ButtonActionHandler();

		JPanel fieldPanel = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,1));
		fieldPanel.setBorder(new EmptyBorder(0,0,12,12));

		JLabel label = new JLabel(jEdit.getProperty(""search.find""));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.find.mnemonic"")
			.charAt(0));
		find = new HistoryTextField(""find"");
		find.setColumns(25);

		find.addActionListener(actionHandler);
		label.setLabelFor(find);
		label.setBorder(new EmptyBorder(12,0,2,0));
		fieldPanel.add(label);
		fieldPanel.add(find);

		label = new JLabel(jEdit.getProperty(""search.replace""));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.replace.mnemonic"")
			.charAt(0));
		label.setBorder(new EmptyBorder(12,0,0,0));
		fieldPanel.add(label);

		ButtonGroup grp = new ButtonGroup();
		ReplaceActionHandler replaceActionHandler = new ReplaceActionHandler();

		
		
		
		

		Box replaceModeBox = new Box(BoxLayout.X_AXIS);
		stringReplace = new MyJRadioButton(jEdit.getProperty(
			""search.string-replace-btn""));
		stringReplace.addActionListener(replaceActionHandler);
		grp.add(stringReplace);
		replaceModeBox.add(stringReplace);

		replaceModeBox.add(Box.createHorizontalStrut(12));

		beanShellReplace = new MyJRadioButton(jEdit.getProperty(
			""search.beanshell-replace-btn""));
		beanShellReplace.addActionListener(replaceActionHandler);
		grp.add(beanShellReplace);
		replaceModeBox.add(beanShellReplace);

		fieldPanel.add(replaceModeBox);

		fieldPanel.add(Box.createVerticalStrut(3));

		replace = new HistoryTextField(""replace"");
		replace.addActionListener(actionHandler);
		label.setLabelFor(replace);
		fieldPanel.add(replace);

		return fieldPanel;
	} 

	
	private JPanel createSearchSettingsPanel()
	{
		JPanel searchSettings = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,3));
		searchSettings.setBorder(new EmptyBorder(0,0,12,12));

		SettingsActionHandler actionHandler = new SettingsActionHandler();
		ButtonGroup fileset = new ButtonGroup();
		ButtonGroup direction = new ButtonGroup();

		searchSettings.add(new JLabel(jEdit.getProperty(""search.fileset"")));

		searchSettings.add(new JLabel(jEdit.getProperty(""search.settings"")));

		searchSettings.add(new JLabel(jEdit.getProperty(""search.direction"")));

		searchSelection = new JRadioButton(jEdit.getProperty(""search.selection""));
		searchSelection.setMnemonic(jEdit.getProperty(""search.selection.mnemonic"")
			.charAt(0));
		fileset.add(searchSelection);
		searchSettings.add(searchSelection);
		searchSelection.addActionListener(actionHandler);

		keepDialog = new JCheckBox(jEdit.getProperty(""search.keep""));
		keepDialog.setMnemonic(jEdit.getProperty(""search.keep.mnemonic"")
			.charAt(0));
		searchSettings.add(keepDialog);

		searchBack = new JRadioButton(jEdit.getProperty(""search.back""));
		searchBack.setMnemonic(jEdit.getProperty(""search.back.mnemonic"")
			.charAt(0));
		direction.add(searchBack);
		searchSettings.add(searchBack);
		searchBack.addActionListener(actionHandler);

		searchCurrentBuffer = new JRadioButton(jEdit.getProperty(""search.current""));
		searchCurrentBuffer.setMnemonic(jEdit.getProperty(""search.current.mnemonic"")
			.charAt(0));
		fileset.add(searchCurrentBuffer);
		searchSettings.add(searchCurrentBuffer);
		searchCurrentBuffer.addActionListener(actionHandler);

		ignoreCase = new JCheckBox(jEdit.getProperty(""search.case""));
		ignoreCase.setMnemonic(jEdit.getProperty(""search.case.mnemonic"")
			.charAt(0));
		searchSettings.add(ignoreCase);
		ignoreCase.addActionListener(actionHandler);

		searchForward = new JRadioButton(jEdit.getProperty(""search.forward""));
		searchForward.setMnemonic(jEdit.getProperty(""search.forward.mnemonic"")
			.charAt(0));
		direction.add(searchForward);
		searchSettings.add(searchForward);
		searchForward.addActionListener(actionHandler);

		searchAllBuffers = new JRadioButton(jEdit.getProperty(""search.all""));
		searchAllBuffers.setMnemonic(jEdit.getProperty(""search.all.mnemonic"")
			.charAt(0));
		fileset.add(searchAllBuffers);
		searchSettings.add(searchAllBuffers);
		searchAllBuffers.addActionListener(actionHandler);

		regexp = new JCheckBox(jEdit.getProperty(""search.regexp""));
		regexp.setMnemonic(jEdit.getProperty(""search.regexp.mnemonic"")
			.charAt(0));
		searchSettings.add(regexp);
		regexp.addActionListener(actionHandler);

		wrap = new JCheckBox(jEdit.getProperty(""search.wrap""));
		wrap.setMnemonic(jEdit.getProperty(""search.wrap.mnemonic"")
			.charAt(0));
		searchSettings.add(wrap);
		wrap.addActionListener(actionHandler);

		searchDirectory = new JRadioButton(jEdit.getProperty(""search.directory""));
		searchDirectory.setMnemonic(jEdit.getProperty(""search.directory.mnemonic"")
			.charAt(0));
		fileset.add(searchDirectory);
		searchSettings.add(searchDirectory);
		searchDirectory.addActionListener(actionHandler);

		hyperSearch = new JCheckBox(jEdit.getProperty(""search.hypersearch""));
		hyperSearch.setMnemonic(jEdit.getProperty(""search.hypersearch.mnemonic"")
			.charAt(0));
		searchSettings.add(hyperSearch);
		hyperSearch.addActionListener(actionHandler);

		return searchSettings;
	} 

	
	private JPanel createMultiFilePanel()
	{
		JPanel multifile = new JPanel();

		GridBagLayout layout = new GridBagLayout();
		multifile.setLayout(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridy = cons.gridwidth = cons.gridheight = 1;
		cons.anchor = GridBagConstraints.WEST;
		cons.fill = GridBagConstraints.HORIZONTAL;

		MultiFileActionHandler actionListener = new MultiFileActionHandler();
		filter = new HistoryTextField(""search.filter"");
		filter.addActionListener(actionListener);

		cons.insets = new Insets(0,0,3,0);

		JLabel label = new JLabel(jEdit.getProperty(""search.filterField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));
		label.setDisplayedMnemonic(jEdit.getProperty(""search.filterField.mnemonic"")
			.charAt(0));
		label.setLabelFor(filter);
		cons.weightx = 0.0f;
		layout.setConstraints(label,cons);
		multifile.add(label);

		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0f;
		layout.setConstraints(filter,cons);
		multifile.add(filter);

		cons.gridy++;

		directory = new HistoryTextField(""search.directory"");
		directory.setColumns(25);
		directory.addActionListener(actionListener);

		label = new JLabel(jEdit.getProperty(""search.directoryField""),
			SwingConstants.RIGHT);
		label.setBorder(new EmptyBorder(0,0,0,12));

		label.setDisplayedMnemonic(jEdit.getProperty(""search.directoryField.mnemonic"")
			.charAt(0));
		label.setLabelFor(directory);
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0f;
		layout.setConstraints(label,cons);
		multifile.add(label);

		cons.insets = new Insets(0,0,3,6);
		cons.weightx = 1.0f;
		cons.gridwidth = 2;
		layout.setConstraints(directory,cons);
		multifile.add(directory);

		choose = new JButton(jEdit.getProperty(""search.choose""));
		choose.setMnemonic(jEdit.getProperty(""search.choose.mnemonic"")
			.charAt(0));
		cons.insets = new Insets(0,0,3,0);
		cons.weightx = 0.0f;
		cons.gridwidth = 1;
		layout.setConstraints(choose,cons);
		multifile.add(choose);
		choose.addActionListener(actionListener);

		cons.insets = new Insets(0,0,0,0);
		cons.gridy++;
		cons.gridwidth = 4;

		searchSubDirectories = new JCheckBox(jEdit.getProperty(
			""search.subdirs""));
		searchSubDirectories.setMnemonic(jEdit.getProperty(""search.subdirs.mnemonic"")
			.charAt(0));
		layout.setConstraints(searchSubDirectories,cons);
		multifile.add(searchSubDirectories);

		return multifile;
	} 

	
	private Box createButtonsPanel()
	{
		Box box = new Box(BoxLayout.Y_AXIS);

		ButtonActionHandler actionHandler = new ButtonActionHandler();

		box.add(Box.createVerticalStrut(12));

		JPanel grid = new JPanel(new GridLayout(5,1,0,12));

		findBtn = new JButton(jEdit.getProperty(""search.findBtn""));
		getRootPane().setDefaultButton(findBtn);
		grid.add(findBtn);
		findBtn.addActionListener(actionHandler);

		

		replaceAndFindBtn = new JButton(jEdit.getProperty(""search.replaceAndFindBtn""));
		replaceAndFindBtn.setMnemonic(jEdit.getProperty(""search.replaceAndFindBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAndFindBtn);
		replaceAndFindBtn.addActionListener(actionHandler);

		replaceAllBtn = new JButton(jEdit.getProperty(""search.replaceAllBtn""));
		replaceAllBtn.setMnemonic(jEdit.getProperty(""search.replaceAllBtn.mnemonic"")
			.charAt(0));
		grid.add(replaceAllBtn);
		replaceAllBtn.addActionListener(actionHandler);

		closeBtn = new JButton(jEdit.getProperty(""common.close""));
		grid.add(closeBtn);
		closeBtn.addActionListener(actionHandler);

		grid.setMaximumSize(grid.getPreferredSize());

		box.add(grid);
		box.add(Box.createGlue());

		return box;
	} 

	
	private void updateEnabled()
	{
		wrap.setEnabled(!hyperSearch.isSelected()
			&& !searchSelection.isSelected());

		boolean reverseEnabled = !hyperSearch.isSelected()
			&& searchCurrentBuffer.isSelected()
			&& !regexp.isSelected();
		searchBack.setEnabled(reverseEnabled);
		searchForward.setEnabled(reverseEnabled);
		if(!reverseEnabled)
			searchForward.setSelected(true);

		filter.setEnabled(searchAllBuffers.isSelected()
			|| searchDirectory.isSelected());

		boolean directoryEnabled = searchDirectory.isSelected();

		directory.setEnabled(directoryEnabled);
		choose.setEnabled(directoryEnabled);
		searchSubDirectories.setEnabled(directoryEnabled);

		findBtn.setEnabled(!searchSelection.isSelected()
			|| hyperSearch.isSelected());
		replaceAndFindBtn.setEnabled(!hyperSearch.isSelected()
			&& !searchSelection.isSelected());
	} 

	
	
	private boolean save(boolean cancel)
	{
		String filter = this.filter.getText();
		this.filter.addCurrentToHistory();
		if(filter.length() == 0)
			filter = ""*"";

		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();

		if(searchSelection.isSelected())
			fileset = new CurrentBufferSet();
		else if(searchCurrentBuffer.isSelected())
		{
			fileset = new CurrentBufferSet();

			jEdit.setBooleanProperty(""search.hypersearch.toggle"",
				hyperSearch.isSelected());
		}
		else if(searchAllBuffers.isSelected())
			fileset = new AllBufferSet(filter);
		else if(searchDirectory.isSelected())
		{
			String directory = this.directory.getText();
			this.directory.addCurrentToHistory();

			if((VFSManager.getVFSForPath(directory).getCapabilities()
				& VFS.LOW_LATENCY_CAP) == 0)
			{
				if(cancel)
					return false;

				int retVal = GUIUtilities.confirm(
					SearchDialog.this,""remote-dir-search"",
					null,JOptionPane.YES_NO_OPTION,
					JOptionPane.WARNING_MESSAGE);
				if(retVal != JOptionPane.YES_OPTION)
					return false;
			}

			boolean recurse = searchSubDirectories.isSelected();

			if(fileset instanceof DirectoryListSet)
			{
				DirectoryListSet dset = (DirectoryListSet)fileset;
				if(!dset.getDirectory().equals(directory)
					|| !dset.getFileFilter().equals(filter)
					|| !dset.isRecursive() == recurse)
					fileset = new DirectoryListSet(directory,filter,recurse);
			}
			else
				fileset = new DirectoryListSet(directory,filter,recurse);
		}
		else
		{
			
			fileset = null;
		}

		jEdit.setBooleanProperty(""search.keepDialog.toggle"",
			keepDialog.isSelected());

		boolean ok = true;

		SearchAndReplace.setSearchFileSet(fileset);

		if(find.getText().length() != 0)
		{
			find.addCurrentToHistory();
			SearchAndReplace.setSearchString(find.getText());
			replace.addCurrentToHistory();

			SearchAndReplace.setReplaceString(replace.getText());
		}
		else
			ok = false;

		return ok;
	} 

	
	private void closeOrKeepDialog()
	{
		if(keepDialog.isSelected())
		{
			
			

			
			
			if(!hyperSearch.isSelected())
			{
				toFront();
				requestFocus();
				find.requestFocus();
			}
			return;
		}
		else
		{
			GUIUtilities.saveGeometry(this,""search"");
			dispose();
		}
	} 

	

	

	

	
	
	
	class MyJRadioButton extends JRadioButton
	{
		MyJRadioButton(String label)
		{
			super(label);
		}

		public boolean isFocusTraversable()
		{
			return false;
		}
	} 

	
	class ReplaceActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			replace.setModel(beanShellReplace.isSelected()
				? ""replace.script""
				: ""replace"");
			SearchAndReplace.setBeanShellReplace(
				beanShellReplace.isSelected());
		}
	} 

	
	class SettingsActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == ignoreCase)
				SearchAndReplace.setIgnoreCase(ignoreCase.isSelected());
			else if(source == regexp)
				SearchAndReplace.setRegexp(regexp.isSelected());
			else if(source == searchBack || source == searchForward)
				SearchAndReplace.setReverseSearch(searchBack.isSelected());
			else if(source == wrap)
				SearchAndReplace.setAutoWrapAround(wrap.isSelected());
			else if(source == searchCurrentBuffer)
				hyperSearch.setSelected(false);
			else if(source == searchSelection
				|| source == searchAllBuffers
				|| source == searchDirectory)
				hyperSearch.setSelected(true);

			updateEnabled();
		}
	} 

	
	class MultiFileActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == choose)
			{
				String[] dirs = GUIUtilities.showVFSFileDialog(
					view,directory.getText(),
					VFSBrowser.CHOOSE_DIRECTORY_DIALOG,
					false);
				if(dirs != null)
					directory.setText(dirs[0]);
			}
			else 
			{
				
				
				ok();
			}
		}
	} 

	
	class ButtonActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == closeBtn)
				cancel();
			else if(source == findBtn || source == find
				|| source == replace)
			{
				ok();
			}
			else if(source == replaceAndFindBtn)
			{
				save(false);
				if(SearchAndReplace.replace(view))
					ok();
				else
					getToolkit().beep();
			}
			else if(source == replaceAllBtn)
			{
				setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));

				save(false);

				if(searchSelection.isSelected())
				{
					if(SearchAndReplace.replace(view))
						closeOrKeepDialog();
					else
						getToolkit().beep();
				}
				else
				{
					if(SearchAndReplace.replaceAll(view))
						closeOrKeepDialog();
					else
						getToolkit().beep();
				}

				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
			}
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.textarea.FoldVisibilityManager,21,1,0,14,52,0,9,7,21,0.492857143,1738,1.0,3,0.0,0.25170068,0,0,81.42857143,35,9.0952,0,"

package org.gjt.sp.jedit.textarea;


import java.awt.Toolkit;
import org.gjt.sp.jedit.buffer.OffsetManager;
import org.gjt.sp.jedit.*;



public class FoldVisibilityManager
{
	
	public FoldVisibilityManager(Buffer buffer, OffsetManager offsetMgr,
		JEditTextArea textArea)
	{
		this.buffer = buffer;
		this.offsetMgr = offsetMgr;
		this.textArea = textArea;
	} 

	
	
	public boolean isNarrowed()
	{
		return narrowed;
	} 

	
	
	public int getVirtualLineCount()
	{
		return offsetMgr.getVirtualLineCount(index);
	} 

	
	
	public final boolean isLineVisible(int line)
	{
		if(line < 0 || line >= offsetMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		try
		{
			buffer.readLock();
			return offsetMgr.isLineVisible(line,index);
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public int getFirstVisibleLine()
	{
		try
		{
			buffer.readLock();

			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				if(offsetMgr.isLineVisible(i,index))
					return i;
			}
		}
		finally
		{
			buffer.readUnlock();
		}

		
		return -1;
	} 

	
	
	public int getLastVisibleLine()
	{
		try
		{
			buffer.readLock();

			for(int i = buffer.getLineCount() - 1; i >= 0; i--)
			{
				if(offsetMgr.isLineVisible(i,index))
					return i;
			}
		}
		finally
		{
			buffer.readUnlock();
		}

		
		return -1;
	} 

	
	
	public int getNextVisibleLine(int line)
	{
		if(line < 0 || line >= offsetMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		try
		{
			buffer.readLock();

			if(line == buffer.getLineCount() - 1)
				return -1;

			for(int i = line + 1; i < buffer.getLineCount(); i++)
			{
				if(offsetMgr.isLineVisible(i,index))
					return i;
			}
			return -1;
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public int getPrevVisibleLine(int line)
	{
		if(line < 0 || line >= offsetMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(line);

		try
		{
			buffer.readLock();

			if(line == 0)
				return -1;

			for(int i = line - 1; i >= 0; i--)
			{
				if(offsetMgr.isLineVisible(i,index))
					return i;
			}
			return -1;
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public int physicalToVirtual(int line)
	{
		try
		{
			buffer.readLock();

			if(line < 0)
				throw new ArrayIndexOutOfBoundsException(line + "" < 0"");
			else if(line >= offsetMgr.getLineCount())
			{
				throw new ArrayIndexOutOfBoundsException(line + "" > ""
					+ buffer.getLineCount());
			}

			
			if(getVirtualLineCount() == buffer.getLineCount())
				return line;

			while(!offsetMgr.isLineVisible(line,index) && line > 0)
				line--;

			if(line == 0 && !offsetMgr.isLineVisible(line,index))
			{
				
				return 0;
			}

			if(lastPhysical == line)
			{
				if(lastVirtual < 0 || lastVirtual >= offsetMgr.getVirtualLineCount(index))
				{
					throw new ArrayIndexOutOfBoundsException(
						""cached: "" + lastVirtual);
				}
			}
			else if(line > lastPhysical && lastPhysical != -1)
			{
				for(;;)
				{
					if(lastPhysical == line)
						break;

					if(offsetMgr.isLineVisible(lastPhysical,index))
						lastVirtual++;

					if(lastPhysical == buffer.getLineCount() - 1)
						break;
					else
						lastPhysical++;
				}

				if(lastVirtual < 0 || lastVirtual >= offsetMgr.getVirtualLineCount(index))
				{
					throw new ArrayIndexOutOfBoundsException(
						""fwd scan: "" + lastVirtual);
				}
			}
			else if(line < lastPhysical && lastPhysical - line > line)
			{
				for(;;)
				{
					if(lastPhysical == line)
						break;

					if(offsetMgr.isLineVisible(lastPhysical,index))
						lastVirtual--;

					if(lastPhysical == 0)
						break;
					else
						lastPhysical--;
				}

				if(lastVirtual < 0 || lastVirtual >= offsetMgr.getVirtualLineCount(index))
				{
					throw new ArrayIndexOutOfBoundsException(
						""back scan: "" + lastVirtual);
				}
			}
			else
			{
				lastPhysical = 0;
				
				while(!offsetMgr.isLineVisible(lastPhysical,index))
					lastPhysical++;

				lastVirtual = 0;
				for(;;)
				{
					if(lastPhysical == line)
						break;

					if(offsetMgr.isLineVisible(lastPhysical,index))
						lastVirtual++;

					if(lastPhysical == buffer.getLineCount() - 1)
						break;
					else
						lastPhysical++;
				}

				if(lastVirtual < 0 || lastVirtual >= offsetMgr.getVirtualLineCount(index))
				{
					throw new ArrayIndexOutOfBoundsException(
						""zero scan: "" + lastVirtual);
				}
			}

			return lastVirtual;
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public int virtualToPhysical(int line)
	{
		try
		{
			buffer.readLock();

			if(line < 0)
				throw new ArrayIndexOutOfBoundsException(line + "" < 0"");
			else if(line >= offsetMgr.getVirtualLineCount(index))
			{
				throw new ArrayIndexOutOfBoundsException(line + "" > ""
					+ offsetMgr.getVirtualLineCount(index));
			}

			
			if(getVirtualLineCount() == buffer.getLineCount())
				return line;

			if(lastVirtual == line)
			{
				if(lastPhysical < 0 || lastPhysical >= buffer.getLineCount())
				{
					throw new ArrayIndexOutOfBoundsException(
						""cached: "" + lastPhysical);
				}
			}
			else if(line > lastVirtual && lastVirtual != -1)
			{
				for(;;)
				{
					if(offsetMgr.isLineVisible(lastPhysical,index))
					{
						if(lastVirtual == line)
							break;
						else
							lastVirtual++;
					}

					if(lastPhysical == buffer.getLineCount() - 1)
						break;
					else
						lastPhysical++;
				}

				if(lastPhysical < 0 || lastPhysical >= buffer.getLineCount())
				{
					throw new ArrayIndexOutOfBoundsException(
						""fwd scan: "" + lastPhysical);
				}
			}
			else if(line < lastVirtual && lastVirtual - line > line)
			{
				for(;;)
				{
					if(offsetMgr.isLineVisible(lastPhysical,index))
					{
						if(lastVirtual == line)
							break;
						else
							lastVirtual--;
					}

					if(lastPhysical == 0)
						break;
					else
						lastPhysical--;
				}

				if(lastPhysical < 0 || lastPhysical >= buffer.getLineCount())
				{
					throw new ArrayIndexOutOfBoundsException(
						""back scan: "" + lastPhysical);
				}
			}
			else
			{

				lastPhysical = 0;
				
				while(!offsetMgr.isLineVisible(lastPhysical,index))
					lastPhysical++;

				lastVirtual = 0;
				for(;;)
				{
					if(offsetMgr.isLineVisible(lastPhysical,index))
					{
						if(lastVirtual == line)
							break;
						else
							lastVirtual++;
					}

					if(lastPhysical == buffer.getLineCount() - 1)
						break;
					else
						lastPhysical++;
				}

				if(lastPhysical < 0 || lastPhysical >= buffer.getLineCount())
				{
					throw new ArrayIndexOutOfBoundsException(
						""zero scan: "" + lastPhysical);
				}
			}

			return lastPhysical;
		}
		finally
		{
			buffer.readUnlock();
		}
	} 

	
	
	public void collapseFold(int line)
	{
		int lineCount = buffer.getLineCount();
		int start = 0;
		int end = lineCount - 1;

		try
		{
			buffer.writeLock();

			
			
			if(line != 0
				&& line != buffer.getLineCount() - 1
				&& buffer.isFoldStart(line)
				&& !offsetMgr.isLineVisible(line + 1,index))
			{
				line--;
			}

			int initialFoldLevel = buffer.getFoldLevel(line);

			
			if(line != lineCount - 1
				&& buffer.getFoldLevel(line + 1) > initialFoldLevel)
			{
				
				start = line + 1;

				for(int i = line + 1; i < lineCount; i++)
				{
					if(buffer.getFoldLevel(i) <= initialFoldLevel)
					{
						end = i - 1;
						break;
					}
				}
			}
			else
			{
				boolean ok = false;

				
				for(int i = line - 1; i >= 0; i--)
				{
					if(buffer.getFoldLevel(i) < initialFoldLevel)
					{
						start = i + 1;
						ok = true;
						break;
					}
				}

				if(!ok)
				{
					
					return;
				}

				for(int i = line + 1; i < lineCount; i++)
				{
					if(buffer.getFoldLevel(i) < initialFoldLevel)
					{
						end = i - 1;
						break;
					}
				}
			} 

			
			int delta = (end - start + 1);

			for(int i = start; i <= end; i++)
			{
				if(offsetMgr.isLineVisible(i,index))
					offsetMgr.setLineVisible(i,index,false);
				else
					delta--;
			}

			if(delta == 0)
			{
				
				return;
			}

			offsetMgr.setVirtualLineCount(index,
				offsetMgr.getVirtualLineCount(index)
				- delta);
			
		}
		finally
		{
			buffer.writeUnlock();
		}

		foldStructureChanged();

		int virtualLine = physicalToVirtual(start);
		if(textArea.getFirstLine() > virtualLine)
			textArea.setFirstLine(virtualLine - textArea.getElectricScroll());
	} 

	
	
	public int expandFold(int line, boolean fully)
	{
		
		int returnValue = -1;

		int lineCount = buffer.getLineCount();
		int start = 0;
		int end = lineCount - 1;
		int delta = 0;

		try
		{
			buffer.writeLock();

			int initialFoldLevel = buffer.getFoldLevel(line);

			
			if(line != lineCount - 1
				&& offsetMgr.isLineVisible(line,index)
				&& !offsetMgr.isLineVisible(line + 1,index)
				&& buffer.getFoldLevel(line + 1) > initialFoldLevel)
			{
				
				start = line + 1;

				for(int i = line + 1; i < lineCount; i++)
				{
					if(
						buffer.getFoldLevel(i) <= initialFoldLevel)
					{
						end = i - 1;
						break;
					}
				}
			}
			else
			{
				boolean ok = false;

				
				for(int i = line - 1; i >= 0; i--)
				{
					if(offsetMgr.isLineVisible(i,index) && buffer.getFoldLevel(i) < initialFoldLevel)
					{
						start = i + 1;
						ok = true;
						break;
					}
				}

				if(!ok)
				{
					
					return -1;
				}

				for(int i = line + 1; i < lineCount; i++)
				{
					if((offsetMgr.isLineVisible(i,index) &&
						buffer.getFoldLevel(i) < initialFoldLevel)
						|| i == getLastVisibleLine())
					{
						end = i - 1;
						break;
					}
				}
			} 

			

			
			initialFoldLevel = buffer.getFoldLevel(start);

			for(int i = start; i <= end; i++)
			{
				buffer.getFoldLevel(i);
			}

			for(int i = start; i <= end; i++)
			{
				if(buffer.getFoldLevel(i) > initialFoldLevel)
				{
					if(returnValue == -1
						&& i != 0
						&& buffer.isFoldStart(i - 1))
					{
						returnValue = i - 1;
					}

					if(!offsetMgr.isLineVisible(i,index) && fully)
					{
						delta++;
						offsetMgr.setLineVisible(i,index,true);
					}
				}
				else if(!offsetMgr.isLineVisible(i,index))
				{
					delta++;
					offsetMgr.setLineVisible(i,index,true);
				}
			}

			offsetMgr.setVirtualLineCount(index,
				offsetMgr.getVirtualLineCount(index)
				+ delta);
			

			if(!fully && !offsetMgr.isLineVisible(line,index))
			{
				
				expandFold(line,false);
				return returnValue;
			}
		}
		finally
		{
			buffer.writeUnlock();
		}

		foldStructureChanged();

		int virtualLine = physicalToVirtual(start);
		int firstLine = textArea.getFirstLine();
		int visibleLines = textArea.getVisibleLines();
		if(virtualLine + delta >= firstLine + visibleLines
			&& delta < visibleLines - 1)
		{
			textArea.setFirstLine(virtualLine + delta - visibleLines + 1);
		}

		return returnValue;
	} 

	
	
	public void expandAllFolds()
	{
		try
		{
			buffer.writeLock();

			narrowed = false;

			if(offsetMgr.getVirtualLineCount(index) == buffer.getLineCount())
				return;

			offsetMgr.setVirtualLineCount(index,buffer.getLineCount());
			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				offsetMgr.setLineVisible(i,index,true);
			}
			foldStructureChanged();
		}
		finally
		{
			buffer.writeUnlock();
		}
	} 

	
	
	public void expandFolds(char digit)
	{
		if(digit < '1' || digit > '9')
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}
		else
			expandFolds((int)(digit - '1') + 1);
	} 

	
	
	public void expandFolds(int foldLevel)
	{
		try
		{
			buffer.writeLock();

			narrowed = false;

			
			
			offsetMgr.setVirtualLineCount(index,buffer.getLineCount());

			int newVirtualLineCount = 0;
			foldLevel = (foldLevel - 1) * buffer.getIndentSize() + 1;

			
			boolean seenVisibleLine = false;

			for(int i = 0; i < buffer.getLineCount(); i++)
			{
				if(!seenVisibleLine || buffer.getFoldLevel(i) < foldLevel)
				{
					seenVisibleLine = true;
					offsetMgr.setLineVisible(i,index,true);
					newVirtualLineCount++;
				}
				else
					offsetMgr.setLineVisible(i,index,false);
			}

			offsetMgr.setVirtualLineCount(index,newVirtualLineCount);
		}
		finally
		{
			buffer.writeUnlock();
		}

		foldStructureChanged();
	} 

	
	
	public void narrow(int start, int end)
	{
		if(start > end || start < 0 || end >= offsetMgr.getLineCount())
			throw new ArrayIndexOutOfBoundsException(start + "", "" + end);

		if(start < getFirstVisibleLine() || end > getLastVisibleLine())
			expandAllFolds();
		
		else if(start != offsetMgr.getLineCount() - 1
			&& !offsetMgr.isLineVisible(start + 1,index))
			expandFold(start,false);

		int virtualLineCount = offsetMgr.getVirtualLineCount(index);
		for(int i = 0; i < start; i++)
		{
			if(offsetMgr.isLineVisible(i,index))
			{
				virtualLineCount--;
				offsetMgr.setLineVisible(i,index,false);
			}
		}

		for(int i = end + 1; i < buffer.getLineCount(); i++)
		{
			if(offsetMgr.isLineVisible(i,index))
			{
				virtualLineCount--;
				offsetMgr.setLineVisible(i,index,false);
			}
		}

		offsetMgr.setVirtualLineCount(index,virtualLineCount);

		narrowed = true;

		foldStructureChanged();

		
		
		GUIUtilities.getView(textArea).getStatus().setMessageAndClear(
			jEdit.getProperty(""view.status.narrow""));
	} 

	

	
	
	public final void _grab(int index)
	{
		this.index = index;
		lastPhysical = lastVirtual = -1;
	} 

	
	
	public final void _release()
	{
		index = -1;
	} 

	
	
	public final int _getIndex()
	{
		return index;
	} 

	
	
	public void _invalidate(int startLine)
	{
		if(lastPhysical >= startLine)
			lastPhysical = lastVirtual = -1;
	} 

	

	
	
	public void foldStructureChanged()
	{
		lastPhysical = lastVirtual = -1;
		textArea.foldStructureChanged();
	} 

	

	
	private Buffer buffer;
	private OffsetManager offsetMgr;
	private JEditTextArea textArea;
	private int index;
	private int lastPhysical;
	private int lastVirtual;
	private boolean narrowed;
	

	
}
"
jEdit,4.1,org.gjt.sp.jedit.EditAction,12,1,5,29,18,54,28,3,12,0.727272727,49,1.0,0,0.0,0.3125,0,0,3.0,1,0.9167,0,"

package org.gjt.sp.jedit;


import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.Component;



public abstract class EditAction
{
	
	
	public EditAction(String name)
	{
		this.name = name;
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public String getLabel()
	{
		return jEdit.getProperty(name + "".label"");
	} 

	
	
	public String getMouseOverText()
	{
		return null;
	} 

	
	
	public abstract void invoke(View view);
	

	
	
	public static View getView(Component comp)
	{
		
		return GUIUtilities.getView(comp);
	} 

	
	
	public boolean isToggle()
	{
		return false;
	} 

	
	
	public boolean isSelected(View view)
	{
		return false;
	} 

	
	
	public boolean noRepeat()
	{
		return false;
	} 

	
	
	public boolean noRecord()
	{
		return false;
	} 

	
	
	public abstract String getCode();
	

	
	public String toString()
	{
		return name;
	} 

	
	private String name;
	

	
	
	public static class Wrapper implements ActionListener
	{
		public Wrapper(EditAction action)
		{
			this.action = action;
		}

		
		public void actionPerformed(ActionEvent evt)
		{
			jEdit.getActiveView().getInputHandler().invokeAction(action);
		}

		private EditAction action;
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.EditServer,6,2,0,8,54,5,3,7,2,0.72,377,1.0,0,0.924242424,0.305555556,0,0,61.0,13,3.8333,0,"

package org.gjt.sp.jedit;


import javax.swing.SwingUtilities;
import java.io.*;
import java.net.*;
import java.util.Random;
import org.gjt.sp.jedit.io.FileVFS;
import org.gjt.sp.util.Log;



public class EditServer extends Thread
{
	
	EditServer(String portFile)
	{
		super(""jEdit server daemon ["" + portFile + ""]"");
		setDaemon(true);
		this.portFile = portFile;

		try
		{
			
			
			
			
			
			if(OperatingSystem.isUnix())
			{
				new File(portFile).createNewFile();
				FileVFS.setPermissions(portFile,0600);
			}

			
			
			socket = new ServerSocket(0, 2,
				InetAddress.getByName(""127.0.0.1""));
			authKey = Math.abs(new Random().nextInt());
			int port = socket.getLocalPort();

			FileWriter out = new FileWriter(portFile);
			out.write(""b\n"");
			out.write(String.valueOf(port));
			out.write(""\n"");
			out.write(String.valueOf(authKey));
			out.write(""\n"");
			out.close();

			Log.log(Log.DEBUG,this,""jEdit server started on port ""
				+ socket.getLocalPort());
			Log.log(Log.DEBUG,this,""Authorization key is ""
				+ authKey);

			ok = true;
		}
		catch(IOException io)
		{
			
			Log.log(Log.NOTICE,this,io);
		}
	} 

	
	public void run()
	{
		for(;;)
		{
			if(abort)
				return;

			Socket client = null;
			try
			{
				client = socket.accept();

				
				
				
				client.setSoTimeout(1000);

				Log.log(Log.MESSAGE,this,client + "": connected"");

				DataInputStream in = new DataInputStream(
					client.getInputStream());

				if(!handleClient(client,in))
					abort = true;
			}
			catch(Exception e)
			{
				if(!abort)
					Log.log(Log.ERROR,this,e);
				abort = true;
			}
			finally
			{
				if(client != null)
				{
					try
					{
						client.close();
					}
					catch(Exception e)
					{
						Log.log(Log.ERROR,this,e);
					}

					client = null;
				}
			}
		}
	} 

	
	
	public static void handleClient(boolean restore, String parent,
		String[] args)
	{
		String splitConfig = null;

		boolean newView = jEdit.getBooleanProperty(""client.newView"");

		
		if(jEdit.getFirstView() == null || newView)
		{
			
			
			

			Buffer buffer = jEdit.openFiles(null,parent,args);

			if(restore)
			{
				if(jEdit.getFirstBuffer() == null
					|| (jEdit.getFirstBuffer().isUntitled()
					&& jEdit.getBufferCount() == 1))
					splitConfig = jEdit.restoreOpenFiles();
				else if(jEdit.getBooleanProperty(""restore.cli""))
				{
					
					jEdit.restoreOpenFiles();
				}
			}

			
			
			if(jEdit.getFirstBuffer() == null
					|| (jEdit.getFirstBuffer().isUntitled()
                                        && jEdit.getBufferCount() == 1))
				buffer = jEdit.newFile(null);

			if(splitConfig != null)
				jEdit.newView(null,splitConfig);
			else
				jEdit.newView(null,buffer);
		}
		else
		{
			
			View view = jEdit.getFirstView();

			jEdit.openFiles(view,parent,args);

			
			
			
			
			if (OperatingSystem.isWindows())
				view.setState(java.awt.Frame.ICONIFIED);
			
			
			view.setState(java.awt.Frame.NORMAL);
			view.requestFocus();
			view.toFront();

			
			return;
		}
	} 

	
	boolean isOK()
	{
		return ok;
	} 

	
	void stopServer()
	{
		abort = true;
		try
		{
			socket.close();
		}
		catch(IOException io)
		{
		}

		new File(portFile).delete();
	} 

	

	
	private String portFile;
	private ServerSocket socket;
	private int authKey;
	private boolean ok;
	private boolean abort;
	

	
	private boolean handleClient(Socket client, DataInputStream in)
		throws Exception
	{
		int key = in.readInt();
		if(key != authKey)
		{
			Log.log(Log.ERROR,this,client + "": wrong""
				+ "" authorization key (got "" + key
				+ "", expected "" + authKey + "")"");
			in.close();
			client.close();

			return false;
		}
		else
		{
			
			client.setSoTimeout(0);

			Log.log(Log.DEBUG,this,client + "": authenticated""
				+ "" successfully"");

			final String script = in.readUTF();
			Log.log(Log.DEBUG,this,script);

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					BeanShell.eval(null,BeanShell.getNameSpace(),
						script);
				}
			});

			return true;
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.options.FirewallOptionPane,12,6,0,4,31,28,2,3,3,0.818181818,269,1.0,0,0.983823529,0.5,2,4,20.66666667,1,0.9167,0,"

package org.gjt.sp.jedit.options;

 
import java.awt.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;


public class FirewallOptionPane extends AbstractOptionPane {

	
	public FirewallOptionPane()
	{
		super(""firewall"");
	} 

	
	public void _init()
	{
		
		addComponent(httpEnabled = new JCheckBox(jEdit.getProperty(
			""options.firewall.http.enabled"")));
		
		addComponent(jEdit.getProperty(""options.firewall.http.host""), 
			httpHost = new JTextField(jEdit.getProperty(""firewall.host""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.http.port""), 
			httpPort = new JTextField(jEdit.getProperty(""firewall.port""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.http.user""),
			httpUser = new JTextField(jEdit.getProperty(""firewall.user""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.http.password""),
			httpPass = new JPasswordField(jEdit.getProperty(""firewall.password""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.http.nonProxy""),
			httpNonProxy = new JTextField(jEdit.getProperty(""firewall.nonProxyHosts""), 15));

		boolean enabled = jEdit.getBooleanProperty(""firewall.enabled"");
		httpEnabled.setSelected(enabled);
		httpHost.setEnabled(enabled);
		httpPort.setEnabled(enabled);
		httpUser.setEnabled(enabled);
		httpPass.setEnabled(enabled);
		httpNonProxy.setEnabled(enabled);

		httpEnabled.addActionListener(new ActionHandler());

		
		addComponent(socksEnabled = new JCheckBox(jEdit.getProperty(
			""options.firewall.socks.enabled"")));
		
		addComponent(jEdit.getProperty(""options.firewall.socks.host""), 
			socksHost = new JTextField(jEdit.getProperty(""firewall.socks.host""), 15));
		
		addComponent(jEdit.getProperty(""options.firewall.socks.port""), 
			socksPort = new JTextField(jEdit.getProperty(""firewall.socks.port""), 15));

		enabled = jEdit.getBooleanProperty(""firewall.socks.enabled"");
		socksEnabled.setSelected(enabled);
		socksHost.setEnabled(enabled);
		socksPort.setEnabled(enabled);

		socksEnabled.addActionListener(new ActionHandler());
	} 

	
	public void _save() {
		jEdit.setBooleanProperty(""firewall.enabled"", httpEnabled.isSelected());
		jEdit.setProperty(""firewall.host"", httpHost.getText());
		jEdit.setProperty(""firewall.port"", httpPort.getText());
		jEdit.setProperty(""firewall.user"", httpUser.getText());
		jEdit.setProperty(""firewall.password"", new String(httpPass.getPassword()));
		jEdit.setProperty(""firewall.nonProxyHosts"", httpNonProxy.getText());

		jEdit.setBooleanProperty(""firewall.socks.enabled"", socksEnabled.isSelected());
		jEdit.setProperty(""firewall.socks.host"", socksHost.getText());
		jEdit.setProperty(""firewall.socks.port"", socksPort.getText());
	} 

	
	private JCheckBox httpEnabled;
	private JTextField httpHost;
	private JTextField httpPort;
	private JTextField httpUser;
	private JPasswordField httpPass;
	private JTextField httpNonProxy;
	private JCheckBox socksEnabled;
	private JTextField socksHost;
	private JTextField socksPort;
	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			httpHost.setEnabled(httpEnabled.isSelected());
			httpPort.setEnabled(httpEnabled.isSelected());
			httpUser.setEnabled(httpEnabled.isSelected());
			httpPass.setEnabled(httpEnabled.isSelected());
			httpNonProxy.setEnabled(httpEnabled.isSelected());
			socksHost.setEnabled(socksEnabled.isSelected());
			socksPort.setEnabled(socksEnabled.isSelected());
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.View,60,6,0,138,221,1420,125,37,45,0.949152542,1722,0.515151515,9,0.916193182,0.08245614,2,3,27.15,20,2.8,6,"

package org.gjt.sp.jedit;


import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.search.*;
import org.gjt.sp.jedit.textarea.*;



public class View extends JFrame implements EBComponent
{
	

	

	
	
	public static final int TOP_GROUP = 0;

	
	public static final int BOTTOM_GROUP = 1;
	public static final int DEFAULT_GROUP = TOP_GROUP;
	

	

	
	
	public static final int TOP_LAYER = Integer.MAX_VALUE;

	
	public static final int DEFAULT_LAYER = 0;

	
	public static final int BOTTOM_LAYER = Integer.MIN_VALUE;

	
	
	public static final int ABOVE_SYSTEM_BAR_LAYER = 150;

	
	public static final int SYSTEM_BAR_LAYER = 100;

	
	public static final int BELOW_SYSTEM_BAR_LAYER = 75;

	
	public static final int SEARCH_BAR_LAYER = 75;

	
	public static final int BELOW_SEARCH_BAR_LAYER = 50;

	
	
	public static final int ABOVE_STATUS_BAR_LAYER = -50;

	
	public static final int STATUS_BAR_LAYER = -100;

	
	public static final int BELOW_STATUS_BAR_LAYER = -150;
	

	

	
	
	public DockableWindowManager getDockableWindowManager()
	{
		return dockableWindowManager;
	} 

	
	
	public JToolBar getToolBar()
	{
		return toolBar;
	} 

	
	
	public void addToolBar(Component toolBar)
	{
		addToolBar(DEFAULT_GROUP, DEFAULT_LAYER, toolBar);
	} 

	
	
	public void addToolBar(int group, Component toolBar)
	{
		addToolBar(group, DEFAULT_LAYER, toolBar);
	} 

	
	
	public void addToolBar(int group, int layer, Component toolBar)
	{
		if(toolBar instanceof SearchBar)
			searchBar = (SearchBar)toolBar;

		toolBarManager.addToolBar(group, layer, toolBar);
		getRootPane().revalidate();
	} 

	
	
	public void removeToolBar(Component toolBar)
	{
		if(toolBar == searchBar)
			searchBar = null;

		toolBarManager.removeToolBar(toolBar);
		getRootPane().revalidate();
	} 

	
	
	public synchronized void showWaitCursor()
	{
		if(waitCount++ == 0)
		{
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR);
			setCursor(cursor);
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane editPane = editPanes[i];
				editPane.getTextArea().getPainter()
					.setCursor(cursor);
			}
		}
	} 

	
	
	public synchronized void hideWaitCursor()
	{
		if(waitCount > 0)
			waitCount--;

		if(waitCount == 0)
		{
			
			
			Cursor cursor = Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR);
			setCursor(cursor);
			cursor = Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR);
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane editPane = editPanes[i];
				editPane.getTextArea().getPainter()
					.setCursor(cursor);
			}
		}
	} 

	
	
	public final SearchBar getSearchBar()
	{
		return searchBar;
	} 

	
	
	public StatusBar getStatus()
	{
		return status;
	} 

	

	

	
	
	public KeyListener getKeyEventInterceptor()
	{
		return keyEventInterceptor;
	} 

	
	
	public void setKeyEventInterceptor(KeyListener listener)
	{
		this.keyEventInterceptor = listener;
	} 

	
	
	public InputHandler getInputHandler()
	{
		return inputHandler;
	} 

	
	
	public void setInputHandler(InputHandler inputHandler)
	{
		this.inputHandler = inputHandler;
	} 

	
	
	public Macros.Recorder getMacroRecorder()
	{
		return recorder;
	} 

	
	
	public void setMacroRecorder(Macros.Recorder recorder)
	{
		this.recorder = recorder;
	} 

	
	
	public void processKeyEvent(KeyEvent evt)
	{
		if(isClosed())
			return;

		if(getFocusOwner() instanceof JComponent)
		{
			JComponent comp = (JComponent)getFocusOwner();
			InputMap map = comp.getInputMap();
			ActionMap am = comp.getActionMap();

			if(map != null && am != null && comp.isEnabled())
			{
				Object binding = map.get(KeyStroke.getKeyStrokeForEvent(evt));
				if(binding != null && am.get(binding) != null)
				{
					return;
				}
			}
		}

		if(getFocusOwner() instanceof JTextComponent)
		{
			
			
			if(evt.getID() == KeyEvent.KEY_PRESSED)
			{
				switch(evt.getKeyCode())
				{
				case KeyEvent.VK_BACK_SPACE:
				case KeyEvent.VK_TAB:
				case KeyEvent.VK_ENTER:
					return;
				}
			}
		}

		if(evt.isConsumed())
			return;

		evt = KeyEventWorkaround.processKeyEvent(evt);
		if(evt == null)
			return;

		switch(evt.getID())
		{
		case KeyEvent.KEY_TYPED:
			
			if(keyEventInterceptor != null)
				;
			else if(inputHandler.isPrefixActive()
				&& !getTextArea().hasFocus())
				inputHandler.keyTyped(evt);
			break;
		case KeyEvent.KEY_PRESSED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyPressed(evt);
			else
				inputHandler.keyPressed(evt);
			break;
		case KeyEvent.KEY_RELEASED:
			if(keyEventInterceptor != null)
				keyEventInterceptor.keyReleased(evt);
			else
				inputHandler.keyReleased(evt);
			break;
		}

		if(!evt.isConsumed())
			super.processKeyEvent(evt);
	} 

	

	

	
	
	public EditPane splitHorizontally()
	{
		return split(JSplitPane.VERTICAL_SPLIT);
	} 

	
	
	public EditPane splitVertically()
	{
		return split(JSplitPane.HORIZONTAL_SPLIT);
	} 

	
	
	public EditPane split(int orientation)
	{
		editPane.saveCaretInfo();
		EditPane oldEditPane = editPane;
		setEditPane(createEditPane(oldEditPane.getBuffer()));
		editPane.loadCaretInfo();

		JComponent oldParent = (JComponent)oldEditPane.getParent();

		final JSplitPane newSplitPane = new JSplitPane(orientation);
		newSplitPane.setOneTouchExpandable(true);
		newSplitPane.setBorder(null);
		newSplitPane.setMinimumSize(new Dimension(0,0));

		if(oldParent instanceof JSplitPane)
		{
			JSplitPane oldSplitPane = (JSplitPane)oldParent;
			int dividerPos = oldSplitPane.getDividerLocation();

			Component left = oldSplitPane.getLeftComponent();

			if(left == oldEditPane)
				oldSplitPane.setLeftComponent(newSplitPane);
			else
				oldSplitPane.setRightComponent(newSplitPane);

			newSplitPane.setLeftComponent(oldEditPane);
			newSplitPane.setRightComponent(editPane);

			oldSplitPane.setDividerLocation(dividerPos);
		}
		else
		{
			this.splitPane = newSplitPane;

			newSplitPane.setLeftComponent(oldEditPane);
			newSplitPane.setRightComponent(editPane);

			oldParent.add(newSplitPane);
			oldParent.revalidate();
		}

		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				newSplitPane.setDividerLocation(0.5);
				editPane.focusOnTextArea();
			}
		});

		return editPane;
	} 

	
	
	public void unsplit()
	{
		if(splitPane != null)
		{
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane _editPane = editPanes[i];
				if(editPane != _editPane)
					_editPane.close();
			}

			JComponent parent = (JComponent)splitPane.getParent();

			parent.remove(splitPane);
			parent.add(editPane);
			parent.revalidate();

			splitPane = null;
			updateTitle();

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					editPane.focusOnTextArea();
				}
			});
		}
		else
			getToolkit().beep();
	} 

	
	
	public void unsplitCurrent()
	{
		if(splitPane != null)
		{
			
			Component comp = editPane;
			while(!(comp instanceof JSplitPane))
			{
				comp = comp.getParent();
			}

			
			
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				EditPane _editPane = editPanes[i];
				if(GUIUtilities.isAncestorOf(comp,_editPane)
					&& _editPane != editPane)
					_editPane.close();
			}

			JComponent parent = (JComponent)comp.getParent();

			if(parent instanceof JSplitPane)
			{
				JSplitPane parentSplit = (JSplitPane)parent;
				int pos = parentSplit.getDividerLocation();
				if(parentSplit.getLeftComponent() == comp)
					parentSplit.setLeftComponent(editPane);
				else
					parentSplit.setRightComponent(editPane);
				parentSplit.setDividerLocation(pos);
			}
			else
			{
				parent.remove(comp);
				parent.add(editPane);
				splitPane = null;
			}

			parent.revalidate();

			updateTitle();

			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					editPane.focusOnTextArea();
				}
			});
		}
		else
			getToolkit().beep();
	} 

	
	
	public void nextTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == editPanes.length - 1)
					editPanes[0].focusOnTextArea();
				else
					editPanes[i+1].focusOnTextArea();
				break;
			}
		}
	} 

	
	
	public void prevTextArea()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPane == editPanes[i])
			{
				if(i == 0)
					editPanes[editPanes.length - 1].focusOnTextArea();
				else
					editPanes[i-1].focusOnTextArea();
				break;
			}
		}
	} 

	
	
	public JSplitPane getSplitPane()
	{
		return splitPane;
	} 

	
	
	public Buffer getBuffer()
	{
		if(editPane == null)
			return null;
		else
			return editPane.getBuffer();
	} 

	
	
	public void setBuffer(Buffer buffer)
	{
		editPane.setBuffer(buffer);
	} 

	
	
	public JEditTextArea getTextArea()
	{
		if(editPane == null)
			return null;
		else
			return editPane.getTextArea();
	} 

	
	
	public EditPane getEditPane()
	{
		return editPane;
	} 

	
	
	public EditPane[] getEditPanes()
	{
		if(splitPane == null)
		{
			EditPane[] ep = { editPane };
			return ep;
		}
		else
		{
			Vector vec = new Vector();
			getEditPanes(vec,splitPane);
			EditPane[] ep = new EditPane[vec.size()];
			vec.copyInto(ep);
			return ep;
		}
	} 

	
	
	public String getSplitConfig()
	{
		

		StringBuffer splitConfig = new StringBuffer();
		
		
		
			splitConfig.append(getBuffer().getPath());
		return splitConfig.toString();
	} 

	
	
	public void updateGutterBorders()
	{
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].getTextArea().getGutter().updateBorder();
	} 

	

	

	
	
	public boolean isSynchroScrollEnabled()
	{
		return synchroScroll;
	} 

	
	
	public void toggleSynchroScrollEnabled()
	{
		setSynchroScrollEnabled(!synchroScroll);
	} 

	
	
	public void setSynchroScrollEnabled(boolean synchroScroll)
	{
		this.synchroScroll = synchroScroll;
		JEditTextArea textArea = getTextArea();
		int firstLine = textArea.getFirstLine();
		int horizontalOffset = textArea.getHorizontalOffset();
		synchroScrollVertical(textArea,firstLine);
		synchroScrollHorizontal(textArea,horizontalOffset);
	} 

	
	
	public void synchroScrollVertical(JEditTextArea textArea, int firstLine)
	{
		if(!synchroScroll)
			return;

		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPanes[i].getTextArea() != textArea)
				editPanes[i].getTextArea()._setFirstLine(firstLine);
		}
	} 

	
	
	public void synchroScrollHorizontal(JEditTextArea textArea, int horizontalOffset)
	{
		if(!synchroScroll)
			return;

		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			if(editPanes[i].getTextArea() != textArea)
				editPanes[i].getTextArea()._setHorizontalOffset(horizontalOffset);
		}
	} 

	

	
	
	public void quickIncrementalSearch(boolean word)
	{
		if(searchBar == null)
		{
			addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,
				new SearchBar(this,true));
		}

		JEditTextArea textArea = getTextArea();

		String text = textArea.getSelectedText();
		if(text == null && word)
		{
			textArea.selectWord();
			text = textArea.getSelectedText();
		}
		else if(text != null && text.indexOf('\n') != -1)
			text = null;

		searchBar.setHyperSearch(false);
		searchBar.getField().setText(text);
		searchBar.getField().requestFocus();
		searchBar.getField().selectAll();
	} 

	
	
	public void quickHyperSearch(boolean word)
	{
		JEditTextArea textArea = getTextArea();

		String text = textArea.getSelectedText();
		if(text == null && word)
		{
			textArea.selectWord();
			text = textArea.getSelectedText();
		}

		if(text != null && text.indexOf('\n') == -1)
		{
			HistoryModel.getModel(""find"").addItem(text);
			SearchAndReplace.setSearchString(text);
			SearchAndReplace.setSearchFileSet(new CurrentBufferSet());
			SearchAndReplace.hyperSearch(this);
		}
		else
		{
			if(searchBar == null)
			{
				addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,
					new SearchBar(this,true));
			}

			searchBar.setHyperSearch(true);
			searchBar.getField().setText(null);
			searchBar.getField().requestFocus();
			searchBar.getField().selectAll();
		}
	} 

	
	
	public boolean isClosed()
	{
		return closed;
	} 

	
	
	public boolean isPlainView()
	{
		return plainView;
	} 

	
	
	public View getNext()
	{
		return next;
	} 

	
	
	public View getPrev()
	{
		return prev;
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof SearchSettingsChanged)
		{
			if(searchBar != null)
				searchBar.update();
		}
		else if(msg instanceof BufferUpdate)
			handleBufferUpdate((BufferUpdate)msg);
		else if(msg instanceof EditPaneUpdate)
			handleEditPaneUpdate((EditPaneUpdate)msg);
	} 

	
	public Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} 

	
	View prev;
	View next;

	
	View(Buffer buffer, String splitConfig, boolean plainView)
	{
		this.plainView = plainView;

		enableEvents(AWTEvent.KEY_EVENT_MASK);

		setIconImage(GUIUtilities.getEditorIcon());

		dockableWindowManager = new DockableWindowManager(this);

		topToolBars = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,
			1));
		bottomToolBars = new JPanel(new VariableGridLayout(
			VariableGridLayout.FIXED_NUM_COLUMNS,
			1));

		toolBarManager = new ToolBarManager(topToolBars, bottomToolBars);

		status = new StatusBar(this);

		setJMenuBar(GUIUtilities.loadMenuBar(""view.mbar""));

		inputHandler = new DefaultInputHandler(this,(DefaultInputHandler)
			jEdit.getInputHandler());

		Component comp = restoreSplitConfig(buffer,splitConfig);
		dockableWindowManager.add(comp);

		EditBus.addToBus(this);

		getContentPane().add(BorderLayout.CENTER,dockableWindowManager);

		
		
		propertiesChanged();

		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		addWindowListener(new WindowHandler());

		dockableWindowManager.init();
	} 

	
	void close()
	{
		closed = true;

		
		dockableWindowManager.close();

		GUIUtilities.saveGeometry(this,(plainView ? ""plain-view""
			: ""view""));
		EditBus.removeFromBus(this);
		dispose();

		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
			editPanes[i].close();

		
		
		toolBarManager = null;
		toolBar = null;
		searchBar = null;
		splitPane = null;
		inputHandler = null;
		recorder = null;

		getContentPane().removeAll();
	} 

	
	
	void updateTitle()
	{
		Vector buffers = new Vector();
		EditPane[] editPanes = getEditPanes();
		for(int i = 0; i < editPanes.length; i++)
		{
			Buffer buffer = editPanes[i].getBuffer();
			if(buffers.indexOf(buffer) == -1)
				buffers.addElement(buffer);
		}

		StringBuffer title = new StringBuffer(jEdit.getProperty(""view.title""));
		for(int i = 0; i < buffers.size(); i++)
		{
			if(i != 0)
				title.append("", "");

			Buffer buffer = (Buffer)buffers.elementAt(i);
			title.append((showFullPath && !buffer.isNewFile())
				? buffer.getPath() : buffer.getName());
		}
		setTitle(title.toString());
	} 

	

	

	
	private boolean closed;

	private DockableWindowManager dockableWindowManager;

	private JPanel topToolBars;
	private JPanel bottomToolBars;
	private ToolBarManager toolBarManager;

	private JToolBar toolBar;
	private SearchBar searchBar;

	private boolean synchroScroll;

	private EditPane editPane;
	private JSplitPane splitPane;

	private StatusBar status;

	private KeyListener keyEventInterceptor;
	private InputHandler inputHandler;
	private Macros.Recorder recorder;

	private int waitCount;

	private boolean showFullPath;

	private boolean plainView;
	

	
	private void getEditPanes(Vector vec, Component comp)
	{
		if(comp instanceof EditPane)
			vec.addElement(comp);
		else if(comp instanceof JSplitPane)
		{
			JSplitPane split = (JSplitPane)comp;
			getEditPanes(vec,split.getLeftComponent());
			getEditPanes(vec,split.getRightComponent());
		}
	} 

	
	
	private void getSplitConfig(JSplitPane splitPane,
		StringBuffer splitConfig)
	{
		Component left = splitPane.getLeftComponent();
		if(left instanceof JSplitPane)
			getSplitConfig((JSplitPane)left,splitConfig);
		else
		{
			splitConfig.append('\t');
			splitConfig.append(((EditPane)left).getBuffer().getPath());
		}

		Component right = splitPane.getRightComponent();
		if(right instanceof JSplitPane)
			getSplitConfig((JSplitPane)right,splitConfig);
		else
		{
			splitConfig.append('\t');
			splitConfig.append(((EditPane)right).getBuffer().getPath());
		}

		splitConfig.append(splitPane.getOrientation()
			== JSplitPane.VERTICAL_SPLIT ? ""\tvertical"" : ""\thorizontal"");
	} 

	
	private Component restoreSplitConfig(Buffer buffer, String splitConfig)
	{
		if(buffer != null)
			return (editPane = createEditPane(buffer));
		else if(splitConfig == null)
			return (editPane = createEditPane(jEdit.getFirstBuffer()));

		Stack stack = new Stack();

		StringTokenizer st = new StringTokenizer(splitConfig,""\t"");

		while(st.hasMoreTokens())
		{
			String token = st.nextToken();
			if(token.equals(""vertical""))
			{
				stack.push(splitPane = new JSplitPane(
					JSplitPane.VERTICAL_SPLIT,
					(Component)stack.pop(),
					(Component)stack.pop()));
				splitPane.setBorder(null);
				splitPane.setDividerLocation(0.5);
			}
			else if(token.equals(""horizontal""))
			{
				stack.push(splitPane = new JSplitPane(
					JSplitPane.HORIZONTAL_SPLIT,
					(Component)stack.pop(),
					(Component)stack.pop()));
				splitPane.setBorder(null);
				splitPane.setDividerLocation(0.5);
			}
			else
			{
				buffer = jEdit.getBuffer(token);
				if(buffer == null)
					buffer = jEdit.getFirstBuffer();

				stack.push(editPane = createEditPane(buffer));
			}
		}

		return (Component)stack.peek();
	} 

	
	
	private void propertiesChanged()
	{
		loadToolBars();

		showFullPath = jEdit.getBooleanProperty(""view.showFullPath"");
		updateTitle();

		dockableWindowManager.propertiesChanged();
		status.propertiesChanged();

		removeToolBar(status);
		getContentPane().remove(status);

		if(jEdit.getBooleanProperty(""view.toolbar.alternateLayout""))
		{
			getContentPane().add(BorderLayout.NORTH,topToolBars);
			getContentPane().add(BorderLayout.SOUTH,bottomToolBars);
			if(!plainView && jEdit.getBooleanProperty(""view.status.visible""))
				addToolBar(BOTTOM_GROUP,STATUS_BAR_LAYER,status);
		}
		else
		{
			dockableWindowManager.add(DockableWindowManager.DockableLayout
				.TOP_TOOLBARS,topToolBars);
			dockableWindowManager.add(DockableWindowManager.DockableLayout
				.BOTTOM_TOOLBARS,bottomToolBars);
			if(!plainView && jEdit.getBooleanProperty(""view.status.visible""))
				getContentPane().add(BorderLayout.SOUTH,status);
		}

		getRootPane().revalidate();

		
	} 

	
	private void loadToolBars()
	{
		if(jEdit.getBooleanProperty(""view.showToolbar"") && !plainView)
		{
			if(toolBar != null)
				toolBarManager.removeToolBar(toolBar);

			toolBar = GUIUtilities.loadToolBar(""view.toolbar"");

			addToolBar(TOP_GROUP, SYSTEM_BAR_LAYER, toolBar);
		}
		else if(toolBar != null)
		{
			removeToolBar(toolBar);
			toolBar = null;
		}

		if(jEdit.getBooleanProperty(""view.showSearchbar"") && !plainView)
		{
			if(searchBar != null)
				removeToolBar(searchBar);

			addToolBar(TOP_GROUP,SEARCH_BAR_LAYER,
				new SearchBar(this,false));
		}
		else if(searchBar != null)
		{
			removeToolBar(searchBar);
			searchBar = null;
		}
	} 

	
	private EditPane createEditPane(Buffer buffer)
	{
		EditPane editPane = new EditPane(this,buffer);
		JEditTextArea textArea = editPane.getTextArea();
		textArea.addFocusListener(new FocusHandler());
		textArea.addCaretListener(new CaretHandler());
		textArea.addScrollListener(new ScrollHandler());
		EditBus.send(new EditPaneUpdate(editPane,EditPaneUpdate.CREATED));
		return editPane;
	} 

	
	private void setEditPane(EditPane editPane)
	{
		this.editPane = editPane;
		status.updateCaretStatus();
		status.updateBufferStatus();
		status.updateMiscStatus();

		EditBus.send(new ViewUpdate(this,ViewUpdate.EDIT_PANE_CHANGED));
	} 

	
	private void handleBufferUpdate(BufferUpdate msg)
	{
		Buffer buffer = msg.getBuffer();
		if(msg.getWhat() == BufferUpdate.DIRTY_CHANGED)
		{
			if(!buffer.isDirty())
			{
				
				
				EditPane[] editPanes = getEditPanes();
				for(int i = 0; i < editPanes.length; i++)
				{
					if(editPanes[i].getBuffer() == buffer)
					{
						updateTitle();
						break;
					}
				}
			}
		}
	} 

	
	private void handleEditPaneUpdate(EditPaneUpdate msg)
	{
		EditPane editPane = msg.getEditPane();
		if(editPane.getView() == this
			&& msg.getWhat() == EditPaneUpdate.BUFFER_CHANGED
			&& editPane.getBuffer().isLoaded())
		{
			status.updateCaretStatus();
			status.updateBufferStatus();
			status.updateMiscStatus();
		}
	} 

	

	

	
	class CaretHandler implements CaretListener
	{
		public void caretUpdate(CaretEvent evt)
		{
			if(evt.getSource() == getTextArea())
				status.updateCaretStatus();
		}
	} 

	
	class FocusHandler extends FocusAdapter
	{
		public void focusGained(FocusEvent evt)
		{
			
			Component comp = (Component)evt.getSource();
			while(!(comp instanceof EditPane))
			{
				if(comp == null)
					return;

				comp = comp.getParent();
			}

			if(comp != editPane)
				setEditPane((EditPane)comp);
		}
	} 

	
	class ScrollHandler implements ScrollListener
	{
		public void scrolledVertically(JEditTextArea textArea)
		{
			if(getTextArea() == textArea)
				status.updateCaretStatus();
		}

		public void scrolledHorizontally(JEditTextArea textArea) {}
	} 

	
	class WindowHandler extends WindowAdapter
	{
		public void windowActivated(WindowEvent evt)
		{
			jEdit.setActiveView(View.this);

			final Vector buffers = new Vector();
			EditPane[] editPanes = getEditPanes();
			for(int i = 0; i < editPanes.length; i++)
			{
				Buffer buffer = ((EditPane)editPanes[i])
					.getBuffer();
				if(buffers.contains(buffer))
					continue;
				else
					buffers.addElement(buffer);
			}

			
			
			
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					for(int i = 0; i < buffers.size(); i++)
					{
						((Buffer)buffers.elementAt(i))
							.checkModTime(editPane);
					}
				}
			});
		}

		public void windowClosing(WindowEvent evt)
		{
			jEdit.closeView(View.this);
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.io.VFS,34,1,4,37,83,471,29,15,28,0.96969697,679,0.333333333,0,0.0,0.242424242,0,0,18.61764706,5,1.5588,1,"

package org.gjt.sp.jedit.io;


import gnu.regexp.*;
import java.awt.Color;
import java.awt.Component;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.buffer.BufferIORequest;
import org.gjt.sp.jedit.msg.PropertiesChanged;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public abstract class VFS
{
	

	
	public static final int READ_CAP = 1 << 0;

	
	public static final int WRITE_CAP = 1 << 1;

	
	public static final int BROWSE_CAP = 1 << 2;

	
	public static final int DELETE_CAP = 1 << 3;

	
	public static final int RENAME_CAP = 1 << 4;

	
	public static final int MKDIR_CAP = 1 << 5;

	
	public static final int LOW_LATENCY_CAP = 1 << 6;

	

	
	
	public VFS(String name)
	{
		this.name = name;
	} 

	
	
	public VFS(String name, int caps)
	{
		this.name = name;
		this.caps = caps;
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public int getCapabilities()
	{
		return caps;
	} 

	
	
	public String showBrowseDialog(Object[] session, Component comp)
	{
		return null;
	} 

	
	
	public String getFileName(String path)
	{
		if(path.equals(""/""))
			return path;

		int count = Math.max(0,path.length() - 2);
		int index = Math.max(path.lastIndexOf('/',count),
			path.lastIndexOf(File.separatorChar,count));
		if(index == -1)
			index = path.indexOf(':');

		
		if(index == -1 || index == path.length() - 1)
			return path;

		return path.substring(index + 1);
	} 

	
	
	public String getParentOfPath(String path)
	{
		
		
		int count = Math.max(0,path.length() - 2);
		int index = path.lastIndexOf(File.separatorChar,count);
		if(index == -1)
			index = path.lastIndexOf('/',count);
		if(index == -1)
		{
			
			
			index = path.lastIndexOf(':');
		}

		return path.substring(0,index + 1);
	} 

	
	
	public String constructPath(String parent, String path)
	{
		return parent + path;
	} 

	
	
	public char getFileSeparator()
	{
		return '/';
	} 

	
	
	public String getTwoStageSaveName(String path)
	{
		return MiscUtilities.constructPath(getParentOfPath(path),
			'#' + getFileName(path) + ""#save#"");
	} 

	
	
	public void reloadDirectory(String path) {} 

	
	
	public Object createVFSSession(String path, Component comp)
	{
		return new Object();
	} 

	
	
	public boolean load(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.load"",new String[] { name });
			return false;
		}

		Object session = createVFSSession(path,view);
		if(session == null)
			return false;

		if((getCapabilities() & WRITE_CAP) == 0)
			buffer.setReadOnly(true);

		BufferIORequest request = new BufferIORequest(
			BufferIORequest.LOAD,view,buffer,session,this,path);
		if(buffer.isTemporary())
			
			request.run();
		else
			VFSManager.runInWorkThread(request);

		return true;
	} 

	
	
	public boolean save(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & WRITE_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.save"",new String[] { name });
			return false;
		}

		Object session = createVFSSession(path,view);
		if(session == null)
			return false;

		
		if(!path.equals(buffer.getPath()))
			buffer.unsetProperty(Buffer.BACKED_UP);

		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.SAVE,view,buffer,session,this,path));
		return true;
	} 

	
	
	public boolean insert(View view, Buffer buffer, String path)
	{
		if((getCapabilities() & READ_CAP) == 0)
		{
			VFSManager.error(view,path,""vfs.not-supported.load"",new String[] { name });
			return false;
		}

		Object session = createVFSSession(path,view);
		if(session == null)
			return false;

		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.INSERT,view,buffer,session,this,path));
		return true;
	} 

	

	
	
	public String _canonPath(Object session, String path, Component comp)
		throws IOException
	{
		return path;
	} 

	
	
	public String[] _listDirectory(Object session, String directory,
		String glob, boolean recursive, Component comp)
		throws IOException
	{
		Log.log(Log.DEBUG,this,""Listing "" + directory);
		ArrayList files = new ArrayList(100);

		RE filter;
		try
		{
			filter = new RE(MiscUtilities.globToRE(glob),
				RE.REG_ICASE);
		}
		catch(REException e)
		{
			Log.log(Log.ERROR,this,e);
			return null;
		}

		_listDirectory(session,new ArrayList(),files,directory,filter,
			recursive,comp);

		String[] retVal = (String[])files.toArray(new String[files.size()]);

		Arrays.sort(retVal,new MiscUtilities.StringICaseCompare());

		return retVal;
	} 

	
	
	public DirectoryEntry[] _listDirectory(Object session, String directory,
		Component comp)
		throws IOException
	{
		VFSManager.error(comp,directory,""vfs.not-supported.list"",new String[] { name });
		return null;
	} 

	
	
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
		throws IOException
	{
		return null;
	} 

	
	
	public static class DirectoryEntry implements Serializable
	{
		
		public static final int FILE = 0;
		public static final int DIRECTORY = 1;
		public static final int FILESYSTEM = 2;
		

		
		public String name;
		public String path;
		public String deletePath;
		public int type;
		public long length;
		public boolean hidden;
		

		
		public DirectoryEntry(String name, String path, String deletePath,
			int type, long length, boolean hidden)
		{
			this.name = name;
			this.path = path;
			this.deletePath = deletePath;
			this.type = type;
			this.length = length;
			this.hidden = hidden;
		} 

		protected boolean colorCalculated;
		protected Color color;

		
		public Color getColor()
		{
			if(!colorCalculated)
			{
				colorCalculated = true;
				color = getDefaultColorFor(name);
			}

			return color;
		} 

		
		public String toString()
		{
			return name;
		} 
	} 

	
	
	public boolean _delete(Object session, String path, Component comp)
		throws IOException
	{
		return false;
	} 

	
	
	public boolean _rename(Object session, String from, String to,
		Component comp) throws IOException
	{
		return false;
	} 

	
	
	public boolean _mkdir(Object session, String directory, Component comp)
		throws IOException
	{
		return false;
	} 

	
	
	public void _backup(Object session, String path, Component comp)
		throws IOException
	{
	} 

	
	
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		VFSManager.error(comp,path,""vfs.not-supported.load"",new String[] { name });
		return null;
	} 

	
	
	public OutputStream _createOutputStream(Object session,
		String path, Component comp)
		throws IOException
	{
		VFSManager.error(comp,path,""vfs.not-supported.save"",new String[] { name });
		return null;
	} 

	
	
	public void _saveComplete(Object session, Buffer buffer, String path,
		Component comp) throws IOException {} 

	
	
	public void _endVFSSession(Object session, Component comp)
		throws IOException
	{
	} 

	
	
	public static Color getDefaultColorFor(String name)
	{
		synchronized(lock)
		{
			if(colors == null)
				loadColors();

			for(int i = 0; i < colors.size(); i++)
			{
				ColorEntry entry = (ColorEntry)colors.elementAt(i);
				if(entry.re.isMatch(name))
					return entry.color;
			}

			return null;
		}
	} 

	
	private String name;
	private int caps;
	private static Vector colors;
	private static Object lock = new Object();

	
	static
	{
		EditBus.addToBus(new EBComponent()
		{
			public void handleMessage(EBMessage msg)
			{
				if(msg instanceof PropertiesChanged)
				{
					synchronized(lock)
					{
						colors = null;
					}
				}
			}
		});
	} 

	
	private void _listDirectory(Object session, ArrayList stack,
		ArrayList files, String directory, RE glob, boolean recursive,
		Component comp) throws IOException
	{
		if(stack.contains(directory))
		{
			Log.log(Log.ERROR,this,
				""Recursion in _listDirectory(): ""
				+ directory);
			return;
		}
		else
			stack.add(directory);

		VFS.DirectoryEntry[] _files = _listDirectory(session,directory,
			comp);
		if(_files == null || _files.length == 0)
			return;

		for(int i = 0; i < _files.length; i++)
		{
			VFS.DirectoryEntry file = _files[i];

			if(file.type == VFS.DirectoryEntry.DIRECTORY
				|| file.type == VFS.DirectoryEntry.FILESYSTEM)
			{
				if(recursive)
				{
					
					String canonPath = _canonPath(session,file.path,comp);

					_listDirectory(session,stack,files,
						canonPath,glob,recursive,
						comp);
				}
			}
			else
			{
				if(!glob.isMatch(file.name))
					continue;

				Log.log(Log.DEBUG,this,file.path);

				files.add(file.path);
			}
		}
	} 

	
	private static void loadColors()
	{
		synchronized(lock)
		{
			colors = new Vector();

			if(!jEdit.getBooleanProperty(""vfs.browser.colorize""))
				return;

			String glob;
			int i = 0;
			while((glob = jEdit.getProperty(""vfs.browser.colors."" + i + "".glob"")) != null)
			{
				try
				{
					colors.addElement(new ColorEntry(
						new RE(MiscUtilities.globToRE(glob)),
						jEdit.getColorProperty(
						""vfs.browser.colors."" + i + "".color"",
						Color.black)));
					i++;
				}
				catch(REException e)
				{
					Log.log(Log.ERROR,VFS.class,""Invalid regular expression: ""
						+ glob);
					Log.log(Log.ERROR,VFS.class,e);
				}
			}
		}
	} 

	
	static class ColorEntry
	{
		RE re;
		Color color;

		ColorEntry(RE re, Color color)
		{
			this.re = re;
			this.color = color;
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.JEditMetalTheme,8,3,0,1,14,16,1,1,8,0.714285714,49,1.0,0,0.911392405,1.0,0,0,4.875,1,0.875,0,"

package org.gjt.sp.jedit.gui;

import javax.swing.plaf.metal.*;
import javax.swing.plaf.*;
import org.gjt.sp.jedit.jEdit;

public class JEditMetalTheme extends DefaultMetalTheme
{
	public String getName()
	{
		return ""jEdit"";
	}

	public ColorUIResource getSystemTextColor()
	{
		return getBlack();
	}

	public FontUIResource getControlTextFont()
	{
		return primaryFont;
	}

	public FontUIResource getSystemTextFont()
	{
		return secondaryFont;
	}

	public FontUIResource getUserTextFont()
	{
		return secondaryFont;
	}

	public FontUIResource getMenuTextFont()
	{
		return primaryFont;
	}

	public void propertiesChanged()
	{
		primaryFont = new FontUIResource(
			jEdit.getFontProperty(""metal.primary.font"",
			super.getControlTextFont()));
		secondaryFont = new FontUIResource(
			jEdit.getFontProperty(""metal.secondary.font"",
			super.getSystemTextFont()));
	}

	
	private FontUIResource primaryFont;
	private FontUIResource secondaryFont;
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.BufferChangeAdapter,5,1,0,2,6,10,0,2,5,2.0,12,0.0,0,0.0,0.8,0,0,1.4,1,0.8,2,"

package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.Buffer;


public abstract class BufferChangeAdapter implements BufferChangeListener
{
	
	
	public void foldLevelChanged(Buffer buffer, int start, int end)
	{
	} 

	
	
	public void contentInserted(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	
	public void contentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length) {}
	

	
	
	public void transactionComplete(Buffer buffer) {}
	
}
"
jEdit,4.1,org.gjt.sp.jedit.Buffer,147,1,0,127,346,9847,99,51,118,0.929969248,5007,0.714285714,12,0.0,0.077947846,0,0,32.72789116,39,3.7959,10,"

package org.gjt.sp.jedit;


import gnu.regexp.*;
import javax.swing.*;
import javax.swing.text.*;
import java.awt.Toolkit;
import java.io.File;
import java.util.*;
import org.gjt.sp.jedit.browser.VFSBrowser;
import org.gjt.sp.jedit.buffer.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.search.RESearchMatcher;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.*;



public class Buffer implements EBComponent
{
	
	
	public static final String LINESEP = ""lineSeparator"";

	
	public static final String BACKED_UP = ""Buffer__backedUp"";

	
	public static final String CARET = ""Buffer__caret"";
	public static final String SELECTION = ""Buffer__selection"";

	
	public static final String SCROLL_VERT = ""Buffer__scrollVert"";
	public static final String SCROLL_HORIZ = ""Buffer__scrollHoriz"";

	
	public static final String ENCODING = ""encoding"";

	
	public static final String TRAILING_EOL = ""trailingEOL"";

	
	public static final String GZIPPED = ""gzipped"";
	

	

	
	
	public void showInsertFileDialog(View view)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,null,
			VFSBrowser.OPEN_DIALOG,false);

		if(files != null)
			insertFile(view,files[0]);
	} 

	
	
	public void reload(View view)
	{
		if(getFlag(DIRTY))
		{
			String[] args = { name };
			int result = GUIUtilities.confirm(view,""changedreload"",
				args,JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}

		view.getEditPane().saveCaretInfo();
		load(view,true);
	} 

	
	
	public boolean load(final View view, final boolean reload)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}

		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);

		setFlag(LOADING,true);

		
		
		
		if(!getFlag(TEMPORARY))
			EditBus.send(new BufferUpdate(this,view,BufferUpdate.LOAD_STARTED));

		final boolean loadAutosave;

		if(reload || !getFlag(NEW_FILE))
		{
			if(file != null)
				modTime = file.lastModified();

			
			if(!reload && autosaveFile != null && autosaveFile.exists())
				loadAutosave = recoverAutosave(view);
			else
			{
				if(autosaveFile != null)
					autosaveFile.delete();
				loadAutosave = false;
			}

			if(!loadAutosave)
			{
				
				
				
				if(!vfs.load(view,this,path))
				{
					setFlag(LOADING,false);
					return false;
				}
			}
		}
		else
			loadAutosave = false;

		
		Runnable runnable = new Runnable()
		{
			public void run()
			{
				String newPath = getStringProperty(
					BufferIORequest.NEW_PATH);
				Segment seg = (Segment)getProperty(
					BufferIORequest.LOAD_DATA);
				IntegerArray endOffsets = (IntegerArray)
					getProperty(BufferIORequest.END_OFFSETS);

				
				
				boolean readOnly = isReadOnly();
				setFlag(READ_ONLY,false);

				
				remove(0,getLength());

				if(seg != null && endOffsets != null)
				{
					
					try
					{
						writeLock();

						
						
						
						contentMgr._setContent(seg.array,seg.count);

						contentInserted(0,seg.count,endOffsets);
					}
					catch(OutOfMemoryError oom)
					{
						Log.log(Log.ERROR,this,oom);
						VFSManager.error(view,path,""out-of-memory-error"",null);
					}
					finally
					{
						writeUnlock();
					}
				}

				setFlag(READ_ONLY,readOnly);

				unsetProperty(BufferIORequest.LOAD_DATA);
				unsetProperty(BufferIORequest.END_OFFSETS);
				unsetProperty(BufferIORequest.NEW_PATH);

				undoMgr.clear();
				undoMgr.setLimit(jEdit.getIntegerProperty(
					""buffer.undoCount"",100));

				if(!getFlag(TEMPORARY))
					finishLoading();

				
				fireContentInserted(0,0,getLineCount(),getLength() - 1);

				setFlag(LOADING,false);

				
				if(reload)
					setDirty(false);

				if(!loadAutosave && newPath != null && !path.equals(newPath))
					setPath(newPath);

				
				

				
				
				
				
				
				
				if(loadAutosave)
					setFlag(DIRTY,true);

				
				if(!getFlag(TEMPORARY))
				{
					EditBus.send(new BufferUpdate(Buffer.this,
						view,BufferUpdate.LOADED));
					
					
				}
			}
		}; 

		if(getFlag(TEMPORARY))
			runnable.run();
		else
			VFSManager.runInAWTThread(runnable);

		return true;
	} 

	
	
	public boolean insertFile(final View view, String path)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}

		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);

		path = MiscUtilities.constructPath(this.path,path);

		Buffer buffer = jEdit.getBuffer(path);
		if(buffer != null)
		{
			view.getTextArea().setSelectedText(
				buffer.getText(0,buffer.getLength()));
			return true;
		}

		VFS vfs = VFSManager.getVFSForPath(path);

		setFlag(IO,true);

		
		
		
		if(!vfs.insert(view,this,path))
		{
			setFlag(IO,false);
			return false;
		}

		
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				setFlag(IO,false);

				SegmentBuffer sbuf = (SegmentBuffer)getProperty(
					BufferIORequest.LOAD_DATA);
				if(sbuf != null)
				{
					unsetProperty(BufferIORequest.LOAD_DATA);

					view.getTextArea().setSelectedText(sbuf.toString());
				}
			}
		});

		return true;
	} 

	
	
	public void autosave()
	{
		if(autosaveFile == null || !getFlag(AUTOSAVE_DIRTY)
			|| !getFlag(DIRTY)
			|| getFlag(LOADING)
			|| getFlag(IO))
			return;

		setFlag(AUTOSAVE_DIRTY,false);

		VFSManager.runInWorkThread(new BufferIORequest(
			BufferIORequest.AUTOSAVE,null,this,null,
			VFSManager.getFileVFS(),autosaveFile.getPath()));
	} 

	
	
	public boolean saveAs(View view, boolean rename)
	{
		String[] files = GUIUtilities.showVFSFileDialog(view,path,
			VFSBrowser.SAVE_DIALOG,false);

		
		
		if(files == null)
			return false;

		return save(view,files[0],rename);
	} 

	
	
	public boolean save(View view, String path)
	{
		return save(view,path,true);
	} 

	
	
	public boolean save(final View view, String path, final boolean rename)
	{
		if(isPerformingIO())
		{
			GUIUtilities.error(view,""buffer-multiple-io"",null);
			return false;
		}

		setBooleanProperty(BufferIORequest.ERROR_OCCURRED,false);

		if(path == null && getFlag(NEW_FILE))
			return saveAs(view,rename);

		if(path == null && file != null)
		{
			long newModTime = file.lastModified();

			if(newModTime != modTime
				&& jEdit.getBooleanProperty(""view.checkModStatus""))
			{
				Object[] args = { this.path };
				int result = GUIUtilities.confirm(view,
					""filechanged-save"",args,
					JOptionPane.YES_NO_OPTION,
					JOptionPane.WARNING_MESSAGE);
				if(result != JOptionPane.YES_OPTION)
					return false;
			}
		}

		setFlag(IO,true);
		EditBus.send(new BufferUpdate(this,view,BufferUpdate.SAVING));

		final String oldPath = this.path;
		final String newPath = (path == null ? this.path : path);

		VFS vfs = VFSManager.getVFSForPath(newPath);

		if(!vfs.save(view,this,newPath))
		{
			setFlag(IO,false);
			return false;
		}

		
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				setFlag(IO,false);
				finishSaving(view,oldPath,newPath,rename,
					getBooleanProperty(BufferIORequest
					.ERROR_OCCURRED));
			}
		});

		return true;
	} 

	
	public static final int FILE_NOT_CHANGED = 0;
	public static final int FILE_CHANGED = 1;
	public static final int FILE_DELETED = 2;
	
	public int checkFileStatus()
	{
		
		
		
		
		if(!getFlag(IO) && !getFlag(LOADING) && file != null
			&& !getFlag(NEW_FILE))
		{
			boolean newReadOnly = (file.exists() && !file.canWrite());
			if(newReadOnly != getFlag(READ_ONLY))
			{
				setFlag(READ_ONLY,newReadOnly);
				EditBus.send(new BufferUpdate(this,null,
					BufferUpdate.DIRTY_CHANGED));
			}

			long oldModTime = modTime;
			long newModTime = file.lastModified();

			if(newModTime != oldModTime)
			{
				modTime = newModTime;

				if(!file.exists())
				{
					setFlag(NEW_FILE,true);
					EditBus.send(new BufferUpdate(this,null,
						BufferUpdate.DIRTY_CHANGED));
					return FILE_DELETED;
				}
				else
					return FILE_CHANGED;
			}
		}

		return FILE_NOT_CHANGED;
	} 

	
	
	public void checkModTime(EditPane editPane)
	{
		View view = editPane.getView();
		int status = checkFileStatus();

		
		
		if(!jEdit.getBooleanProperty(""view.checkModStatus""))
			return;

		if(status == FILE_DELETED)
		{
			Object[] args = { path };
			GUIUtilities.message(view,""filedeleted"",args);
		}
		else if(status == FILE_CHANGED)
		{
			String prop = (isDirty() ? ""filechanged-dirty""
				: ""filechanged-focus"");

			Object[] args = { path };
			int result = GUIUtilities.confirm(view,
				prop,args,JOptionPane.YES_NO_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result == JOptionPane.YES_OPTION)
			{
				editPane.saveCaretInfo();
				load(view,true);
			}
		}
	} 

	

	

	
	
	public long getLastModified()
	{
		return modTime;
	} 

	
	
	public void setLastModified(long modTime)
	{
		this.modTime = modTime;
	} 

	
	
	public VFS getVFS()
	{
		return vfs;
	} 

	
	
	public final File getAutosaveFile()
	{
		return autosaveFile;
	} 

	
	
	public final String getName()
	{
		return name;
	} 

	
	
	public final String getPath()
	{
		return path;
	} 

	
	
	public String getDirectory()
	{
		return directory;
	} 

	
	
	public final boolean isClosed()
	{
		return getFlag(CLOSED);
	} 

	
	
	public final boolean isLoaded()
	{
		return !getFlag(LOADING);
	} 

	
	
	public final boolean isPerformingIO()
	{
		return getFlag(LOADING) || getFlag(IO);
	} 

	
	
	public final boolean isNewFile()
	{
		return getFlag(NEW_FILE);
	} 

	
	
	public final void setNewFile(boolean newFile)
	{
		setFlag(NEW_FILE,newFile);
		if(!newFile)
			setFlag(UNTITLED,false);
	} 

	
	
	public final boolean isUntitled()
	{
		return getFlag(UNTITLED);
	} 

	
	
	public final boolean isDirty()
	{
		return getFlag(DIRTY);
	} 

	
	
	public final boolean isReadOnly()
	{
		return getFlag(READ_ONLY);
	} 

	
	
	public final boolean isEditable()
	{
		return !(getFlag(READ_ONLY) || getFlag(IO) || getFlag(LOADING));
	} 

	
	
	public final void setReadOnly(boolean readOnly)
	{
		setFlag(READ_ONLY,readOnly);
	} 

	
	
	public void setDirty(boolean d)
	{
		boolean old_d = getFlag(DIRTY);

		if(d)
		{
			if(getFlag(LOADING) || getFlag(READ_ONLY))
				return;
			if(getFlag(DIRTY) && getFlag(AUTOSAVE_DIRTY))
				return;
			setFlag(DIRTY,true);
			setFlag(AUTOSAVE_DIRTY,true);
		}
		else
		{
			setFlag(DIRTY,false);
			setFlag(AUTOSAVE_DIRTY,false);

			if(autosaveFile != null)
				autosaveFile.delete();

			
			
			undoMgr.bufferSaved();
		}

		if(d != old_d)
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.DIRTY_CHANGED));
		}
	} 

	
	
	public boolean isTemporary()
	{
		return getFlag(TEMPORARY);
	} 

	
	
	public Icon getIcon()
	{
		if(getFlag(DIRTY))
			return GUIUtilities.DIRTY_BUFFER_ICON;
		else if(getFlag(READ_ONLY))
			return GUIUtilities.READ_ONLY_BUFFER_ICON;
		else if(getFlag(NEW_FILE))
			return GUIUtilities.NEW_BUFFER_ICON;
		else
			return GUIUtilities.NORMAL_BUFFER_ICON;
	} 

	

	

	
	
	public final void readLock()
	{
		lock.readLock();
	} 

	
	
	public final void readUnlock()
	{
		lock.readUnlock();
	} 

	
	
	public final void writeLock()
	{
		lock.writeLock();
	} 

	
	
	public final void writeUnlock()
	{
		lock.writeUnlock();
	} 

	

	

	
	
	public int getLength()
	{
		
		return contentMgr.getLength();
	} 

	
	
	public int getLineCount()
	{
		
		return offsetMgr.getLineCount();
	} 

	
	
	public final int getLineOfOffset(int offset)
	{
		try
		{
			readLock();

			if(offset < 0 || offset > getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			return offsetMgr.getLineOfOffset(offset);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getLineStartOffset(int line)
	{
		try
		{
			readLock();

			if(line < 0 || line >= offsetMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);
			else if(line == 0)
				return 0;

			return offsetMgr.getLineEndOffset(line - 1);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getLineEndOffset(int line)
	{
		try
		{
			readLock();

			if(line < 0 || line >= offsetMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);

			return offsetMgr.getLineEndOffset(line);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getLineLength(int line)
	{
		try
		{
			readLock();

			return getLineEndOffset(line)
				- getLineStartOffset(line) - 1;
		}
		finally
		{
			readUnlock();
		}
	} 

	

	

	
	
	public String getLineText(int lineIndex)
	{
		try
		{
			readLock();

			return getText(getLineStartOffset(lineIndex),
				getLineLength(lineIndex));
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public void getLineText(int lineIndex, Segment segment)
	{
		try
		{
			readLock();

			getText(getLineStartOffset(lineIndex),
				getLineLength(lineIndex),segment);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public String getText(int start, int length)
	{
		try
		{
			readLock();

			if(start < 0 || length < 0
				|| start + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(start + "":"" + length);

			return contentMgr.getText(start,length);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public void getText(int start, int length, Segment seg)
	{
		try
		{
			readLock();

			if(start < 0 || length < 0
				|| start + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(start + "":"" + length);

			contentMgr.getText(start,length,seg);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public void insert(int offset, String str)
	{
		if(str == null)
			return;

		int len = str.length();

		if(len == 0)
			return;

		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");

		try
		{
			writeLock();

			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			contentMgr.insert(offset,str);

			integerArray.clear();

			for(int i = 0; i < len; i++)
			{
				if(str.charAt(i) == '\n')
					integerArray.add(i);
			}

			if(!getFlag(UNDO_IN_PROGRESS))
			{
				undoMgr.contentInserted(offset,len,str,
					!getFlag(DIRTY));
			}

			contentInserted(offset,len,integerArray);
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public void insert(int offset, Segment seg)
	{
		if(seg.count == 0)
			return;

		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");

		try
		{
			writeLock();

			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			contentMgr.insert(offset,seg);

			integerArray.clear();

			for(int i = 0; i < seg.count; i++)
			{
				if(seg.array[seg.offset + i] == '\n')
					integerArray.add(i);
			}

			if(!getFlag(UNDO_IN_PROGRESS))
			{
				undoMgr.contentInserted(offset,seg.count,
					seg.toString(),!getFlag(DIRTY));
			}

			contentInserted(offset,seg.count,integerArray);
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public void remove(int offset, int length)
	{
		if(length == 0)
			return;

		if(isReadOnly())
			throw new RuntimeException(""buffer read-only"");

		try
		{
			writeLock();

			if(offset < 0 || length < 0
				|| offset + length > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset + "":"" + length);

			int startLine = offsetMgr.getLineOfOffset(offset);

			contentMgr.getText(offset,length,seg);
			int numLines = 0;
			for(int i = 0; i < seg.count; i++)
			{
				if(seg.array[seg.offset + i] == '\n')
					numLines++;
			}

			if(!getFlag(UNDO_IN_PROGRESS))
			{
				undoMgr.contentRemoved(offset,length,
					seg.toString(),!getFlag(DIRTY));
			}

			contentMgr.remove(offset,length);

			offsetMgr.contentRemoved(startLine,offset,numLines,length);

			if(numLines > 0)
			{
				for(int i = 0; i < inUseFVMs.length; i++)
				{
					if(inUseFVMs[i] != null)
						inUseFVMs[i]._invalidate(startLine);
				}
			}

			fireContentRemoved(startLine,offset,numLines,length);

			setDirty(true);
		}
		finally
		{
			writeUnlock();
		}
	} 

	

	

	
	
	public void undo(JEditTextArea textArea)
	{
		if(undoMgr == null)
			return;

		if(!isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		try
		{
			writeLock();

			setFlag(UNDO_IN_PROGRESS,true);
			if(!undoMgr.undo(textArea))
				textArea.getToolkit().beep();

			fireTransactionComplete();
		}
		finally
		{
			setFlag(UNDO_IN_PROGRESS,false);

			writeUnlock();
		}
	} 

	
	
	public void redo(JEditTextArea textArea)
	{
		if(undoMgr == null)
			return;

		if(!isEditable())
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}

		try
		{
			writeLock();

			setFlag(UNDO_IN_PROGRESS,true);
			if(!undoMgr.redo(textArea))
				textArea.getToolkit().beep();

			fireTransactionComplete();
		}
		finally
		{
			setFlag(UNDO_IN_PROGRESS,false);

			writeUnlock();
		}
	} 

	
	
	public boolean isTransactionInProgress()
	{
		return getFlag(UNDO_IN_PROGRESS) || insideCompoundEdit();
	} 

	
	
	public void beginCompoundEdit()
	{
		
		
		

		try
		{
			writeLock();

			undoMgr.beginCompoundEdit();
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public void endCompoundEdit()
	{
		
		
		

		try
		{
			writeLock();

			undoMgr.endCompoundEdit();

			if(!insideCompoundEdit())
				fireTransactionComplete();
		}
		finally
		{
			writeUnlock();
		}
	}

	
	
	public boolean insideCompoundEdit()
	{
		return undoMgr.insideCompoundEdit();
	} 

	

	

	
	
	public void addBufferChangeListener(BufferChangeListener listener)
	{
		bufferListeners.addElement(listener);
	} 

	
	
	public void removeBufferChangeListener(BufferChangeListener listener)
	{
		bufferListeners.removeElement(listener);
	} 

	
	
	public BufferChangeListener[] getBufferChangeListeners()
	{
		return (BufferChangeListener[])bufferListeners
			.toArray(new BufferChangeListener[
			bufferListeners.size()]);
	} 

	

	

	
	
	public void propertiesChanged()
	{
		
		
		Iterator iter = properties.values().iterator();
		while(iter.hasNext())
		{
			PropValue value = (PropValue)iter.next();
			if(value.defaultValue)
				iter.remove();
		}

		textMode = ""text"".equals(mode.getName());

		setTokenMarker(mode.getTokenMarker());

		String folding = getStringProperty(""folding"");
		FoldHandler handler = FoldHandler.getFoldHandler(folding);

		if(handler != null)
		{
			setFoldHandler(handler);
		}
		else
		{
			if (folding != null)
				Log.log(Log.WARNING, this, path + "": invalid 'folding' property: "" + folding); 
			setFoldHandler(new DummyFoldHandler());
		}

		if(!isTemporary() && firstTimeDone)
			EditBus.send(new BufferUpdate(this,null,BufferUpdate.PROPERTIES_CHANGED));

		firstTimeDone = true;
	} 

	
	
	public int getTabSize()
	{
		return getIntegerProperty(""tabSize"",8);
	} 

	
	
	public final int getIndentSize()
	{
		return getIntegerProperty(""indentSize"",8);
	} 

	
	
	public synchronized Object getProperty(Object name)
	{
		
		PropValue o = (PropValue)properties.get(name);
		if(o != null)
			return o.value;

		
		if(!(name instanceof String))
			return null;

		
		if(mode != null)
		{
			Object retVal = mode.getProperty((String)name);
			if(retVal == null)
				return null;

			properties.put(name,new PropValue(retVal,true));
			return retVal;
		}
		else
		{
			
			String value = jEdit.getProperty(""buffer."" + name);
			if(value == null)
				return null;

			
			Object retVal;
			try
			{
				retVal = new Integer(value);
			}
			catch(NumberFormatException nf)
			{
				retVal = value;
			}
			properties.put(name,new PropValue(retVal,true));
			return retVal;
		}
	} 

	
	
	public void setProperty(String name, Object value)
	{
		if(value == null)
			properties.remove(name);
		else
		{
			PropValue test = (PropValue)properties.get(name);
			if(test == null)
				properties.put(name,new PropValue(value,false));
			else if(test.value.equals(value))
			{
				
			}
			else
			{
				test.value = value;
				test.defaultValue = false;
			}
		}
	} 

	
	
	public void unsetProperty(String name)
	{
		properties.remove(name);
	} 

	
	
	public String getStringProperty(String name)
	{
		Object obj = getProperty(name);
		if(obj != null)
			return obj.toString();
		else
			return null;
	} 

	
	
	public void setStringProperty(String name, String value)
	{
		setProperty(name,value);
	} 

	
	
	public boolean getBooleanProperty(String name)
	{
		Object obj = getProperty(name);
		if(obj instanceof Boolean)
			return ((Boolean)obj).booleanValue();
		else if(""true"".equals(obj) || ""on"".equals(obj) || ""yes"".equals(obj))
			return true;
		else
			return false;
	} 

	
	
	public void setBooleanProperty(String name, boolean value)
	{
		setProperty(name,value ? Boolean.TRUE : Boolean.FALSE);
	} 

	
	
	public int getIntegerProperty(String name, int defaultValue)
	{
		boolean defaultValueFlag;
		Object obj;
		PropValue value = (PropValue)properties.get(name);
		if(value != null)
		{
			obj = value.value;
			defaultValueFlag = value.defaultValue;
		}
		else
		{
			obj = getProperty(name);
			
			defaultValueFlag = true;
		}

		if(obj == null)
			return defaultValue;
		else if(obj instanceof Number)
			return ((Number)obj).intValue();
		else
		{
			try
			{
				int returnValue = Integer.parseInt(
					obj.toString().trim());
				properties.put(name,new PropValue(
					new Integer(returnValue),
					defaultValueFlag));
				return returnValue;
			}
			catch(Exception e)
			{
				return defaultValue;
			}
		}
	} 

	
	
	public void setIntegerProperty(String name, int value)
	{
		setProperty(name,new Integer(value));
	} 

	
	
	public synchronized RE getRegexpProperty(String name, int cflags,
		RESyntax syntax) throws REException
	{
		boolean defaultValueFlag;
		Object obj;
		PropValue value = (PropValue)properties.get(name);
		if(value != null)
		{
			obj = value.value;
			defaultValueFlag = value.defaultValue;
		}
		else
		{
			obj = getProperty(name);
			
			defaultValueFlag = true;
		}

		if(obj == null)
			return null;
		else if(obj instanceof RE)
			return (RE)obj;
		else
		{
			RE re = new RE(obj.toString(),cflags,syntax);
			properties.put(name,new PropValue(re,
				defaultValueFlag));
			return re;
		}
	} 

	
	
	public ParserRuleSet getRuleSetAtOffset(int offset)
	{
		int line = getLineOfOffset(offset);
		offset -= getLineStartOffset(line);
		if(offset != 0)
			offset--;

		DefaultTokenHandler tokens = new DefaultTokenHandler();
		markTokens(line,tokens);
		Token token = TextUtilities.getTokenAtOffset(tokens.getTokens(),offset);
		return token.rules;
	} 

	
	
	public KeywordMap getKeywordMapAtOffset(int offset)
	{
		return getRuleSetAtOffset(offset).getKeywords();
	} 

	
	
	public String getContextSensitiveProperty(int offset, String name)
	{
		ParserRuleSet rules = getRuleSetAtOffset(offset);

		Object value = null;

		Hashtable rulesetProps = rules.getProperties();
		if(rulesetProps != null)
			value = rulesetProps.get(name);

		if(value == null)
		{
			value = rules.getMode().getProperty(name);

			if(value == null)
				value = mode.getProperty(name);
		}

		if(value == null)
			return null;
		else
			return String.valueOf(value);
	} 

	
	static class PropValue
	{
		PropValue(Object value, boolean defaultValue)
		{
			if(value == null)
				throw new NullPointerException();
			this.value = value;
			this.defaultValue = defaultValue;
		}

		Object value;

		
		boolean defaultValue;

		
		public String toString()
		{
			return value.toString();
		}
	} 

	
	
	public void toggleWordWrap(View view)
	{
		String wrap = getStringProperty(""wrap"");
		if(wrap.equals(""none""))
			wrap = ""soft"";
		else if(wrap.equals(""soft""))
			wrap = ""hard"";
		else if(wrap.equals(""hard""))
			wrap = ""none"";
		view.getStatus().setMessageAndClear(jEdit.getProperty(
			""view.status.wrap-changed"",new String[] {
			wrap }));
		setProperty(""wrap"",wrap);
		propertiesChanged();
	} 

	
	
	public void toggleLineSeparator(View view)
	{
		String status = null;
		String lineSep = getStringProperty(""lineSeparator"");
		if(""\n"".equals(lineSep))
		{
			status = ""windows"";
			lineSep = ""\r\n"";
		}
		else if(""\r\n"".equals(lineSep))
		{
			status = ""mac"";
			lineSep = ""\r"";
		}
		else if(""\r"".equals(lineSep))
		{
			status = ""unix"";
			lineSep = ""\n"";
		}
		view.getStatus().setMessageAndClear(jEdit.getProperty(
			""view.status.linesep-changed"",new String[] {
			jEdit.getProperty(""lineSep."" + status) }));
		setProperty(""lineSeparator"",lineSep);
		setDirty(true);
		propertiesChanged();
	} 

	

	

	
	
	public final Mode getMode()
	{
		return mode;
	} 

	
	
	public void setMode(Mode mode)
	{
		
		if(mode == null)
			throw new NullPointerException(""Mode must be non-null"");

		this.mode = mode;

		propertiesChanged(); 
	} 

	
	
	public void setMode()
	{
		String userMode = getStringProperty(""mode"");
		if(userMode != null)
		{
			Mode m = jEdit.getMode(userMode);
			if(m != null)
			{
				setMode(m);
				return;
			}
		}

		String nogzName = name.substring(0,name.length() -
			(name.endsWith("".gz"") ? 3 : 0));
		Mode[] modes = jEdit.getModes();

		String firstLine = getLineText(0);

		for(int i = 0; i < modes.length; i++)
		{
			if(modes[i].accept(nogzName,firstLine))
			{
				setMode(modes[i]);
				return;
			}
		}

		Mode defaultMode = jEdit.getMode(jEdit.getProperty(""buffer.defaultMode""));
		if(defaultMode == null)
			defaultMode = jEdit.getMode(""text"");
		setMode(defaultMode);
	} 

	
	
	public void markTokens(int lineIndex, TokenHandler tokenHandler)
	{
		Segment seg;
		if(SwingUtilities.isEventDispatchThread())
			seg = this.seg;
		else
			seg = new Segment();

		try
		{
			writeLock();

			if(lineIndex < 0 || lineIndex >= offsetMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(lineIndex);

			
			int start;
			if(textMode)
			{
				start = lineIndex;
			}
			else
			{
				start = 0;

				for(int i = lineIndex - 1; i >= 0; i--)
				{
					if(offsetMgr.isLineContextValid(i))
					{
						start = i;
						break;
					}
				}
			}

			
			for(int i = start; i <= lineIndex; i++)
			{
				getLineText(i,seg);

				TokenMarker.LineContext context = offsetMgr.getLineContext(i);
				ParserRule oldRule;
				ParserRuleSet oldRules;
				if(context == null)
				{
					
					oldRule = null;
					oldRules = null;
				}
				else
				{
					oldRule = context.inRule;
					oldRules = context.rules;
				}

				
				
				
				
				TokenMarker.LineContext prevContext = (
					(i == 0 || !offsetMgr.isLineContextValid(i - 1))
					? null
					: offsetMgr.getLineContext(i - 1)
				);

				context = tokenMarker.markTokens(prevContext,
					(i == lineIndex ? tokenHandler
					: DummyTokenHandler.INSTANCE),seg);
				offsetMgr.setLineContext(i,context);

				
				
				
				if(oldRule != context.inRule)
				{
					
					nextLineRequested = true;
				}
				else if(oldRules != context.rules)
				{
					
					nextLineRequested = true;
				}
				
				
			}

			int lineCount = offsetMgr.getLineCount();
			if(nextLineRequested && lineCount - lineIndex > 1)
			{
				offsetMgr.lineInfoChangedFrom(lineIndex + 1);
			}
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public boolean isNextLineRequested()
	{
		boolean retVal = nextLineRequested;
		nextLineRequested = false;
		return retVal;
	} 

	
	
	public TokenMarker getTokenMarker()
	{
		return tokenMarker;
	} 

	

	

	
	
	public void removeTrailingWhiteSpace(int[] lines)
	{
		try
		{
			beginCompoundEdit();

			for(int i = 0; i < lines.length; i++)
			{
				int pos, lineStart, lineEnd, tail;

				getLineText(lines[i],seg);

				
				if (seg.count == 0) continue;

				lineStart = seg.offset;
				lineEnd = seg.offset + seg.count - 1;

				for (pos = lineEnd; pos >= lineStart; pos--)
				{
					if (!Character.isWhitespace(seg.array[pos]))
						break;
				}

				tail = lineEnd - pos;

				
				if (tail == 0) continue;

				remove(getLineEndOffset(lines[i]) - 1 - tail,tail);
			}
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public void shiftIndentLeft(int[] lines)
	{
		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		boolean noTabs = getBooleanProperty(""noTabs"");

		try
		{
			beginCompoundEdit();

			for(int i = 0; i < lines.length; i++)
			{
				int lineStart = getLineStartOffset(lines[i]);
				String line = getLineText(lines[i]);
				int whiteSpace = MiscUtilities
					.getLeadingWhiteSpace(line);
				if(whiteSpace == 0)
					continue;
				int whiteSpaceWidth = Math.max(0,MiscUtilities
					.getLeadingWhiteSpaceWidth(line,tabSize)
					- indentSize);
	
				insert(lineStart + whiteSpace,MiscUtilities
					.createWhiteSpace(whiteSpaceWidth,
					(noTabs ? 0 : tabSize)));
				remove(lineStart,whiteSpace);
			}

		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public void shiftIndentRight(int[] lines)
	{
		try
		{
			beginCompoundEdit();

			int tabSize = getTabSize();
			int indentSize = getIndentSize();
			boolean noTabs = getBooleanProperty(""noTabs"");
			for(int i = 0; i < lines.length; i++)
			{
				int lineStart = getLineStartOffset(lines[i]);
				String line = getLineText(lines[i]);
				int whiteSpace = MiscUtilities
					.getLeadingWhiteSpace(line);

				
				
				

				int whiteSpaceWidth = MiscUtilities
					.getLeadingWhiteSpaceWidth(
					line,tabSize) + indentSize;
				insert(lineStart + whiteSpace,MiscUtilities
					.createWhiteSpace(whiteSpaceWidth,
					(noTabs ? 0 : tabSize)));
				remove(lineStart,whiteSpace);
			}
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public boolean indentLine(int lineIndex, boolean canIncreaseIndent,
		boolean canDecreaseIndent)
	{
		getLineText(lineIndex,seg);

		int tabSize = getTabSize();

		int whitespaceChars = 0;
		int currentIndent = 0;
loop:		for(int i = 0; i < seg.count; i++)
		{
			char c = seg.array[seg.offset + i];
			switch(c)
			{
			case ' ':
				currentIndent++;
				whitespaceChars++;
				break;
			case '\t':
				currentIndent += (tabSize - (currentIndent
					% tabSize));
				whitespaceChars++;
				break;
			default:
				break loop;
			}
		}

		int idealIndent = getIndentForLine(lineIndex);
		if(idealIndent == -1)
			return false;

		if(!canDecreaseIndent && idealIndent <= currentIndent)
			return false;

		if(!canIncreaseIndent && idealIndent >= currentIndent)
			return false;

		
		try
		{
			beginCompoundEdit();

			int start = getLineStartOffset(lineIndex);

			remove(start,whitespaceChars);
			insert(start,MiscUtilities.createWhiteSpace(
				idealIndent,(getBooleanProperty(""noTabs"")
				? 0 : tabSize)));
		}
		finally
		{
			endCompoundEdit();
		}

		return true;
	} 

	
	
	public void indentLines(int start, int end)
	{
		try
		{
			beginCompoundEdit();
			for(int i = start; i <= end; i++)
				indentLine(i,true,true);
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public void indentLines(int[] lines)
	{
		try
		{
			beginCompoundEdit();
			for(int i = 0; i < lines.length; i++)
				indentLine(lines[i],true,true);
		}
		finally
		{
			endCompoundEdit();
		}
	} 

	
	
	public int getIndentForLine(int lineIndex)
	{
		final String EXPLICIT_START = ""{{{"";
		final String EXPLICIT_END = ""}}}"";

		if(lineIndex == 0)
			return -1;

		
		String openBrackets = getStringProperty(""indentOpenBrackets"");
		if(openBrackets == null)
			openBrackets = """";

		String closeBrackets = getStringProperty(""indentCloseBrackets"");
		if(closeBrackets == null)
			closeBrackets = """";

		RE indentNextLineRE;
		try
		{
			indentNextLineRE = getRegexpProperty(""indentNextLine"",
				RE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);
		}
		catch(REException re)
		{
			indentNextLineRE = null;
			Log.log(Log.ERROR,this,""Invalid indentNextLine regexp"");
			Log.log(Log.ERROR,this,re);
		}

		RE indentNextLinesRE;
		try
		{
			indentNextLinesRE = getRegexpProperty(""indentNextLines"",
				RE.REG_ICASE,RESearchMatcher.RE_SYNTAX_JEDIT);
		}
		catch(REException re)
		{
			indentNextLinesRE = null;
			Log.log(Log.ERROR,this,""Invalid indentNextLines regexp"");
			Log.log(Log.ERROR,this,re);
		}

		boolean doubleBracketIndent = getBooleanProperty(""doubleBracketIndent"");
		boolean lineUpClosingBracket = getBooleanProperty(""lineUpClosingBracket"");

		int tabSize = getTabSize();
		int indentSize = getIndentSize();
		

		
		int prevLineIndex = getPriorNonEmptyLine(lineIndex);
		if(prevLineIndex == -1)
			return -1;

		String prevLine = getLineText(prevLineIndex);

		
		boolean prevLineStart = true; 
		int indent = 0; 
		int prevLineBrackets = 0; 
		int prevLineCloseBracketIndex = -1; 
		                                    
		                                    
		                                    
		                                    
		                                    
		                                    
		                                    

		for(int i = 0; i < prevLine.length(); i++)
		{
			char c = prevLine.charAt(i);
			switch(c)
			{
			case ' ':
				if(prevLineStart)
					indent++;
				break;
			case '\t':
				if(prevLineStart)
				{
					indent += (tabSize
						- (indent
						% tabSize));
				}
				break;
			default:
				prevLineStart = false;

				if(closeBrackets.indexOf(c) != -1)
				{
					if(prevLine.regionMatches(false,
						i,EXPLICIT_END,0,3))
						i += 2;
					else
					{
						prevLineBrackets--;
						if(prevLineBrackets < 0)
						{
							if(lineUpClosingBracket)
								prevLineBrackets = 0;
							prevLineCloseBracketIndex = i;
						}
					}
				}
				else if(openBrackets.indexOf(c) != -1)
				{
					if(prevLine.regionMatches(false,
						i,EXPLICIT_START,0,3))
						i += 2;
					else
						prevLineBrackets++;
				}

				break;
			}
		}

		String line = getLineText(lineIndex);
		

		
		
		int lineBrackets = 0; 
		int closeBracketIndex = -1; 
			
		for(int i = 0; i < line.length(); i++)
		{
			char c = line.charAt(i);
			if(closeBrackets.indexOf(c) != -1)
			{
				if(line.regionMatches(false,
					i,EXPLICIT_END,0,3))
					i += 2;
				else
				{
					closeBracketIndex = i;
					lineBrackets--;
				}
			}
			else if(openBrackets.indexOf(c) != -1)
			{
				if(line.regionMatches(false,
					i,EXPLICIT_START,0,3))
					i += 2;
				else if(lineBrackets >= 0)
					lineBrackets++;
			}
		} 

		
		if(prevLineBrackets > 0)
			indent += (indentSize * prevLineBrackets);

		if(lineUpClosingBracket)
		{
			if(lineBrackets < 0)
			{
				int offset = TextUtilities.findMatchingBracket(
					this,lineIndex,closeBracketIndex);
				if(offset != -1)
				{
					String closeLine = getLineText(getLineOfOffset(offset));
					indent = MiscUtilities.getLeadingWhiteSpaceWidth(
						closeLine,tabSize);
				}
				else
					return -1;
			}
		}
		else
		{
			if(prevLineBrackets < 0)
			{
				int offset = TextUtilities.findMatchingBracket(
					this,prevLineIndex,prevLineCloseBracketIndex);
				if(offset != -1)
				{
					String closeLine = getLineText(getLineOfOffset(offset));
					indent = MiscUtilities.getLeadingWhiteSpaceWidth(
						closeLine,tabSize);
				}
				else
					return -1;
			}
		}

		
		if(lineBrackets == 0 || (doubleBracketIndent && lineBrackets > 0))
		{
			
			
			if(indentNextLinesRE != null && indentNextLinesRE.isMatch(prevLine))
				indent += indentSize;
			else if(indentNextLineRE != null)
			{
				if(indentNextLineRE.isMatch(prevLine))
					indent += indentSize;

				
				
				
				
				else if(prevLineBrackets == 0)
				{
					
					
					
					
					
					
					int prevPrevLineIndex;
					
						prevPrevLineIndex = getPriorNonEmptyLine(prevLineIndex);

					while(prevPrevLineIndex != -1)
					{
						if(indentNextLineRE.isMatch(getLineText(prevPrevLineIndex)))
							indent -= indentSize;
						else
							break;

						prevPrevLineIndex = getPriorNonEmptyLine(prevPrevLineIndex);
					}
				}
			}
		} 

		return indent;
	} 

	
	
	public int getVirtualWidth(int line, int column)
	{
		try
		{
			readLock();

			int start = getLineStartOffset(line);
			getText(start,column,seg);

			return MiscUtilities.getVirtualWidth(seg,getTabSize());
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public int getOffsetOfVirtualColumn(int line, int column,
		int[] totalVirtualWidth)
	{
		try
		{
			readLock();

			getLineText(line,seg);

			return MiscUtilities.getOffsetOfVirtualColumn(seg,
				getTabSize(),column,totalVirtualWidth);
		}
		finally
		{
			readUnlock();
		}
	} 

	
	
	public void insertAtColumn(int line, int col, String str)
	{
		try
		{
			writeLock();

			int[] total = new int[1];
			int offset = getOffsetOfVirtualColumn(line,col,total);
			if(offset == -1)
			{
				offset = getLineEndOffset(line) - 1;
				str = MiscUtilities.createWhiteSpace(col - total[0],0) + str;
			}
			else
				offset += getLineStartOffset(line);

			insert(offset,str);
		}
		finally
		{
			writeUnlock();
		}
	} 

	

	

	
	
	public void putProperty(Object name, Object value)
	{
		
		if(!(name instanceof String))
			return;

		setProperty((String)name,value);
	} 

	
	
	public void putBooleanProperty(String name, boolean value)
	{
		setBooleanProperty(name,value);
	} 

	
	
	public static class TokenList extends DefaultTokenHandler
	{
		public Token getFirstToken()
		{
			return getTokens();
		}
	}

	
	public TokenList markTokens(int lineIndex)
	{
		TokenList list = new TokenList();
		markTokens(lineIndex,list);
		return list;
	} 

	
	
	public Element[] getRootElements()
	{
		return new Element[] { getDefaultRootElement() };
	} 

	
	
	public Element getParagraphElement(int offset)
	{
		return new LineElement(this,getLineOfOffset(offset));
	} 

	
	
	public Element getDefaultRootElement()
	{
		return new RootElement(this);
	} 

	
	
	public void insertString(int offset, String str, AttributeSet attr)
	{
		insert(offset,str);
	} 

	
	
	public final File getFile()
	{
		return file;
	} 

	

	

	
	
	public boolean isFoldStart(int line)
	{
		return (line != getLineCount() - 1
			&& getFoldLevel(line) < getFoldLevel(line + 1));
	} 

	
	
	public void invalidateCachedFoldLevels()
	{
		offsetMgr.lineInfoChangedFrom(0);
		for(int i = 0; i < inUseFVMs.length; i++)
		{
			if(inUseFVMs[i] != null)
				inUseFVMs[i]._invalidate(0);
		}

		fireFoldLevelChanged(0,getLineCount());
	} 

	
	
	public int getFoldLevel(int line)
	{
		try
		{
			writeLock();

			if(line < 0 || line >= offsetMgr.getLineCount())
				throw new ArrayIndexOutOfBoundsException(line);

			if(offsetMgr.isFoldLevelValid(line))
			{
				return offsetMgr.getFoldLevel(line);
			}
			else
			{
				
				

				int start = 0;
				for(int i = line - 1; i >= 0; i--)
				{
					if(offsetMgr.isFoldLevelValid(i))
					{
						start = i + 1;
						break;
					}
				}

				int newFoldLevel = 0;
				boolean changed = false;

				for(int i = start; i <= line; i++)
				{
					newFoldLevel = foldHandler.getFoldLevel(this,i,seg);
					if(newFoldLevel != offsetMgr.getFoldLevel(i))
						changed = true;
					offsetMgr.setFoldLevel(i,newFoldLevel);
				}

				if(changed && !getFlag(INSIDE_INSERT))
				{
					
					fireFoldLevelChanged(start,line);
				}

				return newFoldLevel;
			}
		}
		finally
		{
			writeUnlock();
		}
	} 

	
	
	public int[] getFoldAtLine(int line)
	{
		int start, end;

		if(isFoldStart(line))
		{
			start = line;
			int foldLevel = getFoldLevel(line);

			line++;

			while(getFoldLevel(line) > foldLevel)
			{
				line++;

				if(line == getLineCount())
					break;
			}

			end = line - 1;
		}
		else
		{
			start = line;
			int foldLevel = getFoldLevel(line);
			while(getFoldLevel(start) >= foldLevel)
			{
				if(start == 0)
					break;
				else
					start--;
			}

			end = line;
			while(getFoldLevel(end) >= foldLevel)
			{
				end++;

				if(end == getLineCount())
					break;
			}

			end--;
		}

		while(getLineLength(end) == 0 && end > start)
			end--;

		return new int[] { start, end };
	} 

	

	

	
	
	public Position createPosition(int offset)
	{
		try
		{
			readLock();

			if(offset < 0 || offset > contentMgr.getLength())
				throw new ArrayIndexOutOfBoundsException(offset);

			return offsetMgr.createPosition(offset);
		}
		finally
		{
			readUnlock();
		}
	} 

	

	

	
	
	public final Vector getMarkers()
	{
		return markers;
	} 

	
	
	public void addOrRemoveMarker(char shortcut, int pos)
	{
		int line = getLineOfOffset(pos);
		if(getMarkerAtLine(line) != null)
			removeMarker(line);
		else
			addMarker(shortcut,pos);
	} 

	
	
	public void addMarker(char shortcut, int pos)
	{
		if(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(""persistentMarkers""))
			setDirty(true);

		Marker markerN = new Marker(this,shortcut,pos);
		boolean added = false;

		
		if(!getFlag(LOADING))
		{
			markerN.createPosition();

			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = (Marker)markers.elementAt(i);
				if(shortcut != '\0' && marker.getShortcut() == shortcut)
					marker.setShortcut('\0');

				if(marker.getPosition() == pos)
				{
					markers.removeElementAt(i);
					i--;
				}
			}

			for(int i = 0; i < markers.size(); i++)
			{
				Marker marker = (Marker)markers.elementAt(i);
				if(marker.getPosition() > pos)
				{
					markers.insertElementAt(markerN,i);
					added = true;
					break;
				}
			}
		}

		if(!added)
			markers.addElement(markerN);

		if(!getFlag(LOADING) && !getFlag(TEMPORARY))
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MARKERS_CHANGED));
		}
	} 

	
	
	public Marker getMarkerInRange(int start, int end)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			int pos = marker.getPosition();
			if(pos >= start && pos < end)
				return marker;
		}

		return null;
	} 

	
	
	public Marker getMarkerAtLine(int line)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			if(getLineOfOffset(marker.getPosition()) == line)
				return marker;
		}

		return null;
	} 

	
	
	public void removeMarker(int line)
	{
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			if(getLineOfOffset(marker.getPosition()) == line)
			{
				if(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(""persistentMarkers""))
					setDirty(true);

				marker.removePosition();
				markers.removeElementAt(i);
				i--;
			}
		}

		EditBus.send(new BufferUpdate(this,null,
			BufferUpdate.MARKERS_CHANGED));
	} 

	
	
	public void removeAllMarkers()
	{
		if(!getFlag(READ_ONLY) && jEdit.getBooleanProperty(""persistentMarkers""))
			setDirty(true);

		for(int i = 0; i < markers.size(); i++)
			((Marker)markers.elementAt(i)).removePosition();

		markers.removeAllElements();

		if(!getFlag(LOADING))
		{
			EditBus.send(new BufferUpdate(this,null,
				BufferUpdate.MARKERS_CHANGED));
		}
	} 

	
	
	public Marker getMarker(char shortcut)
	{
		Enumeration enum = markers.elements();
		while(enum.hasMoreElements())
		{
			Marker marker = (Marker)enum.nextElement();
			if(marker.getShortcut() == shortcut)
				return marker;
		}
		return null;
	} 

	

	

	
	
	public final Buffer getNext()
	{
		return next;
	} 

	
	
	public final Buffer getPrev()
	{
		return prev;
	} 

	
	
	public final int getIndex()
	{
		int count = 0;
		Buffer buffer = prev;
		for(;;)
		{
			if(buffer == null)
				break;
			count++;
			buffer = buffer.prev;
		}
		return count;
	} 

	
	
	public String toString()
	{
		return name + "" ("" + directory + "")"";
	} 

	
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof PropertiesChanged)
			propertiesChanged();
		else if(msg instanceof EditPaneUpdate)
		{
			EditPaneUpdate emsg = (EditPaneUpdate)msg;
			if(emsg.getWhat() == EditPaneUpdate.CREATED)
			{
				
			}
			else if(emsg.getWhat() == EditPaneUpdate.DESTROYED)
			{
				JEditTextArea textArea = emsg.getEditPane()
					.getTextArea();
				FoldVisibilityManager mgr = textArea
					.getFoldVisibilityManager();

				for(int i = 0; i < inUseFVMs.length; i++)
				{
					if(mgr == inUseFVMs[i])
					{
						mgr._release();
						inUseFVMs[i] = null;
						break;
					}
				}
			}
		}
	} 

	

	

	
	
	public FoldVisibilityManager _getFoldVisibilityManager(
		JEditTextArea textArea)
	{
		
		

		FoldVisibilityManager mgr = new FoldVisibilityManager(this,
			offsetMgr,textArea);

		
		for(int i = 0; i < inUseFVMs.length; i++)
		{
			if(inUseFVMs[i] == null)
			{
				inUseFVMs[i] = mgr;
				mgr._grab(i);
				return mgr;
			}
		}

		
		throw new InternalError(""Too many text areas editing this buffer"");
	} 

	
	
	public void _releaseFoldVisibilityManager(FoldVisibilityManager mgr)
	{
		inUseFVMs[mgr._getIndex()] = null;
		mgr._release();
	} 

	

	
	Buffer prev;
	Buffer next;

	
	Buffer(String path, boolean newFile, boolean temp, Hashtable props)
	{
		properties = new Hashtable();

		
		Enumeration enum = props.keys();
		while(enum.hasMoreElements())
		{
			Object key = enum.nextElement();
			Object value = props.get(key);

			properties.put(key,new PropValue(value,false));
		} 

		
		
		if(getProperty(ENCODING) == null)
			properties.put(ENCODING,new PropValue(System.getProperty(""file.encoding""),false));
		if(getProperty(LINESEP) == null)
			properties.put(LINESEP,new PropValue(System.getProperty(""line.separator""),false));

		lock = new ReadWriteLock();
		contentMgr = new ContentManager();
		offsetMgr = new OffsetManager(this);
		integerArray = new IntegerArray();
		undoMgr = new UndoManager(this);
		bufferListeners = new Vector();

		seg = new Segment();

		inUseFVMs = new FoldVisibilityManager[8];

		setFlag(TEMPORARY,temp);

		markers = new Vector();

		
		setPath(path);

		Mode defaultMode = jEdit.getMode(jEdit.getProperty(""buffer.defaultMode""));
		if(defaultMode == null)
			defaultMode = jEdit.getMode(""text"");
		setMode(defaultMode);

		
		setFlag(UNTITLED,newFile);
		setFlag(NEW_FILE,newFile);

		if(!temp)
			EditBus.addToBus(Buffer.this);
	} 

	
	void commitTemporary()
	{
		setFlag(TEMPORARY,false);
		EditBus.addToBus(this);

		finishLoading();
	} 

	
	void close()
	{
		setFlag(CLOSED,true);

		if(autosaveFile != null)
			autosaveFile.delete();

		EditBus.removeFromBus(this);
	} 

	

	

	

	
	private void setFlag(int flag, boolean value)
	{
		if(value)
			flags |= (1 << flag);
		else
			flags &= ~(1 << flag);
	} 

	
	private boolean getFlag(int flag)
	{
		int mask = (1 << flag);
		return (flags & mask) == mask;
	} 

	
	private static final int CLOSED = 0;
	private static final int LOADING = 1;
	private static final int IO = 2;
	private static final int NEW_FILE = 3;
	private static final int UNTITLED = 4;
	private static final int AUTOSAVE_DIRTY = 5;
	private static final int DIRTY = 6;
	private static final int READ_ONLY = 7;
	private static final int UNDO_IN_PROGRESS = 8;
	private static final int TEMPORARY = 9;
	private static final int INSIDE_INSERT = 10;
	

	private int flags;

	

	
	private VFS vfs;
	private String path;
	private String name;
	private String directory;
	private File file;
	private File autosaveFile;
	private long modTime;
	private Mode mode;
	private Hashtable properties;

	private ReadWriteLock lock;
	private ContentManager contentMgr;
	private OffsetManager offsetMgr;
	private IntegerArray integerArray;
	private UndoManager undoMgr;
	private Vector bufferListeners;

	private Vector markers;

	
	private boolean textMode;
	private TokenMarker tokenMarker;
	private Segment seg;
	private boolean nextLineRequested;

	
	private FoldHandler foldHandler;
	private FoldVisibilityManager[] inUseFVMs;

	
	private boolean firstTimeDone;
	

	
	private void setPath(String path)
	{
		this.path = path;
		this.vfs = VFSManager.getVFSForPath(path);
		if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)
			setReadOnly(true);
		this.name = vfs.getFileName(path);
		this.directory = vfs.getParentOfPath(path);

		if(vfs instanceof FileVFS)
		{
			file = new File(path);

			
			
			if(autosaveFile != null)
				autosaveFile.delete();
			autosaveFile = new File(file.getParent(),'#' + name + '#');
		}
	} 

	
	private boolean recoverAutosave(final View view)
	{
		if(!autosaveFile.canRead())
			return false;

		
		GUIUtilities.hideSplashScreen();

		final Object[] args = { autosaveFile.getPath() };
		int result = GUIUtilities.confirm(view,""autosave-found"",args,
			JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);

		if(result == JOptionPane.YES_OPTION)
		{
			vfs.load(view,this,autosaveFile.getPath());

			
			
			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					GUIUtilities.message(view,""autosave-loaded"",args);
				}
			});

			return true;
		}
		else
			return false;
	} 

	
	private void finishLoading()
	{
		parseBufferLocalProperties();
		
		
		FoldHandler oldFoldHandler = foldHandler;
		setMode();

		if(foldHandler == oldFoldHandler)
		{
			
			
			
			offsetMgr.lineInfoChangedFrom(0);

			int collapseFolds = getIntegerProperty(""collapseFolds"",0);
			offsetMgr.expandFolds(collapseFolds);
		}
	} 

	
	private void finishSaving(View view, String oldPath, String path,
		boolean rename, boolean error)
	{
		
		
		
		if(!error && !path.equals(oldPath))
		{
			Buffer buffer = jEdit.getBuffer(path);

			if(rename)
			{
				
				if(buffer != null && 
					!buffer.getPath().equals(oldPath))
				{
					buffer.setDirty(false);
					jEdit.closeBuffer(view,buffer);
				}

				setPath(path);
			}
			else
			{
				
				if(buffer != null && 
					!buffer.getPath().equals(oldPath))
				{
					buffer.load(view,true);
				}
			}
		} 

		
		if(rename)
		{
			if(file != null)
				modTime = file.lastModified();

			if(!error)
			{
				
				
				
				
				
				try
				{
					writeLock();

					if(autosaveFile != null)
						autosaveFile.delete();

					setFlag(AUTOSAVE_DIRTY,false);
					setFlag(READ_ONLY,false);
					setFlag(NEW_FILE,false);
					setFlag(UNTITLED,false);
					setFlag(DIRTY,false);

					
					
					
					undoMgr.bufferSaved();
				}
				finally
				{
					writeUnlock();
				}

				parseBufferLocalProperties();

				if(!getPath().equals(oldPath))
				{
					jEdit.updatePosition(Buffer.this);
					setMode();
				}
				else
					propertiesChanged();

				EditBus.send(new BufferUpdate(Buffer.this,
					view,BufferUpdate.DIRTY_CHANGED));

				
				EditBus.send(new BufferUpdate(Buffer.this,
					view,BufferUpdate.SAVED));
			}
		} 
	} 

	
	private void parseBufferLocalProperties()
	{
		
		if(getProperty(""tabSize"")
			.equals(mode.getProperty(""tabSize"")))
			unsetProperty(""tabSize"");

		if(getProperty(""indentSize"")
			.equals(mode.getProperty(""indentSize"")))
			unsetProperty(""indentSize"");

		if(getProperty(""maxLineLen"")
			.equals(mode.getProperty(""maxLineLen"")))
			unsetProperty(""maxLineLen"");
		

		int lastLine = Math.min(9,getLineCount() - 1);
		parseBufferLocalProperties(getText(0,getLineEndOffset(lastLine) - 1));

		
		
		int firstLine = Math.max(lastLine + 1, getLineCount() - 10);
		if(firstLine < getLineCount())
		{
			int length = getLineEndOffset(getLineCount() - 1) 
				- (getLineStartOffset(firstLine) + 1);
			parseBufferLocalProperties(getText(getLineStartOffset(firstLine),length));
		}

		

		
		for(int i = 0; i < markers.size(); i++)
		{
			Marker marker = (Marker)markers.elementAt(i);
			int pos = marker.getPosition();
			if(pos > getLength())
				marker.setPosition(getLength());
			marker.removePosition();
			marker.createPosition();
		}
	} 

	
	private void parseBufferLocalProperties(String prop)
	{
		StringBuffer buf = new StringBuffer();
		String name = null;
		boolean escape = false;
		for(int i = 0; i < prop.length(); i++)
		{
			char c = prop.charAt(i);
			switch(c)
			{
			case ':':
				if(escape)
				{
					escape = false;
					buf.append(':');
					break;
				}
				if(name != null)
				{
					String value = buf.toString();
					try
					{
						setProperty(name,new Integer(value));
					}
					catch(NumberFormatException nf)
					{
						setProperty(name,value);
					}
					name = null;
				}
				buf.setLength(0);
				break;
			case '=':
				if(escape)
				{
					escape = false;
					buf.append('=');
					break;
				}
				name = buf.toString();
				buf.setLength(0);
				break;
			case '\\':
				if(escape)
					buf.append('\\');
				escape = !escape;
				break;
			case 'n':
				if(escape)
				{	buf.append('\n');
					escape = false;
					break;
				}
			case 'r':
				if(escape)
				{	buf.append('\r');
					escape = false;
					break;
				}
			case 't':
				if(escape)
				{
					buf.append('\t');
					escape = false;
					break;
				}
			default:
				buf.append(c);
				break;
			}
		}
	} 

	
	private void setTokenMarker(TokenMarker tokenMarker)
	{
		TokenMarker oldTokenMarker = this.tokenMarker;

		this.tokenMarker = tokenMarker;

		
		if(oldTokenMarker != null && tokenMarker != oldTokenMarker)
		{
			offsetMgr.lineInfoChangedFrom(0);
		}
	} 

	
	private void setFoldHandler(FoldHandler foldHandler)
	{
		FoldHandler oldFoldHandler = this.foldHandler;

		if(foldHandler.equals(oldFoldHandler))
			return;

		this.foldHandler = foldHandler;

		
		if(oldFoldHandler != null)
		{
			offsetMgr.lineInfoChangedFrom(0);

			int collapseFolds = getIntegerProperty(""collapseFolds"",0);
			offsetMgr.expandFolds(collapseFolds);
		}
	} 

	
	
	private int getPriorNonEmptyLine(int lineIndex)
	{
		for(int i = lineIndex - 1; i >= 0; i--)
		{
			if(getLineLength(i) != 0)
				return i;
		}

		return -1;
	} 

	
	private void contentInserted(int offset, int length,
		IntegerArray endOffsets)
	{
		try
		{
			setFlag(INSIDE_INSERT,true);

			int startLine = offsetMgr.getLineOfOffset(offset);
			int numLines = endOffsets.getSize();

			offsetMgr.contentInserted(startLine,offset,numLines,length,
				endOffsets);

			if(numLines > 0)
			{
				
				for(int i = 0; i < inUseFVMs.length; i++)
				{
					if(inUseFVMs[i] != null)
						inUseFVMs[i]._invalidate(startLine);
				}
			}

			setDirty(true);

			if(!getFlag(LOADING))
				fireContentInserted(startLine,offset,numLines,length);
		}
		finally
		{
			setFlag(INSIDE_INSERT,false);
		}
	} 

	

	
	private void fireFoldLevelChanged(int start, int end)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				((BufferChangeListener)bufferListeners.elementAt(i))
					.foldLevelChanged(this,start,end);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event:"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	private void fireContentInserted(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				((BufferChangeListener)bufferListeners.elementAt(i))
					.contentInserted(this,startLine,offset,
					numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event:"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	private void fireContentRemoved(int startLine, int offset,
		int numLines, int length)
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				((BufferChangeListener)bufferListeners.elementAt(i))
					.contentRemoved(this,startLine,offset,
					numLines,length);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event:"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	
	private void fireTransactionComplete()
	{
		for(int i = 0; i < bufferListeners.size(); i++)
		{
			try
			{
				((BufferChangeListener)bufferListeners.elementAt(i))
					.transactionComplete(this);
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,""Exception while sending buffer event:"");
				Log.log(Log.ERROR,this,t);
			}
		}
	} 

	

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.BufferOptions,12,7,0,10,72,32,2,9,3,0.872727273,720,1.0,3,0.983508246,0.291666667,1,1,57.75,8,1.5,2,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.buffer.FoldHandler;
import org.gjt.sp.jedit.*;



public class BufferOptions extends EnhancedDialog
{
	
	public BufferOptions(View view, Buffer buffer)
	{
		super(view,jEdit.getProperty(""buffer-options.title""),true);
		this.view = view;
		this.buffer = buffer;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		ActionHandler actionListener = new ActionHandler();
		AbstractOptionPane panel = new AbstractOptionPane(null);

		panel.addComponent(GUIUtilities.createMultilineLabel(
			jEdit.getProperty(""buffer-options.caption"")));

		panel.addSeparator(""buffer-options.loading-saving"");

		
		String[] lineSeps = { jEdit.getProperty(""lineSep.unix""),
			jEdit.getProperty(""lineSep.windows""),
			jEdit.getProperty(""lineSep.mac"") };
		lineSeparator = new JComboBox(lineSeps);
		String lineSep = buffer.getStringProperty(Buffer.LINESEP);
		if(lineSep == null)
			lineSep = System.getProperty(""line.separator"");
		if(""\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(0);
		else if(""\r\n"".equals(lineSep))
			lineSeparator.setSelectedIndex(1);
		else if(""\r"".equals(lineSep))
			lineSeparator.setSelectedIndex(2);
		panel.addComponent(jEdit.getProperty(""buffer-options.lineSeparator""),
			lineSeparator);
		

		
		DefaultComboBoxModel encodings = new DefaultComboBoxModel();
		StringTokenizer st = new StringTokenizer(jEdit.getProperty(""encodings""));
		while(st.hasMoreTokens())
		{
			encodings.addElement(st.nextToken());
		}

		encoding = new JComboBox(encodings);
		encoding.setEditable(true);
		encoding.setSelectedItem(buffer.getStringProperty(Buffer.ENCODING));
		panel.addComponent(jEdit.getProperty(""buffer-options.encoding""),
			encoding);
		

		
		gzipped = new JCheckBox(jEdit.getProperty(
			""buffer-options.gzipped""));
		gzipped.setSelected(buffer.getBooleanProperty(Buffer.GZIPPED));
		panel.addComponent(gzipped);
		

		panel.addSeparator(""buffer-options.editing"");

		
		modes = jEdit.getModes();
		String bufferMode = buffer.getMode().getName();
		int index = 0;
		String[] modeNames = new String[modes.length];
		for(int i = 0; i < modes.length; i++)
		{
			Mode mode = modes[i];
			modeNames[i] = mode.getName();
			if(bufferMode.equals(mode.getName()))
				index = i;
		}
		mode = new JComboBox(modeNames);
		mode.setSelectedIndex(index);
		mode.addActionListener(actionListener);
		panel.addComponent(jEdit.getProperty(""buffer-options.mode""),mode);
		

		
		String[] foldModes = FoldHandler.getFoldModes();

		folding = new JComboBox(foldModes);
		folding.setSelectedItem(buffer.getStringProperty(""folding""));
		panel.addComponent(jEdit.getProperty(""options.editing.folding""),
			folding);
		

		
		String[] wrapModes = {
			""none"",
			""soft"",
			""hard""
		};

		wrap = new JComboBox(wrapModes);
		wrap.setSelectedItem(buffer.getStringProperty(""wrap""));
		panel.addComponent(jEdit.getProperty(""options.editing.wrap""),
			wrap);
		

		
		String[] lineLengths = { ""0"", ""72"", ""76"", ""80"" };

		maxLineLen = new JComboBox(lineLengths);
		maxLineLen.setEditable(true);
		maxLineLen.setSelectedItem(buffer.getStringProperty(""maxLineLen""));
		panel.addComponent(jEdit.getProperty(""options.editing.maxLineLen""),
			maxLineLen);
		

		
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		tabSize = new JComboBox(tabSizes);
		tabSize.setEditable(true);
		tabSize.setSelectedItem(buffer.getStringProperty(""tabSize""));
		panel.addComponent(jEdit.getProperty(""options.editing.tabSize""),tabSize);
		

		
		indentSize = new JComboBox(tabSizes);
		indentSize.setEditable(true);
		indentSize.setSelectedItem(buffer.getStringProperty(""indentSize""));
		panel.addComponent(jEdit.getProperty(""options.editing.indentSize""),
			indentSize);
		

		
		noTabs = new JCheckBox(jEdit.getProperty(
			""options.editing.noTabs""));
		noTabs.setSelected(buffer.getBooleanProperty(""noTabs""));
		panel.addComponent(noTabs);
		

		content.add(BorderLayout.NORTH,panel);

		
		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionListener);
		getRootPane().setDefaultButton(ok);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionListener);
		buttons.add(cancel);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);
		

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		int index = lineSeparator.getSelectedIndex();
		String lineSep;
		if(index == 0)
			lineSep = ""\n"";
		else if(index == 1)
			lineSep = ""\r\n"";
		else if(index == 2)
			lineSep = ""\r"";
		else
			throw new InternalError();

		String oldLineSep = buffer.getStringProperty(Buffer.LINESEP);
		if(oldLineSep == null)
			oldLineSep = System.getProperty(""line.separator"");
		if(!oldLineSep.equals(lineSep))
		{
			buffer.setStringProperty(""lineSeparator"",lineSep);
			buffer.setDirty(true);
		}

		String encoding = (String)this.encoding.getSelectedItem();
		String oldEncoding = buffer.getStringProperty(Buffer.ENCODING);
		if(!oldEncoding.equals(encoding))
		{
			buffer.setStringProperty(Buffer.ENCODING,encoding);
			buffer.setDirty(true);
		}

		boolean gzippedValue = gzipped.isSelected();
		boolean oldGzipped = buffer.getBooleanProperty(
			Buffer.GZIPPED);
		if(gzippedValue != oldGzipped)
		{
			buffer.setBooleanProperty(Buffer.GZIPPED,gzippedValue);
			buffer.setDirty(true);
		}

		buffer.setStringProperty(""folding"",(String)folding.getSelectedItem());

		buffer.setStringProperty(""wrap"",(String)wrap.getSelectedItem());

		try
		{
			buffer.setProperty(""maxLineLen"",new Integer(
				maxLineLen.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}

		try
		{
			buffer.setProperty(""tabSize"",new Integer(
				tabSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}

		try
		{
			buffer.setProperty(""indentSize"",new Integer(
				indentSize.getSelectedItem().toString()));
		}
		catch(NumberFormatException nf)
		{
		}

		buffer.setBooleanProperty(""noTabs"",noTabs.isSelected());

		index = mode.getSelectedIndex();
		buffer.setMode(modes[index]);

		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

        

	
	private View view;
	private Buffer buffer;
	private Mode[] modes;
	private JComboBox mode;
	private JComboBox lineSeparator;
	private JComboBox encoding;
	private JCheckBox gzipped;
	private JComboBox folding;
	private JComboBox wrap;
	private JComboBox maxLineLen;
	private JComboBox tabSize;
	private JComboBox indentSize;
	private JCheckBox noTabs;
	private JButton ok;
	private JButton cancel;
	

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == mode)
			{
				Mode _mode = jEdit.getMode((String)
					mode.getSelectedItem());
				folding.setSelectedItem(_mode.getProperty(
					""folding""));
				wrap.setSelectedItem(_mode.getProperty(
					""wrap""));
				maxLineLen.setSelectedItem(_mode.getProperty(
					""maxLineLen""));
				tabSize.setSelectedItem(_mode.getProperty(
					""tabSize""));
				indentSize.setSelectedItem(_mode.getProperty(
					""indentSize""));
				noTabs.setSelected(_mode.getBooleanProperty(
					""noTabs""));
			}
		} 
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.options.BrowserOptionPane,3,6,0,3,17,1,1,2,3,0.5,263,1.0,0,0.997019374,1.0,2,4,84.0,5,2.0,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import org.gjt.sp.jedit.*;



public class BrowserOptionPane extends AbstractOptionPane
{
	
	public BrowserOptionPane()
	{
		super(""browser.general"");
	} 

	
	public void _init()
	{
		
		String[] dirs = {
			jEdit.getProperty(""options.browser.general.defaultPath.buffer""),
			jEdit.getProperty(""options.browser.general.defaultPath.home""),
			jEdit.getProperty(""options.browser.general.defaultPath.favorites""),
			jEdit.getProperty(""options.browser.general.defaultPath.last"")
		};

		defaultDirectory = new JComboBox(dirs);
		String defaultDir = jEdit.getProperty(""vfs.browser.defaultPath"");
		if(""buffer"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(0);
		else if(""home"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(1);
		else if(""favorites"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(2);
		else if(""last"".equals(defaultDir))
			defaultDirectory.setSelectedIndex(3);
		addComponent(jEdit.getProperty(""options.browser.general.defaultPath""),
			defaultDirectory);

		
		showToolbar = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showToolbar""));
		showToolbar.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showToolbar""));
		addComponent(showToolbar);

		
		showIcons = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showIcons""));
		showIcons.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showIcons""));
		addComponent(showIcons);

		
		showHiddenFiles = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.showHiddenFiles""));
		showHiddenFiles.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".showHiddenFiles""));
		addComponent(showHiddenFiles);

		
		sortIgnoreCase = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.sortIgnoreCase""));
		sortIgnoreCase.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortIgnoreCase""));
		addComponent(sortIgnoreCase);

		
		sortMixFilesAndDirs = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.sortMixFilesAndDirs""));
		sortMixFilesAndDirs.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".sortMixFilesAndDirs""));
		addComponent(sortMixFilesAndDirs);

		
		doubleClickClose = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.doubleClickClose""));
		doubleClickClose.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".doubleClickClose""));
		addComponent(doubleClickClose);

		
		splitHorizontally = new JCheckBox(jEdit.getProperty(""options.browser""
			+ "".general.splitHorizontally""));
		splitHorizontally.setSelected(jEdit.getBooleanProperty(""vfs.browser""
			+ "".splitHorizontally""));
		addComponent(splitHorizontally);
	} 

	
	public void _save()
	{
		String[] dirs = { ""buffer"", ""home"", ""favorites"", ""last"" };
		jEdit.setProperty(""vfs.browser.defaultPath"",dirs[defaultDirectory
			.getSelectedIndex()]);
		jEdit.setBooleanProperty(""vfs.browser.showToolbar"",
			showToolbar.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showIcons"",
			showIcons.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.showHiddenFiles"",
			showHiddenFiles.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortIgnoreCase"",
			sortIgnoreCase.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.sortMixFilesAndDirs"",
			sortMixFilesAndDirs.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.doubleClickClose"",
			doubleClickClose.isSelected());
		jEdit.setBooleanProperty(""vfs.browser.splitHorizontally"",
			splitHorizontally.isSelected());
	} 

	
	private JComboBox defaultDirectory;
	private JCheckBox showToolbar;
	private JCheckBox showIcons;
	private JCheckBox showHiddenFiles;
	private JCheckBox sortIgnoreCase;
	private JCheckBox sortMixFilesAndDirs;
	private JCheckBox doubleClickClose;
	private JCheckBox splitHorizontally;
	
} 
"
jEdit,4.1,org.gjt.sp.jedit.Registers,14,1,0,11,39,61,4,7,12,0.307692308,314,1.0,1,0.0,0.320512821,0,0,21.35714286,8,2.5,1,"

package org.gjt.sp.jedit;


import java.awt.datatransfer.*;
import java.awt.Toolkit;
import java.io.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class Registers
{
	
	
	public static void copy(JEditTextArea textArea, char register)
	{
		String selection = textArea.getSelectedText();
		if(selection == null)
			return;

		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);
	} 

	
	
	public static void cut(JEditTextArea textArea, char register)
	{
		if(textArea.isEditable())
		{
			String selection = textArea.getSelectedText();
			if(selection == null)
				return;

			setRegister(register,selection);
			HistoryModel.getModel(""clipboard"").addItem(selection);

			textArea.setSelectedText("""");
		}
		else
			textArea.getToolkit().beep();
	} 

	
	
	public static void append(JEditTextArea textArea, char register)
	{
		append(textArea,register,""\n"",false);
	} 

	
	
	public static void append(JEditTextArea textArea, char register,
		String separator)
	{
		append(textArea,register,separator,false);
	} 

	
	
	public static void append(JEditTextArea textArea, char register,
		String separator, boolean cut)
	{
		if(cut && !textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		String selection = textArea.getSelectedText();
		if(selection == null)
			return;

		Register reg = getRegister(register);

		if(reg != null)
		{
			String registerContents = reg.toString();
			if(registerContents != null)
			{
				if(registerContents.endsWith(separator))
					selection = registerContents + selection;
				else
					selection = registerContents + separator + selection;
			}
		}

		setRegister(register,selection);
		HistoryModel.getModel(""clipboard"").addItem(selection);

		if(cut)
			textArea.setSelectedText("""");
	} 

	
	
	public static void paste(JEditTextArea textArea, char register)
	{
		paste(textArea,register,false);
	} 

	
	
	public static void paste(JEditTextArea textArea, char register,
		boolean vertical)
	{
		if(!textArea.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		Register reg = getRegister(register);

		if(reg == null)
		{
			textArea.getToolkit().beep();
			return;
		}
		else
		{
			String selection = reg.toString();
			if(selection == null)
			{
				textArea.getToolkit().beep();
				return;
			}

			if(vertical && textArea.getSelectionCount() == 0)
			{
				int caret = textArea.getCaretPosition();
				int caretLine = textArea.getCaretLine();
				Selection.Rect rect = new Selection.Rect(
					caretLine,caret,caretLine,caret);
				textArea.setSelectedText(rect,selection);
			}
			else
				textArea.setSelectedText(selection);

			HistoryModel.getModel(""clipboard"").addItem(selection);
		}
	} 

	
	
	public static Register getRegister(char name)
	{
		if(registers == null || name >= registers.length)
			return null;
		else
			return registers[name];
	} 

	
	
	public static void setRegister(char name, Register newRegister)
	{
		if(name >= registers.length)
		{
			Register[] newRegisters = new Register[
				Math.min(1<<16,name * 2)];
			System.arraycopy(registers,0,newRegisters,0,
				registers.length);
			registers = newRegisters;
		}

		registers[name] = newRegister;
	} 

	
	
	public static void setRegister(char name, String value)
	{
		if(name >= registers.length)
		{
			Register[] newRegisters = new Register[
				Math.min(1<<16,name * 2)];
			System.arraycopy(registers,0,newRegisters,0,
				registers.length);
			registers = newRegisters;
			registers[name] = new StringRegister(value);
		}
		else
		{
			Register register = registers[name];

			if(register != null)
				register.setValue(value);
			else
				registers[name] = new StringRegister(value);
		}
	} 

	
	
	public static void clearRegister(char name)
	{
		if(name >= registers.length)
			return;

		Register register = registers[name];
		if(name == '$' || name == '%')
			register.setValue("""");
		else
			registers[name] = null;
	} 

	
	
	public static Register[] getRegisters()
	{
		return registers;
	} 

	
	
	public interface Register
	{
		
		String toString();

		
		void setValue(String value);
	} 

	
	
	public static class ClipboardRegister implements Register
	{
		Clipboard clipboard;

		public ClipboardRegister(Clipboard clipboard)
		{
			this.clipboard = clipboard;
		}

		
		public void setValue(String value)
		{
			StringSelection selection = new StringSelection(value);
			clipboard.setContents(selection,null);
		}

		
		public String toString()
		{
			try
			{
				String selection = (String)(clipboard
					.getContents(this).getTransferData(
					DataFlavor.stringFlavor));

				boolean trailingEOL = (selection.endsWith(""\n"")
					|| selection.endsWith(System.getProperty(
					""line.separator"")));

				
				
				
				BufferedReader in = new BufferedReader(
					new StringReader(selection));
				StringBuffer buf = new StringBuffer();
				String line;
				while((line = in.readLine()) != null)
				{
					buf.append(line);
					buf.append('\n');
				}
				
				if(!trailingEOL)
					buf.setLength(buf.length() - 1);
				return buf.toString();
			}
			catch(Exception e)
			{
				Log.log(Log.NOTICE,this,e);
				return null;
			}
		}
	} 

	
	
	public static class StringRegister implements Register
	{
		private String value;

		
		public StringRegister(String value)
		{
			this.value = value;
		}

		
		public void setValue(String value)
		{
			this.value = value;
		}

		
		public String toString()
		{
			return value;
		}

		
		public void dispose() {}
	} 

	
	private static Register[] registers;

	private Registers() {}

	static
	{
		registers = new Register[256];
		registers['$'] = new ClipboardRegister(Toolkit
			.getDefaultToolkit().getSystemClipboard());
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.search.DirectoryListSet,7,2,0,9,22,0,4,6,5,0.444444444,123,1.0,0,0.538461538,0.285714286,1,1,16.14285714,3,1.1429,0,"

package org.gjt.sp.jedit.search;


import javax.swing.SwingUtilities;
import java.awt.Component;
import java.io.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class DirectoryListSet extends BufferListSet
{
	
	public DirectoryListSet(String directory, String glob, boolean recurse)
	{
		this.directory = directory;
		this.glob = glob;
		this.recurse = recurse;
	} 

	
	public String getDirectory()
	{
		return directory;
	} 

	
	public String getFileFilter()
	{
		return glob;
	} 

	
	public boolean isRecursive()
	{
		return recurse;
	} 

	
	public String getCode()
	{
		return ""new DirectoryListSet(\"""" + MiscUtilities.charsToEscapes(directory)
			+ ""\"",\"""" + MiscUtilities.charsToEscapes(glob) + ""\"",""
			+ recurse + "")"";
	} 

	
	protected String[] _getFiles(final Component comp)
	{
		final VFS vfs = VFSManager.getVFSForPath(directory);
		Object session;
		if(SwingUtilities.isEventDispatchThread())
		{
			session = vfs.createVFSSession(directory,comp);
		}
		else
		{
			final Object[] returnValue = new Object[1];

			try
			{
				SwingUtilities.invokeAndWait(new Runnable()
				{
					public void run()
					{
						returnValue[0] = vfs.createVFSSession(directory,comp);
					}
				});
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}

			session = returnValue[0];
		}

		if(session == null)
			return null;

		try
		{
			return vfs._listDirectory(session,directory,glob,recurse,comp);
		}
		catch(IOException io)
		{
			VFSManager.error(comp,directory,""ioerror"",new String[]
				{ io.toString() });
			return null;
		}
	} 

	
	private String directory;
	private String glob;
	private boolean recurse;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.StatusBar,23,5,0,37,128,153,29,18,12,0.897306397,1181,0.888888889,3,0.967407407,0.173913043,1,7,49.17391304,18,2.913,3,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.text.Segment;
import javax.swing.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;



public class StatusBar extends JPanel implements WorkThreadProgressListener
{
	
	public StatusBar(View view)
	{
		super(new BorderLayout());
		setBorder(new CompoundBorder(new EmptyBorder(4,0,0,
			(OperatingSystem.isMacOS() ? 18 : 0)),
			UIManager.getBorder(""TextField.border"")));

		this.view = view;

		panel = new JPanel(new BorderLayout());
		box = new Box(BoxLayout.X_AXIS);
		panel.add(BorderLayout.EAST,box);
		add(BorderLayout.CENTER,panel);

		MouseHandler mouseHandler = new MouseHandler();

		caretStatus = new ToolTipLabel();
		caretStatus.setToolTipText(jEdit.getProperty(""view.status.caret-tooltip""));
		caretStatus.addMouseListener(mouseHandler);

		message = new JLabel("" "");
		setMessageComponent(message);

		mode = new ToolTipLabel();
		mode.setToolTipText(jEdit.getProperty(""view.status.mode-tooltip""));
		mode.addMouseListener(mouseHandler);

		wrap = new ToolTipLabel();
		wrap.setHorizontalAlignment(SwingConstants.CENTER);
		wrap.setToolTipText(jEdit.getProperty(""view.status.wrap-tooltip""));
		wrap.addMouseListener(mouseHandler);

		multiSelect = new ToolTipLabel();
		multiSelect.setHorizontalAlignment(SwingConstants.CENTER);
		multiSelect.setToolTipText(jEdit.getProperty(""view.status.multi-tooltip""));
		multiSelect.addMouseListener(mouseHandler);

		overwrite = new ToolTipLabel();
		overwrite.setHorizontalAlignment(SwingConstants.CENTER);
		overwrite.setToolTipText(jEdit.getProperty(""view.status.overwrite-tooltip""));
		overwrite.addMouseListener(mouseHandler);

		lineSep = new ToolTipLabel();
		lineSep.setHorizontalAlignment(SwingConstants.CENTER);
		lineSep.setToolTipText(jEdit.getProperty(""view.status.linesep-tooltip""));
		lineSep.addMouseListener(mouseHandler);

		memory = new MemoryStatus();
		memory.addMouseListener(mouseHandler);
	} 

	
	public void propertiesChanged()
	{
		showCaretStatus = jEdit.getBooleanProperty(""view.status.show-caret-status"");
		showEditMode = jEdit.getBooleanProperty(""view.status.show-edit-mode"");
		showFoldMode = jEdit.getBooleanProperty(""view.status.show-fold-mode"");
		showEncoding = jEdit.getBooleanProperty(""view.status.show-encoding"");
		showWrap = jEdit.getBooleanProperty(""view.status.show-wrap"");
		showMultiSelect = jEdit.getBooleanProperty(""view.status.show-multi-select"");
		showOverwrite = jEdit.getBooleanProperty(""view.status.show-overwrite"");
		showLineSeperator = jEdit.getBooleanProperty(""view.status.show-line-seperator"");
		showMemory = jEdit.getBooleanProperty(""view.status.show-memory"");

		TextAreaPainter painter = view.getTextArea().getPainter();
		panel.setBackground(painter.getBackground());
		panel.setForeground(painter.getForeground());
		caretStatus.setBackground(painter.getBackground());
		caretStatus.setForeground(painter.getForeground());
		message.setBackground(painter.getBackground());
		message.setForeground(painter.getForeground());
		mode.setBackground(painter.getBackground());
		mode.setForeground(painter.getForeground());
		wrap.setBackground(painter.getBackground());
		wrap.setForeground(painter.getForeground());
		multiSelect.setBackground(painter.getBackground());
		multiSelect.setForeground(painter.getForeground());
		overwrite.setBackground(painter.getBackground());
		overwrite.setForeground(painter.getForeground());
		lineSep.setBackground(painter.getBackground());
		lineSep.setForeground(painter.getForeground());
		memory.setBackground(painter.getBackground());
		memory.setForeground(painter.getForeground());

		Font font = UIManager.getFont(""Label.font"");
		FontMetrics fm = getFontMetrics(font);
		Dimension dim = null;

		if (showCaretStatus)
		{
			panel.add(BorderLayout.WEST,caretStatus);

			caretStatus.setFont(font);

			dim = new Dimension(fm.stringWidth(caretTestStr),
				fm.getHeight());
                        caretStatus.setPreferredSize(dim);
		}
		else
			panel.remove(caretStatus);

		box.removeAll();

		if (showEncoding || showEditMode || showFoldMode)
			box.add(mode);

		if (showWrap)
		{
			dim = new Dimension(Math.max(
				Math.max(fm.charWidth('-'),fm.charWidth('H')),
				fm.charWidth('S')) + 1,fm.getHeight());
			wrap.setPreferredSize(dim);
			wrap.setMaximumSize(dim);
			box.add(wrap);
		}

		if (showMultiSelect)
		{
			dim = new Dimension(
				Math.max(fm.charWidth('-'),fm.charWidth('M')) + 1,
				fm.getHeight());
			multiSelect.setPreferredSize(dim);
			multiSelect.setMaximumSize(dim);
			box.add(multiSelect);
		}

		if (showOverwrite)
		{
			dim = new Dimension(
				Math.max(fm.charWidth('-'),fm.charWidth('O')) + 1,
				fm.getHeight());
			overwrite.setPreferredSize(dim);
			overwrite.setMaximumSize(dim);
			box.add(overwrite);
		}

		if (showLineSeperator)
		{
			dim = new Dimension(Math.max(
				Math.max(fm.charWidth('U'),
				fm.charWidth('W')),
				fm.charWidth('M')) + 1,
				fm.getHeight());
			lineSep.setPreferredSize(dim);
			lineSep.setMaximumSize(dim);
			box.add(lineSep);
		}

		if (showMemory)
		{
			box.add(memory);

			
			

			memory.setFont(font);
			FontRenderContext frc = new FontRenderContext(null,false,false);
			Rectangle2D bounds = font.getStringBounds(memoryTestStr,frc);
			dim = new Dimension((int)bounds.getWidth(),
				(int)bounds.getHeight());
			memory.setPreferredSize(dim);
			memory.setMaximumSize(dim);
			memory.lm = font.getLineMetrics(memoryTestStr,frc);

			memory.progressForeground = jEdit.getColorProperty(
				""view.status.memory.foreground"");
			memory.progressBackground = jEdit.getColorProperty(
				""view.status.memory.background"");
		}

		updateBufferStatus();
		updateMiscStatus();
	} 

	
	public void addNotify()
	{
		super.addNotify();
		VFSManager.getIOThreadPool().addProgressListener(this);
	} 

	
	public void removeNotify()
	{
		super.removeNotify();
		VFSManager.getIOThreadPool().removeProgressListener(this);
	} 

	

	
	public void statusUpdate(final WorkThreadPool threadPool, int threadIndex)
	{
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				
				if(message != null && !"""".equals(message.getText().trim())
					&& !currentMessageIsIO)
					return;

				int requestCount = threadPool.getRequestCount();
				if(requestCount == 0)
				{
					setMessageAndClear(jEdit.getProperty(
						""view.status.io.done""));
					currentMessageIsIO = true;
				}
				else if(requestCount == 1)
				{
					setMessage(jEdit.getProperty(
						""view.status.io-1""));
					currentMessageIsIO = true;
				}
				else
				{
					Object[] args = { new Integer(requestCount) };
					setMessage(jEdit.getProperty(
						""view.status.io"",args));
					currentMessageIsIO = true;
				}
			}
		});
	} 

	
	public void progressUpdate(WorkThreadPool threadPool, int threadIndex)
	{
	} 

	

	
	
	public void setMessageAndClear(String message)
	{
		setMessage(message);

		tempTimer = new Timer(0,new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				
				if(isShowing())
					setMessage(null);
			}
		});

		tempTimer.setInitialDelay(10000);
		tempTimer.setRepeats(false);
		tempTimer.start();
	} 

	
	
	public void setMessage(String message)
	{
		if(tempTimer != null)
		{
			tempTimer.stop();
			tempTimer = null;
		}

		setMessageComponent(this.message);

		if(message == null)
		{
			InputHandler inputHandler = view.getInputHandler();
			if(inputHandler.isRepeatEnabled())
			{
				int repeatCount = inputHandler.getRepeatCount();

				this.message.setText(jEdit.getProperty(""view.status.repeat"",
					new Object[] { repeatCount == 1 ? """" : String.valueOf(repeatCount) }));
			}
			else if(view.getMacroRecorder() != null)
				this.message.setText(jEdit.getProperty(""view.status.recording""));
			else
				this.message.setText("" "");
		}
		else
			this.message.setText(message);
	} 

	
	public void setMessageComponent(Component comp)
	{
		currentMessageIsIO = false;

		if (comp == null || messageComp == comp)
		{
			return;
		}

		messageComp = comp;
		panel.add(BorderLayout.CENTER, messageComp);
	} 

	
	public void updateCaretStatus()
	{
		
		

		if (showCaretStatus)
		{
			Buffer buffer = view.getBuffer();

			if(!buffer.isLoaded() ||
				
				buffer != view.getTextArea().getBuffer())
			{
				caretStatus.setText("" "");
				return;
			}

			JEditTextArea textArea = view.getTextArea();

			int currLine = textArea.getCaretLine();

			
			
			
			
			
			if(currLine >= buffer.getLineCount())
				return; 

			int start = textArea.getLineStartOffset(currLine);
			int dot = textArea.getCaretPosition() - start;
			buffer.getText(start,dot,seg);
			int virtualPosition = MiscUtilities.getVirtualWidth(seg,
				buffer.getTabSize());

			buf.setLength(0);
			buf.append(Integer.toString(currLine + 1));
			buf.append(',');
			buf.append(Integer.toString(dot + 1));

			if (virtualPosition != dot)
			{
				buf.append('-');
				buf.append(Integer.toString(virtualPosition + 1));
			}

			buf.append(' ');

			int firstLine = textArea.getFirstLine();
			int visible = textArea.getVisibleLines();
			int lineCount = textArea.getVirtualLineCount();

			if (visible >= lineCount)
			{
				buf.append(""All"");
			}
			else if (firstLine == 0)
			{
				buf.append(""Top"");
			}
			else if (firstLine + visible >= lineCount)
			{
				buf.append(""Bot"");
			}
			else
			{
				float percent = (float)firstLine / (float)lineCount
					* 100.0f;
				buf.append(Integer.toString((int)percent));
				buf.append('%');
			}

			caretStatus.setText(buf.toString());
		}
	} 

	
	public void updateBufferStatus()
	{
		
		

		Buffer buffer = view.getBuffer();

		if (showWrap)
		{
			String wrap = buffer.getStringProperty(""wrap"");
			if(wrap.equals(""none""))
				this.wrap.setText(""-"");
			else if(wrap.equals(""hard""))
				this.wrap.setText(""H"");
			else if(wrap.equals(""soft""))
				this.wrap.setText(""S"");
		}

		if (showLineSeperator)
		{
			String lineSep = buffer.getStringProperty(""lineSeparator"");
			if(""\n"".equals(lineSep))
				this.lineSep.setText(""U"");
			else if(""\r\n"".equals(lineSep))
				this.lineSep.setText(""W"");
			else if(""\r"".equals(lineSep))
				this.lineSep.setText(""M"");
		}

		if (showEditMode || showFoldMode || showEncoding)
		{
			
			buf.setLength(0);
			if (showEditMode)
				buf.append(buffer.getMode().getName());
			if (showFoldMode)
			{
				if (showEditMode)
					buf.append("","");
				buf.append((String)view.getBuffer().getProperty(""folding""));
			}
			if (showEncoding)
			{
				if (showEditMode || showFoldMode)
					buf.append("","");
				buf.append(buffer.getStringProperty(""encoding""));
			}

			mode.setText(""("" + buf.toString() + "")"");
		}
	} 

	
	public void updateMiscStatus()
	{
		
		

		JEditTextArea textArea = view.getTextArea();

		if (showMultiSelect)
			multiSelect.setText(textArea.isMultipleSelectionEnabled()
				? ""M"" : ""-"");
		if (showOverwrite)
			overwrite.setText(textArea.isOverwriteEnabled()
				? ""O"" : ""-"");
	} 

	
	private View view;
	private JPanel panel;
	private Box box;
	private ToolTipLabel caretStatus;
	private Component messageComp;
	private JLabel message;
	private JLabel mode;
	private JLabel wrap;
	private JLabel multiSelect;
	private JLabel overwrite;
	private JLabel lineSep;
	private MemoryStatus memory;
	 StringBuffer buf = new StringBuffer();
	private Timer tempTimer;
	private boolean currentMessageIsIO;

	private Segment seg = new Segment();

	private boolean showCaretStatus = jEdit.getBooleanProperty(""view.status.show-caret-status"");
	private boolean showEditMode = jEdit.getBooleanProperty(""view.status.show-edit-mode"");
	private boolean showFoldMode = jEdit.getBooleanProperty(""view.status.show-fold-mode"");
	private boolean showEncoding = jEdit.getBooleanProperty(""view.status.show-encoding"");
	private boolean showWrap = jEdit.getBooleanProperty(""view.status.show-wrap"");
	private boolean showMultiSelect = jEdit.getBooleanProperty(""view.status.show-multi-select"");
	private boolean showOverwrite = jEdit.getBooleanProperty(""view.status.show-overwrite"");
	private boolean showLineSeperator = jEdit.getBooleanProperty(""view.status.show-line-seperator"");
	private boolean showMemory = jEdit.getBooleanProperty(""view.status.show-memory"");
	

	static final String caretTestStr = ""9999,999-999 99%"";
	static final String memoryTestStr = ""999/999Mb"";

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			Buffer buffer = view.getBuffer();

			Object source = evt.getSource();
			if(source == caretStatus)
			{
				if(evt.getClickCount() == 2)
					view.getTextArea().showGoToLineDialog();
			}
			else if(source == mode)
			{
				if(evt.getClickCount() == 2)
					new BufferOptions(view,view.getBuffer());
			}
			else if(source == wrap)
				buffer.toggleWordWrap(view);
			else if(source == multiSelect)
				view.getTextArea().toggleMultipleSelectionEnabled();
			else if(source == overwrite)
				view.getTextArea().toggleOverwriteEnabled();
			else if(source == lineSep)
				buffer.toggleLineSeparator(view);
			else if(source == memory)
			{
				if(evt.getClickCount() == 2)
				{
					jEdit.showMemoryDialog(view);
					memory.repaint();
				}
			}
		}
	} 

	
	class ToolTipLabel extends JLabel
	{
		
		public Point getToolTipLocation(MouseEvent event)
		{
			return new Point(event.getX(),-20);
		} 
	} 

	
	class MemoryStatus extends JComponent implements ActionListener
	{
		
		public MemoryStatus()
		{
			MemoryStatus.this.setDoubleBuffered(true);
			MemoryStatus.this.setForeground(UIManager.getColor(""Label.foreground""));
			MemoryStatus.this.setBackground(UIManager.getColor(""Label.background""));
			MemoryStatus.this.setFont(UIManager.getFont(""Label.font""));
		} 

		
		public void addNotify()
		{
			super.addNotify();
			timer = new Timer(2000,this);
			timer.start();
			ToolTipManager.sharedInstance().registerComponent(this);
		} 

		
		public void removeNotify()
		{
			timer.stop();
			ToolTipManager.sharedInstance().unregisterComponent(this);
			super.removeNotify();
		} 

		
		public String getToolTipText()
		{
			Runtime runtime = Runtime.getRuntime();
			int freeMemory = (int)(runtime.freeMemory() / 1024);
			int totalMemory = (int)(runtime.totalMemory() / 1024);
			int usedMemory = (totalMemory - freeMemory);
			Integer[] args = { new Integer(usedMemory),
				new Integer(totalMemory) };
			return jEdit.getProperty(""view.status.memory-tooltip"",args);
		} 

		
		public Point getToolTipLocation(MouseEvent event)
		{
			return new Point(event.getX(),-20);
		} 

		
		public void actionPerformed(ActionEvent evt)
		{
			MemoryStatus.this.repaint();
		} 

		 LineMetrics lm;
		 Color progressForeground;
		 Color progressBackground;

		
		public void paintComponent(Graphics g)
		{
			Insets insets = new Insets(0,0,0,0);

			Runtime runtime = Runtime.getRuntime();
			int freeMemory = (int)(runtime.freeMemory() / 1024);
			int totalMemory = (int)(runtime.totalMemory() / 1024);
			int usedMemory = (totalMemory - freeMemory);

			int width = MemoryStatus.this.getWidth()
				- insets.left - insets.right;
			int height = MemoryStatus.this.getHeight()
				- insets.top - insets.bottom - 1;

			float fraction = ((float)usedMemory) / totalMemory;

			g.setColor(progressBackground);

			g.fillRect(insets.left,insets.top,
				(int)(width * fraction),
				height);

			String str = (usedMemory / 1024) + ""/""
				+ (totalMemory / 1024) + ""Mb"";

			FontRenderContext frc = new FontRenderContext(null,false,false);

			Rectangle2D bounds = g.getFont().getStringBounds(str,frc);
		
			Graphics g2 = g.create();
			g2.setClip(insets.left,insets.top,
				(int)(width * fraction),
				height);

			g2.setColor(progressForeground);

			g2.drawString(str,
				insets.left + (int)(width - bounds.getWidth()) / 2,
				(int)(insets.top + lm.getAscent()));

			g2.dispose();

			g2 = g.create();

			g2.setClip(insets.left + (int)(width * fraction),
				insets.top,MemoryStatus.this.getWidth()
				- insets.left - (int)(width * fraction),
				height);

			g2.setColor(MemoryStatus.this.getForeground());

			g2.drawString(str,
				insets.left + (int)(width - bounds.getWidth()) / 2,
				(int)(insets.top + lm.getAscent()));

			g2.dispose();
		} 

		private Timer timer;
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.Mode,13,1,0,19,30,26,15,6,13,0.733333333,274,1.0,3,0.0,0.338461538,0,0,19.69230769,5,2.1538,0,"

package org.gjt.sp.jedit;


import gnu.regexp.*;
import java.util.Hashtable;
import org.gjt.sp.jedit.syntax.TokenMarker;
import org.gjt.sp.util.Log;



public class Mode
{
	
	
	public Mode(String name)
	{
		this.name = name;
		props = new Hashtable();
	} 

	
	
	public void init()
	{
		try
		{
			String filenameGlob = (String)getProperty(""filenameGlob"");
			if(filenameGlob != null && filenameGlob.length() != 0)
			{
				filenameRE = new RE(MiscUtilities.globToRE(
					filenameGlob),RE.REG_ICASE);
			}

			String firstlineGlob = (String)getProperty(""firstlineGlob"");
			if(firstlineGlob != null && firstlineGlob.length() != 0)
			{
				firstlineRE = new RE(MiscUtilities.globToRE(
					firstlineGlob),RE.REG_ICASE);
			}
		}
		catch(REException re)
		{
			Log.log(Log.ERROR,this,""Invalid filename/firstline""
				+ "" globs in mode "" + name);
			Log.log(Log.ERROR,this,re);
		}

		
		
		
		
		
		
		marker = null;
	} 

	
	
	public TokenMarker getTokenMarker()
	{
		loadIfNecessary();
		return marker;
	} 

	
	
	public void setTokenMarker(TokenMarker marker)
	{
		this.marker = marker;
	} 

	
	
	public void loadIfNecessary()
	{
		if(marker == null)
			jEdit.loadMode(this);
	} 

	
	
	public Object getProperty(String key)
	{
		String prefix = ""mode."" + name + ""."";

		
		
			String property = jEdit.getProperty(prefix + key);
			if(property != null)
			{
				Object value;
				try
				{
					value = new Integer(property);
				}
				catch(NumberFormatException nf)
				{
					value = property;
				}
				return value;
			}
		

		Object value = props.get(key);
		if(value != null)
			return value;

		String global = jEdit.getProperty(""buffer."" + key);
		if(global != null)
		{
			try
			{
				return new Integer(global);
			}
			catch(NumberFormatException nf)
			{
				return global;
			}
		}
		else
			return null;
	} 

	
	
	public boolean getBooleanProperty(String key)
	{
		Object value = getProperty(key);
		if(""true"".equals(value) || ""on"".equals(value) || ""yes"".equals(value))
			return true;
		else
			return false;
	} 

	
	
	public void setProperty(String key, Object value)
	{
		props.put(key,value);
	} 

	
	
	public void unsetProperty(String key)
	{
		props.remove(key);
	} 

	
	
	public void setProperties(Hashtable props)
	{
		
		
		
		String filenameGlob = (String)this.props.get(""filenameGlob"");
		String firstlineGlob = (String)this.props.get(""firstlineGlob"");
		String filename = (String)this.props.get(""file"");
		this.props = props;
		if(filenameGlob != null)
			props.put(""filenameGlob"",filenameGlob);
		if(firstlineGlob != null)
			props.put(""firstlineGlob"",firstlineGlob);
		if(filename != null)
			props.put(""file"",filename);
	} 

	
	
	public boolean accept(String fileName, String firstLine)
	{
		if(filenameRE != null && filenameRE.isMatch(fileName))
			return true;

		if(firstlineRE != null && firstlineRE.isMatch(firstLine))
			return true;

		return false;
	} 

	
	
	public String getName()
	{
		return name;
	} 

	
	
	public String toString()
	{
		return name;
	} 

	
	private String name;
	private Hashtable props;
	private RE firstlineRE;
	private RE filenameRE;
	private TokenMarker marker;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.browser.FileCellRenderer,6,6,0,12,36,3,7,5,4,0.7,263,0.3,0,0.994482759,0.314285714,2,2,41.16666667,11,3.3333,1,"

package org.gjt.sp.jedit.browser;


import java.awt.*;
import javax.swing.*;
import javax.swing.tree.*;
import javax.swing.border.*;
import org.gjt.sp.jedit.io.VFS;
import org.gjt.sp.jedit.*;


public class FileCellRenderer extends DefaultTreeCellRenderer
{
	public static Icon fileIcon = GUIUtilities.loadIcon(""File.png"");
	public static Icon openFileIcon = GUIUtilities.loadIcon(""OpenFile.png"");
	public static Icon dirIcon = GUIUtilities.loadIcon(""Folder.png"");
	public static Icon openDirIcon = GUIUtilities.loadIcon(""OpenFolder.png"");
	public static Icon filesystemIcon = GUIUtilities.loadIcon(""DriveSmall.png"");
	public static Icon loadingIcon = GUIUtilities.loadIcon(""ReloadSmall.png"");

	
	public FileCellRenderer()
	{
		plainFont = UIManager.getFont(""Tree.font"");
		boldFont = plainFont.deriveFont(Font.BOLD);
		setBorder(new EmptyBorder(1,0,1,0));
	} 

	
	public Component getTreeCellRendererComponent(JTree tree, Object value,
		boolean sel, boolean expanded, boolean leaf, int row,
		boolean focus)
	{
		super.getTreeCellRendererComponent(tree,value,sel,expanded,
			leaf,row,focus);

		DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode)value;
		Object userObject = treeNode.getUserObject();
		if(userObject instanceof VFS.DirectoryEntry)
		{
			VFS.DirectoryEntry file = (VFS.DirectoryEntry)userObject;

			underlined = (jEdit.getBuffer(file.path) != null);

			setIcon(showIcons
				? getIconForFile(file,expanded)
				: null);
			setFont(file.type == VFS.DirectoryEntry.FILE
				? plainFont : boldFont);
			setText(file.name);

			if(!sel)
			{
				Color color = file.getColor();

				setForeground(color == null
					? UIManager.getColor(""Tree.foreground"")
					: color);
			}
		}
		else if(userObject instanceof BrowserView.LoadingPlaceholder)
		{
			setIcon(showIcons ? loadingIcon : null);
			setFont(plainFont);
			setText(jEdit.getProperty(""vfs.browser.tree.loading""));
			underlined = false;
		}
		else if(userObject instanceof String)
		{
			setIcon(showIcons ? dirIcon : null);
			setFont(boldFont);
			setText((String)userObject);
			underlined = false;
		}
		else
		{
			
			setIcon(null);
			setText(null);
		}

		return this;
	} 

	
	public void paintComponent(Graphics g)
	{
		if(underlined)
		{
			Font font = getFont();

			FontMetrics fm = getFontMetrics(font);
			int x, y;
			if(getIcon() == null)
			{
				x = 0;
				y = fm.getAscent() + 2;
			}
			else
			{
				x = getIcon().getIconWidth() + getIconTextGap();
				y = Math.max(fm.getAscent() + 2,16);
			}
			g.setColor(getForeground());
			g.drawLine(x,y,x + fm.stringWidth(getText()),y);
		}

		super.paintComponent(g);
	} 

	
	public static Icon getIconForFile(VFS.DirectoryEntry file, boolean expanded)
	{
		if(file.type == VFS.DirectoryEntry.DIRECTORY)
			return (expanded ? openDirIcon : dirIcon);
		else if(file.type == VFS.DirectoryEntry.FILESYSTEM)
			return filesystemIcon;
		else if(jEdit.getBuffer(file.path) != null)
			return openFileIcon;
		else
			return fileIcon;
	} 

	
	boolean showIcons;

	
	void propertiesChanged()
	{
		showIcons = jEdit.getBooleanProperty(""vfs.browser.showIcons"");
	} 

	

	
	private Font plainFont;
	private Font boldFont;

	private boolean underlined;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.help.HelpIndex,11,1,0,12,56,23,3,9,7,0.65,479,1.0,1,0.0,0.4,0,0,42.18181818,3,1.0909,1,"

package org.gjt.sp.jedit.help;


import java.io.*;
import java.net.*;
import java.util.zip.*;
import java.util.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


class HelpIndex
{
	
	public HelpIndex()
	{
		words = new HashMap();
		files = new ArrayList();

		ignoreWord(""a"");
		ignoreWord(""an"");
		ignoreWord(""and"");
		ignoreWord(""are"");
		ignoreWord(""as"");
		ignoreWord(""be"");
		ignoreWord(""by"");
		ignoreWord(""can"");
		ignoreWord(""do"");
		ignoreWord(""for"");
		ignoreWord(""from"");
		ignoreWord(""how"");
		ignoreWord(""i"");
		ignoreWord(""if"");
		ignoreWord(""in"");
		ignoreWord(""is"");
		ignoreWord(""it"");
		ignoreWord(""not"");
		ignoreWord(""of"");
		ignoreWord(""on"");
		ignoreWord(""or"");
		ignoreWord(""s"");
		ignoreWord(""that"");
		ignoreWord(""the"");
		ignoreWord(""this"");
		ignoreWord(""to"");
		ignoreWord(""will"");
		ignoreWord(""with"");
		ignoreWord(""you"");
	} 

	
	public void indexEditorHelp() throws Exception
	{
		String jEditHome = jEdit.getJEditHome();
		if(jEditHome != null)
		{
			indexDirectory(MiscUtilities.constructPath(jEditHome,""doc"",""users-guide""));
			indexDirectory(MiscUtilities.constructPath(jEditHome,""doc"",""FAQ""));
		}

		EditPlugin.JAR[] jars = jEdit.getPluginJARs();
		for(int i = 0; i < jars.length; i++)
		{
			indexJAR(jars[i].getZipFile());
		}

		Log.log(Log.DEBUG,this,""Indexed "" + words.size() + "" words"");
	} 

	
	
	public void indexDirectory(String dir) throws Exception
	{
		String[] files = VFSManager.getFileVFS()
			._listDirectory(null,dir,""*.{html,txt}"",true,null);

		for(int i = 0; i < files.length; i++)
		{
			indexURL(files[i]);
		}
	} 

	
	
	public void indexJAR(ZipFile jar) throws Exception
	{
		Enumeration enum = jar.entries();
		while(enum.hasMoreElements())
		{
			ZipEntry entry = (ZipEntry)enum.nextElement();
			String name = entry.getName();
			String lname = name.toLowerCase();
			if(lname.endsWith("".html""))
			{
				
				String url = ""jeditresource:/"" +
					MiscUtilities.getFileName(jar.getName())
					+ ""!/"" + name;
				Log.log(Log.DEBUG,this,url);
				indexStream(jar.getInputStream(entry),url);
			}
		}
	} 

	
	
	public void indexURL(String url) throws Exception
	{
		InputStream _in;

		if(MiscUtilities.isURL(url))
			_in =  new URL(url).openStream();
		else
		{
			_in = new FileInputStream(url);
			
			url = ""file:"" + url;
		}

		indexStream(_in,url);
	} 

	
	public Word lookupWord(String word)
	{
		Object o = words.get(word);
		if(o == IGNORE)
			return null;
		else
			return (Word)o;
	} 

	
	public HelpFile getFile(int index)
	{
		return (HelpFile)files.get(index);
	} 

	
	private static Word.Occurrence[] EMPTY_ARRAY = new Word.Occurrence[0];
	
	private static Object IGNORE = new Object();
	private HashMap words;
	private ArrayList files;

	
	private void ignoreWord(String word)
	{
		words.put(word,IGNORE);
	} 

	
	
	private void indexStream(InputStream _in, String fileName) throws Exception
	{
		HelpFile file = new HelpFile(fileName);
		files.add(file);
		int index = files.size() - 1;

		BufferedReader in = new BufferedReader(new InputStreamReader(_in));

		StringBuffer titleText = new StringBuffer();

		try
		{
			StringBuffer word = new StringBuffer();
			boolean insideTag = false;
			boolean insideEntity = false;

			boolean title = false;

			int c;
			while((c = in.read()) != -1)
			{
				char ch = (char)c;
				if(insideTag)
				{
					if(ch == '>')
					{
						if(word.toString().equals(""title""))
							title = true;
						insideTag = false;
						word.setLength(0);
					}
					else
						word.append(ch);
				}
				else if(insideEntity)
				{
					if(ch == ';')
						insideEntity = false;
				}
				else if(ch == '<')
				{
					if(title)
						title = false;

					if(word.length() != 0)
					{
						addWord(word.toString(),index);
						word.setLength(0);
					}

					insideTag = true;
				}
				else if(ch == '&')
					insideEntity = true;
				else if(title)
					titleText.append(ch);
				else if(!Character.isLetterOrDigit(ch))
				{
					if(word.length() != 0)
					{
						addWord(word.toString(),index);
						word.setLength(0);
					}
				}
				else
					word.append(ch);
			}
		}
		finally
		{
			in.close();
		}

		if(titleText.length() == 0)
			file.title = fileName;
		else
			file.title = titleText.toString();
	} 

	
	private void addWord(String word, int file)
	{
		word = word.toLowerCase();

		Object o = words.get(word);
		if(o == IGNORE)
			return;

		if(o == null)
			words.put(word,new Word(word,file));
		else
			((Word)o).addOccurrence(file);
	} 

	

	
	static class Word
	{
		
		String word;

		
		int occurCount = 0;
		Occurrence[] occurrences;

		Word(String word, int file)
		{
			this.word = word;
			occurrences = new Occurrence[5];
			addOccurrence(file);
		}

		void addOccurrence(int file)
		{
			for(int i = 0; i < occurCount; i++)
			{
				if(occurrences[i].file == file)
				{
					occurrences[i].count++;
					return;
				}
			}

			if(occurCount >= occurrences.length)
			{
				Occurrence[] newOccur = new Occurrence[occurrences.length * 2];
				System.arraycopy(occurrences,0,newOccur,0,occurCount);
				occurrences = newOccur;
			}

			occurrences[occurCount++] = new Occurrence(file);
		}

		static class Occurrence
		{
			int file;
			int count;

			Occurrence(int file)
			{
				this.file = file;
				this.count = 1;
			}
		}
	} 

	
	static class HelpFile
	{
		String file;
		String title;

		HelpFile(String file)
		{
			this.file = file;
			this.title = title;
		}

		public String toString()
		{
			return title;
		}

		public boolean equals(Object o)
		{
			if(o instanceof HelpFile)
				return ((HelpFile)o).file.equals(file);
			else
				return false;
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.DockableWindowContainer,6,1,0,4,6,15,4,1,6,2.0,6,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.gui;


public interface DockableWindowContainer
{
	void register(DockableWindowManager.Entry entry);
	void add(DockableWindowManager.Entry entry);
	void remove(DockableWindowManager.Entry entry);
	void save(DockableWindowManager.Entry entry);
	void show(DockableWindowManager.Entry entry);
	boolean isVisible(DockableWindowManager.Entry entry);
}
"
jEdit,4.1,org.gjt.sp.jedit.options.TextAreaOptionPane,3,6,0,5,28,1,1,4,3,0.5,435,1.0,9,0.997019374,1.0,3,5,137.3333333,2,1.3333,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;


public class TextAreaOptionPane extends AbstractOptionPane
{
	
	public TextAreaOptionPane()
	{
		super(""textarea"");
	} 

	
	public void _init()
	{
		
		font = new FontSelector(jEdit.getFontProperty(""view.font""));

		addComponent(jEdit.getProperty(""options.textarea.font""),font);

		
		addComponent(jEdit.getProperty(""options.textarea.foreground""),
			foregroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.fgColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.textarea.background""),
			backgroundColor = new ColorWellButton(
			jEdit.getColorProperty(""view.bgColor"")),
			GridBagConstraints.VERTICAL);

		
		blinkCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blinkCaret""));
		blinkCaret.setSelected(jEdit.getBooleanProperty(""view.caretBlink""));

		blockCaret = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".blockCaret""));
		blockCaret.setSelected(jEdit.getBooleanProperty(""view.blockCaret""));

		Box caretSettings = new Box(BoxLayout.X_AXIS);
		caretSettings.add(new JLabel(jEdit.getProperty(
			""options.textarea.caret"")));
		caretSettings.add(Box.createHorizontalStrut(6));
		caretSettings.add(blinkCaret);
		caretSettings.add(blockCaret);

		addComponent(caretSettings,caretColor = new ColorWellButton(
			jEdit.getColorProperty(""view.caretColor"")),
			GridBagConstraints.VERTICAL);

		
		addComponent(jEdit.getProperty(""options.textarea.selection""),
			selectionColor = new ColorWellButton(
			jEdit.getColorProperty(""view.selectionColor"")),
			GridBagConstraints.VERTICAL);

		
		lineHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".lineHighlight""));
		lineHighlight.setSelected(jEdit.getBooleanProperty(""view.lineHighlight""));
		addComponent(lineHighlight,lineHighlightColor = new ColorWellButton(
			jEdit.getColorProperty(""view.lineHighlightColor"")),
			GridBagConstraints.VERTICAL);

		
		bracketHighlight = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".bracketHighlight""));
		bracketHighlight.setSelected(jEdit.getBooleanProperty(
			""view.bracketHighlight""));
		addComponent(bracketHighlight,bracketHighlightColor = new ColorWellButton(
			jEdit.getColorProperty(""view.bracketHighlightColor"")),
			GridBagConstraints.VERTICAL);

		
		eolMarkers = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".eolMarkers""));
		eolMarkers.setSelected(jEdit.getBooleanProperty(""view.eolMarkers""));
		addComponent(eolMarkers,eolMarkerColor =new ColorWellButton(
			jEdit.getColorProperty(""view.eolMarkerColor"")),
			GridBagConstraints.VERTICAL);

		
		wrapGuide = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".wrapGuide""));
		wrapGuide.setSelected(jEdit.getBooleanProperty(""view.wrapGuide""));
		addComponent(wrapGuide,wrapGuideColor = new ColorWellButton(
			jEdit.getColorProperty(""view.wrapGuideColor"")),
			GridBagConstraints.VERTICAL);

		
		electricBorders = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".electricBorders""));
		electricBorders.setSelected(!""0"".equals(jEdit.getProperty(
			""view.electricBorders"")));
		addComponent(electricBorders);

		
		joinNonWordChars = new JCheckBox(jEdit.getProperty(
			""options.textarea.joinNonWordChars""));
		joinNonWordChars.setSelected(jEdit.getBooleanProperty(
			""view.joinNonWordChars""));
		addComponent(joinNonWordChars);

		
		middleMousePaste = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".middleMousePaste""));
		middleMousePaste.setSelected(jEdit.getBooleanProperty(
			""view.middleMousePaste""));
		addComponent(middleMousePaste);

		
		antiAlias = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".antiAlias""));
		antiAlias.setSelected(jEdit.getBooleanProperty(""view.antiAlias""));
		addComponent(antiAlias);

		
		fracFontMetrics = new JCheckBox(jEdit.getProperty(""options.textarea""
			+ "".fracFontMetrics""));
		fracFontMetrics.setSelected(jEdit.getBooleanProperty(
			""view.fracFontMetrics""));
		addComponent(fracFontMetrics);
	} 

	
	public void _save()
	{
		jEdit.setFontProperty(""view.font"",font.getFont());

		jEdit.setColorProperty(""view.fgColor"",foregroundColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.bgColor"",backgroundColor
			.getSelectedColor());
		jEdit.setBooleanProperty(""view.caretBlink"",blinkCaret.isSelected());
		jEdit.setBooleanProperty(""view.blockCaret"",blockCaret.isSelected());
		jEdit.setColorProperty(""view.caretColor"",caretColor
			.getSelectedColor());
		jEdit.setColorProperty(""view.selectionColor"",selectionColor
			.getSelectedColor());
		jEdit.setBooleanProperty(""view.lineHighlight"",lineHighlight
			.isSelected());
		jEdit.setColorProperty(""view.lineHighlightColor"",
			lineHighlightColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.bracketHighlight"",bracketHighlight
			.isSelected());
		jEdit.setColorProperty(""view.bracketHighlightColor"",
			bracketHighlightColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.eolMarkers"",eolMarkers
			.isSelected());
		jEdit.setColorProperty(""view.eolMarkerColor"",
			eolMarkerColor.getSelectedColor());
		jEdit.setBooleanProperty(""view.wrapGuide"",wrapGuide
			.isSelected());
		jEdit.setColorProperty(""view.wrapGuideColor"",
			wrapGuideColor.getSelectedColor());
		jEdit.setIntegerProperty(""view.electricBorders"",electricBorders
			.isSelected() ? 3 : 0);
		jEdit.setBooleanProperty(""view.joinNonWordChars"",joinNonWordChars.isSelected());
		jEdit.setBooleanProperty(""view.middleMousePaste"",
			middleMousePaste.isSelected());
		jEdit.setBooleanProperty(""view.antiAlias"",antiAlias.isSelected());
		jEdit.setBooleanProperty(""view.fracFontMetrics"",fracFontMetrics.isSelected());
	} 

	
	private FontSelector font;
	private ColorWellButton foregroundColor;
	private ColorWellButton backgroundColor;
	private JCheckBox blinkCaret;
	private JCheckBox blockCaret;
	private ColorWellButton caretColor;
	private ColorWellButton selectionColor;
	private JCheckBox lineHighlight;
	private ColorWellButton lineHighlightColor;
	private JCheckBox bracketHighlight;
	private ColorWellButton bracketHighlightColor;
	private JCheckBox eolMarkers;
	private ColorWellButton eolMarkerColor;
	private JCheckBox wrapGuide;
	private ColorWellButton wrapGuideColor;
	private JCheckBox electricBorders;
	private JCheckBox middleMousePaste;
	private JCheckBox antiAlias;
	private JCheckBox fracFontMetrics;
	private JCheckBox joinNonWordChars;
	
}
"
jEdit,4.1,org.gjt.sp.util.Log,13,1,0,76,55,38,76,1,7,0.892857143,446,0.5,0,0.0,0.178571429,0,0,32.23076923,7,2.3846,0,"

package org.gjt.sp.util;

import javax.swing.text.*;
import java.io.*;
import java.util.StringTokenizer;


public class Log
{
	
	public static final int MAXLINES = 500;

	
	public static final int DEBUG = 1;

	
	public static final int MESSAGE = 3;

	
	public static final int NOTICE = 5;

	
	public static final int WARNING = 7;

	
	public static final int ERROR = 9;

	
	public static void init(boolean stdio, int level)
	{
		if(stdio)
		{
			if(System.out == realOut && System.err == realErr)
			{
				System.setOut(createPrintStream(NOTICE,null));
				System.setErr(createPrintStream(ERROR,null));
			}
		}

		Log.level = level;

		
		log(MESSAGE,Log.class,""When reporting bugs, please""
			+ "" include the following information:"");
		String[] props = {
			""java.version"", ""java.vm.version"", ""java.runtime.version"",
			""java.vendor"", ""java.compiler"", ""os.name"", ""os.version"",
			""os.arch"", ""user.home"", ""java.home"",
			""java.class.path"",
			};
		for(int i = 0; i < props.length; i++)
		{
			log(MESSAGE,Log.class,
				props[i] + ""="" + System.getProperty(props[i]));
		}
	}

	
	public static void setLogWriter(Writer stream)
	{
		if(Log.stream == null && stream != null)
		{
			try
			{
				stream.write(logDocument.getText(0,
					logDocument.getLength()));

				stream.flush();
			}
			catch(Exception e)
			{
				
			}
		}

		Log.stream = stream;
	}

	
	public static Document getLogDocument()
	{
		return logDocument;
	}

	
	public static void flushStream()
	{
		if(stream != null)
		{
			try
			{
				stream.flush();
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	}

	
	public static void closeStream()
	{
		if(stream != null)
		{
			try
			{
				stream.close();
				stream = null;
			}
			catch(IOException io)
			{
				io.printStackTrace(realErr);
			}
		}
	}

	
	public static void log(int urgency, Object source, Object message)
	{
		String _source;
		if(source == null)
		{
			_source = Thread.currentThread().getName();
			if(_source == null)
			{
				_source = Thread.currentThread().getClass().getName();
			}
		}
		else if(source instanceof Class)
			_source = ((Class)source).getName();
		else
			_source = source.getClass().getName();
		int index = _source.lastIndexOf('.');
		if(index != -1)
			_source = _source.substring(index+1);

		if(message instanceof Throwable)
		{
			_logException(urgency,source,(Throwable)message);
		}
		else
		{
			String _message = String.valueOf(message);
			
			
			synchronized(LOCK)
			{
				StringTokenizer st = new StringTokenizer(
					_message,""\r\n"");
				while(st.hasMoreTokens())
				{
					_log(urgency,_source,st.nextToken());
				}
			}
		}
	}

	
	private static Object LOCK = new Object();
	private static Document logDocument;
	private static int level = WARNING;
	private static Writer stream;
	private static String lineSep;
	private static PrintStream realOut;
	private static PrintStream realErr;

	static
	{
		level = WARNING;

		realOut = System.out;
		realErr = System.err;

		logDocument = new PlainDocument();
		lineSep = System.getProperty(""line.separator"");
	}

	private static PrintStream createPrintStream(final int urgency,
		final Object source)
	{
		return new PrintStream(new OutputStream() {
			public void write(int b)
			{
				byte[] barray = { (byte)b };
				write(barray,0,1);
			}

			public void write(byte[] b, int off, int len)
			{
				String str = new String(b,off,len);
				log(urgency,source,str);
			}
		});
	}

	private static void _logException(final int urgency,
		final Object source,
		final Throwable message)
	{
		PrintStream out = createPrintStream(urgency,source);

		synchronized(LOCK)
		{
			message.printStackTrace(out);
		}
	}

	private static void _log(int urgency, String source, String message)
	{
		String urgencyString = ""["" + urgencyToString(urgency) + ""] "";

		String fullMessage = urgencyString + source + "": "" + message;

		try
		{
			logDocument.insertString(logDocument.getLength(),
				fullMessage,null);
			logDocument.insertString(logDocument.getLength(),
				""\n"",null);

			Element map = logDocument.getDefaultRootElement();
			int lines = map.getElementCount();
			if(lines > MAXLINES)
			{
				Element first = map.getElement(0);
				Element last = map.getElement(lines - MAXLINES);
				logDocument.remove(first.getStartOffset(),
					last.getEndOffset());
			}

			if(stream != null)
			{
				stream.write(fullMessage);
				stream.write(lineSep);
			}
		}
		catch(Exception e)
		{
			e.printStackTrace(realErr);
		}

		message = urgencyString +  message + '\n';

		if(urgency >= level)
		{
			if(urgency == ERROR)
				realErr.print(message);
			else
				realOut.print(message);
		}
	}

	private static String urgencyToString(int urgency)
	{
		switch(urgency)
		{
		case DEBUG:
			return ""debug"";
		case MESSAGE:
			return ""message"";
		case NOTICE:
			return ""notice"";
		case WARNING:
			return ""warning"";
		case ERROR:
			return ""error"";
		}

		throw new IllegalArgumentException(""Invalid urgency: "" + urgency);
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.DummyTokenHandler,3,1,0,3,4,3,1,2,2,1.0,13,0.0,1,0.0,0.625,0,0,3.0,1,0.3333,0,"

package org.gjt.sp.jedit.syntax;


public class DummyTokenHandler implements TokenHandler
{
	
	public static final DummyTokenHandler INSTANCE = new DummyTokenHandler();

	
	
	public void handleToken(byte id, int offset, int length,
		TokenMarker.LineContext context) {}
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.DefaultInputHandler,16,3,0,9,65,38,3,7,13,0.666666667,670,0.777777778,0,0.729166667,0.185185185,2,5,40.3125,24,4.875,3,"

package org.gjt.sp.jedit.gui;


import javax.swing.KeyStroke;
import java.awt.event.*;
import java.awt.Toolkit;
import java.util.Hashtable;
import java.util.StringTokenizer;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class DefaultInputHandler extends InputHandler
{
	
	
	public DefaultInputHandler(View view)
	{
		super(view);

		bindings = currentBindings = new Hashtable();
	} 

	
	
	public DefaultInputHandler(View view, DefaultInputHandler copy)
	{
		super(view);

		bindings = currentBindings = copy.bindings;
	} 

	
	
	public void addKeyBinding(String keyBinding, EditAction action)
	{
	        Hashtable current = bindings;

		StringTokenizer st = new StringTokenizer(keyBinding);
		while(st.hasMoreTokens())
		{
			String keyCodeStr = st.nextToken();
			KeyStroke keyStroke = parseKeyStroke(keyCodeStr);
			if(keyStroke == null)
				return;

			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = (Hashtable)o;
				else
				{
					Hashtable hash = new Hashtable();
					hash.put(PREFIX_STR,keyCodeStr);
					o = hash;
					current.put(keyStroke,o);
					current = (Hashtable)o;
				}
			}
			else
				current.put(keyStroke,action);
		}
	} 

	
	
	public void removeKeyBinding(String keyBinding)
	{
		throw new InternalError(""Not yet implemented"");
	} 

	
	
	public void removeAllKeyBindings()
	{
		bindings.clear();
	} 

	
	
	public Object getKeyBinding(String keyBinding)
	{
		Hashtable current = bindings;
		StringTokenizer st = new StringTokenizer(keyBinding);

		while(st.hasMoreTokens())
		{
			KeyStroke keyStroke = parseKeyStroke(st.nextToken());
			if(keyStroke == null)
				return null;

			if(st.hasMoreTokens())
			{
				Object o = current.get(keyStroke);
				if(o instanceof Hashtable)
					current = (Hashtable)o;
				else
					return o;
			}
			else
			{
				return current.get(keyStroke);
			}
		}

		return null;
	} 

	
	
	public boolean isPrefixActive()
	{
		return bindings != currentBindings;
	} 

	
	
	public void keyPressed(KeyEvent evt)
	{
		int keyCode = evt.getKeyCode();
		int modifiers = evt.getModifiers();

		if(!(evt.isControlDown() || evt.isAltDown() || evt.isMetaDown()))
		{
			
			
			if((keyCode >= KeyEvent.VK_A && keyCode <= KeyEvent.VK_Z)
				|| (keyCode >= KeyEvent.VK_0 && keyCode <= KeyEvent.VK_9))
			{
				return;
			}
			else if(keyCode == KeyEvent.VK_SPACE)
			{
				return;
			}
			else if(readNextChar != null)
			{
				if(keyCode == KeyEvent.VK_ESCAPE)
				{
					readNextChar = null;
					view.getStatus().setMessage(null);
				}
				else if(!evt.isActionKey()
					&& keyCode != KeyEvent.VK_TAB
					&& keyCode != KeyEvent.VK_ENTER)
				{
					return;
				}
			}
			else
			{
				
			}
		}

		KeyStroke keyStroke = KeyStroke.getKeyStroke(keyCode,
			modifiers);

		Object o = currentBindings.get(keyStroke);
		if(o == null)
		{
			
			
			
			
			if(currentBindings != bindings)
			{
				Toolkit.getDefaultToolkit().beep();
				
				
				repeatCount = 0;
				repeat = false;
				evt.consume();
				setCurrentBindings(bindings);
			}
			else if(modifiers == 0 && (keyCode == KeyEvent.VK_ENTER
				|| keyCode == KeyEvent.VK_TAB))
			{
				userInput((char)keyCode);
				evt.consume();
			}
		}

		if(readNextChar != null)
		{
			readNextChar = null;
			view.getStatus().setMessage(null);
		}

		if(o instanceof EditAction)
		{
			setCurrentBindings(bindings);
			invokeAction((EditAction)o);
			evt.consume();
		}
		else if(o instanceof Hashtable)
		{
			setCurrentBindings((Hashtable)o);
			evt.consume();
		}

		if(o == null)
		{
			switch(evt.getKeyCode())
			{
				case KeyEvent.VK_NUMPAD0:   case KeyEvent.VK_NUMPAD1:
				case KeyEvent.VK_NUMPAD2:   case KeyEvent.VK_NUMPAD3:
				case KeyEvent.VK_NUMPAD4:   case KeyEvent.VK_NUMPAD5:
				case KeyEvent.VK_NUMPAD6:   case KeyEvent.VK_NUMPAD7:
				case KeyEvent.VK_NUMPAD8:   case KeyEvent.VK_NUMPAD9:
				case KeyEvent.VK_MULTIPLY:  case KeyEvent.VK_ADD:
				 case KeyEvent.VK_SUBTRACT:
				case KeyEvent.VK_DECIMAL:   case KeyEvent.VK_DIVIDE:
					KeyEventWorkaround.numericKeypadKey();
					break;
			}
		}
	} 

	
	
	public void keyTyped(KeyEvent evt)
	{
		char c = evt.getKeyChar();

		
		if(c == '\b')
			return;

		KeyStroke keyStroke;

		
		
		
		switch(c)
		{
		case ' ':
			keyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_SPACE,
				evt.getModifiers());
			break;
		case '\t':
			keyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_TAB,
				evt.getModifiers());
			break;
		case '\n':
			keyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ENTER,
				evt.getModifiers());
			break;
		default:
			keyStroke = KeyStroke.getKeyStroke(c);
			break;
		}

		Object o = currentBindings.get(keyStroke);

		if(o instanceof Hashtable)
		{
			setCurrentBindings((Hashtable)o);
		}
		else if(o instanceof EditAction)
		{
			setCurrentBindings(bindings);
			invokeAction((EditAction)o);
		}
		else
		{
			
			setCurrentBindings(bindings);

			if(repeat && Character.isDigit(c))
			{
				repeatCount *= 10;
				repeatCount += (c - '0');
				view.getStatus().setMessage(null);
			}
			else
				userInput(c);
		}
	} 

	
	
	public static void setModifierMapping(int c, int a, int m, int s)
	{
		DefaultInputHandler.c = c;
		DefaultInputHandler.a = a;
		DefaultInputHandler.m = m;
		DefaultInputHandler.s = s;
	} 

	
	
	public static char getSymbolicModifierName(int mod)
	{
		
		
		if(mod == c)
			return 'C';
		else if(mod == a)
			return 'A';
		else if(mod == m)
			return 'M';
		else if(mod == s)
			return 'S';
		else
			return '\0';
	} 

	
	
	public static String getModifierString(InputEvent evt)
	{
		StringBuffer buf = new StringBuffer();
		if(evt.isControlDown())
			buf.append(getSymbolicModifierName(InputEvent.CTRL_MASK));
		if(evt.isAltDown())
			buf.append(getSymbolicModifierName(InputEvent.ALT_MASK));
		if(evt.isMetaDown())
			buf.append(getSymbolicModifierName(InputEvent.META_MASK));
		if(evt.isShiftDown())
			buf.append(getSymbolicModifierName(InputEvent.SHIFT_MASK));
		return buf.toString();
	} 

	
	
	public static KeyStroke parseKeyStroke(String keyStroke)
	{
		if(keyStroke == null)
			return null;
		int modifiers = 0;
		int index = keyStroke.indexOf('+');
		if(index != -1)
		{
			for(int i = 0; i < index; i++)
			{
				switch(Character.toUpperCase(keyStroke
					.charAt(i)))
				{
				case 'A':
					modifiers |= a;
					break;
				case 'C':
					modifiers |= c;
					break;
				case 'M':
					modifiers |= m;
					break;
				case 'S':
					modifiers |= s;
					break;
				}
			}
		}
		String key = keyStroke.substring(index + 1);
		if(key.length() == 1)
		{
			char ch = key.charAt(0);
			if(modifiers == 0)
				return KeyStroke.getKeyStroke(ch);
			else
			{
				return KeyStroke.getKeyStroke(Character.toUpperCase(ch),
					modifiers);
			}
		}
		else if(key.length() == 0)
		{
			Log.log(Log.ERROR,DefaultInputHandler.class,
				""Invalid key stroke: "" + keyStroke);
			return null;
		}
		else
		{
			int ch;

			try
			{
				ch = KeyEvent.class.getField(""VK_"".concat(key))
					.getInt(null);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,DefaultInputHandler.class,
					""Invalid key stroke: ""
					+ keyStroke);
				return null;
			}

			return KeyStroke.getKeyStroke(ch,modifiers);
		}
	} 

	

	
	static
	{
		if(OperatingSystem.isMacOS())
		{
			setModifierMapping(
				InputEvent.META_MASK,
				InputEvent.ALT_MASK,
				InputEvent.CTRL_MASK,
				InputEvent.SHIFT_MASK);
		}
		else
		{
			setModifierMapping(
				InputEvent.CTRL_MASK,
				InputEvent.ALT_MASK,
				InputEvent.META_MASK,
				InputEvent.SHIFT_MASK);
		}
	} 

	private static int c, a, m, s;

	
	private static Object PREFIX_STR = ""PREFIX_STR"";

	private Hashtable bindings;
	private Hashtable currentBindings;

	
	private void setCurrentBindings(Hashtable bindings)
	{
		String prefixStr = (String)bindings.get(PREFIX_STR);
		if(prefixStr != null)
		{
			if(currentBindings != this.bindings)
			{
				
				prefixStr = currentBindings.get(PREFIX_STR)
					+ "" "" + prefixStr;
			}

			view.getStatus().setMessage(prefixStr);
		}
		else
			view.getStatus().setMessage(null);

		currentBindings = bindings;
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.options.ContextOptionPane,11,6,0,9,53,25,3,8,1,0.716666667,349,1.0,0,0.985272459,0.5,3,5,30.18181818,6,1.9091,1,"

package org.gjt.sp.jedit.options;

import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;


public class ContextOptionPane extends AbstractOptionPane
{
	public ContextOptionPane()
	{
		super(""context"");
	}

	
	protected void _init()
	{
		setLayout(new BorderLayout());

		JLabel caption = new JLabel(jEdit.getProperty(
			""options.context.caption""));
		add(BorderLayout.NORTH,caption);

		String contextMenu = jEdit.getProperty(""view.context"");
		StringTokenizer st = new StringTokenizer(contextMenu);
		listModel = new DefaultListModel();
		while(st.hasMoreTokens())
		{
			String actionName = (String)st.nextToken();
			if(actionName.equals(""-""))
				listModel.addElement(new ContextOptionPane.MenuItem(""-"",""-""));
			else
			{
				EditAction action = jEdit.getAction(actionName);
				if(action == null)
					continue;
				String label = action.getLabel();
				if(label == null)
					continue;
				listModel.addElement(new ContextOptionPane.MenuItem(actionName,label));
			}
		}
		list = new JList(listModel);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		list.addListSelectionListener(new ListHandler());

		add(BorderLayout.CENTER,new JScrollPane(list));

		JPanel buttons = new JPanel();
		buttons.setBorder(new EmptyBorder(3,0,0,0));
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		ActionHandler actionHandler = new ActionHandler();
		add = new RolloverButton(GUIUtilities.loadIcon(""Plus.png""));
		add.setToolTipText(jEdit.getProperty(""options.context.add""));
		add.addActionListener(actionHandler);
		buttons.add(add);
		buttons.add(Box.createHorizontalStrut(6));
		remove = new RolloverButton(GUIUtilities.loadIcon(""Minus.png""));
		remove.setToolTipText(jEdit.getProperty(""options.context.remove""));
		remove.addActionListener(actionHandler);
		buttons.add(remove);
		buttons.add(Box.createHorizontalStrut(6));
		moveUp = new RolloverButton(GUIUtilities.loadIcon(""ArrowU.png""));
		moveUp.setToolTipText(jEdit.getProperty(""options.context.moveUp""));
		moveUp.addActionListener(actionHandler);
		buttons.add(moveUp);
		buttons.add(Box.createHorizontalStrut(6));
		moveDown = new RolloverButton(GUIUtilities.loadIcon(""ArrowD.png""));
		moveDown.setToolTipText(jEdit.getProperty(""options.context.moveDown""));
		moveDown.addActionListener(actionHandler);
		buttons.add(moveDown);
		buttons.add(Box.createGlue());

		updateButtons();
		add(BorderLayout.SOUTH,buttons);
	}

	static class MenuItemCompare implements MiscUtilities.Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return MiscUtilities.compareStrings(
				((MenuItem)obj1).label,
				((MenuItem)obj2).label,
				true);
		}
	}

	protected void _save()
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < listModel.getSize(); i++)
		{
			if(i != 0)
				buf.append(' ');
			buf.append(((MenuItem)listModel.elementAt(i)).actionName);
		}
		jEdit.setProperty(""view.context"",buf.toString());
	}

	
	private DefaultListModel listModel;
	private JList list;
	private JButton add;
	private JButton remove;
	private JButton moveUp, moveDown;

	private void updateButtons()
	{
		int index = list.getSelectedIndex();
		remove.setEnabled(index != -1 && listModel.getSize() != 0);
		moveUp.setEnabled(index > 0);
		moveDown.setEnabled(index != -1 && index != listModel.getSize() - 1);
	}

	static class MenuItem
	{
		String actionName;
		String label;

		MenuItem(String actionName, String label)
		{
			this.actionName = actionName;
			this.label = GUIUtilities.prettifyMenuLabel(label);
		}

		public String toString()
		{
			return label;
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();

			if(source == add)
			{
				ContextAddDialog dialog = new ContextAddDialog(
					ContextOptionPane.this);
				String selection = dialog.getSelection();
				if(selection == null)
					return;

				int index = list.getSelectedIndex();
				if(index == -1)
					index = listModel.getSize();
				else
					index++;

				MenuItem menuItem;
				if(selection.equals(""-""))
					menuItem = new ContextOptionPane.MenuItem(""-"",""-"");
				else
				{
					menuItem = new ContextOptionPane.MenuItem(selection,
						jEdit.getAction(selection)
						.getLabel());
				}

				listModel.insertElementAt(menuItem,index);
				list.setSelectedIndex(index);
				list.ensureIndexIsVisible(index);
			}
			else if(source == remove)
			{
				int index = list.getSelectedIndex();
				listModel.removeElementAt(index);
				updateButtons();
			}
			else if(source == moveUp)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index-1);
				list.setSelectedIndex(index-1);
				list.ensureIndexIsVisible(index - 1);
			}
			else if(source == moveDown)
			{
				int index = list.getSelectedIndex();
				Object selected = list.getSelectedValue();
				listModel.removeElementAt(index);
				listModel.insertElementAt(selected,index+1);
				list.setSelectedIndex(index+1);
				list.ensureIndexIsVisible(index+1);
			}
		}
	}

	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateButtons();
		}
	}
}

class ContextAddDialog extends EnhancedDialog
{
	public ContextAddDialog(Component comp)
	{
		super(GUIUtilities.getParentDialog(comp),
			jEdit.getProperty(""options.context.add.title""),
			true);

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		ActionHandler actionHandler = new ActionHandler();
		ButtonGroup grp = new ButtonGroup();

		JPanel typePanel = new JPanel(new GridLayout(3,1,6,6));
		typePanel.setBorder(new EmptyBorder(0,0,6,0));
		typePanel.add(new JLabel(
			jEdit.getProperty(""options.context.add.caption"")));

		separator = new JRadioButton(jEdit.getProperty(""options.context""
			+ "".add.separator""));
		separator.addActionListener(actionHandler);
		grp.add(separator);
		typePanel.add(separator);

		action = new JRadioButton(jEdit.getProperty(""options.context""
			+ "".add.action""));
		action.addActionListener(actionHandler);
		grp.add(action);
		action.setSelected(true);
		typePanel.add(action);

		content.add(BorderLayout.NORTH,typePanel);

		JPanel actionPanel = new JPanel(new BorderLayout(6,6));

		ActionSet[] actionsList = jEdit.getActionSets();
		Vector vec = new Vector(actionsList.length);
		for(int i = 0; i < actionsList.length; i++)
		{
			ActionSet actionSet = actionsList[i];
			if(actionSet.getActionCount() != 0)
				vec.addElement(actionSet);
		}
		combo = new JComboBox(vec);
		combo.addActionListener(actionHandler);
		actionPanel.add(BorderLayout.NORTH,combo);

		list = new JList();
		list.setVisibleRowCount(8);
		list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		actionPanel.add(BorderLayout.CENTER,new JScrollPane(list));

		content.add(BorderLayout.CENTER,actionPanel);

		JPanel southPanel = new JPanel();
		southPanel.setLayout(new BoxLayout(southPanel,BoxLayout.X_AXIS));
		southPanel.setBorder(new EmptyBorder(12,0,0,0));
		southPanel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(actionHandler);
		getRootPane().setDefaultButton(ok);
		southPanel.add(ok);
		southPanel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(actionHandler);
		southPanel.add(cancel);
		southPanel.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,southPanel);

		updateList();

		pack();
		setLocationRelativeTo(GUIUtilities.getParentDialog(comp));
		show();
	}

	public void ok()
	{
		isOK = true;
		dispose();
	}

	public void cancel()
	{
		dispose();
	}

	public String getSelection()
	{
		if(!isOK)
			return null;

		if(separator.isSelected())
			return ""-"";
		else if(action.isSelected())
		{
			return ((ContextOptionPane.MenuItem)list.getSelectedValue())
				.actionName;
		}
		else
			throw new InternalError();
	}

	
	private boolean isOK;
	private JRadioButton separator, action;
	private JComboBox combo;
	private JList list;
	private JButton ok, cancel;

	private void updateList()
	{
		ActionSet actionSet = (ActionSet)combo.getSelectedItem();
		EditAction[] actions = actionSet.getActions();
		Vector listModel = new Vector(actions.length);

		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];
			String label = action.getLabel();
			if(label == null)
				continue;

			listModel.addElement(new ContextOptionPane.MenuItem(
				action.getName(),label));
		}

		MiscUtilities.quicksort(listModel,new ContextOptionPane.MenuItemCompare());

		list.setListData(listModel);
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source instanceof JRadioButton)
			{
				combo.setEnabled(action.isSelected());
				list.setEnabled(action.isSelected());
			}
			if(source == ok)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == combo)
				updateList();
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.options.PrintOptionPane,3,6,0,4,21,1,1,3,1,0.5,159,1.0,1,0.997019374,1.0,1,3,50.0,1,0.6667,0,"

package org.gjt.sp.jedit.options;


import javax.swing.*;
import org.gjt.sp.jedit.gui.FontSelector;
import org.gjt.sp.jedit.*;


public class PrintOptionPane extends AbstractOptionPane
{
	
	public PrintOptionPane()
	{
		super(""print"");
	} 

	
	protected void _init()
	{
		
		font = new FontSelector(jEdit.getFontProperty(""print.font""));
		addComponent(jEdit.getProperty(""options.print.font""),font);

		
		printHeader = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".header""));
		printHeader.setSelected(jEdit.getBooleanProperty(""print.header""));
		addComponent(printHeader);

		
		printFooter = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".footer""));
		printFooter.setSelected(jEdit.getBooleanProperty(""print.footer""));
		addComponent(printFooter);

		
		printLineNumbers = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".lineNumbers""));
		printLineNumbers.setSelected(jEdit.getBooleanProperty(""print.lineNumbers""));
		addComponent(printLineNumbers);

		
		color = new JCheckBox(jEdit.getProperty(""options.print""
			+ "".color""));
		color.setSelected(jEdit.getBooleanProperty(""print.color""));
		addComponent(color);

		
		String[] tabSizes = { ""2"", ""4"", ""8"" };
		tabSize = new JComboBox(tabSizes);
		tabSize.setEditable(true);
		tabSize.setSelectedItem(jEdit.getProperty(""print.tabSize""));
		addComponent(jEdit.getProperty(""options.print.tabSize""),tabSize);
	} 

	
	protected void _save()
	{
		jEdit.setFontProperty(""print.font"",font.getFont());
		jEdit.setBooleanProperty(""print.header"",printHeader.isSelected());
		jEdit.setBooleanProperty(""print.footer"",printFooter.isSelected());
		jEdit.setBooleanProperty(""print.lineNumbers"",printLineNumbers.isSelected());
		jEdit.setBooleanProperty(""print.color"",color.isSelected());
		jEdit.setProperty(""print.tabSize"",(String)tabSize.getSelectedItem());
	} 

	
	private FontSelector font;
	private JCheckBox printHeader;
	private JCheckBox printFooter;
	private JCheckBox printLineNumbers;
	private JCheckBox color;
	private JComboBox tabSize;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.io.UrlVFS,4,2,0,3,17,6,1,3,4,2.0,86,0.0,0,0.928571429,0.6,1,1,20.5,2,1.0,0,"

package org.gjt.sp.jedit.io;


import java.awt.Component;
import java.io.*;
import java.net.*;
import org.gjt.sp.util.Log;



public class UrlVFS extends VFS
{
	
	public UrlVFS()
	{
		super(""url"",READ_CAP | WRITE_CAP);
	} 

	
	public String constructPath(String parent, String path)
	{
		if(parent.endsWith(""/""))
			return parent + path;
		else
			return parent + '/' + path;
	} 

	
	public InputStream _createInputStream(Object session,
		String path, boolean ignoreErrors, Component comp)
		throws IOException
	{
		try
		{
			return new URL(path).openStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { mu.getMessage() };
			VFSManager.error(comp,path,""ioerror.badurl"",args);
			return null;
		}
	} 

	
	public OutputStream _createOutputStream(Object session, String path,
		Component comp) throws IOException
	{
		try
		{
			return new URL(path).openConnection()
				.getOutputStream();
		}
		catch(MalformedURLException mu)
		{
			Log.log(Log.ERROR,this,mu);
			String[] args = { mu.getMessage() };
			VFSManager.error(comp,path,""ioerror.badurl"",args);
			return null;
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.util.WorkThread,14,2,0,7,35,37,4,4,11,0.760683761,429,0.888888889,1,0.824324324,0.224489796,0,0,29.0,5,1.5,0,"

package org.gjt.sp.util;


public class WorkThread extends Thread
{
	public WorkThread(WorkThreadPool pool, ThreadGroup group, String name)
	{
		super(group, name);
		
		
		setPriority(4);

		this.pool = pool;
	}

	
	public void setAbortable(boolean abortable)
	{
		synchronized(abortLock)
		{
			this.abortable = abortable;
			if(aborted)
				stop(new Abort());
		}
	}

	
	public boolean isRequestRunning()
	{
		return requestRunning;
	}

	
	public String getStatus()
	{
		return status;
	}

	
	public void setStatus(String status)
	{
		this.status = status;
		pool.fireProgressChanged(this);
	}

	
	public int getProgressValue()
	{
		return progressValue;
	}

	
	public void setProgressValue(int progressValue)
	{
		this.progressValue = progressValue;
		pool.fireProgressChanged(this);
	}

	
	public int getProgressMaximum()
	{
		return progressMaximum;
	}

	
	public void setProgressMaximum(int progressMaximum)
	{
		this.progressMaximum = progressMaximum;
		pool.fireProgressChanged(this);
	}

	
	public void abortCurrentRequest()
	{
		synchronized(abortLock)
		{
			if(abortable && !aborted)
				stop(new Abort());
			aborted = true;
		}
	}

	public void run()
	{
		Log.log(Log.DEBUG,this,""Work request thread starting ["" + getName() + ""]"");

		for(;;)
		{
			doRequests();
		}
	}

	
	private WorkThreadPool pool;
	private Object abortLock = new Object();
	private boolean requestRunning;
	private boolean abortable;
	private boolean aborted;
	private String status;
	private int progressValue;
	private int progressMaximum;

	private void doRequests()
	{
		WorkThreadPool.Request request;
		for(;;)
		{
			request = pool.getNextRequest();
			if(request == null)
				break;
			else
			{
				requestRunning = true;
				pool.fireStatusChanged(this);
				doRequest(request);
				requestRunning = false;
			}
		}

		pool.fireStatusChanged(this);

		synchronized(pool.waitForAllLock)
		{
			
			pool.waitForAllLock.notifyAll();
		}

		synchronized(pool.lock)
		{
			
			try
			{
				pool.lock.wait();
			}
			catch(InterruptedException ie)
			{
				Log.log(Log.ERROR,this,ie);
			}
		}
	}

	private void doRequest(WorkThreadPool.Request request)
	{
		Log.log(Log.DEBUG,WorkThread.class,""Running in work thread: "" + request);

		try
		{
			request.run.run();
		}
		catch(Abort a)
		{
			Log.log(Log.ERROR,WorkThread.class,""Unhandled abort"");
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception ""
				+ ""in work thread:"");
			Log.log(Log.ERROR,WorkThread.class,t);
		}
		finally
		{
			synchronized(abortLock)
			{
				aborted = abortable = false;
			}
			status = null;
			progressValue = progressMaximum = 0;
			pool.requestDone();
			pool.fireStatusChanged(this);
		}
	}

	public static class Abort extends Error
	{
		public Abort()
		{
			super(""Work request aborted"");
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.Abbrevs,18,1,0,13,102,43,4,11,9,0.661764706,785,0.875,0,0.0,0.104575163,0,0,42.16666667,18,3.1111,0,"

package org.gjt.sp.jedit;


import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.gui.AddAbbrevDialog;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class Abbrevs
{
	
	
	public static boolean getExpandOnInput()
	{
		return expandOnInput;
	} 

	
	
	public static void setExpandOnInput(boolean expandOnInput)
	{
		Abbrevs.expandOnInput = expandOnInput;
	} 

	
	
	public static boolean expandAbbrev(View view, boolean add)
	{
		
		Buffer buffer = view.getBuffer();
		JEditTextArea textArea = view.getTextArea();
		if(!buffer.isEditable())
		{
			view.getToolkit().beep();
			return false;
		}

		int line = textArea.getCaretLine();
		int lineStart = buffer.getLineStartOffset(line);
		int caret = textArea.getCaretPosition();

		String lineText = buffer.getLineText(line);
		if(lineText.length() == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		}

		int pos = caret - lineStart;
		if(pos == 0)
		{
			if(add)
				view.getToolkit().beep();
			return false;
		} 

		
		pp.removeAllElements();

		int wordStart;
		String abbrev;

		
		if(lineText.charAt(pos-1) == '#')
		{
			wordStart = lineText.indexOf('#');
			wordStart = TextUtilities.findWordStart(lineText,wordStart,
				buffer.getStringProperty(""noWordSep"") + '#');

			abbrev = lineText.substring(wordStart,pos - 1);

			
			

			int lastIndex = 0;
			for(int i = 0; i < abbrev.length(); i++)
			{
				if(abbrev.charAt(i) == '#')
				{
					pp.addElement(abbrev.substring(lastIndex,i));
					lastIndex = i + 1;
				}
			}

			pp.addElement(abbrev.substring(lastIndex));

			
			abbrev = (String)pp.elementAt(0);
			pp.removeElementAt(0);
		} 
		
		else
		{
			wordStart = TextUtilities.findWordStart(lineText,pos - 1,
				buffer.getStringProperty(""noWordSep""));

			abbrev = lineText.substring(wordStart,pos);
		} 

		Expansion expand = expandAbbrev(buffer.getMode().getName(),
			abbrev,(buffer.getBooleanProperty(""noTabs"") ?
			buffer.getTabSize() : 0),pp);

		
		if(expand == null)
		{
			if(add)
				new AddAbbrevDialog(view,abbrev);

			return false;
		} 
		
		else
		{
			buffer.beginCompoundEdit();
			try
			{
				
				lineText = buffer.getText(lineStart,wordStart);
				int leadingIndent = MiscUtilities.getLeadingWhiteSpaceWidth(
					lineText,buffer.getTabSize());

				buffer.remove(lineStart + wordStart,pos - wordStart);
				buffer.insert(lineStart + wordStart,expand.text);
				if(expand.caretPosition != -1)
				{
					textArea.setCaretPosition(lineStart + wordStart
						+ expand.caretPosition);
				}

				String whiteSpace = MiscUtilities.createWhiteSpace(
					leadingIndent,buffer.getBooleanProperty(""noTabs"")
					? 0 : buffer.getTabSize());

				
				
				for(int i = line + 1; i <= line + expand.lineCount; i++)
				{
					buffer.insert(buffer.getLineStartOffset(i),
						whiteSpace);
				}
			}
			finally
			{
				buffer.endCompoundEdit();
			}

			if(expand.posParamCount != pp.size())
			{
				view.getStatus().setMessageAndClear(
					jEdit.getProperty(
					""view.status.incomplete-abbrev"",
					new Integer[] { new Integer(pp.size()),
					new Integer(expand.posParamCount) }));
			}

			return true;
		} 
	} 

	
	
	public static Hashtable getGlobalAbbrevs()
	{
		if(!loaded)
			load();

		return globalAbbrevs;
	} 

	
	
	public static void setGlobalAbbrevs(Hashtable globalAbbrevs)
	{
		abbrevsChanged = true;
		Abbrevs.globalAbbrevs = globalAbbrevs;
	} 

	
	
	public static Hashtable getModeAbbrevs()
	{
		if(!loaded)
			load();

		return modes;
	} 

	
	
	public static void setModeAbbrevs(Hashtable modes)
	{
		abbrevsChanged = true;
		Abbrevs.modes = modes;
	} 

	
	
	public static void addGlobalAbbrev(String abbrev, String expansion)
	{
		if(!loaded)
			load();

		globalAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	} 

	
	
	public static void addModeAbbrev(String mode, String abbrev, String expansion)
	{
		if(!loaded)
			load();

		Hashtable modeAbbrevs = (Hashtable)modes.get(mode);
		if(modeAbbrevs == null)
		{
			modeAbbrevs = new Hashtable();
			modes.put(mode,modeAbbrevs);
		}
		modeAbbrevs.put(abbrev,expansion);
		abbrevsChanged = true;
	} 

	
	static void save()
	{
		jEdit.setBooleanProperty(""view.expandOnInput"",expandOnInput);

		String settings = jEdit.getSettingsDirectory();
		if(abbrevsChanged && settings != null)
		{
			File file1 = new File(MiscUtilities.constructPath(settings,""#abbrevs#save#""));
			File file2 = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			if(file2.exists() && file2.lastModified() != abbrevsModTime)
			{
				Log.log(Log.WARNING,Abbrevs.class,file2 + "" changed on disk;""
					+ "" will not save abbrevs"");
			}
			else
			{
				jEdit.backupSettingsFile(file2);

				try
				{
					saveAbbrevs(new FileWriter(file1));
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR,Abbrevs.class,""Error while saving "" + file1);
					Log.log(Log.ERROR,Abbrevs.class,e);
				}
				file2.delete();
				file1.renameTo(file2);
				abbrevsModTime = file2.lastModified();
			}
		}
	} 

	

	
	private static boolean loaded;
	private static boolean abbrevsChanged;
	private static long abbrevsModTime;
	private static boolean expandOnInput;
	private static Hashtable globalAbbrevs;
	private static Hashtable modes;
	private static Vector pp = new Vector();
	

	private Abbrevs() {}

	static
	{
		expandOnInput = jEdit.getBooleanProperty(""view.expandOnInput"");
	}

	
	private static void load()
	{
		globalAbbrevs = new Hashtable();
		modes = new Hashtable();

		String settings = jEdit.getSettingsDirectory();
		if(settings != null)
		{
			File file = new File(MiscUtilities.constructPath(settings,""abbrevs""));
			abbrevsModTime = file.lastModified();

			try
			{
				loadAbbrevs(new FileReader(file));
				loaded = true;
			}
			catch(FileNotFoundException fnf)
			{
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading "" + file);
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
		}

		
		if(!loaded)
		{
			try
			{
				loadAbbrevs(new InputStreamReader(Abbrevs.class
					.getResourceAsStream(""default.abbrevs"")));
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,Abbrevs.class,""Error while loading default.abbrevs"");
				Log.log(Log.ERROR,Abbrevs.class,e);
			}
			loaded = true;
		}
	} 

	
	private static Expansion expandAbbrev(String mode, String abbrev,
		int softTabSize, Vector pp)
	{
		if(!loaded)
			load();

		
		String expand = null;
		Hashtable modeAbbrevs = (Hashtable)modes.get(mode);
		if(modeAbbrevs != null)
			expand = (String)modeAbbrevs.get(abbrev);

		if(expand == null)
			expand = (String)globalAbbrevs.get(abbrev);

		if(expand == null)
			return null;
		else
			return new Expansion(expand,softTabSize,pp);
	} 

	
	private static void loadAbbrevs(Reader _in) throws Exception
	{
		BufferedReader in = new BufferedReader(_in);

		Hashtable currentAbbrevs = null;

		String line;
		while((line = in.readLine()) != null)
		{
			if(line.length() == 0)
				continue;
			else if(line.startsWith(""["") && line.indexOf('|') == -1)
			{
				if(line.equals(""[global]""))
					currentAbbrevs = globalAbbrevs;
				else
				{
					String mode = line.substring(1,
						line.length() - 1);
					currentAbbrevs = (Hashtable)modes.get(mode);
					if(currentAbbrevs == null)
					{
						currentAbbrevs = new Hashtable();
						modes.put(mode,currentAbbrevs);
					}
				}
			}
			else
			{
				int index = line.indexOf('|');
				currentAbbrevs.put(line.substring(0,index),
					line.substring(index + 1));
			}
		}

		in.close();
	} 

	
	private static void saveAbbrevs(Writer _out) throws Exception
	{
		BufferedWriter out = new BufferedWriter(_out);
		String lineSep = System.getProperty(""line.separator"");

		
		out.write(""[global]"");
		out.write(lineSep);

		saveAbbrevs(out,globalAbbrevs);

		
		Enumeration keys = modes.keys();
		Enumeration values = modes.elements();
		while(keys.hasMoreElements())
		{
			out.write('[');
			out.write((String)keys.nextElement());
			out.write(']');
			out.write(lineSep);
			saveAbbrevs(out,(Hashtable)values.nextElement());
		}

		out.close();
	} 

	
	private static void saveAbbrevs(Writer out, Hashtable abbrevs)
		throws Exception
	{
		String lineSep = System.getProperty(""line.separator"");

		Enumeration keys = abbrevs.keys();
		Enumeration values = abbrevs.elements();
		while(keys.hasMoreElements())
		{
			String abbrev = (String)keys.nextElement();
			out.write(abbrev);
			out.write('|');
			out.write(values.nextElement().toString());
			out.write(lineSep);
		}
	} 

	

	
	static class Expansion
	{
		String text;
		int caretPosition = -1;
		int lineCount;

		
		int posParamCount;

		
		Expansion(String text, int softTabSize, Vector pp)
		{
			StringBuffer buf = new StringBuffer();
			boolean backslash = false;

			for(int i = 0; i < text.length(); i++)
			{
				char ch = text.charAt(i);
				
				if(backslash)
				{
					backslash = false;

					if(ch == '|')
						caretPosition = buf.length();
					else if(ch == 'n')
					{
						buf.append('\n');
						lineCount++;
					}
					else if(ch == 't')
					{
						if(softTabSize == 0)
							buf.append('\t');
						else
						{
							for(int j = 0; j < softTabSize; j++)
								buf.append(' ');
						}
					}
					else
						buf.append(ch);
				}
				else if(ch == '\\')
					backslash = true;
				
				
				else if(ch == '$')
				{
					if(i != text.length() - 1)
					{
						ch = text.charAt(i + 1);
						if(Character.isDigit(ch) && ch != '0')
						{
							i++;

							int pos = ch - '0';
							posParamCount = Math.max(pos,posParamCount);
							
							
							if(pos <= pp.size())
								buf.append(pp.elementAt(pos - 1));
						}
						else
						{
							
							
							buf.append('$');
						}
					}
					else
						buf.append('$'); 
				} 
				else
					buf.append(ch);
			}

			this.text = buf.toString();
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.XModeHandler,16,2,0,15,77,78,1,15,8,0.875268817,1296,1.0,5,0.464285714,0.265625,1,3,78.0625,35,6.0,1,"

package org.gjt.sp.jedit.syntax;


import com.microstar.xml.*;
import gnu.regexp.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.search.RESearchMatcher;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class XModeHandler extends HandlerBase
{
	
	public XModeHandler (XmlParser parser, String modeName, String path)
	{
		this.modeName = modeName;
		this.parser = parser;
		this.path = path;
		stateStack = new Stack();

		
		lastNoWordSep = ""_"";
	} 

	
	public Object resolveEntity(String publicId, String systemId)
	{
		if(""xmode.dtd"".equals(systemId))
		{
			
			
			
			return new StringReader(""<!-- -->"");

			
		}

		return null;
	} 

	
	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();

		if (aname == ""NAME"")
		{
			propName = value;
		}
		else if (aname == ""VALUE"")
		{
			propValue = value;
		}
		else if (aname == ""TYPE"")
		{
			lastTokenID = Token.stringToToken(value);
			if(lastTokenID == -1)
				error(""token-invalid"",value);
		}
		else if (aname == ""AT_LINE_START"")
		{
			lastAtLineStart = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""AT_WHITESPACE_END"")
		{
			lastAtWhitespaceEnd = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""AT_WORD_START"")
		{
			lastAtWordStart = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""NO_LINE_BREAK"")
		{
			lastNoLineBreak = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""NO_WORD_BREAK"")
		{
			lastNoWordBreak = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""EXCLUDE_MATCH"")
		{
			lastExcludeMatch = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""IGNORE_CASE"")
		{
			lastIgnoreCase = (isSpecified) ? (value.equals(""TRUE"")) :
				true;
		}
		else if (aname == ""HIGHLIGHT_DIGITS"")
		{
			lastHighlightDigits = (isSpecified) ? (value.equals(""TRUE"")) :
				false;
		}
		else if (aname == ""DIGIT_RE"")
		{
			lastDigitRE = value;
		}
		else if (aname == ""NO_WORD_SEP"")
		{
			if(isSpecified)
				lastNoWordSep = value;
		}
		else if (aname == ""AT_CHAR"")
		{
			try
			{
				if (isSpecified) termChar =
					Integer.parseInt(value);
			}
			catch (NumberFormatException e)
			{
				error(""termchar-invalid"",value);
				termChar = -1;
			}
		}
		else if (aname == ""ESCAPE"")
		{
			lastEscape = value;
		}
		else if (aname == ""SET"")
		{
			lastSetName = value;
		}
		else if (aname == ""DELEGATE"")
		{
			lastDelegateSet = value;
			if (lastDelegateSet != null
				&& lastDelegateSet.indexOf(""::"") == -1)
			{
				lastDelegateSet = modeName + ""::"" + lastDelegateSet;
			}
		}
		else if (aname == ""DEFAULT"")
		{
			lastDefaultID = Token.stringToToken(value);
			if(lastDefaultID == -1)
			{
				error(""token-invalid"",value);
				lastDefaultID = Token.NULL;
			}
		}
		else if (aname == ""HASH_CHAR"")
		{
			if(value.length() != 1)
			{
				error(""hash-char-invalid"",value);
				lastDefaultID = Token.NULL;
			}
			else
				lastHashChar = value.charAt(0);
		}
	} 

	
	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if (""MODE"".equalsIgnoreCase(name)) return;

		error(""doctype-invalid"",name);
	} 

	
	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);

		if (tag == ""EOL_SPAN"" ||
			tag == ""EOL_SPAN_REGEXP"" ||
			tag == ""MARK_PREVIOUS"" ||
			tag == ""MARK_FOLLOWING"" ||
			tag == ""SEQ"" ||
			tag == ""SEQ_REGEXP"" ||
			tag == ""BEGIN""
		)
		{
			lastStart = text;
		}
		else if (tag == ""END"")
		{
			lastEnd = text;
		}
		else
		{
			lastKeyword = text;
		}
	} 

	
	public void startElement (String tag)
	{
		tag = pushElement(tag);

		if (tag == ""WHITESPACE"")
		{
			Log.log(Log.WARNING,this,path + "": WHITESPACE rule ""
				+ ""no longer needed"");
		}
		else if (tag == ""MODE"")
		{
			mode = jEdit.getMode(modeName);
			if (mode == null)
			{
				mode = new Mode(modeName);
				jEdit.addMode(mode);
			}
		}
		else if (tag == ""KEYWORDS"")
		{
			keywords = new KeywordMap(rules.getIgnoreCase());
		}
		else if (tag == ""RULES"")
		{
			rules = new ParserRuleSet(lastSetName,mode);
			rules.setIgnoreCase(lastIgnoreCase);
			rules.setHighlightDigits(lastHighlightDigits);
			if(lastDigitRE != null)
			{
				try
				{
					rules.setDigitRegexp(new RE(lastDigitRE,
						lastIgnoreCase
						? RE.REG_ICASE : 0,
						RESearchMatcher.RE_SYNTAX_JEDIT));
				}
				catch(REException e)
				{
					error(""regexp"",e);
				}
			}

			if(lastEscape != null)
				rules.setEscapeRule(ParserRule.createEscapeRule(lastEscape));
			rules.setDefault(lastDefaultID);
			rules.setNoWordSep(lastNoWordSep);
		}
	} 

	
	public void endElement (String name)
	{
		if (name == null) return;

		String tag = popElement();

		if (name.equalsIgnoreCase(tag))
		{
			
			if (tag == ""MODE"")
			{
				
				
				mode.setTokenMarker(marker);
			} 
			
			else if (tag == ""PROPERTY"")
			{
				props.put(propName,propValue);
			} 
			
			else if (tag == ""PROPS"")
			{
				if(peekElement().equals(""RULES""))
					rules.setProperties(props);
				else
					mode.setProperties(props);

				props = new Hashtable();
			} 
			
			else if (tag == ""RULES"")
			{
				rules.setKeywords(keywords);
				marker.addRuleSet(lastSetName, rules);
				keywords = null;
				lastSetName = null;
				lastEscape = null;
				lastIgnoreCase = true;
				lastHighlightDigits = false;
				lastDigitRE = null;
				lastDefaultID = Token.NULL;
				lastNoWordSep = ""_"";
				rules = null;
			} 
			
			else if (tag == ""TERMINATE"")
			{
				rules.setTerminateChar(termChar);
				termChar = -1;
			} 
			
			else if (tag == ""SEQ"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""SEQ"");
					return;
				}

				rules.addRule(ParserRule.createSequenceRule(
					lastStart,lastDelegateSet,lastTokenID,
					lastAtLineStart,lastAtWhitespaceEnd,
					lastAtWordStart));
				lastStart = null;
				lastEnd = null;
				lastDelegateSet = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastAtWordStart = false;
				lastAtWhitespaceEnd = false;
			} 
			
			else if (tag == ""SEQ_REGEXP"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""SEQ_REGEXP"");
					return;
				}

				try
				{
					rules.addRule(ParserRule.createRegexpSequenceRule(
						lastHashChar,
						lastStart,lastDelegateSet,lastTokenID,
						lastAtLineStart,lastAtWhitespaceEnd,
						lastAtWordStart,lastIgnoreCase));
				}
				catch(REException re)
				{
					error(""regexp"",re);
				}

				lastHashChar = '\0';
				lastStart = null;
				lastEnd = null;
				lastDelegateSet = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastAtWordStart = false;
				lastAtWhitespaceEnd = false;
			} 
			
			else if (tag == ""SPAN"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""START"");
					return;
				}

				if(lastEnd == null)
				{
					error(""empty-tag"",""END"");
					return;
				}

				rules.addRule(ParserRule
					.createSpanRule(
					lastStart,lastEnd,
					lastDelegateSet,
					lastTokenID,lastNoLineBreak,
					lastAtLineStart,
					lastAtWhitespaceEnd,
					lastAtWordStart,
					lastExcludeMatch,
					lastNoWordBreak));

				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastAtWordStart = false;
				lastNoLineBreak = false;
				lastAtWhitespaceEnd = false;
				lastExcludeMatch = false;
				lastNoWordBreak = false;
				lastDelegateSet = null;
			} 
			
			else if (tag == ""SPAN_REGEXP"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""START"");
					return;
				}

				if(lastEnd == null)
				{
					error(""empty-tag"",""END"");
					return;
				}

				try
				{
					rules.addRule(ParserRule
						.createRegexpSpanRule(
						lastHashChar,
						lastStart,lastEnd,
						lastDelegateSet,
						lastTokenID,lastNoLineBreak,
						lastAtLineStart,
						lastAtWhitespaceEnd,
						lastAtWordStart,
						lastExcludeMatch,
						lastNoWordBreak,
						lastIgnoreCase));
				}
				catch(REException re)
				{
					error(""regexp"",re);
				}

				lastHashChar = '\0';
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastAtWordStart = false;
				lastNoLineBreak = false;
				lastAtWhitespaceEnd = false;
				lastExcludeMatch = false;
				lastNoWordBreak = false;
				lastDelegateSet = null;
			} 
			
			else if (tag == ""EOL_SPAN"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""EOL_SPAN"");
					return;
				}

				rules.addRule(ParserRule.createEOLSpanRule(
					lastStart,lastDelegateSet,lastTokenID,
					lastAtLineStart,lastAtWhitespaceEnd,
					lastAtWordStart,lastExcludeMatch));

				lastStart = null;
				lastEnd = null;
				lastDelegateSet = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastAtWordStart = false;
				lastAtWhitespaceEnd = false;
				lastExcludeMatch = false;
			} 
			
			else if (tag == ""EOL_SPAN_REGEXP"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""EOL_SPAN_REGEXP"");
					return;
				}

				try
				{
					rules.addRule(ParserRule.createRegexpEOLSpanRule(
						lastHashChar,lastStart,lastDelegateSet,
						lastTokenID,lastAtLineStart,
						lastAtWhitespaceEnd,lastAtWordStart,
						lastExcludeMatch,lastIgnoreCase));
				}
				catch(REException re)
				{
					error(""regexp"",re);
				}

				lastHashChar = '\0';
				lastStart = null;
				lastEnd = null;
				lastDelegateSet = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastAtWordStart = false;
				lastAtWhitespaceEnd = false;
				lastExcludeMatch = false;
			} 
			
			else if (tag == ""MARK_FOLLOWING"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""MARK_FOLLOWING"");
					return;
				}

				rules.addRule(ParserRule
					.createMarkFollowingRule(lastStart,
					lastTokenID,lastAtLineStart,
					lastAtWhitespaceEnd,lastAtWordStart,
					lastExcludeMatch));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastAtWordStart = false;
				lastAtWhitespaceEnd = false;
				lastExcludeMatch = false;
			} 
			
			else if (tag == ""MARK_PREVIOUS"")
			{
				if(lastStart == null)
				{
					error(""empty-tag"",""MARK_PREVIOUS"");
					return;
				}

				rules.addRule(ParserRule
					.createMarkPreviousRule(lastStart,
					lastTokenID,lastAtLineStart,
					lastAtWhitespaceEnd,lastAtWordStart,
					lastExcludeMatch));
				lastStart = null;
				lastEnd = null;
				lastTokenID = Token.NULL;
				lastAtLineStart = false;
				lastAtWordStart = false;
				lastAtWhitespaceEnd = false;
				lastExcludeMatch = false;
			} 
			
			else
			{
				byte token = Token.stringToToken(tag);
				if(token != -1)
					addKeyword(lastKeyword,token);
			} 
		}
		else
		{
			
			throw new InternalError();
		}
	} 

	
	public void startDocument()
	{
		marker = new TokenMarker();
		marker.setName(modeName);
		props = new Hashtable();

		pushElement(null);
	} 

	

	
	private XmlParser parser;
	private String modeName;
	private String path;

	private TokenMarker marker;
	private KeywordMap keywords;
	private Mode mode;
	private Stack stateStack;
	private String propName;
	private String propValue;
	private Hashtable props;
	private String lastStart;
	private String lastEnd;
	private String lastKeyword;
	private String lastSetName;
	private String lastEscape;
	private String lastDelegateSet;
	private String lastNoWordSep;
	private ParserRuleSet rules;
	private byte lastDefaultID = Token.NULL;
	private byte lastTokenID;
	private int termChar = -1;
	private boolean lastNoLineBreak;
	private boolean lastNoWordBreak;
	private boolean lastAtLineStart;
	private boolean lastAtWhitespaceEnd;
	private boolean lastAtWordStart;
	private boolean lastExcludeMatch;
	private boolean lastIgnoreCase = true;
	private boolean lastHighlightDigits;
	private String lastDigitRE;
	private char lastHashChar;
	

	
	private void addKeyword(String k, byte id)
	{
		if(k == null)
		{
			error(""empty-keyword"");
			return;
		}

		if (keywords == null) return;
		keywords.add(k,id);
	} 

	
	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();

		stateStack.push(name);

		return name;
	} 

	
	private String peekElement()
	{
		return (String) stateStack.peek();
	} 

	
	private String popElement()
	{
		return (String) stateStack.pop();
	} 

	
	private void error(String msg)
	{
		_error(jEdit.getProperty(""xmode-error."" + msg));
	} 

	
	private void error(String msg, String subst)
	{
		_error(jEdit.getProperty(""xmode-error."" + msg,new String[] { subst }));
	} 

	
	private void error(String msg, Throwable t)
	{
		_error(jEdit.getProperty(""xmode-error."" + msg,new String[] { t.toString() }));
		Log.log(Log.ERROR,this,t);
	} 

	
	private void _error(String msg)
	{
		Object[] args = { path, new Integer(parser.getLineNumber()),
			new Integer(parser.getColumnNumber()), msg };

		GUIUtilities.error(null,""xmode-error"",args);
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.FloatingWindowContainer,9,6,0,6,26,34,3,6,9,0.9375,91,1.0,2,0.987748851,0.592592593,3,3,8.888888889,1,0.8889,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.*;
import org.gjt.sp.jedit.*;



public class FloatingWindowContainer extends JFrame implements DockableWindowContainer
{
	
	public FloatingWindowContainer(DockableWindowManager dockableWindowManager)
	{
		this.dockableWindowManager = dockableWindowManager;
		setIconImage(GUIUtilities.getPluginIcon());
		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
	} 

	
	public void register(DockableWindowManager.Entry entry)
	{
		this.entry = entry;
		setTitle(entry.title);

		getContentPane().add(BorderLayout.CENTER,entry.win);

		pack();
		GUIUtilities.loadGeometry(this,entry.factory.name);
		show();
	} 

	
	public void add(DockableWindowManager.Entry entry)
	{
	} 

	
	public void save(DockableWindowManager.Entry entry)
	{
		GUIUtilities.saveGeometry(this,entry.factory.name);
	} 

	
	public void remove(DockableWindowManager.Entry entry)
	{
		super.dispose();
	} 

	
	public void show(final DockableWindowManager.Entry entry)
	{
		toFront();
		requestFocus();
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				entry.win.requestDefaultFocus();
			}
		});
	} 

	
	public boolean isVisible(DockableWindowManager.Entry entry)
	{
		return true;
	} 

	
	public void dispose()
	{
		save(entry);
		entry.container = null;
		entry.win = null;
		super.dispose();
	} 

	
	public Dimension getMinimumSize()
	{
		return new Dimension(0,0);
	} 

	
	private DockableWindowManager dockableWindowManager;
	private DockableWindowManager.Entry entry;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.BufferChangeListener,4,1,0,4,4,6,4,1,4,2.0,4,0.0,0,0.0,0.916666667,0,0,0.0,1,1.0,2,"

package org.gjt.sp.jedit.buffer;

import org.gjt.sp.jedit.Buffer;


public interface BufferChangeListener
{
	
	
	void foldLevelChanged(Buffer buffer, int startLine, int endLine);
	

	
	
	void contentInserted(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void contentRemoved(Buffer buffer, int startLine, int offset,
		int numLines, int length);
	

	
	
	void transactionComplete(Buffer buffer);
	
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.TokenMarker,13,1,0,15,65,30,5,13,7,0.796875,1525,0.9375,4,0.0,0.215384615,0,0,115.0769231,42,8.8462,2,"

package org.gjt.sp.jedit.syntax;


import gnu.regexp.*;
import javax.swing.text.Segment;
import java.util.*;
import org.gjt.sp.jedit.search.CharIndexedSegment;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class TokenMarker
{
	
	public TokenMarker()
	{
		ruleSets = new Hashtable(64);
	} 

	
	public String getName()
	{
		return name;
	} 

	
	public void setName(String name)
	{
		if (name == null)
			throw new NullPointerException();

		this.name = name;
		rulePfx = name.concat(""::"");
	} 

	
	public void addRuleSet(String setName, ParserRuleSet rules)
	{
		if (rules == null)
			return;

		if (setName == null)
			setName = ""MAIN"";

		ruleSets.put(rulePfx.concat(setName), rules);

		if (setName.equals(""MAIN""))
			mainRuleSet = rules;
	} 

	
	public ParserRuleSet getMainRuleSet()
	{
		return mainRuleSet;
	} 

	
	public ParserRuleSet getRuleSet(String setName)
	{
		ParserRuleSet rules;

		rules = (ParserRuleSet) ruleSets.get(setName);

		if (rules == null && !setName.startsWith(rulePfx))
		{
			int delim = setName.indexOf(""::"");
			if(delim == -1)
			{
				byte id = Token.stringToToken(setName);
				rules = ParserRuleSet.getStandardRuleSet(id);
			}
			else
			{
				String modeName = setName.substring(0, delim);

				Mode mode = jEdit.getMode(modeName);
				if(mode == null)
				{
					Log.log(Log.ERROR,TokenMarker.class,
						""Unknown edit mode: "" + modeName);
					rules = null;
				}
				else
				{
					TokenMarker marker = mode.getTokenMarker();
					rules = marker.getRuleSet(setName);
				}
			}

			
			
			ruleSets.put(setName, rules);
		}

		if (rules == null)
		{
			Log.log(Log.ERROR,this,""Unresolved delegate target: "" + setName);
			return ParserRuleSet.getStandardRuleSet(Token.INVALID);
		}
		else
			return rules;
	} 

	
	
	public LineContext markTokens(LineContext prevContext,
		TokenHandler tokenHandler, Segment line)
	{
		
		
		
		this.tokenHandler = tokenHandler;
		this.line = line;

		lastOffset = line.offset;
		lineLength = line.count + line.offset;

		context = new LineContext();

		if(prevContext == null)
			context.rules = getMainRuleSet();
		else
		{
			context.parent = prevContext.parent;
			context.inRule = prevContext.inRule;
			context.rules = prevContext.rules;
		}

		keywords = context.rules.getKeywords();
		escaped = false;

		seenWhitespaceEnd = false;
		whitespaceEnd = line.offset;
		

		
		ParserRule rule;
		int terminateChar = context.rules.getTerminateChar();
		boolean terminated = false;

main_loop:	for(pos = line.offset; pos < lineLength; pos++)
		{
			
			if(terminateChar >= 0 && pos - line.offset >= terminateChar
				&& !terminated)
			{
				terminated = true;
				context = new LineContext(ParserRuleSet
					.getStandardRuleSet(context.rules
					.getDefault()),context);
				keywords = context.rules.getKeywords();
			} 

			
			if(context.parent != null)
			{
				rule = context.parent.inRule;
				if(rule != null)
				{
					if(checkDelegateEnd(rule))
					{
						seenWhitespaceEnd = true;
						continue main_loop;
					}
				}
			} 

			
			char ch = line.array[pos];

			rule = context.rules.getRules(ch);
			while(rule != null)
			{
				
				if (handleRule(rule,false))
				{
					seenWhitespaceEnd = true;
					continue main_loop;
				}
	
				rule = rule.next;
			} 

			
			if(Character.isWhitespace(ch))
			{
				if(!seenWhitespaceEnd)
					whitespaceEnd = pos + 1;

				if(context.inRule != null)
					handleRule(context.inRule,true);

				handleNoWordBreak();

				markKeyword(false);

				if(lastOffset != pos)
				{
					tokenHandler.handleToken(
						context.rules.getDefault(),
						lastOffset - line.offset,
						pos - lastOffset,
						context);
				}

				tokenHandler.handleToken(
					(ch == '\t' ? Token.TAB
					: Token.WHITESPACE),pos - line.offset,1,
					context);
				lastOffset = pos + 1;

				escaped = false;
			}
			else
			{
				if(keywords != null || context.rules.getRuleCount() != 0)
				{
					String noWordSep = context.rules.getNoWordSep();

					if(!Character.isLetterOrDigit(ch)
						&& noWordSep.indexOf(ch) == -1)
					{
						if(context.inRule != null)
							handleRule(context.inRule,true);

						handleNoWordBreak();

						markKeyword(true);

						tokenHandler.handleToken(
							context.rules.getDefault(),
							lastOffset - line.offset,1,
							context);
						lastOffset = pos + 1;
					}
				}

				seenWhitespaceEnd = true;
				escaped = false;
			} 
		} 

		
		pos = lineLength;

		if(context.inRule != null)
			handleRule(context.inRule,true);

		handleNoWordBreak();
		markKeyword(true);

		if(context.parent != null)
		{
			rule = context.parent.inRule;
			if((rule != null && (context.parent.inRule.action
				& ParserRule.NO_LINE_BREAK) == ParserRule.NO_LINE_BREAK)
				|| terminated)
			{
				context = context.parent;
				keywords = context.rules.getKeywords();
				context.inRule = null;
			}
		} 

		tokenHandler.handleToken(Token.END,pos - line.offset,0,context);

		return context.intern();
	} 

	

	
	private Hashtable ruleSets;
	private String name;
	private String rulePfx;
	private ParserRuleSet mainRuleSet;

	
	
	private TokenHandler tokenHandler;
	private Segment line;
	private LineContext context;
	private KeywordMap keywords;
	private Segment pattern = new Segment();
	private int lastOffset;
	private int lineLength;
	private int pos;
	private boolean escaped;

	private int whitespaceEnd;
	private boolean seenWhitespaceEnd;
	

	
	private boolean checkDelegateEnd(ParserRule rule)
	{
		if(rule.end == null)
			return false;

		LineContext tempContext = context;
		context = context.parent;
		keywords = context.rules.getKeywords();
		boolean tempEscaped = escaped;
		boolean b = handleRule(rule,true);
		context = tempContext;
		keywords = context.rules.getKeywords();

		if(b && !tempEscaped)
		{
			if(context.inRule != null)
				handleRule(context.inRule,true);

			markKeyword(true);

			context = (LineContext)context.parent.clone();

			tokenHandler.handleToken(
				(context.inRule.action & ParserRule.EXCLUDE_MATCH)
				== ParserRule.EXCLUDE_MATCH
				? context.rules.getDefault()
				: context.inRule.token,
				pos - line.offset,pattern.count,context);

			keywords = context.rules.getKeywords();
			context.inRule = null;
			lastOffset = pos + pattern.count;

			
			pos += (pattern.count - 1);

			return true;
		}

		
		rule = context.parent.rules.getEscapeRule();
		if(rule != null && handleRule(rule,false))
			return true;

		return false;
	} 

	
	
	private boolean handleRule(ParserRule checkRule, boolean end)
	{
		
		if(!end)
		{
			if(Character.toUpperCase(checkRule.hashChar)
				!= Character.toUpperCase(line.array[pos]))
			{
				return false;
			}

			if((checkRule.action & ParserRule.AT_LINE_START)
				== ParserRule.AT_LINE_START)
			{
				if((((checkRule.action & ParserRule.MARK_PREVIOUS) != 0) ?
					lastOffset : pos) != line.offset)
					return false;
			}
			else if((checkRule.action & ParserRule.AT_WHITESPACE_END)
				== ParserRule.AT_WHITESPACE_END)
			{
				if((((checkRule.action & ParserRule.MARK_PREVIOUS) != 0) ?
					lastOffset : pos) != whitespaceEnd)
					return false;
			}
			else if((checkRule.action & ParserRule.AT_WORD_START)
				== ParserRule.AT_WORD_START)
			{
				if((((checkRule.action & ParserRule.MARK_PREVIOUS) != 0) ?
					lastOffset : pos) != lastOffset)
					return false;
			}
		} 

		int matchedChars = 1;

		
		if(!end || (checkRule.action & ParserRule.MARK_FOLLOWING) == 0)
		{
			
			if((checkRule.action & ParserRule.REGEXP) == 0 || end)
			{
				pattern.array = (end ? checkRule.end : checkRule.start);
				pattern.offset = 0;
				pattern.count = pattern.array.length;
				matchedChars = pattern.count;

				if(!TextUtilities.regionMatches(context.rules
					.getIgnoreCase(),line,pos,pattern.array))
				{
					return false;
				}
			}
			else
			{
				
				
				int matchStart = pos - line.offset;
				REMatch match = checkRule.startRegexp.getMatch(
					new CharIndexedSegment(line,matchStart),
					0,RE.REG_ANCHORINDEX);
				if(match == null)
					return false;
				else if(match.getStartIndex() != 0)
					throw new InternalError(""Can't happen"");
				else
					matchedChars = match.getEndIndex();
			}
		} 

		
		if((checkRule.action & ParserRule.IS_ESCAPE) == ParserRule.IS_ESCAPE)
		{
			if(context.inRule != null)
				handleRule(context.inRule,true);

			escaped = !escaped;
			pos += pattern.count - 1;
		}
		else if(escaped)
		{
			escaped = false;
			pos += pattern.count - 1;
		} 
		
		else if(!end)
		{
			if(context.inRule != null)
				handleRule(context.inRule,true);

			markKeyword((checkRule.action & ParserRule.MARK_PREVIOUS)
				!= ParserRule.MARK_PREVIOUS);

			switch(checkRule.action & ParserRule.MAJOR_ACTIONS)
			{
			
			case ParserRule.SEQ:
				if((checkRule.action & ParserRule.REGEXP) != 0)
				{
					handleTokenWithTabs(tokenHandler,
						checkRule.token,
						pos - line.offset,
						matchedChars,
						context);
				}
				else
				{
					tokenHandler.handleToken(checkRule.token,
						pos - line.offset,matchedChars,context);
				}

				
				
				ParserRuleSet delegateSet = checkRule.getDelegateRuleSet(this);
				if(delegateSet != null)
				{
					context = new LineContext(delegateSet,
						context.parent);
					keywords = context.rules.getKeywords();
				}
				break;
			
			
			case ParserRule.SPAN:
			case ParserRule.EOL_SPAN:
				context.inRule = checkRule;

				delegateSet = checkRule.getDelegateRuleSet(this);

				byte tokenType = ((checkRule.action & ParserRule.EXCLUDE_MATCH)
					== ParserRule.EXCLUDE_MATCH
					? context.rules.getDefault() : checkRule.token);

				if((checkRule.action & ParserRule.REGEXP) != 0)
				{
					handleTokenWithTabs(tokenHandler,
						tokenType,
						pos - line.offset,
						matchedChars,
						context);
				}
				else
				{
					tokenHandler.handleToken(tokenType,
						pos - line.offset,matchedChars,context);
				}

				
				
				context = new LineContext(delegateSet, context);
				keywords = context.rules.getKeywords();

				break;
			
			
			case ParserRule.MARK_FOLLOWING:
				tokenHandler.handleToken((checkRule.action
					& ParserRule.EXCLUDE_MATCH)
					== ParserRule.EXCLUDE_MATCH ?
					context.rules.getDefault()
					: checkRule.token,pos - line.offset,
					pattern.count,context);

				context.inRule = checkRule;
				break;
			
			
			case ParserRule.MARK_PREVIOUS:
				if ((checkRule.action & ParserRule.EXCLUDE_MATCH)
					== ParserRule.EXCLUDE_MATCH)
				{
					if(pos != lastOffset)
					{
						tokenHandler.handleToken(
							checkRule.token,
							lastOffset - line.offset,
							pos - lastOffset,
							context);
					}

					tokenHandler.handleToken(
						context.rules.getDefault(),
						pos - line.offset,pattern.count,
						context);
				}
				else
				{
					tokenHandler.handleToken(checkRule.token,
						lastOffset - line.offset,
						pos - lastOffset + pattern.count,
						context);
				}

				break;
			
			default:
				throw new InternalError(""Unhandled major action"");
			}

			
			pos += (matchedChars - 1);
			lastOffset = pos + 1;

			
		} 
		
		else if((context.inRule.action & ParserRule.MARK_FOLLOWING) != 0)
		{
			if(pos != lastOffset)
			{
				tokenHandler.handleToken(
					context.inRule.token,
					lastOffset - line.offset,
					pos - lastOffset,context);
			}

			lastOffset = pos;
			context.inRule = null;
		} 

		return true;
	} 

	
	private void handleNoWordBreak()
	{
		if(context.parent != null)
		{
			ParserRule rule = context.parent.inRule;
			if(rule != null && (context.parent.inRule.action
				& ParserRule.NO_WORD_BREAK) != 0)
			{
				if(pos != lastOffset)
				{
					tokenHandler.handleToken(rule.token,
						lastOffset - line.offset,
						pos - lastOffset,context);
				}

				lastOffset = pos;
				context = context.parent;
				keywords = context.rules.getKeywords();
				context.inRule = null;
			}
		}
	} 

	
	private void handleTokenWithTabs(TokenHandler tokenHandler, byte tokenType,
		int start, int len, LineContext context)
	{
		int last = start;
		int end = start + len;

		for(int i = start; i < end; i++)
		{
			if(line.array[i] == '\t')
			{
				if(last != i)
					tokenHandler.handleToken(tokenType,last,i - last,context);
				tokenHandler.handleToken(tokenType,i,1,context);
				last = i + 1;
			}
		}

		if(last != end)
			tokenHandler.handleToken(tokenType,last,end - last,context);
	} 

	
	private void markKeyword(boolean addRemaining)
	{
		int len = pos - lastOffset;
		if(len == 0)
			return;

		
		if(context.rules.getHighlightDigits())
		{
			boolean digit = false;
			boolean mixed = false;

			for(int i = lastOffset; i < pos; i++)
			{
				char ch = line.array[i];
				if(Character.isDigit(ch))
					digit = true;
				else
					mixed = true;
			}

			if(mixed)
			{
				RE digitRE = context.rules.getDigitRegexp();

				
				
				if(digit)
				{ 
					if(digitRE == null)
					{
						
						
						
						digit = false;
					}
					else
					{
						CharIndexedSegment seg = new CharIndexedSegment(
							line,false);
						int oldCount = line.count;
						int oldOffset = line.offset;
						line.offset = lastOffset;
						line.count = len;
						if(!digitRE.isMatch(seg))
							digit = false;
						line.offset = oldOffset;
						line.count = oldCount;
					}
				}
			}

			if(digit)
			{
				tokenHandler.handleToken(Token.DIGIT,
					lastOffset - line.offset,
					len,context);
				lastOffset = pos;

				return;
			}
		} 

		
		if(keywords != null)
		{
			byte id = keywords.lookup(line, lastOffset, len);

			if(id != Token.NULL)
			{
				tokenHandler.handleToken(id,
					lastOffset - line.offset,
					len,context);
				lastOffset = pos;
				return;
			}
		} 

		
		if(addRemaining)
		{
			tokenHandler.handleToken(context.rules.getDefault(),
				lastOffset - line.offset,len,context);
			lastOffset = pos;
		} 
	} 

	

	
	
	public static class LineContext
	{
		private static Hashtable intern = new Hashtable();

		public LineContext parent;
		public ParserRule inRule;
		public ParserRuleSet rules;
		
		public String spanEndSubst;

		
		public LineContext(ParserRule r, ParserRuleSet rs,
			String spanEndSubst)
		{
			inRule = r;
			rules = rs;
			this.spanEndSubst = spanEndSubst;
		} 

		
		public LineContext(ParserRuleSet rs, LineContext lc)
		{
			rules = rs;
			parent = (lc == null ? null : (LineContext)lc.clone());
		} 

		
		public LineContext()
		{
		} 

		
		public LineContext intern()
		{
			Object obj = intern.get(this);
			if(obj == null)
			{
				intern.put(this,this);
				return this;
			}
			else
				return (LineContext)obj;
		} 

		
		public int hashCode()
		{
			if(inRule != null)
				return inRule.hashCode();
			else if(rules != null)
				return rules.hashCode();
			else
				return 0;
		} 

		
		public boolean equals(Object obj)
		{
			if(obj instanceof LineContext)
			{
				LineContext lc = (LineContext)obj;
				if(lc.parent == null)
				{
					if(parent != null)
						return false;
				}
				else 
				{
					if(parent == null)
						return false;
					else if(!lc.parent.equals(parent))
						return false;
				}

				if(lc.spanEndSubst == null)
				{
					if(spanEndSubst != null)
						return false;
				}
				else
				{
					if(spanEndSubst == null)
						return false;
					else if(!lc.spanEndSubst.equals(spanEndSubst))
						return false;
				}

				return lc.inRule == inRule && lc.rules == rules;
			}
			else
				return false;
		} 

		
		public Object clone()
		{
			LineContext lc = new LineContext();
			lc.inRule = inRule;
			lc.rules = rules;
			lc.parent = (parent == null) ? null : (LineContext) parent.clone();
			lc.spanEndSubst = spanEndSubst;

			return lc;
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.FontSelector,3,6,0,6,18,3,5,2,1,2.0,66,0.0,0,0.997382199,0.444444444,0,0,21.0,2,1.0,0,"

package org.gjt.sp.jedit.gui;


import java.awt.event.*;
import java.awt.*;
import java.util.Vector;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import org.gjt.sp.jedit.*;




public class FontSelector extends JButton
{
	
	public FontSelector(Font font)
	{
		setFont(font);

		updateText();

		setRequestFocusEnabled(false);

		addActionListener(new ActionHandler());
	} 

	
	private void updateText()
	{
		Font font = getFont();
		String styleString;
		switch(font.getStyle())
		{
		case Font.PLAIN:
			styleString = jEdit.getProperty(""font-selector.plain"");
			break;
		case Font.BOLD:
			styleString = jEdit.getProperty(""font-selector.bold"");
			break;
		case Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.italic"");
			break;
		case Font.BOLD | Font.ITALIC:
			styleString = jEdit.getProperty(""font-selector.bolditalic"");
			break;
		default:
			styleString = ""UNKNOWN!!!???"";
			break;
		}

		setText(font.getName() + "" "" + font.getSize() + "" "" + styleString);
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Font font;

			JDialog dialog = GUIUtilities.getParentDialog(FontSelector.this);
			if(dialog == null)
			{
				font = new FontSelectorDialog(
					JOptionPane.getFrameForComponent(
					FontSelector.this),getFont())
					.getSelectedFont();
			}
			else
			{
				font = new FontSelectorDialog(dialog,getFont())
					.getSelectedFont();
			}

			if(font != null)
			{
				setFont(font);
				updateText();
			}
		}
	} 
} 


class FontSelectorDialog extends EnhancedDialog
{
	
	public FontSelectorDialog(Frame parent, Font font)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		init(font);
	} 

	
	public FontSelectorDialog(Dialog parent, Font font)
	{
		super(parent,jEdit.getProperty(""font-selector.title""),true);
		init(font);
	} 

	
	public void ok()
	{
		isOK = true;
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public Font getSelectedFont()
	{
		if(!isOK)
			return null;

		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 12;
		}

		return new Font(familyField.getText(),styleList
			.getSelectedIndex(),size);
	} 

	

	
	private boolean isOK;
	private JTextField familyField;
	private JList familyList;
	private JTextField sizeField;
	private JList sizeList;
	private JTextField styleField;
	private JList styleList;
	private JLabel preview;
	private JButton ok;
	private JButton cancel;
	

	
	private static final String[] HIDEFONTS = {
		"".bold"",
		"".italic""
	};

	
	private void init(Font font)
	{
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JPanel listPanel = new JPanel(new GridLayout(1,3,6,6));

		JPanel familyPanel = createTextFieldAndListPanel(
			""font-selector.family"",
			familyField = new JTextField(),
			familyList = new JList(getFontList()));
		listPanel.add(familyPanel);

		String[] sizes = { ""9"", ""10"", ""12"", ""14"", ""16"", ""18"", ""24"" };
		JPanel sizePanel = createTextFieldAndListPanel(
			""font-selector.size"",
			sizeField = new JTextField(),
			sizeList = new JList(sizes));
		listPanel.add(sizePanel);

		String[] styles = {
			jEdit.getProperty(""font-selector.plain""),
			jEdit.getProperty(""font-selector.bold""),
			jEdit.getProperty(""font-selector.italic""),
			jEdit.getProperty(""font-selector.bolditalic"")
		};

		JPanel stylePanel = createTextFieldAndListPanel(
			""font-selector.style"",
			styleField = new JTextField(),
			styleList = new JList(styles));
		styleField.setEditable(false);
		listPanel.add(stylePanel);

		familyList.setSelectedValue(font.getFamily(),true);
		familyField.setText(font.getFamily());
		sizeList.setSelectedValue(String.valueOf(font.getSize()),true);
		sizeField.setText(String.valueOf(font.getSize()));
		styleList.setSelectedIndex(font.getStyle());
		styleField.setText((String)styleList.getSelectedValue());

		ListHandler listHandler = new ListHandler();
		familyList.addListSelectionListener(listHandler);
		sizeList.addListSelectionListener(listHandler);
		styleList.addListSelectionListener(listHandler);

		content.add(BorderLayout.NORTH,listPanel);

		preview = new JLabel(jEdit.getProperty(""font-selector.long-text""));
		preview.setBorder(new TitledBorder(jEdit.getProperty(
			""font-selector.preview"")));

		updatePreview();

		Dimension prefSize = preview.getPreferredSize();
		prefSize.height = 50;
		preview.setPreferredSize(prefSize);

		content.add(BorderLayout.CENTER,preview);

		JPanel buttons = new JPanel();
		buttons.setLayout(new BoxLayout(buttons,BoxLayout.X_AXIS));
		buttons.setBorder(new EmptyBorder(12,0,0,0));
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		buttons.add(ok);

		buttons.add(Box.createHorizontalStrut(6));

		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		buttons.add(cancel);

		buttons.add(Box.createGlue());

		content.add(BorderLayout.SOUTH,buttons);

		pack();
		setLocationRelativeTo(getParent());
		show();
	} 

	
	private String[] getFontList()
	{
		String[] nameArray = GraphicsEnvironment
			.getLocalGraphicsEnvironment()
			.getAvailableFontFamilyNames();
		Vector nameVector = new Vector(nameArray.length);

		for(int i = 0, j; i < nameArray.length; i++)
		{
			for(j = 0; j < HIDEFONTS.length; j++)
			{
				if(nameArray[i].indexOf(HIDEFONTS[j]) >= 0)
					break;
			}

			if(j == HIDEFONTS.length)
				nameVector.addElement(nameArray[i]);
		}

		String[] _array = new String[nameVector.size()];
		nameVector.copyInto(_array);
		return _array;
	} 

	
	private JPanel createTextFieldAndListPanel(String label,
		JTextField textField, JList list)
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.gridx = cons.gridy = 0;
		cons.gridwidth = cons.gridheight = 1;
		cons.fill = GridBagConstraints.BOTH;
		cons.weightx = 1.0f;

		JLabel _label = new JLabel(jEdit.getProperty(label));
		layout.setConstraints(_label,cons);
		panel.add(_label);

		cons.gridy = 1;
		Component vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);

		cons.gridy = 2;
		layout.setConstraints(textField,cons);
		panel.add(textField);

		cons.gridy = 3;
		vs = Box.createVerticalStrut(6);
		layout.setConstraints(vs,cons);
		panel.add(vs);

		cons.gridy = 4;
		cons.gridheight = GridBagConstraints.REMAINDER;
		cons.weighty = 1.0f;
		JScrollPane scroller = new JScrollPane(list);
		layout.setConstraints(scroller,cons);
		panel.add(scroller);

		return panel;
	} 

	
	private void updatePreview()
	{
		String family = familyField.getText();
		int size;
		try
		{
			size = Integer.parseInt(sizeField.getText());
		}
		catch(Exception e)
		{
			size = 12;
		}
		int style = styleList.getSelectedIndex();

		preview.setFont(new Font(family,style,size));
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
				ok();
			else if(evt.getSource() == cancel)
				cancel();
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			Object source = evt.getSource();
			if(source == familyList)
			{
				String family = (String)familyList.getSelectedValue();
				if(family != null)
					familyField.setText(family);
			}
			else if(source == sizeList)
			{
				String size = (String)sizeList.getSelectedValue();
				if(size != null)
					sizeField.setText(size);
			}
			else if(source == styleList)
			{
				String style = (String)styleList.getSelectedValue();
				if(style != null)
					styleField.setText(style);
			}

			updatePreview();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.textarea.Selection,14,1,2,18,23,59,17,1,9,0.807692308,117,0.0,0,0.0,0.297619048,0,0,7.071428571,5,1.0714,2,"

package org.gjt.sp.jedit.textarea;


import java.util.ArrayList;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.MiscUtilities;



public abstract class Selection implements Cloneable
{
	
	
	public int getStart()
	{
		return start;
	} 

	
	
	public int getEnd()
	{
		return end;
	} 

	
	
	public abstract int getStart(Buffer buffer, int line);
	

	
	
	public abstract int getEnd(Buffer buffer, int line);
	

	
	
	public int getStartLine()
	{
		return startLine;
	} 

	
	
	public int getEndLine()
	{
		return endLine;
	} 

	
	
	public boolean overlaps(Selection s)
	{
		if((start >= s.start && start <= s.end)
			|| (end >= s.start && end <= s.end))
			return true;
		else
			return false;
	} 

	
	public String toString()
	{
		return getClass().getName() + ""[start="" + start
			+ "",end="" + end + "",startLine="" + startLine
			+ "",endLine="" + endLine + ""]"";
	} 

	
	public Object clone()
	{
		try
		{
			return super.clone();
		}
		catch(CloneNotSupportedException e)
		{
			throw new InternalError(""I just drank a whole ""
				+ ""bottle of cough syrup and I feel ""
				+ ""funny!"");
		}
	} 

	
	int start, end;
	int startLine, endLine;

	
	Selection()
	{
	} 

	
	Selection(Selection sel)
	{
		this.start = sel.start;
		this.end = sel.end;
	} 

	
	Selection(int start, int end)
	{
		this.start = start;
		this.end = end;
	} 

	
	abstract void getText(Buffer buffer, StringBuffer buf);
	abstract int setText(Buffer buffer, String text);
	

	
	
	public static class Range extends Selection
	{
		
		public Range()
		{
		} 

		
		public Range(Selection sel)
		{
			super(sel);
		} 

		
		public Range(int start, int end)
		{
			super(start,end);
		} 

		
		public int getStart(Buffer buffer, int line)
		{
			if(line == startLine)
				return start;
			else
				return buffer.getLineStartOffset(line);
		} 

		
		public int getEnd(Buffer buffer, int line)
		{
			if(line == endLine)
				return end;
			else
				return buffer.getLineEndOffset(line) - 1;
		} 

		
		void getText(Buffer buffer, StringBuffer buf)
		{
			buf.append(buffer.getText(start,end - start));
		} 

		
		int setText(Buffer buffer, String text)
		{
			buffer.remove(start,end - start);
			if(text != null && text.length() != 0)
			{
				buffer.insert(start,text);
				return start + text.length();
			}
			else
				return start;
		} 
	} 

	
	
	
	public static class Rect extends Selection
	{
		
		public Rect()
		{
			super();
		} 

		
		public Rect(Selection sel)
		{
			super(sel);
		} 

		
		public Rect(int start, int end)
		{
			super(start,end);
		} 

		
		public Rect(int startLine, int start, int endLine, int end)
		{
			this.startLine = startLine;
			this.start = start;
			this.endLine = endLine;
			this.end = end;
		} 

		
		public Rect(Buffer buffer, int startLine, int startColumn,
			int endLine, int endColumn)
		{
			this.startLine = startLine;
			this.endLine = endLine;

			int[] width = new int[1];
			int startOffset = buffer.getOffsetOfVirtualColumn(startLine,
				startColumn,width);
			if(startOffset == -1)
			{
				extraStartVirt = startColumn - width[0];
				startOffset = buffer.getLineEndOffset(startLine) - 1;
			}
			else
				startOffset += buffer.getLineStartOffset(startLine);

			int endOffset = buffer.getOffsetOfVirtualColumn(endLine,
				endColumn,width);
			if(endOffset == -1)
			{
				extraEndVirt = endColumn - width[0];
				endOffset = buffer.getLineEndOffset(endLine) - 1;
			}
			else
				endOffset += buffer.getLineStartOffset(endLine);
		} 

		
		public int getStartColumn(Buffer buffer)
		{
			int virtColStart = buffer.getVirtualWidth(startLine,
				start - buffer.getLineStartOffset(startLine)) + extraStartVirt;
			int virtColEnd = buffer.getVirtualWidth(endLine,
				end - buffer.getLineStartOffset(endLine)) + extraEndVirt;
			return Math.min(virtColStart,virtColEnd);
		} 

		
		public int getEndColumn(Buffer buffer)
		{
			int virtColStart = buffer.getVirtualWidth(startLine,
				start - buffer.getLineStartOffset(startLine)) + extraStartVirt;
			int virtColEnd = buffer.getVirtualWidth(endLine,
				end - buffer.getLineStartOffset(endLine)) + extraEndVirt;
			return Math.max(virtColStart,virtColEnd);
		} 

		
		public int getStart(Buffer buffer, int line)
		{
			return getColumnOnOtherLine(buffer,startLine,line,
				getStartColumn(buffer));
		} 

		
		public int getEnd(Buffer buffer, int line)
		{
			return getColumnOnOtherLine(buffer,startLine,line,
				getEndColumn(buffer));
		} 

		
		int extraStartVirt;
		int extraEndVirt;

		
		void getText(Buffer buffer, StringBuffer buf)
		{
			int start = getStartColumn(buffer);
			int end = getEndColumn(buffer);

			for(int i = startLine; i <= endLine; i++)
			{
				int lineStart = buffer.getLineStartOffset(i);
				int lineLen = buffer.getLineLength(i);

				int rectStart = buffer.getOffsetOfVirtualColumn(
					i,start,null);
				if(rectStart == -1)
					rectStart = lineLen;

				int rectEnd = buffer.getOffsetOfVirtualColumn(
					i,end,null);
				if(rectEnd == -1)
					rectEnd = lineLen;

				if(rectEnd < rectStart)
					System.err.println(i + "":::"" + start + "":"" + end
						+ "" ==> "" + rectStart + "":"" + rectEnd);
				buf.append(buffer.getText(lineStart + rectStart,
					rectEnd - rectStart));

				if(i != endLine)
					buf.append('\n');
			}
		} 

		
		int setText(Buffer buffer, String text)
		{
			int startColumn = getStartColumn(buffer);
			int endColumn = getEndColumn(buffer);

			int[] total = new int[1];

			int tabSize = buffer.getTabSize();

			int maxWidth = 0;
			int totalLines = 0;
			ArrayList lines = new ArrayList();

			
			if(text != null)
			{
				int lastNewline = 0;
				int currentWidth = startColumn;
				for(int i = 0; i < text.length(); i++)
				{
					char ch = text.charAt(i);
					if(ch == '\n')
					{
						totalLines++;
						lines.add(text.substring(
							lastNewline,i));
						lastNewline = i + 1;
						maxWidth = Math.max(maxWidth,currentWidth);
						lines.add(new Integer(currentWidth));
						currentWidth = startColumn;
					}
					else if(ch == '\t')
						currentWidth += tabSize - (currentWidth % tabSize);
					else
						currentWidth++;
				}

				if(lastNewline != text.length())
				{
					totalLines++;
					lines.add(text.substring(lastNewline));
					lines.add(new Integer(currentWidth));
					maxWidth = Math.max(maxWidth,currentWidth);
				}
			} 

			
			int endOffset = 0;
			int lastLine = Math.max(startLine + totalLines - 1,endLine);
			for(int i = startLine; i <= lastLine; i++)
			{
				if(i == buffer.getLineCount())
					buffer.insert(buffer.getLength(),""\n"");

				int lineStart = buffer.getLineStartOffset(i);
				int lineLen = buffer.getLineLength(i);

				int rectStart = buffer.getOffsetOfVirtualColumn(
					i,startColumn,total);
				int startWhitespace;
				if(rectStart == -1)
				{
					startWhitespace = (startColumn - total[0]);
					rectStart = lineLen;
				}
				else
					startWhitespace = 0;

				int rectEnd = buffer.getOffsetOfVirtualColumn(
					i,endColumn,null);
				if(rectEnd == -1)
					rectEnd = lineLen;

				buffer.remove(rectStart + lineStart,rectEnd - rectStart);

				int index = 2 * (i - startLine);

				int endWhitespace;
				if(rectEnd == lineLen)
					endWhitespace = 0;
				else if(i - startLine >= totalLines)
					endWhitespace = maxWidth - startColumn;
				else
				{
					endWhitespace = maxWidth
						- ((Integer)lines.get(index+1))
						.intValue();
				}

				String str = (i - startLine >= totalLines
					? """" : (String)lines.get(index));
				if(startWhitespace != 0)
				{
					buffer.insert(rectStart + lineStart,
						MiscUtilities.createWhiteSpace(startWhitespace,0));
				}

				buffer.insert(rectStart + lineStart + startWhitespace,str);

				if(endWhitespace != 0)
				{
					buffer.insert(rectStart + lineStart
						+ startWhitespace + str.length(),
						MiscUtilities.createWhiteSpace(endWhitespace,0));
				}

				endOffset = rectStart + lineStart
					+ startWhitespace
					+ endWhitespace
					+ str.length();
			} 

			
			if(text == null || text.length() == 0)
				return end;
			if(lastLine != buffer.getLineCount() - 1)
			{
				int offset = buffer.getOffsetOfVirtualColumn(
					lastLine + 1,startColumn,null);
				if(offset == -1)
				{
					buffer.insertAtColumn(lastLine + 1,startColumn,"""");
					return buffer.getLineEndOffset(lastLine + 1) - 1;
				}
				else
					return buffer.getLineStartOffset(lastLine + 1) + offset;
			}
			else
				return endOffset;
			
		} 

		

		

		
		private int getColumnOnOtherLine(Buffer buffer, int line1,
			int line2, int col)
		{
			int returnValue = buffer.getOffsetOfVirtualColumn(
				line2,col,null);
			if(returnValue == -1)
				return buffer.getLineEndOffset(line2) - 1;
			else
				return buffer.getLineStartOffset(line2) + returnValue;
		} 

		
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.Token,3,1,1,10,9,1,9,1,3,1.347826087,138,0.0,2,0.0,0.4,0,0,37.33333333,15,5.3333,0,"
package org.gjt.sp.jedit.syntax;


public class Token
{
	
	
	public static byte stringToToken(String value)
	{
		value = value.intern();

		if (value == ""NULL"")
			return Token.NULL;
		else if (value == ""COMMENT1"")
			return Token.COMMENT1;
		else if (value == ""COMMENT2"")
			return Token.COMMENT2;
		else if (value == ""LITERAL1"")
			return Token.LITERAL1;
		else if (value == ""LITERAL2"")
			return Token.LITERAL2;
		else if (value == ""LABEL"")
			return Token.LABEL;
		else if (value == ""KEYWORD1"")
			return Token.KEYWORD1;
		else if (value == ""KEYWORD2"")
			return Token.KEYWORD2;
		else if (value == ""KEYWORD3"")
			return Token.KEYWORD3;
		else if (value == ""FUNCTION"")
			return Token.FUNCTION;
		else if (value == ""MARKUP"")
			return Token.MARKUP;
		else if (value == ""OPERATOR"")
			return Token.OPERATOR;
		else if (value == ""DIGIT"")
			return Token.DIGIT;
		else if (value == ""INVALID"")
			return Token.INVALID;
		else
			return -1;
	} 

	
	public static final byte NULL = 0;
	public static final byte COMMENT1 = 1;
	public static final byte COMMENT2 = 2;
	public static final byte LITERAL1 = 3;
	public static final byte LITERAL2 = 4;
	public static final byte LABEL = 5;
	public static final byte KEYWORD1 = 6;
	public static final byte KEYWORD2 = 7;
	public static final byte KEYWORD3 = 8;
	public static final byte FUNCTION = 9;
	public static final byte MARKUP = 10;
	public static final byte OPERATOR = 11;
	public static final byte DIGIT = 12;
	public static final byte INVALID = 13; 

	public static final byte ID_COUNT = 14;

	
	public static final byte WHITESPACE = 125;
	public static final byte TAB = 126;
	public static final byte END = 127;

	
	
	public byte id;

	
	public int offset;

	
	public int length;

	
	public ParserRuleSet rules;

	
	public Token next;
	

	
	
	public Token(byte id, int offset, int length, ParserRuleSet rules)
	{
		this.id = id;
		this.offset = offset;
		this.length = length;
		this.rules = rules;
	} 

	
	
	public String toString()
	{
		return ""[id="" + id + "",offset="" + offset + "",length="" + length + ""]"";
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.textarea.TextAreaPainter,53,4,0,22,145,988,14,14,46,0.960918114,1107,0.677419355,5,0.925501433,0.101415094,3,25,19.30188679,7,1.6038,5,"

package org.gjt.sp.jedit.textarea;


import javax.swing.text.*;
import javax.swing.JComponent;
import java.awt.event.MouseEvent;
import java.awt.font.*;
import java.awt.*;
import java.util.HashMap;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.util.Log;



public class TextAreaPainter extends JComponent implements TabExpander
{
	
	
	public static final int LOWEST_LAYER = Integer.MIN_VALUE;

	
	public static final int BACKGROUND_LAYER = -60;

	
	public static final int LINE_BACKGROUND_LAYER = -50;

	
	public static final int BELOW_SELECTION_LAYER = -40;

	
	public static final int SELECTION_LAYER = -30;

	
	public static final int WRAP_GUIDE_LAYER = -20;

	
	public static final int BELOW_MOST_EXTENSIONS_LAYER = -10;

	
	public static final int DEFAULT_LAYER = 0;

	
	public static final int BRACKET_HIGHLIGHT_LAYER = 100;

	
	public static final int HIGHEST_LAYER = Integer.MAX_VALUE;
	

	
	
	public TextAreaPainter(JEditTextArea textArea)
	{
		enableEvents(AWTEvent.FOCUS_EVENT_MASK
			| AWTEvent.KEY_EVENT_MASK
			| AWTEvent.MOUSE_EVENT_MASK);

		this.textArea = textArea;

		extensionMgr = new ExtensionManager();

		setAutoscrolls(true);
		setOpaque(true);

		setCursor(Cursor.getPredefinedCursor(Cursor.TEXT_CURSOR));

		fontRenderContext = new FontRenderContext(null,false,false);

		addExtension(LINE_BACKGROUND_LAYER,lineBackground
			= new PaintLineBackground());
		addExtension(SELECTION_LAYER,new PaintSelection());
		addExtension(WRAP_GUIDE_LAYER,new WrapGuide());
		addExtension(BRACKET_HIGHLIGHT_LAYER,new BracketHighlight());
	} 

	
	
	public void setBounds(int x, int y, int width, int height)
	{
		if(x == getX() && y == getY() && width == getWidth()
			&& height == getHeight())
		{
			return;
		}

		super.setBounds(x,y,width,height);

		textArea.recalculateVisibleLines();
		textArea.recalculateLastPhysicalLine();
		textArea.propertiesChanged();
		textArea.scrollBarsInitialized = true;
	} 

	
	
	public boolean isManagingFocus()
	{
		return false;
	} 

	
	
	public boolean getFocusTraversalKeysEnabled()
	{
		return false;
	} 

	

	
	
	public final SyntaxStyle[] getStyles()
	{
		return styles;
	} 

	
	
	public final void setStyles(SyntaxStyle[] styles)
	{
		this.styles = styles;
		styles[Token.NULL] = new SyntaxStyle(getForeground(),null,getFont());
		repaint();
	} 

	
	
	public final Color getCaretColor()
	{
		return caretColor;
	} 

	
	
	public final void setCaretColor(Color caretColor)
	{
		this.caretColor = caretColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final Color getSelectionColor()
	{
		return selectionColor;
	} 

	
	
	public final void setSelectionColor(Color selectionColor)
	{
		this.selectionColor = selectionColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateSelectedLines();
	} 

	
	
	public final Color getLineHighlightColor()
	{
		return lineHighlightColor;
	} 

	
	
	public final void setLineHighlightColor(Color lineHighlightColor)
	{
		this.lineHighlightColor = lineHighlightColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final boolean isLineHighlightEnabled()
	{
		return lineHighlight;
	} 

	
	
	public final void setLineHighlightEnabled(boolean lineHighlight)
	{
		this.lineHighlight = lineHighlight;
		if(textArea.getBuffer() != null)
			textArea.invalidateSelectedLines();
	} 

	
	
	public final Color getBracketHighlightColor()
	{
		return bracketHighlightColor;
	} 

	
	
	public final void setBracketHighlightColor(Color bracketHighlightColor)
	{
		this.bracketHighlightColor = bracketHighlightColor;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getBracketLine());
	} 

	
	
	public final boolean isBracketHighlightEnabled()
	{
		return bracketHighlight;
	} 

	
	
	public final void setBracketHighlightEnabled(boolean bracketHighlight)
	{
		this.bracketHighlight = bracketHighlight;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getBracketLine());
	} 

	
	
	public final boolean isBlockCaretEnabled()
	{
		return blockCaret;
	} 

	
	
	public final void setBlockCaretEnabled(boolean blockCaret)
	{
		this.blockCaret = blockCaret;
		if(textArea.getBuffer() != null)
			textArea.invalidateLine(textArea.getCaretLine());
	} 

	
	
	public final Color getEOLMarkerColor()
	{
		return eolMarkerColor;
	} 

	
	
	public final void setEOLMarkerColor(Color eolMarkerColor)
	{
		this.eolMarkerColor = eolMarkerColor;
		repaint();
	} 

	
	
	public final boolean getEOLMarkersPainted()
	{
		return eolMarkers;
	} 

	
	
	public final void setEOLMarkersPainted(boolean eolMarkers)
	{
		this.eolMarkers = eolMarkers;
		repaint();
	} 

	
	
	public final Color getWrapGuideColor()
	{
		return wrapGuideColor;
	} 

	
	
	public final void setWrapGuideColor(Color wrapGuideColor)
	{
		this.wrapGuideColor = wrapGuideColor;
		repaint();
	} 

	
	
	public final boolean isWrapGuidePainted()
	{
		return wrapGuide;
	} 

	
	
	public final void setWrapGuidePainted(boolean wrapGuide)
	{
		this.wrapGuide = wrapGuide;
		repaint();
	} 

	
	
	public final SyntaxStyle getFoldLineStyle()
	{
		return foldLineStyle;
	} 

	
	
	public final void setFoldLineStyle(SyntaxStyle foldLineStyle)
	{
		this.foldLineStyle = foldLineStyle;
		repaint();
	} 

	
	
	public void setAntiAliasEnabled(boolean antiAlias)
	{
		this.antiAlias = antiAlias;
		updateRenderingHints();
	} 

	
	
	public boolean isAntiAliasEnabled()
	{
		return antiAlias;
	} 

	
	
	public void setFractionalFontMetricsEnabled(boolean fracFontMetrics)
	{
		this.fracFontMetrics = fracFontMetrics;
		updateRenderingHints();
	} 

	
	
	public boolean isFractionalFontMetricsEnabled()
	{
		return fracFontMetrics;
	} 

	
	
	public FontRenderContext getFontRenderContext()
	{
		return fontRenderContext;
	} 

	

	
	
	public void addExtension(TextAreaExtension extension)
	{
		extensionMgr.addExtension(DEFAULT_LAYER,extension);
		repaint();
	} 

	
	
	public void addExtension(int layer, TextAreaExtension extension)
	{
		extensionMgr.addExtension(layer,extension);
		repaint();
	} 

	
	
	public void removeExtension(TextAreaExtension extension)
	{
		extensionMgr.removeExtension(extension);
		repaint();
	} 

	
	
	public TextAreaExtension[] getExtensions()
	{
		return extensionMgr.getExtensions();
	} 

	
	
	public String getToolTipText(MouseEvent evt)
	{
		if(!textArea.getBuffer().isLoaded())
			return null;

		return extensionMgr.getToolTipText(evt.getX(),evt.getY());
	} 

	
	
	public FontMetrics getFontMetrics()
	{
		return fm;
	} 

	
	
	public void setFont(Font font)
	{
		super.setFont(font);
		fm = getFontMetrics(font);
		textArea.recalculateVisibleLines();
	} 

	
	
	public void paintComponent(Graphics _gfx)
	{
		Graphics2D gfx = (Graphics2D)_gfx;
		gfx.setRenderingHints(renderingHints);
		fontRenderContext = gfx.getFontRenderContext();

		Rectangle clipRect = gfx.getClipBounds();

		gfx.setColor(getBackground());
		gfx.fillRect(clipRect.x,clipRect.y,clipRect.width,clipRect.height);

		Buffer buffer = textArea.getBuffer();
		if(!buffer.isLoaded())
			return;

		int x = textArea.getHorizontalOffset();

		int height = fm.getHeight();
		int firstInvalid = clipRect.y / height;
		
		
		
		int lastInvalid = (clipRect.y + clipRect.height - 1) / height;

		
		
		textArea.chunkCache.updateChunksUpTo(lastInvalid);

		int y = (clipRect.y - clipRect.y % height);

		try
		{
			boolean updateMaxHorizontalScrollWidth = false;

			for(int line = firstInvalid; line <= lastInvalid; line++)
			{
				ChunkCache.LineInfo lineInfo = textArea.chunkCache
					.getLineInfo(line);
				if(!lineInfo.chunksValid)
					System.err.println(""text area painter: not valid"");

				lineInfo.width = paintLine(gfx,buffer,lineInfo,line,x,y) - x;
				if(lineInfo.width > textArea.maxHorizontalScrollWidth)
					updateMaxHorizontalScrollWidth = true;

				y += height;
			}

			if(buffer.isNextLineRequested())
			{
				
				int h = clipRect.y + clipRect.height;
				textArea.chunkCache.invalidateChunksFrom(lastInvalid + 1);
				repaint(0,h,getWidth(),getHeight() - h);
			}

			if(updateMaxHorizontalScrollWidth)
				textArea.updateMaxHorizontalScrollWidth();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,""Error repainting line""
				+ "" range {"" + firstInvalid + "",""
				+ lastInvalid + ""}:"");
			Log.log(Log.ERROR,this,e);
		}

		if(textArea.timing)
		{
			textArea.timing = false;
			System.err.println(System.currentTimeMillis() - textArea.time);
		}
	} 

	
	
	public float nextTabStop(float x, int tabOffset)
	{
		int ntabs = (int)(x / textArea.tabSize);
		return (ntabs + 1) * textArea.tabSize;
	} 

	
	
	public Dimension getPreferredSize()
	{
		Dimension dim = new Dimension();

		char[] foo = new char[80];
		for(int i = 0; i < foo.length; i++)
			foo[i] = ' ';
		dim.width = (int)(getFont().getStringBounds(foo,0,foo.length,
			fontRenderContext).getWidth());
		dim.height = fm.getHeight() * 25;
		return dim;
	} 

	
	
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	} 

	

	
	private JEditTextArea textArea;

	private SyntaxStyle[] styles;
	private Color caretColor;
	private Color selectionColor;
	private Color lineHighlightColor;
	private Color bracketHighlightColor;
	private Color eolMarkerColor;
	private Color wrapGuideColor;

	private SyntaxStyle foldLineStyle;

	private boolean blockCaret;
	private boolean lineHighlight;
	private boolean bracketHighlight;
	private boolean eolMarkers;
	private boolean wrapGuide;
	private boolean antiAlias;
	private boolean fracFontMetrics;

	
	private FontMetrics fm;

	private ExtensionManager extensionMgr;

	
	
	private PaintLineBackground lineBackground;

	private RenderingHints renderingHints;
	private FontRenderContext fontRenderContext;
	

	
	private void updateRenderingHints()
	{
		HashMap hints = new HashMap();

		if(antiAlias)
		{
			hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
		}
		else
		{
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_OFF);
			hints.put(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_OFF);
		}

		hints.put(RenderingHints.KEY_FRACTIONALMETRICS,
			fracFontMetrics ?
				RenderingHints.VALUE_FRACTIONALMETRICS_ON
				: RenderingHints.VALUE_FRACTIONALMETRICS_OFF);

		renderingHints = new RenderingHints(hints);
		fontRenderContext = new FontRenderContext(null,antiAlias,
			fracFontMetrics);
	} 

	
	private int paintLine(Graphics2D gfx, Buffer buffer,
		ChunkCache.LineInfo lineInfo, int screenLine,
		int x, int y)
	{
		int physicalLine = lineInfo.physicalLine;

		if(physicalLine == -1)
			extensionMgr.paintInvalidLine(gfx,screenLine,y);
		else
		{
			int start = textArea.getScreenLineStartOffset(screenLine);
			int end = textArea.getScreenLineEndOffset(screenLine);

			extensionMgr.paintValidLine(gfx,screenLine,physicalLine,
				start,end,y);

			Font defaultFont = getFont();
			Color defaultColor = getForeground();

			gfx.setFont(defaultFont);
			gfx.setColor(defaultColor);

			float baseLine = y + fm.getHeight()
				- fm.getLeading() - fm.getDescent();

			if(lineInfo.chunks != null)
			{
				buffer.getLineText(physicalLine,textArea.lineSegment);
				x += Chunk.paintChunkList(textArea.lineSegment,
					lineInfo.chunks,gfx,x,baseLine,
					lineBackground.bgColor,true);
			}


			if(!lineInfo.lastSubregion)
			{
				gfx.setFont(defaultFont);
				gfx.setColor(eolMarkerColor);
				gfx.drawString("":"",Math.max(x,
					textArea.getHorizontalOffset()
					+ textArea.wrapMargin + textArea.charWidth),
					baseLine);
				x += textArea.charWidth;
			}
			else if(lineBackground.collapsedFold)
			{
				Font font = foldLineStyle.getFont();
				gfx.setFont(font);
				gfx.setColor(foldLineStyle.getForegroundColor());

				int nextLine = textArea.getFoldVisibilityManager()
					.getNextVisibleLine(physicalLine);
				if(nextLine == -1)
					nextLine = buffer.getLineCount();

				int count = nextLine - physicalLine - 1;
				String str = "" ["" + count + "" lines]"";

				float width = (float)font.getStringBounds(
					str,fontRenderContext).getWidth();

				gfx.drawString(str,x,baseLine);
				x += width;
			}
			else if(eolMarkers)
			{
				gfx.setFont(defaultFont);
				gfx.setColor(eolMarkerColor);
				gfx.drawString(""."",x,baseLine);
				x += textArea.charWidth;
			}

			paintCaret(gfx,physicalLine,start,end,y,lineBackground.bgColor);
		}

		return x;
	} 

	
	private void paintCaret(Graphics2D gfx, int physicalLine,
		int start, int end, int y, Color bgColor)
	{
		if(!textArea.isCaretVisible())
			return;

		int caret = textArea.getCaretPosition();
		if(caret < start || caret >= end)
			return;

		int offset = caret - textArea.getLineStartOffset(physicalLine);
		textArea.offsetToXY(physicalLine,offset,textArea.returnValue);
		int caretX = textArea.returnValue.x;
		int height = fm.getHeight();

		gfx.setColor(caretColor);

		if(blockCaret)
		{
			
			
			
			Graphics2D blockgfx = (Graphics2D)gfx.create();
			blockgfx.setXORMode(bgColor);

			if(textArea.isOverwriteEnabled())
			{
				blockgfx.fillRect(caretX,y + height - height / 3,
					textArea.charWidth,height / 3);
			}
			else
				blockgfx.fillRect(caretX,y,textArea.charWidth,height);

			blockgfx.dispose();
		}
		else
		{
			if(textArea.isOverwriteEnabled())
			{
				gfx.drawLine(caretX,y + height - 1,
					caretX + textArea.charWidth,y + height - 1);
			}
			else
				gfx.drawLine(caretX,y,caretX,y + height - 1);
		}
	} 

	

	
	class PaintLineBackground extends TextAreaExtension
	{
		boolean collapsedFold;
		Color bgColor;

		
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			
			JEditTextArea textArea = TextAreaPainter.this.textArea;
			Buffer buffer = textArea.getBuffer();

			collapsedFold = (physicalLine < buffer.getLineCount() - 1
				&& buffer.isFoldStart(physicalLine)
				&& !textArea.getFoldVisibilityManager()
				.isLineVisible(physicalLine + 1));

			int caret = textArea.getCaretPosition();
			boolean paintLineHighlight = isLineHighlightEnabled()
				&& caret >= start && caret < end
				&& textArea.selection.size() == 0;

			if(paintLineHighlight)
				bgColor = lineHighlightColor;
			else if(collapsedFold)
			{
				bgColor = foldLineStyle.getBackgroundColor();
				if(bgColor == null)
					bgColor = getBackground();
			}
			else
				bgColor = getBackground();

			if(paintLineHighlight || collapsedFold)
			{
				gfx.setColor(bgColor);
				gfx.fillRect(0,y,getWidth(),fm.getHeight());
			}
		} 
	} 

	
	class PaintSelection extends TextAreaExtension
	{
		
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(textArea.selection.size() == 0)
				return;

			gfx.setColor(getSelectionColor());
			for(int i = textArea.selection.size() - 1;
				i >= 0; i--)
			{
				paintSelection(gfx,screenLine,
					physicalLine,start,end,y,
					(Selection)textArea.selection
					.get(i));
			}
		} 

		
		private void paintSelection(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y, Selection s)
		{
			if(end <= s.start || start > s.end)
				return;

			int selStartScreenLine = textArea.getScreenLineOfOffset(s.start);
			int selEndScreenLine = textArea.getScreenLineOfOffset(s.end);

			Buffer buffer = textArea.getBuffer();

			int lineStart = buffer.getLineStartOffset(physicalLine);

			int x1, x2;

			if(s instanceof Selection.Rect)
			{
				start -= lineStart;
				end -= lineStart;

				Selection.Rect rect = (Selection.Rect)s;
				int _start = rect.getStartColumn(buffer);
				int _end = rect.getEndColumn(buffer);

				int lineLen = buffer.getLineLength(physicalLine);

				int[] total = new int[1];

				int rectStart = buffer.getOffsetOfVirtualColumn(
					physicalLine,_start,total);
				if(rectStart == -1)
				{
					x1 = (_start - total[0]) * textArea.charWidth;
					rectStart = lineLen;
				}
				else
					x1 = 0;

				int rectEnd = buffer.getOffsetOfVirtualColumn(
					physicalLine,_end,total);
				if(rectEnd == -1)
				{
					x2 = (_end - total[0]) * textArea.charWidth;
					rectEnd = lineLen;
				}
				else
					x2 = 0;

				if(end <= rectStart || start > rectEnd)
					return;

				x1 = (rectStart < start ? 0
					: x1 + textArea.offsetToXY(physicalLine,rectStart,textArea.returnValue).x);
				x2 = (rectEnd > end ? getWidth()
					: x2 + textArea.offsetToXY(physicalLine,rectEnd,textArea.returnValue).x);
			}
			else if(selStartScreenLine == selEndScreenLine
				&& selStartScreenLine != -1)
			{
				x1 = textArea.offsetToXY(physicalLine,
					s.start - lineStart,textArea.returnValue).x;
				x2 = textArea.offsetToXY(physicalLine,
					s.end - lineStart,textArea.returnValue).x;
			}
			else if(screenLine == selStartScreenLine)
			{
				x1 = textArea.offsetToXY(physicalLine,
					s.start - lineStart,textArea.returnValue).x;
				x2 = getWidth();
			}
			else if(screenLine == selEndScreenLine)
			{
				x1 = 0;
				x2 = textArea.offsetToXY(physicalLine,
					s.end - lineStart,textArea.returnValue).x;
			}
			else
			{
				x1 = 0;
				x2 = getWidth();
			}

			if(x1 < 0)
				x1 = 0;
			if(x2 < 0)
				x2 = 0;

			if(x1 == x2)
				x2++;

			gfx.fillRect(x1,y,x2 - x1,fm.getHeight());
		} 
	} 

	
	class WrapGuide extends TextAreaExtension
	{
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			paintInvalidLine(gfx,screenLine,y);
		}

		public void paintInvalidLine(Graphics2D gfx, int screenLine, int y)
		{
			if(!textArea.wrapToWidth && textArea.wrapMargin != 0
				&& isWrapGuidePainted())
			{
				gfx.setColor(getWrapGuideColor());
				int x = textArea.getHorizontalOffset() + textArea.wrapMargin;
				gfx.drawLine(x,y,x,y + fm.getHeight());
			}
		}

		public String getToolTipText(int x, int y)
		{
			if(!textArea.wrapToWidth && textArea.wrapMargin != 0
				&& isWrapGuidePainted())
			{
				int wrapGuidePos = textArea.wrapMargin
					+ textArea.getHorizontalOffset();
				if(Math.abs(x - wrapGuidePos) < 5)
				{
					return String.valueOf(textArea.getBuffer()
						.getProperty(""maxLineLen""));
				}
			}

			return null;
		}
	} 

	
	class BracketHighlight extends TextAreaExtension
	{
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(!isBracketHighlightEnabled() || !textArea.isBracketHighlightVisible())
				return;

			int bracketLine = textArea.getBracketLine();
			int bracketOffset = textArea.getBracketPosition();
			if(bracketLine == -1 || bracketOffset == -1)
				return;

			int bracketLineStart = textArea.getLineStartOffset(bracketLine);
			if(bracketOffset + bracketLineStart < start
				|| bracketOffset + bracketLineStart >= end)
				return;

			textArea.offsetToXY(bracketLine,bracketOffset,textArea.returnValue);
			gfx.setColor(getBracketHighlightColor());
			
			
			
			gfx.drawRect(textArea.returnValue.x,y,(int)gfx.getFont().getStringBounds(
				""("",getFontRenderContext()).getWidth() - 1,
				fm.getHeight() - 1);
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.SyntaxStyle,4,1,0,14,5,0,14,0,4,0.666666667,28,1.0,0,0.0,0.5,0,0,5.25,1,0.75,0,"
package org.gjt.sp.jedit.syntax;

import java.awt.Font;
import java.awt.Color;


public class SyntaxStyle
{
	
	public SyntaxStyle(Color fgColor, Color bgColor, Font font)
	{
		this.fgColor = fgColor;
		this.bgColor = bgColor;
		this.font = font;
	}

	
	public Color getForegroundColor()
	{
		return fgColor;
	}

	
	public Color getBackgroundColor()
	{
		return bgColor;
	}

	
	public Font getFont()
	{
		return font;
	}

	
	private Color fgColor;
	private Color bgColor;
	private Font font;
}
"
jEdit,4.1,org.gjt.sp.jedit.Marker,7,1,0,7,10,0,7,1,2,0.625,64,1.0,1,0.0,0.428571429,0,0,7.571428571,2,1.1429,0,"

package org.gjt.sp.jedit;

import javax.swing.text.Position;


public class Marker
{
	
	
	public char getShortcut()
	{
		return shortcut;
	} 

	
	
	public int getPosition()
	{
		return (position == null ? pos : position.getOffset());
	} 

	

	
	Marker(Buffer buffer, char shortcut, int position)
	{
		this.buffer = buffer;
		this.shortcut = shortcut;
		this.pos = position;
	} 

	
	
	void setShortcut(char shortcut)
	{
		this.shortcut = shortcut;
	} 

	
	void createPosition()
	{
		position = buffer.createPosition(pos);
	} 

	
	void removePosition()
	{
		
		if(position != null)
		{
			pos = position.getOffset();
			position = null;
		}
	} 

	
	
	void setPosition(int pos)
	{
		this.pos = pos;
	} 

	

	
	private Buffer buffer;
	private char shortcut;
	private int pos;
	private Position position;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.msg.EditorExiting,1,2,0,3,2,0,1,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class EditorExiting extends EBMessage
{
	
	public EditorExiting(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.RolloverButton,6,6,1,11,22,13,11,1,5,0.8,75,1.0,0,0.996078431,0.4,3,12,11.33333333,2,0.6667,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;



public class RolloverButton extends JButton
{
	
	
	public RolloverButton()
	{
		setBorder(new EtchedBorder());
		setBorderPainted(false);
		setMargin(new Insets(0,0,0,0));

		setRequestFocusEnabled(false);

		addMouseListener(new MouseOverHandler());
	} 

	
	
	public RolloverButton(Icon icon)
	{
		this();

		setIcon(icon);
	} 

	
	public boolean isOpaque()
	{
		return false;
	} 

	
	public void setEnabled(boolean b)
	{
		super.setEnabled(b);
		setBorderPainted(false);
		repaint();
	} 

	
	public void paint(Graphics g)
	{
		if (isEnabled())
			super.paint(g);
		else
		{
			Graphics2D g2 = (Graphics2D)g;
			g2.setComposite(c);
			super.paint(g2);
		}
	} 

	private static AlphaComposite c = AlphaComposite.getInstance(
		AlphaComposite.SRC_OVER, 0.5f);

	
	
	class MouseOverHandler extends MouseAdapter
	{
		public void mouseEntered(MouseEvent e)
		{
			if (isEnabled())
				setBorderPainted(true);
		}

		public void mouseExited(MouseEvent e)
		{
			setBorderPainted(false);
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.pluginmgr.PluginListHandler,12,2,0,7,36,36,1,7,8,0.865612648,505,1.0,4,0.541666667,0.319444444,1,3,39.16666667,14,3.6667,0,"

package org.gjt.sp.jedit.pluginmgr;

import com.microstar.xml.*;
import java.io.*;
import java.util.Stack;
import org.gjt.sp.util.Log;

class PluginListHandler extends HandlerBase
{
	PluginListHandler(PluginList pluginList, String path)
	{
		this.pluginList = pluginList;
		this.path = path;
		stateStack = new Stack();
	}

	public Object resolveEntity(String publicId, String systemId)
	{
		if(""plugins.dtd"".equals(systemId))
		{
			
			
			
			return new StringReader(""<!-- -->"");

			
		}

		return null;
	}

	public void attribute(String aname, String value, boolean isSpecified)
	{
		aname = (aname == null) ? null : aname.intern();
		value = (value == null) ? null : value.intern();

		if(aname == ""NAME"")
			name = value;
		else if(aname == ""JAR"")
			jar = value;
		else if(aname == ""VERSION"")
			version = value;
		else if(aname == ""DATE"")
			date = value;
		else if(aname == ""OBSOLETE"")
			obsolete = (""TRUE"".equals(value));
		else if(aname == ""WHAT"")
			depWhat = value;
		else if(aname == ""FROM"")
			depFrom = value;
		else if(aname == ""TO"")
			depTo = value;
		else if(aname == ""PLUGIN"")
			depPlugin = value;
		else if(aname == ""SIZE"")
		{
			size = Integer.parseInt(value);
			if(size == 0)
				Log.log(Log.WARNING,this,""SIZE = 0"");
		}
	}

	public void doctypeDecl(String name, String publicId,
		String systemId) throws Exception
	{
		if(""PLUGINS"".equals(name))
			return;

		Log.log(Log.ERROR,this,path + "": DOCTYPE must be PLUGINS"");
	}

	public void charData(char[] c, int off, int len)
	{
		String tag = peekElement();
		String text = new String(c, off, len);

		if(tag == ""DESCRIPTION"")
		{
			description = text;
		}
		else if(tag == ""PLUGIN_SET_ENTRY"")
			pluginSetEntry = text;
		else if(tag == ""AUTHOR"")
		{
			if(author != null && author.length() != 0)
				author = author + "", "" + text;
			else
				author = text;
		}
		else if(tag == ""DOWNLOAD"")
			download = text;
		else if(tag == ""DOWNLOAD_SOURCE"")
			downloadSource = text;
	}

	public void startElement(String tag)
	{
		tag = pushElement(tag);

		if(tag == ""PLUGIN_SET"")
		{
			description = null;
			pluginSet = new PluginList.PluginSet();
			pluginSet.name = name;
		}
		else if(tag == ""PLUGIN"")
		{
			description = null;
			author = null;
			branch = null;
			plugin = new PluginList.Plugin();
		}
		else if(tag == ""BRANCH"")
		{
			download = null;
			branch = new PluginList.Branch();
		}
		else if(tag == ""DOWNLOAD"")
			downloadSize = size;
		else if(tag == ""DOWNLOAD_SOURCE"")
			downloadSourceSize = size;
	}

	public void endElement(String tag)
	{
		if(tag == null)
			return;
		else
			tag = tag.intern();

		popElement();

		if(tag == ""PLUGIN_SET"")
		{
			pluginList.addPluginSet(pluginSet);
			pluginSet = null;
			pluginSetEntry = null;
		}
		else if(tag == ""PLUGIN_SET_ENTRY"")
		{
			pluginSet.plugins.addElement(pluginSetEntry);
			pluginSetEntry = null;
		}
		else if(tag == ""PLUGIN"")
		{
			plugin.jar = jar;
			plugin.name = name;
			plugin.author = author;
			plugin.description = description;
			pluginList.addPlugin(plugin);
			jar = null;
			name = null;
			author = null;
		}
		else if(tag == ""BRANCH"")
		{
			branch.version = version;
			branch.date = date;
			branch.download = download;
			branch.downloadSize = downloadSize;
			branch.downloadSource = downloadSource;
			branch.downloadSourceSize = downloadSourceSize;
			branch.obsolete = obsolete;
			plugin.branches.addElement(branch);
			version = null;
			download = null;
			obsolete = false;
		}
		else if(tag == ""DEPEND"")
		{
			PluginList.Dependency dep = new PluginList.Dependency(
				depWhat,depFrom,depTo,depPlugin);
			branch.deps.addElement(dep);
			depWhat = null;
			depFrom = null;
			depTo = null;
			depPlugin = null;
		}
	}

	public void startDocument()
	{
		try
		{
			pushElement(null);
		}
		catch (Exception e)
		{
			e.printStackTrace();
		}
	}

	public void endDocument()
	{
		pluginList.finished();
	}
	

	
	private String path;

	private PluginList pluginList;

	private PluginList.PluginSet pluginSet;
	private String pluginSetEntry;

	private PluginList.Plugin plugin;
	private String jar;
	private String author;

	private PluginList.Branch branch;
	private boolean obsolete;
	private String version;
	private String date;
	private String download;
	private int downloadSize;
	private String downloadSource;
	private int downloadSourceSize;
	private int size;
	private String depWhat;
	private String depFrom;
	private String depTo;
	private String depPlugin;

	private String name;
	private String description;

	private Stack stateStack;

	private String pushElement(String name)
	{
		name = (name == null) ? null : name.intern();

		stateStack.push(name);

		return name;
	}

	private String peekElement()
	{
		return (String) stateStack.peek();
	}

	private String popElement()
	{
		return (String) stateStack.pop();
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.msg.SearchSettingsChanged,1,2,0,5,2,0,3,2,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.EBComponent;
import org.gjt.sp.jedit.EBMessage;


public class SearchSettingsChanged extends EBMessage
{
	
	public SearchSettingsChanged(EBComponent source)
	{
		super(source);
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.IndentFoldHandler,2,2,0,2,6,1,1,2,2,2.0,65,0.0,0,0.888888889,0.625,0,0,31.5,7,3.5,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;


public class IndentFoldHandler extends FoldHandler
{
	public IndentFoldHandler()
	{
		super(""indent"");
	}

	
	
	public int getFoldLevel(Buffer buffer, int lineIndex, Segment seg)
	{
		int tabSize = buffer.getTabSize();

		buffer.getLineText(lineIndex,seg);

		int offset = seg.offset;
		int count = seg.count;

		int whitespace = 0;

		boolean seenNonWhiteSpace = false;

loop:		for(int i = 0; i < count; i++)
		{
			switch(seg.array[offset + i])
			{
			case ' ':
				whitespace++;
				break;
			case '\t':
				whitespace += (tabSize - whitespace % tabSize);
				break;
			default:
				seenNonWhiteSpace = true;
				break loop;
			}
		}

		if(!seenNonWhiteSpace)
		{
			
			if(lineIndex != 0)
				return buffer.getFoldLevel(lineIndex - 1);
			else
				return 0;
		}
			return whitespace;
	} 
}
"
jEdit,4.1,org.gjt.sp.util.ReadWriteLock,9,1,0,2,17,2,1,1,6,0.678571429,236,1.0,0,0.0,1.0,0,0,24.44444444,5,2.8889,0,"

package org.gjt.sp.util;

import java.util.Vector;


public class ReadWriteLock
{
	
	public synchronized void readLock()
	{
		
		
		if (activeReaders != 0 || allowRead())
		{
			++activeReaders;
			
			return;
		}
		++waitingReaders;
		while (!allowRead())
		{
			try
			{
				wait();
			}
			catch (InterruptedException e)
			{
				--waitingReaders; 
				Log.log(Log.ERROR,this,e);
				return;
			}
		}
		--waitingReaders;
		++activeReaders;
		readers.addElement(Thread.currentThread());
	} 

	
	public synchronized void readUnlock()
	{
		if(activeReaders == 0)
			throw new InternalError(""Unbalanced readLock()/readUnlock() calls"");

		--activeReaders;
		
		notifyAll();
	} 

	
	public synchronized void writeLock()
	{
		if (writerThread != null)
		{
			
			if (Thread.currentThread() == writerThread)
			{
				
				++lockCount;
				return;
			}
		}
		if (allowWrite())
		{
			claimWriteLock();
			return;
		}

		++waitingWriters;
		while (!allowWrite())
		{
			try
			{
				wait();
			}
			catch (InterruptedException e)
			{
				--waitingWriters;
				Log.log(Log.ERROR,this,e);
				return;
			}
		}
		--waitingWriters;
		claimWriteLock();
	} 

	
	public synchronized void writeUnlock()
	{
		if(activeWriters != 1 || lockCount <= 0)
			throw new InternalError(""Unbalanced writeLock()/writeUnlock() calls"");

		if(Thread.currentThread() != writerThread)
			throw new InternalError(""writeUnlock() from wrong thread"");

		if (--lockCount == 0)
		{
			--activeWriters;
			writerThread = null;
			notifyAll();
		}
	} 

	
	public synchronized boolean isWriteLocked()
	{
		
		return activeWriters == 1;
	} 

	

	
	private int activeReaders;
	private int activeWriters;
	private int waitingReaders;
	private int waitingWriters;
	private Vector readers = new Vector();

	private Thread writerThread;
	private int lockCount;
	

	
	private final boolean allowRead()
	{
		return (Thread.currentThread() == writerThread)
			|| (waitingWriters == 0 && activeWriters == 0);
	} 

	
	private final boolean allowWrite()
	{
		

		return activeReaders == 0 && activeWriters == 0;
	} 

	
	private void claimWriteLock()
	{
		++activeWriters;
		
		writerThread = Thread.currentThread();
		
		lockCount = 1;
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.OptionGroup,9,1,0,6,20,0,4,2,9,0.5,112,1.0,0,0.0,0.259259259,0,0,11.22222222,3,1.5556,0,"

package org.gjt.sp.jedit;

import java.util.Enumeration;
import java.util.Vector;

import org.gjt.sp.util.Log;


public class OptionGroup
{
	
	public OptionGroup(String name)
	{
		this.name = name;
		members = new Vector();
	}

	public String getName()
	{
		return name;
	}

	public void addOptionGroup(OptionGroup group)
	{
		if (members.indexOf(group) != -1) return;

		members.addElement(group);
	}

	public void addOptionPane(OptionPane pane)
	{
		if (members.indexOf(pane) != -1) return;

		members.addElement(pane);
	}

	public Enumeration getMembers()
	{
		return members.elements();
	}

	public Object getMember(int index)
	{
		return (index >= 0 && index < members.size())
			? members.elementAt(index) : null;
	}

	public int getMemberIndex(Object member)
	{
		return members.indexOf(member);
	}

	public int getMemberCount()
	{
		return members.size();
	}

	public void save()
	{
		Enumeration enum = members.elements();

		while (enum.hasMoreElements())
		{
			Object elem = enum.nextElement();
			try
			{
				if (elem instanceof OptionPane)
				{
					((OptionPane)elem).save();
				}
				else if (elem instanceof OptionGroup)
				{
					((OptionGroup)elem).save();
				}
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR, elem,
					""Error saving option pane"");
				Log.log(Log.ERROR, elem, t);
			}
		}
	}

	private String name;
	private Vector members;
}
"
jEdit,4.1,org.gjt.sp.jedit.OptionPane,4,1,0,6,4,6,6,0,4,2.0,4,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit;

import java.awt.Component;


public interface OptionPane
{
	
	String getName();

	
	Component getComponent();

	
	void init();

	
	void save();
}
"
jEdit,4.1,org.gjt.sp.util.WorkRequest,5,1,4,5,11,10,4,1,5,2.0,48,0.0,0,0.0,0.45,0,0,8.6,2,1.6,0,"

package org.gjt.sp.util;


public abstract class WorkRequest implements Runnable
{
	
	public void setAbortable(boolean abortable)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setAbortable(abortable);
	}

	
	public void setStatus(String status)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setStatus(status);
	}

	
	public void setProgressValue(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressValue(value);
	}

	
	public void setProgressMaximum(int value)
	{
		Thread thread = Thread.currentThread();
		if(thread instanceof WorkThread)
			((WorkThread)thread).setProgressMaximum(value);
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.pluginmgr.InstallPluginsDialog,14,7,0,12,98,43,4,11,2,0.866396761,1049,0.894736842,1,0.980568012,0.204081633,0,0,72.57142857,9,2.4286,0,"

package org.gjt.sp.jedit.pluginmgr;


import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.ArrayList;
import java.util.Vector;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.*;


class InstallPluginsDialog extends EnhancedDialog
{
	static final int INSTALL = 0;
	static final int UPDATE = 1;

	
	InstallPluginsDialog(JDialog dialog, Vector model, int mode)
	{
		super(dialog,
			(mode == INSTALL
			? jEdit.getProperty(""install-plugins.title"")
			: jEdit.getProperty(""update-plugins.title"")),true);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel label = new JLabel(jEdit.getProperty(""install-plugins.caption""));
		content.add(BorderLayout.NORTH,label);

		plugins = new JCheckBoxList(model);
		plugins.getSelectionModel().addListSelectionListener(new ListHandler());
		plugins.getModel().addTableModelListener(new TableModelHandler());
		JScrollPane scroller = new JScrollPane(plugins);
		scroller.setPreferredSize(new Dimension(200,0));
		content.add(BorderLayout.WEST,scroller);

		JPanel panel = new JPanel(new BorderLayout());
		panel.setBorder(new TitledBorder(jEdit.getProperty(""install-plugins""
			+ "".plugin-info"")));

		JPanel labelAndValueBox = new JPanel(new BorderLayout());

		JPanel labelBox = new JPanel(new GridLayout(
			(mode == UPDATE ? 7 : 6),1,0,3));
		labelBox.setBorder(new EmptyBorder(0,0,3,12));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.name""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.author""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.size""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.latest-version""),SwingConstants.RIGHT));
		if(mode == UPDATE)
		{
			labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
				+ "".info.installed-version""),SwingConstants.RIGHT));
		}
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.updated""),SwingConstants.RIGHT));
		labelBox.add(new JLabel(jEdit.getProperty(""install-plugins""
			+ "".info.description""),SwingConstants.RIGHT));
		labelAndValueBox.add(BorderLayout.WEST,labelBox);

		JPanel valueBox = new JPanel(new GridLayout(
			(mode == UPDATE ? 7 : 6),1,0,3));
		valueBox.setBorder(new EmptyBorder(0,0,3,0));
		valueBox.add(name = new JLabel());
		valueBox.add(author = new JLabel());
		valueBox.add(size = new JLabel());
		valueBox.add(latestVersion = new JLabel());
		if(mode == UPDATE)
			valueBox.add(installedVersion = new JLabel());
		valueBox.add(updated = new JLabel());
		valueBox.add(Box.createGlue());
		labelAndValueBox.add(BorderLayout.CENTER,valueBox);

		panel.add(BorderLayout.NORTH,labelAndValueBox);

		description = new JTextArea(6,50);
		description.setEditable(false);
		description.setLineWrap(true);
		description.setWrapStyleWord(true);

		panel.add(BorderLayout.CENTER,new JScrollPane(description));

		content.add(BorderLayout.CENTER,panel);

		panel = new JPanel(new BorderLayout(12,0));

		JPanel panel2 = new JPanel(new GridLayout((mode == INSTALL ? 4 : 2),1));

		Box totalSizeBox = new Box(BoxLayout.X_AXIS);
		totalSizeBox.add(new JLabel(jEdit.getProperty(""install-plugins.totalSize"")));
		totalSizeBox.add(Box.createHorizontalStrut(12));
		totalSizeBox.add(totalSize = new JLabel());
		panel2.add(totalSizeBox);

		panel2.add(downloadSource = new JCheckBox(
			jEdit.getProperty(""install-plugins.downloadSource"")));
		downloadSource.setSelected(jEdit.getBooleanProperty(""install-plugins""
			+ "".downloadSource.value""));
		downloadSource.addActionListener(new ActionHandler());

		if(mode == INSTALL)
		{
			ButtonGroup grp = new ButtonGroup();
			installUser = new JRadioButton();
			String settings = jEdit.getSettingsDirectory();
			if(settings == null)
			{
				settings = jEdit.getProperty(""install-plugins.none"");
				installUser.setEnabled(false);
			}
			else
			{
				settings = MiscUtilities.constructPath(settings,""jars"");
				installUser.setEnabled(true);
			}
			String[] args = { settings };
			installUser.setText(jEdit.getProperty(""install-plugins.user"",args));
			grp.add(installUser);
			panel2.add(installUser);

			installSystem = new JRadioButton();
			String jEditHome = jEdit.getJEditHome();
			if(jEditHome == null)
			{
				jEditHome = jEdit.getProperty(""install-plugins.none"");
				installSystem.setEnabled(false);
			}
			else
			{
				jEditHome = MiscUtilities.constructPath(jEditHome,""jars"");
				installSystem.setEnabled(true);
			}
			args[0] = jEditHome;
			installSystem.setText(jEdit.getProperty(""install-plugins.system"",args));
			grp.add(installSystem);
			panel2.add(installSystem);

			if(installUser.isEnabled())
				installUser.setSelected(true);
			else
				installSystem.setSelected(true);
		}

		panel.add(BorderLayout.NORTH,panel2);

		Box box = new Box(BoxLayout.X_AXIS);

		box.add(Box.createGlue());
		selectAll = new JButton(jEdit.getProperty(""install-plugins.select-all""));
		selectAll.addActionListener(new ActionHandler());
		box.add(selectAll);
		box.add(Box.createHorizontalStrut(6));

		install = new JButton(jEdit.getProperty(""install-plugins.install""));
		install.setEnabled(false);
		getRootPane().setDefaultButton(install);
		install.addActionListener(new ActionHandler());
		box.add(install);
		box.add(Box.createHorizontalStrut(6));

		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createHorizontalStrut(6));
		box.add(Box.createGlue());

		panel.add(BorderLayout.SOUTH,box);

		content.add(BorderLayout.SOUTH,panel);

		updateTotalSize();

		pack();
		setLocationRelativeTo(dialog);
		show();
	} 

	
	public void ok()
	{
		jEdit.setBooleanProperty(""install-plugins.downloadSource.value"",
			downloadSource.isSelected());
		dispose();
	} 

	
	public void cancel()
	{
		cancelled = true;

		dispose();
	} 

	
	void installPlugins(Roster roster)
	{
		if(cancelled)
			return;

		String installDirectory;
		if(installUser == null || installUser.isSelected())
		{
			installDirectory = MiscUtilities.constructPath(
				jEdit.getSettingsDirectory(),""jars"");
		}
		else
		{
			installDirectory = MiscUtilities.constructPath(
				jEdit.getJEditHome(),""jars"");
		}

		Object[] selected = plugins.getCheckedValues();
		for(int i = 0; i < selected.length; i++)
		{
			PluginList.Plugin plugin = (PluginList.Plugin)selected[i];
			plugin.install(roster,installDirectory,downloadSource.isSelected());
		}
	} 

	

	
	private JCheckBoxList plugins;
	private JLabel name;
	private JLabel author;
	private JLabel size;
	private JLabel latestVersion;
	private JLabel installedVersion;
	private JLabel updated;
	private JTextArea description;
	private JLabel totalSize;
	private JCheckBox downloadSource;
	private JRadioButton installUser;
	private JRadioButton installSystem;

	private JButton selectAll;
	private JButton install;
	private JButton cancel;

	private boolean cancelled;
	private Thread thread;
	

	
	private void updateInfo()
	{
		Object selected = plugins.getSelectedValue();
		if(selected instanceof PluginList.Plugin)
		{
			PluginList.Plugin plugin = (PluginList.Plugin)selected;
			PluginList.Branch branch = plugin.getCompatibleBranch();
			name.setText(plugin.name);
			author.setText(plugin.author);
			size.setText(String.valueOf(
				(downloadSource.isSelected()
				? branch.downloadSourceSize
				: branch.downloadSize) / 1024) + "" Kb"");
			if(branch.obsolete)
				latestVersion.setText(jEdit.getProperty(
					""install-plugins.info.obsolete""));
			else
				latestVersion.setText(branch.version);
			if(installedVersion != null)
				installedVersion.setText(plugin.installedVersion);
			updated.setText(branch.date);

			ArrayList deps = new ArrayList();
			createDependencyList(branch.deps,deps);
			StringBuffer buf = new StringBuffer();
			for(int i = 0; i < deps.size(); i++)
			{
				buf.append(""\n- "");
				buf.append(deps.get(i));
			}

			description.setText(plugin.description
				+ (buf.length() == 0 ? """"
				: jEdit.getProperty(""install-plugins.info""
				+ "".also-install"") + buf.toString()
				+ (branch.obsolete ? jEdit.getProperty(
				""install-plugins.info.obsolete-text"") : """")));
			description.setCaretPosition(0);
		}
		else
		{
			name.setText(null);
			author.setText(null);
			size.setText(null);
			latestVersion.setText(null);
			if(installedVersion != null)
				installedVersion.setText(null);
			updated.setText(null);
			description.setText(null);
		}
	} 

	
	private void createDependencyList(Vector deps, ArrayList append)
	{
		for(int i = 0; i < deps.size(); i++)
		{
			PluginList.Dependency dep = (PluginList.Dependency)
				deps.elementAt(i);
			if(dep.what.equals(""plugin"")
				&& !dep.isSatisfied())
			{
				if(!append.contains(dep.plugin))
				{
					append.add(dep.plugin);

					PluginList.Branch branch = dep.plugin
						.getCompatibleBranch();
					createDependencyList(branch.deps,append);
				}
			}
		}
	} 

	
	private void updateTotalSize()
	{
		ArrayList selectedPlugins = new ArrayList();

		Object[] selected = plugins.getCheckedValues();
		install.setEnabled(selected.length != 0);

		for(int i = 0; i < selected.length; i++)
		{
			PluginList.Plugin plugin = (PluginList.Plugin)selected[i];
			if(!selectedPlugins.contains(plugin))
				selectedPlugins.add(plugin);

			createDependencyList(plugin.getCompatibleBranch().deps,
				selectedPlugins);
		}

		int _totalSize = 0;
		for(int i = 0; i < selectedPlugins.size(); i++)
		{
			PluginList.Branch branch = ((PluginList.Plugin)
				selectedPlugins.get(i)).getCompatibleBranch();
			_totalSize += (downloadSource.isSelected()
				? branch.downloadSourceSize
				: branch.downloadSize);
		}

		totalSize.setText(String.valueOf(_totalSize / 1024) + "" Kb"");
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == selectAll)
				plugins.selectAll();
			if(source == install)
				ok();
			else if(source == cancel)
				cancel();
			else if(source == downloadSource)
			{
				updateInfo();
				updateTotalSize();
			}
		}
	} 

	
	class ListHandler implements ListSelectionListener
	{
		public void valueChanged(ListSelectionEvent evt)
		{
			updateInfo();
		}
	} 

	
	class TableModelHandler implements TableModelListener
	{
		public void tableChanged(TableModelEvent e)
		{
			updateTotalSize();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.DisplayTokenHandler,5,2,1,8,11,6,2,6,4,0.75,81,1.0,1,0.666666667,0.288888889,1,2,14.0,2,1.0,0,"

package org.gjt.sp.jedit.syntax;


import javax.swing.text.*;
import java.awt.font.*;
import org.gjt.sp.jedit.syntax.*;



public class DisplayTokenHandler extends DefaultTokenHandler
{
	
	public void init(Segment seg, SyntaxStyle[] styles,
		FontRenderContext fontRenderContext,
		TabExpander expander)
	{
		super.init();

		x = 0.0f;

		this.seg = seg;
		this.styles = styles;
		this.fontRenderContext = fontRenderContext;
		this.expander = expander;
	} 

	
	public void setMonospacedCharWidth(float charWidth)
	{
		this.charWidth = charWidth;
	} 

	
	
	public Chunk getChunks()
	{
		return (Chunk)firstToken;
	} 

	
	protected Segment seg;
	protected SyntaxStyle[] styles;
	protected FontRenderContext fontRenderContext;
	protected TabExpander expander;
	protected float x;
	protected float charWidth;

	
	protected Token createToken(byte id, int offset, int length,
		TokenMarker.LineContext context)
	{
		if(id == Token.END)
			return null;

		Chunk chunk = new Chunk(id,offset,length,getParserRuleSet(context));
		chunk.init(seg,expander,x,styles,fontRenderContext,
			context.rules.getDefault(),charWidth);

		x += chunk.width;

		return chunk;
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.browser.BrowserListener,2,1,0,4,2,1,3,2,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.browser;

import java.util.EventListener;

import org.gjt.sp.jedit.io.VFS;


public interface BrowserListener extends EventListener
{
	
	void filesSelected(VFSBrowser browser, VFS.DirectoryEntry[] files);

	
	void filesActivated(VFSBrowser browser, VFS.DirectoryEntry[] files);
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.ContentManager,11,1,0,2,17,0,2,0,8,0.225,387,1.0,0,0.0,0.436363636,0,0,33.81818182,4,1.8182,0,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;


public class ContentManager
{
	
	public ContentManager()
	{
		text = new char[1024];
	} 

	
	public final int getLength()
	{
		return length;
	} 

	
	public String getText(int start, int len)
	{
		if(start >= gapStart)
			return new String(text,start + gapEnd - gapStart,len);
		else if(start + len <= gapStart)
			return new String(text,start,len);
		else
		{
			return new String(text,start,gapStart - start)
				.concat(new String(text,gapEnd,start + len - gapStart));
		}
	} 

	
	public void getText(int start, int len, Segment seg)
	{
		if(start >= gapStart)
		{
			seg.array = text;
			seg.offset = start + gapEnd - gapStart;
			seg.count = len;
		}
		else if(start + len <= gapStart)
		{
			seg.array = text;
			seg.offset = start;
			seg.count = len;
		}
		else
		{
			seg.array = new char[len];

			
			System.arraycopy(text,start,seg.array,0,gapStart - start);

			
			System.arraycopy(text,gapEnd,seg.array,gapStart - start,
				len + start - gapStart);

			seg.offset = 0;
			seg.count = len;
		}
	} 

	
	public void insert(int start, String str)
	{
		int len = str.length();
		moveGapStart(start);
		if(gapEnd - gapStart < len)
		{
			ensureCapacity(length + len + 1024);
			moveGapEnd(start + len + 1024);
		}

		str.getChars(0,len,text,start);
		gapStart += len;
		length += len;
	} 

	
	public void insert(int start, Segment seg)
	{
		moveGapStart(start);
		if(gapEnd - gapStart < seg.count)
		{
			ensureCapacity(length + seg.count + 1024);
			moveGapEnd(start + seg.count + 1024);
		}

		System.arraycopy(seg.array,seg.offset,text,start,seg.count);
		gapStart += seg.count;
		length += seg.count;
	} 

	
	public void _setContent(char[] text, int length)
	{
		this.text = text;
		this.gapStart = this.gapEnd = 0;
		this.length = length;
	} 

	
	public void remove(int start, int len)
	{
		moveGapStart(start);
		gapEnd += len;
		length -= len;
	} 

	
	private char[] text;
	private int gapStart;
	private int gapEnd;
	private int length;

	
	private void moveGapStart(int newStart)
	{
		int newEnd = gapEnd + (newStart - gapStart);

		if(newStart == gapStart)
		{
			
		}
		else if(newStart > gapStart)
		{
			System.arraycopy(text,gapEnd,text,gapStart,
				newStart - gapStart);
		}
		else if(newStart < gapStart)
		{
			System.arraycopy(text,newStart,text,newEnd,
				gapStart - newStart);
		}

		gapStart = newStart;
		gapEnd = newEnd;
	} 

	
	private void moveGapEnd(int newEnd)
	{
		System.arraycopy(text,gapEnd,text,newEnd,length - gapStart);
		gapEnd = newEnd;
	} 

	
	private void ensureCapacity(int capacity)
	{
		if(capacity >= text.length)
		{
			char[] textN = new char[capacity * 2];
			System.arraycopy(text,0,textN,0,length + (gapEnd - gapStart));
			text = textN;
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.util.WorkThreadPool,21,1,0,14,50,90,13,5,9,0.8625,660,0.6875,5,0.0,0.169312169,0,0,29.66666667,14,3.1429,1,"

package org.gjt.sp.util;


import javax.swing.event.EventListenerList;
import javax.swing.SwingUtilities;



public class WorkThreadPool
{
	
	
	public WorkThreadPool(String name, int count)
	{
		listenerList = new EventListenerList();

		if(count != 0)
		{
			threadGroup = new ThreadGroup(name);
			threads = new WorkThread[count];
			for(int i = 0; i < threads.length; i++)
			{
				threads[i] = new WorkThread(this,threadGroup,name + "" #"" + (i+1));
			}
		}
		else
			Log.log(Log.WARNING,this,""Async I/O disabled"");
	} 

	
	
	public void start()
	{
		synchronized(lock)
		{
			started = true;

			if(awtRequestCount != 0 && requestCount == 0)
				queueAWTRunner();
		}

		if(threads != null)
		{
			for(int i = 0; i < threads.length; i++)
			{
				threads[i].start();
			}
		}
	} 

	
	
	public void addWorkRequest(Runnable run, boolean inAWT)
	{
		if(threads == null)
		{
			run.run();
			return;
		}

		synchronized(lock)
		{
			
			if(started && inAWT && requestCount == 0 && awtRequestCount == 0)
			{


				if(SwingUtilities.isEventDispatchThread())
					run.run();
				else
					SwingUtilities.invokeLater(run);

				return;
			} 

			Request request = new Request(run);

			
			if(inAWT)
			{
				if(firstAWTRequest == null && lastAWTRequest == null)
					firstAWTRequest = lastAWTRequest = request;
				else
				{
					lastAWTRequest.next = request;
					lastAWTRequest = request;
				}

				awtRequestCount++;

				
				
				
				if(started && requestCount == 0)
					queueAWTRunner();
			} 
			
			else
			{
				if(firstRequest == null && lastRequest == null)
					firstRequest = lastRequest = request;
				else
				{
					lastRequest.next = request;
					lastRequest = request;
				}

				requestCount++;
			} 

			lock.notify();
		}
	} 

	
	
	public void waitForRequests()
	{
		if(threads == null)
			return;

		synchronized(waitForAllLock)
		{
			while(requestCount != 0)
			{
				try
				{
					waitForAllLock.wait();
				}
				catch(InterruptedException ie)
				{
					Log.log(Log.ERROR,this,ie);
				}
			}
		}

		if(SwingUtilities.isEventDispatchThread())
		{
			
			doAWTRequests();
		}
		else
		{
			try
			{
				SwingUtilities.invokeAndWait(new RunRequestsInAWTThread());
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);
			}
		}
	} 

	
	
	public int getRequestCount()
	{
		return requestCount;
	} 

	
	
	public int getThreadCount()
	{
		if(threads == null)
			return 0;
		else
			return threads.length;
	} 

	
	
	public WorkThread getThread(int index)
	{
		return threads[index];
	} 

	
	
	public void addProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.add(WorkThreadProgressListener.class,listener);
	} 

	
	
	public void removeProgressListener(WorkThreadProgressListener listener)
	{
		listenerList.remove(WorkThreadProgressListener.class,listener);
	} 

	
	Object lock = new String(""Work thread pool request queue lock"");
	Object waitForAllLock = new String(""Work thread pool waitForAll() notifier"");

	
	void fireStatusChanged(WorkThread thread)
	{
		final Object[] listeners = listenerList.getListenerList();
		if(listeners.length != 0)
		{
			int index = 0;
			for(int i = 0; i < threads.length; i++)
			{
				if(threads[i] == thread)
				{
					index = i;
					break;
				}
			}

			for(int i = listeners.length - 2; i >= 0; i--)
			{
				if(listeners[i] == WorkThreadProgressListener.class)
				{
					((WorkThreadProgressListener)listeners[i+1])
						.statusUpdate(WorkThreadPool.this,index);
				}
			}
		}
	} 

	
	void fireProgressChanged(WorkThread thread)
	{
		final Object[] listeners = listenerList.getListenerList();
		if(listeners.length != 0)
		{
			int index = 0;
			for(int i = 0; i < threads.length; i++)
			{
				if(threads[i] == thread)
				{
					index = i;
					break;
				}
			}

			for(int i = listeners.length - 2; i >= 0; i--)
			{
				if(listeners[i] == WorkThreadProgressListener.class)
				{
					((WorkThreadProgressListener)listeners[i+1])
						.progressUpdate(WorkThreadPool.this,index);
				}
			}
		}
	} 

	
	void requestDone()
	{
		synchronized(lock)
		{
			requestCount--;

			if(requestCount == 0 && firstAWTRequest != null)
				queueAWTRunner();
		}
	} 

	
	Request getNextRequest()
	{
		synchronized(lock)
		{
			Request request = firstRequest;
			if(request == null)
				return null;

			firstRequest = firstRequest.next;
			if(firstRequest == null)
				lastRequest = null;

			if(request.alreadyRun)
				throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
			request.alreadyRun = true;

			

			return request;
		}
	} 

	

	

	
	private boolean started;
	private ThreadGroup threadGroup;
	private WorkThread[] threads;

	
	private Request firstRequest;
	private Request lastRequest;
	private int requestCount;

	
	private boolean awtRunnerQueued;
	private Request firstAWTRequest;
	private Request lastAWTRequest;
	private int awtRequestCount;

	private EventListenerList listenerList;
	

	
	private void doAWTRequests()
	{
		while(firstAWTRequest != null)
		{
			doAWTRequest(getNextAWTRequest());
		}
	} 

	
	private void doAWTRequest(Request request)
	{


		try
		{
			request.run.run();
		}
		catch(Throwable t)
		{
			Log.log(Log.ERROR,WorkThread.class,""Exception ""
				+ ""in AWT thread:"");
			Log.log(Log.ERROR,WorkThread.class,t);
		}

		awtRequestCount--;
	} 

	
	private void queueAWTRunner()
	{
		if(!awtRunnerQueued)
		{
			awtRunnerQueued = true;
			SwingUtilities.invokeLater(new RunRequestsInAWTThread());

		}
	} 

	
	private Request getNextAWTRequest()
	{
		Request request = firstAWTRequest;
		firstAWTRequest = firstAWTRequest.next;
		if(firstAWTRequest == null)
			lastAWTRequest = null;

		if(request.alreadyRun)
			throw new InternalError(""AIEE!!! Request run twice!!! "" + request.run);
		request.alreadyRun = true;

		

		return request;
	} 

	

	static int ID;

	
	static class Request
	{
		int id = ++ID;

		Runnable run;

		boolean alreadyRun;

		Request next;

		Request(Runnable run)
		{
			this.run = run;
		}

		public String toString()
		{
			return ""[id="" + id + "",run="" + run + ""]"";
		}
	} 

	
	class RunRequestsInAWTThread implements Runnable
	{
		public void run()
		{
			synchronized(lock)
			{
				awtRunnerQueued = false;
				if(requestCount == 0)
					doAWTRequests();
			}
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.Autosave,4,1,0,3,13,4,1,3,3,0.666666667,62,1.0,0,0.0,0.333333333,0,0,14.25,4,2.25,3,"

package org.gjt.sp.jedit;

import javax.swing.Timer;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import org.gjt.sp.util.Log;


class Autosave implements ActionListener
{
	public static void setInterval(int interval)
	{
		if(interval == 0)
		{
			if(timer != null)
			{
				timer.stop();
				timer = null;
			}

			return;
		}

		interval *= 1000;

		if(timer == null)
		{
			timer = new Timer(interval,new Autosave());
			timer.start();
		}
		else
			timer.setDelay(interval);
	}

	public static void stop()
	{
		if(timer != null)
			timer.stop();
	}

	public void actionPerformed(ActionEvent evt)
	{
		
		

		
		if(jEdit.getFirstView() != null)
			jEdit.saveOpenFiles(jEdit.getFirstView());

		Buffer[] bufferArray = jEdit.getBuffers();
		for(int i = 0; i < bufferArray.length; i++)
			bufferArray[i].autosave();
	}

	
	private static Timer timer;

	private Autosave() {}
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.CompleteWord,17,5,0,16,94,106,4,16,3,0.770833333,554,1.0,3,0.974276527,0.215686275,3,4,31.23529412,15,2.5294,5,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.util.Vector;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;


public class CompleteWord extends JWindow
{
	
	public static void completeWord(View view)
	{
		JEditTextArea textArea = view.getTextArea();
		Buffer buffer = view.getBuffer();
		int caretLine = textArea.getCaretLine();
		int caret = textArea.getCaretPosition();

		if(!buffer.isEditable())
		{
			textArea.getToolkit().beep();
			return;
		}

		KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);
		String noWordSep = getNonAlphaNumericWordChars(buffer,keywordMap,caret);
		String word = getWordToComplete(buffer,caretLine,caret,noWordSep);
		if(word == null)
		{
			textArea.getToolkit().beep();
			return;
		}

		Vector completions = getCompletions(buffer,word,keywordMap,
			noWordSep,caret);

		if(completions.size() == 0
			|| (completions.size() == 1 &&
			((Completion)completions.get(0)).text.equals(word)))
		{
			textArea.getToolkit().beep();
		}
		
		else if(completions.size() == 1)
		{
			textArea.setSelectedText(completions
				.elementAt(0).toString()
				.substring(word.length()));
		} 
		
		else
		{
			textArea.scrollToCaret(false);
			Point location = textArea.offsetToXY(caret - word.length());
			location.y += textArea.getPainter().getFontMetrics()
				.getHeight();

			SwingUtilities.convertPointToScreen(location,
				textArea.getPainter());
			new CompleteWord(view,word,completions,location,noWordSep);
		} 
	} 

	
	public CompleteWord(View view, String word, Vector completions, Point location,
		String noWordSep)
	{
		super(view);

		this.noWordSep = noWordSep;

		setContentPane(new JPanel(new BorderLayout())
		{
			
			public boolean isManagingFocus()
			{
				return false;
			}

			
			public boolean getFocusTraversalKeysEnabled()
			{
				return false;
			}
		});

		this.view = view;
		this.textArea = view.getTextArea();
		this.buffer = view.getBuffer();
		this.word = word;

		words = new JList(completions);
		words.setFont(UIManager.getFont(""TextArea.font""));

		words.setVisibleRowCount(Math.min(completions.size(),8));

		words.addMouseListener(new MouseHandler());
		words.setSelectedIndex(0);
		words.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		words.setCellRenderer(new Renderer());

		
		
		JScrollPane scroller = new JScrollPane(words,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);

		getContentPane().add(scroller, BorderLayout.CENTER);

		GUIUtilities.requestFocus(this,words);

		pack();
		setLocation(location);
		show();

		KeyHandler keyHandler = new KeyHandler();
		addKeyListener(keyHandler);
		words.addKeyListener(keyHandler);
		view.setKeyEventInterceptor(keyHandler);
	} 

	
	public void dispose()
	{
		view.setKeyEventInterceptor(null);
		super.dispose();
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				textArea.requestFocus();
			}
		});
	} 

	

	
	private static String getNonAlphaNumericWordChars(Buffer buffer,
		KeywordMap keywordMap, int caret)
	{
		
		
		String noWordSep = buffer.getStringProperty(""noWordSep"");
		if(noWordSep == null)
			noWordSep = """";
		if(keywordMap != null)
		{
			String keywordNoWordSep = keywordMap.getNonAlphaNumericChars();
			if(keywordNoWordSep != null)
				noWordSep = noWordSep + keywordNoWordSep;
		}

		return noWordSep;
	} 

	
	private static String getWordToComplete(Buffer buffer, int caretLine,
		int caret, String noWordSep)
	{
		String line = buffer.getLineText(caretLine);
		int dot = caret - buffer.getLineStartOffset(caretLine);
		if(dot == 0)
			return null;

		char ch = line.charAt(dot-1);
		if(!Character.isLetterOrDigit(ch)
			&& noWordSep.indexOf(ch) == -1)
		{
			
			return null;
		}

		int wordStart = TextUtilities.findWordStart(line,dot-1,noWordSep);
		String word = line.substring(wordStart,dot);
		if(word.length() == 0)
			return null;

		return word;
	} 

	
	private static Vector getCompletions(Buffer buffer, String word,
		KeywordMap keywordMap, String noWordSep, int caret)
	{
		Vector completions = new Vector();

		int wordLen = word.length();

		
		if(keywordMap != null)
		{
			String[] keywords = keywordMap.getKeywords();
			for(int i = 0; i < keywords.length; i++)
			{
				String _keyword = keywords[i];
				if(_keyword.regionMatches(keywordMap.getIgnoreCase(),
					0,word,0,wordLen))
				{
					Completion keyword = new Completion(_keyword,true);
					if(completions.indexOf(keyword) == -1)
						completions.addElement(keyword);
				}
			}
		} 

		
		for(int i = 0; i < buffer.getLineCount(); i++)
		{
			String line = buffer.getLineText(i);
			int start = buffer.getLineStartOffset(i);

			

			if(line.startsWith(word) && caret != start + word.length())
			{
				String _word = completeWord(line,0,noWordSep);
				Completion comp = new Completion(_word,false);

				
				if(completions.indexOf(comp) == -1)
					completions.addElement(comp);
			}

			
			int len = line.length() - word.length();
			for(int j = 0; j < len; j++)
			{
				char c = line.charAt(j);
				if(!Character.isLetterOrDigit(c) && noWordSep.indexOf(c) == -1)
				{
					if(line.regionMatches(j + 1,word,0,wordLen)
						&& caret != start + j + word.length() + 1)
					{
						String _word = completeWord(line,j + 1,noWordSep);
						Completion comp = new Completion(_word,false);

						
						if(completions.indexOf(comp) == -1)
							completions.addElement(comp);
					}
				}
			}
		} 

		
		MiscUtilities.quicksort(completions,new MiscUtilities.StringICaseCompare());

		return completions;
	} 

	
	private static String completeWord(String line, int offset, String noWordSep)
	{
		
		int wordEnd = TextUtilities.findWordEnd(line,offset + 1,noWordSep);
		return line.substring(offset,wordEnd);
	} 

	
	private View view;
	private JEditTextArea textArea;
	private Buffer buffer;
	private String word;
	private JList words;
	private String noWordSep;
	

	
	private void insertSelected()
	{
		textArea.setSelectedText(words.getSelectedValue().toString()
			.substring(word.length()));
		dispose();
	} 

	

	
	static class Completion
	{
		String text;
		boolean keyword;

		Completion(String text, boolean keyword)
		{
			this.text = text;
			this.keyword = keyword;
		}

		public String toString()
		{
			return text;
		}

		public boolean equals(Object obj)
		{
			if(obj instanceof Completion)
				return ((Completion)obj).text.equals(text);
			else
				return false;
		}
	} 

	
	static class Renderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(JList list, Object value,
			int index, boolean isSelected, boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,value,index,
				isSelected,cellHasFocus);

			Completion comp = (Completion)value;
			if(comp.keyword)
				setFont(list.getFont().deriveFont(Font.BOLD));
			else
				setFont(list.getFont());

			return this;
		}
	} 

	
	class KeyHandler extends KeyAdapter
	{
		
		public void keyPressed(KeyEvent evt)
		{
			switch(evt.getKeyCode())
			{
			case KeyEvent.VK_TAB:
			case KeyEvent.VK_ENTER:
				insertSelected();
				evt.consume();
				break;
			case KeyEvent.VK_ESCAPE:
				dispose();
				evt.consume();
				break;
			case KeyEvent.VK_UP:
				int selected = words.getSelectedIndex();

				if(selected == 0)
					selected = words.getModel().getSize() - 1;
				else if(getFocusOwner() == words)
					return;
				else
					selected = selected - 1;

				words.setSelectedIndex(selected);
				words.ensureIndexIsVisible(selected);

				evt.consume();
				break;
			case KeyEvent.VK_DOWN:
				 selected = words.getSelectedIndex();

				if(selected == words.getModel().getSize() - 1)
					selected = 0;
				else if(getFocusOwner() == words)
					return;
				else
					selected = selected + 1;

				words.setSelectedIndex(selected);
				words.ensureIndexIsVisible(selected);

				evt.consume();
				break;
			case KeyEvent.VK_BACK_SPACE:
				if(word.length() == 1)
				{
					textArea.backspace();
					evt.consume();
					dispose();
				}
				else
				{
					word = word.substring(0,word.length() - 1);
					textArea.backspace();
					int caret = textArea.getCaretPosition();
					KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);

					Vector completions = getCompletions(buffer,word,
						keywordMap,noWordSep,caret);

					if(completions.size() == 0)
						dispose();

					words.setListData(completions);
					words.setSelectedIndex(0);
					words.setVisibleRowCount(Math.min(completions.size(),8));

					pack();

					evt.consume();
				}
				break;
			default:
				if(evt.isActionKey())
				{
					dispose();
					view.processKeyEvent(evt);
				}
				break;
			}
		} 

		
		public void keyTyped(KeyEvent evt)
		{
			char ch = evt.getKeyChar();
			evt = KeyEventWorkaround.processKeyEvent(evt);
			if(evt == null)
				return;
			else if(ch != '\b')
			{
				textArea.userInput(ch);

				if(!Character.isLetterOrDigit(ch) && noWordSep.indexOf(ch) == -1)
				{
					dispose();
					return;
				}

				word = word + ch;
				int caret = textArea.getCaretPosition();
				KeywordMap keywordMap = buffer.getKeywordMapAtOffset(caret);

				Vector completions = getCompletions(buffer,word,keywordMap,
					noWordSep,caret);

				if(completions.size() == 0)
				{
					dispose();
					return;
				}

				words.setListData(completions);
				words.setSelectedIndex(0);
			}
		} 
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseClicked(MouseEvent evt)
		{
			insertSelected();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.msg.ViewUpdate,5,2,0,6,13,4,4,3,4,0.875,52,0.25,0,0.5,0.5,1,1,8.6,1,0.6,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class ViewUpdate extends EBMessage
{
	
	public static final Object CREATED = ""CREATED"";

	
	public static final Object CLOSED = ""CLOSED"";

	
	public static final Object EDIT_PANE_CHANGED = ""EDIT_PANE_CHANGED"";

	
	
	public ViewUpdate(View view, Object what)
	{
		super(view);

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
	} 

	
	
	public Object getWhat()
	{
		return what;
	} 

	
	
	public View getView()
	{
		return (View)getSource();
	} 

	
	public String paramString()
	{
		return ""what="" + what + "","" + super.paramString();
	} 

	
	private Object what;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.TipOfTheDay,8,7,0,6,60,20,2,6,3,0.8,294,1.0,0,0.989441931,0.375,2,5,35.125,5,1.375,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.EmptyBorder;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.io.*;
import java.util.Random;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


public class TipOfTheDay extends EnhancedDialog
{
	
	public TipOfTheDay(View view)
	{
		super(view,jEdit.getProperty(""tip.title""),false);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel label = new JLabel(jEdit.getProperty(""tip.caption""));
		label.setFont(new Font(""SansSerif"",Font.PLAIN,24));
		label.setForeground(UIManager.getColor(""Button.foreground""));
		content.add(BorderLayout.NORTH,label);

		tipText = new JEditorPane();
		tipText.setEditable(false);
		tipText.setContentType(""text/html"");

		nextTip();

		JScrollPane scroller = new JScrollPane(tipText);
		scroller.setPreferredSize(new Dimension(150,150));
		content.add(BorderLayout.CENTER,scroller);

		ActionHandler actionHandler = new ActionHandler();

		Box buttons = new Box(BoxLayout.X_AXIS);

		showNextTime = new JCheckBox(jEdit.getProperty(""tip.show-next-time""),
			jEdit.getBooleanProperty(""tip.show""));
		showNextTime.addActionListener(actionHandler);
		buttons.add(showNextTime);

		buttons.add(Box.createHorizontalStrut(6));
		buttons.add(Box.createGlue());

		nextTip = new JButton(jEdit.getProperty(""tip.next-tip""));
		nextTip.addActionListener(actionHandler);
		buttons.add(nextTip);

		buttons.add(Box.createHorizontalStrut(6));

		close = new JButton(jEdit.getProperty(""common.close""));
		close.addActionListener(actionHandler);
		buttons.add(close);
		content.getRootPane().setDefaultButton(close);

		Dimension dim = nextTip.getPreferredSize();
		dim.width = Math.max(dim.width,close.getPreferredSize().width);
		nextTip.setPreferredSize(dim);
		close.setPreferredSize(dim);

		content.add(BorderLayout.SOUTH,buttons);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	

	
	private JCheckBox showNextTime;
	private JButton nextTip, close;
	private JEditorPane tipText;
	private int currentTip = -1;
	

	
	private void nextTip()
	{
		File[] tips = new File(MiscUtilities.constructPath(
			jEdit.getJEditHome(),""doc"",""tips"")).listFiles();
		if(tips == null || tips.length == 0)
		{
			tipText.setText(jEdit.getProperty(""tip.not-found""));
			return;
		}

		int count = tips.length;

		
		
		int tipToShow = currentTip;
		while(tipToShow == currentTip || !tips[tipToShow].getName().endsWith("".html""))
			tipToShow = Math.abs(new Random().nextInt()) % count;
		try
		{
			tipText.setPage(tips[tipToShow].toURL());
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
		}
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			Object source = evt.getSource();
			if(source == showNextTime)
			{
				jEdit.setBooleanProperty(""tip.show"",showNextTime
					.isSelected());
			}
			else if(source == nextTip)
				nextTip();
			else if(source == close)
				dispose();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.OperatingSystem,13,1,0,27,31,34,26,1,11,0.962962963,237,0.888888889,0,0.0,0.083333333,0,0,16.53846154,3,1.9231,1,"

package org.gjt.sp.jedit;

import java.awt.Rectangle;
import java.awt.Toolkit;
import javax.swing.UIManager;
import java.io.File;
import org.gjt.sp.util.Log;


public class OperatingSystem
{
	public static final Rectangle getScreenBounds()
	{
		int screenX = (int)Toolkit.getDefaultToolkit().getScreenSize().getWidth();
		int screenY = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight();
		int x, y, w, h;
		
		if (isMacOS())
		{
			x = 0;
			y = 22;
			w = screenX;
			h = screenY - y - 4;
		}
		else if (isWindows())
		{
			x = -4;
			y = -4;
			w = screenX - 2*x;
			h = screenY - 2*y;
		}
		else
		{
			x = 0;
			y = 0;
			w = screenX;
			h = screenY;
		}
		
		return new Rectangle(x,y,w,h);
	}
	
	
	
	public static final boolean isDOSDerived()
	{
		return isWindows() || isOS2();
	} 

	
	
	public static final boolean isWindows()
	{
		return os == WINDOWS_9x || os == WINDOWS_NT;
	} 

	
	
	public static final boolean isWindows9x()
	{
		return os == WINDOWS_9x;
	} 

	
	
	public static final boolean isWindowsNT()
	{
		return os == WINDOWS_NT;
	} 

	
	
	public static final boolean isOS2()
	{
		return os == OS2;
	} 

	
	
	public static final boolean isUnix()
	{
		return os == UNIX || os == MAC_OS_X;
	} 

	
	
	public static final boolean isMacOS()
	{
		return os == MAC_OS_X;
	} 

	
        
        public static final boolean isMacOSLF()
        {
                return (isMacOS() && UIManager.getLookAndFeel().isNativeLookAndFeel());
        } 

	
	
	public static final boolean hasJava14()
	{
		return java14;
	} 

	
	private static final int UNIX = 0x31337;
	private static final int WINDOWS_9x = 0x640;
	private static final int WINDOWS_NT = 0x666;
	private static final int OS2 = 0xDEAD;
	private static final int MAC_OS_X = 0xABC;
	private static final int UNKNOWN = 0xBAD;

	private static int os;
	private static boolean java14;

	
	static
	{
		if(System.getProperty(""mrj.version"") != null)
		{
			os = MAC_OS_X;
		}
		else
		{
			String osName = System.getProperty(""os.name"");
			if(osName.indexOf(""Windows 9"") != -1
				|| osName.indexOf(""Windows M"") != -1)
			{
				os = WINDOWS_9x;
			}
			else if(osName.indexOf(""Windows"") != -1)
			{
				os = WINDOWS_NT;
			}
			else if(osName.indexOf(""OS/2"") != -1)
			{
				os = OS2;
			}
			else if(File.separatorChar == '/')
			{
				os = UNIX;
			}
			else
			{
				os = UNKNOWN;
				Log.log(Log.WARNING,OperatingSystem.class,
					""Unknown operating system: "" + osName);
			}
		}

		if(System.getProperty(""java.version"").compareTo(""1.4"") >= 0
			&& System.getProperty(""jedit.nojava14"") == null)
			java14 = true;
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.PanelWindowContainer,22,1,0,21,89,97,12,15,10,0.857142857,623,0.846153846,3,0.0,0.25,0,0,26.72727273,6,1.7727,2,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.plaf.metal.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.font.*;
import java.awt.geom.AffineTransform;
import java.awt.*;
import java.util.Vector;
import org.gjt.sp.jedit.*;



public class PanelWindowContainer implements DockableWindowContainer
{
	
	public PanelWindowContainer(DockableWindowManager wm, String position)
	{
		this.wm = wm;
		this.position = position;

		
		buttons = new JPanel(new ButtonLayout());
		buttons.setBorder(new EmptyBorder(1,1,1,1));

		
		
		
		
		

		closeBox = new JButton(GUIUtilities.loadIcon(""closebox.gif""));
		closeBox.setRequestFocusEnabled(false);
		closeBox.setToolTipText(jEdit.getProperty(""view.docking.close-tooltip""));
		if(OperatingSystem.isMacOSLF())
			closeBox.putClientProperty(""JButton.buttonType"",""toolbar"");

		
		int left;
		if(position.equals(DockableWindowManager.RIGHT)
			|| position.equals(DockableWindowManager.LEFT))
			left = 1;
		else
			left = 0;

		closeBox.setMargin(new Insets(0,left,0,0));
		buttons.add(closeBox);

		closeBox.addActionListener(new ActionHandler());
		closeBox.addMouseListener(new MouseHandler());

		popupButton = new JButton(GUIUtilities.loadIcon(""ToolbarMenu.gif""));
		popupButton.setRequestFocusEnabled(false);
		popupButton.setToolTipText(jEdit.getProperty(""view.docking.menu-tooltip""));
		if(OperatingSystem.isMacOSLF())
			popupButton.putClientProperty(""JButton.buttonType"",""toolbar"");
		buttons.add(popupButton);

		popupButton.addMouseListener(new MouseHandler());

		buttonGroup = new ButtonGroup();
		
		buttonGroup.add(nullButton = new JToggleButton());
		

		dockables = new Vector();
		dockablePanel = new DockablePanel();

		dimension = jEdit.getIntegerProperty(
			""view.dock."" + position + "".dimension"",0);

		buttons.addMouseListener(new MouseHandler());
	} 

	
	public void register(final DockableWindowManager.Entry entry)
	{
		dockables.addElement(entry);

		
		int rotation;
		if(position.equals(DockableWindowManager.TOP)
			|| position.equals(DockableWindowManager.BOTTOM))
			rotation = RotatedTextIcon.NONE;
		else if(position.equals(DockableWindowManager.LEFT))
			rotation = RotatedTextIcon.CCW;
		else if(position.equals(DockableWindowManager.RIGHT))
			rotation = RotatedTextIcon.CW;
		else
			throw new InternalError(""Invalid position: "" + position);

		JToggleButton button = new JToggleButton();
		button.setMargin(new Insets(0,0,0,0));
		button.setRequestFocusEnabled(false);
		button.setIcon(new RotatedTextIcon(rotation,button.getFont(),
			entry.title));
		button.setActionCommand(entry.factory.name);
		button.addActionListener(new ActionHandler());
		if(OperatingSystem.isMacOSLF())
			button.putClientProperty(""JButton.buttonType"",""toolbar"");
		

		buttonGroup.add(button);
		buttons.add(button);

		button.addMouseListener(new MouseHandler());

		wm.revalidate();
	} 

	
	public void add(DockableWindowManager.Entry entry)
	{
		dockablePanel.add(entry.factory.name,entry.win);
	} 

	
	public void remove(DockableWindowManager.Entry entry)
	{
		if(entry.factory.name.equals(mostRecent))
			mostRecent = null;

		int index = dockables.indexOf(entry);
		buttons.remove(index + 2);

		dockables.removeElement(entry);
		if(entry.win != null)
			dockablePanel.remove(entry.win);

		if(current == entry)
		{
			current = null;
			show(null);
		}
		else
			wm.revalidate();
	} 

	
	public void save(DockableWindowManager.Entry entry) {}
	

	
	public void showMostRecent()
	{
		if(dockables.size() == 0)
		{
			Toolkit.getDefaultToolkit().beep();
			return;
		}

		if(mostRecent == null)
		{
			mostRecent = ((DockableWindowManager.Entry)
				dockables.get(0)).factory.name;
		}

		wm.showDockableWindow(mostRecent);
	} 

	
	public void show(final DockableWindowManager.Entry entry)
	{
		if(current == entry)
		{
			if(entry != null)
			{
				entry.win.requestFocus();
				entry.win.requestDefaultFocus();
			}
			return;
		}

		if(current == null)
		{
			
			dockablePanel.setBorder(new DockBorder(position));
		}

		if(entry != null)
		{
			mostRecent = entry.factory.name;
			this.current = entry;

			dockablePanel.showDockable(entry.factory.name);

			int index = dockables.indexOf(entry);
			((JToggleButton)buttons.getComponent(index + 2)).setSelected(true);

			entry.win.requestFocus();
			entry.win.requestDefaultFocus();
		}
		else
		{
			current = null;
			nullButton.setSelected(true);
			
			dockablePanel.setBorder(null);

			wm.getView().getTextArea().requestFocus();
		}

		wm.revalidate();
		dockablePanel.repaint();
	} 

	
	public boolean isVisible(DockableWindowManager.Entry entry)
	{
		return current == entry;
	} 

	
	public DockableWindowManager.Entry getCurrent()
	{
		return current;
	} 

	
	public String[] getDockables()
	{
		String[] retVal = new String[dockables.size()];
		for(int i = 0; i < dockables.size(); i++)
		{
			DockableWindowManager.Entry entry =
				(DockableWindowManager.Entry) dockables.elementAt(i);
			retVal[i] = entry.factory.name;
		}
		return retVal;
	} 

	
	static final int SPLITTER_WIDTH = 10;
	DockablePanel dockablePanel;

	
	void save()
	{
		jEdit.setIntegerProperty(""view.dock."" + position + "".dimension"",
			dimension);
		if(current == null)
			jEdit.unsetProperty(""view.dock."" + position + "".last"");
		else
		{
			jEdit.setProperty(""view.dock."" + position + "".last"",
				current.factory.name);
		}
	} 

	
	JPanel getButtonBox()
	{
		return buttons;
	} 

	
	DockablePanel getDockablePanel()
	{
		return dockablePanel;
	} 

	
	void setDimension(int dimension)
	{
		if(dimension != 0)
			this.dimension = dimension - SPLITTER_WIDTH - 3;
	} 

	

	
	private DockableWindowManager wm;
	private String position;
	private JPanel buttons;
	private JButton closeBox;
	private JButton popupButton;
	private ButtonGroup buttonGroup;
	private JToggleButton nullButton;
	private int dimension;
	private Vector dockables;
	private DockableWindowManager.Entry current;

	
	private String mostRecent;
	

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == closeBox)
				show(null);
			else
			{
				if(wm.isDockableWindowVisible(evt.getActionCommand()))
					show(null);
				else
					wm.showDockableWindow(evt.getActionCommand());
			}
		}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		JPopupMenu popup;

		public void mousePressed(MouseEvent evt)
		{
			if(evt.getSource() == popupButton
				|| GUIUtilities.isPopupTrigger(evt))
			{
				if(popup != null && popup.isVisible())
					popup.setVisible(false);
				else
				{
					popup = createPopupMenu();
					GUIUtilities.showPopupMenu(popup,
						(Component)evt.getSource(),
						evt.getX(),evt.getY());
				}
			}
		}

		private JPopupMenu createPopupMenu()
		{
			JPopupMenu popup = new JPopupMenu();
			JMenu floatMenu = new JMenu(jEdit.getProperty(""view.docking.menu-float""));

			String[] dockables = getDockables();
			for(int i = 0; i < dockables.length; i++)
			{
				final String entry = dockables[i];
				JMenuItem selectMenuItem = new JMenuItem(wm.getDockableTitle(entry));

				selectMenuItem.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent evt)
					{
						wm.showDockableWindow(entry);
					}
				});

				JMenuItem floatMenuItem = new JMenuItem(wm.getDockableTitle(entry));

				floatMenuItem.addActionListener(new ActionListener()
				{
					public void actionPerformed(ActionEvent evt)
					{
						wm.floatDockableWindow(entry);
					}
				});

				popup.add(selectMenuItem);
				floatMenu.add(floatMenuItem);
			}

			popup.addSeparator();
			popup.add(floatMenu);

			popup.addSeparator();
			JMenuItem config = new JMenuItem(jEdit.getProperty(""view.docking.menu-config""));
			config.addActionListener(new ActionListener()
			{
				public void actionPerformed(ActionEvent evt)
				{
					new org.gjt.sp.jedit.options.GlobalOptions(
						wm.getView(),""docking"");
				}
			});
			popup.add(config);

			return popup;
		}
	} 

	
	static class DockBorder implements Border
	{
		String position;
		Insets insets;
		Color color1;
		Color color2;
		Color color3;

		
		DockBorder(String position)
		{
			this.position = position;
			insets = new Insets(
				position.equals(DockableWindowManager.BOTTOM)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManager.RIGHT)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManager.TOP)
					? SPLITTER_WIDTH : 0,
				position.equals(DockableWindowManager.LEFT)
					? SPLITTER_WIDTH : 0);
		} 

		
		public void paintBorder(Component c, Graphics g,
			int x, int y, int width, int height)
		{
			updateColors();

			if(color1 == null || color2 == null || color3 == null)
				return;

			if(position.equals(DockableWindowManager.BOTTOM))
				paintHorizBorder(g,x,y,width);
			else if(position.equals(DockableWindowManager.RIGHT))
				paintVertBorder(g,x,y,height);
			else if(position.equals(DockableWindowManager.TOP))
			{
				paintHorizBorder(g,x,y + height
					- SPLITTER_WIDTH,width);
			}
			else if(position.equals(DockableWindowManager.LEFT))
			{
				paintVertBorder(g,x + width
					- SPLITTER_WIDTH,y,height);
			}
		} 

		
		public Insets getBorderInsets(Component c)
		{
			return insets;
		} 

		
		public boolean isBorderOpaque()
		{
			return false;
		} 

		
		private void paintHorizBorder(Graphics g, int x, int y, int width)
		{
			g.setColor(color3);
			g.fillRect(x,y,width,SPLITTER_WIDTH);

			for(int i = 0; i < width / 4 - 1; i++)
			{
				g.setColor(color1);
				g.drawLine(x + i * 4 + 2,y + 3,
					x + i * 4 + 2,y + 3);
				g.setColor(color2);
				g.drawLine(x + i * 4 + 3,y + 4,
					x + i * 4 + 3,y + 4);
				g.setColor(color1);
				g.drawLine(x + i * 4 + 4,y + 5,
					x + i * 4 + 4,y + 5);
				g.setColor(color2);
				g.drawLine(x + i * 4 + 5,y + 6,
					x + i * 4 + 5,y + 6);
			}
		} 

		
		private void paintVertBorder(Graphics g, int x, int y, int height)
		{
			g.setColor(color3);
			g.fillRect(x,y,SPLITTER_WIDTH,height);

			for(int i = 0; i < height / 4 - 1; i++)
			{
				g.setColor(color1);
				g.drawLine(x + 3,y + i * 4 + 2,
					x + 3,y + i * 4 + 2);
				g.setColor(color2);
				g.drawLine(x + 4,y + i * 4 + 3,
					x + 4,y + i * 4 + 3);
				g.setColor(color1);
				g.drawLine(x + 5,y + i * 4 + 4,
					x + 5,y + i * 4 + 4);
				g.setColor(color2);
				g.drawLine(x + 6,y + i * 4 + 5,
					x + 6,y + i * 4 + 5);
			}
		} 

		
		private void updateColors()
		{
			if(UIManager.getLookAndFeel() instanceof MetalLookAndFeel)
			{
				color1 = MetalLookAndFeel.getControlHighlight();
				color2 = MetalLookAndFeel.getControlDarkShadow();
				color3 = MetalLookAndFeel.getControl();
			}
			else
			{
				color1 = color2 = color3 = null;
			}
		} 
	} 

	
	public static class RotatedTextIcon implements Icon
	{
		public static final int NONE = 0;
		public static final int CW = 1;
		public static final int CCW = 2;

		
		public RotatedTextIcon(int rotate, Font font, String text)
		{
			this.rotate = rotate;
			this.font = font;

			FontRenderContext fontRenderContext
				= new FontRenderContext(null,true,true);
			this.text = text;
			glyphs = font.createGlyphVector(fontRenderContext,text);
			width = (int)glyphs.getLogicalBounds().getWidth() + 4;
			

			LineMetrics lineMetrics = font.getLineMetrics(text,fontRenderContext);
			ascent = lineMetrics.getAscent();
			height = (int)lineMetrics.getHeight();

			renderHints = new RenderingHints(
				RenderingHints.KEY_ANTIALIASING,
				RenderingHints.VALUE_ANTIALIAS_ON);
			renderHints.put(RenderingHints.KEY_FRACTIONALMETRICS,
				RenderingHints.VALUE_FRACTIONALMETRICS_ON);
			renderHints.put(RenderingHints.KEY_RENDERING,
				RenderingHints.VALUE_RENDER_QUALITY);
		} 

		
		public int getIconWidth()
		{
			return (int)(rotate == RotatedTextIcon.CW
				|| rotate == RotatedTextIcon.CCW
				? height : width);
		} 

		
		public int getIconHeight()
		{
			return (int)(rotate == RotatedTextIcon.CW
				|| rotate == RotatedTextIcon.CCW
				? width : height);
		} 

		
		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			Graphics2D g2d = (Graphics2D)g;
			g2d.setFont(font);
			AffineTransform oldTransform = g2d.getTransform();
			RenderingHints oldHints = g2d.getRenderingHints();

			g2d.setRenderingHints(renderHints);
			g2d.setColor(c.getForeground());

			
			if(rotate == RotatedTextIcon.NONE)
			{
				g2d.drawGlyphVector(glyphs,x + 2,y + ascent);
			} 
			
			else if(rotate == RotatedTextIcon.CW)
			{
				AffineTransform trans = new AffineTransform();
				trans.concatenate(oldTransform);
				trans.translate(x,y + 2);
				trans.rotate(Math.PI / 2,
					height / 2, width / 2);
				g2d.setTransform(trans);
				g2d.drawGlyphVector(glyphs,(height - width) / 2,
					(width - height) / 2
					+ ascent);
			} 
			
			else if(rotate == RotatedTextIcon.CCW)
			{
				AffineTransform trans = new AffineTransform();
				trans.concatenate(oldTransform);
				trans.translate(x,y - 2);
				trans.rotate(Math.PI * 3 / 2,
					height / 2, width / 2);
				g2d.setTransform(trans);
				g2d.drawGlyphVector(glyphs,(height - width) / 2,
					(width - height) / 2
					+ ascent);
			} 

			g2d.setTransform(oldTransform);
			g2d.setRenderingHints(oldHints);
		} 

		
		private int rotate;
		private Font font;
		private String text;
		private GlyphVector glyphs;
		private float width;
		private float height;
		private float ascent;
		private RenderingHints renderHints;
		
	} 

	
	class ButtonLayout implements LayoutManager
	{
		
		public void addLayoutComponent(String name, Component comp) {} 

		
		public void removeLayoutComponent(Component comp) {} 

		
		public Dimension preferredLayoutSize(Container parent)
		{
			Insets insets = ((JComponent)parent).getBorder()
				.getBorderInsets((JComponent)parent);

			Component[] comp = parent.getComponents();
			if(comp.length == 2)
			{
				
				return new Dimension(0,0);
			}
			else
			{
				if(position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM))
				{
					return new Dimension(0,
						comp[2].getPreferredSize().height
						+ insets.top
						+ insets.bottom);
				}
				else
				{
					return new Dimension(
						comp[2].getPreferredSize().width
						+ insets.left + insets.right,0);
				}
			}
		} 

		
		public Dimension minimumLayoutSize(Container parent)
		{
			return preferredLayoutSize(parent);
		} 

		
		public void layoutContainer(Container parent)
		{
			Insets insets = ((JComponent)parent).getBorder()
				.getBorderInsets((JComponent)parent);

			Component[] comp = parent.getComponents();
			if(comp.length != 2)
			{
				boolean closeBoxSizeSet = false;
				boolean noMore = false;
				popupButton.setVisible(false);

				Dimension parentSize = parent.getSize();
				int pos = (position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM)
					) ? 0 : insets.left;

				for(int i = 2; i < comp.length; i++)
				{
					Dimension size = comp[i].getPreferredSize();
					if(position.equals(DockableWindowManager.TOP)
						|| position.equals(DockableWindowManager.BOTTOM))
					{
						if(!closeBoxSizeSet)
						{
							closeBox.setBounds(pos,
								insets.top,
								size.height,size.height);
							pos += size.height;
							closeBoxSizeSet = true;
						}

						if(noMore || pos + size.width > parentSize.width
							- (i == comp.length - 1
							? 0 : closeBox.getWidth()))
						{
							popupButton.setBounds(
								parentSize.width - size.height
								- insets.right,
								insets.top,size.height,
								size.height);
							popupButton.setVisible(true);
							comp[i].setVisible(false);
							noMore = true;
						}
						else
						{
							comp[i].setBounds(pos,insets.top,
								size.width,size.height);
							comp[i].setVisible(true);
							pos += size.width;
						}
					}
					else
					{
						if(!closeBoxSizeSet)
						{
							closeBox.setBounds(insets.left,
								insets.top,size.width,size.width);
							pos += size.width;
							closeBoxSizeSet = true;
						}

						if(noMore || pos + size.height > parentSize.height
							- (i == comp.length - 1
							? 0 : closeBox.getHeight()))
						{
							popupButton.setBounds(
								insets.top,
								parentSize.height - size.width,
								size.width,size.width);
							popupButton.setVisible(true);
							comp[i].setVisible(false);
							noMore = true;
						}
						else
						{
							comp[i].setBounds(insets.left,
								pos,size.width,size.height);
							comp[i].setVisible(true);
							pos += size.height;
						}
					}
				}
			}
		} 
	} 

	
	class DockablePanel extends JPanel
	{
		
		DockablePanel()
		{
			super(new CardLayout());

			ResizeMouseHandler resizeMouseHandler = new ResizeMouseHandler();
			addMouseListener(resizeMouseHandler);
			addMouseMotionListener(resizeMouseHandler);
		} 

		
		PanelWindowContainer getWindowContainer()
		{
			return PanelWindowContainer.this;
		} 

		
		void showDockable(String name)
		{
			((CardLayout)getLayout()).show(this,name);
		} 

		
		public Dimension getMinimumSize()
		{
			return new Dimension(0,0);
		} 

		
		public Dimension getPreferredSize()
		{
			if(current == null)
				return new Dimension(0,0);
			else
			{
				if(dimension <= 0)
				{
					int width = super.getPreferredSize().width;
					dimension = width - SPLITTER_WIDTH - 3;
				}

				if(position.equals(DockableWindowManager.TOP)
					|| position.equals(DockableWindowManager.BOTTOM))
				{
					return new Dimension(0,
						dimension + SPLITTER_WIDTH + 3);
				}
				else
				{
					return new Dimension(dimension + SPLITTER_WIDTH + 3,
						0);
				}
			}
		} 

		
		class ResizeMouseHandler extends MouseAdapter implements MouseMotionListener
		{
			boolean canDrag;
			int dragStartDimension;
			Point dragStart;

			
			public void mousePressed(MouseEvent evt)
			{
				dragStartDimension = dimension;
				dragStart = evt.getPoint();
			} 

			
			public void mouseMoved(MouseEvent evt)
			{
				Border border = getBorder();
				if(border == null)
				{
					
					return;
				}

				Insets insets = border.getBorderInsets(DockablePanel.this);
				int cursor = Cursor.DEFAULT_CURSOR;
				canDrag = false;
				
				if(position.equals(DockableWindowManager.TOP))
				{
					if(evt.getY() >= getHeight() - insets.bottom)
					{
						cursor = Cursor.N_RESIZE_CURSOR;
						canDrag = true;
					}
				} 
				
				else if(position.equals(DockableWindowManager.LEFT))
				{
					if(evt.getX() >= getWidth() - insets.right)
					{
						cursor = Cursor.W_RESIZE_CURSOR;
						canDrag = true;
					}
				} 
				
				else if(position.equals(DockableWindowManager.BOTTOM))
				{
					if(evt.getY() <= insets.top)
					{
						cursor = Cursor.S_RESIZE_CURSOR;
						canDrag = true;
					}
				} 
				
				else if(position.equals(DockableWindowManager.RIGHT))
				{
					if(evt.getX() <= insets.left)
					{
						cursor = Cursor.E_RESIZE_CURSOR;
						canDrag = true;
					}
				} 

				setCursor(Cursor.getPredefinedCursor(cursor));
			} 

			
			public void mouseDragged(MouseEvent evt)
			{
				if(!canDrag)
					return;

				if(dragStart == null) 
					return;

				
				if(position.equals(DockableWindowManager.TOP))
				{
					dimension = evt.getY()
						+ dragStartDimension
						- dragStart.y;
				} 
				
				else if(position.equals(DockableWindowManager.LEFT))
				{
					dimension = evt.getX()
						+ dragStartDimension
						- dragStart.x;
				} 
				
				else if(position.equals(DockableWindowManager.BOTTOM))
				{
					dimension += (dragStart.y - evt.getY());
				} 
				
				else if(position.equals(DockableWindowManager.RIGHT))
				{
					dimension += (dragStart.x - evt.getX());
				} 

				if(dimension <= 0)
					dimension = dragStartDimension;

				wm.invalidate();
				wm.validate();
			} 

			
			public void mouseExited(MouseEvent evt)
			{
				setCursor(Cursor.getPredefinedCursor(
					Cursor.DEFAULT_CURSOR));
			} 
		} 
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.DockableWindowManager,31,5,0,29,83,267,21,16,23,0.921428571,751,0.571428571,5,0.957478006,0.20952381,0,0,22.77419355,12,2.3548,5,"

package org.gjt.sp.jedit.gui;


import bsh.EvalError;
import bsh.NameSpace;
import com.microstar.xml.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;
import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.util.*;



public class DockableWindowManager extends JPanel
{
	

	
	
	public static final String FLOATING = ""floating"";

	
	public static final String TOP = ""top"";

	
	public static final String LEFT = ""left"";

	
	public static final String BOTTOM = ""bottom"";

	
	public static final String RIGHT = ""right"";
	

	
	
	public static boolean loadDockableWindows(String path, Reader in, ActionSet actionSet)
	{
		try
		{
			

			DockableListHandler dh = new DockableListHandler(path,actionSet);
			XmlParser parser = new XmlParser();
			parser.setHandler(dh);
			parser.parse(null, null, in);
			return true;
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,jEdit.class,path + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}

		return false;
	} 

	
	public static void registerDockableWindow(String name, String code,
		boolean actions, ActionSet actionSet)
	{
		dockableWindowFactories.addElement(new Factory(name,code,
			actions,actionSet));
	} 

	
	public static String[] getRegisteredDockableWindows()
	{
		String[] retVal = new String[dockableWindowFactories.size()];
		for(int i = 0; i < dockableWindowFactories.size(); i++)
		{
			retVal[i] = ((Factory)dockableWindowFactories.elementAt(i)).name;
		}
		return retVal;
	} 

	
	static class DockableListHandler extends HandlerBase
	{
		
		DockableListHandler(String path, ActionSet actionSet)
		{
			this.path = path;
			this.actionSet = actionSet;
			stateStack = new Stack();
			actions = true;
		} 

		
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""dockables.dtd"".equals(systemId))
			{
				
				
				
				return new StringReader(""<!-- -->"");

				
			}

			return null;
		} 

		
		public void attribute(String aname, String value, boolean isSpecified)
		{
			aname = (aname == null) ? null : aname.intern();
			value = (value == null) ? null : value.intern();

			if(aname == ""NAME"")
				dockableName = value;
			else if(aname == ""NO_ACTIONS"")
				actions = (value == ""FALSE"");
		} 

		
		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""DOCKABLES"".equals(name))
				return;

			Log.log(Log.ERROR,this,path + "": DOCTYPE must be DOCKABLES"");
		} 

		
		public void charData(char[] c, int off, int len)
		{
			String tag = peekElement();
			String text = new String(c, off, len);

			if (tag == ""DOCKABLE"")
			{
				code = text;
			}
		} 

		
		public void startElement(String tag)
		{
			tag = pushElement(tag);
		} 

		
		public void endElement(String name)
		{
			if(name == null)
				return;

			String tag = peekElement();

			if(name.equals(tag))
			{
				if(tag == ""DOCKABLE"")
				{
					registerDockableWindow(dockableName,
						code,actions,actionSet);
					
					
					actions = true;
				}

				popElement();
			}
			else
			{
				
				throw new InternalError();
			}
		} 

		
		public void startDocument()
		{
			try
			{
				pushElement(null);
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		} 

		

		
		private String path;
		private ActionSet actionSet;

		private String dockableName;
		private String code;
		private boolean actions;

		private Stack stateStack;
		

		
		private String pushElement(String name)
		{
			name = (name == null) ? null : name.intern();

			stateStack.push(name);

			return name;
		} 

		
		private String peekElement()
		{
			return (String) stateStack.peek();
		} 

		
		private String popElement()
		{
			return (String) stateStack.pop();
		} 

		
	} 

	
	static class Factory
	{
		
		
		private static NameSpace nameSpace = new NameSpace(
			BeanShell.getNameSpace(),""dockable window"");

		String name;
		String code;

		
		Factory(String name, String code, boolean actions, ActionSet actionSet)
		{
			this.name = name;
			this.code = code;
			if(actions)
			{
				actionSet.addAction(new OpenAction());
				actionSet.addAction(new ToggleAction());
				actionSet.addAction(new FloatAction());
			}
		} 

		
		JComponent createDockableWindow(View view, String position)
		{
			try
			{
				BeanShell.getNameSpace().setVariable(
					""position"",position);
			}
			catch(EvalError e)
			{
				Log.log(Log.ERROR,this,e);
			}
			JComponent win = (JComponent)BeanShell.eval(view,
				nameSpace,code);
			return win;
		} 

		
		class OpenAction extends EditAction
		{
			
			OpenAction()
			{
				super(name);
			} 

			
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.showDockableWindow(name);
			} 

			
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".showDockableWindow(\"""" + name + ""\"");"";
			} 
		} 

		
		class ToggleAction extends EditAction
		{
			
			ToggleAction()
			{
				super(name + ""-toggle"");
			} 

			
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.toggleDockableWindow(name);
			} 

			
			public boolean isToggle()
			{
				return true;
			} 

			
			public boolean isSelected(View view)
			{
				return view.getDockableWindowManager()
					.isDockableWindowVisible(name);
			} 

			
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".toggleDockableWindow(\"""" + name + ""\"");"";
			} 

			
			public String getLabel()
			{
				String[] args = { jEdit.getProperty(name + "".label"") };
				return jEdit.getProperty(""view.docking.toggle.label"",args);
			} 
		} 

		
		class FloatAction extends EditAction
		{
			
			FloatAction()
			{
				super(name + ""-float"");
			} 

			
			public void invoke(View view)
			{
				view.getDockableWindowManager()
					.floatDockableWindow(name);
			} 

			
			public String getCode()
			{
				return ""view.getDockableWindowManager()""
					+ "".floatDockableWindow(\"""" + name + ""\"");"";
			} 

			
			public String getLabel()
			{
				String[] args = { jEdit.getProperty(name + "".label"") };
				return jEdit.getProperty(""view.docking.float.label"",args);
			} 
		} 
	} 

	private static Vector dockableWindowFactories;

	
	static
	{
		dockableWindowFactories = new Vector();
	} 

	

	

	
	
	public DockableWindowManager(View view)
	{
		setLayout(new DockableLayout());
		this.view = view;
		windows = new Hashtable();

		top = new PanelWindowContainer(this,TOP);
		left = new PanelWindowContainer(this,LEFT);
		bottom = new PanelWindowContainer(this,BOTTOM);
		right = new PanelWindowContainer(this,RIGHT);

		add(DockableLayout.TOP_BUTTONS,top.getButtonBox());
		add(DockableLayout.LEFT_BUTTONS,left.getButtonBox());
		add(DockableLayout.BOTTOM_BUTTONS,bottom.getButtonBox());
		add(DockableLayout.RIGHT_BUTTONS,right.getButtonBox());

		add(TOP,top.getDockablePanel());
		add(LEFT,left.getDockablePanel());
		add(BOTTOM,bottom.getDockablePanel());
		add(RIGHT,right.getDockablePanel());
	} 

	
	
	public void init()
	{
		for(int i = 0; i < dockableWindowFactories.size(); i++)
		{
			Factory factory = (Factory)
				dockableWindowFactories.elementAt(i);
			Entry e;
			if(view.isPlainView())
				e = new Entry(factory,FLOATING);
			else
				e = new Entry(factory);
			windows.put(factory.name,e);
		}

		if(!view.isPlainView())
		{
			String lastTop = jEdit.getProperty(""view.dock.top.last"");
			if(lastTop != null && lastTop.length() != 0)
				showDockableWindow(lastTop);

			String lastLeft = jEdit.getProperty(""view.dock.left.last"");
			if(lastLeft != null && lastLeft.length() != 0)
				showDockableWindow(lastLeft);

			String lastBottom = jEdit.getProperty(""view.dock.bottom.last"");
			if(lastBottom != null && lastBottom.length() != 0)
				showDockableWindow(lastBottom);

			String lastRight = jEdit.getProperty(""view.dock.right.last"");
			if(lastRight != null && lastRight.length() != 0)
				showDockableWindow(lastRight);
		}
	} 

	
	
	public View getView()
	{
		return view;
	} 

	
	
	public JComponent floatDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return null;
		}

		
		Entry newEntry = new Entry(entry.factory,FLOATING);
		newEntry.open();
		if(newEntry.win != null)
			newEntry.container.show(newEntry);
		return newEntry.win;
	} 

	
	
	public void showDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""Unknown dockable window: "" + name);
			return;
		}

		if(entry.win == null)
			entry.open();

		if(entry.win != null)
			entry.container.show(entry);
		else
			;
	} 

	
	
	public void addDockableWindow(String name)
	{
		showDockableWindow(name);
	} 

	
	
	public void removeDockableWindow(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
		{
			Log.log(Log.ERROR,this,""This DockableWindowManager""
				+ "" does not have a window named "" + name);
			return;
		}

		if(entry.win == null)
			return;

		if(entry.container instanceof FloatingWindowContainer)
		{
			entry.container.save(entry);
			entry.container.remove(entry);
			entry.container = null;
			entry.win = null;
		}
		else
			entry.container.show(null);
	} 

	
	
	public void toggleDockableWindow(String name)
	{
		if(isDockableWindowVisible(name))
			removeDockableWindow(name);
		else
			addDockableWindow(name);
	} 

	
	
	public JComponent getDockableWindow(String name)
	{
		return getDockable(name);
	} 

	
	
	public JComponent getDockable(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null || entry.win == null)
			return null;
		else
			return entry.win;
	} 

	
	
	public String getDockableTitle(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
			return null;
		else
			return entry.title;
	} 

	
	
	public boolean isDockableWindowVisible(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null || entry.win == null)
			return false;
		else
			return entry.container.isVisible(entry);
	} 

	
	
	public boolean isDockableWindowDocked(String name)
	{
		Entry entry = (Entry)windows.get(name);
		if(entry == null)
			return false;
		else
			return (entry.position != FLOATING);
	} 

	
	
	public void closeCurrentArea()
	{
		
		
		
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				Component comp = view.getFocusOwner();
				while(comp != null)
				{
					
					if(comp instanceof PanelWindowContainer
						.DockablePanel)
					{
						PanelWindowContainer container =
							((PanelWindowContainer.DockablePanel)
							comp).getWindowContainer();
						container.show(null);
						return;
					}

					comp = comp.getParent();
				}

				getToolkit().beep();
			}
		});
	} 

	
	
	public void close()
	{
		if(!view.isPlainView())
		{
			top.save();
			left.save();
			bottom.save();
			right.save();
		}

		Enumeration enum = windows.elements();
		while(enum.hasMoreElements())
		{
			Entry entry = (Entry)enum.nextElement();
			if(entry.win != null)
				entry.remove();
		}
	} 

	
	public PanelWindowContainer getTopDockingArea()
	{
		return top;
	} 

	
	public PanelWindowContainer getLeftDockingArea()
	{
		return left;
	} 

	
	public PanelWindowContainer getBottomDockingArea()
	{
		return bottom;
	} 

	
	public PanelWindowContainer getRightDockingArea()
	{
		return right;
	} 

	
	
	public void propertiesChanged()
	{
		alternateLayout = jEdit.getBooleanProperty(""view.docking.alternateLayout"");

		Enumeration enum = windows.elements();
		while(enum.hasMoreElements())
		{
			Entry entry = (Entry)enum.nextElement();

			if(!view.isPlainView())
			{
				String position = entry.position;
				String newPosition = jEdit.getProperty(entry.factory.name
					+ "".dock-position"");
				if(newPosition != null 
					&& !newPosition.equals(position))
				{
					entry.position = newPosition;
					if(entry.container != null)
					{
						entry.container.remove(entry);
						entry.container = null;
						entry.win = null;
					}

					if(newPosition.equals(FLOATING))
						;
					else
					{
						if(newPosition.equals(TOP))
							entry.container = top;
						else if(newPosition.equals(LEFT))
							entry.container = left;
						else if(newPosition.equals(BOTTOM))
							entry.container = bottom;
						else if(newPosition.equals(RIGHT))
							entry.container = right;
						else
							throw new InternalError(""Unknown position: "" + newPosition);

						entry.container.register(entry);
					}
				}
			}

			if(entry.container instanceof FloatingWindowContainer)
			{
				SwingUtilities.updateComponentTreeUI(((JFrame)entry.container)
					.getRootPane());
			}
		}
	} 

	
	private View view;
	private Hashtable windows;
	private boolean alternateLayout;
	private PanelWindowContainer left;
	private PanelWindowContainer right;
	private PanelWindowContainer top;
	private PanelWindowContainer bottom;
	

	

	
	public class DockableLayout implements LayoutManager2
	{
		
		
		static final String CENTER = BorderLayout.CENTER;

		public static final String TOP_TOOLBARS = ""top-toolbars"";
		public static final String BOTTOM_TOOLBARS = ""bottom-toolbars"";

		static final String TOP_BUTTONS = ""top-buttons"";
		static final String LEFT_BUTTONS = ""left-buttons"";
		static final String BOTTOM_BUTTONS = ""bottom-buttons"";
		static final String RIGHT_BUTTONS = ""right-buttons"";

		Component topToolbars, bottomToolbars;
		Component center;
		Component top, left, bottom, right;
		Component topButtons, leftButtons, bottomButtons, rightButtons;

		
		public void addLayoutComponent(String name, Component comp)
		{
			addLayoutComponent(comp,name);
		} 

		
		public void addLayoutComponent(Component comp, Object cons)
		{
			if(cons == null || CENTER.equals(cons))
				center = comp;
			else if(TOP_TOOLBARS.equals(cons))
				topToolbars = comp;
			else if(BOTTOM_TOOLBARS.equals(cons))
				bottomToolbars = comp;
			else if(TOP.equals(cons))
				top = comp;
			else if(LEFT.equals(cons))
				left = comp;
			else if(BOTTOM.equals(cons))
				bottom = comp;
			else if(RIGHT.equals(cons))
				right = comp;
			else if(TOP_BUTTONS.equals(cons))
				topButtons = comp;
			else if(LEFT_BUTTONS.equals(cons))
				leftButtons = comp;
			else if(BOTTOM_BUTTONS.equals(cons))
				bottomButtons = comp;
			else if(RIGHT_BUTTONS.equals(cons))
				rightButtons = comp;
		} 

		
		public void removeLayoutComponent(Component comp)
		{
			if(center == comp)
				center = null;
			if(comp == topToolbars)
				topToolbars = null;
			if(comp == bottomToolbars)
				bottomToolbars = null;
			{
				
				
				
				
			}
		} 

		
		public Dimension preferredLayoutSize(Container parent)
		{
			Dimension prefSize = new Dimension(0,0);
			Dimension _top = top.getPreferredSize();
			Dimension _left = left.getPreferredSize();
			Dimension _bottom = bottom.getPreferredSize();
			Dimension _right = right.getPreferredSize();
			Dimension _topButtons = topButtons.getPreferredSize();
			Dimension _leftButtons = leftButtons.getPreferredSize();
			Dimension _bottomButtons = bottomButtons.getPreferredSize();
			Dimension _rightButtons = rightButtons.getPreferredSize();
			Dimension _center = (center == null
				? new Dimension(0,0)
				: center.getPreferredSize());
			Dimension _topToolbars = (topToolbars == null
				? new Dimension(0,0)
				: topToolbars.getPreferredSize());
			Dimension _bottomToolbars = (bottomToolbars == null
				? new Dimension(0,0)
				: bottomToolbars.getPreferredSize());

			prefSize.height = _top.height + _bottom.height + _center.height
				+ _topButtons.height + _bottomButtons.height
				+ _topToolbars.height + _bottomToolbars.height;
			prefSize.width = _left.width + _right.width
				+ Math.max(_center.width,
				Math.max(_topToolbars.width,_bottomToolbars.width))
				+ _leftButtons.width + _rightButtons.width;

			return prefSize;
		} 

		
		public Dimension minimumLayoutSize(Container parent)
		{
			
			return preferredLayoutSize(parent);
		} 

		
		public Dimension maximumLayoutSize(Container parent)
		{
			return new Dimension(Integer.MAX_VALUE,Integer.MAX_VALUE);
		} 

		
		public void layoutContainer(Container parent)
		{
			Dimension size = parent.getSize();

			Dimension _topButtons = topButtons.getPreferredSize();
			Dimension _leftButtons = leftButtons.getPreferredSize();
			Dimension _bottomButtons = bottomButtons.getPreferredSize();
			Dimension _rightButtons = rightButtons.getPreferredSize();
			Dimension _topToolbars = (topToolbars == null
				? new Dimension(0,0)
				: topToolbars.getPreferredSize());
			Dimension _bottomToolbars = (bottomToolbars == null
				? new Dimension(0,0)
				: bottomToolbars.getPreferredSize());

			int _width = size.width - _leftButtons.width - _rightButtons.width;
			int _height = size.height - _topButtons.height - _bottomButtons.height;

			Dimension _top = top.getPreferredSize();
			Dimension _left = left.getPreferredSize();
			Dimension _bottom = bottom.getPreferredSize();
			Dimension _right = right.getPreferredSize();

			int topHeight = Math.min(Math.max(0,_height - _bottom.height),_top.height);
			int leftWidth = Math.min(Math.max(0,_width - _right.width),_left.width);
			int bottomHeight = Math.min(Math.max(0,_height - topHeight),_bottom.height);
			int rightWidth = Math.min(Math.max(0,_width - leftWidth),_right.width);

			DockableWindowManager.this.top.setDimension(topHeight);
			DockableWindowManager.this.left.setDimension(leftWidth);
			DockableWindowManager.this.bottom.setDimension(bottomHeight);
			DockableWindowManager.this.right.setDimension(rightWidth);

			if(alternateLayout)
			{
				topButtons.setBounds(
					_leftButtons.width,
					0,
					_width,
					_topButtons.height);

				leftButtons.setBounds(
					0,
					_topButtons.height + _top.height,
					_leftButtons.width,
					_height - _top.height - _bottom.height);

				bottomButtons.setBounds(
					_leftButtons.width,
					size.height - _bottomButtons.height,
					_width,
					_bottomButtons.height);

				rightButtons.setBounds(
					size.width - _rightButtons.width,
					_topButtons.height + _top.height,
					_rightButtons.width,
					_height - _top.height - _bottom.height);

				top.setBounds(
					_leftButtons.width,
					_topButtons.height,
					_width,
					topHeight);

				bottom.setBounds(
					_leftButtons.width,
					size.height - bottomHeight - _bottomButtons.height,
					_width,
					bottomHeight);

				left.setBounds(
					_leftButtons.width,
					_topButtons.height + topHeight,
					leftWidth,
					_height - topHeight - bottomHeight);

				right.setBounds(
					size.width - rightWidth - _rightButtons.width,
					_topButtons.height + topHeight,
					rightWidth,
					_height - topHeight - bottomHeight);
			}
			else
			{
				topButtons.setBounds(
					_leftButtons.width + leftWidth,
					0,
					_width - leftWidth - rightWidth,
					_topButtons.height);

				leftButtons.setBounds(
					0,
					_topButtons.height,
					_leftButtons.width,
					_height);

				bottomButtons.setBounds(
					_leftButtons.width + leftWidth,
					size.height - _bottomButtons.height,
					_width - leftWidth - rightWidth,
					_bottomButtons.height);

				rightButtons.setBounds(
					size.width - _rightButtons.width,
					_topButtons.height,
					_rightButtons.width,
					_height);

				top.setBounds(
					_leftButtons.width + leftWidth,
					_topButtons.height,
					_width - leftWidth - rightWidth,
					topHeight);
				bottom.setBounds(
					_leftButtons.width + leftWidth,
					size.height - bottomHeight - _bottomButtons.height,
					_width - leftWidth - rightWidth,
					bottomHeight);

				left.setBounds(
					_leftButtons.width,
					_topButtons.height,
					leftWidth,
					_height);

				right.setBounds(
					size.width - rightWidth - _rightButtons.width,
					_topButtons.height,
					rightWidth,
					_height);
			}

			if(topToolbars != null)
			{
				topToolbars.setBounds(
					_leftButtons.width + _left.width,
					_topButtons.height + _top.height,
					_width - _left.width - _right.width,
					_topToolbars.height);
			}

			if(bottomToolbars != null)
			{
				bottomToolbars.setBounds(
					_leftButtons.width + _left.width,
					_height - _bottom.height
					- _bottomToolbars.height
					+ _topButtons.height,
					_width - _left.width - _right.width,
					_bottomToolbars.height);
			}

			if(center != null)
			{
				center.setBounds(
					_leftButtons.width + _left.width,
					_topButtons.height + _top.height
					+ _topToolbars.height,
					_width - _left.width - _right.width,
					_height - _top.height - _bottom.height
					- _topToolbars.height
					- _bottomToolbars.height);
			}
		} 

		
		public float getLayoutAlignmentX(Container target)
		{
			return 0.5f;
		} 

		
		public float getLayoutAlignmentY(Container target)
		{
			return 0.5f;
		} 

		
		public void invalidateLayout(Container target) {}
		
	} 

	
	class Entry
	{
		Factory factory;
		String title;
		String position;
		DockableWindowContainer container;

		
		JComponent win;

		
		Entry(Factory factory)
		{
			this(factory,jEdit.getProperty(factory.name
				+ "".dock-position"",FLOATING));
		} 

		
		Entry(Factory factory, String position)
		{
			this.factory = factory;
			this.position = position;

			
			
			
			title = jEdit.getProperty(factory.name + "".title"");
			if(title == null)
				title = ""NO TITLE PROPERTY: "" + factory.name;

			if(position == null)
				position = FLOATING;
			else if(position.equals(FLOATING))
				;
			else
			{
				if(position.equals(TOP))
					container = top;
				else if(position.equals(LEFT))
					container = left;
				else if(position.equals(BOTTOM))
					container = bottom;
				else if(position.equals(RIGHT))
					container = right;
				else
					throw new InternalError(""Unknown position: "" + position);

				container.register(this);
			}
		} 

		
		void open()
		{
			win = factory.createDockableWindow(view,position);
			if(win == null)
			{
				
				return;
			}

			Log.log(Log.DEBUG,this,""Adding "" + factory.name + "" with position "" + position);

			if(position.equals(FLOATING))
			{
				container = new FloatingWindowContainer(
					DockableWindowManager.this);
				container.register(this);
			}

			container.add(this);
		} 

		
		void remove()
		{
			Log.log(Log.DEBUG,this,""Removing "" + factory.name + "" from ""
				+ container);

			container.save(this);
			container.remove(this);

			if(container instanceof FloatingWindowContainer)
				container = null;

			win = null;
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.textarea.ScrollListener,2,1,0,3,2,1,3,1,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.textarea;


public interface ScrollListener extends java.util.EventListener
{
	void scrolledVertically(JEditTextArea textArea);
	void scrolledHorizontally(JEditTextArea textArea);
}
"
jEdit,4.1,org.gjt.sp.jedit.print.BufferPrinter1_3,5,1,0,5,33,0,0,5,4,0.375,161,1.0,0,0.0,0.25,0,0,30.8,3,1.6,0,"

package org.gjt.sp.jedit.print;


import java.awt.print.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.jedit.io.VFSManager;


public class BufferPrinter1_3
{
	
	private static PrinterJob getPrintJob()
	{
		job = PrinterJob.getPrinterJob();

		int orientation = jEdit.getIntegerProperty(""print.orientation"",PageFormat.PORTRAIT);
		double width = jEdit.getDoubleProperty(""print.width"",0);
		double height = jEdit.getDoubleProperty(""print.height"",0);
		double x = jEdit.getDoubleProperty(""print.x"",0);
		double y = jEdit.getDoubleProperty(""print.y"",0);
		double pagewidth = jEdit.getDoubleProperty(""print.pagewidth"",0);
		double pageheight = jEdit.getDoubleProperty(""print.pageheight"",0);

		format = job.defaultPage();
		
		if(width!=0 && height!=0 )
		{
			Paper pap = format.getPaper();
			pap.setImageableArea(x,y,width,height);
			pap.setSize(pagewidth,pageheight);
			format.setPaper(pap);
		}
		format.setOrientation(orientation);
		return job;

	}

	
	public static void pageSetup(View view)
	{
		job = getPrintJob();

		PageFormat newFormat = job.pageDialog(format);
		if(newFormat != null)
		{
			format = newFormat;
			jEdit.setIntegerProperty(""print.orientation"",format.getOrientation());
			Paper paper=format.getPaper();

			jEdit.setDoubleProperty(""print.width"",paper.getImageableWidth());
			jEdit.setDoubleProperty(""print.height"",paper.getImageableHeight());
			jEdit.setDoubleProperty(""print.x"",paper.getImageableX());
			jEdit.setDoubleProperty(""print.y"",paper.getImageableY());
			jEdit.setDoubleProperty(""print.pagewidth"",paper.getWidth());
			jEdit.setDoubleProperty(""print.pageheight"",paper.getHeight());
		}
	} 

	
	public static void print(final View view, final Buffer buffer, boolean selection)
	{
		job = getPrintJob();
		job.setJobName(buffer.getPath());
		boolean header = jEdit.getBooleanProperty(""print.header"");
		boolean footer = jEdit.getBooleanProperty(""print.footer"");
		boolean lineNumbers = jEdit.getBooleanProperty(""print.lineNumbers"");
		boolean color = jEdit.getBooleanProperty(""print.color"");
		Font font = jEdit.getFontProperty(""print.font"");

		BufferPrintable printable = new BufferPrintable(job,null,view,
			buffer,font,header,footer,lineNumbers,color);
		job.setPrintable(printable,format);

		if(!job.printDialog())
			return;

		VFSManager.runInWorkThread(printable);
	} 

	
	public static PageFormat getPageFormat()
	{
		return format;
	} 

	
	private static PageFormat format;
	private static PrinterJob job;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.msg.VFSUpdate,3,2,0,6,9,0,4,2,3,0.0,36,1.0,0,0.6,0.666666667,1,1,10.66666667,1,0.6667,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class VFSUpdate extends EBMessage
{
	
	public VFSUpdate(String path)
	{
		super(null);

		if(path == null)
			throw new NullPointerException(""Path must be non-null"");

		this.path = path;
	}

	
	public String getPath()
	{
		return path;
	}

	public String paramString()
	{
		return ""path="" + path + "","" + super.paramString();
	}

	
	private String path;
}
"
jEdit,4.1,org.gjt.sp.jedit.print.BufferPrintable,9,2,0,15,64,6,3,13,2,0.788043478,727,0.956521739,4,0.461538462,0.25,0,0,77.22222222,14,3.1111,1,"

package org.gjt.sp.jedit.print;


import javax.swing.text.Segment;
import javax.swing.text.TabExpander;
import javax.swing.SwingUtilities;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.print.*;
import java.awt.*;
import java.lang.reflect.Method;
import java.util.*;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;


class BufferPrintable extends WorkRequest implements Printable
{
	
	BufferPrintable(PrinterJob job, Object format,
		View view, Buffer buffer, Font font, boolean header,
		boolean footer, boolean lineNumbers, boolean color)
	{
		this.job = job;
		this.format = format;
		this.view = view;
		this.buffer = buffer;
		this.font = font;
		this.header = header;
		this.footer = footer;
		this.lineNumbers = lineNumbers;

		styles = GUIUtilities.loadStyles(jEdit.getProperty(""print.font""),
			jEdit.getIntegerProperty(""print.fontsize"",10),color);
		styles[Token.NULL] = new SyntaxStyle(textColor,null,font);

		lineList = new ArrayList();

		softWrap = new SoftWrapTokenHandler();
	} 

	
	public void run()
	{
		try
		{
			
			
			

			if(format == null)
				job.print();
			else
			{
				Method method = PrinterJob.class.getMethod(
					""print"",new Class[] { Class.forName(
					""javax.print.attribute.PrintRequestAttributeSet"") });
				method.invoke(job,new Object[] { format });
			}
		}
		catch(PrinterAbortException ae)
		{
			Log.log(Log.DEBUG,this,ae);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,this,e);
			final String[] args = { e.toString() };
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					GUIUtilities.error(view,""print-error"",args);
				}
			});
		}
		finally
		{
			
		}
	} 

	
	public int print(Graphics _gfx, PageFormat pageFormat, int pageIndex)
		throws PrinterException
	{
		if(pageIndex > currentPage + 1)
		{
			for(int i = currentPage; i < pageIndex; i++)
			{
				printPage(_gfx,pageFormat,i,true);
			}

			currentPage = pageIndex - 1;
		}

		if(pageIndex == currentPage + 1)
		{
			if(end)
			{
				view.getStatus().setMessage(null);
				return NO_SUCH_PAGE;
			}

			currentPageStart = currentPhysicalLine;
			currentPage = pageIndex;
		}
		else if(pageIndex == currentPage)
		{
			currentPhysicalLine = currentPageStart;

			
			
			Object[] args = new Object[] { new Integer(pageIndex + 1) };
			String message = jEdit.getProperty(""view.status.print"",args);
			view.getStatus().setMessage(message);
			setStatus(message);
		}

		printPage(_gfx,pageFormat,pageIndex,true);

		return PAGE_EXISTS;
	} 

	

	
	private static Color headerColor = Color.lightGray;
	private static Color headerTextColor = Color.black;
	private static Color footerColor = Color.lightGray;
	private static Color footerTextColor = Color.black;
	private static Color lineNumberColor = Color.gray;
	private static Color textColor = Color.black;
	

	
	private PrinterJob job;
	private Object format;

	private View view;
	private Buffer buffer;
	private Font font;
	private SyntaxStyle[] styles;
	private boolean header;
	private boolean footer;
	private boolean lineNumbers;

	private int currentPage;
	private int currentPageStart;
	private int currentPhysicalLine;
	private boolean end;

	private LineMetrics lm;
	private ArrayList lineList;

	private SoftWrapTokenHandler softWrap;
	

	
	private void printPage(Graphics _gfx, PageFormat pageFormat, int pageIndex,
		boolean actuallyPaint)
	{
		Graphics2D gfx = (Graphics2D)_gfx;
		gfx.setFont(font);

		double pageX = pageFormat.getImageableX();
		double pageY = pageFormat.getImageableY();
		double pageWidth = pageFormat.getImageableWidth();
		double pageHeight = pageFormat.getImageableHeight();

		if(header)
		{
			double headerHeight = paintHeader(gfx,pageX,pageY,pageWidth,
				actuallyPaint);
			pageY += headerHeight;
			pageHeight -= headerHeight;
		}

		if(footer)
		{
			double footerHeight = paintFooter(gfx,pageX,pageY,pageWidth,
				pageHeight,pageIndex,actuallyPaint);
			pageHeight -= footerHeight;
		}

		FontRenderContext frc = gfx.getFontRenderContext();

		double lineNumberWidth;

		
		if(lineNumbers)
		{
			
			
			int lineNumberDigits = (int)Math.ceil(Math.log(buffer.getLineCount() + 1)
				/ Math.log(10)) + 1;

			
			char[] chars = new char[lineNumberDigits];
			for(int i = 0; i < chars.length; i++)
				chars[i] = ' ';
			lineNumberWidth = font.getStringBounds(chars,
				0,lineNumberDigits,frc).getWidth();
		}
		else
			lineNumberWidth = 0.0;
		

		
		int tabSize = jEdit.getIntegerProperty(""print.tabSize"",8);
		char[] chars = new char[tabSize];
		for(int i = 0; i < chars.length; i++)
			chars[i] = ' ';
		double tabWidth = font.getStringBounds(chars,
			0,tabSize,frc).getWidth();
		PrintTabExpander e = new PrintTabExpander(tabWidth);
		

		Segment seg = new Segment();
		double y = 0.0;

		lm = font.getLineMetrics(""gGyYX"",frc);

print_loop:	for(;;)
		{
			if(currentPhysicalLine == buffer.getLineCount())
			{
				end = true;
				break print_loop;
			}

			lineList.clear();

			buffer.getLineText(currentPhysicalLine,seg);
			softWrap.init(seg,styles,frc,e,lineList,
				(float)(pageWidth - lineNumberWidth));

			buffer.markTokens(currentPhysicalLine,softWrap);
			if(lineList.size() == 0)
				lineList.add(null);

			if(y + (lm.getHeight() * lineList.size()) >= pageHeight)
				break print_loop;

			if(lineNumbers && actuallyPaint)
			{
				gfx.setFont(font);
				gfx.setColor(lineNumberColor);
				gfx.drawString(String.valueOf(currentPhysicalLine + 1),
					(float)pageX,(float)(pageY + y + lm.getHeight()));
			}

			for(int i = 0; i < lineList.size(); i++)
			{
				y += lm.getHeight();
				Chunk chunks = (Chunk)lineList.get(i);
				if(chunks != null && actuallyPaint)
				{
					Chunk.paintChunkList(seg,chunks,gfx,
						(float)(pageX + lineNumberWidth),
						(float)(pageY + y),
						Color.white,false);
				}
			}

			currentPhysicalLine++;
		}
	} 

	
	private double paintHeader(Graphics2D gfx, double pageX, double pageY,
		double pageWidth, boolean actuallyPaint)
	{
		String headerText = jEdit.getProperty(""print.headerText"",
			new String[] { buffer.getPath() });
		FontRenderContext frc = gfx.getFontRenderContext();
		lm = font.getLineMetrics(headerText,frc);

		Rectangle2D bounds = font.getStringBounds(headerText,frc);
		Rectangle2D headerBounds = new Rectangle2D.Double(
			pageX,pageY,pageWidth,bounds.getHeight());

		if(actuallyPaint)
		{
			gfx.setColor(headerColor);
			gfx.fill(headerBounds);
			gfx.setColor(headerTextColor);
			gfx.drawString(headerText,
				(float)(pageX + (pageWidth - bounds.getWidth()) / 2),
				(float)(pageY + lm.getAscent()));
		}

		return headerBounds.getHeight();
	}
	

	
	private double paintFooter(Graphics2D gfx, double pageX, double pageY,
		double pageWidth, double pageHeight, int pageIndex,
		boolean actuallyPaint)
	{
		String footerText = jEdit.getProperty(""print.footerText"",
			new Object[] { new Date(), new Integer(pageIndex + 1) });
		FontRenderContext frc = gfx.getFontRenderContext();
		lm = font.getLineMetrics(footerText,frc);

		Rectangle2D bounds = font.getStringBounds(footerText,frc);
		Rectangle2D footerBounds = new Rectangle2D.Double(
			pageX,pageY + pageHeight - bounds.getHeight(),
			pageWidth,bounds.getHeight());

		if(actuallyPaint)
		{
			gfx.setColor(footerColor);
			gfx.fill(footerBounds);
			gfx.setColor(footerTextColor);
			gfx.drawString(footerText,
				(float)(pageX + (pageWidth - bounds.getWidth()) / 2),
				(float)(pageY + pageHeight - bounds.getHeight()
				+ lm.getAscent()));
		}

		return footerBounds.getHeight();
	} 

	

	
	static class PrintTabExpander implements TabExpander
	{
		private double tabWidth;

		
		public PrintTabExpander(double tabWidth)
		{
			this.tabWidth = tabWidth;
		} 

		
		public float nextTabStop(float x, int tabOffset)
		{
			int ntabs = (int)((x + 1) / tabWidth);
			return (float)((ntabs + 1) * tabWidth);
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.search.HyperSearchResult,5,1,0,9,20,0,6,3,5,0.59375,112,0.0,1,0.0,0.533333333,0,0,19.8,2,1.0,0,"

package org.gjt.sp.jedit.search;


import javax.swing.text.*;
import org.gjt.sp.jedit.jEdit;
import org.gjt.sp.jedit.Buffer;



public class HyperSearchResult
{
	public String path;
	public Buffer buffer;
	public int line;
	public int start;
	public int end;
	public Position startPos;
	public Position endPos;
	public String str; 

	
	public HyperSearchResult(Buffer buffer, int line, int start, int end)
	{
		path = buffer.getPath();
		this.line = line;
		this.start = start;
		this.end = end;

		if(!buffer.isTemporary())
			bufferOpened(buffer);

		str = (line + 1) + "": "" + buffer.getLineText(line)
			.replace('\t',' ').trim();
	} 

	
	public void bufferOpened(Buffer buffer)
	{
		this.buffer = buffer;
		startPos = buffer.createPosition(Math.min(buffer.getLength(),start));
		endPos = buffer.createPosition(Math.min(buffer.getLength(),end));
	} 

	
	public void bufferClosed()
	{
		buffer = null;
		start = startPos.getOffset();
		end = endPos.getOffset();
		startPos = endPos = null;
	} 

	
	public Buffer getBuffer()
	{
		if(buffer == null)
			buffer = jEdit.openFile(null,path);
		return buffer;
	} 

	
	public String toString()
	{
		return str;
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.BeanShellAction,7,3,0,8,18,5,1,7,7,0.80952381,153,1.0,2,0.727272727,0.392857143,2,2,19.85714286,2,1.2857,0,"

package org.gjt.sp.jedit;

import bsh.BshMethod;
import org.gjt.sp.jedit.gui.BeanShellErrorDialog;
import org.gjt.sp.util.Log;


public class BeanShellAction extends EditAction
{
	public BeanShellAction(String name, String code, String isSelected,
		boolean noRepeat, boolean noRecord)
	{
		super(name);

		this.code = code;
		this.isSelected = isSelected;
		this.noRepeat = noRepeat;
		this.noRecord = noRecord;

		
		sanitizedName = name.replace('.','_').replace('-','_');

		
		
		if(isSelected != null)
		{
			String cachedIsSelectedName = ""selected_"" + sanitizedName;
			try
			{
				cachedIsSelected = BeanShell.cacheBlock(cachedIsSelectedName,
					isSelected,false);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,this,e);

				new BeanShellErrorDialog(null,e);
			}
		}
	}

	public void invoke(View view)
	{
		try
		{
			if(cachedCode == null)
			{
				String cachedCodeName = ""action_"" + sanitizedName;
				cachedCode = BeanShell.cacheBlock(cachedCodeName,code,false);
			}

			BeanShell.runCachedBlock(cachedCode,view,null);
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);

			new BeanShellErrorDialog(view,e);
		}
	}

	public boolean isToggle()
	{
		return isSelected != null;
	}

	public boolean isSelected(View view)
	{
		if(isSelected == null)
			return false;

		try
		{
			return Boolean.TRUE.equals(BeanShell.runCachedBlock(
				cachedIsSelected,view,null));
		}
		catch(Throwable e)
		{
			Log.log(Log.ERROR,this,e);

			new BeanShellErrorDialog(view,e);

			return false;
		}
	}

	public boolean noRepeat()
	{
		return noRepeat;
	}

	public boolean noRecord()
	{
		return noRecord;
	}

	public String getCode()
	{
		return code.trim();
	}

	
	private boolean noRepeat;
	private boolean noRecord;
	private String code;
	private String isSelected;
	private BshMethod cachedCode;
	private BshMethod cachedIsSelected;
	private String sanitizedName;
}
"
jEdit,4.1,org.gjt.sp.jedit.textarea.ChunkCache,16,1,0,14,64,0,6,10,1,0.713333333,1130,0.9,4,0.0,0.386666667,0,0,69.0,29,5.875,4,"

package org.gjt.sp.jedit.textarea;


import java.util.*;
import org.gjt.sp.jedit.Buffer;
import org.gjt.sp.jedit.syntax.*;



class ChunkCache
{
	
	ChunkCache(JEditTextArea textArea)
	{
		this.textArea = textArea;
		out = new ArrayList();
		noWrap = new DisplayTokenHandler();
		softWrap = new SoftWrapTokenHandler();
	} 

	
	int getMaxHorizontalScrollWidth()
	{
		int max = 0;
		for(int i = 0; i < lineInfo.length; i++)
		{
			LineInfo info = lineInfo[i];
			if(info.chunksValid && info.width > max)
				max = info.width;
		}
		return max;
	} 

	
	int getScreenLineOfOffset(int line, int offset)
	{
		if(line < textArea.getFirstPhysicalLine())
		{
			return -1;
		}
		else if(line > textArea.getLastPhysicalLine())
		{
			return -1;
		}
		else if(!textArea.softWrap)
		{
			int virtLine = textArea.physicalToVirtual(line);
			if(virtLine < firstLine)
			{
				throw new InternalError(""virtLine < firstLine ""
					+ ""and line >= physFirstLine"");
			}
			return virtLine - firstLine;
		}
		else
		{
			int screenLine;

			if(line == lastScreenLineP)
			{
				LineInfo last = lineInfo[lastScreenLine];

				if(offset >= last.offset
					&& offset < last.offset + last.length)
				{
					updateChunksUpTo(lastScreenLine);
					return lastScreenLine;
				}
			}

			screenLine = -1;

			
			for(int i = 0; i < lineInfo.length; i++)
			{
				updateChunksUpTo(i);

				LineInfo info = getLineInfo(i);
				if(info.physicalLine > line)
				{
					
					if(i == 0)
						screenLine = 0;
					else
						screenLine = i - 1;
					break;
				}
				else if(info.physicalLine == line)
				{
					if(offset >= info.offset
						&& offset < info.offset + info.length)
					{
						screenLine = i;
						break;
					}
				}
			}

			if(screenLine == -1)
				return -1;
			else
			{
				lastScreenLineP = line;
				lastScreenLine = screenLine;

				return screenLine;
			}
		}
	} 

	
	void recalculateVisibleLines()
	{
		lineInfo = new LineInfo[textArea.getVisibleLines() + 1];
		for(int i = 0; i < lineInfo.length; i++)
			lineInfo[i] = new LineInfo();

		lastScreenLine = lastScreenLineP = -1;
	} 

	
	public static boolean DEBUG = false;
	
	void setFirstLine(int firstLine, int physFirstLine, boolean bufferSwitch)
	{
		if(DEBUG)
		{
			System.err.println(""old: "" + this.firstLine + "",new: "" +
				firstLine + "",phys: "" + physFirstLine + "",bs: "" + bufferSwitch);
		}

		int visibleLines = lineInfo.length;
		
		if(bufferSwitch
			|| (!textArea.softWrap && Math.abs(firstLine - this.firstLine) >= visibleLines)
			|| (textArea.softWrap && physFirstLine > textArea.getLastPhysicalLine()))
		{
			if(DEBUG)
				System.err.println(""too far"");
			for(int i = 0; i < visibleLines; i++)
			{
				lineInfo[i].chunksValid = false;
			}
		}
		else if(firstLine > this.firstLine)
		{
			boolean invalidateAll = false;

			int firstScreenLine = 0;
			for(int i = 0; i < visibleLines; i++)
			{
				
				
				
				if(!lineInfo[i].chunksValid)
				{
					invalidateAll = true;
					break;
				}

				if(lineInfo[i].physicalLine == physFirstLine)
				{
					firstScreenLine = i;
					break;
				}
			}

			if(invalidateAll)
			{
				invalidateAll();
			}
			else
			{
				int lastValidLine = -1;

				
				
				
				
				for(int i = visibleLines - 1; i >= 0; i--)
				{
					if(DEBUG)
					{
						System.err.println(""Scan "" + i);
					}
					if(lineInfo[i].lastSubregion)
						break;
					else
						lineInfo[i].chunksValid = false;
				}

				if(firstScreenLine != visibleLines)
				{
					System.arraycopy(lineInfo,firstScreenLine,
						lineInfo,0,visibleLines - firstScreenLine);
				}

				for(int i = visibleLines - firstScreenLine; i < visibleLines; i++)
				{
					lineInfo[i] = new LineInfo();
				}
			}

			if(DEBUG)
			{
				System.err.println(""f > t.f: only "" + firstScreenLine
					+ "" need updates"");
			}
		}
		else if(this.firstLine > firstLine)
		{
			LinkedList list = new LinkedList();
			for(int i = firstLine; i < this.firstLine; i++)
			{
				if(i >= textArea.getVirtualLineCount()
					|| list.size() >= visibleLines)
				{
					break;
				}

				int physicalLine = textArea.virtualToPhysical(i);

				out.clear();
				lineToChunkList(physicalLine,out);
				if(out.size() == 0)
					out.add(null);

				getLineInfosForPhysicalLine(physicalLine,list);
			}

			if(list.size() < visibleLines)
			{
				System.arraycopy(lineInfo,0,lineInfo,list.size(),
					visibleLines - list.size());
			}

			int firstScreenLine = Math.min(list.size(),visibleLines);

			Iterator iter = list.iterator();
			for(int i = 0; i < visibleLines && iter.hasNext(); i++)
			{
				lineInfo[i] = (LineInfo)iter.next();
			}

			if(DEBUG)
			{
				System.err.println(""t.f > f: only "" + firstScreenLine
					+ "" need updates"");
			}
		}

		lastScreenLine = lastScreenLineP = -1;
		this.firstLine = firstLine;
	} 

	
	void invalidateAll()
	{
		for(int i = 0; i < lineInfo.length; i++)
		{
			if(!lineInfo[i].chunksValid)
			{
				
				break;
			}
			lineInfo[i].chunksValid = false;
		}

		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void invalidateChunksFrom(int screenLine)
	{
		for(int i = screenLine; i < lineInfo.length; i++)
		{
			lineInfo[i].chunksValid = false;
		}

		lastScreenLine = lastScreenLineP = -1;
	} 

	
	void invalidateChunksFromPhys(int physicalLine)
	{
		for(int i = 0; i < lineInfo.length; i++)
		{
			LineInfo info = lineInfo[i];
			if(!info.chunksValid)
				break;

			if(info.physicalLine >= physicalLine)
			{
				invalidateChunksFrom(i);
				break;
			}
		}
	} 

	
	void lineToChunkList(int physicalLine, List out)
	{
		if(textArea.softWrap)
		{
			TextAreaPainter painter = textArea.getPainter();
			Buffer buffer = textArea.getBuffer();

			buffer.getLineText(physicalLine,textArea.lineSegment);
			softWrap.init(textArea.lineSegment,painter.getStyles(),
				painter.getFontRenderContext(),
				painter,out,textArea.wrapMargin);
			softWrap.setMonospacedCharWidth(textArea.monospacedHack
				? textArea.charWidth : 0);
			buffer.markTokens(physicalLine,softWrap);
		}
		else
		{
			Chunk chunks = lineToChunkList(physicalLine);
			if(chunks != null)
				out.add(chunks);
		}
	} 

	
	Chunk lineToChunkList(int physicalLine)
	{
		TextAreaPainter painter = textArea.getPainter();
		Buffer buffer = textArea.getBuffer();

		buffer.getLineText(physicalLine,textArea.lineSegment);
		noWrap.init(textArea.lineSegment,painter.getStyles(),
			painter.getFontRenderContext(),
			painter);
		noWrap.setMonospacedCharWidth(textArea.monospacedHack
			? textArea.charWidth : 0);
		buffer.markTokens(physicalLine,noWrap);
		return noWrap.getChunks();
	} 

	
	void updateChunksUpTo(int lastScreenLine)
	{
		if(lineInfo[lastScreenLine].chunksValid)
			return;

		int firstScreenLine = 0;

		for(int i = lastScreenLine; i >= 0; i--)
		{
			if(lineInfo[i].chunksValid)
			{
				firstScreenLine = i + 1;
				break;
			}
		}

		int physicalLine;

		if(firstScreenLine == 0)
		{
			physicalLine = textArea.getFirstPhysicalLine();
		}
		else
		{
			int prevPhysLine = lineInfo[
				firstScreenLine - 1]
				.physicalLine;
			if(prevPhysLine == -1)
				physicalLine = -1;
			else
			{
				physicalLine = textArea
					.getFoldVisibilityManager()
					.getNextVisibleLine(prevPhysLine);
			}
		}

		
		
		
		

		out.clear();

		int offset = 0;
		int length = 0;

		for(int i = firstScreenLine; i <= lastScreenLine; i++)
		{
			LineInfo info = lineInfo[i];

			Chunk chunks;

			if(out.size() == 0)
			{
				if(physicalLine != -1 && i != firstScreenLine)
				{
					physicalLine = textArea.getFoldVisibilityManager()
						.getNextVisibleLine(physicalLine);
				}

				if(physicalLine == -1)
				{
					info.chunks = null;
					info.chunksValid = true;
					info.physicalLine = -1;
					continue;
				}

				lineToChunkList(physicalLine,out);

				info.firstSubregion = true;

				if(out.size() == 0)
				{
					chunks = null;
					offset = 0;
					length = 1;
				}
				else
				{
					chunks = (Chunk)out.get(0);
					out.remove(0);
					offset = 0;
					if(out.size() != 0)
						length = ((Chunk)out.get(0)).offset - offset;
					else
						length = textArea.getLineLength(physicalLine) - offset + 1;
				}
			}
			else
			{
				info.firstSubregion = false;

				chunks = (Chunk)out.get(0);
				out.remove(0);
				offset = chunks.offset;
				if(out.size() != 0)
					length = ((Chunk)out.get(0)).offset - offset;
				else
					length = textArea.getLineLength(physicalLine) - offset + 1;
			}

			boolean lastSubregion = (out.size() == 0);

			if(i == lastScreenLine
				&& lastScreenLine != lineInfo.length - 1)
			{
				
				if(info.physicalLine != physicalLine
					|| info.lastSubregion != lastSubregion)
				{
					lastScreenLine++;
					needFullRepaint = true;
				}
				else if(out.size() != 0)
					lastScreenLine++;
			}

			info.physicalLine = physicalLine;
			info.lastSubregion = lastSubregion;
			info.offset = offset;
			info.length = length;
			info.chunks = chunks;
			info.chunksValid = true;
		}
	} 

	
	LineInfo getLineInfo(int screenLine)
	{
		LineInfo info = lineInfo[screenLine];

		if(!info.chunksValid)
			throw new InternalError(""Not up-to-date: "" + screenLine);
		return info;
	} 

	
	public LineInfo[] getLineInfosForPhysicalLine(int physicalLine)
	{
		out.clear();
		lineToChunkList(physicalLine,out);

		if(out.size() == 0)
			out.add(null);

		ArrayList returnValue = new ArrayList(out.size());
		getLineInfosForPhysicalLine(physicalLine,returnValue);
		return (LineInfo[])returnValue.toArray(new LineInfo[out.size()]);
	} 

	
	
	boolean needFullRepaint()
	{
		boolean retVal = needFullRepaint;
		needFullRepaint = false;
		return retVal;
	} 

	

	
	private JEditTextArea textArea;
	private int firstLine;
	private LineInfo[] lineInfo;
	private ArrayList out;

	private int lastScreenLineP;
	private int lastScreenLine;

	private boolean needFullRepaint;

	private DisplayTokenHandler noWrap;
	private SoftWrapTokenHandler softWrap;
	

	
	private void getLineInfosForPhysicalLine(int physicalLine, List list)
	{
		for(int i = 0; i < out.size(); i++)
		{
			Chunk chunks = (Chunk)out.get(i);
			LineInfo info = new LineInfo();
			info.physicalLine = physicalLine;
			if(i == 0)
			{
				info.firstSubregion = true;
				info.offset = 0;
			}
			else
				info.offset = chunks.offset;

			if(i == out.size() - 1)
			{
				info.lastSubregion = true;
				info.length = textArea.getLineLength(physicalLine)
					- info.offset + 1;
			}
			else
			{
				info.length = ((Chunk)out.get(i + 1)).offset
					- info.offset;
			}

			info.chunksValid = true;
			info.chunks = chunks;

			list.add(info);
		}
	} 

	

	
	static class LineInfo
	{
		int physicalLine;
		int offset;
		int length;
		boolean firstSubregion;
		boolean lastSubregion;
		boolean chunksValid;
		Chunk chunks;
		int width;
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.BeanShellErrorDialog,3,7,0,6,35,3,3,4,3,2.0,161,0.0,0,0.996960486,0.555555556,0,0,52.66666667,1,0.6667,2,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import java.io.PrintWriter;
import java.io.StringWriter;
import org.gjt.sp.jedit.*;


public class BeanShellErrorDialog extends EnhancedDialog
{
	
	public BeanShellErrorDialog(View view, Throwable t)
	{
		super(view,jEdit.getProperty(""beanshell-error.title""),true);

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		Box iconBox = new Box(BoxLayout.Y_AXIS);
		iconBox.add(new JLabel(UIManager.getIcon(""OptionPane.errorIcon"")));
		iconBox.add(Box.createGlue());
		content.add(BorderLayout.WEST,iconBox);

		JPanel centerPanel = new JPanel(new BorderLayout(6,6));

		centerPanel.add(BorderLayout.NORTH,new JLabel(
			jEdit.getProperty(""beanshell-error.message"")));

		JTextArea textArea = new JTextArea(10,80);

		StringWriter s = new StringWriter();
		t.printStackTrace(new PrintWriter(s));

		textArea.setText(s.toString());
		textArea.setLineWrap(true);
		textArea.setCaretPosition(0);
		centerPanel.add(BorderLayout.CENTER,new JScrollPane(textArea));

		content.add(BorderLayout.CENTER,centerPanel);

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());
		JButton ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		buttons.add(ok);
		buttons.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,buttons);

		getRootPane().setDefaultButton(ok);

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	class ActionHandler implements ActionListener
	{
		
		public void actionPerformed(ActionEvent evt)
		{
			dispose();
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.ActionSet,13,1,0,12,26,0,11,1,12,0.458333333,110,1.0,0,0.0,0.384615385,0,0,7.307692308,2,1.0,3,"

package org.gjt.sp.jedit;

import java.util.*;


public class ActionSet
{
	
	public ActionSet()
	{
		this(null);
	}

	
	public ActionSet(String label)
	{
		this.label = label;
		actions = new Hashtable();
	}

	
	public String getLabel()
	{
		return label;
	}

	
	public void setLabel(String label)
	{
		this.label = label;
	}

	
	public void addAction(EditAction action)
	{
		actions.put(action.getName(),action);
	}

	
	public void removeAction(String name)
	{
		actions.remove(name);
	}

	
	public void removeAllActions()
	{
		actions.clear();
	}

	
	public EditAction getAction(String name)
	{
		return (EditAction)actions.get(name);
	}

	
	public int getActionCount()
	{
		return actions.size();
	}

	
	public EditAction[] getActions()
	{
		EditAction[] retVal = new EditAction[actions.size()];
		Enumeration enum = actions.elements();
		int i = 0;
		while(enum.hasMoreElements())
		{
			retVal[i++] = (EditAction)enum.nextElement();
		}
		return retVal;
	}

	
	public boolean contains(EditAction action)
	{
		return actions.contains(action);
	}

	public String toString()
	{
		return label;
	}

	
	void getActions(Vector vec)
	{
		Enumeration enum = actions.elements();
		while(enum.hasMoreElements())
			vec.addElement(enum.nextElement());
	}

	
	private String label;
	private Hashtable actions;
}
"
jEdit,4.1,org.gjt.sp.jedit.SettingsReloader,3,1,0,9,19,3,1,9,1,2.0,110,0.0,0,0.0,0.555555556,0,0,35.66666667,17,6.3333,1,"

package org.gjt.sp.jedit;

import java.io.File;
import org.gjt.sp.jedit.msg.VFSUpdate;
import org.gjt.sp.jedit.search.*;

class SettingsReloader implements EBComponent
{
	public void handleMessage(EBMessage msg)
	{
		if(msg instanceof VFSUpdate)
		{
			VFSUpdate vmsg = (VFSUpdate)msg;
			maybeReload(vmsg.getPath());
		}
	}

	private void maybeReload(String path)
	{
		
		SearchFileSet fileset = SearchAndReplace.getSearchFileSet();
		if(fileset instanceof DirectoryListSet)
		{
			DirectoryListSet dirset = (DirectoryListSet)fileset;
			if(path.startsWith(dirset.getDirectory()))
				dirset.invalidateCachedList();
		}

		String jEditHome = jEdit.getJEditHome();
		String settingsDirectory = jEdit.getSettingsDirectory();
		
		if(OperatingSystem.isDOSDerived() || OperatingSystem.isMacOS())
		{
			path = path.toLowerCase();
			if(jEditHome != null)
				jEditHome = jEditHome.toLowerCase();
			if(settingsDirectory != null)
				settingsDirectory = settingsDirectory.toLowerCase();
		}

		if(jEditHome != null && path.startsWith(jEditHome))
			path = path.substring(jEditHome.length());
		else if(settingsDirectory != null && path.startsWith(settingsDirectory))
			path = path.substring(settingsDirectory.length());
		else
		{
			
			
			return;
		}

		if(path.startsWith(File.separator) || path.startsWith(""/""))
			path = path.substring(1);

		if(path.startsWith(""macros""))
			Macros.loadMacros();
		else if(path.startsWith(""modes"") && (path.endsWith("".xml"")
			|| path.endsWith(""catalog"")))
			jEdit.reloadModes();
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.EnhancedCheckBoxMenuItem,7,7,0,6,40,9,3,5,4,0.611111111,214,1.0,1,0.993811881,0.3,3,13,28.71428571,8,2.1429,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;



public class EnhancedCheckBoxMenuItem extends JCheckBoxMenuItem
{
	
	public EnhancedCheckBoxMenuItem(String label, EditAction action)
	{
		super(label);
		this.action = action;

		if(action != null)
		{
			setEnabled(true);
			addActionListener(new EditAction.Wrapper(action));
			shortcutProp1 = action.getName() + "".shortcut"";
			shortcutProp2 = action.getName() + "".shortcut2"";

			addMouseListener(new MouseHandler());
		}
		else
			setEnabled(false);

		setModel(new Model());
	} 

	
	public Dimension getPreferredSize()
	{
		Dimension d = super.getPreferredSize();

		String shortcut = getShortcut();

		if(shortcut != null)
		{
			d.width += (getFontMetrics(acceleratorFont)
				.stringWidth(shortcut) + 15);
		}
		return d;
	} 

	
	public void paint(Graphics g)
	{
		super.paint(g);

		String shortcut = getShortcut();

		if(shortcut != null)
		{
			g.setFont(acceleratorFont);
			g.setColor(getModel().isArmed() ?
				acceleratorSelectionForeground :
				acceleratorForeground);
			FontMetrics fm = g.getFontMetrics();
			Insets insets = getInsets();
			g.drawString(shortcut,getWidth() - (fm.stringWidth(
				shortcut) + insets.right + insets.left + 5),
				getFont().getSize() + (insets.top - 1)
				);
		}
	} 

	
	public String getActionCommand()
	{
		return getModel().getActionCommand();
	} 

	

	
	private String shortcutProp1;
	private String shortcutProp2;
	private EditAction action;
	private static Font acceleratorFont;
	private static Color acceleratorForeground;
	private static Color acceleratorSelectionForeground;
	

	
	private String getShortcut()
	{
		if(action == null)
			return null;
		else
		{
			String shortcut1 = jEdit.getProperty(shortcutProp1);
			String shortcut2 = jEdit.getProperty(shortcutProp2);

			if(shortcut1 == null || shortcut1.length() == 0)
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return null;
				else
					return shortcut2;
			}
			else
			{
				if(shortcut2 == null || shortcut2.length() == 0)
					return shortcut1;
				else
					return shortcut1 + "" or "" + shortcut2;
			}
		}
	} 

	
	static
	{
		acceleratorFont = UIManager.getFont(""MenuItem.acceleratorFont"");
		acceleratorFont = new Font(""Monospaced"",
			acceleratorFont.getStyle(),
			acceleratorFont.getSize());
		acceleratorForeground = UIManager
			.getColor(""MenuItem.acceleratorForeground"");
		acceleratorSelectionForeground = UIManager
			.getColor(""MenuItem.acceleratorSelectionForeground"");
	} 

	

	
	class Model extends DefaultButtonModel
	{
		public boolean isSelected()
		{
			if(!isShowing())
				return false;

			try
			{
				return action.isSelected(GUIUtilities.getView(
					EnhancedCheckBoxMenuItem.this));
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,this,t);
				return false;
			}
		}

		public void setSelected(boolean b) {}
	} 

	
	class MouseHandler extends MouseAdapter
	{
		public void mouseReleased(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}

		public void mouseEntered(MouseEvent evt)
		{
			String msg = action.getMouseOverText();
			if(msg != null)
			{
				GUIUtilities.getView((Component)evt.getSource())
					.getStatus().setMessage(msg);
			}
		}

		public void mouseExited(MouseEvent evt)
		{
			GUIUtilities.getView((Component)evt.getSource())
				.getStatus().setMessage(null);
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.jEdit,118,1,0,197,390,5891,169,60,81,0.923076923,5263,0.964285714,9,0.0,0.053846154,0,0,43.36440678,61,4.0,17,"

package org.gjt.sp.jedit;


import com.microstar.xml.*;
import javax.swing.plaf.metal.*;
import javax.swing.*;
import java.awt.*;
import java.io.*;
import java.net.*;
import java.text.MessageFormat;
import java.util.*;
import org.gjt.sp.jedit.buffer.BufferIORequest;
import org.gjt.sp.jedit.msg.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.help.HelpViewer;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.jedit.search.SearchAndReplace;
import org.gjt.sp.jedit.syntax.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;



public class jEdit
{
	
	
	public static String getVersion()
	{
		return MiscUtilities.buildToVersion(getBuild());
	} 

	
	
	public static String getBuild()
	{
		
		return ""04.01.99.00"";
	} 

	
	
	public static void main(String[] args)
	{
		String javaVersion = System.getProperty(""java.version"");
		if(javaVersion.compareTo(""1.3"") < 0)
		{
			System.err.println(""You are running Java version ""
				+ javaVersion + ""."");
			System.err.println(""jEdit requires Java 1.3 or later."");
			System.exit(1);
		}

		
		int level = Log.WARNING;
		if(args.length >= 1)
		{
			String levelStr = args[0];
			if(levelStr.length() == 1 && Character.isDigit(
				levelStr.charAt(0)))
			{
				level = Integer.parseInt(levelStr);
				args[0] = null;
			}
		}

		boolean endOpts = false;
		settingsDirectory = MiscUtilities.constructPath(
			System.getProperty(""user.home""),"".jedit"");
		String portFile = ""server"";
		boolean restore = true;
		boolean gui = true; 
		boolean noPlugins = false;
		boolean noStartupScripts = false;
		String userDir = System.getProperty(""user.dir"");

		
		String scriptFile = null;

		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.length() == 0)
				args[i] = null;
			else if(arg.startsWith(""-"") && !endOpts)
			{
				if(arg.equals(""--""))
					endOpts = true;
				else if(arg.equals(""-usage""))
				{
					version();
					System.err.println();
					usage();
					System.exit(1);
				}
				else if(arg.equals(""-version""))
				{
					version();
					System.exit(1);
				}
				else if(arg.equals(""-nosettings""))
					settingsDirectory = null;
				else if(arg.startsWith(""-settings=""))
					settingsDirectory = arg.substring(10);
				else if(arg.startsWith(""-noserver""))
					portFile = null;
				else if(arg.equals(""-server""))
					portFile = ""server"";
				else if(arg.startsWith(""-server=""))
					portFile = arg.substring(8);
				else if(arg.startsWith(""-background""))
					background = true;
				else if(arg.equals(""-nogui""))
					gui = false;
				else if(arg.equals(""-norestore""))
					restore = false;
				else if(arg.equals(""-noplugins""))
					noPlugins = true;
				else if(arg.equals(""-nostartupscripts""))
					noStartupScripts = true;
				else if(arg.startsWith(""-run=""))
					scriptFile = arg.substring(5);
				else
				{
					System.err.println(""Unknown option: ""
						+ arg);
					usage();
					System.exit(1);
				}
				args[i] = null;
			}
		} 

		if(settingsDirectory != null && portFile != null)
			portFile = MiscUtilities.constructPath(settingsDirectory,portFile);
		else
			portFile = null;

		Log.init(true,level);

		
		if(portFile != null && new File(portFile).exists())
		{
			int port, key;
			try
			{
				BufferedReader in = new BufferedReader(new FileReader(portFile));
				String check = in.readLine();
				if(!check.equals(""b""))
					throw new Exception(""Wrong port file format"");

				port = Integer.parseInt(in.readLine());
				key = Integer.parseInt(in.readLine());
				in.close();

				Socket socket = new Socket(InetAddress.getByName(""127.0.0.1""),port);
				DataOutputStream out = new DataOutputStream(
					socket.getOutputStream());
				out.writeInt(key);

				String script = makeServerScript(restore,args,scriptFile);

				out.writeUTF(script);

				out.close();

				System.exit(0);
			}
			catch(Exception e)
			{
				
				
				
				Log.log(Log.NOTICE,jEdit.class,""An error occurred""
					+ "" while connecting to the jEdit server instance."");
				Log.log(Log.NOTICE,jEdit.class,""This probably means that""
					+ "" jEdit crashed and/or exited abnormally"");
				Log.log(Log.NOTICE,jEdit.class,""the last time it was run."");
				Log.log(Log.NOTICE,jEdit.class,""If you don't""
					+ "" know what this means, don't worry."");
				Log.log(Log.NOTICE,jEdit.class,e);
			}
		} 

		
		
		if(!new File(settingsDirectory,""nosplash"").exists())
			GUIUtilities.showSplashScreen();

		
		Writer stream;
		if(settingsDirectory != null)
		{
			File _settingsDirectory = new File(settingsDirectory);
			if(!_settingsDirectory.exists())
				_settingsDirectory.mkdirs();
			File _macrosDirectory = new File(settingsDirectory,""macros"");
			if(!_macrosDirectory.exists())
				_macrosDirectory.mkdir();

			String logPath = MiscUtilities.constructPath(
				settingsDirectory,""activity.log"");

			backupSettingsFile(new File(logPath));

			try
			{
				stream = new BufferedWriter(new FileWriter(logPath));

				
				String lineSep = System.getProperty(""line.separator"");
				stream.write(""Log file created on "" + new Date());
				stream.write(lineSep);
				stream.write(""IMPORTANT:"");
				stream.write(lineSep);
				stream.write(""Because updating this file after ""
					+ ""every log message would kill"");
				stream.write(lineSep);
				stream.write(""performance, it will be *incomplete* ""
					+ ""unless you invoke the"");
				stream.write(lineSep);
				stream.write(""Utilities->Troubleshooting->Update ""
					+ ""Activity Log on Disk command!"");
				stream.write(lineSep);
			}
			catch(Exception e)
			{
				e.printStackTrace();
				stream = null;
			}
		}
		else
		{
			stream = null;
		} 

		Log.setLogWriter(stream);

		Log.log(Log.NOTICE,jEdit.class,""jEdit version "" + getVersion());
		Log.log(Log.MESSAGE,jEdit.class,""Settings directory is ""
			+ settingsDirectory);

		
		if(portFile != null)
		{
			server = new EditServer(portFile);
			if(!server.isOK())
				server = null;
		}
		else
		{
			if(background)
			{
				background = false;
				Log.log(Log.WARNING,jEdit.class,""You cannot specify both the""
					+ "" -background and -noserver switches"");
			}
		} 

		
		initMisc();
		initSystemProperties();
		GUIUtilities.advanceSplashProgress();

		BeanShell.init();

		initUserProperties();
		initPLAF();

		if(OperatingSystem.hasJava14())
		{
			try
			{
				ClassLoader loader = jEdit.class.getClassLoader();
				Class clazz;
				if(loader != null)
					clazz = loader.loadClass(""org.gjt.sp.jedit.Java14"");
				else
					clazz = Class.forName(""org.gjt.sp.jedit.Java14"");
				java.lang.reflect.Method meth = clazz
					.getMethod(""init"",new Class[0]);
				meth.invoke(null,new Object[0]);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
				System.exit(1);
			}
		}

		initActions();
		initDockables();

		GUIUtilities.advanceSplashProgress();

		VFSManager.init();

		if(!noPlugins)
			initPlugins();

		if(jEditHome != null)
			initSiteProperties();

		if(settingsDirectory != null)
		{
			File history = new File(MiscUtilities.constructPath(
				settingsDirectory,""history""));
			if(history.exists())
				historyModTime = history.lastModified();
			HistoryModel.loadHistory(history);

			File recent = new File(MiscUtilities.constructPath(
				settingsDirectory,""recent.xml""));
			if(recent.exists())
				recentModTime = recent.lastModified();
			BufferHistory.load(recent);
		}

		GUIUtilities.advanceSplashProgress();

		
		sortBuffers = getBooleanProperty(""sortBuffers"");
		sortByName = getBooleanProperty(""sortByName"");

		reloadModes();

		GUIUtilities.advanceSplashProgress();

		SearchAndReplace.load();

		GUIUtilities.advanceSplashProgress();
		

		
		for(int i = 0; i < jars.size(); i++)
		{
			((EditPlugin.JAR)jars.elementAt(i)).getClassLoader()
				.startAllPlugins();
		} 

		
		Macros.loadMacros();

		if(!noStartupScripts && jEditHome != null)
		{
			String path = MiscUtilities.constructPath(jEditHome,""startup"");
			File file = new File(path);
			if(file.exists())
				runStartupScripts(file);
		}

		if(!noStartupScripts && settingsDirectory != null)
		{
			String path = MiscUtilities.constructPath(settingsDirectory,""startup"");
			File file = new File(path);
			if(!file.exists())
				file.mkdirs();
			else
				runStartupScripts(file);
		} 

		
		if(scriptFile != null)
		{
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			BeanShell.runScript(null,scriptFile,null,false);
		} 

		
		propertiesChanged();

		GUIUtilities.advanceSplashProgress();

		
		finishStartup(gui,restore,userDir,args);
	} 

	

	
	
	public static final Properties getProperties()
	{
		return props;
	} 

	
	
	public static final String getProperty(String name)
	{
		return props.getProperty(name);
	} 

	
	
	public static final String getProperty(String name, String def)
	{
		return props.getProperty(name,def);
	} 

	
	
	public static final String getProperty(String name, Object[] args)
	{
		if(name == null)
			return null;
		if(args == null)
			return props.getProperty(name);
		else
		{
			String value = props.getProperty(name);
			if(value == null)
				return null;
			else
				return MessageFormat.format(value,args);
		}
	} 

	
	
	public static final boolean getBooleanProperty(String name)
	{
		return getBooleanProperty(name,false);
	} 

	
	
	public static final boolean getBooleanProperty(String name, boolean def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else if(value.equals(""true"") || value.equals(""yes"")
			|| value.equals(""on""))
			return true;
		else if(value.equals(""false"") || value.equals(""no"")
			|| value.equals(""off""))
			return false;
		else
			return def;
	} 

	
	
	public static final int getIntegerProperty(String name, int def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
		{
			try
			{
				return Integer.parseInt(value.trim());
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
		}
	} 

	
	public static double getDoubleProperty(String name, double def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
		{
			try
			{
				return Double.parseDouble(value.trim());
			}
			catch(NumberFormatException nf)
			{
				return def;
			}
		}
	}
	

	
	
	public static final Font getFontProperty(String name)
	{
		return getFontProperty(name,null);
	} 

	
	
	public static final Font getFontProperty(String name, Font def)
	{
		String family = getProperty(name);
		String sizeString = getProperty(name + ""size"");
		String styleString = getProperty(name + ""style"");

		if(family == null || sizeString == null || styleString == null)
			return def;
		else
		{
			int size, style;

			try
			{
				size = Integer.parseInt(sizeString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}

			try
			{
				style = Integer.parseInt(styleString);
			}
			catch(NumberFormatException nf)
			{
				return def;
			}

			return new Font(family,style,size);
		}
	} 

	
	
	public static Color getColorProperty(String name)
	{
		return getColorProperty(name,Color.black);
	} 

	
	
	public static Color getColorProperty(String name, Color def)
	{
		String value = getProperty(name);
		if(value == null)
			return def;
		else
			return GUIUtilities.parseColor(value,def);
	} 

	
	
	public static void setColorProperty(String name, Color value)
	{
		setProperty(name,GUIUtilities.getColorHexString(value));
	} 

	
	
	public static final void setProperty(String name, String value)
	{
		
		if(value == null)
		{
			String prop = (String)defaultProps.get(name);
			if(prop == null || prop.length() == 0)
				props.remove(name);
			else
				props.put(name,"""");
		}
		else
		{
			String prop = (String)defaultProps.get(name);
			if(value.equals(prop))
				props.remove(name);
			else
				props.put(name,value);
		}
	} 

	
	
	public static final void setTemporaryProperty(String name, String value)
	{
		props.remove(name);
		defaultProps.put(name,value);
	} 

	
	
	public static final void setBooleanProperty(String name, boolean value)
	{
		setProperty(name,value ? ""true"" : ""false"");
	} 

	
	
	public static final void setIntegerProperty(String name, int value)
	{
		setProperty(name,String.valueOf(value));
	} 

	
	public static final void setDoubleProperty(String name, double value)
	{
		setProperty(name,String.valueOf(value));
	}
	

	
	
	public static final void setFontProperty(String name, Font value)
	{
		setProperty(name,value.getFamily());
		setIntegerProperty(name + ""size"",value.getSize());
		setIntegerProperty(name + ""style"",value.getStyle());
	} 

	
	
	public static final void unsetProperty(String name)
	{
		if(defaultProps.get(name) != null)
			props.put(name,"""");
		else
			props.remove(name);
	} 

	
	
	public static final void resetProperty(String name)
	{
		props.remove(name);
	} 

	
	
	public static void propertiesChanged()
	{
		initKeyBindings();

		Autosave.setInterval(getIntegerProperty(""autosave"",30));

		saveCaret = getBooleanProperty(""saveCaret"");

		
		
		

		UIDefaults defaults = UIManager.getDefaults();

		
		Font font = getFontProperty(""view.font"");

		
		defaults.put(""TextArea.font"",font);
		defaults.put(""TextPane.font"",font);

		
		ToolTipManager.sharedInstance().setEnabled(
			jEdit.getBooleanProperty(""showTooltips""));

		initProxy();

		EditBus.send(new PropertiesChanged(null));
	} 

	

	

	
	
	public static String[] getNotLoadedPluginJARs()
	{
		Vector returnValue = new Vector();

		if(jEditHome != null)
		{
			String systemPluginDir = MiscUtilities
				.constructPath(jEditHome,""jars"");

			String[] list = new File(systemPluginDir).list();
			if(list != null)
				getNotLoadedPluginJARs(returnValue,systemPluginDir,list);
		}

		if(settingsDirectory != null)
		{
			String userPluginDir = MiscUtilities
				.constructPath(settingsDirectory,""jars"");
			String[] list = new File(userPluginDir).list();
			if(list != null)
			{
				getNotLoadedPluginJARs(returnValue,
					userPluginDir,list);
			}
		}

		String[] _returnValue = new String[returnValue.size()];
		returnValue.copyInto(_returnValue);
		return _returnValue;
	} 

	
	
	public static EditPlugin getPlugin(String name)
	{
		EditPlugin[] plugins = getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			if(plugins[i].getClassName().equals(name))
				return plugins[i];
		}

		return null;
	} 

	
	
	public static EditPlugin[] getPlugins()
	{
		Vector vector = new Vector();
		for(int i = 0; i < jars.size(); i++)
		{
			((EditPlugin.JAR)jars.elementAt(i)).getPlugins(vector);
		}

		EditPlugin[] array = new EditPlugin[vector.size()];
		vector.copyInto(array);
		return array;
	} 

	
	
	public static EditPlugin.JAR[] getPluginJARs()
	{
		EditPlugin.JAR[] array = new EditPlugin.JAR[jars.size()];
		jars.copyInto(array);
		return array;
	} 

	
	
	public static EditPlugin.JAR getPluginJAR(String path)
	{
		for(int i = 0; i < jars.size(); i++)
		{
			EditPlugin.JAR jar = (EditPlugin.JAR)jars.elementAt(i);
			if(jar.getPath().equals(path))
				return jar;
		}

		return null;
	} 

	
	
	public static void addPluginJAR(EditPlugin.JAR plugin)
	{
		addActionSet(plugin.getActions());
		jars.addElement(plugin);
	} 

	

	

	
	
	public static void addActionSet(ActionSet actionSet)
	{
		actionSets.addElement(actionSet);
	} 

	
	
	public static ActionSet[] getActionSets()
	{
		ActionSet[] retVal = new ActionSet[actionSets.size()];
		actionSets.copyInto(retVal);
		return retVal;
	} 

	
	
	public static EditAction getAction(String name)
	{
		for(int i = 0; i < actionSets.size(); i++)
		{
			EditAction action = ((ActionSet)actionSets.elementAt(i))
				.getAction(name);
			if(action != null)
				return action;
		}

		return null;
	} 

	
	
	public static ActionSet getActionSetForAction(EditAction action)
	{
		for(int i = 0; i < actionSets.size(); i++)
		{
			ActionSet set = (ActionSet)actionSets.elementAt(i);
			if(set.contains(action))
				return set;
		}

		return null;
	} 

	
	
	public static EditAction[] getActions()
	{
		Vector vec = new Vector();
		for(int i = 0; i < actionSets.size(); i++)
			((ActionSet)actionSets.elementAt(i)).getActions(vec);

		EditAction[] retVal = new EditAction[vec.size()];
		vec.copyInto(retVal);
		return retVal;
	} 

	

	

	
	
	public static void reloadModes()
	{
		
		modes = new Vector(50);

		
		if(jEditHome == null)
			loadModeCatalog(""/modes/catalog"",true);
		else
		{
			loadModeCatalog(MiscUtilities.constructPath(jEditHome,
				""modes"",""catalog""),false);
		} 

		
		if(settingsDirectory != null)
		{
			File userModeDir = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes""));
			if(!userModeDir.exists())
				userModeDir.mkdirs();

			File userCatalog = new File(MiscUtilities.constructPath(
				settingsDirectory,""modes"",""catalog""));
			if(!userCatalog.exists())
			{
				
				try
				{
					FileWriter out = new FileWriter(userCatalog);
					out.write(jEdit.getProperty(""defaultCatalog""));
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,jEdit.class,io);
				}
			}

			loadModeCatalog(userCatalog.getPath(),false);
		} 

		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			
			
			buffer.setMode();

			buffer = buffer.next;
		}
	} 

	
	
	public static Mode getMode(String name)
	{
		for(int i = 0; i < modes.size(); i++)
		{
			Mode mode = (Mode)modes.elementAt(i);
			if(mode.getName().equals(name))
				return mode;
		}
		return null;
	} 

	
	
	public static Mode[] getModes()
	{
		Mode[] array = new Mode[modes.size()];
		modes.copyInto(array);
		return array;
	} 

	

	

	
	
	public static String restoreOpenFiles()
	{
		if(settingsDirectory == null)
			return null;

		File session = new File(MiscUtilities.constructPath(
			settingsDirectory,""session""));

		if(!session.exists())
			return null;

		String splitConfig = null;

		try
		{
			BufferedReader in = new BufferedReader(new FileReader(
				session));

			String line;
			while((line = in.readLine()) != null)
			{
				if(line.startsWith(""splits\t""))
					splitConfig = line.substring(7);
				else
					openFile(null,line);
			}

			in.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,jEdit.class,""Error while loading "" + session);
			Log.log(Log.ERROR,jEdit.class,io);
		}

		return splitConfig;
	} 

	
	
	public static void saveOpenFiles(View view)
	{
		if(settingsDirectory == null)
			return;

		view.getEditPane().saveCaretInfo();

		File session = new File(MiscUtilities.constructPath(
			settingsDirectory,""session""));

		
		

		try
		{
			String lineSep = System.getProperty(""line.separator"");

			BufferedWriter out = new BufferedWriter(new FileWriter(
				session));
			Buffer buffer = buffersFirst;
			while(buffer != null)
			{
				if(!buffer.isUntitled())
				{
					out.write(buffer.getPath());
					out.write(lineSep);
				}

				buffer = buffer.next;
			}

			out.write(""splits\t"");
			out.write(view.getSplitConfig());
			out.write(lineSep);

			out.close();
		}
		catch(IOException io)
		{
			Log.log(Log.ERROR,jEdit.class,""Error while saving "" + session);
			Log.log(Log.ERROR,jEdit.class,io);
		}
	} 

	
	
	public static Buffer openFiles(View view, String parent, String[] args)
	{
		Buffer retVal = null;
		Buffer lastBuffer = null;

		for(int i = 0; i < args.length; i++)
		{
			String arg = args[i];
			if(arg == null)
				continue;
			else if(arg.startsWith(""+line:"") || arg.startsWith(""+marker:""))
			{
				if(lastBuffer != null)
					gotoMarker(view,lastBuffer,arg);
				continue;
			}

			lastBuffer = openFile(null,parent,arg,false,null);

			if(retVal == null && lastBuffer != null)
				retVal = lastBuffer;
		}

		if(view != null && retVal != null)
			view.setBuffer(retVal);

		return retVal;
	} 

	
	
	public static Buffer openFile(View view, String path)
	{
		return openFile(view,null,path,false,new Hashtable());
	} 

	
	
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile)
	{
		return openFile(view,parent,path,newFile,new Hashtable());
	} 

	
	
	public static Buffer openFile(View view, String parent,
		String path, boolean readOnly, boolean newFile,
		Hashtable props)
	{
		return openFile(view,parent,path,newFile,props);
	} 

	
	
	public static Buffer openFile(View view, String parent,
		String path, boolean newFile, Hashtable props)
	{
		if(view != null && parent == null)
			parent = view.getBuffer().getDirectory();

		if(MiscUtilities.isURL(path))
		{
			if(MiscUtilities.getProtocolOfURL(path).equals(""file""))
				path = path.substring(5);
		}

		path = MiscUtilities.constructPath(parent,path);

		if(!MiscUtilities.isURL(path))
			path = MiscUtilities.canonPath(path);

		synchronized(bufferListLock)
		{
			Buffer buffer = getBuffer(path);
			if(buffer != null)
			{
				if(view != null)
					view.setBuffer(buffer);

				return buffer;
			}

			if(props == null)
				props = new Hashtable();

			BufferHistory.Entry entry = BufferHistory.getEntry(path);

			if(entry != null && saveCaret && props.get(Buffer.CARET) == null)
			{
				props.put(Buffer.CARET,new Integer(entry.caret));
				
			}

			if(entry != null && props.get(Buffer.ENCODING) == null)
			{
				if(entry.encoding != null)
					props.put(Buffer.ENCODING,entry.encoding);
			}

			Buffer newBuffer = new Buffer(path,newFile,false,props);

			if(!newBuffer.load(view,false))
				return null;

			addBufferToList(newBuffer);

			EditBus.send(new BufferUpdate(newBuffer,view,BufferUpdate.CREATED));

			if(view != null)
				view.setBuffer(newBuffer);

			return newBuffer;
		}
	} 

	
	
	public static Buffer openTemporary(View view, String parent,
		String path, boolean newFile)
	{
		if(view != null && parent == null)
			parent = view.getBuffer().getDirectory();

		if(MiscUtilities.isURL(path))
		{
			if(MiscUtilities.getProtocolOfURL(path).equals(""file""))
				path = path.substring(5);
		}

		path = MiscUtilities.constructPath(parent,path);

		synchronized(bufferListLock)
		{
			Buffer buffer = getBuffer(path);
			if(buffer != null)
				return buffer;

			buffer = new Buffer(path,newFile,true,new Hashtable());
			if(!buffer.load(view,false))
				return null;
			else
				return buffer;
		}
	} 

	
	
	public static void commitTemporary(Buffer buffer)
	{
		if(!buffer.isTemporary())
			return;

		addBufferToList(buffer);
		buffer.commitTemporary();

		
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.CREATED));
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOAD_STARTED));
		EditBus.send(new BufferUpdate(buffer,null,BufferUpdate.LOADED));
	} 

	
	
	public static Buffer newFile(View view)
	{
		String path;

		if(view != null && view.getBuffer() != null)
		{
			path = view.getBuffer().getDirectory();
			VFS vfs = VFSManager.getVFSForPath(path);
			
			
			if((vfs.getCapabilities() & VFS.WRITE_CAP) == 0)
				path = System.getProperty(""user.home"");
		}
		else
			path = null;

		return newFile(view,path);
	} 

	
	
	public static Buffer newFile(View view, String dir)
	{
		
		
		if(dir != null
			&& buffersFirst != null
			&& buffersFirst == buffersLast
			&& buffersFirst.isUntitled()
			&& !buffersFirst.isDirty())
		{
			closeBuffer(view,buffersFirst);
			
			return buffersFirst;
		}

		
		int untitledCount = 0;
		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.getName().startsWith(""Untitled-""))
			{
				try
				{
					untitledCount = Math.max(untitledCount,
						Integer.parseInt(buffer.getName()
						.substring(9)));
				}
				catch(NumberFormatException nf)
				{
				}
			}
			buffer = buffer.next;
		}

		return openFile(view,dir,""Untitled-"" + (untitledCount+1),true,null);
	} 

	

	

	
	
	public static boolean closeBuffer(View view, Buffer buffer)
	{
		
		if(buffer.isPerformingIO())
		{
			VFSManager.waitForRequests();
			if(VFSManager.errorOccurred())
				return false;
		}

		if(buffer.isDirty())
		{
			Object[] args = { buffer.getName() };
			int result = GUIUtilities.confirm(view,""notsaved"",args,
				JOptionPane.YES_NO_CANCEL_OPTION,
				JOptionPane.WARNING_MESSAGE);
			if(result == JOptionPane.YES_OPTION)
			{
				if(!buffer.save(view,null,true))
					return false;

				VFSManager.waitForRequests();
				if(buffer.getBooleanProperty(BufferIORequest
					.ERROR_OCCURRED))
				{
					return false;
				}
			}
			else if(result != JOptionPane.NO_OPTION)
				return false;
		}

		_closeBuffer(view,buffer);

		return true;
	} 

	
	
	public static void _closeBuffer(View view, Buffer buffer)
	{
		if(buffer.isClosed())
		{
			
			
			return;
		}

		if(!buffer.isNewFile())
		{
			view.getEditPane().saveCaretInfo();
			Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
			int caret = (_caret == null ? 0 : _caret.intValue());

			BufferHistory.setEntry(buffer.getPath(),caret,
				(Selection[])buffer.getProperty(Buffer.SELECTION),
				buffer.getStringProperty(Buffer.ENCODING));
		}

		removeBufferFromList(buffer);
		buffer.close();

		EditBus.send(new BufferUpdate(buffer,view,BufferUpdate.CLOSED));

		
		if(buffersFirst == null && buffersLast == null)
			newFile(view);
	} 

	
	
	public static boolean closeAllBuffers(View view)
	{
		return closeAllBuffers(view,false);
	} 

	
	
	public static boolean closeAllBuffers(View view, boolean isExiting)
	{
		boolean dirty = false;

		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
			{
				dirty = true;
				break;
			}
			buffer = buffer.next;
		}

		if(dirty)
		{
			boolean ok = new CloseDialog(view).isOK();
			if(!ok)
				return false;
		}

		
		VFSManager.waitForRequests();
		if(VFSManager.errorOccurred())
			return false;

		
		

		buffer = buffersFirst;

		
		buffersFirst = buffersLast = null;
		bufferCount = 0;

		while(buffer != null)
		{
			if(!buffer.isNewFile())
			{
				Integer _caret = (Integer)buffer.getProperty(Buffer.CARET);
				int caret = (_caret == null ? 0 : _caret.intValue());
				BufferHistory.setEntry(buffer.getPath(),caret,
					(Selection[])buffer.getProperty(Buffer.SELECTION),
					buffer.getStringProperty(Buffer.ENCODING));
			}

			buffer.close();
			if(!isExiting)
			{
				EditBus.send(new BufferUpdate(buffer,view,
					BufferUpdate.CLOSED));
			}
			buffer = buffer.next;
		}

		if(!isExiting)
			newFile(view);

		return true;
	} 

	
	
	public static void saveAllBuffers(View view, boolean confirm)
	{
		if(confirm)
		{
			int result = GUIUtilities.confirm(view,""saveall"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}

		Buffer current = view.getBuffer();

		Buffer buffer = buffersFirst;
		while(buffer != null)
		{
			if(buffer.isDirty())
			{
				if(buffer.isNewFile())
					view.setBuffer(buffer);
				buffer.save(view,null,true);
			}

			buffer = buffer.next;
		}

		view.setBuffer(current);
	} 

	
	
	public static void reloadAllBuffers(final View view, boolean confirm)
	{
		if(confirm)
		{
			int result = GUIUtilities.confirm(view,""reload-all"",null,
				JOptionPane.YES_NO_OPTION,
				JOptionPane.QUESTION_MESSAGE);
			if(result != JOptionPane.YES_OPTION)
				return;
		}

		
		View _view = viewsFirst;
		while(_view != null)
		{
			EditPane[] panes = _view.getEditPanes();
			for(int i = 0; i < panes.length; i++)
			{
				panes[i].saveCaretInfo();
			}

			_view = _view.next;
		}

		Buffer[] buffers = jEdit.getBuffers();
		for(int i = 0; i < buffers.length; i++)
		{
			Buffer buffer = buffers[i];
			buffer.load(view,true);
		}
	} 

	
	
	public static Buffer getBuffer(String path)
	{
		boolean caseInsensitiveFilesystem = (File.separatorChar == '\\'
			|| File.separatorChar == ':' );

		synchronized(bufferListLock)
		{
			Buffer buffer = buffersFirst;
			while(buffer != null)
			{
				String _path = buffer.getPath();
				if(caseInsensitiveFilesystem)
				{
					if(_path.equalsIgnoreCase(path))
						return buffer;
				}
				else
				{
					if(_path.equals(path))
						return buffer;
				}
				buffer = buffer.next;
			}
		}

		return null;
	} 

	
	
	public static Buffer[] getBuffers()
	{
		synchronized(bufferListLock)
		{
			Buffer[] buffers = new Buffer[bufferCount];
			Buffer buffer = buffersFirst;
			for(int i = 0; i < bufferCount; i++)
			{
				buffers[i] = buffer;
				buffer = buffer.next;
			}
			return buffers;
		}
	} 

	
	
	public static int getBufferCount()
	{
		return bufferCount;
	} 

	
	
	public static Buffer getFirstBuffer()
	{
		return buffersFirst;
	} 

	
	
	public static Buffer getLastBuffer()
	{
		return buffersLast;
	} 

	

	

	
	
	public static InputHandler getInputHandler()
	{
		return inputHandler;
	} 

	

	
	
	public static View newView(View view, Buffer buffer)
	{
		return newView(view,buffer,false);
	} 

	
	
	public static View newView(View view, Buffer buffer, boolean plainView)
	{
		if(view != null)
		{
			view.showWaitCursor();
			view.getEditPane().saveCaretInfo();
		}

		View newView = new View(buffer,null,plainView);

		
		
		
		newView.pack();

		
		
		if(view != null)
		{
			GUIUtilities.saveGeometry(view,(view.isPlainView()
				? ""plain-view"" : ""view""));
			view.hideWaitCursor();
		}

		GUIUtilities.loadGeometry(newView,(plainView
				? ""plain-view"" : ""view""));

		addViewToList(newView);
		EditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));

		newView.show();

		
		if(newView == viewsFirst)
		{
			newView.getTextArea().requestFocus();

			
			
			if(settingsDirectory != null && getBooleanProperty(""firstTime""))
				new HelpViewer();
			else if(jEdit.getBooleanProperty(""tip.show""))
				new TipOfTheDay(newView);

			setBooleanProperty(""firstTime"",false);
		}
		else
			GUIUtilities.requestFocus(newView,newView.getTextArea());

		return newView;
	} 

	
	
	public static View newView(View view)
	{
		return newView(view,view.getSplitConfig(),false);
	} 

	
	
	public static View newView(View view, String splitConfig)
	{
		return newView(view,splitConfig,false);
	} 

	
	
	public static View newView(View view, String splitConfig, boolean plainView)
	{
		if(view != null)
		{
			view.showWaitCursor();
			view.getEditPane().saveCaretInfo();
		}

		View newView = new View(null,splitConfig,plainView);

		
		
		
		newView.pack();

		
		
		if(view != null)
		{
			GUIUtilities.saveGeometry(view,(view.isPlainView()
				? ""plain-view"" : ""view""));
			view.hideWaitCursor();
		}

		GUIUtilities.loadGeometry(newView,(plainView ? ""plain-view""
				: ""view""));

		addViewToList(newView);
		EditBus.send(new ViewUpdate(newView,ViewUpdate.CREATED));

		newView.show();

		
		if(newView == viewsFirst)
		{
			newView.getTextArea().requestFocus();

			
			
			if(settingsDirectory != null && getBooleanProperty(""firstTime""))
				new HelpViewer();
			else if(jEdit.getBooleanProperty(""tip.show""))
				new TipOfTheDay(newView);

			setBooleanProperty(""firstTime"",false);
		}
		else
			GUIUtilities.requestFocus(newView,newView.getTextArea());

		return newView;
	} 

	
	
	public static void closeView(View view)
	{
		closeView(view,true);
	} 

	
	
	public static View[] getViews()
	{
		View[] views = new View[viewCount];
		View view = viewsFirst;
		for(int i = 0; i < viewCount; i++)
		{
			views[i] = view;
			view = view.next;
		}
		return views;
	} 

	
	
	public static int getViewCount()
	{
		return viewCount;
	} 

	
	
	public static View getFirstView()
	{
		return viewsFirst;
	} 

	
	
	public static View getLastView()
	{
		return viewsLast;
	} 

	
	
	public static View getActiveView()
	{
		return activeView;
	} 

	

	

	
	
	public static boolean isBackgroundModeEnabled()
	{
		return background;
	} 

	
	
	public static void showMemoryDialog(View view)
	{
		Runtime rt = Runtime.getRuntime();
		int before = (int) (rt.freeMemory() / 1024);
		System.gc();
		int after = (int) (rt.freeMemory() / 1024);
		int total = (int) (rt.totalMemory() / 1024);

		JProgressBar progress = new JProgressBar(0,total);
		progress.setValue(total - after);
		progress.setStringPainted(true);
		progress.setString(jEdit.getProperty(""memory-status.use"",
			new Object[] { new Integer(total - after),
			new Integer(total) }));

		Object[] message = new Object[4];
		message[0] = getProperty(""memory-status.gc"",
			new Object[] { new Integer(after - before) });
		message[1] = Box.createVerticalStrut(12);
		message[2] = progress;
		message[3] = Box.createVerticalStrut(6);

		JOptionPane.showMessageDialog(view,message,
			jEdit.getProperty(""memory-status.title""),
			JOptionPane.INFORMATION_MESSAGE);
	} 

	
	
	public static String getJEditHome()
	{
		return jEditHome;
	} 

	
	
	public static String getSettingsDirectory()
	{
		return settingsDirectory;
	} 

	
	
	public static void backupSettingsFile(File file)
	{
		if(settingsDirectory == null)
			return;

		String backupDir = MiscUtilities.constructPath(
			settingsDirectory,""settings-backup"");
		File dir = new File(backupDir);
		if(!dir.exists())
			dir.mkdirs();

		
		

		MiscUtilities.saveBackup(file,5,null,""~"",backupDir);
	} 

	
	
	public static void saveSettings()
	{
		if(settingsDirectory != null)
		{
			
			File file1 = new File(MiscUtilities.constructPath(
				settingsDirectory, ""#recent.xml#save#""));
			File file2 = new File(MiscUtilities.constructPath(
				settingsDirectory, ""recent.xml""));
			if(file2.exists() && file2.lastModified() != recentModTime)
			{
				Log.log(Log.WARNING,jEdit.class,file2 + "" changed""
					+ "" on disk; will not save recent files"");
			}
			else
			{
				backupSettingsFile(file2);
				BufferHistory.save(file1);
				file2.delete();
				file1.renameTo(file2);
			}
			recentModTime = file2.lastModified();

			file1 = new File(MiscUtilities.constructPath(
				settingsDirectory, ""#history#save#""));
			file2 = new File(MiscUtilities.constructPath(
				settingsDirectory, ""history""));
			if(file2.exists() && file2.lastModified() != historyModTime)
			{
				Log.log(Log.WARNING,jEdit.class,file2 + "" changed""
					+ "" on disk; will not save history"");
			}
			else
			{
				backupSettingsFile(file2);
				HistoryModel.saveHistory(file1);
				file2.delete();
				file1.renameTo(file2);
			}
			historyModTime = file2.lastModified();

			SearchAndReplace.save();
			Abbrevs.save();
			FavoritesVFS.saveFavorites();

			file1 = new File(MiscUtilities.constructPath(
				settingsDirectory,""#properties#save#""));
			file2 = new File(MiscUtilities.constructPath(
				settingsDirectory,""properties""));
			if(file2.exists() && file2.lastModified() != propsModTime)
			{
				Log.log(Log.WARNING,jEdit.class,file2 + "" changed""
					+ "" on disk; will not save user properties"");
			}
			else
			{
				backupSettingsFile(file2);

				try
				{
					OutputStream out = new FileOutputStream(file1);
					props.store(out,""jEdit properties"");
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,jEdit.class,io);
				}

				file2.delete();
				file1.renameTo(file2);
			}
			propsModTime = file2.lastModified();
		}
	} 

	
	
	public static void exit(View view, boolean reallyExit)
	{
		
		VFSManager.waitForRequests();

		
		EditBus.send(new EditorExitRequested(view));

		
		
		reallyExit |= !background;

		if (view != null)
			saveOpenFiles(view);

		
		if(!closeAllBuffers(view,reallyExit))
			return;

		
		
		if(!reallyExit)
		{
			
			
			
			view = viewsFirst;
			while(view != null)
			{
				closeView(view,false);
				view = view.next;
			}

			
			
			saveSettings();

			return;
		}

		
		
		
		if (view != null)
			view.close();

		
		Autosave.stop();

		
		if(server != null)
			server.stopServer();

		
		EditPlugin[] plugins = getPlugins();
		for(int i = 0; i < plugins.length; i++)
		{
			try
			{
				plugins[i].stop();
			}
			catch(Throwable t)
			{
				Log.log(Log.ERROR,jEdit.class,""Error while ""
					+ ""stopping plugin:"");
				Log.log(Log.ERROR,jEdit.class,t);
			}
		}

		
		EditBus.send(new EditorExiting(null));

		
		saveSettings();

		
		Log.closeStream();

		
		System.exit(0);
	} 

	

	

	
	
	static void updatePosition(Buffer buffer)
	{
		if(sortBuffers)
		{
			removeBufferFromList(buffer);
			addBufferToList(buffer);
		}
	} 

	
	
	public static void addMode(Mode mode)
	{
		Log.log(Log.DEBUG,jEdit.class,""Adding edit mode ""
			+ mode.getName());

		modes.addElement(mode);
	} 

	
	
	 static void loadMode(Mode mode)
	{
		Object fileName = mode.getProperty(""file"");

		Log.log(Log.NOTICE,jEdit.class,""Loading edit mode "" + fileName);

		XmlParser parser = new XmlParser();
		XModeHandler xmh = new XModeHandler(parser,mode.getName(),fileName.toString());
		parser.setHandler(xmh);
		try
		{
			Reader grammar;
			if(fileName instanceof URL)
			{
				grammar = new BufferedReader(
					new InputStreamReader(
					((URL)fileName).openStream()));
			}
			else
			{
				grammar = new BufferedReader(new FileReader(
					(String)fileName));
			}

			parser.parse(null, null, grammar);
		}
		catch (Throwable e)
		{
			Log.log(Log.ERROR, jEdit.class, e);

			if (e instanceof XmlException)
			{
				XmlException xe = (XmlException) e;
				int line = xe.getLine();
				String message = xe.getMessage();

				Object[] args = { fileName, new Integer(line), null,
					message };
				GUIUtilities.error(null,""xmode-error"",args);
			}

			
			TokenMarker marker = new TokenMarker();
			marker.addRuleSet(""MAIN"",new ParserRuleSet(""MAIN"",mode));
			mode.setTokenMarker(marker);
		}
	} 

	
	
	 static void loadProps(InputStream in, boolean def)
		throws IOException
	{
		in = new BufferedInputStream(in);
		if(def)
			defaultProps.load(in);
		else
			props.load(in);
		in.close();
	} 

	
	
	static boolean loadActions(String path, Reader in, ActionSet actionSet)
	{
		try
		{
			

			ActionListHandler ah = new ActionListHandler(path,actionSet);
			XmlParser parser = new XmlParser();
			parser.setHandler(ah);
			parser.parse(null, null, in);
			return true;
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,jEdit.class,path + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}

		return false;
	} 

	
	static void pluginError(final String path, String messageProp, Object[] args)
	{
		if(pluginErrors == null)
			pluginErrors = new Vector();

		pluginErrors.addElement(new ErrorListDialog.ErrorEntry(
			path,messageProp,args));
	} 

	
	static void setActiveView(View view)
	{
		jEdit.activeView = view;
	} 

	

	

	
	private static String jEditHome;
	private static String settingsDirectory;
	private static long propsModTime, historyModTime, recentModTime;
	private static Properties defaultProps;
	private static Properties props;
	private static EditServer server;
	private static boolean background;
	private static Vector actionSets;
	private static ActionSet builtInActionSet;
	private static Vector pluginErrors;
	private static Vector jars;
	private static Vector modes;
	private static boolean saveCaret;
	private static InputHandler inputHandler;
	private static JEditMetalTheme theme;

	
	private static boolean sortBuffers;
	private static boolean sortByName;
	private static int bufferCount;
	private static Buffer buffersFirst;
	private static Buffer buffersLast;

	
	private static Object bufferListLock = new Object();

	
	private static int viewCount;
	private static View viewsFirst;
	private static View viewsLast;
	private static View activeView;
	

	private jEdit() {}

	
	private static void usage()
	{
		System.out.println(""Usage: jedit [<options>] [<files>]"");

		System.out.println(""	<file> +marker:<marker>: Positions caret""
			+ "" at marker <marker>"");
		System.out.println(""	<file> +line:<line>: Positions caret""
			+ "" at line number <line>"");
		System.out.println(""	--: End of options"");
		System.out.println(""	-background: Run in background mode"");
		System.out.println(""	-nogui: Only if running in background mode;""
			+ "" don't open initial view"");
		System.out.println(""	-norestore: Don't restore previously open files"");
		System.out.println(""	-run=<script>: Run the specified BeanShell script"");
		System.out.println(""	-server: Read/write server""
			+ "" info from/to $HOME/.jedit/server"");
		System.out.println(""	-server=<name>: Read/write server""
			+ "" info from/to $HOME/.jedit/<name>"");
		System.out.println(""	-noserver: Don't start edit server"");
		System.out.println(""	-settings=<path>: Load user-specific""
			+ "" settings from <path>"");
		System.out.println(""	-nosettings: Don't load user-specific""
			+ "" settings"");
		System.out.println(""	-noplugins: Don't load any plugins"");
		System.out.println(""	-nostartupscripts: Don't run startup scripts"");
		System.out.println(""	-version: Print jEdit version and exit"");
		System.out.println(""	-usage: Print this message and exit"");
		System.out.println();
		System.out.println(""To set minimum activity log level,""
			+ "" specify a number as the first"");
		System.out.println(""command line parameter""
			+ "" (1-9, 1 = print everything, 9 = fatal errors only)"");
		System.out.println();
		System.out.println(""Report bugs to Slava Pestov <slava@jedit.org>."");
	} 

	
	private static void version()
	{
		System.out.println(""jEdit "" + getVersion());
	} 

	
	
	private static String makeServerScript(boolean restore,
		String[] args, String scriptFile)
	{
		StringBuffer script = new StringBuffer();

		String userDir = System.getProperty(""user.dir"");

		script.append(""parent = \"""");
		script.append(MiscUtilities.charsToEscapes(userDir));
		script.append(""\"";\n"");

		script.append(""args = new String["");
		script.append(args.length);
		script.append(""];\n"");

		for(int i = 0; i < args.length; i++)
		{
			script.append(""args["");
			script.append(i);
			script.append(""] = "");

			if(args[i] == null)
				script.append(""null"");
			else
			{
				script.append('""');
				script.append(MiscUtilities.charsToEscapes(args[i]));
				script.append('""');
			}

			script.append("";\n"");
		}

		script.append(""EditServer.handleClient("" + restore + "",parent,args);\n"");

		if(scriptFile != null)
		{
			scriptFile = MiscUtilities.constructPath(userDir,scriptFile);
			script.append(""BeanShell.runScript(null,\""""
				+ MiscUtilities.charsToEscapes(scriptFile)
				+ ""\"",null,false);\n"");
		}

		return script.toString();
	} 

	
	
	private static void initMisc()
	{
		
		System.getProperties().put(""java.protocol.handler.pkgs"",
			""org.gjt.sp.jedit.proto|"" +
			System.getProperty(""java.protocol.handler.pkgs"",""""));

		
		String userAgent = ""jEdit/"" + getVersion()
			+ "" (Java "" + System.getProperty(""java.version"")
			+ "". "" + System.getProperty(""java.vendor"")
			+ ""; "" + System.getProperty(""os.arch"") + "")"";
		System.getProperties().put(""http.agent"",userAgent);

		inputHandler = new DefaultInputHandler(null);

		
		jEditHome = System.getProperty(""jedit.home"");
		if(jEditHome == null)
		{
			String classpath = System
				.getProperty(""java.class.path"");
			int index = classpath.toLowerCase()
				.indexOf(""jedit.jar"");
			int start = classpath.lastIndexOf(File
				.pathSeparator,index) + 1;
			
			 if(classpath.equalsIgnoreCase(""jedit.jar""))
			{
				jEditHome = System.getProperty(""user.dir"");
			}
			else if(index > start)
			{
				jEditHome = classpath.substring(start,
					index - 1);
			}
			else
			{
				
				
				{
					
					jEditHome = System.getProperty(""user.dir"");

					Log.log(Log.WARNING,jEdit.class,""jedit.jar not in class path!"");
					Log.log(Log.WARNING,jEdit.class,""Assuming jEdit is installed in ""
						+ jEditHome + ""."");
					Log.log(Log.WARNING,jEdit.class,""Override with jedit.home ""
						+ ""system property."");
				}
			}
		}

		Log.log(Log.MESSAGE,jEdit.class,""jEdit home directory is "" + jEditHome);

		
		

		jars = new Vector();

		
		
		EditBus.addToBus(new SettingsReloader());

		
		
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				Thread.currentThread().setContextClassLoader(
					new JARClassLoader());
			}
		});
	} 

	
	
	private static void initSystemProperties()
	{
		defaultProps = props = new Properties();

		try
		{
			loadProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit.props""),true);
			loadProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_gui.props""),true);
			loadProps(jEdit.class.getResourceAsStream(
				""/org/gjt/sp/jedit/jedit_keys.props""),true);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,
				""Error while loading system properties!"");
			Log.log(Log.ERROR,jEdit.class,
				""One of the following property files could not be loaded:\n""
				+ ""- jedit.props\n""
				+ ""- jedit_gui.props\n""
				+ ""- jedit_keys.props\n""
				+ ""jedit.jar is probably corrupt."");
			Log.log(Log.ERROR,jEdit.class,e);
			System.exit(1);
		}
	} 

	
	
	private static void initSiteProperties()
	{
		
		

		String siteSettingsDirectory = MiscUtilities.constructPath(
			jEditHome, ""properties"");
		File siteSettings = new File(siteSettingsDirectory);

		if (!(siteSettings.exists() && siteSettings.isDirectory()))
			return;

		String[] snippets = siteSettings.list();
		if (snippets == null)
			return;

		MiscUtilities.quicksort(snippets,
			new MiscUtilities.StringICaseCompare());

		for (int i = 0; i < snippets.length; ++i)
		{
			String snippet = snippets[i];
			if(!snippet.toLowerCase().endsWith("".props""))
				continue;

			try
			{
				String path = MiscUtilities.constructPath(
					siteSettingsDirectory,snippet);
				Log.log(Log.DEBUG,jEdit.class,
					""Loading site snippet: "" + path);

				loadProps(new FileInputStream(new File(path)),true);
			}
			catch(FileNotFoundException fnf)
			{
				Log.log(Log.DEBUG,jEdit.class,fnf);
			}
			catch(IOException e)
			{
				Log.log(Log.ERROR,jEdit.class,""Cannot load site snippet ""
					+ snippet);
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} 

	
	
	private static void initActions()
	{
		actionSets = new Vector();

		Reader in = new BufferedReader(new InputStreamReader(
			jEdit.class.getResourceAsStream(""actions.xml"")));
		builtInActionSet = new ActionSet(jEdit.getProperty(
			""action-set.jEdit""));
		if(!loadActions(""actions.xml"",in,builtInActionSet))
			System.exit(1);
		addActionSet(builtInActionSet);
	} 

	
	
	private static void initDockables()
	{
		Reader in = new BufferedReader(new InputStreamReader(
			jEdit.class.getResourceAsStream(""dockables.xml"")));
		if(!DockableWindowManager.loadDockableWindows(""dockables.xml"",
			in,builtInActionSet))
			System.exit(1);
	} 

	
	
	private static void initPlugins()
	{
		if(jEditHome != null)
			loadPlugins(MiscUtilities.constructPath(jEditHome,""jars""));

		if(settingsDirectory != null)
		{
			File jarsDirectory = new File(settingsDirectory,""jars"");
			if(!jarsDirectory.exists())
				jarsDirectory.mkdir();
			loadPlugins(jarsDirectory.getPath());
		}
	} 

	
	
	private static void initUserProperties()
	{
		props = new Properties(defaultProps);

		if(settingsDirectory != null)
		{
			File file = new File(MiscUtilities.constructPath(
				settingsDirectory,""properties""));
			propsModTime = file.lastModified();

			try
			{
				loadProps(new FileInputStream(file),false);
			}
			catch(FileNotFoundException fnf)
			{
				Log.log(Log.DEBUG,jEdit.class,fnf);
			}
			catch(IOException e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} 

	
	
	private static void initPLAF()
	{
		theme = new JEditMetalTheme();
		theme.propertiesChanged();
		MetalLookAndFeel.setCurrentTheme(theme);

		try
		{
			String lf = getProperty(""lookAndFeel"");
			if(lf != null && lf.length() != 0)
				UIManager.setLookAndFeel(lf);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}

		UIDefaults defaults = UIManager.getDefaults();

		
		if(jEdit.getBooleanProperty(""textColors""))
		{
			Color background = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.bgColor""));
			Color foreground = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.fgColor""));
			Color caretColor = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.caretColor""));
			Color selectionColor = new javax.swing.plaf.ColorUIResource(
				jEdit.getColorProperty(""view.selectionColor""));

			String[] prefixes = { ""TextField"", ""TextArea"", ""List"", ""Table"" };
			for(int i = 0; i < prefixes.length; i++)
			{
				String prefix = prefixes[i];
				defaults.put(prefix + "".disabledBackground"",background);
				defaults.put(prefix + "".background"",background);
				defaults.put(prefix + "".disabledForeground"",foreground);
				defaults.put(prefix + "".foreground"",foreground);
				defaults.put(prefix + "".caretForeground"",caretColor);
				defaults.put(prefix + "".selectionForeground"",foreground);
				defaults.put(prefix + "".selectionBackground"",selectionColor);
				
			}

			defaults.put(""Tree.background"",background);
			defaults.put(""Tree.foreground"",foreground);
			defaults.put(""Tree.textBackground"",background);
			defaults.put(""Tree.textForeground"",foreground);
			defaults.put(""Tree.selectionForeground"",foreground);
			defaults.put(""Tree.selectionBackground"",selectionColor);
		}

		defaults.remove(""SplitPane.border"");
		defaults.remove(""SplitPaneDivider.border"");
	} 

	
	
	private static void runStartupScripts(File directory)
	{
		if (!directory.isDirectory())
			return;

		File[] snippets = directory.listFiles();
		if (snippets == null)
			return;

		MiscUtilities.quicksort(snippets,
			new MiscUtilities.StringICaseCompare());

		for(int i = 0; i < snippets.length; ++i)
		{
			File snippet = snippets[i];

			Macros.Handler handler = Macros.getHandlerForPathName(
				snippet.getPath());
			if(handler == null)
				continue;

			try
			{
				Macros.Macro newMacro = handler.createMacro(
					snippet.getName(),
					snippet.getPath());
				handler.runMacro(null,newMacro,false);
			}
			catch(Exception e)
			{
				Log.log(Log.ERROR,jEdit.class,e);
			}
		}
	} 

	
	private static void initProxy()
	{
		boolean socksEnabled = jEdit.getBooleanProperty(""socks.enabled"");
		if(!socksEnabled)
		{
			Log.log(Log.DEBUG,jEdit.class,""SOCKS proxy disabled"");
                        System.getProperties().remove(""socksProxyHost"");
                        System.getProperties().remove(""socksProxyPort"");
		}
		else
		{
			String socksHost = jEdit.getProperty(""firewall.socks.host"");
			if( socksHost != null )
			{
				System.setProperty(""socksProxyHost"", socksHost);
				Log.log(Log.DEBUG, jEdit.class,
					""SOCKS proxy enabled: "" + socksHost);
                        }

			String socksPort =  jEdit.getProperty(""firewall.socks.port"");
			if(socksPort != null)
				System.setProperty(""socksProxyPort"", socksPort);
		}

		boolean httpEnabled = jEdit.getBooleanProperty(""firewall.enabled"");
		if (!httpEnabled)
		{
			Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy disabled"");
			System.getProperties().remove(""proxySet"");
			System.getProperties().remove(""proxyHost"");
			System.getProperties().remove(""proxyPort"");
			System.getProperties().remove(""http.proxyHost"");
			System.getProperties().remove(""http.proxyPort"");
			System.getProperties().remove(""http.nonProxyHosts"");
			Authenticator.setDefault(null);
		}
		else
		{
			
			String host = jEdit.getProperty(""firewall.host"");
			if (host == null)
				return;

			System.setProperty(""http.proxyHost"", host);
			Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy enabled: "" + host);
			
			String port = jEdit.getProperty(""firewall.port"");
			if (port != null)
				System.setProperty(""http.proxyPort"", port);

			
			String nonProxyHosts = jEdit.getProperty(""firewall.nonProxyHosts"");
			if (nonProxyHosts != null)
				System.setProperty(""http.nonProxyHosts"", nonProxyHosts);

			
			String username = jEdit.getProperty(""firewall.user"");
			String password = jEdit.getProperty(""firewall.password"");

			
			if(password == null)
				password = """";

			if(username == null || username.length()==0)
			{
				Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy without user"");
				Authenticator.setDefault(new FirewallAuthenticator(null));
			}
			else
			{
				Log.log(Log.DEBUG, jEdit.class, ""HTTP proxy user: "" + username);
				PasswordAuthentication pw = new PasswordAuthentication(
					username,password.toCharArray()
				);
				Authenticator.setDefault(new FirewallAuthenticator(pw));
			}
		}
	} 

	
	static class FirewallAuthenticator extends Authenticator
	{
		PasswordAuthentication pw;

		public FirewallAuthenticator(PasswordAuthentication pw)
		{
			this.pw = pw;
		}

		protected PasswordAuthentication getPasswordAuthentication()
		{
			return pw;
		}
	} 

	
	private static void finishStartup(final boolean gui, final boolean restore,
		final String userDir, final String[] args)
	{
		SwingUtilities.invokeLater(new Runnable() {
			public void run()
			{
				Buffer buffer = openFiles(null,userDir,args);

				String splitConfig = null;

				if(restore && settingsDirectory != null
					&& jEdit.getBooleanProperty(""restore"")
					&& (bufferCount == 0 || jEdit.getBooleanProperty(""restore.cli"")))
				{
					splitConfig = restoreOpenFiles();
				}

				if(bufferCount == 0 && gui)
					newFile(null);

				EditBus.send(new EditorStarted(null));

				if(gui || buffer != null)
				{
					if(buffer != null)
						newView(null,buffer);
					else
						newView(null,splitConfig);
				}

				
				VFSManager.start();

				
				if(server != null)
					server.start();

				GUIUtilities.hideSplashScreen();

				Log.log(Log.MESSAGE,jEdit.class,""Startup ""
					+ ""complete"");

				
				if(pluginErrors != null)
				{
					String caption = jEdit.getProperty(
						""plugin-error.caption"" + (pluginErrors.size() == 1
						? ""-1"" : """"),new Integer[] {
						new Integer(pluginErrors.size()) });

					new ErrorListDialog(
						jEdit.getFirstView(),
						jEdit.getProperty(""plugin-error.title""),
						caption,pluginErrors,true);
					pluginErrors.removeAllElements();
				} 

				
				
				
				
				Toolkit.getDefaultToolkit();
			}
		});
	} 

	
	private static void getNotLoadedPluginJARs(Vector returnValue,
		String dir, String[] list)
	{
loop:		for(int i = 0; i < list.length; i++)
		{
			String name = list[i];
			if(!name.toLowerCase().endsWith("".jar""))
				continue loop;

			String path = MiscUtilities.constructPath(dir,name);

			for(int j = 0; j < jars.size(); j++)
			{
				EditPlugin.JAR jar = (EditPlugin.JAR)
					jars.elementAt(j);
				String jarPath = jar.getPath();
				String jarName = MiscUtilities.getFileName(jarPath);

				if(path.equals(jarPath))
					continue loop;
				else if(!new File(jarPath).exists()
					&& name.equals(jarName))
					continue loop;
			}

			returnValue.addElement(path);
		}
	} 

	
	private static void gotoMarker(final View view, final Buffer buffer,
		final String marker)
	{
		VFSManager.runInAWTThread(new Runnable()
		{
			public void run()
			{
				int pos;

				
				if(marker.startsWith(""+line:""))
				{
					try
					{
						int line = Integer.parseInt(marker.substring(6));
						pos = buffer.getLineStartOffset(line - 1);
					}
					catch(Exception e)
					{
						return;
					}
				}
				
				else if(marker.startsWith(""+marker:""))
				{
					if(marker.length() != 9)
						return;

					Marker m = buffer.getMarker(marker.charAt(8));
					if(m == null)
						return;
					pos = m.getPosition();
				}
				
				else
					throw new InternalError();

				if(view != null && view.getBuffer() == buffer)
					view.getTextArea().setCaretPosition(pos);
				else
					buffer.setIntegerProperty(Buffer.CARET,pos);
			}
		});
	} 

	
	private static void addBufferToList(Buffer buffer)
	{
		
		
		if(viewCount <= 1 && buffersFirst != null
			&& buffersFirst == buffersLast
			&& buffersFirst.isUntitled()
			&& !buffersFirst.isDirty())
		{
			Buffer oldBuffersFirst = buffersFirst;
			buffersFirst = buffersLast = buffer;
			EditBus.send(new BufferUpdate(oldBuffersFirst,null,
				BufferUpdate.CLOSED));
			return;
		}

		bufferCount++;

		if(buffersFirst == null)
		{
			buffersFirst = buffersLast = buffer;
			return;
		}
		
		else if(sortBuffers)
		{
			String str11, str12;
			if(sortByName)
			{
				str11 = buffer.getName();
				str12 = buffer.getDirectory();
			}
			else
			{
				str11 = buffer.getDirectory();
				str12 = buffer.getName();
			}

			Buffer _buffer = buffersFirst;
			while(_buffer != null)
			{
				String str21, str22;
				if(sortByName)
				{
					str21 = _buffer.getName();
					str22 = _buffer.getDirectory();
				}
				else
				{
					str21 = _buffer.getDirectory();
					str22 = _buffer.getName();
				}

				int comp = MiscUtilities.compareStrings(str11,str21,true);
				if(comp <= 0 || (comp == 0 && MiscUtilities.compareStrings(str12,str22,true) <= 0))
				{
					buffer.next = _buffer;
					buffer.prev = _buffer.prev;
					_buffer.prev = buffer;
					if(_buffer != buffersFirst)
						buffer.prev.next = buffer;
					else
						buffersFirst = buffer;
					return;
				}

				_buffer = _buffer.next;
			}
		} 

		buffer.prev = buffersLast;
		buffersLast.next = buffer;
		buffersLast = buffer;
	} 

	
	private static void removeBufferFromList(Buffer buffer)
	{
		synchronized(bufferListLock)
		{
			bufferCount--;

			if(buffer == buffersFirst && buffer == buffersLast)
			{
				buffersFirst = buffersLast = null;
				return;
			}

			if(buffer == buffersFirst)
			{
				buffersFirst = buffer.next;
				buffer.next.prev = null;
			}
			else
			{
				buffer.prev.next = buffer.next;
			}

			if(buffer == buffersLast)
			{
				buffersLast = buffersLast.prev;
				buffer.prev.next = null;
			}
			else
			{
				buffer.next.prev = buffer.prev;
			}

			
			
			buffer.next = buffer.prev = null;
		}
	} 

	
	private static void addViewToList(View view)
	{
		viewCount++;

		if(viewsFirst == null)
			viewsFirst = viewsLast = view;
		else
		{
			view.prev = viewsLast;
			viewsLast.next = view;
			viewsLast = view;
		}
	} 

	
	private static void removeViewFromList(View view)
	{
		viewCount--;

		if(viewsFirst == viewsLast)
		{
			viewsFirst = viewsLast = null;
			return;
		}

		if(view == viewsFirst)
		{
			viewsFirst = view.next;
			view.next.prev = null;
		}
		else
		{
			view.prev.next = view.next;
		}

		if(view == viewsLast)
		{
			viewsLast = viewsLast.prev;
			view.prev.next = null;
		}
		else
		{
			view.next.prev = view.prev;
		}
	} 

	
	
	private static void closeView(View view, boolean callExit)
	{
		if(viewsFirst == viewsLast && callExit)
			exit(view,false); 
		else
		{
			EditBus.send(new ViewUpdate(view,ViewUpdate.CLOSED));

			view.close();
			removeViewFromList(view);

			if(view == activeView)
				activeView = null;
		}
	} 

	
	
	private static void loadModeCatalog(String path, boolean resource)
	{
		Log.log(Log.MESSAGE,jEdit.class,""Loading mode catalog file "" + path);

		ModeCatalogHandler handler = new ModeCatalogHandler(
			MiscUtilities.getParentOfPath(path),resource);
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		try
		{
			InputStream _in;
			if(resource)
				_in = jEdit.class.getResourceAsStream(path);
			else
				_in = new FileInputStream(path);
			BufferedReader in = new BufferedReader(
				new InputStreamReader(_in));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,jEdit.class,path + "":"" + line
				+ "": "" + message);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,jEdit.class,e);
		}
	} 

	
	
	private static void loadPlugins(String directory)
	{
		Log.log(Log.NOTICE,jEdit.class,""Loading plugins from ""
			+ directory);

		File file = new File(directory);
		if(!(file.exists() && file.isDirectory()))
			return;
		String[] plugins = file.list();
		if(plugins == null)
			return;

		MiscUtilities.quicksort(plugins,new MiscUtilities.StringICaseCompare());
		for(int i = 0; i < plugins.length; i++)
		{
			String plugin = plugins[i];
			if(!plugin.toLowerCase().endsWith("".jar""))
				continue;

			String path = MiscUtilities.constructPath(directory,plugin);

			if(plugin.equals(""EditBuddy.jar"")
				|| plugin.equals(""PluginManager.jar"")
				|| plugin.equals(""Firewall.jar"")
				|| plugin.equals(""Tidy.jar""))
			{
				pluginError(path,""plugin-error.obsolete"",null);
				continue;
			}

			try
			{
				Log.log(Log.DEBUG,jEdit.class,
					""Scanning JAR file: "" + path);
				new JARClassLoader(path);
			}
			catch(IOException io)
			{
				Log.log(Log.ERROR,jEdit.class,""Cannot load""
					+ "" plugin "" + plugin);
				Log.log(Log.ERROR,jEdit.class,io);

				String[] args = { io.toString() };
				pluginError(path,""plugin-error.load-error"",args);
			}
		}
	} 

	
	
	private static void initKeyBindings()
	{
		inputHandler.removeAllKeyBindings();

		EditAction[] actions = getActions();
		for(int i = 0; i < actions.length; i++)
		{
			EditAction action = actions[i];

			String shortcut1 = jEdit.getProperty(action.getName()
				+ "".shortcut"");
			if(shortcut1 != null)
				inputHandler.addKeyBinding(shortcut1,action);

			String shortcut2 = jEdit.getProperty(action.getName()
				+ "".shortcut2"");
			if(shortcut2 != null)
				inputHandler.addKeyBinding(shortcut2,action);
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.io.FileRootsVFS,6,2,0,5,33,9,1,4,4,0.74,439,0.6,0,0.886363636,0.5,2,3,70.5,13,4.1667,3,"

package org.gjt.sp.jedit.io;


import javax.swing.filechooser.FileSystemView;
import java.awt.Component;
import java.lang.reflect.*;
import java.io.File;
import java.util.LinkedList;
import org.gjt.sp.jedit.OperatingSystem;
import org.gjt.sp.util.Log;



public class FileRootsVFS extends VFS
{
	public static final String PROTOCOL = ""roots"";

	
	public FileRootsVFS()
	{
		
		
		super(""roots"",LOW_LATENCY_CAP);

		
		
		if(OperatingSystem.hasJava14())
		{
			try
			{
				getSystemDisplayName = FileSystemView.class.getMethod(""getSystemDisplayName"",
					new Class[] { java.io.File.class });
				getRoots = FileSystemView.class.getMethod(""getRoots"",
					new Class[0]);
				isFileSystemRoot = FileSystemView.class.getMethod(""isFileSystemRoot"",
					new Class[] { java.io.File.class });
				isFloppyDrive = FileSystemView.class.getMethod(""isFloppyDrive"",
					new Class[] { java.io.File.class });
				isDrive = FileSystemView.class.getMethod(""isDrive"",
					new Class[] { java.io.File.class });
				fsView = FileSystemView.getFileSystemView();
				Log.log(Log.DEBUG,this,""Java 1.4 FileSystemView detected"");
			}
			catch(Exception e)
			{
				Log.log(Log.DEBUG,this,""Java 1.4 FileSystemView not detected"");
			}
		}
	} 

	
	public String getParentOfPath(String path)
	{
		return PROTOCOL + "":"";
	} 

	
	public VFS.DirectoryEntry[] _listDirectory(Object session, String url,
		Component comp)
	{
		File[] roots = listRoots();

		if(roots == null)
			return null;

		VFS.DirectoryEntry[] rootDE = new VFS.DirectoryEntry[roots.length];
		for(int i = 0; i < roots.length; i++)
		{
			String name = roots[i].getPath();
			rootDE[i] = _getDirectoryEntry(session,name,comp);
		}

		return rootDE;
	} 

	
	public DirectoryEntry _getDirectoryEntry(Object session, String path,
		Component comp)
	{
		File file = new File(path);

		int type;

		boolean isFloppy;
		boolean isDirectory;

		
		if(isFloppyDrive != null)
		{
			try
			{
				isFloppy = Boolean.TRUE.equals(isFloppyDrive.
					invoke(fsView, new Object[] { file }));
			}
			catch(Exception e)
			{
				isFloppy = false;
			}
		}
		else
			isFloppy = path.startsWith(""A:"") || path.startsWith(""B:"");

		
		if(isDrive != null)
		{
			try
			{
				isDirectory = Boolean.TRUE.equals(isDrive.
					invoke(fsView, new Object[] { file }))
					|| file.isDirectory();
			}
			catch(Exception e)
			{
				isDirectory = file.isDirectory();
			}
		}
		else
			isDirectory = file.isDirectory();

		if(isFloppy || isDirectory)
		{
			type = VFS.DirectoryEntry.FILESYSTEM;

			if(isFileSystemRoot != null)
			{
				try
				{
					if(Boolean.FALSE.equals(isFileSystemRoot
						.invoke(fsView,new Object[] { file })))
					{
						type = VFS.DirectoryEntry.DIRECTORY;
					}
				}
				catch(Exception e) {}
			}
		}
		else
			type = VFS.DirectoryEntry.FILE;

		String name;

		if(getSystemDisplayName != null && !isFloppy)
		{
			try
			{
				name = path + "" "" + (String)getSystemDisplayName
					.invoke(fsView,new Object[] { file });
			}
			catch(Exception e)
			{
				name = path;
			}
		}
		else if(OperatingSystem.isMacOS())
			name = getFileName(path);
		else
			name = path;

		return new VFS.DirectoryEntry(name,path,path,type,0L,false);
	} 

	
	private static FileSystemView fsView;
	private static Method getSystemDisplayName;
	private static Method getRoots;
	private static Method isFileSystemRoot;
	private static Method isFloppyDrive;
	private static Method isDrive;

	
	private static File[] listRoots()
	{
		if (OperatingSystem.isMacOS())
		{
			
			File[] volumes = new File(""/Volumes"").listFiles();
			LinkedList roots = new LinkedList();

			roots.add(new File(""/""));

			for (int i=0; i<volumes.length; i++)
			{
				
				if (volumes[i].isDirectory())
					roots.add(volumes[i]);
			}

			return (File[])roots.toArray(new File[0]);
		}
		else
		{
			File[] roots = File.listRoots();
			File[] desktop = null;

			if(getRoots != null)
			{
				try
				{
					desktop = (File[])getRoots.invoke(fsView,
						new Object[0]);
				}
				catch(Exception e)
				{
					Log.log(Log.ERROR, FileRootsVFS.class, ""Error getting Desktop: "" + e.getMessage());
					desktop = null;
				}
			}

			if(desktop == null)
				return roots;

			File[] rootsPlus = new File[roots.length + desktop.length];
			System.arraycopy(desktop, 0, rootsPlus, 0, desktop.length);
			System.arraycopy(roots, 0, rootsPlus, 1, roots.length);
			return rootsPlus;
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.help.HelpSearchPanel,6,5,0,10,29,5,5,9,1,0.7,140,1.0,3,0.992401216,0.388888889,0,0,21.66666667,2,1.0,0,"

package org.gjt.sp.jedit.help;


import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.gui.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;


class HelpSearchPanel extends JPanel
{
	
	public HelpSearchPanel(HelpViewer helpViewer)
	{
		super(new BorderLayout(6,6));

		this.helpViewer = helpViewer;

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(new JLabel(jEdit.getProperty(""helpviewer.search.caption"")));
		box.add(Box.createHorizontalStrut(6));
		box.add(searchField = new HistoryTextField(""helpviewer.search""));
		searchField.addActionListener(new ActionHandler());

		add(BorderLayout.NORTH,box);

		results = new JList();
		results.addMouseListener(new MouseHandler());
		results.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
		results.setCellRenderer(new ResultRenderer());
		add(BorderLayout.CENTER,new JScrollPane(results));
	} 

	
	private HelpViewer helpViewer;
	private HistoryTextField searchField;
	private JList results;
	private HelpIndex index;

	private HelpIndex getHelpIndex()
	{
		if(index == null)
		{
			index = new HelpIndex();
			try
			{
				index.indexEditorHelp();
			}
			catch(Exception e)
			{
				index = null;
				Log.log(Log.ERROR,this,e);
				GUIUtilities.error(helpViewer,""helpviewer.search.error"",
					new String[] { e.toString() });
			}
		}

		return index;
	} 

	
	static class ResultIcon implements Icon
	{
		private static RenderingHints renderingHints;

		static
		{
			HashMap hints = new HashMap();

			hints.put(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
			hints.put(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

			renderingHints = new RenderingHints(hints);
		}

		private int rank;

		ResultIcon(int rank)
		{
			this.rank = rank;
		}

		public int getIconWidth()
		{
			return 40;
		}

		public int getIconHeight()
		{
			return 9;
		}

		public void paintIcon(Component c, Graphics g, int x, int y)
		{
			Graphics2D g2d = (Graphics2D)g.create();
			g2d.setRenderingHints(renderingHints);

			for(int i = 0; i < 4; i++)
			{
				if(rank > i)
					g2d.setColor(UIManager.getColor(""Label.foreground""));
				else
					g2d.setColor(UIManager.getColor(""Label.disabledForeground""));
				g2d.fillOval(x+i*10,y,9,9);
			}
		}
	} 

	
	class ResultRenderer extends DefaultListCellRenderer
	{
		public Component getListCellRendererComponent(
			JList list,
			Object value,
			int index,
			boolean isSelected,
			boolean cellHasFocus)
		{
			super.getListCellRendererComponent(list,null,index,
				isSelected,cellHasFocus);

			if(value instanceof String)
			{
				setIcon(null);
				setText((String)value);
			}
			else
			{
				Result result = (Result)value;
				setIcon(new ResultIcon(result.rank));
				setText(result.title);
			}

			return this;
		}
	} 

	
	static class Result
	{
		String file;
		String title;
		int rank;

		Result(HelpIndex.HelpFile file, int count)
		{
			this.file = file.file;
			this.title = file.title;
			rank = count;
		}
	} 

	
	static class ResultCompare implements Comparator
	{
		public int compare(Object o1, Object o2)
		{
			Result r1 = (Result)o1;
			Result r2 = (Result)o2;
			if(r1.rank == r2.rank)
				return r1.title.compareTo(r2.title);
			else
				return r2.rank - r1.rank;
		}
	} 

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			final HelpIndex index = getHelpIndex();
			if(index == null)
				return;

			results.setListData(new String[] { jEdit.getProperty(
				""helpviewer.searching"") });

			final String text = searchField.getText();
			final Vector resultModel = new Vector();

			VFSManager.runInWorkThread(new Runnable()
			{
				public void run()
				{
					StringTokenizer st = new StringTokenizer(text,"",.;:-? "");

					
					int maxRank = 0;

					while(st.hasMoreTokens())
					{
						String word = st.nextToken().toLowerCase();
						HelpIndex.Word lookup = index.lookupWord(word);
						if(lookup == null)
							continue;

						for(int i = 0; i < lookup.occurCount; i++)
						{
							HelpIndex.Word.Occurrence occur = lookup.occurrences[i];

							boolean ok = false;

							HelpIndex.HelpFile file = index.getFile(occur.file);
							for(int j = 0; j < resultModel.size(); j++)
							{
								Result result = (Result)resultModel.elementAt(j);
								if(result.file.equals(file.file))
								{
									result.rank += occur.count;
									result.rank += 20; 
									maxRank = Math.max(result.rank,maxRank);
									ok = true;
									break;
								}
							}

							if(!ok)
							{
								maxRank = Math.max(occur.count,maxRank);
								resultModel.addElement(new Result(file,occur.count));
							}
						}
					}

					if(maxRank != 0)
					{
						
						for(int i = 0; i < resultModel.size(); i++)
						{
							Result result = (Result)resultModel.elementAt(i);
							result.rank = (int)Math.ceil((double)result.rank * 4 / maxRank);
						}

						Collections.sort(resultModel,new ResultCompare());
					}
				}
			});

			VFSManager.runInAWTThread(new Runnable()
			{
				public void run()
				{
					if(resultModel.size() == 0)
					{
						results.setListData(new String[] {
							jEdit.getProperty(
							""helpviewer.no-results"") });

						getToolkit().beep();
					}
					else
						results.setListData(resultModel);
				}
			});

		}
	} 

	
	public class MouseHandler extends MouseAdapter
	{
		public void mouseReleased(MouseEvent evt)
		{
			int row = results.locationToIndex(evt.getPoint());
			if(row != -1)
			{
				Result result = (Result)results.getModel()
					.getElementAt(row);
				helpViewer.gotoURL(result.file,true);
			}
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.IOProgressMonitor,6,5,0,9,29,5,5,6,3,0.666666667,141,1.0,2,0.992401216,0.5,1,7,22.0,1,0.8333,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.io.VFSManager;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.*;


public class IOProgressMonitor extends JPanel
{
	
	public IOProgressMonitor()
	{
		super(new BorderLayout());
		caption = new JLabel();
		updateCaption();
		add(BorderLayout.NORTH,caption);

		threads = new ThreadProgress[VFSManager.getIOThreadPool()
			.getThreadCount()];

		Box box = new Box(BoxLayout.Y_AXIS);
		for(int i = 0; i < threads.length; i++)
		{
			if(i != 0)
				box.add(Box.createVerticalStrut(6));

			threads[i] = new ThreadProgress(i);
			box.add(threads[i]);
		}

		JPanel threadPanel = new JPanel(new BorderLayout());
		threadPanel.setBorder(new EmptyBorder(6,6,6,6));
		threadPanel.add(BorderLayout.NORTH,box);

		add(BorderLayout.CENTER,new JScrollPane(threadPanel));

		workThreadHandler = new WorkThreadHandler();
	} 

	
	public void addNotify()
	{
		VFSManager.getIOThreadPool().addProgressListener(workThreadHandler);
		super.addNotify();
	} 

	
	public void removeNotify()
	{
		VFSManager.getIOThreadPool().removeProgressListener(workThreadHandler);
		super.removeNotify();
	} 

	

	
	private JLabel caption;
	private ThreadProgress[] threads;
	private WorkThreadHandler workThreadHandler;
	

	
	private void updateCaption()
	{
		String[] args = { String.valueOf(VFSManager.getIOThreadPool()
			.getRequestCount()) };
		caption.setText(jEdit.getProperty(""io-progress-monitor.caption"",args));
	} 

	

	
	class WorkThreadHandler implements WorkThreadProgressListener
	{
		public void statusUpdate(final WorkThreadPool pool, final int index)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					updateCaption();
					threads[index].update();
				}
			});
		}

		public void progressUpdate(final WorkThreadPool pool, final int index)
		{
			SwingUtilities.invokeLater(new Runnable()
			{
				public void run()
				{
					updateCaption();
					threads[index].update();
				}
			});
		}
	} 

	
	class ThreadProgress extends JPanel
	{
		
		public ThreadProgress(int index)
		{
			super(new BorderLayout(12,12));

			this.index = index;

			Box box = new Box(BoxLayout.Y_AXIS);
			box.add(Box.createGlue());
			box.add(progress = new JProgressBar());
			progress.setStringPainted(true);
			box.add(Box.createGlue());
			ThreadProgress.this.add(BorderLayout.CENTER,box);

			abort = new JButton(jEdit.getProperty(""io-progress-monitor.abort""));
			abort.addActionListener(new ActionHandler());
			ThreadProgress.this.add(BorderLayout.EAST,abort);

			update();
		} 

		
		public void update()
		{
			WorkThread thread = VFSManager.getIOThreadPool().getThread(index);
			if(thread.isRequestRunning())
			{
				abort.setEnabled(true);
				progress.setString(thread.getStatus());
				progress.setMaximum(thread.getProgressMaximum());
				
				progress.setValue(thread.getProgressValue());
			}
			else
			{
				abort.setEnabled(false);
				progress.setString(jEdit.getProperty(""io-progress-monitor""
					+ "".idle""));
				progress.setValue(0);
			}
		} 

		
		private int index;
		private JProgressBar progress;
		private JButton abort;
		

		
		class ActionHandler implements ActionListener
		{
			public void actionPerformed(ActionEvent evt)
			{
				if(evt.getSource() == abort)
				{
					int result = GUIUtilities.confirm(
						IOProgressMonitor.this,""abort"",null,
						JOptionPane.YES_NO_OPTION,
						JOptionPane.QUESTION_MESSAGE);
					if(result == JOptionPane.YES_OPTION)
					{
						VFSManager.getIOThreadPool().getThread(index)
							.abortCurrentRequest();
					}
				}
			}
		} 
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.pluginmgr.PluginListDownloadProgress,6,6,0,6,31,9,4,6,0,0.8,134,1.0,3,0.992378049,0.3,0,0,20.83333333,1,0.8333,0,"

package org.gjt.sp.jedit.pluginmgr;

import com.microstar.xml.XmlException;
import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.options.GlobalOptions;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;

class PluginListDownloadProgress extends JDialog
{
	PluginListDownloadProgress(PluginManager window)
	{
		super(window,
			jEdit.getProperty(""plugin-list.progress.title""),true);

		this.window = window;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JLabel caption = new JLabel(jEdit.getProperty(""plugin-list.progress.caption""));
		caption.setBorder(new EmptyBorder(0,0,12,0));
		content.add(BorderLayout.NORTH,caption);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		JButton stop = new JButton(jEdit.getProperty(""plugin-list.progress.stop""));
		stop.addActionListener(new ActionHandler());
		stop.setMaximumSize(stop.getPreferredSize());
		box.add(stop);
		box.add(Box.createGlue());
		content.add(BorderLayout.CENTER,box);

		addWindowListener(new WindowHandler());
		setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
		pack();
		setLocationRelativeTo(window);
		setResizable(false);
		show();
	}

	PluginList getPluginList()
	{
		return list;
	}

	
	private PluginManager window;
	private PluginList list;
	private DownloadThread thread;

	class DownloadThread extends Thread
	{
		public void run()
		{
			try
			{
				list = new PluginList();
				dispose();
			}
			catch(XmlException xe)
			{
				dispose();

				int line = xe.getLine();
				String path = jEdit.getProperty(""plugin-manager.url"");
				String message = xe.getMessage();
				Log.log(Log.ERROR,this,path + "":"" + line
					+ "": "" + message);
				String[] pp = { path, String.valueOf(line), message };
				GUIUtilities.error(window,""plugin-list.xmlerror"",pp);
			}
			catch(Exception e)
			{
				dispose();

				Log.log(Log.ERROR,this,e);
				String[] pp = { e.toString() };

				String ok = jEdit.getProperty(""common.ok"");
				String proxyButton = jEdit.getProperty(
					""plugin-list.ioerror.proxy-servers"");
				int retVal = JOptionPane.showOptionDialog(window,
					jEdit.getProperty(""plugin-list.ioerror.message"",pp),
					jEdit.getProperty(""plugin-list.ioerror.title""),
					JOptionPane.YES_NO_OPTION,
					JOptionPane.ERROR_MESSAGE,
					null,
					new Object[] {
						proxyButton,
						ok
					},
					ok);

				if(retVal == 0)
					new GlobalOptions(window,""firewall"");
			}
		}
	}

	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			thread.stop();
			dispose();
		}
	}

	class WindowHandler extends WindowAdapter
	{
		boolean done;

		public void windowOpened(WindowEvent evt)
		{
			if(done)
				return;

			done = true;
			thread = new DownloadThread();
			thread.start();
		}

		public void windowClosing(WindowEvent evt)
		{
			thread.stop();
		}
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.LineElement,11,1,0,2,14,49,2,1,11,0.8,50,1.0,1,0.0,0.454545455,0,0,3.363636364,1,0.9091,0,"

package org.gjt.sp.jedit.buffer;


import javax.swing.text.*;
import org.gjt.sp.jedit.Buffer;



public class LineElement implements Element
{
	
	public LineElement(Buffer buffer, int line)
	{
		this.buffer = buffer;
		this.line = line;
	} 

	
	public Document getDocument()
	{
		return null;
	} 

	
	public Element getParentElement()
	{
		return null;
	} 

	
	public String getName()
	{
		return null;
	} 

	
	public AttributeSet getAttributes()
	{
		return null;
	} 

	
	public int getStartOffset()
	{
		return buffer.getLineStartOffset(line);
	} 

	
	public int getEndOffset()
	{
		return buffer.getLineEndOffset(line);
	} 

	
	public int getElementIndex(int offset)
	{
		return 0;
	} 

	
	public int getElementCount()
	{
		return 0;
	} 

	
	public Element getElement(int line)
	{
		return null;
	} 

	
	public boolean isLeaf()
	{
		return true;
	} 

	
	private Buffer buffer;
	private int line;
	
} 
"
jEdit,4.1,org.gjt.sp.jedit.msg.BufferUpdate,6,2,0,10,14,5,8,4,5,0.933333333,86,0.166666667,1,0.428571429,0.4,1,1,11.33333333,1,0.6667,0,"

package org.gjt.sp.jedit.msg;

import org.gjt.sp.jedit.*;


public class BufferUpdate extends EBMessage
{
	
	
	public static final Object CREATED = ""CREATED"";

	
	public static final Object LOAD_STARTED = ""LOAD_STARTED"";

	
	public static final Object LOADED = ""LOADED"";

	
	public static final Object CLOSED = ""CLOSED"";

	
	public static final Object DIRTY_CHANGED = ""DIRTY_CHANGED"";

	
	public static final Object MARKERS_CHANGED = ""MARKERS_CHANGED"";

	
	public static final Object SAVING = ""SAVING"";

	
	public static final Object SAVED = ""SAVED"";

	
	public static final Object PROPERTIES_CHANGED = ""PROPERTIES_CHANGED"";

	
	public static final Object MODE_CHANGED = ""MODE_CHANGED"";
	

	
	
	public BufferUpdate(Buffer buffer, View view, Object what)
	{
		super(buffer);

		this.view = view;

		if(what == null)
			throw new NullPointerException(""What must be non-null"");

		this.what = what;
	} 

	
	
	public Object getWhat()
	{
		return what;
	} 

	
	
	public Buffer getBuffer()
	{
		return (Buffer)getSource();
	} 

	
	
	public View getView()
	{
		return view;
	} 

	
	public String paramString()
	{
		return ""what="" + what + "",view="" + view + "",""
			+ super.paramString();
	} 

	
	private Object what;
	private View view;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.search.SearchFileSet,5,1,0,9,5,10,9,1,5,2.0,5,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"

package org.gjt.sp.jedit.search;

import org.gjt.sp.jedit.*;


public interface SearchFileSet
{
	
	String getFirstFile(View view);

	
	String getNextFile(View view, String path);

	
	String[] getFiles(View view);

	
	int getFileCount(View view);

	
	String getCode();
}
"
jEdit,4.1,org.gjt.sp.jedit.syntax.Chunk,10,2,0,10,39,0,7,3,9,0.641975309,552,0.111111111,1,0.3,0.273504274,0,0,53.3,13,4.7,0,"

package org.gjt.sp.jedit.syntax;


import javax.swing.text.*;
import java.awt.font.*;
import java.awt.geom.*;
import java.awt.*;
import org.gjt.sp.jedit.syntax.*;



public class Chunk extends Token
{
	public static boolean DEBUG = false;

	
	
	public static float paintChunkList(Segment lineText, Chunk chunks,
		Graphics2D gfx, float x, float y, Color background,
		boolean glyphVector)
	{
		FontMetrics forBackground = gfx.getFontMetrics();

		float _x = 0.0f;

		for(;;)
		{
			if(chunks == null)
				return _x;

			
			Chunk start = chunks;
			float width = 0.0f;
			int length = 0;
			while(chunks != null
				&& start.style == chunks.style
				&& (start.visible == chunks.visible)
				&& (start.accessable == chunks.accessable))
			{
				length += chunks.length;
				width += chunks.width;
				chunks = (Chunk)chunks.next;
			} 

			
			if(DEBUG)
			{
				gfx.draw(new Rectangle2D.Float(x + _x,y - 10,
					width,10));
			}

			if(start.accessable)
			{
				
				Color bgColor = start.style.getBackgroundColor();
				if(bgColor != null)
				{
					
					
					
					
					Graphics2D xorGfx = (Graphics2D)gfx.create();
					xorGfx.setXORMode(background);
					xorGfx.setColor(bgColor);

					xorGfx.fill(new Rectangle2D.Float(
						x + _x,y - forBackground.getAscent(),
						_x + width - _x,forBackground.getHeight()));

					xorGfx.dispose();
				} 

				
				if(start.visible)
				{
					gfx.setFont(start.style.getFont());
					gfx.setColor(start.style.getForegroundColor());

					if(glyphVector && start.gv != null
						&& start.next == chunks)
						gfx.drawGlyphVector(start.gv,x + _x,y);
					else
					{
						gfx.drawChars(lineText.array,
							lineText.offset
							+ start.offset,length,
							(int)(x + _x),(int)y);
					}
				} 
			}

			_x += width;
		}

		
	} 

	
	
	public static float offsetToX(Chunk chunks, int offset)
	{
		if(chunks != null && offset < chunks.offset)
		{
			throw new ArrayIndexOutOfBoundsException(offset + "" < ""
				+ chunks.offset);
		}

		float x = 0.0f;

		while(chunks != null)
		{
			if(chunks.accessable && offset < chunks.offset + chunks.length)
				return x + chunks.offsetToX(offset - chunks.offset);

			x += chunks.width;
			chunks = (Chunk)chunks.next;
		}

		return x;
	} 

	
	
	public static int xToOffset(Chunk chunks, float x, boolean round)
	{
		float _x = 0.0f;

		while(chunks != null)
		{
			if(chunks.accessable && x < _x + chunks.width)
				return chunks.xToOffset(x - _x,round);

			_x += chunks.width;
			chunks = (Chunk)chunks.next;
		}

		return -1;
	} 

	
	public boolean accessable;
	public boolean visible;

	public boolean monospaced;
	public float charWidth;

	
	public SyntaxStyle style;
	public float width;
	public GlyphVector gv;
	

	
	public Chunk(float width, int offset, ParserRuleSet rules)
	{
		super(Token.NULL,offset,0,rules);
		this.width = width;
	} 

	
	public Chunk(byte id, int offset, int length, ParserRuleSet rules)
	{
		super(id,offset,length,rules);
		accessable = true;
	} 

	
	public final float[] getPositions()
	{
		if(gv == null)
			return null;

		if(positions == null)
			positions = gv.getGlyphPositions(0,length,null);

		return positions;
	} 

	
	public final float offsetToX(int offset)
	{
		if(!visible)
			return 0.0f;
		else if(monospaced)
			return offset * charWidth;
		else
			return getPositions()[offset * 2];
	} 

	
	public final int xToOffset(float x, boolean round)
	{
		if(!visible)
		{
			if(round && width - x < x)
				return offset + length;
			else
				return offset;
		}
		else if(monospaced)
		{
			x = Math.max(0,x);
			float remainder = x % charWidth;
			int i = (int)(x / charWidth);
			if(round && remainder > charWidth / 2)
				return offset + i + 1;
			else
				return offset + i;
		}
		else
		{
			float[] pos = getPositions();

			for(int i = 0; i < length; i++)
			{
				float glyphX = pos[i*2];
				float nextX = (i == length - 1
					? width : pos[i*2+2]);

				if(nextX > x)
				{
					if(!round || nextX - x > x - glyphX)
						return offset + i;
					else
						return offset + i + 1;
				}
			}
		}

		
		return -1;
	} 

	
	public void init(Segment seg, TabExpander expander, float x,
		SyntaxStyle[] styles, FontRenderContext fontRenderContext,
		byte defaultID, float charWidth)
	{
		style = styles[(id == Token.WHITESPACE || id == Token.TAB)
			? defaultID : id];

		if(length == 1 && seg.array[seg.offset + offset] == '\t')
		{
			visible = false;
			float newX = expander.nextTabStop(x,offset + length);
			width = newX - x;
		}
		else if(charWidth != 0.0f)
		{
			visible = monospaced = true;
			this.charWidth = charWidth;
			width = charWidth * length;
		}
		else
		{
			visible = true;
			String str = new String(seg.array,seg.offset + offset,length);
			gv = style.getFont().createGlyphVector(
				fontRenderContext,str);
			width = (float)gv.getLogicalBounds().getWidth();
		}
	} 

	
	private float[] positions;
	
}
"
jEdit,4.1,org.gjt.sp.jedit.BufferHistory,13,1,0,11,60,44,4,10,6,0.833333333,487,0.6,0,0.0,0.180555556,0,0,36.07692308,6,2.6923,3,"

package org.gjt.sp.jedit;

import com.microstar.xml.*;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.util.Log;


public class BufferHistory
{
	public static Entry getEntry(String path)
	{
		Enumeration enum = history.elements();
		while(enum.hasMoreElements())
		{
			Entry entry = (Entry)enum.nextElement();
			if(pathsCaseInsensitive)
			{
				if(entry.path.equalsIgnoreCase(path))
					return entry;
			}
			else
			{
				if(entry.path.equals(path))
					return entry;
			}
		}

		return null;
	}

	public static void setEntry(String path, int caret, Selection[] selection,
		String encoding)
	{
		removeEntry(path);
		addEntry(new Entry(path,caret,selectionToString(selection),encoding));
	}

	public static Vector getBufferHistory()
	{
		return history;
	}

	public static void load(File file)
	{
		max = jEdit.getIntegerProperty(""recentFiles"",50);

		Log.log(Log.MESSAGE,jEdit.class,""Loading recent file list "" + file);

		RecentHandler handler = new RecentHandler();
		XmlParser parser = new XmlParser();
		parser.setHandler(handler);
		try
		{
			BufferedReader in = new BufferedReader(new FileReader(file));
			parser.parse(null, null, in);
		}
		catch(XmlException xe)
		{
			int line = xe.getLine();
			String message = xe.getMessage();
			Log.log(Log.ERROR,BufferHistory.class,file + "":"" + line
				+ "": "" + message);
		}
		catch(FileNotFoundException fnf)
		{
			Log.log(Log.DEBUG,BufferHistory.class,fnf);
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
	}

	public static void save(File file)
	{
		String lineSep = System.getProperty(""line.separator"");

		try
		{
			BufferedWriter out = new BufferedWriter(
				new FileWriter(file));

			out.write(""<?xml version=\""1.0\""?>"");
			out.write(lineSep);
			out.write(""<!DOCTYPE RECENT SYSTEM \""recent.dtd\"">"");
			out.write(lineSep);
			out.write(""<RECENT>"");
			out.write(lineSep);

			Enumeration enum = history.elements();
			while(enum.hasMoreElements())
			{
				out.write(""<ENTRY>"");
				out.write(lineSep);

				Entry entry = (Entry)enum.nextElement();

				out.write(""<PATH><![CDATA["");
				out.write(entry.path);
				out.write(""]]></PATH>"");
				out.write(lineSep);

				out.write(""<CARET>"");
				out.write(String.valueOf(entry.caret));
				out.write(""</CARET>"");
				out.write(lineSep);

				if(entry.selection != null
					&& entry.selection.length() > 0)
				{
					out.write(""<SELECTION>"");
					out.write(entry.selection);
					out.write(""</SELECTION>"");
					out.write(lineSep);
				}

				if(entry.encoding != null)
				{
					out.write(""<ENCODING>"");
					out.write(entry.encoding);
					out.write(""</ENCODING>"");
					out.write(lineSep);
				}

				out.write(""</ENTRY>"");
				out.write(lineSep);
			}

			out.write(""</RECENT>"");
			out.write(lineSep);

			out.close();
		}
		catch(Exception e)
		{
			Log.log(Log.ERROR,BufferHistory.class,e);
		}
	}

	
	private static Vector history;
	private static boolean pathsCaseInsensitive;
	private static int max;

	static
	{
		history = new Vector();
		pathsCaseInsensitive = (File.separatorChar == '\\'
			|| File.separatorChar == ':');
	}

	 static void addEntry(Entry entry)
	{
		history.addElement(entry);
		while(history.size() > max)
			history.removeElementAt(0);
	}

	 static void removeEntry(String path)
	{
		for(int i = 0; i < history.size(); i++)
		{
			Entry entry = (Entry)history.elementAt(i);
			if(entry.path.equals(path))
			{
				history.removeElementAt(i);
				return;
			}
		}
	}

	private static String selectionToString(Selection[] s)
	{
		if(s == null)
			return null;

		StringBuffer buf = new StringBuffer();

		for(int i = 0; i < s.length; i++)
		{
			if(i != 0)
				buf.append(' ');

			Selection sel = s[i];
			if(sel instanceof Selection.Range)
				buf.append(""range "");
			else 
				buf.append(""rect "");
			buf.append(sel.getStart());
			buf.append(' ');
			buf.append(sel.getEnd());
		}

		return buf.toString();
	}

	private static Selection[] stringToSelection(String s)
	{
		if(s == null)
			return null;

		Vector selection = new Vector();
		StringTokenizer st = new StringTokenizer(s);

		while(st.hasMoreTokens())
		{
			String type = st.nextToken();
			int start = Integer.parseInt(st.nextToken());
			int end = Integer.parseInt(st.nextToken());
			if(end < start)
			{
				
				
				
				continue;
			}

			Selection sel;
			if(type.equals(""range""))
				sel = new Selection.Range(start,end);
			else 
				sel = new Selection.Rect(start,end);

			selection.addElement(sel);
		}

		Selection[] returnValue = new Selection[selection.size()];
		selection.copyInto(returnValue);
		return returnValue;
	}

	
	public static class Entry
	{
		public String path;
		public int caret;
		public String selection;
		public String encoding;

		public Selection[] getSelection()
		{
			return stringToSelection(selection);
		}

		public Entry(String path, int caret, String selection, String encoding)
		{
			this.path = path;
			this.caret = caret;
			this.selection = selection;
			this.encoding = encoding;
		}
	}

	static class RecentHandler extends HandlerBase
	{
		public Object resolveEntity(String publicId, String systemId)
		{
			if(""recent.dtd"".equals(systemId))
			{
				
				
				
				return new StringReader(""<!-- -->"");

				
			}

			return null;
		}

		public void doctypeDecl(String name, String publicId,
			String systemId) throws Exception
		{
			if(""RECENT"".equals(name))
				return;

			Log.log(Log.ERROR,this,""recent.xml: DOCTYPE must be RECENT"");
		}

		public void endElement(String name)
		{
			if(name.equals(""ENTRY""))
			{
				addEntry(new Entry(path,caret,selection,encoding));
				path = null;
				caret = 0;
				selection = null;
				encoding = null;
			}
			else if(name.equals(""PATH""))
				path = charData;
			else if(name.equals(""CARET""))
				caret = Integer.parseInt(charData);
			else if(name.equals(""SELECTION""))
				selection = charData;
			else if(name.equals(""ENCODING""))
				encoding = charData;
		}

		public void charData(char[] ch, int start, int length)
		{
			charData = new String(ch,start,length);
		}

		

		
		private String path;
		private int caret;
		private String selection;
		private String encoding;
		private String charData;
	}
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.EditAbbrevDialog,8,6,0,6,42,10,4,4,4,0.571428571,207,1.0,1,0.99086758,0.291666667,2,2,24.375,2,1.0,1,"

package org.gjt.sp.jedit.gui;


import javax.swing.border.*;
import javax.swing.*;
import java.awt.event.*;
import java.awt.*;
import org.gjt.sp.jedit.*;


public class EditAbbrevDialog extends JDialog
{
	
	public EditAbbrevDialog(Frame frame, String abbrev, String expansion)
	{
		super(frame,jEdit.getProperty(""edit-abbrev.title""),true);
		init(abbrev, expansion);
	} 

	
	public EditAbbrevDialog(Dialog dialog, String abbrev, String expansion)
	{
		super(dialog,jEdit.getProperty(""edit-abbrev.title""),true);
		init(abbrev, expansion);
	} 

	
	public String getAbbrev()
	{
		if(!isOK)
			return null;

		return editor.getAbbrev();
	} 

	
	public String getExpansion()
	{
		if(!isOK)
			return null;

		return editor.getExpansion();
	} 

	
	private AbbrevEditor editor;
	private JButton ok;
	private JButton cancel;
	private boolean isOK;

	
	private void init(String abbrev, String expansion)
	{
		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		editor = new AbbrevEditor();
		editor.setAbbrev(abbrev);
		editor.setExpansion(expansion);
		editor.setBorder(new EmptyBorder(0,0,12,0));
		content.add(BorderLayout.CENTER,editor);

		Box box = new Box(BoxLayout.X_AXIS);
		box.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(new ActionHandler());
		getRootPane().setDefaultButton(ok);
		box.add(ok);
		box.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(new ActionHandler());
		box.add(cancel);
		box.add(Box.createGlue());
		content.add(BorderLayout.SOUTH,box);

		KeyListener listener = new KeyHandler();
		addKeyListener(listener);
		editor.getBeforeCaretTextArea().addKeyListener(listener);
		editor.getAfterCaretTextArea().addKeyListener(listener);

		setDefaultCloseOperation(DISPOSE_ON_CLOSE);
		pack();
		setLocationRelativeTo(getParent());
		show();
	} 

	

	
	class ActionHandler implements ActionListener
	{
		public void actionPerformed(ActionEvent evt)
		{
			if(evt.getSource() == ok)
			{
				if(editor.getAbbrev() == null
					|| editor.getAbbrev().length() == 0)
				{
					getToolkit().beep();
					return;
				}

				isOK = true;
			}

			dispose();
		}
	} 

	
	class KeyHandler extends KeyAdapter
	{
		public void keyPressed(KeyEvent evt)
		{
			if(evt.getKeyCode() == KeyEvent.VK_ESCAPE)
				dispose();
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.SelectLineRange,5,7,0,8,50,2,1,8,4,0.5,362,1.0,1,0.993939394,0.466666667,0,0,70.4,4,1.8,0,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import java.awt.*;
import java.awt.event.*;
import org.gjt.sp.jedit.textarea.*;
import org.gjt.sp.jedit.*;


public class SelectLineRange extends EnhancedDialog implements ActionListener
{
	
	public SelectLineRange(View view)
	{
		super(view,jEdit.getProperty(""selectlinerange.title""),true);
		this.view = view;

		JPanel content = new JPanel(new BorderLayout());
		content.setBorder(new EmptyBorder(12,12,12,0));
		setContentPane(content);

		JLabel label = new JLabel(jEdit.getProperty(
			""selectlinerange.caption""));
		label.setBorder(new EmptyBorder(0,0,6,12));
		content.add(BorderLayout.NORTH,label);

		JPanel panel = createFieldPanel();

		content.add(BorderLayout.CENTER,panel);

		panel = new JPanel();
		panel.setLayout(new BoxLayout(panel,BoxLayout.X_AXIS));
		panel.setBorder(new EmptyBorder(6,0,0,12));
		panel.add(Box.createGlue());
		panel.add(Box.createGlue());
		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		getRootPane().setDefaultButton(ok);
		panel.add(ok);
		panel.add(Box.createHorizontalStrut(6));
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		panel.add(cancel);
		panel.add(Box.createGlue());

		content.add(panel,BorderLayout.SOUTH);

		GUIUtilities.requestFocus(this,startField);

		pack();
		setLocationRelativeTo(view);
		show();
	} 

	
	public void ok()
	{
		int startLine;
		int endLine;

		try
		{
			startLine = Integer.parseInt(startField.getText()) - 1;
			endLine = Integer.parseInt(endField.getText()) - 1;
		}
		catch(NumberFormatException nf)
		{
			getToolkit().beep();
			return;
		}

		Buffer buffer = view.getBuffer();

		if(startLine < 0 || endLine >= buffer.getLineCount()
			|| startLine > endLine)
		{
			getToolkit().beep();
			return;
		}

		JEditTextArea textArea = view.getTextArea();
		textArea.setSelection(new Selection.Range(
			buffer.getLineStartOffset(startLine),
			buffer.getLineEndOffset(endLine) - 1));
		textArea.moveCaretPosition(buffer.getLineEndOffset(endLine) - 1);

		dispose();
	} 

	
	public void cancel()
	{
		dispose();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();
		if(source == ok)
			ok();
		else if(source == cancel)
			cancel();
	} 

	

	
	private View view;
	private JTextField startField;
	private JTextField endField;
	private JButton ok;
	private JButton cancel;
	

	
	private JPanel createFieldPanel()
	{
		GridBagLayout layout = new GridBagLayout();
		JPanel panel = new JPanel(layout);

		GridBagConstraints cons = new GridBagConstraints();
		cons.insets = new Insets(0,0,6,12);
		cons.gridwidth = cons.gridheight = 1;
		cons.gridx = cons.gridy = 0;
		cons.fill = GridBagConstraints.BOTH;
		JLabel label = new JLabel(jEdit.getProperty(""selectlinerange.start""),
			SwingConstants.RIGHT);
		layout.setConstraints(label,cons);
		panel.add(label);

		startField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(startField,cons);
		panel.add(startField);

		label = new JLabel(jEdit.getProperty(""selectlinerange.end""),
			SwingConstants.RIGHT);
		cons.gridx = 0;
		cons.weightx = 0.0f;
		cons.gridy = 1;
		layout.setConstraints(label,cons);
		panel.add(label);

		endField = new JTextField(10);
		cons.gridx = 1;
		cons.weightx = 1.0f;
		layout.setConstraints(endField,cons);
		panel.add(endField);

		return panel;
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.OptionsDialog,19,7,1,10,108,137,4,8,10,0.767676768,767,0.909090909,0,0.97473997,0.194736842,4,8,38.78947368,10,2.4211,2,"

package org.gjt.sp.jedit.gui;


import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import javax.swing.tree.*;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import org.gjt.sp.jedit.*;



public abstract class OptionsDialog extends EnhancedDialog
	implements ActionListener, TreeSelectionListener
{
	
	public OptionsDialog(Frame frame, String name, String pane)
	{
		super(frame, jEdit.getProperty(name + "".title""), true);
		init(name,pane);
	} 

	
	public OptionsDialog(Dialog dialog, String name, String pane)
	{
		super(dialog, jEdit.getProperty(name + "".title""), true);
		init(name,pane);
	} 

	
	public void addOptionGroup(OptionGroup group)
	{
		addOptionGroup(group, getDefaultGroup());
	} 

	
	public void addOptionPane(OptionPane pane)
	{
		addOptionPane(pane, getDefaultGroup());
	} 

	
	public void ok()
	{
		jEdit.setProperty(name + "".last"",currentPane);
		ok(true);
	} 

	
	public void cancel()
	{
		jEdit.setProperty(name + "".last"",currentPane);
		dispose();
	} 

	
	public void ok(boolean dispose)
	{
		OptionTreeModel m = (OptionTreeModel) paneTree
			.getModel();
		((OptionGroup) m.getRoot()).save();

		
		jEdit.propertiesChanged();

		
		jEdit.saveSettings();

		
		if(dispose)
			dispose();
	} 

	
	public void dispose()
	{
		GUIUtilities.saveGeometry(this,name);
		jEdit.setIntegerProperty(name + "".splitter"",splitter.getDividerLocation());
		super.dispose();
	} 

	
	public void actionPerformed(ActionEvent evt)
	{
		Object source = evt.getSource();

		if(source == ok)
		{
			ok();
		}
		else if(source == cancel)
		{
			cancel();
		}
		else if(source == apply)
		{
			ok(false);
		}
	} 

	
	public void valueChanged(TreeSelectionEvent evt)
	{
		TreePath path = evt.getPath();

		if (path == null || !(path.getLastPathComponent() instanceof
			OptionPane)) return;

		Object[] nodes = path.getPath();

		StringBuffer buf = new StringBuffer();

		OptionPane optionPane = null;
		String name = null;

		int lastIdx = nodes.length - 1;

		for (int i = paneTree.isRootVisible() ? 0 : 1;
			i <= lastIdx; i++)
		{
			if (nodes[i] instanceof OptionPane)
			{
				optionPane = (OptionPane)nodes[i];
				name = optionPane.getName();
			}
			else if (nodes[i] instanceof OptionGroup)
			{
				name = ((OptionGroup)nodes[i]).getName();
			}
			else
			{
				continue;
			}

			if (name != null)
			{
				String label = jEdit.getProperty(""options."" +
					name + "".label"");

				if (label == null)
				{
					buf.append(name);
				}
				else
				{
					buf.append(label);
				}
			}

			if (i != lastIdx) buf.append("": "");
		}

		currentLabel.setText(buf.toString());

		optionPane.init();

		((CardLayout)cardPanel.getLayout()).show(cardPanel, name);

		
		addNotify();

		updateSize();

		currentPane = name;
	} 

	
	protected abstract OptionTreeModel createOptionTreeModel();
	protected abstract OptionGroup getDefaultGroup();

	
	protected void addOptionGroup(OptionGroup child, OptionGroup parent)
	{
		Enumeration enum = child.getMembers();

		while (enum.hasMoreElements())
		{
			Object elem = enum.nextElement();

			if (elem instanceof OptionPane)
			{
				addOptionPane((OptionPane) elem, child);
			}
			else if (elem instanceof OptionGroup)
			{
				addOptionGroup((OptionGroup) elem, child);
			}
		}

		parent.addOptionGroup(child);
	} 

	
	protected void addOptionPane(OptionPane pane, OptionGroup parent)
	{
		String name = pane.getName();
		if(firstPane == null)
			firstPane = name;

		cardPanel.add(pane.getComponent(), name);

		parent.addOptionPane(pane);
	} 

	

	

	
	private String name;
	private JSplitPane splitter;
	private JTree paneTree;
	private JPanel cardPanel;
	private JLabel currentLabel;
	private JButton ok;
	private JButton cancel;
	private JButton apply;
	private String currentPane;
	private String firstPane;
	

	
	private void init(String name, String pane)
	{
		this.name = name;

		JPanel content = new JPanel(new BorderLayout(12,12));
		content.setBorder(new EmptyBorder(12,12,12,12));
		setContentPane(content);

		JPanel stage = new JPanel(new BorderLayout(6,6));

		
		
		currentLabel = new JLabel();
		currentLabel.setHorizontalAlignment(JLabel.LEFT);
		stage.add(currentLabel, BorderLayout.NORTH);

		cardPanel = new JPanel(new CardLayout());
		stage.add(cardPanel, BorderLayout.CENTER);

		paneTree = new JTree(createOptionTreeModel());
		paneTree.setVisibleRowCount(1);
		paneTree.setCellRenderer(new PaneNameRenderer());

		
		if(!OperatingSystem.isMacOSLF())
			paneTree.putClientProperty(""JTree.lineStyle"", ""Angled"");

		paneTree.setShowsRootHandles(true);
		paneTree.setRootVisible(false);

		JScrollPane scroller = new JScrollPane(paneTree,
			JScrollPane.VERTICAL_SCROLLBAR_ALWAYS,
			JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
		splitter = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,
			scroller,stage);
		splitter.setDividerLocation(scroller.getPreferredSize().width);
		content.add(splitter, BorderLayout.CENTER);

		Box buttons = new Box(BoxLayout.X_AXIS);
		buttons.add(Box.createGlue());

		ok = new JButton(jEdit.getProperty(""common.ok""));
		ok.addActionListener(this);
		buttons.add(ok);
		buttons.add(Box.createHorizontalStrut(6));
		getRootPane().setDefaultButton(ok);
		cancel = new JButton(jEdit.getProperty(""common.cancel""));
		cancel.addActionListener(this);
		buttons.add(cancel);
		buttons.add(Box.createHorizontalStrut(6));
		apply = new JButton(jEdit.getProperty(""common.apply""));
		apply.addActionListener(this);
		buttons.add(apply);

		buttons.add(Box.createGlue());

		content.add(buttons, BorderLayout.SOUTH);

		
		
		
		paneTree.getSelectionModel().addTreeSelectionListener(this);

		OptionGroup rootNode = (OptionGroup)paneTree.getModel().getRoot();
		for(int i = 0; i < rootNode.getMemberCount(); i++)
		{
			paneTree.expandPath(new TreePath(
			new Object[] { rootNode, rootNode.getMember(i) }));
		}

		if(pane == null || !selectPane(rootNode,pane))
			selectPane(rootNode,firstPane);

		GUIUtilities.loadGeometry(this,name);
		int dividerLocation = jEdit.getIntegerProperty(name + "".splitter"",-1);
		if(dividerLocation != -1)
			splitter.setDividerLocation(dividerLocation);

		
		updateSize();

		show();
	} 

	
	private boolean selectPane(OptionGroup node, String name)
	{
		return selectPane(node,name,new ArrayList());
	} 

	
	private boolean selectPane(OptionGroup node, String name, ArrayList path)
	{
		path.add(node);

		Enumeration enum = node.getMembers();
		while(enum.hasMoreElements())
		{
			Object obj = enum.nextElement();
			if(obj instanceof OptionGroup)
			{
				OptionGroup grp = (OptionGroup)obj;
				if(grp.getName().equals(name))
				{
					path.add(grp);
					path.add(grp.getMember(0));
					TreePath treePath = new TreePath(
						path.toArray());
					paneTree.scrollPathToVisible(treePath);
					paneTree.setSelectionPath(treePath);
					return true;
				}
				else if(selectPane((OptionGroup)obj,name,path))
					return true;
			}
			else
			{
				OptionPane pane = (OptionPane)obj;
				if(pane.getName().equals(name))
				{
					path.add(pane);
					TreePath treePath = new TreePath(
						path.toArray());
					paneTree.scrollPathToVisible(treePath);
					paneTree.setSelectionPath(treePath);
					return true;
				}
			}
		}

		path.remove(node);

		return false;
	} 

	
	private void updateSize()
	{
		Dimension currentSize = getSize();
		Dimension requestedSize = getPreferredSize();
		Dimension newSize = new Dimension(
			Math.max(currentSize.width,requestedSize.width),
			Math.max(currentSize.height,requestedSize.height)
		);
		if(newSize.width < 300)
			newSize.width = 300;
		if(newSize.height < 200)
			newSize.height = 200;
		setSize(newSize);
		validate();
	} 

	

	
	class PaneNameRenderer extends DefaultTreeCellRenderer
	{
		public PaneNameRenderer()
		{
			paneFont = UIManager.getFont(""Tree.font"");
			groupFont = paneFont.deriveFont(Font.BOLD);
		}

		public Component getTreeCellRendererComponent(JTree tree,
			Object value, boolean selected, boolean expanded,
			boolean leaf, int row, boolean hasFocus)
		{
			super.getTreeCellRendererComponent(tree,value,
				selected,expanded,leaf,row,hasFocus);

			String name = null;

			if (value instanceof OptionGroup)
			{
				name = ((OptionGroup)value).getName();
				this.setFont(groupFont);
			}
			else if (value instanceof OptionPane)
			{
				name = ((OptionPane)value).getName();
				this.setFont(paneFont);
			}

			if (name == null)
			{
				setText(null);
			}
			else
			{
				String label = jEdit.getProperty(""options."" +
					name + "".label"");

				if (label == null)
				{
					setText(""NO LABEL PROPERTY: "" + name);
				}
				else
				{
					setText(label);
				}
			}

			setIcon(null);

			return this;
		}

		private Font paneFont;
		private Font groupFont;
	} 

	
	public class OptionTreeModel implements TreeModel
	{
		public void addTreeModelListener(TreeModelListener l)
		{
			listenerList.add(TreeModelListener.class, l);
		}

		public void removeTreeModelListener(TreeModelListener l)
		{
			listenerList.remove(TreeModelListener.class, l);
		}

		public Object getChild(Object parent, int index)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMember(index);
			}
			else
			{
				return null;
			}
		}

		public int getChildCount(Object parent)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent).getMemberCount();
			}
			else
			{
				return 0;
			}
		}

		public int getIndexOfChild(Object parent, Object child)
		{
			if (parent instanceof OptionGroup)
			{
				return ((OptionGroup)parent)
					.getMemberIndex(child);
			}
			else
			{
				return -1;
			}
		}

		public Object getRoot()
		{
			return root;
		}

		public boolean isLeaf(Object node)
		{
			return node instanceof OptionPane;
		}

		public void valueForPathChanged(TreePath path, Object newValue)
		{
			
		}

		protected void fireNodesChanged(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeNodesChanged(modelEvent);
			}
		}

		protected void fireNodesInserted(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeNodesInserted(modelEvent);
			}
		}

		protected void fireNodesRemoved(Object source, Object[] path,
			int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeNodesRemoved(modelEvent);
			}
		}

		protected void fireTreeStructureChanged(Object source,
			Object[] path, int[] childIndices, Object[] children)
		{
			Object[] listeners = listenerList.getListenerList();

			TreeModelEvent modelEvent = null;
			for (int i = listeners.length - 2; i >= 0; i -= 2)
			{
				if (listeners[i] != TreeModelListener.class)
					continue;

				if (modelEvent == null)
				{
					modelEvent = new TreeModelEvent(source,
						path, childIndices, children);
				}

				((TreeModelListener)listeners[i + 1])
					.treeStructureChanged(modelEvent);
			}
		}

		private OptionGroup root = new OptionGroup(null);
		private EventListenerList listenerList = new EventListenerList();
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.buffer.ExplicitFoldHandler,2,2,0,2,6,1,1,2,2,2.0,84,0.0,0,0.888888889,0.625,0,0,41.0,9,4.5,1,"

package org.gjt.sp.jedit.buffer;

import javax.swing.text.Segment;
import org.gjt.sp.jedit.Buffer;


public class ExplicitFoldHandler extends FoldHandler
{
	
	public ExplicitFoldHandler()
	{
		super(""explicit"");
	} 

	
	
	public int getFoldLevel(Buffer buffer, int lineIndex, Segment seg)
	{
		if(lineIndex == 0)
			return 0;
		else
		{
			int tabSize = buffer.getTabSize();
			int foldLevel = buffer.getFoldLevel(lineIndex - 1);

			buffer.getLineText(lineIndex - 1,seg);

			int offset = seg.offset;
			int count = seg.count;

			int openingBrackets = 0, closingBrackets = 0;
			for(int i = 0; i < count; i++)
			{
				switch(seg.array[offset + i])
				{
				case '{':
					closingBrackets = 0;
					openingBrackets++;
					if(openingBrackets == 3)
					{
						foldLevel += tabSize;
						openingBrackets = 0;
					}
					break;
				case '}':
					openingBrackets = 0;
					closingBrackets++;
					if(closingBrackets == 3)
					{
						if(foldLevel >= tabSize)
							foldLevel -= tabSize;
						closingBrackets = 0;
					}
					break;
				default:
					closingBrackets = openingBrackets = 0;
					break;
				}
			}

			return foldLevel;
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.options.GeneralOptionPane,5,6,0,5,28,0,2,4,1,0.708333333,338,1.0,0,0.994056464,0.5,2,4,64.2,3,1.6,0,"

package org.gjt.sp.jedit.options;

import javax.swing.*;
import java.awt.event.*;
import java.io.*;
import org.gjt.sp.jedit.*;
import org.gjt.sp.util.Log;

public class GeneralOptionPane extends AbstractOptionPane
{
	public GeneralOptionPane()
	{
		super(""general"");
	}

	
	protected void _init()
	{
		
		history = new JTextField(jEdit.getProperty(""history""));
		addComponent(jEdit.getProperty(""options.general.history""),history);

		
		saveCaret = new JCheckBox(jEdit.getProperty(
			""options.general.saveCaret""));
		saveCaret.setSelected(jEdit.getBooleanProperty(""saveCaret""));
		addComponent(saveCaret);

		
		sortBuffers = new JCheckBox(jEdit.getProperty(
			""options.general.sortBuffers""));
		sortBuffers.setSelected(jEdit.getBooleanProperty(""sortBuffers""));
		sortBuffers.addActionListener(new ActionListener()
		{
			public void actionPerformed(ActionEvent evt)
			{
				sortByName.setEnabled(sortBuffers.isSelected());
			}
		});

		addComponent(sortBuffers);

		
		sortByName = new JCheckBox(jEdit.getProperty(
			""options.general.sortByName""));
		sortByName.setSelected(jEdit.getBooleanProperty(""sortByName""));
		sortByName.setEnabled(sortBuffers.isSelected());
		addComponent(sortByName);

		
		sortRecent = new JCheckBox(jEdit.getProperty(
			""options.general.sortRecent""));
		sortRecent.setSelected(jEdit.getBooleanProperty(""sortRecent""));
		addComponent(sortRecent);

		
		checkModStatus = new JCheckBox(jEdit.getProperty(
			""options.general.checkModStatus""));
		checkModStatus.setSelected(jEdit.getBooleanProperty(
			""view.checkModStatus""));
		addComponent(checkModStatus);

		
		showFullPath = new JCheckBox(jEdit.getProperty(
			""options.general.showFullPath""));
		showFullPath.setSelected(jEdit.getBooleanProperty(
			""view.showFullPath""));
		addComponent(showFullPath);

		
		showSearchbar = new JCheckBox(jEdit.getProperty(
			""options.general.showSearchbar""));
		showSearchbar.setSelected(jEdit.getBooleanProperty(
			""view.showSearchbar""));
		addComponent(showSearchbar);

		
		beepOnSearchAutoWrap = new JCheckBox(jEdit.getProperty(
			""options.general.beepOnSearchAutoWrap""));
		beepOnSearchAutoWrap.setSelected(jEdit.getBooleanProperty(
			""search.beepOnSearchAutoWrap""));
		addComponent(beepOnSearchAutoWrap);

		
		showBufferSwitcher = new JCheckBox(jEdit.getProperty(
			""options.general.showBufferSwitcher""));
		showBufferSwitcher.setSelected(jEdit.getBooleanProperty(
			""view.showBufferSwitcher""));
		addComponent(showBufferSwitcher);

		
		showTips = new JCheckBox(jEdit.getProperty(
			""options.general.showTips""));
		showTips.setSelected(jEdit.getBooleanProperty(""tip.show""));
		addComponent(showTips);

		
		showSplash = new JCheckBox(jEdit.getProperty(
			""options.general.showSplash""));
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory == null)
			showSplash.setSelected(true);
		else
			showSplash.setSelected(!new File(settingsDirectory,""nosplash"").exists());
		addComponent(showSplash);
	}

	protected void _save()
	{
		jEdit.setProperty(""history"",history.getText());
		jEdit.setBooleanProperty(""saveCaret"",saveCaret.isSelected());
		jEdit.setBooleanProperty(""sortBuffers"",sortBuffers.isSelected());
		jEdit.setBooleanProperty(""sortByName"",sortByName.isSelected());
		jEdit.setBooleanProperty(""sortRecent"",sortRecent.isSelected());
		jEdit.setBooleanProperty(""view.checkModStatus"",checkModStatus
			.isSelected());
		jEdit.setBooleanProperty(""view.showFullPath"",showFullPath
			.isSelected());
		jEdit.setBooleanProperty(""view.showSearchbar"",showSearchbar
			.isSelected());
		jEdit.setBooleanProperty(""search.beepOnSearchAutoWrap"",beepOnSearchAutoWrap
			.isSelected());
		jEdit.setBooleanProperty(""view.showBufferSwitcher"",
			showBufferSwitcher.isSelected());
		jEdit.setBooleanProperty(""tip.show"",showTips.isSelected());

		
		
		
		String settingsDirectory = jEdit.getSettingsDirectory();
		if(settingsDirectory != null)
		{
			File file = new File(settingsDirectory,""nosplash"");
			if(showSplash.isSelected())
				file.delete();
			else
			{
				try
				{
					FileOutputStream out = new FileOutputStream(file);
					out.write('\n');
					out.close();
				}
				catch(IOException io)
				{
					Log.log(Log.ERROR,this,io);
				}
			}
		}
	}

	
	private JTextField history;
	private JCheckBox saveCaret;
	private JCheckBox sortBuffers;
	private JCheckBox sortByName;
	private JCheckBox sortRecent;
	private JCheckBox checkModStatus;
	private JCheckBox showFullPath;
	private JCheckBox showSearchbar;
  private JCheckBox beepOnSearchAutoWrap;
	private JCheckBox showBufferSwitcher;
	private JCheckBox showTips;
	private JCheckBox showSplash;
}
"
jEdit,4.1,org.gjt.sp.jedit.gui.ToolBarManager,5,1,0,2,17,4,1,1,3,0.5,137,1.0,0,0.0,0.5,0,0,25.6,3,2.0,0,"

package org.gjt.sp.jedit.gui;


import java.awt.*;
import java.util.*;
import org.gjt.sp.jedit.*;


public class ToolBarManager
{
	
	public ToolBarManager(Container top, Container bottom)
	{
		this.top = top;
		this.bottom = bottom;
	} 

	
	public void addToolBar(int group, int layer, Component toolbar)
	{
		Entry entry = new Entry(layer, toolbar);

		if (group == View.TOP_GROUP)
			addToolBar(top, topToolBars, entry);
		else if (group == View.BOTTOM_GROUP)
			addToolBar(bottom, bottomToolBars, entry);
		else
			throw new InternalError(""Invalid tool bar group"");
	} 

	
	public void removeToolBar(Component toolbar)
	{
		removeToolBar(top, topToolBars, toolbar);
		removeToolBar(bottom, bottomToolBars, toolbar);
	} 

	

	
	private Container top;
	private Container bottom;

	private ArrayList topToolBars = new ArrayList();
	private ArrayList bottomToolBars = new ArrayList();
	

	
	private void addToolBar(Container group, ArrayList toolbars,
		Entry entry)
	{
		
		for(int i = 0; i < toolbars.size(); i++)
		{
			if(entry.layer > ((Entry)toolbars.get(i)).layer)
			{
				toolbars.add(i,entry);
				group.add(entry.toolbar,i);
				return;
			}
		}

		
		toolbars.add(entry);
		group.add(entry.toolbar);
	} 

	
	private void removeToolBar(Container group, ArrayList toolbars,
		Component toolbar)
	{
		for(int i = 0; i < toolbars.size(); i++)
		{
			if(toolbar == ((Entry)toolbars.get(i)).toolbar)
			{
				group.remove(toolbar);
				toolbars.remove(i);

				return;
			}
		}
	} 

	

	
	static class Entry
	{
		int layer;
		Component toolbar;

		Entry(int layer, Component toolbar)
		{
			this.layer = layer;
			this.toolbar = toolbar;
		}
	} 
}
"
jEdit,4.1,org.gjt.sp.jedit.MiscUtilities,40,1,0,73,94,780,69,8,37,1.0,1674,0.0,0,0.0,0.10625,0,0,40.825,17,4.7,7,"

package org.gjt.sp.jedit;


import javax.swing.text.Segment;
import javax.swing.JMenuItem;
import java.io.*;
import java.util.*;
import org.gjt.sp.jedit.io.*;
import org.gjt.sp.util.Log;



public class MiscUtilities
{
	

	
	
	public static String canonPath(String path)
	{
		if(File.separatorChar == '\\')
		{
			
			path = path.replace('/','\\');
		}

		if(path.startsWith(""~"" + File.separator))
		{
			path = path.substring(2);
			String home = System.getProperty(""user.home"");

			if(home.endsWith(File.separator))
				return home + path;
			else
				return home + File.separator + path;
		}
		else if(path.equals(""~""))
			return System.getProperty(""user.home"");
		else
			return path;
	} 

	
	
	public static boolean isAbsolutePath(String path)
	{
		if(isURL(path))
			return true;
		else if(OperatingSystem.isDOSDerived())
		{
			if(path.length() >= 2 && path.charAt(1) == ':')
				return true;
			if(path.startsWith(""\\\\""))
				return true;
		}
		else if(OperatingSystem.isUnix())
		{
			
			if(path.length() > 0 && path.charAt(0) == '/')
				return true;
		}

		return false;
	} 

	
	
	public static String constructPath(String parent, String path)
	{
		if(MiscUtilities.isURL(path))
			return path;
		else if(path.startsWith(""~""))
			return path;
		else
		{
			
			if(OperatingSystem.isDOSDerived())
			{
				if(path.length() == 2 && path.charAt(1) == ':')
					return path;
				else if(path.length() > 2 && path.charAt(1) == ':')
				{
					if(path.charAt(2) != '\\')
					{
						path = path.substring(0,2) + '\\'
							+ path.substring(2);
					}

					return resolveSymlinks(path);
				}
				else if(path.startsWith(""\\\\""))
					return resolveSymlinks(path);
			}
			else if(OperatingSystem.isUnix())
			{
				
				if(path.length() > 0 && path.charAt(0) == '/')
					return resolveSymlinks(path);
			}
		}

		if(parent == null)
			parent = System.getProperty(""user.dir"");

		if(OperatingSystem.isDOSDerived() && path.startsWith(""\\""))
			parent = parent.substring(0,2);

		VFS vfs = VFSManager.getVFSForPath(parent);
		return vfs.constructPath(parent,path);
	} 

	
	
	public static String constructPath(String parent,
		String path1, String path2)
	{
		return constructPath(constructPath(parent,path1),path2);
	} 

	
	
	public static String concatPath(String parent, String path)
	{
		parent = canonPath(parent);
		path = canonPath(path);

		
		if (path.startsWith(File.separator))
			path = path.substring(1);
		else if ((path.length() >= 3) && (path.charAt(1) == ':'))
			path = path.replace(':', File.separatorChar);

		if (parent == null)
			parent = System.getProperty(""user.dir"");

		if (parent.endsWith(File.separator))
			return parent + path;
		else
			return parent + File.separator + path;
	} 

	
	
	public static String getFileExtension(String name)
	{
		int index = name.indexOf('.');
		if(index == -1)
			return """";
		else
			return name.substring(index);
	} 

	
	
	public static String getFileName(String path)
	{
		return VFSManager.getVFSForPath(path).getFileName(path);
	} 

	
	
	public static String getFileNameNoExtension(String path)
	{
		String name = getFileName(path);
		int index = name.lastIndexOf('.');
		if(index == -1)
			return name;
		else
			return name.substring(0,index);
	} 

	
	
	public static String getFileParent(String path)
	{
		return getParentOfPath(path);
	} 

	
	
	public static String getParentOfPath(String path)
	{
		return VFSManager.getVFSForPath(path).getParentOfPath(path);
	} 

	
	
	public static String getFileProtocol(String url)
	{
		return getProtocolOfURL(url);
	} 

	
	
	public static String getProtocolOfURL(String url)
	{
		return url.substring(0,url.indexOf(':'));
	} 

	
	
	public static boolean isURL(String str)
	{
		int fsIndex = Math.max(str.indexOf(File.separatorChar),
			str.indexOf('/'));
		if(fsIndex == 0) 
			return false;
		else if(fsIndex == 2) 
			return false;

		int cIndex = str.indexOf(':');
		if(cIndex <= 1) 
			return false;
		else if(fsIndex != -1 && cIndex > fsIndex) 
			return false;

		return true;
	} 

	
	
	public static void saveBackup(File file, int backups,
		String backupPrefix, String backupSuffix,
		String backupDirectory)
	{
		if(backupPrefix == null)
			backupPrefix = """";
		if(backupSuffix == null)
			backupSuffix = """";

		String name = file.getName();

		
		if(backups == 1)
		{
			File backupFile = new File(backupDirectory,
				backupPrefix + name + backupSuffix);
			backupFile.delete();
			file.renameTo(backupFile);
		}
		
		else
		{
			new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ backups + backupSuffix).delete();

			for(int i = backups - 1; i > 0; i--)
			{
				File backup = new File(backupDirectory,
					backupPrefix + name + backupSuffix
					+ i + backupSuffix);

				backup.renameTo(new File(backupDirectory,
					backupPrefix + name + backupSuffix
					+ (i+1) + backupSuffix));
			}

			file.renameTo(new File(backupDirectory,
				backupPrefix + name + backupSuffix
				+ ""1"" + backupSuffix));
		}
	} 

	
	
	public static String fileToClass(String name)
	{
		char[] clsName = name.toCharArray();
		for(int i = clsName.length - 6; i >= 0; i--)
			if(clsName[i] == '/')
				clsName[i] = '.';
		return new String(clsName,0,clsName.length - 6);
	} 

	
	
	public static String classToFile(String name)
	{
		return name.replace('.','/').concat("".class"");
	} 

	

	

	
	
	public static int getLeadingWhiteSpace(String str)
	{
		int whitespace = 0;
loop:		for(;whitespace < str.length();)
		{
			switch(str.charAt(whitespace))
			{
			case ' ': case '\t':
				whitespace++;
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} 

	
	
	public static int getTrailingWhiteSpace(String str)
	{
		int whitespace = 0;
loop:		for(int i = str.length() - 1; i >= 0; i--)
		{
			switch(str.charAt(i))
			{
			case ' ': case '\t':
				whitespace++;
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} 

	
	
	public static int getLeadingWhiteSpaceWidth(String str, int tabSize)
	{
		int whitespace = 0;
loop:		for(int i = 0; i < str.length(); i++)
		{
			switch(str.charAt(i))
			{
			case ' ':
				whitespace++;
				break;
			case '\t':
				whitespace += (tabSize - whitespace % tabSize);
				break;
			default:
				break loop;
			}
		}
		return whitespace;
	} 

	
	
	public static int getVirtualWidth(Segment seg, int tabSize)
	{
		int virtualPosition = 0;

		for (int i = 0; i < seg.count; i++)
		{
			char ch = seg.array[seg.offset + i];

			if (ch == '\t')
			{
				virtualPosition += tabSize
					- (virtualPosition % tabSize);
			}
			else
			{
				++virtualPosition;
			}
		}

		return virtualPosition;
	} 

	
	
	public static int getOffsetOfVirtualColumn(Segment seg, int tabSize,
		int column, int[] totalVirtualWidth)
	{
		int virtualPosition = 0;

		for (int i = 0; i < seg.count; i++)
		{
			char ch = seg.array[seg.offset + i];

			if (ch == '\t')
			{
				int tabWidth = tabSize
					- (virtualPosition % tabSize);
				if(virtualPosition >= column)
					return i;
				else
					virtualPosition += tabWidth;
			}
			else
			{
				if(virtualPosition >= column)
					return i;
				else
					++virtualPosition;
			}
		}

		if(totalVirtualWidth != null)
			totalVirtualWidth[0] = virtualPosition;
		return -1;
	} 

	
	
	public static String createWhiteSpace(int len, int tabSize)
	{
		StringBuffer buf = new StringBuffer();
		if(tabSize == 0)
		{
			while(len-- > 0)
				buf.append(' ');
		}
		else
		{
			int count = len / tabSize;
			while(count-- > 0)
				buf.append('\t');
			count = len % tabSize;
			while(count-- > 0)
				buf.append(' ');
		}
		return buf.toString();
	} 

	
	
	public static String globToRE(String glob)
	{
		StringBuffer buf = new StringBuffer();
		boolean backslash = false;
		boolean insideGroup = false;
		boolean insideNegativeLookahead = false;

		for(int i = 0; i < glob.length(); i++)
		{
			char c = glob.charAt(i);
			if(backslash)
			{
				buf.append('\\');
				buf.append(c);
				backslash = false;
				continue;
			}

			switch(c)
			{
			case '\\':
				backslash = true;
				break;
			case '?':
				buf.append('.');
				break;
			case '.':
				buf.append(""\\."");
				break;
			case '*':
				buf.append("".*"");
				break;
			case '{':
				buf.append('(');
				if(i + 1 != glob.length() && glob.charAt(i + 1) == '!')
				{
					buf.append('?');
					insideNegativeLookahead = true;
				}
				else
					insideGroup = true;
				break;
			case ',':
				if(insideGroup)
				{
					if(insideNegativeLookahead)
					{
						buf.append("").*"");
						insideNegativeLookahead = false;
					}
					buf.append('|');
				}
				else
					buf.append(',');
				break;
			case '}':
				if(insideNegativeLookahead)
				{
					buf.append("").*"");
					insideNegativeLookahead = false;
				}
				else if(insideGroup)
				{
					buf.append(')');
					insideGroup = false;
				}
				else
					buf.append('}');
				break;
			default:
				buf.append(c);
			}
		}

		return buf.toString();
	} 

	
	
	public static String escapesToChars(String str)
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			switch(c)
			{
			case '\\':
				if(i == str.length() - 1)
				{
					buf.append('\\');
					break;
				}
				c = str.charAt(++i);
				switch(c)
				{
				case 'n':
					buf.append('\n');
					break;
				case 't':
					buf.append('\t');
					break;
				default:
					buf.append(c);
					break;
				}
				break;
			default:
				buf.append(c);
			}
		}
		return buf.toString();
	} 

	
	
	public static String charsToEscapes(String str)
	{
		return charsToEscapes(str,""\n\t\\\""'"");
	} 

	
	
	public static String charsToEscapes(String str, String toEscape)
	{
		StringBuffer buf = new StringBuffer();
		for(int i = 0; i < str.length(); i++)
		{
			char c = str.charAt(i);
			if(toEscape.indexOf(c) != -1)
			{
				if(c == '\n')
					buf.append(""\\n"");
				else if(c == '\t')
					buf.append(""\\t"");
				else
				{
					buf.append('\\');
					buf.append(c);
				}
			}
			else
				buf.append(c);
		}
		return buf.toString();
	} 

	
	
	public static int compareVersions(String v1, String v2)
	{
		return compareStrings(v1,v2,false);
	} 

	
	
	public static int compareStrings(String str1, String str2, boolean ignoreCase)
	{
		char[] char1 = str1.toCharArray();
		char[] char2 = str2.toCharArray();

		int len = Math.min(char1.length,char2.length);

		for(int i = 0, j = 0; i < len && j < len; i++, j++)
		{
			char ch1 = char1[i];
			char ch2 = char2[j];
			if(Character.isDigit(ch1) && Character.isDigit(ch2)
				&& ch1 != '0' && ch2 != '0')
			{
				int _i = i + 1;
				int _j = j + 1;

				for(; _i < char1.length; _i++)
				{
					if(!Character.isDigit(char1[_i]))
					{
						
						break;
					}
				}

				for(; _j < char2.length; _j++)
				{
					if(!Character.isDigit(char2[_j]))
					{
						
						break;
					}
				}

				int len1 = _i - i;
				int len2 = _j - j;
				if(len1 > len2)
					return 1;
				else if(len1 < len2)
					return -1;
				else
				{
					for(int k = 0; k < len1; k++)
					{
						ch1 = char1[i + k];
						ch2 = char2[j + k];
						if(ch1 != ch2)
							return ch1 - ch2;
					}
				}

				i = _i - 1;
				j = _j - 1;
			}
			else
			{
				if(ignoreCase)
				{
					ch1 = Character.toLowerCase(ch1);
					ch2 = Character.toLowerCase(ch2);
				}

				if(ch1 != ch2)
					return ch1 - ch2;
			}
		}

		return char1.length - char2.length;
	} 

	
	
	public static boolean stringsEqual(String s1, String s2)
	{
		if(s1 == null)
		{
			if(s2 == null)
				return true;
			else
				return false;
		}
		else if(s2 == null)
			return false;
		else
			return s1.equals(s2);
	} 

	

	

	
	
	public static void quicksort(Object[] obj, Comparator compare)
	{
		Arrays.sort(obj,compare);
	} 

	
	
	public static void quicksort(Vector vector, Comparator compare)
	{
		Collections.sort(vector,compare);
	} 

	
	
	public static void quicksort(List list, Comparator compare)
	{
		Collections.sort(list,compare);
	} 

	
	
	public static void quicksort(Object[] obj, Compare compare)
	{
		Arrays.sort(obj,compare);
	} 

	
	
	public static void quicksort(Vector vector, Compare compare)
	{
		Collections.sort(vector,compare);
	} 

	
	
	public interface Compare extends Comparator
	{
		int compare(Object obj1, Object obj2);
	} 

	
	
	public static class StringCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return compareStrings(obj1.toString(),
				obj2.toString(),false);
		}
	} 

	
	
	public static class StringICaseCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return compareStrings(obj1.toString(),
				obj2.toString(),true);
		}
	} 

	
	
	public static class MenuItemCompare implements Compare
	{
		public int compare(Object obj1, Object obj2)
		{
			return compareStrings(((JMenuItem)obj1).getText(),
				((JMenuItem)obj2).getText(),true);
		}
	} 

	

	
	
	public static String buildToVersion(String build)
	{
		if(build.length() != 11)
			return ""<unknown version: "" + build + "">"";
		
		int major = Integer.parseInt(build.substring(0,2));
		
		int minor = Integer.parseInt(build.substring(3,5));
		
		int beta = Integer.parseInt(build.substring(6,8));
		
		int bugfix = Integer.parseInt(build.substring(9,11));

		return """" + major + ""."" + minor
			+ (beta != 99 ? ""pre"" + beta :
			(bugfix != 0 ? ""."" + bugfix : ""final""));
	} 

	
	
	public static boolean isToolsJarAvailable()
	{
		Log.log(Log.DEBUG, MiscUtilities.class,""Searching for tools.jar..."");

		Vector paths = new Vector();

		
		paths.addElement(""System classpath: ""
			+ System.getProperty(""java.class.path""));

		try
		{
			
			
			try
			{
				Class.forName(""sun.tools.javac.Main"");
			}
			catch(ClassNotFoundException e1)
			{
				Class.forName(""com.sun.tools.javac.Main"");
			}
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- is in classpath. Fine."");
			return true;
		}
		catch(ClassNotFoundException e)
		{
			
			
		} 

		
		String settingsDir = jEdit.getSettingsDirectory();
		if(settingsDir != null)
		{
			String toolsPath = constructPath(settingsDir, ""jars"",
				""tools.jar"");
			paths.addElement(toolsPath);
			if(new File(toolsPath).exists())
			{
				Log.log(Log.DEBUG, MiscUtilities.class,
					""- is in the user's jars folder. Fine."");
				
				return true;
			}
		} 

		
		String jEditDir = jEdit.getJEditHome();
		if(jEditDir != null)
		{
			String toolsPath = constructPath(jEditDir, ""jars"", ""tools.jar"");
			paths.addElement(toolsPath);
			if(new File(toolsPath).exists())
			{
				Log.log(Log.DEBUG, MiscUtilities.class,
					""- is in jEdit's system jars folder. Fine."");
				
				return true;
			}
		} 

		
		String toolsPath = System.getProperty(""java.home"");
		if(toolsPath.toLowerCase().endsWith(File.separator + ""jre""))
			toolsPath = toolsPath.substring(0, toolsPath.length() - 4);
		toolsPath = constructPath(toolsPath, ""lib"", ""tools.jar"");
		paths.addElement(toolsPath);

		if(!(new File(toolsPath).exists()))
		{
			Log.log(Log.WARNING, MiscUtilities.class,
				""Could not find tools.jar.\n""
				+ ""I checked the following locations:\n""
				+ paths.toString());
			return false;
		} 

		
		EditPlugin.JAR jar = jEdit.getPluginJAR(toolsPath);
		if(jar == null)
		{
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- adding "" + toolsPath + "" to jEdit plugins."");
			try
			{
				jEdit.addPluginJAR(new EditPlugin.JAR(toolsPath,
					new JARClassLoader(toolsPath)));
			}
			catch(IOException ioex)
			{
				Log.log(Log.ERROR, MiscUtilities.class,
					""- I/O error loading "" + toolsPath);
				Log.log(Log.ERROR, MiscUtilities.class, ioex);
				return false;
			}
		}
		else
			Log.log(Log.DEBUG, MiscUtilities.class,
				""- has been loaded before."");
		

		return true;
	} 

	
	
	public static int parsePermissions(String s)
	{
		int permissions = 0;

		if(s.length() == 9)
		{
			if(s.charAt(0) == 'r')
				permissions += 0400;
			if(s.charAt(1) == 'w')
				permissions += 0200;
			if(s.charAt(2) == 'x')
				permissions += 0100;
			else if(s.charAt(2) == 's')
				permissions += 04100;
			else if(s.charAt(2) == 'S')
				permissions += 04000;
			if(s.charAt(3) == 'r')
				permissions += 040;
			if(s.charAt(4) == 'w')
				permissions += 020;
			if(s.charAt(5) == 'x')
				permissions += 010;
			else if(s.charAt(5) == 's')
				permissions += 02010;
			else if(s.charAt(5) == 'S')
				permissions += 02000;
			if(s.charAt(6) == 'r')
				permissions += 04;
			if(s.charAt(7) == 'w')
				permissions += 02;
			if(s.charAt(8) == 'x')
				permissions += 01;
			else if(s.charAt(8) == 't')
				permissions += 01001;
			else if(s.charAt(8) == 'T')
				permissions += 01000;
		}

		return permissions;
	} 

	
	private MiscUtilities() {}

	
	private static String resolveSymlinks(String path)
	{
		try
		{
			return new File(path).getCanonicalPath();
		}
		catch(IOException io)
		{
			return path;
		}
	} 

	
}
"
jEdit,4.1,org.gjt.sp.jedit.textarea.Gutter,43,4,0,13,108,737,6,12,36,0.940952381,956,0.88,3,0.938953488,0.121645796,3,17,20.65116279,29,1.8837,3,"

package org.gjt.sp.jedit.textarea;


import java.awt.*;
import java.awt.event.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.event.*;
import org.gjt.sp.jedit.*;



public class Gutter extends JComponent implements SwingConstants
{
	
	
	public static final int LOWEST_LAYER = Integer.MIN_VALUE;

	
	public static final int DEFAULT_LAYER = 0;

	
	public static final int HIGHEST_LAYER = Integer.MAX_VALUE;
	

	
	public Gutter(View view, JEditTextArea textArea)
	{
		this.view = view;
		this.textArea = textArea;

		setAutoscrolls(true);
		setOpaque(true);

		extensionMgr = new ExtensionManager();

		MouseHandler ml = new MouseHandler();
		addMouseListener(ml);
		addMouseMotionListener(ml);

		addExtension(new MarkerHighlight());
	} 

	
	public void paintComponent(Graphics _gfx)
	{
		Graphics2D gfx = (Graphics2D)_gfx;

		
		Rectangle clip = gfx.getClipBounds();
		gfx.setColor(getBackground());
		gfx.fillRect(clip.x, clip.y, clip.width, clip.height);

		
		if (!textArea.getBuffer().isLoaded())
			return;

		int lineHeight = textArea.getPainter().getFontMetrics()
			.getHeight();

		int firstLine = clip.y / lineHeight;
		int lastLine = (clip.y + clip.height - 1) / lineHeight;

		int y = (clip.y - clip.y % lineHeight);

		textArea.chunkCache.updateChunksUpTo(lastLine);

		for (int line = firstLine; line <= lastLine;
			line++, y += lineHeight)
		{
			paintLine(gfx,line,y);
		}
	} 

	
	
	public void addExtension(TextAreaExtension extension)
	{
		extensionMgr.addExtension(DEFAULT_LAYER,extension);
		repaint();
	} 

	
	
	public void addExtension(int layer, TextAreaExtension extension)
	{
		extensionMgr.addExtension(layer,extension);
		repaint();
	} 

	
	
	public void removeExtension(TextAreaExtension extension)
	{
		extensionMgr.removeExtension(extension);
		repaint();
	} 

	
	
	public TextAreaExtension[] getExtensions()
	{
		return extensionMgr.getExtensions();
	} 

	
	
	public String getToolTipText(MouseEvent evt)
	{
		if(!textArea.getBuffer().isLoaded())
			return null;

		return extensionMgr.getToolTipText(evt.getX(),evt.getY());
	} 

	
	
	public void setBorder(int width, Color color1, Color color2, Color color3)
	{
		this.borderWidth = width;

		focusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color1));
		noFocusBorder = new CompoundBorder(new MatteBorder(0,0,0,width,color3),
			new MatteBorder(0,0,0,width,color2));
		updateBorder();
	} 

	
	
	public void updateBorder()
	{
		
		
		
		SwingUtilities.invokeLater(new Runnable()
		{
			public void run()
			{
				if(view.getEditPane() == null)
					return;

				if(view.getEditPane().getTextArea() == textArea)
					setBorder(focusBorder);
				else
					setBorder(noFocusBorder);
			}
		});
	} 

	
	
	public void setBorder(Border border)
	{
		super.setBorder(border);

		if (border == null)
		{
			collapsedSize.width = 0;
			collapsedSize.height = 0;
		}
		else
		{
			Insets insets = border.getBorderInsets(this);
			collapsedSize.width = FOLD_MARKER_SIZE + insets.right;
			collapsedSize.height = gutterSize.height
				= insets.top + insets.bottom;
			gutterSize.width = FOLD_MARKER_SIZE + insets.right
				+ fm.stringWidth(""12345"");
		}

		revalidate();
	} 

	
	
	public void setFont(Font font)
	{
		super.setFont(font);

		fm = getFontMetrics(font);

		baseline = fm.getAscent();

		Border border = getBorder();
		if(border != null)
		{
			gutterSize.width = FOLD_MARKER_SIZE
				+ border.getBorderInsets(this).right
				+ fm.stringWidth(""12345"");
			revalidate();
		}
	} 

	

	
	
	public Color getHighlightedForeground()
	{
		return intervalHighlight;
	} 

	
	public void setHighlightedForeground(Color highlight)
	{
		intervalHighlight = highlight;
	} 

	
	public Color getCurrentLineForeground()
 	{
		return currentLineHighlight;
	} 

	
	public void setCurrentLineForeground(Color highlight)
	{
		currentLineHighlight = highlight;
 	} 

	
	public Color getFoldColor()
 	{
		return foldColor;
	} 

	
	public void setFoldColor(Color foldColor)
	{
		this.foldColor = foldColor;
 	} 

	
	
	public Dimension getPreferredSize()
	{
		if (expanded)
			return gutterSize;
		else
			return collapsedSize;
	} 

	
	public Dimension getMinimumSize()
	{
		return getPreferredSize();
	} 

	
	
	public int getLineNumberAlignment()
	{
		return alignment;
	} 

	
	
	public void setLineNumberAlignment(int alignment)
	{
		if (this.alignment == alignment) return;

		this.alignment = alignment;

		repaint();
	} 

	
	
	public boolean isExpanded()
	{
		return expanded;
	} 

	
	
	public void setExpanded(boolean expanded)
	{
		if (this.expanded == expanded) return;

		this.expanded = expanded;

		textArea.revalidate();
	} 

	
	
	public void toggleExpanded()
	{
		setExpanded(!expanded);
	} 

	
	
	public int getHighlightInterval()
	{
		return interval;
	} 

	
	
	public void setHighlightInterval(int interval)
	{
		if (interval <= 1) interval = 0;
		this.interval = interval;
		repaint();
	} 

	
	public boolean isCurrentLineHighlightEnabled()
	{
		return currentLineHighlightEnabled;
	} 

	
	public void setCurrentLineHighlightEnabled(boolean enabled)
	{
		if (currentLineHighlightEnabled == enabled) return;

		currentLineHighlightEnabled = enabled;

		repaint();
	} 

	
	
	public final Color getBracketHighlightColor()
	{
		return bracketHighlightColor;
	} 

	
	
	public final void setBracketHighlightColor(Color bracketHighlightColor)
	{
		this.bracketHighlightColor = bracketHighlightColor;
		repaint();
	} 

	
	
	public final boolean isBracketHighlightEnabled()
	{
		return bracketHighlight;
	} 

	
	
	public final void setBracketHighlightEnabled(boolean bracketHighlight)
	{
		this.bracketHighlight = bracketHighlight;
		repaint();
	} 

	
	public Color getMarkerHighlightColor()
	{
		return markerHighlightColor;
	} 

	
	public void setMarkerHighlightColor(Color markerHighlightColor)
	{
		this.markerHighlightColor = markerHighlightColor;
	} 

	
	public boolean isMarkerHighlightEnabled()
	{
		return markerHighlight;
	} 

	
	public void setMarkerHighlightEnabled(boolean markerHighlight)
	{
		this.markerHighlight = markerHighlight;
	} 

	

	

	
	private static final int FOLD_MARKER_SIZE = 12;

	private View view;
	private JEditTextArea textArea;

	private ExtensionManager extensionMgr;

	private int baseline;

	private Dimension gutterSize = new Dimension(0,0);
	private Dimension collapsedSize = new Dimension(0,0);

	private Color intervalHighlight;
	private Color currentLineHighlight;
	private Color foldColor;

	private FontMetrics fm;

	private int alignment;

	private int interval;
	private boolean currentLineHighlightEnabled;
	private boolean expanded;

	private boolean bracketHighlight;
	private Color bracketHighlightColor;

	private boolean markerHighlight;
	private Color markerHighlightColor;

	private int borderWidth;
	private Border focusBorder, noFocusBorder;
	

	
	private void paintLine(Graphics2D gfx, int line, int y)
	{
		Buffer buffer = textArea.getBuffer();

		int lineHeight = textArea.getPainter().getFontMetrics()
			.getHeight();

		ChunkCache.LineInfo info = textArea.chunkCache.getLineInfo(line);
		if(!info.chunksValid)
			System.err.println(""gutter paint: not valid"");
		int physicalLine = info.physicalLine;

		
		if(physicalLine != -1)
		{
			int start = textArea.getScreenLineStartOffset(line);
			int end = textArea.getScreenLineEndOffset(line);

			extensionMgr.paintValidLine(gfx,line,physicalLine,start,end,y);
		}
		else
			extensionMgr.paintInvalidLine(gfx,line,y);
		

		
		if(physicalLine == -1)
			return;

		
		if(info.firstSubregion
			&& physicalLine != buffer.getLineCount() - 1
			&& buffer.isFoldStart(physicalLine))
		{
			int _y = y + lineHeight / 2;
			gfx.setColor(foldColor);
			if(textArea.getFoldVisibilityManager()
				.isLineVisible(physicalLine + 1))
			{
				gfx.drawLine(1,_y - 3,10,_y - 3);
				gfx.drawLine(2,_y - 2,9,_y - 2);
				gfx.drawLine(3,_y - 1,8,_y - 1);
				gfx.drawLine(4,_y,7,_y);
				gfx.drawLine(5,_y + 1,6,_y + 1);
			}
			else
			{
				gfx.drawLine(4,_y - 5,4,_y + 4);
				gfx.drawLine(5,_y - 4,5,_y + 3);
				gfx.drawLine(6,_y - 3,6,_y + 2);
				gfx.drawLine(7,_y - 2,7,_y + 1);
				gfx.drawLine(8,_y - 1,8,_y);
			}
		} 
		
		else if(bracketHighlight)
		{
			int bracketLine = textArea.getBracketLine();
			int caretLine = textArea.getCaretLine();

			if(textArea.isBracketHighlightVisible()
				&& physicalLine >= Math.min(caretLine,bracketLine)
				&& physicalLine <= Math.max(caretLine,bracketLine))
			{
				int caretScreenLine;
				if(caretLine > textArea.getLastPhysicalLine())
					caretScreenLine = Integer.MAX_VALUE;
				else
				{
					caretScreenLine = textArea
						.getScreenLineOfOffset(
						textArea.getCaretPosition());
				}

				int bracketScreenLine;
				if(bracketLine > textArea.getLastPhysicalLine())
					bracketScreenLine = Integer.MAX_VALUE;
				else
				{
					bracketScreenLine = textArea.chunkCache
						.getScreenLineOfOffset(
						bracketLine,
						textArea.getBracketPosition());
				}

				if(caretScreenLine > bracketScreenLine)
				{
					int tmp = caretScreenLine;
					caretScreenLine = bracketScreenLine;
					bracketScreenLine = tmp;
				}

				gfx.setColor(bracketHighlightColor);
				if(bracketScreenLine == caretScreenLine)
				{
					
				}
				else if(line == caretScreenLine)
				{
					gfx.fillRect(5,
						y
						+ lineHeight / 2,
						5,
						2);
					gfx.fillRect(5,
						y
						+ lineHeight / 2,
						2,
						lineHeight - lineHeight / 2);
				}
				else if(line == bracketScreenLine)
				{
					gfx.fillRect(5,
						y,
						2,
						lineHeight / 2);
					gfx.fillRect(5,
						y + lineHeight / 2,
						5,
						2);
				}
				else if(line > caretScreenLine
					&& line < bracketScreenLine)
				{
					gfx.fillRect(5,
						y,
						2,
						lineHeight);
				}
			}
		} 

		
		if(info.firstSubregion && expanded)
		{
			String number = Integer.toString(physicalLine + 1);

			int offset;
			switch (alignment)
			{
			case RIGHT:
				offset = gutterSize.width - collapsedSize.width
					- (fm.stringWidth(number) + 1);
				break;
			case CENTER:
				offset = ((gutterSize.width - collapsedSize.width)
					- fm.stringWidth(number)) / 2;
				break;
			case LEFT: default:
				offset = 0;
				break;
			}

			boolean highlightCurrentLine = currentLineHighlightEnabled
				&& textArea.selection.size() == 0;
			if (physicalLine == textArea.getCaretLine() && highlightCurrentLine)
			{
				gfx.setColor(currentLineHighlight);
			}
			else if (interval > 1 && (line
				+ textArea.getFirstLine() + 1)
				% interval == 0)
				gfx.setColor(intervalHighlight);
			else
				gfx.setColor(getForeground());

			gfx.drawString(number, FOLD_MARKER_SIZE + offset,
				baseline + y);
		} 
	} 

	

	
	class MouseHandler extends MouseInputAdapter
	{
		boolean drag;
		int toolTipInitialDelay, toolTipReshowDelay;

		
		public void mouseEntered(MouseEvent e)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			toolTipInitialDelay = ttm.getInitialDelay();
			toolTipReshowDelay = ttm.getReshowDelay();
			ttm.setInitialDelay(0);
			ttm.setReshowDelay(0);
		} 

		
		public void mouseExited(MouseEvent evt)
		{
			ToolTipManager ttm = ToolTipManager.sharedInstance();
			ttm.setInitialDelay(toolTipInitialDelay);
			ttm.setReshowDelay(toolTipReshowDelay);
		} 

		
		public void mousePressed(MouseEvent e)
		{
			if(GUIUtilities.isPopupTrigger(e)
				|| e.getX() >= getWidth() - borderWidth * 2)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mousePressed(e);
				drag = true;
			}
			else
			{
				Buffer buffer = textArea.getBuffer();

				int screenLine = e.getY() / textArea.getPainter()
					.getFontMetrics().getHeight();
				textArea.chunkCache.updateChunksUpTo(screenLine);

				int line = textArea.chunkCache.getLineInfo(screenLine)
					.physicalLine;

				if(line == -1)
					return;

				FoldVisibilityManager foldVisibilityManager
					= textArea.getFoldVisibilityManager();

				
				if(buffer.isFoldStart(line))
				{
					StringBuffer property = new StringBuffer(
						""view.gutter.gutter"");
					if(e.isShiftDown())
						property.append(""Shift"");
					if(e.isControlDown())
						property.append(""Control"");
					if(e.isAltDown())
						property.append(""Alt"");
					property.append(""Click"");

					String action = jEdit.getProperty(property
						.toString());
					if(action == null)
					{
						action = jEdit.getProperty(
							""view.gutter.gutterClick"");
					}

					if(action == null)
						action = ""toggleFold"";

					if(action.equals(""selectFold""))
					{
						foldVisibilityManager
							.expandFold(line,true);
						textArea.selectFold(line);
					}
					else if(foldVisibilityManager
						.isLineVisible(line + 1))
					{
						foldVisibilityManager
							.collapseFold(line);
					}
					else
					{
						if(action.equals(
							""toggleFoldFully""))
						{
							foldVisibilityManager
								.expandFold(line,
								true);
						}
						else
						{
							foldVisibilityManager
								.expandFold(line,
								false);
						}
					}
				} 
				
				else if(bracketHighlight)
				{
					if(textArea.isBracketHighlightVisible())
					{
						int bracketLine = textArea.getBracketLine();
						int caretLine = textArea.getCaretLine();
						if(caretLine != bracketLine)
						{
							if(caretLine > bracketLine)
							{
								int tmp = caretLine;
								caretLine = bracketLine;
								bracketLine = tmp;
							}

							if(line >= caretLine
								&& line <= bracketLine)
							{
								if(e.isControlDown())
									textArea.selectToMatchingBracket();
								else
									textArea.goToMatchingBracket();
							}
						}
					}
				} 
			}
		} 

		
		public void mouseDragged(MouseEvent e)
		{
			if(drag )
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseDragged(e);
			}
		} 

		
		public void mouseReleased(MouseEvent e)
		{
			if(drag && e.getX() >= getWidth() - borderWidth * 2)
			{
				e.translatePoint(-getWidth(),0);
				textArea.mouseHandler.mouseReleased(e);
			}

			drag = false;
		} 
	} 

	
	class MarkerHighlight extends TextAreaExtension
	{
		
		public void paintValidLine(Graphics2D gfx, int screenLine,
			int physicalLine, int start, int end, int y)
		{
			if(isMarkerHighlightEnabled())
			{
				Buffer buffer = textArea.getBuffer();
				if(buffer.getMarkerInRange(start,end) != null)
				{
					gfx.setColor(getMarkerHighlightColor());
					FontMetrics fm = textArea.getPainter().getFontMetrics();
					gfx.fillRect(0,y,textArea.getGutter()
						.getWidth(),fm.getHeight());
				}
			}
		} 

		
		public String getToolTipText(int x, int y)
		{
			if(isMarkerHighlightEnabled())
			{
				int line = y / textArea.getPainter().getFontMetrics().getHeight();
				int start = textArea.getScreenLineStartOffset(line);
				int end = textArea.getScreenLineEndOffset(line);
				if(start == -1 || end == -1)
					return null;

				Marker marker = textArea.getBuffer().getMarkerInRange(start,end);
				if(marker != null)
				{
					char shortcut = marker.getShortcut();
					if(shortcut == '\0')
						return jEdit.getProperty(""view.gutter.marker.no-name"");
					else
					{
						String[] args = { String.valueOf(shortcut) };
						return jEdit.getProperty(""view.gutter.marker"",args);
					}
				}
			}

			return null;
		} 
	} 
}
"
