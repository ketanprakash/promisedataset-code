name,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
org.apache.xpath.res.XPATHErrorResources_sv,3,4,0,1,4,1,0,1,2,1.428571429,1872,0.0,0,0.976190476,1.0,0,0,618.3333333,1,0.3333,1,"
package org.apache.xpath.res;


public class XPATHErrorResources_sv extends XPATHErrorResources
{


  
public static final int MAX_CODE = 108;  

  
  public static final int MAX_WARNING = 11;  

  
  public static final int MAX_OTHERS = 20;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  
  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_CURRENT_NOT_ALLOWED_IN_MATCH,
      ""Funktionen current() är inte tillåten i ett matchningsmönster!""},


  
  


  {
    ER_CURRENT_TAKES_NO_ARGS,
      ""Funktionen current() tar inte emot argument!""},


  
  


  {
    ER_DOCUMENT_REPLACED,
      ""Implementeringen av funktionen document() har ersatts av org.apache.xalan.xslt.FuncDocument!""},


  
  


  {
    ER_CONTEXT_HAS_NO_OWNERDOC,
      ""Kontext saknar ägardokument!""},


  
  


  {
    ER_LOCALNAME_HAS_TOO_MANY_ARGS,
      ""local-name() har för många argument.""},


  
  


  {
    ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
      ""namespace-uri() har för många argument.""},


  
  


  {
    ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
      ""normalize-space() har för många argument.""},


  
  


  {
    ER_NUMBER_HAS_TOO_MANY_ARGS,
      ""number() har för många argument.""},


  
  


  {
    ER_NAME_HAS_TOO_MANY_ARGS, ""name() har för många argument.""},


  
  


  {
    ER_STRING_HAS_TOO_MANY_ARGS,
      ""string() har för många argument.""},


  
  


  {
    ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
      ""string.length() har för många argument.""},


  
  


  {
    ER_TRANSLATE_TAKES_3_ARGS,
      ""Funktionen translate() tar emot tre argument!""},


  
  


  {
    ER_UNPARSEDENTITYURI_TAKES_1_ARG,
      ""Funktionen unparsed-entity-uri borde ta emot ett argument!""},


  
  


  {
    ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
      ""Namespace-axel inte implementerad än!""},


  
  


  {
    ER_UNKNOWN_AXIS, ""okänd axel: {0}""},


  
  


  {
    ER_UNKNOWN_MATCH_OPERATION, ""okänd matchningshandling!""},


  
  


  {
    ER_INCORRECT_ARG_LENGTH,
      ""Nodtests argumentlängd i processing-instruction() är inte korrekt!""},


  
  


  {
    ER_CANT_CONVERT_TO_NUMBER,
      ""Kan inte konvertera {0} till ett nummer""},


  
  


  {
    ER_CANT_CONVERT_TO_NODELIST,
      ""Kan inte konvertera {0} till en NodeList!""},


  
  


  {
    ER_CANT_CONVERT_TO_MUTABLENODELIST,
      ""Kan inte konvertera {0} till en NodeSetDTM!""},


  
  


  {
    ER_CANT_CONVERT_TO_TYPE,
      ""Kan inte konvertera {0} till en type


  
  


  {
    ER_EXPECTED_MATCH_PATTERN,
      ""Matchningsmönster i getMatchScore förväntat!""},


  
  


  {
    ER_COULDNOT_GET_VAR_NAMED,
      ""Kunde inte hämta variabeln {0}""},


  
  


  {
    ER_UNKNOWN_OPCODE, ""FEL! Okänd op-kod: {0}""},


  
  


  {
    ER_EXTRA_ILLEGAL_TOKENS, ""Ytterligare otillåtna tecken: {0}""},


  
  


  {
    ER_EXPECTED_DOUBLE_QUOTE,
      ""Litteral omges av fel sorts citationstecken... dubbla citationstecken förväntade!""},


  
  


  {
    ER_EXPECTED_SINGLE_QUOTE,
      ""Litteral omges av fel sorts citationstecken... enkla citationstecken förväntade!""},


  
  


  {
    ER_EMPTY_EXPRESSION, ""Tomt uttryck!""},


  
  


  {
    ER_EXPECTED_BUT_FOUND, ""{0} förväntat, men hittade: {1}""},


  
  


  {
    ER_INCORRECT_PROGRAMMER_ASSERTION,
      ""Programmerares försäkran är inte korrekt! - {0}""},


  
  


  {
    ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
      ""boolean(...)-argument är inte längre valfri med 19990709 XPath-utkast.""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
      ""Hittade ',' men inget föregående argument!""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
      ""Hittade ',' men inget efterföljande argument!""},


  
  


  {
    ER_PREDICATE_ILLEGAL_SYNTAX,
      ""'..[predikat]' or '.[predikat]' är otillåten syntax.  Använd 'self::node()[predikat]' istället.""},


  
  


  {
    ER_ILLEGAL_AXIS_NAME, ""otillåtet axel-namn: {0}""},


  
  


  {
    ER_UNKNOWN_NODETYPE, ""okänd nodtyp: {0}""},


  
  


  {
    ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
      ""Mönsterlitteral {0} måste sättas inom citationstecken!""},


  
  


  {
    ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
      ""{0} kunde inte formateras till ett nummer""},


  
  


  {
    ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
      ""Kunde inte skapa XML TransformerFactory Liaison: {0}""},


  
  


  {
    ER_DIDNOT_FIND_XPATH_SELECT_EXP,
      ""Fel! Hittade inte xpath select-uttryck (-select).""},


  
  


  {
    ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
      ""FEL! Hittade inte ENDOP efter OP_LOCATIONPATH""},


  
  


  {
    ER_ERROR_OCCURED, ""Fel inträffade!""},


  
  


  {
    ER_ILLEGAL_VARIABLE_REFERENCE,
      ""VariableReference angiven för variabel som är utanför sammanhanget eller som saknar definition!  Namn = {0}""},


  
  


  {
    ER_AXES_NOT_ALLOWED,
      ""Enbart barn::- och attribut::- axlar är tillåtna i matchningsmönster!  Regelvidriga axlar = {0}""},


  
  


  {
    ER_KEY_HAS_TOO_MANY_ARGS,
      ""key() har ett felaktigt antal argument.""},


  
  


  {
    ER_COUNT_TAKES_1_ARG,
      ""Funktionen count borde ta emot ett argument!""},


  
  


  {
    ER_COULDNOT_FIND_FUNCTION, ""Hittade inte funktionen: {0}""},


  
  


  {
    ER_UNSUPPORTED_ENCODING, ""Ej understödd kodning: {0}""},


  
  


  {
    ER_PROBLEM_IN_DTM_NEXTSIBLING,
      ""Problem inträffade i DTM i getNextSibling... försöker återhämta""},


  
  


  {
    ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
      ""Programmerarfel: EmptyNodeList kan inte skrivas till.""},


  
  


  {
    ER_SETDOMFACTORY_NOT_SUPPORTED,
      ""setDOMFactory understöds inte av XPathContext!""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""Prefix must resolve to a namespace: {0}""},


  
  


  {
    ER_PARSE_NOT_SUPPORTED,
      ""parse (InputSource source) understöds inte av XPathContext! Kan inte öppna {0}""},


  
  


  {
    ER_SAX_API_NOT_HANDLED,
      ""SAX API-tecken(char ch[]... hanteras inte av DTM!""},


  
  


  {
    ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
      ""ignorableWhitespace(char ch[]... hanteras inte av DTM!""},


  
  


  {
    ER_DTM_CANNOT_HANDLE_NODES,
      ""DTMLiaison kan inte hantera noder av typen {0}""},


  
  


  {
    ER_XERCES_CANNOT_HANDLE_NODES,
      ""DOM2Helper kan inte hantera noder av typen {0}""},


  
  


  {
    ER_XERCES_PARSE_ERROR_DETAILS,
      ""DOM2Helper.parse-fel: SystemID - {0} rad - {1}""},


  
  


  {
    ER_XERCES_PARSE_ERROR, ""DOM2Helper.parse-fel""},


  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""Ogiltigt UTF-16-surrogat upptäckt: {0} ?""},


  
  


  {
    ER_OIERROR, ""IO-fel""},


  
  


  {
    ER_CANNOT_CREATE_URL, ""Kan inte skapa url för: {0}""},


  
  


  {
    ER_XPATH_READOBJECT, ""I XPath.readObject: {0}""},

  
  
  


  {
    ER_FUNCTION_TOKEN_NOT_FOUND,
      ""funktionstecken saknas.""},

  
   
  


  {
    ER_CANNOT_DEAL_XPATH_TYPE,
       ""Kan inte hantera XPath-typ: {0}""},

  
   
  


  {
    ER_NODESET_NOT_MUTABLE,
       ""NodeSet är oföränderlig""},

  
   
  


  {
    ER_NODESETDTM_NOT_MUTABLE,
       ""NodeSetDTM är oföränderlig""},

  
   
  


  {
    ER_VAR_NOT_RESOLVABLE,
        ""Variabel ej lösbar: {0}""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""Null error handler""},

  
   
  


  {
    ER_PROG_ASSERT_UNKNOWN_OPCODE,
       ""Programmerares försäkran: okänd op-kod: {0}""},

  
   
  


  {
    ER_ZERO_OR_ONE,
       ""0 eller 1""},

  
  
   
  


  {
    ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""rtf() understöds inte av XRTreeFragSelectWrapper!""},

  
   
  


  {
    ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""asNodeIterator() understöds inte av XRTreeFragSelectWrapper!""},

  
   
  


  {
    ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
       ""fsb() understöds inte av XRStringForChars!""},

  
   
  


  {
    ER_COULD_NOT_FIND_VAR,
      ""Hittade inte variabeln med namn {0}""},

  
   
  


  {
    ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
      ""XStringForChars kan inte ta en sträng som argument""},

  
   
  


  {
    ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
      ""FastStringBuffer-argumentet får inte vara null""},
    
 
   
  


  {
    ER_TWO_OR_THREE,
       ""2 eller 3""},


   
  


  {
    ER_VARIABLE_ACCESSED_BEFORE_BIND,
       ""Variabeln användes innan den bands!""},


   
  


  {
    ER_FSB_CANNOT_TAKE_STRING,
       ""XStringForFSB kan inte ha en sträng som argument!""},


   
  


  {
    ER_SETTING_WALKER_ROOT_TO_NULL,
       ""
 !!!! Fel! Anger roten för en ""walker"" till null!!!""},


   
  


  {
    ER_NODESETDTM_CANNOT_ITERATE,
       ""Detta NodeSetDTM kan inte iterera till en tidigare nod!""},


  
  


  {
    ER_NODESET_CANNOT_ITERATE,
       ""Detta NodeSet kan inte iterera till en tidigare nod!""},


  
  


  {
    ER_NODESETDTM_CANNOT_INDEX,
       ""Detta NodeSetDTM har inte funktioner för indexering och räkning!""},


  
  


  {
    ER_NODESET_CANNOT_INDEX,
       ""Detta NodeSet har inte funktioner för indexering och räkning!""},


  
  


  {
    ER_CANNOT_CALL_SETSHOULDCACHENODE,
       ""Det går inte att anropa setShouldCacheNodes efter att nextNode har anropats!""},


  
  


  {
    ER_ONLY_ALLOWS,
       ""{0} tillåter bara {1} argument""},


  
  


  {
    ER_UNKNOWN_STEP,
       ""Programmerarkontroll i getNextStepPos: okänt steg Typ: {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_REL_LOC_PATH,
       ""En relativ sökväg förväntades efter token '/' eller '


  
  
  

  
  


  {
    ER_EXPECTED_LOC_PATH,
       ""En plats förväntades, men följande token påträffades:  {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_LOC_STEP,
       ""Ett platssteg förväntades efter token  '/' eller '


  
  
  
  

  
  


  {
    ER_EXPECTED_NODE_TEST,
       ""Ett nodtest som matchar antingen NCName:* eller QName förväntades.""},


  
  
  

  
  


  {
    ER_EXPECTED_STEP_PATTERN,
       ""Ett stegmönster förväntades, men '/' påträffades.""},


  
  
  
 
  
  


  {
    ER_EXPECTED_REL_PATH_PATTERN,
       ""Ett mönster för relativ sökväg förväntades.""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_BOOLEAN,
       ""Det går inte att konvertera {0} till ett Booleskt värde.""},


  
  

  
  


  {
    ER_CANT_CONVERT_TO_SINGLENODE,
       ""Det går inte att konvertera {0} till en enda nod. Gäller typerna ANY_UNORDERED_NODE_TYPE och FIRST_ORDERED_NODE_TYPE.""},


  
  

  
  


  {
    ER_CANT_GET_SNAPSHOT_LENGTH,
       ""Det går inte att erhålla längd för ögonblicksbild på typ: {0}. Gäller typerna UNORDERED_NODE_SNAPSHOT_TYPE och ORDERED_NODE_SNAPSHOT_TYPE.""},


  
  


  {
    ER_NON_ITERATOR_TYPE,
       ""Det går inte att iterera över den icke itererbara typen: {0}""},


  
  
  

  
  


  {
    ER_DOC_MUTATED,
       ""Dokumentet har ändrats sedan resultatet genererades. Iterering ogiltig.""},


  
  


  {
    ER_INVALID_XPATH_TYPE,
       ""Ogiltigt XPath-typargument: {0}""},


  
  


  {
    ER_EMPTY_XPATH_RESULT,
       ""Tomt XPath-resultatobjekt""},


  
  


  {
    ER_INCOMPATIBLE_TYPES,
       ""Den genererade typen: {0} kan inte bearbetas i den angivna typen: {1}""},


  
  


  {
    ER_NULL_RESOLVER,
       ""Det går inte att lösa prefixet utan prefixlösare.""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_STRING,
       ""Det går inte att konvertera {0} till en sträng.""},


  
  

  
  


  {
    ER_NON_SNAPSHOT_TYPE,
       ""Det går inte att anropa snapshotItem på typ: {0}. Metoden gäller typerna UNORDERED_NODE_SNAPSHOT_TYPE och ORDERED_NODE_SNAPSHOT_TYPE.""},


  
  
  
  

  
  


  {
    ER_WRONG_DOCUMENT,
       ""Kontextnoden tillhör inte dokumentet som är bundet till denna XPathEvaluator.""},


  
  
  
  


  {
    ER_WRONG_NODETYPE ,
       ""Kontextnoden kan inte hanteras.""},


  
  


  {
    ER_XPATH_ERROR ,
       ""Okänt fel i XPath.""},



  

  
  


  {
    WG_LOCALE_NAME_NOT_HANDLED,
      ""locale-namnet i format-number-funktionen ännu inte hanterat!""},


  
  


  {
    WG_PROPERTY_NOT_SUPPORTED,
      ""XSL-Egenskap understöds inte: {0}""},


  
  


  {
    WG_DONT_DO_ANYTHING_WITH_NS,
      ""Gör för närvarande inte någonting med namespace {0} i egenskap: {1}""},


  
  


  {
    WG_SECURITY_EXCEPTION,
      ""SecurityException vid försök att få tillgång till XSL-systemegenskap: {0}""},


  
  


  {
    WG_QUO_NO_LONGER_DEFINED,
      ""Gammal syntax: quo(...) är inte längre definierad i XPath.""},


  
  


  {
    WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
      ""XPath behöver ett deriverat objekt för att implementera nodeTest!""},


  
  


  {
    WG_FUNCTION_TOKEN_NOT_FOUND,
      ""funktionstecken saknas.""},


  
  


  {
    WG_COULDNOT_FIND_FUNCTION,
      ""Hittade inte funktion: {0}""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""Kan inte skapa URL från: {0}""},


  
  


  {
    WG_EXPAND_ENTITIES_NOT_SUPPORTED,
      ""Alternativet -E understöds inte för DTM-tolk""},


  
  


  {
    WG_ILLEGAL_VARIABLE_REFERENCE,
      ""VariableReference angiven för variabel som är utanför sammanhanget eller som saknar definition!  Namn = {0}""},


  
  


  {
    WG_UNSUPPORTED_ENCODING, ""Ej understödd kodning: {0}""},


  

  { ""ui_language"", ""sv""},
  { ""help_language"", ""sv""},
  { ""language"", ""sv""},
    { ""BAD_CODE"",
      ""Parameter till createMessage ligger utanför tillåtet intervall""},
    { ""FORMAT_FAILED"",
      ""Undantag utlöst vid messageFormat-anrop""},
    { ""version"", "">>>>>>> Xalan Version""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"",  ""ja""},
    { ""line"",  ""Rad 
    { ""column"", ""Kolumn 
    { ""xsldone"", ""XSLProcessor färdig""},
    { ""xpath_option"", ""xpath-alternativ""},
    { ""optionIN"", ""    [-in inputXMLURL]""},
    { ""optionSelect"", ""[-select xpath-uttryck]""},
    { ""optionMatch"",
      ""   [-match matchningsmönster (för matchningsdiagnostik)]""},
    { ""optionAnyExpr"",
      ""Eller bara ett xpath-uttryck kommer att göra en diagnostik-dump""},
    { ""noParsermsg1"", ""XSL-Process misslyckades.""},
    { ""noParsermsg2"", ""** Hittade inte tolk **""},
    { ""noParsermsg3"", ""Vänligen kontrollera din classpath""},
    { ""noParsermsg4"",
      ""Om du inte har IBMs XML-Tolk för Java, kan du ladda ner den från""},
    { ""noParsermsg5"",
      ""IBMs AlphaWorks: http:
  };

  

  
  public static final String BAD_CODE = ""DÅLIG_KOD"";

  
  public static final String FORMAT_FAILDE = ""FORMATTERING_MISSLYCKADES"";

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""

  
  public static final String ERROR_HEADER = ""Fel: "";

  
  public static final String WARNING_HEADER = ""Varning: "";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""MÖNSTER "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}


"
org.apache.xalan.xsltc.compiler.TransletOutput,5,3,0,20,33,0,0,20,4,0.5,176,1.0,1,0.933333333,0.333333333,2,7,33.8,6,1.8,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.StringType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class TransletOutput extends Instruction {

    private Expression _filename;
    private boolean _append;

    
    public void display(int indent) {
	indent(indent);
	Util.println(""TransletOutput: "" + _filename);
    }
		
    
    public void parseContents(Parser parser) {
	
	String filename = getAttribute(""file"");
        
        
        
        String append   = getAttribute(""append"");

	
	if ((filename == null) || (filename.equals(EMPTYSTRING))) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""file"");
	}

	
	_filename = AttributeValue.create(this, filename, parser);
        
        if (append != null && (append.toLowerCase().equals(""yes"") ||
            append.toLowerCase().equals(""true""))) {
          _append = true;     
        }
        else
          _append = false;
          
	parseChildren(parser);
    }
    
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type type = _filename.typeCheck(stable);
	if (type instanceof StringType == false) {
	    _filename = new CastExpr(_filename, Type.String);
	}
	typeCheckContents(stable);
	return Type.Void;
    }
    
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	
	final int open =  cpg.addMethodref(TRANSLET_CLASS,
					   ""openOutputHandler"",
                                           ""("" + STRING_SIG + ""Z)"" +
					   TRANSLET_OUTPUT_SIG);

	final int close =  cpg.addMethodref(TRANSLET_CLASS,
					    ""closeOutputHandler"",
					    ""(""+TRANSLET_OUTPUT_SIG+"")V"");

	
	il.append(classGen.loadTranslet());
	_filename.translate(classGen, methodGen);
        il.append(new PUSH(cpg, _append));
	il.append(new INVOKEVIRTUAL(open));

	
	il.append(methodGen.storeHandler());
	
	
	translateContents(classGen, methodGen);

	
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadHandler());
	il.append(new INVOKEVIRTUAL(close));

	
	il.append(methodGen.storeHandler());
    }
}

"
org.apache.xalan.lib.Extensions,13,1,0,11,54,76,1,10,9,0.875,371,0.5,1,0.0,0.208333333,0,0,27.23076923,5,1.9231,1,"
package org.apache.xalan.lib;

import java.util.Hashtable;
import java.util.StringTokenizer;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xalan.xslt.EnvironmentCheck;
import org.apache.xpath.NodeSet;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;

import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.w3c.dom.traversal.NodeIterator;

import org.xml.sax.SAXNotSupportedException;


public class Extensions
{

  
  private static Document m_doc = null;
  private static Extensions m_instance = new Extensions();
  
  
  private Extensions(){}  

  
  public static NodeSet nodeset(ExpressionContext myProcessor, Object rtf)
  {

    String textNodeValue;

    if (rtf instanceof NodeIterator)
    {
      return new NodeSet((NodeIterator) rtf);
    }
    else
    {
      if (rtf instanceof String)
      {
        textNodeValue = (String) rtf;
      }
      else if (rtf instanceof Boolean)
      {
        textNodeValue = new XBoolean(((Boolean) rtf).booleanValue()).str();
      }
      else if (rtf instanceof Double)
      {
        textNodeValue = new XNumber(((Double) rtf).doubleValue()).str();
      }
      else
      {
        textNodeValue = rtf.toString();
      }

      
      
      try
      {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        Document myDoc = db.newDocument();
        
        Text textNode = myDoc.createTextNode(textNodeValue);
        DocumentFragment docFrag = myDoc.createDocumentFragment();
  
        docFrag.appendChild(textNode);
  
        return new NodeSet(docFrag);
      }
      catch(ParserConfigurationException pce)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(pce);
      }
    }
  }

  
  public static NodeList intersection(NodeList nl1, NodeList nl2)
  {
    return ExsltSets.intersection(nl1, nl2);
  }

  
  public static NodeList difference(NodeList nl1, NodeList nl2)
  {
    return ExsltSets.difference(nl1, nl2);
  }

  
  public static NodeList distinct(NodeList nl)
  {
    return ExsltSets.distinct(nl);
  }

  
  public static boolean hasSameNodes(NodeList nl1, NodeList nl2)
  {

    NodeSet ns1 = new NodeSet(nl1);
    NodeSet ns2 = new NodeSet(nl2);

    if (ns1.getLength() != ns2.getLength())
      return false;

    for (int i = 0; i < ns1.getLength(); i++)
    {
      Node n = ns1.elementAt(i);

      if (!ns2.contains(n))
        return false;
    }

    return true;
  }

  
  public static XObject evaluate(ExpressionContext myContext, String xpathExpr)
         throws SAXNotSupportedException
  {
    return ExsltDynamic.evaluate(myContext, xpathExpr);
  }

  
  public static NodeList tokenize(String toTokenize, String delims)
  {
    try
    {
      
      if (m_doc == null)
      {
        synchronized (m_instance)
        {
          if (m_doc == null)
            m_doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
        }
      }
    }
    catch(ParserConfigurationException pce)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(pce);
    }

    StringTokenizer lTokenizer = new StringTokenizer(toTokenize, delims);
    NodeSet resultSet = new NodeSet();

    synchronized (m_doc)
    {
      while (lTokenizer.hasMoreTokens())
      {
        resultSet.addNode(m_doc.createTextNode(lTokenizer.nextToken()));
      }
    }

    return resultSet;
  }

  
  public static NodeList tokenize(String toTokenize)
  {
    return tokenize(toTokenize, "" 	

"");
  }

  
  public static Node checkEnvironment(ExpressionContext myContext)
  {

    Document factoryDocument;
    try
    {
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
      DocumentBuilder db = dbf.newDocumentBuilder();
      factoryDocument = db.newDocument();
    }
    catch(ParserConfigurationException pce)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(pce);
    }

    Node resultNode = null;
    try
    {
      
      
      resultNode = checkEnvironmentUsingWhich(myContext, factoryDocument);

      if (null != resultNode)
        return resultNode;

      
      EnvironmentCheck envChecker = new EnvironmentCheck();
      Hashtable h = envChecker.getEnvironmentHash();
      resultNode = factoryDocument.createElement(""checkEnvironmentExtension"");
      envChecker.appendEnvironmentReport(resultNode, factoryDocument, h);
      envChecker = null;
    }
    catch(Exception e)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(e);
    }

    return resultNode;
  }

  
  private static Node checkEnvironmentUsingWhich(ExpressionContext myContext, 
        Document factoryDocument)
  {
    final String WHICH_CLASSNAME = ""org.apache.env.Which"";
    final String WHICH_METHODNAME = ""which"";
    final Class WHICH_METHOD_ARGS[] = { java.util.Hashtable.class,
                                        java.lang.String.class,
                                        java.lang.String.class };
    try
    {
      
      
      
      Class clazz = Class.forName(WHICH_CLASSNAME);
      if (null == clazz)
        return null;

      
      java.lang.reflect.Method method = clazz.getMethod(WHICH_METHODNAME, WHICH_METHOD_ARGS);
      Hashtable report = new Hashtable();

      
      Object[] methodArgs = { report, ""XmlCommons;Xalan;Xerces;Crimson;Ant"", """" };
      Object returnValue = method.invoke(null, methodArgs);

      
      Node resultNode = factoryDocument.createElement(""checkEnvironmentExtension"");
      org.apache.xml.utils.Hashtree2Node.appendHashToNode(report, ""whichReport"", 
            resultNode, factoryDocument);

      return resultNode;
    }
    catch (Throwable t)
    {
      
      return null;
    }
  }
}
"
org.apache.xml.serializer.ToHTMLStream,28,3,0,12,104,222,1,11,17,0.855967078,2480,0.888888889,5,0.866666667,0.196296296,2,26,87.25,3,1.1429,4,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.util.Properties;

import javax.xml.transform.Result;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.Trie;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;


public class ToHTMLStream extends ToStream 
{
    
    protected BoolStack m_isRawStack = new BoolStack();

    
    private boolean m_inBlockElem = false;

    
    protected static CharInfo m_htmlcharInfo =

        CharInfo.getCharInfo(CharInfo.HTML_ENTITIES_RESOURCE);

    
    static Trie m_elementFlags = new Trie();

    static {

        
        m_elementFlags.put(""BASEFONT"", new ElemDesc(0 | ElemDesc.EMPTY));
        m_elementFlags.put(
            ""FRAME"",
            new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
        m_elementFlags.put(""FRAMESET"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""NOFRAMES"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""ISINDEX"",
            new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""APPLET"",
            new ElemDesc(0 | ElemDesc.WHITESPACESENSITIVE));
        m_elementFlags.put(""CENTER"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""DIR"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""MENU"", new ElemDesc(0 | ElemDesc.BLOCK));

        
        m_elementFlags.put(""TT"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
        m_elementFlags.put(""I"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
        m_elementFlags.put(""B"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
        m_elementFlags.put(""BIG"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
        m_elementFlags.put(""SMALL"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
        m_elementFlags.put(""EM"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(""STRONG"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(""DFN"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(""CODE"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(""SAMP"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(""KBD"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(""VAR"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(""CITE"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(""ABBR"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(""ACRONYM"", new ElemDesc(0 | ElemDesc.PHRASE));
        m_elementFlags.put(
            ""SUP"",
            new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
        m_elementFlags.put(
            ""SUB"",
            new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
        m_elementFlags.put(
            ""SPAN"",
            new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
        m_elementFlags.put(
            ""BDO"",
            new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
        m_elementFlags.put(
            ""BR"",
            new ElemDesc(
                0
                    | ElemDesc.SPECIAL
                    | ElemDesc.ASPECIAL
                    | ElemDesc.EMPTY
                    | ElemDesc.BLOCK));
        m_elementFlags.put(""BODY"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""ADDRESS"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));
        m_elementFlags.put(
            ""DIV"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));
        m_elementFlags.put(""A"", new ElemDesc(0 | ElemDesc.SPECIAL));
        m_elementFlags.put(
            ""MAP"",
            new ElemDesc(
                0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""AREA"",
            new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""LINK"",
            new ElemDesc(
                0 | ElemDesc.HEADMISC | ElemDesc.EMPTY | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""IMG"",
            new ElemDesc(
                0
                    | ElemDesc.SPECIAL
                    | ElemDesc.ASPECIAL
                    | ElemDesc.EMPTY
                    | ElemDesc.WHITESPACESENSITIVE));
        m_elementFlags.put(
            ""OBJECT"",
            new ElemDesc(
                0
                    | ElemDesc.SPECIAL
                    | ElemDesc.ASPECIAL
                    | ElemDesc.HEADMISC
                    | ElemDesc.WHITESPACESENSITIVE));
        m_elementFlags.put(""PARAM"", new ElemDesc(0 | ElemDesc.EMPTY));
        m_elementFlags.put(
            ""HR"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET
                    | ElemDesc.EMPTY));
        m_elementFlags.put(
            ""P"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));
        m_elementFlags.put(
            ""H1"",
            new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""H2"",
            new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""H3"",
            new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""H4"",
            new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""H5"",
            new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""H6"",
            new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""PRE"",
            new ElemDesc(0 | ElemDesc.PREFORMATTED | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""Q"",
            new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL));
        m_elementFlags.put(
            ""BLOCKQUOTE"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));
        m_elementFlags.put(""INS"", new ElemDesc(0));
        m_elementFlags.put(""DEL"", new ElemDesc(0));
        m_elementFlags.put(
            ""DL"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));
        m_elementFlags.put(""DT"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""DD"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""OL"",
            new ElemDesc(0 | ElemDesc.LIST | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""UL"",
            new ElemDesc(0 | ElemDesc.LIST | ElemDesc.BLOCK));
        m_elementFlags.put(""LI"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""FORM"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""LABEL"", new ElemDesc(0 | ElemDesc.FORMCTRL));
        m_elementFlags.put(
            ""INPUT"",
            new ElemDesc(
                0 | ElemDesc.FORMCTRL | ElemDesc.INLINELABEL | ElemDesc.EMPTY));
        m_elementFlags.put(
            ""SELECT"",
            new ElemDesc(0 | ElemDesc.FORMCTRL | ElemDesc.INLINELABEL));
        m_elementFlags.put(""OPTGROUP"", new ElemDesc(0));
        m_elementFlags.put(""OPTION"", new ElemDesc(0));
        m_elementFlags.put(
            ""TEXTAREA"",
            new ElemDesc(0 | ElemDesc.FORMCTRL | ElemDesc.INLINELABEL));
        m_elementFlags.put(
            ""FIELDSET"",
            new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM));
        m_elementFlags.put(""LEGEND"", new ElemDesc(0));
        m_elementFlags.put(
            ""BUTTON"",
            new ElemDesc(0 | ElemDesc.FORMCTRL | ElemDesc.INLINELABEL));
        m_elementFlags.put(
            ""TABLE"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));
        m_elementFlags.put(""CAPTION"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""THEAD"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""TFOOT"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""TBODY"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""COLGROUP"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""COL"",
            new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
        m_elementFlags.put(""TR"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(""TH"", new ElemDesc(0));
        m_elementFlags.put(""TD"", new ElemDesc(0));
        m_elementFlags.put(
            ""HEAD"",
            new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.HEADELEM));
        m_elementFlags.put(""TITLE"", new ElemDesc(0 | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""BASE"",
            new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""META"",
            new ElemDesc(
                0 | ElemDesc.HEADMISC | ElemDesc.EMPTY | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""STYLE"",
            new ElemDesc(
                0 | ElemDesc.HEADMISC | ElemDesc.RAW | ElemDesc.BLOCK));
        m_elementFlags.put(
            ""SCRIPT"",
            new ElemDesc(
                0
                    | ElemDesc.SPECIAL
                    | ElemDesc.ASPECIAL
                    | ElemDesc.HEADMISC
                    | ElemDesc.RAW));
        m_elementFlags.put(
            ""NOSCRIPT"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));
        m_elementFlags.put(""HTML"", new ElemDesc(0 | ElemDesc.BLOCK));

        
        
        
        m_elementFlags.put(""FONT"", new ElemDesc(0 | ElemDesc.FONTSTYLE));

        
        m_elementFlags.put(""S"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
        m_elementFlags.put(""STRIKE"", new ElemDesc(0 | ElemDesc.FONTSTYLE));

        
        m_elementFlags.put(""U"", new ElemDesc(0 | ElemDesc.FONTSTYLE));

        
        m_elementFlags.put(""NOBR"", new ElemDesc(0 | ElemDesc.FONTSTYLE));

        
        m_elementFlags.put(
            ""IFRAME"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));
        
        m_elementFlags.put(
            ""LAYER"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));
        m_elementFlags.put(
            ""ILAYER"",
            new ElemDesc(
                0
                    | ElemDesc.BLOCK
                    | ElemDesc.BLOCKFORM
                    | ElemDesc.BLOCKFORMFIELDSET));

        ElemDesc elemDesc;

        elemDesc = (ElemDesc) m_elementFlags.get(""AREA"");

        elemDesc.setAttr(""HREF"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""NOHREF"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""BASE"");

        elemDesc.setAttr(""HREF"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""BLOCKQUOTE"");

        elemDesc.setAttr(""CITE"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""Q"");

        elemDesc.setAttr(""CITE"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""INS"");

        elemDesc.setAttr(""CITE"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""DEL"");

        elemDesc.setAttr(""CITE"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""A"");

        elemDesc.setAttr(""HREF"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""NAME"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""LINK"");
        elemDesc.setAttr(""HREF"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""INPUT"");

        elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""USEMAP"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""CHECKED"", ElemDesc.ATTREMPTY);
        elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);
        elemDesc.setAttr(""ISMAP"", ElemDesc.ATTREMPTY);
        elemDesc.setAttr(""READONLY"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""SELECT"");

        elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);
        elemDesc.setAttr(""MULTIPLE"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""OPTGROUP"");

        elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""OPTION"");

        elemDesc.setAttr(""SELECTED"", ElemDesc.ATTREMPTY);
        elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""TEXTAREA"");

        elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);
        elemDesc.setAttr(""READONLY"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""BUTTON"");

        elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""SCRIPT"");

        elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""FOR"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""DEFER"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""IMG"");

        elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""LONGDESC"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""USEMAP"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""ISMAP"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""OBJECT"");

        elemDesc.setAttr(""CLASSID"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""CODEBASE"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""DATA"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""ARCHIVE"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""USEMAP"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""DECLARE"", ElemDesc.ATTREMPTY);

        elemDesc = (ElemDesc) m_elementFlags.get(""FORM"");

        elemDesc.setAttr(""ACTION"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""HEAD"");

        elemDesc.setAttr(""PROFILE"", ElemDesc.ATTRURL);

        
        elemDesc = (ElemDesc) m_elementFlags.get(""FRAME"");

        elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""LONGDESC"", ElemDesc.ATTRURL);

        
        elemDesc = (ElemDesc) m_elementFlags.get(""IFRAME"");

        elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
        elemDesc.setAttr(""LONGDESC"", ElemDesc.ATTRURL);

        
        elemDesc = (ElemDesc) m_elementFlags.get(""LAYER"");

        elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""ILAYER"");

        elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);

        elemDesc = (ElemDesc) m_elementFlags.get(""DIV"");

        elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
    }

    
    static private ElemDesc m_dummy = new ElemDesc(0 | ElemDesc.BLOCK);

    
    private boolean m_specialEscapeURLs = true;

    
    private boolean m_omitMetaTag = false;

    
    private ElemDesc m_elementDesc = null;

    
    public void setSpecialEscapeURLs(boolean bool)
    {
        m_specialEscapeURLs = bool;
    }

    
    public void setOmitMetaTag(boolean bool)
    {
        m_omitMetaTag = bool;
    }

    
    public void setOutputFormat(Properties format)
    {
 
        m_specialEscapeURLs =
            OutputPropertyUtils.getBooleanProperty(
                OutputPropertiesFactory.S_USE_URL_ESCAPING,
                format);

        m_omitMetaTag =
            OutputPropertyUtils.getBooleanProperty(
                OutputPropertiesFactory.S_OMIT_META_TAG,
                format);

        super.setOutputFormat(format);
    }

    
    private final boolean getSpecialEscapeURLs()
    {
        return m_specialEscapeURLs;
    }

    
    private final boolean getOmitMetaTag()
    {
        return m_omitMetaTag;
    }

    
    private final ElemDesc getElemDesc(String name)
    {

        if (null != name)
        {
            Object obj = m_elementFlags.get(name);

            if (null != obj)
                return (ElemDesc) obj;
        }

        return m_dummy;
    }

    
    public ToHTMLStream()
    {

        super();
        m_charInfo = m_htmlcharInfo;
        
        m_prefixMap = new NamespaceMappings();

    }

    
    private String m_currentElementName = null;

    
    protected void startDocumentInternal() throws org.xml.sax.SAXException
    {
        super.startDocumentInternal();

        m_needToCallStartDocument = false; 
        m_needToOutputDocTypeDecl = true;
        m_startNewLine = false;
        setOmitXMLDeclaration(true);

        if (true == m_needToOutputDocTypeDecl)
        {
            String doctypeSystem = getDoctypeSystem();
            String doctypePublic = getDoctypePublic();
            if ((null != doctypeSystem) || (null != doctypePublic))
            {
                try
                {
                m_writer.write(""<!DOCTYPE HTML"");

                if (null != doctypePublic)
                {
                    m_writer.write("" PUBLIC """");
                    m_writer.write(doctypePublic);
                    m_writer.write("""""");
                }

                if (null != doctypeSystem)
                {
                    if (null == doctypePublic)
                        m_writer.write("" SYSTEM """");
                    else
                        m_writer.write("" """");

                    m_writer.write(doctypeSystem);
                    m_writer.write("""""");
                }

                m_writer.write("">"");
                outputLineSep();
                }
                catch(IOException e)
                {
                    throw new SAXException(e);
                }
            }
        }

        m_needToOutputDocTypeDecl = false;
    }

    
    public final void endDocument() throws org.xml.sax.SAXException
    {
        
        flushPending();
        if (m_doIndent && !m_isprevtext)
        {
            try
            {
            outputLineSep();
            }
            catch(IOException e)
            {
                throw new SAXException(e);
            }
        }

        flushWriter();

        super.fireEndDoc();
    }

    
    public void startElement(
        String namespaceURI,
        String localName,
        String name,
        Attributes atts)
        throws org.xml.sax.SAXException
    {
        

        if (m_cdataTagOpen)
            closeCDATA();
        else if (m_needToCallStartDocument)
            startDocumentInternal();
            








        if (null != namespaceURI && namespaceURI.length() > 0)
        {
            super.startElement(namespaceURI, localName, name, atts);

            return;
        }

        try
        {
        boolean savedDoIndent = m_doIndent;
        boolean noLineBreak;
        if (m_startTagOpen)
        {
            closeStartTag();
            m_startTagOpen = false;
        }

        ElemDesc elemDesc = getElemDesc(name);
        
        m_elementLocalName = localName;
        m_elementURI = namespaceURI;
        m_elementName = name;
        m_elementDesc = elemDesc;
        
        
        boolean isBlockElement = elemDesc.is(ElemDesc.BLOCK);
        boolean isHeadElement = elemDesc.is(ElemDesc.HEADELEM);

        
        if (m_ispreserve)
            m_ispreserve = false;
        else if (
            m_doIndent
            && (null != m_currentElementName)
            && (!m_inBlockElem || isBlockElement) 
            )
        {
            m_startNewLine = true;

            indent();
        }

        m_inBlockElem = !isBlockElement;

        m_isRawStack.push(elemDesc.is(ElemDesc.RAW));

        m_currentElementName = name;

        
        m_writer.write('<');
        m_writer.write(name);

        if (atts != null)
            addAttributes(atts);

        
        m_startTagOpen = true;
        m_currentElemDepth++; 
        m_isprevtext = false;
        m_doIndent = savedDoIndent;

        if (isHeadElement)
        {
            if (m_startTagOpen)
                closeStartTag();

            if (!m_omitMetaTag)
            {
                if (m_doIndent)
                    indent();

                m_writer.write(""<META http-equiv=""Content-Type"" content=""text/html; charset="");

                
                String encoding = getEncoding();
                String encode = Encodings.getMimeEncoding(encoding);

                m_writer.write(encode);
                m_writer.write('""');
                m_writer.write('>');
            }
        }
        }
        catch(IOException e)
        {
            throw new SAXException(e);
        }
    }

    
    public final void endElement(
        String namespaceURI,
        String localName,
        String name)
        throws org.xml.sax.SAXException
    {
        

        if (m_cdataTagOpen)
            closeCDATA();

        if (null != namespaceURI && namespaceURI.length() > 0)
        {
            super.endElement(namespaceURI, localName, name);

            return;
        }

        m_currentElemDepth--;

        
        
        m_isRawStack.pop();

        ElemDesc elemDesc = getElemDesc(name);
        m_elementDesc = elemDesc;

        
        boolean isBlockElement = elemDesc.is(ElemDesc.BLOCK);
        boolean shouldIndent = false;

        if (m_ispreserve)
        {
            m_ispreserve = false;
        }
        else if (m_doIndent && (!m_inBlockElem || isBlockElement))
        {
            m_startNewLine = true;
            shouldIndent = true;

            
        }

        m_inBlockElem = !isBlockElement;

        try
        {
        if (!m_startTagOpen)
        {
            
            
            if (shouldIndent)
                indent();

            m_writer.write(""</"");
            m_writer.write(name);
            m_writer.write('>');

            m_currentElementName = name;

            m_cdataSectionStates.pop();
            if (!m_preserves.isEmpty())
                m_preserves.pop();
        }
        else
        {
            
            processAttributes();
            if (!elemDesc.is(ElemDesc.EMPTY))
            {
                m_writer.write('>');

                
                
                

                m_writer.write('<');
                m_writer.write('/');
                m_writer.write(name);
                m_writer.write('>');
            }
            else
            {
                m_writer.write('>');
            }

            

        }

        if (elemDesc.is(ElemDesc.WHITESPACESENSITIVE))
            m_ispreserve = true;

        
        m_startTagOpen = false;

        m_isprevtext = false;
        
        }
        catch(IOException e)
        {
            throw new SAXException(e);
        }

        
        super.fireEndElem(name);        
 
    }

    
    protected void processAttribute(
        String name,
        String value,
        ElemDesc elemDesc)
        throws IOException
    {

        m_writer.write(' ');

        if (   ((value.length() == 0) || value.equalsIgnoreCase(name))
            && elemDesc != null 
            && elemDesc.isAttrFlagSet(name, ElemDesc.ATTREMPTY))
        {
            m_writer.write(name);
        }
        else
        {
            m_writer.write(name);
            m_writer.write('=');

            m_writer.write('""');
            if (   elemDesc != null
                && elemDesc.isAttrFlagSet(name, ElemDesc.ATTRURL))
                writeAttrURI(value, m_specialEscapeURLs);
            else
                writeAttrString(value, this.getEncoding());
            m_writer.write('""');

        }
    }

    
    private boolean isASCIIDigit(char c)
    {
        return (c >= '0' && c <= '9');
    }

    
    private String makeHHString(int i)
    {
        String s = Integer.toHexString(i).toUpperCase();
        if (s.length() == 1)
        {
            s = ""0"" + s;
        }
        return s;
    }

    
    private boolean isHHSign(String str)
    {
        boolean sign = true;
        try
        {
            char r = (char) Integer.parseInt(str, 16);
        }
        catch (NumberFormatException e)
        {
            sign = false;
        }
        return sign;
    }

    
    public void writeAttrURI(String string, boolean doURLEscaping)
        throws IOException
    {
        
        
        
        
        
        
        
        
        
        
        
        
        
        

        char[] stringArray = string.toCharArray();
        int len = stringArray.length;

        for (int i = 0; i < len; i++)
        {
            char ch = stringArray[i];

            if ((ch < 32) || (ch > 126))
            {
                if (doURLEscaping)
                {
                    
                    
                    

                    
                    
                    
                    
                    
                    
                    if (ch <= 0x7F)
                    {
                        m_writer.write('%');
                        m_writer.write(makeHHString(ch));
                    }
                    else if (ch <= 0x7FF)
                    {
                        
                        
                        int high = (ch >> 6) | 0xC0;
                        int low = (ch & 0x3F) | 0x80;
                        
                        m_writer.write('%');
                        m_writer.write(makeHHString(high));
                        m_writer.write('%');
                        m_writer.write(makeHHString(low));
                    }
                    else if (isUTF16Surrogate(ch)) 
                    {
                        
                        
                        
                        
                        
                        

                        
                        int highSurrogate = ((int) ch) & 0x03FF;

                        
                        
                        
                        
                        int wwww = ((highSurrogate & 0x03C0) >> 6);
                        int uuuuu = wwww + 1;

                        
                        int zzzz = (highSurrogate & 0x003C) >> 2;

                        
                        int yyyyyy = ((highSurrogate & 0x0003) << 4) & 0x30;

                        
                        ch = stringArray[++i];

                        
                        int lowSurrogate = ((int) ch) & 0x03FF;

                        
                        yyyyyy = yyyyyy | ((lowSurrogate & 0x03C0) >> 6);

                        
                        int xxxxxx = (lowSurrogate & 0x003F);

                        int byte1 = 0xF0 | (uuuuu >> 2); 
                        int byte2 =
                            0x80 | (((uuuuu & 0x03) << 4) & 0x30) | zzzz;
                        int byte3 = 0x80 | yyyyyy;
                        int byte4 = 0x80 | xxxxxx;

                        m_writer.write('%');
                        m_writer.write(makeHHString(byte1));
                        m_writer.write('%');
                        m_writer.write(makeHHString(byte2));
                        m_writer.write('%');
                        m_writer.write(makeHHString(byte3));
                        m_writer.write('%');
                        m_writer.write(makeHHString(byte4));
                    }
                    else
                    {
                        int high = (ch >> 12) | 0xE0; 
                        int middle = ((ch & 0x0FC0) >> 6) | 0x80;
                        
                        int low = (ch & 0x3F) | 0x80;
                        
                        m_writer.write('%');
                        m_writer.write(makeHHString(high));
                        m_writer.write('%');
                        m_writer.write(makeHHString(middle));
                        m_writer.write('%');
                        m_writer.write(makeHHString(low));
                    }

                }
                else if (escapingNotNeeded(ch))
                {
                    m_writer.write(ch);
                }
                else
                {
                    m_writer.write(""&#"");
                    m_writer.write(Integer.toString(ch));
                    m_writer.write(';');
                }
            }
            else if ('%' == ch)
            {
                
                

                
                

                

                
                
                m_writer.write(ch);
                

            }
            
            
            
            else if (ch == '""')
            {
                
                if (doURLEscaping)
                    m_writer.write(""%22"");
                else
                    m_writer.write(""&quot;""); 
            }
            else
            {
                m_writer.write(ch);
            }
        }

    }

    
    public void writeAttrString(String string, String encoding)
        throws IOException
    {

        final char chars[] = string.toCharArray();
        final int strLen = chars.length;

        for (int i = 0; i < strLen; i++)
        {
            char ch = chars[i];

            
            
            
            
            if (escapingNotNeeded(ch) && (!m_charInfo.isSpecial(ch)))
            {
                m_writer.write(ch);
            }
            else if ('<' == ch || '>' == ch)
            {
                m_writer.write(ch); 
            }
            else if (
                ('&' == ch) && ((i + 1) < strLen) && ('{' == chars[i + 1]))
            {
                m_writer.write(ch); 
            }
            else
            {
                int pos = accumDefaultEntity(m_writer, ch, i, chars, strLen, false);

                if (i != pos)
                {
                    i = pos - 1;
                }
                else
                {
                    if (isUTF16Surrogate(ch))
                    {
 
                            i = writeUTF16Surrogate(ch, chars, i, strLen);

                    }

                    
                    

                    
                    String entityName = m_charInfo.getEntityNameForChar(ch);

                    if (null != entityName)
                    {
                        m_writer.write('&');
                        m_writer.write(entityName);
                        m_writer.write(';');
                    }
                    else if (escapingNotNeeded(ch))
                    {
                        m_writer.write(ch); 
                    }
                    else
                    {
                        m_writer.write(""&#"");
                        m_writer.write(Integer.toString(ch));
                        m_writer.write(';');
                    }
                }
            }
        }
    }



    
    public final void characters(char chars[], int start, int length)
        throws org.xml.sax.SAXException
    {

        if (m_isRawStack.peekOrFalse())
        {
            try
            {
                if (m_startTagOpen)
                {
                    closeStartTag();
                    m_startTagOpen = false;
                }
                m_ispreserve = true;
                





                
                
                writeNormalizedChars(chars, start, length, false);

                
                
                
                super.fireCharEvent(chars, start, length);
                
                return;
            }
            catch (IOException ioe)
            {
                throw new org.xml.sax.SAXException(
                    XMLMessages.createXMLMessage(
                        XMLErrorResources.ER_OIERROR,
                        null),
                    ioe);
                
            }
        }
        else
        {
            super.characters(chars, start, length);
        }
    }

    
    public final void cdata(char ch[], int start, int length)
        throws org.xml.sax.SAXException
    {

        if ((null != m_currentElementName)
            && (m_currentElementName.equalsIgnoreCase(""SCRIPT"")
                || m_currentElementName.equalsIgnoreCase(""STYLE"")))
        {
            try
            {
                if (m_startTagOpen)
                {
                    closeStartTag();
                    m_startTagOpen = false;
                }

                m_ispreserve = true;

                if (shouldIndent())
                    indent();

                
                writeNormalizedChars(ch, start, length, true);
            }
            catch (IOException ioe)
            {
                throw new org.xml.sax.SAXException(
                    XMLMessages.createXMLMessage(
                        XMLErrorResources.ER_OIERROR,
                        null),
                    ioe);
                
            }
        }
        else
        {
            super.cdata(ch, start, length);
        }
    }

    
    public void processingInstruction(String target, String data)
        throws org.xml.sax.SAXException
    {

		
		flushPending(); 
		
        
        
        if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
        {
            startNonEscaping();
        }
        else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
        {
            endNonEscaping();
        }
        else
        {
            try
            {
            if (m_startTagOpen)
            {
                closeStartTag();
                m_startTagOpen = false;
            }
            else if (m_needToCallStartDocument)
                startDocumentInternal();

            if (shouldIndent())
                indent();

            m_writer.write(""<?"" + target);

            if (data.length() > 0 && !Character.isSpaceChar(data.charAt(0)))
                m_writer.write("" "");

            m_writer.write(data + "">""); 

            
            
            
            if (m_currentElemDepth <= 0)
                outputLineSep();

            m_startNewLine = true;
            }
            catch(IOException e)
            {
                throw new SAXException(e);
            }
        }
               
        
        super.fireEscapingEvent(target, data);
     }

    
    public final void entityReference(String name)
        throws org.xml.sax.SAXException
    {
        try
        {

        m_writer.write(""&"");
        m_writer.write(name);
        m_writer.write("";"");
        
        } catch(IOException e)
        {
            throw new SAXException(e);
        }
    }
    
    public final void endElement(String elemName) throws SAXException
    {
        endElement(null, null, elemName);
    }

    
    public void processAttributes()
        throws IOException,SAXException
    {

        
        super.fireStartElem(m_elementName);
                
        int nAttrs = 0;
        if ((nAttrs = m_attributes.getLength()) > 0)
        {
            
            for (int i = 0; i < nAttrs; i++)
            {
                processAttribute(
                    m_attributes.getQName(i),
                    m_attributes.getValue(i),
                    m_elementDesc);
            }
            

                     
            

                     
            m_attributes.clear();

        }
    }

    
    protected void closeStartTag() throws SAXException
    {
        if (m_startTagOpen)
        {
            try
            {
                
            processAttributes();

            m_writer.write('>');

            
            pushCdataSectionState();

            m_isprevtext = false;
            m_preserves.push(m_ispreserve);
            m_startTagOpen = false;
            
            }
            catch(IOException e)
            {
                throw new SAXException(e);
            }
        }
    }
    
    protected synchronized void init(OutputStream output, Properties format)
        throws UnsupportedEncodingException
    {
        if (null == format)
        {
            format = OutputPropertiesFactory.getDefaultMethodProperties(Method.HTML);
         }
        super.init(output,format, false);
    }
    
        
        public void setOutputStream(OutputStream output)
        {

            try
            {
                Properties format;
                if (null == m_format)
                    format = OutputPropertiesFactory.getDefaultMethodProperties(Method.HTML);
                else
                    format = m_format;
                init(output, format, true);
            }
            catch (UnsupportedEncodingException uee)
            {

                
            }
        }    
        
        public void namespaceAfterStartElement(String prefix, String uri)
            throws SAXException
        {
            
            if (m_elementURI == null)
            {
                String prefix1 = getPrefixPart(m_elementName);
                if (prefix1 == null && EMPTYSTRING.equals(prefix))
                {
                    
                    
                    
                    
                    m_elementURI = uri;
                }
            }            
            startPrefixMapping(prefix,uri,false);
        }
}
"
org.apache.xpath.functions.FuncConcat,4,7,0,7,13,6,0,7,3,2.0,81,0.0,0,0.96,0.5,3,8,19.25,1,0.75,1,"
package org.apache.xpath.functions;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncConcat extends FunctionMultiArgs
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    StringBuffer sb = new StringBuffer();

    
    sb.append(m_arg0.execute(xctxt).str());
    sb.append(m_arg1.execute(xctxt).str());

    if (null != m_arg2)
      sb.append(m_arg2.execute(xctxt).str());

    if (null != m_args)
    {
      for (int i = 0; i < m_args.length; i++)
      {
        sb.append(m_args[i].execute(xctxt).str());
      }
    }

    return new XString(sb.toString());
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum < 2)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""gtone"", null));
  }
}
"
org.apache.xpath.patterns.StepPattern,31,3,2,22,78,239,11,13,26,0.733333333,1095,0.4,2,0.641975309,0.180107527,2,9,34.16129032,17,3.0645,1,"
package org.apache.xpath.patterns;

import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.axes.SubContextList;
import org.apache.xpath.compiler.PsuedoNames;
import org.apache.xpath.objects.XObject;


public class StepPattern extends NodeTest implements SubContextList, ExpressionOwner
{

  
  protected int m_axis;

  
  public StepPattern(int whatToShow, String namespace, String name, int axis,
                     int axisForPredicate)
  {

    super(whatToShow, namespace, name);

    m_axis = axis;
  }

  
  public StepPattern(int whatToShow, int axis, int axisForPredicate)
  {

    super(whatToShow);

    m_axis = axis;
  }

  
  String m_targetString;  

  
  public void calcTargetString()
  {

    int whatToShow = getWhatToShow();

    switch (whatToShow)
    {
    case DTMFilter.SHOW_COMMENT :
      m_targetString = PsuedoNames.PSEUDONAME_COMMENT;
      break;
    case DTMFilter.SHOW_TEXT :
    case DTMFilter.SHOW_CDATA_SECTION :
    case (DTMFilter.SHOW_TEXT | DTMFilter.SHOW_CDATA_SECTION) :
      m_targetString = PsuedoNames.PSEUDONAME_TEXT;
      break;
    case DTMFilter.SHOW_ALL :
      m_targetString = PsuedoNames.PSEUDONAME_ANY;
      break;
    case DTMFilter.SHOW_DOCUMENT :
    case DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT :
      m_targetString = PsuedoNames.PSEUDONAME_ROOT;
      break;
    case DTMFilter.SHOW_ELEMENT :
      if (this.WILD == m_name)
        m_targetString = PsuedoNames.PSEUDONAME_ANY;
      else
        m_targetString = m_name;
      break;
    default :
      m_targetString = PsuedoNames.PSEUDONAME_ANY;
      break;
    }
  }

  
  public String getTargetString()
  {
    return m_targetString;
  }

  
  StepPattern m_relativePathPattern;

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {

    super.fixupVariables(vars, globalsSize);

    if (null != m_predicates)
    {
      for (int i = 0; i < m_predicates.length; i++)
      {
        m_predicates[i].fixupVariables(vars, globalsSize);
      }
    }

    if (null != m_relativePathPattern)
    {
      m_relativePathPattern.fixupVariables(vars, globalsSize);
    }
  }

  
  public void setRelativePathPattern(StepPattern expr)
  {

    m_relativePathPattern = expr;
    expr.exprSetParent(this);

    calcScore();
  }

  
  public StepPattern getRelativePathPattern()
  {
    return m_relativePathPattern;
  }

  
  
  
  
  
  
  
  

  
  public Expression[] getPredicates()
  {
    return m_predicates;
  }

  
  Expression[] m_predicates;

  
  public boolean canTraverseOutsideSubtree()
  {

    int n = getPredicateCount();

    for (int i = 0; i < n; i++)
    {
      if (getPredicate(i).canTraverseOutsideSubtree())
        return true;
    }

    return false;
  }

  
  public Expression getPredicate(int i)
  {
    return m_predicates[i];
  }

  
  public final int getPredicateCount()
  {
    return (null == m_predicates) ? 0 : m_predicates.length;
  }

  
  public void setPredicates(Expression[] predicates)
  {

    m_predicates = predicates;
    if(null != predicates)
    {
    	for(int i = 0; i < predicates.length; i++)
    	{
    		predicates[i].exprSetParent(this);
    	}
    }

    calcScore();
  }

  
  public void calcScore()
  {

    if ((getPredicateCount() > 0) || (null != m_relativePathPattern))
    {
      m_score = SCORE_OTHER;
    }
    else
      super.calcScore();

    if (null == m_targetString)
      calcTargetString();
  }

  
  public XObject execute(XPathContext xctxt, int currentNode)
          throws javax.xml.transform.TransformerException
  {

    DTM dtm = xctxt.getDTM(currentNode);

    if (dtm != null)
    {
      int expType = dtm.getExpandedTypeID(currentNode);

      return execute(xctxt, currentNode, dtm, expType);
    }

    return NodeTest.SCORE_NONE;
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return execute(xctxt, xctxt.getCurrentNode());
  }

  
  public XObject execute(
          XPathContext xctxt, int currentNode, DTM dtm, int expType)
            throws javax.xml.transform.TransformerException
  {

    if (m_whatToShow == NodeTest.SHOW_BYFUNCTION)
    {
      if (null != m_relativePathPattern)
      {
        return m_relativePathPattern.execute(xctxt);
      }
      else
        return NodeTest.SCORE_NONE;
    }

    XObject score;

    score = super.execute(xctxt, currentNode, dtm, expType);

    if (score == NodeTest.SCORE_NONE)
      return NodeTest.SCORE_NONE;

    if (getPredicateCount() != 0)
    {
      if (!executePredicates(xctxt, dtm, currentNode))
        return NodeTest.SCORE_NONE;
    }

    if (null != m_relativePathPattern)
      return m_relativePathPattern.executeRelativePathPattern(xctxt, dtm,
              currentNode);

    return score;
  }

  
  private final boolean checkProximityPosition(XPathContext xctxt,
          int predPos, DTM dtm, int context, int pos)
  {

    try
    {
      DTMAxisTraverser traverser =
        dtm.getAxisTraverser(Axis.PRECEDINGSIBLING);

      for (int child = traverser.first(context); DTM.NULL != child;
              child = traverser.next(context, child))
      {
        try
        {
          xctxt.pushCurrentNode(child);

          if (NodeTest.SCORE_NONE != super.execute(xctxt, child))
          {
            boolean pass = true;

            try
            {
              xctxt.pushSubContextList(this);

              for (int i = 0; i < predPos; i++)
              {
                xctxt.pushPredicatePos(i);
                try
                {
                  XObject pred = m_predicates[i].execute(xctxt);
                  
                  try
                  {
                    if (XObject.CLASS_NUMBER == pred.getType())
                    {
                      throw new Error(""Why: Should never have been called"");
                    }
                    else if (!pred.boolWithSideEffects())
                    {
                      pass = false;
    
                      break;
                    }
                  }
                  finally
                  {
                    pred.detach();
                  }
                }
                finally
                {
                  xctxt.popPredicatePos();
                }
              }
            }
            finally
            {
              xctxt.popSubContextList();
            }

            if (pass)
              pos--;

            if (pos < 1)
              return false;
          }
        }
        finally
        {
          xctxt.popCurrentNode();
        }
      }
    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new java.lang.RuntimeException(se.getMessage());
    }

    return (pos == 1);
  }

  
  private final int getProximityPosition(XPathContext xctxt, int predPos, 
                    boolean findLast)
  {

    int pos = 0;
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    int parent = dtm.getParent(context);

    try
    {
      DTMAxisTraverser traverser = dtm.getAxisTraverser(Axis.CHILD);

      for (int child = traverser.first(parent); DTM.NULL != child;
              child = traverser.next(parent, child))
      {
        try
        {
          xctxt.pushCurrentNode(child);

          if (NodeTest.SCORE_NONE != super.execute(xctxt, child))
          {
            boolean pass = true;

            try
            {
              xctxt.pushSubContextList(this);

              for (int i = 0; i < predPos; i++)
              {
                xctxt.pushPredicatePos(i);
                try
                {
                  XObject pred = m_predicates[i].execute(xctxt);
  
                  try
                  {
                    if (XObject.CLASS_NUMBER == pred.getType())
                    {
                      if ((pos + 1) != (int) pred.numWithSideEffects())
                      {
                        pass = false;
    
                        break;
                      }
                    }
                    else if (!pred.boolWithSideEffects())
                    {
                      pass = false;
    
                      break;
                    }
                  }
                  finally
                  {
                    pred.detach();
                  }
                }
                finally
                {
                  xctxt.popPredicatePos();
                }
              }
            }
            finally
            {
              xctxt.popSubContextList();
            }

            if (pass)
              pos++;

            if (!findLast && child == context)
            {
              return pos;
            }
          }
        }
        finally
        {
          xctxt.popCurrentNode();
        }
      }
    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new java.lang.RuntimeException(se.getMessage());
    }

    return pos;
  }

  
  public int getProximityPosition(XPathContext xctxt)
  {
    return getProximityPosition(xctxt, xctxt.getPredicatePos(), false);
  }
  
  
  public int getLastPos(XPathContext xctxt)
  {
    return getProximityPosition(xctxt, xctxt.getPredicatePos(), true);
  }

  
  protected final XObject executeRelativePathPattern(
          XPathContext xctxt, DTM dtm, int currentNode)
            throws javax.xml.transform.TransformerException
  {

    XObject score = NodeTest.SCORE_NONE;
    int context = currentNode;
    DTMAxisTraverser traverser;

    traverser = dtm.getAxisTraverser(m_axis);

    for (int relative = traverser.first(context); DTM.NULL != relative;
            relative = traverser.next(context, relative))
    {
      try
      {
        xctxt.pushCurrentNode(relative);

        score = execute(xctxt);

        if (score != NodeTest.SCORE_NONE)
          break;
      }
      finally
      {
        xctxt.popCurrentNode();
      }
    }

    return score;
  }

  
  protected final boolean executePredicates(
          XPathContext xctxt, DTM dtm, int currentNode)
            throws javax.xml.transform.TransformerException
  {

    boolean result = true;
    boolean positionAlreadySeen = false;
    int n = getPredicateCount();

    try
    {
      xctxt.pushSubContextList(this);

      for (int i = 0; i < n; i++)
      {
        xctxt.pushPredicatePos(i);

        try
        {
          XObject pred = m_predicates[i].execute(xctxt);

          try
          {
            if (XObject.CLASS_NUMBER == pred.getType())
            {
              int pos = (int) pred.num();
  
              if (positionAlreadySeen)
              {
                result = (pos == 1);
  
                break;
              }
              else
              {
                positionAlreadySeen = true;
  
                if (!checkProximityPosition(xctxt, i, dtm, currentNode, pos))
                {
                  result = false;
  
                  break;
                }
              }
            
            }
            else if (!pred.boolWithSideEffects())
            {
              result = false;
  
              break;
            }
          }
          finally
          {
            pred.detach();
          }
        }
        finally
        {
          xctxt.popPredicatePos();
        }
      }
    }
    finally
    {
      xctxt.popSubContextList();
    }

    return result;
  }

  
  public String toString()
  {

    StringBuffer buf = new StringBuffer();

    for (StepPattern pat = this; pat != null; pat = pat.m_relativePathPattern)
    {
      if (pat != this)
        buf.append(""/"");

      buf.append(Axis.names[pat.m_axis]);
      buf.append(""::"");

      if (0x000005000 == pat.m_whatToShow)
      {
        buf.append(""doc()"");
      }
      else if (DTMFilter.SHOW_BYFUNCTION == pat.m_whatToShow)
      {
        buf.append(""function()"");
      }
      else if (DTMFilter.SHOW_ALL == pat.m_whatToShow)
      {
        buf.append(""node()"");
      }
      else if (DTMFilter.SHOW_TEXT == pat.m_whatToShow)
      {
        buf.append(""text()"");
      }
      else if (DTMFilter.SHOW_PROCESSING_INSTRUCTION == pat.m_whatToShow)
      {
        buf.append(""processing-instruction("");

        if (null != pat.m_name)
        {
          buf.append(pat.m_name);
        }

        buf.append("")"");
      }
      else if (DTMFilter.SHOW_COMMENT == pat.m_whatToShow)
      {
        buf.append(""comment()"");
      }
      else if (null != pat.m_name)
      {
        if (DTMFilter.SHOW_ATTRIBUTE == pat.m_whatToShow)
        {
          buf.append(""@"");
        }

        if (null != pat.m_namespace)
        {
          buf.append(""{"");
          buf.append(pat.m_namespace);
          buf.append(""}"");
        }

        buf.append(pat.m_name);
      }
      else if (DTMFilter.SHOW_ATTRIBUTE == pat.m_whatToShow)
      {
        buf.append(""@"");
      }
      else if ((DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT)
               == pat.m_whatToShow)
      {
        buf.append(""doc-root()"");
      }
      else
      {
        buf.append(""?"" + Integer.toHexString(pat.m_whatToShow));
      }

      if (null != pat.m_predicates)
      {
        for (int i = 0; i < pat.m_predicates.length; i++)
        {
          buf.append(""["");
          buf.append(pat.m_predicates[i]);
          buf.append(""]"");
        }
      }
    }

    return buf.toString();
  }

  
  private static final boolean DEBUG_MATCHES = false;

  
  public double getMatchScore(XPathContext xctxt, int context)
          throws javax.xml.transform.TransformerException
  {

    xctxt.pushCurrentNode(context);
    xctxt.pushCurrentExpressionNode(context);

    try
    {
      XObject score = execute(xctxt);

      return score.num();
    }
    finally
    {
      xctxt.popCurrentNode();
      xctxt.popCurrentExpressionNode();
    }

    
  }

  
  public void setAxis(int axis)
  {
    m_axis = axis;
  }

  
  public int getAxis()
  {
    return m_axis;
  }
  
  class PredOwner implements ExpressionOwner
  {
  	int m_index;
  	
  	PredOwner(int index)
  	{
  		m_index = index;
  	}
  	
    
    public Expression getExpression()
    {
      return m_predicates[m_index];
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(StepPattern.this);
    	m_predicates[m_index] = exp;
    }
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	 	if(visitor.visitMatchPattern(owner, this))
  	 	{
  	 		callSubtreeVisitors(visitor);
  	 	}
  }

  
  protected void callSubtreeVisitors(XPathVisitor visitor)
  {
    if (null != m_predicates)
    {
      int n = m_predicates.length;
      for (int i = 0; i < n; i++)
      {
        ExpressionOwner predOwner = new PredOwner(i);
        if (visitor.visitPredicate(predOwner, m_predicates[i]))
        {
          m_predicates[i].callVisitors(predOwner, visitor);
        }
      }
    }
    if (null != m_relativePathPattern)
    {
      m_relativePathPattern.callVisitors(this, visitor);
    }
  }


  
  public Expression getExpression()
  {
    return m_relativePathPattern;
  }

  
  public void setExpression(Expression exp)
  {
    exp.exprSetParent(this);
  	m_relativePathPattern = (StepPattern)exp;
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	StepPattern sp = (StepPattern)expr;
  	
    if (null != m_predicates)
    {
        int n = m_predicates.length;
        if ((null == sp.m_predicates) || (sp.m_predicates.length != n))
              return false;
        for (int i = 0; i < n; i++)
        {
          if (!m_predicates[i].deepEquals(sp.m_predicates[i]))
          	return false; 
        }
    }
    else if (null != sp.m_predicates)
    	return false;
  		
  	if(null != m_relativePathPattern)
  	{
  		if(!m_relativePathPattern.deepEquals(sp.m_relativePathPattern))
  			return false;
  	}
  	else if(sp.m_relativePathPattern != null)
  		return false;
  		
  	return true;
  }


}
"
org.apache.xalan.transformer.TransformSnapshot,0,1,0,2,0,0,2,0,0,2.0,0,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"
package org.apache.xalan.transformer;


public interface TransformSnapshot
{

}"
org.apache.xpath.functions.FunctionDef1Arg,8,4,9,18,21,8,9,9,4,2.0,110,0.0,0,0.872727273,0.5,2,5,12.75,2,1.125,1,"
package org.apache.xpath.functions;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XString;
import org.apache.xpath.res.XPATHErrorResources;


public class FunctionDef1Arg extends FunctionOneArg
{

  
  protected int getArg0AsNode(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (null == m_arg0)
           ? xctxt.getCurrentNode() : m_arg0.asNode(xctxt);
  }
  
  
  public boolean Arg0IsNodesetExpr()
  {
    return (null == m_arg0) ? true : m_arg0.isNodesetExpr();
  }

  
  protected XMLString getArg0AsString(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    if(null == m_arg0)
    {
      int currentNode = xctxt.getCurrentNode();
      if(DTM.NULL == currentNode)
        return XString.EMPTYSTRING;
      else
      {
        DTM dtm = xctxt.getDTM(currentNode);
        return dtm.getStringValue(currentNode);
      }
      
    }
    else
      return m_arg0.execute(xctxt).xstr();   
  }

  
  protected double getArg0AsNumber(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    if(null == m_arg0)
    {
      int currentNode = xctxt.getCurrentNode();
      if(DTM.NULL == currentNode)
        return 0;
      else
      {
        DTM dtm = xctxt.getDTM(currentNode);
        XMLString str = dtm.getStringValue(currentNode);
        return str.toDouble();
      }
      
    }
    else
      return m_arg0.execute(xctxt).num();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum > 1)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_ZERO_OR_ONE, null)); 
  }

  
  public boolean canTraverseOutsideSubtree()
  {
    return (null == m_arg0) ? false : super.canTraverseOutsideSubtree();
  }
}
"
org.apache.xalan.res.XSLTErrorResources_zh_CN,3,4,0,1,4,1,0,1,2,1.423076923,3769,0.0,0,0.976190476,1.0,0,0,1251.0,1,0.3333,0,"
package org.apache.xalan.res;



public class XSLTErrorResources_zh_CN extends XSLTErrorResources
{

  
  public static final int MAX_CODE = 201;
  
  
  public static final int MAX_WARNING = 29;
  
  
  public static final int MAX_OTHERS = 55;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  

  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_NO_CURLYBRACE,
      ""错误：表达式中不能出现  '{'""},


  
  


  {
    ER_ILLEGAL_ATTRIBUTE, ""{0} 存在一个非法属性： {1}""},


  
  


  {
    ER_NULL_SOURCENODE_APPLYIMPORTS,
      ""sourceNode 在  xsl:apply-imports 为空！  ""},


  
  


  {
    ER_CANNOT_ADD, ""无法将  {0} 添加到  {1} 中 ""},


  
  


  {
    ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES,
      ""sourceNode 在  handleApplyTemplatesInstruction 为空！ ""},


  
  


  {
    ER_NO_NAME_ATTRIB, ""{0} 必须具有一个名称属性。 ""},


  
  


  {
    ER_TEMPLATE_NOT_FOUND, ""未找到命名的模板： {0}""},


  
  


  {
    ER_CANT_RESOLVE_NAME_AVT,
      ""无法在  xsl:call-template 解析名称  AVI。 ""},


  
  


  {
    ER_REQUIRES_ATTRIB, ""{0} 要求属性： {1}""},


  
  


  {
    ER_MUST_HAVE_TEST_ATTRIB,
      ""{0} 必须具有一个  ''test'' 属性。 ""},


  
  


  {
    ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""在级别属性中出现错误数值： {0}""},


  
  


  {
    ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""processing-instruction 名称不能为  'xml'""},


  
  


  {
    ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""processing-instruction 名称必须是一个有效的  NCName： {0}""},


  
  


  {
    ER_NEED_MATCH_ATTRIB,
      ""{0} 必须具有一个与模式相匹配的属性。 ""},


  
  


  {
    ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0} 需要一个名称或匹配属性。 ""},


  
  


  {
    ER_CANT_RESOLVE_NSPREFIX,
      ""无法解析名称空间前缀： {0}""},


  
  


  {
    ER_ILLEGAL_VALUE, ""xml:space 存在一个非法数值： {0}""},


  
  


  {
    ER_NO_OWNERDOC,
      ""子节点没有一个属主文档！ ""},


  
  


  {
    ER_ELEMTEMPLATEELEM_ERR, ""ElemTemplateElement 错误： {0}""},


  
  


  {
    ER_NULL_CHILD, ""正在尝试添加一个空的子节点！ ""},


  
  


  {
    ER_NEED_SELECT_ATTRIB, ""{0} 需要一个选择属性。 ""},


  
  


  {
    ER_NEED_TEST_ATTRIB,
      ""xsl:when 必须具有一个  'test' 属性。 ""},


  
  


  {
    ER_NEED_NAME_ATTRIB,
      ""xsl:with-param 必须具有一个  'name' 属性。 ""},


  
  


  {
    ER_NO_CONTEXT_OWNERDOC,
      ""上下文没有一个属主文档！ ""},


  
  


  {
    ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""无法创建  XML TransformerFactory Liaison： {0}""},


  
  


  {
    ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: 运行不成功。 ""},


  
  


  {
    ER_NOT_SUCCESSFUL, ""Xalan: 不成功。 ""},


  
  


  {
    ER_ENCODING_NOT_SUPPORTED, ""不受支持的编码： {0}""},


  
  


  {
    ER_COULD_NOT_CREATE_TRACELISTENER,
      ""无法创建  TraceListener： {0}""},


  
  


  {
    ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key 需要一个  'name' 属性！ ""},


  
  


  {
    ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key 需要一个  'match' 属性！ ""},


  
  


  {
    ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key 需要一个  'use' 属性！ ""},


  
  


  {
    ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0} 需要一个  ''elements'' 属性！ ""},


  
  


  {
    ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} 缺少  ''prefix'' 属性 ""},


  
  


  {
    ER_BAD_STYLESHEET_URL, ""式样表单的  URL 错误： {0}""},


  
  


  {
    ER_FILE_NOT_FOUND, ""未找到式样表单文件： {0}""},


  
  


  {
    ER_IOEXCEPTION,
      ""式样表单文件中存在  IO 异常： {0}""},


  
  


  {
    ER_NO_HREF_ATTRIB,
      ""(StylesheetHandler) 无法在  {0} 中找到  href 属性  ""},


  
  


  {
    ER_STYLESHEET_INCLUDES_ITSELF,
      ""(StylesheetHandler) {0} 直接或间接包含自身！ ""},


  
  


  {
    ER_PROCESSINCLUDE_ERROR,
      ""StylesheetHandler.processInclude 错误， {0}""},


  
  


  {
    ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} 缺少  ''lang'' 属性 ""},


  
  


  {
    ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) 将  {0} 元素放错位置？？ container 缺少  ''component'' 元素  ""},


  
  


  {
    ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
      ""仅能输出到  Element、 DocumentFragment、 Document 或  PrintWriter。 ""},


  
  


  {
    ER_PROCESS_ERROR, ""StylesheetRoot.process 错误 ""},


  
  


  {
    ER_UNIMPLNODE_ERROR, ""UnImplNode 错误： {0}""},


  
  


  {
    ER_NO_SELECT_EXPRESSION,
      ""错误！未找到  xpath 选择表达式  (-select)。 ""},


  
  


  {
    ER_CANNOT_SERIALIZE_XSLPROCESSOR,
      ""无法串行化一个  XSLProcessor！ ""},


  
  


  {
    ER_NO_INPUT_STYLESHEET,
      ""未指定式样表单输入！ ""},


  
  


  {
    ER_FAILED_PROCESS_STYLESHEET,
      ""运行式样表单错误！ ""},


  
  


  {
    ER_COULDNT_PARSE_DOC, ""无法分析  {0} 文档！ ""},


  
  


  {
    ER_COULDNT_FIND_FRAGMENT, ""未找到段： {0}""},


  
  


  {
    ER_NODE_NOT_ELEMENT,
      ""段标识符指向的节点不是一个元素： {0}""},


  
  


  {
    ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""每个节点必须具有一个匹配或名称属性 ""},


  
  


  {
    ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB,
      ""模板必须具有一个匹配或名称属性 ""},


  
  


  {
    ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""无法复制文档框架！ ""},


  
  


  {
    ER_CANT_CREATE_ITEM,
      ""无法在结果树中创建项： {0}""},


  
  


  {
    ER_XMLSPACE_ILLEGAL_VALUE,
      ""xml:space 在源  XML 中存在一个非法数值： {0}""},


  
  


  {
    ER_NO_XSLKEY_DECLARATION,
      ""在  {0} 中未声明  xsl:key！ ""},


  
  


  {
    ER_CANT_CREATE_URL, ""错误！无法在以下的  {0} 中创建  url： ""},


  
  


  {
    ER_XSLFUNCTIONS_UNSUPPORTED, ""不支持  xsl:functions""},


  
  


  {
    ER_PROCESSOR_ERROR, ""XSLT TransformerFactory 错误 ""},


  
  


  {
    ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""不允许  (StylesheetHandler) {0} 在  stylesheet 的内部！ ""},


  
  


  {
    ER_RESULTNS_NOT_SUPPORTED,
      ""不再支持  result-ns！请使用  xsl:output 替换。 ""},


  
  


  {
    ER_DEFAULTSPACE_NOT_SUPPORTED,
      ""不再支持  default-space！请使用  xsl:strip-space 或  xsl:preserve-space 替换。 ""},


  
  


  {
    ER_INDENTRESULT_NOT_SUPPORTED,
      ""不再支持  indent-result！请使用  xsl:output 替换。 ""},


  
  


  {
    ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0} 存在一个非法属性： {1}""},


  
  


  {
    ER_UNKNOWN_XSL_ELEM, ""未知的  XSL 元素： {0}""},


  
  


  {
    ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort 仅能与  xsl:apply-templates 或  xsl:for-each 一起使用。 ""},


  
  


  {
    ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) 将  xsl:when 放错位置！ ""},


  
  


  {
    ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:when 不是  xsl:choose 的父辈！ ""},


  
  


  {
    ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) 将  xsl:otherwise 放错位置！ ""},


  
  


  {
    ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:otherwise 不是  xsl:choose 的父辈！ ""},


  
  


  {
    ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""不允许  (StylesheetHandler) {0} 在模板的内部！ ""},


  
  


  {
    ER_UNKNOWN_EXT_NS_PREFIX,
      ""(StylesheetHandler) {0} 扩展名称空间前缀  {1} 未知 ""},


  
  


  {
    ER_IMPORTS_AS_FIRST_ELEM,
      ""(StylesheetHandler) 导入仅能在式样表单中作为第一个元素出现！ ""},


  
  


  {
    ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0} 直接或间接输入自身！ ""},


  
  


  {
    ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space 存在一个非法数值： {0}""},


  
  


  {
    ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""processStylesheet 不成功！ ""},


  
  


  {
    ER_SAX_EXCEPTION, ""SAX 异常 ""},


  
  


  {
    ER_XSLT_ERROR, ""XSLT 错误 ""},


  
  


  {
    ER_CURRENCY_SIGN_ILLEGAL,
      ""在格式模式字符串中不允许出现货币符号 ""},


  
  


  {
    ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""在  Stylesheet DOM 中不支持文档函数！ ""},


  
  


  {
    ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""无法分析无前缀分析器的前缀！ ""},


  
  


  {
    ER_REDIRECT_COULDNT_GET_FILENAME,
      ""重定向扩展：无法得到文件  - 文件或选择属性必须返回有效的字符串。 ""},


  
  


  {
    ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""无法在重定向扩展中构建  FormatterListener！ ""},


  
  


  {
    ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""在  exclude-result-prefixes 中的前缀不是有效的： {0}""},


  
  


  {
    ER_MISSING_NS_URI,
      ""在指定的前缀中缺少  URI 的名称空间 ""},


  
  


  {
    ER_MISSING_ARG_FOR_OPTION,
      ""在选项  {0} 中缺少参数： ""},


  
  


  {
    ER_INVALID_OPTION, ""无效的选项： {0}""},


  
  


  {
    ER_MALFORMED_FORMAT_STRING, ""格式不正确的字符串： {0}""},


  
  


  {
    ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet 需要一个  'version' 属性！ ""},


  
  


  {
    ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""属性： {0} 存在一个非法数值： {1}""},


  
  


  {
    ER_CHOOSE_REQUIRES_WHEN, ""xsl:choose 需要  xsl:when""},


  
  


  {
    ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""不允许在  xls:for-each 中出现  xsl:apply-imports""},


  
  


  {
    ER_CANT_USE_DTM_FOR_OUTPUT,
      ""无法为一个输出  DOM 节点使用  DTMLiaison...传送一个  org.apache.xpath.DOM2Helper！  ""},


  
  


  {
    ER_CANT_USE_DTM_FOR_INPUT,
      ""无法为输入  DOM 节点使用  DTMLiaison...传送一个  org.apache.xpath.DOM2Helper！ ""},


  
  


  {
    ER_CALL_TO_EXT_FAILED,
      ""调用扩展元素错误： {0}""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""必须将前缀解析为名称空间： {0}""},


  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""检测到无效的  UTF-16 代理： {0}？  ""},


  
  


  {
    ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0} 被自身使用，将导致无限循环。  ""},


  
  


  {
    ER_CANNOT_MIX_XERCESDOM,
      ""非  Xerces-DOM 输入与  Xerces-DOM 输出不能混合使用！ ""},


  
  


  {
    ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},


  
  


  {
    ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""在  ElemTemplateElement.readObject 中： {0}""},


  
  


  {
    ER_DUPLICATE_NAMED_TEMPLATE,
      ""找到多个命名的模板： {0}""},


  
  


  {
    ER_INVALID_KEY_CALL,
      ""无效的函数调用：不允许调用递归关键词 ()""},

  
  
  


  {
    ER_REFERENCING_ITSELF,
      ""变量  {0} 正在直接或间接地引用自身！ ""},

  
  
  


  {
    ER_ILLEGAL_DOMSOURCE_INPUT,
      ""在  newTemplate 的  DOMSource 中，输入节点不能为空！  ""},

	
	
  


  {
    ER_CLASS_NOT_FOUND_FOR_OPTION,
			""在选项中未找到类文件 {0}""},

	
	
  


  {
    ER_REQUIRED_ELEM_NOT_FOUND,
			""未找到需要的元素： {0}""},

  
  
  


  {
    ER_INPUT_CANNOT_BE_NULL,
			""InputStream 不能为空 ""},

  
  
  


  {
    ER_URI_CANNOT_BE_NULL,
			""URI 不能为空 ""},

  
  
  


  {
    ER_FILE_CANNOT_BE_NULL,
			""File 不能为空 ""},

  
   
  


  {
    ER_SOURCE_CANNOT_BE_NULL,
			""InputSource 不能为空 ""},

  
  
  


  {
    ER_CANNOT_INIT_BSFMGR,
			""无法初始化  BSF 管理器 ""},

  
  
  


  {
    ER_CANNOT_CMPL_EXTENSN,
			""无法编译扩展名 ""},

  
  
  


  {
    ER_CANNOT_CREATE_EXTENSN,
      ""由于以下原因： {1}，无法创建扩展名： {0}""},

  
  
  


  {
    ER_INSTANCE_MTHD_CALL_REQUIRES,
      "" Instance 调用方法  {0} 时需要将对象实例作为第一个参数。 ""},

  
  
  


  {
    ER_INVALID_ELEMENT_NAME,
      ""指定了无效的元素名称  {0}""},

  
   
  


  {
    ER_ELEMENT_NAME_METHOD_STATIC,
      ""元素名称方法必须是静态的  {0}""},

  
   
  


  {
    ER_EXTENSION_FUNC_UNKNOWN,
             ""扩展函数  {0}： {1} 未知 ""},

  
   
  


  {
    ER_MORE_MATCH_CONSTRUCTOR,
             ""适用于  {0} 的构造器的多个最佳匹配  ""},

  
   
  


  {
    ER_MORE_MATCH_METHOD,
             ""适用于方法  {0} 的多个最佳匹配 ""},

  
   
  


  {
    ER_MORE_MATCH_ELEMENT,
             ""适用于元素方法  {0} 的多个最佳匹配 ""},

  
   
  


  {
    ER_INVALID_CONTEXT_PASSED,
             ""传送无效的上下文来求值  {0}""},

  
   
  


  {
    ER_POOL_EXISTS,
             ""池已存在 ""},

  
   
  


  {
    ER_NO_DRIVER_NAME,
             ""未指定驱动器名称 ""},

  
   
  


  {
    ER_NO_URL,
             ""未指定  URL""},

  
   
  


  {
    ER_POOL_SIZE_LESSTHAN_ONE,
             ""池的数量不足一个！ ""},

  
   
  


  {
    ER_INVALID_DRIVER,
             ""指定了无效的驱动程序名称！ ""},

  
   
  


  {
    ER_NO_STYLESHEETROOT,
             ""未找到式样表单的源位置！ ""},

  
   
  


  {
    ER_ILLEGAL_XMLSPACE_VALUE,
         ""在  xml:space 中出现非法数值 ""},

  
   
  


  {
    ER_PROCESSFROMNODE_FAILED,
         ""processFromNode 失败 ""},

  
   
  


  {
    ER_RESOURCE_COULD_NOT_LOAD,
        ""[ {0} ] 资源无法装入： {1} 
 {2} 	 {3}""},

   
  
   
  


  {
    ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""缓冲区大小  <=0""},

  
   
  


  {
    ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""调用扩展时出现未知错误 ""},

  
   
  


  {
    ER_NO_NAMESPACE_DECL,
        ""前缀  {0} 未声明相应的名称空间 ""},

  
   
  


  {
    ER_ELEM_CONTENT_NOT_ALLOWED,
        ""在  lang=javaclass {0} 中不允许出现元素内容 ""},
   
  
   
  


  {
    ER_STYLESHEET_DIRECTED_TERMINATION,
        ""指导式样表单终止 ""},

  
   
  


  {
    ER_ONE_OR_TWO,
        ""1 或  2""},

  
   
  


  {
    ER_TWO_OR_THREE,
        ""2 或  3""},

  
   
  


  {
    ER_COULD_NOT_LOAD_RESOURCE,
        ""无法装入  {0}（检查  CLASSPATH），正在使用缺省值 ""},

  
   
  


  {
    ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""无法初始化缺省模板 ""},

  
   
  


  {
    ER_RESULT_NULL,
        ""结果不应为空 ""},

    
   
  


  {
    ER_RESULT_COULD_NOT_BE_SET,
        ""无法设置结果 ""},

  
   
  


  {
    ER_NO_OUTPUT_SPECIFIED,
        ""未指定输出 ""},

  
   
  


  {
    ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""无法变换到一个类型的结果中  {0}""},

  
   
  


  {
    ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""无法变换一个类型源  {0}""},

  
   
  


  {
    ER_NULL_CONTENT_HANDLER,
        ""空的内容句柄 ""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""空的错误句柄 ""},

  
   
  


  {
    ER_CANNOT_CALL_PARSE,
        ""如果未设置  ContentHandler，则无法调用解析 ""},

  
   
  


  {
    ER_NO_PARENT_FOR_FILTER,
        ""在过滤器中无父辈 ""},

  
  
   
  


  {
    ER_NO_STYLESHEET_IN_MEDIA,
         ""在  {0}， media= {1} 中未找到式样表单  ""},

  
   
  


  {
    ER_NO_STYLESHEET_PI,
         ""在  {0} 中未找到  xml-stylesheet PI：  ""},

  
   
  


  {
    ER_NOT_SUPPORTED,
       ""不支持： {0}""},

  
   
  


  {
    ER_PROPERTY_VALUE_BOOLEAN,
       ""属性值  {0} 应当是一个布尔实例 ""},

  
   
  


  {
    ER_COULD_NOT_FIND_EXTERN_SCRIPT,
       ""无法在  {0} 中到达外部脚本 ""},

  
  
  


  {
    ER_RESOURCE_COULD_NOT_FIND,
        ""未找到  [ {0} ] 资源。 
 {1}""},

  
   
  


  {
    ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""无法识别输出属性： {0}""},

  
   
  


  {
    ER_FAILED_CREATING_ELEMLITRSLT,
        ""创建  ElemLiteralResult 实例失败 ""},
  
  
   
   
   
   

   
  


  {
    ER_VALUE_SHOULD_BE_NUMBER,
        ""{0} 的值应该包含可分析的数字 ""},

  
   
  


  {
    ER_VALUE_SHOULD_EQUAL,
        ""{0} 的值应当是“是”或“非” ""},

 
   
  


  {
    ER_FAILED_CALLING_METHOD,
        ""调用  {0} 方法失败 ""},

  
   
  


  {
    ER_FAILED_CREATING_ELEMTMPL,
        ""创建  ElemTemplateElement 实例失败 ""},

  
   
  


  {
    ER_CHARS_NOT_ALLOWED,
        ""在文档此处不允许出现字符 ""},

  
  
  


  {
    ER_ATTR_NOT_ALLOWED,
        """"{0}"" 属性不允许在  {1} 元素中出现！  ""},

 
  
  


  {
    ER_BAD_VALUE,
     ""{0} 错误数值  {1} ""},

  
  
  


  {
    ER_ATTRIB_VALUE_NOT_FOUND,
     ""未找到  {0} 属性值 ""},

  
  
  


  {
    ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""无法识别  {0} 属性值 ""},

  
  
  


  {
    ER_NULL_URI_NAMESPACE,
     ""试图用空  URI 生成名称空间前缀 ""},
    

  
  
  
  


  {
    ER_NUMBER_TOO_BIG,
     ""试图格式化一个超过最大长整型整数的数 ""},




  


  {
    ER_CANNOT_FIND_SAX1_DRIVER,
     ""找不到  SAX1 驱动程序类  {0}""},



  


  {
    ER_SAX1_DRIVER_NOT_LOADED,
     ""找到  SAX1 驱动程序类  {0} 但无法加载 ""},



  


  {
    ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""加载了  SAX1 驱动程序类  {0} 但无法实例化 ""},




  


  {
    ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
     ""SAX1 驱动程序类  {0} 无法实现  org.xml.sax.Parser""},



  


  {
    ER_PARSER_PROPERTY_NOT_SPECIFIED,
     ""未指定系统特性  org.xml.sax.parser""},



  


  {
    ER_PARSER_ARG_CANNOT_BE_NULL,
     ""Parser 变量必须为非空 ""},




  


  {
    ER_FEATURE,
     ""特征：一个  {0}""},




  


  {
    ER_PROPERTY,
     ""特性：一个  {0}""},



  


  {
    ER_NULL_ENTITY_RESOLVER,
     ""空实体解析程序 ""},



  


  {
    ER_NULL_DTD_HANDLER,
     ""空  DTD 处理程序 ""},



  

  {
    ER_NO_DRIVER_NAME_SPECIFIED,
     ""未指定驱动程序名称！ ""},




  

  {
    ER_NO_URL_SPECIFIED,
     ""未指定  URL！ ""},




  

  {
    ER_POOLSIZE_LESS_THAN_ONE,
     ""池的大小小于  1！ ""},




  

  {
    ER_INVALID_DRIVER_NAME,
     ""指定了无效驱动程序名称！ ""},





  

  {
    ER_ERRORLISTENER,
     ""ErrorListener""},




  

  {
    ER_ASSERT_NO_TEMPLATE_PARENT,
     ""程序员错误！ expr 没有  ElemTemplateElement 父类！ ""},




  

  {
    ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
     ""RundundentExprEliminator 中的程序员声明： {0}""},


  
  

  {
    ER_NOT_ALLOWED_IN_POSITION,
     ""样式表中的这个位置不允许出现  {0}！ ""},


  
  

  {
    ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
     ""样式表中的这个位置不允许非空格文本！ ""},


  
  
  
  

  {
    INVALID_TCHAR,
     ""使用了非法值： {1}（在  CHAR 属性  {0} 中）。 CHAR 类型的属性必须只包含  1 个字符！ ""},


    
    
    
    
    

  
  
  

  {
    INVALID_QNAME,
     ""使用了非法值： {1}（在  QNAME 属性  {0} 中） ""},


    
    
    
    
    
    

  
  

  {
    INVALID_ENUM,
     ""使用了非法值： {1}（在  ENUM 属性  {0} 中）。有效值为： {2}。 ""},








  
  

  {
    INVALID_NMTOKEN,
     ""使用了非法值： {1}（在  NMTOKEN 属性  {0} 中）  ""},








  
  

  {
    INVALID_NCNAME,
     ""使用了非法值： {1}（在  NCNAME 属性  {0} 中）  ""},








  
  


  {
    INVALID_BOOLEAN,
     ""使用了非法值： {1}（在布尔属性  {0} 中）  ""},








  
  

  {
    INVALID_NUMBER,
     ""使用了非法值： {1}（在数字属性  {0} 中）  ""},



  







  
  

  {
    ER_ARG_LITERAL,
     ""匹配模式中的  {0} 变量必须是文字。 ""},







  
  

  {
    ER_DUPLICATE_GLOBAL_VAR,
     ""重复的全局变量声明。 ""},







  
  

  {
    ER_DUPLICATE_VAR,
     ""重复的变量声明。 ""},


    
    
    

  
  

  {
    ER_TEMPLATE_NAME_MATCH,
     ""xsl:template 必须具有名称或匹配的属性（或同时具有两者） ""},


    
    
    
    
    

  
  

  {
    ER_INVALID_PREFIX,
     ""exclude-result-prefixes 中的前缀无效： {0}""},


    
    
    
    
    

  
  

  {
    ER_NO_ATTRIB_SET,
     ""不存在名为  {0} 的  attribute-set""},


  

  
  


  {
    WG_FOUND_CURLYBRACE,
      ""已找到  '}'，但未打开属性模板！ ""},


  
  


  {
    WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""警告： ''count'' 属性与  xsl:number! Target = {0} 中的祖先不匹配 ""},


  
  


  {
    WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""旧语法： 'expr' 属性的名称已经变为  'select'。 ""},


  
  


  {
    WG_NO_LOCALE_IN_FORMATNUMBER,
      "" Xalan 仍然无法处理  format-number 函数中的语言环境名称。 ""},


  
  


  {
    WG_LOCALE_NOT_FOUND,
      ""警告：无法找到  xml:lang={0} 中的语言环境  ""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""从  {0} 中无法产生  URL：  ""},


  
  


  {
    WG_CANNOT_LOAD_REQUESTED_DOC,
      ""无法装入请求文档： {0}""},


  
  


  {
    WG_CANNOT_FIND_COLLATOR,
      ""在  <sort xml:lang={0} 中无法找到整理机  ""},


  
  


  {
    WG_FUNCTIONS_SHOULD_USE_URL,
      ""旧语法：函数指令应当使用  {0} 的一个  URL ""},


  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""不受支持的编码： {0}，正在使用  UTF-8""},


  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      ""不受支持的编码： {0}，正在  Java {1}""},


  
  


  {
    WG_SPECIFICITY_CONFLICTS,
      ""发现专一性冲突： {0} 将使用上次在式样表单中找到的编码。 ""},


  
  


  {
    WG_PARSING_AND_PREPARING,
      ""========= 分析和准备  {0} ==========""},


  
  


  {
    WG_ATTR_TEMPLATE, ""属性模板， {0}""},


  
  


  {
    WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""在  xsl:strip-space 和  xsl:preserve-space 之间出现匹配冲突  ""},


  
  


  {
    WG_ATTRIB_NOT_HANDLED,
      ""Xalan 仍不处理  {0} 属性！ ""},


  
  


  {
    WG_NO_DECIMALFORMAT_DECLARATION,
      ""未找到十进制格式的声明： {0}""},


  
  


  {
    WG_OLD_XSLT_NS, ""缺少或不正确的  XSLT Namespace。  ""},


  
  


  {
    WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""仅允许声明一个缺省  xsl:decimal-format。  ""},


  
  


  {
    WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""xsl:decimal-format 的名称必须是唯一的。名称  ""{0}"" 已复制。 ""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE,
      ""{0} 存在一个非法属性： {1}""},


  
  


  {
    WG_COULD_NOT_RESOLVE_PREFIX,
      ""无法解析名称空间前缀： {0}。忽略节点。 ""},


  
  


  {
    WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet 需要  'version' 属性！ ""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE_NAME,
      ""非法属性名称： {0}""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""在属性中使用非法数值  {0}： {1}""},


  
  


  {
    WG_EMPTY_SECOND_ARG,
      ""来自文档属性第二个参数的结果节点集为空。将使用第一个参数。 ""},


  

    
    
    


  
  

  {
     WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""xsl:processing-instruction 名称的  'name' 属性值不能为  'xml'""},


    
    
    
    

  
  

  {
     WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""xsl:processing-instruction 的  ''name'' 属性值必须是一个有效的  NCName:a {0}""},


    
    
    
    
    

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_POSITION,
      ""无法在已经生成子节点之后或在尚未生成元素之前添加属性  {0}。属性将被忽略。 ""},


    

  
  { ""ui_language"", ""zh""},
  { ""help_language"", ""zh""},
  { ""language"", ""zh""},
    { ""BAD_CODE"",
      ""createMessage 参数超过范围 ""},
    { ""FORMAT_FAILED"",
      ""调用  messageFormat 时出现意外情况   ""},
    { ""version"", "">>>>>>> Xalan 版本  ""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""是 ""},
    { ""line"", ""行  #""},
    { ""column"", ""列  #""},
    { ""xsldone"", ""XSLProcessor: done""},
    { ""xslProc_option"",
    ""Xalan-J 命令行运行类选项： ""},
    { ""optionIN"", ""    -IN inputXMLURL""},
    { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
    { ""optionOUT"", ""   [-OUT outputFileName]""},
    { ""optionLXCIN"",
      ""   [-LXCIN compiledStylesheetFileNameIn]""},
    { ""optionLXCOUT"",
      ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
    { ""optionPARSER"",
      ""   [-PARSER 完全符合分析联络的类名称 ]""},
    { ""optionE"",
    ""   [-E（不扩展实体引用） ]""},
    { ""optionV"",
    ""   [-E（不扩展实体引用） ]""},
    { ""optionQC"",
      ""   [-QC（静止模式冲突警告） ]""},
    { ""optionQ"", ""   [-Q（静止模式） ]""},
    { ""optionLF"",
      ""   [-LF（仅在输出时使用换行  {缺省为  CR/LF}） ]""},
    { ""optionCR"",
      ""   [-CR（仅在输出时使用换行  {缺省为  CR/LF}） ]""},
    { ""optionESCAPE"",
      ""   [-ESCAPE（避免使用的字符  {缺省是  <>&""'\r\n}） ]""},
    { ""optionINDENT"",
      ""   [-INDENT（控制缩进空格的数量  {缺省是  0}） ]""},
    { ""optionTT"",
      ""   [-TT（跟踪调用的模板。） ]""},
    { ""optionTG"",
      ""   [-TG（跟踪发生事件。） ]""},
    { ""optionTS"",
    ""   [-TS（跟踪每个选中事件。） ]""},
    { ""optionTTC"",
      ""   [-TTC（跟踪运行的子模板。） ]""},
    { ""optionTCLASS"",
      ""   [-TCLASS（用于跟踪扩展名的  TraceListener 类。） ]""},
    { ""optionVALIDATE"",
      ""   [-VALIDATE（设置是否“确认”。缺省情况下关闭“确认”。） ]""},
    { ""optionEDUMP"",
      ""   [-EDUMP {可选文件名 }（出现错误时确保栈转储。） ]""},
    { ""optionXML"",
      ""   [-XML (使用  XML 格式标识符并添加  XML 头。） ]""},
    { ""optionTEXT"",
      ""   [-TEXT（使用简单的  Text 格式标识符。） ]""},
    { ""optionHTML"",
    ""   [-HTML（使用  HTML 格式标识符。） ]""},
    { ""optionPARAM"",
      ""   [-PARAM 名称扩展（设置一个  stylesheet 参数） ]""},
    { ""noParsermsg1"",
    ""XSL 运行不成功。  ""},
    { ""noParsermsg2"",
    ""** 未找到分析器  **""},
    { ""noParsermsg3"",
    ""请检查您的类路径。 ""},
    { ""noParsermsg4"",
      ""如果您没有  IBM 用于  Java 的  XML 分析器，您可从 ""},
    { ""noParsermsg5"",
      ""IBM AlphaWorks： http:
    { ""optionURIRESOLVER"",
    ""   [-URIRESOLVER 全类名（ URIResolver 用于分析  URI） ]""},
    { ""optionENTITYRESOLVER"",
    ""   [-ENTITYRESOLVER 全类名（ EntityResolver 用于分析实体） ] ""},
    {  ""optionCONTENTHANDLER"",
    ""   [-CONTENTHANDLER 全类名（ ContentHandler 用于串行化输出） ]""},
    { ""optionLINENUMBERS"",
    ""   [-L 使用源文档的行号 ]""},
		
    


    { ""optionMEDIA"",
    "" [-MEDIA 媒体类型（使用媒体属性查找与某个文档关联的样式表。） ]""},
    { ""optionFLAVOR"",
    "" [-FLAVOR 风格名称（明确使用  s2s=SAX 或  d2d=DOM 进行变换。） ] ""}, 
    { ""optionDIAG"",
    "" [-DIAG（打印变换所花的总毫秒数。） ]""},
    { ""optionINCREMENTAL"",
    "" [-INCREMENTAL（通过将  http:
    { ""optionNOOPTIMIMIZE"",
    "" [-NOOPTIMIMIZE（通过将  http:
    { ""optionRL"",
    "" [-RL 递归限制（声明样式表递归深度的数字限制。） ]""},
    { ""optionXO"",
    "" [-XO [translet 名 ]（指定生成的  translet 的名称） ]""},
    { ""optionXD"",
    "" [-XD 目标目录（指定  translet 的目标目录） ]""},
    { ""optionXJ"",
    "" [-XJ jar 文件（将  translet 类封装成名称为  <jarfile> 的  jar 文件） ]""},
    { ""optionXP"",
    "" [-XP 软件包（为所有生成的  translet 类指定软件包名称前缀） ]""}


  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""错误：  "";

  
  public static final String WARNING_HEADER = ""警告：  "";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }

}
"
org.apache.xalan.templates.Stylesheet,74,3,2,47,119,2539,37,17,70,0.966051221,1136,0.913043478,4,0.728624535,0.073443008,3,19,14.04054054,16,1.8378,2,"
package org.apache.xalan.templates;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Vector;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.StringVector;
import org.apache.xml.utils.SystemIDResolver;


public class Stylesheet extends ElemTemplateElement
        implements java.io.Serializable 
{

  
  public Stylesheet(Stylesheet parent)
  {

    if (null != parent)
    {
      m_stylesheetParent = parent;
      m_stylesheetRoot = parent.getStylesheetRoot();
    }
  }

  
  public Stylesheet getStylesheet()
  {
    return this;
  }

  
  public boolean isAggregatedType()
  {
    return false;
  }

  
  public boolean isRoot()
  {
    return false;
  }

  
  public static final String STYLESHEET_EXT = "".lxc"";

  
  private void readObject(ObjectInputStream stream)
          throws IOException, TransformerException
  {

    
    try
    {
      stream.defaultReadObject();
    }
    catch (ClassNotFoundException cnfe)
    {
      throw new TransformerException(cnfe);
    }

    
  }

  
  private void writeObject(ObjectOutputStream stream) throws IOException
  {

    
    stream.defaultWriteObject();

    
  }

  

  
  private String m_XmlnsXsl;

  
  public void setXmlnsXsl(String v)
  {
    m_XmlnsXsl = v;
  }

  
  public String getXmlnsXsl()
  {
    return m_XmlnsXsl;
  }

  
  private StringVector m_ExtensionElementURIs;

  
  public void setExtensionElementPrefixes(StringVector v)
  {
    m_ExtensionElementURIs = v;
  }

  
  public String getExtensionElementPrefix(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_ExtensionElementURIs)
      throw new ArrayIndexOutOfBoundsException();

    return m_ExtensionElementURIs.elementAt(i);
  }

  
  public int getExtensionElementPrefixCount()
  {
    return (null != m_ExtensionElementURIs)
           ? m_ExtensionElementURIs.size() : 0;
  }

  
  public boolean containsExtensionElementURI(String uri)
  {

    if (null == m_ExtensionElementURIs)
      return false;

    return m_ExtensionElementURIs.contains(uri);
  }

  
  private StringVector m_ExcludeResultPrefixs;

  
  public void setExcludeResultPrefixes(StringVector v)
  {
    m_ExcludeResultPrefixs = v;
  }

  
  public String getExcludeResultPrefix(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_ExcludeResultPrefixs)
      throw new ArrayIndexOutOfBoundsException();

    return m_ExcludeResultPrefixs.elementAt(i);
  }

  
  public int getExcludeResultPrefixCount()
  {
    return (null != m_ExcludeResultPrefixs)
           ? m_ExcludeResultPrefixs.size() : 0;
  }

  
  public boolean containsExcludeResultPrefix(String prefix, String uri) 
  {

    if (null == m_ExcludeResultPrefixs || uri == null )
      return false;
    
    
    
    for (int i =0; i< m_ExcludeResultPrefixs.size(); i++)
    {
      if (uri.equals(getNamespaceForPrefix(m_ExcludeResultPrefixs.elementAt(i))))
        return true;
    }
    
    return false;

  
  }

  
  private String m_Id;

  
  public void setId(String v)
  {
    m_Id = v;
  }

  
  public String getId()
  {
    return m_Id;
  }

  
  private String m_Version;

  
  public void setVersion(String v)
  {
    m_Version = v;
  }

  
  public String getVersion()
  {
    return m_Version;
  }

  
  private Vector m_imports;

  
  public void setImport(StylesheetComposed v)
  {

    if (null == m_imports)
      m_imports = new Vector();

    
    
    m_imports.addElement(v);
  }

  
  public StylesheetComposed getImport(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_imports)
      throw new ArrayIndexOutOfBoundsException();

    return (StylesheetComposed) m_imports.elementAt(i);
  }

  
  public int getImportCount()
  {
    return (null != m_imports) ? m_imports.size() : 0;
  }

  
  private Vector m_includes;

  
  public void setInclude(Stylesheet v)
  {

    if (null == m_includes)
      m_includes = new Vector();

    m_includes.addElement(v);
  }

  
  public Stylesheet getInclude(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_includes)
      throw new ArrayIndexOutOfBoundsException();

    return (Stylesheet) m_includes.elementAt(i);
  }

  
  public int getIncludeCount()
  {
    return (null != m_includes) ? m_includes.size() : 0;
  }

  
  Stack m_DecimalFormatDeclarations;

  
  public void setDecimalFormat(DecimalFormatProperties edf)
  {

    if (null == m_DecimalFormatDeclarations)
      m_DecimalFormatDeclarations = new Stack();

    
    
    m_DecimalFormatDeclarations.push(edf);
  }

  
  public DecimalFormatProperties getDecimalFormat(QName name)
  {

    if (null == m_DecimalFormatDeclarations)
      return null;

    int n = getDecimalFormatCount();

    for (int i = (n - 1); i >= 0; i++)
    {
      DecimalFormatProperties dfp = getDecimalFormat(i);

      if (dfp.getName().equals(name))
        return dfp;
    }

    return null;
  }

  
  public DecimalFormatProperties getDecimalFormat(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_DecimalFormatDeclarations)
      throw new ArrayIndexOutOfBoundsException();

    return (DecimalFormatProperties) m_DecimalFormatDeclarations.elementAt(i);
  }

  
  public int getDecimalFormatCount()
  {
    return (null != m_DecimalFormatDeclarations)
           ? m_DecimalFormatDeclarations.size() : 0;
  }

  
  private Vector m_whitespaceStrippingElements;

  
  public void setStripSpaces(WhiteSpaceInfo wsi)
  {

    if (null == m_whitespaceStrippingElements)
    {
      m_whitespaceStrippingElements = new Vector();
    }

    m_whitespaceStrippingElements.addElement(wsi);
  }

  
  public WhiteSpaceInfo getStripSpace(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_whitespaceStrippingElements)
      throw new ArrayIndexOutOfBoundsException();

    return (WhiteSpaceInfo) m_whitespaceStrippingElements.elementAt(i);
  }

  
  public int getStripSpaceCount()
  {
    return (null != m_whitespaceStrippingElements)
           ? m_whitespaceStrippingElements.size() : 0;
  }

  
  private Vector m_whitespacePreservingElements;

  
  public void setPreserveSpaces(WhiteSpaceInfo wsi)
  {

    if (null == m_whitespacePreservingElements)
    {
      m_whitespacePreservingElements = new Vector();
    }

    m_whitespacePreservingElements.addElement(wsi);
  }

  
  public WhiteSpaceInfo getPreserveSpace(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_whitespacePreservingElements)
      throw new ArrayIndexOutOfBoundsException();

    return (WhiteSpaceInfo) m_whitespacePreservingElements.elementAt(i);
  }

  
  public int getPreserveSpaceCount()
  {
    return (null != m_whitespacePreservingElements)
           ? m_whitespacePreservingElements.size() : 0;
  }

  
  private Vector m_output;

  
  public void setOutput(OutputProperties v)
  {
    if (null == m_output)
    {
      m_output = new Vector();
    }

    m_output.addElement(v);
  }

  
  public OutputProperties getOutput(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_output)
      throw new ArrayIndexOutOfBoundsException();

    return (OutputProperties) m_output.elementAt(i);
  }

  
  public int getOutputCount()
  {
    return (null != m_output)
           ? m_output.size() : 0;
  }

  
  private Vector m_keyDeclarations;

  
  public void setKey(KeyDeclaration v)
  {

    if (null == m_keyDeclarations)
      m_keyDeclarations = new Vector();

    m_keyDeclarations.addElement(v);
  }

  
  public KeyDeclaration getKey(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_keyDeclarations)
      throw new ArrayIndexOutOfBoundsException();

    return (KeyDeclaration) m_keyDeclarations.elementAt(i);
  }

  
  public int getKeyCount()
  {
    return (null != m_keyDeclarations) ? m_keyDeclarations.size() : 0;
  }

  
  private Vector m_attributeSets;

  
  public void setAttributeSet(ElemAttributeSet attrSet)
  {

    if (null == m_attributeSets)
    {
      m_attributeSets = new Vector();
    }

    m_attributeSets.addElement(attrSet);
  }

  
  public ElemAttributeSet getAttributeSet(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_attributeSets)
      throw new ArrayIndexOutOfBoundsException();

    return (ElemAttributeSet) m_attributeSets.elementAt(i);
  }

  
  public int getAttributeSetCount()
  {
    return (null != m_attributeSets) ? m_attributeSets.size() : 0;
  }

  
  private Vector m_topLevelVariables;

  
  public void setVariable(ElemVariable v)
  {

    if (null == m_topLevelVariables)
      m_topLevelVariables = new Vector();

    m_topLevelVariables.addElement(v);
  }
  
  
  public ElemVariable getVariableOrParam(QName qname)
  {

    if (null != m_topLevelVariables)
    {
      int n = getVariableOrParamCount();

      for (int i = 0; i < n; i++)
      {
        ElemVariable var = (ElemVariable) getVariableOrParam(i);

        if (var.getName().equals(qname))
          return var;
      }
    }

    return null;
  }


  
  public ElemVariable getVariable(QName qname)
  {

    if (null != m_topLevelVariables)
    {
      int n = getVariableOrParamCount();

      for (int i = 0; i < n; i++)
      {
        ElemVariable var = getVariableOrParam(i);
        if((var.getXSLToken() == Constants.ELEMNAME_VARIABLE) &&
           (var.getName().equals(qname)))
          return var;
      }
    }

    return null;
  }

  
  public ElemVariable getVariableOrParam(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_topLevelVariables)
      throw new ArrayIndexOutOfBoundsException();

    return (ElemVariable) m_topLevelVariables.elementAt(i);
  }

  
  public int getVariableOrParamCount()
  {
    return (null != m_topLevelVariables) ? m_topLevelVariables.size() : 0;
  }

  
  public void setParam(ElemParam v)
  {
    setVariable(v);
  }

  
  public ElemParam getParam(QName qname)
  {

    if (null != m_topLevelVariables)
    {
      int n = getVariableOrParamCount();

      for (int i = 0; i < n; i++)
      {
        ElemVariable var = getVariableOrParam(i);
        if((var.getXSLToken() == Constants.ELEMNAME_PARAMVARIABLE) &&
           (var.getName().equals(qname)))
          return (ElemParam)var;
      }
    }

    return null;
  }

  
  private Vector m_templates;

  
  public void setTemplate(ElemTemplate v)
  {

    if (null == m_templates)
      m_templates = new Vector();

    m_templates.addElement(v);
    v.setStylesheet(this);
  }

  
  public ElemTemplate getTemplate(int i) throws TransformerException
  {

    if (null == m_templates)
      throw new ArrayIndexOutOfBoundsException();

    return (ElemTemplate) m_templates.elementAt(i);
  }

  
  public int getTemplateCount()
  {
    return (null != m_templates) ? m_templates.size() : 0;
  }

  
  private Vector m_prefix_aliases;

  
  public void setNamespaceAlias(NamespaceAlias na)
  {

    if (m_prefix_aliases == null)
      m_prefix_aliases = new Vector();

    m_prefix_aliases.addElement(na);
  }

  
  public NamespaceAlias getNamespaceAlias(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_prefix_aliases)
      throw new ArrayIndexOutOfBoundsException();

    return (NamespaceAlias) m_prefix_aliases.elementAt(i);
  }

  
  public int getNamespaceAliasCount()
  {
    return (null != m_prefix_aliases) ? m_prefix_aliases.size() : 0;
  }

  
  private Hashtable m_NonXslTopLevel;

  
  public void setNonXslTopLevel(QName name, Object obj)
  {

    if (null == m_NonXslTopLevel)
      m_NonXslTopLevel = new Hashtable();

    m_NonXslTopLevel.put(name, obj);
  }

  
  public Object getNonXslTopLevel(QName name)
  {
    return (null != m_NonXslTopLevel) ? m_NonXslTopLevel.get(name) : null;
  }

  

  
  private String m_href = null;

  
  private String m_publicId;

  
  private String m_systemId;

  
  public String getHref()
  {
    return m_href;
  }

  
  public void setHref(String baseIdent)
  {
    m_href = baseIdent;
  }

  
  public void setLocaterInfo(SourceLocator locator)
  {

    if (null != locator)
    {
      m_publicId = locator.getPublicId();
      m_systemId = locator.getSystemId();

      if (null != m_systemId)
      {
        try
        {
          m_href = SystemIDResolver.getAbsoluteURI(m_systemId, null);
        }
        catch (TransformerException se)
        {

          
        }
      }

      super.setLocaterInfo(locator);
    }
  }

  
  private StylesheetRoot m_stylesheetRoot;

  
  public StylesheetRoot getStylesheetRoot()
  {
    return m_stylesheetRoot;
  }

  
  public void setStylesheetRoot(StylesheetRoot v)
  {
    m_stylesheetRoot = v;
  }

  
  private Stylesheet m_stylesheetParent;

  
  public Stylesheet getStylesheetParent()
  {
    return m_stylesheetParent;
  }

  
  public void setStylesheetParent(Stylesheet v)
  {
    m_stylesheetParent = v;
  }

  
  public StylesheetComposed getStylesheetComposed()
  {

    Stylesheet sheet = this;

    while (!sheet.isAggregatedType())
    {
      sheet = sheet.getStylesheetParent();
    }

    return (StylesheetComposed) sheet;
  }

  
  public short getNodeType()
  {
    return DTM.DOCUMENT_NODE;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_STYLESHEET;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_STYLESHEET_STRING;
  }

  
  public void replaceTemplate(ElemTemplate v, int i) throws TransformerException
  {

    if (null == m_templates)
      throw new ArrayIndexOutOfBoundsException();

    replaceChild(v, (ElemTemplateElement)m_templates.elementAt(i));
    m_templates.setElementAt(v, i);
    v.setStylesheet(this);
  }
  
    
    protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
    {
      int s = getImportCount();
      for (int j = 0; j < s; j++)
      {
      	getImport(j).callVisitors(visitor);
      }
   
      s = getIncludeCount();
      for (int j = 0; j < s; j++)
      {
      	getInclude(j).callVisitors(visitor);
      }

      s = getOutputCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getOutput(j));
      }

      

      s = getAttributeSetCount();
      for (int j = 0; j < s; j++)
      {
      	ElemAttributeSet attrSet = getAttributeSet(j);
        if (visitor.visitTopLevelInstruction(attrSet))
        {
          attrSet.callChildVisitors(visitor);
        }
      }
      

      s = getDecimalFormatCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getDecimalFormat(j));
      }

      

      s = getKeyCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getKey(j));
      }

      

      s = getNamespaceAliasCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getNamespaceAlias(j));
      }

      

      s = getTemplateCount();
      for (int j = 0; j < s; j++)
      {
        try
        {
          ElemTemplate template = getTemplate(j);
          if (visitor.visitTopLevelInstruction(template))
          {
            template.callChildVisitors(visitor);
          }
        }
        catch (TransformerException te)
        {
          throw new org.apache.xml.utils.WrappedRuntimeException(te);
        }
      }

      

      s = getVariableOrParamCount();
      for (int j = 0; j < s; j++)
      {
      	ElemVariable var = getVariableOrParam(j);
        if (visitor.visitTopLevelVariableOrParamDecl(var))
        {
          var.callChildVisitors(visitor);
        }
      }

      

      s = getStripSpaceCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getStripSpace(j));
      }

      s = getPreserveSpaceCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getPreserveSpace(j));
      }
      
      if(null != m_NonXslTopLevel)
      {
      	java.util.Enumeration enum = m_NonXslTopLevel.elements();
      	while(enum.hasMoreElements())
      	{
      	  ElemTemplateElement elem = (ElemTemplateElement)enum.nextElement();
          if (visitor.visitTopLevelInstruction(elem))
          {
            elem.callChildVisitors(visitor);
          }
      		
      	}
      }
    }
        
          
  
  protected boolean accept(XSLTVisitor visitor)
  {
  	return visitor.visitStylesheet(this);
  }

  
}
"
org.apache.xalan.xsltc.dom.LoadDocument,6,1,0,17,51,15,0,17,3,1.2,368,1.0,0,0.0,0.5,0,0,60.16666667,1,0.8333,4,"

package org.apache.xalan.xsltc.dom;

import java.io.File;
import java.io.FileNotFoundException;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.sax.SAXSource;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.DOMCache;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMDefaultBase;

import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;

public final class LoadDocument {

    private static final String NAMESPACE_FEATURE =
	""http:

    
    public static DTMAxisIterator document(String uri, String base,
					AbstractTranslet translet, DOM dom)
	throws Exception 
    {
        final String originalUri = uri;
        MultiDOM multiplexer = (MultiDOM)dom;

        
        
        if (uri == null || uri.equals("""")) {
            return(new SingletonIterator(DTM.NULL,true));
        }

        
        if (base != null && !base.equals("""")) {
            if (!uri.startsWith(base)     &&   
                !uri.startsWith(""/"")      &&   
                !uri.startsWith(""http:/"") &&   
                !uri.startsWith(""file:/"")) {   
                uri = base + uri;
            }
        }

        
        final File file = new File(uri);
        if (file.exists()) {
            uri = file.toURL().toExternalForm();
        }
	
        
        int mask = multiplexer.getDocumentMask(uri);
        if (mask != -1) {
            DOM newDom = ((DOMAdapter)multiplexer.getDOMAdapter(uri))
                                       .getDOMImpl();
            if (newDom instanceof SAXImpl) {
                return new SingletonIterator(((SAXImpl)newDom).getDocument(),
                                             true);
            } 
        }

        
        DOMCache cache = translet.getDOMCache();
        DOM newdom;

        mask = multiplexer.nextMask(); 

        if (cache != null) {
            
            newdom = cache.retrieveDocument(uri, mask, translet);
            if (newdom == null) {
                final Exception e = new FileNotFoundException(originalUri);
                throw new TransletException(e);
            }
        } else {
            
            
            final SAXParserFactory factory = SAXParserFactory.newInstance();
            final SAXParser parser = factory.newSAXParser();
            final XMLReader reader = parser.getXMLReader();
            try {
                reader.setFeature(NAMESPACE_FEATURE,true);
            }
            catch (Exception e) {
                throw new TransletException(e);
            }

            
            XSLTCDTMManager dtmManager = (XSLTCDTMManager)
                        ((DTMDefaultBase)((DOMAdapter)multiplexer.getMain())
                                               .getDOMImpl()).m_mgr;
            newdom = (SAXImpl)dtmManager.getDTM(
                                 new SAXSource(reader, new InputSource(uri)),
                                 false, null, true, false, translet.hasIdCall());

            translet.prepassDocument(newdom);

            ((SAXImpl)newdom).setDocumentURI(uri);
        }

        
        final DOMAdapter domAdapter = translet.makeDOMAdapter(newdom);
        multiplexer.addDOMAdapter(domAdapter);

        
        translet.buildKeys(domAdapter, null, null, ((SAXImpl)newdom).getDocument());

        
        return new SingletonIterator(((SAXImpl)newdom).getDocument(), true);
    }

    
    public static DTMAxisIterator document(Object arg,String xmlURI,String xslURI,
					AbstractTranslet translet, DOM dom)
	throws TransletException {
	try {

	    
	    if (xmlURI != null) {
		int sep = xmlURI.lastIndexOf('\') + 1;
		if (sep <= 0) {
		    sep = xmlURI.lastIndexOf('/') + 1;
	        }
		xmlURI = xmlURI.substring(0, sep); 
	    }
	    else {
		xmlURI = """";
	    }

	    
	    if (xslURI != null) {
		int sep = xslURI.lastIndexOf('\') + 1;
		if (sep <= 0) {
		    sep = xslURI.lastIndexOf('/') + 1;
	        }
		xslURI = xslURI.substring(0, sep); 
	    }
	    else {
		xslURI = """";
	    }

	    
	    
	    if (arg instanceof String) {
		
		try {
		    return document((String)arg, xmlURI, translet, dom);
		}
		
		catch (java.io.FileNotFoundException e) {
		    return document((String)arg, xslURI, translet, dom);
		}
		catch (org.xml.sax.SAXParseException e) {
		    return document((String)arg, xslURI, translet, dom);
		}
	    }
	    
	    
	    else if (arg instanceof DTMAxisIterator) {
		UnionIterator union = new UnionIterator(dom);
		DTMAxisIterator iterator = (DTMAxisIterator)arg;
		int node;

		while ((node = iterator.next()) != DTM.NULL) {
		    String uri = dom.getStringValueX(node);
		    
		    if ((xmlURI == null) || xmlURI.equals("""")) {
			xmlURI = dom.getDocumentURI(node);
			int sep = xmlURI.lastIndexOf('\') + 1;
			if (sep <= 0) {
			    sep = xmlURI.lastIndexOf('/') + 1;
		        }
			xmlURI = xmlURI.substring(0, sep);
		    }
		    
		    try {
			union.addIterator(document(uri, xmlURI, translet, dom));
		    }
		    
		    catch (java.io.FileNotFoundException e) {
			union.addIterator(document(uri, xslURI, translet, dom));
		    }
		}
		return(union);
	    }
	    else {
		final String err = ""document(""+arg.toString()+"")"";
		throw new IllegalArgumentException(err);
	    }
	}
	catch (TransletException e) {
	    throw e;
	}
	catch (Exception e) {
	    throw new TransletException(e);
	}
    }

}
"
org.apache.xalan.xsltc.compiler.AttributeValue,2,3,2,10,8,1,7,5,1,2.0,44,0.0,0,0.986111111,0.5,0,0,21.0,3,1.5,0,"

package org.apache.xalan.xsltc.compiler;


abstract class AttributeValue extends Expression {

    public static final AttributeValue create(SyntaxTreeNode parent,
					      String text, Parser parser) {

	AttributeValue result;
	if (text.indexOf('{') != -1) {
	    result = new AttributeValueTemplate(text, parser, parent);
	}
	else if (text.indexOf('}') != -1) {
	    result = new AttributeValueTemplate(text, parser, parent);
	}
	else {
	    result = new SimpleAttributeValue(text);
	    result.setParser(parser);
	    result.setParent(parent);
	}
	return result;
    }
}
"
org.apache.xalan.xsltc.dom.FilteredStepIterator,2,3,0,3,6,0,0,3,2,0.0,28,1.0,1,0.952380952,0.666666667,1,2,12.5,3,1.5,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xml.dtm.DTMAxisIterator;


public final class FilteredStepIterator extends StepIterator {

    private Filter _filter;

    public FilteredStepIterator(DTMAxisIterator source,
				DTMAxisIterator iterator,
				Filter filter) {
	super(source, iterator);
	_filter = filter;
    }

    public int next() {
	int node;
	while ((node = super.next()) != END) {
	    if (_filter.test(node)) {
		return returnNode(node);
	    }
	}
	return node;
    }

}
"
org.apache.xalan.xsltc.compiler.NamespaceAlias,4,3,0,8,8,6,1,7,3,1.0,30,1.0,0,0.952380952,0.4,2,4,6.0,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class NamespaceAlias extends TopLevelElement {

    private String sPrefix;
    private String rPrefix;
	
    
    public void parseContents(Parser parser) {
	sPrefix = getAttribute(""stylesheet-prefix"");
	rPrefix = getAttribute(""result-prefix"");
	parser.getSymbolTable().addPrefixAlias(sPrefix,rPrefix);
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }
}
"
org.apache.xml.serializer.ToTextSAXHandler,41,3,0,3,56,814,2,1,41,2.0,161,0.0,0,0.74,0.153846154,2,6,2.926829268,1,0.9512,0,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.util.Properties;

import org.w3c.dom.Node;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;


public class ToTextSAXHandler extends ToSAXHandler 
{
    
    public void endElement(String elemName) throws SAXException
    {
        super.fireEndElem(elemName);
    }

    
    public void endElement(String arg0, String arg1, String arg2)
        throws SAXException
    {
        super.fireEndElem(arg2);    	
    }

    public ToTextSAXHandler(ContentHandler hdlr, LexicalHandler lex, String encoding)
    {
        super(hdlr, lex, encoding);
    }
    
        
    public ToTextSAXHandler(ContentHandler handler, String encoding)
    {
        super(handler,encoding);
    }

    public void comment(char ch[], int start, int length)
        throws org.xml.sax.SAXException
    {
        super.fireCommentEvent(ch, start, length);
    }

    public void comment(String data) throws org.xml.sax.SAXException
    {
        comment(data.toCharArray(), 0, data.length());
    }

    
    public Properties getOutputFormat()
    {
        return null;
    }

    
    public OutputStream getOutputStream()
    {
        return null;
    }

    
    public Writer getWriter()
    {
        return null;
    }

    
    public void indent(int n) throws SAXException
    {
    }

    
    public boolean reset()
    {
        return false;
    }

    
    public void serialize(Node node) throws IOException
    {
    }

    
    public boolean setEscaping(boolean escape)
    {
        return false;
    }

    
    public void setIndent(boolean indent)
    {
    }

    
    public void setOutputFormat(Properties format)
    {
    }

    
    public void setOutputStream(OutputStream output)
    {
    }

    
    public void setWriter(Writer writer)
    {
    }

    
    public void addAttribute(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
    {
    }

    
    public void attributeDecl(
        String arg0,
        String arg1,
        String arg2,
        String arg3,
        String arg4)
        throws SAXException
    {
    }

    
    public void elementDecl(String arg0, String arg1) throws SAXException
    {
    }

    
    public void externalEntityDecl(String arg0, String arg1, String arg2)
        throws SAXException
    {
    }

    
    public void internalEntityDecl(String arg0, String arg1)
        throws SAXException
    {
    }

    
    public void endPrefixMapping(String arg0) throws SAXException
    {
    }

    
    public void ignorableWhitespace(char[] arg0, int arg1, int arg2)
        throws SAXException
    {
    }

    
    public void processingInstruction(String arg0, String arg1)
        throws SAXException
    {
		super.fireEscapingEvent(arg0,arg1);            	
    }

    
    public void setDocumentLocator(Locator arg0)
    {
    }

    
    public void skippedEntity(String arg0) throws SAXException
    {
    }

    
    public void startElement(
        String arg0,
        String arg1,
        String arg2,
        Attributes arg3)
        throws SAXException
    {
        flushPending();
        super.startElement(arg0, arg1, arg2, arg3);
    }

    
    public void endCDATA() throws SAXException
    {
    }

    
    public void endDTD() throws SAXException
    {
    }

    
    public void startCDATA() throws SAXException
    {
    }


    
    public void startEntity(String arg0) throws SAXException
    {
    }


    
    public void startElement(
    String elementNamespaceURI,
    String elementLocalName,
    String elementName) throws SAXException
    {
        super.startElement(elementNamespaceURI, elementLocalName, elementName);
    }
    
    public void startElement(
    String elementName) throws SAXException
    {
        super.startElement(elementName);
    }
    

    
    public void endDocument() throws SAXException { 
        
        flushPending();
        m_saxHandler.endDocument();

        super.fireEndDoc();
    }
 
    
    public void characters(String characters) 
    throws SAXException 
    { 
   
        m_saxHandler.characters(characters.toCharArray(), 0, 
        characters.length());
    
    }
    
    public void characters(char[] characters, int offset, int length)
    throws SAXException 
    { 
    
        m_saxHandler.characters(characters, offset, length);

        
        super.fireCharEvent(characters, offset, length);                
    }

    
    public void addAttribute(String name, String value) 
    {
        
    }


    public boolean startPrefixMapping(
        String prefix,
        String uri,
        boolean shouldFlush)
        throws SAXException
    {
        
        return false;
    }


    public void startPrefixMapping(String prefix, String uri)
        throws org.xml.sax.SAXException
    {
        
    }


    public void namespaceAfterStartElement(
        final String prefix,
        final String uri)
        throws SAXException
    {
        
    }

}
"
org.apache.xalan.templates.ElemLiteralResult,32,4,2,17,84,354,6,12,28,0.88172043,656,1.0,2,0.86695279,0.180555556,3,19,19.21875,10,1.8438,3,"
package org.apache.xalan.templates;

import java.util.Enumeration;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.utils.StringVector;
import org.apache.xpath.XPathContext;


public class ElemLiteralResult extends ElemUse
{

  
  private boolean isLiteralResultAsStylesheet = false;

  
  public void setIsLiteralResultAsStylesheet(boolean b)
  {
    isLiteralResultAsStylesheet = b;
  }

  
  public boolean getIsLiteralResultAsStylesheet()
  {
    return isLiteralResultAsStylesheet;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if (null != m_avts)
    {
      int nAttrs = m_avts.size();

      for (int i = (nAttrs - 1); i >= 0; i--)
      {
        AVT avt = (AVT) m_avts.elementAt(i);
        avt.fixupVariables(vnames, cstate.getGlobalsSize());
      } 
    }   
  }
  
  
  private Vector m_avts = null;

  
  private Vector m_xslAttr = null;

  
  public void addLiteralResultAttribute(AVT avt)
  {

    if (null == m_avts)
      m_avts = new Vector();

    m_avts.addElement(avt);
  }

  
  public void addLiteralResultAttribute(String att)
  {

    if (null == m_xslAttr)
      m_xslAttr = new Vector();

    m_xslAttr.addElement(att);
  }
  
  
  public void setXmlSpace(AVT avt)
  {
    
    addLiteralResultAttribute(avt);
    String val = avt.getSimpleString();
    if(val.equals(""default""))
    {
      super.setXmlSpace(Constants.ATTRVAL_STRIP);
    }
    else if(val.equals(""preserve""))
    {
      super.setXmlSpace(Constants.ATTRVAL_PRESERVE);
    }
    
  }


  
  public AVT getLiteralResultAttribute(String name)
  {

    if (null != m_avts)
    {
      int nAttrs = m_avts.size();

      for (int i = (nAttrs - 1); i >= 0; i--)
      {
        AVT avt = (AVT) m_avts.elementAt(i);

        if (avt.getRawName().equals(name))
        {
          return avt;
        }
      }  
    }

    return null;
  }

  
  public boolean containsExcludeResultPrefix(String prefix, String uri)
  {
    if (uri == null ||
				(null == m_excludeResultPrefixes &&
				 null == m_ExtensionElementURIs)
				)
      return super.containsExcludeResultPrefix(prefix, uri);

    if (prefix.length() == 0)
      prefix = Constants.ATTRVAL_DEFAULT_PREFIX;

    
    
		if(m_excludeResultPrefixes!=null)
			for (int i =0; i< m_excludeResultPrefixes.size(); i++)
			{
				if (uri.equals(getNamespaceForPrefix(m_excludeResultPrefixes.elementAt(i))))
					return true;
			}    
		
		
    if(m_ExtensionElementURIs!=null && m_ExtensionElementURIs.contains(uri))
       return true;

		return super.containsExcludeResultPrefix(prefix, uri);
  }

  
  public void resolvePrefixTables() throws TransformerException
  {

    super.resolvePrefixTables();

    StylesheetRoot stylesheet = getStylesheetRoot();

    if ((null != m_namespace) && (m_namespace.length() > 0))
    {
      NamespaceAlias nsa = stylesheet.getNamespaceAliasComposed(m_namespace);

      if (null != nsa)
      {
        m_namespace = nsa.getResultNamespace();

        
        String resultPrefix = nsa.getStylesheetPrefix();  

        if ((null != resultPrefix) && (resultPrefix.length() > 0))
          m_rawName = resultPrefix + "":"" + m_localName;
        else
          m_rawName = m_localName;
      }
    }

    if (null != m_avts)
    {
      int n = m_avts.size();

      for (int i = 0; i < n; i++)
      {
        AVT avt = (AVT) m_avts.elementAt(i);

        
        String ns = avt.getURI();

        if ((null != ns) && (ns.length() > 0))
        {
          NamespaceAlias nsa =
            stylesheet.getNamespaceAliasComposed(m_namespace); 

          if (null != nsa)
          {
            String namespace = nsa.getResultNamespace();

            
            String resultPrefix = nsa.getStylesheetPrefix();  
            String rawName = avt.getName();

            if ((null != resultPrefix) && (resultPrefix.length() > 0))
              rawName = resultPrefix + "":"" + rawName;

            avt.setURI(namespace);
            avt.setRawName(rawName);
          }
        }
      }
    }
  }

  
  boolean needToCheckExclude()
  {
    if (null == m_excludeResultPrefixes && null == m_prefixTable
				&& m_ExtensionElementURIs==null   	
				)
      return false;
    else
    {

      
      if (null == m_prefixTable)
        m_prefixTable = new Vector();

      return true;
    }
  }

  
  private String m_namespace;

  
  public void setNamespace(String ns)
  {
    if(null == ns) 
      ns = """";
    m_namespace = ns;
  }

  
  public String getNamespace()
  {
    return m_namespace;
  }

  
  private String m_localName;

  
  public void setLocalName(String localName)
  {
    m_localName = localName;
  }

  
  public String getLocalName()
  {
    return m_localName;
  }

  
  private String m_rawName;

  
  public void setRawName(String rawName)
  {
    m_rawName = rawName;
  }

  
  public String getRawName()
  {
    return m_rawName;
  }
	
 
  public String getPrefix()
  {
		int len=m_rawName.length()-m_localName.length()-1;
    return (len>0)
			? m_rawName.substring(0,len)
			: """";
  }


  
  private StringVector m_ExtensionElementURIs;

  
  public void setExtensionElementPrefixes(StringVector v)
  {
    m_ExtensionElementURIs = v;
  }

  
  public String getExtensionElementPrefix(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_ExtensionElementURIs)
      throw new ArrayIndexOutOfBoundsException();

    return m_ExtensionElementURIs.elementAt(i);
  }

  
  public int getExtensionElementPrefixCount()
  {
    return (null != m_ExtensionElementURIs)
           ? m_ExtensionElementURIs.size() : 0;
  }

  
  public boolean containsExtensionElementURI(String uri)
  {

    if (null == m_ExtensionElementURIs)
      return false;

    return m_ExtensionElementURIs.contains(uri);
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_LITERALRESULT;
  }

  
  public String getNodeName()
  {

    
    return m_rawName;
  }

  
  private String m_version;

  
  public void setVersion(String v)
  {
    m_version = v;
  }
  
  
  public String getVersion()
  {
    return m_version;
  }

  
  private StringVector m_excludeResultPrefixes;

  
  public void setExcludeResultPrefixes(StringVector v)
  {
    m_excludeResultPrefixes = v;
  }

  
  private boolean excludeResultNSDecl(String prefix, String uri)
          throws TransformerException
  {

    if (null != m_excludeResultPrefixes)
    {
      return containsExcludeResultPrefix(prefix, uri);
    }

    return false;
  }
  
  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    try
    {
      SerializationHandler rhandler = transformer.getSerializationHandler();
			
			
			
			
			rhandler.startPrefixMapping(getPrefix(),getNamespace());

      
      executeNSDecls(transformer);
      rhandler.startElement(getNamespace(), getLocalName(), getRawName());

      try
      {

        
        super.execute(transformer);

        
        
        if (null != m_avts)
        {
          int nAttrs = m_avts.size();

          for (int i = (nAttrs - 1); i >= 0; i--)
          {
            AVT avt = (AVT) m_avts.elementAt(i);
            XPathContext xctxt = transformer.getXPathContext();
            int sourceNode = xctxt.getCurrentNode();
            String stringedValue = avt.evaluate(xctxt, sourceNode, this);

            if (null != stringedValue)
            {

              
              
              
              
							
              rhandler.addAttribute(avt.getURI(), avt.getName(),
                                    avt.getRawName(), ""CDATA"", stringedValue);
            }
          }  
        }

        
        
        transformer.executeChildTemplates(this, true);
      }
      finally
      {
        
        
        rhandler.endElement(getNamespace(), getLocalName(), getRawName());
        unexecuteNSDecls(transformer);
				
				
				rhandler.endPrefixMapping(getPrefix());
      }
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }

  
  public Enumeration enumerateLiteralResultAttributes()
  {
    return (null == m_avts) ? null : m_avts.elements();
  }
  
    
    protected boolean accept(XSLTVisitor visitor)
    {
      return visitor.visitLiteralResultElement(this);
    }

    
    protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
    {
      if (callAttrs && null != m_avts)
      {
        int nAttrs = m_avts.size();

        for (int i = (nAttrs - 1); i >= 0; i--)
        {
          AVT avt = (AVT) m_avts.elementAt(i);
          avt.callVisitors(visitor);
        }
      }
      super.callChildVisitors(visitor, callAttrs);
    }

}
"
org.apache.xml.utils.SAXSourceLocator,8,2,0,17,29,0,17,0,8,0.285714286,119,0.0,0,0.666666667,0.34375,0,0,13.75,2,1.0,0,"
package org.apache.xml.utils;

import java.io.Serializable;

import javax.xml.transform.SourceLocator;

import org.xml.sax.Locator;
import org.xml.sax.SAXParseException;
import org.xml.sax.helpers.LocatorImpl;


public class SAXSourceLocator extends LocatorImpl
        implements SourceLocator, Serializable
{
  
  Locator m_locator;

  
  public SAXSourceLocator(){}

  
  public SAXSourceLocator(Locator locator)
  {
    m_locator = locator;
    this.setColumnNumber(locator.getColumnNumber());
    this.setLineNumber(locator.getLineNumber());
    this.setPublicId(locator.getPublicId());
    this.setSystemId(locator.getSystemId());
  }
  
  
  public SAXSourceLocator(javax.xml.transform.SourceLocator locator)
  {
    m_locator = null;
    this.setColumnNumber(locator.getColumnNumber());
    this.setLineNumber(locator.getLineNumber());
    this.setPublicId(locator.getPublicId());
    this.setSystemId(locator.getSystemId());
  }

  
  
  public SAXSourceLocator(SAXParseException spe)
  {
    this.setLineNumber( spe.getLineNumber() );
    this.setColumnNumber( spe.getColumnNumber() );
    this.setPublicId( spe.getPublicId() );
    this.setSystemId( spe.getSystemId() );
  }
  
  
  public String getPublicId()
  {
    return (null == m_locator) ? super.getPublicId() : m_locator.getPublicId();
  }

  
  public String getSystemId()
  {
    return (null == m_locator) ? super.getSystemId() : m_locator.getSystemId();
  }
  
  
  public int getLineNumber()
  {
    return (null == m_locator) ? super.getLineNumber() : m_locator.getLineNumber();
  }

  
  public int getColumnNumber()
  {
    return (null == m_locator) ? super.getColumnNumber() : m_locator.getColumnNumber();
  }
}
"
org.apache.xalan.xsltc.compiler.FunctionAvailableCall,7,4,0,19,38,7,0,19,5,0.458333333,275,1.0,1,0.941176471,0.285714286,3,13,37.71428571,12,3.2857,0,"

package org.apache.xalan.xsltc.compiler;

import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xalan.xsltc.runtime.TransletLoader;

final class FunctionAvailableCall extends FunctionCall {

    private Expression _arg; 
    private String     _nameOfFunct = null; 
    private String     _namespaceOfFunct = null; 	
    private boolean    _isFunctionAvailable = false; 

    
    public FunctionAvailableCall(QName fname, Vector arguments) {
	super(fname, arguments);
	_arg = (Expression)arguments.elementAt(0);
	_type = null; 

        if (_arg instanceof LiteralExpr) {
	    LiteralExpr arg = (LiteralExpr) _arg;
            _namespaceOfFunct = arg.getNamespace();
            _nameOfFunct = arg.getValue();

            if (!isInternalNamespace()) {
              _isFunctionAvailable = hasMethods();
            }
        }
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_type != null) {
	   return _type;
	}
	if (_arg instanceof LiteralExpr) {
	    return _type = Type.Boolean;
	}
	ErrorMsg err = new ErrorMsg(ErrorMsg.NEED_LITERAL_ERR,
			""function-available"", this);
	throw new TypeCheckError(err);
    }

    
    public Object evaluateAtCompileTime() {
	return getResult() ? Boolean.TRUE : Boolean.FALSE;
    }

    
    private boolean hasMethods() {
	LiteralExpr arg = (LiteralExpr)_arg;
	
	
	String className = getClassNameFromUri(_namespaceOfFunct);
	
	
	String methodName = null;
	int colonIndex = _nameOfFunct.indexOf("":"");
	if (colonIndex > 0) {
	  String functionName = _nameOfFunct.substring(colonIndex+1);
	  int lastDotIndex = functionName.lastIndexOf('.');
	  if (lastDotIndex > 0) {
	    methodName = functionName.substring(lastDotIndex+1);
	    if (className != null && !className.equals(""""))
	      className = className + ""."" + functionName.substring(0, lastDotIndex);
	    else
	      className = functionName.substring(0, lastDotIndex);
	  }
	  else
	    methodName = functionName;
	}
	else
	  methodName = _nameOfFunct;
	  
	if (className == null || methodName == null) {
	    return false;
	}
	
	
	if (methodName.indexOf('-') > 0)
	  methodName = replaceDash(methodName);

	try {
	    TransletLoader loader = new TransletLoader();
	    final Class clazz = loader.loadClass(className);

	    if (clazz == null) {
	    	return false;
	    }
	    else {
		final Method[] methods = clazz.getMethods();

		for (int i = 0; i < methods.length; i++) {
		    final int mods = methods[i].getModifiers();

		    if (Modifier.isPublic(mods)
			&& Modifier.isStatic(mods)
			&& methods[i].getName().equals(methodName))
		    {
			return true;
		    }
		}
	    }
	}
	catch (ClassNotFoundException e) {
	  return false;
	}
        return false;   
    }

    
    public boolean getResult() {
	if (_nameOfFunct == null) { 
	    return false;
	}

        if (isInternalNamespace()) {
            final Parser parser = getParser();
            _isFunctionAvailable = 
		parser.functionSupported(Util.getLocalName(_nameOfFunct));
        }
 	return _isFunctionAvailable;
    }
    
    
    private boolean isInternalNamespace() {
    	return (_namespaceOfFunct == null ||
            _namespaceOfFunct.equals(EMPTYSTRING) ||
	    _namespaceOfFunct.equals(TRANSLET_URI));
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	methodGen.getInstructionList().append(new PUSH(cpg, getResult()));
    }

}
"
org.apache.xalan.templates.DecimalFormatProperties,25,3,0,6,49,0,4,3,25,0.520833333,161,0.5,1,0.890909091,0.253333333,1,1,5.36,2,1.0,2,"
package org.apache.xalan.templates;

import java.text.DecimalFormatSymbols;

import org.apache.xml.utils.QName;


public class DecimalFormatProperties extends ElemTemplateElement
{

  
  DecimalFormatSymbols m_dfs;

  
  public DecimalFormatProperties(int docOrderNumber)
  {

    m_dfs = new java.text.DecimalFormatSymbols();

    
    m_dfs.setInfinity(Constants.ATTRVAL_INFINITY);
    m_dfs.setNaN(Constants.ATTRVAL_NAN);

    m_docOrderNumber = docOrderNumber;
  }

  
  public DecimalFormatSymbols getDecimalFormatSymbols()
  {
    return m_dfs;
  }

  
  private QName m_qname = null;

  
  public void setName(QName qname)
  {
    m_qname = qname;
  }

  
  public QName getName()
  {

    if (m_qname == null)
      return new QName("""");
    else
      return m_qname;
  }

  
  public void setDecimalSeparator(char ds)
  {
    m_dfs.setDecimalSeparator(ds);
  }

  
  public char getDecimalSeparator()
  {
    return m_dfs.getDecimalSeparator();
  }

  
  public void setGroupingSeparator(char gs)
  {
    m_dfs.setGroupingSeparator(gs);
  }

  
  public char getGroupingSeparator()
  {
    return m_dfs.getGroupingSeparator();
  }

  
  public void setInfinity(String inf)
  {
    m_dfs.setInfinity(inf);
  }

  
  public String getInfinity()
  {
    return m_dfs.getInfinity();
  }

  
  public void setMinusSign(char v)
  {
    m_dfs.setMinusSign(v);
  }

  
  public char getMinusSign()
  {
    return m_dfs.getMinusSign();
  }

  
  public void setNaN(String v)
  {
    m_dfs.setNaN(v);
  }

  
  public String getNaN()
  {
    return m_dfs.getNaN();
  }

  
  public void setPercent(char v)
  {
    m_dfs.setPercent(v);
  }

  
  public char getPercent()
  {
    return m_dfs.getPercent();
  }

  
  public void setPerMille(char v)
  {
    m_dfs.setPerMill(v);
  }

  
  public char getPerMille()
  {
    return m_dfs.getPerMill();
  }

  
  public void setZeroDigit(char v)
  {
    m_dfs.setZeroDigit(v);
  }

  
  public char getZeroDigit()
  {
    return m_dfs.getZeroDigit();
  }

  
  public void setDigit(char v)
  {
    m_dfs.setDigit(v);
  }

  
  public char getDigit()
  {
    return m_dfs.getDigit();
  }

  
  public void setPatternSeparator(char v)
  {
    m_dfs.setPatternSeparator(v);
  }

  
  public char getPatternSeparator()
  {
    return m_dfs.getPatternSeparator();
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeDecimalFormats(this);
  }

}
"
org.apache.xalan.transformer.TransformSnapshotImpl,2,1,0,13,31,0,1,13,0,0.142857143,217,0.928571429,9,0.0,1.0,0,0,100.5,3,1.5,0,"
package org.apache.xalan.transformer;

import java.util.Enumeration;
import java.util.Stack;

import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.NamespaceSupport2;
import org.apache.xml.utils.NodeVector;
import org.apache.xml.utils.ObjectStack;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;

import org.xml.sax.helpers.NamespaceSupport;

import org.apache.xml.serializer.NamespaceMappings;
import org.apache.xml.serializer.SerializationHandler;

class TransformSnapshotImpl implements TransformSnapshot
{

  
  private VariableStack m_variableStacks;

  
  private IntStack m_currentNodes;

  
  private IntStack m_currentExpressionNodes;

  
  private Stack m_contextNodeLists;

  
  private DTMIterator m_contextNodeList;

  
  private Stack m_axesIteratorStack;

  
  private BoolStack m_currentTemplateRuleIsNull;

  
  private ObjectStack m_currentTemplateElements;

  
  private Stack m_currentMatchTemplates;

  
  private NodeVector m_currentMatchNodes;

  
  private CountersTable m_countersTable;

  
  private Stack m_attrSetStack;

  
  boolean m_nsContextPushed;

  
  private NamespaceMappings m_nsSupport;

  


  
  TransformSnapshotImpl(TransformerImpl transformer)
  {

    try
    {

      
      SerializationHandler rtf = transformer.getResultTreeHandler();

      {
        
        m_nsSupport = (NamespaceMappings)rtf.getNamespaceMappings().clone();
        
        
      }
 
      XPathContext xpc = transformer.getXPathContext();

      m_variableStacks = (VariableStack) xpc.getVarStack().clone();
      m_currentNodes = (IntStack) xpc.getCurrentNodeStack().clone();
      m_currentExpressionNodes =
        (IntStack) xpc.getCurrentExpressionNodeStack().clone();
      m_contextNodeLists = (Stack) xpc.getContextNodeListsStack().clone();

      if (!m_contextNodeLists.empty())
        m_contextNodeList =
          (DTMIterator) xpc.getContextNodeList().clone();

      m_axesIteratorStack = (Stack) xpc.getAxesIteratorStackStacks().clone();
      m_currentTemplateRuleIsNull =
        (BoolStack) transformer.m_currentTemplateRuleIsNull.clone();
      m_currentTemplateElements =
        (ObjectStack) transformer.m_currentTemplateElements.clone();
      m_currentMatchTemplates =
        (Stack) transformer.m_currentMatchTemplates.clone();
      m_currentMatchNodes =
        (NodeVector) transformer.m_currentMatchedNodes.clone();
      m_countersTable =
        (CountersTable) transformer.getCountersTable().clone();

      if (transformer.m_attrSetStack != null)
        m_attrSetStack = (Stack) transformer.m_attrSetStack.clone();
    }
    catch (CloneNotSupportedException cnse)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(cnse);
    }
  }

  
  void apply(TransformerImpl transformer)
  {

    try
    {

      
      SerializationHandler rtf = transformer.getResultTreeHandler();

      if (rtf != null)
      {
        
         rtf.setNamespaceMappings((NamespaceMappings)m_nsSupport.clone());
      }

      XPathContext xpc = transformer.getXPathContext();

      xpc.setVarStack((VariableStack) m_variableStacks.clone());
      xpc.setCurrentNodeStack((IntStack) m_currentNodes.clone());
      xpc.setCurrentExpressionNodeStack(
        (IntStack) m_currentExpressionNodes.clone());
      xpc.setContextNodeListsStack((Stack) m_contextNodeLists.clone());

      if (m_contextNodeList != null)
        xpc.pushContextNodeList((DTMIterator) m_contextNodeList.clone());

      xpc.setAxesIteratorStackStacks((Stack) m_axesIteratorStack.clone());

      transformer.m_currentTemplateRuleIsNull =
        (BoolStack) m_currentTemplateRuleIsNull.clone();
      transformer.m_currentTemplateElements =
        (ObjectStack) m_currentTemplateElements.clone();
      transformer.m_currentMatchTemplates =
        (Stack) m_currentMatchTemplates.clone();
      transformer.m_currentMatchedNodes =
        (NodeVector) m_currentMatchNodes.clone();
      transformer.m_countersTable = (CountersTable) m_countersTable.clone();

      if (m_attrSetStack != null)
        transformer.m_attrSetStack = (Stack) m_attrSetStack.clone();
    }
    catch (CloneNotSupportedException cnse)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(cnse);
    }
  }
}"
org.apache.xpath.compiler.OpMapVector,4,1,0,2,6,0,2,0,4,0.416666667,87,1.0,0,0.0,1.0,0,0,19.75,2,1.0,1,"

package org.apache.xpath.compiler;


public class OpMapVector {
    
 
  protected int m_blocksize;

  
  protected int m_map[]; 

  
  protected int m_lengthPos = 0;

  
  protected int m_mapSize;
  
    
  public OpMapVector(int blocksize, int increaseSize, int lengthPos)
  {

    m_blocksize = increaseSize;
    m_mapSize = blocksize;
    m_lengthPos = lengthPos;
    m_map = new int[blocksize];
  }
  
  
  public final int elementAt(int i)
  {
    return m_map[i];
  }  
   
    
  public final void setElementAt(int value, int index)
  {
    if (index >= m_mapSize)
    {
      int oldSize = m_mapSize;
      
      m_mapSize += m_blocksize;

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, oldSize);

      m_map = newMap;
    }

    m_map[index] = value;
  }
  
  
  
  public final void setToSize(int size) {
    
    int newMap[] = new int[size];

    System.arraycopy(m_map, 0, newMap, 0, m_map[m_lengthPos]);

    m_mapSize = size;
    m_map = newMap;
    
  }  

}
"
org.apache.xml.utils.DefaultErrorHandler,13,1,1,13,35,58,10,3,13,0.666666667,260,0.0,0,0.0,0.307692308,0,0,18.92307692,11,2.0,1,"
package org.apache.xml.utils;

import java.io.PrintStream;
import java.io.PrintWriter;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;

import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;



public class DefaultErrorHandler implements ErrorHandler, ErrorListener
{
  PrintWriter m_pw;

  
  public DefaultErrorHandler(PrintWriter pw)
  {
    m_pw = pw;
  }
  
  
  public DefaultErrorHandler(PrintStream pw)
  {
    m_pw = new PrintWriter(pw, true);
  }
  
  
  public DefaultErrorHandler()
  {
    m_pw = new PrintWriter(System.err, true);
  }


  
  public void warning(SAXParseException exception) throws SAXException
  {
    printLocation(m_pw, exception);
    m_pw.println(""Parser warning: "" + exception.getMessage());
  }

  
  public void error(SAXParseException exception) throws SAXException
  {
    
    

    throw exception;
  }

  
  public void fatalError(SAXParseException exception) throws SAXException
  {
    
    

    throw exception;
  }
  
  
  public void warning(TransformerException exception) throws TransformerException
  {
    printLocation(m_pw, exception);

    m_pw.println(exception.getMessage());
  }

  
  public void error(TransformerException exception) throws TransformerException
  {
    
    

    throw exception;
  }

  
  public void fatalError(TransformerException exception) throws TransformerException
  {
    
    

    throw exception;
  }
  
  public static void ensureLocationSet(TransformerException exception)
  {
    
    SourceLocator locator = null;
    Throwable cause = exception;
    
    
    do
    {
      if(cause instanceof SAXParseException)
      {
        locator = new SAXSourceLocator((SAXParseException)cause);
      }
      else if (cause instanceof TransformerException)
      {
        SourceLocator causeLocator = ((TransformerException)cause).getLocator();
        if(null != causeLocator)
          locator = causeLocator;
      }
      
      if(cause instanceof TransformerException)
        cause = ((TransformerException)cause).getCause();
      else if(cause instanceof SAXException)
        cause = ((SAXException)cause).getException();
      else
        cause = null;
    }
    while(null != cause);
    
    exception.setLocator(locator);
  }
  
  public static void printLocation(PrintStream pw, TransformerException exception)
  {
    printLocation(new PrintWriter(pw), exception);
  }
  
  public static void printLocation(java.io.PrintStream pw, org.xml.sax.SAXParseException exception)
  {
    printLocation(new PrintWriter(pw), exception);
  }
  
  public static void printLocation(PrintWriter pw, Throwable exception)
  {
    SourceLocator locator = null;
    Throwable cause = exception;
    
    
    do
    {
      if(cause instanceof SAXParseException)
      {
        locator = new SAXSourceLocator((SAXParseException)cause);
      }
      else if (cause instanceof TransformerException)
      {
        SourceLocator causeLocator = ((TransformerException)cause).getLocator();
        if(null != causeLocator)
          locator = causeLocator;
      }
      if(cause instanceof TransformerException)
        cause = ((TransformerException)cause).getCause();
      else if(cause instanceof WrappedRuntimeException)
        cause = ((WrappedRuntimeException)cause).getException();
      else if(cause instanceof SAXException)
        cause = ((SAXException)cause).getException();
      else
        cause = null;
    }
    while(null != cause);
        
    if(null != locator)
    {
      
      String id = (null != locator.getPublicId() )
                  ? locator.getPublicId()
                    : (null != locator.getSystemId())
                      ? locator.getSystemId() : XMLMessages.createXMLMessage(XMLErrorResources.ER_SYSTEMID_UNKNOWN, null); 

      pw.print(id + ""; "" +XMLMessages.createXMLMessage(""line"", null) + locator.getLineNumber()
                         + ""; "" +XMLMessages.createXMLMessage(""column"", null) + locator.getColumnNumber()+""; "");
    }
    else
      pw.print(""(""+XMLMessages.createXMLMessage(XMLErrorResources.ER_LOCATION_UNKNOWN, null)+"")"");
  }
}
"
org.apache.xml.utils.UnImplNode,107,1,1,2,117,5671,1,1,107,2.0,648,0.0,0,0.0,0.191069574,0,0,5.056074766,1,0.9907,1,"
package org.apache.xml.utils;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;

import org.w3c.dom.Attr;
import org.w3c.dom.CDATASection;
import org.w3c.dom.Comment;
import org.w3c.dom.DOMException;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.EntityReference;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Text;


public class UnImplNode implements Node, Element, NodeList, Document
{

  
  public UnImplNode(){}

  
  public void error(String msg)
  {

    System.out.println(""DOM ERROR! class: "" + this.getClass().getName());

    throw new RuntimeException(XMLMessages.createXMLMessage(msg, null));
  }

  
  public void error(String msg, Object[] args)
  {

    System.out.println(""DOM ERROR! class: "" + this.getClass().getName());

    throw new RuntimeException(XMLMessages.createXMLMessage(msg, args));  
  }

  
  public Node appendChild(Node newChild) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean hasChildNodes()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public short getNodeType()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return 0;
  }

  
  public Node getParentNode()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public NodeList getChildNodes()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node getFirstChild()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node getLastChild()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node getNextSibling()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public int getLength()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return 0;
  }  

  
  public Node item(int index)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }  

  
  public Document getOwnerDocument()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public String getTagName()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public String getNodeName()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void normalize()
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public NodeList getElementsByTagName(String name)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Attr removeAttributeNode(Attr oldAttr) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Attr setAttributeNode(Attr newAttr) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean hasAttribute(String name)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public boolean hasAttributeNS(String name, String x)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public Attr getAttributeNode(String name)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void removeAttribute(String name) throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public void setAttribute(String name, String value) throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public String getAttribute(String name)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean hasAttributes()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public NodeList getElementsByTagNameNS(String namespaceURI,
                                         String localName)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Attr setAttributeNodeNS(Attr newAttr) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Attr getAttributeNodeNS(String namespaceURI, String localName)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void removeAttributeNS(String namespaceURI, String localName)
          throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public void setAttributeNS(
          String namespaceURI, String qualifiedName, String value)
            throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public String getAttributeNS(String namespaceURI, String localName)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node getPreviousSibling()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node cloneNode(boolean deep)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public String getNodeValue() throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void setNodeValue(String nodeValue) throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  

  
  
  
  
  

  
  public void setValue(String value) throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  

  
  
  
  

  
  public Element getOwnerElement()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean getSpecified()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public NamedNodeMap getAttributes()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node insertBefore(Node newChild, Node refChild) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node replaceChild(Node newChild, Node oldChild) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node removeChild(Node oldChild) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean isSupported(String feature, String version)
  {
    return false;
  }

  
  public String getNamespaceURI()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public String getPrefix()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void setPrefix(String prefix) throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public String getLocalName()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public DocumentType getDoctype()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public DOMImplementation getImplementation()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Element getDocumentElement()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Element createElement(String tagName) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public DocumentFragment createDocumentFragment()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Text createTextNode(String data)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Comment createComment(String data)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public CDATASection createCDATASection(String data) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public ProcessingInstruction createProcessingInstruction(
          String target, String data) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Attr createAttribute(String name) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public EntityReference createEntityReference(String name)
          throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Node importNode(Node importedNode, boolean deep) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Element createElementNS(String namespaceURI, String qualifiedName)
          throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Attr createAttributeNS(String namespaceURI, String qualifiedName)
          throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Element getElementById(String elementId)
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public void setData(String data) throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public String substringData(int offset, int count) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public void appendData(String arg) throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public void insertData(int offset, String arg) throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public void deleteData(int offset, int count) throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public void replaceData(int offset, int count, String arg)
          throws DOMException
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public Text splitText(int offset) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Node adoptNode(Node source) throws DOMException
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public String getEncoding()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public void setEncoding(String encoding)
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public boolean getStandalone()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return false;
  }

  
  public void setStandalone(boolean standalone)
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public boolean getStrictErrorChecking()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return false;
  }

  
  public void setStrictErrorChecking(boolean strictErrorChecking)
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public String getVersion()
  {

    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public void setVersion(String version)
  {
    error(XMLErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }
}
"
org.apache.xml.res.XMLErrorResources_ko,3,4,0,1,4,1,0,1,2,1.3,875,0.0,0,0.976190476,1.0,0,0,289.0,1,0.3333,0,"
package org.apache.xml.res;



public class XMLErrorResources_ko extends XMLErrorResources
{

  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },


  
  


  {
    ER_FUNCTION_NOT_SUPPORTED, ""기능이 지원되지 않습니다!""},

  
  
  


  {
    ER_CANNOT_OVERWRITE_CAUSE,
			""겹쳐쓸 수 없습니다""},

  
   
  


  {
    ER_NO_DEFAULT_IMPL,
         ""기본 구현을 찾을 수 없습니다""},

  
   
  


  {
    ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
       ""ChunkedIntArray({0})는 현재 지원되지 않습니다.""},

  
   
  


  {
    ER_OFFSET_BIGGER_THAN_SLOT,
       ""오프셋이 슬롯보다 큽니다""},

  
   
  


  {
    ER_COROUTINE_NOT_AVAIL,
       ""Coroutine은 사용할 수 없습니다, ID={0}""},

  
   
  


  {
    ER_COROUTINE_CO_EXIT,
       ""CoroutineManager가 co_exit() 요청을 수신했습니다""},

  
   
  


  {
    ER_COJOINROUTINESET_FAILED,
       ""co_joinCoroutineSet()이 실패했습니다""},

  
   
  


  {
    ER_COROUTINE_PARAM,
       ""Coroutine 매개변수 오류({0})""},

  
   
  


  {
    ER_PARSER_DOTERMINATE_ANSWERS,
       ""
예상치 못한 문제: doTerminate 구문 분석기가 {0}에 응답했습니다. ""},

  
   
  


  {
    ER_NO_PARSE_CALL_WHILE_PARSING,
       ""구문 분석하는 동안에는 구문 분석을 호출할 수 없습니다""},

  
   
  


  {
    ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""오류: {0} 축에 대해 입력된 반복기가 구현되지 않습니다.""},

  
   
  


  {
    ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""오류: {0} 축에 대한 반복기가 구현되지 않습니다. ""},

  
   
  


  {
    ER_ITERATOR_CLONE_NOT_SUPPORTED,
       ""반복기 복제가 지원되지 않습니다""},

  
   
  


  {
    ER_UNKNOWN_AXIS_TYPE,
       ""알 수 없는 축 순회 유형: {0}""},

  
   
  


  {
    ER_AXIS_NOT_SUPPORTED,
       ""축 순회기가 지원되지 않습니다: {0}""},

  
   
  


  {
    ER_NO_DTMIDS_AVAIL,
       ""더 이상 DTM ID를 사용할 수 없습니다.""},

  
   
  


  {
    ER_NOT_SUPPORTED,
       ""지원되지 않습니다: {0}""},

  
   
  


  {
    ER_NODE_NON_NULL,
       ""노드는 getDTMHandleFromNode에 대해 널이 아니어야 합니다""},

  
   
  


  {
    ER_COULD_NOT_RESOLVE_NODE,
       ""노드를 핸들로 변환할 수 없습니다""},

  
   
  


  {
    ER_STARTPARSE_WHILE_PARSING,
       ""startParse는 구문 분석 중에 호출될 수 없습니다""},

  
   
  


  {
    ER_STARTPARSE_NEEDS_SAXPARSER,
       ""startParse에는 널이 아닌 SAXParser가 필요합니다""},

  
   
  


  {
    ER_COULD_NOT_INIT_PARSER,
       ""다음으로 구문 분석기를 초기화할 수 없습니다: ""},

  
   
  


  {
    ER_EXCEPTION_CREATING_POOL,
       ""풀에 대한 새 인스턴스 작성 중 예외가 발생했습니다""},

  
   
  


  {
    ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
       ""경로에 잘못된 제어 문자열이 포함되어 있습니다""},

  
   
  


  {
    ER_SCHEME_REQUIRED,
       ""체계가 필요합니다!""},

  
   
  


  {
    ER_NO_SCHEME_IN_URI,
       ""URI에  체계가 없습니다: {0}""},

  
   
  


  {
    ER_NO_SCHEME_INURI,
       ""URI에 체계가 없습니다""},

  
   
  


  {
    ER_PATH_INVALID_CHAR,
       ""경로에 잘못된 문자 {0}이(가) 포함되어 있습니다.""},

  
   
  


  {
    ER_SCHEME_FROM_NULL_STRING,
       ""널 문자열에서 체계를 설정할 수 없습니다""},

  
   
  


  {
    ER_SCHEME_NOT_CONFORMANT,
       ""체계가 일치하지 않습니다.""},

  
   
  


  {
    ER_HOST_ADDRESS_NOT_WELLFORMED,
       ""호스트 주소가 올바른 형식이 아닙니다""},

  
   
  


  {
    ER_PORT_WHEN_HOST_NULL,
       ""호스트가 널이면 포트를 설정할 수 없습니다""},

  
   
  


  {
    ER_INVALID_PORT,
       ""잘못된 포트 번호입니다""},

  
   
  


  {
    ER_FRAG_FOR_GENERIC_URI,
       ""단편은 일반 URI에 대해서만 설정될 수 있습니다""},

  
   
  


  {
    ER_FRAG_WHEN_PATH_NULL,
       ""경로가 널이면 단편을 설정할 수 없습니다""},

  
   
  


  {
    ER_FRAG_INVALID_CHAR,
       ""단편에 잘못된 문자가 포함되어 있습니다""},

  
 
  
   
  


  {
    ER_PARSER_IN_USE,
        ""구문 분석기가 이미 사용 중입니다""},

  
   
  


  {
    ER_CANNOT_CHANGE_WHILE_PARSING,
        ""구문 분석 중에는 {0} {1}을(를) 변경할 수 없습니다""},

  
   
  


  {
    ER_SELF_CAUSATION_NOT_PERMITTED,
        ""자체 원인 제공은 허용되지 않습니다""},

  
   
  


  {
    ER_NO_USERINFO_IF_NO_HOST,
        ""호스트가 지정되어 있지 않으면 Userinfo를 지정할 수 없습니다""},

  
   
  


  {
    ER_NO_PORT_IF_NO_HOST,
        ""호스트가 지정되어 있지 않으면 포트를 지정할 수 없습니다""},

  
   
  


  {
    ER_NO_QUERY_STRING_IN_PATH,
        ""질의 문자열을 경로 또는 질의 문자열 내에 지정할 수 없습니다""},

  
   
  


  {
    ER_NO_FRAGMENT_STRING_IN_PATH,
        ""단편을 경로와 단편 모두에 지정할 수는 없습니다""},

  
   
  


  {
    ER_CANNOT_INIT_URI_EMPTY_PARMS,
        ""빈 매개변수로는 URI를 초기화할 수 없습니다""},

  
  
  


  {
    ER_METHOD_NOT_SUPPORTED,
        ""지원되지 않는 메소드입니다 ""},


  
  


  {
    ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
     ""IncrementalSAXSource_Filter를 다시 시작할 수 없습니다""},

  
  
  


  {
    ER_XMLRDR_NOT_BEFORE_STARTPARSE,
     ""startParse 요청 전에 XMLReader를 수행할 수 없습니다""},



  

  {
    ER_AXIS_TRAVERSER_NOT_SUPPORTED,
     ""축 트래버서가 지원되지 않음: {0}""},



  

  {
    ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
     ""ListingErrorHandler가 널 PrintWriter로 작성됨!""},


  

  {
    ER_SYSTEMID_UNKNOWN,
     ""시스템 ID를 알 수 없음""},


  
  

  {
    ER_LOCATION_UNKNOWN,
     ""오류 위치를 알 수 없음""},
 

  
  

 
  {
    ER_PREFIX_MUST_RESOLVE,
      ""접두어가 이름 공간 {0}으로(로) 결정되어야 합니다.""},
 

  
  

 
  {
    ER_CREATEDOCUMENT_NOT_SUPPORTED,
      ""createDocument()는 XPathContext에서 지원되지 않습니다!""},
 

  
  

 
  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT,
      ""자식 속성에 소유자 문서가 없습니다!""},
 

  
  

 
  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
      ""자식 속성에 소유자 문서 요소가 없습니다!""},
 

  
  

 
  {
    ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
      ""경고: 문서 요소 전에 텍스트를 출력할 수 없습니다! 무시됩니다...""},
 

  
  

 
  {
    ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
      ""DOM에 두 개 이상의 루트를 가질 수 없습니다!""},
 
  
   
  

 
  {
    ER_ARG_LOCALNAME_NULL,
       ""'localName' 인자가 널입니다""},
 

  
  
  

  
  

 
  {
    ER_ARG_LOCALNAME_INVALID,
       ""QNAME의 로컬 이름은 유효한 NCName이어야 합니다.""},
 
  
  
  
  

  
  

 
  {
    ER_ARG_PREFIX_INVALID,
       ""QNAME의 접두어는 유효한 NCName이어야 합니다.""},

  { ""BAD_CODE"",
      ""createMessage의 매개변수가 바운드를 벗어났습니다.""},
  { ""FORMAT_FAILED"",
      ""messageFormat 호출 시 예외 발생""},
  { ""line"", ""행 #""},
  { ""column"", ""열 #""}
  
  };

  
  public Object[][] getContents()
  {
    return contents;
  }
  
}"
org.apache.xpath.XPathFactory,1,1,0,5,1,0,3,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"
package org.apache.xpath;

import javax.xml.transform.SourceLocator;

import org.apache.xml.utils.PrefixResolver;


public interface XPathFactory
{

  
  XPath create(String exprString, SourceLocator locator,
               PrefixResolver prefixResolver, int type);
}
"
org.apache.xml.dtm.ref.ExtendedType,9,1,0,8,12,0,8,0,7,0.40625,117,1.0,0,0.0,0.5,1,2,11.55555556,4,1.1111,0,"
package org.apache.xml.dtm.ref;


public final class ExtendedType
{
    private int nodetype;
    private String namespace;
    private String localName;
    private int hash;

    
    public ExtendedType (int nodetype, String namespace, String localName)
    {
      this.nodetype = nodetype;
      this.namespace = namespace;
      this.localName = localName;
      this.hash = nodetype + namespace.hashCode() + localName.hashCode();
    }

    
    public ExtendedType (int nodetype, String namespace, String localName, int hash)
    {
      this.nodetype = nodetype;
      this.namespace = namespace;
      this.localName = localName;
      this.hash = hash;
    }

    
    protected void redefine(int nodetype, String namespace, String localName)
    {
      this.nodetype = nodetype;
      this.namespace = namespace;
      this.localName = localName;
      this.hash = nodetype + namespace.hashCode() + localName.hashCode();
    }

    
    protected void redefine(int nodetype, String namespace, String localName, int hash)
    {
      this.nodetype = nodetype;
      this.namespace = namespace;
      this.localName = localName;
      this.hash = hash;
    }

    
    public int hashCode()
    {
      return hash;
    }

    
    public boolean equals(ExtendedType other)
    {
      try
      {
        return other.nodetype == this.nodetype &&
                other.localName.equals(this.localName) &&
                other.namespace.equals(this.namespace);
      }
      catch(NullPointerException e)
      {
        return false;
      }
    }
    
    
    public int getNodeType()
    {
      return nodetype;
    }
    
    
    public String getLocalName()
    {
      return localName;
    }
    
    
    public String getNamespace()
    {
      return namespace;
    }

}
"
org.apache.xml.utils.res.XResourceBundle,5,3,18,19,16,8,19,0,3,1.223684211,424,0.0,0,0.926829268,0.416666667,0,0,80.0,3,1.0,1,"
package org.apache.xml.utils.res;

import java.util.ListResourceBundle;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;


public class XResourceBundle extends ListResourceBundle
{

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xalan.res.XSLTErrorResources"", XSLT_RESOURCE =
    ""org.apache.xml.utils.res.XResourceBundle"", LANG_BUNDLE_NAME =
    ""org.apache.xml.utils.res.XResources"", MULT_ORDER =
    ""multiplierOrder"", MULT_PRECEDES = ""precedes"", MULT_FOLLOWS =
    ""follows"", LANG_ORIENTATION = ""orientation"", LANG_RIGHTTOLEFT =
    ""rightToLeft"", LANG_LEFTTORIGHT = ""leftToRight"", LANG_NUMBERING =
    ""numbering"", LANG_ADDITIVE = ""additive"", LANG_MULT_ADD =
    ""multiplicative-additive"", LANG_MULTIPLIER =
    ""multiplier"", LANG_MULTIPLIER_CHAR =
    ""multiplierChar"", LANG_NUMBERGROUPS = ""numberGroups"", LANG_NUM_TABLES =
    ""tables"", LANG_ALPHABET = ""alphabet"", LANG_TRAD_ALPHABET = ""tradAlphabet"";

  
  public static final XResourceBundle loadResourceBundle(
          String className, Locale locale) throws MissingResourceException
  {

    String suffix = getResourceSuffix(locale);

    
    try
    {
      
      
      String resourceName = className + suffix;
      return (XResourceBundle) ResourceBundle.getBundle(resourceName, locale);
    }
    catch (MissingResourceException e)
    {
      try  
      {

        
        
        return (XResourceBundle) ResourceBundle.getBundle(
          XSLT_RESOURCE, new Locale(""en"", ""US""));
      }
      catch (MissingResourceException e2)
      {

        
        
        throw new MissingResourceException(
          ""Could not load any resource bundles."", className, """");
      }
    }
  }

  
  private static final String getResourceSuffix(Locale locale)
  {

    String lang = locale.getLanguage();
    String country = locale.getCountry();
    String variant = locale.getVariant();
    String suffix = ""_"" + locale.getLanguage();

    if (lang.equals(""zh""))
      suffix += ""_"" + country;

    if (country.equals(""JP""))
      suffix += ""_"" + country + ""_"" + variant;

    return suffix;
  }

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""en"" }, { ""help_language"", ""en"" }, { ""language"", ""en"" },
    { ""alphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },
  };
}
"
org.apache.xalan.xsltc.compiler.WithParam,6,3,0,21,39,0,0,21,5,0.4,201,1.0,2,0.918032787,0.361111111,1,7,32.16666667,3,1.6667,2,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class WithParam extends Instruction {

    private QName _name;
    private Expression _select;

    
    public void display(int indent) {
	indent(indent);
	Util.println(""with-param "" + _name);
	if (_select != null) {
	    indent(indent + IndentIncrement);
	    Util.println(""select "" + _select.toString());
	}
	displayContents(indent + IndentIncrement);
    }

    
    public void parseContents(Parser parser) {
	final String name = getAttribute(""name"");
	if (name.length() > 0) {
	    _name = parser.getQName(name);
	}
        else {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""name"");
        }
	
	final String select = getAttribute(""select"");
	if (select.length() > 0) {
	    _select = parser.parseExpression(this, ""select"", null);
	}
	
	parseChildren(parser);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_select != null) {
	    final Type tselect = _select.typeCheck(stable);
	    if (tselect instanceof ReferenceType == false) {
		_select = new CastExpr(_select, Type.Reference);
	    }
	}
	else {
	    typeCheckContents(stable);
	}
	return Type.Void;
    }

    
    public void translateValue(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	
	if (_select != null) {
	    _select.translate(classGen, methodGen);
	    _select.startResetIterator(classGen, methodGen);
	}
	
	else if (hasContents()) {
	    compileResultTree(classGen, methodGen);
	}
	
	else {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();
	    il.append(new PUSH(cpg, Constants.EMPTYSTRING));
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	String name = Util.escape(_name.getLocalPart());

	
	il.append(classGen.loadTranslet());

	
	il.append(new PUSH(cpg, name)); 
	
	translateValue(classGen, methodGen);
	
	il.append(new PUSH(cpg, false));
	
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
						     ADD_PARAMETER,
						     ADD_PARAMETER_SIG)));
	il.append(POP); 
    }
}
"
org.apache.xalan.lib.PipeDocument,3,1,0,10,46,3,0,10,3,2.0,257,0.0,0,0.0,0.466666667,0,0,84.66666667,1,0.6667,1,"
package org.apache.xalan.lib;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Properties;
import java.util.Vector;

import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamSource;

import org.apache.xalan.extensions.XSLProcessorContext;
import org.apache.xalan.templates.AVT;
import org.apache.xalan.templates.ElemExtensionCall;
import org.apache.xalan.templates.ElemLiteralResult;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xpath.XPathContext;

import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;

import org.apache.xml.serializer.Serializer;
import org.apache.xml.serializer.SerializerFactory;


public class PipeDocument
{

  public void pipeDocument(XSLProcessorContext context, ElemExtensionCall elem)
	  throws TransformerException, TransformerConfigurationException, 
         SAXException, IOException, FileNotFoundException	   
  {
    try
    {
      SAXTransformerFactory saxTFactory = (SAXTransformerFactory) TransformerFactory.newInstance();
      
      
      String source =  elem.getAttribute(""source"", 
                                         context.getContextNode(),
                                         context.getTransformer());
      TransformerImpl transImpl = context.getTransformer();

      
      String baseURLOfSource = transImpl.getBaseURLOfSource();
      
      String absSourceURL = SystemIDResolver.getAbsoluteURI(source, baseURLOfSource);      

      
      String target =  elem.getAttribute(""target"", 
                                         context.getContextNode(),
                                         context.getTransformer());
      
      XPathContext xctxt = context.getTransformer().getXPathContext();
      int xt = xctxt.getDTMHandleFromNode(context.getContextNode());
 
      
      String sysId = elem.getSystemId();
      
      NodeList ssNodes = null;
      NodeList paramNodes = null;
      Node ssNode = null;
      Node paramNode = null;
      if (elem.hasChildNodes())
      {
        ssNodes = elem.getChildNodes();        
        
        Vector vTHandler = new Vector(ssNodes.getLength());
        
        
        
        
        
        for (int i = 0; i < ssNodes.getLength(); i++)
        {
          ssNode = ssNodes.item(i);
          if (ssNode.getNodeType() == Node.ELEMENT_NODE
              && ((Element)ssNode).getTagName().equals(""stylesheet"")
              && ssNode instanceof ElemLiteralResult)
          {
            AVT avt = ((ElemLiteralResult)ssNode).getLiteralResultAttribute(""href"");
            String href = avt.evaluate(xctxt,xt, elem);
            String absURI = SystemIDResolver.getAbsoluteURI(href, sysId);
            Templates tmpl = saxTFactory.newTemplates(new StreamSource(absURI));
            TransformerHandler tHandler = saxTFactory.newTransformerHandler(tmpl);
            Transformer trans = tHandler.getTransformer();
            
            
            vTHandler.addElement(tHandler);

            paramNodes = ssNode.getChildNodes();
            for (int j = 0; j < paramNodes.getLength(); j++)
            {
              paramNode = paramNodes.item(j);
              if (paramNode.getNodeType() == Node.ELEMENT_NODE 
                  && ((Element)paramNode).getTagName().equals(""param"")
                  && paramNode instanceof ElemLiteralResult)
              {
                 avt = ((ElemLiteralResult)paramNode).getLiteralResultAttribute(""name"");
                 String pName = avt.evaluate(xctxt,xt, elem);
                 avt = ((ElemLiteralResult)paramNode).getLiteralResultAttribute(""value"");
                 String pValue = avt.evaluate(xctxt,xt, elem);
                 trans.setParameter(pName, pValue);
               } 
             }
           }
         }
         usePipe(vTHandler, absSourceURL, target);
       }
     }
     catch (Exception e)
     {
       e.printStackTrace();
     }
  }
  
  public void usePipe(Vector vTHandler, String source, String target)
          throws TransformerException, TransformerConfigurationException, 
                 FileNotFoundException, IOException, SAXException, SAXNotRecognizedException
  {
    XMLReader reader = XMLReaderFactory.createXMLReader();
    TransformerHandler tHFirst = (TransformerHandler)vTHandler.firstElement();
    reader.setContentHandler(tHFirst);
    reader.setProperty(""http:
    for (int i = 1; i < vTHandler.size(); i++)
    {
      TransformerHandler tHFrom = (TransformerHandler)vTHandler.elementAt(i-1);
      TransformerHandler tHTo = (TransformerHandler)vTHandler.elementAt(i);
      tHFrom.setResult(new SAXResult(tHTo));      
    }
    TransformerHandler tHLast = (TransformerHandler)vTHandler.lastElement();
    Transformer trans = tHLast.getTransformer();
    Properties outputProps = trans.getOutputProperties();
    Serializer serializer = SerializerFactory.getSerializer(outputProps);
    serializer.setOutputStream(new FileOutputStream(target));
    tHLast.setResult(new SAXResult(serializer.asContentHandler()));
    
    reader.parse(source);
  }
 
}
"
org.apache.xalan.xsltc.compiler.Variable,6,4,0,34,48,1,10,28,5,2.0,282,0.0,0,0.938271605,0.4,2,13,46.0,8,3.6667,1,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.classfile.Field;
import org.apache.bcel.generic.ACONST_NULL;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.DCONST;
import org.apache.bcel.generic.ICONST;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.xalan.xsltc.compiler.util.BooleanType;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.IntType;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.RealType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class Variable extends VariableBase {

    public int getIndex() {
	return (_local != null) ? _local.getIndex() : -1;
    }

    
    public void parseContents(Parser parser) {
	
	super.parseContents(parser);

	
	SyntaxTreeNode parent = getParent();
	if (parent instanceof Stylesheet) {
	    
	    _isLocal = false;
	    
	    Variable var = parser.getSymbolTable().lookupVariable(_name);
	    
	    if (var != null) {
		final int us = this.getImportPrecedence();
		final int them = var.getImportPrecedence();
		
		if (us == them) {
		    final String name = _name.toString();
		    reportError(this, parser, ErrorMsg.VARIABLE_REDEF_ERR,name);
		}
		
		else if (them > us) {
		    _ignore = true;
		    return;
		}
		else {
		    var.disable();
		}
		
	    }
	    ((Stylesheet)parent).addVariable(this);
	    parser.getSymbolTable().addVariable(this);
	}
	else {
	    _isLocal = true;
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	if (_select != null) {
	    _type = _select.typeCheck(stable);
	}
	
	else if (hasContents()) {
	    typeCheckContents(stable);
	    _type = Type.ResultTree;
	}
	else {
	    _type = Type.Reference;
	}
	
	
	
	return Type.Void;
    }

    
    public void initialize(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	if (isLocal() && !_refs.isEmpty()) {
	    
	    if (_local == null) {
		_local = methodGen.addLocalVariable2(_name.getLocalPart(),
						     _type.toJCType(),
						     il.getEnd());
	    }
	    
	    if ((_type instanceof IntType) ||
		(_type instanceof NodeType) ||
		(_type instanceof BooleanType))
		il.append(new ICONST(0)); 
	    else if (_type instanceof RealType)
		il.append(new DCONST(0)); 
	    else
		il.append(new ACONST_NULL()); 
	    il.append(_type.STORE(_local.getIndex()));
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final String name = getVariable();

	
	if (_ignore) return;
	_ignore = true;

	if (isLocal()) {
	    
	    translateValue(classGen, methodGen);

	    
	    if (_refs.isEmpty()) { 
		il.append(_type.POP());
		_local = null;
	    }
	    else {		   
		if (_local == null) mapRegister(methodGen);
		il.append(_type.STORE(_local.getIndex()));
	    }
	}
	else {
	    String signature = _type.toSignature();

	    
	    if (classGen.containsField(name) == null) {
		classGen.addField(new Field(ACC_PUBLIC, 
					    cpg.addUtf8(name),
					    cpg.addUtf8(signature),
					    null, cpg.getConstantPool()));

		
		il.append(classGen.loadTranslet());
		
		translateValue(classGen, methodGen);
		
		il.append(new PUTFIELD(cpg.addFieldref(classGen.getClassName(),
						       name, signature)));
	    }
	}
    }
}
"
org.apache.xalan.xsltc.compiler.SyntaxTreeNode,55,1,5,97,116,1101,74,43,10,0.912037037,1105,1.0,6,0.0,0.149691358,0,0,18.87272727,18,2.1818,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import org.apache.bcel.generic.ANEWARRAY;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.DUP_X1;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.ICONST;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.DOM;

import org.xml.sax.Attributes;


public abstract class SyntaxTreeNode implements Constants {

    
    private Parser _parser;

    
    protected SyntaxTreeNode _parent;          
    private Stylesheet       _stylesheet;      
    private Template         _template;        
    private final Vector _contents = new Vector(2); 

    
    protected QName _qname;                    
    private int _line;                         
    protected Attributes _attributes = null;   
    private   Hashtable _prefixMapping = null; 

    
    protected static final SyntaxTreeNode Dummy = new AbsolutePathPattern(null);

    
    protected static final int IndentIncrement = 4;
    private static final char[] _spaces = 
	""                                                       "".toCharArray();

    
    public SyntaxTreeNode() {
	_line = 0;
	_qname = null;
    }

    
    public SyntaxTreeNode(int line) {
	_line = line;
	_qname = null;
    }

    
    public SyntaxTreeNode(String uri, String prefix, String local) {
	_line = 0;
	setQName(uri, prefix, local);
    }

    
    protected final void setLineNumber(int line) {
	_line = line;
    }

    
    public final int getLineNumber() {
	return _line;
    }

    
    protected void setQName(QName qname) {
	_qname = qname;
    }

    
    protected void setQName(String uri, String prefix, String localname) {
	_qname = new QName(uri, prefix, localname);
    }

    
    protected QName getQName() {
	return(_qname);
    }

    
    protected void setAttributes(Attributes attributes) {
	_attributes = attributes;
    }

    
    protected String getAttribute(String qname) {
	if (_attributes == null) {
	    return EMPTYSTRING;
	}
	final String value = _attributes.getValue(qname);
	return (value == null || value.equals(EMPTYSTRING)) ? 
	    EMPTYSTRING : value;
    }

    protected boolean hasAttribute(String qname) {
	return (_attributes != null && _attributes.getValue(qname) != null);
    }

    
    protected Attributes getAttributes() {
	return(_attributes);
    }

    
    protected void setPrefixMapping(Hashtable mapping) {
	_prefixMapping = mapping;
    }

    
    protected Hashtable getPrefixMapping() {
	return _prefixMapping;
    }

    
    protected void addPrefixMapping(String prefix, String uri) {
	if (_prefixMapping == null)
	    _prefixMapping = new Hashtable();
	_prefixMapping.put(prefix, uri);
    }

    
    protected String lookupNamespace(String prefix) {
	
	String uri = null;

	
	if (_prefixMapping != null)
	    uri = (String)_prefixMapping.get(prefix);
	
	if ((uri == null) && (_parent != null)) {
	    uri = _parent.lookupNamespace(prefix);
	    if ((prefix == Constants.EMPTYSTRING) && (uri == null))
		uri = Constants.EMPTYSTRING;
	}
	
	return(uri);
    }

    
    protected String lookupPrefix(String uri) {
	
	String prefix = null;

	
	if ((_prefixMapping != null) &&
	    (_prefixMapping.contains(uri))) {
	    Enumeration prefixes = _prefixMapping.keys();
	    while (prefixes.hasMoreElements()) {
		prefix = (String)prefixes.nextElement();
		String mapsTo = (String)_prefixMapping.get(prefix);
		if (mapsTo.equals(uri)) return(prefix);
	    }
	}
	
	else if (_parent != null) {
	    prefix = _parent.lookupPrefix(uri);
	    if ((uri == Constants.EMPTYSTRING) && (prefix == null))
		prefix = Constants.EMPTYSTRING;
	}
	return(prefix);
    }

    
    protected void setParser(Parser parser) {
	_parser = parser;
    }

    
    public final Parser getParser() {
	return _parser;
    }

    
    protected void setParent(SyntaxTreeNode parent) {
	if (_parent == null)
	    _parent = parent;
    }

    
    protected final SyntaxTreeNode getParent() {
	return _parent;
    }

    
    protected final boolean isDummy() {
        return this == Dummy;
    }

    
    protected int getImportPrecedence() {
	Stylesheet stylesheet = getStylesheet();
	if (stylesheet == null) return Integer.MIN_VALUE;
	return stylesheet.getImportPrecedence();
    }

    
    public Stylesheet getStylesheet() {
	if (_stylesheet == null) {
	    SyntaxTreeNode parent = this;
	    while (parent != null) {
		if (parent instanceof Stylesheet)
		    return((Stylesheet)parent);
		parent = parent.getParent();
	    }
	    _stylesheet = (Stylesheet)parent;
	}
	return(_stylesheet);
    }

    
    protected Template getTemplate() {
	if (_template == null) {
	    SyntaxTreeNode parent = this;
	    while ((parent != null) && (!(parent instanceof Template)))
		parent = parent.getParent();
	    _template = (Template)parent;
	}
	return(_template);
    }

    
    protected final XSLTC getXSLTC() {
	return _parser.getXSLTC();
    }

    
    protected final SymbolTable getSymbolTable() {
	return (_parser == null) ? null : _parser.getSymbolTable();
    }

    
    public void parseContents(Parser parser) {
	parseChildren(parser);
    }

    
    protected final void parseChildren(Parser parser) {

	Vector locals = null;	
	
	final int count = _contents.size();
	for (int i=0; i<count; i++) {
	    SyntaxTreeNode child = (SyntaxTreeNode)_contents.elementAt(i);
	    parser.getSymbolTable().setCurrentNode(child);
	    child.parseContents(parser);
	    
	    final QName varOrParamName = updateScope(parser, child);
	    if (varOrParamName != null) {
		if (locals == null) {
		    locals = new Vector(2);
		}
		locals.addElement(varOrParamName);
	    }
	}

	parser.getSymbolTable().setCurrentNode(this);

	
	if (locals != null) {
	    final int nLocals = locals.size();
	    for (int i = 0; i < nLocals; i++) {
		parser.removeVariable((QName)locals.elementAt(i));
	    }
	}
    }
   
    
    protected QName updateScope(Parser parser, SyntaxTreeNode node) {
	if (node instanceof Variable) {
	    final Variable var = (Variable)node;
	    parser.addVariable(var);
	    return var.getName();
	}
	else if (node instanceof Param) {
	    final Param param = (Param)node;
	    parser.addParameter(param);
	    return param.getName();
	}
	else {
	    return null;
	}
    }

    
    public abstract Type typeCheck(SymbolTable stable) throws TypeCheckError;

    
    protected Type typeCheckContents(SymbolTable stable) throws TypeCheckError {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
	    item.typeCheck(stable);
	}
	return Type.Void;
    }

    
    public abstract void translate(ClassGenerator classGen,
				   MethodGenerator methodGen);

    
    protected void translateContents(ClassGenerator classGen,
				     MethodGenerator methodGen) {
	
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    final SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
	    item.translate(classGen, methodGen);
	}

	
	
	
	
	
	for (int i = 0; i < n; i++) {
	    if( _contents.elementAt(i) instanceof VariableBase) {
		final VariableBase var = (VariableBase)_contents.elementAt(i);
		var.unmapRegister(methodGen);
	    }
	}
    }
    
    
    private boolean isSimpleRTF(SyntaxTreeNode node) {
        
        Vector contents = node.getContents();
        for (int i = 0; i < contents.size(); i++) {
            SyntaxTreeNode item = (SyntaxTreeNode)contents.elementAt(i);
            if (!isTextElement(item, false))
                return false;
        }
        
        return true;
    }
 
     
    private boolean isAdaptiveRTF(SyntaxTreeNode node) {
        
        Vector contents = node.getContents();
        for (int i = 0; i < contents.size(); i++) {
            SyntaxTreeNode item = (SyntaxTreeNode)contents.elementAt(i);
            if (!isTextElement(item, true))
                return false;
        }
        
        return true;
    }
   
    
    private boolean isTextElement(SyntaxTreeNode node, boolean doExtendedCheck) {
        if (node instanceof ValueOf || node instanceof Number
            || node instanceof Text)
        {
            return true;
        }
        else if (node instanceof If) {
            return doExtendedCheck ? isAdaptiveRTF(node) : isSimpleRTF(node);
        }
        else if (node instanceof Choose) {
            Vector contents = node.getContents();
            for (int i = 0; i < contents.size(); i++) {
                SyntaxTreeNode item = (SyntaxTreeNode)contents.elementAt(i);
                if (item instanceof Text || 
                     ((item instanceof When || item instanceof Otherwise)
                     && ((doExtendedCheck && isAdaptiveRTF(item))
                         || (!doExtendedCheck && isSimpleRTF(item)))))
                    continue;
                else
                    return false;
            }
            return true;
        }
        else if (doExtendedCheck && 
                  (node instanceof CallTemplate
                   || node instanceof ApplyTemplates))
            return true;
        else
            return false;
    }

    
    protected void compileResultTree(ClassGenerator classGen,
				     MethodGenerator methodGen) 
    {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final Stylesheet stylesheet = classGen.getStylesheet();

	boolean isSimple = isSimpleRTF(this);
	boolean isAdaptive = false;
	if (!isSimple) {
	    isAdaptive = isAdaptiveRTF(this);
	}
	
	int rtfType = isSimple ? DOM.SIMPLE_RTF
	                       : (isAdaptive ? DOM.ADAPTIVE_RTF : DOM.TREE_RTF);
	
	
	il.append(methodGen.loadHandler());

	final String DOM_CLASS = classGen.getDOMClass();

	
	
	
	
	il.append(methodGen.loadDOM());
	int index = cpg.addInterfaceMethodref(DOM_INTF,
				 ""getResultTreeFrag"",
				 ""(II)"" + DOM_INTF_SIG);
	il.append(new PUSH(cpg, RTF_INITIAL_SIZE));
	il.append(new PUSH(cpg, rtfType));
	il.append(new INVOKEINTERFACE(index,3));

	
	il.append(DUP);

	
	index = cpg.addInterfaceMethodref(DOM_INTF,
				 ""getOutputDomBuilder"",
				 ""()"" + TRANSLET_OUTPUT_SIG);

	il.append(new INVOKEINTERFACE(index,1));
	il.append(DUP);
	il.append(methodGen.storeHandler());

	
	il.append(methodGen.startDocument());

	
	translateContents(classGen, methodGen);

	
	il.append(methodGen.loadHandler());
	il.append(methodGen.endDocument());

	
	
	
	if ((!isSimple || stylesheet.callsNodeset())
	    && !DOM_CLASS.equals(DOM_IMPL_CLASS)) {
	    
	    index = cpg.addMethodref(DOM_ADAPTER_CLASS,
				     ""<init>"",
				     ""(""+DOM_INTF_SIG+
				     ""[""+STRING_SIG+
				     ""[""+STRING_SIG+"")V"");
	    il.append(new NEW(cpg.addClass(DOM_ADAPTER_CLASS)));
	    il.append(new DUP_X1());
	    il.append(SWAP);

	    
	    if (!stylesheet.callsNodeset()) {
		il.append(new ICONST(0));
		il.append(new ANEWARRAY(cpg.addClass(STRING)));
		il.append(DUP);
		il.append(new INVOKESPECIAL(index));
	    }
	    else {
		
		il.append(ALOAD_0);
		il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					   NAMES_INDEX,
					   NAMES_INDEX_SIG))); 
		il.append(ALOAD_0);
		il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					   NAMESPACE_INDEX,
					   NAMESPACE_INDEX_SIG)));

		
		il.append(new INVOKESPECIAL(index));

		
		il.append(DUP);
		il.append(methodGen.loadDOM());
		il.append(new CHECKCAST(cpg.addClass(classGen.getDOMClass())));
		il.append(SWAP);
		index = cpg.addMethodref(MULTI_DOM_CLASS,
					 ""addDOMAdapter"",
					 ""("" + DOM_ADAPTER_SIG + "")I"");
		il.append(new INVOKEVIRTUAL(index));
		il.append(POP);		
	    }
	}

	
	il.append(SWAP);
	il.append(methodGen.storeHandler());
    }

    
    protected boolean contextDependent() {
	return true;
    }

    
    protected boolean dependentContents() {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    final SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
	    if (item.contextDependent()) {
		return true;
	    }
	}
	return false;
    }

    
    protected final void addElement(SyntaxTreeNode element) {
	_contents.addElement(element);
	element.setParent(this);
    }

    
    protected final void setFirstElement(SyntaxTreeNode element) {
	_contents.insertElementAt(element,0);
	element.setParent(this);
    }

    
    protected final void removeElement(SyntaxTreeNode element) {
	_contents.remove(element);
	element.setParent(null);
    }

    
    protected final Vector getContents() {
	return _contents;
    }

    
    protected final boolean hasContents() {
	return elementCount() > 0;
    }

    
    protected final int elementCount() {
	return _contents.size();
    }

    
    protected final Enumeration elements() {
	return _contents.elements();
    }

    
    protected final Object elementAt(int pos) {
	return _contents.elementAt(pos);
    }

    
    protected final SyntaxTreeNode lastChild() {
	if (_contents.size() == 0) return null;
	return (SyntaxTreeNode)_contents.lastElement();
    }

    
    public void display(int indent) {
	displayContents(indent);
    }

    
    protected void displayContents(int indent) {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
	    item.display(indent);
	}
    }

    
    protected final void indent(int indent) {
	System.out.print(new String(_spaces, 0, indent));
    }

    
    protected void reportError(SyntaxTreeNode element, Parser parser,
			       String errorCode, String message) {
	final ErrorMsg error = new ErrorMsg(errorCode, message, element);
        parser.reportError(Constants.ERROR, error);
    }

    
    protected  void reportWarning(SyntaxTreeNode element, Parser parser,
				  String errorCode, String message) {
	final ErrorMsg error = new ErrorMsg(errorCode, message, element);
        parser.reportError(Constants.WARNING, error);
    }

}
"
org.apache.xalan.xsltc.compiler.util.RealType,28,3,0,42,61,370,13,34,26,1.0,533,0.0,0,0.564516129,0.181547619,1,3,18.0,10,1.8214,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.DLOAD;
import org.apache.bcel.generic.DSTORE;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IFNE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionConstants;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.FlowList;

public final class RealType extends NumberType {
    protected RealType() {}

    public String toString() {
	return ""real"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""D"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.DOUBLE;
    }

    
    public int distanceTo(Type type) {
	if (type == this) {
	    return 0;
	}
	else if (type == Type.Int) {
	    return 1;
	}
	else {
	    return Integer.MAX_VALUE;
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else if (type == Type.Int) {
	    translateTo(classGen, methodGen, (IntType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKESTATIC(cpg.addMethodref(BASIS_LIBRARY_CLASS,
						    ""realToString"",
						    ""(D)"" + STRING_SIG)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	FlowList falsel = translateToDesynthesized(classGen, methodGen, type);
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsel.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    IntType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKESTATIC(cpg.addMethodref(BASIS_LIBRARY_CLASS,
						    ""realToInt"",""(D)I"")));
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	LocalVariableGen local;
	final FlowList flowlist = new FlowList();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(DUP2);
	local = methodGen.addLocalVariable(""real_to_boolean_tmp"", 
					   org.apache.bcel.generic.Type.DOUBLE,
					   il.getEnd(), null);
	il.append(new DSTORE(local.getIndex()));

	
	il.append(DCONST_0);
	il.append(DCMPG);
	flowlist.add(il.append(new IFEQ(null)));

	
	
	il.append(new DLOAD(local.getIndex()));
	il.append(new DLOAD(local.getIndex()));
	il.append(DCMPG);
	flowlist.add(il.append(new IFNE(null)));	
	return flowlist;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new NEW(cpg.addClass(DOUBLE_CLASS)));
	il.append(DUP_X2);
	il.append(DUP_X2);
	il.append(POP);
	il.append(new INVOKESPECIAL(cpg.addMethodref(DOUBLE_CLASS,
						     ""<init>"", ""(D)V"")));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    final Class clazz) {
	final InstructionList il = methodGen.getInstructionList();
	if (clazz == Character.TYPE) {
	    il.append(D2I);
	    il.append(I2C);
	}
	else if (clazz == Byte.TYPE) {
	    il.append(D2I);
	    il.append(I2B);
	}
	else if (clazz == Short.TYPE) {
	    il.append(D2I);
	    il.append(I2S);
	}
	else if (clazz == Integer.TYPE) {
	    il.append(D2I);
	}
	else if (clazz == Long.TYPE) {
	    il.append(D2L);
	}
	else if (clazz == Float.TYPE) {
	    il.append(D2F);
	}
	else if (clazz == Double.TYPE) {
	    il.append(NOP);
	}
        else if (clazz.isAssignableFrom(java.lang.Double.class)) {
            translateTo(classGen, methodGen, Type.Reference);
        }
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen, 
			      Class clazz) {
	InstructionList il = methodGen.getInstructionList();

	if (clazz == Character.TYPE || clazz == Byte.TYPE ||
	    clazz == Short.TYPE || clazz == Integer.TYPE) {
	    il.append(I2D);
	}
	else if (clazz == Long.TYPE) {
	    il.append(L2D);
	}
	else if (clazz == Float.TYPE) {
	    il.append(F2D);
	}
	else if (clazz == Double.TYPE) {
	    il.append(NOP);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new CHECKCAST(cpg.addClass(DOUBLE_CLASS)));
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(DOUBLE_CLASS,
						     DOUBLE_VALUE, 
						     DOUBLE_VALUE_SIG)));
    }

    public Instruction ADD() {
	return InstructionConstants.DADD;
    }

    public Instruction SUB() {
	return InstructionConstants.DSUB;
    }

    public Instruction MUL() {
	return InstructionConstants.DMUL;
    }

    public Instruction DIV() {
	return InstructionConstants.DDIV;
    }

    public Instruction REM() {
	return InstructionConstants.DREM;
    }

    public Instruction NEG() {
	return InstructionConstants.DNEG;
    }

    public Instruction LOAD(int slot) {
	return new DLOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new DSTORE(slot);
    }

    public Instruction POP() {
	return POP2;
    }
    
    public Instruction CMP(boolean less) {
	return less ? InstructionConstants.DCMPG : InstructionConstants.DCMPL;
    }

    public Instruction DUP() {
	return DUP2;
    }
}

"
org.apache.xpath.operations.Or,3,3,0,6,7,1,1,5,3,2.0,42,0.0,0,0.953488372,0.833333333,1,6,13.0,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class Or extends Operation
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XObject expr1 = m_left.execute(xctxt);

    if (!expr1.bool())
    {
      XObject expr2 = m_right.execute(xctxt);

      return expr2.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;
    }
    else
      return XBoolean.S_TRUE;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return (m_left.bool(xctxt) || m_right.bool(xctxt));
  }

}
"
org.apache.xalan.xsltc.TransletException,3,4,0,13,5,3,13,0,3,2.0,16,0.0,0,1.0,0.555555556,0,0,4.333333333,0,0.0,0,"

package org.apache.xalan.xsltc;

import org.xml.sax.SAXException;

public final class TransletException extends SAXException {

    public TransletException() {
	super(""Translet error"");
    }
    
    public TransletException(Exception e) {
	super(e.toString());
    }
    
    public TransletException(String message) {
	super(message);
    }
}
"
org.apache.xalan.xsltc.runtime.Hashtable,15,1,0,13,26,1,12,2,14,0.553571429,477,1.0,1,0.0,0.383333333,0,0,30.53333333,6,2.4667,0,"

package org.apache.xalan.xsltc.runtime;

import java.util.Enumeration;




class HashtableEntry {
    int hash;
    Object key;
    Object value;
    HashtableEntry next;

    protected Object clone() {
	HashtableEntry entry = new HashtableEntry();
	entry.hash = hash;
	entry.key = key;
	entry.value = value;
	entry.next = (next != null) ? (HashtableEntry)next.clone() : null;
	return entry;
    }
}


public class Hashtable {

    private transient HashtableEntry table[]; 
    private transient int count;              
    private int threshold;                    
    private float loadFactor;                 

    
    public Hashtable(int initialCapacity, float loadFactor) {
	if (initialCapacity <= 0) initialCapacity = 11;
	if (loadFactor <= 0.0) loadFactor = 0.75f;
	this.loadFactor = loadFactor;
	table = new HashtableEntry[initialCapacity];
	threshold = (int)(initialCapacity * loadFactor);
    }

    
    public Hashtable(int initialCapacity) {
	this(initialCapacity, 0.75f);
    }

    
    public Hashtable() {
	this(101, 0.75f);
    }

    
    public int size() {
	return count;
    }

    
    public boolean isEmpty() {
	return count == 0;
    }

    
    public Enumeration keys() {
	return new HashtableEnumerator(table, true);
    }

    
    public Enumeration elements() {
	return new HashtableEnumerator(table, false);
    }

    
    public boolean contains(Object value) {

	if (value == null) throw new NullPointerException();

	int i;
	HashtableEntry e;
	HashtableEntry tab[] = table;

	for (i = tab.length ; i-- > 0 ;) {
	    for (e = tab[i] ; e != null ; e = e.next) {
		if (e.value.equals(value)) {
		    return true;
		}
	    }
	}
	return false;
    }

    
    public boolean containsKey(Object key) {
	HashtableEntry e;
	HashtableEntry tab[] = table;
	int hash = key.hashCode();
	int index = (hash & 0x7FFFFFFF) % tab.length;

	for (e = tab[index] ; e != null ; e = e.next)
	    if ((e.hash == hash) && e.key.equals(key))
		return true;

	return false;
    }

    
    public Object get(Object key) {
	HashtableEntry e;
	HashtableEntry tab[] = table;
	int hash = key.hashCode();
	int index = (hash & 0x7FFFFFFF) % tab.length;

	for (e = tab[index] ; e != null ; e = e.next) 
	    if ((e.hash == hash) && e.key.equals(key)) 
		return e.value;

	return null;
    }

    
    protected void rehash() {
	HashtableEntry e, old;
	int i, index;
	int oldCapacity = table.length;
	HashtableEntry oldTable[] = table;

	int newCapacity = oldCapacity * 2 + 1;
	HashtableEntry newTable[] = new HashtableEntry[newCapacity];

	threshold = (int)(newCapacity * loadFactor);
	table = newTable;

	for (i = oldCapacity ; i-- > 0 ;) {
	    for (old = oldTable[i] ; old != null ; ) {
		e = old;
		old = old.next;
		index = (e.hash & 0x7FFFFFFF) % newCapacity;
		e.next = newTable[index];
		newTable[index] = e;
	    }
	}
    }

    
    public Object put(Object key, Object value) {
	
	if (value == null) throw new NullPointerException();

	
	HashtableEntry e;
	HashtableEntry tab[] = table;
	int hash = key.hashCode();
	int index = (hash & 0x7FFFFFFF) % tab.length;

	for (e = tab[index] ; e != null ; e = e.next) {
	    if ((e.hash == hash) && e.key.equals(key)) {
		Object old = e.value;
		e.value = value;
		return old;
	    }
	}

	
	if (count >= threshold) {
	    rehash();
	    return put(key, value);
	} 

	
	e = new HashtableEntry();
	e.hash = hash;
	e.key = key;
	e.value = value;
	e.next = tab[index];
	tab[index] = e;
	count++;
	return null;
    }

    
    public Object remove(Object key) {
	HashtableEntry e, prev;
	HashtableEntry tab[] = table;
	int hash = key.hashCode();
	int index = (hash & 0x7FFFFFFF) % tab.length;
	for (e = tab[index], prev = null ; e != null ; prev = e, e = e.next) {
	    if ((e.hash == hash) && e.key.equals(key)) {
		if (prev != null)
		    prev.next = e.next;
		else
		    tab[index] = e.next;
		count--;
		return e.value;
	    }
	}
	return null;
    }

    
    public void clear() {
	HashtableEntry tab[] = table;
	for (int index = tab.length; --index >= 0; )
	    tab[index] = null;
	count = 0;
    }

    
    public String toString() {
	int i;
	int max = size() - 1;
	StringBuffer buf = new StringBuffer();
	Enumeration k = keys();
	Enumeration e = elements();
	buf.append(""{"");

	for (i = 0; i <= max; i++) {
	    String s1 = k.nextElement().toString();
	    String s2 = e.nextElement().toString();
	    buf.append(s1 + ""="" + s2);
	    if (i < max) buf.append("", "");
	}
	buf.append(""}"");
	return buf.toString();
    }

    
    class HashtableEnumerator implements Enumeration {
	boolean keys;
	int index;
	HashtableEntry table[];
	HashtableEntry entry;

	HashtableEnumerator(HashtableEntry table[], boolean keys) {
	    this.table = table;
	    this.keys = keys;
	    this.index = table.length;
	}
	
	public boolean hasMoreElements() {
	    if (entry != null) {
		return true;
	    }
	    while (index-- > 0) {
		if ((entry = table[index]) != null) {
		    return true;
		}
	    }
	    return false;
	}

	public Object nextElement() {
	    if (entry == null) {
		while ((index-- > 0) && ((entry = table[index]) == null));
	    }
	    if (entry != null) {
		HashtableEntry e = entry;
		entry = e.next;
		return keys ? e.key : e.value;
	    }
	    return null;
	}
    }

}
"
org.apache.xml.utils.DOM2Helper,11,2,1,10,29,53,7,3,11,0.8,125,1.0,0,0.714285714,0.327272727,1,5,10.27272727,4,1.4545,1,"
package org.apache.xml.utils;

import java.io.IOException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.TransformerException;

import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

import org.xml.sax.InputSource;


public class DOM2Helper extends DOMHelper
{

  
  public DOM2Helper(){}

  
  public void checkNode(Node node) throws TransformerException
  {

    
    
    
  }

  
  public boolean supportsSAX()
  {
    return true;
  }

  
  private Document m_doc;

  
  public void setDocument(Document doc)
  {
    m_doc = doc;
  }

  
  public Document getDocument()
  {
    return m_doc;
  }

  
  public void parse(InputSource source) throws TransformerException
  {

    try
    {

      
      
      
      DocumentBuilderFactory builderFactory =
        DocumentBuilderFactory.newInstance();

      builderFactory.setNamespaceAware(true);
      builderFactory.setValidating(true);

      DocumentBuilder parser = builderFactory.newDocumentBuilder();

      

      parser.setErrorHandler(
        new org.apache.xml.utils.DefaultErrorHandler());

      
      
      
      
      
      setDocument(parser.parse(source));
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    catch (ParserConfigurationException pce)
    {
      throw new TransformerException(pce);
    }
    catch (IOException ioe)
    {
      throw new TransformerException(ioe);
    }

    
  }

  
  public Element getElementByID(String id, Document doc)
  {
    return doc.getElementById(id);
  }

  
  public static boolean isNodeAfter(Node node1, Node node2)
  {

    
    
    if(node1 instanceof DOMOrder && node2 instanceof DOMOrder)
    {
      int index1 = ((DOMOrder) node1).getUid();
      int index2 = ((DOMOrder) node2).getUid();

      return index1 <= index2;
    }
    else
    {

      
      
      return DOMHelper.isNodeAfter(node1, node2);
    }
  }

  
  public static Node getParentOfNode(Node node)
  {
          Node parent=node.getParentNode();
          if(parent==null && (Node.ATTRIBUTE_NODE == node.getNodeType()) )
           parent=((Attr) node).getOwnerElement();
          return parent;
  }

  
  public String getLocalNameOfNode(Node n)
  {

    String name = n.getLocalName();

    return (null == name) ? super.getLocalNameOfNode(n) : name;
  }

  
  public String getNamespaceOfNode(Node n)
  {
    return n.getNamespaceURI();
  }

  
  
}
"
org.apache.xalan.processor.ProcessorKey,3,4,0,10,34,3,1,9,1,2.0,169,0.0,0,0.990566038,0.666666667,1,1,55.33333333,1,0.6667,0,"
package org.apache.xalan.processor;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.KeyDeclaration;

import org.xml.sax.Attributes;


class ProcessorKey extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    KeyDeclaration kd = new KeyDeclaration(handler.getStylesheet(), handler.nextUid());

    kd.setDOMBackPointer(handler.getOriginatingNode());
    kd.setLocaterInfo(handler.getLocator());
    setPropertiesFromAttributes(handler, rawName, attributes, kd);
    handler.getStylesheet().setKey(kd);
  }

  
  void setPropertiesFromAttributes(
          StylesheetHandler handler, String rawName, Attributes attributes, 
          org.apache.xalan.templates.ElemTemplateElement target)
            throws org.xml.sax.SAXException
  {

    XSLTElementDef def = getElemDef();

    
    
    Vector processedDefs = new Vector();
    int nAttrs = attributes.getLength();

    for (int i = 0; i < nAttrs; i++)
    {
      String attrUri = attributes.getURI(i);
      String attrLocalName = attributes.getLocalName(i);
      XSLTAttributeDef attrDef = def.getAttributeDef(attrUri, attrLocalName);

      if (null == attrDef)
      {

        
        handler.error(attributes.getQName(i)
                      + ""attribute is not allowed on the "" + rawName
                      + "" element!"", null);
      }
      else
      {
        String valueString = attributes.getValue(i);

        if (valueString.indexOf(org.apache.xpath.compiler.Keywords.FUNC_KEY_STRING
                                + ""("") >= 0)
          handler.error(
            XSLMessages.createMessage(
            XSLTErrorResources.ER_INVALID_KEY_CALL, null), null);

        processedDefs.addElement(attrDef);
        attrDef.setAttrValue(handler, attrUri, attrLocalName,
                             attributes.getQName(i), attributes.getValue(i),
                             target);
      }
    }

    XSLTAttributeDef[] attrDefs = def.getAttributes();
    int nAttrDefs = attrDefs.length;

    for (int i = 0; i < nAttrDefs; i++)
    {
      XSLTAttributeDef attrDef = attrDefs[i];
      String defVal = attrDef.getDefault();

      if (null != defVal)
      {
        if (!processedDefs.contains(attrDef))
        {
          attrDef.setDefAttrValue(handler, target);
        }
      }

      if (attrDef.getRequired())
      {
        if (!processedDefs.contains(attrDef))
          handler.error(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_REQUIRES_ATTRIB, new Object[]{ rawName,
                                                                   attrDef.getName() }), null);
      }
    }
  }
}
"
org.apache.xml.res.XMLErrorResources_en,1,4,0,1,2,0,0,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xml.res;



public class XMLErrorResources_en extends XMLErrorResources
{
}
"
org.apache.xpath.objects.XRTreeFragSelectWrapper,10,4,0,9,23,23,1,8,10,0.555555556,89,0.0,1,0.905263158,0.28,3,22,7.8,2,1.0,0,"
package org.apache.xpath.objects;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.res.XPATHErrorResources;


public class XRTreeFragSelectWrapper extends XRTreeFrag implements Cloneable
{
  XObject m_selected;

  public XRTreeFragSelectWrapper(Expression expr)
  {
    super(expr);
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    ((Expression)m_obj).fixupVariables(vars, globalsSize);
  }
  
  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
     m_selected = ((Expression)m_obj).execute(xctxt);
     m_selected.allowDetachToRelease(m_allowRelease);
     if (m_selected.getType() == CLASS_STRING)
       return m_selected;
     else
       return new XString(m_selected.str());
  }
    
  
  public void detach()
  {
    if(m_allowRelease)
    {
      m_selected.detach();
      m_selected = null;
    }
    
    super.detach();
  }
  
  
  public double num()
    throws javax.xml.transform.TransformerException
  {

    return m_selected.num();
  }

  
  
  public XMLString xstr()
  {
    return m_selected.xstr();
  }

  
  public String str()
  {
    return m_selected.str();
  }
  
  
  public int getType()
  {
    return CLASS_STRING;
  }

  
  public int rtf()
  {
    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER, null)); 
  }

  
  public DTMIterator asNodeIterator()
  {
    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER, null)); 
  }

}"
org.apache.xalan.transformer.KeyRefIterator,3,7,0,15,26,0,0,15,2,0.0,171,0.75,3,0.985185185,0.444444444,3,4,54.66666667,6,3.0,1,"
package org.apache.xalan.transformer;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.KeyDeclaration;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;


public class KeyRefIterator extends org.apache.xpath.axes.ChildTestIterator
{
  
  public KeyRefIterator(QName name, XMLString ref, Vector keyDecls, DTMIterator ki)
  {
    super(null);
    m_name = name;
    m_ref = ref;
    m_keyDeclarations = keyDecls;
    m_keysNodes = ki;
    setWhatToShow(org.apache.xml.dtm.DTMFilter.SHOW_ALL);
  }
  
  DTMIterator m_keysNodes;
  
  
  protected int getNextNode()
  {                  
  	int next;   
    while(DTM.NULL != (next = m_keysNodes.nextNode()))
    {
    	if(DTMIterator.FILTER_ACCEPT == filterNode(next))
    		break;
    }
    m_lastFetched = next;
    
    return next;
  }


  
  public short filterNode(int testNode)
  {
    boolean foundKey = false;
    Vector keys = m_keyDeclarations;

    QName name = m_name;
    KeyIterator ki = (KeyIterator)(((XNodeSet)m_keysNodes).getContainedIter());
    org.apache.xpath.XPathContext xctxt = ki.getXPathContext();
    
    if(null == xctxt)
    	assertion(false, ""xctxt can not be null here!"");

    try
    {
      XMLString lookupKey = m_ref;

      
      int nDeclarations = keys.size();

      
      for (int i = 0; i < nDeclarations; i++)
      {
        KeyDeclaration kd = (KeyDeclaration) keys.elementAt(i);

        
        
        if (!kd.getName().equals(name))
          continue;

        foundKey = true;
        

        
        
        XObject xuse = kd.getUse().execute(xctxt, testNode, ki.getPrefixResolver());

        if (xuse.getType() != xuse.CLASS_NODESET)
        {
          XMLString exprResult = xuse.xstr();

          if (lookupKey.equals(exprResult))
            return DTMIterator.FILTER_ACCEPT;
        }
        else
        {
          DTMIterator nl = ((XNodeSet)xuse).iterRaw();
          int useNode;
          
          while (DTM.NULL != (useNode = nl.nextNode()))
          {
            DTM dtm = getDTM(useNode);
            XMLString exprResult = dtm.getStringValue(useNode);
            if ((null != exprResult) && lookupKey.equals(exprResult))
              return DTMIterator.FILTER_ACCEPT;
          }
        }

      } 
    }
    catch (javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }

    if (!foundKey)
      throw new RuntimeException(
        XSLMessages.createMessage(
          XSLTErrorResources.ER_NO_XSLKEY_DECLARATION,
          new Object[] { name.getLocalName()}));
    return DTMIterator.FILTER_REJECT;
  }

  protected XMLString m_ref;
  protected QName m_name;

  
  protected Vector m_keyDeclarations;

}"
org.apache.xpath.compiler.Compiler,45,2,0,60,112,932,23,41,15,0.568181818,1178,0.6,1,0.328125,0.175925926,1,1,25.06666667,12,1.2222,2,"
package org.apache.xpath.compiler;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xpath.Expression;
import org.apache.xpath.axes.UnionPathIterator;
import org.apache.xpath.axes.WalkerFactory;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.functions.Function;
import org.apache.xpath.functions.WrongNumberArgsException;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XString;
import org.apache.xpath.operations.And;
import org.apache.xpath.operations.Div;
import org.apache.xpath.operations.Equals;
import org.apache.xpath.operations.Gt;
import org.apache.xpath.operations.Gte;
import org.apache.xpath.operations.Lt;
import org.apache.xpath.operations.Lte;
import org.apache.xpath.operations.Minus;
import org.apache.xpath.operations.Mod;
import org.apache.xpath.operations.Mult;
import org.apache.xpath.operations.Neg;
import org.apache.xpath.operations.NotEquals;
import org.apache.xpath.operations.Operation;
import org.apache.xpath.operations.Or;
import org.apache.xpath.operations.Plus;
import org.apache.xpath.operations.UnaryOperation;
import org.apache.xpath.operations.Variable;
import org.apache.xpath.patterns.FunctionPattern;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.patterns.StepPattern;
import org.apache.xpath.patterns.UnionPattern;
import org.apache.xpath.res.XPATHErrorResources;


public class Compiler extends OpMap
{

  
  public Compiler(ErrorListener errorHandler, SourceLocator locator)
  {
    m_errorHandler = errorHandler;
    m_locator = locator;
  }

  
  public Compiler()
  {
    m_errorHandler = null;
    m_locator = null;
  }

  
  public Expression compile(int opPos) throws TransformerException
  {

    int op = getOp(opPos);

    Expression expr = null;
    
    switch (op)
    {
    case OpCodes.OP_XPATH :
      expr = compile(opPos + 2); break;
    case OpCodes.OP_OR :
      expr = or(opPos); break;
    case OpCodes.OP_AND :
      expr = and(opPos); break;
    case OpCodes.OP_NOTEQUALS :
      expr = notequals(opPos); break;
    case OpCodes.OP_EQUALS :
      expr = equals(opPos); break;
    case OpCodes.OP_LTE :
      expr = lte(opPos); break;
    case OpCodes.OP_LT :
      expr = lt(opPos); break;
    case OpCodes.OP_GTE :
      expr = gte(opPos); break;
    case OpCodes.OP_GT :
      expr = gt(opPos); break;
    case OpCodes.OP_PLUS :
      expr = plus(opPos); break;
    case OpCodes.OP_MINUS :
      expr = minus(opPos); break;
    case OpCodes.OP_MULT :
      expr = mult(opPos); break;
    case OpCodes.OP_DIV :
      expr = div(opPos); break;
    case OpCodes.OP_MOD :
      expr = mod(opPos); break;


    case OpCodes.OP_NEG :
      expr = neg(opPos); break;
    case OpCodes.OP_STRING :
      expr = string(opPos); break;
    case OpCodes.OP_BOOL :
      expr = bool(opPos); break;
    case OpCodes.OP_NUMBER :
      expr = number(opPos); break;
    case OpCodes.OP_UNION :
      expr = union(opPos); break;
    case OpCodes.OP_LITERAL :
      expr = literal(opPos); break;
    case OpCodes.OP_VARIABLE :
      expr = variable(opPos); break;
    case OpCodes.OP_GROUP :
      expr = group(opPos); break;
    case OpCodes.OP_NUMBERLIT :
      expr = numberlit(opPos); break;
    case OpCodes.OP_ARGUMENT :
      expr = arg(opPos); break;
    case OpCodes.OP_EXTFUNCTION :
      expr = compileExtension(opPos); break;
    case OpCodes.OP_FUNCTION :
      expr = compileFunction(opPos); break;
    case OpCodes.OP_LOCATIONPATH :
      expr = locationPath(opPos); break;
    case OpCodes.OP_PREDICATE :
      expr = null; break;  
    case OpCodes.OP_MATCHPATTERN :
      expr = matchPattern(opPos + 2); break;
    case OpCodes.OP_LOCATIONPATHPATTERN :
      expr = locationPathPattern(opPos); break;
    case OpCodes.OP_QUO:
      error(XPATHErrorResources.ER_UNKNOWN_OPCODE,
            new Object[]{ ""quo"" });  
      break;
    default :
      error(XPATHErrorResources.ER_UNKNOWN_OPCODE,
            new Object[]{ Integer.toString(getOp(opPos)) });  
    }



    return expr;
  }

  
  private Expression compileOperation(Operation operation, int opPos)
          throws TransformerException
  {

    int leftPos = getFirstChildPos(opPos);
    int rightPos = getNextOpPos(leftPos);

    operation.setLeftRight(compile(leftPos), compile(rightPos));

    return operation;
  }

  
  private Expression compileUnary(UnaryOperation unary, int opPos)
          throws TransformerException
  {

    int rightPos = getFirstChildPos(opPos);

    unary.setRight(compile(rightPos));

    return unary;
  }

  
  protected Expression or(int opPos) throws TransformerException
  {
    return compileOperation(new Or(), opPos);
  }

  
  protected Expression and(int opPos) throws TransformerException
  {
    return compileOperation(new And(), opPos);
  }

  
  protected Expression notequals(int opPos) throws TransformerException
  {
    return compileOperation(new NotEquals(), opPos);
  }

  
  protected Expression equals(int opPos) throws TransformerException
  {
    return compileOperation(new Equals(), opPos);
  }

  
  protected Expression lte(int opPos) throws TransformerException
  {
    return compileOperation(new Lte(), opPos);
  }

  
  protected Expression lt(int opPos) throws TransformerException
  {
    return compileOperation(new Lt(), opPos);
  }

  
  protected Expression gte(int opPos) throws TransformerException
  {
    return compileOperation(new Gte(), opPos);
  }

  
  protected Expression gt(int opPos) throws TransformerException
  {
    return compileOperation(new Gt(), opPos);
  }

  
  protected Expression plus(int opPos) throws TransformerException
  {
    return compileOperation(new Plus(), opPos);
  }

  
  protected Expression minus(int opPos) throws TransformerException
  {
    return compileOperation(new Minus(), opPos);
  }

  
  protected Expression mult(int opPos) throws TransformerException
  {
    return compileOperation(new Mult(), opPos);
  }

  
  protected Expression div(int opPos) throws TransformerException
  {
    return compileOperation(new Div(), opPos);
  }

  
  protected Expression mod(int opPos) throws TransformerException
  {
    return compileOperation(new Mod(), opPos);
  }

  





  
  protected Expression neg(int opPos) throws TransformerException
  {
    return compileUnary(new Neg(), opPos);
  }

  
  protected Expression string(int opPos) throws TransformerException
  {
    return compileUnary(new org.apache.xpath.operations.String(), opPos);
  }

  
  protected Expression bool(int opPos) throws TransformerException
  {
    return compileUnary(new org.apache.xpath.operations.Bool(), opPos);
  }

  
  protected Expression number(int opPos) throws TransformerException
  {
    return compileUnary(new org.apache.xpath.operations.Number(), opPos);
  }

  
  protected Expression literal(int opPos)
  {

    opPos = getFirstChildPos(opPos);

    return (XString) getTokenQueue().elementAt(getOp(opPos));
  }

  
  protected Expression numberlit(int opPos)
  {

    opPos = getFirstChildPos(opPos);

    return (XNumber) getTokenQueue().elementAt(getOp(opPos));
  }

  
  protected Expression variable(int opPos) throws TransformerException
  {

    Variable var = new Variable();

    opPos = getFirstChildPos(opPos);

    int nsPos = getOp(opPos);
    java.lang.String namespace 
      = (OpCodes.EMPTY == nsPos) ? null 
                                   : (java.lang.String) getTokenQueue().elementAt(nsPos);
    java.lang.String localname 
      = (java.lang.String) getTokenQueue().elementAt(getOp(opPos+1));
    QName qname = new QName(namespace, localname);

    var.setQName(qname);

    return var;
  }

  
  protected Expression group(int opPos) throws TransformerException
  {

    
    return compile(opPos + 2);
  }

  
  protected Expression arg(int opPos) throws TransformerException
  {

    
    return compile(opPos + 2);
  }

  
  protected Expression union(int opPos) throws TransformerException
  {
    locPathDepth++;
    try
    {
      return UnionPathIterator.createUnionIterator(this, opPos);
    }
    finally
    {
      locPathDepth--;
    }
  }
  
  private int locPathDepth = -1;
  
  
  public int getLocationPathDepth()
  {
    return locPathDepth;
  }

  
  public Expression locationPath(int opPos) throws TransformerException
  {
    locPathDepth++;
    try
    {
      DTMIterator iter = WalkerFactory.newDTMIterator(this, opPos, (locPathDepth == 0));
      return (Expression)iter; 
    }
    finally
    {
      locPathDepth--;
    }
  }

  
  public Expression predicate(int opPos) throws TransformerException
  {
    return compile(opPos + 2);
  }

  
  protected Expression matchPattern(int opPos) throws TransformerException
  {
    locPathDepth++;
    try
    {
      
      int nextOpPos = opPos;
      int i;

      for (i = 0; getOp(nextOpPos) == OpCodes.OP_LOCATIONPATHPATTERN; i++)
      {
        nextOpPos = getNextOpPos(nextOpPos);
      }

      if (i == 1)
        return compile(opPos);

      UnionPattern up = new UnionPattern();
      StepPattern[] patterns = new StepPattern[i];

      for (i = 0; getOp(opPos) == OpCodes.OP_LOCATIONPATHPATTERN; i++)
      {
        nextOpPos = getNextOpPos(opPos);
        patterns[i] = (StepPattern) compile(opPos);
        opPos = nextOpPos;
      }

      up.setPatterns(patterns);

      return up;
    }
    finally
    {
      locPathDepth--;
    }
  }

  
  public Expression locationPathPattern(int opPos)
          throws TransformerException
  {

    opPos = getFirstChildPos(opPos);

    return stepPattern(opPos, 0, null);
  }

  
  public int getWhatToShow(int opPos)
  {

    int axesType = getOp(opPos);
    int testType = getOp(opPos + 3);

    
    switch (testType)
    {
    case OpCodes.NODETYPE_COMMENT :
      return DTMFilter.SHOW_COMMENT;
    case OpCodes.NODETYPE_TEXT :

      return DTMFilter.SHOW_TEXT | DTMFilter.SHOW_CDATA_SECTION ;
    case OpCodes.NODETYPE_PI :
      return DTMFilter.SHOW_PROCESSING_INSTRUCTION;
    case OpCodes.NODETYPE_NODE :

      switch (axesType)
      {
      case OpCodes.FROM_NAMESPACE:
        return DTMFilter.SHOW_NAMESPACE;
      case OpCodes.FROM_ATTRIBUTES :
      case OpCodes.MATCH_ATTRIBUTE :
        return DTMFilter.SHOW_ATTRIBUTE;
      case OpCodes.FROM_SELF:
      case OpCodes.FROM_ANCESTORS_OR_SELF:
      case OpCodes.FROM_DESCENDANTS_OR_SELF:
        return DTMFilter.SHOW_ALL;
      default:
        if (getOp(0) == OpCodes.OP_MATCHPATTERN)
          return ~DTMFilter.SHOW_ATTRIBUTE
                  & ~DTMFilter.SHOW_DOCUMENT
                  & ~DTMFilter.SHOW_DOCUMENT_FRAGMENT;
        else
          return ~DTMFilter.SHOW_ATTRIBUTE;
      }
    case OpCodes.NODETYPE_ROOT :
      return DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT;
    case OpCodes.NODETYPE_FUNCTEST :
      return NodeTest.SHOW_BYFUNCTION;
    case OpCodes.NODENAME :
      switch (axesType)
      {
      case OpCodes.FROM_NAMESPACE :
        return DTMFilter.SHOW_NAMESPACE;
      case OpCodes.FROM_ATTRIBUTES :
      case OpCodes.MATCH_ATTRIBUTE :
        return DTMFilter.SHOW_ATTRIBUTE;

      
      case OpCodes.MATCH_ANY_ANCESTOR :
      case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
        return DTMFilter.SHOW_ELEMENT;

      
      default :
        return DTMFilter.SHOW_ELEMENT;
      }
    default :
      
      return DTMFilter.SHOW_ALL;
    }
  }
  
private static final boolean DEBUG = false;

  
  protected StepPattern stepPattern(
          int opPos, int stepCount, StepPattern ancestorPattern)
            throws TransformerException
  {

    int startOpPos = opPos;
    int stepType = getOp(opPos);

    if (OpCodes.ENDOP == stepType)
    {
      return null;
    }
    
    boolean addMagicSelf = true;

    int endStep = getNextOpPos(opPos);

    
    StepPattern pattern;
    
    
    int argLen;

    switch (stepType)
    {
    case OpCodes.OP_FUNCTION :
      if(DEBUG)
        System.out.println(""MATCH_FUNCTION: ""+m_currentPattern); 
      addMagicSelf = false;
      argLen = getOp(opPos + OpMap.MAPINDEX_LENGTH);
      pattern = new FunctionPattern(compileFunction(opPos), Axis.PARENT, Axis.CHILD);
      break;
    case OpCodes.FROM_ROOT :
      if(DEBUG)
        System.out.println(""FROM_ROOT, ""+m_currentPattern);
      addMagicSelf = false;
      argLen = getArgLengthOfStep(opPos);
      opPos = getFirstChildPosOfStep(opPos);
      pattern = new StepPattern(DTMFilter.SHOW_DOCUMENT | 
                                DTMFilter.SHOW_DOCUMENT_FRAGMENT,
                                Axis.PARENT, Axis.CHILD);
      break;
    case OpCodes.MATCH_ATTRIBUTE :
     if(DEBUG)
        System.out.println(""MATCH_ATTRIBUTE: ""+getStepLocalName(startOpPos)+"", ""+m_currentPattern);
      argLen = getArgLengthOfStep(opPos);
      opPos = getFirstChildPosOfStep(opPos);
      pattern = new StepPattern(DTMFilter.SHOW_ATTRIBUTE,
                                getStepNS(startOpPos),
                                getStepLocalName(startOpPos),
                                Axis.PARENT, Axis.ATTRIBUTE);
      break;
    case OpCodes.MATCH_ANY_ANCESTOR :
      if(DEBUG)
        System.out.println(""MATCH_ANY_ANCESTOR: ""+getStepLocalName(startOpPos)+"", ""+m_currentPattern);
      argLen = getArgLengthOfStep(opPos);
      opPos = getFirstChildPosOfStep(opPos);
      int what = getWhatToShow(startOpPos);
      
      if(0x00000500 == what)
        addMagicSelf = false;
      pattern = new StepPattern(getWhatToShow(startOpPos),
                                        getStepNS(startOpPos),
                                        getStepLocalName(startOpPos),
                                        Axis.ANCESTOR, Axis.CHILD);
      break;
    case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
      if(DEBUG)
        System.out.println(""MATCH_IMMEDIATE_ANCESTOR: ""+getStepLocalName(startOpPos)+"", ""+m_currentPattern);
      argLen = getArgLengthOfStep(opPos);
      opPos = getFirstChildPosOfStep(opPos);
      pattern = new StepPattern(getWhatToShow(startOpPos),
                                getStepNS(startOpPos),
                                getStepLocalName(startOpPos),
                                Axis.PARENT, Axis.CHILD);
      break;
    default :
      error(XPATHErrorResources.ER_UNKNOWN_MATCH_OPERATION, null);  

      return null;
    }

    pattern.setPredicates(getCompiledPredicates(opPos + argLen));
    if(null == ancestorPattern)
    {
      
      
      
      
      
      
      
      
      
	
    }
    else
    {
      
      pattern.setRelativePathPattern(ancestorPattern);
    }

    StepPattern relativePathPattern = stepPattern(endStep, stepCount + 1,
                                        pattern);

    return (null != relativePathPattern) ? relativePathPattern : pattern;
  }

  
  public Expression[] getCompiledPredicates(int opPos)
          throws TransformerException
  {

    int count = countPredicates(opPos);

    if (count > 0)
    {
      Expression[] predicates = new Expression[count];

      compilePredicates(opPos, predicates);

      return predicates;
    }

    return null;
  }

  
  public int countPredicates(int opPos) throws TransformerException
  {

    int count = 0;

    while (OpCodes.OP_PREDICATE == getOp(opPos))
    {
      count++;

      opPos = getNextOpPos(opPos);
    }

    return count;
  }

  
  private void compilePredicates(int opPos, Expression[] predicates)
          throws TransformerException
  {

    for (int i = 0; OpCodes.OP_PREDICATE == getOp(opPos); i++)
    {
      predicates[i] = predicate(opPos);
      opPos = getNextOpPos(opPos);
    }
  }

  
  Expression compileFunction(int opPos) throws TransformerException
  {

    int endFunc = opPos + getOp(opPos + 1) - 1;

    opPos = getFirstChildPos(opPos);

    int funcID = getOp(opPos);

    opPos++;

    if (-1 != funcID)
    {
      Function func = FunctionTable.getFunction(funcID);

      func.postCompileStep(this);
      
      try
      {
        int i = 0;

        for (int p = opPos; p < endFunc; p = getNextOpPos(p), i++)
        {

          
          
          func.setArg(compile(p), i);
        }

        func.checkNumberArgs(i);
      }
      catch (WrongNumberArgsException wnae)
      {
        java.lang.String name = FunctionTable.m_functions[funcID].getName();

        m_errorHandler.fatalError( new TransformerException(
                  XSLMessages.createXPATHMessage(XPATHErrorResources.ER_ONLY_ALLOWS, 
                      new Object[]{name, wnae.getMessage()}), m_locator)); 
              
      }

      return func;
    }
    else
    {
      error(XPATHErrorResources.ER_FUNCTION_TOKEN_NOT_FOUND, null);  

      return null;
    }
  }

  
  private Expression compileExtension(int opPos)
          throws TransformerException
  {

    int endExtFunc = opPos + getOp(opPos + 1) - 1;

    opPos = getFirstChildPos(opPos);

    java.lang.String ns = (java.lang.String) getTokenQueue().elementAt(getOp(opPos));

    opPos++;

    java.lang.String funcName =
      (java.lang.String) getTokenQueue().elementAt(getOp(opPos));

    opPos++;

    
    
    

    Function extension = new FuncExtFunction(ns, funcName, 
         String.valueOf(opPos)
       + String.valueOf(hashCode())
       + String.valueOf(System.currentTimeMillis()));

    try
    {
      int i = 0;

      while (opPos < endExtFunc)
      {
        int nextOpPos = getNextOpPos(opPos);

        extension.setArg(this.compile(opPos), i);

        opPos = nextOpPos;

        i++;
      }
    }
    catch (WrongNumberArgsException wnae)
    {
      ;  
    }

    return extension;
  }

  
  public void warn(String msg, Object[] args) throws TransformerException
  {

    java.lang.String fmsg = XSLMessages.createXPATHWarning(msg, args);

    if (null != m_errorHandler)
    {
      m_errorHandler.warning(new TransformerException(fmsg, m_locator));
    }
    else
    {
      System.out.println(fmsg
                          +""; file ""+m_locator.getSystemId()
                          +""; line ""+m_locator.getLineNumber()
                          +""; column ""+m_locator.getColumnNumber());
    }
  }

  
  public void assertion(boolean b, java.lang.String msg)
  {

    if (!b)
    {
      java.lang.String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ msg });

      throw new RuntimeException(fMsg);
    }
  }

  
  public void error(String msg, Object[] args) throws TransformerException
  {

    java.lang.String fmsg = XSLMessages.createXPATHMessage(msg, args);
    

    if (null != m_errorHandler)
    {
      m_errorHandler.fatalError(new TransformerException(fmsg, m_locator));
    }
    else
    {

      
      
      
      
      throw new TransformerException(fmsg, (SAXSourceLocator)m_locator);
    }
  }

  
  private PrefixResolver m_currentPrefixResolver = null;

  
  public PrefixResolver getNamespaceContext()
  {
    return m_currentPrefixResolver;
  }

  
  public void setNamespaceContext(PrefixResolver pr)
  {
    m_currentPrefixResolver = pr;
  }

  
  ErrorListener m_errorHandler;

  
  SourceLocator m_locator;
}
"
org.apache.xalan.xsltc.util.IntegerArray,24,1,0,4,30,0,4,0,21,0.543478261,481,1.0,0,0.0,0.316666667,0,0,18.875,8,1.6667,1,"

package org.apache.xalan.xsltc.util;

public final class IntegerArray {
    private static final int InitialSize = 32;
    
    private int[] _array;
    private int   _size;
    private int   _free = 0;
  
    public IntegerArray() {
	this(InitialSize);
    }
  
    public IntegerArray(int size) {
	_array = new int[_size = size];
    }

    public IntegerArray(int[] array) {
	this(array.length);
	System.arraycopy(array, 0, _array, 0, _free = _size);
    }

    public void clear() {
	_free = 0;
    }

    public Object clone() {
	final IntegerArray clone = new IntegerArray(_free);
	System.arraycopy(_array, 0, clone._array, 0, _free);
	clone._free = _free;
	return clone;
    }

    public int[] toIntArray() {
	final int[] result = new int[cardinality()];
	System.arraycopy(_array, 0, result, 0, cardinality());
	return result;
    }

    public final int at(int index) {
	return _array[index];
    }

    public final void set(int index, int value) {
	_array[index] = value;
    }

    public int indexOf(int n) {
	for (int i = 0; i < _free; i++) {
	    if (n == _array[i]) return i;
	}
	return -1;
    }

    public final void add(int value) {
	if (_free == _size) {
	    growArray(_size * 2);
	}
	_array[_free++] = value;
    }
  
    
    public void addNew(int value) {
	for (int i = 0; i < _free; i++) {
	    if (_array[i] == value) return;  
	}
	add(value);
    }

    public void reverse() {
	int left = 0; 
	int right = _free - 1;

	while (left < right) {
	    int temp = _array[left];
	    _array[left++] = _array[right];
	    _array[right--] = temp;
	}
    }

    
    public void merge(IntegerArray other) {
	final int newSize = _free + other._free;

	int[] newArray = new int[newSize];

	
	int i = 0, j = 0, k;
	for (k = 0; i < _free && j < other._free; k++) {
	    int x = _array[i];
	    int y = other._array[j];

	    if (x < y) {
		newArray[k] = x;
		i++;
	    }
	    else if (x > y) {
		newArray[k] = y;
		j++;
	    }
	    else {
		newArray[k] = x;
		i++; j++;
	    }
	}

	
	if (i >= _free) {
	    while (j < other._free) {
		newArray[k++] = other._array[j++];
	    }
	}
	else {
	    while (i < _free) {
		newArray[k++] = _array[i++];
	    }
	}

	
	_array = newArray;
	_free = _size = newSize;

    }

    public void sort() {
	quicksort(_array, 0, _free - 1);
    }

    private static void quicksort(int[] array, int p, int r) {
	if (p < r) {
	    final int q = partition(array, p, r);
	    quicksort(array, p, q);
	    quicksort(array, q + 1, r);
	}
    }
    
    private static int partition(int[] array, int p, int r) {
	final int x = array[(p + r) >>> 1];
	int i = p - 1; int j = r + 1;

	while (true) {
	    while (x < array[--j]);
	    while (x > array[++i]);
	    if (i < j) {
		int temp = array[i];
		array[i] = array[j];
		array[j] = temp;
	    }
	    else {
		return j;
	    }
	}
    }

    private void growArray(int size) {
	final int[] newArray = new int[_size = size];
	System.arraycopy(_array, 0, newArray, 0, _free);
	_array = newArray;
    }

    public int popLast() {
	return _array[--_free];
    }

    public int last() {
	return _array[_free - 1];
    }

    public void setLast(int n) {
	_array[_free - 1] = n;
    }

    public void pop() {
	_free--;
    }

    public void pop(int n) {
	_free -= n;
    }
  
    public final int cardinality() {
	return _free;
    }

    public void print(java.io.PrintStream out) {
	if (_free > 0) {
	    for (int i = 0; i < _free - 1; i++) {
		out.print(_array[i]);
		out.print(' ');
	    }
	    out.println(_array[_free - 1]);
	}
	else {
	    out.println(""IntegerArray: empty"");
	}
    }
}
"
org.apache.xml.res.XMLErrorResources_es,3,4,0,1,4,1,0,1,2,1.3,875,0.0,0,0.976190476,1.0,0,0,289.0,1,0.3333,0,"
package org.apache.xml.res;



public class XMLErrorResources_es extends XMLErrorResources
{

  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },


  
  

  {
    ER_FUNCTION_NOT_SUPPORTED, ""Función no admitida""},

  
  

  {
    ER_CANNOT_OVERWRITE_CAUSE,
			""No se puede sobrescribir la causa""},

   
  

  {
    ER_NO_DEFAULT_IMPL,
         ""No se ha encontrado ninguna implementación predeterminada ""},
  
   
  

  {
    ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
       ""ChunkedIntArray({0}) no se utiliza actualmente""},
  
   
  

  {
    ER_OFFSET_BIGGER_THAN_SLOT,
       ""La desviación es mayor que el intervalo""},
  
   
  

  {
    ER_COROUTINE_NOT_AVAIL,
       ""Corrutina no disponible, id={0}""},
  
   
  

  {
    ER_COROUTINE_CO_EXIT,
       ""CoroutineManager ha recibido una solicitud co_exit()""},
  
   
  

  {
    ER_COJOINROUTINESET_FAILED,
       ""Fallo co_joinCoroutineSet()""},
  
   
  

  {
    ER_COROUTINE_PARAM,
       ""Error de parámetro de corrutina({0})""},
  
   
  

  {
    ER_PARSER_DOTERMINATE_ANSWERS,
       ""
UNEXPECTED: el analizador sintáctico doTerminate responde {0}""},
  
   
  

  {
    ER_NO_PARSE_CALL_WHILE_PARSING,
       ""no puede invocarse el analizador sintáctico con un análisis sintáctico en curso""},
  
   
  

  {
    ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""Error: El iterador introducido para el eje  {0} no está implementado""},
  
   
  

  {
    ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""Error: el iterador para el eje {0} no está implementado ""},
  
   
  

  {
    ER_ITERATOR_CLONE_NOT_SUPPORTED,
       ""no se admite clon del iterador""},
  
   
  

  {
    ER_UNKNOWN_AXIS_TYPE,
       ""El tipo de eje transversal es desconocido: {0}""},
  
   
  

  {
    ER_AXIS_NOT_SUPPORTED,
       ""No se admite traverser de eje: {0}""},
  
   
  

  {
    ER_NO_DTMIDS_AVAIL,
       ""No hay más Id de DTM disponibles""},
  
   
  

  {
    ER_NOT_SUPPORTED,
       ""No se admite: {0}""},
  
   
  

  {
    ER_NODE_NON_NULL,
       ""El nodo no puede ser nulo para getDTMHandleFromNode""},
  
   
  

  {
    ER_COULD_NOT_RESOLVE_NODE,
       ""No se ha podido convertir el nodo en un manejador""},
  
   
  

  {
    ER_STARTPARSE_WHILE_PARSING,
       ""no se puede invocar startParse con un análisis sintáctico en curso""},
  
   
  

  {
    ER_STARTPARSE_NEEDS_SAXPARSER,
       ""startParse no admite SAXParser nulo""},
  
   
  

  {
    ER_COULD_NOT_INIT_PARSER,
       ""No se ha podido inicializar el analizador sintáctico con""},
  
   
  

  {
    ER_EXCEPTION_CREATING_POOL,
       ""se ha producido una excepción al crear una nueva instancia para pool""},
  
   
  

  {
    ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
       ""El trayecto contiene una secuencia de escape no válida""},
  
   
  

  {
    ER_SCHEME_REQUIRED,
       ""Se necesita un esquema.""},
  
   
  

  {
    ER_NO_SCHEME_IN_URI,
       ""No se ha encontrado ningún esquema en el URI: {0}""},
  
   
  

  {
    ER_NO_SCHEME_INURI,
       ""No se ha encontrado ningún esquema en el URI""},
  
   
  

  {
    ER_PATH_INVALID_CHAR,
       ""El trayecto contiene un carácter no válido: {0}""},
  
   
  

  {
    ER_SCHEME_FROM_NULL_STRING,
       ""No se puede establecer un esquema a partir de una cadena nula""},
  
   
  

  {
    ER_SCHEME_NOT_CONFORMANT,
       ""El esquema no es aceptable.""},
  
   
  

  {
    ER_HOST_ADDRESS_NOT_WELLFORMED,
       ""El sistema central no es una dirección bien construida""},
  
   
  

  {
    ER_PORT_WHEN_HOST_NULL,
       ""No puede establecerse el puerto cuando el sistema central es nulo""},
  
   
  

  {
    ER_INVALID_PORT,
       ""Número de puerto no válido""},
  
   
  

  {
    ER_FRAG_FOR_GENERIC_URI,
       ""Sólo puede establecerse el fragmento para un URI genérico""},
  
   
  

  {
    ER_FRAG_WHEN_PATH_NULL,
       ""No puede establecerse el fragmento cuando el trayecto es nulo""},
  
   
  

  {
    ER_FRAG_INVALID_CHAR,
       ""El fragmento contiene un carácter no válido""}, 
  
   
  

  {
    ER_PARSER_IN_USE,
        ""El analizador sintáctico está en uso""},
  
   
  

  {
    ER_CANNOT_CHANGE_WHILE_PARSING,
        ""No se puede cambiar {0} {1} mientras el análisis sintáctico está en curso""},
  
   
  

  {
    ER_SELF_CAUSATION_NOT_PERMITTED,
        ""No se permite la autocausalidad""},
  
   
  

  {
    ER_NO_USERINFO_IF_NO_HOST,
        ""La información de usuario no puede especificarse si no se especifica el sistema central""},
  
   
  

  {
    ER_NO_PORT_IF_NO_HOST,
        ""El puerto no puede especificarse si no está especificado el sistema central""},
  
   
  

  {
    ER_NO_QUERY_STRING_IN_PATH,
        ""La cadena de consulta no puede especificarse a la vez en el trayecto y en la cadena de consulta""},
  
   
  

  {
    ER_NO_FRAGMENT_STRING_IN_PATH,
        ""El fragmento no puede especificarse a la vez en el trayecto y en el fragmento""},
  
   
  

  {
    ER_CANNOT_INIT_URI_EMPTY_PARMS,
        ""No se puede inicializar el URI con parámetros vacíos""},
  
  
  

  {
    ER_METHOD_NOT_SUPPORTED,
        ""Método todavía no utilizado""},

  
  

  {
    ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
     ""IncrementalSAXSource_Filter no puede reiniciarse actualmente""},
  
  
  

  {
    ER_XMLRDR_NOT_BEFORE_STARTPARSE,
     ""XMLReader no antes de una solicitud startParse""},

  
  
  {
    ER_AXIS_TRAVERSER_NOT_SUPPORTED,
     ""No se admite el eje transversal: {0}""},

  
  
  {
    ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
     ""ListingErrorHandler creado con PrintWriter nulo""},

  
  {
    ER_SYSTEMID_UNKNOWN,
     ""Id de sistema desconocido""},

  
  
  {
    ER_LOCATION_UNKNOWN,
     ""Ubicación del error desconocida""},

  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""El prefijo debe convertirse en un espacio de nombre: {0}""},

  
  


  {
    ER_CREATEDOCUMENT_NOT_SUPPORTED,
      ""createDocument no admitido en XPathContext.""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT,
      ""El atributo hijo no tiene documento propietario!""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
      ""El atributo hijo no tiene elemento de documento propietario!""},

  
  


  {
    ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
      ""Advertencia: no puede enviar el texto antes del elemento de documento. Se ignora...""},


  
  


  {
    ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
      ""No puede haber más de una raíz en un DOM.""},

  
   
  


  {
    ER_ARG_LOCALNAME_NULL,
       ""El argumentoArgument 'localName' es nulo.""},

  
  
  

  
  


  {
    ER_ARG_LOCALNAME_INVALID,
       ""El nombre local especificado en QNAME debe ser un nombre NCName válido""},
  
  
  
  

  
  


  {
    ER_ARG_PREFIX_INVALID,
       ""El prefijo especificado en QNAME debe ser un nombre NCName válido""},

  { ""BAD_CODE"",
      ""El parámetro para crear el mensaje estaba fuera de los límites""},
  { ""FORMAT_FAILED"",
      ""Excepción generada durante la llamada messageFormat""},
  { ""line"", ""Línea #""},
  { ""column"", ""Columna #""}
  
  };
  
  
  public Object[][] getContents()
  {
    return contents;
  }
    
}"
org.apache.xml.utils.synthetic.Class,65,1,0,7,135,508,6,4,59,0.7375,2297,0.85,12,0.0,0.1515625,0,0,34.03076923,18,1.8462,1,"
package org.apache.xml.utils.synthetic;

import java.lang.reflect.Modifier;

import org.apache.xml.utils.synthetic.reflection.Constructor;
import org.apache.xml.utils.synthetic.reflection.Field;
import org.apache.xml.utils.synthetic.reflection.Method;




public class Class extends Object implements java.io.Serializable
{

  
  private static java.util.Hashtable global_classtable =
    new java.util.Hashtable();

  
  private java.lang.String name;

  
  private java.lang.Class realclass = null;

  
  private int modifiers;

  
  private boolean isInterface = false;

  
  private Class superclass = null;

  
  private Class declaringclass = null;

  
  private Class[] interfaces = new Class[0];

  
  private Class[] allclasses = new Class[0];

  
  private Class[] declaredclasses = new Class[0];

  
  private Constructor[] allconstructors = new Constructor[0];

  
  private Constructor[] declaredconstructors = new Constructor[0];

  
  private Method[] allmethods = new Method[0];

  
  private Method[] declaredmethods = new Method[0];

  
  private Field[] allfields = new Field[0];

  
  private Field[] declaredfields = new Field[0];

  
  private Class[] innerclasses = new Class[0];

  
  Class(java.lang.Class realclass)
  {

    this(realclass.getName());

    try
    {
      setRealClass(realclass);
    }
    catch (SynthesisException e)
    {
      e.printStackTrace();
    }
  }

  
  Class(String fullname)
  {

    this.name = fullname;

    global_classtable.put(fullname, this);
  }

  
  public static Class forClass(java.lang.Class cls)
  {

    if (cls == null)
      return null;

    Class ret = (Class) (global_classtable.get(cls.getName()));

    if (null == ret)
      ret = new Class(cls);

    return ret;
  }

  
  public Class forNameInContext(String classname)
          throws ClassNotFoundException
  {

    for (int i = innerclasses.length - 1; i >= 0; --i)
    {
      if (classname.equals(innerclasses[i].getShortName()))
        return innerclasses[i];
    }

    return forName(classname);
  }

  
  public static Class forName(String className) throws ClassNotFoundException
  {

    
    
    
    if (className.endsWith(""]""))
    {
      StringBuffer arrayname = new StringBuffer();

      for (int i = className.indexOf('['); i != -1;
              i = className.indexOf('[', i + 1))
      {
        arrayname.append('[');
      }

      
      
      
      
      String classname = className.substring(0, className.indexOf('['));

      if (""byte"".equals(classname))
        arrayname.append('B');
      else if (""char"".equals(classname))
        arrayname.append('C');
      else if (""double"".equals(classname))
        arrayname.append('D');
      else if (""float"".equals(classname))
        arrayname.append('F');
      else if (""int"".equals(classname))
        arrayname.append('I');
      else if (""long"".equals(classname))
        arrayname.append('J');
      else if (""short"".equals(classname))
        arrayname.append('S');
      else if (""boolean"".equals(classname))
        arrayname.append('Z');
      else
        arrayname.append('L').append(classname).append(';');

      
      return forName(arrayname.toString());
    }

    Class ret = (Class) (global_classtable.get(className));

    if (null == ret)
    {

      
      
      
      if (""boolean"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Boolean.TYPE;
      }
      else if (""byte"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Byte.TYPE;
      }
      else if (""char"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Character.TYPE;
      }
      else if (""short"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Short.TYPE;
      }
      else if (""int"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Integer.TYPE;
      }
      else if (""long"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Long.TYPE;
      }
      else if (""float"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Float.TYPE;
      }
      else if (""double"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Double.TYPE;
      }
      else if (""void"".equals(className))
      {

        
        
        ret = new Class(className);
        ret.realclass = java.lang.Class.forName(""java.lang.Object"");
      }

      
      
      
      else
        ret = new Class(java.lang.Class.forName(className));
    }

    return ret;
  }

  
  public static Class declareClass(String className) throws SynthesisException
  {

    Class ret = (Class) (global_classtable.get(className));

    if (null == ret)
      ret = new Class(className);

    if (ret.realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    return ret;
  }

  
  public static Class reallyDeclareClass(String className)
  {

    Class ret = (Class) (global_classtable.get(className));

    if (null != ret)
      global_classtable.remove(ret);

    ret = new Class(className);

    return ret;
  }

  
  public Class[] getClasses()
  {

    if (realclass != null && allclasses == null)
    {
      java.lang.Class[] realDE = realclass.getClasses();

      allclasses = new Class[realDE.length];

      for (int i = 0; i < realDE.length; ++i)
      {
        allclasses[i] = forClass(realDE[i]);
      }
    }

    return allclasses;
  }

  
  public ClassLoader getClassLoader()
  {
    return (realclass == null) ? null : realclass.getClassLoader();
  }

  
  public Class getComponentType()
  {
    return realclass == null ? null : new Class(realclass.getComponentType());
  }

  
  public Constructor getConstructor(Class parameterTypes[])
          throws NoSuchMethodException, SecurityException, SynthesisException
  {

    if (realclass == null)
      throw new SynthesisException(SynthesisException.UNREIFIED);

    java.lang.Class[] real = new java.lang.Class[parameterTypes.length];

    for (int i = 0; i < parameterTypes.length; ++i)
    {
      if ((real[i] = parameterTypes[i].getRealClass()) == null)
        throw new SynthesisException(SynthesisException.UNREIFIED);
    }

    return new Constructor(realclass.getConstructor(real), this);
  }

  
  public Constructor[] getConstructors() throws SecurityException
  {

    if (realclass != null && allconstructors == null)
    {
      java.lang.reflect.Constructor[] realDC = realclass.getConstructors();

      allconstructors = new Constructor[realDC.length];

      for (int i = 0; i < realDC.length; ++i)
      {
        allconstructors[i] = new Constructor(realDC[i], this);
      }
    }

    return allconstructors;
  }

  
  public Class[] getDeclaredClasses() throws SecurityException
  {

    
    if (realclass != null && declaredclasses == null)
    {
      java.lang.Class[] realDE = realclass.getDeclaredClasses();

      declaredclasses = new Class[realDE.length];

      for (int i = 0; i < realDE.length; ++i)
      {
        declaredclasses[i] = forClass(realDE[i]);

        if (!realDE[i].isInterface())
          superclass = declaredclasses[i];
      }
    }

    return declaredclasses;
  }

  
  public void addExtends(Class newclass) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Class[] scratch = new Class[declaredclasses.length + 1];

    System.arraycopy(declaredclasses, 0, scratch, 0, declaredclasses.length);

    scratch[declaredclasses.length] = newclass;
    declaredclasses = scratch;
  }

  
  public Constructor getDeclaredConstructor(Class parameterTypes[])
          throws NoSuchMethodException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Constructor declareConstructor() throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Constructor newctor = new Constructor(this);
    Constructor[] scratch = new Constructor[declaredconstructors.length + 1];

    System.arraycopy(declaredconstructors, 0, scratch, 0,
                     declaredconstructors.length);

    scratch[declaredconstructors.length] = newctor;
    declaredconstructors = scratch;
    scratch = new Constructor[allconstructors.length + 1];

    System.arraycopy(allconstructors, 0, scratch, 0, allconstructors.length);

    scratch[allconstructors.length] = newctor;
    allconstructors = scratch;

    return newctor;
  }

  
  public Class declareInterface(Class newifce) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    if (!newifce.isInterface())
      throw new SynthesisException(SynthesisException.SYNTAX,
                                   newifce.getName() + "" isn't an interface"");

    Class[] scratch = new Class[interfaces.length + 1];

    System.arraycopy(interfaces, 0, scratch, 0, interfaces.length);

    scratch[interfaces.length] = newifce;
    interfaces = scratch;
    scratch = new Class[allclasses.length + 1];

    System.arraycopy(allclasses, 0, scratch, 0, allclasses.length);

    scratch[allclasses.length] = newifce;
    allclasses = scratch;

    return newifce;
  }

  
  public Constructor[] getDeclaredConstructors() throws SecurityException
  {

    if (realclass != null && declaredconstructors == null)
    {
      java.lang.reflect.Constructor[] realDC =
        realclass.getDeclaredConstructors();

      declaredconstructors = new Constructor[realDC.length];

      for (int i = 0; i < realDC.length; ++i)
      {
        declaredconstructors[i] = new Constructor(realDC[i], this);
      }
    }

    return declaredconstructors;
  }

  
  public Field getDeclaredField(String name)
          throws NoSuchFieldException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Field declareField(String name) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Field newfield = new Field(name, this);
    Field[] scratch = new Field[declaredfields.length + 1];

    System.arraycopy(declaredfields, 0, scratch, 0, declaredfields.length);

    scratch[declaredfields.length] = newfield;
    declaredfields = scratch;
    scratch = new Field[allfields.length + 1];

    System.arraycopy(allfields, 0, scratch, 0, allfields.length);

    scratch[allfields.length] = newfield;
    allfields = scratch;

    return newfield;
  }

  
  public Field[] getDeclaredFields() throws SecurityException
  {

    if (realclass != null && declaredfields == null)
    {
      java.lang.reflect.Field[] realDF = realclass.getDeclaredFields();

      declaredfields = new Field[realDF.length];

      for (int i = 0; i < realDF.length; ++i)
      {
        declaredfields[i] = new Field(realDF[i], this);
      }
    }

    return declaredfields;
  }

  
  public Method getDeclaredMethod(String name, Class parameterTypes[])
          throws NoSuchMethodException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Method declareMethod(String name) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Method newMethod = new Method(name, this);
    Method[] scratch = new Method[declaredmethods.length + 1];

    System.arraycopy(declaredmethods, 0, scratch, 0, declaredmethods.length);

    scratch[declaredmethods.length] = newMethod;
    declaredmethods = scratch;
    scratch = new Method[allmethods.length + 1];

    System.arraycopy(allmethods, 0, scratch, 0, allmethods.length);

    scratch[allmethods.length] = newMethod;
    allmethods = scratch;

    return newMethod;
  }

  
  public Method[] getDeclaredMethods() throws SecurityException
  {

    if (realclass != null && declaredmethods == null)
    {
      java.lang.reflect.Method[] realDM = realclass.getDeclaredMethods();

      declaredmethods = new Method[realDM.length];

      for (int i = 0; i < realDM.length; ++i)
      {
        declaredmethods[i] = new Method(realDM[i], this);
      }
    }

    return declaredmethods;
  }

  
  public Class getDeclaringClass()
  {

    if (realclass != null && declaringclass == null)
    {
      java.lang.Class dc = realclass.getDeclaringClass();

      if (dc == null)
        declaringclass = null;
      else
        declaringclass = forClass(dc);
    }

    return declaringclass;
  }

  
  private void addInnerClass(Class newclass) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    if (newclass.getDeclaringClass() != this)
      throw new SynthesisException(SynthesisException.WRONG_OWNER);

    Class[] scratch = new Class[innerclasses.length + 1];

    System.arraycopy(innerclasses, 0, scratch, 0, innerclasses.length);

    scratch[innerclasses.length] = newclass;
    innerclasses = scratch;
  }

  
  public Class declareInnerClass(String className) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    String relativeName = getName() + ""$"" + className;
    Class newclass = (Class) (global_classtable.get(relativeName));

    if (newclass != null)
      throw new SynthesisException(SynthesisException.SYNTAX,
                                   ""Inner class "" + name + "" already exists"");

    newclass = new Class(className);
    newclass.declaringclass = this;

    Class[] scratch = new Class[innerclasses.length + 1];

    System.arraycopy(innerclasses, 0, scratch, 0, innerclasses.length);

    scratch[innerclasses.length] = newclass;
    innerclasses = scratch;

    return newclass;
  }

  
  public Class[] getInnerClasses()
  {
    return innerclasses;
  }

  
  public Field getField(String name)
          throws NoSuchFieldException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Field[] getFields() throws SecurityException
  {

    if (realclass != null && allfields == null)
    {
      java.lang.reflect.Field[] realDF = realclass.getFields();

      allfields = new Field[realDF.length];

      for (int i = 0; i < realDF.length; ++i)
      {
        allfields[i] = new Field(realDF[i], this);
      }
    }

    return allfields;
  }

  
  public Class[] getInterfaces()
  {

    if (realclass != null && interfaces == null)
    {
      java.lang.Class[] realI = realclass.getInterfaces();

      interfaces = new Class[realI.length];

      for (int i = 0; i < realI.length; ++i)
      {
        interfaces[i] = forClass(realI[i]);
      }
    }

    return interfaces;
  }

  
  public void addImplements(Class newclass) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Class[] scratch = new Class[interfaces.length + 1];

    System.arraycopy(interfaces, 0, scratch, 0, interfaces.length);

    scratch[interfaces.length] = newclass;
    interfaces = scratch;
  }

  
  public Method getMethod(String name, Class parameterTypes[])
          throws NoSuchMethodException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Method[] getMethods() throws SecurityException
  {

    if (realclass != null && allmethods == null)
    {
      java.lang.reflect.Method[] realDM = realclass.getMethods();

      allmethods = new Method[realDM.length];

      for (int i = 0; i < realDM.length; ++i)
      {
        allmethods[i] = new Method(realDM[i], this);
      }
    }

    return allmethods;
  }

  
  public int getModifiers()
  {
    return modifiers;
  }

  
  public void setModifiers(int modifiers) throws SynthesisException
  {

    if (this.realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.modifiers = modifiers;
  }

  
  public java.lang.String getName()
  {
    return name;
  }

  
  public java.lang.String getJavaName()
  {

    if (name.charAt(0) != '[')
      return name;

    
    
    int count = name.lastIndexOf('[');
    StringBuffer jname = new StringBuffer(name.substring(count + 2));

    
    jname.setLength(jname.length() - 1);

    while (count-- >= 0)
    {
      jname.append(""[]"");
    }

    return jname.toString();
  }

  
  public java.lang.String getShortName()
  {

    int start = name.lastIndexOf(""."");

    if (start != 0 || name.charAt(0) == '.')
      ++start;

    if (declaringclass != null)
    {
      int d = name.lastIndexOf('$', start);

      if (d != 0)
        start = d + 1;
    }

    return name.substring(start);
  }

  
  public java.lang.String getJavaShortName()
  {

    String shortname = getShortName();

    if (shortname.charAt(0) != '[')
      return shortname;

    
    
    int count = shortname.lastIndexOf('[');
    StringBuffer jname = new StringBuffer(shortname.substring(count + 2));

    
    jname.setLength(jname.length() - 1);

    while (count-- >= 0)
    {
      jname.append(""[]"");
    }

    return jname.toString();
  }

  
  public java.lang.String getPackageName()
  {

    int start = name.lastIndexOf(""."");

    return name.substring(0, start);
  }

  
  public java.lang.Class getRealClass()
  {
    return realclass;
  }

  
  public void setRealClass(java.lang.Class realclass)
          throws SynthesisException
  {

    if (this.realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.realclass = realclass;
    this.modifiers = realclass.getModifiers();
    this.isInterface = realclass.isInterface();

    
    this.declaringclass = null;
    this.interfaces = null;
    this.declaredconstructors = null;
    this.allconstructors = null;
    this.declaredmethods = null;
    this.allmethods = null;
    this.declaredfields = null;
    this.allfields = null;
    this.declaredclasses = null;
    this.allclasses = null;
    this.superclass = null;
  }

  
  public void setSuperClass(Class superclass) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.superclass = superclass;
  }

  
  public void setSuperClass(java.lang.Class superclass)
          throws ClassNotFoundException, SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.superclass = Class.forClass(superclass);
  }

  
  public java.net.URL getResource(String name)
  {
    throw new java.lang.IllegalStateException();
  }

  
  public java.io.InputStream getResourceAsStream(String name)
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Object[] getSigners()
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Class getSuperclass()
  {

    if (realclass != null && superclass == null)
    {
      superclass = forClass(realclass.getSuperclass());

      
    }

    if (superclass == null)
      superclass = forClass(Object.class);

    return superclass;
  }

  
  public boolean isArray()
  {
    return realclass != null && realclass.isArray();
  }

  
  public boolean isAssignableFrom(Class cls)
  {

    if (realclass != null && cls.realclass != null)
      return realclass.isAssignableFrom(cls.realclass);

    throw new java.lang.IllegalStateException();
  }

  
  public boolean isAssignableFrom(java.lang.Class cls)
  {

    if (realclass != null)
      return realclass.isAssignableFrom((java.lang.Class) cls);

    throw new java.lang.IllegalStateException();
  }

  
  public boolean isInstance(Object obj)
  {

    if (realclass != null)
      return realclass.isInstance(obj);

    
    
    throw new java.lang.IllegalStateException();
  }

  
  public boolean isInterface()
  {
    return (realclass != null) ? realclass.isInterface() : isInterface;
  }

  
  public void isInterface(boolean isInterface) throws SynthesisException
  {

    if (realclass == null)
      this.isInterface = isInterface;
    else if (realclass.isInterface() != isInterface)
      throw new SynthesisException(SynthesisException.REIFIED);
  }

  
  public boolean isPrimitive()
  {
    return realclass != null && realclass.isPrimitive();
  }

  
  public Object newInstance()
          throws InstantiationException, IllegalAccessException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public String toString()
  {

    if (realclass != null)
      return realclass.toString();
    else if (isInterface())
      return ""interface "" + name;
    else
      return ""class "" + name;
  }

  
  public void toSource(java.io.OutputStream out, int depth)
  {

    java.io.PrintWriter writer = new java.io.PrintWriter(out);

    toSource(writer, depth);
  }

  
  public void toSource(java.io.PrintWriter out, int depth)
  {

    String tab = tabset(depth);

    if (realclass != null)
      out.println(
        tab
        + """");
    else
      out.println(
        tab
        + """");

    
    if (getDeclaringClass() == null)
      out.println(tab + ""package "" + getPackageName() + "";"");

    out.print(tab + Modifier.toString(getModifiers()));

    if (isInterface())
      out.print("" interface "");
    else
      out.print("" class "");

    out.println(getJavaShortName());

    if (superclass != null)
    {
      out.print('
' + tab + "" extends "" + superclass.getJavaName());
    }

    Class[] ext = getInterfaces();

    if (ext != null & ext.length > 0)
    {

      
      
      out.print('
' + tab + (isInterface ? "" extends "" : "" implements "")
                + ext[0].getName());

      for (int i = 1; i < ext.length; ++i)
      {
        out.print("", "" + ext[i].getJavaName());
      }

      out.print(""
"");
    }

    out.print(tab + ""{
"");

    tab = tabset(++depth);

    
    Field[] fields = null;

    try
    {
      fields = getDeclaredFields();
    }
    catch (SecurityException e)
    {
      out.println(tab + ""
    }

    if (fields != null)
    {
      for (int i = 0; i < fields.length; ++i)
      {
        out.println(tab + fields[i].toSource());
      }
    }

    
    Constructor[] ctors = null;

    try
    {
      ctors = getDeclaredConstructors();
    }
    catch (SecurityException e)
    {
      out.println(tab + ""
    }

    if (ctors != null)
    {
      for (int i = 0; i < ctors.length; ++i)
      {
        out.print(ctors[i].toSource(tab));
      }
    }

    
    Method[] methods = null;

    try
    {
      methods = getDeclaredMethods();
    }
    catch (SecurityException e)
    {
      out.println(tab + ""
    }

    if (methods != null)
    {
      for (int i = 0; i < methods.length; ++i)
      {
        out.print('
');
        out.print(methods[i].toSource(tab));
      }
    }

    
    Class[] inners = getInnerClasses();

    if (inners != null)
    {
      for (int i = 0; i < inners.length; ++i)
      {
        out.print('
');
        inners[i].toSource(out, depth);
      }
    }

    
    tab = tabset(--depth);

    out.print(tab + ""}
"");
    out.flush();
  }

  
  private String tabset(int depth)
  {

    StringBuffer t = new StringBuffer();

    while (depth-- > 0)
    {
      t.append(""    "");
    }

    return t.toString();
  }

  

  
  static final int[] val = { Modifier.ABSTRACT, Modifier.FINAL,
                             Modifier.INTERFACE, Modifier.NATIVE,
                             Modifier.PRIVATE, Modifier.PROTECTED,
                             Modifier.PUBLIC, Modifier.STATIC,
                             Modifier.SYNCHRONIZED, Modifier.TRANSIENT,
                             Modifier.VOLATILE };

  
  static final String[] kwd = { ""abstract"", ""final"", ""interface"", ""native"",
                                ""private"", ""protected"", ""public"", ""static"",
                                ""synchronized"", ""transient"", ""volatile"" };

  
  static public int modifierFromString(String t)
  {

    for (int i = 0; i < kwd.length; ++i)
    {
      if (kwd[i].equals(t))
        return val[i];
    }

    return 0;
  }

  
  static public int modifiersFromString(String s)
  {

    int mods = 0;
    java.util.StringTokenizer parts = new java.util.StringTokenizer(s);

    while (parts.hasMoreTokens())
    {
      String t = parts.nextToken();

      mods |= modifierFromString(t);
    }

    return mods;
  }
}
"
org.apache.xalan.processor.ProcessorExsltFunction,6,5,0,26,27,15,1,25,4,2.0,226,0.0,0,0.97706422,0.533333333,2,4,36.66666667,6,1.6667,2,"
package org.apache.xalan.processor;

import javax.xml.transform.SourceLocator;

import org.apache.xalan.templates.ElemApplyImport;
import org.apache.xalan.templates.ElemApplyTemplates;
import org.apache.xalan.templates.ElemAttribute;
import org.apache.xalan.templates.ElemCallTemplate;
import org.apache.xalan.templates.ElemComment;
import org.apache.xalan.templates.ElemCopy;
import org.apache.xalan.templates.ElemCopyOf;
import org.apache.xalan.templates.ElemElement;
import org.apache.xalan.templates.ElemExsltFuncResult;
import org.apache.xalan.templates.ElemExsltFunction;
import org.apache.xalan.templates.ElemFallback;
import org.apache.xalan.templates.ElemLiteralResult;
import org.apache.xalan.templates.ElemNumber;
import org.apache.xalan.templates.ElemPI;
import org.apache.xalan.templates.ElemParam;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemText;
import org.apache.xalan.templates.ElemTextLiteral;
import org.apache.xalan.templates.ElemValueOf;
import org.apache.xalan.templates.ElemVariable;
import org.apache.xalan.templates.Stylesheet;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;



public class ProcessorExsltFunction extends ProcessorTemplateElem
{
  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws SAXException
  {
    
    String msg = """";
    if (!(handler.getElemTemplateElement() instanceof Stylesheet))
    {
      msg = ""func:function element must be top level."";
      handler.error(msg, new SAXException(msg));
    }
    super.startElement(handler, uri, localName, rawName, attributes);
       
    String val = attributes.getValue(""name"");
    int indexOfColon = val.indexOf("":"");
    if (indexOfColon > 0)
    {
      String prefix = val.substring(0, indexOfColon);
      String localVal = val.substring(indexOfColon + 1);
      String ns = handler.getNamespaceSupport().getURI(prefix);
      
      
    }
    else
    {
      msg = ""func:function name must have namespace"";
      handler.error(msg, new SAXException(msg));
    }
  }
  
  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws SAXException
  {
    
    super.appendAndPush(handler, elem);
    
    elem.setDOMBackPointer(handler.getOriginatingNode());
    handler.getStylesheet().setTemplate((ElemTemplate) elem);
  }
    
  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws SAXException
  {
   ElemTemplateElement function = handler.getElemTemplateElement();
   SourceLocator locator = handler.getLocator();
   validate(function, handler); 
   super.endElement(handler, uri, localName, rawName);   
  }
  
  
  public void validate(ElemTemplateElement elem, StylesheetHandler handler)
    throws SAXException
  {
    String msg = """";
    while (elem != null)
    { 
      
      if (elem instanceof ElemExsltFuncResult 
          && elem.getNextSiblingElem() != null 
          && !(elem.getNextSiblingElem() instanceof ElemFallback))
      {
        msg = ""func:result has an illegal following sibling (only xsl:fallback allowed)"";
        handler.error(msg, new SAXException(msg));
      }
      
      if((elem instanceof ElemApplyImport
	 || elem instanceof ElemApplyTemplates
	 || elem instanceof ElemAttribute
	 || elem instanceof ElemCallTemplate
	 || elem instanceof ElemComment
	 || elem instanceof ElemCopy
	 || elem instanceof ElemCopyOf
	 || elem instanceof ElemElement
	 || elem instanceof ElemLiteralResult
	 || elem instanceof ElemNumber
	 || elem instanceof ElemPI
	 || elem instanceof ElemText
	 || elem instanceof ElemTextLiteral
	 || elem instanceof ElemValueOf)
	&& !(ancestorIsOk(elem)))
      {
        msg =""misplaced literal result in a func:function container."";
        handler.error(msg, new SAXException(msg));
      }
      ElemTemplateElement nextElem = elem.getFirstChildElem();
      while (nextElem == null)
      {
        nextElem = elem.getNextSiblingElem();
        if (nextElem == null)
          elem = elem.getParentElem();
        if (elem == null || elem instanceof ElemExsltFunction)
          return; 
      }  
      elem = nextElem;
    }
  }
  
  
  
  boolean ancestorIsOk(ElemTemplateElement child)
  {
    while (child.getParentElem() != null && !(child.getParentElem() instanceof ElemExsltFunction))
    {
      ElemTemplateElement parent = child.getParentElem();
      if (parent instanceof ElemExsltFuncResult 
          || parent instanceof ElemVariable
          || parent instanceof ElemParam)
        return true;
      child = parent;      
    }
    return false;
  }
  
}"
org.apache.xalan.templates.ElemChoose,6,3,0,9,26,15,0,9,6,2.0,160,0.0,0,0.975124378,0.444444444,2,6,25.66666667,4,1.3333,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;


public class ElemChoose extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_CHOOSE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_CHOOSE_STRING;
  }

  
  public ElemChoose(){}

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    boolean found = false;

    for (ElemTemplateElement childElem = getFirstChildElem();
            childElem != null; childElem = childElem.getNextSiblingElem())
    {
      int type = childElem.getXSLToken();

      if (Constants.ELEMNAME_WHEN == type)
      {
        found = true;

        ElemWhen when = (ElemWhen) childElem;

        
        XPathContext xctxt = transformer.getXPathContext();
        int sourceNode = xctxt.getCurrentNode();
        
        
        
        
        

        if (TransformerImpl.S_DEBUG)
        {
          XObject test = when.getTest().execute(xctxt, sourceNode, when);

          if (TransformerImpl.S_DEBUG)
            transformer.getTraceManager().fireSelectedEvent(sourceNode, when,
                    ""test"", when.getTest(), test);

          if (test.bool())
          {
            transformer.getTraceManager().fireTraceEvent(when);
            
            transformer.executeChildTemplates(when, true);

	        transformer.getTraceManager().fireTraceEndEvent(when); 
	                  
            return;
          }

        }
        else if (when.getTest().bool(xctxt, sourceNode, when))
        {
          transformer.executeChildTemplates(when, true);

          return;
        }
      }
      else if (Constants.ELEMNAME_OTHERWISE == type)
      {
        found = true;

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(childElem);

        
        transformer.executeChildTemplates(childElem, true);

        if (TransformerImpl.S_DEBUG)
	      transformer.getTraceManager().fireTraceEndEvent(childElem); 
        return;
      }
    }

    if (!found)
      transformer.getMsgMgr().error(
        this, XSLTErrorResources.ER_CHOOSE_REQUIRES_WHEN);
        
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this);         
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {
    case Constants.ELEMNAME_WHEN :
    case Constants.ELEMNAME_OTHERWISE :

      
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
  
  
  public boolean canAcceptVariables()
  {
  	return false;
  }

}
"
org.apache.xalan.xsltc.CollatorFactory,2,1,0,2,2,1,2,0,2,2.0,2,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

import java.text.Collator;
import java.util.Locale;

public interface CollatorFactory {
    
    public Collator getCollator(String lang, String country);
    public Collator getCollator(Locale locale);
}
"
org.apache.xalan.xsltc.compiler.ParameterRef,3,4,0,18,31,1,1,17,3,2.0,152,0.0,0,0.974358974,0.5,2,3,49.66666667,8,3.0,2,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;

final class ParameterRef extends VariableRefBase {

    public ParameterRef(Param param) {
	super(param);
    }

    public String toString() {
	return ""parameter-ref(""+_variable.getName()+'/'+_variable.getType()+')';
    }

   public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final String name = _variable.getVariable();
	final String signature = _type.toSignature();

	if (_variable.isLocal()) {
	    if (classGen.isExternal()) {
		Closure variableClosure = _closure;
		while (variableClosure != null) {
		    if (variableClosure.inInnerClass()) break;
		    variableClosure = variableClosure.getParentClosure();
		}
	    
		if (variableClosure != null) {
		    il.append(ALOAD_0);
		    il.append(new GETFIELD(
			cpg.addFieldref(variableClosure.getInnerClassName(), 
			    name, signature)));
		}
		else {
		    il.append(_variable.loadInstruction());
		    _variable.removeReference(this);
		}
	    }
	    else {
		il.append(_variable.loadInstruction());
		_variable.removeReference(this);
	    }
	}
	else {
	    final String className = classGen.getClassName();
	    il.append(classGen.loadTranslet());
	    if (classGen.isExternal()) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }
	    il.append(new GETFIELD(cpg.addFieldref(className,name,signature)));
	}

	if (_variable.getType() instanceof NodeSetType) {
	    
	    final int clone = cpg.addInterfaceMethodref(NODE_ITERATOR,
						       ""cloneIterator"",
						       ""()"" + 
							NODE_ITERATOR_SIG);
	    il.append(new INVOKEINTERFACE(clone, 1));
	}
    }
}
"
org.apache.xalan.xsltc.compiler.FilterParentPath,6,3,0,24,31,0,2,22,6,0.333333333,213,1.0,2,0.934210526,0.305555556,2,7,34.0,4,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class FilterParentPath extends Expression {

    private Expression _filterExpr;
    private Expression _path;
    private boolean _hasDescendantAxis = false;

    public FilterParentPath(Expression filterExpr, Expression path) {
	(_path = path).setParent(this);
	(_filterExpr = filterExpr).setParent(this);
    }
		
    public void setParser(Parser parser) {
	super.setParser(parser);
	_filterExpr.setParser(parser);
	_path.setParser(parser);
    }
    
    public String toString() {
	return ""FilterParentPath("" + _filterExpr + "", "" + _path + ')';
    }

    public void setDescendantAxis() {
	_hasDescendantAxis = true;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type ftype = _filterExpr.typeCheck(stable);
	if (ftype instanceof NodeSetType == false) {
	    if (ftype instanceof ReferenceType)  {
		_filterExpr = new CastExpr(_filterExpr, Type.NodeSet);
	    }
	    
	    else if (ftype instanceof NodeType)  {
		_filterExpr = new CastExpr(_filterExpr, Type.NodeSet);
	    }
	    else {
		throw new TypeCheckError(this);
	    }
	}

	
	final Type ptype = _path.typeCheck(stable);
	if (!(ptype instanceof NodeSetType)) {
	    _path = new CastExpr(_path, Type.NodeSet);
	}

	return _type = Type.NodeSet;	
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	
	final int initSI = cpg.addMethodref(STEP_ITERATOR_CLASS,
					    ""<init>"",
					    ""(""
					    +NODE_ITERATOR_SIG
					    +NODE_ITERATOR_SIG
					    +"")V"");
	il.append(new NEW(cpg.addClass(STEP_ITERATOR_CLASS)));
	il.append(DUP);

	
	_filterExpr.translate(classGen, methodGen);
	_path.translate(classGen, methodGen);

	
	il.append(new INVOKESPECIAL(initSI));

	
        if (_hasDescendantAxis) {
	    final int incl = cpg.addMethodref(NODE_ITERATOR_BASE,
					      ""includeSelf"",
					      ""()"" + NODE_ITERATOR_SIG);
	    il.append(new INVOKEVIRTUAL(incl));
	}

	if (!(getParent() instanceof RelativeLocationPath) &&
	    !(getParent() instanceof FilterParentPath)) {
	    final int order = cpg.addInterfaceMethodref(DOM_INTF,
							ORDER_ITERATOR,
							ORDER_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(order, 3));
	}
    }
}
"
org.apache.xml.serializer.ToHTMLSAXHandler,41,3,0,4,66,742,2,2,40,0.95,337,1.0,0,0.74,0.148217636,3,14,7.195121951,3,1.0,0,"

package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.util.Properties;

import javax.xml.transform.Result;

import org.w3c.dom.Node;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;


public class ToHTMLSAXHandler extends ToSAXHandler
{

    
    protected boolean m_escapeSetting = false;

    
    public Properties getOutputFormat()
    {
        return null;
    }

    
    public OutputStream getOutputStream()
    {
        return null;
    }

    
    public Writer getWriter()
    {
        return null;
    }

    
    public void indent(int n) throws SAXException
    {
    }

    
    public boolean reset()
    {
        return false;
    }

    
    public void serialize(Node node) throws IOException
    {
        return;
    }

    
    public boolean setEscaping(boolean escape) throws SAXException
    {
        boolean oldEscapeSetting = m_escapeSetting;
        m_escapeSetting = escape;

        if (escape) {
            processingInstruction(Result.PI_ENABLE_OUTPUT_ESCAPING, """");
        } else {
            processingInstruction(Result.PI_DISABLE_OUTPUT_ESCAPING, """");
        }

        return oldEscapeSetting;
    }

    
    public void setIndent(boolean indent)
    {
    }

    
    public void setOutputFormat(Properties format)
    {
    }

    
    public void setOutputStream(OutputStream output)
    {
    }


    
    public void setWriter(Writer writer)
    {
    }

    
        
    public void attributeDecl(
        String eName,
        String aName,
        String type,
        String valueDefault,
        String value)
        throws SAXException
    {
    }


        
    public void elementDecl(String name, String model) throws SAXException
    {
        return;
    }

    
    public void externalEntityDecl(String arg0, String arg1, String arg2)
        throws SAXException
    {
    }

    
    public void internalEntityDecl(String name, String value)
        throws SAXException
    {
    }

    
    public void endElement(String uri, String localName, String qName)
        throws SAXException
    {
        flushPending();
        m_saxHandler.endElement(uri, localName, qName);
        
        
        super.fireEndElem(qName);
    }

    
    public void endPrefixMapping(String prefix) throws SAXException
    {
    }

    
    public void ignorableWhitespace(char[] ch, int start, int length)
        throws SAXException
    {
    }
    
    
    public void processingInstruction(String arg0, String arg1)
        throws SAXException
    {
        flushPending();
        m_saxHandler.processingInstruction(arg0,arg1);

		
		super.fireEscapingEvent(arg0,arg1);        
    }

    
    public void setDocumentLocator(Locator arg0)
    {
        
    }

    
    public void skippedEntity(String arg0) throws SAXException
    {
    }

    
    public void startElement(
        String namespaceURI,
        String localName,
        String qName,
        Attributes atts)
        throws SAXException
    {
        flushPending();
        super.startElement(namespaceURI, localName, qName, atts);
        m_saxHandler.startElement(namespaceURI, localName, qName, atts);
        m_startTagOpen = false;
    }

    
    public void comment(char[] ch, int start, int length) throws SAXException
    {
        flushPending();
        m_lexHandler.comment(ch, start, length);

        
        super.fireCommentEvent(ch, start, length);
        return;
    }

    
    public void endCDATA() throws SAXException
    {
        return;
    }

    
    public void endDTD() throws SAXException
    {
    }

    
    public void startCDATA() throws SAXException
    {
    }

    
    public void startEntity(String arg0) throws SAXException
    {
    }

    
    public void endDocument() throws SAXException
    {
        flushPending();

        
        m_saxHandler.endDocument();

        super.fireEndDoc();        
    }

    
    protected void closeStartTag() throws SAXException
    {

        m_startTagOpen = false;

        
        m_saxHandler.startElement(
            EMPTYSTRING,
            m_elementName,
            m_elementName,
            m_attributes);
        m_attributes.clear();       

    }

    
    public void close()
    {
        return;
    }

    
    public void characters(String chars) throws SAXException
    {
        this.characters(chars.toCharArray(), 0, chars.length());
        return;
    }


    
    public ToHTMLSAXHandler(ContentHandler handler, String encoding)
    {
        super(handler,encoding);
    }
    
    public ToHTMLSAXHandler(
        ContentHandler handler,
        LexicalHandler lex,
        String encoding)
    {
        super(handler,lex,encoding);
    }

    
    public void startElement(
        String elementNamespaceURI,
        String elementLocalName,
        String elementName) throws SAXException
    {

        super.startElement(elementNamespaceURI, elementLocalName, elementName);

        flushPending();

        
        if (m_lexHandler != null)
        {
            String doctypeSystem = getDoctypeSystem();
            String doctypePublic = getDoctypePublic();
            if ((doctypeSystem != null) || (doctypePublic != null))
                m_lexHandler.startDTD(
                    elementName,
                    doctypePublic,
                    doctypeSystem);
            m_lexHandler = null;
        }

        m_currentElemDepth++;
        m_elementName = elementName;         
        m_elementLocalName = elementLocalName; 
        m_elementURI = elementNamespaceURI;  

        m_startTagOpen = true;

    }
    
    public void startElement(String elementName) throws SAXException
    {
        this.startElement(null,null, elementName);
    }
    
    
    public void endElement(String elementName) throws SAXException
    {
        flushPending();
        m_saxHandler.endElement(EMPTYSTRING, elementName, elementName);

        
        super.fireEndElem(elementName);        
    }

    
    public void characters(char[] ch, int off, int len) throws SAXException
    {

        flushPending();
        m_saxHandler.characters(ch, off, len);

        
        super.fireCharEvent(ch, off, len);        
    }

    
    public void flushPending()
    {
		if (m_needToCallStartDocument)
		{
			try {startDocumentInternal();
			m_needToCallStartDocument = false;
			} catch (SAXException e) {}
		}       	
        
        if (m_startTagOpen)
        {
            try
            {
                closeStartTag();
            }
            catch(SAXException se)
            {
                
            }
            m_startTagOpen = false;
        }
    }
        
    public boolean startPrefixMapping(
        String prefix,
        String uri,
        boolean shouldFlush)
        throws SAXException
    {
        
        if (shouldFlush) 
            flushPending();   
        m_saxHandler.startPrefixMapping(prefix,uri);
        return false;
    }

    
    public void startPrefixMapping(String prefix, String uri)
        throws org.xml.sax.SAXException
    {
        startPrefixMapping(prefix,uri,true);        
    }

    
    public void namespaceAfterStartElement(
        final String prefix,
        final String uri)
        throws SAXException
    {
        
        if (m_elementURI == null)
        {
            String prefix1 = getPrefixPart(m_elementName);
            if (prefix1 == null && EMPTYSTRING.equals(prefix))
            {
                
                
                
                
                m_elementURI = uri;
            }
        }       
        startPrefixMapping(prefix,uri,false);
    }
}
"
org.apache.xml.utils.AttList,13,1,0,2,27,0,1,1,13,0.694444444,168,0.0,1,0.0,0.4,0,0,11.69230769,6,1.6923,1,"
package org.apache.xml.utils;

import org.w3c.dom.Attr;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import org.xml.sax.Attributes;


public class AttList implements Attributes
{

  
  NamedNodeMap m_attrs;

  
  int m_lastIndex;

  
  

  
  DOMHelper m_dh;















  
  public AttList(NamedNodeMap attrs, DOMHelper dh)
  {

    m_attrs = attrs;
    m_lastIndex = m_attrs.getLength() - 1;
    m_dh = dh;
  }

  
  public int getLength()
  {
    return m_attrs.getLength();
  }

  
  public String getURI(int index)
  {
    String ns = m_dh.getNamespaceOfNode(((Attr) m_attrs.item(index)));
    if(null == ns)
      ns = """";
    return ns;
  }

  
  public String getLocalName(int index)
  {
    return m_dh.getLocalNameOfNode(((Attr) m_attrs.item(index)));
  }

  
  public String getQName(int i)
  {
    return ((Attr) m_attrs.item(i)).getName();
  }

  
  public String getType(int i)
  {
    return ""CDATA"";  
  }

  
  public String getValue(int i)
  {
    return ((Attr) m_attrs.item(i)).getValue();
  }

  
  public String getType(String name)
  {
    return ""CDATA"";  
  }

  
  public String getType(String uri, String localName)
  {
    return ""CDATA"";  
  }

  
  public String getValue(String name)
  {
    Attr attr = ((Attr) m_attrs.getNamedItem(name));
    return (null != attr) 
          ? attr.getValue() : null;
  }

  
  public String getValue(String uri, String localName)
  {
		Node a=m_attrs.getNamedItemNS(uri,localName);
		return (a==null) ? null : a.getNodeValue();
  }

  
  public int getIndex(String uri, String localPart)
  {
    for(int i=m_attrs.getLength()-1;i>=0;--i)
    {
      Node a=m_attrs.item(i);
      String u=a.getNamespaceURI();
      if( (u==null ? uri==null : u.equals(uri))
	  &&
	  a.getLocalName().equals(localPart) )
	return i;
    }
    return -1;
  }

  
  public int getIndex(String qName)
  {
    for(int i=m_attrs.getLength()-1;i>=0;--i)
    {
      Node a=m_attrs.item(i);
      if(a.getNodeName().equals(qName) )
	return i;
    }
    return -1;
  }
}

"
org.apache.xml.serializer.NamespaceMappings,9,1,0,12,32,0,12,0,8,0.6875,276,1.0,0,0.0,0.555555556,0,0,29.0,5,2.1111,1,"
package org.apache.xml.serializer;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Stack;


public class NamespaceMappings
{
    
    private int count = 0;

    
    private java.util.Stack m_prefixStack;

    
    private Hashtable m_namespaces;

    
    private Stack m_nodeStack;

    private static final String EMPTYSTRING = """";
    private static final String XML_PREFIX = ""xml""; 

    
    public NamespaceMappings()
    {
        initNamespaces();
    }

    
    private void initNamespaces()
    {
        
        m_namespaces = new Hashtable();
        m_nodeStack = new Stack();
        m_prefixStack = new Stack();

        
        Stack stack;
        m_namespaces.put(EMPTYSTRING, stack = new Stack());
        stack.push(EMPTYSTRING);
        m_prefixStack.push(EMPTYSTRING);

        m_namespaces.put(XML_PREFIX, stack = new Stack());
        stack.push(""http:
        m_prefixStack.push(XML_PREFIX);

        m_nodeStack.push(new Integer(-1));

    }

    
    public String lookupNamespace(String prefix)
    {
        final Stack stack = (Stack) m_namespaces.get(prefix);
        return stack != null && !stack.isEmpty() ? (String) stack.peek() : null;
    }

    
    public String lookupPrefix(String uri)
    {
        String foundPrefix = null;
        Enumeration prefixes = m_namespaces.keys();
        while (prefixes.hasMoreElements())
        {
            String prefix = (String) prefixes.nextElement();
            String uri2 = lookupNamespace(prefix);
            if (uri2 != null && uri2.equals(uri))
            {
                foundPrefix = prefix;
                break;
            }
        }
        return foundPrefix;
    }

    
    public boolean popNamespace(String prefix)
    {
        
        if (prefix.startsWith(XML_PREFIX))
        {
            return false;
        }

        Stack stack;
        if ((stack = (Stack) m_namespaces.get(prefix)) != null)
        {
            stack.pop();
            return true;
        }
        return false;
    }

    
    public boolean pushNamespace(String prefix, String uri, int elemDepth)
    {
        
        if (prefix.startsWith(XML_PREFIX))
        {
            return false;
        }

        Stack stack;
        
        if ((stack = (Stack) m_namespaces.get(prefix)) == null)
        {
            m_namespaces.put(prefix, stack = new Stack());
        }

        if (!stack.empty() && uri.equals(stack.peek()))
        {
            return false;
        }

        stack.push(uri);
        m_prefixStack.push(prefix);
        m_nodeStack.push(new Integer(elemDepth));
        return true;
    }

    
    public void popNamespaces(int elemDepth)
    {
        while (true)
        {
            if (m_nodeStack.isEmpty())
                return;
            Integer i = (Integer) (m_nodeStack.peek());
            if (i.intValue() < elemDepth)
                return;
            

            m_nodeStack.pop();
            popNamespace((String) m_prefixStack.pop());
        }
    }

    
    public String generateNextPrefix()
    {
        return ""ns"" + (count++);
    }

 
    
    public Object clone() throws CloneNotSupportedException {
        NamespaceMappings clone = new NamespaceMappings();
        clone.m_prefixStack = (Stack)m_prefixStack.clone();
        clone.m_nodeStack = (Stack) m_nodeStack.clone();
        clone.m_namespaces = (Hashtable) m_namespaces.clone();
        
        clone.count = count;
        return clone;
        
    }

}
"
org.apache.xalan.xsltc.compiler.XslElement,10,3,0,23,59,7,1,22,7,0.644444444,505,1.0,2,0.861538462,0.3,1,9,49.0,13,3.9,1,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class XslElement extends Instruction {

    private String  _prefix;
    private boolean _ignore = false;
    private boolean _isLiteralName = true;
    private AttributeValueTemplate _name; 
    private AttributeValueTemplate _namespace;

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Element "" + _name);
	displayContents(indent + IndentIncrement);
    }

    
    public boolean declaresDefaultNS() {
	return false;
    }

    
    private boolean isLiteral(String str) {
	final int length = str.length();
	for (int i = 0; i < length; i++) {
	    if (str.charAt(i) == '{' && str.charAt(i + 1) != '{') {
		return false;
	    }
	}
	return true;
    }

    
    private boolean isLegalName(String str) {
	if (str.indexOf(' ') > -1) {
	    return false;
	}
	final int colon = str.indexOf(':');
	if (colon == 0 || colon == str.length() - 1) {
	    return false;
	}
	final char first = str.charAt(0);
	if (!Character.isLetter(first) && first != '_') {
	    return false;
	}
	return true;
    }

    public void parseContents(Parser parser) {
	final SymbolTable stable = parser.getSymbolTable();

	
	String name = getAttribute(""name"");
	if (name == EMPTYSTRING) {
	    ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_ELEM_NAME_ERR,
					name, this);
	    parser.reportError(WARNING, msg);
	    parseChildren(parser);
	    _ignore = true; 	
	    return;
	}

	
	String namespace = getAttribute(""namespace"");

	
	_isLiteralName = isLiteral(name);
	if (_isLiteralName) {
	    if (!isLegalName(name)) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_ELEM_NAME_ERR,
					    name, this);
		parser.reportError(WARNING, msg);
		parseChildren(parser);
		_ignore = true; 	
		return;
	    }

	    final QName qname = parser.getQNameSafe(name);
	    String prefix = qname.getPrefix();
	    String local = qname.getLocalPart();
	    
	    if (prefix == null) {
		prefix = EMPTYSTRING;
	    }

	    if (!hasAttribute(""namespace"")) {
		namespace = lookupNamespace(prefix); 
		if (namespace == null) {
		    ErrorMsg err = new ErrorMsg(ErrorMsg.NAMESPACE_UNDEF_ERR,
						prefix, this);
		    parser.reportError(WARNING, err);
		    parseChildren(parser);
		    _ignore = true; 	
		    return;
		}
		_prefix = prefix;
		_namespace = new AttributeValueTemplate(namespace, parser, this);
	    }
	    else {
		if (prefix == EMPTYSTRING) {
		    if (isLiteral(namespace)) {
			prefix = lookupPrefix(namespace);
			if (prefix == null) {
			    prefix = stable.generateNamespacePrefix();
			}
		    }

		    
		    final StringBuffer newName = new StringBuffer(prefix);
		    if (prefix != EMPTYSTRING) {
			newName.append(':');
		    }
		    name = newName.append(local).toString();
		}
		_prefix = prefix;
		_namespace = new AttributeValueTemplate(namespace, parser, this);
	    }
	}
	else {
	    _namespace = (namespace == EMPTYSTRING) ? null :
			 new AttributeValueTemplate(namespace, parser, this);
	}

	_name = new AttributeValueTemplate(name, parser, this);

	final String useSets = getAttribute(""use-attribute-sets"");
	if (useSets.length() > 0) {
	    setFirstElement(new UseAttributeSets(useSets, parser));
	}

	parseChildren(parser);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (!_ignore) {
	    _name.typeCheck(stable);
	    if (_namespace != null) {
		_namespace.typeCheck(stable);
	    }
	}
	typeCheckContents(stable);
	return Type.Void;
    }

    
    public void translateLiteral(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (!_ignore) {
	    il.append(methodGen.loadHandler());
	    _name.translate(classGen, methodGen);
	    il.append(DUP2);
	    il.append(methodGen.startElement());

	    if (_namespace != null) {
		il.append(methodGen.loadHandler());
		il.append(new PUSH(cpg, _prefix));
		_namespace.translate(classGen,methodGen);
		il.append(methodGen.namespace());
	    }
	}

	translateContents(classGen, methodGen);

	if (!_ignore) {
	    il.append(methodGen.endElement());
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	LocalVariableGen local = null;
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	if (_isLiteralName) {
	    translateLiteral(classGen, methodGen);
	    return;
	}

	if (!_ignore) {
	    
	    il.append(methodGen.loadHandler());

	    
	    _name.translate(classGen, methodGen);
	    if (_namespace != null) {
		_namespace.translate(classGen, methodGen);
	    }
	    else {
		il.append(ACONST_NULL);
	    }

	    
	    il.append(methodGen.loadHandler());
	    il.append(methodGen.loadDOM());
	    il.append(methodGen.loadCurrentNode());

	    
	    il.append(new INVOKESTATIC(
		cpg.addMethodref(BASIS_LIBRARY_CLASS, ""startXslElement"",
		      ""("" + STRING_SIG 
			  + STRING_SIG 
			  + TRANSLET_OUTPUT_SIG 
			  + DOM_INTF_SIG + ""I)"" + STRING_SIG)));
	}

	translateContents(classGen, methodGen);

	if (!_ignore) {
	    il.append(methodGen.endElement());
	}
    }

    
    public void translateContents(ClassGenerator classGen,
				  MethodGenerator methodGen) {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    final SyntaxTreeNode item =
		(SyntaxTreeNode)getContents().elementAt(i);
	    if (_ignore && item instanceof XslAttribute) continue;
	    item.translate(classGen, methodGen);
	}
    }

}
"
org.apache.xml.dtm.ref.IncrementalSAXSource,5,1,0,6,5,10,6,0,5,2.0,5,0.0,0,0.0,0.333333333,0,0,0.0,1,1.0,0,"

package org.apache.xml.dtm.ref;

import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;


public interface IncrementalSAXSource
{
  
  
  

  
  public void setContentHandler(ContentHandler handler);

  
  public void setLexicalHandler(org.xml.sax.ext.LexicalHandler handler);

  
  public void setDTDHandler(org.xml.sax.DTDHandler handler);

  
  
  

  
  public Object deliverMoreNodes (boolean parsemore);

  
  
  

  
  public void startParse(InputSource source) throws SAXException;
    
} 
"
org.apache.xml.serializer.ToUnknownStream,81,2,0,10,167,0,1,9,75,0.841666667,1040,1.0,1,0.520958084,0.114403292,2,7,11.65432099,10,1.1728,0,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.util.Properties;
import java.util.Vector;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.Transformer;

import org.w3c.dom.Node;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;



public class ToUnknownStream extends SerializerBase
{

    
    private SerializationHandler m_handler;

    
    private static final String EMPTYSTRING = """";

    
    private boolean m_wrapped_handler_not_initialized = false;


    
    private String m_firstElementPrefix;
    
    private String m_firstElementName;

    
    private String m_firstElementURI;
    
    
    private String m_firstElementLocalName = null;

    
    private boolean m_firstTagNotEmitted = true;

    
    private Vector m_namespaceURI = null;
    
    private Vector m_namespacePrefix = null;

    
    private boolean m_needToCallStartDocument = false;
    
    private boolean m_setVersion_called = false;
    
    private boolean m_setDoctypeSystem_called = false;
    
    private boolean m_setDoctypePublic_called = false;
    
    private boolean m_setMediaType_called = false;

    
    public ToUnknownStream()
    {
        m_handler = new ToXMLStream();
    }

    
    public ContentHandler asContentHandler() throws IOException
    {
        
        return this;
    }

    
    public void close()
    {
        m_handler.close();
    }

    
    public Properties getOutputFormat()
    {
        return m_handler.getOutputFormat();
    }

    
    public OutputStream getOutputStream()
    {
        return m_handler.getOutputStream();
    }

    
    public Writer getWriter()
    {
        return m_handler.getWriter();
    }

    
    public boolean reset()
    {
        return m_handler.reset();
    }

    
    public void serialize(Node node) throws IOException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }
        m_handler.serialize(node);
    }

    
    public boolean setEscaping(boolean escape) throws SAXException
    {
        return m_handler.setEscaping(escape);
    }

    
    public void setOutputFormat(Properties format)
    {
        m_handler.setOutputFormat(format);
    }

    
    public void setOutputStream(OutputStream output)
    {
        m_handler.setOutputStream(output);
    }

    
    public void setWriter(Writer writer)
    {
        m_handler.setWriter(writer);
    }

    
    public void addAttribute(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
        throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }
        m_handler.addAttribute(uri, localName, rawName, type, value);
    }
    
    public void addAttribute(String rawName, String value)
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }
        m_handler.addAttribute(rawName, value);
 
    }

    
    public void characters(String chars) throws SAXException
    {
        final char[] arr = chars.toCharArray();
        this.characters(arr, 0, arr.length);
    }    

    
    public void endElement(String elementName) throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }
        m_handler.endElement(elementName);
    }


    
    public void startPrefixMapping(String prefix, String uri) throws SAXException
    {
        this.startPrefixMapping(prefix,uri, true);
    }

        
    public void namespaceAfterStartElement(String prefix, String uri)
        throws SAXException 
    {  
        
        if (m_firstTagNotEmitted && m_firstElementURI == null && m_firstElementName != null)
        {
            String prefix1 = getPrefixPart(m_firstElementName);
            if (prefix1 == null && EMPTYSTRING.equals(prefix))
            {
                
                
                
                
                m_firstElementURI = uri;
            }
        }         
        startPrefixMapping(prefix,uri, false);          
    }
    
    public boolean startPrefixMapping(String prefix, String uri, boolean shouldFlush)
        throws SAXException
    {
        boolean pushed = false;
        if (m_firstTagNotEmitted)
        {
            if (m_firstElementName != null && shouldFlush)
            {
                
                flush();
                pushed = m_handler.startPrefixMapping(prefix, uri, shouldFlush);
            } 
            else 
            {           
                if (m_namespacePrefix == null)
                {
                    m_namespacePrefix = new Vector();
                    m_namespaceURI = new Vector();
                }
                m_namespacePrefix.addElement(prefix);
                m_namespaceURI.addElement(uri);
            
                if (m_firstElementURI == null)
                {
                    if (prefix.equals(m_firstElementPrefix))
                        m_firstElementURI = uri;
                }
            }

        }
        else
        {
           pushed = m_handler.startPrefixMapping(prefix, uri, shouldFlush);
        }
        return pushed;
    }

    

    public void setVersion(String version)
    {
        m_handler.setVersion(version);

        
        
        m_setVersion_called = true;
    }

    
    public void startDocument() throws SAXException
    {
        m_needToCallStartDocument = true;
    }

 
    
    public void startElement(String qName) throws SAXException
    {
        this.startElement(null, null, qName, null);
    }
    
    public void startElement(String namespaceURI, String localName, String qName) throws SAXException
    {
        this.startElement(namespaceURI, localName, qName, null);
    }

    public void startElement(
        String namespaceURI,
        String localName,
        String elementName,
        Attributes atts) throws SAXException
    {
        
        if (m_firstTagNotEmitted)
        {
            
            if (m_firstElementName != null) 
            {
                
                flush();
                m_handler.startElement(namespaceURI, localName, elementName,  atts);                
            }
            else
            {
                
                 
                m_wrapped_handler_not_initialized = true;
                m_firstElementName = elementName;
                
                
                m_firstElementPrefix = getPrefixPartUnknown(elementName);
                
                
                m_firstElementURI = namespaceURI;
                
                
                m_firstElementLocalName = localName;
                
                                
                if (atts != null)   
                    super.addAttributes(atts);
                
                
                
                
                if (atts != null)   
                    flush();
                
            }
        }
        else
        {
            
            
            m_handler.startElement(namespaceURI, localName, elementName,  atts);
        }
    }

    
    public void comment(String comment) throws SAXException
    {
        if (m_firstTagNotEmitted && m_firstElementName != null)
        {
            emitFirstTag();
        }
        else if (m_needToCallStartDocument)
        {
            m_handler.startDocument();
            m_needToCallStartDocument = false;
        }

        m_handler.comment(comment);
    }

    
    public String getDoctypePublic()
    {

        return m_handler.getDoctypePublic();
    }

    
    public String getDoctypeSystem()
    {
        return m_handler.getDoctypeSystem();
    }

    
    public String getEncoding()
    {
        return m_handler.getEncoding();
    }

    
    public boolean getIndent()
    {
        return m_handler.getIndent();
    }

    
    public int getIndentAmount()
    {
        return m_handler.getIndentAmount();
    }

    
    public String getMediaType()
    {
        return m_handler.getMediaType();
    }

    
    public boolean getOmitXMLDeclaration()
    {
        return m_handler.getOmitXMLDeclaration();
    }

    
    public String getStandalone()
    {
        return m_handler.getStandalone();
    }

    
    public String getVersion()
    {
        return m_handler.getVersion();
    }

    
    public void setDoctype(String system, String pub)
    {
        m_handler.setDoctypePublic(pub);
        m_handler.setDoctypeSystem(system);
    }

    
    public void setDoctypePublic(String doctype)
    {
        m_handler.setDoctypePublic(doctype);
        m_setDoctypePublic_called = true;
    }

    
    public void setDoctypeSystem(String doctype)
    {
        m_handler.setDoctypeSystem(doctype);
        m_setDoctypeSystem_called = true;
    }

    
    public void setEncoding(String encoding)
    {
        m_handler.setEncoding(encoding);
    }

    
    public void setIndent(boolean indent)
    {
        m_handler.setIndent(indent);
    }

    
    public void setIndentAmount(int value)
    {
        m_handler.setIndentAmount(value);
    }

    
    public void setMediaType(String mediaType)
    {
        m_handler.setMediaType(mediaType);
        m_setMediaType_called = true;
    }

    
    public void setOmitXMLDeclaration(boolean b)
    {
        m_handler.setOmitXMLDeclaration(b);
    }

    
    public void setStandalone(String standalone)
    {
        m_handler.setStandalone(standalone);
    }

    

    
    public void attributeDecl(
        String arg0,
        String arg1,
        String arg2,
        String arg3,
        String arg4)
        throws SAXException
    {
        m_handler.attributeDecl(arg0, arg1, arg2, arg3, arg4);
    }

    
    public void elementDecl(String arg0, String arg1) throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            emitFirstTag();
        }
        m_handler.elementDecl(arg0, arg1);
    }

    
    public void externalEntityDecl(
        String name,
        String publicId,
        String systemId)
        throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }
        m_handler.externalEntityDecl(name, publicId, systemId);
    }

    
    public void internalEntityDecl(String arg0, String arg1)
        throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }
        m_handler.internalEntityDecl(arg0, arg1);
    }

    
    public void characters(char[] characters, int offset, int length)
        throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }

        m_handler.characters(characters, offset, length);

    }

    
    public void endDocument() throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }

        m_handler.endDocument();
        
    
    }

    
    public void endElement(String namespaceURI, String localName, String qName)
        throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
            if (namespaceURI == null && m_firstElementURI != null)
                namespaceURI = m_firstElementURI;


            if (localName == null && m_firstElementLocalName != null)
                localName = m_firstElementLocalName;
        }
        
        m_handler.endElement(namespaceURI, localName, qName);
    }

    
    public void endPrefixMapping(String prefix) throws SAXException
    {
        m_handler.endPrefixMapping(prefix);
    }

    
    public void ignorableWhitespace(char[] ch, int start, int length)
        throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }
        m_handler.ignorableWhitespace(ch, start, length);
    }

    
    public void processingInstruction(String target, String data)
        throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }

        m_handler.processingInstruction(target, data);
    }

    
    public void setDocumentLocator(Locator locator)
    {
        m_handler.setDocumentLocator(locator);
    }

    
    public void skippedEntity(String name) throws SAXException
    {
        m_handler.skippedEntity(name);
    }



    
    public void comment(char[] ch, int start, int length) throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            flush();
        }

        m_handler.comment(ch, start, length);
    }

    
    public void endCDATA() throws SAXException
    {

        m_handler.endCDATA();
    }

    
    public void endDTD() throws SAXException
    {

        m_handler.endDTD();
    }

    
    public void endEntity(String name) throws SAXException
    {
        if (m_firstTagNotEmitted)
        {
            emitFirstTag();
        }
        m_handler.endEntity(name);
    }

    
    public void startCDATA() throws SAXException
    {
        m_handler.startCDATA();
    }

    
    public void startDTD(String name, String publicId, String systemId)
        throws SAXException
    {
        m_handler.startDTD(name, publicId, systemId);
    }

    
    public void startEntity(String name) throws SAXException
    {
        m_handler.startEntity(name);
    }

    
    private void initStreamOutput() throws SAXException
    {

        
        boolean firstElementIsHTML = isFirstElemHTML();

        if (firstElementIsHTML)
        {
            

            
            SerializationHandler oldHandler = m_handler;

            

            Properties htmlProperties =
                OutputPropertiesFactory.getDefaultMethodProperties(Method.HTML);
            Serializer serializer =
                SerializerFactory.getSerializer(htmlProperties);

            
            
            
            
            m_handler = (SerializationHandler) serializer;
            

            Writer writer = oldHandler.getWriter();

            if (null != writer)
                m_handler.setWriter(writer);
            else
            {
                OutputStream os = oldHandler.getOutputStream();

                if (null != os)
                    m_handler.setOutputStream(os);
            }

            

            
            
            m_handler.setVersion(oldHandler.getVersion());
            
            
            
            m_handler.setDoctypeSystem(oldHandler.getDoctypeSystem());
            
            
            
            m_handler.setDoctypePublic(oldHandler.getDoctypePublic());
            
            
            
            m_handler.setMediaType(oldHandler.getMediaType());
            
            
            m_handler.setTransformer(oldHandler.getTransformer());
        }

        
        
        if (m_needToCallStartDocument)
        {
            m_handler.startDocument();
            m_needToCallStartDocument = false;
        }

        
        m_wrapped_handler_not_initialized = false;
    }

    private void emitFirstTag() throws SAXException
    {   
        if (m_firstElementName != null)
        {
            if (m_wrapped_handler_not_initialized)
            {
                initStreamOutput();
                m_wrapped_handler_not_initialized = false;
            }
            
            m_handler.startElement(m_firstElementURI, null, m_firstElementName, m_attributes);
            
            m_attributes = null;

            
            if (m_namespacePrefix != null)
            {
                final int n = m_namespacePrefix.size();
                for (int i = 0; i < n; i++)
                {
                    final String prefix =
                        (String) m_namespacePrefix.elementAt(i);
                    final String uri = (String) m_namespaceURI.elementAt(i);
                    m_handler.startPrefixMapping(prefix, uri, false);
                }
                m_namespacePrefix = null;
                m_namespaceURI = null;
            }
            m_firstTagNotEmitted = false;
        }
    }

    
    private String getLocalNameUnknown(String value)
    {
        int idx = value.lastIndexOf(':');
        if (idx >= 0)
            value = value.substring(idx + 1);
        idx = value.lastIndexOf('@');
        if (idx >= 0)
            value = value.substring(idx + 1);
        return (value);
    }

    
    private String getPrefixPartUnknown(String qname)
    {
        final int index = qname.indexOf(':');
        return (index > 0) ? qname.substring(0, index) : EMPTYSTRING;
    }

    
    private boolean isFirstElemHTML()
    {
        boolean isHTML;

        
        isHTML =
            getLocalNameUnknown(m_firstElementName).equalsIgnoreCase(""html"");

        
        if (isHTML
            && m_firstElementURI != null
            && !EMPTYSTRING.equals(m_firstElementURI))
        {
            
            isHTML = false;
        }
        
        if (isHTML && m_namespacePrefix != null)
        {
            
            final int max = m_namespacePrefix.size();
            for (int i = 0; i < max; i++)
            {
                final String prefix = (String) m_namespacePrefix.elementAt(i);
                final String uri = (String) m_namespaceURI.elementAt(i);

                if (m_firstElementPrefix != null
                    && m_firstElementPrefix.equals(prefix)
                    && !EMPTYSTRING.equals(uri))
                {
                    
                    isHTML = false;
                    break;
                }
            }

        }
        return isHTML;
    }
    
    public DOMSerializer asDOMSerializer() throws IOException
    {
        return m_handler.asDOMSerializer();
    }

    
    public void setCdataSectionElements(Vector URI_and_localNames)
    {
        m_handler.setCdataSectionElements(URI_and_localNames);
    }
    
    public void addAttributes(Attributes atts) throws SAXException
    {
        m_handler.addAttributes(atts);
    }

    
    public NamespaceMappings getNamespaceMappings()
    {
        NamespaceMappings mappings = null;
        if (m_handler != null)
        {
            mappings = m_handler.getNamespaceMappings();
        }
        return mappings;
    }
    
    public void flushPending()
    {
 
        flush();
      
        m_handler.flushPending();
    }
    
    private void flush()
    {
        try
        {
        if (m_firstTagNotEmitted)
        {
            emitFirstTag();
        }
        if (m_needToCallStartDocument)
        {
            m_handler.startDocument();
            m_needToCallStartDocument = false;
        }
        }
        catch(SAXException e)
        {
            throw new RuntimeException(e.toString());
        }
          
    
    }

    
    public String getPrefix(String namespaceURI)
    {
        return m_handler.getPrefix(namespaceURI);
    }
    
    public void entityReference(String entityName) throws SAXException
    {
        m_handler.entityReference(entityName);
    }

    
    public String getNamespaceURI(String qname, boolean isElement)
    {
        return m_handler.getNamespaceURI(qname, isElement);
    }

    public String getNamespaceURIFromPrefix(String prefix)
    {
        return m_handler.getNamespaceURIFromPrefix(prefix);
    }

    public void setTransformer(Transformer t)
    {
        m_handler.setTransformer(t);
    }
    public Transformer getTransformer()
    {
        return m_handler.getTransformer();
    }

    
    public void setContentHandler(ContentHandler ch)
    {
        m_handler.setContentHandler(ch);
    }
        
    public void setSourceLocator(SourceLocator locator)
    {
        m_handler.setSourceLocator(locator);
    }


}
"
org.apache.xml.utils.res.XResources_it,3,4,0,1,4,1,0,1,2,0.5,314,0.0,0,0.976190476,1.0,0,0,103.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_it extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""it"" }, { ""help_language"", ""it"" }, { ""language"", ""it"" },
    { ""alphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    
    
    
    
    
    
    
    
    
  };
}
"
org.apache.xml.utils.res.XResources_ko,3,4,0,1,4,1,0,1,2,0.5,487,0.0,0,0.976190476,1.0,0,0,161.0,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_ko extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ko"" }, { ""help_language"", ""ko"" }, { ""language"", ""ko"" },
    { ""alphabet"",
      new char[]{ 0x3131, 0x3134, 0x3137, 0x3139, 0x3141, 0x3142, 0x3145, 0x3147, 0x3148, 0x314a, 0x314b, 0x314c,
                  0x314d, 0x314e, 0x314f, 0x3151, 0x3153, 0x3155, 0x3157, 0x315b, 0x315c, 0x3160, 0x3161, 0x3163}},
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    { ""zero"", new char[0] },

    
    { ""multiplier"", new int[]{ 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{  0xc5b5, 0xb9cc, 0xcc9c, 0xbc31, 0xc2ed } },
    { ""digits"",
      new char[]{ 0xc77c, 0xc774, 0xc0bc, 0xc0ac, 0xc624, 0xc721, 0xce60, 0xd314, 0xad6c
                   } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xpath.CachedXPathAPI,12,1,0,5,23,54,0,5,12,0.454545455,139,1.0,1,0.0,0.533333333,0,0,10.5,1,0.8333,0,"
package org.apache.xpath;

import javax.xml.transform.TransformerException;

import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.PrefixResolverDefault;
import org.apache.xpath.objects.XObject;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;


public class CachedXPathAPI
{
  
  protected XPathContext xpathSupport;

  
  public CachedXPathAPI()
  {
    xpathSupport = new XPathContext();
  }
  
  
  public CachedXPathAPI(CachedXPathAPI priorXPathAPI)
  {
    xpathSupport = priorXPathAPI.xpathSupport;
  }


  
  public XPathContext getXPathContext()
  {
    return this.xpathSupport;
  }
  

  
  public  Node selectSingleNode(Node contextNode, String str)
          throws TransformerException
  {
    return selectSingleNode(contextNode, str, contextNode);
  }

  
  public  Node selectSingleNode(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    NodeIterator nl = selectNodeIterator(contextNode, str, namespaceNode);

    
    return nl.nextNode();
  }

  
  public  NodeIterator selectNodeIterator(Node contextNode, String str)
          throws TransformerException
  {
    return selectNodeIterator(contextNode, str, contextNode);
  }

  
  public  NodeIterator selectNodeIterator(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    XObject list = eval(contextNode, str, namespaceNode);

    
    return list.nodeset();
  }

  
  public  NodeList selectNodeList(Node contextNode, String str)
          throws TransformerException
  {
    return selectNodeList(contextNode, str, contextNode);
  }

  
  public  NodeList selectNodeList(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    XObject list = eval(contextNode, str, namespaceNode);

    
    return list.nodelist();
  }

  
  public  XObject eval(Node contextNode, String str)
          throws TransformerException
  {
    return eval(contextNode, str, contextNode);
  }

  
  public  XObject eval(Node contextNode, String str, Node namespaceNode)
          throws TransformerException
  {

    
    
    
    
    

    
    
    
    
    PrefixResolverDefault prefixResolver = new PrefixResolverDefault(
      (namespaceNode.getNodeType() == Node.DOCUMENT_NODE)
      ? ((Document) namespaceNode).getDocumentElement() : namespaceNode);

    
    XPath xpath = new XPath(str, null, prefixResolver, XPath.SELECT, null);

    
    
    int ctxtNode = xpathSupport.getDTMHandleFromNode(contextNode);

    return xpath.execute(xpathSupport, ctxtNode, prefixResolver);
  }

  
  public  XObject eval(
          Node contextNode, String str, PrefixResolver prefixResolver)
            throws TransformerException
  {

    
    
    
    
    
    
    XPath xpath = new XPath(str, null, prefixResolver, XPath.SELECT, null);

    
    XPathContext xpathSupport = new XPathContext();
    int ctxtNode = xpathSupport.getDTMHandleFromNode(contextNode);

    return xpath.execute(xpathSupport, ctxtNode, prefixResolver);
  }
}
"
org.apache.xalan.xsltc.compiler.ForEach,6,3,0,28,58,3,1,28,5,0.6,332,1.0,2,0.918032787,0.361111111,1,7,54.0,9,2.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;
import java.util.Vector;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFGT;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.ResultTreeType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class ForEach extends Instruction {

    private Expression _select;
    private Type       _type;

    public void display(int indent) {
	indent(indent);
	Util.println(""ForEach"");
	indent(indent + IndentIncrement);
	Util.println(""select "" + _select.toString());
	displayContents(indent + IndentIncrement);
    }
		
    public void parseContents(Parser parser) {
	_select = parser.parseExpression(this, ""select"", null);

	parseChildren(parser);

        
        if (_select.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""select"");
        }
	else {
	    
	    final Expression fpe = new ForwardPositionExpr(_select);
	    _select.setParent(fpe);
	    fpe.setParser(_select.getParser());
	    _select = fpe;
	}
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_type = _select.typeCheck(stable);

	if (_type instanceof ReferenceType || _type instanceof NodeType) {
	    _select = new CastExpr(_select, Type.NodeSet);
	    typeCheckContents(stable);
	    return Type.Void;
	}
	if (_type instanceof NodeSetType||_type instanceof ResultTreeType) {
	    typeCheckContents(stable);
	    return Type.Void;
	}
	throw new TypeCheckError(this);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadIterator());
		
	
	final Vector sortObjects = new Vector();
	Enumeration children = elements();
	while (children.hasMoreElements()) {
	    final Object child = children.nextElement();
	    if (child instanceof Sort) {
		sortObjects.addElement(child);
	    }
	}

	if ((_type != null) && (_type instanceof ResultTreeType)) {
	    
	    il.append(methodGen.loadDOM());

	    
	    if (sortObjects.size() > 0) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.RESULT_TREE_SORT_ERR,this);
		getParser().reportError(WARNING, msg);
	    }

	    
	    _select.translate(classGen, methodGen);
	    
	    _type.translateTo(classGen, methodGen, Type.NodeSet);
	    
	    il.append(SWAP);
	    il.append(methodGen.storeDOM());
	}
	else {
	    
	    if (sortObjects.size() > 0) {
		Sort.translateSortIterator(classGen, methodGen,
					   _select, sortObjects);
	    }
	    else {
		_select.translate(classGen, methodGen);
	    }

	    if (_type instanceof ReferenceType == false) {
		_select.startResetIterator(classGen, methodGen);
	    }
	}


	
	il.append(methodGen.storeIterator());

	
	initializeVariables(classGen, methodGen);

	final BranchHandle nextNode = il.append(new GOTO(null));
	final InstructionHandle loop = il.append(NOP);

	translateContents(classGen, methodGen);
		    
	nextNode.setTarget(il.append(methodGen.loadIterator()));
	il.append(methodGen.nextNode());
	il.append(DUP);
	il.append(methodGen.storeCurrentNode());
	il.append(new IFGT(loop));

	
	if ((_type != null) && (_type instanceof ResultTreeType)) {
	    il.append(methodGen.storeDOM());	    
	}

	
	il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
    }

    
    public void initializeVariables(ClassGenerator classGen,
				   MethodGenerator methodGen) {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    final Object child = getContents().elementAt(i);
	    if (child instanceof Variable) {
		Variable var = (Variable)child;
		var.initialize(classGen, methodGen);
	    }
	}
    }

}
"
org.apache.xml.utils.StringVector,11,1,0,8,15,0,8,0,11,0.425,234,1.0,0,0.0,0.515151515,0,0,19.90909091,4,1.7273,1,"
package org.apache.xml.utils;


public class StringVector implements java.io.Serializable
{

  
  protected int m_blocksize;

  
  protected String m_map[];

  
  protected int m_firstFree = 0;

  
  protected int m_mapSize;

  
  public StringVector()
  {

    m_blocksize = 8;
    m_mapSize = m_blocksize;
    m_map = new String[m_blocksize];
  }

  
  public StringVector(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new String[blocksize];
  }

  
  public int getLength()
  {
    return m_firstFree;
  }

  
  public final int size()
  {
    return m_firstFree;
  }

  
  public final void addElement(String value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      String newMap[] = new String[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final String elementAt(int i)
  {
    return m_map[i];
  }

  
  public final boolean contains(String s)
  {

    if (null == s)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equals(s))
        return true;
    }

    return false;
  }

  
  public final boolean containsIgnoreCase(String s)
  {

    if (null == s)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equalsIgnoreCase(s))
        return true;
    }

    return false;
  }

  
  public final void push(String s)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      String newMap[] = new String[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = s;

    m_firstFree++;
  }

  
  public final String pop()
  {

    if (m_firstFree <= 0)
      return null;

    m_firstFree--;

    String s = m_map[m_firstFree];

    m_map[m_firstFree] = null;

    return s;
  }

  
  public final String peek()
  {
    return (m_firstFree <= 0) ? null : m_map[m_firstFree - 1];
  }
}
"
org.apache.xalan.xsltc.dom.DupFilterIterator,8,2,0,6,25,0,1,5,8,0.485714286,183,1.0,2,0.65,0.34375,1,5,21.25,6,1.625,1,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xalan.xsltc.util.IntegerArray;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;
import org.apache.xml.dtm.ref.DTMDefaultBase;


public final class DupFilterIterator extends DTMAxisIteratorBase {

    
    private DTMAxisIterator _source;

    
    private IntegerArray _nodes = new IntegerArray();

    
    private int _current = 0;

    
    private int _nodesSize = 0; 

    
    private int _lastNext = END;

    public DupFilterIterator(DTMAxisIterator source) {
	_source = source;


	
	
	
	if (source instanceof KeyIndex) {
	    setStartNode(DTMDefaultBase.ROOTNODE);
	}
    }
    
    public DTMAxisIterator setStartNode(int node) {
	if (_isRestartable) {
	    
	    
	    if (_source instanceof KeyIndex
                    && _startNode == DTMDefaultBase.ROOTNODE) {
		return this;
	    }

	    if (node != _startNode) {
		_source.setStartNode(_startNode = node);

		_nodes.clear();
		while ((node = _source.next()) != END) {
		    _nodes.add(node);
		}
		_nodes.sort();
		_nodesSize = _nodes.cardinality();
		_current = 0;
		_lastNext = END;
		resetPosition();
	    }
	}
	return this;
    }


    public int next() {
	while (_current < _nodesSize) {
	    final int next = _nodes.at(_current++);
	    if (next != _lastNext) {
		return returnNode(_lastNext = next);
	    }
	}
	return END;
    }

    public DTMAxisIterator cloneIterator() {
	try {
	    final DupFilterIterator clone =
		(DupFilterIterator) super.clone();
	    clone._nodes = (IntegerArray) _nodes.clone();
	    clone._source = _source.cloneIterator();
	    clone._isRestartable = false;
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }

    public void setMark() {
	_markedNode = _current;
    }

    public void gotoMark() {
	_current = _markedNode;
    }

    public DTMAxisIterator reset() {
	_current = 0;
	_lastNext = END;
	return resetPosition();
    }
}
"
org.apache.xalan.res.XSLTErrorResources_sv,3,4,0,1,4,1,0,1,2,1.423076923,3769,0.0,0,0.976190476,1.0,0,0,1251.0,1,0.3333,0,"
package org.apache.xalan.res;



public class XSLTErrorResources_sv extends XSLTErrorResources
{

  
  public static final int MAX_CODE = 201;          

  
  public static final int MAX_WARNING = 29;

  
  public static final int MAX_OTHERS = 55;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  
  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_NO_CURLYBRACE,
      ""Fel: Kan inte ha '{' inuti uttryck""},


  
  


  {
    ER_ILLEGAL_ATTRIBUTE, ""{0} har ett otillåtet attribut: {1}""},


  
  


  {
    ER_NULL_SOURCENODE_APPLYIMPORTS,
      ""sourceNode är null i xsl:apply-imports!""},


  
  


  {
    ER_CANNOT_ADD, ""Kan inte lägga {0} till {1}""},


  
  


  {
    ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES,
      ""sourceNode är null i handleApplyTemplatesInstruction!""},


  
  


  {
    ER_NO_NAME_ATTRIB, ""{0} måste ha ett namn-attribut.""},


  
  


  {
    ER_TEMPLATE_NOT_FOUND, ""Hittade inte mallen med namn: {0}""},


  
  


  {
    ER_CANT_RESOLVE_NAME_AVT,
      ""Kunde inte lösa namn-AVT i xsl:call-template.""},


  
  


  {
    ER_REQUIRES_ATTRIB, ""{0} kräver attribut: {1}""},


  
  


  {
    ER_MUST_HAVE_TEST_ATTRIB,
      ""{0} måste ha ett ''test''-attribut.""},


  
  


  {
    ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""Dåligt värde på nivå-attribut: {0}""},


  
  


  {
    ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""Namn på behandlande instruktion får inte vara 'xml'""},


  
  


  {
    ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""Namn på behandlande instruktion måste vara ett giltigt NCNamn: {0}""},


  
  


  {
    ER_NEED_MATCH_ATTRIB,
      ""{0} måste ha ett matchningsattribut om det har ett tillstånd.""},


  
  


  {
    ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0} kräver antingen ett namn eller ett matchningsattribut.""},


  
  


  {
    ER_CANT_RESOLVE_NSPREFIX,
      ""Kan inte lösa namnrymdsprefix: {0}""},


  
  


  {
    ER_ILLEGAL_VALUE, ""xml:space har ett otillåtet värde: {0}""},


  
  


  {
    ER_NO_OWNERDOC,
      ""Barnnod saknar ägardokument!""},


  
  


  {
    ER_ELEMTEMPLATEELEM_ERR, ""ElemTemplateElement-fel: {0}""},


  
  


  {
    ER_NULL_CHILD, ""Försöker lägga till ett null-barn!""},


  
  


  {
    ER_NEED_SELECT_ATTRIB, ""{0} kräver ett valattribut.""},


  
  


  {
    ER_NEED_TEST_ATTRIB,
      ""xsl:when måste ha ett 'test'-attribut.""},


  
  


  {
    ER_NEED_NAME_ATTRIB,
      ""xsl:with-param måste ha ett 'namn'-attribut.""},


  
  


  {
    ER_NO_CONTEXT_OWNERDOC,
      ""Kontext saknar ägardokument!""},


  
  


  {
    ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""Kunde inte skapa XML TransformerFactory Liaison: {0}""},


  
  


  {
    ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: Process misslyckades.""},


  
  


  {
    ER_NOT_SUCCESSFUL, ""Xalan: misslyckades.""},


  
  


  {
    ER_ENCODING_NOT_SUPPORTED, ""Kodning inte understödd: {0}""},


  
  


  {
    ER_COULD_NOT_CREATE_TRACELISTENER,
      ""Kunde inte skapa TraceListener: {0}""},


  
  


  {
    ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key måste ha ett 'namn'-attribut.""},


  
  


  {
    ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key måste ha ett 'matcha'-attribut.""},


  
  


  {
    ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key måste ha ett 'använd'-attribut.""},


  
  


  {
    ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0} kräver ett ''element''-attribut!""},


  
  


  {
    ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} ''prefix''-attribut saknas""},


  
  


  {
    ER_BAD_STYLESHEET_URL, ""Stylesheet URL är dålig: {0}""},


  
  


  {
    ER_FILE_NOT_FOUND, ""Stylesheet-fil saknas: {0}""},


  
  


  {
    ER_IOEXCEPTION,
      ""Fick IO-Undantag med stylesheet-fil: {0}""},


  
  


  {
    ER_NO_HREF_ATTRIB,
      ""(StylesheetHandler) Hittade inte href-attribute för {0}""},


  
  


  {
    ER_STYLESHEET_INCLUDES_ITSELF,
      ""(StylesheetHandler) {0} inkluderar, direkt eller indirekt, sig själv!""},


  
  


  {
    ER_PROCESSINCLUDE_ERROR,
      ""StylesheetHandler.processInclude-fel, {0}""},


  
  


  {
    ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} ''lang''-attribut' saknas""},


  
  


  {
    ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) felplacerade {0} element?? Saknar behållarelement  ''komponent''""},


  
  


  {
    ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
      ""Kan endast skicka utdata till ett Element, ett DocumentFragment, ett Document, eller en PrintWriter.""},


  
  


  {
    ER_PROCESS_ERROR, ""StylesheetRoot.process-fel""},


  
  


  {
    ER_UNIMPLNODE_ERROR, ""UnImplNode-fel: {0}""},


  
  


  {
    ER_NO_SELECT_EXPRESSION,
      ""Fel! Hittade inte xpath select-uttryck (-select).""},


  
  


  {
    ER_CANNOT_SERIALIZE_XSLPROCESSOR,
      ""Kan inte serialisera en XSLProcessor!""},


  
  


  {
    ER_NO_INPUT_STYLESHEET,
      ""Stylesheet-indata ej angiven!""},


  
  


  {
    ER_FAILED_PROCESS_STYLESHEET,
      ""Kunde inte behandla stylesheet!""},


  
  


  {
    ER_COULDNT_PARSE_DOC, ""Kunde inte tolka {0} dokument!""},


  
  


  {
    ER_COULDNT_FIND_FRAGMENT, ""Hittade inte fragment: {0}""},


  
  


  {
    ER_NODE_NOT_ELEMENT,
      ""Nod som pekades på av fragment-identifierare var inte ett element: {0}""},


  
  


  {
    ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""for-each kräver antingen en matchning eller ett namnattribut.""},


  
  


  {
    ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB,
      ""mallar kräver antingen en matchning eller ett namnattribut.""},


  
  


  {
    ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""Ingen klon av ett dokumentfragment!""},


  
  


  {
    ER_CANT_CREATE_ITEM,
      ""Kan inte skapa element i resultatträd: {0}""},


  
  


  {
    ER_XMLSPACE_ILLEGAL_VALUE,
      ""xml:space i käll-XML har ett otillåtet värde: {0}""},


  
  


  {
    ER_NO_XSLKEY_DECLARATION,
      ""Det finns ingen xsl:key-deklaration för {0}!""},


  
  


  {
    ER_CANT_CREATE_URL, ""Fel! Kan inte skapa url för: {0}""},


  
  


  {
    ER_XSLFUNCTIONS_UNSUPPORTED, ""xsl:functions är inte understödd""},


  
  


  {
    ER_PROCESSOR_ERROR, ""XSLT TransformerFactory-Fel""},


  
  


  {
    ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""(StylesheetHandler) {0} är inte tillåten inne i ett stylesheet!""},


  
  


  {
    ER_RESULTNS_NOT_SUPPORTED,
      ""result-ns inte längre understödd!  Använd xsl:output istället.""},


  
  


  {
    ER_DEFAULTSPACE_NOT_SUPPORTED,
      ""default-space inte längre understödd!  Använd xsl:strip-space eller xsl:preserve-space istället.""},


  
  


  {
    ER_INDENTRESULT_NOT_SUPPORTED,
      ""indent-result inte längre understödd!  Använd xsl:output istället.""},


  
  


  {
    ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0} har ett otillåtet attribut: {1}""},


  
  


  {
    ER_UNKNOWN_XSL_ELEM, ""Okänt XSL-element: {0}""},


  
  


  {
    ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort kan endast användas med xsl:apply-templates eller xsl:for-each.""},


  
  


  {
    ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) felplacerade xsl:when!""},


  
  


  {
    ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:when härstammar inte från xsl:choose!""},


  
  


  {
    ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) felplacerade xsl:otherwise!""},


  
  


  {
    ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:otherwise härstammar inte från xsl:choose!""},


  
  


  {
    ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""(StylesheetHandler) {0} är inte tillåten inne i en mall!""},


  
  


  {
    ER_UNKNOWN_EXT_NS_PREFIX,
      ""(StylesheetHandler) {0} utbyggnadsnamnrymdsprefix {1} okänt""},


  
  


  {
    ER_IMPORTS_AS_FIRST_ELEM,
      ""(StylesheetHandler) Imports kan endast förekomma som de första elementen i ett stylesheet!""},


  
  


  {
    ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0} importerar, direkt eller indirekt, sig själv!""},


  
  


  {
    ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space har ett otillåtet värde: {0}""},


  
  


  {
    ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""processStylesheet misslyckades!""},


  
  


  {
    ER_SAX_EXCEPTION, ""SAX-Undantag""},



  
  


  {
    ER_XSLT_ERROR, ""XSLT-fel""},


  
  


  {
    ER_CURRENCY_SIGN_ILLEGAL,
      ""valutatecken är inte tillåtet i formatmönstersträng""},


  
  


  {
    ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""Dokumentfunktion inte understödd i Stylesheet DOM!""},


  
  


  {
    ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""Kan inte lösa prefix i icke-Prefixlösare!""},


  
  


  {
    ER_REDIRECT_COULDNT_GET_FILENAME,
      ""Redirect extension: Hittade inte filnamn - fil eller valattribut måste returnera vald  sträng.""},


  
  


  {
    ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""Kan inte bygga FormatterListener i Redirect extension!""},


  
  


  {
    ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""Prefix i exkludera-resultat-prefix är inte giltig: {0}""},


  
  


  {
    ER_MISSING_NS_URI,
      ""Namnrymds-URI saknas för angivna prefix""},


  
  


  {
    ER_MISSING_ARG_FOR_OPTION,
      ""Argument saknas för alternativ: {0}""},


  
  


  {
    ER_INVALID_OPTION, ""Ogiltigt alternativ: {0}""},


  
  


  {
    ER_MALFORMED_FORMAT_STRING, ""Fel format på formatsträng: {0}""},


  
  


  {
    ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet måste ha ett 'version'-attribut!""},


  
  


  {
    ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""Attribut: {0} har ett otillåtet värde: {1}""},


  
  


  {
    ER_CHOOSE_REQUIRES_WHEN, ""xsl:choose kräver ett xsl:when""},


  
  


  {
    ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""xsl:apply-imports inte tillåtet i ett xsl:for-each""},


  
  


  {
    ER_CANT_USE_DTM_FOR_OUTPUT,
      ""Kan inte använda DTMLiaison till en DOM utdatanod... skicka en org.apache.xpath.DOM2Helper istället!""},


  
  


  {
    ER_CANT_USE_DTM_FOR_INPUT,
      ""Kan inte använda DTMLiaison till en DOM indatanod... skicka en org.apache.xpath.DOM2Helper istället!""},


  
  


  {
    ER_CALL_TO_EXT_FAILED,
      ""Anrop till anslutningselement misslyckades: {0}""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""Prefix måste lösa till en mamnrymd: {0}""},


  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""Ogiltigt UTF-16-surrogat upptäckt: {0} ?""},


  
  


  {
    ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0} använde sig självt, vilket kommer att orsaka en  oändlig loop.""},


  
  


  {
    ER_CANNOT_MIX_XERCESDOM,
      ""Kan inte blanda icke-Xerces-DOM-indata med Xerces-DOM-utdata!""},


  
  


  {
    ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},


  
  


  {
    ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""I ElemTemplateElement.readObject: {0}""},


  
  


  {
    ER_DUPLICATE_NAMED_TEMPLATE,
      ""Hittade mer än en mall med namnet: {0}""},


  
  


  {
    ER_INVALID_KEY_CALL,
      ""Ogiltigt funktionsanrop: rekursiva key()-anrop är inte tillåtna""},

  
  
  


  {
    ER_REFERENCING_ITSELF,
      ""Variabel {0} hänvisar, direkt eller indirekt, till sig själv!""},

  
  
  


  {
    ER_ILLEGAL_DOMSOURCE_INPUT,
      ""Indatanoden till en DOMSource för newTemplates får inte vara null!""},

	
	
  


  {
    ER_CLASS_NOT_FOUND_FOR_OPTION,
			""Klassfil för alternativ {0} saknas""},

	
	
  


  {
    ER_REQUIRED_ELEM_NOT_FOUND,
			""Nödvändigt element saknas: {0}""},

  
  
  


  {
    ER_INPUT_CANNOT_BE_NULL,
			""InputStream får inte vara null""},

  
  
  


  {
    ER_URI_CANNOT_BE_NULL,
			""URI får inte vara null""},

  
  
  


  {
    ER_FILE_CANNOT_BE_NULL,
			""Fil får inte vara null""},

  
   
  


  {
    ER_SOURCE_CANNOT_BE_NULL,
			""InputSource får inte vara null""},

  
  
  


  {
    ER_CANNOT_INIT_BSFMGR,
			""Kan inte initialisera BSF Manager""},

  
  
  


  {
    ER_CANNOT_CMPL_EXTENSN,
			""Kunde inte kompilera anslutning""},

  
  
  


  {
    ER_CANNOT_CREATE_EXTENSN,
      ""Kunde inte skapa anslutning: {0} på grund av: {1}""},

  
  
  


  {
    ER_INSTANCE_MTHD_CALL_REQUIRES,
      ""Instansmetodanrop till metod {0} kräver en Objektinstans som första argument""},

  
  
  


  {
    ER_INVALID_ELEMENT_NAME,
      ""Ogiltigt elementnamn angivet {0}""},

  
   
  


  {
    ER_ELEMENT_NAME_METHOD_STATIC,
      ""Elementnamnmetod måste vara static {0}""},

  
   
  


  {
    ER_EXTENSION_FUNC_UNKNOWN,
             ""Anslutningsfunktion {0} : {1} är okänd""},

  
   
  


  {
    ER_MORE_MATCH_CONSTRUCTOR,
             ""Fler än en bästa matchning för konstruktor för {0}""},

  
   
  


  {
    ER_MORE_MATCH_METHOD,
             ""Fler än en bästa matchning för metod {0}""},

  
   
  


  {
    ER_MORE_MATCH_ELEMENT,
             ""Fler än en bästa matchning för elementmetod {0}""},

  
   
  


  {
    ER_INVALID_CONTEXT_PASSED,
             ""Ogiltig kontext skickad för att utvärdera {0}""},

  
   
  


  {
    ER_POOL_EXISTS,
             ""Pool finns redan""},

  
   
  


  {
    ER_NO_DRIVER_NAME,
             ""Inget driver-namn angivet""},

  
   
  


  {
    ER_NO_URL,
             ""Ingen URL angiven""},

  
   
  


  {
    ER_POOL_SIZE_LESSTHAN_ONE,
             ""Poolstorlek är mindre än ett!""},

  
   
  


  {
    ER_INVALID_DRIVER,
             ""Ogiltigt driver-namn angivet""},

  
   
  


  {
    ER_NO_STYLESHEETROOT,
             ""Hittade inte stylesheet-roten!""},

  
   
  


  {
    ER_ILLEGAL_XMLSPACE_VALUE,
         ""Ogiltigt värde för xml:space""},

  
   
  


  {
    ER_PROCESSFROMNODE_FAILED,
         ""processFromNode misslyckades""},

  
   
  


  {
    ER_RESOURCE_COULD_NOT_LOAD,
        ""Resursen [ {0} ] kunde inte laddas: {1} 
 {2} 	 {3}""},

   
  
   
  


  {
    ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""Bufferstorlek <=0""},

  
   
  


  {
    ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""Okänt fel vid anslutningsanrop""},

  
   
  


  {
    ER_NO_NAMESPACE_DECL,
        ""Prefix{0} har inte en motsvarande namnrymdsdeklaration""},

  
   
  


  {
    ER_ELEM_CONTENT_NOT_ALLOWED,
        ""Elementinnehåll är inte tillåtet för lang=javaclass {0}""},

  
   
  


  {
    ER_STYLESHEET_DIRECTED_TERMINATION,
        ""Stylesheet-ledd avslutning""},

  
   
  


  {
    ER_ONE_OR_TWO,
        ""1 eller 2""},

  
   
  


  {
    ER_TWO_OR_THREE,
        ""2 eller 3""},

  
   
  


  {
    ER_COULD_NOT_LOAD_RESOURCE,
        ""Kunde inte ladda {0} (kontrollera CLASSPATH), använder nu enbart standard""},

  
   
  


  {
    ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""Kan inte initialisera standardmallar""},

  
   
  


  {
    ER_RESULT_NULL,
        ""Result borde inte vara null""},

    
   
  


  {
    ER_RESULT_COULD_NOT_BE_SET,
        ""Result kunde inte sättas""},

  
   
  


  {
    ER_NO_OUTPUT_SPECIFIED,
        ""Ingen utdata angiven""},

  
   
  


  {
    ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""Kan inte omvandla till en Result av typ {0}""},

  
   
  


  {
    ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""Kan inte omvandla en Source av typ {0}""},

  
   
  


  {
    ER_NULL_CONTENT_HANDLER,
        ""Innehållshanterare med värde null""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""Felhanterare med värde null""},

  
   
  


  {
    ER_CANNOT_CALL_PARSE,
        ""parse kan inte anropas om ContentHandler inte har satts""},

  
   
  


  {
    ER_NO_PARENT_FOR_FILTER,
        ""Ingen förälder till filter""},

  
  
   
  


  {
    ER_NO_STYLESHEET_IN_MEDIA,
         ""Stylesheet saknas i: {0}, media= {1}""},

  
   
  


  {
    ER_NO_STYLESHEET_PI,
         ""xml-stylesheet PI saknas i: {0}""},

  
   
  


  {
    ER_NOT_SUPPORTED,
       ""Understöds inte: {0}""},

  
   
  


  {
    ER_PROPERTY_VALUE_BOOLEAN,
       ""Värde på egenskap {0} borde vara en Boolesk instans""},

  
   

   
  


  {
    ""ER_SRC_ATTRIB_NOT_SUPPORTED"",
       ""src-attributet understöds ännu inte för {0}""},

  
  
  


  {
    ER_RESOURCE_COULD_NOT_FIND,
        ""Resursen [ {0} ] saknas. 
 {1}""},

  
   
  


  {
    ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""Utdata-egenskap känns inte igen: {0}""},

  
   
  


  {
    ER_FAILED_CREATING_ELEMLITRSLT,
        ""Kunde inte skapa instans av ElemLiteralResult""},
    
  
   
   
   
   

   
  


  {
     ER_VALUE_SHOULD_BE_NUMBER,
         ""Värdet för {0} bör innehålla en siffra som inte kan tolkas""},

  
   
  


  {
    ER_VALUE_SHOULD_EQUAL,
        ""Värde på {0} borde motsvara ja eller nej""},

 
   
  


  {
    ER_FAILED_CALLING_METHOD,
        "" Kunde inte anropa metoden {0}""},

  
   
  


  {
    ER_FAILED_CREATING_ELEMTMPL,
        ""Kunde inte skapa instans av ElemTemplateElement""},

  
   
  


  {
    ER_CHARS_NOT_ALLOWED,
        ""Tecken är inte tillåtna i dokumentet vid den här tidpunkten""},

  
  
  


  {
    ER_ATTR_NOT_ALLOWED,
        ""Attributet ""{0}"" är inte tillåten i det {1} elementet!""},

 
  
  


  {
    ER_BAD_VALUE,
     ""{0} dåligt värde {1} ""},

  
  
  


  {
    ER_ATTRIB_VALUE_NOT_FOUND,
     ""Attributet {0} saknas ""},

  
  
  


  {
    ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""Attributvärdet {0} känns inte igen ""},

  
  
  


  {
    ER_NULL_URI_NAMESPACE,
     ""Försöker generera ett namnområdesprefix med en null-URI""},


  

  
  


  {
    ER_NUMBER_TOO_BIG,
     ""Försöker formatera en siffra som är större än det största långa heltalet""},




  


  {
    ER_CANNOT_FIND_SAX1_DRIVER,
     ""Det går inte att hitta SAX1-drivrutinen klass {0}""},



  


  {
    ER_SAX1_DRIVER_NOT_LOADED,
     ""SAX1-drivrutinen klass {0} hittades men kan inte laddas""},



  


  {
    ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""SAX1-drivrutinen klass {0} hittades men kan inte instansieras""},




  


  {
    ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
     ""SAX1-drivrutinen klass {0} implementerar inte org.xml.sax.Parser""},



  


  {
    ER_PARSER_PROPERTY_NOT_SPECIFIED,
     ""Systemegenskapen org.xml.sax.parser är inte angiven""},



  


  {
    ER_PARSER_ARG_CANNOT_BE_NULL,
     ""Tolkningsargumentet får inte vara null""},




  


  {
    ER_FEATURE,
     ""Funktion:a {0}""},




  


  {
    ER_PROPERTY,
     ""Egenskap:a {0}""},



  


  {
    ER_NULL_ENTITY_RESOLVER,
     ""Nullenhetslösare""},



  


  {
    ER_NULL_DTD_HANDLER,
     ""Null-DTD-hanterare""},



  

  {
    ER_NO_DRIVER_NAME_SPECIFIED,
     ""Inget drivrutinsnamn är angett!""},




  

  {
    ER_NO_URL_SPECIFIED,
     ""Ingen URL har angetts!""},




  

  {
    ER_POOLSIZE_LESS_THAN_ONE,
     ""Poolstorleken är mindre än 1!""},




  

  {
    ER_INVALID_DRIVER_NAME,
     ""Ett ogiltigt drivrutinsnamn har angetts!""},





  

  {
    ER_ERRORLISTENER,
     ""ErrorListener""},




  

  {
    ER_ASSERT_NO_TEMPLATE_PARENT,
     ""Programmerarfel! expr har inget överordnat ElemTemplateElement!""},




  

  {
    ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
     ""Programmerarkontroll i RundundentExprEliminator: {0}""},


  
  

  {
    ER_NOT_ALLOWED_IN_POSITION,
     ""{0} är inte tillåten i denna position i formatmallen!""},


  
  

  {
    ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
     ""Text utan blanksteg är inte tillåten i denna position i formatmallen!""},


  
  
  
  

  {
    INVALID_TCHAR,
     ""Ogiltigt värde: {1} används för CHAR-attributet: {0}.  Ett attribut av CHAR-typ får bara ha 1 tecken!""},


    
    
    
    
    

  
  
  

  {
    INVALID_QNAME,
     ""Ogiltigt värde:a {1} används för QNAME-attributet:a {0}""},


    
    
    
    
    
    

  
  

  {
    INVALID_ENUM,
     ""Ogiltigt värde:a  {1} används för ENUM-attributet:a {0}.  Giltiga värden är:a {2}.""},








  
  

  {
    INVALID_NMTOKEN,
     ""Ogiltigt värde:a {1} används för NMTOKEN-attributet:a {0} ""},








  
  

  {
    INVALID_NCNAME,
     ""Ogiltigt värde:a {1} används för NCNAME-attributet:a {0} ""},








  
  


  {
    INVALID_BOOLEAN,
     ""Ogiltigt värde:a {1} används som Booleskt attribut:a {0} ""},








  
  

  {
    INVALID_NUMBER,
     ""Ogiltigt värde:a {1} används som sifferattribut:a {0} ""},



  







  
  

  {
    ER_ARG_LITERAL,
     ""Argument för {0} i matchningsmönstret måste vara literalt.""},







  
  

  {
    ER_DUPLICATE_GLOBAL_VAR,
     ""Dubbel deklaration av global variabel.""},







  
  

  {
    ER_DUPLICATE_VAR,
     ""Dubbel variabeldeklaration.""},


    
    
    

  
  

  {
    ER_TEMPLATE_NAME_MATCH,
     ""xsl: en mall måste ha ett namn och ett matchningsattribut (eller både och)""},


    
    
    
    
    

  
  

  {
    ER_INVALID_PREFIX,
     ""Prefix i exclude-result-prefixes är ogiltigt:a {0}""},


    
    
    
    
    

  
  

  {
    ER_NO_ATTRIB_SET,
     ""attributserien {0} finns inte""},


  

  
  


  {
    WG_FOUND_CURLYBRACE,
      ""Hittade '}' men ingen attributmall är öppen!""},


  
  


  {
    WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""Varning: räknarattribut matchar inte en förfäder in xsl:number! Target = {0}""},


  
  


  {
    WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""Gammal syntax: Namnet på  'expr'-attributet har ändrats till 'select'.""},


  
  


  {
    WG_NO_LOCALE_IN_FORMATNUMBER,
      ""Xalan hanterar ännu inte locale-namnet i funktionen format-number.""},


  
  


  {
    WG_LOCALE_NOT_FOUND,
      ""Varning: Hittade inte locale för xml:lang{0}""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""Kan inte skapa URL från: {0}""},


  
  


  {
    WG_CANNOT_LOAD_REQUESTED_DOC,
      ""Kan inte ladda begärd doc: {0}""},


  
  


  {
    WG_CANNOT_FIND_COLLATOR,
      ""Hittade inte Collator för <sort xml:lang={0}""},


  
  


  {
    WG_FUNCTIONS_SHOULD_USE_URL,
      ""Gammal syntax: Funktionsinstruktionen borde använda en url av {0}""},


  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""kodning understöds inte: {0}, använder UTF-8""},


  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      ""kodning understöds inte: {0}, använder Java {1}""},


  
  


  {
    WG_SPECIFICITY_CONFLICTS,
      ""Hittade specificitetskonflikter: {0} Senast hittade i stylesheet kommer att användas.""},


  
  


  {
    WG_PARSING_AND_PREPARING,
      ""========= Tolkar och förbereder {0} ==========""},


  
  


  {
    WG_ATTR_TEMPLATE, ""Attributmall, {0}""},


  
  


  {
    WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""Matcha konflikter mellan xsl:strip-space och xsl:preserve-space""},


  
  


  {
    WG_ATTRIB_NOT_HANDLED,
      ""Xalan hanterar ännu inte attributet {0}!""},


  
  


  {
    WG_NO_DECIMALFORMAT_DECLARATION,
      ""Deklaration saknas för decimalformat: {0}""},


  
  


  {
    WG_OLD_XSLT_NS, ""XSLT-Namnrymd saknas eller är inkorrekt ""},


  
  


  {
    WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""Endast en standarddeklaration av xsl:decimal-format är tillåten.""},


  
  


  {
    WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""xsl:decimal-formatnamn måste vara unika. Namnet ""{0}"" har blivit duplicerat.""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE,
      ""{0} har ett otillåtet attribut: {1}""},


  
  


  {
    WG_COULD_NOT_RESOLVE_PREFIX,
      ""Kan inte lösa namnrymdsprefix: {0}. Noden kommer att ignoreras.""},


  
  


  {
    WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet måste ha ett 'version'-attribut!""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE_NAME,
      ""Otillåtet attributnamn: {0}""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""Ogiltigt värde använt för attribut {0}: {1}""},


  
  


  {
    WG_EMPTY_SECOND_ARG,
      ""Den resulterande nodmängden från dokumentfunktions andra argument är tomt. Det första argumentet kommer att användas.""},


  

    
    
    


  
  

  {
     WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""Värdet på attributet 'name' i xsl:processing-instruction får inte vara 'xml'""},


    
    
    
    

  
  

  {
     WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""Värdet på attributet  ''name'' i xsl:processing-instruction måste vara ett giltigt NCName:a {0}""},


    
    
    
    
    

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_POSITION,
      ""Det går inte att lägga till attributet {0} efter undernoder eller innan ett element produceras. Attributet ignoreras.""},


    

  
  { ""ui_language"", ""sv""},
  { ""help_language"", ""sv""},
  { ""language"", ""sv""},
    { ""BAD_CODE"",
      ""Parameter till createMessage ligger utanför tillåtet intervall""},
    { ""FORMAT_FAILED"",
      ""Undantag utlöst vid messageFormat-anrop""},
    { ""version"", "">>>>>>> Xalan Version""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""ja""},
    { ""line"",  ""Rad #""},
    { ""column"", ""Kolumn #""},
    { ""xsldone"", ""XSLProcessor: färdig""},
    { ""xslProc_option"", ""Xalan-J kommando linje Process klass alternativ:""},
    { ""optionIN"", ""    -IN inputXMLURL""},
    { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
    { ""optionOUT"", ""   [-OUT utdataFilnamn]""},
    { ""optionLXCIN"", ""   [-LXCIN kompileratStylesheetFilnameIn]""},
    { ""optionLXCOUT"", ""   [-LXCOUT kompileratStylesheetFilenameUt]""},
    { ""optionPARSER"", 
      ""   [-PARSER fullt kvalificerat klassnamn eller tolkförbindelse]""},
    { ""optionE"", ""   [-E (Utöka inte enhetsreferenser)]""},
    { ""optionV"", ""   [-E (Utöka inte enhetsreferenser)]""},
    { ""optionQC"",
      ""   [-QC (Tysta Mönsterkonfliktvarningar)]""},
    { ""optionQ"", ""   [-Q  (Tyst Tillstånd)]""},
    { ""optionLF"",
      ""   [-LF (Använd radframmatning enbart på utdata {standard är CR/LF})]""},
    { ""optionCR"",
      ""   [-CR (Använd vagnretur enbart på utdata {standard är CR/LF})]""},
    { ""optionESCAPE"",
      ""   [-ESCAPE (Vilka tecken är skiftningstecken {standard är <>&""'\r\n}]""},
    { ""optionINDENT"",
      ""   [-INDENT (Bestäm antal blanksteg för att tabulera {standard är 0})]""},
    { ""optionTT"",
      ""   [-TT (Spåra mallarna allt eftersom de blir anropade.)]""},
    { ""optionTG"",
      ""   [-TG (Spåra varje generationshändelse.)]""},
    { ""optionTS"", ""   [-TS (Spåra varje valhändelse.)]""},
    { ""optionTTC"",
      ""   [-TTC (Spåra mallbarnen allt eftersom de blir behandlade.)]""},
    { ""optionTCLASS"",
      ""   [-TCLASS (TraceListener-klass för spårningsanslutningar.)]""},
    { ""optionVALIDATE"",
      ""   [-VALIDATE (Sätt om validering ska ske.  Standard är att validering är avstängd)]""},
    { ""optionEDUMP"",
      ""   [-EDUMP {valfritt filnamn) (Gör stackdump vid fel.)]""},
    { ""optionXML"",
      ""   [-XML (Använd XML-formaterare och lägg till XML-huvud.)]""},
    { ""optionTEXT"",
      ""   [-XML (Använd enkel Text-formaterare.)]""},
    { ""optionHTML"", ""   [-HTML (Använd HTML-formaterare)]""},
    { ""optionPARAM"",
      ""   [-PARAM namn uttryck (Sätt en stylesheet-parameter)]""},
    { ""noParsermsg1"", ""XSL-Process misslyckades.""},
    { ""noParsermsg2"", ""** Hittade inte tolk **""},
    { ""noParsermsg3"", ""Vänligen kontrollera din classpath""},
    { ""noParsermsg4"",
      ""Om du inte har IBMs XML-Tolk för Java, kan du ladda ner den från""},
    { ""noParsermsg5"",
      ""IBM's AlphaWorks: http:
    {  ""optionURIRESOLVER"",
    ""   [-URIRESOLVER fullständigt klassnamn (URIResolver som ska användas för att lösa URI-er)]""},
    { ""optionENTITYRESOLVER"",
    ""   [-ENTITYRESOLVER fullständigt klassnamn (EntityResolver som ska användas för att lösa enheter)]""},
    {  ""optionCONTENTHANDLER"",
    ""   [-CONTENTRESOLVER fullständigt klassnamn (ContentHandler som ska användas för att serialisera utdata)]""},
    { ""optionLINENUMBERS"", ""   [-L använd radnummer i källdokument]""},

    


    { ""optionMEDIA"",
    "" [-MEDIA mediaType (använd medieattribut för att hitta en formatmall som är associerad med ett dokument.)]""},
    { ""optionFLAVOR"",
    "" [-FLAVOR flavorName (Använd s2s=SAX eller d2d=DOM för transformationen.)] ""}, 
    { ""optionDIAG"",
    "" [-DIAG (Skriv ut totala transformationer, millisekunder.)]""},
    { ""optionINCREMENTAL"",
    "" [-INCREMENTAL (begär inkrementell DTM-konstruktion genom att ange http:
    { ""optionNOOPTIMIMIZE"",
    "" [-NOOPTIMIMIZE (begär ingen formatmallsoptimering genom att ange http:
    { ""optionRL"",
     "" [-RL recursionlimit (kontrollera numerisk gräns på formatmallens rekursionsdjup.)]""},
    { ""optionXO"",
    "" [-XO [transletName] (tilldela namnet till genererad translet)]""},
    { ""optionXD"",
    "" [-XD destinationDirectory (ange målkatalog för translet)]""},
    { ""optionXJ"",
    "" [-XJ jarfile (paketerar transletklasserna i en jar-fil med namnet <jarfile>)]""},
    { ""optionXP"",
    "" [-XP-paket (anger ett paketnamnsprefix för alla genererade transletklasser)]""}

		
  };

  

  
  public static final String BAD_CODE = ""DÅLIG_KOD"";

  
  public static final String FORMAT_FAILED = ""FORMATERING_MISSLYCKADES"";

  
  public static final String ERROR_STRING = ""#fel"";

  
  public static final String ERROR_HEADER = ""Fel: "";

  
  public static final String WARNING_HEADER = ""Varning: "";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""MÖNSTER "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}


"
org.apache.xpath.functions.FuncQname,2,5,0,5,7,1,0,5,2,2.0,35,0.0,0,0.982142857,0.75,2,7,16.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncQname extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int context = getArg0AsNode(xctxt);
    XObject val;

    if (DTM.NULL != context)
    {
      DTM dtm = xctxt.getDTM(context);
      String qname = dtm.getNodeNameX(context);
      val = (null == qname) ? XString.EMPTYSTRING : new XString(qname);
    }
    else
    {
      val = XString.EMPTYSTRING;
    }

    return val;
  }
}
"
org.apache.xpath.axes.IteratorPool,4,1,0,4,13,0,2,2,4,0.166666667,76,1.0,1,0.0,0.75,0,0,17.5,2,1.0,1,"
package org.apache.xpath.axes;

import java.util.Vector;

import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.WrappedRuntimeException;


public class IteratorPool implements java.io.Serializable
{

  
  private final DTMIterator m_orig;

  
  private final Vector m_freeStack;

  
  public IteratorPool(DTMIterator original)
  {
    m_orig = original;
    m_freeStack = new Vector();
  }
  
  
  public synchronized DTMIterator getInstanceOrThrow()
    throws CloneNotSupportedException
  {
    
    if (m_freeStack.isEmpty())
    {

      
      return (DTMIterator)m_orig.clone();
    }
    else
    {
      
      DTMIterator result = (DTMIterator)m_freeStack.lastElement();

      m_freeStack.setSize(m_freeStack.size() - 1);

      return result;
    }
  }
  
  
  public synchronized DTMIterator getInstance()
  {
    
    if (m_freeStack.isEmpty())
    {

      
      try
      {
        return (DTMIterator)m_orig.clone();
      }
      catch (Exception ex)
      {
        throw new WrappedRuntimeException(ex);
      }
    }
    else
    {
      
      DTMIterator result = (DTMIterator)m_freeStack.lastElement();

      m_freeStack.setSize(m_freeStack.size() - 1);

      return result;
    }
  }

  
  public synchronized void freeInstance(DTMIterator obj)
  {
    m_freeStack.addElement(obj);
  }
}"
org.apache.xalan.xsltc.compiler.RelativeLocationPath,3,3,2,4,4,3,3,1,2,2.0,6,0.0,0,0.97260274,0.666666667,0,0,1.0,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

abstract class RelativeLocationPath extends Expression {
    public abstract int getAxis();
    public abstract void setAxis(int axis);
}
"
org.apache.xalan.xsltc.DOMCache,1,1,0,6,1,0,4,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"

package org.apache.xalan.xsltc;


public interface DOMCache {

    
    public DOM retrieveDocument(String uri, int mask, Translet translet);

}
"
org.apache.xpath.ExtensionsProvider,4,1,0,4,4,6,4,1,4,2.0,4,0.0,0,0.0,0.55,0,0,0.0,1,1.0,0,"
package org.apache.xpath;

import java.util.Vector;

import org.apache.xpath.functions.FuncExtFunction;


public interface ExtensionsProvider
{
  
  
  public boolean functionAvailable(String ns, String funcName)
          throws javax.xml.transform.TransformerException;
  
  
  public boolean elementAvailable(String ns, String elemName)
          throws javax.xml.transform.TransformerException;
   
  
  public Object extFunction(String ns, String funcName, 
                            Vector argVec, Object methodKey)
            throws javax.xml.transform.TransformerException;

  
  public Object extFunction(FuncExtFunction extFunction, 
                            Vector argVec)
            throws javax.xml.transform.TransformerException;
}
"
org.apache.xalan.templates.XSLTVisitable,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xalan.templates;


public interface XSLTVisitable
{
	
	public void callVisitors(XSLTVisitor visitor);
}

"
org.apache.xalan.xsltc.trax.DOM2TO,22,1,0,2,49,221,1,1,20,0.964285714,341,1.0,1,0.0,0.143939394,0,0,14.31818182,2,1.0,2,"

package org.apache.xalan.xsltc.trax;

import java.io.IOException;


import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.apache.xml.serializer.SerializationHandler;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.XMLReader;

public class DOM2TO implements XMLReader, Locator {

    private final static String EMPTYSTRING = """";
    private static final String XMLNS_PREFIX = ""xmlns"";

    
    private Node _dom;

    
    private SerializationHandler _handler;

    public DOM2TO(Node root, SerializationHandler handler) {
	_dom = root;
	_handler = handler;
    }

    public ContentHandler getContentHandler() { 
	return null;
    }

    public void setContentHandler(ContentHandler handler) {
	
    }

    public void parse(InputSource unused) throws IOException, SAXException {
        parse(_dom);
    }

    public void parse() throws IOException, SAXException {
	if (_dom != null) {
	    boolean isIncomplete = 
		(_dom.getNodeType() != org.w3c.dom.Node.DOCUMENT_NODE);

	    if (isIncomplete) {
		_handler.startDocument();
		parse(_dom);
		_handler.endDocument();
	    }
	    else {
		parse(_dom);
	    }
	}
    }

    
    private void parse(Node node) 
	throws IOException, SAXException 
    {
 	if (node == null) return;

        switch (node.getNodeType()) {
	case Node.ATTRIBUTE_NODE:         
	case Node.DOCUMENT_TYPE_NODE :
	case Node.ENTITY_NODE :
	case Node.ENTITY_REFERENCE_NODE:
	case Node.NOTATION_NODE :
	    
	    break;
	case Node.CDATA_SECTION_NODE:
	    _handler.startCDATA();
	    _handler.characters(node.getNodeValue());
	    _handler.endCDATA();
	    break;

	case Node.COMMENT_NODE:           
	    _handler.comment(node.getNodeValue());
	    break;

	case Node.DOCUMENT_NODE:
	    _handler.startDocument();
	    Node next = node.getFirstChild();
	    while (next != null) {
		parse(next);
		next = next.getNextSibling();
	    }
	    _handler.endDocument();
	    break;

	case Node.DOCUMENT_FRAGMENT_NODE:
	    next = node.getFirstChild();
	    while (next != null) {
		parse(next);
		next = next.getNextSibling();
	    }
	    break;

	case Node.ELEMENT_NODE:
	    
	    final String qname = node.getNodeName();
	    _handler.startElement(null, null, qname);
	    String prefix;
	    final NamedNodeMap map = node.getAttributes();
	    final int length = map.getLength();

	    
	    for (int i = 0; i < length; i++) {
		int colon;
		final Node attr = map.item(i);
		final String qnameAttr = attr.getNodeName();

		if (qnameAttr.startsWith(XMLNS_PREFIX)) {
		    final String uriAttr = attr.getNodeValue();
		    colon = qnameAttr.lastIndexOf(':');
		    prefix = (colon > 0) ? qnameAttr.substring(colon + 1) 
			: EMPTYSTRING;
		    _handler.namespaceAfterStartElement(prefix, uriAttr);
		}
		else {
		    final String uriAttr = attr.getNamespaceURI();
		    
		    if (uriAttr != null && !uriAttr.equals(EMPTYSTRING) ) {	
			colon = qnameAttr.lastIndexOf(':');
			prefix = (colon > 0) ? qnameAttr.substring(0, colon) 
			    : EMPTYSTRING;
			_handler.namespaceAfterStartElement(prefix, uriAttr);
		    }
		    _handler.addAttribute(qnameAttr, attr.getNodeValue());
		}
	    }

	    
	    final String uri = node.getNamespaceURI();

	    
	    if (uri != null) {	
		final int colon = qname.lastIndexOf(':');
		prefix = (colon > 0) ? qname.substring(0, colon) : EMPTYSTRING;
		_handler.namespaceAfterStartElement(prefix, uri);
	    }

	    
	    next = node.getFirstChild();
	    while (next != null) {
		parse(next);
		next = next.getNextSibling();
	    }

	    
	    _handler.endElement(qname);
	    break;

	case Node.PROCESSING_INSTRUCTION_NODE:
	    _handler.processingInstruction(node.getNodeName(),
					   node.getNodeValue());
	    break;

	case Node.TEXT_NODE:
	    _handler.characters(node.getNodeValue());
	    break;
	}
    }

    
    public DTDHandler getDTDHandler() { 
	return null;
    }

    
    public ErrorHandler getErrorHandler() {
	return null;
    }

    
    public boolean getFeature(String name) throws SAXNotRecognizedException,
	SAXNotSupportedException
    {
	return false;
    }

    
    public void setFeature(String name, boolean value) throws 
	SAXNotRecognizedException, SAXNotSupportedException 
    {
    }

    
    public void parse(String sysId) throws IOException, SAXException {
	throw new IOException(""This method is not yet implemented."");
    }

    
    public void setDTDHandler(DTDHandler handler) throws NullPointerException {
    }

    
    public void setEntityResolver(EntityResolver resolver) throws 
	NullPointerException 
    {
    }

    
    public EntityResolver getEntityResolver() {
	return null;
    }

    
    public void setErrorHandler(ErrorHandler handler) throws 
	NullPointerException
    {
    }

    
    public void setProperty(String name, Object value) throws
	SAXNotRecognizedException, SAXNotSupportedException {
    }

    
    public Object getProperty(String name) throws SAXNotRecognizedException,
	SAXNotSupportedException
    {
	return null;
    }

    
    public int getColumnNumber() { 
	return 0; 
    }
    
    
    public int getLineNumber() { 
	return 0; 
    }

    
    public String getPublicId() { 
	return null; 
    }

    
    public String getSystemId() { 
	return null; 
    }

    
    private String getNodeTypeFromCode(short code) {
	String retval = null;
	switch (code) {
	case Node.ATTRIBUTE_NODE : 
	    retval = ""ATTRIBUTE_NODE""; break; 
	case Node.CDATA_SECTION_NODE :
	    retval = ""CDATA_SECTION_NODE""; break; 
	case Node.COMMENT_NODE :
	    retval = ""COMMENT_NODE""; break; 
	case Node.DOCUMENT_FRAGMENT_NODE :
	    retval = ""DOCUMENT_FRAGMENT_NODE""; break; 
	case Node.DOCUMENT_NODE :
	    retval = ""DOCUMENT_NODE""; break; 
	case Node.DOCUMENT_TYPE_NODE :
	    retval = ""DOCUMENT_TYPE_NODE""; break; 
	case Node.ELEMENT_NODE :
	    retval = ""ELEMENT_NODE""; break; 
	case Node.ENTITY_NODE :
	    retval = ""ENTITY_NODE""; break; 
	case Node.ENTITY_REFERENCE_NODE :
	    retval = ""ENTITY_REFERENCE_NODE""; break; 
	case Node.NOTATION_NODE :
	    retval = ""NOTATION_NODE""; break; 
	case Node.PROCESSING_INSTRUCTION_NODE :
	    retval = ""PROCESSING_INSTRUCTION_NODE""; break; 
	case Node.TEXT_NODE:
	    retval = ""TEXT_NODE""; break; 
        }
	return retval;
    }
}
"
org.apache.xalan.trace.TraceListener,3,1,0,8,3,3,5,3,3,2.0,3,0.0,0,0.0,0.5,0,0,0.0,1,1.0,1,"
package org.apache.xalan.trace;



public interface TraceListener extends java.util.EventListener
{

  
  public void trace(TracerEvent ev);

  
  public void selected(SelectionEvent ev) throws javax.xml.transform.TransformerException;

  
  public void generated(GenerateEvent ev);
}
"
org.apache.xml.utils.res.XResources_en,3,4,0,1,4,1,0,1,2,0.5,314,0.0,0,0.976190476,1.0,0,0,103.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_en extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""en"" }, { ""help_language"", ""en"" }, { ""language"", ""en"" },
    { ""alphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    
    
    
    
    
    
    
    
    
  };
}
"
org.apache.xalan.xsltc.compiler.VariableRefBase,7,3,3,16,22,0,10,9,7,0.416666667,146,1.0,2,0.934210526,0.357142857,2,4,19.57142857,3,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

class VariableRefBase extends Expression {

    
    protected final VariableBase _variable; 

    
    protected Closure _closure = null;

    public VariableRefBase(VariableBase variable) {
	_variable = variable;
	variable.addReference(this);
    }

    public VariableRefBase() {
	_variable = null;
    }

    
    public VariableBase getVariable() {
	return _variable;
    }

    
    public VariableBase findParentVariable() {
	SyntaxTreeNode node = this;
	while (node != null && !(node instanceof VariableBase)) {
	    node = node.getParent();
	}
	return (VariableBase) node;
    }

    
    public boolean equals(Object obj) {
	try {
	    return (_variable == ((VariableRefBase) obj)._variable);
	} 
	catch (ClassCastException e) {
	    return false;
	}
    }

    
    public String toString() {
	return ""variable-ref(""+_variable.getName()+'/'+_variable.getType()+')';
    }

    public Type typeCheck(SymbolTable stable) 
	throws TypeCheckError 
    {
	
	if (_type != null) return _type;

	
	if (_variable.isLocal()) {
	    SyntaxTreeNode node = getParent();
	    do {
		if (node instanceof Closure) {
		    _closure = (Closure) node;
		    break;
		}
		if (node instanceof TopLevelElement) {
		    break;	
		}
		node = node.getParent();
	    } while (node != null);

	    if (_closure != null) {
		_closure.addVariable(this);
	    }
	}

	
	VariableBase parent = findParentVariable();
	if (parent != null) parent.addDependency(_variable);

        
        _type = _variable.getType();

        
        
        if (_type == null) {
            _variable.typeCheck(stable);
            _type = _variable.getType();
        }

        
        return _type;
    }

}
"
org.apache.xalan.templates.ElemCallTemplate,13,4,1,16,49,40,2,14,13,0.638888889,352,0.666666667,3,0.946902655,0.188034188,4,11,25.84615385,2,1.1538,1,"
package org.apache.xalan.templates;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;


public class ElemCallTemplate extends ElemForEach
{

  
  public QName m_templateName = null;

  
  public void setName(QName name)
  {
    m_templateName = name;
  }

  
  public QName getName()
  {
    return m_templateName;
  }

  
  private ElemTemplate m_template = null;

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_CALLTEMPLATE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_CALLTEMPLATE_STRING;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    
    
    
    int length = getParamElemCount();
    for (int i = 0; i < length; i++) 
    {
      ElemWithParam ewp = getParamElem(i);
      ewp.compose(sroot);
    }
    
    if ((null != m_templateName) && (null == m_template))
    {
      m_template =
        this.getStylesheetRoot().getTemplateComposed(m_templateName);
        
      if(null == m_template)
        return; 
    
      length = getParamElemCount();
      for (int i = 0; i < length; i++) 
      {
        ElemWithParam ewp = getParamElem(i);
        ewp.m_index = -1;
        
        
        int etePos = 0;
        for (ElemTemplateElement ete = m_template.getFirstChildElem(); 
             null != ete; ete = ete.getNextSiblingElem()) 
        {
          if(ete.getXSLToken() == Constants.ELEMNAME_PARAMVARIABLE)
          {
            ElemParam ep = (ElemParam)ete;
            if(ep.getName().equals(ewp.getName()))
            {
              ewp.m_index = etePos;
            }
          }
          else
            break;
          etePos++;
        }
        
      }
    }
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    int length = getParamElemCount();
    for (int i = 0; i < length; i++) 
    {
      ElemWithParam ewp = getParamElem(i);
      ewp.endCompose(sroot);
    }    
    
    super.endCompose(sroot);
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    if (null != m_template)
    {
      XPathContext xctxt = transformer.getXPathContext();
      VariableStack vars = xctxt.getVarStack();

      int thisframe = vars.getStackFrame();
      int nextFrame = vars.link(m_template.m_frameSize);
      
      
      
      if(m_template.m_inArgsSize > 0)
      {
        vars.clearLocalSlots(0, m_template.m_inArgsSize);
      
        if(null != m_paramElems)
        {
          int currentNode = xctxt.getCurrentNode();
          vars.setStackFrame(thisframe);
          int size = m_paramElems.length;
          
          for (int i = 0; i < size; i++) 
          {
            ElemWithParam ewp = m_paramElems[i];
            if(ewp.m_index >= 0)
            {
              XObject obj = ewp.getValue(transformer, currentNode);
              
              
              
              
              vars.setLocalVariable(ewp.m_index, obj, nextFrame);
            }
          }
          vars.setStackFrame(nextFrame);
        }
      }
      
      SourceLocator savedLocator = xctxt.getSAXLocator();

      try
      {
        xctxt.setSAXLocator(m_template);

        
        transformer.pushElemTemplateElement(m_template);
        m_template.execute(transformer);
      }
      finally
      {
        transformer.popElemTemplateElement();
        xctxt.setSAXLocator(savedLocator);
        
        
        
        
        
        
        
        
        
        vars.unlink(thisframe);
      }
    }
    else
    {
      transformer.getMsgMgr().error(this, XSLTErrorResources.ER_TEMPLATE_NOT_FOUND,
                                    new Object[]{ m_templateName });  
    }
    
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this); 

  }
  
  
  protected ElemWithParam[] m_paramElems = null;

  
  public int getParamElemCount()
  {
    return (m_paramElems == null) ? 0 : m_paramElems.length;
  }

  
  public ElemWithParam getParamElem(int i)
  {
    return m_paramElems[i];
  }

  
  public void setParamElem(ElemWithParam ParamElem)
  {
    if (null == m_paramElems)
    {
      m_paramElems = new ElemWithParam[1];
      m_paramElems[0] = ParamElem;
    }
    else
    {
      
      
      int length = m_paramElems.length;
      ElemWithParam[] ewp = new ElemWithParam[length + 1];
      System.arraycopy(m_paramElems, 0, ewp, 0, length);
      m_paramElems = ewp;
      ewp[length] = ParamElem;
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    if (Constants.ELEMNAME_WITHPARAM == type)
    {
      setParamElem((ElemWithParam) newChild);
    }

    
    
    return super.appendChild(newChild);
  }
  
    
    public void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
    {











      super.callChildVisitors(visitor, callAttrs);
    }
}
"
org.apache.xpath.XPathException,13,4,1,4,26,8,2,2,12,0.541666667,257,0.5,0,0.771428571,0.269230769,2,4,18.61538462,5,1.8462,1,"
package org.apache.xpath;

import javax.xml.transform.TransformerException;

import org.w3c.dom.Node;


public class XPathException extends TransformerException
{

  
  Object m_styleNode = null;

  
  public Object getStylesheetNode()
  {
    return m_styleNode;
  }
  
  
  public void setStylesheetNode(Object styleNode)
  {
    m_styleNode = styleNode;
  }


  
  protected Exception m_exception;

  
  public XPathException(String message, ExpressionNode ex)
  {
    super(message);
    this.setLocator(ex);
    setStylesheetNode(getStylesheetNode(ex));
  }
  
  
  public XPathException(String message)
  {
    super(message);
  }

  
  
  public org.w3c.dom.Node getStylesheetNode(ExpressionNode ex)
  {
  	
    ExpressionNode owner = getExpressionOwner(ex);

    if (null != owner && owner instanceof org.w3c.dom.Node)
    {
		return ((org.w3c.dom.Node)owner);
    }
    return null;

  }
  
  
  protected ExpressionNode getExpressionOwner(ExpressionNode ex)
  {
  	ExpressionNode parent = ex.exprGetParent();
  	while((null != parent) && (parent instanceof Expression))
  		parent = parent.exprGetParent();
  	return parent;
  }



  
  public XPathException(String message, Object styleNode)
  {

    super(message);

    m_styleNode = styleNode;
  }

  
  public XPathException(String message, Node styleNode, Exception e)
  {

    super(message);

    m_styleNode = styleNode;
    this.m_exception = e;
  }

  
  public XPathException(String message, Exception e)
  {

    super(message);

    this.m_exception = e;
  }

  
  public void printStackTrace(java.io.PrintStream s)
  {

    if (s == null)
      s = System.err;

    try
    {
      super.printStackTrace(s);
    }
    catch (Exception e){}

    Throwable exception = m_exception;

    for (int i = 0; (i < 10) && (null != exception); i++)
    {
      s.println(""---------"");
      exception.printStackTrace(s);

      if (exception instanceof TransformerException)
      {
        TransformerException se = (TransformerException) exception;
        Throwable prev = exception;

        exception = se.getException();

        if (prev == exception)
          break;
      }
      else
      {
        exception = null;
      }
    }
  }

  
  public String getMessage()
  {

    String lastMessage = super.getMessage();
    Throwable exception = m_exception;

    while (null != exception)
    {
      String nextMessage = exception.getMessage();

      if (null != nextMessage)
        lastMessage = nextMessage;

      if (exception instanceof TransformerException)
      {
        TransformerException se = (TransformerException) exception;
        Throwable prev = exception;

        exception = se.getException();

        if (prev == exception)
          break;
      }
      else
      {
        exception = null;
      }
    }

    return (null != lastMessage) ? lastMessage : """";
  }

  
  public void printStackTrace(java.io.PrintWriter s)
  {

    if (s == null)
      s = new java.io.PrintWriter(System.err);

    try
    {
      super.printStackTrace(s);
    }
    catch (Exception e){}

    Throwable exception = m_exception;

    for (int i = 0; (i < 10) && (null != exception); i++)
    {
      s.println(""---------"");

      try
      {
        exception.printStackTrace(s);
      }
      catch (Exception e)
      {
        s.println(""Could not print stack trace..."");
      }

      if (exception instanceof TransformerException)
      {
        TransformerException se = (TransformerException) exception;
        Throwable prev = exception;

        exception = se.getException();

        if (prev == exception)
        {
          exception = null;

          break;
        }
      }
      else
      {
        exception = null;
      }
    }
  }

  
  public Throwable getException()
  {
    return m_exception;
  }
}
"
org.apache.xml.utils.synthetic.SynthesisException,4,3,0,6,5,0,6,0,2,1.095238095,54,0.0,0,0.944444444,0.666666667,0,0,10.75,1,0.25,1,"
package org.apache.xml.utils.synthetic;


public class SynthesisException extends Exception
{

  
  int code;

  

  
  public static final int SYNTAX = 0;

  
  public static final int UNSUPPORTED = 1;

  
  public static final int REIFIED = 2;

  
  public static final int UNREIFIED = 3;

  
  public static final int WRONG_OWNER = 4;

  
  public static final String[] errToString = {
    ""(Syntax error; specific message should be passed in)"",
    ""Feature not yet supported"",
    ""Can't change features of 'real' class"",
    ""Can't yet instantiate/invoke without 'real' class"",
    ""Can't add Member to an object other than its declarer"", };

  
  public SynthesisException(int code)
  {

    super(errToString[code]);

    this.code = code;
  }

  
  public SynthesisException(int code, String msg)
  {

    super(msg);

    this.code = code;
  }

  
  int getCode()
  {
    return code;
  }
}
"
org.apache.xalan.xsltc.dom.Filter,1,1,0,2,1,0,2,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.dom;

public interface Filter {
    public boolean test(int node);
}
"
org.apache.xalan.xsltc.dom.ForwardPositionIterator,7,2,0,3,19,0,0,3,7,0.0,64,1.0,1,0.684210526,0.428571429,1,5,8.0,1,0.8571,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;


public final class ForwardPositionIterator extends DTMAxisIteratorBase {

    private DTMAxisIterator _source;

    public ForwardPositionIterator(DTMAxisIterator source) {
	_source = source;
    }

    public DTMAxisIterator cloneIterator() {
	try {
	    final ForwardPositionIterator clone = 
		(ForwardPositionIterator) super.clone();
	    clone._source = _source.cloneIterator();
	    clone._isRestartable = false;
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }

    public int next() {
	return returnNode(_source.next());
    }
	
    public DTMAxisIterator setStartNode(int node) {
	_source.setStartNode(node);
	return this;
    }

    public DTMAxisIterator reset() {
	_source.reset();
	return resetPosition();
    }

    public void setMark() {
	_source.setMark();
    }

    public void gotoMark() {
	_source.gotoMark();
    }
}
"
org.apache.xalan.xsltc.compiler.util.ClassGenerator,10,3,4,124,15,27,120,5,9,0.888888889,87,1.0,2,0.898734177,0.288888889,0,0,6.9,1,0.8,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ClassGen;
import org.apache.bcel.generic.Instruction;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.Stylesheet;


public class ClassGenerator extends ClassGen {
    protected static int TRANSLET_INDEX = 0;
    protected static int INVALID_INDEX  = -1;

    private Stylesheet _stylesheet;
    private final Parser _parser;		
    
    private final Instruction _aloadTranslet;
    private final String _domClass;
    private final String _domClassSig;
    private final String _applyTemplatesSig;

    public ClassGenerator(String class_name, String super_class_name,
			  String file_name,
			  int access_flags, String[] interfaces,
			  Stylesheet stylesheet) {
	super(class_name, super_class_name, file_name,
	      access_flags, interfaces);
	_stylesheet = stylesheet;
	_parser = stylesheet.getParser();
	_aloadTranslet = new ALOAD(TRANSLET_INDEX);
	
	if (stylesheet.isMultiDocument()) {
	    _domClass = ""org.apache.xalan.xsltc.dom.MultiDOM"";
	    _domClassSig = ""Lorg/apache/xalan/xsltc/dom/MultiDOM;"";
	}
	else {
	    _domClass = ""org.apache.xalan.xsltc.dom.DOMAdapter"";
	    _domClassSig = ""Lorg/apache/xalan/xsltc/dom/DOMAdapter;"";
	}
	_applyTemplatesSig = ""("" 
	    + Constants.DOM_INTF_SIG
	    + Constants.NODE_ITERATOR_SIG
	    + Constants.TRANSLET_OUTPUT_SIG
	    + "")V""; 
    }

    public final Parser getParser() {
	return _parser;
    }

    public final Stylesheet getStylesheet() {
	return _stylesheet;
    }

    
    public final String getClassName() {
	return _stylesheet.getClassName();
    }

    public Instruction loadTranslet() {
	return _aloadTranslet;
    }

    public final String getDOMClass() {
	return _domClass;
    }

    public final String getDOMClassSig() {
	return _domClassSig;
    }

    public final String getApplyTemplatesSig() {
	return _applyTemplatesSig;
    }

    
    public boolean isExternal() {
	return false;
    }
}
"
org.apache.xalan.res.XSLTErrorResources_en,1,4,0,1,2,0,0,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xalan.res;



public class XSLTErrorResources_en extends XSLTErrorResources
{
}
"
org.apache.xalan.xsltc.util.JavaCupRedirect,3,1,0,1,15,3,0,1,3,1.5,124,1.0,0,0.0,0.333333333,0,0,40.0,6,2.6667,0,"

package org.apache.xalan.xsltc.util;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;


public class JavaCupRedirect {

    private final static String ERRMSG = 
		 ""You must supply a filename with the -stdin option."";

    public static void main (String args[]) {

		 
         
		 boolean systemExitOK = true;

		 
		 InputStream input = null;

		 
		 final int argc = args.length;

		 
		 String[] new_args = new String[argc - 2];
		 int new_argc = 0;

		 
		 for (int i = 0; i < argc; i++) {
		     
		     if (args[i].equals(""-stdin"")) {
		 		 
		 		 if ((++i >= argc) || (args[i].startsWith(""-""))) {
		 		     System.err.println(ERRMSG);
		 		     doSystemExit(systemExitOK);
		 		 }
		 		 try {
		 		     input = new FileInputStream(args[i]);
		 		 }
		 		 catch (FileNotFoundException e) {
		 		     System.err.println(""Could not open file ""+args[i]);
		 		     doSystemExit(systemExitOK);
		 		 }
		 		 catch (SecurityException e) {
		 		     System.err.println(""No permission to file ""+args[i]);
		 		     doSystemExit(systemExitOK);
		 		 }
		     }
		     else {
		 		 if (new_argc == new_args.length) {
		 		     System.err.println(""Missing -stdin option!"");
		 		     doSystemExit(systemExitOK);
		 		 }
		 		 new_args[new_argc++] = args[i];
		     }
		 }

		 System.setIn(input);
		 try {
		     java_cup.Main.main(new_args);
		 }
		 catch (Exception e) {
		     System.err.println(""Error running JavaCUP:"");
		     e.printStackTrace();
		     doSystemExit(systemExitOK);
		 }
    }
    public static void doSystemExit (boolean doExit) {
        if (doExit)
            System.exit(-1);
    }
}"
org.apache.xalan.xsltc.compiler.KeyPattern,1,6,0,1,2,0,0,1,1,2.0,6,0.0,0,1.0,1.0,0,0,5.0,0,0.0,0,"

package org.apache.xalan.xsltc.compiler;

final class KeyPattern extends IdKeyPattern {

    public KeyPattern(String index, String value) {
	super(index,value);
    }    

}
"
org.apache.xpath.axes.ChildTestIterator,7,6,5,12,15,1,7,6,5,0.333333333,75,1.0,1,0.962406015,0.342857143,2,5,9.571428571,2,1.0,1,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.compiler.Compiler;


public class ChildTestIterator extends BasicTestIterator
{
  
  transient protected DTMAxisTraverser m_traverser;
  
  



  
  ChildTestIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis);
  }
  
  
  public ChildTestIterator(DTMAxisTraverser traverser)
  {

    super(null);

    m_traverser = traverser;
  }

  
  protected int getNextNode()
  {                     
    if(true )
    {
      m_lastFetched = (DTM.NULL == m_lastFetched)
                   ? m_traverser.first(m_context)
                   : m_traverser.next(m_context, m_lastFetched);
    }








    return m_lastFetched;
  }

  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    ChildTestIterator clone = (ChildTestIterator) super.cloneWithReset();
    clone.m_traverser = m_traverser;

    return clone;
  }
  

  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    m_traverser = m_cdtm.getAxisTraverser(Axis.CHILD);
    

















    
  }
  
  
  public int getAxis()
  {
    return org.apache.xml.dtm.Axis.CHILD;
  }

  
  public void detach()
  {   
    if(m_allowDetach)
    {
      m_traverser = null;
      
      
      super.detach();
    }
  }

}
"
org.apache.xml.utils.res.XResourceBundleBase,3,3,0,0,4,3,0,0,3,2.0,6,0.0,0,0.95,0.833333333,0,0,1.0,1,0.6667,1,"
package org.apache.xml.utils.res;

import java.util.ListResourceBundle;


abstract public class XResourceBundleBase extends ListResourceBundle
{

  
  abstract public String getMessageKey(int errorCode);

  
  abstract public String getWarningKey(int errorCode);
}
"
org.apache.xalan.templates.ElemIf,8,3,0,13,27,0,0,13,7,0.285714286,117,1.0,1,0.965517241,0.270833333,2,5,13.5,2,1.0,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;


public class ElemIf extends ElemTemplateElement
{

  
  private XPath m_test = null;

  
  public void setTest(XPath v)
  {
    m_test = v;
  }

  
  public XPath getTest()
  {
    return m_test;
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {

    super.compose(sroot);

    java.util.Vector vnames = sroot.getComposeState().getVariableNames();

    if (null != m_test)
      m_test.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_IF;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_IF_STRING;
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    XPathContext xctxt = transformer.getXPathContext();
    int sourceNode = xctxt.getCurrentNode();

    if (TransformerImpl.S_DEBUG)
    {
      XObject test = m_test.execute(xctxt, sourceNode, this);

      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                ""test"", m_test, test);

      if (test.bool())
      {
      	
      	
      	
      	
        
        

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(this);

        transformer.executeChildTemplates(this, true);
        
        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEndEvent(this);
      }

      
      
      
      
    }
    else if (m_test.bool(xctxt, sourceNode, this))
    {
      transformer.executeChildTemplates(this, true);
    }
    
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  		m_test.getExpression().callVisitors(m_test, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xalan.xsltc.dom.DOMAdapter,55,1,0,12,112,0,5,7,51,0.831481481,576,1.0,3,0.0,0.214141414,0,0,9.290909091,5,1.4182,1,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.StripFilter;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.Hashtable;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.serializer.SerializationHandler;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public final class DOMAdapter implements DOM {

    
    private SAXImpl _saxImpl;

    private DOM _dom;

    private String[] _namesArray;
    private String[] _namespaceArray;

    
    private short[] _mapping = null;
    private int[]   _reverse = null;
    private short[] _NSmapping = null;
    private short[] _NSreverse = null;

    private StripFilter _filter = null;

    private int _multiDOMMask;
    
    public DOMAdapter(DOM dom,
                      String[] namesArray,
                      String[] namespaceArray) {
        if (dom instanceof SAXImpl){
            _saxImpl = (SAXImpl) dom;
        }

        _dom = dom;
        _namesArray = namesArray;
        _namespaceArray = namespaceArray;
    }

    public void setupMapping(String[] names, String[] namespaces) {
        _namesArray = names;
        _namespaceArray = namespaces;
    }
    
    public String[] getNamesArray() {
        return _namesArray;
    }
    
    public String[] getNamespaceArray() {
        return _namespaceArray;
    }
    
    public DOM getDOMImpl() {
    	return _dom;
    }

    private short[] getMapping() {
        if (_mapping == null) {
            if (_saxImpl != null) {
                _mapping = _saxImpl.getMapping(_namesArray);
            } 
        }
        return _mapping;
    }

    private int[] getReverse() {
	if (_reverse == null) {
            if (_saxImpl != null) {
	        _reverse = _saxImpl.getReverseMapping(_namesArray);
            }
	}
	return _reverse;
    }

    private short[] getNSMapping() {
	if (_NSmapping == null) {
            if (_saxImpl != null) {
	        _NSmapping = _saxImpl.getNamespaceMapping(_namespaceArray);
            }
	}
	return _NSmapping;
    }

    private short[] getNSReverse() {
	if (_NSreverse == null) {
            if (_saxImpl != null) {
	        _NSreverse = _saxImpl.getReverseNamespaceMapping(_namespaceArray);
            }
	}
	return _NSreverse;
    }

    
    public DTMAxisIterator getIterator() {
        return _dom.getIterator();
    }
    
    public String getStringValue() {
        return _dom.getStringValue();
    }
    
    public DTMAxisIterator getChildren(final int node) {
        if (_saxImpl != null) {
            return _saxImpl.getChildren(node);
        }
        else {
            DTMAxisIterator iterator = _dom.getChildren(node);
            return iterator.setStartNode(node);
        }
    }

    public void setFilter(StripFilter filter) {
	_filter = filter;
    }

    public DTMAxisIterator getTypedChildren(final int type) {
        final int[] reverse = getReverse();

        if (_saxImpl != null) {
            return _saxImpl.getTypedChildren(reverse[type]);
        }
        else {
            return _dom.getTypedChildren(type);
        }      
    }

    public DTMAxisIterator getNamespaceAxisIterator(final int axis,
                                                    final int ns) {
        return _dom.getNamespaceAxisIterator(axis, getNSReverse()[ns]);
    }

    public DTMAxisIterator getAxisIterator(final int axis) {
        if (_saxImpl != null) {
            return _saxImpl.getAxisIterator(axis);
        }
        else {
            return _dom.getAxisIterator(axis);
        }        
    }
    
    public DTMAxisIterator getTypedAxisIterator(final int axis,
                                                final int type) {
        final int[] reverse = getReverse();

        if (axis == Axis.NAMESPACE) {
            short[] NSReverse = getNSReverse();
            if (type == NO_TYPE || type > NSReverse.length) {
                return _dom.getAxisIterator(axis);
            } else {
                return _dom.getTypedAxisIterator(axis, NSReverse[type]);
            }
        } else if (_saxImpl != null) {
            return _saxImpl.getTypedAxisIterator(axis, reverse[type]);
        } else {
            return _dom.getTypedAxisIterator(axis, type);
        }      
    }
        
    public int getMultiDOMMask() {
	return _multiDOMMask;
    }

    public void setMultiDOMMask(int mask) {
	_multiDOMMask = mask;
    }

    public DTMAxisIterator getNthDescendant(int type, int n,
                                            boolean includeself) {
        return _dom.getNthDescendant(getReverse()[type], n, includeself);
    }

    public DTMAxisIterator getNodeValueIterator(DTMAxisIterator iterator,
                                                int type, String value,
                                                boolean op) {
        return _dom.getNodeValueIterator(iterator, type, value, op);
    }

    public DTMAxisIterator orderNodes(DTMAxisIterator source, int node) {
        return _dom.orderNodes(source, node);
    }
    
    public int getExpandedTypeID(final int node) {
        if (_saxImpl != null) {
            return getMapping()[_saxImpl.getExpandedTypeID2(node)];
        }
        else {
            return getMapping()[_dom.getExpandedTypeID(node)];
        }
    }

    public int getNamespaceType(final int node) {
    	return getNSMapping()[_dom.getNSType(node)];
    }

    public int getNSType(int node) {
	return _dom.getNSType(node);
    }
    
    public int getParent(final int node) {
        return _dom.getParent(node);
    }

    public int getAttributeNode(final int type, final int element) {
	return _dom.getAttributeNode(getReverse()[type], element);
    }
    
    public String getNodeName(final int node) {
    	if (node == DTM.NULL) {
    	    return """";
    	}
        return _dom.getNodeName(node);
    }
    
    public String getNodeNameX(final int node) 
    {
    	if (node == DTM.NULL) {
    	    return """";
    	}
        return _dom.getNodeNameX(node);
    }

    public String getNamespaceName(final int node) 
    {
    	if (node == DTM.NULL) {
    	    return """";
    	}
        return _dom.getNamespaceName(node);
    }
    
    public String getStringValueX(final int node) 
    {    	
    	if (_saxImpl != null) {
            return _saxImpl.getStringValueX(node);
        }
        else {
            if (node == DTM.NULL) {
    	        return """";
    	    }
            return _dom.getStringValueX(node);
        }
    }
    
    public void copy(final int node, SerializationHandler handler)
	throws TransletException 
    {
        _dom.copy(node, handler);
    }
    
    public void copy(DTMAxisIterator nodes,SerializationHandler handler)
	throws TransletException 
    {
	_dom.copy(nodes, handler);
    }

    public String shallowCopy(final int node, SerializationHandler handler)
	throws TransletException 
    {
        if (_saxImpl != null) {
            return _saxImpl.shallowCopy(node, handler);
        }
        else {
            return _dom.shallowCopy(node, handler);
        }
    }
    
    public boolean lessThan(final int node1, final int node2) 
    {
        return _dom.lessThan(node1, node2);
    }
    
    public void characters(final int textNode, SerializationHandler handler)
      throws TransletException 
    {
        if (_saxImpl != null) {
            _saxImpl.characters(textNode, handler);
        }
        else {
            _dom.characters(textNode, handler);
        }
    }

    public Node makeNode(int index) 
    {
        return _dom.makeNode(index);
    }

    public Node makeNode(DTMAxisIterator iter) 
    {
        return _dom.makeNode(iter);
    }

    public NodeList makeNodeList(int index) 
    {
        return _dom.makeNodeList(index);
    }

    public NodeList makeNodeList(DTMAxisIterator iter) 
    {
        return _dom.makeNodeList(iter);
    }

    public String getLanguage(int node) 
    {
        return _dom.getLanguage(node);
    }

    public int getSize() 
    {
        return _dom.getSize();
    }

    public void setDocumentURI(String uri) 
    {
        if (_saxImpl != null) {
            _saxImpl.setDocumentURI(uri);
        }
    }

    public String getDocumentURI()
    {
        if (_saxImpl != null) {
            return _saxImpl.getDocumentURI();
        }
        else {
            return """";
        }
    }

    public String getDocumentURI(int node) 
    {
        return _dom.getDocumentURI(node);
    }

    public int getDocument() 
    {
        return _dom.getDocument();
    }

    public boolean isElement(final int node) 
    {
        return(_dom.isElement(node));
    }

    public boolean isAttribute(final int node) 
    {
        return(_dom.isAttribute(node));
    }
    
    public int getNodeIdent(int nodeHandle)
    {
    	return _dom.getNodeIdent(nodeHandle);
    }
    
    public int getNodeHandle(int nodeId)
    {
    	return _dom.getNodeHandle(nodeId);
    }
    
     
    public DOM getResultTreeFrag(int initSize, int rtfType)
    {
    	if (_saxImpl != null) {
    	    return _saxImpl.getResultTreeFrag(initSize, rtfType);
    	}
    	else {
    	    return _dom.getResultTreeFrag(initSize, rtfType);
    	}
    }
    
    
    public SerializationHandler getOutputDomBuilder()
    {
    	return _dom.getOutputDomBuilder();
    }

    public String lookupNamespace(int node, String prefix) 
	throws TransletException 
    {
	return _dom.lookupNamespace(node, prefix);
    }

    public String getUnparsedEntityURI(String entity) {
        return _dom.getUnparsedEntityURI(entity);
    }

    public Hashtable getElementsWithIDs() {
        return _dom.getElementsWithIDs();
    }
}
"
org.apache.xml.dtm.ref.dom2dtm.DOM2DTMdefaultNamespaceDeclarationNode,46,1,0,3,53,1009,2,1,45,0.966666667,245,0.0,0,0.0,0.190217391,0,0,4.195652174,1,0.9783,0,"

package org.apache.xml.dtm.ref.dom2dtm;

import org.apache.xml.dtm.DTMException;

import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public class DOM2DTMdefaultNamespaceDeclarationNode implements Attr
{
  final String NOT_SUPPORTED_ERR=""Unsupported operation on pseudonode"";
  
  Element pseudoparent;
  String prefix,uri,nodename;
  int handle;
  DOM2DTMdefaultNamespaceDeclarationNode(Element pseudoparent,String prefix,String uri,int handle)
  {
    this.pseudoparent=pseudoparent;
    this.prefix=prefix;
    this.uri=uri;
    this.handle=handle;
    this.nodename=""xmlns:""+prefix;
  }
  public String getNodeName() {return nodename;}
  public String getName() {return nodename;}
  public String getNamespaceURI() {return ""http:
  public String getPrefix() {return prefix;}
  public String getLocalName() {return prefix;}
  public String getNodeValue() {return uri;}
  public String getValue() {return uri;}
  public Element getOwnerElement() {return pseudoparent;}
  
  public boolean isSupported(String feature, String version) {return false;}
  public boolean hasChildNodes() {return false;}
  public boolean hasAttributes() {return false;}
  public Node getParentNode() {return null;}
  public Node getFirstChild() {return null;}
  public Node getLastChild() {return null;}
  public Node getPreviousSibling() {return null;}
  public Node getNextSibling() {return null;}
  public boolean getSpecified() {return false;}
  public void normalize() {return;}
  public NodeList getChildNodes() {return null;}
  public NamedNodeMap getAttributes() {return null;}
  public short getNodeType() {return Node.ATTRIBUTE_NODE;}
  public void setNodeValue(String value) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public void setValue(String value) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public void setPrefix(String value) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Node insertBefore(Node a, Node b) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Node replaceChild(Node a, Node b) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Node appendChild(Node a) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Node removeChild(Node a) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Document getOwnerDocument() {return pseudoparent.getOwnerDocument();}
  public Node cloneNode(boolean deep) {throw new DTMException(NOT_SUPPORTED_ERR);}
	
	
	public int getHandleOfNode()		
	{
		return handle;
	}
}

"
org.apache.xml.utils.XMLCharacterRecognizer,5,1,0,7,10,10,7,0,5,2.0,85,0.0,0,0.0,0.2,0,0,16.0,5,3.0,1,"
package org.apache.xml.utils;


public class XMLCharacterRecognizer
{

  
  public static boolean isWhiteSpace(char ch)
  {
    return (ch == 0x20) || (ch == 0x09) || (ch == 0xD) || (ch == 0xA);
  }

  
  public static boolean isWhiteSpace(char ch[], int start, int length)
  {

    int end = start + length;

    for (int s = start; s < end; s++)
    {
      if (!isWhiteSpace(ch[s]))
        return false;
    }

    return true;
  }

  
  public static boolean isWhiteSpace(StringBuffer buf)
  {

    int n = buf.length();

    for (int i = 0; i < n; i++)
    {
      if (!isWhiteSpace(buf.charAt(i)))
        return false;
    }

    return true;
  }
  
  
  public static boolean isWhiteSpace(String s)
  {

    if(null != s)
    {
      int n = s.length();
  
      for (int i = 0; i < n; i++)
      {
        if (!isWhiteSpace(s.charAt(i)))
          return false;
      }
    }

    return true;
  }

}
"
org.apache.xml.dtm.ref.DTMTreeWalker,10,1,1,6,41,0,3,3,7,0.333333333,437,0.666666667,1,0.0,0.475,0,0,42.4,1,0.8,1,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.NodeConsumer;
import org.apache.xml.utils.XMLString;

import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;


public class DTMTreeWalker
{

  
  private ContentHandler m_contentHandler = null;

  
  protected DTM m_dtm;
  
  
  public void setDTM(DTM dtm)
  {
    m_dtm = dtm;
  }

  
  public ContentHandler getcontentHandler()
  {
    return m_contentHandler;
  }
  
  
  public void setcontentHandler(ContentHandler ch)
  {
    m_contentHandler = ch;
  }

  
  
  public DTMTreeWalker()
  {
  }
  
  
  public DTMTreeWalker(ContentHandler contentHandler, DTM dtm)
  {
    this.m_contentHandler = contentHandler;
    m_dtm = dtm;
  }
  
  
  public void traverse(int pos) throws org.xml.sax.SAXException
  {
    

    int top = pos;		

    while (DTM.NULL != pos)
    {
      startNode(pos);
      int nextNode = m_dtm.getFirstChild(pos);
      while (DTM.NULL == nextNode)
      {
        endNode(pos);

        if (top == pos)
          break;

        nextNode = m_dtm.getNextSibling(pos);

        if (DTM.NULL == nextNode)
        {
          pos = m_dtm.getParent(pos);

          if ((DTM.NULL == pos) || (top == pos))
          {
            
            
            if (DTM.NULL != pos)
              endNode(pos);

            nextNode = DTM.NULL;

            break;
          }
        }
      }

      pos = nextNode;
    }
  }

  
  public void traverse(int pos, int top) throws org.xml.sax.SAXException
  {
    
    
    
    

    while (DTM.NULL != pos)
    {
      startNode(pos);
      int nextNode = m_dtm.getFirstChild(pos);
      while (DTM.NULL == nextNode)
      {
        endNode(pos);

        if ((DTM.NULL != top) && top == pos)
          break;

        nextNode = m_dtm.getNextSibling(pos);

        if (DTM.NULL == nextNode)
        {
          pos = m_dtm.getParent(pos);

          if ((DTM.NULL == pos) || ((DTM.NULL != top) && (top == pos)))
          {
            nextNode = DTM.NULL;

            break;
          }
        }
      }

      pos = nextNode;
    }
  }

  
  boolean nextIsRaw = false;
  
  
  private final void dispatachChars(int node)
     throws org.xml.sax.SAXException
  {
    m_dtm.dispatchCharactersEvents(node, m_contentHandler, false);
  }

  
  protected void startNode(int node) throws org.xml.sax.SAXException
  {

    if (m_contentHandler instanceof NodeConsumer)
    {
      

    }

    switch (m_dtm.getNodeType(node))
    {
    case DTM.COMMENT_NODE :
    {
      XMLString data = m_dtm.getStringValue(node);

      if (m_contentHandler instanceof LexicalHandler)
      {
        LexicalHandler lh = ((LexicalHandler) this.m_contentHandler);
        data.dispatchAsComment(lh);
      }
    }
    break;
    case DTM.DOCUMENT_FRAGMENT_NODE :

      
      break;
    case DTM.DOCUMENT_NODE :
      this.m_contentHandler.startDocument();
      break;
    case DTM.ELEMENT_NODE :
      DTM dtm = m_dtm;           

      for (int nsn = dtm.getFirstNamespaceNode(node, true); DTM.NULL != nsn;
           nsn = dtm.getNextNamespaceNode(node, nsn, true))
      {
        
        String prefix = dtm.getNodeNameX(nsn);

        this.m_contentHandler.startPrefixMapping(prefix, dtm.getNodeValue(nsn));
        
      }

      
      
      String ns = dtm.getNamespaceURI(node);
      if(null == ns)
        ns = """";
        
      
      org.xml.sax.helpers.AttributesImpl attrs = 
                            new org.xml.sax.helpers.AttributesImpl();
              
      for (int i = dtm.getFirstAttribute(node); 
           i != DTM.NULL; 
           i = dtm.getNextAttribute(i)) 
      {
        attrs.addAttribute(dtm.getNamespaceURI(i), 
                           dtm.getLocalName(i), 
                           dtm.getNodeName(i), 
                           ""CDATA"", 
                           dtm.getNodeValue(i));
      }
      
        
      this.m_contentHandler.startElement(ns,
                                         m_dtm.getLocalName(node),
                                         m_dtm.getNodeName(node),
                                         attrs);
      break;
    case DTM.PROCESSING_INSTRUCTION_NODE :
    {
      String name = m_dtm.getNodeName(node);

      
      if (name.equals(""xslt-next-is-raw""))
      {
        nextIsRaw = true;
      }
      else
      {
        this.m_contentHandler.processingInstruction(name,
                                                    m_dtm.getNodeValue(node));
      }
    }
    break;
    case DTM.CDATA_SECTION_NODE :
    {
      boolean isLexH = (m_contentHandler instanceof LexicalHandler);
      LexicalHandler lh = isLexH
                          ? ((LexicalHandler) this.m_contentHandler) : null;

      if (isLexH)
      {
        lh.startCDATA();
      }
      
      dispatachChars(node);

      {
        if (isLexH)
        {
          lh.endCDATA();
        }
      }
    }
    break;
    case DTM.TEXT_NODE :
    {
      if (nextIsRaw)
      {
        nextIsRaw = false;

        m_contentHandler.processingInstruction(javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");
        dispatachChars(node);
        m_contentHandler.processingInstruction(javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");
      }
      else
      {
        dispatachChars(node);
      }
    }
    break;
    case DTM.ENTITY_REFERENCE_NODE :
    {
      if (m_contentHandler instanceof LexicalHandler)
      {
        ((LexicalHandler) this.m_contentHandler).startEntity(
          m_dtm.getNodeName(node));
      }
      else
      {

        
      }
    }
    break;
    default :
    }
  }

  
  protected void endNode(int node) throws org.xml.sax.SAXException
  {

    switch (m_dtm.getNodeType(node))
    {
    case DTM.DOCUMENT_NODE :
      this.m_contentHandler.endDocument();
      break;
    case DTM.ELEMENT_NODE :
      String ns = m_dtm.getNamespaceURI(node);
      if(null == ns)
        ns = """";
      this.m_contentHandler.endElement(ns,
                                         m_dtm.getLocalName(node),
                                         m_dtm.getNodeName(node));

      for (int nsn = m_dtm.getFirstNamespaceNode(node, true); DTM.NULL != nsn;
           nsn = m_dtm.getNextNamespaceNode(node, nsn, true))
      {
        
        String prefix = m_dtm.getNodeNameX(nsn);

        this.m_contentHandler.endPrefixMapping(prefix);
      }
      break;
    case DTM.CDATA_SECTION_NODE :
      break;
    case DTM.ENTITY_REFERENCE_NODE :
    {
      if (m_contentHandler instanceof LexicalHandler)
      {
        LexicalHandler lh = ((LexicalHandler) this.m_contentHandler);

        lh.endEntity(m_dtm.getNodeName(node));
      }
    }
    break;
    default :
    }
  }
}  

"
org.apache.xalan.xsltc.dom.MultipleNodeCounter,4,2,1,6,19,0,1,6,4,0.333333333,164,1.0,1,0.823529412,0.5,1,4,39.75,11,3.25,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.util.IntegerArray;
import org.apache.xml.dtm.DTMAxisIterator;

public abstract class MultipleNodeCounter extends NodeCounter {
    private DTMAxisIterator _precSiblings = null;

    public MultipleNodeCounter(Translet translet,
			       DOM document, DTMAxisIterator iterator) {
	super(translet, document, iterator);
    }
	
    public NodeCounter setStartNode(int node) {
	_node = node;
	_nodeType = _document.getExpandedTypeID(node);
	_precSiblings = _document.getAxisIterator(PRECEDINGSIBLING);
	return this;
    }

    public String getCounter() {
	if (_value != Integer.MIN_VALUE) {
	    return formatNumbers(_value);
	}

	IntegerArray ancestors = new IntegerArray();

	
	int next = _node;
	ancestors.add(next);		
	while ((next = _document.getParent(next)) > END && 
	       !matchesFrom(next)) {
	    ancestors.add(next);
	}

	
	final int nAncestors = ancestors.cardinality();
	final int[] counters = new int[nAncestors]; 
	for (int i = 0; i < nAncestors; i++) {
	    counters[i] = Integer.MIN_VALUE;
	}

	
	for (int j = 0, i = nAncestors - 1; i >= 0 ; i--, j++) {
	    final int counter = counters[j];
	    final int ancestor = ancestors.at(i);

	    if (matchesCount(ancestor)) {
		_precSiblings.setStartNode(ancestor);
		while ((next = _precSiblings.next()) != END) {
		    if (matchesCount(next)) {
			counters[j] = (counters[j] == Integer.MIN_VALUE) ? 1 
			    : counters[j] + 1;		
		    }
		}
		
		counters[j] = counters[j] == Integer.MIN_VALUE
		    ? 1 
		    : counters[j] + 1;	
	    }
	}
	return formatNumbers(counters);
    }

    public static NodeCounter getDefaultNodeCounter(Translet translet,
						    DOM document,
						    DTMAxisIterator iterator) {
	return new DefaultMultipleNodeCounter(translet, document, iterator);
    }

    static class DefaultMultipleNodeCounter extends MultipleNodeCounter {
	public DefaultMultipleNodeCounter(Translet translet,
					  DOM document,
					  DTMAxisIterator iterator) {
	    super(translet, document, iterator);
	}
    }
}
"
org.apache.xalan.transformer.ClonerToResultTree,2,1,0,7,24,1,3,4,2,2.0,109,0.0,0,0.0,0.5,0,0,53.5,1,0.5,1,"
package org.apache.xalan.transformer;

import javax.xml.transform.TransformerException;

import org.apache.xalan.serialize.SerializerUtils;
import org.apache.xml.dtm.DTM;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.utils.XMLString;


public class ClonerToResultTree
{



















































































  
  
  public static void cloneToResultTree(int node, int nodeType, DTM dtm, 
                                             SerializationHandler rth,
                                             boolean shouldCloneAttributes)
    throws TransformerException
  {

    try
    {
      switch (nodeType)
      {
      case DTM.TEXT_NODE :
        dtm.dispatchCharactersEvents(node, rth, false);
        break;
      case DTM.DOCUMENT_FRAGMENT_NODE :
      case DTM.DOCUMENT_NODE :
        
        
        break;
      case DTM.ELEMENT_NODE :
        {
          
          
          String ns = dtm.getNamespaceURI(node);
          if (ns==null) ns="""";
          String localName = dtm.getLocalName(node);
      
      
      
          rth.startElement(ns, localName, dtm.getNodeNameX(node));
          
	  
	  
	  
          if (shouldCloneAttributes)
          {
            SerializerUtils.addAttributes(rth, node);
            SerializerUtils.processNSDecls(rth, node, nodeType, dtm);
          }
        }
        break;
      case DTM.CDATA_SECTION_NODE :
        rth.startCDATA();          
        dtm.dispatchCharactersEvents(node, rth, false);
        rth.endCDATA();
        break;
      case DTM.ATTRIBUTE_NODE :
        SerializerUtils.addAttribute(rth, node);
        break;
			case DTM.NAMESPACE_NODE:
				
				
				
				
  			    SerializerUtils.processNSDecls(rth,node,DTM.NAMESPACE_NODE,dtm);
				break;
      case DTM.COMMENT_NODE :
        XMLString xstr = dtm.getStringValue (node);
        xstr.dispatchAsComment(rth);
        break;
      case DTM.ENTITY_REFERENCE_NODE :
        rth.entityReference(dtm.getNodeNameX(node));
        break;
      case DTM.PROCESSING_INSTRUCTION_NODE :
        {
          
          rth.processingInstruction(dtm.getNodeNameX(node), 
                                      dtm.getNodeValue(node));
        }
        break;
      default :
        
        throw new  TransformerException(
                         ""Can't clone node: ""+dtm.getNodeName(node));
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }  
}
"
org.w3c.dom.xpath.XPathResult,9,1,0,0,9,36,0,0,9,1.125,19,0.0,0,0.0,0.555555556,0,0,0.0,1,1.0,0,"

package org.w3c.dom.xpath;


import org.w3c.dom.Node;
import org.w3c.dom.DOMException;


public interface XPathResult {
    
    
    public static final short ANY_TYPE                  = 0;
    
    public static final short NUMBER_TYPE               = 1;
    
    public static final short STRING_TYPE               = 2;
    
    public static final short BOOLEAN_TYPE              = 3;
    
    public static final short UNORDERED_NODE_ITERATOR_TYPE = 4;
    
    public static final short ORDERED_NODE_ITERATOR_TYPE = 5;
    
    public static final short UNORDERED_NODE_SNAPSHOT_TYPE = 6;
    
    public static final short ORDERED_NODE_SNAPSHOT_TYPE = 7;
    
    public static final short ANY_UNORDERED_NODE_TYPE   = 8;
    
    public static final short FIRST_ORDERED_NODE_TYPE   = 9;

    
    public short getResultType();

    
    public double getNumberValue()
                             throws XPathException;

    
    public String getStringValue()
                             throws XPathException;

    
    public boolean getBooleanValue()
                             throws XPathException;

    
    public Node getSingleNodeValue()
                             throws XPathException;

    
    public boolean getInvalidIteratorState();

    
    public int getSnapshotLength()
                             throws XPathException;

    
    public Node iterateNext()
                            throws XPathException, DOMException;

    
    public Node snapshotItem(int index)
                             throws XPathException;

}
"
org.apache.xml.utils.PrefixResolverDefault,5,1,1,5,17,8,4,1,5,0.75,107,0.0,0,0.0,0.6,0,0,20.2,12,3.0,2,"
package org.apache.xml.utils;

import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;


public class PrefixResolverDefault implements PrefixResolver
{

  
  Node m_context;

  
  public PrefixResolverDefault(Node xpathExpressionContext)
  {
    m_context = xpathExpressionContext;
  }

  
  public String getNamespaceForPrefix(String prefix)
  {
    return getNamespaceForPrefix(prefix, m_context);
  }

  
  public String getNamespaceForPrefix(String prefix,
                                      org.w3c.dom.Node namespaceContext)
  {

    Node parent = namespaceContext;
    String namespace = null;

    if (prefix.equals(""xml""))
    {
      namespace = Constants.S_XMLNAMESPACEURI;
    }
    else
    {
      int type;

      while ((null != parent) && (null == namespace)
             && (((type = parent.getNodeType()) == Node.ELEMENT_NODE)
                 || (type == Node.ENTITY_REFERENCE_NODE)))
      {
        if (type == Node.ELEMENT_NODE)
        {
          NamedNodeMap nnm = parent.getAttributes();

          for (int i = 0; i < nnm.getLength(); i++)
          {
            Node attr = nnm.item(i);
            String aname = attr.getNodeName();
            boolean isPrefix = aname.startsWith(""xmlns:"");

            if (isPrefix || aname.equals(""xmlns""))
            {
              int index = aname.indexOf(':');
              String p = isPrefix ? aname.substring(index + 1) : """";

              if (p.equals(prefix))
              {
                namespace = attr.getNodeValue();

                break;
              }
            }
          }
        }

        parent = parent.getParentNode();
      }
    }

    return namespace;
  }

  
  public String getBaseIdentifier()
  {
    return null;
  }
	
	public boolean handlesNullPrefixes() {
		return false;
	}

}
"
org.apache.xalan.lib.ExsltStrings,11,2,0,3,38,49,0,3,10,0.6,402,1.0,1,0.181818182,0.275,0,0,35.36363636,6,2.5455,2,"
package org.apache.xalan.lib;

import java.util.StringTokenizer;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.xpath.NodeSet;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;


public class ExsltStrings extends ExsltBase
{
  
  private static Document m_doc = null;
  private static ExsltStrings m_instance = new ExsltStrings();

  
  public static String align(String targetStr, String paddingStr, String type)
  {
    if (targetStr.length() >= paddingStr.length())
      return targetStr.substring(0, paddingStr.length());
    
    if (type.equals(""right""))
    {
      return paddingStr.substring(0, paddingStr.length() - targetStr.length()) + targetStr;
    }
    else if (type.equals(""center""))
    {
      int startIndex = (paddingStr.length() - targetStr.length()) / 2;
      return paddingStr.substring(0, startIndex) + targetStr + paddingStr.substring(startIndex + targetStr.length());
    }
    
    else
    {
      return targetStr + paddingStr.substring(paddingStr.length() - targetStr.length());
    }    
  }

  
  public static String align(String targetStr, String paddingStr)
  {
    return align(targetStr, paddingStr, ""left"");
  }
  
  
  public static String concat(NodeList nl)
  {
    StringBuffer sb = new StringBuffer();
    for (int i = 0; i < nl.getLength(); i++)
    {
      Node node = nl.item(i);
      String value = toString(node);
      
      if (value != null && value.length() > 0)
        sb.append(value);
    }
    
    return sb.toString();
  }
    
  
  public static String padding(double length, String pattern)
  {
    if (pattern == null || pattern.length() == 0)
      return """";
    
    StringBuffer sb = new StringBuffer();
    int len = (int)length;
    int numAdded = 0;
    int index = 0;
    while (numAdded < len)
    {
      if (index == pattern.length())
        index = 0;
        
      sb.append(pattern.charAt(index));
      index++;
      numAdded++;
    }
  
    return sb.toString();
  }

  
  public static String padding(double length)
  {
    return padding(length, "" "");
  }
    
  
  public static NodeList split(String str, String pattern)
  {
    try
    {
      
      if (m_doc == null)
      {
        synchronized (m_instance)
        {
          if (m_doc == null)
            m_doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
        }
      }
    }
    catch(ParserConfigurationException pce)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(pce);
    }
    
    NodeSet resultSet = new NodeSet();
    resultSet.setShouldCacheNodes(true);
    
    boolean done = false;
    int fromIndex = 0;
    int matchIndex = 0;
    String token = null;
    
    while (!done && fromIndex < str.length())
    {
      matchIndex = str.indexOf(pattern, fromIndex);
      if (matchIndex >= 0)
      {
	token = str.substring(fromIndex, matchIndex);
	fromIndex = matchIndex + pattern.length();
      }
      else
      {
        done = true;
        token = str.substring(fromIndex);
      }
        
      synchronized (m_doc)
      {
        Element element = m_doc.createElement(""token"");
        Text text = m_doc.createTextNode(token);
        element.appendChild(text);
        resultSet.addNode(element);      
      }
    }
    
    return resultSet;
  }
  
  
  public static NodeList split(String str)
  {
    return split(str, "" "");
  }

  
  public static NodeList tokenize(String toTokenize, String delims)
  {
    try
    {
      
      if (m_doc == null)
      {
        synchronized (m_instance)
        {
          if (m_doc == null)
            m_doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();
        }
      }
    }
    catch(ParserConfigurationException pce)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(pce);
    }

    NodeSet resultSet = new NodeSet();
    
    if (delims != null && delims.length() > 0)
    {
      StringTokenizer lTokenizer = new StringTokenizer(toTokenize, delims);

      synchronized (m_doc)
      {
        while (lTokenizer.hasMoreTokens())
        {
          Element element = m_doc.createElement(""token"");
          element.appendChild(m_doc.createTextNode(lTokenizer.nextToken()));
          resultSet.addNode(element);      
        }
      }
    }
    
    
    else
    {
      synchronized (m_doc)
      {
        for (int i = 0; i < toTokenize.length(); i++)
        {
          Element element = m_doc.createElement(""token"");
          element.appendChild(m_doc.createTextNode(toTokenize.substring(i, i+1)));
          resultSet.addNode(element);              
        }
      }
    }

    return resultSet;
  }

  
  public static NodeList tokenize(String toTokenize)
  {
    return tokenize(toTokenize, "" 	

"");
  }
  
}"
org.apache.xalan.xsltc.compiler.SourceLoader,1,1,0,6,1,0,6,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.xml.sax.InputSource;

public interface SourceLoader {

    
    public InputSource loadSource(String href, String context, XSLTC xsltc);

}
"
org.apache.xml.utils.SuballocatedByteVector,18,1,0,0,20,3,0,0,10,0.329411765,830,1.0,0,0.0,0.685185185,0,0,44.83333333,8,3.1111,1,"
package org.apache.xml.utils;


public class SuballocatedByteVector
{
  
  protected int m_blocksize;
  
  
  protected  int m_numblocks=32;
  
  
  protected byte m_map[][];

  
  protected int m_firstFree = 0;

  
  protected byte m_map0[];

  
  public SuballocatedByteVector()
  {
    this(2048);
  }

  
  public SuballocatedByteVector(int blocksize)
  {
    m_blocksize = blocksize;
    m_map0=new byte[blocksize];
    m_map = new byte[m_numblocks][];
    m_map[0]=m_map0;
  }
  
  
  public SuballocatedByteVector(int blocksize, int increaseSize)
  {
    
    this(blocksize);
  }


  
  public int size()
  {
    return m_firstFree;
  }
  
  
  private  void setSize(int sz)
  {
    if(m_firstFree<sz)
      m_firstFree = sz;
  }

  
  public  void addElement(byte value)
  {
    if(m_firstFree<m_blocksize)
      m_map0[m_firstFree++]=value;
    else
    {
      int index=m_firstFree/m_blocksize;
      int offset=m_firstFree%m_blocksize;
      ++m_firstFree;

      if(index>=m_map.length)
      {
        int newsize=index+m_numblocks;
        byte[][] newMap=new byte[newsize][];
        System.arraycopy(m_map, 0, newMap, 0, m_map.length);
        m_map=newMap;
      }
      byte[] block=m_map[index];
      if(null==block)
        block=m_map[index]=new byte[m_blocksize];
      block[offset]=value;
    }
  }
  
  
  private  void addElements(byte value, int numberOfElements)
  {
    if(m_firstFree+numberOfElements<m_blocksize)
      for (int i = 0; i < numberOfElements; i++) 
      {
        m_map0[m_firstFree++]=value;
      }
    else
    {
      int index=m_firstFree/m_blocksize;
      int offset=m_firstFree%m_blocksize;
      m_firstFree+=numberOfElements;
      while( numberOfElements>0)
      {
        if(index>=m_map.length)
        {
          int newsize=index+m_numblocks;
          byte[][] newMap=new byte[newsize][];
          System.arraycopy(m_map, 0, newMap, 0, m_map.length);
          m_map=newMap;
        }
        byte[] block=m_map[index];
        if(null==block)
          block=m_map[index]=new byte[m_blocksize];
        int copied=(m_blocksize-offset < numberOfElements)
          ? m_blocksize-offset : numberOfElements;
        numberOfElements-=copied;
        while(copied-- > 0)
          block[offset++]=value;

        ++index;offset=0;
      }
    }
  }
  
  
  private  void addElements(int numberOfElements)
  {
    int newlen=m_firstFree+numberOfElements;
    if(newlen>m_blocksize)
    {
      int index=m_firstFree%m_blocksize;
      int newindex=(m_firstFree+numberOfElements)%m_blocksize;
      for(int i=index+1;i<=newindex;++i)
        m_map[i]=new byte[m_blocksize];
    }
    m_firstFree=newlen;
  }
  
  
  private  void insertElementAt(byte value, int at)
  {
    if(at==m_firstFree)
      addElement(value);
    else if (at>m_firstFree)
    {
      int index=at/m_blocksize;
      if(index>=m_map.length)
      {
        int newsize=index+m_numblocks;
        byte[][] newMap=new byte[newsize][];
        System.arraycopy(m_map, 0, newMap, 0, m_map.length);
        m_map=newMap;
      }
      byte[] block=m_map[index];
      if(null==block)
        block=m_map[index]=new byte[m_blocksize];
      int offset=at%m_blocksize;
      block[offset]=value;
      m_firstFree=offset+1;
    }
    else
    {
      int index=at/m_blocksize;
      int maxindex=m_firstFree+1/m_blocksize;
      ++m_firstFree;
      int offset=at%m_blocksize;
      byte push;
      
      
      while(index<=maxindex)
      {
        int copylen=m_blocksize-offset-1;
        byte[] block=m_map[index];
        if(null==block)
        {
          push=0;
          block=m_map[index]=new byte[m_blocksize];
        }
        else
        {
          push=block[m_blocksize-1];
          System.arraycopy(block, offset , block, offset+1, copylen);
        }
        block[offset]=value;
        value=push;
        offset=0;
        ++index;
      }
    }
  }

  
  public void removeAllElements()
  {
    m_firstFree = 0;
  }

  
  private  boolean removeElement(byte s)
  {
    int at=indexOf(s,0);
    if(at<0)
      return false;
    removeElementAt(at);
    return true;
  }

  
  private  void removeElementAt(int at)
  {
    
    if(at<m_firstFree)
    {
      int index=at/m_blocksize;
      int maxindex=m_firstFree/m_blocksize;
      int offset=at%m_blocksize;
      
      while(index<=maxindex)
      {
        int copylen=m_blocksize-offset-1;
        byte[] block=m_map[index];
        if(null==block)
          block=m_map[index]=new byte[m_blocksize];
        else
          System.arraycopy(block, offset+1, block, offset, copylen);
        if(index<maxindex)
        {
          byte[] next=m_map[index+1];
          if(next!=null)
            block[m_blocksize-1]=(next!=null) ? next[0] : 0;
        }
        else
          block[m_blocksize-1]=0;
        offset=0;
        ++index;
      }
    }
    --m_firstFree;
  }

  
  public void setElementAt(byte value, int at)
  {
    if(at<m_blocksize)
    {
      m_map0[at]=value;
      return;
    }

    int index=at/m_blocksize;
    int offset=at%m_blocksize;
        
    if(index>=m_map.length)
    {
      int newsize=index+m_numblocks;
      byte[][] newMap=new byte[newsize][];
      System.arraycopy(m_map, 0, newMap, 0, m_map.length);
      m_map=newMap;
    }

    byte[] block=m_map[index];
    if(null==block)
      block=m_map[index]=new byte[m_blocksize];
    block[offset]=value;

    if(at>=m_firstFree)
      m_firstFree=at+1;
  }

  
  public byte elementAt(int i)
  {
    
    
    if(i<m_blocksize)
      return m_map0[i];

    return m_map[i/m_blocksize][i%m_blocksize];
  }

  
  private  boolean contains(byte s)
  {
    return (indexOf(s,0) >= 0);
  }

  
  public int indexOf(byte elem, int index)
  {
    if(index>=m_firstFree)
      return -1;
          
    int bindex=index/m_blocksize;
    int boffset=index%m_blocksize;
    int maxindex=m_firstFree/m_blocksize;
    byte[] block;
    
    for(;bindex<maxindex;++bindex)
    {
      block=m_map[bindex];
      if(block!=null)
        for(int offset=boffset;offset<m_blocksize;++offset)
          if(block[offset]==elem)
            return offset+bindex*m_blocksize;
      boffset=0; 
    }
    
    int maxoffset=m_firstFree%m_blocksize;
    block=m_map[maxindex];
    for(int offset=boffset;offset<maxoffset;++offset)
      if(block[offset]==elem)
        return offset+maxindex*m_blocksize;

    return -1;    
  }

  
  public int indexOf(byte elem)
  {
    return indexOf(elem,0);
  }

  
  private  int lastIndexOf(byte elem)
  {
    int boffset=m_firstFree%m_blocksize;
    for(int index=m_firstFree/m_blocksize;
        index>=0;
        --index)
    {
      byte[] block=m_map[index];
      if(block!=null)
        for(int offset=boffset; offset>=0; --offset)
          if(block[offset]==elem)
            return offset+index*m_blocksize;
      boffset=0; 
    }
    return -1;
  }

}
"
org.apache.xpath.operations.Lte,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class Lte extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.lessThanOrEqual(right) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.templates.Constants,1,2,0,1,2,0,0,1,1,2.0,338,0.0,0,0.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xalan.templates;



public class Constants extends org.apache.xml.utils.Constants
{

  
  public static final int ELEMNAME_UNDEFINED = -1, ELEMNAME_WITHPARAM = 2,
                          ELEMNAME_ADDATTRIBUTE = 4, ELEMNAME_ANCHOR = 22,

  
  ELEMNAME_APPLY_TEMPLATES = 50, ELEMNAME_USE = 34, ELEMNAME_CHILDREN = 6,
                                 ELEMNAME_CHOOSE = 37, ELEMNAME_COMMENT = 59,  
                                 ELEMNAME_CONSTRUCT = 7,  
                                 ELEMNAME_CONTENTS = 8, ELEMNAME_COPY = 9,
                                 ELEMNAME_COPY_OF = 74,
                                 ELEMNAME_DECIMALFORMAT = 83,
                                 ELEMNAME_DEFINEATTRIBUTESET = 40,

  
  
  ELEMNAME_DEFINESCRIPT = 11, ELEMNAME_DISPLAYIF = 12,  
                              ELEMNAME_EMPTY = 14, ELEMNAME_EVAL = 15,
                              ELEMNAME_EXPECTEDCHILDREN = 16,
                              ELEMNAME_EXTENSION = 54,
                              ELEMNAME_EXTENSIONHANDLER = 63,
                              ELEMNAME_FOREACH = 28, ELEMNAME_KEY = 31,
                              ELEMNAME_IF = 36, ELEMNAME_IMPORT = 26,
                              ELEMNAME_INCLUDE = 27,
                              ELEMNAME_CALLTEMPLATE = 17,
                              ELEMNAME_PARAMVARIABLE = 41,
                              ELEMNAME_NUMBER = 35, ELEMNAME_NSALIAS = 84,
                              ELEMNAME_OTHERWISE = 39, ELEMNAME_PI = 58,
                              ELEMNAME_PRESERVESPACE = 33,
                              ELEMNAME_REMOVEATTRIBUTE = 5,
                              ELEMNAME_TEMPLATE = 19, ELEMNAME_SORT = 64,
                              ELEMNAME_STRIPSPACE = 32,
                              ELEMNAME_STYLESHEET = 25, ELEMNAME_TEXT = 42,
                              ELEMNAME_VALUEOF = 30, ELEMNAME_WHEN = 38,

  
  ELEMNAME_ROOT = 44, ELEMNAME_ANY = 45, ELEMNAME_ELEMENT = 46,
                      ELEMNAME_TARGETELEMENT = 47, ELEMNAME_ATTRIBUTE = 48,
                      ELEMNAME_TARGETATTRIBUTE = 49, ELEMNAME_URL = 52,  
                      ELEMNAME_CALL = 55,  

  
  ELEMNAME_FALLBACK = 57,  
  ELEMNAME_TARGETPI = 60,  
  ELEMNAME_TARGETCOMMENT = 61,  
  ELEMNAME_TARGETTEXT = 62,  
  ELEMNAME_CSSSTYLECONVERSION = 65,  
  ELEMNAME_COUNTER = 66, ELEMNAME_COUNTERS = 67,
  ELEMNAME_COUNTERINCREMENT = 68, ELEMNAME_COUNTERRESET = 69,
  ELEMNAME_COUNTERSCOPE = 71, ELEMNAME_APPLY_IMPORTS = 72,
  ELEMNAME_VARIABLE = 73, ELEMNAME_MESSAGE = 75, ELEMNAME_LOCALE = 76,
  ELEMNAME_LITERALRESULT = 77, ELEMNAME_TEXTLITERALRESULT = 78,
  ELEMNAME_EXTENSIONCALL = 79, ELEMNAME_EXTENSIONDECL = 85,
  ELEMNAME_EXTENSIONSCRIPT = 86, ELEMNAME_OUTPUT = 80,
  ELEMNAME_COMPONENT = 81, ELEMNAME_SCRIPT = 82;

  

  
  public static final String       
	  ELEMNAME_ANCHOR_STRING = ""anchor"",
      ELEMNAME_ANY_STRING = ""any"",  
      ELEMNAME_APPLY_IMPORTS_STRING = ""apply-imports"",
      ELEMNAME_APPLY_TEMPLATES_STRING = ""apply-templates"",
      ELEMNAME_ARG_STRING = ""arg"",
      ELEMNAME_ATTRIBUTESET_STRING = ""attribute-set"",
      ELEMNAME_ATTRIBUTE_STRING = ""attribute"",  
      ELEMNAME_CALLTEMPLATEARG_STRING = ""invoke-arg"",
      ELEMNAME_CALLTEMPLATE_STRING = ""call-template"",
      ELEMNAME_CALL_STRING = ""call"",
      ELEMNAME_CHILDREN_STRING = ""children"",
      ELEMNAME_CHOOSE_STRING = ""choose"",
      ELEMNAME_COMMENT_STRING = ""comment"",
      ELEMNAME_COMPONENT_STRING = ""component"",
      ELEMNAME_CONSTRUCT_STRING = ""construct"",  
      ELEMNAME_CONTENTS_STRING = ""contents"", 
      ELEMNAME_COPY_OF_STRING =""copy-of"",
      ELEMNAME_COPY_STRING = ""copy"",
      ELEMNAME_COUNTERINCREMENT_STRING = ""counter-increment"",
      ELEMNAME_COUNTERRESET_STRING = ""counter-reset"",
      ELEMNAME_COUNTERSCOPE_STRING = ""counter-scope"",
      ELEMNAME_COUNTERS_STRING = ""counters"",
      ELEMNAME_COUNTER_STRING = ""counter"",
      ELEMNAME_CSSSTYLECONVERSION_STRING = ""css-style-conversion"",
      ELEMNAME_DECIMALFORMAT_STRING = ""decimal-format"",
      ELEMNAME_DISPLAYIF_STRING = ""display-if"",  
      ELEMNAME_ELEMENT_STRING = ""element"",  
      ELEMNAME_EMPTY_STRING = ""empty"",
      ELEMNAME_EVAL_STRING = ""eval"",
      ELEMNAME_EXPECTEDCHILDREN_STRING = ""expectedchildren"",
      ELEMNAME_EXTENSIONHANDLER_STRING = ""code-dispatcher"",
      ELEMNAME_EXTENSION_STRING = ""functions"",
      ELEMNAME_FALLBACK_STRING = ""fallback"",
      ELEMNAME_FOREACH_STRING = ""for-each"",
      ELEMNAME_IF_STRING = ""if"",
      ELEMNAME_IMPORT_STRING = ""import"",
      ELEMNAME_INCLUDE_STRING = ""include"",
      ELEMNAME_KEY_STRING = ""key"",
      ELEMNAME_LOCALE_STRING = ""locale"",
      ELEMNAME_MESSAGE_STRING = ""message"",
      ELEMNAME_NSALIAS_STRING = ""namespace-alias"",
      ELEMNAME_NUMBER_STRING = ""number"",
      ELEMNAME_OTHERWISE_STRING = ""otherwise"",
      ELEMNAME_OUTPUT_STRING = ""output"",
      ELEMNAME_PARAMVARIABLE_STRING = ""param"",
      ELEMNAME_PI_OLD_STRING = ""pi"",
      ELEMNAME_PI_STRING = ""processing-instruction"",
      ELEMNAME_PRESERVESPACE_STRING = ""preserve-space"",
      ELEMNAME_ROOT_STRING = ""root"",  
      ELEMNAME_SCRIPT_STRING = ""script"",
      ELEMNAME_SORT_STRING = ""sort"",
      ELEMNAME_STRIPSPACE_STRING = ""strip-space"",
      ELEMNAME_STYLESHEET_STRING = ""stylesheet"",
      ELEMNAME_TARGETATTRIBUTE_STRING = ""target-attribute"",  
      ELEMNAME_TARGETCOMMENT_STRING = ""target-comment"",
      ELEMNAME_TARGETELEMENT_STRING = ""target-element"",  
      ELEMNAME_TARGETPI_STRING = ""target-pi"",
      ELEMNAME_TARGETTEXT_STRING = ""target-text"",
      ELEMNAME_TEMPLATE_STRING = ""template"",
      ELEMNAME_TEXT_STRING = ""text"",
      ELEMNAME_TRANSFORM_STRING = ""transform"",
      ELEMNAME_URL_STRING = ""uri"",  
      ELEMNAME_USE_STRING = ""use"",
      ELEMNAME_VALUEOF_STRING = ""value-of"",
      ELEMNAME_VARIABLE_STRING = ""variable"",
      ELEMNAME_WHEN_STRING = ""when"",
      ELEMNAME_WITHPARAM_STRING = ""with-param"";
  
  
  public static final String
    EXSLT_ELEMNAME_FUNCTION_STRING = ""function"",
    EXSLT_ELEMNAME_FUNCRESULT_STRING = ""result"";
  public static final int
    EXSLT_ELEMNAME_FUNCTION = 88,
    EXSLT_ELEMNAME_FUNCRESULT = 89;
  
  
  
  public static final String
	  ATTRNAME_AMOUNT = ""amount"",
      ATTRNAME_ANCESTOR = ""ancestor"",
      ATTRNAME_ARCHIVE = ""archive"",
      ATTRNAME_ATTRIBUTE = ""attribute"",
      ATTRNAME_ATTRIBUTE_SET = ""attribute-set"",
      ATTRNAME_CASEORDER = ""case-order"",
      ATTRNAME_CLASS = ""class"",
      ATTRNAME_CLASSID = ""classid"",
      ATTRNAME_CODEBASE = ""codebase"",
      ATTRNAME_CODETYPE = ""type"",
      ATTRNAME_CONDITION = ""condition"",
      ATTRNAME_COPYTYPE = ""copy-type"",
      ATTRNAME_COUNT = ""count"",
      ATTRNAME_DATATYPE = ""data-type"",
      ATTRNAME_DECIMALSEPARATOR = ""decimal-separator"",
      ATTRNAME_DEFAULT = ""default"",
      ATTRNAME_DEFAULTSPACE = ""default-space"",
      ATTRNAME_DEPTH = ""with-children"",
      ATTRNAME_DIGIT = ""digit"",
      ATTRNAME_DIGITGROUPSEP = ""digit-group-sep"",
      ATTRNAME_DISABLE_OUTPUT_ESCAPING = ""disable-output-escaping"",
      ATTRNAME_ELEMENT = ""element"",
      ATTRNAME_ELEMENTS = ""elements"",
      ATTRNAME_EXCLUDE_RESULT_PREFIXES =""exclude-result-prefixes"",
      ATTRNAME_EXPR = ""expr"",
      ATTRNAME_EXTENSIONELEMENTPREFIXES = ""extension-element-prefixes"",
      ATTRNAME_FORMAT = ""format"",
      ATTRNAME_FROM = ""from"",
      ATTRNAME_GROUPINGSEPARATOR = ""grouping-separator"",
      ATTRNAME_GROUPINGSIZE = ""grouping-size"",
      ATTRNAME_HREF = ""href"",
      ATTRNAME_ID = ""id"",
      ATTRNAME_IMPORTANCE = ""importance"",
      ATTRNAME_INDENTRESULT = ""indent-result"",
      ATTRNAME_INFINITY = ""infinity"",
      ATTRNAME_LANG = ""lang"",
      ATTRNAME_LETTERVALUE = ""letter-value"",
      ATTRNAME_LEVEL = ""level"",
      ATTRNAME_MATCH = ""match"",
      ATTRNAME_METHOD = ""calls"",
      ATTRNAME_MINUSSIGN = ""minus-sign"",
      ATTRNAME_MODE = ""mode"",
      ATTRNAME_NAME = ""name"",
      ATTRNAME_NAMESPACE = ""namespace"",
      ATTRNAME_NAN = ""NaN"",
      ATTRNAME_NDIGITSPERGROUP = ""n-digits-per-group"",
      ATTRNAME_NS = ""ns"",
      ATTRNAME_ONLY = ""only"",
      ATTRNAME_ORDER = ""order"",
      ATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = ""cdata-section-elements"",
      ATTRNAME_OUTPUT_DOCTYPE_PUBLIC = ""doctype-public"",
      ATTRNAME_OUTPUT_DOCTYPE_SYSTEM = ""doctype-system"",
      ATTRNAME_OUTPUT_ENCODING = ""encoding"",
      ATTRNAME_OUTPUT_INDENT = ""indent"",
      ATTRNAME_OUTPUT_MEDIATYPE = ""media-type"",
      ATTRNAME_OUTPUT_METHOD = ""method"",  
      ATTRNAME_OUTPUT_OMITXMLDECL = ""omit-xml-declaration"",
      ATTRNAME_OUTPUT_STANDALONE = ""standalone"",
      ATTRNAME_OUTPUT_VERSION = ""version"",
      ATTRNAME_PATTERNSEPARATOR = ""pattern-separator"",
      ATTRNAME_PERCENT = ""percent"",
      ATTRNAME_PERMILLE = ""per-mille"",
      ATTRNAME_PRIORITY = ""priority"",
      ATTRNAME_REFID = ""refID"",
      ATTRNAME_RESULTNS = ""result-ns"",
      ATTRNAME_RESULT_PREFIX = ""result-prefix"",
      ATTRNAME_SELECT = ""select"",
      ATTRNAME_SEQUENCESRC = ""sequence-src"",
      ATTRNAME_STYLE = ""style"",
      ATTRNAME_STYLESHEET_PREFIX = ""stylesheet-prefix"",
      ATTRNAME_TERMINATE = ""terminate"",
      ATTRNAME_TEST = ""test"",
      ATTRNAME_TOSTRING = ""to-string"",
      ATTRNAME_TYPE = ""type"",
      ATTRNAME_USE = ""use"",
      ATTRNAME_USEATTRIBUTESETS = ""use-attribute-sets"",
      ATTRNAME_VALUE = ""value"",
      ATTRNAME_VERSION = ""version"",
      ATTRNAME_XMLNS = ""xmlns:"", 
      ATTRNAME_XMLNSDEF = ""xmlns"", 
      ATTRNAME_XMLSPACE = ""xml:space"", 
      ATTRNAME_ZERODIGIT = ""zero-digit"";

  
  public static final int TATTRNAME_OUTPUT_METHOD = 1, TATTRNAME_AMOUNT = 2,
                          TATTRNAME_ANCESTOR = 3, TATTRNAME_ARCHIVE = 4,
                          TATTRNAME_ATTRIBUTE = 5,
                          TATTRNAME_ATTRIBUTE_SET = 6,
                          TATTRNAME_CASEORDER = 7, TATTRNAME_CLASS = 8,
                          TATTRNAME_CLASSID = 9, TATTRNAME_CODEBASE = 10,
                          TATTRNAME_CODETYPE = 11, TATTRNAME_CONDITION = 12,
                          TATTRNAME_COPYTYPE = 13, TATTRNAME_COUNT = 14,
                          TATTRNAME_DATATYPE = 15, TATTRNAME_DEFAULT = 16,
                          TATTRNAME_DEFAULTSPACE = 17, TATTRNAME_DEPTH = 18,
                          TATTRNAME_DIGITGROUPSEP = 19,
                          TATTRNAME_DISABLE_OUTPUT_ESCAPING = 20,
                          TATTRNAME_ELEMENT = 21, TATTRNAME_ELEMENTS = 22,
                          TATTRNAME_EXPR = 23,
                          TATTRNAME_EXTENSIONELEMENTPREFIXES = 24,
                          TATTRNAME_FORMAT = 25, TATTRNAME_FROM = 26,
                          TATTRNAME_GROUPINGSEPARATOR = 27,
                          TATTRNAME_GROUPINGSIZE = 28, TATTRNAME_HREF = 29,
                          TATTRNAME_ID = 30, TATTRNAME_IMPORTANCE = 31,
                          TATTRNAME_INDENTRESULT = 32, TATTRNAME_LANG = 33,
                          TATTRNAME_LETTERVALUE = 34, TATTRNAME_LEVEL = 35,
                          TATTRNAME_MATCH = 36, TATTRNAME_METHOD = 37,
                          TATTRNAME_MODE = 38, TATTRNAME_NAME = 39,
                          TATTRNAME_NAMESPACE = 40,
                          TATTRNAME_NDIGITSPERGROUP = 41, TATTRNAME_NS = 42,
                          TATTRNAME_ONLY = 43, TATTRNAME_ORDER = 44,
                          TATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = 45,
                          TATTRNAME_OUTPUT_DOCTYPE_PUBLIC = 46,
                          TATTRNAME_OUTPUT_DOCTYPE_SYSTEM = 47,
                          TATTRNAME_OUTPUT_ENCODING = 48,
                          TATTRNAME_OUTPUT_INDENT = 49,
                          TATTRNAME_OUTPUT_MEDIATYPE = 50,
                          TATTRNAME_OUTPUT_STANDALONE = 51,
                          TATTRNAME_OUTPUT_VERSION = 52,
                          TATTRNAME_OUTPUT_OMITXMLDECL = 53,
                          TATTRNAME_PRIORITY = 54, TATTRNAME_REFID = 55,
                          TATTRNAME_RESULTNS = 56, TATTRNAME_SELECT = 57,
                          TATTRNAME_SEQUENCESRC = 58, TATTRNAME_STYLE = 59,
                          TATTRNAME_TEST = 60, TATTRNAME_TOSTRING = 61,
                          TATTRNAME_TYPE = 62, TATTRNAME_USE = 63,
                          TATTRNAME_USEATTRIBUTESETS = 64,
                          TATTRNAME_VALUE = 65, TATTRNAME_XMLNSDEF = 66,
                          TATTRNAME_XMLNS = 67, TATTRNAME_XMLSPACE = 68,
                          TATTRNAME_EXCLUDE_RESULT_PREFIXES = 69;

  
  public static final String ATTRVAL_OUTPUT_METHOD_HTML = ""html"",
                             ATTRVAL_OUTPUT_METHOD_XML = ""xml"",
                             ATTRVAL_OUTPUT_METHOD_TEXT = ""text"";

  
  
  public static final int ATTRVAL_PRESERVE = 1, ATTRVAL_STRIP = 2;

  
  
  public static final boolean ATTRVAL_YES = true, ATTRVAL_NO = false;

  
  
  public static final String ATTRVAL_ALPHABETIC = ""alphabetic"",
                             ATTRVAL_OTHER = ""other"",
                             ATTRVAL_TRADITIONAL = ""traditional"";

  
  
  public static final String ATTRVAL_SINGLE = ""single"",
                             ATTRVAL_MULTI = ""multiple"", ATTRVAL_ANY = ""any"";

  
  
  public static final String ATTRVAL_DEFAULT_PREFIX = ""#default"";

 
  public static final int NUMBERLETTER_ALPHABETIC = 1, NUMBERLETTER_TRADITIONAL = 2;
  
  
  public static final int NUMBERLEVEL_SINGLE = 1, NUMBERLEVEL_MULTI = 2,
                          NUMBERLEVEL_ANY = 3, MAX_MULTI_COUNTING_DEPTH = 32;

  
  
  public static final String ATTRVAL_THIS = ""."", ATTRVAL_PARENT = "".."",
                             ATTRVAL_ANCESTOR = ""ancestor"", ATTRVAL_ID = ""id"";

  
  
  public static final String ATTRVAL_DATATYPE_TEXT = ""text"",
                             ATTRVAL_DATATYPE_NUMBER = ""number"",
                             ATTRVAL_ORDER_ASCENDING = ""ascending"",
                             ATTRVAL_ORDER_DESCENDING = ""descending"",
                             ATTRVAL_CASEORDER_UPPER = ""upper-first"",
                             ATTRVAL_CASEORDER_LOWER = ""lower-first"";

 
  public static final int SORTDATATYPE_TEXT = 1, SORTDATATYPE_NUMBER = 2;

  
  public static final int SORTORDER_ASCENDING = 1, SORTORDER_DESCENDING = 2;
  
  
  public static final int SORTCASEORDER_UPPERFIRST = 1, SORTCASEORDER_LOWERFIRST = 2;
  
  
  public static final String ATTRVAL_INFINITY = ""Infinity"",
                             ATTRVAL_NAN = ""NaN"",
                             DEFAULT_DECIMAL_FORMAT = ""#default"";

  
  
  public static final String ATTRNAME_XXXX = ""XXXX"";
}
"
org.apache.xalan.templates.ElemFallback,5,3,0,5,12,10,2,3,5,2.0,39,0.0,0,0.98,0.7,2,4,6.8,1,0.8,2,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;


public class ElemFallback extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_FALLBACK;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_FALLBACK_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
  }

  
  public void executeFallback(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (Constants.ELEMNAME_EXTENSIONCALL == m_parentNode.getXSLToken())
    {

      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEvent(this);

      transformer.executeChildTemplates(this, true);

      if (TransformerImpl.S_DEBUG)
	    transformer.getTraceManager().fireTraceEndEvent(this); 
    }
    else
    {

      
      System.out.println(
        ""Error!  parent of xsl:fallback must be an extension element!"");
    }
  }
}
"
org.apache.xpath.operations.Number,3,3,0,7,8,3,2,5,3,2.0,23,0.0,0,0.952380952,0.555555556,1,1,6.666666667,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class Number extends UnaryOperation
{

  
  public XObject operate(XObject right) throws javax.xml.transform.TransformerException
  {

    if (XObject.CLASS_NUMBER == right.getType())
      return right;
    else
      return new XNumber(right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return m_right.num(xctxt);
  }

}
"
org.apache.xml.utils.URI,42,1,0,3,68,375,1,2,29,0.780487805,2044,1.0,0,0.0,0.226480836,0,0,47.38095238,33,3.1429,0,"
package org.apache.xml.utils;

import java.io.IOException;
import java.io.Serializable;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;


public class URI implements Serializable
{

  
  public static class MalformedURIException extends IOException
  {

    
    public MalformedURIException()
    {
      super();
    }

    
    public MalformedURIException(String p_msg)
    {
      super(p_msg);
    }
  }

  
  private static final String RESERVED_CHARACTERS = "";/?:@&=+$,"";

  
  private static final String MARK_CHARACTERS = ""-_.!~*'() "";

  
  private static final String SCHEME_CHARACTERS = ""+-."";

  
  private static final String USERINFO_CHARACTERS = "";:&=+$,"";

  
  private String m_scheme = null;

  
  private String m_userinfo = null;

  
  private String m_host = null;

  
  private int m_port = -1;

  
  private String m_path = null;

  
  private String m_queryString = null;

  
  private String m_fragment = null;

  
  private static boolean DEBUG = false;

  
  public URI(){}

  
  public URI(URI p_other)
  {
    initialize(p_other);
  }

  
  public URI(String p_uriSpec) throws MalformedURIException
  {
    this((URI) null, p_uriSpec);
  }

  
  public URI(URI p_base, String p_uriSpec) throws MalformedURIException
  {
    initialize(p_base, p_uriSpec);
  }

  
  public URI(String p_scheme, String p_schemeSpecificPart)
          throws MalformedURIException
  {

    if (p_scheme == null || p_scheme.trim().length() == 0)
    {
      throw new MalformedURIException(
        ""Cannot construct URI with null/empty scheme!"");
    }

    if (p_schemeSpecificPart == null
            || p_schemeSpecificPart.trim().length() == 0)
    {
      throw new MalformedURIException(
        ""Cannot construct URI with null/empty scheme-specific part!"");
    }

    setScheme(p_scheme);
    setPath(p_schemeSpecificPart);
  }

  
  public URI(String p_scheme, String p_host, String p_path, String p_queryString, String p_fragment)
          throws MalformedURIException
  {
    this(p_scheme, null, p_host, -1, p_path, p_queryString, p_fragment);
  }

  
  public URI(String p_scheme, String p_userinfo, String p_host, int p_port, String p_path, String p_queryString, String p_fragment)
          throws MalformedURIException
  {

    if (p_scheme == null || p_scheme.trim().length() == 0)
    {
      throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_SCHEME_REQUIRED, null)); 
    }

    if (p_host == null)
    {
      if (p_userinfo != null)
      {
        throw new MalformedURIException(
          XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_USERINFO_IF_NO_HOST, null)); 
      }

      if (p_port != -1)
      {
        throw new MalformedURIException(
          XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_PORT_IF_NO_HOST, null)); 
      }
    }

    if (p_path != null)
    {
      if (p_path.indexOf('?') != -1 && p_queryString != null)
      {
        throw new MalformedURIException(
          XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_QUERY_STRING_IN_PATH, null)); 
      }

      if (p_path.indexOf('#') != -1 && p_fragment != null)
      {
        throw new MalformedURIException(
          XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_FRAGMENT_STRING_IN_PATH, null)); 
      }
    }

    setScheme(p_scheme);
    setHost(p_host);
    setPort(p_port);
    setUserinfo(p_userinfo);
    setPath(p_path);
    setQueryString(p_queryString);
    setFragment(p_fragment);
  }

  
  private void initialize(URI p_other)
  {

    m_scheme = p_other.getScheme();
    m_userinfo = p_other.getUserinfo();
    m_host = p_other.getHost();
    m_port = p_other.getPort();
    m_path = p_other.getPath();
    m_queryString = p_other.getQueryString();
    m_fragment = p_other.getFragment();
  }

  
  private void initialize(URI p_base, String p_uriSpec)
          throws MalformedURIException
  {

    if (p_base == null
            && (p_uriSpec == null || p_uriSpec.trim().length() == 0))
    {
      throw new MalformedURIException(
        XMLMessages.createXMLMessage(XMLErrorResources.ER_CANNOT_INIT_URI_EMPTY_PARMS, null)); 
    }

    
    if (p_uriSpec == null || p_uriSpec.trim().length() == 0)
    {
      initialize(p_base);

      return;
    }

    String uriSpec = p_uriSpec.trim();
    int uriSpecLen = uriSpec.length();
    int index = 0;

    
    int colonIndex = uriSpec.indexOf(':');
    if (colonIndex < 0)
    {
      if (p_base == null)
      {
        throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_SCHEME_IN_URI, new Object[]{uriSpec})); 
      }
    }
    else
    {
      initializeScheme(uriSpec);
      uriSpec = uriSpec.substring(colonIndex+1);
      uriSpecLen = uriSpec.length();
    }

    
    if (((index + 1) < uriSpecLen)
            && (uriSpec.substring(index).startsWith(""
    {
      index += 2;

      int startPos = index;

      
      char testChar = ' ';

      while (index < uriSpecLen)
      {
        testChar = uriSpec.charAt(index);

        if (testChar == '/' || testChar == '?' || testChar == '#')
        {
          break;
        }

        index++;
      }

      
      
      if (index > startPos)
      {
        initializeAuthority(uriSpec.substring(startPos, index));
      }
      else
      {
        m_host = """";
      }
    }

    initializePath(uriSpec.substring(index));

    
    
    
    
    
    if (p_base != null)
    {

      
      
      
      
      
      
      
      if (m_path.length() == 0 && m_scheme == null && m_host == null)
      {
        m_scheme = p_base.getScheme();
        m_userinfo = p_base.getUserinfo();
        m_host = p_base.getHost();
        m_port = p_base.getPort();
        m_path = p_base.getPath();

        if (m_queryString == null)
        {
          m_queryString = p_base.getQueryString();
        }

        return;
      }

      
      
      if (m_scheme == null)
      {
        m_scheme = p_base.getScheme();
      }

      
      
      if (m_host == null)
      {
        m_userinfo = p_base.getUserinfo();
        m_host = p_base.getHost();
        m_port = p_base.getPort();
      }
      else
      {
        return;
      }

      
      if (m_path.length() > 0 && m_path.startsWith(""/""))
      {
        return;
      }

      
      
      String path = new String();
      String basePath = p_base.getPath();

      
      if (basePath != null)
      {
        int lastSlash = basePath.lastIndexOf('/');

        if (lastSlash != -1)
        {
          path = basePath.substring(0, lastSlash + 1);
        }
      }

      
      path = path.concat(m_path);

      
      index = -1;

      while ((index = path.indexOf(""/./"")) != -1)
      {
        path = path.substring(0, index + 1).concat(path.substring(index + 3));
      }

      
      if (path.endsWith(""/.""))
      {
        path = path.substring(0, path.length() - 1);
      }

      
      
      index = -1;

      int segIndex = -1;
      String tempString = null;

      while ((index = path.indexOf(""/../"")) > 0)
      {
        tempString = path.substring(0, path.indexOf(""/../""));
        segIndex = tempString.lastIndexOf('/');

        if (segIndex != -1)
        {
          if (!tempString.substring(segIndex++).equals(""..""))
          {
            path = path.substring(0, segIndex).concat(path.substring(index
                    + 4));
          }
        }
      }

      
      
      if (path.endsWith(""/..""))
      {
        tempString = path.substring(0, path.length() - 3);
        segIndex = tempString.lastIndexOf('/');

        if (segIndex != -1)
        {
          path = path.substring(0, segIndex + 1);
        }
      }

      m_path = path;
    }
  }

  
  private void initializeScheme(String p_uriSpec) throws MalformedURIException
  {

    int uriSpecLen = p_uriSpec.length();
    int index = 0;
    String scheme = null;
    char testChar = ' ';

    while (index < uriSpecLen)
    {
      testChar = p_uriSpec.charAt(index);

      if (testChar == ':' || testChar == '/' || testChar == '?'
              || testChar == '#')
      {
        break;
      }

      index++;
    }

    scheme = p_uriSpec.substring(0, index);

    if (scheme.length() == 0)
    {
      throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_SCHEME_INURI, null)); 
    }
    else
    {
      setScheme(scheme);
    }
  }

  
  private void initializeAuthority(String p_uriSpec)
          throws MalformedURIException
  {

    int index = 0;
    int start = 0;
    int end = p_uriSpec.length();
    char testChar = ' ';
    String userinfo = null;

    
    if (p_uriSpec.indexOf('@', start) != -1)
    {
      while (index < end)
      {
        testChar = p_uriSpec.charAt(index);

        if (testChar == '@')
        {
          break;
        }

        index++;
      }

      userinfo = p_uriSpec.substring(start, index);

      index++;
    }

    
    String host = null;

    start = index;

    while (index < end)
    {
      testChar = p_uriSpec.charAt(index);

      if (testChar == ':')
      {
        break;
      }

      index++;
    }

    host = p_uriSpec.substring(start, index);

    int port = -1;

    if (host.length() > 0)
    {

      
      if (testChar == ':')
      {
        index++;

        start = index;

        while (index < end)
        {
          index++;
        }

        String portStr = p_uriSpec.substring(start, index);

        if (portStr.length() > 0)
        {
          for (int i = 0; i < portStr.length(); i++)
          {
            if (!isDigit(portStr.charAt(i)))
            {
              throw new MalformedURIException(
                portStr + "" is invalid. Port should only contain digits!"");
            }
          }

          try
          {
            port = Integer.parseInt(portStr);
          }
          catch (NumberFormatException nfe)
          {

            
          }
        }
      }
    }

    setHost(host);
    setPort(port);
    setUserinfo(userinfo);
  }

  
  private void initializePath(String p_uriSpec) throws MalformedURIException
  {

    if (p_uriSpec == null)
    {
      throw new MalformedURIException(
        ""Cannot initialize path from null string!"");
    }

    int index = 0;
    int start = 0;
    int end = p_uriSpec.length();
    char testChar = ' ';

    
    while (index < end)
    {
      testChar = p_uriSpec.charAt(index);

      if (testChar == '?' || testChar == '#')
      {
        break;
      }

      
      if (testChar == '%')
      {
        if (index + 2 >= end ||!isHex(p_uriSpec.charAt(index + 1))
                ||!isHex(p_uriSpec.charAt(index + 2)))
        {
          throw new MalformedURIException(
            XMLMessages.createXMLMessage(XMLErrorResources.ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE, null)); 
        }
      }
      else if (!isReservedCharacter(testChar)
               &&!isUnreservedCharacter(testChar))
      {
        if ('\' != testChar)
          throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_PATH_INVALID_CHAR, new Object[]{String.valueOf(testChar)})); 
                                          
      }

      index++;
    }

    m_path = p_uriSpec.substring(start, index);

    
    if (testChar == '?')
    {
      index++;

      start = index;

      while (index < end)
      {
        testChar = p_uriSpec.charAt(index);

        if (testChar == '#')
        {
          break;
        }

        if (testChar == '%')
        {
          if (index + 2 >= end ||!isHex(p_uriSpec.charAt(index + 1))
                  ||!isHex(p_uriSpec.charAt(index + 2)))
          {
            throw new MalformedURIException(
              ""Query string contains invalid escape sequence!"");
          }
        }
        else if (!isReservedCharacter(testChar)
                 &&!isUnreservedCharacter(testChar))
        {
          throw new MalformedURIException(
            ""Query string contains invalid character:"" + testChar);
        }

        index++;
      }

      m_queryString = p_uriSpec.substring(start, index);
    }

    
    if (testChar == '#')
    {
      index++;

      start = index;

      while (index < end)
      {
        testChar = p_uriSpec.charAt(index);

        if (testChar == '%')
        {
          if (index + 2 >= end ||!isHex(p_uriSpec.charAt(index + 1))
                  ||!isHex(p_uriSpec.charAt(index + 2)))
          {
            throw new MalformedURIException(
              ""Fragment contains invalid escape sequence!"");
          }
        }
        else if (!isReservedCharacter(testChar)
                 &&!isUnreservedCharacter(testChar))
        {
          throw new MalformedURIException(
            ""Fragment contains invalid character:"" + testChar);
        }

        index++;
      }

      m_fragment = p_uriSpec.substring(start, index);
    }
  }

  
  public String getScheme()
  {
    return m_scheme;
  }

  
  public String getSchemeSpecificPart()
  {

    StringBuffer schemespec = new StringBuffer();

    if (m_userinfo != null || m_host != null || m_port != -1)
    {
      schemespec.append(""
    }

    if (m_userinfo != null)
    {
      schemespec.append(m_userinfo);
      schemespec.append('@');
    }

    if (m_host != null)
    {
      schemespec.append(m_host);
    }

    if (m_port != -1)
    {
      schemespec.append(':');
      schemespec.append(m_port);
    }

    if (m_path != null)
    {
      schemespec.append((m_path));
    }

    if (m_queryString != null)
    {
      schemespec.append('?');
      schemespec.append(m_queryString);
    }

    if (m_fragment != null)
    {
      schemespec.append('#');
      schemespec.append(m_fragment);
    }

    return schemespec.toString();
  }

  
  public String getUserinfo()
  {
    return m_userinfo;
  }

  
  public String getHost()
  {
    return m_host;
  }

  
  public int getPort()
  {
    return m_port;
  }

  
  public String getPath(boolean p_includeQueryString,
                        boolean p_includeFragment)
  {

    StringBuffer pathString = new StringBuffer(m_path);

    if (p_includeQueryString && m_queryString != null)
    {
      pathString.append('?');
      pathString.append(m_queryString);
    }

    if (p_includeFragment && m_fragment != null)
    {
      pathString.append('#');
      pathString.append(m_fragment);
    }

    return pathString.toString();
  }

  
  public String getPath()
  {
    return m_path;
  }

  
  public String getQueryString()
  {
    return m_queryString;
  }

  
  public String getFragment()
  {
    return m_fragment;
  }

  
  public void setScheme(String p_scheme) throws MalformedURIException
  {

    if (p_scheme == null)
    {
      throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_SCHEME_FROM_NULL_STRING, null)); 
    }

    if (!isConformantSchemeName(p_scheme))
    {
      throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_SCHEME_NOT_CONFORMANT, null)); 
    }

    m_scheme = p_scheme.toLowerCase();
  }

  
  public void setUserinfo(String p_userinfo) throws MalformedURIException
  {

    if (p_userinfo == null)
    {
      m_userinfo = null;
    }
    else
    {
      if (m_host == null)
      {
        throw new MalformedURIException(
          ""Userinfo cannot be set when host is null!"");
      }

      
      
      int index = 0;
      int end = p_userinfo.length();
      char testChar = ' ';

      while (index < end)
      {
        testChar = p_userinfo.charAt(index);

        if (testChar == '%')
        {
          if (index + 2 >= end ||!isHex(p_userinfo.charAt(index + 1))
                  ||!isHex(p_userinfo.charAt(index + 2)))
          {
            throw new MalformedURIException(
              ""Userinfo contains invalid escape sequence!"");
          }
        }
        else if (!isUnreservedCharacter(testChar)
                 && USERINFO_CHARACTERS.indexOf(testChar) == -1)
        {
          throw new MalformedURIException(
            ""Userinfo contains invalid character:"" + testChar);
        }

        index++;
      }
    }

    m_userinfo = p_userinfo;
  }

  
  public void setHost(String p_host) throws MalformedURIException
  {

    if (p_host == null || p_host.trim().length() == 0)
    {
      m_host = p_host;
      m_userinfo = null;
      m_port = -1;
    }
    else if (!isWellFormedAddress(p_host))
    {
      throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_HOST_ADDRESS_NOT_WELLFORMED, null)); 
    }

    m_host = p_host;
  }

  
  public void setPort(int p_port) throws MalformedURIException
  {

    if (p_port >= 0 && p_port <= 65535)
    {
      if (m_host == null)
      {
        throw new MalformedURIException(
          XMLMessages.createXMLMessage(XMLErrorResources.ER_PORT_WHEN_HOST_NULL, null)); 
      }
    }
    else if (p_port != -1)
    {
      throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_INVALID_PORT, null)); 
    }

    m_port = p_port;
  }

  
  public void setPath(String p_path) throws MalformedURIException
  {

    if (p_path == null)
    {
      m_path = null;
      m_queryString = null;
      m_fragment = null;
    }
    else
    {
      initializePath(p_path);
    }
  }

  
  public void appendPath(String p_addToPath) throws MalformedURIException
  {

    if (p_addToPath == null || p_addToPath.trim().length() == 0)
    {
      return;
    }

    if (!isURIString(p_addToPath))
    {
      throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_PATH_INVALID_CHAR, new Object[]{p_addToPath})); 
    }

    if (m_path == null || m_path.trim().length() == 0)
    {
      if (p_addToPath.startsWith(""/""))
      {
        m_path = p_addToPath;
      }
      else
      {
        m_path = ""/"" + p_addToPath;
      }
    }
    else if (m_path.endsWith(""/""))
    {
      if (p_addToPath.startsWith(""/""))
      {
        m_path = m_path.concat(p_addToPath.substring(1));
      }
      else
      {
        m_path = m_path.concat(p_addToPath);
      }
    }
    else
    {
      if (p_addToPath.startsWith(""/""))
      {
        m_path = m_path.concat(p_addToPath);
      }
      else
      {
        m_path = m_path.concat(""/"" + p_addToPath);
      }
    }
  }

  
  public void setQueryString(String p_queryString)
          throws MalformedURIException
  {

    if (p_queryString == null)
    {
      m_queryString = null;
    }
    else if (!isGenericURI())
    {
      throw new MalformedURIException(
        ""Query string can only be set for a generic URI!"");
    }
    else if (getPath() == null)
    {
      throw new MalformedURIException(
        ""Query string cannot be set when path is null!"");
    }
    else if (!isURIString(p_queryString))
    {
      throw new MalformedURIException(
        ""Query string contains invalid character!"");
    }
    else
    {
      m_queryString = p_queryString;
    }
  }

  
  public void setFragment(String p_fragment) throws MalformedURIException
  {

    if (p_fragment == null)
    {
      m_fragment = null;
    }
    else if (!isGenericURI())
    {
      throw new MalformedURIException(
        XMLMessages.createXMLMessage(XMLErrorResources.ER_FRAG_FOR_GENERIC_URI, null)); 
    }
    else if (getPath() == null)
    {
      throw new MalformedURIException(
        XMLMessages.createXMLMessage(XMLErrorResources.ER_FRAG_WHEN_PATH_NULL, null)); 
    }
    else if (!isURIString(p_fragment))
    {
      throw new MalformedURIException(XMLMessages.createXMLMessage(XMLErrorResources.ER_FRAG_INVALID_CHAR, null)); 
    }
    else
    {
      m_fragment = p_fragment;
    }
  }

  
  public boolean equals(Object p_test)
  {

    if (p_test instanceof URI)
    {
      URI testURI = (URI) p_test;

      if (((m_scheme == null && testURI.m_scheme == null) || (m_scheme != null && testURI.m_scheme != null && m_scheme.equals(
              testURI.m_scheme))) && ((m_userinfo == null && testURI.m_userinfo == null) || (m_userinfo != null && testURI.m_userinfo != null && m_userinfo.equals(
              testURI.m_userinfo))) && ((m_host == null && testURI.m_host == null) || (m_host != null && testURI.m_host != null && m_host.equals(
              testURI.m_host))) && m_port == testURI.m_port && ((m_path == null && testURI.m_path == null) || (m_path != null && testURI.m_path != null && m_path.equals(
              testURI.m_path))) && ((m_queryString == null && testURI.m_queryString == null) || (m_queryString != null && testURI.m_queryString != null && m_queryString.equals(
              testURI.m_queryString))) && ((m_fragment == null && testURI.m_fragment == null) || (m_fragment != null && testURI.m_fragment != null && m_fragment.equals(
              testURI.m_fragment))))
      {
        return true;
      }
    }

    return false;
  }

  
  public String toString()
  {

    StringBuffer uriSpecString = new StringBuffer();

    if (m_scheme != null)
    {
      uriSpecString.append(m_scheme);
      uriSpecString.append(':');
    }

    uriSpecString.append(getSchemeSpecificPart());

    return uriSpecString.toString();
  }

  
  public boolean isGenericURI()
  {

    
    
    return (m_host != null);
  }

  
  public static boolean isConformantSchemeName(String p_scheme)
  {

    if (p_scheme == null || p_scheme.trim().length() == 0)
    {
      return false;
    }

    if (!isAlpha(p_scheme.charAt(0)))
    {
      return false;
    }

    char testChar;

    for (int i = 1; i < p_scheme.length(); i++)
    {
      testChar = p_scheme.charAt(i);

      if (!isAlphanum(testChar) && SCHEME_CHARACTERS.indexOf(testChar) == -1)
      {
        return false;
      }
    }

    return true;
  }

  
  public static boolean isWellFormedAddress(String p_address)
  {

    if (p_address == null)
    {
      return false;
    }

    String address = p_address.trim();
    int addrLength = address.length();

    if (addrLength == 0 || addrLength > 255)
    {
      return false;
    }

    if (address.startsWith(""."") || address.startsWith(""-""))
    {
      return false;
    }

    
    
    
    int index = address.lastIndexOf('.');

    if (address.endsWith("".""))
    {
      index = address.substring(0, index).lastIndexOf('.');
    }

    if (index + 1 < addrLength && isDigit(p_address.charAt(index + 1)))
    {
      char testChar;
      int numDots = 0;

      
      
      
      for (int i = 0; i < addrLength; i++)
      {
        testChar = address.charAt(i);

        if (testChar == '.')
        {
          if (!isDigit(address.charAt(i - 1))
                  || (i + 1 < addrLength &&!isDigit(address.charAt(i + 1))))
          {
            return false;
          }

          numDots++;
        }
        else if (!isDigit(testChar))
        {
          return false;
        }
      }

      if (numDots != 3)
      {
        return false;
      }
    }
    else
    {

      
      
      char testChar;

      for (int i = 0; i < addrLength; i++)
      {
        testChar = address.charAt(i);

        if (testChar == '.')
        {
          if (!isAlphanum(address.charAt(i - 1)))
          {
            return false;
          }

          if (i + 1 < addrLength &&!isAlphanum(address.charAt(i + 1)))
          {
            return false;
          }
        }
        else if (!isAlphanum(testChar) && testChar != '-')
        {
          return false;
        }
      }
    }

    return true;
  }

  
  private static boolean isDigit(char p_char)
  {
    return p_char >= '0' && p_char <= '9';
  }

  
  private static boolean isHex(char p_char)
  {
    return (isDigit(p_char) || (p_char >= 'a' && p_char <= 'f')
            || (p_char >= 'A' && p_char <= 'F'));
  }

  
  private static boolean isAlpha(char p_char)
  {
    return ((p_char >= 'a' && p_char <= 'z')
            || (p_char >= 'A' && p_char <= 'Z'));
  }

  
  private static boolean isAlphanum(char p_char)
  {
    return (isAlpha(p_char) || isDigit(p_char));
  }

  
  private static boolean isReservedCharacter(char p_char)
  {
    return RESERVED_CHARACTERS.indexOf(p_char) != -1;
  }

  
  private static boolean isUnreservedCharacter(char p_char)
  {
    return (isAlphanum(p_char) || MARK_CHARACTERS.indexOf(p_char) != -1);
  }

  
  private static boolean isURIString(String p_uric)
  {

    if (p_uric == null)
    {
      return false;
    }

    int end = p_uric.length();
    char testChar = ' ';

    for (int i = 0; i < end; i++)
    {
      testChar = p_uric.charAt(i);

      if (testChar == '%')
      {
        if (i + 2 >= end ||!isHex(p_uric.charAt(i + 1))
                ||!isHex(p_uric.charAt(i + 2)))
        {
          return false;
        }
        else
        {
          i += 2;

          continue;
        }
      }

      if (isReservedCharacter(testChar) || isUnreservedCharacter(testChar))
      {
        continue;
      }
      else
      {
        return false;
      }
    }

    return true;
  }
}
"
org.apache.xpath.operations.Mult,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class Mult extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() * right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return (m_left.num(xctxt) * m_right.num(xctxt));
  }

}
"
org.apache.xml.serializer.ToStream,71,2,3,23,181,1581,4,20,43,0.878881988,2909,0.739130435,4,0.557692308,0.151020408,2,11,39.64788732,12,1.662,6,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.util.BitSet;
import java.util.Hashtable;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.Transformer;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.TreeWalker;
import org.apache.xml.utils.WrappedRuntimeException;
import org.w3c.dom.Node;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;





abstract public class ToStream extends SerializerBase
{

    private static final String COMMENT_BEGIN = ""<!--"";
    private static final String COMMENT_END = ""-->"";

    
    protected BoolStack m_disableOutputEscapingStates = new BoolStack();

    
    boolean m_triedToGetConverter = false;
    
    java.lang.reflect.Method m_canConvertMeth;

    
    Object m_charToByteConverter = null;

    
    protected BoolStack m_preserves = new BoolStack();

    
    protected boolean m_ispreserve = false;

    
    protected boolean m_isprevtext = false;

    
    

    
    private static CharInfo m_xmlcharInfo =
        
    CharInfo.getCharInfo(CharInfo.XML_ENTITIES_RESOURCE);

    
    protected int m_maxCharacter = Encodings.getLastPrintable();

    
    protected final char[] m_lineSep =
        System.getProperty(""line.separator"").toCharArray();

    
    protected final int m_lineSepLen = m_lineSep.length;

    
    protected CharInfo m_charInfo;

    
    private static Hashtable m_charInfos = null;

    
    boolean m_shouldFlush = true;

    

    
    protected boolean m_spaceBeforeClose = false;

    
    boolean m_startNewLine;

    
    protected boolean m_inDoctype = false;

    
    boolean m_isUTF8 = false;

    
    protected Properties m_format;

    
    protected boolean m_cdataStartCalled = false;

    
    public ToStream()
    {
    }

    
    protected void closeCDATA() throws org.xml.sax.SAXException
    {
        try
        {
            m_writer.write(CDATA_DELIMITER_CLOSE);
            
            m_cdataTagOpen = false; 
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }
    }

    
    public void serialize(Node node) throws IOException
    {

        try
        {
            TreeWalker walker =
                new TreeWalker(this, new org.apache.xml.utils.DOM2Helper());

            walker.traverse(node);
        }
        catch (org.xml.sax.SAXException se)
        {
            throw new WrappedRuntimeException(se);
        }
    }

    
    static final boolean isUTF16Surrogate(char c)
    {
        return (c & 0xFC00) == 0xD800;
    }

    
    private boolean m_escaping = true;

    
    protected final void flushWriter() throws org.xml.sax.SAXException
    {

        if (null != m_writer)
        {
            try
            {
                if (m_writer instanceof WriterToUTF8Buffered)
                {
                    if (m_shouldFlush)
                         ((WriterToUTF8Buffered) m_writer).flush();
                    else
                         ((WriterToUTF8Buffered) m_writer).flushBuffer();
                }
                if (m_writer instanceof WriterToUTF8)
                {
                    if (m_shouldFlush)
                        m_writer.flush();
                }
                else if (m_writer instanceof WriterToASCI)
                {
                    if (m_shouldFlush)
                        m_writer.flush();
                }
                else
                {
                    
                    
                    
                    m_writer.flush();
                }
            }
            catch (IOException ioe)
            {
                throw new org.xml.sax.SAXException(ioe);
            }
        }
    }

    
    public OutputStream getOutputStream()
    {

        if (m_writer instanceof WriterToUTF8Buffered)
            return ((WriterToUTF8Buffered) m_writer).getOutputStream();
        if (m_writer instanceof WriterToUTF8)
            return ((WriterToUTF8) m_writer).getOutputStream();
        else if (m_writer instanceof WriterToASCI)
            return ((WriterToASCI) m_writer).getOutputStream();
        else
            return null;
    }

    

    
    public void elementDecl(String name, String model) throws SAXException
    {
        
        if (m_inExternalDTD)
            return;
        try
        {

            if (m_inDoctype)
            {
                m_writer.write("" ["");
                m_writer.write(m_lineSep, 0, m_lineSepLen);

                m_inDoctype = false;
            }

            m_writer.write(""<!ELEMENT "");
            m_writer.write(name);
            m_writer.write(' ');
            m_writer.write(model);
            m_writer.write('>');
            m_writer.write(m_lineSep, 0, m_lineSepLen);
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }

    }

    
    public void internalEntityDecl(String name, String value)
        throws SAXException
    {
        
        if (m_inExternalDTD)
            return;
        try
        {
            if (m_inDoctype)
            {
                m_writer.write("" ["");
                m_writer.write(m_lineSep, 0, m_lineSepLen);

                m_inDoctype = false;
            }

            outputEntityDecl(name, value);
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }

    }

    
    void outputEntityDecl(String name, String value) throws IOException
    {

        m_writer.write(""<!ENTITY "");
        m_writer.write(name);
        m_writer.write("" """");
        m_writer.write(value);
        m_writer.write("""">"");
        m_writer.write(m_lineSep, 0, m_lineSepLen);
    }

    
    protected final void outputLineSep() throws IOException
    {

        m_writer.write(m_lineSep, 0, m_lineSepLen);
    }

    
    public void setOutputFormat(Properties format)
    {

        boolean shouldFlush = m_shouldFlush;

        init(m_writer, format, false, false);

        m_shouldFlush = shouldFlush;
    }

    
    private synchronized void init(
        Writer writer,
        Properties format,
        boolean defaultProperties,
        boolean shouldFlush)
    {

        m_shouldFlush = shouldFlush;

        
        
        
        if (m_tracer != null
         && !(writer instanceof SerializerTraceWriter)  )
            m_writer = new SerializerTraceWriter(writer, m_tracer);
        else
            m_writer = writer;        
        

        m_format = format;
        
        
        
        
        setCdataSectionElements(OutputKeys.CDATA_SECTION_ELEMENTS, format);

        setIndentAmount(
            OutputPropertyUtils.getIntProperty(
                OutputPropertiesFactory.S_KEY_INDENT_AMOUNT,
                format));
        setIndent(
            OutputPropertyUtils.getBooleanProperty(OutputKeys.INDENT, format));

        boolean shouldNotWriteXMLHeader =
            OutputPropertyUtils.getBooleanProperty(
                OutputKeys.OMIT_XML_DECLARATION,
                format);
        setOmitXMLDeclaration(shouldNotWriteXMLHeader);
        setDoctypeSystem(format.getProperty(OutputKeys.DOCTYPE_SYSTEM));
        String doctypePublic = format.getProperty(OutputKeys.DOCTYPE_PUBLIC);
        setDoctypePublic(doctypePublic);

        
        if (format.get(OutputKeys.STANDALONE) != null)
        {
            String val = format.getProperty(OutputKeys.STANDALONE);
            if (defaultProperties)
                setStandaloneInternal(val);
            else
                setStandalone(val);
        }

        setMediaType(format.getProperty(OutputKeys.MEDIA_TYPE));

        if (null != doctypePublic)
        {
            if (doctypePublic.startsWith(""-
                m_spaceBeforeClose = true;
        }

        
        String encoding = getEncoding();
        if (null == encoding)
        {
            encoding =
                Encodings.getMimeEncoding(
                    format.getProperty(OutputKeys.ENCODING));
            setEncoding(encoding);
        }

        m_isUTF8 = encoding.equals(Encodings.DEFAULT_MIME_ENCODING);
        m_maxCharacter = Encodings.getLastPrintable(encoding);

        
        
        String entitiesFileName =
            (String) format.get(OutputPropertiesFactory.S_KEY_ENTITIES);

        if (null != entitiesFileName)
        {
            m_charInfo = CharInfo.getCharInfo(entitiesFileName);
        }

    }

    
    private synchronized void init(Writer writer, Properties format)
    {
        init(writer, format, false, false);
    }
    
    protected synchronized void init(
        OutputStream output,
        Properties format,
        boolean defaultProperties)
        throws UnsupportedEncodingException
    {

        String encoding = getEncoding();
        if (encoding == null)
        {
            
            encoding =
                Encodings.getMimeEncoding(
                    format.getProperty(OutputKeys.ENCODING));
            setEncoding(encoding);
        }

        if (encoding.equalsIgnoreCase(""UTF-8""))
        {
            m_isUTF8 = true;
            
            
            
            
            
            
            
            
            
            
            
            
            
            
            if (output instanceof java.io.BufferedOutputStream)
            {
                init(new WriterToUTF8(output), format, defaultProperties, true);
            }
            else
            {
                init(
                    new WriterToUTF8Buffered(output),
                    format,
                    defaultProperties,
                    true);
            }

        }
        else if (
            encoding.equals(""WINDOWS-1250"")
                || encoding.equals(""US-ASCII"")
                || encoding.equals(""ASCII""))
        {
            init(new WriterToASCI(output), format, defaultProperties, true);
        }
        else
        {
            Writer osw;

            try
            {
                osw = Encodings.getWriter(output, encoding);
            }
            catch (UnsupportedEncodingException uee)
            {
                System.out.println(
                    ""Warning: encoding """"
                        + encoding
                        + """" not supported""
                        + "", using ""
                        + Encodings.DEFAULT_MIME_ENCODING);

                encoding = Encodings.DEFAULT_MIME_ENCODING;
                setEncoding(encoding);
                osw = Encodings.getWriter(output, encoding);
            }

            m_maxCharacter = Encodings.getLastPrintable(encoding);

            init(osw, format, defaultProperties, true);
        }

    }

    
    public Properties getOutputFormat()
    {
        return m_format;
    }

    
    public void setWriter(Writer writer)
    {        
        
        
        if (m_tracer != null
         && !(writer instanceof SerializerTraceWriter)  )
            m_writer = new SerializerTraceWriter(writer, m_tracer);
        else
            m_writer = writer;
    }

    
    public void setOutputStream(OutputStream output)
    {

        try
        {
            Properties format;
            if (null == m_format)
                format =
                    OutputPropertiesFactory.getDefaultMethodProperties(
                        Method.XML);
            else
                format = m_format;
            init(output, format, true);
        }
        catch (UnsupportedEncodingException uee)
        {

            
        }
    }

    
    public boolean setEscaping(boolean escape)
    {
        final boolean temp = m_escaping;
        m_escaping = escape;
        return temp;

    }

    
    public boolean reset()
    {
        m_needToCallStartDocument = true;
        
        return false;
    }

    
    protected void indent() throws IOException
    {

        if (m_startNewLine)
            outputLineSep();
        
        if (m_indentAmount > 0)
            printSpace(m_currentElemDepth * m_indentAmount);

    }
    
    private void printSpace(int n) throws IOException
    {

        for (int i = 0; i < n; i++)
        {
            m_writer.write(' ');
        }

    }

    
    public void attributeDecl(
        String eName,
        String aName,
        String type,
        String valueDefault,
        String value)
        throws SAXException
    {
        
        if (m_inExternalDTD)
            return;
        try
        {
            if (m_inDoctype)
            {
                m_writer.write("" ["");
                m_writer.write(m_lineSep, 0, m_lineSepLen);

                m_inDoctype = false;
            }

            m_writer.write(""<!ATTLIST "");
            m_writer.write(eName);
            m_writer.write("" "");

            m_writer.write(aName);
            m_writer.write("" "");
            m_writer.write(type);
            if (valueDefault != null)
            {
                m_writer.write("" "");
                m_writer.write(valueDefault);
            }

            
            
            m_writer.write("">"");
            m_writer.write(m_lineSep, 0, m_lineSepLen);
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }
    }

    
    public Writer getWriter()
    {
        return m_writer;
    }

    
    public void externalEntityDecl(
        String name,
        String publicId,
        String systemId)
        throws SAXException
    {
    }

    
    protected boolean escapingNotNeeded(char ch)
    {
        if (ch < 127)
        {
            if (ch >= 0x20 || (0x0A == ch || 0x0D == ch || 0x09 == ch))
                return true;
            else
                return false;
        }

        if (null == m_charToByteConverter && false == m_triedToGetConverter)
        {
            m_triedToGetConverter = true;
            try
            {
                m_charToByteConverter =
                    Encodings.getCharToByteConverter(getEncoding());
                if (null != m_charToByteConverter)
                {
                    Class argsTypes[] = new Class[1];
                    argsTypes[0] = Character.TYPE;
                    Class convClass = m_charToByteConverter.getClass();
                    m_canConvertMeth =
                        convClass.getMethod(""canConvert"", argsTypes);
                }
            }
            catch (Exception e)
            {
                
                System.err.println(""Warning: "" + e.getMessage());
            }
        }
        if (null != m_charToByteConverter)
        {
            try
            {
                Object args[] = new Object[1];
                args[0] = new Character(ch);
                Boolean bool =
                    (Boolean) m_canConvertMeth.invoke(
                        m_charToByteConverter,
                        args);
                return bool.booleanValue()
                    ? !Character.isISOControl(ch)
                    : false;
            }
            catch (java.lang.reflect.InvocationTargetException ite)
            {
                
                System.err.println(
                    ""Warning: InvocationTargetException in canConvert!"");
            }
            catch (java.lang.IllegalAccessException iae)
            {
                
                System.err.println(
                    ""Warning: IllegalAccessException in canConvert!"");
            }
        }
        
        return (ch <= m_maxCharacter);
    }

    
    protected int writeUTF16Surrogate(char c, char ch[], int i, int end)
        throws IOException
    {

        
        int surrogateValue = getURF16SurrogateValue(c, ch, i, end);

        i++;

        m_writer.write('&');
        m_writer.write('#');

        
        m_writer.write(Integer.toString(surrogateValue));
        m_writer.write(';');

        return i;
    }

    
    int getURF16SurrogateValue(char c, char ch[], int i, int end)
        throws IOException
    {

        int next;

        if (i + 1 >= end)
        {
            throw new IOException(
                XMLMessages.createXMLMessage(
                    XMLErrorResources.ER_INVALID_UTF16_SURROGATE,
                    new Object[] { Integer.toHexString((int) c)}));
            

            
        }
        else
        {
            next = ch[++i];

            if (!(0xdc00 <= next && next < 0xe000))
                throw new IOException(
                    XMLMessages.createXMLMessage(
                        XMLErrorResources.ER_INVALID_UTF16_SURROGATE,
                        new Object[] {
                            Integer.toHexString((int) c)
                                + "" ""
                                + Integer.toHexString(next)}));
            

            
            next = ((c - 0xd800) << 10) + next - 0xdc00 + 0x00010000;
        }

        return next;
    }

    
    protected int accumDefaultEntity(
        java.io.Writer writer,
        char ch,
        int i,
        char[] chars,
        int len,
        boolean escLF)
        throws IOException
    {

        if (!escLF && CharInfo.S_LINEFEED == ch)
        {
            writer.write(m_lineSep, 0, m_lineSepLen);
        }
        else
        {
            if (m_charInfo.isSpecial(ch))
            {
                String entityRef = m_charInfo.getEntityNameForChar(ch);

                if (null != entityRef)
                {
                    writer.write('&');
                    writer.write(entityRef);
                    writer.write(';');
                }
                else
                    return i;
            }
            else
                return i;
        }

        return i + 1;

    }
    
    void writeNormalizedChars(
        char ch[],
        int start,
        int length,
        boolean isCData)
        throws IOException, org.xml.sax.SAXException
    {

        int end = start + length;

        for (int i = start; i < end; i++)
        {
            char c = ch[i];

            if (CharInfo.S_LINEFEED == c)
            {
                m_writer.write(m_lineSep, 0, m_lineSepLen);
            }
            else if (isCData && (!escapingNotNeeded(c)))
            {
                
                if (m_cdataTagOpen)
                    closeCDATA();

                
                if (isUTF16Surrogate(c))
                {
                    i = writeUTF16Surrogate(c, ch, i, end);
                }
                else
                {
                    m_writer.write(""&#"");

                    String intStr = Integer.toString((int) c);

                    m_writer.write(intStr);
                    m_writer.write(';');
                }

                
                
                
                
                
                
            }
            else if (
                isCData
                    && ((i < (end - 2))
                        && (']' == c)
                        && (']' == ch[i + 1])
                        && ('>' == ch[i + 2])))
            {
                m_writer.write(CDATA_CONTINUE);

                i += 2;
            }
            else
            {
                if (escapingNotNeeded(c))
                {
                    if (isCData && !m_cdataTagOpen)
                    {
                        m_writer.write(CDATA_DELIMITER_OPEN);
                        m_cdataTagOpen = true;
                    }
                    m_writer.write(c);
                }

                
                else if (isUTF16Surrogate(c))
                {
                    if (m_cdataTagOpen)
                        closeCDATA();
                    i = writeUTF16Surrogate(c, ch, i, end);
                }
                else
                {
                    if (m_cdataTagOpen)
                        closeCDATA();
                    m_writer.write(""&#"");

                    String intStr = Integer.toString((int) c);

                    m_writer.write(intStr);
                    m_writer.write(';');
                }
            }
        }

    }

    
    public void endNonEscaping() throws org.xml.sax.SAXException
    {
        m_disableOutputEscapingStates.pop();
    }

    
    public void startNonEscaping() throws org.xml.sax.SAXException
    {
        m_disableOutputEscapingStates.push(true);
    }

    
    protected void cdata(char ch[], int start, final int length)
        throws org.xml.sax.SAXException
    {

        try
        {
            final int old_start = start;
            if (m_startTagOpen)
            {
                closeStartTag();
                m_startTagOpen = false;
            }
            m_ispreserve = true;

            if (shouldIndent())
                indent();

            boolean writeCDataBrackets =
                (((length >= 1) && escapingNotNeeded(ch[start])));

            
            if (writeCDataBrackets && !m_cdataTagOpen)
            {
                m_writer.write(CDATA_DELIMITER_OPEN);
                m_cdataTagOpen = true;
            }

            
            if (isEscapingDisabled())
            {
                charactersRaw(ch, start, length);
            }
            else
                writeNormalizedChars(ch, start, length, true);

            
            if (writeCDataBrackets)
            {
                
                if (ch[start + length - 1] == ']')
                    closeCDATA();
            }

            
            super.fireCDATAEvent(ch, old_start, length);
        }
        catch (IOException ioe)
        {
            throw new org.xml.sax.SAXException(
                XMLMessages.createXMLMessage(
                    XMLErrorResources.ER_OIERROR,
                    null),
                ioe);
            
        }
    }

    
    private boolean isEscapingDisabled()
    {
        return m_disableOutputEscapingStates.peekOrFalse();
    }

    
    protected void charactersRaw(char ch[], int start, int length)
        throws org.xml.sax.SAXException
    {

        if (m_inEntityRef)
            return;
        try
        {
            if (m_startTagOpen)
            {
                closeStartTag();
                m_startTagOpen = false;
            }

            m_ispreserve = true;

            m_writer.write(ch, start, length);
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }

    }

    
    public void characters(char chars[], int start, int length)
        throws org.xml.sax.SAXException
    {
        if (0 == length)
        {
            
            
            super.fireCharEvent(chars, start, length);
            return;
        }

        if (m_startTagOpen)
        {
            closeStartTag();
            m_startTagOpen = false;
        }
        else if (m_needToCallStartDocument)
        {
            startDocumentInternal();
        }

        if (m_cdataStartCalled || m_cdataSectionStates.peekOrFalse())
        {
            
            cdata(chars, start, length);

            return;
        }

        if (m_cdataTagOpen)
            closeCDATA();
        

        if (m_disableOutputEscapingStates.peekOrFalse() || (!m_escaping))
        {
            charactersRaw(chars, start, length);

            
            super.fireCharEvent(chars, start, length);

            return;
        }

        if (m_startTagOpen)
            closeStartTag();

        int startClean = start;
        int lengthClean = 0;

        
        int end = start + length;
        boolean checkWhite = true;
        final int maxCharacter = m_maxCharacter;
        final BitSet specialsMap = m_charInfo.m_specialsMap;
        try
        {
            for (int i = start; i < end; i++)
            {
                char ch = chars[i];

                if (checkWhite
                    && ((ch > 0x20)
                        || !((ch == 0x20)
                            || (ch == 0x09)
                            || (ch == 0xD)
                            || (ch == 0xA))))
                {
                    m_ispreserve = true;
                    checkWhite = false;
                }

                
                
                
                
                if ((((ch < 127)
                    && (0x20 <= ch || (0x0A == ch || 0x0D == ch || 0x09 == ch)))
                    && (!specialsMap.get(ch)))
                    || ('""' == ch))
                {
                    lengthClean++;
                }
                else if (
                    (escapingNotNeeded(ch) && (!specialsMap.get(ch)))
                        || ('""' == ch))
                {
                    lengthClean++;
                }
                else
                {
                    if (lengthClean > 0)
                    {
                        m_writer.write(chars, startClean, lengthClean);

                        lengthClean = 0;
                    }

                    if (CharInfo.S_LINEFEED == ch)
                    {
                        m_writer.write(m_lineSep, 0, m_lineSepLen);

                        startClean = i + 1;
                    }
                    else
                    {
                        startClean =
                            accumDefaultEscape(
                                m_writer,
                                ch,
                                i,
                                chars,
                                end,
                                false);
                        i = startClean - 1;
                    }
                }
            }

            if (lengthClean > 0)
            {
                m_writer.write(chars, startClean, lengthClean);
            }

            m_isprevtext = true;
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }

        
        super.fireCharEvent(chars, start, length);
    }

    
    public void characters(String s) throws org.xml.sax.SAXException
    {
        characters(s.toCharArray(), 0, s.length());
    }

    
    protected int accumDefaultEscape(
        Writer writer,
        char ch,
        int i,
        char[] chars,
        int len,
        boolean escLF)
        throws IOException
    {

        int pos = accumDefaultEntity(writer, ch, i, chars, len, escLF);

        if (i == pos)
        {
            pos++;

            if (0xd800 <= ch && ch < 0xdc00)
            {

                
                int next;

                if (i + 1 >= len)
                {
                    throw new IOException(
                        XMLMessages.createXMLMessage(
                            XMLErrorResources.ER_INVALID_UTF16_SURROGATE,
                            new Object[] { Integer.toHexString(ch)}));
                    

                    
                }
                else
                {
                    next = chars[++i];

                    if (!(0xdc00 <= next && next < 0xe000))
                        throw new IOException(
                            XMLMessages.createXMLMessage(
                                XMLErrorResources
                                    .ER_INVALID_UTF16_SURROGATE,
                                new Object[] {
                                    Integer.toHexString(ch)
                                        + "" ""
                                        + Integer.toHexString(next)}));
                    

                    
                    next = ((ch - 0xd800) << 10) + next - 0xdc00 + 0x00010000;
                }

                writer.write(""&#"");
                writer.write(Integer.toString(next));
                writer.write("";"");

                
            }
            else
            {
                if (!escapingNotNeeded(ch) || (m_charInfo.isSpecial(ch)))
                {
                    writer.write(""&#"");
                    writer.write(Integer.toString(ch));
                    writer.write("";"");
                }
                else
                {
                    writer.write(ch);
                }
            }

        }
        return pos;
    }

    
    public void startElement(
        String namespaceURI,
        String localName,
        String name,
        Attributes atts)
        throws org.xml.sax.SAXException
    {
        if (m_inEntityRef)
            return;

        if (m_needToCallStartDocument)
        {
            startDocumentInternal();
            m_needToCallStartDocument = false;
        }
        else if (m_cdataTagOpen)
            closeCDATA();
        try
        {
            if ((true == m_needToOutputDocTypeDecl)
                && (null != getDoctypeSystem()))
            {
                outputDocTypeDecl(name, true);
            }

            m_needToOutputDocTypeDecl = false;

            
            if (m_startTagOpen)
            {
                closeStartTag();
                m_startTagOpen = false;
            }

            if (namespaceURI != null)
                ensurePrefixIsDeclared(namespaceURI, name);

            
            m_elementLocalName = localName;
            m_elementURI = namespaceURI;
            m_elementName = name;

            m_ispreserve = false;

            if (shouldIndent() && m_startNewLine)
            {
                indent();
            }

            m_startNewLine = true;

            m_writer.write('<');
            m_writer.write(name);
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }

        
        if (atts != null)
            addAttributes(atts);

        
        m_startTagOpen = true;
        m_currentElemDepth++; 
        m_isprevtext = false;
    }

    
    public void startElement(
        String elementNamespaceURI,
        String elementLocalName,
        String elementName)
        throws SAXException
    {
        startElement(elementNamespaceURI, elementLocalName, elementName, null);
    }

    public void startElement(String elementName) throws SAXException
    {
        startElement(null, null, elementName, null);
    }

    
    void outputDocTypeDecl(String name, boolean closeDecl) throws SAXException
    {
        if (m_cdataTagOpen)
            closeCDATA();
        try
        {
            m_writer.write(""<!DOCTYPE "");
            m_writer.write(name);

            String doctypePublic = getDoctypePublic();
            if (null != doctypePublic)
            {
                m_writer.write("" PUBLIC """");
                m_writer.write(doctypePublic);
                m_writer.write('""');
            }

            String doctypeSystem = getDoctypeSystem();
            if (null != doctypeSystem)
            {
                if (null == doctypePublic)
                    m_writer.write("" SYSTEM """");
                else
                    m_writer.write("" """");

                m_writer.write(doctypeSystem);

                if (closeDecl)
                {
                    m_writer.write("""">"");
                    m_writer.write(m_lineSep, 0, m_lineSepLen);
                    closeDecl = false; 
                }
                else
                    m_writer.write('""');
            }
            boolean dothis = false;
            if (dothis)
            {
                
                
                if (closeDecl)
                {
                    m_writer.write("">"");
                    m_writer.write(m_lineSep, 0, m_lineSepLen);
                }
            }
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }
    }

    
    public void processAttributes() throws IOException, SAXException
    {

        
        super.fireStartElem(m_elementName);

        int nAttrs = 0;
        

        if ((nAttrs = m_attributes.getLength()) > 0)
        {
            

            String encoding = getEncoding();
            for (int i = 0; i < nAttrs; i++)
            {
                
                final String name = m_attributes.getQName(i);
                final String value = m_attributes.getValue(i);
                m_writer.write(' ');
                m_writer.write(name);
                m_writer.write(""="""");
                writeAttrString(m_writer, value, encoding);
                m_writer.write('""');
            }

            
            m_attributes.clear();

        }
    }

    
    public void writeAttrString(
        Writer writer,
        String string,
        String encoding)
        throws IOException
    {

        final char[] stringChars = string.toCharArray();
        final int len = stringChars.length;
        for (int i = 0; i < len; i++)
        {
            char ch = stringChars[i];
            if (escapingNotNeeded(ch) && (!m_charInfo.isSpecial(ch)))
            {
                writer.write(ch);
            }
            else
            { 
                if ((CharInfo.S_CARRIAGERETURN == ch)
                    && ((i + 1) < len)
                    && (CharInfo.S_LINEFEED == stringChars[i + 1]))
                {
                    i++;
                    ch = CharInfo.S_LINEFEED;
                }

                accumDefaultEscape(writer, ch, i, stringChars, len, true);
            }
        }

    }

    
    public void endElement(String namespaceURI, String localName, String name)
        throws org.xml.sax.SAXException
    {
        if (m_inEntityRef)
            return;

        
        
        m_prefixMap.popNamespaces(m_currentElemDepth);

        
        m_currentElemDepth--;

        try
        {
            if (m_startTagOpen)
            {
                
                processAttributes();
                if (m_spaceBeforeClose)
                    m_writer.write("" />"");
                else
                    m_writer.write(""/>"");
                

            }
            else
            {
                if (m_cdataTagOpen)
                    closeCDATA();

                if (shouldIndent())
                    indent();
                m_writer.write('<');
                m_writer.write('/');
                m_writer.write(name);
                m_writer.write('>');
                m_cdataSectionStates.pop();
            }
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }

        if (!m_startTagOpen)
        {
            m_ispreserve = m_preserves.isEmpty() ? false : m_preserves.pop();
        }

        m_isprevtext = false;
        m_startTagOpen = false;

        

        
        super.fireEndElem(name);
    }

    
    public void endElement(String name) throws org.xml.sax.SAXException
    {
        endElement(null, null, name);
    }

    
    public void startPrefixMapping(String prefix, String uri)
        throws org.xml.sax.SAXException
    {
        
        startPrefixMapping(prefix, uri, true);
    }

    
    public boolean startPrefixMapping(
        String prefix,
        String uri,
        boolean shouldFlush)
        throws org.xml.sax.SAXException
    {

        

        boolean pushed;
        int pushDepth;
        if (shouldFlush)
        {
            flushPending();
            
            pushDepth = m_currentElemDepth + 1;
        }
        else
        {
            
            pushDepth = m_currentElemDepth;
        }
        pushed = m_prefixMap.pushNamespace(prefix, uri, pushDepth);

        if (pushed)
        {
            
            String name;
            if (EMPTYSTRING.equals(prefix))
            {
                name = ""xmlns"";
                addAttributeAlways(XMLNS_URI, prefix, name, ""CDATA"", uri);
            }
            else
            {
                if (!EMPTYSTRING.equals(uri))
                    
                { 
                    name = ""xmlns:"" + prefix;

                    
                    addAttributeAlways(XMLNS_URI, prefix, name, ""CDATA"", uri);
                }
            }
        }
        return pushed;
    }

    
    public void comment(char ch[], int start, int length)
        throws org.xml.sax.SAXException
    {

        int start_old = start;
        if (m_inEntityRef)
            return;
        if (m_startTagOpen)
        {
            closeStartTag();
            m_startTagOpen = false;
        }
        else if (m_needToCallStartDocument)
        {
            startDocumentInternal();
            m_needToCallStartDocument = false;
        }

        try
        {
            if (shouldIndent())
                indent();

            final int limit = start + length;
            boolean wasDash = false;
            if (m_cdataTagOpen)
                closeCDATA();
            m_writer.write(COMMENT_BEGIN);
            
            for (int i = start; i < limit; i++)
            {
                if (wasDash && ch[i] == '-')
                {
                    m_writer.write(ch, start, i - start);
                    m_writer.write("" -"");
                    start = i + 1;
                }
                wasDash = (ch[i] == '-');
            }

            
            if (length > 0)
            {
                
                final int remainingChars = (limit - start);
                if (remainingChars > 0)
                    m_writer.write(ch, start, remainingChars);
                
                if (ch[limit - 1] == '-')
                    m_writer.write(' ');
            }
            m_writer.write(COMMENT_END);
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }

        m_startNewLine = true;
        
        super.fireCommentEvent(ch, start_old,length);
    }

    
    public void endCDATA() throws org.xml.sax.SAXException
    {
        if (m_cdataTagOpen)
            closeCDATA();
        m_cdataStartCalled = false;
    }

    
    public void endDTD() throws org.xml.sax.SAXException
    {
        try
        {
            if (m_needToOutputDocTypeDecl)
            {
                outputDocTypeDecl(m_elementName, false);
                m_needToOutputDocTypeDecl = false;
            }
            if (!m_inDoctype)
                m_writer.write(""]>"");
            else
            {
                m_writer.write('>');
            }

            m_writer.write(m_lineSep, 0, m_lineSepLen);
        }
        catch (IOException e)
        {
            throw new SAXException(e);
        }

    }

    
    public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException
    { 
    }

    
    public void ignorableWhitespace(char ch[], int start, int length)
        throws org.xml.sax.SAXException
    {

        if (0 == length)
            return;
        characters(ch, start, length);
    }

    
    public void skippedEntity(String name) throws org.xml.sax.SAXException
    { 
    }

    
    public void startCDATA() throws org.xml.sax.SAXException
    {
        m_cdataStartCalled = true;
    }

    
    public void startEntity(String name) throws org.xml.sax.SAXException
    {
        if (name.equals(""[dtd]""))
            m_inExternalDTD = true;
        m_inEntityRef = true;
    }

    
    protected void closeStartTag() throws SAXException
    {

        if (m_startTagOpen)
        {

            try
            {
                processAttributes();
                m_writer.write('>');
            }
            catch (IOException e)
            {
                throw new SAXException(e);
            }

            
            pushCdataSectionState();

            m_isprevtext = false;
            m_preserves.push(m_ispreserve);
            m_startTagOpen = false;

        }

    }

    
    public void startDTD(String name, String publicId, String systemId)
        throws org.xml.sax.SAXException
    {
        setDoctypeSystem(systemId);
        setDoctypePublic(publicId);

        m_elementName = name;
        m_inDoctype = true;
    }

    
    public int getIndentAmount()
    {
        return m_indentAmount;
    }

    
    public void setIndentAmount(int m_indentAmount)
    {
        this.m_indentAmount = m_indentAmount;
    }

    
    protected boolean shouldIndent()
    {
        return m_doIndent && (!m_ispreserve && !m_isprevtext);
    }

    
    private void setCdataSectionElements(String key, Properties props)
    {

        String s = props.getProperty(key);

        if (null != s)
        {
            
            Vector v = new Vector();
            int l = s.length();
            boolean inCurly = false;
            FastStringBuffer buf = new FastStringBuffer();

            
            
            
            for (int i = 0; i < l; i++)
            {
                char c = s.charAt(i);

                if (Character.isWhitespace(c))
                {
                    if (!inCurly)
                    {
                        if (buf.length() > 0)
                        {
                            addCdataSectionElement(buf.toString(), v);
                            buf.reset();
                        }
                        continue;
                    }
                }
                else if ('{' == c)
                    inCurly = true;
                else if ('}' == c)
                    inCurly = false;

                buf.append(c);
            }

            if (buf.length() > 0)
            {
                addCdataSectionElement(buf.toString(), v);
                buf.reset();
            }
            
            setCdataSectionElements(v);
        }

    }

    
    private void addCdataSectionElement(String URI_and_localName, Vector v)
    {

        StringTokenizer tokenizer =
            new StringTokenizer(URI_and_localName, ""{}"", false);
        QName qname;
        String s1 = tokenizer.nextToken();
        String s2 = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;

        if (null == s2)
        {
            
            v.addElement(null);
            v.addElement(s1);
        }
        else
        {
            
            v.addElement(s1);
            v.addElement(s2);
        }
    }

    
    public void setCdataSectionElements(Vector URI_and_localNames)
    {
        m_cdataSectionElements = URI_and_localNames;
    }

    
    protected String ensureAttributesNamespaceIsDeclared(
        String ns,
        String localName,
        String rawName)
        throws org.xml.sax.SAXException
    {

        if (ns != null && ns.length() > 0)
        {

            
            int index = 0;
            String prefixFromRawName =
                (index = rawName.indexOf("":"")) < 0
                    ? """"
                    : rawName.substring(0, index);

            if (index > 0)
            {
                
                String uri = m_prefixMap.lookupNamespace(prefixFromRawName);
                if (uri != null && uri.equals(ns))
                {
                    
                    
                    return null;
                }
                else
                {
                    
                    
                    this.startPrefixMapping(prefixFromRawName, ns, false);
                    this.addAttribute(
                        ""http:
                        prefixFromRawName,
                        ""xmlns:"" + prefixFromRawName,
                        ""CDATA"",
                        ns);
                    return prefixFromRawName;
                }
            }
            else
            {
                
                
                String prefix = m_prefixMap.lookupPrefix(ns);
                if (prefix == null)
                {
                    
                    
                    prefix = m_prefixMap.generateNextPrefix();
                    this.startPrefixMapping(prefix, ns, false);
                    this.addAttribute(
                        ""http:
                        prefix,
                        ""xmlns:"" + prefix,
                        ""CDATA"",
                        ns);
                }

                return prefix;

            }
        }
        return null;
    }

    private void ensurePrefixIsDeclared(String ns, String rawName)
        throws org.xml.sax.SAXException
    {

        if (ns != null && ns.length() > 0)
        {
            int index;
            String prefix =
                (index = rawName.indexOf("":"")) < 0
                    ? """"
                    : rawName.substring(0, index);

            if (null != prefix)
            {
                String foundURI = m_prefixMap.lookupNamespace(prefix);

                if ((null == foundURI) || !foundURI.equals(ns))
                {
                    this.startPrefixMapping(prefix, ns);

                    
                    

                    this.addAttributeAlways(
                        ""http:
                        prefix,
                        ""xmlns"" + (prefix.length() == 0 ? """" : "":"") + prefix,
                        ""CDATA"",
                        ns);
                }

            }
        }
    }

    
    public void flushPending()
    {
        try
        {

            if (m_needToCallStartDocument)
            {
                startDocumentInternal();
                m_needToCallStartDocument = false;
            }
            if (m_startTagOpen)
            {
                closeStartTag();
                m_startTagOpen = false;
            }

            if (m_cdataTagOpen)
            {
                closeCDATA();
                m_cdataTagOpen = false;
            }
        }
        catch (SAXException e)
        { 
            
        }

    }

    public void setContentHandler(ContentHandler ch)
    {
        
        
        
    }

    
    public void addAttributeAlways(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
    {

        int index;
        index = m_attributes.getIndex(rawName);
        if (index >= 0)
        {
            String old_value = null;
            if (m_tracer != null)
            {
                old_value = m_attributes.getValue(index);
                if (value.equals(old_value))
                    old_value = null;
            }

            
            m_attributes.setValue(index, value);
            if (old_value != null)
                firePseudoAttributes();

        }
        else
        {
            
            m_attributes.addAttribute(uri, localName, rawName, type, value);
            if (m_tracer != null)
                firePseudoAttributes();
        }

    }

    

    protected void firePseudoAttributes()
    {

        int nAttrs;

        if (m_tracer != null && (nAttrs = m_attributes.getLength()) > 0)
        {
            String encoding = getEncoding();
            
            StringBuffer sb = new StringBuffer();

            
            
            java.io.Writer writer = new ToStream.WritertoStringBuffer(sb);

            try
            {
                for (int i = 0; i < nAttrs; i++)
                {

                    
                    
                    final String name = m_attributes.getQName(i);
                    final String value = m_attributes.getValue(i);
                    sb.append(' ');
                    sb.append(name);
                    sb.append(""="""");
                    writeAttrString(writer, value, encoding);
                    sb.append('""');
                }
            }
            catch (IOException ioe)
            {
            }

            
            
            
            char ch[] = sb.toString().toCharArray();
            m_tracer.fireGenerateEvent(
                SerializerTrace.EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS,
                ch,
                0,
                ch.length);
        }
    }

    
    private class WritertoStringBuffer extends java.io.Writer
    {
        final private StringBuffer m_stringbuf;
        
        WritertoStringBuffer(StringBuffer sb)
        {
            m_stringbuf = sb;
        }

        public void write(char[] arg0, int arg1, int arg2) throws IOException
        {
            m_stringbuf.append(arg0, arg1, arg2);
        }
        
        public void flush() throws IOException
        {
        }
        
        public void close() throws IOException
        {
        }

        public void write(int i)
        {
            m_stringbuf.append((char) i);
        }
        
        public void write(String s)
        {
            m_stringbuf.append(s);
        }
    }

    
    public void setTransformer(Transformer transformer) {
        super.setTransformer(transformer);
        if (m_tracer != null
         && !(m_writer instanceof SerializerTraceWriter)  )
            m_writer = new SerializerTraceWriter(m_writer, m_tracer);        
        
        
    }
}
"
org.apache.xalan.res.XSLTErrorResources_it,4,4,0,1,11,4,0,1,2,1.282051282,3800,0.0,0,0.953488372,0.5,2,2,945.75,2,0.75,0,"
package org.apache.xalan.res;

import java.util.Locale;



public class XSLTErrorResources_it extends XSLTErrorResources
{


 public static final int MAX_CODE = 201;          

 
 public static final int MAX_WARNING = 29;

 
 public static final int MAX_OTHERS = 55;

 
 public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

 

public static final Object[][] contents = {

 
 
 

 {
   ""ERROR0000"", ""{0}""},


 
 


 {
   ER_NO_CURLYBRACE,
     ""Errore: Impossibile inserire '{' nell'espressione.""},


 
 


 {
   ER_ILLEGAL_ATTRIBUTE, ""{0} ha un attributo illegale: {1}.""},


 
 


 {
   ER_NULL_SOURCENODE_APPLYIMPORTS,
     ""sourceNode nullo in xsl:apply-imports""},


 
 


 {
   ER_CANNOT_ADD, ""Impossibile aggiungere {0} a {1}.""},


 
 


 {
   ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES,
     ""sourceNode nullo in handleApplyTemplatesInstruction.""},


 
 


 {
   ER_NO_NAME_ATTRIB, ""{0} deve avere un attributo nome.""},


 
 


 {
   ER_TEMPLATE_NOT_FOUND, ""Impossibile trovare il modello denominato: {0}.""},


 
 


 {
   ER_CANT_RESOLVE_NAME_AVT,
     ""Impossibile risolvere il nome AVT in xsl:call-template.""},


 
 


 {
   ER_REQUIRES_ATTRIB, ""{0} richiede l'attributo: {1}.""},


 
 


 {
   ER_MUST_HAVE_TEST_ATTRIB,
     ""{0} deve avere un attributo ''test''.""},


 
 


 {
   ER_BAD_VAL_ON_LEVEL_ATTRIB,
     ""Valore non valido su attributo livello: {0}""},


 
 


 {
   ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
     ""Il nome dell'istruzione di elaborazione non può essere 'xml'.""},


 
 


 {
   ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
     ""Il nome dell'istruzione di elaborazione deve essere un NCName valido: {0}.""},


 
 


 {
   ER_NEED_MATCH_ATTRIB,
     ""{0} deve avere un attributo corrispondenza se ha una modalità.""},


 
 


 {
   ER_NEED_NAME_OR_MATCH_ATTRIB,
     ""{0} richiede un attributo nome o corrispondenza.""},


 
 


 {
   ER_CANT_RESOLVE_NSPREFIX,
     ""Impossibile risolvere il prefisso namespace: {0}.""},


 
 


 {
   ER_ILLEGAL_VALUE, ""xml:space ha valore non valido: {0}.""},


 
 


 {
   ER_NO_OWNERDOC,
     ""Il nodo secondario non ha alcun documento di proprietà.""},


 
 


 {
   ER_ELEMTEMPLATEELEM_ERR, ""Errore ElemTemplateElement: {0}.""},


 
 


 {
   ER_NULL_CHILD, ""Tentativo di aggiungere un elemento secondario nullo.""},


 
 


 {
   ER_NEED_SELECT_ATTRIB, ""{0} richiede un attributo selezione.""},


 
 


 {
   ER_NEED_TEST_ATTRIB,
     ""xsl:when deve avere un attributo 'test'.""},


 
 


 {
   ER_NEED_NAME_ATTRIB,
     ""xsl:with-param deve avere un attributo 'name'.""},


 
 


 {
   ER_NO_CONTEXT_OWNERDOC,
     ""Il contesto non ha un documento di proprietà.""},


 
 


 {
   ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
     ""Impossibile creare un XML TransformerFactory Liaison: {0}""},


 
 


 {
   ER_PROCESS_NOT_SUCCESSFUL,
     ""Xalan: il processo non è riuscito.""},


 
 


 {
   ER_NOT_SUCCESSFUL, ""Xalan: non è riuscito.""},


 
 


 {
   ER_ENCODING_NOT_SUPPORTED, ""Codifica non supportata: {0}""},


 
 


 {
   ER_COULD_NOT_CREATE_TRACELISTENER,
     ""Impossibile creare TraceListener: {0}""},


 
 


 {
   ER_KEY_REQUIRES_NAME_ATTRIB,
     ""xsl:key richiede un attributo 'nome'.""},


 
 


 {
   ER_KEY_REQUIRES_MATCH_ATTRIB,
     ""xsl:key richiede un attributo 'corrispondenza'.""},


 
 


 {
   ER_KEY_REQUIRES_USE_ATTRIB,
     ""xsl:key richiede un attributo 'uso'.""},


 
 


 {
   ER_REQUIRES_ELEMENTS_ATTRIB,
     ""(StylesheetHandler) {0} richiede un attributo ''elementi''.""},


 
 


 {
   ER_MISSING_PREFIX_ATTRIB,
     ""(StylesheetHandler) {0} attributo ''prefisso'' mancante""},


 
 


 {
   ER_BAD_STYLESHEET_URL, ""URL del foglio di stile non valido: {0}""},


 
 


 {
   ER_FILE_NOT_FOUND, ""File del foglio di stile non trovato: {0}""},


 
 


 {
   ER_IOEXCEPTION,
     ""Rilevata eccezione IO con il file del foglio di stile: {0}""},


 
 


 {
   ER_NO_HREF_ATTRIB,
     ""(StylesheetHandler) Impossibile trovare l'attributo href per {0}""},


 
 


 {
   ER_STYLESHEET_INCLUDES_ITSELF,
     ""(StylesheetHandler) {0} include se stesso direttamente o indirettamente.""},


 
 


 {
   ER_PROCESSINCLUDE_ERROR,
     ""Errore StylesheetHandler.processInclude, {0}""},


 
 


 {
   ER_MISSING_LANG_ATTRIB,
     ""(StylesheetHandler) {0} attributo ''lang'' mancante""},


 
 


 {
   ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
     ""(StylesheetHandler) elemento {0} fuori posto? ''Componente'' dell'elemento contenitore mancante""},


 
 


 {
   ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
     ""È possibile eseguire l'output solo in Element, DocumentFragment, Document o PrintWriter.""},


 
 


 {
   ER_PROCESS_ERROR, ""Errore in StylesheetRoot.process""},


 
 


 {
   ER_UNIMPLNODE_ERROR, ""Errore in UnImplNode: {0}""},


 
 


 {
   ER_NO_SELECT_EXPRESSION,
     ""Errore. L'espressione di selezione del percorso (-select) non è stata trovata.""},


 
 


 {
   ER_CANNOT_SERIALIZE_XSLPROCESSOR,
     ""Impossibile serializzare un XSLProcessor!""},


 
 


 {
   ER_NO_INPUT_STYLESHEET,
     ""Input del foglio di stile non specificato.""},


 
 


 {
   ER_FAILED_PROCESS_STYLESHEET,
     ""Elaborazione del foglio di stile non riuscita.""},


 
 


 {
   ER_COULDNT_PARSE_DOC, ""Impossibile analizzare il documento {0}.""},


 
 


 {
   ER_COULDNT_FIND_FRAGMENT, ""Impossibile trovare il frammento: {0}""},


 
 


 {
   ER_NODE_NOT_ELEMENT,
     ""Il nodo a cui puntava l'identificatore del frammento non era un elemento: {0}""},


 
 


 {
   ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
     ""for-each deve avere un attributo corrispondenza o nome.""},


 
 


 {
   ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB,
     ""I modelli devono avere un attributo corrispondenza o nome.""},


 
 


 {
   ER_NO_CLONE_OF_DOCUMENT_FRAG,
     ""Nessun duplicato di frammento di un documento.""},


 
 


 {
   ER_CANT_CREATE_ITEM,
     ""Impossibile creare un elemento nell'albero del risultato: {0}""},


 
 


 {
   ER_XMLSPACE_ILLEGAL_VALUE,
     ""xml:space nell'XML sorgente ha valore non valido: {0}""},


 
 


 {
   ER_NO_XSLKEY_DECLARATION,
     ""Dichiarazione xsl:key mancante per {0}!""},


 
 


 {
   ER_CANT_CREATE_URL, ""Errore. Impossibile creare URL per: {0}""},


 
 


 {
   ER_XSLFUNCTIONS_UNSUPPORTED, ""xsl:functions non supportato""},


 
 


 {
   ER_PROCESSOR_ERROR, ""Errore XSLT TransformerFactory""},


 
 


 {
   ER_NOT_ALLOWED_INSIDE_STYLESHEET,
     ""(StylesheetHandler) {0} non consentito in un foglio di stile.""},


 
 


 {
   ER_RESULTNS_NOT_SUPPORTED,
     ""result-ns non è più supportato. Utilizzare xsl:output.""},


 
 


 {
   ER_DEFAULTSPACE_NOT_SUPPORTED,
     ""default-space non è più supportato. Utilizzare xsl:strip-space o xsl:preserve-space.""},


 
 


 {
   ER_INDENTRESULT_NOT_SUPPORTED,
     ""indent-result non è più supportato. Utilizzare xsl:output.""},


 
 


 {
   ER_ILLEGAL_ATTRIB,
     ""(StylesheetHandler) {0} ha un attributo non valido {1}""},


 
 


 {
   ER_UNKNOWN_XSL_ELEM, ""Elemento XSL sconosciuto: {0}""},


 
 


 {
   ER_BAD_XSLSORT_USE,
     ""(StylesheetHandler) xsl:sort può essere utilizzato solo con xsl:apply-templates o xsl:for-each.""},


 
 


 {
   ER_MISPLACED_XSLWHEN,
     ""(StylesheetHandler) xsl:when fuori posto.""},


 
 


 {
   ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
     ""(StylesheetHandler) xsl:when non dipende da xsl:choose!""},


 
 


 {
   ER_MISPLACED_XSLOTHERWISE,
     ""(StylesheetHandler) xsl:otherwise fuori posto.""},


 
 


 {
   ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
     ""(StylesheetHandler) xsl:otherwise non dipende da xsl:choose.""},


 
 


 {
   ER_NOT_ALLOWED_INSIDE_TEMPLATE,
     ""(StylesheetHandler) {0} non è consentito in un modello.""},


 
 


 {
   ER_UNKNOWN_EXT_NS_PREFIX,
     ""(StylesheetHandler) {0} prefisso namespace di estensione {1} sconosciuto""},


 
 


 {
   ER_IMPORTS_AS_FIRST_ELEM,
     ""(StylesheetHandler) Le importazioni sono possibili solo come primi elementi di un foglio di stile.""},


 
 


 {
   ER_IMPORTING_ITSELF,
     ""(StylesheetHandler) {0} sta importando se stesso direttamente o indirettamente.""},


 
 


 {
   ER_XMLSPACE_ILLEGAL_VAL,
     ""(StylesheetHandler) "" + ""xml:space ha valore non valido: {0}""},


 
 


 {
   ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
     ""processStylesheet non è riuscito.""},


 
 


 {
   ER_SAX_EXCEPTION, ""Eccezione SAX""},


 
 


 {
   ER_XSLT_ERROR, ""Errore XSLT""},


 
 


 {
   ER_CURRENCY_SIGN_ILLEGAL,
     ""Il segno di valuta non è consentito nelle stringhe modello di formato.""},


 
 


 {
   ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
     ""Funzione documento non supportata nel foglio di stile DOM!""},


 
 


 {
   ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
     ""Impossibile risolvere il prefisso del risolutore non-Prefix.""},


 
 


 {
   ER_REDIRECT_COULDNT_GET_FILENAME,
     ""Estensione di reindirizzamento: Impossibile trovare il nome file. Il file o l'attributo di selezione devono generare una stringa valida.""},


 
 


 {
   ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
     ""Impossibile generare FormatterListener nell'estensione di reindirizzamento.""},


 
 


 {
   ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
     ""Il prefisso in exclude-result-prefixes non è valido: {0}""},


 
 


 {
   ER_MISSING_NS_URI,
     ""URI namespace mancante per il prefisso specificato.""},


 
 


 {
   ER_MISSING_ARG_FOR_OPTION,
     ""Argomento mancante per l'opzione: {0}""},


 
 


 {
   ER_INVALID_OPTION, ""Opzione non valida: {0}""},


 
 


 {
   ER_MALFORMED_FORMAT_STRING, ""Stringa di formato non valida: {0}""},


 
 


 {
   ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
     ""xsl:stylesheet richiede un attributo 'versione'.""},


 
 


 {
   ER_ILLEGAL_ATTRIBUTE_VALUE,
     ""Attributo: {0} ha un valore non valido: {1}""},


 
 


 {
   ER_CHOOSE_REQUIRES_WHEN, ""xsl:choose richiede xsl:when""},


 
 


 {
   ER_NO_APPLY_IMPORT_IN_FOR_EACH,
     ""xsl:apply-imports non consentito in xsl:for-each""},


 
 


 {
   ER_CANT_USE_DTM_FOR_OUTPUT,
     ""Impossibile utilizzare un collegamento DTM per un nodo DOM di output. Utilizzare org.apache.xpath.DOM2Helper.""},


 
 


 {
   ER_CANT_USE_DTM_FOR_INPUT,
     ""Impossibile utilizzare un collegamento DTM per un nodo DOM di input. Utilizzare org.apache.xpath.DOM2Helper.""},


 
 


 {
   ER_CALL_TO_EXT_FAILED,
     ""Chiamata all'elemento di estensione non riuscita: {0}""},


 
 


 {
   ER_PREFIX_MUST_RESOLVE,
     ""Il prefisso deve risolvere in namespace: {0}""},


 
 


 {
   ER_INVALID_UTF16_SURROGATE,
     ""Rilevato surrogato di UTF-16 non valido: {0} ?""},


 
 


 {
   ER_XSLATTRSET_USED_ITSELF,
     ""xsl:attribute-set {0} ha utilizzato se stesso, generando un loop infinito.""},


 
 


 {
   ER_CANNOT_MIX_XERCESDOM,
     ""Impossibile combinare un input non Xerces-DOM con un input Xerces-DOM.""},


 
 


 {
   ER_TOO_MANY_LISTENERS,
     ""addTraceListenersToStylesheet - TooManyListenersException""},


 
 


 {
   ER_IN_ELEMTEMPLATEELEM_READOBJECT,
     ""In ElemTemplateElement.readObject: {0}""},


 
 


 {
   ER_DUPLICATE_NAMED_TEMPLATE,
     ""Trovato più di un modello denominato: {0}""},


 
 


 {
   ER_INVALID_KEY_CALL,
     ""Chiamata di funzione non valida: le chiamate chiave() ricorsive non sono consentite.""},

 
 
 


 {
   ER_REFERENCING_ITSELF,
     ""La variabile {0} fa riferimento a se stessa direttamente o indirettamente.""},

 
 
 


 {
   ER_ILLEGAL_DOMSOURCE_INPUT,
     ""Il nodo di input non può essere nullo per DOMSource per newTemplates.""},

	
	
 


 {
   ER_CLASS_NOT_FOUND_FOR_OPTION,
			""File di classe non trovato per l'opzione {0}""},

	
	
 


 {
   ER_REQUIRED_ELEM_NOT_FOUND,
			""Elemento richiesto non trovato: {0}""},

 
 
 


 {
   ER_INPUT_CANNOT_BE_NULL,
			""InputStream non può essere nullo.""},

 
 
 


 {
   ER_URI_CANNOT_BE_NULL,
			""L'URI non può essere nullo.""},

 
 
 


 {
   ER_FILE_CANNOT_BE_NULL,
			""Il file non può essere nullo.""},

 
  
 


 {
   ER_SOURCE_CANNOT_BE_NULL,
			""InputSource non può essere nullo.""},

 
 
 


 {
   ER_CANNOT_INIT_BSFMGR,
			""Impossibile inizializzare BSF Manager.""},

 
 
 


 {
   ER_CANNOT_CMPL_EXTENSN,
			""Impossibile compilare l'estensione.""},

 
 
 


 {
   ER_CANNOT_CREATE_EXTENSN,
     ""Impossibile creare l'estensione: {0} a causa di: {1}""},

 
 
 


 {
   ER_INSTANCE_MTHD_CALL_REQUIRES,
     ""La chiamata del metodo istanza al metodo {0} richiede un'istanza oggetto come primo argomento.""},

 
 
 


 {
   ER_INVALID_ELEMENT_NAME,
     ""È stato specificato un nome elemento non valido {0}""},

 
  
 


 {
   ER_ELEMENT_NAME_METHOD_STATIC,
     ""Il metodo del nome elemento deve essere statico {0}""},

 
  
 


 {
   ER_EXTENSION_FUNC_UNKNOWN,
            ""Funzione estensione {0} : {1} sconosciuta.""},

 
  
 


 {
   ER_MORE_MATCH_CONSTRUCTOR,
            ""Più di una corrispondenza migliore per costruttore per {0}.""},

 
  
 


 {
   ER_MORE_MATCH_METHOD,
            ""Più di una corrispondenza migliore per il metodo {0}""},

 
  
 


 {
   ER_MORE_MATCH_ELEMENT,
            ""Più di una corrispondenza migliore per il metodo elemento {0}""},

 
  
 


 {
   ER_INVALID_CONTEXT_PASSED,
            ""Contesto non valido passato da valutare {0}.""},

 
  
 


 {
   ER_POOL_EXISTS,
            ""Pool già esistente.""},

 
  
 


 {
   ER_NO_DRIVER_NAME,
            ""Non è stato specificato alcun nome di driver.""},

 
  
 


 {
   ER_NO_URL,
            ""Non è stato specificato alcun URL.""},

 
  
 


 {
   ER_POOL_SIZE_LESSTHAN_ONE,
            ""Le dimensioni del pool sono minori di uno.""},

 
  
 


 {
   ER_INVALID_DRIVER,
            ""È stato specificato un nome di driver non valido.""},

 
  
 


 {
   ER_NO_STYLESHEETROOT,
            ""Impossibile trovare la root del foglio di stile.""},

 
  
 


 {
   ER_ILLEGAL_XMLSPACE_VALUE,
        ""Valore non valido per xml:space.""},

 
  
 


 {
   ER_PROCESSFROMNODE_FAILED,
        ""processFromNode non riuscito.""},

 
  
 


 {
   ER_RESOURCE_COULD_NOT_LOAD,
       ""Impossibile caricare la risorsa [ {0} ]: {1} 
 {2} 	 {3}""},

  
 
  
 


 {
   ER_BUFFER_SIZE_LESSTHAN_ZERO,
       ""Dimensioni del buffer <=0""},

 
  
 


 {
   ER_UNKNOWN_ERROR_CALLING_EXTENSION,
       ""Errore sconosciuto nella chiamata dell'estensione.""},

 
  
 


 {
   ER_NO_NAMESPACE_DECL,
       ""Il prefisso {0} non ha una corrispondente dichiarazione namespace.""},

 
  
 


 {
   ER_ELEM_CONTENT_NOT_ALLOWED,
       ""Contenuto dell'elemento non consentito per lang=javaclass {0}.""},
   
 
  
 


 {
   ER_STYLESHEET_DIRECTED_TERMINATION,
       ""Conclusione richiesta dal foglio di stile.""},

 
  
 


 {
   ER_ONE_OR_TWO,
       ""1 o 2""},

 
  
 


 {
   ER_TWO_OR_THREE,
       ""2 o 3""},

 
  
 


 {
   ER_COULD_NOT_LOAD_RESOURCE,
       ""Impossibile caricare {0} (verificare CLASSPATH). Attualmente sono in uso i valori predefiniti.""},

 
  
 


 {
   ER_CANNOT_INIT_DEFAULT_TEMPLATES,
       ""Impossibile inizializzare i modelli predefiniti.""},

 
  
 


 {
   ER_RESULT_NULL,
       ""Il risultato non dovrebbe essere nullo.""},

   
  
 


 {
   ER_RESULT_COULD_NOT_BE_SET,
       ""Impossibile stabilire il risultato.""},

 
  
 


 {
   ER_NO_OUTPUT_SPECIFIED,
       ""Nessun output specificato.""},

 
  
 


 {
   ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
       ""Impossibile trasformare in un risultato di tipo {0}.""},

 
  
 


 {
   ER_CANNOT_TRANSFORM_SOURCE_TYPE,
       ""Impossibile trasformare un sorgente di tipo {0}.""},

 
  
 


 {
   ER_NULL_CONTENT_HANDLER,
       ""Contenuto gestore nullo""},

 
  
 


 {
   ER_NULL_ERROR_HANDLER,
       ""Errore gestore nullo""},

 
  
 


 {
   ER_CANNOT_CALL_PARSE,
       ""Impossibile chiamare l'analisi se non è impostato ContentHandler.""},

 
  
 


 {
   ER_NO_PARENT_FOR_FILTER,
       ""Nessun elemento principale per il filtro.""},

 
 
  
 


 {
   ER_NO_STYLESHEET_IN_MEDIA,
        ""Nessun foglio di stile trovato in: {0}, media= {1}""},

 
  
 


 {
   ER_NO_STYLESHEET_PI,
        ""Nessun xml-stylesheet PI trovato in : {0}""},

 
  
 


 {
   ER_NOT_SUPPORTED,
      ""Non supportato: {0}""},
 
  
 


 {
   ER_PROPERTY_VALUE_BOOLEAN,
      ""Il valore della proprietà {0} deve essere un'istanza booleana""},

 
  
 


 {
   ER_COULD_NOT_FIND_EXTERN_SCRIPT,
      ""L'attributo src non è ancora supportato per {0}.""},

 
 
 


 {
   ER_RESOURCE_COULD_NOT_FIND,
       ""Impossibile trovare la risorsa [ {0} ].
 {1}""},

 
  
 


 {
   ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
       ""La proprietà dell'output non è riconosciuta: {0}""},

 
  
 


 {
   ER_FAILED_CREATING_ELEMLITRSLT,
       ""Creazione non riuscita dell'istanza ElemLiteralResult.""},
  
 
	 
    
    
    

  
 


 {
   ER_VALUE_SHOULD_BE_NUMBER,
       ""Il valore di {0} deve contenere un numero analizzabile.""},

 
  
 


 {
   ER_VALUE_SHOULD_EQUAL,
       ""Il valore di {0} deve essere sì o no.""},


  
 


 {
   ER_FAILED_CALLING_METHOD,
       ""Chiamata non riuscita del metodo {0}.""},

 
  
 


 {
   ER_FAILED_CREATING_ELEMTMPL,
       ""Creazione non riuscita dell'istanza ElemTemplateElement.""},

 
  
 


 {
   ER_CHARS_NOT_ALLOWED,
       ""I caratteri non sono consentiti in questo punto del documento.""},

 
 
 


 {
   ER_ATTR_NOT_ALLOWED,
       """"{0}"": questo attributo non è consentito sull'elemento {1}.""},


 
 


 {
   ER_BAD_VALUE,
    ""{0} valore non valido {1} ""},

 
 
 


 {
   ER_ATTRIB_VALUE_NOT_FOUND,
    ""{0} valore dell'attributo non trovato.""},

 
 
 


 {
   ER_ATTRIB_VALUE_NOT_RECOGNIZED,
    ""{0} valore dell'attributo non riconosciuto ""},

 
  
  


  {
      ER_NULL_URI_NAMESPACE,
      ""Tentativo di generare un prefisso di namespace con URI nullo""},
  
 
   
 
   
   
 
 
   {
     ER_NUMBER_TOO_BIG,
      ""Tentativo di formattare un numero maggiore dell'intero lungo più grande""},
  
 
 
 
   
 
 
   {
     ER_CANNOT_FIND_SAX1_DRIVER,
      ""Impossibile trovare classe driver SAX1 {0}""},
  
 
 
   
 
 
   {
     ER_SAX1_DRIVER_NOT_LOADED,
      ""La classe di driver SAX1 {0} è stata trovata ma è impossibile caricarla""},
  
 
 
   
 
 
   {
     ER_SAX1_DRIVER_NOT_INSTANTIATED,
      ""La classe di driver SAX1 {0} è stata caricata ma non è possibile creare istanze""},
  
 
 
 
   
 
 
   {
     ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
      ""La classe di driver SAX1 {0} non implementa org.xml.sax.Parser""},
  
 
 
   
 
 
   {
     ER_PARSER_PROPERTY_NOT_SPECIFIED,
      ""Proprietà di sistema org.xml.sax.parser non specificata""},
  
 
 
   
 
 
   {
     ER_PARSER_ARG_CANNOT_BE_NULL,
      ""L'argomento del Parser non deve essere nullo""},
  
 
 
 
   
 
 
   {
     ER_FEATURE,
      ""Caratteristica:a {0}""},
  
 
 
 
   
 
 
   {
     ER_PROPERTY,
      ""Proprietà:a {0}""},
  
 
 
   
 
 
   {
     ER_NULL_ENTITY_RESOLVER,
      ""Il risolutore dell'entità è nullo""},
  
 
 
   
 
 
   {
     ER_NULL_DTD_HANDLER,
      ""Il gestore DTD è nullo""},
  
 
 
   
 
   {
     ER_NO_DRIVER_NAME_SPECIFIED,
      ""Nessun nome di driver specificato.""},
  
 
 
 
   
 
   {
     ER_NO_URL_SPECIFIED,
      ""Nessun URL specificato.""},
  
 
 
 
   
 
   {
     ER_POOLSIZE_LESS_THAN_ONE,
      ""La dimensione pool è inferiore a 1.""},
  
 
 
 
   
 
   {
     ER_INVALID_DRIVER_NAME,
      ""Il nome specificato del driver non è valido.""},
  
 
 
 
 
   
 
   {
     ER_ERRORLISTENER,
      ""ErrorListener""},
  
 
 
 
   
 
   {
     ER_ASSERT_NO_TEMPLATE_PARENT,
      ""Errore del programmatore. L'espressione non presenta ElemTemplateElement superiore.""},
  
 
 
 
   
 
   {
     ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
      ""Affermazione del programmatore in RundundentExprEliminator: {0}""},
  
 
   
   
 
   {
     ER_NOT_ALLOWED_IN_POSITION,
      ""{0} non è consentito in questa posizione nel foglio di stile.""},
  
 
   
   
 
   {
     ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
      ""Il testo senza spazi non è consentito nel foglio di stile.""},
  
 
   
   
   
   
 
   {
     INVALID_TCHAR,
      ""Valore non consentito: {1} utilizzato per attributo CHAR: {0}. L'attributo di tipo CHAR deve contenere 1 solo carattere.""},
  
 
     
     
     
     
     
 
   
   
   
 
   {
     INVALID_QNAME,
      ""Valore non consentito:a {1} utilizzato per attributo QNAME:a {0}""},
  
 
     
     
     
     
     
     

  
  
 
   {
     INVALID_ENUM,
      ""Valore non consentito:a {1} utilizzato per attributo ENUM:a {0}. I valori validi sono:a {2}.""},
  
 
 
 
 
 
 
 
   
   
 
    {
      INVALID_NMTOKEN,
       ""Valore non consentito:a {1} utilizzato per attributo NMTOKEN:a {0} ""},
   
  
  
  
  
  
  
  
    
    
  
    {
      INVALID_NCNAME,
       ""Valore non consentito:a {1} utilizzato per attributo NCNAME:a {0} ""},
   
  
  
  
  
  
  
  
    
    
  
  
    {
      INVALID_BOOLEAN,
       ""Valore non consentito:a {1} utilizzato per attributo boolean:a {0} ""},
   
  
  
  
  
  
  
  
    
    
  
    {
      INVALID_NUMBER,
       ""Valore non consentito:a {1} utilizzato per attributo number:a {0} ""},
   
  
  
    
  
  
  
  
  
  
  
    
    
  
    {
     ER_ARG_LITERAL,
       ""L'argomento di {0} nel pattern di corrispondenza deve essere letterale.""},
   
  
  
  
  
  
  
    
    
  
    {
      ER_DUPLICATE_GLOBAL_VAR,
       ""Dichiarazione variabile globale duplicata.""},
   
  
  
  
  
  
  
    
    
  
    {
      ER_DUPLICATE_VAR,
       ""Dichiarazione variabile duplicata.""},
   
 
      
      
      
  
    
    
  
    {
      ER_TEMPLATE_NAME_MATCH,
       ""xsl:template deve presentare un name o attributo match (o entrambi)""},
   
 
      
      
      
      
      
  
    
    
  
    {
      ER_INVALID_PREFIX,
       ""Il prefisso in exclude-result-prefixes non è valido:a {0}""},
   
  
      
      
      
      
      
  
    
    
  
    {
      ER_NO_ATTRIB_SET,
       ""la serie di attributi denominata {0} è inesistente""},
   

 

 
 


 {
   WG_FOUND_CURLYBRACE,
     ""Trovato '}' ma non vi è alcun modello di attributi aperto.""},


 
 


 {
   WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
     ""Avvertenza: l'attributo di conteggio non corrisponde a un predecessore in xsl:number! Target = {0}.""},


 
 


 {
   WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
     ""Sintassi precedente: il nome dell'attributo 'expr' è stato cambiato in 'select'.""},


 
 


 {
   WG_NO_LOCALE_IN_FORMATNUMBER,
     ""Xalan non gestisce ancora il nome locale nella funzione format-number.""},


 
 


 {
   WG_LOCALE_NOT_FOUND,
     ""Avvertenza: impossibile trovare la versione locale per xml:lang={0}.""},


 
 


 {
   WG_CANNOT_MAKE_URL_FROM,
     ""Impossibile creare l'URL da: {0}.""},


 
 


 {
   WG_CANNOT_LOAD_REQUESTED_DOC,
     ""Impossibile caricare il documento richiesto: {0}""},


 
 


 {
   WG_CANNOT_FIND_COLLATOR,
     ""Impossibile trovare il collatore per <sort xml:lang={0}.""},


 
 


 {
   WG_FUNCTIONS_SHOULD_USE_URL,
     ""Sintassi precedente: l'istruzione delle funzioni deve utilizzare l'URL {0}""},


 
 


 {
   WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
     ""codifica non supportata: {0}, utilizzando UTF-8""},


 
 


 {
   WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
     ""Codifica non supportata: {0}, utilizzando Java {1}""},


 
 


 {
   WG_SPECIFICITY_CONFLICTS,
     ""Trovati conflitti di specificità: {0} Sarà utilizzato l'ultimo trovato nel foglio di stile.""},


 
 


 {
   WG_PARSING_AND_PREPARING,
     ""========= Analisi e preparazione {0} ==========""},


 
 


 {
   WG_ATTR_TEMPLATE, ""Modello attr., {0}""},


 
 


 {
   WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
     ""Conflitto di corrispondenza tra xsl:strip-space e xsl:preserve-space.""},


 
 


 {
   WG_ATTRIB_NOT_HANDLED,
     ""Xalan non gestisce ancora l'attributo {0}.""},


 
 


 {
   WG_NO_DECIMALFORMAT_DECLARATION,
     ""Non è stata trovata alcuna dichiarazione per il formato decimale: {0}""},


 
 


 {
   WG_OLD_XSLT_NS, ""XSLT Namespace mancante o non valido. ""},


 
 


 {
   WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
     ""È consentita solo una dichiarazione xsl:decimal-format predefinita.""},


 
 


 {
   WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
     ""I nomi xsl:decimal-format devono essere univoci. Il nome ""{0}"" è duplicato.""},


 
 


 {
   WG_ILLEGAL_ATTRIBUTE,
     ""{0} ha un attributo non valido: {1}""},


 
 


 {
   WG_COULD_NOT_RESOLVE_PREFIX,
     ""Impossibile risolvere il prefisso namespace: {0}. Nodo ignorato.""},


 
 


 {
   WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
     ""xsl:stylesheet richiede un attributo 'versione'.""},


 
 


 {
   WG_ILLEGAL_ATTRIBUTE_NAME,
     ""Nome attributo non valido: {0}""},


 
 


 {
   WG_ILLEGAL_ATTRIBUTE_VALUE,
     ""Valore non valido per l'attributo {0}: {1}.""},


 
 


 {
   WG_EMPTY_SECOND_ARG,
     ""Il nodeset risultante dal secondo argomento della funzione documento è vuoto. Sarà utilizzato il primo argomento.""},


   
 
     
     
     
 
 
   
   
 
   {
      WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
       ""Il valore dell'attributo 'name' del nome xsl:processing-instruction name non deve essere 'xml'""},
  
 
     
     
     
     
 
   
   
 
   {
      WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
       ""Il valore dell'attributo ''name'' di xsl:processing-instruction deve essere un NCName valido:a {0}""},
  
 
     
     
     
     
     
 
   
   
 
   {
     WG_ILLEGAL_ATTRIBUTE_POSITION,
       ""Impossibile aggiungere l'attributo {0} dopo i nodi secondari o prima della produzione di un elemento.  L'attributo verrà ignorato.""},
  
 
     
 
 
     { ""ui_language"",  ""it""},
     { ""help_language"",  ""it""},
     { ""language"",  ""it""},
     { ""BAD_CODE"",
     ""I parametri di createMessage sono esterni ai limiti""},
   { ""FORMAT_FAILED"",
     ""Eccezione generata durante la chiamata di messageFormat""},
   { ""version"",
    "">>>>>>> Xalan Versione ""},
   { ""version2"", ""<<<<<<<""},
   { ""yes"", ""sì""},
   { ""line"", ""Linea #""},
   { ""column"", ""Colonna #""},
   { ""xsldone"", ""XSLProcessor: done""},
   { ""xslProc_option"",
   ""opzioni dalla riga di comando della classe Process di Xalan-J:""},
   { ""optionIN"", ""    -IN inputXMLURL""},
   { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
   { ""optionOUT"", ""   [-OUT outputFileName]""},
   { ""optionLXCIN"",
     ""   [-LXCIN compiledStylesheetFileNameIn]""},
   { ""optionLXCOUT"",
     ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
   { ""optionPARSER"",
     ""   [-PARSER nome di classe pienamente qualificato del collegamento parser]""},
   { ""optionE"", ""   [-E (Non espandere i rif entità)]""},
   { ""optionV"", ""   [-E (Non espandere i rif entità)]""},
   { ""optionQC"", ""   [-QC (Avvertenze di conflitti Quiet Pattern)]""},
   { ""optionQ"", ""   [-Q  (Modalità Quiet)]""},
   { ""optionLF"",
     ""   [-LF (Usa nuove righe solo su output {valore predefinito CR/LF})]""},
   { ""optionCR"",
     ""   [-CR (Usa ritorno a capo solo su output {valore predefinito CR/LF})]""},
   { ""optionESCAPE"",
     ""   [-ESCAPE (Quali carattere saltare {valore predefinito <>&""'\r\n}]""},
   { ""optionINDENT"",
     ""   [-INDENT (Controlla il numero di spazi del rientro {valore predefinito 0})]""},
  { ""optionTT"",
     ""   [-TT (Traccia i modelli man mano che sono chiamati)]""},
   { ""optionTG"", ""   [-TG (Traccia ogni evento di generazione)]""},
   { ""optionTS"", ""   [-TS (Traccia ogni evento di selezione)]""},
   { ""optionTTC"",
     ""   [-TTC (Traccia gli elementi secondari del modello man mano che sono elaborati)]""},
   { ""optionTCLASS"",
     ""   [-TCLASS (Classe TraceListener per le estensioni di traccia)]""},
   { ""optionVALIDATE"",
     ""   [-VALIDATE (Imposta se eseguire la validazione. Il valore predefinito è validazione disattivata.)]""},
   { ""optionEDUMP"",
     ""   [-EDUMP {nome file opzionale} (Esegue il dump dello stack in caso di errore)]""},
   { ""optionXML"",
     ""   [-XML (Utilizza il formattatore XML e aggiunge l'intestazione XML)]""},
  { ""optionTEXT"",
     ""   [-TEXT (Utilizza il formattatore di testo semplice)]""},
   { ""optionHTML"", ""   [-HTML (Utilizza il formattatore HTML)]""},
   { ""optionPARAM"",
     ""   [-PARAM espressione nome (Imposta un parametro di foglio di stile)]""},
   { ""noParsermsg1"", ""Processo XSL non riuscito.""},
   { ""noParsermsg2"", ""** Impossibile trovare il parser **""},
   { ""noParsermsg3"", ""Verificare il classpath.""},
   { ""noParsermsg4"",
     ""Se non si dispone del parser XML IBM per Java, scaricarlo da""},
   { ""noParsermsg5"",
     ""AlphaWorks IBM: http:
   { ""optionURIRESOLVER"",
   ""   [-URIRESOLVER nome classe completo (URIResolver da utilizzare per risolvere gli URI)]""},
   { ""optionENTITYRESOLVER"",
   ""   [-ENTITYRESOLVER nome classe completo (EntityResolver da utilizzare per risolvere le entità)]""},
   { ""optionCONTENTHANDLER"",
   ""   [-CONTENTHANDLER nome classe completo (ContentHandler da utilizzare per serializzare l'output)]""},
   { ""optionLINENUMBERS"",
   ""   [-L utilizza i numeri di linea per i documenti sorgente]""},
		

 
 
   { ""optionMEDIA"",
     "" [-MEDIA mediaType (utilizzare l'attributo media per trovare il foglio di stile associato a un documento.)]""},
   { ""optionFLAVOR"",
     "" [-FLAVOR flavorName (utilizzare esplicitamente s2s=SAX o d2d=DOM per effettuare la trasformazione.)] ""}, 
   { ""optionDIAG"",
     "" [-DIAG (stampa i millisecondi globali impiegati dalla trasformazione.)]""},
   { ""optionINCREMENTAL"",
     "" [-INCREMENTAL (richiede la costruzione DTM incrementale impostando a true http:
   { ""optionNOOPTIMIMIZE"",
     "" [-NOOPTIMIMIZE (non richiede l'elaborazione dell'ottimizzazione del foglio di stile impostando a false http:
   { ""optionRL"",
     "" [-RL recursionlimit (garantisce il limite numerico sulla profondità di ricorsione del foglio di stile.)]""},
   { ""optionXO"",
     "" [-XO [transletName] (assegna il nome al translet generato)]""},
   { ""optionXD"",
     "" [-XD destinationDirectory (specifica una directory di destinazione per il translet)]""},
   { ""optionXJ"",
     "" [-XJ jarfile (compatta la classi del translet in un file jar denominato <filejar>)]""},
   { ""optionXP"",
     "" [-XP package (specifica un prefisso del nome di pacchetto per tutte le classi translet generate)]""}
 
  
 };

 

 
 public static final String BAD_CODE = ""BAD_CODE"";

 
 public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

 
 public static final String ERROR_STRING = ""#error"";

 
 public static final String ERROR_HEADER = ""Errore: "";

 
 public static final String WARNING_HEADER = ""Avvertenza: "";

 
 public static final String XSL_HEADER = ""XSLT "";

 
 public static final String XML_HEADER = ""XML "";

 
 public static final String QUERY_HEADER = ""PATTERN "";

 
 public Object[][] getContents()
 {
   return contents;
 }


  
  private static final String getResourceSuffix(Locale locale)
  {

    String suffix = ""_"" + locale.getLanguage();
    String country = locale.getCountry();

    if (country.equals(""TW""))
      suffix += ""_"" + country;

    return suffix;
  }
}

"
org.apache.xalan.xsltc.compiler.ValueOf,5,3,0,20,33,0,1,20,4,0.416666667,237,1.0,1,0.933333333,0.333333333,2,6,45.8,4,2.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class ValueOf extends Instruction {
    private Expression _select;
    private boolean _escaping = true;
    private boolean _isString = false;

    public void display(int indent) {
        indent(indent);
        Util.println(""ValueOf"");
        indent(indent + IndentIncrement);
        Util.println(""select "" + _select.toString());
    }

    public void parseContents(Parser parser) {
        _select = parser.parseExpression(this, ""select"", null);

        
        if (_select.isDummy()) {
            reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""select"");
            return;
        }
        final String str = getAttribute(""disable-output-escaping"");
        if ((str != null) && (str.equals(""yes""))) _escaping = false;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
        Type type = _select.typeCheck(stable);

        
        if (type != null && !type.identicalTo(Type.Node)) {
            
            if (type.identicalTo(Type.NodeSet)) {
                _select = new CastExpr(_select, Type.Node);
            } else {
                _isString = true;
                if (!type.identicalTo(Type.String)) {
                    _select = new CastExpr(_select, Type.String);
                }
                _isString = true;
            }
        }
        return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
        final ConstantPoolGen cpg = classGen.getConstantPool();
        final InstructionList il = methodGen.getInstructionList();
        final int setEscaping = cpg.addInterfaceMethodref(OUTPUT_HANDLER,
                                                          ""setEscaping"",""(Z)Z"");

        
        if (!_escaping) {
            il.append(methodGen.loadHandler());
            il.append(new PUSH(cpg,false));
            il.append(new INVOKEINTERFACE(setEscaping,2));
        }

        
        
        
        
        
        if (_isString) {
            final int characters = cpg.addMethodref(TRANSLET_CLASS,
                                                    CHARACTERSW,
                                                    CHARACTERSW_SIG);

            il.append(classGen.loadTranslet());
            _select.translate(classGen, methodGen);
            il.append(methodGen.loadHandler());
            il.append(new INVOKEVIRTUAL(characters));
        } else {
            final int characters = cpg.addInterfaceMethodref(DOM_INTF,
                                                             CHARACTERS,
                                                             CHARACTERS_SIG);

            il.append(methodGen.loadDOM());
            _select.translate(classGen, methodGen);
            il.append(methodGen.loadHandler());
            il.append(new INVOKEINTERFACE(characters, 3));
        }

        
        if (!_escaping) {
            il.append(methodGen.loadHandler());
            il.append(SWAP);
            il.append(new INVOKEINTERFACE(setEscaping,2));
            il.append(POP);
        }
    }
}
"
org.apache.xml.utils.Hashtree2Node,2,1,0,1,23,1,1,0,2,2.0,145,0.0,0,0.0,0.5,0,0,71.5,8,4.0,2,"

package org.apache.xml.utils;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;


public abstract class Hashtree2Node
{

    
    public static void appendHashToNode(Hashtable hash, String name, 
            Node container, Document factory)
    {
        
        if ((null == container) || (null == factory) || (null == hash))
        {
            return;
        }

        
        String elemName = null;
        if ((null == name) || ("""".equals(name)))
            elemName = ""appendHashToNode"";
        else
            elemName = name;

        try
        {
            Element hashNode = factory.createElement(elemName);
            container.appendChild(hashNode);

            Enumeration enum = hash.keys();
            Vector v = new Vector();

            while (enum.hasMoreElements())
            {
                Object key = enum.nextElement();
                String keyStr = key.toString();
                Object item = hash.get(key);

                if (item instanceof Hashtable)
                {
                    
                    
                    
                    v.addElement(keyStr);
                    v.addElement((Hashtable) item);
                }
                else
                {
                    try
                    {
                        
                        Element node = factory.createElement(""item"");
                        node.setAttribute(""key"", keyStr);
                        node.appendChild(factory.createTextNode((String)item));
                        hashNode.appendChild(node);
                    }
                    catch (Exception e)
                    {
                        Element node = factory.createElement(""item"");
                        node.setAttribute(""key"", keyStr);
                        node.appendChild(factory.createTextNode(""ERROR: Reading "" + key + "" threw: "" + e.toString()));
                        hashNode.appendChild(node);
                    }
                }
            }

            
            enum = v.elements();
            while (enum.hasMoreElements())
            {
                
                String n = (String) enum.nextElement();
                Hashtable h = (Hashtable) enum.nextElement();

                appendHashToNode(h, n, hashNode, factory);
            }
        }
        catch (Exception e2)
        {
            
            
            e2.printStackTrace();
        }
    }    
}
"
org.apache.xalan.processor.ProcessorStylesheetElement,3,4,0,9,29,3,2,9,2,2.0,107,0.0,0,0.990566038,0.666666667,1,1,34.66666667,1,0.6667,0,"
package org.apache.xalan.processor;

import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetComposed;
import org.apache.xalan.templates.StylesheetRoot;

import org.xml.sax.Attributes;


class ProcessorStylesheetElement extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

		super.startElement(handler, uri, localName, rawName, attributes);
    try
    {
      int stylesheetType = handler.getStylesheetType();
      Stylesheet stylesheet;

      if (stylesheetType == StylesheetHandler.STYPE_ROOT)
      {
        try
        {
          stylesheet = new StylesheetRoot(handler.getSchema(), handler.getStylesheetProcessor().getErrorListener());
        }
        catch(TransformerConfigurationException tfe)
        {
          throw new TransformerException(tfe);
        }
      }
      else
      {
        Stylesheet parent = handler.getStylesheet();

        if (stylesheetType == StylesheetHandler.STYPE_IMPORT)
        {
          StylesheetComposed sc = new StylesheetComposed(parent);

          parent.setImport(sc);

          stylesheet = sc;
        }
        else
        {
          stylesheet = new Stylesheet(parent);

          parent.setInclude(stylesheet);
        }
      }

      stylesheet.setDOMBackPointer(handler.getOriginatingNode());
      stylesheet.setLocaterInfo(handler.getLocator());

      stylesheet.setPrefixes(handler.getNamespaceSupport());
      handler.pushStylesheet(stylesheet);
      setPropertiesFromAttributes(handler, rawName, attributes,
                                  handler.getStylesheet());
      handler.pushElemTemplateElement(handler.getStylesheet());
    }
    catch(TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {
		super.endElement(handler, uri, localName, rawName);
    handler.popElemTemplateElement();
    handler.popStylesheet();
  }
}
"
org.apache.xalan.transformer.TransformerIdentityImpl,43,2,0,12,140,573,1,11,41,0.755102041,1105,0.785714286,2,0.236363636,0.153100775,0,0,24.37209302,2,1.0465,4,"
package org.apache.xalan.transformer;

import java.io.IOException;
import java.util.Hashtable;
import java.util.Properties;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;
import org.apache.xml.serializer.Serializer;
import org.apache.xml.serializer.SerializerFactory;
import org.apache.xml.serializer.Method;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.OutputProperties;
import org.apache.xml.utils.DOMBuilder;
import org.apache.xml.utils.TreeWalker;

import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.Node;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.XMLReaderFactory;


public class TransformerIdentityImpl extends Transformer
        implements TransformerHandler, DeclHandler
{

  
  public TransformerIdentityImpl()
  {
    m_outputFormat = new OutputProperties(Method.XML);
  }

  
  public void setResult(Result result) throws IllegalArgumentException
  {
    if(null == result)
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_NULL, null)); 
    m_result = result;
  }

  
  public void setSystemId(String systemID)
  {
    m_systemID = systemID;
  }

  
  public String getSystemId()
  {
    return m_systemID;
  }

  
  public Transformer getTransformer()
  {
    return this;
  }

  
  private void createResultContentHandler(Result outputTarget)
          throws TransformerException
  {

    if (outputTarget instanceof SAXResult)
    {
      SAXResult saxResult = (SAXResult) outputTarget;

      m_resultContentHandler = saxResult.getHandler();
      m_resultLexicalHandler = saxResult.getLexicalHandler();

      if (m_resultContentHandler instanceof Serializer)
      {

        
        m_serializer = (Serializer) m_resultContentHandler;
      }
    }
    else if (outputTarget instanceof DOMResult)
    {
      DOMResult domResult = (DOMResult) outputTarget;
      Node outputNode = domResult.getNode();
      Document doc;
      short type;

      if (null != outputNode)
      {
        type = outputNode.getNodeType();
        doc = (Node.DOCUMENT_NODE == type)
              ? (Document) outputNode : outputNode.getOwnerDocument();
      }
      else
      {
        try
        {
          DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

          dbf.setNamespaceAware(true);

          DocumentBuilder db = dbf.newDocumentBuilder();

          doc = db.newDocument();
        }
        catch (ParserConfigurationException pce)
        {
          throw new TransformerException(pce);
        }

        outputNode = doc;
        type = outputNode.getNodeType();

        ((DOMResult) outputTarget).setNode(outputNode);
      }

      m_resultContentHandler =
        (Node.DOCUMENT_FRAGMENT_NODE == type)
        ? new DOMBuilder(doc, (DocumentFragment) outputNode)
        : new DOMBuilder(doc, outputNode);
      m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;
    }
    else if (outputTarget instanceof StreamResult)
    {
      StreamResult sresult = (StreamResult) outputTarget;
      String method = m_outputFormat.getProperty(OutputKeys.METHOD);

      try
      {
        Serializer serializer =
          SerializerFactory.getSerializer(m_outputFormat.getProperties());

        m_serializer = serializer;

        if (null != sresult.getWriter())
          serializer.setWriter(sresult.getWriter());
        else if (null != sresult.getOutputStream())
          serializer.setOutputStream(sresult.getOutputStream());
        else if (null != sresult.getSystemId())
        {
          String fileURL = sresult.getSystemId();

          if (fileURL.startsWith(""file:
          {
            if (fileURL.substring(8).indexOf("":"") >0)
              fileURL = fileURL.substring(8);
            else 
              fileURL = fileURL.substring(7);
          }

          m_outputStream = new java.io.FileOutputStream(fileURL);
          serializer.setOutputStream(m_outputStream);
        }
        else
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_OUTPUT_SPECIFIED, null)); 

        m_resultContentHandler = serializer.asContentHandler();
      }
      catch (IOException ioe)
      {
        throw new TransformerException(ioe);
      }
    }
    else
    {
      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_TO_RESULT_TYPE, new Object[]{outputTarget.getClass().getName()})); 
                                    
                                    
    }

    if (m_resultContentHandler instanceof DTDHandler)
      m_resultDTDHandler = (DTDHandler) m_resultContentHandler;
    
    if (m_resultContentHandler instanceof DeclHandler)
      m_resultDeclHandler = (DeclHandler) m_resultContentHandler;

    if (m_resultContentHandler instanceof LexicalHandler)
      m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;
  }

  
  public void transform(Source source, Result outputTarget)
          throws TransformerException
  {

    createResultContentHandler(outputTarget);

    try
    {
      if (source instanceof DOMSource)
      {
        DOMSource dsource = (DOMSource) source;
  
        m_systemID = dsource.getSystemId();
  
        Node dNode = dsource.getNode();
  
        if (null != dNode)
        {
          try
          {
            if(dNode.getNodeType() != Node.DOCUMENT_NODE)
              this.startDocument();
            try
            {
              if(dNode.getNodeType() == Node.ATTRIBUTE_NODE)
              {
                String data = dNode.getNodeValue();
                char[] chars = data.toCharArray();
                characters(chars, 0, chars.length);
              }
              else
              {
                TreeWalker walker = new TreeWalker(this, new org.apache.xml.utils.DOM2Helper(), m_systemID);
                walker.traverse(dNode);
              }
            }
            finally
            {
              if(dNode.getNodeType() != Node.DOCUMENT_NODE)
                this.endDocument();
            }
          }
          catch (SAXException se)
          {
            throw new TransformerException(se);
          }
  
          return;
        }
        else
        {
          String messageStr = XSLMessages.createMessage(
            XSLTErrorResources.ER_ILLEGAL_DOMSOURCE_INPUT, null);
  
          throw new IllegalArgumentException(messageStr);
        }
      }
  
      InputSource xmlSource = SAXSource.sourceToInputSource(source);
  
      if (null == xmlSource)
      {
        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_SOURCE_TYPE, new Object[]{source.getClass().getName()})); 
                                       
      }
  
      if (null != xmlSource.getSystemId())
        m_systemID = xmlSource.getSystemId();
  
      try
      {
        XMLReader reader = null;
  
        if (source instanceof SAXSource)
          reader = ((SAXSource) source).getXMLReader();
          
        if (null == reader)
        {
  
          
          try
          {
            javax.xml.parsers.SAXParserFactory factory =
              javax.xml.parsers.SAXParserFactory.newInstance();
  
            factory.setNamespaceAware(true);
  
            javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser();
  
            reader = jaxpParser.getXMLReader();
          }
          catch (javax.xml.parsers.ParserConfigurationException ex)
          {
            throw new org.xml.sax.SAXException(ex);
          }
          catch (javax.xml.parsers.FactoryConfigurationError ex1)
          {
            throw new org.xml.sax.SAXException(ex1.toString());
          }
          catch (NoSuchMethodError ex2){}
          catch (AbstractMethodError ame){}
        }
  
        if (null == reader)
        {
          reader = XMLReaderFactory.createXMLReader();
        }
  
        try
        {
          reader.setFeature(""http:
                            true);
        }
        catch (org.xml.sax.SAXException se)
        {
  
          
        }
  
        
        
        ContentHandler inputHandler = this;
  
        reader.setContentHandler(inputHandler);
  
        if (inputHandler instanceof org.xml.sax.DTDHandler)
          reader.setDTDHandler((org.xml.sax.DTDHandler) inputHandler);
  
        try
        {
          if (inputHandler instanceof org.xml.sax.ext.LexicalHandler)
            reader.setProperty(""http:
                               inputHandler);
  
          if (inputHandler instanceof org.xml.sax.ext.DeclHandler)
            reader.setProperty(
              ""http:
              inputHandler);
        }
        catch (org.xml.sax.SAXException se){}
  
        try
        {
          if (inputHandler instanceof org.xml.sax.ext.LexicalHandler)
            reader.setProperty(""http:
                               inputHandler);
  
          if (inputHandler instanceof org.xml.sax.ext.DeclHandler)
            reader.setProperty(""http:
                               inputHandler);
        }
        catch (org.xml.sax.SAXNotRecognizedException snre){}
  
        reader.parse(xmlSource);
      }
      catch (org.apache.xml.utils.WrappedRuntimeException wre)
      {
        Throwable throwable = wre.getException();
  
        while (throwable
               instanceof org.apache.xml.utils.WrappedRuntimeException)
        {
          throwable =
            ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();
        }
  
        throw new TransformerException(wre.getException());
      }
      catch (org.xml.sax.SAXException se)
      {
        throw new TransformerException(se);
      }
      catch (IOException ioe)
      {
        throw new TransformerException(ioe);
      }
    }
    finally
    {
      if(null != m_outputStream)
      {
        try
        {
          m_outputStream.close();
        }
        catch(IOException ioe){}
        m_outputStream = null;
      }
    }
  }

  
  public void setParameter(String name, Object value)
  {

    if (null == m_params)
    {
      m_params = new Hashtable();
    }

    m_params.put(name, value);
  }

  
  public Object getParameter(String name)
  {

    if (null == m_params)
      return null;

    return m_params.get(name);
  }

  
  public void clearParameters()
  {

    if (null == m_params)
      return;

    m_params.clear();
  }

  
  public void setURIResolver(URIResolver resolver)
  {
    m_URIResolver = resolver;
  }

  
  public URIResolver getURIResolver()
  {
    return m_URIResolver;
  }

  
  public void setOutputProperties(Properties oformat)
          throws IllegalArgumentException
  {

    if (null != oformat)
    {

      
      String method = (String) oformat.get(OutputKeys.METHOD);

      if (null != method)
        m_outputFormat = new OutputProperties(method);
      else
        m_outputFormat = new OutputProperties();
    }

    if (null != oformat)
    {
      m_outputFormat.copyFrom(oformat);
    }
  }

  
  public Properties getOutputProperties()
  {
    return (Properties) m_outputFormat.getProperties().clone();
  }

  
  public void setOutputProperty(String name, String value)
          throws IllegalArgumentException
  {

    if (!m_outputFormat.isLegalPropertyKey(name))
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{name})); 
                                         

    m_outputFormat.setProperty(name, value);
  }

  
  public String getOutputProperty(String name) throws IllegalArgumentException
  {

    String value = null;
    OutputProperties props = m_outputFormat;

    value = props.getProperty(name);

    if (null == value)
    {
      if (!props.isLegalPropertyKey(name))
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{name})); 
                                          
    }

    return value;
  }

  
  public void setErrorListener(ErrorListener listener)
          throws IllegalArgumentException
  {
      if (listener == null)
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NULL_ERROR_HANDLER, null));
      else
        m_errorListener = listener;
  }

  
  public ErrorListener getErrorListener()
  {
    return m_errorListener;
  }

  
  
  

  
  public void notationDecl(String name, String publicId, String systemId)
          throws SAXException
  {
    if (null != m_resultDTDHandler)
      m_resultDTDHandler.notationDecl(name, publicId, systemId);
  }

  
  public void unparsedEntityDecl(
          String name, String publicId, String systemId, String notationName)
            throws SAXException
  {

    if (null != m_resultDTDHandler)
      m_resultDTDHandler.unparsedEntityDecl(name, publicId, systemId,
                                            notationName);
  }

  
  
  

  
  public void setDocumentLocator(Locator locator)
  {
    try
    {
      if (null == m_resultContentHandler)
        createResultContentHandler(m_result);
    }
    catch (TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }

    m_resultContentHandler.setDocumentLocator(locator);
  }

  
  public void startDocument() throws SAXException
  {

    try
    {
      if (null == m_resultContentHandler)
        createResultContentHandler(m_result);
    }
    catch (TransformerException te)
    {
      throw new SAXException(te.getMessage(), te);
    }

    
    m_flushedStartDoc = false;
    m_foundFirstElement = false;
  }
  
  boolean m_flushedStartDoc = false;
  
  protected final void flushStartDoc()
     throws SAXException
  {
    if(!m_flushedStartDoc)
    {
      if (m_resultContentHandler == null)
      {
        try
        {
          createResultContentHandler(m_result);
        }
        catch(TransformerException te)
        {
            throw new SAXException(te);
        }
      }
      m_resultContentHandler.startDocument();
      m_flushedStartDoc = true;
    }
  }

  
  public void endDocument() throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.endDocument();
  }

  
  public void startPrefixMapping(String prefix, String uri)
          throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.startPrefixMapping(prefix, uri);
  }

  
  public void endPrefixMapping(String prefix) throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.endPrefixMapping(prefix);
  }

  
  public void startElement(
          String uri, String localName, String qName, Attributes attributes)
            throws SAXException
  {

    if (!m_foundFirstElement && null != m_serializer)
    {
      m_foundFirstElement = true;

      Serializer newSerializer;

      try
      {
        newSerializer = SerializerSwitcher.switchSerializerIfHTML(uri,
                localName, m_outputFormat.getProperties(), m_serializer);
      }
      catch (TransformerException te)
      {
        throw new SAXException(te);
      }

      if (newSerializer != m_serializer)
      {
        try
        {
          m_resultContentHandler = newSerializer.asContentHandler();
        }
        catch (IOException ioe)  
        {
          throw new SAXException(ioe);
        }

        if (m_resultContentHandler instanceof DTDHandler)
          m_resultDTDHandler = (DTDHandler) m_resultContentHandler;

        if (m_resultContentHandler instanceof LexicalHandler)
          m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;

        m_serializer = newSerializer;
      }
    }
    flushStartDoc();
    m_resultContentHandler.startElement(uri, localName, qName, attributes);
  }

  
  public void endElement(String uri, String localName, String qName)
          throws SAXException
  {
    m_resultContentHandler.endElement(uri, localName, qName);
  }

  
  public void characters(char ch[], int start, int length) throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.characters(ch, start, length);
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws SAXException
  {
    m_resultContentHandler.ignorableWhitespace(ch, start, length);
  }

  
  public void processingInstruction(String target, String data)
          throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.processingInstruction(target, data);
  }

  
  public void skippedEntity(String name) throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.skippedEntity(name);
  }

  
  public void startDTD(String name, String publicId, String systemId)
          throws SAXException
  {
    flushStartDoc();
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.startDTD(name, publicId, systemId);
  }

  
  public void endDTD() throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.endDTD();
  }

  
  public void startEntity(String name) throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.startEntity(name);
  }

  
  public void endEntity(String name) throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.endEntity(name);
  }

  
  public void startCDATA() throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.startCDATA();
  }

  
  public void endCDATA() throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.endCDATA();
  }

  
  public void comment(char ch[], int start, int length) throws SAXException
  {
    flushStartDoc();
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.comment(ch, start, length);
  }
  
  
  
  
    public void elementDecl (String name, String model)
        throws SAXException
    {
                        if (null != m_resultDeclHandler)
                                m_resultDeclHandler.elementDecl(name, model);
    }


    
    public void attributeDecl (String eName,
                                        String aName,
                                        String type,
                                        String valueDefault,
                                        String value)
        throws SAXException
    {
      if (null != m_resultDeclHandler)
                                m_resultDeclHandler.attributeDecl(eName, aName, type, valueDefault, value);
    }


    
    public void internalEntityDecl (String name, String value)
        throws SAXException
    {
      if (null != m_resultDeclHandler)
                                m_resultDeclHandler.internalEntityDecl(name, value); 
    }


    
    public void externalEntityDecl (String name, String publicId,
                                             String systemId)
        throws SAXException
    {
      if (null != m_resultDeclHandler)
                                m_resultDeclHandler.externalEntityDecl(name, publicId, systemId);
    }
  
  
  private java.io.FileOutputStream m_outputStream = null;

  
  private ContentHandler m_resultContentHandler;

  
  private LexicalHandler m_resultLexicalHandler;

  
  private DTDHandler m_resultDTDHandler;
  
  
  private DeclHandler m_resultDeclHandler;

  
  private Serializer m_serializer;

  
  private Result m_result;

  
  private String m_systemID;

  
  private Hashtable m_params;

  
  private ErrorListener m_errorListener =
    new org.apache.xml.utils.DefaultErrorHandler();

  
  URIResolver m_URIResolver;

  
  private OutputProperties m_outputFormat;

  
  boolean m_foundFirstElement;
}
"
org.apache.xml.utils.DOMHelper,26,1,1,14,86,315,9,5,23,0.884444444,1122,0.888888889,6,0.0,0.22,0,0,41.80769231,40,5.0,1,"
package org.apache.xml.utils;

import java.util.Hashtable;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.xml.dtm.ref.DTMNodeProxy;
import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;

import org.w3c.dom.Attr;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.Entity;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.Text;


public class DOMHelper
{

  
  public static Document createDocument()
  {

    try
    {

      
      
      DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();

      dfactory.setNamespaceAware(true);
      dfactory.setValidating(true);

      DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
      Document outNode = docBuilder.newDocument();

      return outNode;
    }
    catch (ParserConfigurationException pce)
    {
      throw new RuntimeException(
        XMLMessages.createXMLMessage(
          XMLErrorResources.ER_CREATEDOCUMENT_NOT_SUPPORTED, null));  

      
    }
  }

  
  public boolean shouldStripSourceNode(Node textNode)
          throws javax.xml.transform.TransformerException
  {

    
    return false;
  }

  
  public String getUniqueID(Node node)
  {
    return ""N"" + Integer.toHexString(node.hashCode()).toUpperCase();
  }

  
  public static boolean isNodeAfter(Node node1, Node node2)
  {
    if (node1 == node2 || isNodeTheSame(node1, node2))
      return true;

        
    boolean isNodeAfter = true;
        
    Node parent1 = getParentOfNode(node1);
    Node parent2 = getParentOfNode(node2);          

    
    if (parent1 == parent2 || isNodeTheSame(parent1, parent2))  
    {
      if (null != parent1)
        isNodeAfter = isNodeAfterSibling(parent1, node1, node2);
      else
      {
                  
                  
                  
                  
                  
                  
                  
          
      }
    }
    else
    {

      
      
          
          
      
                
                
                
                
      
      int nParents1 = 2, nParents2 = 2;  

      while (parent1 != null)
      {
        nParents1++;

        parent1 = getParentOfNode(parent1);
      }

      while (parent2 != null)
      {
        nParents2++;

        parent2 = getParentOfNode(parent2);
      }

          
          
      Node startNode1 = node1, startNode2 = node2;

      
          
      if (nParents1 < nParents2)
      {
        
        int adjust = nParents2 - nParents1;

        for (int i = 0; i < adjust; i++)
        {
          startNode2 = getParentOfNode(startNode2);
        }
      }
      else if (nParents1 > nParents2)
      {
        
        int adjust = nParents1 - nParents2;

        for (int i = 0; i < adjust; i++)
        {
          startNode1 = getParentOfNode(startNode1);
        }
      }

      Node prevChild1 = null, prevChild2 = null;  

      
      while (null != startNode1)
      {
        if (startNode1 == startNode2 || isNodeTheSame(startNode1, startNode2))  
        {
          if (null == prevChild1)  
          {

            
            isNodeAfter = (nParents1 < nParents2) ? true : false;

            break;  
          }
          else 
          {
                        
            isNodeAfter = isNodeAfterSibling(startNode1, prevChild1,
                                             prevChild2);

            break;  
          }
        }  

                
        prevChild1 = startNode1;
        startNode1 = getParentOfNode(startNode1);
        prevChild2 = startNode2;
        startNode2 = getParentOfNode(startNode2);
      }  
    }  
        
        
        
        
    
    return isNodeAfter;
  }  

  
  public static boolean isNodeTheSame(Node node1, Node node2)
  {
    if (node1 instanceof DTMNodeProxy && node2 instanceof DTMNodeProxy)
      return ((DTMNodeProxy)node1).equals((DTMNodeProxy)node2);
    else
      return (node1 == node2);
  }

  
  private static boolean isNodeAfterSibling(Node parent, Node child1,
                                            Node child2)
  {

    boolean isNodeAfterSibling = false;
    short child1type = child1.getNodeType();
    short child2type = child2.getNodeType();

    if ((Node.ATTRIBUTE_NODE != child1type)
            && (Node.ATTRIBUTE_NODE == child2type))
    {

      
      isNodeAfterSibling = false;
    }
    else if ((Node.ATTRIBUTE_NODE == child1type)
             && (Node.ATTRIBUTE_NODE != child2type))
    {

      
      isNodeAfterSibling = true;
    }
    else if (Node.ATTRIBUTE_NODE == child1type)
    {
      NamedNodeMap children = parent.getAttributes();
      int nNodes = children.getLength();
      boolean found1 = false, found2 = false;

          
      for (int i = 0; i < nNodes; i++)
      {
        Node child = children.item(i);

        if (child1 == child || isNodeTheSame(child1, child))
        {
          if (found2)
          {
            isNodeAfterSibling = false;

            break;
          }

          found1 = true;
        }
        else if (child2 == child || isNodeTheSame(child2, child))
        {
          if (found1)
          {
            isNodeAfterSibling = true;

            break;
          }

          found2 = true;
        }
      }
    }
    else
    {
                
                
                
                
                
                
                
                
                
                
                
      Node child = parent.getFirstChild();
      boolean found1 = false, found2 = false;

      while (null != child)
      {

        
        if (child1 == child || isNodeTheSame(child1, child))
        {
          if (found2)
          {
            isNodeAfterSibling = false;

            break;
          }

          found1 = true;
        }
        else if (child2 == child || isNodeTheSame(child2, child))
        {
          if (found1)
          {
            isNodeAfterSibling = true;

            break;
          }

          found2 = true;
        }

        child = child.getNextSibling();
      }
    }

    return isNodeAfterSibling;
  }  

  
  
  

  
  public short getLevel(Node n)
  {

    short level = 1;

    while (null != (n = getParentOfNode(n)))
    {
      level++;
    }

    return level;
  }

  
  public String getNamespaceForPrefix(String prefix, Element namespaceContext)
  {

    int type;
    Node parent = namespaceContext;
    String namespace = null;

    if (prefix.equals(""xml""))
    {
      namespace = QName.S_XMLNAMESPACEURI; 
    }
        else if(prefix.equals(""xmlns""))
    {
          
          
          
          
          
      namespace = ""http:
    }
    else
    {
          
          String declname=(prefix=="""")
                        ? ""xmlns""
                        : ""xmlns:""+prefix;
                                           
          
      while ((null != parent) && (null == namespace)
             && (((type = parent.getNodeType()) == Node.ELEMENT_NODE)
                 || (type == Node.ENTITY_REFERENCE_NODE)))
      {
        if (type == Node.ELEMENT_NODE)
        {
                        
                        
                        
                        
                        
                        
                        
                        
                
                        Attr attr=((Element)parent).getAttributeNode(declname);
                        if(attr!=null)
                        {
                namespace = attr.getNodeValue();
                break;
                        }
                }

        parent = getParentOfNode(parent);
      }
    }

    return namespace;
  }

  
  Hashtable m_NSInfos = new Hashtable();

  
  protected static final NSInfo m_NSInfoUnProcWithXMLNS = new NSInfo(false,
                                                            true);

  
  protected static final NSInfo m_NSInfoUnProcWithoutXMLNS = new NSInfo(false,
                                                               false);

  
  protected static final NSInfo m_NSInfoUnProcNoAncestorXMLNS =
    new NSInfo(false, false, NSInfo.ANCESTORNOXMLNS);

  
  protected static final NSInfo m_NSInfoNullWithXMLNS = new NSInfo(true,
                                                          true);

  
  protected static final NSInfo m_NSInfoNullWithoutXMLNS = new NSInfo(true,
                                                             false);

  
  protected static final NSInfo m_NSInfoNullNoAncestorXMLNS =
    new NSInfo(true, false, NSInfo.ANCESTORNOXMLNS);

  
  protected Vector m_candidateNoAncestorXMLNS = new Vector();

  
  public String getNamespaceOfNode(Node n)
  {

    String namespaceOfPrefix;
    boolean hasProcessedNS;
    NSInfo nsInfo;
    short ntype = n.getNodeType();

    if (Node.ATTRIBUTE_NODE != ntype)
    {
      Object nsObj = m_NSInfos.get(n);  

      nsInfo = (nsObj == null) ? null : (NSInfo) nsObj;
      hasProcessedNS = (nsInfo == null) ? false : nsInfo.m_hasProcessedNS;
    }
    else
    {
      hasProcessedNS = false;
      nsInfo = null;
    }

    if (hasProcessedNS)
    {
      namespaceOfPrefix = nsInfo.m_namespace;
    }
    else
    {
      namespaceOfPrefix = null;

      String nodeName = n.getNodeName();
      int indexOfNSSep = nodeName.indexOf(':');
      String prefix;

      if (Node.ATTRIBUTE_NODE == ntype)
      {
        if (indexOfNSSep > 0)
        {
          prefix = nodeName.substring(0, indexOfNSSep);
        }
        else
        {

          
          
          return namespaceOfPrefix;
        }
      }
      else
      {
        prefix = (indexOfNSSep >= 0)
                 ? nodeName.substring(0, indexOfNSSep) : """";
      }

      boolean ancestorsHaveXMLNS = false;
      boolean nHasXMLNS = false;

      if (prefix.equals(""xml""))
      {
        namespaceOfPrefix = QName.S_XMLNAMESPACEURI;
      }
      else
      {
        int parentType;
        Node parent = n;

        while ((null != parent) && (null == namespaceOfPrefix))
        {
          if ((null != nsInfo)
                  && (nsInfo.m_ancestorHasXMLNSAttrs
                      == NSInfo.ANCESTORNOXMLNS))
          {
            break;
          }

          parentType = parent.getNodeType();

          if ((null == nsInfo) || nsInfo.m_hasXMLNSAttrs)
          {
            boolean elementHasXMLNS = false;

            if (parentType == Node.ELEMENT_NODE)
            {
              NamedNodeMap nnm = parent.getAttributes();

              for (int i = 0; i < nnm.getLength(); i++)
              {
                Node attr = nnm.item(i);
                String aname = attr.getNodeName();

                if (aname.charAt(0) == 'x')
                {
                  boolean isPrefix = aname.startsWith(""xmlns:"");

                  if (aname.equals(""xmlns"") || isPrefix)
                  {
                    if (n == parent)
                      nHasXMLNS = true;

                    elementHasXMLNS = true;
                    ancestorsHaveXMLNS = true;

                    String p = isPrefix ? aname.substring(6) : """";

                    if (p.equals(prefix))
                    {
                      namespaceOfPrefix = attr.getNodeValue();

                      break;
                    }
                  }
                }
              }
            }

            if ((Node.ATTRIBUTE_NODE != parentType) && (null == nsInfo)
                    && (n != parent))
            {
              nsInfo = elementHasXMLNS
                       ? m_NSInfoUnProcWithXMLNS : m_NSInfoUnProcWithoutXMLNS;

              m_NSInfos.put(parent, nsInfo);
            }
          }

          if (Node.ATTRIBUTE_NODE == parentType)
          {
            parent = getParentOfNode(parent);
          }
          else
          {
            m_candidateNoAncestorXMLNS.addElement(parent);
            m_candidateNoAncestorXMLNS.addElement(nsInfo);

            parent = parent.getParentNode();
          }

          if (null != parent)
          {
            Object nsObj = m_NSInfos.get(parent);  

            nsInfo = (nsObj == null) ? null : (NSInfo) nsObj;
          }
        }

        int nCandidates = m_candidateNoAncestorXMLNS.size();

        if (nCandidates > 0)
        {
          if ((false == ancestorsHaveXMLNS) && (null == parent))
          {
            for (int i = 0; i < nCandidates; i += 2)
            {
              Object candidateInfo = m_candidateNoAncestorXMLNS.elementAt(i
                                       + 1);

              if (candidateInfo == m_NSInfoUnProcWithoutXMLNS)
              {
                m_NSInfos.put(m_candidateNoAncestorXMLNS.elementAt(i),
                              m_NSInfoUnProcNoAncestorXMLNS);
              }
              else if (candidateInfo == m_NSInfoNullWithoutXMLNS)
              {
                m_NSInfos.put(m_candidateNoAncestorXMLNS.elementAt(i),
                              m_NSInfoNullNoAncestorXMLNS);
              }
            }
          }

          m_candidateNoAncestorXMLNS.removeAllElements();
        }
      }

      if (Node.ATTRIBUTE_NODE != ntype)
      {
        if (null == namespaceOfPrefix)
        {
          if (ancestorsHaveXMLNS)
          {
            if (nHasXMLNS)
              m_NSInfos.put(n, m_NSInfoNullWithXMLNS);
            else
              m_NSInfos.put(n, m_NSInfoNullWithoutXMLNS);
          }
          else
          {
            m_NSInfos.put(n, m_NSInfoNullNoAncestorXMLNS);
          }
        }
        else
        {
          m_NSInfos.put(n, new NSInfo(namespaceOfPrefix, nHasXMLNS));
        }
      }
    }

    return namespaceOfPrefix;
  }

  
  public String getLocalNameOfNode(Node n)
  {

    String qname = n.getNodeName();
    int index = qname.indexOf(':');

    return (index < 0) ? qname : qname.substring(index + 1);
  }

  
  public String getExpandedElementName(Element elem)
  {

    String namespace = getNamespaceOfNode(elem);

    return (null != namespace)
           ? namespace + "":"" + getLocalNameOfNode(elem)
           : getLocalNameOfNode(elem);
  }

  
  public String getExpandedAttributeName(Attr attr)
  {

    String namespace = getNamespaceOfNode(attr);

    return (null != namespace)
           ? namespace + "":"" + getLocalNameOfNode(attr)
           : getLocalNameOfNode(attr);
  }

  
  
  

  
  public boolean isIgnorableWhitespace(Text node)
  {

    boolean isIgnorable = false;  

    
    
    
        
        
        
    return isIgnorable;
  }

  
  public Node getRoot(Node node)
  {

    Node root = null;

    while (node != null)
    {
      root = node;
      node = getParentOfNode(node);
    }

    return root;
  }

  
  public Node getRootNode(Node n)
  {
    int nt = n.getNodeType();
    return ( (Node.DOCUMENT_NODE == nt) || (Node.DOCUMENT_FRAGMENT_NODE == nt) ) 
           ? n : n.getOwnerDocument();
  }

  
  public boolean isNamespaceNode(Node n)
  {

    if (Node.ATTRIBUTE_NODE == n.getNodeType())
    {
      String attrName = n.getNodeName();

      return (attrName.startsWith(""xmlns:"") || attrName.equals(""xmlns""));
    }

    return false;
  }

  
  public static Node getParentOfNode(Node node) throws RuntimeException
  {
    Node parent;
    short nodeType = node.getNodeType();

    if (Node.ATTRIBUTE_NODE == nodeType)
    {
      Document doc = node.getOwnerDocument();
          

          
          
          
          
          
          
          
          
          
          DOMImplementation impl=doc.getImplementation();
          if(impl!=null && impl.hasFeature(""Core"",""2.0""))
          {
                  parent=((Attr)node).getOwnerElement();
                  return parent;
          }

          

      Element rootElem = doc.getDocumentElement();

      if (null == rootElem)
      {
        throw new RuntimeException(
          XMLMessages.createXMLMessage(
            XMLErrorResources.ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
            null));  
      }

      parent = locateAttrParent(rootElem, node);

        }
    else
    {
      parent = node.getParentNode();

      
      
      
      
    }

    return parent;
  }

  
  public Element getElementByID(String id, Document doc)
  {
    return null;
  }

  
  public String getUnparsedEntityURI(String name, Document doc)
  {

    String url = """";
    DocumentType doctype = doc.getDoctype();

    if (null != doctype)
    {
      NamedNodeMap entities = doctype.getEntities();
      if(null == entities)
        return url;
      Entity entity = (Entity) entities.getNamedItem(name);
      if(null == entity)
        return url;
      
      String notationName = entity.getNotationName();

      if (null != notationName)  
      {
        
        
        
        
        
        
        
        
        
        url = entity.getSystemId();

        if (null == url)
        {
          url = entity.getPublicId();
        }
        else
        {
          
          
        }        
      }
    }

    return url;
  }

  
  private static Node locateAttrParent(Element elem, Node attr)
  {

    Node parent = null;

        
        
        
        
        
        Attr check=elem.getAttributeNode(attr.getNodeName());
        if(check==attr)
                parent = elem;

    if (null == parent)
    {
      for (Node node = elem.getFirstChild(); null != node;
              node = node.getNextSibling())
      {
        if (Node.ELEMENT_NODE == node.getNodeType())
        {
          parent = locateAttrParent((Element) node, attr);

          if (null != parent)
            break;
        }
      }
    }

    return parent;
  }

  
  protected Document m_DOMFactory = null;

  
  public void setDOMFactory(Document domFactory)
  {
    this.m_DOMFactory = domFactory;
  }

  
  public Document getDOMFactory()
  {

    if (null == this.m_DOMFactory)
    {
      this.m_DOMFactory = createDocument();
    }

    return this.m_DOMFactory;
  }

  
  public static String getNodeData(Node node)
  {

    FastStringBuffer buf = StringBufferPool.get();
    String s;

    try
    {
      getNodeData(node, buf);

      s = (buf.length() > 0) ? buf.toString() : """";
    }
    finally
    {
      StringBufferPool.free(buf);
    }

    return s;
  }

  
  public static void getNodeData(Node node, FastStringBuffer buf)
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_FRAGMENT_NODE :
    case Node.DOCUMENT_NODE :
    case Node.ELEMENT_NODE :
    {
      for (Node child = node.getFirstChild(); null != child;
              child = child.getNextSibling())
      {
        getNodeData(child, buf);
      }
    }
    break;
    case Node.TEXT_NODE :
    case Node.CDATA_SECTION_NODE :
      buf.append(node.getNodeValue());
      break;
    case Node.ATTRIBUTE_NODE :
      buf.append(node.getNodeValue());
      break;
    case Node.PROCESSING_INSTRUCTION_NODE :
      
      break;
    default :
      
      break;
    }
  }
}
"
org.apache.xalan.xsltc.compiler.util.SlotAllocator,4,1,0,4,16,0,1,3,3,0.5,242,1.0,0,0.0,0.4375,0,0,58.5,6,3.0,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.Type;

final class SlotAllocator {

    private int   _firstAvailableSlot;
    private int   _size = 8;
    private int   _free = 0;
    private int[] _slotsTaken = new int[_size];
    
    public void initialize(LocalVariableGen[] vars) {
	final int length = vars.length;
	int slot = 0, size, index;

	for (int i = 0; i < length; i++) {
	    size  = vars[i].getType().getSize();
	    index = vars[i].getIndex();
	    slot  = Math.max(slot, index + size);
	}
	_firstAvailableSlot = slot;
    }

    public int allocateSlot(Type type) {
	final int size = type.getSize();
	final int limit = _free;
	int slot = _firstAvailableSlot, where = 0;

	if (_free + size > _size) {
	    final int[] array = new int[_size *= 2];
	    for (int j = 0; j < limit; j++)
		array[j] = _slotsTaken[j];
	    _slotsTaken = array;
	}

	while (where < limit) {
	    if (slot + size <= _slotsTaken[where]) {
		
		for (int j = limit - 1; j >= where; j--)
		    _slotsTaken[j + size] = _slotsTaken[j];
		break;
	    }
	    else {
		slot = _slotsTaken[where++] + 1;
	    }
	}
	
	for (int j = 0; j < size; j++)
	    _slotsTaken[where + j] = slot + j;
	
	_free += size;
	return slot;
    }

    public void releaseSlot(LocalVariableGen lvg) {
	final int size = lvg.getType().getSize();
	final int slot = lvg.getIndex();
	final int limit = _free;
	
	for (int i = 0; i < limit; i++) {
	    if (_slotsTaken[i] == slot) {
		int j = i + size;
		while (j < limit) {
		    _slotsTaken[i++] = _slotsTaken[j++];
		}
		_free -= size;
		return;
	    }
	}
	String state = ""Variable slot allocation error""+
	               ""(size=""+size+"", slot=""+slot+"", limit=""+limit+"")"";
	ErrorMsg err = new ErrorMsg(ErrorMsg.INTERNAL_ERR, state);
	throw new Error(err.toString());
    }
}
"
org.apache.xpath.domapi.XPathNamespaceImpl,39,1,0,1,56,469,1,0,39,0.578947368,198,0.0,0,0.0,0.256410256,0,0,4.051282051,1,0.9744,1,"


package org.apache.xpath.domapi;

import org.w3c.dom.Attr;
import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.xpath.XPathNamespace;



public class XPathNamespaceImpl implements XPathNamespace {

    
    Node m_attributeNode = null;
    
    
    public XPathNamespaceImpl(Node node) {
        m_attributeNode = node;
    }

    
    public Element getOwnerElement() {
        return ((Attr)m_attributeNode).getOwnerElement(); 
    }

    
    public String getNodeName() {
        return ""#namespace"";
    }

    
    public String getNodeValue() throws DOMException {
        return m_attributeNode.getNodeValue();
    }

    
    public void setNodeValue(String arg0) throws DOMException {
    }

    
    public short getNodeType() {
        return XPathNamespace.XPATH_NAMESPACE_NODE;
    }

    
    public Node getParentNode() {
        return m_attributeNode.getParentNode();
    }

    
    public NodeList getChildNodes() {
        return m_attributeNode.getChildNodes();
    }

    
    public Node getFirstChild() {
        return m_attributeNode.getFirstChild();
    }

    
    public Node getLastChild() {
        return m_attributeNode.getLastChild();
    }

    
    public Node getPreviousSibling() {
        return m_attributeNode.getPreviousSibling();
    }

    
    public Node getNextSibling() {
        return m_attributeNode.getNextSibling();
    }

    
    public NamedNodeMap getAttributes() {
        return m_attributeNode.getAttributes();
    }

    
    public Document getOwnerDocument() {
        return m_attributeNode.getOwnerDocument();
    }

    
    public Node insertBefore(Node arg0, Node arg1) throws DOMException {
        return null;
    }

    
    public Node replaceChild(Node arg0, Node arg1) throws DOMException {
        return null;
    }

    
    public Node removeChild(Node arg0) throws DOMException {
        return null;
    }

    
    public Node appendChild(Node arg0) throws DOMException {
        return null;
    }

    
    public boolean hasChildNodes() {
        return false;
    }

    
    public Node cloneNode(boolean arg0) {
        throw new DOMException(DOMException.NOT_SUPPORTED_ERR,null);
    }

    
    public void normalize() {
        m_attributeNode.normalize();
    }

    
    public boolean isSupported(String arg0, String arg1) {
        return m_attributeNode.isSupported(arg0, arg1);
    }

    
    public String getNamespaceURI() {
        
        
        
        return m_attributeNode.getNodeValue();
    }

    
    public String getPrefix() {
        return m_attributeNode.getPrefix();
    }

    
    public void setPrefix(String arg0) throws DOMException {
    }

    
    public String getLocalName() {
        
        
        return m_attributeNode.getPrefix();
    }

    
    public boolean hasAttributes() {
        return m_attributeNode.hasAttributes();
    }

}
"
org.apache.xalan.trace.TraceManager,13,1,0,38,32,0,25,14,13,0.333333333,301,1.0,1,0.0,0.211538462,0,0,22.0,4,1.8462,0,"
package org.apache.xalan.trace;

import java.util.TooManyListenersException;
import java.util.Vector;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;

import org.w3c.dom.Node;


public class TraceManager
{

  
  private TransformerImpl m_transformer;

  
  public TraceManager(TransformerImpl transformer)
  {
    m_transformer = transformer;
  }

  
  private Vector m_traceListeners = null;

  
  public void addTraceListener(TraceListener tl)
          throws TooManyListenersException
  {

    TransformerImpl.S_DEBUG = true;

    if (null == m_traceListeners)
      m_traceListeners = new Vector();

    m_traceListeners.addElement(tl);
  }

  
  public void removeTraceListener(TraceListener tl)
  {

    if (null != m_traceListeners)
    {
      m_traceListeners.removeElement(tl);
      
      
      
      
      if (0 == m_traceListeners.size()) m_traceListeners = null;
    }
  }

  
  public void fireGenerateEvent(GenerateEvent te)
  {

    if (null != m_traceListeners)
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);

        tl.generated(te);
      }
    }
  }

  
  public boolean hasTraceListeners()
  {
    return (null != m_traceListeners);
  }

  
  public void fireTraceEvent(ElemTemplateElement styleNode)
  {

    if (hasTraceListeners())
    {
      int sourceNode = m_transformer.getXPathContext().getCurrentNode();
      Node source = m_transformer.getXPathContext().getDTM(
        sourceNode).getNode(sourceNode);

      fireTraceEvent(new TracerEvent(m_transformer, source, 
                     m_transformer.getMode(),  
                                     styleNode));
    }
  }

  
  public void fireTraceEndEvent(ElemTemplateElement styleNode)
  {

    if (hasTraceListeners())
    {
      int sourceNode = m_transformer.getXPathContext().getCurrentNode();
      Node source = m_transformer.getXPathContext().getDTM(
        sourceNode).getNode(sourceNode);

      fireTraceEndEvent(new TracerEvent(m_transformer, source,
                     m_transformer.getMode(),  
                                     styleNode));
    }
  }

  
  public void fireTraceEndEvent(TracerEvent te)
  {

    if (hasTraceListeners())
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);
        if(tl instanceof TraceListenerEx2)
        {
          ((TraceListenerEx2)tl).traceEnd(te);
        }
      }
    }
  }



  
  public void fireTraceEvent(TracerEvent te)
  {

    if (hasTraceListeners())
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);

        tl.trace(te);
      }
    }
  }

  
  public void fireSelectedEvent(
          int sourceNode, ElemTemplateElement styleNode, String attributeName, 
          XPath xpath, XObject selection)
            throws javax.xml.transform.TransformerException
  {

    if (hasTraceListeners())
    {
      Node source = m_transformer.getXPathContext().getDTM(
        sourceNode).getNode(sourceNode);
        
      fireSelectedEvent(new SelectionEvent(m_transformer, source, styleNode,
                                           attributeName, xpath, selection));
    }
  }
  
  
  public void fireSelectedEndEvent(
          int sourceNode, ElemTemplateElement styleNode, String attributeName, 
          XPath xpath, XObject selection)
            throws javax.xml.transform.TransformerException
  {

    if (hasTraceListeners())
    {
      Node source = m_transformer.getXPathContext().getDTM(
        sourceNode).getNode(sourceNode);
        
      fireSelectedEndEvent(new EndSelectionEvent(m_transformer, source, styleNode,
                                           attributeName, xpath, selection));
    }
  }
  
  
  public void fireSelectedEndEvent(EndSelectionEvent se)
          throws javax.xml.transform.TransformerException
  {

    if (hasTraceListeners())
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);

        if(tl instanceof TraceListenerEx)
          ((TraceListenerEx)tl).selectEnd(se);
      }
    }
  }

  
  public void fireSelectedEvent(SelectionEvent se)
          throws javax.xml.transform.TransformerException
  {

    if (hasTraceListeners())
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);

        tl.selected(se);
      }
    }
  }
}
"
org.apache.xalan.xsltc.compiler.util.Util,18,1,0,44,38,151,43,1,17,0.941176471,274,0.0,0,0.0,0.235294118,0,0,14.16666667,5,1.6667,1,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.Type;
import org.apache.xalan.xsltc.compiler.Constants;

public final class Util {
    static public char filesep;

    static {
	String temp = System.getProperty(""file.separator"", ""/"");
	filesep = temp.charAt(0);
    }

    public static String noExtName(String name) {
	final int index = name.lastIndexOf('.');
	return name.substring(0, index >= 0 ? index : name.length());
    }

    
    public static String baseName(String name) {
	int index = name.lastIndexOf('\');
	if (index < 0) {
	    index = name.lastIndexOf('/');
	}
	
	if (index >= 0)
	    return name.substring(index + 1);
	else {
	    int lastColonIndex = name.lastIndexOf(':');
	    if (lastColonIndex > 0)
	    	return name.substring(lastColonIndex + 1);
	    else
	    	return name;
	}
    }

    
    public static String pathName(String name) {
	int index = name.lastIndexOf('/');
	if (index < 0) {
	    index = name.lastIndexOf('\');
	}
	return name.substring(0, index + 1);
    }

    
    public static String toJavaName(String name) {
	if (name.length() > 0) {
	    final StringBuffer result = new StringBuffer();

	    char ch = name.charAt(0);
	    result.append(Character.isJavaIdentifierStart(ch) ? ch : '_');

	    final int n = name.length();
	    for (int i = 1; i < n; i++) {
		ch = name.charAt(i);
		result.append(Character.isJavaIdentifierPart(ch)  ? ch : '_');
	    }
	    return result.toString();
	}
	return name;
    }

    public static Type getJCRefType(String signature) {
	return Type.getType(signature);
    }

    public static String internalName(String cname) {
	return cname.replace('.', filesep);
    }

    public static void println(String s) {
	System.out.println(s);
    }

    public static void println(char ch) {
	System.out.println(ch);
    }

    public static void TRACE1() {
	System.out.println(""TRACE1"");
    }

    public static void TRACE2() {
	System.out.println(""TRACE2"");
    }

    public static void TRACE3() {
	System.out.println(""TRACE3"");
    }

    
    public static String replace(String base, char ch, String str) {
	return (base.indexOf(ch) < 0) ? base : 
	    replace(base, String.valueOf(ch), new String[] { str });
    }

    public static String replace(String base, String delim, String[] str) {
	final int len = base.length();
	final StringBuffer result = new StringBuffer();

	for (int i = 0; i < len; i++) {
	    final char ch = base.charAt(i);
	    final int k = delim.indexOf(ch);

	    if (k >= 0) {
		result.append(str[k]);
	    }
	    else {
		result.append(ch);
	    }
	}
	return result.toString();
    }

    
    public static String escape(String input) {
	return replace(input, "".-/:"", 
	    new String[] { ""$dot$"", ""$dash$"", ""$slash$"", ""$colon$"" });
    }

    public static String getLocalName(String qname) {
	final int index = qname.lastIndexOf("":"");
	return (index > 0) ? qname.substring(index + 1) : qname;
    }

    public static String getPrefix(String qname) {
	final int index = qname.lastIndexOf("":"");
	return (index > 0) ? qname.substring(0, index) : 
	    Constants.EMPTYSTRING;
    }
}

"
org.apache.xalan.xsltc.compiler.util.AttributeSetMethodGenerator,8,5,0,11,15,14,1,10,7,0.839285714,100,1.0,0,0.958333333,0.476190476,1,2,10.5,1,0.75,1,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.ClassGen;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;

public final class AttributeSetMethodGenerator extends MethodGenerator {
    private static int HANDLER_INDEX = 1;
    private static int ITERATOR_INDEX = 2;

    private static final org.apache.bcel.generic.Type[] argTypes =
	new org.apache.bcel.generic.Type[2];
    private static final String[] argNames = new String[2];
    
    static {
	argTypes[0] = Util.getJCRefType(TRANSLET_OUTPUT_SIG);
	argNames[0] = TRANSLET_OUTPUT_PNAME;
	argTypes[1] = Util.getJCRefType(NODE_ITERATOR_SIG);
	argNames[1] = ITERATOR_PNAME;
    }

    private final Instruction _astoreHandler;
    private final Instruction _aloadHandler;
    private final Instruction _astoreIterator;
    private final Instruction _aloadIterator;
    
    public AttributeSetMethodGenerator(String methodName, ClassGen classGen) {
	super(org.apache.bcel.Constants.ACC_PRIVATE,
	      org.apache.bcel.generic.Type.VOID,
	      argTypes, argNames, methodName, 
	      classGen.getClassName(),
	      new InstructionList(),
	      classGen.getConstantPool());
	
	_astoreHandler  = new ASTORE(HANDLER_INDEX);
	_aloadHandler   = new ALOAD(HANDLER_INDEX);
	_astoreIterator = new ASTORE(ITERATOR_INDEX);
	_aloadIterator  = new ALOAD(ITERATOR_INDEX);
    }

    public Instruction storeIterator() {
	return _astoreIterator;
    }
    
    public Instruction loadIterator() {
	return _aloadIterator;
    }

    public int getIteratorIndex() {
	return ITERATOR_INDEX;
    }

    public Instruction storeHandler() {
	return _astoreHandler;
    }

    public Instruction loadHandler() {
	return _aloadHandler;
    }

    public int getLocalIndex(String name) {
	return INVALID_INDEX;	
    }
}
"
org.apache.xalan.xsltc.compiler.FilteredAbsoluteLocationPath,7,3,0,18,28,0,0,18,7,0.0,143,1.0,1,0.934210526,0.285714286,2,7,19.28571429,2,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class FilteredAbsoluteLocationPath extends Expression {
    private Expression _path;	

    public FilteredAbsoluteLocationPath() {
	_path = null;
    }

    public FilteredAbsoluteLocationPath(Expression path) {
	_path = path;
	if (path != null) {
	    _path.setParent(this);
	}
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_path != null) {
	    _path.setParser(parser);
	}
    }

    public Expression getPath() {
	return(_path);
    }
    
    public String toString() {
	return ""FilteredAbsoluteLocationPath("" +
	    (_path != null ? _path.toString() : ""null"") + ')';
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_path != null) {
	    final Type ptype = _path.typeCheck(stable);
	    if (ptype instanceof NodeType) {		
		_path = new CastExpr(_path, Type.NodeSet);
	    }
	}
	return _type = Type.NodeSet;	
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	if (_path != null) {
	    final int initDFI = cpg.addMethodref(DUP_FILTERED_ITERATOR,
						""<init>"",
						""(""
						+ NODE_ITERATOR_SIG
						+ "")V"");
	    
	    il.append(new NEW(cpg.addClass(DUP_FILTERED_ITERATOR)));
	    il.append(DUP);

	    
	    _path.translate(classGen, methodGen);

	    
	    il.append(new INVOKESPECIAL(initDFI));
	}
	else {
	    final int git = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getIterator"",
						      ""()""+NODE_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(new INVOKEINTERFACE(git, 1));
	}
    }
}
"
org.apache.xpath.functions.FuncCurrent,3,3,0,10,12,3,1,9,3,2.0,50,0.0,0,0.95,0.5,1,6,15.66666667,1,0.6667,2,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.axes.PredicatedNodeTest;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;


public class FuncCurrent extends Function
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    
    Object subContextList = xctxt.getSubContextList();
    int currentNode;

    
    if (null != subContextList && subContextList instanceof PredicatedNodeTest)
    {
      
      
      LocPathIterator lpi = xctxt.getCurrentNodeList();

      currentNode = lpi.getCurrentContextNode();  
        
    }
    else if(xctxt.getIteratorRoot() != DTM.NULL)
    {
      currentNode = xctxt.getIteratorRoot();
    }
    else
    {
      DTMIterator cnl = xctxt.getContextNodeList();

      if (null != cnl)
      {
        
        currentNode = cnl.getCurrentNode();
      }
      else
        currentNode = DTM.NULL;
    }
    
    
    
    
    
    
    
    
    

    return new XNodeSet(currentNode, xctxt.getDTMManager());
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }

}
"
org.apache.xml.serializer.OutputPropertyUtils,3,1,0,3,7,3,3,0,3,2.0,33,0.0,0,0.0,0.555555556,0,0,10.0,3,1.6667,0,"
package org.apache.xml.serializer;

import java.util.Properties;


public class OutputPropertyUtils
{
    
    public static boolean getBooleanProperty(String key, Properties props)
    {

        String s = props.getProperty(key);

        if (null == s || !s.equals(""yes""))
            return false;
        else
            return true;
    }

    
    public static int getIntProperty(String key, Properties props)
    {

        String s = props.getProperty(key);

        if (null == s)
            return 0;
        else
            return Integer.parseInt(s);
    }

}
"
org.apache.xalan.processor.XSLTElementProcessor,15,3,11,20,48,101,16,6,10,0.821428571,280,1.0,2,0.933333333,0.348148148,0,0,17.53333333,1,0.9333,1,"
package org.apache.xalan.processor;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xml.utils.IntStack;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.AttributesImpl;


public class XSLTElementProcessor extends ElemTemplateElement
{

  
  XSLTElementProcessor(){}
	
	private IntStack m_savedLastOrder;

  
  private XSLTElementDef m_elemDef;

  
  XSLTElementDef getElemDef()
  {
    return m_elemDef;
  }

  
  void setElemDef(XSLTElementDef def)
  {
    m_elemDef = def;
  }

  
  public InputSource resolveEntity(
          StylesheetHandler handler, String publicId, String systemId)
            throws org.xml.sax.SAXException
  {
    return null;
  }

  
  public void notationDecl(StylesheetHandler handler, String name,
                           String publicId, String systemId)
  {

    
  }

  
  public void unparsedEntityDecl(StylesheetHandler handler, String name,
                                 String publicId, String systemId,
                                 String notationName)
  {

    
  }

  
  public void startNonText(StylesheetHandler handler) throws org.xml.sax.SAXException
  {

    
  }

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    if (m_savedLastOrder == null)
				m_savedLastOrder = new IntStack();
			m_savedLastOrder.push(getElemDef().getLastOrder());
			getElemDef().setLastOrder(-1);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {
		if (m_savedLastOrder != null && !m_savedLastOrder.empty())
			getElemDef().setLastOrder(m_savedLastOrder.pop());
		
		if (!getElemDef().getRequiredFound())
			handler.error(XSLTErrorResources.ER_REQUIRED_ELEM_NOT_FOUND, new Object[]{getElemDef().getRequiredElem()}, null);
  }

  
  public void characters(
          StylesheetHandler handler, char ch[], int start, int length)
            throws org.xml.sax.SAXException
  {
    handler.error(XSLTErrorResources.ER_CHARS_NOT_ALLOWED, null, null);
                  
  }

  
  public void ignorableWhitespace(
          StylesheetHandler handler, char ch[], int start, int length)
            throws org.xml.sax.SAXException
  {

    
  }

  
  public void processingInstruction(
          StylesheetHandler handler, String target, String data)
            throws org.xml.sax.SAXException
  {

    
  }

  
  public void skippedEntity(StylesheetHandler handler, String name)
          throws org.xml.sax.SAXException
  {

    
  }

  
  void setPropertiesFromAttributes(
          StylesheetHandler handler, String rawName, Attributes attributes, 
          ElemTemplateElement target)
            throws org.xml.sax.SAXException
  {
    setPropertiesFromAttributes(handler, rawName, attributes, target, true);
  }

  
  Attributes setPropertiesFromAttributes(
          StylesheetHandler handler, String rawName, Attributes attributes, 
          ElemTemplateElement target, boolean throwError)
            throws org.xml.sax.SAXException
  {

    XSLTElementDef def = getElemDef();
    AttributesImpl undefines = throwError ? null : new AttributesImpl();

    
    
    Vector processedDefs = new Vector();

    
    Vector errorDefs = new Vector();    
    int nAttrs = attributes.getLength();

    for (int i = 0; i < nAttrs; i++)
    {
      String attrUri = attributes.getURI(i);
      
      if((null != attrUri) && (attrUri.length() == 0)
                           && (attributes.getQName(i).startsWith(""xmlns:"") || 
                               attributes.getQName(i).equals(""xmlns"")))
      {
        attrUri = org.apache.xalan.templates.Constants.S_XMLNAMESPACEURI;
      }
      String attrLocalName = attributes.getLocalName(i);
      XSLTAttributeDef attrDef = def.getAttributeDef(attrUri, attrLocalName);

      if (null == attrDef)
      {
        if (throwError)
        {

          
          handler.error(XSLTErrorResources.ER_ATTR_NOT_ALLOWED, new Object[]{attributes.getQName(i), rawName}, null);
                        
                       
        }
        else
        {
          undefines.addAttribute(attrUri, attrLocalName,
                                 attributes.getQName(i),
                                 attributes.getType(i),
                                 attributes.getValue(i));
        }
      }
      else
      {
        

        boolean success = attrDef.setAttrValue(handler, attrUri, attrLocalName,
                             attributes.getQName(i), attributes.getValue(i),
                             target);
                             
        
        if (success)
            processedDefs.addElement(attrDef);
        else
            errorDefs.addElement(attrDef);
      }
    }

    XSLTAttributeDef[] attrDefs = def.getAttributes();
    int nAttrDefs = attrDefs.length;

    for (int i = 0; i < nAttrDefs; i++)
    {
      XSLTAttributeDef attrDef = attrDefs[i];
      String defVal = attrDef.getDefault();

      if (null != defVal)
      {
        if (!processedDefs.contains(attrDef))
        {
          attrDef.setDefAttrValue(handler, target);
        }
      }

      if (attrDef.getRequired())
      {
        if ((!processedDefs.contains(attrDef)) && (!errorDefs.contains(attrDef)))
          handler.error(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_REQUIRES_ATTRIB, new Object[]{ rawName,
                                                                   attrDef.getName() }), null);
      }
    }

    return undefines;
  }
}
"
org.apache.xalan.templates.ElemPI,8,3,0,11,33,8,1,10,8,0.428571429,164,1.0,1,0.965517241,0.3,2,5,19.375,16,2.75,2,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPathContext;


public class ElemPI extends ElemTemplateElement
{

  
  private AVT m_name_atv = null;

  
  public void setName(AVT v)
  {
    m_name_atv = v;
  }

  
  public AVT getName()
  {
    return m_name_atv;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    java.util.Vector vnames = sroot.getComposeState().getVariableNames();
    if(null != m_name_atv)
      m_name_atv.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
  }



  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_PI;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_PI_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    XPathContext xctxt = transformer.getXPathContext();
    int sourceNode = xctxt.getCurrentNode();
    
    String piName = m_name_atv == null ? null : m_name_atv.evaluate(xctxt, sourceNode, this);
    
    
    if (piName == null) return;

    if (piName.equalsIgnoreCase(""xml""))
    {
     	transformer.getMsgMgr().warn(
        this, XSLTErrorResources.WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
              new Object[]{ Constants.ATTRNAME_NAME, piName });
		return;
    }
    
    
    
    else if ((!m_name_atv.isSimple()) && (!isValidNCName(piName)))
    {
     	transformer.getMsgMgr().warn(
        this, XSLTErrorResources.WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
              new Object[]{ Constants.ATTRNAME_NAME, piName });
		return;    	
    }

    
    
    
    
    
    
    
    
    String data = transformer.transformToString(this);

    try
    {
      transformer.getResultTreeHandler().processingInstruction(piName, data);
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {

    
    case Constants.ELEMNAME_TEXTLITERALRESULT :
    case Constants.ELEMNAME_APPLY_TEMPLATES :
    case Constants.ELEMNAME_APPLY_IMPORTS :
    case Constants.ELEMNAME_CALLTEMPLATE :
    case Constants.ELEMNAME_FOREACH :
    case Constants.ELEMNAME_VALUEOF :
    case Constants.ELEMNAME_COPY_OF :
    case Constants.ELEMNAME_NUMBER :
    case Constants.ELEMNAME_CHOOSE :
    case Constants.ELEMNAME_IF :
    case Constants.ELEMNAME_TEXT :
    case Constants.ELEMNAME_COPY :
    case Constants.ELEMNAME_VARIABLE :
    case Constants.ELEMNAME_MESSAGE :

      
      
      
      
      
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
}
"
org.apache.xml.dtm.ref.DTMDefaultBaseTraversers,3,2,1,31,28,3,22,29,3,2.0,225,0.0,0,0.989130435,0.761904762,0,0,74.0,5,1.6667,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;

import javax.xml.transform.Source;

import org.apache.xml.utils.XMLStringFactory;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;



public abstract class DTMDefaultBaseTraversers extends DTMDefaultBase
{

  
  public DTMDefaultBaseTraversers(DTMManager mgr, Source source,
                                  int dtmIdentity,
                                  DTMWSFilter whiteSpaceFilter,
                                  XMLStringFactory xstringfactory,
                                  boolean doIndexing)
  {
    super(mgr, source, dtmIdentity, whiteSpaceFilter, xstringfactory,
          doIndexing);
  }

  
  public DTMDefaultBaseTraversers(DTMManager mgr, Source source,
                                  int dtmIdentity,
                                  DTMWSFilter whiteSpaceFilter,
                                  XMLStringFactory xstringfactory,
                                  boolean doIndexing,
                                  int blocksize,
                                  boolean usePrevsib)
  {
    super(mgr, source, dtmIdentity, whiteSpaceFilter, xstringfactory,
          doIndexing, blocksize, usePrevsib);
  }

  
  public DTMAxisTraverser getAxisTraverser(final int axis)
  {

    DTMAxisTraverser traverser;

    if (null == m_traversers)  
    {
      m_traversers = new DTMAxisTraverser[Axis.names.length];
      traverser = null;
    }
    else
    {
      traverser = m_traversers[axis];  

      if (traverser != null)
        return traverser;
    }

    switch (axis)  
    {
    case Axis.ANCESTOR :
      traverser = new AncestorTraverser();
      break;
    case Axis.ANCESTORORSELF :
      traverser = new AncestorOrSelfTraverser();
      break;
    case Axis.ATTRIBUTE :
      traverser = new AttributeTraverser();
      break;
    case Axis.CHILD :
      traverser = new ChildTraverser();
      break;
    case Axis.DESCENDANT :
      traverser = new DescendantTraverser();
      break;
    case Axis.DESCENDANTORSELF :
      traverser = new DescendantOrSelfTraverser();
      break;
    case Axis.FOLLOWING :
      traverser = new FollowingTraverser();
      break;
    case Axis.FOLLOWINGSIBLING :
      traverser = new FollowingSiblingTraverser();
      break;
    case Axis.NAMESPACE :
      traverser = new NamespaceTraverser();
      break;
    case Axis.NAMESPACEDECLS :
      traverser = new NamespaceDeclsTraverser();
      break;
    case Axis.PARENT :
      traverser = new ParentTraverser();
      break;
    case Axis.PRECEDING :
      traverser = new PrecedingTraverser();
      break;
    case Axis.PRECEDINGSIBLING :
      traverser = new PrecedingSiblingTraverser();
      break;
    case Axis.SELF :
      traverser = new SelfTraverser();
      break;
    case Axis.ALL :
      traverser = new AllFromRootTraverser();
      break;
    case Axis.ALLFROMNODE :
      traverser = new AllFromNodeTraverser();
      break;
    case Axis.PRECEDINGANDANCESTOR :
      traverser = new PrecedingAndAncestorTraverser();
      break;
    case Axis.DESCENDANTSFROMROOT :
      traverser = new DescendantFromRootTraverser();
      break;
    case Axis.DESCENDANTSORSELFFROMROOT :
      traverser = new DescendantOrSelfFromRootTraverser();
      break;
    case Axis.ROOT :
      traverser = new RootTraverser();
      break;
    case Axis.FILTEREDLIST :
      return null; 
    default :
      throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_UNKNOWN_AXIS_TYPE, new Object[]{Integer.toString(axis)})); 
    }

    if (null == traverser)
      throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_AXIS_TRAVERSER_NOT_SUPPORTED, new Object[]{Axis.names[axis]}));
      
      

    m_traversers[axis] = traverser;

    return traverser;
  }

  
  private class AncestorTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
			return getParent(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      current = makeNodeIdentity(current);

      while (DTM.NULL != (current = m_parent.elementAt(current)))
      {
        if (m_exptype.elementAt(current) == expandedTypeID)
          return makeNodeHandle(current);
      }

      return NULL;
    }
  }

  
  private class AncestorOrSelfTraverser extends AncestorTraverser
  {

    
    public int first(int context)
    {
      return context;
    }

    
    public int first(int context, int expandedTypeID)
    {
			return (getExpandedTypeID(context) == expandedTypeID)
             ? context : next(context, context, expandedTypeID);
    }
  }

  
  private class AttributeTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
      return (context == current)
             ? getFirstAttribute(context) : getNextAttribute(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      current = (context == current)
                ? getFirstAttribute(context) : getNextAttribute(current);

      do
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }
      while (DTM.NULL != (current = getNextAttribute(current)));

      return NULL;
    }
  }

  
  private class ChildTraverser extends DTMAxisTraverser
  {
    
    
    protected int getNextIndexed(int axisRoot, int nextPotential,
                                 int expandedTypeID)
    {

      int nsIndex = m_expandedNameTable.getNamespaceID(expandedTypeID);
      int lnIndex = m_expandedNameTable.getLocalNameID(expandedTypeID);

      for (; ; ) 
      {
        int nextID = findElementFromIndex(nsIndex, lnIndex, nextPotential);

        if (NOTPROCESSED != nextID)
        {
          int parentID = m_parent.elementAt(nextID);
          
          
          if(parentID == axisRoot)
            return nextID;
          
          
          
          if(parentID < axisRoot)
              return NULL;
          
          
          
          
          
          
          do
          {
            parentID = m_parent.elementAt(parentID);
            if(parentID < axisRoot)
              return NULL;
          }
            while(parentID > axisRoot);
          
          
          nextPotential = nextID+1;
          continue;
        }

        nextNode();
        
        if(!(m_nextsib.elementAt(axisRoot) == NOTPROCESSED))
          break;
      }

      return DTM.NULL;
    }
        
    
    public int first(int context)
    {
      return getFirstChild(context);
    }
  
    
    public int first(int context, int expandedTypeID)
    {
      if(true)
      {
        int identity = makeNodeIdentity(context);
        
        int firstMatch = getNextIndexed(identity, _firstch(identity),
                                 expandedTypeID);
       
        return makeNodeHandle(firstMatch);
      }
      else
      {
				
        for (int current = _firstch(makeNodeIdentity(context)); 
             DTM.NULL != current; 
             current = _nextsib(current)) 
        {
          if (m_exptype.elementAt(current) == expandedTypeID)
              return makeNodeHandle(current);
        }
        return NULL;
      }
    }

    
    public int next(int context, int current)
    {
      return getNextSibling(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      for (current = _nextsib(makeNodeIdentity(current)); 
           DTM.NULL != current; 
           current = _nextsib(current)) 
      {
        if (m_exptype.elementAt(current) == expandedTypeID)
            return makeNodeHandle(current);
      }
      
      return NULL;
    }
  }

  
  private abstract class IndexedDTMAxisTraverser extends DTMAxisTraverser
  {

    
    protected final boolean isIndexed(int expandedTypeID)
    {
      return (m_indexing
              && ExpandedNameTable.ELEMENT
                 == m_expandedNameTable.getType(expandedTypeID)); 
    }

    
    protected abstract boolean isAfterAxis(int axisRoot, int identity);

    
    protected abstract boolean axisHasBeenProcessed(int axisRoot);

    
    protected int getNextIndexed(int axisRoot, int nextPotential,
                                 int expandedTypeID)
    {

      int nsIndex = m_expandedNameTable.getNamespaceID(expandedTypeID);
      int lnIndex = m_expandedNameTable.getLocalNameID(expandedTypeID);

      while(true)
      {
        int next = findElementFromIndex(nsIndex, lnIndex, nextPotential);

        if (NOTPROCESSED != next)
        {
          if (isAfterAxis(axisRoot, next))
            return NULL;

          
          return next;
        }
        else if(axisHasBeenProcessed(axisRoot))
          break;

        nextNode();
      }

      return DTM.NULL;
    }
  }

  
  private class DescendantTraverser extends IndexedDTMAxisTraverser
  {
    
    protected int getFirstPotential(int identity)
    {
      return identity + 1;
    }
    
    
    protected boolean axisHasBeenProcessed(int axisRoot)
    {
      return !(m_nextsib.elementAt(axisRoot) == NOTPROCESSED);
    }
    
    
    protected int getSubtreeRoot(int handle)
    {
      return makeNodeIdentity(handle);
    }

    
    protected boolean isDescendant(int subtreeRootIdentity, int identity)
    {
      return _parent(identity) >= subtreeRootIdentity;
    }

    
    protected boolean isAfterAxis(int axisRoot, int identity)
    {   
      
			
			
      do
      {
        if(identity == axisRoot)
          return false;
        identity = m_parent.elementAt(identity);
      }
        while(identity >= axisRoot);
        
      return true;
    }

    
    public int first(int context, int expandedTypeID)
    {

      if (isIndexed(expandedTypeID))
      {
        int identity = getSubtreeRoot(context);
        int firstPotential = getFirstPotential(identity);

        return makeNodeHandle(getNextIndexed(identity, firstPotential, expandedTypeID));
      }

      return next(context, context, expandedTypeID);
    }

    
    public int next(int context, int current)
    {

      int subtreeRootIdent = getSubtreeRoot(context);

      for (current = makeNodeIdentity(current) + 1; ; current++)
      {
        int type = _type(current);  

        if (!isDescendant(subtreeRootIdent, current))
          return NULL;

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type)
          continue;

        return makeNodeHandle(current);  
      }
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      int subtreeRootIdent = getSubtreeRoot(context);

      current = makeNodeIdentity(current) + 1;

      if (isIndexed(expandedTypeID))
      {
        return makeNodeHandle(getNextIndexed(subtreeRootIdent, current, expandedTypeID));
      }

      for (; ; current++)
      {
        int exptype = _exptype(current);  

        if (!isDescendant(subtreeRootIdent, current))
          return NULL;

        if (exptype != expandedTypeID)
          continue;

        return makeNodeHandle(current);  
      }
    }
  }

  
  private class DescendantOrSelfTraverser extends DescendantTraverser
  {

    
    protected int getFirstPotential(int identity)
    {
      return identity;
    }

    
    public int first(int context)
    {
      return context;
    }
  }

  
  private class AllFromNodeTraverser extends DescendantOrSelfTraverser
  {

    
    public int next(int context, int current)
    {

      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) + 1; ; current++)
      {
        
        
        
        
        
        _exptype(current);  

        if (!isDescendant(subtreeRootIdent, current))
          return NULL;

        return makeNodeHandle(current);  
      }
    }
  }

  
  private class FollowingTraverser extends DescendantTraverser
  {

    
    public int first(int context)
    {
			
			context=makeNodeIdentity(context);

      int first;
      int type = _type(context);

      if ((DTM.ATTRIBUTE_NODE == type) || (DTM.NAMESPACE_NODE == type))
      {
        context = _parent(context);
        first = _firstch(context);

        if (NULL != first)
          return makeNodeHandle(first);
      }

      do
      {
        first = _nextsib(context);

        if (NULL == first)
          context = _parent(context);
      }
      while (NULL == first && NULL != context);

      return makeNodeHandle(first);
    }

    
    public int first(int context, int expandedTypeID)
    {
			
			
      int first;
      int type = getNodeType(context);

      if ((DTM.ATTRIBUTE_NODE == type) || (DTM.NAMESPACE_NODE == type))
      {
        context = getParent(context);
        first = getFirstChild(context);

        if (NULL != first)
        {
          if (getExpandedTypeID(first) == expandedTypeID)
            return first;
          else
            return next(context, first, expandedTypeID);
        }
      }

      do
      {
        first = getNextSibling(context);

        if (NULL == first)
          context = getParent(context);
        else
        {
          if (getExpandedTypeID(first) == expandedTypeID)
            return first;
          else
            return next(context, first, expandedTypeID);
        }
      }
      while (NULL == first && NULL != context);

      return first;
    }

    
    public int next(int context, int current)
    {
			
			current=makeNodeIdentity(current);

      while (true)
      {
        current++; 

				
        int type = _type(current);  

        if (NULL == type)
          return NULL;

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type)
          continue;

        return makeNodeHandle(current);  
      }
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
			current=makeNodeIdentity(current);

      while (true)
      {
        current++;

        int etype = _exptype(current);  

        if (NULL == etype)
          return NULL;

        if (etype != expandedTypeID)
          continue;

        return makeNodeHandle(current);  
      }
    }
  }

  
  private class FollowingSiblingTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
      return getNextSibling(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      while (DTM.NULL != (current = getNextSibling(current)))
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }

      return NULL;
    }
  }

  
  private class NamespaceDeclsTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {

      return (context == current)
             ? getFirstNamespaceNode(context, false)
             : getNextNamespaceNode(context, current, false);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      current = (context == current)
                ? getFirstNamespaceNode(context, false)
                : getNextNamespaceNode(context, current, false);

      do
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }
      while (DTM.NULL
             != (current = getNextNamespaceNode(context, current, false)));

      return NULL;
    }
  }

  
  private class NamespaceTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {

      return (context == current)
             ? getFirstNamespaceNode(context, true)
             : getNextNamespaceNode(context, current, true);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      current = (context == current)
                ? getFirstNamespaceNode(context, true)
                : getNextNamespaceNode(context, current, true);

      do
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }
      while (DTM.NULL
             != (current = getNextNamespaceNode(context, current, true)));

      return NULL;
    }
  }

  
  private class ParentTraverser extends DTMAxisTraverser
  {
    
    public int first(int context)
    {
      return getParent(context);
    }
  
    
    public int first(int current, int expandedTypeID)
    {
			
      current = makeNodeIdentity(current);

      while (NULL != (current = m_parent.elementAt(current)))
      {
        if (m_exptype.elementAt(current) == expandedTypeID)
          return makeNodeHandle(current);
      }

      return NULL;
    }


    
    public int next(int context, int current)
    {

      return NULL;
    }
    


    
    public int next(int context, int current, int expandedTypeID)
    {

      return NULL;
    }
  }

  
  private class PrecedingTraverser extends DTMAxisTraverser
  {

    
    protected boolean isAncestor(int contextIdent, int currentIdent)
    {
			
			
      for (contextIdent = m_parent.elementAt(contextIdent); DTM.NULL != contextIdent;
              contextIdent = m_parent.elementAt(contextIdent))
      {
        if (contextIdent == currentIdent)
          return true;
      }

      return false;
    }

    
    public int next(int context, int current)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) - 1; current >= 0; current--)
      {
        short type = _type(current);

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type
                || isAncestor(subtreeRootIdent, current))
          continue;

        return makeNodeHandle(current);  
      }

      return NULL;
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) - 1; current >= 0; current--)
      {
        int exptype = m_exptype.elementAt(current);

        if (exptype != expandedTypeID
                || isAncestor(subtreeRootIdent, current))
          continue;

        return makeNodeHandle(current);  
      }

      return NULL;
    }
  }

  
  private class PrecedingAndAncestorTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context );

      for (current = makeNodeIdentity(current) - 1; current >= 0; current--)
      {
        short type = _type(current);

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type)
          continue;

        return makeNodeHandle(current);  
      }

      return NULL;
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) - 1; current >= 0; current--)
      {
        int exptype = m_exptype.elementAt(current);

        if (exptype != expandedTypeID)
          continue;

        return makeNodeHandle(current);  
      }

      return NULL;
    }
  }

  
  private class PrecedingSiblingTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
      return getPreviousSibling(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      while (DTM.NULL != (current = getPreviousSibling(current)))
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }

      return NULL;
    }
  }

  
  private class SelfTraverser extends DTMAxisTraverser
  {

    
    public int first(int context)
    {
      return context;
    }

    
    public int first(int context, int expandedTypeID)
    {
      return (getExpandedTypeID(context) == expandedTypeID) ? context : NULL;
    }

    
    public int next(int context, int current)
    {
      return NULL;
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
      return NULL;
    }
  }

  
  private class AllFromRootTraverser extends AllFromNodeTraverser
  {

    
    public int first(int context)
    {
      return getDocumentRoot(context);
    }

    
    public int first(int context, int expandedTypeID)
    {
      return (getExpandedTypeID(getDocumentRoot(context)) == expandedTypeID)
             ? context : next(context, context, expandedTypeID);
    }

    
    public int next(int context, int current)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) + 1; ; current++)
      {
				
        int type = _type(current);  
        if (type == NULL)
          return NULL;

        return makeNodeHandle(current);  
      }
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) + 1; ; current++)
      {
        int exptype = _exptype(current);  

        if (exptype == NULL)
          return NULL;

        if (exptype != expandedTypeID)
          continue;

        return makeNodeHandle(current);  
      }
    }
  }

  
  private class RootTraverser extends AllFromRootTraverser
  {
    
    public int first(int context, int expandedTypeID)
    {
      int root=getDocumentRoot(context);
      return (getExpandedTypeID(root) == expandedTypeID)
	? root : NULL;
    }

    
    public int next(int context, int current)
    {
      return NULL;
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
      return NULL;
    }
  }

  
  private class DescendantOrSelfFromRootTraverser extends DescendantTraverser
  {

    
    protected int getFirstPotential(int identity)
    {
      return identity;
    }

    
    protected int getSubtreeRoot(int handle)
    {
			
      return makeNodeIdentity(getDocument());
    }

    
    public int first(int context)
    {
      return getDocumentRoot(context);
    }
    
    
    public int first(int context, int expandedTypeID)
    {
      if (isIndexed(expandedTypeID))
      {
        int identity = 0;
        int firstPotential = getFirstPotential(identity);

        return makeNodeHandle(getNextIndexed(identity, firstPotential, expandedTypeID));
      }

      int root = first(context); 
      return next(root, root, expandedTypeID);
    }
  }
  
  
  private class DescendantFromRootTraverser extends DescendantTraverser
  {

    
    protected int getFirstPotential(int identity)
    {
      return _firstch(0);
    }

    
    protected int getSubtreeRoot(int handle)
    {
      return 0;
    }

    
    public int first(int context)
    {
      return makeNodeHandle(_firstch(0));
    }
    
    
    public int first(int context, int expandedTypeID)
    {
      if (isIndexed(expandedTypeID))
      {
        int identity = 0; 
        int firstPotential = getFirstPotential(identity);

        return makeNodeHandle(getNextIndexed(identity, firstPotential, expandedTypeID));
      }

      int root = getDocumentRoot(context); 
      return next(root, root, expandedTypeID);
    }
    
  }

}
"
org.apache.xalan.xsltc.compiler.Import,5,3,0,14,45,4,0,14,4,0.5,244,1.0,1,0.9375,0.36,2,5,47.6,11,2.8,2,"

package org.apache.xalan.xsltc.compiler;

import java.io.File;
import java.net.URL;
import java.util.Enumeration;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;

final class Import extends TopLevelElement {

    private Stylesheet _imported = null;

    public Stylesheet getImportedStylesheet() {
	return _imported;
    }

    public void parseContents(final Parser parser) {
	final Stylesheet context = parser.getCurrentStylesheet();

	try {
	    String docToLoad = getAttribute(""href"");
	    if (context.checkForLoop(docToLoad)) {
		final ErrorMsg msg = new ErrorMsg(ErrorMsg.CIRCULAR_INCLUDE_ERR,
                                                  docToLoad, this);
		parser.reportError(Constants.FATAL, msg);
		return;
	    }

	    String currLoadedDoc = context.getSystemId();
	    SourceLoader loader = context.getSourceLoader();
	    InputSource input = null;
	    XMLReader reader = null;

	    if (loader != null) {
		final XSLTC xsltc = parser.getXSLTC();
		input = loader.loadSource(docToLoad, currLoadedDoc, xsltc);
		reader = xsltc.getXMLReader();
	    }
	    else {
		File file = new File(currLoadedDoc);
		if (file.exists()) currLoadedDoc = ""file:""+currLoadedDoc;
		final URL url = new URL(new URL(currLoadedDoc), docToLoad);
		docToLoad = url.toString();
		input = new InputSource(docToLoad);
	    }

	    
	    if (input == null) {
		final ErrorMsg msg = 
		    new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, docToLoad, this);
		parser.reportError(Constants.FATAL, msg);
		return;
	    }

	    final SyntaxTreeNode root;
            if (reader != null) {
                root = parser.parse(reader,input);
            }
            else {
                root = parser.parse(input);
            }

	    if (root == null) return;
	    _imported = parser.makeStylesheet(root);
	    if (_imported == null) return;

	    _imported.setSourceLoader(loader);
	    _imported.setSystemId(docToLoad);
	    _imported.setParentStylesheet(context);
	    _imported.setImportingStylesheet(context);

	    
	    final int currPrecedence = parser.getCurrentImportPrecedence();
	    final int nextPrecedence = parser.getNextImportPrecedence();
	    _imported.setImportPrecedence(currPrecedence);
	    context.setImportPrecedence(nextPrecedence);
	    parser.setCurrentStylesheet(_imported);
	    _imported.parseContents(parser);

	    final Enumeration elements = _imported.elements();
	    final Stylesheet topStylesheet = parser.getTopLevelStylesheet();
	    while (elements.hasMoreElements()) {
		final Object element = elements.nextElement();
		if (element instanceof TopLevelElement) {
		    if (element instanceof Variable) {
			topStylesheet.addVariable((Variable) element);
		    }
		    else if (element instanceof Param) {
			topStylesheet.addParam((Param) element);
		    }
		    else {
			topStylesheet.addElement((TopLevelElement) element);
		    }
		}
	    }
	}
	catch (Exception e) {
	    e.printStackTrace();
	}
	finally {
	    parser.setCurrentStylesheet(context);
	}
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }
}
"
org.apache.xml.utils.NodeVector,30,1,1,9,33,0,9,0,30,0.422413793,933,1.0,0,0.0,0.4,0,0,29.96666667,5,2.1667,1,"
package org.apache.xml.utils;

import java.io.Serializable;

import org.apache.xml.dtm.DTM;


public class NodeVector implements Serializable, Cloneable
{

  
  private int m_blocksize;

  
  private int m_map[];

  
  protected int m_firstFree = 0;

  
  private int m_mapSize;  

  
  public NodeVector()
  {
    m_blocksize = 32;
    m_mapSize = 0;
  }

  
  public NodeVector(int blocksize)
  {
    m_blocksize = blocksize;
    m_mapSize = 0;
  }

  
  public Object clone() throws CloneNotSupportedException
  {

    NodeVector clone = (NodeVector) super.clone();

    if ((null != this.m_map) && (this.m_map == clone.m_map))
    {
      clone.m_map = new int[this.m_map.length];

      System.arraycopy(this.m_map, 0, clone.m_map, 0, this.m_map.length);
    }

    return clone;
  }

  
  public int size()
  {
    return m_firstFree;
  }

  
  public void addElement(int value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      if (null == m_map)
      {
        m_map = new int[m_blocksize];
        m_mapSize = m_blocksize;
      }
      else
      {
        m_mapSize += m_blocksize;

        int newMap[] = new int[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

        m_map = newMap;
      }
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final void push(int value)
  {

    int ff = m_firstFree;

    if ((ff + 1) >= m_mapSize)
    {
      if (null == m_map)
      {
        m_map = new int[m_blocksize];
        m_mapSize = m_blocksize;
      }
      else
      {
        m_mapSize += m_blocksize;

        int newMap[] = new int[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, ff + 1);

        m_map = newMap;
      }
    }

    m_map[ff] = value;

    ff++;

    m_firstFree = ff;
  }

  
  public final int pop()
  {

    m_firstFree--;

    int n = m_map[m_firstFree];

    m_map[m_firstFree] = DTM.NULL;

    return n;
  }

  
  public final int popAndTop()
  {

    m_firstFree--;

    m_map[m_firstFree] = DTM.NULL;

    return (m_firstFree == 0) ? DTM.NULL : m_map[m_firstFree - 1];
  }

  
  public final void popQuick()
  {

    m_firstFree--;

    m_map[m_firstFree] = DTM.NULL;
  }

  
  public final int peepOrNull()
  {
    return ((null != m_map) && (m_firstFree > 0))
           ? m_map[m_firstFree - 1] : DTM.NULL;
  }

  
  public final void pushPair(int v1, int v2)
  {

    if (null == m_map)
    {
      m_map = new int[m_blocksize];
      m_mapSize = m_blocksize;
    }
    else
    {
      if ((m_firstFree + 2) >= m_mapSize)
      {
        m_mapSize += m_blocksize;

        int newMap[] = new int[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, m_firstFree);

        m_map = newMap;
      }
    }

    m_map[m_firstFree] = v1;
    m_map[m_firstFree + 1] = v2;
    m_firstFree += 2;
  }

  
  public final void popPair()
  {

    m_firstFree -= 2;
    m_map[m_firstFree] = DTM.NULL;
    m_map[m_firstFree + 1] = DTM.NULL;
  }

  
  public final void setTail(int n)
  {
    m_map[m_firstFree - 1] = n;
  }

  
  public final void setTailSub1(int n)
  {
    m_map[m_firstFree - 2] = n;
  }

  
  public final int peepTail()
  {
    return m_map[m_firstFree - 1];
  }

  
  public final int peepTailSub1()
  {
    return m_map[m_firstFree - 2];
  }

  
  public void insertInOrder(int value)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (value < m_map[i])
      {
        insertElementAt(value, i);

        return;
      }
    }

    addElement(value);
  }

  
  public void insertElementAt(int value, int at)
  {

    if (null == m_map)
    {
      m_map = new int[m_blocksize];
      m_mapSize = m_blocksize;
    }
    else if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    if (at <= (m_firstFree - 1))
    {
      System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);
    }

    m_map[at] = value;

    m_firstFree++;
  }

  
  public void appendNodes(NodeVector nodes)
  {

    int nNodes = nodes.size();

    if (null == m_map)
    {
      m_mapSize = nNodes + m_blocksize;
      m_map = new int[m_mapSize];
    }
    else if ((m_firstFree + nNodes) >= m_mapSize)
    {
      m_mapSize += (nNodes + m_blocksize);

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + nNodes);

      m_map = newMap;
    }

    System.arraycopy(nodes.m_map, 0, m_map, m_firstFree, nNodes);

    m_firstFree += nNodes;
  }

  
  public void removeAllElements()
  {

    if (null == m_map)
      return;

    for (int i = 0; i < m_firstFree; i++)
    {
      m_map[i] = DTM.NULL;
    }

    m_firstFree = 0;
  }
  
  
  public void RemoveAllNoClear()
  {

    if (null == m_map)
      return;

    m_firstFree = 0;
  }

  
  public boolean removeElement(int s)
  {

    if (null == m_map)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      int node = m_map[i];

      if (node == s)
      {
        if (i > m_firstFree)
          System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
        else
          m_map[i] = DTM.NULL;

        m_firstFree--;

        return true;
      }
    }

    return false;
  }

  
  public void removeElementAt(int i)
  {

    if (null == m_map)
      return;

    if (i > m_firstFree)
      System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
    else
      m_map[i] = DTM.NULL;
  }

  
  public void setElementAt(int node, int index)
  {

    if (null == m_map)
    {
      m_map = new int[m_blocksize];
      m_mapSize = m_blocksize;
    }
    
    if(index == -1)
    	addElement(node);

    m_map[index] = node;
  }

  
  public int elementAt(int i)
  {

    if (null == m_map)
      return DTM.NULL;

    return m_map[i];
  }

  
  public boolean contains(int s)
  {

    if (null == m_map)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      int node = m_map[i];

      if (node == s)
        return true;
    }

    return false;
  }

  
  public int indexOf(int elem, int index)
  {

    if (null == m_map)
      return -1;

    for (int i = index; i < m_firstFree; i++)
    {
      int node = m_map[i];

      if (node == elem)
        return i;
    }

    return -1;
  }

  
  public int indexOf(int elem)
  {

    if (null == m_map)
      return -1;

    for (int i = 0; i < m_firstFree; i++)
    {
      int node = m_map[i];

      if (node == elem)
        return i;
    }

    return -1;
  }

  
  public void sort(int a[], int lo0, int hi0) throws Exception
  {

    int lo = lo0;
    int hi = hi0;

    
    if (lo >= hi)
    {
      return;
    }
    else if (lo == hi - 1)
    {

      
      if (a[lo] > a[hi])
      {
        int T = a[lo];

        a[lo] = a[hi];
        a[hi] = T;
      }

      return;
    }

    
    int pivot = a[(lo + hi) / 2];

    a[(lo + hi) / 2] = a[hi];
    a[hi] = pivot;

    while (lo < hi)
    {

      
      while (a[lo] <= pivot && lo < hi)
      {
        lo++;
      }

      
      while (pivot <= a[hi] && lo < hi)
      {
        hi--;
      }

      
      if (lo < hi)
      {
        int T = a[lo];

        a[lo] = a[hi];
        a[hi] = T;

        
      }

      
      
      
    }

    
    a[hi0] = a[hi];
    a[hi] = pivot;

    
    sort(a, lo0, lo - 1);
    sort(a, hi + 1, hi0);
  }

  
  public void sort() throws Exception
  {
    sort(m_map, 0, m_firstFree - 1);
  }
}
"
org.apache.xml.dtm.DTMWSFilter,1,1,0,27,1,0,26,1,1,2.0,4,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xml.dtm;


public interface DTMWSFilter
{
  
  public static final short NOTSTRIP = 1;

  
  public static final short STRIP = 2;

  
  public static final short INHERIT = 3;

  
  public short getShouldStripSpace(int elementHandle, DTM dtm);
  
}"
org.w3c.dom.xpath.XPathException,1,4,0,0,2,0,0,0,1,2.0,11,0.0,0,1.0,1.0,0,0,7.0,0,0.0,0,"

package org.w3c.dom.xpath;


public class XPathException extends RuntimeException {
    public XPathException(short code, String message) {
       super(message);
       this.code = code;
    }
    public short   code;
    
    
    public static final short INVALID_EXPRESSION_ERR    = 1;
    
    public static final short TYPE_ERR                  = 2;

}
"
org.apache.xalan.processor.ProcessorStripSpace,2,5,0,8,14,1,1,7,1,2.0,50,0.0,0,0.995283019,0.625,2,2,24.0,1,0.5,0,"
package org.apache.xalan.processor;

import java.util.Vector;

import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.WhiteSpaceInfo;
import org.apache.xpath.XPath;

import org.xml.sax.Attributes;


class ProcessorStripSpace extends ProcessorPreserveSpace
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {
    Stylesheet thisSheet = handler.getStylesheet();
	WhitespaceInfoPaths paths = new WhitespaceInfoPaths(thisSheet);
    setPropertiesFromAttributes(handler, rawName, attributes, paths);

    Vector xpaths = paths.getElements();

    for (int i = 0; i < xpaths.size(); i++)
    {
      WhiteSpaceInfo wsi = new WhiteSpaceInfo((XPath) xpaths.elementAt(i), true, thisSheet);
      wsi.setUid(handler.nextUid());

      thisSheet.setStripSpaces(wsi);
    }
    paths.clearElements();

  }
}
"
org.apache.xalan.xsltc.compiler.XSLTC,57,1,0,24,146,1224,19,9,50,0.895408163,1289,0.828571429,3,0.0,0.115288221,0,0,21.0,16,1.7018,1,"

package org.apache.xalan.xsltc.compiler;

import java.io.BufferedOutputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.URL;
import java.util.Date;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Map;
import java.util.Properties;
import java.util.Vector;
import java.util.jar.JarEntry;
import java.util.jar.JarOutputStream;
import java.util.jar.Manifest;

import org.apache.bcel.classfile.JavaClass;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xml.dtm.DTM;

import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;

public final class XSLTC {

    
    private Parser _parser;

    
    private XMLReader _reader = null;

    
    private SourceLoader _loader = null;
    
    
    private Stylesheet _stylesheet = null;

    
    
    private int _modeSerial         = 1;
    private int _stylesheetSerial   = 1;
    private int _stepPatternSerial  = 1;
    private int _helperClassSerial  = 0;
    private int _attributeSetSerial = 0;
    
    private int[] _numberFieldIndexes;
    
    
    private int       _nextGType;  
    private Vector    _namesIndex; 
    private Hashtable _elements;   
    private Hashtable _attributes; 

    
    private int       _nextNSType; 
    private Vector    _namespaceIndex; 
    private Hashtable _namespaces; 

    
    public static final int FILE_OUTPUT        = 0;
    public static final int JAR_OUTPUT         = 1;
    public static final int BYTEARRAY_OUTPUT   = 2;
    public static final int CLASSLOADER_OUTPUT = 3;
    public static final int BYTEARRAY_AND_FILE_OUTPUT = 4;
    public static final int BYTEARRAY_AND_JAR_OUTPUT  = 5;
    

    
    private boolean _debug = false;      
    private String  _jarFileName = null; 
    private String  _className = null;   
    private String  _packageName = null; 
    private File    _destDir = null;     
    private int     _outputType = FILE_OUTPUT; 

    private Vector  _classes;
    private Vector  _bcelClasses;
    private boolean _callsNodeset = false;
    private boolean _multiDocument = false;
    private boolean _hasIdCall = false;

    
    private boolean _templateInlining = false;

    
    public XSLTC() {
	_parser = new Parser(this);
    }

    
    public Parser getParser() {
        return _parser;
    }

    
    public void setOutputType(int type) {
	_outputType = type;
    }

    
    public Properties getOutputProperties() {
	return _parser.getOutputProperties();
    }

    
    public void init() {
	reset();
	_reader = null;
	_classes = new Vector();
	_bcelClasses = new Vector();
    }
    
    
    private void reset() {
	_nextGType      = DTM.NTYPES;
	_elements       = new Hashtable();
	_attributes     = new Hashtable();
	_namespaces     = new Hashtable();
	_namespaces.put("""",new Integer(_nextNSType));
	_namesIndex     = new Vector(128);
	_namespaceIndex = new Vector(32);
	_parser.init();
	
	_modeSerial         = 1;
	_stylesheetSerial   = 1;
	_stepPatternSerial  = 1;
	_helperClassSerial  = 0;
	_attributeSetSerial = 0;
	_multiDocument      = false;
	_hasIdCall          = false;
	_numberFieldIndexes = new int[] {
	    -1, 	
	    -1, 	
	    -1		
	};
    }

        
    public void setSourceLoader(SourceLoader loader) {
	_loader = loader;
    }

    
    public void setTemplateInlining(boolean templateInlining) {
	_templateInlining = templateInlining;
    }

    
    public void setPIParameters(String media, String title, String charset) {
	_parser.setPIParameters(media, title, charset);
    }
    
    
    public boolean compile(URL url) {
	try {
	    
	    final InputStream stream = url.openStream();
	    final InputSource input = new InputSource(stream);
	    input.setSystemId(url.toString());
	    return compile(input, _className);
	}
	catch (IOException e) {
	    _parser.reportError(Constants.FATAL, new ErrorMsg(e));
	    return false;
	}
    }

    
    public boolean compile(URL url, String name) {
	try {
	    
	    final InputStream stream = url.openStream();
	    final InputSource input = new InputSource(stream);
	    input.setSystemId(url.toString());
	    return compile(input, name);
	}
	catch (IOException e) {
	    _parser.reportError(Constants.FATAL, new ErrorMsg(e));
	    return false;
	}
    }

    
    public boolean compile(InputStream stream, String name) {
	final InputSource input = new InputSource(stream);
	input.setSystemId(name); 
	return compile(input, name);
    }

    
    public boolean compile(InputSource input, String name) {
	try {
	    
	    reset();

	    
	    String systemId = null; 
	    if (input != null) {
	        systemId = input.getSystemId();
	    }

	    
	    if (_className == null) {
		if (name != null)
		    setClassName(name);
		else if ((systemId != null) && (!systemId.equals("""")))
		    setClassName(Util.baseName(systemId));
		else
		    setClassName(""GregorSamsa""); 
	    }

	    
	    SyntaxTreeNode element = null;
	    if (_reader == null) {
		element = _parser.parse(input);
	    }
	    else {
		element = _parser.parse(_reader, input);
	    }

	    
	    if ((!_parser.errorsFound()) && (element != null)) {
		
		_stylesheet = _parser.makeStylesheet(element);
		_stylesheet.setSourceLoader(_loader);
		_stylesheet.setSystemId(systemId);
		_stylesheet.setParentStylesheet(null);
		_stylesheet.setTemplateInlining(_templateInlining);
		_parser.setCurrentStylesheet(_stylesheet);

		
		_parser.createAST(_stylesheet);
	    }
	    
	    if ((!_parser.errorsFound()) && (_stylesheet != null)) {
		_stylesheet.setCallsNodeset(_callsNodeset);
		_stylesheet.setMultiDocument(_multiDocument);
		_stylesheet.setHasIdCall(_hasIdCall);

		
		synchronized (getClass()) {
		    _stylesheet.translate();
		}
	    }
	}
	catch (Exception e) {
	     e.printStackTrace();
	    _parser.reportError(Constants.FATAL, new ErrorMsg(e));
	}
	catch (Error e) {
	    if (_debug) e.printStackTrace();
	    _parser.reportError(Constants.FATAL, new ErrorMsg(e));
	}
	finally {
	    _reader = null; 
	    return !_parser.errorsFound();
	}
    }

    
    public boolean compile(Vector stylesheets) {
	
	final int count = stylesheets.size();
	
	
	if (count == 0) return true;

	
	
	if (count == 1) {
	    final Object url = stylesheets.firstElement();
	    if (url instanceof URL)
		return compile((URL)url);
	    else
		return false;
	}
	else {
	    
	    final Enumeration urls = stylesheets.elements();
	    while (urls.hasMoreElements()) {
		_className = null; 
		final Object url = urls.nextElement();
		if (url instanceof URL) {
		    if (!compile((URL)url)) return false;
		}
	    }
	}
	return true;
    }

    
    public byte[][] getBytecodes() {
	final int count = _classes.size();
	final byte[][] result = new byte[count][1];
	for (int i = 0; i < count; i++)
	    result[i] = (byte[])_classes.elementAt(i);
	return result;
    }

    
    public byte[][] compile(String name, InputSource input, int outputType) {
	_outputType = outputType;
	if (compile(input, name))
	    return getBytecodes();
	else
	    return null;
    }
    
    
    public byte[][] compile(String name, InputSource input) {
        return compile(name, input, BYTEARRAY_OUTPUT);
    }    

    
    public void setXMLReader(XMLReader reader) {
	_reader = reader;
    }
    
    
    public XMLReader getXMLReader() {
	return _reader ;
    }

    
    public Vector getErrors() {
	return _parser.getErrors();
    }

    
    public Vector getWarnings() {
	return _parser.getWarnings();
    }

    
    public void printErrors() {
	_parser.printErrors();
    }

    
    public void printWarnings() {
	_parser.printWarnings();
    }

    
    protected void setMultiDocument(boolean flag) {
	_multiDocument = flag;
    }

    public boolean isMultiDocument() {
	return _multiDocument;
    }

    
    protected void setCallsNodeset(boolean flag) {
	if (flag) setMultiDocument(flag);
	_callsNodeset = flag;
    }

    public boolean callsNodeset() {
	return _callsNodeset;
    }
    
    protected void setHasIdCall(boolean flag) {
    	_hasIdCall = flag;
    }
    
    public boolean hasIdCall() {
    	return _hasIdCall;
    }

    
    public void setClassName(String className) {
	final String base  = Util.baseName(className);
	final String noext = Util.noExtName(base); 
	String name  = Util.toJavaName(noext);

	if (_packageName == null)
	    _className = name;
	else
	    _className = _packageName + '.' + name;
    }
    
    
    public String getClassName() {
	return _className;
    }

    
    private String classFileName(final String className) {
	return className.replace('.', File.separatorChar) + "".class"";
    }
    
    
    private File getOutputFile(String className) {
	if (_destDir != null)
	    return new File(_destDir, classFileName(className));
	else
	    return new File(classFileName(className));
    }

    
    public boolean setDestDirectory(String dstDirName) {
	final File dir = new File(dstDirName);
	if (dir.exists() || dir.mkdirs()) {
	    _destDir = dir;
	    return true;
	}
	else {
	    _destDir = null;
	    return false;
	}
    }

    
    public void setPackageName(String packageName) {
	_packageName = packageName;
	if (_className != null) setClassName(_className);
    }

    
    public void setJarFileName(String jarFileName) {
	final String JAR_EXT = "".jar"";
	if (jarFileName.endsWith(JAR_EXT))
	    _jarFileName = jarFileName;
	else
	    _jarFileName = jarFileName + JAR_EXT;
	_outputType = JAR_OUTPUT;
    }

    public String getJarFileName() {
	return _jarFileName;
    }

    
    public void setStylesheet(Stylesheet stylesheet) {
	if (_stylesheet == null) _stylesheet = stylesheet;
    }

    
    public Stylesheet getStylesheet() {
	return _stylesheet;
    }
   
    
    public int registerAttribute(QName name) {
	Integer code = (Integer)_attributes.get(name.toString());
	if (code == null) {
	    code = new Integer(_nextGType++);
	    _attributes.put(name.toString(), code);
	    final String uri = name.getNamespace();
	    final String local = ""@""+name.getLocalPart();
	    if ((uri != null) && (!uri.equals("""")))
		_namesIndex.addElement(uri+"":""+local);
	    else
		_namesIndex.addElement(local);
	    if (name.getLocalPart().equals(""*"")) {
		registerNamespace(name.getNamespace());
	    }
	}
	return code.intValue();
    }

    
    public int registerElement(QName name) {
	
	Integer code = (Integer)_elements.get(name.toString());
	if (code == null) {
	    _elements.put(name.toString(), code = new Integer(_nextGType++));
	    _namesIndex.addElement(name.toString());
	}
	if (name.getLocalPart().equals(""*"")) {
	    registerNamespace(name.getNamespace());
	}
	return code.intValue();
    }

    
    public int registerNamespace(QName name) {
	final SymbolTable stable = _parser.getSymbolTable();
	final String uri = stable.lookupNamespace(name.toString());
	final int code = registerNamespace(uri);
	return code; 
    }

    
    public int registerNamespace(String namespaceURI) {
	Integer code = (Integer)_namespaces.get(namespaceURI);
	if (code == null) {
	    code = new Integer(_nextNSType++);
	    _namespaces.put(namespaceURI,code);
	    _namespaceIndex.addElement(namespaceURI);
	}
	return code.intValue();
    }
    
    public int nextModeSerial() {
	return _modeSerial++;
    }

    public int nextStylesheetSerial() {
	return _stylesheetSerial++;
    }

    public int nextStepPatternSerial() {
	return _stepPatternSerial++;
    }

    public int[] getNumberFieldIndexes() {
	return _numberFieldIndexes;
    }

    public int nextHelperClassSerial() {
	return _helperClassSerial++;
    }
    
    public int nextAttributeSetSerial() {
	return _attributeSetSerial++;
    }

    public Vector getNamesIndex() {
	return _namesIndex;
    }

    public Vector getNamespaceIndex() {
	return _namespaceIndex;
    }
    
    
    public String getHelperClassName() {
	return getClassName() + '$' + _helperClassSerial++;
    }
   
    public void dumpClass(JavaClass clazz) {
	
	if (_outputType == FILE_OUTPUT || 
	    _outputType == BYTEARRAY_AND_FILE_OUTPUT) 
	{
	    File outFile = getOutputFile(clazz.getClassName());
	    String parentDir = outFile.getParent();
	    if (parentDir != null) {
	      	File parentFile = new File(parentDir);
	      	if (!parentFile.exists())
	            parentFile.mkdirs();
	    }
	}
	
	try {
	    switch (_outputType) {
	    case FILE_OUTPUT:
		clazz.dump(
		    new BufferedOutputStream(
			new FileOutputStream(
			    getOutputFile(clazz.getClassName()))));
		break;
	    case JAR_OUTPUT:
		_bcelClasses.addElement(clazz);	 
		break;
	    case BYTEARRAY_OUTPUT:
	    case BYTEARRAY_AND_FILE_OUTPUT:
	    case BYTEARRAY_AND_JAR_OUTPUT:
	    case CLASSLOADER_OUTPUT:
		ByteArrayOutputStream out = new ByteArrayOutputStream(2048);
		clazz.dump(out);
		_classes.addElement(out.toByteArray());
		
		if (_outputType == BYTEARRAY_AND_FILE_OUTPUT)
		  clazz.dump(new BufferedOutputStream(
			new FileOutputStream(getOutputFile(clazz.getClassName()))));
		else if (_outputType == BYTEARRAY_AND_JAR_OUTPUT)
		  _bcelClasses.addElement(clazz);
		  
		break;
	    }
	}
	catch (Exception e) {
	    e.printStackTrace();
	}
    }

    
    private String entryName(File f) throws IOException {
	return f.getName().replace(File.separatorChar, '/');
    }
    
    
    public void outputToJar() throws IOException {
	
	final Manifest manifest = new Manifest();
	final java.util.jar.Attributes atrs = manifest.getMainAttributes();
	atrs.put(java.util.jar.Attributes.Name.MANIFEST_VERSION,""1.2"");

	final Map map = manifest.getEntries();
	
	Enumeration classes = _bcelClasses.elements();
	final String now = (new Date()).toString();
	final java.util.jar.Attributes.Name dateAttr = 
	    new java.util.jar.Attributes.Name(""Date"");
	while (classes.hasMoreElements()) {
	    final JavaClass clazz = (JavaClass)classes.nextElement();
	    final String className = clazz.getClassName().replace('.','/');
	    final java.util.jar.Attributes attr = new java.util.jar.Attributes();
	    attr.put(dateAttr, now);
	    map.put(className+"".class"", attr);
	}

	final File jarFile = new File(_destDir, _jarFileName);
	final JarOutputStream jos =
	    new JarOutputStream(new FileOutputStream(jarFile), manifest);
	classes = _bcelClasses.elements();
	while (classes.hasMoreElements()) {
	    final JavaClass clazz = (JavaClass)classes.nextElement();
	    final String className = clazz.getClassName().replace('.','/');
	    jos.putNextEntry(new JarEntry(className+"".class""));
	    final ByteArrayOutputStream out = new ByteArrayOutputStream(2048);
	    clazz.dump(out); 
	    out.writeTo(jos);
	}
	jos.close();
    }

    
    public void setDebug(boolean debug) {
	_debug = debug;
    }

    
    public boolean debug() {
	return _debug;
    }

}
"
org.apache.xml.utils.synthetic.reflection.Constructor,5,2,0,3,13,4,2,3,5,1.0,61,1.0,3,0.904761905,0.5,1,1,10.0,1,0.4,1,"
package org.apache.xml.utils.synthetic.reflection;



public class Constructor extends EntryPoint implements Member
{

  
  private org.apache.xml.utils.synthetic.Class declaringclass = null;

  
  private java.lang.reflect.Constructor realconstructor = null;

  
  private org.apache.xml.utils.synthetic.Class[] parametertypes;

  
  private String[] parameternames;

  
  private org.apache.xml.utils.synthetic.Class[] exceptiontypes;

  
  private int modifiers;

  
  public Constructor(org.apache.xml.utils.synthetic.Class declaringclass)
  {
    super(declaringclass);
  }

  
  public Constructor(java.lang.reflect.Constructor ctor,
                     org.apache.xml.utils.synthetic.Class declaringclass)
  {
    super(ctor, declaringclass);
  }

  
  public Constructor(java.lang.reflect.Constructor realconstructor)
  {
    super(realconstructor);
  }

  
  public int hashCode()
  {
    return getDeclaringClass().getName().hashCode();
  }

  
  public Object newInstance(Object initargs[])
          throws InstantiationException, IllegalAccessException,
                 IllegalArgumentException,
                 java.lang.reflect.InvocationTargetException
  {

    if (realep != null)
      return ((java.lang.reflect.Constructor) realep).newInstance(initargs);
    else
      throw new InstantiationException(
        ""Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation"");
  }
}
"
org.apache.xalan.xsltc.trax.DOM2SAX,25,1,0,3,71,254,2,1,20,0.892857143,582,1.0,1,0.0,0.152727273,0,0,22.0,3,1.08,0,"


package org.apache.xalan.xsltc.trax;

import java.io.IOException;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Vector;

import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.XMLReader;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.AttributesImpl;
import org.apache.xalan.xsltc.dom.SAXImpl;

public class DOM2SAX implements XMLReader, Locator {

    private final static String EMPTYSTRING = """";
    private static final String XMLNS_PREFIX = ""xmlns"";

    private Node _dom = null;
    private ContentHandler _sax = null;
    private LexicalHandler _lex = null;
    private SAXImpl _saxImpl = null;
    private Hashtable _nsPrefixes = new Hashtable();

    public DOM2SAX(Node root) {
	_dom = root;
    }

    public ContentHandler getContentHandler() { 
	return _sax;
    }

    public void setContentHandler(ContentHandler handler) throws 
	NullPointerException 
    {
	_sax = handler;
	if (handler instanceof LexicalHandler) {
	    _lex = (LexicalHandler) handler;
	}
	
	if (handler instanceof SAXImpl) {
	    _saxImpl = (SAXImpl)handler;
	}
    }

    
    private boolean startPrefixMapping(String prefix, String uri) 
	throws SAXException 
    {
	boolean pushed = true;
	Stack uriStack = (Stack) _nsPrefixes.get(prefix);

	if (uriStack != null) {
	    if (uriStack.isEmpty()) {
		_sax.startPrefixMapping(prefix, uri);
		uriStack.push(uri);
	    }
	    else {
		final String lastUri = (String) uriStack.peek();
		if (!lastUri.equals(uri)) {
		    _sax.startPrefixMapping(prefix, uri);
		    uriStack.push(uri);
		}
		else {
		    pushed = false;
		}
	    }	
	}
	else {
	    _sax.startPrefixMapping(prefix, uri);
	    _nsPrefixes.put(prefix, uriStack = new Stack());
	    uriStack.push(uri);
	}
	return pushed;
    }

    
    private void endPrefixMapping(String prefix) 
	throws SAXException
    {
	final Stack uriStack = (Stack) _nsPrefixes.get(prefix);

	if (uriStack != null) {
	    _sax.endPrefixMapping(prefix);
	    uriStack.pop();
	}
    }

    
    private static String getLocalName(Node node) {
	final String localName = node.getLocalName();

	if (localName == null) {
	    final String qname = node.getNodeName();
	    final int col = qname.lastIndexOf(':');
	    return (col > 0) ? qname.substring(col + 1) : qname;
	}
	return localName;
    }

    public void parse(InputSource unused) throws IOException, SAXException {
        parse(_dom);
    }

    public void parse() throws IOException, SAXException {
	if (_dom != null) {
	    boolean isIncomplete = 
		(_dom.getNodeType() != org.w3c.dom.Node.DOCUMENT_NODE);

	    if (isIncomplete) {
		_sax.startDocument();
		parse(_dom);
		_sax.endDocument();
	    }
	    else {
		parse(_dom);
	    }
	}
    }

    
    private void parse(Node node) throws IOException, SAXException {
        Node first = null;
 	if (node == null) return;

        switch (node.getNodeType()) {
	case Node.ATTRIBUTE_NODE:         
	case Node.DOCUMENT_FRAGMENT_NODE:
	case Node.DOCUMENT_TYPE_NODE :
	case Node.ENTITY_NODE :
	case Node.ENTITY_REFERENCE_NODE:
	case Node.NOTATION_NODE :
	    
	    break;
	case Node.CDATA_SECTION_NODE:
	    final String cdata = node.getNodeValue();
	    if (_lex != null) {
		_lex.startCDATA();
	        _sax.characters(cdata.toCharArray(), 0, cdata.length());
		_lex.endCDATA();
 	    } 
	    else {
		
		
	        _sax.characters(cdata.toCharArray(), 0, cdata.length());
	    }	
	    break;

	case Node.COMMENT_NODE:           
	    if (_lex != null) {
		final String value = node.getNodeValue();
		_lex.comment(value.toCharArray(), 0, value.length());
	    }
	    break;
	case Node.DOCUMENT_NODE:
	    _sax.setDocumentLocator(this);

	    _sax.startDocument();
	    Node next = node.getFirstChild();
	    while (next != null) {
		parse(next);
		next = next.getNextSibling();
	    }
	    _sax.endDocument();
	    break;

	case Node.ELEMENT_NODE:
	    String prefix;
	    Vector pushedPrefixes = new Vector();
	    final AttributesImpl attrs = new AttributesImpl();
	    final NamedNodeMap map = node.getAttributes();
	    final int length = map.getLength();

	    
	    for (int i = 0; i < length; i++) {
		final Node attr = map.item(i);
		final String qnameAttr = attr.getNodeName();

		
		if (qnameAttr.startsWith(XMLNS_PREFIX)) {
		    final String uriAttr = attr.getNodeValue();
		    final int colon = qnameAttr.lastIndexOf(':');
		    prefix = (colon > 0) ? qnameAttr.substring(colon + 1) : EMPTYSTRING;
		    if (startPrefixMapping(prefix, uriAttr)) {
			pushedPrefixes.addElement(prefix);
		    }
		}
	    }

	    
	    for (int i = 0; i < length; i++) {
		final Node attr = map.item(i);
		final String qnameAttr = attr.getNodeName();

		
		if (!qnameAttr.startsWith(XMLNS_PREFIX)) {
		    final String uriAttr = attr.getNamespaceURI();
		    final String localNameAttr = getLocalName(attr);

		    
		    if (uriAttr != null) {	
			final int colon = qnameAttr.lastIndexOf(':');
			prefix = (colon > 0) ? qnameAttr.substring(0, colon) : EMPTYSTRING;
			if (startPrefixMapping(prefix, uriAttr)) {
			    pushedPrefixes.addElement(prefix);
			}
		    }

		    
		    attrs.addAttribute(attr.getNamespaceURI(), getLocalName(attr), 
			qnameAttr, ""CDATA"", attr.getNodeValue());
		}
	    }

	    
	    final String qname = node.getNodeName();
	    final String uri = node.getNamespaceURI();
	    final String localName = getLocalName(node);

	    
	    if (uri != null) {	
		final int colon = qname.lastIndexOf(':');
		prefix = (colon > 0) ? qname.substring(0, colon) : EMPTYSTRING;
		if (startPrefixMapping(prefix, uri)) {
		    pushedPrefixes.addElement(prefix);
		}
	    }

	    
	    if (_saxImpl != null) {
	        _saxImpl.startElement(uri, localName, qname, attrs, node);
	    }
	    else {
	        _sax.startElement(uri, localName, qname, attrs);
	    }

	    
	    next = node.getFirstChild();
	    while (next != null) {
		parse(next);
		next = next.getNextSibling();
	    }

	    
	    _sax.endElement(uri, localName, qname);

	    
	    final int nPushedPrefixes = pushedPrefixes.size();
	    for (int i = 0; i < nPushedPrefixes; i++) {
		endPrefixMapping((String) pushedPrefixes.elementAt(i));
	    }
	    break;

	case Node.PROCESSING_INSTRUCTION_NODE:
	    _sax.processingInstruction(node.getNodeName(),
				       node.getNodeValue());
	    break;

	case Node.TEXT_NODE:
	    final String data = node.getNodeValue();
	    _sax.characters(data.toCharArray(), 0, data.length());
	    break;
	}
    }

    
    public DTDHandler getDTDHandler() { 
	return null;
    }

    
    public ErrorHandler getErrorHandler() {
	return null;
    }

    
    public boolean getFeature(String name) throws SAXNotRecognizedException,
	SAXNotSupportedException
    {
	return false;
    }

    
    public void setFeature(String name, boolean value) throws 
	SAXNotRecognizedException, SAXNotSupportedException 
    {
    }

    
    public void parse(String sysId) throws IOException, SAXException {
	throw new IOException(""This method is not yet implemented."");
    }

    
    public void setDTDHandler(DTDHandler handler) throws NullPointerException {
    }

    
    public void setEntityResolver(EntityResolver resolver) throws 
	NullPointerException 
    {
    }

    
    public EntityResolver getEntityResolver() {
	return null;
    }

    
    public void setErrorHandler(ErrorHandler handler) throws 
	NullPointerException
    {
    }

    
    public void setProperty(String name, Object value) throws
	SAXNotRecognizedException, SAXNotSupportedException {
    }

    
    public Object getProperty(String name) throws SAXNotRecognizedException,
	SAXNotSupportedException
    {
	return null;
    }

    
    public int getColumnNumber() { 
	return 0; 
    }
    
    
    public int getLineNumber() { 
	return 0; 
    }

    
    public String getPublicId() { 
	return null; 
    }

    
    public String getSystemId() { 
	return null; 
    }

    
    private String getNodeTypeFromCode(short code) {
	String retval = null;
	switch (code) {
	case Node.ATTRIBUTE_NODE : 
	    retval = ""ATTRIBUTE_NODE""; break; 
	case Node.CDATA_SECTION_NODE :
	    retval = ""CDATA_SECTION_NODE""; break; 
	case Node.COMMENT_NODE :
	    retval = ""COMMENT_NODE""; break; 
	case Node.DOCUMENT_FRAGMENT_NODE :
	    retval = ""DOCUMENT_FRAGMENT_NODE""; break; 
	case Node.DOCUMENT_NODE :
	    retval = ""DOCUMENT_NODE""; break; 
	case Node.DOCUMENT_TYPE_NODE :
	    retval = ""DOCUMENT_TYPE_NODE""; break; 
	case Node.ELEMENT_NODE :
	    retval = ""ELEMENT_NODE""; break; 
	case Node.ENTITY_NODE :
	    retval = ""ENTITY_NODE""; break; 
	case Node.ENTITY_REFERENCE_NODE :
	    retval = ""ENTITY_REFERENCE_NODE""; break; 
	case Node.NOTATION_NODE :
	    retval = ""NOTATION_NODE""; break; 
	case Node.PROCESSING_INSTRUCTION_NODE :
	    retval = ""PROCESSING_INSTRUCTION_NODE""; break; 
	case Node.TEXT_NODE:
	    retval = ""TEXT_NODE""; break; 
        }
	return retval;
    }
}
"
org.apache.xml.dtm.SecuritySupport,7,1,1,2,14,19,2,1,5,0.833333333,76,1.0,0,0.0,0.375,0,0,9.714285714,2,0.8571,0,"

package org.apache.xml.dtm;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;


class SecuritySupport {

    
    private static final Object securitySupport;

    static {
	SecuritySupport ss = null;
	try {
	    Class c = Class.forName(""java.security.AccessController"");
	    
	    
	    
	    ss = new SecuritySupport12();
	} catch (Exception ex) {
	    
	} finally {
	    if (ss == null)
		ss = new SecuritySupport();
	    securitySupport = ss;
	}
    }

    
    public static SecuritySupport getInstance() {
	return (SecuritySupport)securitySupport;
    }

    public ClassLoader getContextClassLoader() {
	return null;
    }

    public String getSystemProperty(String propName) {
        return System.getProperty(propName);
    }

    public FileInputStream getFileInputStream(File file)
        throws FileNotFoundException
    {
        return new FileInputStream(file);
    }

    public InputStream getResourceAsStream(ClassLoader cl, String name) {
        InputStream ris;
        if (cl == null) {
            ris = ClassLoader.getSystemResourceAsStream(name);
        } else {
            ris = cl.getResourceAsStream(name);
        }
        return ris;
    }
}
"
org.apache.xalan.xsltc.dom.SingletonIterator,8,2,0,4,11,0,2,2,8,0.214285714,105,1.0,0,0.722222222,0.5,1,6,11.875,4,1.125,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;

public class SingletonIterator extends DTMAxisIteratorBase {
    private int _node;
    private final boolean _isConstant;

    public SingletonIterator() {
	this(Integer.MIN_VALUE, false);
    }

    public SingletonIterator(int node) {
	this(node, false);
    }

    public SingletonIterator(int node, boolean constant) {
	_node = _startNode = node;
	_isConstant = constant;
    }
    
    
    public DTMAxisIterator setStartNode(int node) {
	if (_isConstant) {
	    _node = _startNode;
	    return resetPosition();
	}
	else if (_isRestartable) {
	    if (_node <= 0)
		_node = _startNode = node;
	    return resetPosition();
	}
	return this;
    }
	
    public DTMAxisIterator reset() {
	if (_isConstant) {
	    _node = _startNode;
	    return resetPosition();
	}
	else {
	    final boolean temp = _isRestartable;
	    _isRestartable = true;
	    setStartNode(_startNode);
	    _isRestartable = temp;
	}
	return this;
    }
    
    public int next() {
	final int result = _node;
	_node = DTMAxisIterator.END;
	return returnNode(result);
    }

    public void setMark() {
	_markedNode = _node;
    }

    public void gotoMark() {
	_node = _markedNode;
    }
}
"
org.apache.xpath.objects.XNumber,13,3,0,42,36,22,38,5,12,0.416666667,330,0.0,0,0.865853659,0.182692308,2,22,24.30769231,13,2.4615,1,"
package org.apache.xpath.objects;

import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;


public class XNumber extends XObject
{

  
  double m_val;

  
  public XNumber(double d)
  {
    super();

    m_val = d;
  }
  
  
  public XNumber(Number num)
  {

    super();

    m_val = num.doubleValue();
    m_obj = num;
  }

  
  public int getType()
  {
    return CLASS_NUMBER;
  }

  
  public String getTypeString()
  {
    return ""#NUMBER"";
  }

  
  public double num()
  {
    return m_val;
  }
  
  
  public double num(XPathContext xctxt) 
    throws javax.xml.transform.TransformerException
  {

    return m_val;
  }

  
  public boolean bool()
  {
    return (Double.isNaN(m_val) || (m_val == 0.0)) ? false : true;
  }























































































































































  
  public String str()
  {

    if (Double.isNaN(m_val))
    {
      return ""NaN"";
    }
    else if (Double.isInfinite(m_val))
    {
      if (m_val > 0)
        return ""Infinity"";
      else
        return ""-Infinity"";
    }

    double num = m_val;
    String s = Double.toString(num);
    int len = s.length();

    if (s.charAt(len - 2) == '.' && s.charAt(len - 1) == '0')
    {
      s = s.substring(0, len - 2);

      if (s.equals(""-0""))
        return ""0"";

      return s;
    }

    int e = s.indexOf('E');

    if (e < 0)
    {
      if (s.charAt(len - 1) == '0')
        return s.substring(0, len - 1);
      else
        return s;
    }

    int exp = Integer.parseInt(s.substring(e + 1));
    String sign;

    if (s.charAt(0) == '-')
    {
      sign = ""-"";
      s = s.substring(1);

      --e;
    }
    else
      sign = """";

    int nDigits = e - 2;

    if (exp >= nDigits)
      return sign + s.substring(0, 1) + s.substring(2, e)
             + zeros(exp - nDigits);

    
    while (s.charAt(e-1) == '0')
      e--;
         
    if (exp > 0)
      return sign + s.substring(0, 1) + s.substring(2, 2 + exp) + "".""
             + s.substring(2 + exp, e);

    return sign + ""0."" + zeros(-1 - exp) + s.substring(0, 1)
           + s.substring(2, e);
  }


  
  static private String zeros(int n)
  {
    if (n < 1)
      return """";

    char[] buf = new char[n];

    for (int i = 0; i < n; i++)
    {
      buf[i] = '0';
    }

    return new String(buf);
  }

  
  public Object object()
  {
    if(null == m_obj)
      m_obj = new Double(m_val);
    return m_obj;
  }

  
  public boolean equals(XObject obj2)
  {

    
    
    
    int t = obj2.getType();
    try
    {
	    if (t == XObject.CLASS_NODESET)
	      return obj2.equals(this);
	    else if(t == XObject.CLASS_BOOLEAN)
	      return obj2.bool() == bool();
		else
	       return m_val == obj2.num();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }
  
  
  public boolean isStableNumber()
  {
    return true;
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	visitor.visitNumberLiteral(owner, this);
  }


}
"
org.apache.xpath.axes.RTFIterator,1,3,0,4,2,0,2,2,1,2.0,6,0.0,0,1.0,1.0,0,0,5.0,0,0.0,1,"


package org.apache.xpath.axes;

import org.apache.xml.dtm.DTMManager;
import org.apache.xpath.NodeSetDTM;

public class RTFIterator extends NodeSetDTM {

		
	public RTFIterator(int root, DTMManager manager) {
		super(root, manager);
	}
}

"
org.apache.xalan.transformer.XalanTransformState,10,1,0,8,21,0,1,8,10,0.711111111,205,0.0,5,0.0,0.4,0,0,18.5,3,1.7,0,"

package org.apache.xalan.transformer;

import javax.xml.transform.Transformer;

import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.w3c.dom.Node;
import org.w3c.dom.traversal.NodeIterator;


public class XalanTransformState
    implements TransformState {
        
    Node m_node = null;
    ElemTemplateElement m_currentElement = null;
    ElemTemplate m_currentTemplate = null;
    ElemTemplate m_matchedTemplate = null;
    int m_currentNodeHandle = DTM.NULL;
    Node m_currentNode = null;
    int m_matchedNode = DTM.NULL;
    DTMIterator m_contextNodeList = null;
    boolean m_elemPending = false;    
    TransformerImpl m_transformer = null;

    
    public void setCurrentNode(Node n) {
        m_node = n;
    }

    
    public void resetState(Transformer transformer) {
        if ((transformer != null) && (transformer instanceof TransformerImpl)) {
           m_transformer = (TransformerImpl)transformer;
           m_currentElement = m_transformer.getCurrentElement();
           m_currentTemplate = m_transformer.getCurrentTemplate();
           m_matchedTemplate = m_transformer.getMatchedTemplate();
           int currentNodeHandle = m_transformer.getCurrentNode();
           DTM dtm = m_transformer.getXPathContext().getDTM(currentNodeHandle);
           m_currentNode = dtm.getNode(currentNodeHandle);
           m_matchedNode = m_transformer.getMatchedNode();
           m_contextNodeList = m_transformer.getContextNodeList();    
        }       
    }

    
    public ElemTemplateElement getCurrentElement() {
      if (m_elemPending)
         return m_currentElement;
      else
         return m_transformer.getCurrentElement();
    }

    
    public Node getCurrentNode() {
      if (m_currentNode != null) {
         return m_currentNode;
      } else {
         DTM dtm = m_transformer.getXPathContext().getDTM(m_transformer.getCurrentNode());
         return dtm.getNode(m_transformer.getCurrentNode());
      }
    }
    
    
    public ElemTemplate getCurrentTemplate() {
       if (m_elemPending)
         return m_currentTemplate;
       else
         return m_transformer.getCurrentTemplate();
    }

    
    public ElemTemplate getMatchedTemplate() {
      if (m_elemPending)
         return m_matchedTemplate;
      else
         return m_transformer.getMatchedTemplate();
    }

    
    public Node getMatchedNode() {
 
       if (m_elemPending) {
         DTM dtm = m_transformer.getXPathContext().getDTM(m_matchedNode);
         return dtm.getNode(m_matchedNode);
       } else {
         DTM dtm = m_transformer.getXPathContext().getDTM(m_transformer.getMatchedNode());
         return dtm.getNode(m_transformer.getMatchedNode());
       }
    }

    
    public NodeIterator getContextNodeList() {
      if (m_elemPending) {
          return new org.apache.xml.dtm.ref.DTMNodeIterator(m_contextNodeList);
      } else {
          return new org.apache.xml.dtm.ref.DTMNodeIterator(m_transformer.getContextNodeList());
      }
    }
    
    public Transformer getTransformer() {
        return m_transformer;
    }

}
"
org.apache.xalan.processor.StopParseException,1,4,0,2,2,0,2,0,0,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,1,"
package org.apache.xalan.processor;


public class StopParseException extends org.xml.sax.SAXException
{

  
  StopParseException()
  {
    super(""Stylesheet PIs found, stop the parse"");
  }
}
"
org.apache.xml.utils.res.XResources_he,3,4,0,1,4,1,0,1,2,0.5,426,0.0,0,0.976190476,1.0,0,0,140.6666667,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_he extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""he"" }, { ""help_language"", ""he"" }, { ""language"", ""he"" },
    { ""alphabet"",
      new char[]{ 0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6,
                  0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD,
                  0x05DE, 0x05DF, 0x05E0, 0x05E1 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""RightToLeft"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    { ""numberGroups"", new int[]{ 10, 1 } },

    
    
    
    
    { ""digits"",
      new char[]{ 0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6,
                  0x05D7, 0x05D8 } },
    { ""tens"",
      new char[]{ 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
                  0x05E0, 0x05E1 } },

    
    { ""tables"", new String[]{ ""tens"", ""digits"" } }
  };
}
"
org.apache.xalan.processor.StylesheetPIHandler,6,2,0,3,26,3,1,2,6,0.733333333,462,0.0,0,0.772727273,0.458333333,1,1,75.0,2,1.0,1,"
package org.apache.xalan.processor;

import java.util.StringTokenizer;
import java.util.Vector;

import javax.xml.transform.Source;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.sax.SAXSource;

import org.apache.xml.utils.SystemIDResolver;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.helpers.DefaultHandler;


public class StylesheetPIHandler extends DefaultHandler
{
  
  String m_baseID;

  
  String m_media;

  
  String m_title;

  
  String m_charset;

  
  Vector m_stylesheets = new Vector();
  
  
  
  
  URIResolver m_uriResolver;

  
  public void setURIResolver(URIResolver resolver)
  {
    m_uriResolver = resolver;
  }

  
  public URIResolver getURIResolver()
  {
    return m_uriResolver;
  }

  
  public StylesheetPIHandler(String baseID, String media, String title,
                             String charset)
  {

    m_baseID = baseID;
    m_media = media;
    m_title = title;
    m_charset = charset;
  }

  
  public Source getAssociatedStylesheet()
  {

    int sz = m_stylesheets.size();

    if (sz > 0)
    {
      Source source = (Source) m_stylesheets.elementAt(sz-1);
      return source;      
    }
    else
      return null;
  }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {

    if (target.equals(""xml-stylesheet""))
    {
      String href = null;  
      String type = null;  
      String title = null;  
      String media = null;  
      String charset = null;  
      boolean alternate = false;  
      StringTokenizer tokenizer = new StringTokenizer(data, "" 	=
"", true);
      boolean lookedAhead = false; 
      Source source = null;

      String token = """";
      while (tokenizer.hasMoreTokens())
      {        
        if (!lookedAhead)
          token = tokenizer.nextToken();
        else
          lookedAhead = false;
        if (tokenizer.hasMoreTokens() && 
               (token.equals("" "") || token.equals(""	"") || token.equals(""="")))
          continue;
          
        String name = token;  
        if (name.equals(""type""))
        { 
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          type = token.substring(1, token.length() - 1);
          
        }
        else if (name.equals(""href""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          href = token;
          if (tokenizer.hasMoreTokens())
          {
            token = tokenizer.nextToken();
            
            
            
            
            
            
            
            
            while ( token.equals(""="") && tokenizer.hasMoreTokens())
            {  
              href = href + token + tokenizer.nextToken();
              if (tokenizer.hasMoreTokens())
              {  
                token = tokenizer.nextToken();
                lookedAhead = true;
              }
              else
              {
                break;
              }
            }
          }
          href = href.substring(1, href.length() - 1);
          try
          { 
            
            if (m_uriResolver != null) 
            {
              source = m_uriResolver.resolve(href, m_baseID);
            } 
           else 
            {
              href = SystemIDResolver.getAbsoluteURI(href, m_baseID);
              source = new SAXSource(new InputSource(href));
            }            
          }
          catch(TransformerException te)
          {
            throw new org.xml.sax.SAXException(te);
          }
        }
        else if (name.equals(""title""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          title = token.substring(1, token.length() - 1);
        }
        else if (name.equals(""media""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          media = token.substring(1, token.length() - 1);
        }
        else if (name.equals(""charset""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
              (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          charset = token.substring(1, token.length() - 1);
        }
        else if (name.equals(""alternate""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          alternate = token.substring(1, token.length()
                                             - 1).equals(""yes"");
        }
        
      }

      if ((null != type) 
          && (type.equals(""text/xsl"") || type.equals(""text/xml"") || type.equals(""application/xml+xslt""))  
          && (null != href))
      {
        if (null != m_media)
        {
          if (null != media)
          {
            if (!media.equals(m_media))
              return;
          }
          else
            return;
        }

        if (null != m_charset)
        {
          if (null != charset)
          {
            if (!charset.equals(m_charset))
              return;
          }
          else
            return;
        }

        if (null != m_title)
        {
          if (null != title)
          {
            if (!title.equals(m_title))
              return;
          }
          else
            return;
        }

        m_stylesheets.addElement(source);
      }
    }
  }
  
  
  
  public void startElement(
          String namespaceURI, String localName, String qName, Attributes atts)
            throws org.xml.sax.SAXException
  {
    throw new StopParseException();
  }
}
"
org.apache.xalan.xsltc.compiler.CastExpr,9,3,0,57,49,0,33,24,8,0.583333333,536,1.0,2,0.91025641,0.3125,2,7,58.22222222,5,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.IF_ICMPNE;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.SIPUSH;
import org.apache.xalan.xsltc.compiler.util.BooleanType;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.MultiHashtable;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.ResultTreeType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.dom.Axis;

final class CastExpr extends Expression {
    private final Expression _left;

    
    static private MultiHashtable InternalTypeMap = new MultiHashtable();

    static {
	
	InternalTypeMap.put(Type.Boolean, Type.Boolean);
	InternalTypeMap.put(Type.Boolean, Type.Real);
	InternalTypeMap.put(Type.Boolean, Type.String);
	InternalTypeMap.put(Type.Boolean, Type.Reference);
        InternalTypeMap.put(Type.Boolean, Type.Object);

	InternalTypeMap.put(Type.Real, Type.Real);
	InternalTypeMap.put(Type.Real, Type.Int);
	InternalTypeMap.put(Type.Real, Type.Boolean);
	InternalTypeMap.put(Type.Real, Type.String);
	InternalTypeMap.put(Type.Real, Type.Reference);
        InternalTypeMap.put(Type.Real, Type.Object);

	InternalTypeMap.put(Type.Int, Type.Int);
	InternalTypeMap.put(Type.Int, Type.Real);
	InternalTypeMap.put(Type.Int, Type.Boolean);
	InternalTypeMap.put(Type.Int, Type.String);
	InternalTypeMap.put(Type.Int, Type.Reference);
        InternalTypeMap.put(Type.Int, Type.Object);

	InternalTypeMap.put(Type.String, Type.String);
	InternalTypeMap.put(Type.String, Type.Boolean);
	InternalTypeMap.put(Type.String, Type.Real);
	InternalTypeMap.put(Type.String, Type.Reference);
        InternalTypeMap.put(Type.String, Type.Object);

	InternalTypeMap.put(Type.NodeSet, Type.NodeSet);
	InternalTypeMap.put(Type.NodeSet, Type.Boolean);
	InternalTypeMap.put(Type.NodeSet, Type.Real);
	InternalTypeMap.put(Type.NodeSet, Type.String);
	InternalTypeMap.put(Type.NodeSet, Type.Node);
	InternalTypeMap.put(Type.NodeSet, Type.Reference);
	InternalTypeMap.put(Type.NodeSet, Type.Object);

	InternalTypeMap.put(Type.Node, Type.Node);
	InternalTypeMap.put(Type.Node, Type.Boolean);
	InternalTypeMap.put(Type.Node, Type.Real);
	InternalTypeMap.put(Type.Node, Type.String);
	InternalTypeMap.put(Type.Node, Type.NodeSet);
	InternalTypeMap.put(Type.Node, Type.Reference);
	InternalTypeMap.put(Type.Node, Type.Object);

	InternalTypeMap.put(Type.ResultTree, Type.ResultTree);
	InternalTypeMap.put(Type.ResultTree, Type.Boolean);
	InternalTypeMap.put(Type.ResultTree, Type.Real);
	InternalTypeMap.put(Type.ResultTree, Type.String);
	InternalTypeMap.put(Type.ResultTree, Type.NodeSet);
	InternalTypeMap.put(Type.ResultTree, Type.Reference);
	InternalTypeMap.put(Type.ResultTree, Type.Object);

	InternalTypeMap.put(Type.Reference, Type.Reference);
	InternalTypeMap.put(Type.Reference, Type.Boolean);
	InternalTypeMap.put(Type.Reference, Type.Int);
	InternalTypeMap.put(Type.Reference, Type.Real);
	InternalTypeMap.put(Type.Reference, Type.String);
	InternalTypeMap.put(Type.Reference, Type.Node);
	InternalTypeMap.put(Type.Reference, Type.NodeSet);
	InternalTypeMap.put(Type.Reference, Type.ResultTree);
	InternalTypeMap.put(Type.Reference, Type.Object);

	InternalTypeMap.put(Type.Object, Type.String);

	InternalTypeMap.put(Type.Void, Type.String);
    }

    private boolean _typeTest = false;

    
    public CastExpr(Expression left, Type type) throws TypeCheckError {
	_left = left;
	_type = type;		

	if ((_left instanceof Step) && (_type == Type.Boolean)) {
	    Step step = (Step)_left;
	    if ((step.getAxis() == Axis.SELF) && (step.getNodeType() != -1)) 
		_typeTest = true;
	}
	
	
	setParser(left.getParser());
	setParent(left.getParent());
	left.setParent(this);
	typeCheck(left.getParser().getSymbolTable());
    }
		
    public Expression getExpr() {
	return _left;
    }

    
    public boolean hasPositionCall() {
	return(_left.hasPositionCall());
    }

    public boolean hasLastCall() {
	return(_left.hasLastCall());
    }

    public String toString() {
	return ""cast("" + _left + "", "" + _type + "")"";
    }

    	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	Type tleft = _left.getType();
	if (tleft == null) {
	    tleft = _left.typeCheck(stable);
	}
	if (tleft instanceof NodeType) {
	    tleft = Type.Node;	
	}
	else if (tleft instanceof ResultTreeType) {
	    tleft = Type.ResultTree; 
	}
	if (InternalTypeMap.maps(tleft, _type) != null) {
	    return _type;
	}
	
	throw new TypeCheckError(new ErrorMsg(
	    ErrorMsg.DATA_CONVERSION_ERR, tleft.toString(), _type.toString()));
    }

    public void translateDesynthesized(ClassGenerator classGen, 
				       MethodGenerator methodGen) {
	FlowList fl;
	final Type ltype = _left.getType();

	
	
	
	if (_typeTest) {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();

	    final int idx = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getExpandedTypeID"",
                                                      ""(I)I"");
	    il.append(new SIPUSH((short)((Step)_left).getNodeType()));
	    il.append(methodGen.loadDOM());
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(idx, 2));
	    _falseList.add(il.append(new IF_ICMPNE(null)));
	}
	else {

	    _left.translate(classGen, methodGen);
	    if (_type != ltype) {
		_left.startResetIterator(classGen, methodGen);
		if (_type instanceof BooleanType) {
		    fl = ltype.translateToDesynthesized(classGen, methodGen,
							_type);
		    if (fl != null) {
			_falseList.append(fl);
		    }
		}
		else {
		    ltype.translateTo(classGen, methodGen, _type);	
		}
	    }
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Type ltype = _left.getType();
	_left.translate(classGen, methodGen);
	if (_type.identicalTo(ltype) == false) {
	    _left.startResetIterator(classGen, methodGen);
	    ltype.translateTo(classGen, methodGen, _type);
	}
    }
}
"
org.apache.xml.res.XMLErrorResources,5,3,10,10,16,8,10,0,3,1.243589744,1171,0.0,0,0.926829268,0.333333333,0,0,217.6,2,0.8,1,"
package org.apache.xml.res;


import java.util.ListResourceBundle;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;


public class XMLErrorResources extends ListResourceBundle
{



  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  
  public static final String ER_FUNCTION_NOT_SUPPORTED = ""ER_FUNCTION_NOT_SUPPORTED"";
  public static final String ER_CANNOT_OVERWRITE_CAUSE = ""ER_CANNOT_OVERWRITE_CAUSE"";
  public static final String ER_NO_DEFAULT_IMPL = ""ER_NO_DEFAULT_IMPL"";
  public static final String ER_CHUNKEDINTARRAY_NOT_SUPPORTED = ""ER_CHUNKEDINTARRAY_NOT_SUPPORTED"";
  public static final String ER_OFFSET_BIGGER_THAN_SLOT = ""ER_OFFSET_BIGGER_THAN_SLOT"";
  public static final String ER_COROUTINE_NOT_AVAIL = ""ER_COROUTINE_NOT_AVAIL"";
  public static final String ER_COROUTINE_CO_EXIT = ""ER_COROUTINE_CO_EXIT"";
  public static final String ER_COJOINROUTINESET_FAILED = ""ER_COJOINROUTINESET_FAILED"";
  public static final String ER_COROUTINE_PARAM = ""ER_COROUTINE_PARAM"";
  public static final String ER_PARSER_DOTERMINATE_ANSWERS = ""ER_PARSER_DOTERMINATE_ANSWERS"";
  public static final String ER_NO_PARSE_CALL_WHILE_PARSING = ""ER_NO_PARSE_CALL_WHILE_PARSING"";
  public static final String ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = ""ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED"";
  public static final String ER_ITERATOR_AXIS_NOT_IMPLEMENTED = ""ER_ITERATOR_AXIS_NOT_IMPLEMENTED"";
  public static final String ER_ITERATOR_CLONE_NOT_SUPPORTED = ""ER_ITERATOR_CLONE_NOT_SUPPORTED"";
  public static final String ER_UNKNOWN_AXIS_TYPE = ""ER_UNKNOWN_AXIS_TYPE"";
  public static final String ER_AXIS_NOT_SUPPORTED = ""ER_AXIS_NOT_SUPPORTED"";
  public static final String ER_NO_DTMIDS_AVAIL = ""ER_NO_DTMIDS_AVAIL"";
  public static final String ER_NOT_SUPPORTED = ""ER_NOT_SUPPORTED"";
  public static final String ER_NODE_NON_NULL = ""ER_NODE_NON_NULL"";
  public static final String ER_COULD_NOT_RESOLVE_NODE = ""ER_COULD_NOT_RESOLVE_NODE"";
  public static final String ER_STARTPARSE_WHILE_PARSING = ""ER_STARTPARSE_WHILE_PARSING"";
  public static final String ER_STARTPARSE_NEEDS_SAXPARSER = ""ER_STARTPARSE_NEEDS_SAXPARSER"";
  public static final String ER_COULD_NOT_INIT_PARSER = ""ER_COULD_NOT_INIT_PARSER"";
  public static final String ER_EXCEPTION_CREATING_POOL = ""ER_EXCEPTION_CREATING_POOL"";
  public static final String ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = ""ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE"";
  public static final String ER_SCHEME_REQUIRED = ""ER_SCHEME_REQUIRED"";
  public static final String ER_NO_SCHEME_IN_URI = ""ER_NO_SCHEME_IN_URI"";
  public static final String ER_NO_SCHEME_INURI = ""ER_NO_SCHEME_INURI"";
  public static final String ER_PATH_INVALID_CHAR = ""ER_PATH_INVALID_CHAR"";
  public static final String ER_SCHEME_FROM_NULL_STRING = ""ER_SCHEME_FROM_NULL_STRING"";
  public static final String ER_SCHEME_NOT_CONFORMANT = ""ER_SCHEME_NOT_CONFORMANT"";
  public static final String ER_HOST_ADDRESS_NOT_WELLFORMED = ""ER_HOST_ADDRESS_NOT_WELLFORMED"";
  public static final String ER_PORT_WHEN_HOST_NULL = ""ER_PORT_WHEN_HOST_NULL"";
  public static final String ER_INVALID_PORT = ""ER_INVALID_PORT"";
  public static final String ER_FRAG_FOR_GENERIC_URI =""ER_FRAG_FOR_GENERIC_URI"";
  public static final String ER_FRAG_WHEN_PATH_NULL = ""ER_FRAG_WHEN_PATH_NULL"";
  public static final String ER_FRAG_INVALID_CHAR = ""ER_FRAG_INVALID_CHAR"";
  public static final String ER_PARSER_IN_USE = ""ER_PARSER_IN_USE"";
  public static final String ER_CANNOT_CHANGE_WHILE_PARSING = ""ER_CANNOT_CHANGE_WHILE_PARSING"";
  public static final String ER_SELF_CAUSATION_NOT_PERMITTED = ""ER_SELF_CAUSATION_NOT_PERMITTED"";
  public static final String ER_NO_USERINFO_IF_NO_HOST = ""ER_NO_USERINFO_IF_NO_HOST"";
  public static final String ER_NO_PORT_IF_NO_HOST = ""ER_NO_PORT_IF_NO_HOST"";
  public static final String ER_NO_QUERY_STRING_IN_PATH = ""ER_NO_QUERY_STRING_IN_PATH"";
  public static final String ER_NO_FRAGMENT_STRING_IN_PATH = ""ER_NO_FRAGMENT_STRING_IN_PATH"";
  public static final String ER_CANNOT_INIT_URI_EMPTY_PARMS = ""ER_CANNOT_INIT_URI_EMPTY_PARMS"";
  public static final String ER_METHOD_NOT_SUPPORTED =""ER_METHOD_NOT_SUPPORTED"";
  public static final String ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = ""ER_INCRSAXSRCFILTER_NOT_RESTARTABLE"";
  public static final String ER_XMLRDR_NOT_BEFORE_STARTPARSE = ""ER_XMLRDR_NOT_BEFORE_STARTPARSE"";
  public static final String ER_AXIS_TRAVERSER_NOT_SUPPORTED = ""ER_AXIS_TRAVERSER_NOT_SUPPORTED"";
  public static final String ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = ""ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER"";
  public static final String ER_SYSTEMID_UNKNOWN = ""ER_SYSTEMID_UNKNOWN"";
  public static final String ER_LOCATION_UNKNOWN = ""ER_LOCATION_UNKNOWN"";
  public static final String ER_PREFIX_MUST_RESOLVE = ""ER_PREFIX_MUST_RESOLVE"";
  public static final String ER_CREATEDOCUMENT_NOT_SUPPORTED = ""ER_CREATEDOCUMENT_NOT_SUPPORTED"";  
  public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT = ""ER_CHILD_HAS_NO_OWNER_DOCUMENT"";
  public static final String ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = ""ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT"";  
  public static final String ER_CANT_OUTPUT_TEXT_BEFORE_DOC = ""ER_CANT_OUTPUT_TEXT_BEFORE_DOC"";  
  public static final String ER_CANT_HAVE_MORE_THAN_ONE_ROOT = ""ER_CANT_HAVE_MORE_THAN_ONE_ROOT"";  
  public static final String ER_ARG_LOCALNAME_NULL = ""ER_ARG_LOCALNAME_NULL"";  
  public static final String ER_ARG_LOCALNAME_INVALID = ""ER_ARG_LOCALNAME_INVALID"";  
  public static final String ER_ARG_PREFIX_INVALID = ""ER_ARG_PREFIX_INVALID"";  

  
  public static final String ER_RESOURCE_COULD_NOT_FIND = ""ER_RESOURCE_COULD_NOT_FIND"";
  public static final String ER_RESOURCE_COULD_NOT_LOAD = ""ER_RESOURCE_COULD_NOT_LOAD"";
  public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = ""ER_BUFFER_SIZE_LESSTHAN_ZERO"";
  public static final String ER_INVALID_UTF16_SURROGATE = ""ER_INVALID_UTF16_SURROGATE"";
  public static final String ER_OIERROR = ""ER_OIERROR"";
  public static final String ER_NAMESPACE_PREFIX = ""ER_NAMESPACE_PREFIX"";
  public static final String ER_STRAY_ATTRIBUTE = ""ER_STRAY_ATTIRBUTE"";
  public static final String ER_STRAY_NAMESPACE = ""ER_STRAY_NAMESPACE"";
  public static final String ER_COULD_NOT_LOAD_RESOURCE = ""ER_COULD_NOT_LOAD_RESOURCE"";
  public static final String ER_COULD_NOT_LOAD_METHOD_PROPERTY = ""ER_COULD_NOT_LOAD_METHOD_PROPERTY"";
  public static final String ER_SERIALIZER_NOT_CONTENTHANDLER = ""ER_SERIALIZER_NOT_CONTENTHANDLER"";
  public static final String ER_ILLEGAL_ATTRIBUTE_POSITION = ""ER_ILLEGAL_ATTRIBUTE_POSITION"";

  

  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },
 
    { ER_FUNCTION_NOT_SUPPORTED, 
      ""Function not supported!""},

    { ER_CANNOT_OVERWRITE_CAUSE,
      ""Cannot overwrite cause""},

    { ER_NO_DEFAULT_IMPL,
      ""No default implementation found ""},

    { ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
      ""ChunkedIntArray({0}) not currently supported""},

    { ER_OFFSET_BIGGER_THAN_SLOT,
      ""Offset bigger than slot""},

    { ER_COROUTINE_NOT_AVAIL,
      ""Coroutine not available, id={0}""},
    
    { ER_COROUTINE_CO_EXIT,
      ""CoroutineManager received co_exit() request""},

    { ER_COJOINROUTINESET_FAILED,
      ""co_joinCoroutineSet() failed""},

    { ER_COROUTINE_PARAM,
      ""Coroutine parameter error ({0})""},

    { ER_PARSER_DOTERMINATE_ANSWERS,
      ""
UNEXPECTED: Parser doTerminate answers {0}""},

    { ER_NO_PARSE_CALL_WHILE_PARSING,
      ""parse may not be called while parsing""},

    { ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
      ""Error: typed iterator for axis  {0} not implemented""},

    { ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
      ""Error: iterator for axis {0} not implemented ""},

    { ER_ITERATOR_CLONE_NOT_SUPPORTED,
      ""Iterator clone not supported""},

    { ER_UNKNOWN_AXIS_TYPE,
      ""Unknown axis traversal type: {0}""},

    { ER_AXIS_NOT_SUPPORTED,
      ""Axis traverser not supported: {0}""},

    { ER_NO_DTMIDS_AVAIL,
      ""No more DTM IDs are available""},

    { ER_NOT_SUPPORTED,
      ""Not supported: {0}""},
    
    { ER_NODE_NON_NULL,
      ""Node must be non-null for getDTMHandleFromNode""},

    { ER_COULD_NOT_RESOLVE_NODE,
      ""Could not resolve the node to a handle""},

    { ER_STARTPARSE_WHILE_PARSING,
       ""startParse may not be called while parsing""},

    { ER_STARTPARSE_NEEDS_SAXPARSER,
       ""startParse needs a non-null SAXParser""},

    { ER_COULD_NOT_INIT_PARSER,
       ""could not initialize parser with""},

    { ER_EXCEPTION_CREATING_POOL,
       ""exception creating new instance for pool""},

    { ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
       ""Path contains invalid escape sequence""},

    { ER_SCHEME_REQUIRED,
       ""Scheme is required!""},
    
    { ER_NO_SCHEME_IN_URI,
       ""No scheme found in URI: {0}""},

    { ER_NO_SCHEME_INURI,
       ""No scheme found in URI""},

    { ER_PATH_INVALID_CHAR,
       ""Path contains invalid character: {0}""},

    { ER_SCHEME_FROM_NULL_STRING,
       ""Cannot set scheme from null string""},

    { ER_SCHEME_NOT_CONFORMANT,
       ""The scheme is not conformant.""},

    { ER_HOST_ADDRESS_NOT_WELLFORMED,
       ""Host is not a well formed address""},

    { ER_PORT_WHEN_HOST_NULL,
       ""Port cannot be set when host is null""},

    { ER_INVALID_PORT,
       ""Invalid port number""},

    { ER_FRAG_FOR_GENERIC_URI,
       ""Fragment can only be set for a generic URI""},

    { ER_FRAG_WHEN_PATH_NULL,
       ""Fragment cannot be set when path is null""},

    { ER_FRAG_INVALID_CHAR,
       ""Fragment contains invalid character""},

    { ER_PARSER_IN_USE,
      ""Parser is already in use""},

    { ER_CANNOT_CHANGE_WHILE_PARSING,
      ""Cannot change {0} {1} while parsing""},
   
    { ER_SELF_CAUSATION_NOT_PERMITTED,
      ""Self-causation not permitted""},

    { ER_NO_USERINFO_IF_NO_HOST,
      ""Userinfo may not be specified if host is not specified""},

    { ER_NO_PORT_IF_NO_HOST,
      ""Port may not be specified if host is not specified""},

    { ER_NO_QUERY_STRING_IN_PATH, 
      ""Query string cannot be specified in path and query string""},

    { ER_NO_FRAGMENT_STRING_IN_PATH,
      ""Fragment cannot be specified in both the path and fragment""},

    { ER_CANNOT_INIT_URI_EMPTY_PARMS, 
      ""Cannot initialize URI with empty parameters""},

    { ER_METHOD_NOT_SUPPORTED,
      ""Method not yet supported ""},
    
    { ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
      ""IncrementalSAXSource_Filter not currently restartable""},

    { ER_XMLRDR_NOT_BEFORE_STARTPARSE,
      ""XMLReader not before startParse request""},

    { ER_AXIS_TRAVERSER_NOT_SUPPORTED,
      ""Axis traverser not supported: {0}""},

    { ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
      ""ListingErrorHandler created with null PrintWriter!""},

    { ER_SYSTEMID_UNKNOWN,
      ""SystemId Unknown""},

    { ER_LOCATION_UNKNOWN,
      ""Location of error unknown""},

    { ER_PREFIX_MUST_RESOLVE,
      ""Prefix must resolve to a namespace: {0}""},

    { ER_CREATEDOCUMENT_NOT_SUPPORTED,
      ""createDocument() not supported in XPathContext!""},

    { ER_CHILD_HAS_NO_OWNER_DOCUMENT,
      ""Attribute child does not have an owner document!""},

    { ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
      ""Attribute child does not have an owner document element!""},

    { ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
      ""Warning: can't output text before document element!  Ignoring...""},

    { ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
      ""Can't have more than one root on a DOM!""},

    { ER_ARG_LOCALNAME_NULL,
       ""Argument 'localName' is null""},
 
    
    
    
    { ER_ARG_LOCALNAME_INVALID,
       ""Localname in QNAME should be a valid NCName""},

    
    
    
    { ER_ARG_PREFIX_INVALID,
       ""Prefix in QNAME should be a valid NCName""},
       
    { ""BAD_CODE"", ""Parameter to createMessage was out of bounds""},
    { ""FORMAT_FAILED"", ""Exception thrown during messageFormat call""},
    { ""line"", ""Line #""},
    { ""column"",""Column #""},
    
    {ER_SERIALIZER_NOT_CONTENTHANDLER,
      ""The serializer class ''{0}'' does not implement org.xml.sax.ContentHandler.""},
    
    {ER_RESOURCE_COULD_NOT_FIND,
      ""The resource [ {0} ] could not be found.
 {1}"" },
    
    {ER_RESOURCE_COULD_NOT_LOAD,
      ""The resource [ {0} ] could not load: {1} 
 {2} 	 {3}"" },
    
    {ER_BUFFER_SIZE_LESSTHAN_ZERO,
      ""Buffer size <=0"" },
    
    {ER_INVALID_UTF16_SURROGATE,
      ""Invalid UTF-16 surrogate detected: {0} ?"" },
    
    {ER_OIERROR,
      ""IO error"" },
    
    {ER_ILLEGAL_ATTRIBUTE_POSITION,
      ""Cannot add attribute {0} after child nodes or before an element is produced.  Attribute will be ignored.""},

      
    {ER_NAMESPACE_PREFIX,
      ""Namespace for prefix ''{0}'' has not been declared."" },
      
    {ER_STRAY_ATTRIBUTE,
      ""Attribute ''{0}'' outside of element."" },

      
    {ER_STRAY_NAMESPACE,
      ""Namespace declaration ''{0}''=''{1}'' outside of element."" },

    {ER_COULD_NOT_LOAD_RESOURCE,
      ""Could not load ''{0}'' (check CLASSPATH), now using just the defaults""},
    
    {ER_COULD_NOT_LOAD_METHOD_PROPERTY,
      ""Could not load the propery file ''{0}'' for output method ''{1}'' (check CLASSPATH)"" }
    
  
  };

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  public static final XMLErrorResources loadResourceBundle(String className)
          throws MissingResourceException
  {

    Locale locale = Locale.getDefault();
    String suffix = getResourceSuffix(locale);

    try
    {

      
      return (XMLErrorResources) ResourceBundle.getBundle(className
              + suffix, locale);
    }
    catch (MissingResourceException e)
    {
      try  
      {

        
        
        return (XMLErrorResources) ResourceBundle.getBundle(className,
                new Locale(""en"", ""US""));
      }
      catch (MissingResourceException e2)
      {

        
        
        throw new MissingResourceException(
          ""Could not load any resource bundles."", className, """");
      }
    }
  }

  
  private static final String getResourceSuffix(Locale locale)
  {

    String suffix = ""_"" + locale.getLanguage();
    String country = locale.getCountry();

    if (country.equals(""TW""))
      suffix += ""_"" + country;

    return suffix;
  }
  
}"
org.apache.xml.utils.res.XResources_ja_JP_I,3,4,0,1,4,1,0,1,2,0.5,595,0.0,0,0.976190476,1.0,0,0,197.0,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_ja_JP_I extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ja"" }, { ""help_language"", ""ja"" }, { ""language"", ""ja"" },
    { ""alphabet"",
      new char[]{ 0x30a4, 0x30ed, 0x30cf, 0x30cb, 0x30db, 0x30d8, 0x30c8,
                  0x30c1, 0x30ea, 0x30cc, 0x30eb, 0x30f2, 0x30ef, 0x30ab,
                  0x30e8, 0x30bf, 0x30ec, 0x30bd, 0x30c4, 0x30cd, 0x30ca,
                  0x30e9, 0x30e0, 0x30a6, 0x30f0, 0x30ce, 0x30aa, 0x30af,
                  0x30e4, 0x30de, 0x30b1, 0x30d5, 0x30b3, 0x30a8, 0x30c6,
                  0x30a2, 0x30b5, 0x30ad, 0x30e6, 0x30e1, 0x30df, 0x30b7,
                  0x30f1, 0x30d2, 0x30e2, 0x30bb, 0x30b9 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    
    
    { ""multiplier"",
      new long[]{ Long.MAX_VALUE, Long.MAX_VALUE, 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4EAC, 0x5146, 0x5104, 0x4E07, 0x5343, 0x767e, 0x5341 } },

    
    { ""zero"", new char[0] },
    { ""digits"",
      new char[]{ 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03,
                  0x516B, 0x4E5D } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xpath.functions.FuncContains,2,5,0,5,7,1,0,5,2,2.0,36,0.0,0,0.98245614,0.75,1,6,17.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class FuncContains extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String s1 = m_arg0.execute(xctxt).str();
    String s2 = m_arg1.execute(xctxt).str();

    
    if (s1.length() == 0 && s2.length() == 0)
      return XBoolean.S_TRUE;

    int index = s1.indexOf(s2);

    return (index > -1) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.xsltc.compiler.util.MethodType,14,2,0,10,29,0,8,2,14,0.269230769,332,1.0,1,0.785714286,0.410714286,1,1,22.57142857,6,1.6429,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Vector;

public final class MethodType extends Type {
    private final Type _resultType;	
    private final Vector _argsType;
	
    public MethodType(Type resultType) {
	_argsType = null;
	_resultType = resultType;
    }

    public MethodType(Type resultType, Type arg1) {
	if (arg1 != Type.Void) {
	    _argsType = new Vector();
	    _argsType.addElement(arg1);
	}
	else {
	    _argsType = null;
	}
	_resultType = resultType;
    }

    public MethodType(Type resultType, Type arg1, Type arg2) {
	_argsType = new Vector(2);
	_argsType.addElement(arg1);
	_argsType.addElement(arg2);
	_resultType = resultType;
    }

    public MethodType(Type resultType, Type arg1, Type arg2, Type arg3) {
	_argsType = new Vector(3);
	_argsType.addElement(arg1);
	_argsType.addElement(arg2);
	_argsType.addElement(arg3);
	_resultType = resultType;
    }

    public MethodType(Type resultType, Vector argsType) {
	_resultType = resultType;
	_argsType = argsType.size() > 0 ? argsType : null;
    }

    public String toString() {
	StringBuffer result = new StringBuffer(""method{"");
	if (_argsType != null) {
	    final int count = _argsType.size();
	    for (int i=0; i<count; i++) {
		result.append(_argsType.elementAt(i));
		if (i != (count-1)) result.append(',');
	    }
	}
	else {
	    result.append(""void"");
	}
	result.append('}');
	return result.toString();
    }

    public String toSignature() {
	return toSignature("""");
    }

    
    public String toSignature(String lastArgSig) {
	final StringBuffer buffer = new StringBuffer();
	buffer.append('(');
	if (_argsType != null) {
	    final int n = _argsType.size();
	    for (int i = 0; i < n; i++) {
		buffer.append(((Type)_argsType.elementAt(i)).toSignature());
	    }
	}
	return buffer
	    .append(lastArgSig)
	    .append(')')
	    .append(_resultType.toSignature())
	    .toString();
    }

    public org.apache.bcel.generic.Type toJCType() {
	return null;	
    }

    public boolean identicalTo(Type other) {
	boolean result = false;
	if (other instanceof MethodType) {
	    final MethodType temp = (MethodType) other;
	    if (_resultType.identicalTo(temp._resultType)) {
		final int len = argsCount();
		result = len == temp.argsCount();
		for (int i = 0; i < len && result; i++) {
		    final Type arg1 = (Type)_argsType.elementAt(i);
		    final Type arg2 = (Type)temp._argsType.elementAt(i);
		    result = arg1.identicalTo(arg2);
		}
	    }
	}
	return result;	
    }
	
    public int distanceTo(Type other) {
	int result = Integer.MAX_VALUE;
	if (other instanceof MethodType) {
	    final MethodType mtype = (MethodType) other;
	    if (_argsType != null) {
		final int len = _argsType.size();
		if (len == mtype._argsType.size()) {
		    result = 0;
		    for (int i = 0; i < len; i++) {
			Type arg1 = (Type) _argsType.elementAt(i);
			Type arg2 = (Type) mtype._argsType.elementAt(i);
			final int temp = arg1.distanceTo(arg2);
			if (temp == Integer.MAX_VALUE) {
			    result = temp;  
			    break;
			}
			else {
			    result += arg1.distanceTo(arg2);
			}
		    }
		}
	    }
	    else if (mtype._argsType == null) {
		result = 0;   
	    }
	}
	return result;
    }
		
    public Type resultType() {
	return _resultType;
    }
		
    public Vector argsType() {
	return _argsType;
    }

    public int argsCount() {
	return _argsType == null ? 0 : _argsType.size();
    }
}
"
org.apache.xml.utils.FastStringBuffer,29,1,0,24,44,0,23,1,21,0.640625,1655,0.0625,1,0.0,0.242063492,0,0,55.51724138,11,3.0,0,"
package org.apache.xml.utils;


public class FastStringBuffer
{
  
  static final int DEBUG_FORCE_INIT_BITS=0;
  
  	
  	
  	
  	
  	
  	
	static boolean DEBUG_FORCE_FIXED_CHUNKSIZE=true;

	
	public static final int SUPPRESS_LEADING_WS=0x01;
	
	
	public static final int SUPPRESS_TRAILING_WS=0x02;
	
	
	public static final int SUPPRESS_BOTH
		= SUPPRESS_LEADING_WS | SUPPRESS_TRAILING_WS;

	
	private static final int CARRY_WS=0x04;

	
  int m_chunkBits = 15;

  
  int m_maxChunkBits = 15;

  
  int m_rebundleBits = 2;

  
  int m_chunkSize;  

  
  int m_chunkMask;  

  
  char[][] m_array;

  
  int m_lastChunk = 0;

  
  int m_firstFree = 0;

  
  FastStringBuffer m_innerFSB = null;

  
  public FastStringBuffer(int initChunkBits, int maxChunkBits,
                          int rebundleBits)
  {
    if(DEBUG_FORCE_INIT_BITS!=0) initChunkBits=DEBUG_FORCE_INIT_BITS;
    
    
    
    
    
    
    
    
    if(DEBUG_FORCE_FIXED_CHUNKSIZE) maxChunkBits=initChunkBits;
    

    m_array = new char[16][];

    
    if (initChunkBits > maxChunkBits)
      initChunkBits = maxChunkBits;

    m_chunkBits = initChunkBits;
    m_maxChunkBits = maxChunkBits;
    m_rebundleBits = rebundleBits;
    m_chunkSize = 1 << (initChunkBits);
    m_chunkMask = m_chunkSize - 1;
    m_array[0] = new char[m_chunkSize];
  }

  
  public FastStringBuffer(int initChunkBits, int maxChunkBits)
  {
    this(initChunkBits, maxChunkBits, 2);
  }

  
  public FastStringBuffer(int initChunkBits)
  {
    this(initChunkBits, 15, 2);
  }

  
  public FastStringBuffer()
  {

    
    
    
    
    
    this(10, 15, 2);
  }

  
  public final int size()
  {
    return (m_lastChunk << m_chunkBits) + m_firstFree;
  }

  
  public final int length()
  {
    return (m_lastChunk << m_chunkBits) + m_firstFree;
  }

  
  public final void reset()
  {

    m_lastChunk = 0;
    m_firstFree = 0;

    
    FastStringBuffer innermost = this;

    while (innermost.m_innerFSB != null)
    {
      innermost = innermost.m_innerFSB;
    }

    m_chunkBits = innermost.m_chunkBits;
    m_chunkSize = innermost.m_chunkSize;
    m_chunkMask = innermost.m_chunkMask;

    
    m_innerFSB = null;
    m_array = new char[16][0];
    m_array[0] = new char[m_chunkSize];
  }

  
  public final void setLength(int l)
  {
    m_lastChunk = l >>> m_chunkBits;

    if (m_lastChunk == 0 && m_innerFSB != null)
    {
      
      m_innerFSB.setLength(l, this);
    }
    else
    {
      m_firstFree = l & m_chunkMask;
      
	  
	  
	  
	  
	  
      if(m_firstFree==0 && m_lastChunk>0)
      {
      	--m_lastChunk;
      	m_firstFree=m_chunkSize;
      }
    }
  }

  
  private final void setLength(int l, FastStringBuffer rootFSB)
  {

    m_lastChunk = l >>> m_chunkBits;

    if (m_lastChunk == 0 && m_innerFSB != null)
    {
      m_innerFSB.setLength(l, rootFSB);
    }
    else
    {

      
      
      rootFSB.m_chunkBits = m_chunkBits;
      rootFSB.m_maxChunkBits = m_maxChunkBits;
      rootFSB.m_rebundleBits = m_rebundleBits;
      rootFSB.m_chunkSize = m_chunkSize;
      rootFSB.m_chunkMask = m_chunkMask;
      rootFSB.m_array = m_array;
      rootFSB.m_innerFSB = m_innerFSB;
      rootFSB.m_lastChunk = m_lastChunk;

      
      rootFSB.m_firstFree = l & m_chunkMask;
    }
  }

  
  public final String toString()
  {

    int length = (m_lastChunk << m_chunkBits) + m_firstFree;

    return getString(new StringBuffer(length), 0, 0, length).toString();
  }

  
  public final void append(char value)
  {
    
    char[] chunk;

    
    
    boolean lastchunk = (m_lastChunk + 1 == m_array.length);

    if (m_firstFree < m_chunkSize)  
      chunk = m_array[m_lastChunk];
    else
    {

      
      int i = m_array.length;

      if (m_lastChunk + 1 == i)
      {
        char[][] newarray = new char[i + 16][];

        System.arraycopy(m_array, 0, newarray, 0, i);

        m_array = newarray;
      }

      
      chunk = m_array[++m_lastChunk];

      if (chunk == null)
      {

        
        if (m_lastChunk == 1 << m_rebundleBits
                && m_chunkBits < m_maxChunkBits)
        {

          
          
          m_innerFSB = new FastStringBuffer(this);
        }

        
        chunk = m_array[m_lastChunk] = new char[m_chunkSize];
      }

      m_firstFree = 0;
    }

    
    chunk[m_firstFree++] = value;
  }

  
  public final void append(String value)
  {

    if (value == null) 
      return;
    int strlen = value.length();

    if (0 == strlen)
      return;

    int copyfrom = 0;
    char[] chunk = m_array[m_lastChunk];
    int available = m_chunkSize - m_firstFree;

    
    while (strlen > 0)
    {

      
      if (available > strlen)
        available = strlen;

      value.getChars(copyfrom, copyfrom + available, m_array[m_lastChunk],
                     m_firstFree);

      strlen -= available;
      copyfrom += available;

      
      if (strlen > 0)
      {

        
        int i = m_array.length;

        if (m_lastChunk + 1 == i)
        {
          char[][] newarray = new char[i + 16][];

          System.arraycopy(m_array, 0, newarray, 0, i);

          m_array = newarray;
        }

        
        chunk = m_array[++m_lastChunk];

        if (chunk == null)
        {

          
          if (m_lastChunk == 1 << m_rebundleBits
                  && m_chunkBits < m_maxChunkBits)
          {

            
            
            m_innerFSB = new FastStringBuffer(this);
          }

          
          chunk = m_array[m_lastChunk] = new char[m_chunkSize];
        }

        available = m_chunkSize;
        m_firstFree = 0;
      }
    }

    
    m_firstFree += available;
  }

  
  public final void append(StringBuffer value)
  {

    if (value == null) 
      return;
    int strlen = value.length();

    if (0 == strlen)
      return;

    int copyfrom = 0;
    char[] chunk = m_array[m_lastChunk];
    int available = m_chunkSize - m_firstFree;

    
    while (strlen > 0)
    {

      
      if (available > strlen)
        available = strlen;

      value.getChars(copyfrom, copyfrom + available, m_array[m_lastChunk],
                     m_firstFree);

      strlen -= available;
      copyfrom += available;

      
      if (strlen > 0)
      {

        
        int i = m_array.length;

        if (m_lastChunk + 1 == i)
        {
          char[][] newarray = new char[i + 16][];

          System.arraycopy(m_array, 0, newarray, 0, i);

          m_array = newarray;
        }

        
        chunk = m_array[++m_lastChunk];

        if (chunk == null)
        {

          
          if (m_lastChunk == 1 << m_rebundleBits
                  && m_chunkBits < m_maxChunkBits)
          {

            
            
            m_innerFSB = new FastStringBuffer(this);
          }

          
          chunk = m_array[m_lastChunk] = new char[m_chunkSize];
        }

        available = m_chunkSize;
        m_firstFree = 0;
      }
    }

    
    m_firstFree += available;
  }

  
  public final void append(char[] chars, int start, int length)
  {

    int strlen = length;

    if (0 == strlen)
      return;

    int copyfrom = start;
    char[] chunk = m_array[m_lastChunk];
    int available = m_chunkSize - m_firstFree;

    
    while (strlen > 0)
    {

      
      if (available > strlen)
        available = strlen;

      System.arraycopy(chars, copyfrom, m_array[m_lastChunk], m_firstFree,
                       available);

      strlen -= available;
      copyfrom += available;

      
      if (strlen > 0)
      {

        
        int i = m_array.length;

        if (m_lastChunk + 1 == i)
        {
          char[][] newarray = new char[i + 16][];

          System.arraycopy(m_array, 0, newarray, 0, i);

          m_array = newarray;
        }

        
        chunk = m_array[++m_lastChunk];

        if (chunk == null)
        {

          
          if (m_lastChunk == 1 << m_rebundleBits
                  && m_chunkBits < m_maxChunkBits)
          {

            
            
            m_innerFSB = new FastStringBuffer(this);
          }

          
          chunk = m_array[m_lastChunk] = new char[m_chunkSize];
        }

        available = m_chunkSize;
        m_firstFree = 0;
      }
    }

    
    m_firstFree += available;
  }

  
  public final void append(FastStringBuffer value)
  {

    
    
    
    
    if (value == null) 
      return;
    int strlen = value.length();

    if (0 == strlen)
      return;

    int copyfrom = 0;
    char[] chunk = m_array[m_lastChunk];
    int available = m_chunkSize - m_firstFree;

    
    while (strlen > 0)
    {

      
      if (available > strlen)
        available = strlen;

      int sourcechunk = (copyfrom + value.m_chunkSize - 1)
                        >>> value.m_chunkBits;
      int sourcecolumn = copyfrom & value.m_chunkMask;
      int runlength = value.m_chunkSize - sourcecolumn;

      if (runlength > available)
        runlength = available;

      System.arraycopy(value.m_array[sourcechunk], sourcecolumn,
                       m_array[m_lastChunk], m_firstFree, runlength);

      if (runlength != available)
        System.arraycopy(value.m_array[sourcechunk + 1], 0,
                         m_array[m_lastChunk], m_firstFree + runlength,
                         available - runlength);

      strlen -= available;
      copyfrom += available;

      
      if (strlen > 0)
      {

        
        int i = m_array.length;

        if (m_lastChunk + 1 == i)
        {
          char[][] newarray = new char[i + 16][];

          System.arraycopy(m_array, 0, newarray, 0, i);

          m_array = newarray;
        }

        
        chunk = m_array[++m_lastChunk];

        if (chunk == null)
        {

          
          if (m_lastChunk == 1 << m_rebundleBits
                  && m_chunkBits < m_maxChunkBits)
          {

            
            
            m_innerFSB = new FastStringBuffer(this);
          }

          
          chunk = m_array[m_lastChunk] = new char[m_chunkSize];
        }

        available = m_chunkSize;
        m_firstFree = 0;
      }
    }

    
    m_firstFree += available;
  }

  
  public boolean isWhitespace(int start, int length)
  {

    int sourcechunk = start >>> m_chunkBits;
    int sourcecolumn = start & m_chunkMask;
    int available = m_chunkSize - sourcecolumn;
    boolean chunkOK;

    while (length > 0)
    {
      int runlength = (length <= available) ? length : available;

      if (sourcechunk == 0 && m_innerFSB != null)
        chunkOK = m_innerFSB.isWhitespace(sourcecolumn, runlength);
      else
        chunkOK = org.apache.xml.utils.XMLCharacterRecognizer.isWhiteSpace(
          m_array[sourcechunk], sourcecolumn, runlength);

      if (!chunkOK)
        return false;

      length -= runlength;

      ++sourcechunk;

      sourcecolumn = 0;
      available = m_chunkSize;
    }

    return true;
  }

  
  public String getString(int start, int length)
  {
    int startColumn = start & m_chunkMask;
    int startChunk = start >>> m_chunkBits;
    if (startColumn + length < m_chunkMask && m_innerFSB == null) {
      return getOneChunkString(startChunk, startColumn, length);
    }
    return getString(new StringBuffer(length), startChunk, startColumn,
                     length).toString();
  }

  protected String getOneChunkString(int startChunk, int startColumn,
                                     int length) {
    return new String(m_array[startChunk], startColumn, length);
  }

  
  StringBuffer getString(StringBuffer sb, int start, int length)
  {
    return getString(sb, start >>> m_chunkBits, start & m_chunkMask, length);
  }

  
  StringBuffer getString(StringBuffer sb, int startChunk, int startColumn,
                         int length)
  {

    int stop = (startChunk << m_chunkBits) + startColumn + length;
    int stopChunk = stop >>> m_chunkBits;
    int stopColumn = stop & m_chunkMask;

    
    
    for (int i = startChunk; i < stopChunk; ++i)
    {
      if (i == 0 && m_innerFSB != null)
        m_innerFSB.getString(sb, startColumn, m_chunkSize - startColumn);
      else
        sb.append(m_array[i], startColumn, m_chunkSize - startColumn);

      startColumn = 0;  
    }

    if (stopChunk == 0 && m_innerFSB != null)
      m_innerFSB.getString(sb, startColumn, stopColumn - startColumn);
    else if (stopColumn > startColumn)
      sb.append(m_array[stopChunk], startColumn, stopColumn - startColumn);

    return sb;
  }

  
  public char charAt(int pos)
  {
    int startChunk = pos >>> m_chunkBits;

    if (startChunk == 0 && m_innerFSB != null)
      return m_innerFSB.charAt(pos & m_chunkMask);
    else
      return m_array[startChunk][pos & m_chunkMask];
  }

  
  public void sendSAXcharacters(
          org.xml.sax.ContentHandler ch, int start, int length)
            throws org.xml.sax.SAXException
  {

    int startChunk = start >>> m_chunkBits;
    int startColumn = start & m_chunkMask;
    if (startColumn + length < m_chunkMask && m_innerFSB == null) {
        ch.characters(m_array[startChunk], startColumn, length);
        return;
    }
    
    int stop = start + length;
    int stopChunk = stop >>> m_chunkBits;
    int stopColumn = stop & m_chunkMask;

    for (int i = startChunk; i < stopChunk; ++i)
    {
      if (i == 0 && m_innerFSB != null)
        m_innerFSB.sendSAXcharacters(ch, startColumn,
                                     m_chunkSize - startColumn);
      else
        ch.characters(m_array[i], startColumn, m_chunkSize - startColumn);

      startColumn = 0;  
    }

    
    if (stopChunk == 0 && m_innerFSB != null)
      m_innerFSB.sendSAXcharacters(ch, startColumn, stopColumn - startColumn);
    else if (stopColumn > startColumn)
    {
      ch.characters(m_array[stopChunk], startColumn,
                    stopColumn - startColumn);
    }
  }
  
  
  public int sendNormalizedSAXcharacters(
          org.xml.sax.ContentHandler ch, int start, int length)
            throws org.xml.sax.SAXException
  {
	
    
    
	
	int stateForNextChunk=SUPPRESS_LEADING_WS;

    int stop = start + length;
    int startChunk = start >>> m_chunkBits;
    int startColumn = start & m_chunkMask;
    int stopChunk = stop >>> m_chunkBits;
    int stopColumn = stop & m_chunkMask;

    for (int i = startChunk; i < stopChunk; ++i)
    {
      if (i == 0 && m_innerFSB != null)
				stateForNextChunk=
        m_innerFSB.sendNormalizedSAXcharacters(ch, startColumn,
                                     m_chunkSize - startColumn);
      else
				stateForNextChunk=
        sendNormalizedSAXcharacters(m_array[i], startColumn, 
                                    m_chunkSize - startColumn, 
																		ch,stateForNextChunk);

      startColumn = 0;  
    }

    
    if (stopChunk == 0 && m_innerFSB != null)
			stateForNextChunk= 
      m_innerFSB.sendNormalizedSAXcharacters(ch, startColumn, stopColumn - startColumn);
    else if (stopColumn > startColumn)
    {
			stateForNextChunk= 
      sendNormalizedSAXcharacters(m_array[stopChunk], 
																	startColumn, stopColumn - startColumn,
																	ch, stateForNextChunk | SUPPRESS_TRAILING_WS);
    }
		return stateForNextChunk;
  }
  
  static final char[] SINGLE_SPACE = {' '};
	  
  
  static int sendNormalizedSAXcharacters(char ch[], 
             int start, int length, 
             org.xml.sax.ContentHandler handler,
						 int edgeTreatmentFlags)
          throws org.xml.sax.SAXException
  {
     boolean processingLeadingWhitespace =
                       ((edgeTreatmentFlags & SUPPRESS_LEADING_WS) != 0);
     boolean seenWhitespace = ((edgeTreatmentFlags & CARRY_WS) != 0);
     boolean suppressTrailingWhitespace =
                       ((edgeTreatmentFlags & SUPPRESS_TRAILING_WS) != 0);
     int currPos = start;
     int limit = start+length;

     
     if (processingLeadingWhitespace) {
         for (; currPos < limit
                && XMLCharacterRecognizer.isWhiteSpace(ch[currPos]);
              currPos++) { }

         
         
         if (currPos == limit) {
             return edgeTreatmentFlags;
         }
     }

     
     while (currPos < limit) {
         int startNonWhitespace = currPos;

         
         for (; currPos < limit
                && !XMLCharacterRecognizer.isWhiteSpace(ch[currPos]);
              currPos++) { }

         
         
         if (startNonWhitespace != currPos) {
             if (seenWhitespace) {
                 handler.characters(SINGLE_SPACE, 0, 1);
                 seenWhitespace = false;
             }
             handler.characters(ch, startNonWhitespace,
                                currPos - startNonWhitespace);
         }

         int startWhitespace = currPos;

         
         for (; currPos < limit
                && XMLCharacterRecognizer.isWhiteSpace(ch[currPos]);
              currPos++) { }

         if (startWhitespace != currPos) {
             seenWhitespace = true;
         }
     }

     return (seenWhitespace ? CARRY_WS : 0)
            | (edgeTreatmentFlags & SUPPRESS_TRAILING_WS);
  }

  
  public static void sendNormalizedSAXcharacters(char ch[], 
             int start, int length, 
             org.xml.sax.ContentHandler handler)
          throws org.xml.sax.SAXException
  {
		sendNormalizedSAXcharacters(ch, start, length, 
             handler, SUPPRESS_BOTH);
	}
		
	
  public void sendSAXComment(
          org.xml.sax.ext.LexicalHandler ch, int start, int length)
            throws org.xml.sax.SAXException
  {

    
    String comment = getString(start, length);
    ch.comment(comment.toCharArray(), 0, length);
  }

  
  private void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)
  {
    
  }

  
  private FastStringBuffer(FastStringBuffer source)
  {

    
    m_chunkBits = source.m_chunkBits;
    m_maxChunkBits = source.m_maxChunkBits;
    m_rebundleBits = source.m_rebundleBits;
    m_chunkSize = source.m_chunkSize;
    m_chunkMask = source.m_chunkMask;
    m_array = source.m_array;
    m_innerFSB = source.m_innerFSB;

    
    
    m_lastChunk = source.m_lastChunk - 1;
    m_firstFree = source.m_chunkSize;

    
    source.m_array = new char[16][];
    source.m_innerFSB = this;

    
    
    
    source.m_lastChunk = 1;
    source.m_firstFree = 0;
    source.m_chunkBits += m_rebundleBits;
    source.m_chunkSize = 1 << (source.m_chunkBits);
    source.m_chunkMask = source.m_chunkSize - 1;
  }
}
"
org.apache.xalan.xsltc.dom.SimpleResultTreeImpl,109,2,1,20,134,5826,5,17,108,0.967948718,837,0.769230769,3,0.475490196,0.153846154,0,0,6.559633028,4,1.1651,0,"
package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.StripFilter;
import org.apache.xalan.xsltc.runtime.Hashtable;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;
import org.apache.xml.dtm.ref.DTMManagerDefault;
import org.apache.xml.serializer.EmptySerializer;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringDefault;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.xml.sax.SAXException;

import javax.xml.transform.SourceLocator;


public class SimpleResultTreeImpl extends EmptySerializer implements DOM, DTM
{
    
    
    public final class SimpleIterator extends DTMAxisIteratorBase
    {
        static final int DIRECTION_UP = 0;
        static final int DIRECTION_DOWN = 1;
        static final int NO_TYPE = -1;
        
        
        
        int _direction = DIRECTION_DOWN;
        
        int _type = NO_TYPE;
        int _currentNode;
        
        public SimpleIterator()
        {
        }
        
        public SimpleIterator(int direction)
        {
            _direction = direction;
        }
        
        public SimpleIterator(int direction, int type)
        {
             _direction = direction;
             _type = type;
        }
        
        public int next()
        {
            
            
            if (_direction == DIRECTION_DOWN) {                
                while (_currentNode < NUMBER_OF_NODES) {
                    if (_type != NO_TYPE) {
                        if ((_currentNode == RTF_ROOT && _type == DTM.ROOT_NODE)
                            || (_currentNode == RTF_TEXT && _type == DTM.TEXT_NODE))
                            return returnNode(getNodeHandle(_currentNode++));
                        else
                            _currentNode++;
                    }
                    else
                        return returnNode(getNodeHandle(_currentNode++));
                }
                
                return END;
            }
            
            else {                
                while (_currentNode >= 0) {
                    if (_type != NO_TYPE) {
                        if ((_currentNode == RTF_ROOT && _type == DTM.ROOT_NODE)
                            || (_currentNode == RTF_TEXT && _type == DTM.TEXT_NODE))
                            return returnNode(getNodeHandle(_currentNode--));
                        else
                            _currentNode--;
                    }
                    else
                        return returnNode(getNodeHandle(_currentNode--));
                }
                
                return END;
            }
        }
                
        public DTMAxisIterator setStartNode(int nodeHandle)
        {
            int nodeID = getNodeIdent(nodeHandle);
            _startNode = nodeID;
            
            
            if (!_includeSelf && nodeID != DTM.NULL) {
                if (_direction == DIRECTION_DOWN)
                    nodeID++;
                else if (_direction == DIRECTION_UP)
                    nodeID--;
            }
            
            _currentNode = nodeID;
            return this;
        }
                
        public void setMark()
        {
            _markedNode = _currentNode;
        }
        
        public void gotoMark()
        {
            _currentNode = _markedNode;
        }
        
    } 
    
    
    public final class SingletonIterator extends DTMAxisIteratorBase
    {
        static final int NO_TYPE = -1;
        int _type = NO_TYPE;
        int _currentNode;
        
        public SingletonIterator()
        {
        }
        
        public SingletonIterator(int type)
        {
            _type = type;
        }
        
        public void setMark()
        {
            _markedNode = _currentNode;
        }
        
        public void gotoMark()
        {
            _currentNode = _markedNode;
        }

        public DTMAxisIterator setStartNode(int nodeHandle)
        {
            _currentNode = _startNode = getNodeIdent(nodeHandle);
            return this;
        }
        
        public int next()
        {
            if (_currentNode == END)
                return END;
            
            _currentNode = END;
            
            if (_type != NO_TYPE) {
                if ((_currentNode == RTF_ROOT && _type == DTM.ROOT_NODE)
                    || (_currentNode == RTF_TEXT && _type == DTM.TEXT_NODE))
                    return getNodeHandle(_currentNode);
            }
            else
                return getNodeHandle(_currentNode);
            
            return END;                
        }
        
    }  

    
    private final static DTMAxisIterator EMPTY_ITERATOR =
        new DTMAxisIteratorBase() {
            public DTMAxisIterator reset() { return this; }
            public DTMAxisIterator setStartNode(int node) { return this; }
            public int next() { return DTM.NULL; }
            public void setMark() {}
            public void gotoMark() {}
            public int getLast() { return 0; }
            public int getPosition() { return 0; }
            public DTMAxisIterator cloneIterator() { return this; }
            public void setRestartable(boolean isRestartable) { }
        };
    
    
    
    public static final int RTF_ROOT = 0;
    
    
    public static final int RTF_TEXT = 1;
    
    
    public static final int NUMBER_OF_NODES = 2;
    
    
    private static int _documentURIIndex = 0;
    
    
    private static final String EMPTY_STR = """";
    
    
    
    private String _text;
    
    
    
    
    protected String[] _textArray;
    
    
    protected XSLTCDTMManager _dtmManager;
    
    
    protected int _size = 0;
    
    
    private int _documentID;

    
    private BitArray _dontEscape = null;
    
    
    private boolean _escaping = true;
    
    
    public SimpleResultTreeImpl(XSLTCDTMManager dtmManager, int documentID)
    {
        _dtmManager = dtmManager;
        _documentID = documentID;
        _textArray = new String[4];
    }
    
    public DTMManagerDefault getDTMManager()
    {
        return _dtmManager;	
    }
    
    
    public int getDocument()
    {
        return _documentID;
    }

    
    public String getStringValue()
    {
        return _text;
    }
    
    public DTMAxisIterator getIterator()
    {
        return new SingletonIterator(getDocument());
    }
	
    public DTMAxisIterator getChildren(final int node)
    {
        return new SimpleIterator().setStartNode(node);
    }
    
    public DTMAxisIterator getTypedChildren(final int type)
    {
        return new SimpleIterator(SimpleIterator.DIRECTION_DOWN, type);
    }
    
    
    
    public DTMAxisIterator getAxisIterator(final int axis)
    {
        switch (axis)
        {
            case Axis.CHILD:
            case Axis.DESCENDANT:
                return new SimpleIterator(SimpleIterator.DIRECTION_DOWN);
            case Axis.PARENT:
            case Axis.ANCESTOR:
                return new SimpleIterator(SimpleIterator.DIRECTION_UP);
            case Axis.ANCESTORORSELF:
                return (new SimpleIterator(SimpleIterator.DIRECTION_UP)).includeSelf();
            case Axis.DESCENDANTORSELF:
                return (new SimpleIterator(SimpleIterator.DIRECTION_DOWN)).includeSelf();
            case Axis.SELF:
                return new SingletonIterator();
            default:
                return EMPTY_ITERATOR;
        }
    }
    
    public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)
    {
        switch (axis)
        {
            case Axis.CHILD:
            case Axis.DESCENDANT:
                return new SimpleIterator(SimpleIterator.DIRECTION_DOWN, type);
            case Axis.PARENT:
            case Axis.ANCESTOR:
                return new SimpleIterator(SimpleIterator.DIRECTION_UP, type);
            case Axis.ANCESTORORSELF:
                return (new SimpleIterator(SimpleIterator.DIRECTION_UP, type)).includeSelf();
            case Axis.DESCENDANTORSELF:
                return (new SimpleIterator(SimpleIterator.DIRECTION_DOWN, type)).includeSelf();
            case Axis.SELF:
                return new SingletonIterator(type);
            default:
                return EMPTY_ITERATOR;
        }
    }
    
    
    public DTMAxisIterator getNthDescendant(int node, int n, boolean includeself)
    {
        return null; 
    }
    
    public DTMAxisIterator getNamespaceAxisIterator(final int axis, final int ns)
    {
        return null;
    }
    
    
    public DTMAxisIterator getNodeValueIterator(DTMAxisIterator iter, int returnType,
					     String value, boolean op)
    {
        return null;
    }
    
    public DTMAxisIterator orderNodes(DTMAxisIterator source, int node)
    {
        return source;
    }
    
    public String getNodeName(final int node)
    {
        if (getNodeIdent(node) == RTF_TEXT)
            return ""#text"";
        else
            return EMPTY_STR;
    }
    
    public String getNodeNameX(final int node)
    {
        return EMPTY_STR;
    }
    
    public String getNamespaceName(final int node)
    {
        return EMPTY_STR;
    }
    
    
    public int getExpandedTypeID(final int nodeHandle)
    {
        int nodeID = getNodeIdent(nodeHandle);
        if (nodeID == RTF_TEXT)
            return DTM.TEXT_NODE;
        else if (nodeID == RTF_ROOT)
            return DTM.ROOT_NODE;
        else
            return DTM.NULL;
    }
    
    public int getNamespaceType(final int node)
    {
        return 0;
    }
    
    public int getParent(final int nodeHandle)
    {
        int nodeID = getNodeIdent(nodeHandle);
        return (nodeID == RTF_TEXT) ? getNodeHandle(RTF_ROOT) : DTM.NULL;            
    }
    
    public int getAttributeNode(final int gType, final int element)
    {
        return DTM.NULL;
    }
    
    public String getStringValueX(final int nodeHandle)
    {
        int nodeID = getNodeIdent(nodeHandle);
        if (nodeID == RTF_ROOT || nodeID == RTF_TEXT)
            return _text;
        else
            return EMPTY_STR;
    }
    
    public void copy(final int node, SerializationHandler handler)
	throws TransletException
    {
        characters(node, handler);
    }
    
    public void copy(DTMAxisIterator nodes, SerializationHandler handler)
	throws TransletException
    {
        int node;
        while ((node = nodes.next()) != DTM.NULL)
        {
            copy(node, handler);
        }
    }
    
    public String shallowCopy(final int node, SerializationHandler handler)
	throws TransletException
    {
        characters(node, handler);
        return null;
    }
    
    public boolean lessThan(final int node1, final int node2)
    {
        if (node1 == DTM.NULL) {
            return false;
        }
        else if (node2 == DTM.NULL) {
            return true;
        }
        else
            return (node1 < node2);
    }
    
    
    public void characters(final int node, SerializationHandler handler)
        throws TransletException
    {
        int nodeID = getNodeIdent(node);
        if (nodeID == RTF_ROOT || nodeID == RTF_TEXT) {
            boolean escapeBit = false;
            boolean oldEscapeSetting = false;

            try {
                for (int i = 0; i < _size; i++) {

                    if (_dontEscape != null) {
                        escapeBit = _dontEscape.getBit(i);
                        if (escapeBit) {
                            oldEscapeSetting = handler.setEscaping(false);
                        }
                    }
                
                    handler.characters(_textArray[i]);
                
                    if (escapeBit) {
                        handler.setEscaping(oldEscapeSetting);
                    }
                }
            } catch (SAXException e) {
                throw new TransletException(e);
            }
        }
    }
    
    
    public Node makeNode(int index)
    {
        return null;
    }
    
    public Node makeNode(DTMAxisIterator iter)
    {
        return null;
    }
    
    public NodeList makeNodeList(int index)
    {
        return null;
    }
    
    public NodeList makeNodeList(DTMAxisIterator iter)
    {
        return null;
    }
    
    public String getLanguage(int node)
    {
        return null;
    }
    
    public int getSize()
    {
        return 2;
    }
    
    public String getDocumentURI(int node)
    {
        return ""simple_rtf"" + _documentURIIndex++;
    }
    
    public void setFilter(StripFilter filter)
    {
    }
    
    public void setupMapping(String[] names, String[] namespaces)
    {
    }
    
    public boolean isElement(final int node)
    {
        return false;
    }
    
    public boolean isAttribute(final int node)
    {
        return false;
    }
    
    public String lookupNamespace(int node, String prefix)
	throws TransletException
    {
        return null;
    }
    
    
    public int getNodeIdent(final int nodehandle)
    {
        return (nodehandle != DTM.NULL) ? (nodehandle - _documentID) : DTM.NULL;
    }
    
    
    public int getNodeHandle(final int nodeId)
    {
        return (nodeId != DTM.NULL) ? (nodeId + _documentID) : DTM.NULL;
    }
    
    public DOM getResultTreeFrag(int initialSize, int rtfType)
    {
        return null;
    }
    
    public SerializationHandler getOutputDomBuilder()
    {
        return this;
    }
    
    public int getNSType(int node)
    {
        return 0;
    }
    
    public String getUnparsedEntityURI(String name)
    {
        return null;
    }
    
    public Hashtable getElementsWithIDs()
    {
        return null;
    }

    
    
    
    
    public void startDocument() throws SAXException
    {
    
    }
    
    public void endDocument() throws SAXException
    {
        
        if (_size == 1)
            _text = _textArray[0];
        else {
            StringBuffer buffer = new StringBuffer();
            for (int i = 0; i < _size; i++) {
                buffer.append(_textArray[i]);
            }
            _text = buffer.toString();
        }
    }

    public void characters(String str) throws SAXException
    {
        
        if (_size >= _textArray.length) {
            String[] newTextArray = new String[_textArray.length * 2];
            System.arraycopy(_textArray, 0, newTextArray, 0, _textArray.length);
            _textArray = newTextArray;
        }
        
        
        
        if (!_escaping) {
            
            if (_dontEscape == null) {
                _dontEscape = new BitArray(8);
            }
            
            
            if (_size >= _dontEscape.size())
                _dontEscape.resize(_dontEscape.size() * 2);
            
            _dontEscape.setBit(_size);
        }
        
        _textArray[_size++] = str;
    }
    
    public void characters(char[] ch, int offset, int length)
	throws SAXException
    {
        if (_size >= _textArray.length) {
            String[] newTextArray = new String[_textArray.length * 2];
            System.arraycopy(_textArray, 0, newTextArray, 0, _textArray.length);
            _textArray = newTextArray;
        }

        if (!_escaping) {
            if (_dontEscape == null) {
                _dontEscape = new BitArray(8);
            }
            
            if (_size >= _dontEscape.size())
                _dontEscape.resize(_dontEscape.size() * 2);
            
            _dontEscape.setBit(_size);
        }
       
        _textArray[_size++] = new String(ch, offset, length);
        
    }
    
    public boolean setEscaping(boolean escape) throws SAXException
    {
        final boolean temp = _escaping;
        _escaping = escape; 
        return temp;
    }
        
    
    
    
     
    public void setFeature(String featureId, boolean state)
    {
    }
    
    public void setProperty(String property, Object value)
    {
    }
    
    public DTMAxisTraverser getAxisTraverser(final int axis)
    {
        return null;
    }
    
    public boolean hasChildNodes(int nodeHandle)
    {
        return (getNodeIdent(nodeHandle) == RTF_ROOT);
    }
    
    public int getFirstChild(int nodeHandle)
    {
        int nodeID = getNodeIdent(nodeHandle);
        if (nodeID == RTF_ROOT)
            return getNodeHandle(RTF_TEXT);
        else
            return DTM.NULL;
    }
    
    public int getLastChild(int nodeHandle)
    {
        return getFirstChild(nodeHandle);
    }
    
    public int getAttributeNode(int elementHandle, String namespaceURI, String name)
    {
        return DTM.NULL;
    }
    
    public int getFirstAttribute(int nodeHandle)
    {
        return DTM.NULL;
    }
    
    public int getFirstNamespaceNode(int nodeHandle, boolean inScope)
    {
        return DTM.NULL;
    }
    
    public int getNextSibling(int nodeHandle)
    {
        return DTM.NULL;
    }
    
    public int getPreviousSibling(int nodeHandle)
    {
        return DTM.NULL;
    }
    
    public int getNextAttribute(int nodeHandle)
    {
        return DTM.NULL;
    }
    
    public int getNextNamespaceNode(int baseHandle, int namespaceHandle,
                                  boolean inScope)
    {
        return DTM.NULL;
    }
    
    public int getOwnerDocument(int nodeHandle)
    {
        return getDocument();
    }
    
    public int getDocumentRoot(int nodeHandle)
    {
        return getDocument();
    }
    
    public XMLString getStringValue(int nodeHandle)
    {
        return new XMLStringDefault(getStringValueX(nodeHandle));
    }
    
    public int getStringValueChunkCount(int nodeHandle)
    {
        return 0;
    }
    
    public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
                                    int[] startAndLen)
    {
        return null;
    }
    
    public int getExpandedTypeID(String namespace, String localName, int type)
    {
        return DTM.NULL;
    }
    
    public String getLocalNameFromExpandedNameID(int ExpandedNameID)
    {
        return EMPTY_STR;
    }
    
    public String getNamespaceFromExpandedNameID(int ExpandedNameID)
    {
        return EMPTY_STR;
    }
    
    public String getLocalName(int nodeHandle)
    {
        return EMPTY_STR;
    }
    
    public String getPrefix(int nodeHandle)
    {
        return null;
    }
    
    public String getNamespaceURI(int nodeHandle)
    {
        return EMPTY_STR;
    }
    
    public String getNodeValue(int nodeHandle)
    {
        return (getNodeIdent(nodeHandle) == RTF_TEXT) ? _text : null;
    }
    
    public short getNodeType(int nodeHandle)
    {
        int nodeID = getNodeIdent(nodeHandle);
        if (nodeID == RTF_TEXT)
            return DTM.TEXT_NODE;
        else if (nodeID == RTF_ROOT)
            return DTM.ROOT_NODE;
        else
            return DTM.NULL;
        
    }
    
    public short getLevel(int nodeHandle)
    {
        int nodeID = getNodeIdent(nodeHandle);
        if (nodeID == RTF_TEXT)
            return 2;
        else if (nodeID == RTF_ROOT)
            return 1;
        else
            return DTM.NULL;            
    }
    
    public boolean isSupported(String feature, String version)
    {
        return false;
    }
    
    public String getDocumentBaseURI()
    {
        return EMPTY_STR;
    }
    
    public void setDocumentBaseURI(String baseURI)
    {
    }
    
    public String getDocumentSystemIdentifier(int nodeHandle)
    {
        return null;
    }
    
    public String getDocumentEncoding(int nodeHandle)
    {
        return null;
    }
    
    public String getDocumentStandalone(int nodeHandle)
    {
        return null;
    }
    
    public String getDocumentVersion(int documentHandle)
    {
        return null;
    }
    
    public boolean getDocumentAllDeclarationsProcessed()
    {
        return false;
    }
    
    public String getDocumentTypeDeclarationSystemIdentifier()
    {
        return null;
    }
    
    public String getDocumentTypeDeclarationPublicIdentifier()
    {
        return null;
    }
    
    public int getElementById(String elementId)
    {
        return DTM.NULL;
    }
        
    public boolean supportsPreStripping()
    {
        return false;
    }
    
    public boolean isNodeAfter(int firstNodeHandle, int secondNodeHandle)
    {
        return lessThan(firstNodeHandle, secondNodeHandle);
    }
    
    public boolean isCharacterElementContentWhitespace(int nodeHandle)
    {
        return false;
    }
    
    public boolean isDocumentAllDeclarationsProcessed(int documentHandle)
    {
        return false;
    }
    
    public boolean isAttributeSpecified(int attributeHandle)
    {
        return false;
    }
    
    public void dispatchCharactersEvents(
        int nodeHandle,
        org.xml.sax.ContentHandler ch,
        boolean normalize)
          throws org.xml.sax.SAXException
    {
    }
    
    public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
      throws org.xml.sax.SAXException
    {
    }
    
    public org.w3c.dom.Node getNode(int nodeHandle)
    {
        return makeNode(nodeHandle);
    }
    
    public boolean needsTwoThreads()
    {
        return false;
    }
    
    public org.xml.sax.ContentHandler getContentHandler()
    {
        return null;
    }
    
    public org.xml.sax.ext.LexicalHandler getLexicalHandler()
    {
        return null;
    }
    
    public org.xml.sax.EntityResolver getEntityResolver()
    {
        return null;
    }
    
    public org.xml.sax.DTDHandler getDTDHandler()
    {
        return null;
    }
    
    public org.xml.sax.ErrorHandler getErrorHandler()
    {
        return null;
    }
    
    public org.xml.sax.ext.DeclHandler getDeclHandler()
    {
        return null;
    }
    
    public void appendChild(int newChild, boolean clone, boolean cloneDepth)
    {
    }
    
    public void appendTextChild(String str)
    {
    }
    
    public SourceLocator getSourceLocatorFor(int node)
    {
    	return null;
    }
    
    public void documentRegistration()
    {
    }
    
    public void documentRelease()
    {
    }

}
"
org.apache.xml.serializer.ToSAXHandler,22,2,3,6,42,143,4,2,19,0.714285714,251,1.0,1,0.820754717,0.217171717,1,4,10.27272727,3,1.0455,2,"
package org.apache.xml.serializer;

import java.util.Vector;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.ext.LexicalHandler;


abstract public class ToSAXHandler extends SerializerBase 
{
    public ToSAXHandler()
    {
    }

    public ToSAXHandler(
        ContentHandler hdlr,
        LexicalHandler lex,
        String encoding)
    {
        setContentHandler(hdlr);
        setLexHandler(lex);
        setEncoding(encoding);
    }
    public ToSAXHandler(ContentHandler handler, String encoding)
    {
        setContentHandler(handler);
        setEncoding(encoding);
    }

    
    protected ContentHandler m_saxHandler;

    
    protected LexicalHandler m_lexHandler;

    
    
    protected TransformStateSetter m_state = null;

    
    protected void startDocumentInternal() throws SAXException
    {
        if (m_needToCallStartDocument)  
        {
            super.startDocumentInternal();

            m_saxHandler.startDocument();
            m_needToCallStartDocument = false;
        }
    }
    
    public void startDTD(String arg0, String arg1, String arg2)
        throws SAXException
    {
        
    }

    
    public void characters(String characters) throws SAXException
    {
        characters(characters.toCharArray(), 0, characters.length());
    }

    
    public void comment(String comment) throws SAXException
    {

        
        if (m_startTagOpen)
        {
            closeStartTag();
        }
        else if (m_cdataTagOpen)
        {
            closeCDATA();
        }

        
        if (m_lexHandler != null)
        {
            m_lexHandler.comment(comment.toCharArray(), 0, comment.length());

            
            super.fireCommentEvent(comment.toCharArray(), 0, comment.length());
        }

    }

    
    public void processingInstruction(String target, String data)
        throws SAXException
    {
        
    }

    protected void closeStartTag() throws SAXException
    {
    }

    protected void closeCDATA() throws SAXException
    {
        
    }
    
    
    public void startElement(
        String arg0,
        String arg1,
        String arg2,
        Attributes arg3)
        throws SAXException
    {
        if (m_state != null) {
            m_state.resetState(getTransformer());
        }

    	
    	super.fireStartElem(arg2);    	
    }

    
    public void setLexHandler(LexicalHandler _lexHandler)
    {
        this.m_lexHandler = _lexHandler;
    }

    
    public void setContentHandler(ContentHandler _saxHandler)
    {
        this.m_saxHandler = _saxHandler;
        if (m_lexHandler == null && _saxHandler instanceof LexicalHandler)
        {
            
            
            m_lexHandler = (LexicalHandler) _saxHandler;
        }
    }

    
    public void setCdataSectionElements(Vector URI_and_localNames)
    {
        
    }

    
    public void flushPending()
    {
        try
        {
            if (m_needToCallStartDocument)
            {
                startDocumentInternal();
                m_needToCallStartDocument = false;
            }

            if (m_startTagOpen)
            {
                closeStartTag();
                m_startTagOpen = false;
            }
            
            if (m_cdataTagOpen)
            {
                closeCDATA();
                m_cdataTagOpen = false;
            }
        }
        catch (SAXException e)
        {
            
            
        }

    }

    
    public void setTransformState(TransformStateSetter ts) {
        this.m_state = ts;
    }

    
    public void startElement(String uri, String localName, String qName)
        throws SAXException {
            
        if (m_state != null) {
            m_state.resetState(getTransformer());
        }

    	
    	super.fireStartElem(qName);    	        
    }

    
    public void startElement(String qName) throws SAXException {
        if (m_state != null) {
            m_state.resetState(getTransformer());
        }        
    	
    	super.fireStartElem(qName);    	                
    }
    
        
    public void characters(org.w3c.dom.Node node)
        throws org.xml.sax.SAXException
    {
        
        if (m_state != null)
        {
            m_state.setCurrentNode(node);
        }
        
        
        super.characters(node);
       }    

    
    public void fatalError(SAXParseException exc) throws SAXException {
        super.fatalError(exc);
        
        m_needToCallStartDocument = false;
        
        if (m_saxHandler instanceof ErrorHandler) {
            ((ErrorHandler)m_saxHandler).fatalError(exc);            
        }
    }

    
    public void error(SAXParseException exc) throws SAXException {
        super.error(exc);
        
        if (m_saxHandler instanceof ErrorHandler)
            ((ErrorHandler)m_saxHandler).error(exc);        
        
    }

    
    public void warning(SAXParseException exc) throws SAXException {
        super.warning(exc);
        
        if (m_saxHandler instanceof ErrorHandler)
            ((ErrorHandler)m_saxHandler).warning(exc);        
    }

}
"
org.apache.xalan.transformer.QueuedEvents,7,1,0,2,10,13,0,2,2,0.861111111,99,0.75,2,0.0,0.571428571,0,0,11.42857143,1,0.8571,0,"
package org.apache.xalan.transformer;

import java.util.Vector;

import org.apache.xml.utils.MutableAttrListImpl;



public abstract class QueuedEvents
{

  
  protected int m_eventCount = 0;

  
  

  
  
  
  public boolean m_docPending = false;
  protected boolean m_docEnded = false;
  
  
  public boolean m_elemIsPending = false;

  
  public boolean m_elemIsEnded = false;
  
  
  protected MutableAttrListImpl m_attributes = new MutableAttrListImpl();

  
  protected boolean m_nsDeclsHaveBeenAdded = false;

  
  protected String m_name;

  
  protected String m_url;

  
  protected String m_localName;
  
  
  
  protected Vector m_namespaces = null;











  
  protected void reInitEvents()
  {
  }

  
  public void reset()
  {
    pushDocumentEvent();
    reInitEvents();
  }

  
  void pushDocumentEvent()
  {

    
    
    m_docPending = true;

    m_eventCount++;
  }

  
  void popEvent()
  {
    m_elemIsPending = false;
    m_attributes.clear();

    m_nsDeclsHaveBeenAdded = false;
    m_name = null;
    m_url = null;
    m_localName = null;
    m_namespaces = null;

    m_eventCount--;
  }

  
  private org.apache.xml.serializer.Serializer m_serializer;

  
  void setSerializer(org.apache.xml.serializer.Serializer s)
  {
    m_serializer = s;
  }

  
  org.apache.xml.serializer.Serializer getSerializer()
  {
    return m_serializer;
  }
}
"
org.apache.xpath.functions.FuncSum,2,4,0,8,11,1,0,8,2,2.0,44,0.0,0,0.979591837,0.75,1,6,21.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class FuncSum extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    DTMIterator nodes = m_arg0.asIterator(xctxt, xctxt.getCurrentNode());
    double sum = 0.0;
    int pos;

    while (DTM.NULL != (pos = nodes.nextNode()))
    {
      DTM dtm = nodes.getDTM(pos);
      XMLString s = dtm.getStringValue(pos);

      if (null != s)
        sum += s.toDouble();
    }
    nodes.detach();

    return new XNumber(sum);
  }
}
"
org.apache.xalan.xsltc.dom.NthIterator,10,2,0,3,21,0,0,3,10,0.62962963,99,1.0,1,0.590909091,0.35,1,7,8.6,2,1.1,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;

public final class NthIterator extends DTMAxisIteratorBase {
    
    private DTMAxisIterator _source;
    private final int _position;
    private boolean _ready;

    public NthIterator(DTMAxisIterator source, int n) {
	_source = source;
	_position = n;
    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }
    
    public DTMAxisIterator cloneIterator() {
	try {
	    final NthIterator clone = (NthIterator) super.clone();
	    clone._source = _source.cloneIterator();	
	    clone._isRestartable = false;
	    return clone;
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }

    public int next() {
	if (_ready) {
	    _ready = false;
	    return _source.getNodeByPosition(_position);
	}
	return DTMAxisIterator.END;
	
    }

    public DTMAxisIterator setStartNode(final int node) {
	if (_isRestartable) {
	    _source.setStartNode(node);
	    _ready = true;
	}
	return this;
    }
	
    public DTMAxisIterator reset() {
	_source.reset();
	_ready = true;
	return this;
    }
    
    public int getLast() {
	return 1;
    }
    
    public int getPosition() {
	return 1;
    }
    
    public void setMark() {
	_source.setMark();
    }
    
    public void gotoMark() {
	_source.gotoMark();
    }
}
"
org.apache.xalan.templates.StylesheetComposed,11,4,1,17,45,39,10,10,9,0.8,333,1.0,0,0.964285714,0.309090909,1,2,28.90909091,4,1.5455,0,"
package org.apache.xalan.templates;

import java.util.Vector;

import javax.xml.transform.TransformerException;


public class StylesheetComposed extends Stylesheet
{

  
  public StylesheetComposed(Stylesheet parent)
  {
    super(parent);
  }

  
  public boolean isAggregatedType()
  {
    return true;
  }

  
  public void recompose(Vector recomposableElements) throws TransformerException
  {

    
    

    

    int n = getIncludeCountComposed();

    for (int i = -1; i < n; i++)
    {
      Stylesheet included = getIncludeComposed(i);

      

      int s = included.getOutputCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getOutput(j));
      }

      

      s = included.getAttributeSetCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getAttributeSet(j));
      }

      

      s = included.getDecimalFormatCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getDecimalFormat(j));
      }

      

      s = included.getKeyCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getKey(j));
      }

      

      s = included.getNamespaceAliasCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getNamespaceAlias(j));
      }

      

      s = included.getTemplateCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getTemplate(j));
      }

      

      s = included.getVariableOrParamCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getVariableOrParam(j));
      }

      

      s = included.getStripSpaceCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getStripSpace(j));
      }

      s = included.getPreserveSpaceCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getPreserveSpace(j));
      }
    }
  }

  
  private int m_importNumber = -1;

  
  private int m_importCountComposed;
  
  
  private int m_endImportCountComposed;

  
  void recomposeImports()
  {

    m_importNumber = getStylesheetRoot().getImportNumber(this);

    StylesheetRoot root = getStylesheetRoot();
    int globalImportCount = root.getGlobalImportCount();

    m_importCountComposed = (globalImportCount - m_importNumber) - 1;
    
    
    int count = getImportCount();
    if ( count > 0)
    {
      m_endImportCountComposed += count;
      while (count > 0)
        m_endImportCountComposed += this.getImport(--count).getEndImportCountComposed();
    }
    
    
    
    count = getIncludeCountComposed();
    while (count>0)
    {
      int imports = getIncludeComposed(--count).getImportCount();
      m_endImportCountComposed += imports;
      while (imports > 0)
        m_endImportCountComposed +=getIncludeComposed(count).getImport(--imports).getEndImportCountComposed();
     
    }                                                            
  }

  
  public StylesheetComposed getImportComposed(int i)
          throws ArrayIndexOutOfBoundsException
  {

    StylesheetRoot root = getStylesheetRoot();

    
    
    
    
    return root.getGlobalImport(1 + m_importNumber + i);
  }

  
  public int getImportCountComposed()
  {
    return m_importCountComposed;
  }
  
  
  public int getEndImportCountComposed()
  {
    return m_endImportCountComposed;
  }
  

  
  private transient Vector m_includesComposed;

  
  void recomposeIncludes(Stylesheet including)
  {

    int n = including.getIncludeCount();

    if (n > 0)
    {
      if (null == m_includesComposed)
        m_includesComposed = new Vector();

      for (int i = 0; i < n; i++)
      {
        Stylesheet included = including.getInclude(i);
        m_includesComposed.addElement(included);
        recomposeIncludes(included);
      }
    }
  }

  
  public Stylesheet getIncludeComposed(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (-1 == i)
      return this;

    if (null == m_includesComposed)
      throw new ArrayIndexOutOfBoundsException();

    return (Stylesheet) m_includesComposed.elementAt(i);
  }

  
  public int getIncludeCountComposed()
  {
    return (null != m_includesComposed) ? m_includesComposed.size() : 0;
  }

  
  public void recomposeTemplates(boolean flushFirst) throws TransformerException
  {

  }
}
"
org.apache.xpath.domapi.XPathNSResolverImpl,2,2,0,2,4,1,1,1,2,2.0,10,0.0,0,0.8,0.666666667,0,0,4.0,1,0.5,1,"

package org.apache.xpath.domapi;

import org.apache.xml.utils.PrefixResolverDefault;
import org.w3c.dom.Node;
import org.w3c.dom.xpath.XPathNSResolver;


public class XPathNSResolverImpl extends PrefixResolverDefault implements XPathNSResolver {

	
	public XPathNSResolverImpl(Node xpathExpressionContext) {
		super(xpathExpressionContext);
	}

	
	public String lookupNamespaceURI(String prefix) {
		return super.getNamespaceForPrefix(prefix);
	}

}
"
org.apache.xalan.xsltc.compiler.ForwardPositionExpr,5,3,0,16,20,0,2,14,5,0.0,86,1.0,1,0.946666667,0.333333333,2,7,16.0,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

class ForwardPositionExpr extends Expression {
    private Expression _expr;

    public ForwardPositionExpr(Expression expr) {
	_expr = expr;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_expr.setParser(parser);
    }
    
    public String toString() {
	return ""forward-position-expr("" + _expr + "")"";
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return (_type = _expr.typeCheck(stable));
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	_expr.translate(classGen, methodGen);

	if (_type == Type.NodeSet) {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();

	    final int init = cpg.addMethodref(FORWARD_POSITION_ITERATOR, 
		""<init>"", ""("" + NODE_ITERATOR_SIG + "")V"");
	    il.append(new NEW(cpg.addClass(FORWARD_POSITION_ITERATOR)));
	    il.append(DUP_X1);
	    il.append(SWAP);
	    il.append(new INVOKESPECIAL(init));
	}
    }
}
"
org.apache.xpath.functions.FuncTranslate,2,6,0,5,12,1,0,5,2,2.0,70,0.0,0,0.984615385,0.75,1,6,34.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncTranslate extends Function3Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String theFirstString = m_arg0.execute(xctxt).str();
    String theSecondString = m_arg1.execute(xctxt).str();
    String theThirdString = m_arg2.execute(xctxt).str();
    int theFirstStringLength = theFirstString.length();
    int theThirdStringLength = theThirdString.length();

    
    
    StringBuffer sbuffer = new StringBuffer();

    for (int i = 0; i < theFirstStringLength; i++)
    {
      char theCurrentChar = theFirstString.charAt(i);
      int theIndex = theSecondString.indexOf(theCurrentChar);

      if (theIndex < 0)
      {

        
        
        sbuffer.append(theCurrentChar);
      }
      else if (theIndex < theThirdStringLength)
      {

        
        
        sbuffer.append(theThirdString.charAt(theIndex));
      }
      else
      {

        
        
        
        
        
      }
    }

    return new XString(sbuffer.toString());
  }
}
"
org.apache.xalan.xsltc.compiler.util.NumberType,3,2,2,5,4,3,4,1,3,2.0,10,0.0,0,0.942857143,1.0,0,0,2.333333333,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler.util;


public abstract class NumberType extends Type {
    public boolean isNumber() {
	return true;
    }

    public boolean isSimple() {
	return true;
    }
}

"
org.apache.xalan.processor.ProcessorCharacters,5,4,0,9,31,2,2,7,4,0.333333333,151,1.0,1,0.981308411,0.4,1,2,28.6,1,0.8,0,"
package org.apache.xalan.processor;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemText;
import org.apache.xalan.templates.ElemTextLiteral;
import org.apache.xml.utils.XMLCharacterRecognizer;

import org.w3c.dom.Node;


public class ProcessorCharacters extends XSLTElementProcessor
{

  
  public void startNonText(StylesheetHandler handler) throws org.xml.sax.SAXException
  {
    if (this == handler.getCurrentProcessor())
    {
      handler.popProcessor();
    }

    int nChars = m_accumulator.length();

    if ((nChars > 0)
            && ((null != m_xslTextElement)
                ||!XMLCharacterRecognizer.isWhiteSpace(m_accumulator)) 
                || handler.isSpacePreserve())
    {
      ElemTextLiteral elem = new ElemTextLiteral();

      elem.setDOMBackPointer(m_firstBackPointer);
      elem.setLocaterInfo(handler.getLocator());
      try
      {
        elem.setPrefixes(handler.getNamespaceSupport());
      }
      catch(TransformerException te)
      {
        throw new org.xml.sax.SAXException(te);
      }

      boolean doe = (null != m_xslTextElement)
                    ? m_xslTextElement.getDisableOutputEscaping() : false;

      elem.setDisableOutputEscaping(doe);
      elem.setPreserveSpace(true);

      char[] chars = new char[nChars];

      m_accumulator.getChars(0, nChars, chars, 0);
      elem.setChars(chars);

      ElemTemplateElement parent = handler.getElemTemplateElement();

      parent.appendChild(elem);
    }

    m_accumulator.setLength(0);
    m_firstBackPointer = null;
  }
  
  protected Node m_firstBackPointer = null;

  
  public void characters(
          StylesheetHandler handler, char ch[], int start, int length)
            throws org.xml.sax.SAXException
  {

    m_accumulator.append(ch, start, length);
    
    if(null == m_firstBackPointer)
      m_firstBackPointer = handler.getOriginatingNode();

    
    if (this != handler.getCurrentProcessor())
      handler.pushProcessor(this);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    
    
    
    startNonText(handler);
    handler.getCurrentProcessor().endElement(handler, uri, localName,
                                             rawName);
    handler.popProcessor();
  }

  
  private StringBuffer m_accumulator = new StringBuffer();

  
  private ElemText m_xslTextElement;

  
  void setXslTextElement(ElemText xslTextElement)
  {
    m_xslTextElement = xslTextElement;
  }
}
"
org.apache.xalan.extensions.ExtensionNamespacesManager,9,1,0,7,29,12,5,2,8,0.625,581,1.0,0,0.0,0.416666667,0,0,63.22222222,7,2.5556,1,"
package org.apache.xalan.extensions;

import java.util.Vector;

import org.apache.xalan.templates.Constants;


public class ExtensionNamespacesManager
{
  
  private Vector m_extensions = new Vector();
  
  private Vector m_predefExtensions = new Vector(7);
  
  private Vector m_unregisteredExtensions = new Vector();
  
  
  public ExtensionNamespacesManager()
  {
    setPredefinedNamespaces();
  }
  
  
  public void registerExtension(String namespace)
  {
    if (namespaceIndex(namespace, m_extensions) == -1)
    {
      int predef = namespaceIndex(namespace, m_predefExtensions);
      if (predef !=-1)
        m_extensions.addElement(m_predefExtensions.elementAt(predef));
      else if (!(m_unregisteredExtensions.contains(namespace)))
        m_unregisteredExtensions.addElement(namespace);       
    }
  }
  
    
  public void registerExtension(ExtensionNamespaceSupport extNsSpt)
  {
    String namespace = extNsSpt.getNamespace();
    if (namespaceIndex(namespace, m_extensions) == -1)
    {
      m_extensions.addElement(extNsSpt);
      if (m_unregisteredExtensions.contains(namespace))
        m_unregisteredExtensions.removeElement(namespace);
    }
    
  }
  
  
  public int namespaceIndex(String namespace, Vector extensions)
  {
    for (int i = 0; i < extensions.size(); i++)
    {
      if (((ExtensionNamespaceSupport)extensions.elementAt(i)).getNamespace().equals(namespace))
        return i;
    }
    return -1;
  }
  
    
  
  public Vector getExtensions()
  {
    return m_extensions;
  }
  
  
  public void registerUnregisteredNamespaces()
  {
    for (int i = 0; i < m_unregisteredExtensions.size(); i++)
    {
      String ns = (String)m_unregisteredExtensions.elementAt(i);
      ExtensionNamespaceSupport extNsSpt = defineJavaNamespace(ns);
      if (extNsSpt != null)
        m_extensions.addElement(extNsSpt);
    }    
  }
  
    
  public ExtensionNamespaceSupport defineJavaNamespace(String ns)
  {
    return defineJavaNamespace(ns, ns);
  }
  public ExtensionNamespaceSupport defineJavaNamespace(String ns, String classOrPackage)
  {
    if(null == ns || ns.trim().length() == 0) 
      return null;

    
    
    
    String className = classOrPackage;
    if (className.startsWith(""class:""))
      className = className.substring(6);

    int lastSlash = className.lastIndexOf(""/"");
    if (-1 != lastSlash)
      className = className.substring(lastSlash + 1);
      
    
    
    if(null == className || className.trim().length() == 0) 
      return null;
    
    try
    {
      ExtensionHandler.getClassForName(className);
      return new ExtensionNamespaceSupport(
                           ns, 
                           ""org.apache.xalan.extensions.ExtensionHandlerJavaClass"",                                         
                           new Object[]{ns, ""javaclass"", className});
    }
    catch (ClassNotFoundException e)
    {
      return new ExtensionNamespaceSupport(
                            ns, 
                            ""org.apache.xalan.extensions.ExtensionHandlerJavaPackage"",
                            new Object[]{ns, ""javapackage"", className + "".""});
    }
  }
  

  
  
  
  private void setPredefinedNamespaces()
  {    
    String uri = Constants.S_EXTENSIONS_JAVA_URL;
    String handlerClassName = ""org.apache.xalan.extensions.ExtensionHandlerJavaPackage"";
    String lang = ""javapackage"";
    String lib = """";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
   
    uri = Constants.S_EXTENSIONS_OLD_JAVA_URL;
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
    
    uri = Constants.S_EXTENSIONS_LOTUSXSL_JAVA_URL;
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
    
    uri = Constants.S_EXTENSIONS_XALANLIB_URL;
    handlerClassName = ""org.apache.xalan.extensions.ExtensionHandlerJavaClass"";
    lang = ""javaclass""; 
    lib = ""org.apache.xalan.lib.Extensions"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
    
    
    uri = Constants.S_EXTENSIONS_REDIRECT_URL;
    lib = ""org.apache.xalan.lib.Redirect"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
 
    uri = Constants.S_EXTENSIONS_PIPE_URL;
    lib = ""org.apache.xalan.lib.PipeDocument"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
 
    uri = Constants.S_EXTENSIONS_SQL_URL;
    lib = ""org.apache.xalan.lib.sql.XConnection"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
 
    
    
    
    uri = Constants.S_EXSLT_COMMON_URL;
    lib = ""org.apache.xalan.lib.ExsltCommon"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));

    uri = Constants.S_EXSLT_MATH_URL;
    lib = ""org.apache.xalan.lib.ExsltMath"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
    
    uri = Constants.S_EXSLT_SETS_URL;
    lib = ""org.apache.xalan.lib.ExsltSets"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
    
    uri = Constants.S_EXSLT_DATETIME_URL;
    lib = ""org.apache.xalan.lib.ExsltDatetime"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
                                             
    uri = Constants.S_EXSLT_DYNAMIC_URL;
    lib = ""org.apache.xalan.lib.ExsltDynamic"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));

    uri = Constants.S_EXSLT_STRINGS_URL;
    lib = ""org.apache.xalan.lib.ExsltStrings"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));                                             
  }    
  
}"
org.apache.xalan.extensions.ExtensionNamespaceSupport,3,1,0,5,12,0,4,1,3,0.5,133,0.0,0,0.0,0.555555556,0,0,42.0,1,0.6667,0,"
package org.apache.xalan.extensions;

import java.lang.reflect.Constructor;

import javax.xml.transform.TransformerException;


public class ExtensionNamespaceSupport
{
  
  
  String m_namespace = null;
  String m_handlerClass = null;
  Class [] m_sig = null;  
  Object [] m_args = null;
 
  public ExtensionNamespaceSupport(String namespace, 
                                   String handlerClass, 
                                   Object[] constructorArgs)
  {
    m_namespace = namespace;
    m_handlerClass = handlerClass;
    m_args = constructorArgs;
    
    m_sig = new Class[m_args.length];
    for (int i = 0; i < m_args.length; i++)
    {
      if (m_args[i] != null)
        m_sig[i] = m_args[i].getClass();
      else 
      {
        m_sig = null;
        break;
      }
    }
  }
  
  public String getNamespace()
  {
    return m_namespace;
  }
  
  
  public ExtensionHandler launch()
    throws TransformerException
  {
    ExtensionHandler handler = null;
    try
    {
      Class cl = ExtensionHandler.getClassForName(m_handlerClass);
      Constructor con = null;
      
      if (m_sig != null)
        con = cl.getConstructor(m_sig);
      else 
      {
        Constructor[] cons = cl.getConstructors();
        for (int i = 0; i < cons.length; i ++)
        {
          if (cons[i].getParameterTypes().length == m_args.length)
          {
            con = cons[i];
            break;
          }
        }
      }
      
      if (con != null)
        handler = (ExtensionHandler)con.newInstance(m_args);
      else
        throw new TransformerException(""ExtensionHandler constructor not found"");
    }
    catch (Exception e)
    {
      throw new TransformerException(e);
    }
    return handler;
  }

}"
org.apache.xalan.processor.ProcessorExsltFuncResult,2,5,0,8,8,1,1,7,2,2.0,57,0.0,0,0.995327103,0.625,1,1,27.5,1,0.5,1,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemExsltFuncResult;
import org.apache.xalan.templates.ElemExsltFunction;
import org.apache.xalan.templates.ElemParam;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemVariable;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;


public class ProcessorExsltFuncResult extends ProcessorTemplateElem
{
  
  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws SAXException
  {
    String msg = """";

    super.startElement(handler, uri, localName, rawName, attributes);
    ElemTemplateElement ancestor = handler.getElemTemplateElement().getParentElem();
    while (ancestor != null && !(ancestor instanceof ElemExsltFunction))
    {
      if (ancestor instanceof ElemVariable 
          || ancestor instanceof ElemParam
          || ancestor instanceof ElemExsltFuncResult)
      {
        msg = ""func:result cannot appear within a variable, parameter, or another func:result."";
        handler.error(msg, new SAXException(msg));
      }
      ancestor = ancestor.getParentElem();
    }
    if (ancestor == null)
    {
      msg = ""func:result must appear in a func:function element"";
      handler.error(msg, new SAXException(msg));
    }
  }
}"
org.apache.xalan.processor.ProcessorTemplateElem,4,4,8,14,23,6,9,5,3,2.0,94,0.0,0,0.985915493,0.55,1,1,22.5,1,0.75,1,"
package org.apache.xalan.processor;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.ElemTemplateElement;

import org.xml.sax.Attributes;


public class ProcessorTemplateElem extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    super.startElement(handler, uri, localName, rawName, attributes);
    try
    {
      
      XSLTElementDef def = getElemDef();
      Class classObject = def.getClassObject();
      ElemTemplateElement elem = null;

      try
      {
        elem = (ElemTemplateElement) classObject.newInstance();

        elem.setDOMBackPointer(handler.getOriginatingNode());
        elem.setLocaterInfo(handler.getLocator());
        elem.setPrefixes(handler.getNamespaceSupport());
      }
      catch (InstantiationException ie)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CREATING_ELEMTMPL, null, ie);
      }
      catch (IllegalAccessException iae)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CREATING_ELEMTMPL, null, iae);
      }

      setPropertiesFromAttributes(handler, rawName, attributes, elem);
      appendAndPush(handler, elem);
    }
    catch(TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    ElemTemplateElement parent = handler.getElemTemplateElement();
    if(null != parent)  
    {
      parent.appendChild(elem);
      handler.pushElemTemplateElement(elem);
    }
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {
    super.endElement(handler, uri, localName, rawName);
    handler.popElemTemplateElement();
  }
}
"
org.apache.xalan.lib.sql.DefaultConnectionPool,20,1,0,4,53,70,1,3,16,0.795321637,451,0.888888889,0,0.0,0.214285714,0,0,21.1,3,1.25,1,"
package org.apache.xalan.lib.sql;

import java.lang.reflect.Method;
import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Enumeration;
import java.util.Properties;
import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


public class DefaultConnectionPool implements ConnectionPool
{
  
  private Driver m_Driver = null;
  
  private static final boolean DEBUG = false;

  
  private String m_driver = new String("""");
  
  private String m_url = new String("""");


  
  private int m_PoolMinSize = 1;


  
  private Properties m_ConnectionProtocol = new Properties();

  
  private Vector m_pool = new Vector();

  
  private boolean m_IsActive = false;

  
  public DefaultConnectionPool( ) {}


  
  public boolean isEnabled( )
  {
    return m_IsActive;
  }

  
  public void setDriver( String d )
  {
    m_driver = d;
  }

  
  public void setURL( String url )
  {
    m_url = url;
  }

  
  public void freeUnused( )
  {
    
    
    for ( int x = 0; x < m_pool.size(); x++ )
    {


      PooledConnection pcon =
        (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.inUse() == false )
      {
        if (DEBUG)
        {
          System.err.println(""Closing JDBC Connection "" + x);
        }

        pcon.close();
      }
    }

  }

  
  public boolean hasActiveConnections( )
  {
    return (m_pool.size() > 0);
  }


  
  public void setPassword( String p )
  {
    m_ConnectionProtocol.put(""password"", p);
  }

  
  public void setUser( String u )
  {
    m_ConnectionProtocol.put(""user"", u);
  }

  
  public void setProtocol( Properties p )
  {
    Enumeration e = p.keys();
    while (e.hasMoreElements())
    {
      String key = (String) e.nextElement();
      m_ConnectionProtocol.put(key, p.getProperty(key));
    }
  }


  
  public void setMinConnections( int n )
  {
    m_PoolMinSize = n;
  }

  
  public boolean testConnection( )
  {
    try
    {
      if (DEBUG)
      {
        System.out.println(""Testing Connection"");
      }

      Connection conn = getConnection();

      if (DEBUG)
      {
        DatabaseMetaData dma = conn.getMetaData();

        System.out.println(""
Connected to "" + dma.getURL());
        System.out.println(""Driver   "" + dma.getDriverName());
        System.out.println(""Version  "" + dma.getDriverVersion());
        System.out.println("""");
      }

      if (conn == null) return false;

      releaseConnection(conn);

      if (DEBUG)
      {
        System.out.println(""Testing Connection, SUCCESS"");
      }

      return true;
    }
    catch(Exception e)
    {
      if (DEBUG)
      {
        System.out.println(""Testing Connection, FAILED"");
        e.printStackTrace();
      }

      return false;
    }

  }


  
  
  public synchronized Connection getConnection( )throws IllegalArgumentException, SQLException
  {

    PooledConnection pcon = null;

    
    
    
    
    if ( m_pool.size() < m_PoolMinSize ) { initializePool(); }

    
    for ( int x = 0; x < m_pool.size(); x++ )
    {

      pcon = (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.inUse() == false )
      {
        
        pcon.setInUse(true);
        
        
        return pcon.getConnection();
      }
    }

    
    

    
    Connection con = createConnection();

    
    
    pcon = new PooledConnection(con);

    
    pcon.setInUse(true);

    
    m_pool.addElement(pcon);

    
    return pcon.getConnection();
  }

  
  public synchronized void releaseConnection( Connection con )throws SQLException
  {

    
    for ( int x = 0; x < m_pool.size(); x++ )
    {

      PooledConnection pcon =
        (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.getConnection() == con )
      {
        if (DEBUG)
        {
          System.out.println(""Releasing Connection "" + x);
        }

        if (! isEnabled())
        {
          con.close();
          m_pool.removeElementAt(x);
          if (DEBUG)
          {
            System.out.println(""-->Inactive Pool, Closing connection"");
          }

        }
        else
        {
          
          
          pcon.setInUse(false);
        }

        break;
      }
    }
  }


  
  public synchronized void releaseConnectionOnError( Connection con )throws SQLException
  {

    
    for ( int x = 0; x < m_pool.size(); x++ )
    {

      PooledConnection pcon =
        (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.getConnection() == con )
      {
        if (DEBUG)
        {
          System.out.println(""Releasing Connection On Error"" + x);
        }

        con.close();
        m_pool.removeElementAt(x);
        if (DEBUG)
        {
          System.out.println(""-->Inactive Pool, Closing connection"");
        }
        break;
      }
    }
  }


  
  private Connection createConnection( )throws SQLException
  {
    Connection con = null;

    
    
    con = m_Driver.connect(m_url, m_ConnectionProtocol );

    return con;
  }

  
  
  public synchronized void initializePool( )throws IllegalArgumentException, SQLException
  {

     
     if ( m_driver == null )
     {
       throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_DRIVER_NAME_SPECIFIED, null));
       
     }

     if ( m_url == null )
     {
       throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_URL_SPECIFIED, null));
       
     }

     if ( m_PoolMinSize < 1 )
     {
       throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_POOLSIZE_LESS_THAN_ONE, null));
       
     }

     
     

     try
     {
        
        Class cls = null;
        try
        {
          Method m = Thread.class.getMethod(""getContextClassLoader"", null);
          ClassLoader classLoader = (ClassLoader) m.invoke(Thread.currentThread(), null);
          cls = classLoader.loadClass(m_driver);
        }
        catch (Exception e)
        {
          cls = Class.forName(m_driver);
        }

        if (cls == null)
          cls = Class.forName(m_driver);

        
        
        m_Driver = (Driver) cls.newInstance();

        
        
        
        DriverManager.registerDriver(m_Driver);

     }
     catch(ClassNotFoundException e)
     {
       throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_DRIVER_NAME, null));
       
     }
     catch(Exception e)
     {
       throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_DRIVER_NAME, null));
     }

     
     
     if ( !m_IsActive) return;

    
    do
    {

      Connection con = createConnection();

      if ( con != null )
      {

        
        
        PooledConnection pcon = new PooledConnection(con);

        
        addConnection(pcon);

        if (DEBUG) System.out.println(""Adding DB Connection to the Pool"");
      }
    }
    while (m_pool.size() < m_PoolMinSize);
  }

  
  
  private void addConnection( PooledConnection value )
  {
    
    m_pool.addElement(value);
  }


  
  protected void finalize( )throws Throwable
  {
    if (DEBUG)
    {
      System.out.println(""In Default Connection Pool, Finalize"");
    }

    
    
    for ( int x = 0; x < m_pool.size(); x++ )
    {

      if (DEBUG)
      {
        System.out.println(""Closing JDBC Connection "" + x);
      }

      PooledConnection pcon =
        (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.inUse() == false ) { pcon.close();  }
      else
      {
        if (DEBUG)
        {
          System.out.println(""--> Force close"");
        }

        
        
        try
        {
          java.lang.Thread.sleep(30000);
          pcon.close();
        }
        catch (InterruptedException ie)
        {
          if (DEBUG) System.err.println(ie.getMessage());
        }
      }
    }

    if (DEBUG)
    {
      System.out.println(""Exit Default Connection Pool, Finalize"");
    }

    super.finalize();
  }

  
  public void setPoolEnabled( boolean flag )
  {
     m_IsActive = flag;
     if ( ! flag )
      freeUnused();
  }

}
"
org.apache.xalan.templates.ElemExsltFuncResult,5,4,0,9,13,10,3,6,5,2.0,54,0.0,0,0.981900452,0.6,3,7,9.8,3,1.2,2,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;


public class ElemExsltFuncResult extends ElemVariable
{
 
  
  public void execute(TransformerImpl transformer) throws TransformerException
  {    
    XPathContext context = transformer.getXPathContext();
    ElemExsltFunction owner = getOwnerFunction();
    if (owner != null)
    {
      
      
      
      if (owner.isResultSet())
        throw new TransformerException(""An EXSLT function cannot set more than one result!"");
      
      int sourceNode = context.getCurrentNode();
      
      XObject var = getValue(transformer, sourceNode);
      owner.setResult(var);
    }    
  }

  
  public int getXSLToken()
  {
    return Constants.EXSLT_ELEMNAME_FUNCRESULT;
  }
  
  
   public String getNodeName()
  {
    return Constants.EXSLT_ELEMNAME_FUNCRESULT_STRING;
  }
  
  
  public ElemExsltFunction getOwnerFunction()
  {
  	ElemTemplateElement elem = this;
  	while((elem != null) && !(elem instanceof ElemExsltFunction))
  	{
    	elem = elem.getParentElem();
  	}
  	return (ElemExsltFunction)elem;
  }
  
}
"
org.apache.xml.utils.WrappedRuntimeException,3,4,0,39,5,0,39,0,3,0.0,22,1.0,0,0.944444444,0.666666667,0,0,6.0,1,0.3333,0,"
package org.apache.xml.utils;


public class WrappedRuntimeException extends RuntimeException
{

  
  private Exception m_exception;

  
  public WrappedRuntimeException(Exception e)
  {

    super(e.getMessage());

    m_exception = e;
  }

  
  public WrappedRuntimeException(String msg, Exception e)
  {

    super(msg);

    m_exception = e;
  }
  
  
  public Exception getException()
  {
    return m_exception;
  }
}
"
org.apache.xalan.templates.ElemParam,6,4,0,18,21,15,7,11,6,1.0,80,0.0,0,0.981900452,0.375,3,8,12.16666667,1,0.6667,2,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.VariableStack;
import org.apache.xpath.objects.XObject;


public class ElemParam extends ElemVariable
{
  int m_qnameID;

  
  public ElemParam(){}

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_PARAMVARIABLE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_PARAMVARIABLE_STRING;
  }

  
  public ElemParam(ElemParam param) throws TransformerException
  {
    super(param);
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    m_qnameID = sroot.getComposeState().getQNameID(m_qname);
    if(m_parentNode.getXSLToken() == Constants.ELEMNAME_TEMPLATE)
      ((ElemTemplate)m_parentNode).m_inArgsSize++;
  }
  
  
  public void execute(TransformerImpl transformer) throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
      
    VariableStack vars = transformer.getXPathContext().getVarStack();
    
    if(!vars.isLocalSet(m_index))
    {

      int sourceNode = transformer.getXPathContext().getCurrentNode();
      XObject var = getValue(transformer, sourceNode);
  
      
      transformer.getXPathContext().getVarStack().setLocalVariable(m_index, var);
    }
    
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
  }
  
}
"
org.apache.xpath.patterns.FunctionPattern,7,4,0,12,18,0,3,10,6,0.166666667,156,0.0,1,0.931034483,0.367346939,3,16,21.14285714,2,1.0,1,"
package org.apache.xpath.patterns;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class FunctionPattern extends StepPattern
{

  
  public FunctionPattern(Expression expr, int axis, int predaxis)
  {

    super(0, null, null, axis, predaxis);

    m_functionExpr = expr;
  }

  
  public final void calcScore()
  {

    m_score = SCORE_OTHER;

    if (null == m_targetString)
      calcTargetString();
  }

  
  Expression m_functionExpr;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    m_functionExpr.fixupVariables(vars, globalsSize);
  }

  
  
  public XObject execute(XPathContext xctxt, int context)
          throws javax.xml.transform.TransformerException
  {

    DTMIterator nl = m_functionExpr.asIterator(xctxt, context);
    XNumber score = SCORE_NONE;

    if (null != nl)
    {
      int n;

      while (DTM.NULL != (n = nl.nextNode()))
      {
        score = (n == context) ? SCORE_OTHER : SCORE_NONE;

        if (score == SCORE_OTHER)
        {
          context = n;

          break;
        }
      }

      
    }
    nl.detach();

    return score;
  }
  
  
  public XObject execute(XPathContext xctxt, int context, 
                         DTM dtm, int expType)
          throws javax.xml.transform.TransformerException
  {

    DTMIterator nl = m_functionExpr.asIterator(xctxt, context);
    XNumber score = SCORE_NONE;

    if (null != nl)
    {
      int n;

      while (DTM.NULL != (n = nl.nextNode()))
      {
        score = (n == context) ? SCORE_OTHER : SCORE_NONE;

        if (score == SCORE_OTHER)
        {
          context = n;

          break;
        }
      }

      nl.detach();
    }

    return score;
  }
  
  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    int context = xctxt.getCurrentNode();
    DTMIterator nl = m_functionExpr.asIterator(xctxt, context);
    XNumber score = SCORE_NONE;

    if (null != nl)
    {
      int n;

      while (DTM.NULL != (n = nl.nextNode()))
      {
        score = (n == context) ? SCORE_OTHER : SCORE_NONE;

        if (score == SCORE_OTHER)
        {
          context = n;

          break;
        }
      }

      nl.detach();
    }

    return score;
  }
  
  class FunctionOwner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_functionExpr;
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(FunctionPattern.this);
    	m_functionExpr = exp;
    }
  }
  
  
  protected void callSubtreeVisitors(XPathVisitor visitor)
  {
    m_functionExpr.callVisitors(new FunctionOwner(), visitor);
    super.callSubtreeVisitors(visitor);
  }

}
"
org.apache.xml.utils.Constants,1,1,1,1,2,0,1,0,1,2.0,26,0.0,0,0.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xml.utils;


public class Constants
{

  
  public static final String 
	S_XMLNAMESPACEURI = ""http:
	S_XSLNAMESPACEURL = ""http:
	S_OLDXSLNAMESPACEURL = ""http:

  
  public static final String 
	S_VENDOR = ""Apache Software Foundation"", 
	S_VENDORURL = ""http:

  
  public static final String 
    S_BUILTIN_EXTENSIONS_URL = ""http:

  
  public static final String 
    S_BUILTIN_OLD_EXTENSIONS_URL = ""http:
  
  
  public static final String 
    
    S_EXTENSIONS_OLD_JAVA_URL = ""http:
    
    S_EXTENSIONS_JAVA_URL = ""http:
    S_EXTENSIONS_LOTUSXSL_JAVA_URL = ""http:
    S_EXTENSIONS_XALANLIB_URL = ""http:
    S_EXTENSIONS_REDIRECT_URL = ""http:
    S_EXTENSIONS_PIPE_URL = ""http:
    S_EXTENSIONS_SQL_URL = ""http:
  
  
  public static final String
    S_EXSLT_COMMON_URL = ""http:
    S_EXSLT_MATH_URL = ""http:
    S_EXSLT_SETS_URL = ""http:
    S_EXSLT_DATETIME_URL = ""http:
    S_EXSLT_FUNCTIONS_URL = ""http:
    S_EXSLT_DYNAMIC_URL = ""http:
    S_EXSLT_STRINGS_URL = ""http:
    
    
  
  public static final double XSLTVERSUPPORTED = 1.0;
}
"
org.apache.xml.dtm.ref.DTMDefaultBaseIterators,4,3,3,54,36,6,46,31,4,2.0,243,0.0,0,0.978723404,0.642857143,0,0,59.75,2,1.0,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;

import javax.xml.transform.Source;

import org.apache.xml.utils.XMLStringFactory;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;



public abstract class DTMDefaultBaseIterators extends DTMDefaultBaseTraversers
{

  
  public DTMDefaultBaseIterators(DTMManager mgr, Source source,
                                 int dtmIdentity,
                                 DTMWSFilter whiteSpaceFilter,
                                 XMLStringFactory xstringfactory,
                                 boolean doIndexing)
  {
    super(mgr, source, dtmIdentity, whiteSpaceFilter, 
          xstringfactory, doIndexing);
  }

  
  public DTMDefaultBaseIterators(DTMManager mgr, Source source,
                                 int dtmIdentity,
                                 DTMWSFilter whiteSpaceFilter,
                                 XMLStringFactory xstringfactory,
                                 boolean doIndexing,
                                 int blocksize,
                                 boolean usePrevsib)
  {
    super(mgr, source, dtmIdentity, whiteSpaceFilter, 
          xstringfactory, doIndexing, blocksize, usePrevsib);
  }

  
  public DTMAxisIterator getTypedAxisIterator(int axis, int type)
  {

    DTMAxisIterator iterator = null;

    

    
    
    
    
    
    
    
    
    {
      switch (axis)
      {
      case Axis.SELF :
        iterator = new TypedSingletonIterator(type);
        break;
      case Axis.CHILD :
        iterator = new TypedChildrenIterator(type);
        break;
      case Axis.PARENT :
        return (new ParentIterator().setNodeType(type));
      case Axis.ANCESTOR :
        return (new TypedAncestorIterator(type));
      case Axis.ANCESTORORSELF :
        return ((new TypedAncestorIterator(type)).includeSelf());
      case Axis.ATTRIBUTE :
        return (new TypedAttributeIterator(type));
      case Axis.DESCENDANT :
        iterator = new TypedDescendantIterator(type);
        break;
      case Axis.DESCENDANTORSELF :
        iterator = (new TypedDescendantIterator(type)).includeSelf();
        break;
      case Axis.FOLLOWING :
        iterator = new TypedFollowingIterator(type);
        break;
      case Axis.PRECEDING :
        iterator = new TypedPrecedingIterator(type);
        break;
      case Axis.FOLLOWINGSIBLING :
        iterator = new TypedFollowingSiblingIterator(type);
        break;
      case Axis.PRECEDINGSIBLING :
        iterator = new TypedPrecedingSiblingIterator(type);
        break;
      case Axis.NAMESPACE :
        iterator = new TypedNamespaceIterator(type);
        break;
      case Axis.ROOT :
        iterator = new TypedRootIterator(type);
        break;
      default :
        throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED, new Object[]{Axis.names[axis]})); 
                               
      }
    }

    return (iterator);
  }

  
  public DTMAxisIterator getAxisIterator(final int axis)
  {

    DTMAxisIterator iterator = null;

    switch (axis)
    {
    case Axis.SELF :
      iterator = new SingletonIterator();
      break;
    case Axis.CHILD :
      iterator = new ChildrenIterator();
      break;
    case Axis.PARENT :
      return (new ParentIterator());
    case Axis.ANCESTOR :
      return (new AncestorIterator());
    case Axis.ANCESTORORSELF :
      return ((new AncestorIterator()).includeSelf());
    case Axis.ATTRIBUTE :
      return (new AttributeIterator());
    case Axis.DESCENDANT :
      iterator = new DescendantIterator();
      break;
    case Axis.DESCENDANTORSELF :
      iterator = (new DescendantIterator()).includeSelf();
      break;
    case Axis.FOLLOWING :
      iterator = new FollowingIterator();
      break;
    case Axis.PRECEDING :
      iterator = new PrecedingIterator();
      break;
    case Axis.FOLLOWINGSIBLING :
      iterator = new FollowingSiblingIterator();
      break;
    case Axis.PRECEDINGSIBLING :
      iterator = new PrecedingSiblingIterator();
      break;
    case Axis.NAMESPACE :
      iterator = new NamespaceIterator();
      break;
    case Axis.ROOT :
      iterator = new RootIterator();
      break;
    default :
      throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_ITERATOR_AXIS_NOT_IMPLEMENTED, new Object[]{Axis.names[axis]})); 
                             
    }

    return (iterator);
  }

  
  public abstract class InternalAxisIteratorBase extends DTMAxisIteratorBase
  {

    
    
    
    
    
    
    

    
    protected int _currentNode;

    
    public void setMark()
    {
      _markedNode = _currentNode;
    }

    
    public void gotoMark()
    {
      _currentNode = _markedNode;
    }
        
  }  

  
  public final class ChildrenIterator extends InternalAxisIteratorBase
  {

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = (node == DTM.NULL) ? DTM.NULL
                                          : _firstch(makeNodeIdentity(node));

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      if (_currentNode != NULL) {
        int node = _currentNode;
        _currentNode = _nextsib(node);
        return returnNode(makeNodeHandle(node));
      }

      return END;
    }
  }  

  
  public final class ParentIterator extends InternalAxisIteratorBase
  {

    
    private int _nodeType = -1;

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = getParent(node);

        return resetPosition();
      }

      return this;
    }

    
    public DTMAxisIterator setNodeType(final int type)
    {

      _nodeType = type;

      return this;
    }

    
    public int next()
    {
      int result = _currentNode;

      if (_nodeType >= DTM.NTYPES) {
        if (_nodeType != getExpandedTypeID(_currentNode)) {
          result = END;
        }
      } else if (_nodeType != NULL) {
        if (_nodeType != getNodeType(_currentNode)) {
          result = END;
        }
      }

      _currentNode = END;

      return returnNode(result);
    }
  }  

  
  public final class TypedChildrenIterator extends InternalAxisIteratorBase
  {

    
    private final int _nodeType;

    
    public TypedChildrenIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = (node == DTM.NULL)
                                   ? DTM.NULL
                                   : _firstch(makeNodeIdentity(_startNode));

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      int eType;
      int node = _currentNode;

      int nodeType = _nodeType;

      if (nodeType >= DTM.NTYPES) {
        while (node != DTM.NULL && _exptype(node) != nodeType) {
          node = _nextsib(node);
        }
      } else {
        while (node != DTM.NULL) {
          eType = _exptype(node);
          if (eType < DTM.NTYPES) {
            if (eType == nodeType) {
              break;
            }
          } else if (m_expandedNameTable.getType(eType) == nodeType) {
            break;
          }
          node = _nextsib(node);
        }
      }

      if (node == DTM.NULL) {
        _currentNode = DTM.NULL;
        return DTM.NULL;
      } else {
        _currentNode = _nextsib(node);
        return returnNode(makeNodeHandle(node));
      }

    }
  }  

  
  public final class NamespaceChildrenIterator
          extends InternalAxisIteratorBase
  {

    
    private final int _nsType;

    
    public NamespaceChildrenIterator(final int type)
    {
      _nsType = type;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = (node == DTM.NULL) ? DTM.NULL : NOTPROCESSED;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      if (_currentNode != DTM.NULL) {
        for (int node = (NOTPROCESSED == _currentNode)
                                  ? _firstch(makeNodeIdentity(_startNode))
                                  : _nextsib(_currentNode);
             node != END;
             node = _nextsib(node)) {
          if (m_expandedNameTable.getNamespaceID(_exptype(node)) == _nsType) {
            _currentNode = node;

            return returnNode(node);
          }
        }
      }

      return END;
    }
  }  
  
  
  public class NamespaceIterator
          extends InternalAxisIteratorBase
  {

    
    public NamespaceIterator()
    {

      super();
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = getFirstNamespaceNode(node, true);

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      int node = _currentNode;

      if (DTM.NULL != node)
        _currentNode = getNextNamespaceNode(_startNode, node, true);

      return returnNode(node);
    }
  }  
  
  
  public class TypedNamespaceIterator extends NamespaceIterator
  {

    
    private final int _nodeType;

    
    public TypedNamespaceIterator(int nodeType)
    {
      super();
      _nodeType = nodeType;
    }

    
    public int next()
    {
    	int node;

      for (node = _currentNode;
           node != END;
           node = getNextNamespaceNode(_startNode, node, true)) {
        if (getExpandedTypeID(node) == _nodeType
            || getNodeType(node) == _nodeType
            || getNamespaceType(node) == _nodeType) {
          _currentNode = node;

          return returnNode(node);
        }
      }

      return (_currentNode =END);
    }
  }  
  
  
  public class RootIterator
          extends InternalAxisIteratorBase
  {

    
    public RootIterator()
    {

      super();
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = getDocumentRoot(node);
        _currentNode = NULL;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      if(_startNode == _currentNode)
        return NULL;

      _currentNode = _startNode;

      return returnNode(_startNode);
    }
  }  
  
  
  public class TypedRootIterator extends RootIterator
  {

    
    private final int _nodeType;

    
    public TypedRootIterator(int nodeType)
    {
      super();
      _nodeType = nodeType;
    }

    
    public int next()
    {
    	if(_startNode == _currentNode)
        return NULL;

      int nodeType = _nodeType;
      int node = _startNode;
      int expType = getExpandedTypeID(node);

      _currentNode = node;

      if (nodeType >= DTM.NTYPES) {
        if (nodeType == expType) {
          return returnNode(node);
        }
      } else {
        if (expType < DTM.NTYPES) {
          if (expType == nodeType) {
            return returnNode(node);
          }
        } else {
          if (m_expandedNameTable.getType(expType) == nodeType) {
            return returnNode(node);
          }
        }
      }

      return END;
    }
  }  

  
  public final class NamespaceAttributeIterator
          extends InternalAxisIteratorBase
  {

    
    private final int _nsType;

    
    public NamespaceAttributeIterator(int nsType)
    {

      super();

      _nsType = nsType;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = getFirstNamespaceNode(node, false);

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      int node = _currentNode;

      if (DTM.NULL != node)
        _currentNode = getNextNamespaceNode(_startNode, node, false);

      return returnNode(node);
    }
  }  

  
  public class FollowingSiblingIterator extends InternalAxisIteratorBase
  {

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = makeNodeIdentity(node);

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      _currentNode = (_currentNode == DTM.NULL) ? DTM.NULL
                                                : _nextsib(_currentNode);
      return returnNode(makeNodeHandle(_currentNode));
    }
  }  

  
  public final class TypedFollowingSiblingIterator
          extends FollowingSiblingIterator
  {

    
    private final int _nodeType;

    
    public TypedFollowingSiblingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {
      if (_currentNode == DTM.NULL) {
        return DTM.NULL;
      }

      int node = _currentNode;
      int eType;
      int nodeType = _nodeType;

      if (nodeType >= DTM.NTYPES) {
        do {
          node = _nextsib(node);
        } while (node != DTM.NULL && _exptype(node) != nodeType);
      } else {
        while ((node = _nextsib(node)) != DTM.NULL) {
          eType = _exptype(node);
          if (eType < DTM.NTYPES) {
            if (eType == nodeType) {
              break;
            }
          } else if (m_expandedNameTable.getType(eType) == nodeType) {
            break;
          }
        }
      }

      _currentNode = node;

      return (_currentNode == DTM.NULL)
                      ? DTM.NULL
                      : returnNode(makeNodeHandle(_currentNode));
    }
  }  

  
  public final class AttributeIterator extends InternalAxisIteratorBase
  {

    

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = getFirstAttributeIdentity(makeNodeIdentity(node));

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      final int node = _currentNode;

      if (node != NULL) {
        _currentNode = getNextAttributeIdentity(node);
        return returnNode(makeNodeHandle(node));
      }

      return NULL;
    }
  }  

  
  public final class TypedAttributeIterator extends InternalAxisIteratorBase
  {

    
    private final int _nodeType;

    
    public TypedAttributeIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    

    
    public DTMAxisIterator setStartNode(int node)
    {
      if (_isRestartable)
      {
        _startNode = node;

        _currentNode = getTypedAttribute(node, _nodeType);

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      final int node = _currentNode;

      
      
      _currentNode = NULL;

      return returnNode(node);
    }
  }  

  
  public class PrecedingSiblingIterator extends InternalAxisIteratorBase
  {

    
    protected int _startNodeID;

    
    public boolean isReverse()
    {
      return true;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        node = _startNodeID = makeNodeIdentity(node);

        if(node == NULL)
        {
          _currentNode = node;
          return resetPosition();
        }

        int type = m_expandedNameTable.getType(_exptype(node));
        if(ExpandedNameTable.ATTRIBUTE == type 
           || ExpandedNameTable.NAMESPACE == type )
        {
          _currentNode = node;
        }
        else
        {
          
          _currentNode = _parent(node);
          if(NULL!=_currentNode)	
            _currentNode = _firstch(_currentNode);
          else
            _currentNode = node;
        }

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      if (_currentNode == _startNodeID || _currentNode == DTM.NULL)
      {
        return NULL;
      }
      else
      {
        final int node = _currentNode;
        _currentNode = _nextsib(node);

        return returnNode(makeNodeHandle(node));
      }
    }
  }  

  
  public final class TypedPrecedingSiblingIterator
          extends PrecedingSiblingIterator
  {

    
    private final int _nodeType;

    
    public TypedPrecedingSiblingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {
      int node = _currentNode;
      int expType;

      int nodeType = _nodeType;
      int startID = _startNodeID;

      if (nodeType >= DTM.NTYPES) {
        while (node != NULL && node != startID && _exptype(node) != nodeType) {
          node = _nextsib(node);
        }
      } else {
        while (node != NULL && node != startID) {
          expType = _exptype(node);
          if (expType < DTM.NTYPES) {
            if (expType == nodeType) {
              break;
            }
          } else {
            if (m_expandedNameTable.getType(expType) == nodeType) {
              break;
            }
          }
          node = _nextsib(node);
        }
      }

      if (node == DTM.NULL || node == _startNodeID) {
        _currentNode = NULL;
        return NULL;
      } else {
        _currentNode = _nextsib(node);
        return returnNode(makeNodeHandle(node));
      }
    }
  }  

  
  public class PrecedingIterator extends InternalAxisIteratorBase
  {

    
    private final int _maxAncestors = 8;

    
    protected int[] _stack = new int[_maxAncestors];

    
    protected int _sp, _oldsp;

    protected int _markedsp, _markedNode, _markedDescendant;

    

    
    public boolean isReverse()
    {
      return true;
    }

    
    public DTMAxisIterator cloneIterator()
    {
      _isRestartable = false;

      try
      {
        final PrecedingIterator clone = (PrecedingIterator) super.clone();
        final int[] stackCopy = new int[_stack.length];
        System.arraycopy(_stack, 0, stackCopy, 0, _stack.length);

        clone._stack = stackCopy;

        
        return clone;
      }
      catch (CloneNotSupportedException e)
      {
        throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_ITERATOR_CLONE_NOT_SUPPORTED, null)); 
      }
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        node = makeNodeIdentity(node);

        
        int parent, index;

       if (_type(node) == DTM.ATTRIBUTE_NODE)
        node = _parent(node);

        _startNode = node;
        _stack[index = 0] = node;
        
       

		parent=node;
		while ((parent = _parent(parent)) != NULL)
		{
			if (++index == _stack.length)
			{
				final int[] stack = new int[index + 4];
				System.arraycopy(_stack, 0, stack, 0, index);
				_stack = stack;
			}
			_stack[index] = parent;
        }
        if(index>0)
	        --index; 

        _currentNode=_stack[index]; 

        _oldsp = _sp = index;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
    	
    	
    	
   		for(++_currentNode; 
   			_sp>=0; 
   			++_currentNode)
   		{
   			if(_currentNode < _stack[_sp])
   			{
   				if(_type(_currentNode) != ATTRIBUTE_NODE &&
   					_type(_currentNode) != NAMESPACE_NODE)
   					return returnNode(makeNodeHandle(_currentNode));
   			}
   			else
   				--_sp;
   		}
   		return NULL;
    }

    

    
    public DTMAxisIterator reset()
    {

      _sp = _oldsp;

      return resetPosition();
    }

    public void setMark() {
        _markedsp = _sp;
        _markedNode = _currentNode;
        _markedDescendant = _stack[0];
    }

    public void gotoMark() {
        _sp = _markedsp;
        _currentNode = _markedNode;
    }
  }  

  
  public final class TypedPrecedingIterator extends PrecedingIterator
  {

    
    private final int _nodeType;

    
    public TypedPrecedingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {
      int node = _currentNode;
      int nodeType = _nodeType;

      if (nodeType >= DTM.NTYPES) {
        while (true) {
          node = node + 1;

          if (_sp < 0) {
            node = NULL;
            break;
          } else if (node >= _stack[_sp]) {
            if (--_sp < 0) {
              node = NULL;
              break;
            }
          } else if (_exptype(node) == nodeType) {
            break;
          }
        }
      } else {
        int expType;

        while (true) {
          node = node + 1;

          if (_sp < 0) {
            node = NULL;
            break;
          } else if (node >= _stack[_sp]) {
            if (--_sp < 0) {
              node = NULL;
              break;
            }
          } else {
            expType = _exptype(node);
            if (expType < DTM.NTYPES) {
              if (expType == nodeType) {
                break;
              }
            } else {
              if (m_expandedNameTable.getType(expType) == nodeType) {
                break;
              }
            }
          }
        }
      }

      _currentNode = node;
             
      return (node == NULL) ? NULL : returnNode(makeNodeHandle(node));
    }
  }  

  
  public class FollowingIterator extends InternalAxisIteratorBase
  {
    DTMAxisTraverser m_traverser; 
    
    public FollowingIterator()
    {
      m_traverser = getAxisTraverser(Axis.FOLLOWING);
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;

        
        
        
        
        
        _currentNode = m_traverser.first(node);

        
        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      int node = _currentNode;

      _currentNode = m_traverser.next(_startNode, _currentNode);

      return returnNode(node);
    }
  }  

  
  public final class TypedFollowingIterator extends FollowingIterator
  {

    
    private final int _nodeType;

    
    public TypedFollowingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {

      int node;

      do{
       node = _currentNode;

      _currentNode = m_traverser.next(_startNode, _currentNode);

      } 
      while (node != DTM.NULL
             && (getExpandedTypeID(node) != _nodeType && getNodeType(node) != _nodeType));

      return (node == DTM.NULL ? DTM.NULL :returnNode(node));
    }
  }  

  
  public class AncestorIterator extends InternalAxisIteratorBase
  {
    org.apache.xml.utils.NodeVector m_ancestors = 
         new org.apache.xml.utils.NodeVector();
         
    int m_ancestorsPos;

    int m_markedPos;
    
    
    int m_realStartNode;
    
    
    public int getStartNode()
    {
      return m_realStartNode;
    }

    
    public final boolean isReverse()
    {
      return true;
    }

    
    public DTMAxisIterator cloneIterator()
    {
      _isRestartable = false;  

      try
      {
        final AncestorIterator clone = (AncestorIterator) super.clone();

        clone._startNode = _startNode;

        
        return clone;
      }
      catch (CloneNotSupportedException e)
      {
        throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_ITERATOR_CLONE_NOT_SUPPORTED, null)); 
      }
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      m_realStartNode = node;

      if (_isRestartable)
      {
        int nodeID = makeNodeIdentity(node);

        if (!_includeSelf && node != DTM.NULL) {
          nodeID = _parent(nodeID);
          node = makeNodeHandle(nodeID);
        }

        _startNode = node;

        while (nodeID != END) {
          m_ancestors.addElement(node);
          nodeID = _parent(nodeID);
          node = makeNodeHandle(nodeID);
        }
        m_ancestorsPos = m_ancestors.size()-1;

        _currentNode = (m_ancestorsPos>=0)
                               ? m_ancestors.elementAt(m_ancestorsPos)
                               : DTM.NULL;

        return resetPosition();
      }

      return this;
    }

    
    public DTMAxisIterator reset()
    {

      m_ancestorsPos = m_ancestors.size()-1;

      _currentNode = (m_ancestorsPos>=0) ? m_ancestors.elementAt(m_ancestorsPos)
                                         : DTM.NULL;

      return resetPosition();
    }

    
    public int next()
    {

      int next = _currentNode;
      
      int pos = --m_ancestorsPos;

      _currentNode = (pos >= 0) ? m_ancestors.elementAt(m_ancestorsPos)
                                : DTM.NULL;
      
      return returnNode(next);
    }

    public void setMark() {
        m_markedPos = m_ancestorsPos;
    }

    public void gotoMark() {
        m_ancestorsPos = m_markedPos;
        _currentNode = m_ancestorsPos>=0 ? m_ancestors.elementAt(m_ancestorsPos)
                                         : DTM.NULL;
    }
  }  

  
  public final class TypedAncestorIterator extends AncestorIterator
  {

    
    private final int _nodeType;

    
    public TypedAncestorIterator(int type)
    {
      _nodeType = type;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      m_realStartNode = node;

      if (_isRestartable)
      {
        int nodeID = makeNodeIdentity(node);
        int nodeType = _nodeType;

        if (!_includeSelf && node != DTM.NULL) {
          nodeID = _parent(nodeID);
        }

        _startNode = node;

        if (nodeType >= DTM.NTYPES) {
          while (nodeID != END) {
            int eType = _exptype(nodeID);

            if (eType == nodeType) {
              m_ancestors.addElement(makeNodeHandle(nodeID));
            }
            nodeID = _parent(nodeID);
          }
        } else {
          while (nodeID != END) {
            int eType = _exptype(nodeID);

            if ((eType >= DTM.NTYPES
                    && m_expandedNameTable.getType(eType) == nodeType)
                || (eType < DTM.NTYPES && eType == nodeType)) {
              m_ancestors.addElement(makeNodeHandle(nodeID));
            }
            nodeID = _parent(nodeID);
          }
        }
        m_ancestorsPos = m_ancestors.size()-1;

        _currentNode = (m_ancestorsPos>=0)
                               ? m_ancestors.elementAt(m_ancestorsPos)
                               : DTM.NULL;

        return resetPosition();
      }

      return this;
    }
  }  

  
  public class DescendantIterator extends InternalAxisIteratorBase
  {

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        node = makeNodeIdentity(node);
        _startNode = node;

        if (_includeSelf)
          node--;

        _currentNode = node;

        return resetPosition();
      }

      return this;
    }

    
    protected boolean isDescendant(int identity)
    {
      return (_parent(identity) >= _startNode) || (_startNode == identity);
    }

    
    public int next()
    {
      if (_startNode == NULL) {
        return NULL;
      }

      if (_includeSelf && (_currentNode + 1) == _startNode)
          return returnNode(makeNodeHandle(++_currentNode)); 

      int node = _currentNode;
      int type;

      do {
        node++;
        type = _type(node);

        if (NULL == type ||!isDescendant(node)) {
          _currentNode = NULL;
          return END;
        }
      } while(ATTRIBUTE_NODE == type || TEXT_NODE == type
                 || NAMESPACE_NODE == type);

      _currentNode = node;
      return returnNode(makeNodeHandle(node));  
    }
  
     
  public DTMAxisIterator reset()
  {

    final boolean temp = _isRestartable;

    _isRestartable = true;

    setStartNode(makeNodeHandle(_startNode));

    _isRestartable = temp;

    return this;
  }
    
  }  

  
  public final class TypedDescendantIterator extends DescendantIterator
  {

    
    private final int _nodeType;

    
    public TypedDescendantIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    
    public int next()
    {
      int node;
      int type;

      if (_startNode == NULL) {
        return NULL;
      }

      node = _currentNode;

      do
      {
        node++;
        type = _type(node);

        if (NULL == type ||!isDescendant(node)) {
          _currentNode = NULL;
          return END;
        }
      }
      while (type != _nodeType && _exptype(node) != _nodeType);

      _currentNode = node;
      return returnNode(makeNodeHandle(node));
    }
  }  

  
  public class NthDescendantIterator extends DescendantIterator
  {

    
    int _pos;

    
    public NthDescendantIterator(int pos)
    {
      _pos = pos;
    }

    
    public int next()
    {

      
      int node;

      while ((node = super.next()) != END)
      {
        node = makeNodeIdentity(node);

        int parent = _parent(node);
        int child = _firstch(parent);
        int pos = 0;

        do
        {
          int type = _type(child);

          if (ELEMENT_NODE == type)
            pos++;
        }
        while ((pos < _pos) && (child = _nextsib(child)) != END);

        if (node == child)
          return node;
      }

      return (END);
    }
  }  

  
  public class SingletonIterator extends InternalAxisIteratorBase
  {

    
    private boolean _isConstant;

    
    public SingletonIterator()
    {
      this(Integer.MIN_VALUE, false);
    }

    
    public SingletonIterator(int node)
    {
      this(node, false);
    }

    
    public SingletonIterator(int node, boolean constant)
    {
      _currentNode = _startNode = node;
      _isConstant = constant;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isConstant)
      {
        _currentNode = _startNode;

        return resetPosition();
      }
      else if (_isRestartable)
      {
        if (_currentNode == Integer.MIN_VALUE)
        {
          _currentNode = _startNode = node;
        }

        return resetPosition();
      }

      return this;
    }

    
    public DTMAxisIterator reset()
    {

      if (_isConstant)
      {
        _currentNode = _startNode;

        return resetPosition();
      }
      else
      {
        final boolean temp = _isRestartable;

        _isRestartable = true;

        setStartNode(_startNode);

        _isRestartable = temp;
      }

      return this;
    }

    
    public int next()
    {

      final int result = _currentNode;

      _currentNode = END;

      return returnNode(result);
    }
  }  

  
  public final class TypedSingletonIterator extends SingletonIterator
  {

    
    private final int _nodeType;

    
    public TypedSingletonIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    
    public int next()
    {

      
      final int result = _currentNode;
      int nodeType = _nodeType;

      _currentNode = END;

      if (nodeType >= DTM.NTYPES) {
        if (getExpandedTypeID(result) == nodeType) {
          return returnNode(result);
        }
      } else {
        if (getNodeType(result) == nodeType) {
          return returnNode(result);
        }
      }

      return NULL;
    }
  }  
}
"
org.apache.xalan.xsltc.compiler.StringLengthCall,2,4,0,11,13,1,0,11,2,2.0,44,0.0,0,0.989690722,0.6,2,4,21.0,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;

final class StringLengthCall extends FunctionCall {
    public StringLengthCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	if (argumentCount() > 0) {
	    argument().translate(classGen, methodGen);
	}
	else {
	    il.append(methodGen.loadContextNode());
	    Type.Node.translateTo(classGen, methodGen, Type.String);
	}
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_CLASS,
						     ""length"", ""()I"")));
    }
}
"
org.apache.xalan.xsltc.runtime.AttributeList,17,1,0,3,39,62,2,1,16,0.7578125,276,1.0,1,0.0,0.441176471,0,0,14.76470588,4,1.4706,0,"

package org.apache.xalan.xsltc.runtime;

import java.util.Vector;

public class AttributeList implements org.xml.sax.Attributes {

    private final static String EMPTYSTRING = """";
    private final static String CDATASTRING = ""CDATA"";

    private Hashtable _attributes;
    private Vector    _names;
    private Vector    _qnames;
    private Vector    _values;
    private Vector    _uris;
    private int       _length;

    
    public AttributeList() {
	
	_length = 0;
    }

    
    public AttributeList(org.xml.sax.Attributes attributes) {
	this();
	if (attributes != null) {
	    final int count = attributes.getLength();
	    for (int i = 0; i < count; i++) {
		add(attributes.getQName(i),attributes.getValue(i));
	    }
	}
    }
    
    
    private void alloc() {
	_attributes = new Hashtable();
	_names  = new Vector();
	_values = new Vector();
	_qnames = new Vector();
	_uris   = new Vector();        
    }

    
    public int getLength() {
	return(_length);
    }

    
    public String getURI(int index) {
	if (index < _length)
	    return((String)_uris.elementAt(index));
	else
	    return(null);
    }

    
    public String getLocalName(int index) {
	if (index < _length)
	    return((String)_names.elementAt(index));
	else
	    return(null);
    }

    
    public String getQName(int pos) {
	if (pos < _length)
	    return((String)_qnames.elementAt(pos));
	else
	    return(null);
    }

    
    public String getType(int index) {
	return(CDATASTRING);
    }

    
    public int getIndex(String namespaceURI, String localPart) {
	return(-1);
    }

    
    public int getIndex(String qname) {
	return(-1);
    }

    
    public String getType(String uri, String localName) {
	return(CDATASTRING);
    }

    
    public String getType(String qname) {
	return(CDATASTRING);
    }

    
    public String getValue(int pos) {
	if (pos < _length)
	    return((String)_values.elementAt(pos));
	else
	    return(null);
    }

    
    public String getValue(String qname) {
	if (_attributes != null) {
	    final Integer obj = (Integer)_attributes.get(qname);
	    if (obj == null) return null;
	    return(getValue(obj.intValue()));
	}
	else
	    return null;
    }

    
    public String getValue(String uri, String localName) {
	return(getValue(uri+':'+localName));
    }

    
    public void add(String qname, String value) {
	
	if (_attributes == null)
	    alloc();
	
	
	Integer obj = (Integer)_attributes.get(qname);
	if (obj == null) {
	    _attributes.put(qname, obj = new Integer(_length++));
	    _qnames.addElement(qname);
	    _values.addElement(value);
	    int col = qname.lastIndexOf(':');
	    if (col > -1) {
		_uris.addElement(qname.substring(0,col));
		_names.addElement(qname.substring(col+1));
	    }
	    else {
		_uris.addElement(EMPTYSTRING);
		_names.addElement(qname);
	    }
	}
	else {
	    final int index = obj.intValue();
	    _values.set(index, value);
	}
    }

    
    public void clear() {
	_length = 0;
	if (_attributes != null) {
	    _attributes.clear();
	    _names.removeAllElements();
	    _values.removeAllElements();
	    _qnames.removeAllElements();
	    _uris.removeAllElements();
	}
    }
    
}
"
org.apache.xalan.processor.XSLTAttributeDef,43,1,0,14,93,783,4,10,1,0.962585034,1969,0.166666667,2,0.0,0.328042328,0,0,43.81395349,19,1.5349,2,"
package org.apache.xalan.processor;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.StringTokenizer;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.AVT;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.StringToIntTable;
import org.apache.xml.utils.StringVector;
import org.apache.xml.utils.XMLChar;
import org.apache.xpath.XPath;

 

public class XSLTAttributeDef
{
   
   static final int FATAL = 0;
   static final int ERROR = 1;
   static final int WARNING = 2;
   
   
  
  XSLTAttributeDef(String namespace, String name, int type, boolean required, boolean supportsAVT, int errorType)
  {
    this.m_namespace = namespace;
    this.m_name = name;
    this.m_type = type;
    this.m_required = required;
    this.m_supportsAVT = supportsAVT;
    this.m_errorType = errorType;
  }

  
  XSLTAttributeDef(String namespace, String name, int type, boolean supportsAVT, int errorType, String defaultVal)
  {

    this.m_namespace = namespace;
    this.m_name = name;
    this.m_type = type;
    this.m_required = false;
    this.m_supportsAVT = supportsAVT;  
    this.m_errorType = errorType;      
    this.m_default = defaultVal;
   }

  
  XSLTAttributeDef(String namespace, String name, boolean required, boolean supportsAVT, 
                    boolean prefixedQNameValAllowed, int errorType, String k1, int v1, String k2, int v2)
  {

    this.m_namespace = namespace;
    this.m_name = name;
	this.m_type = prefixedQNameValAllowed ? this.T_ENUM_OR_PQNAME : this.T_ENUM;    
    this.m_required = required;
    this.m_supportsAVT = supportsAVT;    
    this.m_errorType = errorType;    
    m_enums = new StringToIntTable(2);

    m_enums.put(k1, v1);
    m_enums.put(k2, v2);
  }

  
  XSLTAttributeDef(String namespace, String name, boolean required, boolean supportsAVT,
                    boolean prefixedQNameValAllowed, int errorType, String k1, int v1, String k2, int v2, String k3, int v3)
  {

    this.m_namespace = namespace;
    this.m_name = name;
	this.m_type = prefixedQNameValAllowed ? this.T_ENUM_OR_PQNAME : this.T_ENUM;    
    this.m_required = required;
    this.m_supportsAVT = supportsAVT; 
    this.m_errorType = errorType;      
    m_enums = new StringToIntTable(3);

    m_enums.put(k1, v1);
    m_enums.put(k2, v2);
    m_enums.put(k3, v3);
  }

  
  XSLTAttributeDef(String namespace, String name, boolean required, boolean supportsAVT,
                   boolean prefixedQNameValAllowed, int errorType, String k1, int v1, String k2, int v2, 
                   String k3, int v3, String k4, int v4)
  {

    this.m_namespace = namespace;
    this.m_name = name;
	this.m_type = prefixedQNameValAllowed ? this.T_ENUM_OR_PQNAME : this.T_ENUM;    
    this.m_required = required;
    this.m_supportsAVT = supportsAVT;      
    this.m_errorType = errorType; 
    m_enums = new StringToIntTable(4);

    m_enums.put(k1, v1);
    m_enums.put(k2, v2);
    m_enums.put(k3, v3);
    m_enums.put(k4, v4);
  }

  
  static final int T_CDATA = 1,

  
  T_URL = 2,

  
  
  T_AVT = 3,  

  
  T_PATTERN = 4,

  
  T_EXPR = 5,

  
  
  T_CHAR = 6,

  
  T_NUMBER = 7,

  
  T_YESNO = 8,

  
  
  T_QNAME = 9,

  
  
  T_QNAMES = 10,

  
  T_ENUM = 11,

  
  T_SIMPLEPATTERNLIST = 12,

  
  T_NMTOKEN = 13,

  
  T_STRINGLIST = 14,

  
  T_PREFIX_URLLIST = 15,
  
  
  T_ENUM_OR_PQNAME = 16,

  
  T_NCNAME = 17,
  
  
  T_AVT_QNAME = 18,
  
  
  
  T_QNAMES_RESOLVE_NULL = 19;
  

  
  static XSLTAttributeDef m_foreignAttr = new XSLTAttributeDef(""*"", ""*"",
                                            XSLTAttributeDef.T_CDATA,false, false, WARNING);

  
  static String S_FOREIGNATTR_SETTER = ""setForeignAttr"";

  
  private String m_namespace;

  
  String getNamespace()
  {
    return m_namespace;
  }

  
  private String m_name;

  
  String getName()
  {
    return m_name;
  }

  
  private int m_type;

  
  int getType()
  {
    return m_type;
  }

  
  private StringToIntTable m_enums;

  
  private int getEnum(String key)
  {
    return m_enums.get(key);
  }

 
  private String[] getEnumNames()
  {
    return m_enums.keys();
  }

  
  private String m_default;

  
  String getDefault()
  {
    return m_default;
  }

  
  void setDefault(String def)
  {
    m_default = def;
  }

  
  private boolean m_required;

  
  boolean getRequired()
  {
    return m_required;
  }

  
  private boolean m_supportsAVT;

  
  boolean getSupportsAVT()
  {
    return m_supportsAVT;
  }
  
  int m_errorType = this.WARNING;
  
  
  int getErrorType()
  {
    return m_errorType;
  }
  
  String m_setterString = null;

  
  public String getSetterMethodName()
  {

    if (null == m_setterString)
    {
      if (m_foreignAttr == this)
      {
        return S_FOREIGNATTR_SETTER;
      }
      else if (m_name.equals(""*""))
      {
        m_setterString = ""addLiteralResultAttribute"";

        return m_setterString;
      }

      StringBuffer outBuf = new StringBuffer();

      outBuf.append(""set"");

      if ((m_namespace != null)
              && m_namespace.equals(Constants.S_XMLNAMESPACEURI))
      {
        outBuf.append(""Xml"");
      }

      int n = m_name.length();

      for (int i = 0; i < n; i++)
      {
        char c = m_name.charAt(i);

        if ('-' == c)
        {
          i++;

          c = m_name.charAt(i);
          c = Character.toUpperCase(c);
        }
        else if (0 == i)
        {
          c = Character.toUpperCase(c);
        }

        outBuf.append(c);
      }

      m_setterString = outBuf.toString();
    }

    return m_setterString;
  }

  
  AVT processAVT(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    try
    {
      AVT avt = new AVT(handler, uri, name, rawName, value, owner);

      return avt;
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  Object processCDATA(StylesheetHandler handler, String uri, String name,
                      String rawName, String value, ElemTemplateElement owner)
                      throws org.xml.sax.SAXException
  {
  	if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	      return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }  		
  	} else {  	  	
	    return value;
  	}
  }

  
  Object processCHAR(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {
	if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	
		  
		  if ((avt.isSimple()) && (value.length() != 1)) {
		  	handleError(handler, XSLTErrorResources.INVALID_TCHAR, new Object[] {name, value},null);
            return null;
		  }	
	      return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }
	} else {    
	    if (value.length() != 1)
	    {
            handleError(handler, XSLTErrorResources.INVALID_TCHAR, new Object[] {name, value},null);
            return null;
	    }

	    return new Character(value.charAt(0));
	}
  }

  
  Object processENUM(StylesheetHandler handler, String uri, String name,
                     String rawName, String value, ElemTemplateElement owner)
                     throws org.xml.sax.SAXException
  {

	AVT avt = null;
	if (getSupportsAVT()) {
	    try
	    {
	      avt = new AVT(handler, uri, name, rawName, value, owner);
	      
	      
	      if (!avt.isSimple()) return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }
	}    
	
    int retVal = this.getEnum(value);
    
	if (retVal == StringToIntTable.INVALID_KEY) 
    {
       StringBuffer enumNamesList = getListOfEnums();
       handleError(handler, XSLTErrorResources.INVALID_ENUM,new Object[]{name, value, enumNamesList.toString() },null);
       return null;
    }

	if (getSupportsAVT()) return avt;
	else return new Integer(retVal);	

  }

  
  Object processENUM_OR_PQNAME(StylesheetHandler handler, String uri, String name,
                     String rawName, String value, ElemTemplateElement owner)
                     throws org.xml.sax.SAXException
  {

	Object objToReturn = null;
	
	if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	      if (!avt.isSimple()) return avt;
	      else objToReturn = avt;
	    }  
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }
	}    
	
    
  	int enum = this.getEnum(value);
    
    if (enum != StringToIntTable.INVALID_KEY) 
    {
        if (objToReturn == null) objToReturn = new Integer(enum);
    }

    
    else
    {
        try 
        {
			QName qname = new QName(value, handler, true);
            if (objToReturn == null) objToReturn = qname;	
	        
			if (qname.getPrefix() == null) {
	           StringBuffer enumNamesList = getListOfEnums();

 	           enumNamesList.append("" <qname-but-not-ncname>"");
               handleError(handler,XSLTErrorResources.INVALID_ENUM,new Object[]{name, value, enumNamesList.toString() },null); 
               return null;
        
	        }            
        }
        catch (IllegalArgumentException ie) 
        {
           StringBuffer enumNamesList = getListOfEnums();
           enumNamesList.append("" <qname-but-not-ncname>"");
           
           handleError(handler,XSLTErrorResources.INVALID_ENUM,new Object[]{name, value, enumNamesList.toString() },ie); 
           return null;

        }
        catch (RuntimeException re)
        {
           StringBuffer enumNamesList = getListOfEnums();
           enumNamesList.append("" <qname-but-not-ncname>"");

           handleError(handler,XSLTErrorResources.INVALID_ENUM,new Object[]{name, value, enumNamesList.toString() },re); 
           return null;
        }    
  	}
  	
  	return objToReturn;
  }

  
  Object processEXPR(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    try
    {
      XPath expr = handler.createXPath(value, owner);

      return expr;
    }
    catch (TransformerException te)
    {
      org.xml.sax.SAXException se = new org.xml.sax.SAXException(te);
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  Object processNMTOKEN(StylesheetHandler handler, String uri, String name,
                        String rawName, String value, ElemTemplateElement owner)
             throws org.xml.sax.SAXException
  {
  	
  	if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	
		  
		  if ((avt.isSimple()) && (!XMLChar.isValidNmtoken(value))) {
            handleError(handler,XSLTErrorResources.INVALID_NMTOKEN, new Object[] {name,value},null);
            return null;
		  }	
	      return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }  		
  	} else {
  		if (!XMLChar.isValidNmtoken(value)) {
            handleError(handler,XSLTErrorResources.INVALID_NMTOKEN, new Object[] {name,value},null);
            return null;
  		}
  	}	  			
    return value;
  }

  
  Object processPATTERN(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    try
    {
      XPath pattern = handler.createMatchPatternXPath(value, owner);

      return pattern;
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  Object processNUMBER(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {


	if (getSupportsAVT()) 
	{
		Double val;
		AVT avt = null;
	    try
	    {
	      avt = new AVT(handler, uri, name, rawName, value, owner);
	      
	      
	      if (avt.isSimple()) 
	      {
	      	val = Double.valueOf(value);
	      }
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    } 
	    catch (NumberFormatException nfe)
	    {
	     	handleError(handler,XSLTErrorResources.INVALID_NUMBER, new Object[] {name, value}, nfe);
            return null;
	    }
	    return avt;
	
	} 
	else
    {
	    try
	    {
	      return Double.valueOf(value);
	    }
	    catch (NumberFormatException nfe)
	    {
            handleError(handler,XSLTErrorResources.INVALID_NUMBER, new Object[] {name, value}, nfe);
            return null;
	    }
    }    
  }

  
  Object processQNAME(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

     try 
        {	
   	      QName qname = new QName(value, handler, true);
          return qname;
        }
        catch (IllegalArgumentException ie)
        {
            
            handleError(handler,XSLTErrorResources.INVALID_QNAME, new Object[] {name, value},ie);
            return null;
        }
        catch (RuntimeException re) {
            
            handleError(handler,XSLTErrorResources.INVALID_QNAME, new Object[] {name, value},re);
            return null;
        }
  	}
 

  
  Object processAVT_QNAME(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

       AVT avt = null;
       try
       {
          avt = new AVT(handler, uri, name, rawName, value, owner);
    
          
          if (avt.isSimple())
          {
             int indexOfNSSep = value.indexOf(':');

             if (indexOfNSSep >= 0) 
             {   
                  String prefix = value.substring(0, indexOfNSSep);
                  if (!XMLChar.isValidNCName(prefix))
                  {
                     handleError(handler,XSLTErrorResources.INVALID_QNAME,new Object[]{name,value },null);
                     return null;
                  }
             }
                 
             String localName =  (indexOfNSSep < 0)
                 ? value : value.substring(indexOfNSSep + 1); 
             
             if ((localName == null) || (localName.length() == 0) ||
                 (!XMLChar.isValidNCName(localName)))
             {    
                     handleError(handler,XSLTErrorResources.INVALID_QNAME,new Object[]{name,value },null );
                     return null;
             }
          }  
        }
        catch (TransformerException te)
        {
           
          throw new org.xml.sax.SAXException(te);
        } 
    
    return avt;
 }

  
  Object processNCNAME(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {
    
    if (getSupportsAVT()) 
    {
        AVT avt = null;
        try
        {
          avt = new AVT(handler, uri, name, rawName, value, owner);
    
          
          if ((avt.isSimple()) &&  (!XMLChar.isValidNCName(value))) 
          {
             handleError(handler,XSLTErrorResources.INVALID_NCNAME,new Object[] {name,value},null);
             return null;
          }      
          return avt;
        }
        catch (TransformerException te)
        {
           
          throw new org.xml.sax.SAXException(te);
        } 
        
    } else {
        if (!XMLChar.isValidNCName(value)) 
        {
            handleError(handler,XSLTErrorResources.INVALID_NCNAME,new Object[] {name,value},null);
            return null;
        }
        return value;
    }
 }

  
  Vector processQNAMES(
          StylesheetHandler handler, String uri, String name, String rawName, String value)
            throws org.xml.sax.SAXException
  {

    StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
    int nQNames = tokenizer.countTokens();
    Vector qnames = new Vector(nQNames);

    for (int i = 0; i < nQNames; i++)
    {
      
      qnames.addElement(new QName(tokenizer.nextToken(), handler));
    }

    return qnames;
  }

 
  final Vector processQNAMESRNU(StylesheetHandler handler, String uri,
    String name, String rawName, String value)
    throws org.xml.sax.SAXException
  {

    StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
    int nQNames = tokenizer.countTokens();
    Vector qnames = new Vector(nQNames);

    String defaultURI = handler.getNamespaceForPrefix("""");
    for (int i = 0; i < nQNames; i++)
    {
      String tok = tokenizer.nextToken();
      if (tok.indexOf(':') == -1) {
        qnames.addElement(new QName(defaultURI,tok));
      } else {
        qnames.addElement(new QName(tok, handler));
      }
    }
    return qnames;
  }

  
  Vector processSIMPLEPATTERNLIST(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    try
    {
      StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
      int nPatterns = tokenizer.countTokens();
      Vector patterns = new Vector(nPatterns);

      for (int i = 0; i < nPatterns; i++)
      {
        XPath pattern =
          handler.createMatchPatternXPath(tokenizer.nextToken(), owner);

        patterns.addElement(pattern);
      }

      return patterns;
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  StringVector processSTRINGLIST(StylesheetHandler handler, String uri,
                                 String name, String rawName, String value)
  {

    StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
    int nStrings = tokenizer.countTokens();
    StringVector strings = new StringVector(nStrings);

    for (int i = 0; i < nStrings; i++)
    {
      strings.addElement(tokenizer.nextToken());
    }

    return strings;
  }

  
  StringVector processPREFIX_URLLIST(
          StylesheetHandler handler, String uri, String name, String rawName, String value)
            throws org.xml.sax.SAXException
  {

    StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
    int nStrings = tokenizer.countTokens();
    StringVector strings = new StringVector(nStrings);

    for (int i = 0; i < nStrings; i++)
    {
      String prefix = tokenizer.nextToken();
      String url = handler.getNamespaceForPrefix(prefix);

      if (url != null)
        strings.addElement(url);
      else
        throw new org.xml.sax.SAXException(XSLMessages.createMessage(XSLTErrorResources.ER_CANT_RESOLVE_NSPREFIX, new Object[] {prefix}));
    
    }

    return strings;
  }

  
  Object processURL(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	
		  
		 
			   
			    
			    
		  
	      return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }  		
     } else {
    
    
    
     	
	    return value;
    }
  }

  
  private Boolean processYESNO(
          StylesheetHandler handler, String uri, String name, String rawName, String value)
            throws org.xml.sax.SAXException
  {

    
    if (!(value.equals(""yes"") || value.equals(""no"")))
    {
      handleError(handler, XSLTErrorResources.INVALID_BOOLEAN, new Object[] {name,value}, null);
      return null;
   }
 
     return new Boolean(value.equals(""yes"") ? true : false);
  }

  
  Object processValue(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    int type = getType();
    Object processedValue = null;

    switch (type)
    {
    case T_AVT :
      processedValue = processAVT(handler, uri, name, rawName, value, owner);
      break;
    case T_CDATA :
      processedValue = processCDATA(handler, uri, name, rawName, value, owner);
      break;
    case T_CHAR :
      processedValue = processCHAR(handler, uri, name, rawName, value, owner);
      break;
    case T_ENUM :
      processedValue = processENUM(handler, uri, name, rawName, value, owner);
      break;
    case T_EXPR :
      processedValue = processEXPR(handler, uri, name, rawName, value, owner);
      break;
    case T_NMTOKEN :
      processedValue = processNMTOKEN(handler, uri, name, rawName, value, owner);
      break;
    case T_PATTERN :
      processedValue = processPATTERN(handler, uri, name, rawName, value, owner);
      break;
    case T_NUMBER :
      processedValue = processNUMBER(handler, uri, name, rawName, value, owner);
      break;
    case T_QNAME :
      processedValue = processQNAME(handler, uri, name, rawName, value, owner);
      break;
    case T_QNAMES :
      processedValue = processQNAMES(handler, uri, name, rawName, value);
      break;
	case T_QNAMES_RESOLVE_NULL:
      processedValue = processQNAMESRNU(handler, uri, name, rawName, value);
      break;
    case T_SIMPLEPATTERNLIST :
      processedValue = processSIMPLEPATTERNLIST(handler, uri, name, rawName,
                                                value, owner);
      break;
    case T_URL :
      processedValue = processURL(handler, uri, name, rawName, value, owner);
      break;
    case T_YESNO :
      processedValue = processYESNO(handler, uri, name, rawName, value);
      break;
    case T_STRINGLIST :
      processedValue = processSTRINGLIST(handler, uri, name, rawName, value);
      break;
    case T_PREFIX_URLLIST :
      processedValue = processPREFIX_URLLIST(handler, uri, name, rawName,
                                             value);
      break;
    case T_ENUM_OR_PQNAME :
    	processedValue = processENUM_OR_PQNAME(handler, uri, name, rawName, value, owner);
    	break;
    case T_NCNAME :
        processedValue = processNCNAME(handler, uri, name, rawName, value, owner);
        break;
    case T_AVT_QNAME :
        processedValue = processAVT_QNAME(handler, uri, name, rawName, value, owner);
        break;
    default :
    }

    return processedValue;
  }

  
  void setDefAttrValue(StylesheetHandler handler, ElemTemplateElement elem)
          throws org.xml.sax.SAXException
  {
    setAttrValue(handler, this.getNamespace(), this.getName(),
                 this.getName(), this.getDefault(), elem);
  }

  
  private Class getPrimativeClass(Object obj)
  {

    if (obj instanceof XPath)
      return XPath.class;

    Class cl = obj.getClass();

    if (cl == Double.class)
    {
      cl = double.class;
    }

    if (cl == Float.class)
    {
      cl = float.class;
    }
    else if (cl == Boolean.class)
    {
      cl = boolean.class;
    }
    else if (cl == Byte.class)
    {
      cl = byte.class;
    }
    else if (cl == Character.class)
    {
      cl = char.class;
    }
    else if (cl == Short.class)
    {
      cl = short.class;
    }
    else if (cl == Integer.class)
    {
      cl = int.class;
    }
    else if (cl == Long.class)
    {
      cl = long.class;
    }

    return cl;
  }
  
  
  private StringBuffer getListOfEnums() 
  {
     StringBuffer enumNamesList = new StringBuffer();            
     String [] enumValues = this.getEnumNames();

     for (int i = 0; i < enumValues.length; i++)
     {
        if (i > 0)
        {
           enumNamesList.append(' ');
        }
        enumNamesList.append(enumValues[i]);
    }        
    return enumNamesList;
  }

  
  boolean setAttrValue(
          StylesheetHandler handler, String attrUri, String attrLocalName, 
          String attrRawName, String attrValue, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {
    if(attrRawName.equals(""xmlns"") || attrRawName.startsWith(""xmlns:""))
      return true;
      
    String setterString = getSetterMethodName();

    
    
    if (null != setterString)
    {
      try
      {
        Method meth;
        Object[] args;

        if(setterString.equals(S_FOREIGNATTR_SETTER))
        {
          
          if( attrUri==null) attrUri="""";
          
          Class sclass = attrUri.getClass();
          Class[] argTypes = new Class[]{ sclass, sclass,
                                      sclass, sclass };
  
          meth = elem.getClass().getMethod(setterString, argTypes);
  
          args = new Object[]{ attrUri, attrLocalName,
                                      attrRawName, attrValue };
        }
        else
        {
          Object value = processValue(handler, attrUri, attrLocalName,
                                      attrRawName, attrValue, elem);
          
          
          if (null == value) return false;
                                      
          
          Class[] argTypes = new Class[]{ getPrimativeClass(value) };
  
          try
          {
            meth = elem.getClass().getMethod(setterString, argTypes);
          }
          catch (NoSuchMethodException nsme)
          {
            Class cl = ((Object) value).getClass();
  
            
            argTypes[0] = cl;
            meth = elem.getClass().getMethod(setterString, argTypes);
          }
  
          args = new Object[]{ value };
        }

        meth.invoke(elem, args);
      }
      catch (NoSuchMethodException nsme)
      {
        if (!setterString.equals(S_FOREIGNATTR_SETTER)) 
        {
          handler.error(XSLTErrorResources.ER_FAILED_CALLING_METHOD, new Object[]{setterString}, nsme);
          return false;
        }
      }
      catch (IllegalAccessException iae)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CALLING_METHOD, new Object[]{setterString}, iae);
        return false;
      }
      catch (InvocationTargetException nsme)
      {
        handleError(handler, XSLTErrorResources.WG_ILLEGAL_ATTRIBUTE_VALUE,
            new Object[]{ Constants.ATTRNAME_NAME, getName()}, nsme);
        return false;
      }
    }
    
    return true;
  }
  
  private void handleError(StylesheetHandler handler, String msg, Object [] args, Exception exc) throws org.xml.sax.SAXException
  {
    switch (getErrorType()) 
    {
        case (FATAL):
        case (ERROR):
                handler.error(msg, args, exc);          
                break;
        case (WARNING):
                handler.warn(msg, args);       
        default: break;
    }
  }
}
"
org.apache.xalan.xsltc.compiler.LiteralExpr,8,3,0,16,18,4,5,11,5,0.571428571,75,1.0,0,0.922077922,0.325,2,8,8.125,1,0.75,0,"


package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class LiteralExpr extends Expression {
    private final String _value;
    private final String _namespace;

    
    public LiteralExpr(String value) {
	_value = value;
	_namespace = null;
    }

    
    public LiteralExpr(String value, String namespace) {
	_value = value;
	_namespace = namespace.equals(Constants.EMPTYSTRING) ? null : namespace;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _type = Type.String;
    }

    public String toString() {
	return ""literal-expr("" + _value + ')';
    }

    protected boolean contextDependent() {
	return false;
    }

    protected String getValue() {
	return _value;
    }

    protected String getNamespace() {
	return _namespace;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }
}
"
org.apache.xalan.xsltc.compiler.Text,10,3,0,19,33,0,6,15,7,0.583333333,262,1.0,0,0.875,0.266666667,2,6,24.8,10,2.1,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Util;

final class Text extends Instruction {

    private String _text;
    private boolean _escaping = true;
    private boolean _ignore = false;
    private boolean _textElement = false;

    
    public Text() {
	_textElement = true;
    }

    
    public Text(String text) {
	_text = text;
    }

    
    protected String getText() {
	return _text;
    }

    
    protected void setText(String text) {
	if (_text == null)
	    _text = text;
	else
	    _text = _text + text;
    }

    public void display(int indent) {
	indent(indent);
	Util.println(""Text"");
	indent(indent + IndentIncrement);
	Util.println(_text);
    }
		
    public void parseContents(Parser parser) {
        final String str = getAttribute(""disable-output-escaping"");
	if ((str != null) && (str.equals(""yes""))) _escaping = false;

	parseChildren(parser);

	if (_text == null) {
	    if (_textElement) {
		_text = EMPTYSTRING;
	    }
	    else {
		_ignore = true;
	    }
	}
	else if (_textElement) {
	    if (_text.length() == 0) _ignore = true;
	}
	else if (getParent() instanceof LiteralElement) {
	    LiteralElement element = (LiteralElement)getParent();
	    String space = element.getAttribute(""xml:space"");
	    if ((space == null) || (!space.equals(""preserve"")))
		if (_text.trim().length() == 0) _ignore = true;
	}
	else {
	    if (_text.trim().length() == 0) _ignore = true;
	}
    }

    public void ignore() {
	_ignore = true;
    }

    public boolean isTextElement() {
	return _textElement;
    }

    protected boolean contextDependent() {
	return false;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (!_ignore) {
	    
	    final int esc = cpg.addInterfaceMethodref(OUTPUT_HANDLER,
						      ""setEscaping"", ""(Z)Z"");
	    if (!_escaping) {
		il.append(methodGen.loadHandler());
		il.append(new PUSH(cpg, false));
		il.append(new INVOKEINTERFACE(esc, 2));
	    }

	    final int characters = cpg.addInterfaceMethodref(OUTPUT_HANDLER,
							     ""characters"",
							     ""("" + STRING_SIG + "")V"");
	    il.append(methodGen.loadHandler());
	    il.append(new PUSH(cpg, _text));
	    il.append(new INVOKEINTERFACE(characters, 2));

	    
	    
	    if (!_escaping) {
		il.append(methodGen.loadHandler());
		il.append(SWAP);
		il.append(new INVOKEINTERFACE(esc, 2));
		il.append(POP);
	    }
	}
	translateContents(classGen, methodGen);
    }
}
"
org.apache.xml.utils.BoolStack,13,1,0,9,16,0,9,0,12,0.361111111,160,1.0,0,0.0,0.41025641,0,0,11.07692308,2,1.2308,1,"
package org.apache.xml.utils;



public final class BoolStack implements Cloneable
{

  
  private boolean m_values[];

  
  private int m_allocatedSize;

  
  private int m_index;

  
  public BoolStack()
  {
    this(32);
  }

  
  public BoolStack(int size)
  {

    m_allocatedSize = size;
    m_values = new boolean[size];
    m_index = -1;
  }

  
  public final int size()
  {
    return m_index + 1;
  }

  
  public final boolean push(boolean val)
  {

    if (m_index == m_allocatedSize - 1)
      grow();

    return (m_values[++m_index] = val);
  }

  
  public final boolean pop()
  {
    return m_values[m_index--];
  }

  
  public final boolean popAndTop()
  {

    m_index--;

    return (m_index >= 0) ? m_values[m_index] : false;
  }

  
  public final void setTop(boolean b)
  {
    m_values[m_index] = b;
  }

  
  public final boolean peek()
  {
    return m_values[m_index];
  }

  
  public final boolean peekOrFalse()
  {
    return (m_index > -1) ? m_values[m_index] : false;
  }

  
  public final boolean peekOrTrue()
  {
    return (m_index > -1) ? m_values[m_index] : true;
  }

  
  public boolean isEmpty()
  {
    return (m_index == -1);
  }

  
  private void grow()
  {

    m_allocatedSize *= 2;

    boolean newVector[] = new boolean[m_allocatedSize];

    System.arraycopy(m_values, 0, newVector, 0, m_index + 1);

    m_values = newVector;
  }
  
  public Object clone() 
    throws CloneNotSupportedException
  {
    return super.clone();
  }

}
"
org.apache.xpath.functions.FuncDoclocation,2,5,0,5,9,1,0,5,2,2.0,43,0.0,0,0.982142857,0.75,2,7,20.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncDoclocation extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int whereNode = getArg0AsNode(xctxt);
    String fileLocation = null;

    if (DTM.NULL != whereNode)
    {
      DTM dtm = xctxt.getDTM(whereNode);
      
      
      if (DTM.DOCUMENT_FRAGMENT_NODE ==  dtm.getNodeType(whereNode))
      {
        whereNode = dtm.getFirstChild(whereNode);
      }

      if (DTM.NULL != whereNode)
      {        
        fileLocation = dtm.getDocumentBaseURI();


      }
    }

    return new XString((null != fileLocation) ? fileLocation : """");
  }
}
"
org.apache.xalan.processor.ProcessorImport,3,5,0,2,4,3,1,1,0,2.0,10,0.0,0,0.990950226,1.0,1,1,2.333333333,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.res.XSLTErrorResources;


class ProcessorImport extends ProcessorInclude
{

  
  protected int getStylesheetType()
  {
    return StylesheetHandler.STYPE_IMPORT;
  }

  
  protected String getStylesheetInclErr()
  {
    return XSLTErrorResources.ER_IMPORTING_ITSELF;
  }

}
"
org.apache.xalan.xsltc.dom.BitArray,17,1,0,2,24,0,2,0,16,0.6875,622,0.833333333,0,0.0,0.291666667,0,0,34.88235294,10,2.2353,0,"

package org.apache.xalan.xsltc.dom;

import java.io.Externalizable;
import java.io.IOException;
import java.io.ObjectInput;
import java.io.ObjectOutput;

import org.apache.xml.dtm.DTMAxisIterator;


public class BitArray implements Externalizable {

    private int[] _bits;
    private int   _bitSize;
    private int   _intSize;
    private int   _mask;

    
    
    private final static int[] _masks = {
	0x80000000, 0x40000000, 0x20000000, 0x10000000,
	0x08000000, 0x04000000, 0x02000000, 0x01000000,
	0x00800000, 0x00400000, 0x00200000, 0x00100000,
	0x00080000, 0x00040000, 0x00020000, 0x00010000,
	0x00008000, 0x00004000, 0x00002000, 0x00001000,
	0x00000800, 0x00000400, 0x00000200, 0x00000100,
	0x00000080, 0x00000040, 0x00000020, 0x00000010,
	0x00000008, 0x00000004, 0x00000002, 0x00000001 };

    private final static boolean DEBUG_ASSERTIONS = false;
    
    
    public BitArray() {
	this(32);
    }

    public BitArray(int size) {        
        if (size < 32) size = 32;
        _bitSize = size;
        _intSize = (_bitSize >>> 5) + 1;
        _bits = new int[_intSize + 1];
    }

    public BitArray(int size, int[] bits) {
	if (size < 32) size = 32;
	_bitSize = size;
	_intSize = (_bitSize >>> 5) + 1;
	_bits = bits;
    }

        
    public void setMask(int mask) {
	_mask = mask;
    }

    
    public int getMask() {
	return(_mask);
    }

    
    public final int size() {
	return(_bitSize);
    }

    
    public final boolean getBit(int bit) {
        if (DEBUG_ASSERTIONS) {
            if (bit >= _bitSize) {
                throw new Error(
                             ""Programmer's assertion in  BitArray.getBit"");
            }
        }

        return((_bits[bit>>>5] & _masks[bit%32]) != 0);
    }

    
    public final int getNextBit(int startBit) {
        for (int i = (startBit >>> 5) ; i<=_intSize; i++) {
            int bits = _bits[i];
            if (bits != 0) {
                for (int b = (startBit % 32); b<32; b++) {
                    if ((bits & _masks[b]) != 0) {
                        return((i << 5) + b);
                    }
                }
            }
            startBit = 0;
        }
        return(DTMAxisIterator.END);
    }

    
    private int _pos = Integer.MAX_VALUE;
    private int _node = 0;
    private int _int = 0;
    private int _bit = 0;

    public final int getBitNumber(int pos) {

	
	if (pos == _pos) return(_node);
	
	
	
	if (pos < _pos) {
	    _int = _bit = _pos = 0;
	}

	
	for ( ; _int <= _intSize; _int++) {
	    int bits = _bits[_int];
	    if (bits != 0) { 
		for ( ; _bit < 32; _bit++) {
		    if ((bits & _masks[_bit]) != 0) {
			if (++_pos == pos) {
			    _node = ((_int << 5) + _bit) - 1;
			    return (_node);
			}
		    }
		}
		_bit = 0;
	    }
	}
	return(0);
    }

    
    public final int[] data() {
	return(_bits);
    }

    int _first = Integer.MAX_VALUE; 
    int _last  = Integer.MIN_VALUE; 

    
    public final void setBit(int bit) {
        if (DEBUG_ASSERTIONS) {
            if (bit >= _bitSize) {
                throw new Error(
                             ""Programmer's assertion in  BitArray.getBit"");
            }
        }

        if (bit >= _bitSize) return;
        final int i = (bit >>> 5);
        if (i < _first) _first = i;
        if (i > _last) _last = i;
        _bits[i] |= _masks[bit % 32];
    }

    
    public final BitArray merge(BitArray other) {
	
	if (_last == -1) {
	    _bits = other._bits;
	}
	
	else if (other._last != -1) {
	    int start = (_first < other._first) ? _first : other._first;
	    int stop  = (_last > other._last) ? _last : other._last;

	    
	    if (other._intSize > _intSize) {
		if (stop > _intSize) stop = _intSize;
		for (int i=start; i<=stop; i++)
		    other._bits[i] |= _bits[i];
		_bits = other._bits;
	    }
	    
	    else {
		if (stop > other._intSize) stop = other._intSize;
		for (int i=start; i<=stop; i++)
		    _bits[i] |= other._bits[i];
	    }
	}
	return(this);
    }

    
    public final void resize(int newSize) {
	if (newSize > _bitSize) {
	    _intSize = (newSize >>> 5) + 1;
	    final int[] newBits = new int[_intSize + 1];
	    System.arraycopy(_bits, 0, newBits, 0, (_bitSize>>>5) + 1);
	    _bits = newBits;
	    _bitSize = newSize;
	}
    }

    public BitArray cloneArray() {
	return(new BitArray(_intSize, _bits));
    }

    public void writeExternal(ObjectOutput out) throws IOException {
	out.writeInt(_bitSize);
	out.writeInt(_mask);
	out.writeObject(_bits);
	out.flush();
    }

    
    public void readExternal(ObjectInput in)
	throws IOException, ClassNotFoundException {
	_bitSize = in.readInt();
	_intSize = (_bitSize >>> 5) + 1;
	_mask    = in.readInt();
	_bits    = (int[])in.readObject();
    }

}
"
org.apache.xalan.templates.ElemMessage,6,3,0,5,17,3,0,5,6,0.4,60,1.0,0,0.975124378,0.444444444,2,4,8.833333333,1,0.8333,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;


public class ElemMessage extends ElemTemplateElement
{

  
  private boolean m_terminate = Constants.ATTRVAL_NO;  

  
  public void setTerminate(boolean v)
  {
    m_terminate = v;
  }

  
  public boolean getTerminate()
  {
    return m_terminate;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_MESSAGE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_MESSAGE_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    String data = transformer.transformToString(this);

    transformer.getMsgMgr().message(this, data, m_terminate);
    
    if(m_terminate)
      transformer.getErrorListener().fatalError(new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_STYLESHEET_DIRECTED_TERMINATION, null))); 
    
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this); 
  }
}
"
org.apache.xalan.xsltc.compiler.RoundCall,2,4,0,15,13,1,0,15,2,2.0,61,0.0,0,0.989690722,0.6,2,4,29.5,1,0.5,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.IFNE;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;

final class RoundCall extends FunctionCall {

    public RoundCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	argument().translate(classGen, methodGen);
	il.append(DUP2);

	
	il.append(new INVOKESTATIC(cpg.addMethodref(""java.lang.Double"",
						    ""isNaN"", ""(D)Z"")));
	final BranchHandle skip = il.append(new IFNE(null));
	il.append(new INVOKESTATIC(cpg.addMethodref(MATH_CLASS,
						    ""round"", ""(D)J"")));
	il.append(L2D);
	skip.setTarget(il.append(NOP));
    }
}
"
org.apache.xalan.transformer.ResultNameSpace,1,1,0,0,2,0,0,0,1,2.0,16,0.0,1,0.0,1.0,0,0,12.0,0,0.0,1,"
package org.apache.xalan.transformer;


public class ResultNameSpace
{

  
  public ResultNameSpace m_next = null;

  
  public String m_prefix;

  
  public String m_uri;  

  
  public ResultNameSpace(String prefix, String uri)
  {
    m_prefix = prefix;
    m_uri = uri;
  }
}
"
org.apache.xpath.operations.Gte,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class Gte extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.greaterThanOrEqual(right)
           ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.xsltc.trax.XSLTCSource,9,1,0,9,34,0,1,8,8,0.458333333,206,1.0,1,0.0,0.416666667,0,0,21.55555556,2,0.8889,1,"


package org.apache.xalan.xsltc.trax;

import java.io.File;
import java.io.IOException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.Source;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.dom.DOMBuilder;
import org.apache.xalan.xsltc.dom.SAXImpl;
import org.apache.xalan.xsltc.dom.XSLTCDTMManager;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMManager;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

public final class XSLTCSource implements Source {

    private String     _systemId = null;
    private DOM        _dom      = null;

    private final static String LEXICAL_HANDLER_PROPERTY =
	""http:

    
    public XSLTCSource(int size) 
    {
      XSLTCDTMManager dtmManager =
                XSLTCDTMManager.newInstance();
      int dtmPos = dtmManager.getFirstFreeDTMID();
      int documentID = dtmPos << DTMManager.IDENT_DTM_NODE_BITS;
      _dom = (DOM)new SAXImpl(dtmManager, this, documentID, null,
                              null, false, size, true);
      dtmManager.addDTM((DTM)_dom, dtmPos);
    }

    
    public XSLTCSource() 
    {
      XSLTCDTMManager dtmManager =
                XSLTCDTMManager.newInstance();
      int dtmPos = dtmManager.getFirstFreeDTMID();
      int documentID = dtmPos << DTMManager.IDENT_DTM_NODE_BITS;
      _dom = (DOM)new SAXImpl(dtmManager, this, documentID, null,
                              null, false, true);
      dtmManager.addDTM((DTM)_dom, dtmPos);
    }

    
    public void setSystemId(String systemId) {
	if ((new File(systemId)).exists())
	    _systemId = ""file:""+systemId;
	else
	    _systemId = systemId;

        ((SAXImpl)_dom).setDocumentURI(_systemId);
    }

    
    public String getSystemId() {
	return(_systemId);
    }

    
    public void build(XMLReader reader, String systemId) throws SAXException {
	try {
	    
	    if ((systemId == null) && (_systemId == null)) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.XSLTC_SOURCE_ERR);
		throw new SAXException(err.toString());
	    }

	    
	    if (systemId == null) systemId = _systemId;
	    setSystemId(systemId);

	    
	    
	    
	    InputSource input = new InputSource(systemId);

	    DOMBuilder builder;
        
            
            
            
            builder = ((SAXImpl)_dom).getBuilder();

	    
	    reader.setContentHandler(builder);
	    reader.setDTDHandler(builder);
	    try {
		reader.setProperty(LEXICAL_HANDLER_PROPERTY, builder);
	    }
	    catch (SAXException e) {
		
	    }

	    
	    reader.parse(input);
	}
	catch (IOException e) {
	    throw new SAXException(e);
	}
    }

    
    public void build(String systemId) throws SAXException {
	try {
	    
	    final SAXParserFactory factory = SAXParserFactory.newInstance();
	    final SAXParser parser = factory.newSAXParser();
	    final XMLReader reader = parser.getXMLReader();

	    build(reader, systemId);
	}
	catch (ParserConfigurationException e) {
	    throw new SAXException(e);
	}
    }

    
    public void build(XMLReader reader) throws SAXException {
	build(reader, _systemId);
    }

    
    public void build() throws SAXException {
	build(_systemId);
    }    

    
    protected DOM getDOM() {
	return(_dom);
    }
}
"
org.apache.xalan.templates.XUnresolvedVariable,6,3,0,7,23,9,1,7,6,0.833333333,134,1.0,1,0.934210526,0.361111111,2,12,20.33333333,1,0.8333,0,"
package org.apache.xalan.templates;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;


public class XUnresolvedVariable extends XObject
{  
  
  transient private int m_context;
  
  
  transient private TransformerImpl m_transformer;
  
  
  transient private int m_varStackPos = -1;

  
  transient private int m_varStackContext;
  
  
  private boolean m_isGlobal;
  
  
  transient private boolean m_doneEval = true;
  
  
  public XUnresolvedVariable(ElemVariable obj, int sourceNode, 
                             TransformerImpl transformer,
                             int varStackPos, int varStackContext,
                             boolean isGlobal)
  {
    super(obj);
    m_context = sourceNode;
    m_transformer = transformer;
    
    
    
    m_varStackPos = varStackPos;
    
    
    m_varStackContext = varStackContext;
    
    m_isGlobal = isGlobal;
  }
    
  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    if (!m_doneEval) 
    {
      this.m_transformer.getMsgMgr().error      
        (xctxt.getSAXLocator(), XSLTErrorResources.ER_REFERENCING_ITSELF, 
          new Object[]{((ElemVariable)this.object()).getName().getLocalName()}); 
    }
    VariableStack vars = xctxt.getVarStack();
    
    
    int currentFrame = vars.getStackFrame();
    
   

    ElemVariable velem = (ElemVariable)m_obj;
    try
    {
      m_doneEval = false;
      if(-1 != velem.m_frameSize)
      	vars.link(velem.m_frameSize);
      XObject var = velem.getValue(m_transformer, m_context);
      m_doneEval = true;
      return var;
    }
    finally
    {
      
      
      
      if(-1 != velem.m_frameSize)
	  	vars.unlink(currentFrame);
    }
  }
  
  
  public void setVarStackPos(int top)
  {
    m_varStackPos = top;
  }

  
  public void setVarStackContext(int bottom)
  {
    m_varStackContext = bottom;
  }
  
  
  public int getType()
  {
    return CLASS_UNRESOLVEDVARIABLE;
  }
  
  
  public String getTypeString()
  {
    return ""XUnresolvedVariable ("" + object().getClass().getName() + "")"";
  }


}
"
org.apache.xml.serializer.CharInfo,8,1,0,7,51,14,3,4,4,0.80952381,419,0.333333333,1,0.0,0.619047619,0,0,50.25,6,1.375,2,"
package org.apache.xml.serializer;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.BitSet;
import java.util.Hashtable;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.Enumeration;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.CharKey;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.SystemIDResolver;

public class CharInfo
{

    
    BitSet m_specialsMap = new BitSet(65535);

    
    private Hashtable m_charToEntityRef = new Hashtable();

    
    public static String HTML_ENTITIES_RESOURCE = ""org.apache.xml.serializer.HTMLEntities"";

    
    public static String XML_ENTITIES_RESOURCE = ""org.apache.xml.serializer.XMLEntities"";

    
    public static final char S_LINEFEED = 0x0A;

    
    public static char S_CARRIAGERETURN = 0x0D;

    
    public CharInfo(String entitiesResource)
    {
        PropertyResourceBundle entities;
        InputStream is = null;
        BufferedReader reader = null;
        int index;
        String name;
        String value;
        int code;
        String line;

        
        
        
        
        
        
        
        entities = loadEntitiesResource(entitiesResource);
        if (null != entities) {
            Enumeration enum = entities.getKeys();
            while (enum.hasMoreElements()){
                name = (String) enum.nextElement();
                value = entities.getString(name);
                code = Integer.parseInt(value);
                defineEntity(name, (char) code);
            }
            m_specialsMap.set(S_LINEFEED);
            m_specialsMap.set(S_CARRIAGERETURN);
        } else {
            
            
            try {
                try {
                    
                    
                    
                    
                    ClassLoader cl = CharInfo.class.getClassLoader();

                    if (cl == null) {
                        is = ClassLoader.getSystemResourceAsStream(
                                                             entitiesResource);
                    } else {
                        is = cl.getResourceAsStream(entitiesResource);
                    }
                } catch (Exception e) { }

                if (is == null) {
                    is = CharInfo.class.getResourceAsStream(entitiesResource);
                }

                if (is == null) {
                    URL url = new URL(entitiesResource);

                    is = url.openStream();
                }

                if (is == null) {
                    throw new RuntimeException(
                        XMLMessages.createXMLMessage(
                            XMLErrorResources.ER_RESOURCE_COULD_NOT_FIND,
                            new Object[] {entitiesResource, entitiesResource}));
                }

                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                
                try {
                    reader = new BufferedReader(new InputStreamReader(is,
                                                                      ""UTF-8""));
                } catch (java.io.UnsupportedEncodingException e) {
                    reader = new BufferedReader(new InputStreamReader(is));
                }

                line = reader.readLine();

                while (line != null) {
                    if (line.length() == 0 || line.charAt(0) == '#') {
                        line = reader.readLine();

                        continue;
                    }

                    index = line.indexOf(' ');

                    if (index > 1) {
                        name = line.substring(0, index);

                        ++index;

                        if (index < line.length()) {
                            value = line.substring(index);
                            index = value.indexOf(' ');

                            if (index > 0) {
                                value = value.substring(0, index);
                            }

                            code = Integer.parseInt(value);

                            defineEntity(name, (char) code);
                        }
                    }

                    line = reader.readLine();
                }

                is.close();
                m_specialsMap.set(S_LINEFEED);
                m_specialsMap.set(S_CARRIAGERETURN);
            } catch (Exception except) {
                throw new RuntimeException(
                    XMLMessages.createXMLMessage(
                        XMLErrorResources.ER_RESOURCE_COULD_NOT_LOAD,
                        new Object[] { entitiesResource,
                                       except.toString(),
                                       entitiesResource,
                                       except.toString()}));
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (Exception except) { }
                }
            }
        }
    }

    
    protected void defineEntity(String name, char value)
    {
        CharKey character = new CharKey(value);

        m_charToEntityRef.put(character, name);
        m_specialsMap.set(value);
    }

    private CharKey m_charKey = new CharKey();

    
    synchronized public String getEntityNameForChar(char value)
    {
        
        m_charKey.setChar(value);
        return (String) m_charToEntityRef.get(m_charKey);
    }

    
    public boolean isSpecial(char value)
    {
        return m_specialsMap.get(value);
    }

    
    private static Hashtable m_getCharInfo_cache = null;

    
    public static CharInfo getCharInfo(String entitiesFileName)
    {
        CharInfo retobj = null;
        if (null == m_getCharInfo_cache)
        {
            
            synchronized (XML_ENTITIES_RESOURCE)
            {
                if (null == m_getCharInfo_cache) 
                    m_getCharInfo_cache = new Hashtable();
            }
        }
        else
        {
            
            retobj = (CharInfo) m_getCharInfo_cache.get(entitiesFileName);
        }
        if (retobj == null)
        {
            
            try
            {
                retobj = new CharInfo(entitiesFileName);
                m_getCharInfo_cache.put(entitiesFileName, retobj);
            }
            catch (Exception e)
            {
                retobj = null;
            }
        }
        if (null == retobj)
        {
            String absoluteEntitiesFileName;

            if (entitiesFileName.indexOf(':') < 0)
            {
                absoluteEntitiesFileName =
                    SystemIDResolver.getAbsoluteURIFromRelative(
                        entitiesFileName);
            }
            else
            {
                try
                {
                    absoluteEntitiesFileName =
                        SystemIDResolver.getAbsoluteURI(entitiesFileName, null);
                }
                catch (javax.xml.transform.TransformerException te)
                {
                    throw new org.apache.xml.utils.WrappedRuntimeException(te);
                }
            }
            retobj = new CharInfo(absoluteEntitiesFileName);
            m_getCharInfo_cache.put(entitiesFileName, retobj);
        }
        return retobj;
    }
    

        private PropertyResourceBundle loadEntitiesResource(String baseName)
                                throws MissingResourceException
        {    
                try
                {
                        Locale locale = Locale.getDefault();
                        java.lang.ClassLoader loader = this.getClass().getClassLoader(); 
                        return (PropertyResourceBundle)PropertyResourceBundle.getBundle(baseName);
                }
                catch (MissingResourceException e)
                {
                        return null;
                }
        }
    
}
"
org.apache.xml.dtm.ref.DTMNodeListBase,3,1,3,3,4,3,3,0,3,2.0,10,0.0,0,0.0,0.666666667,0,0,2.333333333,1,0.6667,0,"
package org.apache.xml.dtm.ref;
import org.w3c.dom.Node;


public class DTMNodeListBase implements org.w3c.dom.NodeList {
    public DTMNodeListBase() {
    }

    
    

    
    public Node item(int index) {
        return null;
    }

    
    public int getLength() {
        return 0;
    }
}
"
org.apache.xalan.transformer.Counter,3,1,0,5,8,0,1,4,0,0.833333333,84,0.0,2,0.0,0.466666667,0,0,25.0,4,2.0,1,"
package org.apache.xalan.transformer;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.ElemNumber;
import org.apache.xml.dtm.DTM;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPathContext;


public class Counter
{

  
  static final int MAXCOUNTNODES = 500;

  
  int m_countNodesStartCount = 0;

  
  NodeSetDTM m_countNodes;

  
  int m_fromNode = DTM.NULL;

  
  ElemNumber m_numberElem;

  
  int m_countResult;

  
  Counter(ElemNumber numberElem, NodeSetDTM countNodes) throws TransformerException
  {
    m_countNodes = countNodes;
    m_numberElem = numberElem;
  }

  

  
  int getPreviouslyCounted(XPathContext support, int node)
  {

    int n = m_countNodes.size();

    m_countResult = 0;

    for (int i = n - 1; i >= 0; i--)
    {
      int countedNode = m_countNodes.elementAt(i);

      if (node == countedNode)
      {

        
        
        m_countResult = i + 1 + m_countNodesStartCount;

        break;
      }
      
      DTM dtm = support.getDTM(countedNode);

      
      
      if (dtm.isNodeAfter(countedNode, node))
        break;
    }

    return m_countResult;
  }

  
  int getLast()
  {

    int size = m_countNodes.size();

    return (size > 0) ? m_countNodes.elementAt(size - 1) : DTM.NULL;
  }
}
"
org.apache.xalan.xsltc.compiler.NotCall,3,4,0,14,12,3,1,13,3,2.0,56,0.0,0,0.979591837,0.6,2,6,17.66666667,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;

final class NotCall extends FunctionCall {
    public NotCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	argument().translate(classGen, methodGen);
	il.append(ICONST_1);
	il.append(IXOR);
    }

    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	final Expression exp = argument();
	exp.translateDesynthesized(classGen, methodGen);
	final BranchHandle gotoh = il.append(new GOTO(null));
	_trueList = exp._falseList; 	
	_falseList = exp._trueList;
	_falseList.add(gotoh);
    }
}
"
org.apache.xalan.templates.ElemUse,7,3,4,9,16,0,4,6,6,0.166666667,119,1.0,1,0.97029703,0.428571429,0,0,15.85714286,2,1.0,2,"
package org.apache.xalan.templates;

import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;


public class ElemUse extends ElemTemplateElement
{

  
  private QName m_attributeSetsNames[] = null;

  
  public void setUseAttributeSets(Vector v)
  {

    int n = v.size();

    m_attributeSetsNames = new QName[n];

    for (int i = 0; i < n; i++)
    {
      m_attributeSetsNames[i] = (QName) v.elementAt(i);
    }
  }

  
  public void setUseAttributeSets(QName[] v)
  {
    m_attributeSetsNames = v;
  }

  
  public QName[] getUseAttributeSets()
  {
    return m_attributeSetsNames;
  }
  
  
  public void applyAttrSets(
          TransformerImpl transformer, StylesheetRoot stylesheet)
            throws TransformerException
  {
    applyAttrSets(transformer, stylesheet, m_attributeSetsNames);
  }

  
  private void applyAttrSets(
          TransformerImpl transformer, StylesheetRoot stylesheet, QName attributeSetsNames[])
            throws TransformerException
  {

    if (null != attributeSetsNames)
    {
      int nNames = attributeSetsNames.length;

      for (int i = 0; i < nNames; i++)
      {
        QName qname = attributeSetsNames[i];
        Vector attrSets = stylesheet.getAttributeSetComposed(qname);

        if (null != attrSets)
        {
          int nSets = attrSets.size();

          
          
          for (int k = nSets-1; k >= 0 ; k--)
          {
            ElemAttributeSet attrSet =
              (ElemAttributeSet) attrSets.elementAt(k);

            attrSet.execute(transformer);
          }
        }
      }
    }
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    if (null != m_attributeSetsNames)
    {
      applyAttrSets(transformer, getStylesheetRoot(),
                    m_attributeSetsNames);
    }
    
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this); 
  }
}
"
org.apache.xpath.functions.Function3Args,9,5,4,12,23,6,5,8,8,0.375,124,0.0,1,0.875,0.355555556,4,15,12.66666667,6,1.7778,1,"
package org.apache.xpath.functions;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;


public class Function3Args extends Function2Args
{

  
  Expression m_arg2;

  
  public Expression getArg2()
  {
    return m_arg2;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    if(null != m_arg2)
      m_arg2.fixupVariables(vars, globalsSize);
  }

  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {

    if (argNum < 2)
      super.setArg(arg, argNum);
    else if (2 == argNum)
    {
      m_arg2 = arg;
      arg.exprSetParent(this);
    }
    else
		  reportWrongNumberArgs();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum != 3)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""three"", null));
  }
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return super.canTraverseOutsideSubtree() 
    ? true : m_arg2.canTraverseOutsideSubtree();
   }
   
  class Arg2Owner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_arg2;
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(Function3Args.this);
    	m_arg2 = exp;
    }
  }

   
  
  public void callArgVisitors(XPathVisitor visitor)
  {
  	super.callArgVisitors(visitor);
  	if(null != m_arg2)
  		m_arg2.callVisitors(new Arg2Owner(), visitor);
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(null != m_arg2)
  	{
  		if(null == ((Function3Args)expr).m_arg2)
  			return false;

  		if(!m_arg2.deepEquals(((Function3Args)expr).m_arg2))
  			return false;
  	}
  	else if (null != ((Function3Args)expr).m_arg2)
  		return false;
  		
  	return true;
  }


}
"
org.apache.xpath.objects.XObjectFactory,3,1,0,13,19,3,1,13,3,2.0,207,0.0,0,0.0,0.444444444,0,0,68.0,11,5.3333,0,"
package org.apache.xpath.objects;

import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.OneStepIterator;


public class XObjectFactory
{
  
  
  static public XObject create(Object val)
  {

    XObject result;

    if (val instanceof XObject)
    {
      result = (XObject) val;
    }
    else if (val instanceof String)
    {
      result = new XString((String) val);
    }
    else if (val instanceof Boolean)
    {
      result = new XBoolean((Boolean)val);
    }
    else if (val instanceof Double)
    {
      result = new XNumber(((Double) val));
    }
    else
    {
      result = new XObject(val);
    }

    return result;
  }
  
  
  static public XObject create(Object val, XPathContext xctxt)
  {

    XObject result;

    if (val instanceof XObject)
    {
      result = (XObject) val;
    }
    else if (val instanceof String)
    {
      result = new XString((String) val);
    }
    else if (val instanceof Boolean)
    {
      result = new XBoolean((Boolean)val);
    }
    else if (val instanceof Number)
    {
      result = new XNumber(((Number) val));
    }
    else if (val instanceof DTM)
    {
      DTM dtm = (DTM)val;
      try
      {
        int dtmRoot = dtm.getDocument();
        DTMAxisIterator iter = dtm.getAxisIterator(Axis.SELF);
        iter.setStartNode(dtmRoot);
        DTMIterator iterator = new OneStepIterator(iter, Axis.SELF);
        iterator.setRoot(dtmRoot, xctxt);
        result = new XNodeSet(iterator);
      }
      catch(Exception ex)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(ex);
      }
    }
    else if (val instanceof DTMAxisIterator)
    {
      DTMAxisIterator iter = (DTMAxisIterator)val;
      try
      {
        DTMIterator iterator = new OneStepIterator(iter, Axis.SELF);
        iterator.setRoot(iter.getStartNode(), xctxt);
        result = new XNodeSet(iterator);
      }
      catch(Exception ex)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(ex);
      }
    }
    else if (val instanceof DTMIterator)
    {
      result = new XNodeSet((DTMIterator) val);
    }
    
    
    else if (val instanceof org.w3c.dom.Node)
    {
      result = new XNodeSetForDOM((org.w3c.dom.Node)val, xctxt);
    }
    
    
    else if (val instanceof org.w3c.dom.NodeList)
    {
      result = new XNodeSetForDOM((org.w3c.dom.NodeList)val, xctxt);
    }
    else if (val instanceof org.w3c.dom.traversal.NodeIterator)
    {
      result = new XNodeSetForDOM((org.w3c.dom.traversal.NodeIterator)val, xctxt);
    }
    else
    {
      result = new XObject(val);
    }

    return result;
  }
}"
org.apache.xalan.templates.TemplateList,22,1,0,18,74,121,3,17,9,0.680272109,943,0.857142857,4,0.0,0.180952381,0,0,41.54545455,19,3.0455,2,"
package org.apache.xalan.templates;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.QName;
import org.apache.xpath.Expression;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.PsuedoNames;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.patterns.StepPattern;
import org.apache.xpath.patterns.UnionPattern;


public class TemplateList implements java.io.Serializable
{

  
  public TemplateList()
  {
    super();
  }

  
  public void setTemplate(ElemTemplate template)
  {
    if (null != template.getName())
    {
      ElemTemplate existingTemplate = (ElemTemplate) m_namedTemplates.get(template.getName());
      if (null == existingTemplate)
      {
        m_namedTemplates.put(template.getName(), template);
      }
      else
      {
        int existingPrecedence =
                        existingTemplate.getStylesheetComposed().getImportCountComposed();
        int newPrecedence = template.getStylesheetComposed().getImportCountComposed();
        if (newPrecedence > existingPrecedence)
        {
          
          m_namedTemplates.put(template.getName(), template);
        }
        else if (newPrecedence == existingPrecedence)
          template.error(XSLTErrorResources.ER_DUPLICATE_NAMED_TEMPLATE,
                       new Object[]{ template.getName() });
      }
    }

    XPath matchXPath = template.getMatch();

    if (null != matchXPath)
    {
      Expression matchExpr = matchXPath.getExpression();

      if (matchExpr instanceof StepPattern)
      {
        insertPatternInTable((StepPattern) matchExpr, template);
      }
      else if (matchExpr instanceof UnionPattern)
      {
        UnionPattern upat = (UnionPattern) matchExpr;
        StepPattern[] pats = upat.getPatterns();
        int n = pats.length;

        for (int i = 0; i < n; i++)
        {
          insertPatternInTable(pats[i], template);
        }
      }
      else
      {

        
      }
    }
  }

  
  static boolean DEBUG = false;

  
  void dumpAssociationTables()
  {

    Enumeration associations = m_patternTable.elements();

    while (associations.hasMoreElements())
    {
      TemplateSubPatternAssociation head =
        (TemplateSubPatternAssociation) associations.nextElement();

      while (null != head)
      {
        System.out.print(""("" + head.getTargetString() + "", ""
                         + head.getPattern() + "")"");

        head = head.getNext();
      }

      System.out.println(""
....."");
    }

    TemplateSubPatternAssociation head = m_wildCardPatterns;

    System.out.print(""wild card list: "");

    while (null != head)
    {
      System.out.print(""("" + head.getTargetString() + "", ""
                       + head.getPattern() + "")"");

      head = head.getNext();
    }

    System.out.println(""
....."");
  }

  
  public void compose(StylesheetRoot sroot)
  {

    if (DEBUG)
    {
      System.out.println(""Before wildcard insert..."");
      dumpAssociationTables();
    }

    if (null != m_wildCardPatterns)
    {
      Enumeration associations = m_patternTable.elements();

      while (associations.hasMoreElements())
      {
        TemplateSubPatternAssociation head =
          (TemplateSubPatternAssociation) associations.nextElement();
        TemplateSubPatternAssociation wild = m_wildCardPatterns;

        while (null != wild)
        {
          try
          {
            head = insertAssociationIntoList(
              head, (TemplateSubPatternAssociation) wild.clone(), true);
          }
          catch (CloneNotSupportedException cnse){}

          wild = wild.getNext();
        }
      }
    }

    if (DEBUG)
    {
      System.out.println(""After wildcard insert..."");
      dumpAssociationTables();
    }
  }

  
  private TemplateSubPatternAssociation
              insertAssociationIntoList(TemplateSubPatternAssociation head,
                                         TemplateSubPatternAssociation item,
                                         boolean isWildCardInsert)
  {

    
    
    

    double priority = getPriorityOrScore(item);
    double workPriority;
    int importLevel = item.getImportLevel();
    int docOrder = item.getDocOrderPos();
    TemplateSubPatternAssociation insertPoint = head;
    TemplateSubPatternAssociation next;
    boolean insertBefore;         
                                  
                                  

    
    
    
    
    
    
    
    
    

    while (true)
    {
      next = insertPoint.getNext();
      if (null == next)
        break;
      else
      {
        workPriority = getPriorityOrScore(next);
        if (importLevel > next.getImportLevel())
          break;
        else if (importLevel < next.getImportLevel())
          insertPoint = next;
        else if (priority > workPriority)               
          break;
        else if (priority < workPriority)
          insertPoint = next;
        else if (docOrder >= next.getDocOrderPos())     
          break;
        else
          insertPoint = next;
      }
    }

    if ( (null == next) || (insertPoint == head) )      
    {
      workPriority = getPriorityOrScore(insertPoint);
      if (importLevel > insertPoint.getImportLevel())
        insertBefore = true;
      else if (importLevel < insertPoint.getImportLevel())
        insertBefore = false;
      else if (priority > workPriority)
        insertBefore = true;
      else if (priority < workPriority)
        insertBefore = false;
      else if (docOrder >= insertPoint.getDocOrderPos())
        insertBefore = true;
      else
        insertBefore = false;
    }
    else
      insertBefore = false;

    
    
    if (isWildCardInsert)
    {
      if (insertBefore)
      {
        item.setNext(insertPoint);

        String key = insertPoint.getTargetString();

        item.setTargetString(key);
        putHead(key, item);
        return item;
      }
      else
      {
        item.setNext(next);
        insertPoint.setNext(item);
        return head;
      }
    }
    else
    {
      if (insertBefore)
      {
        item.setNext(insertPoint);

        if (insertPoint.isWild() || item.isWild())
          m_wildCardPatterns = item;
        else
          putHead(item.getTargetString(), item);
        return item;
      }
      else
      {
        item.setNext(next);
        insertPoint.setNext(item);
        return head;
      }
    }
  }

  
  private void insertPatternInTable(StepPattern pattern, ElemTemplate template)
  {

    String target = pattern.getTargetString();

    if (null != target)
    {
      String pstring = template.getMatch().getPatternString();
      TemplateSubPatternAssociation association =
        new TemplateSubPatternAssociation(template, pattern, pstring);

      
      boolean isWildCard = association.isWild();
      TemplateSubPatternAssociation head = isWildCard
                                           ? m_wildCardPatterns
                                           : getHead(target);

      if (null == head)
      {
        if (isWildCard)
          m_wildCardPatterns = association;
        else
          putHead(target, association);
      }
      else
      {
        insertAssociationIntoList(head, association, false);
      }
    }
  }

  
  private double getPriorityOrScore(TemplateSubPatternAssociation matchPat)
  {

    double priority = matchPat.getTemplate().getPriority();

    if (priority == XPath.MATCH_SCORE_NONE)
    {
      Expression ex = matchPat.getStepPattern();

      if (ex instanceof NodeTest)
      {
        return ((NodeTest) ex).getDefaultScore();
      }
    }

    return priority;
  }

  
  public ElemTemplate getTemplate(QName qname)
  {
    return (ElemTemplate) m_namedTemplates.get(qname);
  }

  
  public TemplateSubPatternAssociation getHead(XPathContext xctxt, 
                                               int targetNode, DTM dtm)
  {
    short targetNodeType = dtm.getNodeType(targetNode);
    TemplateSubPatternAssociation head;

    switch (targetNodeType)
    {
    case DTM.ELEMENT_NODE :
    case DTM.ATTRIBUTE_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getLocalName(targetNode));
      break;
    case DTM.TEXT_NODE :
    case DTM.CDATA_SECTION_NODE :
      head = m_textPatterns;
      break;
    case DTM.ENTITY_REFERENCE_NODE :
    case DTM.ENTITY_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getNodeName(targetNode)); 
      break;
    case DTM.PROCESSING_INSTRUCTION_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getLocalName(targetNode));
      break;
    case DTM.COMMENT_NODE :
      head = m_commentPatterns;
      break;
    case DTM.DOCUMENT_NODE :
    case DTM.DOCUMENT_FRAGMENT_NODE :
      head = m_docPatterns;
      break;
    case DTM.NOTATION_NODE :
    default :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getNodeName(targetNode)); 
    }

    return (null == head) ? m_wildCardPatterns : head;
  }
  
  
  public ElemTemplate getTemplateFast(XPathContext xctxt,
                                int targetNode,
                                int expTypeID,
                                QName mode,
                                int maxImportLevel,
                                boolean quietConflictWarnings,
                                DTM dtm)
            throws TransformerException
  {
    
    TemplateSubPatternAssociation head;

    switch (dtm.getNodeType(targetNode))
    {
    case DTM.ELEMENT_NODE :
    case DTM.ATTRIBUTE_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getLocalNameFromExpandedNameID(expTypeID));
      break;
    case DTM.TEXT_NODE :
    case DTM.CDATA_SECTION_NODE :
      head = m_textPatterns;
      break;
    case DTM.ENTITY_REFERENCE_NODE :
    case DTM.ENTITY_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getNodeName(targetNode)); 
      break;
    case DTM.PROCESSING_INSTRUCTION_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getLocalName(targetNode));
      break;
    case DTM.COMMENT_NODE :
      head = m_commentPatterns;
      break;
    case DTM.DOCUMENT_NODE :
    case DTM.DOCUMENT_FRAGMENT_NODE :
      head = m_docPatterns;
      break;
    case DTM.NOTATION_NODE :
    default :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getNodeName(targetNode)); 
    }

    if(null == head)
    {
      head = m_wildCardPatterns;
      if(null == head)
        return null;
    }                                              

    
    
    
    xctxt.pushNamespaceContextNull();
    try
    {
      do
      {
        if ( (maxImportLevel > -1) && (head.getImportLevel() > maxImportLevel) )
        {
          continue;
        }
        ElemTemplate template = head.getTemplate();        
        xctxt.setNamespaceContext(template);
        
        if ((head.m_stepPattern.execute(xctxt, targetNode, dtm, expTypeID) != NodeTest.SCORE_NONE)
                && head.matchMode(mode))
        {
          if (quietConflictWarnings)
            checkConflicts(head, xctxt, targetNode, mode);

          return template;
        }
      }
      while (null != (head = head.getNext()));
    }
    finally
    {
      xctxt.popNamespaceContext();
    }

    return null;
  }  

  
  public ElemTemplate getTemplate(XPathContext xctxt,
                                int targetNode,
                                QName mode,
                                boolean quietConflictWarnings,
                                DTM dtm)
            throws TransformerException
  {

    TemplateSubPatternAssociation head = getHead(xctxt, targetNode, dtm);

    if (null != head)
    {
      
      
      
      xctxt.pushNamespaceContextNull();
      xctxt.pushCurrentNodeAndExpression(targetNode, targetNode);
      try
      {
        do
        {
          ElemTemplate template = head.getTemplate();        
          xctxt.setNamespaceContext(template);
          
          if ((head.m_stepPattern.execute(xctxt, targetNode) != NodeTest.SCORE_NONE)
                  && head.matchMode(mode))
          {
            if (quietConflictWarnings)
              checkConflicts(head, xctxt, targetNode, mode);

            return template;
          }
        }
        while (null != (head = head.getNext()));
      }
      finally
      {
        xctxt.popCurrentNodeAndExpression();
        xctxt.popNamespaceContext();
      }
    }

    return null;
  }  
  
  
  public ElemTemplate getTemplate(XPathContext xctxt,
                                int targetNode,
                                QName mode,
                                int maxImportLevel, int endImportLevel,
                                boolean quietConflictWarnings,
                                DTM dtm)
            throws TransformerException
  {

    TemplateSubPatternAssociation head = getHead(xctxt, targetNode, dtm);

    if (null != head)
    {
      
      
      
      xctxt.pushNamespaceContextNull();
      xctxt.pushCurrentNodeAndExpression(targetNode, targetNode);
      try
      {
        do
        {
          if ( (maxImportLevel > -1) && (head.getImportLevel() > maxImportLevel))
          {
            continue;
          }
          if (head.getImportLevel()<= maxImportLevel - endImportLevel)
            return null;
          ElemTemplate template = head.getTemplate();        
          xctxt.setNamespaceContext(template);
          
          if ((head.m_stepPattern.execute(xctxt, targetNode) != NodeTest.SCORE_NONE)
                  && head.matchMode(mode))
          {
            if (quietConflictWarnings)
              checkConflicts(head, xctxt, targetNode, mode);

            return template;
          }
        }
        while (null != (head = head.getNext()));
      }
      finally
      {
        xctxt.popCurrentNodeAndExpression();
        xctxt.popNamespaceContext();
      }
    }

    return null;
  }  

  
  public TemplateWalker getWalker()
  {
    return new TemplateWalker();
  }

  
  private void checkConflicts(TemplateSubPatternAssociation head,
                              XPathContext xctxt, int targetNode, QName mode)
  {

    
  }

  
  private void addObjectIfNotFound(Object obj, Vector v)
  {

    int n = v.size();
    boolean addIt = true;

    for (int i = 0; i < n; i++)
    {
      if (v.elementAt(i) == obj)
      {
        addIt = false;

        break;
      }
    }

    if (addIt)
    {
      v.addElement(obj);
    }
  }

  
  private Hashtable m_namedTemplates = new Hashtable(89);

  
  private Hashtable m_patternTable = new Hashtable(89);

  
  private TemplateSubPatternAssociation m_wildCardPatterns = null;

  
  private TemplateSubPatternAssociation m_textPatterns = null;

  
  private TemplateSubPatternAssociation m_docPatterns = null;

  
  private TemplateSubPatternAssociation m_commentPatterns = null;

  
  private Hashtable getNamedTemplates()
  {
    return m_namedTemplates;
  }

  
  private void setNamedTemplates(Hashtable v)
  {
    m_namedTemplates = v;
  }

  
  private TemplateSubPatternAssociation getHead(String key)
  {
    return (TemplateSubPatternAssociation) m_patternTable.get(key);
  }

  
  private void putHead(String key, TemplateSubPatternAssociation assoc)
  {

    if (key.equals(PsuedoNames.PSEUDONAME_TEXT))
      m_textPatterns = assoc;
    else if (key.equals(PsuedoNames.PSEUDONAME_ROOT))
      m_docPatterns = assoc;
    else if (key.equals(PsuedoNames.PSEUDONAME_COMMENT))
      m_commentPatterns = assoc;

    m_patternTable.put(key, assoc);
  }

  
  public class TemplateWalker
  {
    private Enumeration hashIterator;
    private boolean inPatterns;
    private TemplateSubPatternAssociation curPattern;

    private Hashtable m_compilerCache = new Hashtable();

    private TemplateWalker()
    {
      hashIterator = m_patternTable.elements();
      inPatterns = true;
      curPattern = null;
    }

    public ElemTemplate next()
    {

      ElemTemplate retValue = null;
      ElemTemplate ct;

      while (true)
      {
        if (inPatterns)
        {
          if (null != curPattern)
            curPattern = curPattern.getNext();

          if (null != curPattern)
            retValue = curPattern.getTemplate();
          else
          {
            if (hashIterator.hasMoreElements())
            {
              curPattern = (TemplateSubPatternAssociation) hashIterator.nextElement();
              retValue =  curPattern.getTemplate();
            }
            else
            {
              inPatterns = false;
              hashIterator = m_namedTemplates.elements();
            }
          }
        }

        if (!inPatterns)
        {
          if (hashIterator.hasMoreElements())
            retValue = (ElemTemplate) hashIterator.nextElement();
          else
            return null;
        }

        ct = (ElemTemplate) m_compilerCache.get(new Integer(retValue.getUid()));
        if (null == ct)
        {
          m_compilerCache.put(new Integer(retValue.getUid()), retValue);
          return retValue;
        }
      }
    }
  }

}
"
org.apache.xml.dtm.DTMConfigurationException,6,5,0,2,11,15,1,1,6,2.0,34,0.0,0,1.0,0.625,0,0,4.666666667,0,0.0,0,"
package org.apache.xml.dtm;

import javax.xml.transform.SourceLocator;


public class DTMConfigurationException extends DTMException {

    
    public DTMConfigurationException() {
        super(""Configuration Error"");
    }

    
    public DTMConfigurationException(String msg) {
        super(msg);
    }

    
    public DTMConfigurationException(Throwable e) {
        super(e);
    }

    
    public DTMConfigurationException(String msg, Throwable e) {
        super(msg, e);
    }

    
    public DTMConfigurationException(String message,
                                             SourceLocator locator) {
        super(message, locator);
    }

    
    public DTMConfigurationException(String message,
                                             SourceLocator locator,
                                             Throwable e) {
        super(message, locator, e);
    }
}"
org.apache.xpath.functions.FuncLast,5,3,0,8,12,8,1,7,5,0.5,59,1.0,0,0.904761905,0.4,1,6,10.6,2,1.0,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.SubContextList;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;



public class FuncLast extends Function
{
  
  private boolean m_isTopLevel;
  
  
  public void postCompileStep(Compiler compiler)
  {
    m_isTopLevel = compiler.getLocationPathDepth() == -1;
  }

  
  public int getCountOfContextNodeList(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    
    
    SubContextList iter = m_isTopLevel ? null : xctxt.getSubContextList();

    
    if (null != iter)
      return iter.getLastPos(xctxt);

    DTMIterator cnl = xctxt.getContextNodeList();
    int count;
    if(null != cnl)
    {
      count = cnl.getLength();
      
    }
    else
      count = 0;   
    return count;
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    XNumber xnum = new XNumber((double) getCountOfContextNodeList(xctxt));
    
    return xnum;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }

}
"
org.apache.xalan.transformer.KeyTable,8,1,0,16,42,8,2,15,4,0.607142857,246,1.0,1,0.0,0.321428571,0,0,29.25,4,1.875,1,"
package org.apache.xalan.transformer;

import java.util.Hashtable;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.KeyDeclaration;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;


public class KeyTable
{
  
  private int m_docKey;

  
  private Vector m_keyDeclarations;

  
  private Hashtable m_refsTable = null;

  
  public int getDocKey()
  {
    return m_docKey;
  }

  
  private XNodeSet m_keyNodes;
  
  KeyIterator getKeyIterator()
  {
  	return (KeyIterator)(m_keyNodes.getContainedIter());
  }

  
  public KeyTable(
          int doc, PrefixResolver nscontext, QName name, Vector keyDeclarations, XPathContext xctxt)
            throws javax.xml.transform.TransformerException
  {
    m_docKey = doc;
    m_keyDeclarations = keyDeclarations;
    KeyIterator ki = new KeyIterator(name, keyDeclarations);

    m_keyNodes = new XNodeSet(ki);
    m_keyNodes.allowDetachToRelease(false);
    m_keyNodes.setRoot(doc, xctxt);
  }

  
  public XNodeSet getNodeSetDTMByKey(QName name, XMLString ref)

  {
    XNodeSet refNodes = (XNodeSet) getRefsTable().get(ref);
    
   try
    {
      if (refNodes != null)
      {
         refNodes = (XNodeSet) refNodes.cloneWithReset();
       }
    }
    catch (CloneNotSupportedException e)
    {
      refNodes = null;
    }

    if (refNodes == null) {
     
      KeyIterator ki = (KeyIterator) (m_keyNodes).getContainedIter();
      XPathContext xctxt = ki.getXPathContext();
      refNodes = new XNodeSet(xctxt.getDTMManager()) {
        public void setRoot(int nodeHandle, Object environment) {
          
        }
      };
      refNodes.reset();
    }

    return refNodes;
  }

  
  public QName getKeyTableName()
  {
    return getKeyIterator().getName();
  }

  
  private KeyDeclaration getKeyDeclaration() {
    int nDeclarations = m_keyDeclarations.size();

    
    for (int i = 0; i < nDeclarations; i++)
    {
      KeyDeclaration kd = (KeyDeclaration) m_keyDeclarations.elementAt(i);

      
      
      if (kd.getName().equals(getKeyTableName()))
      {
        return kd;
      }
    }

    
    return null;
  }

  
  private Hashtable getRefsTable()
  {
    if (m_refsTable == null)
    {
      m_refsTable = new Hashtable(89);  

      KeyIterator ki = (KeyIterator) (m_keyNodes).getContainedIter();
      XPathContext xctxt = ki.getXPathContext();

      KeyDeclaration keyDeclaration = getKeyDeclaration();

      int currentNode;
      m_keyNodes.reset();
      while (DTM.NULL != (currentNode = m_keyNodes.nextNode()))
      {
        try
        {
          XObject xuse = keyDeclaration.getUse().execute(xctxt, currentNode, ki.getPrefixResolver());

          if (xuse.getType() != xuse.CLASS_NODESET)
          {
            XMLString exprResult = xuse.xstr();
            addValueInRefsTable(xctxt, exprResult, currentNode);
          }
          else
          {
            DTMIterator i = ((XNodeSet)xuse).iterRaw();
            int currentNodeInUseClause;

            while (DTM.NULL != (currentNodeInUseClause = i.nextNode()))
            {
              DTM dtm = xctxt.getDTM(currentNodeInUseClause);
              XMLString exprResult = dtm.getStringValue(currentNodeInUseClause);
              addValueInRefsTable(xctxt, exprResult, currentNode);
            }
          }
        }
        catch (TransformerException te)
        {
          throw new WrappedRuntimeException(te);
        }
      }
    }
    return m_refsTable;
  }

  
  private void addValueInRefsTable(XPathContext xctxt, XMLString ref, int node) {
    
    XNodeSet nodes = (XNodeSet) m_refsTable.get(ref);
    if (nodes == null)
    {
      nodes = new XNodeSet(node, xctxt.getDTMManager());
      nodes.nextNode();
      m_refsTable.put(ref, nodes);
    }
    else
    {
      
      
      
      
      if (nodes.getCurrentNode() != node) {
          nodes.mutableNodeset().addNode(node);
          nodes.nextNode();
      }    
    }
  }
}
"
org.apache.xml.serializer.WriterToASCI,7,2,0,1,13,0,1,0,7,0.0,65,1.0,0,0.684210526,0.342857143,1,2,8.142857143,1,0.8571,0,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;




public class WriterToASCI extends Writer
{

  
  private final OutputStream m_os;

  
  public WriterToASCI(OutputStream os)
  {
    m_os = os;
  }

  
  public void write(char chars[], int start, int length)
          throws java.io.IOException
  {

    int n = length+start;

    for (int i = start; i < n; i++)
    {
      m_os.write(chars[i]);
    }
  }

  
  public void write(int c) throws IOException
  {
    m_os.write(c);
  }

  
  public void write(String s) throws IOException
  {
    int n = s.length();
    for (int i = 0; i < n; i++)
    {
      m_os.write(s.charAt(i));
    }
  }

  
  public void flush() throws java.io.IOException
  {
    m_os.flush();
  }

  
  public void close() throws java.io.IOException
  {
    m_os.close();
  }

  
  public OutputStream getOutputStream()
  {
    return m_os;
  }

}
"
org.apache.xalan.xsltc.trax.TemplatesImpl,16,1,0,7,34,10,4,6,7,0.586666667,399,1.0,2,0.0,0.214814815,0,0,23.3125,1,0.75,2,"

package org.apache.xalan.xsltc.trax;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Properties;

import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.URIResolver;

import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;

public final class TemplatesImpl implements Templates, Serializable {

    
    private static String ABSTRACT_TRANSLET 
	= ""org.apache.xalan.xsltc.runtime.AbstractTranslet"";

    
    private String _name = null;

    
    private byte[][] _bytecodes = null;
    
    
    private Translet _translet = null;

    
    private Class[] _class = null;

    
    private int _transletIndex = -1;
    
    
    private Properties _outputProperties; 

    
    private int _indentNumber;

    
    private URIResolver _uriResolver = null;

    
    private transient TransformerFactoryImpl _tfactory = null;

    private class TransletClassLoader extends ClassLoader {

	protected TransletClassLoader(ClassLoader parent){
	    super(parent);
	}
	public Class defineClass(byte[] b) {
	    return super.defineClass(null, b, 0, b.length);
	}
    }


   
    protected TemplatesImpl(byte[][] bytecodes, String transletName,
	Properties outputProperties, int indentNumber,
	TransformerFactoryImpl tfactory) 
    {
	_bytecodes = bytecodes;
	_name      = transletName;
	_outputProperties = outputProperties;
	_indentNumber = indentNumber;
	_tfactory = tfactory;
    }
    
    
    protected TemplatesImpl(Translet translet, String transletName,
	Properties outputProperties, int indentNumber,
	TransformerFactoryImpl tfactory) 
    {
	_translet  = translet;
	_name      = transletName;
	_outputProperties = outputProperties;
	_indentNumber = indentNumber;
	_tfactory = tfactory;
    }
    

    
    public TemplatesImpl() { }

    
    private void  readObject(ObjectInputStream is) 
      throws IOException, ClassNotFoundException 
    {
	is.defaultReadObject();
	_tfactory = new TransformerFactoryImpl();
    } 

     
    public synchronized void setURIResolver(URIResolver resolver) {
	_uriResolver = resolver;
    }

    
    protected synchronized void setTransletBytecodes(byte[][] bytecodes) {
	_bytecodes = bytecodes;
    }

    
    public synchronized byte[][] getTransletBytecodes() {
	return _bytecodes;
    }

    
    public synchronized Class[] getTransletClasses() {
	try {
	    if (_class == null) defineTransletClasses();
	}
	catch (TransformerConfigurationException e) {
	    
	}
	return _class;
    }

    
    public synchronized int getTransletIndex() {
	try {
	    if (_class == null) defineTransletClasses();
	}
	catch (TransformerConfigurationException e) {
	    
	}
	return _transletIndex;
    }

    
    protected synchronized void setTransletName(String name) {
	_name = name;
    }

    
    protected synchronized String getTransletName() {
	return _name;
    }

    
    private void defineTransletClasses()
	throws TransformerConfigurationException {

	if (_bytecodes == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);
	    throw new TransformerConfigurationException(err.toString());
	}

	TransletClassLoader loader = 
	    (TransletClassLoader) AccessController.doPrivileged(
		new PrivilegedAction() {
			public Object run() {
			    
			    return new TransletClassLoader(
				Thread.currentThread().getContextClassLoader());
			}
		    }
		);

	try {
	    final int classCount = _bytecodes.length;
	    _class = new Class[classCount];

	    for (int i = 0; i < classCount; i++) {
		_class[i] = loader.defineClass(_bytecodes[i]);
		final Class superClass = _class[i].getSuperclass();

		
		if (superClass.getName().equals(ABSTRACT_TRANSLET)) {
		    _transletIndex = i;
		}
	    }

	    if (_transletIndex < 0) {
		ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);
		throw new TransformerConfigurationException(err.toString());
	    }
	}
	catch (ClassFormatError e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);
	    throw new TransformerConfigurationException(err.toString());
	}
	catch (LinkageError e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
	    throw new TransformerConfigurationException(err.toString());
	}
    }

    
    private Translet getTransletInstance()
	throws TransformerConfigurationException {
	try {
	    if (_name == null) return null;

	    if (_class == null) defineTransletClasses();

	    
	    
	    Translet translet = (Translet) _class[_transletIndex].newInstance();
	    final int classCount = _bytecodes.length;
	    for (int i = 0; i < classCount; i++) {
		if (i != _transletIndex) {
		    translet.addAuxiliaryClass(_class[i]);
		}
	    }
	    return translet;
	}
	catch (InstantiationException e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
	    throw new TransformerConfigurationException(err.toString());
	}
	catch (IllegalAccessException e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
	    throw new TransformerConfigurationException(err.toString());
	}
    }

    
    public synchronized Transformer newTransformer()
	throws TransformerConfigurationException 
    {
	TransformerImpl transformer;
	if (_translet != null) {
	    transformer = new TransformerImpl(_translet, _outputProperties,
			      _indentNumber, _tfactory);
	}
	else {
	    transformer = new TransformerImpl(getTransletInstance(), _outputProperties,
			      _indentNumber, _tfactory);
	}
	
	if (_uriResolver != null) {
	    transformer.setURIResolver(_uriResolver);
	}
	return transformer;
    }

    
    public synchronized Properties getOutputProperties() { 
	try {
	    return newTransformer().getOutputProperties();
	}
	catch (TransformerConfigurationException e) {
	    return null;
	}
    }

}

"
org.apache.xalan.xsltc.compiler.Key,6,3,0,35,53,0,1,34,5,0.55,570,1.0,4,0.923076923,0.361111111,2,5,93.33333333,4,1.5,1,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IFGE;
import org.apache.bcel.generic.IFGT;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;
import org.apache.xalan.xsltc.compiler.util.StringType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xalan.xsltc.dom.Axis;

final class Key extends TopLevelElement {

    
    private QName _name;

    
    private Pattern _match; 

    
    private Expression _use;

    
    private Type _useType;

    
    public void parseContents(Parser parser) {

	
	_name = parser.getQNameIgnoreDefaultNs(getAttribute(""name""));
	_match = parser.parsePattern(this, ""match"", null);
	_use = parser.parseExpression(this, ""use"", null);

        
        if (_name == null) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""name"");
	    return;
        }
        if (_match.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""match"");
	    return;
        }
        if (_use.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""use"");
	    return;
        }
    }

    
    public String getName() {
	return _name.toString();
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	_match.typeCheck(stable);

	
	_useType = _use.typeCheck(stable);
	if (_useType instanceof StringType == false &&
	    _useType instanceof NodeSetType == false) 
	{
	    _use = new CastExpr(_use, Type.String);
	}

	return Type.Void;
    }

    
    public void traverseNodeSet(ClassGenerator classGen,
				MethodGenerator methodGen,
				int buildKeyIndex) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getNodeValue = cpg.addInterfaceMethodref(DOM_INTF,
							   GET_NODE_VALUE,
							   ""(I)""+STRING_SIG);
							   
	final int getNodeIdent = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getNodeIdent"",
							   ""(I)""+NODE_SIG);	
							   
	
	final int keyDom = cpg.addMethodref(TRANSLET_CLASS,
					 ""setKeyIndexDom"",
					 ""(""+STRING_SIG+DOM_INTF_SIG+"")V"");				 
						   					   

	
	
	
	final LocalVariableGen parentNode =
	    methodGen.addLocalVariable(""parentNode"",
				       Util.getJCRefType(""I""),
				       il.getEnd(), null);

	
	il.append(new ISTORE(parentNode.getIndex()));	
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(parentNode.getIndex()));	
	il.append(new INVOKEINTERFACE(getNodeIdent, 2));
	il.append(new ISTORE(parentNode.getIndex()));

	
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadIterator());

	
	_use.translate(classGen, methodGen);
	_use.startResetIterator(classGen, methodGen);
	il.append(methodGen.storeIterator());

	final BranchHandle nextNode = il.append(new GOTO(null));
	final InstructionHandle loop = il.append(NOP);

	
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, _name.toString()));
	il.append(new ILOAD(parentNode.getIndex()));

	
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadCurrentNode());
	il.append(new INVOKEINTERFACE(getNodeValue, 2));		

	
	il.append(new INVOKEVIRTUAL(buildKeyIndex));
	
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, getName()));
	il.append(methodGen.loadDOM());
	il.append(new INVOKEVIRTUAL(keyDom));

	nextNode.setTarget(il.append(methodGen.loadIterator()));
	il.append(methodGen.nextNode());	

	il.append(DUP);
	il.append(methodGen.storeCurrentNode());
	il.append(new IFGE(loop)); 

	
	il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int current = methodGen.getLocalIndex(""current"");

	
	final int key = cpg.addMethodref(TRANSLET_CLASS,
					 ""buildKeyIndex"",
					 ""(""+STRING_SIG+""I""+OBJECT_SIG+"")V"");
					 
	
	final int keyDom = cpg.addMethodref(TRANSLET_CLASS,
					 ""setKeyIndexDom"",
					 ""(""+STRING_SIG+DOM_INTF_SIG+"")V"");
					 
	final int getNodeIdent = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getNodeIdent"",
							   ""(I)""+NODE_SIG);					 				 

	
	final int git = cpg.addInterfaceMethodref(DOM_INTF,
						  ""getAxisIterator"",
						  ""(I)""+NODE_ITERATOR_SIG);

	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadIterator());

	
	il.append(methodGen.loadDOM());	
	il.append(new PUSH(cpg,Axis.DESCENDANT));
	il.append(new INVOKEINTERFACE(git, 2));

	
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.setStartNode());
	il.append(methodGen.storeIterator());

	
	final BranchHandle nextNode = il.append(new GOTO(null));
	final InstructionHandle loop = il.append(NOP);

	
	il.append(methodGen.loadCurrentNode());
	_match.translate(classGen, methodGen);
	_match.synthesize(classGen, methodGen); 
	final BranchHandle skipNode = il.append(new IFEQ(null));
	
	
	if (_useType instanceof NodeSetType) {
	    
	    il.append(methodGen.loadCurrentNode());
	    traverseNodeSet(classGen, methodGen, key);
	}
	else {
	    il.append(classGen.loadTranslet());
	    il.append(DUP);
	    il.append(new PUSH(cpg, _name.toString()));
	    il.append(DUP_X1);
	    il.append(methodGen.loadCurrentNode());
	    _use.translate(classGen, methodGen);
	    il.append(SWAP);
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(new INVOKEINTERFACE(getNodeIdent, 2));
	    il.append(SWAP);
	    il.append(new INVOKEVIRTUAL(key));
	    
	    il.append(methodGen.loadDOM());
	    il.append(new INVOKEVIRTUAL(keyDom));
	}
	
	
	final InstructionHandle skip = il.append(NOP);
	
	il.append(methodGen.loadIterator());
	il.append(methodGen.nextNode());
	il.append(DUP);
	il.append(methodGen.storeCurrentNode());
	il.append(new IFGT(loop));

	
	il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
	
	nextNode.setTarget(skip);
	skipNode.setTarget(skip);
    }
}
"
org.apache.xalan.xsltc.runtime.AbstractTranslet,37,1,0,25,101,552,10,15,35,0.919871795,899,0.576923077,7,0.0,0.18018018,0,0,22.59459459,12,2.1081,1,"

package org.apache.xalan.xsltc.runtime;

import java.io.FileWriter;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Vector;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.DOMCache;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.dom.DOMAdapter;
import org.apache.xalan.xsltc.dom.KeyIndex;
import org.apache.xalan.xsltc.dom.SAXImpl;
import org.apache.xalan.xsltc.runtime.output.TransletOutputHandlerFactory;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.serializer.SerializationHandler;

public abstract class AbstractTranslet implements Translet {

    
    
    public String  _version = ""1.0"";
    public String  _method = null;
    public String  _encoding = ""UTF-8"";
    public boolean _omitHeader = false;
    public String  _standalone = null;
    public String  _doctypePublic = null;
    public String  _doctypeSystem = null;
    public boolean _indent = false;
    public String  _mediaType = null;
    public Vector _cdata = null;

    
    protected String[] namesArray;
    protected String[] namespaceArray;
    
    
    protected boolean _hasIdCall = false;

    
    protected StringValueHandler stringValueHandler = new StringValueHandler();

    
    private final static String EMPTYSTRING = """";

    
    private final static String ID_INDEX_NAME = ""##id"";

    
    
    public void printInternalState() {
	System.out.println(""-------------------------------------"");
	System.out.println(""AbstractTranslet this = "" + this);
	System.out.println(""pbase = "" + pbase);
	System.out.println(""vframe = "" + pframe);
	System.out.println(""paramsStack.size() = "" + paramsStack.size());
	System.out.println(""namesArray.size = "" + namesArray.length);
	System.out.println(""namespaceArray.size = "" + namespaceArray.length);
	System.out.println("""");
	System.out.println(""Total memory = "" + Runtime.getRuntime().totalMemory());
    }

    
    public final DOMAdapter makeDOMAdapter(DOM dom)
	throws TransletException {
	return new DOMAdapter(dom, namesArray, namespaceArray);
    }

    

    
    
    protected int pbase = 0, pframe = 0;
    protected ArrayList paramsStack = new ArrayList();

    
    public final void pushParamFrame() {
	paramsStack.add(pframe, new Integer(pbase));
	pbase = ++pframe;
    }

    
    public final void popParamFrame() {
	if (pbase > 0) {
	    final int oldpbase = ((Integer)paramsStack.get(--pbase)).intValue();
	    for (int i = pframe - 1; i >= pbase; i--) {
		paramsStack.remove(i);
	    }
	    pframe = pbase; pbase = oldpbase;
	}
    }

    
    public final Object addParameter(String name, Object value) {
	name = BasisLibrary.replace(name, "".-"", 
				    new String[] { ""$dot$"", ""$dash$"" });
	return addParameter(name, value, false);
    }

    
    public final Object addParameter(String name, Object value, 
	boolean isDefault) 
    {
	
	for (int i = pframe - 1; i >= pbase; i--) {
	    final Parameter param = (Parameter) paramsStack.get(i);

	    if (param._name.equals(name)) {
		
		
		if (param._isDefault || !isDefault) {
		    param._value = value;
		    param._isDefault = isDefault;
		    return value;
		}
		return param._value;
	    }
	}

	
	paramsStack.add(pframe++, new Parameter(name, value, isDefault));
	return value;
    }

    
    public void clearParameters() {  
	pbase = pframe = 0;
	paramsStack.clear();
    }

    
    public final Object getParameter(String name) {
	for (int i = pframe - 1; i >= pbase; i--) {
	    final Parameter param = (Parameter)paramsStack.get(i);
	    if (param._name.equals(name)) return param._value;
	}
	return null;
    }

    

    
    
    
    private MessageHandler _msgHandler = null;

    
    public final void setMessageHandler(MessageHandler handler) {
	_msgHandler = handler;
    }

    
    public final void displayMessage(String msg) {
	if (_msgHandler == null) {
            System.err.println(msg);
	}
	else {
	    _msgHandler.displayMessage(msg);
	}
    }

    

    
    public Hashtable _formatSymbols = null;

    
    public void addDecimalFormat(String name, DecimalFormatSymbols symbols) {
	
	if (_formatSymbols == null) _formatSymbols = new Hashtable();

	
	if (name == null) name = EMPTYSTRING;

	
	final DecimalFormat df = new DecimalFormat();
	if (symbols != null) {
	    df.setDecimalFormatSymbols(symbols);
	}
	_formatSymbols.put(name, df);
    }

    
    public final DecimalFormat getDecimalFormat(String name) {

	if (_formatSymbols != null) {
	    
	    if (name == null) name = EMPTYSTRING;

	    DecimalFormat df = (DecimalFormat)_formatSymbols.get(name);
	    if (df == null) df = (DecimalFormat)_formatSymbols.get(EMPTYSTRING);
	    return df;
	}
	return(null);
    }

    
    public final void prepassDocument(DOM document) {
        setIndexSize(document.getSize());
        buildIDIndex(document);
    }

    
    private final void buildIDIndex(DOM document) {
        
        if (document instanceof SAXImpl) {
            SAXImpl saxImpl = (SAXImpl)document;
            
            
            
            
            if (saxImpl.hasDOMSource()) {
                buildKeyIndex(ID_INDEX_NAME, document);
                return;
            }
            else {
                final Hashtable elementsByID = saxImpl.getElementsWithIDs();

                if (elementsByID == null) {
            	    return;
                }

                
                
                
                final Enumeration idValues = elementsByID.keys();
                boolean hasIDValues = false;

                while (idValues.hasMoreElements()) {
            	    final Object idValue = idValues.nextElement();
            	    final int element = ((Integer)elementsByID.get(idValue)).intValue();

            	    buildKeyIndex(ID_INDEX_NAME, element, idValue);
            	    hasIDValues = true;
                }

                if (hasIDValues) {
            	    setKeyIndexDom(ID_INDEX_NAME, document);
                }
            }
        }
    }

    

    
    private Hashtable _keyIndexes = null;
    private KeyIndex  _emptyKeyIndex = new KeyIndex(1);
    private int       _indexSize = 0;

    
    public void setIndexSize(int size) {
	if (size > _indexSize) _indexSize = size;
    }

    
    public KeyIndex createKeyIndex() {
	return(new KeyIndex(_indexSize));
    }

    
    public void buildKeyIndex(String name, int node, Object value) {
	if (_keyIndexes == null) _keyIndexes = new Hashtable();
	
	KeyIndex index = (KeyIndex)_keyIndexes.get(name);
	if (index == null) {
	    _keyIndexes.put(name, index = new KeyIndex(_indexSize));
	}
	index.add(value, node);
    }

    
    public void buildKeyIndex(String name, DOM dom) {
	if (_keyIndexes == null) _keyIndexes = new Hashtable();
	
	KeyIndex index = (KeyIndex)_keyIndexes.get(name);
	if (index == null) {
	    _keyIndexes.put(name, index = new KeyIndex(_indexSize));
	}
	index.setDom(dom);
    }

    
    public KeyIndex getKeyIndex(String name) {
	
	if (_keyIndexes == null) return(_emptyKeyIndex);

	
	final KeyIndex index = (KeyIndex)_keyIndexes.get(name);

	
	if (index == null) return(_emptyKeyIndex);

	return(index);
    }

    
    public void buildKeys(DOM document, DTMAxisIterator iterator,
			  SerializationHandler handler,
			  int root) throws TransletException {
			  	
    }
    
    
    public void setKeyIndexDom(String name, DOM document) {
    	getKeyIndex(name).setDom(document);
			  	
    }

    

    
    private DOMCache _domCache = null;

    
    public void setDOMCache(DOMCache cache) {
	_domCache = cache;
    }

    
    public DOMCache getDOMCache() {
	return(_domCache);
    }

    

    public SerializationHandler openOutputHandler(String filename, boolean append) 
	throws TransletException 
    {
	try {
	    final TransletOutputHandlerFactory factory 
		= TransletOutputHandlerFactory.newInstance();

	    factory.setEncoding(_encoding);
	    factory.setOutputMethod(_method);
	    factory.setWriter(new FileWriter(filename, append));
	    factory.setOutputType(TransletOutputHandlerFactory.STREAM);

	    final SerializationHandler handler 
		= factory.getSerializationHandler();

	    transferOutputSettings(handler);
	    handler.startDocument();
	    return handler;
	}
	catch (Exception e) {
	    throw new TransletException(e);
	}
    }

    public SerializationHandler openOutputHandler(String filename) 
       throws TransletException 
    {
       return openOutputHandler(filename, false);
    }

    public void closeOutputHandler(SerializationHandler handler) {
	try {
	    handler.endDocument();
	    handler.close();
	}
	catch (Exception e) {
	    
	}
    }

    

    
    public abstract void transform(DOM document, DTMAxisIterator iterator,
				   SerializationHandler handler)
	throws TransletException;

    
    public final void transform(DOM document, SerializationHandler handler) 
	throws TransletException {
	transform(document, document.getIterator(), handler);
    }
	
    
    public final void characters(final String string,
				 SerializationHandler handler) 
	throws TransletException {
        if (string != null) {
           
           try {
               handler.characters(string);
           } catch (Exception e) {
               throw new TransletException(e);
           }
        }   
    }

    
    public void addCdataElement(String name) {
	if (_cdata == null) {
            _cdata = new Vector();
        }

        int lastColon = name.lastIndexOf(':');

        if (lastColon > 0) {
            String uri = name.substring(0, lastColon);
            String localName = name.substring(lastColon+1);
	    _cdata.addElement(uri);
	    _cdata.addElement(localName);
        } else {
	    _cdata.addElement(null);
	    _cdata.addElement(name);
        }
    }

    
    protected void transferOutputSettings(SerializationHandler handler) {
	if (_method != null) {
	    if (_method.equals(""xml"")) {
	        if (_standalone != null) {
		    handler.setStandalone(_standalone);
		}
		if (_omitHeader) {
		    handler.setOmitXMLDeclaration(true);
		}
		handler.setCdataSectionElements(_cdata);
		if (_version != null) {
		    handler.setVersion(_version);
		}
		handler.setIndent(_indent);
		if (_doctypeSystem != null) {
		    handler.setDoctype(_doctypeSystem, _doctypePublic);
		}
	    }
	    else if (_method.equals(""html"")) {
		handler.setIndent(_indent);
		handler.setDoctype(_doctypeSystem, _doctypePublic);
		if (_mediaType != null) {
		    handler.setMediaType(_mediaType);
		}
	    }
	}
	else {
	    handler.setCdataSectionElements(_cdata);
	    if (_version != null) {
		handler.setVersion(_version);
	    }
	    if (_standalone != null) {
		handler.setStandalone(_standalone);
	    }
	    if (_omitHeader) {
		handler.setOmitXMLDeclaration(true);
	    }
	    handler.setIndent(_indent);
	    handler.setDoctype(_doctypeSystem, _doctypePublic);
	}
    }

    private Hashtable _auxClasses = null;

    public void addAuxiliaryClass(Class auxClass) {
	if (_auxClasses == null) _auxClasses = new Hashtable();
	_auxClasses.put(auxClass.getName(), auxClass);
    }

    public Class getAuxiliaryClass(String className) {
	if (_auxClasses == null) return null;
	return((Class)_auxClasses.get(className));
    }

    
    public String[] getNamesArray() {
	return namesArray;
    }
    public String[] getNamespaceArray() {
	return namespaceArray;
    }
    
    public boolean hasIdCall() {
    	return _hasIdCall;
    }
}
"
org.apache.xpath.functions.FuncGenerateId,2,5,0,4,10,1,0,4,2,2.0,28,0.0,0,0.982142857,0.75,2,7,13.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncGenerateId extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int which = getArg0AsNode(xctxt);

    if (DTM.NULL != which)
    {
      
      
      
      
      
      
      return new XString(""N"" + Integer.toHexString(which).toUpperCase());
    }
    else
      return XString.EMPTYSTRING;
  }
}
"
org.apache.xml.dtm.DTMManager,19,1,2,53,24,157,44,10,17,0.99382716,94,0.444444444,1,0.0,0.157407407,0,0,3.473684211,1,0.8947,0,"
package org.apache.xml.dtm;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.XMLStringFactory;


public abstract class DTMManager
{

  
  private static final String defaultPropName =
    ""org.apache.xml.dtm.DTMManager"";
  
  
  private static String defaultClassName =
  ""org.apache.xml.dtm.ref.DTMManagerDefault"";

  
  protected XMLStringFactory m_xsf = null;

  
  protected DTMManager(){}

  
  public XMLStringFactory getXMLStringFactory()
  {
    return m_xsf;
  }

  
  public void setXMLStringFactory(XMLStringFactory xsf)
  {
    m_xsf = xsf;
  }

  
  public static DTMManager newInstance(XMLStringFactory xsf) 
           throws DTMConfigurationException
  {

     DTMManager factoryImpl = null;
     try {
        factoryImpl = (DTMManager) FactoryFinder.find(defaultPropName,
              
                                                      defaultClassName);
     } catch (FactoryFinder.ConfigurationError e) {
           throw new DTMConfigurationException(XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_DEFAULT_IMPL, null)); 
     }


    if (factoryImpl == null)
    {
      throw new DTMConfigurationException(XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_DEFAULT_IMPL, null)); 
    }

    factoryImpl.setXMLStringFactory(xsf);

    return factoryImpl;
  }

  
  public abstract DTM getDTM(javax.xml.transform.Source source,
                             boolean unique, DTMWSFilter whiteSpaceFilter,
                             boolean incremental, boolean doIndexing);

  
  public abstract DTM getDTM(int nodeHandle);

  
  public abstract int getDTMHandleFromNode(org.w3c.dom.Node node);

  
  public abstract DTM createDocumentFragment();

  
  public abstract boolean release(DTM dtm, boolean shouldHardDelete);

  
  public abstract DTMIterator createDTMIterator(Object xpathCompiler,
          int pos);

  
  public abstract DTMIterator createDTMIterator(String xpathString,
          PrefixResolver presolver);

  
  public abstract DTMIterator createDTMIterator(int whatToShow,
          DTMFilter filter, boolean entityReferenceExpansion);

  
  public abstract DTMIterator createDTMIterator(int node);
  
  
  public static boolean m_incremental = false;  
  
  
  public synchronized static boolean getIncremental()
  {
    return m_incremental;  
  }
  
  
  public synchronized static void setIncremental(boolean incremental)
  {
    m_incremental = incremental;  
  }
  
  

  

   
  private static boolean debug;

  static
  {
    try
    {
      debug = System.getProperty(""dtm.debug"") != null;
    }
    catch (SecurityException ex){}
  }

  
  public static final int IDENT_DTM_NODE_BITS = 16;
    

  
  public static final int IDENT_NODE_DEFAULT = (1<<IDENT_DTM_NODE_BITS)-1;


  
  public static final int IDENT_DTM_DEFAULT = ~IDENT_NODE_DEFAULT;

  
  public static final int IDENT_MAX_DTMS = (IDENT_DTM_DEFAULT >>> IDENT_DTM_NODE_BITS) + 1;


  
  public abstract int getDTMIdentity(DTM dtm);

  
  public int getDTMIdentityMask()
  {
    return IDENT_DTM_DEFAULT;
  }

  
  public int getNodeIdentityMask()
  {
    return IDENT_NODE_DEFAULT;
  }

}
"
org.apache.xalan.xsltc.ProcessorVersion,3,1,0,0,9,1,0,0,2,0.5,44,1.0,0,0.0,0.5,0,0,12.66666667,2,0.6667,0,"

package org.apache.xalan.xsltc;



public class ProcessorVersion {
    private static int MAJOR = 1;
    private static int MINOR = 0;
    private static int DELTA = 0;

    public static void main(String[] args) {
	System.out.println(""XSLTC version "" + MAJOR + ""."" + MINOR +
	    ((DELTA > 0) ? ("".""+DELTA) : ("""")));
    }
}
"
org.apache.xpath.objects.XBooleanStatic,2,4,0,5,5,0,3,3,2,0.0,25,0.0,0,0.987341772,0.666666667,2,3,11.0,2,1.0,1,"
package org.apache.xpath.objects;


public class XBooleanStatic extends XBoolean
{

  
  boolean m_val;

  
  public XBooleanStatic(boolean b)
  {

    super(b);

    m_val = b;
  }

  
  public boolean equals(XObject obj2)
  {
    try
    {
      return m_val == obj2.bool();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }
}
"
org.apache.xalan.transformer.TransformerClient,1,1,0,2,1,0,1,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xalan.transformer;


public interface TransformerClient
{

  
  void setTransformState(TransformState ts);
}
"
org.apache.xpath.functions.FuncStartsWith,2,5,0,6,6,1,0,6,2,2.0,21,0.0,0,0.98245614,0.75,1,6,9.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class FuncStartsWith extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return m_arg0.execute(xctxt).xstr().startsWith(m_arg1.execute(xctxt).xstr())
           ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.lib.sql.DTMDocument,96,4,2,15,197,0,2,13,66,0.919838057,2568,1.0,2,0.497354497,0.180871212,1,26,25.61458333,11,2.0938,1,"

package org.apache.xalan.lib.sql;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.PrintStream;

import javax.xml.transform.SourceLocator;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.ref.DTMDefaultBaseIterators;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.StringBufferPool;
import org.apache.xml.utils.SuballocatedIntVector;
import org.apache.xml.utils.XMLString;

import org.w3c.dom.Node;

import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.LexicalHandler;


public class DTMDocument extends DTMDefaultBaseIterators
{

  
  public interface CharacterNodeHandler
  {
    
    public void characters( Node node )throws org.xml.sax.SAXException ;
  }

  
  private boolean DEBUG = false;

  
  protected static final String S_NAMESPACE = ""http:

  
  protected static final String S_ATTRIB_NOT_SUPPORTED = ""Not Supported"";
  
  protected static final String S_ISTRUE = ""true"";
  
  protected static final String S_ISFALSE = ""false"";

  
  protected static final String S_DOCUMENT = ""#root"";
  
  protected static final String S_TEXT_NODE = ""#text"";
  
  protected static final String S_ELEMENT_NODE = ""#element"";

  
  protected int m_Document_TypeID = 0;
  
  protected int m_TextNode_TypeID = 0;


  
  protected ObjectArray m_ObjectArray = new ObjectArray();

  
  protected SuballocatedIntVector m_attribute;

  
  protected int m_DocumentIdx;


  
  public DTMDocument( DTMManager mgr, int ident )
  {
    super(mgr, null, ident,
      null, mgr.getXMLStringFactory(), true);

    m_attribute = new SuballocatedIntVector(DEFAULT_BLOCKSIZE);
  }

  
  private int allocateNodeObject( Object o )
  {
    
    m_size++;
    return m_ObjectArray.append(o);
  }

  
  protected int addElementWithData( Object o, int level, int extendedType, int parent, int prevsib )
  {
    int elementIdx = addElement(level,extendedType,parent,prevsib);

    int data = allocateNodeObject(o);
    m_firstch.setElementAt(data,elementIdx);

    m_exptype.setElementAt(m_TextNode_TypeID, data);
    
    m_parent.setElementAt(elementIdx, data);

    m_prevsib.setElementAt(DTM.NULL, data);
    m_nextsib.setElementAt(DTM.NULL, data);
    m_attribute.setElementAt(DTM.NULL, data);
    m_firstch.setElementAt(DTM.NULL, data);

    return elementIdx;
  }

  
  protected int addElement( int level, int extendedType, int parent, int prevsib )
  {
    int node = DTM.NULL;

    try
    {
      
      node = allocateNodeObject(S_ELEMENT_NODE);

      m_exptype.setElementAt(extendedType, node);
      m_nextsib.setElementAt(DTM.NULL, node);
      m_prevsib.setElementAt(prevsib, node);

      m_parent.setElementAt(parent, node);
      m_firstch.setElementAt(DTM.NULL, node);
      
      m_attribute.setElementAt(DTM.NULL, node);

      if (prevsib != DTM.NULL)
      {
        
        
        if (m_nextsib.elementAt(prevsib) != DTM.NULL)
          m_nextsib.setElementAt(m_nextsib.elementAt(prevsib), node);

        
        m_nextsib.setElementAt(node, prevsib);
      }

       
      
      
      
      
      if ((parent != DTM.NULL) && (m_prevsib.elementAt(node) == DTM.NULL))
      {
        m_firstch.setElementAt(node, parent);
      }
    }
    catch(Exception e)
    {
      error(""Error in addElement: ""+e.getMessage());
    }

    return node;
  }

  
  protected int addAttributeToNode( Object o, int extendedType, int pnode )
  {
    int attrib = DTM.NULL;
    int prevsib = DTM.NULL;
    int lastattrib = DTM.NULL;
    int value = DTM.NULL;

    try
    {
      
      attrib = allocateNodeObject(o);

      m_attribute.setElementAt(DTM.NULL, attrib);
      m_exptype.setElementAt(extendedType, attrib);
      

      
      m_nextsib.setElementAt(DTM.NULL, attrib);
      m_prevsib.setElementAt(DTM.NULL,attrib);
      
      
      
      m_parent.setElementAt(pnode, attrib);
      m_firstch.setElementAt(DTM.NULL, attrib);

      if (m_attribute.elementAt(pnode) != DTM.NULL)
      {
        
        
        lastattrib = m_attribute.elementAt(pnode);
        m_nextsib.setElementAt(lastattrib, attrib);
        m_prevsib.setElementAt(attrib, lastattrib);
      }
      
      
      m_attribute.setElementAt(attrib, pnode);
    }
    catch(Exception e)
    {
      error(""Error in addAttributeToNode: ""+e.getMessage());
    }

    return attrib;
  }

  
  protected void cloneAttributeFromNode( int toNode, int fromNode )
  {
   try
    {
      if (m_attribute.elementAt(toNode) != DTM.NULL)
      {
        error(""Cloneing Attributes, where from Node already had addtibures assigned"");
      }

      m_attribute.setElementAt(m_attribute.elementAt(fromNode), toNode);
    }
    catch(Exception e)
    {
      error(""Cloning attributes"");
    }
  }


  
  public int getFirstAttribute( int parm1 )
  {
    if (DEBUG) System.out.println(""getFirstAttribute(""+ parm1+"")"");
    int nodeIdx = makeNodeIdentity(parm1);
    if (nodeIdx != DTM.NULL)
    {
      int attribIdx =  m_attribute.elementAt(nodeIdx);
      return makeNodeHandle(attribIdx);
    }
    else return DTM.NULL;
  }

 
  public String getNodeValue( int parm1 )
  {
    if (DEBUG) System.out.println(""getNodeValue("" + parm1 + "")"");
    try
    {
      Object o = m_ObjectArray.getAt(makeNodeIdentity(parm1));
      if (o != null && o != S_ELEMENT_NODE)
      {
        return o.toString();
      }
      else
      {
        return """";
      }
    }
    catch(Exception e)
    {
      error(""Getting String Value"");
      return null;
    }
  }


  
  public XMLString getStringValue(int nodeHandle)
  {
    int nodeIdx = makeNodeIdentity(nodeHandle);
    if (DEBUG) System.out.println(""getStringValue("" + nodeIdx + "")"");

      Object o = m_ObjectArray.getAt(nodeIdx);
    if ( o == S_ELEMENT_NODE )
      {
        FastStringBuffer buf = StringBufferPool.get();
        String s;

        try
        {
          getNodeData(nodeIdx, buf);

          s = (buf.length() > 0) ? buf.toString() : """";
        }
        finally
        {
          StringBufferPool.free(buf);
        }

        return m_xstrf.newstr( s );
      }
      else if( o != null )
      {
        return m_xstrf.newstr(o.toString());
    }
    else
      return(m_xstrf.emptystr());
  }

  
  protected void getNodeData(int nodeIdx, FastStringBuffer buf)
  {
    for ( int child = _firstch(nodeIdx) ; child != DTM.NULL ; child = _nextsib(child) )
    {
      Object o = m_ObjectArray.getAt(child);
      if ( o == S_ELEMENT_NODE )
        getNodeData(child, buf);
      else if ( o != null )
        buf.append(o.toString());
    }
  }




  
  public int getNextAttribute( int parm1 )
  {
    int nodeIdx = makeNodeIdentity(parm1);
    if (DEBUG) System.out.println(""getNextAttribute("" + nodeIdx + "")"");
    if (nodeIdx != DTM.NULL) return makeNodeHandle(m_nextsib.elementAt(nodeIdx));
    else return DTM.NULL;
  }


  
  protected int getNumberOfNodes( )
  {
    if (DEBUG) System.out.println(""getNumberOfNodes()"");
    return m_size;
  }

  
  protected boolean nextNode( )
  {
    if (DEBUG) System.out.println(""nextNode()"");
    return false;
  }


  
  protected void createExpandedNameTable( )
  {
    m_Document_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_DOCUMENT, DTM.DOCUMENT_NODE);

    m_TextNode_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_TEXT_NODE, DTM.TEXT_NODE);
  }


  
  public void dumpDTM( )
  {
    try
    {

      File f = new File(""DTMDump.txt"");
      System.err.println(""Dumping... ""+f.getAbsolutePath());
      PrintStream ps = new PrintStream(new FileOutputStream(f));

      while (nextNode()){}

      int nRecords = m_size;

      ps.println(""Total nodes: "" + nRecords);

      for (int i = 0; i < nRecords; i++)
      {
        ps.println(""=========== "" + i + "" ==========="");
        ps.println(""NodeName: "" + getNodeName(makeNodeHandle(i)));
        ps.println(""NodeNameX: "" + getNodeNameX(makeNodeHandle(i)));
        ps.println(""LocalName: "" + getLocalName(makeNodeHandle(i)));
        ps.println(""NamespaceURI: "" + getNamespaceURI(makeNodeHandle(i)));
        ps.println(""Prefix: "" + getPrefix(makeNodeHandle(i)));

        int exTypeID = getExpandedTypeID(makeNodeHandle(i));

        ps.println(""Expanded Type ID: ""
                           + Integer.toHexString(exTypeID));

        int type = getNodeType(makeNodeHandle(i));
        String typestring;

        switch (type)
        {
        case DTM.ATTRIBUTE_NODE :
          typestring = ""ATTRIBUTE_NODE"";
          break;
        case DTM.CDATA_SECTION_NODE :
          typestring = ""CDATA_SECTION_NODE"";
          break;
        case DTM.COMMENT_NODE :
          typestring = ""COMMENT_NODE"";
          break;
        case DTM.DOCUMENT_FRAGMENT_NODE :
          typestring = ""DOCUMENT_FRAGMENT_NODE"";
          break;
        case DTM.DOCUMENT_NODE :
          typestring = ""DOCUMENT_NODE"";
          break;
        case DTM.DOCUMENT_TYPE_NODE :
          typestring = ""DOCUMENT_NODE"";
          break;
        case DTM.ELEMENT_NODE :
          typestring = ""ELEMENT_NODE"";
          break;
        case DTM.ENTITY_NODE :
          typestring = ""ENTITY_NODE"";
          break;
        case DTM.ENTITY_REFERENCE_NODE :
          typestring = ""ENTITY_REFERENCE_NODE"";
          break;
        case DTM.NAMESPACE_NODE :
          typestring = ""NAMESPACE_NODE"";
          break;
        case DTM.NOTATION_NODE :
          typestring = ""NOTATION_NODE"";
          break;
        case DTM.NULL :
          typestring = ""NULL"";
          break;
        case DTM.PROCESSING_INSTRUCTION_NODE :
          typestring = ""PROCESSING_INSTRUCTION_NODE"";
          break;
        case DTM.TEXT_NODE :
          typestring = ""TEXT_NODE"";
          break;
        default :
          typestring = ""Unknown!"";
          break;
        }

        ps.println(""Type: "" + typestring);

        int firstChild = _firstch(i);

        if (DTM.NULL == firstChild)
          ps.println(""First child: DTM.NULL"");
        else if (NOTPROCESSED == firstChild)
          ps.println(""First child: NOTPROCESSED"");
        else
          ps.println(""First child: "" + firstChild);

        int prevSibling = _prevsib(i);

        if (DTM.NULL == prevSibling)
          ps.println(""Prev sibling: DTM.NULL"");
        else if (NOTPROCESSED == prevSibling)
          ps.println(""Prev sibling: NOTPROCESSED"");
        else
          ps.println(""Prev sibling: "" + prevSibling);

        int nextSibling = _nextsib(i);

        if (DTM.NULL == nextSibling)
          ps.println(""Next sibling: DTM.NULL"");
        else if (NOTPROCESSED == nextSibling)
          ps.println(""Next sibling: NOTPROCESSED"");
        else
          ps.println(""Next sibling: "" + nextSibling);

        int parent = _parent(i);

        if (DTM.NULL == parent)
          ps.println(""Parent: DTM.NULL"");
        else if (NOTPROCESSED == parent)
          ps.println(""Parent: NOTPROCESSED"");
        else
          ps.println(""Parent: "" + parent);

        int level = _level(i);

        ps.println(""Level: "" + level);
        ps.println(""Node Value: "" + getNodeValue(i));
        ps.println(""String Value: "" + getStringValue(i));

        ps.println(""First Attribute Node: "" + m_attribute.elementAt(i));
      }

    }
    catch(IOException ioe)
    {
      ioe.printStackTrace(System.err);
      System.exit(-1);
    }
  }


  
  protected static void dispatchNodeData( Node node, ContentHandler ch, int depth )throws org.xml.sax.SAXException
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_FRAGMENT_NODE :
    case Node.DOCUMENT_NODE :
    case Node.ELEMENT_NODE :
    {
      for (Node child = node.getFirstChild(); null != child;
              child = child.getNextSibling())
      {
        dispatchNodeData(child, ch, depth+1);
      }
    }
    break;
    case Node.PROCESSING_INSTRUCTION_NODE : 
    case Node.COMMENT_NODE :
      if(0 != depth)
        break;
        
        
    case Node.TEXT_NODE :
    case Node.CDATA_SECTION_NODE :
    case Node.ATTRIBUTE_NODE :
      String str = node.getNodeValue();
      if(ch instanceof CharacterNodeHandler)
      {
        ((CharacterNodeHandler)ch).characters(node);
      }
      else
      {
        ch.characters(str.toCharArray(), 0, str.length());
      }
      break;



    default :
      
      break;
    }
  }

  
  
  
  
  


  
  public void setProperty( String property, Object value )
  {
  }

  
  public SourceLocator getSourceLocatorFor( int node )
  {
    return null;
  }

  
  protected int getNextNodeIdentity( int parm1 )
  {
    if (DEBUG) System.out.println(""getNextNodeIdenty("" + parm1 + "")"");
    return DTM.NULL;
  }

  
  public int getAttributeNode( int parm1, String parm2, String parm3 )
  {
    if (DEBUG)
    {
      System.out.println(
        ""getAttributeNode("" +
        parm1 + "","" +
        parm2 + "","" +
        parm3 + "")"");
    }
    return DTM.NULL;
  }

  
  public String getLocalName( int parm1 )
  {

      int exID = getExpandedTypeID(parm1);

    if (DEBUG)
    {
      DEBUG = false;
      System.out.print(""getLocalName("" + parm1 + "") -> "");
      System.out.println(""..."" + getLocalNameFromExpandedNameID(exID) );
      DEBUG = true;
    }

    return getLocalNameFromExpandedNameID(exID);
  }

  
  public String getNodeName( int parm1 )
  {

    int exID = getExpandedTypeID( parm1 );
    if (DEBUG)
    {
      DEBUG = false;
      System.out.print(""getLocalName("" + parm1 + "") -> "");
      System.out.println(""..."" + getLocalNameFromExpandedNameID(exID) );
      DEBUG = true;
    }
    return getLocalNameFromExpandedNameID(exID);
  }

   
  public boolean isAttributeSpecified( int parm1 )
  {
    if (DEBUG) System.out.println(""isAttributeSpecified("" + parm1 + "")"");
    return false;
  }

  
  public String getUnparsedEntityURI( String parm1 )
  {
    if (DEBUG) System.out.println(""getUnparsedEntityURI("" + parm1 + "")"");
    return """";
  }

  
  public DTDHandler getDTDHandler( )
  {
    if (DEBUG) System.out.println(""getDTDHandler()"");
    return null;
  }

  
  public String getPrefix( int parm1 )
  {
    if (DEBUG) System.out.println(""getPrefix("" + parm1  + "")"");
    return """";
  }

  
  public EntityResolver getEntityResolver( )
  {
    if (DEBUG) System.out.println(""getEntityResolver()"");
    return null;
  }

  
  public String getDocumentTypeDeclarationPublicIdentifier( )
  {
    if (DEBUG) System.out.println(""get_DTD_PubId()"");
    return """";
  }

  
  public LexicalHandler getLexicalHandler( )
  {
    if (DEBUG) System.out.println(""getLexicalHandler()"");
    return null;
  }
  
  public boolean needsTwoThreads( )
  {
    if (DEBUG) System.out.println(""needsTwoThreads()"");
    return false;
  }

  
  public ContentHandler getContentHandler( )
  {
    if (DEBUG) System.out.println(""getContentHandler()"");
    return null;
  }

  
  public void dispatchToEvents( int parm1, ContentHandler parm2 )throws org.xml.sax.SAXException
  {
    if (DEBUG)
    {
      System.out.println(
      ""dispathcToEvents("" +
      parm1 + "","" +
      parm2 + "")"");
    }
    return;
  }

  
  public String getNamespaceURI( int parm1 )
  {
    if (DEBUG) System.out.println(""getNamespaceURI("" +parm1+"")"");
    return """";
  }

  
  public void dispatchCharactersEvents( int nodeHandle, ContentHandler ch, boolean normalize )throws org.xml.sax.SAXException
  {
    if (DEBUG)
    {
      System.out.println(""dispatchCharacterEvents("" +
      nodeHandle + "","" +
      ch + "","" +
      normalize + "")"");
    }

    if(normalize)
    {
      XMLString str = getStringValue(nodeHandle);
      str = str.fixWhiteSpace(true, true, false);
      str.dispatchCharactersEvents(ch);
    }
    else
    {
      int type = getNodeType(nodeHandle);
      Node node = getNode(nodeHandle);
      dispatchNodeData(node, ch, 0);
    }
  }

  
  public boolean supportsPreStripping( )
  {
    if (DEBUG) System.out.println(""supportsPreStripping()"");
    return super.supportsPreStripping();
  }

  
  protected int _exptype( int parm1 )
  {
    if (DEBUG) System.out.println(""_exptype("" + parm1 + "")"");
    return super._exptype( parm1);
  }

  
  protected SuballocatedIntVector findNamespaceContext( int parm1 )
  {
    if (DEBUG) System.out.println(""SuballocatedIntVector("" + parm1 + "")"");
    return super.findNamespaceContext( parm1);
  }

  
  protected int _prevsib( int parm1 )
  {
    if (DEBUG) System.out.println(""_prevsib("" + parm1+ "")"");
    return super._prevsib( parm1);
  }


  
  protected short _type( int parm1 )
  {
    if (DEBUG) System.out.println(""_type("" + parm1 + "")"");
    return super._type( parm1);
  }

  
  public Node getNode( int parm1 )
  {
    if (DEBUG) System.out.println(""getNode("" + parm1 + "")"");
    return super.getNode( parm1);
  }

  
  public int getPreviousSibling( int parm1 )
  {
    if (DEBUG) System.out.println(""getPrevSib("" + parm1 + "")"");
    return super.getPreviousSibling( parm1);
  }

  
  public String getDocumentStandalone( int parm1 )
  {
    if (DEBUG) System.out.println(""getDOcStandAlone("" + parm1 + "")"");
    return super.getDocumentStandalone( parm1);
  }

  
  public String getNodeNameX( int parm1 )
  {
    if (DEBUG) System.out.println(""getNodeNameX("" + parm1 + "")"");
    
    return getNodeName(parm1);

  }

  
  public void setFeature( String parm1, boolean parm2 )
  {
    if (DEBUG)
    {
      System.out.println(
        ""setFeature("" +
        parm1 + "","" +
        parm2 + "")"");
    }
    super.setFeature( parm1,  parm2);
  }

  
  protected int _parent( int parm1 )
  {
    if (DEBUG) System.out.println(""_parent("" + parm1 + "")"");
    return super._parent( parm1);
  }

  
  protected void indexNode( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""indexNode(""+parm1+"",""+parm2+"")"");
    super.indexNode( parm1,  parm2);
  }

  
  protected boolean getShouldStripWhitespace( )
  {
    if (DEBUG) System.out.println(""getShouldStripWS()"");
    return super.getShouldStripWhitespace();
  }

  
  protected void popShouldStripWhitespace( )
  {
    if (DEBUG) System.out.println(""popShouldStripWS()"");
    super.popShouldStripWhitespace();
  }

  
  public boolean isNodeAfter( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""isNodeAfter("" + parm1 + "","" + parm2 + "")"");
    return super.isNodeAfter( parm1,  parm2);
  }

  
  public int getNamespaceType( int parm1 )
  {
    if (DEBUG) System.out.println(""getNamespaceType("" + parm1 + "")"");
    return super.getNamespaceType( parm1);
  }

  
  protected int _level( int parm1 )
  {
    if (DEBUG) System.out.println(""_level("" + parm1 + "")"");
    return super._level( parm1);
  }


  
  protected void pushShouldStripWhitespace( boolean parm1 )
  {
    if (DEBUG) System.out.println(""push_ShouldStripWS("" + parm1 + "")"");
    super.pushShouldStripWhitespace( parm1);
  }

  
  public String getDocumentVersion( int parm1 )
  {
    if (DEBUG) System.out.println(""getDocVer(""+parm1+"")"");
    return super.getDocumentVersion( parm1);
  }

  
  public boolean isSupported( String parm1, String parm2 )
  {
    if (DEBUG) System.out.println(""isSupported(""+parm1+"",""+parm2+"")"");
    return super.isSupported( parm1,  parm2);
  }


  
  protected void setShouldStripWhitespace( boolean parm1 )
  {
    if (DEBUG) System.out.println(""set_ShouldStripWS(""+parm1+"")"");
    super.setShouldStripWhitespace( parm1);
  }


  
  protected void ensureSizeOfIndex( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""ensureSizeOfIndex(""+parm1+"",""+parm2+"")"");
    super.ensureSizeOfIndex( parm1,  parm2);
  }

  
  protected void ensureSize( int parm1 )
  {
    if (DEBUG) System.out.println(""ensureSize(""+parm1+"")"");

    
    
    
  }

  
  public String getDocumentEncoding( int parm1 )
  {
    if (DEBUG) System.out.println(""getDocumentEncoding(""+parm1+"")"");
    return super.getDocumentEncoding( parm1);
  }

  
  public void appendChild( int parm1, boolean parm2, boolean parm3 )
  {
    if (DEBUG)
    {
      System.out.println(
        ""appendChild("" +
        parm1 + "","" +
        parm2 + "","" +
        parm3 + "")"");
    }
    super.appendChild( parm1,  parm2,  parm3);
  }

  
  public short getLevel( int parm1 )
  {
    if (DEBUG) System.out.println(""getLevel(""+parm1+"")"");
    return super.getLevel( parm1);
  }

  
  public String getDocumentBaseURI( )
  {
    if (DEBUG) System.out.println(""getDocBaseURI()"");
    return super.getDocumentBaseURI();
  }

  
  public int getNextNamespaceNode( int parm1, int parm2, boolean parm3 )
  {
    if (DEBUG)
    {
      System.out.println(
      ""getNextNamesapceNode("" +
      parm1 + "","" +
      parm2 + "","" +
      parm3 + "")"");
    }
    return super.getNextNamespaceNode( parm1,  parm2,  parm3);
  }

  
  public void appendTextChild( String parm1 )
  {
    if (DEBUG) System.out.println(""appendTextChild("" + parm1 + "")"");
    super.appendTextChild( parm1);
  }

  
  protected int findGTE( int[] parm1, int parm2, int parm3, int parm4 )
  {
    if (DEBUG)
    {
      System.out.println(
      ""findGTE(""+
      parm1 + "","" +
      parm2 + "","" +
      parm3 + "")"");
    }
    return super.findGTE( parm1,  parm2,  parm3,  parm4);
  }

  
  public int getFirstNamespaceNode( int parm1, boolean parm2 )
  {
    if (DEBUG) System.out.println(""getFirstNamespaceNode()"");
    return super.getFirstNamespaceNode( parm1,  parm2);
  }

  
  public int getStringValueChunkCount( int parm1 )
  {
    if (DEBUG) System.out.println(""getStringChunkCount("" + parm1 + "")"");
    return super.getStringValueChunkCount( parm1);
  }

  
  public int getLastChild( int parm1 )
  {
    if (DEBUG) System.out.println(""getLastChild("" + parm1 + "")"");
    return super.getLastChild( parm1);
  }

  
  public boolean hasChildNodes( int parm1 )
  {
    if (DEBUG) System.out.println(""hasChildNodes("" + parm1 + "")"");
    return super.hasChildNodes( parm1);
  }

  
  public short getNodeType( int parm1 )
  {
    if (DEBUG)
    {
      DEBUG=false;
      System.out.print(""getNodeType("" + parm1 + "") "");
      int exID = getExpandedTypeID(parm1);
      String name = getLocalNameFromExpandedNameID(exID);
      System.out.println(
        "".. Node name ["" + name + ""]"" +
        ""["" + getNodeType( parm1) + ""]"");

      DEBUG=true;
    }

    return super.getNodeType( parm1);
  }

  
  public boolean isCharacterElementContentWhitespace( int parm1 )
  {
    if (DEBUG) System.out.println(""isCharacterElementContentWhitespace("" + parm1 +"")"");
    return super.isCharacterElementContentWhitespace( parm1);
  }

  
  public int getFirstChild( int parm1 )
  {
    if (DEBUG) System.out.println(""getFirstChild("" + parm1 + "")"");
    return super.getFirstChild( parm1);
  }

  
  public String getDocumentSystemIdentifier( int parm1 )
  {
    if (DEBUG) System.out.println(""getDocSysID("" + parm1 + "")"");
    return super.getDocumentSystemIdentifier( parm1);
  }

  
  protected void declareNamespaceInContext( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""declareNamespaceContext(""+parm1+"",""+parm2+"")"");
    super.declareNamespaceInContext( parm1,  parm2);
  }

  
  public String getNamespaceFromExpandedNameID( int parm1 )
  {
    if (DEBUG)
    {
      DEBUG = false;
      System.out.print(""getNamespaceFromExpandedNameID(""+parm1+"")"");
      System.out.println(""..."" + super.getNamespaceFromExpandedNameID( parm1) );
      DEBUG = true;
    }
    return super.getNamespaceFromExpandedNameID( parm1);
  }

  
  public String getLocalNameFromExpandedNameID( int parm1 )
  {
    if (DEBUG)
    {
      DEBUG = false;
      System.out.print(""getLocalNameFromExpandedNameID(""+parm1+"")"");
      System.out.println(""..."" + super.getLocalNameFromExpandedNameID( parm1));
      DEBUG = true;
    }
    return super.getLocalNameFromExpandedNameID( parm1);
  }

  
  public int getExpandedTypeID( int parm1 )
  {
    if (DEBUG) System.out.println(""getExpandedTypeID(""+parm1+"")"");
    return super.getExpandedTypeID( parm1);
  }

  
  public int getDocument( )
  {
    if (DEBUG) System.out.println(""getDocument()"");
    return super.getDocument();
  }


  
  protected int findInSortedSuballocatedIntVector( SuballocatedIntVector parm1, int parm2 )
  {
    if (DEBUG)
    {
      System.out.println(
      ""findInSortedSubAlloctedVector("" +
      parm1 + "","" +
      parm2 + "")"");
    }
    return super.findInSortedSuballocatedIntVector( parm1,  parm2);
  }

  
  public boolean isDocumentAllDeclarationsProcessed( int parm1 )
  {
    if (DEBUG) System.out.println(""isDocumentAllDeclProc(""+parm1+"")"");
    return super.isDocumentAllDeclarationsProcessed( parm1);
  }

  
  protected void error( String parm1 )
  {
    if (DEBUG) System.out.println(""error(""+parm1+"")"");
    super.error( parm1);
  }


  
  protected int _firstch( int parm1 )
  {
    if (DEBUG) System.out.println(""_firstch(""+parm1+"")"");
    return super._firstch( parm1);
  }

  
  public int getOwnerDocument( int parm1 )
  {
    if (DEBUG) System.out.println(""getOwnerDoc(""+parm1+"")"");
    return super.getOwnerDocument( parm1);
  }

  
  protected int _nextsib( int parm1 )
  {
    if (DEBUG) System.out.println(""_nextSib(""+parm1+"")"");
    return super._nextsib( parm1);
  }

  
  public int getNextSibling( int parm1 )
  {
    if (DEBUG) System.out.println(""getNextSibling(""+parm1+"")"");
    return super.getNextSibling( parm1);
  }


  
  public boolean getDocumentAllDeclarationsProcessed( )
  {
    if (DEBUG) System.out.println(""getDocAllDeclProc()"");
    return super.getDocumentAllDeclarationsProcessed();
  }

  
  public int getParent( int parm1 )
  {
    if (DEBUG) System.out.println(""getParent(""+parm1+"")"");
    return super.getParent( parm1);
  }

  
  public int getExpandedTypeID( String parm1, String parm2, int parm3 )
  {
    if (DEBUG) System.out.println(""getExpandedTypeID()"");
    return super.getExpandedTypeID( parm1,  parm2,  parm3);
  }

  
  public void setDocumentBaseURI( String parm1 )
  {
    if (DEBUG) System.out.println(""setDocBaseURI()"");
    super.setDocumentBaseURI( parm1);
  }

  
  public char[] getStringValueChunk( int parm1, int parm2, int[] parm3 )
  {
    if (DEBUG)
    {
      System.out.println(""getStringChunkValue("" +
      parm1 + "","" +
      parm2 + "")"");
    }
    return super.getStringValueChunk( parm1,  parm2,  parm3);
  }

  
  public DTMAxisTraverser getAxisTraverser( int parm1 )
  {
    if (DEBUG) System.out.println(""getAxixTraverser(""+parm1+"")"");
    return super.getAxisTraverser( parm1);
  }

  
  public DTMAxisIterator getTypedAxisIterator( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""getTypedAxisIterator(""+parm1+"",""+parm2+"")"");
    return super.getTypedAxisIterator( parm1,  parm2);
  }

  
  public DTMAxisIterator getAxisIterator( int parm1 )
  {
    if (DEBUG) System.out.println(""getAxisIterator(""+parm1+"")"");
    return super.getAxisIterator( parm1);
  }
  
  public int getElementById( String parm1 )
  {
    if (DEBUG) System.out.println(""getElementByID(""+parm1+"")"");
    return DTM.NULL;
  }

  
  public DeclHandler getDeclHandler( )
  {
    if (DEBUG) System.out.println(""getDeclHandler()"");
    return null;
  }

  
  public ErrorHandler getErrorHandler( )
  {
    if (DEBUG) System.out.println(""getErrorHandler()"");
    return null;
  }

  
  public String getDocumentTypeDeclarationSystemIdentifier( )
  {
    if (DEBUG) System.out.println(""get_DTD-SID()"");
    return null;
  }


}
"
org.apache.xpath.operations.String,2,3,0,5,4,1,1,4,2,2.0,9,0.0,0,0.975609756,0.75,1,1,3.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class String extends UnaryOperation
{

  
  public XObject operate(XObject right) throws javax.xml.transform.TransformerException
  {
    return (XString)right.xstr(); 
  }
}
"
org.apache.xalan.xsltc.compiler.Predicate,21,3,0,61,108,68,4,60,20,0.765,1079,1.0,4,0.78021978,0.210884354,2,8,49.9047619,12,3.1429,4,"

package org.apache.xalan.xsltc.compiler;

import java.util.ArrayList;

import org.apache.bcel.classfile.Field;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.xalan.xsltc.compiler.util.BooleanType;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.FilterGenerator;
import org.apache.xalan.xsltc.compiler.util.IntType;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NumberType;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.ResultTreeType;
import org.apache.xalan.xsltc.compiler.util.TestGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class Predicate extends Expression implements Closure {

    private Expression _exp = null; 
    private boolean _nthPositionFilter = false;
    private boolean _nthDescendant = false;
    private boolean _canOptimize = true;
    private int     _ptype = -1;

    private String _className = null;
    private ArrayList _closureVars = null;
    private Closure _parentClosure = null;

    public Predicate(Expression exp) {
	(_exp = exp).setParent(this);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_exp.setParser(parser);
    }

    public boolean isNthDescendant() {
	return _nthDescendant;
    }

    public boolean isNthPositionFilter() {
	return _nthPositionFilter;
    }

    public void dontOptimize() {
	_canOptimize = false;
    }

    

    
    public boolean inInnerClass() {
	return (_className != null);
    }

    
    public Closure getParentClosure() {
	if (_parentClosure == null) {
	    SyntaxTreeNode node = getParent();
	    do {
		if (node instanceof Closure) {
		    _parentClosure = (Closure) node;
		    break;
		}
		if (node instanceof TopLevelElement) {
		    break;	
		}
		node = node.getParent();
	    } while (node != null);
	}
	return _parentClosure;
    }

    
    public String getInnerClassName() {
	return _className;
    }

    
    public void addVariable(VariableRefBase variableRef) {
	if (_closureVars == null) {
	    _closureVars = new ArrayList();
	}

	
	if (!_closureVars.contains(variableRef)) {
	    _closureVars.add(variableRef);

	    
	    Closure parentClosure = getParentClosure();
	    if (parentClosure != null) {
		parentClosure.addVariable(variableRef);
	    }
	}
    }

    

    public int getPosType() {
	if (_ptype == -1) {
	    SyntaxTreeNode parent = getParent();
	    if (parent instanceof StepPattern) {
		_ptype = ((StepPattern)parent).getNodeType();
	    }
	    else if (parent instanceof AbsoluteLocationPath) {
		AbsoluteLocationPath path = (AbsoluteLocationPath)parent;
		Expression exp = path.getPath();
		if (exp instanceof Step) {
		    _ptype = ((Step)exp).getNodeType();
		}
	    }
	    else if (parent instanceof VariableRefBase) {
		final VariableRefBase ref = (VariableRefBase)parent;
		final VariableBase var = ref.getVariable();
		final Expression exp = var.getExpression();
		if (exp instanceof Step) {
		    _ptype = ((Step)exp).getNodeType();
		}
	    }
	    else if (parent instanceof Step) {
		_ptype = ((Step)parent).getNodeType();
	    }
	}
	return _ptype;
    }

    public boolean parentIsPattern() {
	return (getParent() instanceof Pattern);
    }

    public Expression getExpr() {
	return _exp;
    }

    public String toString() {
	if (isNthPositionFilter())
	    return ""pred(["" + _exp + ""],""+getPosType()+"")"";
	else
	    return ""pred("" + _exp + ')';
    }
	
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	Type texp = _exp.typeCheck(stable);

	
	if (texp instanceof ReferenceType) {
	    _exp = new CastExpr(_exp, texp = Type.Real);
	}

	
	
	
	if (texp instanceof ResultTreeType) {
	    _exp = new CastExpr(_exp, Type.Boolean);
	    _exp = new CastExpr(_exp, Type.Real);
	    texp = _exp.typeCheck(stable);
	}

	
	if (texp instanceof NumberType) {

	    
	    if (texp instanceof IntType == false) {
		_exp = new CastExpr(_exp, Type.Int);
	    }

	    SyntaxTreeNode parent = getParent();

	    
	    if ((_exp instanceof LastCall) ||
		(parent instanceof Pattern) ||
		(parent instanceof FilterExpr)) {

		if (parent instanceof Pattern && !(_exp instanceof LastCall)) {
 		    _nthPositionFilter = _canOptimize;
		}
		else if (parent instanceof FilterExpr) {
		    FilterExpr filter = (FilterExpr)parent;
		    Expression fexp = filter.getExpr();

		    if (fexp instanceof KeyCall)
			_canOptimize = false;
		    else if (fexp instanceof VariableRefBase)
		        _canOptimize = false;
		    else if (fexp instanceof ParentLocationPath)
			_canOptimize = false;
		    else if (fexp instanceof UnionPathExpr)
			_canOptimize = false;
		    else if (_exp.hasPositionCall() && _exp.hasLastCall())
			_canOptimize = false;
		    else if (filter.getParent() instanceof FilterParentPath)
			_canOptimize = false;
		    if (_canOptimize)
			_nthPositionFilter = true;
		}

                
                
                
                if (_nthPositionFilter) {
                   return _type = Type.NodeSet;
                } else {
                   final QName position =
                                getParser().getQNameIgnoreDefaultNs(""position"");

                   final PositionCall positionCall =
                                               new PositionCall(position);
                   positionCall.setParser(getParser());
                   positionCall.setParent(this);

                   _exp = new EqualityExpr(EqualityExpr.EQ, positionCall,
                                            _exp);
                   if (_exp.typeCheck(stable) != Type.Boolean) {
                       _exp = new CastExpr(_exp, Type.Boolean);
                   }

                   return _type = Type.Boolean;
                }
	    }
	    
	    else {
		if ((parent != null) && (parent instanceof Step)) {
		    parent = parent.getParent();
		    if ((parent != null) &&
			(parent instanceof AbsoluteLocationPath)) {
			
			_nthDescendant = true;
			return _type = Type.NodeSet;
		    }
		}
		_nthPositionFilter = true;
		return _type = Type.NodeSet;
	    }
	}
	else if (texp instanceof BooleanType) {
	    if (_exp.hasPositionCall())
		_nthPositionFilter = true;
	}
	
	else {
	    _exp = new CastExpr(_exp, Type.Boolean);
	}
	_nthPositionFilter = false;

	return _type = Type.Boolean;
    }
	
    
    private void compileFilter(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	TestGenerator testGen;
	LocalVariableGen local;
	FilterGenerator filterGen;

	_className = getXSLTC().getHelperClassName();
	filterGen = new FilterGenerator(_className,
					""java.lang.Object"",
					toString(), 
					ACC_PUBLIC | ACC_SUPER,
					new String[] {
					    CURRENT_NODE_LIST_FILTER
					},
					classGen.getStylesheet());	

	final ConstantPoolGen cpg = filterGen.getConstantPool();
	final int length = (_closureVars == null) ? 0 : _closureVars.size();

	
	for (int i = 0; i < length; i++) {
	    VariableBase var = ((VariableRefBase) _closureVars.get(i)).getVariable();

	    filterGen.addField(new Field(ACC_PUBLIC, 
					cpg.addUtf8(var.getVariable()),
					cpg.addUtf8(var.getType().toSignature()),
					null, cpg.getConstantPool()));
	}

	final InstructionList il = new InstructionList();
	testGen = new TestGenerator(ACC_PUBLIC | ACC_FINAL,
				    org.apache.bcel.generic.Type.BOOLEAN, 
				    new org.apache.bcel.generic.Type[] {
					org.apache.bcel.generic.Type.INT,
					org.apache.bcel.generic.Type.INT,
					org.apache.bcel.generic.Type.INT,
					org.apache.bcel.generic.Type.INT,
					Util.getJCRefType(TRANSLET_SIG),
					Util.getJCRefType(NODE_ITERATOR_SIG)
				    },
				    new String[] {
					""node"",
					""position"",
					""last"",
					""current"",
					""translet"",
					""iterator""
				    },
				    ""test"", _className, il, cpg);
		
	
	local = testGen.addLocalVariable(""document"",
					 Util.getJCRefType(DOM_INTF_SIG),
					 null, null);
	final String className = classGen.getClassName();
	il.append(filterGen.loadTranslet());
	il.append(new CHECKCAST(cpg.addClass(className)));
	il.append(new GETFIELD(cpg.addFieldref(className,
					       DOM_FIELD, DOM_INTF_SIG)));
	il.append(new ASTORE(local.getIndex()));

	
	testGen.setDomIndex(local.getIndex());

	_exp.translate(filterGen, testGen);
	il.append(IRETURN);
	
	testGen.stripAttributes(true);
	testGen.setMaxLocals();
	testGen.setMaxStack();
	testGen.removeNOPs();
	filterGen.addEmptyConstructor(ACC_PUBLIC);
	filterGen.addMethod(testGen.getMethod());
		
	getXSLTC().dumpClass(filterGen.getJavaClass());
    }

    
    public boolean isBooleanTest() {
	return (_exp instanceof BooleanExpr);
    }

    
    public boolean isNodeValueTest() {
	if (!_canOptimize) return false;
	return (getStep() != null && getCompareValue() != null);
    }

    private Expression _value = null;
    private Step _step = null;

    
    public Expression getCompareValue() {
	if (_value != null) return _value;
	if (_exp == null) return null;

	if (_exp instanceof EqualityExpr) {
	    EqualityExpr exp = (EqualityExpr)_exp;
	    Expression left = exp.getLeft();
	    Expression right = exp.getRight();

	    Type tleft = left.getType();
	    Type tright = right.getType();

	    
	    if (left instanceof CastExpr) left = ((CastExpr)left).getExpr();
	    if (right instanceof CastExpr) right = ((CastExpr)right).getExpr();
	    
	    try {
		if ((tleft == Type.String) && (!(left instanceof Step)))
		    _value = exp.getLeft();
		if (left instanceof VariableRefBase) 
		    _value = new CastExpr(left, Type.String);
		if (_value != null) return _value;
	    }
	    catch (TypeCheckError e) { }

	    try {
		if ((tright == Type.String) && (!(right instanceof Step)))
		    _value = exp.getRight();
		if (right instanceof VariableRefBase)
		    _value = new CastExpr(right, Type.String);
		if (_value != null) return _value;
	    }
	    catch (TypeCheckError e) { }

	}
	return null;
    }

    
    public Step getStep() {
	if (_step != null) return _step;
	if (_exp == null) return null;

	if (_exp instanceof EqualityExpr) {
	    EqualityExpr exp = (EqualityExpr)_exp;
	    Expression left = exp.getLeft();
	    Expression right = exp.getRight();

	    if (left instanceof CastExpr) left = ((CastExpr)left).getExpr();
	    if (left instanceof Step) _step = (Step)left;
	    
	    if (right instanceof CastExpr) right = ((CastExpr)right).getExpr();
	    if (right instanceof Step) _step = (Step)right;
	}
	return _step;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_nthPositionFilter || _nthDescendant) {
	    _exp.translate(classGen, methodGen);
	}
	else if (isNodeValueTest() && (getParent() instanceof Step)) {
	    _value.translate(classGen, methodGen);
	    il.append(new CHECKCAST(cpg.addClass(STRING_CLASS)));
	    il.append(new PUSH(cpg, ((EqualityExpr)_exp).getOp()));
	}
	else {
	    translateFilter(classGen, methodGen);
	}
    }

    
    public void translateFilter(ClassGenerator classGen,
				MethodGenerator methodGen) 
    {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	compileFilter(classGen, methodGen);
	
	
	il.append(new NEW(cpg.addClass(_className)));
	il.append(DUP);
	il.append(new INVOKESPECIAL(cpg.addMethodref(_className,
						     ""<init>"", ""()V"")));

	
	final int length = (_closureVars == null) ? 0 : _closureVars.size();

	for (int i = 0; i < length; i++) {
	    VariableRefBase varRef = (VariableRefBase) _closureVars.get(i);
	    VariableBase var = varRef.getVariable();
	    Type varType = var.getType();

	    il.append(DUP);

	    
	    Closure variableClosure = _parentClosure;
	    while (variableClosure != null) {
		if (variableClosure.inInnerClass()) break;
		variableClosure = variableClosure.getParentClosure();
	    }

	    
	    if (variableClosure != null) {
		il.append(ALOAD_0);
		il.append(new GETFIELD(
		    cpg.addFieldref(variableClosure.getInnerClassName(), 
			var.getVariable(), varType.toSignature())));
	    }
	    else {
		
		il.append(var.loadInstruction());
	    }

	    
	    il.append(new PUTFIELD(
		    cpg.addFieldref(_className, var.getVariable(), 
			varType.toSignature())));
	}
    }
}
"
org.apache.xml.dtm.DTMIterator,25,1,0,53,25,300,52,2,25,1.041666667,28,0.0,0,0.0,0.34,0,0,0.0,1,1.0,0,"
package org.apache.xml.dtm;


public interface DTMIterator
{

  
  
  

  
  public static final short FILTER_ACCEPT = 1;

  
  public static final short FILTER_REJECT = 2;

  
  public static final short FILTER_SKIP = 3;
    
  
  public DTM getDTM(int nodeHandle);
  
  
  public DTMManager getDTMManager();

  
  public int getRoot();

  
  public void setRoot(int nodeHandle, Object environment);
  
  
  public void reset();

  
  public int getWhatToShow();

  
  public boolean getExpandEntityReferences();

  
  public int nextNode();

  
  public int previousNode();

  
  public void detach();
  
  
  public void allowDetachToRelease(boolean allowRelease);

  
  public int getCurrentNode();

  
  public boolean isFresh();

  

  
  public void setShouldCacheNodes(boolean b);
  
  
  public boolean isMutable();

  
  public int getCurrentPos();

  
  public void runTo(int index);

  
  public void setCurrentPos(int i);

  
  public int item(int index);
  
  
  public void setItem(int node, int index);
  
  
  public int getLength();
    
  
  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException;

  
  public Object clone() throws CloneNotSupportedException;
  
  
  public boolean isDocOrdered();
  
  
  public int getAxis();

}
"
org.apache.xml.utils.StringBufferPool,5,1,0,7,13,4,5,2,3,0.75,44,0.5,1,0.0,0.25,0,0,7.4,1,0.6,1,"
package org.apache.xml.utils;


public class StringBufferPool
{

  
  private static ObjectPool m_stringBufPool =
    new ObjectPool(org.apache.xml.utils.FastStringBuffer.class);

  
  public synchronized static FastStringBuffer get()
  {
    return (FastStringBuffer) m_stringBufPool.getInstance();
  }

  
  public synchronized static void free(FastStringBuffer sb)
  {
    
    
    
    sb.setLength(0);
    m_stringBufPool.freeInstance(sb);
  }
}
"
org.apache.xalan.templates.AVTPartSimple,5,2,0,6,7,4,1,5,5,0.5,22,1.0,0,0.555555556,0.325,0,0,3.2,1,0.8,1,"
package org.apache.xalan.templates;

import org.apache.xml.utils.FastStringBuffer;
import org.apache.xpath.XPathContext;


public class AVTPartSimple extends AVTPart
{

  
  private String m_val;

  
  public AVTPartSimple(String val)
  {
    m_val = val;
  }

  
  public String getSimpleString()
  {
    return m_val;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }


  
  public void evaluate(XPathContext xctxt, FastStringBuffer buf,
                       int context,
                       org.apache.xml.utils.PrefixResolver nsNode)
  {
    buf.append(m_val);
  }
  
  public void callVisitors(XSLTVisitor visitor)
  {
  	
  }

}
"
org.apache.xalan.xsltc.trax.TransformerFactoryImpl,34,3,0,14,143,369,5,13,24,0.903263403,1703,0.576923077,0,0.384615385,0.142857143,1,2,48.32352941,17,2.0882,5,"

package org.apache.xalan.xsltc.trax;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FilenameFilter;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Vector;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;

import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TemplatesHandler;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.compiler.SourceLoader;
import org.apache.xalan.xsltc.compiler.XSLTC;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.runtime.TransletLoader;

import org.xml.sax.InputSource;
import org.xml.sax.XMLFilter;
import org.xml.sax.XMLReader;


public class TransformerFactoryImpl
    extends SAXTransformerFactory implements SourceLoader, ErrorListener 
{
    
    public final static String TRANSLET_NAME = ""translet-name"";
    public final static String DESTINATION_DIRECTORY = ""destination-directory"";
    public final static String PACKAGE_NAME = ""package-name"";
    public final static String JAR_NAME = ""jar-name"";
    public final static String GENERATE_TRANSLET = ""generate-translet"";
    public final static String AUTO_TRANSLET = ""auto-translet"";
    public final static String USE_CLASSPATH = ""use-classpath"";
    public final static String DEBUG = ""debug"";
    public final static String ENABLE_INLINING = ""enable-inlining"";
    public final static String INDENT_NUMBER = ""indent-number"";
    
    
    private ErrorListener _errorListener = this; 

    
    private URIResolver _uriResolver = null;

    
    protected static String DEFAULT_TRANSLET_NAME = ""GregorSamsa"";
    
    
    private String _transletName = DEFAULT_TRANSLET_NAME;
    
    
    private String _destinationDirectory = null;
    
    
    private String _packageName = null;
    
    
    private String _jarFileName = null;

    
    private Hashtable _piParams = null;


    
    static ThreadLocal _xmlReader = new ThreadLocal();

    
    private static class PIParamWrapper {
	public String _media = null;
	public String _title = null;
	public String _charset = null;
	
	public PIParamWrapper(String media, String title, String charset) {
	    _media = media;
	    _title = title;
	    _charset = charset;
	}
    }

    
    private boolean _debug = false;

    
    private boolean _enableInlining = false;
    
    
    private boolean _generateTranslet = false;
    
    
    private boolean _autoTranslet = false;
    
    
    private boolean _useClasspath = false;

    
    private int _indentNumber = -1;

    
    private SAXParserFactory _parserFactory = null;

    
    public TransformerFactoryImpl() {
    }

    
    public void setErrorListener(ErrorListener listener) 
	throws IllegalArgumentException 
    {
	if (listener == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ERROR_LISTENER_NULL_ERR,
					""TransformerFactory"");
            throw new IllegalArgumentException(err.toString());
	}
	_errorListener = listener;
    }

    
    public ErrorListener getErrorListener() { 
	return _errorListener;
    }

    
    public Object getAttribute(String name) 
	throws IllegalArgumentException 
    { 
	
	if (name.equals(TRANSLET_NAME)) {
	    return _transletName;
	}
	else if (name.equals(GENERATE_TRANSLET)) {
	    return new Boolean(_generateTranslet);
	}
	else if (name.equals(AUTO_TRANSLET)) {
	    return new Boolean(_autoTranslet);
	}

	
	ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_INVALID_ATTR_ERR, name);
	throw new IllegalArgumentException(err.toString());
    }

    
    public void setAttribute(String name, Object value) 
	throws IllegalArgumentException 
    { 
	
	
	if (name.equals(TRANSLET_NAME) && value instanceof String) {
	    _transletName = (String) value;	      
	    return;
	}
	else if (name.equals(DESTINATION_DIRECTORY) && value instanceof String) {
	    _destinationDirectory = (String) value;
	    return;
	}
	else if (name.equals(PACKAGE_NAME) && value instanceof String) {
	    _packageName = (String) value;
	    return;
	}
	else if (name.equals(JAR_NAME) && value instanceof String) {
	    _jarFileName = (String) value;
	    return;
	}
	else if (name.equals(GENERATE_TRANSLET)) {
	    if (value instanceof Boolean) {
		_generateTranslet = ((Boolean) value).booleanValue();
		return;
	    }
	    else if (value instanceof String) {
		_generateTranslet = ((String) value).equalsIgnoreCase(""true"");
		return;
	    }
	}
	else if (name.equals(AUTO_TRANSLET)) {
	    if (value instanceof Boolean) {
		_autoTranslet = ((Boolean) value).booleanValue();
		return;
	    }
	    else if (value instanceof String) {
		_autoTranslet = ((String) value).equalsIgnoreCase(""true"");
		return;
	    }
	}
	else if (name.equals(USE_CLASSPATH)) {
	    if (value instanceof Boolean) {
		_useClasspath = ((Boolean) value).booleanValue();
		return;
	    }
	    else if (value instanceof String) {
		_useClasspath = ((String) value).equalsIgnoreCase(""true"");
		return;
	    }	    
	}
	else if (name.equals(DEBUG)) {
	    if (value instanceof Boolean) {
		_debug = ((Boolean) value).booleanValue();
		return;
	    }
	    else if (value instanceof String) {
		_debug = ((String) value).equalsIgnoreCase(""true"");
		return;
	    }
	}
	else if (name.equals(ENABLE_INLINING)) {
	    if (value instanceof Boolean) {
		_enableInlining = ((Boolean) value).booleanValue();
		return;
	    }
	    else if (value instanceof String) {
		_enableInlining = ((String) value).equalsIgnoreCase(""true"");
		return;
	    }
	}
	else if (name.equals(INDENT_NUMBER)) {
	    if (value instanceof String) {
		try {
		    _indentNumber = Integer.parseInt((String) value);
		    return;
		}
		catch (NumberFormatException e) {
		    
		}
	    }
	    else if (value instanceof Integer) {
		_indentNumber = ((Integer) value).intValue();
		return;
	    }
	}

	
	final ErrorMsg err 
	    = new ErrorMsg(ErrorMsg.JAXP_INVALID_ATTR_ERR, name);
	throw new IllegalArgumentException(err.toString());
    }

    
    public boolean getFeature(String name) { 
	
	String[] features = {
	    DOMSource.FEATURE,
	    DOMResult.FEATURE,
	    SAXSource.FEATURE,
	    SAXResult.FEATURE,
	    StreamSource.FEATURE,
	    StreamResult.FEATURE
	};

	
	for (int i =0; i < features.length; i++) {
	    if (name.equals(features[i])) {
		return true;
	    }
	}
	
	return false;
    }

        
    public URIResolver getURIResolver() {
	return _uriResolver;
    } 

        
    public void setURIResolver(URIResolver resolver) {
	_uriResolver = resolver;
    }

    
    public Source getAssociatedStylesheet(Source source, String media,
					  String title, String charset)
	throws TransformerConfigurationException 
    {
	
	if (_piParams == null) {
	    _piParams = new Hashtable();
	}
	
	_piParams.put(source, new PIParamWrapper(media, title, charset));
	
	return source;
    }

        
    public Transformer newTransformer()
	throws TransformerConfigurationException 
    { 
	TransformerImpl result = new TransformerImpl(new Properties(), 
	    _indentNumber, this);
	if (_uriResolver != null) {
	    result.setURIResolver(_uriResolver);
	}
	return result;
    }

    
    public Transformer newTransformer(Source source) throws
	TransformerConfigurationException 
    {
	final Templates templates = newTemplates(source);
	final Transformer transformer = templates.newTransformer();
	if (_uriResolver != null) {
	    transformer.setURIResolver(_uriResolver);
	}
	return(transformer);
    }

    
    private void passWarningsToListener(Vector messages) 
	throws TransformerException 
    {
	if (_errorListener == null || messages == null) {
	    return;
	}
	
	final int count = messages.size();
	for (int pos = 0; pos < count; pos++) {
	    String message = messages.elementAt(pos).toString();
	    _errorListener.error(
		new TransformerConfigurationException(message));
	}
    }

    
    private void passErrorsToListener(Vector messages) {
	try {
	    if (_errorListener == null || messages == null) {
		return;
	    }
	    
	    final int count = messages.size();
	    for (int pos = 0; pos < count; pos++) {
		String message = messages.elementAt(pos).toString();
		_errorListener.error(new TransformerException(message));
	    }
	}
	catch (TransformerException e) {
	    
	}
    }

    
    private Class loadTranslet(String name)
        throws ClassNotFoundException
    {
	
	try {
	    TransletLoader loader = new TransletLoader();
	    return loader.loadTranslet(name);
	}
	catch (ClassNotFoundException e) {
	    
	    return Class.forName(name);
	}
    }
    
    
    public Templates newTemplates(Source source)
	throws TransformerConfigurationException 
    {
	
	
	
	if (_useClasspath) {
	    String transletName = getTransletBaseName(source);
	            
	    if (_packageName != null)
	        transletName = _packageName + ""."" + transletName;
	        
	    try {
	        final Class clazz = loadTranslet(transletName);
	        final Translet translet = (Translet)clazz.newInstance();	            
	        resetTransientAttributes();
	            
	        return new TemplatesImpl(translet, transletName, null, _indentNumber, this);
	    }
	    catch (ClassNotFoundException cnfe) {
	        ErrorMsg err = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, transletName);
	        throw new TransformerConfigurationException(err.toString());
	    }
	    catch (Exception e) {
	        ErrorMsg err = new ErrorMsg(
                                     new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY)
                                     + e.getMessage());
	        throw new TransformerConfigurationException(err.toString());
	    }
	}
	
	
	
	if (_autoTranslet)  {
	    byte[][] bytecodes = null;
	    String transletClassName = getTransletBaseName(source);
	    
	    if (_packageName != null)
	        transletClassName = _packageName + ""."" + transletClassName;
	    
	    if (_jarFileName != null)
	    	bytecodes = getBytecodesFromJar(source, transletClassName);
	    else
	    	bytecodes = getBytecodesFromClasses(source, transletClassName);	    
	  
	    if (bytecodes != null) {
	    	if (_debug) {
	      	    if (_jarFileName != null)
	        	System.err.println(new ErrorMsg(
	            	    ErrorMsg.TRANSFORM_WITH_JAR_STR, transletClassName, _jarFileName));
	            else
	            	System.err.println(new ErrorMsg(
	            	    ErrorMsg.TRANSFORM_WITH_TRANSLET_STR, transletClassName));
	    	}

	    	
	    	
	    	resetTransientAttributes();
	    
	    	return new TemplatesImpl(bytecodes, transletClassName, null, _indentNumber, this);	    
	    }
	}
	
	
	final XSLTC xsltc = new XSLTC();
	if (_debug) xsltc.setDebug(true);
	if (_enableInlining) xsltc.setTemplateInlining(true);
	xsltc.init();

	
	if (_uriResolver != null) {
	    xsltc.setSourceLoader(this);
	}

	
	
	if ((_piParams != null) && (_piParams.get(source) != null)) {
	    
	    PIParamWrapper p = (PIParamWrapper)_piParams.get(source);
	    
	    if (p != null) {
		xsltc.setPIParameters(p._media, p._title, p._charset);
	    }
	}

	
	int outputType = XSLTC.BYTEARRAY_OUTPUT;
	if (_generateTranslet || _autoTranslet) {
	    
	    xsltc.setClassName(getTransletBaseName(source));
	  
	    if (_destinationDirectory != null)
	    	xsltc.setDestDirectory(_destinationDirectory);
	    else {
	    	String xslName = getStylesheetFileName(source);
	    	if (xslName != null) {
	      	    File xslFile = new File(xslName);
	            String xslDir = xslFile.getParent();
	    
	      	    if (xslDir != null)
	                xsltc.setDestDirectory(xslDir);
	    	}
	    }
	  
	    if (_packageName != null)
	        xsltc.setPackageName(_packageName);
	
	    if (_jarFileName != null) {
	    	xsltc.setJarFileName(_jarFileName);
	    	outputType = XSLTC.BYTEARRAY_AND_JAR_OUTPUT;
	    }
	    else
	    	outputType = XSLTC.BYTEARRAY_AND_FILE_OUTPUT;
	}

	
	final InputSource input = Util.getInputSource(xsltc, source);
	byte[][] bytecodes = xsltc.compile(null, input, outputType);
	final String transletName = xsltc.getClassName();

	
	if ((_generateTranslet || _autoTranslet)
	   	&& bytecodes != null && _jarFileName != null) {
	    try {
	    	xsltc.outputToJar();
	    }
	    catch (java.io.IOException e) { }
	}

	
	
	resetTransientAttributes();

	
	if (_errorListener != this) {
	    try {
		passWarningsToListener(xsltc.getWarnings());
	    }
	    catch (TransformerException e) {
		throw new TransformerConfigurationException(e);
	    }
	}
	else {
	    xsltc.printWarnings();
	}

	
    if (bytecodes == null) {
        
        ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR);
        TransformerConfigurationException exc =  new TransformerConfigurationException(err.toString());
        
        
        if (_errorListener != null) {
            passErrorsToListener(xsltc.getErrors());
            
            
            
            
            try {
                _errorListener.fatalError(exc);
            } catch (TransformerException te) {
                
            }    
        }
        else {
            xsltc.printErrors();
        }
        throw exc;
    }

	return new TemplatesImpl(bytecodes, transletName, 
	    xsltc.getOutputProperties(), _indentNumber, this);
    }

    
    public TemplatesHandler newTemplatesHandler() 
	throws TransformerConfigurationException 
    { 
	final TemplatesHandlerImpl handler = 
	    new TemplatesHandlerImpl(_indentNumber, this);
	if (_uriResolver != null) {
	    handler.setURIResolver(_uriResolver);
	}
	return handler;
    }

    
    public TransformerHandler newTransformerHandler() 
	throws TransformerConfigurationException 
    {
	final Transformer transformer = newTransformer();
	if (_uriResolver != null) {
	    transformer.setURIResolver(_uriResolver);
	}
	return new TransformerHandlerImpl((TransformerImpl) transformer);
    }

    
    public TransformerHandler newTransformerHandler(Source src) 
	throws TransformerConfigurationException 
    { 
	final Transformer transformer = newTransformer(src);
	if (_uriResolver != null) {
	    transformer.setURIResolver(_uriResolver);
	}
	return new TransformerHandlerImpl((TransformerImpl) transformer);
    }

        
    public TransformerHandler newTransformerHandler(Templates templates) 
	throws TransformerConfigurationException  
    {
	final Transformer transformer = templates.newTransformer();
	final TransformerImpl internal = (TransformerImpl)transformer;
	return new TransformerHandlerImpl(internal);
    }

    
    public XMLFilter newXMLFilter(Source src) 
	throws TransformerConfigurationException 
    {
	Templates templates = newTemplates(src);
	if (templates == null) return null; 
	return newXMLFilter(templates);
    }

    
    public XMLFilter newXMLFilter(Templates templates) 
	throws TransformerConfigurationException 
    {
	try {
      	    return new org.apache.xalan.xsltc.trax.TrAXFilter(templates);
    	}
	catch (TransformerConfigurationException e1) {
      	    if (_errorListener != null) {
                try {
          	    _errorListener.fatalError(e1);
          	    return null;
        	}
		catch (TransformerException e2) {
          	    new TransformerConfigurationException(e2);
        	}
      	    }
      	    throw e1;
    	}
    }

    
    public void error(TransformerException e)
	throws TransformerException 
    {
	Throwable wrapped = e.getException();
        if (wrapped != null) {
            System.err.println(new ErrorMsg(ErrorMsg.ERROR_PLUS_WRAPPED_MSG,
                                            e.getMessageAndLocation(),
                                            wrapped.getMessage()));
        } else {
            System.err.println(new ErrorMsg(ErrorMsg.ERROR_MSG,
                                            e.getMessageAndLocation()));
	}
	throw e; 	
    }

    
    public void fatalError(TransformerException e)
	throws TransformerException 
    {
	Throwable wrapped = e.getException();
        if (wrapped != null) {
            System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_PLUS_WRAPPED_MSG,
                                            e.getMessageAndLocation(),
                                            wrapped.getMessage()));
        } else {
            System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_MSG,
                                            e.getMessageAndLocation()));
        }
	throw e;
    }

    
    public void warning(TransformerException e)
	throws TransformerException 
    {
	Throwable wrapped = e.getException();
	if (wrapped != null) {
            System.err.println(new ErrorMsg(ErrorMsg.WARNING_PLUS_WRAPPED_MSG,
                                            e.getMessageAndLocation(),
                                            wrapped.getMessage()));
	} else {
            System.err.println(new ErrorMsg(ErrorMsg.WARNING_MSG,
                                            e.getMessageAndLocation()));
        }
    }

    
    public InputSource loadSource(String href, String context, XSLTC xsltc) {
	try {
	    if (_uriResolver != null) {
		final Source source = _uriResolver.resolve(href, context);
		if (source != null) {
		    return Util.getInputSource(xsltc, source);
		}
	    }
	}
	catch (TransformerException e) {
	    
	}
	return null;
    }

    
    public synchronized XMLReader getXMLReader() throws Exception {
	
	if (_parserFactory == null) {
	    _parserFactory = SAXParserFactory.newInstance();
	    _parserFactory.setNamespaceAware(true);
	}
	XMLReader result = (XMLReader) _xmlReader.get();
	if (result == null) {
	    _xmlReader.set(
		result = _parserFactory.newSAXParser().getXMLReader());
	}
	return result;
    }
    
    
    private void resetTransientAttributes() {
	_transletName = DEFAULT_TRANSLET_NAME;
	_destinationDirectory = null;
	_packageName = null;
	_jarFileName = null;    
    }
        
    
    private byte[][] getBytecodesFromClasses(Source source, String fullClassName)
    {
    	if (fullClassName == null)
    	    return null;
    	  
    	String xslFileName = getStylesheetFileName(source);
    	File xslFile = null;
    	if (xslFileName != null)
    	    xslFile = new File(xslFileName);
    	
    	
    	final String transletName;
    	int lastDotIndex = fullClassName.lastIndexOf('.');
    	if (lastDotIndex > 0)
    	    transletName = fullClassName.substring(lastDotIndex+1);
    	else
    	    transletName = fullClassName;
    	    	
    	
    	String transletPath = fullClassName.replace('.', '/');
    	if (_destinationDirectory != null) {
    	    transletPath = _destinationDirectory + ""/"" + transletPath + "".class"";
    	}
    	else {
    	    if (xslFile != null && xslFile.getParent() != null)
    	    	transletPath = xslFile.getParent() + ""/"" + transletPath + "".class"";
    	    else
    	    	transletPath = transletPath + "".class"";
    	}
    	    	    	
    	
    	File transletFile = new File(transletPath);
    	if (!transletFile.exists())
    	    return null;
    	    	  
    	
    	
    	
    	
    	if (xslFile != null && xslFile.exists()) {
    	    long xslTimestamp = xslFile.lastModified();
    	    long transletTimestamp = transletFile.lastModified();
    	    if (transletTimestamp < xslTimestamp)
    	    	return null;
    	}
    	
    	
    	Vector bytecodes = new Vector();
    	int fileLength = (int)transletFile.length();
    	if (fileLength > 0) {
    	    FileInputStream input = null;
    	    try {
    	    	input = new FileInputStream(transletFile);
    	    }
    	    catch (FileNotFoundException e) {
    	    	return null;
    	    }
    	  
    	    byte[] bytes = new byte[fileLength];
    	    try {
	    	readFromInputStream(bytes, input, fileLength);
	    	input.close();
	    }
	    catch (IOException e) {
    	    	return null;
    	    }
    	  
    	    bytecodes.addElement(bytes);
    	}
    	else
    	    return null;
    	
    	
    	String transletParentDir = transletFile.getParent();
    	if (transletParentDir == null)
    	    transletParentDir = System.getProperty(""user.dir"");
    	  
    	File transletParentFile = new File(transletParentDir);
    	
    	
    	final String transletAuxPrefix = transletName + ""$"";
    	File[] auxfiles = transletParentFile.listFiles(new FilenameFilter() {
        	public boolean accept(File dir, String name)
    		{
    		    return (name.endsWith("".class"") && name.startsWith(transletAuxPrefix));	
    		}
    	      });
    	
    	
    	for (int i = 0; i < auxfiles.length; i++)
    	{
    	    File auxfile = auxfiles[i];
    	    int auxlength = (int)auxfile.length();
    	    if (auxlength > 0) {
    	    	FileInputStream auxinput = null;
    	    	try {
    	      	    auxinput = new FileInputStream(auxfile);
    	    	}
    	    	catch (FileNotFoundException e) {
    	      	    continue;
    	    	}
    	  
    	    	byte[] bytes = new byte[auxlength];
    	    
    	    	try {
    	      	    readFromInputStream(bytes, auxinput, auxlength);
    	      	    auxinput.close();
    	    	}
    	    	catch (IOException e) {
    	      	    continue;
    	    	}
    	    
    	    	bytecodes.addElement(bytes);   	    
    	    }
    	}
    	
    	
    	final int count = bytecodes.size();
    	if ( count > 0) {
    	    final byte[][] result = new byte[count][1];
    	    for (int i = 0; i < count; i++) {
    	    	result[i] = (byte[])bytecodes.elementAt(i);
    	    }
    	  
    	    return result;
    	}
    	else
    	    return null;
    }
    
    
    private byte[][] getBytecodesFromJar(Source source, String fullClassName)
    {
    	String xslFileName = getStylesheetFileName(source);
    	File xslFile = null;
    	if (xslFileName != null)
    	    xslFile = new File(xslFileName);
      
      	
      	String jarPath = null;
      	if (_destinationDirectory != null)
            jarPath = _destinationDirectory + ""/"" + _jarFileName;
      	else {
      	    if (xslFile != null && xslFile.getParent() != null)
    	    	jarPath = xslFile.getParent() + ""/"" + _jarFileName;
    	    else
    	    	jarPath = _jarFileName;
    	}
            
      	
      	File file = new File(jarPath);
      	if (!file.exists())
            return null;

     	
     	
    	if (xslFile != null && xslFile.exists()) {
    	    long xslTimestamp = xslFile.lastModified();
    	    long transletTimestamp = file.lastModified();
    	    if (transletTimestamp < xslTimestamp)
    	        return null;
    	}
      
      	
      	ZipFile jarFile = null;
      	try {
            jarFile = new ZipFile(file);
      	}
      	catch (IOException e) {
            return null;
      	}
      
      	String transletPath = fullClassName.replace('.', '/');
      	String transletAuxPrefix = transletPath + ""$"";
      	String transletFullName = transletPath + "".class"";
      
      	Vector bytecodes = new Vector();      
      
      	
      	
      	Enumeration entries = jarFile.entries();
      	while (entries.hasMoreElements())
      	{
            ZipEntry entry = (ZipEntry)entries.nextElement();
            String entryName = entry.getName();
            if (entry.getSize() > 0 && 
            	  (entryName.equals(transletFullName) ||
              	  (entryName.endsWith("".class"") && 
              	      entryName.startsWith(transletAuxPrefix))))
            {
            	try {
              	    InputStream input = jarFile.getInputStream(entry);
              	    int size = (int)entry.getSize();
              	    byte[] bytes = new byte[size];
              	    readFromInputStream(bytes, input, size);
              	    input.close();
              	    bytecodes.addElement(bytes);
            	}
            	catch (IOException e) {
              	    return null;
            	}          
            }
      	}
      
        
    	final int count = bytecodes.size();
    	if (count > 0) {
    	    final byte[][] result = new byte[count][1];
    	    for (int i = 0; i < count; i++) {
    	    	result[i] = (byte[])bytecodes.elementAt(i);
    	    }
    	  
    	    return result;
    	}
    	else
    	    return null;
    }
    
    
    private void readFromInputStream(byte[] bytes, InputStream input, int size)
      	throws IOException
    {
      int n = 0;
      int offset = 0;
      int length = size;
      while (length > 0 && (n = input.read(bytes, offset, length)) > 0) {
          offset = offset + n;
          length = length - n;
      }    
    }

    
    private String getTransletBaseName(Source source)
    {      
        String transletBaseName = null;
        if (!_transletName.equals(DEFAULT_TRANSLET_NAME))
            return _transletName;
      	else {
            String systemId = source.getSystemId();
            if (systemId != null) {
          	String baseName = Util.baseName(systemId);
		if (baseName != null) {
		    baseName = Util.noExtName(baseName);
		    transletBaseName = Util.toJavaName(baseName);
		}
            }
      	}
      
        return (transletBaseName != null) ? transletBaseName : DEFAULT_TRANSLET_NAME;
    }
        
    
    private String getStylesheetFileName(Source source)
    {
    	String systemId = source.getSystemId();
      	if (systemId != null) {
            File file = new File(systemId);
            if (file.exists())
                return systemId;
            else {
              	URL url = null;
          	try {
            	    url = new URL(systemId);
          	}
          	catch (MalformedURLException e) {
            	    return null;
          	}
          
          	if (""file"".equals(url.getProtocol()))
            	    return url.getFile();
          	else
            	    return null;
            }
      	}
      	else
            return null;
    }
}
"
org.apache.xml.utils.SuballocatedIntVector,20,1,0,15,22,8,15,0,13,0.552631579,901,1.0,0,0.0,0.875,0,0,43.55,8,2.95,1,"
package org.apache.xml.utils;


public class SuballocatedIntVector
{
  
  protected int m_blocksize;

  
  protected int m_SHIFT, m_MASK;
  
  
  protected static final int NUMBLOCKS_DEFAULT = 32;
  
  
  protected int m_numblocks = NUMBLOCKS_DEFAULT;
  
  
  protected int m_map[][];

  
  protected int m_firstFree = 0;

  
  protected int m_map0[];

  
  protected int m_buildCache[];
  protected int m_buildCacheStartIndex;


  
  public SuballocatedIntVector()
  {
    this(2048);
  }

  
  public SuballocatedIntVector(int blocksize, int numblocks)
  {
    
    for(m_SHIFT=0;0!=(blocksize>>>=1);++m_SHIFT)
      ;
    m_blocksize=1<<m_SHIFT;
    m_MASK=m_blocksize-1;
    m_numblocks = numblocks;
    	
    m_map0=new int[m_blocksize];
    m_map = new int[numblocks][];
    m_map[0]=m_map0;
    m_buildCache = m_map0;
    m_buildCacheStartIndex = 0;
  }
	
  
  public SuballocatedIntVector(int blocksize)
  {
    this(blocksize, NUMBLOCKS_DEFAULT);
  }

  
  public int size()
  {
    return m_firstFree;
  }
  
  
  public void setSize(int sz)
  {
    if(m_firstFree>sz) 
      m_firstFree = sz;
  }

  
  public  void addElement(int value)
  {
    int indexRelativeToCache = m_firstFree - m_buildCacheStartIndex;

    
    if(indexRelativeToCache >= 0 && indexRelativeToCache < m_blocksize) {
      m_buildCache[indexRelativeToCache]=value;
      ++m_firstFree;
    } else {
      
      
      
      
      
      

      int index=m_firstFree>>>m_SHIFT;
      int offset=m_firstFree&m_MASK;

      if(index>=m_map.length)
      {
	int newsize=index+m_numblocks;
	int[][] newMap=new int[newsize][];
	System.arraycopy(m_map, 0, newMap, 0, m_map.length);
	m_map=newMap;
      }
      int[] block=m_map[index];
      if(null==block)
	block=m_map[index]=new int[m_blocksize];
      block[offset]=value;

      
      
      m_buildCache = block;
      m_buildCacheStartIndex = m_firstFree-offset;

      ++m_firstFree;
    }
  }

  
  private  void addElements(int value, int numberOfElements)
  {
    if(m_firstFree+numberOfElements<m_blocksize)
      for (int i = 0; i < numberOfElements; i++) 
      {
        m_map0[m_firstFree++]=value;
      }
    else
    {
      int index=m_firstFree>>>m_SHIFT;
      int offset=m_firstFree&m_MASK;
      m_firstFree+=numberOfElements;
      while( numberOfElements>0)
      {
        if(index>=m_map.length)
        {
          int newsize=index+m_numblocks;
          int[][] newMap=new int[newsize][];
          System.arraycopy(m_map, 0, newMap, 0, m_map.length);
          m_map=newMap;
        }
        int[] block=m_map[index];
        if(null==block)
          block=m_map[index]=new int[m_blocksize];
        int copied=(m_blocksize-offset < numberOfElements)
          ? m_blocksize-offset : numberOfElements;
        numberOfElements-=copied;
        while(copied-- > 0)
          block[offset++]=value;

        ++index;offset=0;
      }
    }
  }
  
  
  private  void addElements(int numberOfElements)
  {
    int newlen=m_firstFree+numberOfElements;
    if(newlen>m_blocksize)
    {
      int index=m_firstFree>>>m_SHIFT;
      int newindex=(m_firstFree+numberOfElements)>>>m_SHIFT;
      for(int i=index+1;i<=newindex;++i)
        m_map[i]=new int[m_blocksize];
    }
    m_firstFree=newlen;
  }
  
  
  private  void insertElementAt(int value, int at)
  {
    if(at==m_firstFree)
      addElement(value);
    else if (at>m_firstFree)
    {
      int index=at>>>m_SHIFT;
      if(index>=m_map.length)
      {
        int newsize=index+m_numblocks;
        int[][] newMap=new int[newsize][];
        System.arraycopy(m_map, 0, newMap, 0, m_map.length);
        m_map=newMap;
      }
      int[] block=m_map[index];
      if(null==block)
        block=m_map[index]=new int[m_blocksize];
      int offset=at&m_MASK;
          block[offset]=value;
          m_firstFree=offset+1;
        }
    else
    {
      int index=at>>>m_SHIFT;
      int maxindex=m_firstFree>>>m_SHIFT; 
      ++m_firstFree;
      int offset=at&m_MASK;
      int push;
      
      
      while(index<=maxindex)
      {
        int copylen=m_blocksize-offset-1;
        int[] block=m_map[index];
        if(null==block)
        {
          push=0;
          block=m_map[index]=new int[m_blocksize];
        }
        else
        {
          push=block[m_blocksize-1];
          System.arraycopy(block, offset , block, offset+1, copylen);
        }
        block[offset]=value;
        value=push;
        offset=0;
        ++index;
      }
    }
  }

  
  public void removeAllElements()
  {
    m_firstFree = 0;
    m_buildCache = m_map0;
    m_buildCacheStartIndex = 0;
  }

  
  private  boolean removeElement(int s)
  {
    int at=indexOf(s,0);
    if(at<0)
      return false;
    removeElementAt(at);
    return true;
  }

  
  private  void removeElementAt(int at)
  {
        
    if(at<m_firstFree)
    {
      int index=at>>>m_SHIFT;
      int maxindex=m_firstFree>>>m_SHIFT;
      int offset=at&m_MASK;
      
      while(index<=maxindex)
      {
        int copylen=m_blocksize-offset-1;
        int[] block=m_map[index];
        if(null==block)
          block=m_map[index]=new int[m_blocksize];
        else
          System.arraycopy(block, offset+1, block, offset, copylen);
        if(index<maxindex)
        {
          int[] next=m_map[index+1];
          if(next!=null)
            block[m_blocksize-1]=(next!=null) ? next[0] : 0;
        }
        else
          block[m_blocksize-1]=0;
        offset=0;
        ++index;
      }
    }
    --m_firstFree;
  }

  
  public void setElementAt(int value, int at)
  {
    if(at<m_blocksize)
      m_map0[at]=value;
    else
    {
      int index=at>>>m_SHIFT;
      int offset=at&m_MASK;
        
      if(index>=m_map.length)
      {
	int newsize=index+m_numblocks;
	int[][] newMap=new int[newsize][];
	System.arraycopy(m_map, 0, newMap, 0, m_map.length);
	m_map=newMap;
      }

      int[] block=m_map[index];
      if(null==block)
	block=m_map[index]=new int[m_blocksize];
      block[offset]=value;
    }

    if(at>=m_firstFree)
      m_firstFree=at+1;
  }
  

  
  public int elementAt(int i)
  {
    
    if(i<m_blocksize)
      return m_map0[i];

    return m_map[i>>>m_SHIFT][i&m_MASK];
  }

  
  private  boolean contains(int s)
  {
    return (indexOf(s,0) >= 0);
  }

  
  public int indexOf(int elem, int index)
  {
        if(index>=m_firstFree)
                return -1;
          
    int bindex=index>>>m_SHIFT;
    int boffset=index&m_MASK;
    int maxindex=m_firstFree>>>m_SHIFT;
    int[] block;
    
    for(;bindex<maxindex;++bindex)
    {
      block=m_map[bindex];
      if(block!=null)
        for(int offset=boffset;offset<m_blocksize;++offset)
          if(block[offset]==elem)
            return offset+bindex*m_blocksize;
      boffset=0; 
    }
    
    int maxoffset=m_firstFree&m_MASK;
    block=m_map[maxindex];
    for(int offset=boffset;offset<maxoffset;++offset)
      if(block[offset]==elem)
        return offset+maxindex*m_blocksize;

    return -1;    
  }

  
  public int indexOf(int elem)
  {
    return indexOf(elem,0);
  }

  
  private  int lastIndexOf(int elem)
  {
    int boffset=m_firstFree&m_MASK;
    for(int index=m_firstFree>>>m_SHIFT;
        index>=0;
        --index)
    {
      int[] block=m_map[index];
      if(block!=null)
        for(int offset=boffset; offset>=0; --offset)
          if(block[offset]==elem)
            return offset+index*m_blocksize;
      boffset=0; 
    }
    return -1;
  }
  
  
  public final int[] getMap0()
  {
    return m_map0;
  }
  
  
  public final int[][] getMap()
  {
    return m_map;
  }
  
}
"
org.w3c.dom.xpath.XPathExpression,1,1,0,0,1,0,0,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.w3c.dom.xpath;


import org.w3c.dom.Node;
import org.w3c.dom.DOMException;


public interface XPathExpression {
    
    public Object evaluate(Node contextNode, 
                           short type, 
                           Object result)
                           throws XPathException, DOMException;

}
"
org.apache.xml.utils.NSInfo,3,1,0,1,4,0,1,0,3,0.642857143,55,0.0,0,0.0,0.666666667,0,0,15.0,0,0.0,1,"
package org.apache.xml.utils;


public class NSInfo
{

  
  public NSInfo(boolean hasProcessedNS, boolean hasXMLNSAttrs)
  {

    m_hasProcessedNS = hasProcessedNS;
    m_hasXMLNSAttrs = hasXMLNSAttrs;
    m_namespace = null;
    m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED;
  }

  

  
  public NSInfo(boolean hasProcessedNS, boolean hasXMLNSAttrs,
                int ancestorHasXMLNSAttrs)
  {

    m_hasProcessedNS = hasProcessedNS;
    m_hasXMLNSAttrs = hasXMLNSAttrs;
    m_ancestorHasXMLNSAttrs = ancestorHasXMLNSAttrs;
    m_namespace = null;
  }

  
  public NSInfo(String namespace, boolean hasXMLNSAttrs)
  {

    m_hasProcessedNS = true;
    m_hasXMLNSAttrs = hasXMLNSAttrs;
    m_namespace = namespace;
    m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED;
  }

  
  public String m_namespace;

  
  public boolean m_hasXMLNSAttrs;

  
  public boolean m_hasProcessedNS;

  
  public int m_ancestorHasXMLNSAttrs;

  
  public static final int ANCESTORXMLNSUNPROCESSED = 0;

  
  public static final int ANCESTORHASXMLNS = 1;

  
  public static final int ANCESTORNOXMLNS = 2;
}
"
org.apache.xalan.xsltc.compiler.FunctionCall,28,3,23,60,138,124,24,36,15,0.931372549,2406,0.882352941,4,0.739583333,0.128205128,3,10,83.71428571,15,3.1786,1,"

package org.apache.xalan.xsltc.compiler;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionConstants;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.InvokeInstruction;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.BooleanType;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.IntType;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodType;
import org.apache.xalan.xsltc.compiler.util.MultiHashtable;
import org.apache.xalan.xsltc.compiler.util.ObjectType;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.runtime.TransletLoader;

class FunctionCall extends Expression {

    
    private QName  _fname;
    
    private final Vector _arguments;
    
    private final static Vector EMPTY_ARG_LIST = new Vector(0);

    
    protected final static String EXT_XSLTC = 
	TRANSLET_URI;

    protected final static String JAVA_EXT_XSLTC = 
	EXT_XSLTC + ""/java"";

    protected final static String EXT_XALAN =
	""http:

    protected final static String JAVA_EXT_XALAN =
	""http:

    protected final static String JAVA_EXT_XALAN_OLD =
	""http:
	
    protected final static String EXSLT_COMMON =
	""http:

    protected final static String EXSLT_MATH =
	""http:
	
    protected final static String EXSLT_SETS =
	""http:

    protected final static String EXSLT_DATETIME =
	""http:

    protected final static String EXSLT_STRINGS =
	""http:
	
    
    protected final static int NAMESPACE_FORMAT_JAVA = 0;
    protected final static int NAMESPACE_FORMAT_CLASS = 1;
    protected final static int NAMESPACE_FORMAT_PACKAGE = 2;
    protected final static int NAMESPACE_FORMAT_CLASS_OR_PACKAGE = 3;
	
    
    private int _namespace_format = NAMESPACE_FORMAT_JAVA;
        
    
    Expression _thisArgument = null;

    
    private String      _className;
    private Class       _clazz;
    private Method      _chosenMethod;
    private Constructor _chosenConstructor;
    private MethodType  _chosenMethodType;

    
    private boolean    unresolvedExternal;

    
    private boolean     _isExtConstructor = false; 

    
    private boolean 	  _isStatic = false;

    
    private static final MultiHashtable _internal2Java = new MultiHashtable();

    
    private static final Hashtable _java2Internal = new Hashtable();
    
    
    private static final Hashtable _extensionNamespaceTable = new Hashtable();

    
    private static final Hashtable _extensionFunctionTable = new Hashtable();
    
    static class JavaType {
	public Class  type;
	public int distance;
	
	public JavaType(Class type, int distance){
	    this.type = type;
	    this.distance = distance;
	}
	public boolean equals(Object query){
	    return query.equals(type);
	}
    } 

    
    static {

	try {
	    final Class objectClass   = Class.forName(""java.lang.Object"");
	    final Class stringClass   = Class.forName(""java.lang.String"");
	    final Class nodeClass     = Class.forName(""org.w3c.dom.Node"");
	    final Class nodeListClass = Class.forName(""org.w3c.dom.NodeList"");

	    
	    _internal2Java.put(Type.Boolean, new JavaType(objectClass,2));
	    _internal2Java.put(Type.Boolean, new JavaType(java.lang.Boolean.class,1));
	    _internal2Java.put(Type.Boolean, new JavaType(Boolean.TYPE,0));

	    _internal2Java.put(Type.Int, new JavaType(objectClass, 8));
	    _internal2Java.put(Type.Int, new JavaType(Character.TYPE, 7));
	    _internal2Java.put(Type.Int, new JavaType(Byte.TYPE, 6));
	    _internal2Java.put(Type.Int, new JavaType(Short.TYPE, 5));
	    _internal2Java.put(Type.Int, new JavaType(Integer.TYPE, 0));
	    _internal2Java.put(Type.Int, new JavaType(java.lang.Integer.class, 1));
	    _internal2Java.put(Type.Int, new JavaType(Long.TYPE, 2));
	    _internal2Java.put(Type.Int, new JavaType(Float.TYPE, 3));
	    _internal2Java.put(Type.Int, new JavaType(Double.TYPE, 4));

	    _internal2Java.put(Type.Real, new JavaType(objectClass, 8));
	    _internal2Java.put(Type.Real, new JavaType(Character.TYPE, 7)); 
	    _internal2Java.put(Type.Real, new JavaType(Byte.TYPE, 6));
	    _internal2Java.put(Type.Real, new JavaType(Short.TYPE, 5));
	    _internal2Java.put(Type.Real, new JavaType(Integer.TYPE, 4));
	    _internal2Java.put(Type.Real, new JavaType(Long.TYPE, 3));
	    _internal2Java.put(Type.Real, new JavaType(Float.TYPE, 2));
	    _internal2Java.put(Type.Real, new JavaType(java.lang.Double.class, 1));
	    _internal2Java.put(Type.Real, new JavaType(Double.TYPE, 0));

	    _internal2Java.put(Type.String, new JavaType(objectClass, 1));
	    _internal2Java.put(Type.String, new JavaType(stringClass, 0)); 

	    _internal2Java.put(Type.Node, new JavaType(nodeClass, 0));  
	    _internal2Java.put(Type.Node, new JavaType(nodeListClass, 1));
	    _internal2Java.put(Type.Node, new JavaType(objectClass, 2));
	    _internal2Java.put(Type.Node, new JavaType(stringClass, 3));

	    _internal2Java.put(Type.NodeSet, new JavaType(Integer.TYPE, 10));
	    _internal2Java.put(Type.NodeSet, new JavaType(stringClass, 3)); 
	    _internal2Java.put(Type.NodeSet, new JavaType(objectClass, 2));
	    _internal2Java.put(Type.NodeSet, new JavaType(nodeClass, 1)); 
	    _internal2Java.put(Type.NodeSet, new JavaType(nodeListClass,0)); 

	    _internal2Java.put(Type.ResultTree, new JavaType(nodeClass, 1)); 
	    _internal2Java.put(Type.ResultTree, new JavaType(nodeListClass, 0));
	    _internal2Java.put(Type.ResultTree, new JavaType(objectClass, 2));
	    _internal2Java.put(Type.ResultTree, new JavaType(stringClass, 3));
	    _internal2Java.put(Type.ResultTree, new JavaType(Double.TYPE, 4));

	    _internal2Java.put(Type.Reference, new JavaType(objectClass,0));

	    
	    _java2Internal.put(Boolean.TYPE, Type.Boolean); 
	    _java2Internal.put(Void.TYPE, Type.Void);
	    _java2Internal.put(Character.TYPE, Type.Real); 
	    _java2Internal.put(Byte.TYPE, Type.Real);
	    _java2Internal.put(Short.TYPE, Type.Real);
	    _java2Internal.put(Integer.TYPE, Type.Real);
	    _java2Internal.put(Long.TYPE, Type.Real);
	    _java2Internal.put(Float.TYPE, Type.Real);
	    _java2Internal.put(Double.TYPE, Type.Real);

	    _java2Internal.put(stringClass, Type.String);

	    _java2Internal.put(objectClass, Type.Reference);

	    
	    _java2Internal.put(nodeListClass, Type.NodeSet);
	    _java2Internal.put(nodeClass, Type.NodeSet);
	    
	    
	    _extensionNamespaceTable.put(EXT_XALAN, ""org.apache.xalan.lib.Extensions"");
	    _extensionNamespaceTable.put(EXSLT_COMMON, ""org.apache.xalan.lib.ExsltCommon"");
	    _extensionNamespaceTable.put(EXSLT_MATH, ""org.apache.xalan.lib.ExsltMath"");
	    _extensionNamespaceTable.put(EXSLT_SETS, ""org.apache.xalan.lib.ExsltSets"");
	    _extensionNamespaceTable.put(EXSLT_DATETIME, ""org.apache.xalan.lib.ExsltDatetime"");
	    _extensionNamespaceTable.put(EXSLT_STRINGS, ""org.apache.xalan.lib.ExsltStrings"");
	    
	    
	    _extensionFunctionTable.put(EXSLT_COMMON + "":nodeSet"", ""nodeset"");
	    _extensionFunctionTable.put(EXSLT_COMMON + "":objectType"", ""objectType"");	    
	    _extensionFunctionTable.put(EXT_XALAN + "":nodeset"", ""nodeset"");
	}
	catch (ClassNotFoundException e) {
	    System.err.println(e);
	}
    }
		
    public FunctionCall(QName fname, Vector arguments) {
	_fname = fname;
	_arguments = arguments;
	_type = null;
    }

    public FunctionCall(QName fname) {
	this(fname, EMPTY_ARG_LIST);
    }

    public String getName() {
	return(_fname.toString());
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_arguments != null) {
	    final int n = _arguments.size();
	    for (int i = 0; i < n; i++) {
		final Expression exp = (Expression)_arguments.elementAt(i);
		exp.setParser(parser);
		exp.setParent(this);
	    }
	}
    }

    public String getClassNameFromUri(String uri) 
    {   
        String className = (String)_extensionNamespaceTable.get(uri);
    
        if (className != null)
            return className;
        else {
            if (uri.startsWith(JAVA_EXT_XSLTC)) {
      	    	int length = JAVA_EXT_XSLTC.length() + 1;
            	return (uri.length() > length) ? uri.substring(length) : EMPTYSTRING;
            }
            else if (uri.startsWith(JAVA_EXT_XALAN)) {
      	    	int length = JAVA_EXT_XALAN.length() + 1;
            	return (uri.length() > length) ? uri.substring(length) : EMPTYSTRING;
            }
            else if (uri.startsWith(JAVA_EXT_XALAN_OLD)) {
      	    	int length = JAVA_EXT_XALAN_OLD.length() + 1;
            	return (uri.length() > length) ? uri.substring(length) : EMPTYSTRING;
            }
            else {
      	    	int index = uri.lastIndexOf('/');
      	    	return (index > 0) ? uri.substring(index+1) : uri;
            }      
        }
    }

    
    public Type typeCheck(SymbolTable stable) 
	throws TypeCheckError 
    {
        if (_type != null) return _type;

	final String namespace = _fname.getNamespace();
	String local = _fname.getLocalPart();

	if (isExtension()) {
	    _fname = new QName(null, null, local);
	    return typeCheckStandard(stable);
	}
	else if (isStandard()) {
	    return typeCheckStandard(stable);
	}
	
	else {
	    try {
	    	_className = getClassNameFromUri(namespace);
		  
                final int pos = local.lastIndexOf('.');
		if (pos > 0) {
		    _isStatic = true;
		    if (_className != null && _className.length() > 0) {
		    	_namespace_format = NAMESPACE_FORMAT_PACKAGE;
		     	_className = _className + ""."" + local.substring(0, pos);
		    }
		    else {
		     	_namespace_format = NAMESPACE_FORMAT_JAVA;
		     	_className = local.substring(0, pos);
		    }
			  
		    _fname = new QName(namespace, null, local.substring(pos + 1));
		}
		else {
		    if (_className != null && _className.length() > 0) {
		    	try {			  	
		      	    TransletLoader loader = new TransletLoader();
		            _clazz = loader.loadClass(_className);			  	
		            _namespace_format = NAMESPACE_FORMAT_CLASS;
		    	}
		    	catch (ClassNotFoundException e) {
		      	    _namespace_format = NAMESPACE_FORMAT_PACKAGE;	
		        }
		    }
		    else
	            	_namespace_format = NAMESPACE_FORMAT_JAVA;
			
		    if (local.indexOf('-') > 0) {
		        local = replaceDash(local);
		    }
		    
		    String extFunction = (String)_extensionFunctionTable.get(namespace + "":"" + local);
		    if (extFunction != null) {
		      	_fname = new QName(null, null, extFunction);
		      	return typeCheckStandard(stable);
		    }
		    else
		      	_fname = new QName(namespace, null, local);
		}
		  
		return typeCheckExternal(stable);
	    } 
	    catch (TypeCheckError e) {
		ErrorMsg errorMsg = e.getErrorMsg();
		if (errorMsg == null) {
		    final String name = _fname.getLocalPart();
		    errorMsg = new ErrorMsg(ErrorMsg.METHOD_NOT_FOUND_ERR, name);
		}
		getParser().reportError(ERROR, errorMsg);
		return _type = Type.Void;
	    }
	  }
    }

    
    public Type typeCheckStandard(SymbolTable stable) throws TypeCheckError {
	_fname.clearNamespace(); 	

	final int n = _arguments.size();
	final Vector argsType = typeCheckArgs(stable);
	final MethodType args = new MethodType(Type.Void, argsType);
	final MethodType ptype =
	    lookupPrimop(stable, _fname.getLocalPart(), args);

	if (ptype != null) {
	    for (int i = 0; i < n; i++) {
		final Type argType = (Type) ptype.argsType().elementAt(i);
		final Expression exp = (Expression)_arguments.elementAt(i);
		if (!argType.identicalTo(exp.getType())) {
		    try {
			_arguments.setElementAt(new CastExpr(exp, argType), i);
		    }
		    catch (TypeCheckError e) {
			throw new TypeCheckError(this);	
		    }
		}
	    }
	    _chosenMethodType = ptype;
	    return _type = ptype.resultType();
	}
	throw new TypeCheckError(this);
    }

   

    public Type typeCheckConstructor(SymbolTable stable) throws TypeCheckError{
        final Vector constructors = findConstructors();
	if (constructors == null) {
            
            throw new TypeCheckError(ErrorMsg.CONSTRUCTOR_NOT_FOUND, 
		_className);
        
	}

	final int nConstructors = constructors.size();
	final int nArgs = _arguments.size();
	final Vector argsType = typeCheckArgs(stable);

	
	int bestConstrDistance = Integer.MAX_VALUE;
	_type = null;			
	for (int j, i = 0; i < nConstructors; i++) {
	    
	    final Constructor constructor = 
		(Constructor)constructors.elementAt(i);
	    final Class[] paramTypes = constructor.getParameterTypes();

	    Class extType = null;
	    int currConstrDistance = 0;
	    for (j = 0; j < nArgs; j++) {
		
		extType = paramTypes[j];
		final Type intType = (Type)argsType.elementAt(j);
		Object match = _internal2Java.maps(intType, extType);
		if (match != null) {
		    currConstrDistance += ((JavaType)match).distance;
		}
		else if (intType instanceof ObjectType) {
		    ObjectType objectType = (ObjectType)intType;
		    if (objectType.getJavaClass() == extType)
		        continue;
		    else if (extType.isAssignableFrom(objectType.getJavaClass()))
		        currConstrDistance += 1;
		    else {
			currConstrDistance = Integer.MAX_VALUE;
			break;
		    }
		}
		else {
		    
		    currConstrDistance = Integer.MAX_VALUE;
		    break;
		} 
	    }

	    if (j == nArgs && currConstrDistance < bestConstrDistance ) {
	        _chosenConstructor = constructor;
	        _isExtConstructor = true;
		bestConstrDistance = currConstrDistance;
		
		if (_clazz != null)
	          _type = new ObjectType(_clazz);
		else
		  _type = new ObjectType(_className);
	    }
	}

	if (_type != null) {
	    return _type;
	}

	throw new TypeCheckError(ErrorMsg.ARGUMENT_CONVERSION_ERR, getMethodSignature(argsType));
    }


    
    public Type typeCheckExternal(SymbolTable stable) throws TypeCheckError {
	int nArgs = _arguments.size();
	final String name = _fname.getLocalPart();
    
 	
	if (_fname.getLocalPart().equals(""new"")) {
	    return typeCheckConstructor(stable);
	}
	
	else {
	    boolean hasThisArgument = false;
	  
	    if (nArgs == 0)
	        _isStatic = true;
	  
	    if (!_isStatic) {
	        if (_namespace_format == NAMESPACE_FORMAT_JAVA
	  	    || _namespace_format == NAMESPACE_FORMAT_PACKAGE)
	   	    hasThisArgument = true;
	  	  
	  	Expression firstArg = (Expression)_arguments.elementAt(0);
	  	Type firstArgType = (Type)firstArg.typeCheck(stable);
	  	
	  	if (_namespace_format == NAMESPACE_FORMAT_CLASS
	  	    && firstArgType instanceof ObjectType
	  	    && _clazz != null
	  	    && _clazz.isAssignableFrom(((ObjectType)firstArgType).getJavaClass()))
	  	    hasThisArgument = true;
	  	
	  	if (hasThisArgument) {
	  	    _thisArgument = (Expression) _arguments.elementAt(0);
	  	    _arguments.remove(0); nArgs--;
		    if (firstArgType instanceof ObjectType) {
		    	_className = ((ObjectType) firstArgType).getJavaClassName();
		    }
		    else
		    	throw new TypeCheckError(ErrorMsg.NO_JAVA_FUNCT_THIS_REF, name);  	  	
	  	}
	    }
	    else if (_className.length() == 0) {
		
		final Parser parser = getParser();
		if (parser != null) {
		    reportWarning(this, parser, ErrorMsg.FUNCTION_RESOLVE_ERR,
				  _fname.toString());
		}
		unresolvedExternal = true;
		return _type = Type.Int;	
	    }
	}
	
	final Vector methods = findMethods();
	
	if (methods == null) {
	    
	    throw new TypeCheckError(ErrorMsg.METHOD_NOT_FOUND_ERR, _className + ""."" + name);
	}

	Class extType = null;
	final int nMethods = methods.size();
	final Vector argsType = typeCheckArgs(stable);

	
	int bestMethodDistance  = Integer.MAX_VALUE;
	_type = null;                       
	for (int j, i = 0; i < nMethods; i++) {

	    
	    final Method method = (Method)methods.elementAt(i);
	    final Class[] paramTypes = method.getParameterTypes();
	    
	    int currMethodDistance = 0;
	    for (j = 0; j < nArgs; j++) {
		
		extType = paramTypes[j];
		final Type intType = (Type)argsType.elementAt(j);
		Object match = _internal2Java.maps(intType, extType);
		if (match != null) {
		    currMethodDistance += ((JavaType)match).distance; 
		}
		else {
		    
		    
		    
		    
		    if (intType instanceof ReferenceType) {
		       currMethodDistance += 1; 
		    }
		    else if (intType instanceof ObjectType) {
		        ObjectType object = (ObjectType)intType;
		        if (extType.getName().equals(object.getJavaClassName()))
		            currMethodDistance += 0;
		      	else if (extType.isAssignableFrom(object.getJavaClass()))
		            currMethodDistance += 1;
		      	else {
		      	    currMethodDistance = Integer.MAX_VALUE;
		      	    break;
		        }
		    }
		    else {
		        currMethodDistance = Integer.MAX_VALUE;
		        break;
		    }
		}
	    }

	    if (j == nArgs) {
		  
		  extType = method.getReturnType();
		
		  _type = (Type) _java2Internal.get(extType);
		  if (_type == null) {
		      _type = new ObjectType(extType);
		  }		

		  
		  if (_type != null && currMethodDistance < bestMethodDistance) {
		      _chosenMethod = method;
		      bestMethodDistance = currMethodDistance;
		  }
	    }
	}
	
	
	
	if (_chosenMethod != null && _thisArgument == null &&
	    !Modifier.isStatic(_chosenMethod.getModifiers())) {
	    throw new TypeCheckError(ErrorMsg.NO_JAVA_FUNCT_THIS_REF, getMethodSignature(argsType));
	}

	if (_type != null) {
	    if (_type == Type.NodeSet) {
            	getXSLTC().setMultiDocument(true);
            }
	    return _type;
	}

	throw new TypeCheckError(ErrorMsg.ARGUMENT_CONVERSION_ERR, getMethodSignature(argsType));
    }

    
    public Vector typeCheckArgs(SymbolTable stable) throws TypeCheckError {
	final Vector result = new Vector();
	final Enumeration e = _arguments.elements();	
	while (e.hasMoreElements()) {
	    final Expression exp = (Expression)e.nextElement();
	    result.addElement(exp.typeCheck(stable));
	}
	return result;
    }

    protected final Expression argument(int i) {
	return (Expression)_arguments.elementAt(i);
    }

    protected final Expression argument() {
	return argument(0);
    }
    
    protected final int argumentCount() {
	return _arguments.size();
    }

    protected final void setArgument(int i, Expression exp) {
	_arguments.setElementAt(exp, i);
    }

    
    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) 
    {
	Type type = Type.Boolean;
	if (_chosenMethodType != null)
	    type = _chosenMethodType.resultType();

	final InstructionList il = methodGen.getInstructionList();
	translate(classGen, methodGen);

	if ((type instanceof BooleanType) || (type instanceof IntType)) {
	    _falseList.add(il.append(new IFEQ(null)));
	}
    }


    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final int n = argumentCount();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	int index;

	
	if (isStandard() || isExtension()) {
	    for (int i = 0; i < n; i++) {
		final Expression exp = argument(i);
		exp.translate(classGen, methodGen);
		exp.startResetIterator(classGen, methodGen);
	    }

	    
	    final String name = _fname.toString().replace('-', '_') + ""F"";
	    String args = Constants.EMPTYSTRING;

	    
	    if (name.equals(""sumF"")) {
		args = DOM_INTF_SIG;
		il.append(methodGen.loadDOM());
	    }
	    else if (name.equals(""normalize_spaceF"")) {
		if (_chosenMethodType.toSignature(args).
		    equals(""()Ljava/lang/String;"")) {
		    args = ""I""+DOM_INTF_SIG;
		    il.append(methodGen.loadContextNode());
		    il.append(methodGen.loadDOM());
		}
	    }

	    
	    index = cpg.addMethodref(BASIS_LIBRARY_CLASS, name,
				     _chosenMethodType.toSignature(args));
	    il.append(new INVOKESTATIC(index));
	}
	
	
	else if (unresolvedExternal) {
	    index = cpg.addMethodref(BASIS_LIBRARY_CLASS,
				     ""unresolved_externalF"",
				     ""(Ljava/lang/String;)V"");
	    il.append(new PUSH(cpg, _fname.toString()));
	    il.append(new INVOKESTATIC(index));
	}
	else if (_isExtConstructor) {
	    final String clazz = 
		_chosenConstructor.getDeclaringClass().getName();
	    Class[] paramTypes = _chosenConstructor.getParameterTypes();
	    
	    il.append(new NEW(cpg.addClass(_className)));
	    il.append(InstructionConstants.DUP);

	    for (int i = 0; i < n; i++) {
		final Expression exp = argument(i);
		exp.translate(classGen, methodGen);
		
		exp.startResetIterator(classGen, methodGen);
		exp.getType().translateTo(classGen, methodGen, paramTypes[i]);
	    }

	    final StringBuffer buffer = new StringBuffer();
	    buffer.append('(');
	    for (int i = 0; i < paramTypes.length; i++) {
		buffer.append(getSignature(paramTypes[i]));
	    }
	    buffer.append(')');
	    buffer.append(""V"");

	    index = cpg.addMethodref(clazz,
				     ""<init>"", 
				     buffer.toString());
	    il.append(new INVOKESPECIAL(index));

	    
	    (Type.Object).translateFrom(classGen, methodGen, 
				_chosenConstructor.getDeclaringClass());
	    
	}
	
	else {
	    final String clazz = _chosenMethod.getDeclaringClass().getName();
	    Class[] paramTypes = _chosenMethod.getParameterTypes();

	    
	    if (_thisArgument != null) {
		_thisArgument.translate(classGen, methodGen);
	    }	    

	    for (int i = 0; i < n; i++) {
		final Expression exp = argument(i);
		exp.translate(classGen, methodGen);
		
		exp.startResetIterator(classGen, methodGen);
		exp.getType().translateTo(classGen, methodGen, paramTypes[i]);
	    }

	    final StringBuffer buffer = new StringBuffer();
	    buffer.append('(');
	    for (int i = 0; i < paramTypes.length; i++) {
		buffer.append(getSignature(paramTypes[i]));
	    }
	    buffer.append(')');
	    buffer.append(getSignature(_chosenMethod.getReturnType()));

	    index = cpg.addMethodref(clazz,
				     _fname.getLocalPart(),
				     buffer.toString());
	    il.append(_thisArgument != null ? (InvokeInstruction) new INVOKEVIRTUAL(index) :
	    		  (InvokeInstruction) new INVOKESTATIC(index));
 
	    
	    _type.translateFrom(classGen, methodGen,
				_chosenMethod.getReturnType());
	}
    }

    public String toString() {
	return ""funcall("" + _fname + "", "" + _arguments + ')';
    }

    public boolean isStandard() {
	final String namespace = _fname.getNamespace();
	return (namespace == null) || (namespace.equals(Constants.EMPTYSTRING));
    }

    public boolean isExtension() {
	final String namespace = _fname.getNamespace();
	return (namespace != null) && (namespace.equals(EXT_XSLTC));
    }

    
    private Vector findMethods() {
	  
	  Vector result = null;
	  final String namespace = _fname.getNamespace();

	  if (_className != null && _className.length() > 0) {
	    final int nArgs = _arguments.size();
	    try {
	      if (_clazz == null) {
		TransletLoader loader = new TransletLoader();
		_clazz = loader.loadClass(_className);
		
		if (_clazz == null) {
		  final ErrorMsg msg =
		        new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
		  getParser().reportError(Constants.ERROR, msg);
		}
	      }

	      final String methodName = _fname.getLocalPart();
	      final Method[] methods = _clazz.getMethods();

	      for (int i = 0; i < methods.length; i++) {
		final int mods = methods[i].getModifiers();
		
		if (Modifier.isPublic(mods)
		    && methods[i].getName().equals(methodName)
		    && methods[i].getParameterTypes().length == nArgs)
		{
		  if (result == null) {
		    result = new Vector();
	          }
		  result.addElement(methods[i]);
		}
	      }
	    }
	    catch (ClassNotFoundException e) {
		  final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
		  getParser().reportError(Constants.ERROR, msg);
	    }
	  }
	  return result;
    }

    
    private Vector findConstructors() {
        Vector result = null;
        final String namespace = _fname.getNamespace();

        final int nArgs = _arguments.size();
        try {
          if (_clazz == null) {
            TransletLoader loader = new TransletLoader();
            _clazz = loader.loadClass(_className);
          
            if (_clazz == null) {
              final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
              getParser().reportError(Constants.ERROR, msg);
            }          
          }

          final Constructor[] constructors = _clazz.getConstructors();

          for (int i = 0; i < constructors.length; i++) {
              final int mods = constructors[i].getModifiers();
              
              if (Modifier.isPublic(mods) &&
                  constructors[i].getParameterTypes().length == nArgs)
              {
                if (result == null) {
                  result = new Vector();
                }
                result.addElement(constructors[i]);
              }
          }
        }
        catch (ClassNotFoundException e) {
          final ErrorMsg msg = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
          getParser().reportError(Constants.ERROR, msg);
        }
            
        return result;
    }


    
    static final String getSignature(Class clazz) {
	if (clazz.isArray()) {
	    final StringBuffer sb = new StringBuffer();
	    Class cl = clazz;
	    while (cl.isArray()) {
		sb.append(""["");
		cl = cl.getComponentType();
	    }
	    sb.append(getSignature(cl));
	    return sb.toString();
	}
	else if (clazz.isPrimitive()) {
	    if (clazz == Integer.TYPE) {
		return ""I"";
	    }
	    else if (clazz == Byte.TYPE) {
		return ""B"";
	    }
	    else if (clazz == Long.TYPE) {
		return ""J"";
	    }
	    else if (clazz == Float.TYPE) {
		return ""F"";
	    }
	    else if (clazz == Double.TYPE) {
		return ""D"";
	    }
	    else if (clazz == Short.TYPE) {
		return ""S"";
	    }
	    else if (clazz == Character.TYPE) {
		return ""C"";
	    }
	    else if (clazz == Boolean.TYPE) {
		return ""Z"";
	    }
	    else if (clazz == Void.TYPE) {
		return ""V"";
	    }
	    else {
		final String name = clazz.toString();
		ErrorMsg err = new ErrorMsg(ErrorMsg.UNKNOWN_SIG_TYPE_ERR,name);
		throw new Error(err.toString());
	    }
	}
	else {
	    return ""L"" + clazz.getName().replace('.', '/') + ';';
	}
    }

    
    static final String getSignature(Method meth) {
	final StringBuffer sb = new StringBuffer();
	sb.append('(');
	final Class[] params = meth.getParameterTypes(); 
	for (int j = 0; j < params.length; j++) {
	    sb.append(getSignature(params[j]));
	}
	return sb.append(')').append(getSignature(meth.getReturnType()))
	    .toString();
    }

    
    static final String getSignature(Constructor cons) {
	final StringBuffer sb = new StringBuffer();
	sb.append('(');
	final Class[] params = cons.getParameterTypes(); 
	for (int j = 0; j < params.length; j++) {
	    sb.append(getSignature(params[j]));
	}
	return sb.append("")V"").toString();
    }
    
    
    private String getMethodSignature(Vector argsType) {
 	final StringBuffer buf = new StringBuffer(_className);
        buf.append('.').append(_fname.getLocalPart()).append('(');
	  
	int nArgs = argsType.size();	    
	for (int i = 0; i < nArgs; i++) {
	    final Type intType = (Type)argsType.elementAt(i);
	    buf.append(intType.toString());
	    if (i < nArgs - 1) buf.append("", "");
	}
	  
	buf.append(')');
	return buf.toString();
    }

    
    protected static String replaceDash(String name)
    {
        char dash = '-';
        StringBuffer buff = new StringBuffer("""");
        for (int i = 0; i < name.length(); i++) {
        if (i > 0 && name.charAt(i-1) == dash)
            buff.append(Character.toUpperCase(name.charAt(i)));
        else if (name.charAt(i) != dash)
            buff.append(name.charAt(i));
        }
        return buff.toString();
    }
 	 
}
"
org.apache.xalan.xsltc.compiler.ElementAvailableCall,5,4,0,17,19,10,0,17,5,2.0,85,0.0,0,0.96,0.333333333,3,12,16.0,2,1.2,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class ElementAvailableCall extends FunctionCall {

    public ElementAvailableCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (argument() instanceof LiteralExpr) {
	    return _type = Type.Boolean;
	}
	ErrorMsg err = new ErrorMsg(ErrorMsg.NEED_LITERAL_ERR,
				    ""element-available"", this);
	throw new TypeCheckError(err);
    }

    
    public Object evaluateAtCompileTime() {
	return getResult() ? Boolean.TRUE : Boolean.FALSE;
    }

    
    public boolean getResult() {
	try {
	    final LiteralExpr arg = (LiteralExpr) argument();
	    final String qname = arg.getValue();
	    final int index = qname.indexOf(':');
	    final String localName = (index > 0) ? 
		qname.substring(index + 1) : qname;
	    return getParser().elementSupported(arg.getNamespace(), 
					        localName);
	}
	catch (ClassCastException e) {
	    return false;
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final boolean result = getResult();
	methodGen.getInstructionList().append(new PUSH(cpg, result));
    }
}
"
org.apache.xpath.ExpressionNode,5,1,0,44,5,10,44,0,5,2.0,5,0.0,0,0.0,0.6,0,0,0.0,1,1.0,0,"
package org.apache.xpath;

import javax.xml.transform.SourceLocator;


public interface ExpressionNode extends SourceLocator
{
  
  public void exprSetParent(ExpressionNode n);
  public ExpressionNode exprGetParent();

  
  public void exprAddChild(ExpressionNode n, int i);

  
  public ExpressionNode exprGetChild(int i);

  
  public int exprGetNumChildren();
}

"
org.apache.xpath.axes.LocPathIterator,52,4,8,37,84,1016,21,20,45,0.85130719,665,0.833333333,4,0.616,0.145104895,2,9,11.55769231,12,1.4231,1,"
package org.apache.xpath.axes;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;


public abstract class LocPathIterator extends PredicatedNodeTest
        implements Cloneable, DTMIterator, java.io.Serializable, PathComponent
{
	
  
  protected LocPathIterator()
  {
  }


  
  protected LocPathIterator(PrefixResolver nscontext)
  {

    setLocPathIterator(this);
    m_prefixResolver = nscontext;
  }

  
  protected LocPathIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    this(compiler, opPos, analysis, true);
  }

  
  protected LocPathIterator(
          Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers)
            throws javax.xml.transform.TransformerException
  {
    setLocPathIterator(this);
  }
  
  
  public int getAnalysisBits()
  {
  	int axis = getAxis();
  	int bit = WalkerFactory.getAnalysisBitFromAxes(axis);
  	return bit;
  }
  
  
  private void readObject(java.io.ObjectInputStream stream)
          throws java.io.IOException, javax.xml.transform.TransformerException
  {
    try
    {
      stream.defaultReadObject();
      m_clones =  new IteratorPool(this);
    }
    catch (ClassNotFoundException cnfe)
    {
      throw new javax.xml.transform.TransformerException(cnfe);
    }
  }
  
  
  public void setEnvironment(Object environment)
  {
    
  }
  
  
  public DTM getDTM(int nodeHandle)
  {
    
    return m_execContext.getDTM(nodeHandle);
  }
  
  
  public DTMManager getDTMManager()
  {
    return m_execContext.getDTMManager();
  }
  
  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    XNodeSet iter = new XNodeSet((LocPathIterator)m_clones.getInstance());

    iter.setRoot(xctxt.getCurrentNode(), xctxt);

    return iter;
  }
    
  
  public void executeCharsToContentHandler(
          XPathContext xctxt, org.xml.sax.ContentHandler handler)
            throws javax.xml.transform.TransformerException,
                   org.xml.sax.SAXException
  {
    LocPathIterator clone = (LocPathIterator)m_clones.getInstance();

    int current = xctxt.getCurrentNode();
    clone.setRoot(current, xctxt);
    
    int node = clone.nextNode();
    DTM dtm = clone.getDTM(node);
    clone.detach();
	
    if(node != DTM.NULL)
    {
      dtm.dispatchCharactersEvents(node, handler, false);
    }
  }
  
  
  public DTMIterator asIterator(
          XPathContext xctxt, int contextNode)
            throws javax.xml.transform.TransformerException
  {
    XNodeSet iter = new XNodeSet((LocPathIterator)m_clones.getInstance());

    iter.setRoot(contextNode, xctxt);

    return iter;
  }

  
  
  public boolean isNodesetExpr()
  {
    return true;
  }
  
  
  public int asNode(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
    DTMIterator iter = (DTMIterator)m_clones.getInstance();
    
    int current = xctxt.getCurrentNode();
    
    iter.setRoot(current, xctxt);

    int next = iter.nextNode();
    
    iter.detach();
    return next;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return (asNode(xctxt) != DTM.NULL);
  }


  
  public void setIsTopLevel(boolean b)
  {
    m_isTopLevel = b;
  }

  
  public boolean getIsTopLevel()
  {
    return m_isTopLevel;
  }
  
  
  public void setRoot(int context, Object environment)
  {

    m_context = context;
    
    XPathContext xctxt = (XPathContext)environment;
    m_execContext = xctxt;
    m_cdtm = xctxt.getDTM(context);
    
    m_currentContextNode = context; 
    
    
    if(null == m_prefixResolver)
    	m_prefixResolver = xctxt.getNamespaceContext();
        
    m_lastFetched = DTM.NULL;
    m_foundLast = false;
    m_pos = 0;
    m_length = -1;

    if (m_isTopLevel)
      this.m_stackFrame = xctxt.getVarStack().getStackFrame();
      
    
  }

  
  protected void setNextPosition(int next)
  {
    assertion(false, ""setNextPosition not supported in this iterator!"");
  }

  
  public final int getCurrentPos()
  {
    return m_pos;
  }


  
  public void setShouldCacheNodes(boolean b)
  {

    assertion(false, ""setShouldCacheNodes not supported by this iterater!"");
  }
  
  
  public boolean isMutable()
  {
    return false;
  }

  
  public void setCurrentPos(int i)
  {
  	assertion(false, ""setCurrentPos not supported by this iterator!"");
  }
  
  
  public void incrementCurrentPos()
  {
  	m_pos++;
  }


  
  public int size()
  {
	assertion(false, ""size() not supported by this iterator!"");
	return 0;
  }

  
  public int item(int index)
  {
	assertion(false, ""item(int index) not supported by this iterator!"");
	return 0;
  }
  
  
  public void setItem(int node, int index)
  {
	assertion(false, ""setItem not supported by this iterator!"");
  }

  
  public int getLength()
  {      
    
  	boolean isPredicateTest = (this == m_execContext.getSubContextList());

    
  	int predCount = getPredicateCount();
  	
    
    
    
    if (-1 != m_length && isPredicateTest && m_predicateIndex < 1)
  		return m_length;
  	
    
    
    if (m_foundLast)
  		return m_pos;
  		
    
    
    
    int pos = (m_predicateIndex >= 0) ? getProximityPosition() : m_pos;
              
    LocPathIterator clone;

    try
    {
      clone = (LocPathIterator) clone();        
    }
    catch (CloneNotSupportedException cnse)
    {
      return -1;
    }

    
    
    
    if (predCount > 0 && isPredicateTest)
    {
      
      clone.m_predCount = m_predicateIndex;
      
      
      
    }

    int next;

    while (DTM.NULL != (next = clone.nextNode()))
    {
      pos++;
    }
    
    if (isPredicateTest && m_predicateIndex < 1)
      m_length = pos;
    
    return pos;
  }

  
  public boolean isFresh()
  {
    return (m_pos == 0);
  }

  
  public int previousNode()
  {
    throw new RuntimeException(
      XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE, null)); 
  }

  
  public int getWhatToShow()
  {

    
    return DTMFilter.SHOW_ALL & ~DTMFilter.SHOW_ENTITY_REFERENCE;
  }

  
  public DTMFilter getFilter()
  {
    return null;
  }

  
  public int getRoot()
  {
    return m_context;
  }

  
  public boolean getExpandEntityReferences()
  {
    return true;
  }
  
  
  protected boolean m_allowDetach = true;
  
  
  public void allowDetachToRelease(boolean allowRelease)
  {
    m_allowDetach = allowRelease;
  }

  
  public void detach()
  {    
    if(m_allowDetach)
    {
      
      
      m_execContext = null;
      
      m_cdtm = null;
      m_length = -1;
      m_pos = 0;
      m_lastFetched = DTM.NULL;
      m_context = DTM.NULL;
      m_currentContextNode = DTM.NULL;
      
      m_clones.freeInstance(this);
    }
  }
  
  
  public void reset()
  {
  	assertion(false, ""This iterator can not reset!"");
  }

  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {
    LocPathIterator clone;

    clone = (LocPathIterator)m_clones.getInstanceOrThrow();
    clone.m_execContext = m_execContext;
    clone.m_cdtm = m_cdtm;
    
    clone.m_context = m_context;
    clone.m_currentContextNode = m_currentContextNode;
    clone.m_stackFrame = m_stackFrame;

    

    return clone;
  }

















  
  public abstract int nextNode();

  
  protected int returnNextNode(int nextNode)
  {

    if (DTM.NULL != nextNode)
    {
      m_pos++;
    }

    m_lastFetched = nextNode;

    if (DTM.NULL == nextNode)
      m_foundLast = true;

    return nextNode;
  }

  
  public int getCurrentNode()
  {
    return m_lastFetched;
  }

  
  public void runTo(int index)
  {

    if (m_foundLast || ((index >= 0) && (index <= getCurrentPos())))
      return;

    int n;

    if (-1 == index)
    {
      while (DTM.NULL != (n = nextNode()));
    }
    else
    {
      while (DTM.NULL != (n = nextNode()))
      {
        if (getCurrentPos() >= index)
          break;
      }
    }
  }

  
  public final boolean getFoundLast()
  {
    return m_foundLast;
  }

  
  public final XPathContext getXPathContext()
  {
    return m_execContext;
  }

  
  public final int getContext()
  {
    return m_context;
  }

  
  public final int getCurrentContextNode()
  {
    return m_currentContextNode;
  }

  
  public final void setCurrentContextNode(int n)
  {
    m_currentContextNode = n;
  }
  











  
  public final PrefixResolver getPrefixResolver()
  {
  	if(null == m_prefixResolver)
  	{
    	m_prefixResolver = (PrefixResolver)getExpressionOwner();
  	}

    return m_prefixResolver;
  }
        




















  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	 	if(visitor.visitLocationPath(owner, this))
  	 	{
  	 		visitor.visitStep(owner, this);
  	 		callPredicateVisitors(visitor);
  	 	}
  }  

  
  
  
  
  transient protected IteratorPool m_clones = new IteratorPool(this);
  
  
  transient protected DTM m_cdtm;
  
  
  transient int m_stackFrame = -1;

  
  private boolean m_isTopLevel = false;

  
  transient public int m_lastFetched = DTM.NULL;

  
  transient protected int m_context = DTM.NULL;

  
  transient protected int m_currentContextNode = DTM.NULL;
  
  
  transient protected int m_pos = 0;
  
  transient protected int m_length = -1;

  
  private PrefixResolver m_prefixResolver;

  
  transient protected XPathContext m_execContext;
  
  
  public boolean isDocOrdered()
  {
    return true;
  }
  
  
  public int getAxis()
  {
    return -1;
  }









  
  public int getLastPos(XPathContext xctxt)
  {
    return getLength();
  }

}
"
org.apache.xml.utils.SerializableLocatorImpl,10,1,0,0,15,37,0,0,10,0.777777778,64,1.0,0,0.0,0.375,0,0,5.0,1,0.8,0,"
package org.apache.xml.utils;



public class SerializableLocatorImpl
implements org.xml.sax.Locator, java.io.Serializable

{
    
    public SerializableLocatorImpl ()
    {
    }
    
    
    
    public SerializableLocatorImpl (org.xml.sax.Locator locator)
    {
        setPublicId(locator.getPublicId());
        setSystemId(locator.getSystemId());
        setLineNumber(locator.getLineNumber());
        setColumnNumber(locator.getColumnNumber());
    }
    
    
    
    
    
    
    
    
    public String getPublicId ()
    {
        return publicId;
    }
    
    
    
    public String getSystemId ()
    {
        return systemId;
    }
    
    
    
    public int getLineNumber ()
    {
        return lineNumber;
    }
    
    
    
    public int getColumnNumber ()
    {
        return columnNumber;
    }
    
    
    
    
    
    
    
    
    public void setPublicId (String publicId)
    {
        this.publicId = publicId;
    }
    
    
    
    public void setSystemId (String systemId)
    {
        this.systemId = systemId;
    }
    
    
    
    public void setLineNumber (int lineNumber)
    {
        this.lineNumber = lineNumber;
    }
    
    
    
    public void setColumnNumber (int columnNumber)
    {
        this.columnNumber = columnNumber;
    }
    
    
    
    
    
    
    
    private String publicId;
    
    
    private String systemId;
    
    
    private int lineNumber;
    
    
    private int columnNumber;
    
}


"
org.apache.xalan.xsltc.runtime.output.WriterOutputBuffer,6,1,0,1,16,0,0,1,5,0.733333333,88,1.0,0,0.0,0.333333333,0,0,13.16666667,1,0.6667,0,"

package org.apache.xalan.xsltc.runtime.output;

import java.io.BufferedWriter;
import java.io.IOException;
import java.io.Writer;

class WriterOutputBuffer implements OutputBuffer {
    private static final int KB = 1024;
    private static int BUFFER_SIZE = 4 * KB;

    static {
	
	final String osName = System.getProperty(""os.name"");
	if (osName.equalsIgnoreCase(""solaris"")) {
	    BUFFER_SIZE = 32 * KB;
	}
    }

    private Writer _writer;

    
    public WriterOutputBuffer(Writer writer) {
	_writer = new BufferedWriter(writer, BUFFER_SIZE);
    }

    public String close() {
	try {
	    _writer.flush();
	}
	catch (IOException e) {
	    throw new RuntimeException(e.toString());
	}
	return """";
    }

    public OutputBuffer append(String s) {
	try {
	    _writer.write(s);
	}
	catch (IOException e) {
	    throw new RuntimeException(e.toString());
	}
	return this;
    }

    public OutputBuffer append(char[] s, int from, int to) {
	try {
	    _writer.write(s, from, to);
	}
	catch (IOException e) {
	    throw new RuntimeException(e.toString());
	}
	return this;
    }

    public OutputBuffer append(char ch) {
	try {
	    _writer.write(ch);
	}
	catch (IOException e) {
	    throw new RuntimeException(e.toString());
	}
	return this;
    }
}


"
org.apache.xml.dtm.ref.DTMAxisIterNodeList,5,2,0,5,12,0,1,4,4,0.4375,119,1.0,3,0.4,0.4,0,0,22.0,7,2.2,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.utils.IntVector;

import org.w3c.dom.Node;


public class DTMAxisIterNodeList extends DTMNodeListBase {
    private DTM m_dtm;
    private DTMAxisIterator m_iter;
    private IntVector m_cachedNodes;
    private int m_last = -1;
    
    
    private DTMAxisIterNodeList() {
    }

    
    public DTMAxisIterNodeList(DTM dtm, DTMAxisIterator dtmAxisIterator) {
        if (dtmAxisIterator == null) {
            m_last = 0;
        } else {
            m_cachedNodes = new IntVector();
            m_dtm = dtm;
        }
        m_iter = dtmAxisIterator;
    }

    
    public DTMAxisIterator getDTMAxisIterator() {
        return m_iter;
    }
  

    
    

    
    public Node item(int index) {
        if (m_iter != null) {
            int node;
            int count = m_cachedNodes.size();

            if (count > index) {
                node = m_cachedNodes.elementAt(index);
                return m_dtm.getNode(node);
            } else if (m_last == -1) {
                while (((node = m_iter.next()) != DTMAxisIterator.END)
                           && count <= index) {
                    m_cachedNodes.addElement(node);
                    count++;
                }
                if (node == DTMAxisIterator.END) {
                    m_last = count;
                } else {
                    return m_dtm.getNode(node);
                }
            }
        }
        return null;
    }

    
    public int getLength() {
        if (m_last == -1) {
            int node;
            while ((node = m_iter.next()) != DTMAxisIterator.END) {
                m_cachedNodes.addElement(node);
            }
            m_last = m_cachedNodes.size();
        }
        return m_last;
    }
}
"
org.apache.xml.serializer.EmptySerializer,81,1,2,5,82,3240,2,3,80,1.0125,266,1.0,0,0.0,0.096707819,0,0,2.271604938,1,0.9877,0,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Vector;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.Transformer;

import org.w3c.dom.Node;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;


public class EmptySerializer implements SerializationHandler
{
    protected static final String ERR = ""EmptySerializer method not over-ridden"";
    

    private static void throwUnimplementedException()
    {
        
        
        return;
    }
    
    public ContentHandler asContentHandler() throws IOException
    {
        throwUnimplementedException();
        return null;
    }
    
    public void setContentHandler(ContentHandler ch)
    {
        throwUnimplementedException();
    }
    
    public void close()
    {
        throwUnimplementedException();
    }
    
    public Properties getOutputFormat()
    {
        throwUnimplementedException();
        return null;
    }
    
    public OutputStream getOutputStream()
    {
        throwUnimplementedException();
        return null;
    }
    
    public Writer getWriter()
    {
        throwUnimplementedException();
        return null;
    }
    
    public boolean reset()
    {
        throwUnimplementedException();
        return false;
    }
    
    public void serialize(Node node) throws IOException
    {
        throwUnimplementedException();
    }
    
    public void setCdataSectionElements(Vector URI_and_localNames)
    {
        throwUnimplementedException();
    }
    
    public boolean setEscaping(boolean escape) throws SAXException
    {
        throwUnimplementedException();
        return false;
    }
    
    public void setIndent(boolean indent)
    {
        throwUnimplementedException();
    }
    
    public void setIndentAmount(int spaces)
    {
        throwUnimplementedException();
    }
    
    public void setOutputFormat(Properties format)
    {
        throwUnimplementedException();
    }
    
    public void setOutputStream(OutputStream output)
    {
        throwUnimplementedException();
    }
    
    public void setVersion(String version)
    {
        throwUnimplementedException();
    }
    
    public void setWriter(Writer writer)
    {
        throwUnimplementedException();
    }
    
    public void setTransformer(Transformer transformer)
    {
        throwUnimplementedException();
    }
    
    public Transformer getTransformer()
    {
        throwUnimplementedException();
        return null;
    }
    
    public void flushPending()
    {
        throwUnimplementedException();
    }
    
    public void addAttribute(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void addAttributes(Attributes atts) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void addAttribute(String name, String value)
    {
        throwUnimplementedException();
    }
    
    public void characters(String chars) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void endElement(String elemName) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void startDocument() throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void startElement(String uri, String localName, String qName)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void startElement(String qName) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void namespaceAfterStartElement(String uri, String prefix)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public boolean startPrefixMapping(
        String prefix,
        String uri,
        boolean shouldFlush)
        throws SAXException
    {
        throwUnimplementedException();
        return false;
    }
    
    public void entityReference(String entityName) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public NamespaceMappings getNamespaceMappings()
    {
        throwUnimplementedException();
        return null;
    }
    
    public String getPrefix(String uri)
    {
        throwUnimplementedException();
        return null;
    }
    
    public String getNamespaceURI(String name, boolean isElement)
    {
        throwUnimplementedException();
        return null;
    }
    
    public String getNamespaceURIFromPrefix(String prefix)
    {
        throwUnimplementedException();
        return null;
    }
    
    public void setDocumentLocator(Locator arg0)
    {
        throwUnimplementedException();
    }
    
    public void endDocument() throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void startPrefixMapping(String arg0, String arg1)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void endPrefixMapping(String arg0) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void startElement(
        String arg0,
        String arg1,
        String arg2,
        Attributes arg3)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void endElement(String arg0, String arg1, String arg2)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void characters(char[] arg0, int arg1, int arg2) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void ignorableWhitespace(char[] arg0, int arg1, int arg2)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void processingInstruction(String arg0, String arg1)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void skippedEntity(String arg0) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void comment(String comment) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void startDTD(String arg0, String arg1, String arg2)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void endDTD() throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void startEntity(String arg0) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void endEntity(String arg0) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void startCDATA() throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void endCDATA() throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void comment(char[] arg0, int arg1, int arg2) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public String getDoctypePublic()
    {
        throwUnimplementedException();
        return null;
    }
    
    public String getDoctypeSystem()
    {
        throwUnimplementedException();
        return null;
    }
    
    public String getEncoding()
    {
        throwUnimplementedException();
        return null;
    }
    
    public boolean getIndent()
    {
        throwUnimplementedException();
        return false;
    }
    
    public int getIndentAmount()
    {
        throwUnimplementedException();
        return 0;
    }
    
    public String getMediaType()
    {
        throwUnimplementedException();
        return null;
    }
    
    public boolean getOmitXMLDeclaration()
    {
        throwUnimplementedException();
        return false;
    }
    
    public String getStandalone()
    {
        throwUnimplementedException();
        return null;
    }
    
    public String getVersion()
    {
        throwUnimplementedException();
        return null;
    }
    
    public void setCdataSectionElements(Hashtable h) throws Exception
    {
        throwUnimplementedException();
    }
    
    public void setDoctype(String system, String pub)
    {
        throwUnimplementedException();
    }
    
    public void setDoctypePublic(String doctype)
    {
        throwUnimplementedException();
    }
    
    public void setDoctypeSystem(String doctype)
    {
        throwUnimplementedException();
    }
    
    public void setEncoding(String encoding)
    {
        throwUnimplementedException();
    }
    
    public void setMediaType(String mediatype)
    {
        throwUnimplementedException();
    }
    
    public void setOmitXMLDeclaration(boolean b)
    {
        throwUnimplementedException();
    }
    
    public void setStandalone(String standalone)
    {
        throwUnimplementedException();
    }
    
    public void elementDecl(String arg0, String arg1) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void attributeDecl(
        String arg0,
        String arg1,
        String arg2,
        String arg3,
        String arg4)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void internalEntityDecl(String arg0, String arg1)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void externalEntityDecl(String arg0, String arg1, String arg2)
        throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void warning(SAXParseException arg0) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void error(SAXParseException arg0) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public void fatalError(SAXParseException arg0) throws SAXException
    {
        throwUnimplementedException();
    }
    
    public DOMSerializer asDOMSerializer() throws IOException
    {
        throwUnimplementedException();
        return null;
    }

    
    public void setNamespaceMappings(NamespaceMappings mappings) {
        throwUnimplementedException();
    }
    
    public void setSourceLocator(SourceLocator locator)
    {
        throwUnimplementedException();
    }

}
"
org.apache.xml.dtm.ref.DTMAxisIteratorBase,14,1,19,21,21,59,19,2,12,0.807692308,163,1.0,0,0.0,0.404761905,0,0,10.21428571,5,1.4286,1,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTMAxisIterator;


public abstract class DTMAxisIteratorBase implements DTMAxisIterator
{

  
  protected int _last = -1;

  
  protected int _position = 0;

  
  protected int _markedNode;

  
  protected int _startNode = DTMAxisIterator.END;

  
  protected boolean _includeSelf = false;

  
  protected boolean _isRestartable = true;
  
  
  public int getStartNode()
  {
    return _startNode;
  }

  
  public DTMAxisIterator reset()
  {

    final boolean temp = _isRestartable;

    _isRestartable = true;

    setStartNode(_startNode);

    _isRestartable = temp;

    return this;
  }

  
  public DTMAxisIterator includeSelf()
  {

    _includeSelf = true;

    return this;
  }

  
  public int getLast()
  {

    if (_last == -1)		
    {
      
      
      
      
      
      

      final int temp = _position; 
      setMark();

      reset();			
      do
      {
        _last++;
      }
      while (next() != END);

      gotoMark();		
      _position = temp;
    }

    return _last;
  }

  
  public int getPosition()
  {
    return _position == 0 ? 1 : _position;
  }

  
  public boolean isReverse()
  {
    return false;
  }

  
  public DTMAxisIterator cloneIterator()
  {

    try
    {
      final DTMAxisIteratorBase clone = (DTMAxisIteratorBase) super.clone();

      

      
      return clone;
    }
    catch (CloneNotSupportedException e)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(e);
    }
  }

  
  protected final int returnNode(final int node)
  {
    _position++;

    return node;
  }

  
  protected final DTMAxisIterator resetPosition()
  {

    _position = 0;

    return this;
  }
  
  
  public boolean isDocOrdered()
  {
    return true;
  }
  
  
  public int getAxis()
  {
    return -1;
  }
  
  public void setRestartable(boolean isRestartable) {
    _isRestartable = isRestartable;
  }  

  
  public int getNodeByPosition(int position)
  {
    if (position > 0) {
      final int pos = isReverse() ? getLast() - position + 1
                                   : position;
      int node;
      while ((node = next()) != DTMAxisIterator.END) {
        if (pos == getPosition()) {
          return node;
        }
      }
    }
    return END;
  }
  
}
"
org.apache.xml.dtm.ref.CustomStringPool,4,2,0,1,15,0,0,1,4,0.833333333,62,0.0,0,0.571428571,0.5,1,4,14.0,3,1.5,0,"

package org.apache.xml.dtm.ref;
import java.util.Hashtable;


public class CustomStringPool extends DTMStringPool {
        
        
        
        final Hashtable m_stringToInt = new Hashtable();
        public static final int NULL=-1;

        public CustomStringPool()
        {
                super();
                
                
                
        }

        public void removeAllElements()
        {
                m_intToString.removeAllElements();
                if (m_stringToInt != null) 
                        m_stringToInt.clear();
        }

        
        public String indexToString(int i)
        throws java.lang.ArrayIndexOutOfBoundsException
        {
                return(String) m_intToString.elementAt(i);
        }

        
        public int stringToIndex(String s)
        {
                if (s==null) return NULL;
                Integer iobj=(Integer)m_stringToInt.get(s);
                if (iobj==null) {
                        m_intToString.addElement(s);
                        iobj=new Integer(m_intToString.size());
                        m_stringToInt.put(s,iobj);
                }
                return iobj.intValue();
        }
}
"
org.apache.xpath.SourceTreeManager,13,1,0,8,46,42,4,5,13,0.625,339,0.5,0,0.0,0.340659341,0,0,24.92307692,5,1.8462,0,"
package org.apache.xpath;

import java.io.IOException;
import java.util.Vector;

import javax.xml.transform.Source;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;

import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.SystemIDResolver;

import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;


public class SourceTreeManager
{

  
  private Vector m_sourceTree = new Vector();

  
  public void reset()
  {
    m_sourceTree = new Vector();
  }

  
  URIResolver m_uriResolver;

  
  public void setURIResolver(URIResolver resolver)
  {
    m_uriResolver = resolver;
  }

  
  public URIResolver getURIResolver()
  {
    return m_uriResolver;
  }

  
  public String findURIFromDoc(int owner)
  {
    int n = m_sourceTree.size();

    for (int i = 0; i < n; i++)
    {
      SourceTree sTree = (SourceTree) m_sourceTree.elementAt(i);

      if (owner == sTree.m_root)
        return sTree.m_url;
    }

    return null;
  }

  
  public Source resolveURI(
          String base, String urlString, SourceLocator locator)
            throws TransformerException, IOException
  {

    Source source = null;

    if (null != m_uriResolver)
    {
      source = m_uriResolver.resolve(urlString, base);
    }

    if (null == source)
    {
      String uri = SystemIDResolver.getAbsoluteURI(urlString, base);

      source = new StreamSource(uri);
    }

    return source;
  }

  
  public void removeDocumentFromCache(int n)
  {
    if(DTM.NULL ==n)
      return;
    for(int i=m_sourceTree.size()-1;i>=0;--i)
    {
      SourceTree st=(SourceTree)m_sourceTree.elementAt(i);
      if(st!=null && st.m_root==n)
      {
	m_sourceTree.removeElementAt(i);
	return;
      }
    }
  }
  


  
  public void putDocumentInCache(int n, Source source)
  {

    int cachedNode = getNode(source);

    if (DTM.NULL != cachedNode)
    {
      if (!(cachedNode == n))
        throw new RuntimeException(
          ""Programmer's Error!  ""
          + ""putDocumentInCache found reparse of doc: ""
          + source.getSystemId());
      return;
    }
    if (null != source.getSystemId())
    {
      m_sourceTree.addElement(new SourceTree(n, source.getSystemId()));
    }
  }

  
  public int getNode(Source source)
  {




    
    String url = source.getSystemId();

    if (null == url)
      return DTM.NULL;

    int n = m_sourceTree.size();

    
    for (int i = 0; i < n; i++)
    {
      SourceTree sTree = (SourceTree) m_sourceTree.elementAt(i);

      
      
      if (url.equals(sTree.m_url))
        return sTree.m_root;
    }

    
    return DTM.NULL;
  }

  
  public int getSourceTree(
          String base, String urlString, SourceLocator locator, XPathContext xctxt)
            throws TransformerException
  {

    
    try
    {
      Source source = this.resolveURI(base, urlString, locator);

      
      return getSourceTree(source, locator, xctxt);
    }
    catch (IOException ioe)
    {
      throw new TransformerException(ioe.getMessage(), locator, ioe);
    }

    
  }

  
  public int getSourceTree(Source source, SourceLocator locator, XPathContext xctxt)
          throws TransformerException
  {

    int n = getNode(source);

    if (DTM.NULL != n)
      return n;

    n = parseToNode(source, locator, xctxt);

    if (DTM.NULL != n)
      putDocumentInCache(n, source);

    return n;
  }

  
  public int parseToNode(Source source, SourceLocator locator, XPathContext xctxt)
          throws TransformerException
  {

    try
    {      
      Object xowner = xctxt.getOwnerObject();
      DTM dtm;
      if(null != xowner && xowner instanceof org.apache.xml.dtm.DTMWSFilter)
      {
        dtm = xctxt.getDTM(source, false, 
                          (org.apache.xml.dtm.DTMWSFilter)xowner, false, true);
      }
      else
      {
        dtm = xctxt.getDTM(source, false, null, false, true);
      }
      return dtm.getDocument();
    }
    catch (Exception e)
    {
      
      throw new TransformerException(e.getMessage(), locator, e);
    }

  }

  
  public static XMLReader getXMLReader(Source inputSource, SourceLocator locator)
          throws TransformerException
  {

    try
    {
      XMLReader reader = (inputSource instanceof SAXSource)
                         ? ((SAXSource) inputSource).getXMLReader() : null;
                         
      if (null == reader)
      {
        try {
          javax.xml.parsers.SAXParserFactory factory=
              javax.xml.parsers.SAXParserFactory.newInstance();
          factory.setNamespaceAware( true );
          javax.xml.parsers.SAXParser jaxpParser=
              factory.newSAXParser();
          reader=jaxpParser.getXMLReader();
          
        } catch( javax.xml.parsers.ParserConfigurationException ex ) {
          throw new org.xml.sax.SAXException( ex );
        } catch( javax.xml.parsers.FactoryConfigurationError ex1 ) {
            throw new org.xml.sax.SAXException( ex1.toString() );
        } catch( NoSuchMethodError ex2 ) {
        }
        catch (AbstractMethodError ame){}
        if(null == reader)
          reader = XMLReaderFactory.createXMLReader();
      }

      try
      {
        reader.setFeature(""http:
                          true);
      }
      catch (org.xml.sax.SAXException se)
      {

        
        
      }

      return reader;
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se.getMessage(), locator, se);
    }
  }
}
"
org.apache.xalan.xsltc.compiler.IllegalCharException,1,3,0,0,2,0,0,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.apache.xalan.xsltc.compiler;

class IllegalCharException extends Exception {
    public IllegalCharException(String s) {
	super(s);
    }
}
"
org.apache.xml.dtm.ref.DTMNodeProxy,121,1,0,13,151,5992,7,6,120,0.794444444,1009,0.0,1,0.0,0.185185185,0,0,7.314049587,4,1.1818,1,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMDOMException;

import org.w3c.dom.Attr;
import org.w3c.dom.CDATASection;
import org.w3c.dom.Comment;
import org.w3c.dom.DOMException;
import org.w3c.dom.DOMImplementation;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.EntityReference;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Text;


public class DTMNodeProxy
  implements Node, Document, Text, Element, Attr,
                   ProcessingInstruction, Comment, DocumentFragment
{

  
  public DTM dtm;

  
  int node;
        
  
  static final DOMImplementation implementation=new DTMNodeProxyImplementation();

  
  public DTMNodeProxy(DTM dtm, int node)
  {
    this.dtm = dtm;
    this.node = node;
  }

  
  public final DTM getDTM()
  {
    return dtm;
  }

  
  public final int getDTMNodeNumber()
  {
    return node;
  }

  
  public final boolean equals(Node node)
  {

    try
    {
      DTMNodeProxy dtmp = (DTMNodeProxy) node;

      
      
      return (dtmp.node == this.node) && (dtmp.dtm == this.dtm);
    }
    catch (ClassCastException cce)
    {
      return false;
    }
  }

  
  public final boolean equals(Object node)
  {

    try
    {

      
      
      
      return equals((Node) node);
    }
    catch (ClassCastException cce)
    {
      return false;
    }
  }

  
  public final boolean sameNodeAs(Node other)
  {

    if (!(other instanceof DTMNodeProxy))
      return false;

    DTMNodeProxy that = (DTMNodeProxy) other;

    return this.dtm == that.dtm && this.node == that.node;
  }

  
  public final String getNodeName()
  {
    return dtm.getNodeName(node);
  }

  
  public final String getTarget()
  {
    return dtm.getNodeName(node);
  }  

  
  public final String getLocalName()
  {
    return dtm.getLocalName(node);
  }

  
  public final String getPrefix()
  {
    return dtm.getPrefix(node);
  }

  
  public final void setPrefix(String prefix) throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final String getNamespaceURI()
  {
    return dtm.getNamespaceURI(node);
  }

  
  public final boolean supports(String feature, String version)
  {
    return implementation.hasFeature(feature,version);
    
  }

  
  public final boolean isSupported(String feature, String version)
  {
    return implementation.hasFeature(feature,version);
    
  }

  
  public final String getNodeValue() throws DOMException
  {
    return dtm.getNodeValue(node);
  }
  
  
  public final String getStringValue() throws DOMException
  {
  	return dtm.getStringValue(node).toString();
  }

  
  public final void setNodeValue(String nodeValue) throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final short getNodeType()
  {
    return (short) dtm.getNodeType(node);
  }

  
  public final Node getParentNode()
  {

    if (getNodeType() == Node.ATTRIBUTE_NODE)
      return null;

    int newnode = dtm.getParent(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final Node getOwnerNode()
  {

    int newnode = dtm.getParent(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final NodeList getChildNodes()
  {
                
    
    
    
    return new DTMChildIterNodeList(dtm,node);

    
  }

  
  public final Node getFirstChild()
  {

    int newnode = dtm.getFirstChild(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final Node getLastChild()
  {

    int newnode = dtm.getLastChild(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final Node getPreviousSibling()
  {

    int newnode = dtm.getPreviousSibling(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final Node getNextSibling()
  {

    
    if (dtm.getNodeType(node) == Node.ATTRIBUTE_NODE)
      return null;

    int newnode = dtm.getNextSibling(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  

  
  public final NamedNodeMap getAttributes()
  {

    return new DTMNamedNodeMap(dtm, node);
  }

  
  public boolean hasAttribute(String name)
  {
    return DTM.NULL != dtm.getAttributeNode(node,null,name);
  }

  
  public boolean hasAttributeNS(String name, String x)
  {
    return DTM.NULL != dtm.getAttributeNode(node,x,name);
  }

  
  public final Document getOwnerDocument()
  {
  	
	return (Document)(dtm.getNode(dtm.getOwnerDocument(node)));
  }

  
  public final Node insertBefore(Node newChild, Node refChild)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final Node replaceChild(Node newChild, Node oldChild)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final Node removeChild(Node oldChild) throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final Node appendChild(Node newChild) throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final boolean hasChildNodes()
  {
    return (DTM.NULL != dtm.getFirstChild(node));
  }

  
  public final Node cloneNode(boolean deep)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final DocumentType getDoctype()
  {
    return null;
  }

  
  public final DOMImplementation getImplementation()
  {
    return implementation;
  }

  
  public final Element getDocumentElement()
  {
		int dochandle=dtm.getDocument();
		int elementhandle=DTM.NULL;
		for(int kidhandle=dtm.getFirstChild(dochandle);
				kidhandle!=DTM.NULL;
				kidhandle=dtm.getNextSibling(kidhandle))
		{
			switch(dtm.getNodeType(kidhandle))
			{
			case Node.ELEMENT_NODE:
				if(elementhandle!=DTM.NULL) 
				{
					elementhandle=DTM.NULL; 
					kidhandle=dtm.getLastChild(dochandle); 
				}
				else
					elementhandle=kidhandle;
				break;
				
			
			case Node.COMMENT_NODE:
			case Node.PROCESSING_INSTRUCTION_NODE:
			case Node.DOCUMENT_TYPE_NODE:
				break;
					
			default:
				elementhandle=DTM.NULL; 
				kidhandle=dtm.getLastChild(dochandle); 
				break;
			}
		}
		if(elementhandle==DTM.NULL)
			throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
		else
			return (Element)(dtm.getNode(elementhandle));
  }

  
  public final Element createElement(String tagName) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final DocumentFragment createDocumentFragment()
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Text createTextNode(String data)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Comment createComment(String data)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final CDATASection createCDATASection(String data)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final ProcessingInstruction createProcessingInstruction(
                                                                 String target, String data) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr createAttribute(String name) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final EntityReference createEntityReference(String name)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final NodeList getElementsByTagName(String tagname)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Node importNode(Node importedNode, boolean deep)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final Element createElementNS(
                                       String namespaceURI, String qualifiedName) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr createAttributeNS(
                                      String namespaceURI, String qualifiedName) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final NodeList getElementsByTagNameNS(String namespaceURI,
                                               String localName)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Element getElementById(String elementId)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Text splitText(int offset) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final String getData() throws DOMException
  {
    return dtm.getNodeValue(node);
  }

  
  public final void setData(String data) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final int getLength()
  {
    
    return dtm.getNodeValue(node).length();
  }

  
  public final String substringData(int offset, int count) throws DOMException
  {
    return getData().substring(offset,offset+count);
  }

  
  public final void appendData(String arg) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void insertData(int offset, String arg) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void deleteData(int offset, int count) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void replaceData(int offset, int count, String arg)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final String getTagName()
  {
    return dtm.getNodeName(node);
  }

  
  public final String getAttribute(String name)
  {

    DTMNamedNodeMap  map = new DTMNamedNodeMap(dtm, node);
    Node node = map.getNamedItem(name);
    return (null == node) ? null : node.getNodeValue();
  }

  
  public final void setAttribute(String name, String value)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void removeAttribute(String name) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr getAttributeNode(String name)
  {

    DTMNamedNodeMap  map = new DTMNamedNodeMap(dtm, node);
    return (Attr)map.getNamedItem(name);
  }

  
  public final Attr setAttributeNode(Attr newAttr) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr removeAttributeNode(Attr oldAttr) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public boolean hasAttributes()
  {
    return DTM.NULL != dtm.getFirstAttribute(node);
  }

  
  public final void normalize()
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final String getAttributeNS(String namespaceURI, String localName)
  {
    DTMNamedNodeMap  map = new DTMNamedNodeMap(dtm, node);
    Node node = map.getNamedItemNS(namespaceURI,localName);
    return (null == node) ? null : node.getNodeValue();
  }

  
  public final void setAttributeNS(
                                   String namespaceURI, String qualifiedName, String value)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void removeAttributeNS(String namespaceURI, String localName)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr getAttributeNodeNS(String namespaceURI, String localName)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr setAttributeNodeNS(Attr newAttr) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final String getName()
  {
    return dtm.getNodeName(node);
  }

  
  public final boolean getSpecified()
  {
    
    
    
    
    return true;
  }

  
  public final String getValue()
  {
    return dtm.getNodeValue(node);
  }

  
  public final void setValue(String value)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Element getOwnerElement()
  {
    if (getNodeType() != Node.ATTRIBUTE_NODE)
      return null;
    
    
    int newnode = dtm.getParent(node);
    return (newnode == DTM.NULL) ? null : (Element)(dtm.getNode(newnode));
  }

  
  public Node adoptNode(Node source) throws DOMException
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public String getEncoding()
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public void setEncoding(String encoding)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public boolean getStandalone()
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public void setStandalone(boolean standalone)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public boolean getStrictErrorChecking()
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public void setStrictErrorChecking(boolean strictErrorChecking)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public String getVersion()
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public void setVersion(String version)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }
        
        
  
  static class DTMNodeProxyImplementation implements DOMImplementation
  {
    public DocumentType createDocumentType(String qualifiedName,String publicId, String systemId)
    {
      throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
    }
    public Document createDocument(String namespaceURI,String qualfiedName,DocumentType doctype)                        
    {
      
      throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);        
    }
    
    public boolean hasFeature(String feature,String version)
    {
      if( (""CORE"".equals(feature.toUpperCase()) || ""XML"".equals(feature.toUpperCase())) 
					&& 
          (""1.0"".equals(version) || ""2.0"".equals(version))
          )
        return true;
      return false;
    }
  }
}
"
org.apache.xalan.xsltc.compiler.Stylesheet,55,2,0,65,186,1287,27,50,44,0.948888889,1928,0.92,6,0.5,0.101604278,2,6,33.6,9,2.1273,4,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.bcel.generic.ANEWARRAY;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.FieldGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.bcel.generic.TargetLostException;
import org.apache.bcel.util.InstructionFinder;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xml.dtm.DTM;

public final class Stylesheet extends SyntaxTreeNode {

    private String       _version;
    private QName        _name;
    private String       _systemId;
    private Stylesheet   _parentStylesheet;
	
    
    private Vector _globals = new Vector();

    
    private Boolean _hasLocalParams = null;

    
    private String _className;
    
    
    private final Vector _templates = new Vector();

    private int _nextModeSerial = 1;
    private final Hashtable _modes = new Hashtable();
    private final Hashtable _extensions = new Hashtable();

    public  Stylesheet _importedFrom = null;
    public  Stylesheet _includedFrom = null;
    private int _importPrecedence = 1;
    private Mode _defaultMode;
    private boolean _multiDocument = false;
    private boolean _callsNodeset = false;

    
    private Hashtable _keys = new Hashtable();

    private boolean _numberFormattingUsed = false;

    private boolean _simplified = false;

    private SourceLoader _loader = null;

    private boolean _templateInlining = true;

    private boolean _forwardReference = false;
    
    private boolean _hasIdCall = false;

    private Properties _outputProperties = null;

    public void setForwardReference() {
	_forwardReference = true;
    }

    public boolean getTemplateInlining() {
	return _templateInlining;
    }

    public void setTemplateInlining(boolean flag) {
	_templateInlining = flag;
    }

    public boolean isSimplified() {
	return(_simplified);
    }

    public void setSimplified() {
	_simplified = true;
    }
    
    public void setHasIdCall(boolean flag) {
        _hasIdCall = flag;
    }
    
    public void setOutputProperty(String key, String value) {
	if (_outputProperties == null) {
	    _outputProperties = new Properties();
	}
	_outputProperties.setProperty(key, value);
    }

    public void setOutputProperties(Properties props) {
	_outputProperties = props;
    }

    public Properties getOutputProperties() {
	return _outputProperties;
    }

    public void setMultiDocument(boolean flag) {	
	_multiDocument = flag;
    }

    public boolean isMultiDocument() {
	return _multiDocument;
    }

    public void setCallsNodeset(boolean flag) {
	if (flag) setMultiDocument(flag);
	_callsNodeset = flag;
    }

    public boolean callsNodeset() {
	return _callsNodeset;
    }

    public void numberFormattingUsed() {
	_numberFormattingUsed = true;
    }

    public void setImportPrecedence(final int precedence) {
	
	_importPrecedence = precedence;

	
	final Enumeration elements = elements();
	while (elements.hasMoreElements()) {
	    SyntaxTreeNode child = (SyntaxTreeNode)elements.nextElement();
	    if (child instanceof Include) {
		Stylesheet included = ((Include)child).getIncludedStylesheet();
		if (included != null && included._includedFrom == this) {
		    included.setImportPrecedence(precedence);
		}
	    }
	}

	
	if (_importedFrom != null) {
	    if (_importedFrom.getImportPrecedence() < precedence) {
		final Parser parser = getParser();
		final int nextPrecedence = parser.getNextImportPrecedence();
		_importedFrom.setImportPrecedence(nextPrecedence);
	    }
	}
	
	else if (_includedFrom != null) {
	    if (_includedFrom.getImportPrecedence() != precedence)
		_includedFrom.setImportPrecedence(precedence);
	}
    }
    
    public int getImportPrecedence() {
	return _importPrecedence;
    }

    public boolean checkForLoop(String systemId) {
	
	if (_systemId != null && _systemId.equals(systemId)) {
	    return true;
	}
	
	if (_parentStylesheet != null) 
	    return _parentStylesheet.checkForLoop(systemId);
	
	return false;
    }
    
    public void setParser(Parser parser) {
	super.setParser(parser);
	_name = makeStylesheetName(""__stylesheet_"");
    }
    
    public void setParentStylesheet(Stylesheet parent) {
	_parentStylesheet = parent;
    }
    
    public Stylesheet getParentStylesheet() {
	return _parentStylesheet;
    }

    public void setImportingStylesheet(Stylesheet parent) {
	_importedFrom = parent;
    }

    public void setIncludingStylesheet(Stylesheet parent) {
	_includedFrom = parent;
    }

    public void setSystemId(String systemId) {
	_systemId = systemId;
    }
    
    public String getSystemId() {
	return _systemId;
    }

    public void setSourceLoader(SourceLoader loader) {
	_loader = loader;
    }
    
    public SourceLoader getSourceLoader() {
	return _loader;
    }

    private QName makeStylesheetName(String prefix) {
	return getParser().getQName(prefix+getXSLTC().nextStylesheetSerial());
    }

    
    public boolean hasGlobals() {
	return _globals.size() > 0;
    }

    
    public boolean hasLocalParams() {
	if (_hasLocalParams == null) {
	    final int n = _templates.size();
	    for (int i = 0; i < n; i++) {
		final Template template = (Template)_templates.elementAt(i);
		if (template.hasParams()) {
		    _hasLocalParams = new Boolean(true);
		    return true;
		}
	    }
	    _hasLocalParams = new Boolean(false);
	    return false;
	}
	else {
	    return _hasLocalParams.booleanValue();
	}
    }

    
    protected void addPrefixMapping(String prefix, String uri) {
	if (prefix.equals(EMPTYSTRING) && uri.equals(XHTML_URI)) return;
	super.addPrefixMapping(prefix, uri);
    }

    
    private void extensionURI(String prefixes, SymbolTable stable) {
	if (prefixes != null) {
	    StringTokenizer tokens = new StringTokenizer(prefixes);
	    while (tokens.hasMoreTokens()) {
		final String prefix = tokens.nextToken();
		final String uri = lookupNamespace(prefix);
		if (uri != null) {
		    _extensions.put(uri, prefix);
		}
	    }
	}
    }

    public boolean isExtension(String uri) {
	return (_extensions.get(uri) != null);
    }

    public void excludeExtensionPrefixes(Parser parser) {
	final SymbolTable stable = parser.getSymbolTable();
    	final String excludePrefixes = getAttribute(""exclude-result-prefixes"");
	final String extensionPrefixes = getAttribute(""extension-element-prefixes"");
	
	
	stable.excludeURI(Constants.XSLT_URI);
	stable.excludeNamespaces(excludePrefixes);
	stable.excludeNamespaces(extensionPrefixes);
	extensionURI(extensionPrefixes, stable);
    }

    
    public void parseContents(Parser parser) {
	final SymbolTable stable = parser.getSymbolTable();

	

	
	addPrefixMapping(""xml"", ""http:

	
	final Stylesheet sheet = stable.addStylesheet(_name, this);
	if (sheet != null) {
	    
	    ErrorMsg err = new ErrorMsg(ErrorMsg.MULTIPLE_STYLESHEET_ERR,this);
	    parser.reportError(Constants.ERROR, err);
	}

	
	
	
	
	
	if (_simplified) {
	    stable.excludeURI(XSLT_URI);
	    Template template = new Template();
	    template.parseSimplified(this, parser);
	}
	
	else {
	    parseOwnChildren(parser);
	}
    }

    
    public final void parseOwnChildren(Parser parser) {
	final Vector contents = getContents();
	final int count = contents.size();

	
	
	for (int i = 0; i < count; i++) {
	    SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
	    if ((child instanceof VariableBase) ||
		(child instanceof NamespaceAlias)) {
		parser.getSymbolTable().setCurrentNode(child);
		child.parseContents(parser);
	    }
	}

	
	for (int i = 0; i < count; i++) {
	    SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
	    if (!(child instanceof VariableBase) && 
		!(child instanceof NamespaceAlias)) {
		parser.getSymbolTable().setCurrentNode(child);
		child.parseContents(parser);
	    }

	    
	    
	    if (!_templateInlining && (child instanceof Template)) {
		Template template = (Template)child;
		String name = ""template$dot$"" + template.getPosition();
		template.setName(parser.getQName(name));
	    }
	}
    }

    public void processModes() {
	if (_defaultMode == null)
	    _defaultMode = new Mode(null, this, Constants.EMPTYSTRING);
	_defaultMode.processPatterns(_keys);
	final Enumeration modes = _modes.elements();
	while (modes.hasMoreElements()) {
	    final Mode mode = (Mode)modes.nextElement();
	    mode.processPatterns(_keys);
	}
    }
	
    private void compileModes(ClassGenerator classGen) {
	_defaultMode.compileApplyTemplates(classGen);
	final Enumeration modes = _modes.elements();
	while (modes.hasMoreElements()) {
	    final Mode mode = (Mode)modes.nextElement();
	    mode.compileApplyTemplates(classGen);
	}
    }

    public Mode getMode(QName modeName) {
	if (modeName == null) {
	    if (_defaultMode == null) {
		_defaultMode = new Mode(null, this, Constants.EMPTYSTRING);
	    }
	    return _defaultMode;
	}
	else {
	    Mode mode = (Mode)_modes.get(modeName);
	    if (mode == null) {
		final String suffix = Integer.toString(_nextModeSerial++);
		_modes.put(modeName, mode = new Mode(modeName, this, suffix));
	    }
	    return mode;
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final int count = _globals.size();
	for (int i = 0; i < count; i++) {
	    final VariableBase var = (VariableBase)_globals.elementAt(i);
	    var.typeCheck(stable);
	}
	return typeCheckContents(stable);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	translate();
    }

    private void addDOMField(ClassGenerator classGen) {
	final FieldGen fgen = new FieldGen(ACC_PUBLIC,
					   Util.getJCRefType(DOM_INTF_SIG),
					   DOM_FIELD,
					   classGen.getConstantPool());
	classGen.addField(fgen.getField());
    }

    
    public void translate() {
	Output lastOutputElement = null;
	_className = getXSLTC().getClassName();

	
	final ClassGenerator classGen =
	    new ClassGenerator(_className,
			       TRANSLET_CLASS,
			       Constants.EMPTYSTRING,
			       ACC_PUBLIC | ACC_SUPER,
			       null, this);
	
	addDOMField(classGen);

	
	
	compileTransform(classGen);

	
	final Enumeration elements = elements();
	while (elements.hasMoreElements()) {
	    Object element = elements.nextElement();
	    
	    if (element instanceof Template) {
		
		final Template template = (Template)element;
		_templates.addElement(template);
		getMode(template.getModeName()).addTemplate(template);
	    }
	    
	    else if (element instanceof AttributeSet) {
		((AttributeSet)element).translate(classGen, null);
	    }
	    else if (element instanceof Output) {
		
		Output output = (Output)element;
		if (output.enabled()) lastOutputElement = output;
	    }
	    else {
		
		
		
	    }
	}

	processModes();
	compileModes(classGen);
	compileConstructor(classGen, lastOutputElement);

	if (!getParser().errorsFound()) {
	    getXSLTC().dumpClass(classGen.getJavaClass());
	}
    }

    
    private void compileConstructor(ClassGenerator classGen, Output output) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();

	final MethodGenerator constructor =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID, 
				null, null, ""<init>"", 
				_className, il, cpg);

	
	il.append(classGen.loadTranslet());
	il.append(new INVOKESPECIAL(cpg.addMethodref(TRANSLET_CLASS,
						     ""<init>"", ""()V"")));

	
	final Vector names = getXSLTC().getNamesIndex();
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, names.size()));
	il.append(new ANEWARRAY(cpg.addClass(STRING)));		

	for (int i = 0; i < names.size(); i++) {
	    final String name = (String)names.elementAt(i);
	    il.append(DUP);
	    il.append(new PUSH(cpg, i));
	    il.append(new PUSH(cpg, name));
	    il.append(AASTORE);
	}
	il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       NAMES_INDEX,
					       NAMES_INDEX_SIG)));

	
	final Vector namespaces = getXSLTC().getNamespaceIndex();
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, namespaces.size()));
	il.append(new ANEWARRAY(cpg.addClass(STRING)));		

	for (int i = 0; i < namespaces.size(); i++) {
	    final String ns = (String)namespaces.elementAt(i);
	    il.append(DUP);
	    il.append(new PUSH(cpg, i));
	    il.append(new PUSH(cpg, ns));
	    il.append(AASTORE);
	}
	il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       NAMESPACE_INDEX,
					       NAMESPACE_INDEX_SIG)));

	if (_hasIdCall) {
	    il.append(classGen.loadTranslet());
	    il.append(new PUSH(cpg, Boolean.TRUE));
	    il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,
					           HASIDCALL_INDEX,
					           HASIDCALL_INDEX_SIG)));
	}
	
	
	if (output != null) {
	    
	    output.translate(classGen, constructor);
	}

	
	
	if (_numberFormattingUsed)
	    DecimalFormatting.translateDefaultDFS(classGen, constructor);

	il.append(RETURN);

	constructor.stripAttributes(true);
	constructor.setMaxLocals();
	constructor.setMaxStack();
	classGen.addMethod(constructor.getMethod());
    }

    
    private String compileTopLevel(ClassGenerator classGen,
				   Enumeration elements) {

	final ConstantPoolGen cpg = classGen.getConstantPool();

	final org.apache.bcel.generic.Type[] argTypes = {
	    Util.getJCRefType(DOM_INTF_SIG),
	    Util.getJCRefType(NODE_ITERATOR_SIG),
	    Util.getJCRefType(TRANSLET_OUTPUT_SIG)
	};

	final String[] argNames = {
	    DOCUMENT_PNAME, ITERATOR_PNAME, TRANSLET_OUTPUT_PNAME
	};

	final InstructionList il = new InstructionList();

	final MethodGenerator toplevel =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames,
				""topLevel"", _className, il,
				classGen.getConstantPool());

	toplevel.addException(""org.apache.xalan.xsltc.TransletException"");

	
	final LocalVariableGen current = 
	    toplevel.addLocalVariable(""current"",
				    org.apache.bcel.generic.Type.INT,
				    il.getEnd(), null);

	final int setFilter = cpg.addInterfaceMethodref(DOM_INTF,
			       ""setFilter"",
			       ""(Lorg/apache/xalan/xsltc/StripFilter;)V"");

	il.append(new PUSH(cpg, DTM.ROOT_NODE));
	il.append(new ISTORE(current.getIndex()));

	
	_globals = resolveReferences(_globals);
	final int count = _globals.size();
	for (int i = 0; i < count; i++) {
	    final VariableBase var = (VariableBase)_globals.elementAt(i);
	    var.translate(classGen,toplevel);
	}

	
	Vector whitespaceRules = new Vector();
	while (elements.hasMoreElements()) {
	    final Object element = elements.nextElement();
	    
	    if (element instanceof DecimalFormatting) {
		((DecimalFormatting)element).translate(classGen,toplevel);
	    }
	    
	    else if (element instanceof Whitespace) {
		whitespaceRules.addAll(((Whitespace)element).getRules());
	    }
	}

	
	if (whitespaceRules.size() > 0) {
	    Whitespace.translateRules(whitespaceRules,classGen);
	}

	if (classGen.containsMethod(STRIP_SPACE, STRIP_SPACE_PARAMS) != null) {
	    il.append(toplevel.loadDOM());
	    il.append(classGen.loadTranslet());
	    il.append(new INVOKEINTERFACE(setFilter, 2));
	}

	il.append(RETURN);

	
	toplevel.stripAttributes(true);
	toplevel.setMaxLocals();
	toplevel.setMaxStack();
	toplevel.removeNOPs();

	classGen.addMethod(toplevel.getMethod());
	
	return(""(""+DOM_INTF_SIG+NODE_ITERATOR_SIG+TRANSLET_OUTPUT_SIG+"")V"");
    }

    
    private Vector resolveReferences(Vector input) {

	
	for (int i = 0; i < input.size(); i++) {
	    final VariableBase var = (VariableBase) input.elementAt(i);
	    final Vector dep  = var.getDependencies();
	    final int depSize = (dep != null) ? dep.size() : 0;

	    for (int j = 0; j < depSize; j++) {
		final VariableBase depVar = (VariableBase) dep.elementAt(j);
		if (!input.contains(depVar)) {
		    input.addElement(depVar);
		}
	    }
	}

	

	Vector result = new Vector();
	while (input.size() > 0) {
	    boolean changed = false;
	    for (int i = 0; i < input.size(); ) {
		final VariableBase var = (VariableBase)input.elementAt(i);
		final Vector dep = var.getDependencies();
		if (dep == null || result.containsAll(dep)) {
		    result.addElement(var);
		    input.remove(i);
		    changed = true;
		}
		else {
		    i++;
		}
	    }

	    
	    if (!changed) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.CIRCULAR_VARIABLE_ERR,
					    input.toString(), this);
		getParser().reportError(Constants.ERROR, err);
		return(result);
	    }
	}

	

	return result;
    }

    
    private String compileBuildKeys(ClassGenerator classGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();

	final org.apache.bcel.generic.Type[] argTypes = {
	    Util.getJCRefType(DOM_INTF_SIG),
	    Util.getJCRefType(NODE_ITERATOR_SIG),
	    Util.getJCRefType(TRANSLET_OUTPUT_SIG),
	    org.apache.bcel.generic.Type.INT
	};

	final String[] argNames = {
	    DOCUMENT_PNAME, ITERATOR_PNAME, TRANSLET_OUTPUT_PNAME, ""current""
	};

	final InstructionList il = new InstructionList();

	final MethodGenerator buildKeys =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames,
				""buildKeys"", _className, il,
				classGen.getConstantPool());

	buildKeys.addException(""org.apache.xalan.xsltc.TransletException"");
	
	final Enumeration elements = elements();
	
	while (elements.hasMoreElements()) {
	    
	    final Object element = elements.nextElement();
	    if (element instanceof Key) {
		final Key key = (Key)element;
		key.translate(classGen, buildKeys);
		_keys.put(key.getName(),key);
	    }
	}
	
	il.append(RETURN);
	
	
	buildKeys.stripAttributes(true);
	buildKeys.setMaxLocals();
	buildKeys.setMaxStack();
	buildKeys.removeNOPs();

	classGen.addMethod(buildKeys.getMethod());
	
	return(""(""+DOM_INTF_SIG+NODE_ITERATOR_SIG+TRANSLET_OUTPUT_SIG+""I)V"");
    }

    
    private void compileTransform(ClassGenerator classGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();

	
	final org.apache.bcel.generic.Type[] argTypes = 
	    new org.apache.bcel.generic.Type[3];
	argTypes[0] = Util.getJCRefType(DOM_INTF_SIG);
	argTypes[1] = Util.getJCRefType(NODE_ITERATOR_SIG);
	argTypes[2] = Util.getJCRefType(TRANSLET_OUTPUT_SIG);

	final String[] argNames = new String[3];
	argNames[0] = DOCUMENT_PNAME;
	argNames[1] = ITERATOR_PNAME;
	argNames[2] = TRANSLET_OUTPUT_PNAME;

	final InstructionList il = new InstructionList();
	final MethodGenerator transf =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames,
				""transform"",
				_className,
				il,
				classGen.getConstantPool());
	transf.addException(""org.apache.xalan.xsltc.TransletException"");

	
	final LocalVariableGen current = 
	    transf.addLocalVariable(""current"",
				    org.apache.bcel.generic.Type.INT,
				    il.getEnd(), null);
	final String applyTemplatesSig = classGen.getApplyTemplatesSig();
	final int applyTemplates = cpg.addMethodref(getClassName(),
						    ""applyTemplates"",
						    applyTemplatesSig);
	final int domField = cpg.addFieldref(getClassName(),
					     DOM_FIELD,
					     DOM_INTF_SIG);

	
	il.append(classGen.loadTranslet());
	
	
	if (isMultiDocument()) {
	    il.append(new NEW(cpg.addClass(MULTI_DOM_CLASS)));
	    il.append(DUP);
	}
	
	il.append(classGen.loadTranslet());
	il.append(transf.loadDOM());
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
						     ""makeDOMAdapter"",
						     ""(""+DOM_INTF_SIG+"")""+
						     DOM_ADAPTER_SIG)));
	

	if (isMultiDocument()) {
	    final int init = cpg.addMethodref(MULTI_DOM_CLASS,
					      ""<init>"",
					      ""(""+DOM_INTF_SIG+"")V"");
	    il.append(new INVOKESPECIAL(init));
	    
	}
	
	
	il.append(new PUTFIELD(domField));

	
	il.append(new PUSH(cpg, DTM.ROOT_NODE));
	il.append(new ISTORE(current.getIndex()));

	
	il.append(classGen.loadTranslet());
	il.append(transf.loadHandler());
	final int index = cpg.addMethodref(TRANSLET_CLASS,
					   ""transferOutputSettings"",
					   ""(""+OUTPUT_HANDLER_SIG+"")V"");
	il.append(new INVOKEVIRTUAL(index));

    
	final Enumeration toplevel = elements();
	if ((_globals.size() > 0) || (toplevel.hasMoreElements())) {
	    
	    final String topLevelSig = compileTopLevel(classGen, toplevel);
	    
	    final int topLevelIdx = cpg.addMethodref(getClassName(),
						     ""topLevel"",
						     topLevelSig);
	    
	    il.append(classGen.loadTranslet()); 
	    il.append(classGen.loadTranslet());
	    il.append(new GETFIELD(domField));  
	    il.append(transf.loadIterator());
	    il.append(transf.loadHandler());    
	    il.append(new INVOKEVIRTUAL(topLevelIdx));
	}
	
	
	
	final String keySig = compileBuildKeys(classGen);
	final int    keyIdx = cpg.addMethodref(getClassName(),
					       ""buildKeys"", keySig);
	il.append(classGen.loadTranslet());     
	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(domField));      
	il.append(transf.loadIterator());       
	il.append(transf.loadHandler());        
	il.append(new PUSH(cpg, DTM.ROOT_NODE)); 
	il.append(new INVOKEVIRTUAL(keyIdx));



	
	il.append(transf.loadHandler());
	il.append(transf.startDocument());

	
	il.append(classGen.loadTranslet());
	
	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(domField));
	
	il.append(transf.loadIterator());
	il.append(transf.loadHandler());
	il.append(new INVOKEVIRTUAL(applyTemplates));
	
	il.append(transf.loadHandler());
	il.append(transf.endDocument());

	il.append(RETURN);

	
	transf.stripAttributes(true);
	transf.setMaxLocals();
	transf.setMaxStack();
	transf.removeNOPs();

	classGen.addMethod(transf.getMethod());
    }

    
    private void peepHoleOptimization(MethodGenerator methodGen) {
	final String pattern = ""`ALOAD'`POP'`Instruction'"";
	final InstructionList il = methodGen.getInstructionList();
	final InstructionFinder find = new InstructionFinder(il);
	for(Iterator iter=find.search(pattern); iter.hasNext(); ) {
	    InstructionHandle[] match = (InstructionHandle[])iter.next();
	    try {
		il.delete(match[0], match[1]);
	    } 
	    catch (TargetLostException e) {
            	
            }
	}
    }

    public int addParam(Param param) {
	_globals.addElement(param);
	return _globals.size() - 1;
    }

    public int addVariable(Variable global) {
	_globals.addElement(global);
	return _globals.size() - 1;
    }

    public void display(int indent) {
	indent(indent);
	Util.println(""Stylesheet"");
	displayContents(indent + IndentIncrement);
    }

    
    public String getNamespace(String prefix) {
	return lookupNamespace(prefix);
    }

    public String getClassName() {
	return _className;
    }

    public Vector getTemplates() {
	return _templates;
    }
}
"
org.apache.xpath.operations.Mod,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class Mod extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() % right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (m_left.num(xctxt) % m_right.num(xctxt));
  }

}
"
org.apache.xml.serializer.AttributesImplSerializer,5,2,0,6,19,0,6,0,5,0.0,91,1.0,0,0.857142857,0.533333333,1,3,17.0,2,1.2,0,"

package org.apache.xml.serializer;

import java.util.Hashtable;

import org.xml.sax.Attributes;
import org.xml.sax.helpers.AttributesImpl;


public class AttributesImplSerializer extends AttributesImpl
{
    
    private Hashtable m_indexFromQName = new Hashtable();
    
    
    public int getIndex(String qname)
    {
        int index;
        Integer i = (Integer) m_indexFromQName.get(qname);
        if (i==null)
            index = -1;
        else
            index = i.intValue();
        return index;
    }
    
    public void addAttribute(
    String uri, String local, String qname, String type, String val)
    {
        int index = super.getLength();
        super.addAttribute(uri,local,qname,type,val);
        
        
        Integer i = new Integer(index);
        m_indexFromQName.put(qname, i);
    }
    

    
    public void clear()
    {
        m_indexFromQName.clear();
        super.clear();
    }    
    
    
    public void setAttributes(Attributes atts)
    {
        super.setAttributes(atts);
        
        
        
        
        int numAtts = atts.getLength();
        for (int i=0; i < numAtts; i++)
        {
            String qName = atts.getQName(i);
            int index = super.getIndex(qName);
            Integer io = new Integer(index);
            m_indexFromQName.put(qName, io);            
            
        }
    }
}
"
org.apache.xpath.objects.XNodeSetForDOM,7,5,0,5,18,0,1,4,7,0.0,115,0.0,0,0.978417266,0.285714286,3,14,15.28571429,1,0.4286,0,"
package org.apache.xpath.objects;

import org.apache.xml.dtm.DTMManager;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPathContext;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;


public class XNodeSetForDOM extends XNodeSet
{
  Object m_origObj;

  public XNodeSetForDOM(Node node, DTMManager dtmMgr)
  {
    m_dtmMgr = dtmMgr;
    m_origObj = node;
    int dtmHandle = dtmMgr.getDTMHandleFromNode(node);
    m_obj = new NodeSetDTM(dtmMgr);
    ((NodeSetDTM) m_obj).addNode(dtmHandle);
  }
  
  
  public XNodeSetForDOM(XNodeSet val)
  {
  	super(val);
  	if(val instanceof XNodeSetForDOM)
    	m_origObj = ((XNodeSetForDOM)val).m_origObj;
  }
  
  public XNodeSetForDOM(NodeList nodeList, XPathContext xctxt)
  {
    m_dtmMgr = xctxt.getDTMManager();
    m_origObj = nodeList;

    
    
    
    
    org.apache.xpath.NodeSetDTM nsdtm=new org.apache.xpath.NodeSetDTM(nodeList, xctxt);
    m_last=nsdtm.getLength();
    m_obj = nsdtm;   
  }

  public XNodeSetForDOM(NodeIterator nodeIter, XPathContext xctxt)
  {
    m_dtmMgr = xctxt.getDTMManager();
    m_origObj = nodeIter;

    
    
    
    
    org.apache.xpath.NodeSetDTM nsdtm=new org.apache.xpath.NodeSetDTM(nodeIter, xctxt);
    m_last=nsdtm.getLength();
    m_obj = nsdtm;   
  }
  
  
  public Object object()
  {
    return m_origObj;
  }
  
  
  public NodeIterator nodeset() throws javax.xml.transform.TransformerException
  {
    return (m_origObj instanceof NodeIterator) 
                   ? (NodeIterator)m_origObj : super.nodeset();      
  }
  
  
  public NodeList nodelist() throws javax.xml.transform.TransformerException
  {
    return (m_origObj instanceof NodeList) 
                   ? (NodeList)m_origObj : super.nodelist();      
  }



}"
org.apache.xalan.xsltc.compiler.util.VoidType,9,2,0,13,20,36,1,13,8,2.0,85,0.0,0,0.804878049,0.351851852,2,3,8.444444444,2,1.2222,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.Constants;

public final class VoidType extends Type {
    protected VoidType() {}

    public String toString() {
	return ""void"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""V"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return null;	
    }

    public Instruction POP() {
        return NOP;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    StringType type) {
	final InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(classGen.getConstantPool(), """"));
    }

    
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen,
			      Class clazz) {
	if (!clazz.getName().equals(""void"")) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }
}
"
org.apache.xpath.functions.FuncNumber,2,5,0,4,5,1,0,4,2,2.0,12,0.0,0,0.982142857,0.75,2,7,5.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class FuncNumber extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(getArg0AsNumber(xctxt));
  }
}
"
org.apache.xpath.patterns.UnionPattern,9,2,0,12,20,0,4,10,8,0.125,212,1.0,1,0.789473684,0.197530864,1,7,22.44444444,7,2.4444,1,"
package org.apache.xpath.patterns;

import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XObject;


public class UnionPattern extends Expression
{

  
  private StepPattern[] m_patterns;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    for (int i = 0; i < m_patterns.length; i++) 
    {
      m_patterns[i].fixupVariables(vars, globalsSize);
    }
  }

  
  
   public boolean canTraverseOutsideSubtree()
   {
     if(null != m_patterns)
     {
      int n = m_patterns.length;
      for (int i = 0; i < n; i++) 
      {
        if(m_patterns[i].canTraverseOutsideSubtree())
          return true;
      }
     }
     return false;
   }

  
  public void setPatterns(StepPattern[] patterns)
  {
    m_patterns = patterns;
    if(null != patterns)
    {
    	for(int i = 0; i < patterns.length; i++)
    	{
    		patterns[i].exprSetParent(this);
    	}
    }
    
  }

  
  public StepPattern[] getPatterns()
  {
    return m_patterns;
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XObject bestScore = null;
    int n = m_patterns.length;

    for (int i = 0; i < n; i++)
    {
      XObject score = m_patterns[i].execute(xctxt);

      if (score != NodeTest.SCORE_NONE)
      {
        if (null == bestScore)
          bestScore = score;
        else if (score.num() > bestScore.num())
          bestScore = score;
      }
    }

    if (null == bestScore)
    {
      bestScore = NodeTest.SCORE_NONE;
    }

    return bestScore;
  }
  
  class UnionPathPartOwner implements ExpressionOwner
  {
  	int m_index;
  	
  	UnionPathPartOwner(int index)
  	{
  		m_index = index;
  	}
  	
    
    public Expression getExpression()
    {
      return m_patterns[m_index];
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(UnionPattern.this);
    	m_patterns[m_index] = (StepPattern)exp;
    }
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	visitor.visitUnionPattern(owner, this);
  	if(null != m_patterns)
  	{
  		int n = m_patterns.length;
  		for(int i = 0; i < n; i++)
  		{
  			m_patterns[i].callVisitors(new UnionPathPartOwner(i), visitor);
  		}
  	}
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	UnionPattern up = (UnionPattern)expr;
  		
  	if(null != m_patterns)
  	{
  		int n = m_patterns.length;
  		if((null == up.m_patterns) || (up.m_patterns.length != n))
  			return false;
  			
  		for(int i = 0; i < n; i++)
  		{
  			if(!m_patterns[i].deepEquals(up.m_patterns[i]))
  				return false;
  		}
  	}
  	else if(up.m_patterns != null)
  		return false;
  		
  	return true;
  	
  }


}
"
org.apache.xalan.xsltc.compiler.FilterExpr,7,3,0,21,38,0,1,21,6,0.083333333,282,1.0,1,0.922077922,0.306122449,2,9,39.0,3,1.7143,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

class FilterExpr extends Expression {
    private Expression   _primary;
    private final Vector _predicates;

    public FilterExpr(Expression primary, Vector predicates) {
	_primary = primary;
	_predicates = predicates;
	primary.setParent(this);
    }

    protected Expression getExpr() {
	if (_primary instanceof CastExpr)
	    return ((CastExpr)_primary).getExpr();
	else
	    return _primary;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_primary.setParser(parser);
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Expression exp = (Expression)_predicates.elementAt(i);
		exp.setParser(parser);
		exp.setParent(this);
	    }
	}
    }
    
    public String toString() {
	return ""filter-expr("" + _primary + "", "" + _predicates + "")"";
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	Type ptype = _primary.typeCheck(stable);

	if (ptype instanceof NodeSetType == false) {
	    if (ptype instanceof ReferenceType)  {
		_primary = new CastExpr(_primary, Type.NodeSet);
	    }
	    else {
		throw new TypeCheckError(this);
	    }
	}

	int n = _predicates.size();
	for (int i = 0; i < n; i++) {
	    Expression pred = (Expression)_predicates.elementAt(i);
	    pred.typeCheck(stable);
	}
	return _type = Type.NodeSet;	
    }
	
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (_predicates.size() > 0) {
	    translatePredicates(classGen, methodGen);
	}
	else {
	    _primary.translate(classGen, methodGen);
	    _primary.startResetIterator(classGen, methodGen);
	}
    }

    
    public void translatePredicates(ClassGenerator classGen,
				    MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_predicates.size() == 0) {
	    translate(classGen, methodGen);
	}
	else {
	    final int initCNLI = cpg.addMethodref(CURRENT_NODE_LIST_ITERATOR,
						  ""<init>"",
						  ""(""+NODE_ITERATOR_SIG+""Z""+
						  CURRENT_NODE_LIST_FILTER_SIG +
						  NODE_SIG+TRANSLET_SIG+"")V"");

	    Predicate predicate = (Predicate)_predicates.lastElement();
	    _predicates.remove(predicate);

	    if (predicate.isNthPositionFilter()) {
		final int start = cpg.addInterfaceMethodref(NODE_ITERATOR,
							    ""setStartNode"", 
							    ""(I)""+
							    NODE_ITERATOR_SIG);
		final int reset = cpg.addInterfaceMethodref(NODE_ITERATOR,
							    ""reset"",
							    ""()""+
							    NODE_ITERATOR_SIG);
		translatePredicates(classGen, methodGen); 
		predicate.translate(classGen, methodGen); 
		il.append(new INVOKEINTERFACE(start,2));
		il.append(new INVOKEINTERFACE(reset,1));

		final int sngl = cpg.addMethodref(BASIS_LIBRARY_CLASS,
						  ""getSingleNode"",
						  ""(""+NODE_ITERATOR_SIG+"")""+
						  NODE_ITERATOR_SIG);
		il.append(new INVOKESTATIC(sngl));
	    }
	    else {
		
		il.append(new NEW(cpg.addClass(CURRENT_NODE_LIST_ITERATOR)));
		il.append(DUP);
		translatePredicates(classGen, methodGen); 
		il.append(ICONST_1);
		predicate.translate(classGen, methodGen);
		il.append(methodGen.loadCurrentNode());
		il.append(classGen.loadTranslet());
		il.append(new INVOKESPECIAL(initCNLI));
	    }
	}
    }
}
"
org.apache.xpath.operations.Operation,12,2,14,22,23,0,17,7,12,0.363636364,149,1.0,2,0.731707317,0.21875,1,7,11.25,5,1.5833,0,"
package org.apache.xpath.operations;

import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XObject;


public class Operation extends Expression implements ExpressionOwner
{

  
  protected Expression m_left;

  
  protected Expression m_right;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_left.fixupVariables(vars, globalsSize);
    m_right.fixupVariables(vars, globalsSize);
  }


  
  public boolean canTraverseOutsideSubtree()
  {

    if (null != m_left && m_left.canTraverseOutsideSubtree())
      return true;

    if (null != m_right && m_right.canTraverseOutsideSubtree())
      return true;

    return false;
  }

  
  public void setLeftRight(Expression l, Expression r)
  {
    m_left = l;
    m_right = r;
    l.exprSetParent(this);
    r.exprSetParent(this);
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    XObject left = m_left.execute(xctxt, true);
    XObject right = m_right.execute(xctxt, true);

    XObject result = operate(left, right);
    left.detach();
    right.detach();
    return result;
  }

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return null;  
  }

  
  public Expression getLeftOperand(){
    return m_left;
  }

  
  public Expression getRightOperand(){
    return m_right;
  }
  
  class LeftExprOwner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_left;
    }

    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(Operation.this);
    	m_left = exp;
    }
  }

  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	if(visitor.visitBinaryOperation(owner, this))
  	{
  		m_left.callVisitors(new LeftExprOwner(), visitor);
  		m_right.callVisitors(this, visitor);
  	}
  }

  
  public Expression getExpression()
  {
    return m_right;
  }

  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_right = exp;
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	if(!m_left.deepEquals(((Operation)expr).m_left))
  		return false;
  		
  	if(!m_right.deepEquals(((Operation)expr).m_right))
  		return false;
  		
  	return true;
  }
}
"
org.apache.xalan.xsltc.runtime.BasisLibrary,59,1,0,31,173,1695,17,17,54,1.001915709,2363,0.333333333,0,0.0,0.114224138,0,0,38.59322034,49,4.4915,6,"

package org.apache.xalan.xsltc.runtime;

import java.text.DecimalFormat;
import java.text.FieldPosition;
import java.text.MessageFormat;
import java.text.NumberFormat;
import java.util.Locale;
import java.util.ResourceBundle;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.dom.DOMSource;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.dom.AbsoluteIterator;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xalan.xsltc.dom.DOMAdapter;
import org.apache.xalan.xsltc.dom.SAXImpl;
import org.apache.xalan.xsltc.dom.MultiDOM;
import org.apache.xalan.xsltc.dom.SingletonIterator;
import org.apache.xalan.xsltc.dom.StepIterator;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.ref.DTMDefaultBase;

import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;
import org.apache.xml.serializer.SerializationHandler;


public final class BasisLibrary implements Operators {

    private final static String EMPTYSTRING = """";

    
    public static int countF(DTMAxisIterator iterator) {
	return(iterator.getLast());
    }

    
    public static int positionF(DTMAxisIterator iterator) {
	return iterator.isReverse()
                     ? iterator.getLast() - iterator.getPosition() + 1
                     : iterator.getPosition();
    }

    
    public static double sumF(DTMAxisIterator iterator, DOM dom) {
	try {
	    double result = 0.0;
	    int node;
	    while ((node = iterator.next()) != DTMAxisIterator.END) {
		result += Double.parseDouble(dom.getStringValueX(node));
	    }
	    return result;
	}
	catch (NumberFormatException e) {
	    return Double.NaN;
	}
    }

    
    public static String stringF(int node, DOM dom) {
	return dom.getStringValueX(node);
    }

    
    public static String stringF(Object obj, DOM dom) {
	if (obj instanceof DTMAxisIterator) {
	    return dom.getStringValueX(((DTMAxisIterator)obj).reset().next());
	}
	else if (obj instanceof Node) {
	    return dom.getStringValueX(((Node)obj).node);
	}
	else if (obj instanceof DOM) {
	    return ((DOM)obj).getStringValue();
	}
	else {
	    return obj.toString();
	}
    }

    
    public static String stringF(Object obj, int node, DOM dom) {
	if (obj instanceof DTMAxisIterator) {
	    return dom.getStringValueX(((DTMAxisIterator)obj).reset().next());
	}
	else if (obj instanceof Node) {
	    return dom.getStringValueX(((Node)obj).node);
	}
	else if (obj instanceof DOM) {
	    
	    
	    
	    return ((DOM)obj).getStringValue();
	}
	else if (obj instanceof Double) {
	    Double d = (Double)obj;
	    final String result = d.toString();
	    final int length = result.length();
	    if ((result.charAt(length-2)=='.') &&
		(result.charAt(length-1) == '0'))
		return result.substring(0, length-2);
	    else
		return result;
	}
	else {
	    if (obj != null)
		return obj.toString();
	    else
		return stringF(node, dom);
	}
    }

    
    public static double numberF(int node, DOM dom) {
	return stringToReal(dom.getStringValueX(node));
    }

    
    public static double numberF(Object obj, DOM dom) {
	if (obj instanceof Double) {
	    return ((Double) obj).doubleValue();
	}
	else if (obj instanceof Integer) {
	    return ((Integer) obj).doubleValue();
	}
	else if (obj instanceof Boolean) {
	    return  ((Boolean) obj).booleanValue() ? 1.0 : 0.0;
	}
	else if (obj instanceof String) {
	    return stringToReal((String) obj);
	}
	else if (obj instanceof DTMAxisIterator) {
	    DTMAxisIterator iter = (DTMAxisIterator) obj;
	    return stringToReal(dom.getStringValueX(iter.reset().next()));
	}
	else if (obj instanceof Node) {
	    return stringToReal(dom.getStringValueX(((Node) obj).node));
	}
	else if (obj instanceof DOM) {
	    return stringToReal(((DOM) obj).getStringValue());
	}
	else {
	    final String className = obj.getClass().getName();
	    runTimeError(INVALID_ARGUMENT_ERR, className, ""number()"");
	    return 0.0;
	}
    }

    
    public static boolean booleanF(Object obj) {
	if (obj instanceof Double) {
	    final double temp = ((Double) obj).doubleValue();
	    return temp != 0.0 && !Double.isNaN(temp);
	}
	else if (obj instanceof Integer) {
	    return ((Integer) obj).doubleValue() != 0;
	}
	else if (obj instanceof Boolean) {
	    return  ((Boolean) obj).booleanValue();
	}
	else if (obj instanceof String) {
	    return !((String) obj).equals(EMPTYSTRING);
	}
	else if (obj instanceof DTMAxisIterator) {
	    DTMAxisIterator iter = (DTMAxisIterator) obj;
	    return iter.reset().next() != DTMAxisIterator.END;
	}
	else if (obj instanceof Node) {
	    return true;
	}
	else if (obj instanceof DOM) {
	    String temp = ((DOM) obj).getStringValue();
	    return !temp.equals(EMPTYSTRING);
	}
	else {
	    final String className = obj.getClass().getName();
	    runTimeError(INVALID_ARGUMENT_ERR, className, ""number()"");
	}
	return false;
    }

    
    public static String substringF(String value, double start) {
	try {
	    final int strlen = value.length();
	    int istart = (int)Math.round(start) - 1;

	    if (Double.isNaN(start)) return(EMPTYSTRING);
	    if (istart > strlen) return(EMPTYSTRING);
 	    if (istart < 1) istart = 0;

	    return value.substring(istart);
	}
	catch (IndexOutOfBoundsException e) {
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""substring()"");
	    return null;
	}
    }

    
    public static String substringF(String value, double start, double length) {
	try {
	    final int strlen  = value.length();
	    int istart = (int)Math.round(start) - 1;
	    int isum   = istart + (int)Math.round(length);

	    if (Double.isInfinite(length)) isum = Integer.MAX_VALUE;

	    if (Double.isNaN(start) || Double.isNaN(length))
		return(EMPTYSTRING);
	    if (Double.isInfinite(start)) return(EMPTYSTRING);
	    if (istart > strlen) return(EMPTYSTRING);
	    if (isum < 0) return(EMPTYSTRING);
 	    if (istart < 0) istart = 0;

	    if (isum > strlen)
		return value.substring(istart);
	    else
		return value.substring(istart, isum);
	}
	catch (IndexOutOfBoundsException e) {
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""substring()"");
	    return null;
	}
    }

    
    public static String substring_afterF(String value, String substring) {
	final int index = value.indexOf(substring);
	if (index >= 0)
	    return value.substring(index + substring.length());
	else
	    return EMPTYSTRING;
    }

    
    public static String substring_beforeF(String value, String substring) {
	final int index = value.indexOf(substring);
	if (index >= 0)
	    return value.substring(0, index);
	else
	    return EMPTYSTRING;
    }

    
    public static String translateF(String value, String from, String to) {
	final int tol = to.length();
	final int froml = from.length();
	final int valuel = value.length();

	final StringBuffer result = new StringBuffer();
	for (int j, i = 0; i < valuel; i++) {
	    final char ch = value.charAt(i);
	    for (j = 0; j < froml; j++) {
		if (ch == from.charAt(j)) {
		    if (j < tol)
			result.append(to.charAt(j));
		    break;
		}
	    }	
	    if (j == froml)
		result.append(ch);
	}
	return result.toString();
    }

    
    public static String normalize_spaceF(int node, DOM dom) {
	return normalize_spaceF(dom.getStringValueX(node));
    }

    
    public static String normalize_spaceF(String value) {
	int i = 0, n = value.length();
	StringBuffer result = new StringBuffer();

	while (i < n && isWhiteSpace(value.charAt(i)))
	    i++;

	while (true) {
	    while (i < n && !isWhiteSpace(value.charAt(i))) {
		result.append(value.charAt(i++));
	    }
	    if (i == n)
		break;
	    while (i < n && isWhiteSpace(value.charAt(i))) {
		i++;
	    }
	    if (i < n)
		result.append(' ');
	}
	return result.toString();
    }

    
    public static String generate_idF(int node) {
	if (node > 0)
	    
	    return ""N"" + node;
	else
	    
	    return EMPTYSTRING;
    }
    
    
    public static String getLocalName(String value) {
	int idx = value.lastIndexOf(':');
	if (idx >= 0) value = value.substring(idx + 1);
	idx = value.lastIndexOf('@');
	if (idx >= 0) value = value.substring(idx + 1);
	return(value);
    }

    
    public static void unresolved_externalF(String name) {
	runTimeError(EXTERNAL_FUNC_ERR, name);
    }

    
    public static String namespace_uriF(DTMAxisIterator iter, DOM dom) {
	return namespace_uriF(iter.next(), dom);
    }

    
    public static String system_propertyF(String name) {
	if (name.equals(""xsl:version""))
	    return(""1.0"");
	if (name.equals(""xsl:vendor""))
	    return(""Apache Software Foundation (Xalan XSLTC)"");
	if (name.equals(""xsl:vendor-url""))
	    return(""http:
	
	runTimeError(INVALID_ARGUMENT_ERR, name, ""system-property()"");
	return(EMPTYSTRING);
    }

    
    public static String namespace_uriF(int node, DOM dom) {
	final String value = dom.getNodeName(node);
	final int colon = value.lastIndexOf(':');
	if (colon >= 0)
	    return value.substring(0, colon);
	else
	    return EMPTYSTRING;
    }

    
    public static String objectTypeF(Object obj)
    {
      if (obj instanceof String)
        return ""string"";
      else if (obj instanceof Boolean)
        return ""boolean"";
      else if (obj instanceof Number)
        return ""number"";
      else if (obj instanceof DOM)
        return ""RTF"";
      else if (obj instanceof DTMAxisIterator)
        return ""node-set"";
      else
        return ""unknown"";
    }  

    
    public static DTMAxisIterator nodesetF(Object obj) {
	if (obj instanceof DOM) {
	   
	   final DOM dom = (DOM)obj;
	   return new SingletonIterator(dom.getDocument(), true);
	}
        else if (obj instanceof DTMAxisIterator) {
	   return (DTMAxisIterator) obj;
        }
        else {
	    final String className = obj.getClass().getName();
	    runTimeError(DATA_CONVERSION_ERR, ""node-set"", className);
	    return null;
        }
    }

    

    private static boolean isWhiteSpace(char ch) {
	return ch == ' ' || ch == '	' || ch == '
' || ch == '
';
    }

    private static boolean compareStrings(String lstring, String rstring,
					  int op, DOM dom) {
	switch (op) {
	case EQ:
	    return lstring.equals(rstring);

	case NE:
	    return !lstring.equals(rstring);

	case GT:
	    return numberF(lstring, dom) > numberF(rstring, dom);

	case LT:
	    return numberF(lstring, dom) < numberF(rstring, dom);

	case GE:
	    return numberF(lstring, dom) >= numberF(rstring, dom);

	case LE:
	    return numberF(lstring, dom) <= numberF(rstring, dom);

	default:
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""compare()"");
	    return false;
	}
    }

    
    public static boolean compare(DTMAxisIterator left, DTMAxisIterator right,
				  int op, DOM dom) {
	int lnode;
	left.reset();
	
	while ((lnode = left.next()) != DTMAxisIterator.END) {
	    final String lvalue = dom.getStringValueX(lnode);
	    
	    int rnode;
	    right.reset();
	    while ((rnode = right.next()) != DTMAxisIterator.END) {
                
                if (lnode == rnode) {
                    if (op == EQ) {
                        return true;
                    } else if (op == NE) {
                        continue;
                    }
                }
		if (compareStrings(lvalue, dom.getStringValueX(rnode), op,
                                   dom)) {
		    return true;
		}
	    }
	} 
	return false;
    }

    public static boolean compare(int node, DTMAxisIterator iterator,
				  int op, DOM dom) {
	

	int rnode;
	String value;

	switch(op) {
	case EQ:
            rnode = iterator.next();
            if (rnode != DTMAxisIterator.END) {
	        value = dom.getStringValueX(node);
                do {
		    if (node == rnode
                          || value.equals(dom.getStringValueX(rnode))) {
                       return true;
                    }
	        } while ((rnode = iterator.next()) != DTMAxisIterator.END);
            }
	    break;
	case NE:
            rnode = iterator.next();
            if (rnode != DTMAxisIterator.END) {
	        value = dom.getStringValueX(node);
                do {
		    if (node != rnode
                          && !value.equals(dom.getStringValueX(rnode))) {
                        return true;
                    }
	        } while ((rnode = iterator.next()) != DTMAxisIterator.END);
            }
	    break;
	case LT:
	    
	    while ((rnode = iterator.next()) != DTMAxisIterator.END) {
		if (rnode > node) return true;
	    }
	    break;
	case GT:
	    
	    while ((rnode = iterator.next()) != DTMAxisIterator.END) {
		if (rnode < node) return true;
	    }
	    break;
	} 
	return(false);
    }

    
    public static boolean compare(DTMAxisIterator left, final double rnumber,
				  final int op, DOM dom) {
	int node;
	

	switch (op) {
	case EQ:
	    while ((node = left.next()) != DTMAxisIterator.END) {
		if (numberF(dom.getStringValueX(node), dom) == rnumber)
		    return true;
	    }
	    break;

	case NE:
	    while ((node = left.next()) != DTMAxisIterator.END) {
		if (numberF(dom.getStringValueX(node), dom) != rnumber)
		    return true;
	    }
	    break;

	case GT:
	    while ((node = left.next()) != DTMAxisIterator.END) {
		if (numberF(dom.getStringValueX(node), dom) > rnumber)
		    return true;
	    }
	    break;

	case LT:
	    while ((node = left.next()) != DTMAxisIterator.END) {
		if (numberF(dom.getStringValueX(node), dom) < rnumber)
		    return true;
	    }
	    break;

	case GE:
	    while ((node = left.next()) != DTMAxisIterator.END) {
		if (numberF(dom.getStringValueX(node), dom) >= rnumber)
		    return true;
	    }
	    break;

	case LE:
	    while ((node = left.next()) != DTMAxisIterator.END) {
		if (numberF(dom.getStringValueX(node), dom) <= rnumber)
		    return true;
	    }
	    break;

	default:
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""compare()"");
	}

	return false;
    }

    
    public static boolean compare(DTMAxisIterator left, final String rstring,
				  int op, DOM dom) {
	int node;
	
	while ((node = left.next()) != DTMAxisIterator.END) {
	    if (compareStrings(dom.getStringValueX(node), rstring, op, dom)) {
		return true;
	    }
	}
	return false;
    }


    public static boolean compare(Object left, Object right,
				  int op, DOM dom) 
    { 
	boolean result = false;
	boolean hasSimpleArgs = hasSimpleType(left) && hasSimpleType(right);

	if (op != EQ && op != NE) {
	    
	    if (left instanceof Node || right instanceof Node) {
		if (left instanceof Boolean) {
		    right = new Boolean(booleanF(right));
		    hasSimpleArgs = true;
		}
		if (right instanceof Boolean) {
		    left = new Boolean(booleanF(left));
		    hasSimpleArgs = true;
		}
	    }

	    if (hasSimpleArgs) {
		switch (op) {
		case GT:
		    return numberF(left, dom) > numberF(right, dom);
		    
		case LT:
		    return numberF(left, dom) < numberF(right, dom);
		    
		case GE:
		    return numberF(left, dom) >= numberF(right, dom);
		    
		case LE:
		    return numberF(left, dom) <= numberF(right, dom);
		    
		default:
		    runTimeError(RUN_TIME_INTERNAL_ERR, ""compare()"");
		}
	    }
	    
	}

	if (hasSimpleArgs) {
	    if (left instanceof Boolean || right instanceof Boolean) {
		result = booleanF(left) == booleanF(right);
	    }
	    else if (left instanceof Double || right instanceof Double ||
		     left instanceof Integer || right instanceof Integer) {
		result = numberF(left, dom) == numberF(right, dom);
	    }
	    else { 
		result = stringF(left, dom).equals(stringF(right, dom));
	    }

	    if (op == Operators.NE) {
		result = !result;
	    }
	}
	else {
	    if (left instanceof Node) {
		left = new SingletonIterator(((Node)left).node);
	    }
	    if (right instanceof Node) {
		right = new SingletonIterator(((Node)right).node);
	    }

	    if (hasSimpleType(left) ||
		left instanceof DOM && right instanceof DTMAxisIterator) {
		
		final Object temp = right; right = left; left = temp;
	    }

	    if (left instanceof DOM) {
		if (right instanceof Boolean) {
		    result = ((Boolean)right).booleanValue();
		    return result == (op == Operators.EQ);
		}

		final String sleft = ((DOM)left).getStringValue();

		if (right instanceof Number) {
		    result = ((Number)right).doubleValue() ==
			stringToReal(sleft);
		}
		else if (right instanceof String) {
		    result = sleft.equals((String)right);
		}
		else if (right instanceof DOM) {
		    result = sleft.equals(((DOM)right).getStringValue());
		}

		if (op == Operators.NE) {
		    result = !result;
		}
		return result;
	    }

	    

	    DTMAxisIterator iter = ((DTMAxisIterator)left).reset();

	    if (right instanceof DTMAxisIterator) {
		result = compare(iter, (DTMAxisIterator)right, op, dom);
	    }
	    else if (right instanceof String) {
		result = compare(iter, (String)right, op, dom);
	    }	
	    else if (right instanceof Number) {
		final double temp = ((Number)right).doubleValue();
		result = compare(iter, temp, op, dom);
	    }
	    else if (right instanceof Boolean) {
		boolean temp = ((Boolean)right).booleanValue();
		result = (iter.reset().next() != DTMAxisIterator.END) == temp;
	    }
	    else if (right instanceof DOM) {
		result = compare(iter, ((DOM)right).getStringValue(),
				 op, dom);
	    }
	    else if (right == null) {
		return(false);
	    }
	    else {
		final String className = right.getClass().getName();
		runTimeError(INVALID_ARGUMENT_ERR, className, ""compare()"");
	    }
	}
	return result;
    }

    
    public static boolean testLanguage(String testLang, DOM dom, int node) {
	
	String nodeLang = dom.getLanguage(node);
	if (nodeLang == null)
	    return(false);
	else
	    nodeLang = nodeLang.toLowerCase();

	
	testLang = testLang.toLowerCase();
	if (testLang.length() == 2) {
	    return(nodeLang.startsWith(testLang));
	}
	else {
	    return(nodeLang.equals(testLang));
	}
    }

    private static boolean hasSimpleType(Object obj) {
	return obj instanceof Boolean || obj instanceof Double ||
	    obj instanceof Integer || obj instanceof String ||
	    obj instanceof Node || obj instanceof DOM; 
    }

    
    public static double stringToReal(String s) {
	try {
	    return Double.valueOf(s).doubleValue();
	}
	catch (NumberFormatException e) {
	    return Double.NaN;
	}
    }

    
    public static int stringToInt(String s) {
	try {
	    return Integer.parseInt(s);
	}
	catch (NumberFormatException e) {
	    return(-1); 
	}
    }

    private static double lowerBounds = 0.001;
    private static double upperBounds = 10000000;
    private static DecimalFormat defaultFormatter;
    private static String defaultPattern = """";

    static {
	NumberFormat f = NumberFormat.getInstance(Locale.getDefault());
	
	
	f.setMaximumFractionDigits(Integer.MAX_VALUE);
	defaultFormatter = (f instanceof DecimalFormat) ?
	    (DecimalFormat) f : new DecimalFormat();
	defaultFormatter.setGroupingUsed(false);
    }

    
    public static String realToString(double d) {
	final double m = Math.abs(d);
	if ((m >= lowerBounds) && (m < upperBounds)) {
	    final String result = Double.toString(d);
	    final int length = result.length();
	    
	    if ((result.charAt(length-2) == '.') &&
		(result.charAt(length-1) == '0'))
		return result.substring(0, length-2);
	    else
		return result;
	}
	else {
	    if (Double.isNaN(d) || Double.isInfinite(d))
		return(Double.toString(d));
	    return formatNumber(d, defaultPattern, defaultFormatter);
	}
    }

    
    public static int realToInt(double d) {
	return (int)d;
    }

    
    private static FieldPosition _fieldPosition = new FieldPosition(0);

    public static String formatNumber(double number, String pattern,
				      DecimalFormat formatter) {
        
	if (formatter == null) {
	    formatter = defaultFormatter;
	}
	try {
	    StringBuffer result = new StringBuffer();
	    if (pattern != defaultPattern) {
		formatter.applyLocalizedPattern(pattern);
	    }

	    
 	    
	    
	    
	    
	    
	    
	    String localizedPattern = formatter.toPattern();
	    int index = localizedPattern.indexOf('.');
	    if ( index >= 1  && localizedPattern.charAt(index-1) == '#' ) {
		
		StringBuffer newpattern = new StringBuffer();
		newpattern.append(localizedPattern.substring(0, index-1));
                newpattern.append(""0"");
                newpattern.append(localizedPattern.substring(index));
		formatter.applyLocalizedPattern(newpattern.toString());
	    } else if (index == 0) {
                
                StringBuffer newpattern = new StringBuffer();
                newpattern.append(""0"");
                newpattern.append(localizedPattern);
		formatter.applyLocalizedPattern(newpattern.toString());
            }

	    formatter.format(number, result, _fieldPosition);
	    return(result.toString());
	}
	catch (IllegalArgumentException e) {
	    runTimeError(FORMAT_NUMBER_ERR, Double.toString(number), pattern);
	    return(EMPTYSTRING);
	}
    }
    
    
    public static DTMAxisIterator referenceToNodeSet(Object obj) {
	
	if (obj instanceof Node) {
	    return(new SingletonIterator(((Node)obj).node));
	}
	
	else if (obj instanceof DTMAxisIterator) {
	    return(((DTMAxisIterator)obj).cloneIterator());
	}
	else {
	    final String className = obj.getClass().getName();
	    runTimeError(DATA_CONVERSION_ERR, ""reference"", className);
	    return null;
	}
    }
    
    
    public static NodeList referenceToNodeList(Object obj, DOM dom) {
        if (obj instanceof Node || obj instanceof DTMAxisIterator) {
            DTMAxisIterator iter = referenceToNodeSet(obj);
            return dom.makeNodeList(iter);
        }
        else if (obj instanceof DOM) {
          dom = (DOM)obj;
          return dom.makeNodeList(DTMDefaultBase.ROOTNODE);
        }
	else {
	    final String className = obj.getClass().getName();
	    runTimeError(DATA_CONVERSION_ERR, ""reference"", className);
	    return null;
	}
    }

    
    public static org.w3c.dom.Node referenceToNode(Object obj, DOM dom) {
        if (obj instanceof Node || obj instanceof DTMAxisIterator) {
            DTMAxisIterator iter = referenceToNodeSet(obj);
            return dom.makeNode(iter);
        }
        else if (obj instanceof DOM) {
          dom = (DOM)obj;
          DTMAxisIterator iter = dom.getChildren(DTMDefaultBase.ROOTNODE);
          return dom.makeNode(iter);
        }
	else {
	    final String className = obj.getClass().getName();
	    runTimeError(DATA_CONVERSION_ERR, ""reference"", className);
	    return null;
	}
    }
    
    
    public static DTMAxisIterator node2Iterator(org.w3c.dom.Node node,
	Translet translet, DOM dom) 
    {
        final org.w3c.dom.Node inNode = node;
        
        
        org.w3c.dom.NodeList nodelist = new org.w3c.dom.NodeList() {            
            public int getLength() {
                return 1;
            }
            
            public org.w3c.dom.Node item(int index) {
                if (index == 0)
                    return inNode;
                else
                    return null;
            }
        };
        
        return nodeList2Iterator(nodelist, translet, dom);
    }
    
    
    private static void copyNodes(org.w3c.dom.NodeList nodeList, 
	org.w3c.dom.Document doc, org.w3c.dom.Node parent)
    {
        final int size = nodeList.getLength();

          
        for (int i = 0; i < size; i++) 
        {
            org.w3c.dom.Node curr = nodeList.item(i);
            int nodeType = curr.getNodeType();
            String value = null;
            try {
                value = curr.getNodeValue();
            } catch (DOMException ex) {
                runTimeError(RUN_TIME_INTERNAL_ERR, ex.getMessage());
                return;
            }
            
            String nodeName = curr.getNodeName();
            org.w3c.dom.Node newNode = null; 
            switch (nodeType){
                case org.w3c.dom.Node.ATTRIBUTE_NODE:
                     newNode = doc.createAttributeNS(curr.getNamespaceURI(), 
			nodeName);
                     break;
                case org.w3c.dom.Node.CDATA_SECTION_NODE: 
                     newNode = doc.createCDATASection(value);
                     break;
                case org.w3c.dom.Node.COMMENT_NODE: 
                     newNode = doc.createComment(value);
                     break;
                case org.w3c.dom.Node.DOCUMENT_FRAGMENT_NODE: 
                     newNode = doc.createDocumentFragment();
                     break;
                case org.w3c.dom.Node.DOCUMENT_NODE:
                     newNode = doc.createElementNS(null, ""__document__"");
                     copyNodes(curr.getChildNodes(), doc, newNode);
                     break;
                case org.w3c.dom.Node.DOCUMENT_TYPE_NODE:
                     
                     break;
                case org.w3c.dom.Node.ELEMENT_NODE: 
                     
		     
                     org.w3c.dom.Element element = doc.createElementNS(
			curr.getNamespaceURI(), nodeName);
                     if (curr.hasAttributes())
                     {
                       org.w3c.dom.NamedNodeMap attributes = curr.getAttributes();
                       for (int k = 0; k < attributes.getLength(); k++) {
                         org.w3c.dom.Node attr = attributes.item(k);
                         element.setAttribute(attr.getNodeName(), 
			    attr.getNodeValue());
                       }
                     }
                     copyNodes(curr.getChildNodes(), doc, element);
                     newNode = element;
                     break;
                case org.w3c.dom.Node.ENTITY_NODE: 
                     
                     break;
                case org.w3c.dom.Node.ENTITY_REFERENCE_NODE: 
                     newNode = doc.createEntityReference(nodeName);
                     break;
                case org.w3c.dom.Node.NOTATION_NODE: 
                     
                     break;
                case org.w3c.dom.Node.PROCESSING_INSTRUCTION_NODE: 
                     newNode = doc.createProcessingInstruction(nodeName,
                        value);
                     break;
                case org.w3c.dom.Node.TEXT_NODE: 
                     newNode = doc.createTextNode(value);
                     break;
            }
            try {
                parent.appendChild(newNode);
            } catch (DOMException e) {
                runTimeError(RUN_TIME_INTERNAL_ERR, e.getMessage());
                return;
            }           
        }
    }

    
    public static DTMAxisIterator nodeList2Iterator(
                                        org.w3c.dom.NodeList nodeList,
                                    	Translet translet, DOM dom) 
    {
	
	DocumentBuilderFactory dfac = DocumentBuilderFactory.newInstance();
	DocumentBuilder docbldr = null;
	try {
	    docbldr = dfac.newDocumentBuilder();
	} catch (javax.xml.parsers.ParserConfigurationException e) {
	    runTimeError(RUN_TIME_INTERNAL_ERR, e.getMessage());
            return null;

	}
	
	Document doc = docbldr.newDocument();	
        org.w3c.dom.Node topElementNode = 
            doc.appendChild(doc.createElementNS("""", ""__top__""));

        
        copyNodes(nodeList, doc, topElementNode);

        
	if (dom instanceof MultiDOM) {
            final MultiDOM multiDOM = (MultiDOM) dom;

	    DTMDefaultBase dtm = (DTMDefaultBase)((DOMAdapter)multiDOM.getMain()).getDOMImpl();
	    DTMManager dtmManager = dtm.getManager();
	    
	    SAXImpl idom = (SAXImpl)dtmManager.getDTM(new DOMSource(doc), false,
						      null, true, false);
	    
	    DOMAdapter domAdapter = new DOMAdapter(idom, 
                translet.getNamesArray(),
		translet.getNamespaceArray());
            multiDOM.addDOMAdapter(domAdapter);

	    DTMAxisIterator iter1 = idom.getAxisIterator(Axis.CHILD);
	    DTMAxisIterator iter2 = idom.getAxisIterator(Axis.CHILD);
            DTMAxisIterator iter = new AbsoluteIterator(
                new StepIterator(iter1, iter2));

 	    iter.setStartNode(DTMDefaultBase.ROOTNODE);
	    return iter;
	}
        else {
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""nodeList2Iterator()"");
	    return null;
        }
    }

    
    public static DOM referenceToResultTree(Object obj) {
	try {
	    return ((DOM) obj);
	}
	catch (IllegalArgumentException e) {
	    final String className = obj.getClass().getName();
	    runTimeError(DATA_CONVERSION_ERR, ""reference"", className);
	    return null;
	}
    }

    
    public static DTMAxisIterator getSingleNode(DTMAxisIterator iterator) {
	int node = iterator.next();
	return(new SingletonIterator(node));
    }

    
    private static char[] _characterArray = new char[32];

    public static void copy(Object obj,
 			    SerializationHandler handler,
			    int node,
			    DOM dom) {
	try {
	    if (obj instanceof DTMAxisIterator) 
      {
		DTMAxisIterator iter = (DTMAxisIterator) obj;
		dom.copy(iter.reset(), handler);
	    }
	    else if (obj instanceof Node) {
		dom.copy(((Node) obj).node, handler);
	    }
	    else if (obj instanceof DOM) {
		
		DOM newDom = (DOM)obj;
		newDom.copy(newDom.getDocument(), handler);
	    }
	    else {
		String string = obj.toString();		
		final int length = string.length();
		if (length > _characterArray.length)
		    _characterArray = new char[length];
		string.getChars(0, length, _characterArray, 0);
		handler.characters(_characterArray, 0, length);
	    }
	}
	catch (SAXException e) {
	    runTimeError(RUN_TIME_COPY_ERR);
	}
    }

    
    public static String startXslElement(String qname, String namespace,
	SerializationHandler handler, DOM dom, int node)
    {
	try {
	    
	    String prefix;
	    final int index = qname.indexOf(':');

	    if (index > 0) {
		prefix = qname.substring(0, index);

		
		if (namespace == null || namespace.length() == 0) {
		    namespace = dom.lookupNamespace(node, prefix);
		}

		handler.startElement(namespace, qname.substring(index+1),
                                     qname);
		handler.namespaceAfterStartElement(prefix, namespace); 
	    }
	    else {
		
		if (namespace != null && namespace.length() > 0) {
		    prefix = generatePrefix();
		    qname = prefix + ':' + qname;   
		    handler.startElement(namespace, qname, qname);   
		    handler.namespaceAfterStartElement(prefix, namespace);
		}
		else {
		    handler.startElement(null, null, qname);   
		}
	    }
	}
	catch (SAXException e) {
	    throw new RuntimeException(e.getMessage());
	}

	return qname;
    }

    
    public static String getPrefix(String qname) {
	final int index = qname.indexOf(':');
	return (index > 0) ? qname.substring(0, index) : null;
    }

    
    private static int prefixIndex = 0;		
    public static String generatePrefix() {
	return (""ns"" + prefixIndex++);
    }

    public static final String RUN_TIME_INTERNAL_ERR =
                                           ""RUN_TIME_INTERNAL_ERR"";
    public static final String RUN_TIME_COPY_ERR =
                                           ""RUN_TIME_COPY_ERR"";
    public static final String DATA_CONVERSION_ERR =
                                           ""DATA_CONVERSION_ERR"";
    public static final String EXTERNAL_FUNC_ERR =
                                           ""EXTERNAL_FUNC_ERR"";
    public static final String EQUALITY_EXPR_ERR =
                                           ""EQUALITY_EXPR_ERR"";
    public static final String INVALID_ARGUMENT_ERR =
                                           ""INVALID_ARGUMENT_ERR"";
    public static final String FORMAT_NUMBER_ERR =
                                           ""FORMAT_NUMBER_ERR"";
    public static final String ITERATOR_CLONE_ERR =
                                           ""ITERATOR_CLONE_ERR"";
    public static final String AXIS_SUPPORT_ERR =
                                           ""AXIS_SUPPORT_ERR"";
    public static final String TYPED_AXIS_SUPPORT_ERR =
                                           ""TYPED_AXIS_SUPPORT_ERR"";
    public static final String STRAY_ATTRIBUTE_ERR =
                                           ""STRAY_ATTRIBUTE_ERR""; 
    public static final String STRAY_NAMESPACE_ERR =
                                           ""STRAY_NAMESPACE_ERR"";
    public static final String NAMESPACE_PREFIX_ERR =
                                           ""NAMESPACE_PREFIX_ERR"";
    public static final String DOM_ADAPTER_INIT_ERR =
                                           ""DOM_ADAPTER_INIT_ERR"";
    public static final String PARSER_DTD_SUPPORT_ERR =
                                           ""PARSER_DTD_SUPPORT_ERR"";
    public static final String NAMESPACES_SUPPORT_ERR =
                                           ""NAMESPACES_SUPPORT_ERR"";
    public static final String CANT_RESOLVE_RELATIVE_URI_ERR =
                                           ""CANT_RESOLVE_RELATIVE_URI_ERR"";

    
    protected static ResourceBundle m_bundle;
    
    public final static String ERROR_MESSAGES_KEY = ""error-messages"";

    static {
	String resource = ""org.apache.xalan.xsltc.runtime.ErrorMessages"";
	m_bundle = ResourceBundle.getBundle(resource);
    }

    
    public static void runTimeError(String code) {
	throw new RuntimeException(m_bundle.getString(code));
    }

    public static void runTimeError(String code, Object[] args) {
	final String message = MessageFormat.format(m_bundle.getString(code),
                                                    args);
	throw new RuntimeException(message);
    }

    public static void runTimeError(String code, Object arg0) {
	runTimeError(code, new Object[]{ arg0 } );
    }

    public static void runTimeError(String code, Object arg0, Object arg1) {
	runTimeError(code, new Object[]{ arg0, arg1 } );
    }

    public static void consoleOutput(String msg) {
	System.out.println(msg);
    }

    
    public static String replace(String base, char ch, String str) {
	return (base.indexOf(ch) < 0) ? base : 
	    replace(base, String.valueOf(ch), new String[] { str });
    }

    public static String replace(String base, String delim, String[] str) {
	final int len = base.length();
	final StringBuffer result = new StringBuffer();

	for (int i = 0; i < len; i++) {
	    final char ch = base.charAt(i);
	    final int k = delim.indexOf(ch);

	    if (k >= 0) {
		result.append(str[k]);
	    }
	    else {
		result.append(ch);
	    }
	}
	return result.toString();
    }

    
}
"
org.apache.xpath.objects.XString,49,3,2,43,100,1176,34,12,46,1.0,740,0.0,1,0.606837607,0.122222222,3,21,14.08163265,16,1.8571,1,"
package org.apache.xpath.objects;

import java.util.Locale;

import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;


public class XString extends XObject implements XMLString
{

  
  public static XString EMPTYSTRING = new XString("""");

  
  protected XString(Object val)
  {
    super(val);
  }

  
  public XString(String val)
  {
    super(val);
  }

  
  public int getType()
  {
    return CLASS_STRING;
  }

  
  public String getTypeString()
  {
    return ""#STRING"";
  }

  
  public boolean hasString()
  {
    return true;
  }

  
  public double num()
  {
    return toDouble();
  }

  
  public double toDouble()
  {
    int end = length();
    
    if(0 == end)
      return Double.NaN;

    double result = 0.0;
    int start = 0;
    int punctPos = end-1;

    
    for (int i = start; i < end; i++)
    {
      char c = charAt(i);

      if (!XMLCharacterRecognizer.isWhiteSpace(c))
      {
        break;
      }
      else
        start++;
    }

    double sign = 1.0;

    if (start < end && charAt(start) == '-')
    {
      sign = -1.0;

      start++;
    }

    int digitsFound = 0;

    for (int i = start; i < end; i++)  
    {
      char c = charAt(i);

      if (c != '.')
      {
        if (XMLCharacterRecognizer.isWhiteSpace(c))
          break;
        else if (Character.isDigit(c))
        {
          result = result * 10.0 + (c - 0x30);

          digitsFound++;
        }
        else
        {
          return Double.NaN;
        }
      }
      else
      {
        punctPos = i;

        break;
      }
    }

    if (charAt(punctPos) == '.')  
    {
      double fractPart = 0.0;

      for (int i = end - 1; i > punctPos; i--)
      {
        char c = charAt(i);

        if (XMLCharacterRecognizer.isWhiteSpace(c))
          break;
        else if (Character.isDigit(c))
        {
          fractPart = fractPart / 10.0 + (c - 0x30);

          digitsFound++;
        }
        else
        {
          return Double.NaN;
        }
      }

      result += fractPart / 10.0;
    }

    if (0 == digitsFound)
      return Double.NaN;

    return result * sign;
  }

  
  public boolean bool()
  {
    return str().length() > 0;
  }

  
  public XMLString xstr()
  {
    return this;
  }

  
  public String str()
  {
    return (null != m_obj) ? ((String) m_obj) : """";
  }

  
  public int rtf(XPathContext support)
  {

    DTM frag = support.createDocumentFragment();

    frag.appendTextChild(str());

    return frag.getDocument();
  }

  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {

    String str = str();

    ch.characters(str.toCharArray(), 0, str.length());
  }

  
  public void dispatchAsComment(org.xml.sax.ext.LexicalHandler lh)
          throws org.xml.sax.SAXException
  {

    String str = str();

    lh.comment(str.toCharArray(), 0, str.length());
  }

  
  public int length()
  {
    return str().length();
  }

  
  public char charAt(int index)
  {
    return str().charAt(index);
  }

  
  public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)
  {
    str().getChars(srcBegin, srcEnd, dst, dstBegin);
  }

  
  public boolean equals(XObject obj2)
  {

    
    
    
    int t = obj2.getType();
    try
    {
	    if (XObject.CLASS_NODESET == t)
	      return obj2.equals(this);
	    
	    
	    
	    else if(XObject.CLASS_BOOLEAN == t)
	    	return obj2.bool() == bool();
	    
	    
	    else if(XObject.CLASS_NUMBER == t)
	    	return obj2.num() == num();
    }
    catch(javax.xml.transform.TransformerException te)
    {
    	throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }

    
    
    return xstr().equals(obj2.xstr());
  }

  
  public boolean equals(XMLString obj2)
  {

    if (!obj2.hasString())
      return obj2.equals(this);
    else
      return str().equals(obj2.toString());
  }

  
  public boolean equals(Object obj2)
  {

    if (null == obj2)
      return false;

      
      
      
    else if (obj2 instanceof XNodeSet)
      return obj2.equals(this);
    else if(obj2 instanceof XNumber)
    	return obj2.equals(this);
    else
      return str().equals(obj2.toString());
  }

  
  public boolean equalsIgnoreCase(String anotherString)
  {
    return str().equalsIgnoreCase(anotherString);
  }

  
  public int compareTo(XMLString xstr)
  {

    int len1 = this.length();
    int len2 = xstr.length();
    int n = Math.min(len1, len2);
    int i = 0;
    int j = 0;

    while (n-- != 0)
    {
      char c1 = this.charAt(i);
      char c2 = xstr.charAt(j);

      if (c1 != c2)
      {
        return c1 - c2;
      }

      i++;
      j++;
    }

    return len1 - len2;
  }

  
  public int compareToIgnoreCase(XMLString str)
  {
    
    
    
    
    
    
    
    
    throw new org.apache.xml.utils.WrappedRuntimeException(
      new java.lang.NoSuchMethodException(
        ""Java 1.2 method, not yet implemented""));
  }

  
  public boolean startsWith(String prefix, int toffset)
  {
    return str().startsWith(prefix, toffset);
  }

  
  public boolean startsWith(String prefix)
  {
    return startsWith(prefix, 0);
  }

  
  public boolean startsWith(XMLString prefix, int toffset)
  {

    int to = toffset;
    int tlim = this.length();
    int po = 0;
    int pc = prefix.length();

    
    if ((toffset < 0) || (toffset > tlim - pc))
    {
      return false;
    }

    while (--pc >= 0)
    {
      if (this.charAt(to) != prefix.charAt(po))
      {
        return false;
      }

      to++;
      po++;
    }

    return true;
  }

  
  public boolean startsWith(XMLString prefix)
  {
    return startsWith(prefix, 0);
  }

  
  public boolean endsWith(String suffix)
  {
    return str().endsWith(suffix);
  }

  
  public int hashCode()
  {
    return str().hashCode();
  }

  
  public int indexOf(int ch)
  {
    return str().indexOf(ch);
  }

  
  public int indexOf(int ch, int fromIndex)
  {
    return str().indexOf(ch, fromIndex);
  }

  
  public int lastIndexOf(int ch)
  {
    return str().lastIndexOf(ch);
  }

  
  public int lastIndexOf(int ch, int fromIndex)
  {
    return str().lastIndexOf(ch, fromIndex);
  }

  
  public int indexOf(String str)
  {
    return str().indexOf(str);
  }

  
  public int indexOf(XMLString str)
  {
    return str().indexOf(str.toString());
  }

  
  public int indexOf(String str, int fromIndex)
  {
    return str().indexOf(str, fromIndex);
  }

  
  public int lastIndexOf(String str)
  {
    return str().lastIndexOf(str);
  }

  
  public int lastIndexOf(String str, int fromIndex)
  {
    return str().lastIndexOf(str, fromIndex);
  }

  
  public XMLString substring(int beginIndex)
  {
    return new XString(str().substring(beginIndex));
  }

  
  public XMLString substring(int beginIndex, int endIndex)
  {
    return new XString(str().substring(beginIndex, endIndex));
  }

  
  public XMLString concat(String str)
  {

    
    return new XString(str().concat(str));
  }

  
  public XMLString toLowerCase(Locale locale)
  {
    return new XString(str().toLowerCase(locale));
  }

  
  public XMLString toLowerCase()
  {
    return new XString(str().toLowerCase());
  }

  
  public XMLString toUpperCase(Locale locale)
  {
    return new XString(str().toUpperCase(locale));
  }

  
  public XMLString toUpperCase()
  {
    return new XString(str().toUpperCase());
  }

  
  public XMLString trim()
  {
    return new XString(str().trim());
  }

  
  private static boolean isSpace(char ch)
  {
    return XMLCharacterRecognizer.isWhiteSpace(ch);  
  }

  
  public XMLString fixWhiteSpace(boolean trimHead, boolean trimTail,
                                 boolean doublePunctuationSpaces)
  {

    
    int len = this.length();
    char[] buf = new char[len];

    this.getChars(0, len, buf, 0);

    boolean edit = false;
    int s;

    for (s = 0; s < len; s++)
    {
      if (isSpace(buf[s]))
      {
        break;
      }
    }

    
    int d = s;
    boolean pres = false;

    for (; s < len; s++)
    {
      char c = buf[s];

      if (isSpace(c))
      {
        if (!pres)
        {
          if (' ' != c)
          {
            edit = true;
          }

          buf[d++] = ' ';

          if (doublePunctuationSpaces && (s != 0))
          {
            char prevChar = buf[s - 1];

            if (!((prevChar == '.') || (prevChar == '!')
                  || (prevChar == '?')))
            {
              pres = true;
            }
          }
          else
          {
            pres = true;
          }
        }
        else
        {
          edit = true;
          pres = true;
        }
      }
      else
      {
        buf[d++] = c;
        pres = false;
      }
    }

    if (trimTail && 1 <= d && ' ' == buf[d - 1])
    {
      edit = true;

      d--;
    }

    int start = 0;

    if (trimHead && 0 < d && ' ' == buf[0])
    {
      edit = true;

      start++;
    }

    XMLStringFactory xsf = XMLStringFactoryImpl.getFactory();

    return edit ? xsf.newstr(new String(buf, start, d - start)) : this;
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	visitor.visitStringLiteral(owner, this);
  }

}
"
org.apache.xalan.xsltc.StripFilter,1,1,0,9,1,0,9,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;


public interface StripFilter {
    public boolean stripSpace(DOM dom, int node, int type);
}
"
org.apache.xalan.serialize.Serializer,9,1,0,3,9,36,2,1,9,2.0,9,0.0,0,0.0,0.333333333,0,0,0.0,1,1.0,0,"
package org.apache.xalan.serialize;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.util.Properties;

import org.xml.sax.ContentHandler;


public interface Serializer
{

  
  public void setOutputStream(OutputStream output);

  
  public OutputStream getOutputStream();

  
  public void setWriter(Writer writer);

  
  public Writer getWriter();

  
  public void setOutputFormat(Properties format);

  
  public Properties getOutputFormat();

  
  public ContentHandler asContentHandler() throws IOException;

  
  public DOMSerializer asDOMSerializer() throws IOException;

  
  public boolean reset();
}
"
org.apache.xalan.xsltc.trax.TrAXFilter,6,2,0,4,25,13,2,2,5,0.9,104,1.0,1,0.871794872,0.305555556,1,1,16.0,2,1.0,0,"


package org.apache.xalan.xsltc.trax;

import java.io.IOException;

import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.Templates;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.sax.SAXResult;

import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLFilterImpl;
import org.xml.sax.helpers.XMLReaderFactory;


public class TrAXFilter extends XMLFilterImpl {
    private Templates              _templates;
    private TransformerHandlerImpl _transformer;

    public TrAXFilter(Templates templates)  throws 
	TransformerConfigurationException
    {
	_templates = templates;
        _transformer = new TransformerHandlerImpl( 
		(TransformerImpl) templates.newTransformer());
    }

    private void createParent() throws SAXException {
	XMLReader parent = null;
        try {
            SAXParserFactory pfactory = SAXParserFactory.newInstance();
            pfactory.setNamespaceAware(true);
            SAXParser saxparser = pfactory.newSAXParser();
            parent = saxparser.getXMLReader();
        }
        catch (ParserConfigurationException e) {
            throw new SAXException(e);
        }
        catch (FactoryConfigurationError e) {
            throw new SAXException(e.toString());
        }

        if (parent == null) {
            parent = XMLReaderFactory.createXMLReader();
        }

        
        setParent(parent);
    }

    public void parse (InputSource input) throws SAXException, IOException
    {
	if (getParent() == null) {
		try {
		    createParent();
		}
                catch (SAXException  e) {
                    throw new SAXException(e.toString());
                }
	}

	
	getParent().parse(input);
    }

    public void parse (String systemId) throws SAXException, IOException 
    {
        parse(new InputSource(systemId));
    }

    public void setContentHandler (ContentHandler handler) 
    {
	_transformer.setResult(new SAXResult(handler));
	if (getParent() == null) {
                try {
                    createParent();
                }
                catch (SAXException  e) {
                   return; 
                }
	}
	getParent().setContentHandler(_transformer);
    }

    public void setErrorListener (ErrorListener handler) { }
}
"
org.apache.xml.utils.QName,28,1,0,53,49,268,49,4,28,0.562962963,732,0.8,0,0.0,0.285714286,1,1,24.96428571,9,1.4286,2,"
package org.apache.xml.utils;

import java.util.Stack;
import java.util.StringTokenizer;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;

import org.w3c.dom.Element;


public class QName implements java.io.Serializable
{

  
  protected String _localName;

  
  protected String _namespaceURI;

  
  protected String _prefix;

  
  public static final String S_XMLNAMESPACEURI =
    ""http:

  
  private int m_hashCode;

  
  public QName(){}

  
  public QName(String namespaceURI, String localName)
  {
    this(namespaceURI, localName, false); 
  }

  
  public QName(String namespaceURI, String localName, boolean validate) 
  {

    
    
    if (localName == null)
      throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_LOCALNAME_NULL, null)); 

    if (validate) 
    {
        if (!XMLChar.isValidNCName(localName))
        {
            throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }
    
    _namespaceURI = namespaceURI;
    _localName = localName;
    m_hashCode = toString().hashCode();
  }
  
  
  public QName(String namespaceURI, String prefix, String localName)
  {
     this(namespaceURI, prefix, localName, false);
  }
  
 
  public QName(String namespaceURI, String prefix, String localName, boolean validate)
  {

    
    
    if (localName == null)
      throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_LOCALNAME_NULL, null)); 

    if (validate)
    {    
        if (!XMLChar.isValidNCName(localName))
        {
            throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }

        if ((null != prefix) && (!XMLChar.isValidNCName(prefix)))
        {
            throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_PREFIX_INVALID,null )); 
        }

    }
    _namespaceURI = namespaceURI;
    _prefix = prefix;
    _localName = localName;
    m_hashCode = toString().hashCode();
  }  

  
  public QName(String localName)
  {
    this(localName, false);
  }
  
  
  public QName(String localName, boolean validate)
  {

    
    
    if (localName == null)
      throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_LOCALNAME_NULL, null)); 

    if (validate)
    {    
        if (!XMLChar.isValidNCName(localName))
        {
            throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }
    _namespaceURI = null;
    _localName = localName;
    m_hashCode = toString().hashCode();
  }  

  
  public QName(String qname, Stack namespaces)
  {
    this(qname, namespaces, false);
  }

  
  public QName(String qname, Stack namespaces, boolean validate)
  {

    String namespace = null;
    String prefix = null;
    int indexOfNSSep = qname.indexOf(':');

    if (indexOfNSSep > 0)
    {
      prefix = qname.substring(0, indexOfNSSep);

      if (prefix.equals(""xml""))
      {
        namespace = S_XMLNAMESPACEURI;
      }
      
      else if (prefix.equals(""xmlns""))
      {
        return;
      }
      else
      {
        int depth = namespaces.size();

        for (int i = depth - 1; i >= 0; i--)
        {
          NameSpace ns = (NameSpace) namespaces.elementAt(i);

          while (null != ns)
          {
            if ((null != ns.m_prefix) && prefix.equals(ns.m_prefix))
            {
              namespace = ns.m_uri;
              i = -1;

              break;
            }

            ns = ns.m_next;
          }
        }
      }

      if (null == namespace)
      {
        throw new RuntimeException(
          XMLMessages.createXMLMessage(
            XMLErrorResources.ER_PREFIX_MUST_RESOLVE,
            new Object[]{ prefix }));  
      }
    }

    _localName = (indexOfNSSep < 0)
                 ? qname : qname.substring(indexOfNSSep + 1);
                 
    if (validate)
    {
        if ((_localName == null) || (!XMLChar.isValidNCName(_localName))) 
        {
           throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }                 
    _namespaceURI = namespace;
    _prefix = prefix;
    m_hashCode = toString().hashCode();
  }

  
  public QName(String qname, Element namespaceContext,
               PrefixResolver resolver)
  {
      this(qname, namespaceContext, resolver, false);
  }

  
  public QName(String qname, Element namespaceContext,
               PrefixResolver resolver, boolean validate)
  {

    _namespaceURI = null;

    int indexOfNSSep = qname.indexOf(':');

    if (indexOfNSSep > 0)
    {
      if (null != namespaceContext)
      {
        String prefix = qname.substring(0, indexOfNSSep);

        _prefix = prefix;

        if (prefix.equals(""xml""))
        {
          _namespaceURI = S_XMLNAMESPACEURI;
        }
        
        
        else if (prefix.equals(""xmlns""))
        {
          return;
        }
        else
        {
          _namespaceURI = resolver.getNamespaceForPrefix(prefix,
                  namespaceContext);
        }

        if (null == _namespaceURI)
        {
          throw new RuntimeException(
            XMLMessages.createXMLMessage(
              XMLErrorResources.ER_PREFIX_MUST_RESOLVE,
              new Object[]{ prefix }));  
        }
      }
      else
      {

        
      }
    }

    _localName = (indexOfNSSep < 0)
                 ? qname : qname.substring(indexOfNSSep + 1);

    if (validate)
    {
        if ((_localName == null) || (!XMLChar.isValidNCName(_localName))) 
        {
           throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }                 
                 
    m_hashCode = toString().hashCode();
  }


  
  public QName(String qname, PrefixResolver resolver)
  {
    this(qname, resolver, false);
  }

  
  public QName(String qname, PrefixResolver resolver, boolean validate)
  {

	String prefix = null;
    _namespaceURI = null;

    int indexOfNSSep = qname.indexOf(':');

    if (indexOfNSSep > 0)
    {
      prefix = qname.substring(0, indexOfNSSep);

      if (prefix.equals(""xml""))
      {
        _namespaceURI = S_XMLNAMESPACEURI;
      }
      else
      {
        _namespaceURI = resolver.getNamespaceForPrefix(prefix);
      }

      if (null == _namespaceURI)
      {
        throw new RuntimeException(
          XMLMessages.createXMLMessage(
            XMLErrorResources.ER_PREFIX_MUST_RESOLVE,
            new Object[]{ prefix }));  
      }
    }

	_localName = (indexOfNSSep < 0)
                 ? qname : qname.substring(indexOfNSSep + 1);   
                 
    if (validate)
    {
        if ((_localName == null) || (!XMLChar.isValidNCName(_localName))) 
        {
           throw new IllegalArgumentException(XMLMessages.createXMLMessage(
            XMLErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }                 

              
    m_hashCode = toString().hashCode();
    _prefix = prefix;
  }

  
  public String getNamespaceURI()
  {
    return _namespaceURI;
  }

  
  public String getPrefix()
  {
    return _prefix;
  }

  
  public String getLocalName()
  {
    return _localName;
  }

  
  public String toString()
  {

    return _prefix != null
           ? (_prefix + "":"" + _localName)
           : (_namespaceURI != null
              ? (""{""+_namespaceURI + ""}"" + _localName) : _localName);
  }
  
  
  public String toNamespacedString()
  {

    return (_namespaceURI != null
              ? (""{""+_namespaceURI + ""}"" + _localName) : _localName);
  }


  
  public String getNamespace()
  {
    return getNamespaceURI();
  }

  
  public String getLocalPart()
  {
    return getLocalName();
  }

  
  public int hashCode()
  {
    return m_hashCode;
  }

  
  public boolean equals(String ns, String localPart)
  {

    String thisnamespace = getNamespaceURI();

    return getLocalName().equals(localPart)
           && (((null != thisnamespace) && (null != ns))
               ? thisnamespace.equals(ns)
               : ((null == thisnamespace) && (null == ns)));
  }

  
  public boolean equals(Object object)
  {

    if (object == this)
      return true;

    if (object instanceof QName) {
      QName qname = (QName) object;
      String thisnamespace = getNamespaceURI();
      String thatnamespace = qname.getNamespaceURI();

      return getLocalName().equals(qname.getLocalName())
             && (((null != thisnamespace) && (null != thatnamespace))
                 ? thisnamespace.equals(thatnamespace)
                 : ((null == thisnamespace) && (null == thatnamespace)));
    }
    else
      return false;
  }

  
  public static QName getQNameFromString(String name)
  {

    StringTokenizer tokenizer = new StringTokenizer(name, ""{}"", false);
    QName qname;
    String s1 = tokenizer.nextToken();
    String s2 = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;

    if (null == s2)
      qname = new QName(null, s1);
    else
      qname = new QName(s1, s2);

    return qname;
  }

  
  public static boolean isXMLNSDecl(String attRawName)
  {

    return (attRawName.startsWith(""xmlns"")
            && (attRawName.equals(""xmlns"")
                || attRawName.startsWith(""xmlns:"")));
  }

  
  public static String getPrefixFromXMLNSDecl(String attRawName)
  {

    int index = attRawName.indexOf(':');

    return (index >= 0) ? attRawName.substring(index + 1) : """";
  }

  
  public static String getLocalPart(String qname)
  {

    int index = qname.indexOf(':');

    return (index < 0) ? qname : qname.substring(index + 1);
  }

  
  public static String getPrefixPart(String qname)
  {

    int index = qname.indexOf(':');

    return (index >= 0) ? qname.substring(0, index) : """";
  }
}
"
org.apache.xml.serializer.SerializerFactory,3,1,0,10,15,3,6,4,2,1.0,97,1.0,0,0.0,0.5,0,0,31.0,5,1.6667,1,"
package org.apache.xml.serializer;

import java.util.Hashtable;
import java.util.Properties;

import javax.xml.transform.OutputKeys;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.xml.sax.ContentHandler;


public abstract class SerializerFactory
{

  

  

  
  private static Hashtable m_formats = new Hashtable();

  
    public static Serializer getSerializer(Properties format)
    {

      Serializer ser = null;

      try
      {
        Class cls;
        String method = format.getProperty(OutputKeys.METHOD);

        if (method == null)
          throw new IllegalArgumentException(
            ""The output format has a null method name"");



        String className;

          className =
            format.getProperty(OutputPropertiesFactory.S_KEY_CONTENT_HANDLER);

          if (null == className)
          {
            throw new IllegalArgumentException(
              ""The output format must have a '""
              + OutputPropertiesFactory.S_KEY_CONTENT_HANDLER + ""' property!"");
          }

          cls = Class.forName(className);

          


        Object obj = cls.newInstance();

        if (obj instanceof SerializationHandler)
        {
              
            ser = (Serializer) cls.newInstance();
            ser.setOutputFormat(format);
        }
        else
        {
              
               if (obj instanceof ContentHandler)
               {

                  
                  className = SerializerConstants.DEFAULT_SAX_SERIALIZER;
                  cls = Class.forName(className);
                  SerializationHandler sh =
                      (SerializationHandler) cls.newInstance();
                  sh.setContentHandler( (ContentHandler) obj);
                  sh.setOutputFormat(format);

                  ser = sh;


               }
               else
               {
                  
                  
                   throw new Exception(
                       XMLMessages.createXMLMessage(
                           XMLErrorResources.ER_SERIALIZER_NOT_CONTENTHANDLER,
                               new Object[] { className}));
               }

        }
      }
      catch (Exception e)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(e);
      }

      return ser;
    }
}
"
org.apache.xalan.xsltc.runtime.StringValueHandler,8,2,0,2,19,0,1,1,8,0.657142857,183,1.0,0,0.932692308,0.35,0,0,21.25,5,1.625,0,"

package org.apache.xalan.xsltc.runtime;

import org.xml.sax.SAXException;

import org.apache.xml.serializer.EmptySerializer;

public final class StringValueHandler extends EmptySerializer {

    private StringBuffer _buffer = new StringBuffer();
    private String _str = null;
    private static final String EMPTY_STR = """";
    private boolean m_escaping = false;
    private int _nestedLevel = 0;
	
    public void characters(char[] ch, int off, int len) 
	throws SAXException 
    {
	if (_nestedLevel > 0)
	    return;
	
	if (_str != null) {
	    _buffer.append(_str);
	    _str = null;
	}
	_buffer.append(ch, off, len);
    }

    public String getValue() {
	if (_buffer.length() != 0) {
	    String result = _buffer.toString();
	    _buffer.setLength(0);
	    return result;
	}
	else {
	    String result = _str;
	    _str = null;
	    return (result != null) ? result : EMPTY_STR;
	}
    }

    public void characters(String characters) throws SAXException {
	if (_nestedLevel > 0)
	    return;

	if (_str == null && _buffer.length() == 0) {
	    _str = characters;
	}
	else {
	    if (_str != null) {
	        _buffer.append(_str);
	        _str = null;
	    }
	    
	    _buffer.append(characters);
	}
    }
    
    public void startElement(String qname) throws SAXException {
        _nestedLevel++;
    }

    public void endElement(String qname) throws SAXException {
        _nestedLevel--;
    }

    
    
    public boolean setEscaping(boolean bool) {
        boolean oldEscaping = m_escaping;
        m_escaping = bool;

        return bool;
    }

    
    public String getValueOfPI() {
	final String value = getValue();

	if (value.indexOf(""?>"") > 0) {
	    final int n = value.length(); 
	    final StringBuffer valueOfPI = new StringBuffer();

	    for (int i = 0; i < n;) {
		final char ch = value.charAt(i++);
		if (ch == '?' && value.charAt(i) == '>') {
		    valueOfPI.append(""? >""); i++;
		}
		else {
		    valueOfPI.append(ch);
		}
	    } 
	    return valueOfPI.toString();
	}
	return value;
    }
}
"
org.apache.xpath.axes.FilterExprIteratorSimple,16,5,0,16,44,8,4,13,14,0.75,261,1.0,2,0.899280576,0.18125,3,10,15.0625,4,1.4375,0,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XNodeSet;


public class FilterExprIteratorSimple extends LocPathIterator
{
  
  private Expression m_expr;

  
  transient private XNodeSet m_exprObj;

  private boolean m_mustHardReset = false;
  private boolean m_canDetachNodeset = true;

  
  public FilterExprIteratorSimple()
  {
    super(null);
  }
  
  
  public FilterExprIteratorSimple(Expression expr)
  {
    super(null);
    m_expr = expr;
  }
  
  
  public void setRoot(int context, Object environment)
  {
  	super.setRoot(context, environment);
  	m_exprObj = executeFilterExpr(context, m_execContext, getPrefixResolver(), 
  	                  getIsTopLevel(), m_stackFrame, m_expr);
  }

  
  public static XNodeSet executeFilterExpr(int context, XPathContext xctxt, 
  												PrefixResolver prefixResolver,
  												boolean isTopLevel,
  												int stackFrame,
  												Expression expr )
    throws org.apache.xml.utils.WrappedRuntimeException
  {
    PrefixResolver savedResolver = xctxt.getNamespaceContext();
    XNodeSet result = null;

    try
    {
      xctxt.pushCurrentNode(context);
      xctxt.setNamespaceContext(prefixResolver);

      
      
      
      

      if (isTopLevel)
      {
        
        VariableStack vars = xctxt.getVarStack();

        
        int savedStart = vars.getStackFrame();
        vars.setStackFrame(stackFrame);

        result = (org.apache.xpath.objects.XNodeSet) expr.execute(xctxt);
        result.setShouldCacheNodes(true);

        
        vars.setStackFrame(savedStart);
      }
      else
          result = (org.apache.xpath.objects.XNodeSet) expr.execute(xctxt);

    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new org.apache.xml.utils.WrappedRuntimeException(se);
    }
    finally
    {
      xctxt.popCurrentNode();
      xctxt.setNamespaceContext(savedResolver);
    }
    return result;
  }
  
  
  public int nextNode()
  {
  	if(m_foundLast)
  		return DTM.NULL;

    int next;

    if (null != m_exprObj)
    {
      m_lastFetched = next = m_exprObj.nextNode();
    }
    else
      m_lastFetched = next = DTM.NULL;

    
    if (DTM.NULL != next)
    {
      m_pos++;
      return next;
    }
    else
    {
      m_foundLast = true;

      return DTM.NULL;
    }
  }
  
  
  public void detach()
  {  
    if(m_allowDetach)
    {
  		super.detach();
  		m_exprObj.detach();
  		m_exprObj = null;
    }
  }

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    m_expr.fixupVariables(vars, globalsSize);
  }

  
  public Expression getInnerExpression()
  {
    return m_expr;
  }

  
  public void setInnerExpression(Expression expr)
  {
    expr.exprSetParent(this);
    m_expr = expr;
  }

  
  public int getAnalysisBits()
  {
    if (null != m_expr && m_expr instanceof PathComponent)
    {
      return ((PathComponent) m_expr).getAnalysisBits();
    }
    return WalkerFactory.BIT_FILTER;
  }

  
  public boolean isDocOrdered()
  {
    return m_exprObj.isDocOrdered();
  }

  class filterExprOwner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_expr;
    }

    
    public void setExpression(Expression exp)
    {
      exp.exprSetParent(FilterExprIteratorSimple.this);
      m_expr = exp;
    }

  }

  
  public void callPredicateVisitors(XPathVisitor visitor)
  {
    m_expr.callVisitors(new filterExprOwner(), visitor);

    super.callPredicateVisitors(visitor);
  }

  
  public boolean deepEquals(Expression expr)
  {
    if (!super.deepEquals(expr))
      return false;

    FilterExprIteratorSimple fet = (FilterExprIteratorSimple) expr;
    if (!m_expr.deepEquals(fet.m_expr))
      return false;

    return true;
  }
  
  
  public int getAxis()
  {
  	if(null != m_exprObj)
    	return m_exprObj.getAxis();
    else
    	return Axis.FILTEREDLIST;
  }


}

"
org.apache.xml.serializer.Serializer,9,1,0,11,9,36,10,1,9,2.0,9,0.0,0,0.0,0.333333333,0,0,0.0,1,1.0,0,"
package org.apache.xml.serializer;
import java.io.Writer;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Properties;

import org.apache.xml.serializer.DOMSerializer; 

import org.xml.sax.ContentHandler;


public interface Serializer {

    
    public void setOutputStream(OutputStream output);

    
    public OutputStream getOutputStream();

    
    public void setWriter(Writer writer);

    
    public Writer getWriter();

    
    public void setOutputFormat(Properties format);

    
    public Properties getOutputFormat();

    
    public ContentHandler asContentHandler() throws IOException;

    
    public DOMSerializer asDOMSerializer() throws IOException;

    
    public boolean reset();
}

"
org.apache.xpath.objects.XStringForFSB,31,4,0,10,59,117,1,10,29,0.5,823,0.5,0,0.802721088,0.150537634,4,20,25.41935484,14,2.9032,0,"
package org.apache.xpath.objects;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xpath.res.XPATHErrorResources;


public class XStringForFSB extends XString
{

  
  int m_start;

  
  int m_length;

  
  protected String m_strCache = null;

  
  protected int m_hash = 0;

  
  public XStringForFSB(FastStringBuffer val, int start, int length)
  {

    super(val);

    m_start = start;
    m_length = length;

    if (null == val)
      throw new IllegalArgumentException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_FASTSTRINGBUFFER_CANNOT_BE_NULL, null));
  }

  
  private XStringForFSB(String val)
  {

    super(val);

    throw new IllegalArgumentException(
      XSLMessages.createXPATHMessage(XPATHErrorResources.ER_FSB_CANNOT_TAKE_STRING, null)); 
  }

  
  public FastStringBuffer fsb()
  {
    return ((FastStringBuffer) m_obj);
  }
  
  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    
    fsb.append(str());
  }

  
  public boolean hasString()
  {
    return (null != m_strCache);
  }







  
  public Object object()
  {
    return str();
  }

  
  public String str()
  {

    if (null == m_strCache)
    {
      m_strCache = fsb().getString(m_start, m_length);






















      
    }

    return m_strCache;
  }

  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {
    fsb().sendSAXcharacters(ch, m_start, m_length);
  }

  
  public void dispatchAsComment(org.xml.sax.ext.LexicalHandler lh)
          throws org.xml.sax.SAXException
  {
    fsb().sendSAXComment(lh, m_start, m_length);
  }

  
  public int length()
  {
    return m_length;
  }

  
  public char charAt(int index)
  {
    return fsb().charAt(m_start + index);
  }

  
  public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)
  {

    
    
    int n = srcEnd - srcBegin;

    if (n > m_length)
      n = m_length;

    if (n > (dst.length - dstBegin))
      n = (dst.length - dstBegin);

    int end = srcBegin + m_start + n;
    int d = dstBegin;
    FastStringBuffer fsb = fsb();

    for (int i = srcBegin + m_start; i < end; i++)
    {
      dst[d++] = fsb.charAt(i);
    }
  }

  
  public boolean equals(XMLString obj2)
  {

    if (this == obj2)
    {
      return true;
    }

    int n = m_length;

    if (n == obj2.length())
    {
      FastStringBuffer fsb = fsb();
      int i = m_start;
      int j = 0;

      while (n-- != 0)
      {
        if (fsb.charAt(i) != obj2.charAt(j))
        {
          return false;
        }

        i++;
        j++;
      }

      return true;
    }

    return false;
  }

  
  public boolean equals(XObject obj2)
  {

    if (this == obj2)
    {
      return true;
    }
    if(obj2.getType() == XObject.CLASS_NUMBER)
    	return obj2.equals(this);

    String str = obj2.str();
    int n = m_length;

    if (n == str.length())
    {
      FastStringBuffer fsb = fsb();
      int i = m_start;
      int j = 0;

      while (n-- != 0)
      {
        if (fsb.charAt(i) != str.charAt(j))
        {
          return false;
        }

        i++;
        j++;
      }

      return true;
    }

    return false;
  }

  
  public boolean equals(String anotherString)
  {

    int n = m_length;

    if (n == anotherString.length())
    {
      FastStringBuffer fsb = fsb();
      int i = m_start;
      int j = 0;

      while (n-- != 0)
      {
        if (fsb.charAt(i) != anotherString.charAt(j))
        {
          return false;
        }

        i++;
        j++;
      }

      return true;
    }

    return false;
  }

  
  public boolean equals(Object obj2)
  {

    if (null == obj2)
      return false;
      
    if(obj2 instanceof XNumber)
    	return obj2.equals(this);

      
      
      
    else if (obj2 instanceof XNodeSet)
      return obj2.equals(this);
    else if (obj2 instanceof XStringForFSB)
      return equals((XMLString) this);
    else
      return equals(obj2.toString());
  }

  
  public boolean equalsIgnoreCase(String anotherString)
  {
    return (m_length == anotherString.length())
           ? str().equalsIgnoreCase(anotherString) : false;
  }

  
  public int compareTo(XMLString xstr)
  {

    int len1 = m_length;
    int len2 = xstr.length();
    int n = Math.min(len1, len2);
    FastStringBuffer fsb = fsb();
    int i = m_start;
    int j = 0;

    while (n-- != 0)
    {
      char c1 = fsb.charAt(i);
      char c2 = xstr.charAt(j);

      if (c1 != c2)
      {
        return c1 - c2;
      }

      i++;
      j++;
    }

    return len1 - len2;
  }

  
  public int compareToIgnoreCase(XMLString xstr)
  {

    int len1 = m_length;
    int len2 = xstr.length();
    int n = Math.min(len1, len2);
    FastStringBuffer fsb = fsb();
    int i = m_start;
    int j = 0;

    while (n-- != 0)
    {
      char c1 = Character.toLowerCase(fsb.charAt(i));
      char c2 = Character.toLowerCase(xstr.charAt(j));

      if (c1 != c2)
      {
        return c1 - c2;
      }

      i++;
      j++;
    }

    return len1 - len2;
  }

  
  public int hashCode()
  {
    
    
    
    
    
    


    return super.hashCode(); 
  }

  
  public boolean startsWith(XMLString prefix, int toffset)
  {

    FastStringBuffer fsb = fsb();
    int to = m_start + toffset;
    int tlim = m_start + m_length;
    int po = 0;
    int pc = prefix.length();

    
    if ((toffset < 0) || (toffset > m_length - pc))
    {
      return false;
    }

    while (--pc >= 0)
    {
      if (fsb.charAt(to) != prefix.charAt(po))
      {
        return false;
      }

      to++;
      po++;
    }

    return true;
  }

  
  public boolean startsWith(XMLString prefix)
  {
    return startsWith(prefix, 0);
  }

  
  public int indexOf(int ch)
  {
    return indexOf(ch, 0);
  }

  
  public int indexOf(int ch, int fromIndex)
  {

    int max = m_start + m_length;
    FastStringBuffer fsb = fsb();

    if (fromIndex < 0)
    {
      fromIndex = 0;
    }
    else if (fromIndex >= m_length)
    {

      
      return -1;
    }

    for (int i = m_start + fromIndex; i < max; i++)
    {
      if (fsb.charAt(i) == ch)
      {
        return i - m_start;
      }
    }

    return -1;
  }

  
  public XMLString substring(int beginIndex)
  {

    int len = m_length - beginIndex;

    if (len <= 0)
      return XString.EMPTYSTRING;
    else
    {
      int start = m_start + beginIndex;

      return new XStringForFSB(fsb(), start, len);
    }
  }

  
  public XMLString substring(int beginIndex, int endIndex)
  {

    int len = endIndex - beginIndex;

    if (len > m_length)
      len = m_length;

    if (len <= 0)
      return XString.EMPTYSTRING;
    else
    {
      int start = m_start + beginIndex;

      return new XStringForFSB(fsb(), start, len);
    }
  }

  
  public XMLString concat(String str)
  {

    
    return new XString(str().concat(str));
  }

  
  public XMLString trim()
  {
    return fixWhiteSpace(true, true, false);
  }

  
  private static boolean isSpace(char ch)
  {
    return XMLCharacterRecognizer.isWhiteSpace(ch);  
  }

  
  public XMLString fixWhiteSpace(boolean trimHead, boolean trimTail,
                                 boolean doublePunctuationSpaces)
  {

    int end = m_length + m_start;
    char[] buf = new char[m_length];
    FastStringBuffer fsb = fsb();
    boolean edit = false;

    
    int d = 0;
    boolean pres = false;

    for (int s = m_start; s < end; s++)
    {
      char c = fsb.charAt(s);

      if (isSpace(c))
      {
        if (!pres)
        {
          if (' ' != c)
          {
            edit = true;
          }

          buf[d++] = ' ';

          if (doublePunctuationSpaces && (d != 0))
          {
            char prevChar = buf[d - 1];

            if (!((prevChar == '.') || (prevChar == '!')
                  || (prevChar == '?')))
            {
              pres = true;
            }
          }
          else
          {
            pres = true;
          }
        }
        else
        {
          edit = true;
          pres = true;
        }
      }
      else
      {
        buf[d++] = c;
        pres = false;
      }
    }

    if (trimTail && 1 <= d && ' ' == buf[d - 1])
    {
      edit = true;

      d--;
    }

    int start = 0;

    if (trimHead && 0 < d && ' ' == buf[0])
    {
      edit = true;

      start++;
    }

    XMLStringFactory xsf = XMLStringFactoryImpl.getFactory();

    return edit ? xsf.newstr(buf, start, d - start) : this;
  }

  
  public double toDouble()
  {
    if(m_length == 0)
      return Double.NaN;
    int i;
    char c;
    String valueString = fsb().getString(m_start,m_length);
    
    
    
    
    
    
    
    
    for (i=0;i<m_length;i++)
      if (!XMLCharacterRecognizer.isWhiteSpace(valueString.charAt(i)))
        break;
    if (valueString.charAt(i) == '-')
      i++;
    for (;i<m_length;i++) {
      c = valueString.charAt(i);
      if (c != '.' && (c < '0' || c > '9'))
        break;
    }   	    	
    for (;i<m_length;i++)
      if (!XMLCharacterRecognizer.isWhiteSpace(valueString.charAt(i)))
        break;
    if (i != m_length)
      return Double.NaN;
    	
    try {
      return new Double(valueString).doubleValue();
    } catch (NumberFormatException nfe) {
      
      return Double.NaN;
    }
  }
}
"
org.apache.xml.utils.synthetic.JavaUtils,5,1,0,0,18,4,0,0,3,0.625,157,1.0,0,0.0,0.25,0,0,30.0,6,1.8,1,"

package org.apache.xml.utils.synthetic;

import java.io.IOException;


public class JavaUtils
{
        
        private static boolean cantLoadCompiler=false; 

        
        private static boolean debug = false;
  
         
        public static void setDebug(boolean newDebug)
        {
            debug=newDebug;
        }

        
        public static boolean JDKcompile(String fileName, String classPath)
        {
                String moreClassPath=
                        System.getProperty(""org.apache.xml.utils.synthetic.moreclasspath"","""")
                        .trim();
                if(moreClassPath.length()>0)
                        classPath=moreClassPath+';'+classPath;
                                                                                                  
                if (debug)
                {
                        System.err.println (""JavaEngine: Compiling "" + fileName);
                        System.err.println (""JavaEngine: Classpath is "" + classPath);
                }
    
                String code_option = debug ? ""-g"" : ""-O"";

                
            if(!cantLoadCompiler)
                {
                        String args[] = {
                                code_option,
                            ""-classpath"", classPath,
                                fileName
                        };
                                










                }
    
                
                
                
                String javac_command=
                        System.getProperty(""org.apache.xml.utils.synthetic.javac"",""javac"");
            String args[] = {
                        javac_command,
                        code_option,
                        ""-classpath"", classPath,
                        fileName
                        };
                try
                {
                        Process p=java.lang.Runtime.getRuntime().exec(args);
                        int compileOK=waitHardFor(p); 
                        return compileOK==0; 
                }
                catch(IOException e)
                {
                        System.err.println(""ERROR: IO exception during exec(javac)."");
                }
                catch(SecurityException e)
                {
                        System.err.println(""ERROR: Unable to create subprocess to exec(javac)."");
                }
                
                
                return false;
        }

  
  static int waitHardFor(java.lang.Process p)
  {
    boolean done=false;
    while(!done)
        try
        {
            p.waitFor();
            done=true;
        }
        catch(InterruptedException e)
        {
            System.err.println(""(Compiler process wait interrupted and resumed)"");
        }
     int ev=p.exitValue();  
     return ev;
  }
        
}
"
org.apache.xalan.Version,9,1,0,1,15,36,0,1,9,2.0,69,0.0,0,0.0,0.111111111,0,0,6.666666667,2,1.0,1,"
package org.apache.xalan;


public class Version
{

  
  public static String getVersion()
  {
    return getProduct()+"" ""+getImplementationLanguage()+"" ""
           +getMajorVersionNum()+"".""+getReleaseVersionNum()+"".""
           +( (getDevelopmentVersionNum() > 0) ? 
               (""D""+getDevelopmentVersionNum()) : (""""+getMaintenanceVersionNum()));
  }

  
  public static void main(String argv[])
  {
    System.out.println(getVersion());
  }

  
  public static String getProduct()
  {
    return ""Xalan"";
  }

  
  public static String getImplementationLanguage()
  {
    return ""Java"";
  }

  
  public static int getMajorVersionNum()
  {
    
    
    
    
    return org.apache.xalan.processor.XSLProcessorVersion.VERSION;
    
  }

  
  public static int getReleaseVersionNum()
  {
    
    return org.apache.xalan.processor.XSLProcessorVersion.RELEASE;
  }

  
  public static int getMaintenanceVersionNum()
  {
    
    return org.apache.xalan.processor.XSLProcessorVersion.MAINTENANCE;
  }

  
  public static int getDevelopmentVersionNum()
  {
    
    return org.apache.xalan.processor.XSLProcessorVersion.DEVELOPMENT;
  }
}
"
org.apache.xpath.objects.XMLStringFactoryImpl,7,2,0,8,11,19,4,6,6,0.833333333,39,1.0,1,0.444444444,0.333333333,0,0,4.428571429,1,0.7143,1,"
package org.apache.xpath.objects;

import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;


public class XMLStringFactoryImpl extends XMLStringFactory
{
  
  private static XMLStringFactory m_xstringfactory =
    new XMLStringFactoryImpl();

  
  public static XMLStringFactory getFactory()
  {
    return m_xstringfactory;
  }

  
  public XMLString newstr(String string)
  {
    return new XString(string);
  }

  
  public XMLString newstr(FastStringBuffer fsb, int start, int length)
  {
    return new XStringForFSB(fsb, start, length);
  }
  
  
  public XMLString newstr(char[] string, int start, int length)
  {
    return new XStringForChars(string, start, length);
  }
  
  
  public XMLString emptystr()
  {
    return XString.EMPTYSTRING;
  }

}
"
org.apache.xpath.operations.VariableSafeAbsRef,2,3,0,9,11,1,1,8,2,2.0,39,0.0,0,0.97826087,0.666666667,1,1,18.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xml.dtm.DTMManager;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;



public class VariableSafeAbsRef extends Variable
{
	
  
  public XObject execute(XPathContext xctxt, boolean destructiveOK) 
  	throws javax.xml.transform.TransformerException
  {
  	XNodeSet xns = (XNodeSet)super.execute(xctxt, destructiveOK);
  	DTMManager dtmMgr = xctxt.getDTMManager();
  	int context = xctxt.getContextNode();
  	if(dtmMgr.getDTM(xns.getRoot()).getDocument() != 
  	   dtmMgr.getDTM(context).getDocument())
  	{
  		Expression expr = (Expression)xns.getContainedIter();
  		xns = (XNodeSet)expr.asIterator(xctxt, context);
  	}
  	return xns;
  }

}

"
org.apache.xalan.templates.ElemAttributeSet,8,4,0,10,24,16,6,7,8,0.571428571,97,0.0,1,0.966507177,0.3,2,4,11.0,3,1.125,2,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;


public class ElemAttributeSet extends ElemUse
{

  
  public QName m_qname = null;

  
  public void setName(QName name)
  {
    m_qname = name;
  }

  
  public QName getName()
  {
    return m_qname;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_DEFINEATTRIBUTESET;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_ATTRIBUTESET_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (transformer.isRecursiveAttrSet(this))
    {
      throw new TransformerException(
        XSLMessages.createMessage(
          XSLTErrorResources.ER_XSLATTRSET_USED_ITSELF,
          new Object[]{ m_qname.getLocalPart() }));  
    }

    transformer.pushElemAttributeSet(this);
    super.execute(transformer);

    ElemAttribute attr = (ElemAttribute) getFirstChildElem();

    while (null != attr)
    {
      attr.execute(transformer);

      attr = (ElemAttribute) attr.getNextSiblingElem();
    }

    transformer.popElemAttributeSet();
  }

  
  public ElemTemplateElement appendChildElem(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {
    case Constants.ELEMNAME_ATTRIBUTE :
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeAttributeSets(this);
  }

}
"
org.apache.xml.utils.PrefixResolver,4,1,0,69,4,6,69,0,4,2.0,4,0.0,0,0.0,0.583333333,0,0,0.0,1,1.0,1,"
package org.apache.xml.utils;


public interface PrefixResolver
{

  
  String getNamespaceForPrefix(String prefix);

  
  String getNamespaceForPrefix(String prefix, org.w3c.dom.Node context);

  
  public String getBaseIdentifier();
  
  public boolean handlesNullPrefixes();
}
"
org.apache.xalan.transformer.CountersTable,5,3,0,7,23,8,3,5,2,0.875,198,0.5,1,0.904761905,0.44,0,0,38.2,2,1.2,1,"
package org.apache.xalan.transformer;

import java.util.Hashtable;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.ElemNumber;
import org.apache.xml.dtm.DTM;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPathContext;


public class CountersTable extends Hashtable
{

  
  public CountersTable(){}

  
  Vector getCounters(ElemNumber numberElem)
  {

    Vector counters = (Vector) this.get(numberElem);

    return (null == counters) ? putElemNumber(numberElem) : counters;
  }

  
  Vector putElemNumber(ElemNumber numberElem)
  {

    Vector counters = new Vector();

    this.put(numberElem, counters);

    return counters;
  }

  
  transient private NodeSetDTM m_newFound;

  
  void appendBtoFList(NodeSetDTM flist, NodeSetDTM blist)
  {

    int n = blist.size();

    for (int i = (n - 1); i >= 0; i--)
    {
      flist.addElement(blist.item(i));
    }
  }

  

  
  transient int m_countersMade = 0;

  
  public int countNode(XPathContext support, ElemNumber numberElem, int node)
          throws TransformerException
  {

    int count = 0;
    Vector counters = getCounters(numberElem);
    int nCounters = counters.size();

    
    
    int target = numberElem.getTargetNode(support, node);

    if (DTM.NULL != target)
    {
      for (int i = 0; i < nCounters; i++)
      {
        Counter counter = (Counter) counters.elementAt(i);

        count = counter.getPreviouslyCounted(support, target);

        if (count > 0)
          return count;
      }

      
      
      
      
      
      
      count = 0;
      if (m_newFound == null)
        m_newFound = new NodeSetDTM(support.getDTMManager());

      for (; DTM.NULL != target;
              target = numberElem.getPreviousNode(support, target))
      {

        
        
        
        if (0 != count)
        {
          for (int i = 0; i < nCounters; i++)
          {
            Counter counter = (Counter) counters.elementAt(i);
            int cacheLen = counter.m_countNodes.size();

            if ((cacheLen > 0)
                    && (counter.m_countNodes.elementAt(cacheLen
                                                      - 1) == target))
            {
              count += (cacheLen + counter.m_countNodesStartCount);

              if (cacheLen > 0)
                appendBtoFList(counter.m_countNodes, m_newFound);

              m_newFound.removeAllElements();

              return count;
            }
          }
        }

        m_newFound.addElement(target);

        count++;
      }

      
      
      Counter counter = new Counter(numberElem, new NodeSetDTM(support.getDTMManager()));

      m_countersMade++;  

      appendBtoFList(counter.m_countNodes, m_newFound);
      m_newFound.removeAllElements();
      counters.addElement(counter);
    }

    return count;
  }
}
"
org.apache.xalan.xsltc.compiler.CallTemplate,6,3,0,18,40,3,1,18,5,0.4,183,1.0,1,0.918032787,0.305555556,1,6,29.33333333,5,1.6667,4,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class CallTemplate extends Instruction {
    private QName _name;

    public void display(int indent) {
	indent(indent);
	System.out.print(""CallTemplate"");
	Util.println("" name "" + _name);
	displayContents(indent + IndentIncrement);
    }
		
    public boolean hasWithParams() {
	return elementCount() > 0;
    }

    public void parseContents(Parser parser) {
	_name = parser.getQNameIgnoreDefaultNs(getAttribute(""name""));
	parseChildren(parser);
    }
		
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Template template = stable.lookupTemplate(_name);
	if (template != null) {
	    typeCheckContents(stable);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TEMPLATE_UNDEF_ERR,_name,this);
	    throw new TypeCheckError(err);
	}
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Stylesheet stylesheet = classGen.getStylesheet();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();


	if (stylesheet.hasLocalParams() || hasContents()) {
	    
	    final int push = cpg.addMethodref(TRANSLET_CLASS, 
					      PUSH_PARAM_FRAME,
					      PUSH_PARAM_FRAME_SIG);
	    il.append(classGen.loadTranslet());
	    il.append(new INVOKEVIRTUAL(push));
	    
	    translateContents(classGen, methodGen);
	}

	final String className = stylesheet.getClassName();
	
	String methodName = Util.escape(_name.toString());

	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadIterator());
	il.append(methodGen.loadHandler());
	il.append(methodGen.loadCurrentNode());
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(className,
						     methodName,
						     ""(""
						     + DOM_INTF_SIG
						     + NODE_ITERATOR_SIG
						     + TRANSLET_OUTPUT_SIG
						     + NODE_SIG
						     +"")V"")));
	

	if (stylesheet.hasLocalParams() || hasContents()) {
	    
	    final int pop = cpg.addMethodref(TRANSLET_CLASS,
					     POP_PARAM_FRAME,
					     POP_PARAM_FRAME_SIG);
	    il.append(classGen.loadTranslet());
	    il.append(new INVOKEVIRTUAL(pop));
	}
    }
} 
"
org.apache.xalan.xsltc.NodeIterator,10,1,0,1,10,45,1,0,10,1.111111111,11,0.0,0,0.0,0.4,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

import org.apache.xml.dtm.DTM;

public interface NodeIterator extends Cloneable {
    public static final int END = DTM.NULL;

    
    public int next();

    
    public NodeIterator reset();

    
    public int getLast();

    
    public int getPosition();

    
    public void setMark();

    
    public void gotoMark();

    
    public NodeIterator setStartNode(int node);

    
    public boolean isReverse();

    
    public NodeIterator cloneIterator();

    
    public void setRestartable(boolean isRestartable);

}
"
org.apache.xalan.xsltc.compiler.NameBase,5,4,3,17,21,0,3,14,5,0.25,149,1.0,2,0.96969697,0.366666667,3,14,28.4,4,1.2,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

class NameBase extends FunctionCall {

    private Expression _param = null;
    private Type       _paramType = Type.Node;

    
    public NameBase(QName fname) {
	super(fname);
    }

    
    public NameBase(QName fname, Vector arguments) {
	super(fname, arguments);
	_param = argument(0);
    }


    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	switch(argumentCount()) {
	case 0:
	    _paramType = Type.Node;
	    break;
	case 1:
	    _paramType = _param.typeCheck(stable);
	    break;
	default:
	    throw new TypeCheckError(this);
	}

	
	if ((_paramType != Type.NodeSet) &&
	    (_paramType != Type.Node) &&
	    (_paramType != Type.Reference)) {
	    throw new TypeCheckError(this);
	}

	return (_type = Type.String);
    }

    public Type getType() {
	return _type;
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	il.append(methodGen.loadDOM());
	
	
	if (argumentCount() == 0) {
	    il.append(methodGen.loadContextNode());
	}
	
	else if (_paramType == Type.Node) {
	    _param.translate(classGen, methodGen);
	}
	else if (_paramType == Type.Reference) {
	    _param.translate(classGen, methodGen);
	    il.append(new INVOKESTATIC(cpg.addMethodref
				       (BASIS_LIBRARY_CLASS,
					""referenceToNodeSet"",
					""(""
					+ OBJECT_SIG
					+ "")""
					+ NODE_ITERATOR_SIG)));
	    il.append(methodGen.nextNode());
	}
	
	else {
	    _param.translate(classGen, methodGen);
	    _param.startResetIterator(classGen, methodGen);
	    il.append(methodGen.nextNode());
	}
    }
}
"
org.apache.xalan.xsltc.compiler.util.BooleanType,21,2,0,49,56,208,17,36,19,0.95,317,0.0,0,0.622641509,0.216450216,1,2,14.04761905,4,1.4762,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.BranchInstruction;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IFGE;
import org.apache.bcel.generic.IFGT;
import org.apache.bcel.generic.IFLE;
import org.apache.bcel.generic.IFLT;
import org.apache.bcel.generic.IF_ICMPGE;
import org.apache.bcel.generic.IF_ICMPGT;
import org.apache.bcel.generic.IF_ICMPLE;
import org.apache.bcel.generic.IF_ICMPLT;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.Constants;

public final class BooleanType extends Type {
    protected BooleanType() {}

    public String toString() {
	return ""boolean"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""Z"";
    }

    public boolean isSimple() {
	return true;
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.BOOLEAN;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final BranchHandle falsec = il.append(new IFEQ(null));
	il.append(new PUSH(cpg, ""true""));
	final BranchHandle truec = il.append(new GOTO(null));
	falsec.setTarget(il.append(new PUSH(cpg, ""false"")));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	methodGen.getInstructionList().append(I2D);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new NEW(cpg.addClass(BOOLEAN_CLASS)));
	il.append(DUP_X1);
	il.append(SWAP);
	il.append(new INVOKESPECIAL(cpg.addMethodref(BOOLEAN_CLASS,
						     ""<init>"",
						     ""(Z)V"")));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	if (clazz == java.lang.Boolean.TYPE) {
	    methodGen.getInstructionList().append(NOP);
	}
        else if (clazz.isAssignableFrom(java.lang.Boolean.class)) {
            translateTo(classGen, methodGen, Type.Reference);
        }
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen, 
			      Class clazz) {
	translateTo(classGen, methodGen, clazz);
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new CHECKCAST(cpg.addClass(BOOLEAN_CLASS)));
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(BOOLEAN_CLASS,
						     BOOLEAN_VALUE, 
						     BOOLEAN_VALUE_SIG)));
    }

    public Instruction LOAD(int slot) {
	return new ILOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ISTORE(slot);
    }

    public BranchInstruction GT(boolean tozero) {
	return tozero ? (BranchInstruction) new IFGT(null) : 
	    (BranchInstruction) new IF_ICMPGT(null);
    }

    public BranchInstruction GE(boolean tozero) {
	return tozero ? (BranchInstruction) new IFGE(null) : 
	    (BranchInstruction) new IF_ICMPGE(null);
    }

    public BranchInstruction LT(boolean tozero) {
	return tozero ? (BranchInstruction) new IFLT(null) : 
	    (BranchInstruction) new IF_ICMPLT(null);
    }

    public BranchInstruction LE(boolean tozero) {
	return tozero ? (BranchInstruction) new IFLE(null) : 
	    (BranchInstruction) new IF_ICMPLE(null);
    }
}
"
org.apache.xalan.xsltc.compiler.Constants,0,1,0,6,0,0,5,1,0,2.0,203,0.0,0,0.0,0.0,0,0,0.0,0,0.0,1,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.InstructionConstants;

public interface Constants extends InstructionConstants {

    

    
    
    public final int INTERNAL        = 0;
    
    
    public final int UNSUPPORTED     = 1;
    
    
    public final int FATAL           = 2;
    
    
    public final int ERROR           = 3;
    
    
    public final int WARNING         = 4;

    public static final String EMPTYSTRING = """";

    public static final String NAMESPACE_FEATURE =
	""http:

    public static final String TRANSLET_INTF
	= ""org.apache.xalan.xsltc.Translet"";
    public static final String TRANSLET_INTF_SIG        
	= ""Lorg/apache/xalan/xsltc/Translet;"";
    
    public static final String ATTRIBUTES_SIG 
	= ""Lorg/apache/xalan/xsltc/runtime/Attributes;"";
    public static final String NODE_ITERATOR_SIG
	= ""Lorg/apache/xml/dtm/DTMAxisIterator;"";
    public static final String DOM_INTF_SIG
	= ""Lorg/apache/xalan/xsltc/DOM;"";
    public static final String DOM_IMPL_CLASS
	= ""org/apache/xalan/xsltc/DOM""; 
	public static final String SAX_IMPL_CLASS
	= ""org/apache/xalan/xsltc/DOM/SAXImpl""; 
    public static final String DOM_IMPL_SIG
	= ""Lorg/apache/xalan/xsltc/dom/SAXImpl;""; 
	public static final String SAX_IMPL_SIG
	= ""Lorg/apache/xalan/xsltc/dom/SAXImpl;"";
    public static final String DOM_ADAPTER_CLASS
	= ""org/apache/xalan/xsltc/dom/DOMAdapter"";
    public static final String DOM_ADAPTER_SIG
	= ""Lorg/apache/xalan/xsltc/dom/DOMAdapter;"";
    public static final String MULTI_DOM_CLASS
	= ""org.apache.xalan.xsltc.dom.MultiDOM"";
    public static final String MULTI_DOM_SIG
	= ""Lorg/apache/xalan/xsltc/dom/MultiDOM;"";

    public static final String STRING    
	= ""java.lang.String"";

    public static final int ACC_PUBLIC    
	= org.apache.bcel.Constants.ACC_PUBLIC;
    public static final int ACC_SUPER     
	= org.apache.bcel.Constants.ACC_SUPER;
    public static final int ACC_FINAL     
	= org.apache.bcel.Constants.ACC_FINAL;
    public static final int ACC_PRIVATE   
	= org.apache.bcel.Constants.ACC_PRIVATE;
    public static final int ACC_PROTECTED 
	= org.apache.bcel.Constants.ACC_PROTECTED;
    public static final int ACC_STATIC
	= org.apache.bcel.Constants.ACC_STATIC;

    public static final String STRING_SIG         
	= ""Ljava/lang/String;"";
    public static final String STRING_BUFFER_SIG  
	= ""Ljava/lang/StringBuffer;"";
    public static final String OBJECT_SIG         
	= ""Ljava/lang/Object;"";
    public static final String DOUBLE_SIG         
	= ""Ljava/lang/Double;"";
    public static final String INTEGER_SIG        
	= ""Ljava/lang/Integer;"";
    public static final String COLLATOR_CLASS
        = ""java/text/Collator"";
    public static final String COLLATOR_SIG
        = ""Ljava/text/Collator;"";

    public static final String NODE               
	= ""int"";
    public static final String NODE_ITERATOR      
	= ""org.apache.xml.dtm.DTMAxisIterator"";
    public static final String NODE_ITERATOR_BASE
	= ""org.apache.xml.dtm.ref.DTMAxisIteratorBase"";
    public static final String SORT_ITERATOR      
	= ""org.apache.xalan.xsltc.dom.SortingIterator"";
    public static final String SORT_ITERATOR_SIG     
	= ""Lorg.apache.xalan.xsltc.dom.SortingIterator;"";
    public static final String FORWARD_POSITION_ITERATOR      
	= ""org.apache.xalan.xsltc.dom.ForwardPositionIterator"";
    public static final String NODE_SORT_RECORD 
	= ""org.apache.xalan.xsltc.dom.NodeSortRecord"";
    public static final String NODE_SORT_FACTORY
	= ""org/apache/xalan/xsltc/dom/NodeSortRecordFactory"";
    public static final String NODE_SORT_RECORD_SIG 
	= ""Lorg/apache/xalan/xsltc/dom/NodeSortRecord;"";
    public static final String NODE_SORT_FACTORY_SIG
	= ""Lorg/apache/xalan/xsltc/dom/NodeSortRecordFactory;"";
    public static final String LOCALE_CLASS
        = ""java.util.Locale"";
    public static final String LOCALE_SIG 
	= ""Ljava/util/Locale;"";
    public static final String STRING_VALUE_HANDLER
	= ""org.apache.xalan.xsltc.runtime.StringValueHandler"";
    public static final String STRING_VALUE_HANDLER_SIG 
	= ""Lorg/apache/xalan/xsltc/runtime/StringValueHandler;"";
    public static final String OUTPUT_HANDLER
	= ""org/apache/xml/serializer/SerializationHandler"";
    public static final String OUTPUT_HANDLER_SIG
	= ""Lorg/apache/xml/serializer/SerializationHandler;"";
    public static final String FILTER_INTERFACE   
	= ""org.apache.xalan.xsltc.dom.Filter"";
    public static final String FILTER_INTERFACE_SIG   
	= ""Lorg/apache/xalan/xsltc/dom/Filter;"";
    public static final String UNION_ITERATOR_CLASS
	= ""org.apache.xalan.xsltc.dom.UnionIterator"";
    public static final String STEP_ITERATOR_CLASS
	= ""org.apache.xalan.xsltc.dom.StepIterator"";
    public static final String NTH_ITERATOR_CLASS
	= ""org.apache.xalan.xsltc.dom.NthIterator"";
    public static final String ABSOLUTE_ITERATOR
	= ""org.apache.xalan.xsltc.dom.AbsoluteIterator"";
    public static final String DUP_FILTERED_ITERATOR
	= ""org.apache.xalan.xsltc.dom.DupFilterIterator"";
    public static final String CURRENT_NODE_LIST_ITERATOR
	= ""org.apache.xalan.xsltc.dom.CurrentNodeListIterator"";
    public static final String CURRENT_NODE_LIST_FILTER
	= ""org.apache.xalan.xsltc.dom.CurrentNodeListFilter"";
    public static final String CURRENT_NODE_LIST_ITERATOR_SIG 
	= ""Lorg/apache/xalan/xsltc/dom/CurrentNodeListIterator;"";
    public static final String CURRENT_NODE_LIST_FILTER_SIG
	= ""Lorg/apache/xalan/xsltc/dom/CurrentNodeListFilter;"";
    public static final String FILTER_STEP_ITERATOR 
	= ""org.apache.xalan.xsltc.dom.FilteredStepIterator"";
    public static final String FILTER_ITERATOR 
	= ""org.apache.xalan.xsltc.dom.FilterIterator"";
    public static final String SINGLETON_ITERATOR 
	= ""org.apache.xalan.xsltc.dom.SingletonIterator"";
    public static final String MATCHING_ITERATOR 
	= ""org.apache.xalan.xsltc.dom.MatchingIterator"";
    public static final String NODE_SIG           
	= ""I"";
    public static final String GET_PARENT         
	= ""getParent"";
    public static final String GET_PARENT_SIG     
	= ""("" + NODE_SIG + "")"" + NODE_SIG;
    public static final String NEXT_SIG           
	= ""()"" + NODE_SIG;
    public static final String NEXT               
	= ""next"";
	public static final String NEXTID               
	= ""nextNodeID"";
    public static final String MAKE_NODE          
	= ""makeNode"";
    public static final String MAKE_NODE_LIST     
	= ""makeNodeList"";
    public static final String GET_UNPARSED_ENTITY_URI
        = ""getUnparsedEntityURI"";
    public static final String STRING_TO_REAL     
	= ""stringToReal"";
    public static final String STRING_TO_REAL_SIG 
	= ""("" + STRING_SIG + "")D"";
    public static final String STRING_TO_INT     
	= ""stringToInt"";
    public static final String STRING_TO_INT_SIG 
	= ""("" + STRING_SIG + "")I"";

    public static final String XSLT_PACKAGE       
	= ""org.apache.xalan.xsltc"";
    public static final String COMPILER_PACKAGE   
	= XSLT_PACKAGE + "".compiler"";
    public static final String RUNTIME_PACKAGE    
	= XSLT_PACKAGE + "".runtime"";
    public static final String TRANSLET_CLASS     
	= RUNTIME_PACKAGE + "".AbstractTranslet"";

    public static final String TRANSLET_SIG        
	= ""Lorg/apache/xalan/xsltc/runtime/AbstractTranslet;"";
    public static final String UNION_ITERATOR_SIG  
	= ""Lorg/apache/xalan/xsltc/dom/UnionIterator;"";
    public static final String TRANSLET_OUTPUT_SIG    
	= ""Lorg/apache/xml/serializer/SerializationHandler;"";
    public static final String MAKE_NODE_SIG       
	= ""(I)Lorg/w3c/dom/Node;"";
    public static final String MAKE_NODE_SIG2      
	= ""("" + NODE_ITERATOR_SIG + "")Lorg/w3c/dom/Node;"";
    public static final String MAKE_NODE_LIST_SIG  
	= ""(I)Lorg/w3c/dom/NodeList;"";
    public static final String MAKE_NODE_LIST_SIG2 
	= ""("" + NODE_ITERATOR_SIG + "")Lorg/w3c/dom/NodeList;"";
    
    public static final String STREAM_XML_OUTPUT
    = ""org.apache.xml.serializer.ToXMLStream"";
    
    public static final String OUTPUT_BASE
    = ""org.apache.xml.serializer.SerializerBase"";
    
    public static final String LOAD_DOCUMENT_CLASS
	= ""org.apache.xalan.xsltc.dom.LoadDocument"";

    public static final String KEY_INDEX_CLASS
	= ""org/apache/xalan/xsltc/dom/KeyIndex"";
    public static final String KEY_INDEX_SIG
	= ""Lorg/apache/xalan/xsltc/dom/KeyIndex;"";

    public static final String DOM_INTF
	= ""org.apache.xalan.xsltc.DOM"";
    public static final String DOM_IMPL
	= ""org.apache.xalan.xsltc.dom.SAXImpl"";
	public static final String SAX_IMPL
	= ""org.apache.xalan.xsltc.dom.SAXImpl"";
    public static final String STRING_CLASS 		
	= ""java.lang.String"";
    public static final String OBJECT_CLASS 		
	= ""java.lang.Object"";
    public static final String BOOLEAN_CLASS 		
	= ""java.lang.Boolean"";
    public static final String STRING_BUFFER_CLASS
	= ""java.lang.StringBuffer"";
    public static final String STRING_WRITER
        = ""java.io.StringWriter"";
    public static final String WRITER_SIG
        = ""Ljava/io/Writer;"";

    public static final String TRANSLET_OUTPUT_BASE       
	= ""org.apache.xalan.xsltc.TransletOutputBase"";
    
    public static final String TRANSLET_OUTPUT_INTERFACE
	= ""org.apache.xml.serializer.SerializationHandler"";
    public static final String BASIS_LIBRARY_CLASS 
	= ""org.apache.xalan.xsltc.runtime.BasisLibrary"";
    public static final String ATTRIBUTE_LIST_IMPL_CLASS 
	= ""org.apache.xalan.xsltc.runtime.AttributeListImpl"";
    public static final String DOUBLE_CLASS       
	= ""java.lang.Double"";
    public static final String INTEGER_CLASS      
	= ""java.lang.Integer"";
    public static final String RUNTIME_NODE_CLASS 
	= ""org.apache.xalan.xsltc.runtime.Node"";
    public static final String MATH_CLASS         
	= ""java.lang.Math"";

    public static final String BOOLEAN_VALUE      
	= ""booleanValue"";
    public static final String BOOLEAN_VALUE_SIG  
	= ""()Z"";
    public static final String INT_VALUE          
	= ""intValue"";
    public static final String INT_VALUE_SIG      
	= ""()I"";
    public static final String DOUBLE_VALUE       
	= ""doubleValue"";
    public static final String DOUBLE_VALUE_SIG   
	= ""()D"";

    public static final String NODE_PNAME         
	= ""node"";
    public static final String TRANSLET_OUTPUT_PNAME 
	= ""handler"";
    public static final String ITERATOR_PNAME     
	= ""iterator"";
    public static final String DOCUMENT_PNAME     
	= ""document"";
    public static final String TRANSLET_PNAME     
	= ""translet"";

    public static final String GET_NODE_NAME      
	= ""getNodeNameX"";
    public static final String CHARACTERSW        
	= ""characters"";
    public static final String GET_CHILDREN       
	= ""getChildren"";
    public static final String GET_TYPED_CHILDREN 
	= ""getTypedChildren"";
    public static final String CHARACTERS         
	= ""characters"";
    public static final String APPLY_TEMPLATES    
	= ""applyTemplates"";
    public static final String GET_NODE_TYPE      
	= ""getNodeType"";
    public static final String GET_NODE_VALUE     
	= ""getStringValueX"";
    public static final String GET_ELEMENT_VALUE  
	= ""getElementValue"";
    public static final String GET_ATTRIBUTE_VALUE  
	= ""getAttributeValue"";
    public static final String HAS_ATTRIBUTE      
	= ""hasAttribute"";
    public static final String ADD_ITERATOR       
	= ""addIterator"";
    public static final String SET_START_NODE     
	= ""setStartNode"";
    public static final String RESET     	    
	= ""reset"";

    public static final String ATTR_SET_SIG
	= ""("" + TRANSLET_OUTPUT_SIG + NODE_ITERATOR_SIG + "")V"";

    public static final String GET_NODE_NAME_SIG   
	= ""("" + NODE_SIG + "")"" + STRING_SIG;
    public static final String CHARACTERSW_SIG     
	= ""(""  + STRING_SIG + TRANSLET_OUTPUT_SIG + "")V"";
    public static final String CHARACTERS_SIG     
	= ""("" + NODE_SIG + TRANSLET_OUTPUT_SIG + "")V"";
    public static final String GET_CHILDREN_SIG
	= ""("" + NODE_SIG +"")"" + NODE_ITERATOR_SIG;
    public static final String GET_TYPED_CHILDREN_SIG
	= ""(I)"" + NODE_ITERATOR_SIG;
    public static final String GET_NODE_TYPE_SIG
	= ""()S"";
    public static final String GET_NODE_VALUE_SIG
	= ""(I)"" + STRING_SIG;
    public static final String GET_ELEMENT_VALUE_SIG
	= ""(I)"" + STRING_SIG;
    public static final String GET_ATTRIBUTE_VALUE_SIG
	= ""(II)"" + STRING_SIG;
    public static final String HAS_ATTRIBUTE_SIG
	= ""(II)Z"";
    public static final String GET_ITERATOR_SIG
	= ""()"" + NODE_ITERATOR_SIG;

    public static final String NAMES_INDEX
	= ""namesArray"";
    public static final String NAMES_INDEX_SIG
	= ""["" + STRING_SIG;
    public static final String NAMESPACE_INDEX
	= ""namespaceArray"";
    public static final String NAMESPACE_INDEX_SIG
	= ""["" + STRING_SIG;
    public static final String HASIDCALL_INDEX
        = ""_hasIdCall"";
    public static final String HASIDCALL_INDEX_SIG
        = ""Z"";

    public static final String DOM_FIELD
	= ""_dom"";
    public static final String FORMAT_SYMBOLS_FIELD	 
	= ""format_symbols"";

    public static final String ITERATOR_FIELD_SIG      
	= NODE_ITERATOR_SIG;
    public static final String NODE_FIELD		 
	= ""node"";
    public static final String NODE_FIELD_SIG		 
	= ""I"";
	
    public static final String EMPTYATTR_FIELD	     
	= ""EmptyAttributes"";
    public static final String ATTRIBUTE_LIST_FIELD    
	= ""attributeList"";
    public static final String CLEAR_ATTRIBUTES        
	= ""clear"";
    public static final String ADD_ATTRIBUTE           
	= ""addAttribute"";
    public static final String ATTRIBUTE_LIST_IMPL_SIG 
	= ""Lorg/apache/xalan/xsltc/runtime/AttributeListImpl;"";
    public static final String CLEAR_ATTRIBUTES_SIG    
	= ""()"" + ATTRIBUTE_LIST_IMPL_SIG;
    public static final String ADD_ATTRIBUTE_SIG   
	= ""("" + STRING_SIG + STRING_SIG + "")"" + ATTRIBUTE_LIST_IMPL_SIG;
	
    public static final String ADD_ITERATOR_SIG   
	= ""("" + NODE_ITERATOR_SIG +"")"" + UNION_ITERATOR_SIG;

    public static final String ORDER_ITERATOR
	= ""orderNodes"";
    public static final String ORDER_ITERATOR_SIG
	= ""(""+NODE_ITERATOR_SIG+""I)""+NODE_ITERATOR_SIG;
	
    public static final String SET_START_NODE_SIG   
	= ""("" + NODE_SIG + "")"" + NODE_ITERATOR_SIG;

    public static final String NODE_COUNTER 
	= ""org.apache.xalan.xsltc.dom.NodeCounter"";
    public static final String NODE_COUNTER_SIG 
	= ""Lorg/apache/xalan/xsltc/dom/NodeCounter;"";
    public static final String DEFAULT_NODE_COUNTER 
	= ""org.apache.xalan.xsltc.dom.DefaultNodeCounter"";
    public static final String DEFAULT_NODE_COUNTER_SIG 
	= ""Lorg/apache/xalan/xsltc/dom/DefaultNodeCounter;"";
    public static final String TRANSLET_FIELD 
	= ""translet"";
    public static final String TRANSLET_FIELD_SIG 
	= TRANSLET_SIG;

    public static final String RESET_SIG   	       
	= ""()"" + NODE_ITERATOR_SIG;
    public static final String GET_PARAMETER      
	= ""getParameter"";
    public static final String ADD_PARAMETER         
	= ""addParameter"";
    public static final String PUSH_PARAM_FRAME
	= ""pushParamFrame"";
    public static final String PUSH_PARAM_FRAME_SIG  
	= ""()V"";
    public static final String POP_PARAM_FRAME       
	= ""popParamFrame"";
    public static final String POP_PARAM_FRAME_SIG   
	= ""()V"";
    public static final String GET_PARAMETER_SIG     
	= ""("" + STRING_SIG + "")"" + OBJECT_SIG;
    public static final String ADD_PARAMETER_SIG
	= ""("" + STRING_SIG + OBJECT_SIG + ""Z)"" + OBJECT_SIG;

    public static final String STRIP_SPACE
	= ""stripSpace"";
    public static final String STRIP_SPACE_INTF
	= ""org/apache/xalan/xsltc/StripFilter"";
    public static final String STRIP_SPACE_SIG
	= ""Lorg/apache/xalan/xsltc/StripFilter;"";
    public static final String STRIP_SPACE_PARAMS
	= ""(Lorg/apache/xalan/xsltc/DOM;II)Z"";

    public static final String GET_NODE_VALUE_ITERATOR
	= ""getNodeValueIterator"";
    public static final String GET_NODE_VALUE_ITERATOR_SIG
	= ""(""+NODE_ITERATOR_SIG+""I""+STRING_SIG+""Z)""+NODE_ITERATOR_SIG;

    public static final String GET_UNPARSED_ENTITY_URI_SIG
        = ""(""+STRING_SIG+"")""+STRING_SIG;

    public static final int POSITION_INDEX = 2;
    public static final int LAST_INDEX     = 3;

    public static final String XMLNS_PREFIX = ""xmlns"";
    public static final String XMLNS_STRING = ""xmlns:"";
    public static final String XMLNS_URI 
	= ""http:
    public static final String XSLT_URI
	= ""http:
    public static final String XHTML_URI
	= ""http:
    public static final String TRANSLET_URI
	= ""http:
    public static final String REDIRECT_URI
        = ""http:
    public static final String FALLBACK_CLASS
	= ""org.apache.xalan.xsltc.compiler.Fallback"";

    public static final int RTF_INITIAL_SIZE = 32;
}
"
org.apache.xalan.xsltc.runtime.output.TransletOutputHandlerFactory,13,1,0,12,32,34,3,9,13,0.826388889,289,0.75,0,0.0,0.201923077,0,0,20.30769231,2,1.0769,0,"

package org.apache.xalan.xsltc.runtime.output;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;

import javax.xml.parsers.ParserConfigurationException;

import org.apache.xalan.xsltc.trax.SAX2DOM;
import org.apache.xml.serializer.ToHTMLSAXHandler;
import org.apache.xml.serializer.ToHTMLStream;
import org.apache.xml.serializer.ToTextSAXHandler;
import org.apache.xml.serializer.ToTextStream;
import org.apache.xml.serializer.ToUnknownStream;
import org.apache.xml.serializer.ToXMLSAXHandler;
import org.apache.xml.serializer.ToXMLStream;
import org.apache.xml.serializer.SerializationHandler;
import org.w3c.dom.Node;

import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;

public class TransletOutputHandlerFactory {

    public static final int STREAM = 0;
    public static final int SAX    = 1;
    public static final int DOM    = 2;

    private String _encoding       = ""utf-8"";
    private String _method         = null;
    private int    _outputType     = STREAM;
    private OutputStream _ostream  = System.out;
    private Writer _writer         = null;
    private Node           _node   = null;
    private int _indentNumber      = -1;
    private ContentHandler _handler    = null;
    private LexicalHandler _lexHandler = null;

    static public TransletOutputHandlerFactory newInstance() {
	return new TransletOutputHandlerFactory();
    }

    public void setOutputType(int outputType) {
	_outputType = outputType;
    }

    public void setEncoding(String encoding) {
	if (encoding != null) {
	    _encoding = encoding;
	}
    }

    public void setOutputMethod(String method) {
	_method = method;
    }

    public void setOutputStream(OutputStream ostream) {
	_ostream = ostream;
    }

    public void setWriter(Writer writer) {
	_writer = writer;
    }

    public void setHandler(ContentHandler handler) {
        _handler = handler;
    }

    public void setLexicalHandler(LexicalHandler lex) {
	_lexHandler = lex;
    }

    public void setNode(Node node) {
	_node = node;
    }

    public Node getNode() {
	return (_handler instanceof SAX2DOM) ? ((SAX2DOM)_handler).getDOM() 
	   : null;
    }

    public void setIndentNumber(int value) {
	_indentNumber = value;
    }

    public SerializationHandler getSerializationHandler()
        throws IOException, ParserConfigurationException
    {
        SerializationHandler result = null;
        switch (_outputType)
        {
            case STREAM :

                if (_method == null)
                {
                    result = new ToUnknownStream();
                }
                else if (_method.equalsIgnoreCase(""xml""))
                {

                    result = new ToXMLStream();

                }
                else if (_method.equalsIgnoreCase(""html""))
                {

                    result = new ToHTMLStream();

                }
                else if (_method.equalsIgnoreCase(""text""))
                {

                    result = new ToTextStream();

                }

                if (result != null && _indentNumber >= 0)
                {
                    result.setIndentAmount(_indentNumber);
                }

                result.setEncoding(_encoding);

                if (_writer != null)
                {
                    result.setWriter(_writer);
                }
                else
                {
                    result.setOutputStream(_ostream);
                }
                return result;

            case DOM :
                _handler = (_node != null) ? new SAX2DOM(_node) : new SAX2DOM();
                _lexHandler = (LexicalHandler) _handler;
                
            case SAX :
                if (_method == null)
                {
                    _method = ""xml""; 
                }

                if (_method.equalsIgnoreCase(""xml""))
                {

                    if (_lexHandler == null)
                    {
                        result = new ToXMLSAXHandler(_handler, _encoding);
                    }
                    else
                    {
                        result =
                            new ToXMLSAXHandler(
                                _handler,
                                _lexHandler,
                                _encoding);
                    }

                }
                else if (_method.equalsIgnoreCase(""html""))
                {

                    if (_lexHandler == null)
                    {
                        result = new ToHTMLSAXHandler(_handler, _encoding);
                    }
                    else
                    {
                        result =
                            new ToHTMLSAXHandler(
                                _handler,
                                _lexHandler,
                                _encoding);
                    }

                }
                else if (_method.equalsIgnoreCase(""text""))
                {

                    if (_lexHandler == null)
                    {
                        result = new ToTextSAXHandler(_handler, _encoding);
                    }
                    else
                    {
                        result =
                            new ToTextSAXHandler(
                                _handler,
                                _lexHandler,
                                _encoding);
                    }

                }
                return result;
        }
        return null;
    }

}
"
org.apache.xml.utils.synthetic.TestDriver,7,1,0,5,33,15,1,5,4,0.833333333,189,0.5,0,0.0,0.233333333,0,0,25.71428571,2,0.8571,1,"


package org.apache.xml.utils.synthetic;

import org.apache.xml.utils.synthetic.reflection.Method;


public class TestDriver
{

  
  public static int sampleField = 32;

  
  private boolean inTest = false;

  
  public static void main(String[] args)
  {

    
    try
    {
      System.out.println(""Proxying java.awt.Frame..."");

      Class myC = Class.forName(""java.awt.Frame"");

      myC.toSource(System.out, 0);
      System.out.println(
        ""
Proxying org.apache.xml.utils.synthetic.TestDriver..."");

      myC =
        Class.forName(""com.ibm.org.apache.xml.utils.synthetic.TestDriver"");

      myC.toSource(System.out, 0);
    }
    catch (ClassNotFoundException e)
    {
      System.out.println(""Couldn't proxy: "");
      e.printStackTrace();
    }

    
    try
    {
      System.out.println(""
Build a new beast..."");

      Class myC = Class.declareClass(
        ""com.ibm.org.apache.xml.utils.synthetic.BuildMe"");
      Class inner = myC.declareInnerClass(""island"");

      inner.addExtends(Class.forName(""java.lang.String""));

      Method m = inner.declareMethod(""getValue"");

      m.setReturnType(Class.forName(""java.lang.String""));
      m.getBody().append(""return toString();"");
      myC.toSource(System.out, 0);
    }
    catch (ClassNotFoundException e)
    {
      e.printStackTrace();
    }
    catch (SynthesisException e)
    {
      e.printStackTrace();
    }
    catch (IllegalStateException e)
    {
      System.out.println(""Unwritten function: "" + e);
      e.printStackTrace();
    }
  }

  
  public static void dumpClass(Class C)
  {

    System.out.println(""toString(): "" + C);
    System.out.println(""	isPrimitive(): "" + C.isPrimitive());
    System.out.println(""	isInterface(): "" + C.isInterface());
    System.out.println(""	isInstance(""foo""): "" + C.isInstance(""foo""));
    System.out.println(""	isArray(): "" + C.isArray());
    System.out.println(""	getRealClass(): "" + C.getRealClass());
  }

  
  public void quickcheck()
  {

    Inner a = new Inner();

    a.setTest(!a.getTest());
  }

  
  private class Inner
  {

    
    public boolean getTest()
    {
      return inTest;
    }

    
    public void setTest(boolean test)
    {
      inTest = test;
    }
  }
}
"
org.apache.xalan.templates.ElemExtensionCall,10,5,0,20,49,39,4,17,8,1.022222222,285,0.0,1,0.963709677,0.333333333,3,7,27.0,5,1.7,2,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.extensions.ExtensionHandler;
import org.apache.xalan.extensions.ExtensionsTable;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPathContext;


public class ElemExtensionCall extends ElemLiteralResult
{

  
  String m_extns;

  
  String m_lang;

  
  String m_srcURL;

  
  String m_scriptSrc;

  
  ElemExtensionDecl m_decl = null;

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_EXTENSIONCALL;
  }

  

  
  
  
  
  

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    m_extns = this.getNamespace();   
    m_decl = getElemExtensionDecl(sroot, m_extns);
    
    
    if (m_decl == null)
      sroot.getExtensionNamespacesManager().registerExtension(m_extns);
  }
 
  
  private ElemExtensionDecl getElemExtensionDecl(StylesheetRoot stylesheet,
          String namespace)
  {

    ElemExtensionDecl decl = null;
    int n = stylesheet.getGlobalImportCount();

    for (int i = 0; i < n; i++)
    {
      Stylesheet imported = stylesheet.getGlobalImport(i);

      for (ElemTemplateElement child = imported.getFirstChildElem();
              child != null; child = child.getNextSiblingElem())
      {
        if (Constants.ELEMNAME_EXTENSIONDECL == child.getXSLToken())
        {
          decl = (ElemExtensionDecl) child;

          String prefix = decl.getPrefix();
          String declNamespace = child.getNamespaceForPrefix(prefix);

          if (namespace.equals(declNamespace))
          {
            return decl;
          }
        }
      }
    }

    return null;
  }
  
  
  public void executeFallbacks(
          TransformerImpl transformer)
            throws TransformerException
  {
    for (ElemTemplateElement child = m_firstChild; child != null;
             child = child.m_nextSibling)
    {
      if (child.getXSLToken() == Constants.ELEMNAME_FALLBACK)
      {
        try
        {
          transformer.pushElemTemplateElement(child);
          ((ElemFallback) child).executeFallback(transformer);
        }
        finally
        {
          transformer.popElemTemplateElement();
        }
      }
    }

  }
  
  
  public boolean hasFallbackChildren()
  {
    for (ElemTemplateElement child = m_firstChild; child != null;
             child = child.m_nextSibling)
    {
      if (child.getXSLToken() == Constants.ELEMNAME_FALLBACK)
        return true;
    }
    
    return false;
  }


  
  public void execute(TransformerImpl transformer)
            throws TransformerException
  {

    try
    {
      transformer.getResultTreeHandler().flushPending();

      ExtensionsTable etable = transformer.getExtensionsTable();
      ExtensionHandler nsh = etable.get(m_extns);

      if (null == nsh)
      {
        if (hasFallbackChildren())
        {
          executeFallbacks(transformer);
        }
        else
        {
	  TransformerException te = new TransformerException(XSLMessages.createMessage(
	  	XSLTErrorResources.ER_CALL_TO_EXT_FAILED, new Object[]{getNodeName()}));
	  transformer.getErrorListener().fatalError(te);
        }
        
        return;
      }

      try
      {
        nsh.processElement(this.getLocalName(), this, transformer,
                           getStylesheet(), this);
      }
      catch (Exception e)
      {

	if (hasFallbackChildren())
	  executeFallbacks(transformer);
	else
	{
          if(e instanceof TransformerException)
          {
            TransformerException te = (TransformerException)e;
            if(null == te.getLocator())
              te.setLocator(this);
            
            transformer.getErrorListener().fatalError(te);            
          }
          else if (e instanceof RuntimeException)
          {
            transformer.getErrorListener().fatalError(new TransformerException(e));
          }
          else
          {
            transformer.getErrorListener().warning(new TransformerException(e));
          }
        }
      }
    }
    catch(TransformerException e)
    {
      transformer.getErrorListener().fatalError(e);
    }
  }

  
  public String getAttribute(String rawName)
  {

    AVT avt = getLiteralResultAttribute(rawName);

    if ((null != avt) && avt.getRawName().equals(rawName))
    {
      return avt.getSimpleString();
    }

    return null;
  }

  
  public String getAttribute(
          String rawName, org.w3c.dom.Node sourceNode, TransformerImpl transformer)
            throws TransformerException
  {

    AVT avt = getLiteralResultAttribute(rawName);

    if ((null != avt) && avt.getRawName().equals(rawName))
    {
      XPathContext xctxt = transformer.getXPathContext();

      return avt.evaluate(xctxt, 
            xctxt.getDTMHandleFromNode(sourceNode), 
            this);
    }

    return null;
  }
  
  
  protected boolean accept(XSLTVisitor visitor)
  {
  	return visitor.visitExtensionElement(this);
  }

  
}
"
org.apache.xml.utils.res.XResources_zh_TW,3,4,0,1,4,1,0,1,2,0.5,499,0.0,0,0.976190476,1.0,0,0,165.0,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_zh_TW extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""zh"" }, { ""help_language"", ""zh"" }, { ""language"", ""zh"" },
    { ""alphabet"",
      new char[]{ 0xff21, 0xff22, 0xff23, 0xff24, 0xff25, 0xff26, 0xff27,
                  0xff28, 0xff29, 0xff2a, 0xff2b, 0xff2c, 0xff2d, 0xff2e,
                  0xff2f, 0xff30, 0xff31, 0xff32, 0xff33, 0xff34, 0xff35,
                  0xff36, 0xff37, 0xff38, 0xff39, 0xff3a } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    { ""zero"", new char[]{ 0x96f6 } },

    
    { ""multiplier"", new long[]{ 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x5104, 0x842c, 0x4edf, 0x4f70, 0x62fe } },
    { ""digits"",
      new char[]{ 0x58f9, 0x8cb3, 0x53c3, 0x8086, 0x4f0d, 0x9678, 0x67d2,
                  0x634c, 0x7396 } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xalan.xsltc.compiler.ProcessingInstruction,4,3,0,17,26,0,0,17,3,0.333333333,123,1.0,1,0.949152542,0.4,2,6,29.5,2,1.0,1,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class ProcessingInstruction extends Instruction {

    private AttributeValue _name; 
    
    public void parseContents(Parser parser) {
	final String name  = getAttribute(""name"");
	_name = AttributeValue.create(this, name, parser);
	if (name.equals(""xml"")) {
	    reportError(this, parser, ErrorMsg.ILLEGAL_PI_ERR, ""xml"");
	}
	parseChildren(parser);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_name.typeCheck(stable);
	typeCheckContents(stable);
	return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	il.append(DUP);		
	
	
	_name.translate(classGen, methodGen);

	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       ""stringValueHandler"",
					       STRING_VALUE_HANDLER_SIG)));
	il.append(DUP);
	il.append(methodGen.storeHandler());

	
	translateContents(classGen, methodGen);

	
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_VALUE_HANDLER,
						     ""getValueOfPI"",
						     ""()"" + STRING_SIG)));
	
	final int processingInstruction =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""processingInstruction"", 
				      ""("" + STRING_SIG + STRING_SIG + "")V"");
	il.append(new INVOKEINTERFACE(processingInstruction, 3));
	
	il.append(methodGen.storeHandler());
    }
}
"
org.apache.xml.utils.StringToIntTable,8,1,0,2,12,0,2,0,8,0.523809524,217,0.833333333,0,0.0,0.583333333,0,0,25.375,4,1.875,1,"
package org.apache.xml.utils;


public class StringToIntTable
{

  public static final int INVALID_KEY = -10000;
  
  
  private int m_blocksize;

  
  private String m_map[];

  
  private int m_values[];

  
  private int m_firstFree = 0;

  
  private int m_mapSize;

  
  public StringToIntTable()
  {

    m_blocksize = 8;
    m_mapSize = m_blocksize;
    m_map = new String[m_blocksize];
    m_values = new int[m_blocksize];
  }

  
  public StringToIntTable(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new String[blocksize];
    m_values = new int[m_blocksize];
  }

  
  public final int getLength()
  {
    return m_firstFree;
  }

  
  public final void put(String key, int value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      String newMap[] = new String[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;

      int newValues[] = new int[m_mapSize];

      System.arraycopy(m_values, 0, newValues, 0, m_firstFree + 1);

      m_values = newValues;
    }

    m_map[m_firstFree] = key;
    m_values[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final int get(String key)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equals(key))
        return m_values[i];
    }

	return INVALID_KEY;
  }

  
  public final int getIgnoreCase(String key)
  {

    if (null == key)
        return INVALID_KEY;

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equalsIgnoreCase(key))
        return m_values[i];
    }

    return INVALID_KEY;
  }

  
  public final boolean contains(String key)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equals(key))
        return true;
    }

    return false;
  }
  
  
  public final String[] keys()
  {
    String [] keysArr = new String[m_firstFree];

    for (int i = 0; i < m_firstFree; i++)
    {
      keysArr[i] = m_map[i];
    }

    return keysArr;
  }  
}
"
org.apache.xpath.operations.Equals,3,3,0,6,7,3,1,5,3,2.0,40,0.0,0,0.953488372,0.555555556,2,2,12.33333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class Equals extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.equals(right) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    XObject left = m_left.execute(xctxt, true);
    XObject right = m_right.execute(xctxt, true);

    boolean result = left.equals(right) ? true : false;
	left.detach();
	right.detach();
    return result;
  }

}
"
org.apache.xalan.xsltc.compiler.LastCall,4,4,0,13,13,6,1,12,4,2.0,59,0.0,0,0.96969697,0.4375,2,4,13.75,3,1.25,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.CompareGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.TestGenerator;

final class LastCall extends FunctionCall {

    public LastCall(QName fname) {
	super(fname);
    }

    public boolean hasPositionCall() {
	return true;
    }

    public boolean hasLastCall() {
	return true;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();

	if (methodGen instanceof CompareGenerator) {
	    il.append(((CompareGenerator)methodGen).loadLastNode());
	}
	else if (methodGen instanceof TestGenerator) {
	    il.append(new ILOAD(LAST_INDEX));
	}
	else {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final int getLast = cpg.addInterfaceMethodref(NODE_ITERATOR,
							  ""getLast"", 
							  ""()I"");
	    il.append(methodGen.loadIterator());
	    il.append(new INVOKEINTERFACE(getLast, 1));
	}
    }
}
"
org.apache.xml.dtm.ref.CoroutineManager,6,1,0,4,17,0,3,1,6,0.7,183,0.0,0,0.0,0.722222222,0,0,28.5,7,1.8333,1,"
package org.apache.xml.dtm.ref;

import java.util.BitSet;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;



public class CoroutineManager
{
  
  BitSet m_activeIDs=new BitSet();

  
  static final int m_unreasonableId=1024;

  
  Object m_yield=null;

  
  final static int NOBODY=-1;
  final static int ANYBODY=-1;

  
  int m_nextCoroutine=NOBODY;
  
  
  public synchronized int co_joinCoroutineSet(int coroutineID)
  {
    if(coroutineID>=0)
      {
        if(coroutineID>=m_unreasonableId || m_activeIDs.get(coroutineID))
          return -1;
      }
    else
      {
        
        
        coroutineID=0;
        while(coroutineID<m_unreasonableId)
          {
            if(m_activeIDs.get(coroutineID))
              ++coroutineID;
            else
              break;
          }
        if(coroutineID>=m_unreasonableId)
          return -1;
      }

    m_activeIDs.set(coroutineID);
    return coroutineID;
  }

  
  public synchronized Object co_entry_pause(int thisCoroutine) throws java.lang.NoSuchMethodException
  {
    if(!m_activeIDs.get(thisCoroutine))
      throw new java.lang.NoSuchMethodException();

    while(m_nextCoroutine != thisCoroutine)
      {
        try 
          {
            wait();
          }
        catch(java.lang.InterruptedException e)
          {
            
            
          }
      }
    
    return m_yield;
  }

  
  public synchronized Object co_resume(Object arg_object,int thisCoroutine,int toCoroutine) throws java.lang.NoSuchMethodException
  {
    if(!m_activeIDs.get(toCoroutine))
      throw new java.lang.NoSuchMethodException(XMLMessages.createXMLMessage(XMLErrorResources.ER_COROUTINE_NOT_AVAIL, new Object[]{Integer.toString(toCoroutine)})); 

    
    
    m_yield=arg_object;
    m_nextCoroutine=toCoroutine;

    notify();
    while(m_nextCoroutine != thisCoroutine || m_nextCoroutine==ANYBODY || m_nextCoroutine==NOBODY)
      {
        try 
          {
            
            wait();
          }
        catch(java.lang.InterruptedException e)
          {
            
            
          }
      }

    if(m_nextCoroutine==NOBODY)
      {
        
        co_exit(thisCoroutine);
        
        
        throw new java.lang.NoSuchMethodException(XMLMessages.createXMLMessage(XMLErrorResources.ER_COROUTINE_CO_EXIT, null)); 
      }
    
    return m_yield;
  }
  
  
  public synchronized void co_exit(int thisCoroutine)
  {
    m_activeIDs.clear(thisCoroutine);
    m_nextCoroutine=NOBODY; 
    notify();
  }

  
  public synchronized void co_exit_to(Object arg_object,int thisCoroutine,int toCoroutine) throws java.lang.NoSuchMethodException
  {
    if(!m_activeIDs.get(toCoroutine))
      throw new java.lang.NoSuchMethodException(XMLMessages.createXMLMessage(XMLErrorResources.ER_COROUTINE_NOT_AVAIL, new Object[]{Integer.toString(toCoroutine)})); 
    
    
    
    m_yield=arg_object;
    m_nextCoroutine=toCoroutine;

    m_activeIDs.clear(thisCoroutine);

    notify();
  }
}
"
org.apache.xpath.functions.FuncStringLength,2,5,0,5,6,1,0,5,2,2.0,14,0.0,0,0.982142857,0.75,2,7,6.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class FuncStringLength extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(getArg0AsString(xctxt).length());
  }
}
"
org.apache.xalan.xsltc.dom.NodeSortRecord,11,1,0,7,25,3,2,6,8,0.733333333,303,0.777777778,3,0.0,0.328571429,0,0,24.90909091,5,1.2727,2,"

package org.apache.xalan.xsltc.dom;

import java.text.CollationKey;
import java.text.Collator;
import java.util.Locale;

import org.apache.xalan.xsltc.CollatorFactory;
import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;


public abstract class NodeSortRecord {
    public static int COMPARE_STRING     = 0;
    public static int COMPARE_NUMERIC    = 1;

    public static int COMPARE_ASCENDING  = 0;
    public static int COMPARE_DESCENDING = 1;

    
    protected static final Locale DEFAULT_LOCALE = Locale.getDefault();
    protected Locale _locale = Locale.getDefault();

    
    protected static final Collator DEFAULT_COLLATOR = Collator.getInstance();
    protected Collator _collator = DEFAULT_COLLATOR;
    protected CollatorFactory _collatorFactory;

    protected int   _levels = 1;
    protected int[] _compareType;
    protected int[] _sortOrder;

    private AbstractTranslet _translet = null;

    private DOM    _dom = null;
    private int    _node;           
    private int    _last = 0;       
    private int    _scanned = 0;    

    private Object[] _values; 

     
    public NodeSortRecord(int node) {
	_node = node;
	if (_locale != DEFAULT_LOCALE) {
	    _collator = Collator.getInstance(_locale);
	}
    }

    public NodeSortRecord() {
        this(0);
    }

    
    public final void initialize(int node, int last, DOM dom,
	 AbstractTranslet translet, int[] order, int[] type,
	 NodeSortRecordFactory nsrFactory) throws TransletException
    {
	_dom = dom;
	_node = node;
	_last = last;
	_translet = translet;
	_scanned = 0;

	_levels = order.length;
	_sortOrder = order;
	_compareType = type;

	_values = new Object[_levels];

	
        String colFactClassname = 
	    System.getProperty(""org.apache.xalan.xsltc.COLLATOR_FACTORY"");

        if (colFactClassname != null) {
            try {
		Object candObj = nsrFactory.loadTranslet(colFactClassname);
                _collatorFactory = (CollatorFactory)candObj;
            } 
	    catch (ClassNotFoundException e) {
		throw new TransletException(e);
            }
        } 
	else {
	    _collatorFactory = new CollatorFactoryBase();
        }
        _collator = _collatorFactory.getCollator(_locale);
    }

    
    public final int getNode() {
	return _node;
    }

    
    public final int compareDocOrder(NodeSortRecord other) {
	return _node - other._node;
    }

    
    private final CollationKey stringValue(int level) {
	
	if (_scanned <= level) {
	    
	    final String str = extractValueFromDOM(_dom, _node, level,
						   _translet, _last);
	    final CollationKey key = _collator.getCollationKey(str);
	    _values[_scanned++] = key;
	    return(key);
	}
	return((CollationKey)_values[level]);
    }
    
    private final Double numericValue(int level) {
	
	if (_scanned <= level) {
	    
	    final String str = extractValueFromDOM(_dom, _node, level,
						   _translet, _last);
	    Double num;
	    try {
		num = new Double(str);
	    }
	    
	    catch (NumberFormatException e) {
		num = new Double(Double.NEGATIVE_INFINITY);
	    }
	    _values[_scanned++] = num;
	    return(num);
	}
	return((Double)_values[level]);
    }

    
    public int compareTo(NodeSortRecord other) {
	int cmp, level;
	for (level = 0; level < _levels; level++) {
	    
	    if (_compareType[level] == COMPARE_NUMERIC) {
		final Double our = numericValue(level);
		final Double their = other.numericValue(level);
		cmp = our.compareTo(their);
	    }
	    else {
		final CollationKey our = stringValue(level);
		final CollationKey their = other.stringValue(level);
		cmp = our.compareTo(their);
	    }
	    
	    
	    if (cmp != 0) {
		return _sortOrder[level] == COMPARE_DESCENDING ? 0 - cmp : cmp;
	    }
	}
	
	return(_node - other._node);
    }

    
    public Collator getCollator() {
	return _collator;
    }

    
    public abstract String extractValueFromDOM(DOM dom, int current, int level,
					       AbstractTranslet translet,
					       int last);

}
"
org.apache.xml.utils.IntVector,20,1,1,5,22,0,5,0,20,0.342105263,497,1.0,0,0.0,0.6,0,0,23.65,4,1.75,1,"
package org.apache.xml.utils;


public class IntVector implements Cloneable
{

  
  protected int m_blocksize;

  
  protected int m_map[]; 

  
  protected int m_firstFree = 0;

  
  protected int m_mapSize;

  
  public IntVector()
  {

    m_blocksize = 32;
    m_mapSize = m_blocksize;
    m_map = new int[m_blocksize];
  }

  
  public IntVector(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new int[blocksize];
  }
  
  
  public IntVector(int blocksize, int increaseSize)
  {

    m_blocksize = increaseSize;
    m_mapSize = blocksize;
    m_map = new int[blocksize];
  }

  
  public IntVector(IntVector v)
  {
  	m_map = new int[v.m_mapSize];
    m_mapSize = v.m_mapSize;
    m_firstFree = v.m_firstFree;
  	m_blocksize = v.m_blocksize;
  	System.arraycopy(v.m_map, 0, m_map, 0, m_firstFree);
  }

  
  public final int size()
  {
    return m_firstFree;
  }
  
  
  public final void setSize(int sz)
  {
    m_firstFree = sz;
  }


  
  public final void addElement(int value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }
  
  
  public final void addElements(int value, int numberOfElements)
  {

    if ((m_firstFree + numberOfElements) >= m_mapSize)
    {
      m_mapSize += (m_blocksize+numberOfElements);

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    for (int i = 0; i < numberOfElements; i++) 
    {
      m_map[m_firstFree] = value;
      m_firstFree++;
    }
  }
  
  
  public final void addElements(int numberOfElements)
  {

    if ((m_firstFree + numberOfElements) >= m_mapSize)
    {
      m_mapSize += (m_blocksize+numberOfElements);

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }
    
    m_firstFree += numberOfElements;
  }
  

  
  public final void insertElementAt(int value, int at)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    if (at <= (m_firstFree - 1))
    {
      System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);
    }

    m_map[at] = value;

    m_firstFree++;
  }

  
  public final void removeAllElements()
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      m_map[i] = java.lang.Integer.MIN_VALUE;
    }

    m_firstFree = 0;
  }

  
  public final boolean removeElement(int s)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i] == s)
      {
        if ((i + 1) < m_firstFree)
          System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
        else
          m_map[i] = java.lang.Integer.MIN_VALUE;

        m_firstFree--;

        return true;
      }
    }

    return false;
  }

  
  public final void removeElementAt(int i)
  {

    if (i > m_firstFree)
      System.arraycopy(m_map, i + 1, m_map, i, m_firstFree);
    else
      m_map[i] = java.lang.Integer.MIN_VALUE;

    m_firstFree--;
  }

  
  public final void setElementAt(int value, int index)
  {
    m_map[index] = value;
  }

  
  public final int elementAt(int i)
  {
    return m_map[i];
  }

  
  public final boolean contains(int s)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i] == s)
        return true;
    }

    return false;
  }

  
  public final int indexOf(int elem, int index)
  {

    for (int i = index; i < m_firstFree; i++)
    {
      if (m_map[i] == elem)
        return i;
    }

    return java.lang.Integer.MIN_VALUE;
  }

  
  public final int indexOf(int elem)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i] == elem)
        return i;
    }

    return java.lang.Integer.MIN_VALUE;
  }

  
  public final int lastIndexOf(int elem)
  {

    for (int i = (m_firstFree - 1); i >= 0; i--)
    {
      if (m_map[i] == elem)
        return i;
    }

    return java.lang.Integer.MIN_VALUE;
  }
  
  
  public Object clone()
    throws CloneNotSupportedException
  {
  	return new IntVector(this);
  }
  
}
"
org.apache.xalan.lib.ExsltMath,20,2,0,2,48,188,0,2,19,0.947368421,312,1.0,0,0.1,0.25,0,0,14.25,10,2.15,1,"
package org.apache.xalan.lib;

import org.apache.xpath.NodeSet;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public class ExsltMath extends ExsltBase
{
  
  private static String PI = ""3.1415926535897932384626433832795028841971693993751"";
  private static String E  = ""2.71828182845904523536028747135266249775724709369996"";
  private static String SQRRT2 = ""1.41421356237309504880168872420969807856967187537694"";
  private static String LN2 = ""0.69314718055994530941723212145817656807550013436025"";
  private static String LN10 = ""2.302585092994046"";
  private static String LOG2E = ""1.4426950408889633"";
  private static String SQRT1_2 = ""0.7071067811865476"";
	
  
  public static double max (NodeList nl)
  {
    if (nl == null || nl.getLength() == 0)
      return Double.NaN;
      
    double m = - Double.MAX_VALUE;
    for (int i = 0; i < nl.getLength(); i++)
    {
      Node n = nl.item(i);
      double d = toNumber(n);
      if (Double.isNaN(d))
        return Double.NaN;
      else if (d > m)
        m = d;
    }
  	
    return m;  	
  }

  
  public static double min (NodeList nl)
  {
    if (nl == null || nl.getLength() == 0)
      return Double.NaN;

    double m = Double.MAX_VALUE;
    for (int i = 0; i < nl.getLength(); i++)
    {
      Node n = nl.item(i);
      double d = toNumber(n);
      if (Double.isNaN(d))
        return Double.NaN;
      else if (d < m)
        m = d;
    }
    
    return m;
  }
  
  
  public static NodeList highest (NodeList nl)
  {        
    double maxValue = max(nl);

    NodeSet highNodes = new NodeSet();
    highNodes.setShouldCacheNodes(true);    
    
    if (Double.isNaN(maxValue))
      return highNodes;  
    
    for (int i = 0; i < nl.getLength(); i++)
    {
      Node n = nl.item(i);
      double d = toNumber(n); 
      if (d == maxValue)
        highNodes.addElement(n);
    }
    return highNodes;
  }
  
  
  public static NodeList lowest (NodeList nl)
  {
    double minValue = min(nl);

    NodeSet lowNodes = new NodeSet();
    lowNodes.setShouldCacheNodes(true);
    
    if (Double.isNaN(minValue))
      return lowNodes;  
    
    for (int i = 0; i < nl.getLength(); i++)
    {
      Node n = nl.item(i);
      double d = toNumber(n); 
      if (d == minValue)
        lowNodes.addElement(n);
    }
    return lowNodes;
  }
  
  
   public static double abs(double num)
   {
     return Math.abs(num);
   }

  
   public static double acos(double num)
   {
     return Math.acos(num);
   }

  
   public static double asin(double num)
   {
     return Math.asin(num);
   }

  
   public static double atan(double num)
   {
     return Math.atan(num);
   }
  
  
   public static double atan2(double num1, double num2)
   {
     return Math.atan2(num1, num2);
   }

  
   public static double cos(double num)
   {
     return Math.cos(num);
   }

  
   public static double exp(double num)
   {
     return Math.exp(num);
   }

  
   public static double log(double num)
   {
     return Math.log(num);
   }

  
   public static double power(double num1, double num2)
   {
     return Math.pow(num1, num2);
   }

  
   public static double random()
   {
     return Math.random();
   }

  
   public static double sin(double num)
   {
     return Math.sin(num);
   }

  
   public static double sqrt(double num)
   {
     return Math.sqrt(num);
   }

  
   public static double tan(double num)
   {
     return Math.tan(num);
   }

  
   public static double constant(String name, double precision)
   {
     String value = null;
     if (name.equals(""PI""))
       value = PI;
     else if (name.equals(""E""))
       value = E;
     else if (name.equals(""SQRRT2""))
       value = SQRRT2;
     else if (name.equals(""LN2""))
       value = LN2;
     else if (name.equals(""LN10""))
       value = LN10;
     else if (name.equals(""LOG2E""))
       value = LOG2E;
     else if (name.equals(""SQRT1_2""))
       value = SQRT1_2;
     
     if (value != null)
     {
       int bits = new Double(precision).intValue();
       
       if (bits <= value.length())
         value = value.substring(0, bits);
         
       return new Double(value).doubleValue();
     }
     else
       return Double.NaN;
            
   }
      
}"
org.apache.xalan.xsltc.compiler.util.ErrorMessages,3,3,1,1,4,1,1,0,2,0.5,1248,1.0,0,0.974358974,1.0,0,0,414.6666667,1,0.3333,1,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.ListResourceBundle;

public class ErrorMessages extends ListResourceBundle {



    
    private static final String[][] m_errorMessages = { 
        {ErrorMsg.MULTIPLE_STYLESHEET_ERR,
        ""More than one stylesheet defined in the same file.""},

        
        {ErrorMsg.TEMPLATE_REDEF_ERR,
        ""Template ''{0}'' already defined in this stylesheet.""},


        
        {ErrorMsg.TEMPLATE_UNDEF_ERR,
        ""Template ''{0}'' not defined in this stylesheet.""},

        
        {ErrorMsg.VARIABLE_REDEF_ERR,
        ""Variable ''{0}'' is multiply defined in the same scope.""},

        
        {ErrorMsg.VARIABLE_UNDEF_ERR,
        ""Variable or parameter ''{0}'' is undefined.""},

        
        {ErrorMsg.CLASS_NOT_FOUND_ERR,
        ""Cannot find class ''{0}''.""},

        
        {ErrorMsg.METHOD_NOT_FOUND_ERR,
        ""Cannot find external method ''{0}'' (must be public).""},

        
        {ErrorMsg.ARGUMENT_CONVERSION_ERR,
        ""Cannot convert argument/return type in call to method ''{0}''""},

        
        {ErrorMsg.FILE_NOT_FOUND_ERR,
        ""File or URI ''{0}'' not found.""},

        
        {ErrorMsg.INVALID_URI_ERR,
        ""Invalid URI ''{0}''.""},

        
        {ErrorMsg.FILE_ACCESS_ERR,
        ""Cannot open file or URI ''{0}''.""},

        
        {ErrorMsg.MISSING_ROOT_ERR,
        ""<xsl:stylesheet> or <xsl:transform> element expected.""},

        
        {ErrorMsg.NAMESPACE_UNDEF_ERR,
        ""Namespace prefix ''{0}'' is undeclared.""},

        
        {ErrorMsg.FUNCTION_RESOLVE_ERR,
        ""Unable to resolve call to function ''{0}''.""},

        
        {ErrorMsg.NEED_LITERAL_ERR,
        ""Argument to ''{0}'' must be a literal string.""},

        
        {ErrorMsg.XPATH_PARSER_ERR,
        ""Error parsing XPath expression ''{0}''.""},

        
        {ErrorMsg.REQUIRED_ATTR_ERR,
        ""Required attribute ''{0}'' is missing.""},

        
        {ErrorMsg.ILLEGAL_CHAR_ERR,
        ""Illegal character ''{0}'' in XPath expression.""},

        
        {ErrorMsg.ILLEGAL_PI_ERR,
        ""Illegal name ''{0}'' for processing instruction.""},

        
        {ErrorMsg.STRAY_ATTRIBUTE_ERR,
        ""Attribute ''{0}'' outside of element.""},

        
        {ErrorMsg.ILLEGAL_ATTRIBUTE_ERR,
        ""Illegal attribute ''{0}''.""},

        
        {ErrorMsg.CIRCULAR_INCLUDE_ERR,
        ""Circular import/include. Stylesheet ''{0}'' already loaded.""},

        
        {ErrorMsg.RESULT_TREE_SORT_ERR,
        ""Result-tree fragments cannot be sorted (<xsl:sort> elements are "" +
        ""ignored). You must sort the nodes when creating the result tree.""},

        
        {ErrorMsg.SYMBOLS_REDEF_ERR,
        ""Decimal formatting ''{0}'' is already defined.""},

        
        {ErrorMsg.XSL_VERSION_ERR,
        ""XSL version ''{0}'' is not supported by XSLTC.""},

        
        {ErrorMsg.CIRCULAR_VARIABLE_ERR,
        ""Circular variable/parameter reference in ''{0}''.""},

        
        {ErrorMsg.ILLEGAL_BINARY_OP_ERR,
        ""Unknown operator for binary expression.""},

        
        {ErrorMsg.ILLEGAL_ARG_ERR,
        ""Illegal argument(s) for function call.""},

        
        {ErrorMsg.DOCUMENT_ARG_ERR,
        ""Second argument to document() function must be a node-set.""},

        
        {ErrorMsg.MISSING_WHEN_ERR,
        ""At least one <xsl:when> element required in <xsl:choose>.""},

        
        {ErrorMsg.MULTIPLE_OTHERWISE_ERR,
        ""Only one <xsl:otherwise> element allowed in <xsl:choose>.""},

        
        {ErrorMsg.STRAY_OTHERWISE_ERR,
        ""<xsl:otherwise> can only be used within <xsl:choose>.""},

        
        {ErrorMsg.STRAY_WHEN_ERR,
        ""<xsl:when> can only be used within <xsl:choose>.""},

        
        {ErrorMsg.WHEN_ELEMENT_ERR,
        ""Only <xsl:when> and <xsl:otherwise> elements allowed in <xsl:choose>.""},

        
        {ErrorMsg.UNNAMED_ATTRIBSET_ERR,
        ""<xsl:attribute-set> is missing the 'name' attribute.""},

        
        {ErrorMsg.ILLEGAL_CHILD_ERR,
        ""Illegal child element.""},

        
        {ErrorMsg.ILLEGAL_ELEM_NAME_ERR,
        ""You cannot call an element ''{0}''""},

        
        {ErrorMsg.ILLEGAL_ATTR_NAME_ERR,
        ""You cannot call an attribute ''{0}''""},

        
        {ErrorMsg.ILLEGAL_TEXT_NODE_ERR,
        ""Text data outside of top-level <xsl:stylesheet> element.""},

        
        {ErrorMsg.SAX_PARSER_CONFIG_ERR,
        ""JAXP parser not configured correctly""},

        
        {ErrorMsg.INTERNAL_ERR,
        ""Unrecoverable XSLTC-internal error: ''{0}''""},

        
        {ErrorMsg.UNSUPPORTED_XSL_ERR,
        ""Unsupported XSL element ''{0}''.""},

        
        {ErrorMsg.UNSUPPORTED_EXT_ERR,
        ""Unrecognised XSLTC extension ''{0}''.""},

        
        {ErrorMsg.MISSING_XSLT_URI_ERR,
        ""The input document is not a stylesheet (the XSL namespace is not ""+
        ""declared in the root element).""},

        
        {ErrorMsg.MISSING_XSLT_TARGET_ERR,
        ""Could not find stylesheet target ''{0}''.""},

        
        {ErrorMsg.NOT_IMPLEMENTED_ERR,
        ""Not implemented: ''{0}''.""},

        
        {ErrorMsg.NOT_STYLESHEET_ERR,
        ""The input document does not contain an XSL stylesheet.""},

        
        {ErrorMsg.ELEMENT_PARSE_ERR,
        ""Could not parse element ''{0}''""},

        
        {ErrorMsg.KEY_USE_ATTR_ERR,
        ""The use attribute of <key> must be node, node-set, string or number.""},

        
        {ErrorMsg.OUTPUT_VERSION_ERR,
        ""Output XML document version should be 1.0""},

        
        {ErrorMsg.ILLEGAL_RELAT_OP_ERR,
        ""Unknown operator for relational expression""},

        
        {ErrorMsg.ATTRIBSET_UNDEF_ERR,
        ""Attempting to use non-existing attribute set ''{0}''.""},

        
        {ErrorMsg.ATTR_VAL_TEMPLATE_ERR,
        ""Cannot parse attribute value template ''{0}''.""},

        
        {ErrorMsg.UNKNOWN_SIG_TYPE_ERR,
        ""Unknown data-type in signature for class ''{0}''.""},

        
        {ErrorMsg.DATA_CONVERSION_ERR,
        ""Cannot convert data-type ''{0}'' to ''{1}''.""},

        
        {ErrorMsg.NO_TRANSLET_CLASS_ERR,
        ""This Templates does not contain a valid translet class definition.""},

        
        {ErrorMsg.NO_MAIN_TRANSLET_ERR,
        ""This Templates does not contain a class with the name ''{0}''.""},

        
        {ErrorMsg.TRANSLET_CLASS_ERR,
        ""Could not load the translet class ''{0}''.""},

        {ErrorMsg.TRANSLET_OBJECT_ERR,
        ""Translet class loaded, but unable to create translet instance.""},

        
        {ErrorMsg.ERROR_LISTENER_NULL_ERR,
        ""Attempting to set ErrorListener for ''{0}'' to null""},

        
        {ErrorMsg.JAXP_UNKNOWN_SOURCE_ERR,
        ""Only StreamSource, SAXSource and DOMSource are supported by XSLTC""},

        
        {ErrorMsg.JAXP_NO_SOURCE_ERR,
        ""Source object passed to ''{0}'' has no contents.""},

        
        {ErrorMsg.JAXP_COMPILE_ERR,
        ""Could not compile stylesheet""},

        
        {ErrorMsg.JAXP_INVALID_ATTR_ERR,
        ""TransformerFactory does not recognise attribute ''{0}''.""},

        
        {ErrorMsg.JAXP_SET_RESULT_ERR,
        ""setResult() must be called prior to startDocument().""},

        
        {ErrorMsg.JAXP_NO_TRANSLET_ERR,
        ""The Transformer has no encapsulated translet object.""},

        
        {ErrorMsg.JAXP_NO_HANDLER_ERR,
        ""No defined output handler for transformation result.""},

        
        {ErrorMsg.JAXP_NO_RESULT_ERR,
        ""Result object passed to ''{0}'' is invalid.""},

        
        {ErrorMsg.JAXP_UNKNOWN_PROP_ERR,
        ""Attempting to access invalid Transformer property ''{0}''.""},

        
        {ErrorMsg.SAX2DOM_ADAPTER_ERR,
        ""Could not create SAX2DOM adapter: ''{0}''.""},

        
        {ErrorMsg.XSLTC_SOURCE_ERR,
        ""XSLTCSource.build() called without systemId being set.""},


        {ErrorMsg.COMPILE_STDIN_ERR,
        ""The -i option must be used with the -o option.""},


        
        {ErrorMsg.COMPILE_USAGE_STR,
        ""SYNOPSIS
""+
        ""   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]
""+
        ""      [-d <directory>] [-j <jarfile>] [-p <package>]
""+
        ""      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }

""+
        ""OPTIONS
""+
        ""   -o <output>    assigns the name <output> to the generated
""+
        ""                  translet. By default the translet name
""+
        ""                  is taken from the <stylesheet> name. This option
""+
        ""                  is ignored if compiling multiple stylesheets.
""+
        ""   -d <directory> specifies a destination directory for translet
""+
        ""   -j <jarfile>   packages translet classes into a jar file of the
""+
        ""                  name specified as <jarfile>
""+
        ""   -p <package>   specifies a package name prefix for all generated
""+
        ""                  translet classes.
""+
        ""   -n             enables template inlining (default behavior better
""+
        ""                  on average).
""+
        ""   -x             turns on additional debugging message output
""+
        ""   -s             disables calling System.exit
""+
        ""   -u             interprets <stylesheet> arguments as URLs
""+
        ""   -i             forces compiler to read stylesheet from stdin
""+
        ""   -v             prints the version of the compiler
""+
        ""   -h             prints this usage statement
""},

        
        {ErrorMsg.TRANSFORM_USAGE_STR,
        ""SYNOPSIS 
""+
        ""   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]
""+
        ""      [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}
""+
        ""      <class> [<param1>=<value1> ...]

""+
        ""   uses the translet <class> to transform an XML document 
""+
        ""   specified as <document>. The translet <class> is either in
""+
        ""   the user's CLASSPATH or in the optionally specified <jarfile>.
""+
        ""OPTIONS
""+
        ""   -j <jarfile>    specifies a jarfile from which to load translet
""+
        ""   -x              turns on additional debugging message output
""+
        ""   -s              disables calling System.exit
""+
        ""   -n <iterations> runs the transformation <iterations> times and
""+
        ""                   displays profiling information
""+
        ""   -u <document_url> specifies XML input document as a URL
""},



        
        {ErrorMsg.STRAY_SORT_ERR,
        ""<xsl:sort> can only be used within <xsl:for-each> or <xsl:apply-templates>.""},

        
        {ErrorMsg.UNSUPPORTED_ENCODING,
        ""Output encoding ''{0}'' is not supported on this JVM.""},

        
        {ErrorMsg.SYNTAX_ERR,
        ""Syntax error in ''{0}''.""},

        
        {ErrorMsg.CONSTRUCTOR_NOT_FOUND,
        ""Cannot find external constructor ''{0}''.""},

        
        {ErrorMsg.NO_JAVA_FUNCT_THIS_REF,
        ""The first argument to the non-static Java function ''{0}'' is not a ""+
        ""valid object reference.""},

        
        {ErrorMsg.TYPE_CHECK_ERR,
        ""Error checking type of the expression ''{0}''.""},

        
        {ErrorMsg.TYPE_CHECK_UNK_LOC_ERR,
        ""Error checking type of an expression at an unknown location.""},

        
        {ErrorMsg.ILLEGAL_CMDLINE_OPTION_ERR,
        ""The command-line option ''{0}'' is not valid.""},

        
        {ErrorMsg.CMDLINE_OPT_MISSING_ARG_ERR,
        ""The command-line option ''{0}'' is missing a required argument.""},

        
        {ErrorMsg.WARNING_PLUS_WRAPPED_MSG,
        ""WARNING:  ''{0}''
       :{1}""},

        
        {ErrorMsg.WARNING_MSG,
        ""WARNING:  ''{0}''""},

        
        {ErrorMsg.FATAL_ERR_PLUS_WRAPPED_MSG,
        ""FATAL ERROR:  ''{0}''
           :{1}""},

        
        {ErrorMsg.FATAL_ERR_MSG,
        ""FATAL ERROR:  ''{0}''""},

        
        {ErrorMsg.ERROR_PLUS_WRAPPED_MSG,
        ""ERROR:  ''{0}''
     :{1}""},

        
        {ErrorMsg.ERROR_MSG,
        ""ERROR:  ''{0}''""},
        
        
        {ErrorMsg.TRANSFORM_WITH_TRANSLET_STR,
        ""Transform using translet ''{0}'' ""},

        
        {ErrorMsg.TRANSFORM_WITH_JAR_STR,
        ""Transform using translet ''{0}'' from jar file ''{1}''""},

        
        {ErrorMsg.COULD_NOT_CREATE_TRANS_FACT,
        ""Could not create an instance of the TransformerFactory class ''{0}''.""},

        
        {ErrorMsg.COMPILER_ERROR_KEY,
        ""Compiler errors:""},

        
        {ErrorMsg.COMPILER_WARNING_KEY,
        ""Compiler warnings:""},

        
        {ErrorMsg.RUNTIME_ERROR_KEY,
        ""Translet errors:""}
    };


    public Object[][] getContents() {
        return m_errorMessages;
    }
}
"
org.apache.xalan.xsltc.compiler.KeyCall,4,4,0,33,45,0,1,32,3,0.083333333,524,1.0,4,0.96969697,0.458333333,3,7,129.0,8,2.5,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFGT;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.StringType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class KeyCall extends FunctionCall {

    
    private Expression _name;

    
    private Expression _value;

    
    private Type _valueType; 

    
    private QName _resolvedQName = null;

    
    public KeyCall(QName fname, Vector arguments) {
	super(fname, arguments);
	switch(argumentCount()) {
	case 1:
	    _name = null;
	    _value = argument(0);
	    break;
	case 2:
	    _name = argument(0);
	    _value = argument(1);
	    break;
	default:
	    _name = _value = null;
	    break;
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type returnType = super.typeCheck(stable);

	
	
	if (_name != null) {
	    final Type nameType = _name.typeCheck(stable); 

	    if (_name instanceof LiteralExpr) {
		final LiteralExpr literal = (LiteralExpr) _name;
		_resolvedQName = 
		    getParser().getQNameIgnoreDefaultNs(literal.getValue());
	    }
	    else if (nameType instanceof StringType == false) {
		_name = new CastExpr(_name, Type.String);
	    }
	}

	
	
	
	
	
	
	
	_valueType = _value.typeCheck(stable);

	if (_valueType != Type.NodeSet && _valueType != Type.String) 
	{
	    _value = new CastExpr(_value, Type.String);
	}

	return returnType;
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
						 
	final int getNodeHandle = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getNodeHandle"",
							   ""(I)""+NODE_SIG);	

	
	
	final int dupInit = cpg.addMethodref(DUP_FILTERED_ITERATOR,
					     ""<init>"",
					     ""(""+NODE_ITERATOR_SIG+"")V"");
					     
	il.append(new NEW(cpg.addClass(DUP_FILTERED_ITERATOR)));	
	il.append(DUP);
	translateCall(classGen, methodGen);
	il.append(new INVOKESPECIAL(dupInit));
	
    }

    
    private void translateCall(ClassGenerator classGen,
			      MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getNodeValue = cpg.addInterfaceMethodref(DOM_INTF,
							   GET_NODE_VALUE,
							   ""(I)""+STRING_SIG);

	
	final int getKeyIndex = cpg.addMethodref(TRANSLET_CLASS,
						 ""getKeyIndex"",
						 ""(Ljava/lang/String;)""+
						 KEY_INDEX_SIG);

	
	final int lookupId = cpg.addMethodref(KEY_INDEX_CLASS,
					      ""lookupId"",
					      ""(Ljava/lang/Object;)V"");
	final int lookupKey = cpg.addMethodref(KEY_INDEX_CLASS,
					       ""lookupKey"",
					       ""(Ljava/lang/Object;)V"");

	
	final int merge = cpg.addMethodref(KEY_INDEX_CLASS,
					   ""merge"",
					   ""(""+KEY_INDEX_SIG+"")V"");

	
	final int indexConstructor = cpg.addMethodref(TRANSLET_CLASS,
						      ""createKeyIndex"",
						      ""()""+KEY_INDEX_SIG);
						      
	
	final int keyDom = cpg.addMethodref(XSLT_PACKAGE + "".dom.KeyIndex"",
					 ""setDom"",
					 ""(""+DOM_INTF_SIG+"")V"");				 
						      
	
	
	final LocalVariableGen returnIndex =
	    methodGen.addLocalVariable(""returnIndex"",
				       Util.getJCRefType(KEY_INDEX_SIG),
				       il.getEnd(), null);

	
	final LocalVariableGen searchIndex =
	    methodGen.addLocalVariable(""searchIndex"",
				       Util.getJCRefType(KEY_INDEX_SIG),
				       il.getEnd(), null);

	
	
	
	if (_valueType == Type.NodeSet) {
	    
	    il.append(methodGen.loadCurrentNode());
	    il.append(methodGen.loadIterator());

	    
	    _value.translate(classGen, methodGen);
	    _value.startResetIterator(classGen, methodGen);
	    il.append(methodGen.storeIterator());

	    
	    il.append(classGen.loadTranslet());
	    il.append(new INVOKEVIRTUAL(indexConstructor));
	    il.append(DUP);
	    il.append(methodGen.loadDOM());
	    il.append(new INVOKEVIRTUAL(keyDom));
	    il.append(new ASTORE(returnIndex.getIndex()));

	    
	    il.append(classGen.loadTranslet());
	    if (_name == null) {
		il.append(new PUSH(cpg,""##id""));
	    }
	    else if (_resolvedQName != null) {
		il.append(new PUSH(cpg, _resolvedQName.toString()));
	    }
	    else {
		_name.translate(classGen, methodGen);
	    }

	    il.append(new INVOKEVIRTUAL(getKeyIndex));
	    il.append(new ASTORE(searchIndex.getIndex()));

	    

	    
	    
	    final BranchHandle nextNode = il.append(new GOTO(null));
	    final InstructionHandle loop = il.append(NOP);

	    
	    il.append(new ALOAD(returnIndex.getIndex()));
	    
	    
	    il.append(new ALOAD(searchIndex.getIndex()));
	    il.append(DUP);
	    il.append(methodGen.loadDOM());
	    il.append(methodGen.loadCurrentNode());
	    il.append(new INVOKEINTERFACE(getNodeValue, 2));
	    if (_name == null) {
		il.append(new INVOKEVIRTUAL(lookupId));
	    }
	    else {
		il.append(new INVOKEVIRTUAL(lookupKey));
	    }

	    
	    il.append(new INVOKEVIRTUAL(merge));
		
	    
	    nextNode.setTarget(il.append(methodGen.loadIterator()));
	    il.append(methodGen.nextNode());
	    il.append(DUP);
	    il.append(methodGen.storeCurrentNode());
	    il.append(new IFGT(loop));

	    

	    
	    il.append(methodGen.storeIterator());
	    il.append(methodGen.storeCurrentNode());

	    
	    il.append(new ALOAD(returnIndex.getIndex()));
	}
	
	
	else {
	    
	    
	    il.append(classGen.loadTranslet());
	    if (_name == null) {
		il.append(new PUSH(cpg,""##id""));
	    }
	    else if (_resolvedQName != null) {
		il.append(new PUSH(cpg, _resolvedQName.toString()));
	    }
	    else {
		_name.translate(classGen, methodGen);
	    }
	    il.append(new INVOKEVIRTUAL(getKeyIndex));

	    
	    
	    il.append(DUP);

	    _value.translate(classGen, methodGen);

	    if (_name == null) {
		il.append(new INVOKEVIRTUAL(lookupId));
	    }
	    else {
		il.append(new INVOKEVIRTUAL(lookupKey));
	    }
	}
    }
}
"
org.apache.xpath.objects.XObject,42,2,7,145,68,819,132,15,40,0.953929539,465,0.111111111,0,0.428571429,0.112244898,2,8,9.857142857,4,1.1667,1,"
package org.apache.xpath.objects;

import java.io.Serializable;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathException;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.res.XPATHErrorResources;

import org.w3c.dom.DocumentFragment;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;


public class XObject extends Expression implements Serializable, Cloneable
{

  
  protected Object m_obj;  

  
  public XObject(){}

  
  public XObject(Object obj)
  {
    m_obj = obj;
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return this;
  }

  
  public void allowDetachToRelease(boolean allowRelease){}

  
  public void detach(){}

  
  public void destruct()
  {

    if (null != m_obj)
    {
      allowDetachToRelease(true);
      detach();

      m_obj = null;
    }
  }
  
  
  public void reset()
  {
  }

  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {
    xstr().dispatchCharactersEvents(ch);
  }

  
  static public XObject create(Object val)
  {
    return XObjectFactory.create(val);
  }
  
  
  static public XObject create(Object val, XPathContext xctxt)
  {
    return XObjectFactory.create(val, xctxt);
  }

  
  public static final int CLASS_NULL = -1;

  
  public static final int CLASS_UNKNOWN = 0;

  
  public static final int CLASS_BOOLEAN = 1;

  
  public static final int CLASS_NUMBER = 2;

  
  public static final int CLASS_STRING = 3;

  
  public static final int CLASS_NODESET = 4;

  
  public static final int CLASS_RTREEFRAG = 5;

  
  public static final int CLASS_UNRESOLVEDVARIABLE = 600;

  
  public int getType()
  {
    return CLASS_UNKNOWN;
  }

  
  public String getTypeString()
  {
    return ""#UNKNOWN ("" + object().getClass().getName() + "")"";
  }

  
  public double num() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NUMBER,
          new Object[]{ getTypeString() });  

    return 0.0;
  }
  
  
  public double numWithSideEffects()  throws javax.xml.transform.TransformerException
  {
    return num();
  }

  
  public boolean bool() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NUMBER,
          new Object[]{ getTypeString() });  

    return false;
  }
  
  
  public boolean boolWithSideEffects() throws javax.xml.transform.TransformerException
  {
    return bool();
  }


  
  public XMLString xstr()
  {
    return XMLStringFactoryImpl.getFactory().newstr(str());
  }

  
  public String str()
  {
    return (m_obj != null) ? m_obj.toString() : """";
  }

  
  public String toString()
  {
    return str();
  }

  
  public int rtf(XPathContext support)
  {

    int result = rtf();

    if (DTM.NULL == result)
    {
      DTM frag = support.createDocumentFragment();

      
      frag.appendTextChild(str());

      result = frag.getDocument();
    }

    return result;
  }
  
  
  public DocumentFragment rtree(XPathContext support)
  {
    DocumentFragment docFrag = null;
    int result = rtf();

    if (DTM.NULL == result)
    {
      DTM frag = support.createDocumentFragment();

      
      frag.appendTextChild(str());

      docFrag = (DocumentFragment)frag.getNode(frag.getDocument());
    }
    else
    {
      DTM frag = support.getDTM(result);
      docFrag = (DocumentFragment)frag.getNode(frag.getDocument());
    }

    return docFrag;
  }
  
  
  
  public DocumentFragment rtree()
  {
    return null;
  }

  
  public int rtf()
  {
    return DTM.NULL;
  }

  
  public Object object()
  {
    return m_obj;
  }

  
  public DTMIterator iter() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NODELIST,
          new Object[]{ getTypeString() });  

    return null;
  }
  
  
  public XObject getFresh()
  {
    return this;
  }

  
  
  public NodeIterator nodeset() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NODELIST,
          new Object[]{ getTypeString() });  

    return null;
  }
  
  
  public NodeList nodelist() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NODELIST,
          new Object[]{ getTypeString() });  

    return null;
  }


  
  public NodeSetDTM mutableNodeset()
          throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_MUTABLENODELIST,
          new Object[]{ getTypeString() });  

    return (NodeSetDTM) m_obj;
  }

  
  public Object castToType(int t, XPathContext support)
          throws javax.xml.transform.TransformerException
  {

    Object result;

    switch (t)
    {
    case CLASS_STRING :
      result = str();
      break;
    case CLASS_NUMBER :
      result = new Double(num());
      break;
    case CLASS_NODESET :
      result = iter();
      break;
    case CLASS_BOOLEAN :
      result = new Boolean(bool());
      break;
    case CLASS_UNKNOWN :
      result = m_obj;
      break;

    
    
    
    
    default :
      error(XPATHErrorResources.ER_CANT_CONVERT_TO_TYPE,
            new Object[]{ getTypeString(),
                          Integer.toString(t) });  

      result = null;
    }

    return result;
  }

  
  public boolean lessThan(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.greaterThan(this);

    return this.num() < obj2.num();
  }

  
  public boolean lessThanOrEqual(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.greaterThanOrEqual(this);

    return this.num() <= obj2.num();
  }

  
  public boolean greaterThan(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.lessThan(this);

    return this.num() > obj2.num();
  }

  
  public boolean greaterThanOrEqual(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.lessThanOrEqual(this);

    return this.num() >= obj2.num();
  }

  
  public boolean equals(XObject obj2)
  {

    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.equals(this);

    if (null != m_obj)
    {
      return m_obj.equals(obj2.m_obj);
    }
    else
    {
      return obj2.m_obj == null;
    }
  }

  
  public boolean notEquals(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.notEquals(this);

    return !equals(obj2);
  }

  
  protected void error(String msg)
          throws javax.xml.transform.TransformerException
  {
    error(msg, null);
  }

  
  protected void error(String msg, Object[] args)
          throws javax.xml.transform.TransformerException
  {

    String fmsg = XSLMessages.createXPATHMessage(msg, args);

    
    
    
    
    
    {
      throw new XPathException(fmsg, this);
    }
  }
  
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }


  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    fsb.append(str());
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	assertion(false, ""callVisitors should not be called for this object!!!"");
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	
  	
  	
  	if(!this.equals((XObject)expr))
  		return false;
  		
  	return true;
  }

}
"
org.apache.xml.utils.SystemIDResolver,8,1,0,15,31,28,13,2,6,2.0,287,0.0,0,0.0,0.5,0,0,34.875,7,3.5,3,"
package org.apache.xml.utils;

import java.io.File;

import javax.xml.transform.TransformerException;

import org.apache.xml.utils.URI.MalformedURIException;


public class SystemIDResolver
{

  
  public static String getAbsoluteURIFromRelative(String localPath)
  {
    if (localPath == null || localPath.length() == 0)
      return """";
      
    
    
    String absolutePath = localPath;
    if (!isAbsolutePath(localPath))
    {
      try 
      {
        absolutePath = getAbsolutePathFromRelativePath(localPath);
      }
      
      catch (SecurityException se) 
      {
        return ""file:"" + localPath;
      }
    }

    String urlString;
    if (null != absolutePath)
    {
      if (absolutePath.startsWith(File.separator))
        urlString = ""file:
      else
        urlString = ""file:
    }
    else
      urlString = ""file:"" + localPath;
    
    return replaceChars(urlString);
  }
  
  
  private static String getAbsolutePathFromRelativePath(String relativePath)
  {
    return new File(relativePath).getAbsolutePath();
  }
  
  
  public static boolean isAbsoluteURI(String systemId)
  {
    
    
    int colonIndex = systemId.indexOf(':');
    if (colonIndex > 1)
      return true;
    else
      return false;
  }
  
  
  public static boolean isAbsolutePath(String systemId)
  {
    
    if (systemId.startsWith(File.separator))
      return true;
    
    
    if (systemId.length() > 2 
        && systemId.charAt(1) == ':'
        && Character.isLetter(systemId.charAt(0))
        && (systemId.charAt(2) == '\' || systemId.charAt(2) == '/'))
      return true;
    else
      return false;
  }
  
  
  private static String replaceChars(String str)
  {
    StringBuffer buf = new StringBuffer(str);
    int length = buf.length();
    for (int i = 0; i < length; i++)
    {
      char currentChar = buf.charAt(i);
      
      if (currentChar == ' ')
      {
        buf.setCharAt(i, '%');
        buf.insert(i+1, ""20"");
        length = length + 2;
        i = i + 2;
      }
      
      else if (currentChar == '\')
      {
        buf.setCharAt(i, '/');
      }
    }
    
    return buf.toString();
  }
  
  
  public static String getAbsoluteURI(String systemId)
  {
    String absoluteURI = systemId;
    if (isAbsoluteURI(systemId))
    {
      
      if (systemId.startsWith(""file:""))
      {
        String str = systemId.substring(5);
        
        
        
        if (str != null && str.startsWith(""/""))
        {
          if (str.startsWith(""
          {
            
            
            int secondColonIndex = systemId.indexOf(':', 5);
            if (secondColonIndex > 0)
            {
              String localPath = systemId.substring(secondColonIndex-1);
              try {
                if (!isAbsolutePath(localPath))
                  absoluteURI = systemId.substring(0, secondColonIndex-1) + 
                                getAbsolutePathFromRelativePath(localPath);
              }
              catch (SecurityException se) {
                return systemId;
              }
            }
          }          
        }
        else
        {
          return getAbsoluteURIFromRelative(systemId.substring(5));
        }
                
        return replaceChars(absoluteURI);
      }
      else
        return systemId;
    }
    else
      return getAbsoluteURIFromRelative(systemId);
    
  }


  
  public static String getAbsoluteURI(String urlString, String base)
          throws TransformerException
  {    
    if (base == null)
      return getAbsoluteURI(urlString);
    
    String absoluteBase = getAbsoluteURI(base);
    URI uri = null;
    try 
    {
      URI baseURI = new URI(absoluteBase);
      uri = new URI(baseURI, urlString);
    }
    catch (MalformedURIException mue)
    {
      throw new TransformerException(mue);
    }
    
    return replaceChars(uri.toString());
  }
  
}
"
org.apache.xml.dtm.ref.DTMStringPool,6,1,2,6,25,3,5,1,6,0.56,424,0.0,1,0.0,0.375,0,0,68.83333333,8,2.8333,0,"

package org.apache.xml.dtm.ref;

import java.util.Vector;

import org.apache.xml.utils.IntVector;


public class DTMStringPool
{
  Vector m_intToString;
  static final int HASHPRIME=101;
  int[] m_hashStart=new int[HASHPRIME];
  IntVector m_hashChain;
  public static final int NULL=-1;

  
  public DTMStringPool(int chainSize)
    {
      m_intToString=new Vector();
      m_hashChain=new IntVector(chainSize);
      removeAllElements();
      
      
      stringToIndex("""");
    }
  
  public DTMStringPool()
    {
      this(512);	
    }
    
  public void removeAllElements()
    {
      m_intToString.removeAllElements();
      for(int i=0;i<HASHPRIME;++i)
        m_hashStart[i]=NULL;
      m_hashChain.removeAllElements();
    }

   
  public String indexToString(int i)
    throws java.lang.ArrayIndexOutOfBoundsException
    {
      if(i==NULL) return null;
      return (String) m_intToString.elementAt(i);
    }

   
  public int stringToIndex(String s)
    {
      if(s==null) return NULL;
      
      int hashslot=s.hashCode()%HASHPRIME;
      if(hashslot<0) hashslot=-hashslot;

      
      int hashlast=m_hashStart[hashslot];
      int hashcandidate=hashlast;
      while(hashcandidate!=NULL)
        {
          if(m_intToString.elementAt(hashcandidate).equals(s))
            return hashcandidate;

          hashlast=hashcandidate;
          hashcandidate=m_hashChain.elementAt(hashcandidate);
        }
      
      
      int newIndex=m_intToString.size();
      m_intToString.addElement(s);

      m_hashChain.addElement(NULL);	
      if(hashlast==NULL)  
        m_hashStart[hashslot]=newIndex;
      else 
        m_hashChain.setElementAt(newIndex,hashlast);

      return newIndex;
    }

  
  public static void main(String[] args)
  {
    String[] word={
      ""Zero"",""One"",""Two"",""Three"",""Four"",""Five"",
      ""Six"",""Seven"",""Eight"",""Nine"",""Ten"",
      ""Eleven"",""Twelve"",""Thirteen"",""Fourteen"",""Fifteen"",
      ""Sixteen"",""Seventeen"",""Eighteen"",""Nineteen"",""Twenty"",
      ""Twenty-One"",""Twenty-Two"",""Twenty-Three"",""Twenty-Four"",
      ""Twenty-Five"",""Twenty-Six"",""Twenty-Seven"",""Twenty-Eight"",
      ""Twenty-Nine"",""Thirty"",""Thirty-One"",""Thirty-Two"",
      ""Thirty-Three"",""Thirty-Four"",""Thirty-Five"",""Thirty-Six"",
      ""Thirty-Seven"",""Thirty-Eight"",""Thirty-Nine""};

    DTMStringPool pool=new DTMStringPool();

    System.out.println(""If no complaints are printed below, we passed initial test."");

    for(int pass=0;pass<=1;++pass)
      {
        int i;

        for(i=0;i<word.length;++i)
          {
            int j=pool.stringToIndex(word[i]);
            if(j!=i)
              System.out.println(""	Mismatch populating pool: assigned ""+
                                 j+"" for create ""+i);
          }

        for(i=0;i<word.length;++i)
          {
            int j=pool.stringToIndex(word[i]);
            if(j!=i)
              System.out.println(""	Mismatch in stringToIndex: returned ""+
                                 j+"" for lookup ""+i);
          }

        for(i=0;i<word.length;++i)
          {
            String w=pool.indexToString(i);
            if(!word[i].equals(w))
              System.out.println(""	Mismatch in indexToString: returned""+
                                 w+"" for lookup ""+i);
          }
        
        pool.removeAllElements();
        
        System.out.println(""
Pass ""+pass+"" complete
"");
      } 
  }
}
"
org.apache.xpath.functions.FuncNot,2,4,0,5,5,1,0,5,2,2.0,15,0.0,0,0.979591837,0.75,1,6,6.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class FuncNot extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return m_arg0.execute(xctxt).bool() ? XBoolean.S_FALSE : XBoolean.S_TRUE;
  }
}
"
org.apache.xalan.templates.XMLNSDecl,4,1,0,2,5,0,2,0,4,0.666666667,28,1.0,0,0.0,0.5,0,0,5.25,1,0.75,0,"
package org.apache.xalan.templates;


public class XMLNSDecl
        implements java.io.Serializable 
{

  
  public XMLNSDecl(String prefix, String uri, boolean isExcluded)
  {

    m_prefix = prefix;
    m_uri = uri;
    m_isExcluded = isExcluded;
  }

  
  private String m_prefix;

  
  public String getPrefix()
  {
    return m_prefix;
  }

  
  private String m_uri;

  
  public String getURI()
  {
    return m_uri;
  }

  
  private boolean m_isExcluded;

  
  public boolean getIsExcluded()
  {
    return m_isExcluded;
  }
}
"
org.apache.xpath.functions.FuncSystemProperty,5,4,0,8,37,6,0,8,3,0.65,253,0.4,0,0.941176471,0.4375,2,8,48.6,4,1.2,1,"
package org.apache.xpath.functions;

import java.io.BufferedInputStream;
import java.io.InputStream;
import java.util.Properties;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.res.XPATHErrorResources;


public class FuncSystemProperty extends FunctionOneArg
{

  
  static String XSLT_PROPERTIES = ""org/apache/xalan/res/XSLTInfo.properties"";
	
	
  private static final Class[] NO_CLASSES = new Class[0];

  
  private static final Object[] NO_OBJS = new Object[0];


  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String fullName = m_arg0.execute(xctxt).str();
    int indexOfNSSep = fullName.indexOf(':');
    String result;
    String propName = """";
    
    
    Properties xsltInfo = new Properties();

    loadPropertyFile(XSLT_PROPERTIES, xsltInfo);

    if (indexOfNSSep > 0)
    {
      String prefix = (indexOfNSSep >= 0)
                      ? fullName.substring(0, indexOfNSSep) : """";
      String namespace;

      namespace = xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);
      propName = (indexOfNSSep < 0)
                 ? fullName : fullName.substring(indexOfNSSep + 1);

      if (namespace.startsWith(""http:
              || namespace.equals(""http:
      {
        result = xsltInfo.getProperty(propName);

        if (null == result)
        {
          warn(xctxt, XPATHErrorResources.WG_PROPERTY_NOT_SUPPORTED,
               new Object[]{ fullName });  

          return XString.EMPTYSTRING;
        }
      }
      else
      {
        warn(xctxt, XPATHErrorResources.WG_DONT_DO_ANYTHING_WITH_NS,
             new Object[]{ namespace,
                           fullName });  

        try
        {
          result = System.getProperty(propName);

          if (null == result)
          {

            
            return XString.EMPTYSTRING;
          }
        }
        catch (SecurityException se)
        {
          warn(xctxt, XPATHErrorResources.WG_SECURITY_EXCEPTION,
               new Object[]{ fullName });  

          return XString.EMPTYSTRING;
        }
      }
    }
    else
    {
      try
      {
        result = System.getProperty(fullName);

        if (null == result)
        {

          
          return XString.EMPTYSTRING;
        }
      }
      catch (SecurityException se)
      {
        warn(xctxt, XPATHErrorResources.WG_SECURITY_EXCEPTION,
             new Object[]{ fullName });  

        return XString.EMPTYSTRING;
      }
    }

    if (propName.equals(""version"") && result.length() > 0)
    {
      try
      {
        
        return new XNumber(1.0);
      }
      catch (Exception ex)
      {
        return new XString(result);
      }
    }
    else
      return new XString(result);
  }

  
  public void loadPropertyFile(String file, Properties target)
  {

    InputStream is = null;

    try
    {
      try {
        java.lang.reflect.Method getCCL = Thread.class.getMethod(""getContextClassLoader"", NO_CLASSES);
        if (getCCL != null) {
          ClassLoader contextClassLoader = (ClassLoader) getCCL.invoke(Thread.currentThread(), NO_OBJS);
          is = contextClassLoader.getResourceAsStream(file); 
        }
      }
      catch (Exception e) {}

      if (is == null) {
        
        
        
        is = FuncSystemProperty.class.getResourceAsStream(""/"" + file); 
      }

      
      BufferedInputStream bis = new BufferedInputStream(is);

      target.load(bis);  
      bis.close();  
    }
    catch (Exception ex)
    {
      
      throw new org.apache.xml.utils.WrappedRuntimeException(ex);
    }
  }
}
"
org.apache.xalan.xsltc.cmdline.Compile,4,1,0,4,40,0,0,4,3,0.333333333,240,1.0,0,0.0,0.333333333,0,0,58.0,12,3.75,0,"

package org.apache.xalan.xsltc.cmdline;

import java.io.File;
import java.net.URL;
import java.util.Vector;

import org.apache.xalan.xsltc.cmdline.getopt.GetOpt;
import org.apache.xalan.xsltc.cmdline.getopt.GetOptsException;
import org.apache.xalan.xsltc.compiler.XSLTC;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;

public final class Compile {

    
    private static int VERSION_MAJOR = 1;
    private static int VERSION_MINOR = 4;
    private static int VERSION_DELTA = 0;
 

    
    
    
    
    private static boolean _allowExit = true;

    public static void printUsage() {
        StringBuffer vers = new StringBuffer(""XSLTC version "" + 
	    VERSION_MAJOR + ""."" + VERSION_MINOR + 
	    ((VERSION_DELTA > 0) ? ("".""+VERSION_DELTA) : ("""")));
	System.err.println(vers + ""
"" + 
		new ErrorMsg(ErrorMsg.COMPILE_USAGE_STR));
	if (_allowExit) System.exit(-1);
    }

    
    public static void main(String[] args) {
	try {
	    boolean inputIsURL = false;
	    boolean useStdIn = false;
	    boolean classNameSet = false;
	    final GetOpt getopt = new GetOpt(args, ""o:d:j:p:uxhsinv"");
	    if (args.length < 1) printUsage();

	    final XSLTC xsltc = new XSLTC();
	    xsltc.init();

	    int c;
	    while ((c = getopt.getNextOption()) != -1) {
		switch(c) {
		case 'i':
		    useStdIn = true;
		    break;
		case 'o':
		    xsltc.setClassName(getopt.getOptionArg());
		    classNameSet = true;
		    break;
		case 'd':
		    xsltc.setDestDirectory(getopt.getOptionArg());
		    break;
		case 'p':
		    xsltc.setPackageName(getopt.getOptionArg());
		    break;
		case 'j':  
		    xsltc.setJarFileName(getopt.getOptionArg());
		    break;
		case 'x':
		    xsltc.setDebug(true);
		    break;
		case 'u':
		    inputIsURL = true;
		    break;
		case 's':
		    _allowExit = false;
		    break;
		case 'n':
		    xsltc.setTemplateInlining(true);	
		    break;
		case 'v':
		    
		case 'h':
		default:
		    printUsage();
		    break; 
		}
	    }

	    boolean compileOK;

	    if (useStdIn) {
		if (!classNameSet) {
		    System.err.println(new ErrorMsg(ErrorMsg.COMPILE_STDIN_ERR));
		    if (_allowExit) System.exit(-1);
		}
		compileOK = xsltc.compile(System.in, xsltc.getClassName());
	    }
	    else {
		
		final String[] stylesheetNames = getopt.getCmdArgs();
		final Vector   stylesheetVector = new Vector();
		for (int i = 0; i < stylesheetNames.length; i++) {
		    final String name = stylesheetNames[i];
		    URL url;
		    if (inputIsURL)
			url = new URL(name);
		    else
			url = (new File(name)).toURL();
		    stylesheetVector.addElement(url);
		}
		compileOK = xsltc.compile(stylesheetVector);
	    }

	    
	    if (compileOK) {
		xsltc.printWarnings();
		if (xsltc.getJarFileName() != null) xsltc.outputToJar();
		if (_allowExit) System.exit(0);
	    }
	    else {
		xsltc.printWarnings();
		xsltc.printErrors();
		if (_allowExit) System.exit(-1);
	    }
	}
	catch (GetOptsException ex) {
	    System.err.println(ex);
	    printUsage(); 
	}
	catch (Exception e) {
	    e.printStackTrace();
	    if (_allowExit) System.exit(-1);
	}
    }

}
"
org.apache.xalan.transformer.XSLInfiniteLoopException,2,1,0,0,3,1,0,0,1,2.0,7,0.0,0,0.0,1.0,0,0,2.5,1,0.5,1,"
package org.apache.xalan.transformer;


class XSLInfiniteLoopException
{

  
  XSLInfiniteLoopException()
  {
    super();
  }

  
  public String getMessage()
  {
    return ""Processing Terminated."";
  }
}
"
org.apache.xml.utils.CharKey,5,1,0,1,6,0,1,0,5,0.25,32,1.0,0,0.0,0.533333333,1,1,5.2,2,0.8,1,"
package org.apache.xml.utils;


public class CharKey extends Object
{

  
  private char m_char;

  
  public CharKey(char key)
  {
    m_char = key;
  }
  
  
  public CharKey()
  {
  }
  
  
  public final void setChar(char c)
  {
    m_char = c;
  }



  
  public final int hashCode()
  {
    return (int)m_char;
  }

  
  public final boolean equals(Object obj)
  {
    return ((CharKey)obj).m_char == m_char;
  }
}"
org.apache.xalan.xsltc.compiler.util.Type,33,1,10,113,53,526,104,20,32,0.998046875,300,0.0,16,0.0,0.234375,0,0,7.606060606,2,1.0,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.BranchInstruction;
import org.apache.bcel.generic.Instruction;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.NodeTest;

public abstract class Type implements Constants {
    public static final Type Int        = new IntType();
    public static final Type Real       = new RealType();
    public static final Type Boolean    = new BooleanType();
    public static final Type NodeSet    = new NodeSetType();
    public static final Type String     = new StringType();
    public static final Type ResultTree = new ResultTreeType();
    public static final Type Reference  = new ReferenceType();
    public static final Type Void       = new VoidType();
    public static final Type Object     = new ObjectType();

    public static final Type Node       = new NodeType(NodeTest.ANODE);
    public static final Type Root       = new NodeType(NodeTest.ROOT);
    public static final Type Element    = new NodeType(NodeTest.ELEMENT);
    public static final Type Attribute  = new NodeType(NodeTest.ATTRIBUTE);
    public static final Type Text       = new NodeType(NodeTest.TEXT);
    public static final Type Comment    = new NodeType(NodeTest.COMMENT);
    public static final Type Processing_Instruction = new NodeType(NodeTest.PI);

    
    public abstract String toString();

    
    public abstract boolean identicalTo(Type other);

    
    public boolean isNumber() {
	return false;
    }

    
    public boolean implementedAsMethod() {
	return false;
    }

    
    public boolean isSimple() {
	return false;
    }

    public abstract org.apache.bcel.generic.Type toJCType();

    
    public int distanceTo(Type type) {
	return type == this ? 0 : Integer.MAX_VALUE;
    }

    
    public abstract String toSignature();

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    toString(), type.toString());
	classGen.getParser().reportError(Constants.FATAL, err);
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     Type type) {
	FlowList fl = null;
	if (type == Type.Boolean) {
	    fl = translateToDesynthesized(classGen, methodGen,
					  (BooleanType)type);
	}
	else {
	    translateTo(classGen, methodGen, type);
	}
	return fl;
    }

     
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    toString(), type.toString());
	classGen.getParser().reportError(Constants.FATAL, err);
	return null;
    }

     
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    toString(), clazz.getClass().toString());
	classGen.getParser().reportError(Constants.FATAL, err);
    }

     
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen,
			      Class clazz) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    clazz.getClass().toString(), toString());
	classGen.getParser().reportError(Constants.FATAL, err);
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    toString(), ""[""+toString()+""]"");
	classGen.getParser().reportError(Constants.FATAL, err);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    ""[""+toString()+""]"", toString());
	classGen.getParser().reportError(Constants.FATAL, err);
    }

    
    public String getClassName() {
	return(EMPTYSTRING);
    }

    public Instruction ADD() {
	return null;		
    }

    public Instruction SUB() {
	return null;		
    }

    public Instruction MUL() {
	return null;		
    }

    public Instruction DIV() {
	return null;		
    }

    public Instruction REM() {
	return null;		
    }

    public Instruction NEG() {
	return null;		
    }

    public Instruction LOAD(int slot) {
	return null;		
    }
	
    public Instruction STORE(int slot) {
	return null;		
    }

    public Instruction POP() {
	return POP;
    }

    public BranchInstruction GT(boolean tozero) {
	return null;		
    }

    public BranchInstruction GE(boolean tozero) {
	return null;		
    }

    public BranchInstruction LT(boolean tozero) {
	return null;		
    }

    public BranchInstruction LE(boolean tozero) {
	return null;		
    }

    public Instruction CMP(boolean less) {
	return null;		
    }
	
    public Instruction DUP() {
	return DUP;	
    }
}
"
org.apache.xml.utils.DOMBuilder,30,1,0,4,64,223,2,2,28,0.634482759,460,0.6,0,0.0,0.2,0,0,14.16666667,5,1.0667,3,"
package org.apache.xml.utils;

import java.util.Stack;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;

import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.Text;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.ext.LexicalHandler;

public class DOMBuilder
        implements ContentHandler, LexicalHandler
{

  
  public Document m_doc;

  
  protected Node m_currentNode = null;

  
  public DocumentFragment m_docFrag = null;

  
  protected Stack m_elemStack = new Stack();

  
  public DOMBuilder(Document doc, Node node)
  {
    m_doc = doc;
    m_currentNode = node;
  }

  
  public DOMBuilder(Document doc, DocumentFragment docFrag)
  {
    m_doc = doc;
    m_docFrag = docFrag;
  }

  
  public DOMBuilder(Document doc)
  {
    m_doc = doc;
  }

  
  public Node getRootNode()
  {
    return (null != m_docFrag) ? (Node) m_docFrag : (Node) m_doc;
  }

  
  public Node getCurrentNode()
  {
    return m_currentNode;
  }

  
  public java.io.Writer getWriter()
  {
    return null;
  }

  
  protected void append(Node newNode) throws org.xml.sax.SAXException
  {

    Node currentNode = m_currentNode;

    if (null != currentNode)
    {
      currentNode.appendChild(newNode);

      
    }
    else if (null != m_docFrag)
    {
      m_docFrag.appendChild(newNode);
    }
    else
    {
      boolean ok = true;
      short type = newNode.getNodeType();

      if (type == Node.TEXT_NODE)
      {
        String data = newNode.getNodeValue();

        if ((null != data) && (data.trim().length() > 0))
        {
          throw new org.xml.sax.SAXException(
            XMLMessages.createXMLMessage(
              XMLErrorResources.ER_CANT_OUTPUT_TEXT_BEFORE_DOC, null));  
        }

        ok = false;
      }
      else if (type == Node.ELEMENT_NODE)
      {
        if (m_doc.getDocumentElement() != null)
        {
          throw new org.xml.sax.SAXException(
            XMLMessages.createXMLMessage(
              XMLErrorResources.ER_CANT_HAVE_MORE_THAN_ONE_ROOT, null));  
        }
      }

      if (ok)
        m_doc.appendChild(newNode);
    }
  }

  
  public void setDocumentLocator(Locator locator)
  {

    
  }

  
  public void startDocument() throws org.xml.sax.SAXException
  {

    
  }

  
  public void endDocument() throws org.xml.sax.SAXException
  {

    
  }

  
  public void startElement(
          String ns, String localName, String name, Attributes atts)
            throws org.xml.sax.SAXException
  {

    Element elem;

	
	
    if ((null == ns) || (ns.length() == 0))
      elem = m_doc.createElementNS(null,name);
    else
      elem = m_doc.createElementNS(ns, name);

    append(elem);

    try
    {
      int nAtts = atts.getLength();
  
      if (0 != nAtts)
      {
        for (int i = 0; i < nAtts; i++)
        {
  
          
          
          if (atts.getType(i).equalsIgnoreCase(""ID""))
            setIDAttribute(atts.getValue(i), elem);
  
          String attrNS = atts.getURI(i);
          
          if("""".equals(attrNS))
            attrNS = null; 
  
          
          
          
          String attrQName = atts.getQName(i);
          
          elem.setAttributeNS(attrNS,attrQName, atts.getValue(i));
        }
      }
      
      
  
      m_elemStack.push(elem);
  
      m_currentNode = elem;
      
      
    }
    catch(java.lang.Exception de)
    {
      
      throw new org.xml.sax.SAXException(de);
    }
    
  }

  
  public void endElement(String ns, String localName, String name)
          throws org.xml.sax.SAXException
  {
    m_elemStack.pop();
    m_currentNode = m_elemStack.isEmpty() ? null : (Node)m_elemStack.peek();
  }

  
  public void setIDAttribute(String id, Element elem)
  {

    
  }

  
  public void characters(char ch[], int start, int length) throws org.xml.sax.SAXException
  {
    if(isOutsideDocElem()
       && org.apache.xml.utils.XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return;  

    if (m_inCData)
    {
      cdata(ch, start, length);

      return;
    }

    String s = new String(ch, start, length);
    Text text = m_doc.createTextNode(s);

    append(text);
  }

  
  public void charactersRaw(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {
    if(isOutsideDocElem()  
       && org.apache.xml.utils.XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return;  


    String s = new String(ch, start, length);

    append(m_doc.createProcessingInstruction(""xslt-next-is-raw"",
                                             ""formatter-to-dom""));
    append(m_doc.createTextNode(s));
  }

  
  public void startEntity(String name) throws org.xml.sax.SAXException
  {

    
    
  }

  
  public void endEntity(String name) throws org.xml.sax.SAXException{}

  
  public void entityReference(String name) throws org.xml.sax.SAXException
  {
    append(m_doc.createEntityReference(name));
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {
    if(isOutsideDocElem())
      return;  

    String s = new String(ch, start, length);

    append(m_doc.createTextNode(s));
  }
  
  
   private boolean isOutsideDocElem()
   {
      return (null == m_docFrag) && m_elemStack.size() == 0 && (null == m_currentNode || m_currentNode.getNodeType() == Node.DOCUMENT_NODE);
   }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {
    append(m_doc.createProcessingInstruction(target, data));
  }

  
  public void comment(char ch[], int start, int length) throws org.xml.sax.SAXException
  {
    append(m_doc.createComment(new String(ch, start, length)));
  }

  
  protected boolean m_inCData = false;

  
  public void startCDATA() throws org.xml.sax.SAXException
  {
    m_inCData = true;
  }

  
  public void endCDATA() throws org.xml.sax.SAXException
  {
    m_inCData = false;
  }

  
  public void cdata(char ch[], int start, int length) throws org.xml.sax.SAXException
  {
    if(isOutsideDocElem()  
       && org.apache.xml.utils.XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return;  

    String s = new String(ch, start, length);

    append(m_doc.createCDATASection(s));
  }

  
  public void startDTD(String name, String publicId, String systemId)
          throws org.xml.sax.SAXException
  {

    
  }

  
  public void endDTD() throws org.xml.sax.SAXException
  {

    
  }

  
  public void startPrefixMapping(String prefix, String uri)
          throws org.xml.sax.SAXException
  {

    
  }

  
  public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException{}

  
  public void skippedEntity(String name) throws org.xml.sax.SAXException{}
}
"
org.apache.xalan.xsltc.compiler.util.TestGenerator,13,5,0,12,20,54,3,9,12,0.9,119,1.0,0,0.926174497,0.21875,2,5,7.384615385,2,0.9231,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.Type;

public final class TestGenerator extends MethodGenerator {
    private static int CONTEXT_NODE_INDEX = 1;
    private static int CURRENT_NODE_INDEX = 4;
    private static int ITERATOR_INDEX = 6;

    private Instruction _aloadDom;
    private final Instruction _iloadCurrent;
    private final Instruction _iloadContext;
    private final Instruction _istoreCurrent;
    private final Instruction _istoreContext;
    private final Instruction _astoreIterator;
    private final Instruction _aloadIterator;

    public TestGenerator(int access_flags, Type return_type,
			 Type[] arg_types, String[] arg_names,
			 String method_name, String class_name,
			 InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
	
	_iloadCurrent  = new ILOAD(CURRENT_NODE_INDEX);
	_istoreCurrent = new ISTORE(CURRENT_NODE_INDEX);
	_iloadContext  = new ILOAD(CONTEXT_NODE_INDEX);
	_istoreContext  = new ILOAD(CONTEXT_NODE_INDEX);
	_astoreIterator = new ASTORE(ITERATOR_INDEX);
	_aloadIterator  = new ALOAD(ITERATOR_INDEX);
    }

    public int getHandlerIndex() {
	return INVALID_INDEX;		
    }

    public int getIteratorIndex() {
	return ITERATOR_INDEX;		
    }

    public void setDomIndex(int domIndex) {
	_aloadDom = new ALOAD(domIndex);
    }

    public Instruction loadDOM() {
	return _aloadDom;
    }

    public Instruction loadCurrentNode() {
	return _iloadCurrent;
    }

    
    public Instruction loadContextNode() {
	return _iloadContext;
    }

    public Instruction storeContextNode() {
	return _istoreContext;
    }

    public Instruction storeCurrentNode() {
	return _istoreCurrent;
    }

    public Instruction storeIterator() {
	return _astoreIterator;
    }
    
    public Instruction loadIterator() {
	return _aloadIterator;
    }

    public int getLocalIndex(String name) {
	if (name.equals(""current"")) {
	    return CURRENT_NODE_INDEX;
	}
	else {
	    return super.getLocalIndex(name);
	}
    }
}
"
org.apache.xml.utils.WrongParserException,1,4,0,0,2,0,0,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,1,"
package org.apache.xml.utils;


public class WrongParserException extends RuntimeException
{

  
  public WrongParserException(String message)
  {
    super(message);
  }
}
"
org.apache.xpath.res.XPATHErrorResources_it,4,4,0,1,11,4,0,1,2,1.285714286,1903,0.0,0,0.953488372,0.5,2,2,471.25,2,0.75,1,"
package org.apache.xpath.res;

import java.util.Locale;



public class XPATHErrorResources_it extends XPATHErrorResources
{


 
 public static final int MAX_CODE = 108;  

 
 public static final int MAX_WARNING = 11;  

 
 public static final int MAX_OTHERS = 20;

 
 public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


 
  public static final Object[][] contents = {

 
 


 {
   ""ERROR0000"", ""{0}""},


 
 


 {
   ER_CURRENT_NOT_ALLOWED_IN_MATCH,
     ""La funzione current() non è consentita in un criterio di corrispondenza.""},


 
 


 {
   ER_CURRENT_TAKES_NO_ARGS,
     ""La funzione current() non accetta argomenti.""},


 
 


 {
   ER_DOCUMENT_REPLACED,
     ""L'implementazione della funzione document() è stata sostituita da org.apache.xalan.xslt.FuncDocument.""},


 
 


 {
   ER_CONTEXT_HAS_NO_OWNERDOC,
     ""Il contesto non ha un documento proprietario.""},


 
 


 {
   ER_LOCALNAME_HAS_TOO_MANY_ARGS,
     ""local-name() ha troppi argomenti.""},


 
 


 {
   ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
     ""namespace-uri() ha troppi argomenti.""},


 
 


 {
   ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
     ""normalize-space() ha troppi argomenti.""},


 
 


 {
   ER_NUMBER_HAS_TOO_MANY_ARGS,
     ""number() ha troppi argomenti.""},


 
 


 {
   ER_NAME_HAS_TOO_MANY_ARGS, ""name() ha troppi argomenti.""},


 
 


 {
   ER_STRING_HAS_TOO_MANY_ARGS,
     ""string() ha troppi argomenti.""},


 
 


 {
   ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
     ""string-length() ha troppi argomenti.""},


 
 


 {
   ER_TRANSLATE_TAKES_3_ARGS,
     ""La funzione translate() richiede tre argomenti.""},


 
 


 {
   ER_UNPARSEDENTITYURI_TAKES_1_ARG,
     ""La funzione unparsed-entity-uri richiede un argomento.""},


 
 


 {
   ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
     ""Asse namespace non ancora implementato.""},


 
 


 {
   ER_UNKNOWN_AXIS, ""Asse sconosciuto: {0}""},


 
 


 {
   ER_UNKNOWN_MATCH_OPERATION, ""Operazione di corrispondenza sconosciuta.""},


 
 


 {
   ER_INCORRECT_ARG_LENGTH,
     ""La lunghezza argomento del test di nodo di processing-instruction() non è corretta.""},


 
 


 {
   ER_CANT_CONVERT_TO_NUMBER,
     ""Impossibile convertire {0} in un numero.""},


 
 


 {
   ER_CANT_CONVERT_TO_NODELIST,
     ""Impossibile convertire {0} in NodeList.""},


 
 


 {
   ER_CANT_CONVERT_TO_MUTABLENODELIST,
     ""Impossibile convertire {0} in NodeSetDTM.""},


 
 


 {
   ER_CANT_CONVERT_TO_TYPE,
     ""Impossibile convertire {0} in tipo


 
 


 {
   ER_EXPECTED_MATCH_PATTERN,
     ""Previsto criterio di corrispondenza in getMatchScore.""},


 
 


 {
   ER_COULDNOT_GET_VAR_NAMED,
     ""Impossibile trovare la variabile denominata {0}""},


 
 


 {
   ER_UNKNOWN_OPCODE, ""ERRORE. Codice operativo sconosciuto: {0}""},


 
 


 {
   ER_EXTRA_ILLEGAL_TOKENS, ""Altri token non validi: {0}""},


 
 


 {
   ER_EXPECTED_DOUBLE_QUOTE,
     ""Letterale non corretto... previste le doppie virgolette.""},


 
 


 {
   ER_EXPECTED_SINGLE_QUOTE,
     ""Letterale non corretto... previste le virgolette singole.""},


 
 


 {
   ER_EMPTY_EXPRESSION, ""Espressione vuota.""},


 
 


 {
   ER_EXPECTED_BUT_FOUND, ""Previsto {0}, trovato: {1}""},


 
 


 {
   ER_INCORRECT_PROGRAMMER_ASSERTION,
     ""L''asserzione di programmazione non è corretta. - {0}""},


 
 


 {
   ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
     ""L'argomento booleano(...) non è più opzionale con 19990709 XPath draft.""},


 
 


 {
   ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
     ""Trovato ',' ma senza argomento precedente.""},


 
 


 {
   ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
     ""Trovato ',' ma senza argomento successivo.""},


 
 


 {
   ER_PREDICATE_ILLEGAL_SYNTAX,
     ""'.. la sintassi [predicato]' o '.[predicato]' non è valida. Utilizzare 'self::node()[predicato]'.""},


 
 


 {
   ER_ILLEGAL_AXIS_NAME, ""Nome di asse non valido: {0}""},


 
 


 {
   ER_UNKNOWN_NODETYPE, ""Tipo di nodo sconosciuto: {0}""},


 
 


 {
   ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
     ""Il criterio letterale ({0}) deve essere tra virgolette.""},


 
 


 {
   ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
     ""Impossibile formattare {0} in un numero.""},


 
 


 {
   ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
     ""Impossibile creare il collegamento XML TransformerFactory: {0}""},


 
 


 {
   ER_DIDNOT_FIND_XPATH_SELECT_EXP,
     ""Errore. Impossibile trovare l'espressione di selezione xpath (-select).""},


 
 


 {
   ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
     ""ERRORE. Impossibile trovare ENDOP dopo OP_LOCATIONPATH""},


 
 


 {
   ER_ERROR_OCCURED, ""Errore""},


 
 


 {
   ER_ILLEGAL_VARIABLE_REFERENCE,
     ""VariableReference fornito per la variabile è esterno al contesto o senza definizione.  Nome = {0}""},


 
 


 {
   ER_AXES_NOT_ALLOWED,
     ""Nei criteri di corrispondenza sono consentiti solo gli assi child:: e attribute::. Assi non validi = {0}""},


 
 


 {
   ER_KEY_HAS_TOO_MANY_ARGS,
     ""key() ha un numero di argomenti non valido.""},


 
 


 {
   ER_COUNT_TAKES_1_ARG,
     ""La funzione di conteggio deve prendere un argomento.""},


 
 


 {
   ER_COULDNOT_FIND_FUNCTION, ""Impossibile trovare la funzione: {0}""},


 
 


 {
   ER_UNSUPPORTED_ENCODING, ""Codifica non supportata: {0}""},


 
 


 {
   ER_PROBLEM_IN_DTM_NEXTSIBLING,
     ""Problema in DTM in getNextSibling... Tentativo di recupero in corso.""},


 
 


 {
   ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
     ""Errore di programmazione: impossibile scrivere in EmptyNodeList.""},


 
 


 {
   ER_SETDOMFACTORY_NOT_SUPPORTED,
     ""setDOMFactory non è supportato da XPathContext.""},


 
 


 {
   ER_PREFIX_MUST_RESOLVE,
     ""Il prefisso deve risolvere in namespace: {0}""},


 
 


 {
   ER_PARSE_NOT_SUPPORTED,
     ""analisi (sorgente InputSource) non supportata in XPathContext. Impossibile aprire {0}""},


 
 


 {
   ER_SAX_API_NOT_HANDLED,
     ""Caratteri SAX API (char ch[]... non gestiti da DTM.""},


 
 


 {
   ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
     ""ignorableWhitespace(char ch[]... non è gestito da DTM.""},


 
 


 {
   ER_DTM_CANNOT_HANDLE_NODES,
     ""DTMLiaison non può gestire nodi di tipo {0}""},


 
 


 {
   ER_XERCES_CANNOT_HANDLE_NODES,
     ""DOM2Helper non può gestire nodi di tipo {0}""},


 
 


 {
   ER_XERCES_PARSE_ERROR_DETAILS,
     ""Errore DOM2Helper.parse: SystemID - {0} linea - {1}""},


 
 


 {
   ER_XERCES_PARSE_ERROR, ""Errore DOM2Helper.parse""},


 
 


 {
   ER_INVALID_UTF16_SURROGATE,
     ""Rilevato surrogato di UTF-16 non valido: {0} ?""},


 
 


 {
   ER_OIERROR, ""Errore IO""},


 
 


 {
   ER_CANNOT_CREATE_URL, ""Impossibile creare URL per: {0}""},


 
 


 {
   ER_XPATH_READOBJECT, ""In XPath.readObject: {0}""},

 
 
 


 {
   ER_FUNCTION_TOKEN_NOT_FOUND,
     ""token di funzione non trovato.""},

 
  
 


 {
   ER_CANNOT_DEAL_XPATH_TYPE,
      ""Impossibile gestire il tipo XPath: {0}""},

 
  
 


 {
   ER_NODESET_NOT_MUTABLE,
      ""Questo NodeSet non è mutabile""},

 
  
 


 {
   ER_NODESETDTM_NOT_MUTABLE,
      ""Questo NodeSetDTM non è mutabile""},

 
  
 


 {
   ER_VAR_NOT_RESOLVABLE,
       ""Variabile non risolvibile: {0}""},

 
  
 


 {
   ER_NULL_ERROR_HANDLER,
       ""Errore gestore nullo""},

 
  
 


 {
   ER_PROG_ASSERT_UNKNOWN_OPCODE,
      ""Asserzione di programmazione: codice operativo sconosciuto: {0}""},

 
  
 


 {
   ER_ZERO_OR_ONE,
      ""0 o 1""},

 
 
  
 


 {
   ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
      ""rtf() non supportato da XRTreeFragSelectWrapper""},

 
  
 


 {
   ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
      ""asNodeIterator() non supportato da XRTreeFragSelectWrapper""},

 
  
 


 {
   ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
      ""fsb() non supportato per XStringForChars""},

 
  
 


 {
   ER_COULD_NOT_FIND_VAR,
     ""Impossibile trovare la variabile denominata {0}""},

 
  
 


 {
   ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
     ""XStringForChars non può prendere una stringa per un argomento""},

 
  
 


 {
   ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
     ""L'argomento FastStringBuffer non può essere nullo""},
   
    
   
 
 
   {
     ER_TWO_OR_THREE,
        ""2 o 3""},
  
 
    
   
 
 
   {
     ER_VARIABLE_ACCESSED_BEFORE_BIND,
        ""Accesso alla variabile prima della delimitazione.""},
  
 
    
   
 
 
   {
     ER_FSB_CANNOT_TAKE_STRING,
        ""XStringForFSB non può avere una stringa per argomento.""},
  
 
    
   
 
 
   {
     ER_SETTING_WALKER_ROOT_TO_NULL,
        ""
 !!!! Errore! Impostazione radice walker a zero.""},
  
 
    
   
 
 
   {
     ER_NODESETDTM_CANNOT_ITERATE,
        ""Questo NodeSetDTM non è in grado di eseguire iterazione in un nodo precedente.""},
  
 
   
   
 
 
   {
     ER_NODESET_CANNOT_ITERATE,
        ""Questo NodeSet non è in grado di eseguire iterazione in un nodo precedente.""},
  
 
   
   
 
 
   {
     ER_NODESETDTM_CANNOT_INDEX,
        ""Questo NodeSetDTM non è in grado di indicizzare o calcolare le funzioni.""},
  
 
   
   
 
 
   {
     ER_NODESET_CANNOT_INDEX,
        ""Questo NodeSet non è in grado di indicizzare o calcolare le funzioni.""},
  
 
   
   
 
 
   {
     ER_CANNOT_CALL_SETSHOULDCACHENODE,
        ""Impossibile richiamare setShouldCacheNodes dopo aver richiamato nextNode.""},
  
 
   
   
 
 
   {
     ER_ONLY_ALLOWS,
        ""{0} consente solo argomenti {1}""},
  
 
   
   
 
 
   {
     ER_UNKNOWN_STEP,
        ""Conferma del programmatore in getNextStepPos: stepType sconosciuto: {0}""},
  
 
   
   
   
 
   
   
 
 
   {
     ER_EXPECTED_REL_LOC_PATH,
        ""Atteso percorso ubicazione relativo dopo il token '/' o '
  
 
   
   
   
 
   
   
 
 
   {
     ER_EXPECTED_LOC_PATH,
        ""Atteso percorso ubicazione, ma è stato incontrato il token seguente:  {0}""},
  
 
   
   
   
 
   
   
 
 
   {
     ER_EXPECTED_LOC_STEP,
        ""Atteso step ubicazione dopo il token '/' o '
  
 
   
   
   
   
 
   
   
 
 
   {
     ER_EXPECTED_NODE_TEST,
        ""Atteso test nodo corrispondente a NCName:* o QName.""},
  
 
   
   
   
 
   
   
 
 
   {
     ER_EXPECTED_STEP_PATTERN,
        ""Atteso pattern step, ma è stato incontrato '/'.""},
  
 
   
   
   
  
   
   
 
 
   {
     ER_EXPECTED_REL_PATH_PATTERN,
        ""Atteso pattern percorso relativo.""},
  
 
   
   
   
 
   
   
 
 
   {
     ER_CANT_CONVERT_TO_BOOLEAN,
        ""Impossibile convertire {0} in booleano.""},
  
 
   
   
 
   
   
 
 
   {
     ER_CANT_CONVERT_TO_SINGLENODE,
        ""Impossibile convertire {0} in nodo singolo. Questo getter si applica ai tipi ANY_UNORDERED_NODE_TYPE e FIRST_ORDERED_NODE_TYPE.""},
  
 
   
   
 
   
   
 
 
   {
     ER_CANT_GET_SNAPSHOT_LENGTH,
        ""Impossibile recuperare lunghezza snapshot in tipo: {0}. Questo getter si applica ai tipi UNORDERED_NODE_SNAPSHOT_TYPE e ORDERED_NODE_SNAPSHOT_TYPE.""},
  
 
   
   
 
 
   {
     ER_NON_ITERATOR_TYPE,
        ""Impossibile eseguire iterazione su tipo non iterativo: {0}""},
  
 
   
   
   
 
   
   
 
 
   {
     ER_DOC_MUTATED,
        ""Documento modificato dalla restituzione del risultato. Iteratore non valido.""},
  
 
   
   
 
 
   {
     ER_INVALID_XPATH_TYPE,
        ""Argomento tipo XPath non valido: {0}""},
  
 
   
   
 
 
   {
     ER_EMPTY_XPATH_RESULT,
        ""Oggetto risultato XPath vuoto""},
  
 
   
   
 
 
   {
     ER_INCOMPATIBLE_TYPES,
        ""Il tipo restituito: {0} non può essere forzato nel tipo specificato: {1}""},
  
 
   
   
 
 
   {
     ER_NULL_RESOLVER,
        ""Impossibile risolvere il prefisso con risolutore prefisso nullo.""},
  
 
   
   
   
 
   
   
 
 
   {
     ER_CANT_CONVERT_TO_STRING,
        ""Impossibile convertire {0} in stringa.""},
  
 
   
   
 
   
   
 
 
   {
     ER_NON_SNAPSHOT_TYPE,
        ""Impossibile richiamare snapshotItem su tipo: {0}. Questo metodo è valido per i tipi UNORDERED_NODE_SNAPSHOT_TYPE e ORDERED_NODE_SNAPSHOT_TYPE.""},
  
 
   
   
   
   
 
   
   
 
 
   {
     ER_WRONG_DOCUMENT,
        ""Il nodo contesto non appartiene al documento collegato a questo XPathEvaluator.""},
  
 
   
   
   
   
 
 
   {
     ER_WRONG_NODETYPE ,
        ""Il tipo di nodo contesto non è supportato.""},
  
 
   
   
 
 
   {
     ER_XPATH_ERROR ,
        ""Errore sconosciuto in XPath.""},
  
 
 
   

 
 


 {
   WG_LOCALE_NAME_NOT_HANDLED,
     ""Il nome locale nella funzione format-number non è ancora gestito.""},


 
 


 {
   WG_PROPERTY_NOT_SUPPORTED,
     ""Proprietà XSL non supportata: {0}""},


 
 


 {
   WG_DONT_DO_ANYTHING_WITH_NS,
     ""Nulla da fare correntemente con namespace {0} in proprietà: {1}""},


 
 


 {
   WG_SECURITY_EXCEPTION,
     ""Generata SecurityException al tentativo di accedere alle proprietà di sistema XSL: {0}""},


 
 


 {
   WG_QUO_NO_LONGER_DEFINED,
     ""Sintassi precedente: quo(...) non è più definita in XPath.""},


 
 


 {
   WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
     ""XPath deve avere un oggetto derivato per implementare nodeTest.""},


 
 


 {
   WG_FUNCTION_TOKEN_NOT_FOUND,
     ""Token di funzione non trovato.""},


 
 


 {
   WG_COULDNOT_FIND_FUNCTION,
     ""Impossibile trovare la funzione: {0}""},


 
 


 {
   WG_CANNOT_MAKE_URL_FROM,
     ""Impossibile creare un URL da: {0}""},


 
 


 {
   WG_EXPAND_ENTITIES_NOT_SUPPORTED,
     ""L'opzione -E non è supportata per il parser DTM""},


 
 


 {
   WG_ILLEGAL_VARIABLE_REFERENCE,
     ""VariableReference fornita per la variabile è esterna al contesto o senza definizione.  Nome = {0}""},


 
 


 {
   WG_UNSUPPORTED_ENCODING, ""Codifica non supportata: {0}""},


 

 { ""ui_language"", ""it""},
 { ""help_language"", ""it""},
 { ""language"", ""it""},
   { ""BAD_CODE"",
     ""Il parametro di createMessage è esterno ai limiti""},
   { ""FORMAT_FAILED"",
     ""Eccezione generata durante la chiamata di messageFormat""},
   { ""version"", "">>>>>>> Xalan Versione ""},
   { ""version2"", ""<<<<<<<""},
   { ""yes"", ""sì""},
   { ""line"", ""Linea 
   { ""column"", ""Colonna 
   { ""xsldone"", ""XSLProcessor: done""},
   { ""xpath_option"", ""xpath options: ""},
   { ""optionIN"", ""   [-in inputXMLURL]""},
   { ""optionSelect"", ""   [-select espressione xpath]""},
   { ""optionMatch"",
     ""   [-match match pattern (per la diagnostica di corrispondenza)]""},
   { ""optionAnyExpr"",
     ""O solo un'espressione xpath per eseguire un dump di diagnostica""},
   { ""noParsermsg1"", ""Processo XSL non riuscito.""},
   { ""noParsermsg2"", ""** Impossibile trovare il parser **""},
   { ""noParsermsg3"", ""Verificare il classpath.""},
   { ""noParsermsg4"",
     ""Se non si dispone del parser XML IBM per Java, scaricarlo da""},
   { ""noParsermsg5"",
     ""AlphaWorks IBM: http:
 };

 

 
 public static final String BAD_CODE = ""BAD_CODE"";

 
 public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

 
 public static final String ERROR_RESOURCES =
   ""org.apache.xpath.res.XPATHErrorResources"";

 
 public static final String ERROR_STRING = ""

 
 public static final String ERROR_HEADER = ""Errore: "";

 
 public static final String WARNING_HEADER = ""Avvertenza: "";

 
 public static final String XSL_HEADER = ""XSL "";

 
 public static final String XML_HEADER = ""XML "";

 
 public static final String QUERY_HEADER = ""PATTERN "";

 
 public Object[][] getContents()
 {
   return contents;
 }


  
  private static final String getResourceSuffix(Locale locale)
  {

    String suffix = ""_"" + locale.getLanguage();
    String country = locale.getCountry();

    if (country.equals(""TW""))
      suffix += ""_"" + country;

    return suffix;
  }


}

"
org.apache.xalan.xsltc.compiler.AbsolutePathPattern,8,5,0,29,45,0,1,29,8,0.142857143,241,1.0,1,0.933962264,0.270833333,4,5,29.0,6,1.875,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO_W;
import org.apache.bcel.generic.IF_ICMPEQ;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xml.dtm.DTM;

final class AbsolutePathPattern extends LocationPathPattern {
    private final RelativePathPattern _left; 

    public AbsolutePathPattern(RelativePathPattern left) {
	_left = left;
	if (left != null) {
	    left.setParent(this);
	}
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_left != null)
	    _left.setParser(parser);
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _left == null ? Type.Root : _left.typeCheck(stable);
    }

    public boolean isWildcard() {
	return false;
    }
	
    public StepPattern getKernelPattern() {
	return _left != null ? _left.getKernelPattern() : null;
    }
	
    public void reduceKernelPattern() {
	_left.reduceKernelPattern();
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_left != null) {
	    if (_left instanceof StepPattern) {
		final LocalVariableGen local = 
		    
		    methodGen.addLocalVariable2(""apptmp"", 
						Util.getJCRefType(NODE_SIG),
						il.getEnd());
		il.append(DUP);
		il.append(new ISTORE(local.getIndex()));
		_left.translate(classGen, methodGen);
		il.append(methodGen.loadDOM());
		local.setEnd(il.append(new ILOAD(local.getIndex())));
		methodGen.removeLocalVariable(local);
	    }
	    else {
		_left.translate(classGen, methodGen);
	    }
	}

	final int getParent = cpg.addInterfaceMethodref(DOM_INTF,
							GET_PARENT,
							GET_PARENT_SIG);
	final int getType = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getExpandedTypeID"",
                                                      ""(I)I"");

	InstructionHandle begin = il.append(methodGen.loadDOM());
	il.append(SWAP);
	il.append(new INVOKEINTERFACE(getParent, 2));
	if (_left instanceof AncestorPattern) {	
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	}
	il.append(new INVOKEINTERFACE(getType, 2));
	il.append(new PUSH(cpg, DTM.DOCUMENT_NODE));
	
	final BranchHandle skip = il.append(new IF_ICMPEQ(null));
	_falseList.add(il.append(new GOTO_W(null)));
	skip.setTarget(il.append(NOP));

	if (_left != null) {
	    _left.backPatchTrueList(begin);
	    
	    
	    if (_left instanceof AncestorPattern) {
		final AncestorPattern ancestor = (AncestorPattern) _left;
		_falseList.backPatch(ancestor.getLoopHandle());		
	    }
	    _falseList.append(_left._falseList);
	}
    }
	
    public String toString() {
	return ""absolutePathPattern("" + (_left != null ? _left.toString() : "")"");
    }
}
"
org.apache.xml.serializer.DOMSerializer,1,1,0,8,1,0,8,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xml.serializer;

import java.io.IOException;

import org.w3c.dom.Node;


public interface DOMSerializer
{
    
    public void serialize(Node node) throws IOException;
}
"
org.apache.xalan.xsltc.compiler.Number,15,3,0,52,104,23,1,52,9,0.798319328,1308,1.0,8,0.811594203,0.214285714,2,3,85.06666667,14,3.1333,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.ArrayList;

import org.apache.bcel.classfile.Field;
import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFNONNULL;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.L2I;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MatchGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeCounterGenerator;
import org.apache.xalan.xsltc.compiler.util.RealType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class Number extends Instruction implements Closure {
    private static final int LEVEL_SINGLE   = 0;
    private static final int LEVEL_MULTIPLE = 1;
    private static final int LEVEL_ANY      = 2;

    static final private String[] ClassNames = { 
	""org.apache.xalan.xsltc.dom.SingleNodeCounter"",	  
	""org.apache.xalan.xsltc.dom.MultipleNodeCounter"", 
	""org.apache.xalan.xsltc.dom.AnyNodeCounter""	  
    };

    static final private String[] FieldNames = { 
	""___single_node_counter"",		   
	""___multiple_node_counter"",		   
	""___any_node_counter""			   
    };

    private Pattern _from = null;
    private Pattern _count = null;
    private Expression _value = null;

    private AttributeValueTemplate _lang = null;
    private AttributeValueTemplate _format = null;
    private AttributeValueTemplate _letterValue = null;
    private AttributeValueTemplate _groupingSeparator = null;
    private AttributeValueTemplate _groupingSize = null;

    private int _level = LEVEL_SINGLE;
    private boolean _formatNeeded = false;

    private String _className = null;
    private ArrayList _closureVars = null;

     

    
    public boolean inInnerClass() {
	return (_className != null);
    }

    
    public Closure getParentClosure() {
	return null;
    }

    
    public String getInnerClassName() {
	return _className;
    }

    
    public void addVariable(VariableRefBase variableRef) {
	if (_closureVars == null) {
	    _closureVars = new ArrayList();
	}

	
	if (!_closureVars.contains(variableRef)) {
	    _closureVars.add(variableRef);
	}
    }

    

   public void parseContents(Parser parser) {
	final int count = _attributes.getLength();

	for (int i = 0; i < count; i++) {
	    final String name = _attributes.getQName(i);
	    final String value = _attributes.getValue(i);

	    if (name.equals(""value"")) {
		_value = parser.parseExpression(this, name, null);
	    }
	    else if (name.equals(""count"")) {
		_count = parser.parsePattern(this, name, null);
	    }
	    else if (name.equals(""from"")) {
		_from = parser.parsePattern(this, name, null);
	    }
	    else if (name.equals(""level"")) {
		if (value.equals(""single"")) {
		    _level = LEVEL_SINGLE;
		}
		else if (value.equals(""multiple"")) {
		    _level = LEVEL_MULTIPLE;
		}
		else if (value.equals(""any"")) {
		    _level = LEVEL_ANY;
		}
	    }
	    else if (name.equals(""format"")) {
		_format = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	    else if (name.equals(""lang"")) {
		_lang = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	    else if (name.equals(""letter-value"")) {
		_letterValue = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	    else if (name.equals(""grouping-separator"")) {
		_groupingSeparator = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	    else if (name.equals(""grouping-size"")) {
		_groupingSize = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	}
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_value != null) {
	    Type tvalue = _value.typeCheck(stable);
	    if (tvalue instanceof RealType == false) {
		_value = new CastExpr(_value, Type.Real);
	    }
	}
	if (_count != null) {
	    _count.typeCheck(stable);
	}
	if (_from != null) {
	    _from.typeCheck(stable);
	}
	if (_format != null) {
	    _format.typeCheck(stable);
	}
	if (_lang != null) {
	    _lang.typeCheck(stable);
	}
	if (_letterValue != null) {
	    _letterValue.typeCheck(stable);
	}
	if (_groupingSeparator != null) {
	    _groupingSeparator.typeCheck(stable);
	}
	if (_groupingSize != null) {
	    _groupingSize.typeCheck(stable);
	}
	return Type.Void;
    }

    
    public boolean hasValue() {
	return _value != null;
    }

    
    public boolean isDefault() {
	return _from == null && _count == null;
    }

    private void compileDefault(ClassGenerator classGen,
			        MethodGenerator methodGen) {
	int index;
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();

	int[] fieldIndexes = getXSLTC().getNumberFieldIndexes();

	if (fieldIndexes[_level] == -1) {
	    Field defaultNode = new Field(ACC_PRIVATE, 
					  cpg.addUtf8(FieldNames[_level]),
					  cpg.addUtf8(NODE_COUNTER_SIG),
					  null, 
					  cpg.getConstantPool());

	    
	    classGen.addField(defaultNode);

	    
	    fieldIndexes[_level] = cpg.addFieldref(classGen.getClassName(), 
						   FieldNames[_level],
						   NODE_COUNTER_SIG);
	}

	
	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(fieldIndexes[_level]));
	final BranchHandle ifBlock1 = il.append(new IFNONNULL(null));

	
	index = cpg.addMethodref(ClassNames[_level],
				 ""getDefaultNodeCounter"", 
				 ""("" + TRANSLET_INTF_SIG
				 + DOM_INTF_SIG
				 + NODE_ITERATOR_SIG 
				 + "")"" + NODE_COUNTER_SIG);
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadIterator());
	il.append(new INVOKESTATIC(index));
	il.append(DUP);

	
	il.append(classGen.loadTranslet());
	il.append(SWAP);
	il.append(new PUTFIELD(fieldIndexes[_level]));
	final BranchHandle ifBlock2 = il.append(new GOTO(null));

	
	ifBlock1.setTarget(il.append(classGen.loadTranslet()));
	il.append(new GETFIELD(fieldIndexes[_level]));
	
	ifBlock2.setTarget(il.append(NOP));
    }

    
    private void compileConstructor(ClassGenerator classGen) {
	MethodGenerator cons;
	final InstructionList il = new InstructionList();
	final ConstantPoolGen cpg = classGen.getConstantPool();

	cons = new MethodGenerator(ACC_PUBLIC,
				   org.apache.bcel.generic.Type.VOID, 
				   new org.apache.bcel.generic.Type[] {
				       Util.getJCRefType(TRANSLET_INTF_SIG),
				       Util.getJCRefType(DOM_INTF_SIG),
				       Util.getJCRefType(NODE_ITERATOR_SIG)
				   },
				   new String[] {
				       ""dom"",
				       ""translet"",
				       ""iterator""
				   },
				   ""<init>"", _className, il, cpg);

	il.append(ALOAD_0);     
	il.append(ALOAD_1);     
	il.append(ALOAD_2);     
	il.append(new ALOAD(3));

	int index = cpg.addMethodref(ClassNames[_level],
				     ""<init>"", 
				     ""("" + TRANSLET_INTF_SIG
				     + DOM_INTF_SIG
				     + NODE_ITERATOR_SIG 
				     + "")V"");
	il.append(new INVOKESPECIAL(index));
	il.append(RETURN);
	
	cons.stripAttributes(true);
	cons.setMaxLocals();
	cons.setMaxStack();
	classGen.addMethod(cons.getMethod());
    }

    
    private void compileLocals(NodeCounterGenerator nodeCounterGen,
			       MatchGenerator matchGen,
			       InstructionList il) 
    {
	int field;
	LocalVariableGen local;
	ConstantPoolGen cpg = nodeCounterGen.getConstantPool();

	
	local = matchGen.addLocalVariable(""iterator"", 
					  Util.getJCRefType(NODE_ITERATOR_SIG),
					  null, null);
	field = cpg.addFieldref(NODE_COUNTER, ""_iterator"",
				ITERATOR_FIELD_SIG);
	il.append(ALOAD_0); 
	il.append(new GETFIELD(field));
	il.append(new ASTORE(local.getIndex()));
	matchGen.setIteratorIndex(local.getIndex());
	
	
	local = matchGen.addLocalVariable(""translet"", 
				  Util.getJCRefType(TRANSLET_SIG),
				  null, null);
	field = cpg.addFieldref(NODE_COUNTER, ""_translet"",
				""Lorg/apache/xalan/xsltc/Translet;"");
	il.append(ALOAD_0); 
	il.append(new GETFIELD(field));
	il.append(new CHECKCAST(cpg.addClass(TRANSLET_CLASS)));
	il.append(new ASTORE(local.getIndex()));
	nodeCounterGen.setTransletIndex(local.getIndex());

	
	local = matchGen.addLocalVariable(""document"", 
					  Util.getJCRefType(DOM_INTF_SIG),
					  null, null);
	field = cpg.addFieldref(_className, ""_document"", DOM_INTF_SIG);
	il.append(ALOAD_0); 
	il.append(new GETFIELD(field));
	
	il.append(new ASTORE(local.getIndex()));
	matchGen.setDomIndex(local.getIndex());
    }

    private void compilePatterns(ClassGenerator classGen,
				 MethodGenerator methodGen) 
    {
	int current;
	int field;
	LocalVariableGen local;
	MatchGenerator matchGen;
	NodeCounterGenerator nodeCounterGen;

	_className = getXSLTC().getHelperClassName();
	nodeCounterGen = new NodeCounterGenerator(_className,
						  ClassNames[_level],
						  toString(), 
						  ACC_PUBLIC | ACC_SUPER,
						  null,
						  classGen.getStylesheet());
	InstructionList il = null;
	ConstantPoolGen cpg = nodeCounterGen.getConstantPool();

	
	final int closureLen = (_closureVars == null) ? 0 : 
	    _closureVars.size();

	for (int i = 0; i < closureLen; i++) {
	    VariableBase var = 
		((VariableRefBase) _closureVars.get(i)).getVariable();

	    nodeCounterGen.addField(new Field(ACC_PUBLIC, 
					cpg.addUtf8(var.getVariable()),
					cpg.addUtf8(var.getType().toSignature()),
					null, cpg.getConstantPool()));
	}

	
	compileConstructor(nodeCounterGen);

	
	if (_from != null) {
	    il = new InstructionList();
	    matchGen =
		new MatchGenerator(ACC_PUBLIC | ACC_FINAL,
				   org.apache.bcel.generic.Type.BOOLEAN, 
				   new org.apache.bcel.generic.Type[] {
				       org.apache.bcel.generic.Type.INT,
				   },
				   new String[] {
				       ""node"",
				   },
				   ""matchesFrom"", _className, il, cpg);

	    compileLocals(nodeCounterGen,matchGen,il);

	    
	    il.append(matchGen.loadContextNode());
	    _from.translate(nodeCounterGen, matchGen);
	    _from.synthesize(nodeCounterGen, matchGen);
	    il.append(IRETURN);
		    
	    matchGen.stripAttributes(true);
	    matchGen.setMaxLocals();
	    matchGen.setMaxStack();
	    matchGen.removeNOPs();
	    nodeCounterGen.addMethod(matchGen.getMethod());
	}

	
	if (_count != null) {
	    il = new InstructionList();
	    matchGen = new MatchGenerator(ACC_PUBLIC | ACC_FINAL,
					  org.apache.bcel.generic.Type.BOOLEAN, 
					  new org.apache.bcel.generic.Type[] {
					      org.apache.bcel.generic.Type.INT,
					  },
					  new String[] {
					      ""node"",
					  },
					  ""matchesCount"", _className, il, cpg);

	    compileLocals(nodeCounterGen,matchGen,il);
	    
	    
	    il.append(matchGen.loadContextNode());
	    _count.translate(nodeCounterGen, matchGen);
	    _count.synthesize(nodeCounterGen, matchGen);
	    
	    il.append(IRETURN);
		    
	    matchGen.stripAttributes(true);
	    matchGen.setMaxLocals();
	    matchGen.setMaxStack();
	    matchGen.removeNOPs();
	    nodeCounterGen.addMethod(matchGen.getMethod());
	}
	
	getXSLTC().dumpClass(nodeCounterGen.getJavaClass());

	
	cpg = classGen.getConstantPool();
	il = methodGen.getInstructionList();

	final int index = cpg.addMethodref(_className, ""<init>"", 
					   ""("" + TRANSLET_INTF_SIG
					   + DOM_INTF_SIG 
					   + NODE_ITERATOR_SIG
					   + "")V"");
	il.append(new NEW(cpg.addClass(_className)));
	il.append(DUP);
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadIterator());
	il.append(new INVOKESPECIAL(index));

	
	for (int i = 0; i < closureLen; i++) {
	    final VariableRefBase varRef = (VariableRefBase) _closureVars.get(i);
	    final VariableBase var = varRef.getVariable();
	    final Type varType = var.getType();

	    
	    il.append(DUP);
	    il.append(var.loadInstruction());
	    il.append(new PUTFIELD(
		    cpg.addFieldref(_className, var.getVariable(), 
			varType.toSignature())));
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	int index;
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(classGen.loadTranslet());

	if (hasValue()) {
	    compileDefault(classGen, methodGen);
	    _value.translate(classGen, methodGen);

	    
	    index = cpg.addMethodref(MATH_CLASS, ""round"", ""(D)J"");
	    il.append(new INVOKESTATIC(index));
	    il.append(new L2I());

	    
	    index = cpg.addMethodref(NODE_COUNTER, 
				     ""setValue"", 
				     ""(I)"" + NODE_COUNTER_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}
	else if (isDefault()) {
	    compileDefault(classGen, methodGen);
	}
	else {
	    compilePatterns(classGen, methodGen);
	}

	
	if (!hasValue()) {
	    il.append(methodGen.loadContextNode());
	    index = cpg.addMethodref(NODE_COUNTER, 
				     SET_START_NODE, 
				     ""(I)"" + NODE_COUNTER_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}

	
	if (_formatNeeded) {
	    if (_format != null) {
		_format.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, ""1""));
	    }

	    if (_lang != null) {
		_lang.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, ""en"")); 	
	    }

	    if (_letterValue != null) {
		_letterValue.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, Constants.EMPTYSTRING));
	    }

	    if (_groupingSeparator != null) {
		_groupingSeparator.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, Constants.EMPTYSTRING));
	    }

	    if (_groupingSize != null) {
		_groupingSize.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, ""0""));
	    }

	    index = cpg.addMethodref(NODE_COUNTER, ""getCounter"", 
				     ""("" + STRING_SIG + STRING_SIG 
				     + STRING_SIG + STRING_SIG 
				     + STRING_SIG + "")"" + STRING_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}
	else {
	    index = cpg.addMethodref(NODE_COUNTER, ""setDefaultFormatting"", 
				     ""()"" + NODE_COUNTER_SIG);
	    il.append(new INVOKEVIRTUAL(index));

	    index = cpg.addMethodref(NODE_COUNTER, ""getCounter"", 
				     ""()"" + STRING_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}

	
	il.append(methodGen.loadHandler());
	index = cpg.addMethodref(TRANSLET_CLASS,
				 CHARACTERSW,
				 CHARACTERSW_SIG);
	il.append(new INVOKEVIRTUAL(index));
    }
}
"
org.apache.xpath.res.XPATHErrorResources_ko,3,4,0,1,4,1,0,1,2,1.428571429,1872,0.0,0,0.976190476,1.0,0,0,618.3333333,1,0.3333,1,"	
package org.apache.xpath.res;


public class XPATHErrorResources_ko extends XPATHErrorResources
{


  
  public static final int MAX_CODE = 108;  

  
  public static final int MAX_WARNING = 11;  

  
  public static final int MAX_OTHERS = 20;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  
  public static final Object[][] contents = {

  
  

 
  {
    ""ERROR0000"", ""{0}""},
 

  
  

 
  {
    ER_CURRENT_NOT_ALLOWED_IN_MATCH,
      ""current() 함수는 일치 패턴에 허용되지 않습니다.""},
 

  
  

 
  {
    ER_CURRENT_TAKES_NO_ARGS,
      ""current() 함수에는 인자가 없습니다!""},
 

  
  

 
  {
    ER_DOCUMENT_REPLACED,
      ""document() 함수 구현은 org.apache.xalan.xslt.FuncDocument로 대체되었습니다!""},
 

  
  

 
  {
    ER_CONTEXT_HAS_NO_OWNERDOC,
      ""컨텍스트에 소유자 문서가 없습니다.""},
 

  
  

 
  {
    ER_LOCALNAME_HAS_TOO_MANY_ARGS,
      ""local-name()의 인자가 너무 많습니다.""},
 

  
  

 
  {
    ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
      ""namespace-uri()의 인자가 너무 많습니다.""},
 

  
  

 
  {
    ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
      ""normalize-space()의 인자가 너무 많습니다.""},
 

  
  

 
  {
    ER_NUMBER_HAS_TOO_MANY_ARGS,
      ""number()의 인자가 너무 많습니다.""},
 

  
  

 
  {
    ER_NAME_HAS_TOO_MANY_ARGS, ""name()의 인자가 너무 많습니다.""},
 

  
  

 
  {
    ER_STRING_HAS_TOO_MANY_ARGS,
      ""string()의 인자가 너무 많습니다.""},
 

  
  

 
  {
    ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
      ""string-length()의 인자가 너무 많습니다.""},
 

  
  

 
  {
    ER_TRANSLATE_TAKES_3_ARGS,
      ""translate() 함수에는 세 개의 인자를 사용합니다!""},
 

  
  

 
  {
    ER_UNPARSEDENTITYURI_TAKES_1_ARG,
      ""unparsed-entity-uri 함수는 하나의 인자만을 사용합니다!""},
 

  
  

 
  {
    ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
      ""이름 공간 축이 아직 구현되지 않았습니다!""},
 

  
  

 
  {
    ER_UNKNOWN_AXIS, ""{0}은(는) 알 수 없는 축입니다.""},
 

  
  

 
  {
    ER_UNKNOWN_MATCH_OPERATION, ""알 수 없는 일치 연산입니다!""},
 

  
  

 
  {
    ER_INCORRECT_ARG_LENGTH,
      ""processing-instruction() 노드 검사의 인자 길이가 올바르지 않습니다!""},
 

  
  

 
  {
    ER_CANT_CONVERT_TO_NUMBER,
      ""{0}을(를) 숫자로 변환할 수 없습니다.""},
 

  
  

 
  {
    ER_CANT_CONVERT_TO_NODELIST,
      ""{0}을(를) NodeList로 변환할 수 없습니다!""},
 

  
  

 
  {
    ER_CANT_CONVERT_TO_MUTABLENODELIST,
      ""{0}을(를) NodeSetDTM으로 변환할 수 없습니다!""},
 

  
  

 
  {
    ER_CANT_CONVERT_TO_TYPE,
      ""{0}을(를) type
 

  
  

 
  {
    ER_EXPECTED_MATCH_PATTERN,
      ""getMatchScore에 일치 패턴이 있어야 합니다!""},
 

  
  

 
  {
    ER_COULDNOT_GET_VAR_NAMED,
      ""{0} 변수를 가져올 수 없습니다. ""},
 

  
  

 
  {
    ER_UNKNOWN_OPCODE, ""오류! 알 수 없는 연산 코드: {0}""},
 

  
  

 
  {
    ER_EXTRA_ILLEGAL_TOKENS, ""잘못된 토큰: {0}""},
 

  
  

 
  {
    ER_EXPECTED_DOUBLE_QUOTE,
      ""리터럴의 인용부호가 잘못되었습니다... 큰따옴표가 나와야 합니다!""},
 

  
  

 
  {
    ER_EXPECTED_SINGLE_QUOTE,
      ""리터럴의 인용부호가 잘못되었습니다... 단일 인용부호가 나와야 합니다!""},
 

  
  

 
  {
    ER_EMPTY_EXPRESSION, ""표현식이 비어 있습니다!""},
 

  
  

 
  {
    ER_EXPECTED_BUT_FOUND, ""{0}을(를) 예상했지만 {1}을(를) 찾았습니다.""},
 

  
  

 
  {
    ER_INCORRECT_PROGRAMMER_ASSERTION,
      ""프로그래머 명제가 올바르지 않습니다! - {0}""},
 

  
  

 
  {
    ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
      ""부울(...) 인자는 19990709 XPath 드래프트와 함께 더 이상 선택 인자가 아닙니다.""},
 

  
  

 
  {
    ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
      ""','를 찾았으나 선행 인자가 아닙니다!""},
 

  
  

 
  {
    ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
      ""','를 찾았으나 후미 인자가 아닙니다!""},
 

  
  

 
  {
    ER_PREDICATE_ILLEGAL_SYNTAX,
      ""'..[predicate]' 또는 '.[predicate]'는 잘못된 구문입니다. 대신 'self::node()[predicate]'을 사용하십시오. ""},
 

  
  

 
  {
    ER_ILLEGAL_AXIS_NAME, ""잘못된 축 이름: {0}""},
 

  
  

 
  {
    ER_UNKNOWN_NODETYPE, ""알 수 없는 노드 유형: {0}""},
 

  
  

 
  {
    ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
      ""패턴 리터럴({0})에 인용부호가 있어야 합니다!""},
 

  
  

 
  {
    ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
      ""{0}을(를) 숫자로 포맷할 수 없습니다!""},
 

  
  

 
  {
    ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
      ""XML TransformerFactory Liaison {0}을(를) 작성할 수 없습니다.""},
 

  
  

 
  {
    ER_DIDNOT_FIND_XPATH_SELECT_EXP,
      ""오류! xpath 선택 표현식(-select)을 찾을 수 없습니다.""},
 

  
  

 
  {
    ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
      ""오류! OP_LOCATIONPATH 다음에 ENDOP를 찾을 수 없습니다.   ""},
 

  
  

 
  {
    ER_ERROR_OCCURED, ""오류가 발생했습니다!""},
 

  
  

 
  {
    ER_ILLEGAL_VARIABLE_REFERENCE,
      ""VariableReference가 컨텍스트를 벗어났거나 정의되지 않은 변수에 지정되었습니다! 이름 = {0}""},
 

  
  

 
  {
    ER_AXES_NOT_ALLOWED,
      ""일치 패턴에서는 하나의 child:: 및 attribute:: 축이 허용됩니다. 위반 축 = {0}""},
 

  
  

 
  {
    ER_KEY_HAS_TOO_MANY_ARGS,
      ""key()의 인자 수가 잘못되었습니다.""},
 

  
  

 
  {
    ER_COUNT_TAKES_1_ARG,
      ""카운트 함수는 하나의 인자만을 사용합니다!""},
 

  
  

 
  {
    ER_COULDNOT_FIND_FUNCTION, ""함수 {0}을(를) 찾을 수 없습니다.""},
 

  
  

 
  {
    ER_UNSUPPORTED_ENCODING, ""지원되지 않는 코드화: {0}""},
 

  
  

 
  {
    ER_PROBLEM_IN_DTM_NEXTSIBLING,
      ""getNextSibling의 DTM에 문제가 발생했습니다... 복구를 시도 중입니다.""},
 

  
  

 
  {
    ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
      ""프로그래머 오류: EmptyNodeList에는 쓸 수 없습니다.""},
 

  
  

 
  {
    ER_SETDOMFACTORY_NOT_SUPPORTED,
      ""setDOMFactory는 XPathContext에서 지원되지 않습니다!""},
 

  
  

 
  {
    ER_PREFIX_MUST_RESOLVE,
      ""접두어가 이름 공간 {0}으로(로) 결정되어야 합니다.""},
 

  
  

 
  {
    ER_PARSE_NOT_SUPPORTED,
      ""구문 분석(InputSource 소스)은 XPathContext에서 지원되지 않습니다! {0}을(를) 열 수 없습니다.  ""},
 

  
  

 
  {
    ER_SAX_API_NOT_HANDLED,
      ""SAX API 문자(char ch[]...는 DTM에 의해 처리되지 않습니다!""},
 

  
  

 
  {
    ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
      ""ignorableWhitespace(char ch[]...는 DTM에 의해 처리되지 않습니다!""},
 

  
  

 
  {
    ER_DTM_CANNOT_HANDLE_NODES,
      ""DTMLiaison은 {0} 유형의 노드를 처리할 수 없습니다. ""},
 

  
  

 
  {
    ER_XERCES_CANNOT_HANDLE_NODES,
      ""DOM2Helper는 {0} 유형의 노드를 처리할 수 없습니다.   ""},
 

  
  

 
  {
    ER_XERCES_PARSE_ERROR_DETAILS,
      ""DOM2Helper.parse 오류: SystemID - {0} 행 - {1}""},
 

  
  

 
  {
    ER_XERCES_PARSE_ERROR, ""DOM2Helper.parse 오류""},
 

  
  

 
  {
    ER_INVALID_UTF16_SURROGATE,
      ""잘못된 UTF-16 대리가 감지되었습니다: {0} ?""},
 

  
  

 
  {
    ER_OIERROR, ""IO 오류""},
 

  
  

 
  {
    ER_CANNOT_CREATE_URL, ""{0}에 대한 url을 작성할 수 없습니다.     ""},
 

  
  

 
  {
    ER_XPATH_READOBJECT, ""XPath.readObject에: {0}""},
 
  
  
  

 
  {
    ER_FUNCTION_TOKEN_NOT_FOUND,
      ""기능 토큰을 찾을 수 없습니다.""},
 
  
   
  

 
  {
    ER_CANNOT_DEAL_XPATH_TYPE,
       ""XPath 유형을 처리할 수 없습니다: {0}    ""},
 
  
   
  

 
  {
    ER_NODESET_NOT_MUTABLE,
       ""NodeSet은 변경할 수 없습니다""},
 
  
   
  

 
  {
    ER_NODESETDTM_NOT_MUTABLE,
       ""NodeSetDTM은 변경할 수 없습니다""},
 
  
   
  

 
  {
    ER_VAR_NOT_RESOLVABLE,
        ""변수를 결정할 수 없습니다: {0}""},
 
  
   
  

 
  {
    ER_NULL_ERROR_HANDLER,
        ""오류 처리기가 널입니다""},
 
  
   
  

 
  {
    ER_PROG_ASSERT_UNKNOWN_OPCODE,
       ""프로그래머 명제: 알 수 없는 opcode: {0}""},
 
  
   
  

 
  {
    ER_ZERO_OR_ONE,
       ""0 또는 1""},
 
  
 
   
  

 
  {
    ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""XRTreeFragSelectWrapper가 rtf()를 지원하지 않습니다""},
 
  
   
  

 
  {
    ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""XRTreeFragSelectWrapper가 asNodeIterator()를 지원하지 않습니다""},
 
  
   
  

 
  {
    ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
       ""fsb()가 XStringForChars에 대해 지원되지 않습니다""},
 
  
   
  

 
  {
    ER_COULD_NOT_FIND_VAR,
      ""이름이 {0}인 변수를 찾을 수 없습니다.   ""},
 
  
   
  

 
  {
    ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
      ""XStringForChars가 인자에 대한 문자열을 가져올 수 없습니다.""},
 
  
   
  

 
  {
    ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
      ""FastStringBuffer 인자는 널이 될 수 없습니다.""},
    
   
   
  

 
  {
    ER_TWO_OR_THREE,
       ""2 또는 3""},
 

   
  

 
  {
    ER_VARIABLE_ACCESSED_BEFORE_BIND,
       ""변수가 바운딩되기 전에 액세스되었습니다.""},
 

   
  

 
  {
    ER_FSB_CANNOT_TAKE_STRING,
       ""XStringForFSB가 인자에 대한 문자열을 가져올 수 없습니다.""},
 

   
  

 
  {
    ER_SETTING_WALKER_ROOT_TO_NULL,
       ""
 !!!! 오류! walker의 루트를 널로 설정했습니다!!!""},
 

   
  

 
  {
    ER_NODESETDTM_CANNOT_ITERATE,
       ""이 NodeSetDTM이 이전 노드로 반복할 수 없습니다!""},
 

  
  

 
  {
    ER_NODESET_CANNOT_ITERATE,
       ""이 NodeSet이 이전 노드로 반복할 수 없습니다!""},
 

  
  

 
  {
    ER_NODESETDTM_CANNOT_INDEX,
       ""이 NodeSetDTM이 인덱스 또는 카운팅 기능을 수행할 수 없습니다!""},
 

  
  

 
  {
    ER_NODESET_CANNOT_INDEX,
       ""이 NodeSet이 인덱스 또는 카운팅 기능을 수행할 수 없습니다!""},
 

  
  

 
  {
    ER_CANNOT_CALL_SETSHOULDCACHENODE,
       ""nextNode가 호출된 다음에 setShouldCacheNodeshas를 호출할 수 없습니다!""},
 

  
  

 
  {
    ER_ONLY_ALLOWS,
       ""{0}은(는) {1} 인자만 허용합니다.""},
 

  
  

 
  {
    ER_UNKNOWN_STEP,
       ""getNextStepPos에서 프로그래머 명제: 알 수 없는 stepType: {0}""},
 

  
  
  

  
  

 
  {
    ER_EXPECTED_REL_LOC_PATH,
       ""상대 위치 경로는 '/' 또는 '
 

  
  
  

  
  

 
  {
    ER_EXPECTED_LOC_PATH,
       ""상대 위치 경로가 와야 하지만 대신 다음 토큰이 발견되었습니다.:  {0}""},
 

  
  
  

  
  

 
  {
    ER_EXPECTED_LOC_STEP,
       ""위치 단계는 '/' 또는 '
 

  
  
  
  

  
  

 
  {
    ER_EXPECTED_NODE_TEST,
       ""NCName:* 또는 QName과 일치하는 노드 테스트가 와야 합니다.""},
 

  
  
  

  
  

 
  {
    ER_EXPECTED_STEP_PATTERN,
       ""단계 패턴이 와야 하지만 대신 '/'를 발견했습니다.""},
 

  
  
  
 
  
  

 
  {
    ER_EXPECTED_REL_PATH_PATTERN,
       ""상대 경로 패턴이 와야 합니다.""},
 

  
  
  

  
  

 
  {
    ER_CANT_CONVERT_TO_BOOLEAN,
       ""{0}을(를) 부울로 변환할 수 없습니다.""},
 

  
  

  
  

 
  {
    ER_CANT_CONVERT_TO_SINGLENODE,
       ""{0}을(를) 단일 노드로 변환할 수 없습니다. 이 getter는 ANY_UNORDERED_NODE_TYPE 유형과 FIRST_ORDERED_NODE_TYPE 유형에 적용됩니다.""},
 

  
  

  
  

 
  {
    ER_CANT_GET_SNAPSHOT_LENGTH,
       ""유형 {0}에서 스냅샷 길이를 가져올 수 없습니다. 이 getter는 UNORDERED_NODE_SNAPSHOT_TYPE 유형과 ORDERED_NODE_SNAPSHOT_TYPE 유형에 적용됩니다.""},
 

  
  

 
  {
    ER_NON_ITERATOR_TYPE,
       ""비반복 유형 {0}에 대해 반복할 수 없습니다.""},
 

  
  
  

  
  

 
  {
    ER_DOC_MUTATED,
       ""결과 이후로 변경된 문서가 반환되었습니다. 반복자가 잘못되었습니다.""},
 

  
  

 
  {
    ER_INVALID_XPATH_TYPE,
       ""잘못된 XPath 유형 인자: {0}""},
 

  
  

 
  {
    ER_EMPTY_XPATH_RESULT,
       ""빈 XPath 결과 객체""},
 

  
  

 
  {
    ER_INCOMPATIBLE_TYPES,
       ""반환된 유형: {0}을(를) 지정한 유형으로 강제 변환할 수 없습니다: {1}""},
 

  
  

 
  {
    ER_NULL_RESOLVER,
       ""널 접두어 해결자로 접두어를 해결할 수 없습니다.""},
 

  
  
  

  
  

 
  {
    ER_CANT_CONVERT_TO_STRING,
       ""{0}을(를) 문자열로 변환할 수 없습니다.""},
 

  
  

  
  

 
  {
    ER_NON_SNAPSHOT_TYPE,
       ""유형 {0}에서 snapshotItem을 호출할 수 없습니다. 이 메소드는 UNORDERED_NODE_SNAPSHOT_TYPE 유형과 ORDERED_NODE_SNAPSHOT_TYPE 유형에 적용됩니다.""},
 

  
  
  
  

  
  

 
  {
    ER_WRONG_DOCUMENT,
       ""컨텍스트 노드가 이 XPathEvaluator에 바운딩된 문서에 속하지 않습니다.""},
 

  
  
  
  

 
  {
    ER_WRONG_NODETYPE ,
       ""컨텍스트 노드 유형이 지원되지 않습니다.""},
 

  
  

 
  {
    ER_XPATH_ERROR ,
       ""XPath에 알 수 없는 오류가 발생했습니다.""},
 
 

  

  
  

 
  {
    WG_LOCALE_NAME_NOT_HANDLED,
      ""format-number 기능의 로케일 이름이 아직 처리되지 않았습니다.""},
 

  
  

 
  {
    WG_PROPERTY_NOT_SUPPORTED,
      ""XSL 특성이 지원되지 않습니다: {0}""},
 

  
  

 
  {
    WG_DONT_DO_ANYTHING_WITH_NS,
      ""특성 {1}의 이름 공간 {0}에 아무 것도 수행하지 마십시오.""},
 

  
  

 
  {
    WG_SECURITY_EXCEPTION,
      ""XSL 시스템 특성 {0}에 액세스하려고 할 때 SecurityException이 발생했습니다. ""},
 

  
  

 
  {
    WG_QUO_NO_LONGER_DEFINED,
      ""이전 구문: quo(...)는 더 이상 XPath에서 정의되지 않습니다.""},
 

  
  

 
  {
    WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
      ""XPath는 nodeTest 구현을 위해 파생된 객체가 필요합니다!""},
 

  
  

 
  {
    WG_FUNCTION_TOKEN_NOT_FOUND,
      ""기능 토큰을 찾을 수 없습니다.""},
 

  
  

 
  {
    WG_COULDNOT_FIND_FUNCTION,
      ""함수 {0}을(를) 찾을 수 없습니다.""},
 

  
  

 
  {
    WG_CANNOT_MAKE_URL_FROM,
      ""{0}에서 URL을 작성할 수 없습니다.""},
 

  
  

 
  {
    WG_EXPAND_ENTITIES_NOT_SUPPORTED,
      ""-E 옵션은 DTM 구문 분석기에 대해 지원되지 않습니다.""},
 

  
  

 
  {
    WG_ILLEGAL_VARIABLE_REFERENCE,
      ""VariableReference가 컨텍스트를 벗어났거나 정의되지 않은 변수에 지정되었습니다! 이름 = {0}""},
 

  
  

 
  {
    WG_UNSUPPORTED_ENCODING, ""지원되지 않는 코드화: {0}""},
 

  
 
  { ""ui_language"", ""ko""},
  { ""help_language"", ""ko""},
  { ""language"", ""ko""},
    { ""BAD_CODE"",
      ""createMessage의 매개변수가 바운드를 벗어났습니다.""},
    { ""FORMAT_FAILED"",
      ""messageFormat 호출 시 예외 발생""},
    { ""version"", "">>>>>>> Xalan 버전 ""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""예""},
    { ""line"", ""행 
    { ""column"", ""열 
    { ""xsldone"", ""XSLProcessor: 완료""},
    { ""xpath_option"", ""xpath 옵션: ""},
    { ""optionIN"", ""   [-in inputXMLURL]""},
    { ""optionSelect"", ""   [-select xpath expression]""},
    { ""optionMatch"", 
      ""   [-match 일치 패턴 (일치 진단에 대한)]""},
    { ""optionAnyExpr"",
      ""또는 xpath 표현식이 진단 덤프를 수행합니다.""},
    { ""noParsermsg1"",
    ""XSL 프로세스가 성공하지 못했습니다.""},
    { ""noParsermsg2"",
    ""** 구문 분석기를 찾을 수 없습니다 **""},
    { ""noParsermsg3"",
    ""클래스 경로를 확인하십시오.""},
    { ""noParsermsg4"",
      ""Java용 IBM XML 구문 분석기가 없는 경우 다음에서 다운로드할 수 있습니다.""},
    { ""noParsermsg5"",
      ""IBM AlphaWorks: http:
  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""

  
  public static final String ERROR_HEADER = ""오류: "";

  
  public static final String WARNING_HEADER = ""경고: "";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}

"
org.apache.xalan.templates.StylesheetRoot,50,5,0,57,121,1069,49,24,34,0.939909297,987,0.944444444,11,0.853658537,0.079130435,3,6,18.38,10,1.6,1,"
package org.apache.xalan.templates;

import java.text.DecimalFormatSymbols;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Vector;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;

import org.apache.xalan.extensions.ExtensionNamespacesManager;
import org.apache.xalan.processor.XSLTSchema;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.ref.ExpandedNameTable;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.QName;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;


public class StylesheetRoot extends StylesheetComposed
        implements java.io.Serializable, Templates
{

  
  public StylesheetRoot(ErrorListener errorListener) throws TransformerConfigurationException
  {

    super(null);

    setStylesheetRoot(this);

    try
    {
      m_selectDefault = new XPath(""node()"", this, this, XPath.SELECT, errorListener);

      initDefaultRule(errorListener);
    }
    catch (TransformerException se)
    {
      throw new TransformerConfigurationException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_INIT_DEFAULT_TEMPLATES, null), se); 
    }
  }

  
  private Hashtable m_availElems;
  
  
  public StylesheetRoot(XSLTSchema schema, ErrorListener listener) throws TransformerConfigurationException
  {

    this(listener);
    m_availElems = schema.getElemsAvailable();
  }

  
  public boolean isRoot()
  {
    return true;
  }

  
  public Hashtable getAvailableElements()
  {
    return m_availElems;
  }
  
  private ExtensionNamespacesManager m_extNsMgr = null;
  
  
  public ExtensionNamespacesManager getExtensionNamespacesManager()
  {
     if (m_extNsMgr == null)
       m_extNsMgr = new ExtensionNamespacesManager();
     return m_extNsMgr;
  }
  
  
  public Vector getExtensions()
  {
    return m_extNsMgr != null ? m_extNsMgr.getExtensions() : null;
  }  

  

  

  
  public Transformer newTransformer()
  {
    return new TransformerImpl(this);
  }
  

  public Properties getDefaultOutputProps()
  {
    return m_outputProperties.getProperties();
  }
  
  
  public Properties getOutputProperties()
  {    
    return (Properties)getDefaultOutputProps().clone();
  }

  

  
  public void recompose() throws TransformerException
  {
    

      Vector recomposableElements = new Vector();

    

    if (null == m_globalImportList)
    {

      Vector importList = new Vector();

      addImports(this, true, importList);            

      
      
      
      
      

      m_globalImportList = new StylesheetComposed[importList.size()];

      for (int i =  0, j= importList.size() -1; i < importList.size(); i++)
      {  
        m_globalImportList[j] = (StylesheetComposed) importList.elementAt(i);
        
        
        
        m_globalImportList[j].recomposeIncludes(m_globalImportList[j]);
        
        m_globalImportList[j--].recomposeImports();        
      }
    }    
    
    int n = getGlobalImportCount();

    for (int i = 0; i < n; i++)
    {
      StylesheetComposed imported = getGlobalImport(i);
      imported.recompose(recomposableElements);
    }

    

    QuickSort2(recomposableElements, 0, recomposableElements.size() - 1);

    


    m_outputProperties = new OutputProperties(org.apache.xml.serializer.Method.UNKNOWN);

    
    m_attrSets = new Hashtable();
    m_decimalFormatSymbols = new Hashtable();
    m_keyDecls = new Vector();
    m_namespaceAliasComposed = new Hashtable();
    m_templateList = new TemplateList();
    m_variables = new Vector();

    
    
    
    
    for (int i = recomposableElements.size() - 1; i >= 0; i--)
      ((ElemTemplateElement) recomposableElements.elementAt(i)).recompose(this);
    
    initComposeState();

    
    m_templateList.compose(this);
    
    
    m_outputProperties.compose(this);
    m_outputProperties.endCompose(this);
    
    
    
    
    n = getGlobalImportCount();

    for (int i = 0; i < n; i++)
    {
      StylesheetComposed imported = this.getGlobalImport(i);
      int includedCount = imported.getIncludeCountComposed();
      for (int j = -1; j < includedCount; j++)
      {
        Stylesheet included = imported.getIncludeComposed(j);
        composeTemplates(included);
      }
    }
    
    if (m_extNsMgr != null)
      m_extNsMgr.registerUnregisteredNamespaces();

    clearComposeState();
  }

  
  void composeTemplates(ElemTemplateElement templ) throws TransformerException
  {

    templ.compose(this);

    for (ElemTemplateElement child = templ.getFirstChildElem();
            child != null; child = child.getNextSiblingElem())
    {
      composeTemplates(child);
    }
    
    templ.endCompose(this);
  }

  
  private StylesheetComposed[] m_globalImportList;

  
  protected void addImports(Stylesheet stylesheet, boolean addToList, Vector importList)
  {

    

    int n = stylesheet.getImportCount();

    if (n > 0)
    {
      for (int i = 0; i < n; i++)
      {
        Stylesheet imported = stylesheet.getImport(i);

        addImports(imported, true, importList);
      }
    }

    n = stylesheet.getIncludeCount();

    if (n > 0)
    {
      for (int i = 0; i < n; i++)
      {
        Stylesheet included = stylesheet.getInclude(i);

        addImports(included, false, importList);
      }
    }

    if (addToList)
      importList.addElement(stylesheet);

  }

  
  public StylesheetComposed getGlobalImport(int i)
  {
    return m_globalImportList[i];
  }

  
  public int getGlobalImportCount()
  {
          return (m_globalImportList!=null)
                        ? m_globalImportList.length 
                          : 1;
  }

  
  public int getImportNumber(StylesheetComposed sheet)
  {

    if (this == sheet)
      return 0;

    int n = getGlobalImportCount();

    for (int i = 0; i < n; i++)
    {
      if (sheet == getGlobalImport(i))
        return i;
    }

    return -1;
  }

  
  private OutputProperties m_outputProperties;

  
  void recomposeOutput(OutputProperties oprops)
    throws TransformerException
  {
    
    m_outputProperties.copyFrom(oprops);
  }

  
  public OutputProperties getOutputComposed()
  {

    
    
    return m_outputProperties;
  }

  
  private boolean m_outputMethodSet = false;

  
  public boolean isOutputMethodSet()
  {
    return m_outputMethodSet;
  }

  
  private Hashtable m_attrSets;

  
  void recomposeAttributeSets(ElemAttributeSet attrSet)
  {
    Vector attrSetList = (Vector) m_attrSets.get(attrSet.getName());

    if (null == attrSetList)
    {
      attrSetList = new Vector();

      m_attrSets.put(attrSet.getName(), attrSetList);
    }

    attrSetList.addElement(attrSet);
  }

  
  public Vector getAttributeSetComposed(QName name)
          throws ArrayIndexOutOfBoundsException
  {
    return (Vector) m_attrSets.get(name);
  }

  
  private Hashtable m_decimalFormatSymbols;

  
  void recomposeDecimalFormats(DecimalFormatProperties dfp)
  {
    DecimalFormatSymbols oldDfs =
                  (DecimalFormatSymbols) m_decimalFormatSymbols.get(dfp.getName());
    if (null == oldDfs)
    {
      m_decimalFormatSymbols.put(dfp.getName(), dfp.getDecimalFormatSymbols());
    }
    else if (!dfp.getDecimalFormatSymbols().equals(oldDfs))
    {
      String themsg;
      if (dfp.getName().equals(new QName("""")))
      {
        
        themsg = XSLMessages.createWarning(
                          XSLTErrorResources.WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
                          new Object[0]);
      }
      else
      {
        
        themsg = XSLMessages.createWarning(
                          XSLTErrorResources.WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
                          new Object[] {dfp.getName()});
      }

      error(themsg);   
    }

  }

  
  public DecimalFormatSymbols getDecimalFormatComposed(QName name)
  {
    return (DecimalFormatSymbols) m_decimalFormatSymbols.get(name);
  }

  
  private Vector m_keyDecls;

  
  void recomposeKeys(KeyDeclaration keyDecl)
  {
    m_keyDecls.addElement(keyDecl);
  }

  
  public Vector getKeysComposed()
  {
    return m_keyDecls;
  }

  
  private Hashtable m_namespaceAliasComposed;

  
  void recomposeNamespaceAliases(NamespaceAlias nsAlias)
  {
    m_namespaceAliasComposed.put(nsAlias.getStylesheetNamespace(),
                                 nsAlias);
  }

  
  public NamespaceAlias getNamespaceAliasComposed(String uri)
  {
    return (NamespaceAlias) ((null == m_namespaceAliasComposed) 
                    ? null : m_namespaceAliasComposed.get(uri));
  }

  
  private TemplateList m_templateList;

  
  void recomposeTemplates(ElemTemplate template)
  {
    m_templateList.setTemplate(template);
  }

  
  public final TemplateList getTemplateListComposed()
  {
    return m_templateList;
  }

  
  public final void setTemplateListComposed(TemplateList templateList)
  {
    m_templateList = templateList;
  }

  
  public ElemTemplate getTemplateComposed(XPathContext xctxt,
                                          int targetNode,
                                          QName mode,
                                          boolean quietConflictWarnings,
                                          DTM dtm)
            throws TransformerException
  {
    return m_templateList.getTemplate(xctxt, targetNode, mode, 
                                      quietConflictWarnings,
                                      dtm);
  }
  
  
  public ElemTemplate getTemplateComposed(XPathContext xctxt,
                                          int targetNode,
                                          QName mode,
                                          int maxImportLevel, int endImportLevel,
                                          boolean quietConflictWarnings,
                                          DTM dtm)
            throws TransformerException
  {
    return m_templateList.getTemplate(xctxt, targetNode, mode, 
                                      maxImportLevel, endImportLevel,
                                      quietConflictWarnings,
                                      dtm);
  }

  
  public ElemTemplate getTemplateComposed(QName qname)
  {
    return m_templateList.getTemplate(qname);
  }
  
  
  private Vector m_variables;

  
  void recomposeVariables(ElemVariable elemVar)
  {
    
    if (getVariableOrParamComposed(elemVar.getName()) == null)
    {
      elemVar.setIsTopLevel(true);        
      elemVar.setIndex(m_variables.size());
      m_variables.addElement(elemVar);
    }
  }

  
  public ElemVariable getVariableOrParamComposed(QName qname)
  {
    if (null != m_variables)
    {
      int n = m_variables.size();

      for (int i = 0; i < n; i++)
      {
        ElemVariable var = (ElemVariable)m_variables.elementAt(i);
        if(var.getName().equals(qname))
          return var;
      }
    }

    return null;
  }

  
  public Vector getVariablesAndParamsComposed()
  {
    return m_variables;
  }

  
  private TemplateList m_whiteSpaceInfoList;

  
  void recomposeWhiteSpaceInfo(WhiteSpaceInfo wsi)
  {
    if (null == m_whiteSpaceInfoList)
      m_whiteSpaceInfoList = new TemplateList();

    m_whiteSpaceInfoList.setTemplate(wsi);
  }

  
  public boolean shouldCheckWhitespace()
  {
    return null != m_whiteSpaceInfoList;
  }

  
  public WhiteSpaceInfo getWhiteSpaceInfo(
          XPathContext support, int targetElement, DTM dtm) throws TransformerException
  {

    if (null != m_whiteSpaceInfoList)
      return (WhiteSpaceInfo) m_whiteSpaceInfoList.getTemplate(support,
              targetElement, null, false, dtm);
    else
      return null;
  }
  
  
  public boolean shouldStripWhiteSpace(
          XPathContext support, int targetElement) throws TransformerException
  {
    if (null != m_whiteSpaceInfoList)
    {
      while(DTM.NULL != targetElement)
      {
        DTM dtm = support.getDTM(targetElement);
        WhiteSpaceInfo info = (WhiteSpaceInfo) m_whiteSpaceInfoList.getTemplate(support,
                targetElement, null, false, dtm);
        if(null != info)
          return info.getShouldStripSpace();
        
        int parent = dtm.getParent(targetElement);
        if(DTM.NULL != parent && DTM.ELEMENT_NODE == dtm.getNodeType(parent))
          targetElement = parent;
        else
          targetElement = DTM.NULL;
      }
    }
    return false;
  }
  
  
  public boolean canStripWhiteSpace()
  {
    return (null != m_whiteSpaceInfoList);
  }
  


  
  private ElemTemplate m_defaultTextRule;

  
  public final ElemTemplate getDefaultTextRule()
  {
    return m_defaultTextRule;
  }

  
  private ElemTemplate m_defaultRule;

  
  public final ElemTemplate getDefaultRule()
  {
    return m_defaultRule;
  }

  
  private ElemTemplate m_defaultRootRule;

  
  public final ElemTemplate getDefaultRootRule()
  {
    return m_defaultRootRule;
  }
  
  
  private ElemTemplate m_startRule;

  
  public final ElemTemplate getStartRule()
  {
    return m_startRule;
  }


  
  XPath m_selectDefault;

  
  private void initDefaultRule(ErrorListener errorListener) throws TransformerException
  {

    
    m_defaultRule = new ElemTemplate();

    m_defaultRule.setStylesheet(this);

    XPath defMatch = new XPath(""*"", this, this, XPath.MATCH, errorListener);

    m_defaultRule.setMatch(defMatch);

    ElemApplyTemplates childrenElement = new ElemApplyTemplates();

    childrenElement.setIsDefaultTemplate(true);
    childrenElement.setSelect(m_selectDefault);
    m_defaultRule.appendChild(childrenElement);
    
    m_startRule = m_defaultRule;

    
    m_defaultTextRule = new ElemTemplate();

    m_defaultTextRule.setStylesheet(this);

    defMatch = new XPath(""text() | @*"", this, this, XPath.MATCH, errorListener);

    m_defaultTextRule.setMatch(defMatch);

    ElemValueOf elemValueOf = new ElemValueOf();

    m_defaultTextRule.appendChild(elemValueOf);

    XPath selectPattern = new XPath(""."", this, this, XPath.SELECT, errorListener);

    elemValueOf.setSelect(selectPattern);

    
    m_defaultRootRule = new ElemTemplate();

    m_defaultRootRule.setStylesheet(this);

    defMatch = new XPath(""/"", this, this, XPath.MATCH, errorListener);

    m_defaultRootRule.setMatch(defMatch);

    childrenElement = new ElemApplyTemplates();

    childrenElement.setIsDefaultTemplate(true);
    m_defaultRootRule.appendChild(childrenElement);
    childrenElement.setSelect(m_selectDefault);
  }

  

  private void QuickSort2(Vector v, int lo0, int hi0)
    {
      int lo = lo0;
      int hi = hi0;

      if ( hi0 > lo0)
      {
        
        
        ElemTemplateElement midNode = (ElemTemplateElement) v.elementAt( ( lo0 + hi0 ) / 2 );

        
        while( lo <= hi )
        {
          
          
          while( (lo < hi0) && (((ElemTemplateElement) v.elementAt(lo)).compareTo(midNode) < 0) )
          {
            ++lo;
          } 

          
          
          while( (hi > lo0) && (((ElemTemplateElement) v.elementAt(hi)).compareTo(midNode) > 0) )          {
            --hi;
          }

          
          if( lo <= hi )
          {
            ElemTemplateElement node = (ElemTemplateElement) v.elementAt(lo);
            v.setElementAt(v.elementAt(hi), lo);
            v.setElementAt(node, hi);

            ++lo;
            --hi;
          }
        }

        
        
        if( lo0 < hi )
        {
          QuickSort2( v, lo0, hi );
        }

        
        
        if( lo < hi0 )
        {
          QuickSort2( v, lo, hi0 );
        }
      }
    } 
    
    private ComposeState m_composeState;
    
    
    void initComposeState()
    {
      m_composeState = new ComposeState();
    }

    
    ComposeState getComposeState()
    {
      return m_composeState;
    }
    
    
    private void clearComposeState()
    {
      m_composeState = null;
    }
    
    
    class ComposeState
    {
      ComposeState()
      {
        int size = m_variables.size();
        for (int i = 0; i < size; i++) 
        {
          ElemVariable ev = (ElemVariable)m_variables.elementAt(i);
          m_variableNames.addElement(ev.getName());
        }
        
      }
      
      private ExpandedNameTable m_ent = new ExpandedNameTable();
      
      
      public int getQNameID(QName qname)
      {
        
        return m_ent.getExpandedTypeID(qname.getNamespace(), 
                                       qname.getLocalName(),
                                       
                                       
                                       org.apache.xml.dtm.DTM.ELEMENT_NODE);
      }
      
      
      private java.util.Vector m_variableNames = new java.util.Vector();
            
      
      int addVariableName(final org.apache.xml.utils.QName qname)
      {
        int pos = m_variableNames.size();
        m_variableNames.addElement(qname);
        int frameSize = m_variableNames.size() - getGlobalsSize();
        if(frameSize > m_maxStackFrameSize)
          m_maxStackFrameSize++;
        return pos;
      }
      
      void resetStackFrameSize()
      {
        m_maxStackFrameSize = 0;
      }
      
      int getFrameSize()
      {
        return m_maxStackFrameSize;
      }
      
      
      int getCurrentStackFrameSize()
      {
        return m_variableNames.size();
      }
      
      
      void setCurrentStackFrameSize(int sz)
      {
        m_variableNames.setSize(sz);
      }
      
      int getGlobalsSize()
      {
        return m_variables.size();
      }
      
      IntStack m_marks = new IntStack();
      
      void pushStackMark()
      {
        m_marks.push(getCurrentStackFrameSize());
      }
      
      void popStackMark()
      {
        int mark = m_marks.pop();
        setCurrentStackFrameSize(mark);
      }
      
      
      java.util.Vector getVariableNames()
      {
        return m_variableNames;
      }
      
      private int m_maxStackFrameSize;

    }
}
"
org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl,21,3,0,2,43,0,0,2,19,0.5,498,1.0,0,0.5,0.220238095,1,2,22.47619048,3,1.0476,0,"


package org.apache.xalan.xsltc.trax;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TemplatesHandler;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.xml.sax.XMLFilter;


public class SmartTransformerFactoryImpl extends SAXTransformerFactory 
{

    private TransformerFactory _xsltcFactory = null;
    private TransformerFactory _xalanFactory = null;
    private TransformerFactory _currFactory = null;
    private ErrorListener      _errorlistener = null;
    private URIResolver        _uriresolver = null;

    
    public SmartTransformerFactoryImpl() { }

    private void createXSLTCTransformerFactory() {
	
 	final String xsltcMessage =
	    ""org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl ""+
            ""could not create an ""+
            ""org.apache.xalan.xsltc.trax.TransformerFactoryImpl."";
	
	
	try {
	    Class xsltcFactClass = Class.forName(
		""org.apache.xalan.xsltc.trax.TransformerFactoryImpl"");
	    _xsltcFactory = (org.apache.xalan.xsltc.trax.TransformerFactoryImpl)
		xsltcFactClass.newInstance();
	} 
	catch (ClassNotFoundException e) {
	    System.err.println(xsltcMessage);
	} 
 	catch (InstantiationException e) {
	    System.err.println(xsltcMessage);
	}
 	catch (IllegalAccessException e) {
	    System.err.println(xsltcMessage);
	}
	_currFactory = _xsltcFactory;
    }

    private void createXalanTransformerFactory() {
 	final String xalanMessage =
	    ""org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl ""+
	    ""could not create an ""+
	    ""org.apache.xalan.processor.TransformerFactoryImpl."";
	
	try {
	    Class xalanFactClass = Class.forName(
		""org.apache.xalan.processor.TransformerFactoryImpl"");
	    _xalanFactory = (SAXTransformerFactory)
		xalanFactClass.newInstance();
	} 
	catch (ClassNotFoundException e) {
	    System.err.println(xalanMessage);
        }
 	catch (InstantiationException e) {
	    System.err.println(xalanMessage);
	}
 	catch (IllegalAccessException e) {
	    System.err.println(xalanMessage);
	}
	_currFactory = _xalanFactory;
    }

    public void setErrorListener(ErrorListener listener) 
	throws IllegalArgumentException 
    {
	_errorlistener = listener;
    }

    public ErrorListener getErrorListener() { 
	return _errorlistener;
    }

    public Object getAttribute(String name) 
	throws IllegalArgumentException 
    {
	
	if ((name.equals(""translet-name"")) || (name.equals(""debug""))) { 
	    if (_xsltcFactory == null) {
                createXSLTCTransformerFactory();
            }
            return _xsltcFactory.getAttribute(name); 
        }
        else {
	    if (_xalanFactory == null) {
	        createXalanTransformerFactory();
	    } 
	    return _xalanFactory.getAttribute(name);
        }
    }

    public void setAttribute(String name, Object value) 
	throws IllegalArgumentException { 
	
	if ((name.equals(""translet-name"")) || (name.equals(""debug""))) { 
	    if (_xsltcFactory == null) {
                createXSLTCTransformerFactory();
            }
            _xsltcFactory.setAttribute(name, value); 
        }
        else {
	    if (_xalanFactory == null) {
	        createXalanTransformerFactory();
	    } 
	    _xalanFactory.setAttribute(name, value);
        }
    }

    
    public boolean getFeature(String name) { 
	
        String[] features = {
            DOMSource.FEATURE,
            DOMResult.FEATURE,
            SAXSource.FEATURE,
            SAXResult.FEATURE,
            StreamSource.FEATURE,
            StreamResult.FEATURE
        };

        
        for (int i=0; i<features.length; i++) {
            if (name.equals(features[i])) return true;
	}

        
        return false;
    }

    public URIResolver getURIResolver() {
	return _uriresolver; 
    } 

    public void setURIResolver(URIResolver resolver) {
	_uriresolver = resolver;
    }

    public Source getAssociatedStylesheet(Source source, String media,
					  String title, String charset)
	throws TransformerConfigurationException 
    {
	if (_currFactory == null) {
            createXSLTCTransformerFactory();
        }
	return _currFactory.getAssociatedStylesheet(source, media,
		title, charset);
    }

    
    public Transformer newTransformer()
	throws TransformerConfigurationException 
    {
	if (_xalanFactory == null) {
            createXalanTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xalanFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xalanFactory.setURIResolver(_uriresolver);
	}
 	_currFactory = _xalanFactory;	 
	return _currFactory.newTransformer(); 
    }

    
    public Transformer newTransformer(Source source) throws
	TransformerConfigurationException 
    {
        if (_xalanFactory == null) {
            createXalanTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xalanFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xalanFactory.setURIResolver(_uriresolver);
	}
 	_currFactory = _xalanFactory;	 
	return _currFactory.newTransformer(source); 
    }

    
    public Templates newTemplates(Source source)
	throws TransformerConfigurationException 
    {
        if (_xsltcFactory == null) {
            createXSLTCTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xsltcFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xsltcFactory.setURIResolver(_uriresolver);
	}
 	_currFactory = _xsltcFactory;	 
	return _currFactory.newTemplates(source); 
    }

    
    public TemplatesHandler newTemplatesHandler() 
	throws TransformerConfigurationException 
    {
        if (_xsltcFactory == null) {
            createXSLTCTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xsltcFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xsltcFactory.setURIResolver(_uriresolver);
	}
	return ((SAXTransformerFactory)_xsltcFactory).newTemplatesHandler();
    }

    
    public TransformerHandler newTransformerHandler() 
	throws TransformerConfigurationException 
    {
        if (_xalanFactory == null) {
            createXalanTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xalanFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xalanFactory.setURIResolver(_uriresolver);
	}
	return ((SAXTransformerFactory)_xalanFactory).newTransformerHandler(); 
    }

    
    public TransformerHandler newTransformerHandler(Source src) 
	throws TransformerConfigurationException 
    {
        if (_xalanFactory == null) {
            createXalanTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xalanFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xalanFactory.setURIResolver(_uriresolver);
	}
	return 
            ((SAXTransformerFactory)_xalanFactory).newTransformerHandler(src); 
    }


    
    public TransformerHandler newTransformerHandler(Templates templates) 
	throws TransformerConfigurationException  
    {
        if (_xsltcFactory == null) {
            createXSLTCTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xsltcFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xsltcFactory.setURIResolver(_uriresolver);
	}
        return 
        ((SAXTransformerFactory)_xsltcFactory).newTransformerHandler(templates);
    }


    
    public XMLFilter newXMLFilter(Source src) 
	throws TransformerConfigurationException {
        if (_xsltcFactory == null) {
            createXSLTCTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xsltcFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xsltcFactory.setURIResolver(_uriresolver);
	}
	Templates templates = _xsltcFactory.newTemplates(src);
	if (templates == null ) return null;
	return newXMLFilter(templates); 
    }

    
    public XMLFilter newXMLFilter(Templates templates) 
	throws TransformerConfigurationException {
	try {
            return new org.apache.xalan.xsltc.trax.TrAXFilter(templates);
        }
        catch(TransformerConfigurationException e1) {
            if (_xsltcFactory == null) {
                createXSLTCTransformerFactory();
            }
	    ErrorListener errorListener = _xsltcFactory.getErrorListener();
            if(errorListener != null) {
                try {
                    errorListener.fatalError(e1);
                    return null;
                }
                catch( TransformerException e2) {
                    new TransformerConfigurationException(e2);
                }
            }
            throw e1;
        }
    }
}
"
org.apache.xml.utils.ThreadControllerWrapper,5,1,0,3,9,0,2,1,4,0.25,27,0.0,1,0.0,0.3,0,0,4.2,1,0.6,0,"
package org.apache.xml.utils;


public class ThreadControllerWrapper
{
  
  
  static ThreadController m_tpool = new ThreadController();

  
  public static void setThreadController(ThreadController tpool)
  {
    m_tpool = tpool;
  }
  
  public static Thread runThread(Runnable runnable, int priority)
  {
    return m_tpool.run(runnable, priority);
  }
  
  public static void waitThread(Thread worker, Runnable task)
    throws InterruptedException
  {
    m_tpool.waitThread(worker, task);
  }
  
  
  public static class ThreadController
  {

    
    public Thread run(Runnable task, int priority)
    {

      Thread t = new Thread(task);

      t.start();

      
      
      return t;
    }

    
    public void waitThread(Thread worker, Runnable task)
            throws InterruptedException
    {

      
      worker.join();
    }
  }
 
}"
org.apache.xml.res.XMLErrorResources_zh_CN,3,4,0,1,4,1,0,1,2,1.3,875,0.0,0,0.976190476,1.0,0,0,289.0,1,0.3333,0,"
package org.apache.xml.res;



public class XMLErrorResources_zh_CN extends XMLErrorResources
{

  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },


  
  


  {
    ER_FUNCTION_NOT_SUPPORTED, ""函数不受支持！ ""},

  
  
  


  {
    ER_CANNOT_OVERWRITE_CAUSE,
			""无法覆写事由 ""},

  
   
  


  {
    ER_NO_DEFAULT_IMPL,
         ""未找到缺省执行  ""},

  
   
  


  {
    ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
       ""目前不支持  ChunkedIntArray({0}) ""},

  
   
  


  {
    ER_OFFSET_BIGGER_THAN_SLOT,
       ""偏移比槽略大 ""},

  
   
  


  {
    ER_COROUTINE_NOT_AVAIL,
       ""协同程序不可用， id={0}""},

  
   
  


  {
    ER_COROUTINE_CO_EXIT,
       ""CoroutineManager 接收到  co_exit() 请求 ""},

  
   
  


  {
    ER_COJOINROUTINESET_FAILED,
       ""co_joinCoroutineSet() 失败 ""},

  
   
  


  {
    ER_COROUTINE_PARAM,
       ""协同程序参数错误  ({0})""},

  
   
  


  {
    ER_PARSER_DOTERMINATE_ANSWERS,
       ""
UNEXPECTED: 分析器  doTerminate 回答  {0}""},

  
   
  


  {
    ER_NO_PARSE_CALL_WHILE_PARSING,
       ""当分析时可能不会调用分析函数 ""},

  
   
  


  {
    ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""错误：在  axis {0} 中输入的迭代程序无法执行 ""},

  
   
  


  {
    ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""错误：在  axis {0} 中的迭代程序无法执行 ""},

  
   
  


  {
    ER_ITERATOR_CLONE_NOT_SUPPORTED,
       ""不支持复制迭代程序 ""},

  
   
  


  {
    ER_UNKNOWN_AXIS_TYPE,
       ""未知的  axis 遍历类型： {0}""},

  
   
  


  {
    ER_AXIS_NOT_SUPPORTED,
       ""不支持  axis 遍历器： {0}""},

  
   
  


  {
    ER_NO_DTMIDS_AVAIL,
       ""无法使用多个  DTM ID""},

  
   
  


  {
    ER_NOT_SUPPORTED,
       ""不支持： {0}""},

  
   
  


  {
    ER_NODE_NON_NULL,
       ""节点在  getDTMHandleFromNode 中必须非空 ""},

  
   
  


  {
    ER_COULD_NOT_RESOLVE_NODE,
       ""无法将节点解析为句柄 ""},

  
   
  


  {
    ER_STARTPARSE_WHILE_PARSING,
       ""在分析时可能会调用  startParse ""},

  
   
  


  {
    ER_STARTPARSE_NEEDS_SAXPARSER,
       ""startParse 需要一个非空的  SAXParser""},

  
   
  


  {
    ER_COULD_NOT_INIT_PARSER,
       ""无法初始化分析器 ""},

  
   
  


  {
    ER_EXCEPTION_CREATING_POOL,
       ""创建池的新实例时出现异常 ""},

  
   
  


  {
    ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
       ""路径包含无效的换码序列 ""},

  
   
  


  {
    ER_SCHEME_REQUIRED,
       ""需要配置！ ""},

  
   
  


  {
    ER_NO_SCHEME_IN_URI,
       ""在  URI 中未找到配置： {0}""},

  
   
  


  {
    ER_NO_SCHEME_INURI,
       ""在  URI 中未找到配置 ""},

  
   
  


  {
    ER_PATH_INVALID_CHAR,
       ""路径包含无效的字符： {0}""},

  
   
  


  {
    ER_SCHEME_FROM_NULL_STRING,
       ""无法在空的字符串中设置配置 ""},

  
   
  


  {
    ER_SCHEME_NOT_CONFORMANT,
       ""配置不一致。 ""},

  
   
  


  {
    ER_HOST_ADDRESS_NOT_WELLFORMED,
       ""主机地址的格式不正确 ""},

  
   
  


  {
    ER_PORT_WHEN_HOST_NULL,
       ""当主机为空时无法设置端口 ""},

  
   
  


  {
    ER_INVALID_PORT,
       ""无效的端口号 ""},

  
   
  


  {
    ER_FRAG_FOR_GENERIC_URI,
       ""仅在一般的  URI 中设置段 ""},

  
   
  


  {
    ER_FRAG_WHEN_PATH_NULL,
       ""当路径为空时无法设置段 ""},

  
   
  


  {
    ER_FRAG_INVALID_CHAR,
       ""段中包含无效字符 ""},

  
 
  
   
  


  {
    ER_PARSER_IN_USE,
        ""分析器正在使用 ""},

  
   
  


  {
    ER_CANNOT_CHANGE_WHILE_PARSING,
        ""在分析时无法改变  {0} {1}""},

  
   
  


  {
    ER_SELF_CAUSATION_NOT_PERMITTED,
        ""不允许自身引起结果 ""},

  
   
  


  {
    ER_NO_USERINFO_IF_NO_HOST,
        ""如果未指定主机，可能不会指定用户信息 ""},

  
   
  


  {
    ER_NO_PORT_IF_NO_HOST,
        ""如果未指定主机，可能不会指定端口 ""},

  
   
  


  {
    ER_NO_QUERY_STRING_IN_PATH,
        ""在路径和查询字符串中，无法指定查询字符串  ""},

  
   
  


  {
    ER_NO_FRAGMENT_STRING_IN_PATH,
        ""在路径和段中无法指定段  ""},

  
   
  


  {
    ER_CANNOT_INIT_URI_EMPTY_PARMS,
        ""无法使用空的参数初始化  URI""},

  
  
  


  {
    ER_METHOD_NOT_SUPPORTED,
        ""方法仍不受支持  ""},


  
  


  {
    ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
     ""当前无法重新启动  IncrementalSAXSource_Filter""},

  
  
  


  {
    ER_XMLRDR_NOT_BEFORE_STARTPARSE,
     ""XMLReader 未在  startParse 请求之前出现 ""},



  

  {
    ER_AXIS_TRAVERSER_NOT_SUPPORTED,
     ""轴遍历程序不受支持： {0}""},



  

  {
    ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
     ""用空  PrintWriter 来创建  ListingErrorHandler！ ""},


  

  {
    ER_SYSTEMID_UNKNOWN,
     ""未知的  SystemId""},


  
  

  {
    ER_LOCATION_UNKNOWN,
     ""未知的错误位置 ""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""必须解决名称空间的前缀：{0}""},


  
  


  {
    ER_CREATEDOCUMENT_NOT_SUPPORTED,
      ""XPathContext 中不支持 createDocument()！""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT,
      ""子属性没有属主文档！""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
      ""子属性没有属主文档元素！""},


  
  


  {
    ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
      ""警告：不能输出文档元素之前的文字！忽略...""},


  
  


  {
    ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
      ""DOM 上不能有多个根！""},

  
   
  


  {
    ER_ARG_LOCALNAME_NULL,
       ""变量 'localName' 为空""},


  
  
  

  
  


  {
    ER_ARG_LOCALNAME_INVALID,
       ""QNAME 中的 Localname 应该是一个有效的 NCName""},

  
  
  
  

  
  


  {
    ER_ARG_PREFIX_INVALID,
       ""QNAME 中的前缀应该是一个有效的 NCName""},

  { ""BAD_CODE"",
      ""createMessage 参数超过范围 ""},
  { ""FORMAT_FAILED"",
      ""调用  messageFormat 时出现意外情况   ""},
  { ""line"", ""行  #""},
  { ""column"", ""列  #""}
  
  };

  
  public Object[][] getContents()
  {
    return contents;
  }

}"
org.apache.xpath.axes.ContextNodeList,12,1,0,1,12,66,1,0,12,2.0,12,0.0,0,0.0,0.444444444,0,0,0.0,1,1.0,1,"
package org.apache.xpath.axes;

import org.w3c.dom.Node;
import org.w3c.dom.traversal.NodeIterator;


public interface ContextNodeList
{

  
  public Node getCurrentNode();

  
  public int getCurrentPos();

  
  public void reset();

  
  public void setShouldCacheNodes(boolean b);

  
  public void runTo(int index);

  
  public void setCurrentPos(int i);

  
  public int size();

  
  public boolean isFresh();

  
  public NodeIterator cloneWithReset() throws CloneNotSupportedException;

  
  public Object clone() throws CloneNotSupportedException;

  
  public int getLast();

  
  public void setLast(int last);
}
"
org.apache.xalan.xsltc.compiler.util.NodeSortRecordGenerator,3,4,0,5,5,1,1,4,3,1.0,25,1.0,0,0.975903614,0.466666667,0,0,6.666666667,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.Instruction;
import org.apache.xalan.xsltc.compiler.Stylesheet;


public final class NodeSortRecordGenerator extends ClassGenerator {
    private static final int TRANSLET_INDEX = 4;   
    private final Instruction _aloadTranslet;

    public NodeSortRecordGenerator(String className, String superClassName,
				   String fileName,
				   int accessFlags, String[] interfaces,
				   Stylesheet stylesheet) {
	super(className, superClassName, fileName,
	      accessFlags, interfaces, stylesheet);
	_aloadTranslet = new ALOAD(TRANSLET_INDEX);
    }
    
    
    public Instruction loadTranslet() {
	return _aloadTranslet;
    }

    
    public boolean isExternal() {
	return true;
    }

}
"
org.apache.xalan.xsltc.compiler.CurrentCall,2,4,0,7,6,1,0,7,2,2.0,13,0.0,0,0.989690722,0.625,2,4,5.5,1,0.5,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;

final class CurrentCall extends FunctionCall {
    public CurrentCall(QName fname) {
	super(fname);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	methodGen.getInstructionList().append(methodGen.loadCurrentNode());
    }
}
"
org.apache.xalan.xsltc.compiler.CeilingCall,2,4,0,10,10,1,0,10,2,2.0,31,0.0,0,0.989690722,0.6,2,5,14.5,1,0.5,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;

final class CeilingCall extends FunctionCall {
    public CeilingCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	argument(0).translate(classGen, methodGen);
	il.append(new INVOKESTATIC(cpg.addMethodref(MATH_CLASS,
						    ""ceil"", ""(D)D"")));
    }
}
"
org.apache.xalan.xsltc.compiler.When,7,3,0,14,25,0,2,13,6,0.5,118,1.0,1,0.903225806,0.285714286,1,6,15.57142857,5,1.4286,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.BooleanType;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class When extends Instruction {

    private Expression _test;
    private boolean _ignore = false;

    public void display(int indent) {
	indent(indent);
	Util.println(""When"");
	indent(indent + IndentIncrement);
	System.out.print(""test "");
	Util.println(_test.toString());
	displayContents(indent + IndentIncrement);
    }
		
    public Expression getTest() {
	return _test;
    }

    public boolean ignore() {
	return(_ignore);
    }

    public void parseContents(Parser parser) {
	_test = parser.parseExpression(this, ""test"", null);

	
	
	Object result = _test.evaluateAtCompileTime();
	if (result != null && result instanceof Boolean) {
	    _ignore = !((Boolean) result).booleanValue();
	}

	parseChildren(parser);

	
	if (_test.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""test"");
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	if (_test.typeCheck(stable) instanceof BooleanType == false) {
	    _test = new CastExpr(_test, Type.Boolean);
	}
	
	if (!_ignore) {
	    typeCheckContents(stable);
	}

	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ErrorMsg msg = new ErrorMsg(ErrorMsg.STRAY_WHEN_ERR, this);
	getParser().reportError(Constants.ERROR, msg);
    }
}
"
org.apache.xml.utils.ObjectStack,12,2,0,5,20,24,4,1,12,2.0,161,0.0,0,0.653846154,0.395833333,1,14,12.41666667,2,1.0,1,"
package org.apache.xml.utils;

import java.util.EmptyStackException;


public class ObjectStack extends ObjectVector
{

  
  public ObjectStack()
  {
    super();
  }

  
  public ObjectStack(int blocksize)
  {
    super(blocksize);
  }

  
  public ObjectStack (ObjectStack v)
  {
  	super(v);
  }
  
  
  public Object push(Object i)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      Object newMap[] = new Object[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = i;

    m_firstFree++;

    return i;
  }

  
  public Object pop()
  {
    Object val = m_map[--m_firstFree];
    m_map[m_firstFree] = null;
    
    return val;
  }

  

  public void quickPop(int n)
  {
    m_firstFree -= n;
  }

  
  public Object peek()
  {
    try {
      return m_map[m_firstFree - 1];
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      throw new EmptyStackException();
    }
  }

  
  public Object peek(int n)
  {
    try {
      return m_map[m_firstFree-(1+n)];
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      throw new EmptyStackException();
    }
  }

  
  public void setTop(Object val)
  {
    try {
      m_map[m_firstFree - 1] = val;
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      throw new EmptyStackException();
    }
  }

  
  public boolean empty()
  {
    return m_firstFree == 0;
  }

  
  public int search(Object o)
  {

    int i = lastIndexOf(o);

    if (i >= 0)
    {
      return size() - i;
    }

    return -1;
  }

  
  public Object clone()
    throws CloneNotSupportedException
  {
  	return (ObjectStack) super.clone();
  }  
  
}
"
org.apache.xpath.functions.FuncTrue,3,3,0,4,4,3,0,4,3,2.0,9,0.0,0,0.95,0.5,1,6,2.0,1,0.6667,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class FuncTrue extends Function
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return XBoolean.S_TRUE;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }

}
"
org.apache.xalan.templates.ElemForEach,18,3,1,24,81,79,5,20,17,0.735294118,474,0.5,1,0.920187793,0.136752137,2,6,25.11111111,4,1.2778,2,"
package org.apache.xalan.templates;

import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.NodeSorter;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.utils.IntStack;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;


public class ElemForEach extends ElemTemplateElement implements ExpressionOwner
{
  
  static final boolean DEBUG = false;
  
  
  public boolean m_doc_cache_off=false;
  
  
  public ElemForEach(){}

  
  protected Expression m_selectExpression = null;

  
  public void setSelect(XPath xpath)
  {
    m_selectExpression = xpath.getExpression();
  }

  
  public Expression getSelect()
  {
    return m_selectExpression;
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {

    super.compose(sroot);

    int length = getSortElemCount();

    for (int i = 0; i < length; i++)
    {
      getSortElem(i).compose(sroot);
    }

    java.util.Vector vnames = sroot.getComposeState().getVariableNames();

    if (null != m_selectExpression)
      m_selectExpression.fixupVariables(
        vnames, sroot.getComposeState().getGlobalsSize());
    else
    {
      m_selectExpression =
        getStylesheetRoot().m_selectDefault.getExpression();
    }
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    int length = getSortElemCount();

    for (int i = 0; i < length; i++)
    {
      getSortElem(i).endCompose(sroot);
    }
    
    super.endCompose(sroot);
  }


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  protected Vector m_sortElems = null;

  
  public int getSortElemCount()
  {
    return (m_sortElems == null) ? 0 : m_sortElems.size();
  }

  
  public ElemSort getSortElem(int i)
  {
    return (ElemSort) m_sortElems.elementAt(i);
  }

  
  public void setSortElem(ElemSort sortElem)
  {

    if (null == m_sortElems)
      m_sortElems = new Vector();

    m_sortElems.addElement(sortElem);
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_FOREACH;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_FOREACH_STRING;
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    transformer.pushCurrentTemplateRuleIsNull(true);    
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    try
    {
      transformSelectedNodes(transformer);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
	    transformer.getTraceManager().fireTraceEndEvent(this); 
      transformer.popCurrentTemplateRuleIsNull();
    }
  }

  
  protected ElemTemplateElement getTemplateMatch()
  {
    return this;
  }

  
  public DTMIterator sortNodes(
          XPathContext xctxt, Vector keys, DTMIterator sourceNodes)
            throws TransformerException
  {

    NodeSorter sorter = new NodeSorter(xctxt);
    sourceNodes.setShouldCacheNodes(true);
    sourceNodes.runTo(-1);
    xctxt.pushContextNodeList(sourceNodes);

    try
    {
      sorter.sort(sourceNodes, keys, xctxt);
      sourceNodes.setCurrentPos(0);
    }
    finally
    {
      xctxt.popContextNodeList();
    }

    return sourceNodes;
  }

  
  public void transformSelectedNodes(TransformerImpl transformer)
          throws TransformerException
  {

    final XPathContext xctxt = transformer.getXPathContext();
    final int sourceNode = xctxt.getCurrentNode();
    DTMIterator sourceNodes = m_selectExpression.asIterator(xctxt,
            sourceNode);

    try
    {

      final Vector keys = (m_sortElems == null)
              ? null
              : transformer.processSortKeys(this, sourceNode);

      
      if (null != keys)
        sourceNodes = sortNodes(xctxt, keys, sourceNodes);

      if (TransformerImpl.S_DEBUG)
      {
        transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                ""select"", new XPath(m_selectExpression),
                new org.apache.xpath.objects.XNodeSet(sourceNodes));
      }


      xctxt.pushCurrentNode(DTM.NULL);

      IntStack currentNodes = xctxt.getCurrentNodeStack();

      xctxt.pushCurrentExpressionNode(DTM.NULL);

      IntStack currentExpressionNodes = xctxt.getCurrentExpressionNodeStack();

      xctxt.pushSAXLocatorNull();
      xctxt.pushContextNodeList(sourceNodes);
      transformer.pushElemTemplateElement(null);

      
      
      DTM dtm = xctxt.getDTM(sourceNode);
      int docID = sourceNode & DTMManager.IDENT_DTM_DEFAULT;
      int child;

      while (DTM.NULL != (child = sourceNodes.nextNode()))
      {
        currentNodes.setTop(child);
        currentExpressionNodes.setTop(child);

        if ((child & DTMManager.IDENT_DTM_DEFAULT) != docID)
        {
          dtm = xctxt.getDTM(child);
          docID = child & DTMManager.IDENT_DTM_DEFAULT;
        }

        
        final int nodeType = dtm.getNodeType(child); 

        
        if (TransformerImpl.S_DEBUG)
        {
           transformer.getTraceManager().fireTraceEvent(this);
        }

        
        
        
        for (ElemTemplateElement t = this.m_firstChild; t != null;
             t = t.m_nextSibling)
        {
          xctxt.setSAXLocator(t);
          transformer.setCurrentElement(t);
          t.execute(transformer);
        }
        
        if (TransformerImpl.S_DEBUG)
        {
         
          
          transformer.setCurrentElement(null);
          transformer.getTraceManager().fireTraceEndEvent(this);
        }


	 	
	 	
	 	
	 	
	 	
	 	
	 	
		
	 	
	 	
	 	if(m_doc_cache_off)
		{
	 	  if(DEBUG)
	 	    System.out.println(""JJK***** CACHE RELEASE *****
""+
				       ""	dtm=""+dtm.getDocumentBaseURI());
	  	
	  	
	 	
	 	  xctxt.getSourceTreeManager().removeDocumentFromCache(dtm.getDocument());
	 	  xctxt.release(dtm,false);
	 	}
      }
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireSelectedEndEvent(sourceNode, this,
                ""select"", new XPath(m_selectExpression),
                new org.apache.xpath.objects.XNodeSet(sourceNodes));

      xctxt.popSAXLocator();
      xctxt.popContextNodeList();
      transformer.popElemTemplateElement();
      xctxt.popCurrentExpressionNode();
      xctxt.popCurrentNode();
      sourceNodes.detach();
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    if (Constants.ELEMNAME_SORT == type)
    {
      setSortElem((ElemSort) newChild);

      return newChild;
    }
    else
      return super.appendChild(newChild);
  }
  
  
  public void callChildVisitors(XSLTVisitor visitor, boolean callAttributes)
  {
  	if(callAttributes && (null != m_selectExpression))
  		m_selectExpression.callVisitors(this, visitor);
  		
    int length = getSortElemCount();

    for (int i = 0; i < length; i++)
    {
      getSortElem(i).callVisitors(visitor);
    }

    super.callChildVisitors(visitor, callAttributes);
  }

  
  public Expression getExpression()
  {
    return m_selectExpression;
  }

  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_selectExpression = exp;
  }

}
"
org.apache.xalan.extensions.ExtensionHandlerJavaClass,7,3,0,9,43,1,0,9,6,0.7,530,0.4,0,0.571428571,0.349206349,2,6,74.0,8,2.1429,1,"

package org.apache.xalan.extensions;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.objects.XObject;



public class ExtensionHandlerJavaClass extends ExtensionHandlerJava
{

  private Class m_classObj = null;

  

  private Object m_defaultInstance = null;


  
  public ExtensionHandlerJavaClass(String namespaceUri,
                                   String scriptLang,
                                   String className)
  {
    super(namespaceUri, scriptLang, className);
    try
    {
      m_classObj = getClassForName(className);
    }
    catch (ClassNotFoundException e)
    {
      
    }
  }


  

  public boolean isFunctionAvailable(String function) 
  {
    Method[] methods = m_classObj.getMethods();
    int nMethods = methods.length;
    for (int i = 0; i < nMethods; i++)
    {
      if (methods[i].getName().equals(function))
        return true;
    }
    return false;
  }


  

  public boolean isElementAvailable(String element) 
  {
    Method[] methods = m_classObj.getMethods();
    int nMethods = methods.length;
    for (int i = 0; i < nMethods; i++)
    {
      if (methods[i].getName().equals(element))
      {
        Class[] paramTypes = methods[i].getParameterTypes();
        if ( (paramTypes.length == 2)
          && paramTypes[0].isAssignableFrom(
                                     org.apache.xalan.extensions.XSLProcessorContext.class)
          && paramTypes[1].isAssignableFrom(org.apache.xalan.templates.ElemExtensionCall.class) )
        {
          return true;
        }
      }
    }
    return false;
  }
  
  

  public Object callFunction (String funcName, 
                              Vector args, 
                              Object methodKey,
                              ExpressionContext exprContext)
    throws TransformerException 
  {

    Object[] methodArgs;
    Object[][] convertedArgs;
    Class[] paramTypes;

    try
    {
      if (funcName.equals(""new"")) {                   

        methodArgs = new Object[args.size()];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i);
        }
        Constructor c = (Constructor) getFromCache(methodKey, null, methodArgs);
        if (c != null)
        {
          try
          {
            paramTypes = c.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            return c.newInstance(convertedArgs[0]);
          }
          catch (InvocationTargetException ite)
          {
            throw ite;
          }
          catch(Exception e)
          {
            
          }
        }
        c = MethodResolver.getConstructor(m_classObj, 
                                          methodArgs,
                                          convertedArgs,
                                          exprContext);
        putToCache(methodKey, null, methodArgs, c);
        return c.newInstance(convertedArgs[0]);
      }

      else
      {

        int resolveType;
        Object targetObject = null;
        methodArgs = new Object[args.size()];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i);
        }
        Method m = (Method) getFromCache(methodKey, null, methodArgs);
        if (m != null)
        {
          try
          {
            paramTypes = m.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            if (Modifier.isStatic(m.getModifiers()))
              return m.invoke(null, convertedArgs[0]);
            else
            {
              
              
              int nTargetArgs = convertedArgs[0].length;
              if (ExpressionContext.class.isAssignableFrom(paramTypes[0]))
                nTargetArgs--;
              if (methodArgs.length <= nTargetArgs)
                return m.invoke(m_defaultInstance, convertedArgs[0]);
              else  
              {
                targetObject = methodArgs[0];
                
                if (targetObject instanceof XObject)
                  targetObject = ((XObject) targetObject).object();
                  
                return m.invoke(targetObject, convertedArgs[0]);
              }
            }
          }
          catch (InvocationTargetException ite)
          {
            throw ite;
          }
          catch(Exception e)
          {
            
          }
        }

        if (args.size() > 0)
        {
          targetObject = methodArgs[0];

          if (targetObject instanceof XObject)
            targetObject = ((XObject) targetObject).object();

          if (m_classObj.isAssignableFrom(targetObject.getClass()))
            resolveType = MethodResolver.DYNAMIC;
          else
            resolveType = MethodResolver.STATIC_AND_INSTANCE;
        }
        else
        {
          targetObject = null;
          resolveType = MethodResolver.STATIC_AND_INSTANCE;
        }

        m = MethodResolver.getMethod(m_classObj,
                                     funcName,
                                     methodArgs, 
                                     convertedArgs,
                                     exprContext,
                                     resolveType);
        putToCache(methodKey, null, methodArgs, m);

        if (MethodResolver.DYNAMIC == resolveType)          
          return m.invoke(targetObject, convertedArgs[0]);
        else                                  
        {
          if (Modifier.isStatic(m.getModifiers()))
            return m.invoke(null, convertedArgs[0]);
          else
          {
            if (null == m_defaultInstance)
            {
              m_defaultInstance = m_classObj.newInstance();
            }
            return m.invoke(m_defaultInstance, convertedArgs[0]);
          }  
        }

      }
    }
    catch (InvocationTargetException ite)
    {
      Throwable resultException = ite;
      Throwable targetException = ite.getTargetException();
 
      if (targetException instanceof TransformerException)
        throw ((TransformerException)targetException);
      else if (targetException != null)
        resultException = targetException;
            
      throw new TransformerException(resultException);
    }
    catch (Exception e)
    {
      
      throw new TransformerException(e);
    }
  }

  
  public Object callFunction(FuncExtFunction extFunction,
                             Vector args,
                             ExpressionContext exprContext)
      throws TransformerException
  {
    return callFunction(extFunction.getFunctionName(), args, 
                        extFunction.getMethodKey(), exprContext);
  }

  

  public void processElement(String localPart,
                             ElemTemplateElement element,
                             TransformerImpl transformer,
                             Stylesheet stylesheetTree,
                             Object methodKey)
    throws TransformerException, IOException
  {
    Object result = null;

    Method m = (Method) getFromCache(methodKey, null, null);
    if (null == m)
    {
      try
      {
        m = MethodResolver.getElementMethod(m_classObj, localPart);
        if ( (null == m_defaultInstance) && !Modifier.isStatic(m.getModifiers()) )
          m_defaultInstance = m_classObj.newInstance();
      }
      catch (Exception e)
      {
        
        throw new TransformerException (e.getMessage (), e);
      }
      putToCache(methodKey, null, null, m);
    }

    XSLProcessorContext xpc = new XSLProcessorContext(transformer, 
                                                      stylesheetTree);

    try
    {
      result = m.invoke(m_defaultInstance, new Object[] {xpc, element});
    }
    catch (InvocationTargetException e)
    {
      Throwable targetException = e.getTargetException();
      
      if (targetException instanceof TransformerException)
        throw (TransformerException)targetException;
      else if (targetException != null)
        throw new TransformerException (targetException.getMessage (), targetException);
      else
        throw new TransformerException (e.getMessage (), e);
    }
    catch (Exception e)
    {
      
      throw new TransformerException (e.getMessage (), e);
    }

    if (result != null)
    {
      xpc.outputToResultTree (stylesheetTree, result);
    }
 
  }
 
}
"
org.apache.xml.dtm.DTM,66,1,0,94,66,2145,91,3,66,1.015384615,82,0.0,0,0.0,0.277056277,0,0,0.0,1,1.0,1,"
package org.apache.xml.dtm;

import javax.xml.transform.SourceLocator;

import org.apache.xml.utils.XMLString;


public interface DTM
{

  
  public static final int NULL = -1;

  
  
  
  
  

  
  public static final short ROOT_NODE = 0;
  
  
  public static final short ELEMENT_NODE = 1;

  
  public static final short ATTRIBUTE_NODE = 2;

  
  public static final short TEXT_NODE = 3;

  
  public static final short CDATA_SECTION_NODE = 4;

  
  public static final short ENTITY_REFERENCE_NODE = 5;

  
  public static final short ENTITY_NODE = 6;

  
  public static final short PROCESSING_INSTRUCTION_NODE = 7;

  
  public static final short COMMENT_NODE = 8;

  
  public static final short DOCUMENT_NODE = 9;

  
  public static final short DOCUMENT_TYPE_NODE = 10;

  
  public static final short DOCUMENT_FRAGMENT_NODE = 11;

  
  public static final short NOTATION_NODE = 12;

  
  public static final short NAMESPACE_NODE = 13;
  
  
  public static final short  NTYPES = 14;

  
  
  

  
  public void setFeature(String featureId, boolean state);

  
  public void setProperty(String property, Object value);

  

  
  public DTMAxisTraverser getAxisTraverser(final int axis);

  
  public DTMAxisIterator getAxisIterator(final int axis);

  
  public DTMAxisIterator getTypedAxisIterator(final int axis, final int type);

  
  public boolean hasChildNodes(int nodeHandle);

  
  public int getFirstChild(int nodeHandle);

  
  public int getLastChild(int nodeHandle);

  
  public int getAttributeNode(int elementHandle, String namespaceURI,
                              String name);

  
  public int getFirstAttribute(int nodeHandle);

  
  public int getFirstNamespaceNode(int nodeHandle, boolean inScope);

  
  public int getNextSibling(int nodeHandle);

  
  public int getPreviousSibling(int nodeHandle);

  
  public int getNextAttribute(int nodeHandle);

  
  public int getNextNamespaceNode(int baseHandle, int namespaceHandle,
                                  boolean inScope);

  
  public int getParent(int nodeHandle);

  
  public int getDocument();

  
  public int getOwnerDocument(int nodeHandle);

  
  public int getDocumentRoot(int nodeHandle);

  
  public XMLString getStringValue(int nodeHandle);

  
  public int getStringValueChunkCount(int nodeHandle);

  
  public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
                                    int[] startAndLen);

  
  public int getExpandedTypeID(int nodeHandle);

  
  public int getExpandedTypeID(String namespace, String localName, int type);

  
  public String getLocalNameFromExpandedNameID(int ExpandedNameID);

  
  public String getNamespaceFromExpandedNameID(int ExpandedNameID);

  
  public String getNodeName(int nodeHandle);

  
  public String getNodeNameX(int nodeHandle);

  
  public String getLocalName(int nodeHandle);

  
  public String getPrefix(int nodeHandle);

  
  public String getNamespaceURI(int nodeHandle);

  
  public String getNodeValue(int nodeHandle);

  
  public short getNodeType(int nodeHandle);

  
  public short getLevel(int nodeHandle);

  

  
  public boolean isSupported(String feature, String version);

  
  public String getDocumentBaseURI();

  
  public void setDocumentBaseURI(String baseURI);

  
  public String getDocumentSystemIdentifier(int nodeHandle);

  
  public String getDocumentEncoding(int nodeHandle);

  
  public String getDocumentStandalone(int nodeHandle);

  
  public String getDocumentVersion(int documentHandle);

  
  public boolean getDocumentAllDeclarationsProcessed();

  
  public String getDocumentTypeDeclarationSystemIdentifier();

  
  public String getDocumentTypeDeclarationPublicIdentifier();

  
  public int getElementById(String elementId);

  
  public String getUnparsedEntityURI(String name);

  

  
  public boolean supportsPreStripping();

  
  public boolean isNodeAfter(int firstNodeHandle, int secondNodeHandle);

  
  public boolean isCharacterElementContentWhitespace(int nodeHandle);

  
  public boolean isDocumentAllDeclarationsProcessed(int documentHandle);

  
  public boolean isAttributeSpecified(int attributeHandle);

  

  
  public void dispatchCharactersEvents(
    int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize)
      throws org.xml.sax.SAXException;

  
  public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
    throws org.xml.sax.SAXException;

  
  public org.w3c.dom.Node getNode(int nodeHandle);

  
  

  
  public boolean needsTwoThreads();

  
  
  
  
  

  
  public org.xml.sax.ContentHandler getContentHandler();

  
  public org.xml.sax.ext.LexicalHandler getLexicalHandler();

  
  public org.xml.sax.EntityResolver getEntityResolver();

  
  public org.xml.sax.DTDHandler getDTDHandler();

  
  public org.xml.sax.ErrorHandler getErrorHandler();

  
  public org.xml.sax.ext.DeclHandler getDeclHandler();

  
  public void appendChild(int newChild, boolean clone, boolean cloneDepth);

  
  public void appendTextChild(String str);

  
  public SourceLocator getSourceLocatorFor(int node);

  
  public void documentRegistration();

  

   public void documentRelease();
}
"
org.apache.xalan.xsltc.cmdline.getopt.IllegalArgumentException,1,4,0,2,2,0,1,1,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.apache.xalan.xsltc.cmdline.getopt;


class IllegalArgumentException extends GetOptsException{
    public IllegalArgumentException(String msg){
	super(msg);
    }
}
"
org.apache.xalan.xsltc.dom.KeyIndex,20,2,0,9,38,34,2,7,20,0.778947368,385,1.0,4,0.40625,0.242857143,1,7,18.0,11,2.55,0,"

package org.apache.xalan.xsltc.dom;

import java.util.StringTokenizer;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.runtime.Hashtable;
import org.apache.xalan.xsltc.util.IntegerArray;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;

public class KeyIndex extends DTMAxisIteratorBase {

    
    private Hashtable _index = new Hashtable();

    
    private IntegerArray _nodes = null;

    
    private DOM        _dom;
    
    private SAXImpl    _saxImpl;

    
    private int _markedPosition = 0;

    public KeyIndex(int dummy) {
    }

    public void setRestartable(boolean flag) {
    }

    
    public void add(Object value, int node) {
	IntegerArray nodes;
	if ((nodes = (IntegerArray) _index.get(value)) == null) {
	    _index.put(value, nodes = new IntegerArray());
	}
	nodes.add(node);
    }

    
    public void merge(KeyIndex other) {
	if (other == null) return;

	if (other._nodes != null) {
	    if (_nodes == null) {
		_nodes = other._nodes;
	    }
	    else {
		_nodes.merge(other._nodes);
	    }
	}
    }

    
    public void lookupId(Object value) {
	
	_nodes = null;

	final StringTokenizer values = new StringTokenizer((String) value);
	while (values.hasMoreElements()) {
            final String token = (String) values.nextElement();
	    IntegerArray nodes = (IntegerArray) _index.get(token);

            if (nodes == null && _saxImpl != null && _saxImpl.hasDOMSource()) {
                nodes = getDOMNodeById(token);
            }

	    if (nodes == null) continue;

	    if (_nodes == null) {
		_nodes = nodes;
	    }
	    else {
		_nodes.merge(nodes);
	    }
	}
    }

    
    public IntegerArray getDOMNodeById(String id) {
        IntegerArray nodes = null;
        if (_saxImpl != null) {
            int ident = _saxImpl.getElementById(id);
            if (ident != DTM.NULL) {
	        nodes = new IntegerArray();
	    	_index.put(id, nodes);
		nodes.add(ident);
            }
        }
        return nodes; 	
    }
    
    
    public void lookupKey(Object value) {
	_nodes = (IntegerArray) _index.get(value);
	_position = 0;
    }

    
    public int next() {
	if (_nodes == null) return DTMAxisIterator.END;

	return (_position < _nodes.cardinality()) ? 
	    _dom.getNodeHandle(_nodes.at(_position++)) : DTMAxisIterator.END;
    }

    public int containsID(int node, Object value) { 
	final String string = (String)value;
	if (string.indexOf(' ') > -1) {
	    final StringTokenizer values = new StringTokenizer(string);

	    while (values.hasMoreElements()) {
                final String token = (String) values.nextElement();
		IntegerArray nodes = (IntegerArray) _index.get(token);

		if (nodes == null && _saxImpl != null && _saxImpl.hasDOMSource()) {
		    nodes = getDOMNodeById(token);	
		}
		if (nodes != null && nodes.indexOf(node) >= 0) {
		    return 1;
		}
	    }
	    return 0;
	}
	else {
	    IntegerArray nodes = (IntegerArray) _index.get(value);
            if (nodes == null && _saxImpl != null && _saxImpl.hasDOMSource()) {
                nodes = getDOMNodeById(string);
            }
	    return (nodes != null && nodes.indexOf(node) >= 0) ? 1 : 0;
	}
    }

    public int containsKey(int node, Object value) { 
	final IntegerArray nodes = (IntegerArray) _index.get(value);
	return (nodes != null && nodes.indexOf(node) >= 0) ? 1 : 0;
    }

    
    public DTMAxisIterator reset() {
	_position = 0;
	return this;
    }

    
    public int getLast() {
	return (_nodes == null) ? 0 : _nodes.cardinality();
    }

    
    public int getPosition() {
	return _position;
    }

    
    public void setMark() {
	_markedPosition = _position;
    }

    
    public void gotoMark() {
	_position = _markedPosition;
    }

    
    public DTMAxisIterator setStartNode(int start) {
	if (start == DTMAxisIterator.END) {
	    _nodes = null;
	}
	else if (_nodes != null) {
	    _position = 0;
	}
	return (DTMAxisIterator) this;
    }
    
    
    public int getStartNode() {      
        return 0;
    }

    
    public boolean isReverse() {
	return(false);
    }

    
    public DTMAxisIterator cloneIterator() {
	KeyIndex other = new KeyIndex(0);
	other._index = _index;
	other._nodes = _nodes;
	other._position = _position;
	return (DTMAxisIterator) other;
    }
    
    public void setDom(DOM dom) {
    	_dom = dom;
    	if (dom instanceof SAXImpl) {
    	    _saxImpl = (SAXImpl)dom;
    	}
    	else if (dom instanceof DOMAdapter) {
    	    DOM idom = ((DOMAdapter)dom).getDOMImpl();
    	    if (idom instanceof SAXImpl) {
    	        _saxImpl = (SAXImpl)idom;
    	    }
    	}
    }
}
"
org.apache.xalan.templates.ElemCopy,4,4,0,10,25,6,1,9,4,2.0,121,0.0,0,0.985365854,0.625,2,4,29.25,1,0.75,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.ClonerToResultTree;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xalan.serialize.SerializerUtils;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xpath.XPathContext;


public class ElemCopy extends ElemUse
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_COPY;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_COPY_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
                XPathContext xctxt = transformer.getXPathContext();
      
    try
    {
      int sourceNode = xctxt.getCurrentNode();
      xctxt.pushCurrentNode(sourceNode);
      DTM dtm = xctxt.getDTM(sourceNode);
      short nodeType = dtm.getNodeType(sourceNode);

      if ((DTM.DOCUMENT_NODE != nodeType) && (DTM.DOCUMENT_FRAGMENT_NODE != nodeType))
      {
        SerializationHandler rthandler = transformer.getSerializationHandler();

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(this);
            
        
        ClonerToResultTree.cloneToResultTree(sourceNode, nodeType, dtm, 
                                             rthandler, false);

        if (DTM.ELEMENT_NODE == nodeType)
        {
          super.execute(transformer);
          SerializerUtils.processNSDecls(rthandler, sourceNode, nodeType, dtm);
          transformer.executeChildTemplates(this, true);
          
          String ns = dtm.getNamespaceURI(sourceNode);
          String localName = dtm.getLocalName(sourceNode);
          transformer.getResultTreeHandler().endElement(ns, localName,
                                                        dtm.getNodeName(sourceNode));
        }
        if (TransformerImpl.S_DEBUG)
		  transformer.getTraceManager().fireTraceEndEvent(this);         
      }
      else
      {
        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(this);

        super.execute(transformer);
        transformer.executeChildTemplates(this, true);

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEndEvent(this);
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      xctxt.popCurrentNode();
    }
  }
}
"
org.apache.xalan.xsltc.dom.StepIterator,8,2,1,4,21,0,2,3,8,0.333333333,158,1.0,2,0.65,0.34375,1,5,18.375,3,1.5,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;


public class StepIterator extends DTMAxisIteratorBase {

    
    protected DTMAxisIterator _source;

    
    protected DTMAxisIterator _iterator;

    
    private int _pos = -1;

    public StepIterator(DTMAxisIterator source, DTMAxisIterator iterator) {
	_source = source;
	_iterator = iterator;


    }


    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
	_iterator.setRestartable(true); 	
    }

    public DTMAxisIterator cloneIterator() {
	_isRestartable = false;
	try {
	    final StepIterator clone = (StepIterator) super.clone();
	    clone._source = _source.cloneIterator();
	    clone._iterator = _iterator.cloneIterator();
	    clone._iterator.setRestartable(true); 	
	    clone._isRestartable = false;
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public DTMAxisIterator setStartNode(int node) {
	if (_isRestartable) {
	    
	    _source.setStartNode(_startNode = node);

	    
	    
	    _iterator.setStartNode(_includeSelf ? _startNode : _source.next());
	    return resetPosition();
	}
	return this;
    }

    public DTMAxisIterator reset() {
	_source.reset();
	
	_iterator.setStartNode(_includeSelf ? _startNode : _source.next());
	return resetPosition();
    }
    
    public int next() {
	for (int node;;) {
	    
	    if ((node = _iterator.next()) != END) {
		return returnNode(node);
	    }
	    
	    else if ((node = _source.next()) == END) {
		return END;
	    }
	    
	    else {
		_iterator.setStartNode(node);
	    }
	}
    }

    public void setMark() {
	_source.setMark();
	_iterator.setMark();
	
    }

    public void gotoMark() {
	_source.gotoMark();
	_iterator.gotoMark();
	
    }
}
"
org.apache.xalan.xsltc.compiler.StepPattern,20,6,1,53,99,50,8,46,13,0.831578947,1165,1.0,1,0.838983051,0.225,3,8,56.75,7,2.55,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.classfile.Field;
import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.GOTO_W;
import org.apache.bcel.generic.IFLT;
import org.apache.bcel.generic.IFNE;
import org.apache.bcel.generic.IFNONNULL;
import org.apache.bcel.generic.IF_ICMPEQ;
import org.apache.bcel.generic.IF_ICMPLT;
import org.apache.bcel.generic.IF_ICMPNE;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xml.dtm.DTM;

class StepPattern extends RelativePathPattern {

    private static final int NO_CONTEXT = 0;
    private static final int SIMPLE_CONTEXT = 1;
    private static final int GENERAL_CONTEXT = 2;

    protected final int _axis;
    protected final int _nodeType;
    protected Vector _predicates;

    private Step    _step = null;
    private boolean _isEpsilon = false;
    private int     _contextCase;

    private double  _priority = Double.MAX_VALUE;

    public StepPattern(int axis, int nodeType, Vector predicates) {
	_axis = axis;
	_nodeType = nodeType;
	_predicates = predicates;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Predicate exp = (Predicate)_predicates.elementAt(i);
		exp.setParser(parser);
		exp.setParent(this);
	    }
	}
    }

    public int getNodeType() {
	return _nodeType;
    }

    public void setPriority(double priority) {
	_priority = priority;
    }
    
    public StepPattern getKernelPattern() {
	return this;
    }
	
    public boolean isWildcard() {
	return _isEpsilon && hasPredicates() == false;
    }

    public StepPattern setPredicates(Vector predicates) {
	_predicates = predicates;
	return(this);
    }
    
    protected boolean hasPredicates() {
	return _predicates != null && _predicates.size() > 0;
    }

    public double getDefaultPriority() {
	if (_priority != Double.MAX_VALUE) {
	    return _priority;
	}

	if (hasPredicates()) {
	    return 0.5;
	}
	else {
	    switch(_nodeType) {
	    case -1:
		return -0.5;	
	    case 0:
		return 0.0;
	    default:
		return (_nodeType >= NodeTest.GTYPE) ? 0.0 : -0.5;
	    }
	}
    }
    
    public int getAxis() {
	return _axis;
    }

    public void reduceKernelPattern() {
	_isEpsilon = true;
    }
	
    public String toString() {
	final StringBuffer buffer = new StringBuffer(""stepPattern("""");
	buffer.append(Axis.names[_axis])
	    .append("""", "")
	    .append(_isEpsilon ? 
			(""epsilon{"" + Integer.toString(_nodeType) + ""}"") :
			 Integer.toString(_nodeType));
	if (_predicates != null)
	    buffer.append("", "").append(_predicates.toString());
	return buffer.append(')').toString();
    }
    
    private int analyzeCases() {
	boolean noContext = true;
	final int n = _predicates.size();

	for (int i = 0; i < n && noContext; i++) {
	    final Predicate pred = (Predicate)_predicates.elementAt(i);
	    if (pred.getExpr().hasPositionCall()
                || pred.isNthPositionFilter()) {
		noContext = false;
	    }
	}

	if (noContext) {
	    return NO_CONTEXT;
	}
	else if (n == 1) {
	    return SIMPLE_CONTEXT;
	}
	return GENERAL_CONTEXT;
    }

    private String getNextFieldName() {
	return  ""__step_pattern_iter_"" + getXSLTC().nextStepPatternSerial();
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
        if (hasPredicates()) {
            
            final int n = _predicates.size();
            for (int i = 0; i < n; i++) {
                final Predicate pred = (Predicate)_predicates.elementAt(i);
                pred.typeCheck(stable);
            }

            
            _contextCase = analyzeCases();

            Step step = null;

            
            if (_contextCase == SIMPLE_CONTEXT) {
                Predicate pred = (Predicate)_predicates.elementAt(0);
                if (pred.isNthPositionFilter()) {
                    _contextCase = GENERAL_CONTEXT;
                    step = new Step(_axis, _nodeType, _predicates);
                } else {
                    step = new Step(_axis, _nodeType, null);
                }
            } else if (_contextCase == GENERAL_CONTEXT) {
                final int len = _predicates.size();
                for (int i = 0; i < len; i++) {
                    ((Predicate)_predicates.elementAt(i)).dontOptimize();
                }

                step = new Step(_axis, _nodeType, _predicates);
            }
            if (step != null) {
                step.setParser(getParser());
                step.typeCheck(stable);
                _step = step;
            }
        }
        return _axis == Axis.CHILD ? Type.Element : Type.Attribute;
    }

    private void translateKernel(ClassGenerator classGen, 
				 MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	
	if (_nodeType == DTM.ELEMENT_NODE) {
	    final int check = cpg.addInterfaceMethodref(DOM_INTF,
							""isElement"", ""(I)Z"");
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(new INVOKEINTERFACE(check, 2));
	
	    
	    final BranchHandle icmp = il.append(new IFNE(null));
	    _falseList.add(il.append(new GOTO_W(null)));
	    icmp.setTarget(il.append(NOP));
	}
	else if (_nodeType == DTM.ATTRIBUTE_NODE) {
	    final int check = cpg.addInterfaceMethodref(DOM_INTF,
							""isAttribute"", ""(I)Z"");
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(new INVOKEINTERFACE(check, 2));
	
	    
	    final BranchHandle icmp = il.append(new IFNE(null));
	    _falseList.add(il.append(new GOTO_W(null)));
	    icmp.setTarget(il.append(NOP));
	}
	else {
	    
	    final int getEType = cpg.addInterfaceMethodref(DOM_INTF,
							  ""getExpandedTypeID"",
                                                          ""(I)I"");
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(new INVOKEINTERFACE(getEType, 2));
	    il.append(new PUSH(cpg, _nodeType));
	
	    
	    final BranchHandle icmp = il.append(new IF_ICMPEQ(null));
	    _falseList.add(il.append(new GOTO_W(null)));
	    icmp.setTarget(il.append(NOP));
	}
    }

    private void translateNoContext(ClassGenerator classGen, 
				    MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadCurrentNode());
	il.append(SWAP);

	
	il.append(methodGen.storeCurrentNode());

	
	if (!_isEpsilon) {
	    il.append(methodGen.loadCurrentNode());
	    translateKernel(classGen, methodGen);
	}

	
	final int n = _predicates.size();
	for (int i = 0; i < n; i++) {
	    Predicate pred = (Predicate)_predicates.elementAt(i);
	    Expression exp = pred.getExpr();
	    exp.translateDesynthesized(classGen, methodGen);
	    _trueList.append(exp._trueList);
	    _falseList.append(exp._falseList);
	}

	
	InstructionHandle restore;
	restore = il.append(methodGen.storeCurrentNode());
	backPatchTrueList(restore);
	BranchHandle skipFalse = il.append(new GOTO(null));

	
	restore = il.append(methodGen.storeCurrentNode());
	backPatchFalseList(restore);
	_falseList.add(il.append(new GOTO(null)));

	
	skipFalse.setTarget(il.append(NOP));
    }

    private void translateSimpleContext(ClassGenerator classGen, 
					MethodGenerator methodGen) {
	int index;
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	LocalVariableGen match;
	match = methodGen.addLocalVariable(""step_pattern_tmp1"", 
					   Util.getJCRefType(NODE_SIG),
					   il.getEnd(), null);
	il.append(new ISTORE(match.getIndex()));

	
	if (!_isEpsilon) {
	    il.append(new ILOAD(match.getIndex()));
 	    translateKernel(classGen, methodGen);
	}

	
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadIterator());

	
	index = cpg.addMethodref(MATCHING_ITERATOR, ""<init>"", 
				 ""(I"" + NODE_ITERATOR_SIG + "")V"");
	il.append(new NEW(cpg.addClass(MATCHING_ITERATOR)));
	il.append(DUP);
	il.append(new ILOAD(match.getIndex()));
	_step.translate(classGen, methodGen);
	il.append(new INVOKESPECIAL(index));

	
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(match.getIndex()));
	index = cpg.addInterfaceMethodref(DOM_INTF, GET_PARENT, GET_PARENT_SIG);
	il.append(new INVOKEINTERFACE(index, 2));

	
	il.append(methodGen.setStartNode());

	
	il.append(methodGen.storeIterator());
	il.append(new ILOAD(match.getIndex()));
	il.append(methodGen.storeCurrentNode());

	
	Predicate pred = (Predicate) _predicates.elementAt(0);
	Expression exp = pred.getExpr();
	exp.translateDesynthesized(classGen, methodGen);

	
	InstructionHandle restore = il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
	exp.backPatchTrueList(restore);
	BranchHandle skipFalse = il.append(new GOTO(null));

	
	restore = il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
	exp.backPatchFalseList(restore);
	_falseList.add(il.append(new GOTO(null)));

	
	skipFalse.setTarget(il.append(NOP));
    }

    private void translateGeneralContext(ClassGenerator classGen, 
					 MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	int iteratorIndex = 0;
	BranchHandle ifBlock = null;
	LocalVariableGen iter, node, node2;
	final String iteratorName = getNextFieldName();

	
	node = methodGen.addLocalVariable(""step_pattern_tmp1"", 
					  Util.getJCRefType(NODE_SIG),
					  il.getEnd(), null);
	il.append(new ISTORE(node.getIndex()));

	
	iter = methodGen.addLocalVariable(""step_pattern_tmp2"", 
					  Util.getJCRefType(NODE_ITERATOR_SIG),
					  il.getEnd(), null);

	
	if (!classGen.isExternal()) {
	    final Field iterator =
		new Field(ACC_PRIVATE, 
			  cpg.addUtf8(iteratorName),
			  cpg.addUtf8(NODE_ITERATOR_SIG),
			  null, cpg.getConstantPool());
	    classGen.addField(iterator);
	    iteratorIndex = cpg.addFieldref(classGen.getClassName(), 
					    iteratorName,
					    NODE_ITERATOR_SIG);

	    il.append(classGen.loadTranslet());
	    il.append(new GETFIELD(iteratorIndex));
	    il.append(DUP);
	    il.append(new ASTORE(iter.getIndex()));
	    ifBlock = il.append(new IFNONNULL(null));
	    il.append(classGen.loadTranslet());
	}	

	
	_step.translate(classGen, methodGen);
	il.append(new ASTORE(iter.getIndex()));

	
	if (!classGen.isExternal()) {
	    il.append(new ALOAD(iter.getIndex()));
	    il.append(new PUTFIELD(iteratorIndex));
	    ifBlock.setTarget(il.append(NOP));
	}

	
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(node.getIndex()));
	int index = cpg.addInterfaceMethodref(DOM_INTF,
					      GET_PARENT, GET_PARENT_SIG);
	il.append(new INVOKEINTERFACE(index, 2));

	
	il.append(new ALOAD(iter.getIndex()));
	il.append(SWAP);
	il.append(methodGen.setStartNode());

	
	BranchHandle skipNext;
	InstructionHandle begin, next;
	node2 = methodGen.addLocalVariable(""step_pattern_tmp3"", 
					   Util.getJCRefType(NODE_SIG),
					   il.getEnd(), null);

	skipNext = il.append(new GOTO(null));
	next = il.append(new ALOAD(iter.getIndex()));
	begin = il.append(methodGen.nextNode());
	il.append(DUP);
	il.append(new ISTORE(node2.getIndex()));
	_falseList.add(il.append(new IFLT(null)));	

	il.append(new ILOAD(node2.getIndex()));
	il.append(new ILOAD(node.getIndex()));
	il.append(new IF_ICMPLT(next));

	il.append(new ILOAD(node2.getIndex()));
	il.append(new ILOAD(node.getIndex()));
	_falseList.add(il.append(new IF_ICMPNE(null)));

	skipNext.setTarget(begin);
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (hasPredicates()) {
	    switch (_contextCase) {
	    case NO_CONTEXT:
		translateNoContext(classGen, methodGen);
		break;
		
	    case SIMPLE_CONTEXT:
		translateSimpleContext(classGen, methodGen);
		break;
		
	    default:
		translateGeneralContext(classGen, methodGen);
		break;
	    }
	}
	else if (isWildcard()) {
	    il.append(POP); 	
	}
	else {
	    translateKernel(classGen, methodGen);
	}
    }
}
"
org.apache.xpath.domapi.XPathEvaluatorImpl,5,1,0,5,15,4,1,5,5,0.25,77,1.0,0,0.0,0.4,0,0,14.2,2,0.8,1,"

package org.apache.xpath.domapi;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.XPath;
import org.apache.xpath.res.XPATHErrorResources;

import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.xpath.XPathEvaluator;
import org.w3c.dom.xpath.XPathException;
import org.w3c.dom.xpath.XPathExpression;
import org.w3c.dom.xpath.XPathNSResolver;


public class XPathEvaluatorImpl implements XPathEvaluator {

	
	class DummyPrefixResolver implements PrefixResolver {

		
		public DummyPrefixResolver() {}
			
		
		public String getNamespaceForPrefix(String prefix, Node context) {
            String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_RESOLVER, null);       
            throw new DOMException(DOMException.NAMESPACE_ERR, fmsg);   
		}

		
		public String getNamespaceForPrefix(String prefix) {
			return getNamespaceForPrefix(prefix,null);
		}

		
		public boolean handlesNullPrefixes() {
			return false;
		}

		
		public String getBaseIdentifier() {
			return null;
		}

	}

      
    private Document m_doc = null;
    
	
	public XPathEvaluatorImpl() {
		super();
	}
    
     
    public XPathEvaluatorImpl(Document doc) {
        m_doc = doc;
    }

	
	public XPathExpression createExpression(
		String expression,
		XPathNSResolver resolver)
		throws XPathException, DOMException {
		
		try {
			
			
			XPath xpath =  new XPath(expression,null,
			     ((null == resolver) ? new DummyPrefixResolver() : ((PrefixResolver)resolver)), 
			      XPath.SELECT);
                  
            return new XPathExpressionImpl(xpath, m_doc);
			      
		} catch (TransformerException e) {
			throw new DOMException(XPathException.INVALID_EXPRESSION_ERR,e.getMessageAndLocation());
		}
	}

	
	public XPathNSResolver createNSResolver(Node nodeResolver) {
	
		return new XPathNSResolverImpl((nodeResolver.getNodeType() == Node.DOCUMENT_NODE)
	           ? ((Document) nodeResolver).getDocumentElement() : nodeResolver);
	}

	
	public Object evaluate(
		String expression,
		Node contextNode,
		XPathNSResolver resolver,
		short type,
		Object result)
		throws XPathException, DOMException {
			
		XPathExpression xpathExpression = createExpression(expression, resolver);
		
		return	xpathExpression.evaluate(contextNode, type, result);
	}

}
"
org.apache.xalan.transformer.NodeSortKey,1,1,0,6,10,0,3,4,0,2.0,80,0.0,3,0.0,1.0,0,0,71.0,0,0.0,1,"
package org.apache.xalan.transformer;

import java.text.Collator;
import java.util.Locale;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xpath.XPath;


class NodeSortKey
{

  
  XPath m_selectPat;

  
  boolean m_treatAsNumbers;

  
  boolean m_descending;

  
  boolean m_caseOrderUpper;

  
  Collator m_col;

  
  Locale m_locale;

  
  org.apache.xml.utils.PrefixResolver m_namespaceContext;

  
  TransformerImpl m_processor;  

  
  NodeSortKey(
          TransformerImpl transformer, XPath selectPat, boolean treatAsNumbers, 
          boolean descending, String langValue, boolean caseOrderUpper, 
          org.apache.xml.utils.PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    m_processor = transformer;
    m_namespaceContext = namespaceContext;
    m_selectPat = selectPat;
    m_treatAsNumbers = treatAsNumbers;
    m_descending = descending;
    m_caseOrderUpper = caseOrderUpper;

    if (null != langValue && m_treatAsNumbers == false)
    {
      
      
      
      
      
      
      
      
      
      
      m_locale = new Locale(langValue.toLowerCase(), 
                  Locale.getDefault().getCountry());
                  
      
      
      

      if (null == m_locale)
      {

        
        m_locale = Locale.getDefault();
      }
    }
    else
    {
      m_locale = Locale.getDefault();
    }

    m_col = Collator.getInstance(m_locale);

    if (null == m_col)
    {
      m_processor.getMsgMgr().warn(null, XSLTErrorResources.WG_CANNOT_FIND_COLLATOR,
                                   new Object[]{ langValue });  

      m_col = Collator.getInstance();
    }
  }
}
"
org.apache.xpath.axes.PathComponent,1,1,0,8,1,0,8,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xpath.axes;


public interface PathComponent
{
  
  public int getAnalysisBits();

}

"
org.apache.xalan.lib.ExsltSets,7,2,0,4,23,21,1,3,7,2.0,258,0.0,0,0.25,0.5,0,0,35.85714286,6,3.5714,1,"
package org.apache.xalan.lib;

import java.util.Hashtable;

import org.apache.xml.utils.DOMHelper;
import org.apache.xpath.NodeSet;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public class ExsltSets extends ExsltBase
{   
  
  public static NodeList leading (NodeList nl1, NodeList nl2)
  {
    if (nl2.getLength() == 0)
      return nl1;
      
    NodeSet ns1 = new NodeSet(nl1);
    NodeSet leadNodes = new NodeSet();
    Node endNode = nl2.item(0);
    if (!ns1.contains(endNode))
      return leadNodes; 
      
    for (int i = 0; i < nl1.getLength(); i++)
    {
      Node testNode = nl1.item(i);
      if (DOMHelper.isNodeAfter(testNode, endNode) 
          && !DOMHelper.isNodeTheSame(testNode, endNode))
        leadNodes.addElement(testNode);
    }
    return leadNodes;
  }
  
  
  public static NodeList trailing (NodeList nl1, NodeList nl2)
  {
    if (nl2.getLength() == 0)
      return nl1;
      
    NodeSet ns1 = new NodeSet(nl1);
    NodeSet trailNodes = new NodeSet();
    Node startNode = nl2.item(0);
    if (!ns1.contains(startNode))
      return trailNodes; 
      
    for (int i = 0; i < nl1.getLength(); i++)
    {
      Node testNode = nl1.item(i);
      if (DOMHelper.isNodeAfter(startNode, testNode) 
          && !DOMHelper.isNodeTheSame(startNode, testNode))
        trailNodes.addElement(testNode);          
    }
    return trailNodes;
  }
  
  
  public static NodeList intersection(NodeList nl1, NodeList nl2)
  {
    NodeSet ns1 = new NodeSet(nl1);
    NodeSet ns2 = new NodeSet(nl2);
    NodeSet inter = new NodeSet();

    inter.setShouldCacheNodes(true);

    for (int i = 0; i < ns1.getLength(); i++)
    {
      Node n = ns1.elementAt(i);

      if (ns2.contains(n))
        inter.addElement(n);
    }

    return inter;
  }
  
  
  public static NodeList difference(NodeList nl1, NodeList nl2)
  {
    NodeSet ns1 = new NodeSet(nl1);
    NodeSet ns2 = new NodeSet(nl2);

    NodeSet diff = new NodeSet();

    diff.setShouldCacheNodes(true);

    for (int i = 0; i < ns1.getLength(); i++)
    {
      Node n = ns1.elementAt(i);

      if (!ns2.contains(n))
        diff.addElement(n);
    }

    return diff;
  }
  
  
  public static NodeList distinct(NodeList nl)
  {
    NodeSet dist = new NodeSet();
    dist.setShouldCacheNodes(true);

    Hashtable stringTable = new Hashtable();
    
    for (int i = 0; i < nl.getLength(); i++)
    {
      Node currNode = nl.item(i);
      String key = toString(currNode);
      
      if (key == null)
        dist.addElement(currNode);
      else if (!stringTable.containsKey(key))
      {
        stringTable.put(key, currNode);
        dist.addElement(currNode);      	
      }
    }

    return dist;
  }
  
  
  public static boolean hasSameNode(NodeList nl1, NodeList nl2)
  {
    
    NodeSet ns1 = new NodeSet(nl1);
    NodeSet ns2 = new NodeSet(nl2);

    for (int i = 0; i < ns1.getLength(); i++)
    {
      if (ns2.contains(ns1.elementAt(i)))
        return true;
    }
    return false;
  }
  
}"
org.apache.xalan.xsltc.trax.OutputSettings,2,1,0,0,4,1,0,0,2,1.0,47,1.0,0,0.0,1.0,0,0,18.0,1,0.5,0,"

package org.apache.xalan.xsltc.trax;

import java.util.Properties;

public final class OutputSettings {
    
    private String _cdata_section_elements = null;
    private String _doctype_public = null;
    private String _encoding = null;
    private String _indent = null;
    private String _media_type = null;
    private String _method = null;
    private String _omit_xml_declaration = null;
    private String _standalone = null;
    private String _version = null;

    public Properties getProperties() {
	Properties properties = new Properties();
	return(properties);
    }

    
}
"
org.apache.xml.utils.ListingErrorHandler,17,1,0,4,54,50,0,4,16,0.65625,569,1.0,0,0.0,0.196078431,0,0,32.23529412,14,1.8824,1,"

package org.apache.xml.utils;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.URL;
import java.net.URLConnection;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;

import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;



public class ListingErrorHandler implements ErrorHandler, ErrorListener
{
    protected PrintWriter m_pw = null;
  

    
    public ListingErrorHandler(PrintWriter pw)
    {
        if (null == pw)
            throw new NullPointerException(XMLMessages.createXMLMessage(XMLErrorResources.ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER, null));
            
            
        m_pw = pw;
    }

    
    public ListingErrorHandler()
    {
        m_pw = new PrintWriter(System.err, true);
    }


    
    
    public void warning (SAXParseException exception)
    	throws SAXException
    {
    	logExceptionLocation(m_pw, exception);
        
        
        m_pw.println(""warning: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnWarning())
            throw exception;
    }
    
    
    
    public void error (SAXParseException exception)
    	throws SAXException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""error: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnError())
            throw exception;
    }
    
    
    
    public void fatalError (SAXParseException exception)
    	throws SAXException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""fatalError: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnFatalError())
            throw exception;
    }


    

    
    public void warning(TransformerException exception)
        throws TransformerException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""warning: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnWarning())
            throw exception;
    }

    
    public void error(TransformerException exception)
        throws TransformerException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""error: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnError())
            throw exception;
    }

    
    public void fatalError(TransformerException exception)
        throws TransformerException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""error: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnError())
            throw exception;
    }



    


    
    public static void logExceptionLocation(PrintWriter pw, Throwable exception)
    {
        if (null == pw)
            pw = new PrintWriter(System.err, true);
        
        SourceLocator locator = null;
        Throwable cause = exception;

        
        do
        {
            
            if(cause instanceof SAXParseException)
            {
                
                
                
                
                
                locator = new SAXSourceLocator((SAXParseException)cause);
            }
            else if (cause instanceof TransformerException)
            {
                SourceLocator causeLocator = ((TransformerException)cause).getLocator();
                if(null != causeLocator)
                {
                    locator = causeLocator;
                }
            }
            
            
            if(cause instanceof TransformerException)
                cause = ((TransformerException)cause).getCause();
            else if(cause instanceof WrappedRuntimeException)
                cause = ((WrappedRuntimeException)cause).getException();
            else if(cause instanceof SAXException)
                cause = ((SAXException)cause).getException();
            else
                cause = null;
        }
        while(null != cause);

        
        
        
        if(null != locator)
        {
            String id = (locator.getPublicId() != locator.getPublicId())
                      ? locator.getPublicId()
                        : (null != locator.getSystemId())
                          ? locator.getSystemId() : ""SystemId-Unknown"";

            pw.print(id + "":Line="" + locator.getLineNumber()
                             + "";Column="" + locator.getColumnNumber()+"": "");
            pw.println(""exception:"" + exception.getMessage());
            pw.println(""root-cause:"" 
                       + ((null != cause) ? cause.getMessage() : ""null""));
            logSourceLine(pw, locator); 
        }
        else
        {
            pw.print(""SystemId-Unknown:locator-unavailable: "");
            pw.println(""exception:"" + exception.getMessage());
            pw.println(""root-cause:"" 
                       + ((null != cause) ? cause.getMessage() : ""null""));
        }
    }


    
    public static void logSourceLine(PrintWriter pw, SourceLocator locator)
    {
        if (null == locator)
            return;
            
        if (null == pw)
            pw = new PrintWriter(System.err, true);

        String url = locator.getSystemId();
        
        
        
        if (null == url)
        {
            pw.println(""line: (No systemId; cannot read file)"");
            pw.println();
            return;
        }
        
        

        try
        {
            int line = locator.getLineNumber();
            int column = locator.getColumnNumber();
            pw.println(""line: "" + getSourceLine(url, line));
            StringBuffer buf = new StringBuffer(""line: "");
            for (int i = 1; i < column; i++)
            {
                buf.append(' ');
            }
            buf.append('^');
            pw.println(buf.toString());
        }
        catch (Exception e)
        {
            pw.println(""line: logSourceLine unavailable due to: "" + e.getMessage());
            pw.println();
        }
    }


    
    protected static String getSourceLine(String sourceUrl, int lineNum)
            throws Exception
    {
        URL url = null;
        
        try
        {
            
            url = new URL(sourceUrl);
        }
        catch (java.net.MalformedURLException mue)
        {
            int indexOfColon = sourceUrl.indexOf(':');
            int indexOfSlash = sourceUrl.indexOf('/');
            
            if ((indexOfColon != -1)
                && (indexOfSlash != -1)
                && (indexOfColon < indexOfSlash))
            {
                
                
                throw mue;
            }
            else
            {
                
                url = new URL(SystemIDResolver.getAbsoluteURI(sourceUrl));
                
            }
        }
        
        String line = null;
        InputStream is = null;
        BufferedReader br = null;
        try
        {
            
            URLConnection uc = url.openConnection();
            is = uc.getInputStream();
            br = new BufferedReader(new InputStreamReader(is));

            
            
            for (int i = 1; i <= lineNum; i++)
            {
                line = br.readLine();
            }
            
        } 
        
        
        finally
        {
            br.close();
            is.close();
        }
        
        
        return line;
    }    


    

    
    public void setThrowOnWarning(boolean b)
    {
        throwOnWarning = b;
    }

    
    public boolean getThrowOnWarning()
    {
        return throwOnWarning;
    }

    
    protected boolean throwOnWarning = false;


    
    public void setThrowOnError(boolean b)
    {
        throwOnError = b;
    }

    
    public boolean getThrowOnError()
    {
        return throwOnError;
    }

    
    protected boolean throwOnError = true;


    
    public void setThrowOnFatalError(boolean b)
    {
        throwOnFatalError = b;
    }

    
    public boolean getThrowOnFatalError()
    {
        return throwOnFatalError;
    }

    
    protected boolean throwOnFatalError = true;

}
"
org.apache.xml.dtm.DTMException,15,4,1,12,37,0,11,1,15,0.392857143,357,0.0,0,0.62962963,0.311111111,1,2,22.66666667,8,2.0,0,"
package org.apache.xml.dtm;


import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import javax.xml.transform.SourceLocator;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;



public class DTMException extends RuntimeException {

    
    SourceLocator locator;

    
    public SourceLocator getLocator() {
        return locator;
    }

    
    public void setLocator(SourceLocator location) {
        locator = location;
    }

    
    Throwable containedException;

    
    public Throwable getException() {
        return containedException;
    }

    
    public Throwable getCause() {

        return ((containedException == this)
                ? null
                : containedException);
    }

    
    public synchronized Throwable initCause(Throwable cause) {

        if ((this.containedException == null) && (cause != null)) {
            throw new IllegalStateException(XMLMessages.createXMLMessage(XMLErrorResources.ER_CANNOT_OVERWRITE_CAUSE, null)); 
        }

        if (cause == this) {
            throw new IllegalArgumentException(
                XMLMessages.createXMLMessage(XMLErrorResources.ER_SELF_CAUSATION_NOT_PERMITTED, null)); 
        }

        this.containedException = cause;

        return this;
    }

    
    public DTMException(String message) {

        super(message);

        this.containedException = null;
        this.locator            = null;
    }

    
    public DTMException(Throwable e) {

        super(e.getMessage());

        this.containedException = e;
        this.locator            = null;
    }

    
    public DTMException(String message, Throwable e) {

        super(((message == null) || (message.length() == 0))
              ? e.getMessage()
              : message);

        this.containedException = e;
        this.locator            = null;
    }

    
    public DTMException(String message, SourceLocator locator) {

        super(message);

        this.containedException = null;
        this.locator            = locator;
    }

    
    public DTMException(String message, SourceLocator locator,
                                Throwable e) {

        super(message);

        this.containedException = e;
        this.locator            = locator;
    }

    
    public String getMessageAndLocation() {

        StringBuffer sbuffer = new StringBuffer();
        String       message = super.getMessage();

        if (null != message) {
            sbuffer.append(message);
        }

        if (null != locator) {
            String systemID = locator.getSystemId();
            int    line     = locator.getLineNumber();
            int    column   = locator.getColumnNumber();

            if (null != systemID) {
                sbuffer.append(""; SystemID: "");
                sbuffer.append(systemID);
            }

            if (0 != line) {
                sbuffer.append(""; Line#: "");
                sbuffer.append(line);
            }

            if (0 != column) {
                sbuffer.append(""; Column#: "");
                sbuffer.append(column);
            }
        }

        return sbuffer.toString();
    }

    
    public String getLocationAsString() {

        if (null != locator) {
            StringBuffer sbuffer  = new StringBuffer();
            String       systemID = locator.getSystemId();
            int          line     = locator.getLineNumber();
            int          column   = locator.getColumnNumber();

            if (null != systemID) {
                sbuffer.append(""; SystemID: "");
                sbuffer.append(systemID);
            }

            if (0 != line) {
                sbuffer.append(""; Line#: "");
                sbuffer.append(line);
            }

            if (0 != column) {
                sbuffer.append(""; Column#: "");
                sbuffer.append(column);
            }

            return sbuffer.toString();
        } else {
            return null;
        }
    }

    
    public void printStackTrace() {
        printStackTrace(new java.io.PrintWriter(System.err, true));
    }

    
    public void printStackTrace(java.io.PrintStream s) {
        printStackTrace(new java.io.PrintWriter(s));
    }

    
    public void printStackTrace(java.io.PrintWriter s) {

        if (s == null) {
            s = new java.io.PrintWriter(System.err, true);
        }

        try {
            String locInfo = getLocationAsString();

            if (null != locInfo) {
                s.println(locInfo);
            }

            super.printStackTrace(s);
        } catch (Throwable e) {}

        Throwable exception = getException();

        for (int i = 0; (i < 10) && (null != exception); i++) {
            s.println(""---------"");

            try {
                if (exception instanceof DTMException) {
                    String locInfo =
                        ((DTMException) exception)
                            .getLocationAsString();

                    if (null != locInfo) {
                        s.println(locInfo);
                    }
                }

                exception.printStackTrace(s);
            } catch (Throwable e) {
                s.println(""Could not print stack trace..."");
            }

            try {
                Method meth =
                    ((Object) exception).getClass().getMethod(""getException"",
                        null);

                if (null != meth) {
                    Throwable prev = exception;

                    exception = (Throwable) meth.invoke(exception, null);

                    if (prev == exception) {
                        break;
                    }
                } else {
                    exception = null;
                }
            } catch (InvocationTargetException ite) {
                exception = null;
            } catch (IllegalAccessException iae) {
                exception = null;
            } catch (NoSuchMethodException nsme) {
                exception = null;
            }
        }
    }
}"
org.apache.xalan.extensions.ExtensionsTable,7,1,0,9,25,0,2,7,7,0.5,199,0.5,1,0.0,0.357142857,0,0,27.14285714,1,0.8571,1,"
package org.apache.xalan.extensions;

import java.util.Hashtable;
import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xpath.XPathProcessorException;
import org.apache.xpath.functions.FuncExtFunction;


public class ExtensionsTable
{  
  
  public Hashtable m_extensionFunctionNamespaces = new Hashtable();
  
  
  private StylesheetRoot m_sroot;
  
  
  public ExtensionsTable(StylesheetRoot sroot)
    throws javax.xml.transform.TransformerException
  {
    m_sroot = sroot;
    Vector extensions = m_sroot.getExtensions();
    for (int i = 0; i < extensions.size(); i++)
    {
      ExtensionNamespaceSupport extNamespaceSpt = 
                 (ExtensionNamespaceSupport)extensions.elementAt(i);
      ExtensionHandler extHandler = extNamespaceSpt.launch();
        if (extHandler != null)
          addExtensionNamespace(extNamespaceSpt.getNamespace(), extHandler);
      }
    }
       
  
  public ExtensionHandler get(String extns)
  {
    return (ExtensionHandler) m_extensionFunctionNamespaces.get(extns);
  }

  
  public void addExtensionNamespace(String uri, ExtensionHandler extNS)
  {
    m_extensionFunctionNamespaces.put(uri, extNS);
  }

  
  public boolean functionAvailable(String ns, String funcName)
          throws javax.xml.transform.TransformerException
  {
    boolean isAvailable = false;
    
    if (null != ns)
    {
      ExtensionHandler extNS = 
           (ExtensionHandler) m_extensionFunctionNamespaces.get(ns);
      if (extNS != null)
        isAvailable = extNS.isFunctionAvailable(funcName);
    }
    return isAvailable;
  }
  
  
  public boolean elementAvailable(String ns, String elemName)
          throws javax.xml.transform.TransformerException
  {
    boolean isAvailable = false;
    if (null != ns)
    {
      ExtensionHandler extNS = 
               (ExtensionHandler) m_extensionFunctionNamespaces.get(ns);
      if (extNS != null) 
        isAvailable = extNS.isElementAvailable(elemName);
    } 
    return isAvailable;        
  }  
  
  
  public Object extFunction(String ns, String funcName, 
                            Vector argVec, Object methodKey, 
                            ExpressionContext exprContext)
            throws javax.xml.transform.TransformerException
  {
    Object result = null;
    if (null != ns)
    {
      ExtensionHandler extNS =
        (ExtensionHandler) m_extensionFunctionNamespaces.get(ns);
      if (null != extNS)
      {
        try
        {
          result = extNS.callFunction(funcName, argVec, methodKey,
                                      exprContext);
        }
        catch (javax.xml.transform.TransformerException e)
        {
          throw e;
        }
        catch (Exception e)
        {
          throw new javax.xml.transform.TransformerException(e);
        }
      }
      else
      {
        throw new XPathProcessorException(XSLMessages.createMessage(XSLTErrorResources.ER_EXTENSION_FUNC_UNKNOWN, new Object[]{ns, funcName })); 
        
      }
    }
    return result;    
  }
  
  
  public Object extFunction(FuncExtFunction extFunction, Vector argVec, 
                            ExpressionContext exprContext)
         throws javax.xml.transform.TransformerException
  {
    Object result = null;
    String ns = extFunction.getNamespace();
    if (null != ns)
    {
      ExtensionHandler extNS =
        (ExtensionHandler) m_extensionFunctionNamespaces.get(ns);
      if (null != extNS)
      {
        try
        {
          result = extNS.callFunction(extFunction, argVec, exprContext);
        }
        catch (javax.xml.transform.TransformerException e)
        {
          throw e;
        }
        catch (Exception e)
        {
          throw new javax.xml.transform.TransformerException(e);
        }
      }
      else
      {
        throw new XPathProcessorException(XSLMessages.createMessage(XSLTErrorResources.ER_EXTENSION_FUNC_UNKNOWN, 
                                          new Object[]{ns, extFunction.getFunctionName()})); 
      }
    }
    return result;        
  }
}
"
org.apache.xml.utils.StringToStringTable,11,1,0,1,15,0,1,0,11,0.45,286,1.0,0,0.0,0.606060606,0,0,24.63636364,4,2.1818,1,"
package org.apache.xml.utils;


public class StringToStringTable
{

  
  private int m_blocksize;

  
  private String m_map[];

  
  private int m_firstFree = 0;

  
  private int m_mapSize;

  
  public StringToStringTable()
  {

    m_blocksize = 16;
    m_mapSize = m_blocksize;
    m_map = new String[m_blocksize];
  }

  
  public StringToStringTable(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new String[blocksize];
  }

  
  public final int getLength()
  {
    return m_firstFree;
  }

  
  public final void put(String key, String value)
  {

    if ((m_firstFree + 2) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      String newMap[] = new String[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = key;

    m_firstFree++;

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final String get(String key)
  {

    for (int i = 0; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(key))
        return m_map[i + 1];
    }

    return null;
  }

  
  public final void remove(String key)
  {

    for (int i = 0; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(key))
      {
        if ((i + 2) < m_firstFree)
          System.arraycopy(m_map, i + 2, m_map, i, m_firstFree - (i + 2));

        m_firstFree -= 2;
        m_map[m_firstFree] = null;
        m_map[m_firstFree + 1] = null;

        break;
      }
    }
  }

  
  public final String getIgnoreCase(String key)
  {

    if (null == key)
      return null;

    for (int i = 0; i < m_firstFree; i += 2)
    {
      if (m_map[i].equalsIgnoreCase(key))
        return m_map[i + 1];
    }

    return null;
  }

  
  public final String getByValue(String val)
  {

    for (int i = 1; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(val))
        return m_map[i - 1];
    }

    return null;
  }

  
  public final String elementAt(int i)
  {
    return m_map[i];
  }

  
  public final boolean contains(String key)
  {

    for (int i = 0; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(key))
        return true;
    }

    return false;
  }

  
  public final boolean containsValue(String val)
  {

    for (int i = 1; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(val))
        return true;
    }

    return false;
  }
}
"
org.apache.xalan.xsltc.compiler.UnparsedEntityUriCall,3,4,0,15,14,0,0,15,3,0.0,63,1.0,1,0.979591837,0.444444444,3,13,19.66666667,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.StringType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class UnparsedEntityUriCall extends FunctionCall {
    private Expression _entity;

    public UnparsedEntityUriCall(QName fname, Vector arguments) {
        super(fname, arguments);
        _entity = argument();
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
        final Type entity = _entity.typeCheck(stable);
        if (entity instanceof StringType == false) {
            _entity = new CastExpr(_entity, Type.String);
        }
        return _type = Type.String;
    }
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
        final ConstantPoolGen cpg = classGen.getConstantPool();
        final InstructionList il = methodGen.getInstructionList();
        
        il.append(methodGen.loadDOM());
        
        _entity.translate(classGen, methodGen);
        
        il.append(new INVOKEINTERFACE(
                         cpg.addInterfaceMethodref(DOM_INTF,
                                                   GET_UNPARSED_ENTITY_URI,
                                                   GET_UNPARSED_ENTITY_URI_SIG),
                         2));
    }
}
"
org.apache.xalan.xsltc.dom.AnyNodeCounter,4,2,1,5,11,4,1,5,4,2.0,63,0.0,0,0.823529412,0.5,1,4,14.75,5,1.75,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xml.dtm.DTMAxisIterator;

public abstract class AnyNodeCounter extends NodeCounter {
    public AnyNodeCounter(Translet translet,
			  DOM document, DTMAxisIterator iterator) {
	super(translet, document, iterator);
    }
	
    public NodeCounter setStartNode(int node) {
	_node = node;
	_nodeType = _document.getExpandedTypeID(node);
	return this;
    }

    public String getCounter() {
	int result;
	if (_value != Integer.MIN_VALUE) {
	    result = _value;
	}
	else {
	    int next = _node; 
            final int root = _document.getDocument();
	    result = 0;
	    while (next >= root && !matchesFrom(next)) {
		if (matchesCount(next)) {
		    ++result;	
		}
		next--;


		
	    }
	}
	return formatNumbers(result);
    }

    public static NodeCounter getDefaultNodeCounter(Translet translet,
						    DOM document,
						    DTMAxisIterator iterator) {
	return new DefaultAnyNodeCounter(translet, document, iterator);
    }

    static class DefaultAnyNodeCounter extends AnyNodeCounter {
	public DefaultAnyNodeCounter(Translet translet,
				     DOM document, DTMAxisIterator iterator) {
	    super(translet, document, iterator);
	}

	public String getCounter() {
	    int result;
	    if (_value != Integer.MIN_VALUE) {
		result = _value;
	    }
	    else {
		int next = _node;
		result = 0;
		final int ntype = _document.getExpandedTypeID(_node);
                final int root = _document.getDocument();
		while (next >= 0) {
		    if (ntype == _document.getExpandedTypeID(next)) {
			result++;
		    }


		    if (next == root) {
		        break;
                    }
		    else {
		        --next;
                    }
		}
	    }
	    return formatNumbers(result);
	}
    }
}
"
org.apache.xpath.WhitespaceStrippingElementMatcher,2,1,0,2,2,1,1,1,2,2.0,2,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"
package org.apache.xpath;

import javax.xml.transform.TransformerException;

import org.w3c.dom.Element;


public interface WhitespaceStrippingElementMatcher
{
  
  public boolean shouldStripWhiteSpace(
          XPathContext support, Element targetElement) throws TransformerException;
  
  
  public boolean canStripWhiteSpace();
}"
org.apache.xalan.processor.TransformerFactoryImpl,24,3,0,22,99,190,10,14,20,0.936454849,912,0.307692308,0,0.476190476,0.202898551,1,2,36.45833333,17,1.5833,0,"
package org.apache.xalan.processor;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Properties;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TemplatesHandler;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TrAXFilter;
import org.apache.xalan.transformer.TransformerIdentityImpl;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.XalanProperties;
import org.apache.xml.dtm.ref.sax2dtm.SAX2DTM;
import org.apache.xml.utils.DefaultErrorHandler;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.TreeWalker;

import org.w3c.dom.Node;

import org.xml.sax.InputSource;
import org.xml.sax.XMLFilter;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;


public class TransformerFactoryImpl extends SAXTransformerFactory
{

  
  public static String XSLT_PROPERTIES =
    ""org/apache/xalan/res/XSLTInfo.properties"";

     
  public TransformerFactoryImpl()
  {
  }

  
  private static final Class[] NO_CLASSES = new Class[0];

  
  private static final Object[] NO_OBJS = new Object[0];
  
  
  public static final String FEATURE_INCREMENTAL = ""http:

  
  public static final String FEATURE_OPTIMIZE = ""http:

  
  public static final String FEATURE_SOURCE_LOCATION = XalanProperties.SOURCE_LOCATION;

  
   static 
  {
      try
      {
        InputStream is = null;

        try
        {
          Properties props = new Properties();

          try {
            java.lang.reflect.Method getCCL = Thread.class.getMethod(""getContextClassLoader"", NO_CLASSES);
            if (getCCL != null) {
              ClassLoader contextClassLoader = (ClassLoader) getCCL.invoke(Thread.currentThread(), NO_OBJS);
              is = contextClassLoader.getResourceAsStream(XSLT_PROPERTIES); 
            }
          }
          catch (Exception e) {}

          if (is == null) {
            
            
            
            is = TransformerFactoryImpl.class.getResourceAsStream(""/"" + XSLT_PROPERTIES); 
          }

          
          BufferedInputStream bis = new BufferedInputStream(is);

          props.load(bis);  
          bis.close();  

          
          
          Properties systemProps = System.getProperties();
          Enumeration propEnum = props.propertyNames();

          while (propEnum.hasMoreElements())
          {
            String prop = (String) propEnum.nextElement();

            if (!systemProps.containsKey(prop))
              systemProps.put(prop, props.getProperty(prop));
          }

          System.setProperties(systemProps);

        }
        catch (Exception ex){}
      }
      catch (SecurityException se)
      {

        
        
      }
   }

public javax.xml.transform.Templates processFromNode(Node node)
          throws TransformerConfigurationException
  {

    try
    {
      TemplatesHandler builder = newTemplatesHandler();
      TreeWalker walker = new TreeWalker(builder, new org.apache.xml.utils.DOM2Helper(), builder.getSystemId());

      walker.traverse(node);

      return builder.getTemplates();
    }
    catch (org.xml.sax.SAXException se)
    {
      if (m_errorListener != null)
      {
        try
        {
          m_errorListener.fatalError(new TransformerException(se));
        }
        catch (TransformerException ex)
        {
          throw new TransformerConfigurationException(ex);
        }

        return null;
      }
      else

        
        
        
        throw new TransformerConfigurationException(XSLMessages.createMessage(XSLTErrorResources.ER_PROCESSFROMNODE_FAILED, null), se); 
                                                    
    }
    catch (TransformerConfigurationException tce)
    {
      
      throw tce;
    }
   
    catch (Exception e)
    {
      if (m_errorListener != null)
      {
        try
        {
          m_errorListener.fatalError(new TransformerException(e));
        }
        catch (TransformerException ex)
        {
          throw new TransformerConfigurationException(ex);
        }

        return null;
      }
      else

        
        
        
        throw new TransformerConfigurationException(XSLMessages.createMessage(XSLTErrorResources.ER_PROCESSFROMNODE_FAILED, null), e); 
                                                    
    }
  }

  
  private String m_DOMsystemID = null;

  
  String getDOMsystemID()
  {
    return m_DOMsystemID;
  }

  
  javax.xml.transform.Templates processFromNode(Node node, String systemID)
          throws TransformerConfigurationException
  {

    m_DOMsystemID = systemID;

    return processFromNode(node);
  }

  
  public Source getAssociatedStylesheet(
          Source source, String media, String title, String charset)
            throws TransformerConfigurationException
  {

    String baseID;
    InputSource isource = null;
    Node node = null;
    XMLReader reader = null;

    if (source instanceof DOMSource)
    {
      DOMSource dsource = (DOMSource) source;

      node = dsource.getNode();
      baseID = dsource.getSystemId();
    }
    else
    {
      isource = SAXSource.sourceToInputSource(source);
      baseID = isource.getSystemId();
    }

    
    
    
    StylesheetPIHandler handler = new StylesheetPIHandler(baseID, media,
                                    title, charset);
    
    
    if (m_uriResolver != null) 
    {
      handler.setURIResolver(m_uriResolver); 
    }

    try
    {
      if (null != node)
      {
        TreeWalker walker = new TreeWalker(handler, new org.apache.xml.utils.DOM2Helper(), baseID);

        walker.traverse(node);
      }
      else
      {

        
        try
        {
          javax.xml.parsers.SAXParserFactory factory =
            javax.xml.parsers.SAXParserFactory.newInstance();

          factory.setNamespaceAware(true);

          javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser();

          reader = jaxpParser.getXMLReader();
        }
        catch (javax.xml.parsers.ParserConfigurationException ex)
        {
          throw new org.xml.sax.SAXException(ex);
        }
        catch (javax.xml.parsers.FactoryConfigurationError ex1)
        {
          throw new org.xml.sax.SAXException(ex1.toString());
        }
        catch (NoSuchMethodError ex2){}
        catch (AbstractMethodError ame){}

        if (null == reader)
        {
          reader = XMLReaderFactory.createXMLReader();
        }

        
        reader.setContentHandler(handler);
        reader.parse(isource);
      }
    }
    catch (StopParseException spe)
    {

      
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerConfigurationException(
        ""getAssociatedStylesheets failed"", se);
    }
    catch (IOException ioe)
    {
      throw new TransformerConfigurationException(
        ""getAssociatedStylesheets failed"", ioe);
    }

    return handler.getAssociatedStylesheet();
  }

  
  public TemplatesHandler newTemplatesHandler()
          throws TransformerConfigurationException
  {
    return new StylesheetHandler(this);
  }

  
  public boolean getFeature(String name)
  {

    
    
    if ((DOMResult.FEATURE == name) || (DOMSource.FEATURE == name)
            || (SAXResult.FEATURE == name) || (SAXSource.FEATURE == name)
            || (StreamResult.FEATURE == name)
            || (StreamSource.FEATURE == name)
            || (SAXTransformerFactory.FEATURE == name)
            || (SAXTransformerFactory.FEATURE_XMLFILTER == name))
      return true;
    else if ((DOMResult.FEATURE.equals(name))
             || (DOMSource.FEATURE.equals(name))
             || (SAXResult.FEATURE.equals(name))
             || (SAXSource.FEATURE.equals(name))
             || (StreamResult.FEATURE.equals(name))
             || (StreamSource.FEATURE.equals(name))
             || (SAXTransformerFactory.FEATURE.equals(name))
             || (SAXTransformerFactory.FEATURE_XMLFILTER.equals(name)))
      return true;
    else
      return false;
  }
  
  public static boolean m_optimize = true;
  
  
  public static boolean m_source_location = false;
  
  
  public void setAttribute(String name, Object value)
          throws IllegalArgumentException
  {
    if (name.equals(FEATURE_INCREMENTAL))
    {
      if(value instanceof Boolean)
      {
        
        org.apache.xml.dtm.DTMManager.setIncremental(((Boolean)value).booleanValue());
      }
      else if(value instanceof String)
      {
        
        org.apache.xml.dtm.DTMManager.setIncremental((new Boolean((String)value)).booleanValue());
      }
      else
      {
        
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BAD_VALUE, new Object[]{name, value})); 
      }
	}
    else if (name.equals(FEATURE_OPTIMIZE))
    {
      if(value instanceof Boolean)
      {
        
        m_optimize = ((Boolean)value).booleanValue();
      }
      else if(value instanceof String)
      {
        
        m_optimize = (new Boolean((String)value)).booleanValue();
      }
      else
      {
        
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BAD_VALUE, new Object[]{name, value})); 
      }
    }
    
    
    
    
    
    
    else if(name.equals(FEATURE_SOURCE_LOCATION))
    {
      if(value instanceof Boolean)
      {
        
        m_source_location = ((Boolean)value).booleanValue();
        
        SAX2DTM.setUseSourceLocation(m_source_location);
      }
      else if(value instanceof String)
      {
        
        m_source_location = (new Boolean((String)value)).booleanValue();
        SAX2DTM.setUseSourceLocation(m_source_location);
      }
      else
      {
        
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BAD_VALUE, new Object[]{name, value})); 
      }
    }
    
    else
    {
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NOT_SUPPORTED, new Object[]{name})); 
    }
  }

  
  public Object getAttribute(String name) throws IllegalArgumentException
  {
    if (name.equals(FEATURE_INCREMENTAL))
    {
      return new Boolean(org.apache.xml.dtm.DTMManager.getIncremental());            
    }
    else if (name.equals(FEATURE_OPTIMIZE))
    {
      return new Boolean(m_optimize);
    }
    else if (name.equals(FEATURE_SOURCE_LOCATION))
    {
      return new Boolean(m_source_location);
    }
    else
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_ATTRIB_VALUE_NOT_RECOGNIZED, new Object[]{name})); 
  }

  
  public XMLFilter newXMLFilter(Source src)
          throws TransformerConfigurationException
  {

    Templates templates = newTemplates(src);
    if( templates==null ) return null;
    
    return newXMLFilter(templates);
  }

  
  public XMLFilter newXMLFilter(Templates templates)
          throws TransformerConfigurationException
  {
    try {
      return new TrAXFilter(templates);
    } catch( TransformerConfigurationException ex ) {
      if( m_errorListener != null) {
        try {
          m_errorListener.fatalError( ex );
          return null;
        } catch( TransformerException ex1 ) {
          new TransformerConfigurationException(ex1);
        }
      }
      throw ex;
    }
  }

  
  public TransformerHandler newTransformerHandler(Source src)
          throws TransformerConfigurationException
  {

    Templates templates = newTemplates(src);
    if( templates==null ) return null;
    
    return newTransformerHandler(templates);
  }

  
  public TransformerHandler newTransformerHandler(Templates templates)
          throws TransformerConfigurationException
  {
    try {
      TransformerImpl transformer =
        (TransformerImpl) templates.newTransformer();
      transformer.setURIResolver(m_uriResolver);
      TransformerHandler th =
        (TransformerHandler) transformer.getInputContentHandler(true);

      return th;
    } catch( TransformerConfigurationException ex ) {
      if( m_errorListener != null ) {
        try {
          m_errorListener.fatalError( ex );
          return null;
        } catch (TransformerException ex1 ) {
          ex=new TransformerConfigurationException(ex1);
        }
      }
      throw ex;
    }
    
  }












  
  public TransformerHandler newTransformerHandler()
          throws TransformerConfigurationException
  {















    return new TransformerIdentityImpl();
  }

  
  public Transformer newTransformer(Source source)
          throws TransformerConfigurationException
  {
    try {
      Templates tmpl=newTemplates( source );
      
      if( tmpl==null ) return null;
      Transformer transformer = tmpl.newTransformer();
      transformer.setURIResolver(m_uriResolver);
      return transformer;
    } catch( TransformerConfigurationException ex ) {
      if( m_errorListener != null ) {
        try {
          m_errorListener.fatalError( ex );
          return null;
        } catch( TransformerException ex1 ) {
          ex=new TransformerConfigurationException( ex1 );
        }
      }
      throw ex;
    }
  }

  
  public Transformer newTransformer() throws TransformerConfigurationException
  {















      return new TransformerIdentityImpl();
  }

  
  public Templates newTemplates(Source source)
          throws TransformerConfigurationException
  {

    String baseID = source.getSystemId();

    if (null != baseID) {
       baseID = SystemIDResolver.getAbsoluteURI(baseID);
    }


    if (source instanceof DOMSource)
    {
      DOMSource dsource = (DOMSource) source;
      Node node = dsource.getNode();

      if (null != node)
        return processFromNode(node, baseID);
      else
      {
        String messageStr = XSLMessages.createMessage(
          XSLTErrorResources.ER_ILLEGAL_DOMSOURCE_INPUT, null);

        throw new IllegalArgumentException(messageStr);
      }
    }

    TemplatesHandler builder = newTemplatesHandler();
    builder.setSystemId(baseID);
    
    try
    {
      InputSource isource = SAXSource.sourceToInputSource(source);
      isource.setSystemId(baseID);
      XMLReader reader = null;

      if (source instanceof SAXSource)
        reader = ((SAXSource) source).getXMLReader();
        
      if (null == reader)
      {

        
        try
        {
          javax.xml.parsers.SAXParserFactory factory =
            javax.xml.parsers.SAXParserFactory.newInstance();

          factory.setNamespaceAware(true);

          javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser();

          reader = jaxpParser.getXMLReader();
        }
        catch (javax.xml.parsers.ParserConfigurationException ex)
        {
          throw new org.xml.sax.SAXException(ex);
        }
        catch (javax.xml.parsers.FactoryConfigurationError ex1)
        {
          throw new org.xml.sax.SAXException(ex1.toString());
        }
        catch (NoSuchMethodError ex2){}
        catch (AbstractMethodError ame){}
      }

      if (null == reader)
        reader = XMLReaderFactory.createXMLReader();

      
      
      
      reader.setContentHandler(builder);
      reader.parse(isource);
    }
    catch (org.xml.sax.SAXException se)
    {
      if (m_errorListener != null)
      {
        try
        {
          m_errorListener.fatalError(new TransformerException(se));
        }
        catch (TransformerException ex1)
        {
          throw new TransformerConfigurationException(ex1);
        }
      }
      else
        throw new TransformerConfigurationException(se.getMessage(), se);
    }
    catch (Exception e)
    {
      if (m_errorListener != null)
      {
        try
        {
          m_errorListener.fatalError(new TransformerException(e));

          return null;
        }
        catch (TransformerException ex1)
        {
          throw new TransformerConfigurationException(ex1);
        }
      }
      else
        throw new TransformerConfigurationException(e.getMessage(), e);
    }

    return builder.getTemplates();
  }

  
  URIResolver m_uriResolver;

  
  public void setURIResolver(URIResolver resolver)
  {
    m_uriResolver = resolver;
  }

  
  public URIResolver getURIResolver()
  {
    return m_uriResolver;
  }

  
  private ErrorListener m_errorListener = new DefaultErrorHandler();

  
  public ErrorListener getErrorListener()
  {
    return m_errorListener;
  }

  
  public void setErrorListener(ErrorListener listener)
          throws IllegalArgumentException
  {

    if (null == listener)
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_ERRORLISTENER, null));
      

    m_errorListener = listener;
  }
}
"
org.apache.xalan.xsltc.compiler.DecimalFormatting,5,3,0,21,32,2,2,20,4,1.0,518,1.0,1,0.9375,0.4,3,7,102.0,17,4.4,1,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETSTATIC;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class DecimalFormatting extends TopLevelElement {

    private static final String DFS_CLASS = ""java.text.DecimalFormatSymbols"";
    private static final String DFS_SIG   = ""Ljava/text/DecimalFormatSymbols;"";

    private QName _name = null;

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }

    
    public void parseContents(Parser parser) {
	
	_name = parser.getQNameIgnoreDefaultNs(getAttribute(""name""));
	if (_name == null) {
	    _name = parser.getQNameIgnoreDefaultNs(EMPTYSTRING);
	}

	
	SymbolTable stable = parser.getSymbolTable();
	if (stable.getDecimalFormatting(_name) != null) {
	    reportWarning(this, parser, ErrorMsg.SYMBOLS_REDEF_ERR,
		_name.toString());
	}
	else {
	    stable.addDecimalFormatting(_name, this);
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	
	
        
	final int init = cpg.addMethodref(DFS_CLASS, ""<init>"",
                                          ""(""+LOCALE_SIG+"")V"");

	
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, _name.toString()));

	
	
        
        
	il.append(new NEW(cpg.addClass(DFS_CLASS)));
	il.append(DUP);
        il.append(new GETSTATIC(cpg.addFieldref(LOCALE_CLASS, ""US"",
                                                LOCALE_SIG)));
	il.append(new INVOKESPECIAL(init));

	String tmp = getAttribute(""NaN"");
	if ((tmp == null) || (tmp.equals(EMPTYSTRING))) {
	    int nan = cpg.addMethodref(DFS_CLASS,
				       ""setNaN"", ""(Ljava/lang/String;)V"");
	    il.append(DUP);
	    il.append(new PUSH(cpg, ""NaN""));
	    il.append(new INVOKEVIRTUAL(nan));
	}

	tmp = getAttribute(""infinity"");
	if ((tmp == null) || (tmp.equals(EMPTYSTRING))) {
	    int inf = cpg.addMethodref(DFS_CLASS,
				       ""setInfinity"",
				       ""(Ljava/lang/String;)V"");
	    il.append(DUP);
	    il.append(new PUSH(cpg, ""Infinity""));
	    il.append(new INVOKEVIRTUAL(inf));
	}
	    
	final int nAttributes = _attributes.getLength();
	for (int i = 0; i < nAttributes; i++) {
	    final String name = _attributes.getQName(i);
	    final String value = _attributes.getValue(i);

	    boolean valid = true;
	    int method = 0;

	    if (name.equals(""decimal-separator"")) {
		
		method = cpg.addMethodref(DFS_CLASS,
					  ""setDecimalSeparator"", ""(C)V"");
	    }
	    else if (name.equals(""grouping-separator"")) {
		method =  cpg.addMethodref(DFS_CLASS,
					   ""setGroupingSeparator"", ""(C)V"");
	    }
	    else if (name.equals(""minus-sign"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setMinusSign"", ""(C)V"");
	    }
	    else if (name.equals(""percent"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setPercent"", ""(C)V"");
	    }
	    else if (name.equals(""per-mille"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setPerMill"", ""(C)V"");
	    }
	    else if (name.equals(""zero-digit"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setZeroDigit"", ""(C)V"");
	    }
	    else if (name.equals(""digit"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setDigit"", ""(C)V"");
	    }
	    else if (name.equals(""pattern-separator"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setPatternSeparator"", ""(C)V"");
	    }
	    else if (name.equals(""NaN"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setNaN"", ""(Ljava/lang/String;)V"");
	        il.append(DUP);
		il.append(new PUSH(cpg, value));
		il.append(new INVOKEVIRTUAL(method));
		valid = false;
	    }
	    else if (name.equals(""infinity"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setInfinity"",
					  ""(Ljava/lang/String;)V"");
	        il.append(DUP);
		il.append(new PUSH(cpg, value));
		il.append(new INVOKEVIRTUAL(method));
		valid = false;
	    }
	    else {
		valid = false;
	    }

	    if (valid) {
		il.append(DUP);
		il.append(new PUSH(cpg, value.charAt(0)));
		il.append(new INVOKEVIRTUAL(method));
	    }

	}

	final int put = cpg.addMethodref(TRANSLET_CLASS,
					 ""addDecimalFormat"",
					 ""(""+STRING_SIG+DFS_SIG+"")V"");
	il.append(new INVOKEVIRTUAL(put));
    }

    
    public static void translateDefaultDFS(ClassGenerator classGen,
					   MethodGenerator methodGen) {

	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	final int init = cpg.addMethodref(DFS_CLASS, ""<init>"",
                                          ""(""+LOCALE_SIG+"")V"");

	
	
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, EMPTYSTRING));

	
	
        
        
        
	il.append(new NEW(cpg.addClass(DFS_CLASS)));
	il.append(DUP);
        il.append(new GETSTATIC(cpg.addFieldref(LOCALE_CLASS, ""US"",
                                                LOCALE_SIG)));
	il.append(new INVOKESPECIAL(init));

	int nan = cpg.addMethodref(DFS_CLASS,
				   ""setNaN"", ""(Ljava/lang/String;)V"");
	il.append(DUP);
	il.append(new PUSH(cpg, ""NaN""));
	il.append(new INVOKEVIRTUAL(nan));

	int inf = cpg.addMethodref(DFS_CLASS,
				   ""setInfinity"",
				   ""(Ljava/lang/String;)V"");
	il.append(DUP);
	il.append(new PUSH(cpg, ""Infinity""));
	il.append(new INVOKEVIRTUAL(inf));

	final int put = cpg.addMethodref(TRANSLET_CLASS,
					 ""addDecimalFormat"",
					 ""(""+STRING_SIG+DFS_SIG+"")V"");
	il.append(new INVOKEVIRTUAL(put));
    }
}
"
org.apache.xalan.xsltc.dom.AbsoluteIterator,8,2,0,3,21,0,1,3,8,0.0,85,1.0,1,0.65,0.34375,1,5,9.5,2,1.0,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;
import org.apache.xml.dtm.ref.DTMDefaultBase;


public final class AbsoluteIterator extends DTMAxisIteratorBase {

    
    private DTMAxisIterator _source;

    public AbsoluteIterator(DTMAxisIterator source) {
	_source = source;

    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }

    public DTMAxisIterator setStartNode(int node) {
	_startNode = DTMDefaultBase.ROOTNODE;
	if (_isRestartable) {
	    _source.setStartNode(_startNode);
	    resetPosition();
	}
	return this;
    }

    public int next() {
	return returnNode(_source.next());
    }

    public DTMAxisIterator cloneIterator() {
	try {
	    final AbsoluteIterator clone = (AbsoluteIterator) super.clone();
	    clone._source = _source.cloneIterator();	
	    clone.resetPosition();
	    clone._isRestartable = false;
	    return clone;
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }

    public DTMAxisIterator reset() {
	_source.reset();
	return resetPosition();
    }
    
    public void setMark() {
	_source.setMark();
    }

    public void gotoMark() {
	_source.gotoMark();
    }
}
"
org.apache.xalan.xsltc.compiler.NamespaceUriCall,3,5,0,9,11,3,0,9,3,2.0,37,0.0,0,0.99,0.533333333,3,5,11.33333333,1,0.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;

final class NamespaceUriCall extends NameBase {

    
    public NamespaceUriCall(QName fname) {
	super(fname);
    }

    
    public NamespaceUriCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getNamespace = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getNamespaceName"",
							   ""(I)""+STRING_SIG);
	super.translate(classGen, methodGen);
	il.append(new INVOKEINTERFACE(getNamespace, 2));
    }
}
"
org.apache.xalan.xsltc.compiler.ContainsCall,5,4,0,18,22,4,0,18,5,0.25,126,1.0,2,0.96,0.4,3,14,23.8,1,0.8,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.IFLT;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class ContainsCall extends FunctionCall {

    private Expression _base = null;
    private Expression _token = null;

    
    public ContainsCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public boolean isBoolean() {
	return true;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	if (argumentCount() != 2) {
	    throw new TypeCheckError(ErrorMsg.ILLEGAL_ARG_ERR, getName(), this);
	}

	
	_base = argument(0);
	Type baseType = _base.typeCheck(stable);	
	if (baseType != Type.String)
	    _base = new CastExpr(_base, Type.String);

	
	_token = argument(1);
	Type tokenType = _token.typeCheck(stable);	
	if (tokenType != Type.String)
	    _token = new CastExpr(_token, Type.String);

	return _type = Type.Boolean;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	translateDesynthesized(classGen, methodGen);
	synthesize(classGen, methodGen);
    }

    
    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	_base.translate(classGen, methodGen);
	_token.translate(classGen, methodGen);
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_CLASS,
						     ""indexOf"",
						     ""(""+STRING_SIG+"")I"")));
	_falseList.add(il.append(new IFLT(null)));
    }
}
"
org.apache.xalan.xsltc.dom.CollatorFactoryBase,4,1,0,2,9,4,1,1,3,0.666666667,29,0.0,0,0.0,0.555555556,0,0,5.75,2,0.75,0,"

package org.apache.xalan.xsltc.dom;

import java.text.Collator;
import java.util.Locale;

import org.apache.xalan.xsltc.CollatorFactory;

public class CollatorFactoryBase implements CollatorFactory {
    
    public static final Locale DEFAULT_LOCALE = Locale.getDefault();
    public static final Collator DEFAULT_COLLATOR = Collator.getInstance();
    
    public CollatorFactoryBase() {
    }
    
    public Collator getCollator(String lang, String country) {
        return Collator.getInstance(new Locale(lang, country));
    }
    
    public Collator getCollator(Locale locale) {
        if (locale == DEFAULT_LOCALE)
            return DEFAULT_COLLATOR;
        else
            return Collator.getInstance(locale);
    }
}
"
org.apache.xml.serializer.SerializerTrace,6,1,0,4,6,15,4,0,6,1.2,18,0.0,0,0.0,0.533333333,0,0,0.0,1,1.0,0,"
package org.apache.xml.serializer;

import org.xml.sax.Attributes;



public interface SerializerTrace {
    
  
  public static final int EVENTTYPE_STARTDOCUMENT = 1;

  
  public static final int EVENTTYPE_ENDDOCUMENT = 2;

  
  public static final int EVENTTYPE_STARTELEMENT = 3;

  
  public static final int EVENTTYPE_ENDELEMENT = 4;

  
  public static final int EVENTTYPE_CHARACTERS = 5;

  
  public static final int EVENTTYPE_IGNORABLEWHITESPACE = 6;

  
  public static final int EVENTTYPE_PI = 7;

  
  public static final int EVENTTYPE_COMMENT = 8;

  
  public static final int EVENTTYPE_ENTITYREF = 9;

  
  public static final int EVENTTYPE_CDATA = 10;
  
  
  public static final int EVENTTYPE_OUTPUT_PSEUDO_CHARACTERS = 11;
  
  
  public static final int EVENTTYPE_OUTPUT_CHARACTERS = 12;
    

  
  public boolean hasTraceListeners();
  
  
  public void fireGenerateEvent(int eventType);
  
  
  public void fireGenerateEvent(int eventType, String name, Attributes atts);
  
  
  public void fireGenerateEvent(int eventType, char ch[], int start, int length);
  
  
  public void fireGenerateEvent(int eventType, String name, String data);
  

  
  public void fireGenerateEvent(int eventType, String data);
  
}
"
org.apache.xalan.processor.XSLTElementDef,37,1,1,8,57,440,6,4,0,0.793209877,812,0.722222222,3,0.0,0.289189189,0,0,20.45945946,15,2.2162,0,"
package org.apache.xalan.processor;

import java.util.Enumeration;
import java.util.Hashtable;

import org.apache.xalan.templates.Constants;
import org.apache.xml.utils.QName;


public class XSLTElementDef
{

  
  XSLTElementDef(){}

  
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject)
  {
    build(namespace, name, nameAlias, elements, attributes, contentHandler,
          classObject);
    if ( (null != namespace)
    &&  (namespace.equals(Constants.S_XSLNAMESPACEURL)
        || namespace.equals(Constants.S_BUILTIN_EXTENSIONS_URL)
        || namespace.equals(Constants.S_BUILTIN_OLD_EXTENSIONS_URL)))
    {
      schema.addAvailableElement(new QName(namespace, name));
      if(null != nameAlias)
        schema.addAvailableElement(new QName(namespace, nameAlias));
    } 
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, boolean has_required)
  {
		this.m_has_required = has_required;
    build(namespace, name, nameAlias, elements, attributes, contentHandler,
          classObject);
    if ( (null != namespace)
    &&  (namespace.equals(Constants.S_XSLNAMESPACEURL)
        || namespace.equals(Constants.S_BUILTIN_EXTENSIONS_URL)
        || namespace.equals(Constants.S_BUILTIN_OLD_EXTENSIONS_URL)))
    {
      schema.addAvailableElement(new QName(namespace, name));
      if(null != nameAlias)
        schema.addAvailableElement(new QName(namespace, nameAlias));
    } 
		
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 boolean has_required, boolean required)
  {
    this(schema, namespace, name,  nameAlias,
                 elements, attributes,
                 contentHandler, classObject, has_required);
		this.m_required = required;
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 boolean has_required, boolean required, int order, 
								 boolean multiAllowed)
  {
		this(schema, namespace, name,  nameAlias,
                 elements, attributes,
                 contentHandler, classObject, has_required, required);    
		this.m_order = order;
		this.m_multiAllowed = multiAllowed;
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 boolean has_required, boolean required, boolean has_order, int order, 
								 boolean multiAllowed)
  {
		this(schema, namespace, name,  nameAlias,
                 elements, attributes,
                 contentHandler, classObject, has_required, required);    
		this.m_order = order;
		this.m_multiAllowed = multiAllowed;
    this.m_isOrdered = has_order;		
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 boolean has_order, int order, boolean multiAllowed)
  {
    this(schema, namespace, name,  nameAlias,
                 elements, attributes,
                 contentHandler, classObject, 
								 order, multiAllowed);
		this.m_isOrdered = has_order;		
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 int order, boolean multiAllowed)
  {
    this(schema, namespace, name, nameAlias, elements, attributes, contentHandler,
          classObject);
    this.m_order = order;
		this.m_multiAllowed = multiAllowed;
  }

  
  XSLTElementDef(Class classObject, XSLTElementProcessor contentHandler,
                 int type)
  {

    this.m_classObject = classObject;
    this.m_type = type;

    setElementProcessor(contentHandler);
  }

  
  void build(String namespace, String name, String nameAlias,
             XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
             XSLTElementProcessor contentHandler, Class classObject)
  {

    this.m_namespace = namespace;
    this.m_name = name;
    this.m_nameAlias = nameAlias;
    this.m_elements = elements;
    this.m_attributes = attributes;

    setElementProcessor(contentHandler);

    this.m_classObject = classObject;
		
		if (hasRequired() && m_elements != null)
		{
			int n = m_elements.length;
			for (int i = 0; i < n; i++)
			{
				XSLTElementDef def = m_elements[i];
				
				if (def != null && def.getRequired())
				{
					if (m_requiredFound == null)			
						m_requiredFound = new Hashtable();
					m_requiredFound.put(def.getName(), ""xsl:"" +def.getName()); 
				}
			}
		}
  }

  
  private static boolean equalsMayBeNull(Object obj1, Object obj2)
  {
    return (obj2 == obj1)
           || ((null != obj1) && (null != obj2) && obj2.equals(obj1));
  }

  
  private static boolean equalsMayBeNullOrZeroLen(String s1, String s2)
  {

    int len1 = (s1 == null) ? 0 : s1.length();
    int len2 = (s2 == null) ? 0 : s2.length();

    return (len1 != len2) ? false 
						 : (len1 == 0) ? true 
								 : s1.equals(s2);
  }

  
  static final int T_ELEMENT = 1, T_PCDATA = 2, T_ANY = 3;

  
  private int m_type = T_ELEMENT;

  
  int getType()
  {
    return m_type;
  }

  
  void setType(int t)
  {
    m_type = t;
  }

  
  private String m_namespace;

  
  String getNamespace()
  {
    return m_namespace;
  }

  
  private String m_name;

  
  String getName()
  {
    return m_name;
  }

  
  private String m_nameAlias;

  
  String getNameAlias()
  {
    return m_nameAlias;
  }

  
  private XSLTElementDef[] m_elements;

  
  XSLTElementDef[] getElements()
  {
    return m_elements;
  }

  
  void setElements(XSLTElementDef[] defs)
  {
    m_elements = defs;
  }

  
  private boolean QNameEquals(String uri, String localName)
  {

    return (equalsMayBeNullOrZeroLen(m_namespace, uri)
            && (equalsMayBeNullOrZeroLen(m_name, localName)
                || equalsMayBeNullOrZeroLen(m_nameAlias, localName)));
  }

  
  XSLTElementProcessor getProcessorFor(String uri, String localName) 
	{

    XSLTElementProcessor elemDef = null;  

    if (null == m_elements)
      return null;

    int n = m_elements.length;
    int order = -1;
		boolean multiAllowed = true;
    for (int i = 0; i < n; i++)
    {
      XSLTElementDef def = m_elements[i];

      
      
      
      if (def.m_name.equals(""*""))
      {
				
        
        if (!equalsMayBeNullOrZeroLen(uri, Constants.S_XSLNAMESPACEURL))
				{
          elemDef = def.m_elementProcessor;
				  order = def.getOrder();
					multiAllowed = def.getMultiAllowed();
				}
      }
			else if (def.QNameEquals(uri, localName))
			{	
				if (def.getRequired())
					this.setRequiredFound(def.getName(), true);
				order = def.getOrder();
				multiAllowed = def.getMultiAllowed();
				elemDef = def.m_elementProcessor;
				break;
			}
		}		
		
		if (elemDef != null && this.isOrdered())
		{			
			int lastOrder = getLastOrder();
			if (order > lastOrder)
				setLastOrder(order);
			else if (order == lastOrder && !multiAllowed)
			{
				return null;
			}
			else if (order < lastOrder && order > 0)
			{
				return null;
			}
		}

    return elemDef;
  }

  
  XSLTElementProcessor getProcessorForUnknown(String uri, String localName)
  {

    
    if (null == m_elements)
      return null;

    int n = m_elements.length;

    for (int i = 0; i < n; i++)
    {
      XSLTElementDef def = m_elements[i];

      if (def.m_name.equals(""unknown"") && uri.length() > 0)
      {
        return def.m_elementProcessor;
      }
    }

    return null;
  }

  
  private XSLTAttributeDef[] m_attributes;

  
  XSLTAttributeDef[] getAttributes()
  {
    return m_attributes;
  }

  
  XSLTAttributeDef getAttributeDef(String uri, String localName)
  {

    XSLTAttributeDef defaultDef = null;
    XSLTAttributeDef[] attrDefs = getAttributes();
    int nAttrDefs = attrDefs.length;

    for (int k = 0; k < nAttrDefs; k++)
    {
      XSLTAttributeDef attrDef = attrDefs[k];
      String uriDef = attrDef.getNamespace();
      String nameDef = attrDef.getName();
      
      if (nameDef.equals(""*"") && (equalsMayBeNullOrZeroLen(uri, uriDef) || 
          (uriDef != null && uriDef.equals(""*"") && uri!=null && uri.length() > 0 )))
      {
        return attrDef;
      }
      else if (nameDef.equals(""*"") && (uriDef == null))
      {

        
        
        defaultDef = attrDef;
      }
      else if (equalsMayBeNullOrZeroLen(uri, uriDef)
               && localName.equals(nameDef))
      {
        return attrDef;
      }
    }

    if (null == defaultDef)
    {
      if (uri.length() > 0 && !equalsMayBeNullOrZeroLen(uri, Constants.S_XSLNAMESPACEURL))
      {
        return XSLTAttributeDef.m_foreignAttr;
      }
    }

    return defaultDef;
  }

  
  private XSLTElementProcessor m_elementProcessor;

  
  XSLTElementProcessor getElementProcessor()
  {
    return m_elementProcessor;
  }

  
  void setElementProcessor(XSLTElementProcessor handler)
  {

    if (handler != null)
    {
      m_elementProcessor = handler;

      m_elementProcessor.setElemDef(this);
    }
  }

  
  private Class m_classObject;

  
  Class getClassObject()
  {
    return m_classObject;
  }
	
	
  private boolean m_has_required = false;

  
  boolean hasRequired()
  {
    return m_has_required;
  }
	
	
  private boolean m_required = false;

  
  boolean getRequired()
  {
    return m_required;
  }
	
	Hashtable m_requiredFound;
	
	
  void setRequiredFound(String elem, boolean found)
  {
   if (m_requiredFound.get(elem) != null) 
		 m_requiredFound.remove(elem);
  }
	
	
  boolean getRequiredFound()
  {
		if (m_requiredFound == null)
			return true;
    return m_requiredFound.isEmpty();
  }
	
	
  String getRequiredElem()
  {
		if (m_requiredFound == null)
			return null;
		Enumeration elems = m_requiredFound.elements();
		String s = """";
		boolean first = true;
		while (elems.hasMoreElements())
		{
			if (first)
				first = false;
			else
			 s = s + "", "";
			s = s + (String)elems.nextElement();
		}
    return s;
  }
	
	boolean m_isOrdered = false;	
	
	
  boolean isOrdered()
  {
		
			return m_isOrdered;
  }
	
	
  private int m_order = -1;
	
	
  int getOrder()
  {
    return m_order;
  }
	
	
  private int m_lastOrder = -1;
	
	
  int getLastOrder()
  {
    return m_lastOrder;
  }
	
	
  void setLastOrder(int order)
  {
    m_lastOrder = order ;
  }
	
	
  private boolean m_multiAllowed = true;
	
	
  boolean getMultiAllowed()
  {
    return m_multiAllowed;
  }
}
"
org.apache.xalan.xsltc.compiler.Pattern,4,3,2,17,5,6,11,6,4,2.0,7,0.0,0,0.959459459,0.4375,2,4,0.75,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

public abstract class Pattern extends Expression {
    
    public abstract Type typeCheck(SymbolTable stable) throws TypeCheckError;

    
    public abstract void translate(ClassGenerator classGen,
				   MethodGenerator methodGen);

    
    public abstract double getPriority();
}
"
org.apache.xalan.xsltc.compiler.ArgumentList,2,1,0,1,7,0,0,1,2,0.0,35,1.0,2,0.0,0.666666667,0,0,15.5,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

final class ArgumentList {
    private final Expression   _arg;
    private final ArgumentList _rest;
	
    public ArgumentList(Expression arg, ArgumentList rest) {
	_arg = arg;
	_rest = rest;
    }
		
    public String toString() {
	return _rest == null
	    ? _arg.toString()
	    : _arg.toString() + "", "" + _rest.toString();
    }
}
"
org.apache.xalan.xsltc.compiler.StringCall,3,4,0,13,17,3,0,13,3,2.0,75,0.0,0,0.979591837,0.444444444,3,13,24.0,3,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class StringCall extends FunctionCall {
    public StringCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final int argc = argumentCount();
	if (argc > 1) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ILLEGAL_ARG_ERR, this);
	    throw new TypeCheckError(err);
	}

	if (argc > 0) {
	    argument().typeCheck(stable);
	}
	return _type = Type.String;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	Type targ;

	if (argumentCount() == 0) {
	    il.append(methodGen.loadContextNode());
	    targ = Type.Node;
	}
	else {
	    final Expression arg = argument();
	    arg.translate(classGen, methodGen);
	    arg.startResetIterator(classGen, methodGen);
	    targ = arg.getType();
	}

	if (!targ.identicalTo(Type.String)) {
	    targ.translateTo(classGen, methodGen, Type.String);
	}
    }
}
"
org.apache.xalan.extensions.MethodResolver,13,1,0,11,70,66,2,9,6,0.952898551,2002,0.043478261,7,0.0,0.266666667,0,0,151.2307692,14,3.2308,0,"
package org.apache.xalan.extensions;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xpath.objects.XString;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;


public class MethodResolver
{

  
  public static final int STATIC_ONLY         = 1;

  
  public static final int INSTANCE_ONLY       = 2;

  
  public static final int STATIC_AND_INSTANCE = 3;

  
  public static final int DYNAMIC             = 4;

  
  public static Constructor getConstructor(Class classObj, 
                                           Object[] argsIn, 
                                           Object[][] argsOut,
                                           ExpressionContext exprContext)
    throws NoSuchMethodException,
           SecurityException,
           TransformerException
  {
    Constructor bestConstructor = null;
    Class[] bestParamTypes = null;
    Constructor[] constructors = classObj.getConstructors();
    int nMethods = constructors.length;
    int bestScore = Integer.MAX_VALUE;
    int bestScoreCount = 0;
    for(int i = 0; i < nMethods; i++)
    {
      Constructor ctor = constructors[i];
      Class[] paramTypes = ctor.getParameterTypes();
      int numberMethodParams = paramTypes.length;
      int paramStart = 0;
      boolean isFirstExpressionContext = false;
      int scoreStart;
      
      
      
      if(numberMethodParams == (argsIn.length+1))
      {
        Class javaClass = paramTypes[0];
        
        if(ExpressionContext.class.isAssignableFrom(javaClass))
        {
          isFirstExpressionContext = true;
          scoreStart = 0;
          paramStart++;
          
        }
        else
          continue;
      }
      else
          scoreStart = 1000;
      
      if(argsIn.length == (numberMethodParams - paramStart))
      {
        
        int score = scoreMatch(paramTypes, paramStart, argsIn, scoreStart);
        
        if(-1 == score)	
          continue;
        if(score < bestScore)
        {
          
          bestConstructor = ctor;
          bestParamTypes = paramTypes;
          bestScore = score;
          bestScoreCount = 1;
        }
        else if (score == bestScore)
          bestScoreCount++;
      }
    }

    if(null == bestConstructor)
    {
      throw new NoSuchMethodException(errString(""function"", ""constructor"", classObj,
                                                                        """", 0, argsIn));
    }
    
    else
      convertParams(argsIn, argsOut, bestParamTypes, exprContext);
    
    return bestConstructor;
  }

  
  
  public static Method getMethod(Class classObj,
                                 String name, 
                                 Object[] argsIn, 
                                 Object[][] argsOut,
                                 ExpressionContext exprContext,
                                 int searchMethod)
    throws NoSuchMethodException,
           SecurityException,
           TransformerException
  {
    
    
    if (name.indexOf(""-"")>0)
      name = replaceDash(name);
    Method bestMethod = null;
    Class[] bestParamTypes = null;
    Method[] methods = classObj.getMethods();
    int nMethods = methods.length;
    int bestScore = Integer.MAX_VALUE;
    int bestScoreCount = 0;
    boolean isStatic;
    for(int i = 0; i < nMethods; i++)
    {
      Method method = methods[i];
      
      int xsltParamStart = 0;
      if(method.getName().equals(name))
      {
        isStatic = Modifier.isStatic(method.getModifiers());
        switch(searchMethod)
        {
          case STATIC_ONLY:
            if (!isStatic)
            {
              continue;
            }
            break;

          case INSTANCE_ONLY:
            if (isStatic)
            {
              continue;
            }
            break;

          case STATIC_AND_INSTANCE:
            break;

          case DYNAMIC:
            if (!isStatic)
              xsltParamStart = 1;
        }
        int javaParamStart = 0;
        Class[] paramTypes = method.getParameterTypes();
        int numberMethodParams = paramTypes.length;
        boolean isFirstExpressionContext = false;
        int scoreStart;
        
        
        
        int argsLen = (null != argsIn) ? argsIn.length : 0;
        if(numberMethodParams == (argsLen-xsltParamStart+1))
        {
          Class javaClass = paramTypes[0];
          if(ExpressionContext.class.isAssignableFrom(javaClass))
          {
            isFirstExpressionContext = true;
            scoreStart = 0;
            javaParamStart++;
          }
          else
          {
            continue;
          }
        }
        else
            scoreStart = 1000;
        
        if((argsLen - xsltParamStart) == (numberMethodParams - javaParamStart))
        {
          
          int score = scoreMatch(paramTypes, javaParamStart, argsIn, scoreStart);
          
          if(-1 == score)
            continue;
          if(score < bestScore)
          {
            
            bestMethod = method;
            bestParamTypes = paramTypes;
            bestScore = score;
            bestScoreCount = 1;
          }
          else if (score == bestScore)
            bestScoreCount++;
        }
      }
    }
    
    if (null == bestMethod)
    {
      throw new NoSuchMethodException(errString(""function"", ""method"", classObj,
                                                                name, searchMethod, argsIn));
    }
    
    else
      convertParams(argsIn, argsOut, bestParamTypes, exprContext);
    
    return bestMethod;
  }
  
  
  private static String replaceDash(String name)
  {
    char dash = '-';
    StringBuffer buff = new StringBuffer("""");
    for (int i=0; i<name.length(); i++)
    {
      if (name.charAt(i) == dash)
      {}
      else if (i > 0 && name.charAt(i-1) == dash)
        buff.append(Character.toUpperCase(name.charAt(i)));
      else
        buff.append(name.charAt(i));
    }
    return buff.toString();
  }
  
  
  public static Method getElementMethod(Class classObj,
                                        String name)
    throws NoSuchMethodException,
           SecurityException,
           TransformerException
  {
    
    
    Method bestMethod = null;
    Method[] methods = classObj.getMethods();
    int nMethods = methods.length;
    int bestScoreCount = 0;
    for(int i = 0; i < nMethods; i++)
    {
      Method method = methods[i];
      
      if(method.getName().equals(name))
      {
        Class[] paramTypes = method.getParameterTypes();
        if ( (paramTypes.length == 2)
           && paramTypes[1].isAssignableFrom(org.apache.xalan.templates.ElemExtensionCall.class)
                                         && paramTypes[0].isAssignableFrom(org.apache.xalan.extensions.XSLProcessorContext.class) )
        {
          if ( ++bestScoreCount == 1 )
            bestMethod = method;
          else
            break;
        }
      }
    }
    
    if (null == bestMethod)
    {
      throw new NoSuchMethodException(errString(""element"", ""method"", classObj,
                                                                        name, 0, null));
    }
    else if (bestScoreCount > 1)
      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_MORE_MATCH_ELEMENT, new Object[]{name})); 
    
    return bestMethod;
  }
  

  
  public static void convertParams(Object[] argsIn, 
                                   Object[][] argsOut, Class[] paramTypes,
                                   ExpressionContext exprContext)
    throws javax.xml.transform.TransformerException
  {
    
    if (paramTypes == null)
      argsOut[0] = null;
    else
    {
      int nParams = paramTypes.length;
      argsOut[0] = new Object[nParams];
      int paramIndex = 0;
      if((nParams > 0) 
         && ExpressionContext.class.isAssignableFrom(paramTypes[0]))
      {
        argsOut[0][0] = exprContext;
        
        paramIndex++;
      }

      if (argsIn != null)
      {
        for(int i = argsIn.length - nParams + paramIndex ; paramIndex < nParams; i++, paramIndex++)
        {
          
          argsOut[0][paramIndex] = convert(argsIn[i], paramTypes[paramIndex]);
        }
      }
    }
  }
  
  
  static class ConversionInfo
  {
    ConversionInfo(Class cl, int score)
    {
      m_class = cl;
      m_score = score;
    }
    
    Class m_class;  
    int m_score; 
  }
  
  private static final int SCOREBASE=1;
  
  
  static ConversionInfo[] m_javaObjConversions = {
    new ConversionInfo(Double.TYPE, 11),
    new ConversionInfo(Float.TYPE, 12),
    new ConversionInfo(Long.TYPE, 13),
    new ConversionInfo(Integer.TYPE, 14),
    new ConversionInfo(Short.TYPE, 15),
    new ConversionInfo(Character.TYPE, 16),
    new ConversionInfo(Byte.TYPE, 17),
    new ConversionInfo(java.lang.String.class, 18)
  };
  
  
  static ConversionInfo[] m_booleanConversions = {
    new ConversionInfo(Boolean.TYPE, 0),
    new ConversionInfo(java.lang.Boolean.class, 1),
    new ConversionInfo(java.lang.Object.class, 2),
    new ConversionInfo(java.lang.String.class, 3)
  };

  
  static ConversionInfo[] m_numberConversions = {
    new ConversionInfo(Double.TYPE, 0),
    new ConversionInfo(java.lang.Double.class, 1),
    new ConversionInfo(Float.TYPE, 3),
    new ConversionInfo(Long.TYPE, 4),
    new ConversionInfo(Integer.TYPE, 5),
    new ConversionInfo(Short.TYPE, 6),
    new ConversionInfo(Character.TYPE, 7),
    new ConversionInfo(Byte.TYPE, 8),
    new ConversionInfo(Boolean.TYPE, 9),
    new ConversionInfo(java.lang.String.class, 10),
    new ConversionInfo(java.lang.Object.class, 11)
  };

  
  static ConversionInfo[] m_stringConversions = {
    new ConversionInfo(java.lang.String.class, 0),
    new ConversionInfo(java.lang.Object.class, 1),
    new ConversionInfo(Character.TYPE, 2),
    new ConversionInfo(Double.TYPE, 3),
    new ConversionInfo(Float.TYPE, 3),
    new ConversionInfo(Long.TYPE, 3),
    new ConversionInfo(Integer.TYPE, 3),
    new ConversionInfo(Short.TYPE, 3),
    new ConversionInfo(Byte.TYPE, 3),
    new ConversionInfo(Boolean.TYPE, 4)
  };

  
  static ConversionInfo[] m_rtfConversions = {
    new ConversionInfo(org.w3c.dom.traversal.NodeIterator.class, 0),
    new ConversionInfo(org.w3c.dom.NodeList.class, 1),
    new ConversionInfo(org.w3c.dom.Node.class, 2),
    new ConversionInfo(java.lang.String.class, 3),
    new ConversionInfo(java.lang.Object.class, 5),
    new ConversionInfo(Character.TYPE, 6),
    new ConversionInfo(Double.TYPE, 7),
    new ConversionInfo(Float.TYPE, 7),
    new ConversionInfo(Long.TYPE, 7),
    new ConversionInfo(Integer.TYPE, 7),
    new ConversionInfo(Short.TYPE, 7),
    new ConversionInfo(Byte.TYPE, 7),
    new ConversionInfo(Boolean.TYPE, 8)
  };
  
  
  static ConversionInfo[] m_nodesetConversions = {
    new ConversionInfo(org.w3c.dom.traversal.NodeIterator.class, 0),
    new ConversionInfo(org.w3c.dom.NodeList.class, 1),
    new ConversionInfo(org.w3c.dom.Node.class, 2),
    new ConversionInfo(java.lang.String.class, 3),
    new ConversionInfo(java.lang.Object.class, 5),
    new ConversionInfo(Character.TYPE, 6),
    new ConversionInfo(Double.TYPE, 7),
    new ConversionInfo(Float.TYPE, 7),
    new ConversionInfo(Long.TYPE, 7),
    new ConversionInfo(Integer.TYPE, 7),
    new ConversionInfo(Short.TYPE, 7),
    new ConversionInfo(Byte.TYPE, 7),
    new ConversionInfo(Boolean.TYPE, 8)
  };
  
  
  static ConversionInfo[][] m_conversions = 
  {
    m_javaObjConversions, 
    m_booleanConversions, 
    m_numberConversions,  
    m_stringConversions,  
    m_nodesetConversions, 
    m_rtfConversions      
  };
  
  
  public static int scoreMatch(Class[] javaParamTypes, int javaParamsStart,
                               Object[] xsltArgs, int score)
  {
    if ((xsltArgs == null) || (javaParamTypes == null))
      return score;
    int nParams = xsltArgs.length;
    for(int i = nParams - javaParamTypes.length + javaParamsStart, javaParamTypesIndex = javaParamsStart; 
        i < nParams; 
        i++, javaParamTypesIndex++)
    {
      Object xsltObj = xsltArgs[i];
      int xsltClassType = (xsltObj instanceof XObject) 
                          ? ((XObject)xsltObj).getType() 
                            : XObject.CLASS_UNKNOWN;
      Class javaClass = javaParamTypes[javaParamTypesIndex];
      
      
      
      
      if(xsltClassType == XObject.CLASS_NULL)
      {
        
        
        if(!javaClass.isPrimitive())
        {
          
          score += 10;
          continue;
        }
        else
          return -1;  
      }
      
      ConversionInfo[] convInfo = m_conversions[xsltClassType];
      int nConversions = convInfo.length;
      int k;
      for(k = 0; k < nConversions; k++)
      {
        ConversionInfo cinfo = convInfo[k];
        if(javaClass.isAssignableFrom(cinfo.m_class))
        {
          score += cinfo.m_score;
          break; 
        }
      }

      if (k == nConversions)
      {
        
        
        
        

        
        
        
        
        

        
        
        
        
        
        
        
        
        
        
        
                                
        
        

        if (XObject.CLASS_UNKNOWN == xsltClassType)
        {
          Class realClass = null;

          if (xsltObj instanceof XObject)
          {
            Object realObj = ((XObject) xsltObj).object();
            if (null != realObj)
            {
              realClass = realObj.getClass();
            }
            else
            {
              
              score += 10;
              continue;
            }
          }
          else
          {
            realClass = xsltObj.getClass();
          }

          if (javaClass.isAssignableFrom(realClass))
          {
            score += 0;         
          }
          else
            return -1;
        }
        else
          return -1;
      }
    }
    return score;
  }
  
  
  static Object convert(Object xsltObj, Class javaClass)
    throws javax.xml.transform.TransformerException
  {
    if(xsltObj instanceof XObject)
    {
      XObject xobj = ((XObject)xsltObj);
      int xsltClassType = xobj.getType();

      switch(xsltClassType)
      {
      case XObject.CLASS_NULL:
        return null;
        
      case XObject.CLASS_BOOLEAN:
        {
          if(javaClass == java.lang.String.class)
            return xobj.str();
          else
            return new Boolean(xobj.bool());
        }
        
      case XObject.CLASS_NUMBER:
        {
          if(javaClass == java.lang.String.class)
            return xobj.str();
          else if(javaClass == Boolean.TYPE)
            return new Boolean(xobj.bool());
          else 
          {
            return convertDoubleToNumber(xobj.num(), javaClass);
          }
        }
        
        
      case XObject.CLASS_STRING:
        {
          if((javaClass == java.lang.String.class) ||
             (javaClass == java.lang.Object.class))
            return xobj.str();
          else if(javaClass == Character.TYPE)
          {
            String str = xobj.str();
            if(str.length() > 0)
              return new Character(str.charAt(0));
            else
              return null; 
          }
          else if(javaClass == Boolean.TYPE)
            return new Boolean(xobj.bool());
          else 
          {
            return convertDoubleToNumber(xobj.num(), javaClass);
          }
        }
        
        
      case XObject.CLASS_RTREEFRAG:
        {
          
          
          
          
          
          
          if ( (javaClass == NodeIterator.class) ||
               (javaClass == java.lang.Object.class) )
          {
            DTMIterator dtmIter = ((XRTreeFrag) xobj).asNodeIterator();
            return new DTMNodeIterator(dtmIter);
          }
          else if (javaClass == NodeList.class)
          {
            return ((XRTreeFrag) xobj).convertToNodeset();
          }
          
          
          else if(javaClass == Node.class)
          {
            DTMIterator iter = ((XRTreeFrag) xobj).asNodeIterator();
            int rootHandle = iter.nextNode();
            DTM dtm = iter.getDTM(rootHandle);
            return dtm.getNode(dtm.getFirstChild(rootHandle));
          }
          else if(javaClass == java.lang.String.class)
          {
            return xobj.str();
          }
          else if(javaClass == Boolean.TYPE)
          {
            return new Boolean(xobj.bool());
          }
          else if(javaClass.isPrimitive())
          {
            return convertDoubleToNumber(xobj.num(), javaClass);
          }
          else
          {
            DTMIterator iter = ((XRTreeFrag) xobj).asNodeIterator();
            int rootHandle = iter.nextNode();
            DTM dtm = iter.getDTM(rootHandle);
            Node child = dtm.getNode(dtm.getFirstChild(rootHandle));

            if(javaClass.isAssignableFrom(child.getClass()))
              return child;
            else
              return null;
          }
        }
        
        
      case XObject.CLASS_NODESET:
        {
          
          
          
          
          
          
          if ( (javaClass == NodeIterator.class) ||
               (javaClass == java.lang.Object.class) )
          {
            return xobj.nodeset();
          }
          
          
          else if(javaClass == NodeList.class)
          {
            return xobj.nodelist();
          }
          
          
          else if(javaClass == Node.class)
          {
            
            
            DTMIterator ni = xobj.iter();
            int handle = ni.nextNode();
            if (handle != DTM.NULL)
              return ni.getDTM(handle).getNode(handle); 
            else
              return null;
          }
          else if(javaClass == java.lang.String.class)
          {
            return xobj.str();
          }
          else if(javaClass == Boolean.TYPE)
          {
            return new Boolean(xobj.bool());
          }
          else if(javaClass.isPrimitive())
          {
            return convertDoubleToNumber(xobj.num(), javaClass);
          }
          else
          {
            DTMIterator iter = xobj.iter();
            int childHandle = iter.nextNode();
            DTM dtm = iter.getDTM(childHandle);
            Node child = dtm.getNode(childHandle);
            if(javaClass.isAssignableFrom(child.getClass()))
              return child;
            else
              return null;
          }
        }
        
        
        
      } 
      xsltObj = xobj.object();
      
    } 
    
    
    if (null != xsltObj)
    {
      if(javaClass == java.lang.String.class)
      {
        return xsltObj.toString();
      }
      else if(javaClass.isPrimitive())
      {
        
        XString xstr = new XString(xsltObj.toString());
        double num = xstr.num();
        return convertDoubleToNumber(num, javaClass);
      }
      else if(javaClass == java.lang.Class.class)
      {
        return xsltObj.getClass();
      }
      else
      {
        
        return xsltObj;
      }
                }
    else
    {
      
      return xsltObj;
    }
  }
  
  
  static Object convertDoubleToNumber(double num, Class javaClass)
  {
    
    
    
    if((javaClass == Double.TYPE) ||
       (javaClass == java.lang.Double.class))
      return new Double(num);
    else if(javaClass == Float.TYPE)
      return new Float(num);
    else if(javaClass == Long.TYPE)
    {
      
      
      return new Long((long)num);
    }
    else if(javaClass == Integer.TYPE)
    {
      
      
      return new Integer((int)num);
    }
    else if(javaClass == Short.TYPE)
    {
      
      
      return new Short((short)num);
    }
    else if(javaClass == Character.TYPE)
    {
      
      
      return new Character((char)num);
    }
    else if(javaClass == Byte.TYPE)
    {
      
      
      return new Byte((byte)num);
    }
    else     
    {
      return new Double(num);
    }
  }


  
  private static String errString(String callType,    
                                  String searchType,  
                                  Class classObj,
                                  String funcName,
                                  int searchMethod,
                                  Object[] xsltArgs)
  {
    String resultString = ""For extension "" + callType
                                              + "", could not find "" + searchType + "" "";
    switch (searchMethod)
    {
      case STATIC_ONLY:
        return resultString + ""static "" + classObj.getName() + ""."" 
                            + funcName + ""([ExpressionContext,] "" + errArgs(xsltArgs, 0) + "")."";

      case INSTANCE_ONLY:
        return resultString + classObj.getName() + "".""
                            + funcName + ""([ExpressionContext,] "" + errArgs(xsltArgs, 0) + "")."";

      case STATIC_AND_INSTANCE:
        return resultString + classObj.getName() + ""."" + funcName + ""([ExpressionContext,] "" + errArgs(xsltArgs, 0) + "").
""
                            + ""Checked both static and instance methods."";

      case DYNAMIC:
        return resultString + ""static "" + classObj.getName() + ""."" + funcName
                            + ""([ExpressionContext, ]"" + errArgs(xsltArgs, 0) + "") nor
""
                            + classObj + ""."" + funcName + ""([ExpressionContext,] "" + errArgs(xsltArgs, 1) + "")."";

      default:
        if (callType.equals(""function""))      
        {
          return resultString + classObj.getName()
                                  + ""([ExpressionContext,] "" + errArgs(xsltArgs, 0) + "")."";
        }
        else                                  
        {
          return resultString + classObj.getName() + ""."" + funcName
                    + ""(org.apache.xalan.extensions.XSLProcessorContext, ""
                    + ""org.apache.xalan.templates.ElemExtensionCall)."";
        }
    }
    
  }


  private static String errArgs(Object[] xsltArgs, int startingArg)
  {
    StringBuffer returnArgs = new StringBuffer();
    for (int i = startingArg; i < xsltArgs.length; i++)
    {
      if (i != startingArg)
        returnArgs.append("", "");
      if (xsltArgs[i] instanceof XObject)
        returnArgs.append(((XObject) xsltArgs[i]).getTypeString());      
      else
        returnArgs.append(xsltArgs[i].getClass().getName());
    }
    return returnArgs.toString();
  }

}
"
org.apache.xalan.lib.sql.XConnection,34,1,0,12,127,211,0,12,28,0.656565657,1600,1.0,3,0.0,0.196078431,0,0,45.79411765,7,1.6176,1,"
package org.apache.xalan.lib.sql;

import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.Date;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.Enumeration;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.ref.DTMManagerDefault;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBooleanStatic;

import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public class XConnection
{

  
  private static final boolean DEBUG = false;

  
  private ConnectionPool m_ConnectionPool = null;

  
  private boolean m_DefaultPoolingEnabled = false;


  
  private Vector m_OpenSQLDocuments = new Vector();


  
  private ConnectionPoolManager m_PoolMgr = new ConnectionPoolManager();

  
  private Vector m_ParameterList = new Vector();

  
  private SQLErrorDocument m_Error = null;

  
  private boolean m_IsDefaultPool = false;

  
  private boolean m_IsStreamingEnabled = true;

  
  public XConnection( )
  {
  }

  
  
  
  
  
  public XConnection( ExpressionContext exprContext, String ConnPoolName )
  {
    connect(exprContext, ConnPoolName);
  }

  
  public XConnection( ExpressionContext exprContext, String driver, String dbURL )
  {
    connect(exprContext, driver, dbURL);
  }

  
  public XConnection( ExpressionContext exprContext, NodeList list )
  {
    connect(exprContext, list);
  }

  
  public XConnection( ExpressionContext exprContext, String driver, String dbURL, String user, String password )
  {
    connect(exprContext, driver, dbURL, user, password);
  }

  
  public XConnection( ExpressionContext exprContext, String driver, String dbURL, Element protocolElem )
  {
    connect(exprContext, driver, dbURL, protocolElem);
  }


  
  public XBooleanStatic connect( ExpressionContext exprContext, String ConnPoolName )
  {
    try
    {
      m_ConnectionPool = m_PoolMgr.getPool(ConnPoolName);

      if (m_ConnectionPool == null)
        throw new java.lang.IllegalArgumentException(""Invalid Pool Name"");

      m_IsDefaultPool = false;
      return new XBooleanStatic(true);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }

  }

  
  public XBooleanStatic connect( ExpressionContext exprContext, String driver, String dbURL )
  {
    try
    {
      init(driver, dbURL, new Properties());
      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }

  
  public XBooleanStatic connect( ExpressionContext exprContext, Element protocolElem )
  {
    try
    {
      initFromElement(protocolElem);
      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }

  
  public XBooleanStatic connect( ExpressionContext exprContext, NodeList list )
  {
    try
    {
      initFromElement( (Element) list.item(0) );
      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }

  
  public XBooleanStatic connect( ExpressionContext exprContext, String driver, String dbURL, String user, String password )
  {
    try
    {
      Properties prop = new Properties();
      prop.put(""user"", user);
      prop.put(""password"", password);

      init(driver, dbURL, prop);

      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }


  
  public XBooleanStatic connect( ExpressionContext exprContext, String driver, String dbURL, Element protocolElem )
  {
    try
    {
      Properties prop = new Properties();

      NamedNodeMap atts = protocolElem.getAttributes();

      for (int i = 0; i < atts.getLength(); i++)
      {
        prop.put(atts.item(i).getNodeName(), atts.item(i).getNodeValue());
      }

      init(driver, dbURL, prop);

      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }


  
  private void initFromElement( Element e )throws SQLException
  {

    Properties prop = new Properties();
    String driver = """";
    String dbURL = """";
    Node n = e.getFirstChild();

    if (null == n) return; 

    do
    {
      String nName = n.getNodeName();

      if (nName.equalsIgnoreCase(""dbdriver""))
      {
        driver = """";
        Node n1 = n.getFirstChild();
        if (null != n1)
        {
          driver = n1.getNodeValue();
        }
      }

      if (nName.equalsIgnoreCase(""dburl""))
      {
        dbURL = """";
        Node n1 = n.getFirstChild();
        if (null != n1)
        {
          dbURL = n1.getNodeValue();
        }
      }

      if (nName.equalsIgnoreCase(""password""))
      {
        String s = """";
        Node n1 = n.getFirstChild();
        if (null != n1)
        {
          s = n1.getNodeValue();
        }
        prop.put(""password"", s);
      }

      if (nName.equalsIgnoreCase(""user""))
      {
        String s = """";
        Node n1 = n.getFirstChild();
        if (null != n1)
        {
          s = n1.getNodeValue();
        }
        prop.put(""user"", s);
      }

      if (nName.equalsIgnoreCase(""protocol""))
      {
        String Name = """";

        NamedNodeMap attrs = n.getAttributes();
        Node n1 = attrs.getNamedItem(""name"");
        if (null != n1)
        {
          String s = """";
          Name = n1.getNodeValue();

          Node n2 = n.getFirstChild();
          if (null != n2) s = n2.getNodeValue();

          prop.put(Name, s);
        }
      }

    } while ( (n = n.getNextSibling()) != null);

    init(driver, dbURL, prop);
  }



  
  private void init( String driver, String dbURL, Properties prop )throws SQLException
  {
    Connection con = null;

    if (DEBUG)
      System.out.println(""XConnection, Connection Init"");

    String user = prop.getProperty(""user"");
    if (user == null) user = """";

    String passwd = prop.getProperty(""password"");
    if (passwd == null) passwd = """";


    String poolName = driver + dbURL + user + passwd;
    ConnectionPool cpool = m_PoolMgr.getPool(poolName);

    if (cpool == null)
    {

      if (DEBUG)
      {
        System.out.println(""XConnection, Creating Connection"");
        System.out.println("" Driver  :"" + driver);
        System.out.println("" URL     :"" + dbURL);
        System.out.println("" user    :"" + user);
        System.out.println("" passwd  :"" + passwd);
      }


      DefaultConnectionPool defpool = new DefaultConnectionPool();

      if ((DEBUG) && (defpool == null))
        System.out.println(""Failed to Create a Default Connection Pool"");

      defpool.setDriver(driver);
      defpool.setURL(dbURL);
      defpool.setProtocol(prop);

      
      
      if (m_DefaultPoolingEnabled) defpool.setPoolEnabled(true);

      m_PoolMgr.registerPool(poolName, defpool);
      m_ConnectionPool = defpool;
    }
    else
    {
      m_ConnectionPool = cpool;
    }

    m_IsDefaultPool = true;

    
    
    
    
    try
    {
      con = m_ConnectionPool.getConnection();
    }
    catch(SQLException e)
    {
      if (con != null)
      {
        m_ConnectionPool.releaseConnectionOnError(con);
        con = null;
      }
      throw e;
    }
    finally
    {
      m_ConnectionPool.releaseConnection(con);
    }
  }


  
  public DTM query( ExpressionContext exprContext, String queryString )
  {
    Connection con = null;
    Statement stmt = null;
    ResultSet rs = null;

    DTMManagerDefault mgrDefault = null;
    SQLDocument doc = null;

    try
    {
      if (DEBUG) System.out.println(""query()"");
      if (null == m_ConnectionPool)
      {
        
        return null;
      }

      try
      {
        con = m_ConnectionPool.getConnection();
        stmt = con.createStatement();
        rs = stmt.executeQuery(queryString);
      }
      catch(SQLException e)
      {
        
        
        
        
        try  { if (null != rs) rs.close(); }
        catch(Exception e1) {}
        try  { if (null != stmt) stmt.close(); }
        catch(Exception e1) { }
        try  {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        } catch(Exception e1) { }

        buildErrorDocument(exprContext, e);
        return null;
      }

      if (DEBUG) System.out.println(""..creatingSQLDocument"");

      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      doc =
        new SQLDocument(
          mgr, dtmIdent << DTMManager.IDENT_DTM_NODE_BITS ,
          m_ConnectionPool, con, stmt, rs, m_IsStreamingEnabled);

      if (null != doc)
      {
        if (DEBUG) System.out.println(""..returning Document"");

        
        mgrDefault.addDTM(doc, dtmIdent);

        
        m_OpenSQLDocuments.addElement(doc);
        return doc;
      }
      else
      {
        return null;
      }
    }
    catch(SQLException e)
    {
      if ((doc != null) && (mgrDefault != null))
      {
        doc.closeOnError();
        mgrDefault.release(doc, true);
      }
      buildErrorDocument(exprContext, e);
      return null;
    }
    catch (Exception e)
    {
      if ((doc != null) && (mgrDefault != null))
      {
        doc.closeOnError();
        mgrDefault.release(doc, true);
      }

      if (DEBUG) System.out.println(""exception in query()"");
      buildErrorDocument(exprContext, e);
      return null;
    }
    finally
    {
      if (DEBUG) System.out.println(""leaving query()"");
    }
  }

  
  public DTM pquery( ExpressionContext exprContext, String queryString )
  {
    Connection con = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;

    try
    {
      int indx;

      try
      {
        con = m_ConnectionPool.getConnection();
        stmt = con.prepareStatement(queryString);
      }
      catch(SQLException e)
      {
        
        
        
        
        try { if (null != stmt) stmt.close(); }
        catch(Exception e1) { }
        try {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        }  catch(Exception e1) {}

        
        
        throw e;
      }

      if (DEBUG) System.out.println(""..building Prepared Statement"");

      try
      {
        Enumeration enum = m_ParameterList.elements();
        indx = 1;
        while (enum.hasMoreElements())
        {
          QueryParameter qp = (QueryParameter) enum.nextElement();
          setParameter(indx, stmt, qp);
          indx++;
        }

        rs = stmt.executeQuery();
      }
      catch(SQLException e)
      {
        
        
        
        
        try { if (null != rs) rs.close();  }
        catch(Exception e1) {  }
        try { if (null != stmt) stmt.close(); }
        catch(Exception e1) {  }
        try  {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        } catch(Exception e1) { }

        
        
        throw e;
      }

      if (DEBUG) System.out.println(""..creatingSQLDocument"");

      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      DTMManagerDefault mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      SQLDocument doc =
        new SQLDocument(mgr, dtmIdent << DTMManager.IDENT_DTM_NODE_BITS,
        m_ConnectionPool, con, stmt, rs, m_IsStreamingEnabled);

      if (null != doc)
      {
        if (DEBUG) System.out.println(""..returning Document"");

        
        mgrDefault.addDTM(doc, dtmIdent);

        
        m_OpenSQLDocuments.addElement(doc);
        return doc;
      }
      else
      {
        
        return null;
      }
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return null;
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return null;
    }
  }


  
  public DTM pquery( ExpressionContext exprContext, String queryString, String typeInfo )
  {
    Connection con = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;

    try
    {
      int indx;

      
      
      StringTokenizer plist = new StringTokenizer(typeInfo);

      
      
      
      
      indx = 0;
      while (plist.hasMoreTokens())
      {
        String value = plist.nextToken();
        QueryParameter qp = (QueryParameter) m_ParameterList.elementAt(indx);
        if ( null != qp )
        {
          qp.setType(value);
        }

        indx++;
      }

      try
      {
        con = m_ConnectionPool.getConnection();
        stmt = con.prepareStatement(queryString);
      }
      catch(SQLException e)
      {
        
        
        
        
        try { if (null != stmt) stmt.close(); }
        catch(Exception e1) { }
        try {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        } catch(Exception e1) { }

        
        
        throw e;
      }



      if (DEBUG) System.out.println(""..building Prepared Statement"");

      try
      {
        Enumeration enum = m_ParameterList.elements();
        indx = 1;
        while (enum.hasMoreElements())
        {
          QueryParameter qp = (QueryParameter) enum.nextElement();
          setParameter(indx, stmt, qp);
          indx++;
        }

        rs = stmt.executeQuery();
      }
      catch(SQLException e)
      {
        
        
        
        
        try { if (null != rs) rs.close(); }
        catch(Exception e1) {  }
        try { if (null != stmt) stmt.close(); }
        catch(Exception e1) {   }
        try {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        } catch(Exception e1) {  }

        
        
        throw e;
      }


      if (DEBUG) System.out.println(""..creatingSQLDocument"");

      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      DTMManagerDefault mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      SQLDocument doc =
        new SQLDocument(mgr, dtmIdent << DTMManager.IDENT_DTM_NODE_BITS ,
        m_ConnectionPool, con, stmt, rs, m_IsStreamingEnabled);

      if (null != doc)
      {
        if (DEBUG) System.out.println(""..returning Document"");

        
        mgrDefault.addDTM(doc, dtmIdent);

        
        m_OpenSQLDocuments.addElement(doc);
        return doc;
      }
      else
      {
        
        return null;
      }
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return null;
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return null;
    }
  }

  
  public void addParameter( String value )
  {
    addParameterWithType(value, null);
  }

  
  public void addParameterWithType( String value, String Type )
  {
    m_ParameterList.addElement( new QueryParameter(value, Type) );
  }


  
  public void addParameterFromElement( Element e )
  {
    NamedNodeMap attrs = e.getAttributes();
    Node Type = attrs.getNamedItem(""type"");
    Node n1  = e.getFirstChild();
    if (null != n1)
    {
      String value = n1.getNodeValue();
      if (value == null) value = """";
      m_ParameterList.addElement( new QueryParameter(value, Type.getNodeValue()) );
    }
  }


  
  public void addParameterFromElement( NodeList nl )
  {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    int count = nl.getLength();
    for (int x=0; x<count; x++)
    {
      addParameters( (Element) nl.item(x));
    }
  }

  
  private void addParameters( Element elem )
  {
    
    
    
    
    
    
    
    
    
    

    Node n = elem.getFirstChild();

    if (null == n) return;

    do
    {
      if (n.getNodeType() == Node.ELEMENT_NODE)
      {
        NamedNodeMap attrs = n.getAttributes();
        Node Type = attrs.getNamedItem(""type"");
        String TypeStr;

        if (Type == null) TypeStr = ""string"";
        else TypeStr = Type.getNodeValue();

        Node n1  = n.getFirstChild();
        if (null != n1)
        {
          String value = n1.getNodeValue();
          if (value == null) value = """";


          m_ParameterList.addElement(
            new QueryParameter(value, TypeStr) );
        }
      }
    } while ( (n = n.getNextSibling()) != null);
  }

  
  public void clearParameters( )
  {
    m_ParameterList.removeAllElements();
  }

  
  public void enableDefaultConnectionPool( )
  {

    if (DEBUG)
      System.out.println(""Enabling Default Connection Pool"");

    m_DefaultPoolingEnabled = true;

    if (m_ConnectionPool == null) return;
    if (m_IsDefaultPool) return;

    m_ConnectionPool.setPoolEnabled(true);

  }

  
  public void disableDefaultConnectionPool( )
  {
    if (DEBUG)
      System.out.println(""Disabling Default Connection Pool"");

    m_DefaultPoolingEnabled = false;

    if (m_ConnectionPool == null) return;
    if (!m_IsDefaultPool) return;

    m_ConnectionPool.setPoolEnabled(false);
  }


  
  public void enableStreamingMode( )
  {

    if (DEBUG)
      System.out.println(""Enabling Streaming Mode"");

    m_IsStreamingEnabled = true;
  }

  
  public void disableStreamingMode( )
  {

    if (DEBUG)
      System.out.println(""Disable Streaming Mode"");

    m_IsStreamingEnabled = false;
  }

  
  public DTM getError( )
  {
    return m_Error;
  }

  
  public void close( )throws SQLException
  {

    if (DEBUG)
      System.out.println(""Entering XConnection.close"");

    
    
    
    
    while(m_OpenSQLDocuments.size() != 0)
    {
      SQLDocument d = (SQLDocument) m_OpenSQLDocuments.elementAt(0);
      d.close();
      m_OpenSQLDocuments.removeElementAt(0);
    }

    if (DEBUG)
      System.out.println(""Exiting XConnection.close"");

  }

  
  public void close( SQLDocument sqldoc )throws SQLException
  {
    if (DEBUG)
      System.out.println(""Entering XConnection.close"");

    int size = m_OpenSQLDocuments.size();

    for(int x=0; x<size; x++)
    {
      SQLDocument d = (SQLDocument) m_OpenSQLDocuments.elementAt(x);
      if (d == sqldoc)
      {
        d.close();
        m_OpenSQLDocuments.removeElementAt(x);
      }
    }
  }

  
  public void setParameter( int pos, PreparedStatement stmt, QueryParameter p )throws SQLException
  {
    String type = p.getType();
    if (type.equalsIgnoreCase(""string""))
    {
      stmt.setString(pos, p.getValue());
    }

    if (type.equalsIgnoreCase(""bigdecimal""))
    {
      stmt.setBigDecimal(pos, new BigDecimal(p.getValue()));
    }

    if (type.equalsIgnoreCase(""boolean""))
    {
      Integer i = new Integer( p.getValue() );
      boolean b = ((i.intValue() != 0) ? false : true);
      stmt.setBoolean(pos, b);
    }

    if (type.equalsIgnoreCase(""bytes""))
    {
      stmt.setBytes(pos, p.getValue().getBytes());
    }

    if (type.equalsIgnoreCase(""date""))
    {
      stmt.setDate(pos, Date.valueOf(p.getValue()));
    }

    if (type.equalsIgnoreCase(""double""))
    {
      Double d = new Double(p.getValue());
      stmt.setDouble(pos, d.doubleValue() );
    }

    if (type.equalsIgnoreCase(""float""))
    {
      Float f = new Float(p.getValue());
      stmt.setFloat(pos, f.floatValue());
    }

    if (type.equalsIgnoreCase(""long""))
    {
      Long l = new Long(p.getValue());
      stmt.setLong(pos, l.longValue());
    }

    if (type.equalsIgnoreCase(""short""))
    {
      Short s = new Short(p.getValue());
      stmt.setShort(pos, s.shortValue());
    }

    if (type.equalsIgnoreCase(""time""))
    {
      stmt.setTime(pos, Time.valueOf(p.getValue()) );
    }

    if (type.equalsIgnoreCase(""timestamp""))
    {

      stmt.setTimestamp(pos, Timestamp.valueOf(p.getValue()) );
    }

  }

  
  private void buildErrorDocument( ExpressionContext exprContext, SQLException excp )
  {
    try
    {
      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      DTMManagerDefault mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      m_Error = new SQLErrorDocument(mgr, dtmIdent << DTMManager.IDENT_DTM_NODE_BITS, excp);

      
      mgrDefault.addDTM(m_Error, dtmIdent);

    }
    catch(Exception e)
    {
      m_Error = null;
    }
  }

  
  private void buildErrorDocument( ExpressionContext exprContext, Exception excp )
  {
    try
    {
      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      DTMManagerDefault mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      m_Error = new SQLErrorDocument(mgr, dtmIdent<<DTMManager.IDENT_DTM_NODE_BITS, excp);

      
      mgrDefault.addDTM(m_Error, dtmIdent);

    }
    catch(Exception e)
    {
      m_Error = null;
    }
  }

  
  protected void finalize( )
  {
    if (DEBUG) System.out.println(""In XConnection, finalize"");
    try
    {
      close();
    }
    catch(Exception e)
    {
      
    }
  }

}
"
org.apache.xalan.xsltc.runtime.Node,1,1,0,1,2,0,1,0,1,2.0,12,0.0,0,0.0,1.0,0,0,9.0,0,0.0,0,"

package org.apache.xalan.xsltc.runtime;


public class Node {
    public int node;
    public int type;
	
    public Node(int n, int t) {
	node = n;
	type = t;
    }
}
"
org.apache.xml.utils.ObjectVector,21,1,1,5,23,0,5,0,21,0.3375,516,1.0,0,0.0,0.5,0,0,23.38095238,4,1.7143,1,"
package org.apache.xml.utils;


public class ObjectVector implements Cloneable
{

  
  protected int m_blocksize;

  
  protected Object m_map[]; 

  
  protected int m_firstFree = 0;

  
  protected int m_mapSize;

  
  public ObjectVector()
  {

    m_blocksize = 32;
    m_mapSize = m_blocksize;
    m_map = new Object[m_blocksize];
  }

  
  public ObjectVector(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new Object[blocksize];
  }
  
  
  public ObjectVector(int blocksize, int increaseSize)
  {

    m_blocksize = increaseSize;
    m_mapSize = blocksize;
    m_map = new Object[blocksize];
  }

  
  public ObjectVector(ObjectVector v)
  {
  	m_map = new Object[v.m_mapSize];
    m_mapSize = v.m_mapSize;
    m_firstFree = v.m_firstFree;
  	m_blocksize = v.m_blocksize;
  	System.arraycopy(v.m_map, 0, m_map, 0, m_firstFree);
  }

  
  public final int size()
  {
    return m_firstFree;
  }
  
  
  public final void setSize(int sz)
  {
    m_firstFree = sz;
  }


  
  public final void addElement(Object value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      Object newMap[] = new Object[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }
  
  
  public final void addElements(Object value, int numberOfElements)
  {

    if ((m_firstFree + numberOfElements) >= m_mapSize)
    {
      m_mapSize += (m_blocksize+numberOfElements);

      Object newMap[] = new Object[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    for (int i = 0; i < numberOfElements; i++) 
    {
      m_map[m_firstFree] = value;
      m_firstFree++;
    }
  }
  
  
  public final void addElements(int numberOfElements)
  {

    if ((m_firstFree + numberOfElements) >= m_mapSize)
    {
      m_mapSize += (m_blocksize+numberOfElements);

      Object newMap[] = new Object[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }
    
    m_firstFree += numberOfElements;
  }
  

  
  public final void insertElementAt(Object value, int at)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      Object newMap[] = new Object[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    if (at <= (m_firstFree - 1))
    {
      System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);
    }

    m_map[at] = value;

    m_firstFree++;
  }

  
  public final void removeAllElements()
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      m_map[i] = null;
    }

    m_firstFree = 0;
  }

  
  public final boolean removeElement(Object s)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i] == s)
      {
        if ((i + 1) < m_firstFree)
          System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
        else
          m_map[i] = null;

        m_firstFree--;

        return true;
      }
    }

    return false;
  }

  
  public final void removeElementAt(int i)
  {

    if (i > m_firstFree)
      System.arraycopy(m_map, i + 1, m_map, i, m_firstFree);
    else
      m_map[i] = null;

    m_firstFree--;
  }

  
  public final void setElementAt(Object value, int index)
  {
    m_map[index] = value;
  }

  
  public final Object elementAt(int i)
  {
    return m_map[i];
  }

  
  public final boolean contains(Object s)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i] == s)
        return true;
    }

    return false;
  }

  
  public final int indexOf(Object elem, int index)
  {

    for (int i = index; i < m_firstFree; i++)
    {
      if (m_map[i] == elem)
        return i;
    }

    return java.lang.Integer.MIN_VALUE;
  }

  
  public final int indexOf(Object elem)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i] == elem)
        return i;
    }

    return java.lang.Integer.MIN_VALUE;
  }

  
  public final int lastIndexOf(Object elem)
  {

    for (int i = (m_firstFree - 1); i >= 0; i--)
    {
      if (m_map[i] == elem)
        return i;
    }

    return java.lang.Integer.MIN_VALUE;
  }
  
  
  public final void setToSize(int size) {
    
    Object newMap[] = new Object[size];
    
    System.arraycopy(m_map, 0, newMap, 0, m_firstFree);
    m_mapSize = size;

    m_map = newMap;
    
  }  
  
  
  public Object clone()
    throws CloneNotSupportedException
  {
  	return new ObjectVector(this);
  }
}
"
org.apache.xpath.functions.FuncSubstring,4,6,0,8,16,6,0,8,3,2.0,113,0.0,0,0.955223881,0.5,2,8,27.25,1,0.75,1,"
package org.apache.xpath.functions;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.res.XPATHErrorResources;


public class FuncSubstring extends Function3Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XMLString s1 = m_arg0.execute(xctxt).xstr();
    double start = m_arg1.execute(xctxt).num();
    int lenOfS1 = s1.length();
    XMLString substr;

    if (lenOfS1 <= 0)
      return XString.EMPTYSTRING;
    else
    {
      int startIndex;

      if (Double.isNaN(start))
      {

        
        
        start = -1000000;
        startIndex = 0;
      }
      else
      {
        start = Math.round(start);
        startIndex = (start > 0) ? (int) start - 1 : 0;
      }

      if (null != m_arg2)
      {
        double len = m_arg2.num(xctxt);
        int end = (int) (Math.round(len) + start) - 1;

        
        if (end < 0)
          end = 0;
        else if (end > lenOfS1)
          end = lenOfS1;

        if (startIndex > lenOfS1)
          startIndex = lenOfS1;

        substr = s1.substring(startIndex, end);
      }
      else
      {
        if (startIndex > lenOfS1)
          startIndex = lenOfS1;
        substr = s1.substring(startIndex);
      }
    }

    return (XString)substr; 
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum < 2)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_TWO_OR_THREE, null)); 
  }
}
"
org.apache.xalan.xsltc.compiler.AttributeValueTemplate,7,4,0,22,49,21,4,19,5,2.0,452,0.0,0,0.923076923,0.339285714,2,7,63.57142857,14,5.1429,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;
import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class AttributeValueTemplate extends AttributeValue {

    public AttributeValueTemplate(String value, Parser parser, 
	SyntaxTreeNode parent) 
    {
	setParent(parent);
	setParser(parser);
	if (check(value, parser)) {
	    parseAVTemplate(0, value, parser);
	}
    }

    private void parseAVTemplate(final int start, String text, Parser parser) {
	String str;

	if (text == null) return;

	
	int open = start - 2;
	do {
	    open = text.indexOf('{', open+2);
	} while ((open != -1) && 
		 (open < (text.length()-1)) && 
		 (text.charAt(open+1) == '{'));

	if (open != -1) {
	    
	    int close = open - 2;
	    do {
		close = text.indexOf('}', close+2);
	    } while ((close != -1) && 
		     (close < (text.length()-1)) && 
		     (text.charAt(close+1) == '}'));
	    
	    
	    if (open > start) {
		str = removeDuplicateBraces(text.substring(start, open));
		addElement(new LiteralExpr(str));
	    }
	    
	    if (close > open + 1) {
		str = text.substring(open + 1, close);
		str = removeDuplicateBraces(text.substring(open+1,close));
		addElement(parser.parseExpression(this, str));
	    }
	    
	    parseAVTemplate(close + 1, text, parser);
	    
	}
	else if (start < text.length()) {
	    
	    str = removeDuplicateBraces(text.substring(start));
	    addElement(new LiteralExpr(str));
	}
    }

    public String removeDuplicateBraces(String orig) {
	String result = orig;
	int index;

	while ((index = result.indexOf(""{{"")) != -1) {
	    result = result.substring(0,index) + 
		result.substring(index+1,result.length());
	}

	while ((index = result.indexOf(""}}"")) != -1) {
	    result = result.substring(0,index) + 
		result.substring(index+1,result.length());
	}

	return(result);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Vector contents = getContents();
	final int n = contents.size();
	for (int i = 0; i < n; i++) {
	    final Expression exp = (Expression)contents.elementAt(i);
	    if (!exp.typeCheck(stable).identicalTo(Type.String)) {
		contents.setElementAt(new CastExpr(exp, Type.String), i);
	    }
	}
	return _type = Type.String;
    }

    public String toString() {
	final StringBuffer buffer = new StringBuffer(""AVT:["");
	final int count = elementCount();
	for (int i = 0; i < count; i++) {
	    buffer.append(elementAt(i).toString());
	    if (i < count - 1)
		buffer.append(' ');
	}
	return buffer.append(']').toString();
    }
		
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (elementCount() == 1) {
	    final Expression exp = (Expression)elementAt(0);
	    exp.translate(classGen, methodGen);
	}
	else {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();
	    final int initBuffer = cpg.addMethodref(STRING_BUFFER_CLASS,
						    ""<init>"", ""()V"");
	    final Instruction append =
		new INVOKEVIRTUAL(cpg.addMethodref(STRING_BUFFER_CLASS,
						   ""append"",
						   ""("" + STRING_SIG + "")""
						   + STRING_BUFFER_SIG));
	    
	    final int toString = cpg.addMethodref(STRING_BUFFER_CLASS,
						  ""toString"",
						  ""()""+STRING_SIG);
	    il.append(new NEW(cpg.addClass(STRING_BUFFER_CLASS)));
	    il.append(DUP);
	    il.append(new INVOKESPECIAL(initBuffer));
	    
	    final Enumeration enum = elements();
	    while (enum.hasMoreElements()) {
		final Expression exp = (Expression)enum.nextElement();
		exp.translate(classGen, methodGen);
		il.append(append);
	    }
	    il.append(new INVOKEVIRTUAL(toString));
	}
    }

    private boolean check(String value, Parser parser) {
	
	if (value == null) return true;

	final char[] chars = value.toCharArray();
	int level = 0;
	for (int i = 0; i < chars.length; i++) {
	    switch (chars[i]) {
	    case '{':
		if (((i+1) == (chars.length)) || (chars[i+1] != '{'))
		    ++level;
		else
		    i++;
		break;
	    case '}':	
		if (((i+1) == (chars.length)) || (chars[i+1] != '}'))
		    --level;
		else
		    i++;
		break;
	    default:
		continue;
	    }
	    switch (level) {
	    case 0:
	    case 1:
		continue;
	    default:
		reportError(getParent(), parser,
			    ErrorMsg.ATTR_VAL_TEMPLATE_ERR, value);
		return false;
	    }
	}
	if (level != 0) {
	    reportError(getParent(), parser,
			ErrorMsg.ATTR_VAL_TEMPLATE_ERR, value);
	    return false;
	}
	return true;
    }
}
"
org.apache.xalan.xsltc.compiler.util.NodeSortRecordFactGenerator,2,4,0,3,3,1,1,2,2,2.0,13,0.0,0,0.987804878,0.6,0,0,5.5,1,0.5,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.Stylesheet;


public final class NodeSortRecordFactGenerator extends ClassGenerator {

    public NodeSortRecordFactGenerator(String className, String superClassName,
				   String fileName,
				   int accessFlags, String[] interfaces,
				   Stylesheet stylesheet) {
	super(className, superClassName, fileName,
	      accessFlags, interfaces, stylesheet);
    }
    
    
    public boolean isExternal() {
	return true;
    }
}
"
org.apache.xml.dtm.ref.DTMNodeList,5,2,0,8,15,0,5,3,4,0.25,72,1.0,1,0.4,0.466666667,0,0,13.2,3,1.2,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.w3c.dom.Node;


public class DTMNodeList extends DTMNodeListBase {
    private DTMIterator m_iter;

    
    
    private DTMNodeList() {
    }

    
    public DTMNodeList(DTMIterator dtmIterator) {
        if (dtmIterator != null) {
            int pos = dtmIterator.getCurrentPos();
            try {
                m_iter=(DTMIterator)dtmIterator.cloneWithReset();
            } catch(CloneNotSupportedException cnse) {
                m_iter = dtmIterator;
            }
            m_iter.setShouldCacheNodes(true);
            m_iter.runTo(-1);
            m_iter.setCurrentPos(pos);
        }
    }

    
    public DTMIterator getDTMIterator() {
        return m_iter;
    }

    
    

    
    public Node item(int index)
    {
        if (m_iter != null) {
            int handle=m_iter.item(index);
            if (handle == DTM.NULL) {
                return null;
            }
            return m_iter.getDTM(handle).getNode(handle);
        } else {
            return null;
        }
    }

    
    public int getLength() {
        return (m_iter != null) ? m_iter.getLength() : 0;
    }
}
"
org.apache.xml.utils.NamespaceSupport2,11,2,0,3,26,0,2,2,11,0.55,127,0.5,1,0.583333333,0.409090909,1,3,10.36363636,3,1.3636,0,"
package org.apache.xml.utils;

import java.util.EmptyStackException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;


public class NamespaceSupport2
    extends org.xml.sax.helpers.NamespaceSupport
{
    
    
    

    private Context2 currentContext; 


    
    
    


    
    public final static String XMLNS =
        ""http:


    
    
    


    
    public NamespaceSupport2 ()
    {
        reset();
    }


    
    
    


    
    public void reset ()
    {
        
        
        
        currentContext = new Context2(null);
        currentContext.declarePrefix(""xml"", XMLNS);
    }


    
    public void pushContext ()
    {
        
        
        
        

        Context2 parentContext=currentContext;
        currentContext = parentContext.getChild();
        if (currentContext == null){
                currentContext = new Context2(parentContext);
            }
        else{
            
            
            currentContext.setParent(parentContext);
        }
    }


    
    public void popContext ()
    {
        Context2 parentContext=currentContext.getParent();
        if(parentContext==null)
            throw new EmptyStackException();
        else
            currentContext = parentContext;
    }



    
    
    


    
    public boolean declarePrefix (String prefix, String uri)
    {
        if (prefix.equals(""xml"") || prefix.equals(""xmlns"")) {
            return false;
        } else {
            currentContext.declarePrefix(prefix, uri);
            return true;
        }
    }


    
    public String [] processName (String qName, String[] parts,
                                  boolean isAttribute)
    {
        String[] name=currentContext.processName(qName, isAttribute);
        if(name==null)
            return null;

        
        
        System.arraycopy(name,0,parts,0,3);
        return parts;
    }


    
    public String getURI (String prefix)
    {
        return currentContext.getURI(prefix);
    }


    
    public Enumeration getPrefixes ()
    {
        return currentContext.getPrefixes();
    }


    
    public String getPrefix (String uri)
    {
        return currentContext.getPrefix(uri);
    }


    
    public Enumeration getPrefixes (String uri)
    {
        
        
        
        
        
        
        
        
        
        
        return new PrefixForUriEnumerator(this,uri,getPrefixes());       
    }
    

    
    public Enumeration getDeclaredPrefixes ()
    {
        return currentContext.getDeclaredPrefixes();
    }



}








class PrefixForUriEnumerator implements Enumeration
{
    private Enumeration allPrefixes;
    private String uri;
    private String lookahead=null;
    private NamespaceSupport2 nsup;
     
    
    
    PrefixForUriEnumerator(NamespaceSupport2 nsup,String uri, Enumeration allPrefixes)
    {
	this.nsup=nsup;
        this.uri=uri;
        this.allPrefixes=allPrefixes;
    }
        
    public boolean hasMoreElements()
    {
        if(lookahead!=null)
            return true;
            
        while(allPrefixes.hasMoreElements())
            {
                String prefix=(String)allPrefixes.nextElement();
                if(uri.equals(nsup.getURI(prefix)))
                    {
                        lookahead=prefix;
                        return true;
                    }
            }
        return false;
    }
        
    public Object nextElement()
    {
        if(hasMoreElements())
            {
                String tmp=lookahead;
                lookahead=null;
                return tmp;
            }
        else
            throw new java.util.NoSuchElementException();
    }
}


final class Context2 {

    
    
    
        
    
    private final static Enumeration EMPTY_ENUMERATION =
        new Vector().elements();

    
    
    
        
    Hashtable prefixTable;
    Hashtable uriTable;
    Hashtable elementNameTable;
    Hashtable attributeNameTable;
    String defaultNS = null;

    
    
    
        
    private Vector declarations = null;
    private boolean tablesDirty = false;
    private Context2 parent = null;
    private Context2 child = null;

    
    Context2 (Context2 parent)
    {
        if(parent==null)
            {
                prefixTable = new Hashtable();
                uriTable = new Hashtable();
                elementNameTable=null; 
                attributeNameTable=null; 
            }
        else
            setParent(parent);
    }

        
    
    Context2 getChild()
    {
        return child;
    }
        
    
    Context2 getParent()
    {
        return parent;
    }
        
    
    void setParent (Context2 parent)
    {
        this.parent = parent;
        parent.child = this;        
        declarations = null;
        prefixTable = parent.prefixTable;
        uriTable = parent.uriTable;
        elementNameTable = parent.elementNameTable;
        attributeNameTable = parent.attributeNameTable;
        defaultNS = parent.defaultNS;
        tablesDirty = false;
    }
        
        
    
    void declarePrefix (String prefix, String uri)
    {
                                
        if (!tablesDirty) {
            copyTables();
        }
        if (declarations == null) {
            declarations = new Vector();
        }
            
        prefix = prefix.intern();
        uri = uri.intern();
        if ("""".equals(prefix)) {
            if ("""".equals(uri)) {
                defaultNS = null;
            } else {
                defaultNS = uri;
            }
        } else {
            prefixTable.put(prefix, uri);
            uriTable.put(uri, prefix); 
        }
        declarations.addElement(prefix);
    }


    
    String [] processName (String qName, boolean isAttribute)
    {
        String name[];
        Hashtable table;
            
                                
        if (isAttribute) {
            if(elementNameTable==null)
                elementNameTable=new Hashtable();
            table = elementNameTable;
        } else {
            if(attributeNameTable==null)
                attributeNameTable=new Hashtable();
            table = attributeNameTable;
        }
            
                                
                                
                                
        name = (String[])table.get(qName);
        if (name != null) {
            return name;
        }
            
                                
                                
        name = new String[3];
        int index = qName.indexOf(':');
            
            
                                
        if (index == -1) {
            if (isAttribute || defaultNS == null) {
                name[0] = """";
            } else {
                name[0] = defaultNS;
            }
            name[1] = qName.intern();
            name[2] = name[1];
        }
            
                                
        else {
            String prefix = qName.substring(0, index);
            String local = qName.substring(index+1);
            String uri;
            if ("""".equals(prefix)) {
                uri = defaultNS;
            } else {
                uri = (String)prefixTable.get(prefix);
            }
            if (uri == null) {
                return null;
            }
            name[0] = uri;
            name[1] = local.intern();
            name[2] = qName.intern();
        }
            
                                
        table.put(name[2], name);
        tablesDirty = true;
        return name;
    }
        

    
    String getURI (String prefix)
    {
        if ("""".equals(prefix)) {
            return defaultNS;
        } else if (prefixTable == null) {
            return null;
        } else {
            return (String)prefixTable.get(prefix);
        }
    }


    
    String getPrefix (String uri)
    {
        if (uriTable == null) {
            return null;
        } else {
            return (String)uriTable.get(uri);
        }
    }
        
        
    
    Enumeration getDeclaredPrefixes ()
    {
        if (declarations == null) {
            return EMPTY_ENUMERATION;
        } else {
            return declarations.elements();
        }
    }
        
        
    
    Enumeration getPrefixes ()
    {
        if (prefixTable == null) {
            return EMPTY_ENUMERATION;
        } else {
            return prefixTable.keys();
        }
    }
        
    
    
    

         
    private void copyTables ()
    {
        
        prefixTable = (Hashtable)prefixTable.clone();
        uriTable = (Hashtable)uriTable.clone();

        
        
        
        
        
        if(elementNameTable!=null)
            elementNameTable=new Hashtable(); 
        if(attributeNameTable!=null)
            attributeNameTable=new Hashtable(); 
        tablesDirty = true;
    }

}



"
org.apache.xml.serializer.XSLOutputAttributes,19,1,0,1,19,171,1,0,19,2.0,19,0.0,0,0.0,0.381578947,0,0,0.0,1,1.0,0,"
package org.apache.xml.serializer;

import java.util.Vector;


public interface XSLOutputAttributes
{
    
    public String getDoctypePublic();
     
    public String getDoctypeSystem();
        
    public String getEncoding();
        
    public boolean getIndent();
    
    
    public int getIndentAmount();
        
    public String getMediaType();
        
    public boolean getOmitXMLDeclaration();
        
    public String getStandalone();
        
    public String getVersion();






    
    public void setCdataSectionElements(Vector URI_and_localNames);

    
    public void setDoctype(String system, String pub);

    
    public void setDoctypePublic(String doctype);
    
    public void setDoctypeSystem(String doctype);
    
    public void setEncoding(String encoding);
    
    public void setIndent(boolean indent);
    
    public void setMediaType(String mediatype);
    
    public void setOmitXMLDeclaration(boolean b);
    
    public void setStandalone(String standalone);
    
    public void setVersion(String version);

}
"
org.apache.xalan.processor.ProcessorOutputElem,14,4,0,9,40,0,1,8,13,0.076923077,174,1.0,1,0.941704036,0.295918367,2,3,11.35714286,1,0.9286,0,"
package org.apache.xalan.processor;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.OutputProperties;
import org.apache.xml.serializer.OutputPropertiesFactory;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.SystemIDResolver;
import org.xml.sax.Attributes;


class ProcessorOutputElem extends XSLTElementProcessor
{

  
  private OutputProperties m_outputProperties;

  
  public void setCdataSectionElements(java.util.Vector newValue)
  {
    m_outputProperties.setQNameProperties(OutputKeys.CDATA_SECTION_ELEMENTS, newValue);
  }

  
  public void setDoctypePublic(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, newValue);
  }

  
  public void setDoctypeSystem(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, newValue);
  }

  
  public void setEncoding(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.ENCODING, newValue);
  }

  
  public void setIndent(boolean newValue)
  {
    m_outputProperties.setBooleanProperty(OutputKeys.INDENT, newValue);
  }

  
  public void setMediaType(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.MEDIA_TYPE, newValue);
  }

  
  public void setMethod(org.apache.xml.utils.QName newValue)
  {
    m_outputProperties.setQNameProperty(OutputKeys.METHOD, newValue);
  }

  
  public void setOmitXmlDeclaration(boolean newValue)
  {
    m_outputProperties.setBooleanProperty(OutputKeys.OMIT_XML_DECLARATION, newValue);
  }

  
  public void setStandalone(boolean newValue)
  {
    m_outputProperties.setBooleanProperty(OutputKeys.STANDALONE, newValue);
  }

  
  public void setVersion(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.VERSION, newValue);
  }
  
  
  public void setForeignAttr(String attrUri, String attrLocalName, String attrRawName, String attrValue)
  {
    QName key = new QName(attrUri, attrLocalName);
    m_outputProperties.setProperty(key, attrValue);
  }
  
  
  public void addLiteralResultAttribute(String attrUri, String attrLocalName, String attrRawName, String attrValue)
  {
    QName key = new QName(attrUri, attrLocalName);
    m_outputProperties.setProperty(key, attrValue);
  }

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {
    
    m_outputProperties = new OutputProperties();

    m_outputProperties.setDOMBackPointer(handler.getOriginatingNode());
    m_outputProperties.setLocaterInfo(handler.getLocator());
    m_outputProperties.setUid(handler.nextUid());
    setPropertiesFromAttributes(handler, rawName, attributes, this);
    
    
    
    String entitiesFileName =
      (String) m_outputProperties.getProperties().get(OutputPropertiesFactory.S_KEY_ENTITIES);

    if (null != entitiesFileName)
    {
      try
      {
        String absURL = SystemIDResolver.getAbsoluteURI(entitiesFileName,
                    handler.getBaseIdentifier());
        m_outputProperties.getProperties().put(OutputPropertiesFactory.S_KEY_ENTITIES, absURL);
      }
      catch(TransformerException te)
      {
        handler.error(te.getMessage(), te);
      }
    }
    
    handler.getStylesheet().setOutput(m_outputProperties);
    
    ElemTemplateElement parent = handler.getElemTemplateElement();
    parent.appendChild(m_outputProperties);
    
    m_outputProperties = null;
  }
}
"
org.apache.xalan.xsltc.compiler.UnionPathExpr,6,3,0,21,36,0,2,20,5,0.5,289,1.0,3,0.934210526,0.285714286,2,8,46.5,7,2.5,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xml.dtm.DTM;

final class UnionPathExpr extends Expression {

    private final Expression _pathExpr;
    private final Expression _rest;
    private boolean _reverse = false;

    
    private Expression[] _components;
    
    public UnionPathExpr(Expression pathExpr, Expression rest) {
	_pathExpr = pathExpr;
	_rest     = rest;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	
	final Vector components = new Vector();
	flatten(components);
	final int size = components.size();
	_components = (Expression[])components.toArray(new Expression[size]);
	for (int i = 0; i < size; i++) {
	    _components[i].setParser(parser);
	    _components[i].setParent(this);
	    if (_components[i] instanceof Step) {
		final Step step = (Step)_components[i];
		final int axis = step.getAxis();
		final int type = step.getNodeType();
		
		if ((axis == Axis.ATTRIBUTE) || (type == DTM.ATTRIBUTE_NODE)) {
		    _components[i] = _components[0];
		    _components[0] = step;
		}
		
		if (Axis.isReverse[axis]) _reverse = true;
	    }
	}
	
	if (getParent() instanceof Expression) _reverse = false;
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final int length = _components.length;
	for (int i = 0; i < length; i++) {
	    if (_components[i].typeCheck(stable) != Type.NodeSet) {
		_components[i] = new CastExpr(_components[i], Type.NodeSet);
	    }
	}
	return _type = Type.NodeSet;	
    }

    public String toString() {
	return ""union("" + _pathExpr + "", "" + _rest + ')';
    }
	
    private void flatten(Vector components) {
	components.addElement(_pathExpr);
	if (_rest != null) {
	    if (_rest instanceof UnionPathExpr) {
		((UnionPathExpr)_rest).flatten(components);
	    }
	    else {
		components.addElement(_rest);
	    }
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final int init = cpg.addMethodref(UNION_ITERATOR_CLASS,
					  ""<init>"",
					  ""(""+DOM_INTF_SIG+"")V"");
	final int iter = cpg.addMethodref(UNION_ITERATOR_CLASS,
					  ADD_ITERATOR,
					  ADD_ITERATOR_SIG);

	
	il.append(new NEW(cpg.addClass(UNION_ITERATOR_CLASS)));
	il.append(DUP);
	il.append(methodGen.loadDOM());
	il.append(new INVOKESPECIAL(init));

	
	final int length = _components.length;
	for (int i = 0; i < length; i++) {
	    _components[i].translate(classGen, methodGen);
	    il.append(new INVOKEVIRTUAL(iter));
	}

	
	if (_reverse) {
	    final int order = cpg.addInterfaceMethodref(DOM_INTF,
							ORDER_ITERATOR,
							ORDER_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(order, 3));

	}
    }
}
"
org.apache.xalan.xsltc.compiler.Attribute,3,3,0,4,14,1,0,4,2,0.5,37,1.0,1,0.965517241,0.555555556,1,4,11.0,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Util;

final class Attribute extends Instruction {
    private QName _name;
	
    public void display(int indent) {
	indent(indent);
	Util.println(""Attribute "" + _name);
	displayContents(indent + IndentIncrement);
    }

    public void parseContents(Parser parser) {
	_name = parser.getQName(getAttribute(""name""));
	parseChildren(parser);
	
	
    }
}
"
org.apache.xml.utils.XMLString,37,1,0,47,37,666,47,0,37,2.0,37,0.0,0,0.0,0.191891892,1,1,0.0,1,1.0,0,"
package org.apache.xml.utils;

import java.util.Locale;


public interface XMLString
{

  
  public abstract void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
    throws org.xml.sax.SAXException;

  
  public abstract void dispatchAsComment(org.xml.sax.ext.LexicalHandler lh)
    throws org.xml.sax.SAXException;
    
  
  public XMLString fixWhiteSpace(boolean trimHead,
                                 boolean trimTail,
                                 boolean doublePunctuationSpaces);

  
  public abstract int length();

  
  public abstract char charAt(int index);

  
  public abstract void getChars(int srcBegin, int srcEnd, char dst[],
                                int dstBegin);
                                
  
  public abstract boolean equals(XMLString anObject);


  
  public abstract boolean equals(Object anObject);

  
  public abstract boolean equalsIgnoreCase(String anotherString);

  
  public abstract int compareTo(XMLString anotherString);

  
  public abstract int compareToIgnoreCase(XMLString str);

  
  public abstract boolean startsWith(String prefix, int toffset);

  
  public abstract boolean startsWith(XMLString prefix, int toffset);

  
  public abstract boolean startsWith(String prefix);

  
  public abstract boolean startsWith(XMLString prefix);

  
  public abstract boolean endsWith(String suffix);

  
  public abstract int hashCode();

  
  public abstract int indexOf(int ch);

  
  public abstract int indexOf(int ch, int fromIndex);

  
  public abstract int lastIndexOf(int ch);

  
  public abstract int lastIndexOf(int ch, int fromIndex);

  
  public abstract int indexOf(String str);

  
  public abstract int indexOf(XMLString str);

  
  public abstract int indexOf(String str, int fromIndex);

  
  public abstract int lastIndexOf(String str);

  
  public abstract int lastIndexOf(String str, int fromIndex);

  
  public abstract XMLString substring(int beginIndex);

  
  public abstract XMLString substring(int beginIndex, int endIndex);

  
  public abstract XMLString concat(String str);

  
  public abstract XMLString toLowerCase(Locale locale);

  
  public abstract XMLString toLowerCase();

  
  public abstract XMLString toUpperCase(Locale locale);

  
  public abstract XMLString toUpperCase();

  
  public abstract XMLString trim();

  
  public abstract String toString();
  
  
  public abstract boolean hasString();
  
  
  public double toDouble();
}
"
org.apache.xml.serializer.SerializerConstants,1,1,0,1,2,0,1,0,0,2.0,27,0.0,0,0.0,0.0,0,0,10.0,0,0.0,0,"
package org.apache.xml.serializer;


public interface SerializerConstants
{

    
    static final String CDATA_CONTINUE = ""]]]]><![CDATA[>"";
    
    static final String CDATA_DELIMITER_CLOSE = ""]]>"";
    static final String CDATA_DELIMITER_OPEN = ""<![CDATA["";

    static final char[] CNTCDATA = CDATA_CONTINUE.toCharArray();
    static final char[] BEGCDATA = CDATA_DELIMITER_OPEN.toCharArray();
    static final char[] ENDCDATA = CDATA_DELIMITER_CLOSE.toCharArray();

    static final String EMPTYSTRING = """";

    static final String ENTITY_AMP = ""&amp;"";
    static final String ENTITY_CRLF = ""&#xA;"";
    static final String ENTITY_GT = ""&gt;"";
    static final String ENTITY_LT = ""&lt;"";
    static final String ENTITY_QUOT = ""&quot;"";

    static final String XML_PREFIX = ""xml"";
    static final String XMLNS_PREFIX = ""xmlns"";
    static final String XMLNS_URI = ""http:
   
    public static final String DEFAULT_SAX_SERIALIZER=""org.apache.xml.serializer.ToXMLSAXHandler"";
}
"
org.apache.xml.utils.synthetic.reflection.Field,33,1,0,3,73,0,1,3,33,0.75,469,0.0,2,0.0,0.158508159,1,1,13.03030303,6,1.303,1,"
package org.apache.xml.utils.synthetic.reflection;

import org.apache.xml.utils.synthetic.Class;
import org.apache.xml.utils.synthetic.SynthesisException;


public class Field extends Object implements Member
{

  
  public String name, initializer = null;

  
  int modifiers;

  
  java.lang.reflect.Field realfield = null;

  
  Class declaringClass, type;

  
  public Field(java.lang.reflect.Field realfield,
               org.apache.xml.utils.synthetic.Class declaringClass)
  {

    this(realfield.getName(), declaringClass);

    this.realfield = realfield;
    this.type =
      org.apache.xml.utils.synthetic.Class.forClass(realfield.getType());
  }

  
  public Field(String name,
               org.apache.xml.utils.synthetic.Class declaringClass)
  {
    this.name = name;
    this.declaringClass = declaringClass;
  }

  
  public boolean equals(Object obj)
  {

    if (realfield != null)
      return realfield.equals(obj);
    else if (obj instanceof Field)
    {
      Field objf = (Field) obj;

      return (declaringClass.equals(objf.declaringClass)
              && name.equals(objf.name) && type.equals(objf.type));
    }
    else
      return false;
  }

  
  public Object get(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.get(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public boolean getBoolean(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getBoolean(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public byte getByte(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getByte(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public char getChar(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getChar(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public org.apache.xml.utils.synthetic.Class getDeclaringClass()
  {

    if (realfield != null)
      return org.apache.xml.utils.synthetic.Class.forClass(
        realfield.getDeclaringClass());

    throw new java.lang.IllegalStateException();
  }

  
  public double getDouble(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getDouble(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public float getFloat(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getFloat(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public int getInt(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getInt(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public long getLong(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getLong(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public int getModifiers()
  {

    if (realfield != null)
      modifiers = realfield.getModifiers();

    return modifiers;
  }

  
  public String getInitializer()
  {
    return initializer;
  }

  
  public void setInitializer(String i) throws SynthesisException
  {

    if (realfield != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    initializer = i;
  }

  
  public java.lang.String getName()
  {
    return name;
  }

  
  public short getShort(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getShort(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public Class getType()
  {

    if (realfield != null)
      type = Class.forClass(realfield.getType());

    return type;
  }

  
  public void setType(org.apache.xml.utils.synthetic.Class type)
          throws SynthesisException
  {

    if (realfield != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.type = type;
  }

  
  public int hashCode()
  {

    if (realfield != null)
      return realfield.hashCode();
    else
      return declaringClass.getName().hashCode() ^ name.hashCode();
  }

  
  public void set(Object obj, Object value)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.set(obj, value);

    throw new java.lang.IllegalStateException();
  }

  
  public void setBoolean(Object obj, boolean z)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setBoolean(obj, z);

    throw new java.lang.IllegalStateException();
  }

  
  public void setByte(Object obj, byte b)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setByte(obj, b);

    throw new java.lang.IllegalStateException();
  }

  
  public void setChar(Object obj, char c)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setChar(obj, c);

    throw new java.lang.IllegalStateException();
  }

  
  public void setDeclaringClass(
          org.apache.xml.utils.synthetic.Class declaringClass)
  {
    this.declaringClass = declaringClass;
  }

  
  public void setDouble(Object obj, double d)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setDouble(obj, d);

    throw new java.lang.IllegalStateException();
  }

  
  public void setFloat(Object obj, float f)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setFloat(obj, f);

    throw new java.lang.IllegalStateException();
  }

  
  public void setInt(Object obj, int i)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setInt(obj, i);

    throw new java.lang.IllegalStateException();
  }

  
  public void setLong(Object obj, long l)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setLong(obj, l);

    throw new java.lang.IllegalStateException();
  }

  
  public void setModifiers(int modifiers) throws SynthesisException
  {

    if (realfield != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.modifiers = modifiers;
  }

  
  public void setShort(Object obj, short s)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setShort(obj, s);

    throw new java.lang.IllegalStateException();
  }

  
  public String toString()
  {

    if (realfield != null)
      return realfield.toString();

    throw new java.lang.IllegalStateException();
  }

  
  public String toSource()
  {

    StringBuffer sb = new StringBuffer(
      java.lang.reflect.Modifier.toString(getModifiers())).append(' ').append(
      getType().getJavaName()).append(' ').append(getName());
    String i = getInitializer();

    if (i != null && i.length() > 0)
      sb.append('=').append(i);

    sb.append(';');

    return sb.toString();
  }
}
"
org.apache.xpath.functions.FuncLocalPart,2,5,0,5,9,1,0,5,2,2.0,42,0.0,0,0.982142857,0.75,3,8,20.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncLocalPart extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int context = getArg0AsNode(xctxt);
    if(DTM.NULL == context)
      return XString.EMPTYSTRING;
    DTM dtm = xctxt.getDTM(context);
    String s = (context != DTM.NULL) ? dtm.getLocalName(context) : """";
    if(s.startsWith(""#"") || s.equals(""xmlns""))
      return XString.EMPTYSTRING;

    return new XString(s);
  }
}
"
org.apache.xpath.functions.FuncCount,2,4,0,6,8,1,0,6,2,2.0,23,0.0,0,0.979591837,0.75,1,6,10.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class FuncCount extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {












	DTMIterator nl = m_arg0.asIterator(xctxt, xctxt.getCurrentNode());
	int i = nl.getLength();	
	nl.detach();

    return new XNumber((double) i);
  }
}
"
org.apache.xalan.lib.ExsltDatetime,45,1,0,3,83,990,0,3,37,1.022727273,1528,0.0,0,0.0,0.172222222,0,0,32.75555556,10,1.6,2,"

package org.apache.xalan.lib;


import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;

import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;



public class ExsltDatetime
{
    
    static final String dt = ""yyyy-MM-dd'T'HH:mm:ss"";
    static final String d = ""yyyy-MM-dd"";
    static final String gym = ""yyyy-MM"";
    static final String gy = ""yyyy"";
    static final String gmd = ""--MM-dd"";
    static final String gm = ""--MM--"";
    static final String gd = ""---dd"";
    static final String t = ""HH:mm:ss"";
    static final String EMPTY_STR = """";

    
    public static String dateTime()
    {
      Calendar cal = Calendar.getInstance();
      Date datetime = cal.getTime();
      
      SimpleDateFormat dateFormat = new SimpleDateFormat(dt);
      
      StringBuffer buff = new StringBuffer(dateFormat.format(datetime));
      
      
      int offset = cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET);
      
      
      if (offset == 0)
        buff.append(""Z"");
      else
      {
        
        int hrs = offset/(60*60*1000);
        
        int min = offset%(60*60*1000);
        char posneg = hrs < 0? '-': '+';
        buff.append(posneg + formatDigits(hrs) + ':' + formatDigits(min));
      }
      return buff.toString();
    }
    
    
    private static String formatDigits(int q)
    {
      String dd = String.valueOf(Math.abs(q));
      return dd.length() == 1 ? '0' + dd : dd;
    }

    
    public static String date(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String leader = edz[0];
      String datetime = edz[1];
      String zone = edz[2];
      if (datetime == null || zone == null) 
        return EMPTY_STR;
                    
      String[] formatsIn = {dt, d};
      String formatOut = d;
      Date date = testFormats(datetime, formatsIn);
      if (date == null) return EMPTY_STR;
      
      SimpleDateFormat dateFormat = new SimpleDateFormat(formatOut);
      dateFormat.setLenient(false);
      String dateOut = dateFormat.format(date);      
      if (dateOut.length() == 0)
          return EMPTY_STR;
      else        
        return (leader + dateOut + zone);
    }
    
    
    
    public static String date()
    {
      String datetime = dateTime().toString();
      String date = datetime.substring(0, datetime.indexOf(""T""));
      String zone = datetime.substring(getZoneStart(datetime));
      return (date + zone);
    }
    
    
    public static String time(String timeIn)
      throws ParseException      
    {
      String[] edz = getEraDatetimeZone(timeIn);
      String time = edz[1];
      String zone = edz[2];
      if (time == null || zone == null) 
        return EMPTY_STR;
                    
      String[] formatsIn = {dt, d};
      String formatOut =  t;
      Date date = testFormats(time, formatsIn);
      if (date == null) return EMPTY_STR;
      SimpleDateFormat dateFormat = new SimpleDateFormat(formatOut);
      String out = dateFormat.format(date);
      return (out + zone);
    }

    
    public static String time()
    {
      String datetime = dateTime().toString();
      String time = datetime.substring(datetime.indexOf(""T"")+1);
      String zone = datetime.substring(getZoneStart(datetime));      
      return (time + zone);
    } 
       
    
    public static double year(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      boolean ad = edz[0].length() == 0; 
      String datetime = edz[1];
      if (datetime == null) 
        return Double.NaN;
      
      String[] formats = {dt, d, gym, gy};
      double yr = getNumber(datetime, formats, Calendar.YEAR);
      if (ad || yr == Double.NaN)
        return yr;
      else
        return -yr;
    }
     
    
    public static double year()
    {
      Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.YEAR);
    }
    
    
    public static double monthInYear(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null)
        return Double.NaN;      
      
      String[] formats = {dt, d, gym, gm, gmd};
      return getNumber(datetime, formats, Calendar.MONTH);
    }
    
    
    public static double monthInYear()
    {      
      Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.MONTH);
   }
    
    
    public static double weekInYear(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return Double.NaN;      
      
      String[] formats = {dt, d};
      return getNumber(datetime, formats, Calendar.WEEK_OF_YEAR);
    }
        
    
    public static double weekInYear()
    {
       Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.WEEK_OF_YEAR);
   }

    
    public static double dayInYear(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return Double.NaN;            
      
      String[] formats = {dt, d};
      return getNumber(datetime, formats, Calendar.DAY_OF_YEAR);
    }
    
    
    public static double dayInYear()
    {
       Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.DAY_OF_YEAR);
   }
    

    
    public static double dayInMonth(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      String[] formats = {dt, d, gmd, gd};
      double day = getNumber(datetime, formats, Calendar.DAY_OF_MONTH);
      return day;
    }
    
    
    public static double dayInMonth()
    {
      Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.DAY_OF_MONTH);
   }
    
    
    public static double dayOfWeekInMonth(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return Double.NaN;            

      String[] formats =  {dt, d};
      return getNumber(datetime, formats, Calendar.DAY_OF_WEEK_IN_MONTH);
    }
    
    
    public static double dayOfWeekInMonth()
    {
       Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.DAY_OF_WEEK_IN_MONTH);
   }
      
    
    
    public static double dayInWeek(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return Double.NaN;            

      String[] formats = {dt, d};
      return getNumber(datetime, formats, Calendar.DAY_OF_WEEK);
    }
    
    
    public static double dayInWeek()
    {
       Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.DAY_OF_WEEK);
   }        

    
    public static double hourInDay(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return Double.NaN;            
      
      String[] formats = {dt, t};
      return getNumber(datetime, formats, Calendar.HOUR_OF_DAY);
    }
    
    
    public static double hourInDay()
    {
       Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.HOUR_OF_DAY);
   }
    
    
    public static double minuteInHour(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return Double.NaN;            
      
      String[] formats = {dt,t};
      return getNumber(datetime, formats, Calendar.MINUTE);
    }    
    
    
   public static double minuteInHour()
    {
       Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.MINUTE);
   }    

    
    public static double secondInMinute(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return Double.NaN;            
      
      String[] formats = {dt, t};
      return getNumber(datetime, formats, Calendar.SECOND);
    }

    
    public static double secondInMinute()
    {
       Calendar cal = Calendar.getInstance();
      return cal.get(Calendar.SECOND);
    }
       
    
    public static XObject leapYear(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);            
            
      String[] formats = {dt, d, gym, gy};
      double dbl = getNumber(datetime, formats, Calendar.YEAR);
      if (dbl == Double.NaN) 
        return new XNumber(Double.NaN);
      int yr = (int)dbl;
      return new XBoolean(yr % 400 == 0 || (yr % 100 != 0 && yr % 4 == 0));
    }
    
    
    public static boolean leapYear()
    {
      Calendar cal = Calendar.getInstance();
      int yr = (int)cal.get(Calendar.YEAR);
      return (yr % 400 == 0 || (yr % 100 != 0 && yr % 4 == 0));      
    }    
       
    
    public static String monthName(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return EMPTY_STR;
      
      String[] formatsIn = {dt, d, gym, gm};
      String formatOut = ""MMMM"";
      return getNameOrAbbrev(datetimeIn, formatsIn, formatOut);    
    }
    
    
    public static String monthName()
    {
      Calendar cal = Calendar.getInstance();
      String format = ""MMMM"";
      return getNameOrAbbrev(format);  
    }
        
    
    public static String monthAbbreviation(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return EMPTY_STR;
      
      String[] formatsIn = {dt, d, gym, gm};
      String formatOut = ""MMM"";
      return getNameOrAbbrev(datetimeIn, formatsIn, formatOut);
    }
    
    
    public static String monthAbbreviation()
    {
      String format = ""MMM"";
      return getNameOrAbbrev(format);  
    }
        
    
    public static String dayName(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return EMPTY_STR;
            
      String[] formatsIn = {dt, d};
      String formatOut = ""EEEE"";
      return getNameOrAbbrev(datetimeIn, formatsIn, formatOut);    
    }
    
    
    public static String dayName()
    {
      String format = ""EEEE"";
      return getNameOrAbbrev(format);        
    }    
    
    
    public static String dayAbbreviation(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return EMPTY_STR;            
      
      String[] formatsIn = {dt, d};
      String formatOut = ""EEE"";
      return getNameOrAbbrev(datetimeIn, formatsIn, formatOut);
    }
    
    
    public static String dayAbbreviation()
    {
      String format = ""EEE"";
      return getNameOrAbbrev(format);              
    }
    
    
    private static String[] getEraDatetimeZone(String in)
    {
      String leader = """";
      String datetime = in;
      String zone = """";
      if (in.charAt(0)=='-' && !in.startsWith(""--""))
      {
        leader = ""-""; 
        datetime = in.substring(1);
      }
      int z = getZoneStart(datetime);
      if (z > 0)
      {
        zone = datetime.substring(z);
        datetime = datetime.substring(0, z);
      }
      else if (z == -2)
        zone = null;
      
      return new String[]{leader, datetime, zone};  
    }    
    
    
    private static int getZoneStart (String datetime)
    {
      if (datetime.indexOf(""Z"") == datetime.length()-1)
        return datetime.length()-1;
      else if (datetime.length() >=6 
      		&& datetime.charAt(datetime.length()-3) == ':'
      		&& (datetime.charAt(datetime.length()-6) == '+' 
      		    || datetime.charAt(datetime.length()-6) == '-'))      		    
      {
        try
        {
          SimpleDateFormat dateFormat = new SimpleDateFormat(""HH:mm"");
          dateFormat.setLenient(false);
          Date d = dateFormat.parse(datetime.substring(datetime.length() -5));
          return datetime.length()-6;
        }
        catch (ParseException pe)
        {
          System.out.println(""ParseException "" + pe.getErrorOffset());
          return -2; 
        }

      }
        return -1; 
    }
    
    
    private static Date testFormats (String in, String[] formats)
      throws ParseException
    {
      for (int i = 0; i <formats.length; i++)
      {
        try
        {
          SimpleDateFormat dateFormat = new SimpleDateFormat(formats[i]);
          dateFormat.setLenient(false);          
          return dateFormat.parse(in);
        }
        catch (ParseException pe)
        {
        }
      }
      return null;
    }
    
    
    
    private static double getNumber(String in, String[] formats, int calField)
      throws ParseException
    {
      Calendar cal = Calendar.getInstance();
      cal.setLenient(false);
      
      Date date = testFormats(in, formats);
      if (date == null) return Double.NaN;
      cal.setTime(date);
      return cal.get(calField);
    }    
     
    
    private static String getNameOrAbbrev(String in, 
                                         String[] formatsIn,
                                         String formatOut)
      throws ParseException
    {
      for (int i = 0; i <formatsIn.length; i++) 
      {
        try
        {
          SimpleDateFormat dateFormat = new SimpleDateFormat(formatsIn[i]);
          dateFormat.setLenient(false);
          Date dt = dateFormat.parse(in);          
          dateFormat.applyPattern(formatOut);
          return dateFormat.format(dt);
        }
        catch (ParseException pe)
        {
        }
      }
      return """";
    }
    
    private static String getNameOrAbbrev(String format)
    {
      Calendar cal = Calendar.getInstance();
      SimpleDateFormat dateFormat = new SimpleDateFormat(format);
      return dateFormat.format(cal.getTime());
    }

    
    public static String formatDate(String dateTime, String pattern)
    {
        final String yearSymbols = ""Gy"";
        final String monthSymbols = ""M"";
        final String daySymbols = ""dDEFwW"";
        TimeZone timeZone;
        String zone;

        
        
        if (dateTime.endsWith(""Z"") || dateTime.endsWith(""z""))
        {
            timeZone = TimeZone.getTimeZone(""GMT"");
            dateTime = dateTime.substring(0, dateTime.length()-1) + ""GMT"";
            zone = ""z"";
        }
        else if ((dateTime.length() >= 6) 
                 && (dateTime.charAt(dateTime.length()-3) == ':') 
                 && ((dateTime.charAt(dateTime.length()-6) == '+') 
                    || (dateTime.charAt(dateTime.length()-6) == '-')))
        {
            String offset = dateTime.substring(dateTime.length()-6);
            
            if (""+00:00"".equals(offset) || ""-00:00"".equals(offset))
            {
                timeZone = TimeZone.getTimeZone(""GMT"");
            }
            else
            {
                timeZone = TimeZone.getTimeZone(""GMT"" + offset);
            }
            zone = ""z"";
            
            
            dateTime = dateTime.substring(0, dateTime.length()-6) + ""GMT"" + offset;
        }
        else
        {
            
            timeZone = TimeZone.getDefault();
            zone = """";
            
            
        }
        String[] formats = {dt + zone, d, gym, gy};
        
        
        
        
        try
        {
            SimpleDateFormat inFormat = new SimpleDateFormat(t + zone);
            inFormat.setLenient(false);
            Date d= inFormat.parse(dateTime);
            SimpleDateFormat outFormat = new SimpleDateFormat(strip
                (yearSymbols + monthSymbols + daySymbols, pattern));
            outFormat.setTimeZone(timeZone);
            return outFormat.format(d);
        }
        catch (ParseException pe)
        {
        }
        
        
        for (int i = 0; i < formats.length; i++)
        {
            try
            {
                SimpleDateFormat inFormat = new SimpleDateFormat(formats[i]);
                inFormat.setLenient(false);
                Date d = inFormat.parse(dateTime);
                SimpleDateFormat outFormat = new SimpleDateFormat(pattern);
                outFormat.setTimeZone(timeZone);
                return outFormat.format(d);
            }
            catch (ParseException pe)
            {
            }
        }
        
        
        
        
        
        try
        {
            SimpleDateFormat inFormat = new SimpleDateFormat(gmd);
            inFormat.setLenient(false);          
            Date d = inFormat.parse(dateTime);
            SimpleDateFormat outFormat = new SimpleDateFormat(strip(yearSymbols, pattern));
            outFormat.setTimeZone(timeZone);
            return outFormat.format(d);
        }
        catch (ParseException pe)
        {
        }
        try
        {
            SimpleDateFormat inFormat = new SimpleDateFormat(gm);
            inFormat.setLenient(false);
            Date d = inFormat.parse(dateTime);
            SimpleDateFormat outFormat = new SimpleDateFormat(strip(yearSymbols, pattern));
            outFormat.setTimeZone(timeZone);
            return outFormat.format(d);
        }
        catch (ParseException pe)
        {
        }
        try
        {
            SimpleDateFormat inFormat = new SimpleDateFormat(gd);
            inFormat.setLenient(false);
            Date d = inFormat.parse(dateTime);
            SimpleDateFormat outFormat = new SimpleDateFormat(strip(yearSymbols + monthSymbols, pattern));
            outFormat.setTimeZone(timeZone);
            return outFormat.format(d);
        }
        catch (ParseException pe)
        {
        }
        return EMPTY_STR;
    }
    
    
    private static String strip(String symbols, String pattern)
    {
        int quoteSemaphore = 0;
        int i = 0;
        StringBuffer result = new StringBuffer(pattern.length());

        while (i < pattern.length())
        {
            char ch = pattern.charAt(i);
            if (ch == ''')
            {
                
                
                int endQuote = pattern.indexOf(''', i + 1);
                if (endQuote == -1)
                {
                    endQuote = pattern.length();
                }
                result.append(pattern.substring(i, endQuote));
                i = endQuote++;
            }
            else if (symbols.indexOf(ch) > -1)
            {
                
                i++;
            }
            else
            {
                result.append(ch);
                i++;
            }
        }
        return result.toString();
    }

}"
org.apache.xalan.templates.ElemTextLiteral,11,3,0,9,20,29,6,4,11,0.825,114,1.0,0,0.951456311,0.340909091,2,5,9.0,2,1.0,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.serializer.SerializationHandler;
import org.xml.sax.SAXException;


public class ElemTextLiteral extends ElemTemplateElement
{

  
  private boolean m_preserveSpace;

  
  public void setPreserveSpace(boolean v)
  {
    m_preserveSpace = v;
  }

  
  public boolean getPreserveSpace()
  {
    return m_preserveSpace;
  }

  
  private char m_ch[];
  
  
  private String m_str;

  
  public void setChars(char[] v)
  {
    m_ch = v;
  }

  
  public char[] getChars()
  {
    return m_ch;
  }
  
  
  public synchronized String getNodeValue()
  {

    if(null == m_str)
    {
      m_str = new String(m_ch);
    }

    return m_str;
  }


  
  private boolean m_disableOutputEscaping = false;

  
  public void setDisableOutputEscaping(boolean v)
  {
    m_disableOutputEscaping = v;
  }

  
  public boolean getDisableOutputEscaping()
  {
    return m_disableOutputEscaping;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_TEXTLITERALRESULT;
  }

  
  public String getNodeName()
  {
    return ""#Text"";
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
    try
    {
      SerializationHandler rth = transformer.getResultTreeHandler();
      if (m_disableOutputEscaping)
      {
        rth.processingInstruction(javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");
      }

      rth.characters(m_ch, 0, m_ch.length);

      if (m_disableOutputEscaping)
      {
        rth.processingInstruction(javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");
      }
    }
    catch(SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEndEvent(this);
    }
  }
}
"
org.apache.xalan.xsltc.dom.MatchingIterator,10,2,0,3,23,0,0,3,10,0.5,116,1.0,1,0.590909091,0.35,1,8,10.4,4,1.3,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;


public final class MatchingIterator extends DTMAxisIteratorBase {

    
    private DTMAxisIterator _source;

    
    private final int _match;

    public MatchingIterator(int match, DTMAxisIterator source) {
	_source = source;
	_match = match;
    }


    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }

    public DTMAxisIterator cloneIterator() {

	try {
	    final MatchingIterator clone = (MatchingIterator) super.clone();
	    clone._source = _source.cloneIterator();
	    clone._isRestartable = false;
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public DTMAxisIterator setStartNode(int node) {
	if (_isRestartable) {
	    
	    _source.setStartNode(node);

	    
	    _position = 1;
	    while ((node = _source.next()) != END && node != _match) {
		_position++;
	    }
	}
	return this;
    }

    public DTMAxisIterator reset() {
	_source.reset();
	return resetPosition();
    }
    
    public int next() {
	return _source.next();
    }
	
    public int getLast() {
        if (_last == -1) {
            _last = _source.getLast();
        }
        return _last;
    }

    public int getPosition() {
	return _position;
    }

    public void setMark() {
	_source.setMark();
    }

    public void gotoMark() {
	_source.gotoMark();
    }
}
"
org.apache.xalan.processor.ProcessorInclude,7,4,1,11,47,15,2,9,3,0.333333333,268,1.0,0,0.972222222,0.5,1,1,37.14285714,1,0.8571,0,"
package org.apache.xalan.processor;

import java.io.IOException;

import javax.xml.transform.Source;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.TreeWalker;

import org.w3c.dom.Node;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;


class ProcessorInclude extends XSLTElementProcessor
{

  
  private String m_href = null;

  
  public String getHref()
  {
    return m_href;
  }

  
  public void setHref(String baseIdent)
  {
    
    m_href = baseIdent;
  }

  
  protected int getStylesheetType()
  {
    return StylesheetHandler.STYPE_INCLUDE;
  }

  
  protected String getStylesheetInclErr()
  {
    return XSLTErrorResources.ER_STYLESHEET_INCLUDES_ITSELF;
  }

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {


    setPropertiesFromAttributes(handler, rawName, attributes, this);

    try
    {
      String hrefUrl = SystemIDResolver.getAbsoluteURI(getHref(),
                           handler.getBaseIdentifier());    

      if (handler.importStackContains(hrefUrl))
      {
        throw new org.xml.sax.SAXException(
          XSLMessages.createMessage(
          getStylesheetInclErr(), new Object[]{ hrefUrl }));  
      }

      handler.pushImportURL(hrefUrl);

      int savedStylesheetType = handler.getStylesheetType();

      handler.setStylesheetType(this.getStylesheetType());
      handler.pushNewNamespaceSupport();

      try
      {
        parse(handler, uri, localName, rawName, attributes);
      }
      finally
      {
        handler.setStylesheetType(savedStylesheetType);
        handler.popImportURL();
        handler.popNamespaceSupport();
      }
    }
    catch(TransformerException te)
    {
      handler.error(te.getMessage(), te);
    }
  }

  
  protected void parse(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {
    TransformerFactoryImpl processor = handler.getStylesheetProcessor();
    URIResolver uriresolver = processor.getURIResolver();

    try
    {
      Source source = null;

      if (null != uriresolver)
      {
        source = uriresolver.resolve(getHref(),
                                     handler.getBaseIdentifier());

        if (null != source && source instanceof DOMSource)
        {
          Node node = ((DOMSource)source).getNode();
          
          String systemId = source.getSystemId();
          if (systemId == null)
          {
            systemId = SystemIDResolver.getAbsoluteURI(getHref(),
                         handler.getBaseIdentifier());
            
          }
          
          TreeWalker walker = new TreeWalker(handler, new org.apache.xml.utils.DOM2Helper(), systemId);

          try
          {
            walker.traverse(node);
          }
          catch(org.xml.sax.SAXException se)
          {
            throw new TransformerException(se);
          }
          return;
        }
      }
      
      if(null == source)
      {
        String absURL = SystemIDResolver.getAbsoluteURI(getHref(),
                          handler.getBaseIdentifier());

        source = new StreamSource(absURL);
      }
      
      XMLReader reader = null;
      
      if(source instanceof SAXSource)
      {
        SAXSource saxSource = (SAXSource)source;
        reader = saxSource.getXMLReader(); 
      }
      
      InputSource inputSource = SAXSource.sourceToInputSource(source);

      if (null == reader)
      {  
        
        try {
          javax.xml.parsers.SAXParserFactory factory=
                                                     javax.xml.parsers.SAXParserFactory.newInstance();
          factory.setNamespaceAware( true );
          javax.xml.parsers.SAXParser jaxpParser=
                                                 factory.newSAXParser();
          reader=jaxpParser.getXMLReader();
          
        } catch( javax.xml.parsers.ParserConfigurationException ex ) {
          throw new org.xml.sax.SAXException( ex );
        } catch( javax.xml.parsers.FactoryConfigurationError ex1 ) {
            throw new org.xml.sax.SAXException( ex1.toString() );
        } 
        catch( NoSuchMethodError ex2 ) 
        {
        }
        catch (AbstractMethodError ame){}
      }
      if (null == reader)
        reader = XMLReaderFactory.createXMLReader();

      if (null != reader)
      {
        reader.setContentHandler(handler);
        handler.pushBaseIndentifier(inputSource.getSystemId());

        try
        {
          reader.parse(inputSource);
        }
        finally
        {
          handler.popBaseIndentifier();
        }
      }
    }
    catch (IOException ioe)
    {
      handler.error(XSLTErrorResources.ER_IOEXCEPTION,
                    new Object[]{ getHref() }, ioe);
    }
    catch(TransformerException te)
    {
      handler.error(te.getMessage(), te);
    }
  }
}
"
org.apache.xalan.res.XSLTErrorResources_de,3,4,0,1,4,1,0,1,2,1.423076923,3769,0.0,0,0.976190476,1.0,0,0,1251.0,1,0.3333,0,"
package org.apache.xalan.res;




public class XSLTErrorResources_de extends XSLTErrorResources
{

  
  public static final int MAX_CODE = 201;

  
  public static final int MAX_WARNING = 29;

  
  public static final int MAX_OTHERS = 55;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  

  
  public static final Object[][] contents = {

  
    { ""ERROR0000"", ""{0}""},

  


  {
    ER_NO_CURLYBRACE,
      ""Fehler: '{' in Ausdruck nicht zulässig""},

  


  {
    ER_ILLEGAL_ATTRIBUTE,
	""{0} hat ein unzulässiges Attribut: {1}""},

  


  {
    ER_NULL_SOURCENODE_APPLYIMPORTS,
      ""sourceNode ist Null in xsl:apply-imports!""},

  


  {
    ER_CANNOT_ADD,
	""{0} kann {1} nicht hinzugefügt werden""},

  


  {
    ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES,
      ""sourceNode ist Null in handleApplyTemplatesInstruction!""},

  


  {
    ER_NO_NAME_ATTRIB,
	""{0} muss ein ''name''-Attribut haben.""},

  


  {
    ER_TEMPLATE_NOT_FOUND,
	""Vorlage konnte nicht gefunden werden: {0}""},

  


  {
    ER_CANT_RESOLVE_NAME_AVT,
      ""AVT-Name in xsl:call-template konnte nicht aufgelöst werden.""},

  


  {
    ER_REQUIRES_ATTRIB,
	""{0} erfordert Attribut: {1}""},

  


  {
    ER_MUST_HAVE_TEST_ATTRIB,
      ""{0} muss ein ''test''-Attribut haben.""},

  


  {
    ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""Ungültiger Wert des ''level''-Attributs: {0}""},

  


  {
    ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""processing-instruction-Name kann nicht 'xml' sein""},

  


  {
    ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""processing-instruction-Name muss ein gültiger NCName sein: {0}""},

  


  {
    ER_NEED_MATCH_ATTRIB,
      ""{0} muss ein ''match''-Attribut haben, falls ein Modus angegeben ist.""},

  


  {
    ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0} erfordert entweder ein ''name''- oder ein ''match''-Attribut.""},

  


  {
    ER_CANT_RESOLVE_NSPREFIX,
      ""Namensraum-Präfix kann nicht aufgelöst werden: {0}""},

  


  {
    ER_ILLEGAL_VALUE,
	 ""xml:space hat unzulässigen Wert: {0}""},

  


  {
    ER_NO_OWNERDOC,
      ""Tochterknoten hat kein Eigentümer-Dokument!""},

  


  {
    ER_ELEMTEMPLATEELEM_ERR,
	""ElemTemplateElement-Fehler: {0}""},

  


  {
    ER_NULL_CHILD,
 	""Versuch, einen Null-Tochterknoten hinzuzufügen!""},

  


  {
    ER_NEED_SELECT_ATTRIB,
	""{0} erfordert ein ''select''-Attribut.""},

  


  {
    ER_NEED_TEST_ATTRIB,
      ""xsl:when muss ein 'test'-Attribut haben.""},

  


  {
    ER_NEED_NAME_ATTRIB,
      ""xsl:with-param muss ein 'name'-Attribut haben.""},

  


  {
    ER_NO_CONTEXT_OWNERDOC,
      ""Kontext hat kein Eigentümer-Dokument!""},

  


  {
    ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""XML TransformerFactory Liaison konnte nicht erstellt werden: {0}""},

  


  {
    ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: Prozess fehlgeschlagen.""},

  


  {
    ER_NOT_SUCCESSFUL,
	""Xalan: fehlgeschlagen.""},

  


  {
    ER_ENCODING_NOT_SUPPORTED,
	""Codierung nicht unterstützt: {0}""},

  


  {
    ER_COULD_NOT_CREATE_TRACELISTENER,
      ""TraceListener konnte nicht erstellt werden: {0}""},

  


  {
    ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key erfordert ein 'name'-Attribut!""},

  


  {
    ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key erfordert ein 'match'-Attribut!""},

  


  {
    ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key erfordert ein 'use'-Attribut!""},

  


  {
    ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0} erfordert ein ''elements''-Attribut!""},

  


  {
    ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} ''prefix''-Attribut fehlt""},

  


  {
    ER_BAD_STYLESHEET_URL,
	""Stylesheet-URL ungültig: {0}""},

  


  {
    ER_FILE_NOT_FOUND,
	""Stylesheet-Datei nicht gefunden: {0}""},

  


  {
    ER_IOEXCEPTION,
      ""IO-Ausnahme bei Stylesheet-Datei: {0}""},

  


  {
    ER_NO_HREF_ATTRIB,
      ""(StylesheetHandler) ''href''-Attribut für {0} nicht gefunden""},

  


  {
    ER_STYLESHEET_INCLUDES_ITSELF,
      ""(StylesheetHandler) {0} schließt sich selbst direkt oder indirekt ein!""},

  


  {
    ER_PROCESSINCLUDE_ERROR,
      ""StylesheetHandler.processInclude-Fehler, {0}""},

  


  {
    ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} ''lang''-Attribut fehlt""},

  


  {
    ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) Element {0} an falscher Position?? Containerelement ''component'' fehlt""},

  


  {
    ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
      ""Ausgabe nur möglich in Element, DocumentFragment, Document oder PrintWriter.""},

  


  {
    ER_PROCESS_ERROR,
	""StylesheetRoot.process-Fehler""},

  


  {
    ER_UNIMPLNODE_ERROR,
	""UnImplNode-Fehler: {0}""},

  


  {
    ER_NO_SELECT_EXPRESSION,
      ""Fehler! 'select'-Ausdruck bei xpath nicht gefunden (-select).""},

  


  {
    ER_CANNOT_SERIALIZE_XSLPROCESSOR,
      ""Ein XSLProcessor kann nicht serialisiert werden!""},

  


  {
    ER_NO_INPUT_STYLESHEET,
      ""Stylesheet-Eingabe nicht angegeben!""},

  


  {
    ER_FAILED_PROCESS_STYLESHEET,
      ""Stylesheet konnte nicht verarbeitet werden!""},

  


  {
    ER_COULDNT_PARSE_DOC,
	""Dokument {0} konnte nicht geparst werden!""},

  


  {
    ER_COULDNT_FIND_FRAGMENT,
	""Fragment nicht gefunden: {0}""},

  


  {
    ER_NODE_NOT_ELEMENT,
      ""Knoten, auf den von einem Fragmentbezeichner gezeigt wird, war kein Element: {0}""},

  


  {
    ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""for-each muss ein 'match'- oder 'name'-Attribut haben""},

  


  {
    ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB,
      ""Vorlagen müssen ein 'match'- oder 'name'-Attribut haben""},

  


  {
    ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""Kein Klone eines Dokument-Fragments!""}, 

  


  {
    ER_CANT_CREATE_ITEM,
      ""Element im Ergebnisbaum kann nicht erstellt werden: {0}""},

  


  {
    ER_XMLSPACE_ILLEGAL_VALUE,
      ""xml:space in der Quell-XML hat einen ungültigen Wert: {0}""},

  


  {
    ER_NO_XSLKEY_DECLARATION,
      ""Keine xsl:key-Vereinbarung für {0} vorhanden!""},

  


  {
    ER_CANT_CREATE_URL,
	""Fehler! URL kann nicht erstellt werden für: {0}""},

  


  {
    ER_XSLFUNCTIONS_UNSUPPORTED,
	 ""xsl:functions nicht unterstützt""},

  


  {
    ER_PROCESSOR_ERROR, ""XSLT TransformerFactory-Fehler""},

  


  {
    ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""(StylesheetHandler) {0} in einem Stylesheet nicht zulässig!""},

  


  {
    ER_RESULTNS_NOT_SUPPORTED,
      ""result-ns nicht mehr unterstützt! Verwenden Sie statt dessen xsl:output.""},

  


  {
    ER_DEFAULTSPACE_NOT_SUPPORTED,
      ""default-space nicht mehr unterstützt! Verwenden Sie statt dessen xsl:strip-space oder xsl:preserve-space.""},

  


  {
    ER_INDENTRESULT_NOT_SUPPORTED,
      ""indent-result nicht mehr unterstützt! Verwenden Sie statt dessen xsl:output.""},

  


  {
    ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0} hat ein ungültiges Attribut: {1}""},

  


  {
    ER_UNKNOWN_XSL_ELEM, ""Ungekanntes XSL-Element: {0}""},

  


  {
    ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort kann nur mit xsl:apply-templates oder xsl:for-each verwendet werden.""},

  


  {
    ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) xsl:when an falscher Position!""},

  


  {
    ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:when ohne übergeordnetes xsl:choose!""},

  


  {
    ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) xsl:otherwise an falscher Position!""},

  


  {
    ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:otherwise ohne übergeordnetes xsl:choose!""},

  


  {
    ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""(StylesheetHandler) {0} in einer Vorlage nicht zulässig!""},

  


  {
    ER_UNKNOWN_EXT_NS_PREFIX,
      ""(StylesheetHandler) Namensraum-Präfix {1} der Dateierweiterung {0} unbekannt""},

  


  {
    ER_IMPORTS_AS_FIRST_ELEM,
      ""(StylesheetHandler) Importe nur als erste Elemente im Stylesheet möglich!""},

  


  {
    ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0} schließt sich selbst direkt oder indirekt ein!""},

  


  {
    ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space hat ungültigen Wert: {0}""},

  


  {
    ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""processStylesheet fehlgeschlagen!""},

  


  {
    ER_SAX_EXCEPTION, ""SAX-Ausnahme""},

  


  {
    ER_XSLT_ERROR, ""XSLT-Fehler""},

  


  {
    ER_CURRENCY_SIGN_ILLEGAL,
      ""Währungszeichen in Formatierungsmuster nicht zulässig""},

  


  {
    ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""document-Funktion in Stylesheet-DOM nicht unterstützt!""},

  


  {
    ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""Präfix von Nicht-Präfix-Resolver kann nicht aufgelöst werden!""},

  


  {
    ER_REDIRECT_COULDNT_GET_FILENAME,
      ""Redirect-Erweiterung: Dateiname konnte nicht ermittelt werden - 'file'- oder 'select'-Attribut muss gültige Zeichenkette zurückgeben.""},

  


  {
    ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""FormatterListener kann in Redirect-Erweiterung nicht aufgebaut werden!""},

  


  {
    ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""Präfix in exclude-result-prefixes ist ungültig: {0}""},

  


  {
    ER_MISSING_NS_URI,
      ""Namensraum-URI für angegebenes Präfix fehlt""},

  


  {
    ER_MISSING_ARG_FOR_OPTION,
      ""Argument für Option fehlt: {0}""},

  


  {
    ER_INVALID_OPTION, ""Ungültige Option: {0}""},

  


  {
    ER_MALFORMED_FORMAT_STRING, ""Ungültige Formatierungszeichenkette: {0}""},

  


  {
    ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet erfordert ein 'version'-Attribut!""},

  


  {
    ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""Attribut: {0} hat einen ungültigen Wert: {1}""},

  


  {
    ER_CHOOSE_REQUIRES_WHEN, ""xsl:choose erfordert xsl:when""},

  


  {
    ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""xsl:apply-imports nicht zulässig in xsl:for-each""},

  


  {
    ER_CANT_USE_DTM_FOR_OUTPUT,
      ""Objekt der Klasse DTMLiaison kann für einen Ausgabe-DOM-Knoten nicht verwendet werden... Übergeben Sie statt dessen ein Objekt der Klasse org.apache.xpath.DOM2Helper!""},

  


  {
    ER_CANT_USE_DTM_FOR_INPUT,
      ""Objekt der Klasse DTMLiaison kann für einen Eingabe-DOM-Knoten nicht verwendet werden... Übergeben Sie statt dessen ein Objekt der Klasse org.apache.xpath.DOM2Helper!""},

  


  {
    ER_CALL_TO_EXT_FAILED,
      ""Aufruf des Erweiterungselements fehlgeschlagen: {0}""},

  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""Präfix muss sich in einen Namensraum auflösen: {0}""},

  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""Ungültiges UTF-16-Surrogat erkannt: {0} ?""},

  


  {
    ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0} verwendet sich selbst, was zu einer Endlosschleife führt.""},

  


  {
    ER_CANNOT_MIX_XERCESDOM,
      ""Eingabe, die nicht Xerces-DOM entspricht, kann nicht mit Xerces-DOM-Ausgabe gemischt werden!""},

  


  {
    ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},

  


  {
    ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""In ElemTemplateElement.readObject: {0}""},

  


  {
    ER_DUPLICATE_NAMED_TEMPLATE,
      ""Mehr als eine Vorlage gefunden, Name: {0}""},

  


  {
    ER_INVALID_KEY_CALL,
      ""Ungültiger Funktionsaufruf: Aufrufe mit rekursivem Schlüssel () nicht zulässig""},
  
  
 

  {
    ER_REFERENCING_ITSELF,
      ""Variable {0} bezieht sich direkt oder indirekt auf sich selbst!""},
  
  
 

  {
    ER_ILLEGAL_DOMSOURCE_INPUT,
      ""Der Eingabeknoten darf für ein DOMSource für newTemplates nicht Null sein!""},
	
	


  {
    ER_CLASS_NOT_FOUND_FOR_OPTION,
			""Klassendatei nicht gefunden für Option {0}""},
	
	


  {
    ER_REQUIRED_ELEM_NOT_FOUND,
			""Erforderliches Element nicht gefunden: {0}""},
  
  
 

  {
    ER_INPUT_CANNOT_BE_NULL,
			""InputStream kann nicht Null sein""},
  
  
 

  {
    ER_URI_CANNOT_BE_NULL,
			""URI kann nicht Null sein""},
  
  
 

  {
    ER_FILE_CANNOT_BE_NULL,
			""Datei kann nicht Null sein""},
  
   
 

  {
    ER_SOURCE_CANNOT_BE_NULL,
			""InputSource kann nicht Null sein""},
  
  
 

  {
    ER_CANNOT_INIT_BSFMGR,
			""BSF Manager konnte nicht initialisiert werden""},
  
  
 

  {
    ER_CANNOT_CMPL_EXTENSN,
			""Erweiterung kann nicht kompiliert werden""},
  
  
 

  {
    ER_CANNOT_CREATE_EXTENSN,
      ""Erweiterung kann nicht erstellt werde: {0} Grund: {1}""},
  
  
 

  {
    ER_INSTANCE_MTHD_CALL_REQUIRES,
      ""Instanzenmethoden-Aufruf von Methode {0} erfordert eine Object-Instanz als erstes Argument""},
  
  
 

  {
    ER_INVALID_ELEMENT_NAME,
      ""Ungültiger Elementname angegeben {0}""},
  
   
 

  {
    ER_ELEMENT_NAME_METHOD_STATIC,
      ""Elementnamen-Methode muss statisch sein {0}""},
  
   
 

  {
    ER_EXTENSION_FUNC_UNKNOWN,
             ""Erweiterungsfunktion {0} : {1} ist unbekannt""},
  
   
 

  {
    ER_MORE_MATCH_CONSTRUCTOR,
             ""Mehr als ein Best-Match für Konstruktor für {0}""},
  
   
 

  {
    ER_MORE_MATCH_METHOD,
             ""Mehr als ein Best-Match für Methode {0}""},
  
   
 

  {
    ER_MORE_MATCH_ELEMENT,
             ""Mehr als ein Best-Match für Elementmethode {0}""},
  
   
 

  {
    ER_INVALID_CONTEXT_PASSED,
             ""Ungültiger Kontext zur Auswertung von {0} übergeben""},
  
   
 

  {
    ER_POOL_EXISTS,
             ""Pool besteht bereits""},
  
   
 

  {
    ER_NO_DRIVER_NAME,
             ""Kein Treibername angegeben""},
  
   
 

  {
    ER_NO_URL,
             ""Kein URL angegeben""},
  
   
 

  {
    ER_POOL_SIZE_LESSTHAN_ONE,
             ""Pool-Größe kleiner als Eins!""},
  
   
 

  {
    ER_INVALID_DRIVER,
             ""Ungültiger Treibername angegeben!""},
  
   
 

  {
    ER_NO_STYLESHEETROOT,
             ""Stylesheet-Stamm nicht gefunden!""},
  
   
 

  {
    ER_ILLEGAL_XMLSPACE_VALUE,
         ""Ungültiger Wert für xml:space""},
  
   


  {
    ER_PROCESSFROMNODE_FAILED,
         ""processFromNode fehlgeschlagen""},
  
   
  

  {
    ER_RESOURCE_COULD_NOT_LOAD,
        ""Die Ressource [ {0} ] konnte nicht laden: {1} 
 {2} 	 {3}""},
   
  
   
  

  {
    ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""Puffergröße <=0""},
  
   
  

  {
    ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""Unbekannter Fehler beim Aufruf der Erweiterung""},
  
   
  

  {
    ER_NO_NAMESPACE_DECL,
        ""Präfix {0} hat keine entsprechende Namensraum-Vereinbarung""},
  
   
  

  {
    ER_ELEM_CONTENT_NOT_ALLOWED,
        ""Elementinhalt nicht zulässig für lang=javaclass {0}""},
  
   
  

  {
    ER_STYLESHEET_DIRECTED_TERMINATION,
        ""Stylesheet führte zu Beendigung""},
  
   
  

  {
    ER_ONE_OR_TWO,
        ""1 oder 2""},
  
   
  

  {
    ER_TWO_OR_THREE,
        ""2 oder 3""},

   
  

  {
    ER_COULD_NOT_LOAD_RESOURCE,
        ""{0} konnte nicht geladen werden (überprüfen Sie CLASSPATH); jetzt werden die Standardwerte verwendet""},
  
   
  

  {
    ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""Standardvorlagen können nicht initialisiert werden""},
  
   
  

  {
    ER_RESULT_NULL,
        ""Ergebnis sollte nicht Null sein""},
    
   
  

  {
    ER_RESULT_COULD_NOT_BE_SET,
        ""Ergebnis konnte nicht festgelegt werden""},
  
   
  

  {
    ER_NO_OUTPUT_SPECIFIED,
        ""Keine Ausgabe festgelegt""},
  
   
  

  {
    ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""Transformation in ein Ergebnis vom Typ {0} nicht möglich""},
  
   
  

  {
    ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""Transformation einer Quelle vom Typ {0} nicht möglich""},
  
   
  

  {
    ER_NULL_CONTENT_HANDLER,
        ""Kein Content-Handler""},
  
   
  

  {
    ER_NULL_ERROR_HANDLER,
        ""Kein Error-Handler""},
  
   
  

  {
    ER_CANNOT_CALL_PARSE,
        ""parse kann nicht aufgerufen werden, wenn der ContentHandler nicht festgelegt wurde""},
  
   
  

  {
    ER_NO_PARENT_FOR_FILTER,
        ""Kein übergeordneter Knoten für Filter""},
  
  
   
  

  {
    ER_NO_STYLESHEET_IN_MEDIA,
         ""Kein Stylesheet gefunden in: {0}, media= {1}""},
  
   
  

  {
    ER_NO_STYLESHEET_PI,
         ""Kein xml-Stylesheet PI gefunden in: {0}""},
  
   
  

  {
    ER_NOT_SUPPORTED,
       ""Nicht unterstützt: {0}""},
    
   
  

  {
    ER_PROPERTY_VALUE_BOOLEAN,
       ""Wert für Eigenschaft {0} sollte eine Boolesche Instanz sein""},
  
   
   
  

  {
    ""ER_SRC_ATTRIB_NOT_SUPPORTED"",
       ""''src''-Attribut für {0} noch nicht unterstützt""},
  
  
  

  {
    ER_RESOURCE_COULD_NOT_FIND,
        ""Die Ressource [ {0} ] wurde nicht gefunden.
 {1}""},
  
   
  

  {
    ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""Ausgabe-Eigenschaft nicht erkannt: {0}""},
    
   
  

  {
    ER_FAILED_CREATING_ELEMLITRSLT,
        ""Erstellen von ElemLiteralResult-Instanz fehlgeschlagen""},
  
  
  
  
  

   
  

  {
    ER_VALUE_SHOULD_BE_NUMBER,
        ""Der Wert für {0} muss eine Nummer darstellen, die geparst werden kann.""},
  
   
  

  {
    ER_VALUE_SHOULD_EQUAL,
        "" Wert für {0} sollte Ja oder Nein sein""},
 
   
  

  {
    ER_FAILED_CALLING_METHOD,
        "" Aufruf der Methode {0} fehlgeschlagen""},
  
   
  

  {
    ER_FAILED_CREATING_ELEMTMPL,
        ""Erstellen von ElemTemplateElement-Instanz fehlgeschlagen""},
  
   
  

  {
    ER_CHARS_NOT_ALLOWED,
        ""Zeichen an dieser Stelle im Dokument nicht erlaubt""},
  
  
  

  {
    ER_ATTR_NOT_ALLOWED,
        """"{0}"" Attribut ist nicht erlaubt für Element {1}!""},
  
  
  

  {
    ER_BAD_VALUE,
     ""{0} ungültiger Wert {1} ""},
  
  
  

  {
    ER_ATTRIB_VALUE_NOT_FOUND,
     ""{0} Attributwert nicht gefunden""},
  
  
  

  {
    ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""{0} Attributwert nicht erkannt ""},

  
  

  {
    ER_NULL_URI_NAMESPACE,
     ""Es wurde versucht, einen Namensraum-Präfix ohne URI zu erzeugen.""},

  

  
  

  {
    ER_NUMBER_TOO_BIG,
     ""Es wurde versucht, eine Zahl größer als die größte lange Ganzzahl zu formatieren.""},



  

  {
    ER_CANNOT_FIND_SAX1_DRIVER,
     ""Die SAX1-Treiberklasse {0} kann nicht gefunden werden.""},


  

  {
    ER_SAX1_DRIVER_NOT_LOADED,
     ""Die SAX1-Treiberklasse {0} wurde gefunden, kann aber nicht geladen werden.""},


  

  {
    ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""Die SAX1-Treiberklasse {0} wurde geladen, es kann aber keine Instanz gebildet werden.""},



  

  {
    ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
     ""Die SAX1-Treiberklasse {0} implementiert org.xml.sax.Parser nicht.""},


  

  {
    ER_PARSER_PROPERTY_NOT_SPECIFIED,
     ""Die Systemeigenschaft org.xml.sax.parser wurde nicht angegeben.""},


  

  {
    ER_PARSER_ARG_CANNOT_BE_NULL,
     ""Das Parserargument darf nicht Null sein.""},



  

  {
    ER_FEATURE,
     ""Merkmal: {0}""},



  

  {
    ER_PROPERTY,
     ""Eigenschaft: {0}""},


  

  {
    ER_NULL_ENTITY_RESOLVER,
     ""Entity-Resolver Null""},


  

  {
    ER_NULL_DTD_HANDLER,
     ""DTD-Handler Null""},


  
  {
    ER_NO_DRIVER_NAME_SPECIFIED,
     ""Kein Treibername angegeben!""},



  
  {
    ER_NO_URL_SPECIFIED,
     ""Kein URL angegeben!""},



  
  {
    ER_POOLSIZE_LESS_THAN_ONE,
     ""Pool-Größe ist kleiner als 1!""},



  
  {
    ER_INVALID_DRIVER_NAME,
     ""Ungültiger Treibername angegeben!""},




  
  {
    ER_ERRORLISTENER,
     ""ErrorListener""},



  
  {
    ER_ASSERT_NO_TEMPLATE_PARENT,
     ""Programmierfehler! Ausdruck weist kein übergeordnetes Element ElemTemplateElement auf!""},



  
  {
    ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
     ""Programmierannahme in RundundentExprEliminator: {0}""},

  
  
  {
    ER_NOT_ALLOWED_IN_POSITION,
     ""{0} ist an dieser Stelle im Stylesheet nicht zulässig!""},

  
  
  {
    ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
     ""An dieser Stelle im Stylesheet ist nur Leerraum zulässig!""},

  
  
  
  
  {
    INVALID_TCHAR,
     ""Ungültiger Wert: {1} wurde für das CHAR-Attribut {0} verwendet. Ein Attribut vom Typ CHAR darf nur ein Zeichen aufweisen!""},

    
    
    
    
    

  
  
  
  {
    INVALID_QNAME,
     ""Ungültiger Wert: {1} wurde für das QNAME-Attribut {0} verwendet.""},

    
    
    
    
    
    

  
  
  {
    INVALID_ENUM,
     ""Ungültiger Wert: {1} wurde für das ENUM-Attribut {0} verwendet. Die gültigen Werte lauten: {2}.""},







  
  
  {
    INVALID_NMTOKEN,
     ""Ungültiger Wert: {1} wurde für das NMTOKEN-Attribut {0} verwendet. ""},







  
  
  {
    INVALID_NCNAME,
     ""Ungültiger Wert: {1} wurde für das NCNAME-Attribut {0} verwendet. ""},







  
  

  {
    INVALID_BOOLEAN,
     ""Ungültiger Wert: {1} wurde für das boolean-Attribut {0} verwendet. ""},







  
  
  {
    INVALID_NUMBER,
     ""Ungültiger Wert: {1} wurde für das number-Attribut {0} verwendet. ""},


  







  
  
  {
    ER_ARG_LITERAL,
     ""Das Argument für {0} im Muster muss ein Literal sein.""},






  
  
  {
    ER_DUPLICATE_GLOBAL_VAR,
     ""Doppelte Deklaration einer globalen Variablen.""},






  
  
  {
    ER_DUPLICATE_VAR,
     ""Doppelte Deklaration einer Variablen.""},

    
    
    

  
  
  {
    ER_TEMPLATE_NAME_MATCH,
     ""Das Element xsl:template muss ein name- oder ein match-Attribut (oder beide) aufweisen.""},

    
    
    
    
    

  
  
  {
    ER_INVALID_PREFIX,
     ""Präfix in exclude-result-prefixes ist nicht gültig: {0}""},

    
    
    
    
    

  
  
  {
    ER_NO_ATTRIB_SET,
     ""Das Attributset mit dem Namen {0} ist nicht vorhanden.""},


  

  
  

  {
    WG_FOUND_CURLYBRACE,
      ""'}' gefunden, aber keine Attributvorlage geöffnet!""},

  
  

  {
    WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""Warnung: ''count''-Attribute passt zu keinem Vorgängerknoten in xsl:number! Ziel = {0}""},

  
  

  {
    WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""Alte Syntax: Der Name des 'expr'-Attributs ist zu 'select' geändert worden.""},

  
  

  {
    WG_NO_LOCALE_IN_FORMATNUMBER,
      ""Xalan bearbeitet den lokalen Namen in der Funktion format-number noch nicht.""},

  
  

  {
    WG_LOCALE_NOT_FOUND,
      ""Warnung: Locale für xml:lang={0} nicht gefunden""},

  
  

  {
    WG_CANNOT_MAKE_URL_FROM,
      ""URL kann nicht erstellt werden aus: {0}""},

  
  

  {
    WG_CANNOT_LOAD_REQUESTED_DOC,
      ""Angefordertes Dokument kann nicht geladen werden: {0}""},

  
  

  {
    WG_CANNOT_FIND_COLLATOR,
      ""Collator für <sort xml:lang={0} nicht gefunden""},

  
  

  {
    WG_FUNCTIONS_SHOULD_USE_URL,
      ""Alte Syntax: Die Funktionsanweisung sollten einen URL von {0} verwenden""},

  
  

  {
    WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""Codierung nicht unterstützt: {0}, UTF-8 wird verwendet""},

  
  

  {
    WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      ""Codierung nicht unterstützt: {0}, Java {1} wird verwendet""},

  
  

  {
    WG_SPECIFICITY_CONFLICTS,
      ""Spezifitätskonflikte gefunden: {0} Zuletzt in Stylesheet gefundenes wird verwendet.""},

  
  

  {
    WG_PARSING_AND_PREPARING,
      ""========= Parsen und Vorbereiten {0} ==========""},

  
  

  {
    WG_ATTR_TEMPLATE, ""Attributvorlage, {0}""},

  
  

  {
    WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""Match-Konflikt zwischen xsl:strip-space und xsl:preserve-space""},

  
  

  {
    WG_ATTRIB_NOT_HANDLED,
      ""Xalan bearbeitet das Attribut {0} noch nicht!""},

  
  

  {
    WG_NO_DECIMALFORMAT_DECLARATION,
      ""Keine Vereinbarung für Dezimalformat gefunden: {0}""},

  
  

  {
    WG_OLD_XSLT_NS, ""XSLT-Namensraum fehlt oder ist nicht korrekt. ""},

  
  

  {
    WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""Nur eine Standardvereinbarung xsl:decimal-format ist erlaubt.""},

  
  

  {
    WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""xsl:decimal-format-Namen müssen eindeutig sein. Name ""{0}"" ist nicht eindeutig.""},

  
  

  {
    WG_ILLEGAL_ATTRIBUTE,
      ""{0} hat ein ungültiges Attribut: {1}""},

  
  

  {
    WG_COULD_NOT_RESOLVE_PREFIX,
      ""Namensraum-Präfix konnte nicht aufgelöst werden: {0}. Der Knoten wird ignoriert.""},

  
  

  {
    WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet erfordert ein 'version'-Attribut!""},

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_NAME,
      ""Ungültiger Attributname: {0}""},

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""Ungültiger Wert für Attribut {0}: {1}""},

  
  

  {
    WG_EMPTY_SECOND_ARG,
      ""Resultierendes Knotenset aus zweitem Argument von document-Funktion ist leer. Das erste Argument wird verwendet.""},

   

    
    
    


  
  
  {
    WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""Der Wert des name-Attributs von xsl:processing-instruction darf nicht 'xml' lauten.""},

    
    
    
    

  
  
  {
    WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""Der Wert des name-Attributs von xsl:processing-instruction muss einem gültigen ''NCName'' entsprechen: {0}""},

    
    
    
    
    

  
  
  {
    WG_ILLEGAL_ATTRIBUTE_POSITION,
      ""Das Attribut {0} kann nicht nach untergeordneten Elementen oder vor der Erstellung eines Elements hinzugefügt werden. Das Attribut wird ignoriert.""},

    


    { ""ui_language"", ""de""},
    { ""help_language"", ""de""},
    { ""language"", ""de""},
    { ""BAD_CODE"", ""Parameter für createMessage außerhalb der Grenzwerte""},
    { ""FORMAT_FAILED"",
      ""Ausnahme bei messageFormat-Aufruf""},
    { ""version"", "">>>>>>> Xalan Version ""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""ja""},
    { ""line"", ""Zeile #""},
    { ""column"", ""Spalte #""},
    { ""xsldone"",  ""XSLProcessor: fertig""},
    { ""xslProc_option"",  ""Optionen der Klasse Process in Xalan-J-Befehlszeile:""},
    { ""optionIN"", ""    -IN inputXMLURL""},
    { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
    { ""optionOUT"",  ""   [-OUT outputFileName]""},
    { ""optionLXCIN"", ""   [-LXCIN compiledStylesheetFileNameIn]""},
    { ""optionLXCOUT"", ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
    { ""optionPARSER"", ""   [-PARSER voll qualifizierter Klassenname von Parserliaison]""},
    { ""optionE"",  ""   [-E (Entity-Referenzen nicht erweitern)]""},
    { ""optionV"", ""   [-E (Entity-Referenzen nicht erweitern)]""},
    { ""optionQC"", ""   [-QC (Geräuscharme Warnungen bei Musterkonflikten)]""},
    { ""optionQ"", ""   [-Q  (Geräuschmer Modus)]""},
    { ""optionLF"", ""   [-LF (bei Ausgabe nur Zeilenvorsprung {Standard ist CR/LF})]""},
    { ""optionCR"", ""   [-CR (bei Ausgabe nur Wagenrücklauf {Standard ist CR/LF})]""},
    { ""optionESCAPE"", ""   [-ESCAPE (Zeichen für Escape {Standard ist <>&""'\r\n}]""},
    {  ""optionINDENT"", ""   [-INDENT (Anzahl der Leerzeichen zum Einrücken {Standard ist 0})]""},
    { ""optionTT"", ""   [-TT (Vorlagen beim Aufruf verfolgen.)]""},
    { ""optionTG"", ""   [-TG (Jedes Erzeugungsereignis verfolgen.)]""},
    { ""optionTS"", ""   [-TS (Jedes Auswahlereignis verfolgen.)]""},
    { ""optionTTC"", ""   [-TTC (Die Vorlagen-Tochterknoten bei Bearbeitung verfolgen.)]""},
    { ""optionTCLASS"", ""   [-TCLASS (TraceListener-Klasse für Trace-Erweiterungen.)]""},
    { ""optionVALIDATE"", ""   [-VALIDATE (Festlegen, ob Validierung stattfindet. Standard ist keine Validierung.)]""},
    { ""optionEDUMP"", ""   [-EDUMP {optionaler Dateiname} (Speicherauszug bei Fehler.)]""},
    { ""optionXML"", ""   [-XML (XML-Formatierer verwenden und XML-Header hinzufügen.)]""},
    { ""optionTEXT"", ""   [-TEXT (Einfachen Textformatierer verwenden.)]""},
    { ""optionHTML"", ""   [-HTML (HTML-Formatierer verwenden.)]""},
    { ""optionPARAM"", ""   [-PARAM Namensausdruck (Stylesheet-Parameter festlegen)]""},
    { ""noParsermsg1"",  ""XSL-Prozess fehlgeschlagen.""},
    { ""noParsermsg2"",  ""** Parser nicht gefunden **""},
    { ""noParsermsg3"",  ""Bitte Classpath überprüfen.""},
    { ""noParsermsg4"", ""Wenn Sie IBMs XML Parser for Java nicht haben, können Sie ihn von folgender Adresse herunterladen""},
    { ""noParsermsg5"",
	""IBMs AlphaWorks: http:
    { ""optionURIRESOLVER"",
     ""   [-URIRESOLVER vollständiger Klassenname (zum Auflösen von URIs zu verwendender URIResolver)]""},
    { ""optionENTITYRESOLVER"",
     ""   [-ENTITYRESOLVER vollständiger Klassenname (zum Auflösen von Entities zu verwendender EntityResolver)]""},
    { ""optionCONTENTHANDLER"",
     ""   [-CONTENTHANDLER vollständiger Klassenname (zum Serialisieren der Ausgabe zu verwendender ContentHandler)]""},
    { ""optionLINENUMBERS"",
     ""   [-L Zeilennummern für Quelldokument verwenden]""},
		
    


    { ""optionMEDIA"",
     "" [-MEDIA Medientyp (media-Attribut zum Auffinden des einem Dokument zugeordneten Stylesheets verwenden)]""},
    { ""optionFLAVOR"",
     "" [-FLAVOR Variantenname(Ausdrücklich s2s=SAX oder d2d=DOM für die Transformation verwenden)] ""}, 
    { ""optionDIAG"",
     "" [-DIAG (Zeitdauer der Transformation in Millisekunden ausgeben)]""},
    { ""optionINCREMENTAL"",
     "" [-INCREMENTAL (Inkrementellen DTM-Aufbau anfordern, indem http:
    { ""optionNOOPTIMIMIZE"",
     "" [-NOOPTIMIMIZE (Keine Optimierung des Stylesheets durchführen, indem http:
    { ""optionRL"",
     "" [-RL Rekursionsgrenze (Numerische Begrenzung der Rekursionstiefe für das Stylesheet)]""},
    { ""optionXO"",
     "" [-XO [Translet-Name] (Zuweisen eines Namens zum erzeugten Translet)]""},
    { ""optionXD"",
     "" [-XD Zielverzeichnis (Angabe eines Zielverzeichnisses für das Translet)]""},
    { ""optionXJ"",
     "" [-XJ JAR-Datei (Erstellt ein Paket mit den Translet-Klassen in einer JAR-Datei mit dem Namen <JAR-Datei>)]""},
    {  ""optionXP"",
     "" [-XP Paket (Angabe eines Paketnamen-Präfixes für alle erzeugten Translet-Klassen)]""}


  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_STRING = ""#Fehler"";

  
  public static final String ERROR_HEADER = ""Fehler: "";

  
  public static final String WARNING_HEADER = ""Warnung: "";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""MUSTER "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}


"
org.apache.xml.serializer.SerializerTraceWriter,8,2,0,2,17,0,1,1,6,0.171428571,514,1.0,1,0.65,0.3125,1,2,62.625,1,0.875,0,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.Writer;


public class SerializerTraceWriter extends Writer
{

    
    private final java.io.Writer m_writer;

    
    private final SerializerTrace m_tracer;

    
    private int buf_length;

    
    private byte buf[];

    
    private int count;

    
    private void setBufferSize(int size)
    {
        buf = new byte[size + 3];
        buf_length = size;
        count = 0;
    }

    
    public SerializerTraceWriter(Writer out, SerializerTrace tracer)
    {
        m_writer = out;
        m_tracer = tracer;
        setBufferSize(1024);
    }

    
    private void flushBuffer() throws IOException
    {

        
        if (count > 0)
        {
            char[] chars = new char[count];
            for(int i=0; i<count; i++)
                chars[i] = (char) buf[i];

            if (m_tracer != null)
                m_tracer.fireGenerateEvent(
                    SerializerTrace.EVENTTYPE_OUTPUT_CHARACTERS,
                    chars,
                    0,
                    chars.length);

            count = 0;
        }
    }

    
    public void flush() throws java.io.IOException
    {
        
        if (m_writer != null)
            m_writer.flush();

        
        flushBuffer();
    }

    
    public void close() throws java.io.IOException
    {
        
        if (m_writer != null)   
            m_writer.close();

        
        flushBuffer();
    }


    
    public void write(final int c) throws IOException
    {
        
        if (m_writer != null)
            m_writer.write(c);

        

        
        if (count >= buf_length)
            flushBuffer();

        if (c < 0x80)
        {
            buf[count++] = (byte) (c);
        }
        else if (c < 0x800)
        {
            buf[count++] = (byte) (0xc0 + (c >> 6));
            buf[count++] = (byte) (0x80 + (c & 0x3f));
        }
        else
        {
            buf[count++] = (byte) (0xe0 + (c >> 12));
            buf[count++] = (byte) (0x80 + ((c >> 6) & 0x3f));
            buf[count++] = (byte) (0x80 + (c & 0x3f));
        }
    }

    
    public void write(final char chars[], final int start, final int length)
        throws java.io.IOException
    {
        
        if (m_writer != null)
            m_writer.write(chars, start, length);

        
        int lengthx3 = (length << 1) + length;

        if (lengthx3 >= buf_length)
        {

            

            flushBuffer();
            setBufferSize(2 * lengthx3);

        }

        if (lengthx3 > buf_length - count)
        {
            flushBuffer();
        }

        final int n = length + start;
        for (int i = start; i < n; i++)
        {
            final char c = chars[i];

            if (c < 0x80)
                buf[count++] = (byte) (c);
            else if (c < 0x800)
            {
                buf[count++] = (byte) (0xc0 + (c >> 6));
                buf[count++] = (byte) (0x80 + (c & 0x3f));
            }
            else
            {
                buf[count++] = (byte) (0xe0 + (c >> 12));
                buf[count++] = (byte) (0x80 + ((c >> 6) & 0x3f));
                buf[count++] = (byte) (0x80 + (c & 0x3f));
            }
        }

    }

    
    public void write(final String s) throws IOException
    {
        
        if (m_writer != null)
            m_writer.write(s);

        
        final int length = s.length();

        
        
        

        int lengthx3 = (length << 1) + length;

        if (lengthx3 >= buf_length)
        {

            

            flushBuffer();
            setBufferSize(2 * lengthx3);
        }

        if (lengthx3 > buf_length - count)
        {
            flushBuffer();
        }

        for (int i = 0; i < length; i++)
        {
            final char c = s.charAt(i);

            if (c < 0x80)
                buf[count++] = (byte) (c);
            else if (c < 0x800)
            {
                buf[count++] = (byte) (0xc0 + (c >> 6));
                buf[count++] = (byte) (0x80 + (c & 0x3f));
            }
            else
            {
                buf[count++] = (byte) (0xe0 + (c >> 12));
                buf[count++] = (byte) (0x80 + ((c >> 6) & 0x3f));
                buf[count++] = (byte) (0x80 + (c & 0x3f));
            }
        }
    }

}"
org.apache.xalan.xsltc.dom.MultiDOM,52,1,0,15,109,202,4,13,50,0.851540616,775,1.0,3,0.0,0.185314685,0,0,13.76923077,11,1.6346,1,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.StripFilter;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xalan.xsltc.runtime.Hashtable;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;
import org.apache.xml.dtm.ref.DTMDefaultBase;
import org.apache.xml.utils.SuballocatedIntVector;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public final class MultiDOM implements DOM {

    private static final int NO_TYPE = DOM.FIRST_TYPE - 2;
    private static final int INITIAL_SIZE = 4;
    
    private DOM[] _adapters;
    private DOMAdapter _main;
    private int _free;
    private int _size;

    private Hashtable _documents = new Hashtable();

    private final class AxisIterator extends DTMAxisIteratorBase {
        
        private final int _axis;
        private final int _type;
        
        private DTMAxisIterator _source;
        private int _dtmId = -1;

        public AxisIterator(final int axis, final int type) {
            _axis = axis;
            _type = type;
        }

        public int next() {
            if (_source == null) {
                return(END);
            }
            return _source.next();
        }


        public void setRestartable(boolean flag) {
            if (_source != null) {
                _source.setRestartable(flag);
            }
        }

        public DTMAxisIterator setStartNode(final int node) {
            if (node == DTM.NULL) {
                return this;
            }

            int dom = node >>> DTMManager.IDENT_DTM_NODE_BITS;

            
            if (_source == null || _dtmId != dom) {
                if (_type == NO_TYPE) {
                    _source = _adapters[dom].getAxisIterator(_axis);
                } else if (_axis == Axis.CHILD) {
                    _source = _adapters[dom].getTypedChildren(_type);
                } else {
                    _source = _adapters[dom].getTypedAxisIterator(_axis, _type);
                }
            }

            _dtmId = dom;
            _source.setStartNode(node);
            return this;
        }

        public DTMAxisIterator reset() {
            if (_source != null) {
                _source.reset();
            }
            return this;
        }
    
        public int getLast() {
            if (_source != null) {
                return _source.getLast();
            }
            else {
                return END;
            }
        }

        public int getPosition() {
            if (_source != null) {
                return _source.getPosition();
            }
            else {
                return END;
            }
        }
    
        public boolean isReverse() {
	    return Axis.isReverse[_axis];
        }
    
        public void setMark() {
            if (_source != null) {
                _source.setMark();
            }
        }
    
        public void gotoMark() {
            if (_source != null) {
                _source.gotoMark();
            }
        }
    
        public DTMAxisIterator cloneIterator() {
            final AxisIterator clone = new AxisIterator(_axis, _type);
            if (_source != null) {
                clone._source = _source.cloneIterator();
            }
            clone._dtmId = _dtmId;
            return clone;
        }
    } 


    
    private final class NodeValueIterator extends DTMAxisIteratorBase {

        private DTMAxisIterator _source;
        private String _value;
        private boolean _op;
        private final boolean _isReverse;
        private int _returnType = RETURN_PARENT;

        public NodeValueIterator(DTMAxisIterator source, int returnType,
                                 String value, boolean op) {
            _source = source;
            _returnType = returnType;
            _value = value;
            _op = op;
            _isReverse = source.isReverse();
        }

        public boolean isReverse() {
            return _isReverse;
        }
    
        public DTMAxisIterator cloneIterator() {
            try {
                NodeValueIterator clone = (NodeValueIterator)super.clone();
                clone._source = _source.cloneIterator();
                clone.setRestartable(false);
                return clone.reset();
            }
            catch (CloneNotSupportedException e) {
                BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
                                          e.toString());
                return null;
            }
        }


        public void setRestartable(boolean isRestartable) {
            _isRestartable = isRestartable;
            _source.setRestartable(isRestartable);
        }

        public DTMAxisIterator reset() {
            _source.reset();
            return resetPosition();
        }

        public int next() {

            int node;
            while ((node = _source.next()) != END) {
                String val = getStringValueX(node);
                if (_value.equals(val) == _op) {
                    if (_returnType == RETURN_CURRENT)
                        return returnNode(node);
                    else
                        return returnNode(getParent(node));
                }
            }
            return END;
        }

        public DTMAxisIterator setStartNode(int node) {
            if (_isRestartable) {
                _source.setStartNode(_startNode = node); 
                return resetPosition();
            }
            return this;
        }

        public void setMark() {
            _source.setMark();
        }

        public void gotoMark() {
            _source.gotoMark();
        }
    }                       

    public MultiDOM(DOM main) {
        _size = INITIAL_SIZE;
        _free = 1;
        _adapters = new DOM[INITIAL_SIZE];
        DOMAdapter adapter = (DOMAdapter)main;
        _adapters[0] = adapter;
        _main = adapter;

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        addDOMAdapter(adapter, false);
    }

    public int nextMask() {
        return _free;
    }

    public void setupMapping(String[] names, String[] namespaces) {
        
    }

    public int addDOMAdapter(DOMAdapter adapter) {
        return addDOMAdapter(adapter, true);
    }

    private int addDOMAdapter(DOMAdapter adapter, boolean indexByURI) {
        
        DOM dom = adapter.getDOMImpl();
        
        int domNo = 1;
        int dtmSize = 1;
        SuballocatedIntVector dtmIds = null;
        if (dom instanceof DTMDefaultBase) {
            DTMDefaultBase dtmdb = (DTMDefaultBase)dom;
            dtmIds = dtmdb.getDTMIDs();
            dtmSize = dtmIds.size();
            domNo = dtmIds.elementAt(dtmSize-1) >>> DTMManager.IDENT_DTM_NODE_BITS;
        }
        else if (dom instanceof SimpleResultTreeImpl) {
            SimpleResultTreeImpl simpleRTF = (SimpleResultTreeImpl)dom;
            domNo = simpleRTF.getDocument() >>> DTMManager.IDENT_DTM_NODE_BITS;
        }
                  
        if (domNo >= _size) {
            int oldSize = _size;
            do {
            	_size *= 2;
            } while (_size <= domNo);
            
            final DOMAdapter[] newArray = new DOMAdapter[_size];
            System.arraycopy(_adapters, 0, newArray, 0, oldSize);
            _adapters = newArray;
        }
        
        _free = domNo + 1;
        
        if (dtmSize == 1) {
            _adapters[domNo] = adapter;
        }
        else if (dtmIds != null) {
            int domPos = 0;
            for (int i = dtmSize - 1; i >= 0; i++) {
                domPos = dtmIds.elementAt(i) >>> DTMManager.IDENT_DTM_NODE_BITS;
                _adapters[domPos] = adapter;
            }
            domNo = domPos;
        }

        
        if (indexByURI) {
            String uri = adapter.getDocumentURI(0);
            _documents.put(uri, new Integer(domNo));
        }
        
        
        
        
        if (dom instanceof AdaptiveResultTreeImpl) {
            AdaptiveResultTreeImpl adaptiveRTF = (AdaptiveResultTreeImpl)dom;
            DOM nestedDom = adaptiveRTF.getNestedDOM();
            if (nestedDom != null) {
                DOMAdapter newAdapter = new DOMAdapter(nestedDom, 
                                                       adapter.getNamesArray(),
                                                       adapter.getNamespaceArray());
                addDOMAdapter(newAdapter);  
            } 
        }
        
        return domNo;
    }
        
    public int getDocumentMask(String uri) {
        Integer domIdx = (Integer)_documents.get(uri);
        if (domIdx == null) {
            return(-1);
        } else {
            return domIdx.intValue();
        }
    }
    
    public DOM getDOMAdapter(String uri) {
        Integer domIdx = (Integer)_documents.get(uri);
        if (domIdx == null) {
            return(null);
        } else {
            return(_adapters[domIdx.intValue()]);
        }
    }
    
    public int getDocument() 
    {
        return _main.getDocument();
    }

    
    public DTMAxisIterator getIterator() {
        
        return _main.getIterator();
    }
    
    public String getStringValue() {
        return _main.getStringValue();
    }
    
    public DTMAxisIterator getChildren(final int node) {
        return _adapters[getDTMId(node)].getChildren(node);
    }
    
    public DTMAxisIterator getTypedChildren(final int type) {
        return new AxisIterator(Axis.CHILD, type);
    }
    
    public DTMAxisIterator getAxisIterator(final int axis) {
        return new AxisIterator(axis, NO_TYPE);
    }
    
    public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)
    {
        return new AxisIterator(axis, type);
    }

    public DTMAxisIterator getNthDescendant(int node, int n,
                                            boolean includeself)
    {
        return _adapters[getDTMId(node)].getNthDescendant(node, n, includeself);
    }

    public DTMAxisIterator getNodeValueIterator(DTMAxisIterator iterator,
                                                int type, String value,
                                                boolean op)
    {
        return(new NodeValueIterator(iterator, type, value, op));
    }

    public DTMAxisIterator getNamespaceAxisIterator(final int axis,
                                                    final int ns)
    {
        DTMAxisIterator iterator = _main.getNamespaceAxisIterator(axis, ns);
        return(iterator);        
    }

    public DTMAxisIterator orderNodes(DTMAxisIterator source, int node) {
        return _adapters[getDTMId(node)].orderNodes(source, node);
    }

    public int getExpandedTypeID(final int node) {
    	if (node != DTM.NULL) {
            return _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].getExpandedTypeID(node);
    	}
    	else {
    	    return DTM.NULL;
    	}
    }

    public int getNamespaceType(final int node) {
        return _adapters[getDTMId(node)].getNamespaceType(node);
    }
    
    public int getNSType(int node)
   {
        return _adapters[getDTMId(node)].getNSType(node);
   }
    
    public int getParent(final int node) {
        if (node == DTM.NULL) {
            return DTM.NULL;
        }
        return _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].getParent(node);
    }
    
    public int getAttributeNode(final int type, final int el) {
        if (el == DTM.NULL) {
            return DTM.NULL;
        }
        return _adapters[el >>> DTMManager.IDENT_DTM_NODE_BITS].getAttributeNode(type, el);
    }
    
    public String getNodeName(final int node) {
        if (node == DTM.NULL) {
            return """";
        }
        return _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].getNodeName(node);
    }
    
    public String getNodeNameX(final int node) {
        if (node == DTM.NULL) {
            return """";
        }
        return _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].getNodeNameX(node);
    }

    public String getNamespaceName(final int node) {
        if (node == DTM.NULL) {
            return """";
        }
        return _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].getNamespaceName(node);
    }
    
    public String getStringValueX(final int node) {
        if (node == DTM.NULL) {
            return """";
        }
        return _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].getStringValueX(node);
    }
    
    public void copy(final int node, SerializationHandler handler)
        throws TransletException
    {
        if (node != DTM.NULL) {
            _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].copy(node, handler);
        }
    }
    
    public void copy(DTMAxisIterator nodes, SerializationHandler handler)
            throws TransletException
    {
        int node;
        while ((node = nodes.next()) != DTM.NULL) {
            _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].copy(node, handler);
        }
    }


    public String shallowCopy(final int node, SerializationHandler handler)
            throws TransletException
    {
        if (node == DTM.NULL) {
            return """";
        }
        return _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].shallowCopy(node, handler);
    }
    
    public boolean lessThan(final int node1, final int node2) {
        if (node1 == DTM.NULL) {
            return true;
        }
        if (node2 == DTM.NULL) {
            return false;
        }
        final int dom1 = getDTMId(node1);
        final int dom2 = getDTMId(node2);
        return dom1 == dom2 ? _adapters[dom1].lessThan(node1, node2)
                            : dom1 < dom2;
    }
    
    public void characters(final int textNode, SerializationHandler handler)
                 throws TransletException
    {
        if (textNode != DTM.NULL) {
            _adapters[textNode >>> DTMManager.IDENT_DTM_NODE_BITS].characters(textNode, handler);
        }
    }

    public void setFilter(StripFilter filter) {
        for (int dom=0; dom<_free; dom++) {
            if (_adapters[dom] != null) {
                _adapters[dom].setFilter(filter);
            }
        }
    }

    public Node makeNode(int index) {
        if (index == DTM.NULL) {
            return null;
        }
        return _adapters[getDTMId(index)].makeNode(index);
    }

    public Node makeNode(DTMAxisIterator iter) {
        
        return _main.makeNode(iter);
    }

    public NodeList makeNodeList(int index) {
        if (index == DTM.NULL) {
            return null;
        }
        return _adapters[getDTMId(index)].makeNodeList(index);
    }

    public NodeList makeNodeList(DTMAxisIterator iter) {
        
        return _main.makeNodeList(iter);
    }

    public String getLanguage(int node) {
        return _adapters[getDTMId(node)].getLanguage(node);
    }

    public int getSize() {
        int size = 0;
        for (int i=0; i<_size; i++) {
            size += _adapters[i].getSize();
        }
        return(size);
    }

    public String getDocumentURI(int node) {
        if (node == DTM.NULL) {
            node = DOM.NULL;
        }
        return _adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].getDocumentURI(0);
    }

    public boolean isElement(final int node) {
        if (node == DTM.NULL) {
            return false;
        }
        return(_adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].isElement(node));
    }

    public boolean isAttribute(final int node) {
        if (node == DTM.NULL) {
            return false;
        }
        return(_adapters[node >>> DTMManager.IDENT_DTM_NODE_BITS].isAttribute(node));
    }
    
    public int getDTMId(int nodeHandle)
    {
        if (nodeHandle == DTM.NULL)
            return 0;
        
        int id = nodeHandle >>> DTMManager.IDENT_DTM_NODE_BITS;
        while (id >= 2 && _adapters[id] == _adapters[id-1]) {
            id--;
        }
        return id;
    }
    
    public int getNodeIdent(int nodeHandle)
    {
        return _adapters[nodeHandle >>> DTMManager.IDENT_DTM_NODE_BITS].getNodeIdent(nodeHandle);
    }
    
    public int getNodeHandle(int nodeId)
    {
        return _main.getNodeHandle(nodeId);
    }
    
    public DOM getResultTreeFrag(int initSize, int rtfType)
    {
        return _main.getResultTreeFrag(initSize, rtfType);
    }
    
    public DOM getMain()
    {
        return _main;
    }
    
    
    public SerializationHandler getOutputDomBuilder()
    {
        return _main.getOutputDomBuilder();
    }

    public String lookupNamespace(int node, String prefix) 
        throws TransletException
    {
        return _main.lookupNamespace(node, prefix);
    }

    
    public String getUnparsedEntityURI(String entity) {
        return _main.getUnparsedEntityURI(entity);
    }

    
    public Hashtable getElementsWithIDs() {
        return _main.getElementsWithIDs();
    }
}
"
org.apache.xalan.serialize.SerializerFactory,2,1,0,4,5,1,0,4,1,2.0,15,0.0,0,0.0,0.5,0,0,6.5,1,0.5,0,"
package org.apache.xalan.serialize;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.util.Properties;

import org.w3c.dom.Node;
import org.xml.sax.ContentHandler;


public abstract class SerializerFactory
{

    private SerializerFactory()
    {
    }
    
    public static Serializer getSerializer(Properties format)
    {
        org.apache.xml.serializer.Serializer ser;
        ser = org.apache.xml.serializer.SerializerFactory.getSerializer(format);
        SerializerFactory.SerializerWrapper si = new SerializerWrapper(ser);
        return si;

    }
    
    

    private static class SerializerWrapper implements Serializer
    {
        private final org.apache.xml.serializer.Serializer m_serializer;
        private DOMSerializer m_old_DOMSerializer;

        SerializerWrapper(org.apache.xml.serializer.Serializer ser)
        {
            m_serializer = ser;

        }

        public void setOutputStream(OutputStream output)
        {
            m_serializer.setOutputStream(output);
        }

        public OutputStream getOutputStream()
        {
            return m_serializer.getOutputStream();
        }

        public void setWriter(Writer writer)
        {
            m_serializer.setWriter(writer);
        }

        public Writer getWriter()
        {
            return m_serializer.getWriter();
        }

        public void setOutputFormat(Properties format)
        {
            m_serializer.setOutputFormat(format);
        }

        public Properties getOutputFormat()
        {
            return m_serializer.getOutputFormat();
        }

        public ContentHandler asContentHandler() throws IOException
        {
            return m_serializer.asContentHandler();
        }

        
        public DOMSerializer asDOMSerializer() throws IOException
        {
            if (m_old_DOMSerializer == null)
            {
                m_old_DOMSerializer =
                    new DOMSerializerWrapper(m_serializer.asDOMSerializer());
            }
            return m_old_DOMSerializer;
        }
        
        public boolean reset()
        {
            return m_serializer.reset();
        }

    }

    
    private static class DOMSerializerWrapper implements DOMSerializer
    {
        private final org.apache.xml.serializer.DOMSerializer m_dom;
        DOMSerializerWrapper(org.apache.xml.serializer.DOMSerializer domser)
        {
            m_dom = domser;
        }

        public void serialize(Node node) throws IOException
        {
            m_dom.serialize(node);
        }
    }

}
"
org.apache.xml.res.XMLErrorResources_de,3,4,0,1,4,1,0,1,2,1.3,875,0.0,0,0.976190476,1.0,0,0,289.0,1,0.3333,0,"
package org.apache.xml.res;



public class XMLErrorResources_de extends XMLErrorResources
{

  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },

  


  {
    ER_FUNCTION_NOT_SUPPORTED, ""Funktion nicht unterstützt!""},
 
  
 

  {
    ER_CANNOT_OVERWRITE_CAUSE,
			""Ursache für nicht mögliches Überschreiben""},
  
   
  

  {
    ER_NO_DEFAULT_IMPL,
         ""Keine Standardimplementierung gefunden""},
  
   
  

  {
    ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
       ""ChunkedIntArray({0}) zurzeit nicht unterstützt""},
  
   
  

  {
    ER_OFFSET_BIGGER_THAN_SLOT,
       ""Offset größer als Slot""},
  
   
  

  {
    ER_COROUTINE_NOT_AVAIL,
       ""Coroutine nicht verfügbar, ID={0}""},
  
   
  

  {
    ER_COROUTINE_CO_EXIT,
       ""CoroutineManager empfing Anforderung co_exit()""},
  
   
  

  {
    ER_COJOINROUTINESET_FAILED,
       ""co_joinCoroutineSet() fehlgeschlagen""},
  
   
  

  {
    ER_COROUTINE_PARAM,
       ""Parameterfehler in Coroutine ({0})""},
  
   
  

  {
    ER_PARSER_DOTERMINATE_ANSWERS,
       ""
UNEXPECTED: Parser doTerminate antwortet {0}""},
  
   
  

  {
    ER_NO_PARSE_CALL_WHILE_PARSING,
       ""parse darf während des Parsens nicht aufgerufen werden""},
  
   
  

  {
    ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""Fehler: Typisierter Iterator für Achse {0} nicht implementiert""},
  
   
  

  {
    ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""Fehler: Iterator für Achse {0} nicht implementiert""},
  
   
  

  {
    ER_ITERATOR_CLONE_NOT_SUPPORTED,
       ""Iterator-Klone nicht unterstützt""},
  
   
  

  {
    ER_UNKNOWN_AXIS_TYPE,
       ""Unbekannter Achsen-Traversaltyp: {0}""},
  
   
  

  {
    ER_AXIS_NOT_SUPPORTED,
       ""Achsen-Traverser nicht unterstützt: {0}""},
  
   
  

  {
    ER_NO_DTMIDS_AVAIL,
       ""Keine weiteren DTM-IDs verfügbar""},
  
   
  

  {
    ER_NOT_SUPPORTED,
       ""Nicht unterstützt: {0}""},
  
   
  

  {
    ER_NODE_NON_NULL,
       ""Knoten darf für getDTMHandleFromNode nicht Null sein""},
  
   
  

  {
    ER_COULD_NOT_RESOLVE_NODE,
       ""Der Knoten zu einem Handle konnte nicht aufgelöst werden""},
  
   
  

  {
    ER_STARTPARSE_WHILE_PARSING,
       ""startParse darf beim Parsen nicht aufgerufen werden""},
  
   
  

  {
    ER_STARTPARSE_NEEDS_SAXPARSER,
       ""startParse benötigt einen SAXParser, der nicht Null ist""},
  
   
  

  {
    ER_COULD_NOT_INIT_PARSER,
       ""Parser konnte nicht initialisiert werden""},

   
  

  {
    ER_EXCEPTION_CREATING_POOL,
       ""Ausnahme, die neue Instanz für Pool erstellt""},
  
   
  

  {
    ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
       ""Pfad enthält ungültige Escape-Sequenz""},
  
   
  

  {
    ER_SCHEME_REQUIRED,
       ""Schema ist erforderlich!""},
  
   
  

  {
    ER_NO_SCHEME_IN_URI,
       ""Kein Schema gefunden in URI: {0}""},
  
   
  

  {
    ER_NO_SCHEME_INURI,
       ""Kein Schema gefunden in URI""},
  
   
  

  {
    ER_PATH_INVALID_CHAR,
       ""Pfad enthält ungültiges Zeichen: {0}""},
  
   
  

  {
    ER_SCHEME_FROM_NULL_STRING,
       ""Schema kann ausgehend von Null-Zeichenkette nicht gesetzt werden""},
  
   
  

  {
    ER_SCHEME_NOT_CONFORMANT,
       ""Schema ist nicht konform.""},
  
   
  

  {
    ER_HOST_ADDRESS_NOT_WELLFORMED,
       ""Hostadresse nicht korrekt gebildet""},
  
   
  

  {
    ER_PORT_WHEN_HOST_NULL,
       ""Port kann nicht gesetzt werden, wenn Host Null ist""},
  
   
  

  {
    ER_INVALID_PORT,
       ""Ungültige Port-Nummer""},
  
   
  

  {
    ER_FRAG_FOR_GENERIC_URI,
       ""Fragment kann nur für einen generischen URI gesetzt werden""},
  
   
  

  {
    ER_FRAG_WHEN_PATH_NULL,
       ""Fragment kann nicht gesetzt werden, wenn der Pfad Null ist""},
  
   
  

  {
    ER_FRAG_INVALID_CHAR,
       ""Fragment enthält ungültiges Zeichen""},
  
 
  
   
  

  {
    ER_PARSER_IN_USE,
        ""Parser wird bereits verwendet""},
  
   
  

  {
    ER_CANNOT_CHANGE_WHILE_PARSING,
        ""{0} {1} kann beim Parsen nicht geändert werden""},
  
   
  

  {
    ER_SELF_CAUSATION_NOT_PERMITTED,
        ""Selbst-Kausalität nicht erlaubt""},
  
   
  

  {
    ER_NO_USERINFO_IF_NO_HOST,
        ""Userinfo kann nicht angegeben werden, wenn Host nicht angegeben ist""},
  
   
  

  {
    ER_NO_PORT_IF_NO_HOST,
        ""Port kann nicht angegeben werden, wenn Host nicht angegeben ist""},
  
   
  

  {
    ER_NO_QUERY_STRING_IN_PATH,
        ""Abfragezeichenkette kann nicht sowohl im Pfad als auch in der Abfragezeichenkette angegeben werden""},
  
   
  

  {
    ER_NO_FRAGMENT_STRING_IN_PATH,
        ""Fragment kann nicht sowohl im Pfad als auch im Fragment angegeben werden""},
  
   
  

  {
    ER_CANNOT_INIT_URI_EMPTY_PARMS,
        ""URI kann nicht mit leeren Parametern initialisiert werden""},

  
  

  {
    ER_METHOD_NOT_SUPPORTED,
        ""Methode noch nicht unterstützt ""},
 
  
  

  {
    ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
     ""IncrementalSAXSource_Filter kann zurzeit nicht neu gestartet werden""},
  
  
  

  {
    ER_XMLRDR_NOT_BEFORE_STARTPARSE,
     ""XMLReader nicht vor startParse-Anforderung""},
  
  
  
  {
    ER_AXIS_TRAVERSER_NOT_SUPPORTED,
     ""Achsen-Traverser nicht unterstützt: {0}""},

  
  
  {
    ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
     ""ListingErrorHandler wurde mit Null-PrintWriter erstellt!""},

  
  {
    ER_SYSTEMID_UNKNOWN,
     ""Unbekannte SystemId""},

  
  
  {
    ER_LOCATION_UNKNOWN,
     ""Fehler befindet sich an unbekannter Stelle""},

  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""Präfix muss sich in Namensraum auflösen lassen: {0}""},

  
  

  {
    ER_CREATEDOCUMENT_NOT_SUPPORTED,
      ""createDocument() in XpathContext nicht unterstützt!""},
   

  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT,
      ""Attribut-Tochterknoten hat kein Eigentümer-Dokument!""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
      ""Attribut-Tochterknoten hat kein Element Eigentümer-Dokument!""},


  
  


  {
    ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
      ""Warnung: Vor einem Dokumentelement kann kein Text ausgegeben werden! Wird ignoriert...""},


  
  


  {
    ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
      ""Ein DOM kann nur einen Stamm haben!""},

  
   
  


  {
    ER_ARG_LOCALNAME_NULL,
       ""Argument 'localName' ist Null""},

  
  
  

  
  


  {
    ER_ARG_LOCALNAME_INVALID,
       ""Der lokale Name in QNAME muss einem gültigen 'NCName' entsprechen.""},

  
  
  

  
  


  {
    ER_ARG_PREFIX_INVALID,
       ""Das Präfix in QNAME muss einem gültigen 'NCName' entsprechen.""},
       
  { ""BAD_CODE"", ""Parameter für createMessage außerhalb der Grenzwerte""},
  { ""FORMAT_FAILED"", ""Ausnahme bei messageFormat-Aufruf""},
  { ""line"", ""Zeile #""},
  { ""column"", ""Spalte #""}
  
  };

  
  public Object[][] getContents()
  {
    return contents;
  }
      
}"
org.apache.xalan.serialize.DOMSerializer,0,1,0,5,0,0,4,1,0,2.0,0,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"
package org.apache.xalan.serialize;



public interface DOMSerializer extends org.apache.xml.serializer.DOMSerializer
{

}
"
org.apache.xml.utils.RawCharacterHandler,1,1,0,0,1,0,0,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"
package org.apache.xml.utils;


public interface RawCharacterHandler
{

  
  public void charactersRaw(char ch[], int start, int length)
    throws javax.xml.transform.TransformerException;
}
"
org.apache.xalan.processor.ProcessorText,3,5,0,7,10,3,1,6,2,2.0,40,0.0,0,0.990697674,0.583333333,2,4,12.33333333,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemText;


public class ProcessorText extends ProcessorTemplateElem
{

  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    
    ProcessorCharacters charProcessor =
      (ProcessorCharacters) handler.getProcessorFor(null, ""text()"", ""text"");

    charProcessor.setXslTextElement((ElemText) elem);

    ElemTemplateElement parent = handler.getElemTemplateElement();

    parent.appendChild(elem);
    elem.setDOMBackPointer(handler.getOriginatingNode());
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    ProcessorCharacters charProcessor 
      = (ProcessorCharacters) handler.getProcessorFor(null, ""text()"", ""text"");

    charProcessor.setXslTextElement(null);

  }
}
"
org.apache.xalan.transformer.DecimalToRoman,1,1,0,2,2,0,2,0,1,2.0,20,0.0,0,0.0,1.0,0,0,15.0,0,0.0,1,"
package org.apache.xalan.transformer;


public class DecimalToRoman
{

  
  public DecimalToRoman(long postValue, String postLetter, long preValue,
                        String preLetter)
  {

    this.m_postValue = postValue;
    this.m_postLetter = postLetter;
    this.m_preValue = preValue;
    this.m_preLetter = preLetter;
  }

  
  public long m_postValue;

  
  public String m_postLetter;

  
  public long m_preValue;

  
  public String m_preLetter;
}
"
org.apache.xalan.xsltc.compiler.Comment,4,3,0,15,20,6,0,15,3,2.0,92,0.0,0,0.949152542,0.4,1,3,22.0,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class Comment extends Instruction {

    public void parseContents(Parser parser) {
	parseChildren(parser);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	typeCheckContents(stable);
	return Type.String;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	il.append(DUP);		

	
	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       ""stringValueHandler"",
					       STRING_VALUE_HANDLER_SIG)));
	il.append(DUP);
	il.append(methodGen.storeHandler());

	
	translateContents(classGen, methodGen);

	
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_VALUE_HANDLER,
						     ""getValue"",
						     ""()"" + STRING_SIG)));
	
	final int comment =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""comment"", 
				      ""("" + STRING_SIG + "")V"");
	il.append(new INVOKEINTERFACE(comment, 2));
	
	il.append(methodGen.storeHandler());
    }
}
"
org.apache.xalan.xsltc.compiler.Fallback,6,3,0,10,12,0,1,9,5,0.2,49,1.0,0,0.918032787,0.333333333,1,3,7.0,2,1.1667,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class Fallback extends Instruction {

    private boolean _active = false;

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_active) {
	    return(typeCheckContents(stable));
	}
	else {
	    return Type.Void;
	}
    }

    
    public void activate() {
	_active = true;
    }

    public String toString() {
	return(""fallback"");
    }

    
    public void parseContents(Parser parser) {
	if (_active) parseChildren(parser);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_active) translateContents(classGen, methodGen);
    }
}
"
org.apache.xpath.res.XPATHErrorResources_zh_CN,3,4,0,1,4,1,0,1,2,1.428571429,1872,0.0,0,0.976190476,1.0,0,0,618.3333333,1,0.3333,1,"
package org.apache.xpath.res;


public class XPATHErrorResources_zh_CN extends XPATHErrorResources
{


  
  public static final int MAX_CODE = 108;  

  
  public static final int MAX_WARNING = 11;  

  
  public static final int MAX_OTHERS = 20;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  
  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_CURRENT_NOT_ALLOWED_IN_MATCH,
      ""匹配模式中不允许使用 current() 函数！""},


  
  


  {
    ER_CURRENT_TAKES_NO_ARGS,
      ""current() 函数不接受变量！""},


  
  


  {
    ER_DOCUMENT_REPLACED,
      ""document() 函数工具已被 org.apache.xalan.xslt.FuncDocument 替代！""},


  
  


  {
    ER_CONTEXT_HAS_NO_OWNERDOC,
      ""上下文没有属主文档！""},


  
  


  {
    ER_LOCALNAME_HAS_TOO_MANY_ARGS,
      ""local-name() 的变量太多。""},


  
  


  {
    ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
      ""namespace-uri() 的变量太多。""},


  
  


  {
    ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
      ""normalize-space() 的变量太多。""},


  
  


  {
    ER_NUMBER_HAS_TOO_MANY_ARGS,
      ""number() 的变量太多。""},


  
  


  {
    ER_NAME_HAS_TOO_MANY_ARGS, ""name() 的变量太多。""},


  
  


  {
    ER_STRING_HAS_TOO_MANY_ARGS,
      ""string() 的变量太多。""},


  
  


  {
    ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
      ""string-length() 的变量太多。""},


  
  


  {
    ER_TRANSLATE_TAKES_3_ARGS,
      ""translate() 函数使用三个变量！""},


  
  


  {
    ER_UNPARSEDENTITYURI_TAKES_1_ARG,
      ""unparsed-entity-uri 函数应使用一个变量！""},


  
  


  {
    ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
      ""仍未实现名称空间轴！""},


  
  


  {
    ER_UNKNOWN_AXIS, ""未知轴：{0}""},


  
  


  {
    ER_UNKNOWN_MATCH_OPERATION, ""匹配操作未知！""},


  
  


  {
    ER_INCORRECT_ARG_LENGTH,
      ""processing-instruction() 节点的变量长度测试不正确！""},


  
  


  {
    ER_CANT_CONVERT_TO_NUMBER,
      ""不能将 {0} 转换为一个数字""},


  
  


  {
    ER_CANT_CONVERT_TO_NODELIST,
      ""不能将 {0} 转换为一个 NodeList！""},


  
  


  {
    ER_CANT_CONVERT_TO_MUTABLENODELIST,
      ""不能将 {0} 转换为一个 NodeSetDTM！""},


  
  


  {
    ER_CANT_CONVERT_TO_TYPE,
      ""不能将 {0} 转换为一个 type


  
  


  {
    ER_EXPECTED_MATCH_PATTERN,
      ""getMatchScore 中预期的匹配模式！""},


  
  


  {
    ER_COULDNOT_GET_VAR_NAMED,
      ""无法获得命名的变量 {0}""},


  
  


  {
    ER_UNKNOWN_OPCODE, ""错误！op 代码未知：{0}""},


  
  


  {
    ER_EXTRA_ILLEGAL_TOKENS, ""额外的非法标记：{0}""},


  
  


  {
    ER_EXPECTED_DOUBLE_QUOTE,
      ""错误引用文字... 预期的双引用！""},


  
  


  {
    ER_EXPECTED_SINGLE_QUOTE,
      ""错误引用文字... 预期的单引用！""},


  
  


  {
    ER_EMPTY_EXPRESSION, ""空表达式！""},


  
  


  {
    ER_EXPECTED_BUT_FOUND, ""预期的 {0}，但发现：{1}""},


  
  


  {
    ER_INCORRECT_PROGRAMMER_ASSERTION,
      ""程序员断言是错误的！- {0}""},


  
  


  {
    ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
      ""19990709 XPath 草稿不再可选用 boolean(...) 变量。""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
      ""已找到 ','，但未找到前述变量！""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
      ""已找到 ','，但未找到以下变量！""},


  
  


  {
    ER_PREDICATE_ILLEGAL_SYNTAX,
      ""'..[predicate]' 或 '.[predicate]' 是非法语法。请改用 'self::node()[predicate]'。""},


  
  


  {
    ER_ILLEGAL_AXIS_NAME, ""非法的轴名称：{0}""},


  
  


  {
    ER_UNKNOWN_NODETYPE, ""未知的节点类型：{0}""},


  
  


  {
    ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
      ""需要引用模式文字 ({0})！""},


  
  


  {
    ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
      ""不能将 {0} 格式化为一个数字！""},


  
  


  {
    ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
      ""不能创建 XML TransformerFactory Liaison：{0}""},


  
  


  {
    ER_DIDNOT_FIND_XPATH_SELECT_EXP,
      ""错误！未找到 xpath select 表达式 (-select)。""},


  
  


  {
    ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
      ""错误！未在 OP_LOCATIONPATH 后找到 ENDOP""},


  
  


  {
    ER_ERROR_OCCURED, ""出错！""},


  
  


  {
    ER_ILLEGAL_VARIABLE_REFERENCE,
      ""为变量给出的 VariableReference 超出了上下文范围或没有定义！名称 = {0}""},


  
  


  {
    ER_AXES_NOT_ALLOWED,
      ""匹配模式中仅允许使用 child:: 和 attribute:: 轴！违例轴 = {0}""},


  
  


  {
    ER_KEY_HAS_TOO_MANY_ARGS,
      ""key() 有许多不正确的变量。""},


  
  


  {
    ER_COUNT_TAKES_1_ARG,
      ""count 函数应使用一个变量！""},


  
  


  {
    ER_COULDNOT_FIND_FUNCTION, ""未找到函数：{0}""},


  
  


  {
    ER_UNSUPPORTED_ENCODING, ""不受支持的编码：{0}""},


  
  


  {
    ER_PROBLEM_IN_DTM_NEXTSIBLING,
      ""getNextSibling 中的 DTM 出现问题 ... 正在尝试恢复""},


  
  


  {
    ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
      ""程序员出错：不能将 EmptyNodeList 写入。""},


  
  


  {
    ER_SETDOMFACTORY_NOT_SUPPORTED,
      ""setDOMFactory 不受 XPathContext 支持！""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""必须解决名称空间的前缀：{0}""},


  
  


  {
    ER_PARSE_NOT_SUPPORTED,
      ""XPathContext 中不支持（语法）分析器（InputSource 源）！无法打开 {0}""},


  
  


  {
    ER_SAX_API_NOT_HANDLED,
      ""SAX API characters(char ch[]... 不由 DTM 处理！""},


  
  


  {
    ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
      ""ignorableWhitespace(char ch[]... 不由 DTM 处理！""},


  
  


  {
    ER_DTM_CANNOT_HANDLE_NODES,
      ""DTMLiaison 无法处理节点类型 {0}""},


  
  


  {
    ER_XERCES_CANNOT_HANDLE_NODES,
      ""DOM2Helper 无法处理节点类型 {0}""},


  
  


  {
    ER_XERCES_PARSE_ERROR_DETAILS,
      ""DOM2Helper.parse 错误：SystemID - {0} line - {1}""},


  
  


  {
    ER_XERCES_PARSE_ERROR, ""DOM2Helper.parse 错误""},


  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""检测到无效的 UTF-16 surrogate：{0} ?""},


  
  


  {
    ER_OIERROR, ""IO 错误""},


  
  


  {
    ER_CANNOT_CREATE_URL, ""无法创建 url 为：{0}""},


  
  


  {
    ER_XPATH_READOBJECT, ""在 XPath.readObject 中：{0}""},

  
  
  


  {
    ER_FUNCTION_TOKEN_NOT_FOUND,
      ""未找到函数标记。""},

  
   
  


  {
    ER_CANNOT_DEAL_XPATH_TYPE,
       ""无法处理 XPath 类型：{0}""},

  
   
  


  {
    ER_NODESET_NOT_MUTABLE,
       ""此 NodeSet 不易变""},

  
   
  


  {
    ER_NODESETDTM_NOT_MUTABLE,
       ""此 NodeSetDTM 不易变""},

  
   
  


  {
    ER_VAR_NOT_RESOLVABLE,
        ""变量不可分解：{0}""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""错误处理器无效""},

  
   
  


  {
    ER_PROG_ASSERT_UNKNOWN_OPCODE,
       ""程序员断言：opcode 未知：{0}""},

  
   
  


  {
    ER_ZERO_OR_ONE,
       ""0 或 1""},

  
   
  


  {
    ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""rtf() 不受 XRTreeFragSelectWrapper 支持""},

  
   
  


  {
    ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""asNodeIterator() 不受 XRTreeFragSelectWrapper 支持""},

  
   
  


  {
    ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
       ""fsb() 不支持 XStringForChars""},

  
   
  


  {
    ER_COULD_NOT_FIND_VAR,
      ""无法找到名称为 {0} 的变量""},

  
   
  


  {
    ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
      ""XStringForChars 无法使用变量的一个字符串""},

  
   
  


  {
    ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
      ""FastStringBuffer 变量不能为空""},
    
   
  
  

  {
    ER_TWO_OR_THREE,
       ""2 或 3""},

  
   
  
  

  {
    ER_VARIABLE_ACCESSED_BEFORE_BIND,
       ""绑定之前访问了变量！""},


   
  


  {
    ER_FSB_CANNOT_TAKE_STRING,
       ""XStringForFSB 无法接受字符串类型的变量！""},


   
  


  {
    ER_SETTING_WALKER_ROOT_TO_NULL,
       ""
 !!!! 错误！遍历程序的根设置为空!!!""},


   
  


  {
    ER_NODESETDTM_CANNOT_ITERATE,
       ""此 NodeSetDTM 无法迭代到前一个节点！""},


  
  


  {
    ER_NODESET_CANNOT_ITERATE,
       ""此 NodeSet 无法迭代到前一个节点！""},


  
  


  {
    ER_NODESETDTM_CANNOT_INDEX,
       ""此 NodeSetDTM 无法为函数建立索引或计算个数！""},


  
  


  {
    ER_NODESET_CANNOT_INDEX,
       ""此 NodeSet 无法为函数建立索引或计算个数！""},


  
  


  {
    ER_CANNOT_CALL_SETSHOULDCACHENODE,
       ""调用 nextNode 后无法调用 setShouldCacheNodes！""},


  
  


  {
    ER_ONLY_ALLOWS,
       ""{0} 仅允许 {1} 变量""},


  
  


  {
    ER_UNKNOWN_STEP,
       ""getNextStepPos 中的程序员声明：未知的 stepType：{0}""},


  
  
  

  
  


  {
    ER_EXPECTED_REL_LOC_PATH,
       ""“/”或“


  
  
  

  
  


  {
    ER_EXPECTED_LOC_PATH,
       ""需要位置路径，但遇到以下标记:  {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_LOC_STEP,
       ""“/”或“


  
  
  
  

  
  


  {
    ER_EXPECTED_NODE_TEST,
       ""需要与 NCName:* 或 QName 匹配的节点测试。""},


  
  
  

  
  


  {
    ER_EXPECTED_STEP_PATTERN,
       ""需要步骤模式，但遇到“/”。""},


  
  
  
 
  
  


  {
    ER_EXPECTED_REL_PATH_PATTERN,
       ""需要相对路径模式。""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_BOOLEAN,
       ""无法将 {0} 转换成布尔值。""},


  
  

  
  


  {
    ER_CANT_CONVERT_TO_SINGLENODE,
       ""无法将 {0} 转换成单节点。此获取程序适用于 ANY_UNORDERED_NODE_TYPE 和 FIRST_ORDERED_NODE_TYPE 类型。""},


  
  

  
  


  {
    ER_CANT_GET_SNAPSHOT_LENGTH,
       ""无法获取类型 {0} 上的快照长度。此获取程序适用于 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 类型。""},


  
  


  {
    ER_NON_ITERATOR_TYPE,
       ""无法迭代非叠代器类型：{0}""},


  
  
  

  
  


  {
    ER_DOC_MUTATED,
       ""由于结果的返回使文档发生改变。叠代器无效。""},


  
  


  {
    ER_INVALID_XPATH_TYPE,
       ""无效 XPath 类型变量：{0}""},


  
  


  {
    ER_EMPTY_XPATH_RESULT,
       ""空的 XPath 结果对象""},


  
  


  {
    ER_INCOMPATIBLE_TYPES,
       ""返回类型：{0} 无法强制转换成指定的类型：{1}""},


  
  


  {
    ER_NULL_RESOLVER,
       ""无法用空的前缀解决器来解决前缀。""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_STRING,
       ""无法将 {0} 转换成字符串。""},


  
  

  
  


  {
    ER_NON_SNAPSHOT_TYPE,
       ""无法对类型 {0} 调用 snapshotItem。此方法适用于 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 类型。""},


  
  
  
  

  
  


  {
    ER_WRONG_DOCUMENT,
       ""上下文节点不属于绑定到此 XPathEvaluator 的文档。""},


  
  
  
  


  {
    ER_WRONG_NODETYPE ,
       ""上下文节点类型不受支持。""},


  
  


  {
    ER_XPATH_ERROR ,
       ""XPath 中出现未知错误。""},



  


  

  
  


  {
    WG_LOCALE_NAME_NOT_HANDLED,
      ""仍未处理 format-number 函数中的语言环境名称！""},


  
  


  {
    WG_PROPERTY_NOT_SUPPORTED,
      ""不受支持的 XSL Property：{0}""},


  
  


  {
    WG_DONT_DO_ANYTHING_WITH_NS,
      ""当前不要对属性中的名称空间 {0} 执行任何操作：{1}""},


  
  


  {
    WG_SECURITY_EXCEPTION,
      ""尝试访问 XSL 系统属性时，SecurityException：{0}""},


  
  


  {
    WG_QUO_NO_LONGER_DEFINED,
      ""旧语法：XPath 中不再定义 quo(...)。""},


  
  


  {
    WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
      ""XPath 需要由一个派生对象来执行 nodeTest！""},


  
  


  {
    WG_FUNCTION_TOKEN_NOT_FOUND,
      ""未找到函数标记。""},


  
  


  {
    WG_COULDNOT_FIND_FUNCTION,
      ""无法找到函数：{0}""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""无法得到 URL 自：{0}""},


  
  


  {
    WG_EXPAND_ENTITIES_NOT_SUPPORTED,
      ""-E 选项不支持 DTM（语法）分析器""},


  
  


  {
    WG_ILLEGAL_VARIABLE_REFERENCE,
      ""为变量给出的 VariableReference 超出了上下文范围或没有定义！名称 = {0}""},


  
  


  {
    WG_UNSUPPORTED_ENCODING, ""不受支持的编码：{0}""},


  
  { ""ui_language"", ""zh""},
  { ""help_language"", ""zh""},
  { ""language"", ""zh""},
    { ""BAD_CODE"",
      ""createMessage 参数超出了范围""},
    { ""FORMAT_FAILED"",
      ""messageFormat 调用期间提出了例外""},
    { ""version"", "">>>>>>> Xalan 版本""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""是""},
    { ""line"", ""行 
    { ""column"", ""列 
    { ""xsldone"", ""XSLProcessor：已完成""},
    { ""xpath_option"", ""xpath 选项：""},
    { ""optionIN"", ""   [-in inputXMLURL]""},
    { ""optionSelect"", ""   [-select xpath expression]""},
    { ""optionMatch"",
      ""   [-match match pattern (for match diagnostics)]""},
    { ""optionAnyExpr"",
      ""或者只有 xpath 表达式将执行诊断转储""},
    { ""noParsermsg1"", ""XSL Process 未成功。""},
    { ""noParsermsg2"",
    ""** 无法找到（语法）分析器 **""},
    { ""noParsermsg3"",
    ""请检查您的类路径。""},
    { ""noParsermsg4"",
      ""如果您没有 IBM 的 XML Parser for Java，则可以下载其自""},
    { ""noParsermsg5"",
      ""IBM's AlphaWorks: http:
  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""

  
  public static final String ERROR_HEADER = ""错误："";

  
  public static final String WARNING_HEADER = ""警告："";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}

"
org.apache.xalan.xsltc.compiler.PositionCall,3,4,0,13,12,3,1,12,3,2.0,55,0.0,0,0.979591837,0.5,2,4,17.33333333,3,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.CompareGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.TestGenerator;

final class PositionCall extends FunctionCall {

    public PositionCall(QName fname) {
	super(fname);
    }

    public boolean hasPositionCall() {
	return true;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();

	if (methodGen instanceof CompareGenerator) {
	    il.append(((CompareGenerator)methodGen).loadCurrentNode());
	}
	else if (methodGen instanceof TestGenerator) {
	    il.append(new ILOAD(POSITION_INDEX));
	}
	else {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
            final int index =
                    cpg.addMethodref(BASIS_LIBRARY_CLASS, ""positionF"",
                                     ""(""+NODE_ITERATOR_SIG+"")I"");

	    il.append(methodGen.loadIterator());
            il.append(new INVOKESTATIC(index));
	}
    }
}
"
org.apache.xalan.templates.ElemVariablePsuedo,3,4,0,8,9,1,1,7,3,0.5,26,0.0,1,0.99086758,0.555555556,0,0,7.333333333,1,0.6667,0,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPath;

public class ElemVariablePsuedo extends ElemVariable
{
  XUnresolvedVariableSimple m_lazyVar;
	
  
  public void setSelect(XPath v)
  {
    super.setSelect(v);
    m_lazyVar = new XUnresolvedVariableSimple(this);
  }
  
  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    
    

    
    transformer.getXPathContext().getVarStack().setLocalVariable(m_index, m_lazyVar);
  }

}

"
org.apache.xalan.templates.XSLTVisitor,9,2,1,20,10,36,19,6,1,2.0,28,0.0,0,0.6,0.314814815,0,0,2.111111111,1,0.8889,0,"
package org.apache.xalan.templates;

import org.apache.xpath.XPathVisitor;


public class XSLTVisitor extends XPathVisitor
{
	
	boolean visitInstruction(ElemTemplateElement elem)
	{
		return true;
	}
	
	
	boolean visitStylesheet(ElemTemplateElement elem)
	{
		return true;
	}

	
	
	boolean visitTopLevelInstruction(ElemTemplateElement elem)
	{
		return true;
	}
	
	
	boolean visitTopLevelVariableOrParamDecl(ElemTemplateElement elem)
	{
		return true;
	}

	
	
	boolean visitVariableOrParamDecl(ElemVariable elem)
	{
		return true;
	}
	
	
	boolean visitLiteralResultElement(ElemLiteralResult elem)
	{
		return true;
	}
	
	
	boolean visitAVT(AVT elem)
	{
		return true;
	}


	
	boolean visitExtensionElement(ElemExtensionCall elem)
	{
		return true;
	}

}

"
org.apache.xalan.xsltc.compiler.DocumentCall,3,4,0,21,26,0,0,21,3,0.166666667,246,1.0,3,0.979591837,0.444444444,3,14,80.0,4,1.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class DocumentCall extends FunctionCall {

    private Expression _uri = null;
    private Expression _base = null;
    private Type       _uriType;

    
    public DocumentCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	final int ac = argumentCount();
	if ((ac < 1) || (ac > 2)) {
	    ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_ARG_ERR, this);
	    throw new TypeCheckError(msg);
	}

	
	_uri = argument(0);
	if (_uri instanceof LiteralExpr) {
	    LiteralExpr expr = (LiteralExpr)_uri;
	    if (expr.getValue().equals(EMPTYSTRING)) {
		Stylesheet stylesheet = getStylesheet();
		if (stylesheet == null) {
		    ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_ARG_ERR, this);
		    throw new TypeCheckError(msg);
		}
		_uri = new LiteralExpr(stylesheet.getSystemId(), EMPTYSTRING);
	    }
	}

	_uriType = _uri.typeCheck(stable);
	if ((_uriType != Type.NodeSet) && (_uriType != Type.String)) {
	    _uri = new CastExpr(_uri, Type.String);
	}

	
	if (ac == 2) {
	    _base = argument(1);
	    final Type baseType = _base.typeCheck(stable);
	    
	    if (baseType.identicalTo(Type.Node)) {
		_base = new CastExpr(_base, Type.NodeSet);
	    }
	    else if (baseType.identicalTo(Type.NodeSet)) {
		
	    }
	    else {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.DOCUMENT_ARG_ERR, this);
		throw new TypeCheckError(msg);
	    }
	}

	return _type = Type.NodeSet;
    }
	
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final int domField = cpg.addFieldref(classGen.getClassName(),
					     DOM_FIELD,
					     DOM_INTF_SIG);
	final String docParamList =
	    ""(""+OBJECT_SIG+STRING_SIG+STRING_SIG+TRANSLET_SIG+DOM_INTF_SIG+"")""+
	    NODE_ITERATOR_SIG;
	final int docIdx = cpg.addMethodref(LOAD_DOCUMENT_CLASS,
					    ""document"", docParamList);

	final int uriIdx = cpg.addInterfaceMethodref(DOM_INTF,
						     ""getDocumentURI"",
						     ""(I)""+STRING_SIG);

	final int nextIdx = cpg.addInterfaceMethodref(NODE_ITERATOR,
						      NEXT, NEXT_SIG);

	
	_uri.translate(classGen, methodGen);
	if (_uriType == Type.NodeSet)
	    _uri.startResetIterator(classGen, methodGen);

	
	
	if (_base != null) {
		il.append(methodGen.loadDOM());
	    _base.translate(classGen, methodGen);
	    il.append(new INVOKEINTERFACE(nextIdx, 1));
	    il.append(new INVOKEINTERFACE(uriIdx, 2));
	}
	else {
		
		
		
		
		
		
		
		
	     
	     
	     
	     
	     if (_uriType == Type.NodeSet)
	     il.append(new PUSH(cpg,""""));
	     else
	     il.append(new PUSH(cpg, getStylesheet().getSystemId())); 	     
	}
	
	il.append(new PUSH(cpg, getStylesheet().getSystemId()));

	
	il.append(classGen.loadTranslet());
	il.append(DUP);
	il.append(new GETFIELD(domField));
	il.append(new INVOKESTATIC(docIdx));
    }

}
"
org.apache.xalan.xsltc.dom.Axis,1,1,0,7,1,0,6,1,0,2.0,62,0.0,0,0.0,0.0,0,0,60.0,0,0.0,0,"

package org.apache.xalan.xsltc.dom;



public interface Axis extends org.apache.xml.dtm.Axis
{
    public static final boolean[] isReverse = {
	true,  
	true,  
	false, 
	false, 
	false, 
	false, 
	false, 
	false, 
	false, 
	false, 
	false, 
	true,  
	true,  
	false  
    };
}
"
org.apache.xml.dtm.ref.IncrementalSAXSource_Filter,42,1,0,10,90,335,6,5,39,0.667917448,877,0.923076923,1,0.0,0.125396825,0,0,19.57142857,6,1.2857,0,"

package org.apache.xml.dtm.ref;

import java.io.IOException;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.ThreadControllerWrapper;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;
import org.xml.sax.ext.LexicalHandler;


public class IncrementalSAXSource_Filter
implements IncrementalSAXSource, ContentHandler, DTDHandler, LexicalHandler, ErrorHandler, Runnable
{
  boolean DEBUG=false; 

  
  
  
  private CoroutineManager fCoroutineManager = null;
  private int fControllerCoroutineID = -1;
  private int fSourceCoroutineID = -1;

  private ContentHandler clientContentHandler=null; 
  private LexicalHandler clientLexicalHandler=null; 
  private DTDHandler clientDTDHandler=null; 
  private ErrorHandler clientErrorHandler=null; 
  private int eventcounter;
  private int frequency=5;

  
  
  
  private boolean fNoMoreEvents=false;

  
  private XMLReader fXMLReader=null;
  private InputSource fXMLReaderInputSource=null;

  
  
  

  public IncrementalSAXSource_Filter() {
    this.init( new CoroutineManager(), -1, -1);
  }
  
  
  public IncrementalSAXSource_Filter(CoroutineManager co, int controllerCoroutineID)
  {
    this.init( co, controllerCoroutineID, -1 );
  }

  
  
  
  static public IncrementalSAXSource createIncrementalSAXSource(CoroutineManager co, int controllerCoroutineID) {
    return new IncrementalSAXSource_Filter(co, controllerCoroutineID);
  }

  
  
  

  public void init( CoroutineManager co, int controllerCoroutineID,
                    int sourceCoroutineID)
  {
    if(co==null)
      co = new CoroutineManager();
    fCoroutineManager = co;
    fControllerCoroutineID = co.co_joinCoroutineSet(controllerCoroutineID);
    fSourceCoroutineID = co.co_joinCoroutineSet(sourceCoroutineID);
    if (fControllerCoroutineID == -1 || fSourceCoroutineID == -1)
      throw new RuntimeException(XMLMessages.createXMLMessage(XMLErrorResources.ER_COJOINROUTINESET_FAILED, null)); 

    fNoMoreEvents=false;
    eventcounter=frequency;
  }
    
  
  public void setXMLReader(XMLReader eventsource)
  {
    fXMLReader=eventsource;
    eventsource.setContentHandler(this);
    eventsource.setDTDHandler(this);
    eventsource.setErrorHandler(this); 

    
    try 
    {
      eventsource.
        setProperty(""http:
                    this);
    }
    catch(SAXNotRecognizedException e)
    {
      
    }
    catch(SAXNotSupportedException e)
    {
      
    }

    
    
  }

  
  public void setContentHandler(ContentHandler handler)
  {
    clientContentHandler=handler;
  }
  
  public void setDTDHandler(DTDHandler handler)
  {
    clientDTDHandler=handler;
  }
  
  
  
  
  public void setLexicalHandler(LexicalHandler handler)
  {
    clientLexicalHandler=handler;
  }
  
  
  public void setErrHandler(ErrorHandler handler)
  {
    clientErrorHandler=handler;
  }

  
  
  public void setReturnFrequency(int events)
  {
    if(events<1) events=1;
    frequency=eventcounter=events;
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  public void characters(char[] ch, int start, int length)
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.characters(ch,start,length);
  }
  public void endDocument() 
       throws org.xml.sax.SAXException
  {
    
    if(clientContentHandler!=null)
      clientContentHandler.endDocument();

    eventcounter=0;     
    co_yield(false);
  }
  public void endElement(java.lang.String namespaceURI, java.lang.String localName,
      java.lang.String qName) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.endElement(namespaceURI,localName,qName);
  }
  public void endPrefixMapping(java.lang.String prefix) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.endPrefixMapping(prefix);
  }
  public void ignorableWhitespace(char[] ch, int start, int length) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.ignorableWhitespace(ch,start,length);
  }
  public void processingInstruction(java.lang.String target, java.lang.String data) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.processingInstruction(target,data);
  }
  public void setDocumentLocator(Locator locator) 
  {
    if(--eventcounter<=0)
      {
        
        
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.setDocumentLocator(locator);
  }
  public void skippedEntity(java.lang.String name) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.skippedEntity(name);
  }
  public void startDocument() 
       throws org.xml.sax.SAXException
  {
    co_entry_pause();

    
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.startDocument();
  }
  public void startElement(java.lang.String namespaceURI, java.lang.String localName,
      java.lang.String qName, Attributes atts) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.startElement(namespaceURI, localName, qName, atts);
  }
  public void startPrefixMapping(java.lang.String prefix, java.lang.String uri) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.startPrefixMapping(prefix,uri);
  }

  
  
  
  
  
  
  
  
  
  
  public void comment(char[] ch, int start, int length) 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.comment(ch,start,length);
  }
  public void endCDATA() 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.endCDATA();
  }
  public void endDTD() 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.endDTD();
  }
  public void endEntity(java.lang.String name) 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.endEntity(name);
  }
  public void startCDATA() 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.startCDATA();
  }
  public void startDTD(java.lang.String name, java.lang.String publicId,
      java.lang.String systemId) 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler. startDTD(name, publicId, systemId);
  }
  public void startEntity(java.lang.String name) 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.startEntity(name);
  }

  
  
  
  public void notationDecl(String a, String b, String c) throws SAXException
  {
  	if(null!=clientDTDHandler)
	  	clientDTDHandler.notationDecl(a,b,c);
  }
  public void unparsedEntityDecl(String a, String b, String c, String d)  throws SAXException
  {
  	if(null!=clientDTDHandler)
	  	clientDTDHandler.unparsedEntityDecl(a,b,c,d);
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  public void error(SAXParseException exception) throws SAXException
  {
    if(null!=clientErrorHandler)
      clientErrorHandler.error(exception);
  }
  
  public void fatalError(SAXParseException exception) throws SAXException
  {
    
    
    if(null!=clientErrorHandler)
      clientErrorHandler.error(exception);

    eventcounter=0;     
    co_yield(false);

  }
  
  public void warning(SAXParseException exception) throws SAXException
  {
    if(null!=clientErrorHandler)
      clientErrorHandler.error(exception);
  }
  

  
  
  

  public int getSourceCoroutineID() {
    return fSourceCoroutineID;
  }
  public int getControllerCoroutineID() {
    return fControllerCoroutineID;
  }

  
  public CoroutineManager getCoroutineManager()
  {
    return fCoroutineManager;
  }

  
  protected void count_and_yield(boolean moreExpected) throws SAXException
  {
    if(!moreExpected) eventcounter=0;
    
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
  }

  
  private void co_entry_pause() throws SAXException
  {
    if(fCoroutineManager==null)
    {
      
      init(null,-1,-1);
    }

    try
    {
      Object arg=fCoroutineManager.co_entry_pause(fSourceCoroutineID);
      if(arg==Boolean.FALSE)
        co_yield(false);
    }
    catch(NoSuchMethodException e)
    {
      
      
      if(DEBUG) e.printStackTrace();
      throw new SAXException(e);
    }
  }

  
  private void co_yield(boolean moreRemains) throws SAXException
  {
    
    if(fNoMoreEvents)
      return;

    try 
    {
      Object arg=Boolean.FALSE;
      if(moreRemains)
      {
        
        arg = fCoroutineManager.co_resume(Boolean.TRUE, fSourceCoroutineID,
                                          fControllerCoroutineID);
        
      }

      
      if(arg==Boolean.FALSE)
      {
        fNoMoreEvents=true;
        
        if(fXMLReader!=null)    
          throw new StopException(); 
        
        
        fCoroutineManager.co_exit_to(Boolean.FALSE, fSourceCoroutineID,
                                     fControllerCoroutineID);
      }
    }
    catch(NoSuchMethodException e)
    {
      
      
      fNoMoreEvents=true;
      fCoroutineManager.co_exit(fSourceCoroutineID);
      throw new SAXException(e);
    }
  }

  
  
  

  
  public void startParse(InputSource source) throws SAXException
  {
    if(fNoMoreEvents)
      throw new SAXException(XMLMessages.createXMLMessage(XMLErrorResources.ER_INCRSAXSRCFILTER_NOT_RESTARTABLE, null)); 
    if(fXMLReader==null)
      throw new SAXException(XMLMessages.createXMLMessage(XMLErrorResources.ER_XMLRDR_NOT_BEFORE_STARTPARSE, null)); 

    fXMLReaderInputSource=source;
    
    
    
    ThreadControllerWrapper.runThread(this, -1);
  }
  
  
  public void run()
  {
    
    if(fXMLReader==null) return;

    if(DEBUG)System.out.println(""IncrementalSAXSource_Filter parse thread launched"");

    
    Object arg=Boolean.FALSE;

    
    
    
    
    try
    {
      fXMLReader.parse(fXMLReaderInputSource);
    }
    catch(IOException ex)
    {
      arg=ex;
    }
    catch(StopException ex)
    {
      
      if(DEBUG)System.out.println(""Active IncrementalSAXSource_Filter normal stop exception"");
    }
    catch (SAXException ex)
    {
      Exception inner=ex.getException();
      if(inner instanceof StopException){
        
        if(DEBUG)System.out.println(""Active IncrementalSAXSource_Filter normal stop exception"");
      }
      else
      {
        
        if(DEBUG)
        {
          System.out.println(""Active IncrementalSAXSource_Filter UNEXPECTED SAX exception: ""+inner);
          inner.printStackTrace();
        }                
        arg=ex;
      }
    } 
    
    
    fXMLReader=null;

    try
    {
      
      fNoMoreEvents=true;
      fCoroutineManager.co_exit_to(arg, fSourceCoroutineID,
                                   fControllerCoroutineID);
    }
    catch(java.lang.NoSuchMethodException e)
    {
      
      
      e.printStackTrace(System.err);
      fCoroutineManager.co_exit(fSourceCoroutineID);
    }
  }

  
  class StopException extends RuntimeException
  {
  }

  
  public Object deliverMoreNodes(boolean parsemore)
  {
    
    if(fNoMoreEvents)
      return Boolean.FALSE;

    try 
    {
      Object result =
        fCoroutineManager.co_resume(parsemore?Boolean.TRUE:Boolean.FALSE,
                                    fControllerCoroutineID, fSourceCoroutineID);
      if(result==Boolean.FALSE)
        fCoroutineManager.co_exit(fControllerCoroutineID);

      return result;
    }
      
    
    
    
    catch(NoSuchMethodException e)
      {
        return e;
      }
  }
  

  
  
      
} 
"
org.apache.xalan.templates.ElemWithParam,11,3,0,21,33,15,2,19,10,0.825,168,0.5,2,0.951456311,0.191919192,2,9,13.90909091,3,1.0909,2,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xpath.objects.XString;


public class ElemWithParam extends ElemTemplateElement
{
  
  int m_index;

  
  private XPath m_selectPattern = null;

  
  public void setSelect(XPath v)
  {
    m_selectPattern = v;
  }

  
  public XPath getSelect()
  {
    return m_selectPattern;
  }

  
  private QName m_qname = null;
  
  int m_qnameID;

  
  public void setName(QName v)
  {
    m_qname = v;
  }

  
  public QName getName()
  {
    return m_qname;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_WITHPARAM;
  }


  
  public String getNodeName()
  {
    return Constants.ELEMNAME_WITHPARAM_STRING;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    
    if(null == m_selectPattern  
       && org.apache.xalan.processor.TransformerFactoryImpl.m_optimize)
    {
      XPath newSelect = ElemVariable.rewriteChildToExpression(this);
      if(null != newSelect)
        m_selectPattern = newSelect;
    }
    m_qnameID = sroot.getComposeState().getQNameID(m_qname);
    super.compose(sroot);
    
    java.util.Vector vnames = sroot.getComposeState().getVariableNames();
    if(null != m_selectPattern)
      m_selectPattern.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
      
    
  }
  
  
  public void setParentElem(ElemTemplateElement p)
  {
    super.setParentElem(p);
    p.m_hasVariableDecl = true;
  }
  
  
  public XObject getValue(TransformerImpl transformer, int sourceNode)
          throws TransformerException
  {

    XObject var;
    XPathContext xctxt = transformer.getXPathContext();

    xctxt.pushCurrentNode(sourceNode);

    try
    {
      if (null != m_selectPattern)
      {
        var = m_selectPattern.execute(xctxt, sourceNode, this);

        var.allowDetachToRelease(false);

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                  ""select"", m_selectPattern, var);
      }
      else if (null == getFirstChildElem())
      {
        var = XString.EMPTYSTRING;
      }
      else
      {

        
        int df = transformer.transformToRTF(this);

        var = new XRTreeFrag(df, xctxt, this);
      }
    }
    finally
    {
      xctxt.popCurrentNode();
    }

    return var;
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs && (null != m_selectPattern))
  		m_selectPattern.getExpression().callVisitors(m_selectPattern, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }



}
"
org.apache.xalan.xsltc.runtime.output.StringOutputBuffer,5,1,0,1,11,0,0,1,5,0.0,41,1.0,0,0.0,0.36,0,0,7.0,1,0.8,0,"

package org.apache.xalan.xsltc.runtime.output;


class StringOutputBuffer implements OutputBuffer {
    private StringBuffer _buffer;

    public StringOutputBuffer() {
	_buffer = new StringBuffer();
    }

    public String close() {
	return _buffer.toString();
    }

    public OutputBuffer append(String s) {
	_buffer.append(s);
	return this;
    }

    public OutputBuffer append(char[] s, int from, int to) {
	_buffer.append(s, from, to);
	return this;
    }

    public OutputBuffer append(char ch) {
	_buffer.append(ch);
	return this;
    }
}

"
org.apache.xpath.functions.FuncString,2,5,0,5,4,1,0,5,2,2.0,10,0.0,0,0.982142857,0.75,2,7,4.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncString extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return (XString)getArg0AsString(xctxt);
  }
}
"
org.apache.xalan.transformer.SerializerSwitcher,4,1,0,5,21,6,1,4,3,2.0,153,0.0,0,0.0,0.4,0,0,37.25,1,0.75,0,"
package org.apache.xalan.transformer;

import java.io.OutputStream;
import java.io.Writer;
import java.util.Properties;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.TransformerException;

import org.apache.xml.serializer.Serializer;
import org.apache.xml.serializer.SerializerFactory;
import org.apache.xml.serialize.Method;
import org.apache.xalan.templates.OutputProperties;

import org.xml.sax.ContentHandler;


public class SerializerSwitcher
{

  
  public static void switchSerializerIfHTML(
          TransformerImpl transformer, String ns, String localName)
            throws TransformerException
  {

    if (null == transformer)
      return;

    if (((null == ns) || (ns.length() == 0))
            && localName.equalsIgnoreCase(""html""))
    {
      
      
      
      if (null != transformer.getOutputPropertyNoDefault(OutputKeys.METHOD))
        return;

      
      
      Properties prevProperties = transformer.getOutputFormat().getProperties();
      
      
      
      
      OutputProperties htmlOutputProperties = new OutputProperties(Method.HTML);

      htmlOutputProperties.copyFrom(prevProperties, true);
      Properties htmlProperties = htmlOutputProperties.getProperties();

      try
      {

        Serializer oldSerializer = null;

        if (null != oldSerializer)
        {
          Serializer serializer =
            SerializerFactory.getSerializer(htmlProperties);

          Writer writer = oldSerializer.getWriter();

          if (null != writer)
            serializer.setWriter(writer);
          else
          {
            OutputStream os = oldSerializer.getOutputStream();

            if (null != os)
              serializer.setOutputStream(os);
          }



          ContentHandler ch = serializer.asContentHandler();

          transformer.setContentHandler(ch);
        }
      }
      catch (java.io.IOException e)
      {
        throw new TransformerException(e);
      }
    }
  }
  
  
  private static String getOutputPropertyNoDefault(String qnameString, Properties props)
    throws IllegalArgumentException
  {    
    String value = (String)props.get(qnameString);
    
    return value;
  }
  
  
  public static Serializer switchSerializerIfHTML(
          String ns, String localName, Properties props, Serializer oldSerializer)
            throws TransformerException
  {
    Serializer newSerializer = oldSerializer;

    if (((null == ns) || (ns.length() == 0))
            && localName.equalsIgnoreCase(""html""))
    {
      
      
      
      if (null != getOutputPropertyNoDefault(OutputKeys.METHOD, props))
        return newSerializer;

      
      
      Properties prevProperties = props;
      
      
      
      
      OutputProperties htmlOutputProperties = new OutputProperties(Method.HTML);

      htmlOutputProperties.copyFrom(prevProperties, true);
      Properties htmlProperties = htmlOutputProperties.getProperties();


      {
        if (null != oldSerializer)
        {
          Serializer serializer =
            SerializerFactory.getSerializer(htmlProperties);

          Writer writer = oldSerializer.getWriter();

          if (null != writer)
            serializer.setWriter(writer);
          else
          {
            OutputStream os = serializer.getOutputStream();

            if (null != os)
              serializer.setOutputStream(os);
          }
          newSerializer = serializer;
        }
      }




    }
    return newSerializer;
  }
  
}
"
org.apache.xalan.lib.sql.ObjectArray,7,1,0,3,19,0,3,1,6,0.25,432,1.0,1,0.0,0.464285714,0,0,60.14285714,3,1.4286,1,"
package org.apache.xalan.lib.sql;

import java.util.Vector;


public class ObjectArray
{
  
  private int m_minArraySize = 10;
  
  private Vector m_Arrays = new Vector(200);

  
  private _ObjectArray m_currentArray;


  
  private int m_nextSlot;


  
  public ObjectArray( )
  {
    
    
    
    init(10);
  }

  
  public ObjectArray( final int minArraySize )
  {
    init(minArraySize);
  }

  
  private void init( int size )
  {
    m_minArraySize = size;
    m_currentArray = new _ObjectArray(m_minArraySize);
  }

  
  public Object getAt( final int idx )
  {
    int arrayIndx = idx / m_minArraySize;
    int arrayOffset = idx - (arrayIndx * m_minArraySize);

    
    
    
    if (arrayIndx < m_Arrays.size())
    {
      _ObjectArray a = (_ObjectArray)m_Arrays.elementAt(arrayIndx);
      return a.objects[arrayOffset];
    }
    else
    {
      

      
      
      
      return m_currentArray.objects[arrayOffset];
    }
  }

  
  public void setAt( final int idx, final Object obj )
  {
    int arrayIndx = idx / m_minArraySize;
    int arrayOffset = idx - (arrayIndx * m_minArraySize);

    
    
    
    if (arrayIndx < m_Arrays.size())
    {
      _ObjectArray a = (_ObjectArray)m_Arrays.elementAt(arrayIndx);
      a.objects[arrayOffset] = obj;
    }
    else
    {
      

      
      
      
      m_currentArray.objects[arrayOffset] = obj;
    }
  }



  
  public int append( Object o )
  {
    if (m_nextSlot >= m_minArraySize)
    {
      m_Arrays.addElement(m_currentArray);
      m_nextSlot = 0;
      m_currentArray = new _ObjectArray(m_minArraySize);
    }

    m_currentArray.objects[m_nextSlot] = o;

    int pos = (m_Arrays.size() * m_minArraySize) + m_nextSlot;

    m_nextSlot++;

    return pos;
  }


  
  class _ObjectArray
  {
    
    public Object[] objects;
    
    public _ObjectArray( int size )
    {
      objects = new Object[size];
    }
  }

  
  public static void main( String[] args )
  {
    String[] word={
      ""Zero"",""One"",""Two"",""Three"",""Four"",""Five"",
      ""Six"",""Seven"",""Eight"",""Nine"",""Ten"",
      ""Eleven"",""Twelve"",""Thirteen"",""Fourteen"",""Fifteen"",
      ""Sixteen"",""Seventeen"",""Eighteen"",""Nineteen"",""Twenty"",
      ""Twenty-One"",""Twenty-Two"",""Twenty-Three"",""Twenty-Four"",
      ""Twenty-Five"",""Twenty-Six"",""Twenty-Seven"",""Twenty-Eight"",
      ""Twenty-Nine"",""Thirty"",""Thirty-One"",""Thirty-Two"",
      ""Thirty-Three"",""Thirty-Four"",""Thirty-Five"",""Thirty-Six"",
      ""Thirty-Seven"",""Thirty-Eight"",""Thirty-Nine""};

    ObjectArray m_ObjectArray = new ObjectArray();
    
    for (int x =0; x< word.length; x++)
    {
      System.out.print("" - "" + m_ObjectArray.append(word[x]));
    }

    System.out.println(""
"");
    
    for (int x =0; x< word.length; x++)
    {
      String s = (String) m_ObjectArray.getAt(x);
      System.out.println(s);
    }

    
    System.out.println((String) m_ObjectArray.getAt(5));
    System.out.println((String) m_ObjectArray.getAt(10));
    System.out.println((String) m_ObjectArray.getAt(20));
    System.out.println((String) m_ObjectArray.getAt(2));
    System.out.println((String) m_ObjectArray.getAt(15));
    System.out.println((String) m_ObjectArray.getAt(30));
    System.out.println((String) m_ObjectArray.getAt(6));
    System.out.println((String) m_ObjectArray.getAt(8));

    
    System.out.println((String) m_ObjectArray.getAt(40));

  }
}
"
org.apache.xalan.xsltc.compiler.TopLevelElement,5,2,10,24,17,10,14,10,4,2.0,56,0.0,0,0.931034483,0.44,1,4,10.2,1,0.8,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

class TopLevelElement extends SyntaxTreeNode {

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return typeCheckContents(stable);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ErrorMsg msg = new ErrorMsg(ErrorMsg.NOT_IMPLEMENTED_ERR,
				    getClass(), this);
	getParser().reportError(FATAL, msg);
    }
	
    
    public InstructionList compile(ClassGenerator classGen,
				   MethodGenerator methodGen) {
	final InstructionList result, save = methodGen.getInstructionList();
	methodGen.setInstructionList(result = new InstructionList());
	translate(classGen, methodGen);
	methodGen.setInstructionList(save);
	return result;
    }

    public void display(int indent) {
	indent(indent);
	Util.println(""TopLevelElement"");
	displayContents(indent + IndentIncrement);
    }
}
"
org.apache.xalan.xsltc.compiler.XslAttribute,6,3,0,31,57,0,2,29,5,0.5,413,1.0,2,0.918032787,0.305555556,2,10,67.16666667,28,6.0,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class XslAttribute extends Instruction {

    private String _prefix;
    private AttributeValue _name; 	
    private AttributeValueTemplate _namespace = null;
    private boolean _ignore = false;

    
    public AttributeValue getName() {
	return _name;
    }

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Attribute "" + _name);
	displayContents(indent + IndentIncrement);
    }
		
    
    public void parseContents(Parser parser) {
	boolean generated = false;
	final SymbolTable stable = parser.getSymbolTable();

	String name = getAttribute(""name"");
	String namespace = getAttribute(""namespace"");
	QName qname = parser.getQName(name, false);
	final String prefix = qname.getPrefix();

	if ((prefix != null) && (prefix.equals(XMLNS_PREFIX))) {
	    reportError(this, parser, ErrorMsg.ILLEGAL_ATTR_NAME_ERR, name);
	    return;
	}

	
	final SyntaxTreeNode parent = getParent();
	final Vector siblings = parent.getContents();
	for (int i = 0; i < parent.elementCount(); i++) {
	    SyntaxTreeNode item = (SyntaxTreeNode)siblings.elementAt(i);
	    if (item == this) break;

	    
	    if (item instanceof XslAttribute) continue;
	    if (item instanceof UseAttributeSets) continue;
	    if (item instanceof LiteralAttribute) continue;
	    if (item instanceof Text) continue;

	    
	    
	    if (item instanceof If) continue;
	    if (item instanceof Choose) continue;
 	    if (item instanceof CopyOf) continue;
 	    if (item instanceof VariableBase) continue;

	    
	    reportWarning(this, parser, ErrorMsg.STRAY_ATTRIBUTE_ERR, name);
	}

	
	if (namespace != null && namespace != Constants.EMPTYSTRING) {
	    _prefix = lookupPrefix(namespace);
	    _namespace = new AttributeValueTemplate(namespace, parser, this);
	}
	
	else if (prefix != null && prefix != Constants.EMPTYSTRING) {
	    _prefix = prefix;
	    namespace = lookupNamespace(prefix);
	    if (namespace != null) {
		_namespace = new AttributeValueTemplate(namespace, parser, this);
	    }
	}
	
	
	if (_namespace != null) {
	    
	    if (_prefix == null || _prefix == Constants.EMPTYSTRING) {
		if (prefix != null) {
		    _prefix = prefix;
		}
		else {
		    _prefix = stable.generateNamespacePrefix();
		    generated = true;
		}
	    }
	    else if (prefix != null && !prefix.equals(_prefix)) {
		_prefix = prefix;
	    }

	    name = _prefix + "":"" + qname.getLocalPart();

	    
	    if ((parent instanceof LiteralElement) && (!generated)) {
		((LiteralElement)parent).registerNamespace(_prefix,
							   namespace,
							   stable, false);
	    }
	}

	if (name.equals(XMLNS_PREFIX)) {
	    reportError(this, parser, ErrorMsg.ILLEGAL_ATTR_NAME_ERR, name);
	    return;
	}

	if (parent instanceof LiteralElement) {
	    ((LiteralElement)parent).addAttribute(this);
	}

	_name = AttributeValue.create(this, name, parser);
	parseChildren(parser);
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (!_ignore) {
	    _name.typeCheck(stable);
	    if (_namespace != null) {
		_namespace.typeCheck(stable);
	    }
	    typeCheckContents(stable);
	}
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_ignore) return;
	_ignore = true;

	
	if (_namespace != null) {
	    
	    il.append(methodGen.loadHandler());
	    il.append(new PUSH(cpg,_prefix));
	    _namespace.translate(classGen,methodGen);
	    il.append(methodGen.namespace());
	}

	
	il.append(methodGen.loadHandler());
	il.append(DUP);		
	
	
	_name.translate(classGen, methodGen);

	
	if ((elementCount() == 1) && (elementAt(0) instanceof Text)) {
	    il.append(new PUSH(cpg, ((Text)elementAt(0)).getText()));
	}
	else {
	    il.append(classGen.loadTranslet());
	    il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
						   ""stringValueHandler"",
						   STRING_VALUE_HANDLER_SIG)));
	    il.append(DUP);
	    il.append(methodGen.storeHandler());
	    
	    translateContents(classGen, methodGen);
	    
	    il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_VALUE_HANDLER,
							 ""getValue"",
							 ""()"" + STRING_SIG)));
	}

	
	il.append(methodGen.attribute());
	
	il.append(methodGen.storeHandler());
    }
}
"
org.apache.xml.dtm.ref.DTMDefaultBase,93,1,1,17,137,4056,5,13,67,0.922302738,2311,0.777777778,14,0.0,0.173913043,0,0,23.55913978,14,2.4624,2,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;
import org.apache.xml.utils.SuballocatedIntVector;
import org.apache.xml.utils.BoolStack;

import java.util.Vector;

import javax.xml.transform.Source;

import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;

import org.apache.xml.res.XMLMessages;
import org.apache.xml.res.XMLErrorResources;

import java.io.*; 


public abstract class DTMDefaultBase implements DTM
{
	static boolean JJK_DEBUG=false;

  
  
  
  
  public static final int ROOTNODE = 0;
	
  
  protected int m_size = 0;

  
  protected SuballocatedIntVector m_exptype;

  
  protected SuballocatedIntVector m_firstch;

  
  protected SuballocatedIntVector m_nextsib;

  
  protected SuballocatedIntVector m_prevsib;

  
  protected SuballocatedIntVector m_parent;

  
  protected Vector m_namespaceDeclSets = null;

  
  protected SuballocatedIntVector m_namespaceDeclSetElements = null;

  
  protected int[][][] m_elemIndexes;

  
  public static final int DEFAULT_BLOCKSIZE = 512;  
  
  
  public static final int DEFAULT_NUMBLOCKS = 32;
  
  
  public static final int DEFAULT_NUMBLOCKS_SMALL = 4;
  
  
  

  
  protected static final int NOTPROCESSED = DTM.NULL - 1;

  

  public DTMManager m_mgr;

  
  protected DTMManagerDefault m_mgrDefault=null;


  
  protected SuballocatedIntVector m_dtmIdent;

  
  

  
  protected String m_documentBaseURI;

  
  protected DTMWSFilter m_wsfilter;

  
  protected boolean m_shouldStripWS = false;

  
  protected BoolStack m_shouldStripWhitespaceStack;

  
  protected XMLStringFactory m_xstrf;

  
  protected ExpandedNameTable m_expandedNameTable;

  
  protected boolean m_indexing;

  
  public DTMDefaultBase(DTMManager mgr, Source source, int dtmIdentity,
  			DTMWSFilter whiteSpaceFilter,
  			XMLStringFactory xstringfactory, boolean doIndexing)
  {
    this(mgr, source, dtmIdentity, whiteSpaceFilter, xstringfactory,
         doIndexing, DEFAULT_BLOCKSIZE, true);
  }

  
  public DTMDefaultBase(DTMManager mgr, Source source, int dtmIdentity,
                        DTMWSFilter whiteSpaceFilter,
                        XMLStringFactory xstringfactory, boolean doIndexing,
                        int blocksize, boolean usePrevsib)
  {
    
    
    
    
    int numblocks;    
    if (blocksize <= 64)
    {
      numblocks = DEFAULT_NUMBLOCKS_SMALL;
      m_dtmIdent= new SuballocatedIntVector(4, 1);
    }
    else
    {
      numblocks = DEFAULT_NUMBLOCKS;
      m_dtmIdent= new SuballocatedIntVector(32);
    }
    
    m_exptype = new SuballocatedIntVector(blocksize, numblocks);
    m_firstch = new SuballocatedIntVector(blocksize, numblocks);
    m_nextsib = new SuballocatedIntVector(blocksize, numblocks);
    m_parent  = new SuballocatedIntVector(blocksize, numblocks);
    
    
    
    
    if (usePrevsib)
      m_prevsib = new SuballocatedIntVector(blocksize, numblocks);

    m_mgr = mgr;
    if(mgr instanceof DTMManagerDefault)
      m_mgrDefault=(DTMManagerDefault)mgr;
    
    m_documentBaseURI = (null != source) ? source.getSystemId() : null;
    m_dtmIdent.setElementAt(dtmIdentity,0);
    m_wsfilter = whiteSpaceFilter;
    m_xstrf = xstringfactory;
    m_indexing = doIndexing;

    if (doIndexing)
    {
      m_expandedNameTable = new ExpandedNameTable();
    }
    else
    {
      
      
      m_expandedNameTable = m_mgrDefault.getExpandedNameTable(this);
    }

    if (null != whiteSpaceFilter)
    {
      m_shouldStripWhitespaceStack = new BoolStack();

      pushShouldStripWhitespace(false);
    }
  }

  
  protected void ensureSizeOfIndex(int namespaceID, int LocalNameID)
  {

    if (null == m_elemIndexes)
    {
      m_elemIndexes = new int[namespaceID + 20][][];
    }
    else if (m_elemIndexes.length <= namespaceID)
    {
      int[][][] indexes = m_elemIndexes;

      m_elemIndexes = new int[namespaceID + 20][][];

      System.arraycopy(indexes, 0, m_elemIndexes, 0, indexes.length);
    }

    int[][] localNameIndex = m_elemIndexes[namespaceID];

    if (null == localNameIndex)
    {
      localNameIndex = new int[LocalNameID + 100][];
      m_elemIndexes[namespaceID] = localNameIndex;
    }
    else if (localNameIndex.length <= LocalNameID)
    {
      int[][] indexes = localNameIndex;

      localNameIndex = new int[LocalNameID + 100][];

      System.arraycopy(indexes, 0, localNameIndex, 0, indexes.length);

      m_elemIndexes[namespaceID] = localNameIndex;
    }

    int[] elemHandles = localNameIndex[LocalNameID];

    if (null == elemHandles)
    {
      elemHandles = new int[128];
      localNameIndex[LocalNameID] = elemHandles;
      elemHandles[0] = 1;
    }
    else if (elemHandles.length <= elemHandles[0] + 1)
    {
      int[] indexes = elemHandles;

      elemHandles = new int[elemHandles[0] + 1024];

      System.arraycopy(indexes, 0, elemHandles, 0, indexes.length);

      localNameIndex[LocalNameID] = elemHandles;
    }
  }

  
  protected void indexNode(int expandedTypeID, int identity)
  {

    ExpandedNameTable ent = m_expandedNameTable;
    short type = ent.getType(expandedTypeID);

    if (DTM.ELEMENT_NODE == type)
    {
      int namespaceID = ent.getNamespaceID(expandedTypeID);
      int localNameID = ent.getLocalNameID(expandedTypeID);

      ensureSizeOfIndex(namespaceID, localNameID);

      int[] index = m_elemIndexes[namespaceID][localNameID];

      index[index[0]] = identity;

      index[0]++;
    }
  }

  
  protected int findGTE(int[] list, int start, int len, int value)
  {

    int low = start;
    int high = start + (len - 1);
    int end = high;

    while (low <= high)
    {
      int mid = (low + high) / 2;
      int c = list[mid];

      if (c > value)
        high = mid - 1;
      else if (c < value)
        low = mid + 1;
      else
        return mid;
    }

    return (low <= end && list[low] > value) ? low : -1;
  }

  
  int findElementFromIndex(int nsIndex, int lnIndex, int firstPotential)
  {

    int[][][] indexes = m_elemIndexes;

    if (null != indexes && nsIndex < indexes.length)
    {
      int[][] lnIndexs = indexes[nsIndex];

      if (null != lnIndexs && lnIndex < lnIndexs.length)
      {
        int[] elems = lnIndexs[lnIndex];

        if (null != elems)
        {
          int pos = findGTE(elems, 1, elems[0], firstPotential);

          if (pos > -1)
          {
            return elems[pos];
          }
        }
      }
    }

    return NOTPROCESSED;
  }

  
  protected abstract int getNextNodeIdentity(int identity);

  
  protected abstract boolean nextNode();

  
  protected abstract int getNumberOfNodes();

  
  protected DTMAxisTraverser[] m_traversers;













  
  protected short _type(int identity)
  {

    int info = _exptype(identity);

    if (NULL != info)
      return m_expandedNameTable.getType(info);
    else
      return NULL;
  }

  
  protected int _exptype(int identity)
  {
  	if (identity == DTM.NULL)
  	return NULL;
    
    
    
    while (identity>=m_size)
    {
      if (!nextNode() && identity >= m_size)
        return NULL;
    }
    return m_exptype.elementAt(identity);

  }

  
  protected int _level(int identity)
  {
    while (identity>=m_size)
    {
      boolean isMore = nextNode();
      if (!isMore && identity >= m_size)
        return NULL;
    }

    int i=0;
    while(NULL != (identity=_parent(identity)))
      ++i;
    return i;
  }

  
  protected int _firstch(int identity)
  {

    
    int info = (identity >= m_size) ? NOTPROCESSED : m_firstch.elementAt(identity);

    
    
    
    while (info == NOTPROCESSED)
    {
      boolean isMore = nextNode();

      if (identity >= m_size &&!isMore)
        return NULL;
      else
      {
        info = m_firstch.elementAt(identity);
        if(info == NOTPROCESSED && !isMore)
          return NULL;
      }
    }

    return info;
  }

  
  protected int _nextsib(int identity)
  {
    
    int info = (identity >= m_size) ? NOTPROCESSED : m_nextsib.elementAt(identity);

    
    
    
    while (info == NOTPROCESSED)
    {
      boolean isMore = nextNode();

      if (identity >= m_size &&!isMore)
        return NULL;
      else
      {
        info = m_nextsib.elementAt(identity);
        if(info == NOTPROCESSED && !isMore)
          return NULL;
      }
    }

    return info;
  }

  
  protected int _prevsib(int identity)
  {

    if (identity < m_size)
      return m_prevsib.elementAt(identity);

    
    
    
    while (true)
    {
      boolean isMore = nextNode();

      if (identity >= m_size && !isMore)
        return NULL;
      else if (identity < m_size)
        return m_prevsib.elementAt(identity);
    }
  }

  
  protected int _parent(int identity)
  {

    if (identity < m_size)
      return m_parent.elementAt(identity);

    
    
    
    while (true)
    {
      boolean isMore = nextNode();

      if (identity >= m_size && !isMore)
        return NULL;
      else if (identity < m_size)
        return m_parent.elementAt(identity);
    }
  }

  
  public void dumpDTM(OutputStream os)
  {
    try
    {
      if(os==null)
      {
	      File f = new File(""DTMDump""+((Object)this).hashCode()+"".txt"");
 	      System.err.println(""Dumping... ""+f.getAbsolutePath());
 	      os=new FileOutputStream(f);
      }
      PrintStream ps = new PrintStream(os);

      while (nextNode()){}

      int nRecords = m_size;

      ps.println(""Total nodes: "" + nRecords);

      for (int index = 0; index < nRecords; ++index)
      {
      	int i=makeNodeHandle(index);
        ps.println(""=========== index="" + index + "" handle="" + i + "" ==========="");
        ps.println(""NodeName: "" + getNodeName(i));
        ps.println(""NodeNameX: "" + getNodeNameX(i));
        ps.println(""LocalName: "" + getLocalName(i));
        ps.println(""NamespaceURI: "" + getNamespaceURI(i));
        ps.println(""Prefix: "" + getPrefix(i));

        int exTypeID = _exptype(index);

        ps.println(""Expanded Type ID: ""
                           + Integer.toHexString(exTypeID));

        int type = _type(index);
        String typestring;

        switch (type)
        {
        case DTM.ATTRIBUTE_NODE :
          typestring = ""ATTRIBUTE_NODE"";
          break;
        case DTM.CDATA_SECTION_NODE :
          typestring = ""CDATA_SECTION_NODE"";
          break;
        case DTM.COMMENT_NODE :
          typestring = ""COMMENT_NODE"";
          break;
        case DTM.DOCUMENT_FRAGMENT_NODE :
          typestring = ""DOCUMENT_FRAGMENT_NODE"";
          break;
        case DTM.DOCUMENT_NODE :
          typestring = ""DOCUMENT_NODE"";
          break;
        case DTM.DOCUMENT_TYPE_NODE :
          typestring = ""DOCUMENT_NODE"";
          break;
        case DTM.ELEMENT_NODE :
          typestring = ""ELEMENT_NODE"";
          break;
        case DTM.ENTITY_NODE :
          typestring = ""ENTITY_NODE"";
          break;
        case DTM.ENTITY_REFERENCE_NODE :
          typestring = ""ENTITY_REFERENCE_NODE"";
          break;
        case DTM.NAMESPACE_NODE :
          typestring = ""NAMESPACE_NODE"";
          break;
        case DTM.NOTATION_NODE :
          typestring = ""NOTATION_NODE"";
          break;
        case DTM.NULL :
          typestring = ""NULL"";
          break;
        case DTM.PROCESSING_INSTRUCTION_NODE :
          typestring = ""PROCESSING_INSTRUCTION_NODE"";
          break;
        case DTM.TEXT_NODE :
          typestring = ""TEXT_NODE"";
          break;
        default :
          typestring = ""Unknown!"";
          break;
        }

        ps.println(""Type: "" + typestring);

        int firstChild = _firstch(index);

        if (DTM.NULL == firstChild)
          ps.println(""First child: DTM.NULL"");
        else if (NOTPROCESSED == firstChild)
          ps.println(""First child: NOTPROCESSED"");
        else
          ps.println(""First child: "" + firstChild);

        if (m_prevsib != null)
        {
          int prevSibling = _prevsib(index);

          if (DTM.NULL == prevSibling)
            ps.println(""Prev sibling: DTM.NULL"");
          else if (NOTPROCESSED == prevSibling)
            ps.println(""Prev sibling: NOTPROCESSED"");
          else
            ps.println(""Prev sibling: "" + prevSibling);
        }

        int nextSibling = _nextsib(index);

        if (DTM.NULL == nextSibling)
          ps.println(""Next sibling: DTM.NULL"");
        else if (NOTPROCESSED == nextSibling)
          ps.println(""Next sibling: NOTPROCESSED"");
        else
          ps.println(""Next sibling: "" + nextSibling);

        int parent = _parent(index);

        if (DTM.NULL == parent)
          ps.println(""Parent: DTM.NULL"");
        else if (NOTPROCESSED == parent)
          ps.println(""Parent: NOTPROCESSED"");
        else
          ps.println(""Parent: "" + parent);

        int level = _level(index);

        ps.println(""Level: "" + level);
        ps.println(""Node Value: "" + getNodeValue(i));
        ps.println(""String Value: "" + getStringValue(i));
      }
    }
    catch(IOException ioe)
    {
      ioe.printStackTrace(System.err);
      System.exit(-1);
    }
  }
  
  
  public String dumpNode(int nodeHandle)
  {	  
	  if(nodeHandle==DTM.NULL)
		  return ""[null]"";
		  
        String typestring;
        switch (getNodeType(nodeHandle))
        {
        case DTM.ATTRIBUTE_NODE :
          typestring = ""ATTR"";
          break;
        case DTM.CDATA_SECTION_NODE :
          typestring = ""CDATA"";
          break;
        case DTM.COMMENT_NODE :
          typestring = ""COMMENT"";
          break;
        case DTM.DOCUMENT_FRAGMENT_NODE :
          typestring = ""DOC_FRAG"";
          break;
        case DTM.DOCUMENT_NODE :
          typestring = ""DOC"";
          break;
        case DTM.DOCUMENT_TYPE_NODE :
          typestring = ""DOC_TYPE"";
          break;
        case DTM.ELEMENT_NODE :
          typestring = ""ELEMENT"";
          break;
        case DTM.ENTITY_NODE :
          typestring = ""ENTITY"";
          break;
        case DTM.ENTITY_REFERENCE_NODE :
          typestring = ""ENT_REF"";
          break;
        case DTM.NAMESPACE_NODE :
          typestring = ""NAMESPACE"";
          break;
        case DTM.NOTATION_NODE :
          typestring = ""NOTATION"";
          break;
        case DTM.NULL :
          typestring = ""null"";
          break;
        case DTM.PROCESSING_INSTRUCTION_NODE :
          typestring = ""PI"";
          break;
        case DTM.TEXT_NODE :
          typestring = ""TEXT"";
          break;
        default :
          typestring = ""Unknown!"";
          break;
        }

      StringBuffer sb=new StringBuffer();
	  sb.append(""[""+nodeHandle+"": ""+typestring+
				""(0x""+Integer.toHexString(getExpandedTypeID(nodeHandle))+"") ""+
				getNodeNameX(nodeHandle)+"" {""+getNamespaceURI(nodeHandle)+""}""+
				""=""""+ getNodeValue(nodeHandle)+""""]"");
	  return sb.toString();
  }

  

  
  public void setFeature(String featureId, boolean state){}

  

  
  public boolean hasChildNodes(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int firstChild = _firstch(identity);

    return firstChild != DTM.NULL;
  }
	
  
  final public int makeNodeHandle(int nodeIdentity)
  {
    if(NULL==nodeIdentity) return NULL;
		
    if(JJK_DEBUG && nodeIdentity>DTMManager.IDENT_NODE_DEFAULT)
      System.err.println(""GONK! (only useful in limited situations)"");

    return m_dtmIdent.elementAt(nodeIdentity >>> DTMManager.IDENT_DTM_NODE_BITS)
      + (nodeIdentity & DTMManager.IDENT_NODE_DEFAULT) ;											
  }
	
  
  final public int makeNodeIdentity(int nodeHandle)
  {
    if(NULL==nodeHandle) return NULL;

    if(m_mgrDefault!=null)
    {
      
      
      

      int whichDTMindex=nodeHandle>>>DTMManager.IDENT_DTM_NODE_BITS;

      
      
      
      
      if(m_mgrDefault.m_dtms[whichDTMindex]!=this)
	return NULL;
      else
	return
	  m_mgrDefault.m_dtm_offsets[whichDTMindex]
	  | (nodeHandle & DTMManager.IDENT_NODE_DEFAULT);
    }
	  
    int whichDTMid=m_dtmIdent.indexOf(nodeHandle & DTMManager.IDENT_DTM_DEFAULT);
    return (whichDTMid==NULL) 
      ? NULL
      : (whichDTMid << DTMManager.IDENT_DTM_NODE_BITS)
      + (nodeHandle & DTMManager.IDENT_NODE_DEFAULT);
  }


  
  public int getFirstChild(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int firstChild = _firstch(identity);

    return makeNodeHandle(firstChild);
  }
  
  
  public int getTypedFirstChild(int nodeHandle, int nodeType)
  {

    int firstChild, eType;
    if (nodeType < DTM.NTYPES) {
      for (firstChild = _firstch(makeNodeIdentity(nodeHandle));
           firstChild != DTM.NULL;
           firstChild = _nextsib(firstChild)) {
        eType = _exptype(firstChild);
        if (eType == nodeType
               || (eType >= DTM.NTYPES
                      && m_expandedNameTable.getType(eType) == nodeType)) {
          return makeNodeHandle(firstChild);
        }
      }
    } else {
      for (firstChild = _firstch(makeNodeIdentity(nodeHandle));
           firstChild != DTM.NULL;
           firstChild = _nextsib(firstChild)) {
        if (_exptype(firstChild) == nodeType) {
          return makeNodeHandle(firstChild);
        }
      }
    }
    return DTM.NULL;
  }

  
  public int getLastChild(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int child = _firstch(identity);
    int lastChild = DTM.NULL;

    while (child != DTM.NULL)
    {
      lastChild = child;
      child = _nextsib(child);
    }

    return makeNodeHandle(lastChild);
  }

  
  public abstract int getAttributeNode(int nodeHandle, String namespaceURI,
                                       String name);

  
  public int getFirstAttribute(int nodeHandle)
  {
    int nodeID = makeNodeIdentity(nodeHandle);

    return makeNodeHandle(getFirstAttributeIdentity(nodeID));
  }

  
  protected int getFirstAttributeIdentity(int identity) {
    int type = _type(identity);

    if (DTM.ELEMENT_NODE == type)
    {
      
      while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
      {

        
        type = _type(identity);

        if (type == DTM.ATTRIBUTE_NODE)
        {
          return identity;
        }
        else if (DTM.NAMESPACE_NODE != type)
        {
          break;
        }
      }
    }

    return DTM.NULL;
  }

  
  protected int getTypedAttribute(int nodeHandle, int attType) {
    int type = getNodeType(nodeHandle);
    if (DTM.ELEMENT_NODE == type) {
      int identity = makeNodeIdentity(nodeHandle);

      while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
      {
        type = _type(identity);

        if (type == DTM.ATTRIBUTE_NODE)
        {
          if (_exptype(identity) == attType) return makeNodeHandle(identity);
        }
        else if (DTM.NAMESPACE_NODE != type)
        {
          break;
        }
      }
    }

    return DTM.NULL;
  }

  
  public int getNextSibling(int nodeHandle)
  {
  	if (nodeHandle == DTM.NULL)
  	return DTM.NULL;
    return makeNodeHandle(_nextsib(makeNodeIdentity(nodeHandle)));
  }
  
  
  public int getTypedNextSibling(int nodeHandle, int nodeType)
  {
  	if (nodeHandle == DTM.NULL)
  	return DTM.NULL;
  	int node = makeNodeIdentity(nodeHandle);
  	int eType;
  	while ((node = _nextsib(node)) != DTM.NULL && 
  	((eType = _exptype(node)) != nodeType && 
  	m_expandedNameTable.getType(eType)!= nodeType)); 
  	
        
    return (node == DTM.NULL ? DTM.NULL : makeNodeHandle(node));
  }

  
  public int getPreviousSibling(int nodeHandle)
  {
    if (nodeHandle == DTM.NULL)
      return DTM.NULL;
    
    if (m_prevsib != null)
      return makeNodeHandle(_prevsib(makeNodeIdentity(nodeHandle)));
    else
    {
      
      
      
      int nodeID = makeNodeIdentity(nodeHandle);
      int parent = _parent(nodeID);
      int node = _firstch(parent);
      int result = DTM.NULL;
      while (node != nodeID)
      {
        result = node;
        node = _nextsib(node);
      }
      return makeNodeHandle(result);
    }
  }

  
  public int getNextAttribute(int nodeHandle) {
    int nodeID = makeNodeIdentity(nodeHandle);

    if (_type(nodeID) == DTM.ATTRIBUTE_NODE) {
      return makeNodeHandle(getNextAttributeIdentity(nodeID));
    }

    return DTM.NULL;
  }

  
  protected int getNextAttributeIdentity(int identity) {
    
    while (DTM.NULL != (identity = getNextNodeIdentity(identity))) {
      int type = _type(identity);

      if (type == DTM.ATTRIBUTE_NODE) {
        return identity;
      } else if (type != DTM.NAMESPACE_NODE) {
        break;
      }
    }

    return DTM.NULL;
  }

  
  private Vector m_namespaceLists = null;  


  
  protected void declareNamespaceInContext(int elementNodeIndex,int namespaceNodeIndex)
  {
    SuballocatedIntVector nsList=null;
    if(m_namespaceDeclSets==null)
      {

        
        m_namespaceDeclSetElements=new SuballocatedIntVector(32);
        m_namespaceDeclSetElements.addElement(elementNodeIndex);
        m_namespaceDeclSets=new Vector();
        nsList=new SuballocatedIntVector(32);
        m_namespaceDeclSets.addElement(nsList);
      }
    else
      {
        
        
        int last=m_namespaceDeclSetElements.size()-1;
	        
        if(last>=0 && elementNodeIndex==m_namespaceDeclSetElements.elementAt(last))
          {
            nsList=(SuballocatedIntVector)m_namespaceDeclSets.elementAt(last);
          }
      }
    if(nsList==null)
      {
        m_namespaceDeclSetElements.addElement(elementNodeIndex);

        SuballocatedIntVector inherited =
                                findNamespaceContext(_parent(elementNodeIndex));

        if (inherited!=null) {
            
            
            
            int isize=inherited.size();

            
            
            nsList=new SuballocatedIntVector(Math.max(Math.min(isize+16,2048),
                                                      32));

            for(int i=0;i<isize;++i)
              {
                nsList.addElement(inherited.elementAt(i));
              }
        } else {
            nsList=new SuballocatedIntVector(32);
        }

        m_namespaceDeclSets.addElement(nsList);
      }

    
    
    
    
    int newEType=_exptype(namespaceNodeIndex);

    for(int i=nsList.size()-1;i>=0;--i)
      {
        if(newEType==getExpandedTypeID(nsList.elementAt(i)))
          {
            nsList.setElementAt(makeNodeHandle(namespaceNodeIndex),i);
            return;
          }
      }
    nsList.addElement(makeNodeHandle(namespaceNodeIndex));
  }

  
  protected SuballocatedIntVector findNamespaceContext(int elementNodeIndex)
  {
    if (null!=m_namespaceDeclSetElements)
      {
        
        
        int wouldBeAt=findInSortedSuballocatedIntVector(m_namespaceDeclSetElements,
                                            elementNodeIndex);
        if(wouldBeAt>=0) 
          return (SuballocatedIntVector) m_namespaceDeclSets.elementAt(wouldBeAt);
        if(wouldBeAt == -1) 
          return null; 

        
        
        wouldBeAt=-1-wouldBeAt;

        
        int candidate=m_namespaceDeclSetElements.elementAt(-- wouldBeAt);
        int ancestor=_parent(elementNodeIndex);

        
        
        
        if (wouldBeAt == 0 && candidate < ancestor) {
          int rootHandle = getDocumentRoot(makeNodeHandle(elementNodeIndex));
          int rootID = makeNodeIdentity(rootHandle);
          int uppermostNSCandidateID;

          if (getNodeType(rootHandle) == DTM.DOCUMENT_NODE) {
            int ch = _firstch(rootID);
            uppermostNSCandidateID = (ch != DTM.NULL) ? ch : rootID;
          } else {
            uppermostNSCandidateID = rootID;
          }

          if (candidate == uppermostNSCandidateID) {
            return (SuballocatedIntVector)m_namespaceDeclSets.elementAt(wouldBeAt);
          }
        }

        while(wouldBeAt>=0 && ancestor>0)
          {
            if (candidate==ancestor) {
                
                return (SuballocatedIntVector)m_namespaceDeclSets.elementAt(wouldBeAt);
            } else if (candidate<ancestor) {
                
                do {
                  ancestor=_parent(ancestor);
                } while (candidate < ancestor);
            } else {
              
              candidate=m_namespaceDeclSetElements.elementAt(--wouldBeAt);
            }
          }
      }

    return null; 
  }

  
  protected int findInSortedSuballocatedIntVector(SuballocatedIntVector vector, int lookfor)
  {
    
    int i = 0;
    if(vector != null) {
      int first = 0;
      int last  = vector.size() - 1;

      while (first <= last) {
        i = (first + last) / 2;
        int test = lookfor-vector.elementAt(i);
        if(test == 0) {
          return i; 
        }
        else if (test < 0) {
          last = i - 1; 
        }
        else {
          first = i + 1; 
        }
      }

      if (first > i) {
        i = first; 
      }
    }

    return -1 - i; 
  }


  
  public int getFirstNamespaceNode(int nodeHandle, boolean inScope)
  {
        if(inScope)
        {
            int identity = makeNodeIdentity(nodeHandle);
            if (_type(identity) == DTM.ELEMENT_NODE)
            {
              SuballocatedIntVector nsContext=findNamespaceContext(identity);
              if(nsContext==null || nsContext.size()<1)
                return NULL;

              return nsContext.elementAt(0);
            }
            else
              return NULL;
          }
        else
          {
            
            
            
            
            
            
            int identity = makeNodeIdentity(nodeHandle);
            if (_type(identity) == DTM.ELEMENT_NODE)
            {
              while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
              {
                int type = _type(identity);
                if (type == DTM.NAMESPACE_NODE)
                    return makeNodeHandle(identity);
                else if (DTM.ATTRIBUTE_NODE != type)
                    break;
              }
              return NULL;
            }
            else
              return NULL;
          }
  }

  
  public int getNextNamespaceNode(int baseHandle, int nodeHandle,
                                  boolean inScope)
  {
        if(inScope)
          {
            
            
            
            

                SuballocatedIntVector nsContext=findNamespaceContext(makeNodeIdentity(baseHandle));

            if(nsContext==null)
              return NULL;
            int i=1 + nsContext.indexOf(nodeHandle);
            if(i<=0 || i==nsContext.size())
              return NULL;

            return nsContext.elementAt(i);
          }
        else
          {
            
            int identity = makeNodeIdentity(nodeHandle);
            while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
              {
                int type = _type(identity);
                if (type == DTM.NAMESPACE_NODE)
                  {
                    return makeNodeHandle(identity);
                  }
                else if (type != DTM.ATTRIBUTE_NODE)
                  {
                    break;
                  }
              }
          }
     return DTM.NULL;
  }

  
  public int getParent(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);

    if (identity > 0)
      return makeNodeHandle(_parent(identity));
    else
      return DTM.NULL;
  }

  
  public int getDocument()
  {
    return m_dtmIdent.elementAt(0); 
  }

  
  public int getOwnerDocument(int nodeHandle)
  {

    if (DTM.DOCUMENT_NODE == getNodeType(nodeHandle))
  	    return DTM.NULL;

    return getDocumentRoot(nodeHandle);
  }

  
  public int getDocumentRoot(int nodeHandle)
  {
    return getDocument();
  }

  
  public abstract XMLString getStringValue(int nodeHandle);

  
  public int getStringValueChunkCount(int nodeHandle)
  {

    
    error(XMLMessages.createXMLMessage(XMLErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return 0;
  }

  
  public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
                                    int[] startAndLen)
  {

    
    error(XMLMessages.createXMLMessage(XMLErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return null;
  }

  
  public int getExpandedTypeID(int nodeHandle)
  {
    
    
    int id=makeNodeIdentity(nodeHandle);
    if(id==NULL)
      return NULL;
    return _exptype(id);
  }

  
  public int getExpandedTypeID(String namespace, String localName, int type)
  {

    ExpandedNameTable ent = m_expandedNameTable;

    return ent.getExpandedTypeID(namespace, localName, type);
  }

  
  public String getLocalNameFromExpandedNameID(int expandedNameID)
  {
    return m_expandedNameTable.getLocalName(expandedNameID);
  }

  
  public String getNamespaceFromExpandedNameID(int expandedNameID)
  {
    return m_expandedNameTable.getNamespace(expandedNameID);
  }

  
  public int getNamespaceType(final int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int expandedNameID = _exptype(identity);

    return m_expandedNameTable.getNamespaceID(expandedNameID);
  }

  
  public abstract String getNodeName(int nodeHandle);

  
  public String getNodeNameX(int nodeHandle)
  {

    
    error(XMLMessages.createXMLMessage(XMLErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return null;
  }

  
  public abstract String getLocalName(int nodeHandle);

  
  public abstract String getPrefix(int nodeHandle);

  
  public abstract String getNamespaceURI(int nodeHandle);

  
  public abstract String getNodeValue(int nodeHandle);

  
  public short getNodeType(int nodeHandle)
  {
  	if (nodeHandle == DTM.NULL)
  	return DTM.NULL;
    return m_expandedNameTable.getType(_exptype(makeNodeIdentity(nodeHandle)));
  }

  
  public short getLevel(int nodeHandle)
  {
    
    int identity = makeNodeIdentity(nodeHandle);
    return (short) (_level(identity) + 1);
  }
  
  
  public int getNodeIdent(int nodeHandle)
  {
    
      
      return makeNodeIdentity(nodeHandle); 
  }
  
  
  public int getNodeHandle(int nodeId)
  {
    
      
      return makeNodeHandle(nodeId);
  }

  

  
  public boolean isSupported(String feature, String version)
  {

    
    return false;
  }

  
  public String getDocumentBaseURI()
  {
    return m_documentBaseURI;
  }

  
  public void setDocumentBaseURI(String baseURI)
  {
    m_documentBaseURI = baseURI;
  }

  
  public String getDocumentSystemIdentifier(int nodeHandle)
  {

    
    return m_documentBaseURI;
  }

  
  public String getDocumentEncoding(int nodeHandle)
  {

    
    return ""UTF-8"";
  }

  
  public String getDocumentStandalone(int nodeHandle)
  {
    return null;
  }

  
  public String getDocumentVersion(int documentHandle)
  {
    return null;
  }

  
  public boolean getDocumentAllDeclarationsProcessed()
  {

    
    return true;
  }

  
  public abstract String getDocumentTypeDeclarationSystemIdentifier();

  
  public abstract String getDocumentTypeDeclarationPublicIdentifier();

  
  public abstract int getElementById(String elementId);

  
  public abstract String getUnparsedEntityURI(String name);

  

  
  public boolean supportsPreStripping()
  {
    return true;
  }

  
  public boolean isNodeAfter(int nodeHandle1, int nodeHandle2)
  {
		
    int index1 = makeNodeIdentity(nodeHandle1);
    int index2 = makeNodeIdentity(nodeHandle2);

    return index1!=NULL & index2!=NULL & index1 <= index2;
  }

  
  public boolean isCharacterElementContentWhitespace(int nodeHandle)
  {

    
    return false;
  }

  
  public boolean isDocumentAllDeclarationsProcessed(int documentHandle)
  {
    return true;
  }

  
  public abstract boolean isAttributeSpecified(int attributeHandle);

  

  
  public abstract void dispatchCharactersEvents(
    int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize)
      throws org.xml.sax.SAXException;

  
  public abstract void dispatchToEvents(
    int nodeHandle, org.xml.sax.ContentHandler ch)
      throws org.xml.sax.SAXException;

  
  public org.w3c.dom.Node getNode(int nodeHandle)
  {
    return new DTMNodeProxy(this, nodeHandle);
  }

  

  
  public void appendChild(int newChild, boolean clone, boolean cloneDepth)
  {
    error(XMLMessages.createXMLMessage(XMLErrorResources.ER_METHOD_NOT_SUPPORTED, null));
  }

  
  public void appendTextChild(String str)
  {
    error(XMLMessages.createXMLMessage(XMLErrorResources.ER_METHOD_NOT_SUPPORTED, null));
  }

  
  protected void error(String msg)
  {
    throw new DTMException(msg);
  }

  
  protected boolean getShouldStripWhitespace()
  {
    return m_shouldStripWS;
  }

  
  protected void pushShouldStripWhitespace(boolean shouldStrip)
  {

    m_shouldStripWS = shouldStrip;

    if (null != m_shouldStripWhitespaceStack)
      m_shouldStripWhitespaceStack.push(shouldStrip);
  }

  
  protected void popShouldStripWhitespace()
  {
    if (null != m_shouldStripWhitespaceStack)
      m_shouldStripWS = m_shouldStripWhitespaceStack.popAndTop();
  }

  
  protected void setShouldStripWhitespace(boolean shouldStrip)
  {

    m_shouldStripWS = shouldStrip;

    if (null != m_shouldStripWhitespaceStack)
      m_shouldStripWhitespaceStack.setTop(shouldStrip);
  }

  
   public void documentRegistration()
   {
   }

  
   public void documentRelease()
   {
   }

	 
	 public DTMManager getManager()
	 {
		 return m_mgr;
	 }

	 
	 public SuballocatedIntVector getDTMIDs()
	 {
		 if(m_mgr==null) return null;
		 return m_dtmIdent;
	 }
}
"
org.apache.xml.res.XMLErrorResources_zh_TW,3,4,0,1,4,1,0,1,2,1.3,875,0.0,0,0.976190476,1.0,0,0,289.0,1,0.3333,0,"
package org.apache.xml.res;



public class XMLErrorResources_zh_TW extends XMLErrorResources
{

  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },


  
  


  {
    ER_FUNCTION_NOT_SUPPORTED, ""不支援函式！""},

  
  
  


  {
    ER_CANNOT_OVERWRITE_CAUSE,
			""無法改寫原因""},

  
   
  


  {
    ER_NO_DEFAULT_IMPL,
         ""找不到預設建置""},

  
   
  


  {
    ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
       ""目前不支援 ChunkedIntArray({0})""},

  
   
  


  {
    ER_OFFSET_BIGGER_THAN_SLOT,
       ""偏移大於介面槽""},

  
   
  


  {
    ER_COROUTINE_NOT_AVAIL,
       ""沒有 Coroutine 可用，id={0}""},

  
   
  


  {
    ER_COROUTINE_CO_EXIT,
       ""CoroutineManager 收到 co_exit() 要求""},

  
   
  


  {
    ER_COJOINROUTINESET_FAILED,
       ""co_joinCoroutineSet() 失效""},

  
   
  


  {
    ER_COROUTINE_PARAM,
       ""Coroutine 參數錯誤 ({0})""},

  
   
  


  {
    ER_PARSER_DOTERMINATE_ANSWERS,
       ""
UNEXPECTED: 剖析器 doTerminate 回答 {0}""},

  
   
  


  {
    ER_NO_PARSE_CALL_WHILE_PARSING,
       ""在進行剖析時未能呼叫剖析""},

  
   
  


  {
    ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""錯誤：對軸 {0} 輸入的重覆器沒有執行""},

  
   
  


  {
    ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""錯誤：軸 {0} 的重覆器沒有執行 ""},

  
   
  


  {
    ER_ITERATOR_CLONE_NOT_SUPPORTED,
       ""不支援重覆器複製""},

  
   
  


  {
    ER_UNKNOWN_AXIS_TYPE,
       ""未知軸遍歷類型：{0}""},

  
   
  


  {
    ER_AXIS_NOT_SUPPORTED,
       ""不支援軸遍訪器：{0}""},

  
   
  


  {
    ER_NO_DTMIDS_AVAIL,
       ""沒有可用的 DTM ID""},

  
   
  


  {
    ER_NOT_SUPPORTED,
       ""不支援：{0}""},

  
   
  


  {
    ER_NODE_NON_NULL,
       ""對 getDTMHandleFromNode 而言，節點必須為非空值""},

  
   
  


  {
    ER_COULD_NOT_RESOLVE_NODE,
       ""無法解譯節點為控點""},

  
   
  


  {
    ER_STARTPARSE_WHILE_PARSING,
       ""在進行剖析時未呼叫 startParse""},

  
   
  


  {
    ER_STARTPARSE_NEEDS_SAXPARSER,
       ""startParse 需要非空值的 SAXParser""},

  
   
  


  {
    ER_COULD_NOT_INIT_PARSER,
       ""無法起始設定剖析器，以""},

  
   
  


  {
    ER_EXCEPTION_CREATING_POOL,
       ""建立儲存池的新案例時發生異常""},

  
   
  


  {
    ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
       ""路徑包含無效逸出序列""},

  
   
  


  {
    ER_SCHEME_REQUIRED,
       ""綱要是必需的！""},

  
   
  


  {
    ER_NO_SCHEME_IN_URI,
       ""在 URI 找不到綱要：{0}""},

  
   
  


  {
    ER_NO_SCHEME_INURI,
       ""在 URI 找不到綱要""},

  
   
  


  {
    ER_PATH_INVALID_CHAR,
       ""路徑包含無效的字元：{0}""},

  
   
  


  {
    ER_SCHEME_FROM_NULL_STRING,
       ""無法從空字串設定綱要""},

  
   
  


  {
    ER_SCHEME_NOT_CONFORMANT,
       ""綱要不一致。""},

  
   
  


  {
    ER_HOST_ADDRESS_NOT_WELLFORMED,
       ""主機沒有完整的位址""},

  
   
  


  {
    ER_PORT_WHEN_HOST_NULL,
       ""主機為空值時，無法設定通訊埠""},

  
   
  


  {
    ER_INVALID_PORT,
       ""無效的通訊埠編號""},

  
   
  


  {
    ER_FRAG_FOR_GENERIC_URI,
       ""只能對同屬的 URI 設定片段""},

  
   
  


  {
    ER_FRAG_WHEN_PATH_NULL,
       ""路徑為空值時，無法設定片段""},

  
   
  


  {
    ER_FRAG_INVALID_CHAR,
       ""片段包含無效字元""},

  
 
  
   
  


  {
    ER_PARSER_IN_USE,
        ""剖析器已在使用中""},

  
   
  


  {
    ER_CANNOT_CHANGE_WHILE_PARSING,
        ""剖析時無法變更 {0} {1}""},

  
   
  


  {
    ER_SELF_CAUSATION_NOT_PERMITTED,
        ""不允許自行引起""},

  
   
  


  {
    ER_NO_USERINFO_IF_NO_HOST,
        ""如果沒有指定主機，不可指定 Userinfo""},

  
   
  


  {
    ER_NO_PORT_IF_NO_HOST,
        ""如果沒有指定主機，不可指定通訊埠""},

  
   
  


  {
    ER_NO_QUERY_STRING_IN_PATH,
        ""在路徑及查詢字串中不可指定查詢字串""},

  
   
  


  {
    ER_NO_FRAGMENT_STRING_IN_PATH,
        ""無法在路徑和片段中指定片段""},

  
   
  


  {
    ER_CANNOT_INIT_URI_EMPTY_PARMS,
        ""無法起始設定空白參數的 URI""},

  
  
  


  {
    ER_METHOD_NOT_SUPPORTED,
        ""不支援方法 ""},


  
  


  {
    ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
     ""IncrementalSAXSource_Filter 目前無法重新啟動""},

  
  
  


  {
    ER_XMLRDR_NOT_BEFORE_STARTPARSE,
     ""XMLReader 不在 startParse 要求之前""},
  

  
    
  
    {
      ER_AXIS_TRAVERSER_NOT_SUPPORTED,
       ""不支援軸遍歷器：{0}""},
  

  
    
  
    {
      ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
       ""建立的 ListingErrorHandler 具有空 PrintWriter！""},
  

    
  
    {
      ER_SYSTEMID_UNKNOWN,
       ""SystemId 未知""},
  

   
    
  
    {
      ER_LOCATION_UNKNOWN,
       ""未知的錯誤位置""},

  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""前置必須解譯為名稱空間：{0}""},


  
  


  {
    ER_CREATEDOCUMENT_NOT_SUPPORTED,
      ""createDocument() 在 XPathContext 中不受支援！""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT,
      ""屬性子項沒有擁有者文件！""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
      ""屬性子項沒有擁有者文件元素！""},


  
  


  {
    ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
      ""警告：無法輸出文件元素之前的文字！忽略...""},


  
  


  {
    ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
      ""一個 DOM 只能有一個根！""},

  
   
  


  {
    ER_ARG_LOCALNAME_NULL,
       ""引數 'localName' 為空值""},


  
  
  

  
  
 

  {
    ER_ARG_LOCALNAME_INVALID,
       ""QNAME 中的 Localname 應為有效的 NCName""},

  
  
  
  
 
  
  
 

  {
    ER_ARG_PREFIX_INVALID,
       ""QNAME 中的前置應為有效的 NCName""},

  { ""BAD_CODE"",
      ""createMessage 的參數超出界限""},
  { ""FORMAT_FAILED"",
      ""在 messageFormat 呼叫期間丟出異常""},
  { ""line"", ""行 #""},
  { ""column"", ""直欄 #""}
  
  };

 
  
  public Object[][] getContents()
  {
    return contents;
  }

}"
org.apache.xalan.templates.FuncFormatNumb,5,6,0,13,36,10,1,12,4,2.0,186,0.0,0,0.941176471,0.4,2,8,36.2,1,0.8,2,"
package org.apache.xalan.templates;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.functions.Function3Args;
import org.apache.xpath.functions.WrongNumberArgsException;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncFormatNumb extends Function3Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    
    ElemTemplateElement templElem =
      (ElemTemplateElement) xctxt.getNamespaceContext();
    StylesheetRoot ss = templElem.getStylesheetRoot();
    java.text.DecimalFormat formatter = null;
    java.text.DecimalFormatSymbols dfs = null;
    double num = getArg0().execute(xctxt).num();
    String patternStr = getArg1().execute(xctxt).str();

    
    if (patternStr.indexOf(0x00A4) > 0)
      ss.error(XSLTErrorResources.ER_CURRENCY_SIGN_ILLEGAL);  

    
    
    try
    {
      Expression arg2Expr = getArg2();

      if (null != arg2Expr)
      {
        String dfName = arg2Expr.execute(xctxt).str();
        QName qname = new QName(dfName, xctxt.getNamespaceContext());

        dfs = ss.getDecimalFormatComposed(qname);

        if (null == dfs)
        {
          warn(xctxt, XSLTErrorResources.WG_NO_DECIMALFORMAT_DECLARATION,
               new Object[]{ dfName });  

          
        }
        else
        {

          
          formatter = new java.text.DecimalFormat();

          formatter.setDecimalFormatSymbols(dfs);
          formatter.applyLocalizedPattern(patternStr);
        }
      }

      
      if (null == formatter)
      {

        
        if (ss.getDecimalFormatCount() > 0)
          dfs = ss.getDecimalFormatComposed(new QName(""""));

        if (dfs != null)
        {
          formatter = new java.text.DecimalFormat();

          formatter.setDecimalFormatSymbols(dfs);
          formatter.applyLocalizedPattern(patternStr);
        }
        else
        {
          dfs = new java.text.DecimalFormatSymbols(java.util.Locale.US);

          dfs.setInfinity(Constants.ATTRVAL_INFINITY);
          dfs.setNaN(Constants.ATTRVAL_NAN);

          formatter = new java.text.DecimalFormat();

          formatter.setDecimalFormatSymbols(dfs);

          if (null != patternStr)
            formatter.applyLocalizedPattern(patternStr);
        }
      }

      return new XString(formatter.format(num));
    }
    catch (Exception iae)
    {
      templElem.error(XSLTErrorResources.ER_MALFORMED_FORMAT_STRING,
                      new Object[]{ patternStr });

      return XString.EMPTYSTRING;

      
    }
  }

  
  public void warn(XPathContext xctxt, String msg, Object args[])
          throws javax.xml.transform.TransformerException
  {

    String formattedMsg = XSLMessages.createWarning(msg, args);
    ErrorListener errHandler = xctxt.getErrorListener();

    errHandler.warning(new TransformerException(formattedMsg,
                                             (SAXSourceLocator)xctxt.getSAXLocator()));
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if ((argNum > 3) || (argNum < 2))
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createMessage(XSLTErrorResources.ER_TWO_OR_THREE, null)); 
  }
}
"
org.apache.xalan.lib.sql.SQLDocument,10,5,0,7,53,0,1,6,5,0.883141762,1077,1.0,1,0.954545455,0.211111111,2,8,100.9,12,3.5,0,"

package org.apache.xalan.lib.sql;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMManager;


public class SQLDocument extends DTMDocument
{

  
  private boolean DEBUG = false;

  
  private static final String S_NAMESPACE = ""http:


  
  private static final String S_SQL = ""sql"";

  
  private static final String S_ROW_SET = ""row-set"";

  
  private static final String S_METADATA = ""metadata"";

  
  private static final String S_COLUMN_HEADER = ""column-header"";

  
  private static final String S_ROW = ""row"";

  
  private static final String S_COL = ""col"";

  
  private static final String S_CATALOGUE_NAME = ""catalogue-name"";
  
  private static final String S_DISPLAY_SIZE = ""column-display-size"";
  
  private static final String S_COLUMN_LABEL = ""column-label"";
  
  private static final String S_COLUMN_NAME = ""column-name"";
  
  private static final String S_COLUMN_TYPE = ""column-type"";
  
  private static final String S_COLUMN_TYPENAME = ""column-typename"";
  
  private static final String S_PRECISION = ""precision"";
  
  private static final String S_SCALE = ""scale"";
  
  private static final String S_SCHEMA_NAME = ""schema-name"";
  
  private static final String S_TABLE_NAME = ""table-name"";
  
  private static final String S_CASESENSITIVE = ""case-sensitive"";
  
  private static final String S_DEFINITELYWRITABLE = ""definitely-writable"";
  
  private static final String S_ISNULLABLE = ""nullable"";
  
  private static final String S_ISSIGNED = ""signed"";
  
  private static final String S_ISWRITEABLE = ""writable"";
  
  private static final String S_ISSEARCHABLE = ""searchable"";

  
  private int m_SQL_TypeID = 0;
  
  private int m_MetaData_TypeID = 0;
  
  private int m_ColumnHeader_TypeID = 0;
  
  private int m_RowSet_TypeID = 0;
  
  private int m_Row_TypeID = 0;
  
  private int m_Col_TypeID = 0;

  
  private int m_ColAttrib_CATALOGUE_NAME_TypeID = 0;
  
  private int m_ColAttrib_DISPLAY_SIZE_TypeID = 0;
  
  private int m_ColAttrib_COLUMN_LABEL_TypeID = 0;
  
  private int m_ColAttrib_COLUMN_NAME_TypeID = 0;
  
  private int m_ColAttrib_COLUMN_TYPE_TypeID = 0;
  
  private int m_ColAttrib_COLUMN_TYPENAME_TypeID = 0;
  
  private int m_ColAttrib_PRECISION_TypeID = 0;
  
  private int m_ColAttrib_SCALE_TypeID = 0;
  
  private int m_ColAttrib_SCHEMA_NAME_TypeID = 0;
  
  private int m_ColAttrib_TABLE_NAME_TypeID = 0;
  
  private int m_ColAttrib_CASESENSITIVE_TypeID = 0;
  
  private int m_ColAttrib_DEFINITELYWRITABLE_TypeID = 0;
  
  private int m_ColAttrib_ISNULLABLE_TypeID = 0;
  
  private int m_ColAttrib_ISSIGNED_TypeID = 0;
  
  private int m_ColAttrib_ISWRITEABLE_TypeID = 0;
  
  private int m_ColAttrib_ISSEARCHABLE_TypeID = 0;

  
  private Connection m_Connection = null;

  
  private Statement m_Statement = null;

  
  private ResultSet m_ResultSet = null;

  
  private ConnectionPool m_ConnectionPool = null;


  
  private int[] m_ColHeadersIdx;

  
  private int m_ColCount;

  
  private int m_MetaDataIdx = DTM.NULL;

  
  private int m_RowSetIdx = DTM.NULL;

  
  private int m_SQLIdx = DTM.NULL;

  
  private int m_FirstRowIdx = DTM.NULL;

  
  private int m_LastRowIdx = DTM.NULL;

  
  private boolean m_StreamingMode = true;

  
  public SQLDocument( DTMManager mgr, int ident, ConnectionPool pool, Connection con, Statement stmt, ResultSet data, boolean streamingMode )throws SQLException
  {
    super(mgr, ident);

    m_Connection = con;
    m_Statement  = stmt;
    m_ResultSet  = data;
    m_ConnectionPool = pool;
    m_StreamingMode = streamingMode;

    createExpandedNameTable();
    extractSQLMetaData(m_ResultSet.getMetaData());

    
    
    
    
    addRowToDTMFromResultSet();




  }


  
  private void extractSQLMetaData( ResultSetMetaData meta )
  {
    
    
    

    
    m_DocumentIdx = addElement(0, m_Document_TypeID, DTM.NULL, DTM.NULL);

    
    m_SQLIdx = addElement(1, m_SQL_TypeID,  m_DocumentIdx, DTM.NULL);

    
    m_MetaDataIdx = addElement(1, m_MetaData_TypeID,  m_SQLIdx, DTM.NULL);

    try
    {
      m_ColCount = meta.getColumnCount();
      m_ColHeadersIdx = new int[m_ColCount];
    }
    catch(Exception e)
    {
      error(""ERROR Extracting Metadata"");
    }

    
    
    int lastColHeaderIdx = DTM.NULL;

    
    int i = 1;
    for (i=1; i<= m_ColCount; i++)
    {
      m_ColHeadersIdx[i-1] =
        addElement(2,m_ColumnHeader_TypeID, m_MetaDataIdx, lastColHeaderIdx);

      lastColHeaderIdx = m_ColHeadersIdx[i-1];
      

      try
      {
        addAttributeToNode(
          meta.getColumnName(i),
          m_ColAttrib_COLUMN_NAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_COLUMN_NAME_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.getColumnLabel(i),
          m_ColAttrib_COLUMN_LABEL_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_COLUMN_LABEL_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.getCatalogName(i),
          m_ColAttrib_CATALOGUE_NAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_CATALOGUE_NAME_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          new Integer(meta.getColumnDisplaySize(i)),
          m_ColAttrib_DISPLAY_SIZE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_DISPLAY_SIZE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          new Integer(meta.getColumnType(i)),
          m_ColAttrib_COLUMN_TYPE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_COLUMN_TYPE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.getColumnTypeName(i),
          m_ColAttrib_COLUMN_TYPENAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_COLUMN_TYPENAME_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          new Integer(meta.getPrecision(i)),
          m_ColAttrib_PRECISION_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_PRECISION_TypeID, lastColHeaderIdx);
      }
      try
      {
        addAttributeToNode(
          new Integer(meta.getScale(i)),
          m_ColAttrib_SCALE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_SCALE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.getSchemaName(i),
          m_ColAttrib_SCHEMA_NAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_SCHEMA_NAME_TypeID, lastColHeaderIdx);
      }
      try
      {
        addAttributeToNode(
          meta.getTableName(i),
          m_ColAttrib_TABLE_NAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_TABLE_NAME_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isCaseSensitive(i) ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_CASESENSITIVE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_CASESENSITIVE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isDefinitelyWritable(i) ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_DEFINITELYWRITABLE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_DEFINITELYWRITABLE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isNullable(i) != 0 ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_ISNULLABLE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_ISNULLABLE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isSigned(i) ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_ISSIGNED_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_ISSIGNED_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isWritable(i) == true ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_ISWRITEABLE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_ISWRITEABLE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isSearchable(i) == true ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_ISSEARCHABLE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_ISSEARCHABLE_TypeID, lastColHeaderIdx);
      }

    }

  }

  
  protected void createExpandedNameTable( )
  {
    super.createExpandedNameTable();

    m_SQL_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SQL, DTM.ELEMENT_NODE);

    m_MetaData_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_METADATA, DTM.ELEMENT_NODE);

    m_ColumnHeader_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_HEADER, DTM.ELEMENT_NODE);
    m_RowSet_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ROW_SET, DTM.ELEMENT_NODE);
    m_Row_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ROW, DTM.ELEMENT_NODE);
    m_Col_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COL, DTM.ELEMENT_NODE);


    m_ColAttrib_CATALOGUE_NAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_CATALOGUE_NAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_DISPLAY_SIZE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_DISPLAY_SIZE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_COLUMN_LABEL_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_LABEL, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_COLUMN_NAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_NAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_COLUMN_TYPE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_TYPE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_COLUMN_TYPENAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_TYPENAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_PRECISION_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_PRECISION, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_SCALE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SCALE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_SCHEMA_NAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SCHEMA_NAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_TABLE_NAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_TABLE_NAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_CASESENSITIVE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_CASESENSITIVE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_DEFINITELYWRITABLE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_DEFINITELYWRITABLE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_ISNULLABLE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISNULLABLE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_ISSIGNED_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISSIGNED, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_ISWRITEABLE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISWRITEABLE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_ISSEARCHABLE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISSEARCHABLE, DTM.ATTRIBUTE_NODE);
  }


  
  private boolean addRowToDTMFromResultSet( )
  {
    try
    {


      
      
      if (m_RowSetIdx == DTM.NULL)
      {
        m_RowSetIdx = addElement(1, m_RowSet_TypeID,  m_SQLIdx, m_MetaDataIdx);
      }

      
      
      if ( ! m_ResultSet.next())
      {
        
        
        
        

        if (m_StreamingMode && (m_LastRowIdx != DTM.NULL))
        {
          
          m_nextsib.setElementAt(DTM.NULL, m_LastRowIdx);
        }

        return false;
      }

      
      if (m_FirstRowIdx == DTM.NULL)
      {
        m_FirstRowIdx =
          addElement(2, m_Row_TypeID, m_RowSetIdx, DTM.NULL);
        m_LastRowIdx = m_FirstRowIdx;

        if (m_StreamingMode)
        {
          
          m_nextsib.setElementAt(m_LastRowIdx, m_LastRowIdx);
        }

      }
      else
      {
        
        
        if (! m_StreamingMode)
        {
          m_LastRowIdx = addElement(3, m_Row_TypeID, m_RowSetIdx, m_LastRowIdx);
        }
      }

      
      
      int colID = _firstch(m_LastRowIdx);

      
      int pcolID = DTM.NULL;

      
      for (int i=1; i<= m_ColCount; i++)
      {
        
        
        Object o = m_ResultSet.getObject(i);

        
        
        
        if (colID == DTM.NULL)
        {
          pcolID = addElementWithData(o,3,m_Col_TypeID, m_LastRowIdx, pcolID);
          cloneAttributeFromNode(pcolID, m_ColHeadersIdx[i-1]);
        }
        else
        {
          
          
          int dataIdent = _firstch(colID);
          if (dataIdent == DTM.NULL)
          {
            error(""Streaming Mode, Data Error"");
          }
          else
          {
            m_ObjectArray.setAt(dataIdent, o);
          }
        } 

        
        
        
        if (colID != DTM.NULL)
        {
          colID = _nextsib(colID);
        }

      } 
    }
    catch(Exception e)
    {
      if (DEBUG)
      {
        System.out.println(
          ""SQL Error Fetching next row ["" + e.getLocalizedMessage() + ""]"");
      }

      error(""SQL Error Fetching next row ["" + e.getLocalizedMessage() + ""]"");
    }

    
    return true;
  }


  
  public void close( )
  {
    if (DEBUG) System.out.println(""close()"");

    try { if (null != m_ResultSet) m_ResultSet.close(); }
    catch(Exception e) { }
    try { if (null != m_Statement) m_Statement.close(); }
    catch(Exception e) { }
    try {
      if (null != m_Connection)
        m_ConnectionPool.releaseConnection(m_Connection);
    } catch(Exception e) { }
  }

  
  public void closeOnError( )
  {
    if (DEBUG) System.out.println(""close()"");

    try  { if (null != m_ResultSet) m_ResultSet.close();   }
    catch(Exception e) { }
    try  { if (null != m_Statement) m_Statement.close();
    } catch(Exception e) { }
    try {
      if (null != m_Connection)
        m_ConnectionPool.releaseConnectionOnError(m_Connection);
    } catch(Exception e) { }
  }



  
  protected boolean nextNode( )
  {
    if (DEBUG) System.out.println(""nextNode()"");
    try
    {
      return false;

    }
    catch(Exception e)
    {
      return false;
    }
  }

  
  protected int _nextsib( int identity )
  {
    
    
    
    

    int id = _exptype(identity);
    if (
      ( id == m_Row_TypeID) &&
      (identity >= m_LastRowIdx))
    {
      if (DEBUG) System.out.println(""reading from the ResultSet"");
      addRowToDTMFromResultSet();
    }

    return super._nextsib(identity);
  }

  public void documentRegistration()
  {
    if (DEBUG) System.out.println(""Document Registration"");
  }

  public void documentRelease()
  {
    if (DEBUG) System.out.println(""Document Release"");
  }


}
"
org.apache.xpath.functions.FuncExtFunctionAvailable,2,4,0,8,14,1,0,8,2,2.0,72,0.0,0,0.979591837,0.75,2,7,35.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xalan.templates.Constants;
import org.apache.xpath.ExtensionsProvider;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.Keywords;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class FuncExtFunctionAvailable extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String prefix;
    String namespace;
    String methName;

    String fullName = m_arg0.execute(xctxt).str();
    int indexOfNSSep = fullName.indexOf(':');

    if (indexOfNSSep < 0)
    {
      prefix = """";
      namespace = Constants.S_XSLNAMESPACEURL;
      methName = fullName;
    }
    else
    {
      prefix = fullName.substring(0, indexOfNSSep);
      namespace = xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);
      if (null == namespace)
        return XBoolean.S_FALSE;
        methName = fullName.substring(indexOfNSSep + 1);
    }

    if (namespace.equals(Constants.S_XSLNAMESPACEURL))
    {
      try
      {
        return Keywords.functionAvailable(methName) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
      }
      catch (Exception e)
      {
        return XBoolean.S_FALSE;
      }
    }
    else
    {
      
      ExtensionsProvider extProvider = (ExtensionsProvider)xctxt.getOwnerObject();
      return extProvider.functionAvailable(namespace, methName)
             ? XBoolean.S_TRUE : XBoolean.S_FALSE;
    }
  }
}
"
org.apache.xalan.xsltc.compiler.ApplyImports,7,3,0,21,48,17,0,21,5,0.888888889,237,1.0,1,0.903225806,0.30952381,1,4,32.42857143,6,1.7143,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class ApplyImports extends Instruction {

    private QName      _modeName;
    private String     _functionName;
    private int        _precedence;

    public void display(int indent) {
	indent(indent);
	Util.println(""ApplyTemplates"");
	indent(indent + IndentIncrement);
	if (_modeName != null) {
	    indent(indent + IndentIncrement);
	    Util.println(""mode "" + _modeName);
	}
    }

    
    public boolean hasWithParams() {
	return hasContents();
    }

    
    private int getMinPrecedence(int max) {
	Stylesheet stylesheet = getStylesheet();
	Stylesheet root = getParser().getTopLevelStylesheet();

	int min = max;

	Enumeration templates = root.getContents().elements();
	while (templates.hasMoreElements()) {
	    SyntaxTreeNode child = (SyntaxTreeNode)templates.nextElement();
	    if (child instanceof Template) {
		Stylesheet curr = child.getStylesheet();
		while ((curr != null) && (curr != stylesheet)) {
		    if (curr._importedFrom != null)
			curr = curr._importedFrom;
		    else if (curr._includedFrom != null)
			curr = curr._includedFrom;
		    else
			curr = null;
		}
		if (curr == stylesheet) {
		    int prec = child.getStylesheet().getImportPrecedence();
		    if (prec < min) min = prec;
		}
	    }
	}
	return (min);
    }

    
    public void parseContents(Parser parser) {
	
	
	Stylesheet stylesheet = getStylesheet();
	stylesheet.setTemplateInlining(false);

	
	Template template = getTemplate();
	_modeName = template.getModeName();
	_precedence = template.getImportPrecedence();

	
	stylesheet = parser.getTopLevelStylesheet();

	
	
	final int maxPrecedence = _precedence;
	final int minPrecedence = getMinPrecedence(maxPrecedence);
	final Mode mode = stylesheet.getMode(_modeName);
	_functionName = mode.functionName(minPrecedence, maxPrecedence);

	parseChildren(parser);	
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	typeCheckContents(stable);		
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Stylesheet stylesheet = classGen.getStylesheet();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int current = methodGen.getLocalIndex(""current"");

	
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	
	int init = cpg.addMethodref(SINGLETON_ITERATOR,
				    ""<init>"", ""(""+NODE_SIG+"")V"");
	il.append(new NEW(cpg.addClass(SINGLETON_ITERATOR)));
	il.append(DUP);
	il.append(methodGen.loadCurrentNode());
	il.append(new INVOKESPECIAL(init));

	il.append(methodGen.loadHandler());

	
	final String className = classGen.getStylesheet().getClassName();
	final String signature = classGen.getApplyTemplatesSig();
	final int applyTemplates = cpg.addMethodref(className,
						    _functionName,
						    signature);
	il.append(new INVOKEVIRTUAL(applyTemplates));
    }

}
"
org.apache.xpath.functions.FunctionMultiArgs,9,6,1,9,24,6,2,8,8,0.375,218,0.0,1,0.888888889,0.355555556,5,22,23.11111111,7,2.3333,1,"
package org.apache.xpath.functions;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.res.XPATHErrorResources;


public class FunctionMultiArgs extends Function3Args
{

  
  Expression[] m_args;
  
  
  public Expression[] getArgs()
  {
    return m_args;
  }

  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {

    if (argNum < 3)
      super.setArg(arg, argNum);
    else
    {
      if (null == m_args)
      {
        m_args = new Expression[1];
        m_args[0] = arg;
      }
      else
      {

        
        Expression[] args = new Expression[m_args.length + 1];

        System.arraycopy(m_args, 0, args, 0, m_args.length);

        args[m_args.length] = arg;
        m_args = args;
      }
      arg.exprSetParent(this);
    }
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    if(null != m_args)
    {
      for (int i = 0; i < m_args.length; i++) 
      {
        m_args[i].fixupVariables(vars, globalsSize);
      }
    }
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException{}

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
    String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ ""Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called."" });

    throw new RuntimeException(fMsg);
  }

  
  public boolean canTraverseOutsideSubtree()
  {

    if (super.canTraverseOutsideSubtree())
      return true;
    else
    {
      int n = m_args.length;

      for (int i = 0; i < n; i++)
      {
        if (m_args[i].canTraverseOutsideSubtree())
          return true;
      }

      return false;
    }
  }
  
  class ArgMultiOwner implements ExpressionOwner
  {
  	int m_argIndex;
  	
  	ArgMultiOwner(int index)
  	{
  		m_argIndex = index;
  	}
  	
    
    public Expression getExpression()
    {
      return m_args[m_argIndex];
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(FunctionMultiArgs.this);
    	m_args[m_argIndex] = exp;
    }
  }

   
    
    public void callArgVisitors(XPathVisitor visitor)
    {
      super.callArgVisitors(visitor);
      if (null != m_args)
      {
        int n = m_args.length;
        for (int i = 0; i < n; i++)
        {
          m_args[i].callVisitors(new ArgMultiOwner(i), visitor);
        }
      }
    }
    
    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
            return false;

      FunctionMultiArgs fma = (FunctionMultiArgs) expr;
      if (null != m_args)
      {
        int n = m_args.length;
        if ((null == fma) || (fma.m_args.length != n))
              return false;

        for (int i = 0; i < n; i++)
        {
          if (!m_args[i].deepEquals(fma.m_args[i]))
                return false;
        }

      }
      else if (null != fma.m_args)
      {
          return false;
      }

      return true;
    }
}
"
org.apache.xml.dtm.Axis,1,1,0,4,1,0,4,0,0,2.0,111,0.0,0,0.0,0.0,0,0,88.0,0,0.0,0,"
package org.apache.xml.dtm;


public interface Axis
{

  
  public static final int ANCESTOR = 0;

  
  public static final int ANCESTORORSELF = 1;

  
  public static final int ATTRIBUTE = 2;

  
  public static final int CHILD = 3;

  
  public static final int DESCENDANT = 4;

  
  public static final int DESCENDANTORSELF = 5;

  
  public static final int FOLLOWING = 6;

  
  public static final int FOLLOWINGSIBLING = 7;

  
  public static final int NAMESPACEDECLS = 8;

  
  public static final int NAMESPACE = 9;

  
  public static final int PARENT = 10;

  
  public static final int PRECEDING = 11;

  
  public static final int PRECEDINGSIBLING = 12;

  
  public static final int SELF = 13;

  
  public static final int ALLFROMNODE = 14;

  
  public static final int PRECEDINGANDANCESTOR = 15;
  
  
  
  
  
  public static final int ALL = 16;

  
  public static final int DESCENDANTSFROMROOT = 17;

  
  public static final int DESCENDANTSORSELFFROMROOT = 18;

  
  public static final int ROOT = 19;

  
  public static final int FILTEREDLIST = 20;


  
  public static final String[] names =
  {
    ""ancestor"",  
    ""ancestor-or-self"",  
    ""attribute"",  
    ""child"",  
    ""descendant"",  
    ""descendant-or-self"",  
    ""following"",  
    ""following-sibling"",  
    ""namespace-decls"",  
    ""namespace"",  
    ""parent"",  
    ""preceding"",  
    ""preceding-sibling"",  
    ""self"",  
    ""all-from-node"",  
    ""preceding-and-ancestor"",  
    ""all"",  
    ""descendants-from-root"",  
    ""descendants-or-self-from-root"",  
    ""root"",  
    ""filtered-list""  
  };
}
"
org.apache.xalan.xsltc.trax.TransformerImpl,33,2,0,23,149,280,4,20,19,0.890625,1704,1.0,5,0.295454545,0.140151515,0,0,50.03030303,20,2.8182,8,"

package org.apache.xalan.xsltc.trax;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.Reader;
import java.io.Writer;
import java.net.URL;
import java.net.URLConnection;
import java.net.UnknownServiceException;
import java.util.Enumeration;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.DOMCache;
import org.apache.xalan.xsltc.StripFilter;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.dom.DOMWSFilter;
import org.apache.xalan.xsltc.dom.SAXImpl;
import org.apache.xalan.xsltc.dom.XSLTCDTMManager;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.runtime.Hashtable;
import org.apache.xalan.xsltc.runtime.output.TransletOutputHandlerFactory;
import org.apache.xml.dtm.DTMWSFilter;

import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;
import org.xml.sax.ext.LexicalHandler;

public final class TransformerImpl extends Transformer
    implements DOMCache, ErrorListener
{
    private final static String EMPTY_STRING = """";
    private final static String NO_STRING    = ""no"";
    private final static String YES_STRING   = ""yes"";
    private final static String XML_STRING   = ""xml"";

    private final static String LEXICAL_HANDLER_PROPERTY =
	""http:
    private static final String NAMESPACE_FEATURE =
	""http:
    
    
    private AbstractTranslet _translet = null;

    
    private String _method = null;

    
    private String _encoding = null;

    
    private String _sourceSystemId = null;

    
    private ErrorListener _errorListener = this;

    
    private URIResolver _uriResolver = null;

    
    private Properties _properties, _propertiesClone;

    
    private TransletOutputHandlerFactory _tohFactory = null;

    
    private DOM _dom = null;

    
    private int _indentNumber;

    
    private TransformerFactoryImpl _tfactory = null;
    
    
    

    
    private boolean _isIdentity = false;

    
    private Hashtable _parameters = null;

    
    static class MessageHandler 
           extends org.apache.xalan.xsltc.runtime.MessageHandler 
    {
	private ErrorListener _errorListener;
     
	public MessageHandler(ErrorListener errorListener) {
	    _errorListener = errorListener;
	}
     
	public void displayMessage(String msg) {
	    if(_errorListener == null) {
		System.err.println(msg); 
	    }
	    else {
		try {
		    _errorListener.warning(new TransformerException(msg));
		}
		catch (TransformerException e) {
		    
		}
	    }
	}
    }

    protected TransformerImpl(Properties outputProperties, int indentNumber, 
	TransformerFactoryImpl tfactory) 
    {
	this(null, outputProperties, indentNumber, tfactory);
	_isIdentity = true;
	
    }

    protected TransformerImpl(Translet translet, Properties outputProperties,
	int indentNumber, TransformerFactoryImpl tfactory) 
    {
	_translet = (AbstractTranslet) translet;
	_properties = createOutputProperties(outputProperties);
	_propertiesClone = (Properties) _properties.clone();
	_indentNumber = indentNumber;
	_tfactory = tfactory;
	
    }

    
    protected AbstractTranslet getTranslet() {
	return _translet;
    }

    public boolean isIdentity() {
	return _isIdentity;
    }

    
    public void transform(Source source, Result result)
	throws TransformerException 
    {
	if (!_isIdentity) {
	    if (_translet == null) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_TRANSLET_ERR);
		throw new TransformerException(err.toString());
	    }
	    
	    transferOutputProperties(_translet);
	}
	    
	final SerializationHandler toHandler = getOutputHandler(result);
	if (toHandler == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_HANDLER_ERR);
	    throw new TransformerException(err.toString());
	}

	if (_uriResolver != null && !_isIdentity) {
	    _translet.setDOMCache(this);
	}

	
	if (_isIdentity) {
	    transferOutputProperties(toHandler);
	}

	transform(source, toHandler, _encoding);

	if (result instanceof DOMResult) {
	    ((DOMResult)result).setNode(_tohFactory.getNode());
	}
    }

    
    public SerializationHandler getOutputHandler(Result result) 
	throws TransformerException 
    {
	
	_method = (String) _properties.get(OutputKeys.METHOD);

	
	_encoding = (String) _properties.getProperty(OutputKeys.ENCODING);

	_tohFactory = TransletOutputHandlerFactory.newInstance();
	_tohFactory.setEncoding(_encoding);
	if (_method != null) {
	    _tohFactory.setOutputMethod(_method);
	}

	
	if (_indentNumber >= 0) {
	    _tohFactory.setIndentNumber(_indentNumber);
	}

	
	try {
	    
	    if (result instanceof SAXResult) {
                final SAXResult target = (SAXResult)result;
                final ContentHandler handler = target.getHandler();

		_tohFactory.setHandler(handler);
		if (handler instanceof LexicalHandler) {
		    _tohFactory.setLexicalHandler((LexicalHandler) handler);
		}
		_tohFactory.setOutputType(TransletOutputHandlerFactory.SAX);
		return _tohFactory.getSerializationHandler();
            }
	    else if (result instanceof DOMResult) {
		_tohFactory.setNode(((DOMResult) result).getNode());
		_tohFactory.setOutputType(TransletOutputHandlerFactory.DOM);
		return _tohFactory.getSerializationHandler();
            }
	    else if (result instanceof StreamResult) {
		
		final StreamResult target = (StreamResult) result;	

		
		
		

		_tohFactory.setOutputType(TransletOutputHandlerFactory.STREAM);

		
		final Writer writer = target.getWriter();
		if (writer != null) {
		    _tohFactory.setWriter(writer);
		    return _tohFactory.getSerializationHandler();
		}

		
		final OutputStream ostream = target.getOutputStream();
		if (ostream != null) {
		    _tohFactory.setOutputStream(ostream);
		    return _tohFactory.getSerializationHandler();
		}

		
		String systemId = result.getSystemId();
		if (systemId == null) {
		    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_RESULT_ERR);
                    throw new TransformerException(err.toString());
		}

		
		
		
		URL url = null;
		if (systemId.startsWith(""file:"")) {
                    url = new URL(systemId);
		    _tohFactory.setOutputStream(
			new FileOutputStream(url.getFile()));
		    return _tohFactory.getSerializationHandler();
                }
                else if (systemId.startsWith(""http:"")) {
                    url = new URL(systemId);
                    final URLConnection connection = url.openConnection();
		    _tohFactory.setOutputStream(connection.getOutputStream());
		    return _tohFactory.getSerializationHandler();
                }
                else {
                    
                    url = new File(systemId).toURL();
		    _tohFactory.setOutputStream(
			new FileOutputStream(url.getFile()));
		    return _tohFactory.getSerializationHandler();
                }
	    }
	}
        
        catch (UnknownServiceException e) {
            throw new TransformerException(e);
        }
        catch (ParserConfigurationException e) {
            throw new TransformerException(e);
        }
        
        catch (IOException e) {
            throw new TransformerException(e);
        }
	return null;
    }

    
    protected void setDOM(DOM dom) {
	_dom = dom;
    }

    
    private DOM getDOM(Source source, int mask)
	throws TransformerException {
	try {
	    DOM dom = null;
	    SAXImpl saxImpl = null;
	    DTMWSFilter wsfilter;
	    if (_translet != null && _translet instanceof StripFilter) {
	        wsfilter = new DOMWSFilter(_translet);
            } else {
	        wsfilter = null;
            }
            
            boolean hasIdCall = (_translet != null) ? _translet.hasIdCall() 
                                                      : false;
	    
	    if (source != null) {
		_sourceSystemId = source.getSystemId();
	    }

	    if (source instanceof SAXSource) {
		
		final SAXSource sax = (SAXSource)source;
		XMLReader reader = sax.getXMLReader();
		final InputSource input = sax.getInputSource();
                final boolean hasUserReader = reader != null;

		
		if (reader == null) {
		    reader = _tfactory.getXMLReader();
		}

		
		
		XSLTCDTMManager dtmManager = XSLTCDTMManager.newInstance();

                
		saxImpl = (SAXImpl)dtmManager.getDTM(sax, false, wsfilter, true, false,
                                                 hasUserReader, 0, hasIdCall);
		
		try {
		    reader.setProperty(LEXICAL_HANDLER_PROPERTY, saxImpl);
		}
		catch (SAXException e) {
		    
		}
		reader.setContentHandler(saxImpl);
		reader.setDTDHandler(saxImpl);
		saxImpl.setDocumentURI(_sourceSystemId);
	    }
	    else if (source instanceof DOMSource) {
		
		XSLTCDTMManager dtmManager = XSLTCDTMManager.newInstance();
    
                
		saxImpl = (SAXImpl)dtmManager.getDTM(source, false, wsfilter, true,
                                                 false, hasIdCall);
		saxImpl.setDocumentURI(_sourceSystemId);
	    }
	    
	    else if (source instanceof StreamSource) {
		
		final StreamSource stream = (StreamSource)source;
		final InputStream streamInput = stream.getInputStream();
		final Reader streamReader = stream.getReader();
		final XMLReader reader = _tfactory.getXMLReader();

		
		
		XSLTCDTMManager dtmManager = XSLTCDTMManager.newInstance();

		
		
		InputSource input;
		if (streamInput != null) {
		    input = new InputSource(streamInput);
		    input.setSystemId(_sourceSystemId);
		}
		else if (streamReader != null) {
		    input = new InputSource(streamReader);
		    input.setSystemId(_sourceSystemId);
		}
		else if (_sourceSystemId != null)
		    input = new InputSource(_sourceSystemId);
		else {
		    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
		    throw new TransformerException(err.toString());
		}
		saxImpl = (SAXImpl)dtmManager.getDTM(new SAXSource(reader, input),
                                                 false, wsfilter, true,
                                                 false, hasIdCall);
		saxImpl.setDocumentURI(_sourceSystemId);
	    }
	    else if (source instanceof XSLTCSource) {
		final XSLTCSource xsltcsrc = (XSLTCSource)source;
		dom = xsltcsrc.getDOM();
	    }
	    
	    else if (_dom != null) {
		dom = _dom; _dom = null;   
	    }
	    else {
		return null;
	    }

	    if (saxImpl != null) {
	        dom = saxImpl;
	    }
	    
	    if (!_isIdentity) {
                
                
		_translet.prepassDocument(dom);
	    }
	    	    
	    return dom;

	}
	



	







	catch (Exception e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
    }
 
    private void transformIdentity(Source source, SerializationHandler handler)
	throws Exception 
    {
	
	if (source != null) {
	    _sourceSystemId = source.getSystemId();
	}

	if (source instanceof StreamSource) {
	    final StreamSource stream = (StreamSource) source;
	    final InputStream streamInput = stream.getInputStream();
	    final Reader streamReader = stream.getReader();
	    final XMLReader reader = _tfactory.getXMLReader();

	    
	    try {
		reader.setProperty(LEXICAL_HANDLER_PROPERTY, handler);
	    }
	    catch (SAXException e) {
		
	    }
	    reader.setContentHandler(handler);

	    
	    InputSource input;
	    if (streamInput != null) {
		input = new InputSource(streamInput);
		input.setSystemId(_sourceSystemId); 
	    } 
	    else if (streamReader != null) {
		input = new InputSource(streamReader);
		input.setSystemId(_sourceSystemId); 
	    } 
	    else if (_sourceSystemId != null) {
		input = new InputSource(_sourceSystemId);
	    } 
	    else {
		ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
		throw new TransformerException(err.toString());
	    }

	    
	    reader.parse(input);
	}
	else if (source instanceof SAXSource) {
	    final SAXSource sax = (SAXSource) source;
	    XMLReader reader = sax.getXMLReader();
	    final InputSource input = sax.getInputSource();

	    
	    if (reader == null) {
		reader = _tfactory.getXMLReader();
	    }

	    
	    try {
		reader.setProperty(LEXICAL_HANDLER_PROPERTY, handler);
	    }
	    catch (SAXException e) {
		
	    }
	    reader.setContentHandler(handler);

	    
	    reader.parse(input);
	}
	else if (source instanceof DOMSource) {
	    final DOMSource domsrc = (DOMSource) source;
	    new DOM2TO(domsrc.getNode(), handler).parse();
	}
	else if (source instanceof XSLTCSource) {
	    final DOM dom = ((XSLTCSource) source).getDOM();
	    ((SAXImpl)dom).copy(handler);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
	    throw new TransformerException(err.toString());
	}
    }

    
    private void transform(Source source, SerializationHandler handler, 
	String encoding) throws TransformerException 
    {
	try {
	    if (_isIdentity) {
		transformIdentity(source, handler);
	    }
	    else {
		_translet.transform(getDOM(source, 0), handler);
	    }
	}
	catch (TransletException e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
	catch (RuntimeException e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
	catch (Exception e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
    }

    
    public ErrorListener getErrorListener() {  
	return _errorListener; 
    }

    
    public void setErrorListener(ErrorListener listener)
	throws IllegalArgumentException {
        if (listener == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ERROR_LISTENER_NULL_ERR,
					""Transformer"");
            throw new IllegalArgumentException(err.toString());
	}
        _errorListener = listener;
        
	
    if (_translet != null)
    	_translet.setMessageHandler(new MessageHandler(_errorListener));
    }

    
    private void postErrorToListener(String message) {
        try {
            _errorListener.error(new TransformerException(message));
	}
	catch (TransformerException e) {
            
        }
    }

    
    private void postWarningToListener(String message) {
        try {
            _errorListener.warning(new TransformerException(message));
        }
	catch (TransformerException e) {
            
        }
    }

    
    private String makeCDATAString(Hashtable cdata) {
	
	if (cdata == null) return null;

	StringBuffer result = new StringBuffer();

	
	Enumeration elements = cdata.keys();
	if (elements.hasMoreElements()) {
	    result.append((String)elements.nextElement());
	    while (elements.hasMoreElements()) {
		String element = (String)elements.nextElement();
		result.append(' ');
		result.append(element);
	    }
	}
	
	return(result.toString());
    }

    
    public Properties getOutputProperties() { 
	return (Properties) _properties.clone();
    }

    
    public String getOutputProperty(String name)
	throws IllegalArgumentException 
    {
	if (!validOutputProperty(name)) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
	    throw new IllegalArgumentException(err.toString());
	}
	return _properties.getProperty(name);
    }

    
    public void setOutputProperties(Properties properties) 
	throws IllegalArgumentException 
    {
	if (properties != null) {
	    final Enumeration names = properties.propertyNames();

	    while (names.hasMoreElements()) {
		final String name = (String) names.nextElement();

		
		if (isDefaultProperty(name, properties)) continue;

		if (validOutputProperty(name)) {
		    _properties.setProperty(name, properties.getProperty(name));
		}
		else {
		    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
		    throw new IllegalArgumentException(err.toString());
		}
	    }
	}
	else {
	    _properties = _propertiesClone;
	}
    }

    
    public void setOutputProperty(String name, String value)
	throws IllegalArgumentException 
    {
	if (!validOutputProperty(name)) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
	    throw new IllegalArgumentException(err.toString());
	}
	_properties.setProperty(name, value);
    }

    
    private void transferOutputProperties(AbstractTranslet translet)
    {
	
	if (_properties == null) return;

	
	Enumeration names = _properties.propertyNames();
	while (names.hasMoreElements()) {
	    
	    String name  = (String) names.nextElement();
	    String value = (String) _properties.get(name);

	    
	    if (value == null) continue;

	    
	    if (name.equals(OutputKeys.ENCODING)) {
		translet._encoding = value;
	    }
	    else if (name.equals(OutputKeys.METHOD)) {
		translet._method = value;
	    }
	    else if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {
		translet._doctypePublic = value;
	    }
	    else if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {
		translet._doctypeSystem = value;
	    }
	    else if (name.equals(OutputKeys.MEDIA_TYPE)) {
		translet._mediaType = value;
	    }
	    else if (name.equals(OutputKeys.STANDALONE)) {
		translet._standalone = value;
	    }
	    else if (name.equals(OutputKeys.VERSION)) {
		translet._version = value;
	    }
	    else if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {
		translet._omitHeader = 
		    (value != null && value.toLowerCase().equals(""yes""));
	    }
	    else if (name.equals(OutputKeys.INDENT)) {
		translet._indent = 
		    (value != null && value.toLowerCase().equals(""yes""));
	    }
	    else if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {
		if (value != null) {
		    translet._cdata = null; 
		    StringTokenizer e = new StringTokenizer(value);
		    while (e.hasMoreTokens()) {
			translet.addCdataElement(e.nextToken());
		    }
		}
	    }
	}
    }

    
    public void transferOutputProperties(SerializationHandler handler)
    {
	
	if (_properties == null) return;

	String doctypePublic = null;
	String doctypeSystem = null;

	
	Enumeration names = _properties.propertyNames();
	while (names.hasMoreElements()) {
	    
	    String name  = (String) names.nextElement();
	    String value = (String) _properties.get(name);

	    
	    if (value == null) continue;

	    
	    if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {
		doctypePublic = value;
	    }
	    else if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {
		doctypeSystem = value;
	    }
	    else if (name.equals(OutputKeys.MEDIA_TYPE)) {
		handler.setMediaType(value);
	    }
	    else if (name.equals(OutputKeys.STANDALONE)) {
		handler.setStandalone(value);
	    }
	    else if (name.equals(OutputKeys.VERSION)) {
		handler.setVersion(value);
	    }
	    else if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {
		handler.setOmitXMLDeclaration(
		    value != null && value.toLowerCase().equals(""yes""));
	    }
	    else if (name.equals(OutputKeys.INDENT)) {
		handler.setIndent( 
		    value != null && value.toLowerCase().equals(""yes""));
	    }
	    else if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {
		if (value != null) {
		    StringTokenizer e = new StringTokenizer(value);
                    Vector uriAndLocalNames = null;
		    while (e.hasMoreTokens()) {
			final String token = e.nextToken();

                        
                        
                        int lastcolon = token.lastIndexOf(':');
                        String uri;
                        String localName;
                        if (lastcolon > 0) {
                            uri = token.substring(0, lastcolon);
                            localName = token.substring(lastcolon+1);
                        } else {
                            
                            
                            uri = null;
                            localName = token;
                        }

                        if (uriAndLocalNames == null) {
                            uriAndLocalNames = new Vector();
                        }
                        
                        uriAndLocalNames.addElement(uri);
                        uriAndLocalNames.addElement(localName);
                    }
                    handler.setCdataSectionElements(uriAndLocalNames);
		}
	    }
	}

	
	if (doctypePublic != null || doctypeSystem != null) {
	    handler.setDoctype(doctypeSystem, doctypePublic);
	}
    }

    
    private Properties createOutputProperties(Properties outputProperties) {
	final Properties defaults = new Properties();
	defaults.setProperty(OutputKeys.ENCODING, ""UTF-8"");
	defaults.setProperty(OutputKeys.METHOD, XML_STRING);
	defaults.setProperty(OutputKeys.INDENT, NO_STRING);
	defaults.setProperty(OutputKeys.MEDIA_TYPE, ""text/xml"");
	defaults.setProperty(OutputKeys.OMIT_XML_DECLARATION, NO_STRING);
	defaults.setProperty(OutputKeys.STANDALONE, NO_STRING);
	defaults.setProperty(OutputKeys.VERSION, ""1.0"");

	
	final Properties base = new Properties(defaults);
	if (outputProperties != null) {
	    final Enumeration names = outputProperties.propertyNames();
	    while (names.hasMoreElements()) {
		final String name = (String) names.nextElement();
		base.setProperty(name, outputProperties.getProperty(name));
	    }
	}
	else {
	    base.setProperty(OutputKeys.ENCODING, _translet._encoding);
	    if (_translet._method != null)
	        base.setProperty(OutputKeys.METHOD, _translet._method);
	}

	
	final String method = base.getProperty(OutputKeys.METHOD);
	if (method != null) {
	    if (method.equals(""html"")) {
		defaults.setProperty(OutputKeys.INDENT, ""yes"");
		defaults.setProperty(OutputKeys.VERSION, ""4.0"");
		defaults.setProperty(OutputKeys.MEDIA_TYPE, ""text/html"");
	    }
	    else if (method.equals(""text"")) {
		defaults.setProperty(OutputKeys.MEDIA_TYPE, ""text/plain"");
	    }
	}

	return base; 
    }

    
    private boolean validOutputProperty(String name) {
	return (name.equals(OutputKeys.ENCODING) ||
		name.equals(OutputKeys.METHOD) ||
		name.equals(OutputKeys.INDENT) ||
		name.equals(OutputKeys.DOCTYPE_PUBLIC) ||
		name.equals(OutputKeys.DOCTYPE_SYSTEM) ||
		name.equals(OutputKeys.CDATA_SECTION_ELEMENTS) ||
		name.equals(OutputKeys.MEDIA_TYPE) ||
		name.equals(OutputKeys.OMIT_XML_DECLARATION)   ||
		name.equals(OutputKeys.STANDALONE) ||
		name.equals(OutputKeys.VERSION) ||
		name.charAt(0) == '{');
    }

    
    private boolean isDefaultProperty(String name, Properties properties) {
	return (properties.get(name) == null);
    }

    
    public void setParameter(String name, Object value) { 
	if (_isIdentity) {
	    if (_parameters == null) {
		_parameters = new Hashtable();
	    }
	    _parameters.put(name, value);
	}
	else {
	    _translet.addParameter(name, value);
	}
    }

    
    public void clearParameters() {  
	if (_isIdentity && _parameters != null) {
	    _parameters.clear();
	}
	else {
	    _translet.clearParameters();
	}
    }

    
    public final Object getParameter(String name) {
	if (_isIdentity) {
	    return (_parameters != null) ? _parameters.get(name) : null;
	}
	else {
	    return _translet.getParameter(name);
	}
    }

    
    public URIResolver getURIResolver() {
	return _uriResolver;
    }

    
    public void setURIResolver(URIResolver resolver) { 
	_uriResolver = resolver;
    }

    
    public DOM retrieveDocument(String uri, int mask, Translet translet) {
	try {
	    return getDOM(_uriResolver.resolve(uri, _sourceSystemId), mask);
	}
	catch (TransformerException e) {
	    if (_errorListener != null)
		postErrorToListener(""File not found: "" + e.getMessage());
	    return(null);
	}
    }
    
    
    public void error(TransformerException e)
	throws TransformerException 
    {
        Throwable wrapped = e.getException();
        if (wrapped != null) {
            System.err.println(new ErrorMsg(ErrorMsg.ERROR_PLUS_WRAPPED_MSG,
                                            e.getMessageAndLocation(),
                                            wrapped.getMessage()));
        } else {
            System.err.println(new ErrorMsg(ErrorMsg.ERROR_MSG,
                                            e.getMessageAndLocation()));
        }
        throw e;
    }

    
    public void fatalError(TransformerException e)
	throws TransformerException 
    {
        Throwable wrapped = e.getException();
        if (wrapped != null) {
            System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_PLUS_WRAPPED_MSG,
                                            e.getMessageAndLocation(),
                                            wrapped.getMessage()));
        } else {
            System.err.println(new ErrorMsg(ErrorMsg.FATAL_ERR_MSG,
                                            e.getMessageAndLocation()));
        }
        throw e;
    }

    
    public void warning(TransformerException e)
	throws TransformerException 
    {
        Throwable wrapped = e.getException();
        if (wrapped != null) {
            System.err.println(new ErrorMsg(ErrorMsg.WARNING_PLUS_WRAPPED_MSG,
                                            e.getMessageAndLocation(),
                                            wrapped.getMessage()));
        } else {
            System.err.println(new ErrorMsg(ErrorMsg.WARNING_MSG,
                                            e.getMessageAndLocation()));
        }
    }

}
"
org.apache.xpath.functions.FuncId,3,4,0,11,27,3,0,11,2,2.0,169,0.0,0,0.96,0.476190476,1,7,55.33333333,8,3.0,1,"
package org.apache.xpath.functions;

import java.util.StringTokenizer;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.StringVector;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;


public class FuncId extends FunctionOneArg
{

  
  private StringVector getNodesByID(XPathContext xctxt, int docContext,
                                    String refval, StringVector usedrefs,
                                    NodeSetDTM nodeSet, boolean mayBeMore)
  {

    if (null != refval)
    {
      String ref = null;

      StringTokenizer tokenizer = new StringTokenizer(refval);
      boolean hasMore = tokenizer.hasMoreTokens();
      DTM dtm = xctxt.getDTM(docContext);

      while (hasMore)
      {
        ref = tokenizer.nextToken();
        hasMore = tokenizer.hasMoreTokens();

        if ((null != usedrefs) && usedrefs.contains(ref))
        {
          ref = null;

          continue;
        }

        int node = dtm.getElementById(ref);

        if (DTM.NULL != node)
          nodeSet.addNodeInDocOrder(node, xctxt);

        if ((null != ref) && (hasMore || mayBeMore))
        {
          if (null == usedrefs)
            usedrefs = new StringVector();

          usedrefs.addElement(ref);
        }
      }
    }

    return usedrefs;
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    int docContext = dtm.getDocument();

    if (DTM.NULL == docContext)
      error(xctxt, XPATHErrorResources.ER_CONTEXT_HAS_NO_OWNERDOC, null);

    XObject arg = m_arg0.execute(xctxt);
    int argType = arg.getType();
    XNodeSet nodes = new XNodeSet(xctxt.getDTMManager());
    NodeSetDTM nodeSet = nodes.mutableNodeset();

    if (XObject.CLASS_NODESET == argType)
    {
      DTMIterator ni = arg.iter();
      StringVector usedrefs = null;
      int pos = ni.nextNode();

      while (DTM.NULL != pos)
      {
        DTM ndtm = ni.getDTM(pos);
        String refval = ndtm.getStringValue(pos).toString();

        pos = ni.nextNode();
        usedrefs = getNodesByID(xctxt, docContext, refval, usedrefs, nodeSet,
                                DTM.NULL != pos);
      }
      
    }
    else if (XObject.CLASS_NULL == argType)
    {
      return nodes;
    }
    else
    {
      String refval = arg.str();

      getNodesByID(xctxt, docContext, refval, null, nodeSet, false);
    }

    return nodes;
  }
}
"
org.apache.xml.dtm.ref.sax2dtm.SAX2RTFDTM,9,5,0,11,32,8,2,9,8,0.78125,392,0.25,6,0.954285714,0.26984127,2,20,41.66666667,10,2.8889,1,"
package org.apache.xml.dtm.ref.sax2dtm;

import javax.xml.transform.Source;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.IntVector;
import org.apache.xml.utils.StringVector;
import org.apache.xml.utils.XMLStringFactory;

import org.xml.sax.SAXException;


public class SAX2RTFDTM extends SAX2DTM
{
  
  private static final boolean DEBUG = false;
  
  
  private int m_currentDocumentNode=NULL;
  
  
  IntStack mark_size=new IntStack();
  
  IntStack mark_data_size=new IntStack();
  
  IntStack mark_char_size=new IntStack();
  
  IntStack mark_doq_size=new IntStack();
  
  IntStack mark_nsdeclset_size=new IntStack();
  
  IntStack mark_nsdeclelem_size=new IntStack();
  
  public SAX2RTFDTM(DTMManager mgr, Source source, int dtmIdentity,
                 DTMWSFilter whiteSpaceFilter,
                 XMLStringFactory xstringfactory,
                 boolean doIndexing)
  {
    super(mgr, source, dtmIdentity, whiteSpaceFilter, 
          xstringfactory, doIndexing);
          
    
    
    m_useSourceLocationProperty=false; 
    m_sourceSystemId = (m_useSourceLocationProperty) ? new StringVector() : null;
 	m_sourceLine = (m_useSourceLocationProperty) ?  new IntVector() : null;
    m_sourceColumn = (m_useSourceLocationProperty) ?  new IntVector() : null;
    
  }
  
  
  public int getDocument()
  {
    return makeNodeHandle(m_currentDocumentNode);
  }

  
  public int getDocumentRoot(int nodeHandle)
  {
    for(int id=makeNodeIdentity(nodeHandle);
		id!=NULL;
		id=_parent(id))
		if(_type(id)==DTM.DOCUMENT_NODE)
  			return makeNodeHandle(id);

    return DTM.NULL; 
  }
  
  
  protected int _documentRoot(int nodeIdentifier)
  {
  	if(nodeIdentifier==NULL) return NULL;
  	
    for(int parent=_parent(nodeIdentifier);
    	parent!=NULL;
    	nodeIdentifier=parent,parent=_parent(nodeIdentifier))
    	;
    
    return nodeIdentifier;
  }

  
  public void startDocument() throws SAXException
  {
    
    m_endDocumentOccured = false;
    m_prefixMappings = new java.util.Vector();
    m_contextIndexes = new IntStack();
    m_parents = new IntStack();
    
    m_currentDocumentNode=m_size;
    super.startDocument();
  }
  
  
  public void endDocument() throws SAXException
  {
    charactersFlush();

    m_nextsib.setElementAt(NULL,m_currentDocumentNode);

    if (m_firstch.elementAt(m_currentDocumentNode) == NOTPROCESSED)
      m_firstch.setElementAt(NULL,m_currentDocumentNode);

    if (DTM.NULL != m_previous)
      m_nextsib.setElementAt(DTM.NULL,m_previous);

    m_parents = null;
    m_prefixMappings = null;
    m_contextIndexes = null;

    m_currentDocumentNode= NULL; 
    m_endDocumentOccured = true;
  }
  

  
  public void pushRewindMark()
  {
    if(m_indexing || m_elemIndexes!=null) 
      throw new java.lang.NullPointerException(""Coding error; Don't try to mark/rewind an indexed DTM"");

    
    
    mark_size.push(m_size);
    mark_nsdeclset_size.push( (m_namespaceDeclSets==null) ? 0 : m_namespaceDeclSets.size() );
    mark_nsdeclelem_size.push( (m_namespaceDeclSetElements==null) ? 0 : m_namespaceDeclSetElements.size() );
    
    
    mark_data_size.push(m_data.size());
    mark_char_size.push(m_chars.size());
    mark_doq_size.push(m_dataOrQName.size());	
  }
  
  
  public boolean popRewindMark()
  {
    boolean top=mark_size.empty();
    
    m_size=top ? 0 : mark_size.pop();
    m_exptype.setSize(m_size);
    m_firstch.setSize(m_size);
    m_nextsib.setSize(m_size);
    m_prevsib.setSize(m_size);
    m_parent.setSize(m_size);

    m_elemIndexes=null;

    int ds= top ? 0 : mark_nsdeclset_size.pop();
    if (m_namespaceDeclSets!=null)
      m_namespaceDeclSets.setSize(ds);
      
    int ds1= top ? 0 : mark_nsdeclelem_size.pop();
    if (m_namespaceDeclSetElements!=null)
      m_namespaceDeclSetElements.setSize(ds1);
  
    
    m_data.setSize(top ? 0 : mark_data_size.pop());
    m_chars.setLength(top ? 0 : mark_char_size.pop());
    m_dataOrQName.setSize(top ? 0 : mark_doq_size.pop());

    
    return m_size==0;
  }
  
  
  public boolean isTreeIncomplete()
  {
  	return !m_endDocumentOccured;
  	
  }
}
"
org.apache.xalan.processor.XSLProcessorVersion,3,1,0,2,9,1,2,0,2,1.0,67,0.0,0,0.0,0.5,0,0,19.0,1,0.3333,1,"
package org.apache.xalan.processor;


public class XSLProcessorVersion
{

  
  public static void main(String argv[])
  {
    System.out.println(S_VERSION);
  }

  
  public static final String PRODUCT = ""Xalan"";

  
  public static String LANGUAGE = ""Java"";

  
  public static int VERSION = 2;

  
  public static int RELEASE = 5;

  
  public static int MAINTENANCE = 0;

  
  public static int DEVELOPMENT = 0;
  
  
  public static String S_VERSION = PRODUCT+"" ""+LANGUAGE+"" ""
                                   +VERSION+"".""+RELEASE+"".""
                                   +(DEVELOPMENT > 0 ? (""D""+DEVELOPMENT) 
                                     : (""""+MAINTENANCE));

}
"
org.apache.xalan.templates.ElemSort,15,3,0,7,26,53,2,5,15,0.785714286,164,1.0,5,0.933333333,0.293333333,2,6,9.6,2,1.0,1,"
package org.apache.xalan.templates;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xpath.XPath;

import org.w3c.dom.DOMException;
import org.w3c.dom.Node;


public class ElemSort extends ElemTemplateElement
{

  
  private XPath m_selectExpression = null;

  
  public void setSelect(XPath v)
  {

    if (v.getPatternString().indexOf(""{"") < 0)
      m_selectExpression = v;
    else
      error(XSLTErrorResources.ER_NO_CURLYBRACE, null);
  }

  
  public XPath getSelect()
  {
    return m_selectExpression;
  }

  
  private AVT m_lang_avt = null;

  
  public void setLang(AVT v)
  {
    m_lang_avt = v;
  }

  
  public AVT getLang()
  {
    return m_lang_avt;
  }

  
  private AVT m_dataType_avt = null;

  
  public void setDataType(AVT v)
  {
    m_dataType_avt = v;
  }

  
  public AVT getDataType()
  {
    return m_dataType_avt;
  }

  
  private AVT m_order_avt = null;

  
  public void setOrder(AVT v)
  {
    m_order_avt = v;
  }

  
  public AVT getOrder()
  {
    return m_order_avt;
  }

  
  private AVT m_caseorder_avt = null;

  
  public void setCaseOrder(AVT v)
  {
    m_caseorder_avt = v;
  }

  
  public AVT getCaseOrder()
  {
    return m_caseorder_avt;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_SORT;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_SORT_STRING;
  }

  
  public Node appendChild(Node newChild) throws DOMException
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }
  
  
  public void compose(StylesheetRoot sroot) 
    throws javax.xml.transform.TransformerException
  {
    super.compose(sroot);
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_caseorder_avt)
      m_caseorder_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_dataType_avt)
      m_dataType_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_lang_avt)
      m_lang_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_order_avt)
      m_order_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_selectExpression)
      m_selectExpression.fixupVariables(vnames, cstate.getGlobalsSize());
  }
}
"
org.apache.xalan.templates.ElemExtensionDecl,14,3,0,10,42,27,1,9,14,0.666666667,290,1.0,2,0.937799043,0.25,3,4,19.5,2,1.0714,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.extensions.ExtensionNamespaceSupport;
import org.apache.xalan.extensions.ExtensionNamespacesManager;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.StringVector;


public class ElemExtensionDecl extends ElemTemplateElement
{

  
  public ElemExtensionDecl()
  {

    
  }

  
  private String m_prefix = null;

  
  public void setPrefix(String v)
  {
    m_prefix = v;
  }

  
  public String getPrefix()
  {
    return m_prefix;
  }

  
  private StringVector m_functions = new StringVector();

  
  public void setFunctions(StringVector v)
  {
    m_functions = v;
  }

  
  public StringVector getFunctions()
  {
    return m_functions;
  }

  
  public String getFunction(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_functions)
      throw new ArrayIndexOutOfBoundsException();

    return (String) m_functions.elementAt(i);
  }

  
  public int getFunctionCount()
  {
    return (null != m_functions) ? m_functions.size() : 0;
  }

  
  private StringVector m_elements = null;

  
  public void setElements(StringVector v)
  {
    m_elements = v;
  }

  
  public StringVector getElements()
  {
    return m_elements;
  }

  
  public String getElement(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_elements)
      throw new ArrayIndexOutOfBoundsException();

    return (String) m_elements.elementAt(i);
  }

  
  public int getElementCount()
  {
    return (null != m_elements) ? m_elements.size() : 0;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_EXTENSIONDECL;
  }
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    String prefix = getPrefix();
    String declNamespace = getNamespaceForPrefix(prefix);
    String lang = null;
    String srcURL = null;
    String scriptSrc = null;
    if (null == declNamespace)
      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_NAMESPACE_DECL, new Object[]{prefix})); 
      
    for (ElemTemplateElement child = getFirstChildElem(); child != null;
          child = child.getNextSiblingElem())
    {
      if (Constants.ELEMNAME_EXTENSIONSCRIPT == child.getXSLToken())
      {
        ElemExtensionScript sdecl = (ElemExtensionScript) child;
        lang = sdecl.getLang();
        srcURL = sdecl.getSrc();
        ElemTemplateElement childOfSDecl = sdecl.getFirstChildElem();
        if (null != childOfSDecl)
        {
          if (Constants.ELEMNAME_TEXTLITERALRESULT
                  == childOfSDecl.getXSLToken())
          {
            ElemTextLiteral tl = (ElemTextLiteral) childOfSDecl;
            char[] chars = tl.getChars();
            scriptSrc = new String(chars);
            if (scriptSrc.trim().length() == 0)
              scriptSrc = null;
          }
        }
      }
    }
    if (null == lang)
      lang = ""javaclass"";
    if (lang.equals(""javaclass"") && (scriptSrc != null))
        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_ELEM_CONTENT_NOT_ALLOWED, new Object[]{scriptSrc})); 
        

    
    ExtensionNamespaceSupport extNsSpt = null;
    ExtensionNamespacesManager extNsMgr = sroot.getExtensionNamespacesManager();
    if (extNsMgr.namespaceIndex(declNamespace,
                                extNsMgr.getExtensions()) == -1)
    {
      if (lang.equals(""javaclass""))
      {
        if (null == srcURL)
        {
           extNsSpt = extNsMgr.defineJavaNamespace(declNamespace);
        }
        else if (extNsMgr.namespaceIndex(srcURL,
                                         extNsMgr.getExtensions()) == -1)
        {
          extNsSpt = extNsMgr.defineJavaNamespace(declNamespace, srcURL);
        }
      }
      else  
      {
        String handler = ""org.apache.xalan.extensions.ExtensionHandlerGeneral"";
        Object [] args = {declNamespace, this.m_elements, this.m_functions,
                          lang, srcURL, scriptSrc, getSystemId()};
        extNsSpt = new ExtensionNamespaceSupport(declNamespace, handler, args);
      }
    }
    if (extNsSpt != null)
      extNsMgr.registerExtension(extNsSpt);
  }

  
    
  public void runtimeInit(TransformerImpl transformer) throws TransformerException
  {

  }
}
"
org.apache.xalan.processor.ProcessorAttributeSet,3,4,0,7,19,3,1,6,2,2.0,54,0.0,0,0.990566038,0.666666667,2,3,17.0,1,0.6667,0,"
package org.apache.xalan.processor;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.ElemAttributeSet;
import org.apache.xalan.templates.ElemTemplateElement;

import org.xml.sax.Attributes;


class ProcessorAttributeSet extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    ElemAttributeSet eat = new ElemAttributeSet();

    eat.setLocaterInfo(handler.getLocator());
    try
    {
      eat.setPrefixes(handler.getNamespaceSupport());
    }
    catch(TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }

    eat.setDOMBackPointer(handler.getOriginatingNode());
    setPropertiesFromAttributes(handler, rawName, attributes, eat);
    handler.getStylesheet().setAttributeSet(eat);

    
    ElemTemplateElement parent = handler.getElemTemplateElement();

    parent.appendChild(eat);
    handler.pushElemTemplateElement(eat);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {
    handler.popElemTemplateElement();
  }
}
"
org.apache.xalan.templates.WhiteSpaceInfo,4,4,1,9,8,4,7,4,4,0.666666667,30,1.0,0,0.99086758,0.45,0,0,6.25,1,0.5,0,"
package org.apache.xalan.templates;

import org.apache.xpath.XPath;


public class WhiteSpaceInfo extends ElemTemplate
{

  
  private boolean m_shouldStripSpace;

  
  public boolean getShouldStripSpace()
  {
    return m_shouldStripSpace;
  }
  
  
  public WhiteSpaceInfo(Stylesheet thisSheet)
  {
  	setStylesheet(thisSheet);
  }


  
  public WhiteSpaceInfo(XPath matchPattern, boolean shouldStripSpace, Stylesheet thisSheet)
  {

    m_shouldStripSpace = shouldStripSpace;

    setMatch(matchPattern);

    setStylesheet(thisSheet);
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeWhiteSpaceInfo(this);
  }

}
"
org.apache.xalan.xsltc.cmdline.getopt.GetOpt,5,1,0,6,36,0,3,5,5,0.65,330,1.0,2,0.0,0.466666667,0,0,64.0,3,1.6,0,"

package org.apache.xalan.xsltc.cmdline.getopt; 

import java.util.ArrayList;
import java.util.List;
import java.util.ListIterator;

import org.apache.xalan.xsltc.compiler.util.ErrorMsg;



public class GetOpt{
    public GetOpt(String[] args, String optString){
	theOptions = new ArrayList();		 
	int currOptIndex = 0; 
	theCmdArgs = new ArrayList(); 
	theOptionMatcher = new OptionMatcher(optString);
	
	for(int i=0; i<args.length; i++){
	    String token = args[i];
	    int tokenLength = token.length();
	    if(token.equals(""--"")){	    
	        currOptIndex = i+1;	    
                break;                      
	    }
	    else if(token.startsWith(""-"") && tokenLength == 2){ 
		
		theOptions.add(new Option(token.charAt(1)));	
	    }
	    else if(token.startsWith(""-"") && tokenLength > 2){
		
		
		
		for(int j=1; j<tokenLength; j++){
		    theOptions.add(new Option(token.charAt(j)));
		}
	    }		
	    else if(!token.startsWith(""-"")){
		
		
		if(theOptions.size() == 0){
		    currOptIndex = i;
		    break;		
		}
		else {
		    
		    
		    
		    int indexoflast=0;
		    indexoflast = theOptions.size()-1;
		    Option op = (Option)theOptions.get(indexoflast);
		    char opLetter = op.getArgLetter();
		    if(!op.hasArg() && theOptionMatcher.hasArg(opLetter)){
		        op.setArg(token);
		    }
		    else{
		        
		        
		        
		        
		        
		        currOptIndex = i;
		        break; 			
		    }
	  	}
	    }
	} 

        
	theOptionsIterator = theOptions.listIterator();

	
	for(int i=currOptIndex; i<args.length; i++){
	    String token = args[i];
	    theCmdArgs.add(token);
	}
    }


    
    public void printOptions(){
	for(ListIterator it=theOptions.listIterator(); it.hasNext();){
	    Option opt = (Option)it.next();
	    System.out.print(""OPT ="" + opt.getArgLetter());
	    String arg = opt.getArgument();
	    if(arg != null){
	       System.out.print("" "" + arg);
	    }
	    System.out.println();
	}
    }

    
    public int getNextOption() throws IllegalArgumentException, 
	MissingOptArgException
    {
	int retval = -1;
	if(theOptionsIterator.hasNext()){
	    theCurrentOption = (Option)theOptionsIterator.next();
	    char c = theCurrentOption.getArgLetter();
	    boolean shouldHaveArg = theOptionMatcher.hasArg(c);
	    String arg = theCurrentOption.getArgument();
	    if(!theOptionMatcher.match(c)) {
                ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_CMDLINE_OPTION_ERR,
                                            new Character(c));
		throw (new IllegalArgumentException(msg.toString()));
	    }
	    else if(shouldHaveArg && (arg == null)) {
                ErrorMsg msg = new ErrorMsg(ErrorMsg.CMDLINE_OPT_MISSING_ARG_ERR,
                                            new Character(c));
		throw (new MissingOptArgException(msg.toString()));
	    }
	    retval = c;
	}
	return retval;
    }

    
    public String getOptionArg(){
	String retval = null;
	String tmp = theCurrentOption.getArgument();
	char c = theCurrentOption.getArgLetter();
	if(theOptionMatcher.hasArg(c)){
	    retval = tmp;
	}
	return retval;	
    }

    
    public String[] getCmdArgs(){
	String[] retval = new String[theCmdArgs.size()];
	int i=0;
        for(ListIterator it=theCmdArgs.listIterator(); it.hasNext();){
            retval[i++] = (String)it.next();
        }
	return retval;
    }


    private Option theCurrentOption = null;
    private ListIterator theOptionsIterator; 
    private List theOptions = null;
    private List theCmdArgs = null;
    private OptionMatcher theOptionMatcher = null;

    
    
    
    
    

    
    class Option{
        private char theArgLetter;
        private String theArgument = null;
        public Option(char argLetter) { theArgLetter = argLetter; }
        public void setArg(String arg) { 
	    theArgument = arg;
        }
        public boolean hasArg() { return (theArgument != null); } 
        public char getArgLetter() { return theArgLetter; }
        public String getArgument() { return theArgument; }
    } 


    
    
    
    class OptionMatcher{
        public OptionMatcher(String optString){
	    theOptString = optString;	
        }
        public boolean match(char c){
	    boolean retval = false;
	    if(theOptString.indexOf(c) != -1){
	        retval = true;
	    }
	    return retval;	
        }
        public boolean hasArg(char c){
	    boolean retval = false;
	    int index = theOptString.indexOf(c)+1; 
	    if (index == theOptString.length()){
	        
	        retval = false;
	    }
            else if(theOptString.charAt(index) == ':'){
                retval = true;
            }
            return retval;
        }
        private String theOptString = null;
    } 
}
    
"
org.apache.xml.res.XMLErrorResources_it,3,4,0,1,4,1,0,1,2,1.3,875,0.0,0,0.976190476,1.0,0,0,289.0,1,0.3333,0,"
package org.apache.xml.res;



public class XMLErrorResources_it extends XMLErrorResources
{

  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },
 

 
 


 {
   ER_FUNCTION_NOT_SUPPORTED, ""Funzione non supportata""},
 
 
 


 {
   ER_CANNOT_OVERWRITE_CAUSE,
			""Impossibile sovrascrivere la causa.""},
 
  
 


 {
   ER_NO_DEFAULT_IMPL,
        ""Non è stata trovata alcuna implementazione predefinita ""},

 
  
 


 {
   ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
      ""ChunkedIntArray({0}) non è correntemente supportato.""},

 
  
 


 {
   ER_OFFSET_BIGGER_THAN_SLOT,
      ""L'offset è maggiore dello slot.""},

 
  
 


 {
   ER_COROUTINE_NOT_AVAIL,
      ""Coroutine non disponibile, id={0}""},

 
  
 


 {
   ER_COROUTINE_CO_EXIT,
      ""CoroutineManager ha ricevuto una richiesta co_exit().""},

 
  
 


 {
   ER_COJOINROUTINESET_FAILED,
      ""co_joinCoroutineSet() non riuscito.""},

 
  
 


 {
   ER_COROUTINE_PARAM,
      ""Errore del parametro di coroutine ({0}).""},

 
  
 


 {
   ER_PARSER_DOTERMINATE_ANSWERS,
      ""
UNEXPECTED: Risposte doTerminate del parser {0}""},

 
  
 


 {
   ER_NO_PARSE_CALL_WHILE_PARSING,
      ""Impossibile chiamare l'analisi mentre è in esecuzione.""},

 
  
 


 {
   ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
      ""Errore: tipo di iteratore per l'asse {0} non implementato.""},

 
  
 


 {
   ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
      ""Errore: l'iteratore per l'asse {0} non è implementato. ""},

 
  
 


 {
   ER_ITERATOR_CLONE_NOT_SUPPORTED,
      ""Il duplicato dell'iteratore non è supportato.""},

 
  
 


 {
   ER_UNKNOWN_AXIS_TYPE,
      ""Tipo di asse trasversale sconosciuto : {0}.""},

 
  
 


 {
   ER_AXIS_NOT_SUPPORTED,
      ""Attraversatore dell'asse non supportato: {0}""},

 
  
 


 {
   ER_NO_DTMIDS_AVAIL,
      ""Non sono più disponibili ID DTM.""},

 
  
 


 {
   ER_NOT_SUPPORTED,
      ""Non supportato: {0}""},

 
  
 


 {
   ER_NODE_NON_NULL,
      ""Il nodo deve essere non nullo per getDTMHandleFromNode.""},

 
  
 


 {
   ER_COULD_NOT_RESOLVE_NODE,
      ""Impossibile risolvere il nodo a un handle""},

 
  
 


 {
   ER_STARTPARSE_WHILE_PARSING,
      ""Impossibile chiamare startParse durante l'analisi.""},

 
  
 


 {
   ER_STARTPARSE_NEEDS_SAXPARSER,
      ""startParse richiede un SAXParser non nullo.""},

 
  
 


 {
   ER_COULD_NOT_INIT_PARSER,
      ""Impossibile inizializzare il parser con""},
 
  
 


 {
   ER_EXCEPTION_CREATING_POOL,
      ""l'eccezione crea una nuova istanza del pool""},

 
  
 


 {
   ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
      ""Il percorso contiene una sequenza di escape non valida.""},

 
  
 


 {
   ER_SCHEME_REQUIRED,
      ""Lo schema è necessario.""},

 
  
 


 {
   ER_NO_SCHEME_IN_URI,
      ""Nessuno schema trovato nell'URI: {0}""},

 
  
 


 {
   ER_NO_SCHEME_INURI,
      ""Nessuno schema trovato nell'URI""},

 
  
 


 {
   ER_PATH_INVALID_CHAR,
      ""Il percorso contiene un carattere non valido: {0}""},

 
  
 


 {
   ER_SCHEME_FROM_NULL_STRING,
      ""Impossibile impostare lo schema da una stringa nulla.""},

 
  
 


 {
   ER_SCHEME_NOT_CONFORMANT,
      ""Lo schema non è conforme.""},

 
  
 


 {
   ER_HOST_ADDRESS_NOT_WELLFORMED,
      ""L'host non è un indirizzo corretto.""},

 
  
 


 {
   ER_PORT_WHEN_HOST_NULL,
      ""Impossibile impostare la porta quando l'host è nullo.""},

 
  
 


 {
   ER_INVALID_PORT,
      ""Numero di porta non valido""},

 
  
 


 {
   ER_FRAG_FOR_GENERIC_URI,
      ""È possibile impostare il frammento solo per un URI generico.""},

 
  
 


 {
   ER_FRAG_WHEN_PATH_NULL,
      ""Impossibile impostare il frammento quando il percorso è nullo.""},

 
  
 


 {
   ER_FRAG_INVALID_CHAR,
      ""Il frammento contiene un carattere non valido.""},

 

 
  
 


 {
   ER_PARSER_IN_USE,
       ""Il parser è già in uso.""},

 
  
 


 {
   ER_CANNOT_CHANGE_WHILE_PARSING,
       ""Impossibile cambiare {0} {1} durante l'analisi.""},

 
  
 


 {
   ER_SELF_CAUSATION_NOT_PERMITTED,
       ""Non è consentito essere causa ed effetto contemporaneamente.""},

 
  
 


 {
   ER_NO_USERINFO_IF_NO_HOST,
       ""Impossibile specificare Userinfo se non è specificato l'host.""},

 
  
 


 {
   ER_NO_PORT_IF_NO_HOST,
       ""Impossibile specificare la porta se non è specificato l'host.""},

 
  
 


 {
   ER_NO_QUERY_STRING_IN_PATH,
       ""La stringa di query non può essere specificata nella stringa di percorso e di query.""},

 
  
 


 {
   ER_NO_FRAGMENT_STRING_IN_PATH,
       ""Il frammento non può essere specificato sia nel percorso sia nel frammento.""},

 
  
 


 {
   ER_CANNOT_INIT_URI_EMPTY_PARMS,
       ""Impossibile inizializzare l'URI con parametri vuoti.""},

 
 
 


 {
   ER_METHOD_NOT_SUPPORTED,
       ""Metodo non ancora supportato. ""},


 
 


 {
   ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
    ""IncrementalSAXSource_Filter non correntemente riavviabile.""},

 
 
 


 {
   ER_XMLRDR_NOT_BEFORE_STARTPARSE,
    ""XMLReader non prima della richiesta startParse.""},
  
 
 
   
 
   {
     ER_AXIS_TRAVERSER_NOT_SUPPORTED,
      ""Secante asse non supportata: {0}""},
  
 
 
   
 
   {
     ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
      ""ListingErrorHandler creato con PrintWriter nullo.""},
  
 
   
 
   {
     ER_SYSTEMID_UNKNOWN,
      ""ID sistema sconosciuto""},
  
 
   
   
 
   {
     ER_LOCATION_UNKNOWN,
      ""Ubicazione errore sconosciuta""},


 
 


 {
   ER_PREFIX_MUST_RESOLVE,
     ""Il prefisso deve risolvere in namespace: {0}""},


 
 


 {
   ER_CREATEDOCUMENT_NOT_SUPPORTED,
     ""createDocument() non supportato in XPathContext.""},


 
 


 {
   ER_CHILD_HAS_NO_OWNER_DOCUMENT,
     ""L'elemento secondario dell'attributo non ha un documento di proprietà.""},


 
 


 {
   ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
     ""L'elemento secondario dell'attributo non ha un elemento del documento di proprietà.""},


 
 


 {
   ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
     ""Avvertenza: impossibile generare un output di testo prima dell'elemento documento. Richiesta ignorata...""},


 
 


 {
   ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
     ""Impossibile avere più di una root su un DOM.""},

 
  
 


 {
   ER_ARG_LOCALNAME_NULL,
      ""L'argomento 'localName' è nullo""},
  

   
   
   
 
   
   
 
 
   {
     ER_ARG_LOCALNAME_INVALID,
        ""Localname in QNAME deve essere un NCName valido""},
  
   
   
   
   
 
   
   
 
 
   {
     ER_ARG_PREFIX_INVALID,
        ""Prefisso in QNAME deve essere un NCName valido""},

   { ""BAD_CODE"",
     ""I parametri di createMessage sono esterni ai limiti""},
   { ""FORMAT_FAILED"",
     ""Eccezione generata durante la chiamata di messageFormat""},
   { ""line"", ""Linea #""},
   { ""column"", ""Colonna #""}
   
   };

 
 public Object[][] getContents()
 {
   return contents;
 }
}"
org.apache.xml.res.XMLErrorResources_ja,3,4,0,1,4,1,0,1,2,1.3,875,0.0,0,0.976190476,1.0,0,0,289.0,1,0.3333,0,"
package org.apache.xml.res;



public class XMLErrorResources_ja extends XMLErrorResources
{

  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },
 


  
  


  {
    ER_FUNCTION_NOT_SUPPORTED, ""Function はサポートされません。""},

  
  
  


  {
    ER_CANNOT_OVERWRITE_CAUSE,
			""cause を上書きできません""},

  
   
  


  {
    ER_NO_DEFAULT_IMPL,
         ""デフォルト実装が見つかりません""},


  
   
  


  {
    ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
       ""ChunkedIntArray({0}) は現在サポートされていません""},


  
   
  


  {
    ER_OFFSET_BIGGER_THAN_SLOT,
       ""スロットよりも大きいオフセット""},


  
   
  


  {
    ER_COROUTINE_NOT_AVAIL,
       ""コルーチンは無効です。id={0}""},


  
   
  


  {
    ER_COROUTINE_CO_EXIT,
       ""CoroutineManager は co_exit() 要求を受け取りました""},


  
   
  


  {
    ER_COJOINROUTINESET_FAILED,
       ""co_joinCoroutineSet() は失敗しました""},


  
   
  


  {
    ER_COROUTINE_PARAM,
       ""コルーチンパラメータエラー ({0})""},


  
   
  


  {
    ER_PARSER_DOTERMINATE_ANSWERS,
       ""
UNEXPECTED: パーサ doTerminate の答え {0}""},

UNEXPECTED: Parser doTerminate answers {0}""},

  
   
  


  {
    ER_NO_PARSE_CALL_WHILE_PARSING,
       ""構文解析中に parse を呼び出すことはできません""},


  
   
  


  {
    ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""エラー: 入力された軸の反復子 {0} は実装されていません""},


  
   
  


  {
    ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""エラー: 軸の反復子 {0} は実装されていません""},


  
   
  


  {
    ER_ITERATOR_CLONE_NOT_SUPPORTED,
       ""反復子クローンはサポートされていません""},


  
   
  


  {
    ER_UNKNOWN_AXIS_TYPE,
       ""未知の軸トラバーサルタイプ: {0}""},


  
   
  


  {
    ER_AXIS_NOT_SUPPORTED,
       ""軸トラバーサルはサポートされません: {0}""},


  
   
  


  {
    ER_NO_DTMIDS_AVAIL,
       ""これ以上の DTM ID は無効です""},


  
   
  


  {
    ER_NOT_SUPPORTED,
       ""サポートされません: {0}""},


  
   
  


  {
    ER_NODE_NON_NULL,
       ""getDTMHandleFromNode のノードは null 以外でなくてはなりません""},


  
   
  


  {
    ER_COULD_NOT_RESOLVE_NODE,
       ""ノードをハンドルに変えることができませんでした""},


  
   
  


  {
    ER_STARTPARSE_WHILE_PARSING,
       ""構文解析中に startParse を呼び出すことはできません""},


  
   
  


  {
    ER_STARTPARSE_NEEDS_SAXPARSER,
       ""startParse は null でない SAXParser を必要とします""},


  
   
  


  {
    ER_COULD_NOT_INIT_PARSER,
       ""パーサを初期化できませんでした""},


  
   
  


  {
    ER_EXCEPTION_CREATING_POOL,
       ""例外によりプールに新しいインスタンスを作成しています""},


  
   
  


  {
    ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
       ""パスに無効なエスケープシーケンスが含まれています""},


  
   
  


  {
    ER_SCHEME_REQUIRED,
       ""スキーマが必要です。""},


  
   
  


  {
    ER_NO_SCHEME_IN_URI,
       ""URI にスキーマがありません: {0}""},


  
   
  


  {
    ER_NO_SCHEME_INURI,
       ""URI にスキーマがありません""},


  
   
  


  {
    ER_PATH_INVALID_CHAR,
       ""パスに無効な文字列が含まれています: {0}""},


  
   
  


  {
    ER_SCHEME_FROM_NULL_STRING,
       ""null 文字列からスキーマを設定できません""},


  
   
  


  {
    ER_SCHEME_NOT_CONFORMANT,
       ""スキーマが一致しません。""},


  
   
  


  {
    ER_HOST_ADDRESS_NOT_WELLFORMED,
       ""ホストが正しい形式のアドレスではありません""},


  
   
  


  {
    ER_PORT_WHEN_HOST_NULL,
       ""ホストが null のとき、ポートを設定できません""},


  
   
  


  {
    ER_INVALID_PORT,
       ""無効なポート番号""},


  
   
  


  {
    ER_FRAG_FOR_GENERIC_URI,
       ""汎用 URI に対してのみフラグメントを設定できます""},


  
   
  


  {
    ER_FRAG_WHEN_PATH_NULL,
       ""パスが null のとき、フラグメントを設定できません""},


  
   
  


  {
    ER_FRAG_INVALID_CHAR,
       ""フラグメントに無効な文字列が含まれています""},


  
 
  
   
  


  {
    ER_PARSER_IN_USE,
        ""パーサはすでに使われています""},


  
   
  


  {
    ER_CANNOT_CHANGE_WHILE_PARSING,
        ""構文解析中、{0} {1} を変更できません""},


  
   
  


  {
    ER_SELF_CAUSATION_NOT_PERMITTED,
        ""自身が原因となってはなりません""},


  
   
  


  {
    ER_NO_USERINFO_IF_NO_HOST,
        ""ホストが指定されていないとき、Userinfo を指定できません""},


  
   
  


  {
    ER_NO_PORT_IF_NO_HOST,
        ""ホストが指定されていないとき、Port を指定できません""},


  
   
  


  {
    ER_NO_QUERY_STRING_IN_PATH,
        ""パスおよび照会文字列で Query 文字列は指定できません""},


  
   
  


  {
    ER_NO_FRAGMENT_STRING_IN_PATH,
        ""パスおよびフラグメントの両方で、Fragment は指定できません""},


  
   
  


  {
    ER_CANNOT_INIT_URI_EMPTY_PARMS,
        ""空のパラメータを使って URI を初期化できません""},

  
  
  


  {
    ER_METHOD_NOT_SUPPORTED,
        ""メソッドはまだサポートされていません""},



  
  


  {
    ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
     ""IncrementalSAXSource_Filter は現在再起動できません""},


  
  
  


  {
    ER_XMLRDR_NOT_BEFORE_STARTPARSE,
     ""XMLReader は startParse 要求より前に配置できません""},




  

  {
    ER_AXIS_TRAVERSER_NOT_SUPPORTED,
     ""▼軸トラバーサルはサポートされません: {0}""},




  

   {
    ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
     ""▼ListingErrorHandler の作成時に null PrintWriter が指定されました!""},



  

  {
    ER_SYSTEMID_UNKNOWN,
     ""▼システム ID が不明です""},



  
  

  {
    ER_LOCATION_UNKNOWN,
     ""▼エラーの場所が不明です""},



  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""接頭辞は名前空間に変える必要があります: {0}""},



  
  


  {
    ER_CREATEDOCUMENT_NOT_SUPPORTED,
      ""createDocument() は XPathContext でサポートされていません。""},



  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT,
      ""属性 child は所有者ドキュメントを保持していません。""},



  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
      ""属性 child は所有者ドキュメント要素を保持していません。""},



  
  


  {
    ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
      ""警告: ドキュメント要素より前にテキストを出力できません。無視します...""},



  
  


  {
    ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
      ""DOM には複数のルートを保持できません。""},


  
   
  


  {
    ER_ARG_LOCALNAME_NULL,
       ""引数 'localName' が null です""},



  
  
  

  
  


  {
    ER_ARG_LOCALNAME_INVALID,
       ""▼QNAME 内のローカル名は有効な NCName でなければなりません""},

  
  
  
  

  
  


  {
    ER_ARG_PREFIX_INVALID,
       ""▼QNAME 内の接頭辞は有効な NCName でなければなりません""},

  { ""BAD_CODE"",
      ""createMessage のパラメータが範囲外でした""},
  { ""FORMAT_FAILED"",
      ""messageFormat 呼び出しで例外がスローされました""},
  { ""line"", ""行番号""},
  { ""column"", ""列番号""}
  
  };

  
  public Object[][] getContents()
  {
    return contents;
  }  
}"
org.apache.xml.utils.XMLChar,23,1,0,2,26,181,2,0,22,0.97979798,3198,0.0,0,0.0,0.25,0,0,137.6521739,17,3.913,1,"

package org.apache.xml.utils;


public class XMLChar {

    
    
    

    
    public static final byte[] CHARS = new byte[1 << 16];

    
    public static final int MASK_VALID = 0x01;

    
    public static final int MASK_SPACE = 0x02;

    
    public static final int MASK_NAME_START = 0x04;

    
    public static final int MASK_NAME = 0x08;

    
    public static final int MASK_PUBID = 0x10;
    
    
    public static final int MASK_CONTENT = 0x20;

    
    public static final int MASK_NCNAME_START = 0x40;

    
    public static final int MASK_NCNAME = 0x80;

    
    
    

    static {
        
        
        
        
        

        int charRange[] = { 
            0x0009, 0x000A, 0x000D, 0x000D, 0x0020, 0xD7FF, 0xE000, 0xFFFD,
        };

        
        
        

        int spaceChar[] = { 
            0x0020, 0x0009, 0x000D, 0x000A,
        };

        
        
        
        

        int nameChar[] = { 
            0x002D, 0x002E, 
        };

        
        
        

        int nameStartChar[] = { 
            0x003A, 0x005F, 
        };

        
        
        

        int pubidChar[] = {
            0x000A, 0x000D, 0x0020, 0x0021, 0x0023, 0x0024, 0x0025, 0x003D,
            0x005F
        };

        int pubidRange[] = {
            0x0027, 0x003B, 0x003F, 0x005A, 0x0061, 0x007A
        };

        
        
        

        int letterRange[] = {
            
            0x0041, 0x005A, 0x0061, 0x007A, 0x00C0, 0x00D6, 0x00D8, 0x00F6,
            0x00F8, 0x0131, 0x0134, 0x013E, 0x0141, 0x0148, 0x014A, 0x017E,
            0x0180, 0x01C3, 0x01CD, 0x01F0, 0x01F4, 0x01F5, 0x01FA, 0x0217,
            0x0250, 0x02A8, 0x02BB, 0x02C1, 0x0388, 0x038A, 0x038E, 0x03A1,
            0x03A3, 0x03CE, 0x03D0, 0x03D6, 0x03E2, 0x03F3, 0x0401, 0x040C,
            0x040E, 0x044F, 0x0451, 0x045C, 0x045E, 0x0481, 0x0490, 0x04C4,
            0x04C7, 0x04C8, 0x04CB, 0x04CC, 0x04D0, 0x04EB, 0x04EE, 0x04F5,
            0x04F8, 0x04F9, 0x0531, 0x0556, 0x0561, 0x0586, 0x05D0, 0x05EA,
            0x05F0, 0x05F2, 0x0621, 0x063A, 0x0641, 0x064A, 0x0671, 0x06B7,
            0x06BA, 0x06BE, 0x06C0, 0x06CE, 0x06D0, 0x06D3, 0x06E5, 0x06E6,
            0x0905, 0x0939, 0x0958, 0x0961, 0x0985, 0x098C, 0x098F, 0x0990,
            0x0993, 0x09A8, 0x09AA, 0x09B0, 0x09B6, 0x09B9, 0x09DC, 0x09DD,
            0x09DF, 0x09E1, 0x09F0, 0x09F1, 0x0A05, 0x0A0A, 0x0A0F, 0x0A10,
            0x0A13, 0x0A28, 0x0A2A, 0x0A30, 0x0A32, 0x0A33, 0x0A35, 0x0A36,
            0x0A38, 0x0A39, 0x0A59, 0x0A5C, 0x0A72, 0x0A74, 0x0A85, 0x0A8B,
            0x0A8F, 0x0A91, 0x0A93, 0x0AA8, 0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3,
            0x0AB5, 0x0AB9, 0x0B05, 0x0B0C, 0x0B0F, 0x0B10, 0x0B13, 0x0B28,
            0x0B2A, 0x0B30, 0x0B32, 0x0B33, 0x0B36, 0x0B39, 0x0B5C, 0x0B5D,
            0x0B5F, 0x0B61, 0x0B85, 0x0B8A, 0x0B8E, 0x0B90, 0x0B92, 0x0B95,
            0x0B99, 0x0B9A, 0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA,
            0x0BAE, 0x0BB5, 0x0BB7, 0x0BB9, 0x0C05, 0x0C0C, 0x0C0E, 0x0C10,
            0x0C12, 0x0C28, 0x0C2A, 0x0C33, 0x0C35, 0x0C39, 0x0C60, 0x0C61,
            0x0C85, 0x0C8C, 0x0C8E, 0x0C90, 0x0C92, 0x0CA8, 0x0CAA, 0x0CB3,
            0x0CB5, 0x0CB9, 0x0CE0, 0x0CE1, 0x0D05, 0x0D0C, 0x0D0E, 0x0D10,
            0x0D12, 0x0D28, 0x0D2A, 0x0D39, 0x0D60, 0x0D61, 0x0E01, 0x0E2E,
            0x0E32, 0x0E33, 0x0E40, 0x0E45, 0x0E81, 0x0E82, 0x0E87, 0x0E88,
            0x0E94, 0x0E97, 0x0E99, 0x0E9F, 0x0EA1, 0x0EA3, 0x0EAA, 0x0EAB,
            0x0EAD, 0x0EAE, 0x0EB2, 0x0EB3, 0x0EC0, 0x0EC4, 0x0F40, 0x0F47,
            0x0F49, 0x0F69, 0x10A0, 0x10C5, 0x10D0, 0x10F6, 0x1102, 0x1103,
            0x1105, 0x1107, 0x110B, 0x110C, 0x110E, 0x1112, 0x1154, 0x1155,
            0x115F, 0x1161, 0x116D, 0x116E, 0x1172, 0x1173, 0x11AE, 0x11AF,
            0x11B7, 0x11B8, 0x11BC, 0x11C2, 0x1E00, 0x1E9B, 0x1EA0, 0x1EF9,
            0x1F00, 0x1F15, 0x1F18, 0x1F1D, 0x1F20, 0x1F45, 0x1F48, 0x1F4D,
            0x1F50, 0x1F57, 0x1F5F, 0x1F7D, 0x1F80, 0x1FB4, 0x1FB6, 0x1FBC,
            0x1FC2, 0x1FC4, 0x1FC6, 0x1FCC, 0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB,
            0x1FE0, 0x1FEC, 0x1FF2, 0x1FF4, 0x1FF6, 0x1FFC, 0x212A, 0x212B,
            0x2180, 0x2182, 0x3041, 0x3094, 0x30A1, 0x30FA, 0x3105, 0x312C,
            0xAC00, 0xD7A3,
            
            0x3021, 0x3029, 0x4E00, 0x9FA5,
        };
        int letterChar[] = {
            
            0x0386, 0x038C, 0x03DA, 0x03DC, 0x03DE, 0x03E0, 0x0559, 0x06D5,
            0x093D, 0x09B2, 0x0A5E, 0x0A8D, 0x0ABD, 0x0AE0, 0x0B3D, 0x0B9C,
            0x0CDE, 0x0E30, 0x0E84, 0x0E8A, 0x0E8D, 0x0EA5, 0x0EA7, 0x0EB0,
            0x0EBD, 0x1100, 0x1109, 0x113C, 0x113E, 0x1140, 0x114C, 0x114E,
            0x1150, 0x1159, 0x1163, 0x1165, 0x1167, 0x1169, 0x1175, 0x119E,
            0x11A8, 0x11AB, 0x11BA, 0x11EB, 0x11F0, 0x11F9, 0x1F59, 0x1F5B,
            0x1F5D, 0x1FBE, 0x2126, 0x212E,
            
            0x3007,
        };

        
        
        

        int combiningCharRange[] = {
            0x0300, 0x0345, 0x0360, 0x0361, 0x0483, 0x0486, 0x0591, 0x05A1,
            0x05A3, 0x05B9, 0x05BB, 0x05BD, 0x05C1, 0x05C2, 0x064B, 0x0652,
            0x06D6, 0x06DC, 0x06DD, 0x06DF, 0x06E0, 0x06E4, 0x06E7, 0x06E8,
            0x06EA, 0x06ED, 0x0901, 0x0903, 0x093E, 0x094C, 0x0951, 0x0954,
            0x0962, 0x0963, 0x0981, 0x0983, 0x09C0, 0x09C4, 0x09C7, 0x09C8,
            0x09CB, 0x09CD, 0x09E2, 0x09E3, 0x0A40, 0x0A42, 0x0A47, 0x0A48,
            0x0A4B, 0x0A4D, 0x0A70, 0x0A71, 0x0A81, 0x0A83, 0x0ABE, 0x0AC5,
            0x0AC7, 0x0AC9, 0x0ACB, 0x0ACD, 0x0B01, 0x0B03, 0x0B3E, 0x0B43,
            0x0B47, 0x0B48, 0x0B4B, 0x0B4D, 0x0B56, 0x0B57, 0x0B82, 0x0B83,
            0x0BBE, 0x0BC2, 0x0BC6, 0x0BC8, 0x0BCA, 0x0BCD, 0x0C01, 0x0C03,
            0x0C3E, 0x0C44, 0x0C46, 0x0C48, 0x0C4A, 0x0C4D, 0x0C55, 0x0C56,
            0x0C82, 0x0C83, 0x0CBE, 0x0CC4, 0x0CC6, 0x0CC8, 0x0CCA, 0x0CCD,
            0x0CD5, 0x0CD6, 0x0D02, 0x0D03, 0x0D3E, 0x0D43, 0x0D46, 0x0D48,
            0x0D4A, 0x0D4D, 0x0E34, 0x0E3A, 0x0E47, 0x0E4E, 0x0EB4, 0x0EB9,
            0x0EBB, 0x0EBC, 0x0EC8, 0x0ECD, 0x0F18, 0x0F19, 0x0F71, 0x0F84,
            0x0F86, 0x0F8B, 0x0F90, 0x0F95, 0x0F99, 0x0FAD, 0x0FB1, 0x0FB7,
            0x20D0, 0x20DC, 0x302A, 0x302F,
        };

        int combiningCharChar[] = {
            0x05BF, 0x05C4, 0x0670, 0x093C, 0x094D, 0x09BC, 0x09BE, 0x09BF,
            0x09D7, 0x0A02, 0x0A3C, 0x0A3E, 0x0A3F, 0x0ABC, 0x0B3C, 0x0BD7,
            0x0D57, 0x0E31, 0x0EB1, 0x0F35, 0x0F37, 0x0F39, 0x0F3E, 0x0F3F,
            0x0F97, 0x0FB9, 0x20E1, 0x3099, 0x309A,
        };

        
        
        

        int digitRange[] = {
            0x0030, 0x0039, 0x0660, 0x0669, 0x06F0, 0x06F9, 0x0966, 0x096F,
            0x09E6, 0x09EF, 0x0A66, 0x0A6F, 0x0AE6, 0x0AEF, 0x0B66, 0x0B6F,
            0x0BE7, 0x0BEF, 0x0C66, 0x0C6F, 0x0CE6, 0x0CEF, 0x0D66, 0x0D6F,
            0x0E50, 0x0E59, 0x0ED0, 0x0ED9, 0x0F20, 0x0F29,
        };

        
        
        

        int extenderRange[] = {
            0x3031, 0x3035, 0x309D, 0x309E, 0x30FC, 0x30FE,
        };

        int extenderChar[] = {
            0x00B7, 0x02D0, 0x02D1, 0x0387, 0x0640, 0x0E46, 0x0EC6, 0x3005,
        };

        
        
', '
', ']'
        

        int specialChar[] = {
            '<', '&', '
', '
', ']',
        };

        
        
        

        
        for (int i = 0; i < charRange.length; i += 2) {
            for (int j = charRange[i]; j <= charRange[i + 1]; j++) {
                CHARS[j] |= MASK_VALID | MASK_CONTENT;
            }
        }

        
        for (int i = 0; i < specialChar.length; i++) {
            CHARS[specialChar[i]] = (byte)(CHARS[specialChar[i]] & ~MASK_CONTENT);
        }

        
        for (int i = 0; i < spaceChar.length; i++) {
            CHARS[spaceChar[i]] |= MASK_SPACE;
        }

        
        for (int i = 0; i < nameStartChar.length; i++) {
            CHARS[nameStartChar[i]] |= MASK_NAME_START | MASK_NAME | 
                                       MASK_NCNAME_START | MASK_NCNAME;
        }
        for (int i = 0; i < letterRange.length; i += 2) {
            for (int j = letterRange[i]; j <= letterRange[i + 1]; j++) {
                CHARS[j] |= MASK_NAME_START | MASK_NAME |
                            MASK_NCNAME_START | MASK_NCNAME;
            }
        }
        for (int i = 0; i < letterChar.length; i++) {
            CHARS[letterChar[i]] |= MASK_NAME_START | MASK_NAME |
                                    MASK_NCNAME_START | MASK_NCNAME;
        }

        
        for (int i = 0; i < nameChar.length; i++) {
            CHARS[nameChar[i]] |= MASK_NAME | MASK_NCNAME;
        }
        for (int i = 0; i < digitRange.length; i += 2) {
            for (int j = digitRange[i]; j <= digitRange[i + 1]; j++) {
                CHARS[j] |= MASK_NAME | MASK_NCNAME;
            }
        }
        for (int i = 0; i < combiningCharRange.length; i += 2) {
            for (int j = combiningCharRange[i]; j <= combiningCharRange[i + 1]; j++) {
                CHARS[j] |= MASK_NAME | MASK_NCNAME;
            }
        }
        for (int i = 0; i < combiningCharChar.length; i++) {
            CHARS[combiningCharChar[i]] |= MASK_NAME | MASK_NCNAME;
        }
        for (int i = 0; i < extenderRange.length; i += 2) {
            for (int j = extenderRange[i]; j <= extenderRange[i + 1]; j++) {
                CHARS[j] |= MASK_NAME | MASK_NCNAME;
            }
        }
        for (int i = 0; i < extenderChar.length; i++) {
            CHARS[extenderChar[i]] |= MASK_NAME | MASK_NCNAME;
        }

        
        CHARS[':'] &= ~(MASK_NCNAME_START | MASK_NCNAME);

        
        for (int i = 0; i < pubidChar.length; i++) {
            CHARS[pubidChar[i]] |= MASK_PUBID;
        }
        for (int i = 0; i < pubidRange.length; i += 2) {
            for (int j = pubidRange[i]; j <= pubidRange[i + 1]; j++) {
                CHARS[j] |= MASK_PUBID;
            }
        }

    } 

    
    
    

    
    public static boolean isSupplemental(int c) {
        return (c >= 0x10000 && c <= 0x10FFFF);
    }

    
    public static int supplemental(char h, char l) {
        return (h - 0xD800) * 0x400 + (l - 0xDC00) + 0x10000;
    }

    
    public static char highSurrogate(int c) {
        return (char) (((c - 0x00010000) >> 10) + 0xD800);
    }

    
    public static char lowSurrogate(int c) {
        return (char) (((c - 0x00010000) & 0x3FF) + 0xDC00);
    }

    
    public static boolean isHighSurrogate(int c) {
        return (0xD800 <= c && c <= 0xDBFF);
    }

    
    public static boolean isLowSurrogate(int c) {
        return (0xDC00 <= c && c <= 0xDFFF);
    }


    
    public static boolean isValid(int c) {
        return (c < 0x10000 && (CHARS[c] & MASK_VALID) != 0) ||
               (0x10000 <= c && c <= 0x10FFFF);
    } 

    
    public static boolean isInvalid(int c) {
        return !isValid(c);
    } 

    
    public static boolean isContent(int c) {
        return (c < 0x10000 && (CHARS[c] & MASK_CONTENT) != 0) ||
               (0x10000 <= c && c <= 0x10FFFF);
    } 

    
    public static boolean isMarkup(int c) {
        return c == '<' || c == '&' || c == '%';
    } 

    
    public static boolean isSpace(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_SPACE) != 0;
    } 

    
    public static boolean isNameStart(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_NAME_START) != 0;
    } 

    
    public static boolean isName(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_NAME) != 0;
    } 

    
    public static boolean isNCNameStart(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_NCNAME_START) != 0;
    } 

    
    public static boolean isNCName(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_NCNAME) != 0;
    } 

    
    public static boolean isPubid(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_PUBID) != 0;
    } 

    
    
    public static boolean isValidName(String name) {
        if (name.length() == 0)
            return false;
        char ch = name.charAt(0);
        if( isNameStart(ch) == false)
           return false;
        for (int i = 1; i < name.length(); i++ ) {
           ch = name.charAt(i);
           if( isName( ch ) == false ){
              return false;
           }
        }
        return true;
    } 
    

    
    
    public static boolean isValidNCName(String ncName) {
        if (ncName.length() == 0)
            return false;
        char ch = ncName.charAt(0);
        if( isNCNameStart(ch) == false)
           return false;
        for (int i = 1; i < ncName.length(); i++ ) {
           ch = ncName.charAt(i);
           if( isNCName( ch ) == false ){
              return false;
           }
        }
        return true;
    } 

    
    
    public static boolean isValidNmtoken(String nmtoken) {
        if (nmtoken.length() == 0)
            return false;
        for (int i = 0; i < nmtoken.length(); i++ ) {
           char ch = nmtoken.charAt(i);
           if(  ! isName( ch ) ){
              return false;
           }
        }
        return true;
    } 





    

    
    public static boolean isValidIANAEncoding(String ianaEncoding) {
        if (ianaEncoding != null) {
            int length = ianaEncoding.length();
            if (length > 0) {
                char c = ianaEncoding.charAt(0);
                if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
                    for (int i = 1; i < length; i++) {
                        c = ianaEncoding.charAt(i);
                        if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                            (c < '0' || c > '9') && c != '.' && c != '_' &&
                            c != '-') {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    } 

    
    public static boolean isValidJavaEncoding(String javaEncoding) {
        if (javaEncoding != null) {
            int length = javaEncoding.length();
            if (length > 0) {
                for (int i = 1; i < length; i++) {
                    char c = javaEncoding.charAt(i);
                    if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                        (c < '0' || c > '9') && c != '.' && c != '_' &&
                        c != '-') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    } 

} 
"
org.apache.xalan.extensions.ExtensionHandlerGeneral,8,2,0,15,54,18,0,15,6,0.904761905,565,0.866666667,0,0.5,0.328571429,0,0,67.75,2,1.0,2,"
package org.apache.xalan.extensions;

import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Method;
import java.net.URL;
import java.net.URLConnection;
import java.util.Hashtable;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.ref.DTMNodeList;
import org.apache.xml.utils.StringVector;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xpath.XPathProcessorException;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.objects.XObject;


public class ExtensionHandlerGeneral extends ExtensionHandler
{

  
  private String m_scriptSrc;   

  
  private String m_scriptSrcURL;  

  
  private Hashtable m_functions = new Hashtable();  

  
  private Hashtable m_elements = new Hashtable();   

  
  

  
  private Object m_mgr;  

  
  private Object m_engine;  

  

  
  private static final String BSF_MANAGER = ""com.ibm.bsf.BSFManager"";

  
  private static Class managerClass;

  
  private static Method mgrLoadScriptingEngine;

  
  private static final String BSF_ENGINE = ""com.ibm.bsf.BSFEngine"";

  
  private static Method engineExec;   

  
  private static Method engineCall;   

  
  private static final Integer NEG1INT = new Integer(-1);

  static
  {
    try
    {
      
                        managerClass = ExtensionHandler.getClassForName(BSF_MANAGER);
      mgrLoadScriptingEngine = managerClass.getMethod(""loadScriptingEngine"",
              new Class[]{ String.class });

      
                        Class engineClass = ExtensionHandler.getClassForName(BSF_ENGINE);

      engineExec = engineClass.getMethod(""exec"", new Class[]{ String.class,
                                                              Integer.TYPE,
                                                              Integer.TYPE,
                                                              Object.class });
      engineCall = engineClass.getMethod(""call"", new Class[]{ Object.class,
                                                              String.class,
                                                              Class.forName(
                                                                ""[Ljava.lang.Object;"") });
    }
    catch (Exception e)
    {
      managerClass = null;
      mgrLoadScriptingEngine = null;
      engineExec = null;
      engineCall = null;

      e.printStackTrace();
    }
  }

  
  public ExtensionHandlerGeneral(
          String namespaceUri, StringVector elemNames, StringVector funcNames, String scriptLang, String scriptSrcURL, String scriptSrc, String systemId)
            throws TransformerException
  {

    super(namespaceUri, scriptLang);

    if (elemNames != null)
    {
      Object junk = new Object();
      int n = elemNames.size();

      for (int i = 0; i < n; i++)
      {
        String tok = elemNames.elementAt(i);

        m_elements.put(tok, junk);  
      }
    }

    if (funcNames != null)
    {
      Object junk = new Object();
      int n = funcNames.size();

      for (int i = 0; i < n; i++)
      {
        String tok = funcNames.elementAt(i);

        m_functions.put(tok, junk);  
      }
    }

    m_scriptSrcURL = scriptSrcURL;
    m_scriptSrc = scriptSrc;

    if (m_scriptSrcURL != null)
    {
      URL url = null;
      try{
        url = new URL(m_scriptSrcURL);
      }
      catch (java.net.MalformedURLException mue)
      {
        int indexOfColon = m_scriptSrcURL.indexOf(':');
        int indexOfSlash = m_scriptSrcURL.indexOf('/');

        if ((indexOfColon != -1) && (indexOfSlash != -1)
            && (indexOfColon < indexOfSlash))
        {
          
          url = null;
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_FIND_EXTERN_SCRIPT, new Object[]{m_scriptSrcURL}), mue); 
          
        }
        else
        {
          try{
            url = new URL(new URL(SystemIDResolver.getAbsoluteURI(systemId)), m_scriptSrcURL);          
          }        
          catch (java.net.MalformedURLException mue2)
          {
            throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_FIND_EXTERN_SCRIPT, new Object[]{m_scriptSrcURL}), mue2); 
          
          }
        }
      }
      if (url != null)
      {
        try
        {
          URLConnection uc = url.openConnection();
          InputStream is = uc.getInputStream();
          byte []bArray = new byte[uc.getContentLength()];
          is.read(bArray);
          m_scriptSrc = new String(bArray);
          
        }
        catch (IOException ioe)
        {
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_FIND_EXTERN_SCRIPT, new Object[]{m_scriptSrcURL}), ioe); 
          
        }
      }
      
    }
   
    if (null == managerClass)
      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_INIT_BSFMGR, null)); 

    try
    {
      m_mgr = managerClass.newInstance();
      m_engine = mgrLoadScriptingEngine.invoke(m_mgr,
                                               new Object[]{ scriptLang });

      
      engineExec.invoke(m_engine, new Object[]{ ""XalanScript"", NEG1INT,
                                                NEG1INT, m_scriptSrc });
    }
    catch (Exception e)
    {
      e.printStackTrace();

      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_CMPL_EXTENSN, null), e); 
    }
  }

  
  public boolean isFunctionAvailable(String function)
  {
    return (m_functions.get(function) != null);
  }

  
  public boolean isElementAvailable(String element)
  {
    return (m_elements.get(element) != null);
  }

  
  public Object callFunction(
          String funcName, Vector args, Object methodKey, ExpressionContext exprContext)
            throws TransformerException
  {

    Object[] argArray;

    try
    {
      argArray = new Object[args.size()];

      for (int i = 0; i < argArray.length; i++)
      {
        Object o = args.elementAt(i);

        argArray[i] = (o instanceof XObject) ? ((XObject) o).object() : o;
        o = argArray[i];
        if(null != o && o instanceof DTMIterator)
        {
          argArray[i] = new DTMNodeList((DTMIterator)o);
        }
      }

      return engineCall.invoke(m_engine, new Object[]{ null, funcName,
                                                       argArray });
    }
    catch (Exception e)
    {
      e.printStackTrace();

      String msg = e.getMessage();

      if (null != msg)
      {
        if (msg.startsWith(""Stopping after fatal error:""))
        {
          msg = msg.substring(""Stopping after fatal error:"".length());
        }

        
        throw new TransformerException(e);
      }
      else
      {

        
        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_CREATE_EXTENSN, new Object[]{funcName, e })); 
                               
      }
    }
  }

  
  public Object callFunction(FuncExtFunction extFunction,
                             Vector args,
                             ExpressionContext exprContext)
      throws TransformerException
  {
    return callFunction(extFunction.getFunctionName(), args, 
                        extFunction.getMethodKey(), exprContext);
  }

  
  public void processElement(
          String localPart, ElemTemplateElement element, TransformerImpl transformer, 
          Stylesheet stylesheetTree, Object methodKey)
            throws TransformerException, IOException
  {

    Object result = null;
    XSLProcessorContext xpc = new XSLProcessorContext(transformer, stylesheetTree);

    try
    {
      Vector argv = new Vector(2);

      argv.addElement(xpc);
      argv.addElement(element);

      result = callFunction(localPart, argv, methodKey,
                            transformer.getXPathContext().getExpressionContext());
    }
    catch (XPathProcessorException e)
    {

      
      throw new TransformerException(e.getMessage(), e);
    }

    if (result != null)
    {
      xpc.outputToResultTree(stylesheetTree, result);
    }
  }
}
"
org.apache.xalan.templates.ElemExtensionScript,6,3,0,2,7,3,1,1,6,0.6,33,1.0,0,0.975124378,0.666666667,1,2,4.166666667,1,0.8333,1,"
package org.apache.xalan.templates;


public class ElemExtensionScript extends ElemTemplateElement
{

  
  public ElemExtensionScript()
  {

    
  }

  
  private String m_lang = null;

  
  public void setLang(String v)
  {
    m_lang = v;
  }

  
  public String getLang()
  {
    return m_lang;
  }

  
  private String m_src = null;

  
  public void setSrc(String v)
  {
    m_src = v;
  }

  
  public String getSrc()
  {
    return m_src;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_EXTENSIONSCRIPT;
  }
}
"
org.apache.xpath.axes.WalkingIterator,17,5,1,17,41,0,8,11,16,0.4375,281,1.0,2,0.892857143,0.165775401,2,9,15.41176471,7,1.8824,1,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;



public class WalkingIterator extends LocPathIterator implements ExpressionOwner
{
  
  WalkingIterator(
          Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers)
            throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, shouldLoadWalkers);
    
    int firstStepPos = compiler.getFirstChildPos(opPos);

    if (shouldLoadWalkers)
    {
      m_firstWalker = WalkerFactory.loadWalkers(this, compiler, firstStepPos, 0);
      m_lastUsedWalker = m_firstWalker;
    }
  }
  
  
  public WalkingIterator(PrefixResolver nscontext)
  {

    super(nscontext);
  }
  
  
  
  public int getAnalysisBits()
  {
    int bits = 0;
    if (null != m_firstWalker)
    {    	
      AxesWalker walker = m_firstWalker;

      while (null != walker)
      {
        int bit = walker.getAnalysisBits();
        bits |= bit;
        walker = walker.getNextWalker();
      }       
    }
    return bits;
  }
  
  
  public Object clone() throws CloneNotSupportedException
  {

    WalkingIterator clone = (WalkingIterator) super.clone();

    
    
    if (null != m_firstWalker)
    {
      clone.m_firstWalker = m_firstWalker.cloneDeep(clone, null);
    }

    return clone;
  }
  
  
  public void reset()
  {

    super.reset();

    if (null != m_firstWalker)
    {
      m_lastUsedWalker = m_firstWalker;

      m_firstWalker.setRoot(m_context);
    }

  }
  
  
  public void setRoot(int context, Object environment)
  {

    super.setRoot(context, environment);
    
    if(null != m_firstWalker)
    {
      m_firstWalker.setRoot(context);
      m_lastUsedWalker = m_firstWalker;
    }
  }
  
  
  public int nextNode()
  {
  	if(m_foundLast)
  		return DTM.NULL;

    
    
    
    
    
    
    
    
    if (-1 == m_stackFrame)
    {
      return returnNextNode(m_firstWalker.nextNode());
    }
    else
    {
      VariableStack vars = m_execContext.getVarStack();

      
      int savedStart = vars.getStackFrame();

      vars.setStackFrame(m_stackFrame);

      int n = returnNextNode(m_firstWalker.nextNode());

      
      vars.setStackFrame(savedStart);

      return n;
    }
  }

  
  
  public final AxesWalker getFirstWalker()
  {
    return m_firstWalker;
  }
  
  
  public final void setFirstWalker(AxesWalker walker)
  {
    m_firstWalker = walker;
  }


  
  public final void setLastUsedWalker(AxesWalker walker)
  {
    m_lastUsedWalker = walker;
  }

  
  public final AxesWalker getLastUsedWalker()
  {
    return m_lastUsedWalker;
  }
  
  
  public void detach()
  {   
    if(m_allowDetach)
    {
	  	AxesWalker walker = m_firstWalker; 
	    while (null != walker)
	    {
	      walker.detach();
	      walker = walker.getNextWalker();
	    }
	
	    m_lastUsedWalker = null;
	    
	    
	    super.detach();
    }
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_predicateIndex = -1;

    AxesWalker walker = m_firstWalker;

    while (null != walker)
    {
      walker.fixupVariables(vars, globalsSize);
      walker = walker.getNextWalker();
    }
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	 	if(visitor.visitLocationPath(owner, this))
  	 	{
  	 		if(null != m_firstWalker)
  	 		{
  	 			m_firstWalker.callVisitors(this, visitor);
  	 		}
  	 	}
  }

  
  
  protected AxesWalker m_lastUsedWalker;

  
  protected AxesWalker m_firstWalker;

  
  public Expression getExpression()
  {
    return m_firstWalker;
  }

  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_firstWalker = (AxesWalker)exp;
  }
  
    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
                return false;

      AxesWalker walker1 = m_firstWalker;
      AxesWalker walker2 = ((WalkingIterator)expr).m_firstWalker;
      while ((null != walker1) && (null != walker2))
      {
        if(!walker1.deepEquals(walker2))
        	return false;
        walker1 = walker1.getNextWalker();
        walker2 = walker2.getNextWalker();
      }
      
      if((null != walker1) || (null != walker2))
      	return false;

      return true;
    }

}"
org.apache.xalan.xsltc.compiler.Template,22,3,0,25,73,121,10,19,21,0.852380952,485,1.0,4,0.740740741,0.140495868,2,7,20.59090909,8,2.0455,3,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

public final class Template extends TopLevelElement {

    private QName   _name;     
    private QName   _mode;     
    private Pattern _pattern;  
    private double  _priority; 
    private int     _position; 
    private boolean _disabled = false;
    private boolean _compiled = false;
    private boolean _hasParams = false;
    private boolean _simplified = false;

    public boolean hasParams() {
	return _hasParams;
    }

    public void hasParams(boolean hasParams) {
	_hasParams = hasParams;
    }

    public boolean isSimplified() {
	return(_simplified);
    }

    public void setSimplified() {
	_simplified = true;
    }

    public void disable() {
	_disabled = true;
    }

    public boolean disabled() {
	return(_disabled);
    }

    public double getPriority() {
	return _priority;
    }

    public int getPosition() {
	return(_position);
    }

    public boolean isNamed() {
	return _name != null;
    }

    public Pattern getPattern() {
	return _pattern;
    }

    public QName getName() {
	return _name;
    }

    public void setName(QName qname) {
	if (_name == null) _name = qname;
    }

    public QName getModeName() {
	return _mode;
    }

    
    public int compareTo(Object template) {
	Template other = (Template)template;
	if (_priority > other._priority)
	    return 1;
	else if (_priority < other._priority)
	    return -1;
	else if (_position > other._position)
	    return 1;
	else if (_position < other._position)
	    return -1;
	else
	    return 0;
    }

    public void display(int indent) {
	Util.println('
');
	indent(indent);
	if (_name != null) {
	    indent(indent);
	    Util.println(""name = "" + _name);
	}
	else if (_pattern != null) {
	    indent(indent);
	    Util.println(""match = "" + _pattern.toString());
	}
	if (_mode != null) {
	    indent(indent);
	    Util.println(""mode = "" + _mode);
	}
	displayContents(indent + IndentIncrement);
    }

    private boolean resolveNamedTemplates(Template other, Parser parser) {

	if (other == null) return true;

	SymbolTable stable = parser.getSymbolTable();

	final int us = this.getImportPrecedence();
	final int them = other.getImportPrecedence();

	if (us > them) {
	    other.disable();
	    return true;
	}
	else if (us < them) {
	    stable.addTemplate(other);
	    this.disable();
	    return true;
	}
	else {
	    return false;
	}
    }

    private Stylesheet _stylesheet = null;

    public Stylesheet getStylesheet() {
	return _stylesheet;
    }

    public void parseContents(Parser parser) {

	final String name     = getAttribute(""name"");
	final String mode     = getAttribute(""mode"");
	final String match    = getAttribute(""match"");
	final String priority = getAttribute(""priority"");

	_stylesheet = super.getStylesheet();

	if (name.length() > 0) {
	    _name = parser.getQNameIgnoreDefaultNs(name);
	}
	
	if (mode.length() > 0) {
	    _mode = parser.getQNameIgnoreDefaultNs(mode);
	}
	
	if (match.length() > 0) {
	    _pattern = parser.parsePattern(this, ""match"", null);
	}

	if (priority.length() > 0) {
	    _priority = Double.parseDouble(priority);
	}
	else {
	    if (_pattern != null)
		_priority = _pattern.getPriority();
	    else
		_priority = Double.NaN;
	}

	_position = parser.getTemplateIndex();

	
	if (_name != null) {
	    Template other = parser.getSymbolTable().addTemplate(this);
	    if (!resolveNamedTemplates(other, parser)) {
		ErrorMsg err =
		    new ErrorMsg(ErrorMsg.TEMPLATE_REDEF_ERR, _name, this);
		parser.reportError(Constants.ERROR, err);
	    }
	}

	parser.setTemplate(this);	
	parseChildren(parser);
	parser.setTemplate(null);	
    }

    
    public void parseSimplified(Stylesheet stylesheet, Parser parser) {

	_stylesheet = stylesheet;
	setParent(stylesheet);

	_name = null;
	_mode = null;
	_priority = Double.NaN;
	_pattern = parser.parsePattern(this, ""/"");

	final Vector contents = _stylesheet.getContents();
	final SyntaxTreeNode root = (SyntaxTreeNode)contents.elementAt(0);

	if (root instanceof LiteralElement) {
	    addElement(root);
	    root.setParent(this);
	    contents.set(0, this);
	    parser.setTemplate(this);
	    root.parseContents(parser);
	    parser.setTemplate(null);
	}
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_pattern != null) {
	    _pattern.typeCheck(stable);
	}

	return typeCheckContents(stable);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_disabled) return;
	
	String className = classGen.getClassName();

	if (_compiled && isNamed()){
	    String methodName = Util.escape(_name.toString());
	    il.append(classGen.loadTranslet());
	    il.append(methodGen.loadDOM());
	    il.append(methodGen.loadIterator());
	    il.append(methodGen.loadHandler()); 
	    il.append(methodGen.loadCurrentNode()); 
	    il.append(new INVOKEVIRTUAL(cpg.addMethodref(className,
							 methodName,
							 ""(""
							 + DOM_INTF_SIG
							 + NODE_ITERATOR_SIG
							 + TRANSLET_OUTPUT_SIG
							 + ""I)V"")));
	    return;
	}

	if (_compiled) return;
	_compiled = true; 
	
	final InstructionHandle start = il.getEnd();
	translateContents(classGen, methodGen);
	final InstructionHandle end = il.getEnd();
	il.setPositions(true);
    }
}
"
org.apache.xml.utils.res.XResources_sv,3,4,0,1,4,1,0,1,2,0.5,314,0.0,0,0.976190476,1.0,0,0,103.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_sv extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""sv"" }, { ""help_language"", ""sv"" }, { ""language"", ""sv"" },
    { ""alphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    
    
    
    
    
    
    
    
    
  };
}
"
org.apache.xalan.trace.SelectionEvent,1,1,1,8,2,0,4,4,1,2.0,28,0.0,4,0.0,1.0,0,0,21.0,0,0.0,1,"
package org.apache.xalan.trace;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;

import org.w3c.dom.Node;


public class SelectionEvent implements java.util.EventListener
{

  
  public final ElemTemplateElement m_styleNode;

  
  public final TransformerImpl m_processor;

  
  public final Node m_sourceNode;

  
  public final String m_attributeName;

  
  public final XPath m_xpath;

  
  public final XObject m_selection;

  
  public SelectionEvent(TransformerImpl processor, Node sourceNode,
                        ElemTemplateElement styleNode, String attributeName,
                        XPath xpath, XObject selection)
  {

    this.m_processor = processor;
    this.m_sourceNode = sourceNode;
    this.m_styleNode = styleNode;
    this.m_attributeName = attributeName;
    this.m_xpath = xpath;
    this.m_selection = selection;
  }
}
"
org.apache.xpath.functions.FuncNamespace,2,5,0,5,11,1,0,5,2,2.0,65,0.0,0,0.982142857,0.75,3,8,31.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncNamespace extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int context = getArg0AsNode(xctxt);
    
    String s;
    if(context != DTM.NULL)
    {
      DTM dtm = xctxt.getDTM(context);
      int t = dtm.getNodeType(context);
      if(t == DTM.ELEMENT_NODE)
      {
        s = dtm.getNamespaceURI(context);
      }
      else if(t == DTM.ATTRIBUTE_NODE)
      {

        
        

        s = dtm.getNodeName(context);
        if(s.startsWith(""xmlns:"") || s.equals(""xmlns""))
          return XString.EMPTYSTRING;

        s = dtm.getNamespaceURI(context);
      }
      else
        return XString.EMPTYSTRING;
    }
    else 
      return XString.EMPTYSTRING;
    
    return ((null == s) ? XString.EMPTYSTRING : new XString(s));
  }
}
"
org.apache.xml.serializer.TransformStateSetter,2,1,0,4,2,1,4,0,2,2.0,2,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"
package org.apache.xml.serializer;

import javax.xml.transform.Transformer;

import org.w3c.dom.Node;

public interface TransformStateSetter
{


  
  void setCurrentNode(Node n);

  
  void resetState(Transformer transformer);

}
"
org.apache.xpath.compiler.FunctionTable,5,1,0,7,14,0,3,4,4,1.211538462,391,0.051282051,1,0.0,0.375,0,0,69.4,2,0.8,0,"
package org.apache.xpath.compiler;

import org.apache.xpath.Expression;
import org.apache.xpath.functions.Function;


public class FunctionTable
{

  
  public static final int FUNC_CURRENT = 0;

  
  public static final int FUNC_LAST = 1;

  
  public static final int FUNC_POSITION = 2;

  
  public static final int FUNC_COUNT = 3;

  
  public static final int FUNC_ID = 4;

  
  public static final int FUNC_KEY = 5;

  
  public static final int FUNC_LOCAL_PART = 7;

  
  public static final int FUNC_NAMESPACE = 8;

  
  public static final int FUNC_QNAME = 9;

  
  public static final int FUNC_GENERATE_ID = 10;

  
  public static final int FUNC_NOT = 11;

  
  public static final int FUNC_TRUE = 12;

  
  public static final int FUNC_FALSE = 13;

  
  public static final int FUNC_BOOLEAN = 14;

  
  public static final int FUNC_NUMBER = 15;

  
  public static final int FUNC_FLOOR = 16;

  
  public static final int FUNC_CEILING = 17;

  
  public static final int FUNC_ROUND = 18;

  
  public static final int FUNC_SUM = 19;

  
  public static final int FUNC_STRING = 20;

  
  public static final int FUNC_STARTS_WITH = 21;

  
  public static final int FUNC_CONTAINS = 22;

  
  public static final int FUNC_SUBSTRING_BEFORE = 23;

  
  public static final int FUNC_SUBSTRING_AFTER = 24;

  
  public static final int FUNC_NORMALIZE_SPACE = 25;

  
  public static final int FUNC_TRANSLATE = 26;

  
  public static final int FUNC_CONCAT = 27;

  
  public static final int FUNC_SUBSTRING = 29;

  
  public static final int FUNC_STRING_LENGTH = 30;

  
  public static final int FUNC_SYSTEM_PROPERTY = 31;

  
  public static final int FUNC_LANG = 32;

  
  public static final int FUNC_EXT_FUNCTION_AVAILABLE = 33;

  
  public static final int FUNC_EXT_ELEM_AVAILABLE = 34;

  
  public static final int FUNC_UNPARSED_ENTITY_URI = 36;

  

  
  public static final int FUNC_DOCLOCATION = 35;

  
  public static FuncLoader m_functions[];

  
  private static final int NUM_BUILT_IN_FUNCS = 37;

  
  private static final int NUM_ALLOWABLE_ADDINS = 30;

  
  static int m_funcNextFreeIndex = NUM_BUILT_IN_FUNCS;

  static
  {
    m_functions = new FuncLoader[NUM_BUILT_IN_FUNCS + NUM_ALLOWABLE_ADDINS];
    m_functions[FUNC_CURRENT] = new FuncLoader(""FuncCurrent"", FUNC_CURRENT);
    m_functions[FUNC_LAST] = new FuncLoader(""FuncLast"", FUNC_LAST);
    m_functions[FUNC_POSITION] = new FuncLoader(""FuncPosition"",
                                                FUNC_POSITION);
    m_functions[FUNC_COUNT] = new FuncLoader(""FuncCount"", FUNC_COUNT);
    m_functions[FUNC_ID] = new FuncLoader(""FuncId"", FUNC_ID);
    m_functions[FUNC_KEY] =
      new FuncLoader(""org.apache.xalan.templates.FuncKey"", FUNC_KEY);

    
    m_functions[FUNC_LOCAL_PART] = new FuncLoader(""FuncLocalPart"",
            FUNC_LOCAL_PART);
    m_functions[FUNC_NAMESPACE] = new FuncLoader(""FuncNamespace"",
            FUNC_NAMESPACE);
    m_functions[FUNC_QNAME] = new FuncLoader(""FuncQname"", FUNC_QNAME);
    m_functions[FUNC_GENERATE_ID] = new FuncLoader(""FuncGenerateId"",
            FUNC_GENERATE_ID);
    m_functions[FUNC_NOT] = new FuncLoader(""FuncNot"", FUNC_NOT);
    m_functions[FUNC_TRUE] = new FuncLoader(""FuncTrue"", FUNC_TRUE);
    m_functions[FUNC_FALSE] = new FuncLoader(""FuncFalse"", FUNC_FALSE);
    m_functions[FUNC_BOOLEAN] = new FuncLoader(""FuncBoolean"", FUNC_BOOLEAN);
    m_functions[FUNC_LANG] = new FuncLoader(""FuncLang"", FUNC_LANG);
    m_functions[FUNC_NUMBER] = new FuncLoader(""FuncNumber"", FUNC_NUMBER);
    m_functions[FUNC_FLOOR] = new FuncLoader(""FuncFloor"", FUNC_FLOOR);
    m_functions[FUNC_CEILING] = new FuncLoader(""FuncCeiling"", FUNC_CEILING);
    m_functions[FUNC_ROUND] = new FuncLoader(""FuncRound"", FUNC_ROUND);
    m_functions[FUNC_SUM] = new FuncLoader(""FuncSum"", FUNC_SUM);
    m_functions[FUNC_STRING] = new FuncLoader(""FuncString"", FUNC_STRING);
    m_functions[FUNC_STARTS_WITH] = new FuncLoader(""FuncStartsWith"",
            FUNC_STARTS_WITH);
    m_functions[FUNC_CONTAINS] = new FuncLoader(""FuncContains"",
                                                FUNC_CONTAINS);
    m_functions[FUNC_SUBSTRING_BEFORE] = new FuncLoader(""FuncSubstringBefore"",
            FUNC_SUBSTRING_BEFORE);
    m_functions[FUNC_SUBSTRING_AFTER] = new FuncLoader(""FuncSubstringAfter"",
            FUNC_SUBSTRING_AFTER);
    m_functions[FUNC_NORMALIZE_SPACE] = new FuncLoader(""FuncNormalizeSpace"",
            FUNC_NORMALIZE_SPACE);
    m_functions[FUNC_TRANSLATE] = new FuncLoader(""FuncTranslate"",
            FUNC_TRANSLATE);
    m_functions[FUNC_CONCAT] = new FuncLoader(""FuncConcat"", FUNC_CONCAT);

    
    m_functions[FUNC_SYSTEM_PROPERTY] = new FuncLoader(""FuncSystemProperty"",
            FUNC_SYSTEM_PROPERTY);
    m_functions[FUNC_EXT_FUNCTION_AVAILABLE] =
      new FuncLoader(""FuncExtFunctionAvailable"", FUNC_EXT_FUNCTION_AVAILABLE);
    m_functions[FUNC_EXT_ELEM_AVAILABLE] =
      new FuncLoader(""FuncExtElementAvailable"", FUNC_EXT_ELEM_AVAILABLE);
    m_functions[FUNC_SUBSTRING] = new FuncLoader(""FuncSubstring"",
            FUNC_SUBSTRING);
    m_functions[FUNC_STRING_LENGTH] = new FuncLoader(""FuncStringLength"",
            FUNC_STRING_LENGTH);
    m_functions[FUNC_DOCLOCATION] = new FuncLoader(""FuncDoclocation"",
            FUNC_DOCLOCATION);
    m_functions[FUNC_UNPARSED_ENTITY_URI] =
      new FuncLoader(""FuncUnparsedEntityURI"", FUNC_UNPARSED_ENTITY_URI);
  }

  
  public static Function getFunction(int which)
          throws javax.xml.transform.TransformerException
  {
    return m_functions[which].getFunction();
  }

  
  public static int installFunction(String name, Expression func)
  {

    int funcIndex;
    Object funcIndexObj = Keywords.m_functions.get(name);

    if (null != funcIndexObj)
    {
      funcIndex = ((Integer) funcIndexObj).intValue();
    }
    else
    {
      funcIndex = m_funcNextFreeIndex;

      m_funcNextFreeIndex++;

      Keywords.m_functions.put(name, new Integer(funcIndex));
    }

    FuncLoader loader = new FuncLoader(func.getClass().getName(), funcIndex);

    m_functions[funcIndex] = loader;

    return funcIndex;
  }

  
  public static void installFunction(Expression func, int funcIndex)
  {

    FuncLoader loader = new FuncLoader(func.getClass().getName(), funcIndex);

    m_functions[funcIndex] = loader;
  }
}
"
org.apache.xalan.processor.ProcessorGlobalVariableDecl,3,5,0,6,10,3,1,5,1,2.0,30,0.0,0,0.990697674,0.583333333,1,2,9.0,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemVariable;


class ProcessorGlobalVariableDecl extends ProcessorTemplateElem
{

  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    
    handler.pushElemTemplateElement(elem);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    ElemVariable v = (ElemVariable) handler.getElemTemplateElement();

    handler.getStylesheet().appendChild(v);
    handler.getStylesheet().setVariable(v);
    super.endElement(handler, uri, localName, rawName);
  }
}
"
org.apache.xalan.xsltc.compiler.util.FilterGenerator,4,4,0,6,6,2,2,4,3,0.666666667,29,1.0,0,0.975903614,0.466666667,0,0,5.75,1,0.5,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.Instruction;
import org.apache.xalan.xsltc.compiler.Stylesheet;


public final class FilterGenerator extends ClassGenerator {
    private static int TRANSLET_INDEX = 5;   
    private final Instruction _aloadTranslet;

    public FilterGenerator(String className, String superClassName,
			   String fileName,
			   int accessFlags, String[] interfaces,
			   Stylesheet stylesheet) {
	super(className, superClassName, fileName,
	      accessFlags, interfaces, stylesheet);
	
	_aloadTranslet = new ALOAD(TRANSLET_INDEX);
    }

    
    public final Instruction loadTranslet() {
	return _aloadTranslet;
    }
    
    
    public boolean isExternal() {
	return true;
    }
}
"
org.apache.xpath.axes.WalkerFactory,51,1,0,25,114,1275,11,23,40,1.02,2140,0.0,0,0.0,0.181372549,0,0,40.45098039,18,3.3333,1,"
package org.apache.xpath.axes;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.FunctionTable;
import org.apache.xpath.compiler.OpCodes;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.patterns.ContextMatchStepPattern;
import org.apache.xpath.patterns.FunctionPattern;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.patterns.StepPattern;
import org.apache.xpath.res.XPATHErrorResources;


public class WalkerFactory
{

  
  static AxesWalker loadOneWalker(
          WalkingIterator lpi, Compiler compiler, int stepOpCodePos)
            throws javax.xml.transform.TransformerException
  {

    AxesWalker firstWalker = null;
    int stepType = compiler.getOp(stepOpCodePos);

    if (stepType != OpCodes.ENDOP)
    {

      
      
      firstWalker = createDefaultWalker(compiler, stepType, lpi, 0);

      firstWalker.init(compiler, stepOpCodePos, stepType);
    }

    return firstWalker;
  }

  
  static AxesWalker loadWalkers(
          WalkingIterator lpi, Compiler compiler, int stepOpCodePos, int stepIndex)
            throws javax.xml.transform.TransformerException
  {

    int stepType;
    AxesWalker firstWalker = null;
    AxesWalker walker, prevWalker = null;

    int analysis = analyze(compiler, stepOpCodePos, stepIndex);

    while (OpCodes.ENDOP != (stepType = compiler.getOp(stepOpCodePos)))
    {
      walker = createDefaultWalker(compiler, stepOpCodePos, lpi, analysis);

      walker.init(compiler, stepOpCodePos, stepType);
      walker.exprSetParent(lpi);

      
      if (null == firstWalker)
      {
        firstWalker = walker;
      }
      else
      {
        prevWalker.setNextWalker(walker);
        walker.setPrevWalker(prevWalker);
      }

      prevWalker = walker;
      stepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (stepOpCodePos < 0)
        break;
    }

    return firstWalker;
  }
  
  public static boolean isSet(int analysis, int bits)
  {
    return (0 != (analysis & bits));
  }
  
  public static void diagnoseIterator(String name, int analysis, Compiler compiler)
  {
    System.out.println(compiler.toString()+"", ""+name+"", ""
                             + Integer.toBinaryString(analysis) + "", ""
                             + getAnalysisString(analysis));
  }

  
  public static DTMIterator newDTMIterator(
          Compiler compiler, int opPos,
          boolean isTopLevel)
            throws javax.xml.transform.TransformerException
  {

    int firstStepPos = compiler.getFirstChildPos(opPos);
    int analysis = analyze(compiler, firstStepPos, 0);
    boolean isOneStep = isOneStep(analysis);
    DTMIterator iter;

    
    if (isOneStep && walksSelfOnly(analysis) && 
        isWild(analysis) && !hasPredicate(analysis))
    {
      if (DEBUG_ITERATOR_CREATION)
        diagnoseIterator(""SelfIteratorNoPredicate"", analysis, compiler);

      
      
      iter = new SelfIteratorNoPredicate(compiler, opPos, analysis);
    }
    
    else if (walksChildrenOnly(analysis) && isOneStep)
    {

      
      if (isWild(analysis) && !hasPredicate(analysis))
      {
        if (DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""ChildIterator"", analysis, compiler);

        
        iter = new ChildIterator(compiler, opPos, analysis);
      }
      else
      {
        if (DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""ChildTestIterator"", analysis, compiler);

        
        iter = new ChildTestIterator(compiler, opPos, analysis);
      }
    }
    
    else if (isOneStep && walksAttributes(analysis))
    {
      if (DEBUG_ITERATOR_CREATION)
        diagnoseIterator(""AttributeIterator"", analysis, compiler);

      
      
      iter = new AttributeIterator(compiler, opPos, analysis);
    }
    else if(isOneStep && !walksFilteredList(analysis))
    {
      if( !walksNamespaces(analysis) 
      && (walksInDocOrder(analysis) || isSet(analysis, BIT_PARENT)))
      {
        if (false || DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""OneStepIteratorForward"", analysis, compiler);
  
        
        
        iter = new OneStepIteratorForward(compiler, opPos, analysis);
      }
      else
      {
        if (false || DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""OneStepIterator"", analysis, compiler);
  
        
        
        iter = new OneStepIterator(compiler, opPos, analysis);
      }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    else if (isOptimizableForDescendantIterator(compiler, firstStepPos, 0)
              
              
              
             )
    {
      if (DEBUG_ITERATOR_CREATION)
        diagnoseIterator(""DescendantIterator"", analysis, compiler);

      iter = new DescendantIterator(compiler, opPos, analysis);
    }
    else
    { 
      if(isNaturalDocOrder(compiler, firstStepPos, 0, analysis))
      {
        if (false || DEBUG_ITERATOR_CREATION)
        {
          diagnoseIterator(""WalkingIterator"", analysis, compiler);
        }
  
        iter = new WalkingIterator(compiler, opPos, analysis, true);
      }
      else
      {




        if (DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""WalkingIteratorSorted"", analysis, compiler);

        iter = new WalkingIteratorSorted(compiler, opPos, analysis, true);
      }
    }
    if(iter instanceof LocPathIterator)
      ((LocPathIterator)iter).setIsTopLevel(isTopLevel);
      
    return iter;
  }
  
  
  public static int getAxisFromStep(
          Compiler compiler, int stepOpCodePos)
            throws javax.xml.transform.TransformerException
  {

    int stepType = compiler.getOp(stepOpCodePos);

    switch (stepType)
    {
    case OpCodes.FROM_FOLLOWING :
      return Axis.FOLLOWING;
    case OpCodes.FROM_FOLLOWING_SIBLINGS :
      return Axis.FOLLOWINGSIBLING;
    case OpCodes.FROM_PRECEDING :
      return Axis.PRECEDING;
    case OpCodes.FROM_PRECEDING_SIBLINGS :
      return Axis.PRECEDINGSIBLING;
    case OpCodes.FROM_PARENT :
      return Axis.PARENT;
    case OpCodes.FROM_NAMESPACE :
      return Axis.NAMESPACE;
    case OpCodes.FROM_ANCESTORS :
      return Axis.ANCESTOR;
    case OpCodes.FROM_ANCESTORS_OR_SELF :
      return Axis.ANCESTORORSELF;
    case OpCodes.FROM_ATTRIBUTES :
      return Axis.ATTRIBUTE;
    case OpCodes.FROM_ROOT :
      return Axis.ROOT;
    case OpCodes.FROM_CHILDREN :
      return Axis.CHILD;
    case OpCodes.FROM_DESCENDANTS_OR_SELF :
      return Axis.DESCENDANTORSELF;
    case OpCodes.FROM_DESCENDANTS :
      return Axis.DESCENDANT;
    case OpCodes.FROM_SELF :
      return Axis.SELF;
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
    case OpCodes.OP_VARIABLE :
      return Axis.FILTEREDLIST;
    }

    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                               
   }
    
    
    static public int getAnalysisBitFromAxes(int axis)
    {
      switch (axis) 
        {
        case Axis.ANCESTOR :
          return BIT_ANCESTOR;
        case Axis.ANCESTORORSELF :
          return BIT_ANCESTOR_OR_SELF;
        case Axis.ATTRIBUTE :
          return BIT_ATTRIBUTE;
        case Axis.CHILD :
          return BIT_CHILD;
        case Axis.DESCENDANT :
          return BIT_DESCENDANT;
        case Axis.DESCENDANTORSELF :
          return BIT_DESCENDANT_OR_SELF;
        case Axis.FOLLOWING :
          return BIT_FOLLOWING;
        case Axis.FOLLOWINGSIBLING :
          return BIT_FOLLOWING_SIBLING;
        case Axis.NAMESPACE :
        case Axis.NAMESPACEDECLS :
          return BIT_NAMESPACE;
        case Axis.PARENT :
          return BIT_PARENT;
        case Axis.PRECEDING :
          return BIT_PRECEDING;
        case Axis.PRECEDINGSIBLING :
          return BIT_PRECEDING_SIBLING;
        case Axis.SELF :
          return BIT_SELF;
        case Axis.ALLFROMNODE :
          return BIT_DESCENDANT_OR_SELF;
          
        case Axis.DESCENDANTSFROMROOT :
        case Axis.ALL :
        case Axis.DESCENDANTSORSELFFROMROOT :
          return BIT_ANY_DESCENDANT_FROM_ROOT;
        case Axis.ROOT :
          return BIT_ROOT;
        case Axis.FILTEREDLIST :
          return BIT_FILTER;
        default :
          return BIT_FILTER;
      }
    }
  
  static boolean functionProximateOrContainsProximate(Compiler compiler, 
                                                      int opPos)
  {
    int endFunc = opPos + compiler.getOp(opPos + 1) - 1;
    opPos = compiler.getFirstChildPos(opPos);
    int funcID = compiler.getOp(opPos);
    
    
    
    switch(funcID)
    {
      case FunctionTable.FUNC_LAST:
      case FunctionTable.FUNC_POSITION:
        return true;
      default:
        opPos++;
        int i = 0;
        for (int p = opPos; p < endFunc; p = compiler.getNextOpPos(p), i++)
        {
          int innerExprOpPos = p+2;
          int argOp = compiler.getOp(innerExprOpPos);
          boolean prox = isProximateInnerExpr(compiler, innerExprOpPos);
          if(prox)
            return true;
        }

    }
    return false;
  }
  
  static boolean isProximateInnerExpr(Compiler compiler, int opPos)
  {
    int op = compiler.getOp(opPos);
    int innerExprOpPos = opPos+2;
    switch(op)
    {
      case OpCodes.OP_ARGUMENT:
        if(isProximateInnerExpr(compiler, innerExprOpPos))
          return true;
        break;
      case OpCodes.OP_VARIABLE:
      case OpCodes.OP_NUMBERLIT:
      case OpCodes.OP_LITERAL:
      case OpCodes.OP_LOCATIONPATH:
        break; 
      case OpCodes.OP_FUNCTION:
        boolean isProx = functionProximateOrContainsProximate(compiler, opPos);
        if(isProx)
          return true;
        break;
      case OpCodes.OP_GT:
      case OpCodes.OP_GTE:
      case OpCodes.OP_LT:
      case OpCodes.OP_LTE:
      case OpCodes.OP_EQUALS:
        int leftPos = compiler.getFirstChildPos(op);
        int rightPos = compiler.getNextOpPos(leftPos);
        isProx = isProximateInnerExpr(compiler, leftPos);
        if(isProx)
          return true;
        isProx = isProximateInnerExpr(compiler, rightPos);
        if(isProx)
          return true;
        break;
      default:
        return true; 
    }
    return false;
  }
    
  
  public static boolean mightBeProximate(Compiler compiler, int opPos, int stepType)
          throws javax.xml.transform.TransformerException
  {

    boolean mightBeProximate = false;
    int argLen;

    switch (stepType)
    {
    case OpCodes.OP_VARIABLE :
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
      argLen = compiler.getArgLength(opPos);
      break;
    default :
      argLen = compiler.getArgLengthOfStep(opPos);
    }

    int predPos = compiler.getFirstPredicateOpPos(opPos);
    int count = 0;

    while (OpCodes.OP_PREDICATE == compiler.getOp(predPos))
    {
      count++;
      
      int innerExprOpPos = predPos+2;
      int predOp = compiler.getOp(innerExprOpPos);

      switch(predOp)
      {
        case OpCodes.OP_VARIABLE:
        	return true; 
        case OpCodes.OP_LOCATIONPATH:
          
          break;
        case OpCodes.OP_NUMBER:
        case OpCodes.OP_NUMBERLIT:
          return true; 
        case OpCodes.OP_FUNCTION:
          boolean isProx 
            = functionProximateOrContainsProximate(compiler, innerExprOpPos);
          if(isProx)
            return true;
          break;
        case OpCodes.OP_GT:
        case OpCodes.OP_GTE:
        case OpCodes.OP_LT:
        case OpCodes.OP_LTE:
        case OpCodes.OP_EQUALS:
          int leftPos = compiler.getFirstChildPos(innerExprOpPos);
          int rightPos = compiler.getNextOpPos(leftPos);
          isProx = isProximateInnerExpr(compiler, leftPos);
          if(isProx)
            return true;
          isProx = isProximateInnerExpr(compiler, rightPos);
          if(isProx)
            return true;
          break;
        default:
          return true; 
      }

      predPos = compiler.getNextOpPos(predPos);
    }

    return mightBeProximate;
  }
  
  
  private static boolean isOptimizableForDescendantIterator(
          Compiler compiler, int stepOpCodePos, int stepIndex)
            throws javax.xml.transform.TransformerException
  {

    int stepType;
    int stepCount = 0;
    boolean foundDorDS = false;
    boolean foundSelf = false;
    boolean foundDS = false;
    
    int nodeTestType = OpCodes.NODETYPE_NODE;
    
    while (OpCodes.ENDOP != (stepType = compiler.getOp(stepOpCodePos)))
    {
      
      
      if(nodeTestType != OpCodes.NODETYPE_NODE && nodeTestType != OpCodes.NODETYPE_ROOT)
        return false;
        
      stepCount++;
      if(stepCount > 3)
        return false;
        
      boolean mightBeProximate = mightBeProximate(compiler, stepOpCodePos, stepType);
      if(mightBeProximate)
        return false;

      switch (stepType)
      {
      case OpCodes.FROM_FOLLOWING :
      case OpCodes.FROM_FOLLOWING_SIBLINGS :
      case OpCodes.FROM_PRECEDING :
      case OpCodes.FROM_PRECEDING_SIBLINGS :
      case OpCodes.FROM_PARENT :
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
      case OpCodes.FROM_NAMESPACE :
      case OpCodes.FROM_ANCESTORS :
      case OpCodes.FROM_ANCESTORS_OR_SELF :
      case OpCodes.FROM_ATTRIBUTES :
      case OpCodes.MATCH_ATTRIBUTE :
      case OpCodes.MATCH_ANY_ANCESTOR :
      case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
        return false;
      case OpCodes.FROM_ROOT :
        if(1 != stepCount)
          return false;
        break;
      case OpCodes.FROM_CHILDREN :
        if(!foundDS && !(foundDorDS && foundSelf))
          return false;
        break;
      case OpCodes.FROM_DESCENDANTS_OR_SELF :
        foundDS = true;
      case OpCodes.FROM_DESCENDANTS :
        if(3 == stepCount)
          return false;
        foundDorDS = true;
        break;
      case OpCodes.FROM_SELF :
        if(1 != stepCount)
          return false;
        foundSelf = true;
        break;
      default :
        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                  
      }
      
      nodeTestType = compiler.getStepTestType(stepOpCodePos);

      int nextStepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (nextStepOpCodePos < 0)
        break;
        
      if(OpCodes.ENDOP != compiler.getOp(nextStepOpCodePos))
      {
        if(compiler.countPredicates(stepOpCodePos) > 0)
        {
          return false;
        }
      }
      
      stepOpCodePos = nextStepOpCodePos;
    }

    return true;
  }

  
  private static int analyze(
          Compiler compiler, int stepOpCodePos, int stepIndex)
            throws javax.xml.transform.TransformerException
  {

    int stepType;
    int stepCount = 0;
    int analysisResult = 0x00000000;  

    while (OpCodes.ENDOP != (stepType = compiler.getOp(stepOpCodePos)))
    {
      stepCount++;

      
      
      
      
      
      boolean predAnalysis = analyzePredicate(compiler, stepOpCodePos,
                                              stepType);

      if (predAnalysis)
        analysisResult |= BIT_PREDICATE;

      switch (stepType)
      {
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
        analysisResult |= BIT_FILTER;
        break;
      case OpCodes.FROM_ROOT :
        analysisResult |= BIT_ROOT;
        break;
      case OpCodes.FROM_ANCESTORS :
        analysisResult |= BIT_ANCESTOR;
        break;
      case OpCodes.FROM_ANCESTORS_OR_SELF :
        analysisResult |= BIT_ANCESTOR_OR_SELF;
        break;
      case OpCodes.FROM_ATTRIBUTES :
        analysisResult |= BIT_ATTRIBUTE;
        break;
      case OpCodes.FROM_NAMESPACE :
        analysisResult |= BIT_NAMESPACE;
        break;
      case OpCodes.FROM_CHILDREN :
        analysisResult |= BIT_CHILD;
        break;
      case OpCodes.FROM_DESCENDANTS :
        analysisResult |= BIT_DESCENDANT;
        break;
      case OpCodes.FROM_DESCENDANTS_OR_SELF :

        
        if (2 == stepCount && BIT_ROOT == analysisResult)
        {
          analysisResult |= BIT_ANY_DESCENDANT_FROM_ROOT;
        }

        analysisResult |= BIT_DESCENDANT_OR_SELF;
        break;
      case OpCodes.FROM_FOLLOWING :
        analysisResult |= BIT_FOLLOWING;
        break;
      case OpCodes.FROM_FOLLOWING_SIBLINGS :
        analysisResult |= BIT_FOLLOWING_SIBLING;
        break;
      case OpCodes.FROM_PRECEDING :
        analysisResult |= BIT_PRECEDING;
        break;
      case OpCodes.FROM_PRECEDING_SIBLINGS :
        analysisResult |= BIT_PRECEDING_SIBLING;
        break;
      case OpCodes.FROM_PARENT :
        analysisResult |= BIT_PARENT;
        break;
      case OpCodes.FROM_SELF :
        analysisResult |= BIT_SELF;
        break;
      case OpCodes.MATCH_ATTRIBUTE :
        analysisResult |= (BIT_MATCH_PATTERN | BIT_ATTRIBUTE);
        break;
      case OpCodes.MATCH_ANY_ANCESTOR :
        analysisResult |= (BIT_MATCH_PATTERN | BIT_ANCESTOR);
        break;
      case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
        analysisResult |= (BIT_MATCH_PATTERN | BIT_PARENT);
        break;
      default :
        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                   
      }

      if (OpCodes.NODETYPE_NODE == compiler.getOp(stepOpCodePos + 3))  
      {
        analysisResult |= BIT_NODETEST_ANY;
      }

      stepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (stepOpCodePos < 0)
        break;
    }

    analysisResult |= (stepCount & BITS_COUNT);

    return analysisResult;
  }
  
  
  public static boolean isDownwardAxisOfMany(int axis)
  {
    return ((Axis.DESCENDANTORSELF == axis) ||
          (Axis.DESCENDANT == axis) 
          || (Axis.FOLLOWING == axis) 

          || (Axis.PRECEDING == axis) 

          );
  }

  
  static StepPattern loadSteps(
          MatchPatternIterator mpi, Compiler compiler, int stepOpCodePos, 
                                                       int stepIndex)
            throws javax.xml.transform.TransformerException
  {
    if (DEBUG_PATTERN_CREATION)
    {
      System.out.println(""================"");
      System.out.println(""loadSteps for: ""+compiler.getPatternString());
    }
    int stepType;
    StepPattern step = null;
    StepPattern firstStep = null, prevStep = null;
    int analysis = analyze(compiler, stepOpCodePos, stepIndex);

    while (OpCodes.ENDOP != (stepType = compiler.getOp(stepOpCodePos)))
    {
      step = createDefaultStepPattern(compiler, stepOpCodePos, mpi, analysis,
                                      firstStep, prevStep);

      if (null == firstStep)
      {
        firstStep = step;
      }
      else
      {

        
        step.setRelativePathPattern(prevStep);
      }

      prevStep = step;
      stepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (stepOpCodePos < 0)
        break;
    }
    
    int axis = Axis.SELF;
    int paxis = Axis.SELF;
    StepPattern tail = step;
    for (StepPattern pat = step; null != pat; 
         pat = pat.getRelativePathPattern()) 
    {
      int nextAxis = pat.getAxis();
      
      pat.setAxis(axis);
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int whatToShow = pat.getWhatToShow();
      if(whatToShow == DTMFilter.SHOW_ATTRIBUTE || 
         whatToShow == DTMFilter.SHOW_NAMESPACE)
      {
        int newAxis = (whatToShow == DTMFilter.SHOW_ATTRIBUTE) ? 
                       Axis.ATTRIBUTE : Axis.NAMESPACE;
        if(isDownwardAxisOfMany(axis))
        {
          StepPattern attrPat = new StepPattern(whatToShow, 
                                    pat.getNamespace(),
                                    pat.getLocalName(),
                                
                                                newAxis, 0); 
          XNumber score = pat.getStaticScore();
          pat.setNamespace(null);
          pat.setLocalName(NodeTest.WILD);
          attrPat.setPredicates(pat.getPredicates());
          pat.setPredicates(null);
          pat.setWhatToShow(DTMFilter.SHOW_ELEMENT);
          StepPattern rel = pat.getRelativePathPattern();
          pat.setRelativePathPattern(attrPat);
          attrPat.setRelativePathPattern(rel);
          attrPat.setStaticScore(score);
          
          
          
          
          
          if(Axis.PRECEDING == pat.getAxis())
            pat.setAxis(Axis.PRECEDINGANDANCESTOR);
            
          else if(Axis.DESCENDANT == pat.getAxis())
            pat.setAxis(Axis.DESCENDANTORSELF);
          
          pat = attrPat;
        }
        else if(Axis.CHILD == pat.getAxis())
        {
          
          
          pat.setAxis(Axis.ATTRIBUTE);
        }
      }
      axis = nextAxis;
      
      tail = pat;
    }
    
    if(axis < Axis.ALL)
    {
      StepPattern selfPattern = new ContextMatchStepPattern(axis, paxis);
      
      XNumber score = tail.getStaticScore();
      tail.setRelativePathPattern(selfPattern);
      tail.setStaticScore(score);
      selfPattern.setStaticScore(score);
    }        

    if (DEBUG_PATTERN_CREATION)
    {
      System.out.println(""Done loading steps: ""+step.toString());
            
      System.out.println("""");
    }
    return step;  
  }

  
  private static StepPattern createDefaultStepPattern(
          Compiler compiler, int opPos, MatchPatternIterator mpi, 
          int analysis, StepPattern tail, StepPattern head)
            throws javax.xml.transform.TransformerException
  {

    int stepType = compiler.getOp(opPos);
    boolean simpleInit = false;
    int totalNumberWalkers = (analysis & BITS_COUNT);
    boolean prevIsOneStepDown = true;
    int firstStepPos = compiler.getFirstChildPos(opPos);
    
    int whatToShow = compiler.getWhatToShow(opPos);
    StepPattern ai = null;
    int axis, predicateAxis;
    
    switch (stepType)
    {
    case OpCodes.OP_VARIABLE :
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
      prevIsOneStepDown = false;

      Expression expr;

      switch (stepType)
      {
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
        expr = compiler.compile(opPos);
        break;
      default :
        expr = compiler.compile(opPos + 2);
      }

      axis = Axis.FILTEREDLIST;
      predicateAxis = Axis.FILTEREDLIST;
      ai = new FunctionPattern(expr, axis, predicateAxis);
      simpleInit = true;
      break;
    case OpCodes.FROM_ROOT :
      whatToShow = DTMFilter.SHOW_DOCUMENT
                   | DTMFilter.SHOW_DOCUMENT_FRAGMENT;

      axis = Axis.ROOT;
      predicateAxis = Axis.ROOT;
      ai = new StepPattern(DTMFilter.SHOW_DOCUMENT | 
                                DTMFilter.SHOW_DOCUMENT_FRAGMENT,
                                axis, predicateAxis);
      break;
    case OpCodes.FROM_ATTRIBUTES :
      whatToShow = DTMFilter.SHOW_ATTRIBUTE;
      axis = Axis.PARENT;
      predicateAxis = Axis.ATTRIBUTE;
      
      break;
    case OpCodes.FROM_NAMESPACE :
      whatToShow = DTMFilter.SHOW_NAMESPACE;
      axis = Axis.PARENT;
      predicateAxis = Axis.NAMESPACE;
      
      break;
    case OpCodes.FROM_ANCESTORS :
      axis = Axis.DESCENDANT;
      predicateAxis = Axis.ANCESTOR;
      break;
    case OpCodes.FROM_CHILDREN :
      axis = Axis.PARENT;
      predicateAxis = Axis.CHILD;
      break;
    case OpCodes.FROM_ANCESTORS_OR_SELF :
      axis = Axis.DESCENDANTORSELF;
      predicateAxis = Axis.ANCESTORORSELF;
      break;
    case OpCodes.FROM_SELF :
      axis = Axis.SELF;
      predicateAxis = Axis.SELF;
      break;
    case OpCodes.FROM_PARENT :
      axis = Axis.CHILD;
      predicateAxis = Axis.PARENT;
      break;
    case OpCodes.FROM_PRECEDING_SIBLINGS :
      axis = Axis.FOLLOWINGSIBLING;
      predicateAxis = Axis.PRECEDINGSIBLING;
      break;
    case OpCodes.FROM_PRECEDING :
      axis = Axis.FOLLOWING;
      predicateAxis = Axis.PRECEDING;
      break;
    case OpCodes.FROM_FOLLOWING_SIBLINGS :
      axis = Axis.PRECEDINGSIBLING;
      predicateAxis = Axis.FOLLOWINGSIBLING;
      break;
    case OpCodes.FROM_FOLLOWING :
      axis = Axis.PRECEDING;
      predicateAxis = Axis.FOLLOWING;
      break;
    case OpCodes.FROM_DESCENDANTS_OR_SELF :
      axis = Axis.ANCESTORORSELF;
      predicateAxis = Axis.DESCENDANTORSELF;
      break;
    case OpCodes.FROM_DESCENDANTS :
      axis = Axis.ANCESTOR;
      predicateAxis = Axis.DESCENDANT;
      break;
    default :
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                 
    }
    if(null == ai)
    {
      whatToShow = compiler.getWhatToShow(opPos); 
      ai = new StepPattern(whatToShow, compiler.getStepNS(opPos),
                                compiler.getStepLocalName(opPos),
                                axis, predicateAxis);
    }
   
    if (false || DEBUG_PATTERN_CREATION)
    {
      System.out.print(""new step: ""+ ai);
      System.out.print("", axis: "" + Axis.names[ai.getAxis()]);
      System.out.print("", predAxis: "" + Axis.names[ai.getAxis()]);
      System.out.print("", what: "");
      System.out.print(""    "");
      ai.debugWhatToShow(ai.getWhatToShow());
    }

    int argLen = compiler.getFirstPredicateOpPos(opPos);

    ai.setPredicates(compiler.getCompiledPredicates(argLen));

    return ai;
  }

  
  static boolean analyzePredicate(Compiler compiler, int opPos, int stepType)
          throws javax.xml.transform.TransformerException
  {

    int argLen;

    switch (stepType)
    {
    case OpCodes.OP_VARIABLE :
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
      argLen = compiler.getArgLength(opPos);
      break;
    default :
      argLen = compiler.getArgLengthOfStep(opPos);
    }

    int pos = compiler.getFirstPredicateOpPos(opPos);
    int nPredicates = compiler.countPredicates(pos);

    return (nPredicates > 0) ? true : false;
  }

  
  private static AxesWalker createDefaultWalker(Compiler compiler, int opPos,
          WalkingIterator lpi, int analysis)
  {

    AxesWalker ai = null;
    int stepType = compiler.getOp(opPos);

    
    boolean simpleInit = false;
    int totalNumberWalkers = (analysis & BITS_COUNT);
    boolean prevIsOneStepDown = true;

    switch (stepType)
    {
    case OpCodes.OP_VARIABLE :
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
      prevIsOneStepDown = false;

      if (DEBUG_WALKER_CREATION)
        System.out.println(""new walker:  FilterExprWalker: "" + analysis
                           + "", "" + compiler.toString());

      ai = new FilterExprWalker(lpi);
      simpleInit = true;
      break;
    case OpCodes.FROM_ROOT :
      ai = new AxesWalker(lpi, Axis.ROOT);
      break;
    case OpCodes.FROM_ANCESTORS :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.ANCESTOR);
      break;
    case OpCodes.FROM_ANCESTORS_OR_SELF :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.ANCESTORORSELF);
      break;
    case OpCodes.FROM_ATTRIBUTES :
      ai = new AxesWalker(lpi, Axis.ATTRIBUTE);
      break;
    case OpCodes.FROM_NAMESPACE :
      ai = new AxesWalker(lpi, Axis.NAMESPACE);
      break;
    case OpCodes.FROM_CHILDREN :
      ai = new AxesWalker(lpi, Axis.CHILD);
      break;
    case OpCodes.FROM_DESCENDANTS :
      prevIsOneStepDown = false;
      ai = new AxesWalker(lpi, Axis.DESCENDANT);
      break;
    case OpCodes.FROM_DESCENDANTS_OR_SELF :
      prevIsOneStepDown = false;
      ai = new AxesWalker(lpi, Axis.DESCENDANTORSELF);
      break;
    case OpCodes.FROM_FOLLOWING :
      prevIsOneStepDown = false;
      ai = new AxesWalker(lpi, Axis.FOLLOWING);
      break;
    case OpCodes.FROM_FOLLOWING_SIBLINGS :
      prevIsOneStepDown = false;
      ai = new AxesWalker(lpi, Axis.FOLLOWINGSIBLING);
      break;
    case OpCodes.FROM_PRECEDING :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.PRECEDING);
      break;
    case OpCodes.FROM_PRECEDING_SIBLINGS :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.PRECEDINGSIBLING);
      break;
    case OpCodes.FROM_PARENT :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.PARENT);
      break;
    case OpCodes.FROM_SELF :
      ai = new AxesWalker(lpi, Axis.SELF);
      break;
    default :
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                 
    }

    if (simpleInit)
    {
      ai.initNodeTest(DTMFilter.SHOW_ALL);
    }
    else
    {
      int whatToShow = compiler.getWhatToShow(opPos);

      
      if ((0 == (whatToShow
                 & (DTMFilter.SHOW_ATTRIBUTE | DTMFilter.SHOW_NAMESPACE | DTMFilter.SHOW_ELEMENT
                    | DTMFilter.SHOW_PROCESSING_INSTRUCTION))) || (whatToShow == DTMFilter.SHOW_ALL))
        ai.initNodeTest(whatToShow);
      else
      {
        ai.initNodeTest(whatToShow, compiler.getStepNS(opPos),
                        compiler.getStepLocalName(opPos));
      }
    }

    return ai;
  }
  
  public static String getAnalysisString(int analysis)
  {
    StringBuffer buf = new StringBuffer();
    buf.append(""count: ""+getStepCount(analysis)+"" "");
    if((analysis & BIT_NODETEST_ANY) != 0)
    {
      buf.append(""NTANY|"");
    }
    if((analysis & BIT_PREDICATE) != 0)
    {
      buf.append(""PRED|"");
    }
    if((analysis & BIT_ANCESTOR) != 0)
    {
      buf.append(""ANC|"");
    }
    if((analysis & BIT_ANCESTOR_OR_SELF) != 0)
    {
      buf.append(""ANCOS|"");
    }
    if((analysis & BIT_ATTRIBUTE) != 0)
    {
      buf.append(""ATTR|"");
    }
    if((analysis & BIT_CHILD) != 0)
    {
      buf.append(""CH|"");
    }
    if((analysis & BIT_DESCENDANT) != 0)
    {
      buf.append(""DESC|"");
    }
    if((analysis & BIT_DESCENDANT_OR_SELF) != 0)
    {
      buf.append(""DESCOS|"");
    }
    if((analysis & BIT_FOLLOWING) != 0)
    {
      buf.append(""FOL|"");
    }
    if((analysis & BIT_FOLLOWING_SIBLING) != 0)
    {
      buf.append(""FOLS|"");
    }
    if((analysis & BIT_NAMESPACE) != 0)
    {
      buf.append(""NS|"");
    }
    if((analysis & BIT_PARENT) != 0)
    {
      buf.append(""P|"");
    }
    if((analysis & BIT_PRECEDING) != 0)
    {
      buf.append(""PREC|"");
    }
    if((analysis & BIT_PRECEDING_SIBLING) != 0)
    {
      buf.append(""PRECS|"");
    }
    if((analysis & BIT_SELF) != 0)
    {
      buf.append("".|"");
    }
    if((analysis & BIT_FILTER) != 0)
    {
      buf.append(""FLT|"");
    }
    if((analysis & BIT_ROOT) != 0)
    {
      buf.append(""R|"");
    }
    return buf.toString();
  }

  
  static final boolean DEBUG_PATTERN_CREATION = false;

  
  static final boolean DEBUG_WALKER_CREATION = false;

  
  static final boolean DEBUG_ITERATOR_CREATION = false;
  
  public static boolean hasPredicate(int analysis)
  {
    return (0 != (analysis & BIT_PREDICATE));
  }

  public static boolean isWild(int analysis)
  {
    return (0 != (analysis & BIT_NODETEST_ANY));
  }

  public static boolean walksAncestors(int analysis)
  {
    return isSet(analysis, BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF);
  }
  
  public static boolean walksAttributes(int analysis)
  {
    return (0 != (analysis & BIT_ATTRIBUTE));
  }

  public static boolean walksNamespaces(int analysis)
  {
    return (0 != (analysis & BIT_NAMESPACE));
  }  

  public static boolean walksChildren(int analysis)
  {
    return (0 != (analysis & BIT_CHILD));
  }

  public static boolean walksDescendants(int analysis)
  {
    return isSet(analysis, BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF);
  }

  public static boolean walksSubtree(int analysis)
  {
    return isSet(analysis, BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF | BIT_CHILD);
  }
  
  public static boolean walksSubtreeOnlyMaybeAbsolute(int analysis)
  {
    return walksSubtree(analysis)
           && !walksExtraNodes(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           ;
  }
  
  public static boolean walksSubtreeOnly(int analysis)
  {
    return walksSubtreeOnlyMaybeAbsolute(analysis) 
           && !isAbsolute(analysis) 
           ;
  }

  public static boolean walksFilteredList(int analysis)
  {
    return isSet(analysis, BIT_FILTER);
  }
  
  public static boolean walksSubtreeOnlyFromRootOrContext(int analysis)
  {
    return walksSubtree(analysis)
           && !walksExtraNodes(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isSet(analysis, BIT_FILTER) 
           ;
  }

  public static boolean walksInDocOrder(int analysis)
  {
    return (walksSubtreeOnlyMaybeAbsolute(analysis)
           || walksExtraNodesOnly(analysis)
           || walksFollowingOnlyMaybeAbsolute(analysis)) 
           && !isSet(analysis, BIT_FILTER) 
           ;
  }
  
  public static boolean walksFollowingOnlyMaybeAbsolute(int analysis)
  {
    return isSet(analysis, BIT_SELF | BIT_FOLLOWING_SIBLING | BIT_FOLLOWING)
           && !walksSubtree(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           ;
  }
  
  public static boolean walksUp(int analysis)
  {
    return isSet(analysis, BIT_PARENT | BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF);
  }
  
  public static boolean walksSideways(int analysis)
  {
    return isSet(analysis, BIT_FOLLOWING | BIT_FOLLOWING_SIBLING | 
                           BIT_PRECEDING | BIT_PRECEDING_SIBLING);
  }
  
  public static boolean walksExtraNodes(int analysis)
  {
    return isSet(analysis, BIT_NAMESPACE | BIT_ATTRIBUTE);
  }

  public static boolean walksExtraNodesOnly(int analysis)
  {
    return walksExtraNodes(analysis)
           && !isSet(analysis, BIT_SELF) 
           && !walksSubtree(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }

  public static boolean isAbsolute(int analysis)
  {
    return isSet(analysis, BIT_ROOT | BIT_FILTER);
  }
  
  public static boolean walksChildrenOnly(int analysis)
  {
    return walksChildren(analysis)
           && !isSet(analysis, BIT_SELF)
           && !walksExtraNodes(analysis)
           && !walksDescendants(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && (!isAbsolute(analysis) || isSet(analysis, BIT_ROOT))
           ;
  }
  
  public static boolean walksChildrenAndExtraAndSelfOnly(int analysis)
  {
    return walksChildren(analysis)
           && !walksDescendants(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && (!isAbsolute(analysis) || isSet(analysis, BIT_ROOT))
           ;
  }
  
  public static boolean walksDescendantsAndExtraAndSelfOnly(int analysis)
  {
    return !walksChildren(analysis)
           && walksDescendants(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && (!isAbsolute(analysis) || isSet(analysis, BIT_ROOT))
           ;
  }
  
  public static boolean walksSelfOnly(int analysis)
  {
    return isSet(analysis, BIT_SELF) 
           && !walksSubtree(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }

  
  public static boolean walksUpOnly(int analysis)
  {
    return !walksSubtree(analysis) 
           && walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }
  
  public static boolean walksDownOnly(int analysis)
  {
    return walksSubtree(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }

  public static boolean walksDownExtraOnly(int analysis)
  {
    return walksSubtree(analysis) &&  walksExtraNodes(analysis)
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }
  
  public static boolean canSkipSubtrees(int analysis)
  {
    return isSet(analysis, BIT_CHILD) | walksSideways(analysis);
  }
  
  public static boolean canCrissCross(int analysis)
  {
    
    if(walksSelfOnly(analysis))
      return false;
    else if(walksDownOnly(analysis) && !canSkipSubtrees(analysis))
      return false;
    else if(walksChildrenAndExtraAndSelfOnly(analysis))
      return false;
    else if(walksDescendantsAndExtraAndSelfOnly(analysis))
      return false;
    else if(walksUpOnly(analysis))
      return false;
    else if(walksExtraNodesOnly(analysis))
      return false;
    else if(walksSubtree(analysis) 
           && (walksSideways(analysis) 
            || walksUp(analysis) 
            || canSkipSubtrees(analysis)))
      return true;
    else
      return false;
  }
  
  
  static public boolean isNaturalDocOrder(int analysis)
  {
    if(canCrissCross(analysis) || isSet(analysis, BIT_NAMESPACE) ||
       walksFilteredList(analysis))
      return false;
      
    if(walksInDocOrder(analysis))
      return true;
      
    return false;
  }
  
  
  private static boolean isNaturalDocOrder(
          Compiler compiler, int stepOpCodePos, int stepIndex, int analysis)
            throws javax.xml.transform.TransformerException
  {
    if(canCrissCross(analysis))
      return false;
      
    
    
    if(isSet(analysis, BIT_NAMESPACE))
      return false;
      
    
    
    
    
    
    
    if(isSet(analysis, BIT_FOLLOWING | BIT_FOLLOWING_SIBLING) && 
       isSet(analysis, BIT_PRECEDING | BIT_PRECEDING_SIBLING))
      return  false;
      
    
    
    
    
    
    int stepType;
    int stepCount = 0;
    boolean foundWildAttribute = false;
    
    
    
    
    int potentialDuplicateMakingStepCount = 0;
    
    while (OpCodes.ENDOP != (stepType = compiler.getOp(stepOpCodePos)))
    {        
      stepCount++;
        
      switch (stepType)
      {
      case OpCodes.FROM_ATTRIBUTES :
      case OpCodes.MATCH_ATTRIBUTE :
        if(foundWildAttribute) 
          return false;
        
        
        
        
        String localName = compiler.getStepLocalName(stepOpCodePos);
        
        if(localName.equals(""*""))
        {
          foundWildAttribute = true;
        }
        break;
      case OpCodes.FROM_FOLLOWING :
      case OpCodes.FROM_FOLLOWING_SIBLINGS :
      case OpCodes.FROM_PRECEDING :
      case OpCodes.FROM_PRECEDING_SIBLINGS :
      case OpCodes.FROM_PARENT :
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
      case OpCodes.FROM_NAMESPACE :
      case OpCodes.FROM_ANCESTORS :
      case OpCodes.FROM_ANCESTORS_OR_SELF :      
      case OpCodes.MATCH_ANY_ANCESTOR :
      case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
      case OpCodes.FROM_DESCENDANTS_OR_SELF :
      case OpCodes.FROM_DESCENDANTS :
        if(potentialDuplicateMakingStepCount > 0)
            return false;
        potentialDuplicateMakingStepCount++;
      case OpCodes.FROM_ROOT :
      case OpCodes.FROM_CHILDREN :
      case OpCodes.FROM_SELF :
        if(foundWildAttribute)
          return false;
        break;
      default :
        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                  
      }

      int nextStepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (nextStepOpCodePos < 0)
        break;
              
      stepOpCodePos = nextStepOpCodePos;
    }

    return true;
  }
  
  public static boolean isOneStep(int analysis)
  {
    return (analysis & BITS_COUNT) == 0x00000001;
  }

  public static int getStepCount(int analysis)
  {
    return (analysis & BITS_COUNT);
  }

  
  public static final int BITS_COUNT = 0x000000FF;

  
  public static final int BITS_RESERVED = 0x00000F00;

  
  public static final int BIT_PREDICATE = (0x00001000);

  
  public static final int BIT_ANCESTOR = (0x00001000 << 1);

  
  public static final int BIT_ANCESTOR_OR_SELF = (0x00001000 << 2);

  
  public static final int BIT_ATTRIBUTE = (0x00001000 << 3);

  
  public static final int BIT_CHILD = (0x00001000 << 4);

  
  public static final int BIT_DESCENDANT = (0x00001000 << 5);

  
  public static final int BIT_DESCENDANT_OR_SELF = (0x00001000 << 6);

  
  public static final int BIT_FOLLOWING = (0x00001000 << 7);

  
  public static final int BIT_FOLLOWING_SIBLING = (0x00001000 << 8);

  
  public static final int BIT_NAMESPACE = (0x00001000 << 9);

  
  public static final int BIT_PARENT = (0x00001000 << 10);

  
  public static final int BIT_PRECEDING = (0x00001000 << 11);

  
  public static final int BIT_PRECEDING_SIBLING = (0x00001000 << 12);

  
  public static final int BIT_SELF = (0x00001000 << 13);

  
  public static final int BIT_FILTER = (0x00001000 << 14);

  
  public static final int BIT_ROOT = (0x00001000 << 15);

  
  public static final int BITMASK_TRAVERSES_OUTSIDE_SUBTREE = (BIT_NAMESPACE  
                                                                | BIT_PRECEDING_SIBLING
                                                                | BIT_PRECEDING
                                                                | BIT_FOLLOWING_SIBLING
                                                                | BIT_FOLLOWING
                                                                | BIT_PARENT  
                                                                | BIT_ANCESTOR_OR_SELF
                                                                | BIT_ANCESTOR
                                                                | BIT_FILTER
                                                                | BIT_ROOT);

  
  public static final int BIT_BACKWARDS_SELF = (0x00001000 << 16);

  
  public static final int BIT_NODETEST_ANY = (0x00001000 << 18);

  

  
  public static final int BIT_MATCH_PATTERN = (0x00001000 << 19);
}
"
org.apache.xpath.axes.SubContextList,2,1,0,7,2,1,7,1,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"
package org.apache.xpath.axes;

import org.apache.xpath.XPathContext;
 

public interface SubContextList
{

  
  public int getLastPos(XPathContext xctxt);

  
  public int getProximityPosition(XPathContext xctxt);
}
"
org.apache.xml.dtm.ref.DTMChildIterNodeList,4,2,0,3,8,0,1,2,3,0.333333333,62,1.0,1,0.5,0.583333333,0,0,14.0,4,1.5,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTM;
import org.w3c.dom.Node;


public class DTMChildIterNodeList extends DTMNodeListBase {
    private int m_firstChild;
    private DTM m_parentDTM;

    
    
    private DTMChildIterNodeList() {
    }

    
    public DTMChildIterNodeList(DTM parentDTM,int parentHandle) {
        m_parentDTM=parentDTM;
        m_firstChild=parentDTM.getFirstChild(parentHandle);
    }


    
    

    
    public Node item(int index) {
        int handle=m_firstChild;
        while(--index>=0 && handle!=DTM.NULL) {
            handle=m_parentDTM.getNextSibling(handle);
        }
        if (handle == DTM.NULL) {
            return null;
        }
        return m_parentDTM.getNode(handle);
    }

    
    public int getLength() {
        int count=0;
        for (int handle=m_firstChild;
             handle!=DTM.NULL;
             handle=m_parentDTM.getNextSibling(handle)) {
            ++count;
        }
        return count;
    }
}
"
org.apache.xpath.objects.XNodeSet,33,4,3,45,76,472,26,20,31,0.96875,610,0.0,6,0.801470588,0.173611111,3,30,17.3030303,2,1.1515,1,"
package org.apache.xpath.objects;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.axes.NodeSequence;

import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;


public class XNodeSet extends NodeSequence
{  
  
  protected XNodeSet()
  {
  }

  
  public XNodeSet(DTMIterator val)
  {
  	super();
  	if(val instanceof XNodeSet)
  	{
	    setIter(((XNodeSet)val).m_iter);
	    m_dtmMgr = ((XNodeSet)val).m_dtmMgr;
	    m_last = ((XNodeSet)val).m_last;
	    if(!((XNodeSet)val).hasCache())
	    	((XNodeSet)val).setShouldCacheNodes(true);
	    m_obj = ((XNodeSet)val).m_obj;
  	}
  	else
    	setIter(val);
  }
  
  
  public XNodeSet(XNodeSet val)
  {
  	super();
    setIter(val.m_iter);
    m_dtmMgr = val.m_dtmMgr;
    m_last = val.m_last;
    if(!val.hasCache())
    	val.setShouldCacheNodes(true);
    m_obj = val.m_obj;
  }


  
  public XNodeSet(DTMManager dtmMgr) 
  {
     this(DTM.NULL,dtmMgr);
  }

  
  public XNodeSet(int n, DTMManager dtmMgr)
  {

    super(new NodeSetDTM(dtmMgr));
    m_dtmMgr = dtmMgr;

    if (DTM.NULL != n)
    {
      ((NodeSetDTM) m_obj).addNode(n);
      m_last = 1;
    }
    else
    	m_last = 0;
  }

  
  public int getType()
  {
    return CLASS_NODESET;
  }

  
  public String getTypeString()
  {
    return ""#NODESET"";
  }

  
  public double getNumberFromNode(int n)
  {
    XMLString xstr = m_dtmMgr.getDTM(n).getStringValue(n);
    return xstr.toDouble();
  }

  
  public double num()
  {

    int node = item(0);
    return (node != DTM.NULL) ? getNumberFromNode(node) : Double.NaN;
  }
  
  
  public double numWithSideEffects()
  {
    int node = nextNode();

    return (node != DTM.NULL) ? getNumberFromNode(node) : Double.NaN;
  }


  
  public boolean bool()
  {
    return (item(0) != DTM.NULL);
  }
  
  
  public boolean boolWithSideEffects()
  {
    return (nextNode() != DTM.NULL);
  }

  
  
  public XMLString getStringFromNode(int n)
  {
    
    
    if(DTM.NULL != n)
    {
      return m_dtmMgr.getDTM(n).getStringValue(n);
    }
    else
    {
      return org.apache.xpath.objects.XString.EMPTYSTRING;
    }
  }
  
  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {
    int node = item(0);
	
    if(node != DTM.NULL)
    {
      m_dtmMgr.getDTM(node).dispatchCharactersEvents(node, ch, false);
    }
    
  }
  
  
  public XMLString xstr()
  {
    int node = item(0);
    return (node != DTM.NULL) ? getStringFromNode(node) : XString.EMPTYSTRING;
  }
  
  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    XString xstring = (XString)xstr();
    xstring.appendToFsb(fsb);
  }
  

  
  public String str()
  {
    int node = item(0);
    return (node != DTM.NULL) ? getStringFromNode(node).toString() : """";   
  }
  
  
  public Object object()
  {
    if(null == m_obj)
    	return this;
    else
    	return m_obj;
  }

  
  


























  
  public NodeIterator nodeset() throws javax.xml.transform.TransformerException
  {
    return new org.apache.xml.dtm.ref.DTMNodeIterator(iter());
  }
  
  
  public NodeList nodelist() throws javax.xml.transform.TransformerException
  {
    org.apache.xml.dtm.ref.DTMNodeList nodelist = new org.apache.xml.dtm.ref.DTMNodeList(this);
    
    
    
    
    XNodeSet clone = (XNodeSet)nodelist.getDTMIterator();
    SetVector(clone.getVector());
    return nodelist;
  }

  











  
  public DTMIterator iterRaw()
  {
    return this;
  }
  
  public void release(DTMIterator iter)
  {
  }
  
  
  public DTMIterator iter()
  {
    try
    {
    	if(hasCache())
      		return cloneWithReset();
      	else
      		return this; 
    }
    catch (CloneNotSupportedException cnse)
    {
      throw new RuntimeException(cnse.getMessage());
    }
  }
  
  
  public XObject getFresh()
  {
    try
    {
    	if(hasCache())
      		return (XObject)cloneWithReset();
      	else
      		return this; 
    }
    catch (CloneNotSupportedException cnse)
    {
      throw new RuntimeException(cnse.getMessage());
    }
  }

  
  public NodeSetDTM mutableNodeset()
  {
    NodeSetDTM mnl;

    if(m_obj instanceof NodeSetDTM)
    {
      mnl = (NodeSetDTM) m_obj;
    }
    else
    {
      mnl = new NodeSetDTM(iter());
      m_obj = mnl;
      setCurrentPos(0);
    }

    return mnl;
  }

  
  static LessThanComparator S_LT = new LessThanComparator();

  
  static LessThanOrEqualComparator S_LTE = new LessThanOrEqualComparator();

  
  static GreaterThanComparator S_GT = new GreaterThanComparator();

  
  static GreaterThanOrEqualComparator S_GTE =
    new GreaterThanOrEqualComparator();

  
  static EqualComparator S_EQ = new EqualComparator();

  
  static NotEqualComparator S_NEQ = new NotEqualComparator();

  
  public boolean compare(XObject obj2, Comparator comparator)
          throws javax.xml.transform.TransformerException
  {

    boolean result = false;
    int type = obj2.getType();

    if (XObject.CLASS_NODESET == type)
    {
      

      
      
      
      
      
      
      
      
      
      
      
      DTMIterator list1 = iterRaw();
      DTMIterator list2 = ((XNodeSet) obj2).iterRaw();
      int node1;
      java.util.Vector node2Strings = null;

      while (DTM.NULL != (node1 = list1.nextNode()))
      {
        XMLString s1 = getStringFromNode(node1);

        if (null == node2Strings)
        {
          int node2;

          while (DTM.NULL != (node2 = list2.nextNode()))
          {
            XMLString s2 = getStringFromNode(node2);

            if (comparator.compareStrings(s1, s2))
            {
              result = true;

              break;
            }

            if (null == node2Strings)
              node2Strings = new java.util.Vector();

            node2Strings.addElement(s2);
          }
        }
        else
        {
          int n = node2Strings.size();

          for (int i = 0; i < n; i++)
          {
            if (comparator.compareStrings(s1, (XMLString)node2Strings.elementAt(i)))
            {
              result = true;

              break;
            }
          }
        }
      }
      list1.reset();
      list2.reset();
    }
    else if (XObject.CLASS_BOOLEAN == type)
    {

      
      
      
      
      
      
      double num1 = bool() ? 1.0 : 0.0;
      double num2 = obj2.num();

      result = comparator.compareNumbers(num1, num2);
    }
    else if (XObject.CLASS_NUMBER == type)
    {

      
      
      
      
      
      
      
      DTMIterator list1 = iterRaw();
      double num2 = obj2.num();
      int node;

      while (DTM.NULL != (node = list1.nextNode()))
      {
        double num1 = getNumberFromNode(node);

        if (comparator.compareNumbers(num1, num2))
        {
          result = true;

          break;
        }
      }
      list1.reset();
    }
    else if (XObject.CLASS_RTREEFRAG == type)
    {
      XMLString s2 = obj2.xstr();
      DTMIterator list1 = iterRaw();
      int node;

      while (DTM.NULL != (node = list1.nextNode()))
      {
        XMLString s1 = getStringFromNode(node);

        if (comparator.compareStrings(s1, s2))
        {
          result = true;

          break;
        }
      }
      list1.reset();
    }
    else if (XObject.CLASS_STRING == type)
    {

      
      
      
      
      
      
      XMLString s2 = obj2.xstr();
      DTMIterator list1 = iterRaw();
      int node;

      while (DTM.NULL != (node = list1.nextNode()))
      {
        XMLString s1 = getStringFromNode(node);
        if (comparator.compareStrings(s1, s2))
        {
          result = true;

          break;
        }
      }
      list1.reset();
    }
    else
    {
      result = comparator.compareNumbers(this.num(), obj2.num());
    }

    return result;
  }

  
  public boolean lessThan(XObject obj2) throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_LT);
  }

  
  public boolean lessThanOrEqual(XObject obj2) throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_LTE);
  }

  
  public boolean greaterThan(XObject obj2) throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_GT);
  }

  
  public boolean greaterThanOrEqual(XObject obj2)
          throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_GTE);
  }

  
  public boolean equals(XObject obj2)
  {
    try
    {
      return compare(obj2, S_EQ);
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }

  
  public boolean notEquals(XObject obj2) throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_NEQ);
  }
}


abstract class Comparator
{

  
  abstract boolean compareStrings(XMLString s1, XMLString s2);

  
  abstract boolean compareNumbers(double n1, double n2);
}


class LessThanComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return (s1.toDouble() < s2.toDouble());
    
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 < n2;
  }
}


class LessThanOrEqualComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return (s1.toDouble() <= s2.toDouble());
    
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 <= n2;
  }
}


class GreaterThanComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return (s1.toDouble() > s2.toDouble());
    
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 > n2;
  }
}


class GreaterThanOrEqualComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return (s1.toDouble() >= s2.toDouble());
    
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 >= n2;
  }
}


class EqualComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return s1.equals(s2);
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 == n2;
  }
}


class NotEqualComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return !s1.equals(s2);
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 != n2;
  }
}
"
org.apache.xalan.templates.ElemNumber,42,3,0,29,135,617,5,27,27,0.860310421,2384,1.0,9,0.830508475,0.136298422,2,7,55.5,26,2.0952,1,"
package org.apache.xalan.templates;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.util.Locale;
import java.util.NoSuchElementException;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.CountersTable;
import org.apache.xalan.transformer.DecimalToRoman;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.NodeVector;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.StringBufferPool;
import org.apache.xml.utils.res.XResourceBundle;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;

import org.w3c.dom.Node;

import org.xml.sax.SAXException;




public class ElemNumber extends ElemTemplateElement 
{

    private class MyPrefixResolver implements PrefixResolver {
        
        DTM dtm;
        int handle;
        boolean handleNullPrefix;
        
		
		public MyPrefixResolver(Node xpathExpressionContext, DTM dtm, int handle, boolean handleNullPrefix) {
            this.dtm = dtm;
            this.handle = handle;
            this.handleNullPrefix = handleNullPrefix;
		}

    	
		public String getNamespaceForPrefix(String prefix) {
            return dtm.getNamespaceURI(handle);
		}
        
        
        public String getNamespaceForPrefix(String prefix, Node context) {
            return getNamespaceForPrefix(prefix);
        }

		
		public String getBaseIdentifier() {
			return ElemNumber.this.getBaseIdentifier();
		}

		
		public boolean handlesNullPrefixes() {
			return handleNullPrefix;
		}

}
    
  
  private XPath m_countMatchPattern = null;

  
  public void setCount(XPath v)
  {
    m_countMatchPattern = v;
  }

  
  public XPath getCount()
  {
    return m_countMatchPattern;
  }

  
  private XPath m_fromMatchPattern = null;

  
  public void setFrom(XPath v)
  {
    m_fromMatchPattern = v;
  }

  
  public XPath getFrom()
  {
    return m_fromMatchPattern;
  }

  
  private int m_level = Constants.NUMBERLEVEL_SINGLE;

  
  public void setLevel(int v)
  {
    m_level = v;
  }

  
  public int getLevel()
  {
    return m_level;
  }

  
  private XPath m_valueExpr = null;

  
  public void setValue(XPath v)
  {
    m_valueExpr = v;
  }

  
  public XPath getValue()
  {
    return m_valueExpr;
  }

  
  private AVT m_format_avt = null;

  
  public void setFormat(AVT v)
  {
    m_format_avt = v;
  }

  
  public AVT getFormat()
  {
    return m_format_avt;
  }

  
  private AVT m_lang_avt = null;

  
  public void setLang(AVT v)
  {
    m_lang_avt = v;
  }

  
  public AVT getLang()
  {
    return m_lang_avt;
  }

  
  private AVT m_lettervalue_avt = null;

  
  public void setLetterValue(AVT v)
  {
    m_lettervalue_avt = v;
  }

  
  public AVT getLetterValue()
  {
    return m_lettervalue_avt;
  }

  
  private AVT m_groupingSeparator_avt = null;

  
  public void setGroupingSeparator(AVT v)
  {
    m_groupingSeparator_avt = v;
  }

  
  public AVT getGroupingSeparator()
  {
    return m_groupingSeparator_avt;
  }

  
  private AVT m_groupingSize_avt = null;

  
  public void setGroupingSize(AVT v)
  {
    m_groupingSize_avt = v;
  }

  
  public AVT getGroupingSize()
  {
    return m_groupingSize_avt;
  }

  

  

  
  private final static DecimalToRoman m_romanConvertTable[] = {
    new DecimalToRoman(1000, ""M"", 900, ""CM""),
    new DecimalToRoman(500, ""D"", 400, ""CD""),
    new DecimalToRoman(100L, ""C"", 90L, ""XC""),
    new DecimalToRoman(50L, ""L"", 40L, ""XL""),
    new DecimalToRoman(10L, ""X"", 9L, ""IX""),
    new DecimalToRoman(5L, ""V"", 4L, ""IV""),
    new DecimalToRoman(1L, ""I"", 1L, ""I"") };

  
  private static char[] m_alphaCountTable = null;
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_countMatchPattern)
      m_countMatchPattern.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_format_avt)
      m_format_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_fromMatchPattern)
      m_fromMatchPattern.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_groupingSeparator_avt)
      m_groupingSeparator_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_groupingSize_avt)
      m_groupingSize_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_lang_avt)
      m_lang_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_lettervalue_avt)
      m_lettervalue_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_valueExpr)
      m_valueExpr.fixupVariables(vnames, cstate.getGlobalsSize());
  }


  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_NUMBER;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_NUMBER_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

     if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    int sourceNode = transformer.getXPathContext().getCurrentNode();
    String countString = getCountString(transformer, sourceNode);

    try
    {
      transformer.getResultTreeHandler().characters(countString.toCharArray(),
                                                    0, countString.length());
    }
    catch(SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
	    transformer.getTraceManager().fireTraceEndEvent(this); 
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }

  
  int findAncestor(
          XPathContext xctxt, XPath fromMatchPattern, XPath countMatchPattern, 
          int context, ElemNumber namespaceContext)
            throws javax.xml.transform.TransformerException
  {
    DTM dtm = xctxt.getDTM(context);
    while (DTM.NULL != context)
    {
      if (null != fromMatchPattern)
      {
        if (fromMatchPattern.getMatchScore(xctxt, context)
                != XPath.MATCH_SCORE_NONE)
        {

          
          break;
        }
      }

      if (null != countMatchPattern)
      {
        if (countMatchPattern.getMatchScore(xctxt, context)
                != XPath.MATCH_SCORE_NONE)
        {
          break;
        }
      }

      context = dtm.getParent(context);
    }

    return context;
  }

  
  private int findPrecedingOrAncestorOrSelf(
          XPathContext xctxt, XPath fromMatchPattern, XPath countMatchPattern, 
          int context, ElemNumber namespaceContext)
            throws javax.xml.transform.TransformerException
  {
    DTM dtm = xctxt.getDTM(context);
    while (DTM.NULL != context)
    {
      if (null != fromMatchPattern)
      {
        if (fromMatchPattern.getMatchScore(xctxt, context)
                != XPath.MATCH_SCORE_NONE)
        {
          context = DTM.NULL;

          break;
        }
      }

      if (null != countMatchPattern)
      {
        if (countMatchPattern.getMatchScore(xctxt, context)
                != XPath.MATCH_SCORE_NONE)
        {
          break;
        }
      }

      int prevSibling = dtm.getPreviousSibling(context);

      if (DTM.NULL == prevSibling)
      {
        context = dtm.getParent(context);
      }
      else
      {

        
        context = dtm.getLastChild(prevSibling);

        if (context == DTM.NULL)
          context = prevSibling;
      }
    }

    return context;
  }

  
  XPath getCountMatchPattern(XPathContext support, int contextNode)
          throws javax.xml.transform.TransformerException
  {

    XPath countMatchPattern = m_countMatchPattern;
    DTM dtm = support.getDTM(contextNode);
    if (null == countMatchPattern)
    {
      switch (dtm.getNodeType(contextNode))
      {
      case DTM.ELEMENT_NODE :
        MyPrefixResolver resolver;

        if (dtm.getNamespaceURI(contextNode) == null) {
             resolver =  new MyPrefixResolver(dtm.getNode(contextNode), dtm,contextNode, false);
        } else {
            resolver = new MyPrefixResolver(dtm.getNode(contextNode), dtm,contextNode, true);
        }

        countMatchPattern = new XPath(dtm.getNodeName(contextNode), this, resolver,
                                      XPath.MATCH, support.getErrorListener());
        break;

      case DTM.ATTRIBUTE_NODE :

        
        countMatchPattern = new XPath(""@"" + dtm.getNodeName(contextNode), this,
                                      this, XPath.MATCH, support.getErrorListener());
        break;
      case DTM.CDATA_SECTION_NODE :
      case DTM.TEXT_NODE :

        
        countMatchPattern = new XPath(""text()"", this, this, XPath.MATCH, support.getErrorListener());
        break;
      case DTM.COMMENT_NODE :

        
        countMatchPattern = new XPath(""comment()"", this, this, XPath.MATCH, support.getErrorListener());
        break;
      case DTM.DOCUMENT_NODE :

        
        countMatchPattern = new XPath(""/"", this, this, XPath.MATCH, support.getErrorListener());
        break;
      case DTM.PROCESSING_INSTRUCTION_NODE :

        
        countMatchPattern = new XPath(""pi("" + dtm.getNodeName(contextNode)
                                      + "")"", this, this, XPath.MATCH, support.getErrorListener());
        break;
      default :
        countMatchPattern = null;
      }
    }

    return countMatchPattern;
  }

  
  String getCountString(TransformerImpl transformer, int sourceNode)
          throws TransformerException
  {

    long[] list = null;
    XPathContext xctxt = transformer.getXPathContext();
    CountersTable ctable = transformer.getCountersTable();

    if (null != m_valueExpr)
    {
      XObject countObj = m_valueExpr.execute(xctxt, sourceNode, this);
      long count = (long)java.lang.Math.floor(countObj.num()+ 0.5);

      list = new long[1];
      list[0] = count;
    }
    else
    {
      if (Constants.NUMBERLEVEL_ANY == m_level)
      {
        list = new long[1];
        list[0] = ctable.countNode(xctxt, this, sourceNode);
      }
      else
      {
        NodeVector ancestors =
          getMatchingAncestors(xctxt, sourceNode,
                               Constants.NUMBERLEVEL_SINGLE == m_level);
        int lastIndex = ancestors.size() - 1;

        if (lastIndex >= 0)
        {
          list = new long[lastIndex + 1];

          for (int i = lastIndex; i >= 0; i--)
          {
            int target = ancestors.elementAt(i);

            list[lastIndex - i] = ctable.countNode(xctxt, this, target);
          }
        }
      }
    }

    return (null != list)
           ? formatNumberList(transformer, list, sourceNode) : """";
  }

  
  public int getPreviousNode(XPathContext xctxt, int pos)
          throws TransformerException
  {

    XPath countMatchPattern = getCountMatchPattern(xctxt, pos);
    DTM dtm = xctxt.getDTM(pos);

    if (Constants.NUMBERLEVEL_ANY == m_level)
    {
      XPath fromMatchPattern = m_fromMatchPattern;

      
      
      
      while (DTM.NULL != pos)
      {

        
        
        
        int next = dtm.getPreviousSibling(pos);

        if (DTM.NULL == next)
        {
          next = dtm.getParent(pos);

          if ((DTM.NULL != next) && ((((null != fromMatchPattern) && (fromMatchPattern.getMatchScore(
                  xctxt, next) != XPath.MATCH_SCORE_NONE))) 
              || (dtm.getNodeType(next) == DTM.DOCUMENT_NODE)))
          {
            pos = DTM.NULL;  

            break;  
          }
        }
        else
        {

          
          int child = next;

          while (DTM.NULL != child)
          {
            child = dtm.getLastChild(next);

            if (DTM.NULL != child)
              next = child;
          }
        }

        pos = next;

        if ((DTM.NULL != pos)
                && ((null == countMatchPattern)
                    || (countMatchPattern.getMatchScore(xctxt, pos)
                        != XPath.MATCH_SCORE_NONE)))
        {
          break;
        }
      }
    }
    else  
    {
      while (DTM.NULL != pos)
      {
        pos = dtm.getPreviousSibling(pos);

        if ((DTM.NULL != pos)
                && ((null == countMatchPattern)
                    || (countMatchPattern.getMatchScore(xctxt, pos)
                        != XPath.MATCH_SCORE_NONE)))
        {
          break;
        }
      }
    }

    return pos;
  }

  
  public int getTargetNode(XPathContext xctxt, int sourceNode)
          throws TransformerException
  {

    int target = DTM.NULL;
    XPath countMatchPattern = getCountMatchPattern(xctxt, sourceNode);

    if (Constants.NUMBERLEVEL_ANY == m_level)
    {
      target = findPrecedingOrAncestorOrSelf(xctxt, m_fromMatchPattern,
                                             countMatchPattern, sourceNode,
                                             this);
    }
    else
    {
      target = findAncestor(xctxt, m_fromMatchPattern, countMatchPattern,
                            sourceNode, this);
    }

    return target;
  }

  
  NodeVector getMatchingAncestors(
          XPathContext xctxt, int node, boolean stopAtFirstFound)
            throws javax.xml.transform.TransformerException
  {

    NodeSetDTM ancestors = new NodeSetDTM(xctxt.getDTMManager());
    XPath countMatchPattern = getCountMatchPattern(xctxt, node);
    DTM dtm = xctxt.getDTM(node);

    while (DTM.NULL != node)
    {
      if ((null != m_fromMatchPattern)
              && (m_fromMatchPattern.getMatchScore(xctxt, node)
                  != XPath.MATCH_SCORE_NONE))
      {

        
        
        
        
        
        
        if (!stopAtFirstFound)
          break;
      }

      if (null == countMatchPattern)
        System.out.println(
          ""Programmers error! countMatchPattern should never be null!"");

      if (countMatchPattern.getMatchScore(xctxt, node)
              != XPath.MATCH_SCORE_NONE)
      {
        ancestors.addElement(node);

        if (stopAtFirstFound)
          break;
      }

      node = dtm.getParent(node);
    }

    return ancestors;
  }  

  
  Locale getLocale(TransformerImpl transformer, int contextNode)
          throws TransformerException
  {

    Locale locale = null;

    if (null != m_lang_avt)
    {
      XPathContext xctxt = transformer.getXPathContext();
      String langValue = m_lang_avt.evaluate(xctxt, contextNode, this);

      if (null != langValue)
      {

        
        
        
        locale = new Locale(langValue.toUpperCase(), """");

        
        if (null == locale)
        {
          transformer.getMsgMgr().warn(this, null, xctxt.getDTM(contextNode).getNode(contextNode),
                                       XSLTErrorResources.WG_LOCALE_NOT_FOUND,
                                       new Object[]{ langValue });  

          locale = Locale.getDefault();
        }
      }
    }
    else
    {
      locale = Locale.getDefault();
    }

    return locale;
  }

  
  private DecimalFormat getNumberFormatter(
          TransformerImpl transformer, int contextNode) throws TransformerException
  {
    
    
    
    Locale locale = (Locale)getLocale(transformer, contextNode).clone();

    
    DecimalFormat formatter = null;

    
    
    
    

    String digitGroupSepValue =
      (null != m_groupingSeparator_avt)
      ? m_groupingSeparator_avt.evaluate(
      transformer.getXPathContext(), contextNode, this) : null;
      
      
    
    
    if ((digitGroupSepValue != null) && (!m_groupingSeparator_avt.isSimple()) &&
        (digitGroupSepValue.length() != 1))
    {
            transformer.getMsgMgr().warn(
               this, XSLTErrorResources.WG_ILLEGAL_ATTRIBUTE_VALUE,
               new Object[]{ Constants.ATTRNAME_NAME, m_groupingSeparator_avt.getName()});   
    }                  
      
      
    String nDigitsPerGroupValue =
      (null != m_groupingSize_avt)
      ? m_groupingSize_avt.evaluate(
      transformer.getXPathContext(), contextNode, this) : null;

    
    if ((null != digitGroupSepValue) && (null != nDigitsPerGroupValue) &&
        
        (digitGroupSepValue.length() > 0))
    {
      try
      {
        formatter = (DecimalFormat) NumberFormat.getNumberInstance(locale);
        formatter.setGroupingSize(
          Integer.valueOf(nDigitsPerGroupValue).intValue());
        
        DecimalFormatSymbols symbols = formatter.getDecimalFormatSymbols();
        symbols.setGroupingSeparator(digitGroupSepValue.charAt(0));
        formatter.setDecimalFormatSymbols(symbols);
        formatter.setGroupingUsed(true);
      }
      catch (NumberFormatException ex)
      {
        formatter.setGroupingUsed(false);
      }
    }

    return formatter;
  }

  
  String formatNumberList(
          TransformerImpl transformer, long[] list, int contextNode)
            throws TransformerException
  {

    String numStr;
    FastStringBuffer formattedNumber = StringBufferPool.get();

    try
    {
      int nNumbers = list.length, numberWidth = 1;
      char numberType = '1';
      String formatToken, lastSepString = null, formatTokenString = null;

      
      
      
      
      
      
      
      String lastSep = ""."";
      boolean isFirstToken = true;  
      String formatValue =
        (null != m_format_avt)
        ? m_format_avt.evaluate(
        transformer.getXPathContext(), contextNode, this) : null;

      if (null == formatValue)
        formatValue = ""1"";

      NumberFormatStringTokenizer formatTokenizer =
        new NumberFormatStringTokenizer(formatValue);

      
      
      for (int i = 0; i < nNumbers; i++)
      {

        
        if (formatTokenizer.hasMoreTokens())
        {
          formatToken = formatTokenizer.nextToken();

          
          
          if (Character.isLetterOrDigit(
                  formatToken.charAt(formatToken.length() - 1)))
          {
            numberWidth = formatToken.length();
            numberType = formatToken.charAt(numberWidth - 1);
          }

          
          
          else if (formatTokenizer.isLetterOrDigitAhead())
          {
            formatTokenString = formatToken;

            
            
            
            while (formatTokenizer.nextIsSep())
            {
              formatToken = formatTokenizer.nextToken();
              formatTokenString += formatToken;
            }

            
            
            
            
            if (!isFirstToken)
              lastSep = formatTokenString;

            
            formatToken = formatTokenizer.nextToken();
            numberWidth = formatToken.length();
            numberType = formatToken.charAt(numberWidth - 1);
          }
          else  
          {

            
            
            lastSepString = formatToken;

            
            while (formatTokenizer.hasMoreTokens())
            {
              formatToken = formatTokenizer.nextToken();
              lastSepString += formatToken;
            }
          }  
        }  

        
        
        
        
        if (null != formatTokenString && isFirstToken)
        {
          formattedNumber.append(formatTokenString);
        }
        else if (null != lastSep &&!isFirstToken)
          formattedNumber.append(lastSep);

        getFormattedNumber(transformer, contextNode, numberType, numberWidth,
                           list[i], formattedNumber);

        isFirstToken = false;  
      }  

      
      
      while (formatTokenizer.isLetterOrDigitAhead())
      {
        formatTokenizer.nextToken();
      }

      if (lastSepString != null)
        formattedNumber.append(lastSepString);

      while (formatTokenizer.hasMoreTokens())
      {
        formatToken = formatTokenizer.nextToken();

        formattedNumber.append(formatToken);
      }

      numStr = formattedNumber.toString();
    }
    finally
    {
      StringBufferPool.free(formattedNumber);
    }

    return numStr;
  }  

  

  
  private void getFormattedNumber(
          TransformerImpl transformer, int contextNode, 
          char numberType, int numberWidth, long listElement, 
          FastStringBuffer formattedNumber)
            throws javax.xml.transform.TransformerException
  {


    String letterVal =
      (m_lettervalue_avt != null)
      ? m_lettervalue_avt.evaluate(
      transformer.getXPathContext(), contextNode, this) : null;

    switch (numberType)
    {
    case 'A' :
      if (m_alphaCountTable == null)
      {
        XResourceBundle thisBundle;

        thisBundle =
          (XResourceBundle) XResourceBundle.loadResourceBundle(
            org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, getLocale(transformer, contextNode));

        char[] alphabet;

        alphabet = (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET);
        m_alphaCountTable = alphabet;
      }

      int2alphaCount(listElement, m_alphaCountTable, formattedNumber);
      break;
    case 'a' :
      if (m_alphaCountTable == null)
      {
        XResourceBundle thisBundle;

        thisBundle =
          (XResourceBundle) XResourceBundle.loadResourceBundle(
            org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, getLocale(transformer, contextNode));

        char[] alphabet;

        alphabet = (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET);
        m_alphaCountTable = alphabet;
      }

      FastStringBuffer stringBuf = StringBufferPool.get();

      try
      {
        int2alphaCount(listElement, m_alphaCountTable, stringBuf);
        formattedNumber.append(
          stringBuf.toString().toLowerCase(
            getLocale(transformer, contextNode)));
      }
      finally
      {
        StringBufferPool.free(stringBuf);
      }
      break;
    case 'I' :
      formattedNumber.append(long2roman(listElement, true));
      break;
    case 'i' :
      formattedNumber.append(
        long2roman(listElement, true).toLowerCase(
          getLocale(transformer, contextNode)));
      break;
    case 0x3042 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ja"", ""JP"", ""HA""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        formattedNumber.append(
          int2singlealphaCount(
            listElement,
            (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET)));

      break;
    }
    case 0x3044 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ja"", ""JP"", ""HI""));

      if ((letterVal != null)
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        formattedNumber.append(
          int2singlealphaCount(
            listElement,
            (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET)));

      break;
    }
    case 0x30A2 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ja"", ""JP"", ""A""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        formattedNumber.append(
          int2singlealphaCount(
            listElement,
            (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET)));

      break;
    }
    case 0x30A4 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ja"", ""JP"", ""I""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        formattedNumber.append(
          int2singlealphaCount(
            listElement,
            (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET)));

      break;
    }
    case 0x4E00 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""zh"", ""CN""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
      {
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      }
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x58F9 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""zh"", ""TW""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x0E51 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""th"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x05D0 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""he"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x10D0 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ka"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x03B1 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""el"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x0430 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""cy"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    default :  
      DecimalFormat formatter = getNumberFormatter(transformer, contextNode);
      String padString = formatter == null ? String.valueOf(0) : formatter.format(0);    
      String numString = formatter == null ? String.valueOf(listElement) : formatter.format(listElement);
      int nPadding = numberWidth - numString.length();

      for (int k = 0; k < nPadding; k++)
      {
        formattedNumber.append(padString);
      }

      formattedNumber.append(numString);
    }
  }
  
  
   String getZeroString()
   {
     return """"+0;
   }

  
  protected String int2singlealphaCount(long val, char[] table)
  {

    int radix = table.length;

    
    if (val > radix)
    {
      return getZeroString();
    }
    else
      return (new Character(table[(int)val - 1])).toString();  
  }

  
  protected void int2alphaCount(long val, char[] aTable,
                                FastStringBuffer stringBuf)
  {

    int radix = aTable.length;
    char[] table = new char[aTable.length];

    
    int i;

    for (i = 0; i < aTable.length - 1; i++)
    {
      table[i + 1] = aTable[i];
    }

    table[0] = aTable[i];

    
    
    
    char buf[] = new char[100];

    
    
    
    
    int charPos;

    charPos = buf.length - 1;  

    
    int lookupIndex = 1;  

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    long correction = 0;

    
    do
    {

      
      
      
      correction =
        ((lookupIndex == 0) || (correction != 0 && lookupIndex == radix - 1))
        ? (radix - 1) : 0;

      
      lookupIndex = (int)(val + correction) % radix;

      
      val = (val / radix);

      
      if (lookupIndex == 0 && val == 0)
        break;

      
      buf[charPos--] = table[lookupIndex];  
    }
    while (val > 0);

    stringBuf.append(buf, charPos + 1, (buf.length - charPos - 1));
  }

  
  protected String tradAlphaCount(long val, XResourceBundle thisBundle)
  {

    
    if (val > Long.MAX_VALUE)
    {
      this.error(XSLTErrorResources.ER_NUMBER_TOO_BIG);
      return XSLTErrorResources.ERROR_STRING;
    }
    char[] table = null;

    
    int lookupIndex = 1;  

    
    
    
    char buf[] = new char[100];

    
    
    
    
    int charPos;

    charPos = 0;  

    
    int[] groups = (int[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_NUMBERGROUPS);

    
    String[] tables =
      (String[]) (thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_NUM_TABLES));

    
    
    String numbering = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.LANG_NUMBERING);

    
    if (numbering.equals(org.apache.xml.utils.res.XResourceBundle.LANG_MULT_ADD))
    {
      String mult_order = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.MULT_ORDER);
      long[] multiplier =
        (long[]) (thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_MULTIPLIER));
      char[] zeroChar = (char[]) thisBundle.getObject(""zero"");
      int i = 0;

      
      while (i < multiplier.length && val < multiplier[i])
      {
        i++;
      }

      do
      {
        if (i >= multiplier.length)
          break;  

        
        
        
        if (val < multiplier[i])
        {
          if (zeroChar.length == 0)
          {
            i++;
          }
          else
          {
            if (buf[charPos - 1] != zeroChar[0])
              buf[charPos++] = zeroChar[0];

            i++;
          }
        }
        else if (val >= multiplier[i])
        {
          long mult = val / multiplier[i];

          val = val % multiplier[i];  

          int k = 0;

          while (k < groups.length)
          {
            lookupIndex = 1;  

            if (mult / groups[k] <= 0)  
              k++;
            else
            {

              
              char[] THEletters = (char[]) thisBundle.getObject(tables[k]);

              table = new char[THEletters.length + 1];

              int j;

              for (j = 0; j < THEletters.length; j++)
              {
                table[j + 1] = THEletters[j];
              }

              table[0] = THEletters[j - 1];  

              
              lookupIndex = (int)mult / groups[k];

              
              if (lookupIndex == 0 && mult == 0)
                break;

              char multiplierChar = ((char[]) (thisBundle.getObject(
                org.apache.xml.utils.res.XResourceBundle.LANG_MULTIPLIER_CHAR)))[i];

              
              if (lookupIndex < table.length)
              {
                if (mult_order.equals(org.apache.xml.utils.res.XResourceBundle.MULT_PRECEDES))
                {
                  buf[charPos++] = multiplierChar;
                  buf[charPos++] = table[lookupIndex];
                }
                else
                {

                  
                  if (lookupIndex == 1 && i == multiplier.length - 1){}
                  else
                    buf[charPos++] = table[lookupIndex];

                  buf[charPos++] = multiplierChar;
                }

                break;  
              }
              else
                return XSLTErrorResources.ERROR_STRING;
            }  
          }  

          i++;
        }  
      }  
      while (i < multiplier.length);
    }

    
    int count = 0;
    String tableName;

    
    while (count < groups.length)
    {
      if (val / groups[count] <= 0)  
        count++;
      else
      {
        char[] theletters = (char[]) thisBundle.getObject(tables[count]);

        table = new char[theletters.length + 1];

        int j;

        
        for (j = 0; j < theletters.length; j++)
        {
          table[j + 1] = theletters[j];
        }

        table[0] = theletters[j - 1];  

        
        lookupIndex = (int)val / groups[count];

        
        val = val % groups[count];

        
        if (lookupIndex == 0 && val == 0)
          break;

        if (lookupIndex < table.length)
        {

          
          buf[charPos++] = table[lookupIndex];  
        }
        else
          return XSLTErrorResources.ERROR_STRING;

        count++;
      }
    }  

    
    return new String(buf, 0, charPos);
  }

  
  protected String long2roman(long val, boolean prefixesAreOK)
  {

    if (val <= 0)
    {
      return getZeroString();
    }

    String roman = """";
    int place = 0;

    if (val <= 3999L)
    {
      do
      {
        while (val >= m_romanConvertTable[place].m_postValue)
        {
          roman += m_romanConvertTable[place].m_postLetter;
          val -= m_romanConvertTable[place].m_postValue;
        }

        if (prefixesAreOK)
        {
          if (val >= m_romanConvertTable[place].m_preValue)
          {
            roman += m_romanConvertTable[place].m_preLetter;
            val -= m_romanConvertTable[place].m_preValue;
          }
        }

        place++;
      }
      while (val > 0);
    }
    else
    {
      roman = XSLTErrorResources.ERROR_STRING;
    }

    return roman;
  }  
  
  
  public void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  	{
	  	if(null != m_countMatchPattern)
	  		m_countMatchPattern.getExpression().callVisitors(m_countMatchPattern, visitor);
	  	if(null != m_fromMatchPattern)
	  		m_fromMatchPattern.getExpression().callVisitors(m_fromMatchPattern, visitor);
	  	if(null != m_valueExpr)
	  		m_valueExpr.getExpression().callVisitors(m_valueExpr, visitor);
	
	  	if(null != m_format_avt)
	  		m_format_avt.callVisitors(visitor);
	  	if(null != m_groupingSeparator_avt)
	  		m_groupingSeparator_avt.callVisitors(visitor);
	  	if(null != m_groupingSize_avt)
	  		m_groupingSize_avt.callVisitors(visitor);
	  	if(null != m_lang_avt)
	  		m_lang_avt.callVisitors(visitor);
	  	if(null != m_lettervalue_avt)
	  		m_lettervalue_avt.callVisitors(visitor);
  	}

    super.callChildVisitors(visitor, callAttrs);
  }


  
  class NumberFormatStringTokenizer
  {

    
    private int currentPosition;

    
    private int maxPosition;

    
    private String str;

    
    public NumberFormatStringTokenizer(String str)
    {
      this.str = str;
      maxPosition = str.length();
    }

    
    public void reset()
    {
      currentPosition = 0;
    }

    
    public String nextToken()
    {

      if (currentPosition >= maxPosition)
      {
        throw new NoSuchElementException();
      }

      int start = currentPosition;

      while ((currentPosition < maxPosition)
             && Character.isLetterOrDigit(str.charAt(currentPosition)))
      {
        currentPosition++;
      }

      if ((start == currentPosition)
              && (!Character.isLetterOrDigit(str.charAt(currentPosition))))
      {
        currentPosition++;
      }

      return str.substring(start, currentPosition);
    }

    
    public boolean isLetterOrDigitAhead()
    {

      int pos = currentPosition;

      while (pos < maxPosition)
      {
        if (Character.isLetterOrDigit(str.charAt(pos)))
          return true;

        pos++;
      }

      return false;
    }

    
    public boolean nextIsSep()
    {

      if (Character.isLetterOrDigit(str.charAt(currentPosition)))
        return false;
      else
        return true;
    }

    
    public boolean hasMoreTokens()
    {
      return (currentPosition >= maxPosition) ? false : true;
    }

    
    public int countTokens()
    {

      int count = 0;
      int currpos = currentPosition;

      while (currpos < maxPosition)
      {
        int start = currpos;

        while ((currpos < maxPosition)
               && Character.isLetterOrDigit(str.charAt(currpos)))
        {
          currpos++;
        }

        if ((start == currpos)
                && (Character.isLetterOrDigit(str.charAt(currpos)) == false))
        {
          currpos++;
        }

        count++;
      }

      return count;
    }
  }  



}
"
org.apache.xpath.compiler.OpCodes,1,1,0,0,2,0,0,0,1,2.0,68,0.015625,0,0.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xpath.compiler;


public class OpCodes
{

  
  public static final int ENDOP = -1;

  
  public static final int EMPTY = -2;

  
  public static final int ELEMWILDCARD = -3;

  
  public static final int OP_XPATH = 1;

  
  public static final int OP_OR = 2;

  
  public static final int OP_AND = 3;

  
  public static final int OP_NOTEQUALS = 4;

  
  public static final int OP_EQUALS = 5;

  
  public static final int OP_LTE = 6;

  
  public static final int OP_LT = 7;

  
  public static final int OP_GTE = 8;

  
  public static final int OP_GT = 9;

  
  public static final int OP_PLUS = 10;

  
  public static final int OP_MINUS = 11;

  
  public static final int OP_MULT = 12;

  
  public static final int OP_DIV = 13;

  
  public static final int OP_MOD = 14;

  
  public static final int OP_QUO = 15;

  
  public static final int OP_NEG = 16;

  
  public static final int OP_STRING = 17;

  
  public static final int OP_BOOL = 18;

  
  public static final int OP_NUMBER = 19;

  
  public static final int OP_UNION = 20;

  
  public static final int OP_LITERAL = 21;

  
  static final int FIRST_NODESET_OP = 22;

  
  public static final int OP_VARIABLE = 22;

  
  public static final int OP_GROUP = 23;

  
  public static final int OP_EXTFUNCTION = 24;

  
  public static final int OP_FUNCTION = 25;

  
  static final int LAST_NODESET_OP = 25;

  
  public static final int OP_ARGUMENT = 26;

  
  public static final int OP_NUMBERLIT = 27;

  
  public static final int OP_LOCATIONPATH = 28;

  
  
  

  
  public static final int OP_PREDICATE = 29;

  
  public static final int OP_MATCHPATTERN = 30;

  
  public static final int OP_LOCATIONPATHPATTERN = 31;

  
  public static final int NODETYPE_COMMENT = 1030;

  
  public static final int NODETYPE_TEXT = 1031;

  
  public static final int NODETYPE_PI = 1032;

  
  public static final int NODETYPE_NODE = 1033;

  
  public static final int NODENAME = 34;

  
  public static final int NODETYPE_ROOT = 35;

  
  public static final int NODETYPE_ANYELEMENT = 36;

  
  public static final int NODETYPE_FUNCTEST = 1034;

  
  public static final int AXES_START_TYPES = 37;

  
  public static final int FROM_ANCESTORS = 37;

  
  public static final int FROM_ANCESTORS_OR_SELF = 38;

  
  public static final int FROM_ATTRIBUTES = 39;

  
  public static final int FROM_CHILDREN = 40;

  
  public static final int FROM_DESCENDANTS = 41;

  
  public static final int FROM_DESCENDANTS_OR_SELF = 42;

  
  public static final int FROM_FOLLOWING = 43;

  
  public static final int FROM_FOLLOWING_SIBLINGS = 44;

  
  public static final int FROM_PARENT = 45;

  
  public static final int FROM_PRECEDING = 46;

  
  public static final int FROM_PRECEDING_SIBLINGS = 47;

  
  public static final int FROM_SELF = 48;

  
  public static final int FROM_NAMESPACE = 49;

  
  public static final int FROM_ROOT = 50;

  
  public static final int MATCH_ATTRIBUTE = 51;

  
  public static final int MATCH_ANY_ANCESTOR = 52;

  
  public static final int MATCH_IMMEDIATE_ANCESTOR = 53;

  
  public static final int AXES_END_TYPES = 53;

  
  private static final int NEXT_FREE_ID = 99;
}
"
org.apache.xalan.xsltc.compiler.ApplyTemplates,6,3,0,27,62,0,2,27,5,0.65,379,1.0,3,0.918032787,0.305555556,1,6,61.5,13,3.3333,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;
import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.ResultTreeType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class ApplyTemplates extends Instruction {
    private Expression _select;
    private Type       _type = null;
    private QName      _modeName;
    private String     _functionName;
	
    public void display(int indent) {
	indent(indent);
	Util.println(""ApplyTemplates"");
	indent(indent + IndentIncrement);
	Util.println(""select "" + _select.toString());
	if (_modeName != null) {
	    indent(indent + IndentIncrement);
	    Util.println(""mode "" + _modeName);
	}
    }

    public boolean hasWithParams() {
	return hasContents();
    }

    public void parseContents(Parser parser) {
	final String select = getAttribute(""select"");
	final String mode   = getAttribute(""mode"");
	
	if (select.length() > 0) {
	    _select = parser.parseExpression(this, ""select"", null);

	    
	    final Expression fpe = new ForwardPositionExpr(_select);
	    _select.setParent(fpe);
	    fpe.setParser(_select.getParser());
	    _select = fpe;
	}
	
	if (mode.length() > 0) {
	    _modeName = parser.getQNameIgnoreDefaultNs(mode);
	}
	
	
	_functionName =
	    parser.getTopLevelStylesheet().getMode(_modeName).functionName();
	parseChildren(parser);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_select != null) {
	    _type = _select.typeCheck(stable);
	    if (_type instanceof NodeType || _type instanceof ReferenceType) {
		_select = new CastExpr(_select, Type.NodeSet);
		_type = Type.NodeSet;
	    }
	    if (_type instanceof NodeSetType||_type instanceof ResultTreeType) {
		typeCheckContents(stable); 
		return Type.Void;
	    }
	    throw new TypeCheckError(this);
	}
	else {
	    typeCheckContents(stable);		
	    return Type.Void;
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	boolean setStartNodeCalled = false;
	final Stylesheet stylesheet = classGen.getStylesheet();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int current = methodGen.getLocalIndex(""current"");

	
	final Vector sortObjects = new Vector();
	final Enumeration children = elements();
	while (children.hasMoreElements()) {
	    final Object child = children.nextElement();
	    if (child instanceof Sort) {
		sortObjects.addElement(child);
	    }
	}

	
	if (stylesheet.hasLocalParams() || hasContents()) {
	    il.append(classGen.loadTranslet());
	    final int pushFrame = cpg.addMethodref(TRANSLET_CLASS,
						   PUSH_PARAM_FRAME,
						   PUSH_PARAM_FRAME_SIG);
	    il.append(new INVOKEVIRTUAL(pushFrame));
	    
	    translateContents(classGen, methodGen);
	}


	il.append(classGen.loadTranslet());

	
	if ((_type != null) && (_type instanceof ResultTreeType)) {
	    
	    if (sortObjects.size() > 0) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.RESULT_TREE_SORT_ERR,this);
		getParser().reportError(WARNING, err);
	    }
	    
	    _select.translate(classGen, methodGen);	
	    
	    _type.translateTo(classGen, methodGen, Type.NodeSet);
	}
	else {
	    il.append(methodGen.loadDOM());

	    
	    if (sortObjects.size() > 0) {
		Sort.translateSortIterator(classGen, methodGen,
					   _select, sortObjects);
		int setStartNode = cpg.addInterfaceMethodref(NODE_ITERATOR,
							     SET_START_NODE,
							     ""(I)""+
							     NODE_ITERATOR_SIG);
		il.append(methodGen.loadCurrentNode());
		il.append(new INVOKEINTERFACE(setStartNode,2));
		setStartNodeCalled = true;	
	    }
	    else {
		if (_select == null)
		    Mode.compileGetChildren(classGen, methodGen, current);
		else
		    _select.translate(classGen, methodGen);
	    }
	}

	if (_select != null && !setStartNodeCalled) {
	    _select.startResetIterator(classGen, methodGen);
	}

	
	final String className = classGen.getStylesheet().getClassName();
	il.append(methodGen.loadHandler());
	final String applyTemplatesSig = classGen.getApplyTemplatesSig();
	final int applyTemplates = cpg.addMethodref(className,
						    _functionName,
						    applyTemplatesSig);
	il.append(new INVOKEVIRTUAL(applyTemplates));
	
	
	if (stylesheet.hasLocalParams() || hasContents()) {
	    il.append(classGen.loadTranslet());
	    final int popFrame = cpg.addMethodref(TRANSLET_CLASS,
						  POP_PARAM_FRAME,
						  POP_PARAM_FRAME_SIG);
	    il.append(new INVOKEVIRTUAL(popFrame));
	}
    }
}
"
org.apache.xml.dtm.ref.DTMSafeStringPool,5,2,0,1,15,10,0,1,5,2.0,305,0.0,0,0.5,0.35,2,5,60.0,8,2.2,0,"

package org.apache.xml.dtm.ref;



public class DTMSafeStringPool
extends DTMStringPool
{
  public synchronized void removeAllElements()
    {
      super.removeAllElements();
    }

   
  public synchronized String indexToString(int i)
    throws java.lang.ArrayIndexOutOfBoundsException
    {
      return super.indexToString(i);
    }

   
  public synchronized int stringToIndex(String s)
    {
      return super.stringToIndex(s);
    }

  
  public static void main(String[] args)
  {
    String[] word={
      ""Zero"",""One"",""Two"",""Three"",""Four"",""Five"",
      ""Six"",""Seven"",""Eight"",""Nine"",""Ten"",
      ""Eleven"",""Twelve"",""Thirteen"",""Fourteen"",""Fifteen"",
      ""Sixteen"",""Seventeen"",""Eighteen"",""Nineteen"",""Twenty"",
      ""Twenty-One"",""Twenty-Two"",""Twenty-Three"",""Twenty-Four"",
      ""Twenty-Five"",""Twenty-Six"",""Twenty-Seven"",""Twenty-Eight"",
      ""Twenty-Nine"",""Thirty"",""Thirty-One"",""Thirty-Two"",
      ""Thirty-Three"",""Thirty-Four"",""Thirty-Five"",""Thirty-Six"",
      ""Thirty-Seven"",""Thirty-Eight"",""Thirty-Nine""};

    DTMStringPool pool=new DTMSafeStringPool();

    System.out.println(""If no complaints are printed below, we passed initial test."");

    for(int pass=0;pass<=1;++pass)
      {
        int i;

        for(i=0;i<word.length;++i)
          {
            int j=pool.stringToIndex(word[i]);
            if(j!=i)
              System.out.println(""	Mismatch populating pool: assigned ""+
                                 j+"" for create ""+i);
          }

        for(i=0;i<word.length;++i)
          {
            int j=pool.stringToIndex(word[i]);
            if(j!=i)
              System.out.println(""	Mismatch in stringToIndex: returned ""+
                                 j+"" for lookup ""+i);
          }

        for(i=0;i<word.length;++i)
          {
            String w=pool.indexToString(i);
            if(!word[i].equals(w))
              System.out.println(""	Mismatch in indexToString: returned""+
                                 w+"" for lookup ""+i);
          }
        
        pool.removeAllElements();
        
        System.out.println(""
Pass ""+pass+"" complete
"");
      } 
  }
} 
"
org.apache.xpath.compiler.XPathParser,58,1,0,13,94,0,4,10,5,0.679425837,3321,0.454545455,2,0.0,0.163793103,0,0,56.06896552,6,1.4828,2,"
package org.apache.xpath.compiler;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.XPathProcessorException;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XString;
import org.apache.xpath.res.XPATHErrorResources;


public class XPathParser
{
	
	
	
	static public final String CONTINUE_AFTER_FATAL_ERROR=""CONTINUE_AFTER_FATAL_ERROR"";

  
  private OpMap m_ops;

  
  transient String m_token;

  
  transient char m_tokenChar = 0;

  
  int m_queueMark = 0;

  
  protected final static int FILTER_MATCH_FAILED     = 0;
  protected final static int FILTER_MATCH_PRIMARY    = 1;
  protected final static int FILTER_MATCH_PREDICATES = 2;

  
  public XPathParser(ErrorListener errorListener, javax.xml.transform.SourceLocator sourceLocator)
  {
    m_errorListener = errorListener;
    m_sourceLocator = sourceLocator;
  }

  
  PrefixResolver m_namespaceContext;

  
  public void initXPath(
          Compiler compiler, String expression, PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    m_ops = compiler;
    m_namespaceContext = namespaceContext;

    Lexer lexer = new Lexer(compiler, namespaceContext, this);

    lexer.tokenize(expression);

    m_ops.setOp(0,OpCodes.OP_XPATH);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH,2);
    
    
	
	
	
	
	
	
	
	
	try {

      nextToken();
      Expr();

      if (null != m_token)
      {
        String extraTokens = """";

        while (null != m_token)
        {
          extraTokens += ""'"" + m_token + ""'"";

          nextToken();

          if (null != m_token)
            extraTokens += "", "";
        }

        error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
              new Object[]{ extraTokens });  
      }

    } 
    catch (org.apache.xpath.XPathProcessorException e)
    {
	  if(CONTINUE_AFTER_FATAL_ERROR.equals(e.getMessage()))
	  {
		
		
		
		initXPath(compiler, ""/.."",  namespaceContext);
	  }
	  else
		throw e;
    }

    compiler.shrink();
  }

  
  public void initMatchPattern(
          Compiler compiler, String expression, PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    m_ops = compiler;
    m_namespaceContext = namespaceContext;

    Lexer lexer = new Lexer(compiler, namespaceContext, this);

    lexer.tokenize(expression);

    m_ops.setOp(0, OpCodes.OP_MATCHPATTERN);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH, 2);

    nextToken();
    Pattern();

    if (null != m_token)
    {
      String extraTokens = """";

      while (null != m_token)
      {
        extraTokens += ""'"" + m_token + ""'"";

        nextToken();

        if (null != m_token)
          extraTokens += "", "";
      }

      error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
            new Object[]{ extraTokens });  
    }

    
    m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH)+1);

    m_ops.shrink();
  }

  
  private ErrorListener m_errorListener;
  
  
  javax.xml.transform.SourceLocator m_sourceLocator;

  
  public void setErrorHandler(ErrorListener handler)
  {
    m_errorListener = handler;
  }

  
  public ErrorListener getErrorListener()
  {
    return m_errorListener;
  }

  
  final boolean tokenIs(String s)
  {
    return (m_token != null) ? (m_token.equals(s)) : (s == null);
  }

  
  final boolean tokenIs(char c)
  {
    return (m_token != null) ? (m_tokenChar == c) : false;
  }

  
  final boolean lookahead(char c, int n)
  {

    int pos = (m_queueMark + n);
    boolean b;

    if ((pos <= m_ops.getTokenQueueSize()) && (pos > 0)
            && (m_ops.getTokenQueueSize() != 0))
    {
      String tok = ((String) m_ops.m_tokenQueue.elementAt(pos - 1));

      b = (tok.length() == 1) ? (tok.charAt(0) == c) : false;
    }
    else
    {
      b = false;
    }

    return b;
  }

  
  private final boolean lookbehind(char c, int n)
  {

    boolean isToken;
    int lookBehindPos = m_queueMark - (n + 1);

    if (lookBehindPos >= 0)
    {
      String lookbehind = (String) m_ops.m_tokenQueue.elementAt(lookBehindPos);

      if (lookbehind.length() == 1)
      {
        char c0 = (lookbehind == null) ? '|' : lookbehind.charAt(0);

        isToken = (c0 == '|') ? false : (c0 == c);
      }
      else
      {
        isToken = false;
      }
    }
    else
    {
      isToken = false;
    }

    return isToken;
  }

  
  private final boolean lookbehindHasToken(int n)
  {

    boolean hasToken;

    if ((m_queueMark - n) > 0)
    {
      String lookbehind = (String) m_ops.m_tokenQueue.elementAt(m_queueMark - (n - 1));
      char c0 = (lookbehind == null) ? '|' : lookbehind.charAt(0);

      hasToken = (c0 == '|') ? false : true;
    }
    else
    {
      hasToken = false;
    }

    return hasToken;
  }

  
  private final boolean lookahead(String s, int n)
  {

    boolean isToken;

    if ((m_queueMark + n) <= m_ops.getTokenQueueSize())
    {
      String lookahead = (String) m_ops.m_tokenQueue.elementAt(m_queueMark + (n - 1));

      isToken = (lookahead != null) ? lookahead.equals(s) : (s == null);
    }
    else
    {
      isToken = (null == s);
    }

    return isToken;
  }

  
  private final void nextToken()
  {

    if (m_queueMark < m_ops.getTokenQueueSize())
    {
      m_token = (String) m_ops.m_tokenQueue.elementAt(m_queueMark++);
      m_tokenChar = m_token.charAt(0);
    }
    else
    {
      m_token = null;
      m_tokenChar = 0;
    }
  }

  
  private final String getTokenRelative(int i)
  {

    String tok;
    int relative = m_queueMark + i;

    if ((relative > 0) && (relative < m_ops.getTokenQueueSize()))
    {
      tok = (String) m_ops.m_tokenQueue.elementAt(relative);
    }
    else
    {
      tok = null;
    }

    return tok;
  }

  
  private final void prevToken()
  {

    if (m_queueMark > 0)
    {
      m_queueMark--;

      m_token = (String) m_ops.m_tokenQueue.elementAt(m_queueMark);
      m_tokenChar = m_token.charAt(0);
    }
    else
    {
      m_token = null;
      m_tokenChar = 0;
    }
  }

  
  private final void consumeExpected(String expected)
          throws javax.xml.transform.TransformerException
  {

    if (tokenIs(expected))
    {
      nextToken();
    }
    else
    {
      error(XPATHErrorResources.ER_EXPECTED_BUT_FOUND, new Object[]{ expected,
                                                                     m_token });  

	  
	  
	  
		throw new XPathProcessorException(CONTINUE_AFTER_FATAL_ERROR);
	}
  }

  
  private final void consumeExpected(char expected)
          throws javax.xml.transform.TransformerException
  {

    if (tokenIs(expected))
    {
      nextToken();
    }
    else
    {
      error(XPATHErrorResources.ER_EXPECTED_BUT_FOUND,
            new Object[]{ String.valueOf(expected),
                          m_token });  

	  
	  
	  
		throw new XPathProcessorException(CONTINUE_AFTER_FATAL_ERROR);
    }
  }

  
  void warn(String msg, Object[] args) throws TransformerException
  {

    String fmsg = XSLMessages.createXPATHWarning(msg, args);
    ErrorListener ehandler = this.getErrorListener();

    if (null != ehandler)
    {
      
      ehandler.warning(new TransformerException(fmsg, m_sourceLocator));
    }
    else
    {
      
      System.err.println(fmsg);
    }
  }

  
  private void assertion(boolean b, String msg)
  {

    if (!b)
    {
      String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ msg });

      throw new RuntimeException(fMsg);
    }
  }

  
  void error(String msg, Object[] args) throws TransformerException
  {

    String fmsg = XSLMessages.createXPATHMessage(msg, args);
    ErrorListener ehandler = this.getErrorListener();

    TransformerException te = new TransformerException(fmsg, m_sourceLocator);
    if (null != ehandler)
    {
      
      ehandler.fatalError(te);
    }
    else
    {
      
      throw te;
    }
  }

  
  protected String dumpRemainingTokenQueue()
  {

    int q = m_queueMark;
    String returnMsg;

    if (q < m_ops.getTokenQueueSize())
    {
      String msg = ""
 Remaining tokens: ("";

      while (q < m_ops.getTokenQueueSize())
      {
        String t = (String) m_ops.m_tokenQueue.elementAt(q++);

        msg += ("" '"" + t + ""'"");
      }

      returnMsg = msg + "")"";
    }
    else
    {
      returnMsg = """";
    }

    return returnMsg;
  }

  
  final int getFunctionToken(String key)
  {

    int tok;

    try
    {
      tok = ((Integer) (Keywords.m_functions.get(key))).intValue();
    }
    catch (NullPointerException npe)
    {
      tok = -1;
    }
    catch (ClassCastException cce)
    {
      tok = -1;
    }

    return tok;
  }

  
  void insertOp(int pos, int length, int op)
  {

    int totalLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    for (int i = totalLen - 1; i >= pos; i--)
    {
      m_ops.setOp(i + length, m_ops.getOp(i));
    }

    m_ops.setOp(pos,op);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH,totalLen + length);
  }

  
  void appendOp(int length, int op)
  {

    int totalLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    m_ops.setOp(totalLen, op);
    m_ops.setOp(totalLen + OpMap.MAPINDEX_LENGTH, length);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH, totalLen + length);
  }

  

  
  protected void Expr() throws javax.xml.transform.TransformerException
  {
    OrExpr();
  }

  
  protected void OrExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    AndExpr();

    if ((null != m_token) && tokenIs(""or""))
    {
      nextToken();
      insertOp(opPos, 2, OpCodes.OP_OR);
      OrExpr();

      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
        m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
    }
  }

  
  protected void AndExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    EqualityExpr(-1);

    if ((null != m_token) && tokenIs(""and""))
    {
      nextToken();
      insertOp(opPos, 2, OpCodes.OP_AND);
      AndExpr();

      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
        m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
    }
  }

  
  protected int EqualityExpr(int addPos) throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    if (-1 == addPos)
      addPos = opPos;

    RelationalExpr(-1);

    if (null != m_token)
    {
      if (tokenIs('!') && lookahead('=', 1))
      {
        nextToken();
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_NOTEQUALS);

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = EqualityExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
      else if (tokenIs('='))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_EQUALS);

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = EqualityExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
    }

    return addPos;
  }

  
  protected int RelationalExpr(int addPos) throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    if (-1 == addPos)
      addPos = opPos;

    AdditiveExpr(-1);

    if (null != m_token)
    {
      if (tokenIs('<'))
      {
        nextToken();

        if (tokenIs('='))
        {
          nextToken();
          insertOp(addPos, 2, OpCodes.OP_LTE);
        }
        else
        {
          insertOp(addPos, 2, OpCodes.OP_LT);
        }

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = RelationalExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH, 
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
      else if (tokenIs('>'))
      {
        nextToken();

        if (tokenIs('='))
        {
          nextToken();
          insertOp(addPos, 2, OpCodes.OP_GTE);
        }
        else
        {
          insertOp(addPos, 2, OpCodes.OP_GT);
        }

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = RelationalExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
    }

    return addPos;
  }

  
  protected int AdditiveExpr(int addPos) throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    if (-1 == addPos)
      addPos = opPos;

    MultiplicativeExpr(-1);

    if (null != m_token)
    {
      if (tokenIs('+'))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_PLUS);

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = AdditiveExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
      else if (tokenIs('-'))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_MINUS);

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = AdditiveExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH, 
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
    }

    return addPos;
  }

  
  protected int MultiplicativeExpr(int addPos) throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    if (-1 == addPos)
      addPos = opPos;

    UnaryExpr();

    if (null != m_token)
    {
      if (tokenIs('*'))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_MULT);

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = MultiplicativeExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
      else if (tokenIs(""div""))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_DIV);

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = MultiplicativeExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
      else if (tokenIs(""mod""))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_MOD);

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = MultiplicativeExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
      else if (tokenIs(""quo""))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_QUO);

        int opPlusLeftHandLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - addPos;

        addPos = MultiplicativeExpr(addPos);
        m_ops.setOp(addPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(addPos + opPlusLeftHandLen + 1) + opPlusLeftHandLen);
        addPos += 2;
      }
    }

    return addPos;
  }

  
  protected void UnaryExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
    boolean isNeg = false;

    if (m_tokenChar == '-')
    {
      nextToken();
      appendOp(2, OpCodes.OP_NEG);

      isNeg = true;
    }

    UnionExpr();

    if (isNeg)
      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
        m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
  }

  
  protected void StringExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    appendOp(2, OpCodes.OP_STRING);
    Expr();

    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
  }

  
  protected void BooleanExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    appendOp(2, OpCodes.OP_BOOL);
    Expr();

    int opLen = m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos;

    if (opLen == 2)
    {
      error(XPATHErrorResources.ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL, null);  
    }

    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH, opLen);
  }

  
  protected void NumberExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    appendOp(2, OpCodes.OP_NUMBER);
    Expr();

    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
  }

  
  protected void UnionExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
    boolean continueOrLoop = true;
    boolean foundUnion = false;

    do
    {
      PathExpr();

      if (tokenIs('|'))
      {
        if (false == foundUnion)
        {
          foundUnion = true;

          insertOp(opPos, 2, OpCodes.OP_UNION);
        }

        nextToken();
      }
      else
      {
        break;
      }

      
    }
    while (continueOrLoop);

    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
  }

  
  protected void PathExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    int filterExprMatch = FilterExpr();

    if (filterExprMatch != FILTER_MATCH_FAILED)
    {
      
      
      boolean locationPathStarted = (filterExprMatch==FILTER_MATCH_PREDICATES);

      if (tokenIs('/'))
      {
        nextToken();

        if (!locationPathStarted)
        {
          
          insertOp(opPos, 2, OpCodes.OP_LOCATIONPATH);

          locationPathStarted = true;
        }

        if (!RelativeLocationPath())
        {
          
          error(XPATHErrorResources.ER_EXPECTED_REL_LOC_PATH, null);
        }

      }

      
      if (locationPathStarted)
      {
        m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
        m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
        m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
      }
    }
    else
    {
      LocationPath();
    }
  }

  
  protected int FilterExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    int filterMatch;

    if (PrimaryExpr())
    {
      if (tokenIs('['))
      {

        
        insertOp(opPos, 2, OpCodes.OP_LOCATIONPATH);

        while (tokenIs('['))
        {
          Predicate();
        }

        filterMatch = FILTER_MATCH_PREDICATES;
      }
      else
      {
        filterMatch = FILTER_MATCH_PRIMARY;
      }
    }
    else
    {
      filterMatch = FILTER_MATCH_FAILED;
    }

    return filterMatch;

    
  }

  
  protected boolean PrimaryExpr() throws javax.xml.transform.TransformerException
  {

    boolean matchFound;
    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    if ((m_tokenChar == ''') || (m_tokenChar == '""'))
    {
      appendOp(2, OpCodes.OP_LITERAL);
      Literal();

      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH, 
        m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);

      matchFound = true;
    }
    else if (m_tokenChar == '$')
    {
      nextToken();  
      appendOp(2, OpCodes.OP_VARIABLE);
      QName();
      
      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
        m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);

      matchFound = true;
    }
    else if (m_tokenChar == '(')
    {
      nextToken();
      appendOp(2, OpCodes.OP_GROUP);
      Expr();
      consumeExpected(')');

      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
        m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);

      matchFound = true;
    }
    else if ((null != m_token) && ((('.' == m_tokenChar) && (m_token.length() > 1) && Character.isDigit(
            m_token.charAt(1))) || Character.isDigit(m_tokenChar)))
    {
      appendOp(2, OpCodes.OP_NUMBERLIT);
      Number();

      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
        m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);

      matchFound = true;
    }
    else if (lookahead('(', 1) || (lookahead(':', 1) && lookahead('(', 3)))
    {
      matchFound = FunctionCall();
    }
    else
    {
      matchFound = false;
    }

    return matchFound;
  }

  
  protected void Argument() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    appendOp(2, OpCodes.OP_ARGUMENT);
    Expr();

    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
  }

  
  protected boolean FunctionCall() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    if (lookahead(':', 1))
    {
      appendOp(4, OpCodes.OP_EXTFUNCTION);

      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1, m_queueMark - 1);

      nextToken();
      consumeExpected(':');

      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 2, m_queueMark - 1);

      nextToken();
    }
    else
    {
      int funcTok = getFunctionToken(m_token);

      if (-1 == funcTok)
      {
        error(XPATHErrorResources.ER_COULDNOT_FIND_FUNCTION,
              new Object[]{ m_token });  
      }

      switch (funcTok)
      {
      case OpCodes.NODETYPE_PI :
      case OpCodes.NODETYPE_COMMENT :
      case OpCodes.NODETYPE_TEXT :
      case OpCodes.NODETYPE_NODE :
        
        return false;
      default :
        appendOp(3, OpCodes.OP_FUNCTION);

        m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1, funcTok);
      }

      nextToken();
    }

    consumeExpected('(');

    while (!tokenIs(')') && m_token != null)
    {
      if (tokenIs(','))
      {
        error(XPATHErrorResources.ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG, null);  
      }

      Argument();

      if (!tokenIs(')'))
      {
        consumeExpected(',');

        if (tokenIs(')'))
        {
          error(XPATHErrorResources.ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
                null);  
        }
      }
    }

    consumeExpected(')');

    
    m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH,m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH, 
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);

    return true;
  }

  

  
  protected void LocationPath() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    
    appendOp(2, OpCodes.OP_LOCATIONPATH);

    boolean seenSlash = tokenIs('/');

    if (seenSlash)
    {
      appendOp(4, OpCodes.FROM_ROOT);

      
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2, 4);
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_ROOT);

      nextToken();
    }

    if (m_token != null)
    {
      if (!RelativeLocationPath() && !seenSlash)
      {
        
        
        error(XPATHErrorResources.ER_EXPECTED_LOC_PATH, 
              new Object [] {m_token});
      }
    }

    
    m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH,m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
  }

  
  protected boolean RelativeLocationPath()
               throws javax.xml.transform.TransformerException
  {
    if (!Step())
    {
      return false;
    }

    while (tokenIs('/'))
    {
      nextToken();

      if (!Step())
      {
        
        
        error(XPATHErrorResources.ER_EXPECTED_LOC_STEP, null);
      }
    }

    return true;
  }

  
  protected boolean Step() throws javax.xml.transform.TransformerException
  {
    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    boolean doubleSlash = tokenIs('/');

    
    
    
    if (doubleSlash)
    {
      nextToken();

      appendOp(2, OpCodes.FROM_DESCENDANTS_OR_SELF);

      
      
      
      

      
      m_ops.setOp(OpMap.MAPINDEX_LENGTH,m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.NODETYPE_NODE);
      m_ops.setOp(OpMap.MAPINDEX_LENGTH,m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

      
      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1,
          m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);

      
      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
          m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);

      opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
    }

    if (tokenIs("".""))
    {
      nextToken();

      if (tokenIs('['))
      {
        error(XPATHErrorResources.ER_PREDICATE_ILLEGAL_SYNTAX, null);  
      }

      appendOp(4, OpCodes.FROM_SELF);

      
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2,4);
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_NODE);
    }
    else if (tokenIs(""..""))
    {
      nextToken();
      appendOp(4, OpCodes.FROM_PARENT);

      
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2,4);
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_NODE);
    }

    
    
    
    else if (tokenIs('*') || tokenIs('@') || tokenIs('_')
             || (m_token!= null && Character.isLetter(m_token.charAt(0))))
    {
      Basis();

      while (tokenIs('['))
      {
        Predicate();
      }

      
      m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
        m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos); 
    }
    else
    {
      
      if (doubleSlash)
      {
        
        error(XPATHErrorResources.ER_EXPECTED_LOC_STEP, null);
      }

      return false;
    }

    return true;
  }

  
  protected void Basis() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
    int axesType;

    
    if (lookahead(""::"", 1))
    {
      axesType = AxisName();

      nextToken();
      nextToken();
    }
    else if (tokenIs('@'))
    {
      axesType = OpCodes.FROM_ATTRIBUTES;

      appendOp(2, axesType);
      nextToken();
    }
    else
    {
      axesType = OpCodes.FROM_CHILDREN;

      appendOp(2, axesType);
    }

    
    m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

    NodeTest(axesType);

    
    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1,
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
   }

  
  protected int AxisName() throws javax.xml.transform.TransformerException
  {

    Object val = Keywords.m_axisnames.get(m_token);

    if (null == val)
    {
      error(XPATHErrorResources.ER_ILLEGAL_AXIS_NAME,
            new Object[]{ m_token });  
    }

    int axesType = ((Integer) val).intValue();

    appendOp(2, axesType);

    return axesType;
  }

  
  protected void NodeTest(int axesType) throws javax.xml.transform.TransformerException
  {

    if (lookahead('(', 1))
    {
      Object nodeTestOp = Keywords.m_nodetypes.get(m_token);

      if (null == nodeTestOp)
      {
        error(XPATHErrorResources.ER_UNKNOWN_NODETYPE,
              new Object[]{ m_token });  
      }
      else
      {
        nextToken();

        int nt = ((Integer) nodeTestOp).intValue();

        m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), nt);
        m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

        consumeExpected('(');

        if (OpCodes.NODETYPE_PI == nt)
        {
          if (!tokenIs(')'))
          {
            Literal();
          }
        }

        consumeExpected(')');
      }
    }
    else
    {

      
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.NODENAME);
      m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

      if (lookahead(':', 1))
      {
        if (tokenIs('*'))
        {
          m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ELEMWILDCARD);
        }
        else
        {
          m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);

          
          
          if (!Character.isLetter(m_tokenChar) && !tokenIs('_'))
          {
            
            error(XPATHErrorResources.ER_EXPECTED_NODE_TEST, null);
          }
        }

        nextToken();
        consumeExpected(':');
      }
      else
      {
        m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.EMPTY);
      }

      m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

      if (tokenIs('*'))
      {
        m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ELEMWILDCARD);
      }
      else
      {
        if (OpCodes.FROM_NAMESPACE == axesType)
        {
          String prefix = (String) this.m_ops.m_tokenQueue.elementAt(m_queueMark - 1);
          String namespace =
            ((PrefixResolver) m_namespaceContext).getNamespaceForPrefix(
              prefix);

          this.m_ops.m_tokenQueue.setElementAt(namespace,m_queueMark - 1);
        }

        m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);

        
        
        if (!Character.isLetter(m_tokenChar) && !tokenIs('_'))
        {
          
          error(XPATHErrorResources.ER_EXPECTED_NODE_TEST, null);
        }
      }

      m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

      nextToken();
    }
  }

  
  protected void Predicate() throws javax.xml.transform.TransformerException
  {

    if (tokenIs('['))
    {
      nextToken();
      PredicateExpr();
      consumeExpected(']');
    }
  }

  
  protected void PredicateExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    appendOp(2, OpCodes.OP_PREDICATE);
    Expr();

    
    m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
  }

  
  protected void QName() throws javax.xml.transform.TransformerException
  {
    
    if(lookahead(':', 1))
    {
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
      m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

      nextToken();
      consumeExpected(':');
    }
    else
    {
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.EMPTY);
      m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
    }
    
    
    m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

    nextToken();
  }

  
  protected void NCName()
  {

    m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

    nextToken();
  }

  
  protected void Literal() throws javax.xml.transform.TransformerException
  {

    int last = m_token.length() - 1;
    char c0 = m_tokenChar;
    char cX = m_token.charAt(last);

    if (((c0 == '""') && (cX == '""')) || ((c0 == ''') && (cX == ''')))
    {

      
      
      int tokenQueuePos = m_queueMark - 1;

      m_ops.m_tokenQueue.setElementAt(null,tokenQueuePos);

      Object obj = new XString(m_token.substring(1, last));

      m_ops.m_tokenQueue.setElementAt(obj,tokenQueuePos);

      
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), tokenQueuePos);
      m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

      nextToken();
    }
    else
    {
      error(XPATHErrorResources.ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
            new Object[]{ m_token });  
    }
  }

  
  protected void Number() throws javax.xml.transform.TransformerException
  {

    if (null != m_token)
    {

      
      
      double num;

      try
      {
        num = Double.valueOf(m_token).doubleValue();
      }
      catch (NumberFormatException nfe)
      {
        num = 0.0;  

        error(XPATHErrorResources.ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
              new Object[]{ m_token });  
      }

      m_ops.m_tokenQueue.setElementAt(new XNumber(num),m_queueMark - 1);
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), m_queueMark - 1);
      m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

      nextToken();
    }
  }

  

  
  protected void Pattern() throws javax.xml.transform.TransformerException
  {

    while (true)
    {
      LocationPathPattern();

      if (tokenIs('|'))
      {
        nextToken();
      }
      else
      {
        break;
      }
    }
  }

  
  protected void LocationPathPattern() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);

    final int RELATIVE_PATH_NOT_PERMITTED = 0;
    final int RELATIVE_PATH_PERMITTED     = 1;
    final int RELATIVE_PATH_REQUIRED      = 2;

    int relativePathStatus = RELATIVE_PATH_NOT_PERMITTED;

    appendOp(2, OpCodes.OP_LOCATIONPATHPATTERN);

    if (lookahead('(', 1)
            && (tokenIs(Keywords.FUNC_ID_STRING)
                || tokenIs(Keywords.FUNC_KEY_STRING)))
    {
      IdKeyPattern();

      if (tokenIs('/'))
      {
        nextToken();

        if (tokenIs('/'))
        {
          appendOp(4, OpCodes.MATCH_ANY_ANCESTOR);

          nextToken();
        }
        else
        {
          appendOp(4, OpCodes.MATCH_IMMEDIATE_ANCESTOR);
        }

        
        m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2, 4);
        m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_FUNCTEST);

        relativePathStatus = RELATIVE_PATH_REQUIRED;
      }
    }
    else if (tokenIs('/'))
    {
      if (lookahead('/', 1))
      {
        appendOp(4, OpCodes.MATCH_ANY_ANCESTOR);
        
        
        
        
        
        nextToken();

        relativePathStatus = RELATIVE_PATH_REQUIRED;
      }
      else
      {
        appendOp(4, OpCodes.FROM_ROOT);

        relativePathStatus = RELATIVE_PATH_PERMITTED;
      }


      
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 2, 4);
      m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH) - 1, OpCodes.NODETYPE_ROOT);

      nextToken();
    }
    else
    {
      relativePathStatus = RELATIVE_PATH_REQUIRED;
    }

    if (relativePathStatus != RELATIVE_PATH_NOT_PERMITTED)
    {
      if (!tokenIs('|') && (null != m_token))
      {
        RelativePathPattern();
      }
      else if (relativePathStatus == RELATIVE_PATH_REQUIRED)
      {
        
        error(XPATHErrorResources.ER_EXPECTED_REL_PATH_PATTERN, null);
      }
    }

    
    m_ops.setOp(m_ops.getOp(OpMap.MAPINDEX_LENGTH), OpCodes.ENDOP);
    m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);
    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);
  }

  
  protected void IdKeyPattern() throws javax.xml.transform.TransformerException
  {
    FunctionCall();
  }

  
  protected void RelativePathPattern()
              throws javax.xml.transform.TransformerException
  {

    
    
    boolean trailingSlashConsumed = StepPattern(false);

    while (tokenIs('/'))
    {
      nextToken();

      
      
      
      trailingSlashConsumed = StepPattern(!trailingSlashConsumed);
    }
  }

  
  protected boolean StepPattern(boolean isLeadingSlashPermitted)
            throws javax.xml.transform.TransformerException
  {
    return AbbreviatedNodeTestStep(isLeadingSlashPermitted);
  }

  
  protected boolean AbbreviatedNodeTestStep(boolean isLeadingSlashPermitted)
            throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
    int axesType;

    
    int matchTypePos = -1;

    if (tokenIs('@'))
    {
      axesType = OpCodes.MATCH_ATTRIBUTE;

      appendOp(2, axesType);
      nextToken();
    }
    else if (this.lookahead(""::"", 1))
    {
      if (tokenIs(""attribute""))
      {
        axesType = OpCodes.MATCH_ATTRIBUTE;

        appendOp(2, axesType);
      }
      else if (tokenIs(""child""))
      {
        matchTypePos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
        axesType = OpCodes.MATCH_IMMEDIATE_ANCESTOR;

        appendOp(2, axesType);
      }
      else
      {
        axesType = -1;

        this.error(XPATHErrorResources.ER_AXES_NOT_ALLOWED,
                   new Object[]{ this.m_token });
      }

      nextToken();
      nextToken();
    }
    else if (tokenIs('/'))
    {
      if (!isLeadingSlashPermitted)
      {
        
        error(XPATHErrorResources.ER_EXPECTED_STEP_PATTERN, null);
      }
      axesType = OpCodes.MATCH_ANY_ANCESTOR;

      appendOp(2, axesType);
      nextToken();
    }
    else
    {
      matchTypePos = m_ops.getOp(OpMap.MAPINDEX_LENGTH);
      axesType = OpCodes.MATCH_IMMEDIATE_ANCESTOR;

      appendOp(2, axesType);
    }

    
    m_ops.setOp(OpMap.MAPINDEX_LENGTH, m_ops.getOp(OpMap.MAPINDEX_LENGTH) + 1);

    NodeTest(axesType);

    
    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH + 1,
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);

    while (tokenIs('['))
    {
      Predicate();
    }

    boolean trailingSlashConsumed;

    
    
    
    
    
    
    
    
    
    
    
    
    if ((matchTypePos > -1) && tokenIs('/') && lookahead('/', 1))
    {
      m_ops.setOp(matchTypePos, OpCodes.MATCH_ANY_ANCESTOR);

      nextToken();

      trailingSlashConsumed = true;
    }
    else
    {
      trailingSlashConsumed = false;
    }

    
    m_ops.setOp(opPos + OpMap.MAPINDEX_LENGTH,
      m_ops.getOp(OpMap.MAPINDEX_LENGTH) - opPos);

    return trailingSlashConsumed;
  }
}
"
org.apache.xml.res.XMLErrorResources_fr,3,4,0,1,4,1,0,1,2,1.3,875,0.0,0,0.976190476,1.0,0,0,289.0,1,0.3333,0,"
package org.apache.xml.res;


public class XMLErrorResources_fr extends XMLErrorResources
{

  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },

  
  

  {
    ER_FUNCTION_NOT_SUPPORTED, ""Fonction non prise en charge !""},
  
  
  

  {
    ER_CANNOT_OVERWRITE_CAUSE,
			""Impossible d’écraser la cause""},
  
   
  

  {
    ER_NO_DEFAULT_IMPL,
         ""Aucune mise en œuvre par défaut trouvée""},
  
   
  

  {
    ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
       ""ChunkedIntArray({0}) non pris en charge pour le moment""},
  
   
  

  {
    ER_OFFSET_BIGGER_THAN_SLOT,
       ""Impression plus importante que l’emplacement""},
  
   
  

  {
    ER_COROUTINE_NOT_AVAIL,
       ""Coroutine indisponible, id={0}""},
  
   
  

  {
    ER_COROUTINE_CO_EXIT,
       ""CoroutineManager a reçu une requête co_exit()""},
  
   
  

  {
    ER_COJOINROUTINESET_FAILED,
       ""Echec de co_joinCoroutineSet()""},
  
   
  

  {
    ER_COROUTINE_PARAM,
       ""Erreur de paramètre Coroutine ({0})""},
  
   
  

  {
    ER_PARSER_DOTERMINATE_ANSWERS,
       ""
UNEXPECTED: Réponses de Parser doTerminate {0}""},
  
   
  

  {
    ER_NO_PARSE_CALL_WHILE_PARSING,
       ""parse ne peut pas être appelé pendant l’opération d’analyse""},
  
   
  

  {
    ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""Erreur : l’itérateur saisi pour l’axe {0} n’est pas mis en oeuvre""},
  
   
  

  {
    ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""Erreur : l’itérateur pour l’axe {0} n’est pas mis en oeuvre ""},
  
   
  

  {
    ER_ITERATOR_CLONE_NOT_SUPPORTED,
       ""Clone d’itérateur non pris en charge""},
  
   
  

  {
    ER_UNKNOWN_AXIS_TYPE,
       ""Type d’axe transversal inconnu : {0}""},
  
   
  

  {
    ER_AXIS_NOT_SUPPORTED,
       ""Axe transversal non pris en charge : {0}""},
  
   
  

  {
    ER_NO_DTMIDS_AVAIL,
       ""Aucun ID DTM disponible""},
  
   
  

  {
    ER_NOT_SUPPORTED,
       ""Non pris en charge : {0}""},
  
   
  

  {
    ER_NODE_NON_NULL,
       ""Le nœud ne doit pas être vide pour getDTMHandleFromNode""},
  
   
  

  {
    ER_COULD_NOT_RESOLVE_NODE,
       ""Impossible de résoudre le noeud en descripteur""},
  
   
  

  {
    ER_STARTPARSE_WHILE_PARSING,
       ""startParse ne peut pas être appelé pendant l’analyse""},
  
   
  

  {
    ER_STARTPARSE_NEEDS_SAXPARSER,
       ""startParse requiert un SAXParser non vide""},
  
   
  

  {
    ER_COULD_NOT_INIT_PARSER,
       ""Impossible d’initialiser l’analyseur avec""},
  
   
  

  {
    ER_EXCEPTION_CREATING_POOL,
       ""Exception de création d’une nouvelle instance pour le pool""},
  
   
  

  {
    ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
       ""Le chemin contient une séquence de remplacement incorrecte""},
  
   
  

  {
    ER_SCHEME_REQUIRED,
       ""Le modèle est requis !""},
  
   
  

  {
    ER_NO_SCHEME_IN_URI,
       ""Aucun modèle trouvé dans l’URI : {0}""},
  
   
  

  {
    ER_NO_SCHEME_INURI,
       ""Aucun modèle trouvé dans l’URI""},
  
   
  

  {
    ER_PATH_INVALID_CHAR,
       ""Le chemin contient des caractères incorrects : {0}""},
  
   
  

  {
    ER_SCHEME_FROM_NULL_STRING,
       ""Impossible de définir le modèle à partir d’une chaîne vide""},
  
   
  

  {
    ER_SCHEME_NOT_CONFORMANT,
       ""Le modèle n’est pas conforme.""},
  
   
  

  {
    ER_HOST_ADDRESS_NOT_WELLFORMED,
       ""L’hôte n’est pas constitué d’une adresse bien formée""},
  
   
  

  {
    ER_PORT_WHEN_HOST_NULL,
       ""Le port ne peut pas être défini lorsque l’hôte est vide""},
  
   
  

  {
    ER_INVALID_PORT,
       ""Numéro de port incorrect""},
  
   
  

  {
    ER_FRAG_FOR_GENERIC_URI,
       ""Le fragment ne peut être défini que pour un URI générique""},
  
   
  

  {
    ER_FRAG_WHEN_PATH_NULL,
       ""Le fragment ne peut pas être défini lorsque le chemin est vide""},
  
   
  

  {
    ER_FRAG_INVALID_CHAR,
       ""Le fragment contient des caractères incorrects""},
  
 
  
   
  

  {
    ER_PARSER_IN_USE,
        ""L’analyseur est déjà en cours d’utilisation""},
  
   
  

  {
    ER_CANNOT_CHANGE_WHILE_PARSING,
        ""Impossible de modifier {0} {1} pendant la phase d’analyse""},
  
   
  

  {
    ER_SELF_CAUSATION_NOT_PERMITTED,
        ""Lien de causalité vers soi impossible""},
  
   
  

  {
    ER_NO_USERINFO_IF_NO_HOST,
        ""Les informations sur l'utilisateur ne peuvent pas être spécifiées si l’hôte n’est pas spécifié""},
  
   
  

  {
    ER_NO_PORT_IF_NO_HOST,
        ""Le port ne peut pas être spécifié si l’hôte n’est pas spécifié""},
  
   
  

  {
    ER_NO_QUERY_STRING_IN_PATH,
        ""La chaîne de requête ne peut pas être spécifiée dans le chemin et dans la chaîne de requête""},
  
   
  

  {
    ER_NO_FRAGMENT_STRING_IN_PATH,
        ""Le fragment ne peut pas être spécifié dans le chemin et dans le fragment""},
  
   
  

  {
    ER_CANNOT_INIT_URI_EMPTY_PARMS,
        ""Impossible d’initialiser l’URI avec des paramètres vides""},
  
  
  

  {
    ER_METHOD_NOT_SUPPORTED,
        ""Méthode non prise en charge pour le moment""},

  
  

  {
    ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
     ""IncrementalSAXSource_Filter ne peut pas être relancé pour le moment""},
  
  
  

  {
    ER_XMLRDR_NOT_BEFORE_STARTPARSE,
     ""XMLReader pas avant la requête startParse""},

  
  
  {
    ER_AXIS_TRAVERSER_NOT_SUPPORTED,
     ""La coupure d'axe n'est pas prise en charge : {0}""},

  
  
  {
    ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
     ""ListingErrorHandler a été créé avec PrintWriter nul !""},

  
  {
    ER_SYSTEMID_UNKNOWN,
     ""SystemId inconnu""},

  
  
  {
    ER_LOCATION_UNKNOWN,
     ""Emplacement de l'erreur inconnu""},

  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""Le préfixe doit se résoudre en nom d''espace : {0}""},

  
  


  {
    ER_CREATEDOCUMENT_NOT_SUPPORTED,
      ""createDocument() non pris en charge dans XpathContext !""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT,
      ""L’attribut child n’a pas de document propriétaire !""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
      ""L’attribute child n’a pas d’élément de document propriétaire !""},

  
  


  {
    ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
      ""Attention : impossible de sortir le texte avant l’élément document !  Opération ignorée ...""},


  
  


  {
    ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
      ""Impossible d’avoir plus d’une racine sur un DOM !""},

  
   
  


  {
    ER_ARG_LOCALNAME_NULL,
       ""L’argument 'localName' est égal à null""},

  
  
  

  
  


  {
    ER_ARG_LOCALNAME_INVALID,
       ""Le nom local de QNAME doit être un NCName admis""},

  
  
  
  

  
  


  {
    ER_ARG_PREFIX_INVALID,
       ""Le préfixe de QNAME doit être un NCName admis""},

  { ""BAD_CODE"",
      ""Paramètre pour createMessage hors limites""},
  { ""FORMAT_FAILED"",
      ""Exception émise pendant l’appel de messageFormat ""},
  { ""line"", ""N° de ligne""},
  { ""column"", ""N° de colonne""}
  
  };
  
  
  public Object[][] getContents()
  {
    return contents;
  }
}"
org.apache.xalan.xsltc.compiler.LogicalExpr,10,3,0,18,41,0,0,18,9,0.62962963,362,0.666666667,2,0.898734177,0.26984127,2,9,34.6,8,2.4,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class LogicalExpr extends Expression {

    public static final int OR  = 0;
    public static final int AND = 1;
	
    private final int  _op;     
    private Expression _left;   
    private Expression _right;  

    private static final String[] Ops = { ""or"", ""and"" };

    
    public LogicalExpr(int op, Expression left, Expression right) {
	_op = op;
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    
    public boolean hasPositionCall() {
	return (_left.hasPositionCall() || _right.hasPositionCall());
    }

    
    public Object evaluateAtCompileTime() {
	final Object leftb = _left.evaluateAtCompileTime();
	final Object rightb = _right.evaluateAtCompileTime();

	
	if (leftb == null || rightb == null) {
	    return null;
	}

	if (_op == AND) {
	    return (leftb == Boolean.TRUE && rightb == Boolean.TRUE) ?
		Boolean.TRUE : Boolean.FALSE;
	}
	else {
	    return (leftb == Boolean.TRUE || rightb == Boolean.TRUE) ?
		Boolean.TRUE : Boolean.FALSE;
	}
    }

    
    public int getOp() {
	return(_op);
    }

    
    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }

    
    public String toString() {
	return Ops[_op] + '(' + _left + "", "" + _right + ')';
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	Type tleft = _left.typeCheck(stable); 
	Type tright = _right.typeCheck(stable);

	
	MethodType wantType = new MethodType(Type.Void, tleft, tright);
	MethodType haveType = lookupPrimop(stable, Ops[_op], wantType);

	
	if (haveType != null) {
	    
	    Type arg1 = (Type)haveType.argsType().elementAt(0);
	    if (!arg1.identicalTo(tleft))
		_left = new CastExpr(_left, arg1);
	    
	    Type arg2 = (Type) haveType.argsType().elementAt(1);
	    if (!arg2.identicalTo(tright))
		_right = new CastExpr(_right, arg1);
	    
	    return _type = haveType.resultType();
	}
	throw new TypeCheckError(this);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	translateDesynthesized(classGen, methodGen);
	synthesize(classGen, methodGen);
    }

    
    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {

	final InstructionList il = methodGen.getInstructionList();
	final SyntaxTreeNode parent = getParent();

	
	if (_op == AND) {

	    
	    _left.translateDesynthesized(classGen, methodGen);

	    
	    InstructionHandle middle = il.append(NOP);

	    
	    _right.translateDesynthesized(classGen, methodGen);

	    
	    InstructionHandle after = il.append(NOP);

	    
	    _falseList.append(_right._falseList.append(_left._falseList));

	    
	    
	    if ((_left instanceof LogicalExpr) &&
		(((LogicalExpr)_left).getOp() == OR)) {
		_left.backPatchTrueList(middle);
	    }
	    else if (_left instanceof NotCall) {
		_left.backPatchTrueList(middle);
	    }
	    else {
		_trueList.append(_left._trueList);
	    }

	    
	    
	    if ((_right instanceof LogicalExpr) &&
		(((LogicalExpr)_right).getOp() == OR)) {
		_right.backPatchTrueList(after);
	    }
	    else if (_right instanceof NotCall) {
		_right.backPatchTrueList(after);
	    }
	    else {
		_trueList.append(_right._trueList);
	    }
	} 
	
	else {
	    
	    _left.translateDesynthesized(classGen, methodGen);

	    
	    
	    InstructionHandle ih = il.append(new GOTO(null));

	    
	    _right.translateDesynthesized(classGen, methodGen);

	    _left._trueList.backPatch(ih);
	    _left._falseList.backPatch(ih.getNext());
			
	    _falseList.append(_right._falseList);
	    _trueList.add(ih).append(_right._trueList);
	}
    }
}
"
org.apache.xpath.functions.FunctionOneArg,11,3,15,22,20,0,15,7,10,0.3,113,0.0,1,0.791666667,0.345454545,2,4,9.181818182,6,1.5455,1,"
package org.apache.xpath.functions;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;


public class FunctionOneArg extends Function implements ExpressionOwner
{

  
  Expression m_arg0;

  
  public Expression getArg0()
  {
    return m_arg0;
  }
  
  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {

    if (0 == argNum)
    {
      m_arg0 = arg;
      arg.exprSetParent(this);
    }
    else
      reportWrongNumberArgs();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum != 1)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""one"", null));
  }
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return m_arg0.canTraverseOutsideSubtree();
   }
   
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    if(null != m_arg0)
      m_arg0.fixupVariables(vars, globalsSize);
  }
  
  
  public void callArgVisitors(XPathVisitor visitor)
  {
  	if(null != m_arg0)
  		m_arg0.callVisitors(this, visitor);
  }


  
  public Expression getExpression()
  {
    return m_arg0;
  }

  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_arg0 = exp;
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(null != m_arg0)
  	{
  		if(null == ((FunctionOneArg)expr).m_arg0)
  			return false;
  			
  		if(!m_arg0.deepEquals(((FunctionOneArg)expr).m_arg0))
  			return false;
  	}
  	else if(null != ((FunctionOneArg)expr).m_arg0)
  		return false;

  	return true;
  }


}
"
org.apache.xalan.processor.ProcessorPreserveSpace,2,4,1,9,14,1,2,7,1,2.0,50,0.0,0,0.995260664,0.625,2,2,24.0,1,0.5,0,"
package org.apache.xalan.processor;

import java.util.Vector;

import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.WhiteSpaceInfo;
import org.apache.xpath.XPath;

import org.xml.sax.Attributes;


class ProcessorPreserveSpace extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, 
          Attributes attributes)
            throws org.xml.sax.SAXException
  {
    Stylesheet thisSheet = handler.getStylesheet();
	WhitespaceInfoPaths paths = new WhitespaceInfoPaths(thisSheet);
    setPropertiesFromAttributes(handler, rawName, attributes, paths);

    Vector xpaths = paths.getElements();

    for (int i = 0; i < xpaths.size(); i++)
    {
      WhiteSpaceInfo wsi = new WhiteSpaceInfo((XPath) xpaths.elementAt(i), false, thisSheet);
      wsi.setUid(handler.nextUid());

      thisSheet.setPreserveSpaces(wsi);
    }
    paths.clearElements();
  }
}
"
org.apache.xpath.operations.Plus,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class Plus extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() + right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (m_right.num(xctxt) + m_left.num(xctxt));
  }

}
"
org.apache.xml.utils.XMLStringDefault,38,1,0,4,68,0,3,1,38,0.081081081,267,1.0,0,0.0,0.192105263,1,1,6.0,2,1.0,0,"
package org.apache.xml.utils;

import java.util.Locale;


public class XMLStringDefault implements XMLString
{

  private String m_str;
  
  
  public XMLStringDefault(String str)
  {
    m_str = str;
  }
  
  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
    throws org.xml.sax.SAXException
  {
  }

  
  public void dispatchAsComment(org.xml.sax.ext.LexicalHandler lh)
    throws org.xml.sax.SAXException
  {
  }
    
  
  public XMLString fixWhiteSpace(boolean trimHead,
                                 boolean trimTail,
                                 boolean doublePunctuationSpaces)
  {
    return new XMLStringDefault(m_str.trim());
  }

  
  public int length()
  {
    return m_str.length();
  }

  
  public char charAt(int index)
  {
    return m_str.charAt(index);
  }

  
  public void getChars(int srcBegin, int srcEnd, char dst[],
                                int dstBegin)
  {
    int destIndex = dstBegin;
    for (int i = srcBegin; i < srcEnd; i++)
    {
      dst[destIndex++] = m_str.charAt(i);
    }
  }
                                
  
  public boolean equals(XMLString anObject)
  {
    return m_str.equals(anObject.toString());
  }


  
  public boolean equals(Object anObject)
  {
    return m_str.equals(anObject);
  }

  
  public boolean equalsIgnoreCase(String anotherString)
  {
    return m_str.equalsIgnoreCase(anotherString);
  }

  
  public int compareTo(XMLString anotherString)
  {
    return m_str.compareTo(anotherString.toString());
  }

  
  public int compareToIgnoreCase(XMLString str)
  {
    return m_str.compareToIgnoreCase(str.toString());
  }

  
  public boolean startsWith(String prefix, int toffset)
  {
    return m_str.startsWith(prefix, toffset);
  }

  
  public boolean startsWith(XMLString prefix, int toffset)
  {
    return m_str.startsWith(prefix.toString(), toffset);
  }

  
  public boolean startsWith(String prefix)
  {
    return m_str.startsWith(prefix);
  }

  
  public boolean startsWith(XMLString prefix)
  {
    return m_str.startsWith(prefix.toString());
  }

  
  public boolean endsWith(String suffix)
  {
    return m_str.endsWith(suffix);
  }

  
  public int hashCode()
  {
    return m_str.hashCode();
  }

  
  public int indexOf(int ch)
  {
    return m_str.indexOf(ch);
  }

  
  public int indexOf(int ch, int fromIndex)
  {
    return m_str.indexOf(ch, fromIndex);
  }

  
  public int lastIndexOf(int ch)
  {
    return m_str.lastIndexOf(ch);
  }

  
  public int lastIndexOf(int ch, int fromIndex)
  {
    return m_str.lastIndexOf(ch, fromIndex);
  }

  
  public int indexOf(String str)
  {
    return m_str.indexOf(str);
  }

  
  public int indexOf(XMLString str)
  {
    return m_str.indexOf(str.toString());
  }

  
  public int indexOf(String str, int fromIndex)
  {
    return m_str.indexOf(str, fromIndex);
  }

  
  public int lastIndexOf(String str)
  {
    return m_str.lastIndexOf(str);
  }

  
  public int lastIndexOf(String str, int fromIndex)
  {
    return m_str.lastIndexOf(str, fromIndex);
  }

  
  public XMLString substring(int beginIndex)
  {
    return new XMLStringDefault(m_str.substring(beginIndex));
  }

  
  public XMLString substring(int beginIndex, int endIndex)
  {
    return new XMLStringDefault(m_str.substring(beginIndex, endIndex));
  }

  
  public XMLString concat(String str)
  {
    return new XMLStringDefault(m_str.concat(str));
  }

  
  public XMLString toLowerCase(Locale locale)
  {
    return new XMLStringDefault(m_str.toLowerCase(locale));
  }

  
  public XMLString toLowerCase()
  {
    return new XMLStringDefault(m_str.toLowerCase());
  }

  
  public XMLString toUpperCase(Locale locale)
  {
    return new XMLStringDefault(m_str.toUpperCase(locale));
  }

  
  public XMLString toUpperCase()
  {
    return new XMLStringDefault(m_str.toUpperCase());
  }

  
  public XMLString trim()
  {
    return new XMLStringDefault(m_str.trim());
  }

  
  public String toString()
  {
    return m_str;
  }
  
  
  public boolean hasString()
  {
    return true;
  }
  
  
  public double toDouble()
  {
    try {
      return Double.valueOf(m_str).doubleValue();
    }
    catch (NumberFormatException nfe)
    {
      return Double.NaN;
    }
  }
}
"
org.apache.xalan.transformer.TreeWalker2Result,4,2,0,7,24,0,1,6,2,0.444444444,146,0.0,2,0.727272727,0.5625,1,4,34.75,1,0.75,1,"
package org.apache.xalan.transformer;

import org.apache.xalan.serialize.SerializerUtils;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.ref.DTMTreeWalker;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xpath.XPathContext;


public class TreeWalker2Result extends DTMTreeWalker
{

  
  TransformerImpl m_transformer;

  
  SerializationHandler m_handler;

  
  int m_startNode;

  
  public TreeWalker2Result(TransformerImpl transformer,
                           SerializationHandler handler)
  {

    super(handler, null);

    m_transformer = transformer;
    m_handler = handler;
  }

  
  public void traverse(int pos) throws org.xml.sax.SAXException
  {
    m_dtm = m_transformer.getXPathContext().getDTM(pos);
    m_startNode = pos;

    super.traverse(pos);
  }
        
        
  protected void endNode(int node) throws org.xml.sax.SAXException
  {
    super.endNode(node);
    if(DTM.ELEMENT_NODE == m_dtm.getNodeType(node))
    {
      m_transformer.getXPathContext().popCurrentNode();
    }
  }

  
  protected void startNode(int node) throws org.xml.sax.SAXException
  {

    XPathContext xcntxt = m_transformer.getXPathContext();
    try
    {
      
      if (DTM.ELEMENT_NODE == m_dtm.getNodeType(node))
      {
        xcntxt.pushCurrentNode(node);                   
                                        
        if(m_startNode != node)
        {
          super.startNode(node);
        }
        else
        {
          String elemName = m_dtm.getNodeName(node);
          String localName = m_dtm.getLocalName(node);
          String namespace = m_dtm.getNamespaceURI(node);
                                        
          
          
          m_handler.startElement(namespace, localName, elemName);
          boolean hasNSDecls = false;
          DTM dtm = m_dtm;
          for (int ns = dtm.getFirstNamespaceNode(node, true); 
               DTM.NULL != ns; ns = dtm.getNextNamespaceNode(node, ns, true))
          {
            SerializerUtils.ensureNamespaceDeclDeclared(m_handler,dtm, ns);
          }
                                                
                                                
          for (int attr = dtm.getFirstAttribute(node); 
               DTM.NULL != attr; attr = dtm.getNextAttribute(attr))
          {
            SerializerUtils.addAttribute(m_handler, attr);
          }
        }
                                
      }
      else
      {
        xcntxt.pushCurrentNode(node);
        super.startNode(node);
        xcntxt.popCurrentNode();
      }
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }
}
"
org.apache.xalan.xsltc.compiler.IntExpr,4,3,0,11,14,0,0,11,4,0.333333333,44,1.0,0,0.959459459,0.4,2,7,9.75,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class IntExpr extends Expression {
    private final int _value;

    public IntExpr(int value) {
        _value = value;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _type = Type.Int;
    }

    public String toString() {
	return ""int-expr("" + _value + ')';
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }
}
"
org.apache.xalan.xsltc.dom.AdaptiveResultTreeImpl,121,3,0,16,345,0,2,15,118,0.808333333,1630,1.0,3,0.633846154,0.134444444,1,18,12.41322314,2,1.7603,1,"
package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.StripFilter;
import org.apache.xalan.xsltc.runtime.Hashtable;
import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xalan.xsltc.runtime.AttributeList;

import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.utils.XMLString;

import org.apache.xml.serializer.SerializationHandler;

import javax.xml.transform.SourceLocator;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;


public class AdaptiveResultTreeImpl extends SimpleResultTreeImpl
{
    
    
    private static int _documentURIIndex = 0;

    
    private SAXImpl _dom;
    
    
    
    
    private DTMWSFilter _wsfilter;
    
    
    private int _initSize;
    
    
    private boolean _buildIdIndex;
    
    
    private final AttributeList  _attributes = new AttributeList();
    
    
    private String _openElementName;
    
    
    
    public AdaptiveResultTreeImpl(XSLTCDTMManager dtmManager, int documentID,
                                  DTMWSFilter wsfilter, int initSize,
                                  boolean buildIdIndex)
    {
        super(dtmManager, documentID);
        
        _wsfilter = wsfilter;
        _initSize = initSize;
        _buildIdIndex = buildIdIndex;
    }
    
    
    public DOM getNestedDOM()
    {
        return _dom;
    }
        
    
    public int getDocument()
    {
        if (_dom != null) {
            return _dom.getDocument();
        }
        else {
            return super.getDocument();
        }
    }

    
    public String getStringValue()
    {
        if (_dom != null) {
            return _dom.getStringValue();
        }
        else {
            return super.getStringValue();
        }
    }
    
    public DTMAxisIterator getIterator()
    {
        if (_dom != null) {
            return _dom.getIterator();
        }
        else {
            return super.getIterator();
        }
    }
	
    public DTMAxisIterator getChildren(final int node)
    {
        if (_dom != null) {
            return _dom.getChildren(node);
        }
        else {
            return super.getChildren(node);
        }
    }
    
    public DTMAxisIterator getTypedChildren(final int type)
    {
        if (_dom != null) {
            return _dom.getTypedChildren(type);
        }
        else {
            return super.getTypedChildren(type);
        }
    }
    
    public DTMAxisIterator getAxisIterator(final int axis)
    {
        if (_dom != null) {
            return _dom.getAxisIterator(axis);
        }
        else {
            return super.getAxisIterator(axis);
        }
    }
    
    public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)
    {
        if (_dom != null) {
            return _dom.getTypedAxisIterator(axis, type);
        }
        else {
            return super.getTypedAxisIterator(axis, type);
        }        
    }
    
    public DTMAxisIterator getNthDescendant(int node, int n, boolean includeself)
    {
        if (_dom != null) {
            return _dom.getNthDescendant(node, n, includeself);
        }
        else {
            return super.getNthDescendant(node, n, includeself);
        }
    }
    
    public DTMAxisIterator getNamespaceAxisIterator(final int axis, final int ns)
    {
        if (_dom != null) {
            return _dom.getNamespaceAxisIterator(axis, ns);
        }
        else {
            return super.getNamespaceAxisIterator(axis, ns);
        }
    }
    
    public DTMAxisIterator getNodeValueIterator(DTMAxisIterator iter, int returnType,
					     String value, boolean op)
    {
        if (_dom != null) {
            return _dom.getNodeValueIterator(iter, returnType, value, op);
        }
        else {
            return super.getNodeValueIterator(iter, returnType, value, op);
        }
    }
    
    public DTMAxisIterator orderNodes(DTMAxisIterator source, int node)
    {
        if (_dom != null) {
            return _dom.orderNodes(source, node);
        }
        else {
            return super.orderNodes(source, node);
        }
    }
    
    public String getNodeName(final int node)
    {
        if (_dom != null) {
            return _dom.getNodeName(node);
        }
        else {
            return super.getNodeName(node);
        }
    }
    
    public String getNodeNameX(final int node)
    {
        if (_dom != null) {
            return _dom.getNodeNameX(node);
        }
        else {
            return super.getNodeNameX(node);
        }
    }
    
    public String getNamespaceName(final int node)
    {
        if (_dom != null) {
            return _dom.getNamespaceName(node);
        }
        else {
            return super.getNamespaceName(node);
        }
    }
    
    
    public int getExpandedTypeID(final int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getExpandedTypeID(nodeHandle);
        }
        else {
            return super.getExpandedTypeID(nodeHandle);
        }
    }
    
    public int getNamespaceType(final int node)
    {
        if (_dom != null) {
            return _dom.getNamespaceType(node);
        }
        else {
            return super.getNamespaceType(node);
        }
    }
    
    public int getParent(final int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getParent(nodeHandle);
        }
        else {
            return super.getParent(nodeHandle);
        }
    }
    
    public int getAttributeNode(final int gType, final int element)
    {
        if (_dom != null) {
            return _dom.getAttributeNode(gType, element);
        }
        else {
            return super.getAttributeNode(gType, element);
        }
    }
    
    public String getStringValueX(final int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getStringValueX(nodeHandle);
        }
        else {
            return super.getStringValueX(nodeHandle);
        }
    }
    
    public void copy(final int node, SerializationHandler handler)
	throws TransletException
    {
        if (_dom != null) {
            _dom.copy(node, handler);
        }
        else {
            super.copy(node, handler);
        }
    }
    
    public void copy(DTMAxisIterator nodes, SerializationHandler handler)
	throws TransletException
    {
        if (_dom != null) {
            _dom.copy(nodes, handler);
        }
        else {
            super.copy(nodes, handler);
        }
    }
    
    public String shallowCopy(final int node, SerializationHandler handler)
	throws TransletException
    {
        if (_dom != null) {
            return _dom.shallowCopy(node, handler);
        }
        else {
            return super.shallowCopy(node, handler);
        }
    }
    
    public boolean lessThan(final int node1, final int node2)
    {
        if (_dom != null) {
            return _dom.lessThan(node1, node2);
        }
        else {
            return super.lessThan(node1, node2);
        }
    }
    
    
    public void characters(final int node, SerializationHandler handler)
	throws TransletException
    {
        if (_dom != null) {
            _dom.characters(node, handler);
        }
        else {
            super.characters(node, handler);
        }        
    }
    
    public Node makeNode(int index)
    {
        if (_dom != null) {
            return _dom.makeNode(index);
        }
        else {
            return super.makeNode(index);
        }        
    }
    
    public Node makeNode(DTMAxisIterator iter)
    {
        if (_dom != null) {
            return _dom.makeNode(iter);
        }
        else {
            return super.makeNode(iter);
        }        
    }
    
    public NodeList makeNodeList(int index)
    {
        if (_dom != null) {
            return _dom.makeNodeList(index);
        }
        else {
            return super.makeNodeList(index);
        }        
    }
    
    public NodeList makeNodeList(DTMAxisIterator iter)
    {
        if (_dom != null) {
            return _dom.makeNodeList(iter);
        }
        else {
            return super.makeNodeList(iter);
        }        
    }
    
    public String getLanguage(int node)
    {
        if (_dom != null) {
            return _dom.getLanguage(node);
        }
        else {
            return super.getLanguage(node);
        }        
    }
    
    public int getSize()
    {
        if (_dom != null) {
            return _dom.getSize();
        }
        else {
            return super.getSize();
        }        
    }
    
    public String getDocumentURI(int node)
    {
        if (_dom != null) {
            return _dom.getDocumentURI(node);
        }
        else {
            return ""adaptive_rtf"" + _documentURIIndex++;
        }        
    }
    
    public void setFilter(StripFilter filter)
    {
        if (_dom != null) {
            _dom.setFilter(filter);
        }
        else {
            super.setFilter(filter);
        }        
    }
    
    public void setupMapping(String[] names, String[] namespaces)
    {
        if (_dom != null) {
            _dom.setupMapping(names, namespaces);
        }
        else {
            super.setupMapping(names, namespaces);
        }        
    }
    
    public boolean isElement(final int node)
    {
        if (_dom != null) {
            return _dom.isElement(node);
        }
        else {
            return super.isElement(node);
        }        
    }
    
    public boolean isAttribute(final int node)
    {
        if (_dom != null) {
            return _dom.isAttribute(node);
        }
        else {
            return super.isAttribute(node);
        }        
    }
    
    public String lookupNamespace(int node, String prefix)
	throws TransletException
    {
        if (_dom != null) {
            return _dom.lookupNamespace(node, prefix);
        }
        else {
            return super.lookupNamespace(node, prefix);
        }        
    }
    
    
    public final int getNodeIdent(final int nodehandle)
    {
        if (_dom != null) {
            return _dom.getNodeIdent(nodehandle);
        }
        else {
            return super.getNodeIdent(nodehandle);
        }        
    }
    
    
    public final int getNodeHandle(final int nodeId)
    {
        if (_dom != null) {
            return _dom.getNodeHandle(nodeId);
        }
        else {
            return super.getNodeHandle(nodeId);
        }        
    }
    
    public DOM getResultTreeFrag(int initialSize, int rtfType)
    {
        if (_dom != null) {
            return _dom.getResultTreeFrag(initialSize, rtfType);
        }
        else {
            return super.getResultTreeFrag(initialSize, rtfType);
        }        
    }
    
    public SerializationHandler getOutputDomBuilder()
    {
        return this;
    }
    
    public int getNSType(int node)
    {
        if (_dom != null) {
            return _dom.getNSType(node);
        }
        else {
            return super.getNSType(node);
        }        
    }
    
    public String getUnparsedEntityURI(String name)
    {
        if (_dom != null) {
            return _dom.getUnparsedEntityURI(name);
        }
        else {
            return super.getUnparsedEntityURI(name);
        }        
    }
    
    public Hashtable getElementsWithIDs()
    {
        if (_dom != null) {
            return _dom.getElementsWithIDs();
        }
        else {
            return super.getElementsWithIDs();
        }        
    }

    
        
    
    
    private void maybeEmitStartElement() throws SAXException
    {
	if (_openElementName != null) {

	   int index;
	   if ((index =_openElementName.indexOf("":"")) < 0)
	       _dom.startElement(null, _openElementName, _openElementName, _attributes);
	   else
	       _dom.startElement(null, _openElementName.substring(index+1), _openElementName, _attributes);


	    _openElementName = null;
	}
    }
    
    
    private void prepareNewDOM() throws SAXException
    {
        _dom = (SAXImpl)_dtmManager.getDTM(null, true, _wsfilter,
                                  true, false, false,
                                  _initSize, _buildIdIndex);
        _dom.startDocument();
        
        for (int i = 0; i < _size; i++) {
            String str = _textArray[i];
            _dom.characters(str.toCharArray(), 0, str.length());
        }
        _size = 0;
    }
    
    public void startDocument() throws SAXException
    {    
    }
    
    public void endDocument() throws SAXException
    {
        if (_dom != null) {
            _dom.endDocument();
        }
        else {
            super.endDocument();
        }
    }

    public void characters(String str) throws SAXException
    {
        if (_dom != null) {
            characters(str.toCharArray(), 0, str.length());
        }
        else {
            super.characters(str);
        }
    }
    
    public void characters(char[] ch, int offset, int length)
	throws SAXException
    {
        if (_dom != null) {
	    maybeEmitStartElement();
	    _dom.characters(ch, offset, length);
        }
        else {
            super.characters(ch, offset, length);
        }
    }
    
    public boolean setEscaping(boolean escape) throws SAXException
    {
        if (_dom != null) {
            return _dom.setEscaping(escape);
        }
        else {
            return super.setEscaping(escape);
        }
    }
    
    public void startElement(String elementName) throws SAXException
    {
        if (_dom == null) {
            prepareNewDOM();
        }
        	   	    
	maybeEmitStartElement();
	_openElementName = elementName;
	_attributes.clear();
    }

    public void startElement(String uri, String localName, String qName)
        throws SAXException
    {
        startElement(qName);
    }

    public void startElement(String uri, String localName, String qName, Attributes attributes)
        throws SAXException
    {
        startElement(qName);
    }
    
    public void endElement(String elementName) throws SAXException
    {    
	maybeEmitStartElement();
	_dom.endElement(null, null, elementName);
    }

    public void endElement(String uri, String localName, String qName)
        throws SAXException
    {
        endElement(qName);
    }

    public void addAttribute(String name, String value)
    {    
	if (_openElementName != null) {
	    _attributes.add(name, value);
	}
	else {
	    BasisLibrary.runTimeError(BasisLibrary.STRAY_ATTRIBUTE_ERR, name);
	}
    }

    public void namespaceAfterStartElement(String prefix, String uri)
        throws SAXException
    {    
	if (_dom == null) {
	   prepareNewDOM(); 
	}
	
	_dom.startPrefixMapping(prefix, uri);
    }
    
    public void comment(String comment) throws SAXException
    {    
	if (_dom == null) {
	   prepareNewDOM(); 
	}
	
	maybeEmitStartElement();
        char[] chars = comment.toCharArray();
        _dom.comment(chars, 0, chars.length);
    }

    public void comment(char[] chars, int offset, int length)
        throws SAXException
    {    
	if (_dom == null) {
	   prepareNewDOM(); 
	}
	
	maybeEmitStartElement();
        _dom.comment(chars, offset, length);
    }
    
    public void processingInstruction(String target, String data)
	throws SAXException
    {    
	if (_dom == null) {
	   prepareNewDOM(); 
	}
	
	maybeEmitStartElement();
	_dom.processingInstruction(target, data);
    }
    
    
         
    public void setFeature(String featureId, boolean state)
    {
        if (_dom != null) {
            _dom.setFeature(featureId, state);
        }
    }
    
    public void setProperty(String property, Object value)
    {
        if (_dom != null) {
            _dom.setProperty(property, value);
        }
    }
    
    public DTMAxisTraverser getAxisTraverser(final int axis)
    {
        if (_dom != null) {
            return _dom.getAxisTraverser(axis);
        }
        else {
            return super.getAxisTraverser(axis);
        }
    }
    
    public boolean hasChildNodes(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.hasChildNodes(nodeHandle);
        }
        else {
            return super.hasChildNodes(nodeHandle);
        }
    }
    
    public int getFirstChild(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getFirstChild(nodeHandle);
        }
        else {
            return super.getFirstChild(nodeHandle);
        }
    }
    
    public int getLastChild(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getLastChild(nodeHandle);
        }
        else {
            return super.getLastChild(nodeHandle);
        }
    }
    
    public int getAttributeNode(int elementHandle, String namespaceURI, String name)
    {
        if (_dom != null) {
            return _dom.getAttributeNode(elementHandle, namespaceURI, name);
        }
        else {
            return super.getAttributeNode(elementHandle, namespaceURI, name);
        }
    }
    
    public int getFirstAttribute(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getFirstAttribute(nodeHandle);
        }
        else {
            return super.getFirstAttribute(nodeHandle);
        }
    }
    
    public int getFirstNamespaceNode(int nodeHandle, boolean inScope)
    {
        if (_dom != null) {
            return _dom.getFirstNamespaceNode(nodeHandle, inScope);
        }
        else {
            return super.getFirstNamespaceNode(nodeHandle, inScope);
        }
    }
    
    public int getNextSibling(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getNextSibling(nodeHandle);
        }
        else {
            return super.getNextSibling(nodeHandle);
        }
     }
    
    public int getPreviousSibling(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getPreviousSibling(nodeHandle);
        }
        else {
            return super.getPreviousSibling(nodeHandle);
        }
     }
    
    public int getNextAttribute(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getNextAttribute(nodeHandle);
        }
        else {
            return super.getNextAttribute(nodeHandle);
        }
    }
    
    public int getNextNamespaceNode(int baseHandle, int namespaceHandle,
                                  boolean inScope)
    {
        if (_dom != null) {
            return _dom.getNextNamespaceNode(baseHandle, namespaceHandle, inScope);
        }
        else {
            return super.getNextNamespaceNode(baseHandle, namespaceHandle, inScope);
        }
    }
    
    public int getOwnerDocument(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getOwnerDocument(nodeHandle);
        }
        else {
            return super.getOwnerDocument(nodeHandle);
        }
    }
    
    public int getDocumentRoot(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getDocumentRoot(nodeHandle);
        }
        else {
            return super.getDocumentRoot(nodeHandle);
        }
    }
    
    public XMLString getStringValue(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getStringValue(nodeHandle);
        }
        else {
            return super.getStringValue(nodeHandle);
        }
    }
    
    public int getStringValueChunkCount(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getStringValueChunkCount(nodeHandle);
        }
        else {
            return super.getStringValueChunkCount(nodeHandle);
        }
    }
    
    public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
                                    int[] startAndLen)
    {
        if (_dom != null) {
            return _dom.getStringValueChunk(nodeHandle, chunkIndex, startAndLen);
        }
        else {
            return super.getStringValueChunk(nodeHandle, chunkIndex, startAndLen);
        }
    }
    
    public int getExpandedTypeID(String namespace, String localName, int type)
    {
        if (_dom != null) {
            return _dom.getExpandedTypeID(namespace, localName, type);
        }
        else {
            return super.getExpandedTypeID(namespace, localName, type);
        }
    }
    
    public String getLocalNameFromExpandedNameID(int ExpandedNameID)
    {
        if (_dom != null) {
            return _dom.getLocalNameFromExpandedNameID(ExpandedNameID);
        }
        else {
            return super.getLocalNameFromExpandedNameID(ExpandedNameID);
        }
    }
    
    public String getNamespaceFromExpandedNameID(int ExpandedNameID)
    {
        if (_dom != null) {
            return _dom.getNamespaceFromExpandedNameID(ExpandedNameID);
        }
        else {
            return super.getNamespaceFromExpandedNameID(ExpandedNameID);
        }
    }
    
    public String getLocalName(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getLocalName(nodeHandle);
        }
        else {
            return super.getLocalName(nodeHandle);
        }
    }
    
    public String getPrefix(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getPrefix(nodeHandle);
        }
        else {
            return super.getPrefix(nodeHandle);
        }
    }
    
    public String getNamespaceURI(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getNamespaceURI(nodeHandle);
        }
        else {
            return super.getNamespaceURI(nodeHandle);
        }
    }
    
    public String getNodeValue(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getNodeValue(nodeHandle);
        }
        else {
            return super.getNodeValue(nodeHandle);
        }
    }
    
    public short getNodeType(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getNodeType(nodeHandle);
        }
        else {
            return super.getNodeType(nodeHandle);
        }
    }
    
    public short getLevel(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getLevel(nodeHandle);
        }
        else {
            return super.getLevel(nodeHandle);
        }
    }
    
    public boolean isSupported(String feature, String version)
    {
        if (_dom != null) {
            return _dom.isSupported(feature, version);
        }
        else {
            return super.isSupported(feature, version);
        }
    }
    
    public String getDocumentBaseURI()
    {
        if (_dom != null) {
            return _dom.getDocumentBaseURI();
        }
        else {
            return super.getDocumentBaseURI();
        }
    }
    
    public void setDocumentBaseURI(String baseURI)
    {
        if (_dom != null) {
            _dom.setDocumentBaseURI(baseURI);
        }
        else {
            super.setDocumentBaseURI(baseURI);
        }
    }
    
    public String getDocumentSystemIdentifier(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getDocumentSystemIdentifier(nodeHandle);
        }
        else {
            return super.getDocumentSystemIdentifier(nodeHandle);
        }
    }
    
    public String getDocumentEncoding(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getDocumentEncoding(nodeHandle);
        }
        else {
            return super.getDocumentEncoding(nodeHandle);
        }
    }
    
    public String getDocumentStandalone(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getDocumentStandalone(nodeHandle);
        }
        else {
            return super.getDocumentStandalone(nodeHandle);
        }
    }
    
    public String getDocumentVersion(int documentHandle)
    {
        if (_dom != null) {
            return _dom.getDocumentVersion(documentHandle);
        }
        else {
            return super.getDocumentVersion(documentHandle);
        }
    }
    
    public boolean getDocumentAllDeclarationsProcessed()
    {
        if (_dom != null) {
            return _dom.getDocumentAllDeclarationsProcessed();
        }
        else {
            return super.getDocumentAllDeclarationsProcessed();
        }
    }
    
    public String getDocumentTypeDeclarationSystemIdentifier()
    {
        if (_dom != null) {
            return _dom.getDocumentTypeDeclarationSystemIdentifier();
        }
        else {
            return super.getDocumentTypeDeclarationSystemIdentifier();
        }
    }
    
    public String getDocumentTypeDeclarationPublicIdentifier()
    {
        if (_dom != null) {
            return _dom.getDocumentTypeDeclarationPublicIdentifier();
        }
        else {
            return super.getDocumentTypeDeclarationPublicIdentifier();
        }
    }
    
    public int getElementById(String elementId)
    {
        if (_dom != null) {
            return _dom.getElementById(elementId);
        }
        else {
            return super.getElementById(elementId);
        }
    }
        
    public boolean supportsPreStripping()
    {
        if (_dom != null) {
            return _dom.supportsPreStripping();
        }
        else {
            return super.supportsPreStripping();
        }
    }
    
    public boolean isNodeAfter(int firstNodeHandle, int secondNodeHandle)
    {
        if (_dom != null) {
            return _dom.isNodeAfter(firstNodeHandle, secondNodeHandle);
        }
        else {
            return super.isNodeAfter(firstNodeHandle, secondNodeHandle);
        }
    }
    
    public boolean isCharacterElementContentWhitespace(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.isCharacterElementContentWhitespace(nodeHandle);
        }
        else {
            return super.isCharacterElementContentWhitespace(nodeHandle);
        }
    }
    
    public boolean isDocumentAllDeclarationsProcessed(int documentHandle)
    {
        if (_dom != null) {
            return _dom.isDocumentAllDeclarationsProcessed(documentHandle);
        }
        else {
            return super.isDocumentAllDeclarationsProcessed(documentHandle);
        }
    }
    
    public boolean isAttributeSpecified(int attributeHandle)
    {
        if (_dom != null) {
            return _dom.isAttributeSpecified(attributeHandle);
        }
        else {
            return super.isAttributeSpecified(attributeHandle);
        }
    }
    
    public void dispatchCharactersEvents(int nodeHandle, org.xml.sax.ContentHandler ch,
                                         boolean normalize)
          throws org.xml.sax.SAXException
    {
        if (_dom != null) {
            _dom.dispatchCharactersEvents(nodeHandle,  ch, normalize);
        }
        else {
            super.dispatchCharactersEvents(nodeHandle, ch, normalize);
        }
    }
    
    public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
      throws org.xml.sax.SAXException
    {
        if (_dom != null) {
            _dom.dispatchToEvents(nodeHandle,  ch);
        }
        else {
            super.dispatchToEvents(nodeHandle, ch);
        }
    }
    
    public org.w3c.dom.Node getNode(int nodeHandle)
    {
        if (_dom != null) {
            return _dom.getNode(nodeHandle);
        }
        else {
            return super.getNode(nodeHandle);
        }
    }
    
    public boolean needsTwoThreads()
    {
        if (_dom != null) {
            return _dom.needsTwoThreads();
        }
        else {
            return super.needsTwoThreads();
        }
    }
    
    public org.xml.sax.ContentHandler getContentHandler()
    {
        if (_dom != null) {
            return _dom.getContentHandler();
        }
        else {
            return super.getContentHandler();
        }
    }
    
    public org.xml.sax.ext.LexicalHandler getLexicalHandler()
    {
        if (_dom != null) {
            return _dom.getLexicalHandler();
        }
        else {
            return super.getLexicalHandler();
        }
    }
    
    public org.xml.sax.EntityResolver getEntityResolver()
    {
        if (_dom != null) {
            return _dom.getEntityResolver();
        }
        else {
            return super.getEntityResolver();
        }
    }
    
    public org.xml.sax.DTDHandler getDTDHandler()
    {
        if (_dom != null) {
            return _dom.getDTDHandler();
        }
        else {
            return super.getDTDHandler();
        }
    }
    
    public org.xml.sax.ErrorHandler getErrorHandler()
    {
        if (_dom != null) {
            return _dom.getErrorHandler();
        }
        else {
            return super.getErrorHandler();
        }
    }
    
    public org.xml.sax.ext.DeclHandler getDeclHandler()
    {
        if (_dom != null) {
            return _dom.getDeclHandler();
        }
        else {
            return super.getDeclHandler();
        }
    }
    
    public void appendChild(int newChild, boolean clone, boolean cloneDepth)
    {
        if (_dom != null) {
            _dom.appendChild(newChild, clone, cloneDepth);
        }
        else {
            super.appendChild(newChild, clone, cloneDepth);
        }
    }
    
    public void appendTextChild(String str)
    {
        if (_dom != null) {
            _dom.appendTextChild(str);
        }
        else {
            super.appendTextChild(str);
        }
    }
    
    public SourceLocator getSourceLocatorFor(int node)
    {
        if (_dom != null) {
            return _dom.getSourceLocatorFor(node);
        }
        else {
            return super.getSourceLocatorFor(node);
        }
    }
    
    public void documentRegistration()
    {
        if (_dom != null) {
            _dom.documentRegistration();
        }
        else {
            super.documentRegistration();
        }
    }
    
    public void documentRelease()
    {
        if (_dom != null) {
            _dom.documentRelease();
        }
        else {
            super.documentRelease();
        }
    }

}
"
org.apache.xml.utils.StringToStringTableVector,10,1,0,1,14,0,0,1,10,0.472222222,180,1.0,1,0.0,0.4,0,0,16.6,3,1.6,1,"
package org.apache.xml.utils;


public class StringToStringTableVector
{

  
  private int m_blocksize;

  
  private StringToStringTable m_map[];

  
  private int m_firstFree = 0;

  
  private int m_mapSize;

  
  public StringToStringTableVector()
  {

    m_blocksize = 8;
    m_mapSize = m_blocksize;
    m_map = new StringToStringTable[m_blocksize];
  }

  
  public StringToStringTableVector(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new StringToStringTable[blocksize];
  }

  
  public final int getLength()
  {
    return m_firstFree;
  }

  
  public final int size()
  {
    return m_firstFree;
  }

  
  public final void addElement(StringToStringTable value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      StringToStringTable newMap[] = new StringToStringTable[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final String get(String key)
  {

    for (int i = m_firstFree - 1; i >= 0; --i)
    {
      String nsuri = m_map[i].get(key);

      if (nsuri != null)
        return nsuri;
    }

    return null;
  }

  
  public final boolean containsKey(String key)
  {

    for (int i = m_firstFree - 1; i >= 0; --i)
    {
      if (m_map[i].get(key) != null)
        return true;
    }

    return false;
  }

  
  public final void removeLastElem()
  {

    if (m_firstFree > 0)
    {
      m_map[m_firstFree] = null;

      m_firstFree--;
    }
  }

  
  public final StringToStringTable elementAt(int i)
  {
    return m_map[i];
  }

  
  public final boolean contains(StringToStringTable s)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equals(s))
        return true;
    }

    return false;
  }
}
"
org.apache.xml.dtm.ref.IncrementalSAXSource_Xerces,14,1,0,9,51,27,1,8,10,0.596153846,749,0.05,0,0.0,0.162393162,0,0,51.07142857,9,1.5,0,"

package org.apache.xml.dtm.ref;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;

import org.apache.xerces.parsers.SAXParser;
import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;



public class IncrementalSAXSource_Xerces
  implements IncrementalSAXSource
{
  
  
  
  
  
  
  Method fParseSomeSetup=null; 
  Method fParseSome=null; 
  Object fPullParserConfig=null; 
  Method fConfigSetInput=null; 
  Method fConfigParse=null; 
  Method fSetInputSource=null; 
  Constructor fConfigInputSourceCtor=null; 
  Method fConfigSetByteStream=null; 
  Method fConfigSetCharStream=null; 
  Method fConfigSetEncoding=null; 
  Method fReset=null; 
  
  
  
  
  SAXParser fIncrementalParser;
  private boolean fParseInProgress=false;

  
  
  

  
  public IncrementalSAXSource_Xerces() 
		throws NoSuchMethodException
	{
		try
		{
			
			
			
			
			
			
			
			
			
			
			
			Class me=this.getClass();
			
			
			Class xniConfigClass=Class.forName(""org.apache.xerces.xni.parser.XMLParserConfiguration"");
			Class[] args1={xniConfigClass};
			Constructor ctor=SAXParser.class.getConstructor(args1);
			
			
			
			
			Class xniStdConfigClass=Class.forName(""org.apache.xerces.parsers.StandardParserConfiguration"");
			fPullParserConfig=xniStdConfigClass.newInstance();
			Object[] args2={fPullParserConfig};
			fIncrementalParser = (SAXParser)ctor.newInstance(args2);
			
			
			
			
			Class fXniInputSourceClass=Class.forName(""org.apache.xerces.xni.parser.XMLInputSource"");
			Class[] args3={fXniInputSourceClass};
			fConfigSetInput=xniStdConfigClass.getMethod(""setInputSource"",args3);

			Class[] args4={String.class,String.class,String.class};
			fConfigInputSourceCtor=fXniInputSourceClass.getConstructor(args4);
			Class[] args5={java.io.InputStream.class};
			fConfigSetByteStream=fXniInputSourceClass.getMethod(""setByteStream"",args5);
			Class[] args6={java.io.Reader.class};
			fConfigSetCharStream=fXniInputSourceClass.getMethod(""setCharacterStream"",args6);
			Class[] args7={String.class};
			fConfigSetEncoding=fXniInputSourceClass.getMethod(""setEncoding"",args7);

			Class[] argsb={Boolean.TYPE};
			fConfigParse=xniStdConfigClass.getMethod(""parse"",argsb);			
			Class[] noargs=new Class[0];
			fReset=fIncrementalParser.getClass().getMethod(""reset"",noargs);
		}
		catch(Exception e)
		{
	    
			
			
			
			IncrementalSAXSource_Xerces dummy=new IncrementalSAXSource_Xerces(new SAXParser());
			this.fParseSomeSetup=dummy.fParseSomeSetup;
			this.fParseSome=dummy.fParseSome;
			this.fIncrementalParser=dummy.fIncrementalParser;
		}
  }

  
  public IncrementalSAXSource_Xerces(SAXParser parser) 
    throws NoSuchMethodException  
  {
		
		
		
		
		
    fIncrementalParser=parser;
		Class me=parser.getClass();
    Class[] parms={InputSource.class};
    fParseSomeSetup=me.getMethod(""parseSomeSetup"",parms);
    parms=new Class[0];
    fParseSome=me.getMethod(""parseSome"",parms);
    
    
  }

  
  
  
  static public IncrementalSAXSource createIncrementalSAXSource() 
	{
		try
		{
			return new IncrementalSAXSource_Xerces();
		}
		catch(NoSuchMethodException e)
		{
			
			
			IncrementalSAXSource_Filter iss=new IncrementalSAXSource_Filter();
			iss.setXMLReader(new SAXParser());
			return iss;
		}
  }
	
  static public IncrementalSAXSource
  createIncrementalSAXSource(SAXParser parser) {
		try
		{
			return new IncrementalSAXSource_Xerces(parser);
		}
		catch(NoSuchMethodException e)
		{
			
			
			IncrementalSAXSource_Filter iss=new IncrementalSAXSource_Filter();
			iss.setXMLReader(parser);
			return iss;
		}
  }

  
  
  

  
  public void setContentHandler(org.xml.sax.ContentHandler handler)
  {
    
    
    ((XMLReader)fIncrementalParser).setContentHandler(handler);
  }

  
  public void setLexicalHandler(org.xml.sax.ext.LexicalHandler handler)
  {
    
    try 
    {
      
      
      ((XMLReader)fIncrementalParser).setProperty(""http:
                                     handler);
    }
    catch(org.xml.sax.SAXNotRecognizedException e)
    {
      
    }
    catch(org.xml.sax.SAXNotSupportedException e)
    {
      
    }
  }
  
  
  public void setDTDHandler(org.xml.sax.DTDHandler handler)
  {
    
    
    ((XMLReader)fIncrementalParser).setDTDHandler(handler);
  }

  
  
  public void startParse(InputSource source) throws SAXException
  {
    if (fIncrementalParser==null)
      throw new SAXException(XMLMessages.createXMLMessage(XMLErrorResources.ER_STARTPARSE_NEEDS_SAXPARSER, null)); 
    if (fParseInProgress)
      throw new SAXException(XMLMessages.createXMLMessage(XMLErrorResources.ER_STARTPARSE_WHILE_PARSING, null)); 

    boolean ok=false;

    try
    {
      ok = parseSomeSetup(source);
    }
    catch(Exception ex)
    {
      throw new SAXException(ex);
    }
    
    if(!ok)
      throw new SAXException(XMLMessages.createXMLMessage(XMLErrorResources.ER_COULD_NOT_INIT_PARSER, null)); 
  }

  
  
  public Object deliverMoreNodes (boolean parsemore)
  {
    if(!parsemore)
    {
      fParseInProgress=false;
      return Boolean.FALSE;
    }

    Object arg;
    try {
      boolean keepgoing = parseSome();
      arg = keepgoing ? Boolean.TRUE : Boolean.FALSE;
    } catch (SAXException ex) {
      arg = ex;
    } catch (IOException ex) {
      arg = ex;
    } catch (Exception ex) {
      arg = new SAXException(ex);
    }
    return arg;
  }
	
	
	private boolean parseSomeSetup(InputSource source) 
		throws SAXException, IOException, IllegalAccessException, 
					 java.lang.reflect.InvocationTargetException,
					 java.lang.InstantiationException
	{
		if(fConfigSetInput!=null)
		{
			
			
			Object[] parms1={source.getPublicId(),source.getSystemId(),null};
			Object xmlsource=fConfigInputSourceCtor.newInstance(parms1);
			Object[] parmsa={source.getByteStream()};
			fConfigSetByteStream.invoke(xmlsource,parmsa);
			parmsa[0]=source.getCharacterStream();
			fConfigSetCharStream.invoke(xmlsource,parmsa);
			parmsa[0]=source.getEncoding();
			fConfigSetEncoding.invoke(xmlsource,parmsa);

			
			
			
			
			Object[] noparms=new Object[0];
			fReset.invoke(fIncrementalParser,noparms);
			
			parmsa[0]=xmlsource;
			fConfigSetInput.invoke(fPullParserConfig,parmsa);
			
			
			return parseSome();
		}
		else
		{
			Object[] parm={source};
			Object ret=fParseSomeSetup.invoke(fIncrementalParser,parm);
			return ((Boolean)ret).booleanValue();
		}
	}
	
	static final Object[] noparms=new Object[0]; 
	static final Object[] parmsfalse={Boolean.FALSE};
	private boolean parseSome()
		throws SAXException, IOException, IllegalAccessException,
					 java.lang.reflect.InvocationTargetException
	{
		
		if(fConfigSetInput!=null)
		{
			Object ret=(Boolean)(fConfigParse.invoke(fPullParserConfig,parmsfalse));
			return ((Boolean)ret).booleanValue();
		}
		else
		{
			Object ret=fParseSome.invoke(fIncrementalParser,noparms);
			return ((Boolean)ret).booleanValue();
		}
	}
	

  
  
  public static void main(String args[])
  {
    System.out.println(""Starting..."");

    CoroutineManager co = new CoroutineManager();
    int appCoroutineID = co.co_joinCoroutineSet(-1);
    if (appCoroutineID == -1)
    {
      System.out.println(""ERROR: Couldn't allocate coroutine number.
"");
      return;
    }
    IncrementalSAXSource parser=
      createIncrementalSAXSource();

    
    org.apache.xml.serialize.XMLSerializer trace;
    trace=new org.apache.xml.serialize.XMLSerializer(System.out,null);
    parser.setContentHandler(trace);
    parser.setLexicalHandler(trace);

    

    for(int arg=0;arg<args.length;++arg)
    {
      try
      {
        InputSource source = new InputSource(args[arg]);
        Object result=null;
        boolean more=true;
        parser.startParse(source);
        for(result = parser.deliverMoreNodes(more);
            result==Boolean.TRUE;
            result = parser.deliverMoreNodes(more))
        {
          System.out.println(""
Some parsing successful, trying more.
"");
            
          
          if(arg+1<args.length && ""!"".equals(args[arg+1]))
          {
            ++arg;
            more=false;
          }
            
        }
        
        if (result instanceof Boolean && ((Boolean)result)==Boolean.FALSE)
        {
          System.out.println(""
Parser ended (EOF or on request).
"");
        }
        else if (result == null) {
          System.out.println(""
UNEXPECTED: Parser says shut down prematurely.
"");
        }
        else if (result instanceof Exception) {
          throw new org.apache.xml.utils.WrappedRuntimeException((Exception)result);
          
Parser threw exception:"");
          
        }
        
      }

      catch(SAXException e)
      {
        e.printStackTrace();
      }
    }
    
  }

  
} 
"
org.apache.xpath.compiler.Keywords,3,1,0,4,9,1,4,0,2,1.456896552,583,0.896551724,0,0.0,0.5,0,0,174.0,3,1.0,1,"
package org.apache.xpath.compiler;

import java.util.Hashtable;


public class Keywords
{

  
  static Hashtable m_keywords = new Hashtable();

  
  static Hashtable m_axisnames = new Hashtable();

  
  static Hashtable m_functions = new Hashtable();

  
  static Hashtable m_nodetypes = new Hashtable();

  
  private static final String FROM_ANCESTORS_STRING = ""ancestor"";

  
  private static final String FROM_ANCESTORS_OR_SELF_STRING =
    ""ancestor-or-self"";

  
  private static final String FROM_ATTRIBUTES_STRING = ""attribute"";

  
  private static final String FROM_CHILDREN_STRING = ""child"";

  
  private static final String FROM_DESCENDANTS_STRING = ""descendant"";

  
  private static final String FROM_DESCENDANTS_OR_SELF_STRING =
    ""descendant-or-self"";

  
  private static final String FROM_FOLLOWING_STRING = ""following"";

  
  private static final String FROM_FOLLOWING_SIBLINGS_STRING =
    ""following-sibling"";

  
  private static final String FROM_PARENT_STRING = ""parent"";

  
  private static final String FROM_PRECEDING_STRING = ""preceding"";

  
  private static final String FROM_PRECEDING_SIBLINGS_STRING =
    ""preceding-sibling"";

  
  private static final String FROM_SELF_STRING = ""self"";

  
  private static final String FROM_NAMESPACE_STRING = ""namespace"";

  
  private static final String FROM_SELF_ABBREVIATED_STRING = ""."";

  
  private static final String NODETYPE_COMMENT_STRING = ""comment"";

  
  private static final String NODETYPE_TEXT_STRING = ""text"";

  
  private static final String NODETYPE_PI_STRING = ""processing-instruction"";

  
  private static final String NODETYPE_NODE_STRING = ""node"";

  
  private static final String NODETYPE_ANYELEMENT_STRING = ""*"";

  
  private static final String FUNC_CURRENT_STRING = ""current"";

  
  private static final String FUNC_LAST_STRING = ""last"";

  
  private static final String FUNC_POSITION_STRING = ""position"";

  
  private static final String FUNC_COUNT_STRING = ""count"";

  
  static final String FUNC_ID_STRING = ""id"";

  
  public static final String FUNC_KEY_STRING = ""key"";

  
  private static final String FUNC_LOCAL_PART_STRING = ""local-name"";

  
  private static final String FUNC_NAMESPACE_STRING = ""namespace-uri"";

  
  private static final String FUNC_NAME_STRING = ""name"";

  
  private static final String FUNC_GENERATE_ID_STRING = ""generate-id"";

  
  private static final String FUNC_NOT_STRING = ""not"";

  
  private static final String FUNC_TRUE_STRING = ""true"";

  
  private static final String FUNC_FALSE_STRING = ""false"";

  
  private static final String FUNC_BOOLEAN_STRING = ""boolean"";

  
  private static final String FUNC_LANG_STRING = ""lang"";

  
  private static final String FUNC_NUMBER_STRING = ""number"";

  
  private static final String FUNC_FLOOR_STRING = ""floor"";

  
  private static final String FUNC_CEILING_STRING = ""ceiling"";

  
  private static final String FUNC_ROUND_STRING = ""round"";

  
  private static final String FUNC_SUM_STRING = ""sum"";

  
  private static final String FUNC_STRING_STRING = ""string"";

  
  private static final String FUNC_STARTS_WITH_STRING = ""starts-with"";

  
  private static final String FUNC_CONTAINS_STRING = ""contains"";

  
  private static final String FUNC_SUBSTRING_BEFORE_STRING =
    ""substring-before"";

  
  private static final String FUNC_SUBSTRING_AFTER_STRING = ""substring-after"";

  
  private static final String FUNC_NORMALIZE_SPACE_STRING = ""normalize-space"";

  
  private static final String FUNC_TRANSLATE_STRING = ""translate"";

  
  private static final String FUNC_CONCAT_STRING = ""concat"";

  
  private static final String FUNC_SYSTEM_PROPERTY_STRING = ""system-property"";

  
  private static final String FUNC_EXT_FUNCTION_AVAILABLE_STRING =
    ""function-available"";

  
  private static final String FUNC_EXT_ELEM_AVAILABLE_STRING =
    ""element-available"";

  
  private static final String FUNC_SUBSTRING_STRING = ""substring"";

  
  private static final String FUNC_STRING_LENGTH_STRING = ""string-length"";

  
  private static final String FUNC_UNPARSED_ENTITY_URI_STRING =
    ""unparsed-entity-uri"";

  

  
  private static final String FUNC_DOCLOCATION_STRING = ""document-location"";

  static
  {
    m_axisnames.put(FROM_ANCESTORS_STRING,
                    new Integer(OpCodes.FROM_ANCESTORS));
    m_axisnames.put(FROM_ANCESTORS_OR_SELF_STRING,
                    new Integer(OpCodes.FROM_ANCESTORS_OR_SELF));
    m_axisnames.put(FROM_ATTRIBUTES_STRING,
                    new Integer(OpCodes.FROM_ATTRIBUTES));
    m_axisnames.put(FROM_CHILDREN_STRING,
                    new Integer(OpCodes.FROM_CHILDREN));
    m_axisnames.put(FROM_DESCENDANTS_STRING,
                    new Integer(OpCodes.FROM_DESCENDANTS));
    m_axisnames.put(FROM_DESCENDANTS_OR_SELF_STRING,
                    new Integer(OpCodes.FROM_DESCENDANTS_OR_SELF));
    m_axisnames.put(FROM_FOLLOWING_STRING,
                    new Integer(OpCodes.FROM_FOLLOWING));
    m_axisnames.put(FROM_FOLLOWING_SIBLINGS_STRING,
                    new Integer(OpCodes.FROM_FOLLOWING_SIBLINGS));
    m_axisnames.put(FROM_PARENT_STRING,
                    new Integer(OpCodes.FROM_PARENT));
    m_axisnames.put(FROM_PRECEDING_STRING,
                    new Integer(OpCodes.FROM_PRECEDING));
    m_axisnames.put(FROM_PRECEDING_SIBLINGS_STRING,
                    new Integer(OpCodes.FROM_PRECEDING_SIBLINGS));
    m_axisnames.put(FROM_SELF_STRING,
                    new Integer(OpCodes.FROM_SELF));
    m_axisnames.put(FROM_NAMESPACE_STRING,
                    new Integer(OpCodes.FROM_NAMESPACE));
    m_nodetypes.put(NODETYPE_COMMENT_STRING,
                    new Integer(OpCodes.NODETYPE_COMMENT));
    m_nodetypes.put(NODETYPE_TEXT_STRING,
                    new Integer(OpCodes.NODETYPE_TEXT));
    m_nodetypes.put(NODETYPE_PI_STRING,
                    new Integer(OpCodes.NODETYPE_PI));
    m_nodetypes.put(NODETYPE_NODE_STRING,
                    new Integer(OpCodes.NODETYPE_NODE));
    m_nodetypes.put(NODETYPE_ANYELEMENT_STRING,
                    new Integer(OpCodes.NODETYPE_ANYELEMENT));
    m_keywords.put(FROM_SELF_ABBREVIATED_STRING,
                   new Integer(OpCodes.FROM_SELF));
    m_keywords.put(FUNC_ID_STRING,
                   new Integer(FunctionTable.FUNC_ID));
    m_keywords.put(FUNC_KEY_STRING,
                   new Integer(FunctionTable.FUNC_KEY));
    m_functions.put(FUNC_CURRENT_STRING,
                    new Integer(FunctionTable.FUNC_CURRENT));
    m_functions.put(FUNC_LAST_STRING,
                    new Integer(FunctionTable.FUNC_LAST));
    m_functions.put(FUNC_POSITION_STRING,
                    new Integer(FunctionTable.FUNC_POSITION));
    m_functions.put(FUNC_COUNT_STRING,
                    new Integer(FunctionTable.FUNC_COUNT));
    m_functions.put(FUNC_ID_STRING,
                    new Integer(FunctionTable.FUNC_ID));
    m_functions.put(FUNC_KEY_STRING,
                    new Integer(FunctionTable.FUNC_KEY));
    m_functions.put(FUNC_LOCAL_PART_STRING,
                    new Integer(FunctionTable.FUNC_LOCAL_PART));
    m_functions.put(FUNC_NAMESPACE_STRING,
                    new Integer(FunctionTable.FUNC_NAMESPACE));
    m_functions.put(FUNC_NAME_STRING,
                    new Integer(FunctionTable.FUNC_QNAME));
    m_functions.put(FUNC_GENERATE_ID_STRING,
                    new Integer(FunctionTable.FUNC_GENERATE_ID));
    m_functions.put(FUNC_NOT_STRING,
                    new Integer(FunctionTable.FUNC_NOT));
    m_functions.put(FUNC_TRUE_STRING,
                    new Integer(FunctionTable.FUNC_TRUE));
    m_functions.put(FUNC_FALSE_STRING,
                    new Integer(FunctionTable.FUNC_FALSE));
    m_functions.put(FUNC_BOOLEAN_STRING,
                    new Integer(FunctionTable.FUNC_BOOLEAN));
    m_functions.put(FUNC_LANG_STRING,
                    new Integer(FunctionTable.FUNC_LANG));
    m_functions.put(FUNC_NUMBER_STRING,
                    new Integer(FunctionTable.FUNC_NUMBER));
    m_functions.put(FUNC_FLOOR_STRING,
                    new Integer(FunctionTable.FUNC_FLOOR));
    m_functions.put(FUNC_CEILING_STRING,
                    new Integer(FunctionTable.FUNC_CEILING));
    m_functions.put(FUNC_ROUND_STRING,
                    new Integer(FunctionTable.FUNC_ROUND));
    m_functions.put(FUNC_SUM_STRING,
                    new Integer(FunctionTable.FUNC_SUM));
    m_functions.put(FUNC_STRING_STRING,
                    new Integer(FunctionTable.FUNC_STRING));
    m_functions.put(FUNC_STARTS_WITH_STRING,
                    new Integer(FunctionTable.FUNC_STARTS_WITH));
    m_functions.put(FUNC_CONTAINS_STRING,
                    new Integer(FunctionTable.FUNC_CONTAINS));
    m_functions.put(FUNC_SUBSTRING_BEFORE_STRING,
                    new Integer(FunctionTable.FUNC_SUBSTRING_BEFORE));
    m_functions.put(FUNC_SUBSTRING_AFTER_STRING,
                    new Integer(FunctionTable.FUNC_SUBSTRING_AFTER));
    m_functions.put(FUNC_NORMALIZE_SPACE_STRING,
                    new Integer(FunctionTable.FUNC_NORMALIZE_SPACE));
    m_functions.put(FUNC_TRANSLATE_STRING,
                    new Integer(FunctionTable.FUNC_TRANSLATE));
    m_functions.put(FUNC_CONCAT_STRING,
                    new Integer(FunctionTable.FUNC_CONCAT));

    
    m_functions.put(FUNC_SYSTEM_PROPERTY_STRING,
                    new Integer(FunctionTable.FUNC_SYSTEM_PROPERTY));
    m_functions.put(FUNC_EXT_FUNCTION_AVAILABLE_STRING,
                    new Integer(FunctionTable.FUNC_EXT_FUNCTION_AVAILABLE));
    m_functions.put(FUNC_EXT_ELEM_AVAILABLE_STRING,
                    new Integer(FunctionTable.FUNC_EXT_ELEM_AVAILABLE));
    m_functions.put(FUNC_SUBSTRING_STRING,
                    new Integer(FunctionTable.FUNC_SUBSTRING));
    m_functions.put(FUNC_STRING_LENGTH_STRING,
                    new Integer(FunctionTable.FUNC_STRING_LENGTH));
    m_functions.put(FUNC_UNPARSED_ENTITY_URI_STRING,
                    new Integer(FunctionTable.FUNC_UNPARSED_ENTITY_URI));

    
    m_functions.put(NODETYPE_COMMENT_STRING,
                    new Integer(OpCodes.NODETYPE_COMMENT));
    m_functions.put(NODETYPE_TEXT_STRING,
                    new Integer(OpCodes.NODETYPE_TEXT));
    m_functions.put(NODETYPE_PI_STRING,
                    new Integer(OpCodes.NODETYPE_PI));
    m_functions.put(NODETYPE_NODE_STRING,
                    new Integer(OpCodes.NODETYPE_NODE));
    m_functions.put(FUNC_DOCLOCATION_STRING,
                    new Integer(FunctionTable.FUNC_DOCLOCATION));
  }

  
  public static boolean functionAvailable(String methName)
  {

    try
    {
      Object tblEntry = m_functions.get(methName);

      if (null == tblEntry)
        return false;

      int funcType = ((Integer) tblEntry).intValue();

      switch (funcType)
      {
      case OpCodes.NODETYPE_COMMENT :
      case OpCodes.NODETYPE_TEXT :
      case OpCodes.NODETYPE_PI :
      case OpCodes.NODETYPE_NODE :
        return false;  
      default :
        return true;
      }
    }
    catch (Exception e)
    {
      return false;
    }
  }
}
"
org.apache.xalan.transformer.TransformerImpl,130,2,0,117,391,7393,66,68,122,0.942357384,3398,0.743589744,16,0.092198582,0.053123575,1,2,24.83846154,4,1.3231,9,"
package org.apache.xalan.transformer;

import java.io.IOException;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Enumeration;
import java.util.Properties;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.stream.StreamResult;

import org.apache.xalan.extensions.ExtensionsTable;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.serializer.Method;
import org.apache.xml.serializer.Serializer;
import org.apache.xml.serializer.SerializerFactory;
import org.apache.xalan.templates.AVT;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemAttributeSet;
import org.apache.xalan.templates.ElemForEach;
import org.apache.xalan.templates.ElemSort;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemTextLiteral;
import org.apache.xalan.templates.ElemVariable;
import org.apache.xalan.templates.OutputProperties;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetComposed;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.XUnresolvedVariable;
import org.apache.xalan.trace.TraceManager;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.serializer.ToHTMLSAXHandler;
import org.apache.xml.serializer.ToSAXHandler;
import org.apache.xml.serializer.ToTextSAXHandler;
import org.apache.xml.serializer.ToTextStream;
import org.apache.xml.serializer.ToXMLSAXHandler;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.DOMBuilder;
import org.apache.xml.utils.DOMHelper;
import org.apache.xml.utils.NodeVector;
import org.apache.xml.utils.ObjectPool;
import org.apache.xml.utils.ObjectStack;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xml.utils.ThreadControllerWrapper;
import org.apache.xpath.Arg;
import org.apache.xpath.ExtensionsProvider;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.objects.XObject;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.LexicalHandler;

import org.apache.xalan.trace.GenerateEvent;

public class TransformerImpl extends Transformer
        implements Runnable, DTMWSFilter, ExtensionsProvider, org.apache.xml.serializer.SerializerTrace
{

  
  

  
  private Boolean m_reentryGuard = new Boolean(true);

  
  private java.io.FileOutputStream m_outputStream = null;

  
  private boolean m_parserEventsOnMain = true;

  
  private Thread m_transformThread;

  
  private String m_urlOfSource = null;

  
  private Result m_outputTarget = null;

  
  private OutputProperties m_outputFormat;


  
  ContentHandler m_inputContentHandler;

  
  private ContentHandler m_outputContentHandler = null;

  
  
  
  
  
  

  
  DocumentBuilder m_docBuilder = null;

  
  private ObjectPool m_textResultHandlerObjectPool =
    new ObjectPool(""org.apache.xml.serializer.ToTextStream"");

  
  private ObjectPool m_stringWriterObjectPool =
    new ObjectPool(""java.io.StringWriter"");

  
  private OutputProperties m_textformat = new OutputProperties(Method.TEXT);

  
  
  
  
  
  
  
  
  
  
  

  
  ObjectStack m_currentTemplateElements 
      = new ObjectStack(XPathContext.RECURSIONLIMIT);
  
  
  

  
  Stack m_currentMatchTemplates = new Stack();

  
  NodeVector m_currentMatchedNodes = new NodeVector();

  
  private StylesheetRoot m_stylesheetRoot = null;

  
  private boolean m_quietConflictWarnings = true;

  
  private XPathContext m_xcontext;

  
  private StackGuard m_stackGuard;

  
  private SerializationHandler m_serializationHandler;  

  
  private KeyManager m_keyManager = new KeyManager();

  
  Stack m_attrSetStack = null;

  
  CountersTable m_countersTable = null;

  
  BoolStack m_currentTemplateRuleIsNull = new BoolStack();

  
  private MsgMgr m_msgMgr;

  
  public static boolean S_DEBUG = false;

  
  private ErrorListener m_errorHandler =
    new org.apache.xml.utils.DefaultErrorHandler();

  
  private TraceManager m_traceManager = new TraceManager(this);

  
  private Exception m_exceptionThrown = null;

  
  private Source m_xmlSource;

  
  private int m_doc;

  
  private boolean m_isTransformDone = false;

  
  private boolean m_hasBeenReset = false;

  
  private boolean m_shouldReset = true;

  
  public void setShouldReset(boolean shouldReset)
  {
    m_shouldReset = shouldReset;
  }

  
  private Stack m_modes = new Stack();

  
  
  

  
  public TransformerImpl(StylesheetRoot stylesheet)
   
  {
    setStylesheet(stylesheet);
    setXPathContext(new XPathContext(this));
    getXPathContext().setNamespaceContext(stylesheet);
    m_stackGuard = new StackGuard(this);
  }
  
  

  
  private ExtensionsTable m_extensionsTable = null;

  
  public ExtensionsTable getExtensionsTable()
  {
    return m_extensionsTable;
  }

  
  void setExtensionsTable(StylesheetRoot sroot)
       throws javax.xml.transform.TransformerException
  {
    try
    {
      if (sroot.getExtensions() != null)
        m_extensionsTable = new ExtensionsTable(sroot);
    }
    catch (javax.xml.transform.TransformerException te)
    {te.printStackTrace();}
  }
  
  
  
  public boolean functionAvailable(String ns, String funcName)
          throws javax.xml.transform.TransformerException
  {
    return getExtensionsTable().functionAvailable(ns, funcName);
  }
  
  public boolean elementAvailable(String ns, String elemName)
          throws javax.xml.transform.TransformerException
  {
    return getExtensionsTable().elementAvailable(ns, elemName);   
  }
   
  public Object extFunction(String ns, String funcName, 
                            Vector argVec, Object methodKey)
            throws javax.xml.transform.TransformerException
  {
    return getExtensionsTable().extFunction(ns, funcName, 
                                        argVec, methodKey,
                                        getXPathContext().getExpressionContext());   
  }

  public Object extFunction(FuncExtFunction extFunction, Vector argVec)
            throws javax.xml.transform.TransformerException
  {
    return getExtensionsTable().extFunction(extFunction, argVec,
                                            getXPathContext().getExpressionContext());   
  }
  
  

  
  public void reset()
  {

    if (!m_hasBeenReset && m_shouldReset)
    {
      m_hasBeenReset = true;

      if (this.m_outputStream != null)
      {
        try
        {
          m_outputStream.close();
        }
        catch (java.io.IOException ioe){}
      }

      m_outputStream = null;

      
      
      m_countersTable = null;

      m_xcontext.reset();
      
      m_xcontext.getVarStack().reset();
      resetUserParameters();
      

      m_currentTemplateElements.removeAllElements();     
      m_currentMatchTemplates.removeAllElements();
      m_currentMatchedNodes.removeAllElements();
      
      m_serializationHandler = null;      
      m_outputTarget = null;
      m_keyManager = new KeyManager();
      m_attrSetStack = null;
      m_countersTable = null;
      m_currentTemplateRuleIsNull = new BoolStack();
      m_xmlSource = null;
      m_doc = DTM.NULL;
      m_isTransformDone = false;
      m_transformThread = null;

      
      
      m_xcontext.getSourceTreeManager().reset();
    }

    
  }

  
  public boolean getProperty(String property)
  {
    return false;
  }

  
  public void setProperty(String property, Object value)
  {
  }

  

  
  public boolean isParserEventsOnMain()
  {
    return m_parserEventsOnMain;
  }

  
  public Thread getTransformThread()
  {
    return m_transformThread;
  }

  
  public void setTransformThread(Thread t)
  {
    m_transformThread = t;
  }

  
  private boolean m_hasTransformThreadErrorCatcher = false;

  
  public boolean hasTransformThreadErrorCatcher()
  {
    return m_hasTransformThreadErrorCatcher;
  }
        
        
  public void transform(Source source) throws TransformerException
  {
                transform(source, true); 
        }

  
  public void transform(Source source, boolean shouldRelease) throws TransformerException
  {

    try
    {
        
      
      
      
      
      if(getXPathContext().getNamespaceContext() == null){
         getXPathContext().setNamespaceContext(getStylesheet());
      }
      String base = source.getSystemId();
      
      
      if(null == base)
      {
        base = m_stylesheetRoot.getBaseIdentifier();
      }

      
      if(null == base)
      {
        String currentDir = """";
        try {
          currentDir = System.getProperty(""user.dir"");
        }
        catch (SecurityException se) {}
              
        if (currentDir.startsWith(java.io.File.separator))
          base = ""file:
        else
          base = ""file:
        
        base = base + java.io.File.separatorChar
               + source.getClass().getName();
      }
      setBaseURLOfSource(base);
      DTMManager mgr = m_xcontext.getDTMManager();
      DTM dtm = mgr.getDTM(source, false, this, true, true);
      dtm.setDocumentBaseURI(base);
      
      boolean hardDelete = true;  

      try
      {
      	
      	
      	
        this.transformNode(dtm.getDocument());
      }
      finally
      {
        if (shouldRelease)
          mgr.release(dtm, hardDelete);
      }

      
      
      
      
      
      Exception e = getExceptionThrown();

      if (null != e)
      {
        if (e instanceof javax.xml.transform.TransformerException)
        {
          throw (javax.xml.transform.TransformerException) e;
        }
        else if (e instanceof org.apache.xml.utils.WrappedRuntimeException)
        {
          fatalError(
              ((org.apache.xml.utils.WrappedRuntimeException) e).getException());
        }
        else
        {
          throw new javax.xml.transform.TransformerException(e);
        }
      }
      else if (null != m_serializationHandler)
      {
        m_serializationHandler.endDocument();
      }
    }
    catch (org.apache.xml.utils.WrappedRuntimeException wre)
    {
      Throwable throwable = wre.getException();

      while (throwable
             instanceof org.apache.xml.utils.WrappedRuntimeException)
      {
        throwable =
          ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();
      }

      fatalError(throwable);
    }

    
    catch (org.xml.sax.SAXParseException spe)
    {
      fatalError(spe);
    }
    catch (org.xml.sax.SAXException se)
    {
      m_errorHandler.fatalError(new TransformerException(se));
    }
    finally
    {
      m_hasTransformThreadErrorCatcher = false;

      
      reset();
    }
  }
  
  private void fatalError(Throwable throwable) throws TransformerException
  {
    if (throwable instanceof org.xml.sax.SAXParseException)
      m_errorHandler.fatalError(new TransformerException(throwable.getMessage(),new SAXSourceLocator((org.xml.sax.SAXParseException)throwable)));
    else
      m_errorHandler.fatalError(new TransformerException(throwable));
    
  }

  
  public String getBaseURLOfSource()
  {
    return m_urlOfSource;
  }

  
  public void setBaseURLOfSource(String base)
  {
    m_urlOfSource = base;
  }

  
  public Result getOutputTarget()
  {
    return m_outputTarget;
  }

  
  public void setOutputTarget(Result outputTarget)
  {
    m_outputTarget = outputTarget;
  }

  
  public String getOutputProperty(String qnameString)
          throws IllegalArgumentException
  {

    String value = null;
    OutputProperties props = getOutputFormat();

    value = props.getProperty(qnameString);

    if (null == value)
    {
      if (!props.isLegalPropertyKey(qnameString))
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{qnameString})); 
                                           
    }

    return value;
  }

  
  public String getOutputPropertyNoDefault(String qnameString)
          throws IllegalArgumentException
  {

    String value = null;
    OutputProperties props = getOutputFormat();

    value = (String) props.getProperties().get(qnameString);

    if (null == value)
    {
      if (!props.isLegalPropertyKey(qnameString))
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{qnameString})); 
                                          
    }

    return value;
  }

  
  public void setOutputProperty(String name, String value)
          throws IllegalArgumentException
  {

    synchronized (m_reentryGuard)
    {

      
      
      if (null == m_outputFormat)
      {
        m_outputFormat =
          (OutputProperties) getStylesheet().getOutputComposed().clone();
      }

      if (!m_outputFormat.isLegalPropertyKey(name))
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{name})); 
                                           

      m_outputFormat.setProperty(name, value);
    }
  }

  
  public void setOutputProperties(Properties oformat)
  		throws IllegalArgumentException
  {

    synchronized (m_reentryGuard)
    {
      if (null != oformat)
      {

        
        String method = (String) oformat.get(OutputKeys.METHOD);

        if (null != method)
          m_outputFormat = new OutputProperties(method);
        else if(m_outputFormat==null)
          m_outputFormat = new OutputProperties();
      }

      if (null != oformat)
      {
        m_outputFormat.copyFrom(oformat);
      }

      
      
      
      m_outputFormat.copyFrom(m_stylesheetRoot.getOutputProperties());
    }
  }

  
  public Properties getOutputProperties()
  {
    return (Properties) getOutputFormat().getProperties().clone();
  }

    
    public SerializationHandler createSerializationHandler(Result outputTarget)
            throws TransformerException
    {
       SerializationHandler xoh =
        createSerializationHandler(outputTarget, getOutputFormat());
       return xoh;
    }

    
    public SerializationHandler createSerializationHandler(
            Result outputTarget, OutputProperties format)
              throws TransformerException
    {

      SerializationHandler xoh;

      
      
      org.w3c.dom.Node outputNode = null;

      if (outputTarget instanceof DOMResult)
      {
        outputNode = ((DOMResult) outputTarget).getNode();

        org.w3c.dom.Document doc;
        short type;

        if (null != outputNode)
        {
          type = outputNode.getNodeType();
          doc = (org.w3c.dom.Node.DOCUMENT_NODE == type)
                ? (org.w3c.dom.Document) outputNode
                : outputNode.getOwnerDocument();
        }
        else
        {
          doc = org.apache.xml.utils.DOMHelper.createDocument();
          outputNode = doc;
          type = outputNode.getNodeType();

          ((DOMResult) outputTarget).setNode(outputNode);
        }

        ContentHandler handler =
          (org.w3c.dom.Node.DOCUMENT_FRAGMENT_NODE == type)
          ? new DOMBuilder(doc, (org.w3c.dom.DocumentFragment) outputNode)
          : new DOMBuilder(doc, outputNode);
          String encoding = format.getProperty(OutputKeys.ENCODING);          
          xoh = new ToXMLSAXHandler(handler, (LexicalHandler)handler, encoding);
      }
      else if (outputTarget instanceof SAXResult)
      {
        ContentHandler handler = ((SAXResult) outputTarget).getHandler();
        
        if (null == handler)
           throw new IllegalArgumentException(
             ""handler can not be null for a SAXResult""); 
             
        LexicalHandler lexHandler;
        if (handler instanceof LexicalHandler)     
            lexHandler = (LexicalHandler)  handler;
        else
            lexHandler = null;
            
        String encoding = format.getProperty(OutputKeys.ENCODING); 
        String method = format.getProperty(OutputKeys.METHOD);
        if (org.apache.xml.serializer.Method.HTML.equals(method))
        {
            xoh = new ToHTMLSAXHandler(handler, lexHandler, encoding);
        }
        else if (org.apache.xml.serializer.Method.TEXT.equals(method))
        {
            xoh = new ToTextSAXHandler(handler, lexHandler, encoding);
        } 
        else 
        {
            xoh = new ToXMLSAXHandler(handler, lexHandler, encoding);    
        }       
        
        if (handler instanceof TransformerClient) {
            XalanTransformState state = new XalanTransformState();
            ((TransformerClient)handler).setTransformState(state);
            ((ToSAXHandler)xoh).setTransformState(state);
        }

 
      }

      
      
      else if (outputTarget instanceof StreamResult)
      {
        StreamResult sresult = (StreamResult) outputTarget;
        String method = format.getProperty(OutputKeys.METHOD);

        try
        {
          SerializationHandler serializer =
            (SerializationHandler) SerializerFactory.getSerializer(format.getProperties());

          if (null != sresult.getWriter())
            serializer.setWriter(sresult.getWriter());
          else if (null != sresult.getOutputStream())
            serializer.setOutputStream(sresult.getOutputStream());
          else if (null != sresult.getSystemId())
          {
            String fileURL = sresult.getSystemId();

            if (fileURL.startsWith(""file:
            {
              if (fileURL.substring(8).indexOf("":"") >0)
                fileURL = fileURL.substring(8);
              else
                fileURL = fileURL.substring(7);
            }

            m_outputStream = new java.io.FileOutputStream(fileURL);

            serializer.setOutputStream(m_outputStream);
            
            xoh = serializer;
          }
          else
            throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_OUTPUT_SPECIFIED, null)); 

          

        

          xoh = serializer;  
        }




        catch (IOException ioe)
        {
          throw new TransformerException(ioe);
        }
      }
      else
      {
        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_TO_RESULT_TYPE, new Object[]{outputTarget.getClass().getName()})); 
                                       
                                       
      }
      
      
      
      xoh.setTransformer(this);

      SourceLocator srcLocator = getStylesheet();
      xoh.setSourceLocator(srcLocator);
      
      
      return xoh;

   
    }
        
        
  public void transform(Source xmlSource, Result outputTarget)
          throws TransformerException
  {
                transform(xmlSource, outputTarget, true);
        }

  
  public void transform(Source xmlSource, Result outputTarget, boolean shouldRelease)
          throws TransformerException
  {

    synchronized (m_reentryGuard)
    {
      SerializationHandler xoh = createSerializationHandler(outputTarget);
      this.setSerializationHandler(xoh);        

      m_outputTarget = outputTarget;

      transform(xmlSource, shouldRelease);
    }
  }

  
  public void transformNode(int node, Result outputTarget)
          throws TransformerException
  {
    

    SerializationHandler xoh = createSerializationHandler(outputTarget);
    this.setSerializationHandler(xoh);

    m_outputTarget = outputTarget;

    transformNode(node);
  }

  
  public void transformNode(int node) throws TransformerException
  {
    
    setExtensionsTable(getStylesheet());
    
    synchronized (m_serializationHandler)
    {
      m_hasBeenReset = false;
      
      XPathContext xctxt = getXPathContext();
      DTM dtm = xctxt.getDTM(node);

      try
      {
        pushGlobalVars(node);

        
        
        
        StylesheetRoot stylesheet = this.getStylesheet();
        int n = stylesheet.getGlobalImportCount();

        for (int i = 0; i < n; i++)
        {
          StylesheetComposed imported = stylesheet.getGlobalImport(i);
          int includedCount = imported.getIncludeCountComposed();

          for (int j = -1; j < includedCount; j++)
          {
            Stylesheet included = imported.getIncludeComposed(j);

            included.runtimeInit(this);

            for (ElemTemplateElement child = included.getFirstChildElem();
                    child != null; child = child.getNextSiblingElem())
            {
              child.runtimeInit(this);
            }
          }
        }
        
        
        DTMIterator dtmIter = new org.apache.xpath.axes.SelfIteratorNoPredicate();
        dtmIter.setRoot(node, xctxt);
        xctxt.pushContextNodeList(dtmIter);
        try
        {
          this.applyTemplateToNode(null, null, node);
        }
        finally
        {
          xctxt.popContextNodeList();
        }
        

        
        if (null != m_serializationHandler)
        {
          m_serializationHandler.endDocument();
        }
      }
      catch (Exception se)
      {

        
        
        
        
        
        
        
        while(se instanceof org.apache.xml.utils.WrappedRuntimeException)
        {
          Exception e = ((org.apache.xml.utils.WrappedRuntimeException)se).getException();
          if(null != e)
            se = e;
        }
        
        if (null != m_serializationHandler)
        {
          try
          {
            if(se instanceof org.xml.sax.SAXParseException)
              m_serializationHandler.fatalError((org.xml.sax.SAXParseException)se);
            else if(se instanceof TransformerException)
            {
              TransformerException te = ((TransformerException)se);
              SAXSourceLocator sl = new SAXSourceLocator( te.getLocator() );
              m_serializationHandler.fatalError(new org.xml.sax.SAXParseException(te.getMessage(), sl, te)); 
            }
            else
            {
              m_serializationHandler.fatalError(new org.xml.sax.SAXParseException(se.getMessage(), new SAXSourceLocator(), se)); 
            }             
          }
          catch (Exception e){}
        }        
        
        if(se instanceof TransformerException)
        {
          m_errorHandler.fatalError((TransformerException)se);
        }
        else if(se instanceof org.xml.sax.SAXParseException)
        {
          m_errorHandler.fatalError(new TransformerException(se.getMessage(), 
                      new SAXSourceLocator((org.xml.sax.SAXParseException)se), 
                      se));
        }
        else
        {
          m_errorHandler.fatalError(new TransformerException(se));
        }
        
      }
      finally
      {
        this.reset();
      }
    }
  }

  
  public ContentHandler getInputContentHandler()
  {
    return getInputContentHandler(false);
  }

  
  public ContentHandler getInputContentHandler(boolean doDocFrag)
  {

    if (null == m_inputContentHandler)
    {

      
      
      m_inputContentHandler = new TransformerHandlerImpl(this, doDocFrag,
              m_urlOfSource);
    }

    return m_inputContentHandler;
  }

  
  public DeclHandler getInputDeclHandler()
  {

    if (m_inputContentHandler instanceof DeclHandler)
      return (DeclHandler) m_inputContentHandler;
    else
      return null;
  }

  
  public LexicalHandler getInputLexicalHandler()
  {

    if (m_inputContentHandler instanceof LexicalHandler)
      return (LexicalHandler) m_inputContentHandler;
    else
      return null;
  }

  
  public void setOutputFormat(OutputProperties oformat)
  {
    m_outputFormat = oformat;
  }

  
  public OutputProperties getOutputFormat()
  {

    
    
    OutputProperties format = (null == m_outputFormat)
                              ? getStylesheet().getOutputComposed()
                              : m_outputFormat;

    return format;
  }

  
  public void setParameter(String name, String namespace, Object value)
  {

    VariableStack varstack = getXPathContext().getVarStack();
    QName qname = new QName(namespace, name);
    XObject xobject = XObject.create(value, getXPathContext());
    
    StylesheetRoot sroot = m_stylesheetRoot;
    Vector vars = sroot.getVariablesAndParamsComposed();
    int i = vars.size();
    while (--i >= 0)
    {
      ElemVariable variable = (ElemVariable)vars.elementAt(i);
      if(variable.getXSLToken() == Constants.ELEMNAME_PARAMVARIABLE && 
         variable.getName().equals(qname))
      {
          varstack.setGlobalVariable(i, xobject);
      }
    }
  }

  
  Vector m_userParams;

  
  public void setParameter(String name, Object value)
  {

    StringTokenizer tokenizer = new StringTokenizer(name, ""{}"", false);

    try
    {

      
      
      String s1 = tokenizer.nextToken();
      String s2 = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;

      if (null == m_userParams)
        m_userParams = new Vector();

      if (null == s2)
      {
        replaceOrPushUserParam(new QName(s1), XObject.create(value, getXPathContext()));
        setParameter(s1, null, value);
      }
      else
      {
        replaceOrPushUserParam(new QName(s1, s2), XObject.create(value, getXPathContext()));
        setParameter(s2, s1, value);
      }
    }
    catch (java.util.NoSuchElementException nsee)
    {

      
    }
  }

  
  private void replaceOrPushUserParam(QName qname, XObject xval)
  {

    int n = m_userParams.size();

    for (int i = n - 1; i >= 0; i--)
    {
      Arg arg = (Arg) m_userParams.elementAt(i);

      if (arg.getQName().equals(qname))
      {
        m_userParams.setElementAt(new Arg(qname, xval, true), i);

        return;
      }
    }

    m_userParams.addElement(new Arg(qname, xval, true));
  }

  
  public Object getParameter(String name)
  {

    try
    {

      
      
      
      QName qname = QName.getQNameFromString(name);

      if (null == m_userParams)
        return null;

      int n = m_userParams.size();

      for (int i = n - 1; i >= 0; i--)
      {
        Arg arg = (Arg) m_userParams.elementAt(i);

        if (arg.getQName().equals(qname))
        {
          return arg.getVal().object();
        }
      }

      return null;
    }
    catch (java.util.NoSuchElementException nsee)
    {

      
      return null;
    }
  }
  
  
  private void resetUserParameters()
  {

    try
    {
      
      if (null == m_userParams)
        return;

      int n = m_userParams.size();
      for (int i = n - 1; i >= 0; i--)
      {
        Arg arg = (Arg) m_userParams.elementAt(i);
        QName name = arg.getQName();
        
        
        String s1 = name.getNamespace();
        String s2 = name.getLocalPart();

        setParameter(s2, s1, arg.getVal().object());
        
      }
      
    }
    catch (java.util.NoSuchElementException nsee)
    {
      
      
    }
  }

  
  public void setParameters(Properties params)
  {

    clearParameters();

    Enumeration names = params.propertyNames();

    while (names.hasMoreElements())
    {
      String name = params.getProperty((String) names.nextElement());
      StringTokenizer tokenizer = new StringTokenizer(name, ""{}"", false);

      try
      {

        
        
        String s1 = tokenizer.nextToken();
        String s2 = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;

        if (null == s2)
          setParameter(s1, null, params.getProperty(name));
        else
          setParameter(s2, s1, params.getProperty(name));
      }
      catch (java.util.NoSuchElementException nsee)
      {

        
      }
    }
  }

  
  public void clearParameters()
  {

    synchronized (m_reentryGuard)
    {
      VariableStack varstack = new VariableStack();

      m_xcontext.setVarStack(varstack);

      m_userParams = null;
    }
  }


  
  protected void pushGlobalVars(int contextNode) throws TransformerException
  {

    XPathContext xctxt = m_xcontext;
    VariableStack vs = xctxt.getVarStack();
    StylesheetRoot sr = getStylesheet();
    Vector vars = sr.getVariablesAndParamsComposed();
    
    int i = vars.size();
    vs.link(i);

    while (--i >= 0)
    {
      ElemVariable v = (ElemVariable) vars.elementAt(i);

      
      XObject xobj = new XUnresolvedVariable(v, contextNode, this,
                                     vs.getStackFrame(), 0, true);
      
      if(null == vs.elementAt(i))                               
        vs.setGlobalVariable(i, xobj);
    }

  }

  
  public void setURIResolver(URIResolver resolver)
  {

    synchronized (m_reentryGuard)
    {
      m_xcontext.getSourceTreeManager().setURIResolver(resolver);
    }
  }

  
  public URIResolver getURIResolver()
  {
    return m_xcontext.getSourceTreeManager().getURIResolver();
  }

  

  
  public void setContentHandler(ContentHandler handler)
  {

    if (handler == null)
    {
      throw new NullPointerException(XSLMessages.createMessage(XSLTErrorResources.ER_NULL_CONTENT_HANDLER, null)); 
    }
    else
    {
      m_outputContentHandler = handler;

      if (null == m_serializationHandler)
      {
        ToXMLSAXHandler h = new ToXMLSAXHandler();
        h.setContentHandler(handler);
        h.setTransformer(this);
        
        m_serializationHandler = h;
      }
      else
        m_serializationHandler.setContentHandler(handler);
    }
  }

  
  public ContentHandler getContentHandler()
  {
    return m_outputContentHandler;
  }

  
  public int transformToRTF(ElemTemplateElement templateParent)
          throws TransformerException
  {
    
    
    DTM dtmFrag = m_xcontext.getRTFDTM();
    return transformToRTF(templateParent,dtmFrag);
  }
  
  
  public int transformToGlobalRTF(ElemTemplateElement templateParent)
          throws TransformerException
  {
    
    
    DTM dtmFrag = m_xcontext.getGlobalRTFDTM();
    return transformToRTF(templateParent,dtmFrag);
  }
  
  
  private int transformToRTF(ElemTemplateElement templateParent,DTM dtmFrag)
          throws TransformerException
  {

    XPathContext xctxt = m_xcontext;
    
    ContentHandler rtfHandler = dtmFrag.getContentHandler();

    
    
    
    
    int resultFragment; 

    
    SerializationHandler savedRTreeHandler = this.m_serializationHandler;
 

    
    ToSAXHandler h = new ToXMLSAXHandler();
    h.setContentHandler(rtfHandler);
    h.setTransformer(this);
    
    
    m_serializationHandler = h;
 
    
    SerializationHandler rth = m_serializationHandler;

    try
    {
      rth.startDocument();
      
      
      
      
      rth.flushPending(); 
 
      try
      {

        
        executeChildTemplates(templateParent, true);

        
        rth.flushPending();
        
        
        
        
        
	resultFragment = dtmFrag.getDocument();      
      }
      finally
      {
        rth.endDocument();
      }
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {

      
      this.m_serializationHandler = savedRTreeHandler;
    }

    return resultFragment;
  }

  
  public ObjectPool getStringWriterPool()
  {
    return m_stringWriterObjectPool;
  }

  
  public String transformToString(ElemTemplateElement elem)
          throws TransformerException
  {
    ElemTemplateElement firstChild = elem.getFirstChildElem();
    if(null == firstChild)
      return """";
    if(elem.hasTextLitOnly() && org.apache.xalan.processor.TransformerFactoryImpl.m_optimize)
    {
      return ((ElemTextLiteral)firstChild).getNodeValue();
    }

    
    SerializationHandler savedRTreeHandler = this.m_serializationHandler;

    
    
    StringWriter sw = (StringWriter) m_stringWriterObjectPool.getInstance();

    m_serializationHandler =
        (ToTextStream) m_textResultHandlerObjectPool.getInstance();

      if (null == m_serializationHandler)
      {
        

        
        Serializer serializer = org.apache.xml.serializer.SerializerFactory.getSerializer(
            m_textformat.getProperties());
        m_serializationHandler = (SerializationHandler) serializer;
      } 

        m_serializationHandler.setTransformer(this);
        m_serializationHandler.setWriter(sw);
 
 
    String result;

    try
    {
        
      

      
      executeChildTemplates(elem, true);
        this.m_serializationHandler.endDocument();

      result = sw.toString();
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      sw.getBuffer().setLength(0);

      try
      {
        sw.close();
      }
      catch (Exception ioe){}

      m_stringWriterObjectPool.freeInstance(sw);
      m_serializationHandler.reset();
      m_textResultHandlerObjectPool.freeInstance(m_serializationHandler);

      
      m_serializationHandler = savedRTreeHandler;
    }

    return result;
  }

  
  public boolean applyTemplateToNode(ElemTemplateElement xslInstruction,  
                                     ElemTemplate template, int child)
                                             throws TransformerException
  {

    DTM dtm = m_xcontext.getDTM(child);
    short nodeType = dtm.getNodeType(child);
    boolean isDefaultTextRule = false;
    boolean isApplyImports = false;    

    if (null == template)
    {
      int maxImportLevel, endImportLevel=0;
      isApplyImports = ((xslInstruction == null)
                                ? false
                                : xslInstruction.getXSLToken()
                                  == Constants.ELEMNAME_APPLY_IMPORTS);

      if (isApplyImports)
      {
        maxImportLevel =
          xslInstruction.getStylesheetComposed().getImportCountComposed() - 1;
        endImportLevel =
          xslInstruction.getStylesheetComposed().getEndImportCountComposed();
      }
      else
      {
        maxImportLevel = -1;
      }

      
      
      
      
      
      
      if (isApplyImports && (maxImportLevel == -1))
      {
        template = null;
      }
      else
      {

        
        
        XPathContext xctxt = m_xcontext;

        try
        {
          xctxt.pushNamespaceContext(xslInstruction);

          QName mode = this.getMode();
          
          if (isApplyImports)
            template = m_stylesheetRoot.getTemplateComposed(xctxt, child, mode,
                  maxImportLevel, endImportLevel, m_quietConflictWarnings, dtm);
          else
            template = m_stylesheetRoot.getTemplateComposed(xctxt, child, mode,
                  m_quietConflictWarnings, dtm);
          
        }
        finally
        {
          xctxt.popNamespaceContext();
        }
      }

      
      
      if (null == template)
      {
        switch (nodeType)
        {
        case DTM.DOCUMENT_FRAGMENT_NODE :
        case DTM.ELEMENT_NODE :
          template = m_stylesheetRoot.getDefaultRule();
          break;
        case DTM.CDATA_SECTION_NODE :
        case DTM.TEXT_NODE :
        case DTM.ATTRIBUTE_NODE :
          template = m_stylesheetRoot.getDefaultTextRule();
          isDefaultTextRule = true;
          break;
        case DTM.DOCUMENT_NODE :
          template = m_stylesheetRoot.getDefaultRootRule();
          break;
        default :

          
          return false;
        }
      }
    }

    
    
    try
    {
      pushElemTemplateElement(template);
      m_xcontext.pushCurrentNode(child);
      pushPairCurrentMatched(template, child);
      
      
      if (!isApplyImports) {
          DTMIterator cnl = new org.apache.xpath.NodeSetDTM(child, m_xcontext.getDTMManager());
          m_xcontext.pushContextNodeList(cnl);
      }

      if (isDefaultTextRule)
      {
        switch (nodeType)
        {
        case DTM.CDATA_SECTION_NODE :
        case DTM.TEXT_NODE :
          ClonerToResultTree.cloneToResultTree(child, nodeType, 
                                        dtm, getResultTreeHandler(), false);
          break;
        case DTM.ATTRIBUTE_NODE :
          dtm.dispatchCharactersEvents(child, getResultTreeHandler(), false);
          break;
        }
      }
      else
      {

        
         
        if (TransformerImpl.S_DEBUG)
          getTraceManager().fireTraceEvent(template);
        
        
        
        
        
        
        
        
        
        m_xcontext.setSAXLocator(template);
        
        m_xcontext.getVarStack().link(template.m_frameSize);
        executeChildTemplates(template, true);
        
        if (TransformerImpl.S_DEBUG)
          getTraceManager().fireTraceEndEvent(template);
      }
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      m_xcontext.getVarStack().unlink();
      m_xcontext.popCurrentNode();
      if (!isApplyImports) {
          m_xcontext.popContextNodeList();
          popCurrentMatched();
      }
      popElemTemplateElement();
    }

    return true;
  }
  
  
  
  public void executeChildTemplates(
          ElemTemplateElement elem, org.w3c.dom.Node context, QName mode, ContentHandler handler)
            throws TransformerException
  {

    XPathContext xctxt = m_xcontext;

    try
    {
      if(null != mode)
        pushMode(mode);
      xctxt.pushCurrentNode(xctxt.getDTMHandleFromNode(context));
      executeChildTemplates(elem, handler);
    }
    finally
    {
      xctxt.popCurrentNode();
      
      
      
      if (null != mode)
        popMode();
    }
  }

  
  public void executeChildTemplates(
          ElemTemplateElement elem, boolean shouldAddAttrs)
            throws TransformerException
  {

    
    ElemTemplateElement t = elem.getFirstChildElem();

    if (null == t)
      return;      
    
    if(elem.hasTextLitOnly() && org.apache.xalan.processor.TransformerFactoryImpl.m_optimize)
    {      
      char[] chars = ((ElemTextLiteral)t).getChars();
      try
      {
        
        this.pushElemTemplateElement(t);
        m_serializationHandler.characters(chars, 0, chars.length);
      }
      catch(SAXException se)
      {
        throw new TransformerException(se);
      }
      finally
      {
        this.popElemTemplateElement();
      }
      return;
    }







    XPathContext xctxt = m_xcontext;
    xctxt.pushSAXLocatorNull();
    int currentTemplateElementsTop = m_currentTemplateElements.size();
    m_currentTemplateElements.push(null);

    try
    {
      
      
      for (; t != null; t = t.getNextSiblingElem())
      {
        if (!shouldAddAttrs
                && t.getXSLToken() == Constants.ELEMNAME_ATTRIBUTE)
          continue;

        xctxt.setSAXLocator(t);
        m_currentTemplateElements.setElementAt(t,currentTemplateElementsTop);
        t.execute(this);
      }
    }
    catch(RuntimeException re)
    {
    	TransformerException te = new TransformerException(re);
    	te.setLocator(t);
    	throw te;
    }
    finally
    {
      m_currentTemplateElements.pop();
      xctxt.popSAXLocator();
    }

    


  }
    
     public void executeChildTemplates(
             ElemTemplateElement elem, ContentHandler handler)
               throws TransformerException
     {

       SerializationHandler xoh = this.getSerializationHandler();

       
       
       
       SerializationHandler savedHandler = xoh;

       try
       {
         xoh.flushPending();

         
         LexicalHandler lex = null;
         if (handler instanceof LexicalHandler) {
            lex = (LexicalHandler) lex;
         }
         m_serializationHandler = new ToXMLSAXHandler(handler, lex, savedHandler.getEncoding());
         executeChildTemplates(elem, true);
       }
       catch (TransformerException e)
       {
         throw e;
       }
       finally
       {
         m_serializationHandler = savedHandler;
    }
  }

  
  public Vector processSortKeys(ElemForEach foreach, int sourceNodeContext)
          throws TransformerException
  {

    Vector keys = null;
    XPathContext xctxt = m_xcontext;
    int nElems = foreach.getSortElemCount();

    if (nElems > 0)
      keys = new Vector();

    
    for (int i = 0; i < nElems; i++)
    {
      ElemSort sort = foreach.getSortElem(i);
      
      if (TransformerImpl.S_DEBUG)
        getTraceManager().fireTraceEvent(sort);
     
      String langString =
        (null != sort.getLang())
        ? sort.getLang().evaluate(xctxt, sourceNodeContext, foreach) : null;
      String dataTypeString = sort.getDataType().evaluate(xctxt,
                                sourceNodeContext, foreach);

      if (dataTypeString.indexOf("":"") >= 0)
        System.out.println(
          ""TODO: Need to write the hooks for QNAME sort data type"");
      else if (!(dataTypeString.equalsIgnoreCase(Constants.ATTRVAL_DATATYPE_TEXT))
               &&!(dataTypeString.equalsIgnoreCase(
                 Constants.ATTRVAL_DATATYPE_NUMBER)))
        foreach.error(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE,
                      new Object[]{ Constants.ATTRNAME_DATATYPE,
                                    dataTypeString });

      boolean treatAsNumbers =
        ((null != dataTypeString) && dataTypeString.equals(
        Constants.ATTRVAL_DATATYPE_NUMBER)) ? true : false;
      String orderString = sort.getOrder().evaluate(xctxt, sourceNodeContext,
                             foreach);

      if (!(orderString.equalsIgnoreCase(Constants.ATTRVAL_ORDER_ASCENDING))
              &&!(orderString.equalsIgnoreCase(
                Constants.ATTRVAL_ORDER_DESCENDING)))
        foreach.error(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE,
                      new Object[]{ Constants.ATTRNAME_ORDER,
                                    orderString });

      boolean descending =
        ((null != orderString) && orderString.equals(
        Constants.ATTRVAL_ORDER_DESCENDING)) ? true : false;
      AVT caseOrder = sort.getCaseOrder();
      boolean caseOrderUpper;

      if (null != caseOrder)
      {
        String caseOrderString = caseOrder.evaluate(xctxt, sourceNodeContext,
                                                    foreach);

        if (!(caseOrderString.equalsIgnoreCase(Constants.ATTRVAL_CASEORDER_UPPER))
                &&!(caseOrderString.equalsIgnoreCase(
                  Constants.ATTRVAL_CASEORDER_LOWER)))
          foreach.error(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE,
                        new Object[]{ Constants.ATTRNAME_CASEORDER,
                                      caseOrderString });

        caseOrderUpper =
          ((null != caseOrderString) && caseOrderString.equals(
          Constants.ATTRVAL_CASEORDER_UPPER)) ? true : false;
      }
      else
      {
        caseOrderUpper = false;
      }

      keys.addElement(new NodeSortKey(this, sort.getSelect(), treatAsNumbers,
                                      descending, langString, caseOrderUpper,
                                      foreach));
      if (TransformerImpl.S_DEBUG)
        getTraceManager().fireTraceEndEvent(sort);
     }

    return keys;
  }

  
  
  
  
  
  public Vector getElementCallstack()
  {
  	Vector elems = new Vector();
  	int nStackSize = m_currentTemplateElements.size();
  	for(int i = 0; i < nStackSize; i++)
  	{
  		ElemTemplateElement elem = (ElemTemplateElement) m_currentTemplateElements.elementAt(i);
  		if(null != elem)
  		{
  			elems.addElement(elem);
  		}
  	}
  	return elems;
  }
  
  
  public int getCurrentTemplateElementsCount()
  {
  	return m_currentTemplateElements.size();
  }
  
  
  
  public ObjectStack getCurrentTemplateElements()
  {
  	return m_currentTemplateElements;
  }

  
  public void pushElemTemplateElement(ElemTemplateElement elem)
  {
    m_currentTemplateElements.push(elem);
  }

  
  public void popElemTemplateElement()
  {
    m_currentTemplateElements.pop();
  }

  
  public void setCurrentElement(ElemTemplateElement e)
  {
    m_currentTemplateElements.setTop(e);
  }

  
  public ElemTemplateElement getCurrentElement()
  {
    return (m_currentTemplateElements.size() > 0) ? 
        (ElemTemplateElement) m_currentTemplateElements.peek() : null;
  }

  
  public int getCurrentNode()
  {
    return m_xcontext.getCurrentNode();
  }
  
  
  public Vector getTemplateCallstack()
  {
  	Vector elems = new Vector();
  	int nStackSize = m_currentTemplateElements.size();
  	for(int i = 0; i < nStackSize; i++)
  	{
  		ElemTemplateElement elem = (ElemTemplateElement) m_currentTemplateElements.elementAt(i);
  		if(null != elem && (elem.getXSLToken() != Constants.ELEMNAME_TEMPLATE))
  		{
  			elems.addElement(elem);
  		}
  	}
  	return elems;
  }


  
  public ElemTemplate getCurrentTemplate()
  {

    ElemTemplateElement elem = getCurrentElement();

    while ((null != elem)
           && (elem.getXSLToken() != Constants.ELEMNAME_TEMPLATE))
    {
      elem = elem.getParentElem();
    }

    return (ElemTemplate) elem;
  }

  
  public void pushPairCurrentMatched(ElemTemplateElement template, int child)
  {
    m_currentMatchTemplates.push(template);
    m_currentMatchedNodes.push(child);
  }

  
  public void popCurrentMatched()
  {
    m_currentMatchTemplates.pop();
    m_currentMatchedNodes.pop();
  }

  
  public ElemTemplate getMatchedTemplate()
  {
    return (ElemTemplate) m_currentMatchTemplates.peek();
  }

  
  public int getMatchedNode()
  {
    return m_currentMatchedNodes.peepTail();
  }

  
  public DTMIterator getContextNodeList()
  {

    try
    {
      DTMIterator cnl = m_xcontext.getContextNodeList();

      return (cnl == null) ? null : (DTMIterator) cnl.cloneWithReset();
    }
    catch (CloneNotSupportedException cnse)
    {

      
      return null;
    }
  }

  
  public Transformer getTransformer()
  {
    return this;
  }

  
  
  

  
  public void setStylesheet(StylesheetRoot stylesheetRoot)
  {
    m_stylesheetRoot = stylesheetRoot;
  }

  
  public final StylesheetRoot getStylesheet()
  {
    return m_stylesheetRoot;
  }

  
  public boolean getQuietConflictWarnings()
  {
    return m_quietConflictWarnings;
  }

  
  public void setQuietConflictWarnings(boolean b)
  {
    m_quietConflictWarnings = b;
  }

  
  public void setXPathContext(XPathContext xcontext)
  {
    m_xcontext = xcontext;
  }

  
  public final XPathContext getXPathContext()
  {
    return m_xcontext;
  }

  
  public StackGuard getStackGuard()
  {
    return m_stackGuard;
  }

  
  public int getRecursionLimit()
  {
    return m_stackGuard.getRecursionLimit();
  }

  
  public void setRecursionLimit(int limit)
  {
    m_stackGuard.setRecursionLimit(limit);
  }

  
  public SerializationHandler getResultTreeHandler()
  {
    return m_serializationHandler;
  }

  
  public SerializationHandler getSerializationHandler()
  {
    return m_serializationHandler;
  }
  
  
  public KeyManager getKeyManager()
  {
    return m_keyManager;
  }

  
  public boolean isRecursiveAttrSet(ElemAttributeSet attrSet)
  {

    if (null == m_attrSetStack)
    {
      m_attrSetStack = new Stack();
    }

    if (!m_attrSetStack.empty())
    {
      int loc = m_attrSetStack.search(attrSet);

      if (loc > -1)
      {
        return true;
      }
    }

    return false;
  }

  
  public void pushElemAttributeSet(ElemAttributeSet attrSet)
  {
    m_attrSetStack.push(attrSet);
  }

  
  public void popElemAttributeSet()
  {
    m_attrSetStack.pop();
  }

  
  public CountersTable getCountersTable()
  {

    if (null == m_countersTable)
      m_countersTable = new CountersTable();

    return m_countersTable;
  }

  
  public boolean currentTemplateRuleIsNull()
  {
    return ((!m_currentTemplateRuleIsNull.isEmpty())
            && (m_currentTemplateRuleIsNull.peek() == true));
  }

  
  public void pushCurrentTemplateRuleIsNull(boolean b)
  {
    m_currentTemplateRuleIsNull.push(b);
  }

  
  public void popCurrentTemplateRuleIsNull()
  {
    m_currentTemplateRuleIsNull.pop();
  }

  
  public MsgMgr getMsgMgr()
  {

    if (null == m_msgMgr)
      m_msgMgr = new MsgMgr(this);

    return m_msgMgr;
  }

  
  public void setErrorListener(ErrorListener listener)
          throws IllegalArgumentException
  {

    synchronized (m_reentryGuard)
    {
      if (listener == null)
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NULL_ERROR_HANDLER, null)); 

      m_errorHandler = listener;
    }
  }

  
  public ErrorListener getErrorListener()
  {
    return m_errorHandler;
  }

  
  public TraceManager getTraceManager()
  {
    return m_traceManager;
  }

  
  public boolean getFeature(String name)
          throws SAXNotRecognizedException, SAXNotSupportedException
  {

    if (""http:
      return true;
    else if (""http:
      return true;

    throw new SAXNotRecognizedException(name);
  }

  

  
  public QName getMode()
  {
    return m_modes.isEmpty() ? null : (QName) m_modes.peek();
  }

  

  
  public void pushMode(QName mode)
  {
    m_modes.push(mode);
  }

  

  
  public void popMode()
  {
    m_modes.pop();
  }

  
  public void runTransformThread(int priority)
  {

    
    Thread t = ThreadControllerWrapper.runThread(this, priority);
    this.setTransformThread(t);
  }

  
  public void runTransformThread()
  {
    ThreadControllerWrapper.runThread(this, -1);
  }
  
  
  public static void runTransformThread(Runnable runnable)
  {
    ThreadControllerWrapper.runThread(runnable, -1);
  }

  
  public void waitTransformThread() throws SAXException
  {

    
    
    
    
    
    Thread transformThread = this.getTransformThread();

    if (null != transformThread)
    {
      try
      {
        ThreadControllerWrapper.waitThread(transformThread, this);

        if (!this.hasTransformThreadErrorCatcher())
        {
          Exception e = this.getExceptionThrown();

          if (null != e)
          {
            e.printStackTrace();
            throw new org.xml.sax.SAXException(e);
          }
        }

        this.setTransformThread(null);
      }
      catch (InterruptedException ie){}
    }
  }

  
  public Exception getExceptionThrown()
  {
    return m_exceptionThrown;
  }

  
  public void setExceptionThrown(Exception e)
  {
    m_exceptionThrown = e;
  }

  
  public void setSourceTreeDocForThread(int doc)
  {
    m_doc = doc;
  }

  
  public void setXMLSource(Source source)
  {
    m_xmlSource = source;
  }

  
  public boolean isTransformDone()
  {

    synchronized (this)
    {
      return m_isTransformDone;
    }
  }

  
  public void setIsTransformDone(boolean done)
  {

    synchronized (this)
    {
      m_isTransformDone = done;
    }
  }

  
  void postExceptionFromThread(Exception e)
  {

    
    
    
    
    
    
    
    
    
    
    
    
    
 

    
    
    
    
    
    m_isTransformDone = true;
    m_exceptionThrown = e;
    ;  

    synchronized (this)
    {

      
      
      
      
      notifyAll();

      
      
      
      
      
      
      
    }
  }

  
  public void run()
  {

    m_hasBeenReset = false;

    try
    {

      
      
      try
      {
        m_isTransformDone = false;
        
        






        transformNode(m_doc);
        
      }
      catch (Exception e)
      {
        

        
        if (null != m_transformThread)
          postExceptionFromThread(e);   
        else 
          throw new RuntimeException(e.getMessage());
      }
      finally
      {
        m_isTransformDone = true;

        if (m_inputContentHandler instanceof TransformerHandlerImpl)
        {
          ((TransformerHandlerImpl) m_inputContentHandler).clearCoRoutine();
        }

        
        
        
        
      }
    }
    catch (Exception e)
    {

      
      if (null != m_transformThread)
        postExceptionFromThread(e);
      else 
        throw new RuntimeException(e.getMessage());         
    }
  }

  

  
  public TransformSnapshot getSnapshot()
  {
    return new TransformSnapshotImpl(this);
  }

  
  public void executeFromSnapshot(TransformSnapshot ts)
          throws TransformerException
  {

    ElemTemplateElement template = getMatchedTemplate();
    int child = getMatchedNode();

    pushElemTemplateElement(template);  
    m_xcontext.pushCurrentNode(child);  
    this.executeChildTemplates(template, true);  
  }

  
  public void resetToStylesheet(TransformSnapshot ts)
  {
    ((TransformSnapshotImpl) ts).apply(this);
  }

  
  public void stopTransformation(){}

  
  public short getShouldStripSpace(int elementHandle, DTM dtm)
  {

    try
    {
      org.apache.xalan.templates.WhiteSpaceInfo info =
        m_stylesheetRoot.getWhiteSpaceInfo(m_xcontext, elementHandle, dtm);

      if (null == info)
      {
        return DTMWSFilter.INHERIT;
      }
      else
      {

        
        return info.getShouldStripSpace()
               ? DTMWSFilter.STRIP : DTMWSFilter.NOTSTRIP;
      }
    }
    catch (TransformerException se)
    {
      return DTMWSFilter.INHERIT;
    }
  }
  
   public void init(ToXMLSAXHandler h,Transformer transformer, ContentHandler realHandler)
   {
      h.setTransformer(transformer);
      h.setContentHandler(realHandler);
   }
      
   public void setSerializationHandler(SerializationHandler xoh)
   {
      m_serializationHandler = xoh;
   }
   
   
     
	
	public void fireGenerateEvent(
		int eventType,
		char[] ch,
		int start,
		int length) {
			
		GenerateEvent ge = new GenerateEvent(this, eventType, ch, start, length);
		m_traceManager.fireGenerateEvent(ge);					
	}

	
	public void fireGenerateEvent(
		int eventType,
		String name,
		Attributes atts) {
			
		GenerateEvent ge = new GenerateEvent(this, eventType, name, atts);
		m_traceManager.fireGenerateEvent(ge);					
	}

	
	public void fireGenerateEvent(int eventType, String name, String data) {
		GenerateEvent ge = new GenerateEvent(this, eventType, name,data);
		m_traceManager.fireGenerateEvent(ge);				
	}

	
	public void fireGenerateEvent(int eventType, String data) {
		GenerateEvent ge = new GenerateEvent(this, eventType, data);
		m_traceManager.fireGenerateEvent(ge);		
	}

	
	public void fireGenerateEvent(int eventType) {
		GenerateEvent ge = new GenerateEvent(this, eventType);
		m_traceManager.fireGenerateEvent(ge);
	}

	
	public boolean hasTraceListeners() {
		return m_traceManager.hasTraceListeners();
	}

}  

"
org.apache.xalan.xsltc.compiler.LocationPathPattern,13,4,3,13,19,64,5,8,13,0.854166667,107,1.0,1,0.878787879,0.230769231,2,3,6.923076923,6,1.4615,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.dom.Axis;

public abstract class LocationPathPattern extends Pattern {
    private Template _template;
    private int _importPrecedence;
    private double _priority = Double.NaN;
    private int _position = 0;

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;		
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }
	
    public void setTemplate(final Template template) {
	_template = template;
	_priority = template.getPriority();
	_importPrecedence = template.getImportPrecedence();
	_position = template.getPosition();
    }
		
    public Template getTemplate() {
	return _template;
    }
		
    public final double getPriority() {
	return Double.isNaN(_priority) ? getDefaultPriority() : _priority;
    }
		
    public double getDefaultPriority() {
	return 0.5;
    }

    
    public boolean noSmallerThan(LocationPathPattern other) {
	if (_importPrecedence > other._importPrecedence) {
	    return true;
	}
	else if (_importPrecedence == other._importPrecedence) {
	    if (_priority > other._priority) {
		return true;
	    }
	    else if (_priority == other._priority) {
		if (_position > other._position) {
		    return true;
		}
	    }
	}
	return false;
    }
    
    public abstract StepPattern getKernelPattern();
	
    public abstract void reduceKernelPattern();
		
    public abstract boolean isWildcard();

    public int getAxis() {
	final StepPattern sp = getKernelPattern();
	return (sp != null) ? sp.getAxis() : Axis.CHILD;
    }

    public String toString() {
	return ""root()"";
    }
}
"
org.apache.xalan.xsltc.trax.TemplatesHandlerImpl,17,1,0,9,61,0,1,9,16,0.75,283,1.0,2,0.0,0.22875817,0,0,15.35294118,8,1.3529,1,"

package org.apache.xalan.xsltc.trax;

import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.sax.TemplatesHandler;

import org.apache.xalan.xsltc.compiler.CompilerException;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.SourceLoader;
import org.apache.xalan.xsltc.compiler.Stylesheet;
import org.apache.xalan.xsltc.compiler.SyntaxTreeNode;
import org.apache.xalan.xsltc.compiler.XSLTC;

import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.Attributes;


public class TemplatesHandlerImpl
    implements ContentHandler, TemplatesHandler, SourceLoader
{
    
    private String _systemId;

    
    private int _indentNumber;

    
    private URIResolver _uriResolver = null;

    
    private TransformerFactoryImpl _tfactory = null;

    
    private Parser _parser = null;

    
    protected TemplatesHandlerImpl(int indentNumber,
	TransformerFactoryImpl tfactory)
    {
	_indentNumber = indentNumber;
	_tfactory = tfactory;

        
        XSLTC xsltc = new XSLTC();
        xsltc.init();
        xsltc.setOutputType(XSLTC.BYTEARRAY_OUTPUT);
        _parser = xsltc.getParser();
    }

    
    public String getSystemId() {
	return _systemId;
    }

    
    public void setSystemId(String id) {
	_systemId = id;
    }

    
    public void setURIResolver(URIResolver resolver) {
	_uriResolver = resolver;
    }

    
    public Templates getTemplates() {
	try {
	    XSLTC xsltc = _parser.getXSLTC();

	    
	    if (_uriResolver != null) {
		xsltc.setSourceLoader(this);
	    }

	    
	    String transletName = null;
	    if (_systemId != null) {
		transletName = Util.baseName(_systemId);
	    }
	    else {
	    	transletName = (String)_tfactory.getAttribute(""translet-name"");
	    }
	    xsltc.setClassName(transletName);

	    
	    transletName = xsltc.getClassName();

	    Stylesheet stylesheet = null;
	    SyntaxTreeNode root = _parser.getDocumentRoot();

	    
	    if (!_parser.errorsFound() && root != null) {
		
		stylesheet = _parser.makeStylesheet(root);
		stylesheet.setSystemId(_systemId);
		stylesheet.setParentStylesheet(null);
		_parser.setCurrentStylesheet(stylesheet);

		
		xsltc.setStylesheet(stylesheet);

		
		_parser.createAST(stylesheet);
	    }

	    
	    if (!_parser.errorsFound() && stylesheet != null) {
		stylesheet.setMultiDocument(xsltc.isMultiDocument());
		stylesheet.setHasIdCall(xsltc.hasIdCall());

                
                synchronized (xsltc.getClass()) {
                    stylesheet.translate();
                }
	    }

	    if (!_parser.errorsFound()) {
		
		final byte[][] bytecodes = xsltc.getBytecodes();
		if (bytecodes != null) {
		    final TemplatesImpl templates =
			new TemplatesImpl(xsltc.getBytecodes(), transletName,
			    _parser.getOutputProperties(), _indentNumber, _tfactory);

		    
		    if (_uriResolver != null) {
			templates.setURIResolver(_uriResolver);
		    }
		    return templates;
		}
	    }
	}
	catch (CompilerException e) {
	    
	}
	return null;
    }

    
    public InputSource loadSource(String href, String context, XSLTC xsltc) {
	try {
	    
	    final Source source = _uriResolver.resolve(href, context);
	    if (source != null) {
		return Util.getInputSource(xsltc, source);
	    }
	}
	catch (TransformerException e) {
	    
	}
	return null;
    }

    
    
    
    public void startDocument() {
        _parser.init();
        _parser.startDocument();
    }

    
    public void endDocument() { 
        _parser.endDocument();
    }

    
    public void startPrefixMapping(String prefix, String uri) {
        _parser.startPrefixMapping(prefix, uri);
    }

    
    public void endPrefixMapping(String prefix) { 
        _parser.endPrefixMapping(prefix);
    }

    
    public void startElement(String uri, String localname, String qname, 
        Attributes attributes) throws SAXException 
    {
        _parser.startElement(uri, localname, qname, attributes);
    }
    
    
    public void endElement(String uri, String localname, String qname) {
        _parser.endElement(uri, localname, qname);
    }

    
    public void characters(char[] ch, int start, int length) {
        _parser.characters(ch, start, length);
    }
    
    
    public void processingInstruction(String name, String value) {
        _parser.processingInstruction(name, value);
    }
    
    
    public void ignorableWhitespace(char[] ch, int start, int length) { 
        _parser.ignorableWhitespace(ch, start, length);
    }

    
    public void skippedEntity(String name) { 
        _parser.skippedEntity(name);
    }

    
    public void setDocumentLocator(Locator locator) {
        setSystemId(locator.getSystemId());
        _parser.setDocumentLocator(locator);
    }
}


"
org.apache.xalan.templates.ElemTemplate,22,3,2,27,46,189,22,11,22,0.942857143,179,0.8,4,0.903225806,0.181818182,2,14,6.681818182,1,0.9545,1,"
package org.apache.xalan.templates;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;


public class ElemTemplate extends ElemTemplateElement
{
  
  private String m_publicId;

  
  private String m_systemId;

  
  public String getPublicId()
  {
    return m_publicId;
  }

  
  public String getSystemId()
  {
    return m_systemId;
  }

  
  public void setLocaterInfo(SourceLocator locator)
  {

    m_publicId = locator.getPublicId();
    m_systemId = locator.getSystemId();

    super.setLocaterInfo(locator);
  }

  
  private Stylesheet m_stylesheet;

  
  public StylesheetComposed getStylesheetComposed()
  {
    return m_stylesheet.getStylesheetComposed();
  }

  
  public Stylesheet getStylesheet()
  {
    return m_stylesheet;
  }

  
  public void setStylesheet(Stylesheet sheet)
  {
    m_stylesheet = sheet;
  }

  
  public StylesheetRoot getStylesheetRoot()
  {
    return m_stylesheet.getStylesheetRoot();
  }

  
  private XPath m_matchPattern = null;

  
  public void setMatch(XPath v)
  {
    m_matchPattern = v;
  }

  
  public XPath getMatch()
  {
    return m_matchPattern;
  }

  
  private QName m_name = null;

  
  public void setName(QName v)
  {
    m_name = v;
  }

  
  public QName getName()
  {
    return m_name;
  }

  
  private QName m_mode;

  
  public void setMode(QName v)
  {
    m_mode = v;
  }

  
  public QName getMode()
  {
    return m_mode;
  }

  
  private double m_priority = XPath.MATCH_SCORE_NONE;

  
  public void setPriority(double v)
  {
    m_priority = v;
  }

  
  public double getPriority()
  {
    return m_priority;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_TEMPLATE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_TEMPLATE_STRING;
  }
  
  
  public int m_frameSize;
  
  
  int m_inArgsSize;
  
  
  private int[] m_argsQNameIDs;
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_matchPattern)
      m_matchPattern.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
      
    cstate.resetStackFrameSize();
    m_inArgsSize = 0;
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    super.endCompose(sroot);
    m_frameSize = cstate.getFrameSize();
    
    cstate.resetStackFrameSize();
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    XPathContext xctxt = transformer.getXPathContext();
    
    transformer.getStackGuard().checkForInfinateLoop();
    
    xctxt.pushRTFContext();

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

      


      transformer.executeChildTemplates(this, true);










    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);

    xctxt.popRTFContext();  
    }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeTemplates(this);
  }

}
"
org.apache.xml.utils.ObjectPool,7,1,0,4,20,0,2,2,7,0.166666667,119,1.0,0,0.0,0.342857143,0,0,15.71428571,2,0.7143,1,"
package org.apache.xml.utils;

import java.util.Vector;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;



public class ObjectPool implements java.io.Serializable
{

  
  private final Class objectType;

  
  private final Vector freeStack;

  
  public ObjectPool(Class type)
  {
    objectType = type;
    freeStack = new Vector();
  }
  
  
  public ObjectPool(String className)
  {
    try
    {
      objectType = Class.forName(className);
    }
    catch(ClassNotFoundException cnfe)
    {
      throw new WrappedRuntimeException(cnfe);
    }
    freeStack = new Vector();
  }


  
  public ObjectPool(Class type, int size)
  {
    objectType = type;
    freeStack = new Vector(size);
  }

  
  public ObjectPool()
  {
    objectType = null;
    freeStack = new Vector();
  }

  
  public synchronized Object getInstanceIfFree()
  {

    
    if (!freeStack.isEmpty())
    {

      
      Object result = freeStack.lastElement();

      freeStack.setSize(freeStack.size() - 1);

      return result;
    }

    return null;
  }

  
  public synchronized Object getInstance()
  {

    
    if (freeStack.isEmpty())
    {

      
      try
      {
        return objectType.newInstance();
      }
      catch (InstantiationException ex){}
      catch (IllegalAccessException ex){}

      
      throw new RuntimeException(XMLMessages.createXMLMessage(XMLErrorResources.ER_EXCEPTION_CREATING_POOL, null)); 
    }
    else
    {

      
      Object result = freeStack.lastElement();

      freeStack.setSize(freeStack.size() - 1);

      return result;
    }
  }

  
  public synchronized void freeInstance(Object obj)
  {

    
    
    
    
    freeStack.addElement(obj);
    
    
    
    
    
  }
}
"
org.apache.xalan.lib.NodeInfo,9,1,0,3,20,36,0,3,9,2.0,204,0.0,0,0.0,0.333333333,0,0,21.66666667,4,2.6667,0,"

package org.apache.xalan.lib;

import javax.xml.transform.SourceLocator;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xml.dtm.ref.DTMNodeProxy;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public class NodeInfo
{
  
  public static String systemId(ExpressionContext context)
  {
    Node contextNode = context.getContextNode();
    int nodeHandler = ((DTMNodeProxy)contextNode).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)contextNode).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getSystemId();
    else
      return null;
  }

  
  public static String systemId(NodeList nodeList)
  {
    if (nodeList == null || nodeList.getLength() == 0)
      return null;
    
    Node node = nodeList.item(0);
    int nodeHandler = ((DTMNodeProxy)node).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)node).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getSystemId();
    else
      return null;
  }

  
  public static String publicId(ExpressionContext context)
  {
    Node contextNode = context.getContextNode();
    int nodeHandler = ((DTMNodeProxy)contextNode).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)contextNode).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getPublicId();
    else
      return null;
  }

  
  public static String publicId(NodeList nodeList)
  {
    if (nodeList == null || nodeList.getLength() == 0)
      return null;
    
    Node node = nodeList.item(0);
    int nodeHandler = ((DTMNodeProxy)node).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)node).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getPublicId();
    else
      return null;
  }

  
  public static int lineNumber(ExpressionContext context)
  {
    Node contextNode = context.getContextNode();
    int nodeHandler = ((DTMNodeProxy)contextNode).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)contextNode).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getLineNumber();
    else
      return -1;
  }

  
  public static int lineNumber(NodeList nodeList)
  {
    if (nodeList == null || nodeList.getLength() == 0)
      return -1;
    
    Node node = nodeList.item(0);
    int nodeHandler = ((DTMNodeProxy)node).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)node).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getLineNumber();
    else
      return -1;
  }

  
  public static int columnNumber(ExpressionContext context)
  {
    Node contextNode = context.getContextNode();
    int nodeHandler = ((DTMNodeProxy)contextNode).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)contextNode).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getColumnNumber();
    else
      return -1;
  }

  
  public static int columnNumber(NodeList nodeList)
  {
    if (nodeList == null || nodeList.getLength() == 0)
      return -1;
    
    Node node = nodeList.item(0);
    int nodeHandler = ((DTMNodeProxy)node).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)node).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getColumnNumber();
    else
      return -1;
  }
}
"
org.apache.xalan.xsltc.compiler.Expression,18,2,22,83,43,115,64,21,17,0.838235294,238,1.0,3,0.76056338,0.285714286,1,2,12.0,6,1.4444,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO_W;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.BooleanType;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodType;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

abstract class Expression extends SyntaxTreeNode {
    
    protected Type _type;

    
    protected boolean _startReset = false;

    
    protected FlowList _trueList = new FlowList();

    
    protected FlowList _falseList = new FlowList();

    public Type getType() {
	return _type;
    }

    public abstract String toString();

    public boolean hasPositionCall() {
	return false;		
    }

    public boolean hasLastCall() {
	return false;
    }
		
    
    public Object evaluateAtCompileTime() {
	return null;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return typeCheckContents(stable);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ErrorMsg msg = new ErrorMsg(ErrorMsg.NOT_IMPLEMENTED_ERR,
				    getClass(), this);
	getParser().reportError(FATAL, msg);
    }
	
    
    public final InstructionList compile(ClassGenerator classGen,
					 MethodGenerator methodGen) {
	final InstructionList result, save = methodGen.getInstructionList();
	methodGen.setInstructionList(result = new InstructionList());
	translate(classGen, methodGen);
	methodGen.setInstructionList(save);
	return result;
    }

    
    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	translate(classGen, methodGen);
	if (_type instanceof BooleanType) {
	    desynthesize(classGen, methodGen);
	}
    }

    
    public void startResetIterator(ClassGenerator classGen,
				   MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_startReset) {
	    return;			
	}
	_startReset = true;

	if (_type instanceof NodeSetType == false) {
	    return;		
	}

	if ( (this instanceof VariableRefBase) == false ) {
	    il.append(methodGen.loadContextNode());
	    il.append(methodGen.setStartNode());
	}
    }

    
    public void synthesize(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	_trueList.backPatch(il.append(ICONST_1));
	final BranchHandle truec = il.append(new GOTO_W(null));
	_falseList.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    public void desynthesize(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	_falseList.add(il.append(new IFEQ(null)));
    }

    public FlowList getFalseList() {
	return _falseList;
    }

    public FlowList getTrueList() {
	return _trueList;
    }

    public void backPatchFalseList(InstructionHandle ih) {
	_falseList.backPatch(ih);
    }

    public void backPatchTrueList(InstructionHandle ih) {
	_trueList.backPatch(ih);
    }

    
    public MethodType lookupPrimop(SymbolTable stable, String op,
				   MethodType ctype) {
	MethodType result = null;
	final Vector primop = stable.lookupPrimop(op);
	if (primop != null) {
	    final int n = primop.size();
	    int minDistance = Integer.MAX_VALUE;
	    for (int i = 0; i < n; i++) {
		final MethodType ptype = (MethodType) primop.elementAt(i);
		
		if (ptype.argsCount() != ctype.argsCount()) {
		    continue;
		}
				
		
		if (result == null) {
		    result = ptype;		
		}

		
		final int distance = ctype.distanceTo(ptype);
		if (distance < minDistance) {
		    minDistance = distance;
		    result = ptype;
		}
	    }		
	}	
	return result;
    }	
}
"
org.apache.xalan.xsltc.compiler.util.ResultTreeType,22,2,0,40,59,185,9,33,21,0.523809524,728,1.0,0,0.622641509,0.199300699,2,4,32.04545455,7,1.6364,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.FlowList;

public final class ResultTreeType extends Type {
    private final String _methodName;

    protected ResultTreeType() {
	_methodName = null;
    }

    public ResultTreeType(String methodName) {
	_methodName = methodName;
    }

    public String toString() {
	return ""result-tree"";
    }

    public boolean identicalTo(Type other) {
	return (other instanceof ResultTreeType);
    }

    public String toSignature() {
	return DOM_INTF_SIG;
    }

    public org.apache.bcel.generic.Type toJCType() {
	return Util.getJCRefType(toSignature());
    }

    public String getMethodName() {
	return _methodName;
    }

    public boolean implementedAsMethod() {
	return _methodName != null;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType)type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType)type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType)type);
	}
	else if (type == Type.NodeSet) {
	    translateTo(classGen, methodGen, (NodeSetType)type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType)type);
	}
	else if (type == Type.Object) {
	    translateTo(classGen, methodGen, (ObjectType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	
	
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(POP);      
	il.append(ICONST_1); 
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	
	if (_methodName == null) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  ""getStringValue"", 
						  ""()""+STRING_SIG);
	    il.append(new INVOKEINTERFACE(index, 1));
	}
	else {
	    final String className = classGen.getClassName();
	    final int current = methodGen.getLocalIndex(""current"");
	    
	    
	    il.append(classGen.loadTranslet());
	    if (classGen.isExternal()) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }
	    il.append(DUP);
	    il.append(new GETFIELD(cpg.addFieldref(className, ""_dom"",
						   DOM_INTF_SIG)));

	    
	    int index = cpg.addMethodref(STRING_VALUE_HANDLER, ""<init>"", ""()V"");
	    il.append(new NEW(cpg.addClass(STRING_VALUE_HANDLER)));
	    il.append(DUP);
	    il.append(DUP);
	    il.append(new INVOKESPECIAL(index));
	    
	    
	    final LocalVariableGen handler =
		methodGen.addLocalVariable(""rt_to_string_handler"", 
					   Util.getJCRefType(STRING_VALUE_HANDLER_SIG),
					   null, null);
	    il.append(new ASTORE(handler.getIndex()));

	    
	    index = cpg.addMethodref(className, _methodName,
				     ""(""+DOM_INTF_SIG+TRANSLET_OUTPUT_SIG+"")V"");
	    il.append(new INVOKEVIRTUAL(index));
	    
	    
	    il.append(new ALOAD(handler.getIndex()));
	    index = cpg.addMethodref(STRING_VALUE_HANDLER,
				     ""getValue"",
				     ""()"" + STRING_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	translateTo(classGen, methodGen, Type.String);
	Type.String.translateTo(classGen, methodGen, Type.Real);	
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_methodName == null) {
	    il.append(NOP);
	}
	else {
	    LocalVariableGen domBuilder, newDom;
	    final String className = classGen.getClassName();
	    final int current = methodGen.getLocalIndex(""current"");

	    
	    il.append(classGen.loadTranslet());
	    if (classGen.isExternal()) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }
	    il.append(methodGen.loadDOM());

	    
	    il.append(methodGen.loadDOM());
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
				 ""getResultTreeFrag"",
				 ""(IZ)"" + DOM_INTF_SIG);
	    il.append(new PUSH(cpg, RTF_INITIAL_SIZE));
	    il.append(new PUSH(cpg, false));
	    il.append(new INVOKEINTERFACE(index,3));
	    il.append(DUP);
	    
	    
	    newDom = methodGen.addLocalVariable(""rt_to_reference_dom"", 
						Util.getJCRefType(DOM_INTF_SIG),
						null, null);
	    il.append(new CHECKCAST(cpg.addClass(DOM_INTF_SIG)));
	    il.append(new ASTORE(newDom.getIndex()));

	    
	    index = cpg.addInterfaceMethodref(DOM_INTF,
				 ""getOutputDomBuilder"",
				 ""()"" + TRANSLET_OUTPUT_SIG);

	    il.append(new INVOKEINTERFACE(index,1));
	    
		
		
	    
	    il.append(DUP);
	    il.append(DUP);

	    
	    domBuilder =
		methodGen.addLocalVariable(""rt_to_reference_handler"", 
					   Util.getJCRefType(TRANSLET_OUTPUT_SIG),
					   null, null);
	    il.append(new ASTORE(domBuilder.getIndex()));

	    
	    index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE, 
					      ""startDocument"", ""()V"");
	    il.append(new INVOKEINTERFACE(index, 1));

	    
	    index = cpg.addMethodref(className,
				     _methodName,
				     ""(""
				     + DOM_INTF_SIG
				     + TRANSLET_OUTPUT_SIG
				     +"")V"");
	    il.append(new INVOKEVIRTUAL(index));

	    
	    il.append(new ALOAD(domBuilder.getIndex()));
	    index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE, 
					      ""endDocument"", ""()V"");
	    il.append(new INVOKEINTERFACE(index, 1));

	    
	    il.append(new ALOAD(newDom.getIndex()));
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    NodeSetType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(DUP);

	
	
	
	il.append(classGen.loadTranslet()); 
	il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       NAMES_INDEX,
					       NAMES_INDEX_SIG)));
	il.append(classGen.loadTranslet()); 
	il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       NAMESPACE_INDEX,
					       NAMESPACE_INDEX_SIG)));
	
	final int mapping = cpg.addInterfaceMethodref(DOM_INTF,
						      ""setupMapping"",
						      ""([""+STRING_SIG+
						      ""[""+STRING_SIG+"")V"");
	il.append(new INVOKEINTERFACE(mapping, 3));
	il.append(DUP);

	
	final int iter = cpg.addInterfaceMethodref(DOM_INTF,
						   ""getIterator"",
						   ""()""+NODE_ITERATOR_SIG);
	il.append(new INVOKEINTERFACE(iter, 1));	
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ObjectType type) {
	methodGen.getInstructionList().append(NOP);	
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	translateTo(classGen, methodGen, Type.Boolean);
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	final String className = clazz.getName();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (className.equals(""org.w3c.dom.Node"")) {
	    translateTo(classGen, methodGen, Type.NodeSet);
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE,
						  MAKE_NODE_SIG2);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else if (className.equals(""org.w3c.dom.NodeList"")) {
	    translateTo(classGen, methodGen, Type.NodeSet);
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE_LIST,
						  MAKE_NODE_LIST_SIG2);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else if (className.equals(""java.lang.Object"")) {
	    il.append(NOP);
	}
        else if (className.equals(""java.lang.String"")) {
            translateTo(classGen, methodGen, Type.String);
        }
        else if (clazz == Double.TYPE) {
            translateTo(classGen, methodGen, Type.Real);
        }        
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), className);
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public String getClassName() {
	return(DOM_INTF);
    }

    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}
"
org.apache.xalan.xsltc.dom.SingleNodeCounter,5,2,1,5,16,2,1,5,4,0.625,110,0.5,1,0.823529412,0.5,1,4,20.6,9,2.2,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xml.dtm.DTMAxisIterator;

public abstract class SingleNodeCounter extends NodeCounter {
    static private final int[] EmptyArray = new int[] { };
    DTMAxisIterator _countSiblings = null;

    public SingleNodeCounter(Translet translet,
			     DOM document,
			     DTMAxisIterator iterator) {
	super(translet, document, iterator);
    }

    public NodeCounter setStartNode(int node) {
	_node = node;
	_nodeType = _document.getExpandedTypeID(node);
	_countSiblings = _document.getAxisIterator(PRECEDINGSIBLING);
	return this;
    }

    public String getCounter() {
	int result;
	if (_value != Integer.MIN_VALUE) {
	    result = _value;
	}
	else {
	    int next = _node;
	    result = 0;
	    if (!matchesCount(next)) {
		while ((next = _document.getParent(next)) > END) {
		    if (matchesCount(next)) {
			break;		
		    }
		    if (matchesFrom(next)) {
			next = END;
			break;		
		    }
		}
	    }

	    if (next != END) {
		_countSiblings.setStartNode(next);
		do {
		    if (matchesCount(next)) result++;
		} while ((next = _countSiblings.next()) != END);
	    }
	    else {
		
		return formatNumbers(EmptyArray);
	    }
	}
	return formatNumbers(result);
    }

    public static NodeCounter getDefaultNodeCounter(Translet translet,
						    DOM document,
						    DTMAxisIterator iterator) {
	return new DefaultSingleNodeCounter(translet, document, iterator);
    }

    static class DefaultSingleNodeCounter extends SingleNodeCounter {
	public DefaultSingleNodeCounter(Translet translet,
					DOM document, DTMAxisIterator iterator) {
	    super(translet, document, iterator);
	}

	public NodeCounter setStartNode(int node) {
	    _node = node;
	    _nodeType = _document.getExpandedTypeID(node);
	    _countSiblings =
		_document.getTypedAxisIterator(PRECEDINGSIBLING,
					       _document.getExpandedTypeID(node));
	    return this;
	}

	public String getCounter() {
	    int result;
	    if (_value != Integer.MIN_VALUE) {
		result = _value;
	    }
	    else {
		int next;
		result = 1;
		_countSiblings.setStartNode(_node);
		while ((next = _countSiblings.next()) != END) {
		    result++;
		}
	    }
	    return formatNumbers(result);
	}
    }
}

"
org.apache.xalan.xsltc.compiler.IdKeyPattern,9,5,2,25,29,22,3,23,9,0.75,214,1.0,1,0.925233645,0.259259259,3,4,22.44444444,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFNE;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

abstract class IdKeyPattern extends LocationPathPattern {

    protected RelativePathPattern _left = null;;
    private String _index = null;
    private String _value = null;;

    public IdKeyPattern(String index, String value) {
	_index = index;
	_value = value;
    }

    public String getIndexName() {
	return(_index);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.NodeSet;
    }
    
    public boolean isWildcard() {
	return false;
    }
    
    public void setLeft(RelativePathPattern left) {
	_left = left;
    }

    public StepPattern getKernelPattern() {
	return(null);
    }
    
    public void reduceKernelPattern() { }

    public String toString() {
	return ""id/keyPattern("" + _index + "", "" + _value + ')';
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getKeyIndex = cpg.addMethodref(TRANSLET_CLASS,
						 ""getKeyIndex"",
						 ""(Ljava/lang/String;)""+
						 KEY_INDEX_SIG);
	
	
	final int lookupId = cpg.addMethodref(KEY_INDEX_CLASS,
					      ""containsID"",
					      ""(ILjava/lang/Object;)I"");
	final int lookupKey = cpg.addMethodref(KEY_INDEX_CLASS,
					       ""containsKey"",
					       ""(ILjava/lang/Object;)I"");
	final int getNodeIdent = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getNodeIdent"",
							   ""(I)""+NODE_SIG);				       

	
	
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg,_index));
	il.append(new INVOKEVIRTUAL(getKeyIndex));
	
	
	
	il.append(SWAP);
	il.append(new PUSH(cpg,_value));
	if (this instanceof IdPattern)
	{
		il.append(SWAP);
		il.append(methodGen.loadDOM());
		il.append(SWAP);
	    il.append(new INVOKEINTERFACE(getNodeIdent, 2));
	    il.append(SWAP);
	    il.append(new INVOKEVIRTUAL(lookupId));
	}
	else
	{
		il.append(SWAP);
		il.append(methodGen.loadDOM());
		il.append(SWAP);
	    il.append(new INVOKEINTERFACE(getNodeIdent, 2));
	    il.append(SWAP);
	    il.append(new INVOKEVIRTUAL(lookupKey));
	}

	_trueList.add(il.append(new IFNE(null)));
	_falseList.add(il.append(new GOTO(null)));
    }

}

"
org.apache.xml.utils.res.XResources_ka,3,4,0,1,4,1,0,1,2,0.5,614,0.0,0,0.976190476,1.0,0,0,203.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_ka extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ka"" }, { ""help_language"", ""ka"" }, { ""language"", ""ka"" },
    { ""alphabet"",
      new char[]{ 0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6,
                  0x10f1, 0x10D7, 0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC,
                  0x10f2, 0x10DD, 0x10DE, 0x10DF, 0x10E0, 0x10E1, 0x10E2,
                  0x10E3, 0x10E4, 0x10E5, 0x10E6, 0x10E7, 0x10E8, 0x10E9,
                  0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10F4, 0x10EF,
                  0x10F0 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    { ""numberGroups"", new int[]{ 1000, 100, 10, 1 } },

    
    { ""digits"",
      new char[]{ 0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6,
                  0x10f1, 0x10D7 } },
    { ""tens"",
      new char[]{ 0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC, 0x10f2, 0x10DD,
                  0x10DE, 0x10DF } },
    { ""hundreds"",
      new char[]{ 0x10E0, 0x10E1, 0x10E2, 0x10E3, 0x10E4, 0x10E5, 0x10E6,
                  0x10E7, 0x10E8 } },
    { ""thousands"",
      new char[]{ 0x10E9, 0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10F4,
                  0x10EF, 0x10F0 } },
    { ""tables"", new String[]{ ""thousands"", ""hundreds"", ""tens"", ""digits"" } }
  };
}
"
org.apache.xalan.templates.ElemAttribute,9,5,0,9,31,36,2,7,6,2.0,161,0.0,0,0.963800905,0.314814815,4,10,16.88888889,16,3.0,3,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.serializer.NamespaceMappings;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.utils.QName;

import org.xml.sax.SAXException;


public class ElemAttribute extends ElemElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_ATTRIBUTE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_ATTRIBUTE_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    SerializationHandler rhandler = transformer.getSerializationHandler();

    
    
    
    



















    
    super.execute(transformer);
    
  }
  
  
  protected String resolvePrefix(SerializationHandler rhandler,
                                 String prefix, String nodeNamespace)
    throws TransformerException
  {

    if (null != prefix && (prefix.length() == 0 || prefix.equals(""xmlns"")))
    {
      
      
      prefix = rhandler.getPrefix(nodeNamespace);

      
      if (null == prefix || prefix.length() == 0 || prefix.equals(""xmlns""))
      {
        if(nodeNamespace.length() > 0)
        {
            NamespaceMappings prefixMapping = rhandler.getNamespaceMappings();
            prefix = prefixMapping.generateNextPrefix();
        }
        else
          prefix = """";
      }
    }
    return prefix;
  }
  
  
   protected boolean validateNodeName(String nodeName)
   {
      if(null == nodeName)
        return false;
      if(nodeName.equals(""xmlns""))
        return false;
      return super.validateNodeName(nodeName);
   }
  
  
  void constructNode(
          String nodeName, String prefix, String nodeNamespace, TransformerImpl transformer)
            throws TransformerException
  {

    if(null != nodeName && nodeName.length() > 0)
    {
      SerializationHandler rhandler = transformer.getSerializationHandler();
      if(prefix != null && prefix.length() > 0)
      {
        try
        {
          rhandler.startPrefixMapping(prefix, nodeNamespace, false);
        }
        catch(SAXException se)
        {
          throw new TransformerException(se);
        }
      }
      String val = transformer.transformToString(this);
      String localName = QName.getLocalPart(nodeName);
      try 
      {
        rhandler.addAttribute(nodeNamespace, localName, nodeName, ""CDATA"", val);
      }
      catch (SAXException e)
      {
      }
    }
  }


  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {

    
    case Constants.ELEMNAME_TEXTLITERALRESULT :
    case Constants.ELEMNAME_APPLY_TEMPLATES :
    case Constants.ELEMNAME_APPLY_IMPORTS :
    case Constants.ELEMNAME_CALLTEMPLATE :
    case Constants.ELEMNAME_FOREACH :
    case Constants.ELEMNAME_VALUEOF :
    case Constants.ELEMNAME_COPY_OF :
    case Constants.ELEMNAME_NUMBER :
    case Constants.ELEMNAME_CHOOSE :
    case Constants.ELEMNAME_IF :
    case Constants.ELEMNAME_TEXT :
    case Constants.ELEMNAME_COPY :
    case Constants.ELEMNAME_VARIABLE :
    case Constants.ELEMNAME_MESSAGE :

      
      
      
      
      
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
	
	public void setName(AVT v) {
        if (v.isSimple())
        {
            if (v.getSimpleString().equals(""xmlns""))
            {
                throw new IllegalArgumentException();
            }
        }
		super.setName(v);
	}

}
"
org.apache.xpath.axes.ReverseAxesWalker,9,5,0,7,26,28,1,6,5,0.5,207,1.0,1,0.927927928,0.416666667,2,8,21.88888889,4,1.7778,0,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xpath.XPathContext;


public class ReverseAxesWalker extends AxesWalker
{

  
  ReverseAxesWalker(LocPathIterator locPathIterator, int axis)
  {
    super(locPathIterator, axis);
  }
  
  
  public void setRoot(int root)
  {
    super.setRoot(root);
    m_iterator = getDTM(root).getAxisIterator(m_axis);
    m_iterator.setStartNode(root);
  }

  
  public void detach()
  {
    m_iterator = null;
    super.detach();
  }
  
  
  protected int getNextNode()
  {
    if (m_foundLast)
      return DTM.NULL;

    int next = m_iterator.next();
    
    if (m_isFresh)
      m_isFresh = false;

    if (DTM.NULL == next)
      this.m_foundLast = true;

    return next;
  }


  
  public boolean isReverseAxes()
  {
    return true;
  }











  
  protected int getProximityPosition(int predicateIndex)
  {
    
    
    
    if(predicateIndex < 0)
      return -1;
      
    int count = m_proximityPositions[predicateIndex];
      
    if (count <= 0)
    {
      AxesWalker savedWalker = wi().getLastUsedWalker();

      try
      {
        ReverseAxesWalker clone = (ReverseAxesWalker) this.clone();

        clone.setRoot(this.getRoot());

        clone.setPredicateCount(predicateIndex);

        clone.setPrevWalker(null);
        clone.setNextWalker(null);
        wi().setLastUsedWalker(clone);

        
        count++;
        int next;

        while (DTM.NULL != (next = clone.nextNode()))
        {
          count++;
        }

        m_proximityPositions[predicateIndex] = count;
      }
      catch (CloneNotSupportedException cnse)
      {

        
      }
      finally
      {
        wi().setLastUsedWalker(savedWalker);
      }
    }
    
    return count;
  }

  
  protected void countProximityPosition(int i)
  {
    if (i < m_proximityPositions.length)
      m_proximityPositions[i]--;
  }

  
  public int getLastPos(XPathContext xctxt)
  {

    int count = 0;
    AxesWalker savedWalker = wi().getLastUsedWalker();

    try
    {
      ReverseAxesWalker clone = (ReverseAxesWalker) this.clone();

      clone.setRoot(this.getRoot());

      clone.setPredicateCount(this.getPredicateCount() - 1);

      clone.setPrevWalker(null);
      clone.setNextWalker(null);
      wi().setLastUsedWalker(clone);

      
      
      int next;

      while (DTM.NULL != (next = clone.nextNode()))
      {
        count++;
      }
    }
    catch (CloneNotSupportedException cnse)
    {

      
    }
    finally
    {
      wi().setLastUsedWalker(savedWalker);
    }

    return count;
  }
  
  
  public boolean isDocOrdered()
  {
    return false;  
  }
  
  
  protected DTMAxisIterator m_iterator;
}
"
org.apache.xalan.serialize.SerializerUtils,7,1,0,12,37,21,5,7,7,2.0,250,0.0,0,0.0,0.404761905,0,0,34.71428571,4,1.2857,1,"
package org.apache.xalan.serialize;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xml.serializer.NamespaceMappings;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.xml.sax.SAXException;


public class SerializerUtils
{

    
    public static void addAttribute(SerializationHandler handler, int attr)
        throws TransformerException
    {

        TransformerImpl transformer =
            (TransformerImpl) handler.getTransformer();
        DTM dtm = transformer.getXPathContext().getDTM(attr);

        if (SerializerUtils.isDefinedNSDecl(handler, attr, dtm))
            return;

        String ns = dtm.getNamespaceURI(attr);

        if (ns == null)
            ns = """";

        
        try
        {
            handler.addAttribute(
                ns,
                dtm.getLocalName(attr),
                dtm.getNodeName(attr),
                ""CDATA"",
                dtm.getNodeValue(attr));
        }
        catch (SAXException e)
        {
            
        }
    } 

    
    public static void addAttributes(SerializationHandler handler, int src)
        throws TransformerException
    {

        TransformerImpl transformer =
            (TransformerImpl) handler.getTransformer();
        DTM dtm = transformer.getXPathContext().getDTM(src);

        for (int node = dtm.getFirstAttribute(src);
            DTM.NULL != node;
            node = dtm.getNextAttribute(node))
        {
            addAttribute(handler, node);
        }
    }

    
    public static void outputResultTreeFragment(
        SerializationHandler handler,
        XObject obj,
        XPathContext support)
        throws org.xml.sax.SAXException
    {

        int doc = obj.rtf();
        DTM dtm = support.getDTM(doc);

        if (null != dtm)
        {
            for (int n = dtm.getFirstChild(doc);
                DTM.NULL != n;
                n = dtm.getNextSibling(n))
            {
                handler.flushPending();
                
                
                if (dtm.getNamespaceURI(n) == null)
                    handler.startPrefixMapping("""", """");
                dtm.dispatchToEvents(n, handler);
            }
        }
    }

    
    public static void processNSDecls(
        SerializationHandler handler,
        int src,
        int type,
        DTM dtm)
        throws TransformerException
    {

        try
        {
            if (type == DTM.ELEMENT_NODE)
            {
                for (int namespace = dtm.getFirstNamespaceNode(src, true);
                    DTM.NULL != namespace;
                    namespace = dtm.getNextNamespaceNode(src, namespace, true))
                {

                    
                    String prefix = dtm.getNodeNameX(namespace);
                    String desturi = handler.getNamespaceURIFromPrefix(prefix);
                    
                    String srcURI = dtm.getNodeValue(namespace);

                    if (!srcURI.equalsIgnoreCase(desturi))
                    {
                        handler.startPrefixMapping(prefix, srcURI, false);
                    }
                }
            }
            else if (type == DTM.NAMESPACE_NODE)
            {
                String prefix = dtm.getNodeNameX(src);
                
                String desturi = handler.getNamespaceURIFromPrefix(prefix);
                String srcURI = dtm.getNodeValue(src);

                if (!srcURI.equalsIgnoreCase(desturi))
                {
                    handler.startPrefixMapping(prefix, srcURI, false);
                }
            }
        }
        catch (org.xml.sax.SAXException se)
        {
            throw new TransformerException(se);
        }
    }

    
    public static boolean isDefinedNSDecl(
        SerializationHandler serializer,
        int attr,
        DTM dtm)
    {

        if (DTM.NAMESPACE_NODE == dtm.getNodeType(attr))
        {

            
            String prefix = dtm.getNodeNameX(attr);
            String uri = serializer.getNamespaceURIFromPrefix(prefix);
            

            if ((null != uri) && uri.equals(dtm.getStringValue(attr)))
                return true;
        }

        return false;
    }

    
    public static void ensureNamespaceDeclDeclared(
        SerializationHandler handler,
        DTM dtm,
        int namespace)
        throws org.xml.sax.SAXException
    {

        String uri = dtm.getNodeValue(namespace);
        String prefix = dtm.getNodeNameX(namespace);

        if ((uri != null && uri.length() > 0) && (null != prefix))
        {
            String foundURI;
            NamespaceMappings ns = handler.getNamespaceMappings();
            if (ns != null)
            {

                foundURI = ns.lookupNamespace(prefix);
                if ((null == foundURI) || !foundURI.equals(uri))
                {
                    handler.startPrefixMapping(prefix, uri, false);
                }
            }
        }
    }
}
"
org.apache.xalan.xsltc.compiler.FormatNumberCall,3,4,0,22,24,0,0,22,3,0.0,191,1.0,4,0.979591837,0.444444444,3,13,61.33333333,3,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.RealType;
import org.apache.xalan.xsltc.compiler.util.StringType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class FormatNumberCall extends FunctionCall {
    private Expression _value;
    private Expression _format;
    private Expression _name;
    private QName      _resolvedQName = null;

    public FormatNumberCall(QName fname, Vector arguments) {
	super(fname, arguments);
	_value = argument(0);
	_format = argument(1);
	_name = argumentCount() == 3 ? argument(2) : null;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	getStylesheet().numberFormattingUsed();

	final Type tvalue = _value.typeCheck(stable);
	if (tvalue instanceof RealType == false) {
	    _value = new CastExpr(_value, Type.Real);
	}
	final Type tformat = _format.typeCheck(stable);
	if (tformat instanceof StringType == false) {
	    _format = new CastExpr(_format, Type.String);
	}
	if (argumentCount() == 3) {
	    final Type tname = _name.typeCheck(stable);

	    if (_name instanceof LiteralExpr) {
		final LiteralExpr literal = (LiteralExpr) _name;
		_resolvedQName = 
		    getParser().getQNameIgnoreDefaultNs(literal.getValue());
	    }
	    else if (tname instanceof StringType == false) {
		_name = new CastExpr(_name, Type.String);
	    }
	}
	return _type = Type.String;
    }
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	_value.translate(classGen, methodGen);
	_format.translate(classGen, methodGen);

	final int fn3arg = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					    ""formatNumber"",
					    ""(DLjava/lang/String;""+
					    ""Ljava/text/DecimalFormat;)""+
					    ""Ljava/lang/String;"");
	final int get = cpg.addMethodref(TRANSLET_CLASS,
					 ""getDecimalFormat"",
					 ""(Ljava/lang/String;)""+
					 ""Ljava/text/DecimalFormat;"");
	
	il.append(classGen.loadTranslet());
	if (_name == null) {
	    il.append(new PUSH(cpg, EMPTYSTRING));
	}
	else if (_resolvedQName != null) {
	    il.append(new PUSH(cpg, _resolvedQName.toString()));
	}
	else {
	    _name.translate(classGen, methodGen);
	}
	il.append(new INVOKEVIRTUAL(get));
	il.append(new INVOKESTATIC(fn3arg));
    }
}
"
org.apache.xalan.xsltc.compiler.RelationalExpr,10,3,0,31,54,0,0,31,10,0.185185185,600,1.0,2,0.8875,0.257142857,2,9,58.7,7,2.5,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.BranchInstruction;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.BooleanType;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.IntType;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodType;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.RealType;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.ResultTreeType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.runtime.Operators;

final class RelationalExpr extends Expression implements Operators {
    private int _op;
    private Expression _left, _right;
		
    public RelationalExpr(int op, Expression left, Expression right) {
	_op = op;
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }

    
    public boolean hasPositionCall() {
	if (_left.hasPositionCall()) return true;
	if (_right.hasPositionCall()) return true;
	return false;
    }

    public boolean hasReferenceArgs() {
	return _left.getType() instanceof ReferenceType ||
	    _right.getType() instanceof ReferenceType;
    }

    public boolean hasNodeArgs() {
	return _left.getType() instanceof NodeType ||
	    _right.getType() instanceof NodeType;
    }

    public boolean hasNodeSetArgs() {
	return _left.getType() instanceof NodeSetType ||
	    _right.getType() instanceof NodeSetType;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	Type tleft = _left.typeCheck(stable); 
	Type tright = _right.typeCheck(stable);

	
	if (tleft instanceof ResultTreeType &&
	    tright instanceof ResultTreeType ) 
  	{
	    _right = new CastExpr(_right, Type.Real);
	    _left = new CastExpr(_left, Type.Real);
	    return _type = Type.Boolean; 
	}

	
	if (hasReferenceArgs()) {
	    Type type = null;
	    Type typeL = null;
	    Type typeR = null;
	    if (tleft instanceof ReferenceType) {
		if (_left instanceof VariableRefBase) {
		    VariableRefBase ref = (VariableRefBase)_left;
		    VariableBase var = ref.getVariable();
		    typeL = var.getType();
		}
	    }
	    if (tright instanceof ReferenceType) {
		if (_right instanceof VariableRefBase) {
		    VariableRefBase ref = (VariableRefBase)_right;
		    VariableBase var = ref.getVariable();
		    typeR = var.getType();
		}
	    }
	    
	    if (typeL == null)
		type = typeR;
	    else if (typeR == null)
		type = typeL;
	    else {
		type = Type.Real;
	    }
	    if (type == null) type = Type.Real;

	    _right = new CastExpr(_right, type);
            _left = new CastExpr(_left, type);
	    return _type = Type.Boolean;
	}

	if (hasNodeSetArgs()) {
	    
	    if (tright instanceof NodeSetType) {
		final Expression temp = _right; _right = _left; _left = temp;
		_op = (_op == Operators.GT) ? Operators.LT :
		    (_op == Operators.LT) ? Operators.GT :
		    (_op == Operators.GE) ? Operators.LE : Operators.GE;
		tright = _right.getType();
	    }

	    
	    if (tright instanceof NodeType) {
		_right = new CastExpr(_right, Type.NodeSet);
	    }
	    
	    if (tright instanceof IntType) {
		_right = new CastExpr(_right, Type.Real);
	    }
	    
	    if (tright instanceof ResultTreeType) {
		_right = new CastExpr(_right, Type.String);
	    }
	    return _type = Type.Boolean;
	}

	
	if (hasNodeArgs()) {
	    if (tleft instanceof BooleanType) {
		_right = new CastExpr(_right, Type.Boolean);
		tright = Type.Boolean;
	    }
	    if (tright instanceof BooleanType) {
		_left = new CastExpr(_left, Type.Boolean);
		tleft = Type.Boolean;
	    }
	}

	
	MethodType ptype = lookupPrimop(stable, Operators.names[_op],
					new MethodType(Type.Void, 
						       tleft, tright)); 

	if (ptype != null) {
	    Type arg1 = (Type) ptype.argsType().elementAt(0);
	    if (!arg1.identicalTo(tleft)) {
		_left = new CastExpr(_left, arg1);
	    }
	    Type arg2 = (Type) ptype.argsType().elementAt(1);
	    if (!arg2.identicalTo(tright)) {
		_right = new CastExpr(_right, arg1);				
	    }
	    return _type = ptype.resultType();
	}
	throw new TypeCheckError(this);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (hasNodeSetArgs() || hasReferenceArgs()) {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();

	    
	    _left.translate(classGen, methodGen);
	    _left.startResetIterator(classGen, methodGen);
	    _right.translate(classGen, methodGen);
	    _right.startResetIterator(classGen, methodGen);

	    il.append(new PUSH(cpg, _op));
	    il.append(methodGen.loadDOM());

	    int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""compare"",
					 ""(""
					 + _left.getType().toSignature() 
					 + _right.getType().toSignature()
					 + ""I""
					 + DOM_INTF_SIG
					 + "")Z"");
	    il.append(new INVOKESTATIC(index));
	}
	else {
	    translateDesynthesized(classGen, methodGen);
	    synthesize(classGen, methodGen);
	}
    }

    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	if (hasNodeSetArgs() || hasReferenceArgs()) {
	    translate(classGen, methodGen);
	    desynthesize(classGen, methodGen);
	}
	else {
	    BranchInstruction bi = null;
	    final InstructionList il = methodGen.getInstructionList();

	    _left.translate(classGen, methodGen);
	    _right.translate(classGen, methodGen);

	    

	    boolean tozero = false;
	    Type tleft = _left.getType(); 

	    if (tleft instanceof RealType) {
		il.append(tleft.CMP(_op == LT || _op == LE));
		tleft = Type.Int;
		tozero = true;
	    }

	    switch (_op) {
	    case LT:
		bi = tleft.GE(tozero);	
		break;
		
	    case GT:
		bi = tleft.LE(tozero);
		break;
		
	    case LE:
		bi = tleft.GT(tozero);
		break;
		
	    case GE:
		bi = tleft.LT(tozero);
		break;
		
	    default:
		ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_RELAT_OP_ERR,this);
		getParser().reportError(Constants.FATAL, msg);
	    }

	    _falseList.add(il.append(bi));		
	}
    }

    public String toString() {
	return Operators.names[_op] + '(' + _left + "", "" + _right + ')';
    }
}
"
org.apache.xalan.xsltc.DOM,43,1,0,36,43,903,32,5,43,1.023809524,51,0.0,0,0.0,0.261627907,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

import org.apache.xalan.xsltc.runtime.Hashtable;
import org.apache.xml.dtm.DTMAxisIterator;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.apache.xml.serializer.SerializationHandler;

public interface DOM {
    public final static int  FIRST_TYPE             = 0;

    public final static int  NO_TYPE                = -1;
    
    
    public final static int NULL     = 0;

    
    public final static int RETURN_CURRENT = 0;
    public final static int RETURN_PARENT  = 1;
    
    
    public final static int SIMPLE_RTF   = 0;
    public final static int ADAPTIVE_RTF = 1;
    public final static int TREE_RTF     = 2;
    
    
    public DTMAxisIterator getIterator();
    public String getStringValue();
	
    public DTMAxisIterator getChildren(final int node);
    public DTMAxisIterator getTypedChildren(final int type);
    public DTMAxisIterator getAxisIterator(final int axis);
    public DTMAxisIterator getTypedAxisIterator(final int axis, final int type);
    public DTMAxisIterator getNthDescendant(int node, int n, boolean includeself);
    public DTMAxisIterator getNamespaceAxisIterator(final int axis, final int ns);
    public DTMAxisIterator getNodeValueIterator(DTMAxisIterator iter, int returnType,
					     String value, boolean op);
    public DTMAxisIterator orderNodes(DTMAxisIterator source, int node);
    public String getNodeName(final int node);
    public String getNodeNameX(final int node);
    public String getNamespaceName(final int node);
    public int getExpandedTypeID(final int node);
    public int getNamespaceType(final int node);
    public int getParent(final int node);
    public int getAttributeNode(final int gType, final int element);
    public String getStringValueX(final int node);
    public void copy(final int node, SerializationHandler handler)
	throws TransletException;
    public void copy(DTMAxisIterator nodes, SerializationHandler handler)
	throws TransletException;
    public String shallowCopy(final int node, SerializationHandler handler)
	throws TransletException;
    public boolean lessThan(final int node1, final int node2);
    public void characters(final int textNode, SerializationHandler handler)
	throws TransletException;
    public Node makeNode(int index);
    public Node makeNode(DTMAxisIterator iter);
    public NodeList makeNodeList(int index);
    public NodeList makeNodeList(DTMAxisIterator iter);
    public String getLanguage(int node);
    public int getSize();
    public String getDocumentURI(int node);
    public void setFilter(StripFilter filter);
    public void setupMapping(String[] names, String[] namespaces);
    public boolean isElement(final int node);
    public boolean isAttribute(final int node);
    public String lookupNamespace(int node, String prefix)
	throws TransletException;
    public int getNodeIdent(final int nodehandle);
    public int getNodeHandle(final int nodeId);
    public DOM getResultTreeFrag(int initialSize, int rtfType);
    public SerializationHandler getOutputDomBuilder();
    public int getNSType(int node);
    public int getDocument();
    public String getUnparsedEntityURI(String name);
    public Hashtable getElementsWithIDs();
}
"
org.apache.xml.serializer.ToTextStream,24,3,0,3,44,258,2,1,22,2.0,376,0.0,0,0.880208333,0.361111111,2,14,14.66666667,1,0.9583,1,"
package org.apache.xml.serializer;

import java.io.IOException;

import org.apache.xml.serializer.CharInfo;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;


public class ToTextStream extends ToStream 
{ 

       
  
  public ToTextStream()
  {
    super();
  }

 
 
  
  protected void startDocumentInternal() throws org.xml.sax.SAXException
  {
    super.startDocumentInternal();

    m_needToCallStartDocument = false;

    
  }

  
  public void endDocument() throws org.xml.sax.SAXException
  {
    flushPending();
    flushWriter();
    super.fireEndDoc();
  }

  
  public void startElement(
          String namespaceURI, String localName, String name, Attributes atts)
            throws org.xml.sax.SAXException
  {

    m_currentElemDepth++;

    
    super.fireStartElem(name);
    return;
  }

  
  public void endElement(String namespaceURI, String localName, String name)
          throws org.xml.sax.SAXException
  {
        m_currentElemDepth--;
		super.fireEndElem(name);           
  }

  
  public void characters(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    
    flushPending();    
    
    try
    {
        writeNormalizedChars(ch, start, length, false);
		super.fireCharEvent(ch, start, length);      
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  public void charactersRaw(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    try
    {
      writeNormalizedChars(ch, start, length, false);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }
  

void writeNormalizedChars(
    final char ch[],
    final int start,
    final int length,
    final boolean isCData)
    throws IOException, org.xml.sax.SAXException
{
    final int end = start + length;

    
    final char S_LINEFEED = CharInfo.S_LINEFEED;
    final int M_MAXCHARACTER = this.m_maxCharacter;

    if (isCData)
    {
        for (int i = start; i < end; i++)
        {
            final char c = ch[i];

            if (S_LINEFEED == c)
            {
                m_writer.write(m_lineSep, 0, m_lineSepLen);
            }
            else if (c > M_MAXCHARACTER)
            {
                if (i != 0)
                    closeCDATA();

                
                if (isUTF16Surrogate(c))
                {
                    i = writeUTF16Surrogate(c, ch, i, end);
                }
                else
                {
                    m_writer.write(c);
                }

                if ((i != 0) && (i < (end - 1)))
                {
                    m_writer.write(CDATA_DELIMITER_OPEN);
                    m_cdataTagOpen = true;
                }
            }
            else if (
                ((i < (end - 2))
                    && (']' == c)
                    && (']' == ch[i + 1])
                    && ('>' == ch[i + 2])))
            {
                m_writer.write(CDATA_CONTINUE);
                i += 2;
            }
            else
            {
                if (c <= M_MAXCHARACTER)
                {
                    m_writer.write(c);
                }

                else if (isUTF16Surrogate(c))
                {
                    i = writeUTF16Surrogate(c, ch, i, end);
                }
                else
                {
                    m_writer.write(c);
                }
            }
        }
    }
    else
    {
        
        for (int i = start; i < end; i++)
        {
            final char c = ch[i];

            if (S_LINEFEED == c)
            {
                m_writer.write(m_lineSep, 0, m_lineSepLen);
            }
            else if (c <= M_MAXCHARACTER)
            {
                m_writer.write(c);
            }
            else if (isUTF16Surrogate(c))
            {
                i = writeUTF16Surrogate(c, ch, i, end);
            }
            else
            {
                m_writer.write(c);
            }
        }
    }
}

  
  public void cdata(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {
    try
    {
        writeNormalizedChars(ch, start, length, false);
        super.fireCDATAEvent(ch, start, length);              
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    try
    {
      writeNormalizedChars(ch, start, length, false);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {
    
    flushPending();     
    super.fireEscapingEvent(target, data);    
  }

  
  public void comment(String data) throws org.xml.sax.SAXException
  {
    comment(data.toCharArray(), 0, data.length());
  }

  
  public void comment(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    flushPending();

    super.fireCommentEvent(ch, start, length);
  }

  
  public void entityReference(String name) throws org.xml.sax.SAXException
  {
        super.fireEntityReference(name);    
  }
  
    
    public void addAttribute(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
    {
        
    }
 
    
    public void endCDATA() throws SAXException
    {
        
    }

    
    public void endElement(String elemName) throws SAXException
    {
        m_currentElemDepth--;
        super.fireEndElem(elemName);                       
    }
 
    
    public void startElement(
    String elementNamespaceURI,
    String elementLocalName,
    String elementName) 
    throws SAXException 
    {
        m_currentElemDepth++;

        if (m_needToCallStartDocument)
            startDocumentInternal();		
		
        super.fireStartElem(elementName);
        
        return;
    }


    
    public void characters(String characters) 
    throws SAXException 
    { 
        characters(characters.toCharArray(), 0, characters.length());
    }


    
    public void addAttribute(String name, String value)
    {
        
    }

    public boolean startPrefixMapping(
        String prefix,
        String uri,
        boolean shouldFlush)
        throws SAXException
    {
        
        return false;
    }


    public void startPrefixMapping(String prefix, String uri)
        throws org.xml.sax.SAXException
    {
        
    }


    public void namespaceAfterStartElement(
        final String prefix,
        final String uri)
        throws SAXException
    {
        
    }    

    public void flushPending()
    {
        try
        {
            if (m_needToCallStartDocument)
            {
                startDocumentInternal();
                m_needToCallStartDocument = false;
            }
        }
        catch (SAXException e)
        { 
            
        }
    }
}
"
org.apache.xpath.axes.NodeSequence,37,3,1,9,68,212,1,8,34,0.625,711,1.0,2,0.682692308,0.171171171,2,9,18.10810811,12,2.2973,0,"
package org.apache.xpath.axes;

import java.util.Vector;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.utils.NodeVector;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;


public class NodeSequence extends XObject
  implements DTMIterator, Cloneable, PathComponent
{
  
  protected int m_last = -1;
  
  
  protected int m_next = 0;
    
  
  protected NodeVector getVector()
  {
  	return (NodeVector)m_obj;
  }
  
  
  protected void SetVector(NodeVector v)
  {
  	m_obj = v;
  }

  
  
  public boolean hasCache()
  {
  	return (m_obj != null);
  }


  
  protected DTMIterator m_iter;
  
  
  public final void setIter(DTMIterator iter)
  {
  	m_iter = iter;
  }
  
  
  public final DTMIterator getContainedIter()
  {
  	return m_iter;
  }
  
  
  protected DTMManager m_dtmMgr;
  
  
  
  
  public NodeSequence(DTMIterator iter, int context, XPathContext xctxt, boolean shouldCacheNodes)
  {
  	setIter(iter);
  	setRoot(context, xctxt);
  	setShouldCacheNodes(shouldCacheNodes);
  }
  
  
  public NodeSequence(Object nodeVector)
  {
  	super(nodeVector);
  	if(null != nodeVector)
  	{
  		assertion(nodeVector instanceof NodeVector, 
  			""Must have a NodeVector as the object for NodeSequence!"");
  		if(nodeVector instanceof DTMIterator)
  		{
  			setIter((DTMIterator)nodeVector);
  			m_last = ((DTMIterator)nodeVector).getLength();
  		}
  		
  	}
  }
  
  
  public NodeSequence(DTMManager dtmMgr)
  {
    super(new NodeVector());
    m_last = 0;
    m_dtmMgr = dtmMgr;
  }

  
  
  public NodeSequence()
  {
  }


  
  public DTM getDTM(int nodeHandle)
  {
  	DTMManager mgr = getDTMManager();
  	if(null != mgr)
    	return getDTMManager().getDTM(nodeHandle);
    else
    {
    	assertion(false, ""Can not get a DTM Unless a DTMManager has been set!"");
    	return null;
    }
  }

  
  public DTMManager getDTMManager()
  {
    return m_dtmMgr;
  }

  
  public int getRoot()
  {
  	if(null != m_iter)
    	return m_iter.getRoot();
  	else
  	{
  		
  		
  		
  		return DTM.NULL;
  	}
  }

  
  public void setRoot(int nodeHandle, Object environment)
  {
  	if(null != m_iter)
  	{
  		XPathContext xctxt = (XPathContext)environment;
  		m_dtmMgr = xctxt.getDTMManager();
  		m_iter.setRoot(nodeHandle, environment);
  		if(!m_iter.isDocOrdered())
  		{
  			if(!hasCache())
  				setShouldCacheNodes(true);
  			runTo(-1);
  			m_next=0;
  		}
  	}
  	else
  		assertion(false, ""Can not setRoot on a non-iterated NodeSequence!"");
  }

  
  public void reset()
  {
  	m_next = 0;
  	
  }

  
  public int getWhatToShow()
  {
    return hasCache() ? (DTMFilter.SHOW_ALL & ~DTMFilter.SHOW_ENTITY_REFERENCE) 
    	: m_iter.getWhatToShow();
  }

  
  public boolean getExpandEntityReferences()
  {
  	if(null != m_iter)
  		return m_iter.getExpandEntityReferences();
  	else
    	return true;
  }

  
  public int nextNode()
  {
    
    
    NodeVector vec = getVector();
    if (null != vec)
    {	
    	if(m_next < vec.size())
    	{
			int next = vec.elementAt(m_next);
	    	m_next++;
	    	return next;
    	}
    	else if((-1 != m_last) || (null == m_iter))
    	{
    		m_next++;
    		return DTM.NULL;
    	}
    }
    
  if (null == m_iter)
    return DTM.NULL;
  
 	int next = m_iter.nextNode();
    if(DTM.NULL != next)
    {
    	if(hasCache())
    	{
    		if(m_iter.isDocOrdered())
    	    {
    			getVector().addElement(next);
    			m_next++;
    		}
    		else
    		{
    			int insertIndex = addNodeInDocOrder(next);
    			if(insertIndex >= 0)
    				m_next++;
    		}
    	}
    	else
    		m_next++;
    }
    else
    {
    	m_last = m_next;
    	m_next++;
    }
    	
    return next;
  }

  
  public int previousNode()
  {
  	if(hasCache())
  	{
  		if(m_next <= 0)
  			return DTM.NULL;
  		else
  		{
  			m_next--;
  			return item(m_next);
  		}
  	}
  	else
  	{
	    int n = m_iter.previousNode();
	    m_next = m_iter.getCurrentPos();
	    return m_next;
  	}
  }

  
  public void detach()
  {
  	if(null != m_iter)
  		m_iter.detach();
  	super.detach();
  }

  
  public void allowDetachToRelease(boolean allowRelease)
  {
  	if((false == allowRelease) && !hasCache())
  	{
  		setShouldCacheNodes(true);
  	}
  	
  	if(null != m_iter)
  		m_iter.allowDetachToRelease(allowRelease);
  	super.allowDetachToRelease(allowRelease);
  }

  
  public int getCurrentNode()
  {
  	if(hasCache())
  	{
  		int currentIndex = m_next-1;
  		NodeVector vec = getVector();
  		if((currentIndex >= 0) && (currentIndex < vec.size()))
  			return vec.elementAt(currentIndex);
  		else
  			return DTM.NULL;
  	}
  	
  	if(null != m_iter)
  	{
    	return m_iter.getCurrentNode();
  	}
  	else
  		return DTM.NULL;
  }

  
  public boolean isFresh()
  {
    return (0 == m_next);
  }

  
  public void setShouldCacheNodes(boolean b)
  {
    if (b)
    {
      if(!hasCache())
      {
        SetVector(new NodeVector());
      }


    }
    else
      SetVector(null);
  }

  
  public boolean isMutable()
  {
    return hasCache(); 
  }

  
  public int getCurrentPos()
  {
    return m_next;
  }

  
  public void runTo(int index)
  {
    int n;
    
    if (-1 == index)
    {
      int pos = m_next;
      while (DTM.NULL != (n = nextNode()));
      m_next = pos;
    }
    else if(m_next == index)
    {
      return;
    }
    else if(hasCache() && m_next < getVector().size())
    {
      m_next = index;
    }
    else if((null == getVector()) && (index < m_next))
    {
      while ((m_next >= index) && DTM.NULL != (n = previousNode()));
    }
    else
    {   
      while ((m_next < index) && DTM.NULL != (n = nextNode()));
    }
    
  }

  
  public void setCurrentPos(int i)
  {
  	runTo(i);
  }

  
  public int item(int index)
  {
  	setCurrentPos(index);
  	int n = nextNode();
  	m_next = index;
  	return n;
  }

  
  public void setItem(int node, int index)
  {
  	NodeVector vec = getVector();
  	if(null != vec)
  	{
  		vec.setElementAt(node, index);
  		m_last = vec.size();
  	}
  	else
  		m_iter.setItem(node, index);
  }

  
  public int getLength()
  {
  	if(hasCache())
  	{
        
        
        
        if (m_iter instanceof NodeSetDTM)
        {
            return m_iter.getLength();
        }    
        
	  	if(-1 == m_last)
	  	{
	  		int pos = m_next;
	  		runTo(-1);
	  		m_next = pos;
	  	}
	    return m_last;
  	}
  	else
  	{
  		return (-1 == m_last) ? (m_last = m_iter.getLength()) : m_last;
  	}
  }

  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {
  	NodeSequence seq = (NodeSequence)super.clone();
    seq.m_next = 0;
    return seq;
  }
  
  
  public Object clone() throws CloneNotSupportedException
  {
  	return super.clone();
  }


  
  public boolean isDocOrdered()
  {
  	if(null != m_iter)
  		return m_iter.isDocOrdered();
  	else
    	return true; 
  }

  
  public int getAxis()
  {
  	if(null != m_iter)
    	return m_iter.getAxis();
    else
    {
    	assertion(false, ""Can not getAxis from a non-iterated node sequence!"");
    	return 0;
    }
  }

  
  public int getAnalysisBits()
  {
  	if((null != m_iter) && (m_iter instanceof PathComponent))
    	return ((PathComponent)m_iter).getAnalysisBits();
    else
    	return 0;
  }

  
  public void fixupVariables(Vector vars, int globalsSize)
  {
  	super.fixupVariables(vars, globalsSize);
  }  
  
  
   protected int addNodeInDocOrder(int node)
   {
      assertion(hasCache(), ""addNodeInDocOrder must be done on a mutable sequence!"");

      int insertIndex = -1;
      
      NodeVector vec = getVector();

      
      
      
      int size = vec.size(), i;

      for (i = size - 1; i >= 0; i--)
      {
        int child = vec.elementAt(i);

        if (child == node)
        {
          i = -2; 

          break;
        }

        DTM dtm = m_dtmMgr.getDTM(node);
        if (!dtm.isNodeAfter(node, child))
        {
          break;
        }
      }

      if (i != -2)
      {
        insertIndex = i + 1;

        vec.insertElementAt(node, insertIndex);
      }

      
      return insertIndex;
    } 
}

"
org.apache.xalan.xsltc.compiler.util.StringStack,4,5,0,0,8,6,0,0,4,2.0,20,0.0,0,0.963855422,0.625,0,0,4.0,1,0.75,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Stack;

public final class StringStack extends Stack {
    public String peekString() {
	return (String) super.peek();
    }
	
    public String popString() {
	return (String) super.pop();
    }
	
    public String pushString(String val) {
	return (String) super.push(val);
    }		
}
"
org.apache.xalan.processor.ProcessorDecimalFormat,2,4,0,6,9,1,1,5,1,2.0,27,0.0,0,0.995260664,0.625,2,2,12.5,1,0.5,2,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.DecimalFormatProperties;
import org.xml.sax.Attributes;


class ProcessorDecimalFormat extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    DecimalFormatProperties dfp = new DecimalFormatProperties(handler.nextUid());

    setPropertiesFromAttributes(handler, rawName, attributes, dfp);
    handler.getStylesheet().setDecimalFormat(dfp);
    
    handler.getStylesheet().appendChild(dfp);
  }
}
"
org.apache.xalan.xsltc.dom.SortingIterator,11,2,0,5,26,0,0,5,8,0.666666667,272,1.0,3,0.565217391,0.309090909,1,7,23.18181818,4,1.6364,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;

public final class SortingIterator extends DTMAxisIteratorBase {
    private final static int INIT_DATA_SIZE = 16;

    private DTMAxisIterator _source;
    private NodeSortRecordFactory _factory;

    private NodeSortRecord[] _data;
    private int _free = 0;
    private int _current;	

    public SortingIterator(DTMAxisIterator source, 
			   NodeSortRecordFactory factory) {
	_source = source;
	_factory = factory;
    }

    public int next() {
	return _current < _free ? _data[_current++].getNode() : END;
    }
	
    public DTMAxisIterator setStartNode(int node) {
	try {
	    _source.setStartNode(_startNode = node);
	    _data = new NodeSortRecord[INIT_DATA_SIZE];
	    _free = 0;

	    
	    while ((node = _source.next()) != END) {
		addRecord(_factory.makeNodeSortRecord(node,_free));
	    }
	    
	    quicksort(0, _free - 1);

	    _current = 0;
	    return this;
	}
	catch (Exception e) {
	    return this;
	}
    }
	
    public int getPosition() {
	return _current == 0 ? 1 : _current;
    }

    public int getLast() {
	return _free;
    }

    public void setMark() {
	_source.setMark();
	_markedNode = _current;
    }

    public void gotoMark() {
	_source.gotoMark();
	_current = _markedNode;
    }
    
    
    public DTMAxisIterator cloneIterator() {
	try {
	    final SortingIterator clone = (SortingIterator) super.clone();
	    clone._source = _source.cloneIterator();  
	    clone._factory = _factory;		
	    clone._data = _data;		
	    clone._free = _free;
	    clone._current = _current;
	    clone.setRestartable(false);
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }

    private void addRecord(NodeSortRecord record) {
	if (_free == _data.length) {
	    NodeSortRecord[] newArray = new NodeSortRecord[_data.length * 2];
	    System.arraycopy(_data, 0, newArray, 0, _free);
	    _data = newArray;
	}
	_data[_free++] = record;
    }

    private void quicksort(int p, int r) {
	while (p < r) {
	    final int q = partition(p, r);
	    quicksort(p, q);
	    p = q + 1;
	}
    }
    
    private int partition(int p, int r) {
	final NodeSortRecord x = _data[(p + r) >>> 1];
	int i = p - 1;
	int j = r + 1;
	while (true) {
	    while (x.compareTo(_data[--j]) < 0);
	    while (x.compareTo(_data[++i]) > 0);
	    if (i < j) {
		final NodeSortRecord t = _data[i];
		_data[i] = _data[j];
		_data[j] = t;
	    }
	    else {
		return(j);
	    }
	}
    }
}
"
org.apache.xalan.xsltc.runtime.ErrorMessages_no,3,3,0,0,4,1,0,0,2,0.5,195,1.0,0,0.974358974,1.0,0,0,63.66666667,1,0.3333,0,"

package org.apache.xalan.xsltc.runtime;

import java.util.ListResourceBundle;

public class ErrorMessages_no extends ListResourceBundle {


    
    
    private static final Object[][] m_errorMessages = {
	{BasisLibrary.RUN_TIME_INTERNAL_ERR,
	""Intern programfeil i ''{0}''""},

	{BasisLibrary.RUN_TIME_COPY_ERR,
	""Programfeil under utføing av <xsl:copy>.""},

	{BasisLibrary.DATA_CONVERSION_ERR,
	""Ugyldig konvertering av ''{0}'' fra ''{1}''.""},

	{BasisLibrary.EXTERNAL_FUNC_ERR,
	""Ekstern funksjon ''{0}'' er ikke støttet av XSLTC.""},

	{BasisLibrary.EQUALITY_EXPR_ERR,
	""Ugyldig argument i EQUALITY uttrykk.""},

	{BasisLibrary.INVALID_ARGUMENT_ERR,
	""Ugyldig argument ''{0}'' i kall til ''{1}''""},

	{BasisLibrary.FORMAT_NUMBER_ERR,
	""Forsøk på å formattere nummer ''{0}'' med ''{1}''.""},

	{BasisLibrary.ITERATOR_CLONE_ERR,
	""Kan ikke klone iterator ''{0}''.""},

	{BasisLibrary.AXIS_SUPPORT_ERR,
	""Iterator for axis ''{0}'' er ikke stèttet.""},

	{BasisLibrary.TYPED_AXIS_SUPPORT_ERR,
	""Iterator for typet axis ''{0}'' er ikke stèttet.""},

	{BasisLibrary.STRAY_ATTRIBUTE_ERR,
	""Attributt ''{0}'' utenfor element.""},

	{BasisLibrary.STRAY_NAMESPACE_ERR,
	""Navnedeklarasjon ''{0}''=''{1}'' utenfor element.""},

	{BasisLibrary.NAMESPACE_PREFIX_ERR,
	""Prefix ''{0}'' er ikke deklartert.""},

	{BasisLibrary.DOM_ADAPTER_INIT_ERR,
	""Forsøk på å instansiere DOMAdapter med feil type DOM.""}

    };

    public Object[][] getContents() {
        return m_errorMessages;
    }
}
"
org.apache.xml.utils.res.XResources_el,3,4,0,1,4,1,0,1,2,0.5,575,0.0,0,0.976190476,1.0,0,0,190.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_el extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""el"" }, { ""help_language"", ""el"" }, { ""language"", ""el"" },
    { ""alphabet"",
      new char[]{ 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7,
                  0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be,
                  0x03bf, 0x03c0, 0x03c1, 0x03c2, 0x03c3, 0x03c4, 0x03c5,
                  0x03c6, 0x03c7, 0x03c8, 0x03c9 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""precedes"" },

    
    
    
    { ""numberGroups"", new int[]{ 100, 10, 1 } },

    
    { ""multiplier"", new long[]{ 1000 } },
    { ""multiplierChar"", new char[]{ 0x03d9 } },

    
    { ""zero"", new char[0] },

    
    { ""digits"",
      new char[]{ 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03db, 0x03b6,
                  0x03b7, 0x03b8 } },
    { ""tens"",
      new char[]{ 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf,
                  0x03c0, 0x03df } },
    { ""hundreds"",
      new char[]{ 0x03c1, 0x03c2, 0x03c4, 0x03c5, 0x03c6, 0x03c7, 0x03c8,
                  0x03c9, 0x03e1 } },

    
    
    { ""tables"", new String[]{ ""hundreds"", ""tens"", ""digits"" } }
  };
}
"
org.apache.xml.dtm.DTMDOMException,2,5,0,3,3,1,3,0,2,2.0,12,0.0,0,1.0,0.833333333,0,0,5.0,0,0.0,1,"
package org.apache.xml.dtm;


public class DTMDOMException extends org.w3c.dom.DOMException
{
  
  public DTMDOMException(short code, String message)
  {
    super(code, message);
  }

  
  public DTMDOMException(short code)
  {
    super(code, """");
  }
}
"
org.apache.xml.utils.res.XResources_es,3,4,0,1,4,1,0,1,2,0.5,314,0.0,0,0.976190476,1.0,0,0,103.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_es extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""es"" }, { ""help_language"", ""es"" }, { ""language"", ""es"" },
    { ""alphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    
    
    
    
    
    
    
    
    
  };
}
"
org.apache.xalan.res.XSLTErrorResources_es,3,4,0,1,4,1,0,1,2,1.423076923,3769,0.0,0,0.976190476,1.0,0,0,1251.0,1,0.3333,0,"
package org.apache.xalan.res;



public class XSLTErrorResources_es extends XSLTErrorResources
{

  
  public static final int MAX_CODE = 201;          

  
  public static final int MAX_WARNING = 29;

  
  public static final int MAX_OTHERS = 55;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  

  public static final Object[][] contents = {
  
  

  {
    ""ERROR0000"", ""{0}""},

  
  

  {
    ER_NO_CURLYBRACE,
      ""Error: No se puede incluir '{' en una expresión""},

  
  

  {
    ER_ILLEGAL_ATTRIBUTE, ""{0} tiene un atributo no permitido: {1}""},

  
	  

  {
    ER_NULL_SOURCENODE_APPLYIMPORTS,
      ""sourceNode es nulo en xsl:apply-imports.""},

  
  

  {
    ER_CANNOT_ADD, ""No se puede añadir {0} a {1}""},

  
  

  {
    ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES,
      ""sourceNode es nulo en handleApplyTemplatesInstruction.""},

  
  

  {
    ER_NO_NAME_ATTRIB, ""{0} debe tener un atributo de nombre.""},

  
  

  {
    ER_TEMPLATE_NOT_FOUND, ""No se ha encontrado ninguna plantilla con el nombre: {0}""},

  
  

  {
    ER_CANT_RESOLVE_NAME_AVT,
      ""No se ha podido convertir el nombre AVT en xsl:call-template.""},

  
  

  {
    ER_REQUIRES_ATTRIB, ""{0} necesita un atributo: {1}""},

  
  

  {
    ER_MUST_HAVE_TEST_ATTRIB,
      ""{0} debe tener un atributo ''test''.""},

  
  

  {
    ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""Valor erróneo en un atributo de nivel: {0}""},

  
  

  {
    ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""el nombre de la instrucción de procesamiento no puede ser 'xml'""},

  
  

  {
    ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""el nombre de la instrucción de procesamiento debe ser un NCName válido: {0}""},

  
  

  {
    ER_NEED_MATCH_ATTRIB,
      ""{0} debe tener un atributo de búsqueda si tiene un modo.""},

  
  

  {
    ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0} necesita un atributo de nombre o de búsqueda.""},

  
  

  {
    ER_CANT_RESOLVE_NSPREFIX,
      ""No se puede convertir el prefijo de espacio de nombre: {0}""},

  
  

  {
    ER_ILLEGAL_VALUE, ""xml:space tiene un valor no permitido: {0}""},

  
  

  {
    ER_NO_OWNERDOC,
      ""El nodo hijo no tiene documento propietario.""},

  
  

  {
    ER_ELEMTEMPLATEELEM_ERR, ""Error ElemTemplateElement: {0}""},

  
  

  {
    ER_NULL_CHILD, ""Intentando agregar un hijo nulo.""},

  
  

  {
    ER_NEED_SELECT_ATTRIB, ""{0} necesita un atributo de selección.""},

  

  

  {
    ER_NEED_TEST_ATTRIB,
      ""xsl:when debe tener un atributo 'test'.""},

  
  

  {
    ER_NEED_NAME_ATTRIB,
      ""xsl:with-param debe tener un atributo 'name'.""},

  
  

  {
    ER_NO_CONTEXT_OWNERDOC,
      ""el contexto no tiene documento propietario.""},

  
  

  {
    ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""No se ha podido crear un vínculo XML TransformerFactory: {0}""},

  
  

  {
    ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: El proceso ha fallado.""},

  
  

  {
    ER_NOT_SUCCESSFUL, ""Xalan: ha fallado.""},

  
  

  {
    ER_ENCODING_NOT_SUPPORTED, ""Codificación no admitida: {0}""},

  
  

  {
    ER_COULD_NOT_CREATE_TRACELISTENER,
      ""No se ha podido crear TraceListener: {0}""},

  
  

  {
    ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key necesita un atributo 'name'.""},

  
  


  {
    ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key necesita un atributo 'match'.""},

  
  

  {
    ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key necesita un atributo 'use'.""},

  
  

  {
    ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0} necesita un atributo ''elements''.""},

  
  

  {
    ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} falta el atributo ''prefix''""},

  
  

  {
    ER_BAD_STYLESHEET_URL, ""El URL de la hoja de estilo es erróneo: {0}""},

  
  

  {
    ER_FILE_NOT_FOUND, ""No se ha encontrado el archivo de la hoja de estilo: {0}""},

  
  

  {
    ER_IOEXCEPTION,
      ""Tenía una excepción E/S en el archivo de la hoja de estilo: {0}""},

  
  

  {
    ER_NO_HREF_ATTRIB,
      ""(StylesheetHandler) No se ha encontrado el atributo href para {0}""},

  
  

  {
    ER_STYLESHEET_INCLUDES_ITSELF,
      ""(StylesheetHandler) {0} se incluye a sí mismo directa o indirectamente.""},

  
  

  {
    ER_PROCESSINCLUDE_ERROR,
      ""Error StylesheetHandler.processInclude, {0}""},

  
  

  {
    ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} falta el atributo ''lang''""},

  
  

  {
    ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) ¿elemento {0} mal colocado? Falta el elemento ''component'' del contenedor""},

  
  

  {
    ER_CAN_ONLY_OUTPUT_TO_ELEMENT,

      ""Sólo puede enviarse a Element, DocumentFragment, Document o PrintWriter.""},

  
  

  {
    ER_PROCESS_ERROR, ""Error StylesheetRoot.process""},

  
  

  {
    ER_UNIMPLNODE_ERROR, ""Error UnImplNode: {0}""},

  
  

  {
    ER_NO_SELECT_EXPRESSION,
      ""Error. No se ha encontrado la expresión de selección xpath (-seleccionar).""},

  
  

  {
    ER_CANNOT_SERIALIZE_XSLPROCESSOR,
      ""No se puede serializar un XSLProcessor.""},

  
  

  {
    ER_NO_INPUT_STYLESHEET,
      ""No se ha especificado la entrada de la hoja de estilo.""},

  
  

  {
    ER_FAILED_PROCESS_STYLESHEET,
      ""No se ha podido procesar la hoja de estilo.""},

  
  

  {
    ER_COULDNT_PARSE_DOC, ""No se ha podido analizar sintácticamente el documento {0}.""},

  
  

  {
    ER_COULDNT_FIND_FRAGMENT, ""No se ha encontrado el fragmento: {0}""},

  
  

  {
    ER_NODE_NOT_ELEMENT,
      ""El nodo señalado por el identificador de fragmento no era un elemento: {0}""},

  
  

  {
    ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""for-each debe tener un atributo de búsqueda o de nombre""},

  
  

  {
    ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB,
      ""las plantillas deben tener un atributo de búsqueda o de nombre""},

  
  

  {
    ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""No existe clon de un fragmento de un documento""},

  
  

  {
    ER_CANT_CREATE_ITEM,
      ""No se puede crear el elemento en el árbol de resultados: {0}""},

  
  

  {
    ER_XMLSPACE_ILLEGAL_VALUE,
      ""xml:space en el XML fuente tiene un valor no permitido: {0}""},

  
  

  {
    ER_NO_XSLKEY_DECLARATION,
      ""No existe ninguna declaración xsl:key para {0}.""},

  
  

  {
    ER_CANT_CREATE_URL, ""Error. No se puede crear el url para: {0}""},

  
  

  {
    ER_XSLFUNCTIONS_UNSUPPORTED, ""xsl:functions no se admite""},

  
  

  {
    ER_PROCESSOR_ERROR, ""Error XSLT TransformerFactory""},

  
  

  {
    ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""(StylesheetHandler) {0} no se permite en una hoja de estilo.""},

  
  

  {
    ER_RESULTNS_NOT_SUPPORTED,
      ""result-ns ya no se utiliza.  Utilizar en su lugar xsl:output""},

  
  

  {
    ER_DEFAULTSPACE_NOT_SUPPORTED,
      ""default-space ya no se utiliza.  Utilizar en su lugar xsl:strip-space o xsl:preserve-space""},

  
  

  {
    ER_INDENTRESULT_NOT_SUPPORTED,
      ""indent-result ya no se utiliza. Utilizar en su lugar xsl:output""},

  
  

  {
    ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0} tiene un atributo no permitido: {1}""},

  
  

  {
    ER_UNKNOWN_XSL_ELEM, ""Elemento XSL desconocido: {0}""},

  
  

  {
    ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort sólo puede utilizarse con xsl:apply-templates o con xsl:for-each.""},

  
  

  {
    ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) xsl:when mal colocado.""},

  
  

  {
    ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:when no es hijo de xsl:choose.""},

  
  

  {
    ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) xsl:otherwise mal colocado.""},

  
  

  {
    ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:otherwise no es hijo de xsl:choose.""},

  
  

  {
    ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""(StylesheetHandler) {0} no se permite en una plantilla.""},

  
  

  {
    ER_UNKNOWN_EXT_NS_PREFIX,
      ""(StylesheetHandler) {0} prejijo de espacio de nombre de extensión {1} desconocido""},

  
  

  {
    ER_IMPORTS_AS_FIRST_ELEM,
      ""(StylesheetHandler) Las importaciones sólo pueden ser los primeros elementos de la hoja de estilo.""},

  
  

  {
    ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0} se importa a sí mismo directa o indirectamente.""},

  
  

  {
    ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space tiene un valor no permitido: {0}""},


  
  

  {
    ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""processStylesheet ha fallado.""},

  
  

  {
    ER_SAX_EXCEPTION, ""Excepción SAX""},

  
  

  {
    ER_XSLT_ERROR, ""Error XSLT""},

  
  

  {
    ER_CURRENCY_SIGN_ILLEGAL,
      ""el signo de divisa no se permite en la cadena de patrones de formato""},

  
  

  {
    ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""La hoja de estilo DOM no admite la función de documento.""},

  
  

  {
    ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""No se puede convertir el prefijo del convertidor de ausencia de prefijo.""},

  
  

  {
    ER_REDIRECT_COULDNT_GET_FILENAME,
      ""Reencaminar extensión : No se ha podido obtener el nombre del archivo - el atributo de archivo o de selección debe presentar una cadena válida.""},

  
  

  {
    ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""No se puede crear FormatterListener en extensión Redirect.""},

  
  

  {
    ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""El prefijo de exclude-result-prefixes no es válido: {0}""},

  
  

  {
    ER_MISSING_NS_URI,
      ""Falta el URI de espacio de nombre del prefijo especificado""},

  
  

  {
    ER_MISSING_ARG_FOR_OPTION,
      ""Falta el argumento en la opción: {0}""},

  
  

  {
    ER_INVALID_OPTION, ""Opción no válida: {0}""},

  
  

  {
    ER_MALFORMED_FORMAT_STRING, ""Cadena de formato mal construida: {0}""},

  
  

  {
    ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet necesita un atributo 'version'.""},

  
  

  {
    ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""El atributo: {0} tiene un valor no permitido: {1}""},

  
  

  {
    ER_CHOOSE_REQUIRES_WHEN, ""xsl:choose requiere xsl:when""},

  
  

  {
    ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""xsl:apply-imports no se permite en xsl:for-each""},

  
  

  {
    ER_CANT_USE_DTM_FOR_OUTPUT,
      ""No se puede utilizar DTMLiaison con un nodo DOM de salida... utilizar en su lugar org.apache.xpath.DOM2Helper.""},

  
  


  {
    ER_CANT_USE_DTM_FOR_INPUT,
      ""No se puede utilizar DTMLiaison con un nodo DOM de salida... utilizar en su lugar org.apache.xpath.DOM2Helper.""},

  
  

  {
    ER_CALL_TO_EXT_FAILED,
      ""Ha fallado el elemento de llamada a la extensión: {0}""},

  
  

  {
    ER_PREFIX_MUST_RESOLVE,
      ""El prefijo debe convertir un espacio de nombre: {0}""},

  
  

  {
    ER_INVALID_UTF16_SURROGATE,
      ""Se ha detectado un sustituto de UTF-16 no válido: {0} ?""},

  
  

  {
    ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0} se utiliza a sí mismo y provocará un bucle sin fin.""},

  
  

  {
    ER_CANNOT_MIX_XERCESDOM,
      ""No se puede mezclar una entrada no Xerces-DOM con una salida Xerces-DOM.""},

  
  

  {
    ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},

  
  

  {
    ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""En ElemTemplateElement.readObject: {0}""},


  
  

  {
    ER_DUPLICATE_NAMED_TEMPLATE,
      ""Se ha encontrado más de una plantilla con el nombre: {0}""},

  
  

  {
    ER_INVALID_KEY_CALL,
      ""Llamada a función no válida: no se permiten las llamadas con clave recursiva()""},
  
  
  

  {
    ER_REFERENCING_ITSELF,
      ""La variable {0} se refiere a sí misma directa o indirectamente.""},
  
  
  

  {
    ER_ILLEGAL_DOMSOURCE_INPUT,
      ""El nodo de entrada no puede ser nulo para DOMSource en newTemplates.""},
	
	
  

  {
    ER_CLASS_NOT_FOUND_FOR_OPTION,
			""No se ha encontrado el archivo de clase para la opción {0}""},
	
	
  

  {
    ER_REQUIRED_ELEM_NOT_FOUND,
			""No se ha encontrado el elemento requerido: {0}""},
  
  
  

  {
    ER_INPUT_CANNOT_BE_NULL,
			""InputStream no puede ser nulo""},
  
  
  

  {
    ER_URI_CANNOT_BE_NULL,
			""URI no puede ser nulo""},
  
  
  

  {
    ER_FILE_CANNOT_BE_NULL,
			""El archivo no puede ser nulo""},
  
   
  

  {
    ER_SOURCE_CANNOT_BE_NULL,
			""InputSource no puede ser nulo""},
    
  
  

  {
    ER_CANNOT_INIT_BSFMGR,
			""No se ha podido inicializar el administrador de BSF""},
  
  
  

  {
    ER_CANNOT_CMPL_EXTENSN,
			""No se ha podido compilar la extensión""},
  

  
  

  {
    ER_CANNOT_CREATE_EXTENSN,
      ""No se ha podido crear la extensión: {0} debido a: {1}""},
  
  
  

  {
    ER_INSTANCE_MTHD_CALL_REQUIRES,
      ""El primer argumento de la llamada del método de instancia al método {0} necesita una instancia de objeto""},
  
  
  

  {
    ER_INVALID_ELEMENT_NAME,
      ""Se ha especificado un nombre de elemento no válido {0}""},
  
   
  

  {
    ER_ELEMENT_NAME_METHOD_STATIC,
      ""El método del nombre de elemento debe ser estático {0}""},
  
   
  

  {
    ER_EXTENSION_FUNC_UNKNOWN,
             ""La función de extensión {0} : {1} es desconocida""},
  
   
  

  {
    ER_MORE_MATCH_CONSTRUCTOR,
             ""Hay más de una coincidencia óptima para el creador en {0}""},
  
   
  

  {
    ER_MORE_MATCH_METHOD,
             ""Hay más de una coincidencia óptima para el método {0}""},
  
   
  

  {
    ER_MORE_MATCH_ELEMENT,
             ""Hay más de una coincidencia óptima para el método del elemento {0}""},
  
   
  

  {
    ER_INVALID_CONTEXT_PASSED,
             ""El contexto no válido se ha pasado a evaluación {0}""},
  
   
  

  {
    ER_POOL_EXISTS,
             ""El pool ya existe""},
  
   
  

  {
    ER_NO_DRIVER_NAME,
             ""No se ha especificado ningún nombre para el dispositivo""},
  
   
  

  {
    ER_NO_URL,
             ""No se ha especificado ningún URL""},
  
   
  

  {
    ER_POOL_SIZE_LESSTHAN_ONE,
             ""El tamaño del pool es menor que uno.""},
  
   
  

  {
    ER_INVALID_DRIVER,
             ""Se ha especificado un nombre de dispositivo no válido.""},
  
   
  

  {
    ER_NO_STYLESHEETROOT,
             ""No se ha encontrado la raíz de la hoja de estilo.""},
  
   
  

  {
    ER_ILLEGAL_XMLSPACE_VALUE,
         ""Valor no permitido para xml:space""},
  
   
  

  {
    ER_PROCESSFROMNODE_FAILED,
         ""Fallo de processFromNode""},
  
   
  

  {
    ER_RESOURCE_COULD_NOT_LOAD,
        ""El recurso [ {0} ] no ha podido cargar: {1} 
 {2} 	 {3}""},
   
  
   
  

  {
    ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""Tamaño del búfer <=0""},
  
   
  

  {
    ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""Error desconocido al llamar a la extensión""},
  
   
  

  {
    ER_NO_NAMESPACE_DECL,
        ""El prefijo {0} no tiene la declaración de espacio de nombre correspondiente""},
  
   
  

  {
    ER_ELEM_CONTENT_NOT_ALLOWED,
        ""El contenido del elemento no está permitido para lang=javaclass {0}""},
  
   
  

  {
    ER_STYLESHEET_DIRECTED_TERMINATION,
        ""Terminación dirigida a la hoja de estilo""},
  
   
  

  {
    ER_ONE_OR_TWO,
        ""1 ó 2""},
  
   
  

  {
    ER_TWO_OR_THREE,
        ""2 ó 3""},

  
   
  

  {
    ER_COULD_NOT_LOAD_RESOURCE,
        ""No se ha podido cargar {0} (comprobar CLASSPATH), el sistema está utilizando los valores predeterminados""},
  
   
  

  {
    ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""No se puede inicializar las plantillas predeterminadas""},
  
   
  

  {
    ER_RESULT_NULL,
        ""El resultado no debe ser nulo""},
    
   
  

  {
    ER_RESULT_COULD_NOT_BE_SET,
        ""No ha podido establecerse el resultado""},
  
   
  


  {
    ER_NO_OUTPUT_SPECIFIED,
        ""No se ha especificado ninguna salida""},
  
   
  

  {
    ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""No se puede transformar en un resultado del tipo {0}""},
  
   
  

  {
    ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""No se puede transformar una fuente del tipo {0}""},
  
   
  

  {
    ER_NULL_CONTENT_HANDLER,
        ""Manejador de contenido nulo""},
  
   
  

  {
    ER_NULL_ERROR_HANDLER,
        ""Manejador de errores nulo""},
  
   
  

  {
    ER_CANNOT_CALL_PARSE,
        ""no puede invocarse el analizador sintáctico si no se ha establecido el ContentHandler""},
  
   
  

  {
    ER_NO_PARENT_FOR_FILTER,
        ""No existe ningún elemento padre para el filtro""},
  
  
   
  

  {
    ER_NO_STYLESHEET_IN_MEDIA,
         ""No se ha encontrado ninguna hoja de estilo en: {0}, media= {1}""},
  
   
  

  {
    ER_NO_STYLESHEET_PI,
         ""No se ha encontrado xml-stylesheet PI en: {0}""},
  
   
  

  {
    ER_NOT_SUPPORTED,
       ""No se admite: {0}""},
    
   
  

  {
    ER_PROPERTY_VALUE_BOOLEAN,
       ""El valor de propiedad {0} debe ser una instancia booleana""},
  
  
   
  

  {
    ""ER_SRC_ATTRIB_NOT_SUPPORTED"",
       ""el atributo src no se permite todavía para {0}""},
  
  
  

  {
    ER_RESOURCE_COULD_NOT_FIND,
        ""No se ha encontrado el recurso [ {0} ].
 {1}""},
  
   
  

  {
    ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""Propiedad de salida no reconocida: {0}""},
  
   
  

  {
    ER_FAILED_CREATING_ELEMLITRSLT,
        ""Fallo de creación de instancia ElemLiteralResult""},

  
  
  
  

   
  

  {
    ER_VALUE_SHOULD_BE_NUMBER,
        ""El valor de {0} debe contener un número que se pueda analizar""},

  
   
  

  {
    ER_VALUE_SHOULD_EQUAL,
        "" El valor de {0} debe ser igual a sí o no""},
 
   
  

  {
    ER_FAILED_CALLING_METHOD,
        "" Fallo de invocación del método {0}""},
  
   
  

  {
    ER_FAILED_CREATING_ELEMTMPL,
        ""Fallo de creación de instancia ElemTemplateElement""},
  
   
  

  {
    ER_CHARS_NOT_ALLOWED,
        ""No se permiten caracteres en esta parte del documento""},
  
  
  

  {
    ER_ATTR_NOT_ALLOWED,
        ""el atributo ""{0}"" no se permite en el elemento {1}.""},
 
  
  

  {
    ER_BAD_VALUE,
     ""{0} valor erróneo {1} ""},
  
  
  

  {
    ER_ATTRIB_VALUE_NOT_FOUND,
     ""no se ha encontrado el valor del atributo {0}""},
  
  
  

  {
    ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""no se reconoce el valor del atributo {0}""},

  
  

  {
    ER_NULL_URI_NAMESPACE,
     ""Se ha intentado generar un prefijo de espacio de nombre con un URI nulo""},

  

  
  

  {
    ER_NUMBER_TOO_BIG,
     ""Se ha intentado dar formato a un número mayor que el entero Long de mayor tamaño""},

  

  

  {
    ER_CANNOT_FIND_SAX1_DRIVER,
     ""No se puede hallar la clase {0} del controlador SAX1""},

  
  

  {
    ER_SAX1_DRIVER_NOT_LOADED,
     ""Se ha encontrado la clase {0} del controlador SAX1 pero no se puede cargar""},

  
  

  {
    ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""Se ha cargado la clase {0} del controlador SAX1 pero no se puede crear una instancia""},


  
  

  {
    ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
     ""La clase {0} del controlador SAX1 no implementa org.xml.sax.Parser""},

  
  

  {
    ER_PARSER_PROPERTY_NOT_SPECIFIED,
     ""No se ha especificado la propiedad de sistema org.xml.sax.parser""},

  
  

  {
    ER_PARSER_ARG_CANNOT_BE_NULL,
     ""El argumento del analizador sintáctico no debe ser nulo""},


  
  

  {
    ER_FEATURE,
     ""Característica: {0}""},


  
  

  {
    ER_PROPERTY,
     ""Propiedad:{0}""},

  
  

  {
    ER_NULL_ENTITY_RESOLVER,
     ""Convertidor de entidad nulo""},

  
  

  {
    ER_NULL_DTD_HANDLER,
     ""Manejador DTD nulo""},

  
  
  {
    ER_NO_DRIVER_NAME_SPECIFIED,
     ""No se ha especificado un nombre de controlador""},


  
  
  {
    ER_NO_URL_SPECIFIED,
     ""No se ha especificado una URL""},


  
  
  {
    ER_POOLSIZE_LESS_THAN_ONE,
     ""¡El tamaño de pool es inferior a 1!""},


  
  
  {
    ER_INVALID_DRIVER_NAME,
     ""El nombre de controlador especificado no es válido""},



  
  
  {
    ER_ERRORLISTENER,
     ""ErrorListener""},


  
  
  {
    ER_ASSERT_NO_TEMPLATE_PARENT,
     ""Error de programación. expr no tiene ElemTemplateElement padre!""},


  
  
  {
    ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
     ""Confirmación del programador en RundundentExprEliminator: {0}""},

  
  
  {
    ER_NOT_ALLOWED_IN_POSITION,
     ""{0} no está permitido en esta posición de la hoja de estilo""},

  
  
  {
    ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
     ""En esta posición de la hoja de estilo no se admite texto; solo espacios en blanco ""},

  
  
  
  
  {
    INVALID_TCHAR,
     ""Valor no válido: {1} utilizado para el atributo CHAR: {0}.  Un atributo de tipo CHAR debe tener 1 solo carácter""},

    
    
    
    
    

  
  
  
  {
    INVALID_QNAME,
     ""Valor no válido: {1} utilizado para atributo QNAME: {0}""},

    
    
    
    
    
    

  
  
  {
    INVALID_ENUM,
     ""Valor no válido: {1} utilizado para atributo ENUM: {0}.  Los valores válidos son: {2}.""},

  
  
  
  
  

  
  
  {
    INVALID_NMTOKEN,
     ""Valor no válido: {1} utilizado para atributo NMTOKEN: {0}""},

  
  
  
  
  

  
  
  {
    INVALID_NCNAME,
     ""Valor no válido: {1} utilizado para atributo NCNAME : {0}""},

  
  
  
  
  

  
  

  {
    INVALID_BOOLEAN,
     ""Valor no válido: {1} utilizado para atributo booleano: {0}""},







  
  
  {
    INVALID_NUMBER,
     ""Valor no válido: {1} utilizado para atributo de número: {0}""},


  







  
  
  {
    ER_ARG_LITERAL,
     ""El argumento de {0} en el patrón coincidente debe ser literal.""},






  
  
  {
    ER_DUPLICATE_GLOBAL_VAR,
     ""Declaración de variable global duplicada.""},






  
  
  {
    ER_DUPLICATE_VAR,
     ""Declaración de variable duplicada.""},

    
    
    

  
  
  {
    ER_TEMPLATE_NAME_MATCH,
     ""xsl: template debe tener un atributo name o match (o ambos)""},

    
    
    
    
    

  
  
  {
    ER_INVALID_PREFIX,
     ""El prefijo de exclude-result-prefixes no es válido: {0}""},

    
    
    
    
    

  
  
  {
    ER_NO_ATTRIB_SET,
     ""no existe el conjunto de atributos denominado {0}""},


  

  
  

  {
    WG_FOUND_CURLYBRACE,
      ""Se ha encontrado '}' pero no hay abierta ninguna plantilla de atributos.""},

  
  

  {
    WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""Advertencia: el atributo de cómputo no coincide con ningún antecesor en xsl:number. Objetivo = {0}""},

  
  

  {
    WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""Sintaxis antigua: El nombre del atributo 'expr' se ha cambiado por 'select'.""},

  
  

  {
    WG_NO_LOCALE_IN_FORMATNUMBER,

      ""Xalan no maneja todavía el nombre locale en la función format-number.""},

  
  

  {
    WG_LOCALE_NOT_FOUND,
      ""Advertencia: No se ha encontrado locale para xml:lang={0}""},

  
  

  {
    WG_CANNOT_MAKE_URL_FROM,
      ""No se puede crear URL desde: {0}""},

  
  

  {
    WG_CANNOT_LOAD_REQUESTED_DOC,
      ""No se puede cargar el doc solicitado: {0}""},

  
  

  {
    WG_CANNOT_FIND_COLLATOR,
      ""No se ha encontrado Collator para <sort xml:lang={0}""},

  
  

  {
    WG_FUNCTIONS_SHOULD_USE_URL,
      ""Sintaxis antigua: la instrucción de las funciones debe utilizar un url de {0}""},

  
  

  {
    WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""codificación no admitida: {0}, se utiliza UTF-8""},

  
  

  {
    WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      ""codificación no admitida: {0}, se utiliza Java {1}""},

  
  

  {
    WG_SPECIFICITY_CONFLICTS,
      ""Se han encontrado conflictos de especificidad: {0} Se utilizará la última encontrada en la hoja de estilo.""},

  
  

  {
    WG_PARSING_AND_PREPARING,
      ""========= Análisis sintáctico y preparación {0} ==========""},


  
  

  {
    WG_ATTR_TEMPLATE, ""Plantilla atri, {0}""},

  
  

  {
    WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""Conflicto de coincidencia entre xsl:strip-space y xsl:preserve-space""},

  
  

  {
    WG_ATTRIB_NOT_HANDLED,
      ""Xalan no maneja todavía el atributo {0}.""},

  
  

  {
    WG_NO_DECIMALFORMAT_DECLARATION,
      ""No se ha encontrado ninguna declaración para el formato decimal: {0}""},

  
  

  {
    WG_OLD_XSLT_NS, ""Falta el espacio de nombre XSLT o es incorrecto. ""},

  
  

  {
    WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""Sólo se permite una declaración xsl:decimal-format predeterminada.""},

  
  

  {
    WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""los nombres xsl:decimal-format deben ser únicos. El nombre ""{0}"" está duplicado.""},

  
  

  {
    WG_ILLEGAL_ATTRIBUTE,
      ""{0} tiene un atributo no permitido: {1}""},

  
  

  {
    WG_COULD_NOT_RESOLVE_PREFIX,
      ""No se ha podido convertir el prefijo de espacio de nombre : {0}. El nodo se ignorará.""},

  
  

  {
    WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet necesita un atributo 'version'.""},

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_NAME,
      ""Nombre de atributo no permitido: {0}""},

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""Se ha utilizado un valor no permitido para el atributo {0}: {1}""},

  
  

  {
    WG_EMPTY_SECOND_ARG,
      ""El conjunto de nodos resultante del segundo argumento de la función de documento está vacío. Se utilizará el primer argumento.""},

 

    
    
    


  
  
  {
     WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""El valor del atributo 'name' del nombre xsl:processing-instruction no debe ser 'xml'""},

    
    
    
    

  
  
  {
     WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""El valor del atributo ''name'' de xsl:processing-instruction debe ser un nombre NCName válido: {0}""},

    
    
    
    
    

  
  
  {
    WG_ILLEGAL_ATTRIBUTE_POSITION,
      ""No se puede agregar el atributo {0} después de nodos hijos ni antes de generar un elemento.  El atributo no será considerado""},

  


  
    { ""ui_language"", ""es""},
    { ""help_language"", ""es""},
    { ""language"", ""es""},
    { ""BAD_CODE"",
      ""El parámetro para crear el mensaje estaba fuera de los límites""},
    { ""FORMAT_FAILED"",
      ""Excepción generada durante la llamada messageFormat""},
    { ""version"", "">>>>>>> Versión Xalan""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""sí""},
    { ""line"", ""Línea #""},
    { ""column"", ""Columna #""},
    { ""xsldone"", ""XSLProcessor: hecho""},
    { ""xslProc_option"", ""opciones de clase Proceso de la línea de comandos Xalan-J:""},
    { ""optionIN"", ""    -IN inputXMLURL""},
    { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
    { ""optionOUT"", ""   [-OUT outputFileName]""},
    { ""optionLXCIN"", ""   [-LXCIN compiledStylesheetFileNameIn]""},
    { ""optionLXCOUT"", ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
    { ""optionPARSER"",
      ""   [nombre totalmente cualificado -PARSER de clase de vínculo de analizador sintáctico]""},
    { ""optionE"",
     ""   [-E (No expandir refs de entidad)]""},
    { ""optionV"",
     ""   [-E (No expandir refs de entidad)]""},
    {""optionQC"",
      ""   [-QC (Advertencias silenciosas de conflictos de patrones)]""},
    {""optionQ"",
     ""   [-Q  (Modo silencioso)]""},
    { ""optionLF"",
      ""   [-LF (Utilizar cambios de línea sólo en la salida {el valor predeterminado es CR/LF})]""},
    { ""optionCR"",
      ""   [-CR (Utilizar retornos de carro sólo en la salida {el valor predeterminado es CR/LF})]""},
    { ""optionESCAPE"",
      ""   [-ESCAPE (¿Cuáles son los caracteres de escape? {el valor por defecto es <>&""'\r\n}]""},
    { ""optionINDENT"",
      ""   [-INDENT (Controlar el número de espacios de indentación {el valor por defecto es 0})]""},
    { ""optionTT"",
      ""   [-TT (Rastrear las plantillas según se vayan invocando.)]""},
    { ""optionTG"",
      ""   [-TG (Rastrear cada suceso de generación.)]""},
    {""optionTS"",
     ""   [-TS (Rastrear cada suceso de selección.)]""},
    { ""optionTTC"",
      ""   [-TTC (Rastrear las plantillas hijas según se vayan procesando.)]""},
    { ""optionTCLASS"",
      ""   [-TCLASS (Clase TraceListener para las extensiones de rastreo.)]""},
    { ""optionVALIDATE"",
      ""   [-VALIDATE (Establecer si se realiza la validación.  El valor predeterminado de la validación es off.)]""},
    {""optionEDUMP"",
      ""   [-EDUMP {nombre de archivo opcional} (Hacer volcado de pila en caso de error.)]""},
    { ""optionXML"",
      ""   [-XML (Utilizar el formateador XML y agregar la cabecera de XML.)]""},
    { ""optionTEXT"",
      ""   [-TEXT (Utilizar el formateador de texto sencillo.)]""},
    { ""optionHTML"",
     ""   [-HTML (Utilizar el formateador HTML.)]""},
    {""optionPARAM"",
      ""   [expresión de nombre -PARAM (Establecer un parámetro de hoja de estilo)]""},
    { ""noParsermsg1"",
     ""Ha fallado el proceso XSL.""},
    { ""noParsermsg2"",
     ""** No se ha encontrado el analizador sintáctico **""},
    { ""noParsermsg3"",
     ""Comprobar classpath.""},
    { ""noParsermsg4"",
      ""Si no tiene el analizador sintáctico XML para Java de IBM puede cargarlo de ""},
    { ""noParsermsg5"",
      ""AlphaWorks de IBM: http:
    { ""optionURIRESOLVER"",
     ""   [nombre de clase completo -URIRESOLVER (Utilizar URIResolver para convertir los URIs)]""},
    { ""optionENTITYRESOLVER"",
     ""   [nombre de clase completo -ENTITYRESOLVER (Utilizar EntityResolver para convertir las entidades)]""},
    {""optionCONTENTHANDLER"",
     ""   [nombre de clase completo -CONTENTHANDLER (Utilizar ContentHandler para serializar la salida)]""},
    {""optionLINENUMBERS"",
     ""   [-L utilizar números de líneas para el documento fuente]""},
		
    


    { ""optionMEDIA"",
     "" [-MEDIA mediaType (utilice un atributo media para buscar las hojas de estilo asociadas con un documento.)]""},
    { ""optionFLAVOR"",
     "" [-FLAVOR flavorName (utilice explícitamente s2s=SAX o d2d=DOM para la transformación.)] ""}, 
    { ""optionDIAG"",
     "" [-DIAG (la impresión tardó milisegundos.)]""},
    {""optionINCREMENTAL"",
     "" [-INCREMENTAL (solicitar una construcción DTM incremental estableciendo http:
    { ""optionNOOPTIMIMIZE"",
     "" [-NOOPTIMIMIZE (solicitar no optimizar la hoja de estilo estableciendo http:
    { ""optionRL"",
     "" [-RL recursionlimit (afirmar límite numérico en la profundidad de recursividad de la hoja de estilo.)]""},
    { ""optionXO"",
     "" [-XO [transletName] (asignar nombre al translet generado)]""},
    {""optionXD"",
     "" [-XD destinationDirectory (especifica un directorio de destino para translet)]""},
    { ""optionXJ"",
     "" [-XJ jarfile (empaqueta clases translet en un archivo JAR denominado <archivoJAR>)]""},
    { ""optionXP"",
     "" [-XP package (especifica un prefijo de nombre de paquete para todas las clases translet generadas)]""}


  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""Error: "";

  
  public static final String WARNING_HEADER = ""Advertencia: "";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATRÓN "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}

"
org.apache.xpath.operations.Gt,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class Gt extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.greaterThan(right) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.xsltc.compiler.util.NodeType,22,2,0,42,54,199,13,32,20,0.571428571,466,1.0,0,0.622641509,0.215909091,2,4,20.13636364,7,1.4091,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.NodeTest;

public final class NodeType extends Type {
    private final int _type;

    protected NodeType() {
	this(NodeTest.ANODE);
    }

    protected NodeType(int type) {
	_type = type;
    }

    public int getType() {
	return _type;
    }

    public String toString() {
	return ""node-type"";
    }

    public boolean identicalTo(Type other) {
	return other instanceof NodeType;
    }

    public int hashCode() {
	return _type;
    }

    public String toSignature() {
	return ""I"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.INT;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.NodeSet) {
	    translateTo(classGen, methodGen, (NodeSetType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else if (type == Type.Object) {
	    translateTo(classGen, methodGen, (ObjectType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	switch (_type) {
	case NodeTest.ROOT:
	case NodeTest.ELEMENT:
	    il.append(methodGen.loadDOM());
	    il.append(SWAP); 
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  GET_ELEMENT_VALUE,
						  GET_ELEMENT_VALUE_SIG);
	    il.append(new INVOKEINTERFACE(index, 2));
	    break;

	case NodeTest.ANODE:
	case NodeTest.COMMENT:
	case NodeTest.ATTRIBUTE:
	case NodeTest.PI:
	    il.append(methodGen.loadDOM());
	    il.append(SWAP); 
	    index = cpg.addInterfaceMethodref(DOM_INTF,
					      GET_NODE_VALUE,
					      GET_NODE_VALUE_SIG);
	    il.append(new INVOKEINTERFACE(index, 2));
	    break;
	    
	default:
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	    break;
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	FlowList falsel = translateToDesynthesized(classGen, methodGen, type);
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsel.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	translateTo(classGen, methodGen, Type.String);
	Type.String.translateTo(classGen, methodGen, Type.Real);	
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    NodeSetType type) {
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();

	
	il.append(new NEW(cpg.addClass(SINGLETON_ITERATOR)));
	il.append(DUP_X1);
	il.append(SWAP);
	final int init = cpg.addMethodref(SINGLETON_ITERATOR, ""<init>"",
					  ""("" + NODE_SIG +"")V"");
	il.append(new INVOKESPECIAL(init));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ObjectType type) {
	    methodGen.getInstructionList().append(NOP);	
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new NEW(cpg.addClass(RUNTIME_NODE_CLASS)));
	il.append(DUP_X1);
	il.append(SWAP);
	il.append(new PUSH(cpg, _type));
	il.append(new INVOKESPECIAL(cpg.addMethodref(RUNTIME_NODE_CLASS,
						     ""<init>"", ""(II)V"")));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

        String className = clazz.getName();
        if (className.equals(""java.lang.String"")) {
           translateTo(classGen, methodGen, Type.String);
           return;
        }

	il.append(methodGen.loadDOM());
	il.append(SWAP);		

        if (className.equals(""org.w3c.dom.Node"") ||
            className.equals(""java.lang.Object"")) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE,
						  MAKE_NODE_SIG);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else if (className.equals(""org.w3c.dom.NodeList"")) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE_LIST,
						  MAKE_NODE_LIST_SIG);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), className);
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new CHECKCAST(cpg.addClass(RUNTIME_NODE_CLASS)));
	il.append(new GETFIELD(cpg.addFieldref(RUNTIME_NODE_CLASS,
					       NODE_FIELD,
					       NODE_FIELD_SIG)));
    }

    
    public String getClassName() {
	return(RUNTIME_NODE_CLASS);
    }

    public Instruction LOAD(int slot) {
	return new ILOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ISTORE(slot);
    }
}

"
org.apache.xpath.objects.XStringForChars,12,4,0,4,22,4,1,3,11,0.484848485,148,0.333333333,0,0.921875,0.25,3,15,11.08333333,2,1.0,0,"
package org.apache.xpath.objects;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xpath.res.XPATHErrorResources;



public class XStringForChars extends XString
{
  
  int m_start;
  
  
  int m_length;
  
  protected String m_strCache = null;
  
  
  public XStringForChars(char[] val, int start, int length)
  {
    super(val);
    m_start = start;
    m_length = length;
    if(null == val)
      throw new IllegalArgumentException(
                          XSLMessages.createXPATHMessage(XPATHErrorResources.ER_FASTSTRINGBUFFER_CANNOT_BE_NULL, null)); 
  }


  
  private XStringForChars(String val)
  {
    super(val);
    throw new IllegalArgumentException(
                      XSLMessages.createXPATHMessage(XPATHErrorResources.ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING, null)); 
  }
  
  
  public FastStringBuffer fsb()
  {
    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS, null)); 
  }
  
  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    fsb.append((char[])m_obj, m_start, m_length);
  }

  
  
  public boolean hasString()
  {
    return (null != m_strCache);
  }

  
  
  public String str()
  {
    if(null == m_strCache)
      m_strCache = new String((char[])m_obj, m_start, m_length);
    
    return m_strCache;
  }
  

  
  public Object object()
  {
    return str();
  }

  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
      throws org.xml.sax.SAXException
  {
    ch.characters((char[])m_obj, m_start, m_length);
  }
      
  
  public void dispatchAsComment(org.xml.sax.ext.LexicalHandler lh)
      throws org.xml.sax.SAXException
  {
    lh.comment((char[])m_obj, m_start, m_length);
  }
  
  
  public int length()
  {
    return m_length;
  }

  
  public char charAt(int index)
  {
    return ((char[])m_obj)[index+m_start];
  }

  
  public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)
  {
    System.arraycopy((char[])m_obj, m_start+srcBegin, dst, dstBegin, srcEnd);
  }
  
}"
org.apache.xpath.axes.WalkingIteratorSorted,5,6,0,5,13,0,1,5,3,0.25,129,1.0,0,0.979020979,0.366666667,1,1,24.6,17,4.0,1,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.Axis;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.compiler.Compiler;


public class WalkingIteratorSorted extends WalkingIterator
{



  
  
  protected boolean m_inNaturalOrderStatic = false;

  
  public WalkingIteratorSorted(PrefixResolver nscontext)
  {
    super(nscontext);
  }

  
  WalkingIteratorSorted(
          Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers)
            throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, shouldLoadWalkers);
  }
  
  
  public boolean isDocOrdered()
  {
    return m_inNaturalOrderStatic;
  }

    
  
  boolean canBeWalkedInNaturalDocOrderStatic()
  {

    if (null != m_firstWalker)
    {
      AxesWalker walker = m_firstWalker;
      int prevAxis = -1;
      boolean prevIsSimpleDownAxis = true;

      for(int i = 0; null != walker; i++)
      {
        int axis = walker.getAxis();
        
        if(walker.isDocOrdered())
        {
          boolean isSimpleDownAxis = ((axis == Axis.CHILD)
                                   || (axis == Axis.SELF)
                                   || (axis == Axis.ROOT));
          
          
          if(isSimpleDownAxis || (axis == -1))
            walker = walker.getNextWalker();
          else
          {
            boolean isLastWalker = (null == walker.getNextWalker());
            if(isLastWalker)
            {
              if(walker.isDocOrdered() && (axis == Axis.DESCENDANT || 
                 axis == Axis.DESCENDANTORSELF || axis == Axis.DESCENDANTSFROMROOT
                 || axis == Axis.DESCENDANTSORSELFFROMROOT) || (axis == Axis.ATTRIBUTE))
                return true;
            }
            return false;
          }
        }
        else
          return false;
      }
      return true;
    }
    return false;
  }


















































  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);

    int analysis = getAnalysisBits();
    if(WalkerFactory.isNaturalDocOrder(analysis))
    {
    	m_inNaturalOrderStatic = true;
    }
    else
    {
    	m_inNaturalOrderStatic = false;
    	
    	
    }
    
  }

}
"
org.apache.xalan.templates.NamespaceAlias,10,3,0,6,12,37,6,2,10,0.888888889,52,1.0,0,0.956097561,0.4,1,1,3.8,1,0.9,0,"
package org.apache.xalan.templates;


public class NamespaceAlias extends ElemTemplateElement
{
  
  
  public NamespaceAlias(int docOrderNumber)
  {
    super();
    m_docOrderNumber = docOrderNumber;
  }

  
  private String m_StylesheetPrefix;

  
  public void setStylesheetPrefix(String v)
  {
    m_StylesheetPrefix = v;
  }

  
  public String getStylesheetPrefix()
  {
    return m_StylesheetPrefix;
  }
  
  
  private String m_StylesheetNamespace;

  
  public void setStylesheetNamespace(String v)
  {
    m_StylesheetNamespace = v;
  }

  
  public String getStylesheetNamespace()
  {
    return m_StylesheetNamespace;
  }

  
  private String m_ResultPrefix;

  
  public void setResultPrefix(String v)
  {
    m_ResultPrefix = v;
  }

  
  public String getResultPrefix()
  {
    return m_ResultPrefix;
  }
  
  
  private String m_ResultNamespace;

  
  public void setResultNamespace(String v)
  {
    m_ResultNamespace = v;
  }

  
  public String getResultNamespace()
  {
    return m_ResultNamespace;
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeNamespaceAliases(this);
  }

}
"
org.apache.xml.utils.res.XResources_fr,3,4,0,1,4,1,0,1,2,0.5,314,0.0,0,0.976190476,1.0,0,0,103.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_fr extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""fr"" }, { ""help_language"", ""fr"" }, { ""language"", ""fr"" },
    { ""alphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    
    
    
    
    
    
    
    
    
  };
}
"
org.apache.xalan.xsltc.compiler.util.ErrorMsg,16,1,0,52,31,0,52,2,12,1.024836601,470,0.049019608,0,0.0,0.411111111,0,0,22.0,3,0.6875,2,"

package org.apache.xalan.xsltc.compiler.util;

import java.text.MessageFormat;
import java.util.Locale;
import java.util.ResourceBundle;

import org.apache.xalan.xsltc.compiler.Stylesheet;
import org.apache.xalan.xsltc.compiler.SyntaxTreeNode;

public final class ErrorMsg {

    private String _code;
    private int _line;
    private String _message = null;
    private String _url = null;
    Object[] _params = null;

    
    public static final String MULTIPLE_STYLESHEET_ERR = ""MULTIPLE_STYLESHEET_ERR"";
    public static final String TEMPLATE_REDEF_ERR = ""TEMPLATE_REDEF_ERR"";
    public static final String TEMPLATE_UNDEF_ERR = ""TEMPLATE_UNDEF_ERR"";
    public static final String VARIABLE_REDEF_ERR = ""VARIABLE_REDEF_ERR"";
    public static final String VARIABLE_UNDEF_ERR = ""VARIABLE_UNDEF_ERR"";
    public static final String CLASS_NOT_FOUND_ERR = ""CLASS_NOT_FOUND_ERR"";
    public static final String METHOD_NOT_FOUND_ERR = ""METHOD_NOT_FOUND_ERR"";
    public static final String ARGUMENT_CONVERSION_ERR = ""ARGUMENT_CONVERSION_ERR"";
    public static final String FILE_NOT_FOUND_ERR = ""FILE_NOT_FOUND_ERR"";
    public static final String INVALID_URI_ERR = ""INVALID_URI_ERR"";
    public static final String FILE_ACCESS_ERR = ""FILE_ACCESS_ERR"";
    public static final String MISSING_ROOT_ERR = ""MISSING_ROOT_ERR"";
    public static final String NAMESPACE_UNDEF_ERR = ""NAMESPACE_UNDEF_ERR"";
    public static final String FUNCTION_RESOLVE_ERR = ""FUNCTION_RESOLVE_ERR"";
    public static final String NEED_LITERAL_ERR = ""NEED_LITERAL_ERR"";
    public static final String XPATH_PARSER_ERR = ""XPATH_PARSER_ERR"";
    public static final String REQUIRED_ATTR_ERR = ""REQUIRED_ATTR_ERR"";
    public static final String ILLEGAL_CHAR_ERR = ""ILLEGAL_CHAR_ERR"";
    public static final String ILLEGAL_PI_ERR = ""ILLEGAL_PI_ERR"";
    public static final String STRAY_ATTRIBUTE_ERR = ""STRAY_ATTRIBUTE_ERR"";
    public static final String ILLEGAL_ATTRIBUTE_ERR = ""ILLEGAL_ATTRIBUTE_ERR"";
    public static final String CIRCULAR_INCLUDE_ERR = ""CIRCULAR_INCLUDE_ERR"";
    public static final String RESULT_TREE_SORT_ERR = ""RESULT_TREE_SORT_ERR"";
    public static final String SYMBOLS_REDEF_ERR = ""SYMBOLS_REDEF_ERR"";
    public static final String XSL_VERSION_ERR = ""XSL_VERSION_ERR"";
    public static final String CIRCULAR_VARIABLE_ERR = ""CIRCULAR_VARIABLE_ERR"";
    public static final String ILLEGAL_BINARY_OP_ERR = ""ILLEGAL_BINARY_OP_ERR"";
    public static final String ILLEGAL_ARG_ERR = ""ILLEGAL_ARG_ERR"";
    public static final String DOCUMENT_ARG_ERR = ""DOCUMENT_ARG_ERR"";
    public static final String MISSING_WHEN_ERR = ""MISSING_WHEN_ERR"";
    public static final String MULTIPLE_OTHERWISE_ERR = ""MULTIPLE_OTHERWISE_ERR"";
    public static final String STRAY_OTHERWISE_ERR = ""STRAY_OTHERWISE_ERR"";
    public static final String STRAY_WHEN_ERR = ""STRAY_WHEN_ERR"";
    public static final String WHEN_ELEMENT_ERR = ""WHEN_ELEMENT_ERR"";
    public static final String UNNAMED_ATTRIBSET_ERR = ""UNNAMED_ATTRIBSET_ERR"";
    public static final String ILLEGAL_CHILD_ERR = ""ILLEGAL_CHILD_ERR"";
    public static final String ILLEGAL_ELEM_NAME_ERR = ""ILLEGAL_ELEM_NAME_ERR"";
    public static final String ILLEGAL_ATTR_NAME_ERR = ""ILLEGAL_ATTR_NAME_ERR"";
    public static final String ILLEGAL_TEXT_NODE_ERR = ""ILLEGAL_TEXT_NODE_ERR"";
    public static final String SAX_PARSER_CONFIG_ERR = ""SAX_PARSER_CONFIG_ERR"";
    public static final String INTERNAL_ERR = ""INTERNAL_ERR"";
    public static final String UNSUPPORTED_XSL_ERR = ""UNSUPPORTED_XSL_ERR"";
    public static final String UNSUPPORTED_EXT_ERR = ""UNSUPPORTED_EXT_ERR"";
    public static final String MISSING_XSLT_URI_ERR = ""MISSING_XSLT_URI_ERR"";
    public static final String MISSING_XSLT_TARGET_ERR = ""MISSING_XSLT_TARGET_ERR"";
    public static final String NOT_IMPLEMENTED_ERR = ""NOT_IMPLEMENTED_ERR"";
    public static final String NOT_STYLESHEET_ERR = ""NOT_STYLESHEET_ERR"";
    public static final String ELEMENT_PARSE_ERR = ""ELEMENT_PARSE_ERR"";
    public static final String KEY_USE_ATTR_ERR = ""KEY_USE_ATTR_ERR"";
    public static final String OUTPUT_VERSION_ERR = ""OUTPUT_VERSION_ERR"";
    public static final String ILLEGAL_RELAT_OP_ERR = ""ILLEGAL_RELAT_OP_ERR"";
    public static final String ATTRIBSET_UNDEF_ERR = ""ATTRIBSET_UNDEF_ERR"";
    public static final String ATTR_VAL_TEMPLATE_ERR = ""ATTR_VAL_TEMPLATE_ERR"";
    public static final String UNKNOWN_SIG_TYPE_ERR = ""UNKNOWN_SIG_TYPE_ERR"";
    public static final String DATA_CONVERSION_ERR = ""DATA_CONVERSION_ERR"";

    
    public static final String NO_TRANSLET_CLASS_ERR = ""NO_TRANSLET_CLASS_ERR"";
    public static final String NO_MAIN_TRANSLET_ERR = ""NO_MAIN_TRANSLET_ERR"";
    public static final String TRANSLET_CLASS_ERR = ""TRANSLET_CLASS_ERR"";
    public static final String TRANSLET_OBJECT_ERR = ""TRANSLET_OBJECT_ERR"";
    public static final String ERROR_LISTENER_NULL_ERR = ""ERROR_LISTENER_NULL_ERR"";
    public static final String JAXP_UNKNOWN_SOURCE_ERR = ""JAXP_UNKNOWN_SOURCE_ERR"";
    public static final String JAXP_NO_SOURCE_ERR = ""JAXP_NO_SOURCE_ERR"";
    public static final String JAXP_COMPILE_ERR = ""JAXP_COMPILE_ERR"";
    public static final String JAXP_INVALID_ATTR_ERR = ""JAXP_INVALID_ATTR_ERR"";
    public static final String JAXP_SET_RESULT_ERR = ""JAXP_SET_RESULT_ERR"";
    public static final String JAXP_NO_TRANSLET_ERR = ""JAXP_NO_TRANSLET_ERR"";
    public static final String JAXP_NO_HANDLER_ERR = ""JAXP_NO_HANDLER_ERR"";
    public static final String JAXP_NO_RESULT_ERR = ""JAXP_NO_RESULT_ERR"";
    public static final String JAXP_UNKNOWN_PROP_ERR = ""JAXP_UNKNOWN_PROP_ERR"";
    public static final String SAX2DOM_ADAPTER_ERR = ""SAX2DOM_ADAPTER_ERR"";
    public static final String XSLTC_SOURCE_ERR = ""XSLTC_SOURCE_ERR"";

    
    public static final String COMPILE_STDIN_ERR = ""COMPILE_STDIN_ERR"";
    public static final String COMPILE_USAGE_STR = ""COMPILE_USAGE_STR"";
    public static final String TRANSFORM_USAGE_STR = ""TRANSFORM_USAGE_STR"";

    
    public static final String STRAY_SORT_ERR = ""STRAY_SORT_ERR"";
    public static final String UNSUPPORTED_ENCODING = ""UNSUPPORTED_ENCODING"";
    public static final String SYNTAX_ERR = ""SYNTAX_ERR"";
    public static final String CONSTRUCTOR_NOT_FOUND = ""CONSTRUCTOR_NOT_FOUND"";
    public static final String NO_JAVA_FUNCT_THIS_REF = ""NO_JAVA_FUNCT_THIS_REF"";
    public static final String TYPE_CHECK_ERR = ""TYPE_CHECK_ERR"";
    public static final String TYPE_CHECK_UNK_LOC_ERR = ""TYPE_CHECK_UNK_LOC_ERR"";
    public static final String ILLEGAL_CMDLINE_OPTION_ERR = ""ILLEGAL_CMDLINE_OPTION_ERR"";
    public static final String CMDLINE_OPT_MISSING_ARG_ERR = ""CMDLINE_OPT_MISSING_ARG_ERR"";
    public static final String WARNING_PLUS_WRAPPED_MSG = ""WARNING_PLUS_WRAPPED_MSG"";
    public static final String WARNING_MSG = ""WARNING_MSG"";
    public static final String FATAL_ERR_PLUS_WRAPPED_MSG = ""FATAL_ERR_PLUS_WRAPPED_MSG"";
    public static final String FATAL_ERR_MSG = ""FATAL_ERR_MSG"";
    public static final String ERROR_PLUS_WRAPPED_MSG = ""ERROR_PLUS_WRAPPED_MSG"";
    public static final String ERROR_MSG = ""ERROR_MSG"";
    public static final String TRANSFORM_WITH_TRANSLET_STR = ""TRANSFORM_WITH_TRANSLET_STR"";
    public static final String TRANSFORM_WITH_JAR_STR = ""TRANSFORM_WITH_JAR_STR"";
    public static final String COULD_NOT_CREATE_TRANS_FACT = ""COULD_NOT_CREATE_TRANS_FACT"";
    
    
    
    private static ResourceBundle _bundle;
    
    public final static String ERROR_MESSAGES_KEY   = ""ERROR_MESSAGES_KEY"";
    public final static String COMPILER_ERROR_KEY   = ""COMPILER_ERROR_KEY"";
    public final static String COMPILER_WARNING_KEY = ""COMPILER_WARNING_KEY"";
    public final static String RUNTIME_ERROR_KEY    = ""RUNTIME_ERROR_KEY"";

    static {
        _bundle = ResourceBundle.getBundle(
                          ""org.apache.xalan.xsltc.compiler.util.ErrorMessages"",
                          Locale.getDefault());
    }

    public ErrorMsg(String code) {
	_code = code;
	_line = 0;
    }
	
    public ErrorMsg(Throwable e) {
   	_code = null;
	_message = e.getMessage();
	_line = 0;
    }

    public ErrorMsg(String message, int line) {
	_code = null;
	_message = message;
	_line = line;
    }

    public ErrorMsg(String code, int line, Object param) {
	_code = code;
	_line = line;
	_params = new Object[] { param };
    }

    public ErrorMsg(String code, Object param) {
	this(code);
	_params = new Object[1];
	_params[0] = param;
    }

    public ErrorMsg(String code, Object param1, Object param2) {
	this(code);
	_params = new Object[2];
	_params[0] = param1;
	_params[1] = param2;
    }

    public ErrorMsg(String code, SyntaxTreeNode node) {
	_code = code;
	_url  = getFileName(node);
	_line = node.getLineNumber();
    }

    public ErrorMsg(String code, Object param1, SyntaxTreeNode node) {
	_code = code;
	_url  = getFileName(node);
	_line = node.getLineNumber();
	_params = new Object[1];
	_params[0] = param1;
    }

    public ErrorMsg(String code, Object param1, Object param2,
		    SyntaxTreeNode node) {
	_code = code;
	_url  = getFileName(node);
	_line = node.getLineNumber();
	_params = new Object[2];
	_params[0] = param1;
	_params[1] = param2;
    }

    private String getFileName(SyntaxTreeNode node) {
	Stylesheet stylesheet = node.getStylesheet();
	if (stylesheet != null)
	    return stylesheet.getSystemId();
	else
	    return null;
    }

    private String formatLine() {
	StringBuffer result = new StringBuffer();
	if (_url != null) {
	    result.append(_url);
	    result.append("": "");
	}
	if (_line > 0) {
	    result.append(""line "");
	    result.append(Integer.toString(_line));
	    result.append("": "");
	}
	return result.toString();
    }
	
    
    public String toString() {
	String suffix = (_params == null) ? 
	    (null != _code ? new String(getErrorMessage()) : _message)
	    : MessageFormat.format(getErrorMessage(), _params);
	return formatLine() + suffix;
    }
	
    public String toString(Object obj) {
	Object params[] = new Object[1];
	params[0] = obj.toString();
	String suffix = MessageFormat.format(getErrorMessage(), params);
	return formatLine() + suffix;
    }
	
    public String toString(Object obj0, Object obj1) {
	Object params[] = new Object[2];
	params[0] = obj0.toString();
	params[1] = obj1.toString();
	String suffix = MessageFormat.format(getErrorMessage(), params);
	return formatLine() + suffix;
    }

        
    private String getErrorMessage() {
      return _bundle.getString(_code);
    }
}

"
org.apache.xalan.transformer.TrAXFilter,8,2,0,3,36,0,1,2,7,0.5,203,1.0,1,0.829268293,0.25,1,6,24.125,6,1.625,1,"
package org.apache.xalan.transformer;

import java.io.IOException;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.Templates;
import javax.xml.transform.TransformerConfigurationException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLFilterImpl;
import org.xml.sax.helpers.XMLReaderFactory;


public class TrAXFilter extends XMLFilterImpl
{
  private Templates m_templates;
  private TransformerImpl m_transformer;
    
  
  public TrAXFilter (Templates templates)
    throws TransformerConfigurationException
  {
    m_templates = templates;
    m_transformer = (TransformerImpl)templates.newTransformer();
  }
  
  
  public TransformerImpl getTransformer()
  {
    return m_transformer;
  }
  
  
  public void setParent (XMLReader parent)
  { 
    super.setParent(parent);
    
    if(null != parent.getContentHandler())
      this.setContentHandler(parent.getContentHandler());

    
    
    
    setupParse ();
  }
  
  
  public void parse (InputSource input)
    throws org.xml.sax.SAXException, IOException
  {
    if(null == getParent())
    {
      XMLReader reader=null;

      
      try {
          javax.xml.parsers.SAXParserFactory factory=
              javax.xml.parsers.SAXParserFactory.newInstance();
          factory.setNamespaceAware( true );
          javax.xml.parsers.SAXParser jaxpParser=
              factory.newSAXParser();
          reader=jaxpParser.getXMLReader();
          
      } catch( javax.xml.parsers.ParserConfigurationException ex ) {
          throw new org.xml.sax.SAXException( ex );
      } catch( javax.xml.parsers.FactoryConfigurationError ex1 ) {
          throw new org.xml.sax.SAXException( ex1.toString() );
      } catch( NoSuchMethodError ex2 ) {
      }
      catch (AbstractMethodError ame){}

      XMLReader parent;
      if( reader==null )
          parent= XMLReaderFactory.createXMLReader();
      else
          parent=reader;
      try
      {
        parent.setFeature(""http:
                          true);
      }
      catch (org.xml.sax.SAXException se){}
      
      setParent(parent);
    }
    else
    {
      
      setupParse ();
    }
    if(null == m_transformer.getContentHandler())
    {
      throw new org.xml.sax.SAXException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_CALL_PARSE, null)); 
    }

    getParent().parse(input);
    Exception e = m_transformer.getExceptionThrown();
    if(null != e)
    {
      if(e instanceof org.xml.sax.SAXException)
        throw (org.xml.sax.SAXException)e;
      else
        throw new org.xml.sax.SAXException(e);
    }
  }
  
  
  public void parse (String systemId)
    throws org.xml.sax.SAXException, IOException
  {
    parse(new InputSource(systemId));
  }


  
  private void setupParse ()
  {
    XMLReader p = getParent();
    if (p == null) {
      throw new NullPointerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_PARENT_FOR_FILTER, null)); 
    }
    
    ContentHandler ch = m_transformer.getInputContentHandler();


    p.setContentHandler(ch);

    if(ch instanceof EntityResolver)
      p.setEntityResolver((EntityResolver)ch);
    else
      p.setEntityResolver(this);
    
    if(ch instanceof DTDHandler)
      p.setDTDHandler((DTDHandler)ch);
    else
      p.setDTDHandler(this);
    
    ErrorListener elistener = m_transformer.getErrorListener();
    if((null != elistener) && (elistener instanceof org.xml.sax.ErrorHandler))
      p.setErrorHandler((org.xml.sax.ErrorHandler)elistener);
    else
      p.setErrorHandler(this);
  }

  
  public void setContentHandler (ContentHandler handler)
  {
    m_transformer.setContentHandler(handler);
    
  }
  
  public void setErrorListener (ErrorListener handler)
  {
    m_transformer.setErrorListener(handler);
  }

}
"
org.apache.xalan.res.XSLTErrorResources_zh_TW,3,4,0,1,4,1,0,1,2,1.423076923,3769,0.0,0,0.976190476,1.0,0,0,1251.0,1,0.3333,0,"
package org.apache.xalan.res;




public class XSLTErrorResources_zh_TW extends XSLTErrorResources
{

   
  public static final int MAX_CODE = 201;          

  
  public static final int MAX_WARNING = 29;

   
  public static final int MAX_OTHERS = 55;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  

  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_NO_CURLYBRACE,
      ""錯誤：在表示式內不能有 '{'""},


  
  


  {
    ER_ILLEGAL_ATTRIBUTE, ""{0} 含有不正確屬性：{1}""},


  
  


  {
    ER_NULL_SOURCENODE_APPLYIMPORTS,
      ""在 xsl:apply-imports 中的 sourceNode 為空值！""},


  
  


  {
    ER_CANNOT_ADD, ""無法將 {0} 新增至 {1}""},


  
  


  {
    ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES,
      ""在 handleApplyTemplatesInstruction 中的 sourceNode 為空值！""},


  
  


  {
    ER_NO_NAME_ATTRIB, ""{0} 必須有 name 屬性。 ""},


  
  


  {
    ER_TEMPLATE_NOT_FOUND, ""找不到名稱為 {0} 的範本""},


  
  


  {
    ER_CANT_RESOLVE_NAME_AVT,
      ""無法解譯 xsl:call-template 中的名稱 AVT。""},


  
  


  {
    ER_REQUIRES_ATTRIB, ""{0} 需要屬性：{1}""},


  
  


  {
    ER_MUST_HAVE_TEST_ATTRIB,
      ""{0} 必須有 ''test'' 屬性。""},


  
  


  {
    ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""level 屬性 {0} 上的值錯誤""},


  
  


  {
    ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""processing-instruction 名稱不得為 'xml'""},


  
  


  {
    ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""processing-instruction 名稱必須是有效的 NCName：{0}""},


  
  


  {
    ER_NEED_MATCH_ATTRIB,
      ""如果 {0} 有模式的話，則它必須有 match 屬性。""},


  
  


  {
    ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0} 需要 name 或 match 屬性。""},


  
  


  {
    ER_CANT_RESOLVE_NSPREFIX,
      ""無法解譯名稱空間前置：{0}""},


  
  


  {
    ER_ILLEGAL_VALUE, ""xml:space 含有不合規則的值：{0}""},


  
  


  {
    ER_NO_OWNERDOC,
      ""子項節點沒有擁有者文件！""},


  
  


  {
    ER_ELEMTEMPLATEELEM_ERR, ""ElemTemplateElement 錯誤：{0}""},


  
  


  {
    ER_NULL_CHILD, ""嘗試新增空的子項！""},


  
  


  {
    ER_NEED_SELECT_ATTRIB, ""{0} 需要 select 屬性。""},


  
  


  {
    ER_NEED_TEST_ATTRIB,
      ""xsl:when 必須有 'test' 屬性。""},


  
  


  {
    ER_NEED_NAME_ATTRIB,
      ""xsl:with-param 必須有 'name' 屬性。""},


  
  


  {
    ER_NO_CONTEXT_OWNERDOC,
      ""上下文不含擁有者文件！""},


  
  


  {
    ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""無法建立 XML TransformerFactory Liaison：{0}""},


  
  


  {
    ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: 處理不成功。""},


  
  


  {
    ER_NOT_SUCCESSFUL, ""Xalan: 不成功。""},


  
  


  {
    ER_ENCODING_NOT_SUPPORTED, ""不支援編碼：{0}""},


  
  


  {
    ER_COULD_NOT_CREATE_TRACELISTENER,
      ""無法建立 TraceListener：{0}""},


  
  


  {
    ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key 需要 'name' 屬性！""},


  
  


  {
    ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key 需要 'match' 屬性！""},


  
  


  {
    ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key 需要 'use' 屬性！""},


  
  


  {
    ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0} 需要 ''elements'' 屬性！""},


  
  


  {
    ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} 屬性 ''prefix'' 遺漏""},


  
  


  {
    ER_BAD_STYLESHEET_URL, ""樣式表 URL 錯誤：{0}""},


  
  


  {
    ER_FILE_NOT_FOUND, ""找不到樣式表檔案：{0}""},


  
  


  {
    ER_IOEXCEPTION,
      ""樣式表檔案 {0} 有輸入/輸出 (I/O) 異常""},


  
  


  {
    ER_NO_HREF_ATTRIB,
      ""(StylesheetHandler) 找不到 {0} 的 href 屬性""},


  
  


  {
    ER_STYLESHEET_INCLUDES_ITSELF,
      ""(StylesheetHandler) {0} 直接或間接包含本身！""},


  
  


  {
    ER_PROCESSINCLUDE_ERROR,
      ""StylesheetHandler.processInclude 錯誤：{0}""},


  
  


  {
    ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} 屬性 ''lang'' 遺漏""},


  
  


  {
    ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) 誤置 {0} 元素？？ 遺漏 container 元素 ''component''""},


  
  


  {
    ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
      ""只能輸出至 Element、DocumentFragment、Document 或 PrintWriter。""},


  
  


  {
    ER_PROCESS_ERROR, ""StylesheetRoot.process 錯誤""},


  
  


  {
    ER_UNIMPLNODE_ERROR, ""UnImplNode 錯誤：{0}""},


  
  


  {
    ER_NO_SELECT_EXPRESSION,
      ""錯誤！未找到 xpath select 表示式 (-select)。""},


  
  


  {
    ER_CANNOT_SERIALIZE_XSLPROCESSOR,
      ""無法串列化 XSLProcessor！""},


  
  


  {
    ER_NO_INPUT_STYLESHEET,
      ""未指定樣式表輸入！""},


  
  


  {
    ER_FAILED_PROCESS_STYLESHEET,
      ""無法處理樣式表！""},


  
  


  {
    ER_COULDNT_PARSE_DOC, ""無法剖析 {0} 文件！""},


  
  


  {
    ER_COULDNT_FIND_FRAGMENT, ""找不到片段：{0}""},


  
  


  {
    ER_NODE_NOT_ELEMENT,
      ""片段識別碼所指的節點不是元素：{0}""},


  
  


  {
    ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""for-each 必須有 match 或 name 屬性""},


  
  


  {
    ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB,
      ""templates 必須有 match 或 name 屬性""},


  
  


  {
    ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""文件片段沒有複本！""},


  
  


  {
    ER_CANT_CREATE_ITEM,
      ""無法在結果樹 {0} 建立項目""},


  
  


  {
    ER_XMLSPACE_ILLEGAL_VALUE,
      ""來源 XML 中的 xml:space 含有不合規則的值：{0}""},


  
  


  {
    ER_NO_XSLKEY_DECLARATION,
      ""{0} 沒有 xsl:key 宣告！""},


  
  


  {
    ER_CANT_CREATE_URL, ""錯誤！無法建立 URL 給：{0}""},


  
  


  {
    ER_XSLFUNCTIONS_UNSUPPORTED, ""不支援 xsl:functions""},


  
  


  {
    ER_PROCESSOR_ERROR, ""XSLT TransformerFactory 錯誤""},


  
  


  {
    ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""(StylesheetHandler) {0} 不允許在樣式表內！""},


  
  


  {
    ER_RESULTNS_NOT_SUPPORTED,
      ""不再支援 result-ns！請使用 xsl:output 來代替。""},


  
  


  {
    ER_DEFAULTSPACE_NOT_SUPPORTED,
      ""不再支援 default-space！請使用 xsl:strip-space 或 xsl:preserve-space 來代替。""},


  
  


  {
    ER_INDENTRESULT_NOT_SUPPORTED,
      ""不再支援 indent-result！請使用 xsl:output 來代替。""},


  
  


  {
    ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0} 含有不合規則的屬性：{1}""},


  
  


  {
    ER_UNKNOWN_XSL_ELEM, ""XSL 元素：{0}""},


  
  


  {
    ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort 只能與 xsl:apply-templates 或 xsl:for-each 一起使用。""},


  
  


  {
    ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) 誤置 xsl:when！""},


  
  


  {
    ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:when 的上代不是 xsl:choose！""},


  
  


  {
    ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) 誤置 xsl:otherwise！""},


  
  


  {
    ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:otherwise 的上代不是 xsl:choose！""},


  
  


  {
    ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""(StylesheetHandler) {0} 不允許在範本內！""},


  
  


  {
    ER_UNKNOWN_EXT_NS_PREFIX,
      ""(StylesheetHandler) {0} 延伸程式名稱空間前置 {1} 未知""},


  
  


  {
    ER_IMPORTS_AS_FIRST_ELEM,
      ""(StylesheetHandler) Imports 只能出現於樣式表中作為第一個元素！""},


  
  


  {
    ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0} 直接或間接匯入本身！""},


  
  


  {
    ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space 含有不合規則的值：{0}""},


  
  


  {
    ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""processStylesheet 不成功！""},


  
  


  {
    ER_SAX_EXCEPTION, ""SAX 異常""},


  
  


  {
    ER_XSLT_ERROR, ""XSLT 錯誤""},


  
  


  {
    ER_CURRENCY_SIGN_ILLEGAL,
      ""貨幣符號不允許在格式型樣字串中""},


  
  


  {
    ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""樣式表 DOM 不支援文件函式！""},


  
  


  {
    ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""無法解譯非前置解析器的前置！""},


  
  


  {
    ER_REDIRECT_COULDNT_GET_FILENAME,
      ""重新導向延伸程式：無法取得檔案名稱 - file 或 select 屬性必須傳回有效字串。""},


  
  


  {
    ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""無法在重新導向延伸程式中建立 FormatterListener！""},


  
  


  {
    ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""exclude-result-prefixes 中的前置無效：{0}""},


  
  


  {
    ER_MISSING_NS_URI,
      ""遺漏指定的前置的名稱空間 URI""},


  
  


  {
    ER_MISSING_ARG_FOR_OPTION,
      ""遺漏選項：{0} 的引數""},


  
  


  {
    ER_INVALID_OPTION, ""無效的選項：{0}""},


  
  


  {
    ER_MALFORMED_FORMAT_STRING, ""變形的格式字串：{0}""},


  
  


  {
    ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet 需要 'version' 屬性！""},


  
  


  {
    ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""屬性：{0} 含有不正確值：{1}""},


  
  


  {
    ER_CHOOSE_REQUIRES_WHEN, ""xsl:choose 需要 xsl:when""},


  
  


  {
    ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""xsl:apply-imports 不允許在 xsl:for-each 中""},


  
  


  {
    ER_CANT_USE_DTM_FOR_OUTPUT,
      ""無法對輸出 DOM 節點使用 DTMLiaison... 改為傳送 org.apache.xpath.DOM2Helper！""},


  
  


  {
    ER_CANT_USE_DTM_FOR_INPUT,
      ""無法對輸入 DOM 節點使用 DTMLiaison... 改為傳送 org.apache.xpath.DOM2Helper！""},


  
  


  {
    ER_CALL_TO_EXT_FAILED,
      ""呼叫延伸程式元素失敗：{0}""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""前置必須解譯為名稱空間：{0}""},


  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""偵測到無效的 UTF-16 代用品：{0} ?""},


  
  


  {
    ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0} 使用本身，這將造成無窮迴圈。""},


  
  


  {
    ER_CANNOT_MIX_XERCESDOM,
      ""無法混合非 Xerces-DOM 輸入與 Xerces-DOM 輸出！""},


  
  


  {
    ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},


  
  


  {
    ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""在 ElemTemplateElement.readObject：{0}""},


  
  


  {
    ER_DUPLICATE_NAMED_TEMPLATE,
      ""找到一個以上叫作 {0} 的範本""},


  
  


  {
    ER_INVALID_KEY_CALL,
      ""無效的函式呼叫：recursive key() 呼叫不被允許""},

  
  
  


  {
    ER_REFERENCING_ITSELF,
      ""變數 {0} 直接或間接參照本身！""},

  
  
  


  {
    ER_ILLEGAL_DOMSOURCE_INPUT,
      ""對 newTemplates 的 DOMSource 而言，輸入節點不得為空值！""},

	
	
  


  {
    ER_CLASS_NOT_FOUND_FOR_OPTION,
			""找不到選項 {0} 的類別檔案""},

	
	
  


  {
    ER_REQUIRED_ELEM_NOT_FOUND,
			""找不到必需的元素：{0}""},

  
  
  


  {
    ER_INPUT_CANNOT_BE_NULL,
			""InputStream 不得為空值""},

  
  
  


  {
    ER_URI_CANNOT_BE_NULL,
			""URI 不得為空值""},

  
  
  


  {
    ER_FILE_CANNOT_BE_NULL,
			""檔案不可為空值""},

  
   
  


  {
    ER_SOURCE_CANNOT_BE_NULL,
			""InputSource 不可為空值""},

  
  
  


  {
    ER_CANNOT_INIT_BSFMGR,
			""無法起始設定 BSF Manager""},

  
  
  


  {
    ER_CANNOT_CMPL_EXTENSN,
			""無法編譯延伸程式""},

  
  
  


  {
    ER_CANNOT_CREATE_EXTENSN,
      ""無法建立延伸程式 {0}，因為：{1}""},

  
  
  


  {
    ER_INSTANCE_MTHD_CALL_REQUIRES,
      ""方法 {0} 的實例方法呼叫需要一個物件實例作為第一個引數""},

  
  
  


  {
    ER_INVALID_ELEMENT_NAME,
      ""指定的元素名稱無效 {0}""},

  
   
  


  {
    ER_ELEMENT_NAME_METHOD_STATIC,
      ""元素名稱方法必須為靜態 {0}""},

  
   
  


  {
    ER_EXTENSION_FUNC_UNKNOWN,
             ""延伸程式函式 {0} : {1} 未知""},

  
   
  


  {
    ER_MORE_MATCH_CONSTRUCTOR,
             ""{0} 的最符合建構元不止一個""},

  
   
  


  {
    ER_MORE_MATCH_METHOD,
             ""最符合方法 {0} 的不止一個""},

  
   
  


  {
    ER_MORE_MATCH_ELEMENT,
             ""最符合元素方法 {0} 的不止一個""},

  
   
  


  {
    ER_INVALID_CONTEXT_PASSED,
             ""傳送來評估 {0} 的上下文無效""},

  
   
  


  {
    ER_POOL_EXISTS,
             ""儲存池已存在""},

  
   
  


  {
    ER_NO_DRIVER_NAME,
             ""未指定驅動程式名稱""},

  
   
  


  {
    ER_NO_URL,
             ""未指定 URL""},

  
   
  


  {
    ER_POOL_SIZE_LESSTHAN_ONE,
             ""儲存池大小小於 1！""},

  
   
  


  {
    ER_INVALID_DRIVER,
             ""指定的驅動程式名稱無效！""},

  
   
  


  {
    ER_NO_STYLESHEETROOT,
             ""找不到 stylesheet 根！""},

  
   
  


  {
    ER_ILLEGAL_XMLSPACE_VALUE,
         ""xml:space 的值不正確""},

  
   
  


  {
    ER_PROCESSFROMNODE_FAILED,
         ""processFromNode 失效""},

  
   
  


  {
    ER_RESOURCE_COULD_NOT_LOAD,
        ""無法載入資源 [ {0} ]：{1} 
 {2} 	 {3}""},

   
  
   
  


  {
    ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""緩衝區大小 <=0""},

  
   
  


  {
    ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""呼叫延伸程式時發生未知錯誤""},

  
   
  


  {
    ER_NO_NAMESPACE_DECL,
        ""前置 {0} 沒有對應的名稱空間宣告""},

  
   
  


  {
    ER_ELEM_CONTENT_NOT_ALLOWED,
        ""lang=javaclass {0} 不允許元素內容""},
     
  
   
  


  {
    ER_STYLESHEET_DIRECTED_TERMINATION,
        ""Stylesheet 引導終止""},

  
   
  


  {
    ER_ONE_OR_TWO,
        ""1 或 2""},

  
   
  


  {
    ER_TWO_OR_THREE,
        ""2 或 3""},

  
   
  


  {
    ER_COULD_NOT_LOAD_RESOURCE,
        ""無法載入 {0}（檢查 CLASSPATH），現在只使用預設值""},

  
   
  


  {
    ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""無法起始設定預設範本""},

  
   
  


  {
    ER_RESULT_NULL,
        ""結果不應該為空值""},

    
   
  


  {
    ER_RESULT_COULD_NOT_BE_SET,
        ""無法設定結果""},

  
   
  


  {
    ER_NO_OUTPUT_SPECIFIED,
        ""未指定輸出""},

  
   
  


  {
    ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""無法轉換成類型 {0} 的結果""},

  
   
  


  {
    ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""無法轉換類型 {0} 的來源""},

  
   
  


  {
    ER_NULL_CONTENT_HANDLER,
        ""空的內容處理器""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""空的錯誤處理器""},

  
   
  


  {
    ER_CANNOT_CALL_PARSE,
        ""如果未設定 ContentHandler 則無法呼叫剖析""},

  
   
  


  {
    ER_NO_PARENT_FOR_FILTER,
        ""過濾器沒有上代""},

  
  
   
  


  {
    ER_NO_STYLESHEET_IN_MEDIA,
         ""在 {0} media= {1} 找不到樣式表""},

  
   
  


  {
    ER_NO_STYLESHEET_PI,
         ""在 {0} 中沒有發現 XML 樣式表 PI""},

  
   
  


  {
    ER_NOT_SUPPORTED,
       ""不支援：{0}""},

  
   
  


  {
    ER_PROPERTY_VALUE_BOOLEAN,
       ""內容 {0} 的值應該是一個布林案例""},

  
   
  


  {
    ER_COULD_NOT_FIND_EXTERN_SCRIPT,
       ""無法於 {0} 處取得外部指令集""},

  
  
  


  {
    ER_RESOURCE_COULD_NOT_FIND,
        ""找不到資源 [ {0} ]。
 {1}""},

  
   
  


  {
    ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""未能辨識輸出內容：{0}""},

  
   
  


  {
    ER_FAILED_CREATING_ELEMLITRSLT,
        ""建立 ElemLiteralResult 案例失敗""},
  
  
  
  
  
  

  
   
  


  {
    ER_VALUE_SHOULD_BE_NUMBER,
        ""{0} 的值應包含可剖析的數字""},

  
   
  


  {
    ER_VALUE_SHOULD_EQUAL,
        "" {0} 的值應等於 yes 或 no""},

 
   
  


  {
    ER_FAILED_CALLING_METHOD,
        "" 呼叫 {0} 方法失敗""},

  
   
  


  {
    ER_FAILED_CREATING_ELEMTMPL,
        ""建立 ElemTemplateElement 案例失敗""},

  
   
  


  {
    ER_CHARS_NOT_ALLOWED,
        ""文件的這個地方不允許字元""},

  
  
  


  {
    ER_ATTR_NOT_ALLOWED,
        ""{1} 元素上不允許有 ""{0}"" 屬性！""},

 
  
  


  {
    ER_BAD_VALUE,
     ""{0} 錯誤值 {1} ""},

  
  
  


  {
    ER_ATTRIB_VALUE_NOT_FOUND,
     ""找不到 {0} 屬性值 ""},

  
  
  


  {
    ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""不能辨識 {0} 屬性值 ""},

  
  
  


  {
    ER_NULL_URI_NAMESPACE,
     ""正在嘗試使用空 URI 產生名稱空間前置""},
   
   
  
  
  
  


  {
    ER_NUMBER_TOO_BIG,
     ""試圖格式化比最大的 Long 整數還要大的數字""},

  
  
  
  
  

  {
  ER_CANNOT_FIND_SAX1_DRIVER,
   ""無法找到 SAX1 驅動程式類別 {0}""},


  
    


  {
  ER_SAX1_DRIVER_NOT_LOADED,
   ""已找到 SAX1 驅動程式類別 {0}，但是無法載入""},


  
  


  {
    ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""已載入 SAX1 驅動程式類別 {0}，但是無法將其實例化""},



  
    

  
    {
     ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
      ""SAX1 驅動程式類別 {0} 不執行 org.xml.sax.Parser""},
  

  
    

  
    {
      ER_PARSER_PROPERTY_NOT_SPECIFIED,
       ""未指定系統屬性 org.xml.sax.parser""},
  

  
    

  
    {
      ER_PARSER_ARG_CANNOT_BE_NULL,
       ""剖析器引數不能為空""},
  


  
    

  
    {
      ER_FEATURE,
       ""功能：a {0}""},
  


  
    

  
    {
      ER_PROPERTY,
       ""屬性：a {0}""},
  
 
  
    

  
    {
      ER_NULL_ENTITY_RESOLVER,
      ""空實體解析器""},
  

  
    

  
    {
      ER_NULL_DTD_HANDLER,
       ""空 DTD 處理程式""},
  

  
    
  
    {
      ER_NO_DRIVER_NAME_SPECIFIED,
       ""未指定驅動程式名稱！""},
  


  
    
  
    {
      ER_NO_URL_SPECIFIED,
       ""未指定 URL！""},
  


  
    
  
    {
      ER_POOLSIZE_LESS_THAN_ONE,
       ""儲存區小於 1！""},
  


  
    
  
    {
      ER_INVALID_DRIVER_NAME,
       ""指定的驅動程式名稱無效！""},
  



  
    
  
    {
      ER_ERRORLISTENER,
       ""ErrorListener""},
  


  
    
  
    {
      ER_ASSERT_NO_TEMPLATE_PARENT,
       ""程式設計師的錯誤！expr 沒有 ElemTemplateElement 父！""},
  


  
    
  
    {
      ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
       ""程式設計師在 RundundentExprEliminator 中的判斷：{0}""},
  

  
    
  
    {
      ER_NOT_ALLOWED_IN_POSITION,
       ""在樣式表中，此位置不允許出現 {0}！""},
  

  
    
  
    {
      ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
       ""在樣式表中，此位置只能是空白！""},
  

  
  
    
    
  
    {
      INVALID_TCHAR,
       ""不正確的值：{1} 被用於 CHAR 屬性：{0}。  CHAR 類型的屬性只能是 1 個字元！""},
  

   
   
   
   
   

  
  
  

  {
    INVALID_QNAME,
     ""不正確的值：a {1} 被用於 QNAME 屬性：a {0}""},


   
   
   
   
   
   

   
   
 
   {
     INVALID_ENUM,
      ""不正確的值：a {1} 被用於 ENUM 屬性：a {0}。  有效值為：a {2}。""},
 

   
   
   
   
   

   
   
 
   {
     INVALID_NMTOKEN,
      ""不正確的值：a {1} 被用於 NMTOKEN 屬性：a {0}""},
 

  
  
  
  
  

  
  

  {
    INVALID_NCNAME,
     ""不正確的值：a {1} 被用於 NCNAME 屬性：a {0}""},


  
  
  
  
  
 
  
  


  {
    INVALID_BOOLEAN,
     ""不正確的值：a {1} 被用於 boolean 屬性：a {0}""},


  
  
  
  
  

  
  

  {
    INVALID_NUMBER,
     ""不正確的值：a {1} 被用於 number 屬性：a {0}""},



  

  
  
  
  
  

   
   
 
   {
     ER_ARG_LITERAL,
      ""在相符型樣中 {0} 的引數必須是文字。""},
 

  
  
  
  

   
   
 
   {
     ER_DUPLICATE_GLOBAL_VAR,
      ""重複的全域變數宣告。""},
 


  
  
  

   
   
 
   {
     ER_DUPLICATE_VAR,
      ""重複的變數宣告。""},
 

      
      
      

  
  

  {
    ER_TEMPLATE_NAME_MATCH,
     ""xsl:template 必須有一個名稱或相符屬性 (或兩者均有)""},


    
    
    
    
    

   
   
 
   {
     ER_INVALID_PREFIX,
      ""exclude-result-prefixes 中的前置無效：a {0}""},
 

     
     
     
     
     

     
     
   
     {
       ER_NO_ATTRIB_SET,
        ""名為 {0} 的 attribute-set 不存在""},
   

  

  
  


  {
    WG_FOUND_CURLYBRACE,
      ""找到 '}' 但沒有開啟的屬性範本！""},


  
  


  {
    WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""警告：count 屬性不符合 xsl:number 中的祖先節點！目標 = {0}""},


  
  


  {
    WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""舊語法：'expr' 屬性的名稱已變更為 'select'。""},


  
  


  {
    WG_NO_LOCALE_IN_FORMATNUMBER,
      ""Xalan 尚未處理 format-number 函式中的語言環境名稱。""},


  
  


  {
    WG_LOCALE_NOT_FOUND,
      ""警告：找不到 xml:lang={0} 的語言環境""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""無法從： {0} 產生 URL""},


  
  


  {
    WG_CANNOT_LOAD_REQUESTED_DOC,
      ""無法載入所要求的文件：{0}""},


  
  


  {
    WG_CANNOT_FIND_COLLATOR,
      ""找不到 <sort xml:lang={0} 的理序器""},


  
  


  {
    WG_FUNCTIONS_SHOULD_USE_URL,
      ""舊語法：函式指令應使用 URL {0}""},


  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""不支援編碼：{0}，使用 UTF-8""},


  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      ""不支援編碼：{0}，使用 Java {1}""},


  
  


  {
    WG_SPECIFICITY_CONFLICTS,
      ""找到具體衝突：{0} 將使用在樣式表中找到的最後一個。""},


  
  


  {
    WG_PARSING_AND_PREPARING,
      ""========= 剖析及準備 {0} ==========""},


  
  


  {
    WG_ATTR_TEMPLATE, ""Attr 範本，{0}""},


  
  


  {
    WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""xsl:strip-space 和 xsl:preserve-space 之間發生符合衝突""},


  
  


  {
    WG_ATTRIB_NOT_HANDLED,
      ""Xalan 尚未處理 {0} 屬性！""},


  
  


  {
    WG_NO_DECIMALFORMAT_DECLARATION,
      ""找不到十進位格式的宣告：{0}""},


  
  


  {
    WG_OLD_XSLT_NS, ""XSLT 名稱空間遺漏或不正確。""},


  
  


  {
    WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""僅允許一個預設 xsl:decimal-format 宣告。""},


  
  


  {
    WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""xsl:decimal-format 名稱必須是唯一的。 ""{0}"" 名稱重複。""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE,
      ""{0} 含有不合規則的屬性：{1}""},


  
  


  {
    WG_COULD_NOT_RESOLVE_PREFIX,
      ""無法解譯名稱空間前置：{0}。節點被忽略。""},


  
  


  {
    WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet 需要 'version' 屬性！""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE_NAME,
      ""不合規則的屬性名稱：{0}""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""屬性 {0} 使用了不合規則的值：{1}""},


  
  


  {
    WG_EMPTY_SECOND_ARG,
      ""從文件函式第二個引數產生的節點集是空值。將使用第一個引數。""},




    
    
    
 

  
  

  {
     WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
     ""xsl:processing-instruction 名稱之 'name' 屬性的值不能是 'xml'""},

 
    
    
    
    
 
  
  

  {
     WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
     ""xsl:processing-instruction 之 ''name'' 屬性的值必須是一個有效的 NCName：a {0}""},


    
    
    
    
    

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_POSITION,
     ""無法在產生子節點之後或產生元素之前加入屬性 {0}。  屬性將被忽略。""},


    
 
  
  { ""ui_language"", ""zh_TW""},
  { ""help_language"", ""zh_TW""},
  { ""language"", ""zh_TW""},
    { ""BAD_CODE"",
      ""createMessage 的參數超出界限""},
    { ""FORMAT_FAILED"",
      ""在 messageFormat 呼叫期間丟出異常""},
    { ""version"", "">>>>>>> Xalan 版本 ""},
    {  ""version2"", ""<<<<<<<""},
    { ""yes"", ""是""},
    { ""line"", ""行 #""},
    { ""column"", ""直欄 #""},
    { ""xsldone"", ""XSLProcessor: done""},
    { ""xslProc_option"",
    ""Xalan-J 指令行 Process 類別選項：""},
    { ""optionIN"", ""    -IN inputXMLURL""},
    { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
    { ""optionOUT"", ""   [-OUT outputFileName]""},
    { ""optionLXCIN"", ""   [-LXCIN compiledStylesheetFileNameIn]""},
    { ""optionLXCOUT"",
      ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
    { ""optionPARSER"",
      ""   [-PARSER 剖析器關聯別名的完整名稱]""},
    { ""optionE"",
    ""   [-E (不展開實體參照)]""},
    { ""optionV"",
    ""   [-E (不展開實體參照)]""},
    { ""optionQC"",
      ""   [-QC (無聲型樣衝突警告)]""},
    { ""optionQ"",
    ""   [-Q  (無聲模式)]""},
    { ""optionLF"",
      ""   [-LF (只在輸出上使用換行 {預設是 CR/LF})]""},
    { ""optionCR"",
      ""   [-CR (只在輸出上使用換行鍵 {預設是 CR/LF})]""},
    { ""optionESCAPE"",
      ""   [-ESCAPE (要逸出的字元 {預設是 <>&""'\r\n})]""},
    { ""optionINDENT"",
      ""   [-INDENT (控制要內縮的空格數 {預設是 0})]""},
    { ""optionTT"",
      ""   [-TT (呼叫時追蹤範本。)]""},
    { ""optionTG"",
      ""   [-TG (追蹤每一個產生事件。)]""},
    { ""optionTS"",
    ""   [-TS (追蹤每一個選取事件。)]""},
    { ""optionTTC"",
      ""   [-TTC (追蹤處理中的範本子項。)]""},
    {""optionTCLASS"",
      ""   [-TCLASS (追蹤延伸程式的 TraceListener 類別。)]""},
    { ""optionVALIDATE"",
      ""   [-VALIDATE (設定是否發生驗證。依預設驗證是關閉的。)]""},
    { ""optionEDUMP"",
      ""   [-EDUMP {可選用的檔案名稱} (發生錯誤時執行 stackdump。)]""},
    { ""optionXML"",
      ""   [-XML (使用 XML 格式製作器及新增 XML 表頭。)]""},
    { ""optionTEXT"",
      ""   [-TEXT (使用簡式文字格式化程式。)]""},
    { ""optionHTML"",
    ""   [-HTML (使用 HTML 格式製作器。)]""},
    { ""optionPARAM"",
      ""   [-PARAM 名稱表示式 (設定樣式表參數)]""},
    { ""noParsermsg1"",
    ""XSL 處理不成功。""},
    { ""noParsermsg2"",
    ""** 找不到剖析器 **""},
    { ""noParsermsg3"",
    ""請檢查類別路徑。""},
    { ""noParsermsg4"",
      ""如果您沒有 IBM 的 XML Parser for Java，可下載自 ""},
    { ""noParsermsg5"",
      ""IBM's AlphaWorks: http:
    { ""optionURIRESOLVER"",
    ""   [-URIRESOLVER 完整的類別名稱 (URIResolver 用來解譯 URI)]""},
    { ""optionENTITYRESOLVER"",
    ""   [-ENTITYRESOLVER 完整的類別名稱 (EntityResolver 用來解譯實體)]""},
    { ""optionCONTENTHANDLER"",
    ""   [-CONTENTHANDLER 完整的類別名稱 (ContentHandler 用來串列化輸出)]""},
    { ""optionLINENUMBERS"",
    ""   [-L 使用原始文件的行號]""},
    
    


    { ""optionMEDIA"",
    "" [-MEDIA mediaType (使用媒體屬性尋找與文件關聯的樣式表。)]""},
    { ""optionFLAVOR"",
    "" [-FLAVOR flavorName (明確是使用 s2s=SAX 還是 d2d=DOM 來執行轉換。)] ""}, 
    { ""optionDIAG"",
    "" [-DIAG (列印轉換作業花費的總毫秒數。)]""},
    { ""optionINCREMENTAL"",
    "" [-INCREMENTAL (透過將 http:
    { ""optionNOOPTIMIMIZE"",
    "" [-NOOPTIMIMIZE (透過將 http:
    { ""optionRL"",
    "" [-RL 循環限制 (假設在樣式表循環深度上數字限制。)]""},
    { ""optionXO"",
    "" [-XO [transletName] (指定產生的 translet 名稱)]""},
    { ""optionXD"",
    "" [-XD destinationDirectory (指定 translet 的目標目錄)]""},
    { ""optionXJ"",
    "" [-XJ jarfile (將 translet 類別封裝成名為 <jarfile> 的 jar 檔)]""},
    { ""optionXP"",
    "" [-XP package (指定所有 translet 類別的封裝名稱前置)]""}

		
  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""錯誤："";

  
  public static final String WARNING_HEADER = ""警告："";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}
"
org.apache.xml.res.XMLMessages,8,1,1,33,22,18,33,0,6,0.828571429,183,1.0,0,0.0,0.314285714,0,0,21.25,7,1.875,1,"
package org.apache.xml.res;

import java.util.ListResourceBundle;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;


public class XMLMessages
{

  
  protected Locale fLocale = Locale.getDefault();

  
  private static ListResourceBundle XMLBundle = null;

  
  private static final String XML_ERROR_RESOURCES =
    ""org.apache.xml.res.XMLErrorResources"";

  
  protected static String BAD_CODE = ""BAD_CODE"";

  
  protected static String FORMAT_FAILED = ""FORMAT_FAILED"";
    
  
   public void setLocale(Locale locale)
  {
    fLocale = locale;
  }

  
  public Locale getLocale()
  {
    return fLocale;
  }
    
  
  public static final String createXMLMessage(String msgKey, Object args[])
  {
    if (XMLBundle == null)
      XMLBundle = loadResourceBundle(XML_ERROR_RESOURCES);
    
    if (XMLBundle != null)
    {
      return createMsg(XMLBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }

  
  public static final String createMsg(ListResourceBundle fResourceBundle,
	String msgKey, Object args[])  
  {

    String fmsg = null;
    boolean throwex = false;
    String msg = null;

    if (msgKey != null)
      msg = fResourceBundle.getString(msgKey);

    if (msg == null)
    {
      msg = fResourceBundle.getString(BAD_CODE);
      throwex = true;
    }

    if (args != null)
    {
      try
      {

        
        
        
        int n = args.length;

        for (int i = 0; i < n; i++)
        {
          if (null == args[i])
            args[i] = """";
        }

        fmsg = java.text.MessageFormat.format(msg, args);
      }
      catch (Exception e)
      {
        fmsg = fResourceBundle.getString(FORMAT_FAILED);
        fmsg += "" "" + msg;
      }
    }
    else
      fmsg = msg;

    if (throwex)
    {
      throw new RuntimeException(fmsg);
    }

    return fmsg;
  }

  
  public static ListResourceBundle loadResourceBundle(String className)
          throws MissingResourceException
  {    
    Locale locale = Locale.getDefault();

    try
    {
      return (ListResourceBundle)ResourceBundle.getBundle(className, locale);
    }
    catch (MissingResourceException e)
    {
      try  
      {

        
        
        return (ListResourceBundle)ResourceBundle.getBundle(
          className, new Locale(""en"", ""US""));
      }
      catch (MissingResourceException e2)
      {

        
        
        throw new MissingResourceException(
          ""Could not load any resource bundles."" + className, className, """");
      }
    }
  }

  
  protected static String getResourceSuffix(Locale locale)
  {

    String suffix = ""_"" + locale.getLanguage();
    String country = locale.getCountry();

    if (country.equals(""TW""))
      suffix += ""_"" + country;

    return suffix;
  }
}
"
org.w3c.dom.xpath.XPathEvaluator,3,1,0,0,3,3,0,0,3,2.0,3,0.0,0,0.0,0.611111111,0,0,0.0,1,1.0,0,"

package org.w3c.dom.xpath;


import org.w3c.dom.Node;
import org.w3c.dom.DOMException;


public interface XPathEvaluator {
    
    public XPathExpression createExpression(String expression, 
                                            XPathNSResolver resolver)
                                            throws XPathException, DOMException;

    
    public XPathNSResolver createNSResolver(Node nodeResolver);

    
    public Object evaluate(String expression, 
                           Node contextNode, 
                           XPathNSResolver resolver, 
                           short type, 
                           Object result)
                           throws XPathException, DOMException;

}
"
org.apache.xml.utils.NameSpace,1,1,0,1,2,0,1,0,1,2.0,16,0.0,1,0.0,1.0,0,0,12.0,0,0.0,1,"
package org.apache.xml.utils;

import java.io.Serializable;


public class NameSpace implements Serializable
{

  
  public NameSpace m_next = null;

  
  public String m_prefix;

  
  public String m_uri;  

  
  public NameSpace(String prefix, String uri)
  {
    m_prefix = prefix;
    m_uri = uri;
  }
}
"
org.apache.xpath.operations.Bool,3,3,0,6,7,3,1,5,3,2.0,24,0.0,0,0.952380952,0.555555556,1,1,7.0,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class Bool extends UnaryOperation
{

  
  public XObject operate(XObject right) throws javax.xml.transform.TransformerException
  {

    if (XObject.CLASS_BOOLEAN == right.getType())
      return right;
    else
      return right.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return m_right.bool(xctxt);
  }

}
"
org.apache.xalan.xsltc.compiler.ConcatCall,3,4,0,19,22,3,0,19,3,2.0,131,0.0,0,0.979591837,0.444444444,3,14,42.66666667,5,2.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class ConcatCall extends FunctionCall {
    public ConcatCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	for (int i = 0; i < argumentCount(); i++) {
	    final Expression exp = argument(i);
	    if (!exp.typeCheck(stable).identicalTo(Type.String)) {
		setArgument(i, new CastExpr(exp, Type.String));
	    }
	}
	return _type = Type.String;
    }
	
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int nArgs = argumentCount();
	
	switch (nArgs) {
	case 0:
	    il.append(new PUSH(cpg, EMPTYSTRING));
	    break;
	    
	case 1:
	    argument().translate(classGen, methodGen);
	    break;

	default:
	    final int initBuffer = cpg.addMethodref(STRING_BUFFER_CLASS,
						    ""<init>"", ""()V"");
	    final Instruction append =
		new INVOKEVIRTUAL(cpg.addMethodref(STRING_BUFFER_CLASS,
						   ""append"",
						   ""(""+STRING_SIG+"")""
						   +STRING_BUFFER_SIG));
	    
	    final int toString = cpg.addMethodref(STRING_BUFFER_CLASS,
						  ""toString"",
						  ""()""+STRING_SIG);
	    
	    il.append(new NEW(cpg.addClass(STRING_BUFFER_CLASS)));
	    il.append(DUP);
	    il.append(new INVOKESPECIAL(initBuffer));
	    for (int i = 0; i < nArgs; i++) {
		argument(i).translate(classGen, methodGen);
		il.append(append);
	    }
	    il.append(new INVOKEVIRTUAL(toString));
	}
    }
}
"
org.apache.xalan.lib.Redirect,7,1,0,12,45,1,0,12,4,0.75,499,0.5,0,0.0,0.571428571,0,0,69.71428571,7,1.7143,0,"
package org.apache.xalan.lib;

import java.io.File;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.util.Hashtable;

import javax.xml.transform.Result;
import javax.xml.transform.TransformerException;
import javax.xml.transform.stream.StreamResult;

import org.apache.xalan.extensions.XSLProcessorContext;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.ElemExtensionCall;
import org.apache.xalan.templates.OutputProperties;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xml.serializer.SerializationHandler;
import org.xml.sax.ContentHandler;


public class Redirect
{
  
  protected Hashtable m_formatterListeners = new Hashtable ();

  
  protected Hashtable m_outputStreams = new Hashtable ();

  
  public static final boolean DEFAULT_APPEND_OPEN = false;

  
  public static final boolean DEFAULT_APPEND_WRITE = false;

  
  public void open(XSLProcessorContext context, ElemExtensionCall elem)
    throws java.net.MalformedURLException,
           java.io.FileNotFoundException,
           java.io.IOException,
           javax.xml.transform.TransformerException
  {
    String fileName = getFilename(context, elem);
    Object flistener = m_formatterListeners.get(fileName);
    if(null == flistener)
    {
      String mkdirsExpr 
        = elem.getAttribute (""mkdirs"", context.getContextNode(), 
                                                  context.getTransformer());
      boolean mkdirs = (mkdirsExpr != null)
                       ? (mkdirsExpr.equals(""true"") || mkdirsExpr.equals(""yes"")) : true;

      
      String appendExpr = elem.getAttribute(""append"", context.getContextNode(), context.getTransformer());
	  boolean append = (appendExpr != null)
                       ? (appendExpr.equals(""true"") || appendExpr.equals(""yes"")) : DEFAULT_APPEND_OPEN;

      Object ignored = makeFormatterListener(context, elem, fileName, true, mkdirs, append);
    }
  }
  
  
  public void write(XSLProcessorContext context, ElemExtensionCall elem)
    throws java.net.MalformedURLException,
           java.io.FileNotFoundException,
           java.io.IOException,
           javax.xml.transform.TransformerException
  {
    String fileName = getFilename(context, elem);
    Object flObject = m_formatterListeners.get(fileName);
    ContentHandler formatter;
    boolean inTable = false;
    if(null == flObject)
    {
      String mkdirsExpr 
        = ((ElemExtensionCall)elem).getAttribute (""mkdirs"", 
                                                  context.getContextNode(), 
                                                  context.getTransformer());
      boolean mkdirs = (mkdirsExpr != null)
                       ? (mkdirsExpr.equals(""true"") || mkdirsExpr.equals(""yes"")) : true;

      
      String appendExpr = elem.getAttribute(""append"", context.getContextNode(), context.getTransformer());
	  boolean append = (appendExpr != null)
                       ? (appendExpr.equals(""true"") || appendExpr.equals(""yes"")) : DEFAULT_APPEND_WRITE;

      formatter = makeFormatterListener(context, elem, fileName, true, mkdirs, append);
    }
    else
    {
      inTable = true;
      formatter = (ContentHandler)flObject;
    }
    
    TransformerImpl transf = context.getTransformer();
    
    transf.executeChildTemplates(elem,
                                 context.getContextNode(),
                                 context.getMode(), formatter);
    
    if(!inTable)
    {
      OutputStream ostream = (OutputStream)m_outputStreams.get(fileName);
      if(null != ostream)
      {
        try
        {
          formatter.endDocument();
        }
        catch(org.xml.sax.SAXException se)
        {
          throw new TransformerException(se);
        }
        ostream.close();
        m_outputStreams.remove(fileName);
        m_formatterListeners.remove(fileName);
      }
    }
  }


  
  public void close(XSLProcessorContext context, ElemExtensionCall elem)
    throws java.net.MalformedURLException,
    java.io.FileNotFoundException,
    java.io.IOException,
    javax.xml.transform.TransformerException
  {
    String fileName = getFilename(context, elem);
    Object formatterObj = m_formatterListeners.get(fileName);
    if(null != formatterObj)
    {
      ContentHandler fl = (ContentHandler)formatterObj;
      try
      {
        fl.endDocument();
      }
      catch(org.xml.sax.SAXException se)
      {
        throw new TransformerException(se);
      }
      OutputStream ostream = (OutputStream)m_outputStreams.get(fileName);
      if(null != ostream)
      {
        ostream.close();
        m_outputStreams.remove(fileName);
      }
      m_formatterListeners.remove(fileName);
    }
  }

  
  private String getFilename(XSLProcessorContext context, ElemExtensionCall elem)
    throws java.net.MalformedURLException,
    java.io.FileNotFoundException,
    java.io.IOException,
    javax.xml.transform.TransformerException
  {
    String fileName;
    String fileNameExpr 
      = ((ElemExtensionCall)elem).getAttribute (""select"", 
                                                context.getContextNode(), 
                                                context.getTransformer());
    if(null != fileNameExpr)
    {
      org.apache.xpath.XPathContext xctxt 
        = context.getTransformer().getXPathContext();
      XPath myxpath = new XPath(fileNameExpr, elem, xctxt.getNamespaceContext(), XPath.SELECT);
      XObject xobj = myxpath.execute(xctxt, context.getContextNode(), elem);
      fileName = xobj.str();
      if((null == fileName) || (fileName.length() == 0))
      {
        fileName = elem.getAttribute (""file"", 
                                      context.getContextNode(), 
                                      context.getTransformer());
      }
    }
    else
    {
      fileName = elem.getAttribute (""file"", context.getContextNode(), 
                                                               context.getTransformer());
    }
    if(null == fileName)
    {
      context.getTransformer().getMsgMgr().error(elem, elem, 
                                     context.getContextNode(), 
                                     XSLTErrorResources.ER_REDIRECT_COULDNT_GET_FILENAME);
                              
    }
    return fileName;
  }
  
  
  
  
  private String urlToFileName(String base)
  {
    if(null != base)
    {
      if(base.startsWith(""file:
      {
        base = base.substring(7);
      }
      else if(base.startsWith(""file:
      {
        base = base.substring(6);
      }
      else if(base.startsWith(""file:
      {
        base = base.substring(5); 
      }
      else if(base.startsWith(""file:/""))
      {
        base = base.substring(5);
      }
      else if(base.startsWith(""file:""))
      {
        base = base.substring(4);
      }
    }
    return base;
  }

  
  private ContentHandler makeFormatterListener(XSLProcessorContext context,
                                               ElemExtensionCall elem,
                                               String fileName,
                                               boolean shouldPutInTable,
                                               boolean mkdirs, 
                                               boolean append)
    throws java.net.MalformedURLException,
    java.io.FileNotFoundException,
    java.io.IOException,
    javax.xml.transform.TransformerException
  {
    File file = new File(fileName);
    TransformerImpl transformer = context.getTransformer();
    String base;          

    if(!file.isAbsolute())
    {
      
      
      
      
      
  

      Result outputTarget = transformer.getOutputTarget();
      if ( (null != outputTarget) && ((base = outputTarget.getSystemId()) != null) ) {
        base = urlToFileName(base);
      }
      else
      {
        base = urlToFileName(transformer.getBaseURLOfSource());
      }

      if(null != base)
      {
        File baseFile = new File(base);
        file = new File(baseFile.getParent(), fileName);
      }
      
    }

    if(mkdirs)
    {
      String dirStr = file.getParent();
      if((null != dirStr) && (dirStr.length() > 0))
      {
        File dir = new File(dirStr);
        dir.mkdirs();
      }
    }

    
    
    OutputProperties format = transformer.getOutputFormat();

    
    
    
    
    
    
    FileOutputStream ostream = new FileOutputStream(file.getPath(), append);
    
    try
    {
      SerializationHandler flistener = 
        transformer.createSerializationHandler(new StreamResult(ostream),
                                               format);
      try
      {
        flistener.startDocument();
      }
      catch(org.xml.sax.SAXException se)
      {
        throw new TransformerException(se);
      }
      if(shouldPutInTable)
      {
        m_outputStreams.put(fileName, ostream);
        m_formatterListeners.put(fileName, flistener);
      }
      return flistener;
    }
    catch(TransformerException te)
    {
      throw new javax.xml.transform.TransformerException(te);
    }
    
  }
}
"
org.apache.xalan.xsltc.compiler.Whitespace,14,3,0,30,79,79,1,29,7,1.030769231,805,0.3,0,0.821917808,0.207142857,2,6,55.78571429,11,3.5714,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.IF_ICMPEQ;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class Whitespace extends TopLevelElement {
    
    public static final int USE_PREDICATE  = 0;
    public static final int STRIP_SPACE    = 1;
    public static final int PRESERVE_SPACE = 2;

    
    public static final int RULE_NONE      = 0; 
    public static final int RULE_ELEMENT   = 1; 
    public static final int RULE_NAMESPACE = 2; 
    public static final int RULE_ALL       = 3; 

    private String _elementList;
    private int    _action;
    private int    _importPrecedence;

    
    private final static class WhitespaceRule {
	private final int _action;
	private String _namespace; 
	private String _element;   
	private int    _type;
	private int    _priority;
	
	
	public WhitespaceRule(int action, String element, int precedence) {
 	    
	    _action = action;

	    
	    final int colon = element.indexOf(':');
	    if (colon >= 0) {
		_namespace = element.substring(0,colon);
		_element = element.substring(colon+1,element.length());
	    }
	    else {
		_namespace = Constants.EMPTYSTRING;
		_element = element;
	    }

	    
	    _priority = precedence << 2;

	    
	    if (_element.equals(""*"")) {
		if (_namespace == Constants.EMPTYSTRING) {
		    _type = RULE_ALL;       
		    _priority += 2;         
		}
		else {
		    _type = RULE_NAMESPACE; 
		    _priority += 1;         
		}
	    }
	    else {
		_type = RULE_ELEMENT;       
	    }
	}

	
	public int compareTo(WhitespaceRule other) {
	    return _priority < other._priority
		? -1
		: _priority > other._priority ? 1 : 0;
	}

	public int getAction() { return _action; }
	public int getStrength() { return _type; }
	public int getPriority() { return _priority; }
	public String getElement() { return _element; }
	public String getNamespace() { return _namespace; }
    }

    
    public void parseContents(Parser parser) {
	
	_action = _qname.getLocalPart().endsWith(""strip-space"") 
	    ? STRIP_SPACE : PRESERVE_SPACE;

	
	_importPrecedence = parser.getCurrentImportPrecedence();

	
	_elementList = getAttribute(""elements"");
	if (_elementList == null || _elementList.length() == 0) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""elements"");
	    return;
	}

	final SymbolTable stable = parser.getSymbolTable();
	StringTokenizer list = new StringTokenizer(_elementList);
	StringBuffer elements = new StringBuffer(Constants.EMPTYSTRING);

	while (list.hasMoreElements()) {
	    String token = list.nextToken();
	    String prefix;
	    String namespace;
	    int col;

	    if ((col = token.indexOf(':')) != -1) {
		prefix  = token.substring(0,col);
	    }
	    else {
		prefix = Constants.EMPTYSTRING;
	    }

	    namespace = lookupNamespace(prefix);
	    if (namespace != null)
		elements.append(namespace+"":""+
				token.substring(col+1,token.length()));
	    else
		elements.append(token);

	    if (list.hasMoreElements())
		elements.append("" "");
	}
	_elementList = elements.toString();
    }


    
    public Vector getRules() {
	final Vector rules = new Vector();
	
	final StringTokenizer list = new StringTokenizer(_elementList);
	while (list.hasMoreElements()) {
	    rules.add(new WhitespaceRule(_action,
					 list.nextToken(),
					 _importPrecedence));
	}
	return rules;
    }
    
    
    
    private static WhitespaceRule findContradictingRule(Vector rules,
							WhitespaceRule rule) {
	for (int i = 0; i < rules.size(); i++) {
	    
	    WhitespaceRule currentRule = (WhitespaceRule)rules.elementAt(i);
	    
	    if (currentRule == rule) {
		return null;
	    }
	    
	    
	    switch (currentRule.getStrength()) {
	    case RULE_ALL:
		return currentRule;
		
	    case RULE_ELEMENT:
		if (!rule.getElement().equals(currentRule.getElement())) {
		    break;
		}
		
	    case RULE_NAMESPACE:
		if (rule.getNamespace().equals(currentRule.getNamespace())) {
		    return currentRule;
		}
		break;
	    }
	}
	return null;
    }


    
    private static int prioritizeRules(Vector rules) {
	WhitespaceRule currentRule;
	int defaultAction = PRESERVE_SPACE;

	
	quicksort(rules, 0, rules.size()-1);

	
	
	
	boolean strip = false;
	for (int i = 0; i < rules.size(); i++) {
	    currentRule = (WhitespaceRule)rules.elementAt(i);
	    if (currentRule.getAction() == STRIP_SPACE) {
		strip = true;
	    }
	}
	
	if (!strip) {
	    rules.removeAllElements();
	    return PRESERVE_SPACE;
	}

	
	for (int idx = 0; idx < rules.size(); ) {
	    currentRule = (WhitespaceRule)rules.elementAt(idx);
	
	    
	    if (findContradictingRule(rules,currentRule) != null) {
		rules.remove(idx);
	    }
	    else {
		
		if (currentRule.getStrength() == RULE_ALL) {
		    defaultAction = currentRule.getAction();
		    for (int i = idx; i < rules.size(); i++) {
			rules.removeElementAt(i);
		    }
		}
		
		idx++;
	    }
	}

	
	if (rules.size() == 0) {
	    return defaultAction;
	}

	
	
	do {
	    currentRule = (WhitespaceRule)rules.lastElement();
	    if (currentRule.getAction() == defaultAction) {
		rules.removeElementAt(rules.size() - 1);
	    }
	    else {
		break;
	    }
	} while (rules.size() > 0);
	
	
	return defaultAction;
    }

    public static void compileStripSpace(BranchHandle strip[], 
					 int sCount,
					 InstructionList il) {
	final InstructionHandle target = il.append(ICONST_1);
	il.append(IRETURN);
	for (int i = 0; i < sCount; i++) {
	    strip[i].setTarget(target);
	}
    }

    public static void compilePreserveSpace(BranchHandle preserve[], 
					    int pCount,
					    InstructionList il) {
	final InstructionHandle target = il.append(ICONST_0);
	il.append(IRETURN);
	for (int i = 0; i < pCount; i++) {
	    preserve[i].setTarget(target);
	}
    }

    

    
    private static void compilePredicate(Vector rules,
					 int defaultAction,
					 ClassGenerator classGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();
	final XSLTC xsltc = classGen.getParser().getXSLTC();

	
	final MethodGenerator stripSpace =
	    new MethodGenerator(ACC_PUBLIC | ACC_FINAL ,
			org.apache.bcel.generic.Type.BOOLEAN, 
			new org.apache.bcel.generic.Type[] {
			    Util.getJCRefType(DOM_INTF_SIG),
			    org.apache.bcel.generic.Type.INT,
			    org.apache.bcel.generic.Type.INT
			},
			new String[] { ""dom"",""node"",""type"" },
			""stripSpace"",classGen.getClassName(),il,cpg);

	classGen.addInterface(""org/apache/xalan/xsltc/StripFilter"");

	final int paramDom = stripSpace.getLocalIndex(""dom"");
	final int paramCurrent = stripSpace.getLocalIndex(""node"");
	final int paramType = stripSpace.getLocalIndex(""type"");

	BranchHandle strip[] = new BranchHandle[rules.size()];
	BranchHandle preserve[] = new BranchHandle[rules.size()];
	int sCount = 0;
	int pCount = 0;

	
	for (int i = 0; i<rules.size(); i++) {
	    
	    WhitespaceRule rule = (WhitespaceRule)rules.elementAt(i);

	    
	    final int gns = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getNamespaceName"",
						      ""(I)Ljava/lang/String;"");

	    final int strcmp = cpg.addMethodref(""java/lang/String"",
						""compareTo"",
						""(Ljava/lang/String;)I"");

	    
	    if (rule.getStrength() == RULE_NAMESPACE) {
		il.append(new ALOAD(paramDom));
		il.append(new ILOAD(paramCurrent));
		il.append(new INVOKEINTERFACE(gns,2));
		il.append(new PUSH(cpg, rule.getNamespace()));
		il.append(new INVOKEVIRTUAL(strcmp));
		il.append(ICONST_0);

		if (rule.getAction() == STRIP_SPACE) {
		    strip[sCount++] = il.append(new IF_ICMPEQ(null));
		}
		else {
		    preserve[pCount++] = il.append(new IF_ICMPEQ(null));
		}
	    }
	    
	    else if (rule.getStrength() == RULE_ELEMENT) {
		
		final Parser parser = classGen.getParser();
		QName qname;
		if (rule.getNamespace() != Constants.EMPTYSTRING )
		    qname = parser.getQName(rule.getNamespace(), null,
					    rule.getElement());
		else
		    qname = parser.getQName(rule.getElement());

		
		final int elementType = xsltc.registerElement(qname);
		il.append(new ILOAD(paramType));
		il.append(new PUSH(cpg, elementType));

		
		if (rule.getAction() == STRIP_SPACE)
		    strip[sCount++] = il.append(new IF_ICMPEQ(null));
		else
		    preserve[pCount++] = il.append(new IF_ICMPEQ(null));
	    }
	}

	if (defaultAction == STRIP_SPACE) {
	    compileStripSpace(strip, sCount, il);
	    compilePreserveSpace(preserve, pCount, il);
	}
	else {
	    compilePreserveSpace(preserve, pCount, il);
	    compileStripSpace(strip, sCount, il);
	}

	stripSpace.stripAttributes(true);
	stripSpace.setMaxLocals();
	stripSpace.setMaxStack();
	stripSpace.removeNOPs();

	classGen.addMethod(stripSpace.getMethod());
    }

    
    private static void compileDefault(int defaultAction,
				       ClassGenerator classGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();
	final XSLTC xsltc = classGen.getParser().getXSLTC();

	
	final MethodGenerator stripSpace =
	    new MethodGenerator(ACC_PUBLIC | ACC_FINAL ,
			org.apache.bcel.generic.Type.BOOLEAN, 
			new org.apache.bcel.generic.Type[] {
			    Util.getJCRefType(DOM_INTF_SIG),
			    org.apache.bcel.generic.Type.INT,
			    org.apache.bcel.generic.Type.INT
			},
			new String[] { ""dom"",""node"",""type"" },
			""stripSpace"",classGen.getClassName(),il,cpg);

	classGen.addInterface(""org/apache/xalan/xsltc/StripFilter"");

	if (defaultAction == STRIP_SPACE)
	    il.append(ICONST_1);
	else
	    il.append(ICONST_0);
	il.append(IRETURN);

	stripSpace.stripAttributes(true);
	stripSpace.setMaxLocals();
	stripSpace.setMaxStack();
	stripSpace.removeNOPs();

	classGen.addMethod(stripSpace.getMethod());
    }


    
    public static int translateRules(Vector rules,
				     ClassGenerator classGen) {
	
	final int defaultAction = prioritizeRules(rules);
	
	if (rules.size() == 0) {
	    compileDefault(defaultAction,classGen);
	    return defaultAction;
	}
	
	compilePredicate(rules, defaultAction, classGen);
	
	return USE_PREDICATE;
    }

    
    private static void quicksort(Vector rules, int p, int r) {
	while (p < r) {
	    final int q = partition(rules, p, r);
	    quicksort(rules, p, q);
	    p = q + 1;
	}
    }
    
    
    private static int partition(Vector rules, int p, int r) {
	final WhitespaceRule x = (WhitespaceRule)rules.elementAt((p+r) >>> 1);
	int i = p - 1, j = r + 1;
	while (true) {
	    while (x.compareTo((WhitespaceRule)rules.elementAt(--j)) < 0) {
	    }
	    while (x.compareTo((WhitespaceRule)rules.elementAt(++i)) > 0) {
	    }
	    if (i < j) {
		final WhitespaceRule tmp = (WhitespaceRule)rules.elementAt(i);
		rules.setElementAt(rules.elementAt(j), i);
		rules.setElementAt(tmp, j);
	    }
	    else {
		return j;
	    }
	}
    }
    
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void; 
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
    }
}
"
org.apache.xml.serializer.ToXMLStream,14,3,0,8,79,57,2,6,11,0.961538462,648,1.0,1,0.933701657,0.538461538,3,29,45.14285714,9,1.4286,1,"
 package org.apache.xml.serializer;

import java.io.IOException;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.xml.sax.SAXException;



public class ToXMLStream extends ToStream
{

    
    private boolean m_cdataTagOpen = false;


    
    protected static CharInfo m_xmlcharInfo =

        CharInfo.getCharInfo(CharInfo.XML_ENTITIES_RESOURCE);

    
    public ToXMLStream()
    {
        m_charInfo = m_xmlcharInfo;

        initCDATA();
        
        m_prefixMap = new NamespaceMappings();

    }

    
    public void CopyFrom(ToXMLStream xmlListener)
    {

        m_writer = xmlListener.m_writer;


        
        String encoding = xmlListener.getEncoding();
        setEncoding(encoding);

        setOmitXMLDeclaration(xmlListener.getOmitXMLDeclaration());

        m_startTagOpen = xmlListener.m_startTagOpen;

        
        
        m_ispreserve = xmlListener.m_ispreserve;
        m_preserves = xmlListener.m_preserves;
        m_isprevtext = xmlListener.m_isprevtext;
        m_doIndent = xmlListener.m_doIndent;
        m_currentElemDepth = xmlListener.m_currentElemDepth;
        setIndentAmount(xmlListener.getIndentAmount());
        m_startNewLine = xmlListener.m_startNewLine;
        m_needToOutputDocTypeDecl = xmlListener.m_needToOutputDocTypeDecl;
        setDoctypeSystem(xmlListener.getDoctypeSystem());
        setDoctypePublic(xmlListener.getDoctypePublic());        
        setStandalone(xmlListener.getStandalone());
        setMediaType(xmlListener.getMediaType());
        m_maxCharacter = xmlListener.m_maxCharacter;
        m_spaceBeforeClose = xmlListener.m_spaceBeforeClose;
        m_cdataStartCalled = xmlListener.m_cdataStartCalled;

    }

    
    public void startDocumentInternal() throws org.xml.sax.SAXException
    {

        if (m_needToCallStartDocument)
        { 
            super.startDocumentInternal();
            m_needToCallStartDocument = false;

            if (m_inEntityRef)
                return;

            m_needToOutputDocTypeDecl = true;
            m_startNewLine = false;

            if (getOmitXMLDeclaration() == false)
            {
                String encoding = Encodings.getMimeEncoding(getEncoding());
                String version = getVersion();
                if (version == null)
                    version = ""1.0"";
                String standalone;

                if (m_standaloneWasSpecified)
                {
                    standalone = "" standalone="""" + getStandalone() + """""";
                }
                else
                {
                    standalone = """";
                }

                try
                {
                    m_writer.write(""<?xml version="""");
                    m_writer.write(version);
                    m_writer.write("""" encoding="""");
                    m_writer.write(encoding);
                    m_writer.write('""');
                    m_writer.write(standalone);
                    m_writer.write(""?>"");
                    m_writer.write(m_lineSep, 0, m_lineSepLen);
                } 
                catch(IOException e)
                {
                    throw new SAXException(e);
                }

            }
        }
    }

    
    public void endDocument() throws org.xml.sax.SAXException
    {
        flushPending();
        if (m_doIndent && !m_isprevtext)
        {
            try
            {
            outputLineSep();
            }
            catch(IOException e)
            {
                throw new SAXException(e);
            }
        }

        flushWriter();
        super.fireEndDoc();
    }

    
    public void startPreserving() throws org.xml.sax.SAXException
    {

        
        m_preserves.push(true);

        m_ispreserve = true;
    }

    
    public void endPreserving() throws org.xml.sax.SAXException
    {

        
        m_ispreserve = m_preserves.isEmpty() ? false : m_preserves.pop();
    }

    
    public void processingInstruction(String target, String data)
        throws org.xml.sax.SAXException
    {
        if (m_inEntityRef)
            return;
        
        flushPending();   

        if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
        {
            startNonEscaping();
        }
        else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
        {
            endNonEscaping();
        }
        else
        {
            try
            {
                if (m_startTagOpen)
                    closeStartTag();

                if (shouldIndent())
                    indent();

                m_writer.write('<');
                m_writer.write('?');
                m_writer.write(target);

                if (data.length() > 0
                    && !Character.isSpaceChar(data.charAt(0)))
                    m_writer.write(' ');

                int indexOfQLT = data.indexOf(""?>"");

                if (indexOfQLT >= 0)
                {

                    
                    if (indexOfQLT > 0)
                    {
                        m_writer.write(data.substring(0, indexOfQLT));
                    }

                    m_writer.write(""? >""); 

                    if ((indexOfQLT + 2) < data.length())
                    {
                        m_writer.write(data.substring(indexOfQLT + 2));
                    }
                }
                else
                {
                    m_writer.write(data);
                }

                m_writer.write('?');
                m_writer.write('>');

                
                
                
                if (m_currentElemDepth <= 0)
                    m_writer.write(m_lineSep, 0, m_lineSepLen);

                m_startNewLine = true;
            }
            catch(IOException e)
            {
                throw new SAXException(e);
            }
        }
        super.fireEscapingEvent(target, data);        
    }

    
    public void entityReference(String name) throws org.xml.sax.SAXException
    {
        if (m_startTagOpen)
        {
            closeStartTag();
            m_startTagOpen = false;
        }

        try
        {
            if (shouldIndent())
                indent();

            m_writer.write(""&"");
            m_writer.write(name);
            m_writer.write("";"");
        }
        catch(IOException e)
        {
            throw new SAXException(e);
        }
        super.fireEntityReference(name);            
    }


    public void addAttribute(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
        throws SAXException
    {
        if (m_startTagOpen)
        {
            if (!rawName.startsWith(""xmlns""))
            {
                String prefixUsed =
                    ensureAttributesNamespaceIsDeclared(
                        uri,
                        localName,
                        rawName);
                if (prefixUsed != null
                    && rawName != null
                    && !rawName.startsWith(prefixUsed))
                {
                    
                    
                    rawName = prefixUsed + "":"" + localName;

                }
            }
            addAttributeAlways(uri, localName, rawName, type, value);
        }
        else
        {
            
            

            
            String msg = XMLMessages.createXMLMessage(
                    XMLErrorResources.ER_ILLEGAL_ATTRIBUTE_POSITION,new Object[]{ localName });

            try {
                
                Transformer tran = super.getTransformer();
                ErrorListener errHandler = tran.getErrorListener();


                
                if (null != errHandler && m_sourceLocator != null)
                  errHandler.warning(new TransformerException(msg, m_sourceLocator));
                else
                  System.out.println(msg);
                }
            catch (Exception e){}             
        }
    }

    
    private String escapeString(String value)
    {
        final char[] ch = value.toCharArray();
        final int limit = ch.length;
        StringBuffer result = new StringBuffer();

        int offset = 0;
        for (int i = 0; i < limit; i++)
        {
            switch (ch[i])
            {
                case '&' :
                    result.append(ch, offset, i - offset).append(ENTITY_AMP);
                    offset = i + 1;
                    break;
                case '""' :
                    result.append(ch, offset, i - offset).append(ENTITY_QUOT);
                    offset = i + 1;
                    break;
                case '<' :
                    result.append(ch, offset, i - offset).append(ENTITY_LT);
                    offset = i + 1;
                    break;
                case '>' :
                    result.append(ch, offset, i - offset).append(ENTITY_GT);
                    offset = i + 1;
                    break;
                case '
' :
                    result.append(ch, offset, i - offset).append(ENTITY_CRLF);
                    offset = i + 1;
                    break;
            }
        }

        if (offset < limit)
        {
            result.append(ch, offset, limit - offset);
        }
        return result.toString();
    }

    
    public void endElement(String elemName) throws SAXException
    {
        endElement(null, null, elemName);
    }

    
    public void namespaceAfterStartElement(
        final String prefix,
        final String uri)
        throws SAXException
    {

        
        if (m_elementURI == null)
        {
            String prefix1 = getPrefixPart(m_elementName);
            if (prefix1 == null && EMPTYSTRING.equals(prefix))
            {
                
                
                
                
                m_elementURI = uri;
            }
        }            
        startPrefixMapping(prefix,uri,false);
        return;

    }

    
    protected boolean pushNamespace(String prefix, String uri)
    {
        try
        {
            if (m_prefixMap.pushNamespace(prefix, uri, m_currentElemDepth))
            {
                startPrefixMapping(prefix, uri);
                return true;
            }
        }
        catch (SAXException e)
        {
            
        }
        return false;
    }


}
"
org.apache.xalan.trace.PrintTraceListener,7,1,0,18,53,9,1,17,7,0.722222222,609,0.0,0,0.0,0.333333333,0,0,85.14285714,10,2.4286,1,"
package org.apache.xalan.trace;

import javax.xml.transform.SourceLocator;

import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemTextLiteral;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.ref.DTMNodeProxy;
import org.apache.xml.serializer.SerializerTrace;

import org.w3c.dom.Node;


public class PrintTraceListener implements TraceListenerEx2
{

  
  public PrintTraceListener(java.io.PrintWriter pw)
  {
    m_pw = pw;
  }

  
  java.io.PrintWriter m_pw;

  
  public boolean m_traceTemplates = false;

  
  public boolean m_traceElements = false;

  
  public boolean m_traceGeneration = false;

  
  public boolean m_traceSelection = false;

  
  public void _trace(TracerEvent ev)
  {

    switch (ev.m_styleNode.getXSLToken())
    {
    case Constants.ELEMNAME_TEXTLITERALRESULT :
      if (m_traceElements)
      {
        m_pw.print(ev.m_styleNode.getSystemId()+ "" Line #"" + ev.m_styleNode.getLineNumber() + "", ""
                   + ""Column #"" + ev.m_styleNode.getColumnNumber() + "" -- ""
                   + ev.m_styleNode.getNodeName() + "": "");

        ElemTextLiteral etl = (ElemTextLiteral) ev.m_styleNode;
        String chars = new String(etl.getChars(), 0, etl.getChars().length);

        m_pw.println(""    "" + chars.trim());
      }
      break;
    case Constants.ELEMNAME_TEMPLATE :
      if (m_traceTemplates || m_traceElements)
      {
        ElemTemplate et = (ElemTemplate) ev.m_styleNode;

        m_pw.print(et.getSystemId()+ "" Line #"" + et.getLineNumber() + "", "" + ""Column #""
                   + et.getColumnNumber() + "": "" + et.getNodeName() + "" "");

        if (null != et.getMatch())
        {
          m_pw.print(""match='"" + et.getMatch().getPatternString() + ""' "");
        }

        if (null != et.getName())
        {
          m_pw.print(""name='"" + et.getName() + ""' "");
        }

        m_pw.println();
      }
      break;
    default :
      if (m_traceElements)
      {
        m_pw.println(ev.m_styleNode.getSystemId()+ "" Line #"" + ev.m_styleNode.getLineNumber() + "", ""
                     + ""Column #"" + ev.m_styleNode.getColumnNumber() + "": ""
                     + ev.m_styleNode.getNodeName());
      }
    }
  }
  
  int m_indent = 0;
  
  
  public void trace(TracerEvent ev)
  {







	_trace(ev);
  }
  
  
  public void traceEnd(TracerEvent ev)
  {








  }


  
public void selected(SelectionEvent ev)
    throws javax.xml.transform.TransformerException {

    if (m_traceSelection) {
        ElemTemplateElement ete = (ElemTemplateElement) ev.m_styleNode;
        Node sourceNode = ev.m_sourceNode;

        SourceLocator locator = null;
        if (sourceNode instanceof DTMNodeProxy) {
            int nodeHandler = ((DTMNodeProxy) sourceNode).getDTMNodeNumber();
            locator =
                ((DTMNodeProxy) sourceNode).getDTM().getSourceLocatorFor(
                    nodeHandler);
        }

        if (locator != null)
            m_pw.println(
                ""Selected source node '""
                    + sourceNode.getNodeName()
                    + ""', at ""
                    + locator);
        else
            m_pw.println(
                ""Selected source node '"" + sourceNode.getNodeName() + ""'"");

        if (ev.m_styleNode.getLineNumber() == 0) {

            
            
            ElemTemplateElement parent =
                (ElemTemplateElement) ete.getParentElem();

            if (parent == ete.getStylesheetRoot().getDefaultRootRule()) {
                m_pw.print(""(default root rule) "");
            } else if (
                parent == ete.getStylesheetRoot().getDefaultTextRule()) {
                m_pw.print(""(default text rule) "");
            } else if (parent == ete.getStylesheetRoot().getDefaultRule()) {
                m_pw.print(""(default rule) "");
            }

            m_pw.print(
                ete.getNodeName()
                    + "", ""
                    + ev.m_attributeName
                    + ""='""
                    + ev.m_xpath.getPatternString()
                    + ""': "");
        } else {
            m_pw.print(
                ev.m_styleNode.getSystemId()
                    + "" Line #""
                    + ev.m_styleNode.getLineNumber()
                    + "", ""
                    + ""Column #""
                    + ev.m_styleNode.getColumnNumber()
                    + "": ""
                    + ete.getNodeName()
                    + "", ""
                    + ev.m_attributeName
                    + ""='""
                    + ev.m_xpath.getPatternString()
                    + ""': "");
        }

        if (ev.m_selection.getType() == ev.m_selection.CLASS_NODESET) {
            m_pw.println();

            org.apache.xml.dtm.DTMIterator nl = ev.m_selection.iter();
            
            
            
            
            
            int currentPos = DTM.NULL;
            currentPos = nl.getCurrentPos();
            nl.setShouldCacheNodes(true); 
            org.apache.xml.dtm.DTMIterator clone = null;
            
            
            try {
                clone = nl.cloneWithReset();
            } catch (CloneNotSupportedException cnse) {
                m_pw.println(
                    ""     [Can't trace nodelist because it it threw a CloneNotSupportedException]"");
                return;
            }
            int pos = clone.nextNode();

            if (DTM.NULL == pos) {
                m_pw.println(""     [empty node list]"");
            } else {
                while (DTM.NULL != pos) {
                    
                    DTM dtm = ev.m_processor.getXPathContext().getDTM(pos);
                    m_pw.print(""     "");
                    m_pw.print(Integer.toHexString(pos));
                    m_pw.print("": "");
                    m_pw.println(dtm.getNodeName(pos));
                    pos = clone.nextNode();
                }
            }
			
            
            nl.runTo(-1);
            nl.setCurrentPos(currentPos);
        	
			
        } else {
            m_pw.println(ev.m_selection.str());
        }
    }
}
  
  public void selectEnd(EndSelectionEvent ev) 
     throws javax.xml.transform.TransformerException
  {
  	
  }


  
  public void generated(GenerateEvent ev)
  {

    if (m_traceGeneration)
    {
      switch (ev.m_eventtype)
      {
      case SerializerTrace.EVENTTYPE_STARTDOCUMENT :
        m_pw.println(""STARTDOCUMENT"");
        break;
      case SerializerTrace.EVENTTYPE_ENDDOCUMENT :
        m_pw.println(""ENDDOCUMENT"");
        break;
      case SerializerTrace.EVENTTYPE_STARTELEMENT :
        m_pw.println(""STARTELEMENT: "" + ev.m_name);
        break;
      case SerializerTrace.EVENTTYPE_ENDELEMENT :
        m_pw.println(""ENDELEMENT: "" + ev.m_name);
        break;
      case SerializerTrace.EVENTTYPE_CHARACTERS :
      {
        String chars = new String(ev.m_characters, ev.m_start, ev.m_length);

        m_pw.println(""CHARACTERS: "" + chars);
      }
      break;
      case SerializerTrace.EVENTTYPE_CDATA :
      {
        String chars = new String(ev.m_characters, ev.m_start, ev.m_length);

        m_pw.println(""CDATA: "" + chars);
      }
      break;
      case SerializerTrace.EVENTTYPE_COMMENT :
        m_pw.println(""COMMENT: "" + ev.m_data);
        break;
      case SerializerTrace.EVENTTYPE_PI :
        m_pw.println(""PI: "" + ev.m_name + "", "" + ev.m_data);
        break;
      case SerializerTrace.EVENTTYPE_ENTITYREF :
        m_pw.println(""ENTITYREF: "" + ev.m_name);
        break;
      case SerializerTrace.EVENTTYPE_IGNORABLEWHITESPACE :
        m_pw.println(""IGNORABLEWHITESPACE"");
        break;
      }
    }
  }
  

}
"
org.apache.xalan.xsltc.compiler.VariableBase,19,3,2,29,61,99,14,18,18,0.907407407,335,1.0,3,0.769230769,0.190789474,1,5,16.0,7,1.7368,2,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.Util;

class VariableBase extends TopLevelElement {

    protected QName       _name;            
    protected String      _variable;        
    protected Type        _type;            
    protected boolean     _isLocal;         
    protected LocalVariableGen _local;      
    protected Instruction _loadInstruction; 
    protected Expression  _select;          
    protected String      select;           

    
    protected Vector      _refs = new Vector(2); 

    
    protected Vector      _dependencies = null;

    
    protected boolean    _ignore = false;

    
    protected int        _weight = 0;

    
    public void disable() {
	_ignore = true;
    }

    
    public void addReference(VariableRefBase vref) {
	_refs.addElement(vref);
    }

    
    public void removeReference(VariableRefBase vref) {
	_refs.remove(vref);
    }

    
    public void addDependency(VariableBase other) {
	if (_dependencies == null) {
	    _dependencies = new Vector();
	}
	if (!_dependencies.contains(other)) {
	    _dependencies.addElement(other);
	}
    }

    
    public Vector getDependencies() {
	return _dependencies;
    }

    
    public void mapRegister(MethodGenerator methodGen) {
        if (_local == null) {
            final InstructionList il = methodGen.getInstructionList();
	    final String name = _name.getLocalPart(); 
	    final org.apache.bcel.generic.Type varType = _type.toJCType();
            _local = methodGen.addLocalVariable2(name, varType, il.getEnd());
        }
    }

    
    public void unmapRegister(MethodGenerator methodGen) {
	if (_refs.isEmpty() && (_local != null)) {
	    _local.setEnd(methodGen.getInstructionList().getEnd());
	    methodGen.removeLocalVariable(_local);
	    _refs = null;
	    _local = null;
	}
    }

    
    public Instruction loadInstruction() {
	final Instruction instr = _loadInstruction;
	if (_loadInstruction == null) 
	    _loadInstruction = _type.LOAD(_local.getIndex());
	return _loadInstruction;
    }

    
    public Expression getExpression() {
	return(_select);
    }

    
    public String toString() {
	return(""variable(""+_name+"")"");
    }

    
    public void display(int indent) {
	indent(indent);
	System.out.println(""Variable "" + _name);
	if (_select != null) { 
	    indent(indent + IndentIncrement);
	    System.out.println(""select "" + _select.toString());
	}
	displayContents(indent + IndentIncrement);
    }

    
    public Type getType() {
	return _type;
    }

    
    public QName getName() {
	return _name;
    }

    
    public String getVariable() {
	return _variable;
    }

    
    public void setName(QName name) {
	_name = name;
	_variable = Util.escape(name.getLocalPart());
    }

    
    public boolean isLocal() {
	return _isLocal;
    }

    
    public void parseContents(Parser parser) {
	
	String name = getAttribute(""name"");
	if (name == null) name = EMPTYSTRING;

	if (name.length() > 0)
	    setName(parser.getQNameIgnoreDefaultNs(name));
        else
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""name"");

	
	VariableBase other = parser.lookupVariable(_name);
	if ((other != null) && (other.getParent() == getParent())) {
	    reportError(this, parser, ErrorMsg.VARIABLE_REDEF_ERR, name);
	}
	
	select = getAttribute(""select"");
	if (select.length() > 0) {
	    _select = getParser().parseExpression(this, ""select"", null);
	    if (_select.isDummy()) {
		reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""select"");
		return;
	    }
	}

	
	parseChildren(parser);
    }

    
    public void translateValue(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	
	if (_select != null) {
	    _select.translate(classGen, methodGen);
	    _select.startResetIterator(classGen, methodGen);
	}
	
	else if (hasContents()) {
	    compileResultTree(classGen, methodGen);
	}
	
	else {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();
	    il.append(new PUSH(cpg, Constants.EMPTYSTRING));
	}
    }

}
"
org.apache.xalan.xsltc.compiler.Step,16,4,0,30,69,10,5,28,13,0.566666667,787,1.0,0,0.829545455,0.232142857,2,9,47.9375,16,3.3125,2,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ICONST;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xml.dtm.DTM;

final class Step extends RelativeLocationPath {

    
    private int _axis;

    
    private Vector _predicates;

    
    private boolean _hadPredicates = false;

    
    private int _nodeType;

    public Step(int axis, int nodeType, Vector predicates) {
	_axis = axis;
	_nodeType = nodeType;
	_predicates = predicates;
    }

    
    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Predicate exp = (Predicate)_predicates.elementAt(i);
		exp.setParser(parser);
		exp.setParent(this);
	    }
	}
    }
    
    
    public int getAxis() {
	return _axis;
    }
	
    
    public void setAxis(int axis) {
	_axis = axis;
    }

    
    public int getNodeType() {
	return _nodeType;
    }

    
    public Vector getPredicates() {
	return _predicates;
    }

    
    public void addPredicates(Vector predicates) {
	if (_predicates == null) {
	    _predicates = predicates;
	}
	else {
	    _predicates.addAll(predicates);
	}
    }

    
    private boolean hasParentPattern() {
	final SyntaxTreeNode parent = getParent();
	return (parent instanceof ParentPattern ||
		parent instanceof ParentLocationPath ||
		parent instanceof UnionPathExpr ||
		parent instanceof FilterParentPath);
    }
    
    
    private boolean hasPredicates() {
	return _predicates != null && _predicates.size() > 0;
    }

    
    private boolean isPredicate() {
	SyntaxTreeNode parent = this;
	while (parent != null) {
	    parent = parent.getParent();
	    if (parent instanceof Predicate) return true;
	}
	return false;
    }

    
    public boolean isAbbreviatedDot() {
	return _nodeType == NodeTest.ANODE && _axis == Axis.SELF;
    }


    
    public boolean isAbbreviatedDDot() {
	return _nodeType == NodeTest.ANODE && _axis == Axis.PARENT;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	
	_hadPredicates = hasPredicates();

	
 	
	
	if (isAbbreviatedDot()) {
	    _type =  (hasParentPattern() || hasPredicates() ) ? 
		Type.NodeSet : Type.Node;
	}
	else {
	    _type = Type.NodeSet;
	}

	
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Expression pred = (Expression)_predicates.elementAt(i);
		pred.typeCheck(stable);
	    }
	}

	
	return _type;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (hasPredicates()) {
	    translatePredicates(classGen, methodGen);
	}
	else {
	    
	    
	    if (_axis == Axis.ATTRIBUTE && _nodeType != NodeTest.ATTRIBUTE &&
		_nodeType != NodeTest.ANODE && !hasParentPattern()) 
	    {
		int iter = cpg.addInterfaceMethodref(DOM_INTF,
						     ""getTypedAxisIterator"",
						     ""(II)""+NODE_ITERATOR_SIG);
		il.append(methodGen.loadDOM());
		il.append(new PUSH(cpg, Axis.ATTRIBUTE));
		il.append(new PUSH(cpg, _nodeType));
		il.append(new INVOKEINTERFACE(iter, 3));
		return;
	    }

	    
	    if (isAbbreviatedDot()) {
		if (_type == Type.Node) {
		    
		    il.append(methodGen.loadContextNode());
		}
		else {
		    
		    int init = cpg.addMethodref(SINGLETON_ITERATOR,
						""<init>"", ""(""+NODE_SIG+"")V"");
		    il.append(new NEW(cpg.addClass(SINGLETON_ITERATOR)));
		    il.append(DUP);
		    il.append(methodGen.loadContextNode());
		    il.append(new INVOKESPECIAL(init));
		}
		return;
	    }

	    
	    SyntaxTreeNode parent = getParent();
	    if ((parent instanceof ParentLocationPath) &&
		(parent.getParent() instanceof ParentLocationPath)) {
		if ((_nodeType == NodeTest.ELEMENT) && (!_hadPredicates)) {
		    _nodeType = NodeTest.ANODE;
		}
	    }

	    
	    switch (_nodeType) {
	    case NodeTest.ATTRIBUTE:
		_axis = Axis.ATTRIBUTE;
	    case NodeTest.ANODE:
		
		int git = cpg.addInterfaceMethodref(DOM_INTF,
						    ""getAxisIterator"",
						    ""(I)""+NODE_ITERATOR_SIG);
		il.append(methodGen.loadDOM());
		il.append(new PUSH(cpg, _axis));
		il.append(new INVOKEINTERFACE(git, 2));
		break;
	    default:
		final XSLTC xsltc = getParser().getXSLTC();
		final Vector ni = xsltc.getNamesIndex();
		String name = null;
		int star = 0;
		
		if (_nodeType >= DTM.NTYPES) {
		    name = (String)ni.elementAt(_nodeType-DTM.NTYPES);
		    star = name.lastIndexOf('*');
		}
		
		if (star > 1) {
		    final String namespace;
		    if (_axis == Axis.ATTRIBUTE)
			namespace = name.substring(0,star-2);
		    else
			namespace = name.substring(0,star-1);

		    final int nsType = xsltc.registerNamespace(namespace);
		    final int ns = cpg.addInterfaceMethodref(DOM_INTF,
						    ""getNamespaceAxisIterator"",
						    ""(II)""+NODE_ITERATOR_SIG);
		    il.append(methodGen.loadDOM());
		    il.append(new PUSH(cpg, _axis));
		    il.append(new PUSH(cpg, nsType));
		    il.append(new INVOKEINTERFACE(ns, 3));
		    break;
		}
	    case NodeTest.ELEMENT:
		
		final int ty = cpg.addInterfaceMethodref(DOM_INTF,
						""getTypedAxisIterator"",
						""(II)""+NODE_ITERATOR_SIG);
		
		il.append(methodGen.loadDOM());
		il.append(new PUSH(cpg, _axis));
		il.append(new PUSH(cpg, _nodeType));
		il.append(new INVOKEINTERFACE(ty, 3));

		break;
	    }
	}
    }


    
    public void translatePredicates(ClassGenerator classGen,
				    MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	int idx = 0;

	if (_predicates.size() == 0) {
	    translate(classGen, methodGen);
	}
	else {
	    final Predicate predicate = (Predicate)_predicates.lastElement();
	    _predicates.remove(predicate);

	    
	    
	    
	    
	    
	    
	    
	    if (predicate.isNodeValueTest()) {
		Step step = predicate.getStep();

		il.append(methodGen.loadDOM());
		
		
		if (step.isAbbreviatedDot()) {
		    translate(classGen, methodGen);
		    il.append(new ICONST(DOM.RETURN_CURRENT));
		}
		
		
		else {
		    ParentLocationPath path = new ParentLocationPath(this,step);
		    try {
			path.typeCheck(getParser().getSymbolTable());
		    }
		    catch (TypeCheckError e) { }
		    path.translate(classGen, methodGen);
		    il.append(new ICONST(DOM.RETURN_PARENT));
		}
		predicate.translate(classGen, methodGen);
		idx = cpg.addInterfaceMethodref(DOM_INTF,
						GET_NODE_VALUE_ITERATOR,
						GET_NODE_VALUE_ITERATOR_SIG);
		il.append(new INVOKEINTERFACE(idx, 5));
	    }
	    
	    else if (predicate.isNthDescendant()) {
		il.append(methodGen.loadDOM());
		il.append(new ICONST(NodeTest.ELEMENT));
		predicate.translate(classGen, methodGen);
		il.append(new ICONST(0));
		idx = cpg.addInterfaceMethodref(DOM_INTF,
						""getNthDescendant"",
						""(IIZ)""+NODE_ITERATOR_SIG);
		il.append(new INVOKEINTERFACE(idx, 4));
	    }
	    
	    else if (predicate.isNthPositionFilter()) {
		idx = cpg.addMethodref(NTH_ITERATOR_CLASS,
				       ""<init>"",
				       ""(""+NODE_ITERATOR_SIG+""I)V"");
		il.append(new NEW(cpg.addClass(NTH_ITERATOR_CLASS)));
		il.append(DUP);
		translatePredicates(classGen, methodGen); 
		predicate.translate(classGen, methodGen);
		il.append(new INVOKESPECIAL(idx));
	    }
	    else {
		idx = cpg.addMethodref(CURRENT_NODE_LIST_ITERATOR,
				       ""<init>"",
				       ""(""
				       + NODE_ITERATOR_SIG
				       + CURRENT_NODE_LIST_FILTER_SIG
				       + NODE_SIG
				       + TRANSLET_SIG
				       + "")V"");
		
		il.append(new NEW(cpg.addClass(CURRENT_NODE_LIST_ITERATOR)));
		il.append(DUP);
		translatePredicates(classGen, methodGen); 
		predicate.translateFilter(classGen, methodGen);
		
		il.append(methodGen.loadCurrentNode());
		il.append(classGen.loadTranslet());
		if (classGen.isExternal()) {
		    final String className = classGen.getClassName();
		    il.append(new CHECKCAST(cpg.addClass(className)));
		}
		il.append(new INVOKESPECIAL(idx));
	    }
	}
    }

    
    public String toString() {
	final StringBuffer buffer = new StringBuffer(""step("""");
	buffer.append(Axis.names[_axis]).append("""", "").append(_nodeType);
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Predicate pred = (Predicate)_predicates.elementAt(i);
		buffer.append("", "").append(pred.toString());
	    }
	}
	return buffer.append(')').toString();
    }
}
"
org.apache.xalan.xsltc.compiler.UnresolvedRef,7,4,0,16,22,0,0,16,5,0.625,153,1.0,4,0.926829268,0.30952381,2,4,20.28571429,6,1.7143,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class UnresolvedRef extends VariableRefBase {

    private QName           _variableName = null;
    private VariableRefBase _ref = null;
    private VariableBase    _var = null;
    private Stylesheet      _sheet = null;

    public UnresolvedRef(QName name) {
	super();
	_variableName = name;
	_sheet = getStylesheet();
    }

    public QName getName() {
	return(_variableName);
    }

    private ErrorMsg reportError() {
	ErrorMsg err = new ErrorMsg(ErrorMsg.VARIABLE_UNDEF_ERR,
				    _variableName, this);
	getParser().reportError(Constants.ERROR, err);
	return(err);
    }

    private VariableRefBase resolve(Parser parser, SymbolTable stable) {
	
	
	VariableBase ref = parser.lookupVariable(_variableName);
	if (ref == null) ref = (VariableBase)stable.lookupName(_variableName);
	if (ref == null) {
	    reportError();
	    return null;
	}
	
	
	
	if ((_var = findParentVariable()) != null) _var.addDependency(ref);

	
	if (ref instanceof Variable)
	    return(new VariableRef((Variable)ref));
	else if (ref instanceof Param)
	    return(new ParameterRef((Param)ref));
	else
	    return null;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_ref != null) {
	    final String name = _variableName.toString();
	    ErrorMsg err = new ErrorMsg(ErrorMsg.CIRCULAR_VARIABLE_ERR,
					name, this);
	}
	if ((_ref = resolve(getParser(), stable)) != null) {
	    return (_type = _ref.typeCheck(stable));
	}
	throw new TypeCheckError(reportError());
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (_ref != null)
	    _ref.translate(classGen, methodGen);
	else
	    reportError();
    }

    public String toString() {
	return ""unresolved-ref()"";
    }

}
"
org.apache.xpath.operations.Lt,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class Lt extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.lessThan(right) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xpath.functions.FuncSubstringBefore,2,5,0,5,8,1,0,5,2,2.0,34,0.0,0,0.98245614,0.75,1,6,16.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncSubstringBefore extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String s1 = m_arg0.execute(xctxt).str();
    String s2 = m_arg1.execute(xctxt).str();
    int index = s1.indexOf(s2);

    return (-1 == index)
           ? XString.EMPTYSTRING : new XString(s1.substring(0, index));
  }
}
"
org.apache.xalan.templates.OutputProperties,35,3,0,15,75,323,9,7,35,0.205882353,556,1.0,0,0.859649123,0.234920635,0,0,14.85714286,13,1.9429,2,"
package org.apache.xalan.templates;

import java.util.Enumeration;
import java.util.Properties;
import java.util.Vector;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.serializer.OutputPropertiesFactory;
import org.apache.xml.serializer.OutputPropertyUtils;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.QName;


public class OutputProperties extends ElemTemplateElement
        implements Cloneable
{

  
  public OutputProperties()
  {
    this(org.apache.xml.serializer.Method.XML);
  }

  
  public OutputProperties(Properties defaults)
  {
    m_properties = new Properties(defaults);
  }

  
  public OutputProperties(String method)
  {
    m_properties = new Properties(
        OutputPropertiesFactory.getDefaultMethodProperties(method));
  }

  
  public Object clone()
  {

    try
    {
      OutputProperties cloned = (OutputProperties) super.clone();

      cloned.m_properties = (Properties) cloned.m_properties.clone();

      return cloned;
    }
    catch (CloneNotSupportedException e)
    {
      return null;
    }
  }

  
  public void setProperty(QName key, String value)
  {
    setProperty(key.toNamespacedString(), value);
  }

  
  public void setProperty(String key, String value)
  {
    if(key.equals(OutputKeys.METHOD))
    {
      setMethodDefaults(value);
    }
    
    if (key.startsWith(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL))
      key = OutputPropertiesFactory.S_BUILTIN_EXTENSIONS_UNIVERSAL
         + key.substring(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN);
    
    m_properties.put(key, value);
  }

  
  public String getProperty(QName key)
  {
    return m_properties.getProperty(key.toNamespacedString());
  }

  
  public String getProperty(String key) 
  {
    if (key.startsWith(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL))
      key = OutputPropertiesFactory.S_BUILTIN_EXTENSIONS_UNIVERSAL 
        + key.substring(OutputPropertiesFactory.S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN);
    return m_properties.getProperty(key);
  }

  
  public void setBooleanProperty(QName key, boolean value)
  {
    m_properties.put(key.toNamespacedString(), value ? ""yes"" : ""no"");
  }

  
  public void setBooleanProperty(String key, boolean value)
  {
    m_properties.put(key, value ? ""yes"" : ""no"");
  }

  
  public boolean getBooleanProperty(QName key)
  {
    return getBooleanProperty(key.toNamespacedString());
  }

  
  public boolean getBooleanProperty(String key)
  {
    return OutputPropertyUtils.getBooleanProperty(key, m_properties);
  }

  
  public void setIntProperty(QName key, int value)
  {
    setIntProperty(key.toNamespacedString(), value);
  }

  
  public void setIntProperty(String key, int value)
  {
    m_properties.put(key, Integer.toString(value));
  }

  
  public int getIntProperty(QName key)
  {
    return getIntProperty(key.toNamespacedString());
  }

  
  public int getIntProperty(String key)
  {
    return OutputPropertyUtils.getIntProperty(key, m_properties);
  }


  
  public void setQNameProperty(QName key, QName value)
  {
    setQNameProperty(key.toNamespacedString(), value);
  }
  
  
  public void setMethodDefaults(String method)
  {
        String defaultMethod = m_properties.getProperty(OutputKeys.METHOD);
 
        if((null == defaultMethod) || !defaultMethod.equals(method)
         
         
         
         
         
         
         
         || defaultMethod.equals(""xml"")
         )
        {
            Properties savedProps = m_properties;
            Properties newDefaults = 
                OutputPropertiesFactory.getDefaultMethodProperties(method);
            m_properties = new Properties(newDefaults);
            copyFrom(savedProps, false);
        }
  }
  

  
  public void setQNameProperty(String key, QName value)
  {
    setProperty(key, value.toNamespacedString());
  }

  
  public QName getQNameProperty(QName key)
  {
    return getQNameProperty(key.toNamespacedString());
  }

  
  public QName getQNameProperty(String key)
  {
    return getQNameProperty(key, m_properties);
  }

  
  public static QName getQNameProperty(String key, Properties props)
  {

    String s = props.getProperty(key);

    if (null != s)
      return QName.getQNameFromString(s);
    else
      return null;
  }

  
  public void setQNameProperties(QName key, Vector v)
  {
    setQNameProperties(key.toNamespacedString(), v);
  }

  
  public void setQNameProperties(String key, Vector v)
  {

    int s = v.size();

    
    FastStringBuffer fsb = new FastStringBuffer(9,9);

    for (int i = 0; i < s; i++)
    {
      QName qname = (QName) v.elementAt(i);

      fsb.append(qname.toNamespacedString());
      
      if (i < s-1) 
        fsb.append(' ');
    }

    m_properties.put(key, fsb.toString());
  }

  
  public Vector getQNameProperties(QName key)
  {
    return getQNameProperties(key.toNamespacedString());
  }

  
  public Vector getQNameProperties(String key)
  {
    return getQNameProperties(key, m_properties);
  }

  
  public static Vector getQNameProperties(String key, Properties props)
  {

    String s = props.getProperty(key);

    if (null != s)
    {
      Vector v = new Vector();
      int l = s.length();
      boolean inCurly = false;
      FastStringBuffer buf = new FastStringBuffer();

      
      
      
      for (int i = 0; i < l; i++)
      {
        char c = s.charAt(i);

        if (Character.isWhitespace(c))
        {
          if (!inCurly)
          {
            if (buf.length() > 0)
            {
              QName qname = QName.getQNameFromString(buf.toString());
              v.addElement(qname);
              buf.reset();
            }
            continue;
          }
        }
        else if ('{' == c)
          inCurly = true;
        else if ('}' == c)
          inCurly = false;

        buf.append(c);
      }

      if (buf.length() > 0)
      {
        QName qname = QName.getQNameFromString(buf.toString());
        v.addElement(qname);
        buf.reset();
      }

      return v;
    }
    else
      return null;
  }

  
  public void recompose(StylesheetRoot root)
    throws TransformerException
  {
    root.recomposeOutput(this);
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {

    super.compose(sroot);

  }

  
  public Properties getProperties()
  {
    return m_properties;
  }
  
  
  public void copyFrom(Properties src)
  {
    copyFrom(src, true);
  }

  
  public void copyFrom(Properties src, boolean shouldResetDefaults)
  {

    Enumeration enum = src.keys();

    while (enum.hasMoreElements())
    {
      String key = (String) enum.nextElement();
    
      if (!isLegalPropertyKey(key))
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{key})); 
      
      Object oldValue = m_properties.get(key);
      if (null == oldValue)
      {
        String val = (String) src.get(key);
        
        if(shouldResetDefaults && key.equals(OutputKeys.METHOD))
        {
          setMethodDefaults(val);
        }

        m_properties.put(key, val);
      }
      else if (key.equals(OutputKeys.CDATA_SECTION_ELEMENTS))
      {
        m_properties.put(key, (String) oldValue + "" "" + (String) src.get(key));
      }
    }
  }

  
  public void copyFrom(OutputProperties opsrc)
    throws TransformerException
  {
   
    
    copyFrom(opsrc.getProperties());
  }

  
  public static boolean isLegalPropertyKey(String key)
  {

    return (key.equals(OutputKeys.CDATA_SECTION_ELEMENTS)
            || key.equals(OutputKeys.DOCTYPE_PUBLIC)
            || key.equals(OutputKeys.DOCTYPE_SYSTEM)
            || key.equals(OutputKeys.ENCODING)
            || key.equals(OutputKeys.INDENT)
            || key.equals(OutputKeys.MEDIA_TYPE)
            || key.equals(OutputKeys.METHOD)
            || key.equals(OutputKeys.OMIT_XML_DECLARATION)
            || key.equals(OutputKeys.STANDALONE)
            || key.equals(OutputKeys.VERSION)
            || (key.length() > 0) && (key.charAt(0) == '{'));
  }

  
  private Properties m_properties = null;

    
    static public Properties getDefaultMethodProperties(String method)
    {
        return org.apache.xml.serializer.OutputPropertiesFactory.getDefaultMethodProperties(method);
    }
}
"
org.apache.xml.serializer.ToXMLSAXHandler,44,3,0,8,95,716,3,5,40,0.930232558,683,1.0,0,0.730263158,0.15034965,2,13,14.5,1,0.9318,4,"
 package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.util.Properties;

import javax.xml.transform.Result;

import org.w3c.dom.Node;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;


public class ToXMLSAXHandler extends ToSAXHandler
{

    
    protected boolean m_escapeSetting = false;

    public ToXMLSAXHandler()
    {
        
        m_prefixMap = new NamespaceMappings();
        initCDATA();
    }

    
    public Properties getOutputFormat()
    {
        return null;
    }

    
    public OutputStream getOutputStream()
    {
        return null;
    }

    
    public Writer getWriter()
    {
        return null;
    }

    
    public void indent(int n) throws SAXException
    {
    }

    
    public boolean reset()
    {
        return false;
    }

    
    public void serialize(Node node) throws IOException
    {
    }

    
    public boolean setEscaping(boolean escape) throws SAXException
    {
        boolean oldEscapeSetting = m_escapeSetting;
        m_escapeSetting = escape;

        if (escape) {
            processingInstruction(Result.PI_ENABLE_OUTPUT_ESCAPING, """");
        } else {
            processingInstruction(Result.PI_DISABLE_OUTPUT_ESCAPING, """");
        }

        return oldEscapeSetting;
    }

    
    public void setOutputFormat(Properties format)
    {
    }

    
    public void setOutputStream(OutputStream output)
    {
    }

    
    public void setWriter(Writer writer)
    {
    }

    
    public void attributeDecl(
        String arg0,
        String arg1,
        String arg2,
        String arg3,
        String arg4)
        throws SAXException
    {
    }

    
    public void elementDecl(String arg0, String arg1) throws SAXException
    {
    }

    
    public void externalEntityDecl(String arg0, String arg1, String arg2)
        throws SAXException
    {
    }

    
    public void internalEntityDecl(String arg0, String arg1)
        throws SAXException
    {
    }

    
    public void endDocument() throws SAXException
    {

        flushPending();

        
        m_saxHandler.endDocument();

        super.fireEndDoc();
    }

    
    protected void closeStartTag() throws SAXException
    {

        m_startTagOpen = false;

        final String localName = getLocalName(m_elementName);
        final String uri = getNamespaceURI(m_elementName, true);

        
        if (m_needToCallStartDocument)
        {
            startDocumentInternal();
        }
        m_saxHandler.startElement(uri, localName, m_elementName, m_attributes);
        
        
        m_attributes.clear();

        if(m_state != null)
          m_state.setCurrentNode(null);

        pushCdataSectionState();

    }

    
    public void closeCDATA() throws SAXException
    {

        
        m_saxHandler.characters(ENDCDATA, 0, ENDCDATA.length);
        m_cdataTagOpen = false;
    }

    
    public void endElement(String namespaceURI, String localName, String qName)
        throws SAXException
    {
        
        flushPending();
        
        if (namespaceURI == null)
        {
            if (m_elementURI != null)
                namespaceURI = m_elementURI;
            else
                namespaceURI = getNamespaceURI(qName, true);
        }
        
        if (localName == null)
        {
            if (m_elementLocalName != null)
                localName = m_elementLocalName;
            else
                localName = getLocalName(qName);
        }

        m_saxHandler.endElement(namespaceURI, localName, qName);

		super.fireEndElem(qName);       

        
        m_prefixMap.popNamespaces(m_currentElemDepth);
        m_currentElemDepth--;
        m_startTagOpen = false;
        
        m_cdataSectionStates.pop();
    }

    
    public void endPrefixMapping(String prefix) throws SAXException
    {
        
         return;
    }

    
    public void ignorableWhitespace(char[] arg0, int arg1, int arg2)
        throws SAXException
    {
        m_saxHandler.ignorableWhitespace(arg0,arg1,arg2);
    }

    
    public void setDocumentLocator(Locator arg0)
    {
        m_saxHandler.setDocumentLocator(arg0);
    }

    
    public void skippedEntity(String arg0) throws SAXException
    {
        m_saxHandler.skippedEntity(arg0);
    }

    
    public void startPrefixMapping(String prefix, String uri)
        throws SAXException
    {
       startPrefixMapping(prefix, uri, true);
    }

    

    public boolean startPrefixMapping(
        String prefix,
        String uri,
        boolean shouldFlush)
        throws org.xml.sax.SAXException
    {

        

        boolean pushed;
        int pushDepth;
        if (shouldFlush)
        {
            flushPending();
            
            pushDepth = m_currentElemDepth + 1;
        }
        else
        {
            
            pushDepth = m_currentElemDepth;
        }
        pushed = m_prefixMap.pushNamespace(prefix, uri, pushDepth);

        if (pushed)
        {
            m_saxHandler.startPrefixMapping(prefix,uri);
            
            
            String name;
            if (EMPTYSTRING.equals(prefix))
            {
                name = ""xmlns"";
                addAttributeAlways(XMLNS_URI, prefix, name,""CDATA"",uri);
            }
            else {
                if (!EMPTYSTRING.equals(uri)) 
                {                             
                    name = ""xmlns:"" + prefix;

                    
                    addAttributeAlways(XMLNS_URI, prefix, name,""CDATA"",uri);
                }
            }
        }
        return pushed;
    }
        

    
    public void comment(char[] arg0, int arg1, int arg2) throws SAXException
    {
        flushPending();
        if (m_lexHandler != null)
            m_lexHandler.comment(arg0, arg1, arg2);
            
        super.fireCommentEvent(arg0, arg1, arg2);
    }

    
    public void endCDATA() throws SAXException
    {
        if (m_lexHandler != null)
            m_lexHandler.endCDATA();
    }

    
    public void endDTD() throws SAXException
    {
        if (m_lexHandler != null)
            m_lexHandler.endDTD();
    }

    
    public void startEntity(String arg0) throws SAXException
    {
        if (m_lexHandler != null)
            m_lexHandler.startEntity(arg0);
    }

    
    public void characters(String chars) throws SAXException
    {
        final char[] arr = chars.toCharArray();
        this.characters(arr,0,arr.length);
    }

    
    public ToXMLSAXHandler(ContentHandler handler, String encoding)
    {
        super(handler, encoding);

        initCDATA();
        
        m_prefixMap = new NamespaceMappings();
    }

    public ToXMLSAXHandler(
        ContentHandler handler,
        LexicalHandler lex,
        String encoding)
    {
        super(handler, lex, encoding);

        initCDATA();
        
        m_prefixMap = new NamespaceMappings();
    }

    
    public void startElement(
    String elementNamespaceURI,
    String elementLocalName,
    String elementName) throws SAXException
    {
        startElement(
            elementNamespaceURI,elementLocalName,elementName, null);


    }
    public void startElement(String elementName) throws SAXException
    {
        startElement(null, null, elementName, null);
    }


    public void characters(char[] ch, int off, int len) throws SAXException
    {
        

        flushPending();

        if (m_cdataSectionStates.peekOrFalse())
        {
            startCDATA(ch, off, len);
        }
        else
        {
            m_saxHandler.characters(ch, off, len);
        }

		
		fireCharEvent(ch, off, len);
    }
    

    
    public void endElement(String elemName) throws SAXException
    {
        endElement(null, null, elemName);
    }    


    
    public void namespaceAfterStartElement(
        final String prefix,
        final String uri)
        throws SAXException
    {
        startPrefixMapping(prefix,uri,false);
    }

    
    public void processingInstruction(String target, String data)
        throws SAXException
    {
        flushPending();

        
        m_saxHandler.processingInstruction(target, data);

        
        
        super.fireEscapingEvent(target, data);        
    }

    
    protected boolean popNamespace(String prefix)
    {
        try
        {
            if (m_prefixMap.popNamespace(prefix))
            {
                m_saxHandler.endPrefixMapping(prefix);
                return true;
            }
        }
        catch (SAXException e)
        {
            
        }
        return false;
    }

    public void startCDATA() throws SAXException
    {

        
        m_saxHandler.characters(BEGCDATA, 0, BEGCDATA.length);
        m_cdataTagOpen = true;

    }

    
    private void startCDATA(char[] ch, int off, int len) throws SAXException
    {
        final int limit = off + len;
        int offset = off;

        
        m_saxHandler.characters(BEGCDATA, 0, BEGCDATA.length);

        
        for (int i = offset; i < limit - 2; i++)
        {
            if (ch[i] == ']' && ch[i + 1] == ']' && ch[i + 2] == '>')
            {
                m_saxHandler.characters(ch, offset, i - offset);
                m_saxHandler.characters(CNTCDATA, 0, CNTCDATA.length);
                offset = i + 3;
                i += 2; 
            }
        }

        
        if (offset < limit)
        {
            m_saxHandler.characters(ch, offset, limit - offset);
        }
        m_cdataTagOpen = true;
    }

    
    public void startElement(
    String namespaceURI,
    String localName,
    String name,
    Attributes atts)
        throws SAXException
    {
        flushPending();
        super.startElement(namespaceURI, localName, name, atts);

        
         if (m_needToOutputDocTypeDecl)
         {
             String doctypeSystem = getDoctypeSystem();
             if (doctypeSystem != null && m_lexHandler != null)
             {
                 String doctypePublic = getDoctypePublic();
                 if (doctypeSystem != null)
                     m_lexHandler.startDTD(
                         name,
                         doctypePublic,
                         doctypeSystem);
             }
             m_needToOutputDocTypeDecl = false;
         }

        m_currentElemDepth++; 

        
        
        if (namespaceURI != null)
            ensurePrefixIsDeclared(namespaceURI, name);

        
        m_elementLocalName = localName;  
        m_elementURI = namespaceURI;     
        m_elementName = name;            

        
        if (atts != null)
            addAttributes(atts);

        m_startTagOpen = true;
         
        
        pushCdataSectionState();
   
    }
 
    private void ensurePrefixIsDeclared(String ns, String rawName)
        throws org.xml.sax.SAXException
    {

        if (ns != null && ns.length() > 0)
        {
            int index;
            String prefix =
                (index = rawName.indexOf("":"")) < 0
                    ? """"
                    : rawName.substring(0, index);

            if (null != prefix)
            {
                String foundURI = m_prefixMap.lookupNamespace(prefix);

                if ((null == foundURI) || !foundURI.equals(ns))
                {
                    this.startPrefixMapping(prefix, ns, false);

                    
                    
                    this.addAttributeAlways(
                        ""http:
                        prefix,
                        ""xmlns"" + (prefix.length() == 0 ? """" : "":"") + prefix,
                        ""CDATA"",
                        ns);
                }

            }
        }
    }
    
    public void addAttribute(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
        throws SAXException
    {      
        if (m_startTagOpen)
        {
            ensurePrefixIsDeclared(uri, rawName);
            addAttributeAlways(uri, localName, rawName, type, value);
        }

    }    

}
"
org.apache.xalan.templates.ElemEmpty,1,3,0,1,2,0,0,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xalan.templates;



public class ElemEmpty extends ElemTemplateElement
{

  
  public ElemEmpty(){}
}
"
org.apache.xalan.res.XSLTErrorResources_ja,3,4,0,1,4,1,0,1,2,1.423076923,3769,0.0,0,0.976190476,1.0,0,0,1251.0,1,0.3333,0,"
package org.apache.xalan.res;



public class XSLTErrorResources_ja extends XSLTErrorResources
{

  
  public static final int MAX_CODE = 201;          

  
  public static final int MAX_WARNING = 29;

  
  public static final int MAX_OTHERS = 55;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  

  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_NO_CURLYBRACE,
      ""エラー: 式の中で '{' を持つことはできません""},
  


  
  


  {
    ER_ILLEGAL_ATTRIBUTE, ""{0} に不当な属性が含まれています: {1}""},
  


  
  


  {
    ER_NULL_SOURCENODE_APPLYIMPORTS,
      ""xsl:apply-imports で sourceNode が null です""},
  


  
  


  {
    ER_CANNOT_ADD, ""{0} を {1} に追加できません""},
  


  
  


  {
    ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES,
      ""handleApplyTemplatesInstruction で sourceNode が null です。""},
  


  
  


  {
    ER_NO_NAME_ATTRIB, ""{0} には名前属性が必要です。""},
  


  
  


  {
    ER_TEMPLATE_NOT_FOUND, ""{0} という名前のテンプレートが見つかりませんでした。""},
  


  
  


  {
    ER_CANT_RESOLVE_NAME_AVT,
      ""xls:call-template で名前 AVT を解決できませんでした。""},
  


  
  


  {
    ER_REQUIRES_ATTRIB, ""{0} には属性 {1} が必要です:""},
  


  
  


  {
    ER_MUST_HAVE_TEST_ATTRIB,
      ""{0} には ''test'' 属性が必要です。""},
  


  
  


  {
    ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""レベル属性に不正な値が指定されています: {0}""},
  


  
  


  {
    ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""processing-instruction 名は 'xml' にできません""},
  


  
  


  {
    ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""processing-instruction 名は有効な NCName でなくてはなりません: {0}""},
  


  
  


  {
    ER_NEED_MATCH_ATTRIB,
      ""{0} にモードがある場合、一致する属性を持たなくてはなりません。""},
  


  
  


  {
    ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0} は name 属性か、または match 属性を必要とします。""},
  


  
  


  {
    ER_CANT_RESOLVE_NSPREFIX,
      ""名前空間の接頭辞 {0} を解決できません""},
  


  
  


  {
    ER_ILLEGAL_VALUE, ""xml:space に不当な値があります: {0}""},
  


  
  


  {
    ER_NO_OWNERDOC,
      ""子ノードは所有者ドキュメントを保持しません。""},
  


  
  


  {
    ER_ELEMTEMPLATEELEM_ERR, ""ElemTemplateElement エラー: {0}""},
  


  
  


  {
    ER_NULL_CHILD, ""null である子を追加しています。""},
  


  
  


  {
    ER_NEED_SELECT_ATTRIB, ""{0} は select 属性が必要です。""},
  


  
  


  {
    ER_NEED_TEST_ATTRIB,
      ""xsl:when には 'test' 属性が必要です。""},
  


  
  


  {
    ER_NEED_NAME_ATTRIB,
      ""xsl:with-param には 'name' 属性が必要です。""},
  


  
  


  {
    ER_NO_CONTEXT_OWNERDOC,
      ""コンテキストは所有者ドキュメントを保持しません。""},
  


  
  


  {
    ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""XML TransformerFactory Liaison {0} を作成できませんでした。""},
  


  
  


  {
    ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: プロセスは成功しませんでした。""},
  


  
  


  {
    ER_NOT_SUCCESSFUL, ""Xalan: は成功しませんでした。""},
  


  
  


  {
    ER_ENCODING_NOT_SUPPORTED, ""エンコーディングはサポートされていません: {0}""},
  


  
  


  {
    ER_COULD_NOT_CREATE_TRACELISTENER,
      ""TraceListener を作成できませんでした: {0}""},
  


  
  


  {
    ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key には 'name' 属性が必要です。""},
  


  
  


  {
    ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key には 'match' 属性が必要です。""},
  


  
  


  {
    ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key には 'use' 属性が必要です。""},
  


  
  


  {
    ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0} には ''elements'' 属性が必要です。""},
  


  
  


  {
    ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} 属性に ''prefix'' が足りません""},
  


  
  


  {
    ER_BAD_STYLESHEET_URL, ""スタイルシートの URL が不正です: {0}""},
  


  
  


  {
    ER_FILE_NOT_FOUND, ""スタイルシートファイルが見つかりませんでした: {0}""},



  
  


  {
    ER_IOEXCEPTION,
      ""スタイルシートファイルで入出力例外が発生しました: {0}""},



  
  


  {
    ER_NO_HREF_ATTRIB,
      ""(StylesheetHandler) {0} の href 属性が見つかりませんでした""},



  
  


  {
    ER_STYLESHEET_INCLUDES_ITSELF,
      ""(StylesheetHandler) {0} は直接的または間接的に自身をインクルードしています。""},



  
  


  {
    ER_PROCESSINCLUDE_ERROR,
      ""StylesheetHandler.processInclude エラー、{0}""},



  
  


  {
    ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} 属性 ''lang'' が足りません""},



  
  


  {
    ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) {0} 要素を配置し忘れていませんか?? コンテナ要素 ''component'' が足りません""},



  
  


  {
    ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
      ""Element、DocumentFragment、Document、または PrintWriter にだけ出力できます。""},



  
  


  {
    ER_PROCESS_ERROR, ""StylesheetRoot.process エラー""},



  
  


  {
    ER_UNIMPLNODE_ERROR, ""UnImplNode エラー: {0}""},



  
  


  {
    ER_NO_SELECT_EXPRESSION,
      ""エラー。xpath の選択式 (-select) が見つかりませんでした。""},



  
  


  {
    ER_CANNOT_SERIALIZE_XSLPROCESSOR,
      ""XSLProcessor を直列化できません。""},



  
  


  {
    ER_NO_INPUT_STYLESHEET,
      ""スタイルシートの入力が指定されませんでした。""},



  
  


  {
    ER_FAILED_PROCESS_STYLESHEET,
      ""スタイルシートでの処理に失敗しました。""},



  
  


  {
    ER_COULDNT_PARSE_DOC, ""{0} ドキュメントを構文解析できませんでした。""},



  
  


  {
    ER_COULDNT_FIND_FRAGMENT, ""フラグメント {0} が見つかりませんでした""},



  
  


  {
    ER_NODE_NOT_ELEMENT,
      ""フラグメント識別子が指すノードが要素ではありませんでした: {0}""},



  
  


  {
    ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""for-each は match 属性または name 属性を持たなくてはなりません""},



  
  


  {
    ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB,
      ""テンプレートは match 属性または name 属性を持たなくてはなりません""},



  
  


  {
    ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""ドキュメントのフラグメントにクローンがありません。""},



  
  


  {
    ER_CANT_CREATE_ITEM,
      ""結果ツリーに項目を作成できません: {0}""},



  
  


  {
    ER_XMLSPACE_ILLEGAL_VALUE,
      ""ソース XML の xml:space に不当な値があります: {0}""},



  
  


  {
    ER_NO_XSLKEY_DECLARATION,
      ""{0} に xsl:key 宣言がありません。""},



  
  


  {
    ER_CANT_CREATE_URL, ""エラー。{0} の URL を作成できません""},



  
  


  {
    ER_XSLFUNCTIONS_UNSUPPORTED, ""xsl:functions はサポートされていません""},



  
  


  {
    ER_PROCESSOR_ERROR, ""XSLT TransformerFactory エラー""},



  
  


  {
    ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""(StylesheetHandler) {0} はスタイルシート内で許可されません。""},



  
  


  {
    ER_RESULTNS_NOT_SUPPORTED,
      ""result-ns はもうサポートされていません。代わりに xsl:output を使用してください。""},



  
  


  {
    ER_DEFAULTSPACE_NOT_SUPPORTED,
      ""default-space はもうサポートされていません。代わりに xsl:strip-space または xsl:preserve-space を使用してください。""},



  
  


  {
    ER_INDENTRESULT_NOT_SUPPORTED,
      ""indent-result はもうサポートされていません。代わりに xsl:output を使用してください。""},



  
  


  {
    ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0} に不当な属性があります: {1}""},



  
  


  {
    ER_UNKNOWN_XSL_ELEM, ""未知の XSL 要素: {0}""},



  
  


  {
    ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort は xsl:apply-templates または xsl:for-each といっしょにのみ使用できます。""},



  
  


  {
    ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) xsl:when の配置が誤っています。""},



  
  


  {
    ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:when の親は xsl:choose ではありません。""},



  
  


  {
    ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) xsl:otherwise の配置が誤っています。""},



  
  


  {
    ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:otherwise の親は xsl:choose ではありません。""},



  
  


  {
    ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""(StylesheetHandler) {0} はテンプレートの中に置くことを許可されません。""},



  
  


  {
    ER_UNKNOWN_EXT_NS_PREFIX,
      ""(StylesheetHandler) {0} 拡張名前空間の接頭辞 {1} が未知です""},



  
  


  {
    ER_IMPORTS_AS_FIRST_ELEM,
      ""(StylesheetHandler) スタイルシートの最初の要素でのみインポートが実行可能です。""},



  
  


  {
    ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0} は直接的または間接的に自身をインポートしています。""},



  
  


  {
    ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space に不当な値があります: {0}""},



  
  


  {
    ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""processStylesheet は成功しません。""},



  
  


  {
    ER_SAX_EXCEPTION, ""SAX 例外""},



  
  


  {
    ER_XSLT_ERROR, ""XSLT エラー""},



  
  


  {
    ER_CURRENCY_SIGN_ILLEGAL,
      ""通貨記号は書式パターン文字列で許可されません。""},



  
  


  {
    ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""Document 関数は Stylesheet DOM でサポートされません。""},



  
  


  {
    ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""non-Prefix リゾルバの接頭辞は解決できません。""},



  
  


  {
    ER_REDIRECT_COULDNT_GET_FILENAME,
      ""Rediret 拡張: ファイル名を取得できませんでした - file 属性または select 属性が有効な文字列を戻す必要があります。 ""},



  
  


  {
    ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""Redirect 拡張で FormatterListener を構築できません。""},



  
  


  {
    ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""exclude-result-prefixes の接頭辞が有効ではありません: {0}""},



  
  


  {
    ER_MISSING_NS_URI,
      ""指定された接頭辞の名前空間 URI がありません""},



  
  


  {
    ER_MISSING_ARG_FOR_OPTION,
      ""オプションの引数がありません: {0}""},



  
  


  {
    ER_INVALID_OPTION, ""無効なオプション: {0}""},



  
  


  {
    ER_MALFORMED_FORMAT_STRING, ""形式の誤った文字列: {0}""},



  
  


  {
    ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet には 'version' 属性が必要です。""},



  
  


  {
    ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""属性: {0} に不当な値があります: {1}""},



  
  


  {
    ER_CHOOSE_REQUIRES_WHEN, ""xsl:choose には xsl:when が必要です""},



  
  


  {
    ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""xsl:apply-imports は xsl:for-each で許可されません""},



  
  


  {
    ER_CANT_USE_DTM_FOR_OUTPUT,
      ""出力 DOM ノードに DTMLiaison を使用できません... 代わりに org.apache.xpath.DOM2Helper を渡します。""},



  
  


  {
    ER_CANT_USE_DTM_FOR_INPUT,
      ""入力 DOM ノードに DTMLiaison を使用できません... 代わりに org.apache.xpath.DOM2Helper を渡します。""},



  
  


  {
    ER_CALL_TO_EXT_FAILED,
      ""拡張要素の呼び出しに失敗しました: {0}""},



  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""接頭辞は名前空間に変わる必要があります: {0}""},



  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""無効な UTF-16 代理が検出されました: {0} ?""},



  
  


  {
    ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0} は自身を使用したため、無限ループが発生します。""},



  
  


  {
    ER_CANNOT_MIX_XERCESDOM,
      ""非 Xerces-DOM 入力と Xerces-DOM 出力を混合できません。""},



  
  


  {
    ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},



  
  


  {
    ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""ElemTemplateElement.readObject に {0} があります""},



  
  


  {
    ER_DUPLICATE_NAMED_TEMPLATE,
      ""以下に示す名前のテンプレートが複数見つかりました: {0}""},



  
  


  {
    ER_INVALID_KEY_CALL,
      ""無効な関数呼び出し: recursive key() 呼び出しは許可されません""},


  
  
  


  {
    ER_REFERENCING_ITSELF,
      ""変数 {0} は直接的または間接的に自身を参照しています。""},


  
  
  


  {
    ER_ILLEGAL_DOMSOURCE_INPUT,
      ""newTemplates の DOMSource に対する入力ノードは null にできません。 ""},


	
	
  


  {
    ER_CLASS_NOT_FOUND_FOR_OPTION,
			""オプション {0} に対するクラスファイルが見つかりません""},


	
	
  


  {
    ER_REQUIRED_ELEM_NOT_FOUND,
			""必要な要素が見つかりません: {0}""},


  
  
  


  {
    ER_INPUT_CANNOT_BE_NULL,
			""InputStream は null にできません""},


  
  
  


  {
    ER_URI_CANNOT_BE_NULL,
			""URI は null にできません""},


  
  
  


  {
    ER_FILE_CANNOT_BE_NULL,
			""File は null にできません""},


  
   
  


  {
    ER_SOURCE_CANNOT_BE_NULL,
			""InputSource は null にできません""},


  
  
  


  {
    ER_CANNOT_INIT_BSFMGR,
			""BSF Manager を初期化できませんでした""},


  
  
  


  {
    ER_CANNOT_CMPL_EXTENSN,
			""拡張をコンパイルできませんでした""},


  
  
  


  {
    ER_CANNOT_CREATE_EXTENSN,
       ""拡張 {0} を作成できませんでした。原因: {1}""},


  
  
  


  {
    ER_INSTANCE_MTHD_CALL_REQUIRES,
      ""メソッド {0} のインスタンスメソッド呼び出しは、最初の引数に Objcet インスタンスを必要とします""},


  
  
  


  {
    ER_INVALID_ELEMENT_NAME,
      ""無効な要素名が指定されました {0}""},


  
   
  


  {
    ER_ELEMENT_NAME_METHOD_STATIC,
      ""要素名メソッドは static でなくてはなりません {0}""},


  
   
  


  {
    ER_EXTENSION_FUNC_UNKNOWN,
             ""拡張関数 {0} : {1} は未知です""},


  
   
  


  {
    ER_MORE_MATCH_CONSTRUCTOR,
             ""{0} のコンストラクタに最適な一致が複数個あります {0}""},


  
   
  


  {
    ER_MORE_MATCH_METHOD,
             ""メソッド {0} に最適な一致が複数個あります""},


  
   
  


  {
    ER_MORE_MATCH_ELEMENT,
             ""要素メソッド {0} に最適な一致が複数個あります""},


  
   
  


  {
    ER_INVALID_CONTEXT_PASSED,
             ""{0} を評価するのに無効なコンテキストが渡されました""},


  
   
  


  {
    ER_POOL_EXISTS,
             ""Pool がすでに存在します""},


  
   
  


  {
    ER_NO_DRIVER_NAME,
             ""ドライバの Name が指定されていません""},


  
   
  


  {
    ER_NO_URL,
             ""URL が指定されていません""},


  
   
  


  {
    ER_POOL_SIZE_LESSTHAN_ONE,
             ""1 より小さい Pool のサイズです。""},


  
   
  


  {
    ER_INVALID_DRIVER,
             ""無効なドライバ名が指定されました。""},


  
   
  


  {
    ER_NO_STYLESHEETROOT,
             ""スタイルシートのルートが見つかりませんでした。""},


  
   
  


  {
    ER_ILLEGAL_XMLSPACE_VALUE,
         ""xml:space に不当な値です""},


  
   
  


  {
    ER_PROCESSFROMNODE_FAILED,
         ""processFromNode が失敗しました""},


  
   
  


  {
    ER_RESOURCE_COULD_NOT_LOAD,
        ""リソース [ {0} ] は次のものをロードできませんでした: {1} 
 {2} 	 {3}""},

 {2} 	 {3}""},

   
  
   
  


  {
    ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""バッファサイズ <=0""},


  
   
  


  {
    ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""拡張を呼び出すときに未知のエラーが発生しました""},


  
   
  


  {
    ER_NO_NAMESPACE_DECL,
        ""接頭辞 {0} には対応する名前空間宣言がありません""},


  
   
  


  {
    ER_ELEM_CONTENT_NOT_ALLOWED,
        ""要素の内容は lang=javaclass {0} に許可されません""},

     
  
   
  


  {
    ER_STYLESHEET_DIRECTED_TERMINATION,
        ""スタイルシートにより終了が指示されました""},


  
   
  


  {
    ER_ONE_OR_TWO,
        ""1 または 2""},


  
   
  


  {
    ER_TWO_OR_THREE,
        ""2 または 3""},


  
   
  


  {
    ER_COULD_NOT_LOAD_RESOURCE,
        ""{0} をロードできませんでした (CLASSPATH をチェックしてください)。デフォルトだけを使用します。""},


  
   
  


  {
    ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""デフォルトのテンプレートを初期化できません""},


  
   
  


  {
    ER_RESULT_NULL,
        ""Result は null にはできません""},


    
   
  


  {
    ER_RESULT_COULD_NOT_BE_SET,
        ""Result を設定できませんでした""},


  
   
  


  {
    ER_NO_OUTPUT_SPECIFIED,
        ""出力を指定できませんでした""},


  
   
  


  {
    ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""タイプ {0} の Result に変形できません""},


  
   
  


  {
    ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""タイプ {0} の Source に変形できません""},


  
   
  


  {
    ER_NULL_CONTENT_HANDLER,
        ""Null コンテンツハンドラ""},


  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""Null エラーハンドラ""},


  
   
  


  {
    ER_CANNOT_CALL_PARSE,
        ""ContentHandler が設定されていないと構文解析を呼び出すことができません""},


  
   
  


  {
    ER_NO_PARENT_FOR_FILTER,
        ""フィルタ処理する親がありません""},


  
  
   
  


  {
    ER_NO_STYLESHEET_IN_MEDIA,
         ""{0} にスタイルシートが見つかりません。メディア= {1}""},


  
   
  


  {
    ER_NO_STYLESHEET_PI,
         ""xml-stylesheet PI が {0} に見つかりませんでした""},


  
   
  


  {
    ER_NOT_SUPPORTED,
       ""サポートされません: {0}""},


  
   
  


  {
    ER_PROPERTY_VALUE_BOOLEAN,
       ""プロパティ {0} の値は Boolean インスタンスでなくてはなりません""},


  
   
  


  {
    ER_COULD_NOT_FIND_EXTERN_SCRIPT,
         ""{0} にある外部スクリプトを入手できませんでした。""},


  
  
  


  {
    ER_RESOURCE_COULD_NOT_FIND,
        ""リソース [ {0} ] が見つかりませんでした.
 {1}""},

 {1}""},

  
   
  


  {
    ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""出力プロパティが認められません: {0}""},


  
   
  


  {
    ER_FAILED_CREATING_ELEMLITRSLT,
        ""ElemLiteralResult インスタンスの作成に失敗しました""},

    
  
  
  
  
  
   
  


  {
    ER_VALUE_SHOULD_BE_NUMBER,
        ""▼{0} の値に解析可能な数字が含まれている必要があります""},


  
   
  


  {
    ER_VALUE_SHOULD_EQUAL,
        "" {0} の値は yes または no のいずれかでなくてはなりません""},


 
   
  


  {
    ER_FAILED_CALLING_METHOD,
        "" {0} メソッドの呼び出しに失敗しました""},


  
   
  


  {
    ER_FAILED_CREATING_ELEMTMPL,
        ""ElemTemplateElement インスタンスの作成に失敗しました""},


  
   
  


  {
    ER_CHARS_NOT_ALLOWED,
        ""ドキュメントのこの部分で、文字列は許可されません""},


  
  
  


  {
    ER_ATTR_NOT_ALLOWED,
        """"{0}"" 属性は {1} 要素で許可されません。""},



 
  
  


  {
    ER_BAD_VALUE,
     ""{0} 誤った値 {1} ""},


  
  
  


  {
    ER_ATTRIB_VALUE_NOT_FOUND,
     ""{0} 属性値が見つかりません""},


  
  
  


  {
    ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""{0} 属性値が認められません""},


  
    
  


  {
    ER_NULL_URI_NAMESPACE,
     ""null URI を使って名前空間の接頭辞を生成しようとしています""},
      

  
  
  
  


  {
    ER_NUMBER_TOO_BIG,
     ""▼Long 型整数の最大値を超える数字をフォーマットしようとしています""},





  


  {
    ER_CANNOT_FIND_SAX1_DRIVER,
     ""▼SAX1 ドライバクラス {0} が見つかりません""},




  


  {
    ER_SAX1_DRIVER_NOT_LOADED,
     ""▼SAX1 ドライバクラス {0} が見つかりましたが、ロードできません""},




  


  {
    ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""▼SAX1 ドライバクラス {0} がロードされましたが、インスタンス化できません""},





  


  {
    ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
     ""▼SAX1 ドライバクラス {0} が org.xml.sax.Parser を実装していません""},




  


  {
    ER_PARSER_PROPERTY_NOT_SPECIFIED,
     ""▼システムプロパティ org.xml.sax.parser が指定されていません""},




  


  {
    ER_PARSER_ARG_CANNOT_BE_NULL,
     ""▼パーサ属性は null にできません""},





  


  {
    ER_FEATURE,
     ""▼機能: {0}""},





  


  {
    ER_PROPERTY,
     ""▼プロパティ: {0}""},




  


  {
    ER_NULL_ENTITY_RESOLVER,
     ""▼null エンティティリゾルバ""},




  


  {
    ER_NULL_DTD_HANDLER,
     ""▼null DTD ハンドラ""},




  

  {
    ER_NO_DRIVER_NAME_SPECIFIED,
     ""▼ドライバ名が指定されていません!""},





  

  {
    ER_NO_URL_SPECIFIED,
     ""▼URL が指定されていません!""},





  

  {
    ER_POOLSIZE_LESS_THAN_ONE,
     ""▼プールサイズが 1 より小さい値になっています!""},





  

  {
    ER_INVALID_DRIVER_NAME,
     ""▼無効なドライバ名が指定されています!""},






  

  {
    ER_ERRORLISTENER,
     ""▼エラーリスナー""},





  

  {
    ER_ASSERT_NO_TEMPLATE_PARENT,
     ""▼プログラマエラー! 式に ElemTemplateElement の親が含まれていません!""},





  

  {
    ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
     ""▼RundundentExprEliminator におけるプログラマの表明: {0}""},



  
  

  {
    ER_NOT_ALLOWED_IN_POSITION,
     ""▼スタイルシートのこの位置では、{0} は指定できません!""},



  
  

  {
    ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
     ""▼スタイルシートのこの位置では、空白類以外のテキストは指定できません!""},



  
  
  
  

  {
    INVALID_TCHAR,
     ""▼CHAR 型の属性 {0} に不正な値 {1} が指定されています。CHAR 型の属性に指定できるのは、単一の文字だけです!""},



    
    
    
    
    

  
  
  

  {
    INVALID_QNAME,
     ""▼QNAME 型の属性 {0} に不正な値 {1} が指定されています""},



    
    
    
    
    
    

  
  

  {
    INVALID_ENUM,
     ""▼ENUM 型の属性 {0} に不正な値 {1} が指定されています。有効な値は {2} です。""},









  
  

  {
    INVALID_NMTOKEN,
     ""▼NMTOKEN 型の属性 {0} に不正な値 {1} が指定されています""},









  
  

  {
    INVALID_NCNAME,
     ""▼NCNAME 型の属性 {0} に不正な {1} が指定されています""},









  
  


  {
    INVALID_BOOLEAN,
     ""▼boolean 型の属性 {0} に不正な {1} が指定されています""},









  
  

  {
    INVALID_NUMBER,
     ""▼数字型の属性 {0} に不正な {1} が指定されています""},




  







  
  

  {
    ER_ARG_LITERAL,
     ""▼マッチパターン内に含まれる {0} の引数には、リテラルを指定する必要があります。""},








  
  

  {
    ER_DUPLICATE_GLOBAL_VAR,
     ""▼グローバル変数の宣言が重複しています。""},








  
  

  {
    ER_DUPLICATE_VAR,
     ""▼変数の宣言が重複しています。""},



    
    
    

  
  

  {
    ER_TEMPLATE_NAME_MATCH,
     ""▼xsl:template には、name 属性、match 属性のいずれかまたは両方が含まれている必要があります""},



    
    
    
    
    

  
  

  {
    ER_INVALID_PREFIX,
     ""▼exclude-result-prefixes の接頭辞が有効ではありません: {0}""},



    
    
    
    
    

  
  

  {
    ER_NO_ATTRIB_SET,
     ""▼{0} という名前の attribute-set が存在しません""},



  

  
  


  {
    WG_FOUND_CURLYBRACE,
      ""'}' が見つかりましたが、属性テンプレートが開かれていません。""},



  
  


  {
    WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""警告: count 属性が xsl:number 内の祖先と一致しません。 ターゲット = {0}""},



  
  


  {
    WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""古い構文: 'expr' 属性の名前は 'select' に変更されています。""},



  
  


  {
    WG_NO_LOCALE_IN_FORMATNUMBER,
      ""Xalan は format-number 関数内のロケール名をまだ処理していません。""},



  
  


  {
    WG_LOCALE_NOT_FOUND,
      ""警告: xml:lang={0} のロケールが見つかりませんでした""},



  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""URL を作成できません: {0}""},



  
  


  {
    WG_CANNOT_LOAD_REQUESTED_DOC,
      ""要求されたドキュメントをロードできません: {0}""},



  
  


  {
    WG_CANNOT_FIND_COLLATOR,
      ""<sort xml:lang={0} の Collator が見つかりませんでした""},



  
  


  {
    WG_FUNCTIONS_SHOULD_USE_URL,
      ""古い構文: 関数の指令は {0} の URL を使用する必要があります""},



  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""エンコーディングがサポートされていません: {0}、UTF-8 を使用""},



  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      ""エンコーディングがサポートされていません: {0}、Java {1} を使用""},



  
  


  {
    WG_SPECIFICITY_CONFLICTS,
      ""特定であるべきものの競合が見つかりました: {0} スタイルシートで最後に見つかったものが使用されます。""},



  
  


  {
    WG_PARSING_AND_PREPARING,
      ""========= {0} の構文解析および準備  ==========""},



  
  


  {
    WG_ATTR_TEMPLATE, ""属性テンプレート、{0}""},



  
  


  {
    WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""xsl:strip-space と xsl:preserve-space の間で match 競合します""},



  
  


  {
    WG_ATTRIB_NOT_HANDLED,
      ""Xalan はまだ {0} 属性を処理していません。""},



  
  


  {
    WG_NO_DECIMALFORMAT_DECLARATION,
      ""10 進数形式の宣言が見つかりません: {0}""},



  
  


  {
    WG_OLD_XSLT_NS, ""XSLT 名前空間がない、または不正です。""},



  
  


  {
    WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""デフォルトの xsl:decimal-format 宣言は 1 つだけ許可されます。""},



  
  


  {
    WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""xsl:decimal-format の名前は一意でなくてはなりません。名前 ""{0}"" は重複しています。""},



  
  


  {
    WG_ILLEGAL_ATTRIBUTE,
      ""{0} に不当な属性があります: {1}""},



  
  


  {
    WG_COULD_NOT_RESOLVE_PREFIX,
      ""名前空間の接頭辞を解決できません: {0}。 ノードは無視されます。""},



  
  


  {
    WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet は 'version' 属性が必要です。""},



  
  


  {
    WG_ILLEGAL_ATTRIBUTE_NAME,
      ""不当な属性名: {0}""},



  
  


  {
    WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""属性 {0} に不当な値が使用されています: {1}""},



  
  


  {
    WG_EMPTY_SECOND_ARG,
      ""document 関数の 2 番目の引数の結果のノードセットが空です。最初の引数が使用されます。""},



  

    
    
    


  
  

  {
     WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""▼xsl:processing-instruction の 'name' 属性では、'xml' を値として指定することはできません""},



    
    
    
    

  
  

  {
     WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""▼xsl:processing-instruction の ''name'' 属性には、有効な NCName 値 {0} を指定する必要があります""},



    
    
    
    
    

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_POSITION,
      ""▼子ノードの生成後や要素の生成前に属性 {0} を要素に追加することはできません。その属性は無視されます。""},



    


  
  { ""ui_language"", ""ja""},
  { ""help_language"", ""ja""},
  { ""language"", ""ja""},
    { ""BAD_CODE"",
      ""createMessage のパラメータが範囲外でした""},
    { ""FORMAT_FAILED"",
      ""messageFormat 呼び出しで例外がスローされました""},
    { ""version"", "">>>>>>> Xalan バージョン ""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""はい""},
    { ""line"", ""行番号""},
    { ""column"", ""列番号""},
    { ""xsldone"", ""XSLProcessor: 終了""},
    { ""xslProc_option"",
    ""Xalan-J コマンド行プロセスのクラスオプション:""},
    { ""optionIN"", ""    -IN inputXMLURL""},
    { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
    { ""optionOUT"", ""   [-OUT outputFileName]""},
    { ""optionLXCIN"",
      ""   [-LXCIN compiledStylesheetFileNameIn]""},
    { ""optionLXCOUT"",
      ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
    { ""optionPARSER"",
      ""   [-PARSER は parser liaison のクラス名を完全修飾する]""},
    { ""optionE"",
    ""   [-E (エンティティ参照を拡張しない)]""},
    { ""optionV"",
    ""   [-E (エンティティ参照を拡張しない)]""},
    { ""optionQC"", ""   [-QC (Quiet Pattern Conflicts Warnings)]""},
    { ""optionQ"", ""   [-Q  (非出力モード)]""},
    { ""optionLF"",
      ""   [-LF (出力にのみ改行を使用する {デフォルトは CR/LF})]""},
    { ""optionCR"",
      ""   [-CR (出力にのみキャリッジリターンを使用する {デフォルトは CR/LF})]""},
    { ""optionESCAPE"",
      ""   [-ESCAPE (エスケープする文字列 {デフォルトは <>&""'\r\n}]""},
    { ""optionINDENT"",
      ""   [-INDENT (インデントに設定する空白文字数を制御する {デフォルトは 0})]""},
    { ""optionTT"",
      ""   [-TT (テンプレートが呼び出されたときにトレースする)]""},
    { ""optionTG"",
      ""   [-TG (各生成イベントをトレースする。)]""},
    { ""optionTS"",
    ""   [-TS (各選択イベントをトレースする。)]""},
    { ""optionTTC"",
      ""   [-TTC (テンプレートの子が処理されたときにトレースする。)]""},
    { ""optionTCLASS"",
      ""   [-TCLASS (トレース拡張用の TraceListener クラス。)]""},
    { ""optionVALIDATE"",
      ""   [-VALIDATE (妥当性検査を有効にするかどうかを設定する。デフォルトでは無効。)]""},
    { ""optionEDUMP"",
      ""   [-EDUMP {オプションのファイル名} (エラー発生時にスタックダンプを実行する。)]""},
    { ""optionXML"",
      ""   [-XML (XML フォーマッタを使用して、XML ヘッダを追加する。)]""},
    { ""optionTEXT"",
      ""   [-TEXT (単純な Text フォーマッタを使用する。)]""},
    { ""optionHTML"",
    ""   [-HTML (HTML フォーマッタを使用する。)]""},
    { ""optionPARAM"",
      ""   [-PARAM 名前式 (スタイルシートのパラメータを設定)]""},
    { ""noParsermsg1"",
    ""XSL プロセスは成功しませんでした。""},
    { ""noParsermsg2"",
    ""** パーサが見つかりませんでした **""},
    { ""noParsermsg3"",
    ""クラスパスをチェックしてください。""},
    { ""noParsermsg4"",
      ""Java 用に IBM の XML パーサがない場合、以下からダウンロードできます""},
    { ""noParsermsg5"",
      ""IBM's AlphaWorks: http:
    { ""optionURIRESOLVER"",
    ""   [-URIRESOLVER フルクラス名 (URI を解決する場合は URIResolver を使用する)]""},
    { ""optionENTITYRESOLVER"",
    ""   [-ENTITYRESOLVER フルクラス名 (エンティティを解決する場合は EntityResolver を使用する)]""},
    { ""optionCONTENTHANDLER"",
    ""   [-CONTENTHANDLER フルクラス名 (出力を直列化する場合は ContentHandler を使用する)]""},
    { ""optionLINENUMBERS"",
    ""   [-L ソースドキュメントには行番号を使用する]""},
		
    


    { ""optionMEDIA"",
    "" ▼[-MEDIA mediaType (media 属性を使用してドキュメントに関連付けられたスタイルシートを検索する。)]""},
    { ""optionFLAVOR"",
    "" ▼[-FLAVOR flavorName (s2s=SAX または d2d=DOM を明示的に使用してトランスフォームを実行する。)] ""}, 
    { ""optionDIAG"",
    "" ▼[-DIAG (トランスフォームにかかった合計時間 (ミリ秒) を出力する。)]""},
    { ""optionINCREMENTAL"",
    "" ▼[-INCREMENTAL (http:
    { ""optionNOOPTIMIMIZE"",
    "" ▼[-NOOPTIMIMIZE (http:
    { ""optionRL"",
    "" ▼[-RL recursionlimit (スタイルシートの回帰の深さに上限値を設定する。)]""},
    { ""optionXO"",
    "" ▼[-XO [transletName] (生成されたトランスレットの名前を指定する)]""},
    { ""optionXD"",
    "" ▼[-XD destinationDirectory (トランスレットの出力先ディレクトリを指定する)]""},
    { ""optionXJ"",
    "" ▼[-XJ jarfile (トランスレットのクラスを <jarfile> に指定された名前の JAR ファイルにパッケージ化する)]""},
    { ""optionXP"",
    "" ▼[-XP package (生成されたすべてのトランスレットクラスに対するパッケージ名の接頭辞を指定する)]""}



  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""Error: "";

  
  public static final String WARNING_HEADER = ""Warning: "";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}
"
org.apache.xml.serializer.ElemDesc,4,1,0,2,8,0,1,1,0,1.269230769,80,0.0,1,0.0,0.833333333,0,0,12.5,3,1.75,0,"
package org.apache.xml.serializer;

import org.apache.xml.utils.StringToIntTable;


class ElemDesc
{
    
    int m_flags;

    
    StringToIntTable m_attrs = null;

    
    static final int EMPTY = (1 << 1);

    
    static final int FLOW = (1 << 2);

    
    static final int BLOCK = (1 << 3);

    
    static final int BLOCKFORM = (1 << 4);

    
    static final int BLOCKFORMFIELDSET = (1 << 5);

    
    static final int CDATA = (1 << 6);

    
    static final int PCDATA = (1 << 7);

    
    static final int RAW = (1 << 8);

    
    static final int INLINE = (1 << 9);

    
    static final int INLINEA = (1 << 10);

    
    static final int INLINELABEL = (1 << 11);

    
    static final int FONTSTYLE = (1 << 12);

    
    static final int PHRASE = (1 << 13);

    
    static final int FORMCTRL = (1 << 14);

    
    static final int SPECIAL = (1 << 15);

    
    static final int ASPECIAL = (1 << 16);

    
    static final int HEADMISC = (1 << 17);

    
    static final int HEAD = (1 << 18);

    
    static final int LIST = (1 << 19);

    
    static final int PREFORMATTED = (1 << 20);

    
    static final int WHITESPACESENSITIVE = (1 << 21);

    
    static final int HEADELEM = (1 << 22);

    
    static final int ATTRURL = (1 << 1);

    
    static final int ATTREMPTY = (1 << 2);

    
    ElemDesc(int flags)
    {
        m_flags = flags;
    }

    
    boolean is(int flags)
    {

        
        return (m_flags & flags) != 0;
    }

    
    void setAttr(String name, int flags)
    {

        if (null == m_attrs)
            m_attrs = new StringToIntTable();

        m_attrs.put(name, flags);
    }

    
    boolean isAttrFlagSet(String name, int flags)
    {
        return (null != m_attrs)
            ? ((m_attrs.getIgnoreCase(name) & flags) != 0)
            : false;
    }
}
"
org.apache.xalan.res.XSLTErrorResources,5,3,10,10,16,8,10,0,3,1.24795082,4275,0.0,0,0.926829268,0.333333333,0,0,805.2,2,0.8,2,"
package org.apache.xalan.res;

import java.util.ListResourceBundle;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;


public class XSLTErrorResources extends ListResourceBundle
{



  
  public static final int MAX_CODE = 201;

  
  public static final int MAX_WARNING = 29;

  
  public static final int MAX_OTHERS = 55;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  
  public static final String ER_NO_CURLYBRACE = ""ER_NO_CURLYBRACE"";;
  public static final String ER_ILLEGAL_ATTRIBUTE = ""ER_ILLEGAL_ATTRIBUTE"";
  public static final String ER_NULL_SOURCENODE_APPLYIMPORTS = ""ER_NULL_SOURCENODE_APPLYIMPORTS"";
  public static final String ER_CANNOT_ADD = ""ER_CANNOT_ADD""; 
  public static final String ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES=""ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES"";
  public static final String ER_NO_NAME_ATTRIB = ""ER_NO_NAME_ATTRIB"";
  public static final String ER_TEMPLATE_NOT_FOUND = ""ER_TEMPLATE_NOT_FOUND"";
  public static final String ER_CANT_RESOLVE_NAME_AVT = ""ER_CANT_RESOLVE_NAME_AVT"";
  public static final String ER_REQUIRES_ATTRIB = ""ER_REQUIRES_ATTRIB"";
  public static final String ER_MUST_HAVE_TEST_ATTRIB = ""ER_MUST_HAVE_TEST_ATTRIB"";
  public static final String ER_BAD_VAL_ON_LEVEL_ATTRIB =
	 ""ER_BAD_VAL_ON_LEVEL_ATTRIB"";
  public static final String ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML =
	 ""ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML"";
  public static final String ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = 
	 ""ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME"";
  public static final String ER_NEED_MATCH_ATTRIB = ""ER_NEED_MATCH_ATTRIB"";
  public static final String ER_NEED_NAME_OR_MATCH_ATTRIB = 
	 ""ER_NEED_NAME_OR_MATCH_ATTRIB"";
  public static final String ER_CANT_RESOLVE_NSPREFIX =
	 ""ER_CANT_RESOLVE_NSPREFIX"";
  public static final String ER_ILLEGAL_VALUE = ""ER_ILLEGAL_VALUE"";
  public static final String ER_NO_OWNERDOC = ""ER_NO_OWNERDOC"";
  public static final String ER_ELEMTEMPLATEELEM_ERR =""ER_ELEMTEMPLATEELEM_ERR"";
  public static final String ER_NULL_CHILD = ""ER_NULL_CHILD"";
  public static final String ER_NEED_SELECT_ATTRIB = ""ER_NEED_SELECT_ATTRIB"";
  public static final String ER_NEED_TEST_ATTRIB = ""ER_NEED_TEST_ATTRIB"";
  public static final String ER_NEED_NAME_ATTRIB = ""ER_NEED_NAME_ATTRIB"";
  public static final String ER_NO_CONTEXT_OWNERDOC = ""ER_NO_CONTEXT_OWNERDOC"";
  public static final String ER_COULD_NOT_CREATE_XML_PROC_LIAISON = 
	 ""ER_COULD_NOT_CREATE_XML_PROC_LIAISON"";
  public static final String ER_PROCESS_NOT_SUCCESSFUL = 
	 ""ER_PROCESS_NOT_SUCCESSFUL"";
  public static final String ER_NOT_SUCCESSFUL = ""ER_NOT_SUCCESSFUL"";
  public static final String ER_ENCODING_NOT_SUPPORTED = 
	 ""ER_ENCODING_NOT_SUPPORTED"";
  public static final String ER_COULD_NOT_CREATE_TRACELISTENER = 
	 ""ER_COULD_NOT_CREATE_TRACELISTENER"";
  public static final String ER_KEY_REQUIRES_NAME_ATTRIB = 
	 ""ER_KEY_REQUIRES_NAME_ATTRIB"";
  public static final String ER_KEY_REQUIRES_MATCH_ATTRIB = 
	 ""ER_KEY_REQUIRES_MATCH_ATTRIB"";
  public static final String ER_KEY_REQUIRES_USE_ATTRIB = 
	 ""ER_KEY_REQUIRES_USE_ATTRIB"";
  public static final String ER_REQUIRES_ELEMENTS_ATTRIB = 
	 ""ER_REQUIRES_ELEMENTS_ATTRIB"";
  public static final String ER_MISSING_PREFIX_ATTRIB = 
	 ""ER_MISSING_PREFIX_ATTRIB"";
  public static final String ER_BAD_STYLESHEET_URL = ""ER_BAD_STYLESHEET_URL"";
  public static final String ER_FILE_NOT_FOUND = ""ER_FILE_NOT_FOUND"";
  public static final String ER_IOEXCEPTION = ""ER_IOEXCEPTION"";
  public static final String ER_NO_HREF_ATTRIB = ""ER_NO_HREF_ATTRIB"";
  public static final String ER_STYLESHEET_INCLUDES_ITSELF = 
	 ""ER_STYLESHEET_INCLUDES_ITSELF"";
  public static final String ER_PROCESSINCLUDE_ERROR =""ER_PROCESSINCLUDE_ERROR"";
  public static final String ER_MISSING_LANG_ATTRIB = ""ER_MISSING_LANG_ATTRIB"";
  public static final String ER_MISSING_CONTAINER_ELEMENT_COMPONENT = 
	 ""ER_MISSING_CONTAINER_ELEMENT_COMPONENT"";
  public static final String ER_CAN_ONLY_OUTPUT_TO_ELEMENT = 
	 ""ER_CAN_ONLY_OUTPUT_TO_ELEMENT"";
  public static final String ER_PROCESS_ERROR = ""ER_PROCESS_ERROR"";
  public static final String ER_UNIMPLNODE_ERROR = ""ER_UNIMPLNODE_ERROR"";
  public static final String ER_NO_SELECT_EXPRESSION =""ER_NO_SELECT_EXPRESSION"";
  public static final String ER_CANNOT_SERIALIZE_XSLPROCESSOR = 
	 ""ER_CANNOT_SERIALIZE_XSLPROCESSOR"";
  public static final String ER_NO_INPUT_STYLESHEET = ""ER_NO_INPUT_STYLESHEET"";
  public static final String ER_FAILED_PROCESS_STYLESHEET = 
	 ""ER_FAILED_PROCESS_STYLESHEET"";
  public static final String ER_COULDNT_PARSE_DOC = ""ER_COULDNT_PARSE_DOC"";
  public static final String ER_COULDNT_FIND_FRAGMENT = 
	 ""ER_COULDNT_FIND_FRAGMENT"";
  public static final String ER_NODE_NOT_ELEMENT = ""ER_NODE_NOT_ELEMENT"";
  public static final String ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = 
	 ""ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB"";
  public static final String ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = 
	 ""ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB"";
  public static final String ER_NO_CLONE_OF_DOCUMENT_FRAG = 
	 ""ER_NO_CLONE_OF_DOCUMENT_FRAG"";
  public static final String ER_CANT_CREATE_ITEM = ""ER_CANT_CREATE_ITEM"";
  public static final String ER_XMLSPACE_ILLEGAL_VALUE = 
	 ""ER_XMLSPACE_ILLEGAL_VALUE"";
  public static final String ER_NO_XSLKEY_DECLARATION = 
	 ""ER_NO_XSLKEY_DECLARATION"";
  public static final String ER_CANT_CREATE_URL = ""ER_CANT_CREATE_URL"";
  public static final String ER_XSLFUNCTIONS_UNSUPPORTED = 
	 ""ER_XSLFUNCTIONS_UNSUPPORTED"";
  public static final String ER_PROCESSOR_ERROR = ""ER_PROCESSOR_ERROR"";
  public static final String ER_NOT_ALLOWED_INSIDE_STYLESHEET = 
	 ""ER_NOT_ALLOWED_INSIDE_STYLESHEET"";
  public static final String ER_RESULTNS_NOT_SUPPORTED = 
	 ""ER_RESULTNS_NOT_SUPPORTED"";
  public static final String ER_DEFAULTSPACE_NOT_SUPPORTED = 
	 ""ER_DEFAULTSPACE_NOT_SUPPORTED"";
  public static final String ER_INDENTRESULT_NOT_SUPPORTED = 
	 ""ER_INDENTRESULT_NOT_SUPPORTED"";
  public static final String ER_ILLEGAL_ATTRIB = ""ER_ILLEGAL_ATTRIB"";
  public static final String ER_UNKNOWN_XSL_ELEM = ""ER_UNKNOWN_XSL_ELEM"";
  public static final String ER_BAD_XSLSORT_USE = ""ER_BAD_XSLSORT_USE"";
  public static final String ER_MISPLACED_XSLWHEN = ""ER_MISPLACED_XSLWHEN"";
  public static final String ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = 
	 ""ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE"";
  public static final String ER_MISPLACED_XSLOTHERWISE = 
	 ""ER_MISPLACED_XSLOTHERWISE"";
  public static final String ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = 
	 ""ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE"";
  public static final String ER_NOT_ALLOWED_INSIDE_TEMPLATE = 
	 ""ER_NOT_ALLOWED_INSIDE_TEMPLATE"";
  public static final String ER_UNKNOWN_EXT_NS_PREFIX = 
	 ""ER_UNKNOWN_EXT_NS_PREFIX"";
  public static final String ER_IMPORTS_AS_FIRST_ELEM = 
	 ""ER_IMPORTS_AS_FIRST_ELEM"";
  public static final String ER_IMPORTING_ITSELF = ""ER_IMPORTING_ITSELF"";
  public static final String ER_XMLSPACE_ILLEGAL_VAL =""ER_XMLSPACE_ILLEGAL_VAL"";
  public static final String ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = 
	 ""ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL"";
  public static final String ER_SAX_EXCEPTION = ""ER_SAX_EXCEPTION"";
  public static final String ER_XSLT_ERROR = ""ER_XSLT_ERROR"";
  public static final String ER_CURRENCY_SIGN_ILLEGAL=
	 ""ER_CURRENCY_SIGN_ILLEGAL"";
  public static final String ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = 
	 ""ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM"";
  public static final String ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = 
	 ""ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER"";
  public static final String ER_REDIRECT_COULDNT_GET_FILENAME = 
	 ""ER_REDIRECT_COULDNT_GET_FILENAME"";
  public static final String ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = 
	 ""ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT"";
  public static final String ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = 
	 ""ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX"";
  public static final String ER_MISSING_NS_URI = ""ER_MISSING_NS_URI"";
  public static final String ER_MISSING_ARG_FOR_OPTION = 
	 ""ER_MISSING_ARG_FOR_OPTION"";
  public static final String ER_INVALID_OPTION = ""ER_INVALID_OPTION"";
  public static final String ER_MALFORMED_FORMAT_STRING = 
	 ""ER_MALFORMED_FORMAT_STRING"";
  public static final String ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = 
	 ""ER_STYLESHEET_REQUIRES_VERSION_ATTRIB"";
  public static final String ER_ILLEGAL_ATTRIBUTE_VALUE = 
	 ""ER_ILLEGAL_ATTRIBUTE_VALUE"";
  public static final String ER_CHOOSE_REQUIRES_WHEN =""ER_CHOOSE_REQUIRES_WHEN"";
  public static final String ER_NO_APPLY_IMPORT_IN_FOR_EACH = 
	 ""ER_NO_APPLY_IMPORT_IN_FOR_EACH"";
  public static final String ER_CANT_USE_DTM_FOR_OUTPUT = 
	 ""ER_CANT_USE_DTM_FOR_OUTPUT"";
  public static final String ER_CANT_USE_DTM_FOR_INPUT = 
	 ""ER_CANT_USE_DTM_FOR_INPUT"";
  public static final String ER_CALL_TO_EXT_FAILED = ""ER_CALL_TO_EXT_FAILED"";
  public static final String ER_PREFIX_MUST_RESOLVE = ""ER_PREFIX_MUST_RESOLVE"";
  public static final String ER_INVALID_UTF16_SURROGATE = 
	 ""ER_INVALID_UTF16_SURROGATE"";
  public static final String ER_XSLATTRSET_USED_ITSELF = 
	 ""ER_XSLATTRSET_USED_ITSELF"";
  public static final String ER_CANNOT_MIX_XERCESDOM =""ER_CANNOT_MIX_XERCESDOM"";
  public static final String ER_TOO_MANY_LISTENERS = ""ER_TOO_MANY_LISTENERS"";
  public static final String ER_IN_ELEMTEMPLATEELEM_READOBJECT = 
	 ""ER_IN_ELEMTEMPLATEELEM_READOBJECT"";
  public static final String ER_DUPLICATE_NAMED_TEMPLATE = 
	 ""ER_DUPLICATE_NAMED_TEMPLATE"";
  public static final String ER_INVALID_KEY_CALL = ""ER_INVALID_KEY_CALL"";
  public static final String ER_REFERENCING_ITSELF = ""ER_REFERENCING_ITSELF"";
  public static final String ER_ILLEGAL_DOMSOURCE_INPUT = 
	 ""ER_ILLEGAL_DOMSOURCE_INPUT"";
  public static final String ER_CLASS_NOT_FOUND_FOR_OPTION = 
	 ""ER_CLASS_NOT_FOUND_FOR_OPTION"";
  public static final String ER_REQUIRED_ELEM_NOT_FOUND = 
	 ""ER_REQUIRED_ELEM_NOT_FOUND"";
  public static final String ER_INPUT_CANNOT_BE_NULL =""ER_INPUT_CANNOT_BE_NULL"";
  public static final String ER_URI_CANNOT_BE_NULL = ""ER_URI_CANNOT_BE_NULL"";
  public static final String ER_FILE_CANNOT_BE_NULL = ""ER_FILE_CANNOT_BE_NULL"";
  public static final String ER_SOURCE_CANNOT_BE_NULL = 
	 ""ER_SOURCE_CANNOT_BE_NULL"";
  public static final String ER_CANNOT_INIT_BSFMGR = ""ER_CANNOT_INIT_BSFMGR"";
  public static final String ER_CANNOT_CMPL_EXTENSN = ""ER_CANNOT_CMPL_EXTENSN"";
  public static final String ER_CANNOT_CREATE_EXTENSN = 
	 ""ER_CANNOT_CREATE_EXTENSN"";
  public static final String ER_INSTANCE_MTHD_CALL_REQUIRES = 
	 ""ER_INSTANCE_MTHD_CALL_REQUIRES"";
  public static final String ER_INVALID_ELEMENT_NAME =""ER_INVALID_ELEMENT_NAME"";
  public static final String ER_ELEMENT_NAME_METHOD_STATIC = 
	 ""ER_ELEMENT_NAME_METHOD_STATIC"";
  public static final String ER_EXTENSION_FUNC_UNKNOWN = 
	 ""ER_EXTENSION_FUNC_UNKNOWN"";
  public static final String ER_MORE_MATCH_CONSTRUCTOR = 
	 ""ER_MORE_MATCH_CONSTRUCTOR"";
  public static final String ER_MORE_MATCH_METHOD = ""ER_MORE_MATCH_METHOD"";
  public static final String ER_MORE_MATCH_ELEMENT = ""ER_MORE_MATCH_ELEMENT"";
  public static final String ER_INVALID_CONTEXT_PASSED = 
	 ""ER_INVALID_CONTEXT_PASSED"";
  public static final String ER_POOL_EXISTS = ""ER_POOL_EXISTS"";
  public static final String ER_NO_DRIVER_NAME = ""ER_NO_DRIVER_NAME"";
  public static final String ER_NO_URL = ""ER_NO_URL"";
  public static final String ER_POOL_SIZE_LESSTHAN_ONE = 
	 ""ER_POOL_SIZE_LESSTHAN_ONE"";
  public static final String ER_INVALID_DRIVER = ""ER_INVALID_DRIVER"";
  public static final String ER_NO_STYLESHEETROOT = ""ER_NO_STYLESHEETROOT"";
  public static final String ER_ILLEGAL_XMLSPACE_VALUE = 
	 ""ER_ILLEGAL_XMLSPACE_VALUE"";
  public static final String ER_PROCESSFROMNODE_FAILED = 
	 ""ER_PROCESSFROMNODE_FAILED"";
  public static final String ER_RESOURCE_COULD_NOT_LOAD = 
	 ""ER_RESOURCE_COULD_NOT_LOAD"";
  public static final String ER_BUFFER_SIZE_LESSTHAN_ZERO = 
	 ""ER_BUFFER_SIZE_LESSTHAN_ZERO"";
  public static final String ER_UNKNOWN_ERROR_CALLING_EXTENSION = 
	 ""ER_UNKNOWN_ERROR_CALLING_EXTENSION"";
  public static final String ER_NO_NAMESPACE_DECL = ""ER_NO_NAMESPACE_DECL"";
  public static final String ER_ELEM_CONTENT_NOT_ALLOWED = 
	 ""ER_ELEM_CONTENT_NOT_ALLOWED"";
  public static final String ER_STYLESHEET_DIRECTED_TERMINATION = 
	 ""ER_STYLESHEET_DIRECTED_TERMINATION"";
  public static final String ER_ONE_OR_TWO = ""ER_ONE_OR_TWO"";
  public static final String ER_TWO_OR_THREE = ""ER_TWO_OR_THREE"";
  public static final String ER_COULD_NOT_LOAD_RESOURCE = 
	 ""ER_COULD_NOT_LOAD_RESOURCE"";
  public static final String ER_CANNOT_INIT_DEFAULT_TEMPLATES = 
	 ""ER_CANNOT_INIT_DEFAULT_TEMPLATES"";
  public static final String ER_RESULT_NULL = ""ER_RESULT_NULL"";
  public static final String ER_RESULT_COULD_NOT_BE_SET = 
	 ""ER_RESULT_COULD_NOT_BE_SET"";
  public static final String ER_NO_OUTPUT_SPECIFIED = ""ER_NO_OUTPUT_SPECIFIED"";
  public static final String ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = 
	 ""ER_CANNOT_TRANSFORM_TO_RESULT_TYPE"";
  public static final String ER_CANNOT_TRANSFORM_SOURCE_TYPE = 
	 ""ER_CANNOT_TRANSFORM_SOURCE_TYPE"";
  public static final String ER_NULL_CONTENT_HANDLER =""ER_NULL_CONTENT_HANDLER"";
  public static final String ER_NULL_ERROR_HANDLER = ""ER_NULL_ERROR_HANDLER"";
  public static final String ER_CANNOT_CALL_PARSE = ""ER_CANNOT_CALL_PARSE"";
  public static final String ER_NO_PARENT_FOR_FILTER =""ER_NO_PARENT_FOR_FILTER"";
  public static final String ER_NO_STYLESHEET_IN_MEDIA = 
	 ""ER_NO_STYLESHEET_IN_MEDIA"";
  public static final String ER_NO_STYLESHEET_PI = ""ER_NO_STYLESHEET_PI"";
  public static final String ER_NOT_SUPPORTED = ""ER_NOT_SUPPORTED"";
  public static final String ER_PROPERTY_VALUE_BOOLEAN = 
	 ""ER_PROPERTY_VALUE_BOOLEAN"";
  public static final String ER_COULD_NOT_FIND_EXTERN_SCRIPT = 
	 ""ER_COULD_NOT_FIND_EXTERN_SCRIPT"";
  public static final String ER_RESOURCE_COULD_NOT_FIND = 
	 ""ER_RESOURCE_COULD_NOT_FIND"";
  public static final String ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = 
	 ""ER_OUTPUT_PROPERTY_NOT_RECOGNIZED"";
  public static final String ER_FAILED_CREATING_ELEMLITRSLT = 
	 ""ER_FAILED_CREATING_ELEMLITRSLT"";
  public static final String ER_VALUE_SHOULD_BE_NUMBER = 
	 ""ER_VALUE_SHOULD_BE_NUMBER"";
  public static final String ER_VALUE_SHOULD_EQUAL = ""ER_VALUE_SHOULD_EQUAL"";
  public static final String ER_FAILED_CALLING_METHOD = 
	 ""ER_FAILED_CALLING_METHOD"";
  public static final String ER_FAILED_CREATING_ELEMTMPL = 
	 ""ER_FAILED_CREATING_ELEMTMPL"";
  public static final String ER_CHARS_NOT_ALLOWED = ""ER_CHARS_NOT_ALLOWED"";
  public static final String ER_ATTR_NOT_ALLOWED = ""ER_ATTR_NOT_ALLOWED"";
  public static final String ER_BAD_VALUE = ""ER_BAD_VALUE"";
  public static final String ER_ATTRIB_VALUE_NOT_FOUND = 
	 ""ER_ATTRIB_VALUE_NOT_FOUND"";
  public static final String ER_ATTRIB_VALUE_NOT_RECOGNIZED = 
	 ""ER_ATTRIB_VALUE_NOT_RECOGNIZED"";
  public static final String ER_NULL_URI_NAMESPACE = ""ER_NULL_URI_NAMESPACE"";
  public static final String ER_NUMBER_TOO_BIG = ""ER_NUMBER_TOO_BIG"";
  public static final String  ER_CANNOT_FIND_SAX1_DRIVER = 
	 ""ER_CANNOT_FIND_SAX1_DRIVER"";
  public static final String  ER_SAX1_DRIVER_NOT_LOADED = 
	 ""ER_SAX1_DRIVER_NOT_LOADED"";
  public static final String  ER_SAX1_DRIVER_NOT_INSTANTIATED = 
	 ""ER_SAX1_DRIVER_NOT_INSTANTIATED"" ;
  public static final String ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER = 
	 ""ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER"";
  public static final String  ER_PARSER_PROPERTY_NOT_SPECIFIED = 
	 ""ER_PARSER_PROPERTY_NOT_SPECIFIED"";
  public static final String  ER_PARSER_ARG_CANNOT_BE_NULL = 
	 ""ER_PARSER_ARG_CANNOT_BE_NULL"" ;
  public static final String  ER_FEATURE = ""ER_FEATURE"";
  public static final String ER_PROPERTY = ""ER_PROPERTY"" ;
  public static final String ER_NULL_ENTITY_RESOLVER =""ER_NULL_ENTITY_RESOLVER"";
  public static final String  ER_NULL_DTD_HANDLER = ""ER_NULL_DTD_HANDLER"" ;
  public static final String ER_NO_DRIVER_NAME_SPECIFIED = 
	 ""ER_NO_DRIVER_NAME_SPECIFIED"";
  public static final String ER_NO_URL_SPECIFIED = ""ER_NO_URL_SPECIFIED"";
  public static final String ER_POOLSIZE_LESS_THAN_ONE = 
	 ""ER_POOLSIZE_LESS_THAN_ONE"";
  public static final String ER_INVALID_DRIVER_NAME = ""ER_INVALID_DRIVER_NAME"";
  public static final String ER_ERRORLISTENER = ""ER_ERRORLISTENER"";
  public static final String ER_ASSERT_NO_TEMPLATE_PARENT = 
	 ""ER_ASSERT_NO_TEMPLATE_PARENT"";
  public static final String ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = 
	 ""ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR"";
  public static final String ER_NOT_ALLOWED_IN_POSITION = 
	 ""ER_NOT_ALLOWED_IN_POSITION"";
  public static final String ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = 
	 ""ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION"";
  public static final String INVALID_TCHAR = ""INVALID_TCHAR"";
  public static final String INVALID_QNAME = ""INVALID_QNAME"";
  public static final String INVALID_ENUM = ""INVALID_ENUM"";
  public static final String INVALID_NMTOKEN = ""INVALID_NMTOKEN"";
  public static final String INVALID_NCNAME = ""INVALID_NCNAME"";
  public static final String INVALID_BOOLEAN = ""INVALID_BOOLEAN"";
  public static final String INVALID_NUMBER = ""INVALID_NUMBER"";
  public static final String ER_ARG_LITERAL = ""ER_ARG_LITERAL"";
  public static final String ER_DUPLICATE_GLOBAL_VAR =""ER_DUPLICATE_GLOBAL_VAR"";
  public static final String ER_DUPLICATE_VAR = ""ER_DUPLICATE_VAR"";
  public static final String ER_TEMPLATE_NAME_MATCH = ""ER_TEMPLATE_NAME_MATCH"";
  public static final String ER_INVALID_PREFIX = ""ER_INVALID_PREFIX"";
  public static final String ER_NO_ATTRIB_SET = ""ER_NO_ATTRIB_SET"";

  public static final String WG_FOUND_CURLYBRACE = ""WG_FOUND_CURLYBRACE"";
  public static final String WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = 
	 ""WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR"";
  public static final String WG_EXPR_ATTRIB_CHANGED_TO_SELECT = 
	 ""WG_EXPR_ATTRIB_CHANGED_TO_SELECT"";
  public static final String WG_NO_LOCALE_IN_FORMATNUMBER = 
	 ""WG_NO_LOCALE_IN_FORMATNUMBER"";
  public static final String WG_LOCALE_NOT_FOUND = ""WG_LOCALE_NOT_FOUND"";
  public static final String WG_CANNOT_MAKE_URL_FROM =""WG_CANNOT_MAKE_URL_FROM"";
  public static final String WG_CANNOT_LOAD_REQUESTED_DOC = 
	 ""WG_CANNOT_LOAD_REQUESTED_DOC"";
  public static final String WG_CANNOT_FIND_COLLATOR =""WG_CANNOT_FIND_COLLATOR"";
  public static final String WG_FUNCTIONS_SHOULD_USE_URL = 
	 ""WG_FUNCTIONS_SHOULD_USE_URL"";
  public static final String WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = 
	 ""WG_ENCODING_NOT_SUPPORTED_USING_UTF8"";
  public static final String WG_ENCODING_NOT_SUPPORTED_USING_JAVA = 
	 ""WG_ENCODING_NOT_SUPPORTED_USING_JAVA"";
  public static final String WG_SPECIFICITY_CONFLICTS = 
	 ""WG_SPECIFICITY_CONFLICTS"";
  public static final String WG_PARSING_AND_PREPARING = 
	 ""WG_PARSING_AND_PREPARING"";
  public static final String WG_ATTR_TEMPLATE = ""WG_ATTR_TEMPLATE"";
  public static final String WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE = ""WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESP"";
  public static final String WG_ATTRIB_NOT_HANDLED = ""WG_ATTRIB_NOT_HANDLED"";
  public static final String WG_NO_DECIMALFORMAT_DECLARATION = 
	 ""WG_NO_DECIMALFORMAT_DECLARATION"";
  public static final String WG_OLD_XSLT_NS = ""WG_OLD_XSLT_NS"";
  public static final String WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = 
	 ""WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED"";
  public static final String WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = 
	 ""WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE"";
  public static final String WG_ILLEGAL_ATTRIBUTE = ""WG_ILLEGAL_ATTRIBUTE"";
  public static final String WG_COULD_NOT_RESOLVE_PREFIX = 
	 ""WG_COULD_NOT_RESOLVE_PREFIX"";
  public static final String WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = 
	 ""WG_STYLESHEET_REQUIRES_VERSION_ATTRIB"";
  public static final String WG_ILLEGAL_ATTRIBUTE_NAME = 
	 ""WG_ILLEGAL_ATTRIBUTE_NAME"";
  public static final String WG_ILLEGAL_ATTRIBUTE_VALUE = 
	 ""WG_ILLEGAL_ATTRIBUTE_VALUE"";
  public static final String WG_EMPTY_SECOND_ARG = ""WG_EMPTY_SECOND_ARG"";
  public static final String WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = 
	 ""WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML"";
  public static final String WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = 
	 ""WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME"";
  public static final String WG_ILLEGAL_ATTRIBUTE_POSITION = 
	 ""WG_ILLEGAL_ATTRIBUTE_POSITION"";



  

  

  
  public static final Object[][] contents = {

  
  {""ER0000"" , ""{0}"" },
 

  
 


    { ER_NO_CURLYBRACE,                            
      ""Error: Can not have '{' within expression""},

  


    { ER_ILLEGAL_ATTRIBUTE , 
     ""{0} has an illegal attribute: {1}""},

  


  {ER_NULL_SOURCENODE_APPLYIMPORTS ,
      ""sourceNode is null in xsl:apply-imports!""},

  
 

  {ER_CANNOT_ADD,
      ""Can not add {0} to {1}""},


  



    { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES, 
      ""sourceNode is null in handleApplyTemplatesInstruction!""},

  



    { ER_NO_NAME_ATTRIB, 
     ""{0} must have a name attribute.""},

  
  


    {ER_TEMPLATE_NOT_FOUND,
     ""Could not find template named: {0}""},

  
  

    {ER_CANT_RESOLVE_NAME_AVT,
      ""Could not resolve name AVT in xsl:call-template.""},

  
  


    {ER_REQUIRES_ATTRIB,
     ""{0} requires attribute: {1}""},

  
 


    { ER_MUST_HAVE_TEST_ATTRIB, 
      ""{0} must have a ''test'' attribute.""},

  



    {ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""Bad value on level attribute: {0}""},

  



    {ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML, 
      ""processing-instruction name can not be 'xml'""},

  



    { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""processing-instruction name must be a valid NCName: {0}""},

  



    { ER_NEED_MATCH_ATTRIB,
      ""{0} must have a match attribute if it has a mode.""},

  



    { ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0} requires either a name or a match attribute.""},

  



    {ER_CANT_RESOLVE_NSPREFIX,
      ""Can not resolve namespace prefix: {0}""},

  



    { ER_ILLEGAL_VALUE,
     ""xml:space has an illegal value: {0}""},

  



    { ER_NO_OWNERDOC,
      ""Child node does not have an owner document!""},

  



    { ER_ELEMTEMPLATEELEM_ERR,
     ""ElemTemplateElement error: {0}""},

  



    { ER_NULL_CHILD,
     ""Trying to add a null child!""},

  



    { ER_NEED_SELECT_ATTRIB,
     ""{0} requires a select attribute.""},

  



    { ER_NEED_TEST_ATTRIB ,
      ""xsl:when must have a 'test' attribute.""},

  



    { ER_NEED_NAME_ATTRIB,
      ""xsl:with-param must have a 'name' attribute.""},

  



    { ER_NO_CONTEXT_OWNERDOC,
      ""context does not have an owner document!""},

  



    {ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""Could not create XML TransformerFactory Liaison: {0}""},

  



    {ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: Process was not successful.""},

  



    { ER_NOT_SUCCESSFUL,
     ""Xalan: was not successful.""},

  



    { ER_ENCODING_NOT_SUPPORTED,
     ""Encoding not supported: {0}""},

  



    {ER_COULD_NOT_CREATE_TRACELISTENER,
      ""Could not create TraceListener: {0}""},

  



    {ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key requires a 'name' attribute!""},

  



    { ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key requires a 'match' attribute!""},

  



    { ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key requires a 'use' attribute!""},

  



    { ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0} requires an ''elements'' attribute!""},

  



    { ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} attribute ''prefix'' is missing""},

  



    { ER_BAD_STYLESHEET_URL,
     ""Stylesheet URL is bad: {0}""},

  



    { ER_FILE_NOT_FOUND,
     ""Stylesheet file was not found: {0}""},

  



    { ER_IOEXCEPTION,
      ""Had IO Exception with stylesheet file: {0}""},

  



    { ER_NO_HREF_ATTRIB, 
      ""(StylesheetHandler) Could not find href attribute for {0}""},

  



    { ER_STYLESHEET_INCLUDES_ITSELF, 
      ""(StylesheetHandler) {0} is directly or indirectly including itself!""},

  



    { ER_PROCESSINCLUDE_ERROR,
      ""StylesheetHandler.processInclude error, {0}""},

  



    { ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} attribute ''lang'' is missing""},

  


    { ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) misplaced {0} element?? Missing container element ''component''""},

  


    { ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
      ""Can only output to an Element, DocumentFragment, Document, or PrintWriter.""},

  


    { ER_PROCESS_ERROR,
     ""StylesheetRoot.process error""},

  


    { ER_UNIMPLNODE_ERROR,
     ""UnImplNode error: {0}""},

  


    { ER_NO_SELECT_EXPRESSION,
      ""Error! Did not find xpath select expression (-select).""},

  


    { ER_CANNOT_SERIALIZE_XSLPROCESSOR, 
      ""Can not serialize an XSLProcessor!""},

  


    { ER_NO_INPUT_STYLESHEET,
      ""Stylesheet input was not specified!""},

  


    { ER_FAILED_PROCESS_STYLESHEET,
      ""Failed to process stylesheet!""},

  


    { ER_COULDNT_PARSE_DOC,       
     ""Could not parse {0} document!""},

  


    { ER_COULDNT_FIND_FRAGMENT,
     ""Could not find fragment: {0}""},

  
 

    { ER_NODE_NOT_ELEMENT,
      ""Node pointed to by fragment identifier was not an element: {0}""},

  


    { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""for-each must have either a match or name attribute""},

  


    { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB, 
      ""templates must have either a match or name attribute""},

  


    { ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""No clone of a document fragment!""},

  


    { ER_CANT_CREATE_ITEM,
      ""Can not create item in result tree: {0}""},

  


    { ER_XMLSPACE_ILLEGAL_VALUE,
      ""xml:space in the source XML has an illegal value: {0}""},

  


    { ER_NO_XSLKEY_DECLARATION,
      ""There is no xsl:key declaration for {0}!""},

  


    { ER_CANT_CREATE_URL, 
     ""Error! Cannot create url for: {0}""},

  


    { ER_XSLFUNCTIONS_UNSUPPORTED,
     ""xsl:functions is unsupported""},

  


    { ER_PROCESSOR_ERROR, 
     ""XSLT TransformerFactory Error""},

  


    { ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""(StylesheetHandler) {0} not allowed inside a stylesheet!""},

  


    { ER_RESULTNS_NOT_SUPPORTED, 
      ""result-ns no longer supported!  Use xsl:output instead.""},

  


    { ER_DEFAULTSPACE_NOT_SUPPORTED, 
      ""default-space no longer supported!  Use xsl:strip-space or xsl:preserve-space instead.""},

  


    { ER_INDENTRESULT_NOT_SUPPORTED,
      ""indent-result no longer supported!  Use xsl:output instead.""},

  


    { ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0} has an illegal attribute: {1}""},

  


    { ER_UNKNOWN_XSL_ELEM,
     ""Unknown XSL element: {0}""},

  


    { ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort can only be used with xsl:apply-templates or xsl:for-each.""},

  


    { ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) misplaced xsl:when!""},

  


    { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:when not parented by xsl:choose!""},

  


    { ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) misplaced xsl:otherwise!""},

  


    { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:otherwise not parented by xsl:choose!""},

  


    { ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""(StylesheetHandler) {0} is not allowed inside a template!""},

  


    { ER_UNKNOWN_EXT_NS_PREFIX, 
      ""(StylesheetHandler) {0} extension namespace prefix {1} unknown""},

  


    { ER_IMPORTS_AS_FIRST_ELEM, 
      ""(StylesheetHandler) Imports can only occur as the first elements in the stylesheet!""},

  


    { ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0} is directly or indirectly importing itself!""},

  


    { ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space has an illegal value: {0}""},

  


    { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""processStylesheet not succesfull!""},

  


    { ER_SAX_EXCEPTION, 
     ""SAX Exception""},

  


    
    

  


    { ER_XSLT_ERROR,
     ""XSLT Error""},

  


    { ER_CURRENCY_SIGN_ILLEGAL,
      ""currency sign is not allowed in format pattern string""},

  


    { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""Document function not supported in Stylesheet DOM!""},

  


    { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""Can't resolve prefix of non-Prefix resolver!""},

  


    { ER_REDIRECT_COULDNT_GET_FILENAME,
      ""Redirect extension: Could not get filename - file or select attribute must return vald string.""},

  


    { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""Can not build FormatterListener in Redirect extension!""},

  


    { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""Prefix in exclude-result-prefixes is not valid: {0}""},

  


    { ER_MISSING_NS_URI, 
      ""Missing namespace URI for specified prefix""},

  


    { ER_MISSING_ARG_FOR_OPTION,
      ""Missing argument for option: {0}""},

  


    { ER_INVALID_OPTION,
     ""Invalid option: {0}""},

  


    { ER_MALFORMED_FORMAT_STRING,
     ""Malformed format string: {0}""},

  


    { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet requires a 'version' attribute!""},

  


    { ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""Attribute: {0} has an illegal value: {1}""},

  


    { ER_CHOOSE_REQUIRES_WHEN,
     ""xsl:choose requires an xsl:when""},

  


    { ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""xsl:apply-imports not allowed in a xsl:for-each""},

  


    { ER_CANT_USE_DTM_FOR_OUTPUT,
      ""Cannot use a DTMLiaison for an output DOM node... pass a org.apache.xpath.DOM2Helper instead!""},

  


    { ER_CANT_USE_DTM_FOR_INPUT,
      ""Cannot use a DTMLiaison for a input DOM node... pass a org.apache.xpath.DOM2Helper instead!""},

  


    { ER_CALL_TO_EXT_FAILED,
      ""Call to extension element failed: {0}""},

  


    { ER_PREFIX_MUST_RESOLVE,
      ""Prefix must resolve to a namespace: {0}""},

  


    { ER_INVALID_UTF16_SURROGATE,
      ""Invalid UTF-16 surrogate detected: {0} ?""},

  
 

    { ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0} used itself, which will cause an infinite loop.""},

  


    { ER_CANNOT_MIX_XERCESDOM,
      ""Can not mix non Xerces-DOM input with Xerces-DOM output!""},

  


    { ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},

  


    { ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""In ElemTemplateElement.readObject: {0}""},

  


    { ER_DUPLICATE_NAMED_TEMPLATE,
      ""Found more than one template named: {0}""},

  


    { ER_INVALID_KEY_CALL,
      ""Invalid function call: recursive key() calls are not allowed""},

  


    { ER_REFERENCING_ITSELF,
      ""Variable {0} is directly or indirectly referencing itself!""},

  


    { ER_ILLEGAL_DOMSOURCE_INPUT,
      ""The input node can not be null for a DOMSource for newTemplates!""},

	


    { ER_CLASS_NOT_FOUND_FOR_OPTION,
	""Class file not found for option {0}""},

	


    { ER_REQUIRED_ELEM_NOT_FOUND,
	""Required Element not found: {0}""},

  


    { ER_INPUT_CANNOT_BE_NULL,
	""InputStream cannot be null""},

  


    { ER_URI_CANNOT_BE_NULL,
	""URI cannot be null""},

  


    { ER_FILE_CANNOT_BE_NULL,
	""File cannot be null""},

   


    { ER_SOURCE_CANNOT_BE_NULL,
		""InputSource cannot be null""},

  


    
	

  


    { ER_CANNOT_INIT_BSFMGR,
		""Could not initialize BSF Manager""},

  


    { ER_CANNOT_CMPL_EXTENSN,
		""Could not compile extension""},

  


    { ER_CANNOT_CREATE_EXTENSN,
      ""Could not create extension: {0} because of: {1}""},

  


    { ER_INSTANCE_MTHD_CALL_REQUIRES,
      ""Instance method call to method {0} requires an Object instance as first argument""},

  


    { ER_INVALID_ELEMENT_NAME,
      ""Invalid element name specified {0}""},

   


    { ER_ELEMENT_NAME_METHOD_STATIC,
      ""Element name method must be static {0}""},

   


    { ER_EXTENSION_FUNC_UNKNOWN,
             ""Extension function {0} : {1} is unknown""},

   


    { ER_MORE_MATCH_CONSTRUCTOR,
             ""More than one best match for constructor for {0}""},

   


    { ER_MORE_MATCH_METHOD,
             ""More than one best match for method {0}""},

   


    { ER_MORE_MATCH_ELEMENT,
             ""More than one best match for element method {0}""},

   


    { ER_INVALID_CONTEXT_PASSED,
             ""Invalid context passed to evaluate {0}""},

   


    { ER_POOL_EXISTS,
             ""Pool already exists""},

   


    { ER_NO_DRIVER_NAME,
             ""No driver Name specified""},

   


    { ER_NO_URL,
             ""No URL specified""},

   


    { ER_POOL_SIZE_LESSTHAN_ONE,
             ""Pool size is less than one!""},

   


    { ER_INVALID_DRIVER,
             ""Invalid driver name specified!""},

   


    { ER_NO_STYLESHEETROOT,
             ""Did not find the stylesheet root!""},

   


    { ER_ILLEGAL_XMLSPACE_VALUE,
         ""Illegal value for xml:space""},

   


    { ER_PROCESSFROMNODE_FAILED,
         ""processFromNode failed""},

   


    { ER_RESOURCE_COULD_NOT_LOAD,
        ""The resource [ {0} ] could not load: {1} 
 {2} 	 {3}""},


   


    { ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""Buffer size <=0""},

   


    { ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""Unknown error when calling extension""},

   


    { ER_NO_NAMESPACE_DECL,
        ""Prefix {0} does not have a corresponding namespace declaration""},

   


    { ER_ELEM_CONTENT_NOT_ALLOWED,
        ""Element content not allowed for lang=javaclass {0}""},

   


    { ER_STYLESHEET_DIRECTED_TERMINATION,
        ""Stylesheet directed termination""},

   


    { ER_ONE_OR_TWO,
        ""1 or 2""},

   


    { ER_TWO_OR_THREE,
        ""2 or 3""},

   


    { ER_COULD_NOT_LOAD_RESOURCE,
        ""Could not load {0} (check CLASSPATH), now using just the defaults""},

   


    { ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""Cannot initialize default templates""},

   


    { ER_RESULT_NULL,
        ""Result should not be null""},

   


    { ER_RESULT_COULD_NOT_BE_SET,
        ""Result could not be set""},

   


    { ER_NO_OUTPUT_SPECIFIED,
        ""No output specified""},

   


    { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""Can''t transform to a Result of type {0}""},

   


    { ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""Can''t transform a Source of type {0}""},

   


    { ER_NULL_CONTENT_HANDLER,
        ""Null content handler""},

   

    { ER_NULL_ERROR_HANDLER,
        ""Null error handler""},

   


    { ER_CANNOT_CALL_PARSE,
        ""parse can not be called if the ContentHandler has not been set""},

   


    { ER_NO_PARENT_FOR_FILTER,
        ""No parent for filter""},


   


    { ER_NO_STYLESHEET_IN_MEDIA,
         ""No stylesheet found in: {0}, media= {1}""},

   


    { ER_NO_STYLESHEET_PI,
         ""No xml-stylesheet PI found in: {0}""},

   


    
     

   


    
     

   


    
     

   


    
    

   


    
     

   


    
    

   


    
    

   


    
    
UNEXPECTED: Parser doTerminate answers {0}""},

   


    
    

   


    
     

   


    
    

   


    
     

   


    
    

   


    
    

   


    
     

   


    { ER_NOT_SUPPORTED,
       ""Not supported: {0}""},

   


    
    

   


    
    

   


    
     

   


    
    

   

    
     

   


    { ER_PROPERTY_VALUE_BOOLEAN,
       ""Value for property {0} should be a Boolean instance""},

   


    
    

   


    
    

   


    
     

   


    
    

   


    
    

   


    
    

   


    
    

   


    
    

   


    
    

   


    
    

   


    
    

   


    
    

   


    
    

   


    
    



   


    
    

   


    
    

   


    
     

   


    { ER_COULD_NOT_FIND_EXTERN_SCRIPT,
         ""Could not get to external script at {0}""},

  


    { ER_RESOURCE_COULD_NOT_FIND,
        ""The resource [ {0} ] could not be found.
 {1}""},

   


    { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""Output property not recognized: {0}""},

   


    
    

   


    
    

   


    
    

   


    
    

   


    
    

   


    { ER_FAILED_CREATING_ELEMLITRSLT,
        ""Failed creating ElemLiteralResult instance""},

  
  
  
  

   


    { ER_VALUE_SHOULD_BE_NUMBER,
        ""Value for {0} should contain a parsable number""},

   


    { ER_VALUE_SHOULD_EQUAL,
        ""Value for {0} should equal yes or no""},

   


    { ER_FAILED_CALLING_METHOD,
        ""Failed calling {0} method""},

   


    { ER_FAILED_CREATING_ELEMTMPL,
        ""Failed creating ElemTemplateElement instance""},

   


    { ER_CHARS_NOT_ALLOWED,
        ""Characters are not allowed at this point in the document""},

  

    { ER_ATTR_NOT_ALLOWED,
        """"{0}"" attribute is not allowed on the {1} element!""},

  


    
     

  


    { ER_BAD_VALUE,
     ""{0} bad value {1} ""},

  


    { ER_ATTRIB_VALUE_NOT_FOUND,
     ""{0} attribute value not found ""},

  


    { ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""{0} attribute value not recognized ""},

  


    
   

  


    
    

  


    { ER_NULL_URI_NAMESPACE,
     ""Attempting to generate a namespace prefix with a null URI""},

  

  


    { ER_NUMBER_TOO_BIG,
     ""Attempting to format a number bigger than the largest Long integer""},





    { ER_CANNOT_FIND_SAX1_DRIVER,
     ""Cannot find SAX1 driver class {0}""},




    { ER_SAX1_DRIVER_NOT_LOADED,
     ""SAX1 driver class {0} found but cannot be loaded""},




    { ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""SAX1 driver class {0} loaded but cannot be instantiated""},





    { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
     ""SAX1 driver class {0} does not implement org.xml.sax.Parser""},




    { ER_PARSER_PROPERTY_NOT_SPECIFIED,
     ""System property org.xml.sax.parser not specified""},




    { ER_PARSER_ARG_CANNOT_BE_NULL,
     ""Parser argument must not be null""},





    { ER_FEATURE,
     ""Feature: {0}""},





    { ER_PROPERTY,
     ""Property: {0}""},




    { ER_NULL_ENTITY_RESOLVER,
     ""Null entity resolver""},




    { ER_NULL_DTD_HANDLER,
     ""Null DTD handler""},



    { ER_NO_DRIVER_NAME_SPECIFIED,
     ""No Driver Name Specified!""},




    { ER_NO_URL_SPECIFIED,
     ""No URL Specified!""},




    { ER_POOLSIZE_LESS_THAN_ONE,
     ""Pool size is less than 1!""},




    { ER_INVALID_DRIVER_NAME,
     ""Invalid Driver Name Specified!""},





    { ER_ERRORLISTENER,
     ""ErrorListener""},










    { ER_ASSERT_NO_TEMPLATE_PARENT,
     ""Programmer's error! The expression has no ElemTemplateElement parent!""},











    { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
     ""Programmer''s assertion in RedundentExprEliminator: {0}""},



    
    



    
    

  

    { ER_NOT_ALLOWED_IN_POSITION,
     ""{0} is not allowed in this position in the stylesheet!""},

  

    { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
     ""Non-whitespace text is not allowed in this position in the stylesheet!""},

  
  

  
    { INVALID_TCHAR,
     ""Illegal value: {1} used for CHAR attribute: {0}.  An attribute of type CHAR must be only 1 character!""},


    
    

  

    
    

    
    
    
    
    

  
  

    { INVALID_QNAME,
     ""Illegal value: {1} used for QNAME attribute: {0}""},

    
    
    
    
    
    

  

    { INVALID_ENUM,
     ""Illegal value: {1} used for ENUM attribute: {0}.  Valid values are: {2}.""},







  

    { INVALID_NMTOKEN,
     ""Illegal value: {1} used for NMTOKEN attribute: {0} ""},







  

    { INVALID_NCNAME,
     ""Illegal value: {1} used for NCNAME attribute: {0} ""},







  


    { INVALID_BOOLEAN,
     ""Illegal value: {1} used for boolean attribute: {0} ""},







  

     { INVALID_NUMBER,
     ""Illegal value: {1} used for number attribute: {0} ""},


  







  

    { ER_ARG_LITERAL,
     ""Argument to {0} in match pattern must be a literal.""},






  

    { ER_DUPLICATE_GLOBAL_VAR,
     ""Duplicate global variable declaration.""},






  

    { ER_DUPLICATE_VAR,
     ""Duplicate variable declaration.""},

    
    
    

  

    { ER_TEMPLATE_NAME_MATCH,
     ""xsl:template must have a name or match attribute (or both)""},

    
    
    
    
    

  

    { ER_INVALID_PREFIX,
     ""Prefix in exclude-result-prefixes is not valid: {0}""},

    
    
    
    
    

  

    { ER_NO_ATTRIB_SET,
     ""attribute-set named {0} does not exist""},





  

  

    { WG_FOUND_CURLYBRACE,
      ""Found '}' but no attribute template open!""},

  


    { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""Warning: count attribute does not match an ancestor in xsl:number! Target = {0}""},

  


    { WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""Old syntax: The name of the 'expr' attribute has been changed to 'select'.""},

  


    { WG_NO_LOCALE_IN_FORMATNUMBER,
      ""Xalan doesn't yet handle the locale name in the format-number function.""},

  


    { WG_LOCALE_NOT_FOUND,
      ""Warning: Could not find locale for xml:lang={0}""},

  


    { WG_CANNOT_MAKE_URL_FROM,
      ""Can not make URL from: {0}""},

  


    { WG_CANNOT_LOAD_REQUESTED_DOC,
      ""Can not load requested doc: {0}""},

  

    { WG_CANNOT_FIND_COLLATOR,
      ""Could not find Collator for <sort xml:lang={0}""},

  


    { WG_FUNCTIONS_SHOULD_USE_URL,
      ""Old syntax: the functions instruction should use a url of {0}""},

  


    { WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""encoding not supported: {0}, using UTF-8""},

  


    { WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      ""encoding not supported: {0}, using Java {1}""},

  


    { WG_SPECIFICITY_CONFLICTS,
      ""Specificity conflicts found: {0} Last found in stylesheet will be used.""},

  


    { WG_PARSING_AND_PREPARING,
      ""========= Parsing and preparing {0} ==========""},

  


    { WG_ATTR_TEMPLATE,
     ""Attr Template, {0}""},

  


    { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""Match conflict between xsl:strip-space and xsl:preserve-space""},

  


    { WG_ATTRIB_NOT_HANDLED,
      ""Xalan does not yet handle the {0} attribute!""},

  


    { WG_NO_DECIMALFORMAT_DECLARATION,
      ""No declaration found for decimal format: {0}""},

  


    { WG_OLD_XSLT_NS,
     ""Missing or incorrect XSLT Namespace. ""},

  


    { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""Only one default xsl:decimal-format declaration is allowed.""},

  


    { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""xsl:decimal-format names must be unique. Name ""{0}"" has been duplicated.""},

  
  

    { WG_ILLEGAL_ATTRIBUTE,
      ""{0} has an illegal attribute: {1}""},

  


    { WG_COULD_NOT_RESOLVE_PREFIX,
      ""Could not resolve namespace prefix: {0}. The node will be ignored.""},

  

    { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet requires a 'version' attribute!""},

  


    { WG_ILLEGAL_ATTRIBUTE_NAME,
      ""Illegal attribute name: {0}""},

  

    { WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""Illegal value used for attribute {0}: {1}""},

  


    { WG_EMPTY_SECOND_ARG,
      ""Resulting nodeset from second argument of document function is empty. Return an empty node-set.""},

  

    
    
    


  

    { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""The value of the 'name' attribute of xsl:processing-instruction name must not be 'xml'""},

    
    
    
    

  

    { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""The value of the 'name' attribute of xsl:processing-instruction must be a valid NCName: {0}""},

    
    
    
    
    

  

    { WG_ILLEGAL_ATTRIBUTE_POSITION,
      ""Cannot add attribute {0} after child nodes or before an element is produced.  Attribute will be ignored.""},

    

  
  { ""ui_language"", ""en""},
  {  ""help_language"",  ""en"" },
  {  ""language"",  ""en"" },
  { ""BAD_CODE"", ""Parameter to createMessage was out of bounds""},
  {  ""FORMAT_FAILED"", ""Exception thrown during messageFormat call""},
  {  ""version"", "">>>>>>> Xalan Version ""},
  {  ""version2"",  ""<<<<<<<""},
  {  ""yes"", ""yes""},
  { ""line"", ""Line #""},
  { ""column"",""Column #""},
  { ""xsldone"", ""XSLProcessor: done""},


  
  
  
  { ""xslProc_option"", ""Xalan-J command line Process class options:""},
  { ""xslProc_option"", ""Xalan-J command line Process class options:""},
  { ""xslProc_invalid_xsltc_option"", ""The option {0} is not supported in XSLTC mode.""},
  { ""xslProc_invalid_xalan_option"", ""The option {0} can only be used with -XSLTC.""},
  { ""xslProc_no_input"", ""Error: No stylesheet or input xml is specified. Run this command without any option for usage instructions.""},
  { ""xslProc_common_options"", ""-Common Options-""},
  { ""xslProc_xalan_options"", ""-Options for Xalan-""},
  { ""xslProc_xsltc_options"", ""-Options for XSLTC-""},
  { ""xslProc_return_to_continue"", ""(press <return> to continue)""},

   
   
   
   
   
  { ""optionXSLTC"", ""   [-XSLTC (use XSLTC for transformation)]""},
  { ""optionIN"", ""   [-IN inputXMLURL]""},
  { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
  { ""optionOUT"",  ""   [-OUT outputFileName]""},
  { ""optionLXCIN"", ""   [-LXCIN compiledStylesheetFileNameIn]""},
  { ""optionLXCOUT"", ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
  { ""optionPARSER"", ""   [-PARSER fully qualified class name of parser liaison]""},
  {  ""optionE"", ""   [-E (Do not expand entity refs)]""},
  {  ""optionV"",  ""   [-E (Do not expand entity refs)]""},
  {  ""optionQC"", ""   [-QC (Quiet Pattern Conflicts Warnings)]""},
  {  ""optionQ"", ""   [-Q  (Quiet Mode)]""},
  {  ""optionLF"", ""   [-LF (Use linefeeds only on output {default is CR/LF})]""},
  {  ""optionCR"", ""   [-CR (Use carriage returns only on output {default is CR/LF})]""},
  { ""optionESCAPE"", ""   [-ESCAPE (Which characters to escape {default is <>&""'\r\n}]""},
  { ""optionINDENT"", ""   [-INDENT (Control how many spaces to indent {default is 0})]""},
  { ""optionTT"", ""   [-TT (Trace the templates as they are being called.)]""},
  { ""optionTG"", ""   [-TG (Trace each generation event.)]""},
  { ""optionTS"", ""   [-TS (Trace each selection event.)]""},
  {  ""optionTTC"", ""   [-TTC (Trace the template children as they are being processed.)]""},
  { ""optionTCLASS"", ""   [-TCLASS (TraceListener class for trace extensions.)]""},
  { ""optionVALIDATE"", ""   [-VALIDATE (Set whether validation occurs.  Validation is off by default.)]""},
  { ""optionEDUMP"", ""   [-EDUMP {optional filename} (Do stackdump on error.)]""},
  {  ""optionXML"", ""   [-XML (Use XML formatter and add XML header.)]""},
  {  ""optionTEXT"", ""   [-TEXT (Use simple Text formatter.)]""},
  {  ""optionHTML"", ""   [-HTML (Use HTML formatter.)]""},
  {  ""optionPARAM"", ""   [-PARAM name expression (Set a stylesheet parameter)]""},
  {  ""noParsermsg1"", ""XSL Process was not successful.""},
  {  ""noParsermsg2"", ""** Could not find parser **""},
  { ""noParsermsg3"",  ""Please check your classpath.""},
  { ""noParsermsg4"", ""If you don't have IBM's XML Parser for Java, you can download it from""},
  { ""noParsermsg5"", ""IBM's AlphaWorks: http:
  { ""optionURIRESOLVER"", ""   [-URIRESOLVER full class name (URIResolver to be used to resolve URIs)]""},
  { ""optionENTITYRESOLVER"",  ""   [-ENTITYRESOLVER full class name (EntityResolver to be used to resolve entities)]""},
  { ""optionCONTENTHANDLER"",  ""   [-CONTENTHANDLER full class name (ContentHandler to be used to serialize output)]""},
  {  ""optionLINENUMBERS"",  ""   [-L use line numbers for source document]""},

    


  {  ""optionMEDIA"",  ""   [-MEDIA mediaType (use media attribute to find stylesheet associated with a document.)]""},
  {  ""optionFLAVOR"",  ""   [-FLAVOR flavorName (Explicitly use s2s=SAX or d2d=DOM to do transform.)] ""}, 
  { ""optionDIAG"", ""   [-DIAG (Print overall milliseconds transform took.)]""},
  { ""optionINCREMENTAL"",  ""   [-INCREMENTAL (request incremental DTM construction by setting http:
  {  ""optionNOOPTIMIMIZE"",  ""   [-NOOPTIMIMIZE (request no stylesheet optimization proccessing by setting http:
  { ""optionRL"",  ""   [-RL recursionlimit (assert numeric limit on stylesheet recursion depth.)]""},
  {   ""optionXO"",  ""   [-XO [transletName] (assign the name to the generated translet)]""},
  {  ""optionXD"", ""   [-XD destinationDirectory (specify a destination directory for translet)]""},
  {  ""optionXJ"",  ""   [-XJ jarfile (packages translet classes into a jar file of name <jarfile>)]""},
  {   ""optionXP"",  ""   [-XP package (specifies a package name prefix for all generated translet classes)]""},

  
  
  
  
  
  { ""optionXN"",  ""   [-XN (enables template inlining)]"" },
  { ""optionXX"",  ""   [-XX (turns on additional debugging message output)]""},
  { ""optionXT"" , ""   [-XT (use translet to transform if possible)]""},
  { ""diagTiming"","" --------- Transform of {0} via {1} took {2} ms"" },
  { ""recursionTooDeep"",""Template nesting too deep. nesting = {0}, template {1} {2}"" },
  { ""nameIs"", ""name is"" },
  { ""matchPatternIs"", ""match pattern is"" }

  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""Error: "";

  
  public static final String WARNING_HEADER = ""Warning: "";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  public static final XSLTErrorResources loadResourceBundle(String className)
          throws MissingResourceException
  {

    Locale locale = Locale.getDefault();
    String suffix = getResourceSuffix(locale);

    try
    {

      
      return (XSLTErrorResources) ResourceBundle.getBundle(className
              + suffix, locale);
    }
    catch (MissingResourceException e)
    {
      try  
      {

        
        
        return (XSLTErrorResources) ResourceBundle.getBundle(className,
                new Locale(""en"", ""US""));
      }
      catch (MissingResourceException e2)
      {

        
        
        throw new MissingResourceException(
          ""Could not load any resource bundles."", className, """");
      }
    }
  }

  
  private static final String getResourceSuffix(Locale locale)
  {

    String suffix = ""_"" + locale.getLanguage();
    String country = locale.getCountry();

    if (country.equals(""TW""))
      suffix += ""_"" + country;

    return suffix;
  }


}
"
org.apache.xpath.axes.BasicTestIterator,7,5,2,8,24,21,2,7,2,2.0,163,0.0,0,0.9765625,0.371428571,2,4,22.28571429,11,1.8571,0,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.compiler.Compiler;


public abstract class BasicTestIterator extends LocPathIterator
{
  
  protected BasicTestIterator()
  {
  }


  
  protected BasicTestIterator(PrefixResolver nscontext)
  {

    super(nscontext);
  }

  
  protected BasicTestIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, false);
    
    int firstStepPos = compiler.getFirstChildPos(opPos);
    int whatToShow = compiler.getWhatToShow(firstStepPos);

    if ((0 == (whatToShow
               & (DTMFilter.SHOW_ATTRIBUTE 
               | DTMFilter.SHOW_NAMESPACE 
               | DTMFilter.SHOW_ELEMENT
               | DTMFilter.SHOW_PROCESSING_INSTRUCTION))) 
               || (whatToShow == DTMFilter.SHOW_ALL))
      initNodeTest(whatToShow);
    else
    {
      initNodeTest(whatToShow, compiler.getStepNS(firstStepPos),
                              compiler.getStepLocalName(firstStepPos));
    }
    initPredicateInfo(compiler, firstStepPos);
  }

  
  protected BasicTestIterator(
          Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers)
            throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, shouldLoadWalkers);
  }

	
  
  protected abstract int getNextNode();

  
  public int nextNode()
  {      
  	if(m_foundLast)
  	{
  		m_lastFetched = DTM.NULL;
  		return DTM.NULL;
  	}
  		
    if(DTM.NULL == m_lastFetched)
    {
      resetProximityPositions();
    }

    int next;
    
    org.apache.xpath.VariableStack vars;
    int savedStart;
    if (-1 != m_stackFrame)
    {
      vars = m_execContext.getVarStack();

      
      savedStart = vars.getStackFrame();

      vars.setStackFrame(m_stackFrame);
    }
    else
    {
      
      vars = null;
      savedStart = 0;
    }
    
    try
    {
      do
      {
        next = getNextNode();
  
        if (DTM.NULL != next)
        {
          if(DTMIterator.FILTER_ACCEPT == acceptNode(next))
            break;
          else
            continue;
        }
        else
          break;
      }
      while (next != DTM.NULL);
  
      if (DTM.NULL != next)
      {
      	m_pos++;
        return next;
      }
      else
      {
        m_foundLast = true;
  
        return DTM.NULL;
      }
    }
    finally
    {
      if (-1 != m_stackFrame)
      {
        
        vars.setStackFrame(savedStart);
      }
    }
  }
  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    ChildTestIterator clone = (ChildTestIterator) super.cloneWithReset();

    clone.resetProximityPositions();

    return clone;
  }


}

"
org.apache.xalan.xsltc.compiler.UnsupportedElement,7,2,0,11,24,5,1,11,6,0.583333333,131,1.0,2,0.9,0.238095238,1,5,17.42857143,6,1.8571,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class UnsupportedElement extends SyntaxTreeNode {

    private Fallback _fallback = null;
    private ErrorMsg _message = null;

    
    public UnsupportedElement(String uri, String prefix, String local) {
	super(uri, prefix, local);
    }

    
    public void setErrorMessage(ErrorMsg message) {
	_message = message;
    }

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Unsupported element = "" + _qname.getNamespace() +
		     "":"" + _qname.getLocalPart());
	displayContents(indent + IndentIncrement);
    }


    
    private SyntaxTreeNode findFallback(SyntaxTreeNode root) {

	
	if (root == null) return null;

	
	if (root instanceof Fallback) return((Fallback)root);

	
	Vector children = root.getContents();
	if (children != null) {
	    final int count = children.size();
	    for (int i = 0; i < count; i++) {
		SyntaxTreeNode child = (SyntaxTreeNode)children.elementAt(i);
		SyntaxTreeNode node = findFallback(child);
		if (node != null) return node;
	    }
	}
	return null;
    }

    
    public void parseContents(Parser parser) {
	_fallback = (Fallback)findFallback(this);
	if (_fallback != null) {
	    _fallback.activate();
	    _fallback.parseContents(parser);
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_fallback == null) {
	    throw new TypeCheckError(_message);
	}
	return(_fallback.typeCheck(stable));
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (_fallback != null) _fallback.translate(classGen, methodGen);
    }
}
"
org.apache.xalan.xsltc.compiler.Closure,4,1,0,6,4,6,6,1,4,2.0,4,0.0,0,0.0,0.625,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.compiler;

public interface Closure {

    
    public boolean inInnerClass();

    
    public Closure getParentClosure();

    
    public String getInnerClassName();

    
    public void addVariable(VariableRefBase variableRef);
}
"
org.apache.xalan.templates.ElemText,6,3,0,4,11,9,3,1,6,0.6,49,1.0,0,0.975124378,0.444444444,2,6,7.0,3,1.1667,1,"
package org.apache.xalan.templates;

import org.apache.xalan.res.XSLTErrorResources;


public class ElemText extends ElemTemplateElement
{

  
  private boolean m_disableOutputEscaping = false;

  
  public void setDisableOutputEscaping(boolean v)
  {
    m_disableOutputEscaping = v;
  }

  
  public boolean getDisableOutputEscaping()
  {
    return m_disableOutputEscaping;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_TEXT;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_TEXT_STRING;
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {
    case Constants.ELEMNAME_TEXTLITERALRESULT :
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
}
"
org.apache.xalan.xsltc.compiler.BooleanCall,3,4,0,8,11,0,0,8,3,0.0,51,1.0,1,0.979591837,0.444444444,3,13,15.66666667,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class BooleanCall extends FunctionCall {

    private Expression _arg = null;

    public BooleanCall(QName fname, Vector arguments) {
	super(fname, arguments);
	_arg = argument(0);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_arg.typeCheck(stable);
	return _type = Type.Boolean;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	_arg.translate(classGen, methodGen);
	final Type targ = _arg.getType();
	if (!targ.identicalTo(Type.Boolean)) {
	    _arg.startResetIterator(classGen, methodGen);
	    targ.translateTo(classGen, methodGen, Type.Boolean);
	}
    }
}
"
org.apache.xpath.XPathProcessorException,2,5,0,4,4,1,3,1,2,2.0,11,0.0,0,1.0,0.833333333,0,0,4.5,0,0.0,1,"
package org.apache.xpath;


public class XPathProcessorException extends XPathException
{

  
  public XPathProcessorException(String message)
  {
    super(message);
  }
  

  
  public XPathProcessorException(String message, Exception e)
  {
    super(message, e);
  }
}
"
org.apache.xalan.xsltc.dom.CurrentNodeListFilter,1,1,0,3,1,0,1,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xml.dtm.DTMAxisIterator;

public interface CurrentNodeListFilter {
    public abstract boolean test(int node, int position, int last, int current,
				 AbstractTranslet translet, DTMAxisIterator iter);
}
"
org.apache.xpath.operations.Minus,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class Minus extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() - right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (m_left.num(xctxt) - m_right.num(xctxt));
  }

}
"
org.apache.xalan.xsltc.compiler.util.MatchGenerator,10,5,0,9,16,27,1,8,9,0.844444444,79,1.0,0,0.945205479,0.263888889,2,5,6.4,2,0.9,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.Type;

public final class MatchGenerator extends MethodGenerator {
    private static int CURRENT_INDEX = 1;

    private int _iteratorIndex = INVALID_INDEX;

    private final Instruction _iloadCurrent;
    private final Instruction _istoreCurrent;
    private Instruction _aloadDom;
    
    public MatchGenerator(int access_flags, Type return_type, 
			  Type[] arg_types, String[] arg_names, 
			  String method_name, String class_name,
			  InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
	
	_iloadCurrent = new ILOAD(CURRENT_INDEX);
	_istoreCurrent = new ISTORE(CURRENT_INDEX);
    }

    public Instruction loadCurrentNode() {
	return _iloadCurrent;
    }

    public Instruction storeCurrentNode() {
	return _istoreCurrent;
    }
    
    public int getHandlerIndex() {
	return INVALID_INDEX;		
    }

    
    public Instruction loadDOM() {
	return _aloadDom;
    }

    
    public void setDomIndex(int domIndex) {
	_aloadDom = new ALOAD(domIndex);
    }

    
    public int getIteratorIndex() {
	return _iteratorIndex;
    }

    
    public void setIteratorIndex(int iteratorIndex) {
	_iteratorIndex = iteratorIndex;
    }

    public int getLocalIndex(String name) {
	if (name.equals(""current"")) {
	    return CURRENT_INDEX;
	}
	return super.getLocalIndex(name);
    }
}
"
org.apache.xpath.compiler.OpMap,22,1,1,5,38,67,2,3,21,0.873015873,384,0.166666667,2,0.0,0.327272727,0,0,16.18181818,8,1.5455,0,"
package org.apache.xpath.compiler;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.ObjectVector;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.res.XPATHErrorResources;


public class OpMap
{

  
  protected String m_currentPattern;

  
  public String toString()
  {
    return m_currentPattern;
  }

  
  public String getPatternString()
  {
    return m_currentPattern;
  }

  
  static final int MAXTOKENQUEUESIZE = 500;

  
  static final int BLOCKTOKENQUEUESIZE = 500;
  
  
  ObjectVector m_tokenQueue = new ObjectVector(MAXTOKENQUEUESIZE, BLOCKTOKENQUEUESIZE);

  
  public ObjectVector getTokenQueue()
  {
    return m_tokenQueue;
  }

  
  public Object getToken(int pos)
  {
    return m_tokenQueue.elementAt(pos);
  }

  


  
  public int getTokenQueueSize()
  {
    return m_tokenQueue.size();
    
  }

  
  OpMapVector m_opMap = null;

  
  public OpMapVector getOpMap()
  {
    return m_opMap;
  }

  

  
  public static final int MAPINDEX_LENGTH = 1;

  
  void shrink()
  {

    int n = m_opMap.elementAt(MAPINDEX_LENGTH);
    m_opMap.setToSize(n + 4);

    m_opMap.setElementAt(0,n);
    m_opMap.setElementAt(0,n+1);
    m_opMap.setElementAt(0,n+2);


    n = m_tokenQueue.size();
    m_tokenQueue.setToSize(n + 4);

    m_tokenQueue.setElementAt(null,n);
    m_tokenQueue.setElementAt(null,n + 1);
    m_tokenQueue.setElementAt(null,n + 2);
  }

  
  public int getOp(int opPos)
  {
    return m_opMap.elementAt(opPos);
  }

  
  public void setOp(int opPos, int value)
  {
     m_opMap.setElementAt(value,opPos);
  }
  
  
  public int getNextOpPos(int opPos)
  {
    return opPos + m_opMap.elementAt(opPos + 1);
  }

  
  public int getNextStepPos(int opPos)
  {

    int stepType = getOp(opPos);

    if ((stepType >= OpCodes.AXES_START_TYPES)
            && (stepType <= OpCodes.AXES_END_TYPES))
    {
      return getNextOpPos(opPos);
    }
    else if ((stepType >= OpCodes.FIRST_NODESET_OP)
             && (stepType <= OpCodes.LAST_NODESET_OP))
    {
      int newOpPos = getNextOpPos(opPos);

      while (OpCodes.OP_PREDICATE == getOp(newOpPos))
      {
        newOpPos = getNextOpPos(newOpPos);
      }

      stepType = getOp(newOpPos);

      if (!((stepType >= OpCodes.AXES_START_TYPES)
            && (stepType <= OpCodes.AXES_END_TYPES)))
      {
        return OpCodes.ENDOP;
      }

      return newOpPos;
    }
    else
    {
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_UNKNOWN_STEP, new Object[]{new Integer(stepType).toString()})); 
      
    }
  }

  
  public static int getNextOpPos(int[] opMap, int opPos)
  {
    return opPos + opMap[opPos + 1];
  }

  
  public int getFirstPredicateOpPos(int opPos)
     throws javax.xml.transform.TransformerException
  {

    int stepType = m_opMap.elementAt(opPos);

    if ((stepType >= OpCodes.AXES_START_TYPES)
            && (stepType <= OpCodes.AXES_END_TYPES))
    {
      return opPos + m_opMap.elementAt(opPos + 2);
    }
    else if ((stepType >= OpCodes.FIRST_NODESET_OP)
             && (stepType <= OpCodes.LAST_NODESET_OP))
    {
      return opPos + m_opMap.elementAt(opPos + 1);
    }
    else if(-2 == stepType)
    {
      return -2;
    }
    else
    {
      error(org.apache.xpath.res.XPATHErrorResources.ER_UNKNOWN_OPCODE,
            new Object[]{ String.valueOf(stepType) });  
      return -1;
    }
  }
  
  
  public void error(String msg, Object[] args) throws javax.xml.transform.TransformerException
  {

    java.lang.String fmsg = org.apache.xalan.res.XSLMessages.createXPATHMessage(msg, args);
    

    throw new javax.xml.transform.TransformerException(fmsg);
  }


  
  public static int getFirstChildPos(int opPos)
  {
    return opPos + 2;
  }

  
  public int getArgLength(int opPos)
  {
    return m_opMap.elementAt(opPos + MAPINDEX_LENGTH);
  }

  
  public int getArgLengthOfStep(int opPos)
  {
    return m_opMap.elementAt(opPos + MAPINDEX_LENGTH + 1) - 3;
  }

  
  public static int getFirstChildPosOfStep(int opPos)
  {
    return opPos + 3;
  }

  
  public int getStepTestType(int opPosOfStep)
  {
    return m_opMap.elementAt(opPosOfStep + 3);  
  }

  
  public String getStepNS(int opPosOfStep)
  {

    int argLenOfStep = getArgLengthOfStep(opPosOfStep);

    
    if (argLenOfStep == 3)
    {
      int index = m_opMap.elementAt(opPosOfStep + 4);

      if (index >= 0)
        return (String) m_tokenQueue.elementAt(index);
      else if (OpCodes.ELEMWILDCARD == index)
        return NodeTest.WILD;
      else
        return null;
    }
    else
      return null;
  }

  
  public String getStepLocalName(int opPosOfStep)
  {

    int argLenOfStep = getArgLengthOfStep(opPosOfStep);

    
    int index;

    switch (argLenOfStep)
    {
    case 0 :
      index = OpCodes.EMPTY;
      break;
    case 1 :
      index = OpCodes.ELEMWILDCARD;
      break;
    case 2 :
      index = m_opMap.elementAt(opPosOfStep + 4);
      break;
    case 3 :
      index = m_opMap.elementAt(opPosOfStep + 5);
      break;
    default :
      index = OpCodes.EMPTY;
      break;  
    }

    
    
    if (index >= 0)
      return (String) m_tokenQueue.elementAt(index).toString();
    else if (OpCodes.ELEMWILDCARD == index)
      return NodeTest.WILD;
    else
      return null;
  }
  
}
"
org.apache.xml.dtm.SecuritySupport12,5,2,0,5,13,10,5,5,4,2.0,45,0.0,0,0.692307692,0.45,0,0,8.0,1,0.8,0,"

package org.apache.xml.dtm;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.security.PrivilegedActionException;
import java.security.PrivilegedExceptionAction;


class SecuritySupport12 extends SecuritySupport {

    public ClassLoader getContextClassLoader() {
	return (ClassLoader)
		AccessController.doPrivileged(new PrivilegedAction() {
	    public Object run() {
		ClassLoader cl = null;
		try {
		    cl = Thread.currentThread().getContextClassLoader();
		} catch (SecurityException ex) { }
		return cl;
	    }
	});
    }

    public String getSystemProperty(final String propName) {
	return (String)
            AccessController.doPrivileged(new PrivilegedAction() {
                public Object run() {
                    return System.getProperty(propName);
                }
            });
    }


    public FileInputStream getFileInputStream(final File file)
        throws FileNotFoundException
    {
	try {
            return (FileInputStream)
                AccessController.doPrivileged(new PrivilegedExceptionAction() {
                    public Object run() throws FileNotFoundException {
                        return new FileInputStream(file);
                    }
                });
	} catch (PrivilegedActionException e) {
	    throw (FileNotFoundException)e.getException();
	}
    }

    public InputStream getResourceAsStream(final ClassLoader cl,
                                           final String name)
    {
        return (InputStream)
            AccessController.doPrivileged(new PrivilegedAction() {
                public Object run() {
                    InputStream ris;
                    if (cl == null) {
                        ris = ClassLoader.getSystemResourceAsStream(name);
                    } else {
                        ris = cl.getResourceAsStream(name);
                    }
                    return ris;
                }
            });
    }
}
"
org.apache.xalan.xsltc.dom.SAXImpl,71,6,0,62,215,2365,16,51,63,0.958128079,2049,1.0,5,0.748148148,0.151428571,3,8,27.45070423,10,2.0,4,"

package org.apache.xalan.xsltc.dom;

import java.util.Enumeration;

import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.StripFilter;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xalan.xsltc.runtime.Hashtable;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.dtm.ref.DTMAxisIterNodeList;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;
import org.apache.xml.dtm.ref.DTMDefaultBase;
import org.apache.xml.dtm.ref.DTMNodeProxy;
import org.apache.xml.dtm.ref.sax2dtm.SAX2DTM2;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.serializer.ToXMLSAXHandler;
import org.apache.xml.utils.XMLStringFactory;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Entity;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;



public final class SAXImpl extends SAX2DTM2 implements DOM, DOMBuilder
{
    
    
    
    

    
    private int       _uriCount     = 0;
    private int       _prefixCount  = 0;

    
    
    private int[]   _xmlSpaceStack;
    private int     _idx = 1;
    private boolean _preserve = false;

    private static final String XML_STRING = ""xml:"";
    private static final String XML_PREFIX   = ""xml"";   
    private static final String XMLSPACE_STRING = ""xml:space"";
    private static final String PRESERVE_STRING = ""preserve"";
    private static final String XMLNS_PREFIX = ""xmlns"";
    private static final String XML_URI = ""http:

    private boolean _escaping = true;
    private boolean _disableEscaping = false;
    private int _textNodeToProcess = DTM.NULL;

    
    
    

    
    private final static String EMPTYSTRING = """";

    
    private final static DTMAxisIterator EMPTYITERATOR =
        new DTMAxisIteratorBase() {
            public DTMAxisIterator reset() { return this; }
            public DTMAxisIterator setStartNode(int node) { return this; }
            public int next() { return DTM.NULL; }
            public void setMark() {}
            public void gotoMark() {}
            public int getLast() { return 0; }
            public int getPosition() { return 0; }
            public DTMAxisIterator cloneIterator() { return this; }
            public void setRestartable(boolean isRestartable) { }
        };
    
    
    private int _namesSize = 0;

    
    private Hashtable _nsIndex = new Hashtable();
   
    
    private int _size = 0;
    
    
    private BitArray  _dontEscape = null;

    
    private String    _documentURI = null;
    static private int _documentURIIndex = 0;

    
    private Document _document;

    
    
    
    private Hashtable _node2Ids = null;

    
    private boolean _hasDOMSource = false;

    
    private XSLTCDTMManager _dtmManager;

    
    private Node[] _nodes;
    private NodeList[] _nodeLists;
    private final static String XML_LANG_ATTRIBUTE =
        ""http:

    
    public void setDocumentURI(String uri) {
        setDocumentBaseURI(uri);
        _documentURI = uri;
    }

    
    public String getDocumentURI() {
        String baseURI = getDocumentBaseURI();
        return (baseURI != null) ? baseURI : ""rtf"" + _documentURIIndex++;
    }

    public String getDocumentURI(int node) {
        return getDocumentURI();
    }

    public void setupMapping(String[] names, String[] namespaces) {
        
    }

    
    public String lookupNamespace(int node, String prefix)
        throws TransletException
    {
        int anode, nsnode;
        final AncestorIterator ancestors = new AncestorIterator();

        if (isElement(node)) {
            ancestors.includeSelf();
        }

        ancestors.setStartNode(node);
        while ((anode = ancestors.next()) != DTM.NULL) {
            final NamespaceIterator namespaces = new NamespaceIterator();

            namespaces.setStartNode(anode);
            while ((nsnode = namespaces.next()) != DTM.NULL) {
                if (getLocalName(nsnode).equals(prefix)) {
                    return getNodeValue(nsnode);
                }
            }
        }

        BasisLibrary.runTimeError(BasisLibrary.NAMESPACE_PREFIX_ERR, prefix);
        return null;
    }

    
    public boolean isElement(final int node) {
        return getNodeType(node) == DTM.ELEMENT_NODE;
    }

    
    public boolean isAttribute(final int node) {
        return getNodeType(node) == DTM.ATTRIBUTE_NODE;
    }

    
    public int getSize() {
        return getNumberOfNodes();
    }

    
    public void setFilter(StripFilter filter) {
    }


    
    public boolean lessThan(int node1, int node2) {
        if (node1 == DTM.NULL) {
            return false;
        }

        if (node2 == DTM.NULL) {
            return true;
        }

        return (node1 < node2);
    }

    
    public Node makeNode(int index) {
        if (_nodes == null) {
            _nodes = new Node[_namesSize];
        }

        return (_nodes[index] != null)
                    ? _nodes[index]
                    : (_nodes[index] = new DTMNodeProxy((DTM)this, index));
    }

    
    public Node makeNode(DTMAxisIterator iter) {
        return makeNode(iter.next());
    }

    
    public NodeList makeNodeList(int index) {
        if (_nodeLists == null) {
            _nodeLists = new NodeList[_namesSize];
        }
        return (_nodeLists[index] != null)
                 ? _nodeLists[index]
                 : (_nodeLists[index] =
                         new DTMAxisIterNodeList(this,
                                                 new SingletonIterator(index)));
    }

    
    public NodeList makeNodeList(DTMAxisIterator iter) {
        return new DTMAxisIterNodeList(this, iter);
    }

    
    public class TypedNamespaceIterator extends NamespaceIterator {
        
        private final int _nodeType;

        
        public TypedNamespaceIterator(int nodeType) {
            super();
            _nodeType = nodeType;
        }

       
        public int next() {
            int node;

            for (node = super.next(); node != END; node = super.next()) {
                if (getExpandedTypeID(node) == _nodeType
                      || getNodeType(node) == _nodeType
                      || getIdForNamespace(getStringValueX(node))
                             == _nodeType) {
                    return returnNode(node);
                }
            }

            return (END);
        }
    }  


    
    private final class NodeValueIterator extends InternalAxisIteratorBase
    {

	private DTMAxisIterator _source;
	private String _value;
	private boolean _op;
	private final boolean _isReverse;
	private int _returnType = RETURN_PARENT;

	public NodeValueIterator(DTMAxisIterator source, int returnType,
				 String value, boolean op)
        {
	    _source = source;
	    _returnType = returnType;
	    _value = value;
	    _op = op;
	    _isReverse = source.isReverse();
	}

	public boolean isReverse()
        {
	    return _isReverse;
	}

        public DTMAxisIterator cloneIterator()
        {
            try {
                NodeValueIterator clone = (NodeValueIterator)super.clone();
                clone._isRestartable = false;
                clone._source = _source.cloneIterator();
                clone._value = _value;
                clone._op = _op;
                return clone.reset();
            }
            catch (CloneNotSupportedException e) {
                BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
                                          e.toString());
                return null;
            }
        }
  
        public void setRestartable(boolean isRestartable)
        {
	    _isRestartable = isRestartable;
	    _source.setRestartable(isRestartable);
	}

	public DTMAxisIterator reset()
        {
	    _source.reset();
	    return resetPosition();
	}

	public int next()
        {
            int node;
            while ((node = _source.next()) != END) {
                String val = getStringValueX(node);
                if (_value.equals(val) == _op) {
                    if (_returnType == RETURN_CURRENT) {
                        return returnNode(node);
                    }
                    else {
                        return returnNode(getParent(node));
                    }
                }
            }
            return END;
        }

	public DTMAxisIterator setStartNode(int node)
        {
            if (_isRestartable) {
                _source.setStartNode(_startNode = node);
                return resetPosition();
            }
            return this;
        }

	public void setMark()
        {
	    _source.setMark();
	}

	public void gotoMark()
        {
	    _source.gotoMark();
	}
    } 

    public DTMAxisIterator getNodeValueIterator(DTMAxisIterator iterator, int type,
					     String value, boolean op)
    {
        return(DTMAxisIterator)(new NodeValueIterator(iterator, type, value, op));
    }

    
    public DTMAxisIterator orderNodes(DTMAxisIterator source, int node)
    {
        return new DupFilterIterator(source);
    }

    
    public DTMAxisIterator getIterator()
    {
        return new SingletonIterator(getDocument());
    }

     
    public int getNSType(int node)
    {
    	String s = getNamespaceURI(node);
    	if (s == null) {
    	    return 0;
    	}
    	int eType = getIdForNamespace(s);
    	return ((Integer)_nsIndex.get(new Integer(eType))).intValue();        
    }
    
    

    
    public int getNamespaceType(final int node)
    {
    	return super.getNamespaceType(node);
    }

    
    private int[] setupMapping(String[] namesArray, int nNames) {
        
        
        final int[] types = new int[m_expandedNameTable.getSize()];
        for (int i = 0; i < nNames; i++)      {
            int type = getGeneralizedType(namesArray[i]);
            types[type] = type;
        }
        return types;
    }

    
    public int getGeneralizedType(final String name) {
        String lName, ns = null;
        int index = -1;
        int code;

        
        if ((index = name.lastIndexOf("":""))> -1) {
            ns = name.substring(0, index);
        }

        
        
        int lNameStartIdx = index+1;

        
        
        if (name.charAt(lNameStartIdx) == '@') {
            code = DTM.ATTRIBUTE_NODE;
            lNameStartIdx++;
        }
        else {
            code = DTM.ELEMENT_NODE;
        }

        
        lName = (lNameStartIdx == 0) ? name : name.substring(lNameStartIdx);

        return this.getExpandedTypeID(ns, lName, code);
    }

    
    public short[] getMapping(String[] names)
    {
        int i;
        final int namesLength = names.length;
        final int exLength = m_expandedNameTable.getSize();
        int[] generalizedTypes = null;
        if (namesLength > 0) {
            generalizedTypes = new int[namesLength];
        }
      
        int resultLength = exLength;
      
        for (i = 0; i < namesLength; i++) {
            generalizedTypes[i] = getGeneralizedType(names[i]);
            if (_namesSize == 0 && generalizedTypes[i] >= resultLength) {
                resultLength = generalizedTypes[i] + 1;
            }
        }
      
        final short[] result = new short[resultLength];

        
        for (i = 0; i < DTM.NTYPES; i++) {
            result[i] = (short)i;
        }
        
        for (i = NTYPES; i < exLength; i++) { 
      	    result[i] = m_expandedNameTable.getType(i);
      	}
      	
        
        for (i = 0; i < namesLength; i++) {
            int genType = generalizedTypes[i];         
            if (_namesSize > 0) {
                if (genType < result.length) {
                    result[genType] = (short)(i + DTM.NTYPES);
                }
            }
            else {
                result[genType] = (short)(i + DTM.NTYPES);
            }
        }

        return(result);
    }

    
    public int[] getReverseMapping(String[] names)
    {
        int i;
        final int[] result = new int[names.length + DTM.NTYPES];
        
        
        for (i = 0; i < DTM.NTYPES; i++) {
            result[i] = i;
        }
        
        
        for (i = 0; i < names.length; i++) {
            int type = getGeneralizedType(names[i]);
            result[i+DTM.NTYPES] = type;
        }
        return(result);
    }
    
    
    public short[] getNamespaceMapping(String[] namespaces)
    {
        int i;
        final int nsLength = namespaces.length;
        final int mappingLength = _uriCount;

        final short[] result = new short[mappingLength];

        
        for (i=0; i<mappingLength; i++) {
            result[i] = (short)(-1);
        }

        for (i=0; i<nsLength; i++) {
            int eType = getIdForNamespace(namespaces[i]); 
            Integer type = (Integer)_nsIndex.get(new Integer(eType));
            if (type != null) {
                result[type.intValue()] = (short)i;
            }
        }

        return(result);
    }

    
    public short[] getReverseNamespaceMapping(String[] namespaces)
    {
        int i;
        final int length = namespaces.length;
        final short[] result = new short[length];

        for (i = 0; i < length; i++) {
            int eType = getIdForNamespace(namespaces[i]);
            Integer type = (Integer)_nsIndex.get(new Integer(eType));
            result[i] = (type == null) ? -1 : type.shortValue();
        }

        return result;
    }

    
    public SAXImpl(XSLTCDTMManager mgr, Source source,
                   int dtmIdentity, DTMWSFilter whiteSpaceFilter,
                   XMLStringFactory xstringfactory,
                   boolean doIndexing, boolean buildIdIndex)
    {
        this(mgr, source, dtmIdentity, whiteSpaceFilter, xstringfactory,
            doIndexing, DEFAULT_BLOCKSIZE, buildIdIndex);
    }
    
    
    public SAXImpl(XSLTCDTMManager mgr, Source source,
                   int dtmIdentity, DTMWSFilter whiteSpaceFilter,
                   XMLStringFactory xstringfactory,
                   boolean doIndexing, int blocksize, 
                   boolean buildIdIndex)
    {
        super(mgr, source, dtmIdentity, whiteSpaceFilter, xstringfactory,
            doIndexing, blocksize, false, buildIdIndex);
      
        _dtmManager = mgr;      
        _size = blocksize;
      
        
        _xmlSpaceStack = new int[blocksize <= 64 ? 4 : 64];
                                  
         
        _xmlSpaceStack[0] = DTMDefaultBase.ROOTNODE;
      
        
        
        if (source instanceof DOMSource) {
            _hasDOMSource = true;
            DOMSource domsrc = (DOMSource)source;
            Node node = domsrc.getNode();
            if (node instanceof Document) {
                _document = (Document)node;
            }
            else {
                _document = node.getOwnerDocument();
            }
            _node2Ids = new Hashtable();
        }                          
    }
        
    
    public int getElementById(String idString)
    {
        Node node = _document.getElementById(idString);
        if (node != null) {
            Integer id = (Integer)_node2Ids.get(node);
            return (id != null) ? id.intValue() : DTM.NULL;
        }
        else {
            return DTM.NULL;
        }
    }
    
    
    public boolean hasDOMSource()
    {
        return _hasDOMSource;	
    }

    
    
    
    
    
    private void xmlSpaceDefine(String val, final int node)
    {
        final boolean setting = val.equals(PRESERVE_STRING);
        if (setting != _preserve) {
            _xmlSpaceStack[_idx++] = node;
            _preserve = setting;
        }
    }

    
    private void xmlSpaceRevert(final int node)
    {
        if (node == _xmlSpaceStack[_idx - 1]) {
            _idx--;
            _preserve = !_preserve;
        }
    }

    
    protected boolean getShouldStripWhitespace()
    {
        return _preserve ? false : super.getShouldStripWhitespace();
    }

    
    private void handleTextEscaping() {
        if (_disableEscaping && _textNodeToProcess != DTM.NULL
            && _type(_textNodeToProcess) == DTM.TEXT_NODE) {
            if (_dontEscape == null) {
                _dontEscape = new BitArray(_size);
            }
          
            
            if (_textNodeToProcess >= _dontEscape.size()) {
                _dontEscape.resize(_dontEscape.size() * 2);
            }
          
            _dontEscape.setBit(_textNodeToProcess);
            _disableEscaping = false;
        }
        _textNodeToProcess = DTM.NULL;
    }


    
    
    

    
    public void characters(char[] ch, int start, int length) throws SAXException
    {
        super.characters(ch, start, length);
        
        _disableEscaping = !_escaping;  
        _textNodeToProcess = getNumberOfNodes();
    }

    
    public void startDocument() throws SAXException
    {
        super.startDocument();

        _nsIndex.put(new Integer(0), new Integer(_uriCount++));
        
        super.startPrefixMapping(XML_PREFIX, XML_URI);
        Integer eType = new Integer(getIdForNamespace(XML_URI));
        _nsIndex.put(eType, new Integer(_uriCount++));
    }

    
    public void endDocument() throws SAXException
    {
        super.endDocument();
        
        handleTextEscaping();
        _namesSize = m_expandedNameTable.getSize();
    }

    
    public void startElement(String uri, String localName,
                             String qname, Attributes attributes,
                             Node node)
        throws SAXException
    {
    	this.startElement(uri, localName, qname, attributes);
    	
    	if (m_buildIdIndex) {
    	    _node2Ids.put(node, new Integer(m_parents.peek()));
    	}
    }
    
    
    public void startElement(String uri, String localName,
                 String qname, Attributes attributes)
        throws SAXException
    {
        super.startElement(uri, localName, qname, attributes);
        
        handleTextEscaping();

        if (m_wsfilter != null) {
            
            
            
            final int index = attributes.getIndex(XMLSPACE_STRING);
            if (index >= 0) {
                xmlSpaceDefine(attributes.getValue(index), m_parents.peek());
            }
        }
    }

    
    public void endElement(String namespaceURI, String localName, String qname)
        throws SAXException
    {
        super.endElement(namespaceURI, localName, qname);
        
        handleTextEscaping();

        
        if (m_wsfilter != null) {
            xmlSpaceRevert(m_previous);
        }
    }

    
    public void processingInstruction(String target, String data)
        throws SAXException
    {
        super.processingInstruction(target, data);
        handleTextEscaping();
    }

    
    public void ignorableWhitespace(char[] ch, int start, int length)
        throws SAXException
    {
        super.ignorableWhitespace(ch, start, length);
        _textNodeToProcess = getNumberOfNodes();
    }

    
    public void startPrefixMapping(String prefix, String uri)
        throws SAXException
    {
        super.startPrefixMapping(prefix, uri);
        handleTextEscaping();

        definePrefixAndUri(prefix, uri);
    }

    private void definePrefixAndUri(String prefix, String uri) 
        throws SAXException 
    {
        
        Integer eType = new Integer(getIdForNamespace(uri));
        if ((Integer)_nsIndex.get(eType) == null) {
            _nsIndex.put(eType, new Integer(_uriCount++));
        }
    }
 
    
    public void comment(char[] ch, int start, int length)
        throws SAXException
    {
        super.comment(ch, start, length);
        handleTextEscaping();
    }

    public boolean setEscaping(boolean value) {
        final boolean temp = _escaping;
        _escaping = value; 
        return temp;
    }
   
   
   
   

    
    public void print(int node, int level)
    {
        switch(getNodeType(node))
        {
	    case DTM.ROOT_NODE:
	    case DTM.DOCUMENT_NODE:
	        print(getFirstChild(node), level);
	        break;
	    case DTM.TEXT_NODE:
	    case DTM.COMMENT_NODE:
	    case DTM.PROCESSING_INSTRUCTION_NODE:
	        System.out.print(getStringValueX(node));
	        break;
	    default:
	        final String name = getNodeName(node);
	        System.out.print(""<"" + name);
	        for (int a = getFirstAttribute(node); a != DTM.NULL; a = getNextAttribute(a))
                {
		    System.out.print(""
"" + getNodeName(a) + ""="""" + getStringValueX(a) + """""");
	        }
	        System.out.print('>');
	        for (int child = getFirstChild(node); child != DTM.NULL;
		    child = getNextSibling(child)) {
		    print(child, level + 1);
	        }
	        System.out.println(""</"" + name + '>');
	        break;
	}
    }

    
    public String getNodeName(final int node)
    {
	
	int nodeh = node;
	final short type = getNodeType(nodeh);
	switch(type)
        {
	    case DTM.ROOT_NODE:
	    case DTM.DOCUMENT_NODE:
	    case DTM.TEXT_NODE:
	    case DTM.COMMENT_NODE:
	        return EMPTYSTRING;
	    case DTM.NAMESPACE_NODE:
		return this.getLocalName(nodeh);
	    default:
	        return super.getNodeName(nodeh);
	}
    }    

    
    public String getNamespaceName(final int node)
    {
    	if (node == DTM.NULL) {
    	    return """";
    	}
    	
        String s;
        return (s = getNamespaceURI(node)) == null ? EMPTYSTRING : s;
    }

 
    
    public int getAttributeNode(final int type, final int element)
    {
        for (int attr = getFirstAttribute(element);
           attr != DTM.NULL;
           attr = getNextAttribute(attr))
        {
            if (getExpandedTypeID(attr) == type) return attr;
        }
        return DTM.NULL;
    }

    
    public String getAttributeValue(final int type, final int element)
    {
        final int attr = getAttributeNode(type, element);
        return (attr != DTM.NULL) ? getStringValueX(attr) : EMPTYSTRING;
    }

    
    public String getAttributeValue(final String name, final int element)
    {
        return getAttributeValue(getGeneralizedType(name), element);
    }

    
    public DTMAxisIterator getChildren(final int node)
    {
        return (new ChildrenIterator()).setStartNode(node);
    }

    
    public DTMAxisIterator getTypedChildren(final int type)
    {
        return(new TypedChildrenIterator(type));
    }

    
    public DTMAxisIterator getAxisIterator(final int axis)
    {
        switch (axis)
        {
            case Axis.SELF:
                return new SingletonIterator();
            case Axis.CHILD:
                return new ChildrenIterator();
            case Axis.PARENT:
                return new ParentIterator();
            case Axis.ANCESTOR:
                return new AncestorIterator();
            case Axis.ANCESTORORSELF:
                return (new AncestorIterator()).includeSelf();
            case Axis.ATTRIBUTE:
                return new AttributeIterator();
            case Axis.DESCENDANT:
                return new DescendantIterator();
            case Axis.DESCENDANTORSELF:
                return (new DescendantIterator()).includeSelf();
            case Axis.FOLLOWING:
                return new FollowingIterator();
            case Axis.PRECEDING:
                return new PrecedingIterator();
            case Axis.FOLLOWINGSIBLING:
                return new FollowingSiblingIterator();
            case Axis.PRECEDINGSIBLING:
                return new PrecedingSiblingIterator();
            case Axis.NAMESPACE:
                return new NamespaceIterator();
            default:
                BasisLibrary.runTimeError(BasisLibrary.AXIS_SUPPORT_ERR, Axis.names[axis]);
        }
        return null;
    }

    
    public DTMAxisIterator getTypedAxisIterator(int axis, int type)
    {
        
        if (axis == Axis.CHILD) {
            return new TypedChildrenIterator(type);
        }

        if (type == NO_TYPE) {
            return(EMPTYITERATOR);
        }

        switch (axis)
        {
            case Axis.SELF:
                return new TypedSingletonIterator(type);
            case Axis.CHILD:
                return new TypedChildrenIterator(type);
            case Axis.PARENT:
                return new ParentIterator().setNodeType(type);
            case Axis.ANCESTOR:
                return new TypedAncestorIterator(type);
            case Axis.ANCESTORORSELF:
                return (new TypedAncestorIterator(type)).includeSelf();
            case Axis.ATTRIBUTE:
                return new TypedAttributeIterator(type);
            case Axis.DESCENDANT:
                return new TypedDescendantIterator(type);
            case Axis.DESCENDANTORSELF:
                return (new TypedDescendantIterator(type)).includeSelf();
            case Axis.FOLLOWING:
                return new TypedFollowingIterator(type);
            case Axis.PRECEDING:
                return new TypedPrecedingIterator(type);
            case Axis.FOLLOWINGSIBLING:
                return new TypedFollowingSiblingIterator(type);
            case Axis.PRECEDINGSIBLING:
                return new TypedPrecedingSiblingIterator(type);
            case Axis.NAMESPACE:
                return (type == DTM.ELEMENT_NODE)
                       ? new NamespaceIterator()
                       : new TypedNamespaceIterator(type);
            default:
                BasisLibrary.runTimeError(BasisLibrary.TYPED_AXIS_SUPPORT_ERR, Axis.names[axis]);
        }
        return null;
    }

    
    public DTMAxisIterator getNamespaceAxisIterator(int axis, int ns)
    {

        DTMAxisIterator iterator = null;

        if (ns == NO_TYPE) {
            return EMPTYITERATOR;
        }
        else {
            switch (axis) {
                case Axis.CHILD:
                    return new NamespaceChildrenIterator(ns);
                case Axis.ATTRIBUTE:
                    return new NamespaceAttributeIterator(ns);
                default:
                    BasisLibrary.runTimeError(BasisLibrary.TYPED_AXIS_SUPPORT_ERR,
                        Axis.names[axis]);
            }
        }
        return null;
    }

    
    public DTMAxisIterator getTypedDescendantIterator(int type)
    {
        return new TypedDescendantIterator(type);
    }

    
    public DTMAxisIterator getNthDescendant(int type, int n, boolean includeself)
    {
        DTMAxisIterator source = (DTMAxisIterator) new TypedDescendantIterator(type);
        return new NthDescendantIterator(n);
    }

    
    public void characters(final int node, SerializationHandler handler)
        throws TransletException
    {
        if (node != DTM.NULL) {
            try {
                dispatchCharactersEvents(node, handler, false);
            } catch (SAXException e) {
                throw new TransletException(e);
            }
        }
    }
    
    
    public void copy(DTMAxisIterator nodes, SerializationHandler handler)
        throws TransletException
    {
        int node;
        while ((node = nodes.next()) != DTM.NULL) {
            copy(node, handler);
        }
    }

    
    public void copy(SerializationHandler handler) throws TransletException
    {
        copy(getDocument(), handler);
    }

    
    public void copy(final int node, SerializationHandler handler)
        throws TransletException
    {
        int nodeID = makeNodeIdentity(node);
        int eType = _exptype2(nodeID);
        int type = _exptype2Type(eType);

        try {
            switch(type)
            {
                case DTM.ROOT_NODE:
                case DTM.DOCUMENT_NODE:
                    for(int c = _firstch2(nodeID); c != DTM.NULL; c = _nextsib2(c)) {
                        copy(makeNodeHandle(c), handler);
                    }
                    break;
                case DTM.PROCESSING_INSTRUCTION_NODE:
                    copyPI(node, handler);
                    break;
                case DTM.COMMENT_NODE:
                    handler.comment(getStringValueX(node));
                    break;
                case DTM.TEXT_NODE:
                    boolean oldEscapeSetting = false;
                    boolean escapeBit = false;

                    if (_dontEscape != null) {
                        escapeBit = _dontEscape.getBit(getNodeIdent(node));
                        if (escapeBit) {
                            oldEscapeSetting = handler.setEscaping(false);
                        }
                    }
                    
                    copyTextNode(nodeID, handler);
        
                    if (escapeBit) {
                        handler.setEscaping(oldEscapeSetting);
                    }
                    break;
                case DTM.ATTRIBUTE_NODE:
                    copyAttribute(nodeID, eType, handler);
                    break;
                case DTM.NAMESPACE_NODE:
                    handler.namespaceAfterStartElement(getNodeNameX(node), getNodeValue(node));
                    break;
                default:
                    if (type == DTM.ELEMENT_NODE) 
                    {
                        
                        final String name = copyElement(nodeID, eType, handler);
          
                        
                        
                        int current = nodeID;
                        while (true)
                        {
                            current++;
                            eType = _exptype2(current);
                            type = _exptype2Type(eType);
            
                            if (type == DTM.ATTRIBUTE_NODE) {
                                copyAttribute(current, eType, handler);
                            }
                            else if (type == DTM.NAMESPACE_NODE) {
                                handler.namespaceAfterStartElement(getNodeNameX(makeNodeHandle(current)), getNodeValue(makeNodeHandle(current)));            
                            }
                            else
                                break;
                        }

                        
                        for (int c = _firstch2(nodeID); c != DTM.NULL; c = _nextsib2(c)) {
                            copy(makeNodeHandle(c), handler);
                        }
          
                        
                        handler.endElement(name);
                    }
                    
                    else {
                        final String uri = getNamespaceName(node);
                        if (uri.length() != 0) {
                            final String prefix = getPrefix(node);
                            handler.namespaceAfterStartElement(prefix, uri);
                        }
                        handler.addAttribute(getNodeName(node), getNodeValue(node));
                    }
                    break;
            }
        } 
        catch (Exception e) {
            throw new TransletException(e);
        }
    }

    
    private void copyPI(final int node, SerializationHandler handler)
	throws TransletException
    {
        final String target = getNodeName(node);
        final String value = getStringValueX(node);
      
        try {
            handler.processingInstruction(target, value);
        } catch (Exception e) {
            throw new TransletException(e);
        }
    }

    
    public String shallowCopy(final int node, SerializationHandler handler)
        throws TransletException
    {
        int nodeID = makeNodeIdentity(node);
        int exptype = _exptype2(nodeID);
        int type = _exptype2Type(exptype);
      
        try {
            switch(type)
            {
                case DTM.ELEMENT_NODE:
                    return(copyElement(nodeID, exptype, handler));
                case DTM.ROOT_NODE:
                case DTM.DOCUMENT_NODE:
                    return EMPTYSTRING;
                case DTM.TEXT_NODE:
                    copyTextNode(nodeID, handler);
                    return null;
                case DTM.PROCESSING_INSTRUCTION_NODE:
                    copyPI(node, handler);
                    return null;
                case DTM.COMMENT_NODE:
                    handler.comment(getStringValueX(node));
                    return null;
                case DTM.NAMESPACE_NODE:
                    handler.namespaceAfterStartElement(getNodeNameX(node), getNodeValue(node));
                    return null;
                case DTM.ATTRIBUTE_NODE:
                    copyAttribute(nodeID, exptype, handler);
                    return null;  
                default:
                    final String uri1 = getNamespaceName(node);
                    if (uri1.length() != 0) {
                        final String prefix = getPrefix(node);
                        handler.namespaceAfterStartElement(prefix, uri1);
                    }
                    handler.addAttribute(getNodeName(node), getNodeValue(node));
                    return null;
            }
        } catch (Exception e) {
            throw new TransletException(e);
        }   
    }
    
    
    public String getLanguage(int node)
    {
        int parent = node;
    	while (DTM.NULL != parent) {
            if (DTM.ELEMENT_NODE == getNodeType(parent)) {
                int langAttr = getAttributeNode(parent, ""http:

                if (DTM.NULL != langAttr) {
                    return getNodeValue(langAttr);     
                }
            }

            parent = getParent(parent);
        }      
        return(null);
    }

    
    public DOMBuilder getBuilder()
    {
	return this;
    }
    
    
    public SerializationHandler getOutputDomBuilder()
    {
        return new ToXMLSAXHandler(this, ""UTF-8"");
    }
    
     
    public DOM getResultTreeFrag(int initSize, int rtfType)
    {
    	if (rtfType == DOM.SIMPLE_RTF) {
            int dtmPos = _dtmManager.getFirstFreeDTMID();
    	    SimpleResultTreeImpl rtf = new SimpleResultTreeImpl(_dtmManager,
    	                               dtmPos << DTMManager.IDENT_DTM_NODE_BITS);
    	    _dtmManager.addDTM(rtf, dtmPos, 0);
    	    return rtf;
    	}
    	else if (rtfType == DOM.ADAPTIVE_RTF) {
            int dtmPos = _dtmManager.getFirstFreeDTMID();
    	    AdaptiveResultTreeImpl rtf = new AdaptiveResultTreeImpl(_dtmManager,
    	                               dtmPos << DTMManager.IDENT_DTM_NODE_BITS,
    	                               m_wsfilter, initSize, m_buildIdIndex);
    	    _dtmManager.addDTM(rtf, dtmPos, 0);
    	    return rtf;
    	
    	}
    	else {
    	    return (SAXImpl) _dtmManager.getDTM(null, true, m_wsfilter,
                                                true, false, false,
                                                initSize, m_buildIdIndex);
        }
    }

    
    public Hashtable getElementsWithIDs() {
        if (m_idAttributes == null) {
            return null;
        }

        
        Enumeration idValues = m_idAttributes.keys();
        if (!idValues.hasMoreElements()) {
            return null;
        }

        Hashtable idAttrsTable = new Hashtable();

        while (idValues.hasMoreElements()) {
            Object idValue = idValues.nextElement();

            idAttrsTable.put(idValue, m_idAttributes.get(idValue));
        }

        return idAttrsTable;
    }

    
    public String getUnparsedEntityURI(String name)
    {
        
        if (_document != null) {
            String uri = """";
            DocumentType doctype = _document.getDoctype();
            if (doctype != null) {
                NamedNodeMap entities = doctype.getEntities();
                
                if (entities == null) {
                    return uri;
                }
                
                Entity entity = (Entity) entities.getNamedItem(name);
                
                if (entity == null) {
                    return uri;
                }
                
                String notationName = entity.getNotationName();
                if (notationName != null) {
                    uri = entity.getSystemId();
                    if (uri == null) {
                        uri = entity.getPublicId();
                    }
                }
            }
            return uri;
        }
        else {
            return super.getUnparsedEntityURI(name);
        }	
    }

}
"
org.apache.xml.utils.res.XResources_de,3,4,0,1,4,1,0,1,2,0.5,314,0.0,0,0.976190476,1.0,0,0,103.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_de extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""de"" }, { ""help_language"", ""de"" }, { ""language"", ""de"" },
    { ""alphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    
    
    
    
    
    
    
    
    
  };
}
"
org.apache.xalan.res.XSLTErrorResources_ko,3,4,0,1,4,1,0,1,2,1.423076923,3769,0.0,0,0.976190476,1.0,0,0,1251.0,1,0.3333,0,"
package org.apache.xalan.res;



public class XSLTErrorResources_ko extends XSLTErrorResources
{

  
  public static final int MAX_CODE = 201;

  
  public static final int MAX_WARNING = 29;

  
  public static final int MAX_OTHERS = 55;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  

  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_NO_CURLYBRACE,
      ""오류: 표현식 안에 '{'를 사용할 수 없습니다.""},


  
  


  {
    ER_ILLEGAL_ATTRIBUTE, ""{0}에 잘못된 속성 {1}이(가) 있습니다.""},


  
  


  {
    ER_NULL_SOURCENODE_APPLYIMPORTS,
      ""sourceNode는 xsl:apply-imports에서 널입니다!""},


  
  


  {
    ER_CANNOT_ADD, ""{0}을(를) {1}에 추가할 수 없습니다. ""},


  
  


  {
    ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES,
      ""sourceNode는 handleApplyTemplatesInstruction에서 널입니다!""},


  
  


  {
    ER_NO_NAME_ATTRIB, ""{0}에 이름 속성이 있어야 합니다.""},


  
  


  {
    ER_TEMPLATE_NOT_FOUND, ""템플리트 {0}을(를) 찾을 수 없습니다.""},


  
  


  {
    ER_CANT_RESOLVE_NAME_AVT,
      ""xsl:call-template에서 이름 AVT를 결정할 수 없습니다.""},


  
  


  {
    ER_REQUIRES_ATTRIB, ""{0}에 속성 {1}이(가) 필요합니다.""},


  
  


  {
    ER_MUST_HAVE_TEST_ATTRIB,
      ""{0}에 ''test'' 속성이 있어야 합니다.""},


  
  


  {
    ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""레벨 속성 {0}에 잘못된 값이 있습니다.""},


  
  


  {
    ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""processing-instruction 이름이 'xml'이어서는 안됩니다.""},


  
  


  {
    ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""processing-instruction 이름은 올바른 NCName {0}이어야 합니다.""},


  
  


  {
    ER_NEED_MATCH_ATTRIB,
      ""{0}이(가) 모드를 가지고 있는 경우 일치 속성이 있어야 합니다.""},


  
  


  {
    ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0}에 이름 또는 일치 속성 중 하나가 필요합니다.""},


  
  


  {
    ER_CANT_RESOLVE_NSPREFIX,
      ""이름 공간 접두어 {0}을(를) 결정할 수 없습니다.""},


  
  


  {
    ER_ILLEGAL_VALUE, ""xml:space에 잘못된 값 {0}이(가) 있습니다.""},


  
  


  {
    ER_NO_OWNERDOC,
      ""자식 노드에 소유자 문서가 없습니다!""},


  
  


  {
    ER_ELEMTEMPLATEELEM_ERR, ""ElemTemplateElement 오류: {0}""},


  
  


  {
    ER_NULL_CHILD, ""널 자식을 추가하려고 시도하는 중입니다!""},


  
  


  {
    ER_NEED_SELECT_ATTRIB, ""{0}에 선택 속성이 필요합니다.""},


  
  


  {
    ER_NEED_TEST_ATTRIB,
      ""xsl:when에 'test' 속성이 있어야 합니다.""},


  
  


  {
    ER_NEED_NAME_ATTRIB,
      ""xsl:with-param에 'name' 속성이 있어야 합니다.""},


  
  


  {
    ER_NO_CONTEXT_OWNERDOC,
      ""컨텍스트에 소유자 문서가 없습니다.""},


  
  


  {
    ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""XML TransformerFactory Liaison {0}을(를) 작성할 수 없습니다.""},


  
  


  {
    ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: 프로세스에 성공하지 못했습니다.""},


  
  


  {
    ER_NOT_SUCCESSFUL, ""Xalan:에 성공하지 못했습니다.""},


  
  


  {
    ER_ENCODING_NOT_SUPPORTED, ""코드화가 지원되지 않습니다: {0}""},


  
  


  {
    ER_COULD_NOT_CREATE_TRACELISTENER,
      ""TraceListener {0}을(를) 작성할 수 없습니다.""},


  
  


  {
    ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key에 'name' 속성이 필요합니다!""},


  
  


  {
    ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key에 'match' 속성이 필요합니다!""},


  
  


  {
    ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key에 'use' 속성이 필요합니다!""},


  
  


  {
    ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0}에 ''elements'' 속성이 필요합니다!""},


  
  


  {
    ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} 속성 ''prefix''가 빠졌습니다.""},


  
  


  {
    ER_BAD_STYLESHEET_URL, ""Stylesheet URL이 잘못되었습니다: {0}""},


  
  


  {
    ER_FILE_NOT_FOUND, ""Stylesheet 파일을 찾을 수 없습니다: {0}""},


  
  


  {
    ER_IOEXCEPTION,
      ""스타일 시트 파일로 IO 예외가 발생하였습니다: {0}""},


  
  


  {
    ER_NO_HREF_ATTRIB,
      ""(StylesheetHandler) {0}에 대한 href 속성을 찾을 수 없습니다.""},


  
  


  {
    ER_STYLESHEET_INCLUDES_ITSELF,
      ""(StylesheetHandler) {0}이(가) 직접 또는 간접적으로 자신을 포함하고 있습니다.""},


  
  


  {
    ER_PROCESSINCLUDE_ERROR,
      ""StylesheetHandler.processInclude 오류, {0}""},


  
  


  {
    ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} 속성 ''lang''이 빠졌습니다.""},


  
  


  {
    ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) {0} 요소의 위치가 잘못되었습니다?? container 요소 ''component''가 빠졌습니다.""},


  
  


  {
    ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
      ""Element, DocumentFragment, Document 또는 PrintWriter로만 출력할 수 있습니다.""},


  
  


  {
    ER_PROCESS_ERROR, ""StylesheetRoot.process 오류""},


  
  


  {
    ER_UNIMPLNODE_ERROR, ""UnImplNode 오류: {0}""},


  
  


  {
    ER_NO_SELECT_EXPRESSION,
      ""오류! xpath 선택 표현식(-select)을 찾을 수 없습니다""},


  
  


  {
    ER_CANNOT_SERIALIZE_XSLPROCESSOR,
      ""XSLProcessor를 일련화할 수 없습니다!""},


  
  


  {
    ER_NO_INPUT_STYLESHEET,
      ""Stylesheet 입력을 지정하지 않았습니다!""},


  
  


  {
    ER_FAILED_PROCESS_STYLESHEET,
      ""stylesheet 처리에 실패했습니다!""},


  
  


  {
    ER_COULDNT_PARSE_DOC, ""{0} 문서를 구문 분석할 수 없습니다!""},


  
  


  {
    ER_COULDNT_FIND_FRAGMENT, ""단편 {0}을(를) 찾을 수 없습니다.""},


  
  


  {
    ER_NODE_NOT_ELEMENT,
      ""단편 식별자에 의해 지정된 노드는 요소가 아닙니다: {0}""},


  
  


  {
    ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""for-each에 일치 또는 이름 속성 중 하나가 있어야 합니다.""},


  
  


  {
    ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB,
      ""템플리트에 일치 또는 이름 속성 중 하나가 있어야 합니다.""},


  
  


  {
    ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""문서 단편 복제가 없습니다!""},


  
  


  {
    ER_CANT_CREATE_ITEM,
      ""결과 트리 {0}에 항목을 작성할 수 없습니다.""},


  
  


  {
    ER_XMLSPACE_ILLEGAL_VALUE,
      ""소스 XML의 xml:space에 잘못된 값 {0}이(가) 있습니다.""},


  
  


  {
    ER_NO_XSLKEY_DECLARATION,
      ""{0}에 대하여 xsl:key 선언이 없습니다!""},


  
  


  {
    ER_CANT_CREATE_URL, ""오류! {0}에 대하여 url을 작성할 수 없습니다.""},


  
  


  {
    ER_XSLFUNCTIONS_UNSUPPORTED, ""xsl:functions가 지원되지 않습니다.""},


  
  


  {
    ER_PROCESSOR_ERROR, ""XSLT TransformerFactory 오류""},


  
  


  {
    ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""(StylesheetHandler) {0}은(는) 스타일 시트 내부에 허용되지 않습니다!""},


  
  


  {
    ER_RESULTNS_NOT_SUPPORTED,
      ""result-ns는 더 이상 지원되지 않습니다! 대신 xsl:output을 사용하십시오.""},


  
  


  {
    ER_DEFAULTSPACE_NOT_SUPPORTED,
      ""default-space는 더 이상 지원되지 않습니다! 대신 xsl:preserve-space를 사용하십시오.""},


  
  


  {
    ER_INDENTRESULT_NOT_SUPPORTED,
      ""indent-result는 더 이상 지원되지 않습니다! 대신 xsl:output을 사용하십시오.""},


  
  


  {
    ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0}에 잘못된 속성 {1}이(가) 있습니다.""},


  
  


  {
    ER_UNKNOWN_XSL_ELEM, ""알 수 없는 XSL 요소 {0}""},


  
  


  {
    ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort는 xsl:apply-templates 또는 xsl:for-each와만 사용할 수 있습니다.""},


  
  


  {
    ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) xsl:when의 위치가 잘못되었습니다!""},


  
  


  {
    ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:when의 부모는 xsl:choose가 아닙니다!""},


  
  


  {
    ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) xsl:otherwise의 위치가 잘못되었습니다!""},


  
  


  {
    ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:otherwise의 부모는 xsl:choose가 아닙니다!""},


  
  


  {
    ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""(StylesheetHandler) {0}은(는) 템플리트 내부에 허용되지 않습니다!""},


  
  


  {
    ER_UNKNOWN_EXT_NS_PREFIX,
      ""(StylesheetHandler) {0} 확장 이름 공간 접두어 {1}을(를) 알 수 없습니다.""},


  
  


  {
    ER_IMPORTS_AS_FIRST_ELEM,
      ""(StylesheetHandler) 가져오기는 스타일 시트의 첫 번째 요소로만 발생할 수 있습니다!""},


  
  


  {
    ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0}이(가) 직접 또는 간접적으로 자신을 가져오고 있습니다!""},


  
  


  {
    ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space에 잘못된 값 {0}이(가) 있습니다.""},


  
  


  {
    ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""processStylesheet가 성공하지 못했습니다!""},


  
  


  {
    ER_SAX_EXCEPTION, ""SAX 예외""},


  
  


  {
    ER_XSLT_ERROR, ""XSLT 오류""},


  
  


  {
    ER_CURRENCY_SIGN_ILLEGAL,
      ""형식 패턴 문자열에 통화 부호가 허용되지 않습니다.""},


  
  


  {
    ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""Stylesheet DOM에서 문서 기능이 지원되지 않습니다!""},


  
  


  {
    ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""접두어가 없는 결정자의 접두어를 결정할 수 없습니다!""},


  
  


  {
    ER_REDIRECT_COULDNT_GET_FILENAME,
      ""Redirect 확장: 파일 이름을 가져올 수 없습니다 - 파일 또는 선택 속성이 올바른 문자열을 반환해야 합니다.""},


  
  


  {
    ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""Redirect 확장에 FormatterListener를 구축할 수 없습니다!""},


  
  


  {
    ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""exclude-result-prefixes의 접두어가 올바르지 않습니다: {0}""},


  
  


  {
    ER_MISSING_NS_URI,
      ""지정된 접두어에 대한 이름 공간 URI가 빠졌습니다.""},


  
  


  {
    ER_MISSING_ARG_FOR_OPTION,
      ""옵션 {0}에 대한 인자가 빠졌습니다.""},


  
  


  {
    ER_INVALID_OPTION, ""잘못된 옵션: {0}""},


  
  


  {
    ER_MALFORMED_FORMAT_STRING, ""잘못된 형식 문자열: {0}""},


  
  


  {
    ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet에 'version' 속성이 필요합니다!""},


  
  


  {
    ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""속성: {0}에 잘못된 값 {1}이(가) 있습니다.""},


  
  


  {
    ER_CHOOSE_REQUIRES_WHEN, ""xsl:choose에 xsl:when이 필요합니다.   ""},


  
  


  {
    ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""xsl:apply-imports는 xsl:for-each에 허용되지 않습니다.""},


  
  


  {
    ER_CANT_USE_DTM_FOR_OUTPUT,
      ""출력 DOM 노드로 DTMLiaison을 사용할 수 없습니다... 대신 org.apache.xpath.DOM2Helper를 전달하십시오!""},


  
  


  {
    ER_CANT_USE_DTM_FOR_INPUT,
      ""입력 DOM 노드로 DTMLiaison을 사용할 수 없습니다... 대신 org.apache.xpath.DOM2Helper를 전달하십시오!""},


  
  


  {
    ER_CALL_TO_EXT_FAILED,
      ""확장 요소에 대한 호출이 실패했습니다: {0}""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""접두어가 이름 공간 {0}으로(로) 결정되어야 합니다.""},


  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""잘못된 UTF-16 대리가 감지되었습니다: {0} ?""},


  
  


  {
    ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0}이(가) 자신을 사용하였며, 이로 인해 무한 루프가 발생합니다.""},


  
  


  {
    ER_CANNOT_MIX_XERCESDOM,
      ""Xerces-DOM이 아닌 입력과 Xerces-DOM 출력을 함께 사용할 수 없습니다!""},


  
  


  {
    ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},


  
  


  {
    ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""ElemTemplateElement.readObject에: {0}""},


  
  


  {
    ER_DUPLICATE_NAMED_TEMPLATE,
      ""같은 이름 {0}을(를) 가진 둘 이상의 템플리트를 찾았습니다.""},


  
  


  {
    ER_INVALID_KEY_CALL,
      ""잘못된 함수 호출: 순환적 key() 호출은 허용되지 않습니다.""},

  
  
  


  {
    ER_REFERENCING_ITSELF,
      ""{0} 변수가 직접 또는 간접적으로 자신을 참조하고 있습니다!""},

  
  
  


  {
    ER_ILLEGAL_DOMSOURCE_INPUT,
      ""newTemplates의 DOMSource에서 입력 노드가 널이 될 수 없습니다!""},

	
	
  


  {
    ER_CLASS_NOT_FOUND_FOR_OPTION,
			""옵션 {0}의 클래스 파일을 찾을 수 없습니다.    ""},

	
	
  


  {
    ER_REQUIRED_ELEM_NOT_FOUND,
			""필수 요소를 찾을 수 없습니다: {0}""},

  
  
  


  {
    ER_INPUT_CANNOT_BE_NULL,
			""InputStream은 널이 될 수 없습니다""},

  
  
  


  {
    ER_URI_CANNOT_BE_NULL,
			""URI는 널이 될 수 없습니다""},

  
  
  


  {
    ER_FILE_CANNOT_BE_NULL,
			""파일은 널이 될 수 없습니다""},

  
   
  


  {
    ER_SOURCE_CANNOT_BE_NULL,
			""InputSource는 널이 될 수 없습니다""},

  
  
  


  {
    ER_CANNOT_INIT_BSFMGR,
			""BSF 관리자를 초기화할 수 없습니다""},

  
  
  


  {
    ER_CANNOT_CMPL_EXTENSN,
			""확장자를 컴파일할 수 없습니다""},

  
  
  


  {
    ER_CANNOT_CREATE_EXTENSN,
      ""{1}로 인해 확장자 {0}을(를) 작성할 수 없습니다.""},

  
  
  


  {
    ER_INSTANCE_MTHD_CALL_REQUIRES,
      ""메소드 {0}에 대한 인스턴스 메소드 호출에서 객체 인스턴스가 첫 번째 인자가 되어야 합니다.""},

  
  
  


  {
    ER_INVALID_ELEMENT_NAME,
      ""잘못된 이름 요소 {0}이(가) 지정되었습니다.   ""},

  
   
  


  {
    ER_ELEMENT_NAME_METHOD_STATIC,
      ""이름 요소 메소드는 정적 {0}이어야 합니다.""},

  
   
  


  {
    ER_EXTENSION_FUNC_UNKNOWN,
             ""확장 기능 {0} : {1}을(를) 알 수 없습니다.""},

  
   
  


  {
    ER_MORE_MATCH_CONSTRUCTOR,
             ""{0}의 구성자와 일치하는 것이 두 개 이상입니다.   ""},

  
   
  


  {
    ER_MORE_MATCH_METHOD,
             ""{0} 메소드와 일치하는 것이 두 개 이상입니다""},

  
   
  


  {
    ER_MORE_MATCH_ELEMENT,
             ""{0} 요소 메소드와 일치하는 것이 두 개 이상입니다""},

  
   
  


  {
    ER_INVALID_CONTEXT_PASSED,
             ""{0} 평가를 위해 전달된 컨텍스트가 잘못되었습니다.""},

  
   
  


  {
    ER_POOL_EXISTS,
             ""풀이 이미 있습니다""},

  
   
  


  {
    ER_NO_DRIVER_NAME,
             ""지정된 드라이버 이름이 없습니다""},

  
   
  


  {
    ER_NO_URL,
             ""지정된 URL이 없습니다""},

  
   
  


  {
    ER_POOL_SIZE_LESSTHAN_ONE,
             ""풀 크기가 1보다 작습니다!""},

  
   
  


  {
    ER_INVALID_DRIVER,
             ""지정된 드라이버 이름이 잘못되었습니다!""},

  
   
  


  {
    ER_NO_STYLESHEETROOT,
             ""스타일 시트 루트를 찾을 수 없습니다!""},

  
   
  


  {
    ER_ILLEGAL_XMLSPACE_VALUE,
         ""xml:space에 대한 값이 잘못되었습니다""},

  
   
  


  {
    ER_PROCESSFROMNODE_FAILED,
         ""processFromNode가 실패했습니다""},

  
   
  


  {
    ER_RESOURCE_COULD_NOT_LOAD,
        ""[ {0} ] 자원이 다음을 로드할 수 없습니다: {1} 
 {2} 	 {3}""},

   
  
   
  


  {
    ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""버퍼 크기 <=0""},

  
   
  


  {
    ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""확장자 호출 중 알 수 없는 오류가 발생했습니다""},

  
   
  


  {
    ER_NO_NAMESPACE_DECL,
        ""{0} 접두어에 관련 이름 공간 선언이 없습니다.""},

  
   
  


  {
    ER_ELEM_CONTENT_NOT_ALLOWED,
        ""lang=javaclass {0}에 요소 컨텐트가 허용되지 않습니다.""},
     
  
   
  


  {
    ER_STYLESHEET_DIRECTED_TERMINATION,
        ""스타일 시트가 종료로 지정되었습니다""},

  
   
  


  {
    ER_ONE_OR_TWO,
        ""1 또는 2""},

  
   
  


  {
    ER_TWO_OR_THREE,
        ""2 or 3""},

  
   
  


  {
    ER_COULD_NOT_LOAD_RESOURCE,
        ""기본값만을 사용하여 {0}을(를) 로드할 수 없습니다(CLASSPATH를 확인하십시오).""},

  
   
  


  {
    ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""기본 템플리트를 초기화할 수 없습니다""},

  
   
  


  {
    ER_RESULT_NULL,
        ""결과는 널이 될 수 없습니다""},

    
   
  


  {
    ER_RESULT_COULD_NOT_BE_SET,
        ""결과를 설정할 수 없습니다""},

  
   
  


  {
    ER_NO_OUTPUT_SPECIFIED,
        ""지정된 출력이 없습니다""},

  
   
  


  {
    ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""유형이 {0}인 결과로 변환할 수 없습니다.""},

  
   
  


  {
    ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""유형이 {0}인 소스로 변환할 수 없습니다. ""},

  
   
  


  {
    ER_NULL_CONTENT_HANDLER,
        ""컨텐트 처리기가 널입니다""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""오류 처리기가 널입니다""},

  
   
  


  {
    ER_CANNOT_CALL_PARSE,
        ""ContentHandler를 설정하지 않으면 구문 분석이 호출되지 않습니다.""},

  
   
  


  {
    ER_NO_PARENT_FOR_FILTER,
        ""필터에 대한 부모가 없습니다""},

  
  
   
  


  {
    ER_NO_STYLESHEET_IN_MEDIA,
         ""{0}에 스타일 시트가 없습니다. 매체= {1}""},

  
   
  


  {
    ER_NO_STYLESHEET_PI,
         ""{0}에 xml-stylesheet PI가 없습니다. ""},

  
   
  


  {
    ER_NOT_SUPPORTED,
       ""지원되지 않습니다: {0}""},

  
   
  


  {
    ER_PROPERTY_VALUE_BOOLEAN,
       ""{0} 특성에 대한 값이 부울 인스턴스여야 합니다.""},

  
    

   
  


  {
    ""ER_SRC_ATTRIB_NOT_SUPPORTED"",
       ""{0}에서 외부 스크립트를 얻을 수 없습니다""},

  
  
  


  {
    ER_RESOURCE_COULD_NOT_FIND,
        ""[ {0} ] 자원을 찾을 수 없습니다.
 {1}""},

  
   
  


  {
    ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""출력 특성을 인식할 수 없습니다: {0}""},

  
   
  


  {
    ER_FAILED_CREATING_ELEMLITRSLT,
        ""ElemLiteralResult 인스턴스 작성에 실패했습니다""},
    
  
  
  
  
  

   
  


  {
    ER_VALUE_SHOULD_BE_NUMBER,
        ""{0}에 대한 값은 구분 분석할 수 있는 숫자를 포함해야 합니다.""},

  
   
  


  {
    ER_VALUE_SHOULD_EQUAL,
        ""{0}에 대한 값은 예 또는 아니오이어야 합니다.""},

 
   
  


  {
    ER_FAILED_CALLING_METHOD,
        ""{0} 메소드 호출에 실패했습니다""},

  
   
  


  {
    ER_FAILED_CREATING_ELEMTMPL,
        ""ElemTemplateElement 인스턴스 작성에 실패했습니다""},

  
   
  


  {
    ER_CHARS_NOT_ALLOWED,
        ""이 문서에서 문자가 허용되지 않습니다""},

  
  
  


  {
    ER_ATTR_NOT_ALLOWED,
        """"{0}"" 속성이 {1} 요소에 허용되지 않습니다!""},

 
  
  


  {
    ER_BAD_VALUE,
     ""{0} 잘못된 값 {1} ""},

  
  
  


  {
    ER_ATTRIB_VALUE_NOT_FOUND,
     ""{0} 속성 값을 찾을 수 없습니다 ""},

  
  
  


  {
    ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""{0} 속성 값을 인식할 수 없습니다 ""},

  
  
  


  {
    ER_NULL_URI_NAMESPACE,
     ""널 URI로 이름 공간 접두부를 생성하려고 시도 중입니다""},
      
  
    

  
  


  {
    ER_NUMBER_TOO_BIG,
     ""가장 큰 Long 정수보다 큰 숫자 서식을 지정하려고 시도 중입니다.""},




  


  {
    ER_CANNOT_FIND_SAX1_DRIVER,
     ""SAX1 드라이버 클래스 {0}을(를) 찾을 수 없습니다.""},



  


  {
    ER_SAX1_DRIVER_NOT_LOADED,
     ""SAX1 드라이버 클래스 {0}을(를) 찾았지만 로드할 수 없습니다.""},



  


  {
    ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""SAX1 드라이버 클래스 {0}을(를) 로드했지만 인스턴스화할 수 없습니다.""},




  


  {
    ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
     ""SAX1 드라이버 클래스 {0}은(는) org.xml.sax.Parser를 구현하지 않습니다.""},



  


  {
    ER_PARSER_PROPERTY_NOT_SPECIFIED,
     ""org.xml.sax.parser 시스템 특성이 지정되어 있지 않습니다.""},



  


  {
    ER_PARSER_ARG_CANNOT_BE_NULL,
     ""Parser 인자는 널이 아니어야 합니다.""},




  


  {
    ER_FEATURE,
     ""기능: {0}""},




  


  {
    ER_PROPERTY,
     ""특성: {0}""},



  


  {
    ER_NULL_ENTITY_RESOLVER,
     ""널 엔티티 결정자""},



  


  {
    ER_NULL_DTD_HANDLER,
     ""널 DTD 처리기""},



  

  {
    ER_NO_DRIVER_NAME_SPECIFIED,
     ""드라이버 이름이 지정되지 않음!""},




  

  {
    ER_NO_URL_SPECIFIED,
     ""URL이 지정되지 않음!""},




  

  {
    ER_POOLSIZE_LESS_THAN_ONE,
     ""풀 크기가 1보다 작음!""},




  

  {
    ER_INVALID_DRIVER_NAME,
     ""잘못된 드라이브 이름이 지정됨!""},





  

  {
    ER_ERRORLISTENER,
     ""오류 수신기""},




  

  {
    ER_ASSERT_NO_TEMPLATE_PARENT,
     ""프로그래머 오류! 식에 ElemTemplateElement 부모가 없음!""},




  

  {
    ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
     ""RundundentExprEliminator의 프로그래머 명제: {0}""},


  
  

  {
    ER_NOT_ALLOWED_IN_POSITION,
     ""스타일 시트의 이 위치에는 {0}을(를) 사용할 수 없습니다!""},


  
  

  {
    ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
     ""스타일 시트의 이 위치에는 공백이 아닌 텍스트를 사용할 수 없습니다!""},


  
  
  
  

  {
    INVALID_TCHAR,
     ""잘못된 값:  CHAR 속성 {0}에 사용된 {1}.  CHAR 유형의 속성은 1자여야 합니다!""},


    
    
    
    
    

  
  
  

  {
    INVALID_QNAME,
     ""잘못된 값: QNAME 속성 {0}에 사용된 {1}""},


    
    
    
    
    
    

  
  

  {
    INVALID_ENUM,
     ""잘못된 값: ENUM 속성 {0}에 사용된 {1}.  유효한 값: {2}.""},








  
  

  {
    INVALID_NMTOKEN,
     ""잘못된 값: NMTOKEN 속성 {0}에 사용된 {1} ""},








  
  

  {
    INVALID_NCNAME,
     ""잘못된 값: NCNAME 속성 {0}에 사용된 {1} ""},








  
  


  {
    INVALID_BOOLEAN,
     ""잘못된 값: boolean 속성 {0}에 사용된 {1} ""},








  
  

  {
    INVALID_NUMBER,
     ""잘못된 값: number 속성 {0}에 사용된 {1} ""},



  







  
  

  {
    ER_ARG_LITERAL,
     ""일치 패턴에서 {0}에 대한 인자는 리터럴이어야 합니다.""},







  
  

  {
    ER_DUPLICATE_GLOBAL_VAR,
     ""중복되는 전역 변수 선언""},







  
  

  {
    ER_DUPLICATE_VAR,
     ""중복되는 변수 선언""},


    
    
    

  
  

  {
    ER_TEMPLATE_NAME_MATCH,
     ""xsl:template은 name 또는 match 속성(또는 모두)을 가져야 합니다.""},


    
    
    
    
    

  
  

  {
    ER_INVALID_PREFIX,
     ""exclude-result-prefixes의 접두어가 잘못되었습니다: {0}""},


    
    
    
    
    

  
  

  {
    ER_NO_ATTRIB_SET,
     ""이름이 {0}인 속성 집합이 없습니다.""},

  
  

  
  


  {
    WG_FOUND_CURLYBRACE,
      ""'}'를 찾았으나 속성 템플리트를 열 수 없습니다!""},


  
  


  {
    WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""경고: 카운트 속성이 xsl:number의 상위와 일치하지 않습니다! 대상 = {0}""},


  
  


  {
    WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""이전 구문: 'expr' 속성의 이름이 'select'로 변경되었습니다.""},


  
  


  {
    WG_NO_LOCALE_IN_FORMATNUMBER,
      ""Xalan이 format-number 기능에서 로켈 이름을 아직 처리하지 않습니다.""},


  
  


  {
    WG_LOCALE_NOT_FOUND,
      ""경고: xml:lang={0}에 대한 로켈을 찾을 수 없습니다.""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""{0}에서 URL을 작성할 수 없습니다.""},


  
  


  {
    WG_CANNOT_LOAD_REQUESTED_DOC,
      ""요청한 문서 {0}을(를) 로드할 수 없습니다.""},


  
  


  {
    WG_CANNOT_FIND_COLLATOR,
      ""<sort xml:lang={0}에 대한 조합기를 찾을 수 없습니다.""},


  
  


  {
    WG_FUNCTIONS_SHOULD_USE_URL,
      ""이전 구문: 함수 지시사항은 {0} url을 사용해야 합니다.""},


  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""UTF-8을 사용하여 코드화가 지원되지 않습니다: {0}""},


  
  


  {
    WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      ""Java {1}을(를) 사용하여 코드화가 지원되지 않습니다: {0} ""},


  
  


  {
    WG_SPECIFICITY_CONFLICTS,
      ""특이성 충돌이 발견되었습니다: 스타일 시트에서 마지막으로 발견된 {0}이(가) 사용됩니다.""},


  
  


  {
    WG_PARSING_AND_PREPARING,
      ""========= {0}을(를) 구문 분석 및 준비 중 ==========""},


  
  


  {
    WG_ATTR_TEMPLATE, ""Attr 템플리트, {0}""},


  
  


  {
    WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""xsl:strip-space 및 xsl:preserve-space 간의 일치 충돌""},


  
  


  {
    WG_ATTRIB_NOT_HANDLED,
      ""Xalan이 아직 {0} 속성을 처리하지 않습니다!""},


  
  


  {
    WG_NO_DECIMALFORMAT_DECLARATION,
      ""십진수 형식 {0}에 대한 선언을 찾을 수 없습니다.""},


  
  


  {
    WG_OLD_XSLT_NS, ""XSLT 이름 공간이 빠졌거나 잘못되었습니다. ""},


  
  


  {
    WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""하나의 기본 xsl:decimal-format 선언만 허용됩니다.""},


  
  


  {
    WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""xsl:decimal-format 이름은 고유해야 합니다. ""{0}""은(는) 중복됩니다.""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE,
      ""{0}에 잘못된 속성 {1}이(가) 있습니다.""},


  
  


  {
    WG_COULD_NOT_RESOLVE_PREFIX,
      ""이름 공간 접두어 {0}을(를) 결정할 수 없습니다. 이 노드는 무시됩니다.""},


  
  


  {
    WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet에 'version' 속성이 필요합니다!""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE_NAME,
      ""잘못된 속성 이름: {0}""},


  
  


  {
    WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""{0} 속성에 잘못된 값 {1}이(가) 사용되었습니다""},


  
  


  {
    WG_EMPTY_SECOND_ARG,
      ""문서 기능의 두 번째 인자의 결과로 발생한 노드 세트가 비어 있습니다. 첫 번째 인자가 사용됩니다.""},


  

    
    
    


  
  

  {
     WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""xsl:processing-instruction 이름의 'name' 속성 값은 'xml'이어서는 안됩니다.""},


    
    
    
    

  
  

  {
     WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""xsl:processing-instruction의 'name' 속성 값은 유효한 NCName이어야 합니다: {0}""},


    
    
    
    
    

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_POSITION,
      ""하위 노드 다음이나 또는 요소가 만들어지기 전에 속성 {0}을(를) 추가할 수 없습니다.  속성이 무시됩니다.""},


    

  
  { ""ui_language"", ""ko""},
  { ""help_language"", ""ko""},
  { ""language"", ""ko""},
    { ""BAD_CODE"",
      ""createMessage의 매개변수가 바운드를 벗어났습니다.""},
    { ""FORMAT_FAILED"",
      ""messageFormat 호출 시 예외 발생""},
    { ""version"", "">>>>>>> Xalan 버전 ""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""예""},
    { ""line"", ""행 #""},
    { ""column"", ""열 #""},
    { ""xsldone"", ""XSLProcessor: 완료""},
    { ""xslProc_option"",
    ""Xalan-J 명령줄 프로세스 클래스 옵션:""},
    { ""optionIN"", ""    -IN inputXMLURL""},
    { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
    { ""optionOUT"", ""   [-OUT outputFileName]""},
    { ""optionLXCIN"",
      ""   [-LXCIN compiledStylesheetFileNameIn]""},
    { ""optionLXCOUT"",
      ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
    { ""optionPARSER"",
      ""   [-PARSER 구문 분석기 liaison의 완전한 클래스 이름]""},
    { ""optionE"",
    ""   [-E (엔티티 refs를 확장하지 마십시오.)]""},
    { ""optionV"",
    ""   [-E (엔티티 refs를 확장하지 마십시오.)]""},
    { ""optionQC"",
      ""   [-QC (무음 패턴 충돌 경고)]""},
    { ""optionQ"", ""   [-Q  (무음 모드)]""},
    { ""optionLF"",
      ""   [-LF (출력에서만 줄 바꿈을 사용하십시오. {기본값은 CR/LF입니다.})]""},
    { ""optionCR"",
      ""   [-CR (출력에서만 캐리지 리턴을 사용하십시오. {기본값은 CR/LF입니다.})]""},
    { ""optionESCAPE"",
      ""   [-ESCAPE (제어할 문자 {기본값은 <>&""'\r\n}]""},
    { ""optionINDENT"",
      ""   [-INDENT (들여쓰기할 공백 수를 제어합니다. {기본값은 0입니다.})]""},
    { ""optionTT"",
      ""   [-TT (호출될 때 템플리트를 추적합니다.)]""},
    { ""optionTG"",
      ""   [-TG (각 생성 이벤트를 추적합니다.)]""},
    { ""optionTS"",
    ""   [-TS (각 선택 이벤트를 추적합니다.)]""},
    { ""optionTTC"",
      ""   [-TTC (처리될 때 템플리트 자식을 추적합니다.)]""},
    { ""optionTCLASS"",
      ""   [-TCLASS (추적 확장에 대한 TraceListener 클래스입니다.)]""},
    { ""optionVALIDATE"",
      ""   [-VALIDATE (검증 여부를 설정합니다. 기본값은 검증이 발생하지 않는 것입니다.)]""},
    { ""optionEDUMP"",
      ""   [-EDUMP {선택적 파일 이름} (오류가 발생하면 스택덤프 하십시오.)]""},
    { ""optionXML"",
      ""   [-XML (XML 포매터를 사용하여 XML 헤더를 추가하십시오.)]""},
    { ""optionTEXT"",
      ""   [-TEXT (단순 텍스트 포매터를 사용하십시오.)]""},
    { ""optionHTML"",
    ""   [-HTML (HTML 포매터를 사용하십시오.)]""},
    { ""optionPARAM"",
      ""   [-PARAM 이름 표현식 (스타일 시트 매개변수를 설정하십시오.)]""},
    { ""noParsermsg1"",
    ""XSL 프로세스가 성공하지 못했습니다.""},
    { ""noParsermsg2"",
    ""** 구문 분석기를 찾을 수 없습니다 **""},
    { ""noParsermsg3"",
    ""클래스 경로를 확인하십시오.""},
    { ""noParsermsg4"",
      ""Java용 IBM XML 구문 분석기가 없는 경우 다음에서 다운로드할 수 있습니다.""},
    { ""noParsermsg5"",
      ""IBM AlphaWorks: http:
    { ""optionURIRESOLVER"",
    ""   [-URIRESOLVER 전체 클래스 이름(URI를 결정하는 데 사용되는 URIResolver)]""},
    { ""optionENTITYRESOLVER"",
    ""   [-ENTITYRESOLVER 전체 클래스 이름(엔티티를 결정하는 데 사용되는 EntityResolver)]""},
    {  ""optionCONTENTHANDLER"",
    ""   [-CONTENTHANDLER 전체 클래스 이름(출력을 일련화하는 데 사용되는 ContentHandler)]""},
    { ""optionLINENUMBERS"",
    ""   [-L 소스 문서의 줄 번호 사용]""},
		
    


    { ""optionMEDIA"",
    "" [-MEDIA mediaType(media 속성을 사용하여 문서와 관련된 스타일 시트를 찾습니다.)]""},
    { ""optionFLAVOR"",
    "" [-FLAVOR flavorName(변환하려면 명시적으로 s2s=SAX 또는 d2d=DOM을 사용하십시오.)] ""}, 
    { ""optionDIAG"",
    "" [-DIAG(변환에 걸린 전체 시간(밀리초)를 인쇄합니다.)]""},
    { ""optionINCREMENTAL"",
    "" [-INCREMENTAL (http:
    { ""optionNOOPTIMIMIZE"",
    "" [-NOOPTIMIMIZE (http:
    { ""optionRL"",
    "" [-RL recursionlimit(스타일 시트 재귀 깊이에 대해 숫자 제한을 지정합니다.)]""},
    { ""optionXO"",
    "" [-XO [transletName] (생성된 translet에 이름을 할당합니다.)]""},
    { ""optionXD"",
    "" [-XD destinationDirectory(translet에 대한 대상 디렉토리를 지정합니다.)]""},
    { ""optionXJ"",
    "" [-XJ jarfile(translet 클래스를 이름이 <jarfile>인 jar 파일로 패키지화합니다.)]""},
    { ""optionXP"",
    "" [-XP package(생성된 모든 translet 클래스에 대해 패키지 이름 접두어를 지정합니다.)]""}


  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""오류: "";

  
  public static final String WARNING_HEADER = ""경고: "";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}
"
org.apache.xml.utils.res.XResources_cy,3,4,0,1,4,1,0,1,2,0.5,583,0.0,0,0.976190476,1.0,0,0,193.0,1,0.3333,1,"
package org.apache.xml.utils.res;



public class XResources_cy extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

 
  static final Object[][] contents =
  {
    { ""ui_language"", ""cy"" }, { ""help_language"", ""cy"" }, { ""language"", ""cy"" },
    { ""alphabet"",
      new char[]{ 0x0430, 0x0432, 0x0433, 0x0434, 0x0435, 0x0437, 0x0438,
                  0x0439, 0x04A9, 0x0457, 0x043A, 0x043B, 0x043C, 0x043D,
                  0x046F, 0x043E, 0x043F, 0x0447, 0x0440, 0x0441, 0x0442,
                  0x0443, 0x0444, 0x0445, 0x0470, 0x0460, 0x0446 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""precedes"" },

    
    
    
    { ""numberGroups"", new int[]{ 100, 10, 1 } },

    
    { ""multiplier"", new long[]{ 1000 } },
    { ""multiplierChar"", new char[]{ 0x03D9 } },

    
    { ""zero"", new char[0] },

    
    { ""digits"",
      new char[]{ 0x0430, 0x0432, 0x0433, 0x0434, 0x0435, 0x0437, 0x0438,
                  0x0439, 0x04A9 } },
    { ""tens"",
      new char[]{ 0x0457, 0x043A, 0x043B, 0x043C, 0x043D, 0x046F, 0x043E,
                  0x043F, 0x0447 } },
    { ""hundreds"",
      new char[]{ 0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0470,
                  0x0460, 0x0446 } },
    { ""tables"", new String[]{ ""hundreds"", ""tens"", ""digits"" } }
  };
}
"
org.apache.xalan.xsltc.compiler.QName,10,1,0,56,18,17,56,0,10,0.777777778,106,1.0,0,0.0,0.4,1,1,9.1,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

final class QName {
    private final String _localname;
    private String _prefix;
    private String _namespace;
    private String _stringRep;
    private int    _hashCode;

    public QName(String namespace, String prefix, String localname) {
	_namespace = namespace;
	_prefix    = prefix;
	_localname = localname;

	_stringRep = 
	    (namespace != null && !namespace.equals(Constants.EMPTYSTRING)) ?
	    (namespace + ':' + localname) : localname;

	_hashCode  = _stringRep.hashCode() + 19; 
    }

    public void clearNamespace() {
	_namespace = Constants.EMPTYSTRING;
    }

    public String toString() {
	return _stringRep;
    }

    public String getStringRep() {
	return _stringRep;
    }

    public boolean equals(Object other) {
	return (this == other);
    }

    public String getLocalPart() {
	return _localname;
    }

    public String getNamespace() {
	return _namespace;
    }

    public String getPrefix() {
	return _prefix;
    }

    public int hashCode() {
	return _hashCode;
    }

    public String dump() {
	return new String(""QName: "" + _namespace + ""("" + _prefix + ""):"" 
	    + _localname);
    }
}
"
org.apache.xalan.templates.ElemCopyOf,9,3,0,21,45,6,1,20,8,0.375,217,0.0,1,0.960784314,0.238095238,2,6,23.0,2,1.0,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.TreeWalker2Result;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.ref.DTMTreeWalker;
import org.apache.xalan.serialize.SerializerUtils;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;


public class ElemCopyOf extends ElemTemplateElement
{

  
  public XPath m_selectExpression = null;

  
  public void setSelect(XPath expr)
  {
    m_selectExpression = expr;
  }

  
  public XPath getSelect()
  {
    return m_selectExpression;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    m_selectExpression.fixupVariables(cstate.getVariableNames(), cstate.getGlobalsSize());
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_COPY_OF;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_COPY_OF_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
    	transformer.getTraceManager().fireTraceEvent(this);

    try
    {
      XPathContext xctxt = transformer.getXPathContext();
      int sourceNode = xctxt.getCurrentNode();
      XObject value = m_selectExpression.execute(xctxt, sourceNode, this);

      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                                                        ""select"", m_selectExpression, value);

      SerializationHandler handler = transformer.getSerializationHandler();

      if (null != value)
                        {
        int type = value.getType();
        String s;

        switch (type)
        {
        case XObject.CLASS_BOOLEAN :
        case XObject.CLASS_NUMBER :
        case XObject.CLASS_STRING :
          s = value.str();

          handler.characters(s.toCharArray(), 0, s.length());
          break;
        case XObject.CLASS_NODESET :

          
          DTMIterator nl = value.iter();

          
          DTMTreeWalker tw = new TreeWalker2Result(transformer, handler);
          int pos;

          while (DTM.NULL != (pos = nl.nextNode()))
          {
            DTM dtm = xctxt.getDTMManager().getDTM(pos);
            short t = dtm.getNodeType(pos);

            
            
            if (t == DTM.DOCUMENT_NODE)
            {
              for (int child = dtm.getFirstChild(pos); child != DTM.NULL;
                   child = dtm.getNextSibling(child))
              {
                tw.traverse(child);
              }
            }
            else if (t == DTM.ATTRIBUTE_NODE)
            {
              SerializerUtils.addAttribute(handler, pos);
            }
            else
            {
              tw.traverse(pos);
            }
          }
          
          break;
        case XObject.CLASS_RTREEFRAG :
          SerializerUtils.outputResultTreeFragment(
            handler, value, transformer.getXPathContext());
          break;
        default :
          
          s = value.str();

          handler.characters(s.toCharArray(), 0, s.length());
          break;
        }
      }
                        
      
      
      
      

    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEndEvent(this);
    }

  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  		m_selectExpression.getExpression().callVisitors(m_selectExpression, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xalan.xsltc.compiler.UseAttributeSets,4,3,0,19,30,0,5,15,4,0.833333333,127,1.0,0,0.949152542,0.416666667,1,4,30.25,4,2.0,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class UseAttributeSets extends Instruction {

    
    private final static String ATTR_SET_NOT_FOUND =
	"""";

    
    private final Vector _sets = new Vector(2);

    
    public UseAttributeSets(String setNames, Parser parser) {
	setParser(parser);
	addAttributeSets(setNames);
    }

    
    public void addAttributeSets(String setNames) {
	if ((setNames != null) && (!setNames.equals(Constants.EMPTYSTRING))) {
	    final StringTokenizer tokens = new StringTokenizer(setNames);
	    while (tokens.hasMoreTokens()) {
		final QName qname = 
		    getParser().getQNameIgnoreDefaultNs(tokens.nextToken());
		_sets.add(qname);
	    }
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final SymbolTable symbolTable = getParser().getSymbolTable();

	
	for (int i=0; i<_sets.size(); i++) {
	    
	    final QName name = (QName)_sets.elementAt(i);
	    
	    final AttributeSet attrs = symbolTable.lookupAttributeSet(name);
	    
	    if (attrs != null) {
		final String methodName = attrs.getMethodName();
		il.append(classGen.loadTranslet());
		il.append(methodGen.loadHandler());
		il.append(methodGen.loadIterator());
		final int method = cpg.addMethodref(classGen.getClassName(),
						    methodName, ATTR_SET_SIG);
		il.append(new INVOKESPECIAL(method));
	    }
	    
	    else {
		final Parser parser = getParser();
		final String atrs = name.toString();
		reportError(this, parser, ErrorMsg.ATTRIBSET_UNDEF_ERR, atrs);
	    }
	}
    }
}
"
org.apache.xpath.functions.Function2Args,9,4,7,15,23,6,8,8,8,0.375,123,0.0,1,0.857142857,0.355555556,3,9,12.55555556,6,1.7778,1,"
package org.apache.xpath.functions;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;


public class Function2Args extends FunctionOneArg
{

  
  Expression m_arg1;

  
  public Expression getArg1()
  {
    return m_arg1;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    if(null != m_arg1)
      m_arg1.fixupVariables(vars, globalsSize);
  }


  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {

    
    if (argNum == 0)
      super.setArg(arg, argNum);
    else if (1 == argNum)
    {
      m_arg1 = arg;
      arg.exprSetParent(this);
    }
    else
		  reportWrongNumberArgs();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum != 2)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""two"", null));
  }
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return super.canTraverseOutsideSubtree() 
    ? true : m_arg1.canTraverseOutsideSubtree();
   }
   
  class Arg1Owner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_arg1;
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(Function2Args.this);
    	m_arg1 = exp;
    }
  }

   
  
  public void callArgVisitors(XPathVisitor visitor)
  {
  	super.callArgVisitors(visitor);
  	if(null != m_arg1)
  		m_arg1.callVisitors(new Arg1Owner(), visitor);
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(null != m_arg1)
  	{
  		if(null == ((Function2Args)expr).m_arg1)
  			return false;
  			
  		if(!m_arg1.deepEquals(((Function2Args)expr).m_arg1))
  			return false;
  	}
  	else if(null != ((Function2Args)expr).m_arg1)
  		return false;
  		
  	return true;
  }

}
"
org.apache.xpath.objects.XBoolean,10,3,1,27,18,3,25,3,9,0.777777778,98,0.0,2,0.91025641,0.333333333,2,22,8.5,3,1.2,1,"
package org.apache.xpath.objects;


public class XBoolean extends XObject
{

  
  public static XBoolean S_TRUE = new XBooleanStatic(true);

  
  public static XBoolean S_FALSE = new XBooleanStatic(false);

  
  boolean m_val;

  
  public XBoolean(boolean b)
  {

    super();

    m_val = b;
  }
  
  
  public XBoolean(Boolean b)
  {

    super();

    m_val = b.booleanValue();
    m_obj = b;
  }


  
  public int getType()
  {
    return CLASS_BOOLEAN;
  }

  
  public String getTypeString()
  {
    return ""#BOOLEAN"";
  }

  
  public double num()
  {
    return m_val ? 1.0 : 0.0;
  }

  
  public boolean bool()
  {
    return m_val;
  }

  
  public String str()
  {
    return m_val ? ""true"" : ""false"";
  }

  
  public Object object()
  {
    if(null == m_obj)
      m_obj = new Boolean(m_val);
    return m_obj;
  }

  
  public boolean equals(XObject obj2)
  {

    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.equals(this);

    try
    {
      return m_val == obj2.bool();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }

}
"
org.apache.xpath.axes.UnionPathIterator,16,5,0,22,54,46,4,21,13,0.6,560,1.0,2,0.899280576,0.2,2,13,33.875,9,2.4375,2,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.OpCodes;


public class UnionPathIterator extends LocPathIterator
        implements Cloneable, DTMIterator, java.io.Serializable, PathComponent
{

  
  public UnionPathIterator()
  {

    super();

    
    
    m_iterators = null;
    m_exprs = null;
  }

  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);

    try
    {
      if (null != m_exprs)
      {
        int n = m_exprs.length;
        DTMIterator newIters[] = new DTMIterator[n];
  
        for (int i = 0; i < n; i++)
        {
          DTMIterator iter = m_exprs[i].asIterator(m_execContext, context);
          newIters[i] = iter;
          iter.nextNode();
        }
        m_iterators = newIters;
      }
    }
    catch(Exception e)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(e);
    }
  }
  
  
  public void addIterator(DTMIterator expr)
  {

    
    
    if (null == m_iterators)
    {
      m_iterators = new DTMIterator[1];
      m_iterators[0] = expr;
    }
    else
    {
      DTMIterator[] exprs = m_iterators;
      int len = m_iterators.length;

      m_iterators = new DTMIterator[len + 1];

      System.arraycopy(exprs, 0, m_iterators, 0, len);

      m_iterators[len] = expr;
    }
    expr.nextNode();
    if(expr instanceof Expression)
    	((Expression)expr).exprSetParent(this);
  }
  
  
  public void detach()
  {    
    if(null != m_iterators)
    {
    	int n = m_iterators.length;
    	for(int i = 0; i < n; i++)
    	{
    		m_iterators[i].detach();
    	}
    	m_iterators = null;
    }
  }


  
  public UnionPathIterator(Compiler compiler, int opPos)
          throws javax.xml.transform.TransformerException
  {

    super();

    opPos = compiler.getFirstChildPos(opPos);

    loadLocationPaths(compiler, opPos, 0);
  }
  
  
  public static LocPathIterator createUnionIterator(Compiler compiler, int opPos)
          throws javax.xml.transform.TransformerException
  {
  	
  	
  	
  	
  	UnionPathIterator upi = new UnionPathIterator(compiler, opPos);
  	int nPaths = upi.m_exprs.length;
  	boolean isAllChildIterators = true;
  	for(int i = 0; i < nPaths; i++)
  	{
  		LocPathIterator lpi = upi.m_exprs[i];
  		
  		if(lpi.getAxis() != Axis.CHILD)
  		{
  			isAllChildIterators = false;
  			break;
  		}
  		else
  		{
  			
  			if(HasPositionalPredChecker.check(lpi))
  			{
  				isAllChildIterators = false;
  				break;
  			}
  		}
  	}
  	if(isAllChildIterators)
  	{
  		UnionChildIterator uci = new UnionChildIterator();
  		
	  	for(int i = 0; i < nPaths; i++)
	  	{
	  		PredicatedNodeTest lpi = upi.m_exprs[i];
	  		
	  		
	  		
	  		uci.addNodeTest(lpi);
	  	}
	  	return uci;
  		
  	}
  	else
  		return upi;
  }
  
  
  public int getAnalysisBits()
  {
    int bits = 0;
    
    if (m_exprs != null)
    {
      int n = m_exprs.length;

      for (int i = 0; i < n; i++)
      {
      	int bit = m_exprs[i].getAnalysisBits();
        bits |= bit;
      }
    }

    return bits;
  }
  
  
  private void readObject(java.io.ObjectInputStream stream)
          throws java.io.IOException, javax.xml.transform.TransformerException
  {
    try
    {
      stream.defaultReadObject();
      m_clones =  new IteratorPool(this);
    }
    catch (ClassNotFoundException cnfe)
    {
      throw new javax.xml.transform.TransformerException(cnfe);
    }
  }

  
  public Object clone() throws CloneNotSupportedException
  {

    UnionPathIterator clone = (UnionPathIterator) super.clone();












    return clone;
  }
  
  
  
  protected LocPathIterator createDTMIterator(
          Compiler compiler, int opPos) throws javax.xml.transform.TransformerException
  {
    LocPathIterator lpi = (LocPathIterator)WalkerFactory.newDTMIterator(compiler, opPos, 
                                      (compiler.getLocationPathDepth() <= 0));
    return lpi;
  }

  
  protected void loadLocationPaths(Compiler compiler, int opPos, int count)
          throws javax.xml.transform.TransformerException
  {

    
    int steptype = compiler.getOp(opPos);

    if (steptype == OpCodes.OP_LOCATIONPATH)
    {
      loadLocationPaths(compiler, compiler.getNextOpPos(opPos), count + 1);

      m_exprs[count] = createDTMIterator(compiler, opPos);
      m_exprs[count].exprSetParent(this);
    }
    else
    {

      
      
      switch (steptype)
      {
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
        loadLocationPaths(compiler, compiler.getNextOpPos(opPos), count + 1);

        WalkingIterator iter =
          new WalkingIterator(compiler.getNamespaceContext());
        iter.exprSetParent(this);
          
        if(compiler.getLocationPathDepth() <= 0)
          iter.setIsTopLevel(true);

        iter.m_firstWalker = new org.apache.xpath.axes.FilterExprWalker(iter);

        iter.m_firstWalker.init(compiler, opPos, steptype);

        m_exprs[count] = iter;
        break;
      default :
        m_exprs = new LocPathIterator[count];
      }
    }
  }

  
  public int nextNode()
  {
  	if(m_foundLast)
  		return DTM.NULL;

    
    
    int earliestNode = DTM.NULL;

    if (null != m_iterators)
    {
      int n = m_iterators.length;
      int iteratorUsed = -1;

      for (int i = 0; i < n; i++)
      {
        int node = m_iterators[i].getCurrentNode();

        if (DTM.NULL == node)
          continue;
        else if (DTM.NULL == earliestNode)
        {
          iteratorUsed = i;
          earliestNode = node;
        }
        else
        {
          if (node == earliestNode)
          {

            
            m_iterators[i].nextNode();
          }
          else
          {
            DTM dtm = getDTM(node);

            if (dtm.isNodeAfter(node, earliestNode))
            {
              iteratorUsed = i;
              earliestNode = node;
            }
          }
        }
      }

      if (DTM.NULL != earliestNode)
      {
        m_iterators[iteratorUsed].nextNode();

        incrementCurrentPos();
      }
      else
        m_foundLast = true;
    }

    m_lastFetched = earliestNode;

    return earliestNode;
  }
            
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    for (int i = 0; i < m_exprs.length; i++) 
    {
      m_exprs[i].fixupVariables(vars, globalsSize);
    }
    
  }
  
  
  protected LocPathIterator[] m_exprs;

    
  
  protected DTMIterator[] m_iterators;
      
  
  public int getAxis()
  {
    
    return -1;
  }
  
  class iterOwner implements ExpressionOwner
  {
  	int m_index;
  	
  	iterOwner(int index)
  	{
  		m_index = index;
  	}
  	
    
    public Expression getExpression()
    {
      return m_exprs[m_index];
    }

    
    public void setExpression(Expression exp)
    {
    	
    	if(!(exp instanceof LocPathIterator))
    	{
    		
    		
    		WalkingIterator wi = new WalkingIterator(getPrefixResolver());
    		FilterExprWalker few = new FilterExprWalker(wi);
    		wi.setFirstWalker(few);
    		few.setInnerExpression(exp);
    		wi.exprSetParent(UnionPathIterator.this);
    		few.exprSetParent(wi);
    		exp.exprSetParent(few);
    		exp = wi;
    	}
    	else
    		exp.exprSetParent(UnionPathIterator.this);
    	m_exprs[m_index] = (LocPathIterator)exp;
    }

  }

  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	 	if(visitor.visitUnionPath(owner, this))
  	 	{
  	 		if(null != m_exprs)
  	 		{
  	 			int n = m_exprs.length;
  	 			for(int i = 0; i < n; i++)
  	 			{
  	 				m_exprs[i].callVisitors(new iterOwner(i), visitor);
  	 			}
  	 		}
  	 	}
  }
  
    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
            return false;

      UnionPathIterator upi = (UnionPathIterator) expr;

      if (null != m_exprs)
      {
        int n = m_exprs.length;
        
        if((null == upi.m_exprs) || (upi.m_exprs.length != n))
        	return false;
        
        for (int i = 0; i < n; i++)
        {
          if(!m_exprs[i].deepEquals(upi.m_exprs[i]))
          	return false;
        }
      }
      else if (null != upi.m_exprs)
      {
          return false;
      }

      return true;
    }


}
"
org.apache.xalan.xsltc.compiler.TestSeq,11,1,0,13,45,0,1,13,9,0.633333333,360,1.0,2,0.0,0.222222222,0,0,31.18181818,11,2.4545,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Dictionary;
import java.util.Vector;

import org.apache.bcel.generic.GOTO_W;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;


final class TestSeq {

    
    private int _kernelType;

    
    private Vector _patterns = null;

    
    private Mode _mode = null;

    
    private Template _default = null;

    
    private InstructionList _instructionList;

    
    private InstructionHandle _start = null;

    
    public TestSeq(Vector patterns, Mode mode) {
	this(patterns, -2, mode);
    }

    public TestSeq(Vector patterns, int kernelType, Mode mode) {
	_patterns = patterns;
	_kernelType = kernelType;
	_mode = mode;
    }

    
    public String toString() {
	final int count = _patterns.size();
	final StringBuffer result = new StringBuffer();

	for (int i = 0; i < count; i++) {
	    final LocationPathPattern pattern =
		(LocationPathPattern) _patterns.elementAt(i);

	    if (i == 0) {
		result.append(""Testseq for kernel "" + _kernelType)
		      .append('
');
	    }
	    result.append(""   pattern "" + i + "": "")
	          .append(pattern.toString())
		  .append('
');
	}
	return result.toString();
    }

    
    public InstructionList getInstructionList() {
	return _instructionList;
    }

    
    public double getPriority() {
	final Template template = (_patterns.size() == 0) ? _default 
	    : ((Pattern) _patterns.elementAt(0)).getTemplate();
	return template.getPriority();
    }

    
    public int getPosition() {
	final Template template = (_patterns.size() == 0) ? _default 
	    : ((Pattern) _patterns.elementAt(0)).getTemplate();
	return template.getPosition();
    }

    
    public void reduce() {
	final Vector newPatterns = new Vector();

	final int count = _patterns.size();
	for (int i = 0; i < count; i++) {
	    final LocationPathPattern pattern =
		(LocationPathPattern)_patterns.elementAt(i);
		
	    
	    pattern.reduceKernelPattern();
			
	    
	    if (pattern.isWildcard()) {
		_default = pattern.getTemplate();
		break; 		
	    }
	    else {
		newPatterns.addElement(pattern);
	    }
	}
	_patterns = newPatterns;
    }

    
    public void findTemplates(Dictionary templates) {
	if (_default != null) {
	    templates.put(_default, this);
	}
	for (int i = 0; i < _patterns.size(); i++) {
	    final LocationPathPattern pattern =
		(LocationPathPattern)_patterns.elementAt(i);
	    templates.put(pattern.getTemplate(), this);
	}
    }

    
    private InstructionHandle getTemplateHandle(Template template) {
	return (InstructionHandle)_mode.getTemplateInstructionHandle(template);
    }

    
    private LocationPathPattern getPattern(int n) {
	return (LocationPathPattern)_patterns.elementAt(n);
    }

    
    public InstructionHandle compile(ClassGenerator classGen,
				     MethodGenerator methodGen,
				     InstructionHandle continuation) 
    {
	
	if (_start != null) {
	    return _start;
	}

	
	final int count = _patterns.size();
	if (count == 0) {
	    return (_start = getTemplateHandle(_default));
	}

	
	InstructionHandle fail = (_default == null) ? continuation
	    : getTemplateHandle(_default);
	
	
	for (int n = count - 1; n >= 0; n--) {
	    final LocationPathPattern pattern = getPattern(n);
	    final Template template = pattern.getTemplate();
	    final InstructionList il = new InstructionList();

	    
	    il.append(methodGen.loadCurrentNode());

	    
	    InstructionList ilist = _mode.getInstructionList(pattern);
	    if (ilist == null) {
		ilist = pattern.compile(classGen, methodGen);
		_mode.addInstructionList(pattern, ilist);
	    }

	    
	    InstructionList copyOfilist = ilist.copy();

	    FlowList trueList = pattern.getTrueList();
	    if (trueList != null) {
		trueList = trueList.copyAndRedirect(ilist, copyOfilist);
	    }
	    FlowList falseList = pattern.getFalseList();
	    if (falseList != null) {
		falseList = falseList.copyAndRedirect(ilist, copyOfilist);
	    }

	    il.append(copyOfilist);

	    
	    final InstructionHandle gtmpl = getTemplateHandle(template);
	    final InstructionHandle success = il.append(new GOTO_W(gtmpl));

	    if (trueList != null) {
		trueList.backPatch(success);
	    }
	    if (falseList != null) {
		falseList.backPatch(fail);
	    } 

	    
	    fail = il.getStart();

	    
	    if (_instructionList != null) {
		il.append(_instructionList);
	    }

	    
	    _instructionList = il;
	}
	return (_start = fail);
    }
}
"
org.apache.xml.dtm.ref.ExpandedNameTable,13,1,0,23,25,2,21,2,10,0.949275362,383,0.391304348,4,0.0,0.555555556,0,0,26.69230769,9,2.0,1,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTM;


public class ExpandedNameTable
{

  
  private ExtendedType[] m_extendedTypes;

  
  private static int m_initialSize = 128;
  
  
  
  
  private int m_nextType;

  
  public static final int ELEMENT = ((int)DTM.ELEMENT_NODE) ;
  public static final int ATTRIBUTE = ((int)DTM.ATTRIBUTE_NODE) ;
  public static final int TEXT = ((int)DTM.TEXT_NODE) ;
  public static final int CDATA_SECTION = ((int)DTM.CDATA_SECTION_NODE) ;
  public static final int ENTITY_REFERENCE = ((int)DTM.ENTITY_REFERENCE_NODE) ;
  public static final int ENTITY = ((int)DTM.ENTITY_NODE) ;
  public static final int PROCESSING_INSTRUCTION = ((int)DTM.PROCESSING_INSTRUCTION_NODE) ;
  public static final int COMMENT = ((int)DTM.COMMENT_NODE) ;
  public static final int DOCUMENT = ((int)DTM.DOCUMENT_NODE) ;
  public static final int DOCUMENT_TYPE = ((int)DTM.DOCUMENT_TYPE_NODE) ;
  public static final int DOCUMENT_FRAGMENT =((int)DTM.DOCUMENT_FRAGMENT_NODE) ;
  public static final int NOTATION = ((int)DTM.NOTATION_NODE) ;
  public static final int NAMESPACE = ((int)DTM.NAMESPACE_NODE) ;

  
  ExtendedType hashET = new ExtendedType(-1, """", """");

  
  private static ExtendedType[] m_defaultExtendedTypes;

  
  private static float m_loadFactor = 0.75f;
    
   
  private static int m_initialCapacity = 203;
  
   
  private int m_capacity;
  
  
  private int m_threshold;
  
  
  private HashEntry[] m_table;

  
  static {
    m_defaultExtendedTypes = new ExtendedType[DTM.NTYPES];

    for (int i = 0; i < DTM.NTYPES; i++)
    {
      m_defaultExtendedTypes[i] = new ExtendedType(i, """", """");
    }
  }

  
  public ExpandedNameTable()
  {
    m_capacity = m_initialCapacity;
    m_threshold = (int)(m_capacity * m_loadFactor);
    m_table = new HashEntry[m_capacity];
    
    initExtendedTypes();
  }


  
  private void initExtendedTypes()
  {    
    m_extendedTypes = new ExtendedType[m_initialSize];
    for (int i = 0; i < DTM.NTYPES; i++) {
        m_extendedTypes[i] = m_defaultExtendedTypes[i];
        m_table[i] = new HashEntry(m_defaultExtendedTypes[i], i, i, null);
    }
    
    m_nextType = DTM.NTYPES;
  }

  
  public int getExpandedTypeID(String namespace, String localName, int type)
  {
    if (null == namespace)
      namespace = """";
    if (null == localName)
      localName = """";
    
    
    int hash = type + namespace.hashCode() + localName.hashCode();
    
    
    hashET.redefine(type, namespace, localName, hash);
    
    
    int index = hash % m_capacity;
    if (index < 0)
      index = -index;

    
    
    for (HashEntry e = m_table[index]; e != null; e = e.next)
    {
      if (e.hash == hash && e.key.equals(hashET))
        return e.value;
    }

    
    if (m_nextType > m_threshold)
      rehash();
    
    
    ExtendedType newET = new ExtendedType(type, namespace, localName, hash);
    
    
    if (m_extendedTypes.length == m_nextType) {
        ExtendedType[] newArray = new ExtendedType[m_extendedTypes.length * 2];
        System.arraycopy(m_extendedTypes, 0, newArray, 0,
                         m_extendedTypes.length);
        m_extendedTypes = newArray;
    }
    
    m_extendedTypes[m_nextType] = newET;
    
    
    
    HashEntry entry = new HashEntry(newET, m_nextType, hash, m_table[index]);
    m_table[index] = entry;

    return m_nextType++;
  }

  
  private void rehash()
  {
    int oldCapacity = m_capacity;
    HashEntry[] oldTable = m_table;
      
    int newCapacity = 2 * oldCapacity + 1;
    m_capacity = newCapacity;
    m_threshold = (int)(newCapacity * m_loadFactor);
      
    m_table = new HashEntry[newCapacity];
    for (int i = oldCapacity-1; i >=0 ; i--)
    {
      for (HashEntry old = oldTable[i]; old != null; )
      {
        HashEntry e = old;
        old = old.next;
          
        int newIndex = e.hash % newCapacity;
        if (newIndex < 0)
          newIndex = -newIndex;
          
        e.next = m_table[newIndex];
        m_table[newIndex] = e;
      }
    }
  }

  
  public int getExpandedTypeID(int type)
  {
    return type;
  }

  
  public String getLocalName(int ExpandedNameID)
  {
    return m_extendedTypes[ExpandedNameID].getLocalName();
  }

  
  public final int getLocalNameID(int ExpandedNameID)
  {
    
    if (m_extendedTypes[ExpandedNameID].getLocalName().equals(""""))
      return 0;
    else
    return ExpandedNameID;
  }


  
  public String getNamespace(int ExpandedNameID)
  {
    String namespace = m_extendedTypes[ExpandedNameID].getNamespace();
    return (namespace.equals("""") ? null : namespace);
  }

  
  public final int getNamespaceID(int ExpandedNameID)
  {
    
    if (m_extendedTypes[ExpandedNameID].getNamespace().equals(""""))
      return 0;
    else
    return ExpandedNameID;
  }

  
  public final short getType(int ExpandedNameID)
  {
    
    return (short)m_extendedTypes[ExpandedNameID].getNodeType();
  }
  
  
  public int getSize()
  {
    return m_nextType;
  }
  
  
  public ExtendedType[] getExtendedTypes()
  {
    return m_extendedTypes;
  }

  
  private static final class HashEntry
  {
    ExtendedType key;
    int value;
    int hash;
    HashEntry next;
      
    protected HashEntry(ExtendedType key, int value, int hash, HashEntry next)
    {
      this.key = key;
      this.value = value;
      this.hash = hash;
      this.next = next;
    }
  }
  
}"
org.apache.xml.serializer.WriterToUTF8,7,2,0,1,13,0,1,0,7,0.583333333,214,1.0,0,0.684210526,0.342857143,1,2,29.28571429,1,0.8571,0,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.io.Writer;


public class WriterToUTF8 extends Writer
{

    
    private static final boolean DEBUG_OUT = false;

    
    private final OutputStream m_os;

    
    public WriterToUTF8(OutputStream os) throws UnsupportedEncodingException
    {
        m_os = os;
    }

    
    public void write(final int c) throws IOException
    {

        if (c < 0x80)
            m_os.write(c);
        else if (c < 0x800)
        {
            m_os.write(0xc0 + (c >> 6));
            m_os.write(0x80 + (c & 0x3f));
        }
        else
        {
            m_os.write(0xe0 + (c >> 12));
            m_os.write(0x80 + ((c >> 6) & 0x3f));
            m_os.write(0x80 + (c & 0x3f));
        }

        if (DEBUG_OUT)
        {
            if (c < 0x80)
            {
                char ch = (char) c;
                System.out.print(ch);
            }
            else if (c < 0x800)
            {
                System.out.print(0xc0 + (c >> 6));
                System.out.print(0x80 + (c & 0x3f));
            }
            else
            {
                System.out.print(0xe0 + (c >> 12));
                System.out.print(0x80 + ((c >> 6) & 0x3f));
                System.out.print(0x80 + (c & 0x3f));
            }
            System.out.flush();
        }
        return;
    }

    
    public void write(final char chars[], final int start, final int length)
        throws java.io.IOException
    {

        final OutputStream os = m_os;

        int n = length + start;
        for (int i = start; i < n; i++)
        {
            final char c = chars[i];

            if (c < 0x80)
                os.write(c);
            else if (c < 0x800)
            {
                os.write(0xc0 + (c >> 6));
                os.write(0x80 + (c & 0x3f));
            }
            else
            {
                os.write(0xe0 + (c >> 12));
                os.write(0x80 + ((c >> 6) & 0x3f));
                os.write(0x80 + (c & 0x3f));
            }
        }

        if (DEBUG_OUT)
        {
            for (int i = start; i < n; i++)
            {
                final char c = chars[i];

                if (c < 0x80)
                    System.out.print(c);
                else if (c < 0x800)
                {
                    System.out.print(0xc0 + (c >> 6));
                    System.out.print(0x80 + (c & 0x3f));
                }
                else
                {
                    System.out.print(0xe0 + (c >> 12));
                    System.out.print(0x80 + ((c >> 6) & 0x3f));
                    System.out.print(0x80 + (c & 0x3f));
                }
            }
            System.out.flush();
        }
        return;
    }

    
    public void write(final String s) throws IOException
    {

        final int n = s.length();
        final OutputStream os = m_os;

        for (int i = 0; i < n; i++)
        {
            final char c = s.charAt(i);

            if (c < 0x80)
                os.write(c);
            else if (c < 0x800)
            {
                os.write(0xc0 + (c >> 6));
                os.write(0x80 + (c & 0x3f));
            }
            else
            {
                os.write(0xe0 + (c >> 12));
                os.write(0x80 + ((c >> 6) & 0x3f));
                os.write(0x80 + (c & 0x3f));
            }
        }

        if (DEBUG_OUT)
        {

            for (int i = 0; i < n; i++)
            {
                final char c = s.charAt(i);

                if (c < 0x80)
                    System.out.print(c);
                else if (c < 0x800)
                {
                    System.out.print(0xc0 + (c >> 6));
                    System.out.print(0x80 + (c & 0x3f));
                }
                else
                {
                    System.out.print(0xe0 + (c >> 12));
                    System.out.print(0x80 + ((c >> 6) & 0x3f));
                    System.out.print(0x80 + (c & 0x3f));
                }
            }
            System.out.flush();
        }
        return;
    }

    
    public void flush() throws java.io.IOException
    {
        m_os.flush();
    }

    
    public void close() throws java.io.IOException
    {
        m_os.close();
    }

    
    public OutputStream getOutputStream()
    {
        return m_os;
    }
}
"
org.apache.xpath.operations.Quo,2,3,0,4,5,1,1,3,2,2.0,16,0.0,0,0.976190476,0.75,1,1,7.0,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class Quo extends Operation
{

  

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber((int) (left.num() / right.num()));
  }
}
"
org.apache.xpath.FoundIndex,1,4,0,0,2,0,0,0,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xpath;


public class FoundIndex extends RuntimeException
{

  
  public FoundIndex(){}
}
"
org.apache.xpath.axes.FilterExprWalker,18,5,0,19,48,13,5,15,16,0.735294118,244,1.0,2,0.858333333,0.185185185,4,14,12.33333333,3,1.3889,0,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.OpCodes;
import org.apache.xpath.objects.XNodeSet;


public class FilterExprWalker extends AxesWalker
{

  
  public FilterExprWalker(WalkingIterator locPathIterator)
  {
    super(locPathIterator, Axis.FILTEREDLIST);
  }

  
  public void init(Compiler compiler, int opPos, int stepType)
          throws javax.xml.transform.TransformerException
  {

    super.init(compiler, opPos, stepType);

    
    switch (stepType)
    {
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_EXTFUNCTION :
    	m_mustHardReset = true;
    case OpCodes.OP_GROUP :
    case OpCodes.OP_VARIABLE :
      m_expr = compiler.compile(opPos);
      m_expr.exprSetParent(this);
      
      if(m_expr instanceof org.apache.xpath.operations.Variable)
      {
      	
      	m_canDetachNodeset = false;
      }
      break;
    default :
      m_expr = compiler.compile(opPos + 2);
      m_expr.exprSetParent(this);
    }














  }
  
  
  public void detach()
  {  
  	super.detach();
  	if (m_canDetachNodeset)
  	{
  	  m_exprObj.detach();
  	}
  	m_exprObj = null;
  }

  
  public void setRoot(int root)
  {

    super.setRoot(root);

  	m_exprObj = FilterExprIteratorSimple.executeFilterExpr(root, 
  	                  m_lpi.getXPathContext(), m_lpi.getPrefixResolver(), 
  	                  m_lpi.getIsTopLevel(), m_lpi.m_stackFrame, m_expr);

  }

  
  public Object clone() throws CloneNotSupportedException
  {

    FilterExprWalker clone = (FilterExprWalker) super.clone();

    
    if (null != m_exprObj)
      clone.m_exprObj = (XNodeSet) m_exprObj.clone();

    return clone;
  }
  
  
  public short acceptNode(int n)
  {

    try
    {
      if (getPredicateCount() > 0)
      {
        countProximityPosition(0);

        if (!executePredicates(n, m_lpi.getXPathContext()))
          return DTMIterator.FILTER_SKIP;
      }

      return DTMIterator.FILTER_ACCEPT;
    }
    catch (javax.xml.transform.TransformerException se)
    {
      throw new RuntimeException(se.getMessage());
    }
  }

  
  public int getNextNode()
  {

    if (null != m_exprObj)
    {
       int next = m_exprObj.nextNode();
       return next;
    }
    else
      return DTM.NULL;
  }
  
  
  public int getLastPos(XPathContext xctxt)
  {
    return m_exprObj.getLength();
  }
  
  
  private Expression m_expr;

  
  transient private XNodeSet m_exprObj;
  
  private boolean m_mustHardReset = false;
  private boolean m_canDetachNodeset = true;

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    m_expr.fixupVariables(vars, globalsSize);
  }
  
  
  public Expression getInnerExpression()
  {
  	return m_expr;
  }
  
  
  public void setInnerExpression(Expression expr)
  {
  	expr.exprSetParent(this);
  	m_expr = expr;
  }

  
  
  public int getAnalysisBits()
  {
      if (null != m_expr && m_expr instanceof PathComponent)
      {
        return ((PathComponent) m_expr).getAnalysisBits();
      }
      return WalkerFactory.BIT_FILTER;
  }
  
  
  public boolean isDocOrdered()
  {
    return m_exprObj.isDocOrdered();
  }
  
  
  public int getAxis()
  {
    return m_exprObj.getAxis();
  }
  
  class filterExprOwner implements ExpressionOwner
  {
      
    public Expression getExpression()
    {
      return m_expr;
    }

    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(FilterExprWalker.this);
    	m_expr = exp;
    }
  }
  
	
	public void callPredicateVisitors(XPathVisitor visitor)
	{
	  m_expr.callVisitors(new filterExprOwner(), visitor);
	  
	  super.callPredicateVisitors(visitor);
	} 


    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
                return false;

      FilterExprWalker walker = (FilterExprWalker)expr;
      if(!m_expr.deepEquals(walker.m_expr))
      	return false;

      return true;
    }

	

}
"
org.apache.xalan.xsltc.compiler.Include,5,3,0,14,51,4,1,14,4,0.5,332,1.0,1,0.9375,0.36,2,5,65.2,14,3.4,2,"

package org.apache.xalan.xsltc.compiler;

import java.io.File;
import java.io.FileNotFoundException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Enumeration;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;

final class Include extends TopLevelElement {

    private Stylesheet _included = null;

    public Stylesheet getIncludedStylesheet() {
	return _included;
    }

    public void parseContents(final Parser parser) {
	final Stylesheet context = parser.getCurrentStylesheet();

	String docToLoad = getAttribute(""href"");
	try {
	    if (context.checkForLoop(docToLoad)) {
		final ErrorMsg msg = new ErrorMsg(ErrorMsg.CIRCULAR_INCLUDE_ERR,
                                                  docToLoad, this);
		parser.reportError(Constants.FATAL, msg);
		return;
	    }

	    String currLoadedDoc = context.getSystemId();
	    SourceLoader loader = context.getSourceLoader();
	    InputSource input = null;
	    XMLReader reader = null;

	    if (loader != null) {
		final XSLTC xsltc = parser.getXSLTC();
		input = loader.loadSource(docToLoad, currLoadedDoc, xsltc);
		reader = xsltc.getXMLReader();
	    }
	    else {
		
		if ((currLoadedDoc != null) && (currLoadedDoc.length() > 0)) {
		    File file = new File(currLoadedDoc);
		    if (file.exists()) {
		        currLoadedDoc = ""file:"" + file.getCanonicalPath();
		    }
		    final URL url = new URL(new URL(currLoadedDoc), docToLoad);
		    docToLoad = url.toString();
		    input = new InputSource(docToLoad);
		}
		else {
		    File file = new File(System.getProperty(""user.dir""),
			docToLoad);
		    if (file.exists()) {
			docToLoad = ""file:"" + file.getCanonicalPath();
		    }
		    else {
			final ErrorMsg msg =
                                       new ErrorMsg(ErrorMsg.FILE_ACCESS_ERR,
                                                    docToLoad);
                        parser.reportError(Constants.FATAL, msg);
                        return;
		    }
		    input = new InputSource(docToLoad);
		}
	    }

	    
	    if (input == null) {
		final ErrorMsg msg = 
		    new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, docToLoad, this);
		parser.reportError(Constants.FATAL, msg);
		return;
	    }

	    final SyntaxTreeNode root;
            if (reader != null) {
                root = parser.parse(reader,input);
            }
            else {
                root = parser.parse(input);
            }
              
	    if (root == null) return;
	    _included = parser.makeStylesheet(root);
	    if (_included == null) return;

	    _included.setSourceLoader(loader);
	    _included.setSystemId(docToLoad);
	    _included.setParentStylesheet(context);
	    _included.setIncludingStylesheet(context);
	    _included.setTemplateInlining(context.getTemplateInlining());

	    
	    
	    final int precedence = context.getImportPrecedence();
	    _included.setImportPrecedence(precedence);
	    parser.setCurrentStylesheet(_included);
	    _included.parseContents(parser);

	    final Enumeration elements = _included.elements();
	    final Stylesheet topStylesheet = parser.getTopLevelStylesheet();
	    while (elements.hasMoreElements()) {
		final Object element = elements.nextElement();
		if (element instanceof TopLevelElement) {
		    if (element instanceof Variable) {
			topStylesheet.addVariable((Variable) element);
		    }
		    else if (element instanceof Param) {
			topStylesheet.addParam((Param) element);
		    }
		    else {
			topStylesheet.addElement((TopLevelElement) element);
		    }
		}
	    }
	}
	catch (FileNotFoundException e) {
	    
	    context.setSystemId(getAttribute(""href""));

	    final ErrorMsg msg = 
		new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, docToLoad, this);
	    parser.reportError(Constants.FATAL, msg);
	}
	catch (MalformedURLException e) {
	    
	    context.setSystemId(getAttribute(""href""));

	    final ErrorMsg msg = 
		new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, docToLoad, this);
	    parser.reportError(Constants.FATAL, msg);
	}
	catch (Exception e) {
	    e.printStackTrace();
	}
	finally {
	    parser.setCurrentStylesheet(context);
	}
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }
}
"
org.apache.xalan.processor.StylesheetHandler,70,2,0,46,152,2107,25,24,33,0.93812709,1315,0.730769231,5,0.2,0.108695652,1,1,17.41428571,7,1.3,4,"
package org.apache.xalan.processor;

import java.util.Stack;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.Templates;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.sax.TemplatesHandler;

import org.apache.xalan.extensions.ExpressionVisitor;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemForEach;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.NamespaceSupport2;
import org.apache.xml.utils.NodeConsumer;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xpath.XPath;
import org.apache.xpath.compiler.FunctionTable;
import org.apache.xpath.functions.Function;

import org.w3c.dom.Node;

import org.xml.sax.Attributes;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.helpers.DefaultHandler;
import org.xml.sax.helpers.NamespaceSupport;


public class StylesheetHandler extends DefaultHandler
        implements TemplatesHandler, PrefixResolver, NodeConsumer
{


  static {
      Function func = new org.apache.xalan.templates.FuncDocument();

      FunctionTable.installFunction(""document"", func);

      
      
      func = new org.apache.xalan.templates.FuncFormatNumb();

      FunctionTable.installFunction(""format-number"", func);

  }
  
  public StylesheetHandler(TransformerFactoryImpl processor)
          throws TransformerConfigurationException
  {

    
    init(processor);
  }

  
  void init(TransformerFactoryImpl processor)
  {
    m_stylesheetProcessor = processor;

    
    m_processors.push(m_schema.getElementProcessor());
    this.pushNewNamespaceSupport();

    
    
  }

  
  public XPath createXPath(String str, ElemTemplateElement owningTemplate)
          throws javax.xml.transform.TransformerException
  {
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();
    XPath xpath = new XPath(str, owningTemplate, this, XPath.SELECT, handler);
    
    xpath.callVisitors(xpath, new ExpressionVisitor(getStylesheetRoot()));
    return xpath;
  }

  
  XPath createMatchPatternXPath(String str, ElemTemplateElement owningTemplate)
          throws javax.xml.transform.TransformerException
  {
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();
    XPath xpath = new XPath(str, owningTemplate, this, XPath.MATCH, handler);
    
    xpath.callVisitors(xpath, new ExpressionVisitor(getStylesheetRoot()));
    return xpath;    
  }

  
  public String getNamespaceForPrefix(String prefix)
  {
    return this.getNamespaceSupport().getURI(prefix);
  }

  
  public String getNamespaceForPrefix(String prefix, org.w3c.dom.Node context)
  {

    
    
    assertion(true, ""can't process a context node in StylesheetHandler!"");

    return null;
  }

  
  private boolean stackContains(Stack stack, String url)
  {

    int n = stack.size();
    boolean contains = false;

    for (int i = 0; i < n; i++)
    {
      String url2 = (String) stack.elementAt(i);

      if (url2.equals(url))
      {
        contains = true;

        break;
      }
    }

    return contains;
  }

  
  
  

  
  public Templates getTemplates()
  {
    return getStylesheetRoot();
  }

  
  public void setSystemId(String baseID)
  {
    pushBaseIndentifier(baseID);
  }

  
  public String getSystemId()
  {
    return this.getBaseIdentifier();
  }

  
  
  

  
  public InputSource resolveEntity(String publicId, String systemId)
          throws org.xml.sax.SAXException
  {
    return getCurrentProcessor().resolveEntity(this, publicId, systemId);
  }

  
  
  

  
  public void notationDecl(String name, String publicId, String systemId)
  {
    getCurrentProcessor().notationDecl(this, name, publicId, systemId);
  }

  
  public void unparsedEntityDecl(String name, String publicId,
                                 String systemId, String notationName)
  {
    getCurrentProcessor().unparsedEntityDecl(this, name, publicId, systemId,
                                             notationName);
  }

  
  XSLTElementProcessor getProcessorFor(
          String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    XSLTElementProcessor currentProcessor = getCurrentProcessor();
    XSLTElementDef def = currentProcessor.getElemDef();
    XSLTElementProcessor elemProcessor = def.getProcessorFor(uri, localName);

    if (null == elemProcessor
            && ((null == getStylesheet()
                || Double.valueOf(getStylesheet().getVersion()).doubleValue()
                   > Constants.XSLTVERSUPPORTED) 
                ||(!uri.equals(Constants.S_XSLNAMESPACEURL) &&
                            currentProcessor instanceof ProcessorStylesheetElement)
                || getElemVersion() > Constants.XSLTVERSUPPORTED
        ))
    {
      elemProcessor = def.getProcessorForUnknown(uri, localName);
    }

    if (null == elemProcessor)
      error(XSLMessages.createMessage(XSLTErrorResources.ER_NOT_ALLOWED_IN_POSITION, new Object[]{rawName}),null);
            
                
    return elemProcessor;
  }

  
  
  

  
  public void setDocumentLocator(Locator locator)
  {

    
    m_stylesheetLocatorStack.push(new SAXSourceLocator(locator));
  }

  
  private int m_stylesheetLevel = -1;

  
  public void startDocument() throws org.xml.sax.SAXException
  {
    m_stylesheetLevel++;
    pushSpaceHandling(false);
  }

  
  private boolean m_parsingComplete = false;

  
  public boolean isStylesheetParsingComplete()
  {
    return m_parsingComplete;
  }

  
  public void endDocument() throws org.xml.sax.SAXException
  {

    try
    {
      if (null != getStylesheetRoot())
      {
        if (0 == m_stylesheetLevel)
          getStylesheetRoot().recompose();        
      }
      else
        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_STYLESHEETROOT, null)); 

      XSLTElementProcessor elemProcessor = getCurrentProcessor();

      if (null != elemProcessor)
        elemProcessor.startNonText(this);

      m_stylesheetLevel--;			
      
      popSpaceHandling();

      
      
      
      
      
      m_parsingComplete = (m_stylesheetLevel < 0);
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }
  
  private java.util.Vector m_prefixMappings = new java.util.Vector();

  
  public void startPrefixMapping(String prefix, String uri)
          throws org.xml.sax.SAXException
  {

    
    
    
    
    m_prefixMappings.addElement(prefix); 
    m_prefixMappings.addElement(uri); 
  }

  
  public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException
  {

    
  }

  
  private void flushCharacters() throws org.xml.sax.SAXException
  {

    XSLTElementProcessor elemProcessor = getCurrentProcessor();

    if (null != elemProcessor)
      elemProcessor.startNonText(this);
  }

  
  public void startElement(
          String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {
    NamespaceSupport nssupport = this.getNamespaceSupport();
    nssupport.pushContext();
    
    int n = m_prefixMappings.size();

    for (int i = 0; i < n; i++) 
    {
      String prefix = (String)m_prefixMappings.elementAt(i++);
      String nsURI = (String)m_prefixMappings.elementAt(i);
      nssupport.declarePrefix(prefix, nsURI);
    }
    
    m_prefixMappings.removeAllElements(); 

    m_elementID++;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    checkForFragmentID(attributes);

    if (!m_shouldProcess)
      return;

    flushCharacters();
    
    pushSpaceHandling(attributes);

    XSLTElementProcessor elemProcessor = getProcessorFor(uri, localName,
                                           rawName);

    if(null != elemProcessor)  
    {
      this.pushProcessor(elemProcessor);
      elemProcessor.startElement(this, uri, localName, rawName, attributes);
    }
    else
    {
      m_shouldProcess = false;
      popSpaceHandling();
    }
                
  }

  
  public void endElement(String uri, String localName, String rawName)
          throws org.xml.sax.SAXException
  {

    m_elementID--;

    if (!m_shouldProcess)
      return;

    if ((m_elementID + 1) == m_fragmentID)
      m_shouldProcess = false;

    flushCharacters();
    
    popSpaceHandling();

    XSLTElementProcessor p = getCurrentProcessor();

    p.endElement(this, uri, localName, rawName);
    this.popProcessor();
    this.getNamespaceSupport().popContext();
  }

  
  public void characters(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    if (!m_shouldProcess)
      return;

    XSLTElementProcessor elemProcessor = getCurrentProcessor();
    XSLTElementDef def = elemProcessor.getElemDef();

    if (def.getType() != XSLTElementDef.T_PCDATA)
      elemProcessor = def.getProcessorFor(null, ""text()"");

    if (null == elemProcessor)
    {

      
      if (!XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
        error(
          XSLMessages.createMessage(XSLTErrorResources.ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION, null),null);
          
    }
    else
      elemProcessor.characters(this, ch, start, length);
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    if (!m_shouldProcess)
      return;

    getCurrentProcessor().ignorableWhitespace(this, ch, start, length);
  }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {
    if (!m_shouldProcess)
      return;

    
    
    
    
    
    
    
    
    
    String prefix="""",ns="""", localName=target;
    int colon=target.indexOf(':');
    if(colon>=0)
    {
      ns=getNamespaceForPrefix(prefix=target.substring(0,colon));
      localName=target.substring(colon+1);
    }

    try
    {
      
      
      
      
      
      
      
      if(
	 ""xalan:doc-cache-off"".equals(target) ||
	   (""doc-cache-off"".equals(localName) &&
	    ns.equals(""org.apache.xalan.xslt.extensions.Redirect"") )
	 )
      {
	if(!(m_elems.peek() instanceof ElemForEach))
          throw new TransformerException
	    (""xalan:doc-cache-off not allowed here!"", 
	     getLocator());
        ElemForEach elem = (ElemForEach)m_elems.peek();

        elem.m_doc_cache_off = true;

	
      }
    }
    catch(Exception e)
    {
      
      
    }


    flushCharacters();
    getCurrentProcessor().processingInstruction(this, target, data);
  }

  
  public void skippedEntity(String name) throws org.xml.sax.SAXException
  {

    if (!m_shouldProcess)
      return;

    getCurrentProcessor().skippedEntity(this, name);
  }

  
  public void warn(String msg, Object args[]) throws org.xml.sax.SAXException
  {

    String formattedMsg = XSLMessages.createWarning(msg, args);
    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();

    try
    {
      if (null != handler)
        handler.warning(new TransformerException(formattedMsg, locator));
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  private void assertion(boolean condition, String msg) throws RuntimeException
  {
    if (!condition)
      throw new RuntimeException(msg);
  }

  
  protected void error(String msg, Exception e)
          throws org.xml.sax.SAXException
  {

    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();
    TransformerException pe;

    if (!(e instanceof TransformerException))
    {
      pe = (null == e)
           ? new TransformerException(msg, locator)
           : new TransformerException(msg, locator, e);
    }
    else
      pe = (TransformerException) e;

    if (null != handler)
    {
      try
      {
        handler.error(pe);
      }
      catch (TransformerException te)
      {
        throw new org.xml.sax.SAXException(te);
      }
    }
    else
      throw new org.xml.sax.SAXException(pe);
  }

  
  protected void error(String msg, Object args[], Exception e)
          throws org.xml.sax.SAXException
  {

    String formattedMsg = XSLMessages.createMessage(msg, args);

    error(formattedMsg, e);
  }

  
  public void warning(org.xml.sax.SAXParseException e)
          throws org.xml.sax.SAXException
  {

    String formattedMsg = e.getMessage();
    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();

    try
    {
      handler.warning(new TransformerException(formattedMsg, locator));
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  public void error(org.xml.sax.SAXParseException e)
          throws org.xml.sax.SAXException
  {

    String formattedMsg = e.getMessage();
    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();

    try
    {
      handler.error(new TransformerException(formattedMsg, locator));
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  public void fatalError(org.xml.sax.SAXParseException e)
          throws org.xml.sax.SAXException
  {

    String formattedMsg = e.getMessage();
    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();

    try
    {
      handler.fatalError(new TransformerException(formattedMsg, locator));
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  private boolean m_shouldProcess = true;

  
  private String m_fragmentIDString;

  
  private int m_elementID = 0;

  
  private int m_fragmentID = 0;

  
  private void checkForFragmentID(Attributes attributes)
  {

    if (!m_shouldProcess)
    {
      if ((null != attributes) && (null != m_fragmentIDString))
      {
        int n = attributes.getLength();

        for (int i = 0; i < n; i++)
        {
          String name = attributes.getQName(i);

          if (name.equals(Constants.ATTRNAME_ID))
          {
            String val = attributes.getValue(i);

            if (val.equalsIgnoreCase(m_fragmentIDString))
            {
              m_shouldProcess = true;
              m_fragmentID = m_elementID;
            }
          }
        }
      }
    }
  }

  
  private TransformerFactoryImpl m_stylesheetProcessor;

  
  TransformerFactoryImpl getStylesheetProcessor()
  {
    return m_stylesheetProcessor;
  }

  
  static final int STYPE_ROOT = 1;

  
  static final int STYPE_INCLUDE = 2;

  
  static final int STYPE_IMPORT = 3;

  
  private int m_stylesheetType = STYPE_ROOT;

  
  int getStylesheetType()
  {
    return m_stylesheetType;
  }

  
  void setStylesheetType(int type)
  {
    m_stylesheetType = type;
  }

  
  private Stack m_stylesheets = new Stack();

  
  Stylesheet getStylesheet()
  {
    return (m_stylesheets.size() == 0)
           ? null : (Stylesheet) m_stylesheets.peek();
  }

  
  Stylesheet getLastPoppedStylesheet()
  {
    return m_lastPoppedStylesheet;
  }

  
  public StylesheetRoot getStylesheetRoot()
  {
    return m_stylesheetRoot;
  }

  
  StylesheetRoot m_stylesheetRoot;
        
        
  Stylesheet m_lastPoppedStylesheet;

  
  public void pushStylesheet(Stylesheet s)
  {

    if (m_stylesheets.size() == 0)
      m_stylesheetRoot = (StylesheetRoot) s;

    m_stylesheets.push(s);
  }

  
  Stylesheet popStylesheet()
  {

    
    
    
    if (!m_stylesheetLocatorStack.isEmpty())
      m_stylesheetLocatorStack.pop();

    if (!m_stylesheets.isEmpty())
      m_lastPoppedStylesheet = (Stylesheet) m_stylesheets.pop();

    
    return m_lastPoppedStylesheet;
  }

  
  private Stack m_processors = new Stack();

  
  XSLTElementProcessor getCurrentProcessor()
  {
    return (XSLTElementProcessor) m_processors.peek();
  }

  
  void pushProcessor(XSLTElementProcessor processor)
  {
    m_processors.push(processor);
  }

  
  XSLTElementProcessor popProcessor()
  {
    return (XSLTElementProcessor) m_processors.pop();
  }

  
  private XSLTSchema m_schema = new XSLTSchema();

  
  XSLTSchema getSchema()
  {
    return m_schema;
  }

  
  private Stack m_elems = new Stack();

  
  ElemTemplateElement getElemTemplateElement()
  {

    try
    {
      return (ElemTemplateElement) m_elems.peek();
    }
    catch (java.util.EmptyStackException ese)
    {
      return null;
    }
  }  

  
  private int m_docOrderCount = 0;

  
  int nextUid()
  {
    return m_docOrderCount++;
  }

  
  void pushElemTemplateElement(ElemTemplateElement elem)
  {

    if (elem.getUid() == -1)
      elem.setUid(nextUid());

    m_elems.push(elem);
  }

  
  ElemTemplateElement popElemTemplateElement()
  {
    return (ElemTemplateElement) m_elems.pop();
  }

  
  Stack m_baseIdentifiers = new Stack();

  
  void pushBaseIndentifier(String baseID)
  {

    if (null != baseID)
    {
      int posOfHash = baseID.indexOf('#');

      if (posOfHash > -1)
      {
        m_fragmentIDString = baseID.substring(posOfHash + 1);
        m_shouldProcess = false;
      }
      else
        m_shouldProcess = true;
    }
    else
      m_shouldProcess = true;

    m_baseIdentifiers.push(baseID);
  }

  
  String popBaseIndentifier()
  {
    return (String) m_baseIdentifiers.pop();
  }

  
  public String getBaseIdentifier()
  {

    
    
    
    String base = (String) (m_baseIdentifiers.isEmpty()
                            ? null : m_baseIdentifiers.peek());

    
    if (null == base)
    {
      SourceLocator locator = getLocator();

      base = (null == locator) ? """" : locator.getSystemId();
    }

    return base;
  }

  
  private Stack m_stylesheetLocatorStack = new Stack();

  
  public SAXSourceLocator getLocator()
  {

    if (m_stylesheetLocatorStack.isEmpty())
    {
      SAXSourceLocator locator = new SAXSourceLocator();

      locator.setSystemId(this.getStylesheetProcessor().getDOMsystemID());

      return locator;

      
    }

    return ((SAXSourceLocator) m_stylesheetLocatorStack.peek());
  }

  
  private Stack m_importStack = new Stack();

  
  void pushImportURL(String hrefUrl)
  {
    m_importStack.push(hrefUrl);
  }

  
  boolean importStackContains(String hrefUrl)
  {
    return stackContains(m_importStack, hrefUrl);
  }

  
  String popImportURL()
  {
    return (String) m_importStack.pop();
  }

  
  private boolean warnedAboutOldXSLTNamespace = false;

  
  Stack m_nsSupportStack = new Stack();

  
  void pushNewNamespaceSupport()
  {
    m_nsSupportStack.push(new NamespaceSupport2());
  }

  
  void popNamespaceSupport()
  {
    m_nsSupportStack.pop();
  }

  
  NamespaceSupport getNamespaceSupport()
  {
    return (NamespaceSupport) m_nsSupportStack.peek();
  }

  
  private Node m_originatingNode;

  
  public void setOriginatingNode(Node n)
  {
    m_originatingNode = n;
  }

  
  public Node getOriginatingNode()
  {
    return m_originatingNode;
  }
  
  
  private BoolStack m_spacePreserveStack = new BoolStack();
  
  
  boolean isSpacePreserve()
  {
    return m_spacePreserveStack.peek();
  }
  
  
  void popSpaceHandling()
  {
    m_spacePreserveStack.pop();
  }
  
  
  void pushSpaceHandling(boolean b)
    throws org.xml.sax.SAXParseException
  {
    m_spacePreserveStack.push(b);
  }
  
  
  void pushSpaceHandling(Attributes attrs)
    throws org.xml.sax.SAXParseException
  {    
    String value = attrs.getValue(""xml:space"");
    if(null == value)
    {
      m_spacePreserveStack.push(m_spacePreserveStack.peekOrFalse());
    }
    else if(value.equals(""preserve""))
    {
      m_spacePreserveStack.push(true);
    }
    else if(value.equals(""default""))
    {
      m_spacePreserveStack.push(false);
    }
    else
    {
      SAXSourceLocator locator = getLocator();
      ErrorListener handler = m_stylesheetProcessor.getErrorListener();
  
      try
      {
        handler.error(new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_ILLEGAL_XMLSPACE_VALUE, null), locator)); 
      }
      catch (TransformerException te)
      {
        throw new org.xml.sax.SAXParseException(te.getMessage(), locator, te);
      }
      m_spacePreserveStack.push(m_spacePreserveStack.peek());
    }
  }
  
  private double getElemVersion()
  {
    ElemTemplateElement elem = getElemTemplateElement();
    double version = -1; 
    while ((version == -1 || version == Constants.XSLTVERSUPPORTED) && elem != null)
    {
      try{
      version = Double.valueOf(elem.getVersion()).doubleValue();
      }
      catch (Exception ex)
      {
        version = -1;
      }
      elem = elem.getParentElem();
      }
    return (version == -1)? Constants.XSLTVERSUPPORTED : version;
  }
	
	public boolean handlesNullPrefixes() {
		return false;
	}

}



"
org.apache.xalan.xsltc.dom.DocumentCache,10,1,0,7,52,17,1,7,4,0.654320988,402,1.0,1,0.0,0.2875,0,0,38.3,7,2.0,1,"

package org.apache.xalan.xsltc.dom;

import java.io.File;
import java.io.PrintWriter;
import java.net.URL;
import java.net.URLConnection;
import java.net.URLDecoder;
import java.util.Date;
import java.util.Hashtable;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.sax.SAXSource;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.DOMCache;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xalan.xsltc.runtime.Constants;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

public final class DocumentCache implements DOMCache {

    private int       _size;
    private Hashtable _references;
    private String[]  _URIs;
    private int       _count;
    private int       _current;
    private SAXParser _parser;
    private XMLReader _reader;
    private XSLTCDTMManager _dtmManager;

    private static final int REFRESH_INTERVAL = 1000;

    
    public final class CachedDocument {
	
	
	private long _firstReferenced;
	private long _lastReferenced;
	private long _accessCount;
	private long _lastModified;
	private long _lastChecked;
	private long _buildTime;

	
	private SAXImpl    _dom = null;
	
	
	public CachedDocument(String uri) {
	    
	    final long stamp = System.currentTimeMillis();
	    _firstReferenced = stamp;
	    _lastReferenced  = stamp;
	    _accessCount     = 0;
	    loadDocument(uri);

	    _buildTime = System.currentTimeMillis() - stamp;
	}

	
	public void loadDocument(String uri) {

	    try {
		final long stamp = System.currentTimeMillis();
                _dom = (SAXImpl)_dtmManager.getDTM(
                                 new SAXSource(_reader, new InputSource(uri)),
                                 false, null, true, false);
		_dom.setDocumentURI(uri);

		
		
		final long thisTime = System.currentTimeMillis() - stamp;
		if (_buildTime > 0)
		    _buildTime = (_buildTime + thisTime) >>> 1;
		else
		    _buildTime = thisTime;
	    }
	    catch (Exception e) {
		_dom = null;
	    }
	}

	public DOM getDocument()       { return(_dom); }

	public long getFirstReferenced()   { return(_firstReferenced); }

	public long getLastReferenced()    { return(_lastReferenced); }

	public long getAccessCount()       { return(_accessCount); }

	public void incAccessCount()       { _accessCount++; }

	public long getLastModified()      { return(_lastModified); }

	public void setLastModified(long t){ _lastModified = t; }

	public long getLatency()           { return(_buildTime); }

	public long getLastChecked()       { return(_lastChecked); }
	
	public void setLastChecked(long t) { _lastChecked = t; }

	public long getEstimatedSize() {
	    if (_dom != null)
		return(_dom.getSize() << 5); 
	    else
		return(0);
	}

    }

    
    public DocumentCache(int size) throws SAXException {
        this(size, null);
        _dtmManager = XSLTCDTMManager.newInstance();
    }

    
    public DocumentCache(int size, XSLTCDTMManager dtmManager) throws SAXException {
	_dtmManager = dtmManager;
	_count = 0;
	_current = 0;
	_size  = size;
	_references = new Hashtable(_size+2);
	_URIs = new String[_size];

	try {
	    
	    final SAXParserFactory factory = SAXParserFactory.newInstance();
	    try {
		factory.setFeature(Constants.NAMESPACE_FEATURE,true);
	    }
	    catch (Exception e) {
		factory.setNamespaceAware(true);
	    }
	    _parser = factory.newSAXParser();
	    _reader = _parser.getXMLReader();
	}
	catch (ParserConfigurationException e) {
	    BasisLibrary.runTimeError(BasisLibrary.NAMESPACES_SUPPORT_ERR);
	    System.exit(-1);
	}
    }

    
    private final long getLastModified(String uri) {
	try {
	    URL url = new URL(uri);
	    URLConnection connection = url.openConnection();
	    long timestamp = connection.getLastModified();
	    
	    if (timestamp == 0){ 
	        if (""file"".equals(url.getProtocol())){
	            File localfile = new File(URLDecoder.decode(url.getFile()));
	            timestamp = localfile.lastModified();
	        }
	    }
	    return(timestamp);
	}
	
	catch (Exception e) {
	    return(System.currentTimeMillis());
	}
    }

    
    private CachedDocument lookupDocument(String uri) {
	return((CachedDocument)_references.get(uri));
    }

    
    private synchronized void insertDocument(String uri, CachedDocument doc) {
	if (_count < _size) {
	    
	    _URIs[_count++] = uri;
	    _current = 0;
	}
	else {
	    
	    _references.remove(_URIs[_current]);
	    
	    _URIs[_current] = uri;
	    if (++_current >= _size) _current = 0;
	}
	_references.put(uri, doc);
    }

    
    private synchronized void replaceDocument(String uri, CachedDocument doc) {
	CachedDocument old = (CachedDocument)_references.get(uri);
	if (doc == null)
	    insertDocument(uri, doc);
	else
	    _references.put(uri, doc);
    }

    
    public final DOM retrieveDocument(String uri, int mask, Translet trs) {
	CachedDocument doc;

	
	if ((doc = lookupDocument(uri)) == null) {
	    doc = new CachedDocument(uri);
	    if (doc == null) return null; 
	    doc.setLastModified(getLastModified(uri));
	    insertDocument(uri, doc);
	}
	
	else {
	    long now = System.currentTimeMillis();
	    long chk = doc.getLastChecked();
	    doc.setLastChecked(now);
	    
	    if (now > (chk + REFRESH_INTERVAL)) {
		doc.setLastChecked(now);
		long last = getLastModified(uri);
		
		if (last > doc.getLastModified()) {
		    doc = new CachedDocument(uri);
		    if (doc == null) return null;
		    doc.setLastModified(getLastModified(uri));
		    replaceDocument(uri, doc);
		}
	    }
	    
	}

	
	final DOM dom = doc.getDocument();

	
	
	if (dom == null) return null;

	doc.incAccessCount(); 

	final AbstractTranslet translet = (AbstractTranslet)trs;

	
        
	translet.prepassDocument(dom);

	return(doc.getDocument());
    }

    
    public void getStatistics(PrintWriter out) {
	out.println(""<h2>DOM cache statistics</h2><center><table border=""2"">""+
		    ""<tr><td><b>Document URI</b></td>""+
		    ""<td><center><b>Build time</b></center></td>""+
		    ""<td><center><b>Access count</b></center></td>""+
		    ""<td><center><b>Last accessed</b></center></td>""+
		    ""<td><center><b>Last modified</b></center></td></tr>"");

	for (int i=0; i<_count; i++) {
	    CachedDocument doc = (CachedDocument)_references.get(_URIs[i]);
	    out.print(""<tr><td><a href=""""+_URIs[i]+"""">""+
		      ""<font size=-1>""+_URIs[i]+""</font></a></td>"");
	    out.print(""<td><center>""+doc.getLatency()+""ms</center></td>"");
	    out.print(""<td><center>""+doc.getAccessCount()+""</center></td>"");
	    out.print(""<td><center>""+(new Date(doc.getLastReferenced()))+
		      ""</center></td>"");
	    out.print(""<td><center>""+(new Date(doc.getLastModified()))+
		      ""</center></td>"");
	    out.println(""</tr>"");
	}

	out.println(""</table></center>"");
    }
}
"
org.apache.xml.dtm.DTMAxisIterator,12,1,0,78,12,66,78,0,12,1.090909091,13,0.0,0,0.0,0.416666667,0,0,0.0,1,1.0,0,"
package org.apache.xml.dtm;


public interface DTMAxisIterator extends Cloneable
{

  
  public static final int END = DTM.NULL;

  
  public int next();  
  

  
  public DTMAxisIterator reset();

  
  public int getLast();

  
  public int getPosition();

  
  public void setMark();

  
  public void gotoMark();

  
  public DTMAxisIterator setStartNode(int node);

  
  public int getStartNode();

  
  public boolean isReverse();

  
  public DTMAxisIterator cloneIterator();
  
  
  public void setRestartable(boolean isRestartable);

  
  public int getNodeByPosition(int position);
}
"
org.apache.xalan.lib.sql.QueryParameter,5,1,0,1,6,0,1,0,5,0.5,30,1.0,0,0.0,0.8,0,0,4.6,1,0.8,1,"

package org.apache.xalan.lib.sql;


public class QueryParameter         
{

  
  private String value;
  
  private String type;

  
  public QueryParameter( String v, String t )
  {
    value = v;
    type = t;
  }

  
  public String getValue( ) {
    return value;
  }

  
  public void setValue( String newValue ) {
    value = newValue;
  }

  
  public void setType( String newType ) {
    type = newType;
  }

  
  public String getType( ) {
    return type;
  }
}"
org.apache.xalan.xsltc.compiler.If,5,3,0,16,28,0,2,15,4,0.25,129,1.0,1,0.933333333,0.333333333,1,5,24.4,5,1.8,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.BooleanType;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class If extends Instruction {

    private Expression _test;
    private boolean    _ignore = false;

    
    public void display(int indent) {
	indent(indent);
	Util.println(""If"");
	indent(indent + IndentIncrement);
	System.out.print(""test "");
	Util.println(_test.toString());
	displayContents(indent + IndentIncrement);
    }

    
    public void parseContents(Parser parser) {
	
	_test = parser.parseExpression(this, ""test"", null);

        
        if (_test.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""test"");
	    return;
        }

	
	
	Object result = _test.evaluateAtCompileTime();
	if (result != null && result instanceof Boolean) {
	    _ignore = !((Boolean) result).booleanValue();
	}

	parseChildren(parser);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	if (_test.typeCheck(stable) instanceof BooleanType == false) {
	    _test = new CastExpr(_test, Type.Boolean);
	}
	
	if (!_ignore) {
	    typeCheckContents(stable);
	}
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	_test.translateDesynthesized(classGen, methodGen);
	
	final InstructionHandle truec = il.getEnd();
	if (!_ignore) {
	    translateContents(classGen, methodGen);
	}
	_test.backPatchFalseList(il.append(NOP));
	_test.backPatchTrueList(truec.getNext());
    }
}
"
org.apache.xalan.processor.WhitespaceInfoPaths,4,5,0,4,6,0,2,2,3,0.333333333,23,1.0,0,0.986486486,0.5,0,0,4.5,1,0.75,0,"
package org.apache.xalan.processor;

import java.util.Vector;

import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.WhiteSpaceInfo;

public class WhitespaceInfoPaths extends WhiteSpaceInfo
{
	
  
  private Vector m_elements;

  
  public void setElements(Vector elems)
  {
    m_elements = elems;
  }

  
  Vector getElements()
  {
    return m_elements;
  }
  
  public void clearElements()
  {
  	m_elements = null;
  }

 
  public WhitespaceInfoPaths(Stylesheet thisSheet)
  {
  	super(thisSheet);
  	setStylesheet(thisSheet);
  }


}

"
org.apache.xalan.xsltc.compiler.util.IntType,28,3,0,46,63,374,8,40,26,1.0,422,0.0,0,0.564516129,0.181547619,1,3,14.03571429,10,1.6786,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.BranchInstruction;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IFGE;
import org.apache.bcel.generic.IFGT;
import org.apache.bcel.generic.IFLE;
import org.apache.bcel.generic.IFLT;
import org.apache.bcel.generic.IF_ICMPGE;
import org.apache.bcel.generic.IF_ICMPGT;
import org.apache.bcel.generic.IF_ICMPLE;
import org.apache.bcel.generic.IF_ICMPLT;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionConstants;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.FlowList;

public final class IntType extends NumberType {
    protected IntType() {}

    public String toString() {
	return ""int"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""I"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.INT;
    }

    
    public int distanceTo(Type type) {
	if (type == this) {
	    return 0;
	}
	else if (type == Type.Real) {
	    return 1;
	}
	else
	    return Integer.MAX_VALUE;
    }
    
    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    final Type type) {
	if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	methodGen.getInstructionList().append(I2D);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKESTATIC(cpg.addMethodref(INTEGER_CLASS,
						    ""toString"",
						    ""(I)"" + STRING_SIG)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	final BranchHandle falsec = il.append(new IFEQ(null));
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsec.setTarget(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new NEW(cpg.addClass(INTEGER_CLASS)));
	il.append(DUP_X1);
	il.append(SWAP);
	il.append(new INVOKESPECIAL(cpg.addMethodref(INTEGER_CLASS,
						     ""<init>"", ""(I)V"")));
    }


    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	final InstructionList il = methodGen.getInstructionList();
	if (clazz == Character.TYPE) {
	    il.append(I2C);
	}
	else if (clazz == Byte.TYPE) {
	    il.append(I2B);
	}
	else if (clazz == Short.TYPE) {
	    il.append(I2S);
	}
	else if (clazz == Integer.TYPE) {
	    il.append(NOP);
	}
	else if (clazz == Long.TYPE) {
	    il.append(I2L);
	}
	else if (clazz == Float.TYPE) {
	    il.append(I2F);
	}
	else if (clazz == Double.TYPE) {
	    il.append(I2D);
	}
        else if (clazz.isAssignableFrom(java.lang.Integer.class)) {
            translateTo(classGen, methodGen, Type.Reference);   
        }
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new CHECKCAST(cpg.addClass(INTEGER_CLASS)));
	final int index = cpg.addMethodref(INTEGER_CLASS,
					   INT_VALUE, 
					   INT_VALUE_SIG);
	il.append(new INVOKEVIRTUAL(index));
    }

    public Instruction ADD() {
	return InstructionConstants.IADD;
    }

    public Instruction SUB() {
	return InstructionConstants.ISUB;
    }

    public Instruction MUL() {
	return InstructionConstants.IMUL;
    }

    public Instruction DIV() {
	return InstructionConstants.IDIV;
    }

    public Instruction REM() {
	return InstructionConstants.IREM;
    }

    public Instruction NEG() {
	return InstructionConstants.INEG;
    }

    public Instruction LOAD(int slot) {
	return new ILOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ISTORE(slot);
    }

    public BranchInstruction GT(boolean tozero) {
	return tozero ? (BranchInstruction) new IFGT(null) : 
	    (BranchInstruction) new IF_ICMPGT(null);
    }

    public BranchInstruction GE(boolean tozero) {
	return tozero ? (BranchInstruction) new IFGE(null) : 
	    (BranchInstruction) new IF_ICMPGE(null);
    }

    public BranchInstruction LT(boolean tozero) {
	return tozero ? (BranchInstruction) new IFLT(null) : 
	    (BranchInstruction) new IF_ICMPLT(null);
    }

    public BranchInstruction LE(boolean tozero) {
	return tozero ? (BranchInstruction) new IFLE(null) : 
	    (BranchInstruction) new IF_ICMPLE(null);
    }
}
"
org.apache.xalan.xsltc.compiler.util.NodeSetType,21,2,0,41,49,190,15,29,19,2.0,516,0.0,0,0.622641509,0.238095238,2,4,23.57142857,7,1.619,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFLT;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.FlowList;

public final class NodeSetType extends Type {
    protected NodeSetType() {}

    public String toString() {
	return ""node-set"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return NODE_ITERATOR_SIG;
    }

    public org.apache.bcel.generic.Type toJCType() {
	return new org.apache.bcel.generic.ObjectType(NODE_ITERATOR);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.Node) {
	    translateTo(classGen, methodGen, (NodeType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else if (type == Type.Object) {
	    translateTo(classGen, methodGen, (ObjectType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateFrom(ClassGenerator classGen, 
	MethodGenerator methodGen, Class clazz) 
    {
		
  	InstructionList il = methodGen.getInstructionList();
	ConstantPoolGen cpg = classGen.getConstantPool();
	if (clazz.getName().equals(""org.w3c.dom.NodeList"")) {
	   
	   
	   
	   il.append(classGen.loadTranslet());   
	   il.append(methodGen.loadDOM());   	 
	   final int convert = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					""nodeList2Iterator"",
					""(""		
					 + ""Lorg/w3c/dom/NodeList;""
					 + TRANSLET_INTF_SIG 
					 + DOM_INTF_SIG 
					 + "")"" + NODE_ITERATOR_SIG );
	   il.append(new INVOKESTATIC(convert));
	}
	else if (clazz.getName().equals(""org.w3c.dom.Node"")) {
	   
	   
	   
	   il.append(classGen.loadTranslet());   
	   il.append(methodGen.loadDOM());   	 
	   final int convert = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					""node2Iterator"",
					""(""		
					 + ""Lorg/w3c/dom/Node;""
					 + TRANSLET_INTF_SIG 
					 + DOM_INTF_SIG 
					 + "")"" + NODE_ITERATOR_SIG );
	   il.append(new INVOKESTATIC(convert));
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
		toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	} 
    }


    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	FlowList falsel = translateToDesynthesized(classGen, methodGen, type);
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsel.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final InstructionList il = methodGen.getInstructionList();
	getFirstNode(classGen, methodGen);
	il.append(DUP);
	final BranchHandle falsec = il.append(new IFLT(null));
	Type.Node.translateTo(classGen, methodGen, type);
	final BranchHandle truec = il.append(new GOTO(null));
	falsec.setTarget(il.append(POP));
	il.append(new PUSH(classGen.getConstantPool(), """"));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	translateTo(classGen, methodGen, Type.String);
	Type.String.translateTo(classGen, methodGen, Type.Real);	
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    NodeType type) {
	getFirstNode(classGen, methodGen);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ObjectType type) {
	    methodGen.getInstructionList().append(NOP);	
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	getFirstNode(classGen, methodGen);
	return new FlowList(il.append(new IFLT(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final String className = clazz.getName();

	il.append(methodGen.loadDOM());
	il.append(SWAP);

	if (className.equals(""org.w3c.dom.Node"")) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE,
						  MAKE_NODE_SIG2);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
        else if (className.equals(""org.w3c.dom.NodeList"") || 
                 className.equals(""java.lang.Object"")) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE_LIST,
						  MAKE_NODE_LIST_SIG2);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
        else if (className.equals(""java.lang.String"")) {
            int next = cpg.addInterfaceMethodref(NODE_ITERATOR,
                                                 ""next"", ""()I"");
            int index = cpg.addInterfaceMethodref(DOM_INTF,
                                                 GET_NODE_VALUE,
                                                 ""(I)""+STRING_SIG);

            
            il.append(new INVOKEINTERFACE(next, 1));
            
            il.append(new INVOKEINTERFACE(index, 2));
                       
        }
	else if (className.equals(""int"")) {
	    int next = cpg.addInterfaceMethodref(NODE_ITERATOR,
						  ""next"", ""()I"");
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  GET_NODE_VALUE,
						  ""(I)""+STRING_SIG);
	    int str = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					STRING_TO_INT,
					STRING_TO_INT_SIG);

	    
	    il.append(new INVOKEINTERFACE(next, 1));
	    
	    il.append(new INVOKEINTERFACE(index, 2));
	    
	    il.append(new INVOKESTATIC(str));
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), className);
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }
    
    
    private void getFirstNode(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKEINTERFACE(cpg.addInterfaceMethodref(NODE_ITERATOR,
								NEXT,
								NEXT_SIG), 1));
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public String getClassName() {
	return(NODE_ITERATOR);
    }


    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}
"
org.apache.xml.utils.res.XResources_ja_JP_A,3,4,0,1,4,1,0,1,2,0.5,599,0.0,0,0.976190476,1.0,0,0,198.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_ja_JP_A extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ja"" }, { ""help_language"", ""ja"" }, { ""language"", ""ja"" },
    { ""alphabet"",
      new char[]{ 0x30a2, 0x30a4, 0x30a6, 0x30a8, 0x30aa, 0x30ab, 0x30ad,
                  0x30af, 0x30b1, 0x30b3, 0x30b5, 0x30b7, 0x30b9, 0x30bb,
                  0x30bd, 0x30bf, 0x30c1, 0x30c4, 0x30c6, 0x30c8, 0x30ca,
                  0x30cb, 0x30cc, 0x30cd, 0x30ce, 0x30cf, 0x30d2, 0x30d5,
                  0x30d8, 0x30db, 0x30de, 0x30df, 0x30e0, 0x30e1, 0x30e2,
                  0x30e4, 0x30e6, 0x30e8, 0x30e9, 0x30ea, 0x30eb, 0x30ec,
                  0x30ed, 0x30ef, 0x30f0, 0x30f1, 0x30f2, 0x30f3 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    
    
    { ""multiplier"",
      new long[]{ Long.MAX_VALUE, Long.MAX_VALUE, 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4EAC, 0x5146, 0x5104, 0x4E07, 0x5343, 0x767e, 0x5341 } },

    
    { ""zero"", new char[0] },
    { ""digits"",
      new char[]{ 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03,
                  0x516B, 0x4E5D } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xml.utils.res.XResources_hy,3,4,0,1,4,1,0,1,2,0.5,614,0.0,0,0.976190476,1.0,0,0,203.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_hy extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""hy"" }, { ""help_language"", ""hy"" }, { ""language"", ""hy"" },
    { ""alphabet"",
      new char[]{ 0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567,
                  0x0568, 0x0569, 0x056A, 0x056B, 0x056C, 0x056D, 0x056E,
                  0x056F, 0x0567, 0x0568, 0x0572, 0x0573, 0x0574, 0x0575,
                  0x0576, 0x0577, 0x0578, 0x0579, 0x057A, 0x057B, 0x057C,
                  0x057D, 0x057E, 0x057F, 0x0580, 0x0581, 0x0582, 0x0583,
                  0x0584 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    { ""numberGroups"", new int[]{ 1000, 100, 10, 1 } },

    
    
    
    
    { ""digits"",
      new char[]{ 0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567,
                  0x0568, 0x0569 } },
    { ""tens"",
      new char[]{ 0x056A, 0x056B, 0x056C, 0x056D, 0x056E, 0x056F, 0x0567,
                  0x0568, 0x0572 } },
    { ""hundreds"",
      new char[]{ 0x0573, 0x0574, 0x0575, 0x0576, 0x0577, 0x0578, 0x0579,
                  0x057A, 0x057B } },
    { ""thousands"",
      new char[]{ 0x057C, 0x057D, 0x057E, 0x057F, 0x0580, 0x0581, 0x0582,
                  0x0583, 0x0584 } },
    { ""tables"", new String[]{ ""thousands"", ""hundreds"", ""tens"", ""digits"" } }
  };
}
"
org.apache.xalan.templates.ElemValueOf,11,3,0,16,41,15,3,14,10,0.7,228,1.0,1,0.951456311,0.233766234,2,6,19.45454545,4,1.2727,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xpath.Expression;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.xml.sax.SAXException;


public class ElemValueOf extends ElemTemplateElement
{

  
  private XPath m_selectExpression = null;

  
  private boolean m_isDot = false;

  
  public void setSelect(XPath v)
  {

    if (null != v)
    {
      String s = v.getPatternString();

      m_isDot = (null != s) && s.equals(""."");
    }

    m_selectExpression = v;
  }

  
  public XPath getSelect()
  {
    return m_selectExpression;
  }

  
  private boolean m_disableOutputEscaping = false;

  
  public void setDisableOutputEscaping(boolean v)
  {
    m_disableOutputEscaping = v;
  }

  
  public boolean getDisableOutputEscaping()
  {
    return m_disableOutputEscaping;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_VALUEOF;
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {

    super.compose(sroot);

    java.util.Vector vnames = sroot.getComposeState().getVariableNames();

    if (null != m_selectExpression)
      m_selectExpression.fixupVariables(
        vnames, sroot.getComposeState().getGlobalsSize());
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_VALUEOF_STRING;
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    XPathContext xctxt = transformer.getXPathContext();
    SerializationHandler rth = transformer.getResultTreeHandler();

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    try
    {
      
      if (false && m_isDot && !TransformerImpl.S_DEBUG)
      {
        int child = xctxt.getCurrentNode();
        DTM dtm = xctxt.getDTM(child);

        xctxt.pushCurrentNode(child);

        if (m_disableOutputEscaping)
          rth.processingInstruction(
            javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");

        try
        {
          dtm.dispatchCharactersEvents(child, rth, false);
        }
        finally
        {
          if (m_disableOutputEscaping)
            rth.processingInstruction(
              javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");

          xctxt.popCurrentNode();
        }
      }
      else
      {
        xctxt.pushNamespaceContext(this);

        int current = xctxt.getCurrentNode();

        xctxt.pushCurrentNodeAndExpression(current, current);

        if (m_disableOutputEscaping)
          rth.processingInstruction(
            javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");

        try
        {
          Expression expr = m_selectExpression.getExpression();

          if (TransformerImpl.S_DEBUG)
          {
            XObject obj = expr.execute(xctxt);

            transformer.getTraceManager().fireSelectedEvent(current, this,
                    ""select"", m_selectExpression, obj);
            obj.dispatchCharactersEvents(rth);
          }
          else
          {
            expr.executeCharsToContentHandler(xctxt, rth);
          }
        }
        finally
        {
          if (m_disableOutputEscaping)
            rth.processingInstruction(
              javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");

          xctxt.popNamespaceContext();
          xctxt.popCurrentNodeAndExpression();
        }
      }
    }
    catch (SAXException se)
    {
      throw new TransformerException(se);
    }
    catch (RuntimeException re) {
    	TransformerException te = new TransformerException(re);
    	te.setLocator(this);
    	throw te;
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
	    transformer.getTraceManager().fireTraceEndEvent(this); 
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  		m_selectExpression.getExpression().callVisitors(m_selectExpression, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xalan.xsltc.runtime.Parameter,2,1,0,2,3,0,2,0,2,0.0,29,0.0,0,0.0,0.875,0,0,12.0,0,0.0,0,"

package org.apache.xalan.xsltc.runtime;

public class Parameter {

    public String  _name;
    public Object  _value;
    public boolean _isDefault;

    public Parameter(String name, Object value) {
	_name = name;
	_value = value;
	_isDefault = true;
    }

    public Parameter(String name, Object value, boolean isDefault) {
	_name = name;
	_value = value;
	_isDefault = isDefault;
    }
}
"
org.apache.xalan.xsltc.compiler.FlowList,7,1,0,29,17,0,26,3,7,0.0,155,1.0,0,0.0,0.464285714,0,0,21.0,4,1.8571,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Iterator;
import java.util.Vector;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;

public final class FlowList {
    private Vector _elements;

    public FlowList() {
	_elements = null;
    }

    public FlowList(InstructionHandle bh) {
	_elements = new Vector();
	_elements.addElement(bh);
    }

    public FlowList(FlowList list) {
	_elements = list._elements;
    }

    public FlowList add(InstructionHandle bh) {
	if (_elements == null) {
	    _elements = new Vector();
	}
	_elements.addElement(bh);
	return this;
    }

    public FlowList append(FlowList right) {
	if (_elements == null) {
	    _elements = right._elements;
	}
	else {
	    final Vector temp = right._elements;
	    if (temp != null) {
		final int n = temp.size();
		for (int i = 0; i < n; i++) {
		    _elements.addElement(temp.elementAt(i));
		}
	    }
	}
	return this;
    }

    
    public void backPatch(InstructionHandle target) {
	if (_elements != null) {
	    final int n = _elements.size();
	    for (int i = 0; i < n; i++) {
		BranchHandle bh = (BranchHandle)_elements.elementAt(i);
		bh.setTarget(target);
	    }
	    _elements.clear();		
	}
    }

    
    public FlowList copyAndRedirect(InstructionList oldList, 
	InstructionList newList) 
    {
	final FlowList result = new FlowList();
	if (_elements == null) {
	    return result;
	}

	final int n = _elements.size();
	final Iterator oldIter = oldList.iterator();
	final Iterator newIter = newList.iterator();
	
	while (oldIter.hasNext()) {
	    final InstructionHandle oldIh = (InstructionHandle) oldIter.next();
	    final InstructionHandle newIh = (InstructionHandle) newIter.next();

	    for (int i = 0; i < n; i++) {
		if (_elements.elementAt(i) == oldIh) {
		    result.add(newIh);
		}
	    }
	}
	return result;
    }
}
"
org.apache.xalan.res.XSLTErrorResources_fr,3,4,0,1,4,1,0,1,2,1.423076923,3769,0.0,0,0.976190476,1.0,0,0,1251.0,1,0.3333,0,"
package org.apache.xalan.res;




public class XSLTErrorResources_fr extends XSLTErrorResources
{

   
   public static final int MAX_CODE = 201;

   
    public static final int MAX_WARNING = 29;

  
  public static final int MAX_OTHERS = 55;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  

  public static final Object[][] contents = {
  
  

  {
    ""ERROR0000"", ""{0}""},

  
  

  {
    ER_NO_CURLYBRACE,
      ""Erreur : L’expression ne peut pas contenir '{'""},

  
  

  {
    ER_ILLEGAL_ATTRIBUTE, ""{0} dispose d’un attribut non autorisé : {1}""},

  
  

  {
    ER_NULL_SOURCENODE_APPLYIMPORTS,
      ""sourceNode est vide dans xsl:apply-imports!""},

  
  

  {
    ER_CANNOT_ADD, ""Impossible d’ajouter {0} à {1}""},

  
  

  {
    ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES,
      ""sourceNode est vide dans handleApplyTemplatesInstruction!""},

  
  

  {
    ER_NO_NAME_ATTRIB, ""{0} doit disposer d’un attribut name.""},

  
  

  {
    ER_TEMPLATE_NOT_FOUND, ""Impossible de trouver le modèle : {0}""},

  
  

  {
    ER_CANT_RESOLVE_NAME_AVT,
      ""Impossible de résoudre le nom AVT dans xsl:call-template.""},

  
  

  {
    ER_REQUIRES_ATTRIB, ""{0} requiert l’attribut : {1}""},

  
  

  {
    ER_MUST_HAVE_TEST_ATTRIB,
      ""{0} doit disposer de l’attribut ''test''.""},

  
  

  {
    ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""Valeur incorrecte pour l’attribut level : {0}""},

  
  

  {
    ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""Le nom de processing-instruction ne peut pas être 'xml'""},

  
  

  {
    ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""Le nom de processing-instruction doit être un nom sans deux points correct : {0}""},

  
  

  {
    ER_NEED_MATCH_ATTRIB,
      ""{0} doit disposer d’un attribut conforme s’il a un mode.""},

  
  

  {
    ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0} requiert soit un nom soit un attribut conforme.""},

  
  

  {
    ER_CANT_RESOLVE_NSPREFIX,
      ""Impossible de résoudre le préfixe d'espace de noms : {0}""},

  
  

  {
    ER_ILLEGAL_VALUE, ""xml:space dispose d’une valeur non autorisée : {0}""},

  
  

  {
    ER_NO_OWNERDOC,
      ""Le nœud enfant ne dispose pas d’un document propriétaire !""},

  
  

  {
    ER_ELEMTEMPLATEELEM_ERR, ""Erreur ElemTemplateElement : {0}""},

  
  

  {
    ER_NULL_CHILD, ""Tentative d’ajout d’un enfant vide !""},

  
  

  {
    ER_NEED_SELECT_ATTRIB, ""{0} requiert un attribut select.""},

  
  

  {
    ER_NEED_TEST_ATTRIB,
      ""xsl:when doit disposer d’un attribut 'test'.""},

  
  

  {
    ER_NEED_NAME_ATTRIB,
      ""xsl:with-param doit disposer d’un attribut 'name'.""},

  
  

  {
    ER_NO_CONTEXT_OWNERDOC,
      ""Le contexte ne dispose pas d’un document propriétaire !""},

  
  

  {
    ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""Impossible de créer XML TransformerFactory Liaison : {0}""},

  
  

  {
    ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: échec du traitement.""},

  
  

  {
    ER_NOT_SUCCESSFUL, ""Xalan: échec.""},

  
  

  {
    ER_ENCODING_NOT_SUPPORTED, ""Encodage non pris en charge : {0}""},

  
  

  {
    ER_COULD_NOT_CREATE_TRACELISTENER,
      ""Impossible de créer TraceListener : {0}""},

  
  

  {
    ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key requiert un attribut 'name' !""},

  
  

  {
    ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key requiert un attribut 'match' !""},

  
  

  {
    ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key requiert un attribut 'use' !""},

  
  

  {
    ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0} requiert un attribut ''elements'' !""},

  
  

  {
    ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} attribut ''prefix'' manquant""},

  
  

  {
    ER_BAD_STYLESHEET_URL, ""L’URL de la feuille de style n’est pas correct : {0}""},

  
  

  {
    ER_FILE_NOT_FOUND, ""Le fichier de feuille de style est introuvable : {0}""},

  
  

  {
    ER_IOEXCEPTION,
      ""Exception d’E/S avec le fichier de feuille de style : {0}""},

  
  

  {
    ER_NO_HREF_ATTRIB,
      ""(StylesheetHandler) Impossible de trouver l’attribut href pour {0}""},

  
  

  {
    ER_STYLESHEET_INCLUDES_ITSELF,
      ""(StylesheetHandler) {0} est directement ou indirectement inclus dans lui-même !""},

  
  

  {
    ER_PROCESSINCLUDE_ERROR,
      ""Erreur StylesheetHandler.processInclude, {0}""},

  
  

  {
    ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} attribut ''lang'' manquant""},

  
  

  {
    ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) élément {0} mal placé ?? Elément ''component'' de container manquant""},

  
  

  {
    ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
      ""Sortie possible uniquement vers Element, DocumentFragment, Document ou PrintWriter.""},

  
  

  {
    ER_PROCESS_ERROR, ""Erreur StylesheetRoot.process""},

  
  

  {
    ER_UNIMPLNODE_ERROR, ""Erreur UnImplNode : {0}""},

  
  

  {
    ER_NO_SELECT_EXPRESSION,
      ""Erreur ! Impossible de trouver l’expression de sélection xpath (-select).""},

  
  

  {
    ER_CANNOT_SERIALIZE_XSLPROCESSOR,
      ""Impossible de mettre en série un processeur XSL !""},

  
  

  {
    ER_NO_INPUT_STYLESHEET,
      ""Entrée de la feuille de style non spécifiée !""},

  
  

  {
    ER_FAILED_PROCESS_STYLESHEET,
      ""Echec de traitement de la feuille de style !""},

  
  

  {
    ER_COULDNT_PARSE_DOC, ""Impossible d’analyser le document {0} !""},

  
  

  {
    ER_COULDNT_FIND_FRAGMENT, ""Impossible de trouver le fragment : {0}""},

  
  

  {
    ER_NODE_NOT_ELEMENT,
      ""Le nœud identifié par l’identificateur de fragments n’est pas un élement : {0}""},

  
  

  {
    ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""for-each doit disposer d’un attribut match ou name""},

  
  

  {
    ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB,
      ""templates doit disposer d’un attribut match ou name""},

  
  

  {
    ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""Impossible de cloner un fragment de document !""},

  
  

  {
    ER_CANT_CREATE_ITEM,
      ""Impossible de créer un objet dans l’arbre de résultats : {0}""},

  
  

  {
    ER_XMLSPACE_ILLEGAL_VALUE,
      ""xml:space dispose d’une valeur non autorisée dans la source XML : {0}""},

  
  

  {
    ER_NO_XSLKEY_DECLARATION,
      ""Il n’existe pas de déclaration xsl:key pour for {0} !""},

  
  

  {
    ER_CANT_CREATE_URL, ""Erreur! Impossible de créer une url pour : {0}""},

  
  

  {
    ER_XSLFUNCTIONS_UNSUPPORTED, ""xsl:functions n’est pas pris en charge""},

  
  

  {
    ER_PROCESSOR_ERROR, ""Erreur XSLT TransformerFactory""},

  
  

  {
    ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""(StylesheetHandler) {0} non autorisé dans une feuille de style !""},

  
  

  {
    ER_RESULTNS_NOT_SUPPORTED,
      ""result-ns n’est plus pris en charge ! Utilisez xsl:output à la place.""},

  
  

  {
    ER_DEFAULTSPACE_NOT_SUPPORTED,
      ""default-space n’est plus pris en charge ! Utilisez xsl:strip-space ou xsl:preserve-space à la place.""},

  
  

  {
    ER_INDENTRESULT_NOT_SUPPORTED,
      ""indent-result n’est plus pris en charge ! Utilisez xsl:output à la place.""},

  
  

  {
    ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0} dispose d’un attribut non autorisé : {1}""},

  
  

  {
    ER_UNKNOWN_XSL_ELEM, ""Elément XSL inconnu : {0}""},

  
  

  {
    ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort ne peut être utilisé qu’avec xsl:apply-templates ou xsl:for-each.""},

  
  

  {
    ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) xsl:when mal placé !""},

  
  

  {
    ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:choose n’est pas parent de xsl:when !""},

  
  

  {
    ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) xsl:otherwise mal placé !""},

  
  

  {
    ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:choose n’est pas parent de xsl:otherwise !""},

  
  

  {
    ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""(StylesheetHandler) {0} n’est pas admis dans un modèle !""},

  
  

  {
    ER_UNKNOWN_EXT_NS_PREFIX,
      ""(StylesheetHandler) {0} préfixe de l’espace de noms de l’extension {1} inconnu""},

  
  

  {
    ER_IMPORTS_AS_FIRST_ELEM,
      ""(StylesheetHandler) Les importations ne peuvent intervenir qu’en tant que premiers éléments de la feuille de style !""},

  
  

  {
    ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0} est en train de s’importer directement ou indirectement !""},

  
  

  {
    ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space dispose d’une valeur non autorisée : {0}""},

  
  

  {
    ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""Echec de processStylesheet !""},

  
  

  {
    ER_SAX_EXCEPTION, ""Exception SAX""},

  
  

  {
    ER_XSLT_ERROR, ""Erreur XSLT""},

  
  

  {
    ER_CURRENCY_SIGN_ILLEGAL,
      ""Le symbole d’une devise n’est pas admise dans une chaîne conforme au modèle""},

  
  

  {
    ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""La fonction Document n’est pas prise en charge dans la feuille de style DOM !""},

  
  

  {
    ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""Impossible de résoudre le préfixe d’un résolveur sans préfixe !""},

  
  

  {
    ER_REDIRECT_COULDNT_GET_FILENAME,
      ""Redirect extension : impossible de récupérer le nom de fichier – l’attribut file ou select doit retourner une chaîne valide.""},

  
  

  {
    ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""Impossible de créer FormatterListener dans Redirect extension !""},

  
  

  {
    ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""Le préfixe dans exclude-result-prefixes n’est pas valide : {0}""},

  
  

  {
    ER_MISSING_NS_URI,
      ""URI d’espace de noms manquant pour le préfixe spécifié""},

  
  

  {
    ER_MISSING_ARG_FOR_OPTION,
      ""Argument manquant pour l’option : {0}""},

  
  

  {
    ER_INVALID_OPTION, ""Option incorrecte : {0}""},

  
  

  {
    ER_MALFORMED_FORMAT_STRING, ""Chaîne de format mal formée : {0}""},

  
  

  {
    ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet requiert un attribut 'version' !""},

  
  

  {
    ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""L’attribut : {0} dispose d’une valeur non autorisée : {1}""},

  
  

  {
    ER_CHOOSE_REQUIRES_WHEN, ""xsl:choose requiert un xsl:when""},

  
  

  {
    ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""xsl:apply-imports n’est pas admis dans un xsl:for-each""},

  
  

  {
    ER_CANT_USE_DTM_FOR_OUTPUT,
      ""Impossible d'utiliser DTMLiaison pour un noeud de sortie DOM ... Utilisez org.apache.xpath.DOM2Helper à la place !""},

  
  

  {
    ER_CANT_USE_DTM_FOR_INPUT,
      ""Impossible d'utiliser DTMLiaison pour un noeud d'entrée DOM... Utilisez org.apache.xpath.DOM2Helper à la place!""},

  
  

  {
    ER_CALL_TO_EXT_FAILED,
      ""Echec de l’appel de l’élément d’extension : {0}""},

  
  

  {
    ER_PREFIX_MUST_RESOLVE,
      ""Le préfixe doit se résoudre en espace de nom : {0}""},

  
  

  {
    ER_INVALID_UTF16_SURROGATE,
      ""Substitut UTF-16 incorrect détecté : {0} ?""},

  
  

  {
    ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0} s’est utilisé lui-même, ce qui va entraîner une boucle sans fin.""},

  
  

  {
    ER_CANNOT_MIX_XERCESDOM,
      ""Impossible de mélanger des entrées non Xerces-DOM avec des sorties Xerces-DOM !""},

  
  

  {
    ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},

  
  

  {
    ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""Dans ElemTemplateElement.readObject : {0}""},

  
  

  {
    ER_DUPLICATE_NAMED_TEMPLATE,
      ""Plusieurs modèles trouvés nommés : {0}""},

  
  

  {
    ER_INVALID_KEY_CALL,
      ""Appel de fonction incorrect : les appels de recursive key() ne sont pas autorisés""},
  
  
  

  {
    ER_REFERENCING_ITSELF,
      ""La variable {0} est en train de se référencer directement ou indirectement !""},
  
  
  

  {
    ER_ILLEGAL_DOMSOURCE_INPUT,
      ""Le nœud d’entrée ne peut pas être vide au niveau d’une source DOM pour newTemplates !""},
	
	
  

  {
    ER_CLASS_NOT_FOUND_FOR_OPTION,
			""Fichier de classe introuvable pour l’option {0}""},
	
	
  

  {
    ER_REQUIRED_ELEM_NOT_FOUND,
			""Elément requis introuvable : {0}""},
  
  
  

  {
    ER_INPUT_CANNOT_BE_NULL,
			""InputStream ne peut pas être vide""},
  
  
  

  {
    ER_URI_CANNOT_BE_NULL,
			""URI ne peut pas être vide""},
  
  
  

  {
    ER_FILE_CANNOT_BE_NULL,
			""File ne peut pas être vide""},
  
   
  

  {
    ER_SOURCE_CANNOT_BE_NULL,
			""InputSource ne peut pas être vide""},
  
  
  

  {
    ER_CANNOT_INIT_BSFMGR,
			""Impossible d’initialiser BSF Manager""},
  
  
  

  {
    ER_CANNOT_CMPL_EXTENSN,
			""Impossible de compiler l’extension""},

  
  

  {
    ER_CANNOT_CREATE_EXTENSN,
      ""Impossible de créer l’extension : {0} à cause de : {1}""},
  
  
  

  {
    ER_INSTANCE_MTHD_CALL_REQUIRES,
      ""L’appel de la méthode d’instance à la méthode {0} requiert une instance Object comme premier argument""},
  
  
  

  {
    ER_INVALID_ELEMENT_NAME,
      ""Nom d’élément spécifié incorrect {0}""},
  
   
  

  {
    ER_ELEMENT_NAME_METHOD_STATIC,
      ""La méthode de nom d’élément doit être statique {0}""},
  
   
  

  {
    ER_EXTENSION_FUNC_UNKNOWN,
             ""Fonction d’extension {0} : {1} inconnue""},
  
   
  

  {
    ER_MORE_MATCH_CONSTRUCTOR,
             ""Plusieurs occurrences exactes pour le constructeur pour {0}""},
  
   
  

  {
    ER_MORE_MATCH_METHOD,
             ""Plusieurs occurrences exactes pour la méthode {0}""},
  
   
  

  {
    ER_MORE_MATCH_ELEMENT,
             "" Plusieurs occurrences exactes pour la méthode d’éléments {0}""},
  
   
  

  {
    ER_INVALID_CONTEXT_PASSED,
             ""Contexte incorrect pour l’évaluation {0}""},
  
   
  

  {
    ER_POOL_EXISTS,
             ""Pool existe déjà""},
  
   
  

  {
    ER_NO_DRIVER_NAME,
             ""Aucun nom de pilote spécifié""},
  
   
  

  {
    ER_NO_URL,
             ""Aucune URL spécifiée""},
  
   
  

  {
    ER_POOL_SIZE_LESSTHAN_ONE,
             ""La taille du Pool est inférieure à un !""},
  
   
  

  {
    ER_INVALID_DRIVER,
             ""Le nom de pilote spécifié n’est pas correct !""},
  
   
  

  {
    ER_NO_STYLESHEETROOT,
             ""Impossible de trouver la feuille de style racine !""},
  
   
  

  {
    ER_ILLEGAL_XMLSPACE_VALUE,
         ""Valeur non autorisée pour xml:space""},
  
   
  

  {
    ER_PROCESSFROMNODE_FAILED,
         ""Echec de processFromNode""},
  
   
  

  {
    ER_RESOURCE_COULD_NOT_LOAD,
        ""La ressource [ {0} ] n’a pas pu être chargée : {1} 
 {2} 	 {3}""},
   
  
   
  

  {
    ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""Taille du tampon <=0""},
  
   
  

  {
    ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""Erreur inconnue lors de l’appel de l’extension""},
  
   
  

  {
    ER_NO_NAMESPACE_DECL,
        ""Le préfixe {0} de dispose pas d’une déclaration d’espaces de noms correspondante""},
  
   
  

  {
    ER_ELEM_CONTENT_NOT_ALLOWED,
        ""Contenu d’élément non autorisé pour lang=javaclass {0}""},
  
   
  

  {
    ER_STYLESHEET_DIRECTED_TERMINATION,
        ""Achèvement dirigé de la feuille de style""},
  
   
  

  {
    ER_ONE_OR_TWO,
        ""1 ou 2""},
  
   
  

  {
    ER_TWO_OR_THREE,
        ""2 ou 3""},

   
  

  {
    ER_COULD_NOT_LOAD_RESOURCE,
        ""Impossible de charger {0} (vérifier le CHEMIN DE CLASSE). Utilisation des modèles par défaut""},
  
   
  

  {
    ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""Impossible d’initialiser les modèles par défaut""},
  
   
  

  {
    ER_RESULT_NULL,
        ""Le résultat ne peut pas être vide""},
    
   
  

  {
    ER_RESULT_COULD_NOT_BE_SET,
        ""Le résultat ne peut pas être défini""},
  
   
  

  {
    ER_NO_OUTPUT_SPECIFIED,
        ""Aucune sortie spécifiée""},
  
   
  

  {
    ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""Transformation impossible en un résultat de type {0}""},
  
   
  

  {
    ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""Transformation impossible d’une source de type {0}""},
  
   
  

  {
    ER_NULL_CONTENT_HANDLER,
        ""Gestionnaire de contenu vide""},
  
   
  

  {
    ER_NULL_ERROR_HANDLER,
        ""Gestionnaire d’erreurs vide""},
  
   
  

  {
    ER_CANNOT_CALL_PARSE,
        ""L’analyse ne peut être appelée si le gestionnaire de contenu n’a pas été défini""},
  
   
  

  {
    ER_NO_PARENT_FOR_FILTER,
        ""Aucun parent pour le filtre""},
  
  
   
  

  {
    ER_NO_STYLESHEET_IN_MEDIA,
         ""Aucune feuille de style trouvée dans: {0}, media= {1}""},
  
   
  

  {
    ER_NO_STYLESHEET_PI,
         ""Aucun xml-stylesheet PI trouvé dans : {0}""},
  
   
  

  {
    ER_NOT_SUPPORTED,
       ""Non pris en charge : {0}""},
  
   
  

  {
    ER_PROPERTY_VALUE_BOOLEAN,
       ""La valeur pour la propriété {0} doit être une instance booléenne""},
  
   

   
  

  {
    ""ER_SRC_ATTRIB_NOT_SUPPORTED"",
       ""L’attribut src n’est pas encore pris en charge pour {0}""},
  
  
  

  {
    ER_RESOURCE_COULD_NOT_FIND,
        ""Impossible de trouver la ressource [ {0} ].
 {1}""},
  
   
  

  {
    ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""La propriété de sortie n’a pas été reconnue : {0}""},
  
   
  

  {
    ER_FAILED_CREATING_ELEMLITRSLT,
        ""Echec de création de l’instance ElemLiteralResult""},

  
  
  
  
  
   
  

  {
    ER_VALUE_SHOULD_BE_NUMBER,
        ""La valeur de {0} doit contenir un nombre analysable""}, 
  
   
  

  {
    ER_VALUE_SHOULD_EQUAL,
        ""La valeur pour {0} doit être équivalente à oui ou non""},
 
   
  

  {
    ER_FAILED_CALLING_METHOD,
        ""Echec d’appel de la méthode {0}""},
  
   
  

  {
    ER_FAILED_CREATING_ELEMTMPL,
        ""Echec de création de l’instance ElemTemplateElement""},
  
   
  

  {
    ER_CHARS_NOT_ALLOWED,
        ""Les caractères ne sont pas admis à ce niveau du document""},
  
  
  

  {
    ER_ATTR_NOT_ALLOWED,
        ""L’attribut ""{0}"" n’est pas admis dans l’élément {1} !""},
 
  
  

  {
    ER_BAD_VALUE,
     ""{0} valeur incorrecte {1}""},
  
  
  

  {
    ER_ATTRIB_VALUE_NOT_FOUND,
     ""Valeur de l’attribut {0} introuvable""},
  
  
  

  {
    ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""Valeur de l’attribut {0} non reconnue""},

  
  

  {
    ER_NULL_URI_NAMESPACE,
     ""Tentative de génération d'un préfixe d'expace de nom avec un URI nul""},

   

   
  

  {
    ER_NUMBER_TOO_BIG,
     ""Tentative de formatage d'un nombre supérieur à l'entier le plus long""},

  

  

  {
    ER_CANNOT_FIND_SAX1_DRIVER,
     ""Classe de pilotes SAX1 {0} introuvable""},

  
  

  {
    ER_SAX1_DRIVER_NOT_LOADED,
     ""La classe de pilotes SAX1 {0} a été trouvée mais n''a pas été chargée""},

  
  

  {
    ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""La classe de pilotes SAX1 {0} a été chargée mais n''a pas été instanciée""},


  
  

  {
    ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
     ""La classe de pilotes SAX1 {0} n''implémente pas org.xml.sax.Parser""},

  
  

  {
    ER_PARSER_PROPERTY_NOT_SPECIFIED,
     ""Les propriétés du système org.xml.sax.parser n'ont pas été spécifiées""},

  
  

  {
    ER_PARSER_ARG_CANNOT_BE_NULL,
     ""L'argument de l'analyseur ne doit pas être nul""},


  
  

  {
    ER_FEATURE,
     ""Fonction : a {0}""},


  
  

  {
    ER_PROPERTY,
     ""Propriété : a {0}""},

  
  

  {
    ER_NULL_ENTITY_RESOLVER,
     ""Convertisseur d'entité nul""},

  
  

  {
    ER_NULL_DTD_HANDLER,
     ""Gestionnaire de DTD nul""},

  
  
  {
    ER_NO_DRIVER_NAME_SPECIFIED,
     ""Aucun nom de pilote spécifié !""},


  
  
  {
    ER_NO_URL_SPECIFIED,
     ""Aucun URL spécifié !""},


  
  
  {
    ER_POOLSIZE_LESS_THAN_ONE,
     ""La taille du pool est inférieure à 1 !""},


  
  
  {
    ER_INVALID_DRIVER_NAME,
     ""Nom de pilote spécifié incorrect !""},



  
  
  {
    ER_ERRORLISTENER,
     ""ErrorListener""},


  
  
  {
    ER_ASSERT_NO_TEMPLATE_PARENT,
     ""Erreur du programmeur ! expr n'a pas de parent ElemTemplateElement !""},


  
  
  {
    ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
     ""Assertion du programmeur dans RundundentExprEliminator : {0}""},

  
  
  {
    ER_NOT_ALLOWED_IN_POSITION,
     ""{0} n'est pas admis à cet endroit de la feuille de style !""},

  
  
  {
    ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
     ""Le texte sans espace blanc n'est pas admis à cet endroit de la feuille de style !""},

  
  
  
  
  {
    INVALID_TCHAR,
     ""Valeur incorrecte : {1} est utilisé pour l'attribut CHAR : {0}.  Un attribut de type CHAR doit être composé d'un seul caractère !""},

  
    
    
    
    

  
  
  
  {
    INVALID_QNAME,
     ""Valeur incorrecte :a {1} utilisé pour l''attribut QNAME :a {0}""},

    
    
    
    
    
    

  
  
  {
    INVALID_ENUM,
     ""Valeur incorrecte :a {1} utilisé pour l''attribut ENUM :a {0}.  Les valeurs correctes sont :a {2}.""},

  
  
  
  
  

  
  
  {
    INVALID_NMTOKEN,
     ""Valeur incorrecte :a {1} utilisé pour l''attribut NMTOKEN :a {0} ""},

  
  
  
  
  

  
  
  {
    INVALID_NCNAME,
     ""Valeur incorrecte :a {1} utilisé pour l''attribut NCNAME :a {0} ""},

  
  
  
  
  

  
  

  {
    INVALID_BOOLEAN,
     ""Valeur incorrecte :a {1} utilisé pour l''attribut boolean :a {0} ""},

  
  
  
  
  

  
  
  {
    INVALID_NUMBER,
     ""Valeur incorrecte :a {1} utilisé pour l''attribut number :a {0} ""},


  

  
  
  
  
  

  
  
  {
    ER_ARG_LITERAL,
     ""L''argument de {0} de la structure de comparaison doit être un littéral.""},

  
  
  
  

  
  
  {
    ER_DUPLICATE_GLOBAL_VAR,
     ""Duplication de la déclaration de variable globale.""},


  
  
  

  
  
  {
    ER_DUPLICATE_VAR,
     ""Duplication de la déclaration de variable.""},

  
    
    

  
  
  {
    ER_TEMPLATE_NAME_MATCH,
     ""xsl:template doit avoir un attribut name ou match (ou les deux)""},

    
    
    
    
    

  
  
  {
    ER_INVALID_PREFIX,
     ""Le préfixe de exclude-result-prefixes est incorrect :a {0}""},

    
    
    
    
    

  
  
  {
    ER_NO_ATTRIB_SET,
     ""L''ensemble d'attributs {0} n'existe pas""},


  

  
  

  {
    WG_FOUND_CURLYBRACE,
      ""'}' trouvé mais aucun modèle d’attribut ouvert !""},

  
  

  {
    WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""Attention : l’attribut count ne correspond pas à un ancêtre dans xsl:number! Target = {0}""},

  
  

  {
    WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""Ancienne syntaxe : le nom de l’attribut 'expr' été changé par 'select'.""},

  
  

  {
    WG_NO_LOCALE_IN_FORMATNUMBER,
      ""Xalan ne gère pas encore la partie locale du nom dans la fonction format-number.""},

  
  

  {
    WG_LOCALE_NOT_FOUND,
      ""Attention : Impossible de trouver la partie locale du nom pour xml:lang={0}""},

  
  

  {
    WG_CANNOT_MAKE_URL_FROM,
      ""Impossible de créer une URL à partir de : {0}""},

  
  

  {
    WG_CANNOT_LOAD_REQUESTED_DOC,
      ""Impossible de charger le document demandé : {0}""},

  
  

  {
    WG_CANNOT_FIND_COLLATOR,
      ""Impossible de trouver Collator pour <sort xml:lang={0}""},

  
  

  {
    WG_FUNCTIONS_SHOULD_USE_URL,
      ""Ancienne syntaxe : les fonctions doivent utiliser une url de {0}""},

  
  

  {
    WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""Encodage non pris en charge : {0}, en utilisant UTF-8""},

  
  

  {
    WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      "" Encodage non pris en charge: {0}, en utilisant Java {1}""},

  
  

  {
    WG_SPECIFICITY_CONFLICTS,
      ""Conflits de spécificité détectés : {0}, le dernier trouvé dans la feuille de style sera utilisé.""},

  
  

  {
    WG_PARSING_AND_PREPARING,
      ""========= Analyse et préparation {0} ==========""},

  
  

  {
    WG_ATTR_TEMPLATE, ""Modèle d’attribut, {0}""},

  
  

  {
    WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""Conflit de correspondance entre xsl:strip-space et xsl:preserve-space""},

  
  

  {
    WG_ATTRIB_NOT_HANDLED,
      ""Xalan ne gère pas encore l’attribut {0} !""},

  
  

  {
    WG_NO_DECIMALFORMAT_DECLARATION,
      ""Aucune déclaration trouvée pour le format décimal : {0}""},

  
  

  {
    WG_OLD_XSLT_NS, ""Espace de noms XSLT manquant ou incorrect. ""},

  
  

  {
    WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""Seule une déclaration xsl:decimal-format par défaut est autorisée.""},

  
  

  {
    WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""Les noms xsl:decimal-format doivent être uniques. Le nom ""{0}"" apparaît en double.""},

  
  

  {
    WG_ILLEGAL_ATTRIBUTE,
      ""{0} dispose d’un attribut non autorisé : {1}""},

  
  

  {
    WG_COULD_NOT_RESOLVE_PREFIX,
      ""Impossible de résoudre de préfixe d’espace de noms : {0}. Le nœud sera ignoré.""},

  
  

  {
    WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet requiert un attribut 'version' !""},

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_NAME,
      ""Nom d’attribut non autorisé : {0}""},

  
  

  {
    WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""La valeur utilisée pour l’attribut {0} n’est pas autorisée : {1}""},

  
  

  {
    WG_EMPTY_SECOND_ARG,
      ""L’ensemble de nœuds résultant d’un deuxième argument de la fonction document est vide. Le premier argument sera utilisé.""},

  

    
    
    


  
  
  {
     WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""La valeur de l'attribut 'name' de xsl:processing-instruction ne doit pas être 'xml'""},

    
    
    
    

  
  
  {
     WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""La valeur de l''attribut ''name'' de xsl:processing-instruction doit être un NCName valide :a {0}""},

    
    
    
    
    

  
  
  {
    WG_ILLEGAL_ATTRIBUTE_POSITION,
      ""Impossible d''ajouter l''attribut {0}après les noeuds enfants ou avant qu'un élément ne soit produit.  L'attribut est ignoré.""},

  

  
    { ""ui_language"", ""fr""},
    { ""help_language"", ""fr""},
    { ""language"", ""fr""},
    { ""BAD_CODE"",
      ""Paramètre pour createMessage hors limites""},
    { ""FORMAT_FAILED"",
      ""Exception émise pendant l’appel de messageFormat ""},
    {""version"",
      "">>>>>>> Version Xalan ""},
    { ""version2"",  ""<<<<<<<""},
    {""yes"",  ""oui""},
    { ""line"", ""N° de ligne""},
    {""column"", ""N° de colonne""},
    {""xsldone"", ""XSLProcessor: terminé""},
    {""xslProc_option"", ""Options de classe de traitement de la ligne de commande Xalan-J :""},
    {""optionIN"",  ""    -IN inputXMLURL""},
    {  ""optionXSL"",  ""   [-XSL XSLTransformationURL]""},
    { ""optionOUT"",  ""   [-OUT outputFileName]""},
    { ""optionLXCIN"", ""   [-LXCIN compiledStylesheetFileNameIn]""},
    { ""optionLXCOUT"",
      ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
    { ""optionPARSER"",
      ""   [-PARSER nom de classe qualifié pour la liaison de l’analyseur]""},
    { ""optionE"",
      ""   [-E (Ne pas développer les références d’entités)]""},
    { ""optionV"",  ""   [-E (Ne pas développer les références d’entités)]""},
    { ""optionQC"",
      ""   [-QC (Avertissements pour les conflits silencieux de formes)]""},
    {""optionQ"",
      ""   [-Q  (Mode silencieux)]""},
    { ""optionLF"",
      ""   [-LF (Utilisation des sauts de ligne uniquement en sortie {CR/LF par défaut})]""},
    { ""optionCR"",
      ""   [-CR (Utilisation des retours chariot uniquement en sortie {CR/LF par défaut})]""},
    {  ""optionESCAPE"",
      ""   [-ESCAPE (Caractères à remplacer {<>&""'\r\n par défaut}]""},
    {  ""optionINDENT"",
      ""   [-INDENT (Contrôle le nombre d’espaces pour le retrait {0 par défaut})]""},
    {  ""optionTT"",
      ""   [-TT (Trace des modèles lors de leur appel.)]""},
    { ""optionTG"",
      ""   [-TG (Trace de chaque création d’événement.)]""},
    { ""optionTS"",
      ""   [-TS (Trace de chaque sélection d’événement.)]""},
    { ""optionTTC"",
      ""   [-TTC (Trace de chaque modèle enfant lorsqu’ils sont traités.)]""},
    { ""optionTCLASS"",
      ""   [-TCLASS (Classe TraceListener pour les extensions de trace.)]""},
    { ""optionVALIDATE"",
      ""   [-VALIDATE (Détermine si la validation intervient. La validation est désactivée par défaut.)]""},
    { ""optionEDUMP"",
      ""   [-EDUMP {optional filename} (Permet d’accéder à l’emplacement de l’erreur.)]""},
    { ""optionXML"",
      ""   [-XML (Utilisation d’un formateur XML et ajout d’en-tête XML.)]""},
    {  ""optionTEXT"",
      ""   [-TEXT (Utilisation d’un formateur de texte simple.)]""},
    { ""optionHTML"", ""   [-HTML (Utilisation d’un formateur HTML.)]""},
    { ""optionPARAM"",
      ""   [-PARAM name expression (Définition d’un paramètre de feuille de style)]""},
    {  ""noParsermsg1"",
      ""Echec de XSL Process.""},
    {  ""noParsermsg2"",
      ""** Impossible de trouver l’analyseur **""},
    { ""noParsermsg3"",
      ""Veuillez vérifier votre chemin de classe.""},
    {  ""noParsermsg4"",
      "" Si vous ne disposez pas de l’analyseur XML d’IBM pour Java, vous pouvez le télécharger à l’adresse suivante ""},
    {  ""noParsermsg5"",
      ""IBM's AlphaWorks: http:
    { ""optionURIRESOLVER"",
      ""   [-URIRESOLVER nom de classe complet (URIResolver à utiliser pour résoudre les URI)]""},
    { ""optionENTITYRESOLVER"",
      ""   [-ENTITYRESOLVER nom de classe complet (EntityResolver à utiliser pour résoudre les entités)]""},
    { ""optionCONTENTHANDLER"",
      ""   [-CONTENTHANDLER nom de classe complet (ContentHandler à utiliser pour mettre en série les sorties)]""},
    { ""optionLINENUMBERS"",
      ""   [-L Utilisation des nombres de lignes pour le document source]""},




    { ""optionMEDIA"",
      "" [-MEDIA mediaType (utilisation de l'attribut media pour rechercher la feuille de style associée à un document.)]""},
    { ""optionFLAVOR"",
     "" [-FLAVOR flavorName (utilisation explicite de s2s=SAX ou d2d=DOM pour procéder aux transformations.)] ""}, 
    { ""optionDIAG"",
      "" [-DIAG (Impression du nombre global de millisecondes de la transformation.)]""},
    {  ""optionINCREMENTAL"",
     "" [-INCREMENTAL (demande de construction DTM incrémentielle en attribuant la valeur true à http:
    { ""optionNOOPTIMIMIZE"",
     "" [-NOOPTIMIMIZE (demande d'aucune optimisation de la feuille de style en attribuant la valeur false à http:
    { ""optionRL"",
     "" [-RL recursionlimit (assertion d'une limite numérique sur la profondeur de récursion de la feuille de style.)]""},
    { ""optionXO"",
     "" [-XO [transletName] (affectation du nom au translet généré)]""},
    { ""optionXD"",
     "" [-XD destinationDirectory (spécification d'un répertoire de destination pour le translet)]""},
    { ""optionXJ"",
     "" [-XJ jarfile (regroupe les classes de translet dans un fichier jar nommé <jarfile>)]""},
    { ""optionXP"",
     "" [-XP package (spécifie un préfixe de nom de groupe pour toutes les classes de translet générées)]""}


  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""Erreur : "";

  
  public static final String WARNING_HEADER = ""Attention : "";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""FORME"";

  
  public Object[][] getContents()
  {
    return contents;
  }
}

"
org.apache.xpath.axes.UnionChildIterator,3,7,0,9,14,0,1,8,3,0.0,119,1.0,0,0.985185185,0.555555556,3,3,38.33333333,5,2.3333,1,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.patterns.NodeTest;


public class UnionChildIterator extends ChildTestIterator
{
  
  private PredicatedNodeTest[] m_nodeTests = null;

  
  public UnionChildIterator()
  {
    super(null);
  }

  
  public void addNodeTest(PredicatedNodeTest test)
  {

    
    
    if (null == m_nodeTests)
    {
      m_nodeTests = new PredicatedNodeTest[1];
      m_nodeTests[0] = test;
    }
    else
    {
      PredicatedNodeTest[] tests = m_nodeTests;
      int len = m_nodeTests.length;

      m_nodeTests = new PredicatedNodeTest[len + 1];

      System.arraycopy(tests, 0, m_nodeTests, 0, len);

      m_nodeTests[len] = test;
    }
    test.exprSetParent(this);
  }

  
  public short acceptNode(int n)
  {
    XPathContext xctxt = getXPathContext();
    try
    {
      xctxt.pushCurrentNode(n);
      for (int i = 0; i < m_nodeTests.length; i++)
      {
        PredicatedNodeTest pnt = m_nodeTests[i];
        XObject score = pnt.execute(xctxt, n);
        if (score != NodeTest.SCORE_NONE)
        {
          
          if (pnt.getPredicateCount() > 0)
          {
            if (pnt.executePredicates(n, xctxt))
              return DTMIterator.FILTER_ACCEPT;
          }
          else
            return DTMIterator.FILTER_ACCEPT;

        }
      }
    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new RuntimeException(se.getMessage());
    }
    finally
    {
      xctxt.popCurrentNode();
    }
    return DTMIterator.FILTER_SKIP;
  }

}"
org.apache.xpath.functions.FuncExtFunction,13,3,0,22,30,16,12,12,12,0.791666667,207,0.0,0,0.76,0.205128205,2,9,14.61538462,3,1.3846,2,"
package org.apache.xpath.functions;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionNode;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.ExtensionsProvider;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XNull;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;


public class FuncExtFunction extends Function
{

  
  String m_namespace;

  
  String m_extensionName;

  
  Object m_methodKey;

  
  Vector m_argVec = new Vector();

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {

    if (null != m_argVec)
    {
      int nArgs = m_argVec.size();

      for (int i = 0; i < nArgs; i++)
      {
        Expression arg = (Expression) m_argVec.elementAt(i);

        arg.fixupVariables(vars, globalsSize);
      }
    }
  }
  
  
  public String getNamespace()
  {
    return m_namespace;
  }
  
  
  public String getFunctionName()
  {
    return m_extensionName;
  }
  
  
  public Object getMethodKey()
  {
    return m_methodKey;
  }

      
  public Expression getArg(int n) {
    if (n >= 0 && n < m_argVec.size())
      return (Expression) m_argVec.elementAt(n);
    else
      return null;
  }

      
  public int getArgCount() {
    return m_argVec.size();
  }

  
  public FuncExtFunction(java.lang.String namespace,
                         java.lang.String extensionName, Object methodKey)
  {
    
    m_namespace = namespace;
    m_extensionName = extensionName;
    m_methodKey = methodKey;
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    XObject result;
    Vector argVec = new Vector();
    int nArgs = m_argVec.size();

    for (int i = 0; i < nArgs; i++)
    {
      Expression arg = (Expression) m_argVec.elementAt(i);
      
      XObject xobj = arg.execute(xctxt);

      argVec.addElement(xobj);
    }
    
    ExtensionsProvider extProvider = (ExtensionsProvider)xctxt.getOwnerObject();
    Object val = extProvider.extFunction(this, argVec);

    if (null != val)
    {
      result = XObject.create(val, xctxt);
    }
    else
    {
      result = new XNull();
    }

    return result;
  }

  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {
    m_argVec.addElement(arg);
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException{}


  class ArgExtOwner implements ExpressionOwner
  {
  
    Expression m_exp;
  	
  	ArgExtOwner(Expression exp)
  	{
  		m_exp = exp;
  	}
  	
    
    public Expression getExpression()
    {
      return m_exp;
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(FuncExtFunction.this);
    	m_exp = exp;
    }
  }
  
  
  
  public void callArgVisitors(XPathVisitor visitor)
  {
      for (int i = 0; i < m_argVec.size(); i++)
      {
         Expression exp = (Expression)m_argVec.elementAt(i);
         exp.callVisitors(new ArgExtOwner(exp), visitor);
      }
    
  }

  
  public void exprSetParent(ExpressionNode n) 
  {
	
    super.exprSetParent(n);
      
    int nArgs = m_argVec.size();

    for (int i = 0; i < nArgs; i++)
    {
      Expression arg = (Expression) m_argVec.elementAt(i);

      arg.exprSetParent(n);
    }		
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
    String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ ""Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called."" });

    throw new RuntimeException(fMsg);
  }
}
"
org.apache.xalan.xsltc.dom.DOMWSFilter,2,1,0,9,10,0,2,7,2,0.4,110,1.0,4,0.0,0.625,0,0,51.5,9,4.5,0,"
package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.StripFilter;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.runtime.Hashtable;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMWSFilter;


public class DOMWSFilter implements DTMWSFilter {

    private AbstractTranslet m_translet;
    private StripFilter m_filter;
    
    
    private Hashtable m_mappings;
    
    
    private DTM m_currentDTM;
    private short[] m_currentMapping;

    
    public DOMWSFilter(AbstractTranslet translet) {
        m_translet = translet;
        m_mappings = new Hashtable();

        if (translet instanceof StripFilter) {
            m_filter = (StripFilter) translet;
        }
    }

    
    public short getShouldStripSpace(int node, DTM dtm) {
        if (m_filter != null && dtm instanceof DOM) {
            DOM dom = (DOM)dtm;
            int type = 0;

            if (dtm instanceof SAXImpl) {
                SAXImpl saxImpl = (SAXImpl)dtm;
                
                short[] mapping;
                if (dtm == m_currentDTM) {
                    mapping = m_currentMapping;
                }
                else {  
                    mapping = (short[])m_mappings.get(dtm);
                    if (mapping == null) {
                        mapping = saxImpl.getMapping(m_translet.getNamesArray());
                        m_mappings.put(dtm, mapping);
                        m_currentDTM = saxImpl;
                        m_currentMapping = mapping;
                    }
                }
                
                int expType = saxImpl.getExpandedTypeID(node);
                
                
                
                
                
                
                if (expType >= 0 && expType < mapping.length)
                  type = mapping[expType];
                else
                  type = -1;
                
            } 
            else {
                return INHERIT;
            }

            if (m_filter.stripSpace(dom, node, type)) {
                return STRIP;
            } else {
                return NOTSTRIP;
            }
        } else {
            return NOTSTRIP;
        }
    }
}
"
org.apache.xpath.functions.FuncNormalizeSpace,3,5,0,6,11,3,0,6,3,2.0,45,0.0,0,0.964912281,0.666666667,2,7,14.0,1,0.6667,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.xml.sax.ContentHandler;


public class FuncNormalizeSpace extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    XMLString s1 = getArg0AsString(xctxt);

    return (XString)s1.fixWhiteSpace(true, true, false);
  }
  
  
  public void executeCharsToContentHandler(XPathContext xctxt, 
                                              ContentHandler handler)
    throws javax.xml.transform.TransformerException,
           org.xml.sax.SAXException
  {
    if(Arg0IsNodesetExpr())
    {
      int node = getArg0AsNode(xctxt);
      if(DTM.NULL != node)
      {
        DTM dtm = xctxt.getDTM(node);
        dtm.dispatchCharactersEvents(node, handler, true);
      }
    }
    else
    {
      XObject obj = execute(xctxt);
      obj.dispatchCharactersEvents(handler);
    }
  }

}
"
org.apache.xalan.xsltc.compiler.FloorCall,2,4,0,10,10,1,0,10,2,2.0,26,0.0,0,0.989690722,0.6,2,4,12.0,1,0.5,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;

final class FloorCall extends FunctionCall {
    public FloorCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	argument().translate(classGen, methodGen);
	methodGen.getInstructionList()
	    .append(new INVOKESTATIC(classGen.getConstantPool()
				     .addMethodref(MATH_CLASS,
						   ""floor"", ""(D)D"")));
    }
}
"
org.apache.xalan.templates.KeyDeclaration,9,3,0,11,17,16,7,6,9,0.75,79,1.0,3,0.960784314,0.296296296,1,2,7.444444444,1,0.8889,2,"
package org.apache.xalan.templates;

import org.apache.xml.utils.QName;
import org.apache.xpath.XPath;


public class KeyDeclaration extends ElemTemplateElement
{

  
  public KeyDeclaration(Stylesheet parentNode, int docOrderNumber)
  {
    m_parentNode = parentNode;
    setUid(docOrderNumber);
  }

  
  private QName m_name;

  
  public void setName(QName name)
  {
    m_name = name;
  }

  
  public QName getName()
  {
    return m_name;
  }

  
  private XPath m_matchPattern = null;

  
  public void setMatch(XPath v)
  {
    m_matchPattern = v;
  }

  
  public XPath getMatch()
  {
    return m_matchPattern;
  }

  
  private XPath m_use;

  
  public void setUse(XPath v)
  {
    m_use = v;
  }

  
  public XPath getUse()
  {
    return m_use;
  }
  
  
  public void compose(StylesheetRoot sroot) 
    throws javax.xml.transform.TransformerException
  {
    super.compose(sroot);
    java.util.Vector vnames = sroot.getComposeState().getVariableNames();
    if(null != m_matchPattern)
      m_matchPattern.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
    if(null != m_use)
      m_use.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeKeys(this);
  }

}
"
org.apache.xml.utils.res.XResources_zh_CN,3,4,0,1,4,1,0,1,2,0.5,499,0.0,0,0.976190476,1.0,0,0,165.0,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_zh_CN extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""zh"" }, { ""help_language"", ""zh"" }, { ""language"", ""zh"" },
    { ""alphabet"",
      new char[]{ 0xff21, 0xff22, 0xff23, 0xff24, 0xff25, 0xff26, 0xff27,
                  0xff28, 0xff29, 0xff2a, 0xff2b, 0xff2c, 0xff2d, 0xff2e,
                  0xff2f, 0xff30, 0xff31, 0xff32, 0xff33, 0xff34, 0xff35,
                  0xff36, 0xff37, 0xff38, 0xff39, 0xff3a } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    { ""zero"", new char[]{ 0x96f6 } },

    
    { ""multiplier"", new long[]{ 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4ebf, 0x4e07, 0x5343, 0x767e, 0x5341 } },
    { ""digits"",
      new char[]{ 0x4e00, 0x4e8c, 0x4e09, 0x56db, 0x4e94, 0x516d, 0x4e03,
                  0x516b, 0x4e5d } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xpath.operations.And,3,3,0,6,7,1,1,5,3,2.0,42,0.0,0,0.953488372,0.833333333,1,6,13.0,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class And extends Operation
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XObject expr1 = m_left.execute(xctxt);

    if (expr1.bool())
    {
      XObject expr2 = m_right.execute(xctxt);

      return expr2.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;
    }
    else
      return XBoolean.S_FALSE;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return (m_left.bool(xctxt) && m_right.bool(xctxt));
  }

}
"
org.apache.xalan.templates.ElemApplyImport,5,3,0,7,17,10,1,6,5,2.0,69,0.0,0,0.98,0.466666667,2,6,12.8,1,0.8,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;


public class ElemApplyImport extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_APPLY_IMPORTS;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_APPLY_IMPORTS_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (transformer.currentTemplateRuleIsNull())
    {
      transformer.getMsgMgr().error(this,
        XSLTErrorResources.ER_NO_APPLY_IMPORT_IN_FOR_EACH);  
    }

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    int sourceNode = transformer.getXPathContext().getCurrentNode();
    if (DTM.NULL != sourceNode)
    {

      
      
      transformer.applyTemplateToNode(this, null, sourceNode);
    }
    else  
    {
      transformer.getMsgMgr().error(this,
        XSLTErrorResources.ER_NULL_SOURCENODE_APPLYIMPORTS);  
    }
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }
}
"
org.apache.xpath.XPathContext,78,2,1,173,145,2203,156,23,76,0.93452381,1077,0.791666667,13,0.2,0.06993007,0,0,12.5,5,1.2949,3,"
package org.apache.xpath;

import java.lang.reflect.Method;
import java.util.Stack;
import java.util.Vector;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.dtm.ref.sax2dtm.SAX2RTFDTM;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.NodeVector;
import org.apache.xml.utils.ObjectStack;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.axes.SubContextList;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.res.XPATHErrorResources;

import org.xml.sax.XMLReader;


public class XPathContext extends DTMManager 
{
	IntStack m_last_pushed_rtfdtm=new IntStack();	
  
  private Vector m_rtfdtm_stack=null;
  
  private int m_which_rtfdtm=-1;
  
 
  private SAX2RTFDTM m_global_rtfdtm=null;
  
	
  
  protected DTMManager m_dtmManager = DTMManager.newInstance(
                   org.apache.xpath.objects.XMLStringFactoryImpl.getFactory());
  
  
   public DTMManager getDTMManager()
   {
     return m_dtmManager;
   }
  
  
  public DTM getDTM(javax.xml.transform.Source source, boolean unique, 
                    DTMWSFilter wsfilter,
                    boolean incremental,
                    boolean doIndexing)
  {
    return m_dtmManager.getDTM(source, unique, wsfilter, 
                               incremental, doIndexing);
  }
                             
  
  public DTM getDTM(int nodeHandle)
  {
    return m_dtmManager.getDTM(nodeHandle);
  }

  
  public int getDTMHandleFromNode(org.w3c.dom.Node node)
  {
    return m_dtmManager.getDTMHandleFromNode(node);
  }


  
  public int getDTMIdentity(DTM dtm)
  {
    return m_dtmManager.getDTMIdentity(dtm);
  }

  
  public DTM createDocumentFragment()
  {
    return m_dtmManager.createDocumentFragment();
  }

  
  public boolean release(DTM dtm, boolean shouldHardDelete)
  {
    
    
    
    
    
    if(m_rtfdtm_stack!=null && m_rtfdtm_stack.contains(dtm))
    {
      return false;
    }
  	
    return m_dtmManager.release(dtm, shouldHardDelete);
  }

  
  public DTMIterator createDTMIterator(Object xpathCompiler, int pos)
  {
    return m_dtmManager.createDTMIterator(xpathCompiler, pos);
  }

  
  public DTMIterator createDTMIterator(String xpathString,
          PrefixResolver presolver)
  {
    return m_dtmManager.createDTMIterator(xpathString, presolver);
  }

  
  public DTMIterator createDTMIterator(int whatToShow,
          DTMFilter filter, boolean entityReferenceExpansion)
  {
    return m_dtmManager.createDTMIterator(whatToShow, filter, entityReferenceExpansion);
  }
  
  
  public DTMIterator createDTMIterator(int node)
  {
    
    DTMIterator iter = new org.apache.xpath.axes.OneStepIteratorForward(Axis.SELF);
    iter.setRoot(node, this);
    return iter;
    
  }

  
  public XPathContext()
  {
    m_prefixResolvers.push(null);
    m_currentNodes.push(DTM.NULL);
    m_currentExpressionNodes.push(DTM.NULL);
    m_saxLocations.push(null);
  }

  
  public XPathContext(Object owner)
  {
    m_owner = owner;
    try {
      m_ownerGetErrorListener = m_owner.getClass().getMethod(""getErrorListener"", new Class[] {});
    }
    catch (NoSuchMethodException nsme) {}
    m_prefixResolvers.push(null);
    m_currentNodes.push(DTM.NULL);
    m_currentExpressionNodes.push(DTM.NULL);
    m_saxLocations.push(null);
  }

  
  public void reset()
  {
  	
  	if(m_rtfdtm_stack!=null)
  		 for (java.util.Enumeration e = m_rtfdtm_stack.elements() ; e.hasMoreElements() ;) 
  		 	m_dtmManager.release((DTM)e.nextElement(), true);

    m_rtfdtm_stack=null; 
    m_which_rtfdtm=-1;
    
    if(m_global_rtfdtm!=null)
  		 	m_dtmManager.release(m_global_rtfdtm,true);
    m_global_rtfdtm=null;
  	
    m_dtmManager = DTMManager.newInstance(
                   org.apache.xpath.objects.XMLStringFactoryImpl.getFactory());
                   
    m_saxLocations.removeAllElements();   
	m_axesIteratorStack.removeAllElements();
	m_contextNodeLists.removeAllElements();
	m_currentExpressionNodes.removeAllElements();
	m_currentNodes.removeAllElements();
	m_iteratorRoots.RemoveAllNoClear();
	m_predicatePos.removeAllElements();
	m_predicateRoots.RemoveAllNoClear();
	m_prefixResolvers.removeAllElements();
	
	m_prefixResolvers.push(null);
    m_currentNodes.push(DTM.NULL);
    m_currentExpressionNodes.push(DTM.NULL);
    m_saxLocations.push(null);
  }

  
  ObjectStack m_saxLocations = new ObjectStack(RECURSIONLIMIT);

  
  public void setSAXLocator(SourceLocator location)
  {
    m_saxLocations.setTop(location);
  }
  
  
  public void pushSAXLocator(SourceLocator location)
  {
    m_saxLocations.push(location);
  }
  
  
  public void pushSAXLocatorNull()
  {
    m_saxLocations.push(null);
  }


  
  public void popSAXLocator()
  {
    m_saxLocations.pop();
  }

  
  public SourceLocator getSAXLocator()
  {
    return (SourceLocator) m_saxLocations.peek();
  }

  
  private Object m_owner;

  
  private Method m_ownerGetErrorListener;

  
  public Object getOwnerObject()
  {
    return m_owner;
  }

  

  
  private VariableStack m_variableStacks = new VariableStack();

  
  public final VariableStack getVarStack()
  {
    return m_variableStacks;
  }

  
  public final void setVarStack(VariableStack varStack)
  {
    m_variableStacks = varStack;
  }

  

  
  private SourceTreeManager m_sourceTreeManager = new SourceTreeManager();

  
  public final SourceTreeManager getSourceTreeManager()
  {
    return m_sourceTreeManager;
  }

  
  public void setSourceTreeManager(SourceTreeManager mgr)
  {
    m_sourceTreeManager = mgr;
  }
  
  

  
  private ErrorListener m_errorListener;

  
  private ErrorListener m_defaultErrorListener;

  
  public final ErrorListener getErrorListener()
  {

    if (null != m_errorListener)
        return m_errorListener;

    ErrorListener retval = null;

    try {
      if (null != m_ownerGetErrorListener)
        retval = (ErrorListener) m_ownerGetErrorListener.invoke(m_owner, new Object[] {});
    }
    catch (Exception e) {}

    if (null == retval)
    {
      if (null == m_defaultErrorListener) 
        m_defaultErrorListener = new org.apache.xml.utils.DefaultErrorHandler();
      retval = m_defaultErrorListener;
    }

    return retval;
  }

  
  public void setErrorListener(ErrorListener listener) throws IllegalArgumentException
  {
    if (listener == null) 
      throw new IllegalArgumentException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, null)); 
    m_errorListener = listener;
  }


  

  
  private URIResolver m_uriResolver;

  
  public final URIResolver getURIResolver()
  {
    return m_uriResolver;
  }

  
  public void setURIResolver(URIResolver resolver)
  {
    m_uriResolver = resolver;
  }

  

  
  public XMLReader m_primaryReader;

  
  public final XMLReader getPrimaryReader()
  {
    return m_primaryReader;
  }

  
  public void setPrimaryReader(XMLReader reader)
  {
    m_primaryReader = reader;
  }

  


  
  

  
  private void assertion(boolean b, String msg) throws javax.xml.transform.TransformerException
  {

    ErrorListener errorHandler = getErrorListener();

    if (errorHandler != null)
    {
      errorHandler.fatalError(
        new TransformerException(
          XSLMessages.createMessage(
            XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
            new Object[]{ msg }), (SAXSourceLocator)this.getSAXLocator()));
    }
  }

  
  
  
  
  
  private Stack m_contextNodeLists = new Stack();
  
  public Stack getContextNodeListsStack() { return m_contextNodeLists; }
  public void setContextNodeListsStack(Stack s) { m_contextNodeLists = s; }

  
  public final DTMIterator getContextNodeList()
  {

    if (m_contextNodeLists.size() > 0)
      return (DTMIterator) m_contextNodeLists.peek();
    else
      return null;
  }

  
  public final void pushContextNodeList(DTMIterator nl)
  {
    m_contextNodeLists.push(nl);
  }

  
  public final void popContextNodeList()
  {
  	if(m_contextNodeLists.isEmpty())
  	  System.err.println(""Warning: popContextNodeList when stack is empty!"");
  	else
      m_contextNodeLists.pop();
  }

  
  public static final int RECURSIONLIMIT = (1024*4);

  
  private IntStack m_currentNodes = new IntStack(RECURSIONLIMIT);
   

  
  public IntStack getCurrentNodeStack() {return m_currentNodes; }
  public void setCurrentNodeStack(IntStack nv) { m_currentNodes = nv; }

  
  public final int getCurrentNode()
  {
    return m_currentNodes.peek();
  }
  
  
  public final void pushCurrentNodeAndExpression(int cn, int en)
  {
    m_currentNodes.push(cn);
    m_currentExpressionNodes.push(cn);
  }

  
  public final void popCurrentNodeAndExpression()
  {
    m_currentNodes.quickPop(1);
    m_currentExpressionNodes.quickPop(1);
  }
  
  
  public final void pushExpressionState(int cn, int en, PrefixResolver nc)
  {
    m_currentNodes.push(cn);
    m_currentExpressionNodes.push(cn);
    m_prefixResolvers.push(nc);
  }
  
  
  public final void popExpressionState()
  {
    m_currentNodes.quickPop(1);
    m_currentExpressionNodes.quickPop(1);
    m_prefixResolvers.pop();
  }



  
  public final void pushCurrentNode(int n)
  {
    m_currentNodes.push(n);
  }
  
  
  public final void popCurrentNode()
  {
    m_currentNodes.quickPop(1);
  }
  
  
  public final void pushPredicateRoot(int n)
  {
    m_predicateRoots.push(n);
  }

  
  public final void popPredicateRoot()
  {
    m_predicateRoots.popQuick();
  }

  
  public final int getPredicateRoot()
  {
    return m_predicateRoots.peepOrNull();
  }
  
  
  public final void pushIteratorRoot(int n)
  {
    m_iteratorRoots.push(n);
  }

  
  public final void popIteratorRoot()
  {
    m_iteratorRoots.popQuick();
  }

  
  public final int getIteratorRoot()
  {
    return m_iteratorRoots.peepOrNull();
  }
  
  
  private NodeVector m_iteratorRoots = new NodeVector();

  
  private NodeVector m_predicateRoots = new NodeVector();

  
  private IntStack m_currentExpressionNodes = new IntStack(RECURSIONLIMIT);
  
     
  public IntStack getCurrentExpressionNodeStack() { return m_currentExpressionNodes; }
  public void setCurrentExpressionNodeStack(IntStack nv) { m_currentExpressionNodes = nv; }
  
  private IntStack m_predicatePos = new IntStack();
  
  public final int getPredicatePos()
  {
    return m_predicatePos.peek();
  }

  public final void pushPredicatePos(int n)
  {
    m_predicatePos.push(n);
  }

  public final void popPredicatePos()
  {
    m_predicatePos.pop();
  }

  
  public final int getCurrentExpressionNode()
  {
    return m_currentExpressionNodes.peek();
  }

  
  public final void pushCurrentExpressionNode(int n)
  {
    m_currentExpressionNodes.push(n);
  }

  
  public final void popCurrentExpressionNode()
  {
    m_currentExpressionNodes.quickPop(1);
  }
  
  private ObjectStack m_prefixResolvers 
                                   = new ObjectStack(RECURSIONLIMIT);

  
  public final PrefixResolver getNamespaceContext()
  {
    return (PrefixResolver) m_prefixResolvers.peek();
  }

  
  public final void setNamespaceContext(PrefixResolver pr)
  {
    m_prefixResolvers.setTop(pr);
  }

  
  public final void pushNamespaceContext(PrefixResolver pr)
  {
    m_prefixResolvers.push(pr);
  }
  
  
  public final void pushNamespaceContextNull()
  {
    m_prefixResolvers.push(null);
  }

  
  public final void popNamespaceContext()
  {
    m_prefixResolvers.pop();
  }

  
  
  

  
  private Stack m_axesIteratorStack = new Stack();
  
  public Stack getAxesIteratorStackStacks() { return m_axesIteratorStack; }
  public void setAxesIteratorStackStacks(Stack s) { m_axesIteratorStack = s; }

  
  public final void pushSubContextList(SubContextList iter)
  {
    m_axesIteratorStack.push(iter);
  }

  
  public final void popSubContextList()
  {
    m_axesIteratorStack.pop();
  }

  
  public SubContextList getSubContextList()
  {
    return m_axesIteratorStack.isEmpty()
           ? null : (SubContextList) m_axesIteratorStack.peek();
  }
  
  
  public org.apache.xpath.axes.LocPathIterator getCurrentNodeList()
  {
    for (int i = m_axesIteratorStack.size()-1; i >= 0; i--) 
    {
      org.apache.xpath.axes.PredicatedNodeTest iter 
       = (org.apache.xpath.axes.PredicatedNodeTest)m_axesIteratorStack.elementAt(i);
      org.apache.xpath.axes.LocPathIterator lpi = iter.getLocPathIterator();
      if(lpi.getIsTopLevel())
        return lpi;
    }
    return null;
  }


  
  
  

  
  public final int getContextNode()
  {
    return this.getCurrentNode();
  }

  
  public final DTMIterator getContextNodes()
  {

    try
    {
      DTMIterator cnl = getContextNodeList();

      if (null != cnl)
        return cnl.cloneWithReset();
      else
        return null;  
    }
    catch (CloneNotSupportedException cnse)
    {
      return null;  
    }
  }
  
  XPathExpressionContext expressionContext = new XPathExpressionContext();
  
  
  public ExpressionContext getExpressionContext()
  {
    return expressionContext;
  }
  
  public class XPathExpressionContext implements ExpressionContext
  {
    
     public XPathContext getXPathContext()
     {
       return XPathContext.this;
     }

    
     public DTMManager getDTMManager()
     {
       return m_dtmManager;
     }
    
    
    public org.w3c.dom.Node getContextNode()
    {
      int context = getCurrentNode();
      
      return getDTM(context).getNode(context);
    }
  
    
    public org.w3c.dom.traversal.NodeIterator getContextNodes()
    {
      return new org.apache.xml.dtm.ref.DTMNodeIterator(getContextNodeList());
    }

    
    public ErrorListener getErrorListener()
    {
      return XPathContext.this.getErrorListener();
    }
  
    
    public double toNumber(org.w3c.dom.Node n)
    {
      
      int nodeHandle = getDTMHandleFromNode(n);
      DTM dtm = getDTM(nodeHandle);
      XString xobj = (XString)dtm.getStringValue(nodeHandle);
      return xobj.num();
    }
  
    
    public String toString(org.w3c.dom.Node n)
    {
      
      int nodeHandle = getDTMHandleFromNode(n);
      DTM dtm = getDTM(nodeHandle);
      XMLString strVal = dtm.getStringValue(nodeHandle);
      return strVal.toString();
    }

    

    public final XObject getVariableOrParam(org.apache.xml.utils.QName qname)
              throws javax.xml.transform.TransformerException
    {
      return m_variableStacks.getVariableOrParam(XPathContext.this, qname);
    }

  }

 
  public DTM getGlobalRTFDTM()
  {
  	
  	
  	
  	
  	
  	
  	
  	
  	

	
	
	
	if( m_global_rtfdtm==null || m_global_rtfdtm.isTreeIncomplete() )
	{
  		m_global_rtfdtm=(SAX2RTFDTM)m_dtmManager.getDTM(null,true,null,false,false);
	}
    return m_global_rtfdtm;
  }
  



  
  public DTM getRTFDTM()
  {
  	SAX2RTFDTM rtfdtm;

  	
  	
  	
  	
  	
  	
  	
  	
  	

	if(m_rtfdtm_stack==null)
	{
		m_rtfdtm_stack=new Vector();
  		rtfdtm=(SAX2RTFDTM)m_dtmManager.getDTM(null,true,null,false,false);
    m_rtfdtm_stack.addElement(rtfdtm);
		++m_which_rtfdtm;
	}
	else if(m_which_rtfdtm<0)
	{
		rtfdtm=(SAX2RTFDTM)m_rtfdtm_stack.elementAt(++m_which_rtfdtm);
	}
	else
	{
		rtfdtm=(SAX2RTFDTM)m_rtfdtm_stack.elementAt(m_which_rtfdtm);
  		
	  	
 	 	
  		
  		
  		
  		
  		if(rtfdtm.isTreeIncomplete())
	  	{
	  		if(++m_which_rtfdtm < m_rtfdtm_stack.size())
				rtfdtm=(SAX2RTFDTM)m_rtfdtm_stack.elementAt(m_which_rtfdtm);
	  		else
	  		{
		  		rtfdtm=(SAX2RTFDTM)m_dtmManager.getDTM(null,true,null,false,false);
          m_rtfdtm_stack.addElement(rtfdtm); 	
	  		}
 	 	}
	}
		
    return rtfdtm;
  }
  
  
  public void pushRTFContext()
  {
  	m_last_pushed_rtfdtm.push(m_which_rtfdtm);
  	if(null!=m_rtfdtm_stack)
	  	((SAX2RTFDTM)(getRTFDTM())).pushRewindMark();
  }
  
  
  public void popRTFContext()
  {
  	int previous=m_last_pushed_rtfdtm.pop();
  	if(null==m_rtfdtm_stack)
  		return;
  
  	if(m_which_rtfdtm==previous)
  	{
  		if(previous>=0) 
  		{
	  		boolean isEmpty=((SAX2RTFDTM)(m_rtfdtm_stack.elementAt(previous))).popRewindMark();
  		}
  	}
  	else while(m_which_rtfdtm!=previous)
  	{
  		
  		
  		
  		boolean isEmpty=((SAX2RTFDTM)(m_rtfdtm_stack.elementAt(m_which_rtfdtm))).popRewindMark();
  		--m_which_rtfdtm; 
  	}
  }
}
"
org.apache.xalan.lib.sql.ConnectionPoolManager,6,1,0,3,16,0,1,2,5,0.3,69,0.0,0,0.0,0.6,0,0,10.16666667,3,1.3333,1,"


 package org.apache.xalan.lib.sql;

import java.util.Hashtable;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


public class ConnectionPoolManager
{
  
  static Hashtable m_poolTable = null;
  
  static boolean m_isInit = false;

  
  public ConnectionPoolManager( )
  {
    init();
  }

  
  public synchronized void init( )
  {
    
    if (m_isInit == true) return;


    
    
    
    m_poolTable = new Hashtable();

    m_isInit = true;
  }

  
  public synchronized void registerPool( String name, ConnectionPool pool )
  {
    if ( m_poolTable.containsKey(name) )
    {
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_POOL_EXISTS, null)); 
    }

    m_poolTable.put(name, pool);
  }

  
  public synchronized void removePool( String name )
  {
    ConnectionPool pool = getPool(name);

    if (null != pool)
    {
      
      
      
      
      pool.setPoolEnabled(false);


      
      
      
      
      if ( ! pool.hasActiveConnections() ) m_poolTable.remove(name);
    }

  }


  
  public synchronized ConnectionPool getPool( String name )
  {
    return (ConnectionPool) m_poolTable.get(name);
  }

}"
org.apache.xalan.xsltc.dom.ExtendedSAX,0,1,0,1,0,0,1,0,0,2.0,0,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"
package org.apache.xalan.xsltc.dom;

import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.LexicalHandler;

public interface ExtendedSAX extends ContentHandler, LexicalHandler, DTDHandler,
                                     DeclHandler
{ 
}
"
org.apache.xalan.processor.XSLTSchema,6,2,0,27,47,3,5,25,2,0.7875,2717,0.03125,0,0.848484848,0.444444444,1,1,446.5,38,7.0,1,"
package org.apache.xalan.processor;

import java.util.Hashtable;

import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemApplyImport;
import org.apache.xalan.templates.ElemApplyTemplates;
import org.apache.xalan.templates.ElemAttribute;
import org.apache.xalan.templates.ElemCallTemplate;
import org.apache.xalan.templates.ElemChoose;
import org.apache.xalan.templates.ElemComment;
import org.apache.xalan.templates.ElemCopy;
import org.apache.xalan.templates.ElemCopyOf;
import org.apache.xalan.templates.ElemElement;
import org.apache.xalan.templates.ElemExsltFuncResult;
import org.apache.xalan.templates.ElemExsltFunction;
import org.apache.xalan.templates.ElemExtensionDecl;
import org.apache.xalan.templates.ElemExtensionScript;
import org.apache.xalan.templates.ElemFallback;
import org.apache.xalan.templates.ElemForEach;
import org.apache.xalan.templates.ElemIf;
import org.apache.xalan.templates.ElemLiteralResult;
import org.apache.xalan.templates.ElemMessage;
import org.apache.xalan.templates.ElemNumber;
import org.apache.xalan.templates.ElemOtherwise;
import org.apache.xalan.templates.ElemPI;
import org.apache.xalan.templates.ElemParam;
import org.apache.xalan.templates.ElemSort;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemText;
import org.apache.xalan.templates.ElemTextLiteral;
import org.apache.xalan.templates.ElemUnknown;
import org.apache.xalan.templates.ElemValueOf;
import org.apache.xalan.templates.ElemVariable;
import org.apache.xalan.templates.ElemWhen;
import org.apache.xalan.templates.ElemWithParam;
import org.apache.xml.utils.QName;


public class XSLTSchema extends XSLTElementDef
{

  
  XSLTSchema()
  {
    build();
  }

  
  void build()
  {
	
    XSLTAttributeDef hrefAttr = new XSLTAttributeDef(null, ""href"",
                                  XSLTAttributeDef.T_URL, true, false,XSLTAttributeDef.ERROR);
                                  
	
    XSLTAttributeDef elementsAttr = new XSLTAttributeDef(null, ""elements"",
                                      XSLTAttributeDef.T_SIMPLEPATTERNLIST,
                                      true, false, XSLTAttributeDef.ERROR);
                                      
    
    
    
    
    XSLTAttributeDef methodAttr = new XSLTAttributeDef(null, ""method"",
                                    XSLTAttributeDef.T_QNAME, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef versionAttr = new XSLTAttributeDef(null, ""version"",
                                     XSLTAttributeDef.T_NMTOKEN, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef encodingAttr = new XSLTAttributeDef(null, ""encoding"",
                                      XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef omitXmlDeclarationAttr = new XSLTAttributeDef(null,
                                                ""omit-xml-declaration"",
                                                XSLTAttributeDef.T_YESNO,
                                                false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef standaloneAttr = new XSLTAttributeDef(null,
                                        ""standalone"",
                                        XSLTAttributeDef.T_YESNO, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef doctypePublicAttr = new XSLTAttributeDef(null,
                                           ""doctype-public"",
                                           XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef doctypeSystemAttr = new XSLTAttributeDef(null,
                                           ""doctype-system"",
                                           XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef cdataSectionElementsAttr = new XSLTAttributeDef(null,
                                                  ""cdata-section-elements"",
                                                  XSLTAttributeDef.T_QNAMES_RESOLVE_NULL,
                                                  false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef indentAttr = new XSLTAttributeDef(null, ""indent"",
                                    XSLTAttributeDef.T_YESNO, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef mediaTypeAttr = new XSLTAttributeDef(null, ""media-type"",
                                       XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.ERROR);
                                       
                  
    
    
    
    XSLTAttributeDef nameAttrRequired = new XSLTAttributeDef(null, ""name"",
                                          XSLTAttributeDef.T_QNAME, true, false,XSLTAttributeDef.ERROR);
	
    
    
    XSLTAttributeDef nameAVTRequired = new XSLTAttributeDef(null, ""name"",
                                         XSLTAttributeDef.T_AVT_QNAME, true, true,XSLTAttributeDef.WARNING);
            

    
    
    
    XSLTAttributeDef nameAVT_NCNAMERequired = new XSLTAttributeDef(null, ""name"",
                                         XSLTAttributeDef.T_NCNAME, true, true,XSLTAttributeDef.WARNING);
                                        
    
    
    
    XSLTAttributeDef nameAttrOpt_ERROR = new XSLTAttributeDef(null, ""name"",
                                     XSLTAttributeDef.T_QNAME, false, false,XSLTAttributeDef.ERROR);

    
    XSLTAttributeDef useAttr = new XSLTAttributeDef(null, ""use"",
                                 XSLTAttributeDef.T_EXPR, true, false,XSLTAttributeDef.ERROR);
           
    
    XSLTAttributeDef namespaceAVTOpt = new XSLTAttributeDef(null,
                                         ""namespace"",XSLTAttributeDef.T_URL,
                                         false, true,XSLTAttributeDef.WARNING);
    
    XSLTAttributeDef decimalSeparatorAttr = new XSLTAttributeDef(null,
                                              ""decimal-separator"",
                                              XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, ""."");
    XSLTAttributeDef infinityAttr = new XSLTAttributeDef(null, ""infinity"",
                                      XSLTAttributeDef.T_CDATA, false,XSLTAttributeDef.ERROR,""Infinity"");
    XSLTAttributeDef minusSignAttr = new XSLTAttributeDef(null, ""minus-sign"",
                                       XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR,""-"");
    XSLTAttributeDef NaNAttr = new XSLTAttributeDef(null, ""NaN"",
                                 XSLTAttributeDef.T_CDATA, false,XSLTAttributeDef.ERROR, ""NaN"");
    XSLTAttributeDef percentAttr = new XSLTAttributeDef(null, ""percent"",
                                     XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, ""%"");
    XSLTAttributeDef perMilleAttr = new XSLTAttributeDef(null, ""per-mille"",
                                      XSLTAttributeDef.T_CHAR,
                                      false, false,XSLTAttributeDef.ERROR );
    XSLTAttributeDef zeroDigitAttr = new XSLTAttributeDef(null, ""zero-digit"",
                                       XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, ""0"");
    XSLTAttributeDef digitAttr = new XSLTAttributeDef(null, ""digit"",
                                   XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, ""#"");
    XSLTAttributeDef patternSeparatorAttr = new XSLTAttributeDef(null,
                                              ""pattern-separator"",
                                              XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, "";"");
    
    XSLTAttributeDef groupingSeparatorAttr = new XSLTAttributeDef(null,
                                               ""grouping-separator"",
                                               XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR,"","");

                                              
    
    XSLTAttributeDef useAttributeSetsAttr = new XSLTAttributeDef(null,
                                              ""use-attribute-sets"",
                                              XSLTAttributeDef.T_QNAMES,
                                              false, false, XSLTAttributeDef.ERROR);

    
    XSLTAttributeDef testAttrRequired = new XSLTAttributeDef(null, ""test"",   
                                          XSLTAttributeDef.T_EXPR, true, false,XSLTAttributeDef.ERROR);
      
      
    
    
    XSLTAttributeDef selectAttrRequired = new XSLTAttributeDef(null,
                                            ""select"",
                                            XSLTAttributeDef.T_EXPR, true, false,XSLTAttributeDef.ERROR);

    
    
    XSLTAttributeDef selectAttrOpt = new XSLTAttributeDef(null, ""select"",
                                       XSLTAttributeDef.T_EXPR, false, false,XSLTAttributeDef.ERROR);

    
    
    
    XSLTAttributeDef selectAttrDefNode = new XSLTAttributeDef(null, ""select"",
                                           XSLTAttributeDef.T_EXPR, false,XSLTAttributeDef.ERROR, ""node()"");
    
    
    
    XSLTAttributeDef selectAttrDefDot = new XSLTAttributeDef(null, ""select"",
                                          XSLTAttributeDef.T_EXPR, false,XSLTAttributeDef.ERROR, ""."");
    
    XSLTAttributeDef matchAttrRequired = new XSLTAttributeDef(null, ""match"",
                                           XSLTAttributeDef.T_PATTERN, true, false,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef matchAttrOpt = new XSLTAttributeDef(null, ""match"",
                                      XSLTAttributeDef.T_PATTERN, false, false,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef priorityAttr = new XSLTAttributeDef(null, ""priority"",
                                     XSLTAttributeDef.T_NUMBER, false, false,XSLTAttributeDef.ERROR);
                                     
    
    XSLTAttributeDef modeAttr = new XSLTAttributeDef(null, ""mode"",
                                     XSLTAttributeDef.T_QNAME, false, false,XSLTAttributeDef.ERROR);
   
    XSLTAttributeDef spaceAttr =
      new XSLTAttributeDef(Constants.S_XMLNAMESPACEURI, ""space"", false, false, false, XSLTAttributeDef.WARNING,
                           ""default"", Constants.ATTRVAL_STRIP, ""preserve"",
                           Constants.ATTRVAL_PRESERVE);
                           
                         
    XSLTAttributeDef spaceAttrLiteral =
      new XSLTAttributeDef(Constants.S_XMLNAMESPACEURI, ""space"", 
                                          XSLTAttributeDef.T_URL, false, true,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef stylesheetPrefixAttr = new XSLTAttributeDef(null,
                                              ""stylesheet-prefix"",
                                              XSLTAttributeDef.T_CDATA, true, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef resultPrefixAttr = new XSLTAttributeDef(null,
                                          ""result-prefix"",
                                          XSLTAttributeDef.T_CDATA, true, false,XSLTAttributeDef.ERROR);
                                          
    
    XSLTAttributeDef disableOutputEscapingAttr = new XSLTAttributeDef(null,
                                                   ""disable-output-escaping"",
                                                   XSLTAttributeDef.T_YESNO,
                                                   false, false,XSLTAttributeDef.ERROR);
                                                   
	
    XSLTAttributeDef levelAttr = new XSLTAttributeDef(null, ""level"", false, false, false, XSLTAttributeDef.ERROR,
                                   ""single"", Constants.NUMBERLEVEL_SINGLE,
                                   ""multiple"", Constants.NUMBERLEVEL_MULTI,
                                   ""any"", Constants.NUMBERLEVEL_ANY);
    levelAttr.setDefault(""single"");
    XSLTAttributeDef countAttr = new XSLTAttributeDef(null, ""count"",
                                   XSLTAttributeDef.T_PATTERN, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef fromAttr = new XSLTAttributeDef(null, ""from"",
                                  XSLTAttributeDef.T_PATTERN, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef valueAttr = new XSLTAttributeDef(null, ""value"",
                                   XSLTAttributeDef.T_EXPR, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef formatAttr = new XSLTAttributeDef(null, ""format"",
                                    XSLTAttributeDef.T_CDATA, false, true,XSLTAttributeDef.ERROR);
    formatAttr.setDefault(""1"");
    
    
    XSLTAttributeDef langAttr = new XSLTAttributeDef(null, ""lang"",
                                  XSLTAttributeDef.T_NMTOKEN, false, true,XSLTAttributeDef.ERROR);
   
    
    XSLTAttributeDef letterValueAttr = new XSLTAttributeDef(null,
                                         ""letter-value"",
                                         false, true, false, XSLTAttributeDef.ERROR,
                                         ""alphabetic"", Constants.NUMBERLETTER_ALPHABETIC,
                                         ""traditional"", Constants.NUMBERLETTER_TRADITIONAL);
    
    XSLTAttributeDef groupingSeparatorAVT = new XSLTAttributeDef(null,
                                              ""grouping-separator"",
                                              XSLTAttributeDef.T_CHAR, false, true,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef groupingSizeAttr = new XSLTAttributeDef(null,
                                          ""grouping-size"",
                                          XSLTAttributeDef.T_NUMBER, false, true,XSLTAttributeDef.ERROR);
   
   
    XSLTAttributeDef dataTypeAttr = new XSLTAttributeDef(null, ""data-type"", false, true, true, XSLTAttributeDef.ERROR,
                                    ""text"", Constants.SORTDATATYPE_TEXT ,""number"", Constants.SORTDATATYPE_TEXT);
	dataTypeAttr.setDefault(""text"");
	
	
    XSLTAttributeDef orderAttr = new XSLTAttributeDef(null, ""order"", false, true, false,XSLTAttributeDef.ERROR,
                                    ""ascending"", Constants.SORTORDER_ASCENDING, 
                                    ""descending"", Constants.SORTORDER_DESCENDING);
    orderAttr.setDefault(""ascending"");

    
    XSLTAttributeDef caseOrderAttr = new XSLTAttributeDef(null, ""case-order"", false, true, false,XSLTAttributeDef.ERROR,
                                       ""upper-first"", Constants.SORTCASEORDER_UPPERFIRST ,
                                       ""lower-first"", Constants.SORTCASEORDER_LOWERFIRST);
	    
    
    XSLTAttributeDef terminateAttr = new XSLTAttributeDef(null, ""terminate"",
                                       XSLTAttributeDef.T_YESNO, false, false,XSLTAttributeDef.ERROR);
    terminateAttr.setDefault(""no"");

	
    XSLTAttributeDef xslExcludeResultPrefixesAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL,
                           ""exclude-result-prefixes"",
                           XSLTAttributeDef.T_STRINGLIST, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef xslExtensionElementPrefixesAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL,
                           ""extension-element-prefixes"",
                           XSLTAttributeDef.T_PREFIX_URLLIST, false, false,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef xslUseAttributeSetsAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL, ""use-attribute-sets"",
                           XSLTAttributeDef.T_QNAMES, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef xslVersionAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL, ""version"",
                           XSLTAttributeDef.T_NMTOKEN, false, false,XSLTAttributeDef.ERROR);
                           
    XSLTElementDef charData = new XSLTElementDef(this, null, ""text()"",
                                null , null , null,  
                                new ProcessorCharacters(),
                                ElemTextLiteral.class );

    charData.setType(XSLTElementDef.T_PCDATA);

    XSLTElementDef whiteSpaceOnly = new XSLTElementDef(this, null, ""text()"",
                                      null , null ,
                                      null,  
                                      null,
                                      ElemTextLiteral.class );

    charData.setType(XSLTElementDef.T_PCDATA);

    XSLTAttributeDef resultAttr = new XSLTAttributeDef(null, ""*"",
                                    XSLTAttributeDef.T_AVT, false, true,XSLTAttributeDef.WARNING);
    XSLTAttributeDef xslResultAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL, ""*"",
                           XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.WARNING);
                           
    XSLTElementDef[] templateElements = new XSLTElementDef[23];
    XSLTElementDef[] templateElementsAndParams = new XSLTElementDef[24];
    XSLTElementDef[] templateElementsAndSort = new XSLTElementDef[24];
    
    XSLTElementDef[] exsltFunctionElements = new XSLTElementDef[24];
    
    XSLTElementDef[] charTemplateElements = new XSLTElementDef[15];
    XSLTElementDef resultElement = new XSLTElementDef(this, null, ""*"",
                                     null ,
                                     templateElements ,
                                     new XSLTAttributeDef[]{
                                       spaceAttrLiteral, 
                                       xslExcludeResultPrefixesAttr,
                                       xslExtensionElementPrefixesAttr,
                                       xslUseAttributeSetsAttr,
                                       xslVersionAttr,
                                       xslResultAttr,
                                       resultAttr }, 
                                        new ProcessorLRE(),
                                     ElemLiteralResult.class , 20, true);
    XSLTElementDef unknownElement =
      new XSLTElementDef(this, ""*"", ""unknown"", null ,
                         templateElementsAndParams ,
                         new XSLTAttributeDef[]{ xslExcludeResultPrefixesAttr,
                                                 xslExtensionElementPrefixesAttr,
                                                 xslUseAttributeSetsAttr,
                                                 xslVersionAttr,
                                                 xslResultAttr,
                                                 resultAttr }, 
                                                                                                 new ProcessorUnknown(),
                         ElemUnknown.class , 20, true);
    XSLTElementDef xslValueOf = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""value-of"",
                                  null , null ,
                                  new XSLTAttributeDef[]{ selectAttrRequired,
                                                          disableOutputEscapingAttr }, 
                                               new ProcessorTemplateElem(),
                                  ElemValueOf.class , 20, true);
    XSLTElementDef xslCopyOf = new XSLTElementDef(this,
                                 Constants.S_XSLNAMESPACEURL, ""copy-of"",
                                 null , null ,
                                 new XSLTAttributeDef[]{ selectAttrRequired },
                                 new ProcessorTemplateElem(),
                                 ElemCopyOf.class , 20, true);
    XSLTElementDef xslNumber = new XSLTElementDef(this,
                                 Constants.S_XSLNAMESPACEURL, ""number"",
                                 null , null ,
                                 new XSLTAttributeDef[]{ levelAttr,
                                                         countAttr,
                                                         fromAttr,
                                                         valueAttr,
                                                         formatAttr,
                                                         langAttr,
                                                         letterValueAttr,
                                                         groupingSeparatorAVT,
                                                         groupingSizeAttr }, 
                                        new ProcessorTemplateElem(),
                                 ElemNumber.class , 20, true);

    
    
    XSLTElementDef xslSort = new XSLTElementDef(this,
                                                Constants.S_XSLNAMESPACEURL,
                                                ""sort"", null ,
                                                null ,
                                                new XSLTAttributeDef[]{
                                                  selectAttrDefDot,
                                                  langAttr,
                                                  dataTypeAttr,
                                                  orderAttr,
                                                  caseOrderAttr }, 
                                       new ProcessorTemplateElem(),
                                                ElemSort.class, 19, true );
    XSLTElementDef xslWithParam = new XSLTElementDef(this,
                                    Constants.S_XSLNAMESPACEURL,
                                    ""with-param"", null ,
                                    templateElements ,  
                                    new XSLTAttributeDef[]{ nameAttrRequired,
                                                            selectAttrOpt }, new ProcessorTemplateElem(),
                                                                             ElemWithParam.class , 19, true);
    XSLTElementDef xslApplyTemplates = new XSLTElementDef(this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""apply-templates"", null ,
                                         new XSLTElementDef[]{ xslSort,
                                                               xslWithParam } , new XSLTAttributeDef[]{
                                                                 selectAttrDefNode,
                                                                 modeAttr }, 
                                                                        new ProcessorTemplateElem(),
                                         ElemApplyTemplates.class , 20, true);
    XSLTElementDef xslApplyImports =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""apply-imports"",
                         null , null ,
                         new XSLTAttributeDef[]{},
                         new ProcessorTemplateElem(),
                         ElemApplyImport.class );
    XSLTElementDef xslForEach = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""for-each"",
                                  null , templateElementsAndSort,  
                                  new XSLTAttributeDef[]{ selectAttrRequired,
                                                          spaceAttr }, 
                                               new ProcessorTemplateElem(),
                                  ElemForEach.class , true, false, true, 20, true);
    XSLTElementDef xslIf = new XSLTElementDef(this,
                                              Constants.S_XSLNAMESPACEURL,
                                              ""if"", null ,
                                              templateElements ,  
                                              new XSLTAttributeDef[]{
                                                testAttrRequired,
                                                spaceAttr }, new ProcessorTemplateElem(),
                                                             ElemIf.class , 20, true);
    XSLTElementDef xslWhen =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""when"",
                         null , templateElements ,  
                                                new XSLTAttributeDef[]{
                                                  testAttrRequired,
                                                  spaceAttr }, new ProcessorTemplateElem(),
                                                               ElemWhen.class ,
                                                                                                false, true, 1, true);
    XSLTElementDef xslOtherwise = new XSLTElementDef(this,
                                    Constants.S_XSLNAMESPACEURL, ""otherwise"",
                                    null ,
                                    templateElements ,  
                                    new XSLTAttributeDef[]{ spaceAttr },
                                    new ProcessorTemplateElem(),
                                    ElemOtherwise.class ,
                                                       false, false, 2, false);
    XSLTElementDef xslChoose = new XSLTElementDef(this,
                                 Constants.S_XSLNAMESPACEURL, ""choose"",
                                 null ,
                                 new XSLTElementDef[]{ xslWhen,
                                                       xslOtherwise } , 
                                        new XSLTAttributeDef[]{ spaceAttr },
                                 new ProcessorTemplateElem(),
                                 ElemChoose.class , true, false, true, 20, true);                                
    XSLTElementDef xslAttribute = new XSLTElementDef(this,
                                    Constants.S_XSLNAMESPACEURL, ""attribute"",
                                    null ,
                                    charTemplateElements ,  
                                    new XSLTAttributeDef[]{ nameAVTRequired,
                                                            namespaceAVTOpt,
                                                            spaceAttr }, 
                                    new ProcessorTemplateElem(),
                                    ElemAttribute.class , 20, true);
    XSLTElementDef xslCallTemplate =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""call-template"",
                         null ,
                         new XSLTElementDef[]{ xslWithParam } ,
                         new XSLTAttributeDef[]{ nameAttrRequired },
                         new ProcessorTemplateElem(),
                         ElemCallTemplate.class , 20, true);
    XSLTElementDef xslVariable = new XSLTElementDef(this,
                                   Constants.S_XSLNAMESPACEURL, ""variable"",
                                   null ,
                                   templateElements ,  
                                   new XSLTAttributeDef[]{ nameAttrRequired,
                                                           selectAttrOpt }, 
                                  new ProcessorTemplateElem(),
                                   ElemVariable.class , 20, true);
    XSLTElementDef xslParam = new XSLTElementDef(this,
                                Constants.S_XSLNAMESPACEURL, ""param"",
                                null ,
                                templateElements ,  
                                new XSLTAttributeDef[]{ nameAttrRequired,
                                                        selectAttrOpt }, 
                                       new ProcessorTemplateElem(),
                                ElemParam.class , 19, true);
    XSLTElementDef xslText =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""text"",
                         null ,
                         new XSLTElementDef[]{ charData } ,
                         new XSLTAttributeDef[]{ disableOutputEscapingAttr },
                         new ProcessorText(),
                         ElemText.class , 20, true);
    XSLTElementDef xslProcessingInstruction =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL,
                         ""processing-instruction"", null ,
                         charTemplateElements ,  
                         new XSLTAttributeDef[]{
                                                  nameAVT_NCNAMERequired,
                                                  spaceAttr }, 
                                        new ProcessorTemplateElem(),
                          ElemPI.class , 20, true);
    XSLTElementDef xslElement = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""element"",
                                  null ,
                                  templateElements ,  
                                  new XSLTAttributeDef[]{ nameAVTRequired,
                                                          namespaceAVTOpt,
                                                          useAttributeSetsAttr,
                                                          spaceAttr }, 
                                               new ProcessorTemplateElem(),
                                  ElemElement.class , 20, true);
    XSLTElementDef xslComment = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""comment"",
                                  null ,
                                  charTemplateElements ,  
                                  new XSLTAttributeDef[]{ spaceAttr },
                                  new ProcessorTemplateElem(),
                                  ElemComment.class , 20, true);
    XSLTElementDef xslCopy =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""copy"",
                         null , templateElements ,  
                          new XSLTAttributeDef[]{
                                                  spaceAttr,
                                                  useAttributeSetsAttr }, 
                                        new ProcessorTemplateElem(),
                          ElemCopy.class , 20, true);
    XSLTElementDef xslMessage = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""message"",
                                  null ,
                                  templateElements ,  
                                  new XSLTAttributeDef[]{ terminateAttr },
                                  new ProcessorTemplateElem(),
                                  ElemMessage.class , 20, true);
    XSLTElementDef xslFallback = new XSLTElementDef(this,
                                   Constants.S_XSLNAMESPACEURL, ""fallback"",
                                   null ,
                                   templateElements ,  
                                   new XSLTAttributeDef[]{ spaceAttr },
                                   new ProcessorTemplateElem(),
                                   ElemFallback.class , 20, true);
    
    XSLTElementDef exsltFunction =
                                  new XSLTElementDef(this, 
                                  Constants.S_EXSLT_FUNCTIONS_URL, 
                                  ""function"",
                                  null ,
                                  exsltFunctionElements ,
                                  new XSLTAttributeDef[]{ nameAttrRequired },
                                  new ProcessorExsltFunction(),
                                  ElemExsltFunction.class );
    XSLTElementDef exsltResult =
                                  new XSLTElementDef(this, 
                                  Constants.S_EXSLT_FUNCTIONS_URL, 
                                  ""result"",
                                  null ,
                                  templateElements ,
                                  new XSLTAttributeDef[]{ selectAttrOpt },
                                  new ProcessorExsltFuncResult(),
                                  ElemExsltFuncResult.class  );            
    

    int i = 0;

    templateElements[i++] = charData;  

    
    templateElements[i++] = xslApplyTemplates;
    templateElements[i++] = xslCallTemplate;
    templateElements[i++] = xslApplyImports;
    templateElements[i++] = xslForEach;
    templateElements[i++] = xslValueOf;
    templateElements[i++] = xslCopyOf;
    templateElements[i++] = xslNumber;
    templateElements[i++] = xslChoose;
    templateElements[i++] = xslIf;
    templateElements[i++] = xslText;
    templateElements[i++] = xslCopy;
    templateElements[i++] = xslVariable;
    templateElements[i++] = xslMessage;
    templateElements[i++] = xslFallback;

    
    templateElements[i++] = xslProcessingInstruction;
    templateElements[i++] = xslComment;
    templateElements[i++] = xslElement;
    templateElements[i++] = xslAttribute;
    templateElements[i++] = resultElement;
    templateElements[i++] = unknownElement;
    templateElements[i++] = exsltFunction;
    templateElements[i++] = exsltResult;

    int k;

    for (k = 0; k < i; k++)
    {
      templateElementsAndParams[k] = templateElements[k];
      templateElementsAndSort[k] = templateElements[k];
      exsltFunctionElements[k]     = templateElements[k];

    }

    templateElementsAndParams[k] = xslParam;
    templateElementsAndSort[k] = xslSort;
    exsltFunctionElements[k]   = xslParam;

    i = 0;
    charTemplateElements[i++] = charData;  

    
    charTemplateElements[i++] = xslApplyTemplates;
    charTemplateElements[i++] = xslCallTemplate;
    charTemplateElements[i++] = xslApplyImports;
    charTemplateElements[i++] = xslForEach;
    charTemplateElements[i++] = xslValueOf;
    charTemplateElements[i++] = xslCopyOf;
    charTemplateElements[i++] = xslNumber;
    charTemplateElements[i++] = xslChoose;
    charTemplateElements[i++] = xslIf;
    charTemplateElements[i++] = xslText;
    charTemplateElements[i++] = xslCopy;
    charTemplateElements[i++] = xslVariable;
    charTemplateElements[i++] = xslMessage;
    charTemplateElements[i++] = xslFallback;

    XSLTElementDef importDef = new XSLTElementDef(this,
                                 Constants.S_XSLNAMESPACEURL, ""import"",
                                 null , null ,
                                 new XSLTAttributeDef[]{ hrefAttr },  
                                 new ProcessorImport(),
                                 null ,
                                        1, true);
    XSLTElementDef includeDef = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""include"",
                                  null , null ,  
                                  new XSLTAttributeDef[]{ hrefAttr },
                                  new ProcessorInclude(),
                                  null ,
                                               20, true);
    
    XSLTAttributeDef[] scriptAttrs = new XSLTAttributeDef[]{
    					    new XSLTAttributeDef(null, ""lang"", XSLTAttributeDef.T_NMTOKEN,
                                                                 true, false,XSLTAttributeDef.WARNING),
                                            new XSLTAttributeDef(null, ""src"", XSLTAttributeDef.T_URL, 
                                            			 false, false,XSLTAttributeDef.WARNING)};

    XSLTAttributeDef[] componentAttrs = new XSLTAttributeDef[]{ 
                                            new XSLTAttributeDef(null, ""prefix"", XSLTAttributeDef.T_NMTOKEN, 
                                            			 true, false,XSLTAttributeDef.WARNING),
                                            new XSLTAttributeDef(null, ""elements"", XSLTAttributeDef.T_STRINGLIST, 
                                            			 false, false,XSLTAttributeDef.WARNING),
                                            new XSLTAttributeDef(null, ""functions"", XSLTAttributeDef.T_STRINGLIST, 
                                            			 false, false,XSLTAttributeDef.WARNING) };

    XSLTElementDef[] topLevelElements = new XSLTElementDef[]
                                 {includeDef,
                                  importDef,
                                  
                                  whiteSpaceOnly,
                                  unknownElement,
                                  new XSLTElementDef(
                                         this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""strip-space"",
                                         null ,
                                         null ,
                                         new XSLTAttributeDef[]{
                                                elementsAttr },
                                                new ProcessorStripSpace(),
                                         null , 20, true),
                                  new XSLTElementDef(
                                         this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""preserve-space"",
                                         null ,
                                         null ,
                                         new XSLTAttributeDef[]{
                                                 elementsAttr },
                                                 new ProcessorPreserveSpace(),
                                         null , 20, true),
                                  new XSLTElementDef(
                                         this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""output"",
                                         null ,
                                         null ,
                                         new XSLTAttributeDef[]{
                                                  methodAttr,
                                                  versionAttr,
                                                  encodingAttr,
                                                  omitXmlDeclarationAttr,
                                                  standaloneAttr,
                                                  doctypePublicAttr,
                                                  doctypeSystemAttr,
                                                  cdataSectionElementsAttr,
                                                  indentAttr,
                                                  mediaTypeAttr,
                                                  XSLTAttributeDef.m_foreignAttr }, 
                                          new ProcessorOutputElem(), null , 20, true), 
                                  new XSLTElementDef(
                                          this,
                                          Constants.S_XSLNAMESPACEURL,
                                          ""key"",
                                          null ,
                                          null ,  
                                          new XSLTAttributeDef[]{ nameAttrRequired,
                                                  matchAttrRequired,
                                                  useAttr }, 
                                          new ProcessorKey(), null , 20, true),
                                  new XSLTElementDef(
                                          this,
                                          Constants.S_XSLNAMESPACEURL,
                                          ""decimal-format"",
                                          null ,
                                          null ,  
                                          new XSLTAttributeDef[]{
                                                  nameAttrOpt_ERROR,
                                                  decimalSeparatorAttr,
                                                  groupingSeparatorAttr,
                                                  infinityAttr,
                                                  minusSignAttr,
                                                  NaNAttr,
                                                  percentAttr,
                                                  perMilleAttr,
                                                  zeroDigitAttr,
                                                  digitAttr,
                                                  patternSeparatorAttr }, 
                                           new ProcessorDecimalFormat(),
                                           null , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""attribute-set"",
                                           null ,
                                           new XSLTElementDef[]{
                                                   xslAttribute } ,
                                           new XSLTAttributeDef[]{
                                                   nameAttrRequired,
                                                   useAttributeSetsAttr }, 
                                           new ProcessorAttributeSet(),
                                           null , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""variable"",
                                           null ,
                                           templateElements ,
                                           new XSLTAttributeDef[]{
                                                   nameAttrRequired,
                                                   selectAttrOpt }, 
                                           new ProcessorGlobalVariableDecl(),
                                           ElemVariable.class , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""param"",
                                           null ,
                                           templateElements ,
                                           new XSLTAttributeDef[]{
                                                   nameAttrRequired,
                                                   selectAttrOpt }, 
                                           new ProcessorGlobalParamDecl(),
                                           ElemParam.class , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""template"",
                                           null ,
                                           templateElementsAndParams ,
                                           new XSLTAttributeDef[]{
                                                   matchAttrOpt,
                                                   nameAttrOpt_ERROR,
                                                   priorityAttr,
                                                   modeAttr,
                                                   spaceAttr }, 
                                           new ProcessorTemplate(), ElemTemplate.class , true, 20, true), 
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""namespace-alias"",
                                           null ,
                                          null ,  
                                           new XSLTAttributeDef[]{ 
                                                   stylesheetPrefixAttr,
                                                   resultPrefixAttr }, 
                                           new ProcessorNamespaceAlias(), null , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_BUILTIN_EXTENSIONS_URL,
                                           ""component"",
                                           null ,
                                           new XSLTElementDef[]{
                                                    new XSLTElementDef(
                                                        this,
                                                        Constants.S_BUILTIN_EXTENSIONS_URL,
                                                        ""script"",
                                                        null ,
                                                    	new XSLTElementDef[]{ 
                                                        charData } ,
                                                        scriptAttrs, 
                                                        new ProcessorLRE(),
                                                        ElemExtensionScript.class , 20, true) },  
                                           componentAttrs, 
                                           new ProcessorLRE(), ElemExtensionDecl.class ),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_BUILTIN_OLD_EXTENSIONS_URL,
                                           ""component"",
                                           null ,
                                           new XSLTElementDef[]{
                                                    new XSLTElementDef(
                                                        this,
                                                        Constants.S_BUILTIN_OLD_EXTENSIONS_URL,
                                                        ""script"",
                                                        null ,
                                                    	new XSLTElementDef[]{ 
                                                        charData } ,
                                                        scriptAttrs, 
                                                        new ProcessorLRE(),
                                                        ElemExtensionScript.class , 20, true) },  
                                           componentAttrs, 
                                           new ProcessorLRE(), ElemExtensionDecl.class ),
                                  exsltFunction};  
    
    XSLTAttributeDef excludeResultPrefixesAttr =
      new XSLTAttributeDef(null, ""exclude-result-prefixes"",
                           XSLTAttributeDef.T_STRINGLIST, false,false,XSLTAttributeDef.WARNING);
    XSLTAttributeDef extensionElementPrefixesAttr =
      new XSLTAttributeDef(null, ""extension-element-prefixes"",
                           XSLTAttributeDef.T_PREFIX_URLLIST, false,false,XSLTAttributeDef.WARNING);
    XSLTAttributeDef idAttr = new XSLTAttributeDef(null, ""id"",
                                XSLTAttributeDef.T_CDATA, false,false,XSLTAttributeDef.WARNING);
    XSLTAttributeDef versionAttrRequired = new XSLTAttributeDef(null,
                                             ""version"",
                                             XSLTAttributeDef.T_NMTOKEN,
                                             true,false,XSLTAttributeDef.WARNING);
    XSLTElementDef stylesheetElemDef = new XSLTElementDef(this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""stylesheet"", ""transform"",
                                         topLevelElements,
                                         new XSLTAttributeDef[]{
                                           extensionElementPrefixesAttr,
                                           excludeResultPrefixesAttr,
                                           idAttr,
                                           versionAttrRequired,
                                           spaceAttr }, new ProcessorStylesheetElement(),  
                                         null  ,
                                         true, -1, false);

    importDef.setElements(new XSLTElementDef[]{ stylesheetElemDef,
                                                resultElement,
                                                unknownElement });
    includeDef.setElements(new XSLTElementDef[]{ stylesheetElemDef,
                                                 resultElement,
                                                 unknownElement });
    build(null, null, null, new XSLTElementDef[]{ stylesheetElemDef,
                                                  whiteSpaceOnly,
                                                  resultElement,
                                                  unknownElement }, null,
                                                                    new ProcessorStylesheetDoc(),  
                                                                    null  
                                                                      );
  }

  
  private Hashtable m_availElems = new Hashtable();
  
  
  public Hashtable getElemsAvailable() 
  {
    return m_availElems;
  }

  
  void addAvailableElement(QName elemName)
  {
    m_availElems.put(elemName, elemName);
  }

  
  public boolean elementAvailable(QName elemName)
  {
    return m_availElems.containsKey(elemName);
  }
}

"
org.apache.xalan.xsltc.compiler.util.ErrorMessages_no,3,4,0,1,4,1,0,1,2,0.5,1014,1.0,0,0.975,1.0,0,0,336.6666667,1,0.3333,0,"

package org.apache.xalan.xsltc.compiler.util;


public final class ErrorMessages_no extends ErrorMessages {
    
    
    
    private static final String m_errorMessages[][] = { 
	{ErrorMsg.MULTIPLE_STYLESHEET_ERR,
	""En fil kan bare innehold ett stilark.""},
	{ErrorMsg.TEMPLATE_REDEF_ERR,	
	""<xsl:template> ''{0}'' er allerede definert i dette stilarket.""},
	{ErrorMsg.TEMPLATE_UNDEF_ERR,
	""<xsl:template> ''{0}'' er ikke definert i dette stilarket.""},
	{ErrorMsg.VARIABLE_REDEF_ERR,	
	""Variabel ''{0}'' er allerede definert.""},
	{ErrorMsg.VARIABLE_UNDEF_ERR,
	""Variabel eller parameter ''{0}'' er ikke definert.""},
	{ErrorMsg.CLASS_NOT_FOUND_ERR,
	""Finner ikke klassen ''{0}''.""},
	{ErrorMsg.METHOD_NOT_FOUND_ERR,
	""Finner ikke ekstern funksjon ''{0}'' (må v e6re deklarert både 'static' og 'public').""},
	{ErrorMsg.ARGUMENT_CONVERSION_ERR,
	""Kan ikke konvertere argument/retur type i kall til funksjon ''{0}''""},
	{ErrorMsg.FILE_NOT_FOUND_ERR,
	""Finner ikke fil eller URI ''{0}''.""},
	{ErrorMsg.INVALID_URI_ERR,
	""Ugyldig URI ''{0}''.""},
	{ErrorMsg.FILE_ACCESS_ERR,
	""Kan ikke åpne fil eller URI ''{0}''.""},
	{ErrorMsg.MISSING_ROOT_ERR,
	""Forvented <xsl:stylesheet> eller <xsl:transform> element.""},
	{ErrorMsg.NAMESPACE_UNDEF_ERR,
	""Prefiks ''{0}'' er ikke deklarert.""},
	{ErrorMsg.FUNCTION_RESOLVE_ERR,
	""Kunne ikke resolvere kall til funksjon ''{0}''.""},
	{ErrorMsg.NEED_LITERAL_ERR,
	""Argument til ''{0}'' må v e6re ordrett tekst.""},
	{ErrorMsg.XPATH_PARSER_ERR,
	""Kunne ikke tolke XPath uttrykk ''{0}''.""},
	{ErrorMsg.REQUIRED_ATTR_ERR,
	""Nødvendig attributt ''{0}'' er ikke deklarert.""},
	{ErrorMsg.ILLEGAL_CHAR_ERR,
	""Ugyldig bokstav/tegn ''{0}'' i XPath uttrykk.""},
	{ErrorMsg.ILLEGAL_PI_ERR,
	""Ugyldig navn ''{0}'' for prosesserings-instruksjon.""},
	{ErrorMsg.STRAY_ATTRIBUTE_ERR,
	""Attributt ''{0}'' utenfor element.""},
	{ErrorMsg.ILLEGAL_ATTRIBUTE_ERR,
	""Ugyldig attributt ''{0}''.""},
	{ErrorMsg.CIRCULAR_INCLUDE_ERR,
	""Sirkul  e6 import/include; stilark ''{0}'' er alt lest.""},
	{ErrorMsg.RESULT_TREE_SORT_ERR,
	""Result-tre fragmenter kan ikke sorteres (<xsl:sort> elementer vil ""+
	""bli ignorert). Du må sortere nodene mens du bygger treet.""},
	{ErrorMsg.SYMBOLS_REDEF_ERR,
	""Formatterings-symboler ''{0}'' er alt definert.""},
	{ErrorMsg.XSL_VERSION_ERR,
	""XSL versjon ''{0}'' er ikke støttet av XSLTC.""},
	{ErrorMsg.CIRCULAR_VARIABLE_ERR,
	""Sirkul e6r variabel/parameter referanse i ''{0}''.""},
	{ErrorMsg.ILLEGAL_BINARY_OP_ERR,
	""Ugyldig operator for bin e6rt uttrykk.""},
	{ErrorMsg.ILLEGAL_ARG_ERR,
	""Ugyldig parameter i funksjons-kall.""},
	{ErrorMsg.DOCUMENT_ARG_ERR,
	""Andre argument til document() må v e6re et node-sett.""},
	{ErrorMsg.MISSING_WHEN_ERR,
	""Du må deklarere minst ett <xsl:when> element innenfor <xsl:choose>.""},
	{ErrorMsg.MULTIPLE_OTHERWISE_ERR,
	""Kun ett <xsl:otherwise> element kan deklareres innenfor <xsl:choose>.""},
	{ErrorMsg.STRAY_OTHERWISE_ERR,
	""<xsl:otherwise> kan kun benyttes innenfor <xsl:choose>.""},
	{ErrorMsg.STRAY_WHEN_ERR,
	""<xsl:when> kan kun benyttes innenfor <xsl:choose>.""},
	{ErrorMsg.WHEN_ELEMENT_ERR,	
	""Kun <xsl:when> og <xsl:otherwise> kan benyttes innenfor <xsl:choose>.""},
	{ErrorMsg.UNNAMED_ATTRIBSET_ERR,
	""<xsl:attribute-set> element manger 'name' attributt.""},
	{ErrorMsg.ILLEGAL_CHILD_ERR,
	""Ugyldig element.""},
	{ErrorMsg.ILLEGAL_ELEM_NAME_ERR,
	""''{0}'' er ikke et gyldig navn for et element.""},
	{ErrorMsg.ILLEGAL_ATTR_NAME_ERR,
	""''{0}'' er ikke et gyldig navn for et attributt.""},
	{ErrorMsg.ILLEGAL_TEXT_NODE_ERR,
	""Du kan ikke plassere tekst utenfor et <xsl:stylesheet> element.""},
	{ErrorMsg.SAX_PARSER_CONFIG_ERR,
	""JAXP parser er ikke korrekt konfigurert.""},
	{ErrorMsg.INTERNAL_ERR,
	""XSLTC-intern feil: ''{0}''""},
	{ErrorMsg.UNSUPPORTED_XSL_ERR,
	""Støtter ikke XSL element ''{0}''.""},
	{ErrorMsg.UNSUPPORTED_EXT_ERR,
	""XSLTC støtter ikke utvidet funksjon ''{0}''.""},
	{ErrorMsg.MISSING_XSLT_URI_ERR,
	""Dette dokumentet er ikke et XSL stilark ""+
	""(xmlns:xsl='http:
	{ErrorMsg.MISSING_XSLT_TARGET_ERR,
	""Kan ikke finne stilark ved navn ''{0}'' i dette dokumentet.""},
	{ErrorMsg.NOT_IMPLEMENTED_ERR,
	""Ikke implementert/gjenkjent: ''{0}''.""},
	{ErrorMsg.NOT_STYLESHEET_ERR,
	""Dokumentet inneholder ikke et XSL stilark""},
	{ErrorMsg.ELEMENT_PARSE_ERR,
	""Kan ikke tolke element ''{0}''""},
	{ErrorMsg.KEY_USE_ATTR_ERR,
	""'use'-attributtet i <xsl:key> må v e6re node, node-sett, tekst eller nummer.""},
	{ErrorMsg.OUTPUT_VERSION_ERR,
	""Det genererte XML dokumentet må gis versjon 1.0""},
	{ErrorMsg.ILLEGAL_RELAT_OP_ERR,
	""Ugyldig operator for relasjons-uttrykk.""},
	{ErrorMsg.ATTRIBSET_UNDEF_ERR,
	""Finner ikke <xsl:attribute-set> element med navn ''{0}''.""},
	{ErrorMsg.ATTR_VAL_TEMPLATE_ERR,
	""Kan ikke tolke attributt ''{0}''.""},
	{ErrorMsg.UNKNOWN_SIG_TYPE_ERR,
	""Ukjent data-type i signatur for klassen ''{0}''.""},
	{ErrorMsg.DATA_CONVERSION_ERR,
	""Kan ikke oversette mellom data-type ''{0}'' og ''{1}''.""},

	{ErrorMsg.NO_TRANSLET_CLASS_ERR,
	""Dette Templates objected inneholder ingen translet klasse definisjon.""},
	{ErrorMsg.NO_MAIN_TRANSLET_ERR,
	""Dette Templates objected inneholder ingen klasse ved navn ''{0}''.""},
	{ErrorMsg.TRANSLET_CLASS_ERR,
	""Kan ikke laste translet-klasse ''{0}''.""},
	{ErrorMsg.TRANSLET_OBJECT_ERR,
	""Translet klassen er lastet man kan instansieres.""},
	{ErrorMsg.ERROR_LISTENER_NULL_ERR,
	""ErrorListener for ''{0}'' forsøkt satt til 'null'.""},
	{ErrorMsg.JAXP_UNKNOWN_SOURCE_ERR,
	""Kun StreamSource, SAXSource og DOMSOurce er støttet av XSLTC""},
	{ErrorMsg.JAXP_NO_SOURCE_ERR,
	""Source objekt sendt til ''{0}'' har intet innhold.""},
	{ErrorMsg.JAXP_COMPILE_ERR,
	""Kan ikke kompilere stilark.""},
	{ErrorMsg.JAXP_INVALID_ATTR_ERR,
	""TransformerFactory gjenkjenner ikke attributtet ''{0}''.""},
	{ErrorMsg.JAXP_SET_RESULT_ERR,
	""setResult() må kalles før startDocument().""},
	{ErrorMsg.JAXP_NO_TRANSLET_ERR,
	""Transformer objektet inneholder ikken noen translet instans.""},
	{ErrorMsg.JAXP_NO_HANDLER_ERR,
	""Ingen 'handler' er satt for å ta imot generert dokument.""},
	{ErrorMsg.JAXP_NO_RESULT_ERR,
	""Result objektet sendt til ''{0}'' er ikke gyldig.""},
	{ErrorMsg.JAXP_UNKNOWN_PROP_ERR,
	""Forsøker å lese ugyldig attributt ''{0}'' fra Transformer.""},
	{ErrorMsg.SAX2DOM_ADAPTER_ERR,
	""Kan ikke instansiere SAX2DOM adapter: ''{0}''.""},
	{ErrorMsg.XSLTC_SOURCE_ERR,
	""XSLTCSource.build() kalt uten at 'systemId' er definert.""},

	{ErrorMsg.COMPILE_STDIN_ERR,
	""Du kan ikke bruke -i uten å også angi klasse-navn med -o.""},
	{ErrorMsg.COMPILE_USAGE_STR,
	""Bruk:
"" + 
	""   xsltc [-o <klasse>] [-d <katalog>] [-j <arkiv>]
""+
	""         [-p <pakke>] [-x] [-s] [-u] <stilark>|-i

""+
	""   Der:  <klasse> er navnet du vil gi den kompilerte java klassen.
""+
	""         <stilark> er ett eller flere XSL stilark, eller dersom -u
""+
	""         er benyttet, en eller flere URL'er til stilark.
""+
	""         <katalog> katalog der klasse filer vil plasseres.
""+
	""         <arkiv> er en JAR-fil der klassene vil plasseres
""+
	""         <pakke> er an Java 'package' klassene vil legges i.

""+
	""   Annet:
""+
	""         -i tvinger kompilatoren til å lese fra stdin.
""+
	""         -o ignoreres dersom flere enn ett silark kompileres.
""+
	""         -x slår på debug meldinger.
""+
	""         -s blokkerer alle kall til System.exit().""},
	{ErrorMsg.TRANSFORM_USAGE_STR,
	""Bruk: 
"" +
	""   xslt  [-j <arkiv>] {-u <url> | <dokument>} <klasse>
""+
	""         [<param>=<verdi> ...]

"" +
	""   Der:  <dokument> er XML dokumentet som skal behandles.
"" +
	""         <url> er en URL til XML dokumentet som skal behandles.
"" +
	""         <klasse> er Java klassen som skal benyttes.
"" +
	""         <arkiv> er en JAR-fil som klassen leses fra.
""+
	""   Annet:
""+
	""         -x slår på debug meldinger.
""+
	""         -s blokkerer alle kall til System.exit().""},

	{ErrorMsg.STRAY_SORT_ERR,
	""<xsl:sort> kan bare brukes under <xsl:for-each> eller <xsl:apply-templates>.""},
	{ErrorMsg.UNSUPPORTED_ENCODING,
	""Karaktersett ''{0}'' er ikke støttet av denne JVM.""},
	{ErrorMsg.SYNTAX_ERR,
	""Syntax error in ''{0}''.""}  
    };

    public Object[][] getContents() {
        return m_errorMessages;
    }
}
"
org.apache.xalan.xsltc.compiler.AncestorPattern,10,6,0,30,48,1,2,28,10,0.518518519,302,1.0,2,0.925233645,0.242857143,4,5,28.9,8,1.6,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFLT;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class AncestorPattern extends RelativePathPattern {

    private final Pattern _left;	
    private final RelativePathPattern _right;
    private InstructionHandle _loop;
		
    public AncestorPattern(RelativePathPattern right) {
	this(null, right);
    }

    public AncestorPattern(Pattern left, RelativePathPattern right) {
	_left = left;
	(_right = right).setParent(this);
	if (left != null) {
	    left.setParent(this);
	}
    }
	
    public InstructionHandle getLoopHandle() {
	return _loop;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_left != null) {
	    _left.setParser(parser);
	}
	_right.setParser(parser);
    }
    
    public boolean isWildcard() {
	
	return false;
    }
	
    public StepPattern getKernelPattern() {
	return _right.getKernelPattern();
    }

    public void reduceKernelPattern() {
	_right.reduceKernelPattern();
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_left != null) {
	    _left.typeCheck(stable);
	}
	return _right.typeCheck(stable);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	InstructionHandle parent;
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final LocalVariableGen local =
	    methodGen.addLocalVariable2(""app"", Util.getJCRefType(NODE_SIG),
					il.getEnd());

	final org.apache.bcel.generic.Instruction loadLocal =
	    new ILOAD(local.getIndex());
	final org.apache.bcel.generic.Instruction storeLocal =
	    new ISTORE(local.getIndex());

	if (_right instanceof StepPattern) {
	    il.append(DUP);
	    il.append(storeLocal);
	    _right.translate(classGen, methodGen);
	    il.append(methodGen.loadDOM());
	    il.append(loadLocal);
	}
	else {
	    _right.translate(classGen, methodGen);

	    if (_right instanceof AncestorPattern) {
		il.append(methodGen.loadDOM());
		il.append(SWAP);
	    }
	}

	if (_left != null) {
	    final int getParent = cpg.addInterfaceMethodref(DOM_INTF,
							    GET_PARENT,
							    GET_PARENT_SIG);
	    parent = il.append(new INVOKEINTERFACE(getParent, 2));
	    
	    il.append(DUP);
	    il.append(storeLocal);
	    _falseList.add(il.append(new IFLT(null)));
	    il.append(loadLocal);

	    _left.translate(classGen, methodGen);

	    final SyntaxTreeNode p = getParent();
	    if (p == null || p instanceof Instruction ||
		p instanceof TopLevelElement) 
	    {
		
	    }
	    else {
		il.append(loadLocal);
	    }

	    final BranchHandle exit = il.append(new GOTO(null));
	    _loop = il.append(methodGen.loadDOM());
	    il.append(loadLocal);
	    local.setEnd(_loop);
	    il.append(new GOTO(parent));
	    exit.setTarget(il.append(NOP));
	    _left.backPatchFalseList(_loop);

	    _trueList.append(_left._trueList);	
	}
	else {
	    il.append(POP2);
	}
	
	
	if (_right instanceof AncestorPattern) {
	    final AncestorPattern ancestor = (AncestorPattern) _right;
	    _falseList.backPatch(ancestor.getLoopHandle());    
	}

	_trueList.append(_right._trueList);
	_falseList.append(_right._falseList);
    }

    public String toString() {
	return ""AncestorPattern("" + _left + "", "" + _right + ')';
    }
}
"
org.apache.xpath.patterns.ContextMatchStepPattern,3,4,0,8,16,3,1,8,3,2.0,176,0.0,0,0.975903614,0.583333333,2,12,57.66666667,1,0.6667,0,"
package org.apache.xpath.patterns;

import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.WalkerFactory;
import org.apache.xpath.objects.XObject;

public class ContextMatchStepPattern extends StepPattern
{

  
  public ContextMatchStepPattern(int axis, int paxis)
  {
    super(DTMFilter.SHOW_ALL, axis, paxis);
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    if (xctxt.getIteratorRoot() == xctxt.getCurrentNode())
      return getStaticScore();
    else
      return this.SCORE_NONE;
  }
  
  
  public XObject executeRelativePathPattern(
          XPathContext xctxt, StepPattern prevStep)
            throws javax.xml.transform.TransformerException
  {

    XObject score = NodeTest.SCORE_NONE;
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);

    if (null != dtm)
    {
      int predContext = xctxt.getCurrentNode();
      DTMAxisTraverser traverser;
      
      int axis = m_axis;
      
      boolean needToTraverseAttrs = WalkerFactory.isDownwardAxisOfMany(axis);
      boolean iterRootIsAttr = (dtm.getNodeType(xctxt.getIteratorRoot()) 
                                 == DTM.ATTRIBUTE_NODE);

      if((Axis.PRECEDING == axis) && iterRootIsAttr)
      {
        axis = Axis.PRECEDINGANDANCESTOR;
      }
      
      traverser = dtm.getAxisTraverser(axis);

      for (int relative = traverser.first(context); DTM.NULL != relative;
              relative = traverser.next(context, relative))
      {
        try
        {
          xctxt.pushCurrentNode(relative);

          score = execute(xctxt);

          if (score != NodeTest.SCORE_NONE)
          {
	      
	      
	      if (executePredicates(xctxt, dtm, context))
		  return score;
	      
	      score = NodeTest.SCORE_NONE;
          }
          
          if(needToTraverseAttrs && iterRootIsAttr
             && (DTM.ELEMENT_NODE == dtm.getNodeType(relative)))
          {
            int xaxis = Axis.ATTRIBUTE;
            for (int i = 0; i < 2; i++) 
            {            
              DTMAxisTraverser atraverser = dtm.getAxisTraverser(xaxis);
        
              for (int arelative = atraverser.first(relative); 
                      DTM.NULL != arelative;
                      arelative = atraverser.next(relative, arelative))
              {
                try
                {
                  xctxt.pushCurrentNode(arelative);
        
                  score = execute(xctxt);
        
                  if (score != NodeTest.SCORE_NONE)
                  {
		      
		      
        
                    if (score != NodeTest.SCORE_NONE)
                      return score;
                  }
                }
                finally
                {
                  xctxt.popCurrentNode();
                }
              }
              xaxis = Axis.NAMESPACE;
            }
          }

        }
        finally
        {
          xctxt.popCurrentNode();
        }
      }

    }

    return score;
  }

}
"
org.apache.xalan.xsltc.compiler.util.TypeCheckError,7,3,0,89,13,0,88,2,7,0.083333333,98,0.0,2,0.85,0.371428571,1,2,12.71428571,3,0.7143,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.SyntaxTreeNode;

public class TypeCheckError extends Exception {
    ErrorMsg _error = null;
    SyntaxTreeNode _node = null;
	
    public TypeCheckError(SyntaxTreeNode node) {
	super();
	_node = node;
    }

    public TypeCheckError(ErrorMsg error) {
	super();
	_error = error;
    }
	
    public TypeCheckError(String code, Object param) {
	super();
	_error = new ErrorMsg(code, param);
    }

    public TypeCheckError(String code, Object param1, Object param2) {
	super();
	_error = new ErrorMsg(code, param1, param2);
    }

    public ErrorMsg getErrorMsg() {
        return _error;
    }

    public String getMessage() {
        return toString();
    }

    public String toString() {
	String result;

	if (_error == null) {
            if (_node != null) {
                _error = new ErrorMsg(ErrorMsg.TYPE_CHECK_ERR,
                                      _node.toString());
	    } else {
	        _error = new ErrorMsg(ErrorMsg.TYPE_CHECK_UNK_LOC_ERR);
	    }
        }

	return _error.toString();
    }
}
"
org.apache.xalan.xsltc.compiler.NameCall,3,5,0,9,11,3,0,9,3,2.0,37,0.0,0,0.99,0.533333333,3,5,11.33333333,1,0.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;

final class NameCall extends NameBase {

    
    public NameCall(QName fname) {
	super(fname);
    }

    
    public NameCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

     
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final int getName = cpg.addInterfaceMethodref(DOM_INTF,
						      GET_NODE_NAME,
						      GET_NODE_NAME_SIG);
	super.translate(classGen, methodGen);
	il.append(new INVOKEINTERFACE(getName, 2));
    }
}
"
org.apache.xalan.xsltc.dom.NodeSortRecordFactory,5,1,0,7,14,4,2,6,4,0.75,126,1.0,2,0.0,0.416666667,0,0,22.6,1,0.6,1,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.runtime.TransletLoader;

public class NodeSortRecordFactory {

    private static int DESCENDING = ""descending"".length();
    private static int NUMBER     = ""number"".length();

    private final DOM      _dom;
    private final String   _className;
    private Class _class;
    private int   _order[];
    private int   _type[];
    private final AbstractTranslet _translet;

    public Class loadTranslet(String name) throws ClassNotFoundException {
	
	try {
	    return Class.forName(name);
	}
	catch (ClassNotFoundException e) {
	    
	}

	
	return new TransletLoader().loadTranslet(name);
    }

    
    public NodeSortRecordFactory(DOM dom, String className, Translet translet,
				 String order[], String type[])
	throws TransletException {
	try {
	    _dom = dom;
	    _className = className;
	    
	    _class = translet.getAuxiliaryClass(className);
	    
	    if (_class == null) _class = loadTranslet(className);
	    _translet = (AbstractTranslet)translet;

	    int levels = order.length;
	    _order = new int[levels];
	    _type = new int[levels];
	    for (int i = 0; i < levels; i++) {
		if (order[i].length() == DESCENDING)
		    _order[i] = NodeSortRecord.COMPARE_DESCENDING;
		if (type[i].length() == NUMBER)
		    _type[i] = NodeSortRecord.COMPARE_NUMERIC;
	    }
	}
	catch (ClassNotFoundException e) {
	    throw new TransletException(e);
	}
    }

    
    public NodeSortRecord makeNodeSortRecord(int node, int last)
	throws ExceptionInInitializerError,
	       LinkageError,
	       IllegalAccessException,
	       InstantiationException,
	       SecurityException,
	       TransletException {

	final NodeSortRecord sortRecord =
	    (NodeSortRecord)_class.newInstance();
	sortRecord.initialize(node, last, _dom, _translet, _order, _type, this);
	return sortRecord;
    }

    public String getClassName() {
	return _className;
    }
}
"
org.apache.xpath.objects.XRTreeFrag,19,3,1,21,42,83,6,15,18,0.6,332,0.2,3,0.816091954,0.184210526,2,24,16.21052632,9,1.6842,1,"
package org.apache.xpath.objects;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionNode;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.RTFIterator;

import org.w3c.dom.NodeList;


public class XRTreeFrag extends XObject implements Cloneable
{
  DTM m_dtm;
  int m_dtmRoot;
  XPathContext m_xctxt;
  boolean m_allowRelease = false;













  
  
  public XRTreeFrag(int root, XPathContext xctxt, ExpressionNode parent)
  {
    super(null);
    
    
    exprSetParent(parent);
    m_dtmRoot = root;
    m_xctxt = xctxt;
    m_dtm = xctxt.getDTM(root);
  }
  
  
  public XRTreeFrag(int root, XPathContext xctxt)
  {
    super(null);
    
    
    m_dtmRoot = root;
    m_xctxt = xctxt;
    m_dtm = xctxt.getDTM(root);
  }

  
  
  public Object object()
  {
    if (m_xctxt != null)
      return new org.apache.xml.dtm.ref.DTMNodeIterator((DTMIterator)(new org.apache.xpath.NodeSetDTM(m_dtmRoot, m_xctxt.getDTMManager())));
    else
      return super.object();
  }
  
  
  public XRTreeFrag(Expression expr)
  {
    super(expr);
  }
  
  
  protected void finalize() throws Throwable
  {
    try
    {
      destruct();
    }
    finally
    {
      super.finalize();  
    }
  }
  
  
  public void allowDetachToRelease(boolean allowRelease)
  {
    m_allowRelease = allowRelease;
  }

  
  public void detach()
  {
    if(m_allowRelease)
    {
    	
    	
      
      int ident = m_xctxt.getDTMIdentity(m_dtm);
      DTM foundDTM = m_xctxt.getDTM(ident);      
      if(foundDTM == m_dtm)
      {
        m_xctxt.release(m_dtm, true);
        m_dtm = null;
        m_xctxt = null;
      }
      m_obj = null;
    }
  }
  
  
  public void destruct()
  {
    if(null != m_dtm)
    {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int ident = m_xctxt.getDTMIdentity(m_dtm);
      DTM foundDTM = m_xctxt.getDTM(ident);      
      if(foundDTM == m_dtm)
      {
        m_xctxt.release(m_dtm, true);
        m_dtm = null;
        m_xctxt = null;
      }
    }
    m_obj = null;
 }

  
  public int getType()
  {
    return CLASS_RTREEFRAG;
  }

  
  public String getTypeString()
  {
    return ""#RTREEFRAG"";
  }

  
  public double num()
    throws javax.xml.transform.TransformerException
  {

    XMLString s = xstr();

    return s.toDouble();
  }

  
  public boolean bool()
  {
    return true;
  }
  
  private XMLString m_xmlStr = null;
  
  
  public XMLString xstr()
  {
    if(null == m_xmlStr)
      m_xmlStr = m_dtm.getStringValue(m_dtmRoot);
    
    return m_xmlStr;
  }
  
  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    XString xstring = (XString)xstr();
    xstring.appendToFsb(fsb);
  }


  
  public String str()
  {
    String str = m_dtm.getStringValue(m_dtmRoot).toString();

    return (null == str) ? """" : str;
  }

  
  public int rtf()
  {
    return m_dtmRoot;
  }

  
  public DTMIterator asNodeIterator()
  {
    return new RTFIterator(m_dtmRoot, m_xctxt.getDTMManager());
  }

  
  public NodeList convertToNodeset()
  {

    if (m_obj instanceof NodeList)
      return (NodeList) m_obj;
    else
      return new org.apache.xml.dtm.ref.DTMNodeList(asNodeIterator());
  }

  
  public boolean equals(XObject obj2)
  {

    try
    {
      if (XObject.CLASS_NODESET == obj2.getType())
      {
  
        
        
        
        return obj2.equals(this);
      }
      else if (XObject.CLASS_BOOLEAN == obj2.getType())
      {
        return bool() == obj2.bool();
      }
      else if (XObject.CLASS_NUMBER == obj2.getType())
      {
        return num() == obj2.num();
      }
      else if (XObject.CLASS_NODESET == obj2.getType())
      {
        return xstr().equals(obj2.xstr());
      }
      else if (XObject.CLASS_STRING == obj2.getType())
      {
        return xstr().equals(obj2.xstr());
      }
      else if (XObject.CLASS_RTREEFRAG == obj2.getType())
      {
  
        
        return xstr().equals(obj2.xstr());
      }
      else
      {
        return super.equals(obj2);
      }
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }

}
"
org.apache.xalan.xsltc.dom.CurrentNodeListIterator,13,2,0,6,31,14,0,6,12,0.583333333,268,1.0,4,0.541666667,0.307692308,1,8,19.07692308,3,1.4615,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xalan.xsltc.util.IntegerArray;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;



public final class CurrentNodeListIterator extends DTMAxisIteratorBase {
    
    private boolean _docOrder;

    
    private DTMAxisIterator _source;

    
    private final CurrentNodeListFilter _filter;

    
    private IntegerArray _nodes = new IntegerArray();
	
    
    private int _currentIndex;
	
    
    private final int _currentNode;

    
    private AbstractTranslet _translet;

    public CurrentNodeListIterator(DTMAxisIterator source, 
				   CurrentNodeListFilter filter,
				   int currentNode,
				   AbstractTranslet translet) 
    {
	this(source, !source.isReverse(), filter, currentNode, translet);
    }

    public CurrentNodeListIterator(DTMAxisIterator source, boolean docOrder,
				   CurrentNodeListFilter filter,
				   int currentNode,
				   AbstractTranslet translet) 
    {
	_source = source;
	_filter = filter;
	_translet = translet;
	_docOrder = docOrder;
	_currentNode = currentNode;
    }

    public DTMAxisIterator forceNaturalOrder() {
	_docOrder = true;
	return this;
    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }

    public boolean isReverse() {
	return !_docOrder;
    }

    public DTMAxisIterator cloneIterator() {
	try {
	    final CurrentNodeListIterator clone =
		(CurrentNodeListIterator) super.clone();
	    clone._nodes = (IntegerArray) _nodes.clone();
	    clone._source = _source.cloneIterator();
	    clone._isRestartable = false;
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public DTMAxisIterator reset() {
	_currentIndex = 0;
	return resetPosition();
    }

    public int next() {
	final int last = _nodes.cardinality();
	final int currentNode = _currentNode;
	final AbstractTranslet translet = _translet;

	for (int index = _currentIndex; index < last; ) {
	    final int position = _docOrder ? index + 1 : last - index;
	    final int node = _nodes.at(index++); 	

	    if (_filter.test(node, position, last, currentNode, translet,
                             this)) {
		_currentIndex = index;
		return returnNode(node);
	    }
	}
	return END;
    }

    public DTMAxisIterator setStartNode(int node) {
	if (_isRestartable) {
	    _source.setStartNode(_startNode = node);

	    _nodes.clear();
	    while ((node = _source.next()) != END) {
		_nodes.add(node);
	    }
	    _currentIndex = 0;
	    resetPosition();
	}
	return this;
    }
	
    public int getLast() {
	if (_last == -1) {
	    _last = computePositionOfLast();
	}
	return _last;
    }

    public void setMark() {
	_markedNode = _currentIndex;
    }

    public void gotoMark() {
	_currentIndex = _markedNode;
    }

    private int computePositionOfLast() {
        final int last = _nodes.cardinality();
        final int currNode = _currentNode;
	final AbstractTranslet translet = _translet;

	int lastPosition = _position;
	for (int index = _currentIndex; index < last; ) {
	    final int position = _docOrder ? index + 1 : last - index;
            int nodeIndex = _nodes.at(index++); 	

            if (_filter.test(nodeIndex, position, last, currNode, translet,
                             this)) {
                lastPosition++;
            }
        }
	return lastPosition;
    }
}
"
org.apache.xpath.functions.FuncLang,2,4,0,6,15,1,0,6,2,2.0,73,0.0,0,0.979591837,0.75,1,6,35.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class FuncLang extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String lang = m_arg0.execute(xctxt).str();
    int parent = xctxt.getCurrentNode();
    boolean isLang = false;
    DTM dtm = xctxt.getDTM(parent);

    while (DTM.NULL != parent)
    {
      if (DTM.ELEMENT_NODE == dtm.getNodeType(parent))
      {
        int langAttr = dtm.getAttributeNode(parent, ""http:

        if (DTM.NULL != langAttr)
        {
          String langVal = dtm.getNodeValue(langAttr);
          
          if (langVal.toLowerCase().startsWith(lang.toLowerCase()))
          {
            int valLen = lang.length();

            if ((langVal.length() == valLen)
                    || (langVal.charAt(valLen) == '-'))
            {
              isLang = true;
            }
          }

          break;
        }
      }

      parent = dtm.getParent(parent);
    }

    return isLang ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xpath.functions.FuncUnparsedEntityURI,2,4,0,6,10,1,0,6,2,2.0,30,0.0,0,0.979591837,0.75,1,6,14.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncUnparsedEntityURI extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String name = m_arg0.execute(xctxt).str();
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    int doc = dtm.getDocument();
    
    String uri = dtm.getUnparsedEntityURI(name);

    return new XString(uri);
  }
}
"
org.apache.xalan.templates.ElemApplyTemplates,9,5,0,23,82,20,2,22,9,0.6875,571,1.0,1,0.965811966,0.311111111,5,10,62.22222222,1,0.8889,2,"
package org.apache.xalan.templates;

import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.StackGuard;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.QName;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.xml.sax.SAXException;


public class ElemApplyTemplates extends ElemCallTemplate
{

  
  private QName m_mode = null;

  
  public void setMode(QName mode)
  {
    m_mode = mode;
  }

  
  public QName getMode()
  {
    return m_mode;
  }

  
  private boolean m_isDefaultTemplate = false;
  






  
  public void setIsDefaultTemplate(boolean b)
  {
    m_isDefaultTemplate = b;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_APPLY_TEMPLATES;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_APPLY_TEMPLATES_STRING;
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    transformer.pushCurrentTemplateRuleIsNull(false);

    boolean pushMode = false;

    try
    {
      
      
      
      
      QName mode = transformer.getMode();

      if (!m_isDefaultTemplate)
      {
        if (((null == mode) && (null != m_mode))
                || ((null != mode) &&!mode.equals(m_mode)))
        {
          pushMode = true;

          transformer.pushMode(m_mode);
        }
      }
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEvent(this);

      transformSelectedNodes(transformer);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEndEvent(this);

      if (pushMode)
        transformer.popMode();

      transformer.popCurrentTemplateRuleIsNull();
    }
  }

  
  
  public void transformSelectedNodes(TransformerImpl transformer)
            throws TransformerException
  {

    final XPathContext xctxt = transformer.getXPathContext();
    final int sourceNode = xctxt.getCurrentNode();
    DTMIterator sourceNodes = m_selectExpression.asIterator(xctxt, sourceNode);
    VariableStack vars = xctxt.getVarStack();
    int nParams = getParamElemCount();
    int thisframe = vars.getStackFrame();
    StackGuard guard = transformer.getStackGuard();
    boolean check = (guard.getRecursionLimit() > -1) ? true : false;
      
    try
    {

      final Vector keys = (m_sortElems == null)
                          ? null
                          : transformer.processSortKeys(this, sourceNode);

      
      if (null != keys)
        sourceNodes = sortNodes(xctxt, keys, sourceNodes);

      if (TransformerImpl.S_DEBUG)
      {
        transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                ""select"", new XPath(m_selectExpression),
                new org.apache.xpath.objects.XNodeSet(sourceNodes));
      }

      final SerializationHandler rth = transformer.getSerializationHandler();

      final StylesheetRoot sroot = transformer.getStylesheet();
      final TemplateList tl = sroot.getTemplateListComposed();
      final boolean quiet = transformer.getQuietConflictWarnings();
      
      
      DTM dtm = xctxt.getDTM(sourceNode);
      
      int argsFrame = -1;
      if(nParams > 0)
      {
        
        
        
        argsFrame = vars.link(nParams);
        vars.setStackFrame(thisframe);
        
        for (int i = 0; i < nParams; i++) 
        {
          ElemWithParam ewp = m_paramElems[i];
          XObject obj = ewp.getValue(transformer, sourceNode);
          
          vars.setLocalVariable(i, obj, argsFrame);
        }
        vars.setStackFrame(argsFrame);
      }
      
      xctxt.pushCurrentNode(DTM.NULL);
      IntStack currentNodes = xctxt.getCurrentNodeStack();
      
      xctxt.pushCurrentExpressionNode(DTM.NULL);
      IntStack currentExpressionNodes = xctxt.getCurrentExpressionNodeStack();     

      xctxt.pushSAXLocatorNull();
      xctxt.pushContextNodeList(sourceNodes);
      transformer.pushElemTemplateElement(null);
      
      
      int child;
      while (DTM.NULL != (child = sourceNodes.nextNode()))
      {
        currentNodes.setTop(child);
        currentExpressionNodes.setTop(child);

        if(xctxt.getDTM(child) != dtm)
        {
          dtm = xctxt.getDTM(child);
        }
        
        final int exNodeType = dtm.getExpandedTypeID(child);

        final int nodeType = dtm.getNodeType(child);

        final QName mode = transformer.getMode();

        ElemTemplate template = tl.getTemplateFast(xctxt, child, exNodeType, mode, 
                                      -1, quiet, dtm);

        
        
        if (null == template)
        {
          switch (nodeType)
          {
          case DTM.DOCUMENT_FRAGMENT_NODE :
          case DTM.ELEMENT_NODE :
            template = sroot.getDefaultRule();
            
            break;
          case DTM.ATTRIBUTE_NODE :
          case DTM.CDATA_SECTION_NODE :
          case DTM.TEXT_NODE :
            
            
            transformer.pushPairCurrentMatched(sroot.getDefaultTextRule(), child);
            transformer.setCurrentElement(sroot.getDefaultTextRule());
            
            dtm.dispatchCharactersEvents(child, rth, false);
            transformer.popCurrentMatched();
            continue;
          case DTM.DOCUMENT_NODE :
            template = sroot.getDefaultRootRule();
            break;
          default :

            
            continue;
          }
        }
        else
        {
        	transformer.setCurrentElement(template);
        }
                
        transformer.pushPairCurrentMatched(template, child);
        if (check)
	        guard.checkForInfinateLoop();

        int currentFrameBottom;  
        if(template.m_frameSize > 0)
        {
          xctxt.pushRTFContext();
          currentFrameBottom = vars.getStackFrame();  
          vars.link(template.m_frameSize);
          
          
          if( template.m_inArgsSize > 0)
          {
            int paramIndex = 0;
            for (ElemTemplateElement elem = template.getFirstChildElem(); 
                 null != elem; elem = elem.getNextSiblingElem()) 
            {
              if(Constants.ELEMNAME_PARAMVARIABLE == elem.getXSLToken())
              {
                ElemParam ep = (ElemParam)elem;
                
                int i;
                for (i = 0; i < nParams; i++) 
                {
                  ElemWithParam ewp = m_paramElems[i];
                  if(ewp.m_qnameID == ep.m_qnameID)
                  {
                    XObject obj = vars.getLocalVariable(i, argsFrame);
                    vars.setLocalVariable(paramIndex, obj);
                    break;
                  }
                }
                if(i == nParams)
                  vars.setLocalVariable(paramIndex, null);
              }
              else
                break;
              paramIndex++;
            }
            
          }
        }
        else
        	currentFrameBottom = 0;

        
        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(template);

        
        
        
        for (ElemTemplateElement t = template.m_firstChild; 
             t != null; t = t.m_nextSibling)
        {
          xctxt.setSAXLocator(t);
          try
          {
          	transformer.pushElemTemplateElement(t);
          	t.execute(transformer);
          }
          finally
          {
          	transformer.popElemTemplateElement();
          }
        }
        
        if (TransformerImpl.S_DEBUG)
	      transformer.getTraceManager().fireTraceEndEvent(template); 
	    
        if(template.m_frameSize > 0)
        {
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          vars.unlink(currentFrameBottom);
          xctxt.popRTFContext();
        }
          
        transformer.popCurrentMatched();
        
      } 
    }
    catch (SAXException se)
    {
      transformer.getErrorListener().fatalError(new TransformerException(se));
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireSelectedEndEvent(sourceNode, this,
                ""select"", new XPath(m_selectExpression),
                new org.apache.xpath.objects.XNodeSet(sourceNodes));
      
      
      if(nParams > 0)
        vars.unlink(thisframe);
      xctxt.popSAXLocator();
      xctxt.popContextNodeList();
      transformer.popElemTemplateElement();
      xctxt.popCurrentExpressionNode();
      xctxt.popCurrentNode();
      sourceNodes.detach();
    }
  }

}
"
org.apache.xalan.xsltc.dom.UnionIterator,9,2,0,6,25,0,1,5,8,0.517857143,401,1.0,2,0.619047619,0.361111111,1,6,42.77777778,6,2.8889,2,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;


public final class UnionIterator extends DTMAxisIteratorBase {
    
    final private DOM _dom;

    private final static class LookAheadIterator {
	public int node, markedNode;
	public DTMAxisIterator iterator;
		
	public LookAheadIterator(DTMAxisIterator iterator) {
	    this.iterator = iterator;
	}
		
	public int step() {
	    node = iterator.next();
	    return node;
	}

	public LookAheadIterator cloneIterator() {
	    final LookAheadIterator clone = 
		 new LookAheadIterator(iterator.cloneIterator());
	    clone.node = node;
	    clone.markedNode = node;
	    return clone;
	}

	public void setMark() {
	    markedNode = node;
	    iterator.setMark();
	}

	public void gotoMark() {
	    node = markedNode;
	    iterator.gotoMark();
	}

    } 

    private static final int InitSize = 8;
  
    private int            _heapSize = 0;
    private int            _size = InitSize;
    private LookAheadIterator[] _heap = new LookAheadIterator[InitSize];
    private int            _free = 0;
  
    
    
    private int _returnedLast;

    public UnionIterator(DOM dom) {
	_dom = dom;
    }


    public DTMAxisIterator cloneIterator() {
	_isRestartable = false;
	final LookAheadIterator[] heapCopy = 
	    new LookAheadIterator[_heap.length];
	try {
	    final UnionIterator clone = (UnionIterator)super.clone();
            for (int i = 0; i < _free; i++) {
                heapCopy[i] = _heap[i].cloneIterator();
            }
	    clone.setRestartable(false);
	    clone._heap = heapCopy;
	    return clone.reset();
	} 
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public UnionIterator addIterator(DTMAxisIterator iterator) {
	if (_free == _size) {
	    LookAheadIterator[] newArray = new LookAheadIterator[_size *= 2];
	    System.arraycopy(_heap, 0, newArray, 0, _free);
	    _heap = newArray;
	}
	_heapSize++;
	_heap[_free++] = new LookAheadIterator(iterator);
	return this;
    }
  
    public int next() {
	while (_heapSize > 0) {
	    final int smallest = _heap[0].node;
	    if (smallest == END) { 
		if (_heapSize > 1) {
		    
		    final LookAheadIterator temp = _heap[0];
		    _heap[0] = _heap[--_heapSize];
		    _heap[_heapSize] = temp;
		}
		else {
		    return END;
		}
	    }
	    else if (smallest == _returnedLast) {	
		_heap[0].step(); 
	    }
	    else {
		_heap[0].step(); 
		heapify(0);
		return returnNode(_returnedLast = smallest);
	    }
	    
	    heapify(0);
	}
	return END;
    }
  
    public DTMAxisIterator setStartNode(int node) {
	if (_isRestartable) {
	    _startNode = node;
	    for (int i = 0; i < _free; i++) {
		_heap[i].iterator.setStartNode(node);
		_heap[i].step();	
	    }
	    
	    for (int i = (_heapSize = _free)/2; i >= 0; i--) {
		heapify(i);
	    }
	    _returnedLast = END;
	    return resetPosition();
	}
	return this;
    }
	
    private void heapify(int i) {
	for (int r, l, smallest;;) {
	    r = (i + 1) << 1; l = r - 1;
	    smallest = l < _heapSize 
		&& _dom.lessThan(_heap[l].node, _heap[i].node) ? l : i;
	    if (r < _heapSize && _dom.lessThan(_heap[r].node,
					       _heap[smallest].node)) {
		smallest = r;
	    }
	    if (smallest != i) {
		final LookAheadIterator temp = _heap[smallest];
		_heap[smallest] = _heap[i];
		_heap[i] = temp;
		i = smallest;
	    }
	    else
		break;
	}
    }

    public void setMark() {
	for (int i = 0; i < _free; i++) {
	    _heap[i].setMark();
	}
    }

    public void gotoMark() {
	for (int i = 0; i < _free; i++) {
	    _heap[i].gotoMark();
	}
    }

    public DTMAxisIterator reset() {
	for (int i = 0; i < _free; i++) {
	    _heap[i].iterator.reset();
	    _heap[i].step();
	}
	
	for (int i = (_heapSize = _free)/2; i >= 0; i--) {
	    heapify(i);
	}
	_returnedLast = END;
	return resetPosition();
    }

}
"
org.apache.xml.dtm.ref.dom2dtm.DOM2DTM,39,4,0,18,119,617,1,18,30,0.870813397,1667,0.545454545,1,0.712121212,0.142857143,2,17,41.46153846,42,4.6154,0,"
package org.apache.xml.dtm.ref.dom2dtm;

import java.util.Vector;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.dom.DOMSource;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.dtm.ref.DTMDefaultBaseIterators;
import org.apache.xml.dtm.ref.DTMManagerDefault;
import org.apache.xml.dtm.ref.ExpandedNameTable;
import org.apache.xml.dtm.ref.IncrementalSAXSource;
import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.StringBufferPool;
import org.apache.xml.utils.TreeWalker;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.w3c.dom.Attr;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentType;
import org.w3c.dom.Element;
import org.w3c.dom.Entity;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.xml.sax.ContentHandler;


public class DOM2DTM extends DTMDefaultBaseIterators
{
  static final boolean JJK_DEBUG=false;
  static final boolean JJK_NEWCODE=true;
  
  
  static final String NAMESPACE_DECL_NS=""http:
  
  
  transient private Node m_pos;
  
  private int m_last_parent=0;
  
  private int m_last_kid=NULL;

  
  transient private Node m_root;

  
  boolean m_processedFirstElement=false;
        
  
  transient private boolean m_nodesAreProcessed;

  
  protected Vector m_nodes = new Vector();

  
  public DOM2DTM(DTMManager mgr, DOMSource domSource, 
                 int dtmIdentity, DTMWSFilter whiteSpaceFilter,
                 XMLStringFactory xstringfactory,
                 boolean doIndexing)
  {
    super(mgr, domSource, dtmIdentity, whiteSpaceFilter, 
          xstringfactory, doIndexing);

    
    m_pos=m_root = domSource.getNode();
    
    m_last_parent=m_last_kid=NULL;
    m_last_kid=addNode(m_root, m_last_parent,m_last_kid, NULL);

    
    
    
    
    
    
    
		
		
		
    if(ELEMENT_NODE == m_root.getNodeType())
    {
      NamedNodeMap attrs=m_root.getAttributes();
      int attrsize=(attrs==null) ? 0 : attrs.getLength();
      if(attrsize>0)
      {
        int attrIndex=NULL; 
        for(int i=0;i<attrsize;++i)
        {
          
          
          
          attrIndex=addNode(attrs.item(i),0,attrIndex,NULL);
          m_firstch.setElementAt(DTM.NULL,attrIndex);
        }
        
        
        m_nextsib.setElementAt(DTM.NULL,attrIndex);

        
      } 
    } 

    
    m_nodesAreProcessed = false;
  }

  
  protected int addNode(Node node, int parentIndex,
                        int previousSibling, int forceNodeType)
  {
    int nodeIndex = m_nodes.size();

    
    if(m_dtmIdent.size() == (nodeIndex>>>DTMManager.IDENT_DTM_NODE_BITS))
    {
      try
      {
        if(m_mgr==null)
          throw new ClassCastException();
                                
                                
        DTMManagerDefault mgrD=(DTMManagerDefault)m_mgr;
        int id=mgrD.getFirstFreeDTMID();
        mgrD.addDTM(this,id,nodeIndex);
        m_dtmIdent.addElement(id<<DTMManager.IDENT_DTM_NODE_BITS);
      }
      catch(ClassCastException e)
      {
        
        
        
        error(XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_DTMIDS_AVAIL, null));
      }
    }

    m_size++;
    
    
    int type;
    if(NULL==forceNodeType)
        type = node.getNodeType();
    else
        type=forceNodeType;
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    if (Node.ATTRIBUTE_NODE == type)
    {
      String name = node.getNodeName();

      if (name.startsWith(""xmlns:"") || name.equals(""xmlns""))
      {
        type = DTM.NAMESPACE_NODE;
      }
    }
    
    m_nodes.addElement(node);
    
    m_firstch.setElementAt(NOTPROCESSED,nodeIndex);
    m_nextsib.setElementAt(NOTPROCESSED,nodeIndex);
    m_prevsib.setElementAt(previousSibling,nodeIndex);
    m_parent.setElementAt(parentIndex,nodeIndex);
    
    if(DTM.NULL != parentIndex && 
       type != DTM.ATTRIBUTE_NODE && 
       type != DTM.NAMESPACE_NODE)
    {
      
      if(NOTPROCESSED == m_firstch.elementAt(parentIndex))
        m_firstch.setElementAt(nodeIndex,parentIndex);
    }
    
    String nsURI = node.getNamespaceURI();

    
    
    
    String localName =  (type == Node.PROCESSING_INSTRUCTION_NODE) ? 
                         node.getNodeName() :
                         node.getLocalName();
                         
    
    if(((type == Node.ELEMENT_NODE) || (type == Node.ATTRIBUTE_NODE)) 
        && null == localName)
      localName = node.getNodeName(); 
      
    ExpandedNameTable exnt = m_expandedNameTable;

    
    
    
    
    
    
    
    
    if(node.getLocalName()==null &&
       (type==Node.ELEMENT_NODE || type==Node.ATTRIBUTE_NODE))
      {
        
      }
    
    int expandedNameID = (null != localName) 
       ? exnt.getExpandedTypeID(nsURI, localName, type) :
         exnt.getExpandedTypeID(type);

    m_exptype.setElementAt(expandedNameID,nodeIndex);
    
    indexNode(expandedNameID, nodeIndex);

    if (DTM.NULL != previousSibling)
      m_nextsib.setElementAt(nodeIndex,previousSibling);

    
    
    if (type == DTM.NAMESPACE_NODE)
        declareNamespaceInContext(parentIndex,nodeIndex);

    return nodeIndex;
  }
  
  
  public int getNumberOfNodes()
  {
    return m_nodes.size();
  }
  
 
  protected boolean nextNode()
  {
    
    
    
    
    
    if (m_nodesAreProcessed)
      return false;
        
    
    
    Node pos=m_pos; 
    Node next=null;
    int nexttype=NULL;

    
    do
      {
        
        if (pos.hasChildNodes()) 
          {
            next = pos.getFirstChild();

            
            
            if(next!=null && DOCUMENT_TYPE_NODE==next.getNodeType())
              next=next.getNextSibling();

            
            
            if(ENTITY_REFERENCE_NODE!=pos.getNodeType())
              {
                m_last_parent=m_last_kid;
                m_last_kid=NULL;
                
                if(null != m_wsfilter)
                {
                  short wsv =
                    m_wsfilter.getShouldStripSpace(makeNodeHandle(m_last_parent),this);
                  boolean shouldStrip = (DTMWSFilter.INHERIT == wsv) 
                    ? getShouldStripWhitespace() 
                    : (DTMWSFilter.STRIP == wsv);
                  pushShouldStripWhitespace(shouldStrip);
                } 
              }
          }

        
        else 
          {
            if(m_last_kid!=NULL)
              {
                
                
                if(m_firstch.elementAt(m_last_kid)==NOTPROCESSED)
                  m_firstch.setElementAt(NULL,m_last_kid);
              }
                        
            while(m_last_parent != NULL)
              {
                
                
                next = pos.getNextSibling();
                if(next!=null && DOCUMENT_TYPE_NODE==next.getNodeType())
                  next=next.getNextSibling();

                if(next!=null)
                  break; 
                
                
                pos=pos.getParentNode();
                if(pos==null)
                  {
                    
                    if(JJK_DEBUG)
                      {
                        System.out.println(""***** DOM2DTM Pop Control Flow problem"");
                        for(;;); 
                      }
                  }
                
                
                
                
                if(pos!=null && ENTITY_REFERENCE_NODE == pos.getNodeType())
                  {
                    
                    if(JJK_DEBUG)
                      System.out.println(""***** DOM2DTM popping EntRef"");
                  }
                else
                  {
                    popShouldStripWhitespace();
                    
                    if(m_last_kid==NULL)
                      m_firstch.setElementAt(NULL,m_last_parent); 
                    else
                      m_nextsib.setElementAt(NULL,m_last_kid); 
                    m_last_parent=m_parent.elementAt(m_last_kid=m_last_parent);
                  }
              }
            if(m_last_parent==NULL)
              next=null;
          }
                
        if(next!=null)
          nexttype=next.getNodeType();
                
        
        
        
        
        
        if (ENTITY_REFERENCE_NODE == nexttype)
          pos=next;
      }
    while (ENTITY_REFERENCE_NODE == nexttype); 
        
    
    if(next==null)
      {
        m_nextsib.setElementAt(NULL,0);
        m_nodesAreProcessed = true;
        m_pos=null;
                
        if(JJK_DEBUG)
          {
            System.out.println(""***** DOM2DTM Crosscheck:"");
            for(int i=0;i<m_nodes.size();++i)
              System.out.println(i+"":	""+m_firstch.elementAt(i)+""	""+m_nextsib.elementAt(i));
          }
                
        return false;
      }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
        
    boolean suppressNode=false;
    Node lastTextNode=null;

    nexttype=next.getNodeType();
        
    
    if(TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype)
      {
        
        suppressNode=((null != m_wsfilter) && getShouldStripWhitespace());

        
        
        Node n=next;
        while(n!=null)
          {
            lastTextNode=n;
            
            if(TEXT_NODE == n.getNodeType())
              nexttype=TEXT_NODE;
            
            
            suppressNode &=
              XMLCharacterRecognizer.isWhiteSpace(n.getNodeValue());
                        
            n=logicalNextDOMTextNode(n);
          }
      }
        
    
    
    
    
    
    else if(PROCESSING_INSTRUCTION_NODE==nexttype)
      {
        suppressNode = (pos.getNodeName().toLowerCase().equals(""xml""));
      }
        
        
    if(!suppressNode)
      {
        
        
        
        int nextindex=addNode(next,m_last_parent,m_last_kid,
			      nexttype);
	
        m_last_kid=nextindex;

        if(ELEMENT_NODE == nexttype)
          {
            int attrIndex=NULL; 
            
            
            NamedNodeMap attrs=next.getAttributes();
            int attrsize=(attrs==null) ? 0 : attrs.getLength();
            if(attrsize>0)
              {
                for(int i=0;i<attrsize;++i)
                  {
                    
                    
                    
                    attrIndex=addNode(attrs.item(i),
                                      nextindex,attrIndex,NULL);
                    m_firstch.setElementAt(DTM.NULL,attrIndex);

                    
                    
		    
		    
		    
		    
		    
		    
		    
                    if(!m_processedFirstElement
                       && ""xmlns:xml"".equals(attrs.item(i).getNodeName()))
                      m_processedFirstElement=true; 
                  }
                
                
              } 
            if(!m_processedFirstElement)
            {
              
              
              
              
              
              
              attrIndex=addNode(new DOM2DTMdefaultNamespaceDeclarationNode(
																	(Element)next,""xml"",NAMESPACE_DECL_NS,
																	makeNodeHandle(((attrIndex==NULL)?nextindex:attrIndex)+1)
																	),
                                nextindex,attrIndex,NULL);      
              m_firstch.setElementAt(DTM.NULL,attrIndex);
              m_processedFirstElement=true;
            }
            if(attrIndex!=NULL)
              m_nextsib.setElementAt(DTM.NULL,attrIndex);
          } 
      } 

    
    if(TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype)
      {
        
                
        next=lastTextNode;      
      }
        
    
    m_pos=next;
    return true;
  }  


  
  public Node getNode(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);

    return (Node) m_nodes.elementAt(identity);
  }

  
  protected Node lookupNode(int nodeIdentity)
  {
    return (Node) m_nodes.elementAt(nodeIdentity);
  }

  
  protected int getNextNodeIdentity(int identity)
  {

    identity += 1;

    if (identity >= m_nodes.size())
    {
      if (!nextNode())
        identity = DTM.NULL;
    }

    return identity;
  }

  
  private int getHandleFromNode(Node node)
  {
    if (null != node)
    {
      int len = m_nodes.size();        
      boolean isMore;
      int i = 0;
      do
      {          
        for (; i < len; i++)
        {
          if (m_nodes.elementAt(i) == node)
            return makeNodeHandle(i);
        }

        isMore = nextNode();
  
        len = m_nodes.size();
            
      } 
      while(isMore || i < len);
    }
    
    return DTM.NULL;
  }

  
  public int getHandleOfNode(Node node)
  {
    if (null != node)
    {
      
      
      
      if((m_root==node) ||
         (m_root.getNodeType()==DOCUMENT_NODE &&
          m_root==node.getOwnerDocument()) ||
         (m_root.getNodeType()!=DOCUMENT_NODE &&
          m_root.getOwnerDocument()==node.getOwnerDocument())
         )
        {
          
          
          
          
          
          for(Node cursor=node;
              cursor!=null;
              cursor=
                (cursor.getNodeType()!=ATTRIBUTE_NODE)
                ? cursor.getParentNode()
                : ((org.w3c.dom.Attr)cursor).getOwnerElement())
            {
              if(cursor==m_root)
                
                return getHandleFromNode(node); 
            } 
        } 
    } 

    return DTM.NULL;
  }

  
  public int getAttributeNode(int nodeHandle, String namespaceURI,
                              String name)
  {

    
    if (null == namespaceURI)
      namespaceURI = """";

    int type = getNodeType(nodeHandle);

    if (DTM.ELEMENT_NODE == type)
    {

      
      int identity = makeNodeIdentity(nodeHandle);

      while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
      {
        
        type = _type(identity);

				
				
				
				
				
				
				
        if (type == DTM.ATTRIBUTE_NODE || type==DTM.NAMESPACE_NODE)
        {
          Node node = lookupNode(identity);
          String nodeuri = node.getNamespaceURI();

          if (null == nodeuri)
            nodeuri = """";

          String nodelocalname = node.getLocalName();

          if (nodeuri.equals(namespaceURI) && name.equals(nodelocalname))
            return makeNodeHandle(identity);
        }
				
        else 
        {
          break;
        }
      }
    }

    return DTM.NULL;
  }

  
  public XMLString getStringValue(int nodeHandle)
  {

    int type = getNodeType(nodeHandle);
    Node node = getNode(nodeHandle);
    
    
    if(DTM.ELEMENT_NODE == type || DTM.DOCUMENT_NODE == type 
    || DTM.DOCUMENT_FRAGMENT_NODE == type)
    {
      FastStringBuffer buf = StringBufferPool.get();
      String s;
  
      try
      {
        getNodeData(node, buf);
  
        s = (buf.length() > 0) ? buf.toString() : """";
      }
      finally
      {
        StringBufferPool.free(buf);
      }
  
      return m_xstrf.newstr( s );
    }
    else if(TEXT_NODE == type || CDATA_SECTION_NODE == type)
    {
      
      
      
      
      
      
      
      FastStringBuffer buf = StringBufferPool.get();
      while(node!=null)
      {
        buf.append(node.getNodeValue());
        node=logicalNextDOMTextNode(node);
      }
      String s=(buf.length() > 0) ? buf.toString() : """";
      StringBufferPool.free(buf);
      return m_xstrf.newstr( s );
    }
    else
      return m_xstrf.newstr( node.getNodeValue() );
  }
  
  
  public boolean isWhitespace(int nodeHandle)
  {
  	int type = getNodeType(nodeHandle);
    Node node = getNode(nodeHandle);
  	if(TEXT_NODE == type || CDATA_SECTION_NODE == type)
    {
      
      
      
      
      
      
      
      FastStringBuffer buf = StringBufferPool.get();
      while(node!=null)
      {
        buf.append(node.getNodeValue());
        node=logicalNextDOMTextNode(node);
      }
     boolean b = buf.isWhitespace(0, buf.length());
      StringBufferPool.free(buf);
     return b;
    }
    return false;
  }
  
  
  protected static void getNodeData(Node node, FastStringBuffer buf)
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_FRAGMENT_NODE :
    case Node.DOCUMENT_NODE :
    case Node.ELEMENT_NODE :
    {
      for (Node child = node.getFirstChild(); null != child;
              child = child.getNextSibling())
      {
        getNodeData(child, buf);
      }
    }
    break;
    case Node.TEXT_NODE :
    case Node.CDATA_SECTION_NODE :
    case Node.ATTRIBUTE_NODE :	
      buf.append(node.getNodeValue());
      break;
    case Node.PROCESSING_INSTRUCTION_NODE :
      
      break;
    default :
      
      break;
    }
  }

  
  public String getNodeName(int nodeHandle)
  {

    Node node = getNode(nodeHandle);

    
    return node.getNodeName();
  }

  
  public String getNodeNameX(int nodeHandle)
  {

    String name;
    short type = getNodeType(nodeHandle);

    switch (type)
    {
    case DTM.NAMESPACE_NODE :
    {
      Node node = getNode(nodeHandle);

      
      name = node.getNodeName();
      if(name.startsWith(""xmlns:""))
      {
        name = QName.getLocalPart(name);
      }
      else if(name.equals(""xmlns""))
      {
        name = """";
      }
    }
    break;
    case DTM.ATTRIBUTE_NODE :
    case DTM.ELEMENT_NODE :
    case DTM.ENTITY_REFERENCE_NODE :
    case DTM.PROCESSING_INSTRUCTION_NODE :
    {
      Node node = getNode(nodeHandle);

      
      name = node.getNodeName();
    }
    break;
    default :
      name = """";
    }

    return name;
  }

  
  public String getLocalName(int nodeHandle)
  {
    if(JJK_NEWCODE)
    {
      int id=makeNodeIdentity(nodeHandle);
      if(NULL==id) return null;
      Node newnode=(Node)m_nodes.elementAt(id);
      String newname=newnode.getLocalName();
      if (null == newname)
      {
	
	String qname = newnode.getNodeName();
	if('#'==qname.charAt(0))
	{
	  
	  
	  newname="""";
	}
	else
	{
	  int index = qname.indexOf(':');
	  newname = (index < 0) ? qname : qname.substring(index + 1);
	}
      }
      return newname;
    }
    else
    {
      String name;
      short type = getNodeType(nodeHandle);
      switch (type)
      {
      case DTM.ATTRIBUTE_NODE :
      case DTM.ELEMENT_NODE :
      case DTM.ENTITY_REFERENCE_NODE :
      case DTM.NAMESPACE_NODE :
      case DTM.PROCESSING_INSTRUCTION_NODE :
	{
	  Node node = getNode(nodeHandle);
	  
	  
	  name = node.getLocalName();
	  
	  if (null == name)
	  {
	    String qname = node.getNodeName();
	    int index = qname.indexOf(':');
	    
	    name = (index < 0) ? qname : qname.substring(index + 1);
	  }
	}
	break;
      default :
	name = """";
      }
      return name;
    }
  }

  
  public String getPrefix(int nodeHandle)
  {

    String prefix;
    short type = getNodeType(nodeHandle);

    switch (type)
    {
    case DTM.NAMESPACE_NODE :
    {
      Node node = getNode(nodeHandle);

      
      String qname = node.getNodeName();
      int index = qname.indexOf(':');

      prefix = (index < 0) ? """" : qname.substring(index + 1);
    }
    break;
    case DTM.ATTRIBUTE_NODE :
    case DTM.ELEMENT_NODE :
    {
      Node node = getNode(nodeHandle);

      
      String qname = node.getNodeName();
      int index = qname.indexOf(':');

      prefix = (index < 0) ? """" : qname.substring(0, index);
    }
    break;
    default :
      prefix = """";
    }

    return prefix;
  }

  
  public String getNamespaceURI(int nodeHandle)
  {
    if(JJK_NEWCODE)
    {
      int id=makeNodeIdentity(nodeHandle);
      if(id==NULL) return null;
      Node node=(Node)m_nodes.elementAt(id);
      return node.getNamespaceURI();
    }
    else
    {
      String nsuri;
      short type = getNodeType(nodeHandle);
      
      switch (type)
      {
      case DTM.ATTRIBUTE_NODE :
      case DTM.ELEMENT_NODE :
      case DTM.ENTITY_REFERENCE_NODE :
      case DTM.NAMESPACE_NODE :
      case DTM.PROCESSING_INSTRUCTION_NODE :
	{
	  Node node = getNode(nodeHandle);
	  
	  
	  nsuri = node.getNamespaceURI();
	  
	  
	}
	break;
      default :
	nsuri = null;
      }

      return nsuri;
    }
    
  }
  
  
  private Node logicalNextDOMTextNode(Node n)
  {
        Node p=n.getNextSibling();
        if(p==null)
        {
                
                for(n=n.getParentNode();
                        n!=null && ENTITY_REFERENCE_NODE == n.getNodeType();
                        n=n.getParentNode())
                {
                        p=n.getNextSibling();
                        if(p!=null)
                                break;
                }
        }
        n=p;
        while(n!=null && ENTITY_REFERENCE_NODE == n.getNodeType())
        {
                
                if(n.hasChildNodes())
                        n=n.getFirstChild();
                else
                        n=n.getNextSibling();
        }
        if(n!=null)
        {
                
                int ntype=n.getNodeType();
                if(TEXT_NODE != ntype && CDATA_SECTION_NODE != ntype)
                        n=null;
        }
        return n;
  }

  
  public String getNodeValue(int nodeHandle)
  {
    
    
    
    int type = _exptype(makeNodeIdentity(nodeHandle));
    type=(NULL != type) ? getNodeType(nodeHandle) : NULL;
    
    if(TEXT_NODE!=type && CDATA_SECTION_NODE!=type)
      return getNode(nodeHandle).getNodeValue();
    
    
    
    
    
    
    
    
    Node node = getNode(nodeHandle);
    Node n=logicalNextDOMTextNode(node);
    if(n==null)
      return node.getNodeValue();
    
    FastStringBuffer buf = StringBufferPool.get();
        buf.append(node.getNodeValue());
    while(n!=null)
    {
      buf.append(n.getNodeValue());
      n=logicalNextDOMTextNode(n);
    }
    String s = (buf.length() > 0) ? buf.toString() : """";
    StringBufferPool.free(buf);
    return s;
  }

  
  public String getDocumentTypeDeclarationSystemIdentifier()
  {

    Document doc;

    if (m_root.getNodeType() == Node.DOCUMENT_NODE)
      doc = (Document) m_root;
    else
      doc = m_root.getOwnerDocument();

    if (null != doc)
    {
      DocumentType dtd = doc.getDoctype();

      if (null != dtd)
      {
        return dtd.getSystemId();
      }
    }

    return null;
  }

  
  public String getDocumentTypeDeclarationPublicIdentifier()
  {

    Document doc;

    if (m_root.getNodeType() == Node.DOCUMENT_NODE)
      doc = (Document) m_root;
    else
      doc = m_root.getOwnerDocument();

    if (null != doc)
    {
      DocumentType dtd = doc.getDoctype();

      if (null != dtd)
      {
        return dtd.getPublicId();
      }
    }

    return null;
  }

  
  public int getElementById(String elementId)
  {

    Document doc = (m_root.getNodeType() == Node.DOCUMENT_NODE) 
        ? (Document) m_root : m_root.getOwnerDocument();
        
    if(null != doc)
    {
      Node elem = doc.getElementById(elementId);
      if(null != elem)
      {
        int elemHandle = getHandleFromNode(elem);
        
        if(DTM.NULL == elemHandle)
        {
          int identity = m_nodes.size()-1;
          while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
          {
            Node node = getNode(identity);
            if(node == elem)
            {
              elemHandle = getHandleFromNode(elem);
              break;
            }
           }
        }
        
        return elemHandle;
      }
    
    }
    return DTM.NULL;
  }

  
  public String getUnparsedEntityURI(String name)
  {

    String url = """";
    Document doc = (m_root.getNodeType() == Node.DOCUMENT_NODE) 
        ? (Document) m_root : m_root.getOwnerDocument();

    if (null != doc)
    {
      DocumentType doctype = doc.getDoctype();
  
      if (null != doctype)
      {
        NamedNodeMap entities = doctype.getEntities();
        if(null == entities)
          return url;
        Entity entity = (Entity) entities.getNamedItem(name);
        if(null == entity)
          return url;
        
        String notationName = entity.getNotationName();
  
        if (null != notationName)  
        {
          
          
          
          
          
          
          
          
          
          url = entity.getSystemId();
  
          if (null == url)
          {
            url = entity.getPublicId();
          }
          else
          {
            
            
          }        
        }
      }
    }

    return url;
  }

  
  public boolean isAttributeSpecified(int attributeHandle)
  {
    int type = getNodeType(attributeHandle);

    if (DTM.ATTRIBUTE_NODE == type)
    {
      Attr attr = (Attr)getNode(attributeHandle);
      return attr.getSpecified();
    }
    return false;
  }

  
  public void setIncrementalSAXSource(IncrementalSAXSource source)
  {
  }
  
  
  public org.xml.sax.ContentHandler getContentHandler()
  {
      return null;
  }
  
  
  public org.xml.sax.ext.LexicalHandler getLexicalHandler()
  {

    return null;
  }

  
  
  public org.xml.sax.EntityResolver getEntityResolver()
  {

    return null;
  }
  
  
  public org.xml.sax.DTDHandler getDTDHandler()
  {

    return null;
  }

  
  public org.xml.sax.ErrorHandler getErrorHandler()
  {

    return null;
  }
  
  
  public org.xml.sax.ext.DeclHandler getDeclHandler()
  {

    return null;
  }  

  
  public boolean needsTwoThreads()
  {
    return false;
  }

  
  
  
  private static boolean isSpace(char ch)
  {
    return XMLCharacterRecognizer.isWhiteSpace(ch);  
  }

  
  public void dispatchCharactersEvents(
          int nodeHandle, org.xml.sax.ContentHandler ch, 
          boolean normalize)
            throws org.xml.sax.SAXException
  {
    if(normalize)
    {
      XMLString str = getStringValue(nodeHandle);
      str = str.fixWhiteSpace(true, true, false);
      str.dispatchCharactersEvents(ch);
    }
    else
    {
      int type = getNodeType(nodeHandle);
      Node node = getNode(nodeHandle);
      dispatchNodeData(node, ch, 0);
          
          
          if(TEXT_NODE == type || CDATA_SECTION_NODE == type)
          {
                  while( null != (node=logicalNextDOMTextNode(node)) )
                  {
                      dispatchNodeData(node, ch, 0);
                  }
          }
    }
  }
  
  
  protected static void dispatchNodeData(Node node, 
                                         org.xml.sax.ContentHandler ch, 
                                         int depth)
            throws org.xml.sax.SAXException
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_FRAGMENT_NODE :
    case Node.DOCUMENT_NODE :
    case Node.ELEMENT_NODE :
    {
      for (Node child = node.getFirstChild(); null != child;
              child = child.getNextSibling())
      {
        dispatchNodeData(child, ch, depth+1);
      }
    }
    break;
    case Node.PROCESSING_INSTRUCTION_NODE : 
    case Node.COMMENT_NODE :
      if(0 != depth)
        break;
        
        
    case Node.TEXT_NODE :
    case Node.CDATA_SECTION_NODE :
    case Node.ATTRIBUTE_NODE :
      String str = node.getNodeValue();
      if(ch instanceof CharacterNodeHandler)
      {
        ((CharacterNodeHandler)ch).characters(node);
      }
      else
      {
        ch.characters(str.toCharArray(), 0, str.length());
      }
      break;



    default :
      
      break;
    }
  }
  
  TreeWalker m_walker = new TreeWalker(null);
  
  
  public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {
    TreeWalker treeWalker = m_walker;
    ContentHandler prevCH = treeWalker.getContentHandler();
    
    if(null != prevCH)
    {
      treeWalker = new TreeWalker(null);
    }
    treeWalker.setContentHandler(ch);
    
    try
    {
      Node node = getNode(nodeHandle);
      treeWalker.traverse(node);
    }
    finally
    {
      treeWalker.setContentHandler(null);
    }
  }
  
  public interface CharacterNodeHandler
  {
    public void characters(Node node)
            throws org.xml.sax.SAXException;
  }

  
  public void setProperty(String property, Object value)
  {
  }
  
  
  public SourceLocator getSourceLocatorFor(int node)
  {
    return null;
  }

}


"
org.apache.xml.dtm.ref.DTMDocumentImpl,110,1,0,13,149,5191,0,13,96,0.943807339,1849,0.666666667,8,0.0,0.11983945,0,0,15.59090909,10,1.5364,1,"
package org.apache.xml.dtm.ref;

import javax.xml.transform.SourceLocator;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.ext.LexicalHandler;


public class DTMDocumentImpl
implements DTM, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler
{

        
        protected static final byte DOCHANDLE_SHIFT = 22;
        
        
        protected static final int NODEHANDLE_MASK = (1 << (DOCHANDLE_SHIFT + 1)) - 1;
        
        
        protected static final int DOCHANDLE_MASK = -1 - NODEHANDLE_MASK;

        int m_docHandle = NULL;		 
        int m_docElement = NULL;	 

        
        int currentParent = 0;			
        int previousSibling = 0;		
        protected int m_currentNode = -1;		

        
        
        

        private boolean previousSiblingWasParent = false;
        
        int gotslot[] = new int[4];

        
        private boolean done = false;
        boolean m_isError = false;

        private final boolean DEBUG = false;

        
        protected String m_documentBaseURI;

  
  private IncrementalSAXSource m_incrSAXSource=null;


        

        
        
        
        
        ChunkedIntArray nodes = new ChunkedIntArray(4);

        
        
        private FastStringBuffer m_char = new FastStringBuffer();
        
        
        private int m_char_current_start=0;

        
        
        
        
        
        private DTMStringPool m_localNames = new DTMStringPool();
        private DTMStringPool m_nsNames = new DTMStringPool();
        private DTMStringPool m_prefixNames = new DTMStringPool();

        
        
        
        
        
        
        private ExpandedNameTable m_expandedNames=
                new ExpandedNameTable();

        private XMLStringFactory m_xsf;


        
        public DTMDocumentImpl(DTMManager mgr, int documentNumber,
                               DTMWSFilter whiteSpaceFilter,
                               XMLStringFactory xstringfactory){
                initDocument(documentNumber);	 
                m_xsf = xstringfactory;
        }

  
  public void setIncrementalSAXSource(IncrementalSAXSource source)
  {
    m_incrSAXSource=source;

    
    source.setContentHandler(this);
    source.setLexicalHandler(this);

    
    
    
    
    
  }

        
        private final int appendNode(int w0, int w1, int w2, int w3)
        {
                
                int slotnumber = nodes.appendSlot(w0, w1, w2, w3);

                if (DEBUG) System.out.println(slotnumber+"": ""+w0+"" ""+w1+"" ""+w2+"" ""+w3);

                if (previousSiblingWasParent)
                        nodes.writeEntry(previousSibling,2,slotnumber);

                previousSiblingWasParent = false;	

                return slotnumber;
        }

        

        
        public void setFeature(String featureId, boolean state) {};

        
        public void setLocalNameTable(DTMStringPool poolRef) {
                m_localNames = poolRef;
        }

        
        public DTMStringPool getLocalNameTable() {
                 return m_localNames;
         }

        
        public void setNsNameTable(DTMStringPool poolRef) {
                m_nsNames = poolRef;
        }

        
        public DTMStringPool getNsNameTable() {
                 return m_nsNames;
         }

        
        public void setPrefixNameTable(DTMStringPool poolRef) {
                m_prefixNames = poolRef;
        }

        
        public DTMStringPool getPrefixNameTable() {
                return m_prefixNames;
        }

         
         void setContentBuffer(FastStringBuffer buffer) {
                 m_char = buffer;
         }

         
         FastStringBuffer getContentBuffer() {
                 return m_char;
         }

  
  public org.xml.sax.ContentHandler getContentHandler()
  {
    if (m_incrSAXSource instanceof IncrementalSAXSource_Filter)
      return (ContentHandler) m_incrSAXSource;
    else
      return this;
  }

  
  public LexicalHandler getLexicalHandler()
  {

    if (m_incrSAXSource instanceof IncrementalSAXSource_Filter)
      return (LexicalHandler) m_incrSAXSource;
    else
      return this;
  }

  
  public org.xml.sax.EntityResolver getEntityResolver()
  {

    return null;
  }

  
  public org.xml.sax.DTDHandler getDTDHandler()
  {

    return null;
  }

  
  public org.xml.sax.ErrorHandler getErrorHandler()
  {

    return null;
  }

  
  public org.xml.sax.ext.DeclHandler getDeclHandler()
  {

    return null;
  }

  
  public boolean needsTwoThreads()
  {
    return null!=m_incrSAXSource;
  }

  
  
  
  

  public void characters(char[] ch, int start, int length)
       throws org.xml.sax.SAXException
  {
    
    
    
    m_char.append(ch,start,length);
  }

  
  private void processAccumulatedText()
  {
    int len=m_char.length();
    if(len!=m_char_current_start)
      {
        
        appendTextChild(m_char_current_start,len-m_char_current_start);
        m_char_current_start=len;
      }
  }
  public void endDocument()
       throws org.xml.sax.SAXException
  {
    
    
    appendEndDocument();
  }
  public void endElement(java.lang.String namespaceURI, java.lang.String localName,
      java.lang.String qName)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();
    
    
    appendEndElement();
  }
  public void endPrefixMapping(java.lang.String prefix)
       throws org.xml.sax.SAXException
  {
    
  }
  public void ignorableWhitespace(char[] ch, int start, int length)
       throws org.xml.sax.SAXException
  {
    
  }
  public void processingInstruction(java.lang.String target, java.lang.String data)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();
    
  }
  public void setDocumentLocator(Locator locator)
  {
    
  }
  public void skippedEntity(java.lang.String name)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();
    
  }
  public void startDocument()
       throws org.xml.sax.SAXException
  {
    appendStartDocument();
  }
  public void startElement(java.lang.String namespaceURI, java.lang.String localName,
      java.lang.String qName, Attributes atts)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();

    
    String prefix=null;
    int colon=qName.indexOf(':');
    if(colon>0)
      prefix=qName.substring(0,colon);

    
    System.out.println(""Prefix=""+prefix+"" index=""+m_prefixNames.stringToIndex(prefix));
    appendStartElement(m_nsNames.stringToIndex(namespaceURI),
                     m_localNames.stringToIndex(localName),
                     m_prefixNames.stringToIndex(prefix)); 

    
    
    
    int nAtts=(atts==null) ? 0 : atts.getLength();
    
    for(int i=nAtts-1;i>=0;--i)
      {
        qName=atts.getQName(i);
        if(qName.startsWith(""xmlns:"") || ""xmlns"".equals(qName))
          {
            prefix=null;
            colon=qName.indexOf(':');
            if(colon>0)
              {
                prefix=qName.substring(0,colon);
              }
            else
              {
                
                prefix=null; 
              }


            appendNSDeclaration(
                                    m_prefixNames.stringToIndex(prefix),
                                    m_nsNames.stringToIndex(atts.getValue(i)),
                                    atts.getType(i).equalsIgnoreCase(""ID""));
          }
      }

    for(int i=nAtts-1;i>=0;--i)
      {
        qName=atts.getQName(i);
        if(!(qName.startsWith(""xmlns:"") || ""xmlns"".equals(qName)))
          {
            
            
            
            prefix=null;
            colon=qName.indexOf(':');
            if(colon>0)
              {
                prefix=qName.substring(0,colon);
                localName=qName.substring(colon+1);
              }
            else
              {
                prefix=""""; 
                localName=qName;
              }


            m_char.append(atts.getValue(i)); 
            int contentEnd=m_char.length();

            if(!(""xmlns"".equals(prefix) || ""xmlns"".equals(qName)))
              appendAttribute(m_nsNames.stringToIndex(atts.getURI(i)),
                                  m_localNames.stringToIndex(localName),
                                  m_prefixNames.stringToIndex(prefix),
                                  atts.getType(i).equalsIgnoreCase(""ID""),
                                  m_char_current_start, contentEnd-m_char_current_start);
            m_char_current_start=contentEnd;
          }
      }
  }
  public void startPrefixMapping(java.lang.String prefix, java.lang.String uri)
       throws org.xml.sax.SAXException
  {
    
  }

  
  
  
  
  public void comment(char[] ch, int start, int length)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();

    m_char.append(ch,start,length); 
    appendComment(m_char_current_start,length);
    m_char_current_start+=length;
  }
  public void endCDATA()
       throws org.xml.sax.SAXException
  {
    
  }
  public void endDTD()
       throws org.xml.sax.SAXException
  {
    
  }
  public void endEntity(java.lang.String name)
       throws org.xml.sax.SAXException
  {
    
  }
  public void startCDATA()
       throws org.xml.sax.SAXException
  {
    
  }
  public void startDTD(java.lang.String name, java.lang.String publicId,
      java.lang.String systemId)
       throws org.xml.sax.SAXException
  {
    
  }
  public void startEntity(java.lang.String name)
       throws org.xml.sax.SAXException
  {
    
  }


  
  
  
  
  

        
        final void initDocument(int documentNumber)
        {
                
                m_docHandle = documentNumber<<DOCHANDLE_SHIFT;

                
                nodes.writeSlot(0,DOCUMENT_NODE,-1,-1,0);
                
                done = false;
        }


































































































































































































































































































































































        

        
        public boolean hasChildNodes(int nodeHandle) {
                return(getFirstChild(nodeHandle) != NULL);
        }

        
        public int getFirstChild(int nodeHandle) {

                
                nodeHandle &= NODEHANDLE_MASK;
                
                nodes.readSlot(nodeHandle, gotslot);

                
                short type = (short) (gotslot[0] & 0xFFFF);

                
                if ((type == ELEMENT_NODE) || (type == DOCUMENT_NODE) ||
                                (type == ENTITY_REFERENCE_NODE)) {

                        
                        
                        
                        
                        
                        

                        int kid = nodeHandle + 1;
                        nodes.readSlot(kid, gotslot);
                        while (ATTRIBUTE_NODE == (gotslot[0] & 0xFFFF)) {
                                
                                kid = gotslot[2];
                                
                                if (kid == NULL) return NULL;
                                nodes.readSlot(kid, gotslot);
                        }
                        
                        if (gotslot[1] == nodeHandle)
                        {
                          int firstChild = kid | m_docHandle;

                          return firstChild;
                        }
                }
                

                return NULL;
        }

        
        public int getLastChild(int nodeHandle) {
                
                nodeHandle &= NODEHANDLE_MASK;
                
                int lastChild = NULL;
                for (int nextkid = getFirstChild(nodeHandle); nextkid != NULL;
                                nextkid = getNextSibling(nextkid)) {
                        lastChild = nextkid;
                }
                return lastChild | m_docHandle;
        }

        
        public int getAttributeNode(int nodeHandle, String namespaceURI, String name) {
                int nsIndex = m_nsNames.stringToIndex(namespaceURI),
                                                                        nameIndex = m_localNames.stringToIndex(name);
                nodeHandle &= NODEHANDLE_MASK;
                nodes.readSlot(nodeHandle, gotslot);
                short type = (short) (gotslot[0] & 0xFFFF);
                
                if (type == ELEMENT_NODE)
                        nodeHandle++;
                
                while (type == ATTRIBUTE_NODE) {
                        if ((nsIndex == (gotslot[0] << 16)) && (gotslot[3] == nameIndex))
                                return nodeHandle | m_docHandle;
                        
                        nodeHandle = gotslot[2];
                        nodes.readSlot(nodeHandle, gotslot);
                }
                return NULL;
        }

        
        public int getFirstAttribute(int nodeHandle) {
                nodeHandle &= NODEHANDLE_MASK;

                
                
                
                

                
                if (ELEMENT_NODE != (nodes.readEntry(nodeHandle, 0) & 0xFFFF))
                        return NULL;
                
                nodeHandle++;
                return(ATTRIBUTE_NODE == (nodes.readEntry(nodeHandle, 0) & 0xFFFF)) ?
                nodeHandle | m_docHandle : NULL;
        }

        
        public int getFirstNamespaceNode(int nodeHandle, boolean inScope) {

                return NULL;
        }

        
        public int getNextSibling(int nodeHandle) {
                nodeHandle &= NODEHANDLE_MASK;
                
                if (nodeHandle == 0)
                        return NULL;

                short type = (short) (nodes.readEntry(nodeHandle, 0) & 0xFFFF);
                if ((type == ELEMENT_NODE) || (type == ATTRIBUTE_NODE) ||
                                (type == ENTITY_REFERENCE_NODE)) {
                        int nextSib = nodes.readEntry(nodeHandle, 2);
                        if (nextSib == NULL)
                                return NULL;
                        if (nextSib != 0)
                                return (m_docHandle | nextSib);
                        
                }
                
                int thisParent = nodes.readEntry(nodeHandle, 1);

                if (nodes.readEntry(++nodeHandle, 1) == thisParent)
                        return (m_docHandle | nodeHandle);

                return NULL;
        }

        
        public int getPreviousSibling(int nodeHandle) {
                nodeHandle &= NODEHANDLE_MASK;
                
                if (nodeHandle == 0)
                        return NULL;

                int parent = nodes.readEntry(nodeHandle, 1);
                int kid = NULL;
                for (int nextkid = getFirstChild(parent); nextkid != nodeHandle;
                                nextkid = getNextSibling(nextkid)) {
                        kid = nextkid;
                }
                return kid | m_docHandle;
        }

        
        public int getNextAttribute(int nodeHandle) {
                nodeHandle &= NODEHANDLE_MASK;
                nodes.readSlot(nodeHandle, gotslot);

                
                
                
                
                short type = (short) (gotslot[0] & 0xFFFF);

                if (type == ELEMENT_NODE) {
                        return getFirstAttribute(nodeHandle);
                } else if (type == ATTRIBUTE_NODE) {
                        if (gotslot[2] != NULL)
                                return (m_docHandle | gotslot[2]);
                }
                return NULL;
        }

        
        public int getNextNamespaceNode(int baseHandle,int namespaceHandle, boolean inScope) {
                
                return NULL;
        }

        
        public int getNextDescendant(int subtreeRootHandle, int nodeHandle) {
                subtreeRootHandle &= NODEHANDLE_MASK;
                nodeHandle &= NODEHANDLE_MASK;
                
                if (nodeHandle == 0)
                        return NULL;
                while (!m_isError) {
                        
                        if (done && (nodeHandle > nodes.slotsUsed()))
                                break;
                        if (nodeHandle > subtreeRootHandle) {
                                nodes.readSlot(nodeHandle+1, gotslot);
                                if (gotslot[2] != 0) {
                                        short type = (short) (gotslot[0] & 0xFFFF);
                                        if (type == ATTRIBUTE_NODE) {
                                                nodeHandle +=2;
                                        } else {
                                                int nextParentPos = gotslot[1];
                                                if (nextParentPos >= subtreeRootHandle)
                                                        return (m_docHandle | (nodeHandle+1));
                                                else
                                                        break;
                                        }
                                } else if (!done) {
                                        
                                } else
                                        break;
                        } else {
                                nodeHandle++;
                        }
                }
                
                return NULL;
        }

        
        public int getNextFollowing(int axisContextHandle, int nodeHandle) {
                
                return NULL;
        }

        
        public int getNextPreceding(int axisContextHandle, int nodeHandle) {
                
                nodeHandle &= NODEHANDLE_MASK;
                while (nodeHandle > 1) {
                        nodeHandle--;
                        if (ATTRIBUTE_NODE == (nodes.readEntry(nodeHandle, 0) & 0xFFFF))
                                continue;

                        
                        
                        

                        
                        
                        

                        return (m_docHandle | nodes.specialFind(axisContextHandle, nodeHandle));
                }
                return NULL;
        }

        
        public int getParent(int nodeHandle) {
                

                
                return (m_docHandle | nodes.readEntry(nodeHandle, 1));
        }

        
        public int getDocumentRoot() {
                return (m_docHandle | m_docElement);
        }

        
        public int getDocument() {
                return m_docHandle;
        }

        
        public int getOwnerDocument(int nodeHandle) {
                
                if ((nodeHandle & NODEHANDLE_MASK) == 0)
                        return NULL;
                return (nodeHandle & DOCHANDLE_MASK);
        }

        
        public int getDocumentRoot(int nodeHandle) {
                
                if ((nodeHandle & NODEHANDLE_MASK) == 0)
                        return NULL;
                return (nodeHandle & DOCHANDLE_MASK);
        }

        
        public XMLString getStringValue(int nodeHandle) {
        
        nodes.readSlot(nodeHandle, gotslot);
        int nodetype=gotslot[0] & 0xFF;
        String value=null;

        switch (nodetype) {
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
                value= m_char.getString(gotslot[2], gotslot[3]);
                break;
        case PROCESSING_INSTRUCTION_NODE:
        case ATTRIBUTE_NODE:
        case ELEMENT_NODE:
        case ENTITY_REFERENCE_NODE:
        default:
                break;
        }
        return m_xsf.newstr( value );

        }

        
        
        public int getStringValueChunkCount(int nodeHandle)
        {
                
                return 0;
        }

        
        
        public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
                                                                                                                                                int[] startAndLen) {return new char[0];}

        
        public int getExpandedTypeID(int nodeHandle) {
           nodes.readSlot(nodeHandle, gotslot);
           String qName = m_localNames.indexToString(gotslot[3]);
           
           
           int colonpos = qName.indexOf("":"");
           String localName = qName.substring(colonpos+1);
           
           String namespace = m_nsNames.indexToString(gotslot[0] << 16);
           
           String expandedName = namespace + "":"" + localName;
           int expandedNameID = m_nsNames.stringToIndex(expandedName);

        return expandedNameID;
        }


        
        public int getExpandedTypeID(String namespace, String localName, int type) {
           
          
          
          
          
           String expandedName = namespace + "":"" + localName;
           int expandedNameID = m_nsNames.stringToIndex(expandedName);

           return expandedNameID;
        }


        
        public String getLocalNameFromExpandedNameID(int ExpandedNameID) {

           
           String expandedName = m_localNames.indexToString(ExpandedNameID);
           
           int colonpos = expandedName.indexOf("":"");
           String localName = expandedName.substring(colonpos+1);
           return localName;
        }


        
        public String getNamespaceFromExpandedNameID(int ExpandedNameID) {

           String expandedName = m_localNames.indexToString(ExpandedNameID);
           
           int colonpos = expandedName.indexOf("":"");
           String nsName = expandedName.substring(0, colonpos);

        return nsName;
        }


        
        static final String[] fixednames=
        {
                null,null,							
                null,""#text"",						
                ""#cdata_section"",null,	
                null,null,							
                ""#comment"",""#document"",	
                null,""#document-fragment"", 
                null};									

        
        public String getNodeName(int nodeHandle) {
                nodes.readSlot(nodeHandle, gotslot);
                short type = (short) (gotslot[0] & 0xFFFF);
                String name = fixednames[type];
                if (null == name) {
                  int i=gotslot[3];
                  System.out.println(""got i=""+i+"" ""+(i>>16)+""/""+(i&0xffff));

                  name=m_localNames.indexToString(i & 0xFFFF);
                  String prefix=m_prefixNames.indexToString(i >>16);
                  if(prefix!=null && prefix.length()>0)
                    name=prefix+"":""+name;
                }
                return name;
        }

        
        public String getNodeNameX(int nodeHandle) {return null;}

        
        public String getLocalName(int nodeHandle) {
                nodes.readSlot(nodeHandle, gotslot);
                short type = (short) (gotslot[0] & 0xFFFF);
                String name = """";
                if ((type==ELEMENT_NODE) || (type==ATTRIBUTE_NODE)) {
                  int i=gotslot[3];
                  name=m_localNames.indexToString(i & 0xFFFF);
                  if(name==null) name="""";
                }
                return name;
        }

        
        public String getPrefix(int nodeHandle) {
                nodes.readSlot(nodeHandle, gotslot);
                short type = (short) (gotslot[0] & 0xFFFF);
                String name = """";
                if((type==ELEMENT_NODE) || (type==ATTRIBUTE_NODE)) {
                  int i=gotslot[3];
                  name=m_prefixNames.indexToString(i >>16);
                  if(name==null) name="""";
                }
                return name;
        }

        
        public String getNamespaceURI(int nodeHandle) {return null;}

        
        public String getNodeValue(int nodeHandle)
        {
                nodes.readSlot(nodeHandle, gotslot);
                int nodetype=gotslot[0] & 0xFF;		
                String value=null;

                switch (nodetype) {			
                case ATTRIBUTE_NODE:
                        nodes.readSlot(nodeHandle+1, gotslot);
                case TEXT_NODE:
                case COMMENT_NODE:
                case CDATA_SECTION_NODE:
                        value=m_char.getString(gotslot[2], gotslot[3]);		
                        break;
                case PROCESSING_INSTRUCTION_NODE:
                case ELEMENT_NODE:
                case ENTITY_REFERENCE_NODE:
                default:
                        break;
                }
                return value;
        }

        
        public short getNodeType(int nodeHandle) {
                return(short) (nodes.readEntry(nodeHandle, 0) & 0xFFFF);
        }

        
        public short getLevel(int nodeHandle) {
                short count = 0;
                while (nodeHandle != 0) {
                        count++;
                        nodeHandle = nodes.readEntry(nodeHandle, 1);
                }
                return count;
        }

        

        
        public boolean isSupported(String feature, String version) {return false;}

        
        public String getDocumentBaseURI()
        {

          return m_documentBaseURI;
        }

        
        public void setDocumentBaseURI(String baseURI)
        {

          m_documentBaseURI = baseURI;
        }

        
        public String getDocumentSystemIdentifier(int nodeHandle) {return null;}

        
        public String getDocumentEncoding(int nodeHandle) {return null;}

        
        public String getDocumentStandalone(int nodeHandle) {return null;}

        
        public String getDocumentVersion(int documentHandle) {return null;}

        
        public boolean getDocumentAllDeclarationsProcessed() {return false;}

        
        public String getDocumentTypeDeclarationSystemIdentifier() {return null;}

        
        public String getDocumentTypeDeclarationPublicIdentifier() {return null;}

        
        public int getElementById(String elementId) {return 0;}

        
        public String getUnparsedEntityURI(String name) {return null;}


        

        
        public boolean supportsPreStripping() {return false;}

        
        public boolean isNodeAfter(int nodeHandle1, int nodeHandle2) {return false;}

        
        public boolean isCharacterElementContentWhitespace(int nodeHandle) {return false;}

        
        public boolean isDocumentAllDeclarationsProcessed(int documentHandle) {return false;}

        
        public boolean isAttributeSpecified(int attributeHandle) {return false;}

        

        
        public void dispatchCharactersEvents(
                                                                                                                                                        int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize)
        throws org.xml.sax.SAXException {}

        

        public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
        throws org.xml.sax.SAXException {}

        
        public org.w3c.dom.Node getNode(int nodeHandle)
        {
          return null;
        }

        
        
        
        

        
        public void appendChild(int newChild, boolean clone, boolean cloneDepth) {
                boolean sameDoc = ((newChild & DOCHANDLE_MASK) == m_docHandle);
                if (clone || !sameDoc) {

                } else {

                }
        }

        
        public void appendTextChild(String str) {
                
          
        }


  
  
  
  

  
  void appendTextChild(int m_char_current_start,int contentLength)
  {
    
    
    int w0 = TEXT_NODE;
    
    int w1 = currentParent;
    
    int w2 = m_char_current_start;
    
    int w3 = contentLength;

    int ourslot = appendNode(w0, w1, w2, w3);
    previousSibling = ourslot;
  }

  
  void appendComment(int m_char_current_start,int contentLength)
  {
    
    
    int w0 = COMMENT_NODE;
    
    int w1 = currentParent;
    
    int w2 = m_char_current_start;
    
    int w3 = contentLength;

    int ourslot = appendNode(w0, w1, w2, w3);
    previousSibling = ourslot;
  }


  
  void appendStartElement(int namespaceIndex,int localNameIndex, int prefixIndex)
  {
                
                
                
                

                
                int w0 = (namespaceIndex << 16) | ELEMENT_NODE;
                
                int w1 = currentParent;
                
                int w2 = 0;
                
                int w3 = localNameIndex | prefixIndex<<16;
                System.out.println(""set w3=""+w3+"" ""+(w3>>16)+""/""+(w3&0xffff));

                
                int ourslot = appendNode(w0, w1, w2, w3);
                currentParent = ourslot;
                previousSibling = 0;

                
                if (m_docElement == NULL)
                        m_docElement = ourslot;
  }

  
  void appendNSDeclaration(int prefixIndex, int namespaceIndex,
                           boolean isID)
  {
    
    
    
    

    
    

    

    final int namespaceForNamespaces=m_nsNames.stringToIndex(""http:

    
    int w0 = NAMESPACE_NODE | (m_nsNames.stringToIndex(""http:

    
    int w1 = currentParent;
    
    int w2 = 0;
    
    int w3 = namespaceIndex;
    
    int ourslot = appendNode(w0, w1, w2, w3);
    previousSibling = ourslot;	
    previousSiblingWasParent = false;
    return ;
  }

  
  void appendAttribute(int namespaceIndex, int localNameIndex, int prefixIndex,
                       boolean isID,
                       int m_char_current_start, int contentLength)
  {
    

    
    int w0 = ATTRIBUTE_NODE | namespaceIndex<<16;

    
    int w1 = currentParent;
    
    int w2 = 0;
    
    int w3 = localNameIndex | prefixIndex<<16;
    System.out.println(""set w3=""+w3+"" ""+(w3>>16)+""/""+(w3&0xffff));
    
    int ourslot = appendNode(w0, w1, w2, w3);
    previousSibling = ourslot;	

    

    
    w0 = TEXT_NODE;
    
    w1 = ourslot;
    
    w2 = m_char_current_start;
    
    w3 = contentLength;
    appendNode(w0, w1, w2, w3);

    
    previousSiblingWasParent = true;
    return ;
  }

  
  public DTMAxisTraverser getAxisTraverser(final int axis)
  {
    return null;
  }

  
  public DTMAxisIterator getAxisIterator(final int axis)
  {
    
    return null;
  }

  
  public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)
  {
    
    return null;
  }


  
  void appendEndElement()
  {
    

    if (previousSiblingWasParent)
      nodes.writeEntry(previousSibling, 2, NULL);

    
    previousSibling = currentParent;
    nodes.readSlot(currentParent, gotslot);
    currentParent = gotslot[1] & 0xFFFF;

    
    
    previousSiblingWasParent = true;

    
    
  }

  
  void appendStartDocument()
  {

    
    
    m_docElement = NULL;	 
    initDocument(0);
  }

  
  void appendEndDocument()
  {
    done = true;
    
    
  }

  
  public void setProperty(String property, Object value)
  {
  }

  
  public SourceLocator getSourceLocatorFor(int node)
  {
    return null;
  }


  
   public void documentRegistration()
   {
   }

  
   public void documentRelease()
   {
   }


}
"
org.apache.xalan.xsltc.compiler.EqualityExpr,12,3,0,37,49,0,1,36,11,0.333333333,836,1.0,2,0.865853659,0.238095238,2,8,68.41666667,18,3.25,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.BranchInstruction;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IFNE;
import org.apache.bcel.generic.IF_ICMPEQ;
import org.apache.bcel.generic.IF_ICMPNE;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.BooleanType;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.IntType;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.NumberType;
import org.apache.xalan.xsltc.compiler.util.RealType;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.ResultTreeType;
import org.apache.xalan.xsltc.compiler.util.StringType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.runtime.Operators;

final class EqualityExpr extends Expression implements Operators {
    private final int _op;
    private Expression _left;
    private Expression _right;
		
    public EqualityExpr(int op, Expression left, Expression right) {
	_op = op;
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }
    
    public String toString() {
	return Operators.names[_op] + '(' + _left + "", "" + _right + ')';
    }

    public Expression getLeft() {
	return _left;
    }

    public Expression getRight() {
	return _right;
    }

    public boolean getOp() {
	return (_op != Operators.NE);
    }

    
    public boolean hasPositionCall() {
	if (_left.hasPositionCall()) return true;
	if (_right.hasPositionCall()) return true;
	return false;
    }

    public boolean hasLastCall() {
	if (_left.hasLastCall()) return true;
	if (_right.hasLastCall()) return true;
	return false;
    }

    private void swapArguments() {
	final Expression temp = _left;
	_left = _right;
	_right = temp;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tleft = _left.typeCheck(stable); 
	final Type tright = _right.typeCheck(stable);

	if (tleft.isSimple() && tright.isSimple()) {
	    if (tleft != tright) {
		if (tleft instanceof BooleanType) {
		    _right = new CastExpr(_right, Type.Boolean);
		}
		else if (tright instanceof BooleanType) {
		    _left = new CastExpr(_left, Type.Boolean);
		}
		else if (tleft instanceof NumberType || 
			 tright instanceof NumberType) {
		    _left = new CastExpr(_left, Type.Real);
		    _right = new CastExpr(_right, Type.Real);
		}
		else {		
		    _left = new CastExpr(_left,   Type.String);
		    _right = new CastExpr(_right, Type.String);
		}
	    }
	}
	else if (tleft instanceof ReferenceType) {
	    _right = new CastExpr(_right, Type.Reference);
	}
	else if (tright instanceof ReferenceType) {
	    _left = new CastExpr(_left, Type.Reference);
	}
	
	else if (tleft instanceof NodeType && tright == Type.String) {
	    _left = new CastExpr(_left, Type.String);
	}
	else if (tleft == Type.String && tright instanceof NodeType) {
	    _right = new CastExpr(_right, Type.String);
	}
	
	else if (tleft instanceof NodeType && tright instanceof NodeType) {
	    _left = new CastExpr(_left, Type.String);
	    _right = new CastExpr(_right, Type.String);
	}
	else if (tleft instanceof NodeType && tright instanceof NodeSetType) {
	    
	}
	else if (tleft instanceof NodeSetType && tright instanceof NodeType) {
	    swapArguments();	
	}
	else {	
	    

	    
	    if (tleft instanceof NodeType) {
		_left = new CastExpr(_left, Type.NodeSet);
	    }
	    if (tright instanceof NodeType) {
		_right = new CastExpr(_right, Type.NodeSet);
	    }

	    
	    if (tleft.isSimple() ||
		tleft instanceof ResultTreeType &&
		tright instanceof NodeSetType) {
		swapArguments();
	    }

	    
	    if (_right.getType() instanceof IntType) {
		_right = new CastExpr(_right, Type.Real);
	    }
	}
	return _type = Type.Boolean;
    }

    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	final Type tleft = _left.getType();
	final InstructionList il = methodGen.getInstructionList();

	if (tleft instanceof BooleanType) {
	    _left.translate(classGen, methodGen);
	    _right.translate(classGen, methodGen);
	    _falseList.add(il.append(_op == Operators.EQ ? 
				     (BranchInstruction)new IF_ICMPNE(null) :
				     (BranchInstruction)new IF_ICMPEQ(null)));
	}
	else if (tleft instanceof NumberType) {
	    _left.translate(classGen, methodGen);
	    _right.translate(classGen, methodGen);

	    if (tleft instanceof RealType) {
		il.append(DCMPG);
		_falseList.add(il.append(_op == Operators.EQ ? 
					 (BranchInstruction)new IFNE(null) : 
					 (BranchInstruction)new IFEQ(null)));
	    }
	    else {
		_falseList.add(il.append(_op == Operators.EQ ? 
					 (BranchInstruction)new IF_ICMPNE(null) :
					 (BranchInstruction)new IF_ICMPEQ(null)));
	    }
	}
	else {
	    translate(classGen, methodGen);
	    desynthesize(classGen, methodGen);
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final Type tleft = _left.getType();
	Type tright = _right.getType();

	if (tleft instanceof BooleanType || tleft instanceof NumberType) {
	    translateDesynthesized(classGen, methodGen);
	    synthesize(classGen, methodGen);
	    return;
	}

	if (tleft instanceof StringType) {
	    final int equals = cpg.addMethodref(STRING_CLASS,
						""equals"",
						""("" + OBJECT_SIG +"")Z"");
	    _left.translate(classGen, methodGen);
	    _right.translate(classGen, methodGen);
	    il.append(new INVOKEVIRTUAL(equals));

	    if (_op == Operators.NE) {
		il.append(ICONST_1);
		il.append(IXOR);			
	    }
	    return;
	}

	BranchHandle truec, falsec;
	
	if (tleft instanceof ResultTreeType) {
	    if (tright instanceof BooleanType) {
		_right.translate(classGen, methodGen);
		if (_op == Operators.NE) {
		    il.append(ICONST_1);
		    il.append(IXOR); 
		}
		return;
	    }

	    if (tright instanceof RealType) {
		_left.translate(classGen, methodGen);
		tleft.translateTo(classGen, methodGen, Type.Real);
		_right.translate(classGen, methodGen);

		il.append(DCMPG);
		falsec = il.append(_op == Operators.EQ ? 
				   (BranchInstruction) new IFNE(null) : 
				   (BranchInstruction) new IFEQ(null));
		il.append(ICONST_1);
		truec = il.append(new GOTO(null));
		falsec.setTarget(il.append(ICONST_0));
		truec.setTarget(il.append(NOP));
		return;
	    }

	    

	    _left.translate(classGen, methodGen);
	    tleft.translateTo(classGen, methodGen, Type.String);
	    _right.translate(classGen, methodGen);

	    if (tright instanceof ResultTreeType) {
		tright.translateTo(classGen, methodGen, Type.String);
	    }

	    final int equals = cpg.addMethodref(STRING_CLASS,
						""equals"",
						""("" +OBJECT_SIG+ "")Z"");
	    il.append(new INVOKEVIRTUAL(equals));

	    if (_op == Operators.NE) {
		il.append(ICONST_1);
		il.append(IXOR);			
	    }
	    return;
	}

	if (tleft instanceof NodeSetType && tright instanceof BooleanType) {
	    _left.translate(classGen, methodGen);
	    _left.startResetIterator(classGen, methodGen);
	    Type.NodeSet.translateTo(classGen, methodGen, Type.Boolean);
	    _right.translate(classGen, methodGen);

	    il.append(IXOR); 
	    if (_op == EQ) {
		il.append(ICONST_1);
		il.append(IXOR); 
	    }
	    return;
	}

	if (tleft instanceof NodeSetType && tright instanceof StringType) {
	    _left.translate(classGen, methodGen);
	    _left.startResetIterator(classGen, methodGen); 
	    _right.translate(classGen, methodGen);
	    il.append(new PUSH(cpg, _op));
	    il.append(methodGen.loadDOM());
	    final int cmp = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					     ""compare"",
					     ""(""
					     + tleft.toSignature() 
					     + tright.toSignature()
					     + ""I""
					     + DOM_INTF_SIG
					     + "")Z"");
	    il.append(new INVOKESTATIC(cmp));
	    return;
	}

	
	_left.translate(classGen, methodGen);
	_left.startResetIterator(classGen, methodGen);
	_right.translate(classGen, methodGen);
	_right.startResetIterator(classGen, methodGen);

	
	if (tright instanceof ResultTreeType) {
	    tright.translateTo(classGen, methodGen, Type.String);	
	    tright = Type.String;
	}

	
	il.append(new PUSH(cpg, _op));
	il.append(methodGen.loadDOM());

	final int compare = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					     ""compare"",
					     ""(""
					     + tleft.toSignature() 
					     + tright.toSignature()
					     + ""I""
					     + DOM_INTF_SIG
					     + "")Z"");
	il.append(new INVOKESTATIC(compare));
    }
}
"
org.apache.xalan.xsltc.runtime.Constants,0,1,0,1,0,0,1,0,0,2.0,14,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.apache.xalan.xsltc.runtime;

import org.apache.xml.dtm.DTM;


public interface Constants {

    final static int ANY       = -1;
    final static int ATTRIBUTE = -2;
    final static int ROOT      = DTM.ROOT_NODE;
    final static int TEXT      = DTM.TEXT_NODE;
    final static int ELEMENT   = DTM.ELEMENT_NODE;
    final static int COMMENT   = DTM.COMMENT_NODE;
    final static int PROCESSING_INSTRUCTION = DTM.PROCESSING_INSTRUCTION_NODE;

    public static String XSLT_URI = ""http:
    public static final String NAMESPACE_FEATURE =
	""http:

    public static final String EMPTYSTRING = """";
    public static final String XML_PREFIX = ""xml"";
    public static final String XMLNS_PREFIX = ""xmlns"";
    public static final String XMLNS_STRING = ""xmlns:"";
    public static final String XMLNS_URI = ""http:
}
"
org.apache.xalan.xsltc.compiler.ParentPattern,8,6,0,26,43,0,1,25,8,0.285714286,253,1.0,2,0.933962264,0.25,4,5,30.375,8,1.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class ParentPattern extends RelativePathPattern {
    private final Pattern _left;
    private final RelativePathPattern _right;
		
    public ParentPattern(Pattern left, RelativePathPattern right) {
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }
    
    public boolean isWildcard() {
	return false;
    }
	
    public StepPattern getKernelPattern() {
	return _right.getKernelPattern();
    }
	
    public void reduceKernelPattern() {
	_right.reduceKernelPattern();
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_left.typeCheck(stable);
	return _right.typeCheck(stable);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final LocalVariableGen local =
	    methodGen.addLocalVariable2(""ppt"", 
					Util.getJCRefType(NODE_SIG),
					il.getEnd());
	
	final org.apache.bcel.generic.Instruction loadLocal =
	    new ILOAD(local.getIndex());
	final org.apache.bcel.generic.Instruction storeLocal =
	    new ISTORE(local.getIndex());

	if (_right.isWildcard()) {
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	}
	else if (_right instanceof StepPattern) {
	    il.append(DUP);
	    il.append(storeLocal);
	    
	    _right.translate(classGen, methodGen);
	    
	    il.append(methodGen.loadDOM());
	    local.setEnd(il.append(loadLocal));
	}
	else {
	    _right.translate(classGen, methodGen);

	    if (_right instanceof AncestorPattern) {
		il.append(methodGen.loadDOM());
		il.append(SWAP);
	    }
	}

	final int getParent = cpg.addInterfaceMethodref(DOM_INTF,
							GET_PARENT,
							GET_PARENT_SIG);
	il.append(new INVOKEINTERFACE(getParent, 2));

	final SyntaxTreeNode p = getParent();
	if (p == null || p instanceof Instruction || 
	    p instanceof TopLevelElement) 
	{
	    _left.translate(classGen, methodGen);
	}
	else {
	    il.append(DUP);
	    il.append(storeLocal);
	    
	    _left.translate(classGen, methodGen);

	    il.append(methodGen.loadDOM());
	    local.setEnd(il.append(loadLocal));
	}

	methodGen.removeLocalVariable(local);
	
	
	if (_right instanceof AncestorPattern) {
	    final AncestorPattern ancestor = (AncestorPattern) _right;
	    _left.backPatchFalseList(ancestor.getLoopHandle());    
	}

	_trueList.append(_right._trueList.append(_left._trueList));
	_falseList.append(_right._falseList.append(_left._falseList));
    }

    public String toString() {
	return ""Parent("" + _left + "", "" + _right + ')';
    }
}
"
org.apache.xalan.xsltc.compiler.util.StringType,19,2,0,41,47,151,18,27,17,1.0,286,0.0,0,0.647058824,0.247368421,2,4,14.0,4,1.3158,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IFNONNULL;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.FlowList;

public class StringType extends Type {
    protected StringType() {}

    public String toString() {
	return ""string"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""Ljava/lang/String;"";
    }

    public boolean isSimple() {
	return true;
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.STRING;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	FlowList falsel = translateToDesynthesized(classGen, methodGen, type);
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsel.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    RealType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKESTATIC(cpg.addMethodref(BASIS_LIBRARY_CLASS,
						    STRING_TO_REAL,
						    STRING_TO_REAL_SIG)));
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_CLASS,
						     ""length"", ""()I"")));
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) 
    {
        if (clazz.isAssignableFrom(java.lang.String.class)) {
	    
	    methodGen.getInstructionList().append(NOP);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }
    
    
    public void translateFrom(ClassGenerator classGen, 
	MethodGenerator methodGen, Class clazz) 
    {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (clazz.getName().equals(""java.lang.String"")) {
	    
	    il.append(DUP);
	    final BranchHandle ifNonNull = il.append(new IFNONNULL(null));
	    il.append(POP);
	    il.append(new PUSH(cpg, """"));
	    ifNonNull.setTarget(il.append(NOP));
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public String getClassName() {
	return(STRING_CLASS);
    }


    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}
"
org.apache.xml.utils.synthetic.reflection.Member,4,1,0,6,4,6,4,2,4,2.0,4,0.0,0,0.0,0.5,0,0,0.0,1,1.0,1,"
package org.apache.xml.utils.synthetic.reflection;

import org.apache.xml.utils.synthetic.SynthesisException;


public interface Member
{

  
  public abstract org.apache.xml.utils.synthetic.Class getDeclaringClass();

  
  public abstract int getModifiers();

  
  public abstract void setDeclaringClass(
    org.apache.xml.utils.synthetic.Class declaringClass)
      throws SynthesisException;

  
  public abstract void setModifiers(int modifiers) throws SynthesisException;
}
"
org.apache.xalan.xsltc.runtime.MessageHandler,2,1,1,3,4,1,3,0,2,2.0,9,0.0,0,0.0,0.75,0,0,3.5,1,0.5,0,"

package org.apache.xalan.xsltc.runtime;

public class MessageHandler {
    public void displayMessage(String msg) {
	System.err.println(msg);
    }
}
"
org.apache.xalan.lib.sql.PooledConnection,5,1,0,1,9,0,1,0,5,0.5,41,1.0,0,0.0,0.466666667,0,0,6.8,1,0.8,1,"
package org.apache.xalan.lib.sql;

import java.sql.Connection;
import java.sql.SQLException;


public class PooledConnection
{

  
  
  private Connection connection = null;
  
  
  private boolean inuse = false;

  
  
  
  public PooledConnection( Connection value )
  {
    if ( value != null ) { connection = value; }
  }

  
  public Connection getConnection( )
  {
    
    return connection;
  }

  
  public void setInUse( boolean value )
  {
    inuse = value;
  }

  
  public boolean inUse( ) { return inuse; }

  
  public void close( )
  {
    try
    {
      connection.close();
    }
    catch (SQLException sqle)
    {
      System.err.println(sqle.getMessage());
    }
  }
}
"
org.apache.xalan.trace.EndSelectionEvent,1,2,0,8,2,0,3,5,1,2.0,10,0.0,0,0.0,1.0,0,0,9.0,0,0.0,1,"
package org.apache.xalan.trace;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;

import org.w3c.dom.Node;


public class EndSelectionEvent extends SelectionEvent
{

  
  public EndSelectionEvent(TransformerImpl processor, Node sourceNode,
                        ElemTemplateElement styleNode, String attributeName,
                        XPath xpath, XObject selection)
  {

    super(processor, sourceNode, styleNode, attributeName, xpath, selection);
  }
}"
org.apache.xalan.xsltc.compiler.util.ReferenceType,20,2,0,41,46,184,19,29,19,2.0,448,0.0,0,0.634615385,0.230769231,2,4,21.4,8,1.75,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;

import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.FlowList;

import org.apache.xml.dtm.DTM;

public final class ReferenceType extends Type {
    protected ReferenceType() {}

    public String toString() {
	return ""reference"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""Ljava/lang/Object;"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.OBJECT;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.NodeSet) {
	    translateTo(classGen, methodGen, (NodeSetType) type);
	}
	else if (type == Type.Node) {
	    translateTo(classGen, methodGen, (NodeType) type);
	}
	else if (type == Type.ResultTree) {
	    translateTo(classGen, methodGen, (ResultTreeType) type);
	}
	else if (type == Type.Object) {
	    translateTo(classGen, methodGen, (ObjectType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.INTERNAL_ERR, type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    StringType type) {
	final int current = methodGen.getLocalIndex(""current"");
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();

	
	if (current < 0) {
	    il.append(new PUSH(cpg, DTM.ROOT_NODE));  
	}
	else {
	    il.append(new ILOAD(current));
	}
	il.append(methodGen.loadDOM());
	final int stringF = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					     ""stringF"",
					     ""(""
					     + OBJECT_SIG
					     + NODE_SIG
					     + DOM_INTF_SIG
					     + "")"" + STRING_SIG);
	il.append(new INVOKESTATIC(stringF));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    RealType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	il.append(methodGen.loadDOM());
	int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""numberF"",
				     ""(""
				     + OBJECT_SIG
				     + DOM_INTF_SIG
				     + "")D"");
	il.append(new INVOKESTATIC(index));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    BooleanType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""booleanF"",
				     ""(""
				     + OBJECT_SIG
				     + "")Z"");
	il.append(new INVOKESTATIC(index));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    NodeSetType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""referenceToNodeSet"",
				     ""(""
				     + OBJECT_SIG
				     + "")""
				     + NODE_ITERATOR_SIG);
	il.append(new INVOKESTATIC(index));

	
	index = cpg.addInterfaceMethodref(NODE_ITERATOR, RESET, RESET_SIG);
	il.append(new INVOKEINTERFACE(index, 1));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    NodeType type) {
	translateTo(classGen, methodGen, Type.NodeSet);
	Type.NodeSet.translateTo(classGen, methodGen, type);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    ResultTreeType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""referenceToResultTree"",
				     ""("" + OBJECT_SIG + "")"" + DOM_INTF_SIG);
	il.append(new INVOKESTATIC(index));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    ObjectType type) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    Class clazz) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (clazz.getName().equals(""java.lang.Object"")) {
	    il.append(NOP);
	}
	else if (clazz == Double.TYPE) {
	    translateTo(classGen, methodGen, Type.Real);
	}
	else if (clazz.getName().equals(""java.lang.String"")) {
	    translateTo(classGen, methodGen, Type.String);
	}
	else if (clazz.getName().equals(""org.w3c.dom.Node"")) {
	    int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""referenceToNode"",
				         ""(""
				         + OBJECT_SIG
				         + DOM_INTF_SIG
				         + "")""
				         + ""Lorg/w3c/dom/Node;"");
	    il.append(methodGen.loadDOM());
	    il.append(new INVOKESTATIC(index));
	}
	else if (clazz.getName().equals(""org.w3c.dom.NodeList"")) {
	    int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""referenceToNodeList"",
				         ""(""
				         + OBJECT_SIG
				         + DOM_INTF_SIG
				         + "")""
				         + ""Lorg/w3c/dom/NodeList;"");
	    il.append(methodGen.loadDOM());
	    il.append(new INVOKESTATIC(index));
	}
	else if (clazz.getName().equals(""org.apache.xalan.xsltc.DOM"")) {
	    translateTo(classGen, methodGen, Type.ResultTree);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen,
			      Class clazz) {
	if (clazz.getName().equals(""java.lang.Object"")) {
	    methodGen.getInstructionList().append(NOP);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
        }
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen,
					     MethodGenerator methodGen,
					     BooleanType type) {
	InstructionList il = methodGen.getInstructionList();
	translateTo(classGen, methodGen, type);
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
    }

    
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
    }


    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }

    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}

"
org.apache.xalan.xsltc.cmdline.Transform,10,1,0,12,71,17,0,12,6,0.788888889,665,1.0,1,0.0,0.277777778,0,0,64.5,15,3.4,0,"

package org.apache.xalan.xsltc.cmdline;

import java.io.FileNotFoundException;
import java.net.MalformedURLException;
import java.net.UnknownHostException;
import java.util.Vector;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.sax.SAXSource;

import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.dom.SAXImpl;
import org.apache.xalan.xsltc.dom.XSLTCDTMManager;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.runtime.Constants;
import org.apache.xalan.xsltc.runtime.Parameter;
import org.apache.xalan.xsltc.runtime.TransletLoader;
import org.apache.xalan.xsltc.runtime.output.TransletOutputHandlerFactory;
import org.apache.xml.serializer.SerializationHandler;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.XMLReader;

final public class Transform {

    private SerializationHandler _handler;

    private String  _fileName;
    private String  _className;
    private String  _jarFileSrc;
    private boolean _isJarFileSpecified = false;
    private Vector  _params = null;
    private boolean _uri, _debug;
    private int     _iterations;

    private static boolean _allowExit = true;

    public Transform(String className, String fileName,
		     boolean uri, boolean debug, int iterations) {
	_fileName = fileName;
	_className = className;
	_uri = uri;
	_debug = debug;
	_iterations = iterations;
  }
  
   public String getFileName(){return _fileName;}
   public String getClassName(){return _className;}

    public void setParameters(Vector params) {
	_params = params;
    }

    private void setJarFileInputSrc(boolean flag,  String jarFile) {
	
	
	
	
	
	_isJarFileSpecified = flag;
	
	_jarFileSrc = jarFile;	
    }

    private Class loadTranslet(String name) throws ClassNotFoundException {
	
	try {
	    return Class.forName(name);
	}
	catch (ClassNotFoundException e) {
	    
	}

	
	TransletLoader loader = new TransletLoader();
	return loader.loadTranslet(name);
    }

    private void doTransform() {
	try {
	    
	    final Class clazz = loadTranslet(_className);
	    final AbstractTranslet translet = (AbstractTranslet)clazz.newInstance();

	    
	    final SAXParserFactory factory = SAXParserFactory.newInstance();
	    try {
		factory.setFeature(Constants.NAMESPACE_FEATURE,true);
	    }
	    catch (Exception e) {
		factory.setNamespaceAware(true);
	    }
	    final SAXParser parser = factory.newSAXParser();
	    final XMLReader reader = parser.getXMLReader();

	    
            XSLTCDTMManager dtmManager = XSLTCDTMManager.newInstance();

            final SAXImpl dom = (SAXImpl)dtmManager.getDTM(
                             new SAXSource(reader, new InputSource(_fileName)),
                             false, null, true, false, translet.hasIdCall());

	    dom.setDocumentURI(_fileName);
            translet.prepassDocument(dom);

	    
	    int n = _params.size();
	    for (int i = 0; i < n; i++) {
		Parameter param = (Parameter) _params.elementAt(i);
		translet.addParameter(param._name, param._value);
	    }

	    
	    TransletOutputHandlerFactory tohFactory = 
		TransletOutputHandlerFactory.newInstance();
	    tohFactory.setOutputType(TransletOutputHandlerFactory.STREAM);
	    tohFactory.setEncoding(translet._encoding);
	    tohFactory.setOutputMethod(translet._method);

	    if (_iterations == -1) {
		translet.transform(dom, tohFactory.getSerializationHandler());
	    }
	    else if (_iterations > 0) {
		long mm = System.currentTimeMillis();
		for (int i = 0; i < _iterations; i++) {
		    translet.transform(dom,
				       tohFactory.getSerializationHandler());
		}
		mm = System.currentTimeMillis() - mm;

		System.err.println(""
<!--"");
		System.err.println(""  transform  = ""
                                   + (((double) mm) / ((double) _iterations))
                                   + "" ms"");
		System.err.println(""  throughput = ""
                                   + (1000.0 / (((double) mm)
                                                 / ((double) _iterations)))
                                   + "" tps"");
		System.err.println(""-->"");
	    }
	}
	catch (TransletException e) {
	    if (_debug) e.printStackTrace();
	    System.err.println(new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY)+
			       e.getMessage());
	    if (_allowExit) System.exit(-1);	    
	}
	catch (RuntimeException e) {
	    if (_debug) e.printStackTrace();
	    System.err.println(new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY)+
			       e.getMessage());
	    if (_allowExit) System.exit(-1);
	}
	catch (FileNotFoundException e) {
	    if (_debug) e.printStackTrace();
	    ErrorMsg err = new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, _fileName);
	    System.err.println(new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY)+
			       err.toString());
	    if (_allowExit) System.exit(-1);
	}
	catch (MalformedURLException e) {
	    if (_debug) e.printStackTrace();
	    ErrorMsg err = new ErrorMsg(ErrorMsg.INVALID_URI_ERR, _fileName);
	    System.err.println(new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY)+
			       err.toString());
	    if (_allowExit) System.exit(-1);
	}
	catch (ClassNotFoundException e) {
	    if (_debug) e.printStackTrace();
	    ErrorMsg err= new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR,_className);
	    System.err.println(new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY)+
			       err.toString());
	    if (_allowExit) System.exit(-1);
	}
        catch (UnknownHostException e) {
	    if (_debug) e.printStackTrace();
	    ErrorMsg err = new ErrorMsg(ErrorMsg.INVALID_URI_ERR, _fileName);
	    System.err.println(new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY)+
			       err.toString());
	    if (_allowExit) System.exit(-1);
        }
	catch (SAXException e) {
	    Exception ex = e.getException();
	    if (_debug) {
		if (ex != null) ex.printStackTrace();
		e.printStackTrace();
	    }
	    System.err.print(new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY));
	    if (ex != null)
		System.err.println(ex.getMessage());
	    else
		System.err.println(e.getMessage());
	    if (_allowExit) System.exit(-1);
	}
	catch (Exception e) {
	    if (_debug) e.printStackTrace();
	    System.err.println(new ErrorMsg(ErrorMsg.RUNTIME_ERROR_KEY)+
			       e.getMessage());
	    if (_allowExit) System.exit(-1);
	}
    }

    public static void printUsage() {
	System.err.println(new ErrorMsg(ErrorMsg.TRANSFORM_USAGE_STR));
	if (_allowExit) System.exit(-1);
    }

    public static void main(String[] args) {
	try {
	    if (args.length > 0) {
		int i;
		int iterations = -1;
		boolean uri = false, debug = false;
		boolean isJarFileSpecified = false;
		String  jarFile = null;

		
		for (i = 0; i < args.length && args[i].charAt(0) == '-'; i++) {
		    if (args[i].equals(""-u"")) {
			uri = true;
		    }
		    else if (args[i].equals(""-x"")) {
			debug = true;
		    }
		    else if (args[i].equals(""-s"")) {
			_allowExit = false;
		    }
		    else if (args[i].equals(""-j"")) {
			isJarFileSpecified = true;	
			jarFile = args[++i];
		    }
		    else if (args[i].equals(""-n"")) {
			try {
			    iterations = Integer.parseInt(args[++i]);
			}
			catch (NumberFormatException e) {
			    
			}
		    }
		    else {
			printUsage();
		    }
		}

		
		if (args.length - i < 2) printUsage();

		
		Transform handler = new Transform(args[i+1], args[i], uri,
		    debug, iterations);
		handler.setJarFileInputSrc(isJarFileSpecified,	jarFile);

		
		Vector params = new Vector();
		for (i += 2; i < args.length; i++) {
		    final int equal = args[i].indexOf('=');
		    if (equal > 0) {
			final String name  = args[i].substring(0, equal);
			final String value = args[i].substring(equal+1);
			params.addElement(new Parameter(name, value));
		    }
		    else {
			printUsage();
		    }
		}

		if (i == args.length) {
		    handler.setParameters(params);
		    handler.doTransform();
		    if (_allowExit) System.exit(0);
		}
	    } else {
		printUsage();
	    }
	}
	catch (Exception e) {
	    e.printStackTrace();
	}
    }
}
"
org.apache.xalan.templates.VarNameCollector,5,2,0,5,12,0,1,4,4,0.0,34,0.0,0,0.75,0.4,0,0,5.6,1,0.8,0,"
package org.apache.xalan.templates;

import java.util.Vector;

import org.apache.xml.utils.QName;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.operations.Variable;


public class VarNameCollector extends XPathVisitor
{
	Vector m_refs = new Vector();
	
	
	public void reset()
	{
		m_refs.removeAllElements(); 
	}
	
	
	public int getVarCount()
	{
		return m_refs.size();
	}
	
	
	boolean doesOccur(QName refName)
	{
		return m_refs.contains(refName);
	}

	
	public boolean visitVariableRef(ExpressionOwner owner, Variable var)
	{
		m_refs.addElement(var.getQName());
		return true;
	}

}

"
org.apache.xml.utils.MutableAttrListImpl,5,2,0,1,18,10,1,0,5,2.0,107,0.0,0,0.888888889,0.6,1,2,20.4,4,1.8,1,"
package org.apache.xml.utils;

import java.io.Serializable;

import org.xml.sax.Attributes;
import org.xml.sax.helpers.AttributesImpl;


public class MutableAttrListImpl extends AttributesImpl
        implements Serializable
{



public MutableAttrListImpl()
  {
    super();
  }

  
  public MutableAttrListImpl(Attributes atts)
  {
    super(atts);
  }

  
  public void addAttribute(String uri, String localName, String qName,
                           String type, String value)
  {

    if (null == uri)
      uri = """";

    
    
    int index = this.getIndex(qName);
    
   
    

    if (index >= 0)
      this.setAttribute(index, uri, localName, qName, type, value);
    else
      super.addAttribute(uri, localName, qName, type, value);
  }

  
  public void addAttributes(Attributes atts)
  {

    int nAtts = atts.getLength();

    for (int i = 0; i < nAtts; i++)
    {
      String uri = atts.getURI(i);

      if (null == uri)
        uri = """";

      String localName = atts.getLocalName(i);
      String qname = atts.getQName(i);
      int index = this.getIndex(uri, localName);
      
      if (index >= 0)
        this.setAttribute(index, uri, localName, qname, atts.getType(i),
                          atts.getValue(i));
      else
        addAttribute(uri, localName, qname, atts.getType(i),
                     atts.getValue(i));
    }
  }

  
  public boolean contains(String name)
  {
    return getValue(name) != null;
  }
}


"
org.apache.xalan.xsltc.compiler.StartsWithCall,3,4,0,16,17,0,0,16,3,0.0,108,1.0,2,0.979591837,0.444444444,3,13,34.33333333,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class StartsWithCall extends FunctionCall {

    private Expression _base = null;
    private Expression _token = null;

    
    public StartsWithCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	if (argumentCount() != 2) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ILLEGAL_ARG_ERR,
					getName(), this);
	    throw new TypeCheckError(err);
	}

	
	_base = argument(0);
	Type baseType = _base.typeCheck(stable);	
	if (baseType != Type.String)
	    _base = new CastExpr(_base, Type.String);

	
	_token = argument(1);
	Type tokenType = _token.typeCheck(stable);	
	if (tokenType != Type.String)
	    _token = new CastExpr(_token, Type.String);

	return _type = Type.Boolean;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	_base.translate(classGen, methodGen);
	_token.translate(classGen, methodGen);
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_CLASS,
						     ""startsWith"", 
						     ""(""+STRING_SIG+"")Z"")));
    }
}
"
org.apache.xalan.xsltc.compiler.AttributeSet,8,3,0,24,54,6,3,23,7,0.80952381,279,1.0,3,0.895522388,0.3,2,5,33.125,7,2.25,2,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;
import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.AttributeSetMethodGenerator;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class AttributeSet extends TopLevelElement {

    
    private static final String AttributeSetPrefix = ""$as$"";
    
    
    private QName            _name;
    private UseAttributeSets _useSets;
    private AttributeSet     _mergeSet;
    private String           _method;
    private boolean          _ignore = false;
    
    
    public QName getName() {
	return _name;
    }

    
    public String getMethodName() {
	return _method;
    }

    
    public void ignore() {
	_ignore = true;
    }

    
    public void parseContents(Parser parser) {
	
	
	_name = parser.getQNameIgnoreDefaultNs(getAttribute(""name""));
	if ((_name == null) || (_name.equals(EMPTYSTRING))) {
	    ErrorMsg msg = new ErrorMsg(ErrorMsg.UNNAMED_ATTRIBSET_ERR, this);
	    parser.reportError(Constants.ERROR, msg);
	}

	
	final String useSets = getAttribute(""use-attribute-sets"");
	if (useSets.length() > 0) {
	    _useSets = new UseAttributeSets(useSets, parser);
	}

	
	
	final Vector contents = getContents();
	final int count = contents.size();
	for (int i=0; i<count; i++) {
	    SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
	    if (child instanceof XslAttribute) {
		parser.getSymbolTable().setCurrentNode(child);
		child.parseContents(parser);
	    }
	    else if (child instanceof Text) {
		
	    }
	    else {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_CHILD_ERR, this);
		parser.reportError(Constants.ERROR, msg);
	    }
	}

	
	parser.getSymbolTable().setCurrentNode(this);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	if (_ignore) return (Type.Void);

        
	_mergeSet = stable.addAttributeSet(this);

	_method = AttributeSetPrefix + getXSLTC().nextAttributeSetSerial();

	if (_useSets != null) _useSets.typeCheck(stable);
	typeCheckContents(stable);
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	if (_ignore) return;

	
	methodGen = new AttributeSetMethodGenerator(_method, classGen);

        
        
        if (_mergeSet != null) {
            final ConstantPoolGen cpg = classGen.getConstantPool();
            final InstructionList il = methodGen.getInstructionList();
            final String methodName = _mergeSet.getMethodName();

            il.append(classGen.loadTranslet());
            il.append(methodGen.loadHandler());
            il.append(methodGen.loadIterator());
            final int method = cpg.addMethodref(classGen.getClassName(),
                                                methodName, ATTR_SET_SIG);
            il.append(new INVOKESPECIAL(method));
        }

	
	
	if (_useSets != null) _useSets.translate(classGen, methodGen);

	
	final Enumeration attributes = elements();
	while (attributes.hasMoreElements()) {
	    SyntaxTreeNode element = (SyntaxTreeNode)attributes.nextElement();
	    if (element instanceof XslAttribute) {
		final XslAttribute attribute = (XslAttribute)element;
		attribute.translate(classGen, methodGen);
	    }
	}
	final InstructionList il = methodGen.getInstructionList();
	il.append(RETURN);
	
	methodGen.stripAttributes(true);
	methodGen.setMaxLocals();
	methodGen.setMaxStack();
	methodGen.removeNOPs();
	classGen.addMethod(methodGen.getMethod());
    }

    public String toString() {
	StringBuffer buf = new StringBuffer(""attribute-set: "");
	
	final Enumeration attributes = elements();
	while (attributes.hasMoreElements()) {
	    final XslAttribute attribute =
		(XslAttribute)attributes.nextElement();
	    buf.append(attribute);
	}
	return(buf.toString());
    }
}
"
org.apache.xalan.extensions.ExpressionVisitor,2,2,0,7,6,0,1,6,2,0.0,23,1.0,1,0.923076923,0.625,0,0,10.0,2,1.0,2,"
package org.apache.xalan.extensions;

import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.functions.Function;


public class ExpressionVisitor extends XPathVisitor
{
  private StylesheetRoot m_sroot;
  
  
  public ExpressionVisitor (StylesheetRoot sroot)
  {
    m_sroot = sroot;
  }
  
  
  public boolean visitFunction(ExpressionOwner owner, Function func)
	{
    if (func instanceof FuncExtFunction)
    {
      String namespace = ((FuncExtFunction)func).getNamespace();
      m_sroot.getExtensionNamespacesManager().registerExtension(namespace);      
    }
		return true;
	}
}"
org.apache.xalan.xsltc.compiler.CompilerException,4,3,0,2,9,0,2,0,4,0.333333333,40,1.0,0,0.944444444,0.5,1,1,8.75,2,0.5,0,"

package org.apache.xalan.xsltc.compiler;

public final class CompilerException extends Exception {

    private String _msg;

    public CompilerException() {
	super();
    }
    
    public CompilerException(Exception e) {
	super(e.toString());
	_msg = e.toString(); 
    }
    
    public CompilerException(String message) {
	super(message);
	_msg = message;
    }

    public String getMessage() {
	final int col = _msg.indexOf(':');

	if (col > -1)
	    return(_msg.substring(col));
	else
	    return(_msg);
    }
}
"
org.apache.xalan.xsltc.compiler.Choose,3,3,0,24,37,3,2,23,2,2.0,245,0.0,0,0.965517241,0.5,2,4,80.66666667,15,5.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;
import java.util.Vector;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class Choose extends Instruction {

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Choose"");
	indent(indent + IndentIncrement);
	displayContents(indent + IndentIncrement);
    }
	
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Vector whenElements = new Vector();
	Otherwise otherwise = null;
	Enumeration elements = elements();

	
	ErrorMsg error = null;
	final int line = getLineNumber();

	
	while (elements.hasMoreElements()) {
	    Object element = elements.nextElement();
	    
	    if (element instanceof When) {
		whenElements.addElement(element);
	    }
	    
	    else if (element instanceof Otherwise) {
		if (otherwise == null) {
		    otherwise = (Otherwise)element;
		}
		else {
		    error = new ErrorMsg(ErrorMsg.MULTIPLE_OTHERWISE_ERR, this);
		    getParser().reportError(Constants.ERROR, error);
		}
	    }
	    else if (element instanceof Text) {
		((Text)element).ignore();
	    }
	    
	    else {
		error = new ErrorMsg(ErrorMsg.WHEN_ELEMENT_ERR, this);
		getParser().reportError(Constants.ERROR, error);
	    }
	}

	
	if (whenElements.size() == 0) {
	    error = new ErrorMsg(ErrorMsg.MISSING_WHEN_ERR, this);
	    getParser().reportError(Constants.ERROR, error);
	    return;
	}

	InstructionList il = methodGen.getInstructionList();

	
	
	BranchHandle nextElement = null;
	Vector exitHandles = new Vector();
	InstructionHandle exit = null;

	Enumeration whens = whenElements.elements();
	while (whens.hasMoreElements()) {
	    final When when = (When)whens.nextElement();
	    final Expression test = when.getTest();

	    InstructionHandle truec = il.getEnd();

	    if (nextElement != null) 
		nextElement.setTarget(il.append(NOP));
	    test.translateDesynthesized(classGen, methodGen);

	    if (test instanceof FunctionCall) {
		FunctionCall call = (FunctionCall)test;
		try {
		    Type type = call.typeCheck(getParser().getSymbolTable());
		    if (type != Type.Boolean) {
			test._falseList.add(il.append(new IFEQ(null)));
		    }
		}
		catch (TypeCheckError e) { 
		    
		}
	    }
	    
	    truec = il.getEnd();

	    
	    
	    if (!when.ignore()) when.translateContents(classGen, methodGen);

	    
	    exitHandles.addElement(il.append(new GOTO(null)));
	    if (whens.hasMoreElements() || otherwise != null) {
		nextElement = il.append(new GOTO(null));
		test.backPatchFalseList(nextElement);
	    }
	    else
		test.backPatchFalseList(exit = il.append(NOP));
	    test.backPatchTrueList(truec.getNext());
	}
	
	
	if (otherwise != null) {
	    nextElement.setTarget(il.append(NOP));
	    otherwise.translateContents(classGen, methodGen);
	    exit = il.append(NOP);
	}

	
	Enumeration exitGotos = exitHandles.elements();
	while (exitGotos.hasMoreElements()) {
	    BranchHandle gotoExit = (BranchHandle)exitGotos.nextElement();
	    gotoExit.setTarget(exit);
	}
    }
}
"
org.apache.xalan.transformer.TransformState,7,1,0,6,7,21,3,3,7,2.0,7,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xalan.transformer;

import javax.xml.transform.Transformer;

import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xml.serializer.TransformStateSetter;

import org.w3c.dom.Node;
import org.w3c.dom.traversal.NodeIterator;


public interface TransformState extends TransformStateSetter
{

  
  ElemTemplateElement getCurrentElement();

  
  Node getCurrentNode();

  
  ElemTemplate getCurrentTemplate();

  
  ElemTemplate getMatchedTemplate();

  
  Node getMatchedNode();

  
  NodeIterator getContextNodeList();

  
  Transformer getTransformer();
  

    
}
"
org.apache.xalan.xsltc.compiler.ProcessingInstructionPattern,7,7,0,23,40,1,0,23,7,0.583333333,297,1.0,0,0.951612903,0.314285714,5,11,41.14285714,4,1.5714,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IF_ICMPEQ;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xml.dtm.DTM;

final class ProcessingInstructionPattern extends StepPattern {

    private String _name = null;
    private boolean _typeChecked = false;

    
    public ProcessingInstructionPattern(String name) {
	super(Axis.CHILD, DTM.PROCESSING_INSTRUCTION_NODE, null);
	_name = name;
	
    }

    
     public double getDefaultPriority() {
        return (_name != null) ? 0.0 : -0.5;       
     }
    public String toString() {
	if (_predicates == null)
	    return ""processing-instruction(""+_name+"")"";
	else
	    return ""processing-instruction(""+_name+"")""+_predicates;
    }

    public void reduceKernelPattern() {
	_typeChecked = true;
    }

    public boolean isWildcard() {
	return false;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (hasPredicates()) {
	    
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Predicate pred = (Predicate)_predicates.elementAt(i);
		pred.typeCheck(stable);
	    }
	}
	return Type.NodeSet;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	int gname = cpg.addInterfaceMethodref(DOM_INTF,
					      ""getNodeName"",
					      ""(I)Ljava/lang/String;"");
	int cmp = cpg.addMethodref(STRING_CLASS,
				   ""equals"", ""(Ljava/lang/Object;)Z"");

	
	il.append(methodGen.loadCurrentNode());
	il.append(SWAP);

	
	il.append(methodGen.storeCurrentNode());

	
	if (!_typeChecked) {
	    il.append(methodGen.loadCurrentNode());
	    final int getType = cpg.addInterfaceMethodref(DOM_INTF,
							  ""getExpandedTypeID"",
                                                          ""(I)I"");
	    il.append(methodGen.loadDOM());
	    il.append(methodGen.loadCurrentNode());
	    il.append(new INVOKEINTERFACE(getType, 2));
	    il.append(new PUSH(cpg, DTM.PROCESSING_INSTRUCTION_NODE));
	    _falseList.add(il.append(new IF_ICMPEQ(null)));
	}

	
	il.append(new PUSH(cpg, _name));
	
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadCurrentNode());
	il.append(new INVOKEINTERFACE(gname, 2));
	
	il.append(new INVOKEVIRTUAL(cmp));
	_falseList.add(il.append(new IFEQ(null)));
		
	
	if (hasPredicates()) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		Predicate pred = (Predicate)_predicates.elementAt(i);
		Expression exp = pred.getExpr();
		exp.translateDesynthesized(classGen, methodGen);
		_trueList.append(exp._trueList);
		_falseList.append(exp._falseList);
	    }
	}

	
	InstructionHandle restore;
	restore = il.append(methodGen.storeCurrentNode());
	backPatchTrueList(restore);
	BranchHandle skipFalse = il.append(new GOTO(null));

	
	restore = il.append(methodGen.storeCurrentNode());
	backPatchFalseList(restore);
	_falseList.add(il.append(new GOTO(null)));

	
	skipFalse.setTarget(il.append(NOP));
    }
}
"
org.apache.xml.utils.synthetic.reflection.EntryPoint,22,1,2,5,49,71,2,5,20,0.706349206,827,0.833333333,4,0.0,0.272727273,1,1,36.04545455,16,2.7727,1,"
package org.apache.xml.utils.synthetic.reflection;

import org.apache.xml.utils.synthetic.SynthesisException;




abstract public class EntryPoint implements Member
{

  
  protected Object realep;

  
  private org.apache.xml.utils.synthetic.Class declaringclass = null;

  
  protected org.apache.xml.utils.synthetic.Class returntype = null;

  
  private String[] parameternames = new String[0];

  
  private org.apache.xml.utils.synthetic.Class[] parametertypes =
    new org.apache.xml.utils.synthetic.Class[0];

  
  private org.apache.xml.utils.synthetic.Class[] exceptiontypes =
    new org.apache.xml.utils.synthetic.Class[0];
  ;

  
  private int modifiers;

  
  protected String name = null;  

  

  
  private StringBuffer body = null;

  
  private String language = null;

  

  
  Class[] realE, realP;

  
  public EntryPoint(org.apache.xml.utils.synthetic.Class declaringclass)
  {
    this.declaringclass = declaringclass;
  }

  
  protected EntryPoint(
          Object ep, org.apache.xml.utils.synthetic.Class declaringclass)
            throws IllegalArgumentException
  {

    realep = ep;
    this.declaringclass = declaringclass;

    if (ep instanceof java.lang.reflect.Method)
    {
      java.lang.reflect.Method m = (java.lang.reflect.Method) ep;

      if (declaringclass == null)
      {
        declaringclass = org.apache.xml.utils.synthetic.Class.forClass(
          m.getDeclaringClass());
      }

      name = m.getName();
      modifiers = m.getModifiers();
      returntype =
        org.apache.xml.utils.synthetic.Class.forClass(m.getReturnType());
      realP = m.getParameterTypes();
      realE = m.getExceptionTypes();
    }
    else if (ep instanceof java.lang.reflect.Constructor)
    {
      java.lang.reflect.Constructor c = (java.lang.reflect.Constructor) ep;

      if (declaringclass == null)
      {
        declaringclass = org.apache.xml.utils.synthetic.Class.forClass(
          c.getDeclaringClass());
      }

      name = declaringclass.getShortName();
      modifiers = c.getModifiers();
      returntype = declaringclass;
      realP = c.getParameterTypes();
      realE = c.getExceptionTypes();
    }
    else
      throw new IllegalArgumentException();
  }

  
  protected EntryPoint(Object ep) throws IllegalArgumentException
  {
    this(ep, null);
  }

  
  public boolean equals(Object obj)
  {

    EntryPoint otherep = null;

    if (obj instanceof EntryPoint)
      otherep = (EntryPoint) obj;
    else if (obj instanceof java.lang.reflect.Constructor
             || obj instanceof java.lang.reflect.Method)
      otherep = (EntryPoint) obj;

    return (otherep != null && ((this instanceof Constructor && otherep instanceof Constructor) || (this instanceof Method && otherep instanceof Method && this.getName().equals(
      otherep.getName()))) && otherep.getDeclaringClass().equals(
        declaringclass) && otherep.getParameterTypes().equals(
        parametertypes));
  }

  
  public org.apache.xml.utils.synthetic.Class getDeclaringClass()
  {
    return declaringclass;
  }

  
  public org.apache.xml.utils.synthetic.Class getReturnType()
  {
    return returntype;
  }

  
  public org.apache.xml.utils.synthetic.Class[] getExceptionTypes()
  {

    if (realep != null && exceptiontypes == null)
    {
      exceptiontypes =
        new org.apache.xml.utils.synthetic.Class[realE.length];

      for (int i = 0; i < realE.length; ++i)
      {
        exceptiontypes[i] =
          org.apache.xml.utils.synthetic.Class.forClass(realE[i]);
      }

      realE = null;
    }

    return exceptiontypes;
  }

  
  public void addExceptionType(
          org.apache.xml.utils.synthetic.Class exception)
            throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    org.apache.xml.utils.synthetic.Class[] e =
      new org.apache.xml.utils.synthetic.Class[exceptiontypes.length + 1];

    System.arraycopy(exceptiontypes, 0, e, 0, exceptiontypes.length);

    e[exceptiontypes.length] = exception;
    exceptiontypes = e;
  }

  
  public int getModifiers()
  {
    return modifiers;
  }

  
  public java.lang.String getName()
  {

    if (this instanceof Constructor)
      return declaringclass.getShortName();

    return name;
  }

  
  public void setName(String name) throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.name = name;
  }

  
  public org.apache.xml.utils.synthetic.Class[] getParameterTypes()
  {

    if (realep != null && parametertypes == null)
    {
      parametertypes =
        new org.apache.xml.utils.synthetic.Class[realP.length];

      for (int i = 0; i < realP.length; ++i)
      {
        parametertypes[i] =
          org.apache.xml.utils.synthetic.Class.forClass(realP[i]);
      }

      realP = null;
    }

    return parametertypes;
  }

  
  public String[] getParameterNames()
  {
    return parameternames;
  }

  
  public void addParameter(
          org.apache.xml.utils.synthetic.Class type, String name)
            throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    org.apache.xml.utils.synthetic.Class[] types =
      new org.apache.xml.utils.synthetic.Class[parametertypes.length + 1];

    System.arraycopy(parametertypes, 0, types, 0, parametertypes.length);

    types[parametertypes.length] = type;
    parametertypes = types;

    String[] names = new String[parameternames.length + 1];

    System.arraycopy(parameternames, 0, names, 0, parameternames.length);

    names[parameternames.length] = name;
    parameternames = names;
  }

  
  abstract public int hashCode();

  
  public void setDeclaringClass(
          org.apache.xml.utils.synthetic.Class declaringClass)
            throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.declaringclass = declaringClass;
  }

  
  public void setModifiers(int modifiers) throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.modifiers = modifiers;
  }

  
  public String toString()
  {

    StringBuffer sb =
      new StringBuffer(java.lang.reflect.Modifier.toString(getModifiers()));

    if (this instanceof org.apache.xml.utils.synthetic.reflection.Method)
      sb.append(' ').append(getReturnType()).append(
        getDeclaringClass().getName()).append('.').append(getName());
    else
      sb.append(getDeclaringClass().getName());

    sb.append('(');

    org.apache.xml.utils.synthetic.Class[] p = getParameterTypes();

    if (p != null && p.length > 0)
    {
      sb.append(p[0].getName());

      for (int i = 1; i < p.length; ++i)
      {
        sb.append(',').append(p[i].getName());
      }
    }

    sb.append(')');

    if (this instanceof org.apache.xml.utils.synthetic.reflection.Method)
    {
      p = getExceptionTypes();

      if (p != null && p.length > 0)
      {
        sb.append("" throws "").append(p[0].getName());

        for (int i = 1; i < p.length; ++i)
        {
          sb.append(',').append(p[i].getName());
        }
      }
    }

    return sb.toString();
  }

  
  public void setBody(String language, StringBuffer body)
          throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.language = language;
    this.body = body;
  }

  
  public StringBuffer getBody()
  {

    if (body == null)
      body = new StringBuffer();

    return body;
  }

  
  public String getLanguage()
  {
    return language;
  }

  
  public String toSource(String basetab)
  {

    StringBuffer sb = new StringBuffer();

    sb.append(basetab).append(
      java.lang.reflect.Modifier.toString(getModifiers()));

    if (this instanceof org.apache.xml.utils.synthetic.reflection.Method)
    {
      if (returntype != null)
        sb.append("" "").append(getReturnType().getJavaName());
      else
        sb.append("" void"");
    }

    sb.append("" "").append(getName()).append(""("");

    org.apache.xml.utils.synthetic.Class[] types = getParameterTypes();

    if (types != null & types.length > 0)
    {
      sb.append(types[0].getJavaName());

      if (parameternames != null)
        sb.append(' ').append(parameternames[0]);

      for (int i = 1; i < types.length; ++i)
      {
        sb.append(',').append(types[i].getJavaName());

        if (parameternames != null)
          sb.append(' ').append(parameternames[i]);
      }
    }

    sb.append(')');

    types = getExceptionTypes();

    if (types != null & types.length > 0)
    {
      sb.append("" throws "").append(types[0].getJavaName());

      for (int i = 1; i < types.length; ++i)
      {
        sb.append(',').append(types[i].getJavaName());
      }
    }

    if (body == null)
      sb.append(""; 
"");
    else
    {
      sb.append(""
"" + basetab + ""{
"");

      if (language == null || ""java"".equals(language))
      {
        sb.append(basetab + ""
"");
        sb.append(basetab + body + ""
"");
      }
      else
      {
        sb.append(basetab + ""
"");
      }

      sb.append(basetab + ""}
"");
    }

    return sb.toString();
  }
}
"
org.apache.xpath.operations.NotEquals,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class NotEquals extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return (left.notEquals(right)) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.extensions.XSLProcessorContext,7,1,1,26,49,5,6,20,7,0.733333333,321,1.0,4,0.0,0.392857143,0,0,44.14285714,1,0.8571,1,"
package org.apache.xalan.extensions;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.transformer.ClonerToResultTree;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xalan.serialize.SerializerUtils;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.utils.QName;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.DescendantIterator;
import org.apache.xpath.axes.OneStepIterator;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xpath.objects.XString;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.traversal.NodeIterator;




public class XSLProcessorContext
{

  
  public XSLProcessorContext(TransformerImpl transformer,
                             Stylesheet stylesheetTree)
  {

    this.transformer = transformer;
    this.stylesheetTree = stylesheetTree;
    
    org.apache.xpath.XPathContext xctxt = transformer.getXPathContext();
    this.mode = transformer.getMode();
    this.sourceNode = xctxt.getCurrentNode();
    this.sourceTree = xctxt.getDTM(this.sourceNode);
  }

  
  private TransformerImpl transformer;

  
  public TransformerImpl getTransformer()
  {
    return transformer;
  }

  
  private Stylesheet stylesheetTree;

  
  public Stylesheet getStylesheet()
  {
    return stylesheetTree;
  }

  
  private org.apache.xml.dtm.DTM sourceTree;

  
  public org.w3c.dom.Node getSourceTree()
  {
    return sourceTree.getNode(sourceTree.getDocumentRoot(sourceNode));
  }

  
  private int sourceNode;

  
  public org.w3c.dom.Node getContextNode()
  {
    return sourceTree.getNode(sourceNode);
  }

  
  private QName mode;

  
  public QName getMode()
  {
    return mode;
  }

  
  public void outputToResultTree(Stylesheet stylesheetTree, Object obj)
          throws TransformerException, java.net.MalformedURLException,
                 java.io.FileNotFoundException, java.io.IOException
  {

    try
    {
      SerializationHandler rtreeHandler = transformer.getResultTreeHandler();
      XPathContext xctxt = transformer.getXPathContext();
      XObject value;

      
      
      
      
      if (obj instanceof XObject)
      {
        value = (XObject) obj;
      }
      else if (obj instanceof String)
      {
        value = new XString((String) obj);
      }
      else if (obj instanceof Boolean)
      {
        value = new XBoolean(((Boolean) obj).booleanValue());
      }
      else if (obj instanceof Double)
      {
        value = new XNumber(((Double) obj).doubleValue());
      }
      else if (obj instanceof DocumentFragment)
      {
        int handle = xctxt.getDTMHandleFromNode((DocumentFragment)obj);
        
        value = new XRTreeFrag(handle, xctxt);
      }
      else if (obj instanceof DTM)
      {
        DTM dtm = (DTM)obj;
        DTMIterator iterator = new DescendantIterator();
        
        
        
        
        
        iterator.setRoot(dtm.getDocument(), xctxt);
        value = new XNodeSet(iterator);
      }
      else if (obj instanceof DTMAxisIterator)
      {
        DTMAxisIterator iter = (DTMAxisIterator)obj;
        DTMIterator iterator = new OneStepIterator(iter, -1);
        value = new XNodeSet(iterator);
      }
      else if (obj instanceof DTMIterator)
      {
        value = new XNodeSet((DTMIterator) obj);
      }
      else if (obj instanceof NodeIterator)
      {
        value = new XNodeSet(new org.apache.xpath.NodeSetDTM(((NodeIterator)obj), xctxt));
      }
      else if (obj instanceof org.w3c.dom.Node)
      {
        value =
          new XNodeSet(xctxt.getDTMHandleFromNode((org.w3c.dom.Node) obj),
                       xctxt.getDTMManager());
      }
      else
      {
        value = new XString(obj.toString());
      }

      int type = value.getType();
      String s;

      switch (type)
      {
      case XObject.CLASS_BOOLEAN :
      case XObject.CLASS_NUMBER :
      case XObject.CLASS_STRING :
        s = value.str();

        rtreeHandler.characters(s.toCharArray(), 0, s.length());
        break;

      case XObject.CLASS_NODESET :  
        DTMIterator nl = value.iter();
        
        int pos;

        while (DTM.NULL != (pos = nl.nextNode()))
        {
          DTM dtm = nl.getDTM(pos);
          int top = pos;

          while (DTM.NULL != pos)
          {
            rtreeHandler.flushPending();
            ClonerToResultTree.cloneToResultTree(pos, dtm.getNodeType(pos), 
                                                   dtm, rtreeHandler, true);

            int nextNode = dtm.getFirstChild(pos);

            while (DTM.NULL == nextNode)
            {
              if (DTM.ELEMENT_NODE == dtm.getNodeType(pos))
              {
                rtreeHandler.endElement("""", """", dtm.getNodeName(pos));
              }

              if (top == pos)
                break;

              nextNode = dtm.getNextSibling(pos);

              if (DTM.NULL == nextNode)
              {
                pos = dtm.getParent(pos);

                if (top == pos)
                {
                  if (DTM.ELEMENT_NODE == dtm.getNodeType(pos))
                  {
                    rtreeHandler.endElement("""", """", dtm.getNodeName(pos));
                  }

                  nextNode = DTM.NULL;

                  break;
                }
              }
            }

            pos = nextNode;
          }
        }
        break;
      case XObject.CLASS_RTREEFRAG :
        SerializerUtils.outputResultTreeFragment(
            rtreeHandler, value, transformer.getXPathContext());


        break;
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }

  
}
"
org.apache.xpath.XPathVisitor,13,1,5,43,14,78,40,13,13,2.0,40,0.0,0,0.0,0.203296703,0,0,2.076923077,1,0.9231,0,"
package org.apache.xpath;

import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.axes.UnionPathIterator;
import org.apache.xpath.functions.Function;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XString;
import org.apache.xpath.operations.Operation;
import org.apache.xpath.operations.UnaryOperation;
import org.apache.xpath.operations.Variable;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.patterns.StepPattern;
import org.apache.xpath.patterns.UnionPattern;


public class XPathVisitor
{
	
	public boolean visitLocationPath(ExpressionOwner owner, LocPathIterator path)
	{
		return true;
	}

	
	public boolean visitUnionPath(ExpressionOwner owner, UnionPathIterator path)
	{
		return true;
	}
	
	
	public boolean visitStep(ExpressionOwner owner, NodeTest step)
	{
		return true;
	}
		
	
	public boolean visitPredicate(ExpressionOwner owner, Expression pred)
	{
		return true;
	}

	
	public boolean visitBinaryOperation(ExpressionOwner owner, Operation op)
	{
		return true;
	}

	
	public boolean visitUnaryOperation(ExpressionOwner owner, UnaryOperation op)
	{
		return true;
	}
	
	
	public boolean visitVariableRef(ExpressionOwner owner, Variable var)
	{
		return true;
	}

	
	public boolean visitFunction(ExpressionOwner owner, Function func)
	{
		return true;
	}
	
	
	public boolean visitMatchPattern(ExpressionOwner owner, StepPattern pattern)
	{
		return true;
	}
	
	
	public boolean visitUnionPattern(ExpressionOwner owner, UnionPattern pattern)
	{
		return true;
	}
	
	
	public boolean visitStringLiteral(ExpressionOwner owner, XString str)
	{
		return true;
	}


	
	public boolean visitNumberLiteral(ExpressionOwner owner, XNumber num)
	{
		return true;
	}


}

"
org.apache.xalan.xsltc.compiler.LocalNameCall,3,5,0,10,13,3,0,10,3,2.0,50,0.0,0,0.99,0.533333333,3,5,15.66666667,1,0.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;

final class LocalNameCall extends NameBase {

    
    public LocalNameCall(QName fname) {
	super(fname);
    }

    
    public LocalNameCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getNodeName = cpg.addInterfaceMethodref(DOM_INTF,
							  ""getNodeName"",
							  ""(I)""+STRING_SIG);

	final int getLocalName = cpg.addMethodref(BASIS_LIBRARY_CLASS,
						  ""getLocalName"",
						  ""(Ljava/lang/String;)""+
						  ""Ljava/lang/String;"");
	super.translate(classGen, methodGen);
	il.append(new INVOKEINTERFACE(getNodeName, 2));
	il.append(new INVOKESTATIC(getLocalName));
    }
}
"
org.apache.xalan.xsltc.cmdline.getopt.GetOptsException,1,3,2,3,2,0,3,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.apache.xalan.xsltc.cmdline.getopt; 

public class GetOptsException extends Exception{
    public GetOptsException(String msg){
	super(msg);
    }
}
"
org.apache.xalan.xsltc.dom.NodeCounter,15,1,3,8,39,91,4,4,7,0.811688312,833,0.818181818,3,0.0,0.267857143,0,0,53.06666667,14,3.6,0,"

package org.apache.xalan.xsltc.dom;

import java.util.Vector;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;

public abstract class NodeCounter implements Axis {
    public static final int END = DTM.NULL;

    protected int _node = END;
    protected int _nodeType = DOM.FIRST_TYPE - 1;
    protected int _value = Integer.MIN_VALUE;

    public final DOM          _document;
    public final DTMAxisIterator _iterator;
    public final Translet     _translet;

    protected String _format;
    protected String _lang;
    protected String _letterValue;
    protected String _groupSep;
    protected int    _groupSize;

    private boolean separFirst = true;
    private boolean separLast = false;
    private Vector separToks = null;
    private Vector formatToks = null;
    private int nSepars  = 0;
    private int nFormats = 0;

    private static String[] Thousands = 
        {"""", ""m"", ""mm"", ""mmm"" };
    private static String[] Hundreds = 
	{"""", ""c"", ""cc"", ""ccc"", ""cd"", ""d"", ""dc"", ""dcc"", ""dccc"", ""cm""};
    private static String[] Tens = 
	{"""", ""x"", ""xx"", ""xxx"", ""xl"", ""l"", ""lx"", ""lxx"", ""lxxx"", ""xc""};
    private static String[] Ones = 
	{"""", ""i"", ""ii"", ""iii"", ""iv"", ""v"", ""vi"", ""vii"", ""viii"", ""ix""};

    protected NodeCounter(Translet translet,
			  DOM document, DTMAxisIterator iterator) {
	_translet = translet;
	_document = document;
	_iterator = iterator;
    }

    
    abstract public NodeCounter setStartNode(int node);

    
    public NodeCounter setValue(int value) {
	_value = value;
	return this;
    }

    
    protected void setFormatting(String format, String lang, String letterValue,
				 String groupSep, String groupSize) {
	_lang = lang;
	_format = format;
	_groupSep = groupSep;
	_letterValue = letterValue;

	try {
	    _groupSize = Integer.parseInt(groupSize);
	}
	catch (NumberFormatException e) {
	    _groupSize = 0;
	}

	final int length = _format.length();
	boolean isFirst = true;
	separFirst = true;
	separLast = false;

        separToks = new Vector();
        formatToks = new Vector();

	
	for (int j = 0, i = 0; i < length;) {
            char c = _format.charAt(i);
            for (j = i; Character.isLetterOrDigit(c);) {
                if (++i == length) break;
		c = _format.charAt(i);
            }
            if (i > j) {
                if (isFirst) {
                    separToks.addElement(""."");
                    isFirst = separFirst = false;
                }
                formatToks.addElement(_format.substring(j, i));
            }

            if (i == length) break;

            c = _format.charAt(i);
            for (j = i; !Character.isLetterOrDigit(c);) {
                if (++i == length) break;
                c = _format.charAt(i);
                isFirst = false;
            }
            if (i > j) {
                separToks.addElement(_format.substring(j, i));
            }
        }

	nSepars = separToks.size();
	nFormats = formatToks.size(); 
	if (nSepars > nFormats) separLast = true;

	if (separFirst) nSepars--;
	if (separLast) nSepars--;
	if (nSepars == 0) {
	    separToks.insertElementAt(""."", 1);
 	    nSepars++;
	}
	if (separFirst) nSepars ++;
    }

    
    public NodeCounter setDefaultFormatting() {
	setFormatting(""1"", ""en"", ""alphabetic"", null, null);
	return this;
    }

    
    abstract public String getCounter();

    
    public String getCounter(String format, String lang, String letterValue,
			     String groupSep, String groupSize) {
	setFormatting(format, lang, letterValue, groupSep, groupSize);
	return getCounter();
    }

    
    public boolean matchesCount(int node) {
	return _nodeType == _document.getExpandedTypeID(node);
    }

    
    public boolean matchesFrom(int node) {
	return false;
    }

    
    protected String formatNumbers(int value) {
	return formatNumbers(new int[] { value });
    }

    
    protected String formatNumbers(int[] values) {
	final int nValues = values.length;
	final int length = _format.length();

	boolean isEmpty = true;
	for (int i = 0; i < nValues; i++)
	    if (values[i] != Integer.MIN_VALUE)
		isEmpty = false;
	if (isEmpty) return("""");

	
	boolean isFirst = true;
	int t = 0, n = 0, s = 1;
	final StringBuffer buffer = new StringBuffer();

	
	if (separFirst) buffer.append((String)separToks.elementAt(0));

	
	while (n < nValues) {
	    final int value = values[n];
	    if (value != Integer.MIN_VALUE) {
		if (!isFirst) buffer.append((String) separToks.elementAt(s++));
		formatValue(value, (String)formatToks.elementAt(t++), buffer);
		if (t == nFormats) t--;
		if (s >= nSepars) s--;
		isFirst = false;
	    }
	    n++;
	}

	
	if (separLast) buffer.append((String)separToks.lastElement());
	return buffer.toString();
    }

    
    private void formatValue(int value, String format, StringBuffer buffer) {
        char c = format.charAt(0);

        if (Character.isDigit(c)) {
            char zero = (char)(c - Character.getNumericValue(c));

            StringBuffer temp = buffer;
            if (_groupSize > 0) {
                temp = new StringBuffer();
            }
            String s = """";
            int n = value;
            while (n > 0) {
                s = (char) ((int) zero + (n % 10)) + s;
                n = n / 10;
            }
                
            for (int i = 0; i < format.length() - s.length(); i++) {
                temp.append(zero);
            }
            temp.append(s);
            
            if (_groupSize > 0) {
                for (int i = 0; i < temp.length(); i++) {
                    if (i != 0 && ((temp.length() - i) % _groupSize) == 0) {
                        buffer.append(_groupSep);
                    }
                    buffer.append(temp.charAt(i));
                }
            }
        } 
	else if (c == 'i' && !_letterValue.equals(""alphabetic"")) {
            buffer.append(romanValue(value));
        } 
	else if (c == 'I' && !_letterValue.equals(""alphabetic"")) {
            buffer.append(romanValue(value).toUpperCase());
        } 
	else {
	    int min = (int) c;
	    int max = (int) c;

	    
	    if (c >= 0x3b1 && c <= 0x3c9) {
		max = 0x3c9;	
	    }
	    else {
		
		while (Character.isLetterOrDigit((char) (max + 1))) {
		    max++;
		}
	    }
            buffer.append(alphaValue(value, min, max));
        }
    }

    private String alphaValue(int value, int min, int max) {
        if (value <= 0) {
	    return """" + value;
	}

        int range = max - min + 1;
        char last = (char)(((value-1) % range) + min);
        if (value > range) {
            return alphaValue((value-1) / range, min, max) + last;
        } 
	else {
            return """" + last;
        }
    }

    private String romanValue(int n) {
        if (n <= 0 || n > 4000) {
	    return """" + n;
	}
        return
	    Thousands[n / 1000] +
	    Hundreds[(n / 100) % 10] +
	    Tens[(n/10) % 10] +
	    Ones[n % 10];
    }
}

"
org.apache.xpath.functions.FuncExtElementAvailable,2,4,0,10,17,1,0,10,2,2.0,87,0.0,0,0.979591837,0.75,2,7,42.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xalan.templates.Constants;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;
import org.apache.xpath.ExtensionsProvider;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class FuncExtElementAvailable extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String prefix;
    String namespace;
    String methName;

    String fullName = m_arg0.execute(xctxt).str();
    int indexOfNSSep = fullName.indexOf(':');

    if (indexOfNSSep < 0)
    {
      prefix = """";
      namespace = Constants.S_XSLNAMESPACEURL;
      methName = fullName;
    }
    else
    {
      prefix = fullName.substring(0, indexOfNSSep);
      namespace = xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);
      if (null == namespace)
        return XBoolean.S_FALSE;
      methName= fullName.substring(indexOfNSSep + 1);
    }

    if (namespace.equals(Constants.S_XSLNAMESPACEURL)
    ||  namespace.equals(Constants.S_BUILTIN_EXTENSIONS_URL))
    {
      try
      {
        TransformerImpl transformer = (TransformerImpl) xctxt.getOwnerObject();
        return transformer.getStylesheet().getAvailableElements().containsKey(
                                                            new QName(namespace, methName))
               ? XBoolean.S_TRUE : XBoolean.S_FALSE;
      }
      catch (Exception e)
      {
        return XBoolean.S_FALSE;
      }
    }
    else
    {
      
      ExtensionsProvider extProvider = (ExtensionsProvider)xctxt.getOwnerObject();
      return extProvider.elementAvailable(namespace, methName)
             ? XBoolean.S_TRUE : XBoolean.S_FALSE;
    }
  }
}
"
org.apache.xml.dtm.FactoryFinder,7,1,0,3,35,11,1,2,0,0.611111111,395,0.666666667,0,0.0,0.333333333,0,0,55.0,2,0.8571,0,"

package org.apache.xml.dtm;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.Properties;


class FactoryFinder {
    
    private static boolean debug;
    
   
   private static String foundFactory = null;
   

    
    static {
        try {
            String val =
                SecuritySupport.getInstance().getSystemProperty(""jaxp.debug"");
            
            debug = val != null && (! ""false"".equals(val));
        } catch (SecurityException se) {
            debug = false;
        }
    }

    
    static Object find(String factoryId, String fallbackClassName)
        throws ConfigurationError
    {
        SecuritySupport ss = SecuritySupport.getInstance();
        ClassLoader cl = FactoryFinder.class.getClassLoader();
        dPrint(""find factoryId="" + factoryId);

        
        try {
            String systemProp = ss.getSystemProperty(factoryId);
            if (systemProp != null) {
                dPrint(""found system property, value="" + systemProp);
                
                return newInstance(systemProp, cl, true);
            }
            
        } catch (SecurityException se) {
            
        }

   
        synchronized (FactoryFinder.class) {            
            
            
            
            
            
   
            if (foundFactory == null) {
           
               
               Properties xalanProperties = null;
                try {
                   String javah = ss.getSystemProperty(""java.home"");
                   String configFile = javah + File.separator +
                        ""lib"" + File.separator + ""xalan.properties"";

                   File f = new File(configFile);
                   FileInputStream fis = ss.getFileInputStream(f);
                   xalanProperties = new Properties();
                   xalanProperties.load(fis);
                   fis.close();
                   
               } catch (Exception x) {
                
                
                
               }
               
               if (xalanProperties != null) {            
                   foundFactory = xalanProperties.getProperty(factoryId);
                   if (foundFactory != null) {
                       dPrint(""found in xalan.properties, value="" + foundFactory);
                   }
                } else {    
                    
                    
                    findJarServiceProvider(factoryId);
        
                    if (foundFactory == null) {
                        if (fallbackClassName == null) {
                            throw new ConfigurationError(
                            ""Provider for "" + factoryId + "" cannot be found"", null);
                        }

                        dPrint(""using fallback, value="" + fallbackClassName);
                        foundFactory = fallbackClassName;        
                    }
               }   
            }               
        }
            
        return newInstance(foundFactory, cl, true);
    }

    private static void dPrint(String msg) {
        if (debug) {
            System.err.println(""JAXP: "" + msg);
        }
    }

    
    private static Object newInstance(String className, ClassLoader cl,
                                      boolean doFallback)
        throws ConfigurationError
    {
        

        try {
            Class providerClass;
            if (cl == null) {
                
                
                
                
                
                
                
                
                
                providerClass = Class.forName(className);
            } else {
                try {
                    providerClass = cl.loadClass(className);
                } catch (ClassNotFoundException x) {
                    if (doFallback) {
                        
                        cl = FactoryFinder.class.getClassLoader();
                        providerClass = cl.loadClass(className);
                    } else {
                        throw x;
                    }
                }
            }
            Object instance = providerClass.newInstance();
            dPrint(""created new instance of "" + providerClass +
                   "" using ClassLoader: "" + cl);
            return instance;
        } catch (ClassNotFoundException x) {
            throw new ConfigurationError(
                ""Provider "" + className + "" not found"", x);
        } catch (Exception x) {
            throw new ConfigurationError(
                ""Provider "" + className + "" could not be instantiated: "" + x,
                x);
        }
    }

    
    private static String findJarServiceProvider(String factoryId)
        throws ConfigurationError
    {
        SecuritySupport ss = SecuritySupport.getInstance();
        String serviceId = ""META-INF/services/"" + factoryId;
        InputStream is = null;
        
        ClassLoader cl = FactoryFinder.class.getClassLoader();
        is = ss.getResourceAsStream(cl, serviceId);

        if (is == null) {
            
            return null;
        }

        dPrint(""found jar resource="" + serviceId +
               "" using ClassLoader: "" + cl);

        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        BufferedReader rd;
        try {
            rd = new BufferedReader(new InputStreamReader(is, ""UTF-8""));
        } catch (java.io.UnsupportedEncodingException e) {
            rd = new BufferedReader(new InputStreamReader(is));
        }
        
        String factoryClassName = null;
        try {
            
            
            factoryClassName = rd.readLine();
            rd.close();
        } catch (IOException x) {
            
            return null;
        }

        if (factoryClassName != null &&
            ! """".equals(factoryClassName)) {
            dPrint(""found in resource, value=""
                   + factoryClassName);

            
            
            
            
            return factoryClassName;
        }

        
        return null;
    }

    static class ConfigurationError extends Error {
        private Exception exception;

        
        ConfigurationError(String msg, Exception x) {
            super(msg);
            this.exception = x;
        }

        Exception getException() {
            return exception;
        }
    }
}
"
org.apache.xml.dtm.DTMAxisTraverser,5,1,12,31,6,10,31,0,5,2.0,19,0.0,0,0.0,0.9,0,0,2.8,1,0.8,0,"
package org.apache.xml.dtm;


public abstract class DTMAxisTraverser
{

  
  public int first(int context)
  {
    return next(context, context);
  }

  
  public int first(int context, int extendedTypeID)
  {
    return next(context, context, extendedTypeID);
  }

  
  public abstract int next(int context, int current);

  
  public abstract int next(int context, int current, int extendedTypeID);
}
"
org.apache.xpath.axes.AttributeIterator,3,7,0,4,6,3,1,3,1,2.0,31,0.0,0,0.985185185,0.555555556,3,5,9.333333333,2,1.0,1,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.compiler.Compiler;


public class AttributeIterator extends ChildTestIterator
{

  
  AttributeIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis);
  }
    
  
  protected int getNextNode()
  {
    m_lastFetched = (DTM.NULL == m_lastFetched)
                     ? m_cdtm.getFirstAttribute(m_context)
                     : m_cdtm.getNextAttribute(m_lastFetched);
    return m_lastFetched;
  }
  
  
  public int getAxis()
  {
    return org.apache.xml.dtm.Axis.ATTRIBUTE;
  }



}
"
org.apache.xalan.xsltc.compiler.CopyOf,5,3,0,24,32,0,1,23,4,0.25,269,1.0,1,0.933333333,0.333333333,1,4,52.6,5,1.8,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.ResultTreeType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class CopyOf extends Instruction {
    private Expression _select;
	
    public void display(int indent) {
	indent(indent);
	Util.println(""CopyOf"");
	indent(indent + IndentIncrement);
	Util.println(""select "" + _select.toString());
    }

    public void parseContents(Parser parser) {
	_select = parser.parseExpression(this, ""select"", null);
        
        if (_select.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""select"");
	    return;
        }
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tselect = _select.typeCheck(stable);
	if (tselect instanceof NodeType ||
	    tselect instanceof NodeSetType ||
	    tselect instanceof ReferenceType ||
	    tselect instanceof ResultTreeType) {
	    
	}
	else {
	    _select = new CastExpr(_select, Type.String);
	}
	return Type.Void;
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final Type tselect = _select.getType();

	final String CPY1_SIG = ""(""+NODE_ITERATOR_SIG+TRANSLET_OUTPUT_SIG+"")V"";
	final int cpy1 = cpg.addInterfaceMethodref(DOM_INTF, ""copy"", CPY1_SIG);

	final String CPY2_SIG = ""(""+NODE_SIG+TRANSLET_OUTPUT_SIG+"")V"";
	final int cpy2 = cpg.addInterfaceMethodref(DOM_INTF, ""copy"", CPY2_SIG);
	
	final String getDoc_SIG = ""()""+NODE_SIG;
	final int getDoc = cpg.addInterfaceMethodref(DOM_INTF, ""getDocument"", getDoc_SIG);


	if (tselect instanceof NodeSetType) {
	    il.append(methodGen.loadDOM());

	    
	    _select.translate(classGen, methodGen);	
	    _select.startResetIterator(classGen, methodGen);

	    
	    il.append(methodGen.loadHandler());
	    il.append(new INVOKEINTERFACE(cpy1, 3));
	}
	else if (tselect instanceof NodeType) {
	    il.append(methodGen.loadDOM());
	    _select.translate(classGen, methodGen);	
	    il.append(methodGen.loadHandler());
	    il.append(new INVOKEINTERFACE(cpy2, 3));
	}
	else if (tselect instanceof ResultTreeType) {
	    _select.translate(classGen, methodGen);	
	    
	    il.append(DUP); 
	    il.append(new INVOKEINTERFACE(getDoc,1)); 
	    il.append(methodGen.loadHandler());
	    il.append(new INVOKEINTERFACE(cpy2, 3));
	}
	else if (tselect instanceof ReferenceType) {
	    _select.translate(classGen, methodGen);
	    il.append(methodGen.loadHandler());
	    il.append(methodGen.loadCurrentNode());
	    il.append(methodGen.loadDOM());
	    final int copy = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""copy"",
					      ""("" 
					      + OBJECT_SIG  
					      + TRANSLET_OUTPUT_SIG 
					      + NODE_SIG
					      + DOM_INTF_SIG
					      + "")V"");
	    il.append(new INVOKESTATIC(copy));
	}
	else {
	    il.append(classGen.loadTranslet());
	    _select.translate(classGen, methodGen);
	    il.append(methodGen.loadHandler());
	    il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
							 CHARACTERSW,
							 CHARACTERSW_SIG)));
	}

    }
}
"
org.apache.xalan.xsltc.compiler.Output,8,3,0,19,43,0,2,19,7,0.847619048,734,1.0,0,0.895522388,0.270833333,3,7,88.875,29,5.875,1,"

package org.apache.xalan.xsltc.compiler;

import java.io.OutputStreamWriter;
import java.util.Properties;
import java.util.StringTokenizer;

import javax.xml.transform.OutputKeys;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xml.serializer.Encodings;

final class Output extends TopLevelElement {

    

    
    
    private String  _version;
    private String  _method;
    private String  _encoding;
    private boolean _omitHeader = false;
    private String  _standalone;
    private String  _doctypePublic;
    private String  _doctypeSystem;
    private String  _cdata;
    private boolean _indent = false;
    private String  _mediaType;
    private String  _cdataToMerge;

    
    private boolean _disabled = false;

    
    private final static String STRING_SIG = ""Ljava/lang/String;"";
    private final static String XML_VERSION = ""1.0"";
    private final static String HTML_VERSION = ""4.0"";

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Output "" + _method);
    }

    
    public void disable() {
	_disabled = true;
    }

    public boolean enabled() {
	return !_disabled;
    }

    public String getCdata() {
	return _cdata;
    }

    public void mergeCdata(String cdata) {
	_cdataToMerge = cdata;
    }

    
    public void parseContents(Parser parser) {
	final Properties outputProperties = new Properties();

	
	parser.setOutput(this);

	
	if (_disabled) return;

	String attrib = null;

	
	_version = getAttribute(""version"");
	if (_version == null || _version.equals(Constants.EMPTYSTRING)) {
	    _version = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.VERSION, _version);
	}

	
	_method = getAttribute(""method"");
	if (_method.equals(Constants.EMPTYSTRING)) {
	    _method = null;
	}
	if (_method != null) {
	    _method = _method.toLowerCase();
	    outputProperties.setProperty(OutputKeys.METHOD, _method);
	}

	
	_encoding = getAttribute(""encoding"");
	if (_encoding.equals(Constants.EMPTYSTRING)) {
	    _encoding = null;
	}
	else {
	    try {
		
        String canonicalEncoding;
        canonicalEncoding = Encodings.convertMime2JavaEncoding(_encoding);
		OutputStreamWriter writer =
		    new OutputStreamWriter(System.out, canonicalEncoding); 
	    }
	    catch (java.io.UnsupportedEncodingException e) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.UNSUPPORTED_ENCODING,
					    _encoding, this);
		parser.reportError(Constants.WARNING, msg);
	    }
	    outputProperties.setProperty(OutputKeys.ENCODING, _encoding);
	}

	
	attrib = getAttribute(""omit-xml-declaration"");
	if (attrib != null && !attrib.equals(Constants.EMPTYSTRING)) {
	    if (attrib.equals(""yes"")) {
		_omitHeader = true;
	    }
	    outputProperties.setProperty(OutputKeys.OMIT_XML_DECLARATION, attrib);
	}

	
	_standalone = getAttribute(""standalone"");
	if (_standalone.equals(Constants.EMPTYSTRING)) {
	    _standalone = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.STANDALONE, _standalone);
	}

	
	_doctypeSystem = getAttribute(""doctype-system"");
	if (_doctypeSystem.equals(Constants.EMPTYSTRING)) {
	    _doctypeSystem = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, _doctypeSystem);
	}


	_doctypePublic = getAttribute(""doctype-public"");
	if (_doctypePublic.equals(Constants.EMPTYSTRING)) {
	    _doctypePublic = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, _doctypePublic);
	}

	
	_cdata = getAttribute(""cdata-section-elements"");
	if (_cdata != null && _cdata.equals(Constants.EMPTYSTRING)) {
	    _cdata = null;
	}
	else {
	    StringBuffer expandedNames = new StringBuffer();
	    StringTokenizer tokens = new StringTokenizer(_cdata);

	    
	    while (tokens.hasMoreTokens()) {
		expandedNames.append(
		   parser.getQName(tokens.nextToken()).toString()).append(' ');
	    }
	    _cdata = expandedNames.toString();
	    if (_cdataToMerge != null) {
		_cdata = _cdata + _cdataToMerge;
	    }
	    outputProperties.setProperty(OutputKeys.CDATA_SECTION_ELEMENTS, 
		_cdata);
	}

	
	attrib = getAttribute(""indent"");
	if (attrib != null && !attrib.equals(EMPTYSTRING)) {
	    if (attrib.equals(""yes"")) {
		_indent = true;
	    }
	    outputProperties.setProperty(OutputKeys.INDENT, attrib);
	}
	else if (_method != null && _method.equals(""html"")) {
	    _indent = true;
	}

	
	_mediaType = getAttribute(""media-type"");
	if (_mediaType.equals(Constants.EMPTYSTRING)) {
	    _mediaType = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.MEDIA_TYPE, _mediaType);
	}

	
	if (_method != null) {
	    if (_method.equals(""html"")) {
		if (_version == null) {
		    _version = HTML_VERSION;
		}
		if (_mediaType == null) {
		    _mediaType = ""text/html"";
		}
	    }
	    else if (_method.equals(""text"")) {
		if (_mediaType == null) {
		    _mediaType = ""text/plain"";
		}
	    }
	}

	
	parser.getCurrentStylesheet().setOutputProperties(outputProperties);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	
	if (_disabled) return;

	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();

	int field = 0;
        il.append(classGen.loadTranslet());

	
	if ((_version != null) && (!_version.equals(XML_VERSION))) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_version"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _version));
	    il.append(new PUTFIELD(field));
	}

	
	if (_method != null) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_method"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _method));
	    il.append(new PUTFIELD(field));
	}

	
	if (_encoding != null) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_encoding"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _encoding));
	    il.append(new PUTFIELD(field));
	}

	
	if (_omitHeader) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_omitHeader"", ""Z"");
	    il.append(DUP);
	    il.append(new PUSH(cpg, _omitHeader));
	    il.append(new PUTFIELD(field));
	}

	
	if (_standalone != null) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_standalone"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _standalone));
	    il.append(new PUTFIELD(field));
	}

	
	field = cpg.addFieldref(TRANSLET_CLASS,""_doctypeSystem"",STRING_SIG);
	il.append(DUP);
	il.append(new PUSH(cpg, _doctypeSystem));
	il.append(new PUTFIELD(field));
	field = cpg.addFieldref(TRANSLET_CLASS,""_doctypePublic"",STRING_SIG);
	il.append(DUP);
	il.append(new PUSH(cpg, _doctypePublic));
	il.append(new PUTFIELD(field));
	
	
	if (_mediaType != null) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_mediaType"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _mediaType));
	    il.append(new PUTFIELD(field));
	}

	
	if (_indent) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_indent"", ""Z"");
	    il.append(DUP);
	    il.append(new PUSH(cpg, _indent));
	    il.append(new PUTFIELD(field));
	}

	
	if (_cdata != null) {
	    int index = cpg.addMethodref(TRANSLET_CLASS,
					 ""addCdataElement"",
					 ""(Ljava/lang/String;)V"");

	    StringTokenizer tokens = new StringTokenizer(_cdata);
	    while (tokens.hasMoreTokens()) {
		il.append(DUP);
		il.append(new PUSH(cpg, tokens.nextToken()));
		il.append(new INVOKEVIRTUAL(index));
	    }
	}
	il.append(POP); 
    }

}
"
org.apache.xpath.SourceTree,1,1,0,1,2,0,1,0,1,2.0,12,0.0,0,0.0,1.0,0,0,9.0,0,0.0,1,"
package org.apache.xpath;



public class SourceTree
{

  
  public SourceTree(int root, String url)
  {
    m_root = root;
    m_url = url;
  }

  
  public String m_url;

  
  public int m_root;
}
"
org.apache.xalan.xsltc.compiler.util.CompareGenerator,11,5,0,16,23,37,3,13,10,0.916666667,141,1.0,0,0.93877551,0.225,2,5,10.72727273,2,0.9091,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ACONST_NULL;
import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.Type;
import org.apache.xalan.xsltc.compiler.Constants;

public final class CompareGenerator extends MethodGenerator {

    private static int DOM_INDEX      = 1;
    private static int CURRENT_INDEX  = 2;
    private static int LEVEL_INDEX    = 3;
    private static int TRANSLET_INDEX = 4;
    private static int LAST_INDEX     = 5;
    private int ITERATOR_INDEX = 6;

    private final Instruction _iloadCurrent;
    private final Instruction _istoreCurrent;
    private final Instruction _aloadDom;
    private final Instruction _iloadLast;
    private final Instruction _aloadIterator;
    private final Instruction _astoreIterator;

    public CompareGenerator(int access_flags, Type return_type,
			    Type[] arg_types, String[] arg_names,
			    String method_name, String class_name,
			    InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
	
	_iloadCurrent = new ILOAD(CURRENT_INDEX);
	_istoreCurrent = new ISTORE(CURRENT_INDEX);
	_aloadDom = new ALOAD(DOM_INDEX);
	_iloadLast = new ILOAD(LAST_INDEX);

	LocalVariableGen iterator =
	    addLocalVariable(""iterator"",
			     Util.getJCRefType(Constants.NODE_ITERATOR_SIG),
			     null, null);
	ITERATOR_INDEX = iterator.getIndex();
	_aloadIterator = new ALOAD(ITERATOR_INDEX);
	_astoreIterator = new ASTORE(ITERATOR_INDEX);
	il.append(new ACONST_NULL());
	il.append(storeIterator());
    }

    public Instruction loadLastNode() {
	return _iloadLast;
    }

    public Instruction loadCurrentNode() {
	return _iloadCurrent;
    }

    public Instruction storeCurrentNode() {
	return _istoreCurrent;
    }

    public Instruction loadDOM() {
	return _aloadDom;
    }

    public int getHandlerIndex() {
	return INVALID_INDEX;		
    }

    public int getIteratorIndex() {
	return INVALID_INDEX;
    }

    public Instruction storeIterator() {
	return _astoreIterator;
    }
    
    public Instruction loadIterator() {
	return _aloadIterator;
    }

    
    public int getLocalIndex(String name) {
	if (name.equals(""current"")) {
	    return CURRENT_INDEX;
	}
	return super.getLocalIndex(name);
    }
}
"
org.apache.xpath.axes.ChildIterator,4,5,0,5,9,6,1,4,3,2.0,64,0.0,0,0.9765625,0.4375,1,6,15.0,4,1.5,1,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.Compiler;


public class ChildIterator extends LocPathIterator
{

  
  ChildIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, false);
  }
  
  
  public int asNode(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
    int current = xctxt.getCurrentNode();
    
    DTM dtm = xctxt.getDTM(current);
    
    return dtm.getFirstChild(current);
  }

  
  public int nextNode()
  {
  	if(m_foundLast)
  		return DTM.NULL;

    int next;

    m_lastFetched = next = (DTM.NULL == m_lastFetched)
                           ? m_cdtm.getFirstChild(m_context)
                           : m_cdtm.getNextSibling(m_lastFetched);

    
    if (DTM.NULL != next)
    {
      m_pos++;
      return next;
    }
    else
    {
      m_foundLast = true;

      return DTM.NULL;
    }
  }
  
  
  public int getAxis()
  {
    return org.apache.xml.dtm.Axis.CHILD;
  }


}
"
org.apache.xml.utils.Trie,3,1,0,2,8,0,2,1,3,0.75,100,0.0,1,0.0,0.666666667,0,0,31.66666667,4,2.3333,1,"
package org.apache.xml.utils;


public class Trie
{

  
  public static final int ALPHA_SIZE = 128;

  
  Node m_Root;

  
  public Trie()
  {
    m_Root = new Node();
  }

  
  public Object put(String key, Object value)
  {

    final int len = key.length();
    Node node = m_Root;

    for (int i = 0; i < len; i++)
    {
      Node nextNode = node.m_nextChar[Character.toUpperCase(key.charAt(i))];

      if (nextNode != null)
      {
        node = nextNode;
      }
      else
      {
        for (; i < len; i++)
        {
          Node newNode = new Node();

          node.m_nextChar[Character.toUpperCase(key.charAt(i))] = newNode;
          node = newNode;
        }

        break;
      }
    }

    Object ret = node.m_Value;

    node.m_Value = value;

    return ret;
  }

  
  public Object get(String key)
  {

    final int len = key.length();
    Node node = m_Root;

    for (int i = 0; i < len; i++)
    {
      try
      {
        node = node.m_nextChar[Character.toUpperCase(key.charAt(i))];
      }
      catch (ArrayIndexOutOfBoundsException e)
      {

        
        node = null;
      }

      if (node == null)
        return null;
    }

    return node.m_Value;
  }

  
  class Node
  {

    
    Node()
    {
      m_nextChar = new Node[ALPHA_SIZE];
      m_Value = null;
    }

    
    Node m_nextChar[];

    
    Object m_Value;
  }
}
"
org.apache.xpath.Arg,15,1,0,3,21,0,1,2,15,0.628571429,158,1.0,2,0.0,0.311111111,0,0,9.2,2,0.8667,1,"
package org.apache.xpath;

import org.apache.xml.utils.QName;
import org.apache.xpath.objects.XObject;


public class Arg
{

  
  private QName m_qname;

  
  public final QName getQName()
  {
    return m_qname;
  }

  
  public final void setQName(QName name)
  {
    m_qname = name;
  }

  
  private XObject m_val;

  
  public final XObject getVal()
  {
    return m_val;
  }

  
  public final void setVal(XObject val)
  {
    m_val = val;
  }
  
  
  public void detach()
  {
    if(null != m_val)
    {
      m_val.allowDetachToRelease(true);
      m_val.detach();
    }
  }


  
  private String m_expression;

  
  public String getExpression()
  {
    return m_expression;
  }

  
  public void setExpression(String expr)
  {
    m_expression = expr;
  }

  
  private boolean m_isFromWithParam;

  
   public boolean isFromWithParam()
   {
    return m_isFromWithParam;
   }

  
  private boolean m_isVisible;

  
   public boolean isVisible()
   {
    return m_isVisible;
   }
   
  
   public void setIsVisible(boolean b)
   {
    m_isVisible = b;
   }

  
  public Arg()
  {

    m_qname = new QName("""");
    ;  
    m_val = null;
    m_expression = null;
    m_isVisible = true;
    m_isFromWithParam = false;
  }

  
  public Arg(QName qname, String expression, boolean isFromWithParam)
  {

    m_qname = qname;
    m_val = null;
    m_expression = expression;
    m_isFromWithParam = isFromWithParam;
    m_isVisible = !isFromWithParam;
  }

  
  public Arg(QName qname, XObject val)
  {

    m_qname = qname;
    m_val = val;
    m_isVisible = true;
    m_isFromWithParam = false;
    m_expression = null;
  }
  
  
  public boolean equals(Object obj) 
  {
    if(obj instanceof QName)
    {
      return m_qname.equals(obj);
    }
    else
      return super.equals(obj);
  }

  
  public Arg(QName qname, XObject val, boolean isFromWithParam)
  {

    m_qname = qname;
    m_val = val;
    m_isFromWithParam = isFromWithParam;
    m_isVisible = !isFromWithParam;
    m_expression = null;
  }
}
"
org.apache.xalan.xsltc.compiler.RealExpr,4,3,0,11,14,0,0,11,4,0.333333333,44,1.0,0,0.959459459,0.4,2,7,9.75,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class RealExpr extends Expression {
    private double _value;

    public RealExpr(double value) {
	_value = value;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _type = Type.Real;
    }

    public String toString() {
	return ""real-expr("" + _value + ')';
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }
}
"
org.apache.xalan.trace.GenerateEvent,5,1,0,4,6,0,4,1,5,0.6875,82,0.0,1,0.0,0.666666667,0,0,13.8,0,0.0,1,"
package org.apache.xalan.trace;

import org.apache.xalan.transformer.TransformerImpl;
import org.xml.sax.Attributes;


public class GenerateEvent implements java.util.EventListener
{

  
  public TransformerImpl m_processor;

  
  public int m_eventtype;


  
  public char m_characters[];

  
  public int m_start;

  
  public int m_length;

  
  public String m_name;

  
  public String m_data;

  
  public Attributes m_atts;

  
  public GenerateEvent(TransformerImpl processor, int eventType)
  {
    m_processor = processor;
    m_eventtype = eventType;
  }

  
  public GenerateEvent(TransformerImpl processor, int eventType, String name,
                       Attributes atts)
  {

    m_name = name;
    m_atts = atts;
    m_processor = processor;
    m_eventtype = eventType;
  }

  
  public GenerateEvent(TransformerImpl processor, int eventType, char ch[],
                       int start, int length)
  {

    m_characters = ch;
    m_start = start;
    m_length = length;
    m_processor = processor;
    m_eventtype = eventType;
  }

  
  public GenerateEvent(TransformerImpl processor, int eventType, String name,
                       String data)
  {

    m_name = name;
    m_data = data;
    m_processor = processor;
    m_eventtype = eventType;
  }

  
  public GenerateEvent(TransformerImpl processor, int eventType, String data)
  {

    m_data = data;
    m_processor = processor;
    m_eventtype = eventType;
  }
}
"
org.apache.xml.dtm.ref.DTMNamedNodeMap,9,1,0,3,16,24,2,2,9,0.708333333,143,0.0,1,0.0,0.4,0,0,14.55555556,3,1.5556,1,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTM;

import org.w3c.dom.DOMException;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;


public class DTMNamedNodeMap implements NamedNodeMap
{

  
  DTM dtm;

  
  int element;

  
  short m_count = -1;

  
  public DTMNamedNodeMap(DTM dtm, int element)
  {
    this.dtm = dtm;
    this.element = element;
  }

  
  public int getLength()
  {

    if (m_count == -1)
    {
      short count = 0;

      for (int n = dtm.getFirstAttribute(element); n != -1;
              n = dtm.getNextAttribute(n))
      {
        ++count;
      }

      m_count = count;
    }

    return (int) m_count;
  }

  
  public Node getNamedItem(String name)
  {

    for (int n = dtm.getFirstAttribute(element); n != -1;
            n = dtm.getNextAttribute(n))
    {
      if (dtm.getNodeName(n).equals(name))
        return dtm.getNode(n);
    }

    return null;
  }

  
  public Node item(int i)
  {

    int count = 0;

    for (int n = dtm.getFirstAttribute(element); n != -1;
            n = dtm.getNextAttribute(n))
    {
      if (count == i)
        return dtm.getNode(n);
      else
        ++count;
    }

    return null;
  }

  
  public Node setNamedItem(Node newNode)
  {
    throw new DTMException(DTMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public Node removeNamedItem(String name)
  {
    throw new DTMException(DTMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public Node getNamedItemNS(String namespaceURI, String localName)
  {
    throw new DTMException(DTMException.NOT_SUPPORTED_ERR);
  }

  
  public Node setNamedItemNS(Node arg) throws DOMException
  {
    throw new DTMException(DTMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public Node removeNamedItemNS(String namespaceURI, String localName)
          throws DOMException
  {
    throw new DTMException(DTMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public class DTMException extends org.w3c.dom.DOMException
  {

    
    public DTMException(short code, String message)
    {
      super(code, message);
    }

    
    public DTMException(short code)
    {
      super(code, """");
    }
  }
}
"
org.apache.xml.serializer.SerializerBase,65,1,3,12,109,1852,3,9,46,0.965104167,842,0.933333333,4,0.0,0.13974359,0,0,11.49230769,9,1.4615,2,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.util.Hashtable;
import java.util.Stack;
import java.util.Vector;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.Transformer;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.BoolStack;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;



abstract public class SerializerBase
    implements SerializationHandler, SerializerConstants, org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.CharacterNodeHandler
{
    

    
    protected void fireEndElem(String name)
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
        if (m_tracer != null)
            m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENDELEMENT,name, (Attributes)null);     	        	    	
    }

    
    protected void fireCharEvent(char[] chars, int start, int length)
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
        if (m_tracer != null)
            m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_CHARACTERS, chars, start,length);     	        	    	
    }

    
    protected boolean m_needToCallStartDocument = true; 
    
    
    protected boolean m_startTagOpen = false;

    
    int m_currentElemDepth = 0;

    
    protected String m_elementName = null;
    
    
    protected String m_elementLocalName = null;
    
    
    protected String m_elementURI = null;


    
    protected boolean m_cdataTagOpen = false;

    
    protected AttributesImplSerializer m_attributes = new AttributesImplSerializer();

    
    protected boolean m_inEntityRef = false;

    
    protected boolean m_inExternalDTD = false;

    
    protected BoolStack m_cdataSectionStates = new BoolStack();

    
    private String m_doctypeSystem;

    
    private String m_doctypePublic;

    
    boolean m_needToOutputDocTypeDecl = true;

    
    private String m_encoding = null;

    
    protected Stack m_nodeStack;

    
    protected Stack m_prefixStack;

    
    private boolean m_shouldNotWriteXMLHeader = false;

    
    private String m_standalone;

    
    protected boolean m_standaloneWasSpecified = false;

    
    protected boolean m_doIndent = false;
    
    protected int m_indentAmount = 0;

    
    private String m_version = null;

    
    private String m_mediatype;

    
    private Transformer m_transformer;

    
    protected Vector m_cdataSectionElements = null;

    
    protected NamespaceMappings m_prefixMap;
    
    
    protected SerializerTrace m_tracer;
    
    protected SourceLocator m_sourceLocator;
    

    
    protected java.io.Writer m_writer = null;    

    
    public void comment(String data) throws SAXException
    {
        this.comment(data.toCharArray(), 0, data.length());
    }

    
    protected String patchName(String qname)
    {

        
        final int lastColon = qname.lastIndexOf(':');

        if (lastColon > 0) {
            final int firstColon = qname.indexOf(':');
            final String prefix = qname.substring(0, firstColon);
            final String localName = qname.substring(lastColon + 1);

        
            final String uri = m_prefixMap.lookupNamespace(prefix);
            if (uri != null && uri.length() == 0) {
                return localName;
            }
            else if (firstColon != lastColon) {
                return prefix + ':' + localName;
            }
        }
        return qname;        
    }

    
    protected static String getLocalName(String qname)
    {
        final int col = qname.lastIndexOf(':');
        return (col > 0) ? qname.substring(col + 1) : qname;
    }

    
    public void setDocumentLocator(Locator locator)
    {
        return;

        
    }

    
    public void addAttribute(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
        throws SAXException
    {
        if (m_startTagOpen)
        {
            addAttributeAlways(uri, localName, rawName, type, value);
        }

    }
    
    
    public void addAttributeAlways(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
    {



            int index;






            index = m_attributes.getIndex(rawName);
            if (index >= 0)
            {
                
                m_attributes.setValue(index,value);
            }
            else
            {
                
                m_attributes.addAttribute(uri, localName, rawName, type, value);
            }
        
    }
  

    
    public void addAttribute(String name, final String value)
    {
        if (m_startTagOpen)
        {
            final String patchedName = patchName(name);
            final String localName = getLocalName(patchedName);
            final String uri = getNamespaceURI(patchedName, false);

            addAttributeAlways(uri,localName, patchedName, ""CDATA"", value);
         }
    }    


    
    public void addAttributes(Attributes atts) throws SAXException
    {

        int nAtts = atts.getLength();

        for (int i = 0; i < nAtts; i++)
        {
            String uri = atts.getURI(i);

            if (null == uri)
                uri = """";

            addAttributeAlways(
                uri,
                atts.getLocalName(i),
                atts.getQName(i),
                atts.getType(i),
                atts.getValue(i));

        }
    }

    
    public ContentHandler asContentHandler() throws IOException
    {
        return this;
    }

    
    public void endEntity(String name) throws org.xml.sax.SAXException
    {
        if (name.equals(""[dtd]""))
            m_inExternalDTD = false;
        m_inEntityRef = false;

        this.fireEndEntity(name);        
    }

    
    public void close()
    {
        
    }

    
    protected void initCDATA()
    {
        
        
        
    }

    
    public String getEncoding()
    {
        return m_encoding;
    }

   
    public void setEncoding(String m_encoding)
    {
        this.m_encoding = m_encoding;
    }

    
    public void setOmitXMLDeclaration(boolean b)
    {
        this.m_shouldNotWriteXMLHeader = b;
    }


    
    public boolean getOmitXMLDeclaration()
    {
        return m_shouldNotWriteXMLHeader;
    }

        
    public String getDoctypePublic()
    {
        return m_doctypePublic;
    }

    
    public void setDoctypePublic(String doctypePublic)
    {
        this.m_doctypePublic = doctypePublic;
    }


        
    public String getDoctypeSystem()
    {
        return m_doctypeSystem;
    }

    
    public void setDoctypeSystem(String doctypeSystem)
    {
        this.m_doctypeSystem = doctypeSystem;
    }

    
    public void setDoctype(String doctypeSystem, String doctypePublic)
    {
        this.m_doctypeSystem = doctypeSystem;
        this.m_doctypePublic = doctypePublic;
    }

    
    public void setStandalone(String standalone)
    {
        if (standalone != null)
        {
            m_standaloneWasSpecified = true;
            setStandaloneInternal(standalone);
        }
    }
        
    protected void setStandaloneInternal(String standalone)
    {
        if (""yes"".equals(standalone))
            m_standalone = ""yes"";
        else
            m_standalone = ""no"";
        
    }

    
    public String getStandalone()
    {
        return m_standalone;
    }

    
    public boolean getIndent()
    {
        return m_doIndent;
    }
    
    public String getMediaType()
    {
        return m_mediatype;
    }

    
    public String getVersion()
    {
        return m_version;
    }

    
    public void setVersion(String version)
    {
        m_version = version;
    }

    
    public void setMediaType(String mediaType)
    {
        m_mediatype = mediaType;
    }

    
    public int getIndentAmount()
    {
        return m_indentAmount;
    }

    
    public void setIndentAmount(int m_indentAmount)
    {
        this.m_indentAmount = m_indentAmount;
    }

    
    public void setIndent(boolean doIndent)
    {
        m_doIndent = doIndent;
    }

    
    public void namespaceAfterStartElement(String uri, String prefix)
        throws SAXException
    {
        
    }

    
    public DOMSerializer asDOMSerializer() throws IOException
    { 
        return this;
    }

    
    protected void pushCdataSectionState()
    {

        boolean b;

        if (null != m_cdataSectionElements)
        {
            b = false;
            if (m_elementLocalName == null)
                m_elementLocalName = getLocalName(m_elementName);
            if (m_elementURI == null)
            {
                String prefix = getPrefixPart(m_elementName);
                if (prefix != null)
                    m_elementURI = m_prefixMap.lookupNamespace(prefix);

            }

            if ((null != m_elementURI) && m_elementURI.length() == 0)
                m_elementURI = null;

            int nElems = m_cdataSectionElements.size();

            
            for (int i = 0; i < nElems; i += 2)
            {
                String uri = (String) m_cdataSectionElements.elementAt(i);
                String loc = (String) m_cdataSectionElements.elementAt(i + 1);
                if (loc.equals(m_elementLocalName)
                    && subPartMatch(m_elementURI, uri))
                {
                    b = true;

                    break;
                }
            }
        }
        else
        {
            b = m_cdataSectionStates.peekOrFalse();
        }

        m_cdataSectionStates.push(b);
    }

    
    private static final boolean subPartMatch(String p, String t)
    {
        return (p == t) || ((null != p) && (p.equals(t)));
    }

    
    protected static final String getPrefixPart(String qname)
    {
        final int col = qname.indexOf(':');
        return (col > 0) ? qname.substring(0, col) : null;
        
    }

    
    public NamespaceMappings getNamespaceMappings()
    {
        return m_prefixMap;
    }

    
    public String getPrefix(String namespaceURI)
    {
        String prefix = m_prefixMap.lookupPrefix(namespaceURI);
        return prefix;
    }

    
    public String getNamespaceURI(String qname, boolean isElement)
    {
        String uri = EMPTYSTRING;
        int col = qname.lastIndexOf(':');
        final String prefix = (col > 0) ? qname.substring(0, col) : EMPTYSTRING;

        if (!EMPTYSTRING.equals(prefix) || isElement)
        {
            if (m_prefixMap != null)
            {
                uri = m_prefixMap.lookupNamespace(prefix);
                if (uri == null && !prefix.equals(XMLNS_PREFIX))
                {
                    throw new RuntimeException(
                        XMLMessages.createXMLMessage(
                            XMLErrorResources.ER_NAMESPACE_PREFIX,
                            new Object[] { qname.substring(0, col) }  ));
                }
            }
        }
        return uri;
    }

    
    public String getNamespaceURIFromPrefix(String prefix)
    {
        String uri = null;
        if (m_prefixMap != null)
            uri = m_prefixMap.lookupNamespace(prefix);
        return uri;
    }

    
    public void entityReference(String name) throws org.xml.sax.SAXException
    {

        flushPending();

        startEntity(name);
        endEntity(name);

		fireEntityReference(name);
    }

    
    public void setTransformer(Transformer t)
    {
        m_transformer = t;
        
        
        
        
        if ((m_transformer instanceof SerializerTrace) &&
            (((SerializerTrace) m_transformer).hasTraceListeners())) {
           m_tracer = (SerializerTrace) m_transformer;
        } else {
           m_tracer = null;
        }
    }
    
    public Transformer getTransformer()
    {
        return m_transformer;
    }
    
    
    public void characters(org.w3c.dom.Node node)
        throws org.xml.sax.SAXException
    {
        flushPending();

        String data = node.getNodeValue();
        char[] ch = null;
        int length = 0;
        if (data != null)
        {
            ch = data.toCharArray();
            length = data.length();
             characters(ch, 0, length);

        }
    }
    

    
    public void error(SAXParseException exc) throws SAXException {
    }

    
    public void fatalError(SAXParseException exc) throws SAXException {
        
      m_startTagOpen = false;

    }

    
    public void warning(SAXParseException exc) throws SAXException 
    {
    }

    
    protected void fireStartEntity(String name)
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
        if (m_tracer != null)
            m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENTITYREF, name);     	        	    	
    }

    








    
    private void flushMyWriter()
    {
        if (m_writer != null)
        {
            try
            {
                m_writer.flush();
            }
            catch(IOException ioe)
            {
            
            }
        }
    }
    
    protected void fireCDATAEvent(char[] chars, int start, int length)
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
		if (m_tracer != null)
			m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_CDATA, chars, start,length);     	        	    	
    }

    
    protected void fireCommentEvent(char[] chars, int start, int length)
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
		if (m_tracer != null)
			m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_COMMENT, new String(chars, start, length));     	        	    	
    }


    
    public void fireEndEntity(String name)
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
    	
    }    

    
     protected void fireStartDoc()
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
        if (m_tracer != null)
            m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_STARTDOCUMENT);     	    
    }    


    
    protected void fireEndDoc()
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
        if (m_tracer != null)
        m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENDDOCUMENT);     	        	
    }    
    
    
    protected void fireStartElem(String elemName)
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
        if (m_tracer != null)
            m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_STARTELEMENT,
                elemName, m_attributes);     	        	
    }    


    








    
    protected void fireEscapingEvent(String name, String data)
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
        if (m_tracer != null)
            m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_PI,name, data);     	        	    	
    }    


    
    protected void fireEntityReference(String name)
        throws org.xml.sax.SAXException
    {
        flushMyWriter();
        if (m_tracer != null)
            m_tracer.fireGenerateEvent(SerializerTrace.EVENTTYPE_ENTITYREF,name, (Attributes)null);     	        	    	
    }    

    
    public void startDocument() throws org.xml.sax.SAXException
    {

        
        startDocumentInternal();
        m_needToCallStartDocument = false;
        return;
    }   
    
    
    protected void startDocumentInternal() throws org.xml.sax.SAXException
    {
    	this.fireStartDoc();
    } 
    
    public void setSourceLocator(SourceLocator locator)
    {
        m_sourceLocator = locator;    
    }

    
    
    public void setNamespaceMappings(NamespaceMappings mappings) {
        m_prefixMap = mappings;
    }

}
"
org.apache.xalan.xsltc.cmdline.getopt.MissingOptArgException,1,4,0,2,2,0,1,1,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.apache.xalan.xsltc.cmdline.getopt; 


class MissingOptArgException extends GetOptsException{
    public MissingOptArgException(String msg){
	super(msg);
    }
}
"
org.apache.xml.serializer.OutputPropertiesFactory,8,1,0,9,47,14,6,5,2,0.983516484,460,0.615384615,0,0.0,0.25,0,0,53.25,10,2.375,0,"
package org.apache.xml.serializer;

import java.io.BufferedInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.Enumeration;
import java.util.Properties;
import javax.xml.transform.OutputKeys;

import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.Constants;
import org.apache.xml.utils.WrappedRuntimeException;


public class OutputPropertiesFactory
{
    
    
    
    
    public static final String S_BUILTIN_EXTENSIONS_UNIVERSAL =
        ""{"" + Constants.S_BUILTIN_EXTENSIONS_URL + ""}"";

    

    
    public static final String S_KEY_INDENT_AMOUNT =
        S_BUILTIN_EXTENSIONS_UNIVERSAL + ""indent-amount"";

    
    public static final String S_KEY_CONTENT_HANDLER =
        S_BUILTIN_EXTENSIONS_UNIVERSAL + ""content-handler"";

    
    public static final String S_KEY_ENTITIES =
        S_BUILTIN_EXTENSIONS_UNIVERSAL + ""entities"";

    
    public static final String S_USE_URL_ESCAPING =
        S_BUILTIN_EXTENSIONS_UNIVERSAL + ""use-url-escaping"";

    
    public static final String S_OMIT_META_TAG =
        S_BUILTIN_EXTENSIONS_UNIVERSAL + ""omit-meta-tag"";

    
    public static final String S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL =
        ""{"" + Constants.S_BUILTIN_OLD_EXTENSIONS_URL + ""}"";

    
    public static final int S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL_LEN =
        S_BUILTIN_OLD_EXTENSIONS_UNIVERSAL.length();

    
    
    

    private static final String S_XSLT_PREFIX = ""xslt.output."";
    private static final int S_XSLT_PREFIX_LEN = S_XSLT_PREFIX.length();
    private static final String S_XALAN_PREFIX = ""org.apache.xslt."";
    private static final int S_XALAN_PREFIX_LEN = S_XALAN_PREFIX.length();

    
    private static final Class[] NO_CLASSES = new Class[0];
    
    private static Integer m_synch_object = new Integer(1);
    
    private static final Object[] NO_OBJS = new Object[0];

    
    private static final String PROP_DIR = ""org/apache/xml/serializer/"";
    
    private static final String PROP_FILE_XML = ""output_xml.properties"";
    
    private static final String PROP_FILE_TEXT = ""output_text.properties"";
    
    private static final String PROP_FILE_HTML = ""output_html.properties"";
    
    private static final String PROP_FILE_UNKNOWN = ""output_unknown.properties"";

    
    
    

    
    private static Properties m_xml_properties = null;

    
    private static Properties m_html_properties = null;

    
    private static Properties m_text_properties = null;

    
    private static Properties m_unknown_properties = null;

    
    static public Properties getDefaultMethodProperties(String method)
    {
        String fileName = null;
        Properties defaultProperties = null;
        
        
        try
        {
            synchronized (m_synch_object)
            {
                if (null == m_xml_properties) 
                {
                    fileName = PROP_FILE_XML;
                    m_xml_properties = loadPropertiesFile(fileName, null);
                }
            }

            if (method.equals(Method.XML))
            {
                defaultProperties = m_xml_properties;
            }
            else if (method.equals(Method.HTML))
            {
                if (null == m_html_properties) 
                {
                    fileName = PROP_FILE_HTML;
                    m_html_properties =
                        loadPropertiesFile(fileName, m_xml_properties);
                }

                defaultProperties = m_html_properties;
            }
            else if (method.equals(Method.TEXT))
            {
                if (null == m_text_properties) 
                {
                    fileName = PROP_FILE_TEXT;
                    m_text_properties =
                        loadPropertiesFile(fileName, m_xml_properties);
                    if (null
                        == m_text_properties.getProperty(OutputKeys.ENCODING))
                    {
                        String mimeEncoding = Encodings.getMimeEncoding(null);
                        m_text_properties.put(
                            OutputKeys.ENCODING,
                            mimeEncoding);
                    }
                }

                defaultProperties = m_text_properties;
            }
            else if (method.equals(org.apache.xml.serializer.Method.UNKNOWN))
            {
                if (null == m_unknown_properties) 
                {
                    fileName = PROP_FILE_UNKNOWN;
                    m_unknown_properties =
                        loadPropertiesFile(fileName, m_xml_properties);
                }
                defaultProperties = m_unknown_properties;
            }
            else
            {

                
                defaultProperties = m_xml_properties;
            }
        }
        catch (IOException ioe)
        {
            throw new WrappedRuntimeException(
                XMLMessages.createXMLMessage(
                    XMLErrorResources.ER_COULD_NOT_LOAD_METHOD_PROPERTY,
                    new Object[] { fileName, method }),
                ioe);
        }

        return defaultProperties;
    }

    
    static private Properties loadPropertiesFile(
        final String resourceName,
        Properties defaults)
        throws IOException
    {

        
        
        

        Properties props = new Properties(defaults);

        InputStream is = null;
        BufferedInputStream bis = null;
        Class accessControllerClass = null;

        try
        {
            try
            {
                try
                {

                    
                    
                    
                    
                    
                    

                    accessControllerClass =
                        Class.forName(""java.security.AccessController"");

                    
                    
                    

                    is =
                        (
                            InputStream) java
                                .security
                                .AccessController
                                .doPrivileged(
                                    new java
                                    .security
                                    .PrivilegedAction()
                    {

                        public Object run()
                        {
                            try
                            {
                                java.lang.reflect.Method getCCL =
                                    Thread.class.getMethod(
                                        ""getContextClassLoader"",
                                        NO_CLASSES);
                                if (getCCL != null)
                                {
                                    ClassLoader contextClassLoader =
                                        (ClassLoader) getCCL.invoke(
                                            Thread.currentThread(),
                                            NO_OBJS);
                                    return (
                                        contextClassLoader.getResourceAsStream(
                                            PROP_DIR + resourceName));
                                }
                            }
                            catch (Exception e)
                            {
                            }

                            return null;

                        }
                    });
                }
                catch (ClassNotFoundException e)
                {
                    
                    
                    try
                    {
                        java.lang.reflect.Method getCCL =
                            Thread.class.getMethod(
                                ""getContextClassLoader"",
                                NO_CLASSES);
                        if (getCCL != null)
                        {
                            ClassLoader contextClassLoader =
                                (ClassLoader) getCCL.invoke(
                                    Thread.currentThread(),
                                    NO_OBJS);
                            is =
                                contextClassLoader.getResourceAsStream(
                                    PROP_DIR + resourceName);
                        }
                    }
                    catch (Exception exception)
                    {
                    }
                }
            }
            catch (Exception e)
            {
            }

            if (is == null)
            {
                if (accessControllerClass != null)
                {
                    is =
                        (
                            InputStream) java
                                .security
                                .AccessController
                                .doPrivileged(
                                    new java
                                    .security
                                    .PrivilegedAction()
                    {
                        public Object run()
                        {
                            return OutputPropertiesFactory
                                .class
                                .getResourceAsStream(
                                resourceName);
                        }
                    });
                }
                else
                {
                    
                    is =
                        OutputPropertiesFactory.class.getResourceAsStream(
                            resourceName);
                }
            }

            bis = new BufferedInputStream(is);
            props.load(bis);
        }
        catch (IOException ioe)
        {
            if (defaults == null)
            {
                throw ioe;
            }
            else
            {
                throw new WrappedRuntimeException(
                    XMLMessages.createXMLMessage(
                        XMLErrorResources.ER_COULD_NOT_LOAD_RESOURCE,
                        new Object[] { resourceName }),
                    ioe);
                
            }
        }
        catch (SecurityException se)
        {
            
            if (defaults == null)
            {
                throw se;
            }
            else
            {
                throw new WrappedRuntimeException(
                    XMLMessages.createXMLMessage(
                        XMLErrorResources.ER_COULD_NOT_LOAD_RESOURCE,
                        new Object[] { resourceName }),
                    se);
                
            }
        }
        finally
        {
            if (bis != null)
            {
                bis.close();
            }
            if (is != null)
            {
                is.close();
            }
        }

        
        
        
        
        
        
        
        
        
        
        
        
        

        Enumeration keys = ((Properties) props.clone()).keys();
        while (keys.hasMoreElements())
        {
            String key = (String) keys.nextElement();
            
            
            
            String value = null;
            try
            {
                value = System.getProperty(key);
            }
            catch (SecurityException se)
            {
                
            }
            if (value == null)
                value = (String) props.get(key);

            String newKey = fixupPropertyString(key, true);
            String newValue = null;
            try
            {
                newValue = System.getProperty(newKey);
            }
            catch (SecurityException se)
            {
                
            }
            if (newValue == null)
                newValue = fixupPropertyString(value, false);
            else
                newValue = fixupPropertyString(newValue, false);

            if (key != newKey || value != newValue)
            {
                props.remove(key);
                props.put(newKey, newValue);
            }

        }

        return props;
    }

    
    static private String fixupPropertyString(String s, boolean doClipping)
    {
        int index;
        if (doClipping && s.startsWith(S_XSLT_PREFIX))
        {
            s = s.substring(S_XSLT_PREFIX_LEN);
        }
        if (s.startsWith(S_XALAN_PREFIX))
        {
            s =
                S_BUILTIN_EXTENSIONS_UNIVERSAL
                    + s.substring(S_XALAN_PREFIX_LEN);
        }
        if ((index = s.indexOf(""\u003a"")) > 0)
        {
            String temp = s.substring(index + 6);
            s = s.substring(0, index) + "":"" + temp;

        }
        return s;
    }

}
"
org.apache.xpath.axes.SelfIteratorNoPredicate,5,5,0,8,8,10,3,5,4,2.0,57,0.0,0,0.9765625,0.45,1,4,10.4,4,1.2,1,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.Compiler;


public class SelfIteratorNoPredicate extends LocPathIterator
{

  
  SelfIteratorNoPredicate(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, false);
  }
  
  
  public SelfIteratorNoPredicate()
          throws javax.xml.transform.TransformerException
  {
    super(null);
  }


  
  public int nextNode()
  {
    if (m_foundLast)
      return DTM.NULL;
      
    int next;
    DTM dtm = m_cdtm;

    m_lastFetched = next = (DTM.NULL == m_lastFetched)
                           ? m_context
                           : DTM.NULL;

    
    if (DTM.NULL != next)
    {
      m_pos++;

      return next;
    }
    else
    {
      m_foundLast = true;

      return DTM.NULL;
    }
  }
  
  
  public int asNode(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
    return xctxt.getCurrentNode();
  }
  
  
  public int getLastPos(XPathContext xctxt)
  {
    return 1;
  }


}"
org.apache.xalan.xsltc.dom.XSLTCDTMManager,6,3,0,20,37,15,10,11,5,1.133333333,273,1.0,0,0.897435897,0.56,1,4,44.0,16,3.1667,0,"
package org.apache.xalan.xsltc.dom;

import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMException;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.dtm.ref.DTMManagerDefault;
import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xalan.xsltc.trax.DOM2SAX;

import org.xml.sax.InputSource;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.XMLReader;


public class XSLTCDTMManager extends DTMManagerDefault
{
	
    
    private static String defaultClassName =
        ""org.apache.xalan.xsltc.dom.XSLTCDTMManager"";

    
    private static final boolean DUMPTREE = false;
  
    
    private static final boolean DEBUG = false;


    
    public XSLTCDTMManager()
    {
        super();
    } 
  
    
    public static XSLTCDTMManager newInstance()
    {
        XSLTCDTMManager factoryImpl = new XSLTCDTMManager();
        return factoryImpl;
    } 

    
    public DTM getDTM(Source source, boolean unique,
                      DTMWSFilter whiteSpaceFilter, boolean incremental,
                      boolean doIndexing)
    {
        return getDTM(source, unique, whiteSpaceFilter, incremental,
                      doIndexing, false, 0, true);
    }

    
    public DTM getDTM(Source source, boolean unique,
                      DTMWSFilter whiteSpaceFilter, boolean incremental,
                      boolean doIndexing, boolean buildIdIndex)
    {
        return getDTM(source, unique, whiteSpaceFilter, incremental,
                      doIndexing, false, 0, buildIdIndex);
    }
  
    
    public DTM getDTM(Source source, boolean unique,
                      DTMWSFilter whiteSpaceFilter, boolean incremental,
                      boolean doIndexing, boolean hasUserReader, int size,
                      boolean buildIdIndex)
    {
        if(DEBUG && null != source) {
            System.out.println(""Starting ""+
			 (unique ? ""UNIQUE"" : ""shared"")+
			 "" source: ""+source.getSystemId());
        }

        int dtmPos = getFirstFreeDTMID();
        int documentID = dtmPos << IDENT_DTM_NODE_BITS;

        if ((null != source) && source instanceof DOMSource)
        {
            final DOMSource domsrc = (DOMSource) source;
            final org.w3c.dom.Node node = domsrc.getNode();
            final DOM2SAX dom2sax = new DOM2SAX(node);
      
            SAXImpl dtm;

            if (size <= 0) {
                dtm = new SAXImpl(this, source, documentID,
                          whiteSpaceFilter, null, doIndexing, buildIdIndex);
            } else {
                dtm = new SAXImpl(this, source, documentID,
                          whiteSpaceFilter, null, doIndexing, size, buildIdIndex);
            }
      
            dtm.setDocumentURI(source.getSystemId());

            addDTM(dtm, dtmPos, 0);
      
            dom2sax.setContentHandler(dtm);
      
            try {
                dom2sax.parse();
            }
            catch (RuntimeException re) {
                throw re;
            }
            catch (Exception e) {
                throw new org.apache.xml.utils.WrappedRuntimeException(e);
            }
      
            return dtm;
        }
        else
        {
            boolean isSAXSource = (null != source)
                                  ? (source instanceof SAXSource) : true;
            boolean isStreamSource = (null != source)
                                  ? (source instanceof StreamSource) : false;

            if (isSAXSource || isStreamSource) {
                XMLReader reader;
                InputSource xmlSource;

                if (null == source) {
                    xmlSource = null;
                    reader = null;
                    hasUserReader = false;  
                }
                else {
                    reader = getXMLReader(source);
                    xmlSource = SAXSource.sourceToInputSource(source);

                    String urlOfSource = xmlSource.getSystemId();

                    if (null != urlOfSource) {
                        try {
                            urlOfSource = SystemIDResolver.getAbsoluteURI(urlOfSource);
                        }
                        catch (Exception e) {
                            
                            System.err.println(""Can not absolutize URL: "" + urlOfSource);
                        }

                        xmlSource.setSystemId(urlOfSource);
                    }
                }

                
                SAXImpl dtm;
                if (size <= 0) {
                    dtm = new SAXImpl(this, source, documentID, whiteSpaceFilter,
                                      null, doIndexing, buildIdIndex);
                } else {
                    dtm = new SAXImpl(this, source, documentID, whiteSpaceFilter,
                                      null, doIndexing, size, buildIdIndex);
                }

                
                
                
                addDTM(dtm, dtmPos, 0);

                if (null == reader) {
                    
                    return dtm;
                }

                reader.setContentHandler(dtm.getBuilder());
                
                if (!hasUserReader || null == reader.getDTDHandler()) {
                    reader.setDTDHandler(dtm);
                }
                
                if(!hasUserReader || null == reader.getErrorHandler()) {
                    reader.setErrorHandler(dtm);
                }

                try {
                    reader.setProperty(""http:
                }
                catch (SAXNotRecognizedException e){}
                catch (SAXNotSupportedException e){}

                try {
                    reader.parse(xmlSource);
                }
                catch (RuntimeException re) {
                    throw re;
                }
                catch (Exception e) {
                    throw new org.apache.xml.utils.WrappedRuntimeException(e);
                }

                if (DUMPTREE) {
                    System.out.println(""Dumping SAX2DOM"");
                    dtm.dumpDTM(System.err);
                }

                return dtm;
            }
            else {
                
                
                throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_NOT_SUPPORTED, new Object[]{source}));
            }
        }
    }
}
"
org.apache.xalan.xsltc.trax.SAX2DOM,21,1,0,2,52,126,1,1,21,0.7625,322,1.0,0,0.0,0.265306122,0,0,14.14285714,7,1.381,0,"


package org.apache.xalan.xsltc.trax;

import java.util.Stack;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.xalan.xsltc.runtime.Constants;

import org.w3c.dom.Comment;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.ProcessingInstruction;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;

public class SAX2DOM implements ContentHandler, LexicalHandler, Constants {

    private Node _root = null;
    private Document _document = null;
    private Stack _nodeStk = new Stack();
    private Vector _namespaceDecls = null;

    public SAX2DOM() throws ParserConfigurationException {
	final DocumentBuilderFactory factory = 
		DocumentBuilderFactory.newInstance();
	_document = factory.newDocumentBuilder().newDocument();
	_root = _document;
    }

    public SAX2DOM(Node root) throws ParserConfigurationException {
	_root = root;
	if (root instanceof Document) {
	  _document = (Document)root;
	}
	else if (root != null) {
	  _document = root.getOwnerDocument();
	}
	else {
	  final DocumentBuilderFactory factory = 
		DocumentBuilderFactory.newInstance();
	  _document = factory.newDocumentBuilder().newDocument();
	  _root = _document;
	}
    }

    public Node getDOM() {
	return _root;
    }

    public void characters(char[] ch, int start, int length) {
	final Node last = (Node)_nodeStk.peek();

	
	if (last != _document) {
	    final String text = new String(ch, start, length);
	    last.appendChild(_document.createTextNode(text));
	}
    }

    public void startDocument() {
	_nodeStk.push(_root);
    }

    public void endDocument() {
        _nodeStk.pop();
    }

    public void startElement(String namespace, String localName, String qName,
	Attributes attrs) 
    {
	final Element tmp = (Element)_document.createElementNS(namespace, qName);

	
	if (_namespaceDecls != null) {
	    final int nDecls = _namespaceDecls.size();
	    for (int i = 0; i < nDecls; i++) {
		final String prefix = (String) _namespaceDecls.elementAt(i++);

		if (prefix == null || prefix.equals(EMPTYSTRING)) {
		    tmp.setAttributeNS(XMLNS_URI, XMLNS_PREFIX,
			(String) _namespaceDecls.elementAt(i));
		}
		else {
		    tmp.setAttributeNS(XMLNS_URI, XMLNS_STRING + prefix, 
			(String) _namespaceDecls.elementAt(i));
		}
	    }
	    _namespaceDecls.clear();
	}

	
	final int nattrs = attrs.getLength();
	for (int i = 0; i < nattrs; i++) {
	    if (attrs.getLocalName(i) == null) {
		tmp.setAttribute(attrs.getQName(i), attrs.getValue(i));
	    }
	    else {
		tmp.setAttributeNS(attrs.getURI(i), attrs.getQName(i), 
		    attrs.getValue(i));
	    }
	}

	
	Node last = (Node)_nodeStk.peek();
	last.appendChild(tmp);

	
	_nodeStk.push(tmp);
    }

    public void endElement(String namespace, String localName, String qName) {
	_nodeStk.pop();  
    }

    public void startPrefixMapping(String prefix, String uri) {
	if (_namespaceDecls == null) {
	    _namespaceDecls = new Vector(2);
	}
	_namespaceDecls.addElement(prefix);
	_namespaceDecls.addElement(uri);
    }

    public void endPrefixMapping(String prefix) {
	
    }

    
    public void ignorableWhitespace(char[] ch, int start, int length) {
    }

    
    public void processingInstruction(String target, String data) {
	final Node last = (Node)_nodeStk.peek();
	ProcessingInstruction pi = _document.createProcessingInstruction(
		target, data);
	if (pi != null)  last.appendChild(pi);
    }

    
    public void setDocumentLocator(Locator locator) {
    }

    
    public void skippedEntity(String name) {
    }


    
    public void comment(char[] ch, int start, int length) {
	final Node last = (Node)_nodeStk.peek();
	Comment comment = _document.createComment(new String(ch,start,length));
	if (comment != null) last.appendChild(comment);
    }

    
    public void startCDATA() { }
    public void endCDATA() { }
    public void startEntity(java.lang.String name) { }
    public void endDTD() { }
    public void endEntity(String name) { }
    public void startDTD(String name, String publicId, String systemId)
        throws SAXException { }

}
"
org.apache.xalan.xsltc.compiler.util.MethodGenerator,27,4,6,137,49,311,122,15,27,0.978632479,432,1.0,1,0.788617886,0.159259259,1,2,14.0,4,1.2963,1,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ICONST;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.MethodGen;
import org.apache.bcel.generic.Type;

public class MethodGenerator extends MethodGen
    implements org.apache.xalan.xsltc.compiler.Constants {
    protected static final int INVALID_INDEX   = -1;
    
    private static final String START_ELEMENT_SIG   
	= ""("" + STRING_SIG + "")V"";
    private static final String END_ELEMENT_SIG     
	= START_ELEMENT_SIG;
    
    private InstructionList _mapTypeSub;
	
    private static final int DOM_INDEX       = 1;
    private static final int ITERATOR_INDEX  = 2;
    private static final int HANDLER_INDEX   = 3;

    private Instruction       _iloadCurrent;
    private Instruction       _istoreCurrent;
    private final Instruction _astoreHandler;
    private final Instruction _aloadHandler;
    private final Instruction _astoreIterator;
    private final Instruction _aloadIterator;
    private final Instruction _aloadDom;
    private final Instruction _astoreDom;
    
    private final Instruction _startElement;
    private final Instruction _endElement;
    private final Instruction _startDocument;
    private final Instruction _endDocument;
    private final Instruction _attribute;
    private final Instruction _namespace;

    private final Instruction _setStartNode;
    private final Instruction _reset;
    private final Instruction _nextNode;
    private final Instruction _nextNodeId;

    private SlotAllocator _slotAllocator;
    private boolean _allocatorInit = false;
    
    public MethodGenerator(int access_flags, Type return_type,
			   Type[] arg_types, String[] arg_names,
			   String method_name, String class_name,
			   InstructionList il, ConstantPoolGen cpg) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cpg);
	
	_astoreHandler  = new ASTORE(HANDLER_INDEX);
	_aloadHandler   = new ALOAD(HANDLER_INDEX);
	_astoreIterator = new ASTORE(ITERATOR_INDEX);
	_aloadIterator  = new ALOAD(ITERATOR_INDEX);
	_aloadDom       = new ALOAD(DOM_INDEX);
	_astoreDom      = new ASTORE(DOM_INDEX);
	
	final int startElement =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""startElement"",
				      START_ELEMENT_SIG);
	_startElement = new INVOKEINTERFACE(startElement, 2);
	
	final int endElement =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""endElement"",
				      END_ELEMENT_SIG);
	_endElement = new INVOKEINTERFACE(endElement, 2);

	final int attribute =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""addAttribute"", 
				      ""(""
				      + STRING_SIG
				      + STRING_SIG
				      + "")V"");
	_attribute = new INVOKEINTERFACE(attribute, 3);

	final int namespace =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""namespaceAfterStartElement"", 
				      ""(""
				      + STRING_SIG
				      + STRING_SIG
				      + "")V"");
	_namespace = new INVOKEINTERFACE(namespace, 3);
	
	int index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
					      ""startDocument"",
					      ""()V"");
	_startDocument = new INVOKEINTERFACE(index, 1);
	
	index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
					  ""endDocument"",
					  ""()V"");
	_endDocument = new INVOKEINTERFACE(index, 1);
	
	
	index = cpg.addInterfaceMethodref(NODE_ITERATOR,
					  SET_START_NODE,
					  SET_START_NODE_SIG);
	_setStartNode = new INVOKEINTERFACE(index, 2);

	index = cpg.addInterfaceMethodref(NODE_ITERATOR,
					  ""reset"", ""()""+NODE_ITERATOR_SIG);
	_reset = new INVOKEINTERFACE(index, 1);
	
	index = cpg.addInterfaceMethodref(NODE_ITERATOR, NEXT, NEXT_SIG);
	_nextNode = new INVOKEINTERFACE(index, 1);
	
	index = cpg.addInterfaceMethodref(""org.apache.xalan.xsltc.dom.SAXImpl$SingletonNodeIDIterator"", NEXTID, NEXT_SIG);
	_nextNodeId = new INVOKEINTERFACE(index, 1);
	
	_slotAllocator = new SlotAllocator();
	_slotAllocator.initialize(getLocalVariables());
	_allocatorInit = true;
    }

    
    public LocalVariableGen addLocalVariable(String name, Type type,
					     InstructionHandle start,
					     InstructionHandle end) 
    {
	return (_allocatorInit) ? addLocalVariable2(name, type, start) 
	    : super.addLocalVariable(name, type, start, end);
    }
    
    public LocalVariableGen addLocalVariable2(String name, Type type,
					      InstructionHandle start) 
    {
	return super.addLocalVariable(name, type,
				      _slotAllocator.allocateSlot(type),
				      start, null);
    }

    public void removeLocalVariable(LocalVariableGen lvg) {
	_slotAllocator.releaseSlot(lvg);
	super.removeLocalVariable(lvg);
    }

    public Instruction loadDOM() {
	return _aloadDom;
    }

    public Instruction storeDOM() {
	return _astoreDom;
    }
    
    public Instruction storeHandler() {
	return _astoreHandler;
    }

    public Instruction loadHandler() {
	return _aloadHandler;
    }

    public Instruction storeIterator() {
	return _astoreIterator;
    }
    
    public Instruction loadIterator() {
	return _aloadIterator;
    }
    
    public final Instruction setStartNode() {
	return _setStartNode;
    }

    public final Instruction reset() {
	return _reset;
    }
    
    public final Instruction nextNode() {
	return _nextNode;
    }
    
    public final Instruction nextNodeId() {
	return _nextNodeId;
    }
    
    public final Instruction startElement() {
	return _startElement;
    }

    public final Instruction endElement() {
	return _endElement;
    }

    public final Instruction startDocument() {
	return _startDocument;
    }

    public final Instruction endDocument() {
	return _endDocument;
    }

    public final Instruction attribute() {
	return _attribute;
    }

    public final Instruction namespace() {
	return _namespace;
    }

    public Instruction loadCurrentNode() {
	if (_iloadCurrent == null) {
	    int idx = getLocalIndex(""current"");
	    if (idx > 0)
		_iloadCurrent = new ILOAD(idx);
	    else
		_iloadCurrent = new ICONST(0);
	}
	return _iloadCurrent;
    }

    public Instruction storeCurrentNode() {
	return _istoreCurrent != null
	    ? _istoreCurrent
	    : (_istoreCurrent = new ISTORE(getLocalIndex(""current"")));
    }

    
    public Instruction loadContextNode() {
	return loadCurrentNode();
    }

    public Instruction storeContextNode() {
	return storeCurrentNode();
    }

    public int getLocalIndex(String name) {
	return getLocalVariable(name).getIndex();
    }

    public LocalVariableGen getLocalVariable(String name) {
	final LocalVariableGen[] vars = getLocalVariables();
	for (int i = 0; i < vars.length; i++)
	    if (vars[i].getName().equals(name))
		return vars[i];
	return null;	
    }

    public void setMaxLocals() {
	
	
	int maxLocals = super.getMaxLocals();
	int prevLocals = maxLocals;

	
	final LocalVariableGen[] localVars = super.getLocalVariables();
	if (localVars != null) {
	    if (localVars.length > maxLocals)
		maxLocals = localVars.length;
	}

	
	if (maxLocals < 5) maxLocals = 5;

	super.setMaxLocals(maxLocals);
    }

}
"
org.apache.xml.serializer.SerializationHandler,9,1,0,47,9,36,41,6,9,2.0,9,0.0,0,0.0,0.238095238,0,0,0.0,1,1.0,0,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.Writer;
import java.util.Properties;
import java.util.Vector;

import javax.xml.transform.Transformer;

import org.apache.xml.serializer.Serializer;
import org.w3c.dom.Node;
import org.xml.sax.ContentHandler;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.ext.DeclHandler;


public interface SerializationHandler
    extends
        ExtendedContentHandler,
        ExtendedLexicalHandler,
        XSLOutputAttributes,
        DeclHandler,
        ErrorHandler,
        DOMSerializer,
        Serializer
{
    
    public void setContentHandler(ContentHandler ch);
    
    public void close();

    
    public void serialize(Node node) throws IOException;
    
    public boolean setEscaping(boolean escape) throws SAXException;

    
    public void setIndentAmount(int spaces);

    
    public void setTransformer(Transformer transformer);
    
    
    public Transformer getTransformer();

    
    public void setNamespaceMappings(NamespaceMappings mappings);

    
    public void flushPending();


}
"
org.apache.xpath.functions.FuncBoolean,2,4,0,5,5,1,0,5,2,2.0,15,0.0,0,0.979591837,0.75,1,6,6.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class FuncBoolean extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return m_arg0.execute(xctxt).bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
  
}
"
org.apache.xpath.patterns.NodeTestFilter,1,1,0,1,1,0,0,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xpath.patterns;


public interface NodeTestFilter
{

  
  void setNodeTest(NodeTest nodeTest);
}
"
org.apache.xalan.xsltc.compiler.LangCall,4,4,0,17,17,0,0,17,4,0.666666667,84,1.0,2,0.96969697,0.375,3,8,19.5,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.FilterGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.StringType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class LangCall extends FunctionCall {
    private Expression _lang;
    private Type _langType;

    
    public LangCall(QName fname, Vector arguments) {
	super(fname, arguments);
	_lang = argument(0);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_langType = _lang.typeCheck(stable);
	if (!(_langType instanceof StringType)) {
	    _lang = new CastExpr(_lang, Type.String);
	}
	return Type.Boolean;
    }

    
    public Type getType() {
	return(Type.Boolean);
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final int tst = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					 ""testLanguage"",
					 ""(""+STRING_SIG+DOM_INTF_SIG+""I)Z"");
	_lang.translate(classGen,methodGen);
	il.append(methodGen.loadDOM());
	if (classGen instanceof FilterGenerator)
	    il.append(new ILOAD(1));
	else
	    il.append(methodGen.loadContextNode());
	il.append(new INVOKESTATIC(tst));
    }
}
"
org.apache.xalan.xsltc.dom.FilterIterator,9,2,0,4,24,0,0,4,9,0.625,109,1.0,2,0.619047619,0.288888889,1,6,10.77777778,3,1.2222,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.ref.DTMAxisIteratorBase;


public final class FilterIterator extends DTMAxisIteratorBase {

    
    private DTMAxisIterator _source;

    
    private final DTMFilter _filter;

    
    private final boolean _isReverse;
	
    public FilterIterator(DTMAxisIterator source, DTMFilter filter) {
	_source = source;

	_filter = filter;
	_isReverse = source.isReverse();
    }

    public boolean isReverse() {
	return _isReverse;
    }


    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }

    public DTMAxisIterator cloneIterator() {

	try {
	    final FilterIterator clone = (FilterIterator) super.clone();
	    clone._source = _source.cloneIterator();
	    clone._isRestartable = false;
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public DTMAxisIterator reset() {
	_source.reset();
	return resetPosition();
    }
    
    public int next() {
	int node;
	while ((node = _source.next()) != END) {
	    if (_filter.acceptNode(node, DTMFilter.SHOW_ALL) == DTMIterator.FILTER_ACCEPT) {
		return returnNode(node);
	    }
	}
	return END;
    }

    public DTMAxisIterator setStartNode(int node) {
	if (_isRestartable) {
	    _source.setStartNode(_startNode = node); 
	    return resetPosition();
	}
	return this;
    }

    public void setMark() {
	_source.setMark();
    }

    public void gotoMark() {
	_source.gotoMark();
    }

}
"
org.apache.xalan.xsltc.compiler.RelativePathPattern,1,5,3,7,2,0,6,1,0,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"

package org.apache.xalan.xsltc.compiler;

abstract class RelativePathPattern extends LocationPathPattern {}
"
org.apache.xpath.axes.AxesWalker,27,4,2,21,53,257,8,15,23,0.802884615,454,0.625,4,0.747572816,0.138888889,1,4,15.51851852,5,1.5926,0,"
package org.apache.xpath.axes;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.res.XPATHErrorResources;


public class AxesWalker extends PredicatedNodeTest
        implements Cloneable, PathComponent, ExpressionOwner
{
  
  
  public AxesWalker(LocPathIterator locPathIterator, int axis)
  {
    super( locPathIterator );
    m_axis = axis;
  }
  
  public final WalkingIterator wi()
  {
    return (WalkingIterator)m_lpi;
  }

  
  public void init(Compiler compiler, int opPos, int stepType)
          throws javax.xml.transform.TransformerException
  {

    initPredicateInfo(compiler, opPos);

    
  }

  
  public Object clone() throws CloneNotSupportedException
  {
    
    
    AxesWalker clone = (AxesWalker) super.clone();

    

    

    return clone;
  }
  
  
  AxesWalker cloneDeep(WalkingIterator cloneOwner, Vector cloneList)
     throws CloneNotSupportedException
  {
    AxesWalker clone = findClone(this, cloneList);
    if(null != clone)
      return clone;
    clone = (AxesWalker)this.clone();
    clone.setLocPathIterator(cloneOwner);
    if(null != cloneList)
    {
      cloneList.addElement(this);
      cloneList.addElement(clone);
    }
    
    if(wi().m_lastUsedWalker == this)
      cloneOwner.m_lastUsedWalker = clone;
      
    if(null != m_nextWalker)
      clone.m_nextWalker = m_nextWalker.cloneDeep(cloneOwner, cloneList);
      
    
    
    if(null != cloneList)
    {
      if(null != m_prevWalker)
        clone.m_prevWalker = m_prevWalker.cloneDeep(cloneOwner, cloneList);
    }
    else
    {
      if(null != m_nextWalker)
        clone.m_nextWalker.m_prevWalker = clone;
    }
    return clone;
  }
  
  
  static AxesWalker findClone(AxesWalker key, Vector cloneList)
  {
    if(null != cloneList)
    {
      
      int n = cloneList.size();
      for (int i = 0; i < n; i+=2) 
      {
        if(key == cloneList.elementAt(i))
          return (AxesWalker)cloneList.elementAt(i+1);
      }
    }
    return null;    
  }
  
  
  public void detach()
  { 
  	m_currentNode = DTM.NULL;
  	m_dtm = null;
  	m_traverser = null;
  	m_isFresh = true;
  	m_root = DTM.NULL;
  }
  
  

  
  public int getRoot()
  {
    return m_root;
  }
  
  
  public int getAnalysisBits()
  {
  	int axis = getAxis();
  	int bit = WalkerFactory.getAnalysisBitFromAxes(axis);
  	return bit;
  }

  
  public void setRoot(int root)
  {
    
    XPathContext xctxt = wi().getXPathContext();
    m_dtm = xctxt.getDTM(root);
    m_traverser = m_dtm.getAxisTraverser(m_axis);
    m_isFresh = true;
    m_foundLast = false;
    m_root = root;
    m_currentNode = root;

    if (DTM.NULL == root)
    {
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_SETTING_WALKER_ROOT_TO_NULL, null)); 
 !!!! Error! Setting the root of a walker to null!!!"");
    }

    resetProximityPositions();
  }

  
  public final int getCurrentNode()
  {
    return m_currentNode;
  }

  
  public void setNextWalker(AxesWalker walker)
  {
    m_nextWalker = walker;
  }

  
  public AxesWalker getNextWalker()
  {
    return m_nextWalker;
  }

  
  public void setPrevWalker(AxesWalker walker)
  {
    m_prevWalker = walker;
  }

  
  public AxesWalker getPrevWalker()
  {
    return m_prevWalker;
  }

  
  private int returnNextNode(int n)
  {

    return n;
  }

  
  protected int getNextNode()
  {
    if (m_foundLast)
      return DTM.NULL;

    if (m_isFresh)
    {
      m_currentNode = m_traverser.first(m_root);
      m_isFresh = false;
    }
    
    
umbering24.xsl fails if I don't do this.  I think 
    
    else if(DTM.NULL != m_currentNode) 
    {
      m_currentNode = m_traverser.next(m_root, m_currentNode);
    }

    if (DTM.NULL == m_currentNode)
      this.m_foundLast = true;

    return m_currentNode;
  }

  
  public int nextNode()
  {
    int nextNode = DTM.NULL;
    AxesWalker walker = wi().getLastUsedWalker();

    while (true)
    {
      if (null == walker)
        break;

      nextNode = walker.getNextNode();

      if (DTM.NULL == nextNode)
      {

        walker = walker.m_prevWalker;
      }
      else
      {
        if (walker.acceptNode(nextNode) != DTMIterator.FILTER_ACCEPT)
        {
          continue;
        }

        if (null == walker.m_nextWalker)
        {
          wi().setLastUsedWalker(walker);

          
          break;
        }
        else
        {
          AxesWalker prev = walker;

          walker = walker.m_nextWalker;

          walker.setRoot(nextNode);

          walker.m_prevWalker = prev;

          continue;
        }
      }  
    }  

    return nextNode;
  }

  

  
  public int getLastPos(XPathContext xctxt)
  {

    int pos = getProximityPosition();
    
    AxesWalker walker;

    try
    {
      walker = (AxesWalker) clone();
    }
    catch (CloneNotSupportedException cnse)
    {
      return -1;
    }

    walker.setPredicateCount(walker.getPredicateCount() - 1);
    walker.setNextWalker(null);
    walker.setPrevWalker(null);

    WalkingIterator lpi = wi();
    AxesWalker savedWalker = lpi.getLastUsedWalker();

    try
    {
      lpi.setLastUsedWalker(walker);

      int next;

      while (DTM.NULL != (next = walker.nextNode()))
      {
        pos++;
      }

      
    }
    finally
    {
      lpi.setLastUsedWalker(savedWalker);
    }

    
    return pos;
  }
  
  
  
  
  private DTM m_dtm;
  
  
  public void setDefaultDTM(DTM dtm)
  {
    m_dtm = dtm;
  }
  
  
  public DTM getDTM(int node)
  {
    
    return wi().getXPathContext().getDTM(node);
  }
  
  
  public boolean isDocOrdered()
  {
    return true;
  }
  
  
  public int getAxis()
  {
    return m_axis;
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	if(visitor.visitStep(owner, this))
  	{
  		callPredicateVisitors(visitor);
  		if(null != m_nextWalker)
  		{
  			m_nextWalker.callVisitors(this, visitor);
  		}
  	}
  }
  
  
  public Expression getExpression()
  {
    return m_nextWalker;
  }

  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_nextWalker = (AxesWalker)exp;
  }
  
    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
                return false;

      AxesWalker walker = (AxesWalker)expr;
      if(this.m_axis != walker.m_axis)
      	return false;

      return true;
    }

  
  transient int m_root = DTM.NULL;

  
  private transient int m_currentNode = DTM.NULL;
  
  
  transient boolean m_isFresh;

  
  protected AxesWalker m_nextWalker;
  
  
  AxesWalker m_prevWalker;
  
  
  protected int m_axis = -1;

  
  protected DTMAxisTraverser m_traverser; 
}
"
org.apache.xalan.xsltc.compiler.SimpleAttributeValue,5,4,0,11,10,4,1,11,4,0.5,38,1.0,0,0.947368421,0.36,2,8,6.4,1,0.8,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class SimpleAttributeValue extends AttributeValue {

    private String _value; 

    
    public SimpleAttributeValue(String value) {
	_value = value;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _type = Type.String;
    }
    
    public String toString() {
	return _value;
    }
	
    protected boolean contextDependent() {
	return false;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }
}
"
org.apache.xalan.xsltc.compiler.VariableRef,2,4,0,18,25,1,2,16,2,2.0,137,0.0,0,0.987012987,0.625,2,3,67.5,9,4.5,1,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSetType;

final class VariableRef extends VariableRefBase {

    public VariableRef(Variable variable) {
	super(variable);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	if (_type.implementedAsMethod()) return;

	final String name = _variable.getVariable();
	final String signature = _type.toSignature();

	if (_variable.isLocal()) {
	    if (classGen.isExternal()) {
		Closure variableClosure = _closure;
		while (variableClosure != null) {
		    if (variableClosure.inInnerClass()) break;
		    variableClosure = variableClosure.getParentClosure();
		}
	    
		if (variableClosure != null) {
		    il.append(ALOAD_0);
		    il.append(new GETFIELD(
			cpg.addFieldref(variableClosure.getInnerClassName(), 
			    name, signature)));
		}
		else {
		    il.append(_variable.loadInstruction());
		    _variable.removeReference(this);
		}
	    }
	    else {
		il.append(_variable.loadInstruction());
		_variable.removeReference(this);
	    }
	}
	else {
	    final String className = classGen.getClassName();
	    il.append(classGen.loadTranslet());
	    if (classGen.isExternal()) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }
	    il.append(new GETFIELD(cpg.addFieldref(className,name,signature)));
	}

	if (_variable.getType() instanceof NodeSetType) {
	    
	    final int clone = cpg.addInterfaceMethodref(NODE_ITERATOR,
						       ""cloneIterator"",
						       ""()"" + 
							NODE_ITERATOR_SIG);
	    il.append(new INVOKEINTERFACE(clone, 1));
	}
    }
}
"
org.apache.xalan.xsltc.compiler.Message,4,3,0,19,26,0,0,19,3,0.333333333,311,1.0,0,0.949152542,0.4,2,6,76.5,6,2.25,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class Message extends Instruction {
    private boolean _terminate = false;

    public void parseContents(Parser parser) {
	String termstr = getAttribute(""terminate"");
	if (termstr != null) {
            _terminate = termstr.equals(""yes"");
	}
	parseChildren(parser);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	typeCheckContents(stable);
	return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(classGen.loadTranslet());

        switch (elementCount()) {
            case 0:
                il.append(new PUSH(cpg, """"));
            break;
            case 1:
                SyntaxTreeNode child = (SyntaxTreeNode) elementAt(0);
                if (child instanceof Text) {
                    il.append(new PUSH(cpg, ((Text) child).getText()));
                    break;
                }
                
            default:
                
                il.append(methodGen.loadHandler());

                
                il.append(new NEW(cpg.addClass(STREAM_XML_OUTPUT)));
                il.append(methodGen.storeHandler());

                
                il.append(new NEW(cpg.addClass(STRING_WRITER)));
                il.append(DUP);
                il.append(DUP);
                il.append(new INVOKESPECIAL(
                    cpg.addMethodref(STRING_WRITER, ""<init>"", ""()V"")));

                
                il.append(methodGen.loadHandler());
                il.append(new INVOKESPECIAL(
                    cpg.addMethodref(STREAM_XML_OUTPUT, ""<init>"",
                                     ""()V"")));

                
                il.append(methodGen.loadHandler());
                il.append(SWAP);
                il.append(new INVOKEVIRTUAL(
                    cpg.addMethodref(OUTPUT_BASE, ""setWriter"",
                                     ""(""+WRITER_SIG+"")V"")));

                
                il.append(methodGen.loadHandler());
                il.append(new PUSH(cpg, ""UTF-8""));   
                il.append(new INVOKEVIRTUAL(
                    cpg.addMethodref(OUTPUT_BASE, ""setEncoding"",
                                     ""(""+STRING_SIG+"")V"")));

                
                il.append(methodGen.loadHandler());
                il.append(ICONST_1);
                il.append(new INVOKEVIRTUAL(
                    cpg.addMethodref(OUTPUT_BASE, ""setOmitXMLDeclaration"",
                                     ""(Z)V"")));

                il.append(methodGen.loadHandler());
                il.append(new INVOKEVIRTUAL(
                    cpg.addMethodref(OUTPUT_BASE, ""startDocument"",
                                     ""()V"")));

                
                translateContents(classGen, methodGen);

                il.append(methodGen.loadHandler());
                il.append(new INVOKEVIRTUAL(
                    cpg.addMethodref(OUTPUT_BASE, ""endDocument"",
                                     ""()V"")));

                
                il.append(new INVOKEVIRTUAL(
                    cpg.addMethodref(STRING_WRITER, ""toString"",
                                     ""()"" + STRING_SIG)));

                
                il.append(SWAP);
                il.append(methodGen.storeHandler());
            break;
        }

	
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
						     ""displayMessage"",
						     ""(""+STRING_SIG+"")V"")));

	
	
	if (_terminate == true) {
	    
	    final int einit = cpg.addMethodref(""java.lang.RuntimeException"",
					       ""<init>"",
					       ""(Ljava/lang/String;)V"");
	    il.append(new NEW(cpg.addClass(""java.lang.RuntimeException"")));
	    il.append(DUP);
	    il.append(new PUSH(cpg,""Termination forced by an "" +
			           ""xsl:message instruction""));
	    il.append(new INVOKESPECIAL(einit));
	    il.append(ATHROW);
	}
    }

}
"
org.apache.xpath.compiler.PsuedoNames,1,1,0,0,2,0,0,0,1,2.0,10,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xpath.compiler;


public class PsuedoNames
{

  
  public static final String PSEUDONAME_ANY = ""*"";

  
  public static final String PSEUDONAME_ROOT = ""/"";

  
  public static final String PSEUDONAME_TEXT = ""#text"";

  
  public static final String PSEUDONAME_COMMENT = ""#comment"";

  
  public static final String PSEUDONAME_PI = ""#pi"";

  
  public static final String PSEUDONAME_OTHER = ""*"";
}
"
org.apache.xalan.transformer.TransformerHandlerImpl,36,1,0,10,100,0,2,9,33,0.817582418,914,0.923076923,2,0.0,0.176623377,0,0,24.02777778,7,1.1944,0,"
package org.apache.xalan.transformer;

import java.io.IOException;

import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.sax.TransformerHandler;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.ref.IncrementalSAXSource_Filter;
import org.apache.xml.dtm.ref.sax2dtm.SAX2DTM;
import org.apache.xpath.XPathContext;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.LexicalHandler;
import org.apache.xml.serializer.SerializationHandler;



public class TransformerHandlerImpl
        implements EntityResolver, DTDHandler, ContentHandler, ErrorHandler,
                   LexicalHandler, TransformerHandler, DeclHandler
{
  
  private boolean m_insideParse = false;

  
  
  

  
  public TransformerHandlerImpl(TransformerImpl transformer,
                                boolean doFragment, String baseSystemID)
  {

    super();

    m_transformer = transformer;
    m_baseSystemID = baseSystemID;

    XPathContext xctxt = transformer.getXPathContext();
    DTM dtm = xctxt.getDTM(null, true, transformer, true, true);
    
    m_dtm = dtm;
    dtm.setDocumentBaseURI(baseSystemID);

    m_contentHandler = dtm.getContentHandler();
    m_dtdHandler = dtm.getDTDHandler();
    m_entityResolver = dtm.getEntityResolver();
    m_errorHandler = dtm.getErrorHandler();
    m_lexicalHandler = dtm.getLexicalHandler();
  }
  
  
  protected void clearCoRoutine()
  {
    clearCoRoutine(null);
  }
  
  
  protected void clearCoRoutine(SAXException ex)
  {
    if(null != ex)
      m_transformer.setExceptionThrown(ex);
    
    if(m_dtm instanceof SAX2DTM)
    {
      if(DEBUG)
        System.err.println(""In clearCoRoutine..."");
      try
      {
        SAX2DTM sax2dtm = ((SAX2DTM)m_dtm);          
        if(null != m_contentHandler 
           && m_contentHandler instanceof IncrementalSAXSource_Filter)
        {
          IncrementalSAXSource_Filter sp =
            (IncrementalSAXSource_Filter)m_contentHandler;
          
          sp.deliverMoreNodes(false);
        }
        
        sax2dtm.clearCoRoutine(true);
        m_contentHandler = null;
        m_dtdHandler = null;
        m_entityResolver = null;
        m_errorHandler = null;
        m_lexicalHandler = null;
      }
      catch(Throwable throwable)
      {
        throwable.printStackTrace();
      }
      
      if(DEBUG)
        System.err.println(""...exiting clearCoRoutine"");
    }
  }
  
  
  
  

  
  public void setResult(Result result) throws IllegalArgumentException
  {

    if (null == result)
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_NULL, null)); 

    try
    {



        SerializationHandler xoh = 
            m_transformer.createSerializationHandler(result);
        m_transformer.setSerializationHandler(xoh);
    }
    catch (javax.xml.transform.TransformerException te)
    {
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_COULD_NOT_BE_SET, null)); 
    }

    m_result = result;
  }

  
  public void setSystemId(String systemID)
  {
    m_baseSystemID = systemID;
    m_dtm.setDocumentBaseURI(systemID);
  }

  
  public String getSystemId()
  {
    return m_baseSystemID;
  }

  
  public Transformer getTransformer()
  {
    return m_transformer;
  }

  
  
  

  
  public InputSource resolveEntity(String publicId, String systemId)
          throws SAXException, IOException
  {

    if (m_entityResolver != null)
    {
      return m_entityResolver.resolveEntity(publicId, systemId);
    }
    else
    {
      return null;
    }
  }

  
  
  

  
  public void notationDecl(String name, String publicId, String systemId)
          throws SAXException
  {

    if (m_dtdHandler != null)
    {
      m_dtdHandler.notationDecl(name, publicId, systemId);
    }
  }

  
  public void unparsedEntityDecl(
          String name, String publicId, String systemId, String notationName)
            throws SAXException
  {

    if (m_dtdHandler != null)
    {
      m_dtdHandler.unparsedEntityDecl(name, publicId, systemId, notationName);
    }
  }

  
  
  

  
  public void setDocumentLocator(Locator locator)
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#setDocumentLocator: ""
                         + locator.getSystemId());

    this.m_locator = locator;
    
    if(null == m_baseSystemID)
    {
      setSystemId(locator.getSystemId());
    }

    if (m_contentHandler != null)
    {
      m_contentHandler.setDocumentLocator(locator);
    }
  }

  
  public void startDocument() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startDocument"");
      
    m_insideParse = true;

   

    if (m_contentHandler != null)
    {
      
      if(DTMManager.getIncremental())
      {
        m_transformer.setSourceTreeDocForThread(m_dtm.getDocument());
            
        int cpriority = Thread.currentThread().getPriority();
    
        
        
        m_transformer.runTransformThread( cpriority );
      }

      
      
      
      
      m_contentHandler.startDocument();
   }
        
   
   

  }

  
  public void endDocument() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endDocument"");

    m_insideParse = false;
    
    if (m_contentHandler != null)
    {
      m_contentHandler.endDocument();
    }
    
    if(DTMManager.getIncremental())
    {
      m_transformer.waitTransformThread();
    }
    else
    {
      m_transformer.setSourceTreeDocForThread(m_dtm.getDocument());
      m_transformer.run();
    }
   
  }

  
  public void startPrefixMapping(String prefix, String uri)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startPrefixMapping: ""
                         + prefix + "", "" + uri);

    if (m_contentHandler != null)
    {
      m_contentHandler.startPrefixMapping(prefix, uri);
    }
  }

  
  public void endPrefixMapping(String prefix) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endPrefixMapping: ""
                         + prefix);

    if (m_contentHandler != null)
    {
      m_contentHandler.endPrefixMapping(prefix);
    }
  }

  
  public void startElement(
          String uri, String localName, String qName, Attributes atts)
            throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startElement: "" + qName);

    if (m_contentHandler != null)
    {
      m_contentHandler.startElement(uri, localName, qName, atts);
    }
  }

  
  public void endElement(String uri, String localName, String qName)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endElement: "" + qName);

    if (m_contentHandler != null)
    {
      m_contentHandler.endElement(uri, localName, qName);
    }
  }

  
  public void characters(char ch[], int start, int length) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#characters: "" + start + "", ""
                         + length);

    if (m_contentHandler != null)
    {
      m_contentHandler.characters(ch, start, length);
    }
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#ignorableWhitespace: ""
                         + start + "", "" + length);

    if (m_contentHandler != null)
    {
      m_contentHandler.ignorableWhitespace(ch, start, length);
    }
  }

  
  public void processingInstruction(String target, String data)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#processingInstruction: ""
                         + target + "", "" + data);

    if (m_contentHandler != null)
    {
      m_contentHandler.processingInstruction(target, data);
    }
  }

  
  public void skippedEntity(String name) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#skippedEntity: "" + name);

    if (m_contentHandler != null)
    {
      m_contentHandler.skippedEntity(name);
    }
  }

  
  
  

  
  public void warning(SAXParseException e) throws SAXException
  {
    
    
    
    
    javax.xml.transform.ErrorListener errorListener = m_transformer.getErrorListener();
    if(errorListener instanceof ErrorHandler)
    {
      ((ErrorHandler)errorListener).warning(e);
    }
    else
    {
      try
      {
        errorListener.warning(new javax.xml.transform.TransformerException(e));
      }
      catch(javax.xml.transform.TransformerException te)
      {
        throw e;
      }
    }
  }

  
  public void error(SAXParseException e) throws SAXException
  {
    
    

    
    
    
    
    javax.xml.transform.ErrorListener errorListener = m_transformer.getErrorListener();
    if(errorListener instanceof ErrorHandler)
    {
      ((ErrorHandler)errorListener).error(e);
      if(null != m_errorHandler)
        m_errorHandler.error(e); 
    }
    else
    {
      try
      {
        errorListener.error(new javax.xml.transform.TransformerException(e));
        if(null != m_errorHandler)
          m_errorHandler.error(e); 
      }
      catch(javax.xml.transform.TransformerException te)
      {
        throw e;
      }
    }
  }

  
  public void fatalError(SAXParseException e) throws SAXException
  {
    if(null != m_errorHandler)
    {
      try
      {
        m_errorHandler.fatalError(e);
      }
      catch(SAXParseException se)
      {
        
      }
      
    }

    
    
    
    
    javax.xml.transform.ErrorListener errorListener = m_transformer.getErrorListener();
    
    if(errorListener instanceof ErrorHandler)
    {
      ((ErrorHandler)errorListener).fatalError(e);
      if(null != m_errorHandler)
        m_errorHandler.fatalError(e); 
    }
    else
    {
      try
      {
        errorListener.fatalError(new javax.xml.transform.TransformerException(e));
        if(null != m_errorHandler)
          m_errorHandler.fatalError(e); 
      }
      catch(javax.xml.transform.TransformerException te)
      {
        throw e;
      }
    }
  }

  
  
  

  
  public void startDTD(String name, String publicId, String systemId)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startDTD: "" + name + "", ""
                         + publicId + "", "" + systemId);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startDTD(name, publicId, systemId);
    }
  }

  
  public void endDTD() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endDTD"");

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.endDTD();
    }
  }

  
  public void startEntity(String name) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startEntity: "" + name);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startEntity(name);
    }
  }

  
  public void endEntity(String name) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endEntity: "" + name);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.endEntity(name);
    }
  }

  
  public void startCDATA() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startCDATA"");

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startCDATA();
    }
  }

  
  public void endCDATA() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endCDATA"");

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.endCDATA();
    }
  }

  
  public void comment(char ch[], int start, int length) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#comment: "" + start + "", ""
                         + length);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.comment(ch, start, length);
    }
  }

  
  
  

  
  public void elementDecl(String name, String model) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#elementDecl: "" + name + "", ""
                         + model);

    if (null != m_declHandler)
    {
      m_declHandler.elementDecl(name, model);
    }
  }

  
  public void attributeDecl(
          String eName, String aName, String type, String valueDefault, String value)
            throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#attributeDecl: "" + eName
                         + "", "" + aName + "", etc..."");

    if (null != m_declHandler)
    {
      m_declHandler.attributeDecl(eName, aName, type, valueDefault, value);
    }
  }

  
  public void internalEntityDecl(String name, String value)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#internalEntityDecl: "" + name
                         + "", "" + value);

    if (null != m_declHandler)
    {
      m_declHandler.internalEntityDecl(name, value);
    }
  }

  
  public void externalEntityDecl(
          String name, String publicId, String systemId) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#externalEntityDecl: "" + name
                         + "", "" + publicId + "", "" + systemId);

    if (null != m_declHandler)
    {
      m_declHandler.externalEntityDecl(name, publicId, systemId);
    }
  }

  
  
  

  
  private static boolean DEBUG = false;

  
  private TransformerImpl m_transformer;

  
  private String m_baseSystemID;

  
  private Result m_result = null;

  
  private Locator m_locator = null;

  
  private EntityResolver m_entityResolver = null;

  
  private DTDHandler m_dtdHandler = null;

  
  private ContentHandler m_contentHandler = null;

  
  private ErrorHandler m_errorHandler = null;

  
  private LexicalHandler m_lexicalHandler = null;

  
  private DeclHandler m_declHandler = null;
  
  
  DTM m_dtm;
}
"
org.apache.xalan.templates.AVT,14,1,0,23,44,29,11,13,14,0.769230769,546,1.0,0,0.0,0.206349206,0,0,37.64285714,4,1.8571,1,"
package org.apache.xalan.templates;

import java.util.StringTokenizer;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.processor.StylesheetHandler;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.StringBufferPool;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;


public class AVT implements java.io.Serializable, XSLTVisitable
{

  
  private String m_simpleString = null;

  
  private Vector m_parts = null;

  
  private String m_rawName;

  
  public String getRawName()
  {
    return m_rawName;
  }

  
  public void setRawName(String rawName)
  {
    m_rawName = rawName;
  }

  
  private String m_name;

  
  public String getName()
  {
    return m_name;
  }

  
  public void setName(String name)
  {
    m_name = name;
  }

  
  private String m_uri;

  
  public String getURI()
  {
    return m_uri;
  }

  
  public void setURI(String uri)
  {
    m_uri = uri;
  }

  
  public AVT(StylesheetHandler handler, String uri, String name, 
             String rawName, String stringedValue,
             ElemTemplateElement owner)
          throws javax.xml.transform.TransformerException
  {

    m_uri = uri;
    m_name = name;
    m_rawName = rawName;

    StringTokenizer tokenizer = new StringTokenizer(stringedValue, ""{}""'"",
                                  true);
    int nTokens = tokenizer.countTokens();

    if (nTokens < 2)
    {
      m_simpleString = stringedValue;  
    }
    else
    {
      FastStringBuffer buffer = StringBufferPool.get();
      FastStringBuffer exprBuffer = StringBufferPool.get();

      try
      {
        m_parts = new Vector(nTokens + 1);

        String t = null;  
        String lookahead = null;  
        String error = null;  

        while (tokenizer.hasMoreTokens())
        {
          if (lookahead != null)
          {
            t = lookahead;
            lookahead = null;
          }
          else
            t = tokenizer.nextToken();

          if (t.length() == 1)
          {
            switch (t.charAt(0))
            {
            case ('""') :
            case (''') :
            {

              
              buffer.append(t);

              break;
            }
            case ('{') :
            {

              try
              {
                
                lookahead = tokenizer.nextToken();

                if (lookahead.equals(""{""))
                {

                  
                  buffer.append(lookahead);

                  lookahead = null;

                  break;  
                }

                
                else
                {
                  if (buffer.length() > 0)
                  {
                    m_parts.addElement(new AVTPartSimple(buffer.toString()));
                    buffer.setLength(0);
                  }

                  exprBuffer.setLength(0);

                  while (null != lookahead)
                  {
                    if (lookahead.length() == 1)
                    {
                      switch (lookahead.charAt(0))
                      {
                      case ''' :
                      case '""' :
                        {

                          
                          exprBuffer.append(lookahead);

                          String quote = lookahead;

                          
                          lookahead = tokenizer.nextToken();

                          while (!lookahead.equals(quote))
                          {
                            exprBuffer.append(lookahead);

                            lookahead = tokenizer.nextToken();
                          }

                          exprBuffer.append(lookahead);

                          lookahead = tokenizer.nextToken();

                          break;
                        }
                      case '{' :
                        {

                          
                          error = XSLMessages.createMessage(
                                                            XSLTErrorResources.ER_NO_CURLYBRACE, null);  
                          
                          lookahead = null;  

                          break;
                        }
                      case '}' :
                        {

                          
                          
                          buffer.setLength(0);

                          XPath xpath =
                                       handler.createXPath(exprBuffer.toString(), owner);

                          m_parts.addElement(new AVTPartXPath(xpath));

                          lookahead = null;  

                          break;
                        }
                      default :
                        {

                          
                          exprBuffer.append(lookahead);

                          lookahead = tokenizer.nextToken();
                        }
                      }  
                    }  
                    else
                    {

                      
                      exprBuffer.append(lookahead);

                      lookahead = tokenizer.nextToken();
                    }
                  }  

                  if (error != null)
                  {
                    break;  
                  }
                }

                break;
              }
              catch (java.util.NoSuchElementException ex)
              {
                error = XSLMessages.createMessage(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE, new Object[]{ name, stringedValue }); 
                break;
              }
            }
            case ('}') :
            {
              lookahead = tokenizer.nextToken();

              if (lookahead.equals(""}""))
              {

                
                buffer.append(lookahead);

                lookahead = null;  
              }
              else
              {

                
                try
                {
                  handler.warn(XSLTErrorResources.WG_FOUND_CURLYBRACE, null);  
                }
                catch (org.xml.sax.SAXException se)
                {
                  throw new TransformerException(se);
                }

                buffer.append(""}"");

                
              }

              break;
            }
            default :
            {

              
              buffer.append(t);
            }
            }  
          }  
          else
          {

            
            buffer.append(t);
          }

          if (null != error)
          {
            try
            {
              handler.warn(XSLTErrorResources.WG_ATTR_TEMPLATE,
                           new Object[]{ error });  
            }
            catch (org.xml.sax.SAXException se)
            {
              throw new TransformerException(se);
            }

            break;
          }
        }  

        if (buffer.length() > 0)
        {
          m_parts.addElement(new AVTPartSimple(buffer.toString()));
          buffer.setLength(0);
        }
      }
      finally
      {
        StringBufferPool.free(buffer);
        StringBufferPool.free(exprBuffer);
      }
    }  

    if (null == m_parts && (null == m_simpleString))
    {

      
      m_simpleString = """";
    }
  }

  
  public String getSimpleString()
  {

    if (null != m_simpleString)
    {
      return m_simpleString;
    }
    else if (null != m_parts)
    {
      FastStringBuffer buf = StringBufferPool.get();
      String s;

      try
      {
        buf.setLength(0);

        int n = m_parts.size();

        for (int i = 0; i < n; i++)
        {
          AVTPart part = (AVTPart) m_parts.elementAt(i);

          buf.append(part.getSimpleString());
        }

        s = buf.toString();
      }
      finally
      {
        StringBufferPool.free(buf);
      }

      return s;
    }
    else
    {
      return """";
    }
  }

  
  public String evaluate(
          XPathContext xctxt, int context, org.apache.xml.utils.PrefixResolver nsNode)
            throws javax.xml.transform.TransformerException
  {

    FastStringBuffer buf = StringBufferPool.get();

    try
    {
      if (null != m_simpleString)
      {
        return m_simpleString;
      }
      else if (null != m_parts)
      {
        buf.setLength(0);

        int n = m_parts.size();

        for (int i = 0; i < n; i++)
        {
          AVTPart part = (AVTPart) m_parts.elementAt(i);

          part.evaluate(xctxt, buf, context, nsNode);
        }

        return buf.toString();
      }
      else
      {
        return """";
      }
    }
    finally
    {
      StringBufferPool.free(buf);
    }
  }

  
  public boolean isContextInsensitive()
  {
    return null != m_simpleString;
  }

  
  public boolean canTraverseOutsideSubtree()
  {

    if (null != m_parts)
    {
      int n = m_parts.size();

      for (int i = 0; i < n; i++)
      {
        AVTPart part = (AVTPart) m_parts.elementAt(i);

        if (part.canTraverseOutsideSubtree())
          return true;
      }
    }

    return false;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    if (null != m_parts)
    {
      int n = m_parts.size();

      for (int i = 0; i < n; i++)
      {
        AVTPart part = (AVTPart) m_parts.elementAt(i);

        part.fixupVariables(vars, globalsSize);
      }
    }
  }
  
  
  public void callVisitors(XSLTVisitor visitor)
  {
  	if(visitor.visitAVT(this) && (null != m_parts))
  	{
      int n = m_parts.size();

      for (int i = 0; i < n; i++)
      {
        AVTPart part = (AVTPart) m_parts.elementAt(i);

        part.callVisitors(visitor);
      }  		
  	}
  }


  
  public boolean isSimple() {
  	return m_simpleString != null;
  }
}
"
org.apache.xpath.functions.FuncFalse,3,3,0,4,4,3,0,4,3,2.0,9,0.0,0,0.95,0.5,1,6,2.0,1,0.6667,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class FuncFalse extends Function
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return XBoolean.S_FALSE;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }

}
"
org.apache.xalan.xsltc.compiler.LiteralElement,13,3,0,25,77,40,5,21,9,0.783333333,663,1.0,1,0.823529412,0.207692308,2,10,49.61538462,18,4.5385,2,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class LiteralElement extends Instruction {

    private String _name;
    private LiteralElement _literalElemParent;
    private Vector _attributeElements = null;
    private Hashtable _accessedPrefixes = null;

    private final static String XMLNS_STRING = ""xmlns"";

    
    public QName getName() {
	return _qname;
    }
 
    
    public void display(int indent) {
	indent(indent);
	Util.println(""LiteralElement name = "" + _name);
	displayContents(indent + IndentIncrement);
    }

    
    private String accessedNamespace(String prefix) {
	if (_accessedPrefixes == null)
	    return(null);
	else
	    return((String)_accessedPrefixes.get(prefix));
    }

    
    public void registerNamespace(String prefix, String uri,
				  SymbolTable stable, boolean declared) {

	
	if (_literalElemParent != null) {
	    final String parentUri = _literalElemParent.accessedNamespace(prefix);
	    if (parentUri == null) {
		_literalElemParent.registerNamespace(prefix, uri, stable, declared);
		return;
	    }
	    if (parentUri.equals(uri)) return;
	}

	
	if (_accessedPrefixes == null) {
	    _accessedPrefixes = new Hashtable();
	}
	else {
	    if (!declared) {
		
		final String old = (String)_accessedPrefixes.get(prefix);
		if (old != null) {
		    if (old.equals(uri))
			return;
		    else 
			prefix = stable.generateNamespacePrefix();
		}
	    }
	}

	if (!prefix.equals(""xml"")) {
	    _accessedPrefixes.put(prefix,uri);
	}
    }

    
    private String translateQName(QName qname, SymbolTable stable) {
	
	String localname = qname.getLocalPart();
	String prefix = qname.getPrefix();

	
	if (prefix == null)
	    prefix = Constants.EMPTYSTRING;
	else if (prefix.equals(XMLNS_STRING))
	    return(XMLNS_STRING);
	
	
	final String alternative = stable.lookupPrefixAlias(prefix);
	if (alternative != null) {
	    stable.excludeNamespaces(prefix);
	    prefix = alternative;
	}

	
	String uri = lookupNamespace(prefix);
	if (uri == null) return(localname);

	
	registerNamespace(prefix, uri, stable, false);

	
	if (prefix != Constants.EMPTYSTRING)
	    return(prefix+"":""+localname);
	else
	    return(localname);
    }

    
    public void addAttribute(SyntaxTreeNode attribute) {
	if (_attributeElements == null) {
	    _attributeElements = new Vector(2);
	}
	_attributeElements.add(attribute);
    }

    
    public void setFirstAttribute(SyntaxTreeNode attribute) {
	if (_attributeElements == null) {
	    _attributeElements = new Vector(2);
	}
	_attributeElements.insertElementAt(attribute,0);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	if (_attributeElements != null) {
	    final int count = _attributeElements.size();
	    for (int i = 0; i < count; i++) {
		SyntaxTreeNode node = 
		    (SyntaxTreeNode)_attributeElements.elementAt(i);
		node.typeCheck(stable);
	    }
	}
	typeCheckContents(stable);
	return Type.Void;
    }

    
    public Enumeration getNamespaceScope(SyntaxTreeNode node) {
	Hashtable all = new Hashtable();
	
	while (node != null) {
	    Hashtable mapping = node.getPrefixMapping();
	    if (mapping != null) {
		Enumeration prefixes = mapping.keys();
		while (prefixes.hasMoreElements()) {
		    String prefix = (String)prefixes.nextElement();
		    if (!all.containsKey(prefix)) {
			all.put(prefix, mapping.get(prefix));
		    }
		}
	    }
	    node = node.getParent();
	}
	return(all.keys());
    }

    
    public void parseContents(Parser parser) {
	final SymbolTable stable = parser.getSymbolTable();
	stable.setCurrentNode(this);

	
	SyntaxTreeNode _literalElemParent = getParent();
	while (_literalElemParent != null && !(_literalElemParent instanceof LiteralElement)) {
	    _literalElemParent = _literalElemParent.getParent();
	}

	if (!(_literalElemParent instanceof LiteralElement)) {
	    _literalElemParent = null;
	}

	_name = translateQName(_qname, stable);

	
	final int count = _attributes.getLength();
	for (int i = 0; i < count; i++) {
	    final QName qname = parser.getQName(_attributes.getQName(i));
	    final String uri = qname.getNamespace();
	    final String val = _attributes.getValue(i);

	    
	    
	    
	    if (qname == parser.getUseAttributeSets()) {
		setFirstAttribute(new UseAttributeSets(val, parser));
	    }
	    
	    else if (qname == parser.getExtensionElementPrefixes()) {
		stable.excludeNamespaces(val);
	    }
	    
	    else if (qname == parser.getExcludeResultPrefixes()) {
		stable.excludeNamespaces(val);
	    }
	    else {
		
		final String prefix = qname.getPrefix();
		if (prefix != null && prefix.equals(XMLNS_PREFIX) ||
		    prefix == null && qname.getLocalPart().equals(""xmlns"") ||
		    uri != null && uri.equals(XSLT_URI))
		{
		    continue;	
		}

		
		final String name = translateQName(qname, stable);
		LiteralAttribute attr = new LiteralAttribute(name, val, parser);
		addAttribute(attr);
		attr.setParent(this);
		attr.parseContents(parser);
	    }
	}

	
	
	final Enumeration include = getNamespaceScope(this);
	while (include.hasMoreElements()) {
	    final String prefix = (String)include.nextElement();
	    if (!prefix.equals(""xml"")) {
		final String uri = lookupNamespace(prefix);
		if (uri != null && !stable.isExcludedNamespace(uri)) {
		    registerNamespace(prefix, uri, stable, true);
		}
	    }
	}

	parseChildren(parser);

	
	for (int i = 0; i < count; i++) {
	    final QName qname = parser.getQName(_attributes.getQName(i));
	    final String val = _attributes.getValue(i);

	    
	    if (qname == parser.getExtensionElementPrefixes()) {
		stable.unExcludeNamespaces(val);
	    }
	    
	    else if (qname == parser.getExcludeResultPrefixes()) {
		stable.unExcludeNamespaces(val);
	    }
	}
    }

    protected boolean contextDependent() {
	return dependentContents();
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	il.append(new PUSH(cpg, _name));
	il.append(DUP2); 		
	il.append(methodGen.startElement());

	
	for (int i = 0; i < elementCount(); i++) {
	    final SyntaxTreeNode item = (SyntaxTreeNode) elementAt(i);
	    if (item instanceof Variable) {
		item.translate(classGen, methodGen);
		removeElement(item);	
	    }
	}

	
	if (_accessedPrefixes != null) {
	    boolean declaresDefaultNS = false;
	    Enumeration e = _accessedPrefixes.keys();

	    while (e.hasMoreElements()) {
		final String prefix = (String)e.nextElement();
		final String uri = (String)_accessedPrefixes.get(prefix);

		if (uri != Constants.EMPTYSTRING || 
			prefix != Constants.EMPTYSTRING) 
		{
		    if (prefix == Constants.EMPTYSTRING) {
			declaresDefaultNS = true;
		    }
		    il.append(methodGen.loadHandler());
		    il.append(new PUSH(cpg,prefix));
		    il.append(new PUSH(cpg,uri));
		    il.append(methodGen.namespace());
		}
	    }

	    
	    if (!declaresDefaultNS && (_parent instanceof XslElement)
		    && ((XslElement) _parent).declaresDefaultNS()) 
	    {
		il.append(methodGen.loadHandler());
		il.append(new PUSH(cpg, Constants.EMPTYSTRING));
		il.append(new PUSH(cpg, Constants.EMPTYSTRING));
		il.append(methodGen.namespace());
	    }
	}

	
	if (_attributeElements != null) {
	    final int count = _attributeElements.size();
	    for (int i = 0; i < count; i++) {
		SyntaxTreeNode node = 
		    (SyntaxTreeNode)_attributeElements.elementAt(i);
		node.translate(classGen, methodGen);
	    }
	}
	
	
	translateContents(classGen, methodGen);

	
	il.append(methodGen.endElement());
    }
}
"
org.apache.xpath.NodeSetDTM,56,2,2,25,84,714,18,7,56,0.739393939,839,0.833333333,1,0.363636364,0.160714286,1,4,13.875,9,1.5714,1,"
package org.apache.xpath;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.utils.NodeVector;
import org.apache.xpath.res.XPATHErrorResources;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;



public class NodeSetDTM extends NodeVector
        implements  DTMIterator, 
        Cloneable
{

  
  public NodeSetDTM(DTMManager dtmManager)
  {
    super();
    m_manager = dtmManager;
  }

  
  public NodeSetDTM(int blocksize, int dummy, DTMManager dtmManager)
  {
    super(blocksize);
    m_manager = dtmManager;
  }

  














  
  public NodeSetDTM(NodeSetDTM nodelist)
  {

    super();
    m_manager = nodelist.getDTMManager();
    m_root = nodelist.getRoot();

    addNodes((DTMIterator) nodelist);
  }

  
  public NodeSetDTM(DTMIterator ni)
  {

    super();

    m_manager = ni.getDTMManager();
    m_root = ni.getRoot();
    addNodes(ni);
  }
  
  
  public NodeSetDTM(NodeIterator iterator, XPathContext xctxt)
  {

    super();

    Node node;
    m_manager = xctxt.getDTMManager();

    while (null != (node = iterator.nextNode()))
    {
      int handle = xctxt.getDTMHandleFromNode(node);
      addNodeInDocOrder(handle, xctxt);
    }
  }
  
  
  public NodeSetDTM(NodeList nodeList, XPathContext xctxt)
  {

    super();

    m_manager = xctxt.getDTMManager();

    int n = nodeList.getLength();
    for (int i = 0; i < n; i++) 
    {
      Node node = nodeList.item(i);
      int handle = xctxt.getDTMHandleFromNode(node);
      
      addNode(handle); 
    } 
  }


  
  public NodeSetDTM(int node, DTMManager dtmManager)
  {

    super();
    m_manager = dtmManager;

    addNode(node);
  }
  
  
  public void setEnvironment(Object environment)
  {
    
  }


  
  public int getRoot()
  {
    if(DTM.NULL == m_root)
    {
      if(size() > 0)
        return item(0);
      else
        return DTM.NULL;
    }
    else
      return m_root;
  }
  
  
  public void setRoot(int context, Object environment)
  {
    
  }

  
  public Object clone() throws CloneNotSupportedException
  {

    NodeSetDTM clone = (NodeSetDTM) super.clone();

    return clone;
  }

  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    NodeSetDTM clone = (NodeSetDTM) clone();

    clone.reset();

    return clone;
  }

  
  public void reset()
  {
    m_next = 0;
  }

  
  public int getWhatToShow()
  {
    return DTMFilter.SHOW_ALL & ~DTMFilter.SHOW_ENTITY_REFERENCE;
  }

  
  public DTMFilter getFilter()
  {
    return null;
  }

  
  public boolean getExpandEntityReferences()
  {
    return true;
  }
  
  
  public DTM getDTM(int nodeHandle)
  {
    
    return m_manager.getDTM(nodeHandle);
  }
  
  
  DTMManager m_manager;
  
  
  public DTMManager getDTMManager()
  {
    
    return m_manager;
  }

  
  public int nextNode()
  {

    if ((m_next) < this.size())
    {
      int next = this.elementAt(m_next);

      m_next++;

      return next;
    }
    else
      return DTM.NULL;
  }

  
  public int previousNode()
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE, null)); 

    if ((m_next - 1) > 0)
    {
      m_next--;

      return this.elementAt(m_next);
    }
    else
      return DTM.NULL;
  }

  
  public void detach(){}
  
  
  public void allowDetachToRelease(boolean allowRelease)
  {
    
  }


  
  public boolean isFresh()
  {
    return (m_next == 0);
  }

  
  public void runTo(int index)
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_INDEX, null)); 

    if ((index >= 0) && (m_next < m_firstFree))
      m_next = index;
    else
      m_next = m_firstFree - 1;
  }

  
  public int item(int index)
  {

    runTo(index);

    return this.elementAt(index);
  }

  
  public int getLength()
  {

    runTo(-1);

    return this.size();
  }

  
  public void addNode(int n)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    this.addElement(n);
  }

  
  public void insertNode(int n, int pos)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    insertElementAt(n, pos);
  }

  
  public void removeNode(int n)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    this.removeElement(n);
  }

  

































  

























  
  public void addNodes(DTMIterator iterator)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    if (null != iterator)  
    {
      int obj;

      while (DTM.NULL != (obj = iterator.nextNode()))
      {
        addElement(obj);
      }
    }

    
  }

  




























  
  public void addNodesInDocOrder(DTMIterator iterator, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    int node;

    while (DTM.NULL != (node = iterator.nextNode()))
    {
      addNodeInDocOrder(node, support);
    }
  }

  
































































  
  public int addNodeInDocOrder(int node, boolean test, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    int insertIndex = -1;

    if (test)
    {

      
      
      
      int size = size(), i;

      for (i = size - 1; i >= 0; i--)
      {
        int child = elementAt(i);

        if (child == node)
        {
          i = -2;  

          break;
        }

        DTM dtm = support.getDTM(node);
        if (!dtm.isNodeAfter(node, child))
        {
          break;
        }
      }

      if (i != -2)
      {
        insertIndex = i + 1;

        insertElementAt(node, insertIndex);
      }
    }
    else
    {
      insertIndex = this.size();

      boolean foundit = false;

      for (int i = 0; i < insertIndex; i++)
      {
        if (i == node)
        {
          foundit = true;

          break;
        }
      }

      if (!foundit)
        addElement(node);
    }

    
    return insertIndex;
  }  

  
  public int addNodeInDocOrder(int node, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    return addNodeInDocOrder(node, true, support);
  }  

  
  public int size()
  {
    return super.size();
  }

  
  public void addElement(int value)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.addElement(value);
  }

  
  public void insertElementAt(int value, int at)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.insertElementAt(value, at);
  }

  
  public void appendNodes(NodeVector nodes)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.appendNodes(nodes);
  }

  
  public void removeAllElements()
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.removeAllElements();
  }

  
  public boolean removeElement(int s)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    return super.removeElement(s);
  }

  
  public void removeElementAt(int i)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.removeElementAt(i);
  }

  
  public void setElementAt(int node, int index)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.setElementAt(node, index);
  }
  
  
  public void setItem(int node, int index)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.setElementAt(node, index);
  }

  
  public int elementAt(int i)
  {

    runTo(i);

    return super.elementAt(i);
  }
  
  
  public boolean contains(int s)
  {

    runTo(-1);

    return super.contains(s);
  }

  
  public int indexOf(int elem, int index)
  {

    runTo(-1);

    return super.indexOf(elem, index);
  }

  
  public int indexOf(int elem)
  {

    runTo(-1);

    return super.indexOf(elem);
  }

  
  transient protected int m_next = 0;

  
  public int getCurrentPos()
  {
    return m_next;
  }

  
  public void setCurrentPos(int i)
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_INDEX, null)); 

    m_next = i;
  }

  
  public int getCurrentNode()
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        ""This NodeSetDTM can not do indexing or counting functions!"");

    int saved = m_next;
    
    
    
    int current = (m_next > 0) ? m_next-1 : m_next; 
    int n = (current < m_firstFree) ? elementAt(current) : DTM.NULL;
    m_next = saved; 
    return n;
  }

  
  transient protected boolean m_mutable = true;

  
  transient protected boolean m_cacheNodes = true;
  
  
  protected int m_root = DTM.NULL;

  
  public boolean getShouldCacheNodes()
  {
    return m_cacheNodes;
  }

  
  public void setShouldCacheNodes(boolean b)
  {

    if (!isFresh())
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANNOT_CALL_SETSHOULDCACHENODE, null)); 

    m_cacheNodes = b;
    m_mutable = true;
  }
  
  
  public boolean isMutable()
  {
    return m_mutable;
  }
  
  transient private int m_last = 0;
  
  public int getLast()
  {
    return m_last;
  }
  
  public void setLast(int last)
  {
    m_last = last;
  }
  
  
  public boolean isDocOrdered()
  {
    return true;
  }
  
  
  public int getAxis()
  {
    return -1;
  }
  

}
"
org.apache.xpath.compiler.Lexer,10,1,0,6,30,3,1,6,0,0.611111111,807,0.5,3,0.0,0.3125,0,0,79.1,11,2.8,0,"
package org.apache.xpath.compiler;

import java.util.Vector;

import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.res.XPATHErrorResources;


class Lexer
{

  
  private Compiler m_compiler;

  
  PrefixResolver m_namespaceContext;

  
  XPathParser m_processor;

  
  static final int TARGETEXTRA = 10000;

  
  private int m_patternMap[] = new int[100];

  
  private int m_patternMapSize;

  
  Lexer(Compiler compiler, PrefixResolver resolver,
        XPathParser xpathProcessor)
  {

    m_compiler = compiler;
    m_namespaceContext = resolver;
    m_processor = xpathProcessor;
  }

  
  void tokenize(String pat) throws javax.xml.transform.TransformerException
  {
    tokenize(pat, null);
  }

  
  void tokenize(String pat, Vector targetStrings)
          throws javax.xml.transform.TransformerException
  {

    m_compiler.m_currentPattern = pat;
    m_patternMapSize = 0; 

    
    m_compiler.m_opMap = new OpMapVector(OpMap.MAXTOKENQUEUESIZE * 5, OpMap.BLOCKTOKENQUEUESIZE * 5, OpMap.MAPINDEX_LENGTH);

    int nChars = pat.length();
    int startSubstring = -1; 
    int posOfNSSep = -1;
    boolean isStartOfPat = true;
    boolean isAttrName = false;
    boolean isNum = false;

    
    
    int nesting = 0;

    
    for (int i = 0; i < nChars; i++)
    {
      char c = pat.charAt(i);

      switch (c)
      {
      case '""' :
      {
        if (startSubstring != -1)
        {
          isNum = false;
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;

          if (-1 != posOfNSSep)
          {
            posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, i);
          }
          else
          {
            addToTokenQueue(pat.substring(startSubstring, i));
          }
        }

        startSubstring = i;

        for (i++; (i < nChars) && ((c = pat.charAt(i)) != '""'); i++);

        if (c == '""' && i < nChars)
        {
          addToTokenQueue(pat.substring(startSubstring, i + 1));

          startSubstring = -1;
        }
        else
        {
          m_processor.error(XPATHErrorResources.ER_EXPECTED_DOUBLE_QUOTE,
                            null);  
        }
      }
      break;
      case ''' :
        if (startSubstring != -1)
        {
          isNum = false;
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;

          if (-1 != posOfNSSep)
          {
            posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, i);
          }
          else
          {
            addToTokenQueue(pat.substring(startSubstring, i));
          }
        }

        startSubstring = i;

        for (i++; (i < nChars) && ((c = pat.charAt(i)) != '''); i++);

        if (c == ''' && i < nChars)
        {
          addToTokenQueue(pat.substring(startSubstring, i + 1));

          startSubstring = -1;
        }
        else
        {
          m_processor.error(XPATHErrorResources.ER_EXPECTED_SINGLE_QUOTE,
                            null);  
        }
        break;
      case 0x0A :
      case 0x0D :
      case ' ' :
      case '	' :
        if (startSubstring != -1)
        {
          isNum = false;
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;

          if (-1 != posOfNSSep)
          {
            posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, i);
          }
          else
          {
            addToTokenQueue(pat.substring(startSubstring, i));
          }

          startSubstring = -1;
        }
        break;
      case '@' :
        isAttrName = true;

      
      case '-' :
        if ('-' == c)
        {
          if (!(isNum || (startSubstring == -1)))
          {
            break;
          }

          isNum = false;
        }

      
      case '(' :
      case '[' :
      case ')' :
      case ']' :
      case '|' :
      case '/' :
      case '*' :
      case '+' :
      case '=' :
      case ',' :
      case '\' :  
      case '^' :  
      case '!' :  
      case '$' :
      case '<' :
      case '>' :
        if (startSubstring != -1)
        {
          isNum = false;
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;

          if (-1 != posOfNSSep)
          {
            posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, i);
          }
          else
          {
            addToTokenQueue(pat.substring(startSubstring, i));
          }

          startSubstring = -1;
        }
        else if (('/' == c) && isStartOfPat)
        {
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
        }
        else if ('*' == c)
        {
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;
        }

        if (0 == nesting)
        {
          if ('|' == c)
          {
            if (null != targetStrings)
            {
              recordTokenString(targetStrings);
            }

            isStartOfPat = true;
          }
        }

        if ((')' == c) || (']' == c))
        {
          nesting--;
        }
        else if (('(' == c) || ('[' == c))
        {
          nesting++;
        }

        addToTokenQueue(pat.substring(i, i + 1));
        break;
      case ':' :
        if (i>0)
        {
          if (posOfNSSep == (i - 1))
          {
            if (startSubstring != -1)
            {
              if (startSubstring < (i - 1))
                addToTokenQueue(pat.substring(startSubstring, i - 1));
            }

            isNum = false;
            isAttrName = false;
            startSubstring = -1;
            posOfNSSep = -1;

            addToTokenQueue(pat.substring(i - 1, i + 1));

            break;
          }
          else
          {
            posOfNSSep = i;
          }
        }

      
      default :
        if (-1 == startSubstring)
        {
          startSubstring = i;
          isNum = Character.isDigit(c);
        }
        else if (isNum)
        {
          isNum = Character.isDigit(c);
        }
      }
    }

    if (startSubstring != -1)
    {
      isNum = false;
      isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);

      if ((-1 != posOfNSSep) || 
         ((m_namespaceContext != null) && (m_namespaceContext.handlesNullPrefixes())))
      {
        posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, nChars);
      }
      else
      {
        addToTokenQueue(pat.substring(startSubstring, nChars));
      }
    }

    if (0 == m_compiler.getTokenQueueSize())
    {
      m_processor.error(XPATHErrorResources.ER_EMPTY_EXPRESSION, null);  
    }
    else if (null != targetStrings)
    {
      recordTokenString(targetStrings);
    }

    m_processor.m_queueMark = 0;
  }

  
  private boolean mapPatternElemPos(int nesting, boolean isStart,
                                    boolean isAttrName)
  {

    if (0 == nesting)
    {
      if(m_patternMapSize >= m_patternMap.length)
      {
        int patternMap[] = m_patternMap;
        int len = m_patternMap.length;
        m_patternMap = new int[m_patternMapSize + 100];
        System.arraycopy(patternMap, 0, m_patternMap, 0, len);
      } 
      if (!isStart)
      {
        m_patternMap[m_patternMapSize - 1] -= TARGETEXTRA;
      }
      m_patternMap[m_patternMapSize] =
        (m_compiler.getTokenQueueSize() - (isAttrName ? 1 : 0)) + TARGETEXTRA;

      m_patternMapSize++;

      isStart = false;
    }

    return isStart;
  }

  
  private int getTokenQueuePosFromMap(int i)
  {

    int pos = m_patternMap[i];

    return (pos >= TARGETEXTRA) ? (pos - TARGETEXTRA) : pos;
  }

  
  private final void resetTokenMark(int mark)
  {

    int qsz = m_compiler.getTokenQueueSize();

    m_processor.m_queueMark = (mark > 0)
                              ? ((mark <= qsz) ? mark - 1 : mark) : 0;

    if (m_processor.m_queueMark < qsz)
    {
      m_processor.m_token =
        (String) m_compiler.getTokenQueue().elementAt(m_processor.m_queueMark++);
      m_processor.m_tokenChar = m_processor.m_token.charAt(0);
    }
    else
    {
      m_processor.m_token = null;
      m_processor.m_tokenChar = 0;
    }
  }

  
  final int getKeywordToken(String key)
  {

    int tok;

    try
    {
      Integer itok = (Integer) Keywords.m_keywords.get(key);

      tok = (null != itok) ? itok.intValue() : 0;
    }
    catch (NullPointerException npe)
    {
      tok = 0;
    }
    catch (ClassCastException cce)
    {
      tok = 0;
    }

    return tok;
  }

  
  private void recordTokenString(Vector targetStrings)
  {

    int tokPos = getTokenQueuePosFromMap(m_patternMapSize - 1);

    resetTokenMark(tokPos + 1);

    if (m_processor.lookahead('(', 1))
    {
      int tok = getKeywordToken(m_processor.m_token);

      switch (tok)
      {
      case OpCodes.NODETYPE_COMMENT :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_COMMENT);
        break;
      case OpCodes.NODETYPE_TEXT :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_TEXT);
        break;
      case OpCodes.NODETYPE_NODE :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ANY);
        break;
      case OpCodes.NODETYPE_ROOT :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ROOT);
        break;
      case OpCodes.NODETYPE_ANYELEMENT :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ANY);
        break;
      case OpCodes.NODETYPE_PI :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ANY);
        break;
      default :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ANY);
      }
    }
    else
    {
      if (m_processor.tokenIs('@'))
      {
        tokPos++;

        resetTokenMark(tokPos + 1);
      }

      if (m_processor.lookahead(':', 1))
      {
        tokPos += 2;
      }

      targetStrings.addElement(m_compiler.getTokenQueue().elementAt(tokPos));
    }
  }

  
  private final void addToTokenQueue(String s)
  {
    m_compiler.getTokenQueue().addElement(s);
  }

  
  private int mapNSTokens(String pat, int startSubstring, int posOfNSSep,
                          int posOfScan)
           throws javax.xml.transform.TransformerException
 {

    String prefix = """";
    
    if ((startSubstring >= 0) && (posOfNSSep >= 0))
    {
       prefix = pat.substring(startSubstring, posOfNSSep);
    }
    String uName;

    if ((null != m_namespaceContext) &&!prefix.equals(""*"")
            &&!prefix.equals(""xmlns""))
    {
      try
      {
        if (prefix.length() > 0)
          uName = ((PrefixResolver) m_namespaceContext).getNamespaceForPrefix(
            prefix);
        else
        {

          
          
          
          if (false)
          {
            addToTokenQueue("":"");

            String s = pat.substring(posOfNSSep + 1, posOfScan);

            if (s.length() > 0)
              addToTokenQueue(s);

            return -1;
          }
          else
          {
            uName =
              ((PrefixResolver) m_namespaceContext).getNamespaceForPrefix(
                prefix);
          }
        }
      }
      catch (ClassCastException cce)
      {
        uName = m_namespaceContext.getNamespaceForPrefix(prefix);
      }
    }
    else
    {
      uName = prefix;
    }

    if ((null != uName) && (uName.length() > 0))
    {
      addToTokenQueue(uName);
      addToTokenQueue("":"");

      String s = pat.substring(posOfNSSep + 1, posOfScan);

      if (s.length() > 0)
        addToTokenQueue(s);
    }
    else
    {

      
      m_processor.error(XPATHErrorResources.ER_PREFIX_MUST_RESOLVE,
                 new String[] {prefix});  


      
    }

    return -1;
  }
}
"
org.apache.xalan.templates.ElemExsltFunction,10,4,0,16,31,15,4,12,10,0.666666667,198,1.0,1,0.960176991,0.25,4,7,18.5,1,0.9,3,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.extensions.ExtensionNamespaceSupport;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;



public class ElemExsltFunction extends ElemTemplate
{
  
  
  private boolean m_isResultSet = false;
  
  
  private XObject m_result;
  
  
  private int m_callerFrameSize = 0;
  
  
  public int getXSLToken()
  {
    return Constants.EXSLT_ELEMNAME_FUNCTION;
  }

    
  public String getNodeName()
  {
    return Constants.EXSLT_ELEMNAME_FUNCTION_STRING;
  }
  
  public void execute(TransformerImpl transformer, XObject[] args)
          throws TransformerException
  {
    
    m_isResultSet = false;
    m_result = null;
    
    XPathContext xctxt = transformer.getXPathContext();
    VariableStack vars = xctxt.getVarStack();
    
    
    
    int oldStackFrame = vars.getStackFrame();
    vars.setStackFrame(m_callerFrameSize + oldStackFrame);
    
    
    NodeList children = this.getChildNodes();
    int numparams =0;
    for (int i = 0; i < args.length; i ++)
    {
      Node child = children.item(i);
      if (children.item(i) instanceof ElemParam)
      {
        numparams++;
        ElemParam param = (ElemParam)children.item(i);
        vars.setLocalVariable (param.getIndex(), args[i]);
      }
    }
    if (numparams < args.length)
      throw new TransformerException (""function called with too many args"");

    
    
    
    
    
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
    
    transformer.executeChildTemplates(this, true);
    
    
    vars.setStackFrame(oldStackFrame);
    m_callerFrameSize = 0;

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
    
    
    
    
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    
    
    String namespace = getName().getNamespace();
    String handlerClass = ""org.apache.xalan.extensions.ExtensionHandlerExsltFunction"";    
    Object[] args ={namespace, sroot};
    ExtensionNamespaceSupport extNsSpt = 
                         new ExtensionNamespaceSupport(namespace, handlerClass, args);
    sroot.getExtensionNamespacesManager().registerExtension(extNsSpt);
    
    
    if (!(namespace.equals(Constants.S_EXSLT_FUNCTIONS_URL)))
    {
      namespace = Constants.S_EXSLT_FUNCTIONS_URL;
      args = new Object[]{namespace, sroot};
      extNsSpt = new ExtensionNamespaceSupport(namespace, handlerClass, args);
      sroot.getExtensionNamespacesManager().registerExtension(extNsSpt);
    }
  }
  
  
  public XObject getResult()
  {
    return m_result;
  }
  
  
  public void setResult(XObject result)
  {
    m_isResultSet = true;
    m_result = result;
  }
  
  
  public boolean isResultSet()
  {
    return m_isResultSet;
  }
  
  
  public void clearResult()
  {
    m_isResultSet = false;
    m_result = null;    
  }
  
  
  public void setCallerFrameSize(int callerFrameSize)
  {
    m_callerFrameSize = callerFrameSize;
  }
}"
org.apache.xml.utils.XMLStringFactoryDefault,6,2,0,4,10,13,0,4,5,0.8,41,1.0,1,0.5,0.4,0,0,5.666666667,1,0.6667,0,"
package org.apache.xml.utils;


public class XMLStringFactoryDefault extends XMLStringFactory
{
  
  private static final XMLStringDefault EMPTY_STR = new XMLStringDefault("""");
  
  
  public XMLString newstr(String string)
  {
    return new XMLStringDefault(string);
  }

  
  public XMLString newstr(FastStringBuffer fsb, int start, int length)
  {
    return new XMLStringDefault(fsb.getString(start, length));
  }

  
  public XMLString newstr(char[] string, int start, int length)
  {
    return new XMLStringDefault(new String(string, start, length));
  }
                                   
  
  public XMLString emptystr()
  {
    return EMPTY_STR;
  }
}
"
org.apache.xml.dtm.ref.CoroutineParser,8,1,0,1,8,28,0,1,8,2.0,8,0.0,0,0.0,0.28125,0,0,0.0,1,1.0,0,"

package org.apache.xml.dtm.ref;

import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;


public interface CoroutineParser {

    
    public int getParserCoroutineID();

    
    public CoroutineManager getCoroutineManager();

  
  public void setContentHandler(ContentHandler handler);

  
  public void setLexHandler(org.xml.sax.ext.LexicalHandler handler);

  

  
  
  public Object doParse(InputSource source, int appCoroutine);

  
  public Object doMore (boolean parsemore, int appCoroutine);

  
  public void doTerminate(int appCoroutine);


    
  public void init( CoroutineManager co, int appCoroutineID, XMLReader parser );

} 
"
org.apache.xpath.operations.Variable,16,2,1,26,51,50,8,19,16,0.746666667,356,0.8,1,0.666666667,0.1875,2,10,20.9375,9,2.25,1,"
package org.apache.xpath.operations;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.QName;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.axes.PathComponent;
import org.apache.xpath.axes.WalkerFactory;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;



public class Variable extends Expression implements PathComponent
{
  
  private boolean m_fixUpWasCalled = false;

  
  protected QName m_qname;
  
  
  protected int m_index;
  
  
  public void setIndex(int index)
  {
  	m_index = index;
  }
  
  
  public int getIndex()
  {
  	return m_index;
  }
  
  
  public void setIsGlobal(boolean isGlobal)
  {
  	m_isGlobal = isGlobal;
  }
  
  
  public boolean getGlobal()
  {
  	return m_isGlobal;
  }

  
  

  
  protected boolean m_isGlobal = false;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_fixUpWasCalled = true;
    int sz = vars.size();

    for (int i = vars.size()-1; i >= 0; i--) 
    {
      QName qn = (QName)vars.elementAt(i);
      
      if(qn.equals(m_qname))
      {
        
        if(i < globalsSize)
        {
          m_isGlobal = true;
          m_index = i;
        }
        else
        {
          m_index = i-globalsSize;
        }
          
        return;
      }
    }
    
    java.lang.String msg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_COULD_NOT_FIND_VAR, 
                                             new Object[]{m_qname.toString()});
                                             
    TransformerException te = new TransformerException(msg, this);
                                             
    throw new org.apache.xml.utils.WrappedRuntimeException(te);
    
  }


  
  public void setQName(QName qname)
  {
    m_qname = qname;
  }
  
  
  public QName getQName()
  {
    return m_qname;
  }
  
  
  public XObject execute(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
  	return execute(xctxt, false);
  }


  
  public XObject execute(XPathContext xctxt, boolean destructiveOK) throws javax.xml.transform.TransformerException
  {
  	org.apache.xml.utils.PrefixResolver xprefixResolver = xctxt.getNamespaceContext();

    
    
    if(m_fixUpWasCalled)
    {    
      XObject result;
      if(m_isGlobal)
        result = xctxt.getVarStack().getGlobalVariable(xctxt, m_index, destructiveOK);
      else
        result = xctxt.getVarStack().getLocalVariable(xctxt, m_index, destructiveOK);
  
      if (null == result)
      {
        
        warn(xctxt, XPATHErrorResources.WG_ILLEGAL_VARIABLE_REFERENCE,
             new Object[]{ m_qname.getLocalPart() });  
  
  
  
        
        result = new XNodeSet(xctxt.getDTMManager());
      }
  
      return result;
    }
    else
    {
      
      
      synchronized(this)
      {
      	org.apache.xalan.templates.ElemVariable vvar= getElemVariable();
      	if(null != vvar)
      	{
          m_index = vvar.getIndex();
          m_isGlobal = vvar.getIsTopLevel();
          m_fixUpWasCalled = true;
          return execute(xctxt);
      	}
      }
      throw new javax.xml.transform.TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VAR_NOT_RESOLVABLE, new Object[]{m_qname.toString()})); 
    }
  }
  
  
  public org.apache.xalan.templates.ElemVariable getElemVariable()
  {
  	
    
    
    
    
    
    
    org.apache.xpath.ExpressionNode owner = getExpressionOwner();

    if (null != owner && owner instanceof org.apache.xalan.templates.ElemTemplateElement)
    {

      org.apache.xalan.templates.ElemVariable vvar;

      org.apache.xalan.templates.ElemTemplateElement prev = 
        (org.apache.xalan.templates.ElemTemplateElement) owner;

      if (!(prev instanceof org.apache.xalan.templates.Stylesheet))
      {            
        while ( !(prev.getParentNode() instanceof org.apache.xalan.templates.Stylesheet) )
        {
          org.apache.xalan.templates.ElemTemplateElement savedprev = prev;

          while (null != (prev = prev.getPreviousSiblingElem()))
          {
            if(prev instanceof org.apache.xalan.templates.ElemVariable)
            {
              vvar = (org.apache.xalan.templates.ElemVariable) prev;
            
              if (vvar.getName().equals(m_qname))
              {
                return vvar;
              }
            }
          }
          prev = savedprev.getParentElem();
        }
      }

      vvar = prev.getStylesheetRoot().getVariableOrParamComposed(m_qname);
      if (null != vvar)
      {
        return vvar;
      }

    }
    return null;

  }
  
  
  public boolean isStableNumber()
  {
    return true;
  }
  
  
  public int getAnalysisBits()
  {
  	org.apache.xalan.templates.ElemVariable vvar = getElemVariable();
  	if(null != vvar)
  	{
  		XPath xpath = vvar.getSelect();
  		if(null != xpath)
  		{
	  		Expression expr = xpath.getExpression();
	  		if(null != expr && expr instanceof PathComponent)
	  		{
	  			return ((PathComponent)expr).getAnalysisBits();
	  		}
  		}
  	}
    return WalkerFactory.BIT_FILTER;
  }


  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	visitor.visitVariableRef(owner, this);
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	if(!m_qname.equals(((Variable)expr).m_qname))
  		return false;
  		
  	
  	
    if(getElemVariable() != ((Variable)expr).getElemVariable())
    	return false;
  		
  	return true;
  }
  
  static final java.lang.String PSUEDOVARNAMESPACE = ""http:
  
  
  public boolean isPsuedoVarRef()
  {
  	java.lang.String ns = m_qname.getNamespaceURI();
  	if((null != ns) && ns.equals(PSUEDOVARNAMESPACE))
  	{
  		if(m_qname.getLocalName().startsWith(""#""))
  			return true;
  	}
  	return false;
  }
  

}
"
org.apache.xpath.compiler.XPathDumper,1,1,0,0,2,0,0,0,1,2.0,4,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xpath.compiler;



public class XPathDumper
{

  
}
"
org.apache.xml.dtm.ref.DTMManagerDefault,16,2,1,27,85,76,8,22,16,0.8,728,0.8,2,0.558823529,0.215909091,1,1,44.1875,25,4.0625,0,"
package org.apache.xml.dtm.ref;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Source;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMException;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.dtm.ref.dom2dtm.DOM2DTM;
import org.apache.xml.dtm.ref.sax2dtm.SAX2DTM;
import org.apache.xml.dtm.ref.sax2dtm.SAX2RTFDTM;
import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.XMLStringFactory;

import org.w3c.dom.Document;
import org.w3c.dom.Node;

import org.xml.sax.InputSource;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;


public class DTMManagerDefault extends DTMManager
{
  

  
  private static final boolean DUMPTREE = false;

  
  private static final boolean DEBUG = false;

  
  protected DTM m_dtms[] = new DTM[256];
	
  
  int m_dtm_offsets[] = new int[256];

  
  synchronized public void addDTM(DTM dtm, int id) {	addDTM(dtm,id,0); }

	
  
  synchronized public void addDTM(DTM dtm, int id, int offset)
  {
		if(id>=IDENT_MAX_DTMS)
		{
			
	    throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_DTMIDS_AVAIL, null)); 
		}
		
		
		
		
		
		
		int oldlen=m_dtms.length;
		if(oldlen<=id)
		{
			
			
			
			
			
			int newlen=Math.min((id+256),IDENT_MAX_DTMS);

			DTM new_m_dtms[] = new DTM[newlen];
			System.arraycopy(m_dtms,0,new_m_dtms,0,oldlen);
			m_dtms=new_m_dtms;
			int new_m_dtm_offsets[] = new int[newlen];
			System.arraycopy(m_dtm_offsets,0,new_m_dtm_offsets,0,oldlen);
			m_dtm_offsets=new_m_dtm_offsets;
		}
		
    m_dtms[id] = dtm;
		m_dtm_offsets[id]=offset;
    dtm.documentRegistration();
		
		
  }

  
  synchronized public int getFirstFreeDTMID()
  {
    int n = m_dtms.length;
    for (int i = 1; i < n; i++)
    {
      if(null == m_dtms[i])
      {
        return i;
      }
    }
		return n; 
  }

  
  private ExpandedNameTable m_expandedNameTable =
    new ExpandedNameTable();

  
  public DTMManagerDefault(){}


  
  synchronized public DTM getDTM(Source source, boolean unique,
                                 DTMWSFilter whiteSpaceFilter,
                                 boolean incremental, boolean doIndexing)
  {

    if(DEBUG && null != source)
      System.out.println(""Starting ""+
                         (unique ? ""UNIQUE"" : ""shared"")+
                         "" source: ""+source.getSystemId()
                         );

    XMLStringFactory xstringFactory = m_xsf;
    int dtmPos = getFirstFreeDTMID();
    int documentID = dtmPos << IDENT_DTM_NODE_BITS;

    if ((null != source) && source instanceof DOMSource)
    {
      DOM2DTM dtm = new DOM2DTM(this, (DOMSource) source, documentID,
                                whiteSpaceFilter, xstringFactory, doIndexing);

      addDTM(dtm, dtmPos, 0);

      
      
      
      

      return dtm;
    }
    else
    {
      boolean isSAXSource = (null != source)
        ? (source instanceof SAXSource) : true;
      boolean isStreamSource = (null != source)
        ? (source instanceof StreamSource) : false;

      if (isSAXSource || isStreamSource)
      {
        XMLReader reader;
        InputSource xmlSource;

        if (null == source)
        {
          xmlSource = null;
          reader = null;
        }
        else
        {
          reader = getXMLReader(source);
          xmlSource = SAXSource.sourceToInputSource(source);

          String urlOfSource = xmlSource.getSystemId();

          if (null != urlOfSource)
          {
            try
            {
              urlOfSource = SystemIDResolver.getAbsoluteURI(urlOfSource);
            }
            catch (Exception e)
            {

              
              System.err.println(""Can not absolutize URL: "" + urlOfSource);
            }

            xmlSource.setSystemId(urlOfSource);
          }
        }

        SAX2DTM dtm;
        if(source==null && unique && !incremental && !doIndexing)
        {
          
          
          
          
          
          
          
          dtm = new SAX2RTFDTM(this, source, documentID, whiteSpaceFilter,
                               xstringFactory, doIndexing);
        }
        
        else 
        {
          dtm = new SAX2DTM(this, source, documentID, whiteSpaceFilter,
                            xstringFactory, doIndexing);
        }

        
        
        
        addDTM(dtm, dtmPos, 0);


        boolean haveXercesParser =
          (null != reader)
          && (reader.getClass().getName().equals(""org.apache.xerces.parsers.SAXParser"") );
        
        if (haveXercesParser)
          incremental = true;  
        
        
        
        if (m_incremental && incremental )
        {
          IncrementalSAXSource coParser=null;

          if (haveXercesParser)
          {
            
            try {
              coParser=org.apache.xml.dtm.ref.IncrementalSAXSource_Xerces.createIncrementalSAXSource();
            }  catch( Exception ex ) {
              ex.printStackTrace();
              coParser=null;
            }
          }

          if( coParser==null ) {
            
            if (null == reader)
              coParser = new IncrementalSAXSource_Filter();
            else
            {
              IncrementalSAXSource_Filter filter=new IncrementalSAXSource_Filter();
              filter.setXMLReader(reader);
              coParser=filter;
            }

          }

			
        
          
          
          dtm.setIncrementalSAXSource(coParser);

          if (null == xmlSource)
          {

            
            return dtm;
          }

          if(null == reader.getErrorHandler())
            reader.setErrorHandler(dtm);
          reader.setDTDHandler(dtm);

          try
          {

            
            
            coParser.startParse(xmlSource);
          }
          catch (RuntimeException re)
          {

            dtm.clearCoRoutine();

            throw re;
          }
          catch (Exception e)
          {

            dtm.clearCoRoutine();

            throw new org.apache.xml.utils.WrappedRuntimeException(e);
          }
        }
        else
        {
          if (null == reader)
          {

            
            return dtm;
          }

          
          reader.setContentHandler(dtm);
          reader.setDTDHandler(dtm);
          if(null == reader.getErrorHandler())
            reader.setErrorHandler(dtm);

          try
          {
            reader.setProperty(
                               ""http:
          }
          catch (SAXNotRecognizedException e){}
          catch (SAXNotSupportedException e){}

          try
          {
            reader.parse(xmlSource);
          }
          catch (RuntimeException re)
          {

            dtm.clearCoRoutine();

            throw re;
          }
          catch (Exception e)
          {

            dtm.clearCoRoutine();

            throw new org.apache.xml.utils.WrappedRuntimeException(e);
          }
        }

        if (DUMPTREE)
        {
          System.out.println(""Dumping SAX2DOM"");
          dtm.dumpDTM(System.err);
        }

        return dtm;
      }
      else
      {

        
        
        throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_NOT_SUPPORTED, new Object[]{source})); 
      }
    }
  }

  
  synchronized public int getDTMHandleFromNode(org.w3c.dom.Node node)
  {
    if(null == node)
      throw new IllegalArgumentException(XMLMessages.createXMLMessage(XMLErrorResources.ER_NODE_NON_NULL, null)); 

    if (node instanceof org.apache.xml.dtm.ref.DTMNodeProxy)
      return ((org.apache.xml.dtm.ref.DTMNodeProxy) node).getDTMNodeNumber();
		
    else
    {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
			
			
			
			
			
			
			
			int max = m_dtms.length;
      for(int i = 0; i < max; i++)
        {
          DTM thisDTM=m_dtms[i];
          if((null != thisDTM) && thisDTM instanceof DOM2DTM)
          {
            int handle=((DOM2DTM)thisDTM).getHandleOfNode(node);
            if(handle!=DTM.NULL) return handle;
          }
         }

			
			
			
			
			
			
			
			
			
			
			
			
			
			
			

			
      
      
      Node root = node;
      Node p = (root.getNodeType() == Node.ATTRIBUTE_NODE) ? ((org.w3c.dom.Attr)root).getOwnerElement() : root.getParentNode();
      for (; p != null; p = p.getParentNode())
      {
        root = p;
      }

      DOM2DTM dtm = (DOM2DTM) getDTM(new javax.xml.transform.dom.DOMSource(root),
																		 false, null, true, true);

      int handle;
      
      if(node instanceof org.apache.xml.dtm.ref.dom2dtm.DOM2DTMdefaultNamespaceDeclarationNode)
      {
				
				
				
				handle=dtm.getHandleOfNode(((org.w3c.dom.Attr)node).getOwnerElement());
				handle=dtm.getAttributeNode(handle,node.getNamespaceURI(),node.getLocalName());
      }
      else
				handle = ((DOM2DTM)dtm).getHandleOfNode(node);

      if(DTM.NULL == handle)
        throw new RuntimeException(XMLMessages.createXMLMessage(XMLErrorResources.ER_COULD_NOT_RESOLVE_NODE, null)); 

      return handle;
    }
  }

  
  synchronized public XMLReader getXMLReader(Source inputSource)
  {

    try
    {
      XMLReader reader = (inputSource instanceof SAXSource)
                         ? ((SAXSource) inputSource).getXMLReader() : null;

      if (null == reader)
      {
        try
        {
          javax.xml.parsers.SAXParserFactory factory =
            javax.xml.parsers.SAXParserFactory.newInstance();

          factory.setNamespaceAware(true);

          javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser();

          reader = jaxpParser.getXMLReader();
        }
        catch (javax.xml.parsers.ParserConfigurationException ex)
        {
          throw new org.xml.sax.SAXException(ex);
        }
        catch (javax.xml.parsers.FactoryConfigurationError ex1)
        {
          throw new org.xml.sax.SAXException(ex1.toString());
        }
        catch (NoSuchMethodError ex2){}
        catch (AbstractMethodError ame){}

        if (null == reader)
          reader = XMLReaderFactory.createXMLReader();
      }

      try
      {
        reader.setFeature(""http:
                          true);
      }
      catch (org.xml.sax.SAXException se)
      {

        
        
      }

      return reader;
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new DTMException(se.getMessage(), se);
    }
  }

  
  synchronized public DTM getDTM(int nodeHandle)
  {
    try
    {
      
      return m_dtms[nodeHandle >>> IDENT_DTM_NODE_BITS];
    }
    catch(java.lang.ArrayIndexOutOfBoundsException e)
    {
      if(nodeHandle==DTM.NULL)
				return null;		
      else
				throw e;		
    }    
  }

  
  synchronized public int getDTMIdentity(DTM dtm)
  {
	
	
	if(dtm instanceof DTMDefaultBase)
	{
		DTMDefaultBase dtmdb=(DTMDefaultBase)dtm;
		if(dtmdb.getManager()==this)
			return dtmdb.getDTMIDs().elementAt(0);
		else
			return -1;
	}
				
    int n = m_dtms.length;

    for (int i = 0; i < n; i++)
    {
      DTM tdtm = m_dtms[i];

      if (tdtm == dtm && m_dtm_offsets[i]==0)
        return i << IDENT_DTM_NODE_BITS;
    }

    return -1;
  }

  
  synchronized public boolean release(DTM dtm, boolean shouldHardDelete)
  {
    if(DEBUG)
    {
      System.out.println(""Releasing ""+
			 (shouldHardDelete ? ""HARD"" : ""soft"")+
			 "" dtm=""+
			 
			 
			 dtm.getDocumentBaseURI()
			 );
    }

    if (dtm instanceof SAX2DTM)
    {
      ((SAX2DTM) dtm).clearCoRoutine();
    }

		
		
		
		
		
		
		
		
		if(dtm instanceof DTMDefaultBase)
		{
			org.apache.xml.utils.SuballocatedIntVector ids=((DTMDefaultBase)dtm).getDTMIDs();
			for(int i=ids.size()-1;i>=0;--i)
				m_dtms[ids.elementAt(i)>>>DTMManager.IDENT_DTM_NODE_BITS]=null;
		}
		else
		{
			int i = getDTMIdentity(dtm);
		    if (i >= 0)
			{
				m_dtms[i >>> DTMManager.IDENT_DTM_NODE_BITS] = null;
			}
		}

    dtm.documentRelease();
    return true;
  }

  
  synchronized public DTM createDocumentFragment()
  {

    try
    {
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

      dbf.setNamespaceAware(true);

      DocumentBuilder db = dbf.newDocumentBuilder();
      Document doc = db.newDocument();
      Node df = doc.createDocumentFragment();

      return getDTM(new DOMSource(df), true, null, false, false);
    }
    catch (Exception e)
    {
      throw new DTMException(e);
    }
  }

  
  synchronized public DTMIterator createDTMIterator(int whatToShow, DTMFilter filter,
                                       boolean entityReferenceExpansion)
  {

    
    return null;
  }

  
  synchronized public DTMIterator createDTMIterator(String xpathString,
                                       PrefixResolver presolver)
  {

    
    return null;
  }

  
  synchronized public DTMIterator createDTMIterator(int node)
  {

    
    return null;
  }

  
  synchronized public DTMIterator createDTMIterator(Object xpathCompiler, int pos)
  {

    
    return null;
  }

  
  public ExpandedNameTable getExpandedNameTable(DTM dtm)
  {
    return m_expandedNameTable;
  }
}
"
org.apache.xalan.processor.ProcessorUnknown,3,5,0,3,4,3,1,2,3,2.0,8,0.0,0,0.990697674,0.666666667,1,2,1.666666667,1,0.6667,2,"
package org.apache.xalan.processor;

import org.xml.sax.Attributes;


public class ProcessorUnknown extends ProcessorTemplateElem
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException{}

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException{}
}
"
org.apache.xml.dtm.ref.ChunkedIntArray,9,1,0,3,24,0,2,2,0,0.892857143,353,0.0,1,0.0,0.62962963,0,0,37.44444444,3,1.4444,0,"
package org.apache.xml.dtm.ref;
 
import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;


final class ChunkedIntArray
{
  final int slotsize=4; 
  
  
  static final int lowbits=10; 
  static final int chunkalloc=1<<lowbits;
  static final int lowmask=chunkalloc-1;
  
  ChunksVector chunks=new ChunksVector();
  final int fastArray[] = new int[chunkalloc];
  int lastUsed=0;

  
  ChunkedIntArray(int slotsize)
  {
    if(this.slotsize<slotsize)
      throw new ArrayIndexOutOfBoundsException(XMLMessages.createXMLMessage(XMLErrorResources.ER_CHUNKEDINTARRAY_NOT_SUPPORTED, new Object[]{Integer.toString(slotsize)})); 
    else if (this.slotsize>slotsize)
      System.out.println(""*****WARNING: ChunkedIntArray(""+slotsize+"") wasting ""+(this.slotsize-slotsize)+"" words per slot"");
    chunks.addElement(fastArray);
  }
  
  int appendSlot(int w0, int w1, int w2, int w3)
  {
    
    {
      final int slotsize=4;
      int newoffset = (lastUsed+1)*slotsize;
      int chunkpos = newoffset >> lowbits;
      int slotpos = (newoffset & lowmask);

      
      if (chunkpos > chunks.size() - 1)
        chunks.addElement(new int[chunkalloc]);
      int[] chunk = chunks.elementAt(chunkpos);
      chunk[slotpos] = w0;
      chunk[slotpos+1] = w1;
      chunk[slotpos+2] = w2;
      chunk[slotpos+3] = w3;

      return ++lastUsed;
    }
  }
  
  int readEntry(int position, int offset) throws ArrayIndexOutOfBoundsException
  {
    
    {
      
      if (offset>=slotsize)
        throw new ArrayIndexOutOfBoundsException(XMLMessages.createXMLMessage(XMLErrorResources.ER_OFFSET_BIGGER_THAN_SLOT, null)); 
      position*=slotsize;
      int chunkpos = position >> lowbits;
      int slotpos = position & lowmask;
      int[] chunk = chunks.elementAt(chunkpos);
      return chunk[slotpos + offset];
    }
  }
  
  
  
  
  
  
  
  int specialFind(int startPos, int position)
  {
          
          
          int ancestor = startPos;
          while(ancestor > 0)
          {
                
                ancestor*=slotsize;
                int chunkpos = ancestor >> lowbits;
                int slotpos = ancestor & lowmask;
                int[] chunk = chunks.elementAt(chunkpos);
                                                        
                
                
                
                ancestor = chunk[slotpos + 1];

                if(ancestor == position)
                         break;
          }

          if (ancestor <= 0) 
          {
                  return position;
          }
          return -1;
  }
  
  
  int slotsUsed()
  {
    return lastUsed;
  }

  
  void discardLast()
  {
    --lastUsed;
  }

  
  void writeEntry(int position, int offset, int value) throws ArrayIndexOutOfBoundsException
  {
    
    {
      if (offset >= slotsize)
        throw new ArrayIndexOutOfBoundsException(XMLMessages.createXMLMessage(XMLErrorResources.ER_OFFSET_BIGGER_THAN_SLOT, null)); 
      position*=slotsize;
      int chunkpos = position >> lowbits;
      int slotpos = position & lowmask;
      int[] chunk = chunks.elementAt(chunkpos);
      chunk[slotpos + offset] = value; 
    }
  }

  
  void writeSlot(int position, int w0, int w1, int w2, int w3)
  {
      position *= slotsize;
      int chunkpos = position >> lowbits;
      int slotpos = (position & lowmask);

    
    if (chunkpos > chunks.size() - 1)
      chunks.addElement(new int[chunkalloc]);
    int[] chunk = chunks.elementAt(chunkpos);
    chunk[slotpos] = w0;
    chunk[slotpos + 1] = w1;
    chunk[slotpos + 2] = w2;
    chunk[slotpos + 3] = w3;
  }

  
  void readSlot(int position, int[] buffer)
  {
    
    {
      
      position *= slotsize;
      int chunkpos = position >> lowbits;
      int slotpos = (position & lowmask);

      
      if (chunkpos > chunks.size() - 1)
        chunks.addElement(new int[chunkalloc]);
      int[] chunk = chunks.elementAt(chunkpos);
      System.arraycopy(chunk,slotpos,buffer,0,slotsize);
    }
  }

  class ChunksVector
  {
    final int BLOCKSIZE = 64;
    int[] m_map[] = new int[BLOCKSIZE][];
    int m_mapSize = BLOCKSIZE;
    int pos = 0;
    
    ChunksVector()
    {
    }
    
    final int size()
    {
      return pos;
    }
    
    void addElement(int[] value)
    {
      if(pos >= m_mapSize)
      {
        int orgMapSize = m_mapSize;
        while(pos >= m_mapSize)
          m_mapSize+=BLOCKSIZE;
        int[] newMap[] = new int[m_mapSize][];
        System.arraycopy(m_map, 0, newMap, 0, orgMapSize);
        m_map = newMap;
      }
      
      
      m_map[pos] = value;
      pos++;
    }
    
    final int[] elementAt(int pos)
    {
      return m_map[pos];
    }
  }
}
"
org.apache.xml.utils.ElemDesc,4,1,0,0,10,0,0,0,0,1.266666667,90,0.0,0,0.0,0.833333333,0,0,15.25,4,2.0,1,"
package org.apache.xml.utils;

import java.util.Hashtable;


class ElemDesc
{

  
  Hashtable m_attrs = null;

  
  int m_flags;

  
  static final int EMPTY = (1 << 1);

  
  static final int FLOW = (1 << 2);

  
  static final int BLOCK = (1 << 3);

  
  static final int BLOCKFORM = (1 << 4);

  
  static final int BLOCKFORMFIELDSET = (1 << 5);

  
  static final int CDATA = (1 << 6);

  
  static final int PCDATA = (1 << 7);

  
  static final int RAW = (1 << 8);

  
  static final int INLINE = (1 << 9);

  
  static final int INLINEA = (1 << 10);

  
  static final int INLINELABEL = (1 << 11);

  
  static final int FONTSTYLE = (1 << 12);

  
  static final int PHRASE = (1 << 13);

  
  static final int FORMCTRL = (1 << 14);

  
  static final int SPECIAL = (1 << 15);

  
  static final int ASPECIAL = (1 << 16);

  
  static final int HEADMISC = (1 << 17);

  
  static final int HEAD = (1 << 18);

  
  static final int LIST = (1 << 19);

  
  static final int PREFORMATTED = (1 << 20);

  
  static final int WHITESPACESENSITIVE = (1 << 21);

  
  static final int ATTRURL = (1 << 1);

  
  static final int ATTREMPTY = (1 << 2);

  
  ElemDesc(int flags)
  {
    m_flags = flags;
  }

  
  boolean is(int flags)
  {
    
    return (m_flags & flags) != 0;
  }

  
  void setAttr(String name, int flags)
  {

    if (null == m_attrs)
      m_attrs = new Hashtable();

    m_attrs.put(name, new Integer(flags));
  }

  
  boolean isAttrFlagSet(String name, int flags)
  {

    if (null != m_attrs)
    {
      Integer _flags = (Integer) m_attrs.get(name);

      if (null != _flags)
      {
        return (_flags.intValue() & flags) != 0;
      }
    }

    return false;
  }
}
"
org.apache.xalan.xsltc.Translet,9,1,0,20,9,36,16,4,9,2.0,9,0.0,0,0.0,0.296296296,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.serializer.SerializationHandler;

public interface Translet {

    public void transform(DOM document, SerializationHandler handler)
	throws TransletException;
    public void transform(DOM document, SerializationHandler[] handlers)
	throws TransletException;
    public void transform(DOM document, DTMAxisIterator iterator,
			  SerializationHandler handler)
	throws TransletException;

    public Object addParameter(String name, Object value);

    public void buildKeys(DOM document, DTMAxisIterator iterator,
			  SerializationHandler handler, int root)
	throws TransletException;
    public void addAuxiliaryClass(Class auxClass);
    public Class getAuxiliaryClass(String className);
    public String[] getNamesArray();
    public String[] getNamespaceArray();
}
"
org.apache.xalan.xsltc.compiler.util.ObjectType,18,2,0,28,52,91,6,23,16,0.68627451,271,0.666666667,0,0.6875,0.222222222,2,3,13.88888889,2,1.0,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.IFNULL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.runtime.TransletLoader;

public final class ObjectType extends Type {

    private String _javaClassName = ""java.lang.Object"";
    private Class  _clazz = java.lang.Object.class;

    
    protected ObjectType() {}

    
    public ObjectType(String javaClassName) {
	_javaClassName = javaClassName;
	  
	try {
	  TransletLoader loader = new TransletLoader();
	  _clazz = loader.loadClass(javaClassName);
	}
	catch (ClassNotFoundException e) {
	  _clazz = null;
	}
    }
    
    public ObjectType(Class clazz) {
        _clazz = clazz;
        _javaClassName = clazz.getName();	
    }

    public int hashCode() {
        return toString().hashCode();
    }

    public boolean equals(Object obj) {
        return (obj instanceof ObjectType);
    }

    public String getJavaClassName() {
	return _javaClassName;
    }
    
    public Class getJavaClass() {
        return _clazz;	
    }

    public String toString() {
	return _javaClassName;
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	final StringBuffer result = new StringBuffer(""L"");
	result.append(_javaClassName.replace('.', '/')).append(';');
	return result.toString();
    }

    public org.apache.bcel.generic.Type toJCType() {
	return Util.getJCRefType(toSignature());
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	il.append(DUP);
	final BranchHandle ifNull = il.append(new IFNULL(null));
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(_javaClassName,
						    ""toString"",
						    ""()"" + STRING_SIG)));
	final BranchHandle gotobh = il.append(new GOTO(null));
	ifNull.setTarget(il.append(POP));
	il.append(new PUSH(cpg, """"));
	gotobh.setTarget(il.append(NOP));
    }

     
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
        if (clazz.isAssignableFrom(_clazz))
	    methodGen.getInstructionList().append(NOP);
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
			       toString(), clazz.getClass().toString());
	    classGen.getParser().reportError(Constants.FATAL, err);	  	
	}
    }
	
    
    public void translateFrom(ClassGenerator classGen, 
			      MethodGenerator methodGen, Class clazz) {
	methodGen.getInstructionList().append(NOP);
    }

    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}
"
org.apache.xalan.xsltc.compiler.BinOpExpr,7,3,0,14,36,0,0,14,6,0.814814815,242,0.444444444,2,0.934210526,0.285714286,2,8,32.28571429,3,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class BinOpExpr extends Expression {
    public static final int PLUS  = 0;
    public static final int MINUS = 1;
    public static final int TIMES = 2;
    public static final int DIV   = 3;
    public static final int MOD   = 4;
	
    private static final String[] Ops = {
	""+"", ""-"", ""*"", ""/"", ""%""
    };

    private int _op;
    private Expression _left, _right;
	
    public BinOpExpr(int op, Expression left, Expression right) {
	_op = op;
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    
    public boolean hasPositionCall() {
	if (_left.hasPositionCall()) return true;
	if (_right.hasPositionCall()) return true;
	return false;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tleft = _left.typeCheck(stable); 
	final Type tright = _right.typeCheck(stable);
	final MethodType ptype = lookupPrimop(stable, Ops[_op],
					      new MethodType(Type.Void,
							     tleft, tright)); 
	if (ptype != null) {
	    final Type arg1 = (Type) ptype.argsType().elementAt(0);
	    if (!arg1.identicalTo(tleft)) {
		_left = new CastExpr(_left, arg1);
	    }
	    final Type arg2 = (Type) ptype.argsType().elementAt(1);
	    if (!arg2.identicalTo(tright)) {
		_right = new CastExpr(_right, arg1);
	    }
	    return _type = ptype.resultType();
	}
	throw new TypeCheckError(this);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();

	_left.translate(classGen, methodGen);
	_right.translate(classGen, methodGen);

	switch (_op) {
	case PLUS:
	    il.append(_type.ADD());
	    break;
	case MINUS:
	    il.append(_type.SUB());
	    break;
	case TIMES:
	    il.append(_type.MUL());
	    break;
	case DIV:
	    il.append(_type.DIV());
	    break;
	case MOD:
	    il.append(_type.REM());
	    break;
	default:
	    ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_BINARY_OP_ERR, this);
	    getParser().reportError(Constants.ERROR, msg);
	}
    }

    public String toString() {
	return Ops[_op] + '(' + _left + "", "" + _right + ')';
    }
} 
"
org.apache.xpath.functions.Function,9,2,7,21,15,36,15,8,8,2.0,51,0.0,0,0.789473684,0.285714286,1,7,4.666666667,2,1.1111,1,"
package org.apache.xpath.functions;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.objects.XObject;


public abstract class Function extends Expression
{

  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {
			
      reportWrongNumberArgs();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum != 0)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""zero"", null));
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    
    System.out.println(""Error! Function.execute should not be called!"");

    return null;
  }
  
  
  public void callArgVisitors(XPathVisitor visitor)
  {
  }

  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	if(visitor.visitFunction(owner, this))
  	{
  		callArgVisitors(visitor);
  	}
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	return true;
  }

  
  public void postCompileStep(Compiler compiler)
  {
    
  }
}
"
org.apache.xalan.extensions.ExtensionHandlerJavaPackage,7,3,0,10,47,9,0,10,6,1.0,658,0.0,0,0.571428571,0.349206349,2,5,92.71428571,7,1.8571,1,"
package org.apache.xalan.extensions;

import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.objects.XObject;




public class ExtensionHandlerJavaPackage extends ExtensionHandlerJava
{

  
  public ExtensionHandlerJavaPackage(String namespaceUri,
                                     String scriptLang,
                                     String className)
  {
    super(namespaceUri, scriptLang, className);
  }


  

  public boolean isFunctionAvailable(String function) 
  {
    try
    {
      String fullName = m_className + function;
      int lastDot = fullName.lastIndexOf(""."");
      if (lastDot >= 0)
      {
        Class myClass = getClassForName(fullName.substring(0, lastDot));
        Method[] methods = myClass.getMethods();
        int nMethods = methods.length;
        function = fullName.substring(lastDot + 1);
        for (int i = 0; i < nMethods; i++)
        {
          if (methods[i].getName().equals(function))
            return true;
        }
      }
    }
    catch (ClassNotFoundException cnfe) {}

    return false;
  }


  

  public boolean isElementAvailable(String element) 
  {
    try
    {
      String fullName = m_className + element;
      int lastDot = fullName.lastIndexOf(""."");
      if (lastDot >= 0)
      {
        Class myClass = getClassForName(fullName.substring(0, lastDot));
        Method[] methods = myClass.getMethods();
        int nMethods = methods.length;
        element = fullName.substring(lastDot + 1);
        for (int i = 0; i < nMethods; i++)
        {
          if (methods[i].getName().equals(element))
          {
            Class[] paramTypes = methods[i].getParameterTypes();
            if ( (paramTypes.length == 2)
              && paramTypes[0].isAssignableFrom(
                                     org.apache.xalan.extensions.XSLProcessorContext.class)
              && paramTypes[1].isAssignableFrom(
                                       org.apache.xalan.templates.ElemExtensionCall.class) )
            {
              return true;
            }
          }
        }
      }
    }
    catch (ClassNotFoundException cnfe) {}

    return false;
  }


  

  public Object callFunction (String funcName, 
                              Vector args, 
                              Object methodKey,
                              ExpressionContext exprContext)
    throws TransformerException 
  {

    String className;
    String methodName;
    Class  classObj;
    Object targetObject;
    int lastDot = funcName.lastIndexOf(""."");
    Object[] methodArgs;
    Object[][] convertedArgs;
    Class[] paramTypes;

    try
    {

      if (funcName.endsWith("".new"")) {                   

        methodArgs = new Object[args.size()];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i);
        }
        Constructor c = (Constructor) getFromCache(methodKey, null, methodArgs);
        if (c != null)
        {
          try
          {
            paramTypes = c.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            return c.newInstance(convertedArgs[0]);
          }
          catch (InvocationTargetException ite)
          {
            throw ite;
          }
          catch(Exception e)
          {
            
          }
        }
        className = m_className + funcName.substring(0, lastDot);
        try
        {
          classObj = getClassForName(className);
        }
        catch (ClassNotFoundException e) 
        {
          throw new TransformerException(e);
        }
        c = MethodResolver.getConstructor(classObj, 
                                          methodArgs,
                                          convertedArgs,
                                          exprContext);
        putToCache(methodKey, null, methodArgs, c);
        return c.newInstance(convertedArgs[0]);
      }

      else if (-1 != lastDot) {                         

        methodArgs = new Object[args.size()];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i);
        }
        Method m = (Method) getFromCache(methodKey, null, methodArgs);
        if (m != null)
        {
          try
          {
            paramTypes = m.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            return m.invoke(null, convertedArgs[0]);
          }
          catch (InvocationTargetException ite)
          {
            throw ite;
          }
          catch(Exception e)
          {
            
          }
        }
        className = m_className + funcName.substring(0, lastDot);
        methodName = funcName.substring(lastDot + 1);
        try
        {
          classObj = getClassForName(className);
        }
        catch (ClassNotFoundException e) 
        {
          throw new TransformerException(e);
        }
        m = MethodResolver.getMethod(classObj,
                                     methodName,
                                     methodArgs, 
                                     convertedArgs,
                                     exprContext,
                                     MethodResolver.STATIC_ONLY);
        putToCache(methodKey, null, methodArgs, m);
        return m.invoke(null, convertedArgs[0]);
      }

      else {                                            

        if (args.size() < 1)
        {
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_INSTANCE_MTHD_CALL_REQUIRES, new Object[]{funcName })); 
                                    
        }
        targetObject = args.elementAt(0);
        if (targetObject instanceof XObject)          
          targetObject = ((XObject) targetObject).object();
        methodArgs = new Object[args.size() - 1];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i+1);
        }
        Method m = (Method) getFromCache(methodKey, targetObject, methodArgs);
        if (m != null)
        {
          try
          {
            paramTypes = m.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            return m.invoke(targetObject, convertedArgs[0]);
          }
          catch (InvocationTargetException ite)
          {
            throw ite;
          }
          catch(Exception e)
          {
            
          }
        }
        classObj = targetObject.getClass();
        m = MethodResolver.getMethod(classObj,
                                     funcName,
                                     methodArgs, 
                                     convertedArgs,
                                     exprContext,
                                     MethodResolver.INSTANCE_ONLY);
        putToCache(methodKey, targetObject, methodArgs, m);
        return m.invoke(targetObject, convertedArgs[0]);
      }
    }
    catch (InvocationTargetException ite)
    {
      Throwable resultException = ite;
      Throwable targetException = ite.getTargetException();
 
      if (targetException instanceof TransformerException)
        throw ((TransformerException)targetException);
      else if (targetException != null)
        resultException = targetException;
            
      throw new TransformerException(resultException);
    }
    catch (Exception e)
    {
      
      throw new TransformerException(e);
    }
  }

  
  public Object callFunction(FuncExtFunction extFunction,
                             Vector args,
                             ExpressionContext exprContext)
      throws TransformerException
  {
    return callFunction(extFunction.getFunctionName(), args, 
                        extFunction.getMethodKey(), exprContext);
  }

  

  public void processElement (String localPart,
                              ElemTemplateElement element,
                              TransformerImpl transformer,
                              Stylesheet stylesheetTree,
                              Object methodKey)
    throws TransformerException, IOException
  {
    Object result = null;
    Class classObj;

    Method m = (Method) getFromCache(methodKey, null, null);
    if (null == m)
    {
      try
      {
        String fullName = m_className + localPart;
        int lastDot = fullName.lastIndexOf(""."");
        if (lastDot < 0)
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_ELEMENT_NAME, new Object[]{fullName })); 
        try
        {
          classObj = getClassForName(fullName.substring(0, lastDot));
        }
        catch (ClassNotFoundException e) 
        {
          throw new TransformerException(e);
        }
        localPart = fullName.substring(lastDot + 1);
        m = MethodResolver.getElementMethod(classObj, localPart);
        if (!Modifier.isStatic(m.getModifiers()))
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_ELEMENT_NAME_METHOD_STATIC, new Object[]{fullName })); 
      }
      catch (Exception e)
      {
        
        throw new TransformerException (e);
      }
      putToCache(methodKey, null, null, m);
    }

    XSLProcessorContext xpc = new XSLProcessorContext(transformer, 
                                                      stylesheetTree);

    try
    {
      result = m.invoke(null, new Object[] {xpc, element});
    }
    catch (InvocationTargetException ite)
    {
      Throwable resultException = ite;
      Throwable targetException = ite.getTargetException();
 
      if (targetException instanceof TransformerException)
        throw ((TransformerException)targetException);
      else if (targetException != null)
        resultException = targetException;
            
      throw new TransformerException(resultException);
    }
    catch (Exception e)
    {
      
      throw new TransformerException (e);
    }

    if (result != null)
    {
      xpc.outputToResultTree (stylesheetTree, result);
    }
 
  }

}
"
org.apache.xml.utils.XMLStringFactory,5,1,2,22,6,10,20,2,5,2.0,8,0.0,0,0.0,0.4,0,0,0.6,1,0.8,0,"
package org.apache.xml.utils;


public abstract class XMLStringFactory
{

  
  public abstract XMLString newstr(String string);

  
  public abstract XMLString newstr(FastStringBuffer string, int start, 
                                   int length);

  
  public abstract XMLString newstr(char[] string, int start, 
                                   int length);
                                   
  
  public abstract XMLString emptystr();
}
"
org.apache.xalan.templates.ElemComment,5,3,0,5,17,10,1,4,5,2.0,74,0.0,0,0.98,0.466666667,2,6,13.8,16,3.8,1,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;


public class ElemComment extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_COMMENT;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_COMMENT_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
    try
    {
      
      
      
      
      
      
      
      
      String data = transformer.transformToString(this);

      transformer.getResultTreeHandler().comment(data);
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEndEvent(this);
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {

    
    case Constants.ELEMNAME_TEXTLITERALRESULT :
    case Constants.ELEMNAME_APPLY_TEMPLATES :
    case Constants.ELEMNAME_APPLY_IMPORTS :
    case Constants.ELEMNAME_CALLTEMPLATE :
    case Constants.ELEMNAME_FOREACH :
    case Constants.ELEMNAME_VALUEOF :
    case Constants.ELEMNAME_COPY_OF :
    case Constants.ELEMNAME_NUMBER :
    case Constants.ELEMNAME_CHOOSE :
    case Constants.ELEMNAME_IF :
    case Constants.ELEMNAME_TEXT :
    case Constants.ELEMNAME_COPY :
    case Constants.ELEMNAME_VARIABLE :
    case Constants.ELEMNAME_MESSAGE :

      
      
      
      
      
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
}
"
org.apache.xpath.res.XPATHErrorResources,5,3,10,10,16,8,10,0,3,1.246296296,2125,0.0,0,0.926829268,0.333333333,0,0,397.0,2,0.8,1,"
package org.apache.xpath.res;

import java.util.ListResourceBundle;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.ResourceBundle;


public class XPATHErrorResources extends ListResourceBundle
{



  
  public static final int MAX_CODE = 108;  

  
  public static final int MAX_WARNING = 11;  

  
  public static final int MAX_OTHERS = 20;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  
  public static final String ERROR0000 = ""ERROR0000"";
  public static final String ER_CURRENT_NOT_ALLOWED_IN_MATCH = 
	 ""ER_CURRENT_NOT_ALLOWED_IN_MATCH"";
  public static final String ER_CURRENT_TAKES_NO_ARGS = 
	 ""ER_CURRENT_TAKES_NO_ARGS"";
  public static final String ER_DOCUMENT_REPLACED = ""ER_DOCUMENT_REPLACED"";
  public static final String ER_CONTEXT_HAS_NO_OWNERDOC = 
	 ""ER_CONTEXT_HAS_NO_OWNERDOC"";
  public static final String ER_LOCALNAME_HAS_TOO_MANY_ARGS = 
	 ""ER_LOCALNAME_HAS_TOO_MANY_ARGS"";
  public static final String ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = 
	 ""ER_NAMESPACEURI_HAS_TOO_MANY_ARGS"";
  public static final String ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = 
	 ""ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS"";
  public static final String ER_NUMBER_HAS_TOO_MANY_ARGS = 
	 ""ER_NUMBER_HAS_TOO_MANY_ARGS"";
  public static final String ER_NAME_HAS_TOO_MANY_ARGS = 
	 ""ER_NAME_HAS_TOO_MANY_ARGS"";
  public static final String ER_STRING_HAS_TOO_MANY_ARGS = 
	 ""ER_STRING_HAS_TOO_MANY_ARGS"";
  public static final String ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = 
	 ""ER_STRINGLENGTH_HAS_TOO_MANY_ARGS"";
  public static final String ER_TRANSLATE_TAKES_3_ARGS = 
	 ""ER_TRANSLATE_TAKES_3_ARGS"";
  public static final String ER_UNPARSEDENTITYURI_TAKES_1_ARG = 
	 ""ER_UNPARSEDENTITYURI_TAKES_1_ARG"";
  public static final String ER_NAMESPACEAXIS_NOT_IMPLEMENTED = 
	 ""ER_NAMESPACEAXIS_NOT_IMPLEMENTED"";
  public static final String ER_UNKNOWN_AXIS = ""ER_UNKNOWN_AXIS"";
  public static final String ER_UNKNOWN_MATCH_OPERATION = 
	 ""ER_UNKNOWN_MATCH_OPERATION"";
  public static final String ER_INCORRECT_ARG_LENGTH =""ER_INCORRECT_ARG_LENGTH"";
  public static final String ER_CANT_CONVERT_TO_NUMBER = 
	 ""ER_CANT_CONVERT_TO_NUMBER"";
  public static final String ER_CANT_CONVERT_TO_NODELIST = 
	 ""ER_CANT_CONVERT_TO_NODELIST"";
  public static final String ER_CANT_CONVERT_TO_MUTABLENODELIST = 
	 ""ER_CANT_CONVERT_TO_MUTABLENODELIST"";
  public static final String ER_CANT_CONVERT_TO_TYPE =""ER_CANT_CONVERT_TO_TYPE"";
  public static final String ER_EXPECTED_MATCH_PATTERN = 
	 ""ER_EXPECTED_MATCH_PATTERN"";
  public static final String ER_COULDNOT_GET_VAR_NAMED = 
	 ""ER_COULDNOT_GET_VAR_NAMED"";
  public static final String ER_UNKNOWN_OPCODE = ""ER_UNKNOWN_OPCODE"";
  public static final String ER_EXTRA_ILLEGAL_TOKENS =""ER_EXTRA_ILLEGAL_TOKENS"";
  public static final String ER_EXPECTED_DOUBLE_QUOTE = 
	 ""ER_EXPECTED_DOUBLE_QUOTE"";
  public static final String ER_EXPECTED_SINGLE_QUOTE = 
	 ""ER_EXPECTED_SINGLE_QUOTE"";
  public static final String ER_EMPTY_EXPRESSION = ""ER_EMPTY_EXPRESSION"";
  public static final String ER_EXPECTED_BUT_FOUND = ""ER_EXPECTED_BUT_FOUND"";
  public static final String ER_INCORRECT_PROGRAMMER_ASSERTION = 
	 ""ER_INCORRECT_PROGRAMMER_ASSERTION"";
  public static final String ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = 
	 ""ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL"";
  public static final String ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = 
	 ""ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG"";
  public static final String ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = 
	 ""ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG"";
  public static final String ER_PREDICATE_ILLEGAL_SYNTAX = 
	 ""ER_PREDICATE_ILLEGAL_SYNTAX"";
  public static final String ER_ILLEGAL_AXIS_NAME = ""ER_ILLEGAL_AXIS_NAME"";
  public static final String ER_UNKNOWN_NODETYPE = ""ER_UNKNOWN_NODETYPE"";
  public static final String ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = 
	 ""ER_PATTERN_LITERAL_NEEDS_BE_QUOTED"";
  public static final String ER_COULDNOT_BE_FORMATTED_TO_NUMBER = 
	 ""ER_COULDNOT_BE_FORMATTED_TO_NUMBER"";
  public static final String ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = 
	 ""ER_COULDNOT_CREATE_XMLPROCESSORLIAISON"";
  public static final String ER_DIDNOT_FIND_XPATH_SELECT_EXP = 
	 ""ER_DIDNOT_FIND_XPATH_SELECT_EXP"";
  public static final String ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = 
	 ""ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH"";
  public static final String ER_ERROR_OCCURED = ""ER_ERROR_OCCURED"";
  public static final String ER_ILLEGAL_VARIABLE_REFERENCE = 
	 ""ER_ILLEGAL_VARIABLE_REFERENCE"";
  public static final String ER_AXES_NOT_ALLOWED = ""ER_AXES_NOT_ALLOWED"";
  public static final String ER_KEY_HAS_TOO_MANY_ARGS = 
	 ""ER_KEY_HAS_TOO_MANY_ARGS"";
  public static final String ER_COUNT_TAKES_1_ARG = ""ER_COUNT_TAKES_1_ARG"";
  public static final String ER_COULDNOT_FIND_FUNCTION = 
	 ""ER_COULDNOT_FIND_FUNCTION"";
  public static final String ER_UNSUPPORTED_ENCODING =""ER_UNSUPPORTED_ENCODING"";
  public static final String ER_PROBLEM_IN_DTM_NEXTSIBLING = 
	 ""ER_PROBLEM_IN_DTM_NEXTSIBLING"";
  public static final String ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = 
	 ""ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL"";
  public static final String ER_SETDOMFACTORY_NOT_SUPPORTED = 
	 ""ER_SETDOMFACTORY_NOT_SUPPORTED"";
  public static final String ER_PREFIX_MUST_RESOLVE = ""ER_PREFIX_MUST_RESOLVE"";
  public static final String ER_PARSE_NOT_SUPPORTED = ""ER_PARSE_NOT_SUPPORTED"";
  

  

  

  public static final String ER_SAX_API_NOT_HANDLED = ""ER_SAX_API_NOT_HANDLED"";
public static final String ER_IGNORABLE_WHITESPACE_NOT_HANDLED = 
	 ""ER_IGNORABLE_WHITESPACE_NOT_HANDLED"";
  public static final String ER_DTM_CANNOT_HANDLE_NODES = 
	 ""ER_DTM_CANNOT_HANDLE_NODES"";
  public static final String ER_XERCES_CANNOT_HANDLE_NODES = 
	 ""ER_XERCES_CANNOT_HANDLE_NODES"";
  public static final String ER_XERCES_PARSE_ERROR_DETAILS = 
	 ""ER_XERCES_PARSE_ERROR_DETAILS"";
  public static final String ER_XERCES_PARSE_ERROR = ""ER_XERCES_PARSE_ERROR"";
  

  

  public static final String ER_INVALID_UTF16_SURROGATE = 
	 ""ER_INVALID_UTF16_SURROGATE"";
  public static final String ER_OIERROR = ""ER_OIERROR"";
  public static final String ER_CANNOT_CREATE_URL = ""ER_CANNOT_CREATE_URL"";
  public static final String ER_XPATH_READOBJECT = ""ER_XPATH_READOBJECT"";
 public static final String ER_FUNCTION_TOKEN_NOT_FOUND = 
	 ""ER_FUNCTION_TOKEN_NOT_FOUND"";
 
  public static final String ER_CANNOT_DEAL_XPATH_TYPE = 
	 ""ER_CANNOT_DEAL_XPATH_TYPE"";
  public static final String ER_NODESET_NOT_MUTABLE = ""ER_NODESET_NOT_MUTABLE"";
  public static final String ER_NODESETDTM_NOT_MUTABLE = 
	 ""ER_NODESETDTM_NOT_MUTABLE"";
   
  public static final String ER_VAR_NOT_RESOLVABLE = ""ER_VAR_NOT_RESOLVABLE"";
   
 public static final String ER_NULL_ERROR_HANDLER = ""ER_NULL_ERROR_HANDLER"";
   
  public static final String ER_PROG_ASSERT_UNKNOWN_OPCODE = 
	 ""ER_PROG_ASSERT_UNKNOWN_OPCODE"";
   
  public static final String ER_ZERO_OR_ONE = ""ER_ZERO_OR_ONE"";
   
  public static final String ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = 
	 ""ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER"";
   
  public static final String ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = ""ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER"";
   
  public static final String ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = 
	 ""ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS"";
   
 public static final String ER_COULD_NOT_FIND_VAR = ""ER_COULD_NOT_FIND_VAR"";
   
 public static final String ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = 
	 ""ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING"";
   
 public static final String ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = 
	 ""ER_FASTSTRINGBUFFER_CANNOT_BE_NULL"";
   
  public static final String ER_TWO_OR_THREE = ""ER_TWO_OR_THREE"";
   
  public static final String ER_VARIABLE_ACCESSED_BEFORE_BIND = 
	 ""ER_VARIABLE_ACCESSED_BEFORE_BIND"";
   
 public static final String ER_FSB_CANNOT_TAKE_STRING = 
	 ""ER_FSB_CANNOT_TAKE_STRING"";
   
  public static final String ER_SETTING_WALKER_ROOT_TO_NULL = 
	 ""ER_SETTING_WALKER_ROOT_TO_NULL"";
   
  public static final String ER_NODESETDTM_CANNOT_ITERATE = 
	 ""ER_NODESETDTM_CANNOT_ITERATE"";
  
 public static final String ER_NODESET_CANNOT_ITERATE = 
	 ""ER_NODESET_CANNOT_ITERATE"";
  
  public static final String ER_NODESETDTM_CANNOT_INDEX = 
	 ""ER_NODESETDTM_CANNOT_INDEX"";
  
  public static final String ER_NODESET_CANNOT_INDEX = 
	 ""ER_NODESET_CANNOT_INDEX"";
  
  public static final String ER_CANNOT_CALL_SETSHOULDCACHENODE = 
	 ""ER_CANNOT_CALL_SETSHOULDCACHENODE"";
  
 public static final String ER_ONLY_ALLOWS = ""ER_ONLY_ALLOWS"";
  
  public static final String ER_UNKNOWN_STEP = ""ER_UNKNOWN_STEP"";
  
  public static final String ER_EXPECTED_REL_LOC_PATH = 
	 ""ER_EXPECTED_REL_LOC_PATH"";
  
  public static final String ER_EXPECTED_LOC_PATH = ""ER_EXPECTED_LOC_PATH"";
  
  public static final String ER_EXPECTED_LOC_STEP = ""ER_EXPECTED_LOC_STEP"";
  
  public static final String ER_EXPECTED_NODE_TEST = ""ER_EXPECTED_NODE_TEST"";
  
  public static final String ER_EXPECTED_STEP_PATTERN = 
	""ER_EXPECTED_STEP_PATTERN"";
  
  public static final String ER_EXPECTED_REL_PATH_PATTERN = 
	 ""ER_EXPECTED_REL_PATH_PATTERN"";
  
  

  
  
  
  public static final String ER_CANT_CONVERT_TO_BOOLEAN = 
	 ""ER_CANT_CONVERT_TO_BOOLEAN"";
  
  public static final String ER_CANT_CONVERT_TO_SINGLENODE = 
	 ""ER_CANT_CONVERT_TO_SINGLENODE"";
  
  public static final String ER_CANT_GET_SNAPSHOT_LENGTH = 
	 ""ER_CANT_GET_SNAPSHOT_LENGTH"";
  
  public static final String ER_NON_ITERATOR_TYPE = ""ER_NON_ITERATOR_TYPE"";
  
  public static final String ER_DOC_MUTATED = ""ER_DOC_MUTATED"";
  public static final String ER_INVALID_XPATH_TYPE = ""ER_INVALID_XPATH_TYPE"";
  public static final String ER_EMPTY_XPATH_RESULT = ""ER_EMPTY_XPATH_RESULT"";
  public static final String ER_INCOMPATIBLE_TYPES = ""ER_INCOMPATIBLE_TYPES"";
  public static final String ER_NULL_RESOLVER = ""ER_NULL_RESOLVER"";
  public static final String ER_CANT_CONVERT_TO_STRING = 
	 ""ER_CANT_CONVERT_TO_STRING"";
  public static final String ER_NON_SNAPSHOT_TYPE = ""ER_NON_SNAPSHOT_TYPE"";
  public static final String ER_WRONG_DOCUMENT = ""ER_WRONG_DOCUMENT"";
  
  
  public static final String ER_WRONG_NODETYPE = ""ER_WRONG_NODETYPE"";
  public static final String ER_XPATH_ERROR = ""ER_XPATH_ERROR"";

  public static final String WG_LOCALE_NAME_NOT_HANDLED = 
	 ""WG_LOCALE_NAME_NOT_HANDLED"";
  public static final String WG_PROPERTY_NOT_SUPPORTED = 
	 ""WG_PROPERTY_NOT_SUPPORTED"";
  public static final String WG_DONT_DO_ANYTHING_WITH_NS = 
	 ""WG_DONT_DO_ANYTHING_WITH_NS"";
  public static final String WG_SECURITY_EXCEPTION = ""WG_SECURITY_EXCEPTION"";
  public static final String WG_QUO_NO_LONGER_DEFINED = 
	 ""WG_QUO_NO_LONGER_DEFINED"";
  public static final String WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = 
	 ""WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST"";
  public static final String WG_FUNCTION_TOKEN_NOT_FOUND = 
	 ""WG_FUNCTION_TOKEN_NOT_FOUND"";
  public static final String WG_COULDNOT_FIND_FUNCTION = 
	 ""WG_COULDNOT_FIND_FUNCTION"";
  public static final String WG_CANNOT_MAKE_URL_FROM =""WG_CANNOT_MAKE_URL_FROM"";
  public static final String WG_EXPAND_ENTITIES_NOT_SUPPORTED = 
	 ""WG_EXPAND_ENTITIES_NOT_SUPPORTED"";
  public static final String WG_ILLEGAL_VARIABLE_REFERENCE = 
	 ""WG_ILLEGAL_VARIABLE_REFERENCE"";
  public static final String WG_UNSUPPORTED_ENCODING =""WG_UNSUPPORTED_ENCODING"";


  

  public static final Object[][] contents = {

  



  { ""ERROR0000"" , ""{0}"" },


  


  { ER_CURRENT_NOT_ALLOWED_IN_MATCH, ""The current() function is not allowed in a match pattern!"" },

  
  

  { ER_CURRENT_TAKES_NO_ARGS, ""The current() function does not accept arguments!"" },

  

  { ER_DOCUMENT_REPLACED,
      ""document() function implementation has been replaced by org.apache.xalan.xslt.FuncDocument!""},
  

  
 

  { ER_CONTEXT_HAS_NO_OWNERDOC,
      ""context does not have an owner document!""},

  
 

  { ER_LOCALNAME_HAS_TOO_MANY_ARGS,
      ""local-name() has too many arguments.""},

  
 

  { ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
      ""namespace-uri() has too many arguments.""},

  

  { ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
      ""normalize-space() has too many arguments.""},

  


  { ER_NUMBER_HAS_TOO_MANY_ARGS,
      ""number() has too many arguments.""},

  


  { ER_NAME_HAS_TOO_MANY_ARGS,
     ""name() has too many arguments.""},

  


  { ER_STRING_HAS_TOO_MANY_ARGS,
      ""string() has too many arguments.""},

  


  { ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
      ""string-length() has too many arguments.""},

  


  { ER_TRANSLATE_TAKES_3_ARGS,
      ""The translate() function takes three arguments!""},

  


  { ER_UNPARSEDENTITYURI_TAKES_1_ARG,
      ""The unparsed-entity-uri function should take one argument!""},

  


  { ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
      ""namespace axis not implemented yet!""},

  


  { ER_UNKNOWN_AXIS,
     ""unknown axis: {0}""},

  


  { ER_UNKNOWN_MATCH_OPERATION,
     ""unknown match operation!""},

  


  { ER_INCORRECT_ARG_LENGTH,
      ""Arg length of processing-instruction() node test is incorrect!""},

  


  { ER_CANT_CONVERT_TO_NUMBER,
      ""Can not convert {0} to a number""},

  
  

  { ER_CANT_CONVERT_TO_NODELIST,
      ""Can not convert {0} to a NodeList!""},

  


  { ER_CANT_CONVERT_TO_MUTABLENODELIST,
      ""Can not convert {0} to a NodeSetDTM!""},

  


  { ER_CANT_CONVERT_TO_TYPE,
      ""Can not convert {0} to a type#{1}""},

  


  { ER_EXPECTED_MATCH_PATTERN,
      ""Expected match pattern in getMatchScore!""},

  


  { ER_COULDNOT_GET_VAR_NAMED,
      ""Could not get variable named {0}""},

  


  { ER_UNKNOWN_OPCODE,
     ""ERROR! Unknown op code: {0}""},

  


  { ER_EXTRA_ILLEGAL_TOKENS,
     ""Extra illegal tokens: {0}""},

  


  { ER_EXPECTED_DOUBLE_QUOTE,
      ""misquoted literal... expected double quote!""},

  


  { ER_EXPECTED_SINGLE_QUOTE,
      ""misquoted literal... expected single quote!""},

  


  { ER_EMPTY_EXPRESSION,
     ""Empty expression!""},

  


  { ER_EXPECTED_BUT_FOUND,
     ""Expected {0}, but found: {1}""},

  


  { ER_INCORRECT_PROGRAMMER_ASSERTION,
      ""Programmer assertion is incorrect! - {0}""},

  


  { ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
      ""boolean(...) argument is no longer optional with 19990709 XPath draft.""},

  


  { ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
      ""Found ',' but no preceding argument!""},

  


  { ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
      ""Found ',' but no following argument!""},

  


  { ER_PREDICATE_ILLEGAL_SYNTAX,
      ""'..[predicate]' or '.[predicate]' is illegal syntax.  Use 'self::node()[predicate]' instead.""},

  


  { ER_ILLEGAL_AXIS_NAME,
     ""illegal axis name: {0}""},

  


  { ER_UNKNOWN_NODETYPE,
     ""Unknown nodetype: {0}""},

  


  { ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
      ""Pattern literal ({0}) needs to be quoted!""},

  


  { ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
      ""{0} could not be formatted to a number!""},

  


  { ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
      ""Could not create XML TransformerFactory Liaison: {0}""},

  


  { ER_DIDNOT_FIND_XPATH_SELECT_EXP,
      ""Error! Did not find xpath select expression (-select).""},

  


  { ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
      ""ERROR! Could not find ENDOP after OP_LOCATIONPATH""},

  


  { ER_ERROR_OCCURED,
     ""Error occured!""},

  


  { ER_ILLEGAL_VARIABLE_REFERENCE,
      ""VariableReference given for variable out of context or without definition!  Name = {0}""},

  


  { ER_AXES_NOT_ALLOWED,
      ""Only child:: and attribute:: axes are allowed in match patterns!  Offending axes = {0}""},

  


  { ER_KEY_HAS_TOO_MANY_ARGS,
      ""key() has an incorrect number of arguments.""},

  


  { ER_COUNT_TAKES_1_ARG,
      ""The count function should take one argument!""},

  


  { ER_COULDNOT_FIND_FUNCTION,
     ""Could not find function: {0}""},

  


  { ER_UNSUPPORTED_ENCODING,
     ""Unsupported encoding: {0}""},

  


  { ER_PROBLEM_IN_DTM_NEXTSIBLING,
      ""Problem occured in DTM in getNextSibling... trying to recover""},

  


  { ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
      ""Programmer error: EmptyNodeList can not be written to.""},

  


  { ER_SETDOMFACTORY_NOT_SUPPORTED,
      ""setDOMFactory is not supported by XPathContext!""},

  


  { ER_PREFIX_MUST_RESOLVE,
      ""Prefix must resolve to a namespace: {0}""},

  


  { ER_PARSE_NOT_SUPPORTED,
      ""parse (InputSource source) not supported in XPathContext! Can not open {0}""},

  


  
  

  


  
  

  


  
  

  


  { ER_SAX_API_NOT_HANDLED,
      ""SAX API characters(char ch[]... not handled by the DTM!""},

  


  { ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
      ""ignorableWhitespace(char ch[]... not handled by the DTM!""},

  


  { ER_DTM_CANNOT_HANDLE_NODES,
      ""DTMLiaison can not handle nodes of type {0}""},

  


  { ER_XERCES_CANNOT_HANDLE_NODES,
      ""DOM2Helper can not handle nodes of type {0}""},

  


  { ER_XERCES_PARSE_ERROR_DETAILS,
      ""DOM2Helper.parse error: SystemID - {0} line - {1}""},

  


  { ER_XERCES_PARSE_ERROR,
     ""DOM2Helper.parse error""},

  


  
   

  


  
   

  


  { ER_INVALID_UTF16_SURROGATE,
      ""Invalid UTF-16 surrogate detected: {0} ?""},

  
  

  { ER_OIERROR,
     ""IO error""},

  
  

  { ER_CANNOT_CREATE_URL,
     ""Cannot create url for: {0}""},

  


  { ER_XPATH_READOBJECT,
     ""In XPath.readObject: {0}""},
  
  


  { ER_FUNCTION_TOKEN_NOT_FOUND,
      ""function token not found.""},
  
   


  
  
  
   


  { ER_CANNOT_DEAL_XPATH_TYPE,
       ""Can not deal with XPath type: {0}""},
  
   
 

  { ER_NODESET_NOT_MUTABLE,
       ""This NodeSet is not mutable""},
  
   


  { ER_NODESETDTM_NOT_MUTABLE,
       ""This NodeSetDTM is not mutable""},
  
   


  { ER_VAR_NOT_RESOLVABLE,
        ""Variable not resolvable: {0}""},
  
   


  { ER_NULL_ERROR_HANDLER,
        ""Null error handler""},
  
   
 

  { ER_PROG_ASSERT_UNKNOWN_OPCODE,
       ""Programmer''s assertion: unknown opcode: {0}""},
  
   


  { ER_ZERO_OR_ONE,
       ""0 or 1""},
  
  
   
  

  { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""rtf() not supported by XRTreeFragSelectWrapper""},
  
   
  

  { ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""asNodeIterator() not supported by XRTreeFragSelectWrapper""},
  
   
 

  { ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
       ""fsb() not supported for XStringForChars""},
  
   


  { ER_COULD_NOT_FIND_VAR,
      ""Could not find variable with the name of {0}""},
  
   


  { ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
      ""XStringForChars can not take a string for an argument""},
  
   


  { ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
      ""The FastStringBuffer argument can not be null""},

   
   


  { ER_TWO_OR_THREE,
       ""2 or 3""},

   


  { ER_VARIABLE_ACCESSED_BEFORE_BIND,
       ""Variable accessed before it is bound!""},

   


  { ER_FSB_CANNOT_TAKE_STRING,
       ""XStringForFSB can not take a string for an argument!""},

   


  { ER_SETTING_WALKER_ROOT_TO_NULL,
       ""
 !!!! Error! Setting the root of a walker to null!!!""},

   


  { ER_NODESETDTM_CANNOT_ITERATE,
       ""This NodeSetDTM can not iterate to a previous node!""},

  


  { ER_NODESET_CANNOT_ITERATE,
       ""This NodeSet can not iterate to a previous node!""},

  


  { ER_NODESETDTM_CANNOT_INDEX,
       ""This NodeSetDTM can not do indexing or counting functions!""},

  


  { ER_NODESET_CANNOT_INDEX,
       ""This NodeSet can not do indexing or counting functions!""},

  


  { ER_CANNOT_CALL_SETSHOULDCACHENODE,
       ""Can not call setShouldCacheNodes after nextNode has been called!""},

  


  { ER_ONLY_ALLOWS,
       ""{0} only allows {1} arguments""},

  


  { ER_UNKNOWN_STEP,
       ""Programmer''s assertion in getNextStepPos: unknown stepType: {0}""},

  
  
  

  


  { ER_EXPECTED_REL_LOC_PATH,
      ""A relative location path was expected following the '/' or '

  
  
  

  


  { ER_EXPECTED_LOC_PATH,
       ""A location path was expected, but the following token was encountered:  {0}""},

  
  
  

  


  { ER_EXPECTED_LOC_STEP,
       ""A location step was expected following the '/' or '

  
  
  
  

  


  { ER_EXPECTED_NODE_TEST,
       ""A node test that matches either NCName:* or QName was expected.""},

  
  
  

  


  { ER_EXPECTED_STEP_PATTERN,
       ""A step pattern was expected, but '/' was encountered.""},

  
  
  
 
  


  { ER_EXPECTED_REL_PATH_PATTERN,
       ""A relative path pattern was expected.""},

  
  
  

  


  
  
  
  
  
  

  
 

  
   

  
  
  

  


  { ER_CANT_CONVERT_TO_BOOLEAN,
       ""Cannot convert {0} to a boolean.""},

  
  

  
  

  { ER_CANT_CONVERT_TO_SINGLENODE,
       ""Cannot convert {0} to a single node. This getter applies to types ANY_UNORDERED_NODE_TYPE and FIRST_ORDERED_NODE_TYPE.""},

  
  

  


  { ER_CANT_GET_SNAPSHOT_LENGTH,
       ""Cannot get snapshot length on type: {0}. This getter applies to types UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.""},

  
  

  { ER_NON_ITERATOR_TYPE,
       ""Cannot iterate over non-iterator type: {0}""},

  
  
  

  


  { ER_DOC_MUTATED,
       ""Document mutated since result was returned. Iterator is invalid.""},

  


  { ER_INVALID_XPATH_TYPE,
       ""Invalid XPath type argument: {0}""},

  


  { ER_EMPTY_XPATH_RESULT,
       ""Empty XPath result object""},

  


  { ER_INCOMPATIBLE_TYPES,
       ""The returned type: {0} cannot be coerced into the specified type: {1}""},

  
 

  { ER_NULL_RESOLVER,
       ""Unable to resolve prefix with null prefix resolver.""},

  
  
  

  


  { ER_CANT_CONVERT_TO_STRING,
       ""Cannot convert {0} to a string.""},

  
  

  


  { ER_NON_SNAPSHOT_TYPE,
       ""Cannot call snapshotItem on type: {0}. This method applies to types UNORDERED_NODE_SNAPSHOT_TYPE and ORDERED_NODE_SNAPSHOT_TYPE.""},

  
  
  
  

  


  { ER_WRONG_DOCUMENT,
       ""Context node does not belong to the document that is bound to this XPathEvaluator.""},

  
  
  


  { ER_WRONG_NODETYPE,
       ""The context node type is not supported.""},

  


  { ER_XPATH_ERROR,
       ""Unknown error in XPath.""},


  

  


  { WG_LOCALE_NAME_NOT_HANDLED,
      ""locale name in the format-number function not yet handled!""},

  


  { WG_PROPERTY_NOT_SUPPORTED,
      ""XSL Property not supported: {0}""},

  


  { WG_DONT_DO_ANYTHING_WITH_NS,
      ""Do not currently do anything with namespace {0} in property: {1}""},

  


  { WG_SECURITY_EXCEPTION,
      ""SecurityException when trying to access XSL system property: {0}""},

  


  { WG_QUO_NO_LONGER_DEFINED,
      ""Old syntax: quo(...) is no longer defined in XPath.""},

  


  { WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
      ""XPath needs a derived object to implement nodeTest!""},

  


  { WG_FUNCTION_TOKEN_NOT_FOUND,
      ""function token not found.""},

  


  { WG_COULDNOT_FIND_FUNCTION,
      ""Could not find function: {0}""},

  


  { WG_CANNOT_MAKE_URL_FROM,
      ""Can not make URL from: {0}""},

  


  { WG_EXPAND_ENTITIES_NOT_SUPPORTED,
      ""-E option not supported for DTM parser""},

  


  { WG_ILLEGAL_VARIABLE_REFERENCE,
      ""VariableReference given for variable out of context or without definition!  Name = {0}""},

  


  { WG_UNSUPPORTED_ENCODING,
     ""Unsupported encoding: {0}""},



  
  { ""ui_language"", ""en""},
  { ""help_language"", ""en""},
  { ""language"", ""en""},
  { ""BAD_CODE"", ""Parameter to createMessage was out of bounds""},
  { ""FORMAT_FAILED"", ""Exception thrown during messageFormat call""},
  { ""version"", "">>>>>>> Xalan Version ""},
  { ""version2"", ""<<<<<<<""},
  { ""yes"", ""yes""},
  { ""line"", ""Line #""},
  { ""column"", ""Column #""},
  { ""xsldone"", ""XSLProcessor: done""},
  { ""xpath_option"", ""xpath options: ""},
  { ""optionIN"", ""   [-in inputXMLURL]""},
  { ""optionSelect"", ""   [-select xpath expression]""},
  { ""optionMatch"", ""   [-match match pattern (for match diagnostics)]""},
  { ""optionAnyExpr"", ""Or just an xpath expression will do a diagnostic dump""},
  { ""noParsermsg1"", ""XSL Process was not successful.""},
  { ""noParsermsg2"", ""** Could not find parser **""},
  { ""noParsermsg3"", ""Please check your classpath.""},
  { ""noParsermsg4"", ""If you don't have IBM's XML Parser for Java, you can download it from""},
  { ""noParsermsg5"", ""IBM's AlphaWorks: http:
  { ""gtone"", "">1"" },
  { ""zero"", ""0"" },
  { ""one"", ""1"" },
  { ""two"" , ""2"" },
  { ""three"", ""3"" }

  };


  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""Error: "";

  
  public static final String WARNING_HEADER = ""Warning: "";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  public static final XPATHErrorResources loadResourceBundle(String className)
          throws MissingResourceException
  {

    Locale locale = Locale.getDefault();
    String suffix = getResourceSuffix(locale);

    try
    {

      
      return (XPATHErrorResources) ResourceBundle.getBundle(className
              + suffix, locale);
    }
    catch (MissingResourceException e)
    {
      try  
      {

        
        
        return (XPATHErrorResources) ResourceBundle.getBundle(className,
                new Locale(""en"", ""US""));
      }
      catch (MissingResourceException e2)
      {

        
        
        throw new MissingResourceException(
          ""Could not load any resource bundles."", className, """");
      }
    }
  }

  
  private static final String getResourceSuffix(Locale locale)
  {

    String suffix = ""_"" + locale.getLanguage();
    String country = locale.getCountry();

    if (country.equals(""TW""))
      suffix += ""_"" + country;

    return suffix;
  }

}
"
org.apache.xpath.axes.MatchPatternIterator,6,5,0,11,25,3,1,11,4,0.75,261,1.0,2,0.961538462,0.4,1,6,41.83333333,10,2.8333,0,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.patterns.StepPattern;


public class MatchPatternIterator extends LocPathIterator
{

  
  protected StepPattern m_pattern;

  
  protected int m_superAxis = -1;

  
  protected DTMAxisTraverser m_traverser;
  
  
  private static final boolean DEBUG = false;
  


  
  MatchPatternIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {

    super(compiler, opPos, analysis, false);

    int firstStepPos = compiler.getFirstChildPos(opPos);

    m_pattern = WalkerFactory.loadSteps(this, compiler, firstStepPos, 0); 

    boolean fromRoot = false;
    boolean walkBack = false;
    boolean walkDescendants = false;
    boolean walkAttributes = false;

    if (0 != (analysis & (WalkerFactory.BIT_ROOT | 
                          WalkerFactory.BIT_ANY_DESCENDANT_FROM_ROOT)))
      fromRoot = true;
      
    if (0 != (analysis
              & (WalkerFactory.BIT_ANCESTOR
                 | WalkerFactory.BIT_ANCESTOR_OR_SELF
                 | WalkerFactory.BIT_PRECEDING
                 | WalkerFactory.BIT_PRECEDING_SIBLING 
                 | WalkerFactory.BIT_FOLLOWING
                 | WalkerFactory.BIT_FOLLOWING_SIBLING
                 | WalkerFactory.BIT_PARENT | WalkerFactory.BIT_FILTER)))
      walkBack = true;

    if (0 != (analysis
              & (WalkerFactory.BIT_DESCENDANT_OR_SELF
                 | WalkerFactory.BIT_DESCENDANT
                 | WalkerFactory.BIT_CHILD)))
      walkDescendants = true;

    if (0 != (analysis
              & (WalkerFactory.BIT_ATTRIBUTE | WalkerFactory.BIT_NAMESPACE)))
      walkAttributes = true;
      
    if(false || DEBUG)
    {
      System.out.print(""analysis: ""+Integer.toBinaryString(analysis));
      System.out.println("", ""+WalkerFactory.getAnalysisString(analysis));
    }
      
    if(fromRoot || walkBack)
    {
      if(walkAttributes)
      {
        m_superAxis = Axis.ALL;
      }
      else
      {
        m_superAxis = Axis.DESCENDANTSFROMROOT;
      }
    }
    else if(walkDescendants)
    {
      if(walkAttributes)
      {
        m_superAxis = Axis.ALLFROMNODE;
      }
      else
      {
        m_superAxis = Axis.DESCENDANTORSELF;
      }
    }
    else
    {
      m_superAxis = Axis.ALL;
    }
    if(false || DEBUG)
    {
      System.out.println(""axis: ""+Axis.names[m_superAxis]);
    }
    
  }
  
  
  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    m_traverser = m_cdtm.getAxisTraverser(m_superAxis);
  }

  
  public void detach()
  {    
    if(m_allowDetach)
    {
      m_traverser = null;
      
      
      super.detach();
    }
  }
  
  
  protected int getNextNode()
  {
    m_lastFetched = (DTM.NULL == m_lastFetched)
                     ? m_traverser.first(m_context)
                     : m_traverser.next(m_context, m_lastFetched);
    return m_lastFetched;
  }

  
  public int nextNode()
  {      
  	if(m_foundLast)
  		return DTM.NULL;

    int next;
    
    org.apache.xpath.VariableStack vars;
    int savedStart;
    if (-1 != m_stackFrame)
    {
      vars = m_execContext.getVarStack();

      
      savedStart = vars.getStackFrame();

      vars.setStackFrame(m_stackFrame);
    }
    else
    {
      
      vars = null;
      savedStart = 0;
    }
    
    try
    {
      if(DEBUG)
        System.out.println(""m_pattern""+m_pattern.toString());

      do
      {
        next = getNextNode();
  
        if (DTM.NULL != next)
        {
          if(DTMIterator.FILTER_ACCEPT == acceptNode(next, m_execContext))
            break;
          else
            continue;
        }
        else
          break;
      }
      while (next != DTM.NULL);
      
      if (DTM.NULL != next)
      {
        if(DEBUG)
        {
          System.out.println(""next: ""+next);
          System.out.println(""name: ""+m_cdtm.getNodeName(next));
        }
        incrementCurrentPos();
  
        return next;
      }
      else
      {
        m_foundLast = true;
  
        return DTM.NULL;
      }
    }
    finally
    {
      if (-1 != m_stackFrame)
      {
        
        vars.setStackFrame(savedStart);
      }
    }

  }
  
  
  public short acceptNode(int n, XPathContext xctxt)
  {

    try
    {
      xctxt.pushCurrentNode(n);
      xctxt.pushIteratorRoot(m_context);
      if(DEBUG)
      {
        System.out.println(""traverser: ""+m_traverser);
        System.out.print(""node: ""+n);
        System.out.println("", ""+m_cdtm.getNodeName(n));
        
        System.out.println(""pattern: ""+m_pattern.toString());
        m_pattern.debugWhatToShow(m_pattern.getWhatToShow());
      }
      
      XObject score = m_pattern.execute(xctxt);
      
      if(DEBUG)
      {
        
        System.out.println(""score: ""+score);
        System.out.println(""skip: ""+(score == NodeTest.SCORE_NONE));
      }

      
::acceptNode - score: ""+score.num()+""::"");
      return (score == NodeTest.SCORE_NONE) ? DTMIterator.FILTER_SKIP 
                    : DTMIterator.FILTER_ACCEPT;
    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new RuntimeException(se.getMessage());
    }
    finally
    {
      xctxt.popCurrentNode();
      xctxt.popIteratorRoot();
    }

  }

}
"
org.apache.xpath.res.XPATHErrorResources_zh_TW,3,4,0,1,4,1,0,1,2,1.428571429,1872,0.0,0,0.976190476,1.0,0,0,618.3333333,1,0.3333,1,"
package org.apache.xpath.res;


public class XPATHErrorResources_zh_TW extends XPATHErrorResources
{

  
  
  public static final int MAX_CODE = 108;  

  
  public static final int MAX_WARNING = 11;  

  
  public static final int MAX_OTHERS = 20;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  
  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_CURRENT_NOT_ALLOWED_IN_MATCH,
      ""在符合型樣中不允許使用 current() 函式！""},


  
  


  {
    ER_CURRENT_TAKES_NO_ARGS,
      ""current() 函式不接受引數！""},


  
  


  {
    ER_DOCUMENT_REPLACED,
      ""org.apache.xalan.xslt.FuncDocument 已取代執行 document() 函式！""},


  
  


  {
    ER_CONTEXT_HAS_NO_OWNERDOC,
      ""上下文不含擁有者文件！""},


  
  


  {
    ER_LOCALNAME_HAS_TOO_MANY_ARGS,
      ""local-name() 有太多引數。""},


  
  


  {
    ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
      ""namespace-uri() 有太多引數。""},


  
  


  {
    ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
      ""normalize-space() 有太多引數。""},


  
  


  {
    ER_NUMBER_HAS_TOO_MANY_ARGS,
      ""number() 有太多引數。""},


  
  


  {
    ER_NAME_HAS_TOO_MANY_ARGS, ""name() 有太多引數。""},


  
  


  {
    ER_STRING_HAS_TOO_MANY_ARGS,
      ""string() 有太多引數。""},


  
  


  {
    ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
      ""string-length() 有太多引數。""},


  
  


  {
    ER_TRANSLATE_TAKES_3_ARGS,
      ""translate() 函式需要 3 個引數！""},


  
  


  {
    ER_UNPARSEDENTITYURI_TAKES_1_ARG,
      ""unparsed-entity-uri 函式需要 1 個引數！""},


  
  


  {
    ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
      ""namespace 軸尚未建置！""},


  
  


  {
    ER_UNKNOWN_AXIS, ""未知軸：{0}""},


  
  


  {
    ER_UNKNOWN_MATCH_OPERATION, ""未知的符合作業！""},


  
  


  {
    ER_INCORRECT_ARG_LENGTH,
      ""processing-instruction() 節點測試的引數長度不正確！""},


  
  


  {
    ER_CANT_CONVERT_TO_NUMBER,
      ""{0} 無法轉換為數字""},


  
  


  {
    ER_CANT_CONVERT_TO_NODELIST,
      ""{0} 無法轉換為 NodeList！""},


  
  


  {
    ER_CANT_CONVERT_TO_MUTABLENODELIST,
      ""{0} 無法轉換為 NodeSetDTM！""},


  
  


  {
    ER_CANT_CONVERT_TO_TYPE,
      ""{0} 無法轉換為 type


  
  


  {
    ER_EXPECTED_MATCH_PATTERN,
      ""在 getMatchScore 中預期的符合型樣！""},


  
  


  {
    ER_COULDNOT_GET_VAR_NAMED,
      ""無法取得叫作 {0} 的變數""},


  
  


  {
    ER_UNKNOWN_OPCODE, ""錯誤！未知的作業碼：{0}""},


  
  


  {
    ER_EXTRA_ILLEGAL_TOKENS, ""額外不合規則的記號：{0}""},


  
  


  {
    ER_EXPECTED_DOUBLE_QUOTE,
      ""文字列引號括錯... 預期出現雙引號！""},


  
  


  {
    ER_EXPECTED_SINGLE_QUOTE,
      ""文字列引號括錯... 預期出現單引號！""},


  
  


  {
    ER_EMPTY_EXPRESSION, ""空的表示式！""},


  
  


  {
    ER_EXPECTED_BUT_FOUND, ""預期 {0}，卻找到：{1}""},


  
  


  {
    ER_INCORRECT_PROGRAMMER_ASSERTION,
      ""程式設計師假設不正確！- {0}""},


  
  


  {
    ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
      ""boolean(...) 引數在 19990709 XPath 初稿中不再是可選用的。""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
      ""找到 ','，但之前沒有引數！""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
      ""找到 ','，但之後沒有引數！""},


  
  


  {
    ER_PREDICATE_ILLEGAL_SYNTAX,
      ""'..[predicate]' 或 '.[predicate]' 是不合規則的語法。請使用 'self::node()[predicate]' 來代替。""},


  
  


  {
    ER_ILLEGAL_AXIS_NAME, ""不合規則的軸名稱：{0}""},


  
  


  {
    ER_UNKNOWN_NODETYPE, ""未知節點類型：{0}""},


  
  


  {
    ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
      ""型樣文字列 ({0}) 需要用引號括住！""},


  
  


  {
    ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
      ""{0} 無法格式化為數字！""},


  
  


  {
    ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
      ""無法建立 XML TransformerFactory Liaison：{0}""},


  
  


  {
    ER_DIDNOT_FIND_XPATH_SELECT_EXP,
      ""錯誤！未找到 xpath select 表示式 (-select)。""},


  
  


  {
    ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
      ""錯誤！在 OP_LOCATIONPATH 之後找不到 ENDOP""},


  
  


  {
    ER_ERROR_OCCURED, ""發生錯誤！""},


  
  


  {
    ER_ILLEGAL_VARIABLE_REFERENCE,
      ""提供給變數的 VariableReference 超出上下文或沒有定義！名稱 = {0}""},


  
  


  {
    ER_AXES_NOT_ALLOWED,
      ""在符合型樣中僅允許 child:: 及 attribute:: 軸！ 違例軸 = {0}""},


  
  


  {
    ER_KEY_HAS_TOO_MANY_ARGS,
      ""key() 含有不正確的引數數目。""},


  
  


  {
    ER_COUNT_TAKES_1_ARG,
      ""count 函式只接受一個引數！""},


  
  


  {
    ER_COULDNOT_FIND_FUNCTION, ""找不到函式：{0}""},


  
  


  {
    ER_UNSUPPORTED_ENCODING, ""未支援的編碼：{0}""},


  
  


  {
    ER_PROBLEM_IN_DTM_NEXTSIBLING,
      ""getNextSibling 中的 DTM 發生問題... 嘗試回復""},


  
  


  {
    ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
      ""程式設計師錯誤：無法寫入 EmptyNodeList 中。""},


  
  


  {
    ER_SETDOMFACTORY_NOT_SUPPORTED,
      ""setDOMFactory 不受 XPathContext 支援！""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""前置必須解譯為名稱空間：{0}""},


  
  


  {
    ER_PARSE_NOT_SUPPORTED,
      ""在 XPathContext 中不支援剖析（InputSource 來源）！無法開啟 {0}""},


  
  


  {
    ER_SAX_API_NOT_HANDLED,
      ""SAX API 字元(char ch[]... DTM 未處理！""},


  
  


  {
    ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
      ""ignorableWhitespace(char ch[]... DTM 未處理！""},


  
  


  {
    ER_DTM_CANNOT_HANDLE_NODES,
      ""DTMLiaison 無法處理類型 {0} 的節點""},


  
  


  {
    ER_XERCES_CANNOT_HANDLE_NODES,
      ""DOM2Helper 無法處理類型 {0} 的節點""},


  
  


  {
    ER_XERCES_PARSE_ERROR_DETAILS,
      ""DOM2Helper.parse 錯誤：SystemID - {0} 行 - {1}""},


  
  


  {
    ER_XERCES_PARSE_ERROR, ""DOM2Helper.parse 錯誤""},


  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""偵測到無效的 UTF-16 代用品：{0} ?""},


  
  


  {
    ER_OIERROR, ""輸入/輸出 (I/O) 錯誤""},


  
  


  {
    ER_CANNOT_CREATE_URL, ""無法建立 URL 給： {0}""},


  
  


  {
    ER_XPATH_READOBJECT, ""在 XPath.readObject：{0}""},

  
  
  


  {
    ER_FUNCTION_TOKEN_NOT_FOUND,
      ""找不到函式記號。""},

  
   
  


  {
    ER_CANNOT_DEAL_XPATH_TYPE,
       ""無法處理 XPath 類型：{0}""},

  
   
  


  {
    ER_NODESET_NOT_MUTABLE,
       ""此類 NodeSet 不易變""},

  
   
  


  {
    ER_NODESETDTM_NOT_MUTABLE,
       ""此類 NodeSetDTM 不易變""},

  
   
  


  {
    ER_VAR_NOT_RESOLVABLE,
        ""變數無法解譯：{0}""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""空的錯誤處理器""},

  
   
  


  {
    ER_PROG_ASSERT_UNKNOWN_OPCODE,
       ""程式設計師的假設：未知作業碼：{0}""},

  
   
  


  {
    ER_ZERO_OR_ONE,
       ""0 或 1""},

  
  
     
  


  {
    ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""XRTreeFragSelectWrapper 不支援 rtf()""},

  
   
  


  {
    ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""XRTreeFragSelectWrapper 不支援 asNodeIterator()""},

  
   
  


  {
    ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
       ""XStringForChars 不支援 fsb()""},

  
   
  


  {
    ER_COULD_NOT_FIND_VAR,
      ""找不到名稱為 {0} 的變數""},

  
   
  


  {
    ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
      ""XStringForChars 不接受字串引數""},

  
   
  


  {
    ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
      ""FastStringBuffer 引數不得為空值""},
    
    
  
  

  {
    ER_TWO_OR_THREE,
       ""2 或 3""},

 
   
  
 

  {
    ER_VARIABLE_ACCESSED_BEFORE_BIND,
       ""連結前已存取變數！""},

 
   
  
 

  {
    ER_FSB_CANNOT_TAKE_STRING,
       ""XStringForFSB 不會將字串看作引數！""},

 
   
  
 

  {
    ER_SETTING_WALKER_ROOT_TO_NULL,
       ""
 ！！！！錯誤！將 walker 的根設定為空！！！""},

 
   
  
 

  {
    ER_NODESETDTM_CANNOT_ITERATE,
       ""無法對前一個節點重複此 NodeSetDTM！""},

 
  
  
 

  {
    ER_NODESET_CANNOT_ITERATE,
       ""無法對前一個節點重複此 NodeSet！""},

 
  
  
 

  {
    ER_NODESETDTM_CANNOT_INDEX,
       ""此 NodeSetDTM 無法對函式進行索引或計數！""},

 
  
  
 

  {
    ER_NODESET_CANNOT_INDEX,
       ""此 NodeSet 無法對函式進行索引或計數！""},

 
  
  
 

  {
    ER_CANNOT_CALL_SETSHOULDCACHENODE,
       ""呼叫 nextNode 之後，不能呼叫 setShouldCacheNodes！""},

 
  
  
 

  {
    ER_ONLY_ALLOWS,
       ""{0} 僅允許使用 {1} 引數""},

 
  
  
 

  {
    ER_UNKNOWN_STEP,
       ""程式設計師在 getNextStepPos 中的判斷：未知的 stepType：{0}""},

 
  
  
  
 
  
  
 

  {
    ER_EXPECTED_REL_LOC_PATH,
       ""'/' 或 '

 
  
  
  
 
  
  
 

  {
    ER_EXPECTED_LOC_PATH,
       ""應為位置路徑，卻遇到以下記號 :  {0}""},

 
  
  
  
 
  
  
 

  {
    ER_EXPECTED_LOC_STEP,
       ""'/' 或 '

 
  
  
  
  
 
  
  
 

  {
    ER_EXPECTED_NODE_TEST,
       ""應為符合 NCName:* 或 QName 的節點測試。""},

 
  
  
  
 
  
  
 

  {
    ER_EXPECTED_STEP_PATTERN,
       ""應為步驟型樣，卻遇到 '/'。""},

  
  
  
  
 
  
  
 

  {
    ER_EXPECTED_REL_PATH_PATTERN,
       ""應為相對路徑型樣。""},

  
   
   
   
 
  
  
 

  {
    ER_CANT_CONVERT_TO_BOOLEAN,
       ""{0} 無法轉換為布林值。""},

 
  
  
 
  
  
 

  {
    ER_CANT_CONVERT_TO_SINGLENODE,
       ""{0} 無法轉換為單一節點。此 getter 適用於 ANY_UNORDERED_NODE_TYPE 和 FIRST_ORDERED_NODE_TYPE 類型。""},

 
  
  
 
  
  
 

  {
    ER_CANT_GET_SNAPSHOT_LENGTH,
       ""無法取得類型 {0} 的快照長度。此 getter 適用於 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 類型。""},

 
  
  
 

  {
    ER_NON_ITERATOR_TYPE,
       ""無法重複非疊代器類型：{0}""},

 
  
  
  
 
  
  
 

  {
    ER_DOC_MUTATED,
       ""傳回結果後文件發生變更。疊代器無效。""},

 
  
  
 

  {
    ER_INVALID_XPATH_TYPE,
       ""無效的 XPath 類型引數：{0}""},

 
  
  
 

  {
    ER_EMPTY_XPATH_RESULT,
       ""空的 XPath 結果物件""},

 
  
  
 

  {
    ER_INCOMPATIBLE_TYPES,
       ""傳回的類型：{0} 無法強行轉換為指定的類型：{1}""},

 
  
  
 

  {
    ER_NULL_RESOLVER,
       ""無法使用空前置解析器解析前置。""},

 
  
  
  
 
  
  
 

  {
    ER_CANT_CONVERT_TO_STRING,
       ""{0} 無法轉換為字串。""},

 
  
  
 
  
  
 

  {
    ER_NON_SNAPSHOT_TYPE,
       ""無法呼叫類型 {0} 的 snapshotItem。 此方法適用於 UNORDERED_NODE_SNAPSHOT_TYPE 和 ORDERED_NODE_SNAPSHOT_TYPE 類型。""},

 
  
  
  
  
 
  
  
 
  {
    ER_WRONG_DOCUMENT,
       ""上下文節點不屬於連結至此 XPathEvaluator 的文件。""},

 
  
  
  
  
 

  {
    ER_WRONG_NODETYPE ,
       ""不支援上下文節點。""},

 
  
  
 

  {
    ER_XPATH_ERROR ,
       ""XPath 中出現未知錯誤。""},

 

  

  
  


  {
    WG_LOCALE_NAME_NOT_HANDLED,
      ""format-number 函式中的語言環境名稱尚未處理！""},


  
  


  {
    WG_PROPERTY_NOT_SUPPORTED,
      ""不支援 XSL 內容：{0}""},


  
  


  {
    WG_DONT_DO_ANYTHING_WITH_NS,
      ""目前請勿處理內容 {1} 中的名稱空間 {0}""},


  
  


  {
    WG_SECURITY_EXCEPTION,
      ""嘗試存取 XSL 系統內容 {0} 時發生 SecurityException""},


  
  


  {
    WG_QUO_NO_LONGER_DEFINED,
      ""舊語法：quo(...) 不再定義於 XPath 中。""},


  
  


  {
    WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
      ""XPath 需要衍生物件來執行 nodeTest！""},


  
  


  {
    WG_FUNCTION_TOKEN_NOT_FOUND,
      ""找不到函式記號。""},


  
  


  {
    WG_COULDNOT_FIND_FUNCTION,
      ""找不到函式：{0}""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""無法從 {0} 產生 URL""},


  
  


  {
    WG_EXPAND_ENTITIES_NOT_SUPPORTED,
      ""DTM 剖析器不支援 -E 選項""},


  
  


  {
    WG_ILLEGAL_VARIABLE_REFERENCE,
      ""提供給變數的 VariableReference 超出上下文或沒有定義！名稱 = {0}""},


  
  


  {
    WG_UNSUPPORTED_ENCODING, ""未支援的編碼：{0}""},


  

  { ""ui_language"", ""zh_TW""},
  { ""help_language"", ""zh_TW""},
  { ""language"", ""zh_TW""},
    { ""BAD_CODE"",
      ""createMessage 的參數超出界限""},
    { ""FORMAT_FAILED"",
      ""在 messageFormat 呼叫期間異常丟出""},
    { ""version"", "">>>>>>> Xalan 版本""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""是""},
    { ""line"", ""列 
    { ""column"", ""行 
    { ""xsldone"", ""XSLProcessor: done""},
    { ""xpath_option"", ""xpath 選項： ""},
    { ""optionIN"", ""   [-in inputXMLURL]""},
    { ""optionSelect"", ""   [-select xpath expression]""},
    { ""optionMatch"", 
      ""   [-match match pattern (用於符合診斷)]""},
    { ""optionAnyExpr"",
      ""或只有一個 xpath 表示式會執行診斷傾印""},
    { ""noParsermsg1"", ""XSL 程序不成功。""},
    { ""noParsermsg2"", ""** 找不到剖析器 **""},
    { ""noParsermsg3"", ""請檢查類別路徑。""},
    { ""noParsermsg4"", 
      ""如果您沒有 IBM 的 XML Parser for Java，可下載自 ""},
    { ""noParsermsg5"",
      ""IBM's AlphaWorks: http:
  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""

  
  public static final String ERROR_HEADER = ""錯誤："";

  
  public static final String WARNING_HEADER = ""警告："";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}

"
org.apache.xml.utils.synthetic.reflection.Method,6,2,0,5,16,13,3,4,6,2.0,58,0.0,0,0.863636364,0.388888889,2,3,8.666666667,1,0.5,1,"
package org.apache.xml.utils.synthetic.reflection;

import org.apache.xml.utils.synthetic.SynthesisException;


public class Method extends EntryPoint implements Member
{

  
  public Method(String name,
                org.apache.xml.utils.synthetic.Class declaringclass)
  {

    super(declaringclass);

    this.name = name;
  }

  
  public Method(java.lang.reflect.Method ctor,
                org.apache.xml.utils.synthetic.Class declaringclass)
  {
    super(ctor, declaringclass);
  }

  
  public Method(java.lang.reflect.Method realmethod)
  {
    super(realmethod);
  }

  

  
  public int hashCode()
  {
    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
  }

  
  public Object invoke(Object obj, Object args[])
          throws IllegalAccessException, IllegalArgumentException,
                 java.lang.reflect.InvocationTargetException
  {

    if (realep != null)
      return ((java.lang.reflect.Method) realep).invoke(obj, args);
    else
      throw new IllegalAccessException(
        ""Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation"");
  }

  
  public void setReturnType(org.apache.xml.utils.synthetic.Class returntype)
          throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.returntype = returntype;
  }
}
"
org.apache.xalan.templates.RedundentExprEliminator,38,3,0,27,128,607,1,27,6,0.9,1849,0.0,2,0.357142857,0.194594595,0,0,47.39473684,15,3.7632,0,"
package org.apache.xalan.templates;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionNode;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPath;
import org.apache.xpath.axes.AxesWalker;
import org.apache.xpath.axes.FilterExprIteratorSimple;
import org.apache.xpath.axes.FilterExprWalker;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.axes.SelfIteratorNoPredicate;
import org.apache.xpath.axes.WalkerFactory;
import org.apache.xpath.axes.WalkingIterator;
import org.apache.xpath.operations.Variable;
import org.apache.xpath.operations.VariableSafeAbsRef;


public class RedundentExprEliminator extends XSLTVisitor
{
  Vector m_paths;
  Vector m_absPaths;
  boolean m_isSameContext;
  AbsPathChecker m_absPathChecker = new AbsPathChecker();
  
  static int m_uniquePsuedoVarID = 1;
  static final String PSUEDOVARNAMESPACE = Constants.S_VENDORURL+""/xalan/psuedovar"";
 
  public static boolean DEBUG = false;
  public static boolean DIAGNOSE_NUM_PATHS_REDUCED = false;
  public static boolean DIAGNOSE_MULTISTEPLIST = false;

  
  VarNameCollector m_varNameCollector = new VarNameCollector();

  
  public RedundentExprEliminator()
  {
    m_isSameContext = true;
    m_absPaths = new Vector();
    m_paths = null;
  }
  
  
  
  public void eleminateRedundentLocals(ElemTemplateElement psuedoVarRecipient)
  {
    eleminateRedundent(psuedoVarRecipient, m_paths);
  }
  
  
  public void eleminateRedundentGlobals(StylesheetRoot stylesheet)
  {
    eleminateRedundent(stylesheet, m_absPaths);
  }

  
  
  protected void eleminateRedundent(ElemTemplateElement psuedoVarRecipient, Vector paths)
  {
    int n = paths.size();
    int numPathsEliminated = 0;
    int numUniquePathsEliminated = 0;
    for (int i = 0; i < n; i++)
    {
      ExpressionOwner owner = (ExpressionOwner) paths.elementAt(i);
      if (null != owner)
      {
        int found = findAndEliminateRedundant(i + 1, i, owner, psuedoVarRecipient, paths);
        if (found > 0)
                  numUniquePathsEliminated++;
        numPathsEliminated += found;
      }
    }
    
    eleminateSharedPartialPaths(psuedoVarRecipient, paths);
    
    if(DIAGNOSE_NUM_PATHS_REDUCED)
		diagnoseNumPaths(paths, numPathsEliminated, numUniquePathsEliminated);
  }
  
  
  protected void eleminateSharedPartialPaths(ElemTemplateElement psuedoVarRecipient, Vector paths)
  {
  	MultistepExprHolder list = createMultistepExprList(paths);
  	if(null != list)
  	{
  		if(DIAGNOSE_MULTISTEPLIST)
        	list.diagnose();
        	
        boolean isGlobal = (paths == m_absPaths);
        	
        
        
        int longestStepsCount = list.m_stepCount;
    	for (int i = longestStepsCount-1; i >= 1; i--)
    	{
    		MultistepExprHolder next = list;
        	while(null != next)
        	{
        		if(next.m_stepCount < i)
        			break;
				list = matchAndEliminatePartialPaths(next, list, isGlobal, i, psuedoVarRecipient);
				next = next.m_next;
        	}
    	}
  	}
  }

  
  protected MultistepExprHolder matchAndEliminatePartialPaths(MultistepExprHolder testee, 
                                               MultistepExprHolder head,
                                               boolean isGlobal,
                                               int lengthToTest,
                                               ElemTemplateElement varScope)
  {  	
  	if(null == testee.m_exprOwner)
  		return head;
  		
    
    WalkingIterator iter1 = (WalkingIterator) testee.m_exprOwner.getExpression();
    if(partialIsVariable(testee, lengthToTest))
    	return head;
    MultistepExprHolder matchedPaths = null;
    MultistepExprHolder matchedPathsTail = null;
    MultistepExprHolder meh = head;
    while( null != meh)
    {
      if ((meh != testee) && (null != meh.m_exprOwner))
      {
	      WalkingIterator iter2 = (WalkingIterator) meh.m_exprOwner.getExpression();
	      if (stepsEqual(iter1, iter2, lengthToTest))
	      {
	        if (null == matchedPaths)
	        {
	          try
	          {
	          	matchedPaths = (MultistepExprHolder)testee.clone();
	          	testee.m_exprOwner = null; 
	          }
	          catch(CloneNotSupportedException cnse){}
	          matchedPathsTail = matchedPaths;
	          matchedPathsTail.m_next = null;
	        }
	       
	        try
	        {
	          matchedPathsTail.m_next = (MultistepExprHolder)meh.clone();
	          meh.m_exprOwner = null; 
	        }
	        catch(CloneNotSupportedException cnse){}
	        matchedPathsTail = matchedPathsTail.m_next;
	        matchedPathsTail.m_next = null;
	      }
      }
      meh = meh.m_next;
    }
    	
	int matchCount = 0;
	if(null != matchedPaths)
	{
		ElemTemplateElement root = isGlobal ? varScope : findCommonAncestor(matchedPaths);
		WalkingIterator sharedIter = (WalkingIterator)matchedPaths.m_exprOwner.getExpression();
		WalkingIterator newIter = createIteratorFromSteps(sharedIter, lengthToTest);
		ElemVariable var = createPsuedoVarDecl(root, newIter, isGlobal);
		if(DIAGNOSE_MULTISTEPLIST)
			System.err.println(""Created var: ""+var.getName()+(isGlobal ? ""(Global)"" : """"));
		while(null != matchedPaths)
		{
			ExpressionOwner owner = matchedPaths.m_exprOwner;
			WalkingIterator iter = (WalkingIterator)owner.getExpression();
			
			if(DIAGNOSE_MULTISTEPLIST)
				diagnoseLineNumber(iter);
			
			LocPathIterator newIter2 = 
			    changePartToRef(var.getName(), iter, lengthToTest, isGlobal);
			owner.setExpression(newIter2);
			
			matchedPaths = matchedPaths.m_next;
		}
	}
	
	if(DIAGNOSE_MULTISTEPLIST)
		diagnoseMultistepList(matchCount, lengthToTest, isGlobal);
    return head;
  }
  
  
  boolean partialIsVariable(MultistepExprHolder testee, int lengthToTest)
  {
  	if(1 == lengthToTest)
  	{
  		WalkingIterator wi = (WalkingIterator)testee.m_exprOwner.getExpression();
  		if(wi.getFirstWalker() instanceof FilterExprWalker)
  			return true;
  	}
  	return false;
  }

  
  protected void diagnoseLineNumber(Expression expr)
  {
    ElemTemplateElement e = getElemFromExpression(expr);
    System.err.println(""   "" + e.getSystemId() + "" Line "" + e.getLineNumber());
  }
      
  
  protected ElemTemplateElement findCommonAncestor(MultistepExprHolder head)
  {
  	
  	int numExprs = head.getLength();
  	
  	
  	
    ElemTemplateElement[] elems = new ElemTemplateElement[numExprs];
    int[] ancestorCounts = new int[numExprs];
    
    
    
  	MultistepExprHolder next = head;
  	int shortestAncestorCount = 10000;
  	for(int i = 0; i < numExprs; i++)
  	{
  		ElemTemplateElement elem = 
  			getElemFromExpression(next.m_exprOwner.getExpression());
  		elems[i] = elem;
  		int numAncestors = countAncestors(elem);
  		ancestorCounts[i] = numAncestors;
  		if(numAncestors < shortestAncestorCount)
  		{
  			shortestAncestorCount = numAncestors;
  		}
  		next = next.m_next;
  	}
  	
  	
  	for(int i = 0; i < numExprs; i++)
  	{
  		if(ancestorCounts[i] > shortestAncestorCount)
  		{
  			int numStepCorrection = ancestorCounts[i] - shortestAncestorCount;
  			for(int j = 0; j < numStepCorrection; j++)
  			{
  				elems[i] = elems[i].getParentElem();
  			}
  		}
  	}
  	
  	
  	
  	ElemTemplateElement first = null;
  	while(shortestAncestorCount-- >= 0)
  	{
  		boolean areEqual = true;
  		first = elems[0];
  		for(int i = 1; i < numExprs; i++)
  		{
  			if(first != elems[i])
  			{
  				areEqual = false;
  				break;
  			}
  		}
  		
  		
  		if(areEqual && isNotSameAsOwner(head, first) && first.canAcceptVariables())
  		{
  			if(DIAGNOSE_MULTISTEPLIST)
  			{
  				System.err.print(first.getClass().getName());
  				System.err.println("" at   "" + first.getSystemId() + "" Line "" + first.getLineNumber());
  			}
  			return first;
  		}
   			
  		for(int i = 0; i < numExprs; i++)
  		{
  			elems[i] = elems[i].getParentElem();
  		}
  	}
  	
  	assertion(false, ""Could not find common ancestor!!!"");
  	return null;
  }
  
  
  protected boolean isNotSameAsOwner(MultistepExprHolder head, ElemTemplateElement ete)
  {
  	MultistepExprHolder next = head;
  	while(null != next)
  	{
  		ElemTemplateElement elemOwner = getElemFromExpression(next.m_exprOwner.getExpression());
  		if(elemOwner == ete)
  			return false;
  		next = next.m_next;
  	}
  	return true;
  }
  
  
  protected int countAncestors(ElemTemplateElement elem)
  {
  	int count = 0;
  	while(null != elem)
  	{
  		count++;
  		elem = elem.getParentElem();
  	}
  	return count;
  }

  
  protected void diagnoseMultistepList(
      int matchCount,
      int lengthToTest,
      boolean isGlobal)
  {
      if (matchCount > 0)
        {
        System.err.print(
          ""Found multistep matches: "" + matchCount + "", "" + lengthToTest + "" length"");
        if (isGlobal)
              System.err.println("" (global)"");
        else
              System.err.println();
      }
  }
  
  
  protected LocPathIterator changePartToRef(final QName uniquePsuedoVarName, WalkingIterator wi, 
                                 final int numSteps, final boolean isGlobal)
  {
  	Variable var = new Variable();
  	var.setQName(uniquePsuedoVarName);
  	var.setIsGlobal(isGlobal);
  	if(isGlobal)
  	{	ElemTemplateElement elem = getElemFromExpression(wi);
  		StylesheetRoot root = elem.getStylesheetRoot();
  		Vector vars = root.getVariablesAndParamsComposed();
  		var.setIndex(vars.size()-1);
  	}
  	
  	
  	AxesWalker walker = wi.getFirstWalker();
  	for(int i = 0; i < numSteps; i++)
  	{
  		assertion(null != walker, ""Walker should not be null!"");
  		walker = walker.getNextWalker();
  	}
  	
  	if(null != walker)
  	{
  	
  	  FilterExprWalker few = new FilterExprWalker(wi);
  	  few.setInnerExpression(var);
  	  few.exprSetParent(wi);
  	  few.setNextWalker(walker);
  	  walker.setPrevWalker(few);
  	  wi.setFirstWalker(few);
  	  return wi;
  	}
  	else
  	{
  	  FilterExprIteratorSimple feis = new FilterExprIteratorSimple(var);
  	  feis.exprSetParent(wi.exprGetParent());
  	  return feis;
  	}
  }
  
  
  protected WalkingIterator createIteratorFromSteps(final WalkingIterator wi, int numSteps)
  {
  	WalkingIterator newIter = new WalkingIterator(wi.getPrefixResolver());
  	try
  	{
  		AxesWalker walker = (AxesWalker)wi.getFirstWalker().clone();
  		newIter.setFirstWalker(walker);
  		walker.setLocPathIterator(newIter);
  		for(int i = 1; i < numSteps; i++)
  		{
  			AxesWalker next = (AxesWalker)walker.getNextWalker().clone();
  			walker.setNextWalker(next);
  			next.setLocPathIterator(newIter);
  			walker = next;
  		}
  		walker.setNextWalker(null);
  	}
  	catch(CloneNotSupportedException cnse)
  	{
  		throw new WrappedRuntimeException(cnse);
  	}
  	return newIter;
  }
    
  
  protected boolean stepsEqual(WalkingIterator iter1, WalkingIterator iter2, 
                                         int numSteps)
  {
  	AxesWalker aw1 = iter1.getFirstWalker();
  	AxesWalker aw2 = iter2.getFirstWalker();
  	
  	for(int i = 0; (i < numSteps); i++)
  	{
  		if((null == aw1) || (null == aw2))
  		 	return false;
  		 	
  		if(!aw1.deepEquals(aw2))
  			return false;
  		
  		aw1 = aw1.getNextWalker();
  		aw2 = aw2.getNextWalker();
  	}
  	
  	assertion((null != aw1) || (null != aw2), ""Total match is incorrect!"");
  	
  	return true;
  }
  
  
  protected MultistepExprHolder createMultistepExprList(Vector paths)
  {
  	MultistepExprHolder first = null;
  	int n = paths.size();
  	for(int i = 0; i < n; i++)
  	{
  		ExpressionOwner eo = (ExpressionOwner)paths.elementAt(i);
  		if(null == eo)
  			continue;
  			
  		
  		LocPathIterator lpi = (LocPathIterator)eo.getExpression();
  		int numPaths = countSteps(lpi);
  		if(numPaths > 1)
  		{
  			if(null == first)
  				first = new MultistepExprHolder(eo, numPaths, null);
  			else
  				first = first.addInSortedOrder(eo, numPaths);
  		}
  	}
  	
  	if((null == first) || (first.getLength() <= 1))
  		return null;
  	else
  		return first;
  }
  
  
  protected int findAndEliminateRedundant(int start, int firstOccuranceIndex,
                         ExpressionOwner firstOccuranceOwner, 
                         ElemTemplateElement psuedoVarRecipient,
                         Vector paths) 
                 throws org.w3c.dom.DOMException 
  {
	MultistepExprHolder head = null;
	MultistepExprHolder tail = null;
	int numPathsFound = 0;
	int n = paths.size();
	
	Expression expr1 = firstOccuranceOwner.getExpression();
	if(DEBUG)
		assertIsLocPathIterator(expr1, firstOccuranceOwner);
	boolean isGlobal = (paths == m_absPaths);
	LocPathIterator lpi = (LocPathIterator)expr1;
	int stepCount = countSteps(lpi);
	for(int j = start; j < n; j++)
	{
		ExpressionOwner owner2 = (ExpressionOwner)paths.elementAt(j);
		if(null != owner2)
		{
			Expression expr2 = owner2.getExpression();
			boolean isEqual = expr2.deepEquals(lpi);
			if(isEqual)
			{  		
				LocPathIterator lpi2  = (LocPathIterator)expr2;				
				if(null == head)
				{
					head = new MultistepExprHolder(firstOccuranceOwner, stepCount, null);
					tail = head;
					numPathsFound++;
				}
				tail.m_next = new MultistepExprHolder(owner2, stepCount, null);
				tail = tail.m_next;
	
				
				paths.setElementAt(null, j);
				
				
				numPathsFound++;
			}
		}
	}
	
	
	if((0 == numPathsFound) && isGlobal)
	{
      head = new MultistepExprHolder(firstOccuranceOwner, stepCount, null);
      numPathsFound++;
	}
	
	if(null != head)
	{
		ElemTemplateElement root = isGlobal ? psuedoVarRecipient : findCommonAncestor(head);
		LocPathIterator sharedIter = (LocPathIterator)head.m_exprOwner.getExpression();
		ElemVariable var = createPsuedoVarDecl(root, sharedIter, isGlobal);
		if(DIAGNOSE_MULTISTEPLIST)
			System.err.println(""Created var: ""+var.getName()+(isGlobal ? ""(Global)"" : """"));
		QName uniquePsuedoVarName = var.getName();
		while(null != head)
		{
			ExpressionOwner owner = head.m_exprOwner;	
			if(DIAGNOSE_MULTISTEPLIST)
				diagnoseLineNumber(owner.getExpression());
			changeToVarRef(uniquePsuedoVarName, owner, paths, root);
			head = head.m_next;
		}
		
		
		paths.setElementAt(var.getSelect(), firstOccuranceIndex);
	}
	
	return numPathsFound;
  } 
  
  
  protected int oldFindAndEliminateRedundant(int start, int firstOccuranceIndex,
                         ExpressionOwner firstOccuranceOwner, 
                         ElemTemplateElement psuedoVarRecipient,
                         Vector paths) 
                 throws org.w3c.dom.DOMException 
  {
	QName uniquePsuedoVarName = null;
	boolean foundFirst = false;
	int numPathsFound = 0;
	int n = paths.size();
	Expression expr1 = firstOccuranceOwner.getExpression();
	if(DEBUG)
		assertIsLocPathIterator(expr1, firstOccuranceOwner);
	boolean isGlobal = (paths == m_absPaths);
	LocPathIterator lpi = (LocPathIterator)expr1;
	for(int j = start; j < n; j++)
	{
		ExpressionOwner owner2 = (ExpressionOwner)paths.elementAt(j);
		if(null != owner2)
		{
			Expression expr2 = owner2.getExpression();
			boolean isEqual = expr2.deepEquals(lpi);
			if(isEqual)
			{  		
				LocPathIterator lpi2  = (LocPathIterator)expr2;				
				if(!foundFirst)
				{
					foundFirst = true;
					
					
					
				    ElemVariable var = createPsuedoVarDecl(psuedoVarRecipient, lpi, isGlobal);
				    if(null == var)
				    	return 0;
				    uniquePsuedoVarName = var.getName();
	
					changeToVarRef(uniquePsuedoVarName, firstOccuranceOwner, 
					               paths, psuedoVarRecipient);
					               
					
					
					paths.setElementAt(var.getSelect(), firstOccuranceIndex);
					numPathsFound++;
				}
	
				changeToVarRef(uniquePsuedoVarName, owner2, paths, psuedoVarRecipient);
	
				
				paths.setElementAt(null, j);
				
				
				numPathsFound++;
			}
		}
	}
	
	
	if((0 == numPathsFound) && (paths == m_absPaths))
	{
      ElemVariable var = createPsuedoVarDecl(psuedoVarRecipient, lpi, true);
      if(null == var)
        return 0;
	  uniquePsuedoVarName = var.getName();
      changeToVarRef(uniquePsuedoVarName, firstOccuranceOwner, paths, psuedoVarRecipient);
      paths.setElementAt(var.getSelect(), firstOccuranceIndex);
      numPathsFound++;
	}
	return numPathsFound;
  }
  
  
  protected int countSteps(LocPathIterator lpi)
  {
  	if(lpi instanceof WalkingIterator)
  	{
  		WalkingIterator wi = (WalkingIterator)lpi;
  		AxesWalker aw = wi.getFirstWalker();
  		int count = 0;
  		while(null != aw)
  		{
  			count++;
  			aw = aw.getNextWalker();
  		}
  		return count;
  	}
  	else
  		return 1;
  }
  
  
  protected void changeToVarRef(QName varName, ExpressionOwner owner, 
                                Vector paths, ElemTemplateElement psuedoVarRecipient) 
  {
	Variable varRef = (paths == m_absPaths) ? new VariableSafeAbsRef() : new Variable();
	varRef.setQName(varName);
	if(paths == m_absPaths)
	{
		StylesheetRoot root = (StylesheetRoot)psuedoVarRecipient;
		Vector globalVars = root.getVariablesAndParamsComposed();
		
		
		varRef.setIndex(globalVars.size()-1);
		varRef.setIsGlobal(true);
	}
	owner.setExpression(varRef);
  }

  
  protected ElemVariable createPsuedoVarDecl(
      ElemTemplateElement psuedoVarRecipient,
      LocPathIterator lpi, boolean isGlobal)
      throws org.w3c.dom.DOMException
  {
    QName uniquePsuedoVarName = new QName (PSUEDOVARNAMESPACE, ""#""+m_uniquePsuedoVarID);
    m_uniquePsuedoVarID++;
  		
  	if(isGlobal)
  	{
  	  return createGlobalPsuedoVarDecl(uniquePsuedoVarName, 
  	                                  (StylesheetRoot)psuedoVarRecipient, lpi);
  	}
  	else						
      return createLocalPsuedoVarDecl(uniquePsuedoVarName, psuedoVarRecipient, lpi);
  }
  
  
  protected ElemVariable createGlobalPsuedoVarDecl(QName uniquePsuedoVarName,
                                           StylesheetRoot stylesheetRoot, 
                                           LocPathIterator lpi) 
        throws org.w3c.dom.DOMException 
  {
  	ElemVariable psuedoVar = new ElemVariable();
  	psuedoVar.setIsTopLevel(true);
	XPath xpath = new XPath(lpi);
	psuedoVar.setSelect(xpath);
	psuedoVar.setName(uniquePsuedoVarName);
	
	Vector globalVars = stylesheetRoot.getVariablesAndParamsComposed();
	psuedoVar.setIndex(globalVars.size());
	globalVars.addElement(psuedoVar);
	return psuedoVar;
  }

  
  

  
  protected ElemVariable createLocalPsuedoVarDecl(QName uniquePsuedoVarName,
                                           ElemTemplateElement psuedoVarRecipient, 
                                           LocPathIterator lpi) 
        throws org.w3c.dom.DOMException 
  {
		ElemVariable psuedoVar = new ElemVariablePsuedo();
		
		XPath xpath = new XPath(lpi);
		psuedoVar.setSelect(xpath);
		psuedoVar.setName(uniquePsuedoVarName);

		ElemVariable var = addVarDeclToElem(psuedoVarRecipient, lpi, psuedoVar);
		
		lpi.exprSetParent(var);
		
		return var;
  }

  
  protected ElemVariable addVarDeclToElem(
    ElemTemplateElement psuedoVarRecipient,
    LocPathIterator lpi,
    ElemVariable psuedoVar)
    throws org.w3c.dom.DOMException
  {
    
    ElemTemplateElement ete = psuedoVarRecipient.getFirstChildElem();

    lpi.callVisitors(null, m_varNameCollector);

    
    
    
    
    if (m_varNameCollector.getVarCount() > 0)
    {
      ElemTemplateElement baseElem = getElemFromExpression(lpi);
      ElemVariable varElem = getPrevVariableElem(baseElem);
      while (null != varElem)
      {
        if (m_varNameCollector.doesOccur(varElem.getName()))
          {
          psuedoVarRecipient = varElem.getParentElem();
          ete = varElem.getNextSiblingElem();
          break;
        }
        varElem = getPrevVariableElem(varElem);
      }
    }

    if ((null != ete) && (Constants.ELEMNAME_PARAMVARIABLE == ete.getXSLToken()))
    {
      
      if(isParam(lpi))
        return null;

      while (null != ete)
      {
        ete = ete.getNextSiblingElem();
        if ((null != ete) && Constants.ELEMNAME_PARAMVARIABLE != ete.getXSLToken())
            break;
      }
    }
    psuedoVarRecipient.insertBefore(psuedoVar, ete);
    m_varNameCollector.reset();
    return psuedoVar;
  }
    
  
  protected boolean isParam(ExpressionNode expr)
  {
  	while(null != expr)
  	{
  		if(expr instanceof ElemTemplateElement)
  			break;
  		expr = expr.exprGetParent();
  	}
  	if(null != expr)
  	{
  		ElemTemplateElement ete = (ElemTemplateElement)expr;
  		while(null != ete)
  		{
  			int type = ete.getXSLToken();
  			switch(type)
  			{
  				case Constants.ELEMNAME_PARAMVARIABLE:
  					return true;
  				case Constants.ELEMNAME_TEMPLATE:
  				case Constants.ELEMNAME_STYLESHEET:
  					return false;
  			}
  			ete = ete.getParentElem();
  		}
  	}
  	return false;
  	
  }
  
  
  protected ElemVariable getPrevVariableElem(ElemTemplateElement elem)
  {
  	
  	
  	while(null != (elem = getPrevElementWithinContext(elem)))
  	{
  		int type = elem.getXSLToken();
  			
  		if((Constants.ELEMNAME_VARIABLE == type) ||
  		   (Constants.ELEMNAME_PARAMVARIABLE == type))
  		{
  			return (ElemVariable)elem;
  		}
  	}
  	return null;
  }
  
  
  protected ElemTemplateElement getPrevElementWithinContext(ElemTemplateElement elem)
  {
  	ElemTemplateElement prev = elem.getPreviousSiblingElem();
  	if(null == prev)
  		prev = elem.getParentElem();
  	if(null != prev)
  	{
  	  int type = prev.getXSLToken();
  	  if((Constants.ELEMNAME_FOREACH == type) || 
  	     (Constants.ELEMNAME_TEMPLATE == type) ||
  	     (Constants.ELEMNAME_STYLESHEET == type))
  	  {
  	  	prev = null;
  	  }
  	}
  	return prev;
  }
  
  
  protected ElemTemplateElement getElemFromExpression(Expression expr)
  {
  	ExpressionNode parent = expr.exprGetParent();
  	while(null != parent)
  	{
  		if(parent instanceof ElemTemplateElement)
  			return (ElemTemplateElement)parent;
  		parent = parent.exprGetParent();
  	}
  	throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_ASSERT_NO_TEMPLATE_PARENT, null));
  	
  }
      
  
  public boolean isAbsolute(LocPathIterator path)
  {
  	int analysis = path.getAnalysisBits();
    boolean isAbs = (WalkerFactory.isSet(analysis, WalkerFactory.BIT_ROOT) || 
           WalkerFactory.isSet(analysis, WalkerFactory.BIT_ANY_DESCENDANT_FROM_ROOT));
    if(isAbs)
    {
    	isAbs = m_absPathChecker.checkAbsolute(path);
    }
    return isAbs;
  }


  
  public boolean visitLocationPath(ExpressionOwner owner, LocPathIterator path)
  {
  	
  	
  	if(path instanceof SelfIteratorNoPredicate)
  	{
  		return true;
  	}
  	else if(path instanceof WalkingIterator)
  	{
  		WalkingIterator wi = (WalkingIterator)path;
  		AxesWalker aw = wi.getFirstWalker();
  		if((aw instanceof FilterExprWalker) && (null == aw.getNextWalker()))
  		{
  			FilterExprWalker few = (FilterExprWalker)aw;
  			Expression exp = few.getInnerExpression();
  			if(exp instanceof Variable)
  				return true;
  		}
  	}

    if (isAbsolute(path) && (null != m_absPaths))
    {
      if(DEBUG)
        validateNewAddition(m_absPaths, owner, path);
      m_absPaths.addElement(owner);
    }
    else if (m_isSameContext && (null != m_paths))
    {
      if(DEBUG)
        validateNewAddition(m_paths, owner, path);
      m_paths.addElement(owner);
    }

    return true;
  }

  
  public boolean visitPredicate(ExpressionOwner owner, Expression pred)
  {
    boolean savedIsSame = m_isSameContext;
    m_isSameContext = false;

    
    pred.callVisitors(owner, this);

    m_isSameContext = savedIsSame;

    
    
    return false;
  }
  
  
   boolean visitTopLevelInstruction(ElemTemplateElement elem)
   {
     int type = elem.getXSLToken();
     switch(type)
     {
       case Constants.ELEMNAME_TEMPLATE :
         return visitInstruction(elem);
       default:
         return true;
     }
   }


  
  boolean visitInstruction(ElemTemplateElement elem)
  {
    int type = elem.getXSLToken();
    switch (type)
    {
      case Constants.ELEMNAME_CALLTEMPLATE :
      case Constants.ELEMNAME_TEMPLATE :
      case Constants.ELEMNAME_FOREACH :
        {
          
          
          if(type == Constants.ELEMNAME_FOREACH)
          {
            ElemForEach efe = (ElemForEach) elem;
   		    
  		    Expression select = efe.getSelect();
  		    select.callVisitors(efe, this);
          }
         
  		  Vector savedPaths = m_paths;
  		  m_paths = new Vector();
  		    
  		  
  		  
  		  
  		  elem.callChildVisitors(this, false);  		
  		  eleminateRedundentLocals(elem);
  		    
  		  m_paths = savedPaths;
 
          
          return false;
        }
      case Constants.ELEMNAME_NUMBER :
      case Constants.ELEMNAME_SORT :
        
        
        boolean savedIsSame = m_isSameContext;
        m_isSameContext = false;
        elem.callChildVisitors(this);
        m_isSameContext = savedIsSame;
        return false;
        
      default :
        return true;
    }
  }
  
  
  
  
  protected void diagnoseNumPaths(Vector paths, int numPathsEliminated,  
                                  int numUniquePathsEliminated) 
  {
		if (numPathsEliminated > 0)
		{ 
		  if(paths == m_paths)
		  {
		    System.err.println(""Eliminated "" + numPathsEliminated + "" total paths!"");
		    System.err.println(
		      ""Consolodated "" + numUniquePathsEliminated + "" redundent paths!"");
		  }
		  else
		  {
		    System.err.println(""Eliminated "" + numPathsEliminated + "" total global paths!"");
		    System.err.println(
		      ""Consolodated "" + numUniquePathsEliminated + "" redundent global paths!"");
		  }
		}  
  }


  
  private final void assertIsLocPathIterator(Expression expr1, ExpressionOwner eo) 
    throws RuntimeException 
  {
		if(!(expr1 instanceof LocPathIterator))
		{
			String errMsg;
			if(expr1 instanceof Variable)
			{
				errMsg = ""Programmer's assertion: expr1 not an iterator: ""+
				          ((Variable)expr1).getQName();
			}
			else
			{
				errMsg = ""Programmer's assertion: expr1 not an iterator: ""+
				          expr1.getClass().getName();
			}
			throw new RuntimeException(errMsg + "", ""+
				          eo.getClass().getName()+"" ""+
				          expr1.exprGetParent());
		}
  }


  
  private static void validateNewAddition(Vector paths, ExpressionOwner owner, 
                                          LocPathIterator path) 
		throws RuntimeException 
  {
  	assertion(owner.getExpression() == path, ""owner.getExpression() != path!!!"");
	int n = paths.size();
	
	for(int i = 0; i < n; i++)
	{
		ExpressionOwner ew = (ExpressionOwner)paths.elementAt(i);
		assertion(ew != owner, ""duplicate owner on the list!!!"");
		assertion(ew.getExpression() != path, ""duplicate expression on the list!!!"");
	}
  }
  
  
  protected static void assertion(boolean b, String msg)
  {
  	if(!b)
  	{
  		throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR, new Object[]{msg}));
  		
  	}
  }
  
  
  class MultistepExprHolder implements Cloneable
  {
	ExpressionOwner m_exprOwner; 
	final int m_stepCount;
	MultistepExprHolder m_next;
	
	
	public Object clone()
		throws CloneNotSupportedException
	{
		return super.clone();
	}
	
	
  	MultistepExprHolder(ExpressionOwner exprOwner, int stepCount, MultistepExprHolder next)
  	{
  		m_exprOwner = exprOwner;
  		assertion(null != m_exprOwner, ""exprOwner can not be null!"");
  		m_stepCount = stepCount;
  		m_next = next;
  	}
	
	
	MultistepExprHolder addInSortedOrder(ExpressionOwner exprOwner, int stepCount)
	{
		MultistepExprHolder first = this;
		MultistepExprHolder next = this;
		MultistepExprHolder prev = null;
		while(null != next)
		{
			if(stepCount >= next.m_stepCount)
			{
				MultistepExprHolder newholder = new MultistepExprHolder(exprOwner, stepCount, next);
				if(null == prev)
					first = newholder;
				else
					prev.m_next = newholder;
					
				return first;
			}
			prev = next;
			next = next.m_next;
		}
		
		prev.m_next = new MultistepExprHolder(exprOwner, stepCount, null);
		return first;
	}
	
	
	MultistepExprHolder unlink(MultistepExprHolder itemToRemove)
	{
		MultistepExprHolder first = this;
		MultistepExprHolder next = this;
		MultistepExprHolder prev = null;
		while(null != next)
		{
			if(next == itemToRemove)
			{
				if(null == prev)
					first = next.m_next;
				else
					prev.m_next = next.m_next;
				
				next.m_next = null;
					
				return first;
			}
			prev = next;
			next = next.m_next;
		}
		
		assertion(false, ""unlink failed!!!"");
		return null;
	}
		
	
	int getLength()
	{
		int count = 0;
		MultistepExprHolder next = this;
		while(null != next)
		{
			count++;
			next = next.m_next;
		}
		return count;
	}
	
    
    protected void diagnose()
    {
      System.err.print(""Found multistep iterators: "" + this.getLength() + ""  "");
      MultistepExprHolder next = this;
      while (null != next)
      {
        System.err.print("""" + next.m_stepCount);
        next = next.m_next;
        if (null != next)
              System.err.print("", "");
      }
      System.err.println();
    }
	
  }

}"
org.apache.xml.utils.TreeWalker,10,1,0,12,65,0,7,5,7,0.305555556,623,0.75,1,0.0,0.44,0,0,60.9,1,0.7,2,"
package org.apache.xml.utils;

import java.io.File;

import org.w3c.dom.Comment;
import org.w3c.dom.Element;
import org.w3c.dom.EntityReference;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Text;

import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.LocatorImpl;



public class TreeWalker
{

  
  private ContentHandler m_contentHandler = null;

  
  

  
  protected DOMHelper m_dh;
        
        
        private LocatorImpl m_locator = new LocatorImpl();

  
  public ContentHandler getContentHandler()
  {
    return m_contentHandler;
  }

  
  public void setContentHandler(ContentHandler ch)
  {
    m_contentHandler = ch;
  }
        
        
  public TreeWalker(ContentHandler contentHandler, DOMHelper dh, String systemId)
  {
    this.m_contentHandler = contentHandler;
    m_contentHandler.setDocumentLocator(m_locator);
    if (systemId != null)
        m_locator.setSystemId(systemId);
    else {
        try {
          
          
          m_locator.setSystemId(System.getProperty(""user.dir"") + File.separator + ""dummy.xsl"");
         }
         catch (SecurityException se) {
             m_locator.setSystemId("""");
         }
    }
    m_dh = dh;
  }

  
  public TreeWalker(ContentHandler contentHandler, DOMHelper dh)
  {
    this.m_contentHandler = contentHandler;
    m_contentHandler.setDocumentLocator(m_locator);
    try {
      
      
      m_locator.setSystemId(System.getProperty(""user.dir"") + File.separator + ""dummy.xsl"");
    } 
    catch (SecurityException se){
      m_locator.setSystemId("""");
    }
    m_dh = dh;
  }
  
  
  public TreeWalker(ContentHandler contentHandler)
  {
    this.m_contentHandler = contentHandler;
                if (m_contentHandler != null)
                        m_contentHandler.setDocumentLocator(m_locator);
                try {
                  
                  
                  m_locator.setSystemId(System.getProperty(""user.dir"") + File.separator + ""dummy.xsl"");
                } 
                catch (SecurityException se){
                  m_locator.setSystemId("""");
    }
    m_dh = new DOM2Helper();
  }

  
  public void traverse(Node pos) throws org.xml.sax.SAXException
  {

   	this.m_contentHandler.startDocument();

    Node top = pos;

    while (null != pos)
    {
      startNode(pos);

      Node nextNode = pos.getFirstChild();

      while (null == nextNode)
      {
        endNode(pos);

        if (top.equals(pos))
          break;

        nextNode = pos.getNextSibling();

        if (null == nextNode)
        {
          pos = pos.getParentNode();

          if ((null == pos) || (top.equals(pos)))
          {
            if (null != pos)
              endNode(pos);

            nextNode = null;

            break;
          }
        }
      }

      pos = nextNode;
    }
    this.m_contentHandler.endDocument();
  }

  
  public void traverse(Node pos, Node top) throws org.xml.sax.SAXException
  {

	this.m_contentHandler.startDocument();
	
    while (null != pos)
    {
      startNode(pos);

      Node nextNode = pos.getFirstChild();

      while (null == nextNode)
      {
        endNode(pos);

        if ((null != top) && top.equals(pos))
          break;

        nextNode = pos.getNextSibling();

        if (null == nextNode)
        {
          pos = pos.getParentNode();

          if ((null == pos) || ((null != top) && top.equals(pos)))
          {
            nextNode = null;

            break;
          }
        }
      }

      pos = nextNode;
    }
    this.m_contentHandler.endDocument();
  }

  
  boolean nextIsRaw = false;
  
  
  private final void dispatachChars(Node node)
     throws org.xml.sax.SAXException
  {
    if(m_contentHandler instanceof org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.CharacterNodeHandler)
    {
      ((org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.CharacterNodeHandler)m_contentHandler).characters(node);
    }
    else
    {
      String data = ((Text) node).getData();
      this.m_contentHandler.characters(data.toCharArray(), 0, data.length());
    }
  }

  
  protected void startNode(Node node) throws org.xml.sax.SAXException
  {

    if (m_contentHandler instanceof NodeConsumer)
    {
      ((NodeConsumer) m_contentHandler).setOriginatingNode(node);
    }
                
                if (node instanceof Locator)
                {
                        Locator loc = (Locator)node;
                        m_locator.setColumnNumber(loc.getColumnNumber());
                        m_locator.setLineNumber(loc.getLineNumber());
                        m_locator.setPublicId(loc.getPublicId());
                        m_locator.setSystemId(loc.getSystemId());
                }
                else
                {
                        m_locator.setColumnNumber(0);
      m_locator.setLineNumber(0);
                }

    switch (node.getNodeType())
    {
    case Node.COMMENT_NODE :
    {
      String data = ((Comment) node).getData();

      if (m_contentHandler instanceof LexicalHandler)
      {
        LexicalHandler lh = ((LexicalHandler) this.m_contentHandler);

        lh.comment(data.toCharArray(), 0, data.length());
      }
    }
    break;
    case Node.DOCUMENT_FRAGMENT_NODE :

      
      break;
    case Node.DOCUMENT_NODE :
    
      break;
    case Node.ELEMENT_NODE :
      NamedNodeMap atts = ((Element) node).getAttributes();
      int nAttrs = atts.getLength();
      

      for (int i = 0; i < nAttrs; i++)
      {
        Node attr = atts.item(i);
        String attrName = attr.getNodeName();

        
        if (attrName.equals(""xmlns"") || attrName.startsWith(""xmlns:""))
        {
          
          int index;
          
          
          
          String prefix = (index = attrName.indexOf("":"")) < 0
                          ? """" : attrName.substring(index + 1);

          this.m_contentHandler.startPrefixMapping(prefix,
                                                   attr.getNodeValue());
        }
        
      }

      
      
      String ns = m_dh.getNamespaceOfNode(node);
      if(null == ns)
        ns = """";
      this.m_contentHandler.startElement(ns,
                                         m_dh.getLocalNameOfNode(node),
                                         node.getNodeName(),
                                         new AttList(atts, m_dh));
      break;
    case Node.PROCESSING_INSTRUCTION_NODE :
    {
      ProcessingInstruction pi = (ProcessingInstruction) node;
      String name = pi.getNodeName();

      
      if (name.equals(""xslt-next-is-raw""))
      {
        nextIsRaw = true;
      }
      else
      {
        this.m_contentHandler.processingInstruction(pi.getNodeName(),
                                                    pi.getData());
      }
    }
    break;
    case Node.CDATA_SECTION_NODE :
    {
      boolean isLexH = (m_contentHandler instanceof LexicalHandler);
      LexicalHandler lh = isLexH
                          ? ((LexicalHandler) this.m_contentHandler) : null;

      if (isLexH)
      {
        lh.startCDATA();
      }
      
      dispatachChars(node);

      {
        if (isLexH)
        {
          lh.endCDATA();
        }
      }
    }
    break;
    case Node.TEXT_NODE :
    {
      

      if (nextIsRaw)
      {
        nextIsRaw = false;

        m_contentHandler.processingInstruction(javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");
        dispatachChars(node);
        m_contentHandler.processingInstruction(javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");
      }
      else
      {
        dispatachChars(node);
      }
    }
    break;
    case Node.ENTITY_REFERENCE_NODE :
    {
      EntityReference eref = (EntityReference) node;

      if (m_contentHandler instanceof LexicalHandler)
      {
        ((LexicalHandler) this.m_contentHandler).startEntity(
          eref.getNodeName());
      }
      else
      {

        
      }
    }
    break;
    default :
    }
  }

  
  protected void endNode(Node node) throws org.xml.sax.SAXException
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_NODE :
      break;
      
    case Node.ELEMENT_NODE :
      String ns = m_dh.getNamespaceOfNode(node);
      if(null == ns)
        ns = """";
      this.m_contentHandler.endElement(ns,
                                         m_dh.getLocalNameOfNode(node),
                                         node.getNodeName());

      NamedNodeMap atts = ((Element) node).getAttributes();
      int nAttrs = atts.getLength();

      for (int i = 0; i < nAttrs; i++)
      {
        Node attr = atts.item(i);
        String attrName = attr.getNodeName();

        if (attrName.equals(""xmlns"") || attrName.startsWith(""xmlns:""))
        {
          int index;
          
          
          
          String prefix = (index = attrName.indexOf("":"")) < 0
                          ? """" : attrName.substring(index + 1);

          this.m_contentHandler.endPrefixMapping(prefix);
        }
      }
      break;
    case Node.CDATA_SECTION_NODE :
      break;
    case Node.ENTITY_REFERENCE_NODE :
    {
      EntityReference eref = (EntityReference) node;

      if (m_contentHandler instanceof LexicalHandler)
      {
        LexicalHandler lh = ((LexicalHandler) this.m_contentHandler);

        lh.endEntity(eref.getNodeName());
      }
    }
    break;
    default :
    }
  }
}  

"
org.apache.xalan.lib.sql.SQLErrorDocument,4,5,0,4,13,0,1,3,2,0.636363636,179,1.0,0,0.989528796,0.55,1,1,41.0,1,0.5,0,"

package org.apache.xalan.lib.sql;

import java.sql.SQLException;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMManager;




public class SQLErrorDocument extends DTMDocument
{
  
  private static final String S_EXT_ERROR = ""ext-error"";
  
  private static final String S_SQL_ERROR = ""sql-error"";
  
  private static final String S_MESSAGE = ""message"";
  
  private static final String S_CODE = ""code"";

  
  private int m_ErrorExt_TypeID = DTM.NULL;
  
  private int m_Message_TypeID = DTM.NULL;
  
  private int m_Code_TypeID = DTM.NULL;

  
  private int m_SQLError_TypeID = DTM.NULL;

  
  private int m_rootID = DTM.NULL;
  
  private int m_extErrorID = DTM.NULL;
  
  private int m_MainMessageID = DTM.NULL;

  
  public SQLErrorDocument( DTMManager mgr, int ident, SQLException error )
  {
    super(mgr, ident);

    createExpandedNameTable();
    buildBasicStructure(error);

    int sqlError = addElement(2, m_SQLError_TypeID, m_extErrorID, m_MainMessageID);
    int element = DTM.NULL;

    element = addElementWithData(
      new Integer(error.getErrorCode()), 3,
      m_Code_TypeID, sqlError, element);

    element = addElementWithData(
      error.getLocalizedMessage(), 3,
      m_Message_TypeID, sqlError, element);


  }


  
  public SQLErrorDocument( DTMManager mgr, int ident, Exception error )
  {
    super(mgr, ident);
    createExpandedNameTable();
    buildBasicStructure(error);
  }

  
  private void buildBasicStructure( Exception e )
  {
    m_rootID = addElement(0, m_Document_TypeID, DTM.NULL, DTM.NULL);
    m_extErrorID = addElement(1, m_ErrorExt_TypeID, m_rootID, DTM.NULL);
    m_MainMessageID = addElementWithData
      (e.getLocalizedMessage(), 2, m_Message_TypeID, m_extErrorID, DTM.NULL);
  }

  
  protected void createExpandedNameTable( )
  {

    super.createExpandedNameTable();

    m_ErrorExt_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_EXT_ERROR, DTM.ELEMENT_NODE);

    m_SQLError_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SQL_ERROR, DTM.ELEMENT_NODE);

    m_Message_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_MESSAGE, DTM.ELEMENT_NODE);

    m_Code_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_CODE, DTM.ELEMENT_NODE);
  }

}"
org.apache.xml.res.XMLErrorResources_sv,3,4,0,1,4,1,0,1,2,1.3,875,0.0,0,0.976190476,1.0,0,0,289.0,1,0.3333,0,"
package org.apache.xml.res;



public class XMLErrorResources_sv extends XMLErrorResources
{

  
  public static final int MAX_CODE = 61;

  
  public static final int MAX_WARNING = 0;

  
  public static final int MAX_OTHERS = 4;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  
  

  
  public static final Object[][] contents = {

  
    {""ER0000"" , ""{0}"" },

  
  


  {
    ER_FUNCTION_NOT_SUPPORTED, ""Funktion inte understödd:""},

  
  
  


  {
    ER_CANNOT_OVERWRITE_CAUSE,
			""Kan inte skriva över orsak""},

  
   
  


  {
    ER_NO_DEFAULT_IMPL,
         ""Standardimplementering saknas i:""},

  
   
  


  {
    ER_CHUNKEDINTARRAY_NOT_SUPPORTED,
       ""ChunkedIntArray({0}) understöds för närvarande inte""},

  
   
  


  {
    ER_OFFSET_BIGGER_THAN_SLOT,
       ""Offset större än fack""},

  
   
  


  {
    ER_COROUTINE_NOT_AVAIL,
       ""Sidorutin inte tillgänglig, id={0}""},

  
   
  


  {
    ER_COROUTINE_CO_EXIT,
       ""CoroutineManager mottog co_exit()-förfrågan""},

  
   
  


  {
    ER_COJOINROUTINESET_FAILED,
       ""co_joinCoroutineSet() misslyckades""},

  
   
  


  {
    ER_COROUTINE_PARAM,
       ""Sidorutin fick parameterfel ({0})""},

  
   
  


  {
    ER_PARSER_DOTERMINATE_ANSWERS,
       ""
OVÄNTAT: Parser doTerminate-svar {0}""},

  
   
  


  {
    ER_NO_PARSE_CALL_WHILE_PARSING,
       ""parse får inte anropas medan tolkning sker""},

  
   
  


  {
    ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""Fel: typad upprepare för axel {0} inte implementerad""},

  
   
  


  {
    ER_ITERATOR_AXIS_NOT_IMPLEMENTED,
       ""Fel: upprepare för axel {0} inte implementerad""},

  
   
  


  {
    ER_ITERATOR_CLONE_NOT_SUPPORTED,
       ""Uppreparklon understöds inte""},

  
   
  


  {
    ER_UNKNOWN_AXIS_TYPE,
       ""Okänd axeltraverstyp: {0}""},

  
   
  


  {
    ER_AXIS_NOT_SUPPORTED,
       ""Axeltravers understöds inte: {0}""},

  
   
  


  {
    ER_NO_DTMIDS_AVAIL,
       ""Inga fler DTM-IDs är tillgängliga""},

  
   
  


  {
    ER_NOT_SUPPORTED,
       ""Understöds inte: {0}""},

  
   
  


  {
    ER_NODE_NON_NULL,
       ""Nod måste vara icke-null för getDTMHandleFromNode""},

  
   
  


  {
    ER_COULD_NOT_RESOLVE_NODE,
       ""Kunde inte lösa nod till ett handtag""},

  
   
  


  {
    ER_STARTPARSE_WHILE_PARSING,
       ""startParse får inte anropas medan tolkning sker""},

  
   
  


  {
    ER_STARTPARSE_NEEDS_SAXPARSER,
       ""startParse behöver en SAXParser som är icke-null""},

  
   
  


  {
    ER_COULD_NOT_INIT_PARSER,
       ""kunde inte initialisera tolk med""},

  
   
  


  {
    ER_EXCEPTION_CREATING_POOL,
       ""undantag skapar ny instans för pool""},

  
   
  


  {
    ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE,
       ""Väg innehåller ogiltig flyktsekvens""},

  
   
  


  {
    ER_SCHEME_REQUIRED,
       ""Schema krävs!""},

  
   
  


  {
    ER_NO_SCHEME_IN_URI,
       ""Schema saknas i URI: {0}""},

  
   
  


  {
    ER_NO_SCHEME_INURI,
       ""Schema saknas i URI""},

  
   
  


  {
    ER_PATH_INVALID_CHAR,
       ""Väg innehåller ogiltigt tecken: {0}""},

  
   
  


  {
    ER_SCHEME_FROM_NULL_STRING,
       ""Kan inte sätta schema från null-sträng""},

  
   
  


  {
    ER_SCHEME_NOT_CONFORMANT,
       ""Schemat är inte likformigt.""},

  
   
  


  {
    ER_HOST_ADDRESS_NOT_WELLFORMED,
       ""Värd är inte en välformulerad adress""},

  
   
  


  {
    ER_PORT_WHEN_HOST_NULL,
       ""Port kan inte sättas när värd är null""},

  
   
  


  {
    ER_INVALID_PORT,
       ""Ogiltigt portnummer""},

  
   
  


  {
    ER_FRAG_FOR_GENERIC_URI,
       ""Fragment kan bara sättas för en allmän URI""},

  
   
  


  {
    ER_FRAG_WHEN_PATH_NULL,
       ""Fragment kan inte sättas när väg är null""},

  
   
  


  {
    ER_FRAG_INVALID_CHAR,
       ""Fragment innehåller ogiltigt tecken""},

  
 
  
   
  


  {
    ER_PARSER_IN_USE,
        ""Tolk används redan""},

  
   
  


  {
    ER_CANNOT_CHANGE_WHILE_PARSING,
        ""Kan inte ändra {0} {1} medan tolkning sker""},

  
   
  


  {
    ER_SELF_CAUSATION_NOT_PERMITTED,
        ""Självorsakande inte tillåten""},

  
   
  


  {
    ER_NO_USERINFO_IF_NO_HOST,
        ""Userinfo får inte anges om värden inte är angiven""},

  
   
  


  {
    ER_NO_PORT_IF_NO_HOST,
        ""Port får inte anges om värden inte är angiven""},

  
   
  


  {
    ER_NO_QUERY_STRING_IN_PATH,
        ""Förfrågan-sträng kan inte anges i väg och förfrågan-sträng""},

  
   
  


  {
    ER_NO_FRAGMENT_STRING_IN_PATH,
        ""Fragment kan inte anges i både vägen och fragmentet""},

  
   
  


  {
    ER_CANNOT_INIT_URI_EMPTY_PARMS,
        ""Kan inte initialisera URI med tomma parametrar""},

  
  
  


  {
    ER_METHOD_NOT_SUPPORTED,
        ""Metod ännu inte understödd ""},


  
  


  {
    ER_INCRSAXSRCFILTER_NOT_RESTARTABLE,
     ""IncrementalSAXSource_Filter kan för närvarande inte startas om""},

  
  
  


  {
    ER_XMLRDR_NOT_BEFORE_STARTPARSE,
     ""XMLReader inte innan startParse-begäran""},



  

  {
    ER_AXIS_TRAVERSER_NOT_SUPPORTED,
     ""Det går inte att vända axeln: {0}""},



  

  {
    ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER,
     ""ListingErrorHandler skapad med null PrintWriter!""},


  

  {
    ER_SYSTEMID_UNKNOWN,
     ""SystemId okänt""},


  
  

  {
    ER_LOCATION_UNKNOWN,
     ""Platsen för felet är okänd""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""Prefix must resolve to a namespace: {0}""},


  
  


  {
    ER_CREATEDOCUMENT_NOT_SUPPORTED,
      ""createDocument() understöds inte av XPathContext!""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT,
      ""Attributbarn saknar ägardokument!""},


  
  


  {
    ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
      ""Attributbarn saknar ägardokumentelement!""},


  
  


  {
    ER_CANT_OUTPUT_TEXT_BEFORE_DOC,
      ""Varning: kan inte skriva ut text innan dokumentelement!  Ignorerar...""},


  
  


  {
    ER_CANT_HAVE_MORE_THAN_ONE_ROOT,
      ""Kan inte ha mer än en rot på en DOM!""},

  
   
  


  {
    ER_ARG_LOCALNAME_NULL,
       ""Argument 'localName' är null""},


  
  
  

  
  


  {
    ER_ARG_LOCALNAME_INVALID,
       ""Localname i QNAME bör vara ett giltigt NCName""},

  
  
  
  

  
  


  {
    ER_ARG_PREFIX_INVALID,
       ""Prefixet i QNAME bör vara ett giltigt NCName""},

  { ""BAD_CODE"",
      ""Parameter till createMessage ligger utanför tillåtet intervall""},
  { ""FORMAT_FAILED"",
      ""Undantag utlöst vid messageFormat-anrop""},
  { ""line"",  ""Rad #""},
  { ""column"", ""Kolumn #""}
         
  };
 
  
  public Object[][] getContents()
  {
    return contents;
  }
 
}"
org.apache.xalan.processor.ProcessorStylesheetDoc,1,4,0,2,2,0,1,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xalan.processor;


public class ProcessorStylesheetDoc extends XSLTElementProcessor
{
}
"
org.apache.xalan.templates.ElemTemplateElement,85,2,29,94,127,3140,83,17,74,0.912698413,1307,0.75,3,0.564766839,0.092041522,1,12,14.23529412,9,1.5529,4,"
package org.apache.xalan.templates;

import java.io.Serializable;
import java.util.Enumeration;
import java.util.Vector;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.UnImplNode;
import org.apache.xpath.ExpressionNode;
import org.apache.xpath.WhitespaceStrippingElementMatcher;

import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.xml.sax.helpers.NamespaceSupport;


public class ElemTemplateElement extends UnImplNode
        implements PrefixResolver, Serializable, ExpressionNode, 
                   WhitespaceStrippingElementMatcher, XSLTVisitable
{

  
  public ElemTemplateElement(){}

  
  public boolean isCompiledTemplate()
  {
    return false;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_UNDEFINED;
  }

  
  public String getNodeName()
  {
    return ""Unknown XSLT Element"";
  }
  
  
  public String getLocalName()
  {

    return getNodeName();
  }


  
  public void runtimeInit(TransformerImpl transformer) throws TransformerException{}

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException{}

  
  public StylesheetComposed getStylesheetComposed()
  {
    return m_parentNode.getStylesheetComposed();
  }

  
  public Stylesheet getStylesheet()
  {
    return (null==m_parentNode) ? null : m_parentNode.getStylesheet();
  }

  
  public StylesheetRoot getStylesheetRoot()
  {
    return m_parentNode.getStylesheetRoot();
  }

  
  public void recompose(StylesheetRoot root) throws TransformerException
  {
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    resolvePrefixTables();
    ElemTemplateElement t = getFirstChildElem();
    m_hasTextLitOnly = ((t != null) 
              && (t.getXSLToken() == Constants.ELEMNAME_TEXTLITERALRESULT) 
              && (t.getNextSiblingElem() == null));
              
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    cstate.pushStackMark();
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    cstate.popStackMark();
  }

  
  protected boolean isValidNCName(String s)
  {

    int len = s.length();
    char c = s.charAt(0);

    if (!(Character.isLetter(c) || (c == '_')))
      return false;

    if (len > 0)
    {
      for (int i = 1; i < len; i++)
      {
        c = s.charAt(i);

        if (!(Character.isLetterOrDigit(c) || (c == '_') || (c == '-')
              || (c == '.')))
          return false;
      }
    }

    return true;
  }

  
  public void error(String msg, Object[] args)
  {

    String themsg = XSLMessages.createMessage(msg, args);

    throw new RuntimeException(XSLMessages.createMessage(
                                    XSLTErrorResources.ER_ELEMTEMPLATEELEM_ERR,
                                    new Object[]{ themsg }));
  }
  
  
  public void error(String msg)
  {
    error(msg, null);
  }
  

  
  
  public Node appendChild(Node newChild) throws DOMException
  {

    if (null == newChild)
    {
      error(XSLTErrorResources.ER_NULL_CHILD, null);  
    }

    ElemTemplateElement elem = (ElemTemplateElement) newChild;

    if (null == m_firstChild)
    {
      m_firstChild = elem;
    }
    else
    {
      ElemTemplateElement last = (ElemTemplateElement) getLastChild();

      last.m_nextSibling = elem;
    }

    elem.m_parentNode = this;

    return newChild;
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement elem)
  {

    if (null == elem)
    {
      error(XSLTErrorResources.ER_NULL_CHILD, null);  
    }

    if (null == m_firstChild)
    {
      m_firstChild = elem;
    }
    else
    {
      ElemTemplateElement last = getLastChildElem();

      last.m_nextSibling = elem;
    }

    elem.setParentElem(this);

    return elem;
  }


  
  public boolean hasChildNodes()
  {
    return (null != m_firstChild);
  }

  
  public short getNodeType()
  {
    return org.w3c.dom.Node.ELEMENT_NODE;
  }

  
  public NodeList getChildNodes()
  {
    return this;
  }

  
  public ElemTemplateElement removeChild(ElemTemplateElement childETE)
  {

    if (childETE == null || childETE.m_parentNode != this)
      return null;

    
    if (childETE == m_firstChild)
      m_firstChild = childETE.m_nextSibling;
    else
    {
      ElemTemplateElement prev = childETE.getPreviousSiblingElem();

      prev.m_nextSibling = childETE.m_nextSibling;
    }

    
    childETE.m_parentNode = null;
    childETE.m_nextSibling = null;

    return childETE;
  }

  
  public Node replaceChild(Node newChild, Node oldChild) throws DOMException
  {

    if (oldChild == null || oldChild.getParentNode() != this)
      return null;

    ElemTemplateElement newChildElem = ((ElemTemplateElement) newChild);
    ElemTemplateElement oldChildElem = ((ElemTemplateElement) oldChild);

    
    ElemTemplateElement prev =
      (ElemTemplateElement) oldChildElem.getPreviousSibling();

    if (null != prev)
      prev.m_nextSibling = newChildElem;

    
    if (m_firstChild == oldChildElem)
      m_firstChild = newChildElem;

    newChildElem.m_parentNode = this;
    oldChildElem.m_parentNode = null;
    newChildElem.m_nextSibling = oldChildElem.m_nextSibling;
    oldChildElem.m_nextSibling = null;

    
    
    return newChildElem;
  }
  
  
  public Node insertBefore(Node newChild, Node refChild) throws DOMException
  {
  	if(null == refChild)
  	{
  		appendChild(newChild);
  		return newChild;
  	}
  	
  	if(newChild == refChild)
  	{
  		
  		return newChild;
  	}

    Node node = m_firstChild; 
    Node prev = null;  
    boolean foundit = false;
    
    while (null != node)
    {
    	
    	if(newChild == node)
    	{
    		if(null != prev)
    			((ElemTemplateElement)prev).m_nextSibling = 
    				(ElemTemplateElement)node.getNextSibling();
    		else
    			m_firstChild = (ElemTemplateElement)node.getNextSibling();
    		node = node.getNextSibling();
    		continue; 
    	}
    	if(refChild == node)
    	{
    		if(null != prev)
    		{
    			((ElemTemplateElement)prev).m_nextSibling = (ElemTemplateElement)newChild;
    		}
    		else
    		{
    			m_firstChild = (ElemTemplateElement)newChild;
    		}
    		((ElemTemplateElement)newChild).m_nextSibling = (ElemTemplateElement)refChild;
    		((ElemTemplateElement)newChild).setParentElem(this);
    		prev = newChild;
    		node = node.getNextSibling();
    		foundit = true;
    		continue;
    	}
    	prev = node;
    	node = node.getNextSibling();
    }
    
    if(!foundit)
    	throw new DOMException(DOMException.NOT_FOUND_ERR, 
    		""refChild was not found in insertBefore method!"");
    else
    	return newChild;
  }


  
  public ElemTemplateElement replaceChild(ElemTemplateElement newChildElem, 
                                          ElemTemplateElement oldChildElem)
  {

    if (oldChildElem == null || oldChildElem.getParentElem() != this)
      return null;

    
    ElemTemplateElement prev =
      oldChildElem.getPreviousSiblingElem();

    if (null != prev)
      prev.m_nextSibling = newChildElem;

    
    if (m_firstChild == oldChildElem)
      m_firstChild = newChildElem;

    newChildElem.m_parentNode = this;
    oldChildElem.m_parentNode = null;
    newChildElem.m_nextSibling = oldChildElem.m_nextSibling;
    oldChildElem.m_nextSibling = null;

    
    
    return newChildElem;
  }

  
  public int getLength()
  {

    
    
    
    int count = 0;

    for (ElemTemplateElement node = m_firstChild; node != null;
            node = node.m_nextSibling)
    {
      count++;
    }

    return count;
  }  

  
  public Node item(int index)
  {

    
    
    
    ElemTemplateElement node = m_firstChild;

    for (int i = 0; i < index && node != null; i++)
    {
      node = node.m_nextSibling;
    }

    return node;
  }  

  
  public Document getOwnerDocument()
  {
    return getStylesheet();
  }
  
  
  public ElemTemplate getOwnerXSLTemplate()
  {
  	ElemTemplateElement el = this;
  	int type = el.getXSLToken();
  	while((null != el) && (type != Constants.ELEMNAME_TEMPLATE))
  	{
    	el = el.getParentElem();
    	if(null != el)
  			type = el.getXSLToken();
  	}
  	return (ElemTemplate)el;
  }


  
  public String getTagName()
  {
    return getNodeName();
  }
  
  
  public boolean hasTextLitOnly()
  {
    return m_hasTextLitOnly;
  }

  
  public String getBaseIdentifier()
  {

    
    return this.getSystemId();
  }

  
  private int m_lineNumber;

  
  public int getLineNumber()
  {
    return m_lineNumber;
  }

  
  private int m_columnNumber;

  
  public int getColumnNumber()
  {
    return m_columnNumber;
  }

  
  public String getPublicId()
  {
    return (null != m_parentNode) ? m_parentNode.getPublicId() : null;
  }

  
  public String getSystemId()
  {
    Stylesheet sheet=getStylesheet();
    return (sheet==null) ? null : sheet.getHref();
  }

  
  public void setLocaterInfo(SourceLocator locator)
  {
    m_lineNumber = locator.getLineNumber();
    m_columnNumber = locator.getColumnNumber();
  }

  
  private boolean m_defaultSpace = true;

  
  private boolean m_hasTextLitOnly = false;

  
  protected boolean m_hasVariableDecl = false;
  
  public boolean hasVariableDecl()
  {
    return m_hasVariableDecl;
  }

  
  public void setXmlSpace(int v)
  {
    m_defaultSpace = ((Constants.ATTRVAL_STRIP == v) ? true : false);
  }

  
  public boolean getXmlSpace()
  {
    return m_defaultSpace;
  }

  
  private Vector m_declaredPrefixes;

  
  public Vector getDeclaredPrefixes()
  {
    return m_declaredPrefixes;
  }

  
  public void setPrefixes(NamespaceSupport nsSupport) throws TransformerException
  {
    setPrefixes(nsSupport, false);
  }

  
  public void setPrefixes(NamespaceSupport nsSupport, boolean excludeXSLDecl)
          throws TransformerException
  {

    Enumeration decls = nsSupport.getDeclaredPrefixes();

    while (decls.hasMoreElements())
    {
      String prefix = (String) decls.nextElement();

      if (null == m_declaredPrefixes)
        m_declaredPrefixes = new Vector();

      String uri = nsSupport.getURI(prefix);

      if (excludeXSLDecl && uri.equals(Constants.S_XSLNAMESPACEURL))
        continue;

      
      XMLNSDecl decl = new XMLNSDecl(prefix, uri, false);

      m_declaredPrefixes.addElement(decl);
    }
  }

  
  public String getNamespaceForPrefix(String prefix, org.w3c.dom.Node context)
  {
    this.error(XSLTErrorResources.ER_CANT_RESOLVE_NSPREFIX, null);

    return null;
  }

  
  public String getNamespaceForPrefix(String prefix)
  {





    Vector nsDecls = m_declaredPrefixes;

    if (null != nsDecls)
    {
      int n = nsDecls.size();
      if(prefix.equals(Constants.ATTRVAL_DEFAULT_PREFIX))
      {
        prefix = """";
      }

      for (int i = 0; i < n; i++)
      {
        XMLNSDecl decl = (XMLNSDecl) nsDecls.elementAt(i);

        if (prefix.equals(decl.getPrefix()))
          return decl.getURI();
      }
    }

    
    if (null != m_parentNode)
      return m_parentNode.getNamespaceForPrefix(prefix);

    
    
    
    if(""xml"".equals(prefix))
      return ""http:

    
    return null;
  }

  
  Vector m_prefixTable;

  
  public Vector getPrefixes()
  {
    return m_prefixTable;
  }
  
  
  public boolean containsExcludeResultPrefix(String prefix, String uri)
  {
    ElemTemplateElement parent = this.getParentElem();
    if(null != parent)
      return parent.containsExcludeResultPrefix(prefix, uri);
      
    return false;
  }

  
  private boolean excludeResultNSDecl(String prefix, String uri)
          throws TransformerException
  {

    if (uri != null)
    {
      if (uri.equals(Constants.S_XSLNAMESPACEURL)
              || getStylesheet().containsExtensionElementURI(uri)
              || uri.equals(Constants.S_BUILTIN_EXTENSIONS_URL)
              || uri.equals(Constants.S_BUILTIN_OLD_EXTENSIONS_URL))
        return true;

      if (containsExcludeResultPrefix(prefix, uri))
        return true;
    }

    return false;
  }
  
  
  public void resolvePrefixTables() throws TransformerException
  {
    
    m_prefixTable = null;

    
    
    
    
    if (null != this.m_declaredPrefixes)
    {
      StylesheetRoot stylesheet = this.getStylesheetRoot();
      
      
      
      int n = m_declaredPrefixes.size();

      for (int i = 0; i < n; i++)
      {
        XMLNSDecl decl = (XMLNSDecl) m_declaredPrefixes.elementAt(i);
        String prefix = decl.getPrefix();
        String uri = decl.getURI();
        if(null == uri)
          uri = """";
        boolean shouldExclude = excludeResultNSDecl(prefix, uri);

        
        if (null == m_prefixTable)
          m_prefixTable = new Vector();

        NamespaceAlias nsAlias = stylesheet.getNamespaceAliasComposed(uri);
        if(null != nsAlias)
        {
          
          
          
          
          
          
          decl = new XMLNSDecl(nsAlias.getStylesheetPrefix(), 
                              nsAlias.getResultNamespace(), shouldExclude);
        }
        else
          decl = new XMLNSDecl(prefix, uri, shouldExclude);

        m_prefixTable.addElement(decl);
        
      }
    }

    ElemTemplateElement parent = this.getParentNodeElem();

    if (null != parent)
    {

      
      Vector prefixes = parent.m_prefixTable;

      if (null == m_prefixTable && !needToCheckExclude())
      {

        
        this.m_prefixTable = parent.m_prefixTable;
      }
      else
      {

        
        int n = prefixes.size();
        
        for (int i = 0; i < n; i++)
        {
          XMLNSDecl decl = (XMLNSDecl) prefixes.elementAt(i);
          boolean shouldExclude = excludeResultNSDecl(decl.getPrefix(),
                                                      decl.getURI());

          if (shouldExclude != decl.getIsExcluded())
          {
            decl = new XMLNSDecl(decl.getPrefix(), decl.getURI(),
                                 shouldExclude);
          }
          
          
          addOrReplaceDecls(decl);
        }
      }
    }
    else if (null == m_prefixTable)
    {

      
      m_prefixTable = new Vector();
    }
  }
  
  
  void addOrReplaceDecls(XMLNSDecl newDecl)
  {
      int n = m_prefixTable.size();

        for (int i = n - 1; i >= 0; i--)
        {
          XMLNSDecl decl = (XMLNSDecl) m_prefixTable.elementAt(i);

          if (decl.getPrefix().equals(newDecl.getPrefix()))
          {
            return;
          }
        }
      m_prefixTable.addElement(newDecl);    
    
  }
  
  
  boolean needToCheckExclude()
  {
    return false;    
  } 

  
  void executeNSDecls(TransformerImpl transformer) throws TransformerException
  {
       executeNSDecls(transformer, null);
  }

  
  void executeNSDecls(TransformerImpl transformer, String ignorePrefix) throws TransformerException
  {  
    try
    {
      if (null != m_prefixTable)
      {
        SerializationHandler rhandler = transformer.getResultTreeHandler();
        int n = m_prefixTable.size();

        for (int i = n - 1; i >= 0; i--)
        {
          XMLNSDecl decl = (XMLNSDecl) m_prefixTable.elementAt(i);

          if (!decl.getIsExcluded() && !(null != ignorePrefix && decl.getPrefix().equals(ignorePrefix)))
          {
            rhandler.startPrefixMapping(decl.getPrefix(), decl.getURI(), true);
          }
        }
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }

  
  void unexecuteNSDecls(TransformerImpl transformer) throws TransformerException
  {
       unexecuteNSDecls(transformer, null);
  }

  
  void unexecuteNSDecls(TransformerImpl transformer, String ignorePrefix) throws TransformerException
  {
 
    try
    {
      if (null != m_prefixTable)
      {
        SerializationHandler rhandler = transformer.getResultTreeHandler();
        int n = m_prefixTable.size();

        for (int i = 0; i < n; i++)
        {
          XMLNSDecl decl = (XMLNSDecl) m_prefixTable.elementAt(i);

          if (!decl.getIsExcluded() && !(null != ignorePrefix && decl.getPrefix().equals(ignorePrefix)))
          {
            rhandler.endPrefixMapping(decl.getPrefix());
          }
        }
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }
  
  
  protected int m_docOrderNumber = -1;
  
  
  public void setUid(int i)
  {
    m_docOrderNumber = i;
  }

  
  public int getUid()
  {
    return m_docOrderNumber;
  }


  
  protected ElemTemplateElement m_parentNode;

  
  public Node getParentNode()
  {
    return m_parentNode;
  }

  
  public ElemTemplateElement getParentElem()
  {
    return m_parentNode;
  }

  
  public void setParentElem(ElemTemplateElement p)
  {
    m_parentNode = p;
  }

  
  ElemTemplateElement m_nextSibling;

  
  public Node getNextSibling()
  {
    return m_nextSibling;
  }

  
  public Node getPreviousSibling()
  {

    Node walker = getParentNode(), prev = null;

    if (walker != null)
      for (walker = walker.getFirstChild(); walker != null;
              prev = walker, walker = walker.getNextSibling())
      {
        if (walker == this)
          return prev;
      }

    return null;
  }

  
  public ElemTemplateElement getPreviousSiblingElem()
  {

    ElemTemplateElement walker = getParentNodeElem();
    ElemTemplateElement prev = null;

    if (walker != null)
      for (walker = walker.getFirstChildElem(); walker != null;
              prev = walker, walker = walker.getNextSiblingElem())
      {
        if (walker == this)
          return prev;
      }

    return null;
  }


  
  public ElemTemplateElement getNextSiblingElem()
  {
    return m_nextSibling;
  }
  
  
  public ElemTemplateElement getParentNodeElem()
  {
    return m_parentNode;
  }


  
  ElemTemplateElement m_firstChild;

  
  public Node getFirstChild()
  {
    return m_firstChild;
  }

  
  public ElemTemplateElement getFirstChildElem()
  {
    return m_firstChild;
  }

  
  public Node getLastChild()
  {

    ElemTemplateElement lastChild = null;

    for (ElemTemplateElement node = m_firstChild; node != null;
            node = node.m_nextSibling)
    {
      lastChild = node;
    }

    return lastChild;
  }

  
  public ElemTemplateElement getLastChildElem()
  {

    ElemTemplateElement lastChild = null;

    for (ElemTemplateElement node = m_firstChild; node != null;
            node = node.m_nextSibling)
    {
      lastChild = node;
    }

    return lastChild;
  }


  
  transient private org.w3c.dom.Node m_DOMBackPointer;

  
  public org.w3c.dom.Node getDOMBackPointer()
  {
    return m_DOMBackPointer;
  }

  
  public void setDOMBackPointer(org.w3c.dom.Node n)
  {
    m_DOMBackPointer = n;
  }

  
  public int compareTo(Object o) throws ClassCastException {
    
    ElemTemplateElement ro = (ElemTemplateElement) o;
    int roPrecedence = ro.getStylesheetComposed().getImportCountComposed();
    int myPrecedence = this.getStylesheetComposed().getImportCountComposed();

    if (myPrecedence < roPrecedence)
      return -1;
    else if (myPrecedence > roPrecedence)
      return 1;
    else
      return this.getUid() - ro.getUid();
  }
  
  
  public boolean shouldStripWhiteSpace(
          org.apache.xpath.XPathContext support, 
          org.w3c.dom.Element targetElement) throws TransformerException
  {
    StylesheetRoot sroot = this.getStylesheetRoot();
    return (null != sroot) ? sroot.shouldStripWhiteSpace(support, targetElement) :false;
  }
  
  
  public boolean canStripWhiteSpace()
  {
    StylesheetRoot sroot = this.getStylesheetRoot();
    return (null != sroot) ? sroot.canStripWhiteSpace() : false;
  }
  
  
  public boolean canAcceptVariables()
  {
  	return true;
  }
  
  
  
  
  public void exprSetParent(ExpressionNode n)
  {
  	
  	
  	setParentElem((ElemTemplateElement)n);
  }
  
  
  public ExpressionNode exprGetParent()
  {
  	return getParentElem();
  }

  
  public void exprAddChild(ExpressionNode n, int i)
  {
  	appendChild((ElemTemplateElement)n);
  }

  
  public ExpressionNode exprGetChild(int i)
  {
  	return (ExpressionNode)item(i);
  }

  
  public int exprGetNumChildren()
  {
  	return getLength();
  }
  
  
  protected boolean accept(XSLTVisitor visitor)
  {
  	return visitor.visitInstruction(this);
  }

  
  public void callVisitors(XSLTVisitor visitor)
  {
  	if(accept(visitor))
  	{
		callChildVisitors(visitor);
  	}
  }

  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttributes)
  {
    for (ElemTemplateElement node = m_firstChild;
      node != null;
      node = node.m_nextSibling)
      {
      node.callVisitors(visitor);
    }
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor)
  {
  	callChildVisitors(visitor, true);
  }


	
	public boolean handlesNullPrefixes() {
		return false;
	}

}
"
org.apache.xml.utils.IntStack,12,2,0,11,20,24,10,1,12,2.0,153,0.0,0,0.64,0.527777778,1,14,11.75,2,1.0,1,"
package org.apache.xml.utils;

import java.util.EmptyStackException;


public class IntStack extends IntVector
{

  
  public IntStack()
  {
    super();
  }

  
  public IntStack(int blocksize)
  {
    super(blocksize);
  }
  
  
  public IntStack (IntStack v)
  {
  	super(v);
  }

  
  public int push(int i)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = i;

    m_firstFree++;

    return i;
  }

  
  public final int pop()
  {
    return m_map[--m_firstFree];
  }

  

  public final void quickPop(int n)
  {
    m_firstFree -= n;
  }

  
  public final int peek()
  {
    try {
      return m_map[m_firstFree - 1];
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      throw new EmptyStackException();
    }
  }

  
  public int peek(int n)
  {
    try {
      return m_map[m_firstFree-(1+n)];
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      throw new EmptyStackException();
    }
  }

  
  public void setTop(int val)
  {
    try {
      m_map[m_firstFree - 1] = val;
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      throw new EmptyStackException();
    }
  }

  
  public boolean empty()
  {
    return m_firstFree == 0;
  }

  
  public int search(int o)
  {

    int i = lastIndexOf(o);

    if (i >= 0)
    {
      return size() - i;
    }

    return -1;
  }
  
  
  public Object clone()
    throws CloneNotSupportedException
  {
  	return (IntStack) super.clone();
  }
}
"
org.apache.xalan.lib.sql.ConnectionPool,14,1,0,4,14,91,4,0,14,2.0,14,0.0,0,0.0,0.273809524,0,0,0.0,1,1.0,1,"

package org.apache.xalan.lib.sql;

import java.sql.Connection;
import java.sql.SQLException;
import java.util.Properties;


public interface ConnectionPool
{

  
  public boolean isEnabled( );

  
  public void setDriver( String d );

  
  public void setURL( String url );

  
  public void freeUnused( );


  
  public boolean hasActiveConnections( );

  
  public void setPassword( String p );

  
  public void setUser( String u );


  
  public void setMinConnections( int n );

  
  public boolean testConnection( );

  
  public Connection getConnection( )throws SQLException;

   
  public void releaseConnection( Connection con )throws SQLException;

   
  public void releaseConnectionOnError( Connection con )throws SQLException;


  
  public void setPoolEnabled( final boolean flag );

  
  public void setProtocol(Properties p);


}"
org.apache.xpath.NodeSet,61,1,0,10,71,714,6,4,60,0.629166667,1450,0.875,0,0.0,0.219262295,0,0,22.63934426,9,2.2131,2,"
package org.apache.xpath;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.DOM2Helper;
import org.apache.xpath.axes.ContextNodeList;
import org.apache.xpath.res.XPATHErrorResources;

import org.w3c.dom.DOMException;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeFilter;
import org.w3c.dom.traversal.NodeIterator;



public class NodeSet
        implements NodeList, NodeIterator, Cloneable, ContextNodeList
{

  
  public NodeSet()
  {
    m_blocksize = 32;
    m_mapSize = 0;
  }

  
  public NodeSet(int blocksize)
  {
    m_blocksize = blocksize;
    m_mapSize = 0;
  }

  
  public NodeSet(NodeList nodelist)
  {

    this(32);

    addNodes(nodelist);
  }

  
  public NodeSet(NodeSet nodelist)
  {

    this(32);

    addNodes((NodeIterator) nodelist);
  }

  
  public NodeSet(NodeIterator ni)
  {

    this(32);

    addNodes(ni);
  }

  
  public NodeSet(Node node)
  {

    this(32);

    addNode(node);
  }

  
  public Node getRoot()
  {
    return null;
  }

  
  public NodeIterator cloneWithReset() throws CloneNotSupportedException
  {

    NodeSet clone = (NodeSet) clone();

    clone.reset();

    return clone;
  }

  
  public void reset()
  {
    m_next = 0;
  }

  
  public int getWhatToShow()
  {
    return NodeFilter.SHOW_ALL & ~NodeFilter.SHOW_ENTITY_REFERENCE;
  }

  
  public NodeFilter getFilter()
  {
    return null;
  }

  
  public boolean getExpandEntityReferences()
  {
    return true;
  }

  
  public Node nextNode() throws DOMException
  {

    if ((m_next) < this.size())
    {
      Node next = this.elementAt(m_next);

      m_next++;

      return next;
    }
    else
      return null;
  }

  
  public Node previousNode() throws DOMException
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_ITERATE, null)); 

    if ((m_next - 1) > 0)
    {
      m_next--;

      return this.elementAt(m_next);
    }
    else
      return null;
  }

  
  public void detach(){}

  
  public boolean isFresh()
  {
    return (m_next == 0);
  }

  
  public void runTo(int index)
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_INDEX, null)); 

    if ((index >= 0) && (m_next < m_firstFree))
      m_next = index;
    else
      m_next = m_firstFree - 1;
  }

  
  public Node item(int index)
  {

    runTo(index);

    return (Node) this.elementAt(index);
  }

  
  public int getLength()
  {

    runTo(-1);

    return this.size();
  }

  
  public void addNode(Node n)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    this.addElement(n);
  }

  
  public void insertNode(Node n, int pos)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    insertElementAt(n, pos);
  }

  
  public void removeNode(Node n)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    this.removeElement(n);
  }

  
  public void addNodes(NodeList nodelist)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null != nodelist)  
    {
      int nChildren = nodelist.getLength();

      for (int i = 0; i < nChildren; i++)
      {
        Node obj = nodelist.item(i);

        if (null != obj)
        {
          addElement(obj);
        }
      }
    }

    
  }

  
  public void addNodes(NodeSet ns)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    addNodes((NodeIterator) ns);
  }

  
  public void addNodes(NodeIterator iterator)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null != iterator)  
    {
      Node obj;

      while (null != (obj = iterator.nextNode()))
      {
        addElement(obj);
      }
    }

    
  }

  
  public void addNodesInDocOrder(NodeList nodelist, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    int nChildren = nodelist.getLength();

    for (int i = 0; i < nChildren; i++)
    {
      Node node = nodelist.item(i);

      if (null != node)
      {
        addNodeInDocOrder(node, support);
      }
    }
  }

  
  public void addNodesInDocOrder(NodeIterator iterator, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    Node node;

    while (null != (node = iterator.nextNode()))
    {
      addNodeInDocOrder(node, support);
    }
  }

  
  private boolean addNodesInDocOrder(int start, int end, int testIndex,
                                     NodeList nodelist, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    boolean foundit = false;
    int i;
    Node node = nodelist.item(testIndex);

    for (i = end; i >= start; i--)
    {
      Node child = (Node) elementAt(i);

      if (child == node)
      {
        i = -2;  

        break;
      }

      if (!DOM2Helper.isNodeAfter(node, child))
      {
        insertElementAt(node, i + 1);

        testIndex--;

        if (testIndex > 0)
        {
          boolean foundPrev = addNodesInDocOrder(0, i, testIndex, nodelist,
                                                 support);

          if (!foundPrev)
          {
            addNodesInDocOrder(i, size() - 1, testIndex, nodelist, support);
          }
        }

        break;
      }
    }

    if (i == -1)
    {
      insertElementAt(node, 0);
    }

    return foundit;
  }

  
  public int addNodeInDocOrder(Node node, boolean test, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    int insertIndex = -1;

    if (test)
    {

      
      
      
      int size = size(), i;

      for (i = size - 1; i >= 0; i--)
      {
        Node child = (Node) elementAt(i);

        if (child == node)
        {
          i = -2;  

          break;
        }

        if (!DOM2Helper.isNodeAfter(node, child))
        {
          break;
        }
      }

      if (i != -2)
      {
        insertIndex = i + 1;

        insertElementAt(node, insertIndex);
      }
    }
    else
    {
      insertIndex = this.size();

      boolean foundit = false;

      for (int i = 0; i < insertIndex; i++)
      {
        if (this.item(i).equals(node))
        {
          foundit = true;

          break;
        }
      }

      if (!foundit)
        addElement(node);
    }

    
    return insertIndex;
  }  

  
  public int addNodeInDocOrder(Node node, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    return addNodeInDocOrder(node, true, support);
  }  


  
  transient protected int m_next = 0;

  
  public int getCurrentPos()
  {
    return m_next;
  }

  
  public void setCurrentPos(int i)
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_INDEX, null)); 

    m_next = i;
  }

  
  public Node getCurrentNode()
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_INDEX, null)); 

    int saved = m_next;
    Node n = (m_next < m_firstFree) ? elementAt(m_next) : null;
    m_next = saved; 
    return n;
  }

  
  transient protected boolean m_mutable = true;

  
  transient protected boolean m_cacheNodes = true;

  
  public boolean getShouldCacheNodes()
  {
    return m_cacheNodes;
  }

  
  public void setShouldCacheNodes(boolean b)
  {

    if (!isFresh())
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANNOT_CALL_SETSHOULDCACHENODE, null)); 

    m_cacheNodes = b;
    m_mutable = true;
  }
  
  
  transient private int m_last = 0;
  
  public int getLast()
  {
    return m_last;
  }
  
  public void setLast(int last)
  {
    m_last = last;
  }
  
  
  private int m_blocksize;

  
  Node m_map[];

  
  protected int m_firstFree = 0;

  
  private int m_mapSize;  

  
  public Object clone() throws CloneNotSupportedException
  {

    NodeSet clone = (NodeSet) super.clone();

    if ((null != this.m_map) && (this.m_map == clone.m_map))
    {
      clone.m_map = new Node[this.m_map.length];

      System.arraycopy(this.m_map, 0, clone.m_map, 0, this.m_map.length);
    }

    return clone;
  }

  
  public int size()
  {
    return m_firstFree;
  }

  
  public void addElement(Node value)
  {
    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if ((m_firstFree + 1) >= m_mapSize)
    {
      if (null == m_map)
      {
        m_map = new Node[m_blocksize];
        m_mapSize = m_blocksize;
      }
      else
      {
        m_mapSize += m_blocksize;

        Node newMap[] = new Node[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

        m_map = newMap;
      }
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final void push(Node value)
  {

    int ff = m_firstFree;

    if ((ff + 1) >= m_mapSize)
    {
      if (null == m_map)
      {
        m_map = new Node[m_blocksize];
        m_mapSize = m_blocksize;
      }
      else
      {
        m_mapSize += m_blocksize;

        Node newMap[] = new Node[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, ff + 1);

        m_map = newMap;
      }
    }

    m_map[ff] = value;

    ff++;

    m_firstFree = ff;
  }

  
  public final Node pop()
  {

    m_firstFree--;

    Node n = m_map[m_firstFree];

    m_map[m_firstFree] = null;

    return n;
  }

  
  public final Node popAndTop()
  {

    m_firstFree--;

    m_map[m_firstFree] = null;

    return (m_firstFree == 0) ? null : m_map[m_firstFree - 1];
  }

  
  public final void popQuick()
  {

    m_firstFree--;

    m_map[m_firstFree] = null;
  }

  
  public final Node peepOrNull()
  {
    return ((null != m_map) && (m_firstFree > 0))
           ? m_map[m_firstFree - 1] : null;
  }

  
  public final void pushPair(Node v1, Node v2)
  {

    if (null == m_map)
    {
      m_map = new Node[m_blocksize];
      m_mapSize = m_blocksize;
    }
    else
    {
      if ((m_firstFree + 2) >= m_mapSize)
      {
        m_mapSize += m_blocksize;

        Node newMap[] = new Node[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, m_firstFree);

        m_map = newMap;
      }
    }

    m_map[m_firstFree] = v1;
    m_map[m_firstFree + 1] = v2;
    m_firstFree += 2;
  }

  
  public final void popPair()
  {

    m_firstFree -= 2;
    m_map[m_firstFree] = null;
    m_map[m_firstFree + 1] = null;
  }

  
  public final void setTail(Node n)
  {
    m_map[m_firstFree - 1] = n;
  }

  
  public final void setTailSub1(Node n)
  {
    m_map[m_firstFree - 2] = n;
  }

  
  public final Node peepTail()
  {
    return m_map[m_firstFree - 1];
  }

  
  public final Node peepTailSub1()
  {
    return m_map[m_firstFree - 2];
  }

  
  public void insertElementAt(Node value, int at)
  {
    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null == m_map)
    {
      m_map = new Node[m_blocksize];
      m_mapSize = m_blocksize;
    }
    else if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      Node newMap[] = new Node[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    if (at <= (m_firstFree - 1))
    {
      System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);
    }

    m_map[at] = value;

    m_firstFree++;
  }

  
  public void appendNodes(NodeSet nodes)
  {

    int nNodes = nodes.size();

    if (null == m_map)
    {
      m_mapSize = nNodes + m_blocksize;
      m_map = new Node[m_mapSize];
    }
    else if ((m_firstFree + nNodes) >= m_mapSize)
    {
      m_mapSize += (nNodes + m_blocksize);

      Node newMap[] = new Node[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + nNodes);

      m_map = newMap;
    }

    System.arraycopy(nodes.m_map, 0, m_map, m_firstFree, nNodes);

    m_firstFree += nNodes;
  }

  
  public void removeAllElements()
  {

    if (null == m_map)
      return;

    for (int i = 0; i < m_firstFree; i++)
    {
      m_map[i] = null;
    }

    m_firstFree = 0;
  }

  
  public boolean removeElement(Node s)
  {
    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null == m_map)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      Node node = m_map[i];

      if ((null != node) && node.equals(s))
      {
        if (i > m_firstFree)
          System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
        else
          m_map[i] = null;

        m_firstFree--;

        return true;
      }
    }

    return false;
  }

  
  public void removeElementAt(int i)
  {

    if (null == m_map)
      return;

    if (i > m_firstFree)
      System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
    else
      m_map[i] = null;
  }

  
  public void setElementAt(Node node, int index)
  {
    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null == m_map)
    {
      m_map = new Node[m_blocksize];
      m_mapSize = m_blocksize;
    }

    m_map[index] = node;
  }

  
  public Node elementAt(int i)
  {

    if (null == m_map)
      return null;

    return m_map[i];
  }

  
  public boolean contains(Node s)
  {
    runTo(-1);

    if (null == m_map)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      Node node = m_map[i];

      if ((null != node) && node.equals(s))
        return true;
    }

    return false;
  }

  
  public int indexOf(Node elem, int index)
  {
    runTo(-1);

    if (null == m_map)
      return -1;

    for (int i = index; i < m_firstFree; i++)
    {
      Node node = m_map[i];

      if ((null != node) && node.equals(elem))
        return i;
    }

    return -1;
  }

  
  public int indexOf(Node elem)
  {
    runTo(-1);

    if (null == m_map)
      return -1;

    for (int i = 0; i < m_firstFree; i++)
    {
      Node node = m_map[i];

      if ((null != node) && node.equals(elem))
        return i;
    }

    return -1;
  }

}
"
org.apache.xalan.xsltc.compiler.Parser,76,1,0,97,204,2562,87,23,59,0.933777778,3281,1.0,9,0.0,0.093421053,0,0,41.77631579,13,2.25,1,"

package org.apache.xalan.xsltc.compiler;

import java.io.File;
import java.io.IOException;
import java.io.StringReader;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.Vector;

import java_cup.runtime.Symbol;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.runtime.AttributeList;
import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.XMLReader;

public class Parser implements Constants, ContentHandler {

    private static final String XSL = ""xsl"";            
    private static final String TRANSLET = ""translet""; 

    private Locator _locator = null;

    private XSLTC _xsltc;             
    private XPathParser _xpathParser; 
    private Vector _errors;           
    private Vector _warnings;         

    private Hashtable   _instructionClasses; 
    private Hashtable   _instructionAttrs;;  
    private Hashtable   _qNames;
    private Hashtable   _namespaces;
    private QName       _useAttributeSets;
    private QName       _excludeResultPrefixes;
    private QName       _extensionElementPrefixes;
    private Hashtable   _variableScope;
    private Stylesheet  _currentStylesheet;
    private SymbolTable _symbolTable; 
    private Output      _output;
    private Template    _template;    

    private boolean     _rootNamespaceDef; 

    private SyntaxTreeNode _root;

    private String _target;

    private int _currentImportPrecedence;

    public Parser(XSLTC xsltc) {
	_xsltc = xsltc;
    }

    public void init() {
	_qNames              = new Hashtable(512);
	_namespaces          = new Hashtable();
	_instructionClasses  = new Hashtable();
	_instructionAttrs    = new Hashtable();
	_variableScope       = new Hashtable();
	_template            = null;
	_errors              = new Vector();
	_warnings            = new Vector();
	_symbolTable         = new SymbolTable();
	_xpathParser         = new XPathParser(this);
	_currentStylesheet   = null;
        _output              = null;
        _root                = null;
        _rootNamespaceDef    = false;
	_currentImportPrecedence = 1;
	
	initStdClasses();
	initInstructionAttrs();
	initExtClasses();
	initSymbolTable();
	
	_useAttributeSets =
	    getQName(XSLT_URI, XSL, ""use-attribute-sets"");
	_excludeResultPrefixes =
	    getQName(XSLT_URI, XSL, ""exclude-result-prefixes"");
	_extensionElementPrefixes =
	    getQName(XSLT_URI, XSL, ""extension-element-prefixes"");
    }

    public void setOutput(Output output) {
	if (_output != null) {
	    if (_output.getImportPrecedence() <= output.getImportPrecedence()) {
		String cdata = _output.getCdata();
		output.mergeCdata(cdata);
		_output.disable();
		_output = output;
	    }
	    else {
		output.disable();
	    }
	}
	else {
	    _output = output;
	}
    }

    public Output getOutput() {
	return _output;
    }

    public Properties getOutputProperties() {
	return getTopLevelStylesheet().getOutputProperties();
    }

    public void addVariable(Variable var) {
	addVariableOrParam(var);
    }

    public void addParameter(Param param) {
	addVariableOrParam(param);
    }

    private void addVariableOrParam(VariableBase var) {
	Object existing = _variableScope.get(var.getName());
	if (existing != null) {
	    if (existing instanceof Stack) {
		Stack stack = (Stack)existing;
		stack.push(var);
	    }
	    else if (existing instanceof VariableBase) {
		Stack stack = new Stack();
		stack.push(existing);
		stack.push(var);
		_variableScope.put(var.getName(), stack);
	    }
	}
	else {
	    _variableScope.put(var.getName(), var);
	}
    }

    public void removeVariable(QName name) {
	Object existing = _variableScope.get(name);
	if (existing instanceof Stack) {
	    Stack stack = (Stack)existing;
	    if (!stack.isEmpty()) stack.pop();
	    if (!stack.isEmpty()) return;
	}
	_variableScope.remove(name);
    }

    public VariableBase lookupVariable(QName name) {
	Object existing = _variableScope.get(name);
	if (existing instanceof VariableBase) {
	    return((VariableBase)existing);
	}
	else if (existing instanceof Stack) {
	    Stack stack = (Stack)existing;
	    return((VariableBase)stack.peek());
	}
	return(null);
    }

    public void setXSLTC(XSLTC xsltc) {
	_xsltc = xsltc;
    }

    public XSLTC getXSLTC() {
	return _xsltc;
    }

    public int getCurrentImportPrecedence() {
	return _currentImportPrecedence;
    }
    
    public int getNextImportPrecedence() {
	return ++_currentImportPrecedence;
    }

    public void setCurrentStylesheet(Stylesheet stylesheet) {
	_currentStylesheet = stylesheet;
    }

    public Stylesheet getCurrentStylesheet() {
	return _currentStylesheet;
    }
    
    public Stylesheet getTopLevelStylesheet() {
	return _xsltc.getStylesheet();
    }

    public QName getQNameSafe(final String stringRep) {
	
	final int colon = stringRep.lastIndexOf(':');
	if (colon != -1) {
	    final String prefix = stringRep.substring(0, colon);
	    final String localname = stringRep.substring(colon + 1);
	    String namespace = null;
	    
	    
	    if (prefix.equals(XMLNS_PREFIX) == false) {
		namespace = _symbolTable.lookupNamespace(prefix);
		if (namespace == null) namespace = EMPTYSTRING;
	    }
	    return getQName(namespace, prefix, localname);
	}
	else {
	    final String uri = stringRep.equals(XMLNS_PREFIX) ? null
		: _symbolTable.lookupNamespace(EMPTYSTRING);
	    return getQName(uri, null, stringRep);
	}
    }
    
    public QName getQName(final String stringRep) {
	return getQName(stringRep, true, false);    
    }

    public QName getQNameIgnoreDefaultNs(final String stringRep) {
	return getQName(stringRep, true, true);
    }

    public QName getQName(final String stringRep, boolean reportError) {
	return getQName(stringRep, reportError, false);
    }

    private QName getQName(final String stringRep, boolean reportError,
	boolean ignoreDefaultNs) 
    {
	
	final int colon = stringRep.lastIndexOf(':');
	if (colon != -1) {
	    final String prefix = stringRep.substring(0, colon);
	    final String localname = stringRep.substring(colon + 1);
	    String namespace = null;
	    
	    
	    if (prefix.equals(XMLNS_PREFIX) == false) {
		namespace = _symbolTable.lookupNamespace(prefix);
		if (namespace == null && reportError) {
		    final int line = _locator.getLineNumber();
		    ErrorMsg err = new ErrorMsg(ErrorMsg.NAMESPACE_UNDEF_ERR,
						line, prefix);
		    reportError(ERROR, err);
		}
	    }
	    return getQName(namespace, prefix, localname);
	}
	else {
	    if (stringRep.equals(XMLNS_PREFIX)) {
		ignoreDefaultNs = true;
	    }
	    final String defURI = ignoreDefaultNs ? null 
				  : _symbolTable.lookupNamespace(EMPTYSTRING);
	    return getQName(defURI, null, stringRep);
	}
    }

    public QName getQName(String namespace, String prefix, String localname) {
	if (namespace == null || namespace.equals(EMPTYSTRING)) {
	    QName name = (QName)_qNames.get(localname);
	    if (name == null) {
		name = new QName(null, prefix, localname);
		_qNames.put(localname, name);
	    }
	    return name;
	}
	else {
	    Dictionary space = (Dictionary)_namespaces.get(namespace);
	    if (space == null) {
		final QName name = new QName(namespace, prefix, localname);
		_namespaces.put(namespace, space = new Hashtable());
		space.put(localname, name);
		return name;
	    }
	    else {
		QName name = (QName)space.get(localname);
		if (name == null) {
		    name = new QName(namespace, prefix, localname);
		    space.put(localname, name);
		}
		return name;
	    }
	}
    }
    
    public QName getQName(String scope, String name) {
	return getQName(scope + name);
    }

    public QName getQName(QName scope, QName name) {
	return getQName(scope.toString() + name.toString());
    }

    public QName getUseAttributeSets() {
	return _useAttributeSets;
    }

    public QName getExtensionElementPrefixes() {
	return _extensionElementPrefixes;
    }

    public QName getExcludeResultPrefixes() {
	return _excludeResultPrefixes;
    }
    
    
    public Stylesheet makeStylesheet(SyntaxTreeNode element) 
	throws CompilerException {
	try {
	    Stylesheet stylesheet;

	    if (element instanceof Stylesheet) {
		stylesheet = (Stylesheet)element;
	    }
	    else {
		stylesheet = new Stylesheet();
		stylesheet.setSimplified();
		stylesheet.addElement(element);
		stylesheet.setAttributes(element.getAttributes());

		
		if (element.lookupNamespace(EMPTYSTRING) == null) {
		    element.addPrefixMapping(EMPTYSTRING, EMPTYSTRING);
		}
	    }
	    stylesheet.setParser(this);
	    return stylesheet;
	}
	catch (ClassCastException e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.NOT_STYLESHEET_ERR, element);
	    throw new CompilerException(err.toString());
	}
    }
    
    
    public void createAST(Stylesheet stylesheet) {
	try {
	    if (stylesheet != null) {
		stylesheet.parseContents(this);
		final int precedence = stylesheet.getImportPrecedence();
		final Enumeration elements = stylesheet.elements();
		while (elements.hasMoreElements()) {
		    Object child = elements.nextElement();
		    if (child instanceof Text) {
			final int l = _locator.getLineNumber();
			ErrorMsg err =
			    new ErrorMsg(ErrorMsg.ILLEGAL_TEXT_NODE_ERR,l,null);
			reportError(ERROR, err);
		    }
		}
		if (!errorsFound()) {
		    stylesheet.typeCheck(_symbolTable);
		}
	    }
	}
	catch (TypeCheckError e) {
	    reportError(ERROR, new ErrorMsg(e));
	}
    }

    
    public SyntaxTreeNode parse(XMLReader reader, InputSource input) {
	try {
	    
	    reader.setContentHandler(this);
	    reader.parse(input);
	    
	    return (SyntaxTreeNode)getStylesheet(_root);	
	}
	catch (IOException e) {
	    if (_xsltc.debug()) e.printStackTrace();
	    reportError(ERROR,new ErrorMsg(e));
	}
	catch (SAXException e) {
	    Throwable ex = e.getException();
	    if (_xsltc.debug()) {
		e.printStackTrace();
		if (ex != null) ex.printStackTrace();
	    }
	    reportError(ERROR, new ErrorMsg(e));
	}
	catch (CompilerException e) {
	    if (_xsltc.debug()) e.printStackTrace();
	    reportError(ERROR, new ErrorMsg(e));
	}
	catch (Exception e) {
	    if (_xsltc.debug()) e.printStackTrace();
	    reportError(ERROR, new ErrorMsg(e));
	}
	return null;
    }

    
    public SyntaxTreeNode parse(InputSource input) {
	try {
	    
	    final SAXParserFactory factory = SAXParserFactory.newInstance();
	    try {
		factory.setFeature(Constants.NAMESPACE_FEATURE,true);
	    }
	    catch (Exception e) {
		factory.setNamespaceAware(true);
	    }
	    final SAXParser parser = factory.newSAXParser();
	    final XMLReader reader = parser.getXMLReader();
	    return(parse(reader, input));
	}
	catch (ParserConfigurationException e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.SAX_PARSER_CONFIG_ERR);
	    reportError(ERROR, err);
	}
	catch (SAXParseException e){
	    reportError(ERROR, new ErrorMsg(e.getMessage(),e.getLineNumber()));
	}
	catch (SAXException e) {
	    reportError(ERROR, new ErrorMsg(e.getMessage()));
	}
	return null;
    }

    public SyntaxTreeNode getDocumentRoot() {
	return _root;
    }

    private String _PImedia = null;
    private String _PItitle = null;
    private String _PIcharset = null;

    
    protected void setPIParameters(String media, String title, String charset) {
	_PImedia = media;
	_PItitle = title;
	_PIcharset = charset;
    }

    
    private SyntaxTreeNode getStylesheet(SyntaxTreeNode root)
	throws CompilerException {

	
	
	if (_target == null) {
	    if (!_rootNamespaceDef) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.MISSING_XSLT_URI_ERR);
		throw new CompilerException(msg.toString());
	    }
	    return(root);
	}

	
	if (_target.charAt(0) == '#') {
	    SyntaxTreeNode element = findStylesheet(root, _target.substring(1));
	    if (element == null) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.MISSING_XSLT_TARGET_ERR,
					    _target, root);
		throw new CompilerException(msg.toString());
	    }
	    return(element);
	}
	else {
	    return(loadExternalStylesheet(_target));
	}
    }

    
    private SyntaxTreeNode findStylesheet(SyntaxTreeNode root, String href) {

	if (root == null) return null;

	if (root instanceof Stylesheet) {
	    String id = root.getAttribute(""id"");
	    if (id.equals(href)) return root;
	}
	Vector children = root.getContents();
	if (children != null) {
	    final int count = children.size();
	    for (int i = 0; i < count; i++) {
		SyntaxTreeNode child = (SyntaxTreeNode)children.elementAt(i);
		SyntaxTreeNode node = findStylesheet(child, href);
		if (node != null) return node;
	    }
	}
	return null;	
    }

    
    private SyntaxTreeNode loadExternalStylesheet(String location)
	throws CompilerException {

	InputSource source;

	
	if ((new File(location)).exists())
	    source = new InputSource(""file:""+location);
	else
	    source = new InputSource(location);

	SyntaxTreeNode external = (SyntaxTreeNode)parse(source);
	return(external);
    }

    private void initAttrTable(String elementName, String[] attrs) {
	_instructionAttrs.put(getQName(XSLT_URI, XSL, elementName),
				attrs);
    }

    private void initInstructionAttrs() {
	initAttrTable(""template"", 
	    new String[] {""match"", ""name"", ""priority"", ""mode""});
	initAttrTable(""stylesheet"", 
	    new String[] {""id"", ""version"", ""extension-element-prefixes"",
		""exclude-result-prefixes""});
	initAttrTable(""transform"",
	    new String[] {""id"", ""version"", ""extension-element-prefixes"",
		""exclude-result-prefixes""});
	initAttrTable(""text"", new String[] {""disable-output-escaping""}); 
	initAttrTable(""if"", new String[] {""test""}); 
	initAttrTable(""choose"", new String[] {}); 
	initAttrTable(""when"", new String[] {""test""}); 
	initAttrTable(""otherwise"", new String[] {}); 
	initAttrTable(""for-each"", new String[] {""select""}); 
	initAttrTable(""message"", new String[] {""terminate""}); 
	initAttrTable(""number"", 
	    new String[] {""level"", ""count"", ""from"", ""value"", ""format"", ""lang"",
		""letter-value"", ""grouping-separator"", ""grouping-size""});
		initAttrTable(""comment"", new String[] {}); 
	initAttrTable(""copy"", new String[] {""use-attribute-sets""}); 
	initAttrTable(""copy-of"", new String[] {""select""}); 
	initAttrTable(""param"", new String[] {""name"", ""select""}); 
	initAttrTable(""with-param"", new String[] {""name"", ""select""}); 
	initAttrTable(""variable"", new String[] {""name"", ""select""}); 
	initAttrTable(""output"", 
	    new String[] {""method"", ""version"", ""encoding"", 
		""omit-xml-declaration"", ""standalone"", ""doctype-public"",
		""doctype-system"", ""cdata-section-elements"", ""indent"",
		""media-type""}); 
	initAttrTable(""sort"", 
	   new String[] {""select"", ""order"", ""case-order"", ""lang"", ""data-type""});
	initAttrTable(""key"", new String[] {""name"", ""match"", ""use""}); 
	initAttrTable(""fallback"", new String[] {}); 
	initAttrTable(""attribute"", new String[] {""name"", ""namespace""}); 
	initAttrTable(""attribute-set"", 
	    new String[] {""name"", ""use-attribute-sets""}); 
	initAttrTable(""value-of"", 
	    new String[] {""select"", ""disable-output-escaping""}); 
	initAttrTable(""element"", 
	    new String[] {""name"", ""namespace"", ""use-attribute-sets""}); 
	initAttrTable(""call-template"", new String[] {""name""}); 
	initAttrTable(""apply-templates"", new String[] {""select"", ""mode""}); 
	initAttrTable(""apply-imports"", new String[] {}); 
	initAttrTable(""decimal-format"", 
	    new String[] {""name"", ""decimal-separator"", ""grouping-separator"",
		""infinity"", ""minus-sign"", ""NaN"", ""percent"", ""per-mille"",
		""zero-digit"", ""digit"", ""pattern-separator""}); 
	initAttrTable(""import"", new String[] {""href""}); 
	initAttrTable(""include"", new String[] {""href""}); 
	initAttrTable(""strip-space"", new String[] {""elements""}); 
	initAttrTable(""preserve-space"", new String[] {""elements""}); 
	initAttrTable(""processing-instruction"", new String[] {""name""}); 
	initAttrTable(""namespace-alias"", 
	   new String[] {""stylesheet-prefix"", ""result-prefix""}); 
    }



    
    private void initStdClasses() {
	initStdClass(""template"", ""Template"");
	initStdClass(""stylesheet"", ""Stylesheet"");
	initStdClass(""transform"", ""Stylesheet"");
	initStdClass(""text"", ""Text"");
	initStdClass(""if"", ""If"");
	initStdClass(""choose"", ""Choose"");
	initStdClass(""when"", ""When"");
	initStdClass(""otherwise"", ""Otherwise"");
	initStdClass(""for-each"", ""ForEach"");
	initStdClass(""message"", ""Message"");
	initStdClass(""number"", ""Number"");
	initStdClass(""comment"", ""Comment"");
	initStdClass(""copy"", ""Copy"");
	initStdClass(""copy-of"", ""CopyOf"");
	initStdClass(""param"", ""Param"");
	initStdClass(""with-param"", ""WithParam"");
	initStdClass(""variable"", ""Variable"");
	initStdClass(""output"", ""Output"");
	initStdClass(""sort"", ""Sort"");
	initStdClass(""key"", ""Key"");
	initStdClass(""fallback"", ""Fallback"");
	initStdClass(""attribute"", ""XslAttribute"");
	initStdClass(""attribute-set"", ""AttributeSet"");
	initStdClass(""value-of"", ""ValueOf"");
	initStdClass(""element"", ""XslElement"");
	initStdClass(""call-template"", ""CallTemplate"");
	initStdClass(""apply-templates"", ""ApplyTemplates"");
	initStdClass(""apply-imports"", ""ApplyImports"");
	initStdClass(""decimal-format"", ""DecimalFormatting"");
	initStdClass(""import"", ""Import"");
	initStdClass(""include"", ""Include"");
	initStdClass(""strip-space"", ""Whitespace"");
	initStdClass(""preserve-space"", ""Whitespace"");
	initStdClass(""processing-instruction"", ""ProcessingInstruction"");
	initStdClass(""namespace-alias"", ""NamespaceAlias"");
    }
    
    private void initStdClass(String elementName, String className) {
	_instructionClasses.put(getQName(XSLT_URI, XSL, elementName),
				COMPILER_PACKAGE + '.' + className);
    }

    public boolean elementSupported(String namespace, String localName) {
	return(_instructionClasses.get(getQName(namespace, XSL, localName)) != null);
    }

    public boolean functionSupported(String fname) {
	return(_symbolTable.lookupPrimop(fname) != null);
    }

    private void initExtClasses() {
	initExtClass(""output"", ""TransletOutput"");
        initExtClass(REDIRECT_URI, ""write"", ""TransletOutput"");
    }

    private void initExtClass(String elementName, String className) {
	_instructionClasses.put(getQName(TRANSLET_URI, TRANSLET, elementName),
				COMPILER_PACKAGE + '.' + className);
    }

    private void initExtClass(String namespace, String elementName, String className) {
        _instructionClasses.put(getQName(namespace, TRANSLET, elementName),
                                COMPILER_PACKAGE + '.' + className);
    }

    
    private void initSymbolTable() {
	MethodType I_V  = new MethodType(Type.Int, Type.Void);
	MethodType I_R  = new MethodType(Type.Int, Type.Real);
	MethodType I_S  = new MethodType(Type.Int, Type.String);
	MethodType I_D  = new MethodType(Type.Int, Type.NodeSet);
	MethodType R_I  = new MethodType(Type.Real, Type.Int);
	MethodType R_V  = new MethodType(Type.Real, Type.Void);
	MethodType R_R  = new MethodType(Type.Real, Type.Real);
	MethodType R_D  = new MethodType(Type.Real, Type.NodeSet);
	MethodType R_O  = new MethodType(Type.Real, Type.Reference);
	MethodType I_I  = new MethodType(Type.Int, Type.Int);
 	MethodType D_O  = new MethodType(Type.NodeSet, Type.Reference);
	MethodType D_V  = new MethodType(Type.NodeSet, Type.Void);
	MethodType D_S  = new MethodType(Type.NodeSet, Type.String);
	MethodType D_D  = new MethodType(Type.NodeSet, Type.NodeSet);
	MethodType A_V  = new MethodType(Type.Node, Type.Void);
	MethodType S_V  = new MethodType(Type.String, Type.Void);
	MethodType S_S  = new MethodType(Type.String, Type.String);
	MethodType S_A  = new MethodType(Type.String, Type.Node);
	MethodType S_D  = new MethodType(Type.String, Type.NodeSet);
	MethodType S_O  = new MethodType(Type.String, Type.Reference);
	MethodType B_O  = new MethodType(Type.Boolean, Type.Reference);
	MethodType B_V  = new MethodType(Type.Boolean, Type.Void);
	MethodType B_B  = new MethodType(Type.Boolean, Type.Boolean);
	MethodType B_S  = new MethodType(Type.Boolean, Type.String);
	MethodType D_X  = new MethodType(Type.NodeSet, Type.Object);
	MethodType R_RR = new MethodType(Type.Real, Type.Real, Type.Real);
	MethodType I_II = new MethodType(Type.Int, Type.Int, Type.Int);
	MethodType B_RR = new MethodType(Type.Boolean, Type.Real, Type.Real);
	MethodType B_II = new MethodType(Type.Boolean, Type.Int, Type.Int);
	MethodType S_SS = new MethodType(Type.String, Type.String, Type.String);
	MethodType S_DS = new MethodType(Type.String, Type.Real, Type.String);
	MethodType S_SR = new MethodType(Type.String, Type.String, Type.Real);

	MethodType D_SS =
	    new MethodType(Type.NodeSet, Type.String, Type.String);
	MethodType D_SD = 
	    new MethodType(Type.NodeSet, Type.String, Type.NodeSet);
	MethodType B_BB =
	    new MethodType(Type.Boolean, Type.Boolean, Type.Boolean);
	MethodType B_SS =
	    new MethodType(Type.Boolean, Type.String, Type.String);
	MethodType S_SD =
	    new MethodType(Type.String, Type.String, Type.NodeSet);
	MethodType S_DSS =
	    new MethodType(Type.String, Type.Real, Type.String, Type.String);
	MethodType S_SRR =
	    new MethodType(Type.String, Type.String, Type.Real, Type.Real);
	MethodType S_SSS =
	    new MethodType(Type.String, Type.String, Type.String, Type.String);

	

	

	_symbolTable.addPrimop(""current"", A_V);
	_symbolTable.addPrimop(""last"", I_V);
	_symbolTable.addPrimop(""position"", I_V);
	_symbolTable.addPrimop(""true"", B_V);
	_symbolTable.addPrimop(""false"", B_V);
	_symbolTable.addPrimop(""not"", B_B);
	_symbolTable.addPrimop(""name"", S_V);
	_symbolTable.addPrimop(""name"", S_A);
	_symbolTable.addPrimop(""generate-id"", S_V);
	_symbolTable.addPrimop(""generate-id"", S_A);
	_symbolTable.addPrimop(""ceiling"", R_R);
	_symbolTable.addPrimop(""floor"", R_R);
	_symbolTable.addPrimop(""round"", R_R);
	_symbolTable.addPrimop(""contains"", B_SS);
	_symbolTable.addPrimop(""number"", R_O);
	_symbolTable.addPrimop(""number"", R_V);
	_symbolTable.addPrimop(""boolean"", B_O);
	_symbolTable.addPrimop(""string"", S_O);
	_symbolTable.addPrimop(""string"", S_V);
	_symbolTable.addPrimop(""translate"", S_SSS);
	_symbolTable.addPrimop(""string-length"", I_V);
	_symbolTable.addPrimop(""string-length"", I_S);
	_symbolTable.addPrimop(""starts-with"", B_SS);
	_symbolTable.addPrimop(""format-number"", S_DS);
	_symbolTable.addPrimop(""format-number"", S_DSS);
	_symbolTable.addPrimop(""unparsed-entity-uri"", S_S);
	_symbolTable.addPrimop(""key"", D_SS);
	_symbolTable.addPrimop(""key"", D_SD);
	_symbolTable.addPrimop(""id"", D_S);
	_symbolTable.addPrimop(""id"", D_D);
	_symbolTable.addPrimop(""namespace-uri"", S_V);
	_symbolTable.addPrimop(""function-available"", B_S);
	_symbolTable.addPrimop(""element-available"", B_S);
	_symbolTable.addPrimop(""document"", D_S);
	_symbolTable.addPrimop(""document"", D_V);

	
	_symbolTable.addPrimop(""count"", I_D);
	_symbolTable.addPrimop(""sum"", R_D);
	_symbolTable.addPrimop(""local-name"", S_V);
	_symbolTable.addPrimop(""local-name"", S_D);
	_symbolTable.addPrimop(""namespace-uri"", S_V);
	_symbolTable.addPrimop(""namespace-uri"", S_D);
	_symbolTable.addPrimop(""substring"", S_SR);
	_symbolTable.addPrimop(""substring"", S_SRR);
	_symbolTable.addPrimop(""substring-after"", S_SS);
	_symbolTable.addPrimop(""substring-before"", S_SS);
	_symbolTable.addPrimop(""normalize-space"", S_V);
	_symbolTable.addPrimop(""normalize-space"", S_S);
	_symbolTable.addPrimop(""system-property"", S_S);

	
        _symbolTable.addPrimop(""nodeset"", D_O);
        _symbolTable.addPrimop(""objectType"", S_O);

	
	_symbolTable.addPrimop(""+"", R_RR);	
	_symbolTable.addPrimop(""-"", R_RR);	
	_symbolTable.addPrimop(""*"", R_RR);	
	_symbolTable.addPrimop(""/"", R_RR);	
	_symbolTable.addPrimop(""%"", R_RR);	

	
	
	_symbolTable.addPrimop(""+"", I_II);	
	_symbolTable.addPrimop(""-"", I_II);	
	_symbolTable.addPrimop(""*"", I_II);	

	 
	_symbolTable.addPrimop(""<"",  B_RR);	
	_symbolTable.addPrimop(""<="", B_RR);	
	_symbolTable.addPrimop("">"",  B_RR);	
	_symbolTable.addPrimop("">="", B_RR);	

	
	_symbolTable.addPrimop(""<"",  B_II);	
	_symbolTable.addPrimop(""<="", B_II);	
	_symbolTable.addPrimop("">"",  B_II);	
	_symbolTable.addPrimop("">="", B_II);	

	
	_symbolTable.addPrimop(""<"",  B_BB);	
	_symbolTable.addPrimop(""<="", B_BB);	
	_symbolTable.addPrimop("">"",  B_BB);	
	_symbolTable.addPrimop("">="", B_BB);	

	
	_symbolTable.addPrimop(""or"", B_BB);	
	_symbolTable.addPrimop(""and"", B_BB);	

	
	_symbolTable.addPrimop(""u-"", R_R);	
	_symbolTable.addPrimop(""u-"", I_I);	
    }

    public SymbolTable getSymbolTable() {
	return _symbolTable;
    }

    public Template getTemplate() {
	return _template;
    }

    public void setTemplate(Template template) {
	_template = template;
    }

    private int _templateIndex = 0;

    public int getTemplateIndex() {
	return(_templateIndex++);
    }

    

    private boolean versionIsOne = true;

    public SyntaxTreeNode makeInstance(String uri, String prefix, 
	String local, Attributes attributes)
    {
	SyntaxTreeNode node = null;
	QName  qname = getQName(uri, prefix, local);
	String className = (String)_instructionClasses.get(qname);

	if (className != null) {
	    try {
		final Class clazz = Class.forName(className);
		node = (SyntaxTreeNode)clazz.newInstance();
		node.setQName(qname);
		node.setParser(this);
		if (_locator != null) {
		    node.setLineNumber(_locator.getLineNumber());
		}
		if (node instanceof Stylesheet) {
		    _xsltc.setStylesheet((Stylesheet)node);
		}
		checkForSuperfluousAttributes(node, attributes);
	    }
	    catch (ClassNotFoundException e) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, node);
		reportError(ERROR, err);
	    }
	    catch (Exception e) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.INTERNAL_ERR,
					    e.getMessage(), node);
		reportError(FATAL, err);
	    }
	}
	else {
	    if (uri != null) {
		
		if (uri.equals(XSLT_URI)) {
		    node = new UnsupportedElement(uri, prefix, local);
		    UnsupportedElement element = (UnsupportedElement)node;
		    ErrorMsg msg = new ErrorMsg(ErrorMsg.UNSUPPORTED_XSL_ERR,
						_locator.getLineNumber(),local);
		    element.setErrorMessage(msg);
		}
		
		else if (uri.equals(TRANSLET_URI)) {
		    node = new UnsupportedElement(uri, prefix, local);
		    UnsupportedElement element = (UnsupportedElement)node;
		    ErrorMsg msg = new ErrorMsg(ErrorMsg.UNSUPPORTED_EXT_ERR,
						_locator.getLineNumber(),local);
		    element.setErrorMessage(msg);
		}
		
		else {
		    Stylesheet sheet = _xsltc.getStylesheet();
		    if ((sheet != null) && (sheet.isExtension(uri))) {
			if (sheet != (SyntaxTreeNode)_parentStack.peek()) {
			    node = new UnsupportedElement(uri, prefix, local);
			    UnsupportedElement elem = (UnsupportedElement)node;
			    ErrorMsg msg =
				new ErrorMsg(ErrorMsg.UNSUPPORTED_EXT_ERR,
					     _locator.getLineNumber(),
					     prefix+"":""+local);
			    elem.setErrorMessage(msg);
			}
		    }
		}
	    }
	    if (node == null) node = new LiteralElement();
	}
	if ((node != null) && (node instanceof LiteralElement)) {
	    ((LiteralElement)node).setQName(qname);
	}
	return(node);
    }

    
    private void checkForSuperfluousAttributes(SyntaxTreeNode node, 
	Attributes attrs)
    {
	QName qname = node.getQName();
	boolean isStylesheet = (node instanceof Stylesheet); 
        String[] legal = (String[]) _instructionAttrs.get(qname);
	if (versionIsOne && legal != null) {
	    int j;
	    final int n = attrs.getLength();

	    for (int i = 0; i < n; i++) {
	        final String attrQName = attrs.getQName(i);

	        if (isStylesheet && attrQName.equals(""version"")) {
	            versionIsOne = attrs.getValue(i).equals(""1.0"");
	        }

		
	        if (attrQName.startsWith(""xml"") ||
		    attrQName.indexOf(':') > 0) continue;

	        for (j = 0; j < legal.length; j++) {
	            if (attrQName.equalsIgnoreCase(legal[j])) {
		        break;
		    }	
	        }
	        if (j == legal.length) {
	            final ErrorMsg err = 
		        new ErrorMsg(ErrorMsg.ILLEGAL_ATTRIBUTE_ERR, 
				attrQName, node);
		    reportError(WARNING, err);
	        }
	    }
        }	
    }


    
    public Expression parseExpression(SyntaxTreeNode parent, String exp) {
	return (Expression)parseTopLevel(parent, ""<EXPRESSION>""+exp, null);
    }

    
    public Expression parseExpression(SyntaxTreeNode parent,
				      String attr, String def) {
	
        String exp = parent.getAttribute(attr);
	
        if ((exp.length() == 0) && (def != null)) exp = def;
	
        return (Expression)parseTopLevel(parent, ""<EXPRESSION>""+exp, exp);
    }

    
    public Pattern parsePattern(SyntaxTreeNode parent, String pattern) {
	return (Pattern)parseTopLevel(parent, ""<PATTERN>""+pattern, pattern);
    }

    
    public Pattern parsePattern(SyntaxTreeNode parent,
				String attr, String def) {
	
        String pattern = parent.getAttribute(attr);
	
	if ((pattern.length() == 0) && (def != null)) pattern = def;
	
        return (Pattern)parseTopLevel(parent, ""<PATTERN>""+pattern, pattern);
    }

    
    private SyntaxTreeNode parseTopLevel(SyntaxTreeNode parent, String text,
					 String expression) {
	int line = 0;
	if (_locator != null) line = _locator.getLineNumber();

	try {
	    _xpathParser.setScanner(new XPathLexer(new StringReader(text)));
	    Symbol result = _xpathParser.parse(expression, line);
	    if (result != null) {
		final SyntaxTreeNode node = (SyntaxTreeNode)result.value;
		if (node != null) {
		    node.setParser(this);
		    node.setParent(parent);
		    node.setLineNumber(line);

		    return node;
		}
	    } 
	    reportError(ERROR, new ErrorMsg(ErrorMsg.XPATH_PARSER_ERR,
					    expression, parent));
	}
	catch (Exception e) {
	    if (_xsltc.debug()) e.printStackTrace();
	    reportError(ERROR, new ErrorMsg(ErrorMsg.XPATH_PARSER_ERR,
					    expression, parent));
	}

	
	SyntaxTreeNode.Dummy.setParser(this);
        return SyntaxTreeNode.Dummy; 
    }

    

    
    public boolean errorsFound() {
	return _errors.size() > 0;
    }

    
    public void printErrors() {
	final int size = _errors.size();
	if (size > 0) {
	    System.err.println(new ErrorMsg(ErrorMsg.COMPILER_ERROR_KEY));
	    for (int i = 0; i < size; i++) {
		System.err.println(""  "" + _errors.elementAt(i));
	    }
	}
    }

    
    public void printWarnings() {
	final int size = _warnings.size();
	if (size > 0) {
	    System.err.println(new ErrorMsg(ErrorMsg.COMPILER_WARNING_KEY));
	    for (int i = 0; i < size; i++) {
		System.err.println(""  "" + _warnings.elementAt(i));
	    }
	}
    }

    
    public void reportError(final int category, final ErrorMsg error) {
	switch (category) {
	case Constants.INTERNAL:
	    
	    
	    _errors.addElement(error);
	    break;
	case Constants.UNSUPPORTED:
	    
	    
	    _errors.addElement(error);
	    break;
	case Constants.FATAL:
	    
	    
	    _errors.addElement(error);
	    break;
	case Constants.ERROR:
	    
	    
	    _errors.addElement(error);
	    break;
	case Constants.WARNING:
	    
	    
	    _warnings.addElement(error);
	    break;
	}
    }

    public Vector getErrors() {
	return _errors;
    }

    public Vector getWarnings() {
	return _warnings;
    }

    

    private Stack _parentStack = null;
    private Hashtable _prefixMapping = null;

    
    public void startDocument() {
	_root = null;
	_target = null;
	_prefixMapping = null;
	_parentStack = new Stack();
    }

    
    public void endDocument() { }


    
    public void startPrefixMapping(String prefix, String uri) {
	if (_prefixMapping == null) {
	    _prefixMapping = new Hashtable();
	}
	_prefixMapping.put(prefix, uri);
    }

    
    public void endPrefixMapping(String prefix) { }

    
    public void startElement(String uri, String localname,
			     String qname, Attributes attributes) 
	throws SAXException {
	final int col = qname.lastIndexOf(':');
	final String prefix = (col == -1) ? null : qname.substring(0, col);

	SyntaxTreeNode element = makeInstance(uri, prefix, 
					localname, attributes);
	if (element == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ELEMENT_PARSE_ERR,
					prefix+':'+localname);
	    throw new SAXException(err.toString());
	}

	
	
	if (_root == null) {
	    if ((_prefixMapping == null) ||
		(_prefixMapping.containsValue(Constants.XSLT_URI) == false))
		_rootNamespaceDef = false;
	    else
		_rootNamespaceDef = true;
	    _root = element;
	}
	else {
	    SyntaxTreeNode parent = (SyntaxTreeNode)_parentStack.peek();
	    parent.addElement(element);
	    element.setParent(parent);
	}
	element.setAttributes((Attributes)new AttributeList(attributes));
	element.setPrefixMapping(_prefixMapping);
	
	if (element instanceof Stylesheet) {
	    
	    
	    
	    getSymbolTable().setCurrentNode(element);
	    ((Stylesheet)element).excludeExtensionPrefixes(this);
	}

	_prefixMapping = null;
	_parentStack.push(element);
    }

    
    public void endElement(String uri, String localname, String qname) {
	_parentStack.pop();
    }

    
    public void characters(char[] ch, int start, int length) {
	String string = new String(ch, start, length);
	SyntaxTreeNode parent = (SyntaxTreeNode)_parentStack.peek();

	if (string.length() == 0) return;

	
	
	if (parent instanceof Text) {
	    ((Text)parent).setText(string);
	    return;
	}

	
	if (parent instanceof Stylesheet) return;

	SyntaxTreeNode bro = parent.lastChild();
	if ((bro != null) && (bro instanceof Text)) {
	    Text text = (Text)bro;
	    if (!text.isTextElement()) {
		if ((length > 1) || ( ((int)ch[0]) < 0x100)) {
		    text.setText(string);
		    return;
		}
	    }
	}

	
	parent.addElement(new Text(string));
    }

    private String getTokenValue(String token) {
	final int start = token.indexOf('""');
	final int stop = token.lastIndexOf('""');
	return token.substring(start+1, stop);
    }

    
    public void processingInstruction(String name, String value) {
	
	if ((_target == null) && (name.equals(""xml-stylesheet""))) {

	    String href = null;    
	    String media = null;   
	    String title = null;   
	    String charset = null; 

	    
	    StringTokenizer tokens = new StringTokenizer(value);
	    while (tokens.hasMoreElements()) {
		String token = (String)tokens.nextElement();
		if (token.startsWith(""href""))
		    href = getTokenValue(token);
		else if (token.startsWith(""media""))
		    media = getTokenValue(token);
		else if (token.startsWith(""title""))
		    title = getTokenValue(token);
		else if (token.startsWith(""charset""))
		    charset = getTokenValue(token);
	    }

	    
	    
	    if ( ((_PImedia == null) || (_PImedia.equals(media))) &&
		 ((_PItitle == null) || (_PImedia.equals(title))) &&
		 ((_PIcharset == null) || (_PImedia.equals(charset))) ) {
		_target = href;
	    }
	}
    }

    
    public void ignorableWhitespace(char[] ch, int start, int length) { }

    
    public void skippedEntity(String name) { }

    
    public void setDocumentLocator(Locator locator) {
	_locator = locator;
    }

}
"
org.apache.xalan.xsltc.compiler.Mode,31,1,0,41,146,327,4,39,12,0.853968254,3077,1.0,7,0.0,0.163306452,0,0,97.58064516,41,5.6452,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.Vector;

import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.DUP;
import org.apache.bcel.generic.GOTO_W;
import org.apache.bcel.generic.IFLT;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.bcel.generic.SWITCH;
import org.apache.bcel.generic.TargetLostException;
import org.apache.bcel.util.InstructionFinder;
import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NamedMethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xml.dtm.DTM;


final class Mode implements Constants {

    
    private final QName _name;

    
    private final Stylesheet _stylesheet; 

    
    private final String _methodName;

    
    private Vector _templates; 

    
    private Vector _childNodeGroup = null;

    
    private TestSeq _childNodeTestSeq = null;

    
    private Vector _attribNodeGroup = null;

    
    private TestSeq _attribNodeTestSeq = null;
    
    
    private Vector _idxGroup = null;

    
    private TestSeq _idxTestSeq = null;

    
    private Vector[] _patternGroups;

    
    private TestSeq[] _testSeq;

    
    private Hashtable _preCompiled = new Hashtable();

    
    private Hashtable _neededTemplates = new Hashtable();

    
    private Hashtable _namedTemplates = new Hashtable();

    
    private Hashtable _templateIHs = new Hashtable();

    
    private Hashtable _templateILs = new Hashtable();

    
    private LocationPathPattern _rootPattern = null;

    
    private Hashtable _importLevels = null;

    
    private Hashtable _keys = null;

    
    private int _currentIndex;

    
    public Mode(QName name, Stylesheet stylesheet, String suffix) {
	_name = name;
	_stylesheet = stylesheet;
	_methodName = APPLY_TEMPLATES + suffix;
	_templates = new Vector();
	_patternGroups = new Vector[32];
    }

    
    public String functionName() {
	return _methodName;
    }

    public String functionName(int min, int max) {
	if (_importLevels == null) {
	    _importLevels = new Hashtable();
	}
	_importLevels.put(new Integer(max), new Integer(min));
	return _methodName + '_' + max;
    }

    
    public void addInstructionList(Pattern pattern, 
	InstructionList ilist) 
    {
	_preCompiled.put(pattern, ilist);
    }

    
    public InstructionList getInstructionList(Pattern pattern) {
	return (InstructionList) _preCompiled.get(pattern);
    }

    
    private String getClassName() {
	return _stylesheet.getClassName();
    }

    public Stylesheet getStylesheet() {
	return _stylesheet;
    }

    public void addTemplate(Template template) {
	_templates.addElement(template);
    }

    private Vector quicksort(Vector templates, int p, int r) {
	if (p < r) {
	    final int q = partition(templates, p, r);
	    quicksort(templates, p, q);
	    quicksort(templates, q + 1, r);
	}
	return templates;
    }
    
    private int partition(Vector templates, int p, int r) {
	final Template x = (Template)templates.elementAt(p);
	int i = p - 1;
	int j = r + 1;
	while (true) {
	    while (x.compareTo((Template)templates.elementAt(--j)) > 0);
	    while (x.compareTo((Template)templates.elementAt(++i)) < 0);
	    if (i < j) {
		templates.set(j, templates.set(i, templates.elementAt(j)));
	    }
	    else {
		return j;
	    }
	}
    }

    
    public void processPatterns(Hashtable keys) {
	_keys = keys;



	_templates = quicksort(_templates, 0, _templates.size() - 1);



	
	final Enumeration templates = _templates.elements();
	while (templates.hasMoreElements()) {
	    
	    final Template template = (Template)templates.nextElement();

	    
	    if (template.isNamed() && !template.disabled()) {
		_namedTemplates.put(template, this);
	    }

	    
	    final Pattern pattern = template.getPattern();
	    if (pattern != null) {
		flattenAlternative(pattern, template, keys);
	    }
	}
	prepareTestSequences();
    }

    
    private void flattenAlternative(Pattern pattern,
				    Template template,
				    Hashtable keys) {
	
	
	
	if (pattern instanceof IdKeyPattern) {
	    final IdKeyPattern idkey = (IdKeyPattern)pattern;
	    idkey.setTemplate(template);
	    if (_idxGroup == null) _idxGroup = new Vector();
	    _idxGroup.add(pattern);
	}
	
	else if (pattern instanceof AlternativePattern) {
	    final AlternativePattern alt = (AlternativePattern)pattern;
	    flattenAlternative(alt.getLeft(), template, keys);
	    flattenAlternative(alt.getRight(), template, keys);
	}
	
	else if (pattern instanceof LocationPathPattern) {
	    final LocationPathPattern lpp = (LocationPathPattern)pattern;
	    lpp.setTemplate(template);
	    addPatternToGroup(lpp);
	}
    }

    
    private void addPatternToGroup(final LocationPathPattern lpp) {
	
	if (lpp instanceof IdKeyPattern) {
	    addPattern(-1, lpp);
	}
	
	else {
	    
	    final StepPattern kernel = lpp.getKernelPattern();
	    if (kernel != null) {
		addPattern(kernel.getNodeType(), lpp);
	    }
	    else if (_rootPattern == null ||
		     lpp.noSmallerThan(_rootPattern)) {
		_rootPattern = lpp;
	    }
	}
    }

    
    private void addPattern(int kernelType, LocationPathPattern pattern) {
	
	final int oldLength = _patternGroups.length;
	if (kernelType >= oldLength) {
	    Vector[] newGroups = new Vector[kernelType * 2];
	    System.arraycopy(_patternGroups, 0, newGroups, 0, oldLength);
	    _patternGroups = newGroups;
	}
	
	
	Vector patterns;

	if (kernelType == DOM.NO_TYPE) {
	    if (pattern.getAxis() == Axis.ATTRIBUTE) {
		patterns = (_attribNodeGroup == null) ?
		    (_attribNodeGroup = new Vector(2)) : _attribNodeGroup;
	    }
	    else {
		patterns = (_childNodeGroup == null) ?
		    (_childNodeGroup = new Vector(2)) : _childNodeGroup;
	    }
	}
	else {
	    patterns = (_patternGroups[kernelType] == null) ?
		(_patternGroups[kernelType] = new Vector(2)) : 
		_patternGroups[kernelType];
	}

	if (patterns.size() == 0) {
	    patterns.addElement(pattern);
	}
	else {
	    boolean inserted = false;
	    for (int i = 0; i < patterns.size(); i++) {
		final LocationPathPattern lppToCompare =
		    (LocationPathPattern)patterns.elementAt(i);

		if (pattern.noSmallerThan(lppToCompare)) {
		    inserted = true;
		    patterns.insertElementAt(pattern, i);
		    break;
		}
	    }
	    if (inserted == false) {
		patterns.addElement(pattern);
	    }
	}
    }
    
    
    private void completeTestSequences(int nodeType, Vector patterns) {
	if (patterns != null) {
	    if (_patternGroups[nodeType] == null) {
		_patternGroups[nodeType] = patterns;
	    }
	    else {
		final int m = patterns.size();
		for (int j = 0; j < m; j++) {
		    addPattern(nodeType, 
			(LocationPathPattern) patterns.elementAt(j));
		}
	    }
	}
    }

    
    private void prepareTestSequences() {
	final Vector starGroup = _patternGroups[DTM.ELEMENT_NODE];
	final Vector atStarGroup = _patternGroups[DTM.ATTRIBUTE_NODE];

	
	completeTestSequences(DTM.TEXT_NODE, _childNodeGroup);
	
	
	completeTestSequences(DTM.ELEMENT_NODE, _childNodeGroup);
	
	
	completeTestSequences(DTM.PROCESSING_INSTRUCTION_NODE, _childNodeGroup);
	
	
	completeTestSequences(DTM.COMMENT_NODE, _childNodeGroup);
	
	
	completeTestSequences(DTM.ATTRIBUTE_NODE, _attribNodeGroup);

	final Vector names = _stylesheet.getXSLTC().getNamesIndex();
	if (starGroup != null || atStarGroup != null || 
	    _childNodeGroup != null || _attribNodeGroup != null) 
	{
	    final int n = _patternGroups.length;

	    
	    for (int i = DTM.NTYPES; i < n; i++) {
		if (_patternGroups[i] == null) continue;

		final String name = (String) names.elementAt(i - DTM.NTYPES);

		if (isAttributeName(name)) {
		    
		    completeTestSequences(i, atStarGroup);

		    
		    completeTestSequences(i, _attribNodeGroup);
		}
		else {
		    
		    completeTestSequences(i, starGroup);

		    
		    completeTestSequences(i, _childNodeGroup);
		}
	    }
	}

	_testSeq = new TestSeq[DTM.NTYPES + names.size()];
	
	final int n = _patternGroups.length;
	for (int i = 0; i < n; i++) {
	    final Vector patterns = _patternGroups[i];
	    if (patterns != null) {
		final TestSeq testSeq = new TestSeq(patterns, i, this);

		testSeq.reduce();
		_testSeq[i] = testSeq;
		testSeq.findTemplates(_neededTemplates);
	    }
	}

	if (_childNodeGroup != null && _childNodeGroup.size() > 0) {
	    _childNodeTestSeq = new TestSeq(_childNodeGroup, -1, this);
	    _childNodeTestSeq.reduce();
	    _childNodeTestSeq.findTemplates(_neededTemplates);
	}



	if (_idxGroup != null && _idxGroup.size() > 0) {
	    _idxTestSeq = new TestSeq(_idxGroup, this);
	    _idxTestSeq.reduce();
	    _idxTestSeq.findTemplates(_neededTemplates);
	}
	
	if (_rootPattern != null) {
	    
	    _neededTemplates.put(_rootPattern.getTemplate(), this);
	}
    }

    private void compileNamedTemplate(Template template,
				      ClassGenerator classGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();
	String methodName = Util.escape(template.getName().toString());

	final NamedMethodGenerator methodGen =
	    new NamedMethodGenerator(ACC_PUBLIC,
				     org.apache.bcel.generic.Type.VOID,
				     new org.apache.bcel.generic.Type[] {
					 Util.getJCRefType(DOM_INTF_SIG),
					 Util.getJCRefType(NODE_ITERATOR_SIG),
					 Util.getJCRefType(TRANSLET_OUTPUT_SIG),
					 org.apache.bcel.generic.Type.INT
				     },
				     new String[] {
					 DOCUMENT_PNAME,
					 ITERATOR_PNAME,
					 TRANSLET_OUTPUT_PNAME,
					 NODE_PNAME
				     },
				     methodName,
				     getClassName(),
				     il, cpg);
	
	il.append(template.compile(classGen, methodGen));
	il.append(RETURN);
	
	methodGen.stripAttributes(true);
	methodGen.setMaxLocals();
	methodGen.setMaxStack();
	methodGen.removeNOPs();
	classGen.addMethod(methodGen.getMethod());
    }

    private void compileTemplates(ClassGenerator classGen,
				  MethodGenerator methodGen,
				  InstructionHandle next) 
    {
        Enumeration templates = _namedTemplates.keys();
        while (templates.hasMoreElements()) {
            final Template template = (Template)templates.nextElement();
            compileNamedTemplate(template, classGen);
        }

	templates = _neededTemplates.keys();
	while (templates.hasMoreElements()) {
	    final Template template = (Template)templates.nextElement();
	    if (template.hasContents()) {
		
		InstructionList til = template.compile(classGen, methodGen);
		til.append(new GOTO_W(next));
		_templateILs.put(template, til);
		_templateIHs.put(template, til.getStart());
	    }
	    else {
		
		_templateIHs.put(template, next);
	    }
	}
    }
	
    private void appendTemplateCode(InstructionList body) {
	final Enumeration templates = _neededTemplates.keys();
	while (templates.hasMoreElements()) {
	    final Object iList =
		_templateILs.get(templates.nextElement());
	    if (iList != null) {
		body.append((InstructionList)iList);
	    }
	}
    }

    private void appendTestSequences(InstructionList body) {
	final int n = _testSeq.length;
	for (int i = 0; i < n; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    if (testSeq != null) {
		InstructionList il = testSeq.getInstructionList();
		if (il != null)
		    body.append(il);
		
	    }
	}
    }

    public static void compileGetChildren(ClassGenerator classGen,
					  MethodGenerator methodGen,
					  int node) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int git = cpg.addInterfaceMethodref(DOM_INTF,
						  GET_CHILDREN,
						  GET_CHILDREN_SIG);
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(node));
	il.append(new INVOKEINTERFACE(git, 2));
    }

    
    private InstructionList compileDefaultRecursion(ClassGenerator classGen,
						    MethodGenerator methodGen,
						    InstructionHandle next) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();
	final String applyTemplatesSig = classGen.getApplyTemplatesSig();
	final int git = cpg.addInterfaceMethodref(DOM_INTF,
						  GET_CHILDREN,
						  GET_CHILDREN_SIG);
	final int applyTemplates = cpg.addMethodref(getClassName(),
						    functionName(),
						    applyTemplatesSig);
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(_currentIndex));
	il.append(new INVOKEINTERFACE(git, 2));
	il.append(methodGen.loadHandler());
	il.append(new INVOKEVIRTUAL(applyTemplates));
	il.append(new GOTO_W(next));
	return il;
    }

    
    private InstructionList compileDefaultText(ClassGenerator classGen,
					       MethodGenerator methodGen,
					       InstructionHandle next) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();

	final int chars = cpg.addInterfaceMethodref(DOM_INTF,
						    CHARACTERS,
						    CHARACTERS_SIG);
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(_currentIndex));
	il.append(methodGen.loadHandler());
	il.append(new INVOKEINTERFACE(chars, 3));
	il.append(new GOTO_W(next));
	return il;
    }

    private InstructionList compileNamespaces(ClassGenerator classGen,
					      MethodGenerator methodGen,
					      boolean[] isNamespace,
					      boolean[] isAttribute,
					      boolean attrFlag,
					      InstructionHandle defaultTarget) {
	final XSLTC xsltc = classGen.getParser().getXSLTC();
	final ConstantPoolGen cpg = classGen.getConstantPool();

	
	final Vector namespaces = xsltc.getNamespaceIndex();
	final Vector names = xsltc.getNamesIndex();
	final int namespaceCount = namespaces.size() + 1;
	final int namesCount = names.size();

	final InstructionList il = new InstructionList();
	final int[] types = new int[namespaceCount];
	final InstructionHandle[] targets = new InstructionHandle[types.length];

	if (namespaceCount > 0) {
	    boolean compiled = false;

	    
	    for (int i = 0; i < namespaceCount; i++) {
		targets[i] = defaultTarget;
		types[i] = i;
	    }

	    
	    for (int i = DTM.NTYPES; i < (DTM.NTYPES+namesCount); i++) {
		if ((isNamespace[i]) && (isAttribute[i] == attrFlag)) {
		    String name = (String)names.elementAt(i-DTM.NTYPES);
		    String namespace = name.substring(0,name.lastIndexOf(':'));
		    final int type = xsltc.registerNamespace(namespace);
		    
		    if ((i < _testSeq.length) &&
			(_testSeq[i] != null)) {
			targets[type] =
			    (_testSeq[i]).compile(classGen,
						       methodGen,
						       defaultTarget);
			compiled = true;
		    }
		}
	    }

	    
	    if (!compiled) return(null);
		
	    
	    final int getNS = cpg.addInterfaceMethodref(DOM_INTF,
							""getNamespaceType"",
							""(I)I"");
	    il.append(methodGen.loadDOM());
	    il.append(new ILOAD(_currentIndex));
	    il.append(new INVOKEINTERFACE(getNS, 2));
	    il.append(new SWITCH(types, targets, defaultTarget));
	    return(il);
	}
	else {
	    return(null);
	}
    }

   
    public void compileApplyTemplates(ClassGenerator classGen) {
	final XSLTC xsltc = classGen.getParser().getXSLTC();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final Vector names = xsltc.getNamesIndex();

	
	final org.apache.bcel.generic.Type[] argTypes =
	    new org.apache.bcel.generic.Type[3];
	argTypes[0] = Util.getJCRefType(DOM_INTF_SIG);
	argTypes[1] = Util.getJCRefType(NODE_ITERATOR_SIG);
	argTypes[2] = Util.getJCRefType(TRANSLET_OUTPUT_SIG);
	
	final String[] argNames = new String[3];
	argNames[0] = DOCUMENT_PNAME;
	argNames[1] = ITERATOR_PNAME;
	argNames[2] = TRANSLET_OUTPUT_PNAME;

	final InstructionList mainIL = new InstructionList();
	final MethodGenerator methodGen =
	    new MethodGenerator(ACC_PUBLIC | ACC_FINAL, 
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames, functionName(),
				getClassName(), mainIL,
				classGen.getConstantPool());
	methodGen.addException(""org.apache.xalan.xsltc.TransletException"");

	
	final LocalVariableGen current;
	current = methodGen.addLocalVariable2(""current"",
					      org.apache.bcel.generic.Type.INT,
					      mainIL.getEnd());
	_currentIndex = current.getIndex();

	
	
	final InstructionList body = new InstructionList();
	body.append(NOP);

	
	
	final InstructionList ilLoop = new InstructionList();
	ilLoop.append(methodGen.loadIterator());
	ilLoop.append(methodGen.nextNode());
	ilLoop.append(DUP);
	ilLoop.append(new ISTORE(_currentIndex));

	
	
        final BranchHandle ifeq = ilLoop.append(new IFLT(null));
	final BranchHandle loop = ilLoop.append(new GOTO_W(null));
	ifeq.setTarget(ilLoop.append(RETURN)); 	
	final InstructionHandle ihLoop = ilLoop.getStart();

	
	InstructionList ilRecurse =
	    compileDefaultRecursion(classGen, methodGen, ihLoop);
	InstructionHandle ihRecurse = ilRecurse.getStart();

	
	InstructionList ilText =
	    compileDefaultText(classGen, methodGen, ihLoop);
	InstructionHandle ihText = ilText.getStart();

	
	final int[] types = new int[DTM.NTYPES + names.size()];
	for (int i = 0; i < types.length; i++) {
	    types[i] = i;
	}

	
	final boolean[] isAttribute = new boolean[types.length];
	final boolean[] isNamespace = new boolean[types.length];
	for (int i = 0; i < names.size(); i++) {
	    final String name = (String)names.elementAt(i);
	    isAttribute[i + DTM.NTYPES] = isAttributeName(name);
	    isNamespace[i + DTM.NTYPES] = isNamespaceName(name);
	}

	
	compileTemplates(classGen, methodGen, ihLoop);

	
	final TestSeq elemTest = _testSeq[DTM.ELEMENT_NODE];
	InstructionHandle ihElem = ihRecurse;
	if (elemTest != null)
	    ihElem = elemTest.compile(classGen, methodGen, ihRecurse);

	
	final TestSeq attrTest = _testSeq[DTM.ATTRIBUTE_NODE];
	InstructionHandle ihAttr = ihText;
	if (attrTest != null)
	    ihAttr = attrTest.compile(classGen, methodGen, ihAttr);

	
	InstructionList ilKey = null;
	if (_idxTestSeq != null) {
	    loop.setTarget(_idxTestSeq.compile(classGen, methodGen, body.getStart()));
	    ilKey = _idxTestSeq.getInstructionList();
	}
	else {
	    loop.setTarget(body.getStart());
	}

	
	
	if (_childNodeTestSeq != null) {
	    
	    double nodePrio = _childNodeTestSeq.getPriority();
	    int    nodePos  = _childNodeTestSeq.getPosition();
	    double elemPrio = (0 - Double.MAX_VALUE);
	    int    elemPos  = Integer.MIN_VALUE;

	    if (elemTest != null) {
		elemPrio = elemTest.getPriority();
		elemPos  = elemTest.getPosition();
	    }
	    if (elemPrio == Double.NaN || elemPrio < nodePrio || 
		(elemPrio == nodePrio && elemPos < nodePos)) 
	    {
		ihElem = _childNodeTestSeq.compile(classGen, methodGen, ihLoop);
	    }

	    
	    final TestSeq textTest = _testSeq[DTM.TEXT_NODE];
	    double textPrio = (0 - Double.MAX_VALUE);
	    int    textPos  = Integer.MIN_VALUE;

	    if (textTest != null) {
		textPrio = textTest.getPriority();
		textPos  = textTest.getPosition();
	    }
	    if (textPrio == Double.NaN || textPrio < nodePrio ||
	        (textPrio == nodePrio && textPos < nodePos)) 
	    {
		ihText = _childNodeTestSeq.compile(classGen, methodGen, ihLoop);
		_testSeq[DTM.TEXT_NODE] = _childNodeTestSeq;
	    }
	}

	
	InstructionHandle elemNamespaceHandle = ihElem;
	InstructionList nsElem = compileNamespaces(classGen, methodGen,
						   isNamespace, isAttribute,
						   false, ihElem);
	if (nsElem != null) elemNamespaceHandle = nsElem.getStart();

	
	InstructionHandle attrNamespaceHandle = ihAttr;
	InstructionList nsAttr = compileNamespaces(classGen, methodGen,
						   isNamespace, isAttribute,
						   true, ihAttr);
	if (nsAttr != null) attrNamespaceHandle = nsAttr.getStart();

	
	final InstructionHandle[] targets = new InstructionHandle[types.length];
	for (int i = DTM.NTYPES; i < targets.length; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    
	    if (isNamespace[i]) {
		if (isAttribute[i])
		    targets[i] = attrNamespaceHandle;
		else
		    targets[i] = elemNamespaceHandle;
	    }
	    
	    else if (testSeq != null) {
		if (isAttribute[i])
		    targets[i] = testSeq.compile(classGen, methodGen,
						 attrNamespaceHandle);
		else
		    targets[i] = testSeq.compile(classGen, methodGen,
						 elemNamespaceHandle);
	    }
	    else {
		targets[i] = ihLoop;
	    }
	}


	
	targets[DTM.ROOT_NODE] = _rootPattern != null
	    ? getTemplateInstructionHandle(_rootPattern.getTemplate())
	    : ihRecurse;

        
	targets[DTM.DOCUMENT_NODE] = _rootPattern != null
	    ? getTemplateInstructionHandle(_rootPattern.getTemplate())
	    : ihRecurse;

	
	targets[DTM.TEXT_NODE] = _testSeq[DTM.TEXT_NODE] != null
	    ? _testSeq[DTM.TEXT_NODE].compile(classGen, methodGen, ihText)
	    : ihText;

	
	targets[DTM.NAMESPACE_NODE] = ihLoop;

	
	targets[DTM.ELEMENT_NODE] = elemNamespaceHandle;

	
	targets[DTM.ATTRIBUTE_NODE] = attrNamespaceHandle;

	
	InstructionHandle ihPI = ihLoop;
	if (_childNodeTestSeq != null) ihPI = ihElem;
	if (_testSeq[DTM.PROCESSING_INSTRUCTION_NODE] != null)
	    targets[DTM.PROCESSING_INSTRUCTION_NODE] =
		_testSeq[DTM.PROCESSING_INSTRUCTION_NODE].
		compile(classGen, methodGen, ihPI);
	else
	    targets[DTM.PROCESSING_INSTRUCTION_NODE] = ihPI;
	
	
	InstructionHandle ihComment = ihLoop;
	if (_childNodeTestSeq != null) ihComment = ihElem;
	targets[DTM.COMMENT_NODE] = _testSeq[DTM.COMMENT_NODE] != null
	    ? _testSeq[DTM.COMMENT_NODE].compile(classGen, methodGen, ihComment)
	    : ihComment;
	    
	    
	targets[DTM.CDATA_SECTION_NODE] = ihLoop;

	
	targets[DTM.DOCUMENT_FRAGMENT_NODE] = ihLoop;
	
	
	targets[DTM.DOCUMENT_TYPE_NODE] = ihLoop;

	
	targets[DTM.ENTITY_NODE] = ihLoop;

	
	targets[DTM.ENTITY_REFERENCE_NODE] = ihLoop;
	
	
	targets[DTM.NOTATION_NODE] = ihLoop;


	
	for (int i = DTM.NTYPES; i < targets.length; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    
	    if ((testSeq == null) || (isNamespace[i])) {
		if (isAttribute[i])
		    targets[i] = attrNamespaceHandle;
		else
		    targets[i] = elemNamespaceHandle;
	    }
	    
	    else {
		if (isAttribute[i])
		    targets[i] = testSeq.compile(classGen, methodGen,
						 attrNamespaceHandle);
		else
		    targets[i] = testSeq.compile(classGen, methodGen,
						 elemNamespaceHandle);
	    }
	}

	if (ilKey != null) body.insert(ilKey);

	
	final int getType = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getExpandedTypeID"",
                                                      ""(I)I"");
	body.append(methodGen.loadDOM());
	body.append(new ILOAD(_currentIndex));
	body.append(new INVOKEINTERFACE(getType, 2));

	
	InstructionHandle disp = body.append(new SWITCH(types, targets, ihLoop));

	
	appendTestSequences(body);
	
	appendTemplateCode(body);

	
	if (nsElem != null) body.append(nsElem);
	
	if (nsAttr != null) body.append(nsAttr);

	
	body.append(ilRecurse);
	
	body.append(ilText);

	
	mainIL.append(new GOTO_W(ihLoop));
	mainIL.append(body);
	
	mainIL.append(ilLoop);

	peepHoleOptimization(methodGen);
	methodGen.stripAttributes(true);
	
	methodGen.setMaxLocals();
	methodGen.setMaxStack();
	methodGen.removeNOPs();
	classGen.addMethod(methodGen.getMethod());

	
	if (_importLevels != null) {
	    Enumeration levels = _importLevels.keys();
	    while (levels.hasMoreElements()) {
		Integer max = (Integer)levels.nextElement();
		Integer min = (Integer)_importLevels.get(max);
		compileApplyImports(classGen, min.intValue(), max.intValue());
	    }
	}
    }

    private void compileTemplateCalls(ClassGenerator classGen,
				      MethodGenerator methodGen,
				      InstructionHandle next, int min, int max){
        Enumeration templates = _neededTemplates.keys();
	while (templates.hasMoreElements()) {
	    final Template template = (Template)templates.nextElement();
	    final int prec = template.getImportPrecedence();
	    if ((prec >= min) && (prec < max)) {
		if (template.hasContents()) {
		    InstructionList til = template.compile(classGen, methodGen);
		    til.append(new GOTO_W(next));
		    _templateILs.put(template, til);
		    _templateIHs.put(template, til.getStart());
		}
		else {
		    
		    _templateIHs.put(template, next);
		}
	    }
	}
    }


    public void compileApplyImports(ClassGenerator classGen, int min, int max) {
	final XSLTC xsltc = classGen.getParser().getXSLTC();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final Vector names      = xsltc.getNamesIndex();

	
	_namedTemplates = new Hashtable();
	_neededTemplates = new Hashtable();
	_templateIHs = new Hashtable();
	_templateILs = new Hashtable();
	_patternGroups = new Vector[32];
	_rootPattern = null;

	
	Vector oldTemplates = _templates;

	
	_templates = new Vector();
	final Enumeration templates = oldTemplates.elements();
	while (templates.hasMoreElements()) {
	    final Template template = (Template)templates.nextElement();
	    final int prec = template.getImportPrecedence();
	    if ((prec >= min) && (prec < max)) addTemplate(template);
	}

	
	processPatterns(_keys);

	
	final org.apache.bcel.generic.Type[] argTypes =
	    new org.apache.bcel.generic.Type[3];
	argTypes[0] = Util.getJCRefType(DOM_INTF_SIG);
	argTypes[1] = Util.getJCRefType(NODE_ITERATOR_SIG);
	argTypes[2] = Util.getJCRefType(TRANSLET_OUTPUT_SIG);

	final String[] argNames = new String[3];
	argNames[0] = DOCUMENT_PNAME;
	argNames[1] = ITERATOR_PNAME;
	argNames[2] = TRANSLET_OUTPUT_PNAME;

	final InstructionList mainIL = new InstructionList();
	final MethodGenerator methodGen =
	    new MethodGenerator(ACC_PUBLIC | ACC_FINAL, 
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames, functionName()+'_'+max,
				getClassName(), mainIL,
				classGen.getConstantPool());
	methodGen.addException(""org.apache.xalan.xsltc.TransletException"");

	
	final LocalVariableGen current;
	current = methodGen.addLocalVariable2(""current"",
					      org.apache.bcel.generic.Type.INT,
					      mainIL.getEnd());
	_currentIndex = current.getIndex();

	
	
	final InstructionList body = new InstructionList();
	body.append(NOP);

	
	
	final InstructionList ilLoop = new InstructionList();
	ilLoop.append(methodGen.loadIterator());
	ilLoop.append(methodGen.nextNode());
	ilLoop.append(DUP);
	ilLoop.append(new ISTORE(_currentIndex));

	
	
        final BranchHandle ifeq = ilLoop.append(new IFLT(null));
	final BranchHandle loop = ilLoop.append(new GOTO_W(null));
	ifeq.setTarget(ilLoop.append(RETURN)); 
	final InstructionHandle ihLoop = ilLoop.getStart();

	
	InstructionList ilRecurse =
	    compileDefaultRecursion(classGen, methodGen, ihLoop);
	InstructionHandle ihRecurse = ilRecurse.getStart();

	
	InstructionList ilText =
	    compileDefaultText(classGen, methodGen, ihLoop);
	InstructionHandle ihText = ilText.getStart();

	
	final int[] types = new int[DTM.NTYPES + names.size()];
	for (int i = 0; i < types.length; i++) {
	    types[i] = i;
	}

	final boolean[] isAttribute = new boolean[types.length];
	final boolean[] isNamespace = new boolean[types.length];
	for (int i = 0; i < names.size(); i++) {
	    final String name = (String)names.elementAt(i);
	    isAttribute[i+DTM.NTYPES] = isAttributeName(name);
	    isNamespace[i+DTM.NTYPES] = isNamespaceName(name);
	}

	
	compileTemplateCalls(classGen, methodGen, ihLoop, min, max);

	
	final TestSeq elemTest = _testSeq[DTM.ELEMENT_NODE];
	InstructionHandle ihElem = ihRecurse;
	if (elemTest != null) {
	    ihElem = elemTest.compile(classGen, methodGen, ihLoop);
	}

	
	final TestSeq attrTest = _testSeq[DTM.ATTRIBUTE_NODE];
	InstructionHandle ihAttr = ihLoop;
	if (attrTest != null) {
	    ihAttr = attrTest.compile(classGen, methodGen, ihAttr);
	}

	
	InstructionList ilKey = null;
	if (_idxTestSeq != null) {
	    loop.setTarget(_idxTestSeq.compile(classGen, methodGen, body.getStart()));
	    ilKey = _idxTestSeq.getInstructionList();
	}
	else {
	    loop.setTarget(body.getStart());
	}

	
	
	if (_childNodeTestSeq != null) {
	    
	    double nodePrio = _childNodeTestSeq.getPriority();
	    int    nodePos  = _childNodeTestSeq.getPosition();
	    double elemPrio = (0 - Double.MAX_VALUE);
	    int    elemPos  = Integer.MIN_VALUE;

	    if (elemTest != null) {
		elemPrio = elemTest.getPriority();
		elemPos  = elemTest.getPosition();
	    }

	    if (elemPrio == Double.NaN || elemPrio < nodePrio || 
		(elemPrio == nodePrio && elemPos < nodePos)) 
	    {
		ihElem = _childNodeTestSeq.compile(classGen, methodGen, ihLoop);
	    }

	    
	    final TestSeq textTest = _testSeq[DTM.TEXT_NODE];
	    double textPrio = (0 - Double.MAX_VALUE);
	    int    textPos  = Integer.MIN_VALUE;

	    if (textTest != null) {
		textPrio = textTest.getPriority();
		textPos  = textTest.getPosition();
	    }

	    if (textPrio == Double.NaN || textPrio < nodePrio ||
	        (textPrio == nodePrio && textPos < nodePos)) 
	    {
		ihText = _childNodeTestSeq.compile(classGen, methodGen, ihLoop);
		_testSeq[DTM.TEXT_NODE] = _childNodeTestSeq;
	    }
	}

	
	InstructionHandle elemNamespaceHandle = ihElem;
	InstructionList nsElem = compileNamespaces(classGen, methodGen,
						   isNamespace, isAttribute,
						   false, ihElem);
	if (nsElem != null) elemNamespaceHandle = nsElem.getStart();

	
	InstructionList nsAttr = compileNamespaces(classGen, methodGen,
						   isNamespace, isAttribute,
						   true, ihAttr);
	InstructionHandle attrNamespaceHandle = ihAttr;
	if (nsAttr != null) attrNamespaceHandle = nsAttr.getStart();

	
	final InstructionHandle[] targets = new InstructionHandle[types.length];
	for (int i = DTM.NTYPES; i < targets.length; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    
	    if (isNamespace[i]) {
		if (isAttribute[i])
		    targets[i] = attrNamespaceHandle;
		else
		    targets[i] = elemNamespaceHandle;
	    }
	    
	    else if (testSeq != null) {
		if (isAttribute[i])
		    targets[i] = testSeq.compile(classGen, methodGen,
						 attrNamespaceHandle);
		else
		    targets[i] = testSeq.compile(classGen, methodGen,
						 elemNamespaceHandle);
	    }
	    else {
		targets[i] = ihLoop;
	    }
	}

	
	targets[DTM.ROOT_NODE] = _rootPattern != null
	    ? getTemplateInstructionHandle(_rootPattern.getTemplate())
	    : ihRecurse;
	
	targets[DTM.DOCUMENT_NODE] = _rootPattern != null
	    ? getTemplateInstructionHandle(_rootPattern.getTemplate())
	    : ihRecurse;    
	
	
	targets[DTM.TEXT_NODE] = _testSeq[DTM.TEXT_NODE] != null
	    ? _testSeq[DTM.TEXT_NODE].compile(classGen, methodGen, ihText)
	    : ihText;

	
	targets[DTM.NAMESPACE_NODE] = ihLoop;

	
	targets[DTM.ELEMENT_NODE] = elemNamespaceHandle;

	
	targets[DTM.ATTRIBUTE_NODE] = attrNamespaceHandle;

	
	InstructionHandle ihPI = ihLoop;
	if (_childNodeTestSeq != null) ihPI = ihElem;
	if (_testSeq[DTM.PROCESSING_INSTRUCTION_NODE] != null) {
	    targets[DTM.PROCESSING_INSTRUCTION_NODE] =
		_testSeq[DTM.PROCESSING_INSTRUCTION_NODE].
		compile(classGen, methodGen, ihPI);
	}
	else {
	    targets[DTM.PROCESSING_INSTRUCTION_NODE] = ihPI;
	}
	
	
	InstructionHandle ihComment = ihLoop;
	if (_childNodeTestSeq != null) ihComment = ihElem;
	targets[DTM.COMMENT_NODE] = _testSeq[DTM.COMMENT_NODE] != null
	    ? _testSeq[DTM.COMMENT_NODE].compile(classGen, methodGen, ihComment)
	    : ihComment;
	    
	        
	targets[DTM.CDATA_SECTION_NODE] = ihLoop;

	
	targets[DTM.DOCUMENT_FRAGMENT_NODE] = ihLoop;
	
	
	targets[DTM.DOCUMENT_TYPE_NODE] = ihLoop;

	
	targets[DTM.ENTITY_NODE] = ihLoop;

	
	targets[DTM.ENTITY_REFERENCE_NODE] = ihLoop;
	
	
	targets[DTM.NOTATION_NODE] = ihLoop;



	
	for (int i = DTM.NTYPES; i < targets.length; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    
	    if ((testSeq == null) || (isNamespace[i])) {
		if (isAttribute[i])
		    targets[i] = attrNamespaceHandle;
		else
		    targets[i] = elemNamespaceHandle;
	    }
	    
	    else {
		if (isAttribute[i])
		    targets[i] = testSeq.compile(classGen, methodGen,
						 attrNamespaceHandle);
		else
		    targets[i] = testSeq.compile(classGen, methodGen,
						 elemNamespaceHandle);
	    }
	}

	if (ilKey != null) body.insert(ilKey);

	
	final int getType = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getExpandedTypeID"",
                                                      ""(I)I"");
	body.append(methodGen.loadDOM());
	body.append(new ILOAD(_currentIndex));
	body.append(new INVOKEINTERFACE(getType, 2));

	
	InstructionHandle disp = body.append(new SWITCH(types,targets,ihLoop));

	
	appendTestSequences(body);
	
	appendTemplateCode(body);

	
	if (nsElem != null) body.append(nsElem);
	
	if (nsAttr != null) body.append(nsAttr);

	
	body.append(ilRecurse);
	
	body.append(ilText);

	
	mainIL.append(new GOTO_W(ihLoop));
	mainIL.append(body);
	
	mainIL.append(ilLoop);

	peepHoleOptimization(methodGen);
	methodGen.stripAttributes(true);
	
	methodGen.setMaxLocals();
	methodGen.setMaxStack();
	methodGen.removeNOPs();
	classGen.addMethod(methodGen.getMethod());

	
	_templates = oldTemplates;
    }

    
    private void peepHoleOptimization(MethodGenerator methodGen) {
    InstructionList il = methodGen.getInstructionList();
    InstructionFinder find = new InstructionFinder(il);
	InstructionHandle ih;
	String pattern;

	
	pattern = ""`ALOAD'`POP'`Instruction'"";
	for(Iterator iter=find.search(pattern); iter.hasNext();){
	    InstructionHandle[] match = (InstructionHandle[])iter.next();
	    try {
		if ((!match[0].hasTargeters()) && (!match[1].hasTargeters())) {
                    il.delete(match[0], match[1]);
                }
	    }
	    catch (TargetLostException e) {
                
            }
	}
	
	pattern = ""`ILOAD'`ALOAD'`SWAP'`Instruction'"";
	for(Iterator iter=find.search(pattern); iter.hasNext();){
            InstructionHandle[] match = (InstructionHandle[])iter.next();
            try {
                org.apache.bcel.generic.Instruction iload;
                org.apache.bcel.generic.Instruction aload;
                if ((!match[0].hasTargeters()) &&
                    (!match[1].hasTargeters()) &&
                    (!match[2].hasTargeters())) {
                    iload = match[0].getInstruction();
                    aload = match[1].getInstruction();
                    il.insert(match[0], aload);
                    il.insert(match[0], iload);
                    il.delete(match[0], match[2]);
                }
            }
            catch (TargetLostException e) {
                
            }
        }
        
        
	pattern = ""`ALOAD_1'`ALOAD_1'`Instruction'"";
        for(Iterator iter=find.search(pattern); iter.hasNext();){
            InstructionHandle[] match = (InstructionHandle[])iter.next();
            try {
	        org.apache.bcel.generic.Instruction iload;
                org.apache.bcel.generic.Instruction aload;
                if ((!match[0].hasTargeters()) && (!match[1].hasTargeters())) {
                    il.insert(match[1], new DUP());
                    il.delete(match[1]);
                }
            }
            catch (TargetLostException e) {
                
            }
        }
        
    }

    public InstructionHandle getTemplateInstructionHandle(Template template) {
	return (InstructionHandle)_templateIHs.get(template);
    }

    
    private static boolean isAttributeName(String qname) {
	final int col = qname.lastIndexOf(':') + 1;
	return (qname.charAt(col) == '@');
    }

    
    private static boolean isNamespaceName(String qname) {
	final int col = qname.lastIndexOf(':');
	return (col > -1 && qname.charAt(qname.length()-1) == '*');
    }
}
"
org.apache.xalan.lib.ExsltDynamic,7,2,0,16,43,21,1,15,7,1.166666667,682,0.0,0,0.25,0.642857143,0,0,96.28571429,1,0.8571,1,"
package org.apache.xalan.lib;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.TransformerException;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xpath.NodeSet;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;

import org.xml.sax.SAXNotSupportedException;


public class ExsltDynamic extends ExsltBase
{

   public static final String EXSL_URI = ""http:
   
  
  public static double max(ExpressionContext myContext, NodeList nl, String expr)
    throws SAXNotSupportedException
  {

    XPathContext xctxt = null;
    if (myContext instanceof XPathContext.XPathExpressionContext)
      xctxt = ((XPathContext.XPathExpressionContext) myContext).getXPathContext();
    else
      throw new SAXNotSupportedException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_CONTEXT_PASSED, new Object[]{myContext }));

    if (expr == null || expr.length() == 0)
      return Double.NaN;
      
    NodeSetDTM contextNodes = new NodeSetDTM(nl, xctxt);
    xctxt.pushContextNodeList(contextNodes);
    
    double maxValue = - Double.MAX_VALUE;
    for (int i = 0; i < contextNodes.getLength(); i++)
    {
      int contextNode = contextNodes.item(i);
      xctxt.pushCurrentNode(contextNode);
      
      double result = 0;
      try
      {
        XPath dynamicXPath = new XPath(expr, xctxt.getSAXLocator(),
                                       xctxt.getNamespaceContext(),
                                       XPath.SELECT);
        result = dynamicXPath.execute(xctxt, contextNode, xctxt.getNamespaceContext()).num();
      }
      catch (TransformerException e)
      {
        xctxt.popCurrentNode();
        xctxt.popContextNodeList();
        return Double.NaN;
      }
      
      xctxt.popCurrentNode();
              
      if (result > maxValue)
          maxValue = result;
    }      
      
    xctxt.popContextNodeList();
    return maxValue;
        
  }
  
  
  public static double min(ExpressionContext myContext, NodeList nl, String expr)
    throws SAXNotSupportedException
  {
    
    XPathContext xctxt = null;
    if (myContext instanceof XPathContext.XPathExpressionContext)
      xctxt = ((XPathContext.XPathExpressionContext) myContext).getXPathContext();
    else
      throw new SAXNotSupportedException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_CONTEXT_PASSED, new Object[]{myContext }));

    if (expr == null || expr.length() == 0)
      return Double.NaN;
      
    NodeSetDTM contextNodes = new NodeSetDTM(nl, xctxt);
    xctxt.pushContextNodeList(contextNodes);
    
    double minValue = Double.MAX_VALUE;
    for (int i = 0; i < nl.getLength(); i++)
    {
      int contextNode = contextNodes.item(i);
      xctxt.pushCurrentNode(contextNode);
      
      double result = 0;
      try
      {
        XPath dynamicXPath = new XPath(expr, xctxt.getSAXLocator(),
                                       xctxt.getNamespaceContext(),
                                       XPath.SELECT);
        result = dynamicXPath.execute(xctxt, contextNode, xctxt.getNamespaceContext()).num();
      }
      catch (TransformerException e)
      {
        xctxt.popCurrentNode();
        xctxt.popContextNodeList();
        return Double.NaN;
      }
      
      xctxt.popCurrentNode();
              
      if (result < minValue)
          minValue = result;
    }      
      
    xctxt.popContextNodeList();
    return minValue;
  
  }

  
  public static double sum(ExpressionContext myContext, NodeList nl, String expr)
    throws SAXNotSupportedException
  {
    XPathContext xctxt = null;
    if (myContext instanceof XPathContext.XPathExpressionContext)
      xctxt = ((XPathContext.XPathExpressionContext) myContext).getXPathContext();
    else
      throw new SAXNotSupportedException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_CONTEXT_PASSED, new Object[]{myContext }));

    if (expr == null || expr.length() == 0)
      return Double.NaN;
      
    NodeSetDTM contextNodes = new NodeSetDTM(nl, xctxt);
    xctxt.pushContextNodeList(contextNodes);
    
    double sum = 0;
    for (int i = 0; i < nl.getLength(); i++)
    {
      int contextNode = contextNodes.item(i);
      xctxt.pushCurrentNode(contextNode);
      
      double result = 0;
      try
      {
        XPath dynamicXPath = new XPath(expr, xctxt.getSAXLocator(),
                                       xctxt.getNamespaceContext(),
                                       XPath.SELECT);
        result = dynamicXPath.execute(xctxt, contextNode, xctxt.getNamespaceContext()).num();
      }
      catch (TransformerException e)
      {
        xctxt.popCurrentNode();
        xctxt.popContextNodeList();
        return Double.NaN;
      }
      
      xctxt.popCurrentNode();
      
      sum = sum + result;
              
    }      
      
    xctxt.popContextNodeList();
    return sum;
  }

  
  public static NodeList map(ExpressionContext myContext, NodeList nl, String expr)
    throws SAXNotSupportedException
  {
    XPathContext xctxt = null;
    Document lDoc = null;
    
    if (myContext instanceof XPathContext.XPathExpressionContext)
      xctxt = ((XPathContext.XPathExpressionContext) myContext).getXPathContext();
    else
      throw new SAXNotSupportedException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_CONTEXT_PASSED, new Object[]{myContext }));

    if (expr == null || expr.length() == 0)
      return new NodeSet();
      
    NodeSetDTM contextNodes = new NodeSetDTM(nl, xctxt);
    xctxt.pushContextNodeList(contextNodes);
    
    NodeSet resultSet = new NodeSet();
    resultSet.setShouldCacheNodes(true);
    
    for (int i = 0; i < nl.getLength(); i++)
    {
      int contextNode = contextNodes.item(i);
      xctxt.pushCurrentNode(contextNode);
      
      XObject object = null;
      try
      {
        XPath dynamicXPath = new XPath(expr, xctxt.getSAXLocator(),
                                       xctxt.getNamespaceContext(),
                                       XPath.SELECT);
        object = dynamicXPath.execute(xctxt, contextNode, xctxt.getNamespaceContext());
        
        if (object instanceof XNodeSet)
        {
          NodeList nodelist = null;
          nodelist = ((XNodeSet)object).nodelist();
        
          for (int k = 0; k < nodelist.getLength(); k++)
          {
            Node n = nodelist.item(k);
            if (!resultSet.contains(n))
              resultSet.addNode(n);
          }
        }
        else
        {
	  if (lDoc == null)
	  {
            DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
            dbf.setNamespaceAware(true);
            DocumentBuilder db = dbf.newDocumentBuilder();
            lDoc = db.newDocument();
          }
        
          Element element = null;
          if (object instanceof XNumber)
            element = lDoc.createElementNS(EXSL_URI, ""exsl:number"");
          else if (object instanceof XBoolean)
            element = lDoc.createElementNS(EXSL_URI, ""exsl:boolean"");
          else
            element = lDoc.createElementNS(EXSL_URI, ""exsl:string"");
          
          Text textNode = lDoc.createTextNode(object.str());
          element.appendChild(textNode);
          resultSet.addNode(element);
        }
      }
      catch (Exception e)
      {
        xctxt.popCurrentNode();
        xctxt.popContextNodeList();
        return new NodeSet();
      }
      
      xctxt.popCurrentNode();
      
    }      
      
    xctxt.popContextNodeList();
    return resultSet;
  }

  
  public static XObject evaluate(ExpressionContext myContext, String xpathExpr)
    throws SAXNotSupportedException
  {
    if (myContext instanceof XPathContext.XPathExpressionContext)
    {
      XPathContext xctxt = null;
      try
      {
        xctxt = ((XPathContext.XPathExpressionContext) myContext).getXPathContext();
        XPath dynamicXPath = new XPath(xpathExpr, xctxt.getSAXLocator(),
                                       xctxt.getNamespaceContext(),
                                       XPath.SELECT);

        return dynamicXPath.execute(xctxt, myContext.getContextNode(),
                                    xctxt.getNamespaceContext());
      }
      catch (TransformerException e)
      {
        return new XNodeSet(xctxt.getDTMManager());
      }
    }
    else
      throw new SAXNotSupportedException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_CONTEXT_PASSED, new Object[]{myContext })); 
  }

  
  public static NodeList closure(ExpressionContext myContext, NodeList nl, String expr)
    throws SAXNotSupportedException
  {
    XPathContext xctxt = null;
    if (myContext instanceof XPathContext.XPathExpressionContext)
      xctxt = ((XPathContext.XPathExpressionContext) myContext).getXPathContext();
    else
      throw new SAXNotSupportedException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_CONTEXT_PASSED, new Object[]{myContext }));

    if (expr == null || expr.length() == 0)
      return new NodeSet();
          
    NodeSet closureSet = new NodeSet();
    closureSet.setShouldCacheNodes(true);
        
    NodeList iterationList = nl;
    do
    {
    
      NodeSet iterationSet = new NodeSet();

      NodeSetDTM contextNodes = new NodeSetDTM(iterationList, xctxt);
      xctxt.pushContextNodeList(contextNodes);
      
      for (int i = 0; i < iterationList.getLength(); i++)
      {
        int contextNode = contextNodes.item(i);
        xctxt.pushCurrentNode(contextNode);

        XObject object = null;
        try
        {
          XPath dynamicXPath = new XPath(expr, xctxt.getSAXLocator(),
                                         xctxt.getNamespaceContext(),
                                         XPath.SELECT);
          object = dynamicXPath.execute(xctxt, contextNode, xctxt.getNamespaceContext());
          
          if (object instanceof XNodeSet)
          {
            NodeList nodelist = null;
            nodelist = ((XNodeSet)object).nodelist();
        
            for (int k = 0; k < nodelist.getLength(); k++)
            {
              Node n = nodelist.item(k);
              if (!iterationSet.contains(n))
                iterationSet.addNode(n);
            }        
          }
          else
          {
            xctxt.popCurrentNode();
            xctxt.popContextNodeList();
            return new NodeSet();
          }          
        }
        catch (TransformerException e)
        {
          xctxt.popCurrentNode();
          xctxt.popContextNodeList();
          return new NodeSet();
        }
      
        xctxt.popCurrentNode();
            
      }
      
      xctxt.popContextNodeList();
      
      iterationList = iterationSet;
      
      for (int i = 0; i < iterationList.getLength(); i++)
      {
        Node n = iterationList.item(i);
        if (!closureSet.contains(n))
          closureSet.addNode(n);
      }
      
    } while(iterationList.getLength() > 0);
    
    return closureSet;
              
  }
  
}"
org.apache.xalan.templates.TemplateSubPatternAssociation,15,1,0,7,25,49,2,5,12,0.833333333,139,0.833333333,3,0.0,0.208333333,0,0,7.866666667,6,1.2667,0,"
package org.apache.xalan.templates;

import java.io.Serializable;

import javax.xml.transform.TransformerException;

import org.apache.xml.utils.QName;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.patterns.StepPattern;


class TemplateSubPatternAssociation implements Serializable, Cloneable
{

  
  StepPattern m_stepPattern;

  
  private String m_pattern;

  
  private ElemTemplate m_template;

  
  private TemplateSubPatternAssociation m_next = null;

  
  private boolean m_wild;

  
  private String m_targetString;

  
  TemplateSubPatternAssociation(ElemTemplate template, StepPattern pattern, String pat)
  {

    m_pattern = pat;
    m_template = template;
    m_stepPattern = pattern;
    m_targetString = m_stepPattern.getTargetString();
    m_wild = m_targetString.equals(""*"");
  }

  
  public Object clone() throws CloneNotSupportedException
  {

    TemplateSubPatternAssociation tspa =
      (TemplateSubPatternAssociation) super.clone();

    tspa.m_next = null;

    return tspa;
  }

  
  public final String getTargetString()
  {
    return m_targetString;
  }

  
  public void setTargetString(String key)
  {
    m_targetString = key;
  }

  
  boolean matchMode(QName m1)
  {
    return matchModes(m1, m_template.getMode());
  }

  
  private boolean matchModes(QName m1, QName m2)
  {
    return (((null == m1) && (null == m2))
            || ((null != m1) && (null != m2) && m1.equals(m2)));
  }

  
  public boolean matches(XPathContext xctxt, int targetNode, QName mode)
          throws TransformerException
  {

    double score = m_stepPattern.getMatchScore(xctxt, targetNode);

    return (XPath.MATCH_SCORE_NONE != score)
           && matchModes(mode, m_template.getMode());
  }

  
  public final boolean isWild()
  {
    return m_wild;
  }

  
  public final StepPattern getStepPattern()
  {
    return m_stepPattern;
  }

  
  public final String getPattern()
  {
    return m_pattern;
  }

  
  public int getDocOrderPos()
  {
    return m_template.getUid();
  }

  
  public final int getImportLevel()
  {
    return m_template.getStylesheetComposed().getImportCountComposed();
  }

  
  public final ElemTemplate getTemplate()
  {
    return m_template;
  }

  
  public final TemplateSubPatternAssociation getNext()
  {
    return m_next;
  }

  
  public void setNext(TemplateSubPatternAssociation mp)
  {
    m_next = mp;
  }
}
"
org.apache.xalan.templates.AVTPartXPath,7,2,0,13,20,0,1,12,7,0.0,74,1.0,1,0.5,0.25974026,0,0,9.428571429,1,0.7143,1,"
package org.apache.xalan.templates;

import org.apache.xml.utils.FastStringBuffer;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathFactory;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xpath.objects.XObject;


public class AVTPartXPath extends AVTPart
{

  
  private XPath m_xpath;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_xpath.fixupVariables(vars, globalsSize);
  }
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return m_xpath.getExpression().canTraverseOutsideSubtree();
   }

  
  public AVTPartXPath(XPath xpath)
  {
    m_xpath = xpath;
  }

  
  public AVTPartXPath(
          String val, org.apache.xml.utils.PrefixResolver nsNode, 
          XPathParser xpathProcessor, XPathFactory factory, 
          XPathContext liaison)
            throws javax.xml.transform.TransformerException
  {
    m_xpath = new XPath(val, null, nsNode, XPath.SELECT, liaison.getErrorListener());
  }

  
  public String getSimpleString()
  {
    return ""{"" + m_xpath.getPatternString() + ""}"";
  }

  
  public void evaluate(
          XPathContext xctxt, FastStringBuffer buf, int context, org.apache.xml.utils.PrefixResolver nsNode)
            throws javax.xml.transform.TransformerException
  {

    XObject xobj = m_xpath.execute(xctxt, context, nsNode);

    if (null != xobj)
    {
      xobj.appendToFsb(buf);
    }
  }
  
  
  public void callVisitors(XSLTVisitor visitor)
  {
  	m_xpath.getExpression().callVisitors(m_xpath, visitor);
  }
}
"
org.apache.xpath.operations.UnaryOperation,11,2,4,11,20,0,6,6,11,0.2,88,1.0,1,0.75,0.227272727,1,7,6.909090909,3,1.3636,0,"
package org.apache.xpath.operations;

import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XObject;


public abstract class UnaryOperation extends Expression implements ExpressionOwner
{

  
  protected Expression m_right;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_right.fixupVariables(vars, globalsSize);
  }
  
  
  public boolean canTraverseOutsideSubtree()
  {

    if (null != m_right && m_right.canTraverseOutsideSubtree())
      return true;

    return false;
  }

  
  public void setRight(Expression r)
  {
    m_right = r;
    r.exprSetParent(this);
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    return operate(m_right.execute(xctxt));
  }

  
  public abstract XObject operate(XObject right)
    throws javax.xml.transform.TransformerException;

  
  public Expression getOperand(){
    return m_right;
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	if(visitor.visitUnaryOperation(owner, this))
  	{
  		m_right.callVisitors(this, visitor);
  	}
  }


  
  public Expression getExpression()
  {
    return m_right;
  }

  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_right = exp;
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	if(!m_right.deepEquals(((UnaryOperation)expr).m_right))
  		return false;
  		
  	return true;
  }


}
"
org.apache.xalan.processor.ProcessorGlobalParamDecl,3,5,0,6,10,3,1,5,1,2.0,30,0.0,0,0.990697674,0.583333333,1,2,9.0,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemParam;
import org.apache.xalan.templates.ElemTemplateElement;


class ProcessorGlobalParamDecl extends ProcessorTemplateElem
{

  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    
    handler.pushElemTemplateElement(elem);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    ElemParam v = (ElemParam) handler.getElemTemplateElement();

    handler.getStylesheet().appendChild(v);
    handler.getStylesheet().setParam(v);
    super.endElement(handler, uri, localName, rawName);
  }
}
"
org.apache.xalan.xsltc.compiler.util.NamedMethodGenerator,3,5,0,5,6,1,1,4,2,0.5,28,1.0,0,0.992805755,0.625,2,3,8.0,2,0.6667,1,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.Type;


public final class NamedMethodGenerator extends MethodGenerator {
    protected static int CURRENT_INDEX  = 4;

    public NamedMethodGenerator(int access_flags, Type return_type,
				Type[] arg_types, String[] arg_names,
				String method_name, String class_name,
				InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
    }

    public int getLocalIndex(String name) {
	if (name.equals(""current"")) {
	    return CURRENT_INDEX;
	}
	return super.getLocalIndex(name);
    }
}
"
org.apache.xpath.axes.DescendantIterator,9,5,0,11,42,0,2,9,8,0.583333333,423,1.0,1,0.946969697,0.277777778,3,11,45.66666667,14,2.7778,2,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.OpCodes;
import org.apache.xpath.patterns.NodeTest;


public class DescendantIterator extends LocPathIterator
{
  
  DescendantIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {

    super(compiler, opPos, analysis, false);

    int firstStepPos = compiler.getFirstChildPos(opPos);
    int stepType = compiler.getOp(firstStepPos);

    boolean orSelf = (OpCodes.FROM_DESCENDANTS_OR_SELF == stepType);
    boolean fromRoot = false;
    if (OpCodes.FROM_SELF == stepType)
    {
      orSelf = true;
      
    }
    else if(OpCodes.FROM_ROOT == stepType)
    {
      fromRoot = true;
      
      int nextStepPos = compiler.getNextStepPos(firstStepPos);
      if(compiler.getOp(nextStepPos) == OpCodes.FROM_DESCENDANTS_OR_SELF)
        orSelf = true;
      
    }
    
    
    int nextStepPos = firstStepPos;
    while(true)
    {
      nextStepPos = compiler.getNextStepPos(nextStepPos);
      if(nextStepPos > 0)
      {
        int stepOp = compiler.getOp(nextStepPos);
        if(OpCodes.ENDOP != stepOp)
          firstStepPos = nextStepPos;
        else
          break;
      }
      else
        break;
      
    }
    
    
    if((analysis & WalkerFactory.BIT_CHILD) != 0)
      orSelf = false;
      
    if(fromRoot)
    {
      if(orSelf)
        m_axis = Axis.DESCENDANTSORSELFFROMROOT;
      else
        m_axis = Axis.DESCENDANTSFROMROOT;
    }
    else if(orSelf)
      m_axis = Axis.DESCENDANTORSELF;
    else
      m_axis = Axis.DESCENDANT;

    int whatToShow = compiler.getWhatToShow(firstStepPos);

    if ((0 == (whatToShow
               & (DTMFilter.SHOW_ATTRIBUTE | DTMFilter.SHOW_ELEMENT
                  | DTMFilter.SHOW_PROCESSING_INSTRUCTION))) || 
                   (whatToShow == DTMFilter.SHOW_ALL))
      initNodeTest(whatToShow);
    else
    {
      initNodeTest(whatToShow, compiler.getStepNS(firstStepPos),
                              compiler.getStepLocalName(firstStepPos));
    }
    initPredicateInfo(compiler, firstStepPos);
  }
  
  
  public DescendantIterator()
  {
    super(null);
    m_axis = Axis.DESCENDANTSORSELFFROMROOT;
    int whatToShow = DTMFilter.SHOW_ALL;
    initNodeTest(whatToShow);
  }

  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    DescendantIterator clone = (DescendantIterator) super.cloneWithReset();
    clone.m_traverser = m_traverser;

    clone.resetProximityPositions();

    return clone;
  }

  
  public int nextNode()
  {
   	if(m_foundLast)
  		return DTM.NULL;

    if(DTM.NULL == m_lastFetched)
    {
      resetProximityPositions();
    }

    int next;
    
    org.apache.xpath.VariableStack vars;
    int savedStart;
    if (-1 != m_stackFrame)
    {
      vars = m_execContext.getVarStack();

      
      savedStart = vars.getStackFrame();

      vars.setStackFrame(m_stackFrame);
    }
    else
    {
      
      vars = null;
      savedStart = 0;
    }
    
    try
    {
      do
      {
        if(0 == m_extendedTypeID)
        {
          next = m_lastFetched = (DTM.NULL == m_lastFetched)
                       ? m_traverser.first(m_context)
                       : m_traverser.next(m_context, m_lastFetched);
        }
        else
        {
          next = m_lastFetched = (DTM.NULL == m_lastFetched)
                       ? m_traverser.first(m_context, m_extendedTypeID)
                       : m_traverser.next(m_context, m_lastFetched, 
                                          m_extendedTypeID);
        }
  
        if (DTM.NULL != next)
        {
          if(DTMIterator.FILTER_ACCEPT == acceptNode(next))
            break;
          else
            continue;
        }
        else
          break;
      }
      while (next != DTM.NULL);
  
      if (DTM.NULL != next)
      {
      	m_pos++;
        return next;
      }
      else
      {
        m_foundLast = true;
  
        return DTM.NULL;
      }
    }
    finally
    {
      if (-1 != m_stackFrame)
      {
        
        vars.setStackFrame(savedStart);
      }
    }
  }
  
  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    m_traverser = m_cdtm.getAxisTraverser(m_axis);
    
    String localName = getLocalName();
    String namespace = getNamespace();
    int what = m_whatToShow;
    
    
    if(DTMFilter.SHOW_ALL == what
       || localName == NodeTest.WILD
       || namespace == NodeTest.WILD)
    {
      m_extendedTypeID = 0;
    }
    else
    {
      int type = getNodeTypeTest(what);
      m_extendedTypeID = m_cdtm.getExpandedTypeID(namespace, localName, type);
    }
    
  }
  
  
  public int asNode(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
    if(getPredicateCount() > 0)
      return super.asNode(xctxt);

    int current = xctxt.getCurrentNode();
    
    DTM dtm = xctxt.getDTM(current);
    DTMAxisTraverser traverser = dtm.getAxisTraverser(m_axis);
    
    String localName = getLocalName();
    String namespace = getNamespace();
    int what = m_whatToShow;
    
    
    
    
    
    if(DTMFilter.SHOW_ALL == what
       || localName == NodeTest.WILD
       || namespace == NodeTest.WILD)
    {
      return traverser.first(current);
    }
    else
    {
      int type = getNodeTypeTest(what);
      int extendedType = dtm.getExpandedTypeID(namespace, localName, type);
      return traverser.first(current, extendedType);
    }
  }
  
  
  public void detach()
  {    
    m_traverser = null;    
    m_extendedTypeID = 0;
    
    
    super.detach();
  }
  
  
  public int getAxis()
  {
    return m_axis;
  }
  
  
  
  transient protected DTMAxisTraverser m_traverser;
  
  
  protected int m_axis;
  
  
  protected int m_extendedTypeID;
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(m_axis != ((DescendantIterator)expr).m_axis)
  		return false;
  		
  	return true;
  }

  
}
"
org.apache.xalan.processor.ProcessorTemplate,2,5,0,6,8,1,1,5,0,2.0,19,0.0,0,0.995327103,0.666666667,1,1,8.5,1,0.5,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;


class ProcessorTemplate extends ProcessorTemplateElem
{
  
  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    super.appendAndPush(handler, elem);
    elem.setDOMBackPointer(handler.getOriginatingNode());
    handler.getStylesheet().setTemplate((ElemTemplate) elem);
  }
}
"
org.apache.xpath.functions.FuncSubstringAfter,2,5,0,6,8,1,0,6,2,2.0,34,0.0,0,0.98245614,0.75,1,6,16.0,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncSubstringAfter extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XMLString s1 = m_arg0.execute(xctxt).xstr();
    XMLString s2 = m_arg1.execute(xctxt).xstr();
    int index = s1.indexOf(s2);

    return (-1 == index)
           ? XString.EMPTYSTRING
           : (XString)s1.substring(index + s2.length());
  }
}
"
org.apache.xalan.xsltc.compiler.IdPattern,1,6,0,1,2,0,1,1,1,2.0,6,0.0,0,1.0,1.0,0,0,5.0,0,0.0,0,"

package org.apache.xalan.xsltc.compiler;


final class IdPattern extends IdKeyPattern {

    public IdPattern(String id) {
	super(""##id"",id);
    }

}
"
org.apache.xalan.xsltc.compiler.AbsoluteLocationPath,7,3,0,19,28,0,1,18,7,0.0,143,1.0,1,0.934210526,0.285714286,2,7,19.28571429,2,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class AbsoluteLocationPath extends Expression {
    private Expression _path;	

    public AbsoluteLocationPath() {
	_path = null;
    }

    public AbsoluteLocationPath(Expression path) {
	_path = path;
	if (path != null) {
	    _path.setParent(this);
	}
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_path != null) {
	    _path.setParser(parser);
	}
    }

    public Expression getPath() {
	return(_path);
    }
    
    public String toString() {
	return ""AbsoluteLocationPath("" +
	    (_path != null ? _path.toString() : ""null"") + ')';
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_path != null) {
	    final Type ptype = _path.typeCheck(stable);
	    if (ptype instanceof NodeType) {		
		_path = new CastExpr(_path, Type.NodeSet);
	    }
	}
	return _type = Type.NodeSet;	
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	if (_path != null) {
	    final int initAI = cpg.addMethodref(ABSOLUTE_ITERATOR,
						""<init>"",
						""(""
						+ NODE_ITERATOR_SIG
						+ "")V"");
	    
	    il.append(new NEW(cpg.addClass(ABSOLUTE_ITERATOR)));
	    il.append(DUP);

	    
	    _path.translate(classGen, methodGen);

	    
	    il.append(new INVOKESPECIAL(initAI));
	}
	else {
	    final int gitr = cpg.addInterfaceMethodref(DOM_INTF,
						       ""getIterator"",
						       ""()""+NODE_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(new INVOKEINTERFACE(gitr, 1));
	}
    }
}
"
org.apache.xpath.res.XPATHErrorResources_ja,3,4,0,1,4,1,0,1,2,1.428571429,1872,0.0,0,0.976190476,1.0,0,0,618.3333333,1,0.3333,1,"
package org.apache.xpath.res;


public class XPATHErrorResources_ja extends XPATHErrorResources
{


  
  public static final int MAX_CODE = 108;  

  
  public static final int MAX_WARNING = 11;  

  
  public static final int MAX_OTHERS = 20;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  
  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_CURRENT_NOT_ALLOWED_IN_MATCH,
      ""current() 関数は一致パターンで許可されません。""},



  
  


  {
    ER_CURRENT_TAKES_NO_ARGS,
      ""current() 関数は引数を受け入れません。""},



  
  


  {
    ER_DOCUMENT_REPLACED,
      ""document() 関数実装は org.apache.xalan.xslt.FuncDocument に置き換えられました。""},



  
  


  {
    ER_CONTEXT_HAS_NO_OWNERDOC,
      ""コンテキストは所有者ドキュメントを保持しません。""},



  
  


  {
    ER_LOCALNAME_HAS_TOO_MANY_ARGS,
      ""local-name() の引数が多すぎます。""},



  
  


  {
    ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
      ""namespace-uri() の引数が多すぎます。""},



  
  


  {
    ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
      ""normalize-space() の引数が多すぎます。""},



  
  


  {
    ER_NUMBER_HAS_TOO_MANY_ARGS,
      ""number() の引数が多すぎます。""},



  
  


  {
    ER_NAME_HAS_TOO_MANY_ARGS, ""name() の引数が多すぎます。""},



  
  


  {
    ER_STRING_HAS_TOO_MANY_ARGS,
      ""string() の引数が多すぎます。""},



  
  


  {
    ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
      ""string-length() の引数が多すぎます。""},



  
  


  {
    ER_TRANSLATE_TAKES_3_ARGS,
      ""translate() 関数に 3 つの引数が指定されています。""},



  
  


  {
    ER_UNPARSEDENTITYURI_TAKES_1_ARG,
      ""unparsed-entity-uri 関数は引数を 1 つだけ使用できます。""},



  
  


  {
    ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
      ""名前空間軸はまだ実装されていません。""},



  
  


  {
    ER_UNKNOWN_AXIS, ""未知の軸: {0}""},



  
  


  {
    ER_UNKNOWN_MATCH_OPERATION, ""未知の照合オペレーションです。""},



  
  


  {
    ER_INCORRECT_ARG_LENGTH,
      ""processing-instruction() ノードテストの引数の長さが不正です。""},



  
  


  {
    ER_CANT_CONVERT_TO_NUMBER,
      ""{0} を数字に変換できません""},



  
  


  {
    ER_CANT_CONVERT_TO_NODELIST,
      ""{0} を NodeList に変換できません。""},



  
  


  {
    ER_CANT_CONVERT_TO_MUTABLENODELIST,
      ""{0} を NodeSetDTM に変換できません。""},



  
  


  {
    ER_CANT_CONVERT_TO_TYPE,
      ""{0} を type



  
  


  {
    ER_EXPECTED_MATCH_PATTERN,
      ""getMatchScore に予期される一致パターンです。""},



  
  


  {
    ER_COULDNOT_GET_VAR_NAMED,
      ""{0} という名前の変数を取得できませんでした""},



  
  


  {
    ER_UNKNOWN_OPCODE, ""エラー。未知のオプションコード: {0}""},



  
  


  {
    ER_EXTRA_ILLEGAL_TOKENS, ""余分な不正トークン: {0}""},



  
  


  {
    ER_EXPECTED_DOUBLE_QUOTE,
      ""リテラルの引用符が誤りです... 二重引用符が必要です。""},



  
  


  {
    ER_EXPECTED_SINGLE_QUOTE,
      ""リテラルの引用符が誤りです... 単一引用符が必要です。""},



  
  


  {
    ER_EMPTY_EXPRESSION, ""式が空です。""},



  
  


  {
    ER_EXPECTED_BUT_FOUND, ""{0} が予期されていましたが、{1} が見つかりました。""},



  
  


  {
    ER_INCORRECT_PROGRAMMER_ASSERTION,
      ""プログラマの表明が不正です。 - {0}""},



  
  


  {
    ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
      ""19990709 XPath ドラフトについて、boolean(...) 引数はもう任意ではありません。""},



  
  


  {
    ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
      ""',' が見つかりましたが、その前に引数がありません。""},



  
  


  {
    ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
      ""',' が見つかりましたが、それに続く引数がありません。""},



  
  


  {
    ER_PREDICATE_ILLEGAL_SYNTAX,
      ""'..[predicate]' または '.[predicate]' は不当な構文です。代わりに 'self::node()[predicate]' を使用してください。""},



  
  


  {
    ER_ILLEGAL_AXIS_NAME, ""不当な軸名: {0}""},



  
  


  {
    ER_UNKNOWN_NODETYPE, ""未知のノードタイプ: {0}""},



  
  


  {
    ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
      ""リテラル ({0}) パターンは、引用符で囲む必要があります。""},



  
  


  {
    ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
      ""{0} は数字に書式設定できませんでした。""},



  
  


  {
    ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
      ""XML TransformerFactory Liaison を作成できませんでした: {0}""},



  
  


  {
    ER_DIDNOT_FIND_XPATH_SELECT_EXP,
      ""エラー。xpath 選択式 (-select) が見つかりませんでした。""},



  
  


  {
    ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
      ""エラー。OP_LOCATIONPATH の後に ENDOP が見つかりませんでした""},



  
  


  {
    ER_ERROR_OCCURED, ""エラーが発生しました。""},



  
  


  {
    ER_ILLEGAL_VARIABLE_REFERENCE,
      ""コンテキストの外で、または定義なしで VariableReference が変数に指定されました。Name = {0}""},



  
  


  {
    ER_AXES_NOT_ALLOWED,
      ""一致パターンには、child:: および attribute:: 軸だけが許可されます。許可されない軸 = {0}""},



  
  


  {
    ER_KEY_HAS_TOO_MANY_ARGS,
      ""key() の引数の数が不正です。""},



  
  


  {
    ER_COUNT_TAKES_1_ARG,
      ""count 関数に使用できる引数は 1 つです。""},



  
  


  {
    ER_COULDNOT_FIND_FUNCTION, ""関数 {0} が見つかりませんでした""},



  
  


  {
    ER_UNSUPPORTED_ENCODING, ""サポートされないエンコーディング: {0}""},



  
  


  {
    ER_PROBLEM_IN_DTM_NEXTSIBLING,
      ""getNextSibling の DTM に問題が発生しました... 復元しています""},



  
  


  {
    ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
      ""プログラマエラー: EmptyNodeList に書き込みできません。""},



  
  


  {
    ER_SETDOMFACTORY_NOT_SUPPORTED,
      ""setDOMFactory は XPathContext でサポートされていません。""},



  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""接頭辞は名前空間に変える必要があります: {0}""},



  
  


  {
    ER_PARSE_NOT_SUPPORTED,
      ""構文解析 (InputSource ソース) は XPathContext でサポートされていません。{0} をオープンできません""},



  
  


  {
    ER_SAX_API_NOT_HANDLED,
      ""SAX API characters(char ch[]... は DTM で処理されません。""},



  
  


  {
    ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
      ""ignorableWhitespace(char ch[]... は DTM で処理されません。""},



  
  


  {
    ER_DTM_CANNOT_HANDLE_NODES,
      ""DTMLiaison はタイプ {0} のノードを処理できません""},



  
  


  {
    ER_XERCES_CANNOT_HANDLE_NODES,
      ""DOM2Helper はタイプ {0} のノードを処理できません""},



  
  


  {
    ER_XERCES_PARSE_ERROR_DETAILS,
      ""DOM2Helper.parse エラー: SystemID - {0} 行番号 - {1}""},



  
  


  {
    ER_XERCES_PARSE_ERROR, ""DOM2Helper.parse エラー""},



  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""無効な UTF-16 代理が検出されました: {0} ?""},



  
  


  {
    ER_OIERROR, ""入出力エラー""},



  
  


  {
    ER_CANNOT_CREATE_URL, ""{0} の URL を作成できません""},



  
  


  {
    ER_XPATH_READOBJECT, ""XPath.readObject にあります: {0}""},


  
  
  


  {
    ER_FUNCTION_TOKEN_NOT_FOUND,
      ""関数トークンが見つかりません。""},


  
   
  


  {
    ER_CANNOT_DEAL_XPATH_TYPE,
       ""XPath タイプ {0} は処理できません""},


  
   
  


  {
    ER_NODESET_NOT_MUTABLE,
       ""この NodeSet は可変ではありません""},


  
   
  


  {
    ER_NODESETDTM_NOT_MUTABLE,
       ""この NodeSetDTM は可変ではありません""},


  
   
  


  {
    ER_VAR_NOT_RESOLVABLE,
        ""解決できない変数: {0}""},


  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""null エラーハンドラ""},


  
   
  


  {
    ER_PROG_ASSERT_UNKNOWN_OPCODE,
       ""プログラマの表明: 未知のオプションコード: {0}""},


  
   
  


  {
    ER_ZERO_OR_ONE,
       ""0 または 1""},


  
  
  
   
  


  {
    ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""rtf() は XRTreeFragSelectWrapper でサポートされていません""},


  
   
  


  {
    ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""asNodeIterator() は XRTreeFragSelectWrapper でサポートされていません""},


  
   
  


  {
    ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
       ""XStringForChars に fsb() はサポートされていません""},


  
   
  


  {
    ER_COULD_NOT_FIND_VAR,
      ""{0} という名前の変数が見つかりませんでした""},


  
   
  


  {
    ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
      ""XStringForChars は引数に文字列を使用できません""},


  
   
  


  {
    ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
      ""FastStringBuffer 引数は null にできません""},

    
  
   
   
  


  {
    ER_TWO_OR_THREE,
       ""▼2 または 3""},


   
  


  {
    ER_VARIABLE_ACCESSED_BEFORE_BIND,
       ""▼バインド前の変数にアクセスしました!""},


   
  


  {
    ER_FSB_CANNOT_TAKE_STRING,
       ""▼XStringForFSB の引数には文字列を指定できません!""},


   
  


  {
    ER_SETTING_WALKER_ROOT_TO_NULL,
       ""▼
 !!!! エラー! walker のルートの設定を null にしてください!!!""},


   
  


  {
    ER_NODESETDTM_CANNOT_ITERATE,
       ""▼この NodeSetDTM は前のノードに対して繰り返し処理を実行できません!""},


  
  


  {
    ER_NODESET_CANNOT_ITERATE,
       ""▼この NodeSet は前のノードに対して繰り返し処理を実行できません!""},


  
  


  {
    ER_NODESETDTM_CANNOT_INDEX,
       ""▼この NodeSetDTM はインデックス処理またはカウント処理を実行できません!""},


  
  


  {
    ER_NODESET_CANNOT_INDEX,
       ""▼この NodeSet はインデックス処理またはカウント処理を実行できません!""},


  
  


  {
    ER_CANNOT_CALL_SETSHOULDCACHENODE,
       ""▼nextNode を呼び出した後で setShouldCacheNodes を呼び出すことはできません!""},


  
  


  {
    ER_ONLY_ALLOWS,
       ""▼{0} で許される引数は {1} だけです""},


  
  


  {
    ER_UNKNOWN_STEP,
       ""▼getNextStepPos におけるプログラマの表明: 未知の stepType: {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_REL_LOC_PATH,
       ""▼トークン '/' または '


  
  
  

  
  


  {
    ER_EXPECTED_LOC_PATH,
       ""▼ロケーションパスが見つかりません。代わりに次のトークンが見つかりました:  {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_LOC_STEP,
       ""▼トークン '/' または '


  
  
  
  

  
  


  {
    ER_EXPECTED_NODE_TEST,
       ""▼NCName:* または QName の形式に一致するノードテストが見つかりません。""},


  
  
  

  
  


  {
    ER_EXPECTED_STEP_PATTERN,
       ""▼ステップパターンが見つかりません。代わりに '/' が見つかりました。""},


  
  
  
 
  
  


  {
    ER_EXPECTED_REL_PATH_PATTERN,
       ""▼相対パスパターンが見つかりません。""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_BOOLEAN,
       ""▼{0} を boolean 値に変換できません。""},


  
  

  
  


  {
    ER_CANT_CONVERT_TO_SINGLENODE,
       ""▼{0} を単一のノードに変換できません。この取得メソッドを適用できる型は、ANY_UNORDERED_NODE_TYPE と FIRST_ORDERED_NODE_TYPE です。""},


  
  

  
  


  {
    ER_CANT_GET_SNAPSHOT_LENGTH,
       ""▼型 {0} のスナップショット長を取得できません。この取得メソッドを適用できる型は、UNORDERED_NODE_SNAPSHOT_TYPE と ORDERED_NODE_SNAPSHOT_TYPE です。""},


  
  


  {
    ER_NON_ITERATOR_TYPE,
       ""▼非 iterator 型 {0} に対して繰り返し処理を実行することはできません""},


  
  
  

  
  


  {
    ER_DOC_MUTATED,
       ""▼結果が返された後にドキュメントが変更されたため、現在の反復子は無効になりました。""},


  
  


  {
    ER_INVALID_XPATH_TYPE,
       ""▼無効な XPath 型の引数: {0}""},


  
  


  {
    ER_EMPTY_XPATH_RESULT,
       ""▼空の XPath 結果オブジェクト""},


  
  


  {
    ER_INCOMPATIBLE_TYPES,
       ""▼戻り値の型 {0} は指定された型 {1} に変換できません""},


  
  


  {
    ER_NULL_RESOLVER,
       ""▼接頭辞リゾルバが null であったため、接頭辞の解決に失敗しました。""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_STRING,
       ""▼{0} を文字列値に変換できません。""},


  
  

  
  


  {
    ER_NON_SNAPSHOT_TYPE,
       ""▼型 {0} の snapshotItem を呼び出せません。このメソッドを呼び出せる型は、UNORDERED_NODE_SNAPSHOT_TYPE と ORDERED_NODE_SNAPSHOT_TYPE です。""},


  
  
  
  

  
  


  {
    ER_WRONG_DOCUMENT,
       ""▼コンテキストノードが、この XPathEvaluator にバインドされたドキュメントに所属していません。""},


  
  
  
  


  {
    ER_WRONG_NODETYPE ,
       ""▼このコンテキストノード型はサポートされていません。""},


  
  


  {
    ER_XPATH_ERROR ,
       ""▼XPath 内における未知のエラー""},

 


  

  
  


  {
    WG_LOCALE_NAME_NOT_HANDLED,
      ""format-number 関数でロケール名はまだ処理されていません。""},



  
  


  {
    WG_PROPERTY_NOT_SUPPORTED,
      ""XSL プロパティはサポートされていません: {0}""},



  
  


  {
    WG_DONT_DO_ANYTHING_WITH_NS,
      ""名前空間 {0} のプロパティ {1} には現在何も行なってはなりません""},



  
  


  {
    WG_SECURITY_EXCEPTION,
      ""XSL システムプロパティにアクセスしようとしたときに SecurityException が発生しました: {0}""},



  
  


  {
    WG_QUO_NO_LONGER_DEFINED,
      ""古い構文: quo(...) は XPath ではもう定義されていません。""},



  
  


  {
    WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
      ""XPath は nodeTest を実装するために抽出されたオブジェクトが必要です。""},



  
  


  {
    WG_FUNCTION_TOKEN_NOT_FOUND,
      ""関数トークンが見つかりません。""},



  
  


  {
    WG_COULDNOT_FIND_FUNCTION,
      ""関数 {0} が見つかりませんでした。""},



  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""ここから URL を作成できません: {0}""},



  
  


  {
    WG_EXPAND_ENTITIES_NOT_SUPPORTED,
      ""DTM パーサで -E オプションはサポートされていません""},



  
  


  {
    WG_ILLEGAL_VARIABLE_REFERENCE,
      ""コンテキストの外で、または定義なしで、変数に VariableReference が指定されました。Name = {0}""},



  
  


  {
    WG_UNSUPPORTED_ENCODING, ""サポートされないエンコーディング: {0}""},



  
  { ""ui_language"", ""ja""},
  { ""help_language"", ""ja""},
  { ""language"", ""ja""},
    { ""BAD_CODE"",
      ""createMessage のパラメータが範囲外でした""},
    { ""FORMAT_FAILED"",
      ""messageFormat 呼び出し中に例外がスローされました""},
    { ""version"", "">>>>>>> Xalan バージョン ""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""はい""},
    { ""line"", ""行番号 
    { ""column"", ""列番号 
    { ""xsldone"", ""XSLProcessor: 終了""},
    { ""xpath_option"", ""xpath オプション: ""},
    { ""optionIN"", ""   [-in inputXMLURL]""},
    { ""optionSelect"", ""   [-select xpath 式]""},
    { ""optionMatch"",
      ""   [-match 一致パターン (照合診断用)]""},
    { ""optionAnyExpr"",
      ""もしくは、ただ xpath 式が診断用ダンプを行うのみ""},
    { ""noParsermsg1"",
    ""XSL プロセスは成功しませんでした。""},
    { ""noParsermsg2"",
    ""** パーサが見つかりませんでした **""},
    { ""noParsermsg3"",
    ""クラスパスをチェックしてください。""},
    { ""noParsermsg4"",
      ""Java 用に IBM の XML パーサを備えていない場合は、これを以下からダウンロードできます。""},
    { ""noParsermsg5"",
      ""IBM's AlphaWorks: http:
  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""

  
  public static final String ERROR_HEADER = ""Error: "";

  
  public static final String WARNING_HEADER = ""Warning: "";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}
"
org.apache.xalan.transformer.StackGuard,7,1,0,8,19,0,3,7,5,0.5,157,0.0,1,0.0,0.458333333,0,0,21.14285714,4,1.4286,0,"
package org.apache.xalan.transformer;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xml.utils.ObjectStack;


public class StackGuard
{

  
  public static int m_recursionLimit = -1;
  
  TransformerImpl m_transformer;

  
  public int getRecursionLimit()
  {
    return m_recursionLimit;
  }

  
  public void setRecursionLimit(int limit)
  {
    m_recursionLimit = limit;
  }

  
  public StackGuard(TransformerImpl transformerImpl)
  {
    m_transformer = transformerImpl;
  }

  
  public int countLikeTemplates(ElemTemplate templ, int pos)
  {
  	ObjectStack elems = m_transformer.getCurrentTemplateElements();
  	int count = 1;
    for (int i = pos-1; i >= 0; i--)
    {
    	if((ElemTemplateElement)elems.elementAt(i) == templ)
    		count++;
    }
	
    return count;
  }

  
  
  private ElemTemplate getNextMatchOrNamedTemplate(int pos)
  {
  	ObjectStack elems = m_transformer.getCurrentTemplateElements();
    for (int i = pos; i >= 0; i--)
    {
    	ElemTemplateElement elem = (ElemTemplateElement) elems.elementAt(i);
    	if(null != elem)
    	{
	    	if(elem.getXSLToken() == Constants.ELEMNAME_TEMPLATE)
	    	{
	    		return (ElemTemplate)elem;
	    	}
    	}
    }
  	return null;
  }

  
  public void checkForInfinateLoop() throws TransformerException
  {
    int nTemplates = m_transformer.getCurrentTemplateElementsCount();
    if(nTemplates < m_recursionLimit)
    	return;
    	
    if(m_recursionLimit <= 0)
    	return;  
    	
    
    
    for (int i = (nTemplates - 1); i >= m_recursionLimit; i--)
    {
    	ElemTemplate template = getNextMatchOrNamedTemplate(i);
    	
    	if(null == template)
    		break;
    		
    	int loopCount = countLikeTemplates(template, i);
    	
    	if (loopCount >= m_recursionLimit)
    	{
    		
    		
    		
    		
    		
    		String idIs = XSLMessages.createMessage(((null != template.getName()) ? ""nameIs"" : ""matchPatternIs""), null);
        	Object[] msgArgs = new Object[]{ new Integer(loopCount), idIs, 
                     ((null != template.getName()) ? template.getName().toString() 
    		   : template.getMatch().getPatternString()) };
        	String msg = XSLMessages.createMessage(""recursionTooDeep"", msgArgs);

    		throw new TransformerException(msg);
    	}
    }
  }

}
"
org.apache.xml.utils.DOMOrder,1,1,0,1,1,0,1,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xml.utils;


public interface DOMOrder
{

  
  public int getUid();
}
"
org.apache.xml.serializer.EncodingInfo,1,1,0,1,2,0,1,0,1,2.0,16,0.0,0,0.0,1.0,0,0,12.0,0,0.0,0,"
package org.apache.xml.serializer;

public class EncodingInfo extends Object
{

    
    final String name;

    
    final String javaName;

    
    final int lastPrintable;

    
    public EncodingInfo(String name, String javaName, int lastPrintable)
    {

        this.name = name;
        this.javaName = javaName;
        this.lastPrintable = lastPrintable;
    }
}
"
org.apache.xalan.xsltc.dom.EmptyFilter,2,1,0,1,3,1,0,1,2,2.0,7,0.0,0,0.0,0.75,0,0,2.5,1,0.5,0,"

package org.apache.xalan.xsltc.dom;

public final class EmptyFilter implements Filter {
    public boolean test(int node) {
	return true;
    }
}
"
org.apache.xpath.functions.FuncCeiling,2,4,0,5,7,1,0,5,2,2.0,15,0.0,0,0.979591837,0.75,1,6,6.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class FuncCeiling extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(Math.ceil(m_arg0.execute(xctxt).num()));
  }
}
"
org.apache.xalan.templates.AVTPart,6,1,2,7,7,15,3,4,6,2.0,12,0.0,0,0.0,0.361111111,0,0,1.0,1,0.8333,1,"
package org.apache.xalan.templates;

import org.apache.xml.utils.FastStringBuffer;
import org.apache.xpath.XPathContext;


public abstract class AVTPart implements java.io.Serializable, XSLTVisitable
{

  
  public AVTPart(){}

  
  public abstract String getSimpleString();

  
  public abstract void evaluate(
    XPathContext xctxt, FastStringBuffer buf, int context,
      org.apache.xml.utils.PrefixResolver nsNode)
        throws javax.xml.transform.TransformerException;

  
  public void setXPathSupport(XPathContext support){}
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return false;
   }
   
  
  public abstract void fixupVariables(java.util.Vector vars, int globalsSize);


}
"
org.apache.xalan.xsltc.runtime.Attributes,7,1,0,1,8,21,0,1,7,1.0,30,1.0,1,0.0,0.5,0,0,3.0,1,0.8571,0,"

package org.apache.xalan.xsltc.runtime;

import org.apache.xalan.xsltc.DOM;
import org.xml.sax.AttributeList;

public final class Attributes implements AttributeList {
    private int _element;
    private DOM _document;

    public Attributes(DOM document, int element) {
	_element = element;
	_document = document;
    }

    public int getLength() {
	return 0;
    }

    public String getName(int i) {
	return null;
    }

    public String getType(int i) {
	return null;
    }

    public String getType(String name) {
	return null;
    }

    public String getValue(int i) {
	return null;
    }

    public String getValue(String name) {
	return null;
    }
}
"
org.apache.xalan.transformer.NodeSorter,4,1,0,9,28,2,2,8,2,0.333333333,475,0.0,1,0.0,0.583333333,0,0,117.25,1,0.75,2,"
package org.apache.xalan.transformer;

import java.text.CollationKey;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;


public class NodeSorter
{

  
  XPathContext m_execContext;

  
  Vector m_keys;  






  
  public NodeSorter(XPathContext p)
  {
    m_execContext = p;
  }

  
  public void sort(DTMIterator v, Vector keys, XPathContext support)
          throws javax.xml.transform.TransformerException
  {

    m_keys = keys;

    
    int n = v.getLength();

    
    
    
    
    
    
    Vector nodes = new Vector();

    for (int i = 0; i < n; i++)
    {
      NodeCompareElem elem = new NodeCompareElem(v.item(i));

      nodes.addElement(elem);
    }

    Vector scratchVector = new Vector();

    mergesort(nodes, scratchVector, 0, n - 1, support);

    
    for (int i = 0; i < n; i++)
    {
      v.setItem(((NodeCompareElem) nodes.elementAt(i)).m_node, i);
    }
    v.setCurrentPos(0);

    
    
    
  }

  
  int compare(
          NodeCompareElem n1, NodeCompareElem n2, int kIndex, XPathContext support)
            throws TransformerException
  {

    int result = 0;
    NodeSortKey k = (NodeSortKey) m_keys.elementAt(kIndex);

    if (k.m_treatAsNumbers)
    {
      double n1Num, n2Num;

      if (kIndex == 0)
      {
        n1Num = ((Double) n1.m_key1Value).doubleValue();
        n2Num = ((Double) n2.m_key1Value).doubleValue();
      }
      else if (kIndex == 1)
      {
        n1Num = ((Double) n1.m_key2Value).doubleValue();
        n2Num = ((Double) n2.m_key2Value).doubleValue();
      }

      
      else
      {

        
        XObject r1 = k.m_selectPat.execute(m_execContext, n1.m_node,
                                           k.m_namespaceContext);
        XObject r2 = k.m_selectPat.execute(m_execContext, n2.m_node,
                                           k.m_namespaceContext);
        n1Num = r1.num();

        
        
        
        n2Num = r2.num();
        
      }

      if ((n1Num == n2Num) && ((kIndex + 1) < m_keys.size()))
      {
        result = compare(n1, n2, kIndex + 1, support);
      }
      else
      {
        double diff;
        if (Double.isNaN(n1Num))
        {
          if (Double.isNaN(n2Num))
            diff = 0.0;
          else
            diff = -1;
        }
        else if (Double.isNaN(n2Num))
           diff = 1;
        else
          diff = n1Num - n2Num;

        
        result = (int) ((diff < 0.0)
                        ? (k.m_descending ? 1 : -1)
                        : (diff > 0.0) ? (k.m_descending ? -1 : 1) : 0);
      }
    }  
    else
    {
      CollationKey n1String, n2String;

      if (kIndex == 0)
      {
        n1String = (CollationKey) n1.m_key1Value;
        n2String = (CollationKey) n2.m_key1Value;
      }
      else if (kIndex == 1)
      {
        n1String = (CollationKey) n1.m_key2Value;
        n2String = (CollationKey) n2.m_key2Value;
      }

      
      else
      {

        
        XObject r1 = k.m_selectPat.execute(m_execContext, n1.m_node,
                                           k.m_namespaceContext);
        XObject r2 = k.m_selectPat.execute(m_execContext, n2.m_node,
                                           k.m_namespaceContext);

        n1String = k.m_col.getCollationKey(r1.str());
        n2String = k.m_col.getCollationKey(r2.str());
      }

      
      
      result = n1String.compareTo(n2String);

      
      if (k.m_caseOrderUpper)
      {
        String tempN1 = n1String.getSourceString().toLowerCase();
        String tempN2 = n2String.getSourceString().toLowerCase();

        if (tempN1.equals(tempN2))
        {

          
          result = result == 0 ? 0 : -result;
        }
      }

      
      if (k.m_descending)
      {
        result = -result;
      }
    }  

    if (0 == result)
    {
      if ((kIndex + 1) < m_keys.size())
      {
        result = compare(n1, n2, kIndex + 1, support);
      }
    }

    if (0 == result)
    {

      
      
      
      
      DTM dtm = support.getDTM(n1.m_node); 
      result = dtm.isNodeAfter(n1.m_node, n2.m_node) ? -1 : 1;

      
    }

    return result;
  }

  
  void mergesort(Vector a, Vector b, int l, int r, XPathContext support)
          throws TransformerException
  {

    if ((r - l) > 0)
    {
      int m = (r + l) / 2;

      mergesort(a, b, l, m, support);
      mergesort(a, b, m + 1, r, support);

      int i, j, k;

      for (i = m; i >= l; i--)
      {

        
        
        if (i >= b.size())
          b.insertElementAt(a.elementAt(i), i);
        else
          b.setElementAt(a.elementAt(i), i);
      }

      i = l;

      for (j = (m + 1); j <= r; j++)
      {

        
        if (r + m + 1 - j >= b.size())
          b.insertElementAt(a.elementAt(j), r + m + 1 - j);
        else
          b.setElementAt(a.elementAt(j), r + m + 1 - j);
      }

      j = r;

      int compVal;

      for (k = l; k <= r; k++)
      {

        
        if (i == j)
          compVal = -1;
        else
          compVal = compare((NodeCompareElem) b.elementAt(i),
                            (NodeCompareElem) b.elementAt(j), 0, support);

        if (compVal < 0)
        {

          
          a.setElementAt(b.elementAt(i), k);

          i++;
        }
        else if (compVal > 0)
        {

          
          a.setElementAt(b.elementAt(j), k);

          j--;
        }
      }
    }
  }

  

  
  class NodeCompareElem
  {

    
    int m_node;

    
    int maxkey = 2;

    
    
    

    
    Object m_key1Value;

    
    Object m_key2Value;

    
    NodeCompareElem(int node) throws javax.xml.transform.TransformerException
    {

      boolean tryNextKey = true;

      m_node = node;

      if (!m_keys.isEmpty())
      {
        NodeSortKey k1 = (NodeSortKey) m_keys.elementAt(0);
        XObject r = k1.m_selectPat.execute(m_execContext, node,
                                           k1.m_namespaceContext);

        if (r == null)
          tryNextKey = false;

        double d;

        if (k1.m_treatAsNumbers)
        {
          d = r.num();

          
          m_key1Value = new Double(d);
        }
        else
        {
          m_key1Value = k1.m_col.getCollationKey(r.str());
        }

        if (r.getType() == XObject.CLASS_NODESET)
        {
          
          DTMIterator ni = ((XNodeSet)r).iterRaw();
          int current = ni.getCurrentNode();
          if(DTM.NULL == current)
            current = ni.nextNode();

          
          tryNextKey = (DTM.NULL != current);

          
        }

        if (m_keys.size() > 1)
        {
          NodeSortKey k2 = (NodeSortKey) m_keys.elementAt(1);

          if (!tryNextKey)
          {
            if (k2.m_treatAsNumbers)
              m_key2Value = new Double(0.0);
            else
              m_key2Value = k2.m_col.getCollationKey("""");
          }
          else
          {
            XObject r2 = k2.m_selectPat.execute(m_execContext, node,
                                                k2.m_namespaceContext);

            if (k2.m_treatAsNumbers)
            {
              d = r2.num();
              m_key2Value = new Double(d);
            }
            else
              m_key2Value = k2.m_col.getCollationKey(r2.str());
          }
        }

        
      }  
    }
  }  
}
"
org.apache.xpath.domapi.XPathResultImpl,15,1,0,4,40,35,1,3,12,0.773809524,573,1.0,1,0.0,0.255555556,0,0,36.8,5,1.4667,1,"


package org.apache.xpath.domapi;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;

import org.w3c.dom.DOMException;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.events.Event;
import org.w3c.dom.events.EventListener;
import org.w3c.dom.events.EventTarget;
import org.w3c.dom.traversal.NodeIterator;
import org.w3c.dom.xpath.XPathException;
import org.w3c.dom.xpath.XPathResult;


public class XPathResultImpl implements XPathResult, EventListener {

	
	private XObject m_resultObj;
	
	
	private short m_resultType = ANY_TYPE; 
	
	private boolean m_isInvalidIteratorState = false;
	
    
	private Node m_contextNode;
	
	
	private NodeIterator m_iterator = null;
	
	
	private NodeList m_list = null;
	

	
	 XPathResultImpl(short type, XObject result, Node contextNode) {
		
		if (!isValidType(type)) {
            String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INVALID_XPATH_TYPE, new Object[] {new Integer(type)});       
            throw new XPathException(XPathException.TYPE_ERR,fmsg); 
		}

        
        if (null == result) {
            String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_EMPTY_XPATH_RESULT, null);       
            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,fmsg); 
        }
        
        this.m_resultObj = result;
        this.m_contextNode = contextNode;

        
        if (type == ANY_TYPE) {
            this.m_resultType = getTypeFromXObject(result);
        } else {
            this.m_resultType = type;
        }
		
        
        
        if (((m_resultType == XPathResult.ORDERED_NODE_ITERATOR_TYPE) ||
            (m_resultType == XPathResult.UNORDERED_NODE_ITERATOR_TYPE))&&
            (contextNode instanceof EventTarget)) {
                ((EventTarget)contextNode).addEventListener(""MutationEvents"",this,true);
        }
    				
        
        if ((m_resultType == ORDERED_NODE_ITERATOR_TYPE) ||
            (m_resultType == UNORDERED_NODE_ITERATOR_TYPE) ||
            (m_resultType == ANY_UNORDERED_NODE_TYPE) ||
            (m_resultType == FIRST_ORDERED_NODE_TYPE))  {
    
            try {
                m_iterator = m_resultObj.nodeset();
            } catch (TransformerException te) {
                
                String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INCOMPATIBLE_TYPES, new Object[] {getTypeString(getTypeFromXObject(m_resultObj)),getTypeString(m_resultType)});       
                throw new XPathException(XPathException.TYPE_ERR, fmsg);  
            }
    
                
                
    
    
    
    
    
        
        } else if ((m_resultType == UNORDERED_NODE_SNAPSHOT_TYPE) ||
                   (m_resultType == ORDERED_NODE_SNAPSHOT_TYPE)) {
            try {       	
        	   m_list = m_resultObj.nodelist();
            } catch (TransformerException te) {
        		
                String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INCOMPATIBLE_TYPES, new Object[] {getTypeString(getTypeFromXObject(m_resultObj)),getTypeString(m_resultType)});       
                throw new XPathException(XPathException.TYPE_ERR, fmsg);  
            }
    	}	    	 
	}

	
	public short getResultType() {
		return m_resultType;
	}

	
	public double getNumberValue() throws XPathException {
		if (getResultType() != NUMBER_TYPE) {
			String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANT_CONVERT_TO_NUMBER, new Object[] {getTypeString(m_resultType)});		
			throw new XPathException(XPathException.TYPE_ERR,fmsg); 
		} else {
			try {
			   return m_resultObj.num();
			} catch (Exception e) {
				
				throw new XPathException(XPathException.TYPE_ERR,e.getMessage());
			}
		}		
	}

	
	public String getStringValue() throws XPathException {
		if (getResultType() != STRING_TYPE) {
			String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANT_CONVERT_TO_STRING, new Object[] {m_resultObj.getTypeString()});		
			throw new XPathException(XPathException.TYPE_ERR,fmsg); 
		} else {
			try {
			   return m_resultObj.str();
			} catch (Exception e) {
				
				throw new XPathException(XPathException.TYPE_ERR,e.getMessage());
			}
		}
	}

	
	public boolean getBooleanValue() throws XPathException {
		if (getResultType() != BOOLEAN_TYPE) {
			String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANT_CONVERT_TO_BOOLEAN, new Object[] {getTypeString(m_resultType)});		
			throw new XPathException(XPathException.TYPE_ERR,fmsg);  
		} else {
			try {
			   return m_resultObj.bool();
			} catch (TransformerException e) {
				
				throw new XPathException(XPathException.TYPE_ERR,e.getMessage());
			}
		}
	}

	
	public Node getSingleNodeValue() throws XPathException {
		
		if ((m_resultType != ANY_UNORDERED_NODE_TYPE) &&
		    (m_resultType != FIRST_ORDERED_NODE_TYPE)) {
           String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANT_CONVERT_TO_SINGLENODE, new Object[] {getTypeString(m_resultType)});                        
		   throw new XPathException(XPathException.TYPE_ERR,fmsg); 
                                                                 
	    }
	
		NodeIterator result = null;
		try {
			result = m_resultObj.nodeset();
		} catch (TransformerException te) {
			throw new XPathException(XPathException.TYPE_ERR,te.getMessage());
		}
        
        if (null == result) return null;
        
        Node node = result.nextNode();
         
        
        if (isNamespaceNode(node)) {
            return new XPathNamespaceImpl(node);
        } else {
            return node;
        }        
	}

	
	public boolean getInvalidIteratorState() {
		return m_isInvalidIteratorState;
	}

	
	public int getSnapshotLength() throws XPathException {
	
		if ((m_resultType != UNORDERED_NODE_SNAPSHOT_TYPE) &&
		    (m_resultType != ORDERED_NODE_SNAPSHOT_TYPE)) {
           String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANT_GET_SNAPSHOT_LENGTH, new Object[] {getTypeString(m_resultType)});                        
		   throw new XPathException(XPathException.TYPE_ERR,fmsg); 
                                                         
	    }
			
		return m_list.getLength();
	}

	
	public Node iterateNext() throws XPathException, DOMException {
		if ((m_resultType != UNORDERED_NODE_ITERATOR_TYPE) &&
		    (m_resultType != ORDERED_NODE_ITERATOR_TYPE)) {
          String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NON_ITERATOR_TYPE, new Object[] {getTypeString(m_resultType)});                        
		  throw new XPathException(XPathException.TYPE_ERR, fmsg);  
	    }

		if (getInvalidIteratorState()) {
          String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_DOC_MUTATED, null);                        
		  throw new DOMException(DOMException.INVALID_STATE_ERR,fmsg);  
		}			 

        Node node = m_iterator.nextNode();
        
        
        if (isNamespaceNode(node)) {
            return new XPathNamespaceImpl(node);
        } else {
            return node;
        }
	}

    
	public Node snapshotItem(int index) throws XPathException {
		
		if ((m_resultType != UNORDERED_NODE_SNAPSHOT_TYPE) &&
		    (m_resultType != ORDERED_NODE_SNAPSHOT_TYPE)) {
           String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NON_SNAPSHOT_TYPE, new Object[] {getTypeString(m_resultType)});                        
           throw new XPathException(XPathException.TYPE_ERR, fmsg); 
                                                              
	    }		
        
        Node node = m_list.item(index);
        
        
        if (isNamespaceNode(node)) {
            return new XPathNamespaceImpl(node);
        } else {
            return node;
        }
	}

	
	
	public static boolean isValidType( short type ) {
		switch (type) {
			case ANY_TYPE:
			case NUMBER_TYPE:
			case STRING_TYPE:
			case BOOLEAN_TYPE:
			case UNORDERED_NODE_ITERATOR_TYPE:
			case ORDERED_NODE_ITERATOR_TYPE:
			case UNORDERED_NODE_SNAPSHOT_TYPE:
			case ORDERED_NODE_SNAPSHOT_TYPE:
			case ANY_UNORDERED_NODE_TYPE:
			case FIRST_ORDERED_NODE_TYPE: return true;
			default: return false;
		}
	}

	
	public void handleEvent(Event event) {
		
		if (event.getType().equals(""MutationEvents"")) {
			
			m_isInvalidIteratorState = true;
			
			
			((EventTarget)m_contextNode).removeEventListener(""MutationEvents"",this,true);
			
		}
	}
    
  
  public String getTypeString(int type)
  {
     switch (type) {
      case ANY_TYPE: return ""ANY_TYPE"";
      case ANY_UNORDERED_NODE_TYPE: return ""ANY_UNORDERED_NODE_TYPE"";
      case BOOLEAN_TYPE: return ""BOOLEAN"";
      case FIRST_ORDERED_NODE_TYPE: return ""FIRST_ORDERED_NODE_TYPE"";
      case NUMBER_TYPE: return ""NUMBER_TYPE"";
      case ORDERED_NODE_ITERATOR_TYPE: return ""ORDERED_NODE_ITERATOR_TYPE"";
      case ORDERED_NODE_SNAPSHOT_TYPE: return ""ORDERED_NODE_SNAPSHOT_TYPE"";
      case STRING_TYPE: return ""STRING_TYPE"";
      case UNORDERED_NODE_ITERATOR_TYPE: return ""UNORDERED_NODE_ITERATOR_TYPE"";
      case UNORDERED_NODE_SNAPSHOT_TYPE: return ""UNORDERED_NODE_SNAPSHOT_TYPE"";
      default: return ""#UNKNOWN"";
    }
  }  
  
  
  private short getTypeFromXObject(XObject object) {
      switch (object.getType()) {
        case XObject.CLASS_BOOLEAN: return BOOLEAN_TYPE;
        case XObject.CLASS_NODESET: return UNORDERED_NODE_ITERATOR_TYPE; 
        case XObject.CLASS_NUMBER: return NUMBER_TYPE;
        case XObject.CLASS_STRING: return STRING_TYPE;
        










      
        case XObject.CLASS_RTREEFRAG: return UNORDERED_NODE_ITERATOR_TYPE; 
        case XObject.CLASS_NULL: return ANY_TYPE; 
        default: return ANY_TYPE; 
    }     
    
  }  


  private boolean isNamespaceNode(Node node) {
    
     if ((null != node) && 
         (node.getNodeType() == Node.ATTRIBUTE_NODE) &&
         (node.getNodeName().startsWith(""xmlns:"") || node.getNodeName().equals(""xmlns""))) {
        return true;   
     } else {
        return false;
     }
  }
  
}
"
org.apache.xalan.templates.XUnresolvedVariableSimple,4,3,0,6,15,6,1,5,4,2.0,39,0.0,0,0.959459459,0.5,2,12,8.75,1,0.75,0,"
package org.apache.xalan.templates;

import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;



public class XUnresolvedVariableSimple extends XObject
{
  public XUnresolvedVariableSimple(ElemVariable obj)
  {
    super(obj);
  }
    
	
  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
  	Expression expr = ((ElemVariable)m_obj).getSelect().getExpression();
    XObject xobj = expr.execute(xctxt);
    xobj.allowDetachToRelease(false);
    return xobj;
  }
  
  
  public int getType()
  {
    return CLASS_UNRESOLVEDVARIABLE;
  }
  
  
  public String getTypeString()
  {
    return ""XUnresolvedVariableSimple ("" + object().getClass().getName() + "")"";
  }


}

"
org.apache.xalan.xsltc.compiler.BooleanExpr,7,3,0,17,16,1,1,16,7,0.333333333,70,1.0,0,0.922077922,0.371428571,2,8,8.857142857,2,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;


final class BooleanExpr extends Expression {
    private boolean _value;

    public BooleanExpr(boolean value) {
	_value = value;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_type = Type.Boolean;
	return _type;
    }

    public String toString() {
	return _value ? ""true()"" : ""false()"";
    }

    public boolean getValue() {
	return _value;
    }

    public boolean contextDependent() {
	return false;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }

    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	if (_value) {
	    il.append(NOP);	
	}
	else {
	    _falseList.add(il.append(new GOTO(null)));
	}
    }
}
"
org.apache.xalan.templates.AbsPathChecker,4,2,0,8,6,0,1,7,4,0.0,37,1.0,0,0.8,0.45,0,0,8.0,3,1.25,0,"
package org.apache.xalan.templates;

import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.functions.FuncCurrent;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.functions.Function;
import org.apache.xpath.operations.Variable;


public class AbsPathChecker extends XPathVisitor
{
	private boolean m_isAbs = true;
	
	
	public boolean checkAbsolute(LocPathIterator path)
	{
		m_isAbs = true;
		path.callVisitors(null, this);
		return m_isAbs;
	}
	
	
	public boolean visitFunction(ExpressionOwner owner, Function func)
	{
		if((func instanceof FuncCurrent) ||
		   (func instanceof FuncExtFunction))
			m_isAbs = false;
		return true;
	}
	
	
	public boolean visitVariableRef(ExpressionOwner owner, Variable var)
	{
		m_isAbs = false;
		return true;
	}
}

"
org.apache.xpath.res.XPATHErrorResources_de,3,4,0,1,4,1,0,1,2,1.428571429,1872,0.0,0,0.976190476,1.0,0,0,618.3333333,1,0.3333,1,"
package org.apache.xpath.res;


public class XPATHErrorResources_de extends XPATHErrorResources
{


  
  public static final int MAX_CODE = 108;  

  
  public static final int MAX_WARNING = 11;  

  
  public static final int MAX_OTHERS = 20;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;

  

  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_CURRENT_NOT_ALLOWED_IN_MATCH,
      ""Funktion current() in einem Muster nicht zulässig!""},


  
  


  {
    ER_CURRENT_TAKES_NO_ARGS,
      ""Funktion current() hat keine Argumente!""},


  
  


  {
    ER_DOCUMENT_REPLACED,
      ""Die Implementierung der Funktion document() wurde durch org.apache.xalan.xslt.FuncDocument ersetzt!""},


  
  


  {
    ER_CONTEXT_HAS_NO_OWNERDOC,
      ""Kontext hat kein Eigentümer-Dokument!""},


  
  


  {
    ER_LOCALNAME_HAS_TOO_MANY_ARGS,
      ""local-name() hat zu viele Argumente.""},


  
  


  {
    ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
      ""namespace-uri() hat zu viele Argumente.""},


  
  


  {
    ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
      ""normalize-space() hat zu viele Argumente.""},


  
  


  {
    ER_NUMBER_HAS_TOO_MANY_ARGS,
      ""number() hat zu viele Argumente.""},


  
  


  {
    ER_NAME_HAS_TOO_MANY_ARGS, ""name() hat zu viele Argumente.""},


  
  


  {
    ER_STRING_HAS_TOO_MANY_ARGS,
      ""string() hat zu viele Argumente.""},


  
  


  {
    ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
      ""string-length() hat zu viele Argumente.""},


  
  


  {
    ER_TRANSLATE_TAKES_3_ARGS,
      ""Funktion translate() hat drei Argumente!""},


  
  


  {
    ER_UNPARSEDENTITYURI_TAKES_1_ARG,
      ""Funktion unparsed-entity-uri hat ein Argument!""},


  
  


  {
    ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
      ""Namensraum-Achse noch nicht implementiert!""},


  
  


  {
    ER_UNKNOWN_AXIS, ""Unbekannte Achse: {0}""},


  
  


  {
    ER_UNKNOWN_MATCH_OPERATION, ""Unbekannte Match-Operation!""},


  
  


  {
    ER_INCORRECT_ARG_LENGTH,
      ""Argumentlänge beim Test des Knotens processing-instruction() ist nicht korrekt!""},


  
  


  {
    ER_CANT_CONVERT_TO_NUMBER,
      ""{0} kann nicht in Zahl konvertiert werden""},


  
  


  {
    ER_CANT_CONVERT_TO_NODELIST,
      ""{0} kann nicht in NodeList konvertiert werden!""},


  
  


  {
    ER_CANT_CONVERT_TO_MUTABLENODELIST,
      ""{0} kann nicht in NodeSetDTM konvertiert werden!""},


  
  


  {
    ER_CANT_CONVERT_TO_TYPE,
      ""{0} kann nicht in type


  
  


  {
    ER_EXPECTED_MATCH_PATTERN,
      ""Muster in getMatchScore erwartet!""},


  
  


  {
    ER_COULDNOT_GET_VAR_NAMED,
      ""Variable mit Namen {0} konnte nicht abgerufen werden""},


  
  


  {
    ER_UNKNOWN_OPCODE, ""FEHLER! Unbekannter Opcode: {0}""},


  
  


  {
    ER_EXTRA_ILLEGAL_TOKENS, ""Zusätzliche unzulässige Token: {0}""},


  
  


  {
    ER_EXPECTED_DOUBLE_QUOTE,
      ""Literalwert mit falschen Anführungszeichen... doppelte Anführungszeichen erwartet!""},


  
  


  {
    ER_EXPECTED_SINGLE_QUOTE,
      ""Literalwert mit falschen Anführungszeichen... einfache Anführungszeichen erwartet!""},


  
  


  {
    ER_EMPTY_EXPRESSION, ""Leerer Ausdruck!""},


  
  


  {
    ER_EXPECTED_BUT_FOUND, ""{0} erwartet, gefunden: {1}""},


  
  


  {
    ER_INCORRECT_PROGRAMMER_ASSERTION,
      ""Programmierannahme ist falsch! - {0}""},


  
  


  {
    ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
      ""Boolesches Argument (...) ist bei Xpath-Draft 19990709 nicht mehr optional.""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
      ""',' gefunden, aber davor kein Argument!""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
      ""',' gefunden, aber danach kein Argument!""},


  
  


  {
    ER_PREDICATE_ILLEGAL_SYNTAX,
      ""Syntax '..[predicate]' oder '.[predicate]' nicht zulässig. Verwenden Sie statt dessen 'self::node()[Prädikat]'.""},


  
  


  {
    ER_ILLEGAL_AXIS_NAME, ""Unzulässiger Achsenname: {0}""},


  
  


  {
    ER_UNKNOWN_NODETYPE, ""Unbekannter nodetype: {0}""},


  
  


  {
    ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
      ""Musterliteralwert ({0}) muss in Anführungszeichen eingeschlossen werden!""},


  
  


  {
    ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
      ""{0} konnte nicht als Zahl formatiert werden!""},


  
  


  {
    ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
      ""XML TransformerFactory Liaison konnte nicht erstellt werden: {0}""},


  
  


  {
    ER_DIDNOT_FIND_XPATH_SELECT_EXP,
      ""Fehler! 'select'-Ausdruck bei xpath nicht gefunden (-select).""},


  
  


  {
    ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
      ""FEHLER! ENDOP nach OP_LOCATIONPATH nicht gefunden""},


  
  


  {
    ER_ERROR_OCCURED, ""Fehler!""},


  
  


  {
    ER_ILLEGAL_VARIABLE_REFERENCE,
      ""VariableReference für eine Variable außerhalb des Kontexts oder ohne Definition angegeben!  Name = {0}""},


  
  


  {
    ER_AXES_NOT_ALLOWED,
      ""Nur die Achsen child:: und attribute:: sind in Mustern zulässig! Regel verletzende Achse = {0}""},


  
  


  {
    ER_KEY_HAS_TOO_MANY_ARGS,
      ""key() mit falscher Anzahl von Argumenten.""},


  
  


  {
    ER_COUNT_TAKES_1_ARG,
      ""Funktion count hat ein Argument!""},


  
  


  {
    ER_COULDNOT_FIND_FUNCTION, ""Funktion nicht gefunden: {0}""},


  
  


  {
    ER_UNSUPPORTED_ENCODING, ""Codierung nicht unterstützt: {0}""},


  
  


  {
    ER_PROBLEM_IN_DTM_NEXTSIBLING,
      ""Problem bei DTM in getNextSibling... Wiederherstellung wird versucht""},


  
  


  {
    ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
      ""Programmierfehler: In EmptyNodeList kann nicht geschrieben werden.""},


  
  


  {
    ER_SETDOMFACTORY_NOT_SUPPORTED,
      ""setDOMFactory wird von XpathContext nicht unterstützt!""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""Präfix muss sich in Namensraum auflösen lassen: {0}""},


  
  


  {
    ER_PARSE_NOT_SUPPORTED,
      ""Parsen von (InputSource Quelle) in XpathContext nicht unterstützt! {0} kann nicht geöffnet werden""},



  
  


  {
    ER_SAX_API_NOT_HANDLED,
      ""SAX API-Zeichen (char ch[]... werden vom DTM nicht bearbeitet!""},


  
  


  {
    ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
      ""ignorableWhitespace(char ch[]... wird vom DTM nicht bearbeitet!""},


  
  


  {
    ER_DTM_CANNOT_HANDLE_NODES,
      ""DTMLiaison kann Knoten vom Typ {0} nicht bearbeiten""},


  
  


  {
    ER_XERCES_CANNOT_HANDLE_NODES,
      ""DOM2Helper kann Knoten vom Typ {0} nicht bearbeiten""},


  
  


  {
    ER_XERCES_PARSE_ERROR_DETAILS,
      ""Fehler bei DOM2Helper.parse: SystemID - {0} Zeile - {1}""},


  
  


  {
    ER_XERCES_PARSE_ERROR, ""Fehler bei DOM2Helper.parse""},



  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""Ungültiges UTF-16-Surrogat erkannt: {0} ?""},


  
  


  {
    ER_OIERROR, ""IO-Fehler""},


  
  


  {
    ER_CANNOT_CREATE_URL, ""URL kann nicht erstellt werden für: {0}""},


  
  



  {
    ER_XPATH_READOBJECT, ""In XPath.readObject: {0}""},

  
  
  


  {
    ER_FUNCTION_TOKEN_NOT_FOUND,
      ""Funktions-Token nicht gefunden.""},

  
   
  


  {
    ER_CANNOT_DEAL_XPATH_TYPE,
       ""Bearbeitung nicht möglich von XPath vom Typ: {0}""},

  
   
  


  {
    ER_NODESET_NOT_MUTABLE,
       ""Dieses NodeSet ist nicht mutierbar""},

  
   
  


  {
    ER_NODESETDTM_NOT_MUTABLE,
       ""Dieses NodeSetDTM ist nicht mutierbar""},

  
   
  


  {
    ER_VAR_NOT_RESOLVABLE,
        ""Variable nicht auflösbar: {0}""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""Ungültiger Error-Handler""},

  
   
  


  {
    ER_PROG_ASSERT_UNKNOWN_OPCODE,
       ""Programmierannahme: Unbekannter Opcode: {0}""},

  
   
  


  {
    ER_ZERO_OR_ONE,
       ""0 oder 1""},

  
  
   
  


  {
    ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""rtf() nicht unterstützt von XRTreeFragSelectWrapper""},

  
   
  


  {
    ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""asNodeIterator() nicht unterstützt von XRTreeFragSelectWrapper""},

  
   
  


  {
    ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
       ""fsb() nicht unterstützt von XStringForChars""},

  
   
  


  {
    ER_COULD_NOT_FIND_VAR,
      ""Variable mit Namen {0} kann nicht gefunden werden""},

  
   
  


  {
    ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
      ""XStringForChars kann keine Zeichenkette als Argument haben""},

  
   
  


  {
    ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
      ""Das FastStringBuffer-Argument darf nicht Null sein""},
    
  
   
  


  {
    ER_TWO_OR_THREE,
       ""2 oder 3""},


   
  


  {
    ER_VARIABLE_ACCESSED_BEFORE_BIND,
       ""Zugriff auf Variable vor deren Bindung!""},


   
  


  {
    ER_FSB_CANNOT_TAKE_STRING,
       ""XStringForFSB darf keine Zeichenkette als Argument übergeben werden!""},


   
  


  {
    ER_SETTING_WALKER_ROOT_TO_NULL,
       ""
 !!!! Fehler! Ausgangspunkt für Walker wird auf Null gesetzt!!!""},


   
  


  {
    ER_NODESETDTM_CANNOT_ITERATE,
       ""Dieses NodeSetDTM-Element kann nicht zu einem vorausgegangenen Knoten iterieren!""},


  
  


  {
    ER_NODESET_CANNOT_ITERATE,
       ""Dieses NodeSet-Element kann nicht zu einem vorausgegangenen Knoten iterieren!""},


  
  


  {
    ER_NODESETDTM_CANNOT_INDEX,
       ""Dieses NodeSetDTM-Element kann keine Indizierung oder Zählung durchführen!""},


  
  


  {
    ER_NODESET_CANNOT_INDEX,
       ""Dieses NodeSet-Element kann keine Indizierung oder Zählung durchführen!""},


  
  


  {
    ER_CANNOT_CALL_SETSHOULDCACHENODE,
       ""setShouldCacheNodes kann nicht nach dem Aufruf von nextNode aufgerufen werden!""},


  
  


  {
    ER_ONLY_ALLOWS,
       ""Für {0} sind nur {1} Argumente zulässig.""},


  
  


  {
    ER_UNKNOWN_STEP,
       ""Programmierannahme in getNextStepPos: unbekannter stepType: {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_REL_LOC_PATH,
       ""Nach dem Token '/' bzw. '


  
  
  

  
  


  {
    ER_EXPECTED_LOC_PATH,
       ""Es wurde ein Pfad zum Speicherort erwartet. Vorgefunden wurde jedoch der folgende Token:  {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_LOC_STEP,
       ""Nach dem Token '/' bzw. '


  
  
  
  

  
  


  {
    ER_EXPECTED_NODE_TEST,
       ""Es wurde ein Knotentest erwartet, der entweder NCName:* oder QName entspricht.""},


  
  
  

  
  


  {
    ER_EXPECTED_STEP_PATTERN,
       ""Es wurde ein Schrittmuster erwartet. Vorgefunden wurde jedoch das Zeichen '/'.""},


  
  
  
 
  
  


  {
    ER_EXPECTED_REL_PATH_PATTERN,
       ""Es wurde ein relatives Pfadmuster erwartet.""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_BOOLEAN,
       ""{0} kann nicht in Datentyp ''boolean'' konvertiert werden.""},


  
  

  
  


  {
    ER_CANT_CONVERT_TO_SINGLENODE,
       ""{0} kann nicht in einen einzelnen Knoten konvertiert werden. Diese Abruffunktion ist für die Typen ANY_UNORDERED_NODE_TYPE und FIRST_ORDERED_NODE_TYPE bestimmt.""},


  
  

  
  


  {
    ER_CANT_GET_SNAPSHOT_LENGTH,
       ""Die Snapshot-Länge für diesen Typ kann nicht ermittelt werden: {0}. Diese Abruffunktion ist für die Typen UNORDERED_NODE_SNAPSHOT_TYPE und ORDERED_NODE_SNAPSHOT_TYPE bestimmt.""},


  
  


  {
    ER_NON_ITERATOR_TYPE,
       ""Es kann keine Iteration über einen nicht-iterativen Typ durchgeführt werden: {0}""},


  
  
  

  
  


  {
    ER_DOC_MUTATED,
       ""Das Dokument wurde geändert, nachdem das Ergebnis zurückgegeben wurde. Der Iterator ist ungültig.""},


  
  


  {
    ER_INVALID_XPATH_TYPE,
       ""Ungültiges XPath-Typargument: {0}""},


  
  


  {
    ER_EMPTY_XPATH_RESULT,
       ""Leeres XPath-Ergebnisobjekt""},


  
  


  {
    ER_INCOMPATIBLE_TYPES,
       ""Der zurückgegebene Typ {0} kann nicht in den angegebenen Typ umgewandelt werden: {1}""},


  
  


  {
    ER_NULL_RESOLVER,
       ""Präfix kann nicht aufgelöst werden, wenn Präfix-Resolver Null ist.""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_STRING,
       ""{0} kann nicht in eine Zeichenkette konvertiert werden.""},


  
  

  
  


  {
    ER_NON_SNAPSHOT_TYPE,
       ""snapshotItem kann nicht für diesen Typ aufgerufen werden: {0}. Diese Methode ist für die Typen UNORDERED_NODE_SNAPSHOT_TYPE und ORDERED_NODE_SNAPSHOT_TYPE bestimmt.""},


  
  
  
  

  
  


  {
    ER_WRONG_DOCUMENT,
       ""Der Kontextknoten gehört nicht zu dem Dokument, das an dieses XPathEvaluator-Element gebunden ist.""},


  
  
  
  


  {
    ER_WRONG_NODETYPE ,
       ""Der Kontextknotentyp wird nicht unterstützt.""},


  
  


  {
    ER_XPATH_ERROR ,
       ""Unbekannter Fehler in XPath.""},



  

  
  


  {
    WG_LOCALE_NAME_NOT_HANDLED,
      ""Name von locale in der Funktion format-number noch nicht bearbeitet!""},


  
  


  {
    WG_PROPERTY_NOT_SUPPORTED,
      ""XSL Property nicht unterstützt: {0}""},


  
  


  {
    WG_DONT_DO_ANYTHING_WITH_NS,
      ""Zurzeit nichts tun mit Namensraum {0} in Eigenschaft: {1}""},


  
  


  {
    WG_SECURITY_EXCEPTION,
      ""SecurityException beim Versuch des Zugriffs auf XSL-Systemeigenschaft: {0}""},


  
  


  {
    WG_QUO_NO_LONGER_DEFINED,
      ""Alte Syntax: quo(...) ist in XPath nicht mehr definiert.""},


  
  


  {
    WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
      ""XPath benötigt ein abgeleitetes Objekt zum Implementieren von nodeTest!""},


  
  


  {
    WG_FUNCTION_TOKEN_NOT_FOUND,
      ""Funktions-Token nicht gefunden.""},


  
  


  {
    WG_COULDNOT_FIND_FUNCTION,
      ""Funktion nicht gefunden: {0}""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""URL kann nicht erstellt werden aus: {0}""},


  
  


  {
    WG_EXPAND_ENTITIES_NOT_SUPPORTED,
      ""Option -E für DTM-Parser nicht unterstützt""},


  
  


  {
    WG_ILLEGAL_VARIABLE_REFERENCE,
      ""VariableReference für Variable außerhalb des Kontexts oder ohne Definition angegeben!  Name = {0}""},


  
  


  {
    WG_UNSUPPORTED_ENCODING, ""Nicht unterstützte Codierung: {0}""},


  
  { ""ui_language"", ""de""},
  { ""help_language"", ""de""},
  { ""language"", ""de""},
    { ""BAD_CODE"",
      ""Parameter für createMessage außerhalb der Grenzwerte""},
    { ""FORMAT_FAILED"",
      ""Ausnahme bei Aufruf von messageFormat""},
    { ""version"", "">>>>>>> Xalan Version ""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""ja""},
    { ""line"", ""Zeile 
    { ""column"", ""Spalte 
    { ""xsldone"", ""XSLProcessor: fertig""},
    { ""xpath_option"", ""xpath-Optionen: ""},
    { ""optionIN"", ""   [-in inputXMLURL]""},
    { ""optionSelect"", ""   [-select xpath-Ausdruck]""},
    { ""optionMatch"", ""   [-match Muster (für Trefferdiagnose)]""},
    { ""optionAnyExpr"",
      ""Oder irgendein xpath-Ausdruck führt einen Diagnose-Dump aus""},
    { ""noParsermsg1"", ""XSL Process fehlgeschlagen.""},
    { ""noParsermsg2"", ""** Parser nicht gefunden**""},
    { ""noParsermsg3"", ""Prüfen Sie Ihren classpath.""},
    { ""noParsermsg4"",
      ""Wenn Sie IBMs XML Parser for Java nicht haben, können Sie ihn von folgender Adresse herunterladen""},
    { ""noParsermsg5"", ""IBMs AlphaWorks: http:
  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""

  
  public static final String ERROR_HEADER = ""Fehler: "";

  
  public static final String WARNING_HEADER = ""Warnung: "";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""MUSTER "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}

"
org.apache.xalan.extensions.ExtensionHandlerJava,3,2,2,3,7,0,2,1,2,0.5,32,1.0,0,0.75,0.666666667,0,0,9.0,1,0.6667,1,"
package org.apache.xalan.extensions;

import java.util.Hashtable;


public abstract class ExtensionHandlerJava extends ExtensionHandler
{

  
  protected String m_className = """";

  
  private Hashtable m_cachedMethods = new Hashtable();

  
  protected ExtensionHandlerJava(String namespaceUri, String scriptLang,
                                 String className)
  {

    super(namespaceUri, scriptLang);

    m_className = className;
  }

  
  public Object getFromCache(Object methodKey, Object objType,
                             Object[] methodArgs)
  {

    
    return m_cachedMethods.get(methodKey);
  }

  
  public Object putToCache(Object methodKey, Object objType,
                           Object[] methodArgs, Object methodObj)
  {

    
    return m_cachedMethods.put(methodKey, methodObj);
  }
}
"
org.apache.xalan.xsltc.trax.Util,5,1,0,6,27,10,2,4,5,2.0,149,0.0,0,0.0,0.3,0,0,28.8,1,0.8,3,"

package org.apache.xalan.xsltc.trax;

import java.io.InputStream;
import java.io.Reader;

import javax.xml.transform.Source;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;

import org.apache.xalan.xsltc.compiler.XSLTC;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;

import org.w3c.dom.Document;
import org.xml.sax.InputSource;

public final class Util {

    public static String baseName(String name) {
	return org.apache.xalan.xsltc.compiler.util.Util.baseName(name);
    }
    
    public static String noExtName(String name) {
	return org.apache.xalan.xsltc.compiler.util.Util.noExtName(name);
    }

    public static String toJavaName(String name) {
	return org.apache.xalan.xsltc.compiler.util.Util.toJavaName(name);
    }

     

    
    
    public static InputSource getInputSource(XSLTC xsltc, Source source)
	throws TransformerConfigurationException 
    {
	InputSource input = null;

	String systemId = source.getSystemId();
	if (systemId == null) {
	    systemId = """";
	}

	try {
	    
	    if (source instanceof SAXSource) {
		final SAXSource sax = (SAXSource)source;
		input = sax.getInputSource();
		
		xsltc.setXMLReader(sax.getXMLReader());
	    }
	    
	    else if (source instanceof DOMSource) {
		final DOMSource domsrc = (DOMSource)source;
		final Document dom = (Document)domsrc.getNode();
		final DOM2SAX dom2sax = new DOM2SAX(dom);
		xsltc.setXMLReader(dom2sax);  

	        
		input = SAXSource.sourceToInputSource(source);
		if (input == null){
		    input = new InputSource(domsrc.getSystemId());
		}
	    }
	    
	    else if (source instanceof StreamSource) {
		final StreamSource stream = (StreamSource)source;
		final InputStream istream = stream.getInputStream();
		final Reader reader = stream.getReader();

		
		if (istream != null) {
		    input = new InputSource(istream);
		}
		else if (reader != null) {
		    input = new InputSource(reader);
		}
		else {
		    input = new InputSource(systemId);
		}
	    }
	    else {
		ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_SOURCE_ERR);
		throw new TransformerConfigurationException(err.toString());
	    }
	    input.setSystemId(systemId);
	}
	catch (NullPointerException e) {
 	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR,
					""TransformerFactory.newTemplates()"");
	    throw new TransformerConfigurationException(err.toString());
	}
	catch (SecurityException e) {
 	    ErrorMsg err = new ErrorMsg(ErrorMsg.FILE_ACCESS_ERR, systemId);
	    throw new TransformerConfigurationException(err.toString());
	}
	finally {
	    return input;
	}
    }

}

"
org.apache.xpath.axes.OneStepIteratorForward,6,7,1,8,16,0,3,6,4,0.2,94,1.0,0,0.97080292,0.4,4,10,14.5,3,1.1667,1,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xpath.Expression;
import org.apache.xpath.compiler.Compiler;


public class OneStepIteratorForward extends ChildTestIterator
{
  
  protected int m_axis = -1;

  
  OneStepIteratorForward(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis);
    int firstStepPos = compiler.getFirstChildPos(opPos);
    
    m_axis = WalkerFactory.getAxisFromStep(compiler, firstStepPos);
    
  }
    
  
  public OneStepIteratorForward(int axis)
  {
    super(null);
    
    m_axis = axis;
    int whatToShow = DTMFilter.SHOW_ALL;
    initNodeTest(whatToShow);
  }

  

  
  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    m_traverser = m_cdtm.getAxisTraverser(m_axis);
    
  }
  







































  
  
  protected int getNextNode()
  {
    m_lastFetched = (DTM.NULL == m_lastFetched)
                     ? m_traverser.first(m_context)
                     : m_traverser.next(m_context, m_lastFetched);
    return m_lastFetched;
  }
  
  
  public int getAxis()
  {
    return m_axis;
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(m_axis != ((OneStepIteratorForward)expr).m_axis)
  		return false;
  		
  	return true;
  }

  
}"
org.apache.xpath.objects.XNull,8,5,0,5,10,28,2,3,8,2.0,31,0.0,0,0.951048951,0.416666667,3,19,2.875,2,1.0,1,"
package org.apache.xpath.objects;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.XPathContext;


public class XNull extends XNodeSet
{

  
  public XNull()
  {
    super();
  }

  
  public int getType()
  {
    return CLASS_NULL;
  }

  
  public String getTypeString()
  {
    return ""#CLASS_NULL"";
  }

  

  public double num()
  {
    return 0.0;
  }

  
  public boolean bool()
  {
    return false;
  }

  
  public String str()
  {
    return """";
  }

  
  public int rtf(XPathContext support)
  {
    
    
    return DTM.NULL;
  }











  
  public boolean equals(XObject obj2)
  {
    return obj2.getType() == CLASS_NULL;
  }
}
"
org.apache.xalan.templates.ElemOtherwise,3,3,0,1,4,3,0,1,3,2.0,10,0.0,0,0.98989899,1.0,2,4,2.333333333,1,0.6667,1,"
package org.apache.xalan.templates;



public class ElemOtherwise extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_OTHERWISE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_OTHERWISE_STRING;
  }
}
"
org.apache.xpath.domapi.XPathExpressionImpl,2,1,0,7,16,0,1,6,1,0.333333333,137,1.0,2,0.0,0.583333333,0,0,66.0,1,0.5,1,"


package org.apache.xpath.domapi;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;

import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.xpath.XPathException;
import org.w3c.dom.xpath.XPathExpression;
import org.w3c.dom.xpath.XPathNamespace;


public class XPathExpressionImpl implements XPathExpression {

  private PrefixResolver m_resolver;      
  
  
  private XPath m_xpath;
  
    
  private Document m_doc = null;  

    
    XPathExpressionImpl(XPath xpath, Document doc) {
        m_xpath = xpath;
        m_doc = doc;
    }

    
    public Object evaluate(
        Node contextNode,
        short type,
        Object result)
        throws XPathException, DOMException {
            
        
        if (m_doc != null) {
        
            
            if ((contextNode != m_doc) && (!contextNode.getOwnerDocument().equals(m_doc))) {
                String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_WRONG_DOCUMENT, null);       
                throw new DOMException(DOMException.WRONG_DOCUMENT_ERR, fmsg);
            }
            
            
            short nodeType = contextNode.getNodeType();
            if ((nodeType != Document.DOCUMENT_NODE) &&
                (nodeType != Document.ELEMENT_NODE) && 
                (nodeType != Document.ATTRIBUTE_NODE) &&
                (nodeType != Document.TEXT_NODE) &&
                (nodeType != Document.CDATA_SECTION_NODE) &&
                (nodeType != Document.COMMENT_NODE) &&
                (nodeType != Document.PROCESSING_INSTRUCTION_NODE) &&
                (nodeType != XPathNamespace.XPATH_NAMESPACE_NODE)) {
                    String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_WRONG_NODETYPE, null);       
                    throw new DOMException(DOMException.NOT_SUPPORTED_ERR, fmsg);
            }
        }
            
        
        
        
        if (!XPathResultImpl.isValidType(type)) {
            String fmsg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_INVALID_XPATH_TYPE, new Object[] {new Integer(type)});       
            throw new XPathException(XPathException.TYPE_ERR,fmsg); 
        }
        
        
        XPathContext xpathSupport = new XPathContext();
        
        
        if (null != m_doc) {
            xpathSupport.getDTMHandleFromNode(m_doc);
        }

        XObject xobj = null;
        try {
            xobj = m_xpath.execute(xpathSupport, contextNode, m_resolver );         
        } catch (TransformerException te) {
            
            throw new XPathException(XPathException.INVALID_EXPRESSION_ERR,te.getMessageAndLocation()); 
        }

        
        
        
        
        return new XPathResultImpl(type,xobj,contextNode);
    }

}
"
org.apache.xalan.trace.TraceListenerEx,1,1,0,4,1,0,2,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"
package org.apache.xalan.trace;


public interface TraceListenerEx extends TraceListener
{

  
  public void selectEnd(EndSelectionEvent ev) throws javax.xml.transform.TransformerException;

}
"
org.apache.xpath.functions.FuncPosition,5,3,0,9,17,8,1,8,5,0.5,92,1.0,0,0.904761905,0.4,1,6,17.2,8,2.4,1,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.SubContextList;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class FuncPosition extends Function
{
  private boolean m_isTopLevel;
  
  
  public void postCompileStep(Compiler compiler)
  {
    m_isTopLevel = compiler.getLocationPathDepth() == -1;
  }

  
  public int getPositionInContextNodeList(XPathContext xctxt)
  {

    
    
    SubContextList iter = m_isTopLevel ? null : xctxt.getSubContextList();

    if (null != iter)
    {
      int prox = iter.getProximityPosition(xctxt);
 
      
      return prox;
    }

    DTMIterator cnl = xctxt.getContextNodeList();

    if (null != cnl)
    {
      int n = cnl.getCurrentNode();
      if(n == DTM.NULL)
      {
        if(cnl.getCurrentPos() == 0)
          return 0;
          
        
        
        
        
        
        try 
        { 
          cnl = cnl.cloneWithReset(); 
        }
        catch(CloneNotSupportedException cnse)
        {
          throw new org.apache.xml.utils.WrappedRuntimeException(cnse);
        }
        int currentNode = xctxt.getContextNode();
        
        while(DTM.NULL != (n = cnl.nextNode()))
        {
          if(n == currentNode)
            break;
        }
      }
      
      
      return cnl.getCurrentPos();
    }

    
    return -1;
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    double pos = (double) getPositionInContextNodeList(xctxt);
    
    return new XNumber(pos);
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }
}
"
org.apache.xpath.res.XPATHErrorResources_es,3,4,0,1,4,1,0,1,2,1.428571429,1872,0.0,0,0.976190476,1.0,0,0,618.3333333,1,0.3333,1,"
package org.apache.xpath.res;


public class XPATHErrorResources_es extends XPATHErrorResources
{


 
  public static final int MAX_CODE = 108;  

  
  public static final int MAX_WARNING = 11;  

  
  public static final int MAX_OTHERS = 20;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  

  public static final Object[][] contents = {
  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_CURRENT_NOT_ALLOWED_IN_MATCH,
      ""Esta función no se permite en un patrón de búsqueda""},


  
  


  {
    ER_CURRENT_TAKES_NO_ARGS,
      ""Esta función no acepta argumentos.""},


  
  


  {
    ER_DOCUMENT_REPLACED,
      ""la implementación de la función del documento() se ha sustituido por org.apache.xalan.xslt.FuncDocument.!""},


  
  


  {
    ER_CONTEXT_HAS_NO_OWNERDOC,
      ""el contexto no tiene documento propietario!""},


  
  


  {
    ER_LOCALNAME_HAS_TOO_MANY_ARGS,
      ""el nombre local tiene demasiados argumentos.""},


  
  


  {
    ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
      ""el URI del espacio de nombre tiene demasiados argumentos.""},


  
  


  {
    ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
      ""el espacio estándar tiene demasiados argumentos.""},


  
  


  {
    ER_NUMBER_HAS_TOO_MANY_ARGS,
      ""el número tiene demasiados argumentos.""},


  
  


  {
    ER_NAME_HAS_TOO_MANY_ARGS, ""el nombre tiene demasiados argumentos.""},


  
  


  {
    ER_STRING_HAS_TOO_MANY_ARGS,
      ""la cadena tiene demasiados argumentos.""},


  
  


  {
    ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
      ""la longitud de la cadena tiene demasiados argumentos.""},


  
  


  {
    ER_TRANSLATE_TAKES_3_ARGS,
      ""La función de traducción utiliza tres argumentos!""},


  
  


  {
    ER_UNPARSEDENTITYURI_TAKES_1_ARG,
      ""La función unparsed-entity-uri debería utilizar un argumento!""},


  
  


  {
    ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
      ""no se ha implementado todavía el eje de espacio de nombre!""},


  
  


  {
    ER_UNKNOWN_AXIS, ""eje desconocido: {0}""},


  
  


  {
    ER_UNKNOWN_MATCH_OPERATION, ""operación de búsqueda desconocida!""},


  
  


  {
    ER_INCORRECT_ARG_LENGTH,
      ""La longitud de los argumentos de la prueba del nodo de instrucción de procesamiento () es incorrecta!""},


  
  


  {
    ER_CANT_CONVERT_TO_NUMBER,
      ""No se puede convertir {0} en un número.""},


  
  


  {
    ER_CANT_CONVERT_TO_NODELIST,
      ""No se puede convertir {0} en una NodeList.""},


  
  


  {
    ER_CANT_CONVERT_TO_MUTABLENODELIST,
      ""No se puede convertir {0} en un NodeSetDTM!.""},


  
  


  {
    ER_CANT_CONVERT_TO_TYPE,
      ""No se puede convertir {0} en un tipo


  
  


  {
    ER_EXPECTED_MATCH_PATTERN,
      ""Patrón de búsqueda esperado en getMatchScore!""},


  
  


  {
    ER_COULDNOT_GET_VAR_NAMED,
      ""No se ha podido obtener una variable con el nombre {0}""},


  
  


  {
    ER_UNKNOWN_OPCODE, ""ERROR! Código de operación desconocido: {0}""},


  
  


  {
    ER_EXTRA_ILLEGAL_TOKENS, ""Tokens adicionales no permitidos: {0}""},


  
  


  {
    ER_EXPECTED_DOUBLE_QUOTE,
      ""error de entrecomillado... debe usar comillas dobles!""},


  
  


  {
    ER_EXPECTED_SINGLE_QUOTE,
      ""error de entrecomillado... debe usar comillas sencillas!""},


  
  


  {
    ER_EMPTY_EXPRESSION, ""Expresión vacía!""},


  
  


  {
    ER_EXPECTED_BUT_FOUND, ""Esperados {0}, pero encontrados: {1}""},


  
  


  {
    ER_INCORRECT_PROGRAMMER_ASSERTION,
      ""El aserto del programador es incorrecto! - {0}""},


  
  


  {
    ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
      ""El argumento booleano(...) ya no es opcional con el borrador 19990709 Xpath.""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
      ""Se ha encontrado ',' pero no hay ningún argumento anterior!""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
      ""Se ha encontrado ',' pero no hay ningún argumento posterior!""},


  
  


  {
    ER_PREDICATE_ILLEGAL_SYNTAX,
      ""La sintaxis '..[predicate]' no es válida.  Sustituir por 'self::node()[predicate]'.""},


  
  


  {
    ER_ILLEGAL_AXIS_NAME, ""nombre de eje no válido: {0}""},


  
  


  {
    ER_UNKNOWN_NODETYPE, ""Tipo de nodo desconocido: {0}""},


  
  


  {
    ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
      ""La cadena literal del patró ({0}) requiere entrecomillado!""},


  
  


  {
    ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
      ""No se ha podido dar formato numérico a {0}!""},


  
  


  {
    ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
      ""No se ha podido crear un vínculo XML TransformerFactory: {0}""},


  
  


  {
    ER_DIDNOT_FIND_XPATH_SELECT_EXP,
      ""Error! No se ha encontrado la expresión de selección de xpath (-seleccionar).""},


  
  


  {
    ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
      ""ERROR! No se ha podido encontra ENDOP después de OP_LOCATIONPATH.""},


  
  


  {
    ER_ERROR_OCCURED, ""Se ha producido un error!""},


  
  


  {
    ER_ILLEGAL_VARIABLE_REFERENCE,
      ""Referencia variable atribuida a una variable fuera de contexto o sin definición! Nombre = {0}""},


  
  


  {
    ER_AXES_NOT_ALLOWED,
      ""Sólo se permiten los ejes child:: y attribute:: en los patrones de búsqueda!  Ejes incompatibles = {0}""},


  
  


  {
    ER_KEY_HAS_TOO_MANY_ARGS,
      ""El número de argumentos de la clave es incorrecto.""},


  
  


  {
    ER_COUNT_TAKES_1_ARG,
      ""La función de cómputo debería utilizar un argumento!""},


  
  


  {
    ER_COULDNOT_FIND_FUNCTION, ""No se ha podido encontrar la función: {0}""},


  
  


  {
    ER_UNSUPPORTED_ENCODING, ""Codificación no admitida: {0}""},


  
  


  {
    ER_PROBLEM_IN_DTM_NEXTSIBLING,
      ""Se ha producido un error en DTM en getNextSibling... intentando restablecer.""},


  
  


  {
    ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
      ""Error del programador: no se puede escribir en EmptyNodeList.""},


  
  


  {
    ER_SETDOMFACTORY_NOT_SUPPORTED,
      ""XPathContext no admite setDOMFactory!""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""El prefijo debe convertirse en un espacio de nombre: {0}""},


  
  


  {
    ER_PARSE_NOT_SUPPORTED,
      ""análisis sintáctico (fuente InputSource source) no admitido! No se puede abri {0}""},


  
  


  {
    ER_SAX_API_NOT_HANDLED,
      ""Caracteres SAX API no manejados por DTM!""},


  
  


  {
    ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
      ""Espacio en blanco que puede ignorarse no procesado por DTM!""},


  
  


  {
    ER_DTM_CANNOT_HANDLE_NODES,
      ""DTMLiaison no puede manejar nodos de tipo {0}""},


  
  


  {
    ER_XERCES_CANNOT_HANDLE_NODES,
      ""DOM2Helper no puede manejar nodos de tipo {0}""},


  
  


  {
    ER_XERCES_PARSE_ERROR_DETAILS,
      ""Error DOM2Helper.parse: ID del sistema - {0} línea - {1}""},


  
  


  {
    ER_XERCES_PARSE_ERROR, ""Error DOM2Helper.parse.""},


  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""Se ha detectado un sustituto UTF-16 no válido: {0} ?""},


  
  


  {
    ER_OIERROR, ""Error de entrada/salida.""},


  
  


  {
    ER_CANNOT_CREATE_URL, ""No se puede crear url para: {0}""},


  
  


  {
    ER_XPATH_READOBJECT, ""En XPath.readObject: {0}""},

  
  
  


  {
    ER_FUNCTION_TOKEN_NOT_FOUND,
      ""No se ha encontrado el token de función.""},

  
   
  


  {
    ER_CANNOT_DEAL_XPATH_TYPE,
       ""No puede manejar el tipo XPath: {0}""},

  
   
  


  {
    ER_NODESET_NOT_MUTABLE,
       ""Este NodeSet es inmutable.""},

  
   
  


  {
    ER_NODESETDTM_NOT_MUTABLE,
       "" Este NodeSetDTM es inmutable.""},

  
   
  


  {
    ER_VAR_NOT_RESOLVABLE,
        ""Variable no convertible: {0}""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""Manejador de errores nulo.""},

  
   
  


  {
    ER_PROG_ASSERT_UNKNOWN_OPCODE,
       ""Aserto del programador: código de operación desconocido: {0}""},

  
   
  


  {
    ER_ZERO_OR_ONE,
       ""0 ór 1""},

  
    
   
  


  {
    ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""rtf() no admitido por XRTreeFragSelectWrapper""},

  
   
  


  {
    ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""asNodeIterator() no admitido por XRTreeFragSelectWrapper""},

  
   
  


  {
    ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
       ""fsb() no admitido para XStringForChars""},

  
   
  


  {
    ER_COULD_NOT_FIND_VAR,
      ""No se ha podido encontrar variable con el nombre {0}""},

  
   
  


  {
    ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
      ""XStringForChars no puede utilizar una cadena para un argumento""},

  
   
  


  {
    ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
      ""El argumento FastStringBuffer no puede ser nulo""},
    
   
   
  


  {
    ER_TWO_OR_THREE,
       ""2 o 3""},


   
  


  {
    ER_VARIABLE_ACCESSED_BEFORE_BIND,
       ""Se ha accedido a la variable antes de vincularla!""},


   
  


  {
    ER_FSB_CANNOT_TAKE_STRING,
       ""¡XStringForFSB no puede utilizar una cadena como argumento!""},


   
  


  {
    ER_SETTING_WALKER_ROOT_TO_NULL,
       ""
 !!!! ¡Error! Se está estableciendo la raíz de un walker a nulo""},


   
  


  {
    ER_NODESETDTM_CANNOT_ITERATE,
       ""¡Este NodeSetDTM no puede hacer iteraciones a un nodo previo!""},


  
  


  {
    ER_NODESET_CANNOT_ITERATE,
       ""¡Este NodeSet no puede hacer iteraciones a un nodo previo!""},


  
  


  {
    ER_NODESETDTM_CANNOT_INDEX,
       ""¡Este NodeSetDTM no puede generar índices o funciones de contador!""},


  
  


  {
    ER_NODESET_CANNOT_INDEX,
       ""¡Este NodeSet no puede generar índices ni funciones de contador!""},


  
  


  {
    ER_CANNOT_CALL_SETSHOULDCACHENODE,
      ""No se puede invocar setShouldCacheNodes después de haber invocado nextNode""},


  
  


  {
    ER_ONLY_ALLOWS,
       ""{0} sólo permite {1} argumentos""},


  
  


  {
    ER_UNKNOWN_STEP,
       ""Confirmación del programador en getNextStepPos: stepType desconocido: {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_REL_LOC_PATH,
       ""Se esperaba una ruta de destino relativa después del token '/' o '


  
  
  

  
  


  {
    ER_EXPECTED_LOC_PATH,
       ""Se esperaba una ruta de destino, pero se ha encontrado el siguiente token:  {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_LOC_STEP,
       ""Se esperaba un paso de ubicación después de '/' o '


  
  
  
  

  
  


  {
    ER_EXPECTED_NODE_TEST,
       ""Se esperaba una prueba de nodo coincidente con NCName:* o con QName.""},


  
  
  

  
  


  {
    ER_EXPECTED_STEP_PATTERN,
       ""Se esperaba un patrón de pasos, pero se ha encontrado '/' .""},


  
  
  
 
  
  


  {
    ER_EXPECTED_REL_PATH_PATTERN,
       ""Se esperaba un patrón de pasos relativo.""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_BOOLEAN,
       ""No se puede convertir {0} en una instancia booleana.""},


  
  

  
  


  {
    ER_CANT_CONVERT_TO_SINGLENODE,
       ""No se puede convertir {0} en un nodo único. Este método getter se aplica a los tipos ANY_UNORDERED_NODE_TYPE y FIRST_ORDERED_NODE_TYPE.""},


  
  

  
  


  {
    ER_CANT_GET_SNAPSHOT_LENGTH,
       ""No se puede obtener la longitud de la snapshot del tipo: {0}. Este método getter se aplica a los tipos UNORDERED_NODE_SNAPSHOT_TYPE y ORDERED_NODE_SNAPSHOT_TYPE.""},


  
  


  {
    ER_NON_ITERATOR_TYPE,
       ""No se puede hacer iteraciones en un tipo que no permite iteraciones: {0}""},


  
  
  

  
  


  {
    ER_DOC_MUTATED,
       ""El documento ha cambiado desde que se envió el resultado. La iteración no es válida.""},


  
  


  {
    ER_INVALID_XPATH_TYPE,
       ""Argumento de tipo XPath no válido: {0}""},


  
  


  {
    ER_EMPTY_XPATH_RESULT,
       ""Objeto resultado XPath vacío""},


  
  


  {
    ER_INCOMPATIBLE_TYPES,
       ""El tipo devuelto: {0} no se puede transformar en el tipo especificado: {1}""},


  
  


  {
    ER_NULL_RESOLVER,
       ""No se puede resolver el prefijo con un convertidor de prefijo nulo.""},


  
  
  

  
  


  {
    ER_CANT_CONVERT_TO_STRING,
       ""No se puede convertir {0} en una cadena.""},


  
  

  
  


  {
    ER_NON_SNAPSHOT_TYPE,
       ""No se puede invocar snapshotItem en el tipo: {0}. Este método se aplica a los tipos UNORDERED_NODE_SNAPSHOT_TYPE y ORDERED_NODE_SNAPSHOT_TYPE.""},


  
  
  
  

  
  


  {
    ER_WRONG_DOCUMENT,
       ""El nodo de contexto no pertenece al documento vinculado a este XPathEvaluator.""},


  
  
  
  


  {
    ER_WRONG_NODETYPE ,
       ""El tipo de nodo de contexto no es compatible.""},


  
  


  {
    ER_XPATH_ERROR ,
       ""Error desconocido en XPath.""},



  

  
  


  {
    WG_LOCALE_NAME_NOT_HANDLED,
      ""No se ha manejado todavía el nombre locale en la función!""},


  



  {
    WG_PROPERTY_NOT_SUPPORTED,
      ""Propiedad XSL no admitida: {0}""},


  
  


  {
    WG_DONT_DO_ANYTHING_WITH_NS,
      ""Actualmente el espacio de nombres {0} en propiedad debe dejarse como está: {1}""},


  
  


  {
    WG_SECURITY_EXCEPTION,
      ""SecurityException al intentar tener acceso a la propiedad del sistema XSL: {0}""},


  
  


  {
    WG_QUO_NO_LONGER_DEFINED,
      ""Sintaxis antigua: quo(...) ya no viene definida enis XPath""},


  
  


  {
    WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
      ""XPath requiere un objeto derivado para ejecutar nodeTest!""},


  
  


  {
    WG_FUNCTION_TOKEN_NOT_FOUND,
      ""No se ha encontrado el token de la función""},


  
  


  {
    WG_COULDNOT_FIND_FUNCTION,
      ""No se ha podido encontrar la función: {0}""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""No se puede crear URL desde: {0}""},


  
  


  {
    WG_EXPAND_ENTITIES_NOT_SUPPORTED,
      ""opción -E no admitida para analizador sintáctico DTM""},


  
  


  {
    WG_ILLEGAL_VARIABLE_REFERENCE,
      ""VariableReference atribuida a una variable fuera de contexto o sin definición. Nombre = {0}""},


  
  


  {
    ER_UNSUPPORTED_ENCODING, ""Codificación no admitida: {0}""},


  
  { ""ui_language"", ""es""},
  { ""help_language"", ""es""},
  { ""language"", ""es""},
    { ""BAD_CODE"",
      ""El parámetro para createMessage estaba fuera de los límites""},
    { ""FORMAT_FAILED"", ""Excepción generada la llamada messageFormat""},
    { ""version"", "">>>>>>> Versión Xalan ""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""sí""},
    { ""line"", ""Línea 
    { ""column"", ""Columna 
    { ""xsldone"", ""XSLProcessor: hecho""},
    { ""xpath_option"", ""opciones xpath: ""},
    { ""optionIN"", ""   [-in inputXMLURL]""},
    { ""optionSelect"", ""   [- seleccionar expresión xpath]""},
    { ""optionMatch"",
      ""   [-match coincidir patrón de búsqueda (para diagnósticos de búsqueda)]""},
    { ""optionAnyExpr"",
      ""O una expresión xpath realizará un volcado de diagnóstico""},
    { ""noParsermsg1"", ""Ha fallado el proceso XSLl""},
    { ""noParsermsg2"", ""** No se ha podido encontrar analizador sintáctico **""},
    { ""noParsermsg3"", ""Compruebe el classpath""},
    { ""noParsermsg4"",
      ""Si no tiene el analizador sintáctico XML para Java de IBM, puede descargarlo desde""},
    { ""noParsermsg5"",
      ""AlphaWorks de IBM: http:
  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_RESOURCES =
  ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""

  
  public static final String ERROR_HEADER = ""Error: "";

  
  public static final String WARNING_HEADER = ""Advertencia: "";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATRÓN "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}


"
org.apache.xpath.res.XPATHErrorResources_en,1,4,0,1,2,0,0,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xpath.res;



public class XPATHErrorResources_en extends XPATHErrorResources
{
}
"
org.apache.xalan.xsltc.runtime.output.OutputBuffer,4,1,0,2,4,6,2,0,4,2.0,4,0.0,0,0.0,0.4,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.runtime.output;

interface OutputBuffer {

    public String close();
    public OutputBuffer append(char ch);
    public OutputBuffer append(String s);
    public OutputBuffer append(char[] s, int from, int to);

}


"
org.apache.xalan.extensions.ExtensionHandler,9,1,3,12,18,34,7,5,6,0.95,92,0.8,0,0.0,0.319444444,0,0,8.666666667,1,0.7778,1,"
package org.apache.xalan.extensions;

import java.io.IOException;
import java.lang.reflect.Method;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.functions.FuncExtFunction;


public abstract class ExtensionHandler
{

  
  protected String m_namespaceUri; 

  
  protected String m_scriptLang;

  
  private static final Object NO_OBJS[] = new Object[0];

  
  private static Method getCCL;

  static
  {
    try
    {
      getCCL = Thread.class.getMethod(""getContextClassLoader"", new Class[0]);
    }
    catch (Exception e)
    {
      getCCL = null;
    }
  }

  
  public static Class getClassForName(String className)
      throws ClassNotFoundException
  {
    Class result = null;
    
    
    if(className.equals(""org.apache.xalan.xslt.extensions.Redirect""))
      className = ""org.apache.xalan.lib.Redirect"";
      
    if (getCCL != null)
    {
      try {
        ClassLoader contextClassLoader =
                              (ClassLoader) getCCL.invoke(Thread.currentThread(), NO_OBJS);
        result = contextClassLoader.loadClass(className);
      }
      catch (ClassNotFoundException cnfe)
      {
        result = Class.forName(className);
      }
      catch (Exception e)
      {
        getCCL = null;
        result = Class.forName(className);
      }
    }

    else
       result = Class.forName(className);

    return result;
 }


  
  protected ExtensionHandler(String namespaceUri, String scriptLang)
  {
    m_namespaceUri = namespaceUri;
    m_scriptLang = scriptLang;
  }

  
  public abstract boolean isFunctionAvailable(String function);

  
  public abstract boolean isElementAvailable(String element);

  
  public abstract Object callFunction(
    String funcName, Vector args, Object methodKey,
      ExpressionContext exprContext) throws TransformerException;

  
  public abstract Object callFunction(
    FuncExtFunction extFunction, Vector args,
      ExpressionContext exprContext) throws TransformerException;

  
  public abstract void processElement(
    String localPart, ElemTemplateElement element, TransformerImpl transformer,
      Stylesheet stylesheetTree, Object methodKey) throws TransformerException, IOException;
}
"
org.apache.xml.dtm.ref.NodeLocator,6,1,0,1,11,0,1,0,6,0.65,57,1.0,0,0.0,0.444444444,0,0,7.833333333,1,0.8333,0,"

package org.apache.xml.dtm.ref;

import javax.xml.transform.SourceLocator;


public class NodeLocator implements SourceLocator
{
  protected String m_publicId;
  protected String m_systemId;
  protected int m_lineNumber;
  protected int m_columnNumber;

  
  public NodeLocator(String publicId, String systemId,
                     int lineNumber, int columnNumber)
  {
    this.m_publicId = publicId;
    this.m_systemId = systemId;
    this.m_lineNumber = lineNumber;
    this.m_columnNumber = columnNumber;
  }

  
  public String getPublicId()
  {
    return m_publicId;
  }

  
  public String getSystemId()
  {
    return m_systemId;
  }

  
  public int getLineNumber()
  {
    return m_lineNumber;
  }

  
  public int getColumnNumber()
  {
    return m_columnNumber;
  }

  
  public String toString()
  {
    return ""file '"" + m_systemId
      + ""', line #"" + m_lineNumber
      + "", column #"" + m_columnNumber;
  }
}
"
org.apache.xml.dtm.DTMFilter,2,1,0,6,2,1,6,0,2,2.0,17,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xml.dtm;


public interface DTMFilter
{

  
  
  

  
  public static final int SHOW_ALL = 0xFFFFFFFF;

  
  public static final int SHOW_ELEMENT = 0x00000001;

  
  public static final int SHOW_ATTRIBUTE = 0x00000002;

  
  public static final int SHOW_TEXT = 0x00000004;

  
  public static final int SHOW_CDATA_SECTION = 0x00000008;

  
  public static final int SHOW_ENTITY_REFERENCE = 0x00000010;

  
  public static final int SHOW_ENTITY = 0x00000020;

  
  public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040;

  
  public static final int SHOW_COMMENT = 0x00000080;

  
  public static final int SHOW_DOCUMENT = 0x00000100;

  
  public static final int SHOW_DOCUMENT_TYPE = 0x00000200;

  
  public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400;

  
  public static final int SHOW_NOTATION = 0x00000800;
  
  
  public static final int SHOW_NAMESPACE = 0x00001000;

  
  public static final int SHOW_BYFUNCTION = 0x00010000;

  
  public short acceptNode(int nodeHandle, int whatToShow);
  
  
  public short acceptNode(int nodeHandle, int whatToShow, int expandedName);
 
}
"
org.apache.xalan.extensions.ExtensionHandlerExsltFunction,9,2,0,15,33,28,0,15,7,0.625,221,1.0,2,0.461538462,0.325,1,1,23.22222222,8,2.2222,1,"
package org.apache.xalan.extensions;

import java.io.IOException;
import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemExsltFuncResult;
import org.apache.xalan.templates.ElemExsltFunction;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;
import org.apache.xpath.ExpressionNode;
import org.apache.xpath.XPathContext;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class ExtensionHandlerExsltFunction extends ExtensionHandler
{
  private String m_namespace;
  private StylesheetRoot m_stylesheet;
  private static final QName RESULTQNAME = 
                  new QName(Constants.S_EXSLT_FUNCTIONS_URL,
                            Constants.EXSLT_ELEMNAME_FUNCRESULT_STRING);
    
  public ExtensionHandlerExsltFunction(String ns, StylesheetRoot stylesheet)
  {
    super(ns, ""xml""); 
    m_namespace = ns;
    m_stylesheet = stylesheet;
  }
  
  
  public void processElement(
    String localPart, ElemTemplateElement element, TransformerImpl transformer,
    Stylesheet stylesheetTree, Object methodKey) throws TransformerException, IOException
  {}
  
  
  public ElemExsltFunction getFunction(String funcName)
  {
    QName qname = new QName(m_namespace, funcName);
    ElemTemplate templ = m_stylesheet.getTemplateComposed(qname);
    if (templ != null && templ instanceof ElemExsltFunction)
      return (ElemExsltFunction) templ;
    else
      return null;    
  }
  
  
    
  public boolean isFunctionAvailable(String funcName)
  {
    return getFunction(funcName)!= null;
  }
    
   
  public boolean isElementAvailable(String elemName)
  {
    if (!(new QName(m_namespace, elemName).equals(RESULTQNAME)))
    {
      return false;
    }
    else
    {
      ElemTemplateElement elem = m_stylesheet.getFirstChildElem();
      while (elem != null && elem != m_stylesheet)
      {
        if (elem instanceof ElemExsltFuncResult && ancestorIsFunction(elem))
          return true;
        ElemTemplateElement  nextElem = elem.getFirstChildElem();
        if (nextElem == null)
          nextElem = elem.getNextSiblingElem();
        if (nextElem == null)
          nextElem = elem.getParentElem();
        elem = nextElem;
      }
    }
    return false;
  }

  
  private boolean ancestorIsFunction(ElemTemplateElement child)
  {
    while (child.getParentElem() != null 
           && !(child.getParentElem() instanceof StylesheetRoot))
    {
      if (child.getParentElem() instanceof ElemExsltFunction)
        return true;
      child = child.getParentElem();      
    }
    return false;
  }

  
  public Object callFunction(
      String funcName, Vector args, Object methodKey,
      ExpressionContext exprContext) throws TransformerException
  {
    throw new TransformerException(""This method should not be called."");
  }

  
  public Object callFunction(FuncExtFunction extFunction,
                             Vector args,
                             ExpressionContext exprContext)
      throws TransformerException
  {
    
    ExpressionNode parent = extFunction.exprGetParent();
    while (parent != null && !(parent instanceof ElemTemplate))
    {
      parent = parent.exprGetParent();
    }
    
    ElemTemplate callerTemplate = (parent != null) ? (ElemTemplate)parent: null;
    
    XObject[] methodArgs;
    methodArgs = new XObject[args.size()];
    try
    {
      for (int i = 0; i < methodArgs.length; i++)
      {
        methodArgs[i] =  XObject.create(args.elementAt(i));
      }
      
      ElemExsltFunction elemFunc = getFunction(extFunction.getFunctionName());
      XPathContext context = exprContext.getXPathContext();
      TransformerImpl transformer = (TransformerImpl)context.getOwnerObject();
      
      
      if (callerTemplate != null)
        elemFunc.setCallerFrameSize(callerTemplate.m_frameSize);
      else
        elemFunc.setCallerFrameSize(0);
      
      elemFunc.execute(transformer, methodArgs);
      
      XObject val = new XString(""""); 
      if (elemFunc.isResultSet())
      {
        val = elemFunc.getResult();
        elemFunc.clearResult();
      }
              
      return val;
    }
    catch (TransformerException e)
    {
      throw e;
    }
    catch (Exception e)
    {
      throw new TransformerException(e);
    }    
  }
  
}
"
org.apache.xalan.xsltc.compiler.NumberCall,3,4,0,11,15,3,0,11,3,2.0,59,0.0,0,0.979591837,0.444444444,3,13,18.66666667,3,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class NumberCall extends FunctionCall {

    public NumberCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (argumentCount() > 0) {
	    argument().typeCheck(stable);
	}
	return _type = Type.Real;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	Type targ;
	
	if (argumentCount() == 0) {
	    il.append(methodGen.loadContextNode());
	    targ = Type.Node;
	}
	else {
	    final Expression arg = argument();
	    arg.translate(classGen, methodGen);
	    arg.startResetIterator(classGen, methodGen);
	    targ = arg.getType();
	}

	if (!targ.identicalTo(Type.Real)) {
	    targ.translateTo(classGen, methodGen, Type.Real);
	}
    }
}
"
org.apache.xalan.processor.ProcessorNamespaceAlias,2,4,0,6,17,1,1,5,1,2.0,65,0.0,0,0.995260664,0.625,3,4,31.5,1,0.5,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.NamespaceAlias;
import org.xml.sax.Attributes;


class ProcessorNamespaceAlias extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    NamespaceAlias na = new NamespaceAlias(handler.nextUid());

    setPropertiesFromAttributes(handler, rawName, attributes, na);
    String prefix = na.getStylesheetPrefix();
    if(prefix.equals(""#default""))
    {
      prefix = """";
      na.setStylesheetPrefix(prefix);
    }
    String stylesheetNS = handler.getNamespaceForPrefix(prefix);
    na.setStylesheetNamespace(stylesheetNS);
    prefix = na.getResultPrefix();
    if(prefix.equals(""#default""))
    {
      prefix = """";
      na.setResultPrefix(prefix);
    }
    String resultNS = handler.getNamespaceForPrefix(prefix);
    na.setResultNamespace(resultNS);
    handler.getStylesheet().setNamespaceAlias(na);
    handler.getStylesheet().appendChild(na);
  }
}
"
org.apache.xalan.xsltc.compiler.util.MultiHashtable,3,3,0,2,11,3,2,0,3,2.0,61,0.0,0,0.95,0.833333333,1,2,19.33333333,5,2.3333,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Hashtable;
import java.util.Vector;

public final class MultiHashtable extends Hashtable {
    public Object put(Object key, Object value) {
	Vector vector = (Vector)get(key);
	if (vector == null)
	    super.put(key, vector = new Vector());
	vector.add(value);
	return vector;
    }
	
    public Object maps(Object from, Object to) {
	if (from == null) return null;
	final Vector vector = (Vector) get(from);
	if (vector != null) {
	    final int n = vector.size();
	    for (int i = 0; i < n; i++) {
                final Object item = vector.elementAt(i);
		if (item.equals(to)) {
		    return item;
		}
	    }
	}
	return null;
    }
}
"
org.apache.xpath.res.XPATHErrorResources_fr,3,4,0,1,4,1,0,1,2,1.428571429,1872,0.0,0,0.976190476,1.0,0,0,618.3333333,1,0.3333,1,"
package org.apache.xpath.res;


public class XPATHErrorResources_fr extends XPATHErrorResources
{

  
  public static final int MAX_CODE = 108;  

  
  public static final int MAX_WARNING = 11;  

  
  public static final int MAX_OTHERS = 20;

  
  public static final int MAX_MESSAGES = MAX_CODE + MAX_WARNING + 1;


  
  public static final Object[][] contents = {

  
  


  {
    ""ERROR0000"", ""{0}""},


  
  


  {
    ER_CURRENT_NOT_ALLOWED_IN_MATCH,
      ""La fonction current() n’est pas admise dans la correspondance à la forme !""},


  
  


  {
    ER_CURRENT_TAKES_NO_ARGS,
      ""La fonction current() n’admet pas les arguments !""},


  
  


  {
    ER_DOCUMENT_REPLACED,
      ""La mise en oeuvre de la fonction document () a été remplacée par org.apache.xalan.xslt.FuncDocument!""},


  
  


  {
    ER_CONTEXT_HAS_NO_OWNERDOC,
      ""le contexte n’a pas de document propriétaire !""},


  
  


  {
    ER_LOCALNAME_HAS_TOO_MANY_ARGS,
      ""local-name() a trop d’arguments.""},


  
  


  {
    ER_NAMESPACEURI_HAS_TOO_MANY_ARGS,
      ""namespace-uri() a trop d’arguments.""},


  
  


  {
    ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS,
      ""normalize-space() a trop d’arguments.""},


  
  


  {
    ER_NUMBER_HAS_TOO_MANY_ARGS,
      ""number() a trop d’arguments.""},


  
  


  {
    ER_NAME_HAS_TOO_MANY_ARGS, ""name() a trop d’arguments.""},


  
  


  {
    ER_STRING_HAS_TOO_MANY_ARGS,
      ""string() a trop d’arguments.""},


  
  


  {
    ER_STRINGLENGTH_HAS_TOO_MANY_ARGS,
      ""string-length() a trop d’arguments.""},


  
  


  {
    ER_TRANSLATE_TAKES_3_ARGS,
      ""La fonction translate() a trois arguments !""},


  
  


  {
    ER_UNPARSEDENTITYURI_TAKES_1_ARG,
      ""La fonction unparsed-entity-uri ne peut avoir qu’un seul argument !""},


  
  


  {
    ER_NAMESPACEAXIS_NOT_IMPLEMENTED,
      ""l'axe namespace n’est pas encore mis en œuvre !""},


  
  


  {
    ER_UNKNOWN_AXIS, ""axe inconnu : {0}""},


  
  


  {
    ER_UNKNOWN_MATCH_OPERATION, ""opération de correspondance inconnue !""},


  
  


  {
    ER_INCORRECT_ARG_LENGTH,
      ""La longueur d’argument du test du nœud processing-instruction() n’est pas correcte !""},


  
  


  {
    ER_CANT_CONVERT_TO_NUMBER,
      ""Impossible de convertir {0} en fonction number""},


  
  


  {
    ER_CANT_CONVERT_TO_NODELIST,
      ""Impossible de convertir {0} en fonction NodeList !""},


  
  


  {
    ER_CANT_CONVERT_TO_MUTABLENODELIST,
      ""Impossible de convertir {0} en fonction NodeSetDTM !""},


  
  


  {
    ER_CANT_CONVERT_TO_TYPE,
      ""Impossible de convertir {0} en type


  
  


  {
    ER_EXPECTED_MATCH_PATTERN,
      ""Correspondance à la forme attendue dans getMatchScore !""},


  
  


  {
    ER_COULDNOT_GET_VAR_NAMED,
      ""Impossible de trouver la variable nommée {0}""},


  
  


  {
    ER_UNKNOWN_OPCODE, ""ERREUR ! Code d’opération inconnu : {0}""},


  
  


  {
    ER_EXTRA_ILLEGAL_TOKENS, ""Unités lexicales supplémentaires non autorisées : {0}""},


  
  


  {
    ER_EXPECTED_DOUBLE_QUOTE,
      ""libellé mal présenté... guillemet attendu !""},


  
  


  {
    ER_EXPECTED_SINGLE_QUOTE,
      ""libellé mal présenté... apostrophe attendue !""},


  
  


  {
    ER_EMPTY_EXPRESSION, ""Expression vide !""},


  
  


  {
    ER_EXPECTED_BUT_FOUND, ""{0} attendu(e), mais : {1} trouvé(e)""},


  
  


  {
    ER_INCORRECT_PROGRAMMER_ASSERTION,
      ""Assertion de programmeur incorrecte ! - {0}""},


  
  


  {
    ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL,
      ""L’argument boolean(...) n’est plus facultatif avec la version brouillon 19990709 XPath .""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG,
      ""',' trouvé sans argument avant !""},


  
  


  {
    ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
      ""',' trouvé sans argument après !""},


  
  


  {
    ER_PREDICATE_ILLEGAL_SYNTAX,
      ""'..[predicate]' ou '.[predicate]' constitue une mauvaise syntaxe. Utilisez 'self::node()[predicate]' à la place.""},


  
  


  {
    ER_ILLEGAL_AXIS_NAME, ""nom d’axe non autorisé : {0}""},


  
  


  {
    ER_UNKNOWN_NODETYPE, ""Type de nœud inconnu : {0}""},


  
  


  {
    ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
      ""Le libellé de la forme ({0}) doit être entre guillemets !""},


  
  


  {
    ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
      ""{0} ne peut pas être formaté(e) en number !""},


  
  


  {
    ER_COULDNOT_CREATE_XMLPROCESSORLIAISON,
      ""Impossible de créer XML TransformerFactory Liaison : {0}""},


  
  


  {
    ER_DIDNOT_FIND_XPATH_SELECT_EXP,
      ""Erreur ! Impossible de trouver l’expression de sélection xpath (-select).""},


  
  


  {
    ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH,
      ""ERREUR ! Impossible de trouver ENDOP après OP_LOCATIONPATH""},


  
  


  {
    ER_ERROR_OCCURED, ""Une erreur s’est produite !""},


  
  


  {
    ER_ILLEGAL_VARIABLE_REFERENCE,
      ""L''élément VariableReference a été fourni pour la variable hors contexte ou sans définition !  Nom = {0}""},


  
  


  {
    ER_AXES_NOT_ALLOWED,
      ""Seuls les axes child:: et attribute:: sont admis dans les correspondances à la forme !  Axes erronés = {0}""},


  
  


  {
    ER_KEY_HAS_TOO_MANY_ARGS,
      ""key() dispose d’un nombre incorrect d’arguments.""},


  
  


  {
    ER_COUNT_TAKES_1_ARG,
      ""La fonction count ne doit avoir qu’un seul argument !""},


  
  


  {
    ER_COULDNOT_FIND_FUNCTION, ""Impossible de trouver la fonction : {0}""},


  
  


  {
    ER_UNSUPPORTED_ENCODING, ""Codage non pris en charge : {0}""},


  
  


  {
    ER_PROBLEM_IN_DTM_NEXTSIBLING,
      ""Un incident s’est produit au niveau de DTM dans getNextSibling... Tentative de récupération""},


  
  


  {
    ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL,
      ""Erreur de programmation : Impossible d’écrire dans EmptyNodeList.""},


  
  


  {
    ER_SETDOMFACTORY_NOT_SUPPORTED,
      ""setDOMFactory n’est pas pris en charge par XPathContext!""},


  
  


  {
    ER_PREFIX_MUST_RESOLVE,
      ""Le préfixe doit se résoudre en nom d''espace : {0}""},


  
  


  {
    ER_PARSE_NOT_SUPPORTED,
      ""parse (source InputSource) non pris en charge dans XpathContext ! Impossible d’ouvrir {0}""},


  
  


  {
    ER_SAX_API_NOT_HANDLED,
      ""Les caractères SAX API (char ch[]... ne sont pas pris en charge par DTM !""},


  
  


  {
    ER_IGNORABLE_WHITESPACE_NOT_HANDLED,
      ""ignorableWhitespace(char ch[]... ne sont pas pris en charge par DTM !""},


  
  


  {
    ER_DTM_CANNOT_HANDLE_NODES,
      ""DTMLiaison ne peut pas prendre en charge les nœuds de type {0}""},


  
  


  {
    ER_XERCES_CANNOT_HANDLE_NODES,
      ""DOM2Helper ne peut pas prendre en charge les nœuds de type {0}""},


  
  


  {
    ER_XERCES_PARSE_ERROR_DETAILS,
      ""Erreur DOM2Helper.parse : ID système - {0} ligne - {1}""},


  
  


  {
    ER_XERCES_PARSE_ERROR, ""Erreur DOM2Helper.parse""},


  
  


  {
    ER_INVALID_UTF16_SURROGATE,
      ""Substitut UTF-16 incorrect détecté : {0} ?""},


  
  


  {
    ER_OIERROR, ""Erreur d’E/S""},


  
  


  {
    ER_CANNOT_CREATE_URL, ""Impossible de créer une url pour : {0}""},


  
  


  {
    ER_XPATH_READOBJECT, ""Dans XPath.readObject : {0}""},

  
  
  


  {
    ER_FUNCTION_TOKEN_NOT_FOUND,
      ""Unité lexicale function introuvable.""},

  
   
  


  {
    ER_CANNOT_DEAL_XPATH_TYPE,
       ""Impossible d’opérer avec le type : {0} XPath""},

  
   
  

	
  {
    ER_NODESET_NOT_MUTABLE,
       ""Cet élément NodeSet n’est pas mutable""},

  
   
  


  {
    ER_NODESETDTM_NOT_MUTABLE,
       ""Cet élément NodeSetDTM n’est pas mutable""},

  
   
  


  {
    ER_VAR_NOT_RESOLVABLE,
        ""Variable non résolue : {0}""},

  
   
  


  {
    ER_NULL_ERROR_HANDLER,
        ""Gestionnaire d’erreur vide""},

  
   
  


  {
    ER_PROG_ASSERT_UNKNOWN_OPCODE,
       ""Assertion du programmeur : code opération inconnu : {0}""},

  
   
  


  {
    ER_ZERO_OR_ONE,
       ""0 ou 1""},
    
  
  
   
  


  {
    ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""rtf() n’est pas pris en charge par XRTreeFragSelectWrapper""},

  
   
  


  {
    ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER,
       ""asNodeIterator() n’est pas pris en charge par XRTreeFragSelectWrapper""},

  
   
  


  {
    ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS,
       ""fsb() n’est pas pris en charge pour XStringForChars""},

  
   
  


  {
    ER_COULD_NOT_FIND_VAR,
      ""Impossible de trouver la variable nommée {0}""},

  
   
  


  {
    ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING,
      ""XStringForChars ne peut pas avoir de chaîne comme argument""},

  
   
  


  {
    ER_FASTSTRINGBUFFER_CANNOT_BE_NULL,
      ""L’argument FastStringBuffer ne peut pas être égal à null""},
    
 
   
  


  {
    ER_TWO_OR_THREE,
       ""2 ou 3""},


 
  


  {
    ER_VARIABLE_ACCESSED_BEFORE_BIND,
       ""Variable accédée avant sa limite !""},


   
  


  {
    ER_FSB_CANNOT_TAKE_STRING,
       ""XStringForFSB ne peut pas être une chaîne pour un argument!""},


   
  


  {
    ER_SETTING_WALKER_ROOT_TO_NULL,
       ""
 !!!! Erreur! Attribution d'une valeur null à la racine d'un walker !!!""},


   
  


  {
    ER_NODESETDTM_CANNOT_ITERATE,
       ""Ce NodeSetDTM ne peut pas être répété à un noeud précédent !""},


  
  


  {
    ER_NODESET_CANNOT_ITERATE,
       ""Ce NodeSet ne peut pas être répété vers un noeud précédent !""},


  
  


  {
    ER_NODESETDTM_CANNOT_INDEX,
       ""Ce NodeSetDTM ne peut pas exécuter de fonctions d'indexation ou de comptage !""},


  
  


  {
    ER_NODESET_CANNOT_INDEX,
       ""Ce NodeSet ne peut pas exécuter de fonctions d'indexation ou de comptage !""},


  
  


  {
    ER_CANNOT_CALL_SETSHOULDCACHENODE,
       ""Impossible d'appeler setShouldCacheNodes après avoir appelé nextNode !""},


  
  


  {
    ER_ONLY_ALLOWS,
       ""{0} n''admet que les arguments {1} arguments""},


  
  


  {
    ER_UNKNOWN_STEP,
       ""Assertion du programmeur dans getNextStepPos : stepType inconnu : {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_REL_LOC_PATH,
       ""Un chemin d'accès relatif était attendu après le jeton '/' ou '


  
  
  

  
  


  {
    ER_EXPECTED_LOC_PATH,
       ""Un chemin d'accès était attendu, mais l'objet suivant a été rencontré:  {0}""},


  
  
  

  
  


  {
    ER_EXPECTED_LOC_STEP,
       ""Une étape de positionnement été attendue à la suite de l'objet '/' ou '


  
  
  
  

  
  


  {
    ER_EXPECTED_NODE_TEST,
       ""Un test de noeud correspondant à NCName:* ou à QName était attendu.""},


  
  
  

  
  


  {
    ER_EXPECTED_STEP_PATTERN,
       ""Une forme d'étape était attendue, mais '/' a été rencontré.""},


  
  
  
 

  


  {
    ER_EXPECTED_REL_PATH_PATTERN,
       ""Une forme de chemin d'accès relatif était attendue.""},



  
  

  
  


  {
    ER_CANT_CONVERT_TO_BOOLEAN,
       ""Impossible de convertir {0} en valeur booléenne.""},



  

  
  


  {
    ER_CANT_CONVERT_TO_SINGLENODE,
       ""Impossible de convertir {0} en noeud unique. Cette méthode d'obtention s'applique aux  types ANY_UNORDERED_NODE_TYPE et FIRST_ORDERED_NODE_TYPE.""},



  

  
  


  {
    ER_CANT_GET_SNAPSHOT_LENGTH,
       ""Impossible d'obtenir une longueur d'instantané du type : {0}. Cette méthode d'obtention s'applique aux types UNORDERED_NODE_SNAPSHOT_TYPE et ORDERED_NODE_SNAPSHOT_TYPE.""},

  
  
  


  {
    ER_NON_ITERATOR_TYPE,
       ""Impossible d'itérer sur le type non répétiteur : {0}""},



  
  

  
  


  {
    ER_DOC_MUTATED,
       ""Le document a muté depuis que le résultat a été renvoyé. L'itérateur est incorrect.""},



  


  {
    ER_INVALID_XPATH_TYPE,
       ""Argument de type XPath incorrect : {0}""},



  


  {
    ER_EMPTY_XPATH_RESULT,
       ""Objet de résultat XPath vide""},


  
  


  {
    ER_INCOMPATIBLE_TYPES,
       ""Impossible de forcer le type renvoyé : {0} dans le fichier : {1}""},



  


  {
    ER_NULL_RESOLVER,
       ""Impossible de résoudre le préfixe sans décomposeur de préfixe.""},



  
  

  
  


  {
    ER_CANT_CONVERT_TO_STRING,
       ""Impossible de convertir {0} en chaîne .""},



  

  
  


  {
    ER_NON_SNAPSHOT_TYPE,
       ""Impossible d'appeler snapshotItem sur le type : {0}. Cette méthode s'applique aux types UNORDERED_NODE_SNAPSHOT_TYPE et ORDERED_NODE_SNAPSHOT_TYPE.""},



  
  
  


  


  {
    ER_WRONG_DOCUMENT,
       ""Le noeud de contexte n'appartient pas au document associé à ce XPathEvaluator.""},



  
  
  


  {
    ER_WRONG_NODETYPE ,
       ""Le noeud de contexte n'est pas pris en charge.""},



  


  {
    ER_XPATH_ERROR ,
       ""Erreur inconnue dans XPath.""},



  

  
  


  {
    WG_LOCALE_NAME_NOT_HANDLED,
      ""Le nom de l'environnement local dans la fonction format-number n’est pas encore géré !""},


  
  


  {
    WG_PROPERTY_NOT_SUPPORTED,
      ""XSL Property non pris en charge : {0}""},


  
  


  {
    WG_DONT_DO_ANYTHING_WITH_NS,
      ""Ne rien faire pour l’instant avec le nom d''espace {0} dans la propriété : {1}""},


  
  


  {
    WG_SECURITY_EXCEPTION,
      ""Interception de SecurityException ors de la tentative d’accès à la propriété système XSL : {0}""},


  
  


  {
    WG_QUO_NO_LONGER_DEFINED,
      ""L’ancienne syntaxe: quo(...) n’est plus définie dans XPath.""},


  
  


  {
    WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST,
      ""XPath requiert un objet dérivé pour mettre en oeuvre nodeTest !""},


  
  


  {
    WG_FUNCTION_TOKEN_NOT_FOUND,
      ""Unité lexicale function introuvable.""},


  
  


  {
    WG_COULDNOT_FIND_FUNCTION,
      ""Impossible de trouver la fonction : {0}""},


  
  


  {
    WG_CANNOT_MAKE_URL_FROM,
      ""Impossible de créer une URL à partir de : {0}""},


  
  


  {
    WG_EXPAND_ENTITIES_NOT_SUPPORTED,
      ""L’option -E n’est pas pris en charge pour l’analyseur syntaxique DTM""},


  
  


  {
    WG_ILLEGAL_VARIABLE_REFERENCE,
      ""L''élément VariableReference a été fourni pour la variable hors contexte ou sans définition !  Nom = {0}""},


  
  


  {
    ER_UNSUPPORTED_ENCODING, ""Codage non pris en charge : {0}""},


  

  { ""ui_language"", ""fr""},
  { ""help_language"", ""fr""},
  { ""language"", ""fr""},
    { ""BAD_CODE"",
      ""Paramètre pour createMessage hors limites""},
    { ""FORMAT_FAILED"",
      ""Exception émise pendant l’appel de messageFormat""},
    { ""version"", "">>>>>>> Version Xalan ""},
    { ""version2"", ""<<<<<<<""},
    { ""yes"", ""oui""},
    { ""line"", ""Ligne 
    { ""column"", ""Colonne 
    { ""xsldone"", ""XSLProcessor: terminé""},
    { ""xpath_option"", ""options xpath : ""},
    { ""optionIN"", ""   [-in inputXMLURL]""},
    { ""optionSelect"", ""   [expression xpath -select]""},
    { ""optionMatch"",
      ""   [correspondance à la forme -match (pour les diagnostics de correspondance)]""},
    { ""optionAnyExpr"",
      ""Ou une expression xpath provoquera un échec de diagnostic""},
    { ""noParsermsg1"", ""Echec de XSL Process.""},
    { ""noParsermsg2"", ""** Impossible de trouver l’analyseur syntaxique**""},
    { ""noParsermsg3"", ""Veuillez vérifier votre chemin de classe.""},
    { ""noParsermsg4"",
      ""Si vous ne disposez pas de l’analyseur XML d’IBM pour Java, vous pouvez le télécharger à l’adresse suivante""},
    { ""noParsermsg5"",
      ""IBM's AlphaWorks: http:
  };

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""

  
  public static final String ERROR_HEADER = ""Erreur : "";

  
  public static final String WARNING_HEADER = ""Attention : "";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""FORME "";

  
  public Object[][] getContents()
  {
    return contents;
  }
}


"
org.apache.xalan.templates.FuncDocument,8,5,0,16,67,28,1,15,6,2.0,551,0.0,0,0.888888889,0.475,3,8,67.875,1,0.875,2,"
package org.apache.xalan.templates;

import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringWriter;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.Source;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.Expression;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.SourceTreeManager;
import org.apache.xpath.XPathContext;
import org.apache.xpath.functions.Function2Args;
import org.apache.xpath.functions.WrongNumberArgsException;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;


public class FuncDocument extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    
    int docContext = dtm.getDocumentRoot(context);
    XObject arg = (XObject) this.getArg0().execute(xctxt);

    String base = """";
    Expression arg1Expr = this.getArg1();

    if (null != arg1Expr)
    {

      
      
      
      
      XObject arg2 = arg1Expr.execute(xctxt);

      if (XObject.CLASS_NODESET == arg2.getType())
      {
        int baseNode = arg2.iter().nextNode();

        if (baseNode == DTM.NULL)
        {
            
            
            
          	warn(xctxt, XSLTErrorResources.WG_EMPTY_SECOND_ARG, null);
          	XNodeSet nodes = new XNodeSet(xctxt.getDTMManager());
   	        return nodes;
        } else{
	        DTM baseDTM = xctxt.getDTM(baseNode);
    	    base = baseDTM.getDocumentBaseURI();
        }
        
        










      }
      else
      {
        base = arg2.str();
      }
    }
    else
    {

      
      
      
      
      
      
      
      
      
      assertion(null != xctxt.getNamespaceContext(), ""Namespace context can not be null!"");
      base = xctxt.getNamespaceContext().getBaseIdentifier();
    }

    XNodeSet nodes = new XNodeSet(xctxt.getDTMManager());
    NodeSetDTM mnl = nodes.mutableNodeset();
    DTMIterator iterator = (XObject.CLASS_NODESET == arg.getType())
                            ? arg.iter() : null;
    int pos = DTM.NULL;

    while ((null == iterator) || (DTM.NULL != (pos = iterator.nextNode())))
    {
      XMLString ref = (null != iterator)
                   ? xctxt.getDTM(pos).getStringValue(pos) : arg.xstr();
      
      
      
      
      
      
      
      
      
      if (null == arg1Expr && DTM.NULL != pos)
      {
        DTM baseDTM = xctxt.getDTM(pos);
        base = baseDTM.getDocumentBaseURI();
      }

      if (null == ref)
        continue;

      if (DTM.NULL == docContext)
      {
        error(xctxt, XSLTErrorResources.ER_NO_CONTEXT_OWNERDOC, null);  
      }

      
      
      
      
      
      
      int indexOfColon = ref.indexOf(':');
      int indexOfSlash = ref.indexOf('/');

      if ((indexOfColon != -1) && (indexOfSlash != -1)
              && (indexOfColon < indexOfSlash))
      {

        
        base = null;
      }

      int newDoc = getDoc(xctxt, context, ref.toString(), base);

      
      if (DTM.NULL != newDoc)
      {
        
        if (!mnl.contains(newDoc))
        {
          mnl.addElement(newDoc);
        }
      }

      if (null == iterator || newDoc == DTM.NULL)
        break;
    }

    return nodes;
  }

  
  int getDoc(XPathContext xctxt, int context, String uri, String base)
          throws javax.xml.transform.TransformerException
  {

    
    SourceTreeManager treeMgr = xctxt.getSourceTreeManager();
    Source source;
   
    int newDoc;
    try
    {
      source = treeMgr.resolveURI(base, uri, xctxt.getSAXLocator());
      newDoc = treeMgr.getNode(source);
    }
    catch (IOException ioe)
    {
      throw new TransformerException(ioe.getMessage(), 
        (SourceLocator)xctxt.getSAXLocator(), ioe);
    }
    catch(TransformerException te)
    {
      throw new TransformerException(te);
    }

    if (DTM.NULL != newDoc)
      return newDoc;

    
    if (uri.length() == 0)
    {
      
      uri = xctxt.getNamespaceContext().getBaseIdentifier();
      try
      {
        source = treeMgr.resolveURI(base, uri, xctxt.getSAXLocator());
      }
      catch (IOException ioe)
      {
        throw new TransformerException(ioe.getMessage(), 
          (SourceLocator)xctxt.getSAXLocator(), ioe);
      }
    }

    String diagnosticsString = null;

    try
    {
      if ((null != uri) && (uri.toString().length() > 0))
      {
        newDoc = treeMgr.getSourceTree(source, xctxt.getSAXLocator(), xctxt);

        
      }
      else
        warn(xctxt, XSLTErrorResources.WG_CANNOT_MAKE_URL_FROM,
             new Object[]{ ((base == null) ? """" : base) + uri });  
    }
    catch (Throwable throwable)
    {

      
      newDoc = DTM.NULL;

      
      while (throwable
             instanceof org.apache.xml.utils.WrappedRuntimeException)
      {
        throwable =
          ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();
      }

      if ((throwable instanceof NullPointerException)
              || (throwable instanceof ClassCastException))
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(
          (Exception) throwable);
      }

      StringWriter sw = new StringWriter();
      PrintWriter diagnosticsWriter = new PrintWriter(sw);

      if (throwable instanceof TransformerException)
      {
        TransformerException spe = (TransformerException) throwable;

        {
          Throwable e = spe;

          while (null != e)
          {
            if (null != e.getMessage())
            {
              diagnosticsWriter.println("" ("" + e.getClass().getName() + ""): ""
                                        + e.getMessage());
            }

            if (e instanceof TransformerException)
            {
              TransformerException spe2 = (TransformerException) e;

              SourceLocator locator = spe2.getLocator();
              if ((null != locator) && (null != locator.getSystemId()))
                diagnosticsWriter.println(""   ID: "" + locator.getSystemId()
                                          + "" Line #"" + locator.getLineNumber()
                                          + "" Column #""
                                          + locator.getColumnNumber());

              e = spe2.getException();

              if (e instanceof org.apache.xml.utils.WrappedRuntimeException)
                e = ((org.apache.xml.utils.WrappedRuntimeException) e).getException();
            }
            else
              e = null;
          }
        }
      }
      else
      {
        diagnosticsWriter.println("" ("" + throwable.getClass().getName()
                                  + ""): "" + throwable.getMessage());
      }

      diagnosticsString = throwable.getMessage(); 
    }

    if (DTM.NULL == newDoc)
    {

      
      if (null != diagnosticsString)
      {
        warn(xctxt, XSLTErrorResources.WG_CANNOT_LOAD_REQUESTED_DOC,
             new Object[]{ diagnosticsString });  
      }
      else
        warn(xctxt, XSLTErrorResources.WG_CANNOT_LOAD_REQUESTED_DOC,
             new Object[]{
               uri == null
               ? ((base == null) ? """" : base) + uri : uri.toString() });  
    }
    else
    {
      
      
      
    }

    return newDoc;
  }

  
  public void error(XPathContext xctxt, String msg, Object args[])
          throws javax.xml.transform.TransformerException
  {

    String formattedMsg = XSLMessages.createMessage(msg, args);
    ErrorListener errHandler = xctxt.getErrorListener();
    TransformerException spe = new TransformerException(formattedMsg,
                              (SourceLocator)xctxt.getSAXLocator());

    if (null != errHandler)
      errHandler.error(spe);
    else
      System.out.println(formattedMsg);
  }

  
  public void warn(XPathContext xctxt, String msg, Object args[])
          throws javax.xml.transform.TransformerException
  {

    String formattedMsg = XSLMessages.createWarning(msg, args);
    ErrorListener errHandler = xctxt.getErrorListener();
    TransformerException spe = new TransformerException(formattedMsg,
                              (SourceLocator)xctxt.getSAXLocator());

    if (null != errHandler)
      errHandler.warning(spe);
    else
      System.out.println(formattedMsg);
  }

 
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if ((argNum < 1) || (argNum > 2))
      reportWrongNumberArgs();
  }
  
  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createMessage(XSLTErrorResources.ER_ONE_OR_TWO, null)); 
  }
  
  
  public boolean isNodesetExpr()
  {
    return true;
  }

}
"
org.apache.xpath.functions.FuncRound,2,4,0,5,7,1,0,5,2,2.0,17,0.0,0,0.979591837,0.75,1,6,7.5,1,0.5,2,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class FuncRound extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(java.lang.Math.floor(m_arg0.execute(xctxt).num()
                                            + 0.5));
  }
}
"
org.apache.xalan.transformer.XalanProperties,1,1,0,0,2,0,0,0,1,2.0,5,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"

package org.apache.xalan.transformer;


public class XalanProperties
{
  public final static String SOURCE_LOCATION
    = ""http:
}
"
org.apache.xalan.xsltc.runtime.Operators,1,1,0,3,1,0,3,0,0,2.0,36,0.0,0,0.0,0.0,0,0,28.0,0,0.0,0,"

package org.apache.xalan.xsltc.runtime;

public interface Operators {
    public static final int EQ = 0;
    public static final int NE = 1;
    public static final int GT = 2;
    public static final int LT = 3;
    public static final int GE = 4;
    public static final int LE = 5;
	
    public static final String[] names = {
	""="", ""!="", "">"", ""<"", "">="", ""<=""
    };
}
"
org.apache.xalan.trace.TraceListenerEx2,1,1,0,4,1,0,2,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,1,"
package org.apache.xalan.trace;


public interface TraceListenerEx2 extends TraceListenerEx
{
  
  public void traceEnd(TracerEvent ev);
}
"
org.apache.xalan.xsltc.compiler.Copy,5,3,0,28,42,4,0,28,4,0.5,253,1.0,1,0.933333333,0.333333333,1,6,49.4,4,1.6,1,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.BranchHandle;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.IFNULL;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.ISTORE;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.LocalVariableGen;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class Copy extends Instruction {
    private UseAttributeSets _useSets;
    
    public void parseContents(Parser parser) {
	final String useSets = getAttribute(""use-attribute-sets"");
	if (useSets.length() > 0) {
	    _useSets = new UseAttributeSets(useSets, parser);
	}
	parseChildren(parser);
    }
    
    public void display(int indent) {
	indent(indent);
	Util.println(""Copy"");
	indent(indent + IndentIncrement);
	displayContents(indent + IndentIncrement);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_useSets != null) {
	    _useSets.typeCheck(stable);
	}
	typeCheckContents(stable);
	return Type.Void;
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final LocalVariableGen name =
	    methodGen.addLocalVariable2(""name"",
					Util.getJCRefType(STRING_SIG),
					il.getEnd());
	final LocalVariableGen length =
	    methodGen.addLocalVariable2(""length"",
					Util.getJCRefType(""I""),
					il.getEnd());

	
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadHandler());
	final int cpy = cpg.addInterfaceMethodref(DOM_INTF,
						  ""shallowCopy"",
						  ""(""
						  + NODE_SIG
						  + TRANSLET_OUTPUT_SIG
						  + "")"" + STRING_SIG); 
	il.append(new INVOKEINTERFACE(cpy, 3));
	il.append(DUP);
	il.append(new ASTORE(name.getIndex()));
	final BranchHandle ifBlock1 = il.append(new IFNULL(null));

	
	il.append(new ALOAD(name.getIndex()));
	final int lengthMethod = cpg.addMethodref(STRING_CLASS,""length"",""()I"");
	il.append(new INVOKEVIRTUAL(lengthMethod));
	il.append(new ISTORE(length.getIndex()));

	
	if (_useSets != null) {
	    
	    
	    final SyntaxTreeNode parent = getParent();
	    if ((parent instanceof LiteralElement) ||
		(parent instanceof LiteralElement)) {
		_useSets.translate(classGen, methodGen);
	    }
	    
	    
	    else {
		
		il.append(new ILOAD(length.getIndex()));
		final BranchHandle ifBlock2 = il.append(new IFEQ(null));
		
		_useSets.translate(classGen, methodGen);
		
		ifBlock2.setTarget(il.append(NOP));
	    }
	}

	
	translateContents(classGen, methodGen);

	
	
	il.append(new ILOAD(length.getIndex()));
	final BranchHandle ifBlock3 = il.append(new IFEQ(null));
	il.append(methodGen.loadHandler());
	il.append(new ALOAD(name.getIndex()));
	il.append(methodGen.endElement());
	
	final InstructionHandle end = il.append(NOP);
	ifBlock1.setTarget(end);
	ifBlock3.setTarget(end);
	methodGen.removeLocalVariable(name);
	methodGen.removeLocalVariable(length);
    }
}
"
org.apache.xalan.xsltc.compiler.util.RtMethodGenerator,5,5,0,7,8,6,0,7,5,0.916666667,41,1.0,0,0.971830986,0.325,1,2,6.6,1,0.8,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ASTORE;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.Type;


public final class RtMethodGenerator extends MethodGenerator {
    private static final int HANDLER_INDEX = 2;
    private final Instruction _astoreHandler;
    private final Instruction _aloadHandler;

    public RtMethodGenerator(int access_flags, Type return_type,
			     Type[] arg_types, String[] arg_names,
			     String method_name, String class_name,
			     InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
	
	_astoreHandler = new ASTORE(HANDLER_INDEX);
	_aloadHandler  = new ALOAD(HANDLER_INDEX);
    }

    public int getIteratorIndex() {
	return INVALID_INDEX;		
    }
    
    public final Instruction storeHandler() {
	return _astoreHandler;
    }

    public final Instruction loadHandler() {
	return _aloadHandler;
    }

    public int getLocalIndex(String name) {
	return INVALID_INDEX;		
    }
}
"
org.apache.xalan.xsltc.dom.StripWhitespaceFilter,1,1,0,1,1,0,0,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;

public interface StripWhitespaceFilter {
    public boolean stripSpace(DOM dom, int node, int type);
}
"
org.apache.xalan.xsltc.compiler.UnaryOpExpr,6,3,0,13,28,0,0,13,6,0.0,101,1.0,1,0.934210526,0.305555556,2,8,15.66666667,1,0.8333,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class UnaryOpExpr extends Expression {
    private Expression _left;
	
    public UnaryOpExpr(Expression left) {
	(_left = left).setParent(this);
    }

    
    public boolean hasPositionCall() {
	return(_left.hasPositionCall());
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tleft = _left.typeCheck(stable); 
	final MethodType ptype = lookupPrimop(stable, ""u-"",
					      new MethodType(Type.Void,
							     tleft)); 
	
	if (ptype != null) {
	    final Type arg1 = (Type) ptype.argsType().elementAt(0);
	    if (!arg1.identicalTo(tleft)) {
		_left = new CastExpr(_left, arg1);
	    }
	    return _type = ptype.resultType();
	}

	throw new TypeCheckError(this);
    }

    public String toString() {
	return ""u-"" + '(' + _left + ')';
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	InstructionList il = methodGen.getInstructionList();
	_left.translate(classGen, methodGen);
	il.append(_type.NEG());
    }
}

"
org.apache.xalan.xsltc.runtime.TransletLoader,3,1,0,6,11,0,6,0,3,0.0,38,0.0,0,0.0,0.833333333,0,0,11.33333333,1,0.6667,0,"

package org.apache.xalan.xsltc.runtime;



final public class TransletLoader {
    
    ClassLoader _loader = null; 

    
    public TransletLoader() {
	
	ClassLoader loader = Thread.currentThread().getContextClassLoader();

	
	final String loaderName = loader.getClass().getName();
	if (loaderName.equals(""sun.misc.Launcher$ExtClassLoader"")) {
	    loader = ClassLoader.getSystemClassLoader();
	}
	_loader = loader;
    }

    
    public Class loadClass(String name) throws ClassNotFoundException {
	return(Class.forName(name, false, _loader));
    }

    
    public Class loadTranslet(String name) throws ClassNotFoundException {
	return(Class.forName(name, true, _loader));
    }
}
"
org.apache.xpath.ExpressionOwner,2,1,0,55,2,1,54,1,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"
package org.apache.xpath;


public interface ExpressionOwner
{
  
  public Expression getExpression();

  
  public void setExpression(Expression exp);


}

"
org.apache.xml.dtm.ref.sax2dtm.SAX2DTM,74,4,2,25,188,2227,5,21,64,0.907106164,2452,0.9375,11,0.56969697,0.134246575,2,20,31.7027027,13,2.2973,0,"
package org.apache.xml.dtm.ref.sax2dtm;

import java.util.Hashtable;
import java.util.Vector;
import javax.xml.transform.Source;
import javax.xml.transform.SourceLocator;

import org.apache.xml.dtm.*;
import org.apache.xml.dtm.ref.*;
import org.apache.xml.utils.StringVector;
import org.apache.xml.utils.IntVector;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.SuballocatedIntVector;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.res.XMLMessages;
import org.xml.sax.*;
import org.xml.sax.ext.*;


public class SAX2DTM extends DTMDefaultBaseIterators
        implements EntityResolver, DTDHandler, ContentHandler, ErrorHandler,
                   DeclHandler, LexicalHandler
{
  
  private static final boolean DEBUG = false;

  
  private IncrementalSAXSource m_incrementalSAXSource = null;

  
  
  protected FastStringBuffer m_chars;

  
  protected SuballocatedIntVector m_data;

  
  transient protected IntStack m_parents;

  
  transient protected int m_previous = 0;

  
  transient protected java.util.Vector m_prefixMappings =
    new java.util.Vector();

  
  transient protected IntStack m_contextIndexes;

  
  transient protected int m_textType = DTM.TEXT_NODE;

  
  transient protected int m_coalescedTextType = DTM.TEXT_NODE;

  
  transient protected Locator m_locator = null;

  
  transient private String m_systemId = null;

  
  transient protected boolean m_insideDTD = false;

  
  protected DTMTreeWalker m_walker = new DTMTreeWalker();

  
  protected DTMStringPool m_valuesOrPrefixes;

  
  protected boolean m_endDocumentOccured = false;

  
  protected SuballocatedIntVector m_dataOrQName;

  
  protected Hashtable m_idAttributes = new Hashtable();

  
  static final String[] m_fixednames = { null, null,  
                                         null, ""#text"",  
                                         ""#cdata_section"", null,  
                                         null, null,  
                                         ""#comment"", ""#document"",  
                                         null, ""#document-fragment"",  
                                         null };  

  
  private Vector m_entities = null;

  
  private static final int ENTITY_FIELD_PUBLICID = 0;

  
  private static final int ENTITY_FIELD_SYSTEMID = 1;

  
  private static final int ENTITY_FIELD_NOTATIONNAME = 2;

  
  private static final int ENTITY_FIELD_NAME = 3;

  
  private static final int ENTITY_FIELDS_PER = 4;

  
  protected int m_textPendingStart = -1;

  
  protected boolean m_useSourceLocationProperty = false;

  
  protected static boolean m_source_location = false;

   
  protected StringVector m_sourceSystemId;
   
  protected IntVector m_sourceLine;
   
  protected IntVector m_sourceColumn;
  
  
  public SAX2DTM(DTMManager mgr, Source source, int dtmIdentity,
                 DTMWSFilter whiteSpaceFilter,
                 XMLStringFactory xstringfactory,
                 boolean doIndexing)
  {

    this(mgr, source, dtmIdentity, whiteSpaceFilter,
          xstringfactory, doIndexing, DEFAULT_BLOCKSIZE, true);
  }
  
  
  public SAX2DTM(DTMManager mgr, Source source, int dtmIdentity,
                 DTMWSFilter whiteSpaceFilter,
                 XMLStringFactory xstringfactory,
                 boolean doIndexing,
                 int blocksize,
                 boolean usePrevsib)
  {

    super(mgr, source, dtmIdentity, whiteSpaceFilter,
          xstringfactory, doIndexing, blocksize, usePrevsib);

    
    
    if (blocksize <= 64) 
    {
      m_data = new SuballocatedIntVector(blocksize, DEFAULT_NUMBLOCKS_SMALL);
      m_dataOrQName = new SuballocatedIntVector(blocksize, DEFAULT_NUMBLOCKS_SMALL);
      m_valuesOrPrefixes = new DTMStringPool(16);
      m_chars = new FastStringBuffer(7, 10);
      m_contextIndexes = new IntStack(4);
      m_parents = new IntStack(4);
    }
    else
    {
      m_data = new SuballocatedIntVector(blocksize, DEFAULT_NUMBLOCKS);
      m_dataOrQName = new SuballocatedIntVector(blocksize, DEFAULT_NUMBLOCKS);
      m_valuesOrPrefixes = new DTMStringPool();
      m_chars = new FastStringBuffer(10, 13);
      m_contextIndexes = new IntStack();
      m_parents = new IntStack();
    }
         
    
    
    
    

    m_data.addElement(0);   

    
    
    
    m_useSourceLocationProperty = m_source_location;
    m_sourceSystemId = (m_useSourceLocationProperty) ? new StringVector() : null;
 	m_sourceLine = (m_useSourceLocationProperty) ?  new IntVector() : null;
    m_sourceColumn = (m_useSourceLocationProperty) ?  new IntVector() : null; 
  }

  
  public static void setUseSourceLocation(boolean useSourceLocation)
  {
    m_source_location = useSourceLocation;
  }

  
  protected int _dataOrQName(int identity)
  {

    if (identity < m_size)
      return m_dataOrQName.elementAt(identity);

    
    
    
    while (true)
    {
      boolean isMore = nextNode();

      if (!isMore)
        return NULL;
      else if (identity < m_size)
        return m_dataOrQName.elementAt(identity);
    }
  }

  
  public void clearCoRoutine()
  {
    clearCoRoutine(true);
  }

  
  public void clearCoRoutine(boolean callDoTerminate)
  {

    if (null != m_incrementalSAXSource)
    {
      if (callDoTerminate)
        m_incrementalSAXSource.deliverMoreNodes(false);

      m_incrementalSAXSource = null;
    }
  }

  
  public void setIncrementalSAXSource(IncrementalSAXSource incrementalSAXSource)
  {

    
    
    
    
    
    
    
    m_incrementalSAXSource = incrementalSAXSource;

    
    incrementalSAXSource.setContentHandler(this);
    incrementalSAXSource.setLexicalHandler(this);
    incrementalSAXSource.setDTDHandler(this);

    
    
    
    
  }

  
  public ContentHandler getContentHandler()
  {

    if (m_incrementalSAXSource instanceof IncrementalSAXSource_Filter)
      return (ContentHandler) m_incrementalSAXSource;
    else
      return this;
  }

  
  public LexicalHandler getLexicalHandler()
  {

    if (m_incrementalSAXSource instanceof IncrementalSAXSource_Filter)
      return (LexicalHandler) m_incrementalSAXSource;
    else
      return this;
  }

  
  public EntityResolver getEntityResolver()
  {
    return this;
  }

  
  public DTDHandler getDTDHandler()
  {
    return this;
  }

  
  public ErrorHandler getErrorHandler()
  {
    return this;
  }

  
  public DeclHandler getDeclHandler()
  {
    return this;
  }

  
  public boolean needsTwoThreads()
  {
    return null != m_incrementalSAXSource;
  }

  
  public void dispatchCharactersEvents(int nodeHandle, ContentHandler ch,
                                       boolean normalize)
          throws SAXException
  {

    int identity = makeNodeIdentity(nodeHandle);
    
    if (identity == DTM.NULL)
      return;
    
    int type = _type(identity);

    if (isTextType(type))
    {
      int dataIndex = m_dataOrQName.elementAt(identity);
      int offset = m_data.elementAt(dataIndex);
      int length = m_data.elementAt(dataIndex + 1);

      if(normalize)
        m_chars.sendNormalizedSAXcharacters(ch, offset, length);
      else
        m_chars.sendSAXcharacters(ch, offset, length);
    }
    else
    {
      int firstChild = _firstch(identity);

      if (DTM.NULL != firstChild)
      {
        int offset = -1;
        int length = 0;
        int startNode = identity;

        identity = firstChild;

        do {
          type = _type(identity);

          if (isTextType(type))
          {
            int dataIndex = _dataOrQName(identity);

            if (-1 == offset)
            {
              offset = m_data.elementAt(dataIndex);
            }

            length += m_data.elementAt(dataIndex + 1);
          }

          identity = getNextNodeIdentity(identity);
        } while (DTM.NULL != identity && (_parent(identity) >= startNode));

        if (length > 0)
        {
          if(normalize)
            m_chars.sendNormalizedSAXcharacters(ch, offset, length);
          else
            m_chars.sendSAXcharacters(ch, offset, length);
        }
      }
      else if(type != DTM.ELEMENT_NODE)
      {
        int dataIndex = _dataOrQName(identity);

        if (dataIndex < 0)
        {
          dataIndex = -dataIndex;
          dataIndex = m_data.elementAt(dataIndex + 1);
        }

        String str = m_valuesOrPrefixes.indexToString(dataIndex);

          if(normalize)
            FastStringBuffer.sendNormalizedSAXcharacters(str.toCharArray(),
                                                         0, str.length(), ch);
          else
            ch.characters(str.toCharArray(), 0, str.length());
      }
    }
  }


  
  public String getNodeName(int nodeHandle)
  {

    int expandedTypeID = getExpandedTypeID(nodeHandle);
    
    int namespaceID = m_expandedNameTable.getNamespaceID(expandedTypeID);                     

    if (0 == namespaceID)
    {
      
      
      int type = getNodeType(nodeHandle);

      if (type == DTM.NAMESPACE_NODE)
      {
        if (null == m_expandedNameTable.getLocalName(expandedTypeID))
          return ""xmlns"";
        else
          return ""xmlns:"" + m_expandedNameTable.getLocalName(expandedTypeID);
      }
      else if (0 == m_expandedNameTable.getLocalNameID(expandedTypeID))
      {
        return m_fixednames[type];
      }
      else
        return m_expandedNameTable.getLocalName(expandedTypeID);
    }
    else
    {
      int qnameIndex = m_dataOrQName.elementAt(makeNodeIdentity(nodeHandle));

      if (qnameIndex < 0)
      {
        qnameIndex = -qnameIndex;
        qnameIndex = m_data.elementAt(qnameIndex);
      }

      return m_valuesOrPrefixes.indexToString(qnameIndex);
    }
  }

  
  public String getNodeNameX(int nodeHandle)
  {

    int expandedTypeID = getExpandedTypeID(nodeHandle);    
    int namespaceID = m_expandedNameTable.getNamespaceID(expandedTypeID);                      

    if (0 == namespaceID)
    {
      String name = m_expandedNameTable.getLocalName(expandedTypeID);

      if (name == null)
        return """";
      else
        return name;
    }
    else
    {
      int qnameIndex = m_dataOrQName.elementAt(makeNodeIdentity(nodeHandle));

      if (qnameIndex < 0)
      {
        qnameIndex = -qnameIndex;
        qnameIndex = m_data.elementAt(qnameIndex);
      }

      return m_valuesOrPrefixes.indexToString(qnameIndex);
    }
  }

  
  public boolean isAttributeSpecified(int attributeHandle)
  {

    
    return true;  
  }

  
  public String getDocumentTypeDeclarationSystemIdentifier()
  {

    
    error(XMLMessages.createXMLMessage(XMLErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return null;
  }

  
  protected int getNextNodeIdentity(int identity)
  {

    identity += 1;

    while (identity >= m_size)
    {
      if (null == m_incrementalSAXSource)
        return DTM.NULL;

      nextNode();
    }

    return identity;
  }

  
  public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {

    DTMTreeWalker treeWalker = m_walker;
    ContentHandler prevCH = treeWalker.getcontentHandler();

    if (null != prevCH)
    {
      treeWalker = new DTMTreeWalker();
    }

    treeWalker.setcontentHandler(ch);
    treeWalker.setDTM(this);

    try
    {
      treeWalker.traverse(nodeHandle);
    }
    finally
    {
      treeWalker.setcontentHandler(null);
    }
  }

  
  public int getNumberOfNodes()
  {
    return m_size;
  }

  
  protected boolean nextNode()
  {

    if (null == m_incrementalSAXSource)
      return false;

    if (m_endDocumentOccured)
    {
      clearCoRoutine();

      return false;
    }

    Object gotMore = m_incrementalSAXSource.deliverMoreNodes(true);

    
    
    
    
    
    
    
    if (!(gotMore instanceof Boolean))
    {
      if(gotMore instanceof RuntimeException)
      {
        throw (RuntimeException)gotMore;
      }
      else if(gotMore instanceof Exception)
      {
        throw new WrappedRuntimeException((Exception)gotMore);
      }
      
      clearCoRoutine();

      return false;

      
    }

    if (gotMore != Boolean.TRUE)
    {

      
      clearCoRoutine();  

      
    }

    return true;
  }

  
  private final boolean isTextType(int type)
  {
    return (DTM.TEXT_NODE == type || DTM.CDATA_SECTION_NODE == type);
  }

















  
  protected int addNode(int type, int expandedTypeID,
                        int parentIndex, int previousSibling,
                        int dataOrPrefix, boolean canHaveFirstChild)
  {
    
    int nodeIndex = m_size++;

    
    if(m_dtmIdent.size() == (nodeIndex>>>DTMManager.IDENT_DTM_NODE_BITS))
    {
      addNewDTMID(nodeIndex);
    }

    m_firstch.addElement(canHaveFirstChild ? NOTPROCESSED : DTM.NULL);
    m_nextsib.addElement(NOTPROCESSED);
    m_parent.addElement(parentIndex);
    m_exptype.addElement(expandedTypeID);
    m_dataOrQName.addElement(dataOrPrefix);

    if (m_prevsib != null) {
      m_prevsib.addElement(previousSibling);
    }

    if (DTM.NULL != previousSibling) {
      m_nextsib.setElementAt(nodeIndex,previousSibling);
    }

    if (m_locator != null && m_useSourceLocationProperty) {
      setSourceLocation();
    }

    
    

    
    switch(type)
    {
    case DTM.NAMESPACE_NODE:
      declareNamespaceInContext(parentIndex,nodeIndex);
      break;
    case DTM.ATTRIBUTE_NODE:
      break;
    default:
      if (DTM.NULL == previousSibling && DTM.NULL != parentIndex) {
        m_firstch.setElementAt(nodeIndex,parentIndex);
      }
      break;
    }

    return nodeIndex;
  }

  
  protected void addNewDTMID(int nodeIndex) {
    try
    {
      if(m_mgr==null)
        throw new ClassCastException();
                              
                              
      DTMManagerDefault mgrD=(DTMManagerDefault)m_mgr;
      int id=mgrD.getFirstFreeDTMID();
      mgrD.addDTM(this,id,nodeIndex);
      m_dtmIdent.addElement(id<<DTMManager.IDENT_DTM_NODE_BITS);
    }
    catch(ClassCastException e)
    {
      
      
      
      error(XMLMessages.createXMLMessage(XMLErrorResources.ER_NO_DTMIDS_AVAIL, null));
    }
  }

  
  protected void setSourceLocation() {
    m_sourceSystemId.addElement(m_locator.getSystemId());
    m_sourceLine.addElement(m_locator.getLineNumber());
    m_sourceColumn.addElement(m_locator.getColumnNumber());

    
    
    
    if (m_sourceSystemId.size() != m_size) {
        System.err.println(""CODING ERROR in Source Location: "" + m_size
                           + "" != ""
                            + m_sourceSystemId.size());
        System.exit(1);
    }
  }

  
  public String getNodeValue(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int type = _type(identity);

    if (isTextType(type))
    {
      int dataIndex = _dataOrQName(identity);
      int offset = m_data.elementAt(dataIndex);
      int length = m_data.elementAt(dataIndex + 1);

      
      return m_chars.getString(offset, length);
    }
    else if (DTM.ELEMENT_NODE == type || DTM.DOCUMENT_FRAGMENT_NODE == type
             || DTM.DOCUMENT_NODE == type)
    {
      return null;
    }
    else
    {
      int dataIndex = _dataOrQName(identity);

      if (dataIndex < 0)
      {
        dataIndex = -dataIndex;
        dataIndex = m_data.elementAt(dataIndex + 1);
      }

      return m_valuesOrPrefixes.indexToString(dataIndex);
    }
  }

  
  public String getLocalName(int nodeHandle)
  {
    return m_expandedNameTable.getLocalName(_exptype(makeNodeIdentity(nodeHandle)));
  }

  
  public String getUnparsedEntityURI(String name)
  {

    String url = """";

    if (null == m_entities)
      return url;

    int n = m_entities.size();

    for (int i = 0; i < n; i += ENTITY_FIELDS_PER)
    {
      String ename = (String) m_entities.elementAt(i + ENTITY_FIELD_NAME);

      if (null != ename && ename.equals(name))
      {
        String nname = (String) m_entities.elementAt(i
                         + ENTITY_FIELD_NOTATIONNAME);

        if (null != nname)
        {

          
          
          
          
          
          
          
          
          
          url = (String) m_entities.elementAt(i + ENTITY_FIELD_SYSTEMID);

          if (null == url)
          {
            url = (String) m_entities.elementAt(i + ENTITY_FIELD_PUBLICID);
          }
        }

        break;
      }
    }

    return url;
  }

  
  public String getPrefix(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int type = _type(identity);

    if (DTM.ELEMENT_NODE == type)
    {
      int prefixIndex = _dataOrQName(identity);

      if (0 == prefixIndex)
        return """";
      else
      {
        String qname = m_valuesOrPrefixes.indexToString(prefixIndex);

        return getPrefix(qname, null);
      }
    }
    else if (DTM.ATTRIBUTE_NODE == type)
    {
      int prefixIndex = _dataOrQName(identity);

      if (prefixIndex < 0)
      {
        prefixIndex = m_data.elementAt(-prefixIndex);

        String qname = m_valuesOrPrefixes.indexToString(prefixIndex);

        return getPrefix(qname, null);
      }
    }

    return """";
  }

  
  public int getAttributeNode(int nodeHandle, String namespaceURI,
                              String name)
  {

    for (int attrH = getFirstAttribute(nodeHandle); DTM.NULL != attrH;
            attrH = getNextAttribute(attrH))
    {
      String attrNS = getNamespaceURI(attrH);
      String attrName = getLocalName(attrH);
      boolean nsMatch = namespaceURI == attrNS
                        || (namespaceURI != null
                            && namespaceURI.equals(attrNS));

      if (nsMatch && name.equals(attrName))
        return attrH;
    }

    return DTM.NULL;
  }

  
  public String getDocumentTypeDeclarationPublicIdentifier()
  {

    
    error(XMLMessages.createXMLMessage(XMLErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return null;
  }

  
  public String getNamespaceURI(int nodeHandle)
  {

    return m_expandedNameTable.getNamespace(_exptype(makeNodeIdentity(nodeHandle)));
  }

  
  public XMLString getStringValue(int nodeHandle)
  {
    int identity = makeNodeIdentity(nodeHandle);
    int type;
    if(identity==DTM.NULL) 
      type = DTM.NULL;
    else
      type= _type(identity);

    if (isTextType(type))
    {
      int dataIndex = _dataOrQName(identity);
      int offset = m_data.elementAt(dataIndex);
      int length = m_data.elementAt(dataIndex + 1);

      return m_xstrf.newstr(m_chars, offset, length);
    }
    else
    {
      int firstChild = _firstch(identity);

      if (DTM.NULL != firstChild)
      {
        int offset = -1;
        int length = 0;
        int startNode = identity;

        identity = firstChild;

        do {
          type = _type(identity);

          if (isTextType(type))
          {
            int dataIndex = _dataOrQName(identity);

            if (-1 == offset)
            {
              offset = m_data.elementAt(dataIndex);
            }

            length += m_data.elementAt(dataIndex + 1);
          }

          identity = getNextNodeIdentity(identity);
        } while (DTM.NULL != identity && (_parent(identity) >= startNode));

        if (length > 0)
        {
          return m_xstrf.newstr(m_chars, offset, length);
        }
      }
      else if(type != DTM.ELEMENT_NODE)
      {
        int dataIndex = _dataOrQName(identity);

        if (dataIndex < 0)
        {
          dataIndex = -dataIndex;
          dataIndex = m_data.elementAt(dataIndex + 1);
        }
        return m_xstrf.newstr(m_valuesOrPrefixes.indexToString(dataIndex));
      }
    }

    return m_xstrf.emptystr();
  }
  
  
  public boolean isWhitespace(int nodeHandle)
  {
    int identity = makeNodeIdentity(nodeHandle);
    int type;
    if(identity==DTM.NULL) 
      type = DTM.NULL;
    else
      type= _type(identity);

    if (isTextType(type))
    {
      int dataIndex = _dataOrQName(identity);
      int offset = m_data.elementAt(dataIndex);
      int length = m_data.elementAt(dataIndex + 1);

      return m_chars.isWhitespace(offset, length);
    }
    return false;
  }

  
  public int getElementById(String elementId)
  {

    Integer intObj;
    boolean isMore = true;

    do
    {
      intObj = (Integer) m_idAttributes.get(elementId);

      if (null != intObj)
        return makeNodeHandle(intObj.intValue());

      if (!isMore || m_endDocumentOccured)
        break;

      isMore = nextNode();
    }
    while (null == intObj);

    return DTM.NULL;
  }

  
  public String getPrefix(String qname, String uri)
  {

    String prefix;
    int uriIndex = -1;

    if (null != uri && uri.length() > 0)
    {

      do
      {
        uriIndex = m_prefixMappings.indexOf(uri, ++uriIndex);
      } while ( (uriIndex & 0x01) == 0);

      if (uriIndex >= 0)
      {
        prefix = (String) m_prefixMappings.elementAt(uriIndex - 1);
      }
      else if (null != qname)
      {
        int indexOfNSSep = qname.indexOf(':');

        if (qname.equals(""xmlns""))
          prefix = """";
        else if (qname.startsWith(""xmlns:""))
          prefix = qname.substring(indexOfNSSep + 1);
        else
          prefix = (indexOfNSSep > 0)
                   ? qname.substring(0, indexOfNSSep) : null;
      }
      else
      {
        prefix = null;
      }
    }
    else if (null != qname)
    {
      int indexOfNSSep = qname.indexOf(':');

      if (indexOfNSSep > 0)
      {
        if (qname.startsWith(""xmlns:""))
          prefix = qname.substring(indexOfNSSep + 1);
        else
          prefix = qname.substring(0, indexOfNSSep);	
      }
      else
      {
      	if (qname.equals(""xmlns""))
      	  prefix = """";
      	else
      	  prefix = null;
      }
    }
    else
    {
      prefix = null;
    }

    return prefix;
  }
  
  
  public int getIdForNamespace(String uri)
  {

     return m_valuesOrPrefixes.stringToIndex(uri);
    
  }

    
  public String getNamespaceURI(String prefix)
  {

    String uri = """";
    int prefixIndex = m_contextIndexes.peek() - 1 ;

    if(null == prefix)
      prefix = """";

      do
      {
        prefixIndex = m_prefixMappings.indexOf(prefix, ++prefixIndex);
      } while ( (prefixIndex >= 0) && (prefixIndex & 0x01) == 0x01);

      if (prefixIndex > -1)
      {
        uri = (String) m_prefixMappings.elementAt(prefixIndex + 1);
      }


    return uri;
  }

  
  public void setIDAttribute(String id, int elem)
  {
    m_idAttributes.put(id, new Integer(elem));
  }

  
  protected void charactersFlush()
  {

    if (m_textPendingStart >= 0)  
    {
      int length = m_chars.size() - m_textPendingStart;
      boolean doStrip = false;

      if (getShouldStripWhitespace())
      {
        doStrip = m_chars.isWhitespace(m_textPendingStart, length);
      }

      if (doStrip)
        m_chars.setLength(m_textPendingStart);  
      else
      {
        int exName = m_expandedNameTable.getExpandedTypeID(DTM.TEXT_NODE);
        int dataIndex = m_data.size();

        m_previous = addNode(m_coalescedTextType, exName,
                             m_parents.peek(), m_previous, dataIndex, false);

        m_data.addElement(m_textPendingStart);
        m_data.addElement(length);
      }

      
      m_textPendingStart = -1;
      m_textType = m_coalescedTextType = DTM.TEXT_NODE;
    }
  }

  
  
  

  
  public InputSource resolveEntity(String publicId, String systemId)
          throws SAXException
  {
    return null;
  }

  
  
  

  
  public void notationDecl(String name, String publicId, String systemId)
          throws SAXException
  {

    
  }

  
  public void unparsedEntityDecl(
          String name, String publicId, String systemId, String notationName)
            throws SAXException
  {

    if (null == m_entities)
    {
      m_entities = new Vector();
    }

    try
    {
      systemId = SystemIDResolver.getAbsoluteURI(systemId,
                                                 getDocumentBaseURI());
    }
    catch (Exception e)
    {
      throw new org.xml.sax.SAXException(e);
    }

    
    m_entities.addElement(publicId);

    
    m_entities.addElement(systemId);

    
    m_entities.addElement(notationName);

    
    m_entities.addElement(name);
  }

  
  
  

  
  public void setDocumentLocator(Locator locator)
  {
    m_locator = locator;
    m_systemId = locator.getSystemId();
  }

  
  public void startDocument() throws SAXException
  {
    if (DEBUG)
      System.out.println(""startDocument"");

		
    int doc = addNode(DTM.DOCUMENT_NODE,
                      m_expandedNameTable.getExpandedTypeID(DTM.DOCUMENT_NODE),
                      DTM.NULL, DTM.NULL, 0, true);

    m_parents.push(doc);
    m_previous = DTM.NULL;

    m_contextIndexes.push(m_prefixMappings.size());  
  }

  
  public void endDocument() throws SAXException
  {
    if (DEBUG)
      System.out.println(""endDocument"");

		charactersFlush();

    m_nextsib.setElementAt(NULL,0);

    if (m_firstch.elementAt(0) == NOTPROCESSED)
      m_firstch.setElementAt(NULL,0);

    if (DTM.NULL != m_previous)
      m_nextsib.setElementAt(DTM.NULL,m_previous);

    m_parents = null;
    m_prefixMappings = null;
    m_contextIndexes = null;

    m_endDocumentOccured = true;
    
    
    m_locator = null;
  }

  
  public void startPrefixMapping(String prefix, String uri)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""startPrefixMapping: prefix: "" + prefix + "", uri: ""
                         + uri);

    if(null == prefix)
      prefix = """";
    m_prefixMappings.addElement(prefix);  
    m_prefixMappings.addElement(uri);  
  }

  
  public void endPrefixMapping(String prefix) throws SAXException
  {
    if (DEBUG)
      System.out.println(""endPrefixMapping: prefix: "" + prefix);

    if(null == prefix)
      prefix = """";

    int index = m_contextIndexes.peek() - 1;

    do
    {
      index = m_prefixMappings.indexOf(prefix, ++index);
    } while ( (index >= 0) && ((index & 0x01) == 0x01) );


    if (index > -1)
    {
      m_prefixMappings.setElementAt(""%@$#^@#"", index);
      m_prefixMappings.setElementAt(""%@$#^@#"", index + 1);
    }

    
  }

  
  protected boolean declAlreadyDeclared(String prefix)
  {

    int startDecls = m_contextIndexes.peek();
    java.util.Vector prefixMappings = m_prefixMappings;
    int nDecls = prefixMappings.size();

    for (int i = startDecls; i < nDecls; i += 2)
    {
      String prefixDecl = (String) prefixMappings.elementAt(i);

      if (prefixDecl == null)
        continue;

      if (prefixDecl.equals(prefix))
        return true;
    }

    return false;
  }

	boolean m_pastFirstElement=false;

  
  public void startElement(
          String uri, String localName, String qName, Attributes attributes)
            throws SAXException
  {
   if (DEBUG)
	 {
      System.out.println(""startElement: uri: "" + uri + "", localname: ""
												 + localName + "", qname: ""+qName+"", atts: "" + attributes);

			boolean DEBUG_ATTRS=true;
			if(DEBUG_ATTRS & attributes!=null)
			{
				int n = attributes.getLength();
				if(n==0)
					System.out.println(""	empty attribute list"");
				else for (int i = 0; i < n; i++)
					System.out.println(""	 attr: uri: "" + attributes.getURI(i) +
														 "", localname: "" + attributes.getLocalName(i) +
														 "", qname: "" + attributes.getQName(i) +
														 "", type: "" + attributes.getType(i) +
														 "", value: "" + attributes.getValue(i)
														 );
			}
	 }
		
    charactersFlush();

    int exName = m_expandedNameTable.getExpandedTypeID(uri, localName, DTM.ELEMENT_NODE);
    String prefix = getPrefix(qName, uri);
    int prefixIndex = (null != prefix)
                      ? m_valuesOrPrefixes.stringToIndex(qName) : 0;

    int elemNode = addNode(DTM.ELEMENT_NODE, exName,
                           m_parents.peek(), m_previous, prefixIndex, true);

    if(m_indexing)
      indexNode(exName, elemNode);
    

    m_parents.push(elemNode);

    int startDecls = m_contextIndexes.peek();
    int nDecls = m_prefixMappings.size();
    int prev = DTM.NULL;

    if(!m_pastFirstElement)
    {
      
      prefix=""xml"";
      String declURL = ""http:
      exName = m_expandedNameTable.getExpandedTypeID(null, prefix, DTM.NAMESPACE_NODE);
      int val = m_valuesOrPrefixes.stringToIndex(declURL);
      prev = addNode(DTM.NAMESPACE_NODE, exName, elemNode,
                     prev, val, false);
      m_pastFirstElement=true;
    }

    for (int i = startDecls; i < nDecls; i += 2)
    {
      prefix = (String) m_prefixMappings.elementAt(i);

      if (prefix == null)
        continue;

      String declURL = (String) m_prefixMappings.elementAt(i + 1);

      exName = m_expandedNameTable.getExpandedTypeID(null, prefix, DTM.NAMESPACE_NODE);

      int val = m_valuesOrPrefixes.stringToIndex(declURL);

      prev = addNode(DTM.NAMESPACE_NODE, exName, elemNode,
                     prev, val, false);
    }

    int n = attributes.getLength();

    for (int i = 0; i < n; i++)
    {
      String attrUri = attributes.getURI(i);
      String attrQName = attributes.getQName(i);
      String valString = attributes.getValue(i);

      prefix = getPrefix(attrQName, attrUri);

      int nodeType;
      
       String attrLocalName = attributes.getLocalName(i);

      if ((null != attrQName)
              && (attrQName.equals(""xmlns"")
                  || attrQName.startsWith(""xmlns:"")))
      {
        if (declAlreadyDeclared(prefix))
          continue;  

        nodeType = DTM.NAMESPACE_NODE;
      }
      else
      {
        nodeType = DTM.ATTRIBUTE_NODE;

        if (attributes.getType(i).equalsIgnoreCase(""ID""))
          setIDAttribute(valString, elemNode);
      }

      
      
      if(null == valString)
        valString = """";

      int val = m_valuesOrPrefixes.stringToIndex(valString);
      

      if (null != prefix)
      {

        prefixIndex = m_valuesOrPrefixes.stringToIndex(attrQName);

        int dataIndex = m_data.size();

        m_data.addElement(prefixIndex);
        m_data.addElement(val);

        val = -dataIndex;
      }

      exName = m_expandedNameTable.getExpandedTypeID(attrUri, attrLocalName, nodeType);
      prev = addNode(nodeType, exName, elemNode, prev, val,
                     false);
    }

    if (DTM.NULL != prev)
      m_nextsib.setElementAt(DTM.NULL,prev);

    if (null != m_wsfilter)
    {
      short wsv = m_wsfilter.getShouldStripSpace(makeNodeHandle(elemNode), this);
      boolean shouldStrip = (DTMWSFilter.INHERIT == wsv)
                            ? getShouldStripWhitespace()
                            : (DTMWSFilter.STRIP == wsv);

      pushShouldStripWhitespace(shouldStrip);
    }

    m_previous = DTM.NULL;

    m_contextIndexes.push(m_prefixMappings.size());  
  }

  
  public void endElement(String uri, String localName, String qName)
          throws SAXException
  {
   if (DEBUG)
      System.out.println(""endElement: uri: "" + uri + "", localname: ""
												 + localName + "", qname: ""+qName);

    charactersFlush();

    
    
    m_contextIndexes.quickPop(1);

    
    int topContextIndex = m_contextIndexes.peek();
    if (topContextIndex != m_prefixMappings.size()) {
      m_prefixMappings.setSize(topContextIndex);
    }

    int lastNode = m_previous;

    m_previous = m_parents.pop();

    
    if (DTM.NULL == lastNode)
      m_firstch.setElementAt(DTM.NULL,m_previous);
    else
      m_nextsib.setElementAt(DTM.NULL,lastNode);

    popShouldStripWhitespace();
  }

  
  public void characters(char ch[], int start, int length) throws SAXException
  {
    if (m_textPendingStart == -1)  
    {
      m_textPendingStart = m_chars.size();
      m_coalescedTextType = m_textType;
    }
    
    
    
    
    else if (m_textType == DTM.TEXT_NODE)
    {
      m_coalescedTextType = DTM.TEXT_NODE;
    }

    m_chars.append(ch, start, length);
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws SAXException
  {

    
    
    characters(ch, start, length);
  }

  
  public void processingInstruction(String target, String data)
          throws SAXException
  {
    if (DEBUG)
		 System.out.println(""processingInstruction: target: "" + target +"", data: ""+data);

    charactersFlush();

    int exName = m_expandedNameTable.getExpandedTypeID(null, target,
                                         DTM.PROCESSING_INSTRUCTION_NODE);
    int dataIndex = m_valuesOrPrefixes.stringToIndex(data);

    m_previous = addNode(DTM.PROCESSING_INSTRUCTION_NODE, exName,
                         m_parents.peek(), m_previous,
                         dataIndex, false);
  }

  
  public void skippedEntity(String name) throws SAXException
  {

    
    
  }

  
  
  

  
  public void warning(SAXParseException e) throws SAXException
  {

    
    System.err.println(e.getMessage());
  }

  
  public void error(SAXParseException e) throws SAXException
  {
    throw e;
  }

  
  public void fatalError(SAXParseException e) throws SAXException
  {
    throw e;
  }

  
  
  

  
  public void elementDecl(String name, String model) throws SAXException
  {

    
  }

  
  public void attributeDecl(
          String eName, String aName, String type, String valueDefault, String value)
            throws SAXException
  {

    
  }

  
  public void internalEntityDecl(String name, String value)
          throws SAXException
  {

    
  }

  
  public void externalEntityDecl(
          String name, String publicId, String systemId) throws SAXException
  {

    
  }

  
  
  

  
  public void startDTD(String name, String publicId, String systemId)
          throws SAXException
  {

    m_insideDTD = true;
  }

  
  public void endDTD() throws SAXException
  {

    m_insideDTD = false;
  }

  
  public void startEntity(String name) throws SAXException
  {

    
  }

  
  public void endEntity(String name) throws SAXException
  {

    
  }

  
  public void startCDATA() throws SAXException
  {
    m_textType = DTM.CDATA_SECTION_NODE;
  }

  
  public void endCDATA() throws SAXException
  {
    m_textType = DTM.TEXT_NODE;
  }

  
  public void comment(char ch[], int start, int length) throws SAXException
  {

    if (m_insideDTD)      
      return;

    charactersFlush();

    int exName = m_expandedNameTable.getExpandedTypeID(DTM.COMMENT_NODE);

    
    
    int dataIndex = m_valuesOrPrefixes.stringToIndex(new String(ch, start,
                      length));


    m_previous = addNode(DTM.COMMENT_NODE, exName,
                         m_parents.peek(), m_previous, dataIndex, false);
  }

  
  public void setProperty(String property, Object value)
  {
  }

  
  public SourceLocator getSourceLocatorFor(int node)
  {
    if (m_useSourceLocationProperty)
    {

      node = makeNodeIdentity(node);
      

      return new NodeLocator(null,
                             m_sourceSystemId.elementAt(node),
                             m_sourceLine.elementAt(node),
                             m_sourceColumn.elementAt(node));
    }
    else if(m_locator!=null)
    {
    	return new NodeLocator(null,m_locator.getSystemId(),-1,-1);
    }
    else if(m_systemId!=null)
    {
    	return new NodeLocator(null,m_systemId,-1,-1);
    }
    return null;
  }
}
"
org.apache.xalan.extensions.ExpressionContext,7,1,0,17,7,21,15,3,7,2.0,7,0.0,0,0.0,0.476190476,0,0,0.0,1,1.0,0,"
package org.apache.xalan.extensions;

import javax.xml.transform.ErrorListener;

import org.apache.xpath.objects.XObject;
import org.w3c.dom.Node;
import org.w3c.dom.traversal.NodeIterator;


public interface ExpressionContext
{

  
  public Node getContextNode();

  
  public NodeIterator getContextNodes();
  
  
  public ErrorListener getErrorListener();

  
  public double toNumber(Node n);

  
  public String toString(Node n);

  
  public XObject getVariableOrParam(org.apache.xml.utils.QName qname)
            throws javax.xml.transform.TransformerException;
  
  
  public org.apache.xpath.XPathContext getXPathContext()
            throws javax.xml.transform.TransformerException;

}
"
org.apache.xalan.templates.ElemWhen,7,3,0,9,16,9,1,8,6,0.5,55,1.0,1,0.97029703,0.314285714,2,5,6.714285714,2,1.0,1,"
package org.apache.xalan.templates;

import org.apache.xpath.XPath;


public class ElemWhen extends ElemTemplateElement
{

  
  private XPath m_test;

  
  public void setTest(XPath v)
  {
    m_test = v;
  }

  
  public XPath getTest()
  {
    return m_test;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_WHEN;
  }
  
  
  public void compose(StylesheetRoot sroot) 
    throws javax.xml.transform.TransformerException
  {
    super.compose(sroot);
    java.util.Vector vnames = sroot.getComposeState().getVariableNames();
    if(null != m_test)
      m_test.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_WHEN_STRING;
  }

  
  public ElemWhen(){}
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  		m_test.getExpression().callVisitors(m_test, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xalan.xsltc.dom.NodeIteratorBase,11,1,0,2,18,19,0,2,9,0.75,138,1.0,0,0.0,0.424242424,0,0,11.0,3,1.2727,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public abstract class NodeIteratorBase implements NodeIterator {

    
    protected int _last = -1;

    
    protected int _position = 0;

    
    protected int _markedNode;

    
    protected int _startNode = NodeIterator.END;

    
    protected boolean _includeSelf = false;

    
    protected boolean _isRestartable = true;

    
    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
    }

    
    abstract public NodeIterator setStartNode(int node);

    
    public NodeIterator reset() {
	final boolean temp = _isRestartable;
	_isRestartable = true;
	
	setStartNode(_includeSelf ? _startNode + 1 : _startNode);
	_isRestartable = temp;
	return this;
    }

    
    public NodeIterator includeSelf() {
	_includeSelf = true;
	return this;
    }

    
    public int getLast() {
	if (_last == -1) {
	    final int temp = _position;
	    setMark();
	    reset();
	    do {
		_last++;
	    } while (next() != END);
	    gotoMark();
	    _position = temp;
	}
	return _last;
    }

    
    public int getPosition() {
	return _position == 0 ? 1 : _position;
    }

    
    public boolean isReverse() {
	return false;
    }
    
    
    public NodeIterator cloneIterator() {
	try {
	    final NodeIteratorBase clone = (NodeIteratorBase)super.clone();
	    clone._isRestartable = false;
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    
    protected final int returnNode(final int node) {
	_position++;
	return node;
    }
    
    
    protected final NodeIterator resetPosition() {
	_position = 0;
	return this;
    }
}
"
org.apache.xpath.XPath,17,1,0,62,64,78,47,15,17,0.96875,462,0.2,1,0.0,0.219607843,0,0,25.58823529,2,0.9412,1,"
package org.apache.xpath;

import java.io.Serializable;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.FunctionTable;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xpath.functions.Function;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;


public class XPath implements Serializable, ExpressionOwner
{

  
  private Expression m_mainExp;

  
  public Expression getExpression()
  {
    return m_mainExp;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_mainExp.fixupVariables(vars, globalsSize);
  }

  
  public void setExpression(Expression exp)
  {
  	if(null != m_mainExp)
    	exp.exprSetParent(m_mainExp.exprGetParent()); 
    m_mainExp = exp;
  }

  
  public SourceLocator getLocator()
  {
    return m_mainExp;
  }














  
  String m_patternString;

  
  public String getPatternString()
  {
    return m_patternString;
  }

  
  public static final int SELECT = 0;

  
  public static final int MATCH = 1;

  
  public XPath(
          String exprString, SourceLocator locator, PrefixResolver prefixResolver, int type,
          ErrorListener errorListener)
            throws javax.xml.transform.TransformerException
  {      
    if(null == errorListener)
      errorListener = new org.apache.xml.utils.DefaultErrorHandler();
    
    m_patternString = exprString;

    XPathParser parser = new XPathParser(errorListener, locator);
    Compiler compiler = new Compiler(errorListener, locator);

    if (SELECT == type)
      parser.initXPath(compiler, exprString, prefixResolver);
    else if (MATCH == type)
      parser.initMatchPattern(compiler, exprString, prefixResolver);
    else
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANNOT_DEAL_XPATH_TYPE, new Object[]{Integer.toString(type)})); 

    
    Expression expr = compiler.compile(0);

    
    this.setExpression(expr);
    
    if((null != locator) && locator instanceof ExpressionNode)
    {
    	expr.exprSetParent((ExpressionNode)locator);
    }

  }
  
  
  public XPath(
          String exprString, SourceLocator locator, PrefixResolver prefixResolver, int type)
            throws javax.xml.transform.TransformerException
  {  
    this(exprString, locator, prefixResolver, type, null);    
  }

  
  public XPath(Expression expr)
  {  
    this.setExpression(expr);   
  }
  
  
  public XObject execute(
          XPathContext xctxt, org.w3c.dom.Node contextNode, 
          PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {
    return execute(
          xctxt, xctxt.getDTMHandleFromNode(contextNode), 
          namespaceContext);
  }
  

  
  public XObject execute(
          XPathContext xctxt, int contextNode, PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    xctxt.pushNamespaceContext(namespaceContext);

    xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);

    XObject xobj = null;

    try
    {
      xobj = m_mainExp.execute(xctxt);
    }
    catch (TransformerException te)
    {
      te.setLocator(this.getLocator());
      ErrorListener el = xctxt.getErrorListener();
      if(null != el) 
      {
        el.error(te);
      }
      else
        throw te;
    }
    catch (Exception e)
    {
      while (e instanceof org.apache.xml.utils.WrappedRuntimeException)
      {
        e = ((org.apache.xml.utils.WrappedRuntimeException) e).getException();
      }
      

      String msg = e.getMessage();
      
      if (msg == null || msg.length() == 0) {
           msg = XSLMessages.createXPATHMessage(
               XPATHErrorResources.ER_XPATH_ERROR, null);
     
      }  
      TransformerException te = new TransformerException(msg,
              getLocator(), e);
      ErrorListener el = xctxt.getErrorListener();
      
      if(null != el) 
      {
        el.fatalError(te);
      }
      else
        throw te;
    }
    finally
    {
      xctxt.popNamespaceContext();

      xctxt.popCurrentNodeAndExpression();
    }

    return xobj;
  }
  
  
  public boolean bool(
          XPathContext xctxt, int contextNode, PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    xctxt.pushNamespaceContext(namespaceContext);

    xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);

    try
    {
      return m_mainExp.bool(xctxt);
    }
    catch (TransformerException te)
    {
      te.setLocator(this.getLocator());
      ErrorListener el = xctxt.getErrorListener();
      if(null != el) 
      {
        el.error(te);
      }
      else
        throw te;
    }
    catch (Exception e)
    {
      while (e instanceof org.apache.xml.utils.WrappedRuntimeException)
      {
        e = ((org.apache.xml.utils.WrappedRuntimeException) e).getException();
      }
      

      String msg = e.getMessage();
      
      if (msg == null || msg.length() == 0) {
           msg = XSLMessages.createXPATHMessage(
               XPATHErrorResources.ER_XPATH_ERROR, null);
     
      }        
      
      TransformerException te = new TransformerException(msg,
              getLocator(), e);
      ErrorListener el = xctxt.getErrorListener();
      
      if(null != el) 
      {
        el.fatalError(te);
      }
      else
        throw te;
    }
    finally
    {
      xctxt.popNamespaceContext();

      xctxt.popCurrentNodeAndExpression();
    }

    return false;
  }

  
  private static final boolean DEBUG_MATCHES = false;

  
  public double getMatchScore(XPathContext xctxt, int context)
          throws javax.xml.transform.TransformerException
  {

    xctxt.pushCurrentNode(context);
    xctxt.pushCurrentExpressionNode(context);

    try
    {
      XObject score = m_mainExp.execute(xctxt);

      if (DEBUG_MATCHES)
      {
        DTM dtm = xctxt.getDTM(context);
        System.out.println(""score: "" + score.num() + "" for ""
                           + dtm.getNodeName(context) + "" for xpath ""
                           + this.getPatternString());
      }

      return score.num();
    }
    finally
    {
      xctxt.popCurrentNode();
      xctxt.popCurrentExpressionNode();
    }

    
  }

  
  public void installFunction(String name, int funcIndex, Function func)
  {
    FunctionTable.installFunction(func, funcIndex);
  }

  
  public void warn(
          XPathContext xctxt, int sourceNode, String msg, Object[] args)
            throws javax.xml.transform.TransformerException
  {

    String fmsg = XSLMessages.createXPATHWarning(msg, args);
    ErrorListener ehandler = xctxt.getErrorListener();

    if (null != ehandler)
    {

      
      ehandler.warning(new TransformerException(fmsg, (SAXSourceLocator)xctxt.getSAXLocator()));
    }
  }

  
  public void assertion(boolean b, String msg)
  {

    if (!b)
    {
      String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ msg });

      throw new RuntimeException(fMsg);
    }
  }

  
  public void error(
          XPathContext xctxt, int sourceNode, String msg, Object[] args)
            throws javax.xml.transform.TransformerException
  {

    String fmsg = XSLMessages.createXPATHMessage(msg, args);
    ErrorListener ehandler = xctxt.getErrorListener();

    if (null != ehandler)
    {
      ehandler.fatalError(new TransformerException(fmsg,
                              (SAXSourceLocator)xctxt.getSAXLocator()));
    }
    else
    {
      SourceLocator slocator = xctxt.getSAXLocator();
      System.out.println(fmsg + ""; file "" + slocator.getSystemId()
                         + ""; line "" + slocator.getLineNumber() + ""; column ""
                         + slocator.getColumnNumber());
    }
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	m_mainExp.callVisitors(this, visitor);
  }

  
  public static final double MATCH_SCORE_NONE = Double.NEGATIVE_INFINITY;

  
  public static final double MATCH_SCORE_QNAME = 0.0;

  
  public static final double MATCH_SCORE_NSWILD = -0.25;

  
  public static final double MATCH_SCORE_NODETEST = -0.5;

  
  public static final double MATCH_SCORE_OTHER = 0.5;
}
"
org.apache.xalan.transformer.MsgMgr,12,1,0,12,20,46,11,2,12,0.0,176,1.0,1,0.0,0.489583333,0,0,13.58333333,1,0.9167,1,"
package org.apache.xalan.transformer;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;

import org.w3c.dom.Node;


public class MsgMgr
{

  
  public MsgMgr(TransformerImpl transformer)
  {
    m_transformer = transformer;
  }

  
  private TransformerImpl m_transformer;

  
  public void message(SourceLocator srcLctr, String msg, boolean terminate) throws TransformerException
  {

    ErrorListener errHandler = m_transformer.getErrorListener();

    if (null != errHandler)
    {
      errHandler.warning(new TransformerException(msg, srcLctr));
    }
    else
    {
      if (terminate)
        throw new TransformerException(msg, srcLctr);
      else
        System.out.println(msg);
    }
  }

  
  public void warn(SourceLocator srcLctr, String msg) throws TransformerException
  {
    warn(srcLctr, null, null, msg, null);
  }

  
  public void warn(SourceLocator srcLctr, String msg, Object[] args) throws TransformerException
  {
    warn(srcLctr, null, null, msg, args);
  }

  
  public void warn(SourceLocator srcLctr, Node styleNode, Node sourceNode, String msg)
          throws TransformerException
  {
    warn(srcLctr, styleNode, sourceNode, msg, null);
  }

  
  public void warn(SourceLocator srcLctr, Node styleNode, Node sourceNode, String msg, Object args[])
          throws TransformerException
  {

    String formattedMsg = XSLMessages.createWarning(msg, args);
    ErrorListener errHandler = m_transformer.getErrorListener();

    if (null != errHandler)
      errHandler.warning(new TransformerException(formattedMsg, srcLctr));
    else
      System.out.println(formattedMsg);
  }

  

  
  public void error(SourceLocator srcLctr, String msg) throws TransformerException
  {
    error(srcLctr, null, null, msg, null);
  }

  
  public void error(SourceLocator srcLctr, String msg, Object[] args) throws TransformerException
  {
    error(srcLctr, null, null, msg, args);
  }

  
  public void error(SourceLocator srcLctr, String msg, Exception e) throws TransformerException
  {
    error(srcLctr, msg, null, e);
  }

  
  public void error(SourceLocator srcLctr, String msg, Object args[], Exception e) throws TransformerException
  {

    
    String formattedMsg = XSLMessages.createMessage(msg, args);

    
    
    
    
    ErrorListener errHandler = m_transformer.getErrorListener();

    if (null != errHandler)
      errHandler.fatalError(new TransformerException(formattedMsg, srcLctr));
    else
      throw new TransformerException(formattedMsg, srcLctr);
  }

  
  public void error(SourceLocator srcLctr, Node styleNode, Node sourceNode, String msg)
          throws TransformerException
  {
    error(srcLctr, styleNode, sourceNode, msg, null);
  }

  
  public void error(SourceLocator srcLctr, Node styleNode, Node sourceNode, String msg, Object args[])
          throws TransformerException
  {

    String formattedMsg = XSLMessages.createMessage(msg, args);

    
    
    
    
    ErrorListener errHandler = m_transformer.getErrorListener();

    if (null != errHandler)
      errHandler.fatalError(new TransformerException(formattedMsg, srcLctr));
    else
      throw new TransformerException(formattedMsg, srcLctr);
  }
}
"
org.apache.xalan.transformer.NumeratorFormatter,4,1,0,3,11,4,1,3,0,1.095238095,357,0.428571429,3,0.0,0.428571429,0,0,86.5,7,3.5,1,"
package org.apache.xalan.transformer;

import java.util.Locale;
import java.util.NoSuchElementException;

import org.w3c.dom.Element;


class NumeratorFormatter
{

  
  protected Element m_xslNumberElement;

  
  NumberFormatStringTokenizer m_formatTokenizer;

  
  Locale m_locale;

  
  java.text.NumberFormat m_formatter;

  
  TransformerImpl m_processor;

  
  private final static DecimalToRoman m_romanConvertTable[] = {
    new DecimalToRoman(1000, ""M"", 900, ""CM""),
    new DecimalToRoman(500, ""D"", 400, ""CD""),
    new DecimalToRoman(100L, ""C"", 90L, ""XC""),
    new DecimalToRoman(50L, ""L"", 40L, ""XL""),
    new DecimalToRoman(10L, ""X"", 9L, ""IX""),
    new DecimalToRoman(5L, ""V"", 4L, ""IV""),
    new DecimalToRoman(1L, ""I"", 1L, ""I"") };

  
  private final static char[] m_alphaCountTable = { 'Z',  
                                                    'A', 'B', 'C', 'D', 'E',
                                                    'F', 'G', 'H', 'I', 'J',
                                                    'K', 'L', 'M', 'N', 'O',
                                                    'P', 'Q', 'R', 'S', 'T',
                                                    'U', 'V', 'W', 'X', 'Y' };

  
  NumeratorFormatter(Element xslNumberElement, TransformerImpl processor)
  {
    m_xslNumberElement = xslNumberElement;
    m_processor = processor;
  }  

  
  protected String int2alphaCount(int val, char[] table)
  {

    int radix = table.length;

    
    
    
    char buf[] = new char[100];

    
    int charPos = buf.length - 1;  

    
    int lookupIndex = 1;  

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    int correction = 0;

    
    do
    {

      
      
      
      correction =
        ((lookupIndex == 0) || (correction != 0 && lookupIndex == radix - 1))
        ? (radix - 1) : 0;

      
      lookupIndex = (val + correction) % radix;

      
      val = (val / radix);

      
      if (lookupIndex == 0 && val == 0)
        break;

      
      buf[charPos--] = table[lookupIndex];
    }
    while (val > 0);

    return new String(buf, charPos + 1, (buf.length - charPos - 1));
  }

  
  String long2roman(long val, boolean prefixesAreOK)
  {

    if (val <= 0)
    {
      return ""#E("" + val + "")"";
    }

    String roman = """";
    int place = 0;

    if (val <= 3999L)
    {
      do
      {
        while (val >= m_romanConvertTable[place].m_postValue)
        {
          roman += m_romanConvertTable[place].m_postLetter;
          val -= m_romanConvertTable[place].m_postValue;
        }

        if (prefixesAreOK)
        {
          if (val >= m_romanConvertTable[place].m_preValue)
          {
            roman += m_romanConvertTable[place].m_preLetter;
            val -= m_romanConvertTable[place].m_preValue;
          }
        }

        place++;
      }
      while (val > 0);
    }
    else
    {
      roman = ""#error"";
    }

    return roman;
  }  

  
  class NumberFormatStringTokenizer
  {

    
    private int currentPosition;

    
    private int maxPosition;

    
    private String str;

    
    NumberFormatStringTokenizer(String str)
    {
      this.str = str;
      maxPosition = str.length();
    }
    
    
    void reset()
    {
      currentPosition = 0;
    }

    
    String nextToken()
    {

      if (currentPosition >= maxPosition)
      {
        throw new NoSuchElementException();
      }

      int start = currentPosition;

      while ((currentPosition < maxPosition)
             && Character.isLetterOrDigit(str.charAt(currentPosition)))
      {
        currentPosition++;
      }

      if ((start == currentPosition)
              && (!Character.isLetterOrDigit(str.charAt(currentPosition))))
      {
        currentPosition++;
      }

      return str.substring(start, currentPosition);
    }

    
    boolean hasMoreTokens()
    {
      return (currentPosition >= maxPosition) ? false : true;
    }

    
    int countTokens()
    {

      int count = 0;
      int currpos = currentPosition;

      while (currpos < maxPosition)
      {
        int start = currpos;

        while ((currpos < maxPosition)
               && Character.isLetterOrDigit(str.charAt(currpos)))
        {
          currpos++;
        }

        if ((start == currpos)
                && (Character.isLetterOrDigit(str.charAt(currpos)) == false))
        {
          currpos++;
        }

        count++;
      }

      return count;
    }
  }  
}
"
org.apache.xml.dtm.ref.sax2dtm.SAX2DTM2,35,5,1,34,107,213,20,14,26,0.804812834,2248,1.0,2,0.83919598,0.200980392,2,33,62.6,20,3.6286,2,"
package org.apache.xml.dtm.ref.sax2dtm;

import org.apache.xml.dtm.*;
import org.apache.xml.dtm.ref.*;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringDefault;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xml.res.XMLMessages;
import org.apache.xml.res.XMLErrorResources;
import org.apache.xml.serializer.SerializationHandler;

import javax.xml.transform.Source;
import java.util.Vector;
import org.xml.sax.*;


public class SAX2DTM2 extends SAX2DTM
{

  
   
  
  public final class ChildrenIterator extends InternalAxisIteratorBase
  {

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = (node == DTM.NULL) ? DTM.NULL
                                          : _firstch2(makeNodeIdentity(node));

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      if (_currentNode != NULL) {
        int node = _currentNode;
        _currentNode = _nextsib2(node);
        return returnNode(makeNodeHandle(node));
      }

      return END;
    }
  }  

  
  public final class ParentIterator extends InternalAxisIteratorBase
  {

    
    private int _nodeType = DTM.NULL;

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        
        if (node != DTM.NULL)
          _currentNode = _parent2(makeNodeIdentity(node));
        else
          _currentNode = DTM.NULL;
        
        return resetPosition();
      }

      return this;
    }

    
    public DTMAxisIterator setNodeType(final int type)
    {

      _nodeType = type;

      return this;
    }

    
    public int next()
    {
      int result = _currentNode;
      if (result == END)
        return DTM.NULL;

      
      if (_nodeType == NULL) {
        _currentNode = END;
        return returnNode(makeNodeHandle(result));
      }
      else if (_nodeType >= DTM.NTYPES) {
        if (_nodeType == _exptype2(result)) {
          _currentNode = END;
	  return returnNode(makeNodeHandle(result));
        }
      } 
      else {
        if (_nodeType == _type2(result)) {
	  _currentNode = END;
	  return returnNode(makeNodeHandle(result));          
        }
      }
      
      return DTM.NULL;      
    }
  }  

  
  public final class TypedChildrenIterator extends InternalAxisIteratorBase
  {

    
    private final int _nodeType;

    
    public TypedChildrenIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = (node == DTM.NULL)
                                   ? DTM.NULL
                                   : _firstch2(makeNodeIdentity(_startNode));

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      int node = _currentNode;
      if (node == DTM.NULL)
        return DTM.NULL;

      final int nodeType = _nodeType;

      if (nodeType != DTM.ELEMENT_NODE) {
        while (node != DTM.NULL && _exptype2(node) != nodeType) {
          node = _nextsib2(node);
        }
      }
      
      
      
      
      
      else {
      	int eType;
      	while (node != DTM.NULL) {
      	  eType = _exptype2(node);
      	  if (eType >= DTM.NTYPES)
      	    break;
      	  else
      	    node = _nextsib2(node);
      	}
      }

      if (node == DTM.NULL) {
        _currentNode = DTM.NULL;
        return DTM.NULL;
      } else {
        _currentNode = _nextsib2(node);
        return returnNode(makeNodeHandle(node));
      }

    }

    
    public int getNodeByPosition(int position)
    {
      if (position <= 0)
        return DTM.NULL;
      
      int node = _currentNode; 
      int pos = 0;
      
      final int nodeType = _nodeType;
      if (nodeType != DTM.ELEMENT_NODE) {   
        while (node != DTM.NULL) {
          if (_exptype2(node) == nodeType) {
            pos++;
            if (pos == position)
              return makeNodeHandle(node);
          }
          
          node = _nextsib2(node);
        }
        return NULL;
      }
      else {
      	while (node != DTM.NULL) {
      	  if (_exptype2(node) >= DTM.NTYPES) {
      	    pos++;
      	    if (pos == position)
      	      return makeNodeHandle(node);
      	  }
      	  node = _nextsib2(node);
      	}
      	return NULL;
      }
    }

  }  

  
  public class TypedRootIterator extends RootIterator
  {

    
    private final int _nodeType;

    
    public TypedRootIterator(int nodeType)
    {
      super();
      _nodeType = nodeType;
    }

    
    public int next()
    {
      if(_startNode == _currentNode)
        return NULL;

      final int node = _startNode;
      int expType = _exptype2(makeNodeIdentity(node));

      _currentNode = node;

      if (_nodeType >= DTM.NTYPES) {
        if (_nodeType == expType) {
          return returnNode(node);
        }
      } 
      else {
        if (expType < DTM.NTYPES) {
          if (expType == _nodeType) {
            return returnNode(node);
          }
        } 
        else {
          if (m_extendedTypes[expType].getNodeType() == _nodeType) {
            return returnNode(node);
          }
        }
      }

      return NULL;
    }
  }  

  
  public class FollowingSiblingIterator extends InternalAxisIteratorBase
  {

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = makeNodeIdentity(node);

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      _currentNode = (_currentNode == DTM.NULL) ? DTM.NULL
                                                : _nextsib2(_currentNode);
      return returnNode(makeNodeHandle(_currentNode));
    }
  }  

  
  public final class TypedFollowingSiblingIterator
          extends FollowingSiblingIterator
  {

    
    private final int _nodeType;

    
    public TypedFollowingSiblingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {
      if (_currentNode == DTM.NULL) {
        return DTM.NULL;
      }

      int node = _currentNode;
      final int nodeType = _nodeType;

      if (nodeType != DTM.ELEMENT_NODE) {
        while ((node = _nextsib2(node)) != DTM.NULL && _exptype2(node) != nodeType) {}
      }
      else {
        while ((node = _nextsib2(node)) != DTM.NULL && _exptype2(node) < DTM.NTYPES) {}
      }
      
      _currentNode = node;

      return (node == DTM.NULL)
                      ? DTM.NULL
                      : returnNode(makeNodeHandle(node));
    }

  }  

  
  public final class AttributeIterator extends InternalAxisIteratorBase
  {

    

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = getFirstAttributeIdentity(makeNodeIdentity(node));

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      final int node = _currentNode;

      if (node != NULL) {
        _currentNode = getNextAttributeIdentity(node);
        return returnNode(makeNodeHandle(node));
      }

      return NULL;
    }
  }  

  
  public final class TypedAttributeIterator extends InternalAxisIteratorBase
  {

    
    private final int _nodeType;

    
    public TypedAttributeIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    

    
    public DTMAxisIterator setStartNode(int node)
    {
      if (_isRestartable)
      {
        _startNode = node;

        _currentNode = getTypedAttribute(node, _nodeType);

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      final int node = _currentNode;

      
      
      _currentNode = NULL;

      return returnNode(node);
    }
  }  

  
  public class PrecedingSiblingIterator extends InternalAxisIteratorBase
  {

    
    protected int _startNodeID;

    
    public boolean isReverse()
    {
      return true;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;
        node = _startNodeID = makeNodeIdentity(node);

        if(node == NULL)
        {
          _currentNode = node;
          return resetPosition();
        }

        int type = _type2(node);
        if(ExpandedNameTable.ATTRIBUTE == type 
           || ExpandedNameTable.NAMESPACE == type )
        {
          _currentNode = node;
        }
        else
        {
          
          _currentNode = _parent2(node);
          if(NULL!=_currentNode)	
            _currentNode = _firstch2(_currentNode);
          else
            _currentNode = node;
        }

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      if (_currentNode == _startNodeID || _currentNode == DTM.NULL)
      {
        return NULL;
      }
      else
      {
        final int node = _currentNode;
        _currentNode = _nextsib2(node);

        return returnNode(makeNodeHandle(node));
      }
    }
  }  

  
  public final class TypedPrecedingSiblingIterator
          extends PrecedingSiblingIterator
  {

    
    private final int _nodeType;

    
    public TypedPrecedingSiblingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {
      int node = _currentNode;

      final int nodeType = _nodeType;
      final int startNodeID = _startNodeID;

      if (nodeType != DTM.ELEMENT_NODE) {
        while (node != NULL && node != startNodeID && _exptype2(node) != nodeType) {
          node = _nextsib2(node);
        }
      } 
      else {
        while (node != NULL && node != startNodeID && _exptype2(node) < DTM.NTYPES) {
          node = _nextsib2(node);
        }
      }

      if (node == DTM.NULL || node == startNodeID) {
        _currentNode = NULL;
        return NULL;
      }
      else {
        _currentNode = _nextsib2(node);
        return returnNode(makeNodeHandle(node));
      }
    }
    
        
    public int getLast()
    {
      if (_last != -1)
        return _last;
      
      setMark();
      
      int node = _currentNode;
      final int nodeType = _nodeType;
      final int startNodeID = _startNodeID;
      
      int last = 0;
      if (nodeType != DTM.ELEMENT_NODE) {
        while (node != NULL && node != startNodeID) {
          if (_exptype2(node) == nodeType) {
            last++;
          }
          node = _nextsib2(node);
        }
      }
      else {
        while (node != NULL && node != startNodeID) {
          if (_exptype2(node) >= DTM.NTYPES) {
            last++;
          }
          node = _nextsib2(node);
        }      
      }
      
      gotoMark();
      
      return (_last = last);
    }
  }  

  
  public class PrecedingIterator extends InternalAxisIteratorBase
  {

    
    private final int _maxAncestors = 8;

    
    protected int[] _stack = new int[_maxAncestors];

    
    protected int _sp, _oldsp;

    protected int _markedsp, _markedNode, _markedDescendant;

    

    
    public boolean isReverse()
    {
      return true;
    }

    
    public DTMAxisIterator cloneIterator()
    {
      _isRestartable = false;

      try
      {
        final PrecedingIterator clone = (PrecedingIterator) super.clone();
        final int[] stackCopy = new int[_stack.length];
        System.arraycopy(_stack, 0, stackCopy, 0, _stack.length);

        clone._stack = stackCopy;

        
        return clone;
      }
      catch (CloneNotSupportedException e)
      {
        throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_ITERATOR_CLONE_NOT_SUPPORTED, null)); 
      }
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        node = makeNodeIdentity(node);

        
        int parent, index;

       if (_type2(node) == DTM.ATTRIBUTE_NODE)
         node = _parent2(node);

        _startNode = node;
        _stack[index = 0] = node;
        
       	parent=node;
	while ((parent = _parent2(parent)) != NULL)
	{
	  if (++index == _stack.length)
	  {
	    final int[] stack = new int[index*2];
	    System.arraycopy(_stack, 0, stack, 0, index);
	    _stack = stack;
	  }
	  _stack[index] = parent;
        }
        
        if(index>0)
	  --index; 

        _currentNode=_stack[index]; 

        _oldsp = _sp = index;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
    	
    	
    	
   	for(++_currentNode; _sp>=0; ++_currentNode)
   	{
   	  if(_currentNode < _stack[_sp])
   	  {
   	    int type = _type2(_currentNode);
   	    if(type != ATTRIBUTE_NODE && type != NAMESPACE_NODE)
   	      return returnNode(makeNodeHandle(_currentNode));
   	  }
   	  else
   	    --_sp;
   	}
   	return NULL;
    }

    

    
    public DTMAxisIterator reset()
    {

      _sp = _oldsp;

      return resetPosition();
    }

    public void setMark() {
        _markedsp = _sp;
        _markedNode = _currentNode;
        _markedDescendant = _stack[0];
    }

    public void gotoMark() {
        _sp = _markedsp;
        _currentNode = _markedNode;
    }
  }  

  
  public final class TypedPrecedingIterator extends PrecedingIterator
  {

    
    private final int _nodeType;

    
    public TypedPrecedingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {
      int node = _currentNode;
      final int nodeType = _nodeType;

      if (nodeType >= DTM.NTYPES) {
        while (true) {
          node++;

          if (_sp < 0) {
            node = NULL;
            break;
          } 
          else if (node >= _stack[_sp]) {
            if (--_sp < 0) {
              node = NULL;
              break;
            }
          } 
          else if (_exptype2(node) == nodeType) {
            break;
          }
        }
      }
      else {
        int expType;

        while (true) {
          node++;

          if (_sp < 0) {
            node = NULL;
            break;
          }
          else if (node >= _stack[_sp]) {
            if (--_sp < 0) {
              node = NULL;
              break;
            }
          }
          else {
            expType = _exptype2(node);
            if (expType < DTM.NTYPES) {
              if (expType == nodeType) {
                break;
              }
            }
            else {
              if (m_extendedTypes[expType].getNodeType() == nodeType) {
                break;
              }
            }
          }
        }
      }

      _currentNode = node;
             
      return (node == NULL) ? NULL : returnNode(makeNodeHandle(node));
    }
  }  

  
  public class FollowingIterator extends InternalAxisIteratorBase
  {
    
    
    public FollowingIterator()
    {
      
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        _startNode = node;

        
        
        node = makeNodeIdentity(node);

        int first;
        int type = _type2(node);

        if ((DTM.ATTRIBUTE_NODE == type) || (DTM.NAMESPACE_NODE == type))
        {
          node = _parent2(node);
          first = _firstch2(node);

          if (NULL != first) {
            _currentNode = makeNodeHandle(first);
            return resetPosition();
          }
        }

        do
        {
          first = _nextsib2(node);

          if (NULL == first)
            node = _parent2(node);
        }
        while (NULL == first && NULL != node);

        _currentNode = makeNodeHandle(first);

        
        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      int node = _currentNode;

      
      int current = makeNodeIdentity(node);

      while (true)
      {
        current++;

        int type = _type2(current);
        if (NULL == type) {
          _currentNode = NULL;
          return returnNode(node);
        }

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type)
          continue;

        _currentNode = makeNodeHandle(current);
        return returnNode(node);
      }
    }
    
  }  

  
  public final class TypedFollowingIterator extends FollowingIterator
  {

    
    private final int _nodeType;

    
    public TypedFollowingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {
      int current;
      int node;
      int type;

      final int nodeType = _nodeType;
      int currentNodeID = makeNodeIdentity(_currentNode);
      
      if (nodeType >= DTM.NTYPES) {
        do {
          node = currentNodeID;
	  current = node;

          do {
            current++;
            type = _type2(current);
          } 
          while (type != NULL && (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type));
        
          currentNodeID = (type != NULL) ? current : NULL;    
        } 
        while (node != DTM.NULL && _exptype2(node) != nodeType);
      }
      else {
        do {
          node = currentNodeID;
	  current = node;

          do {
            current++;
            type = _type2(current);
          } 
          while (type != NULL && (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type));
        
          currentNodeID = (type != NULL) ? current : NULL;    
        } 
        while (node != DTM.NULL
               && (_exptype2(node) != nodeType && _type2(node) != nodeType));      
      }

      _currentNode = makeNodeHandle(currentNodeID);
      return (node == DTM.NULL ? DTM.NULL :returnNode(makeNodeHandle(node)));
    }
  }  

  
  public class AncestorIterator extends InternalAxisIteratorBase
  {
    
    private static final int m_blocksize = 32;
    
    
    int[] m_ancestors = new int[m_blocksize];
    
    
    int m_size = 0;
    
    int m_ancestorsPos;

    int m_markedPos;
    
    
    int m_realStartNode;
    
    
    public int getStartNode()
    {
      return m_realStartNode;
    }

    
    public final boolean isReverse()
    {
      return true;
    }

    
    public DTMAxisIterator cloneIterator()
    {
      _isRestartable = false;  

      try
      {
        final AncestorIterator clone = (AncestorIterator) super.clone();

        clone._startNode = _startNode;

        
        return clone;
      }
      catch (CloneNotSupportedException e)
      {
        throw new DTMException(XMLMessages.createXMLMessage(XMLErrorResources.ER_ITERATOR_CLONE_NOT_SUPPORTED, null)); 
      }
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      m_realStartNode = node;

      if (_isRestartable)
      {
        int nodeID = makeNodeIdentity(node);
        
        if (nodeID == DTM.NULL) {
          _currentNode = DTM.NULL;
          m_ancestorsPos = 0;
          return this;
        }

        
        
        if (!_includeSelf) {
          nodeID = _parent2(nodeID);
          node = makeNodeHandle(nodeID);
        }

        _startNode = node;

        while (nodeID != END) {
          
          if (m_size >= m_ancestors.length)
          {
            int[] newAncestors = new int[m_size * 2];
            System.arraycopy(m_ancestors, 0, newAncestors, 0, m_ancestors.length);
            m_ancestors = newAncestors;
          }
          
          m_ancestors[m_size++] = node;
          nodeID = _parent2(nodeID);
          node = makeNodeHandle(nodeID);
        }
        
        m_ancestorsPos = m_size - 1;

        _currentNode = (m_ancestorsPos>=0)
                               ? m_ancestors[m_ancestorsPos]
                               : DTM.NULL;

        return resetPosition();
      }

      return this;
    }

    
    public DTMAxisIterator reset()
    {

      m_ancestorsPos = m_size - 1;

      _currentNode = (m_ancestorsPos >= 0) ? m_ancestors[m_ancestorsPos]
                                         : DTM.NULL;

      return resetPosition();
    }

    
    public int next()
    {

      int next = _currentNode;
      
      int pos = --m_ancestorsPos;

      _currentNode = (pos >= 0) ? m_ancestors[m_ancestorsPos]
                                : DTM.NULL;
      
      return returnNode(next);
    }

    public void setMark() {
        m_markedPos = m_ancestorsPos;
    }

    public void gotoMark() {
        m_ancestorsPos = m_markedPos;
        _currentNode = m_ancestorsPos>=0 ? m_ancestors[m_ancestorsPos]
                                         : DTM.NULL;
    }
  }  

  
  public final class TypedAncestorIterator extends AncestorIterator
  {

    
    private final int _nodeType;

    
    public TypedAncestorIterator(int type)
    {
      _nodeType = type;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      m_realStartNode = node;

      if (_isRestartable)
      {
        int nodeID = makeNodeIdentity(node);
        
        if (nodeID == DTM.NULL) {
          _currentNode = DTM.NULL;
          m_ancestorsPos = 0;
          return this;
        }
        
        final int nodeType = _nodeType;

        if (!_includeSelf) {
          nodeID = _parent2(nodeID);
          node = makeNodeHandle(nodeID);
        }

        _startNode = node;

        if (nodeType >= DTM.NTYPES) {
          while (nodeID != END) {
            int eType = _exptype2(nodeID);

            if (eType == nodeType) {
              if (m_size >= m_ancestors.length)
              {
              	int[] newAncestors = new int[m_size * 2];
              	System.arraycopy(m_ancestors, 0, newAncestors, 0, m_ancestors.length);
              	m_ancestors = newAncestors;
              }
              m_ancestors[m_size++] = makeNodeHandle(nodeID);
            }
            nodeID = _parent2(nodeID);
          }
        }
        else {
          while (nodeID != END) {
            int eType = _exptype2(nodeID);

            if ((eType < DTM.NTYPES && eType == nodeType)
                || (eType >= DTM.NTYPES
                    && m_extendedTypes[eType].getNodeType() == nodeType)) {
              if (m_size >= m_ancestors.length)
              {
              	int[] newAncestors = new int[m_size * 2];
              	System.arraycopy(m_ancestors, 0, newAncestors, 0, m_ancestors.length);
              	m_ancestors = newAncestors;
              }
              m_ancestors[m_size++] = makeNodeHandle(nodeID);
            }
            nodeID = _parent2(nodeID);
          }
        }
        m_ancestorsPos = m_size - 1;

        _currentNode = (m_ancestorsPos>=0)
                               ? m_ancestors[m_ancestorsPos]
                               : DTM.NULL;

        return resetPosition();
      }

      return this;
    }

    
    public int getNodeByPosition(int position)
    {
      if (position > 0 && position <= m_size) {
        return m_ancestors[position-1];
      }
      else
        return DTM.NULL;
    }
    
    
    public int getLast() {
      return m_size;
    }
  }  

  
  public class DescendantIterator extends InternalAxisIteratorBase
  {

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (node == DTMDefaultBase.ROOTNODE)
        node = getDocument();
      if (_isRestartable)
      {
        node = makeNodeIdentity(node);
        _startNode = node;

        if (_includeSelf)
          node--;

        _currentNode = node;

        return resetPosition();
      }

      return this;
    }

    
    protected final boolean isDescendant(int identity)
    {
      return (_parent2(identity) >= _startNode) || (_startNode == identity);
    }

    
    public int next()
    {
      final int startNode = _startNode;
      if (startNode == NULL) {
        return NULL;
      }

      if (_includeSelf && (_currentNode + 1) == startNode)
          return returnNode(makeNodeHandle(++_currentNode)); 

      int node = _currentNode;
      int type;

      
      
      if (startNode == ROOTNODE) {
        int eType;
        do {
          node++;
          eType = _exptype2(node);

          if (NULL == eType) {
            _currentNode = NULL;
            return END;
          }
        } while (eType == TEXT_NODE
                 || (type = m_extendedTypes[eType].getNodeType()) == ATTRIBUTE_NODE
                 || type == NAMESPACE_NODE);
      }
      else {
        do {
          node++;
          type = _type2(node);

          if (NULL == type ||!isDescendant(node)) {
            _currentNode = NULL;
            return END;
          }
        } while(ATTRIBUTE_NODE == type || TEXT_NODE == type
                 || NAMESPACE_NODE == type);      
      }

      _currentNode = node;
      return returnNode(makeNodeHandle(node));  
    }
  
     
  public DTMAxisIterator reset()
  {

    final boolean temp = _isRestartable;

    _isRestartable = true;

    setStartNode(makeNodeHandle(_startNode));

    _isRestartable = temp;

    return this;
  }
    
  }  

  
  public final class TypedDescendantIterator extends DescendantIterator
  {

    
    private final int _nodeType;

    
    public TypedDescendantIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    
    public int next()
    {
      final int startNode = _startNode;
      if (_startNode == NULL) {
        return NULL;
      }

      int node = _currentNode;

      int expType;
      final int nodeType = _nodeType;
      
      if (nodeType != DTM.ELEMENT_NODE)
      {
        do
        {
          node++;
	  expType = _exptype2(node);

          if (NULL == expType || _parent2(node) < startNode && startNode != node) {
            _currentNode = NULL;
            return END;
          }
        }
        while (expType != nodeType);      
      }
      
      
      
      else if (startNode == DTMDefaultBase.ROOTNODE)
      {
	do
	{
	  node++;
	  expType = _exptype2(node);

	  if (NULL == expType) {
	    _currentNode = NULL;
	    return END;
	  }
	} while (expType < DTM.NTYPES 
	        || m_extendedTypes[expType].getNodeType() != DTM.ELEMENT_NODE);
      }
      else
      {
        do
        {
          node++;
	  expType = _exptype2(node);

          if (NULL == expType || _parent2(node) < startNode && startNode != node) {
            _currentNode = NULL;
            return END;
          }
        }
        while (expType < DTM.NTYPES 
	       || m_extendedTypes[expType].getNodeType() != DTM.ELEMENT_NODE);      
      }
      
      _currentNode = node;
      return returnNode(makeNodeHandle(node));
    }
  }  

  
  public final class TypedSingletonIterator extends SingletonIterator
  {

    
    private final int _nodeType;

    
    public TypedSingletonIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    
    public int next()
    {

      final int result = _currentNode;
      if (result == END)
        return DTM.NULL;
      
      _currentNode = END;

      if (_nodeType >= DTM.NTYPES) {
        if (_exptype2(makeNodeIdentity(result)) == _nodeType) {
          return returnNode(result);
        }
      } 
      else {
        if (_type2(makeNodeIdentity(result)) == _nodeType) {
          return returnNode(result);
        }
      }

      return NULL;
    }
  }  

  


  
  
  
  
  private int[] m_exptype_map0;
  private int[] m_nextsib_map0;
  private int[] m_firstch_map0;
  private int[] m_parent_map0;
  
  
  private int[][] m_exptype_map;
  private int[][] m_nextsib_map;
  private int[][] m_firstch_map;
  private int[][] m_parent_map;

  
  protected ExtendedType[] m_extendedTypes;
  
  
  
  
  
  
  
  
  
  protected Vector m_values;
  
  
  private int m_valueIndex = 0;
  
  
  private int m_maxNodeIndex;
  
  
  protected int m_SHIFT;
  protected int m_MASK;
  protected int m_blocksize;
  
  
  
  protected final static int TEXT_LENGTH_BITS = 10;
  
  
  protected final static int TEXT_OFFSET_BITS = 21;
  
  
  protected final static int TEXT_LENGTH_MAX = (1<<TEXT_LENGTH_BITS) - 1;
  
  
  protected final static int TEXT_OFFSET_MAX = (1<<TEXT_OFFSET_BITS) - 1;
  
  
  protected boolean m_buildIdIndex = true;
      
  
  private static final String EMPTY_STR = """";
  
  
  private static final XMLString EMPTY_XML_STR = new XMLStringDefault("""");

  
  public SAX2DTM2(DTMManager mgr, Source source, int dtmIdentity,
                 DTMWSFilter whiteSpaceFilter,
                 XMLStringFactory xstringfactory,
                 boolean doIndexing)
  {

    this(mgr, source, dtmIdentity, whiteSpaceFilter,
          xstringfactory, doIndexing, DEFAULT_BLOCKSIZE, true, true);
  }
 
  
  public SAX2DTM2(DTMManager mgr, Source source, int dtmIdentity,
                 DTMWSFilter whiteSpaceFilter,
                 XMLStringFactory xstringfactory,
                 boolean doIndexing,
                 int blocksize,
                 boolean usePrevsib,
                 boolean buildIdIndex)
  {

    super(mgr, source, dtmIdentity, whiteSpaceFilter,
          xstringfactory, doIndexing, blocksize, usePrevsib);
        
    
    int shift;
    for(shift=0; (blocksize>>>=1) != 0; ++shift);
    
    m_blocksize = 1<<shift;
    m_SHIFT = shift;
    m_MASK = m_blocksize - 1;
    
    m_buildIdIndex = buildIdIndex;
    
    
    
    
    m_values = new Vector(32, 512);
    
    m_maxNodeIndex = 1 << DTMManager.IDENT_DTM_NODE_BITS;
    
    
    m_exptype_map0 = m_exptype.getMap0();
    m_nextsib_map0 = m_nextsib.getMap0();
    m_firstch_map0 = m_firstch.getMap0();
    m_parent_map0  = m_parent.getMap0();
  }
  
  
  public final int _exptype(int identity)
  {
    return m_exptype.elementAt(identity);    
  }

  
 
  
  public final int _exptype2(int identity)
  {
    
    
    if (identity < m_blocksize)
      return m_exptype_map0[identity];
    else
      return m_exptype_map[identity>>>m_SHIFT][identity&m_MASK];    
  }
  
  
  public final int _nextsib2(int identity)
  {
    
    
    if (identity < m_blocksize)
      return m_nextsib_map0[identity];
    else
      return m_nextsib_map[identity>>>m_SHIFT][identity&m_MASK];     
  }
  
  
  public final int _firstch2(int identity)
  {
    
    
    if (identity < m_blocksize)
      return m_firstch_map0[identity];
    else
      return m_firstch_map[identity>>>m_SHIFT][identity&m_MASK];    
  }
  
  
  public final int _parent2(int identity)
  {
    
    
    if (identity < m_blocksize)
      return m_parent_map0[identity];
    else
      return m_parent_map[identity>>>m_SHIFT][identity&m_MASK];    
  }
  
  
  public final int _type2(int identity)
  {
    
    int eType;
    if (identity < m_blocksize)
      eType = m_exptype_map0[identity];
    else
      eType = m_exptype_map[identity>>>m_SHIFT][identity&m_MASK];    
  	
    if (NULL != eType)
      return m_extendedTypes[eType].getNodeType();
    else
      return NULL;
  }
    
  
  public final int getExpandedTypeID2(int nodeHandle)
  {
    int nodeID = makeNodeIdentity(nodeHandle);
    
    
    
    if (nodeID != NULL) {
      if (nodeID < m_blocksize)
        return m_exptype_map0[nodeID];
      else
        return m_exptype_map[nodeID>>>m_SHIFT][nodeID&m_MASK]; 
    }
    else
      return NULL;
  }
  
  
   

  
  public final int _exptype2Type(int exptype)
  {
    if (NULL != exptype)
      return m_extendedTypes[exptype].getNodeType();
    else
      return NULL;    
  }

  
  public int getIdForNamespace(String uri)
  {
     int index = m_values.indexOf(uri);
     if (index < 0)
     {
       m_values.addElement(uri);
       return m_valueIndex++;
     }
     else
       return index;
  }

  
  public void startElement(String uri, String localName, String qName, Attributes attributes)
      throws SAXException
  {
		
    charactersFlush();

    int exName = m_expandedNameTable.getExpandedTypeID(uri, localName, DTM.ELEMENT_NODE);
    
    int prefixIndex = (qName.length() != localName.length())
                      ? m_valuesOrPrefixes.stringToIndex(qName) : 0;

    int elemNode = addNode(DTM.ELEMENT_NODE, exName,
                           m_parents.peek(), m_previous, prefixIndex, true);

    if(m_indexing)
      indexNode(exName, elemNode);
    
    m_parents.push(elemNode);

    int startDecls = m_contextIndexes.peek();
    int nDecls = m_prefixMappings.size();
    String prefix;

    if(!m_pastFirstElement)
    {
      
      prefix=""xml"";
      String declURL = ""http:
      exName = m_expandedNameTable.getExpandedTypeID(null, prefix, DTM.NAMESPACE_NODE);
      m_values.addElement(declURL);
      int val = m_valueIndex++;
      addNode(DTM.NAMESPACE_NODE, exName, elemNode,
                     DTM.NULL, val, false);
      m_pastFirstElement=true;
    }

    for (int i = startDecls; i < nDecls; i += 2)
    {
      prefix = (String) m_prefixMappings.elementAt(i);

      if (prefix == null)
        continue;

      String declURL = (String) m_prefixMappings.elementAt(i + 1);

      exName = m_expandedNameTable.getExpandedTypeID(null, prefix, DTM.NAMESPACE_NODE);

      m_values.addElement(declURL);
      int val = m_valueIndex++;

      addNode(DTM.NAMESPACE_NODE, exName, elemNode, DTM.NULL, val, false);
    }

    int n = attributes.getLength();

    for (int i = 0; i < n; i++)
    {
      String attrUri = attributes.getURI(i);
      String attrQName = attributes.getQName(i);
      String valString = attributes.getValue(i);

      int nodeType;
      
      String attrLocalName = attributes.getLocalName(i);

      if ((null != attrQName)
              && (attrQName.equals(""xmlns"")
                  || attrQName.startsWith(""xmlns:"")))
      {
        prefix = getPrefix(attrQName, attrUri);
        if (declAlreadyDeclared(prefix))
          continue;  

        nodeType = DTM.NAMESPACE_NODE;
      }
      else
      {
        nodeType = DTM.ATTRIBUTE_NODE;

        if (m_buildIdIndex && attributes.getType(i).equalsIgnoreCase(""ID""))
          setIDAttribute(valString, elemNode);
      }

      
      
      if(null == valString)
        valString = """";

      m_values.addElement(valString);
      int val = m_valueIndex++;

      if (attrLocalName.length() != attrQName.length())
      {

        prefixIndex = m_valuesOrPrefixes.stringToIndex(attrQName);

        int dataIndex = m_data.size();

        m_data.addElement(prefixIndex);
        m_data.addElement(val);

        val = -dataIndex;
      }

      exName = m_expandedNameTable.getExpandedTypeID(attrUri, attrLocalName, nodeType);
      addNode(nodeType, exName, elemNode, DTM.NULL, val,
                     false);
    }

    if (null != m_wsfilter)
    {
      short wsv = m_wsfilter.getShouldStripSpace(makeNodeHandle(elemNode), this);
      boolean shouldStrip = (DTMWSFilter.INHERIT == wsv)
                            ? getShouldStripWhitespace()
                            : (DTMWSFilter.STRIP == wsv);

      pushShouldStripWhitespace(shouldStrip);
    }

    m_previous = DTM.NULL;

    m_contextIndexes.push(m_prefixMappings.size());  
  }

  
  public void endElement(String uri, String localName, String qName)
          throws SAXException
  {
    charactersFlush();

    
    
    m_contextIndexes.quickPop(1);

    
    int topContextIndex = m_contextIndexes.peek();
    if (topContextIndex != m_prefixMappings.size()) {
      m_prefixMappings.setSize(topContextIndex);
    }

    m_previous = m_parents.pop();

    popShouldStripWhitespace();
  }

  
  public void comment(char ch[], int start, int length) throws SAXException
  {

    if (m_insideDTD)      
      return;

    charactersFlush();

    
    
    m_values.addElement(new String(ch, start, length));
    int dataIndex = m_valueIndex++;

    m_previous = addNode(DTM.COMMENT_NODE, DTM.COMMENT_NODE,
                         m_parents.peek(), m_previous, dataIndex, false);
  }  

  
  public void startDocument() throws SAXException
  {
		
    int doc = addNode(DTM.DOCUMENT_NODE,
                      DTM.DOCUMENT_NODE,
                      DTM.NULL, DTM.NULL, 0, true);

    m_parents.push(doc);
    m_previous = DTM.NULL;

    m_contextIndexes.push(m_prefixMappings.size());  
  }
  
  
  public void endDocument() throws SAXException
  {
    super.endDocument();
        
    
    
    m_exptype.addElement(NULL);
    m_parent.addElement(NULL);
    m_nextsib.addElement(NULL);
    m_firstch.addElement(NULL);
    
    
    m_extendedTypes = m_expandedNameTable.getExtendedTypes();
    m_exptype_map = m_exptype.getMap();
    m_nextsib_map = m_nextsib.getMap();
    m_firstch_map = m_firstch.getMap();
    m_parent_map  = m_parent.getMap();
  }

  
  protected final int addNode(int type, int expandedTypeID,
                        int parentIndex, int previousSibling,
                        int dataOrPrefix, boolean canHaveFirstChild)
  {
    
    int nodeIndex = m_size++;

    
    
    if (nodeIndex == m_maxNodeIndex)
    {
      addNewDTMID(nodeIndex);
      m_maxNodeIndex += (1 << DTMManager.IDENT_DTM_NODE_BITS);
    }

    m_firstch.addElement(DTM.NULL);
    m_nextsib.addElement(DTM.NULL);
    m_parent.addElement(parentIndex);
    m_exptype.addElement(expandedTypeID);
    m_dataOrQName.addElement(dataOrPrefix);

    if (m_prevsib != null) {
      m_prevsib.addElement(previousSibling);
    }

    if (m_locator != null && m_useSourceLocationProperty) {
      setSourceLocation();
    }

    
    

    
    switch(type)
    {
    case DTM.NAMESPACE_NODE:
      declareNamespaceInContext(parentIndex,nodeIndex);
      break;
    case DTM.ATTRIBUTE_NODE:
      break;
    default:
      if (DTM.NULL != previousSibling) {
        m_nextsib.setElementAt(nodeIndex,previousSibling);
      }
      else if (DTM.NULL != parentIndex) {
        m_firstch.setElementAt(nodeIndex,parentIndex);
      }
      break;
    }

    return nodeIndex;
  }

  
  protected final void charactersFlush()
  {

    if (m_textPendingStart >= 0)  
    {
      int length = m_chars.size() - m_textPendingStart;
      boolean doStrip = false;

      if (getShouldStripWhitespace())
      {
        doStrip = m_chars.isWhitespace(m_textPendingStart, length);
      }

      if (doStrip)
        m_chars.setLength(m_textPendingStart);  
      else
      {
        
        
        
        if (length <= TEXT_LENGTH_MAX && m_textPendingStart <= TEXT_OFFSET_MAX)
        {
          m_previous = addNode(m_coalescedTextType, DTM.TEXT_NODE,
                             m_parents.peek(), m_previous,
                             length + (m_textPendingStart << TEXT_LENGTH_BITS),
                             false);
          
        }
        else
        {
          
          
          int dataIndex = m_data.size();
          m_previous = addNode(m_coalescedTextType, DTM.TEXT_NODE,
                             m_parents.peek(), m_previous, -dataIndex, false);

          m_data.addElement(m_textPendingStart);
          m_data.addElement(length);
        }
      }

      
      m_textPendingStart = -1;
      m_textType = m_coalescedTextType = DTM.TEXT_NODE;
    }
  }

  
  public void processingInstruction(String target, String data)
	  throws SAXException
  {

    charactersFlush();

    int dataIndex = m_data.size();
    m_previous = addNode(DTM.PROCESSING_INSTRUCTION_NODE, 
			 DTM.PROCESSING_INSTRUCTION_NODE,
			 m_parents.peek(), m_previous,
			 -dataIndex, false);

    m_data.addElement(m_valuesOrPrefixes.stringToIndex(target));
    m_values.addElement(data);
    m_data.addElement(m_valueIndex++);

  }

  
  public final int getFirstAttribute(int nodeHandle)
  {
    int nodeID = makeNodeIdentity(nodeHandle);

    if (nodeID == DTM.NULL)
      return DTM.NULL;
    
    int type = _type2(nodeID);

    if (DTM.ELEMENT_NODE == type)
    {
      
      while (true)
      {
        nodeID++;
	
	type = _type2(nodeID);

	if (type == DTM.ATTRIBUTE_NODE)
	{
	  return makeNodeHandle(nodeID);
	}
	else if (DTM.NAMESPACE_NODE != type)
	{
	  break;
	}
      }
    }

    return DTM.NULL;
  }

  
  protected int getFirstAttributeIdentity(int identity) {
    int type = _type2(identity);

    if (DTM.ELEMENT_NODE == type)
    {
      
      while (true)
      {
        identity++;

        
        type = _type2(identity);

        if (type == DTM.ATTRIBUTE_NODE)
        {
          return identity;
        }
        else if (DTM.NAMESPACE_NODE != type)
        {
          break;
        }
      }
    }

    return DTM.NULL;
  }

  
  protected int getNextAttributeIdentity(int identity) {
    
    while (true) {
      identity++;
      int type = _type2(identity);

      if (type == DTM.ATTRIBUTE_NODE) {
        return identity;
      } else if (type != DTM.NAMESPACE_NODE) {
        break;
      }
    }

    return DTM.NULL;
  }

  
  protected final int getTypedAttribute(int nodeHandle, int attType) 
  {
          
    int nodeID = makeNodeIdentity(nodeHandle);
    
    if (nodeID == DTM.NULL)
      return DTM.NULL;
    
    int type = _type2(nodeID);
    
    if (DTM.ELEMENT_NODE == type)
    {
      int expType;
      while (true)
      {
	nodeID++;
	expType = _exptype2(nodeID);
	
	if (expType != DTM.NULL)
	  type = m_extendedTypes[expType].getNodeType();
	else
	  return DTM.NULL;

	if (type == DTM.ATTRIBUTE_NODE)
	{
	  if (expType == attType) return makeNodeHandle(nodeID);
	}
	else if (DTM.NAMESPACE_NODE != type)
	{
	  break;
	}
      }
    }

    return DTM.NULL;
  }

  
  public String getLocalName(int nodeHandle)
  {
    int expType = _exptype(makeNodeIdentity(nodeHandle));
    
    if (expType == DTM.PROCESSING_INSTRUCTION_NODE)
    {
      int dataIndex = _dataOrQName(makeNodeIdentity(nodeHandle));
      dataIndex = m_data.elementAt(-dataIndex);
      return m_valuesOrPrefixes.indexToString(dataIndex);     
    }
    else
      return m_expandedNameTable.getLocalName(expType);
  }

  
  public final String getNodeNameX(int nodeHandle)
  {

    int nodeID = makeNodeIdentity(nodeHandle);
    int eType = _exptype2(nodeID);
    
    if (eType == DTM.PROCESSING_INSTRUCTION_NODE)
    {
      int dataIndex = _dataOrQName(nodeID);
      dataIndex = m_data.elementAt(-dataIndex);
      return m_valuesOrPrefixes.indexToString(dataIndex);           
    }
    
    final ExtendedType extType = m_extendedTypes[eType];
                         
    if (extType.getNamespace().length() == 0)
    {
      return extType.getLocalName();
    }
    else
    {
      int qnameIndex = m_dataOrQName.elementAt(nodeID);

      if (qnameIndex == 0)
        return extType.getLocalName();
      
      if (qnameIndex < 0)
      {
	qnameIndex = -qnameIndex;
	qnameIndex = m_data.elementAt(qnameIndex);
      }

      return m_valuesOrPrefixes.indexToString(qnameIndex);
    }
  }

  
  public String getNodeName(int nodeHandle)
  {

    int nodeID = makeNodeIdentity(nodeHandle);
    int eType = _exptype2(nodeID);

    final ExtendedType extType = m_extendedTypes[eType];
    if (extType.getNamespace().length() == 0)
    {
      int type = extType.getNodeType();
      
      String localName = extType.getLocalName(); 
      if (type == DTM.NAMESPACE_NODE)
      {
	if (localName.length() == 0)
	  return ""xmlns"";
	else
	  return ""xmlns:"" + localName;
      }
      else if (type == DTM.PROCESSING_INSTRUCTION_NODE)
      {
	int dataIndex = _dataOrQName(nodeID);
	dataIndex = m_data.elementAt(-dataIndex);
	return m_valuesOrPrefixes.indexToString(dataIndex);           	
      }
      else if (localName.length() == 0)
      {
	return m_fixednames[type];
      }
      else
	return localName;      
    }
    else
    {
      int qnameIndex = m_dataOrQName.elementAt(nodeID);

      if (qnameIndex == 0)
        return extType.getLocalName();
      
      if (qnameIndex < 0)
      {
	qnameIndex = -qnameIndex;
	qnameIndex = m_data.elementAt(qnameIndex);
      }

      return m_valuesOrPrefixes.indexToString(qnameIndex);
    }
  }

  
  public XMLString getStringValue(int nodeHandle)
  {
    int identity = makeNodeIdentity(nodeHandle);
    if (identity == DTM.NULL)
      return EMPTY_XML_STR;
    
    int type= _type2(identity);

    if (type == DTM.ELEMENT_NODE || type == DTM.DOCUMENT_NODE)
    {
      int startNode = identity;
      identity = _firstch2(identity);
      if (DTM.NULL != identity)
      {
	int offset = -1;
	int length = 0;

	do 
	{
	  type = _exptype2(identity);

	  if (type == DTM.TEXT_NODE || type == DTM.CDATA_SECTION_NODE)
	  {
	    int dataIndex = m_dataOrQName.elementAt(identity);
	    if (dataIndex > 0)
	    {
	      if (-1 == offset)
	      {
                offset = dataIndex >>> TEXT_LENGTH_BITS;
	      }

	      length += dataIndex & TEXT_LENGTH_MAX;	      
	    }
	    else
	    {
	      if (-1 == offset)
	      {
                offset = m_data.elementAt(-dataIndex);
	      }

	      length += m_data.elementAt(-dataIndex + 1);
	    }
	  }

	  identity++;
	} while (_parent2(identity) >= startNode);

	if (length > 0)
	{
	  if (m_xstrf != null)
	    return m_xstrf.newstr(m_chars, offset, length);
	  else
	    return new XMLStringDefault(m_chars.getString(offset, length));
	}
	else
	  return EMPTY_XML_STR;
      }
      else
        return EMPTY_XML_STR;
    } 
    else if (DTM.TEXT_NODE == type || DTM.CDATA_SECTION_NODE == type)
    {
      int dataIndex = m_dataOrQName.elementAt(identity);
      if (dataIndex > 0)
      {
      	if (m_xstrf != null)
      	  return m_xstrf.newstr(m_chars, dataIndex >>> TEXT_LENGTH_BITS, 
      	                 dataIndex & TEXT_LENGTH_MAX);
      	else
      	  return new XMLStringDefault(m_chars.getString(dataIndex >>> TEXT_LENGTH_BITS, 
      	                              dataIndex & TEXT_LENGTH_MAX));
      }
      else
      {
        if (m_xstrf != null)
          return m_xstrf.newstr(m_chars, m_data.elementAt(-dataIndex),
                                m_data.elementAt(-dataIndex+1));
        else
          return new XMLStringDefault(m_chars.getString(m_data.elementAt(-dataIndex), 
                                   m_data.elementAt(-dataIndex+1)));
      }
    }
    else
    {
      int dataIndex = m_dataOrQName.elementAt(identity);

      if (dataIndex < 0)
      {
        dataIndex = -dataIndex;
        dataIndex = m_data.elementAt(dataIndex + 1);
      }

      if (m_xstrf != null)
        return m_xstrf.newstr((String)m_values.elementAt(dataIndex));
      else
        return new XMLStringDefault((String)m_values.elementAt(dataIndex));
    }
  }
  
  
  public final String getStringValueX(final int nodeHandle)
  {
    int identity = makeNodeIdentity(nodeHandle);
    if (identity == DTM.NULL)
      return EMPTY_STR;
    
    int type= _type2(identity);

    if (type == DTM.ELEMENT_NODE || type == DTM.DOCUMENT_NODE)
    {
      int startNode = identity;
      identity = _firstch2(identity);
      if (DTM.NULL != identity)
      {
	int offset = -1;
	int length = 0;

	do 
	{
	  type = _exptype2(identity);

	  if (type == DTM.TEXT_NODE || type == DTM.CDATA_SECTION_NODE)
	  {
	    int dataIndex = m_dataOrQName.elementAt(identity);
	    if (dataIndex > 0)
	    {
	      if (-1 == offset)
	      {
                offset = dataIndex >>> TEXT_LENGTH_BITS;
	      }

	      length += dataIndex & TEXT_LENGTH_MAX;	      
	    }
	    else
	    {
	      if (-1 == offset)
	      {
                offset = m_data.elementAt(-dataIndex);
	      }

	      length += m_data.elementAt(-dataIndex + 1);
	    }
	  }

	  identity++;
	} while (_parent2(identity) >= startNode);

	if (length > 0)
	{
	  return m_chars.getString(offset, length);
	}
	else
	  return EMPTY_STR;
      }
      else
        return EMPTY_STR;
    } 
    else if (DTM.TEXT_NODE == type || DTM.CDATA_SECTION_NODE == type)
    {
      int dataIndex = m_dataOrQName.elementAt(identity);
      if (dataIndex > 0)
      {
      	return m_chars.getString(dataIndex >>> TEXT_LENGTH_BITS, 
      	                          dataIndex & TEXT_LENGTH_MAX);
      }
      else
      {
        return m_chars.getString(m_data.elementAt(-dataIndex), 
                                  m_data.elementAt(-dataIndex+1));
      }
    }
    else
    {
      int dataIndex = m_dataOrQName.elementAt(identity);

      if (dataIndex < 0)
      {
        dataIndex = -dataIndex;
        dataIndex = m_data.elementAt(dataIndex + 1);
      }

      return (String)m_values.elementAt(dataIndex);
    }
  }

  
  public String getStringValue()
  {
    int child = _firstch2(ROOTNODE);
    if (child == DTM.NULL) return EMPTY_STR;
      
    
    if ((_exptype2(child) == DTM.TEXT_NODE) && (_nextsib2(child) == DTM.NULL))
    {
      int dataIndex = m_dataOrQName.elementAt(child);
      if (dataIndex > 0)
        return m_chars.getString(dataIndex >>> TEXT_LENGTH_BITS, dataIndex & TEXT_LENGTH_MAX);
      else
        return m_chars.getString(m_data.elementAt(-dataIndex), 
                                  m_data.elementAt(-dataIndex + 1));      
    }
    else
      return getStringValueX(getDocument());
    
  }

  
  public final void dispatchCharactersEvents(int nodeHandle, ContentHandler ch,
                                             boolean normalize)
          throws SAXException
  {

    int identity = makeNodeIdentity(nodeHandle);
    
    if (identity == DTM.NULL)
      return;
    
    int type = _type2(identity);

    if (type == DTM.ELEMENT_NODE || type == DTM.DOCUMENT_NODE)
    {
      int startNode = identity;
      identity = _firstch2(identity);
      if (DTM.NULL != identity)
      {
	int offset = -1;
	int length = 0;

	do 
	{
	  type = _exptype2(identity);

	  if (type == DTM.TEXT_NODE || type == DTM.CDATA_SECTION_NODE)
	  {
	    int dataIndex = m_dataOrQName.elementAt(identity);

	    if (dataIndex > 0)
	    {
	      if (-1 == offset)
	      {
                offset = dataIndex >>> TEXT_LENGTH_BITS;
	      }

	      length += dataIndex & TEXT_LENGTH_MAX;	      
	    }
	    else
	    {
	      if (-1 == offset)
	      {
                offset = m_data.elementAt(-dataIndex);
	      }

	      length += m_data.elementAt(-dataIndex + 1);
	    }
	  }

	  identity++;
	} while (_parent2(identity) >= startNode);

	if (length > 0)
	{
          if(normalize)
            m_chars.sendNormalizedSAXcharacters(ch, offset, length);
          else
	    m_chars.sendSAXcharacters(ch, offset, length);
	}
      }
    } 
    else if (DTM.TEXT_NODE == type || DTM.CDATA_SECTION_NODE == type)
    {
      int dataIndex = m_dataOrQName.elementAt(identity);

      if (dataIndex > 0)
      {
      	if (normalize)
      	  m_chars.sendNormalizedSAXcharacters(ch, dataIndex >>> TEXT_LENGTH_BITS,
      	                                      dataIndex & TEXT_LENGTH_MAX);
      	else
      	  m_chars.sendSAXcharacters(ch, dataIndex >>> TEXT_LENGTH_BITS,
      	                            dataIndex & TEXT_LENGTH_MAX);
      }
      else
      {
        if (normalize)
          m_chars.sendNormalizedSAXcharacters(ch, m_data.elementAt(-dataIndex), 
                                              m_data.elementAt(-dataIndex+1));          
        else
          m_chars.sendSAXcharacters(ch, m_data.elementAt(-dataIndex), 
                                    m_data.elementAt(-dataIndex+1));
      }
    }
    else
    {
      int dataIndex = m_dataOrQName.elementAt(identity);

      if (dataIndex < 0)
      {
        dataIndex = -dataIndex;
        dataIndex = m_data.elementAt(dataIndex + 1);
      }
      
      String str = (String)m_values.elementAt(dataIndex);
      
      if(normalize)
        FastStringBuffer.sendNormalizedSAXcharacters(str.toCharArray(),
                                                     0, str.length(), ch);
      else
        ch.characters(str.toCharArray(), 0, str.length());
    }
  }

  
  public String getNodeValue(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int type = _type2(identity);

    if (type == DTM.TEXT_NODE || type == DTM.CDATA_SECTION_NODE)
    {
      int dataIndex = _dataOrQName(identity);
      if (dataIndex > 0)
      {
      	return m_chars.getString(dataIndex >>> TEXT_LENGTH_BITS, 
      	                          dataIndex & TEXT_LENGTH_MAX);
      }
      else
      {
        return m_chars.getString(m_data.elementAt(-dataIndex), 
                                  m_data.elementAt(-dataIndex+1));
      }
    }
    else if (DTM.ELEMENT_NODE == type || DTM.DOCUMENT_FRAGMENT_NODE == type
             || DTM.DOCUMENT_NODE == type)
    {
      return null;
    }
    else
    {
      int dataIndex = m_dataOrQName.elementAt(identity);

      if (dataIndex < 0)
      {
        dataIndex = -dataIndex;
        dataIndex = m_data.elementAt(dataIndex + 1);
      }

      return (String)m_values.elementAt(dataIndex);
    }
  }

    
    protected final void copyTextNode(final int nodeID, SerializationHandler handler)
        throws SAXException
    {
        if (nodeID != DTM.NULL) {
      	    int dataIndex = m_dataOrQName.elementAt(nodeID);
            if (dataIndex > 0) {
                m_chars.sendSAXcharacters(handler,
                                          dataIndex >>> TEXT_LENGTH_BITS,
                                          dataIndex & TEXT_LENGTH_MAX);
            } else {
                m_chars.sendSAXcharacters(handler, m_data.elementAt(-dataIndex),
                                          m_data.elementAt(-dataIndex+1));
            }
        }      
    }

    
    protected final String copyElement(int nodeID, int exptype,
                               SerializationHandler handler)
        throws SAXException
    {
        final ExtendedType extType = m_extendedTypes[exptype];
        String uri = extType.getNamespace();
        String name = extType.getLocalName();
      
        if (uri.length() == 0) {
            handler.startElement(name);
            return name;
        }
        else {
            int qnameIndex = m_dataOrQName.elementAt(nodeID);
    
            if (qnameIndex == 0) {
                handler.startElement(name);
                handler.namespaceAfterStartElement(EMPTY_STR, uri);
                return name;
            }
          
            if (qnameIndex < 0) {
    	        qnameIndex = -qnameIndex;
    	        qnameIndex = m_data.elementAt(qnameIndex);
            }
    
            String qName = m_valuesOrPrefixes.indexToString(qnameIndex);
            handler.startElement(qName);
            
            int prefixIndex = qName.indexOf(':');
            String prefix;
            if (prefixIndex > 0) {
                prefix = qName.substring(0, prefixIndex);
            }
            else {
                prefix = null;
            }
            
            handler.namespaceAfterStartElement(prefix, uri);
            return qName;
        }      
    }

    
    protected final void copyAttribute(int nodeID, int exptype, 
        SerializationHandler handler)
        throws SAXException
    {
        
        final ExtendedType extType = m_extendedTypes[exptype];
        final String uri = extType.getNamespace();
        final String localName = extType.getLocalName();
        
        String prefix = null;
        String qname = null;
        int dataIndex = _dataOrQName(nodeID);
        int valueIndex = dataIndex;
        if (uri.length() != 0) {
            if (dataIndex <= 0) {
                int prefixIndex = m_data.elementAt(-dataIndex);
                valueIndex = m_data.elementAt(-dataIndex+1);
                qname = m_valuesOrPrefixes.indexToString(prefixIndex);
                int colonIndex = qname.indexOf(':');
                if (colonIndex > 0) {
                    prefix = qname.substring(0, colonIndex);
                }
            }
            handler.namespaceAfterStartElement(prefix, uri);           
        }
        
        String nodeName = (prefix != null) ? qname : localName;
        String nodeValue = (String)m_values.elementAt(valueIndex);
        
        handler.addAttribute(nodeName, nodeValue);
    }
    
}"
org.apache.xalan.templates.FuncKey,3,5,0,14,33,1,0,14,2,0.5,177,1.0,0,0.98245614,0.75,1,7,57.66666667,1,0.3333,1,"
package org.apache.xalan.templates;

import java.util.Hashtable;

import org.apache.xalan.transformer.KeyManager;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.UnionPathIterator;
import org.apache.xpath.functions.Function2Args;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;


public class FuncKey extends Function2Args
{

  
  static private Boolean ISTRUE = new Boolean(true);

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    
    TransformerImpl transformer = (TransformerImpl) xctxt.getOwnerObject();
    XNodeSet nodes = null;
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    int docContext = dtm.getDocumentRoot(context);

    if (DTM.NULL == docContext)
    {

      
    }

    String xkeyname = getArg0().execute(xctxt).str();
    QName keyname = new QName(xkeyname, xctxt.getNamespaceContext());
    XObject arg = getArg1().execute(xctxt);
    boolean argIsNodeSetDTM = (XObject.CLASS_NODESET == arg.getType());
    KeyManager kmgr = transformer.getKeyManager();
    
    
    if(argIsNodeSetDTM)
    {
    	XNodeSet ns = (XNodeSet)arg;
    	ns.setShouldCacheNodes(true);
    	int len = ns.getLength();
    	if(len <= 1)
    		argIsNodeSetDTM = false;
    }

    if (argIsNodeSetDTM)
    {
      Hashtable usedrefs = null;
      DTMIterator ni = arg.iter();
      int pos;
      UnionPathIterator upi = new UnionPathIterator();
      upi.exprSetParent(this);

      while (DTM.NULL != (pos = ni.nextNode()))
      {
        dtm = xctxt.getDTM(pos);
        XMLString ref = dtm.getStringValue(pos);

        if (null == ref)
          continue;

        if (null == usedrefs)
          usedrefs = new Hashtable();

        if (usedrefs.get(ref) != null)
        {
          continue;  
        }
        else
        {

          
          usedrefs.put(ref, ISTRUE);
        }

        XNodeSet nl =
          kmgr.getNodeSetDTMByKey(xctxt, docContext, keyname, ref,
                               xctxt.getNamespaceContext());
                               
        nl.setRoot(xctxt.getCurrentNode(), xctxt);



          upi.addIterator(nl);





        
      }

      int current = xctxt.getCurrentNode();
      upi.setRoot(current, xctxt);

      nodes = new XNodeSet(upi);
    }
    else
    {
      XMLString ref = arg.xstr();
      nodes = kmgr.getNodeSetDTMByKey(xctxt, docContext, keyname,
                                                ref,
                                                xctxt.getNamespaceContext());
      nodes.setRoot(xctxt.getCurrentNode(), xctxt);
    }

    return nodes;
  }
}
"
org.apache.xml.serializer.WriterToUTF8Buffered,10,2,0,1,17,0,1,0,8,0.444444444,588,1.0,0,0.590909091,0.36,1,2,57.4,1,0.9,1,"
package org.apache.xml.serializer;

import java.io.IOException;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.io.Writer;



public final class WriterToUTF8Buffered extends Writer
{
    
  
  private static final int buf_length=16*1024;
  
  
  private final OutputStream m_os;

  
  private final byte buf[];

  
  private int count;

  
  public WriterToUTF8Buffered(OutputStream out)
          throws UnsupportedEncodingException
  {
      m_os = out;
      
      
      buf = new byte[buf_length + 3];
      count = 0;
      


  }

  















  
  public void write(final int c) throws IOException
  {
    
     
    if (count >= buf_length)
        flushBuffer();

    if (c < 0x80)
    {
       buf[count++] = (byte) (c);
    }
    else if (c < 0x800)
    {
      buf[count++] = (byte) (0xc0 + (c >> 6));
      buf[count++] = (byte) (0x80 + (c & 0x3f));
    }
    else
    {
      buf[count++] = (byte) (0xe0 + (c >> 12));
      buf[count++] = (byte) (0x80 + ((c >> 6) & 0x3f));
      buf[count++] = (byte) (0x80 + (c & 0x3f));
    }
  }

  
  private final void writeDirect(
          final char chars[], final int start, final int length)
            throws java.io.IOException
  {

    final OutputStream os = m_os;

    final int n = length+start;
    for (int i = start; i < n; i++)
    {
      final char c = chars[i];

      if (c < 0x80)
        os.write(c);
      else if (c < 0x800)
      {
        os.write(0xc0 + (c >> 6));
        os.write(0x80 + (c & 0x3f));
      }
      else
      {
        os.write(0xe0 + (c >> 12));
        os.write(0x80 + ((c >> 6) & 0x3f));
        os.write(0x80 + (c & 0x3f));
      }
    }
  }

  
  private final void writeDirect(final String s) throws IOException
  {

    final int n = s.length();
    final OutputStream os = m_os;

    for (int i = 0; i < n; i++)
    {
      final char c = s.charAt(i);

      if (c < 0x80)
        os.write(c);
      else if (c < 0x800)
      {
        os.write(0xc0 + (c >> 6));
        os.write(0x80 + (c & 0x3f));
      }
      else
      {
        os.write(0xe0 + (c >> 12));
        os.write(0x80 + ((c >> 6) & 0x3f));
        os.write(0x80 + (c & 0x3f));
      }
    }
  }

  
  public void write(final char chars[], final int start, final int length)
          throws java.io.IOException
  {

    
    
    

    int lengthx3 = (length << 1) + length;

    if (lengthx3 >= buf_length)
    {

      
      flushBuffer();
      writeDirect(chars, start, length);

      return;
    }

    if (lengthx3 > buf_length - count)
    {
      flushBuffer();
    }

    final OutputStream os = m_os;
    final int n = length+start;
    for (int i = start; i < n; i++)
    {
      final char c = chars[i];

      if (c < 0x80)
        buf[count++] = (byte) (c);
      else if (c < 0x800)
      {
        buf[count++] = (byte) (0xc0 + (c >> 6));
        buf[count++] = (byte) (0x80 + (c & 0x3f));
      }
      else
      {
        buf[count++] = (byte) (0xe0 + (c >> 12));
        buf[count++] = (byte) (0x80 + ((c >> 6) & 0x3f));
        buf[count++] = (byte) (0x80 + (c & 0x3f));
      }
    }

  }

  
  public void write(final String s) throws IOException
  {

    final int length = s.length();

    
    
    

    int lengthx3 = (length << 1) + length;

    if (lengthx3 >= buf_length)
    {

      
      flushBuffer();
      writeDirect(s);

      return;
    }

    if (lengthx3 > buf_length - count)
    {
      flushBuffer();
    }

    final OutputStream os = m_os;

    for (int i = 0; i < length; i++)
    {
      final char c = s.charAt(i);

      if (c < 0x80)
        buf[count++] = (byte) (c);
      else if (c < 0x800)
      {
        buf[count++] = (byte) (0xc0 + (c >> 6));
        buf[count++] = (byte) (0x80 + (c & 0x3f));
      }
      else
      {
        buf[count++] = (byte) (0xe0 + (c >> 12));
        buf[count++] = (byte) (0x80 + ((c >> 6) & 0x3f));
        buf[count++] = (byte) (0x80 + (c & 0x3f));
      }
    }

  }

  
  public void flushBuffer() throws IOException
  {

    if (count > 0)
    {
      m_os.write(buf, 0, count);

      count = 0;
    }
  }

  
  public void flush() throws java.io.IOException
  {
    flushBuffer();
    m_os.flush();
  }

  
  public void close() throws java.io.IOException
  {
    flushBuffer();
    m_os.close();
  }

  
  public OutputStream getOutputStream()
  {
    return m_os;
  }
}
"
org.apache.xalan.xsltc.compiler.Instruction,3,2,26,36,9,3,28,8,2,2.0,24,0.0,0,0.964285714,0.5,1,2,7.0,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

abstract class Instruction extends SyntaxTreeNode {
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return typeCheckContents(stable);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ErrorMsg msg = new ErrorMsg(ErrorMsg.NOT_IMPLEMENTED_ERR,
				    getClass(), this);
	getParser().reportError(FATAL, msg);
    }
}
"
org.w3c.dom.xpath.XPathNSResolver,1,1,0,0,1,0,0,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.w3c.dom.xpath;



public interface XPathNSResolver {
    
    public String lookupNamespaceURI(String prefix);

}
"
org.apache.xalan.client.XSLTProcessorApplet,29,5,0,2,74,300,1,2,21,0.879251701,782,0.857142857,1,0.94214876,0.344827586,3,5,25.24137931,10,1.5172,2,"
package org.apache.xalan.client;

import java.applet.Applet;
import java.awt.Graphics;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.StringReader;
import java.io.StringWriter;
import java.net.MalformedURLException;
import java.net.URL;

import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


public class XSLTProcessorApplet extends Applet
{

  
  TransformerFactory m_tfactory = null;

  
  private String m_styleURL;

  
  private String m_documentURL;

  
  
  

  
  private final String PARAM_styleURL = ""styleURL"";

  
  private final String PARAM_documentURL = ""documentURL"";


  
  

  
  private String m_styleURLOfCached = null;

  
  private String m_documentURLOfCached = null;

  
  private URL m_codeBase = null;
  
  
  private String m_treeURL = null;

  
  private URL m_documentBase = null;

  
  transient private Thread m_callThread = null;

  
  transient private TrustedAgent m_trustedAgent = null;

  
  transient private Thread m_trustedWorker = null;

  
  transient private String m_htmlText = null;
  
  
  transient private String m_sourceText = null;
  
  
  transient private String m_nameOfIDAttrOfElemToModify = null;

  
  transient private String m_elemIdToModify = null;

  
  transient private String m_attrNameToSet = null;

  
  transient private String m_attrValueToSet = null;

  
  public XSLTProcessorApplet(){}

  
  public String getAppletInfo()
  {
    return ""Name: XSLTProcessorApplet
"" + ""Author: Scott Boag"";
  }

  
  public String[][] getParameterInfo()
  {

    String[][] info =
    {
      { PARAM_styleURL, ""String"", ""URL to an XSL stylesheet"" },
      { PARAM_documentURL, ""String"", ""URL to an XML document"" },
    };

    return info;
  }

  
  public void init()
  {

    
    
    
    
    
    String param;

    
    
    param = getParameter(PARAM_styleURL);

    if (param != null)
      setStyleURL(param);

    
    
    param = getParameter(PARAM_documentURL);

    if (param != null)
      setDocumentURL(param);

    m_codeBase = this.getCodeBase();
    m_documentBase = this.getDocumentBase();

    
    
    
    
    
    
    resize(320, 240);
  }
  
    
  public void start()
  {

    m_trustedAgent = new TrustedAgent();
    Thread currentThread = Thread.currentThread();
    m_trustedWorker = new Thread(currentThread.getThreadGroup(),
                                 m_trustedAgent);
    m_trustedWorker.start();
    try
    {
      m_tfactory = TransformerFactory.newInstance();
      this.showStatus(""Causing Transformer and Parser to Load and JIT..."");

      
      StringReader xmlbuf = new StringReader(""<?xml version='1.0'?><foo/>"");
      StringReader xslbuf = new StringReader(
        ""<?xml version='1.0'?><xsl:stylesheet xmlns:xsl='http:
      PrintWriter pw = new PrintWriter(new StringWriter());

      synchronized (m_tfactory)
      {
        Templates templates = m_tfactory.newTemplates(new StreamSource(xslbuf));
        Transformer transformer = templates.newTransformer();
        transformer.transform(new StreamSource(xmlbuf), new StreamResult(pw));
      }
      System.out.println(""Primed the pump!"");
      this.showStatus(""Ready to go!"");
    }
    catch (Exception e)
    {
      this.showStatus(""Could not prime the pump!"");
      System.out.println(""Could not prime the pump!"");
      e.printStackTrace();
    }
  }

  
  public void paint(Graphics g){}  
  
  
  public void stop()
  {
    if (null != m_trustedWorker)
    {
      m_trustedWorker.stop();

      
      m_trustedWorker = null;
    }

    m_styleURLOfCached = null;
    m_documentURLOfCached = null;
  }   
  
  
  public void destroy()
  {
    if (null != m_trustedWorker)
    {
      m_trustedWorker.stop();

      
      m_trustedWorker = null;
    }
    m_styleURLOfCached = null;
    m_documentURLOfCached = null;
  }

  
  public void setStyleURL(String urlString)
  {
    m_styleURL = urlString;
  }

  
  public void setDocumentURL(String urlString)
  {
    m_documentURL = urlString;
  }

  
  public void freeCache()
  {
    m_styleURLOfCached = null;
    m_documentURLOfCached = null;
  }

  
  public void setStyleSheetAttribute(String nameOfIDAttrOfElemToModify,
                                     String elemId, String attrName,
                                     String value)
  {
    m_nameOfIDAttrOfElemToModify = nameOfIDAttrOfElemToModify;
    m_elemIdToModify = elemId;
    m_attrNameToSet = attrName;
    m_attrValueToSet = value;
  }

  
  transient String m_key;

  
  transient String m_expression;

  
  public void setStylesheetParam(String key, String expr)
  {
    m_key = key;
    m_expression = expr;
  }

  
  public String escapeString(String s)
  {
    StringBuffer sb = new StringBuffer();
    int length = s.length();

    for (int i = 0; i < length; i++)
    {
      char ch = s.charAt(i);

      if ('<' == ch)
      {
        sb.append(""&lt;"");
      }
      else if ('>' == ch)
      {
        sb.append(""&gt;"");
      }
      else if ('&' == ch)
      {
        sb.append(""&amp;"");
      }
      else if (0xd800 <= ch && ch < 0xdc00)
      {
        
        int next;

        if (i + 1 >= length)
        {
          throw new RuntimeException(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_INVALID_UTF16_SURROGATE,
              new Object[]{ Integer.toHexString(ch) }));  

          
        }
        else
        {
          next = s.charAt(++i);

          if (!(0xdc00 <= next && next < 0xe000))
            throw new RuntimeException(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_INVALID_UTF16_SURROGATE,
                new Object[]{
                  Integer.toHexString(ch) + "" ""
                  + Integer.toHexString(next) }));  

          
          next = ((ch - 0xd800) << 10) + next - 0xdc00 + 0x00010000;
        }
        sb.append(""&#x"");
        sb.append(Integer.toHexString(next));
        sb.append("";"");
      }
      else
      {
        sb.append(ch);
      }
    }
    return sb.toString();
  }

  
  public String getHtmlText()
  {
    m_trustedAgent.m_getData = true;
    m_callThread = Thread.currentThread();
    try
    {
      synchronized (m_callThread)
      {
        m_callThread.wait();
      }
    }
    catch (InterruptedException ie)
    {
      System.out.println(ie.getMessage());
    }
    return m_htmlText;
  }

  
  public String getTreeAsText(String treeURL) throws IOException
  {
    m_treeURL = treeURL;
    m_trustedAgent.m_getData = true;
    m_trustedAgent.m_getSource = true;
    m_callThread = Thread.currentThread();
    try
    {
      synchronized (m_callThread)
      {
        m_callThread.wait();
      }
    }
    catch (InterruptedException ie)
    {
      System.out.println(ie.getMessage());
    }
    return m_sourceText;
  }
  
  
  private String getSource() throws TransformerException
  {
    StringWriter osw = new StringWriter();
    PrintWriter pw = new PrintWriter(osw, false);
    String text = """";
    try
    {
      URL docURL = new URL(m_documentBase, m_treeURL);
      synchronized (m_tfactory)
      {
        Transformer transformer = m_tfactory.newTransformer();
        StreamSource source = new StreamSource(docURL.toString());    
        StreamResult result = new StreamResult(pw);
        transformer.transform(source, result);
        text = osw.toString();
      }
    }
    catch (MalformedURLException e)
    {
      e.printStackTrace();
      System.exit(-1);
    }      
    catch (Exception any_error)
    {
      any_error.printStackTrace();
    }
    return text;
  }

  
  public String getSourceTreeAsText() throws Exception
  {
    return getTreeAsText(m_documentURL);
  }

  
  public String getStyleTreeAsText() throws Exception
  {
    return getTreeAsText(m_styleURL);
  }

  
  public String getResultTreeAsText() throws Exception
  {
    return escapeString(getHtmlText());
  }

  
  public String transformToHtml(String doc, String style)
  {

    if (null != doc)
    {
      m_documentURL = doc;
    }

    if (null != style)
    {
      m_styleURL = style;
    }

    return getHtmlText();
  }

  
  public String transformToHtml(String doc)
  {

    if (null != doc)
    {
      m_documentURL = doc;
    }

    m_styleURL = null;

    return getHtmlText();
  }


  
  private String processTransformation() throws TransformerException
  {
    String htmlData = null;
    this.showStatus(""Waiting for Transformer and Parser to finish loading and JITing..."");
    
    synchronized (m_tfactory)
    {
     URL documentURL = null;
      URL styleURL = null;
      StringWriter osw = new StringWriter();
      PrintWriter pw = new PrintWriter(osw, false);
      StreamResult result = new StreamResult(pw);
    
      this.showStatus(""Begin Transformation..."");
      try
      {
        documentURL = new URL(m_codeBase, m_documentURL);
        StreamSource xmlSource = new StreamSource(documentURL.toString());

        styleURL = new URL(m_codeBase, m_styleURL);
        StreamSource xslSource = new StreamSource(styleURL.toString());

        Transformer transformer = m_tfactory.newTransformer(xslSource);

        if (null != m_key)
          transformer.setParameter(m_key, m_expression);
      
         transformer.transform(xmlSource, result);
      }
      catch (TransformerConfigurationException tfe)
      {
        tfe.printStackTrace();
        System.exit(-1);
      }
      catch (MalformedURLException e)
      {
        e.printStackTrace();
        System.exit(-1);
      }
	  
      this.showStatus(""Transformation Done!"");
      htmlData = osw.toString();
    }
    return htmlData;
  }

  
  class TrustedAgent implements Runnable
  {

    
    public boolean m_getData = false;

    
    public boolean m_getSource = false;

    
    public void run()
    {
      while (true)
      {
        m_trustedWorker.yield();

        if (m_getData)  
        {
          try
          {
            m_getData = false;
            m_htmlText = null;
            m_sourceText = null;
            if (m_getSource)  
            {
              m_getSource = false;
              m_sourceText = getSource();
            }
            else              
              m_htmlText = processTransformation();
          }
          catch (Exception e)
          {
            e.printStackTrace();
          }
          finally
          {
            synchronized (m_callThread)
            {
              m_callThread.notify();
            }
          }
        }
        else
        {
          try
          {
            m_trustedWorker.sleep(50);
          }
          catch (InterruptedException ie)
          {
            ie.printStackTrace();
          }
        }
      }
    }
  }
}
"
org.apache.xalan.xslt.Process,7,1,0,8,109,21,0,8,2,2.0,2034,0.0,0,0.0,0.2,0,0,289.5714286,138,20.4286,2,"
package org.apache.xalan.xslt;

import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.io.StringReader;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import org.apache.xalan.processor.XSLProcessorVersion;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.trace.PrintTraceListener;
import org.apache.xalan.trace.TraceManager;
import org.apache.xalan.transformer.XalanProperties;
import org.apache.xml.utils.DefaultErrorHandler;

import org.w3c.dom.Document;
import org.w3c.dom.Node;

import org.xml.sax.ContentHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;


public class Process
{
  
  protected static void printArgOptions(ResourceBundle resbundle)
  {
    System.out.println(resbundle.getString(""xslProc_option""));  
    System.out.println(""
			"" + resbundle.getString(""xslProc_common_options"") + ""
"");
    System.out.println(resbundle.getString(""optionXSLTC""));  
    System.out.println(resbundle.getString(""optionIN""));  
    System.out.println(resbundle.getString(""optionXSL""));  
    System.out.println(resbundle.getString(""optionOUT""));  

    
    System.out.println(resbundle.getString(""optionV""));  

    
    System.out.println(resbundle.getString(""optionEDUMP""));  
    System.out.println(resbundle.getString(""optionXML""));  
    System.out.println(resbundle.getString(""optionTEXT""));  
    System.out.println(resbundle.getString(""optionHTML""));  
    System.out.println(resbundle.getString(""optionPARAM""));  
    
    System.out.println(resbundle.getString(""optionMEDIA""));
    System.out.println(resbundle.getString(""optionFLAVOR""));
    System.out.println(resbundle.getString(""optionDIAG""));
    System.out.println(resbundle.getString(""optionURIRESOLVER""));  
    System.out.println(resbundle.getString(""optionENTITYRESOLVER""));  
    waitForReturnKey(resbundle);
    System.out.println(resbundle.getString(""optionCONTENTHANDLER""));  
    
    System.out.println(""
			"" + resbundle.getString(""xslProc_xalan_options"") + ""
"");
    
    System.out.println(resbundle.getString(""optionQC""));  

    
    System.out.println(resbundle.getString(""optionTT""));  
    System.out.println(resbundle.getString(""optionTG""));  
    System.out.println(resbundle.getString(""optionTS""));  
    System.out.println(resbundle.getString(""optionTTC""));  
    System.out.println(resbundle.getString(""optionTCLASS""));  
    System.out.println(resbundle.getString(""optionLINENUMBERS"")); 
    System.out.println(resbundle.getString(""optionINCREMENTAL""));
    System.out.println(resbundle.getString(""optionNOOPTIMIMIZE""));
    System.out.println(resbundle.getString(""optionRL""));
        
    System.out.println(""
			"" + resbundle.getString(""xslProc_xsltc_options"") + ""
"");
    System.out.println(resbundle.getString(""optionXO""));
    System.out.println(resbundle.getString(""optionXD""));
    waitForReturnKey(resbundle);    
    System.out.println(resbundle.getString(""optionXJ""));
    System.out.println(resbundle.getString(""optionXP""));
    System.out.println(resbundle.getString(""optionXN""));
    System.out.println(resbundle.getString(""optionXX""));
    System.out.println(resbundle.getString(""optionXT""));
  }
  
  
  public static void main(String argv[])
  {
    
    
    boolean doStackDumpOnError = false;
    boolean setQuietMode = false;
    boolean doDiag = false;

    
    

    
    java.io.PrintWriter diagnosticsWriter = new PrintWriter(System.err, true);
    java.io.PrintWriter dumpWriter = diagnosticsWriter;
    ResourceBundle resbundle =
      (XSLMessages.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.ERROR_RESOURCES));
    String flavor = ""s2s"";

    if (argv.length < 1)
    {
      printArgOptions(resbundle);
    }
    else
    {
      boolean useXSLTC = false;
      for (int i = 0; i < argv.length; i++)
      {
        if (""-XSLTC"".equalsIgnoreCase(argv[i]))
        {
          useXSLTC = true;
        }
      }
        
      TransformerFactory tfactory;
      if (useXSLTC)
      {
	 String key = ""javax.xml.transform.TransformerFactory"";
	 String value = ""org.apache.xalan.xsltc.trax.TransformerFactoryImpl"";
	 Properties props = System.getProperties();
	 props.put(key, value);
	 System.setProperties(props);      
      }
      
      try
      {
        tfactory = TransformerFactory.newInstance();
      }
      catch (TransformerFactoryConfigurationError pfe)
      {
        pfe.printStackTrace(dumpWriter);
        diagnosticsWriter.println(
          XSLMessages.createMessage(
            XSLTErrorResources.ER_NOT_SUCCESSFUL, null));  

        tfactory = null;  

        doExit(-1);
      }

      boolean formatOutput = false;
      boolean useSourceLocation = false;
      String inFileName = null;
      String outFileName = null;
      String dumpFileName = null;
      String xslFileName = null;
      String treedumpFileName = null;
      PrintTraceListener tracer = null;
      String outputType = null;
      String media = null;
      Vector params = new Vector();
      boolean quietConflictWarnings = false;
      URIResolver uriResolver = null;
      EntityResolver entityResolver = null;
      ContentHandler contentHandler = null;
      int recursionLimit=-1;

      for (int i = 0; i < argv.length; i++)
      {
        if (""-XSLTC"".equalsIgnoreCase(argv[i]))
        {
          
        }
        else if (""-TT"".equalsIgnoreCase(argv[i]))
        {
          if (!useXSLTC)
          {
            if (null == tracer)
              tracer = new PrintTraceListener(diagnosticsWriter);

            tracer.m_traceTemplates = true;
          }
          else
            printInvalidXSLTCOption(""-TT"");

          
        }
        else if (""-TG"".equalsIgnoreCase(argv[i]))
        {
          if (!useXSLTC)
          {
            if (null == tracer)
              tracer = new PrintTraceListener(diagnosticsWriter);

            tracer.m_traceGeneration = true;
          }
          else
            printInvalidXSLTCOption(""-TG"");

          
        }
        else if (""-TS"".equalsIgnoreCase(argv[i]))
        {
          if (!useXSLTC)
          {
            if (null == tracer)
              tracer = new PrintTraceListener(diagnosticsWriter);

            tracer.m_traceSelection = true;
          }
          else
            printInvalidXSLTCOption(""-TS"");

          
        }
        else if (""-TTC"".equalsIgnoreCase(argv[i]))
        {
          if (!useXSLTC)
          {
            if (null == tracer)
              tracer = new PrintTraceListener(diagnosticsWriter);

            tracer.m_traceElements = true;
          }
          else
            printInvalidXSLTCOption(""-TTC"");

          
        }
        else if (""-INDENT"".equalsIgnoreCase(argv[i]))
        {
          int indentAmount;

          if (((i + 1) < argv.length) && (argv[i + 1].charAt(0) != '-'))
          {
            indentAmount = Integer.parseInt(argv[++i]);
          }
          else
          {
            indentAmount = 0;
          }

          
          
        }
        else if (""-IN"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length && argv[i + 1].charAt(0) != '-')
            inFileName = argv[++i];
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-IN"" }));  
        }
        else if (""-MEDIA"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
            media = argv[++i];
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-MEDIA"" }));  
        }
        else if (""-OUT"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length && argv[i + 1].charAt(0) != '-')
            outFileName = argv[++i];
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-OUT"" }));  
        }
        else if (""-XSL"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length && argv[i + 1].charAt(0) != '-')
            xslFileName = argv[++i];
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-XSL"" }));  
        }
        else if (""-FLAVOR"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
          {
            flavor = argv[++i];
          }
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-FLAVOR"" }));  
        }
        else if (""-PARAM"".equalsIgnoreCase(argv[i]))
        {
          if (i + 2 < argv.length)
          {
            String name = argv[++i];

            params.addElement(name);

            String expression = argv[++i];

            params.addElement(expression);
          }
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-PARAM"" }));  
        }
        else if (""-E"".equalsIgnoreCase(argv[i]))
        {

          
          
        }
        else if (""-V"".equalsIgnoreCase(argv[i]))
        {
          diagnosticsWriter.println(resbundle.getString(""version"")  
                                    + XSLProcessorVersion.S_VERSION + "", "" +

          
          resbundle.getString(""version2""));  
        }
        else if (""-QC"".equalsIgnoreCase(argv[i]))
        {
          if (!useXSLTC)
            quietConflictWarnings = true;
          else
            printInvalidXSLTCOption(""-QC"");
        }
        else if (""-Q"".equalsIgnoreCase(argv[i]))
        {
          setQuietMode = true;
        }
        else if (""-DIAG"".equalsIgnoreCase(argv[i]))
        {
          doDiag = true;
        }
        else if (""-XML"".equalsIgnoreCase(argv[i]))
        {
          outputType = ""xml"";
        }
        else if (""-TEXT"".equalsIgnoreCase(argv[i]))
        {
          outputType = ""text"";
        }
        else if (""-HTML"".equalsIgnoreCase(argv[i]))
        {
          outputType = ""html"";
        }
        else if (""-EDUMP"".equalsIgnoreCase(argv[i]))
        {
          doStackDumpOnError = true;

          if (((i + 1) < argv.length) && (argv[i + 1].charAt(0) != '-'))
          {
            dumpFileName = argv[++i];
          }
        }
        else if (""-URIRESOLVER"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
          {
            try
            {
              uriResolver =
                (URIResolver) Class.forName(argv[++i],true,ClassLoader.getSystemClassLoader()).newInstance();

              tfactory.setURIResolver(uriResolver);
            }
            catch (Exception cnfe)
            {
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_CLASS_NOT_FOUND_FOR_OPTION,
                  new Object[]{ ""-URIResolver"" }));
              doExit(-1);
            }
          }
          else
          {
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-URIResolver"" }));  
            doExit(-1);
          }
        }
        else if (""-ENTITYRESOLVER"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
          {
            try
            {
              entityResolver =
                (EntityResolver) Class.forName(argv[++i],true,ClassLoader.getSystemClassLoader()).newInstance();
            }
            catch (Exception cnfe)
            {
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_CLASS_NOT_FOUND_FOR_OPTION,
                  new Object[]{ ""-EntityResolver"" }));
              doExit(-1);
            }
          }
          else
          {
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-EntityResolver"" }));  
            doExit(-1);
          }
        }
        else if (""-CONTENTHANDLER"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
          {
            try
            {
              contentHandler =
                (ContentHandler) Class.forName(argv[++i],true,ClassLoader.getSystemClassLoader()).newInstance();
            }
            catch (Exception cnfe)
            {
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_CLASS_NOT_FOUND_FOR_OPTION,
                  new Object[]{ ""-ContentHandler"" }));
              doExit(-1);
            }
          }
          else
          {
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-ContentHandler"" }));  
            doExit(-1);
          }
        }
        else if (""-L"".equalsIgnoreCase(argv[i]))
        {
          if (!useXSLTC)
            useSourceLocation = true;
          else
            printInvalidXSLTCOption(""-L"");
        }
        else if (""-INCREMENTAL"".equalsIgnoreCase(argv[i]))
        {
          if (!useXSLTC)
            tfactory.setAttribute
              (""http:
               java.lang.Boolean.TRUE);
          else
            printInvalidXSLTCOption(""-INCREMENTAL"");
        }
        else if (""-NOOPTIMIZE"".equalsIgnoreCase(argv[i]))
        {
          
          
          
          
          
          if (!useXSLTC)
            tfactory.setAttribute
              (""http:
               java.lang.Boolean.FALSE);
          else
            printInvalidXSLTCOption(""-NOOPTIMIZE"");
	}
        else if (""-RL"".equalsIgnoreCase(argv[i]))
        {
          if (!useXSLTC)
          {
            if (i + 1 < argv.length)
              recursionLimit = Integer.parseInt(argv[++i]);
            else
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                  new Object[]{ ""-rl"" }));  
          }
          else
          {
            if (i + 1 < argv.length && argv[i + 1].charAt(0) != '-')
             i++;
             
            printInvalidXSLTCOption(""-RL"");
          }
        }
        
        
        else if (""-XO"".equalsIgnoreCase(argv[i]))
        {
          if (useXSLTC)
          {
            if (i + 1 < argv.length && argv[i+1].charAt(0) != '-')
            {
              tfactory.setAttribute(""generate-translet"", ""true"");
              tfactory.setAttribute(""translet-name"", argv[++i]);
            }
            else
              tfactory.setAttribute(""generate-translet"", ""true"");
          }
          else
          {
            if (i + 1 < argv.length && argv[i + 1].charAt(0) != '-')
             i++;
            printInvalidXalanOption(""-XO"");
          }
        }
        
        else if (""-XD"".equalsIgnoreCase(argv[i]))
        {
          if (useXSLTC)
          {
            if (i + 1 < argv.length && argv[i+1].charAt(0) != '-')
              tfactory.setAttribute(""destination-directory"", argv[++i]);
            else
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                  new Object[]{ ""-XD"" }));  
            
          }          
          else
          {
            if (i + 1 < argv.length && argv[i + 1].charAt(0) != '-')
             i++;
             
            printInvalidXalanOption(""-XD"");
          }
        }
        
        else if (""-XJ"".equalsIgnoreCase(argv[i]))
        {
          if (useXSLTC)
          {
            if (i + 1 < argv.length && argv[i+1].charAt(0) != '-')
            {
              tfactory.setAttribute(""generate-translet"", ""true"");
              tfactory.setAttribute(""jar-name"", argv[++i]);
            }
            else
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                  new Object[]{ ""-XJ"" }));  
          }                    
          else
          {
            if (i + 1 < argv.length && argv[i + 1].charAt(0) != '-')
             i++;
             
            printInvalidXalanOption(""-XJ"");
          }
        
        }
        
        else if (""-XP"".equalsIgnoreCase(argv[i]))
        {
          if (useXSLTC)
          {
            if (i + 1 < argv.length && argv[i+1].charAt(0) != '-')
              tfactory.setAttribute(""package-name"", argv[++i]);
            else
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                  new Object[]{ ""-XP"" }));  
          }                              
          else
          {
            if (i + 1 < argv.length && argv[i + 1].charAt(0) != '-')
             i++;
             
            printInvalidXalanOption(""-XP"");
          }
        
        }
        
        else if (""-XN"".equalsIgnoreCase(argv[i]))
        {
          if (useXSLTC)
          {
            tfactory.setAttribute(""enable-inlining"", ""true"");
          }                                        
          else
            printInvalidXalanOption(""-XN"");        
        }
        
        else if (""-XX"".equalsIgnoreCase(argv[i]))
        {
          if (useXSLTC)
          {
            tfactory.setAttribute(""debug"", ""true"");
          }                                        
          else
            printInvalidXalanOption(""-XX"");        
        }
        
        
        else if (""-XT"".equalsIgnoreCase(argv[i]))
        {
          if (useXSLTC)
          {
            tfactory.setAttribute(""auto-translet"", ""true"");
          }                                        
          else
            printInvalidXalanOption(""-XT"");        
        }
        else
          System.err.println(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_INVALID_OPTION, new Object[]{ argv[i] }));  
      }
      
      
      if (inFileName == null && xslFileName == null)
      {
        System.err.println(resbundle.getString(""xslProc_no_input""));
        doExit(-1);
      }

      
      
      try
      {
        long start = System.currentTimeMillis();

        if (null != dumpFileName)
        {
          dumpWriter = new PrintWriter(new FileWriter(dumpFileName));
        }

        Templates stylesheet = null;

        if (null != xslFileName)
        {
          if (flavor.equals(""d2d""))
          {

            
            DocumentBuilderFactory dfactory =
              DocumentBuilderFactory.newInstance();

            dfactory.setNamespaceAware(true);

            DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
            Node xslDOM = docBuilder.parse(new InputSource(xslFileName));

            stylesheet = tfactory.newTemplates(new DOMSource(xslDOM,
                    xslFileName));
          }
          else
          {
            
            stylesheet = tfactory.newTemplates(new StreamSource(xslFileName));
            
          }
        }

        PrintWriter resultWriter;
        StreamResult strResult;

        if (null != outFileName)
        {
          strResult = new StreamResult(new FileOutputStream(outFileName));
          
          
          
          
          strResult.setSystemId(outFileName);
        }
        else
        {
          strResult = new StreamResult(System.out);
	  
	  
	  
	  
        }

        SAXTransformerFactory stf = (SAXTransformerFactory) tfactory;
        
		
        if (!useXSLTC && useSourceLocation)
           stf.setAttribute(XalanProperties.SOURCE_LOCATION, Boolean.TRUE);        

        
        
        if (null == stylesheet)
        {
          Source source =
            stf.getAssociatedStylesheet(new StreamSource(inFileName), media,
                                        null, null);

          if (null != source)
            stylesheet = tfactory.newTemplates(source);
          else
          {
            if (null != media)
              throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_STYLESHEET_IN_MEDIA, new Object[]{inFileName, media})); 
                                            
                                            
            else
              throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_STYLESHEET_PI, new Object[]{inFileName})); 
                                             
          }
        }

        if (null != stylesheet)
        {
          Transformer transformer = flavor.equals(""th"") ? null : stylesheet.newTransformer();

          
          if (null != outputType)
          {
            transformer.setOutputProperty(OutputKeys.METHOD, outputType);
          }

          if (transformer instanceof org.apache.xalan.transformer.TransformerImpl)
          {
            org.apache.xalan.transformer.TransformerImpl impl = (org.apache.xalan.transformer.TransformerImpl)transformer;
            TraceManager tm = impl.getTraceManager();

            if (null != tracer)
              tm.addTraceListener(tracer);

            impl.setQuietConflictWarnings(quietConflictWarnings);

			
            if (useSourceLocation)
              impl.setProperty(XalanProperties.SOURCE_LOCATION, Boolean.TRUE);

	    if(recursionLimit>0)
	      impl.setRecursionLimit(recursionLimit);

            
            
          }

          int nParams = params.size();

          for (int i = 0; i < nParams; i += 2)
          {
            transformer.setParameter((String) params.elementAt(i),
                                     (String) params.elementAt(i + 1));
          }

          if (uriResolver != null)
            transformer.setURIResolver(uriResolver);

          if (null != inFileName)
          {
            if (flavor.equals(""d2d""))
            {

              
              DocumentBuilderFactory dfactory =
                DocumentBuilderFactory.newInstance();

              dfactory.setCoalescing(true);
              dfactory.setNamespaceAware(true);

              DocumentBuilder docBuilder = dfactory.newDocumentBuilder();

              if (entityResolver != null)
                docBuilder.setEntityResolver(entityResolver);

              Node xmlDoc = docBuilder.parse(new InputSource(inFileName));
              Document doc = docBuilder.newDocument();
              org.w3c.dom.DocumentFragment outNode =
                doc.createDocumentFragment();

              transformer.transform(new DOMSource(xmlDoc, inFileName),
                                    new DOMResult(outNode));

              
              Transformer serializer = stf.newTransformer();
              Properties serializationProps =
                stylesheet.getOutputProperties();

              serializer.setOutputProperties(serializationProps);

              if (contentHandler != null)
              {
                SAXResult result = new SAXResult(contentHandler);

                serializer.transform(new DOMSource(outNode), result);
              }
              else
                serializer.transform(new DOMSource(outNode), strResult);
            }
            else if (flavor.equals(""th""))
            {
              for (int i = 0; i < 1; i++) 
              {
              

              
              XMLReader reader = null;

              
              try
              {
                javax.xml.parsers.SAXParserFactory factory =
                  javax.xml.parsers.SAXParserFactory.newInstance();

                factory.setNamespaceAware(true);

                javax.xml.parsers.SAXParser jaxpParser =
                  factory.newSAXParser();

                reader = jaxpParser.getXMLReader();
              }
              catch (javax.xml.parsers.ParserConfigurationException ex)
              {
                throw new org.xml.sax.SAXException(ex);
              }
              catch (javax.xml.parsers.FactoryConfigurationError ex1)
              {
                throw new org.xml.sax.SAXException(ex1.toString());
              }
              catch (NoSuchMethodError ex2){}
              catch (AbstractMethodError ame){}

              if (null == reader)
              {
                reader = XMLReaderFactory.createXMLReader();
              }
              
              if (!useXSLTC)
                stf.setAttribute(org.apache.xalan.processor.TransformerFactoryImpl.FEATURE_INCREMENTAL, 
                   Boolean.TRUE);
                 
              TransformerHandler th = stf.newTransformerHandler(stylesheet);
              
              reader.setContentHandler(th);
              reader.setDTDHandler(th);
              
              if(th instanceof org.xml.sax.ErrorHandler)
                reader.setErrorHandler((org.xml.sax.ErrorHandler)th);
              
              try
              {
                reader.setProperty(
                  ""http:
              }
              catch (org.xml.sax.SAXNotRecognizedException e){}
              catch (org.xml.sax.SAXNotSupportedException e){}
              try
              {
                reader.setFeature(""http:
                                  true);
              } catch (org.xml.sax.SAXException se) {}
        
              th.setResult(strResult);
              
              reader.parse(new InputSource(inFileName));
              }                            
            }
            else
            {
              if (entityResolver != null)
              {
                XMLReader reader = null;

                
                try
                {
                  javax.xml.parsers.SAXParserFactory factory =
                    javax.xml.parsers.SAXParserFactory.newInstance();

                  factory.setNamespaceAware(true);

                  javax.xml.parsers.SAXParser jaxpParser =
                    factory.newSAXParser();

                  reader = jaxpParser.getXMLReader();
                }
                catch (javax.xml.parsers.ParserConfigurationException ex)
                {
                  throw new org.xml.sax.SAXException(ex);
                }
                catch (javax.xml.parsers.FactoryConfigurationError ex1)
                {
                  throw new org.xml.sax.SAXException(ex1.toString());
                }
                catch (NoSuchMethodError ex2){}
                catch (AbstractMethodError ame){}

                if (null == reader)
                {
                  reader = XMLReaderFactory.createXMLReader();
                }

                reader.setEntityResolver(entityResolver);

                if (contentHandler != null)
                {
                  SAXResult result = new SAXResult(contentHandler);

                  transformer.transform(
                    new SAXSource(reader, new InputSource(inFileName)),
                    result);
                }
                else
                {
                  transformer.transform(
                    new SAXSource(reader, new InputSource(inFileName)),
                    strResult);
                }
              }
              else if (contentHandler != null)
              {
                SAXResult result = new SAXResult(contentHandler);

                transformer.transform(new StreamSource(inFileName), result);
              }
              else
              {
                
                transformer.transform(new StreamSource(inFileName),
                                      strResult);
                
              }
            }
          }
          else
          {
            StringReader reader =
              new StringReader(""<?xml version=""1.0""?> <doc/>"");

            transformer.transform(new StreamSource(reader), strResult);
          }
        }
        else
        {
          diagnosticsWriter.println(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_NOT_SUCCESSFUL, null));  
          doExit(-1);
        }
        
	
	if (null != outFileName && strResult!=null)
	{
   	  java.io.OutputStream out = strResult.getOutputStream();
   	  java.io.Writer writer = strResult.getWriter();
   	  try
   	  {
      	    if (out != null) out.close();
      	    if (writer != null) writer.close();
   	  }
   	  catch(java.io.IOException ie) {}
	}        

        long stop = System.currentTimeMillis();
        long millisecondsDuration = stop - start;

        if (doDiag)
        {
        	Object[] msgArgs = new Object[]{ inFileName, xslFileName, new Long(millisecondsDuration) };
        	String msg = XSLMessages.createMessage(""diagTiming"", msgArgs);
        	diagnosticsWriter.println('
');
          	diagnosticsWriter.println(msg);
        }
          
      }
      catch (Throwable throwable)
      {
        while (throwable
               instanceof org.apache.xml.utils.WrappedRuntimeException)
        {
          throwable =
            ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();
        }

        if ((throwable instanceof NullPointerException)
                || (throwable instanceof ClassCastException))
          doStackDumpOnError = true;

        diagnosticsWriter.println();

        if (doStackDumpOnError)
          throwable.printStackTrace(dumpWriter);
        else
        {
          DefaultErrorHandler.printLocation(diagnosticsWriter, throwable);
          diagnosticsWriter.println(
            XSLMessages.createMessage(XSLTErrorResources.ER_XSLT_ERROR, null)
            + "" ("" + throwable.getClass().getName() + ""): ""
            + throwable.getMessage());
        }

        
        if (null != dumpFileName)
        {
          dumpWriter.close();
        }

        doExit(-1);
      }

      if (null != dumpFileName)
      {
        dumpWriter.close();
      }

      if (null != diagnosticsWriter)
      {

        
      }

      
      
      
      diagnosticsWriter.println("""");  
    }
  }
  
  
  static void doExit(int i)
  {
    System.exit(i);
  }
  
  
  private static void waitForReturnKey(ResourceBundle resbundle)
  {
    System.out.println(resbundle.getString(""xslProc_return_to_continue""));
    try
    {
      while (System.in.read() != '
');
    }
    catch (java.io.IOException e) { }  
  }
  
  
  private static void printInvalidXSLTCOption(String option)
  {
    System.err.println(XSLMessages.createMessage(""xslProc_invalid_xsltc_option"", new Object[]{option}));
  }
  
  
  private static void printInvalidXalanOption(String option)
  {
    System.err.println(XSLMessages.createMessage(""xslProc_invalid_xalan_option"", new Object[]{option}));
  }
}
"
org.apache.xml.serializer.ExtendedLexicalHandler,1,1,0,1,1,0,1,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xml.serializer;

import org.xml.sax.SAXException;


public interface ExtendedLexicalHandler extends org.xml.sax.ext.LexicalHandler
{
    
    public void comment(String comment) throws SAXException;
}
"
org.w3c.dom.xpath.XPathNamespace,1,1,0,0,1,0,0,0,1,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.w3c.dom.xpath;


import org.w3c.dom.Element;
import org.w3c.dom.Node;


public interface XPathNamespace extends Node {
    
    
    public static final short XPATH_NAMESPACE_NODE      = 13;

    
    public Element getOwnerElement();

}
"
org.apache.xalan.xsltc.compiler.LiteralAttribute,5,3,0,18,24,0,2,16,4,0.25,84,1.0,1,0.933333333,0.314285714,1,4,15.4,1,0.8,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class LiteralAttribute extends Instruction {

    private final String  _name;         
    private final AttributeValue _value; 

    
    public LiteralAttribute(String name, String value, Parser parser) {
	_name = name;
	_value = AttributeValue.create(this, value, parser);
    }

    public void display(int indent) {
	indent(indent);
	Util.println(""LiteralAttribute name="" + _name + "" value="" + _value);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_value.typeCheck(stable);
	typeCheckContents(stable);
	return Type.Void;
    }

    protected boolean contextDependent() {
	return _value.contextDependent();
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	
	il.append(new PUSH(cpg, _name));
	
	_value.translate(classGen, methodGen);
	
	il.append(methodGen.attribute());
    }
}
"
org.apache.xalan.xsltc.compiler.AlternativePattern,8,4,0,15,27,0,1,14,8,0.142857143,135,1.0,2,0.925531915,0.270833333,2,3,15.625,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.GOTO;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class AlternativePattern extends Pattern {
    private final Pattern _left;
    private final Pattern _right;
		
    
    public AlternativePattern(Pattern left, Pattern right) {
	_left = left;
	_right = right;
    }
		
    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }
    
    public Pattern getLeft() {
	return _left;
    }

    public Pattern getRight() {
	return _right;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_left.typeCheck(stable);
	_right.typeCheck(stable);
	return null;
    }

    public double getPriority() {
	double left = _left.getPriority();
	double right = _right.getPriority();
	
	if (left < right)
	    return(left);
	else
	    return(right);
    }

    public String toString() {
	return ""alternative("" + _left + "", "" + _right + ')';
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();

	_left.translate(classGen, methodGen);
	final InstructionHandle gotot = il.append(new GOTO(null));
	il.append(methodGen.loadContextNode());
	_right.translate(classGen, methodGen);

	_left._trueList.backPatch(gotot);
	_left._falseList.backPatch(gotot.getNext());

	_trueList.append(_right._trueList.add(gotot));
	_falseList.append(_right._falseList);
    }
}
"
org.apache.xalan.lib.ExsltBase,3,1,4,5,14,3,4,1,1,2.0,62,0.0,0,0.0,0.5,0,0,19.66666667,4,1.6667,0,"
package org.apache.xalan.lib;

import org.apache.xml.dtm.ref.DTMNodeProxy;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public abstract class ExsltBase
{
  
  protected static String toString(Node n)
  {
    if (n instanceof DTMNodeProxy)
  	 return ((DTMNodeProxy)n).getStringValue();
    else
    {
      String value = n.getNodeValue();
      if (value == null)
      {
        NodeList nodelist = n.getChildNodes();
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < nodelist.getLength(); i++)
        {
          Node childNode = nodelist.item(i);
          buf.append(toString(childNode));
        }
        return buf.toString();
      }
      else
        return value;
    }
  }
  
  
  protected static double toNumber(Node n)
  {
    double d = 0.0;
    String str = toString(n);
    try
    {
      d = Double.valueOf(str).doubleValue();
    }
    catch (NumberFormatException e)
    {
      d= Double.NaN;  		
    }
    return d;
  }
}"
org.apache.xalan.transformer.KeyManager,2,1,0,10,14,0,2,8,2,0.0,104,1.0,0,0.0,0.583333333,0,0,50.5,1,0.5,0,"
package org.apache.xalan.transformer;

import java.util.Vector;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNodeSet;


public class KeyManager
{

  
  private transient Vector m_key_tables = null;

  
  public XNodeSet getNodeSetDTMByKey(
          XPathContext xctxt, int doc, QName name, XMLString ref, PrefixResolver nscontext)
            throws javax.xml.transform.TransformerException
  {

    XNodeSet nl = null;
    ElemTemplateElement template = (ElemTemplateElement) nscontext;  

    if ((null != template)
            && null != template.getStylesheetRoot().getKeysComposed())
    {
      boolean foundDoc = false;

      if (null == m_key_tables)
      {
        m_key_tables = new Vector(4);
      }
      else
      {
        int nKeyTables = m_key_tables.size();

        for (int i = 0; i < nKeyTables; i++)
        {
          KeyTable kt = (KeyTable) m_key_tables.elementAt(i);

          if (kt.getKeyTableName().equals(name) && doc == kt.getDocKey())
          {
            nl = kt.getNodeSetDTMByKey(name, ref);

            if (nl != null)
            {
              foundDoc = true;

              break;
            }
          }
        }
      }

      if ((null == nl) &&!foundDoc )
      {
        KeyTable kt =
          new KeyTable(doc, nscontext, name,
                       template.getStylesheetRoot().getKeysComposed(),
                       xctxt);

        m_key_tables.addElement(kt);

        if (doc == kt.getDocKey())
        {
          foundDoc = true;
          nl = kt.getNodeSetDTMByKey(name, ref);
        }
      }
    }

    return nl;
  }
}
"
org.apache.xalan.xsltc.compiler.Param,6,4,0,33,62,3,8,29,5,2.0,369,0.0,0,0.938271605,0.305555556,3,16,60.5,7,2.8333,2,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.classfile.Field;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;

final class Param extends VariableBase {

    
    public String toString() {
	return(""param(""+_name+"")"");
    }

    
    public void display(int indent) {
	indent(indent);
	System.out.println(""param "" + _name);
	if (_select != null) {
	    indent(indent + IndentIncrement);
	    System.out.println(""select "" + _select.toString());
	}
	displayContents(indent + IndentIncrement);
    }

    
    public void parseContents(Parser parser) {

	
	super.parseContents(parser);

	
	final SyntaxTreeNode parent = getParent();
	if (parent instanceof Stylesheet) {
	    
	    _isLocal = false;
	    
	    Param param = parser.getSymbolTable().lookupParam(_name);
	    
	    if (param != null) {
		final int us = this.getImportPrecedence();
		final int them = param.getImportPrecedence();
		
		if (us == them) {
		    final String name = _name.toString();
		    reportError(this, parser, ErrorMsg.VARIABLE_REDEF_ERR,name);
		}
		
		else if (them > us) {
		    _ignore = true;
		    return;
		}
		else {
		    param.disable();
		}
	    }
	    
	    ((Stylesheet)parent).addParam(this);
	    parser.getSymbolTable().addParam(this);
	}
	else if (parent instanceof Template) {
	    _isLocal = true;
	    ((Template)parent).hasParams(true);
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_select != null) {
	    _type = _select.typeCheck(stable); 
	    if (_type instanceof ReferenceType == false) {
		_select = new CastExpr(_select, Type.Reference);
	    }
	}
	else if (hasContents()) {
	    typeCheckContents(stable);
	}
	_type = Type.Reference;

	
	
	return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_ignore) return;
	_ignore = true;

	final String name = getVariable();
	final String signature = _type.toSignature();
	final String className = _type.getClassName();

	if (isLocal()) {

	    il.append(classGen.loadTranslet());
	    il.append(new PUSH(cpg, name));
	    translateValue(classGen, methodGen);
	    il.append(new PUSH(cpg, true));

	    
	    il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
							 ADD_PARAMETER,
							 ADD_PARAMETER_SIG)));
	    if (className != EMPTYSTRING) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }

	    _type.translateUnBox(classGen, methodGen);

	    if (_refs.isEmpty()) { 
		il.append(_type.POP());
		_local = null;
	    }
	    else {		
		_local = methodGen.addLocalVariable2(name,
						     _type.toJCType(),
						     il.getEnd());
		
		il.append(_type.STORE(_local.getIndex()));
	    }
	}
	else {
	    if (classGen.containsField(name) == null) {
		classGen.addField(new Field(ACC_PUBLIC, cpg.addUtf8(name),
					    cpg.addUtf8(signature),
					    null, cpg.getConstantPool()));
		il.append(classGen.loadTranslet());
		il.append(DUP);
		il.append(new PUSH(cpg, name));
		translateValue(classGen, methodGen);
		il.append(new PUSH(cpg, true));

		
		il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
						     ADD_PARAMETER,
						     ADD_PARAMETER_SIG)));

		_type.translateUnBox(classGen, methodGen);

		
		if (className != EMPTYSTRING) {
		    il.append(new CHECKCAST(cpg.addClass(className)));
		}
		il.append(new PUTFIELD(cpg.addFieldref(classGen.getClassName(),
						       name, signature)));
	    }
	}
    }

}
"
org.apache.xml.utils.NodeConsumer,1,1,0,3,1,0,3,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xml.utils;

import org.w3c.dom.Node;


public interface NodeConsumer
{

  
  public void setOriginatingNode(Node n);
}
"
org.apache.xalan.xsltc.compiler.Otherwise,4,3,0,11,12,6,2,10,3,2.0,43,0.0,0,0.949152542,0.4,1,4,9.75,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;

final class Otherwise extends Instruction {
    public void display(int indent) {
	indent(indent);
	Util.println(""Otherwise"");
	indent(indent + IndentIncrement);
	displayContents(indent + IndentIncrement);
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	typeCheckContents(stable);
	return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Parser parser = getParser();
	final ErrorMsg err = new ErrorMsg(ErrorMsg.STRAY_OTHERWISE_ERR, this);
	parser.reportError(Constants.ERROR, err);
    }
}
"
org.apache.xpath.XPathVisitable,1,1,0,3,1,0,1,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xpath;


public interface XPathVisitable
{
	
	public void callVisitors(ExpressionOwner owner, XPathVisitor visitor);
}

"
org.apache.xalan.transformer.KeyIterator,4,8,0,9,15,2,2,7,3,0.333333333,97,1.0,1,0.978571429,0.4375,2,2,22.75,4,1.5,1,"
package org.apache.xalan.transformer;

import java.util.Vector;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.KeyDeclaration;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.QName;
import org.apache.xpath.XPath;
import org.apache.xpath.axes.OneStepIteratorForward;


public class KeyIterator extends OneStepIteratorForward
{

  
  private QName m_name;

  
  public QName getName()
  {
    return m_name;
  }

  
  private Vector m_keyDeclarations;

  
  public Vector getKeyDeclarations()
  {
    return m_keyDeclarations;
  }

  
  KeyIterator(QName name, Vector keyDeclarations)
  {
    super(Axis.ALL);
    m_keyDeclarations = keyDeclarations;
    
    m_name = name;
  }

  
  public short acceptNode(int testNode)
  {
    boolean foundKey = false;
    KeyIterator ki = (KeyIterator) m_lpi;
    org.apache.xpath.XPathContext xctxt = ki.getXPathContext();
    Vector keys = ki.getKeyDeclarations();

    QName name = ki.getName();
    try
    {
      
      int nDeclarations = keys.size();

      
      for (int i = 0; i < nDeclarations; i++)
      {
        KeyDeclaration kd = (KeyDeclaration) keys.elementAt(i);

        
        
        if (!kd.getName().equals(name))
          continue;

        foundKey = true;
        

        
        
        XPath matchExpr = kd.getMatch();
        double score = matchExpr.getMatchScore(xctxt, testNode);

        if (score == kd.getMatch().MATCH_SCORE_NONE)
          continue;

        return DTMIterator.FILTER_ACCEPT;

      } 
    }
    catch (TransformerException se)
    {

      
    }

    if (!foundKey)
      throw new RuntimeException(
        XSLMessages.createMessage(
          XSLTErrorResources.ER_NO_XSLKEY_DECLARATION,
          new Object[] { name.getLocalName()}));
          
    return DTMIterator.FILTER_REJECT;
  }

}
"
org.apache.xpath.operations.Neg,3,3,0,6,7,3,1,5,3,2.0,19,0.0,0,0.952380952,0.555555556,1,1,5.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class Neg extends UnaryOperation
{

  
  public XObject operate(XObject right) throws javax.xml.transform.TransformerException
  {
    return new XNumber(-right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return -(m_right.num(xctxt));
  }

}
"
org.apache.xml.dtm.ref.DTMNodeIterator,9,1,0,11,19,0,7,4,9,0.5,106,1.0,1,0.0,0.555555556,0,0,10.55555556,3,1.1111,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMDOMException;
import org.apache.xml.dtm.DTMIterator;

import org.w3c.dom.DOMException;
import org.w3c.dom.Node;
import org.w3c.dom.traversal.NodeFilter;


public class DTMNodeIterator implements org.w3c.dom.traversal.NodeIterator
{
  private DTMIterator dtm_iter;
  private boolean valid=true;

  
  

  
  public DTMNodeIterator(DTMIterator dtmIterator)
    {
      try
      {
        dtm_iter=(DTMIterator)dtmIterator.clone();
      }
      catch(CloneNotSupportedException cnse)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(cnse);
      }
    }

  
  public DTMIterator getDTMIterator()
    {
      return dtm_iter;
    }
  

  
  

  
  public void detach() 
    {
      
      
      
      valid=false;
    }

  
  public boolean getExpandEntityReferences()
    {
      return false;
    }
  
  
  public NodeFilter getFilter() 
    {
      throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
    }
  

  
  public Node getRoot()
    {
      int handle=dtm_iter.getRoot();
      return dtm_iter.getDTM(handle).getNode(handle);
    }
  

  
  public int getWhatToShow()
    {
      return dtm_iter.getWhatToShow();
    }

  
  public Node nextNode() throws DOMException
    {
      if(!valid)
        throw new DTMDOMException(DOMException.INVALID_STATE_ERR);
      
      int handle=dtm_iter.nextNode();
      if (handle==DTM.NULL)
        return null;
      return dtm_iter.getDTM(handle).getNode(handle);
    }
  

  
  public Node previousNode() 
    {
      if(!valid)
        throw new DTMDOMException(DOMException.INVALID_STATE_ERR);
      
      int handle=dtm_iter.previousNode();
      if (handle==DTM.NULL)
        return null;      
      return dtm_iter.getDTM(handle).getNode(handle);
    }
}
"
org.apache.xpath.functions.FuncFloor,2,4,0,5,7,1,0,5,2,2.0,15,0.0,0,0.979591837,0.75,1,6,6.5,1,0.5,1,"
package org.apache.xpath.functions;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class FuncFloor extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(java.lang.Math.floor(m_arg0.execute(xctxt).num()));
  }
}
"
org.apache.xalan.lib.ExsltCommon,3,1,0,6,6,3,0,6,3,2.0,41,0.0,0,0.0,0.444444444,0,0,12.66666667,6,2.3333,2,"
package org.apache.xalan.lib;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xpath.NodeSet;


public class ExsltCommon
{
  
  public static String objectType (Object obj)
  {
    if (obj instanceof String)
      return ""string"";
    else if (obj instanceof Boolean)
      return ""boolean"";
    else if (obj instanceof Number)
      return ""number"";
    else if (obj instanceof DTMNodeIterator)
    {
      DTMIterator dtmI = ((DTMNodeIterator)obj).getDTMIterator();
      if (dtmI instanceof org.apache.xpath.axes.RTFIterator)
      	return ""RTF"";
      else
        return ""node-set"";
    }
    else
      return ""unknown"";
  }
    
  
  public static NodeSet nodeSet(ExpressionContext myProcessor, Object rtf)
  {
    return Extensions.nodeset(myProcessor, rtf);
  }
 
}"
org.apache.xalan.xsltc.compiler.ParentLocationPath,11,4,0,20,42,0,2,19,11,0.64,380,1.0,3,0.879518072,0.204545455,2,7,33.09090909,35,4.8182,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xml.dtm.DTM;

final class ParentLocationPath extends RelativeLocationPath {
    private Expression _step;
    private final RelativeLocationPath _path;
    private Type stype;
    private boolean _orderNodes = false;
    private boolean _axisMismatch = false;

    public ParentLocationPath(RelativeLocationPath path, Expression step) {
	_path = path;
	_step = step;
	_path.setParent(this);
	_step.setParent(this);

	if (_step instanceof Step) {
	    _axisMismatch = checkAxisMismatch();
	}
    }
		
    public void setAxis(int axis) {
	_path.setAxis(axis);
    }

    public int getAxis() {
	return _path.getAxis();
    }

    public RelativeLocationPath getPath() {
	return(_path);
    }

    public Expression getStep() {
	return(_step);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_step.setParser(parser);
	_path.setParser(parser);
    }
    
    public String toString() {
	return ""ParentLocationPath("" + _path + "", "" + _step + ')';
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	stype = _step.typeCheck(stable);
	_path.typeCheck(stable);

	if (_axisMismatch) enableNodeOrdering();

	return _type = Type.NodeSet;	
    }

    public void enableNodeOrdering() {
	SyntaxTreeNode parent = getParent();
	if (parent instanceof ParentLocationPath)
	    ((ParentLocationPath)parent).enableNodeOrdering();
	else {
	    _orderNodes = true;
	}
    }

    
    public boolean checkAxisMismatch() {

	int left = _path.getAxis();
	int right = ((Step)_step).getAxis();

	if (((left == Axis.ANCESTOR) || (left == Axis.ANCESTORORSELF)) &&
	    ((right == Axis.CHILD) ||
	     (right == Axis.DESCENDANT) ||
	     (right == Axis.DESCENDANTORSELF) ||
	     (right == Axis.PARENT) ||
	     (right == Axis.PRECEDING) ||
	     (right == Axis.PRECEDINGSIBLING)))
	    return true;

	if ((left == Axis.CHILD) &&
	    (right == Axis.ANCESTOR) ||
	    (right == Axis.ANCESTORORSELF) ||
	    (right == Axis.PARENT) ||
	    (right == Axis.PRECEDING))
	    return true;

	if ((left == Axis.DESCENDANT) || (left == Axis.DESCENDANTORSELF))
	    return true;

	if (((left == Axis.FOLLOWING) || (left == Axis.FOLLOWINGSIBLING)) &&
	    ((right == Axis.FOLLOWING) ||
	     (right == Axis.PARENT) ||
	     (right == Axis.PRECEDING) ||
	     (right == Axis.PRECEDINGSIBLING)))
	    return true;

	if (((left == Axis.PRECEDING) || (left == Axis.PRECEDINGSIBLING)) &&
	    ((right == Axis.DESCENDANT) ||
	     (right == Axis.DESCENDANTORSELF) ||
	     (right == Axis.FOLLOWING) ||
	     (right == Axis.FOLLOWINGSIBLING) ||
	     (right == Axis.PARENT) ||
	     (right == Axis.PRECEDING) ||
	     (right == Axis.PRECEDINGSIBLING)))
	    return true;

	if ((right == Axis.FOLLOWING) && (left == Axis.CHILD)) {
	    
	    
	    
	    
	    if (_path instanceof Step) {
		int type = ((Step)_path).getNodeType();
		if (type == DTM.ATTRIBUTE_NODE) return true;
	    }
	}

	return false;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int initSI = cpg.addMethodref(STEP_ITERATOR_CLASS,
					    ""<init>"",
					    ""(""
					    +NODE_ITERATOR_SIG
					    +NODE_ITERATOR_SIG
					    +"")V"");
	il.append(new NEW(cpg.addClass(STEP_ITERATOR_CLASS)));
	il.append(DUP);

	
	_path.translate(classGen, methodGen); 
	_step.translate(classGen, methodGen);

	
	il.append(new INVOKESPECIAL(initSI));

	
	Expression stp = _step;
	if (stp instanceof ParentLocationPath)
	    stp = ((ParentLocationPath)stp).getStep();

	if ((_path instanceof Step) && (stp instanceof Step)) {
	    final int path = ((Step)_path).getAxis();
	    final int step = ((Step)stp).getAxis();
	    if ((path == Axis.DESCENDANTORSELF && step == Axis.CHILD) ||
		(path == Axis.PRECEDING        && step == Axis.PARENT)) {
		final int incl = cpg.addMethodref(NODE_ITERATOR_BASE,
						  ""includeSelf"",
						  ""()"" + NODE_ITERATOR_SIG);
		il.append(new INVOKEVIRTUAL(incl));
	    }
	}

	
	if (_orderNodes) {
	    final int order = cpg.addInterfaceMethodref(DOM_INTF,
							ORDER_ITERATOR,
							ORDER_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(order, 3));
	}
    }
}
"
org.apache.xpath.VariableStack,22,1,0,25,42,0,18,9,21,0.682539683,476,0.333333333,2,0.0,0.365079365,0,0,20.36363636,3,1.0,2,"
package org.apache.xpath;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;


public class VariableStack implements Cloneable
{

  
  public VariableStack()
  {
    reset();
  }

  
  public synchronized Object clone() throws CloneNotSupportedException
  {

    VariableStack vs = (VariableStack) super.clone();

    
    vs._stackFrames = (XObject[]) _stackFrames.clone();
    vs._links = (int[]) _links.clone();

    return vs;
  }

  
  XObject[] _stackFrames = new XObject[XPathContext.RECURSIONLIMIT * 2];

  
  int _frameTop;

  
  private int _currentFrameBottom;

  
  int[] _links = new int[XPathContext.RECURSIONLIMIT];

  
  int _linksTop;

  
  public XObject elementAt(final int i)
  {
    return _stackFrames[i];
  }

  
  public int size()
  {
    return _frameTop;
  }

  
  public void reset()
  {

    _frameTop = 0;
    _linksTop = 0;

    
    
    
    _links[_linksTop++] = 0;
    _stackFrames = new XObject[_stackFrames.length]; 
  }

  
  public void setStackFrame(int sf)
  {
    _currentFrameBottom = sf;
  }

  
  public int getStackFrame()
  {
    return _currentFrameBottom;
  }

  
  public int link(final int size)
  {

    _currentFrameBottom = _frameTop;
    _frameTop += size;

    if (_frameTop >= _stackFrames.length)
    {
      XObject newsf[] = new XObject[_stackFrames.length + (1024 * 4) + size];

      System.arraycopy(_stackFrames, 0, newsf, 0, _stackFrames.length);

      _stackFrames = newsf;
    }

    if (_linksTop + 1 >= _links.length)
    {
      int newlinks[] = new int[_links.length + (1024 * 2)];

      System.arraycopy(_links, 0, newlinks, 0, _links.length);

      _links = newlinks;
    }

    _links[_linksTop++] = _currentFrameBottom;

    return _currentFrameBottom;
  }

  
  public  void unlink()
  {
    _frameTop = _links[--_linksTop];
    _currentFrameBottom = _links[_linksTop - 1];
  }
  
  
  public  void unlink(int currentFrame)
  {
    _frameTop = _links[--_linksTop];
    _currentFrameBottom = currentFrame; 
  }

  
  public void setLocalVariable(int index, XObject val)
  {
    _stackFrames[index + _currentFrameBottom] = val;
  }

  
  public void setLocalVariable(int index, XObject val, int stackFrame)
  {
    _stackFrames[index + stackFrame] = val;
  }

  
  public XObject getLocalVariable(XPathContext xctxt, int index)
          throws TransformerException
  {

    index += _currentFrameBottom;

    XObject val = _stackFrames[index];
    
    if(null == val)
      throw new TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VARIABLE_ACCESSED_BEFORE_BIND, null),
                     xctxt.getSAXLocator());
      

    
    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)
      return (_stackFrames[index] = val.execute(xctxt));

    return val;
  }

  
  public XObject getLocalVariable(int index, int frame)
          throws TransformerException
  {

    index += frame;

    XObject val = _stackFrames[index];

    return val;
  }
  
  
  public XObject getLocalVariable(XPathContext xctxt, int index, boolean destructiveOK)
          throws TransformerException
  {

    index += _currentFrameBottom;

    XObject val = _stackFrames[index];
    
    if(null == val)
      throw new TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VARIABLE_ACCESSED_BEFORE_BIND, null),
                     xctxt.getSAXLocator());
      

    
    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)
      return (_stackFrames[index] = val.execute(xctxt));

    return destructiveOK ? val : val.getFresh();
  }

  
  public boolean isLocalSet(int index) throws TransformerException
  {
    return (_stackFrames[index + _currentFrameBottom] != null);
  }

  
  private static XObject[] m_nulls = new XObject[1024];

  
  public void clearLocalSlots(int start, int len)
  {

    start += _currentFrameBottom;

    System.arraycopy(m_nulls, 0, _stackFrames, start, len);
  }

  
  public void setGlobalVariable(final int index, final XObject val)
  {
    _stackFrames[index] = val;
  }

  
  public XObject getGlobalVariable(XPathContext xctxt, final int index)
          throws TransformerException
  {

    XObject val = _stackFrames[index];

    
    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)
      return (_stackFrames[index] = val.execute(xctxt));

    return val;
  }
  
  
  public XObject getGlobalVariable(XPathContext xctxt, final int index, boolean destructiveOK)
          throws TransformerException
  {

    XObject val = _stackFrames[index];

    
    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)
      return (_stackFrames[index] = val.execute(xctxt));

    return destructiveOK ? val : val.getFresh();
  }

  
  public XObject getVariableOrParam(
          XPathContext xctxt, org.apache.xml.utils.QName qname)
            throws javax.xml.transform.TransformerException
  {

    org.apache.xml.utils.PrefixResolver prefixResolver =
      xctxt.getNamespaceContext();

    
    
    
    
    

    if (prefixResolver instanceof org.apache.xalan.templates.ElemTemplateElement)
    {
      
      org.apache.xalan.templates.ElemVariable vvar;

      org.apache.xalan.templates.ElemTemplateElement prev =
        (org.apache.xalan.templates.ElemTemplateElement) prefixResolver;

      if (!(prev instanceof org.apache.xalan.templates.Stylesheet))
      {
        while ( !(prev.getParentNode() instanceof org.apache.xalan.templates.Stylesheet) )
        {
          org.apache.xalan.templates.ElemTemplateElement savedprev = prev;

          while (null != (prev = prev.getPreviousSiblingElem()))
          {
            if (prev instanceof org.apache.xalan.templates.ElemVariable)
            {
              vvar = (org.apache.xalan.templates.ElemVariable) prev;

              if (vvar.getName().equals(qname))
                return getLocalVariable(xctxt, vvar.getIndex());
            }
          }
          prev = savedprev.getParentElem();
        }
      }

      vvar = prev.getStylesheetRoot().getVariableOrParamComposed(qname);
      if (null != vvar)
        return getGlobalVariable(xctxt, vvar.getIndex());
    }

    throw new javax.xml.transform.TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VAR_NOT_RESOLVABLE, new Object[]{qname.toString()})); 
  }
}  

"
org.apache.xpath.axes.OneStepIterator,14,7,0,12,41,7,3,10,10,0.346153846,330,1.0,1,0.917241379,0.273809524,4,18,22.42857143,9,2.2857,1,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.Compiler;


public class OneStepIterator extends ChildTestIterator
{
  
  protected int m_axis = -1;

  
  protected DTMAxisIterator m_iterator;

  
  OneStepIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis);
    int firstStepPos = compiler.getFirstChildPos(opPos);
    
    m_axis = WalkerFactory.getAxisFromStep(compiler, firstStepPos);
    
  }
  
  
  
  public OneStepIterator(DTMAxisIterator iterator, int axis)
          throws javax.xml.transform.TransformerException
  {
    super(null);
    
    m_iterator = iterator;
    m_axis = axis;
    int whatToShow = DTMFilter.SHOW_ALL;
    initNodeTest(whatToShow);
  }
  
  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    if(m_axis > -1)
      m_iterator = m_cdtm.getAxisIterator(m_axis);
    m_iterator.setStartNode(m_context);
  }

  
  public void detach()
  {    
    if(m_allowDetach)
    {
      if(m_axis > -1)
        m_iterator = null;
      
      
      super.detach();
    }
  }
  
  
  protected int getNextNode()
  {
    return m_lastFetched = m_iterator.next();
  }
  
  
  public Object clone() throws CloneNotSupportedException
  {
    
    
    OneStepIterator clone = (OneStepIterator) super.clone();

    if(m_iterator != null)
    {
      clone.m_iterator = m_iterator.cloneIterator();
    }
    return clone;
  }
  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    OneStepIterator clone = (OneStepIterator) super.cloneWithReset();
    clone.m_iterator = m_iterator;

    return clone;
  }



  
  public boolean isReverseAxes()
  {
    return m_iterator.isReverse();
  }

  
  protected int getProximityPosition(int predicateIndex)
  {
    if(!isReverseAxes())
      return super.getProximityPosition(predicateIndex);
      
    
    
    
    if(predicateIndex < 0)
      return -1;
      
    if (m_proximityPositions[predicateIndex] <= 0)
    {
      XPathContext xctxt = getXPathContext();
      try
      {
        OneStepIterator clone = (OneStepIterator) this.clone();
        
        int root = getRoot();
        xctxt.pushCurrentNode(root);
        clone.setRoot(root, xctxt);

        
        clone.m_predCount = predicateIndex;

        
        int count = 1;
        int next;

        while (DTM.NULL != (next = clone.nextNode()))
        {
          count++;
        }

        m_proximityPositions[predicateIndex] += count;
      }
      catch (CloneNotSupportedException cnse)
      {

        
      }
      finally
      {
        xctxt.popCurrentNode();
      }
    }

    return m_proximityPositions[predicateIndex];
  }

  
  public int getLength()
  {
    if(!isReverseAxes())
      return super.getLength();
      
    
    boolean isPredicateTest = (this == m_execContext.getSubContextList());

    
    int predCount = getPredicateCount();
   
    
    
    
    if (-1 != m_length && isPredicateTest && m_predicateIndex < 1)
       return m_length;      

    int count = 0;
    
    XPathContext xctxt = getXPathContext();
    try
    {
      OneStepIterator clone = (OneStepIterator) this.cloneWithReset();
      
      int root = getRoot();
      xctxt.pushCurrentNode(root);
      clone.setRoot(root, xctxt);
 
      clone.m_predCount = m_predicateIndex;

      int next;

      while (DTM.NULL != (next = clone.nextNode()))
      {
        count++;
      }
    }
    catch (CloneNotSupportedException cnse)
    {
       
    }
    finally
    {
      xctxt.popCurrentNode();
    }
    if (isPredicateTest && m_predicateIndex < 1)
      m_length = count;    
      
    return count;
  }

  
  protected void countProximityPosition(int i)
  {
    if(!isReverseAxes())
      super.countProximityPosition(i);
    else if (i < m_proximityPositions.length)
      m_proximityPositions[i]--;
  }
  
  
  public void reset()
  {

    super.reset();
    if(null != m_iterator)
      m_iterator.reset();
  }
  
  
  public int getAxis()
  {
    return m_axis;
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(m_axis != ((OneStepIterator)expr).m_axis)
  		return false;
  		
  	return true;
  }

  
}
"
org.apache.xml.serializer.Encodings,11,1,0,7,51,31,5,2,8,0.927272727,489,0.454545455,1,0.0,0.3,0,0,42.45454545,15,3.4545,0,"
package org.apache.xml.serializer;

import java.io.InputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.Writer;
import java.net.URL;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.StringTokenizer;


public class Encodings extends Object
{

    
    static final int m_defaultLastPrintable = 0x7F;

    
    static final String ENCODINGS_FILE =
        ""org/apache/xml/serializer/Encodings.properties"";

    
    static final String ENCODINGS_PROP = ""org.apache.xalan.serialize.encodings"";

    
    private static final Class[] NO_CLASSES = new Class[0];

    
    private static final Object[] NO_OBJS = new Object[0];

    
    public static Writer getWriter(OutputStream output, String encoding)
        throws UnsupportedEncodingException
    {

        for (int i = 0; i < _encodings.length; ++i)
        {
            if (_encodings[i].name.equalsIgnoreCase(encoding))
            {
                try
                {
                    return new OutputStreamWriter(
                        output,
                        _encodings[i].javaName);
                }
                catch (java.lang.IllegalArgumentException iae) 
                {
                    
                }
                catch (UnsupportedEncodingException usee)
                {

                    
                }
            }
        }

        try
        {
            return new OutputStreamWriter(output, encoding);
        }
        catch (java.lang.IllegalArgumentException iae) 
        {
            throw new UnsupportedEncodingException(encoding);
        }
    }

    
    public static Object getCharToByteConverter(String encoding)
    {

        Class charToByteConverterClass = null;
        java.lang.reflect.Method getConverterMethod = null;

        try
        {
            charToByteConverterClass =
                Class.forName(""sun.io.CharToByteConverter"");
            Class argTypes[] = new Class[1];
            argTypes[0] = String.class;
            getConverterMethod =
                charToByteConverterClass.getMethod(""getConverter"", argTypes);
        }
        catch (Exception e)
        {
            System.err.println(
                ""Warning: Could not get charToByteConverterClass!"");
            return null;
        }
        Object args[] = new Object[1];
        for (int i = 0; i < _encodings.length; ++i)
        {
            if (_encodings[i].name.equalsIgnoreCase(encoding))
            {
                try
                {
                    args[0] = _encodings[i].javaName;
                    Object converter = getConverterMethod.invoke(null, args);
                    if (null != converter)
                        return converter;
                }
                catch (Exception iae)
                {
                    
                }
            }
        }

        return null;
    }

    
    public static int getLastPrintable(String encoding)
    {
        EncodingInfo ei;

        String normalizedEncoding = encoding.toUpperCase();
        ei = (EncodingInfo) _encodingTableKeyJava.get(normalizedEncoding);
        if (ei == null)
            ei = (EncodingInfo) _encodingTableKeyMime.get(normalizedEncoding);
        if (ei != null)
            return ei.lastPrintable;
        return m_defaultLastPrintable;
    }

    
    public static int getLastPrintable()
    {
        return m_defaultLastPrintable;
    }

    
    public static final String DEFAULT_MIME_ENCODING = ""UTF-8"";

    
    public static String getMimeEncoding(String encoding)
    {

        if (null == encoding)
        {
            try
            {

                
                
                
                encoding = System.getProperty(""file.encoding"", ""UTF8"");

                if (null != encoding)
                {

                    
                    String jencoding =
                        (encoding.equalsIgnoreCase(""Cp1252"")
                            || encoding.equalsIgnoreCase(""ISO8859_1"")
                            || encoding.equalsIgnoreCase(""8859_1"")
                            || encoding.equalsIgnoreCase(""UTF8""))
                            ? DEFAULT_MIME_ENCODING
                            : convertJava2MimeEncoding(encoding);

                    encoding =
                        (null != jencoding) ? jencoding : DEFAULT_MIME_ENCODING;
                }
                else
                {
                    encoding = DEFAULT_MIME_ENCODING;
                }
            }
            catch (SecurityException se)
            {
                encoding = DEFAULT_MIME_ENCODING;
            }
        }
        else
        {
            encoding = convertJava2MimeEncoding(encoding);
        }

        return encoding;
    }

    
    public static String convertJava2MimeEncoding(String encoding)
    {
        EncodingInfo enc =
            (EncodingInfo) _encodingTableKeyJava.get(encoding.toUpperCase());
        if (null != enc)
            return enc.name;
        return encoding;
    }

    
    public static String convertMime2JavaEncoding(String encoding)
    {

        for (int i = 0; i < _encodings.length; ++i)
        {
            if (_encodings[i].name.equalsIgnoreCase(encoding))
            {
                return _encodings[i].javaName;
            }
        }

        return encoding;
    }

    
    private static EncodingInfo[] loadEncodingInfo()
    {
        URL url = null;
        try
        {
            String urlString = null;
            try
            {
                urlString = System.getProperty(ENCODINGS_PROP, """");
            }
            catch (SecurityException e)
            {
            }

            if (urlString != null && urlString.length() > 0)
                url = new URL(urlString);
            if (url == null)
            {
                ClassLoader cl = null;
                try
                {
                    java.lang.reflect.Method getCCL =
                        Thread.class.getMethod(
                            ""getContextClassLoader"",
                            NO_CLASSES);
                    if (getCCL != null)
                    {
                        cl =
                            (ClassLoader) getCCL.invoke(
                                Thread.currentThread(),
                                NO_OBJS);
                    }
                }
                catch (Exception e)
                {
                }
                if (cl != null)
                {
                    url = cl.getResource(ENCODINGS_FILE);
                }
            }
            if (url == null)
                url = ClassLoader.getSystemResource(ENCODINGS_FILE);

            Properties props = new Properties();
            if (url != null)
            {
                InputStream is = url.openStream();
                props.load(is);
                is.close();
            }
            else
            {
                
                
                
                
                
                
            }

            int totalEntries = props.size();
            int totalMimeNames = 0;
            Enumeration keys = props.keys();
            for (int i = 0; i < totalEntries; ++i)
            {
                String javaName = (String) keys.nextElement();
                String val = props.getProperty(javaName);
                totalMimeNames++;
                int pos = val.indexOf(' ');
                for (int j = 0; j < pos; ++j)
                    if (val.charAt(j) == ',')
                        totalMimeNames++;
            }
            EncodingInfo[] ret = new EncodingInfo[totalMimeNames];
            int j = 0;
            keys = props.keys();
            for (int i = 0; i < totalEntries; ++i)
            {
                String javaName = (String) keys.nextElement();
                String val = props.getProperty(javaName);
                int pos = val.indexOf(' ');
                String mimeName;
                int lastPrintable;
                if (pos < 0)
                {
                    
                    
                    
                    mimeName = val;
                    lastPrintable = 0x00FF;
                }
                else
                {
                    lastPrintable =
                        Integer.decode(val.substring(pos).trim()).intValue();
                    StringTokenizer st =
                        new StringTokenizer(val.substring(0, pos), "","");
                    for (boolean first = true;
                        st.hasMoreTokens();
                        first = false)
                    {
                        mimeName = st.nextToken();
                        ret[j] =
                            new EncodingInfo(mimeName, javaName, lastPrintable);
                        _encodingTableKeyMime.put(
                            mimeName.toUpperCase(),
                            ret[j]);
                        if (first)
                            _encodingTableKeyJava.put(
                                javaName.toUpperCase(),
                                ret[j]);
                        j++;
                    }
                }
            }
            return ret;
        }
        catch (java.net.MalformedURLException mue)
        {
            throw new org.apache.xml.utils.WrappedRuntimeException(mue);
        }
        catch (java.io.IOException ioe)
        {
            throw new org.apache.xml.utils.WrappedRuntimeException(ioe);
        }
    }

    private static final Hashtable _encodingTableKeyJava = new Hashtable();
    private static final Hashtable _encodingTableKeyMime = new Hashtable();
    private static final EncodingInfo[] _encodings = loadEncodingInfo();
}
"
org.apache.xalan.xsltc.trax.TransformerHandlerImpl,29,1,0,14,73,116,2,12,29,0.857142857,462,1.0,3,0.0,0.237068966,0,0,14.51724138,2,1.0,0,"

package org.apache.xalan.xsltc.trax;

import javax.xml.transform.Result;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.sax.TransformerHandler;

import org.apache.xalan.xsltc.StripFilter;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.dom.DOMWSFilter;
import org.apache.xalan.xsltc.dom.SAXImpl;
import org.apache.xalan.xsltc.dom.XSLTCDTMManager;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.serializer.SerializationHandler;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.Locator;
import org.xml.sax.SAXException;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.DefaultHandler;


public class TransformerHandlerImpl implements TransformerHandler, DeclHandler {

    private TransformerImpl  _transformer;
    private AbstractTranslet _translet = null;
    private String           _systemId;
    private SAXImpl          _dom = null;
    private ContentHandler   _handler = null;
    private LexicalHandler   _lexHandler = null;
    private DTDHandler       _dtdHandler = null;
    private DeclHandler      _declHandler = null;
    private Result           _result = null;
    private Locator          _locator = null;

    private boolean          _done = false; 

    
    private boolean _isIdentity = false;

    
    public TransformerHandlerImpl(TransformerImpl transformer) {
	
	_transformer = transformer;

	if (transformer.isIdentity()) {
	    
	    _handler = new DefaultHandler();
	    _isIdentity = true;
	}
	else {
	    
	    _translet = _transformer.getTranslet();
	}
    }

    
    public String getSystemId() {
	return _systemId;
    }

    
    public void setSystemId(String id) {
	_systemId = id;
    }

    
    public Transformer getTransformer() {
	return _transformer;
    }

    
    public void setResult(Result result) throws IllegalArgumentException {
	_result = result;

	if (_isIdentity) {
	    try {
		
		SerializationHandler outputHandler =
		    _transformer.getOutputHandler(result);
		_transformer.transferOutputProperties(outputHandler);

		_handler = outputHandler;
		_lexHandler = outputHandler;
	    }
	    catch (TransformerException e) {
		_result = null;
	    }
	}
	else if (_done) {
	    
	    try {
		_transformer.setDOM(_dom);
		_transformer.transform(null, _result);
	    }
	    catch (TransformerException e) {
		
		throw new IllegalArgumentException(e.getMessage());
	    }
	}
    }

    
    public void characters(char[] ch, int start, int length) 
	throws SAXException 
    {
	_handler.characters(ch, start, length);
    }

    
    public void startDocument() throws SAXException {
	
	if (_result == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_SET_RESULT_ERR);
	    throw new SAXException(err.toString());
	}

        if (!_isIdentity) {
            boolean hasIdCall = (_translet != null) ? _translet.hasIdCall() : false;
            
            
            XSLTCDTMManager dtmManager = XSLTCDTMManager.newInstance();

            DTMWSFilter wsFilter;
            if (_translet != null && _translet instanceof StripFilter) {
                wsFilter = new DOMWSFilter(_translet);
            } else {
                wsFilter = null;
            }            
          
            
            _dom = (SAXImpl)dtmManager.getDTM(null, false, wsFilter, true, false, hasIdCall);         
            
            _handler = _dom.getBuilder();
            _lexHandler = (LexicalHandler) _handler;
            _dtdHandler = (DTDHandler) _handler;
            _declHandler = (DeclHandler) _handler;  
            
            
	        
	        _dom.setDocumentURI(_systemId);
            
             if (_locator != null) {
                _handler.setDocumentLocator(_locator);
             }            
        }

	
	_handler.startDocument();
    }

    
    public void endDocument() throws SAXException {
	
	_handler.endDocument();

	if (!_isIdentity) {
	    
	    if (_result != null) {
		try {
		    _transformer.setDOM(_dom);
		    _transformer.transform(null, _result);
		}
		catch (TransformerException e) {
		    throw new SAXException(e);
		}
	    }
	    
	    _done = true;

	    
	    _transformer.setDOM(_dom);
	}
    }
	
    
    public void startElement(String uri, String localName,
			     String qname, Attributes attributes)
	throws SAXException 
    {
	_handler.startElement(uri, localName, qname, attributes);
    }
	
    
    public void endElement(String namespaceURI, String localName, String qname)
	throws SAXException 
    {
	_handler.endElement(namespaceURI, localName, qname);
    }

    
    public void processingInstruction(String target, String data)
	throws SAXException 
    {
	_handler.processingInstruction(target, data);
    }

    
    public void startCDATA() throws SAXException { 
	if (_lexHandler != null) {
	    _lexHandler.startCDATA();
	}
    }

    
    public void endCDATA() throws SAXException { 
	if (_lexHandler != null) {
	    _lexHandler.endCDATA();
	}
    }

    
    public void comment(char[] ch, int start, int length) 
	throws SAXException 
    { 
	if (_lexHandler != null) {
	    _lexHandler.comment(ch, start, length);
	}
    }

    
    public void ignorableWhitespace(char[] ch, int start, int length)
	throws SAXException 
    {
	_handler.ignorableWhitespace(ch, start, length);
    }

    
    public void setDocumentLocator(Locator locator) {
        _locator = locator;

        if (_handler != null) {
            _handler.setDocumentLocator(locator);
        }
    }

    
    public void skippedEntity(String name) throws SAXException {
	_handler.skippedEntity(name);
    }

    
    public void startPrefixMapping(String prefix, String uri) 
	throws SAXException {
	_handler.startPrefixMapping(prefix, uri);
    }

    
    public void endPrefixMapping(String prefix) throws SAXException {
	_handler.endPrefixMapping(prefix);
    }

    
    public void startDTD(String name, String publicId, String systemId) 
	throws SAXException
    { 
	if (_lexHandler != null) {
	    _lexHandler.startDTD(name, publicId, systemId);
	}
    }

    
    public void endDTD() throws SAXException {
	if (_lexHandler != null) {
	    _lexHandler.endDTD();
	}
    }

    
    public void startEntity(String name) throws SAXException { 
	if (_lexHandler != null) {
	    _lexHandler.startEntity(name);
	}
    }

    
    public void endEntity(String name) throws SAXException { 
	if (_lexHandler != null) {
	    _lexHandler.endEntity(name);
	}
    }

    
    public void unparsedEntityDecl(String name, String publicId, 
	String systemId, String notationName) throws SAXException 
    {
        if (_dtdHandler != null) {
	    _dtdHandler.unparsedEntityDecl(name, publicId, systemId,
                                           notationName);
        }
    }

    
    public void notationDecl(String name, String publicId, String systemId) 
	throws SAXException
    {
        if (_dtdHandler != null) {
	    _dtdHandler.notationDecl(name, publicId, systemId);
        }
    }

    
    public void attributeDecl(String eName, String aName, String type, 
	String valueDefault, String value) throws SAXException 
    {
        if (_declHandler != null) {
	    _declHandler.attributeDecl(eName, aName, type, valueDefault, value);
        }
    }

    
    public void elementDecl(String name, String model) 
	throws SAXException
    {
        if (_declHandler != null) {
	    _declHandler.elementDecl(name, model);
        }
    }

    
    public void externalEntityDecl(String name, String publicId, String systemId) 
	throws SAXException
    {
        if (_declHandler != null) {
	    _declHandler.externalEntityDecl(name, publicId, systemId);
        }
    }

    
    public void internalEntityDecl(String name, String value) 
	throws SAXException
    {
        if (_declHandler != null) {
	    _declHandler.internalEntityDecl(name, value);
        }
    }
}
"
org.apache.xml.serializer.Method,1,1,0,0,2,0,0,0,1,2.0,9,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xml.serializer;


public final class Method
{

  
  public static final String XML = ""xml"";

  
  public static final String HTML = ""html"";

  
  public static final String XHTML = ""xhtml"";

  
  public static final String TEXT = ""text"";
  
    
  public static final String UNKNOWN = """";
}
"
org.apache.xalan.templates.ElemVariable,22,3,3,35,70,151,18,23,19,0.828571429,390,0.8,2,0.907407407,0.168181818,2,15,16.5,4,1.0909,2,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xpath.objects.XRTreeFragSelectWrapper;
import org.apache.xpath.objects.XString;


public class ElemVariable extends ElemTemplateElement
{

  
  public ElemVariable(){}

  
  protected int m_index;
  
  
  int m_frameSize = -1;

  
  
  public void setIndex(int index)
  {
    m_index = index;
  }

  
  public int getIndex()
  {
    return m_index;
  }

  
  private XPath m_selectPattern;

  
  public void setSelect(XPath v)
  {
    m_selectPattern = v;
  }

  
  public XPath getSelect()
  {
    return m_selectPattern;
  }

  
  protected QName m_qname;

  
  public void setName(QName v)
  {
    m_qname = v;
  }

  
  public QName getName()
  {
    return m_qname;
  }

  
  private boolean m_isTopLevel = false;

  
  public void setIsTopLevel(boolean v)
  {
    m_isTopLevel = v;
  }

  
  public boolean getIsTopLevel()
  {
    return m_isTopLevel;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_VARIABLE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_VARIABLE_STRING;
  }

  
  public ElemVariable(ElemVariable param) throws TransformerException
  {

    m_selectPattern = param.m_selectPattern;
    m_qname = param.m_qname;
    m_isTopLevel = param.m_isTopLevel;

    
    
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    int sourceNode = transformer.getXPathContext().getCurrentNode();
  
    XObject var = getValue(transformer, sourceNode);

    
    transformer.getXPathContext().getVarStack().setLocalVariable(m_index, var);
    
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this);         
  }

  
  public XObject getValue(TransformerImpl transformer, int sourceNode)
          throws TransformerException
  {

    XObject var;
    XPathContext xctxt = transformer.getXPathContext();

    xctxt.pushCurrentNode(sourceNode);
 
    try
    {
      if (null != m_selectPattern)
      {
        var = m_selectPattern.execute(xctxt, sourceNode, this);

        var.allowDetachToRelease(false);

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                  ""select"", m_selectPattern, var);
      }
      else if (null == getFirstChildElem())
      {
        var = XString.EMPTYSTRING;
      }
      else
      {

        
        
        
        
        int df;

		
		
		
		
		
		try
		{
			
			if(m_parentNode instanceof Stylesheet) 
				df = transformer.transformToGlobalRTF(this);
			else
				df = transformer.transformToRTF(this);
    	}
		finally{ 
			
			}

        var = new XRTreeFrag(df, xctxt, this);
      }
    }
    finally
    {      
      xctxt.popCurrentNode();
    }

    return var;
  }
  
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    
    if(null == m_selectPattern  
       && org.apache.xalan.processor.TransformerFactoryImpl.m_optimize)
    {
      XPath newSelect = rewriteChildToExpression(this);
      if(null != newSelect)
        m_selectPattern = newSelect;
    }
    
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    
    
    
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_selectPattern)
      m_selectPattern.fixupVariables(vnames, cstate.getGlobalsSize());
      
    
    
    if(!(m_parentNode instanceof Stylesheet) && m_qname != null)
    {
      m_index = cstate.addVariableName(m_qname) - cstate.getGlobalsSize();
    }
    else if (m_parentNode instanceof Stylesheet)
    {
    	
    	
    	
		cstate.resetStackFrameSize();
    }
    
    
    
    super.compose(sroot);
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    super.endCompose(sroot);
    if(m_parentNode instanceof Stylesheet)
    {
    	StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    	m_frameSize = cstate.getFrameSize();
    	cstate.resetStackFrameSize();
    }
  }

  
  









  
  static XPath rewriteChildToExpression(ElemTemplateElement varElem)
          throws TransformerException
  {

    ElemTemplateElement t = varElem.getFirstChildElem();

    
    
    if (null != t && null == t.getNextSiblingElem())
    {
      int etype = t.getXSLToken();

      if (Constants.ELEMNAME_VALUEOF == etype)
      {
        ElemValueOf valueof = (ElemValueOf) t;

        
        if (valueof.getDisableOutputEscaping() == false
                && valueof.getDOMBackPointer() == null)
        {
          varElem.m_firstChild = null;

          return new XPath(new XRTreeFragSelectWrapper(valueof.getSelect().getExpression()));
        }
      }
      else if (Constants.ELEMNAME_TEXTLITERALRESULT == etype)
      {
        ElemTextLiteral lit = (ElemTextLiteral) t;

        if (lit.getDisableOutputEscaping() == false
                && lit.getDOMBackPointer() == null)
        {
          String str = lit.getNodeValue();
          XString xstr = new XString(str);

          varElem.m_firstChild = null;

          return new XPath(new XRTreeFragSelectWrapper(xstr));
        }
      }
    }

    return null;
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeVariables(this);
  }
  
  
  public void setParentElem(ElemTemplateElement p)
  {
    super.setParentElem(p);
    p.m_hasVariableDecl = true;
  }
  
  
  protected boolean accept(XSLTVisitor visitor)
  {
  	return visitor.visitVariableOrParamDecl(this);
  }

  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(null != m_selectPattern)
  		m_selectPattern.getExpression().callVisitors(m_selectPattern, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }
  
  
  public boolean isPsuedoVar()
  {
  	java.lang.String ns = m_qname.getNamespaceURI();
  	if((null != ns) && ns.equals(RedundentExprEliminator.PSUEDOVARNAMESPACE))
  	{
  		if(m_qname.getLocalName().startsWith(""#""))
  			return true;
  	}
  	return false;
  }

}
"
org.apache.xml.serializer.ExtendedContentHandler,15,1,0,2,15,105,1,1,15,2.0,15,0.0,0,0.0,0.413333333,0,0,0.0,1,1.0,0,"
package org.apache.xml.serializer;

import javax.xml.transform.SourceLocator;

import org.xml.sax.SAXException;


public interface ExtendedContentHandler extends org.xml.sax.ContentHandler
{
    
    public void addAttribute(
        String uri,
        String localName,
        String rawName,
        String type,
        String value)
        throws SAXException;
    
    public void addAttributes(org.xml.sax.Attributes atts)
        throws org.xml.sax.SAXException;
    
    public void addAttribute(String qName, String value);
    
    public void characters(String chars) throws SAXException;
    
    public void endElement(String elemName) throws SAXException;

    
    public void startElement(String uri, String localName, String qName)
        throws org.xml.sax.SAXException;

    
    public void startElement(String qName) throws SAXException;
    
    public void namespaceAfterStartElement(String uri, String prefix)
        throws SAXException;

    
    public boolean startPrefixMapping(
        String prefix,
        String uri,
        boolean shouldFlush)
        throws SAXException;
    
    public void entityReference(String entityName) throws SAXException;

    
    public NamespaceMappings getNamespaceMappings();
    
    public String getPrefix(String uri);
    
    public String getNamespaceURI(String name, boolean isElement);
    
    public String getNamespaceURIFromPrefix(String prefix);

    
    public void setSourceLocator(SourceLocator locator);

}
"
org.apache.xalan.xsltc.runtime.ErrorMessages,3,3,0,0,4,1,0,0,2,0.5,234,1.0,0,0.974358974,1.0,0,0,76.66666667,1,0.3333,2,"

package org.apache.xalan.xsltc.runtime;

import java.util.ListResourceBundle;

public class ErrorMessages extends ListResourceBundle {



    
    private static final Object[][] m_errorMessages = {

        
        {BasisLibrary.RUN_TIME_INTERNAL_ERR,
        ""Run-time internal error in ''{0}''""},

        
        {BasisLibrary.RUN_TIME_COPY_ERR,
        ""Run-time error when executing <xsl:copy>.""},

        
        {BasisLibrary.DATA_CONVERSION_ERR,
        ""Invalid conversion from ''{0}'' to ''{1}''.""},

        
        {BasisLibrary.EXTERNAL_FUNC_ERR,
        ""External function ''{0}'' not supported by XSLTC.""},

        
        {BasisLibrary.EQUALITY_EXPR_ERR,
        ""Unknown argument type in equality expression.""},

        
        {BasisLibrary.INVALID_ARGUMENT_ERR,
        ""Invalid argument type ''{0}'' in call to ''{1}''""},

        
        {BasisLibrary.FORMAT_NUMBER_ERR,
        ""Attempting to format number ''{0}'' using pattern ''{1}''.""},

        
        {BasisLibrary.ITERATOR_CLONE_ERR,
        ""Cannot clone iterator ''{0}''.""},

        
        {BasisLibrary.AXIS_SUPPORT_ERR,
        ""Iterator for axis ''{0}'' not supported.""},

        
        {BasisLibrary.TYPED_AXIS_SUPPORT_ERR,
        ""Iterator for typed axis ''{0}'' not supported.""},

        
        {BasisLibrary.STRAY_ATTRIBUTE_ERR,
        ""Attribute ''{0}'' outside of element.""},

        
        {BasisLibrary.STRAY_NAMESPACE_ERR,
        ""Namespace declaration ''{0}''=''{1}'' outside of element.""},

        
        {BasisLibrary.NAMESPACE_PREFIX_ERR,
        ""Namespace for prefix ''{0}'' has not been declared.""},

        
        {BasisLibrary.DOM_ADAPTER_INIT_ERR,
        ""DOMAdapter created using wrong type of source DOM.""},

        
        {BasisLibrary.PARSER_DTD_SUPPORT_ERR,
        ""The SAX parser you are using does not handle DTD declaration events.""},

        
        {BasisLibrary.NAMESPACES_SUPPORT_ERR,
        ""The SAX parser you are using does not have support for XML Namespaces.""},

        
        {BasisLibrary.CANT_RESOLVE_RELATIVE_URI_ERR,
        ""Could not resolve the URI reference ''{0}''.""}
    };

    public Object[][] getContents() {
        return m_errorMessages;
    }

}
"
org.apache.xml.utils.res.XResources_ja_JP_HA,3,4,0,1,4,1,0,1,2,0.5,599,0.0,0,0.976190476,1.0,0,0,198.3333333,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_ja_JP_HA extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ja"" }, { ""help_language"", ""ja"" }, { ""language"", ""ja"" },
    { ""alphabet"",
      new char[]{ 0x3042, 0x3044, 0x3046, 0x3048, 0x304a, 0x304b, 0x304d,
                  0x304f, 0x3051, 0x3053, 0x3055, 0x3057, 0x3059, 0x305b,
                  0x305d, 0x305f, 0x3061, 0x3064, 0x3066, 0x3068, 0x306a,
                  0x306b, 0x306c, 0x306d, 0x306e, 0x306f, 0x3072, 0x3075,
                  0x3078, 0x307b, 0x307e, 0x307f, 0x3080, 0x3081, 0x3082,
                  0x3084, 0x3086, 0x3088, 0x3089, 0x308a, 0x308b, 0x308c,
                  0x308d, 0x308f, 0x3090, 0x3091, 0x3092, 0x3093 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    
    
    { ""multiplier"",
      new long[]{ Long.MAX_VALUE, Long.MAX_VALUE, 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4EAC, 0x5146, 0x5104, 0x4E07, 0x5343, 0x767e, 0x5341 } },

    
    { ""zero"", new char[0] },
    { ""digits"",
      new char[]{ 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03,
                  0x516B, 0x4E5D } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xalan.templates.ElemUnknown,2,5,0,2,3,1,0,2,2,2.0,6,0.0,0,0.995833333,0.75,1,1,2.0,1,0.5,2,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.transformer.TransformerImpl;


public class ElemUnknown extends ElemLiteralResult
{

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException{}
}
"
org.apache.xml.utils.res.XResources_ja_JP_HI,3,4,0,1,4,1,0,1,2,0.5,595,0.0,0,0.976190476,1.0,0,0,197.0,1,0.3333,1,"
package org.apache.xml.utils.res;






public class XResources_ja_JP_HI extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ja"" }, { ""help_language"", ""ja"" }, { ""language"", ""ja"" },
    { ""alphabet"",
      new char[]{ 0x3044, 0x308d, 0x306f, 0x306b, 0x307b, 0x3078, 0x3068,
                  0x3061, 0x308a, 0x306c, 0x308b, 0x3092, 0x308f, 0x304b,
                  0x3088, 0x305f, 0x308c, 0x305d, 0x3064, 0x306d, 0x306a,
                  0x3089, 0x3080, 0x3046, 0x3090, 0x306e, 0x304a, 0x304f,
                  0x3084, 0x307e, 0x3051, 0x3075, 0x3053, 0x3048, 0x3066,
                  0x3042, 0x3055, 0x304d, 0x3086, 0x3081, 0x307f, 0x3057,
                  0x3091, 0x3072, 0x3082, 0x305b, 0x3059 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    
    
    { ""multiplier"",
      new long[]{ Long.MAX_VALUE, Long.MAX_VALUE, 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4EAC, 0x5146, 0x5104, 0x4E07, 0x5343, 0x767e, 0x5341 } },

    
    { ""zero"", new char[0] },
    { ""digits"",
      new char[]{ 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03,
                  0x516B, 0x4E5D } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xpath.XPathAPI,10,1,0,6,21,45,1,5,10,2.0,116,0.0,0,0.0,0.5,0,0,10.6,1,0.9,0,"
package org.apache.xpath;

import javax.xml.transform.TransformerException;

import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.PrefixResolverDefault;
import org.apache.xpath.objects.XObject;

import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;


public class XPathAPI
{

  
  public static Node selectSingleNode(Node contextNode, String str)
          throws TransformerException
  {
    return selectSingleNode(contextNode, str, contextNode);
  }

  
  public static Node selectSingleNode(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    NodeIterator nl = selectNodeIterator(contextNode, str, namespaceNode);

    
    return nl.nextNode();
  }

  
  public static NodeIterator selectNodeIterator(Node contextNode, String str)
          throws TransformerException
  {
    return selectNodeIterator(contextNode, str, contextNode);
  }

  
  public static NodeIterator selectNodeIterator(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    XObject list = eval(contextNode, str, namespaceNode);

    
    return list.nodeset();
  }

  
  public static NodeList selectNodeList(Node contextNode, String str)
          throws TransformerException
  {
    return selectNodeList(contextNode, str, contextNode);
  }

  
  public static NodeList selectNodeList(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    XObject list = eval(contextNode, str, namespaceNode);

    
    return list.nodelist();
  }

  
  public static XObject eval(Node contextNode, String str)
          throws TransformerException
  {
    return eval(contextNode, str, contextNode);
  }

  
  public static XObject eval(Node contextNode, String str, Node namespaceNode)
          throws TransformerException
  {

    
    
    
    
    
    XPathContext xpathSupport = new XPathContext();

    
    
    
    
    PrefixResolverDefault prefixResolver = new PrefixResolverDefault(
      (namespaceNode.getNodeType() == Node.DOCUMENT_NODE)
      ? ((Document) namespaceNode).getDocumentElement() : namespaceNode);

    
    XPath xpath = new XPath(str, null, prefixResolver, XPath.SELECT, null);

    
    
    int ctxtNode = xpathSupport.getDTMHandleFromNode(contextNode);

    return xpath.execute(xpathSupport, ctxtNode, prefixResolver);
  }

  
  public static XObject eval(
          Node contextNode, String str, PrefixResolver prefixResolver)
            throws TransformerException
  {

    
    
    
    
    
    
    XPath xpath = new XPath(str, null, prefixResolver, XPath.SELECT, null);

    
    XPathContext xpathSupport = new XPathContext();
    int ctxtNode = xpathSupport.getDTMHandleFromNode(contextNode);

    return xpath.execute(xpathSupport, ctxtNode, prefixResolver);
  }
}
"
org.apache.xalan.xsltc.compiler.SymbolTable,25,1,0,91,48,214,89,9,24,0.891666667,494,1.0,1,0.0,0.185454545,0,0,18.36,5,2.2,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.MethodType;

final class SymbolTable {

    
    private final Hashtable _stylesheets = new Hashtable();
    private final Hashtable _primops     = new Hashtable();

    
    private Hashtable _variables = null;
    private Hashtable _templates = null;
    private Hashtable _attributeSets = null;
    private Hashtable _aliases = null;
    private Hashtable _excludedURI = null;
    private Hashtable _decimalFormats = null;

    public DecimalFormatting getDecimalFormatting(QName name) {
	if (_decimalFormats == null) return null;
	return((DecimalFormatting)_decimalFormats.get(name));
    }

    public void addDecimalFormatting(QName name, DecimalFormatting symbols) {
	if (_decimalFormats == null) _decimalFormats = new Hashtable();
	_decimalFormats.put(name, symbols);
    }

    public Stylesheet addStylesheet(QName name, Stylesheet node) {
	return (Stylesheet)_stylesheets.put(name, node);
    }
	
    public Stylesheet lookupStylesheet(QName name) {
	return (Stylesheet)_stylesheets.get(name);
    }

    public Template addTemplate(Template template) {
	final QName name = template.getName();
	if (_templates == null) _templates = new Hashtable();
	return (Template)_templates.put(name, template);
    }
	
    public Template lookupTemplate(QName name) {
	if (_templates == null) return null;
	return (Template)_templates.get(name);
    }

    public Variable addVariable(Variable variable) {
	if (_variables == null) _variables = new Hashtable();
	final String name = variable.getName().getStringRep();
	return (Variable)_variables.put(name, variable);
    }
	
    public Param addParam(Param parameter) {
	if (_variables == null) _variables = new Hashtable();
	final String name = parameter.getName().getStringRep();
	return (Param)_variables.put(name, parameter);
    }
	
    public Variable lookupVariable(QName qname) {
	if (_variables == null) return null;
	final String name = qname.getStringRep();
	final Object obj = _variables.get(name);
	return obj instanceof Variable ? (Variable)obj : null;
    }

    public Param lookupParam(QName qname) {
	if (_variables == null) return null;
	final String name = qname.getStringRep();
	final Object obj = _variables.get(name);
	return obj instanceof Param ? (Param)obj : null;
    }
	
    public SyntaxTreeNode lookupName(QName qname) {
	if (_variables == null) return null;
	final String name = qname.getStringRep();
	return (SyntaxTreeNode)_variables.get(name);
    }

    public AttributeSet addAttributeSet(AttributeSet atts) {
	if (_attributeSets == null) _attributeSets = new Hashtable();
	return (AttributeSet)_attributeSets.put(atts.getName(), atts);
    }

    public AttributeSet lookupAttributeSet(QName name) {
	if (_attributeSets == null) return null;
	return (AttributeSet)_attributeSets.get(name);
    }

    
    public void addPrimop(String name, MethodType mtype) {
	Vector methods = (Vector)_primops.get(name);
	if (methods == null) {
	    _primops.put(name, methods = new Vector());
	}
	methods.addElement(mtype);
    }
	
    
    public Vector lookupPrimop(String name) {
	return (Vector)_primops.get(name);
    }

    
    private int _nsCounter = 0;

    public String generateNamespacePrefix() {
	return(new String(""ns""+(_nsCounter++)));
    }

    
    private SyntaxTreeNode _current = null;

    public void setCurrentNode(SyntaxTreeNode node) {
	_current = node;
    }

    public String lookupNamespace(String prefix) {
	if (_current == null) return(Constants.EMPTYSTRING);
	return(_current.lookupNamespace(prefix));
    }

     
    public void addPrefixAlias(String prefix, String alias) {
	if (_aliases == null) _aliases = new Hashtable();
	_aliases.put(prefix,alias);
    }

     
    public String lookupPrefixAlias(String prefix) {
	if (_aliases == null) return null;
	return (String)_aliases.get(prefix);
    }

    
    public void excludeURI(String uri) {
	
	if (uri == null) return;

	
	if (_excludedURI == null) _excludedURI = new Hashtable();

	
	Integer refcnt = (Integer)_excludedURI.get(uri);
	if (refcnt == null)
	    refcnt = new Integer(1);
	else
	    refcnt = new Integer(refcnt.intValue() + 1);
	_excludedURI.put(uri,refcnt);
    }

    
    public void excludeNamespaces(String prefixes) {
	if (prefixes != null) {
	    StringTokenizer tokens = new StringTokenizer(prefixes);
	    while (tokens.hasMoreTokens()) {
		final String prefix = tokens.nextToken();
		final String uri;
		if (prefix.equals(""#default""))
		    uri = lookupNamespace(Constants.EMPTYSTRING);
		else
		    uri = lookupNamespace(prefix);
		if (uri != null) excludeURI(uri);
	    }
	}
    }

    
    public boolean isExcludedNamespace(String uri) {
	if (uri != null && _excludedURI != null) {
	    final Integer refcnt = (Integer)_excludedURI.get(uri);
	    return (refcnt != null && refcnt.intValue() > 0);
	}
	return false;
    }

    
    public void unExcludeNamespaces(String prefixes) {
	if (_excludedURI == null) return;
	if (prefixes != null) {
	    StringTokenizer tokens = new StringTokenizer(prefixes);
	    while (tokens.hasMoreTokens()) {
		final String prefix = tokens.nextToken();
		final String uri;
		if (prefix.equals(""#default""))
		    uri = lookupNamespace(Constants.EMPTYSTRING);
		else
		    uri = lookupNamespace(prefix);
		Integer refcnt = (Integer)_excludedURI.get(uri);
		if (refcnt != null)
		    _excludedURI.put(uri, new Integer(refcnt.intValue() - 1));
	    }
	}	
    }

}

"
org.apache.xpath.compiler.FuncLoader,3,1,0,3,11,0,2,1,3,0.5,64,1.0,0,0.0,0.555555556,0,0,19.66666667,1,0.6667,1,"
package org.apache.xpath.compiler;

import org.apache.xpath.functions.Function;


public class FuncLoader
{

  
  private int m_funcID;

  
  private String m_funcName;

  
  public String getName()
  {
    return m_funcName;
  }

  
  public FuncLoader(String funcName, int funcID)
  {

    super();

    m_funcID = funcID;
    m_funcName = funcName;
  }

  
  public Function getFunction() throws javax.xml.transform.TransformerException
  {

    try
    {
      Class function;

      
      if (m_funcName.indexOf(""."") < 0)
      {

        
        
        
        String classname = ""org.apache.xpath.functions."" + m_funcName;

        function = Class.forName(classname);
      }
      else
        function = Class.forName(m_funcName);

      Function func = (Function) function.newInstance();

      return func;
    }
    catch (ClassNotFoundException e)
    {
      throw new javax.xml.transform.TransformerException(e);
    }
    catch (IllegalAccessException e)
    {
      throw new javax.xml.transform.TransformerException(e);
    }
    catch (InstantiationException e)
    {
      throw new javax.xml.transform.TransformerException(e);
    }
  }
}
"
org.apache.xalan.res.XSLMessages,4,3,0,68,7,0,67,1,3,0.833333333,40,1.0,0,0.818181818,0.555555556,0,0,8.5,3,1.5,1,"
package org.apache.xalan.res;

import java.util.ListResourceBundle;

import org.apache.xpath.res.XPATHMessages;


public class XSLMessages extends XPATHMessages
{

  
  private static ListResourceBundle XSLTBundle = null;

  
  private static final String XSLT_ERROR_RESOURCES =
    ""org.apache.xalan.res.XSLTErrorResources"";

  
  public static final String createMessage(String msgKey, Object args[])  
  {
    if (XSLTBundle == null)
      XSLTBundle = loadResourceBundle(XSLT_ERROR_RESOURCES);
    
    if (XSLTBundle != null)
    {
      return createMsg(XSLTBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }
  
  
  public static final String createWarning(String msgKey, Object args[])  
  {
    if (XSLTBundle == null)
      XSLTBundle = loadResourceBundle(XSLT_ERROR_RESOURCES);

    if (XSLTBundle != null)
    {
      return createMsg(XSLTBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }
}
"
org.apache.xalan.xsltc.compiler.GenerateIdCall,2,4,0,10,12,1,0,10,2,2.0,39,0.0,0,0.989690722,0.6,2,4,18.5,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.InstructionList;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;

final class GenerateIdCall extends FunctionCall {
    public GenerateIdCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	if (argumentCount() == 0) {
	   il.append(methodGen.loadContextNode());
	}
	else {			
	    argument().translate(classGen, methodGen);
	}
	final ConstantPoolGen cpg = classGen.getConstantPool();
	il.append(new INVOKESTATIC(cpg.addMethodref(BASIS_LIBRARY_CLASS,
						    ""generate_idF"",
						    
						    GET_NODE_NAME_SIG)));
    }
}
"
org.apache.xalan.trace.TracerEvent,3,1,0,7,15,3,4,3,3,1.0,183,0.0,3,0.0,0.388888889,0,0,58.66666667,5,3.3333,1,"
package org.apache.xalan.trace;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;

import org.w3c.dom.Attr;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public class TracerEvent implements java.util.EventListener
{

  
  public final ElemTemplateElement m_styleNode;

  
  public final TransformerImpl m_processor;

  
  public final Node m_sourceNode;

  
  public final QName m_mode;

  
  public TracerEvent(TransformerImpl processor, Node sourceNode, QName mode,
                     ElemTemplateElement styleNode)
  {

    this.m_processor = processor;
    this.m_sourceNode = sourceNode;
    this.m_mode = mode;
    this.m_styleNode = styleNode;
  }

  
  public static String printNode(Node n)
  {

    String r = n.hashCode() + "" "";

    if (n instanceof Element)
    {
      r += ""<"" + n.getNodeName();

      Node c = n.getFirstChild();

      while (null != c)
      {
        if (c instanceof Attr)
        {
          r += printNode(c) + "" "";
        }

        c = c.getNextSibling();
      }

      r += "">"";
    }
    else
    {
      if (n instanceof Attr)
      {
        r += n.getNodeName() + ""="" + n.getNodeValue();
      }
      else
      {
        r += n.getNodeName();
      }
    }

    return r;
  }

  
  public static String printNodeList(NodeList l)
  {

    String r = l.hashCode() + ""["";
    int len = l.getLength() - 1;
    int i = 0;

    while (i < len)
    {
      Node n = l.item(i);

      if (null != n)
      {
        r += printNode(n) + "", "";
      }

      ++i;
    }

    if (i == len)
    {
      Node n = l.item(len);

      if (null != n)
      {
        r += printNode(n);
      }
    }

    return r + ""]"";
  }
}
"
org.apache.xpath.operations.Div,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;


public class Div extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() / right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (m_left.num(xctxt) / m_right.num(xctxt));
  }

}
"
org.apache.xalan.xsltc.compiler.Sort,18,3,0,59,109,93,2,59,13,0.847058824,1436,0.8,4,0.767123288,0.232323232,1,4,78.22222222,9,3.0556,3,"

package org.apache.xalan.xsltc.compiler;

import java.text.Collator;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.bcel.classfile.Field;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.ANEWARRAY;
import org.apache.bcel.generic.CHECKCAST;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.GETFIELD;
import org.apache.bcel.generic.ICONST;
import org.apache.bcel.generic.ILOAD;
import org.apache.bcel.generic.INVOKEINTERFACE;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.InstructionHandle;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.NOP;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.PUTFIELD;
import org.apache.bcel.generic.TABLESWITCH;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.CompareGenerator;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.IntType;
import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSortRecordFactGenerator;
import org.apache.xalan.xsltc.compiler.util.NodeSortRecordGenerator;
import org.apache.xalan.xsltc.compiler.util.StringType;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xalan.xsltc.dom.Axis;


final class Sort extends Instruction implements Closure {

    private Expression     _select;
    private AttributeValue _order;
    private AttributeValue _caseOrder;
    private AttributeValue _dataType;

    private String         _data = null;
    public  String         _lang;
    public  String         _country;

    private String _className = null;
    private ArrayList _closureVars = null;
    private boolean _needsSortRecordFactory = false;

    

    
    public boolean inInnerClass() {
	return (_className != null);
    }

    
    public Closure getParentClosure() {
	return null;
    }

    
    public String getInnerClassName() {
	return _className;
    }

    
    public void addVariable(VariableRefBase variableRef) {
	if (_closureVars == null) {
	    _closureVars = new ArrayList();
	}

	
	if (!_closureVars.contains(variableRef)) {
	    _closureVars.add(variableRef);
	    _needsSortRecordFactory = true;
	}
    }

    

    private void setInnerClassName(String className) {
	_className = className;
    }

    
    public void parseContents(Parser parser) {

	final SyntaxTreeNode parent = getParent();
	if (!(parent instanceof ApplyTemplates) &&
	    !(parent instanceof ForEach)) {
	    reportError(this, parser, ErrorMsg.STRAY_SORT_ERR, null);
	    return;
	}

	
	_select = parser.parseExpression(this, ""select"", ""string(.)"");

	
	String val = getAttribute(""order"");
	if (val.length() == 0) val = ""ascending"";
	_order = AttributeValue.create(this, val, parser);

	
	val = getAttribute(""case-order"");
	if (val.length() == 0) val = ""upper-first"";
	_caseOrder = AttributeValue.create(this, val, parser);

	
	val = getAttribute(""data-type"");
	if (val.length() == 0) {
	    try {
		final Type type = _select.typeCheck(parser.getSymbolTable());
		if (type instanceof IntType)
		    val = ""number"";
		else
		    val = ""text"";
	    }
	    catch (TypeCheckError e) {
		val = ""text"";
	    }
	}
	_dataType = AttributeValue.create(this, val, parser);

	
	if ((val = getAttribute(""lang"")) != null) {
	    try {
		StringTokenizer st = new StringTokenizer(val,""-"",false);
		_lang = st.nextToken();
		_country = st.nextToken();
	    }
	    catch (NoSuchElementException e) { 
	    }
	}
    }
    
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tselect = _select.typeCheck(stable);

	
	
	if (!(tselect instanceof StringType)) {
	    _select = new CastExpr(_select, Type.String);
	}

	_order.typeCheck(stable);
	_caseOrder.typeCheck(stable);
	_dataType.typeCheck(stable);
	return Type.Void;
    }

    
    public void translateSortType(ClassGenerator classGen,
				  MethodGenerator methodGen) {
	_dataType.translate(classGen, methodGen);
    }
    
    public void translateSortOrder(ClassGenerator classGen,
				   MethodGenerator methodGen) {
	_order.translate(classGen, methodGen);
    }
    
    
    public void translateSelect(ClassGenerator classGen,
				MethodGenerator methodGen) {
	_select.translate(classGen,methodGen);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }

    
    public static void translateSortIterator(ClassGenerator classGen,
				      MethodGenerator methodGen,
				      Expression nodeSet,
				      Vector sortObjects) 
    {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int init = cpg.addMethodref(SORT_ITERATOR, ""<init>"",
					  ""(""
					  + NODE_ITERATOR_SIG
					  + NODE_SORT_FACTORY_SIG
					  + "")V"");	

	il.append(new NEW(cpg.addClass(SORT_ITERATOR)));
	il.append(DUP);

	
	if (nodeSet == null) {	
	    final int children = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getAxisIterator"",
							   ""(I)""+
							   NODE_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(new PUSH(cpg, Axis.CHILD));
	    il.append(new INVOKEINTERFACE(children, 2));
	}
	else {
	    nodeSet.translate(classGen, methodGen);
	}
	
	
	
	compileSortRecordFactory(sortObjects, classGen, methodGen);
	il.append(new INVOKESPECIAL(init));
    }


    
    public static void compileSortRecordFactory(Vector sortObjects,
	ClassGenerator classGen, MethodGenerator methodGen) 
    {
	String sortRecordClass = 
	    compileSortRecord(sortObjects, classGen, methodGen);

	boolean needsSortRecordFactory = false;
	final int nsorts = sortObjects.size();
	for (int i = 0; i < nsorts; i++) {
	    final Sort sort = (Sort) sortObjects.elementAt(i);
	    needsSortRecordFactory |= sort._needsSortRecordFactory;
	}

	String sortRecordFactoryClass = NODE_SORT_FACTORY;
	if (needsSortRecordFactory) {
	    sortRecordFactoryClass = 
		compileSortRecordFactory(sortObjects, classGen, methodGen, 
		    sortRecordClass);
	}

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	
	il.append(new NEW(cpg.addClass(sortRecordFactoryClass)));
	il.append(DUP);
	il.append(methodGen.loadDOM());
	il.append(new PUSH(cpg, sortRecordClass));
	il.append(classGen.loadTranslet());

	
	il.append(new PUSH(cpg, nsorts));
	il.append(new ANEWARRAY(cpg.addClass(STRING)));
	for (int level = 0; level < nsorts; level++) {
	    final Sort sort = (Sort)sortObjects.elementAt(level);
	    il.append(DUP);
	    il.append(new PUSH(cpg, level));
	    sort.translateSortOrder(classGen, methodGen);
	    il.append(AASTORE);
	}

	il.append(new PUSH(cpg, nsorts));
	il.append(new ANEWARRAY(cpg.addClass(STRING)));
	for (int level = 0; level < nsorts; level++) {
	    final Sort sort = (Sort)sortObjects.elementAt(level);
	    il.append(DUP);
	    il.append(new PUSH(cpg, level));
	    sort.translateSortType(classGen, methodGen);
	    il.append(AASTORE);
	}

	il.append(new INVOKESPECIAL(
	    cpg.addMethodref(sortRecordFactoryClass, ""<init>"", 
		""("" + DOM_INTF_SIG 
		    + STRING_SIG
		    + TRANSLET_INTF_SIG
		    + ""["" + STRING_SIG
		    + ""["" + STRING_SIG + "")V"")));

	
	final ArrayList dups = new ArrayList();

	for (int j = 0; j < nsorts; j++) {
	    final Sort sort = (Sort) sortObjects.get(j);
	    final int length = (sort._closureVars == null) ? 0 : 
		sort._closureVars.size();

	    for (int i = 0; i < length; i++) {
		VariableRefBase varRef = (VariableRefBase) sort._closureVars.get(i);

		
		if (dups.contains(varRef)) continue;

		final VariableBase var = varRef.getVariable();

		
		il.append(DUP);
		il.append(var.loadInstruction());
		il.append(new PUTFIELD(
			cpg.addFieldref(sortRecordFactoryClass, var.getVariable(), 
			    var.getType().toSignature())));
		dups.add(varRef);
	    }
	}
    }

    public static String compileSortRecordFactory(Vector sortObjects,
	ClassGenerator classGen, MethodGenerator methodGen, 
	String sortRecordClass)
    {
	final XSLTC  xsltc = ((Sort)sortObjects.firstElement()).getXSLTC();
	final String className = xsltc.getHelperClassName();

	final NodeSortRecordFactGenerator sortRecordFactory =
	    new NodeSortRecordFactGenerator(className,
					NODE_SORT_FACTORY,
					className + "".java"",
					ACC_PUBLIC | ACC_SUPER | ACC_FINAL,
					new String[] {},
					classGen.getStylesheet());

	ConstantPoolGen cpg = sortRecordFactory.getConstantPool();

	
	final int nsorts = sortObjects.size();
	final ArrayList dups = new ArrayList();

	for (int j = 0; j < nsorts; j++) {
	    final Sort sort = (Sort) sortObjects.get(j);
	    final int length = (sort._closureVars == null) ? 0 : 
		sort._closureVars.size();

	    for (int i = 0; i < length; i++) {
		final VariableRef varRef = (VariableRef) sort._closureVars.get(i);

		
		if (dups.contains(varRef)) continue;

		final VariableBase var = varRef.getVariable();
		sortRecordFactory.addField(new Field(ACC_PUBLIC, 
					   cpg.addUtf8(var.getVariable()),
					   cpg.addUtf8(var.getType().toSignature()),
					   null, cpg.getConstantPool()));
		dups.add(varRef);
	    }
	}

	
	final org.apache.bcel.generic.Type[] argTypes = 
	    new org.apache.bcel.generic.Type[5];
	argTypes[0] = Util.getJCRefType(DOM_INTF_SIG);
	argTypes[1] = Util.getJCRefType(STRING_SIG);
	argTypes[2] = Util.getJCRefType(TRANSLET_INTF_SIG);
	argTypes[3] = Util.getJCRefType(""["" + STRING_SIG);
	argTypes[4] = Util.getJCRefType(""["" + STRING_SIG);

	final String[] argNames = new String[5];
	argNames[0] = DOCUMENT_PNAME;
	argNames[1] = ""className"";
	argNames[2] = TRANSLET_PNAME;
	argNames[3] = ""order"";
	argNames[4] = ""type"";

	InstructionList il = new InstructionList();
	final MethodGenerator constructor =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID, 
				argTypes, argNames, ""<init>"", 
				className, il, cpg);

	
	il.append(ALOAD_0);
	il.append(ALOAD_1);
	il.append(ALOAD_2);
	il.append(new ALOAD(3));
	il.append(new ALOAD(4));
	il.append(new ALOAD(5));
	il.append(new INVOKESPECIAL(cpg.addMethodref(NODE_SORT_FACTORY,
	    ""<init>"", 
	    ""("" + DOM_INTF_SIG 
		+ STRING_SIG 
		+ TRANSLET_INTF_SIG 
		+ ""["" + STRING_SIG
		+ ""["" + STRING_SIG + "")V"")));
	il.append(RETURN);

	
	il = new InstructionList(); 
	final MethodGenerator makeNodeSortRecord =
	    new MethodGenerator(ACC_PUBLIC,
		Util.getJCRefType(NODE_SORT_RECORD_SIG), 
		new org.apache.bcel.generic.Type[] { 
		    org.apache.bcel.generic.Type.INT,
		    org.apache.bcel.generic.Type.INT },
		new String[] { ""node"", ""last"" }, ""makeNodeSortRecord"",
		className, il, cpg);

	il.append(ALOAD_0);
	il.append(ILOAD_1);
	il.append(ILOAD_2);
	il.append(new INVOKESPECIAL(cpg.addMethodref(NODE_SORT_FACTORY,
	    ""makeNodeSortRecord"", ""(II)"" + NODE_SORT_RECORD_SIG)));
	il.append(DUP);
	il.append(new CHECKCAST(cpg.addClass(sortRecordClass)));

	
	final int ndups = dups.size();
	for (int i = 0; i < ndups; i++) {
	    final VariableRef varRef = (VariableRef) dups.get(i);
	    final VariableBase var = varRef.getVariable();
	    final Type varType = var.getType();
	    
	    il.append(DUP);

	    
	    il.append(ALOAD_0);
	    il.append(new GETFIELD(
		cpg.addFieldref(className,
		    var.getVariable(), varType.toSignature())));

	    
	    il.append(new PUTFIELD(
		cpg.addFieldref(sortRecordClass,
		    var.getVariable(), varType.toSignature())));
	}
	il.append(POP);
	il.append(ARETURN);

	constructor.setMaxLocals();
	constructor.setMaxStack();
	sortRecordFactory.addMethod(constructor.getMethod());
	makeNodeSortRecord.setMaxLocals();
	makeNodeSortRecord.setMaxStack();
	sortRecordFactory.addMethod(makeNodeSortRecord.getMethod());
	xsltc.dumpClass(sortRecordFactory.getJavaClass());

	return className;
    }

    
    private static String compileSortRecord(Vector sortObjects,
					    ClassGenerator classGen,
					    MethodGenerator methodGen) {
	final XSLTC  xsltc = ((Sort)sortObjects.firstElement()).getXSLTC();
	final String className = xsltc.getHelperClassName();

	
	final NodeSortRecordGenerator sortRecord =
	    new NodeSortRecordGenerator(className,
					NODE_SORT_RECORD,
					""sort$0.java"",
					ACC_PUBLIC | ACC_SUPER | ACC_FINAL,
					new String[] {},
					classGen.getStylesheet());
	
	final ConstantPoolGen cpg = sortRecord.getConstantPool();	

	
	final int nsorts = sortObjects.size();
	final ArrayList dups = new ArrayList();

	for (int j = 0; j < nsorts; j++) {
	    final Sort sort = (Sort) sortObjects.get(j);

	    
	    sort.setInnerClassName(className);	

	    final int length = (sort._closureVars == null) ? 0 : 
		sort._closureVars.size();
	    for (int i = 0; i < length; i++) {
		final VariableRef varRef = (VariableRef) sort._closureVars.get(i);

		
		if (dups.contains(varRef)) continue;

		final VariableBase var = varRef.getVariable();
		sortRecord.addField(new Field(ACC_PUBLIC, 
				    cpg.addUtf8(var.getVariable()),
				    cpg.addUtf8(var.getType().toSignature()),
				    null, cpg.getConstantPool()));
		dups.add(varRef);
	    }
	}

	Method init = compileInit(sortObjects, sortRecord,
					 cpg, className);
	Method extract = compileExtract(sortObjects, sortRecord,
					cpg, className);
	sortRecord.addMethod(init);
	sortRecord.addMethod(extract);

	xsltc.dumpClass(sortRecord.getJavaClass());
	return className;
    }

    
    private static Method compileInit(Vector sortObjects,
					   NodeSortRecordGenerator sortRecord,
					   ConstantPoolGen cpg,
					   String className) 
    {
	final InstructionList il = new InstructionList();
	final MethodGenerator init = 
	    new MethodGenerator(ACC_PUBLIC, 
				org.apache.bcel.generic.Type.VOID, 
				null, null, ""<init>"", className, 
				il, cpg);

	
	il.append(ALOAD_0);
	il.append(new INVOKESPECIAL(cpg.addMethodref(NODE_SORT_RECORD,
						     ""<init>"", ""()V"")));

	final int initLocale =  cpg.addMethodref(""java/util/Locale"",
						 ""<init>"",
						 ""(Ljava/lang/String;""+
						 ""Ljava/lang/String;)V"");
	
	final int getCollator = cpg.addMethodref(COLLATOR_CLASS,
						 ""getInstance"",
						 ""(Ljava/util/Locale;)""+
						 COLLATOR_SIG);

	final int setStrength = cpg.addMethodref(COLLATOR_CLASS,
						 ""setStrength"", ""(I)V"");

	final int levels = sortObjects.size();

	

	
	String language = null;
	String country = null;
	Sort sort = (Sort)sortObjects.elementAt(0);

	for (int level = 0; level < levels; level++) {
	    if (language == null && sort._lang != null) {
		language = sort._lang;
	    }
	    if (country == null && sort._country != null) {
		country = sort._country;
	    }
	}

	final int collator =
	    cpg.addFieldref(className, ""_collator"", COLLATOR_SIG);
	final int locale =
	    cpg.addFieldref(className, ""_locale"", LOCALE_SIG);

	if (language != null) {
	    
	    il.append(new NEW(cpg.addClass(""java/util/Locale"")));
	    il.append(DUP);
	    il.append(DUP);
	    il.append(new PUSH(cpg, language));
	    il.append(new PUSH(cpg, (country != null ? country : EMPTYSTRING)));
	    il.append(new INVOKESPECIAL(initLocale));
	    il.append(ALOAD_0);
	    il.append(SWAP);
	    il.append(new PUTFIELD(locale));
	    
	    
	    il.append(new INVOKESTATIC(getCollator));
	    il.append(ALOAD_0);
	    il.append(SWAP);
	    il.append(new PUTFIELD(collator));
	}

	il.append(ALOAD_0);
	il.append(new GETFIELD(collator));
	il.append(new ICONST(Collator.TERTIARY));
	il.append(new INVOKEVIRTUAL(setStrength));

	il.append(RETURN);

	init.stripAttributes(true);
	init.setMaxLocals();
	init.setMaxStack();

	return init.getMethod();
    }


    
    private static Method compileExtract(Vector sortObjects,
					 NodeSortRecordGenerator sortRecord,
					 ConstantPoolGen cpg,
					 String className) {
	final InstructionList il = new InstructionList();
	
	
	final CompareGenerator extractMethod =
	    new CompareGenerator(ACC_PUBLIC | ACC_FINAL,
				 org.apache.bcel.generic.Type.STRING, 
				 new org.apache.bcel.generic.Type[] {
		                     Util.getJCRefType(DOM_INTF_SIG),
				     org.apache.bcel.generic.Type.INT,
				     org.apache.bcel.generic.Type.INT,
				     Util.getJCRefType(TRANSLET_SIG),
				     org.apache.bcel.generic.Type.INT
				 },
				 new String[] { ""dom"",
						""current"",
						""level"",
						""translet"",
						""last""
				 },
				 ""extractValueFromDOM"", className, il, cpg);

	
	final int levels = sortObjects.size();
	final int match[] = new int[levels];
	final InstructionHandle target[] = new InstructionHandle[levels];
	InstructionHandle tblswitch = null;

	
	if (levels > 1) {
	    
	    il.append(new ILOAD(extractMethod.getLocalIndex(""level"")));
	    
	    tblswitch = il.append(new NOP());
	}

	
	for (int level = 0; level < levels; level++) {
	    match[level] = level;
	    final Sort sort = (Sort)sortObjects.elementAt(level);
	    target[level] = il.append(NOP);
	    sort.translateSelect(sortRecord, extractMethod);
	    il.append(ARETURN);
	}
	
	
	if (levels > 1) {
	    
	    InstructionHandle defaultTarget =
		il.append(new PUSH(cpg, EMPTYSTRING));
	    il.insert(tblswitch,new TABLESWITCH(match, target, defaultTarget));
	    il.append(ARETURN);
	}

	extractMethod.stripAttributes(true);
	extractMethod.setMaxLocals();
	extractMethod.setMaxStack();
	extractMethod.removeNOPs();

	return extractMethod.getMethod();
    }
}
"
org.apache.xalan.templates.ElemElement,13,4,1,15,51,30,2,13,9,0.583333333,390,1.0,2,0.943925234,0.230769231,2,6,28.84615385,8,1.6923,3,"
package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.serializer.SerializationHandler;
import org.apache.xml.utils.QName;
import org.apache.xpath.XPathContext;
import org.xml.sax.SAXException;


public class ElemElement extends ElemUse
{

  
  protected AVT m_name_avt = null;

  
  public void setName(AVT v)
  {
    m_name_avt = v;
  }

  
  public AVT getName()
  {
    return m_name_avt;
  }

  
  protected AVT m_namespace_avt = null;

  
  public void setNamespace(AVT v)
  {
    m_namespace_avt = v;
  }

  
  public AVT getNamespace()
  {
    return m_namespace_avt;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_name_avt)
      m_name_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_namespace_avt)
      m_namespace_avt.fixupVariables(vnames, cstate.getGlobalsSize());
  }


  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_ELEMENT;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_ELEMENT_STRING;
  }
  
  
   protected boolean validateNodeName(String nodeName)
   {
    if(nodeName == null)
      return false;

    int len = nodeName.length();
    
    if(len == 0)
      return false;
      
    int indexOfNSSep = nodeName.indexOf(':');

    if(indexOfNSSep + 1 == len)
      return false;
      
    if(indexOfNSSep == 0)
      return false;
      
    String localName = QName.getLocalPart(nodeName);
      
    if(isValidNCName(localName))
    {
      String prefix = QName.getPrefixPart(nodeName);
      if(prefix.length() == 0)
        return true;
      if(isValidNCName(prefix))
        return true;
    }

    return false;
   }
   
  
  protected String resolvePrefix(SerializationHandler rhandler,
                                 String prefix, String nodeNamespace)
    throws TransformerException
  {









    return prefix;
  }
    
  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
      
 	SerializationHandler rhandler = transformer.getSerializationHandler();
    XPathContext xctxt = transformer.getXPathContext();
    int sourceNode = xctxt.getCurrentNode();
    
    
    String nodeName = m_name_avt == null ? null : m_name_avt.evaluate(xctxt, sourceNode, this);

    String prefix = null;
    String nodeNamespace = """";

    
    if ((nodeName != null) && (!m_name_avt.isSimple()) && (!validateNodeName(nodeName)))
    {
      transformer.getMsgMgr().warn(
        this, XSLTErrorResources.WG_ILLEGAL_ATTRIBUTE_VALUE,
        new Object[]{ Constants.ATTRNAME_NAME, nodeName });

      nodeName = null;
    }

    else if (nodeName != null)
    {
      prefix = QName.getPrefixPart(nodeName);

      if (null != m_namespace_avt)
      {
        nodeNamespace = m_namespace_avt.evaluate(xctxt, sourceNode, this);
        if (null == nodeNamespace || 
            (prefix != null && prefix.length()>0 && nodeNamespace.length()== 0) )
          transformer.getMsgMgr().error(
              this, XSLTErrorResources.ER_NULL_URI_NAMESPACE);
        else
        {
        

        prefix = resolvePrefix(rhandler, prefix, nodeNamespace);
        if (null == prefix)
          prefix = """";

        if (prefix.length() > 0)
          nodeName = (prefix + "":"" + QName.getLocalPart(nodeName));
        else
          nodeName = QName.getLocalPart(nodeName);
        }
      }

      
      
      else    
      {
        try
        {
          
          nodeNamespace = getNamespaceForPrefix(prefix);

          
          
          

          if ( (null == nodeNamespace) && (prefix.length() == 0) )
            nodeNamespace = """";
          else if (null == nodeNamespace)
          {
            transformer.getMsgMgr().warn(
              this, XSLTErrorResources.WG_COULD_NOT_RESOLVE_PREFIX,
              new Object[]{ prefix });

            nodeName = null;
          }

        }
        catch (Exception ex)
        {
          transformer.getMsgMgr().warn(
            this, XSLTErrorResources.WG_COULD_NOT_RESOLVE_PREFIX,
            new Object[]{ prefix });

          nodeName = null;
        }
      }
    }

    constructNode(nodeName, prefix, nodeNamespace, transformer);

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
  }
  
  
  void constructNode(
          String nodeName, String prefix, String nodeNamespace, TransformerImpl transformer)
            throws TransformerException
  {

    boolean shouldAddAttrs;

    try
    {
      SerializationHandler rhandler = transformer.getResultTreeHandler();

      if (null == nodeName)
      {
        shouldAddAttrs = false;
      }
      else
      {
        
        
        
        executeNSDecls(transformer, prefix);

        if (null != prefix)
        {
          rhandler.startPrefixMapping(prefix, nodeNamespace, true);
        }

        rhandler.startElement(nodeNamespace, QName.getLocalPart(nodeName),
                              nodeName);

        super.execute(transformer);

        shouldAddAttrs = true;
      }

      transformer.executeChildTemplates(this, shouldAddAttrs);

      
      if (null != nodeName)
      {
        rhandler.endElement(nodeNamespace, QName.getLocalPart(nodeName),
                            nodeName);
        if (null != prefix)
        {
          rhandler.endPrefixMapping(prefix);
        }
        
        
        unexecuteNSDecls(transformer, prefix);
      }
    }
    catch (SAXException se)
    {
      throw new TransformerException(se);
    }
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  	{
  	  if(null != m_name_avt)
  		m_name_avt.callVisitors(visitor);
  		
  	  if(null != m_namespace_avt)
  		m_namespace_avt.callVisitors(visitor);
  	}
  		
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xpath.axes.HasPositionalPredChecker,4,2,0,17,7,0,1,16,4,0.166666667,93,1.0,0,0.8,0.4,0,0,21.75,12,4.0,0,"
package org.apache.xpath.axes;

import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.functions.FuncLast;
import org.apache.xpath.functions.FuncPosition;
import org.apache.xpath.functions.Function;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.operations.Div;
import org.apache.xpath.operations.Minus;
import org.apache.xpath.operations.Mod;
import org.apache.xpath.operations.Mult;
import org.apache.xpath.operations.Plus;
import org.apache.xpath.operations.Quo;
import org.apache.xpath.operations.Variable;

public class HasPositionalPredChecker extends XPathVisitor
{
	private boolean m_hasPositionalPred = false;
	private int m_predDepth = 0;
	
	
	public static boolean check(LocPathIterator path)
	{
		HasPositionalPredChecker hppc = new HasPositionalPredChecker();
		path.callVisitors(null, hppc);
		return hppc.m_hasPositionalPred;
	}
	
	
	public boolean visitFunction(ExpressionOwner owner, Function func)
	{
		if((func instanceof FuncPosition) ||
		   (func instanceof FuncLast))
			m_hasPositionalPred = true;
		return true;
	}
	












	
  
  public boolean visitPredicate(ExpressionOwner owner, Expression pred)
  {
    m_predDepth++;

    if(m_predDepth == 1)
    {
      if((pred instanceof Variable) || 
         (pred instanceof XNumber) ||
         (pred instanceof Div) ||
         (pred instanceof Plus) ||
         (pred instanceof Minus) ||
         (pred instanceof Mod) ||
         (pred instanceof Quo) ||
         (pred instanceof Mult) ||
         (pred instanceof org.apache.xpath.operations.Number) ||
         (pred instanceof Function))
          m_hasPositionalPred = true;
      else
      	pred.callVisitors(owner, this);
    }

    m_predDepth--;

    
    return false;
  }


}

"
org.apache.xalan.xsltc.compiler.util.NodeCounterGenerator,4,4,0,5,6,4,1,4,4,0.666666667,26,1.0,0,0.964285714,0.45,0,0,5.25,1,0.75,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.ALOAD;
import org.apache.bcel.generic.Instruction;
import org.apache.xalan.xsltc.compiler.Stylesheet;


public final class NodeCounterGenerator extends ClassGenerator {
    private Instruction _aloadTranslet;

    public NodeCounterGenerator(String className, 
				String superClassName,
			        String fileName,
			        int accessFlags, 
				String[] interfaces,
			        Stylesheet stylesheet) {
	super(className, superClassName, fileName,
	      accessFlags, interfaces, stylesheet);
    }

    
    public void setTransletIndex(int index) {
	_aloadTranslet = new ALOAD(index);
    }

    
    public Instruction loadTranslet() {
	return _aloadTranslet;
    }
    
    
    public boolean isExternal() {
	return true;
    }
}
"
org.apache.xpath.functions.WrongNumberArgsException,1,3,0,12,2,0,12,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,1,"
package org.apache.xpath.functions;


public class WrongNumberArgsException extends Exception
{

  
  public WrongNumberArgsException(String argsExpected)
  {

    super(argsExpected);
  }
}
"
org.apache.xalan.xslt.EnvironmentCheck,22,1,0,1,78,219,1,0,5,0.972789116,2461,0.142857143,0,0.0,0.227513228,0,0,110.2272727,8,3.4091,1,"
package org.apache.xalan.xslt;

import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.Vector;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;


public class EnvironmentCheck
{

  
  public static void main(String[] args)
  {
    
    PrintWriter sendOutputTo = new PrintWriter(System.out, true);

    
    for (int i = 0; i < args.length; i++)
    {
      if (""-out"".equalsIgnoreCase(args[i]))
      {
        i++;

        if (i < args.length)
        {
          try
          {
            sendOutputTo = new PrintWriter(new FileWriter(args[i], true));
          }
          catch (Exception e)
          {
            System.err.println(""# WARNING: -out "" + args[i] + "" threw ""
                               + e.toString());
          }
        }
        else
        {
          System.err.println(
            ""# WARNING: -out argument should have a filename, output sent to console"");
        }
      }
    }

    EnvironmentCheck app = new EnvironmentCheck();
    app.checkEnvironment(sendOutputTo);
  }

  
  public boolean checkEnvironment(PrintWriter pw)
  {

    
    if (null != pw)
      outWriter = pw;

    
    Hashtable hash = getEnvironmentHash();

    
    boolean environmentHasErrors = writeEnvironmentReport(hash);

    if (environmentHasErrors)
    {
      
      
      logMsg(""# WARNING: Potential problems found in your environment!"");
      logMsg(""#    Check any 'ERROR' items above against the Xalan FAQs"");
      logMsg(""#    to correct potential problems with your classes/jars"");
      logMsg(""#    http:
      if (null != outWriter)
        outWriter.flush();
      return false;
    }
    else
    {
      logMsg(""# YAHOO! Your environment seems to be OK."");
      if (null != outWriter)
        outWriter.flush();
      return true;
    }
  }

  
  public Hashtable getEnvironmentHash()
  {
    
    Hashtable hash = new Hashtable();

    
    
    
    checkJAXPVersion(hash);
    checkProcessorVersion(hash);
    checkParserVersion(hash);
    checkAntVersion(hash);
    checkDOMVersion(hash);
    checkSAXVersion(hash);
    checkSystemProperties(hash);

    return hash;
  }

  
  protected boolean writeEnvironmentReport(Hashtable h)
  {

    if (null == h)
    {
      logMsg(""# ERROR: writeEnvironmentReport called with null Hashtable"");
      return false;
    }

    boolean errors = false;

    logMsg(
      ""#---- BEGIN writeEnvironmentReport($Revision: 1.19 $): Useful stuff found: ----"");

    
    for (Enumeration enum = h.keys(); 
         enum.hasMoreElements();
        
        )
    {
      Object key = enum.nextElement();
      String keyStr = (String) key;
      try
      {
        
        if (keyStr.startsWith(FOUNDCLASSES))
        {
          Vector v = (Vector) h.get(keyStr);
          errors |= logFoundJars(v, keyStr);
        }
        
        else
        {
          
          
          
          
          if (keyStr.startsWith(ERROR))
          {
            errors = true;
          }
          logMsg(keyStr + ""="" + h.get(keyStr));
        }
      }
      catch (Exception e)
      {
        logMsg(""Reading-"" + key + ""= threw: "" + e.toString());
      }
    }

    logMsg(
      ""#----- END writeEnvironmentReport: Useful properties found: -----"");

    return errors;
  }

  
  public static final String ERROR = ""ERROR."";

  
  public static final String WARNING = ""WARNING."";

  
  public static final String ERROR_FOUND = ""At least one error was found!"";

  
  public static final String VERSION = ""version."";

  
  public static final String FOUNDCLASSES = ""foundclasses."";

  
  public static final String CLASS_PRESENT = ""present-unknown-version"";

  
  public static final String CLASS_NOTPRESENT = ""not-present"";

  
  public String[] jarNames =
  {
    ""xalan.jar"", ""xalansamples.jar"", ""xalanj1compat.jar"", ""xalanservlet.jar"",
    ""xerces.jar"",       
    ""xercesImpl.jar"",   
    ""testxsl.jar"", 
    ""crimson.jar"", 
    ""lotusxsl.jar"", 
    ""jaxp.jar"", ""parser.jar"", ""dom.jar"", ""sax.jar"", ""xml.jar"", 
    ""xml-apis.jar"",
    ""xsltc.jar""
  };

  
  protected boolean logFoundJars(Vector v, String desc)
  {

    if ((null == v) || (v.size() < 1))
      return false;

    boolean errors = false;

    logMsg(""#---- BEGIN Listing XML-related jars in: "" + desc + "" ----"");

    for (int i = 0; i < v.size(); i++)
    {
      Hashtable subhash = (Hashtable) v.elementAt(i);

      for (Enumeration enum = subhash.keys(); 
           enum.hasMoreElements();
           
          )
      {
        Object key = enum.nextElement();
        String keyStr = (String) key;
        try
        {
          if (keyStr.startsWith(ERROR))
          {
            errors = true;
          }
          logMsg(keyStr + ""="" + subhash.get(keyStr));

        }
        catch (Exception e)
        {
          errors = true;
          logMsg(""Reading-"" + key + ""= threw: "" + e.toString());
        }
      }
    }

    logMsg(""#----- END Listing XML-related jars in: "" + desc + "" -----"");

    return errors;
  }

  
  public void appendEnvironmentReport(Node container, Document factory, Hashtable h)
  {
    if ((null == container) || (null == factory))
    {
      return;
    }
  
    try
    {
      Element envCheckNode = factory.createElement(""EnvironmentCheck"");
      envCheckNode.setAttribute(""version"", ""$Revision: 1.19 $"");
      container.appendChild(envCheckNode);

      if (null == h)
      {
        Element statusNode = factory.createElement(""status"");
        statusNode.setAttribute(""result"", ""ERROR"");
        statusNode.appendChild(factory.createTextNode(""appendEnvironmentReport called with null Hashtable!""));
        envCheckNode.appendChild(statusNode);
        return;
      }

      boolean errors = false;

      Element hashNode = factory.createElement(""environment"");
      envCheckNode.appendChild(hashNode);
      
      for (Enumeration enum = h.keys(); 
           enum.hasMoreElements();
          
          )
      {
        Object key = enum.nextElement();
        String keyStr = (String) key;
        try
        {
          
          if (keyStr.startsWith(FOUNDCLASSES))
          {
            Vector v = (Vector) h.get(keyStr);
            
            errors |= appendFoundJars(hashNode, factory, v, keyStr);
          }
          
          else 
          {
            
            
            
            
            if (keyStr.startsWith(ERROR))
            {
              errors = true;
            }
            Element node = factory.createElement(""item"");
            node.setAttribute(""key"", keyStr);
            node.appendChild(factory.createTextNode((String)h.get(keyStr)));
            hashNode.appendChild(node);
          }
        }
        catch (Exception e)
        {
          errors = true;
          Element node = factory.createElement(""item"");
          node.setAttribute(""key"", keyStr);
          node.appendChild(factory.createTextNode(ERROR + "" Reading "" + key + "" threw: "" + e.toString()));
          hashNode.appendChild(node);
        }
      } 

      Element statusNode = factory.createElement(""status"");
      statusNode.setAttribute(""result"", (errors ? ""ERROR"" : ""OK"" ));
      envCheckNode.appendChild(statusNode);
    }
    catch (Exception e2)
    {
      System.err.println(""appendEnvironmentReport threw: "" + e2.toString());
      e2.printStackTrace();
    }
  }    

  
  protected boolean appendFoundJars(Node container, Document factory, 
        Vector v, String desc)
  {

    if ((null == v) || (v.size() < 1))
      return false;

    boolean errors = false;

    for (int i = 0; i < v.size(); i++)
    {
      Hashtable subhash = (Hashtable) v.elementAt(i);

      for (Enumeration enum = subhash.keys(); 
           enum.hasMoreElements();
           
          )
      {
        Object key = enum.nextElement();
        try
        {
          String keyStr = (String) key;
          if (keyStr.startsWith(ERROR))
          {
            errors = true;
          }
          Element node = factory.createElement(""foundJar"");
          node.setAttribute(""name"", keyStr.substring(0, keyStr.indexOf(""-"")));
          node.setAttribute(""desc"", keyStr.substring(keyStr.indexOf(""-"") + 1));
          node.appendChild(factory.createTextNode((String)subhash.get(keyStr)));
          container.appendChild(node);
        }
        catch (Exception e)
        {
          errors = true;
          Element node = factory.createElement(""foundJar"");
          node.appendChild(factory.createTextNode(ERROR + "" Reading "" + key + "" threw: "" + e.toString()));
          container.appendChild(node);
        }
      }
    }
    return errors;
  }

  
  protected void checkSystemProperties(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    
    try
    {
      String javaVersion = System.getProperty(""java.version"");

      h.put(""java.version"", javaVersion);
    }
    catch (SecurityException se)
    {

      
      h.put(
        ""java.version"",
        ""WARNING: SecurityException thrown accessing system version properties"");
    }

    
    
    try
    {

      
      String cp = System.getProperty(""java.class.path"");

      h.put(""java.class.path"", cp);

      Vector classpathJars = checkPathForJars(cp, jarNames);

      if (null != classpathJars)
        h.put(FOUNDCLASSES + ""java.class.path"", classpathJars);

      
      String othercp = System.getProperty(""sun.boot.class.path"");

      if (null != othercp)
      {
        h.put(""sun.boot.class.path"", othercp);

        classpathJars = checkPathForJars(othercp, jarNames);

        if (null != classpathJars)
          h.put(FOUNDCLASSES + ""sun.boot.class.path"", classpathJars);
      }

      
      
      othercp = System.getProperty(""java.ext.dirs"");

      if (null != othercp)
      {
        h.put(""java.ext.dirs"", othercp);

        classpathJars = checkPathForJars(othercp, jarNames);

        if (null != classpathJars)
          h.put(FOUNDCLASSES + ""java.ext.dirs"", classpathJars);
      }

      
      
      
    }
    catch (SecurityException se2)
    {
      
      h.put(
        ""java.class.path"",
        ""WARNING: SecurityException thrown accessing system classpath properties"");
    }
  }

  
  protected Vector checkPathForJars(String cp, String[] jars)
  {

    if ((null == cp) || (null == jars) || (0 == cp.length())
            || (0 == jars.length))
      return null;

    Vector v = new Vector();
    StringTokenizer st = new StringTokenizer(cp, File.pathSeparator);

    while (st.hasMoreTokens())
    {

      
      String filename = st.nextToken();

      for (int i = 0; i < jars.length; i++)
      {
        if (filename.indexOf(jars[i]) > -1)
        {
          File f = new File(filename);

          if (f.exists())
          {

            
            
            try
            {
              Hashtable h = new Hashtable(2);
              
              h.put(jars[i] + ""-path"", f.getAbsolutePath());
              h.put(jars[i] + ""-apparent.version"",
                    getApparentVersion(jars[i], f.length()));
              v.addElement(h);
            }
            catch (Exception e)
            {

              
            }
          }
          else
          {
            Hashtable h = new Hashtable(2);
            
            h.put(jars[i] + ""-path"", WARNING + "" Classpath entry: "" 
                  + filename + "" does not exist"");
            h.put(jars[i] + ""-apparent.version"", CLASS_NOTPRESENT);
            v.addElement(h);
          }
        }
      }
    }

    return v;
  }

  
  protected String getApparentVersion(String jarName, long jarSize)
  {
    
    
    
    String foundSize = (String) jarVersions.get(new Long(jarSize));

    if ((null != foundSize) && (foundSize.startsWith(jarName)))
    {
      return foundSize;
    }
    else
    {
      if (""xerces.jar"".equalsIgnoreCase(jarName)
              || ""xercesImpl.jar"".equalsIgnoreCase(jarName)
              || ""xalan.jar"".equalsIgnoreCase(jarName))
      {

        
        
        
        return jarName + "" "" + WARNING + CLASS_PRESENT;
      }
      else
      {

        
        return jarName + "" "" + CLASS_PRESENT;
      }
    }
  }

  
  protected void checkJAXPVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    final Class noArgs[] = new Class[0];
    Class clazz = null;

    try
    {
      final String JAXP1_CLASS = ""javax.xml.parsers.DocumentBuilder"";
      final String JAXP11_METHOD = ""getDOMImplementation"";

      clazz = classForName(JAXP1_CLASS);

      Method method = clazz.getMethod(JAXP11_METHOD, noArgs);

      
      h.put(VERSION + ""JAXP"", ""1.1"");
    }
    catch (Exception e)
    {
      if (null != clazz)
      {

        
        
        h.put(ERROR + VERSION + ""JAXP"", ""1.0.1"");
        h.put(ERROR, ERROR_FOUND);
      }
      else
      {
        
        
        
        h.put(ERROR + VERSION + ""JAXP"", CLASS_NOTPRESENT);
        h.put(ERROR, ERROR_FOUND);
      }
    }
  }

  
  protected void checkProcessorVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    try
    {
      final String XALAN1_VERSION_CLASS =
        ""org.apache.xalan.xslt.XSLProcessorVersion"";
      Class clazz = classForName(XALAN1_VERSION_CLASS);

      
      StringBuffer buf = new StringBuffer();
      Field f = clazz.getField(""PRODUCT"");

      buf.append(f.get(null));
      buf.append(';');

      f = clazz.getField(""LANGUAGE"");

      buf.append(f.get(null));
      buf.append(';');

      f = clazz.getField(""S_VERSION"");

      buf.append(f.get(null));
      buf.append(';');
      h.put(VERSION + ""xalan1"", buf.toString());
    }
    catch (Exception e1)
    {
      h.put(VERSION + ""xalan1"", CLASS_NOTPRESENT);
    }

    try
    {
      
      
      final String XALAN2_VERSION_CLASS =
        ""org.apache.xalan.processor.XSLProcessorVersion"";
      Class clazz = classForName(XALAN2_VERSION_CLASS);

      
      StringBuffer buf = new StringBuffer();
      Field f = clazz.getField(""S_VERSION"");
      buf.append(f.get(null));

      h.put(VERSION + ""xalan2x"", buf.toString());
    }
    catch (Exception e2)
    {
      h.put(VERSION + ""xalan2x"", CLASS_NOTPRESENT);
    }
    try
    {
      
      final String XALAN2_2_VERSION_CLASS =
        ""org.apache.xalan.Version"";
      final String XALAN2_2_VERSION_METHOD = ""getVersion"";
      final Class noArgs[] = new Class[0];

      Class clazz = classForName(XALAN2_2_VERSION_CLASS);
      Method method = clazz.getMethod(XALAN2_2_VERSION_METHOD, noArgs);
      Object returnValue = method.invoke(null, new Object[0]);

      h.put(VERSION + ""xalan2_2"", (String)returnValue);
    }
    catch (Exception e2)
    {
      h.put(VERSION + ""xalan2_2"", CLASS_NOTPRESENT);
    }
  }

  
  protected void checkParserVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    try
    {
      final String XERCES1_VERSION_CLASS = ""org.apache.xerces.framework.Version"";
      Class clazz = classForName(XERCES1_VERSION_CLASS);

      
      Field f = clazz.getField(""fVersion"");
      String parserVersion = (String) f.get(null);

      h.put(VERSION + ""xerces1"", parserVersion);
    }
    catch (Exception e)
    {
      h.put(VERSION + ""xerces1"", CLASS_NOTPRESENT);
    }

    
    try
    {
      final String XERCES2_VERSION_CLASS = ""org.apache.xerces.impl.Version"";
      Class clazz = classForName(XERCES2_VERSION_CLASS);

      
      Field f = clazz.getField(""fVersion"");
      String parserVersion = (String) f.get(null);

      h.put(VERSION + ""xerces2"", parserVersion);
    }
    catch (Exception e)
    {
      h.put(VERSION + ""xerces2"", CLASS_NOTPRESENT);
    }

    try
    {
      final String CRIMSON_CLASS = ""org.apache.crimson.parser.Parser2"";
      Class clazz = classForName(CRIMSON_CLASS);

      
      h.put(VERSION + ""crimson"", CLASS_PRESENT);
    }
    catch (Exception e)
    {
      h.put(VERSION + ""crimson"", CLASS_NOTPRESENT);
    }
  }

  
  protected void checkAntVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    try
    {
      final String ANT_VERSION_CLASS = ""org.apache.tools.ant.Main"";
      final String ANT_VERSION_METHOD = ""getAntVersion""; 
      final Class noArgs[] = new Class[0];

      Class clazz = classForName(ANT_VERSION_CLASS);
      Method method = clazz.getMethod(ANT_VERSION_METHOD, noArgs);
      Object returnValue = method.invoke(null, new Object[0]);

      h.put(VERSION + ""ant"", (String)returnValue);
    }
    catch (Exception e)
    {
      h.put(VERSION + ""ant"", CLASS_NOTPRESENT);
    }
  }

  
  protected void checkDOMVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    final String DOM_LEVEL2_CLASS = ""org.w3c.dom.Document"";
    final String DOM_LEVEL2_METHOD = ""createElementNS"";  
    final String DOM_LEVEL2WD_CLASS = ""org.w3c.dom.Node"";
    final String DOM_LEVEL2WD_METHOD = ""supported"";  
    final String DOM_LEVEL2FD_CLASS = ""org.w3c.dom.Node"";
    final String DOM_LEVEL2FD_METHOD = ""isSupported"";  
    final Class twoStringArgs[] = { java.lang.String.class,
                                    java.lang.String.class };

    try
    {
      Class clazz = classForName(DOM_LEVEL2_CLASS);
      Method method = clazz.getMethod(DOM_LEVEL2_METHOD, twoStringArgs);

      
      
      h.put(VERSION + ""DOM"", ""2.0"");

      try
      {

        
        
        clazz = classForName(DOM_LEVEL2WD_CLASS);
        method = clazz.getMethod(DOM_LEVEL2WD_METHOD, twoStringArgs);

        h.put(ERROR + VERSION + ""DOM.draftlevel"", ""2.0wd"");
        h.put(ERROR, ERROR_FOUND);
      }
      catch (Exception e2)
      {
        try
        {

          
          clazz = classForName(DOM_LEVEL2FD_CLASS);
          method = clazz.getMethod(DOM_LEVEL2FD_METHOD, twoStringArgs);

          h.put(VERSION + ""DOM.draftlevel"", ""2.0fd"");
        }
        catch (Exception e3)
        {
          h.put(ERROR + VERSION + ""DOM.draftlevel"", ""2.0unknown"");
          h.put(ERROR, ERROR_FOUND);
        }
      }
    }
    catch (Exception e)
    {
      h.put(ERROR + VERSION + ""DOM"",
            ""ERROR attempting to load DOM level 2 class: "" + e.toString());
      h.put(ERROR, ERROR_FOUND);
    }

    
    
    
    
  }

  
  protected void checkSAXVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    final String SAX_VERSION1_CLASS = ""org.xml.sax.Parser"";
    final String SAX_VERSION1_METHOD = ""parse"";  
    final String SAX_VERSION2_CLASS = ""org.xml.sax.XMLReader"";
    final String SAX_VERSION2_METHOD = ""parse"";  
    final String SAX_VERSION2BETA_CLASSNF = ""org.xml.sax.helpers.AttributesImpl"";
    final String SAX_VERSION2BETA_METHODNF = ""setAttributes"";  
    final Class oneStringArg[] = { java.lang.String.class };
    
    final Class attributesArg[] = { org.xml.sax.Attributes.class };

    try
    {
      
      
      Class clazz = classForName(SAX_VERSION2BETA_CLASSNF);
      Method method = clazz.getMethod(SAX_VERSION2BETA_METHODNF, attributesArg);

      
      
      h.put(VERSION + ""SAX"", ""2.0"");
    }
    catch (Exception e)
    {
      
      h.put(ERROR + VERSION + ""SAX"",
            ""ERROR attempting to load SAX version 2 class: "" + e.toString());
      h.put(ERROR, ERROR_FOUND);
            
      try
      {
        Class clazz = classForName(SAX_VERSION2_CLASS);
        Method method = clazz.getMethod(SAX_VERSION2_METHOD, oneStringArg);

        
        
        
        h.put(VERSION + ""SAX-backlevel"", ""2.0beta2-or-earlier"");
      }
      catch (Exception e2)
      {
        
        h.put(ERROR + VERSION + ""SAX"",
              ""ERROR attempting to load SAX version 2 class: "" + e.toString());
        h.put(ERROR, ERROR_FOUND);
          
        try
        {
          Class clazz = classForName(SAX_VERSION1_CLASS);
          Method method = clazz.getMethod(SAX_VERSION1_METHOD, oneStringArg);

          
          
          
          h.put(VERSION + ""SAX-backlevel"", ""1.0"");
        }
        catch (Exception e3)
        {
          
          
          h.put(ERROR + VERSION + ""SAX-backlevel"",
                ""ERROR attempting to load SAX version 1 class: "" + e3.toString());
            
        }
      }
    }
  }

  
  protected static Class classForName(String className)
        throws ClassNotFoundException
  {
    ClassLoader classLoader = findClassLoader();
    if (classLoader == null) 
    {
      return Class.forName(className);
    } 
    else 
    {
      return classLoader.loadClass(className);
    }
  }
  
  
  protected static ClassLoader findClassLoader()
        throws ClassNotFoundException
  {
    ClassLoader classLoader = null;
    Method m = null;

    try 
    {
      m = Thread.class.getMethod(""getContextClassLoader"", null);
    } 
    catch (NoSuchMethodException e) 
    {
      
      return EnvironmentCheck.class.getClassLoader();
    }
    try 
    {
      return (ClassLoader) m.invoke(Thread.currentThread(), null);
    } 
    catch (Exception e) 
    {
      throw new RuntimeException(e.toString());
    }
  }

  
  protected static Hashtable jarVersions = new Hashtable();

  
  static 
  {
    
    jarVersions.put(new Long(857192), ""xalan.jar from xalan-j_1_1"");
    jarVersions.put(new Long(440237), ""xalan.jar from xalan-j_1_2"");
    jarVersions.put(new Long(436094), ""xalan.jar from xalan-j_1_2_1"");
    jarVersions.put(new Long(426249), ""xalan.jar from xalan-j_1_2_2"");
    jarVersions.put(new Long(702536), ""xalan.jar from xalan-j_2_0_0"");
    jarVersions.put(new Long(720930), ""xalan.jar from xalan-j_2_0_1"");
    jarVersions.put(new Long(732330), ""xalan.jar from xalan-j_2_1_0"");
    jarVersions.put(new Long(872241), ""xalan.jar from xalan-j_2_2_D10"");
    jarVersions.put(new Long(882739), ""xalan.jar from xalan-j_2_2_D11"");
    jarVersions.put(new Long(923866), ""xalan.jar from xalan-j_2_2_0"");
    jarVersions.put(new Long(905872), ""xalan.jar from xalan-j_2_3_D1"");
    jarVersions.put(new Long(906122), ""xalan.jar from xalan-j_2_3_0"");
    jarVersions.put(new Long(906248), ""xalan.jar from xalan-j_2_3_1"");
    jarVersions.put(new Long(983377), ""xalan.jar from xalan-j_2_4_D1"");    
    jarVersions.put(new Long(997276), ""xalan.jar from xalan-j_2_4_0"");
    jarVersions.put(new Long(1031036), ""xalan.jar from xalan-j_2_4_1"");    
    
    jarVersions.put(new Long(857171), ""xalan.jar from lotusxsl-j_1_0_1"");
    jarVersions.put(new Long(802165), ""xalan.jar from lotusxsl-j_2_0_0"");
    jarVersions.put(new Long(857692), ""xalan.jar from lotusxsl-j_2_2"");
    jarVersions.put(new Long(906359), ""xalan.jar from lotusxsl-j_2_3_1"");
    jarVersions.put(new Long(857692), ""xalan.jar from lotusxsl-j_2_3_2"");
    jarVersions.put(new Long(1201514), ""xalan.jar from lotusxsl-j_2_3_3"");
    jarVersions.put(new Long(1201599), ""xalan.jar from lotusxsl-j_2_3_4"");
    jarVersions.put(new Long(1201641), ""xalan.jar from lotusxsl-j_2_3_5"");    

    jarVersions.put(new Long(596540), ""xsltc.jar from xalan-j_2_2_0"");
    jarVersions.put(new Long(590247), ""xsltc.jar from xalan-j_2_3_D1"");
    jarVersions.put(new Long(589914), ""xsltc.jar from xalan-j_2_3_0"");
    jarVersions.put(new Long(589915), ""xsltc.jar from xalan-j_2_3_1"");
    jarVersions.put(new Long(1306667), ""xsltc.jar from xalan-j_2_4_D1"");     
    jarVersions.put(new Long(1328227), ""xsltc.jar from xalan-j_2_4_0"");
    jarVersions.put(new Long(1344009), ""xsltc.jar from xalan-j_2_4_1"");
    jarVersions.put(new Long(1348361), ""xsltc.jar from xalan-j_2_5_D1"");    
    jarVersions.put(new Long(1268634), ""xsltc.jar-bundled from xalan-j_2_3_0"");

    jarVersions.put(new Long(100196), ""xml-apis.jar from xalan-j_2_2_0 or xalan-j_2_3_D1"");
    jarVersions.put(new Long(108484), ""xml-apis.jar from xalan-j_2_3_0, or xalan-j_2_3_1 from xml-commons-1.0.b2"");
    jarVersions.put(new Long(109049), ""xml-apis.jar from xalan-j_2_4_0 from xml-commons RIVERCOURT1 branch"");
    jarVersions.put(new Long(109049), ""xml-apis.jar from xalan-j_2_4_0, lotusxsl-j_2_3_2 or lotusxsl-j_2_3_3 from xml-commons RIVERCOURT1"");
    jarVersions.put(new Long(113749), ""xml-apis.jar from xalan-j_2_4_1, lotusxsl-j_2_3_4 or lotusxsl-j_2_3_5 from factoryfinder-build of xml-commons RIVERCOURT1"");
    jarVersions.put(new Long(124704), ""xml-apis.jar from xalan-j_2_5_0 from from tck-jaxp-1_2_0 branch of xml-commons"");    
    
    
    jarVersions.put(new Long(424490), ""xalan.jar from Xerces Tools releases - ERROR:DO NOT USE!"");

    jarVersions.put(new Long(1591855), ""xerces.jar from xalan-j_1_1 from xerces-1..."");
    jarVersions.put(new Long(1498679), ""xerces.jar from xalan-j_1_2 from xerces-1_2_0.bin"");
    jarVersions.put(new Long(1484896), ""xerces.jar from xalan-j_1_2_1 from xerces-1_2_1.bin"");
    jarVersions.put(new Long(804460),  ""xerces.jar from xalan-j_1_2_2 from xerces-1_2_2.bin"");
    jarVersions.put(new Long(1499244), ""xerces.jar from xalan-j_2_0_0 from xerces-1_2_3.bin"");
    jarVersions.put(new Long(1605266), ""xerces.jar from xalan-j_2_0_1 from xerces-1_3_0.bin"");
    jarVersions.put(new Long(904030), ""xerces.jar from xalan-j_2_1_0 from xerces-1_4.bin"");
    jarVersions.put(new Long(1190776), ""xerces.jar from lotusxsl_1_0_1 apparently-from xerces-1_0_3.bin"");
    jarVersions.put(new Long(1489400), ""xerces.jar from lotusxsl-j_2_0_0 from XML4J-3_1_1"");
    jarVersions.put(new Long(1787796), ""xerces.jar from lotusxsl-j_2_2 or xerces-1_4_1.bin"");
    jarVersions.put(new Long(904030), ""xerces.jar from xerces-1_4_0.bin"");
    jarVersions.put(new Long(1802885), ""xerces.jar from xerces-1_4_2.bin"");
    jarVersions.put(new Long(1734594), ""xerces.jar from Xerces-J-bin.2.0.0.beta3"");
    jarVersions.put(new Long(1808883), ""xerces.jar from xalan-j_2_2_D10,D11,D12 or xerces-1_4_3.bin"");
    jarVersions.put(new Long(1803877), ""xerces.jar from XML4J-3_2_1"");
    jarVersions.put(new Long(1812019), ""xerces.jar from xalan-j_2_2_0"");
    jarVersions.put(new Long(1720292), ""xercesImpl.jar from xalan-j_2_3_D1"");
    jarVersions.put(new Long(1730053), ""xercesImpl.jar from xalan-j_2_3_0 or xalan-j_2_3_1 from xerces-2_0_0"");
    jarVersions.put(new Long(1728861), ""xercesImpl.jar from xalan-j_2_4_D1 from xerces-2_0_1"");    
    jarVersions.put(new Long(972027), ""xercesImpl.jar from xalan-j_2_4_0 from xerces-2_1"");
    jarVersions.put(new Long(831587), ""xercesImpl.jar from xalan-j_2_4_1 from xerces-2_2""); 
    jarVersions.put(new Long(891817), ""xercesImpl.jar from xalan-j_2_5_D1 from xerces-2_3"");  
    jarVersions.put(new Long(895924), ""xercesImpl.jar from xalan-j_2_5_0 from xerces-2_4"");                    
    jarVersions.put(new Long(1729063), ""xercesImpl.jar from lotusxsl-j_2_3_1 from XML4J-4_0_0"");
    jarVersions.put(new Long(1738551), ""xercesImpl.jar from lotusxsl-j_2_3_2 from XML4J-4_0_2"");
    jarVersions.put(new Long(3243826), ""xercesImpl.jar from lotusxsl-j_2_3_3 from XML4J-4_0_5"");
    jarVersions.put(new Long(1171789), ""xercesImpl.jar from lotusxsl-j_2_3_4 from XML4J-4_0_6"");
    jarVersions.put(new Long(1174955), ""xercesImpl.jar from lotusxsl-j_2_3_5 from XML4J-4_0_8"");
    jarVersions.put(new Long(1173922), ""xercesImpl.jar from lotusxsl-j_2_3_6 from XML4J-4_0_9"");
    jarVersions.put(new Long(831828), ""xercesImpl.jar from lotusxsl-j_2_4_0 from XML4J-4_1_1"");
  

    jarVersions.put(new Long(37485), ""xalanj1compat.jar from xalan-j_2_0_0"");
    jarVersions.put(new Long(38100), ""xalanj1compat.jar from xalan-j_2_0_1"");

    jarVersions.put(new Long(18779), ""xalanservlet.jar from xalan-j_2_0_0"");
    jarVersions.put(new Long(21453), ""xalanservlet.jar from xalan-j_2_0_1"");
    jarVersions.put(new Long(24826), ""xalanservlet.jar from xalan-j_2_3_1 or xalan-j_2_4_1 or lotusxsl-j_2_3_1 to lotusxsl-j-2_3_5"");    
    jarVersions.put(new Long(24831), ""xalanservlet.jar from xalan-j_2_4_1"");
    
    
    jarVersions.put(new Long(5618), ""jaxp.jar from jaxp1.0.1"");
    jarVersions.put(new Long(136133), ""parser.jar from jaxp1.0.1"");
    jarVersions.put(new Long(28404), ""jaxp.jar from jaxp-1.1"");
    jarVersions.put(new Long(187162), ""crimson.jar from jaxp-1.1"");
    jarVersions.put(new Long(801714), ""xalan.jar from jaxp-1.1"");
    jarVersions.put(new Long(196399), ""crimson.jar from crimson-1.1.1"");
    jarVersions.put(new Long(33323), ""jaxp.jar from crimson-1.1.1 or jakarta-ant-1.4.1b1"");
    jarVersions.put(new Long(152717), ""crimson.jar from crimson-1.1.2beta2"");
    jarVersions.put(new Long(88143), ""xml-apis.jar from crimson-1.1.2beta2"");
    jarVersions.put(new Long(206384), ""crimson.jar from crimson-1.1.3 or jakarta-ant-1.4.1b1"");

    
    jarVersions.put(new Long(136198), ""parser.jar from jakarta-ant-1.3 or 1.2"");
    jarVersions.put(new Long(5537), ""jaxp.jar from jakarta-ant-1.3 or 1.2"");

    
    
    jarVersions.put(new Long(120274), ""lotusxsl.jar from lotusxsl-0_16_4"");
    jarVersions.put(new Long(120293), ""lotusxsl.jar from lotusxsl-0_16_5"");
    jarVersions.put(new Long(283777), ""lotusxsl.jar from lotusxsl-0_17_2"");
    jarVersions.put(new Long(305577), ""lotusxsl.jar from lotusxsl-0_17_3"");
    jarVersions.put(new Long(304500), ""lotusxsl.jar from lotusxsl-0_17_4"");
    jarVersions.put(new Long(714959), ""lotusxsl.jar from lotusxsl-0_18_1"");
    jarVersions.put(new Long(717674), ""lotusxsl.jar from lotusxsl-0_18_2"");
    jarVersions.put(new Long(752343), ""lotusxsl.jar from lotusxsl-0_18_3"");
    jarVersions.put(new Long(907101), ""lotusxsl.jar from lotusxsl-0_18_4"");
  }

  
  protected PrintWriter outWriter = new PrintWriter(System.out, true);

  
  protected void logMsg(String s)
  {
    outWriter.println(s);
  }
}
"
org.apache.xalan.xsltc.dom.DOMBuilder,0,1,0,5,0,0,4,1,0,2.0,0,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"
package org.apache.xalan.xsltc.dom;


public interface DOMBuilder extends  ExtendedSAX { }
"
org.apache.xalan.processor.ProcessorLRE,4,5,0,17,77,6,1,17,3,2.0,472,0.0,0,0.986111111,0.5,4,6,117.0,3,1.25,1,"
package org.apache.xalan.processor;

import java.util.Vector;

import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemExtensionCall;
import org.apache.xalan.templates.ElemLiteralResult;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.XMLNSDecl;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xpath.XPath;

import org.xml.sax.Attributes;
import org.xml.sax.Locator;
import org.xml.sax.helpers.AttributesImpl;


public class ProcessorLRE extends ProcessorTemplateElem
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    try
    {
      ElemTemplateElement p = handler.getElemTemplateElement();
      boolean excludeXSLDecl = false;
      boolean isLREAsStyleSheet = false;

      if (null == p)
      {

        
        XSLTElementProcessor lreProcessor = handler.popProcessor();
        XSLTElementProcessor stylesheetProcessor =
                                                  handler.getProcessorFor(Constants.S_XSLNAMESPACEURL, ""stylesheet"",
                                                                          ""xsl:stylesheet"");

        handler.pushProcessor(lreProcessor);

        Stylesheet stylesheet;
        try
        {
          stylesheet = new StylesheetRoot(handler.getSchema(), handler.getStylesheetProcessor().getErrorListener());
        }
        catch(TransformerConfigurationException tfe)
        {
          throw new TransformerException(tfe);
        }

        
        
        SAXSourceLocator slocator = new SAXSourceLocator();
        Locator locator = handler.getLocator();
        if(null != locator)
        {
          slocator.setLineNumber(locator.getLineNumber());
          slocator.setColumnNumber(locator.getColumnNumber());
          slocator.setPublicId(locator.getPublicId());
          slocator.setSystemId(locator.getSystemId());
        }
        stylesheet.setLocaterInfo(slocator);
        stylesheet.setPrefixes(handler.getNamespaceSupport());
        handler.pushStylesheet(stylesheet);

        isLREAsStyleSheet = true;

        AttributesImpl stylesheetAttrs = new AttributesImpl();
        AttributesImpl lreAttrs = new AttributesImpl();
        int n = attributes.getLength();

        for (int i = 0; i < n; i++)
        {
          String attrLocalName = attributes.getLocalName(i);
          String attrUri = attributes.getURI(i);
          String value = attributes.getValue(i);

          if ((null != attrUri) && attrUri.equals(Constants.S_XSLNAMESPACEURL))
          {
            stylesheetAttrs.addAttribute(null, attrLocalName, attrLocalName,
                                         attributes.getType(i),
                                         attributes.getValue(i));
          }
          else if ((attrLocalName.startsWith(""xmlns:"") || attrLocalName.equals(
                                                                               ""xmlns"")) && value.equals(Constants.S_XSLNAMESPACEURL))
          {

            
          }
          else
          {
            lreAttrs.addAttribute(attrUri, attrLocalName,
                                  attributes.getQName(i),
                                  attributes.getType(i),
                                  attributes.getValue(i));
          }
        }

        attributes = lreAttrs;

        
        
        
				try{
        stylesheetProcessor.setPropertiesFromAttributes(handler, ""stylesheet"",
                                                        stylesheetAttrs, stylesheet);
				}
				catch (Exception e)
				{
					
					
					
					
					
					
					String msg = e.getMessage();
					if (stylesheet.getDeclaredPrefixes() == null || 
						!declaredXSLNS(stylesheet))
					{
						msg = msg +""; "" + XSLMessages.createWarning(XSLTErrorResources.WG_OLD_XSLT_NS, null);
						
					}
					
						throw new org.xml.sax.SAXException(msg, e);
				}
        handler.pushElemTemplateElement(stylesheet);

        ElemTemplate template = new ElemTemplate();

        appendAndPush(handler, template);

        XPath rootMatch = new XPath(""/"", stylesheet, stylesheet, XPath.MATCH, 
             handler.getStylesheetProcessor().getErrorListener());

        template.setMatch(rootMatch);

        
        stylesheet.setTemplate(template);

        p = handler.getElemTemplateElement();
        excludeXSLDecl = true;
      }

      XSLTElementDef def = getElemDef();
      Class classObject = def.getClassObject();
      boolean isExtension = false;
      boolean isComponentDecl = false;
      boolean isUnknownTopLevel = false;

      while (null != p)
      {

        
        if (p instanceof ElemLiteralResult)
        {
          ElemLiteralResult parentElem = (ElemLiteralResult) p;

          isExtension = parentElem.containsExtensionElementURI(uri);
        }
        else if (p instanceof Stylesheet)
        {
          Stylesheet parentElem = (Stylesheet) p;

          isExtension = parentElem.containsExtensionElementURI(uri);

          if ((false == isExtension) && (null != uri)
              && (uri.equals(Constants.S_BUILTIN_EXTENSIONS_URL)
                  || uri.equals(Constants.S_BUILTIN_OLD_EXTENSIONS_URL)))
          {
            isComponentDecl = true;
          }
          else
          {
            isUnknownTopLevel = true;
          }
        }

        if (isExtension)
          break;

        p = p.getParentElem();
      }

      ElemTemplateElement elem = null;

      try
      {
        if (isExtension)
        {

          
          elem = new ElemExtensionCall();
        }
        else if (isComponentDecl)
        {
          elem = (ElemTemplateElement) classObject.newInstance();
        }
        else if (isUnknownTopLevel)
        {

          
          elem = (ElemTemplateElement) classObject.newInstance();
        }
        else
        {
          elem = (ElemTemplateElement) classObject.newInstance();
        }

        elem.setDOMBackPointer(handler.getOriginatingNode());
        elem.setLocaterInfo(handler.getLocator());
        elem.setPrefixes(handler.getNamespaceSupport(), excludeXSLDecl);

        if (elem instanceof ElemLiteralResult)
        {
          ((ElemLiteralResult) elem).setNamespace(uri);
          ((ElemLiteralResult) elem).setLocalName(localName);
          ((ElemLiteralResult) elem).setRawName(rawName);
          ((ElemLiteralResult) elem).setIsLiteralResultAsStylesheet(
                                                                    isLREAsStyleSheet);
        }
      }
      catch (InstantiationException ie)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CREATING_ELEMLITRSLT, null, ie);
      }
      catch (IllegalAccessException iae)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CREATING_ELEMLITRSLT, null, iae);
      }

      setPropertiesFromAttributes(handler, rawName, attributes, elem);

      
      if (!isExtension && (elem instanceof ElemLiteralResult))
      {
        isExtension =
                     ((ElemLiteralResult) elem).containsExtensionElementURI(uri);

        if (isExtension)
        {

          
          elem = new ElemExtensionCall();

          elem.setLocaterInfo(handler.getLocator());
          elem.setPrefixes(handler.getNamespaceSupport());
          ((ElemLiteralResult) elem).setNamespace(uri);
          ((ElemLiteralResult) elem).setLocalName(localName);
          ((ElemLiteralResult) elem).setRawName(rawName);
          setPropertiesFromAttributes(handler, rawName, attributes, elem);
        }
      }

      appendAndPush(handler, elem);
    }
    catch(TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    ElemTemplateElement elem = handler.getElemTemplateElement();

    if (elem instanceof ElemLiteralResult)
    {
      if (((ElemLiteralResult) elem).getIsLiteralResultAsStylesheet())
      {
        handler.popStylesheet();
      }
    }

    super.endElement(handler, uri, localName, rawName);
  }
	
	private boolean declaredXSLNS(Stylesheet stylesheet)
	{
		Vector declaredPrefixes = stylesheet.getDeclaredPrefixes();
		int n = declaredPrefixes.size();

		for (int i = 0; i < n; i++)
		{
			XMLNSDecl decl = (XMLNSDecl) declaredPrefixes.elementAt(i);
			if(decl.getURI().equals(Constants.S_XSLNAMESPACEURL))
				return true;
		}
		return false;
	}
}
"
org.apache.xpath.axes.FilterExprIterator,14,6,0,11,32,0,1,11,11,0.730769231,163,1.0,2,0.914285714,0.234693878,4,8,10.35714286,3,1.2143,0,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XNodeSet;

public class FilterExprIterator extends BasicTestIterator
{
  
  private Expression m_expr;

  
  transient private XNodeSet m_exprObj;

  private boolean m_mustHardReset = false;
  private boolean m_canDetachNodeset = true;

  
  public FilterExprIterator()
  {
    super(null);
  }
  
  
  public FilterExprIterator(Expression expr)
  {
    super(null);
    m_expr = expr;
  }

  
  public void setRoot(int context, Object environment)
  {
  	super.setRoot(context, environment);
 	
  	m_exprObj = FilterExprIteratorSimple.executeFilterExpr(context, 
  	                  m_execContext, getPrefixResolver(), 
  	                  getIsTopLevel(), m_stackFrame, m_expr);
   }


  
  protected int getNextNode()
  {
    if (null != m_exprObj)
    {
      m_lastFetched = m_exprObj.nextNode();
    }
    else
      m_lastFetched = DTM.NULL;

    return m_lastFetched;
  }
  
  
  public void detach()
  {  
  	super.detach();
  	m_exprObj.detach();
  	m_exprObj = null;
  }

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    m_expr.fixupVariables(vars, globalsSize);
  }

  
  public Expression getInnerExpression()
  {
    return m_expr;
  }

  
  public void setInnerExpression(Expression expr)
  {
    expr.exprSetParent(this);
    m_expr = expr;
  }

  
  public int getAnalysisBits()
  {
    if (null != m_expr && m_expr instanceof PathComponent)
    {
      return ((PathComponent) m_expr).getAnalysisBits();
    }
    return WalkerFactory.BIT_FILTER;
  }

  
  public boolean isDocOrdered()
  {
    return m_exprObj.isDocOrdered();
  }

  class filterExprOwner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_expr;
    }

    
    public void setExpression(Expression exp)
    {
      exp.exprSetParent(FilterExprIterator.this);
      m_expr = exp;
    }

  }

  
  public void callPredicateVisitors(XPathVisitor visitor)
  {
    m_expr.callVisitors(new filterExprOwner(), visitor);

    super.callPredicateVisitors(visitor);
  }

  
  public boolean deepEquals(Expression expr)
  {
    if (!super.deepEquals(expr))
      return false;

    FilterExprIterator fet = (FilterExprIterator) expr;
    if (!m_expr.deepEquals(fet.m_expr))
      return false;

    return true;
  }

}"
org.apache.xpath.res.XPATHMessages,5,2,1,2,13,4,1,1,4,0.875,115,1.0,0,0.666666667,0.5,0,0,21.6,7,2.6,1,"
package org.apache.xpath.res;

import java.util.ListResourceBundle;

import org.apache.xml.res.XMLMessages;


public class XPATHMessages extends XMLMessages
{
  
  private static ListResourceBundle XPATHBundle = null;

  
  private static final String XPATH_ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";
  
  
  public static final String createXPATHMessage(String msgKey, Object args[])  
  {
    if (XPATHBundle == null)
      XPATHBundle = loadResourceBundle(XPATH_ERROR_RESOURCES);
    
    if (XPATHBundle != null)
    {
      return createXPATHMsg(XPATHBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }

  
  public static final String createXPATHWarning(String msgKey, Object args[])  
  {
    if (XPATHBundle == null)
      XPATHBundle = loadResourceBundle(XPATH_ERROR_RESOURCES);

    if (XPATHBundle != null)
    {
      return createXPATHMsg(XPATHBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }

  
  public static final String createXPATHMsg(ListResourceBundle fResourceBundle,
                                            String msgKey, Object args[])  
  {

    String fmsg = null;
    boolean throwex = false;
    String msg = null;

    if (msgKey != null)
      msg = fResourceBundle.getString(msgKey); 

    if (msg == null)
    {
      msg = fResourceBundle.getString(XPATHErrorResources.BAD_CODE);
      throwex = true;
    }

    if (args != null)
    {
      try
      {

        
        
        
        int n = args.length;

        for (int i = 0; i < n; i++)
        {
          if (null == args[i])
            args[i] = """";
        }

        fmsg = java.text.MessageFormat.format(msg, args);
      }
      catch (Exception e)
      {
        fmsg = fResourceBundle.getString(XPATHErrorResources.FORMAT_FAILED);
        fmsg += "" "" + msg;
      }
    }
    else
      fmsg = msg;

    if (throwex)
    {
      throw new RuntimeException(fmsg);
    }

    return fmsg;
  }

}
"
org.apache.xpath.Expression,31,1,6,103,56,435,95,9,30,0.8,275,1.0,1,0.0,0.190615836,0,0,7.838709677,3,1.2903,1,"
package org.apache.xpath;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;

import org.xml.sax.ContentHandler;


public abstract class Expression implements java.io.Serializable, ExpressionNode, XPathVisitable
{

  
  private ExpressionNode m_parent;

  
  public boolean canTraverseOutsideSubtree()
  {
    return false;
  }
  












  
  public XObject execute(XPathContext xctxt, int currentNode)
          throws javax.xml.transform.TransformerException
  {

    
    return execute(xctxt);
  }

  
  public XObject execute(
          XPathContext xctxt, int currentNode, DTM dtm, int expType)
            throws javax.xml.transform.TransformerException
  {

    
    return execute(xctxt);
  }

  
  public abstract XObject execute(XPathContext xctxt)
    throws javax.xml.transform.TransformerException;

  
  public XObject execute(XPathContext xctxt, boolean destructiveOK)
    throws javax.xml.transform.TransformerException
  {
  	return execute(xctxt);
  }


  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return execute(xctxt).num();
  }

  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return execute(xctxt).bool();
  }

  
  public XMLString xstr(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return execute(xctxt).xstr();
  }

  
  public boolean isNodesetExpr()
  {
    return false;
  }

  
  public int asNode(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
  	DTMIterator iter = execute(xctxt).iter();
    return iter.nextNode();
  }

  
  public DTMIterator asIterator(XPathContext xctxt, int contextNode)
          throws javax.xml.transform.TransformerException
  {

    try
    {
      xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);

      return execute(xctxt).iter();
    }
    finally
    {
      xctxt.popCurrentNodeAndExpression();
    }
  }
  
  
  public DTMIterator asIteratorRaw(XPathContext xctxt, int contextNode)
          throws javax.xml.transform.TransformerException
  {

    try
    {
      xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);

      XNodeSet nodeset = (XNodeSet)execute(xctxt);
      return nodeset.iterRaw();
    }
    finally
    {
      xctxt.popCurrentNodeAndExpression();
    }
  }


  
  public void executeCharsToContentHandler(
          XPathContext xctxt, ContentHandler handler)
            throws javax.xml.transform.TransformerException,
                   org.xml.sax.SAXException
  {

    XObject obj = execute(xctxt);

    obj.dispatchCharactersEvents(handler);
    obj.detach();
  }

  
  public boolean isStableNumber()
  {
    return false;
  }

  
  public abstract void fixupVariables(java.util.Vector vars, int globalsSize);
  
  
  public abstract boolean deepEquals(Expression expr);
  
  
  protected final boolean isSameClass(Expression expr)
  {
  	if(null == expr)
  	  return false;
  	  
  	return (getClass() == expr.getClass());
  }

  
  public void warn(XPathContext xctxt, String msg, Object[] args)
          throws javax.xml.transform.TransformerException
  {

    java.lang.String fmsg = XSLMessages.createXPATHWarning(msg, args);

    if (null != xctxt)
    {
      ErrorListener eh = xctxt.getErrorListener();

      
      eh.warning(new TransformerException(fmsg, xctxt.getSAXLocator()));
    }
  }

  
  public void assertion(boolean b, java.lang.String msg)
  {

    if (!b)
    {
      java.lang.String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ msg });

      throw new RuntimeException(fMsg);
    }
  }

  
  public void error(XPathContext xctxt, String msg, Object[] args)
          throws javax.xml.transform.TransformerException
  {

    java.lang.String fmsg = XSLMessages.createXPATHMessage(msg, args);

    if (null != xctxt)
    {
      ErrorListener eh = xctxt.getErrorListener();
      TransformerException te = new TransformerException(fmsg, this);

      eh.fatalError(te);
    }
  }
  
  
  public ExpressionNode getExpressionOwner()
  {
  	ExpressionNode parent = exprGetParent();
  	while((null != parent) && (parent instanceof Expression))
  		parent = parent.exprGetParent();
  	return parent;
  }
  
  
  
  
  public void exprSetParent(ExpressionNode n)
  {
  	assertion(n != this, ""Can not parent an expression to itself!"");
  	m_parent = n;
  }
  
  public ExpressionNode exprGetParent()
  {
  	return m_parent;
  }

  
  public void exprAddChild(ExpressionNode n, int i)
  {
  	assertion(false, ""exprAddChild method not implemented!"");
  }

  
  public ExpressionNode exprGetChild(int i)
  {
  	return null;
  }

  
  public int exprGetNumChildren()
  {
  	return 0;
  }
  
  

  
  public String getPublicId()
  {
  	if(null == m_parent)
  	  return null;
  	return m_parent.getPublicId();
  }

  
  public String getSystemId()
  {
  	if(null == m_parent)
  	  return null;
  	return m_parent.getSystemId();
  }

  
  public int getLineNumber()
  {
  	if(null == m_parent)
  	  return 0;
  	return m_parent.getLineNumber();
  }

  
  public int getColumnNumber()
  {
  	if(null == m_parent)
  	  return 0;
  	return m_parent.getColumnNumber();
  }
}
"
