name,wmc,dit,noc,cbo,rfc,lcom,ca,ce,npm,lcom3,loc,dam,moa,mfa,cam,ic,cbm,amc,max_cc,avg_cc,bug,code
org.apache.xalan.xsltc.runtime.output.SAXXMLOutput,16,3,0,6,52,112,1,5,11,0.777777778,509,1.0,0,0.74,0.344444444,2,8,30.625,1,0.8125,0,"

package org.apache.xalan.xsltc.runtime.output;

import java.util.Stack;
import java.io.IOException;
import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.Hashtable;
import org.xml.sax.SAXException;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public class SAXXMLOutput extends SAXOutput {

    private static final char[] BEGCDATA = ""<![CDATA["".toCharArray();
    private static final char[] ENDCDATA = ""]]>"".toCharArray();
    private static final char[] CNTCDATA = ""]]]]><![CDATA[>"".toCharArray();

    public SAXXMLOutput(ContentHandler handler, String encoding) 
	throws IOException 
    {
    	super(handler, encoding);
	initCDATA();
	initNamespaces();
    }

    public SAXXMLOutput(ContentHandler handler, LexicalHandler lex, 
        String encoding) throws IOException
    {
        super(handler, lex, encoding);
	initCDATA();
	initNamespaces();
    }

    public void endDocument() throws TransletException {
	try {
	    
            if (_startTagOpen) {
		closeStartTag();
	    }
            else if (_cdataTagOpen) {
		closeCDATA();
	    }

            
            _saxHandler.endDocument();
        } 
	catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    public void startElement(String elementName) throws TransletException {

	try {
            
            if (_startTagOpen) {
		closeStartTag();
	    }
            else if (_cdataTagOpen) {
		closeCDATA();
	    }

            
            if (_firstElement) {
                if (_doctypeSystem != null) {
                    _lexHandler.startDTD(elementName, _doctypePublic,
			_doctypeSystem);
		}
                _firstElement = false;
            }

            _depth++;
            _elementName = elementName;
            _attributes.clear();
            _startTagOpen = true;
	}
        catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    public void attribute(String name, final String value)
        throws TransletException 
    {
	if (_startTagOpen) {
	    final String patchedName = patchName(name);
	    final String localName = getLocalName(patchedName);
	    final String uri = getNamespaceURI(patchedName, false);

	    final int index = (localName == null) ?
		    _attributes.getIndex(name) :    
		    _attributes.getIndex(uri, localName);

	    if (index >= 0) {       
		_attributes.setAttribute(index, uri, localName,
		    patchedName, ""CDATA"", value);
	    }
	    else {
		_attributes.addAttribute(uri, localName, patchedName,
		    ""CDATA"", value);
	    }
	}
    }

    public void characters(char[] ch, int off, int len)
        throws TransletException 
    {


	try {
            
            if (_startTagOpen) {
		closeStartTag();
	    }

            Integer I = (Integer)_cdataStack.peek();
            if ((I.intValue() == _depth) && (!_cdataTagOpen)) {
                startCDATA(ch, off, len);
            }
            else {
                _saxHandler.characters(ch, off, len);
            }
	}
        catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    public void endElement(String elementName) throws TransletException {

        try {
            
            if (_startTagOpen) {
		closeStartTag();
	    }
            else if (_cdataTagOpen) {
		closeCDATA();
	    }

            _saxHandler.endElement(getNamespaceURI(elementName, true),
                getLocalName(elementName), elementName);

            popNamespaces();
            if (((Integer)_cdataStack.peek()).intValue() == _depth){
                _cdataStack.pop();
	    }
            _depth--;

    	} 
	catch (SAXException e) {
            throw new TransletException(e);
    	}
    }

    
    public void namespace(final String prefix, final String uri)
        throws TransletException 
    {
	if (_startTagOpen) {
	    pushNamespace(prefix, uri);
	}
	else {
	    if ((prefix == EMPTYSTRING) && (uri == EMPTYSTRING)) return;
	    BasisLibrary.runTimeError(BasisLibrary.STRAY_NAMESPACE_ERR,
				      prefix, uri);
	}
    }

    
    public void processingInstruction(String target, String data)
        throws TransletException {
        try {
            
            if (_startTagOpen) {
		closeStartTag();
	    }
            else if (_cdataTagOpen) {
		closeCDATA();
	    }

            
            _saxHandler.processingInstruction(target, data);
        }
        catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    protected boolean pushNamespace(String prefix, String uri) {
	try {
	    if (super.pushNamespace(prefix, uri)) {
		_saxHandler.startPrefixMapping(prefix, uri);
		return true;
	    }
	} 
	catch (SAXException e) {
	    
	}
	return false;
    }

    
    protected boolean popNamespace(String prefix) {
	try {
	    if (super.popNamespace(prefix)) {
		_saxHandler.endPrefixMapping(prefix);
		return true;
	    }
	}
	catch (SAXException e) {
	    
	}
	return false;
    }

    
    protected void closeStartTag() throws TransletException {
        try {
            _startTagOpen = false;

	    final String localName = getLocalName(_elementName);
	    final String uri = getNamespaceURI(_elementName, true);

            
            _saxHandler.startElement(uri, localName, _elementName, 
		_attributes);

	    if (_cdata != null) {
		final StringBuffer expandedName = (uri == EMPTYSTRING) ? 
		    new StringBuffer(_elementName) :
		    new StringBuffer(uri).append(':').append(localName);

		if (_cdata.containsKey(expandedName.toString())) {
		    _cdataStack.push(new Integer(_depth));
		}
	    }
        }
        catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    public void startCDATA() throws TransletException {
	try {
	    
	    _saxHandler.characters(BEGCDATA, 0, BEGCDATA.length);
	    _cdataTagOpen = true;
	}
	catch (SAXException e) {
            throw new TransletException(e);
	}
    }

    public void closeCDATA() throws TransletException {
	try {
	    
	    _saxHandler.characters(ENDCDATA, 0, ENDCDATA.length);
	    _cdataTagOpen = false;
	}
	catch (SAXException e) {
            throw new TransletException(e);
	}
    }

    
    private void startCDATA(char[] ch, int off, int len) throws SAXException {
        final int limit = off + len;
        int offset = off;

        
        _saxHandler.characters(BEGCDATA, 0, BEGCDATA.length);

        
        for (int i = offset; i < limit - 2; i++) {
            if (ch[i] == ']' && ch[i + 1] == ']' && ch[i + 2] == '>') {
                _saxHandler.characters(ch, offset, i - offset);
                _saxHandler.characters(CNTCDATA, 0, CNTCDATA.length);
                offset = i+3;
                i += 2; 	
            }
        }

        
        if (offset < limit) {
	    _saxHandler.characters(ch, offset, limit - offset);
	}	    
        _cdataTagOpen = true;
    }
}

"
org.apache.xpath.operations.Operation,12,2,14,23,23,0,17,8,12,0.363636364,149,1.0,2,0.731707317,0.21875,1,7,11.25,5,1.5833,0,"
package org.apache.xpath.operations;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XObject;


public class Operation extends Expression implements ExpressionOwner
{

  
  protected Expression m_left;

  
  protected Expression m_right;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_left.fixupVariables(vars, globalsSize);
    m_right.fixupVariables(vars, globalsSize);
  }


  
  public boolean canTraverseOutsideSubtree()
  {

    if (null != m_left && m_left.canTraverseOutsideSubtree())
      return true;

    if (null != m_right && m_right.canTraverseOutsideSubtree())
      return true;

    return false;
  }

  
  public void setLeftRight(Expression l, Expression r)
  {
    m_left = l;
    m_right = r;
    l.exprSetParent(this);
    r.exprSetParent(this);
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    XObject left = m_left.execute(xctxt, true);
    XObject right = m_right.execute(xctxt, true);

    XObject result = operate(left, right);
    left.detach();
    right.detach();
    return result;
  }

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return null;  
  }

  
  public Expression getLeftOperand(){
    return m_left;
  }

  
  public Expression getRightOperand(){
    return m_right;
  }
  
  class LeftExprOwner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_left;
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(Operation.this);
    	m_left = exp;
    }
  }

  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	if(visitor.visitBinaryOperation(owner, this))
  	{
  		m_left.callVisitors(new LeftExprOwner(), visitor);
  		m_right.callVisitors(this, visitor);
  	}
  }


  
  public Expression getExpression()
  {
    return m_right;
  }


  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_right = exp;
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	if(!m_left.deepEquals(((Operation)expr).m_left))
  		return false;
  		
  	if(!m_right.deepEquals(((Operation)expr).m_right))
  		return false;
  		
  	return true;
  }

}
"
org.apache.xalan.xsltc.runtime.BasisLibrary,53,1,0,34,150,1362,22,15,49,1.001602564,2089,0.375,0,0.0,0.125,0,0,37.96226415,49,4.3962,1,"

package org.apache.xalan.xsltc.runtime;

import java.util.Locale;
import java.util.ResourceBundle;

import java.text.NumberFormat;
import java.text.MessageFormat;
import java.text.FieldPosition;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;

import org.xml.sax.AttributeList;

import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xalan.xsltc.dom.DOMAdapter;
import org.apache.xalan.xsltc.dom.MultiDOM;
import org.apache.xalan.xsltc.dom.AbsoluteIterator;
import org.apache.xalan.xsltc.dom.SingletonIterator;

import org.apache.xalan.xsltc.dom.DOMImpl;
import org.apache.xalan.xsltc.dom.DOMBuilder;
import org.apache.xalan.xsltc.dom.StepIterator;
import org.w3c.dom.NodeList;
import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import javax.xml.parsers.DocumentBuilderFactory; 
import javax.xml.parsers.DocumentBuilder; 
import org.apache.xalan.xsltc.trax.DOM2SAX;


public final class BasisLibrary implements Operators {

    private final static String EMPTYSTRING = """";

    
    public static int countF(NodeIterator iterator) {
	return(iterator.getLast());
    }

    
    public static double sumF(NodeIterator iterator, DOM dom) {
	try {
	    double result = 0.0;
	    int node;
	    while ((node = iterator.next()) != NodeIterator.END) {
		result += Double.parseDouble(dom.getNodeValue(node));
	    }
	    return result;
	}
	catch (NumberFormatException e) {
	    return Double.NaN;
	}
    }

    
    public static String stringF(int node, DOM dom) {
	return dom.getNodeValue(node);
    }

    
    public static String stringF(Object obj, DOM dom) {
	if (obj instanceof NodeIterator) {
	    return dom.getNodeValue(((NodeIterator)obj).reset().next());
	}
	else if (obj instanceof Node) {
	    return dom.getNodeValue(((Node)obj).node);
	}
	else if (obj instanceof DOM) {
	    return ((DOM)obj).getStringValue();
	}
	else {
	    return obj.toString();
	}
    }

    
    public static String stringF(Object obj, int node, DOM dom) {
	if (obj instanceof NodeIterator) {
	    return dom.getNodeValue(((NodeIterator)obj).reset().next());
	}
	else if (obj instanceof Node) {
	    return dom.getNodeValue(((Node)obj).node);
	}
	else if (obj instanceof DOM) {
	    
	    
	    
	    return ((DOM)obj).getStringValue();
	}
	else if (obj instanceof Double) {
	    Double d = (Double)obj;
	    final String result = d.toString();
	    final int length = result.length();
	    if ((result.charAt(length-2)=='.') &&
		(result.charAt(length-1) == '0'))
		return result.substring(0, length-2);
	    else
		return result;
	}
	else {
	    if (obj != null)
		return obj.toString();
	    else
		return stringF(node, dom);
	}
    }

    
    public static double numberF(int node, DOM dom) {
	return stringToReal(dom.getNodeValue(node));
    }

    
    public static double numberF(Object obj, DOM dom) {
	if (obj instanceof Double) {
	    return ((Double) obj).doubleValue();
	}
	else if (obj instanceof Integer) {
	    return ((Integer) obj).doubleValue();
	}
	else if (obj instanceof Boolean) {
	    return  ((Boolean) obj).booleanValue() ? 1.0 : 0.0;
	}
	else if (obj instanceof String) {
	    return stringToReal((String) obj);
	}
	else if (obj instanceof NodeIterator) {
	    NodeIterator iter = (NodeIterator) obj;
	    return stringToReal(dom.getNodeValue(iter.reset().next()));
	}
	else if (obj instanceof Node) {
	    return stringToReal(dom.getNodeValue(((Node) obj).node));
	}
	else if (obj instanceof DOM) {
	    return stringToReal(((DOM) obj).getStringValue());
	}
	else {
	    final String className = obj.getClass().getName();
	    runTimeError(INVALID_ARGUMENT_ERR, className, ""number()"");
	    return 0.0;
	}
    }

    
    public static boolean booleanF(Object obj) {
	if (obj instanceof Double) {
	    final double temp = ((Double) obj).doubleValue();
	    return temp != 0.0 && !Double.isNaN(temp);
	}
	else if (obj instanceof Integer) {
	    return ((Integer) obj).doubleValue() != 0;
	}
	else if (obj instanceof Boolean) {
	    return  ((Boolean) obj).booleanValue();
	}
	else if (obj instanceof String) {
	    return !((String) obj).equals(EMPTYSTRING);
	}
	else if (obj instanceof NodeIterator) {
	    NodeIterator iter = (NodeIterator) obj;
	    return iter.reset().next() != NodeIterator.END;
	}
	else if (obj instanceof Node) {
	    return true;
	}
	else if (obj instanceof DOM) {
	    String temp = ((DOM) obj).getStringValue();
	    return !temp.equals(EMPTYSTRING);
	}
	else {
	    final String className = obj.getClass().getName();
	    runTimeError(INVALID_ARGUMENT_ERR, className, ""number()"");
	}
	return false;
    }

    
    public static String substringF(String value, double start) {
	try {
	    final int strlen = value.length();
	    int istart = (int)Math.round(start) - 1;

	    if (Double.isNaN(start)) return(EMPTYSTRING);
	    if (istart > strlen) return(EMPTYSTRING);
 	    if (istart < 1) istart = 0;

	    return value.substring(istart);
	}
	catch (IndexOutOfBoundsException e) {
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""substring()"");
	    return null;
	}
    }

    
    public static String substringF(String value, double start, double length) {
	try {
	    final int strlen  = value.length();
	    int istart = (int)Math.round(start) - 1;
	    int isum   = istart + (int)Math.round(length);

	    if (Double.isInfinite(length)) isum = Integer.MAX_VALUE;

	    if (Double.isNaN(start) || Double.isNaN(length))
		return(EMPTYSTRING);
	    if (Double.isInfinite(start)) return(EMPTYSTRING);
	    if (istart > strlen) return(EMPTYSTRING);
	    if (isum < 0) return(EMPTYSTRING);
 	    if (istart < 0) istart = 0;

	    if (isum > strlen)
		return value.substring(istart);
	    else
		return value.substring(istart, isum);
	}
	catch (IndexOutOfBoundsException e) {
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""substring()"");
	    return null;
	}
    }

    
    public static String substring_afterF(String value, String substring) {
	final int index = value.indexOf(substring);
	if (index >= 0)
	    return value.substring(index + substring.length());
	else
	    return EMPTYSTRING;
    }

    
    public static String substring_beforeF(String value, String substring) {
	final int index = value.indexOf(substring);
	if (index >= 0)
	    return value.substring(0, index);
	else
	    return EMPTYSTRING;
    }

    
    public static String translateF(String value, String from, String to) {
	final int tol = to.length();
	final int froml = from.length();
	final int valuel = value.length();

	final StringBuffer result = new StringBuffer();
	for (int j, i = 0; i < valuel; i++) {
	    final char ch = value.charAt(i);
	    for (j = 0; j < froml; j++) {
		if (ch == from.charAt(j)) {
		    if (j < tol)
			result.append(to.charAt(j));
		    break;
		}
	    }	
	    if (j == froml)
		result.append(ch);
	}
	return result.toString();
    }

    
    public static String normalize_spaceF(int node, DOM dom) {
	return normalize_spaceF(dom.getNodeValue(node));
    }

    
    public static String normalize_spaceF(String value) {
	int i = 0, n = value.length();
	StringBuffer result = new StringBuffer();

	while (i < n && isWhiteSpace(value.charAt(i)))
	    i++;

	while (true) {
	    while (i < n && !isWhiteSpace(value.charAt(i))) {
		result.append(value.charAt(i++));
	    }
	    if (i == n)
		break;
	    while (i < n && isWhiteSpace(value.charAt(i))) {
		i++;
	    }
	    if (i < n)
		result.append(' ');
	}
	return result.toString();
    }

    
    public static String generate_idF(int node) {
	if (node > 0)
	    
	    return ""N"" + node;
	else
	    
	    return EMPTYSTRING;
    }
    
    
    public static String getLocalName(String value) {
	int idx = value.lastIndexOf(':');
	if (idx >= 0) value = value.substring(idx + 1);
	idx = value.lastIndexOf('@');
	if (idx >= 0) value = value.substring(idx + 1);
	return(value);
    }

    
    public static void unresolved_externalF(String name) {
	runTimeError(EXTERNAL_FUNC_ERR, name);
    }

    
    public static String namespace_uriF(NodeIterator iter, DOM dom) {
	return namespace_uriF(iter.next(), dom);
    }

    
    public static String system_propertyF(String name) {
	if (name.equals(""xsl:version""))
	    return(""1.0"");
	if (name.equals(""xsl:vendor""))
	    return(""Apache Software Foundation (Xalan XSLTC)"");
	if (name.equals(""xsl:vendor-url""))
	    return(""http:
	
	runTimeError(INVALID_ARGUMENT_ERR, name, ""system-property()"");
	return(EMPTYSTRING);
    }

    
    public static String namespace_uriF(int node, DOM dom) {
	final String value = dom.getNodeName(node);
	final int colon = value.lastIndexOf(':');
	if (colon >= 0)
	    return value.substring(0, colon);
	else
	    return EMPTYSTRING;
    }

    
    public static NodeIterator nodesetF(Object obj) {
	if (obj instanceof DOM) {
	   final DOMAdapter adapter = (DOMAdapter) obj;
	   return new SingletonIterator(
		  DOM.ROOTNODE | adapter.getMultiDOMMask(), true);
	}
        else if (obj instanceof NodeIterator) {
	   return (NodeIterator) obj;
        }
        else {
	    final String className = obj.getClass().getName();
	    runTimeError(DATA_CONVERSION_ERR, ""node-set"", className);
	    return null;
        }
    }

    

    private static boolean isWhiteSpace(char ch) {
	return ch == ' ' || ch == '	' || ch == '
' || ch == '
';
    }

    private static boolean compareStrings(String lstring, String rstring,
					  int op, DOM dom) {
	switch (op) {
	case EQ:
	    return lstring.equals(rstring);

	case NE:
	    return !lstring.equals(rstring);

	case GT:
	    return numberF(lstring, dom) > numberF(rstring, dom);

	case LT:
	    return numberF(lstring, dom) < numberF(rstring, dom);

	case GE:
	    return numberF(lstring, dom) >= numberF(rstring, dom);

	case LE:
	    return numberF(lstring, dom) <= numberF(rstring, dom);

	default:
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""compare()"");
	    return false;
	}
    }

    
    public static boolean compare(NodeIterator left, NodeIterator right,
				  int op, int node, DOM dom) {
	int lnode;
	left.reset();
	
	while ((lnode = left.next()) != NodeIterator.END) {
	    final String lvalue = dom.getNodeValue(lnode);
	    
	    int rnode;
	    right.reset();
	    while ((rnode = right.next()) != NodeIterator.END) {
		if (compareStrings(lvalue, dom.getNodeValue(rnode), op, dom)) {
		    return true;
		}
	    }
	} 
	return false;
    }

    
    public static boolean compare(int node, NodeIterator nodeSet,
				  int op, DOM dom) {
	final String lvalue = dom.getNodeValue(node);
	int rnode;
	
	while ((rnode = nodeSet.next()) != NodeIterator.END) {
	    if (compareStrings(lvalue, dom.getNodeValue(rnode), op, dom)) {
		return true;
	    }
	} 
	return false;
    }

    public static boolean compare(int node, NodeIterator iterator,
				  int op, int dummy, DOM dom) {
	

	int rnode;
	String value;

	switch(op) {
	case EQ:
	    
	    value = dom.getNodeValue(node);
	    while ((rnode = iterator.next()) != NodeIterator.END)
		if (value.equals(dom.getNodeValue(rnode))) return true;
	    
	    break;
	case NE:
	    value = dom.getNodeValue(node);
	    while ((rnode = iterator.next()) != NodeIterator.END)
		if (!value.equals(dom.getNodeValue(rnode))) return true;
	    
	    break;
	case LT:
	    
	    while ((rnode = iterator.next()) != NodeIterator.END)
		if (rnode > node) return true;
	    break;
	case GT:
	    
	    while ((rnode = iterator.next()) != NodeIterator.END)
		if (rnode < node) return true;
	    break;
	} 
	return(false);
    }

    public static boolean compare(NodeIterator left, final double rnumber,
				  final int op, final int node, DOM dom) {
	return(compare(left,rnumber,op,dom));
    }

    
    public static boolean compare(NodeIterator left, final double rnumber,
				  final int op, DOM dom) {
	int node;
	

	switch (op) {
	case EQ:
	    while ((node = left.next()) != NodeIterator.END) {
		if (numberF(dom.getNodeValue(node), dom) == rnumber)
		    return true;
	    }
	    break;

	case NE:
	    while ((node = left.next()) != NodeIterator.END) {
		if (numberF(dom.getNodeValue(node), dom) != rnumber)
		    return true;
	    }
	    break;

	case GT:
	    while ((node = left.next()) != NodeIterator.END) {
		if (numberF(dom.getNodeValue(node), dom) > rnumber)
		    return true;
	    }
	    break;

	case LT:
	    while ((node = left.next()) != NodeIterator.END) {
		if (numberF(dom.getNodeValue(node), dom) < rnumber)
		    return true;
	    }
	    break;

	case GE:
	    while ((node = left.next()) != NodeIterator.END) {
		if (numberF(dom.getNodeValue(node), dom) >= rnumber)
		    return true;
	    }
	    break;

	case LE:
	    while ((node = left.next()) != NodeIterator.END) {
		if (numberF(dom.getNodeValue(node), dom) <= rnumber)
		    return true;
	    }
	    break;

	default:
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""compare()"");
	}

	return false;
    }

    
    public static boolean compare(NodeIterator left, final String rstring,
				  int op, DOM dom) {
	int node;
	
	while ((node = left.next()) != NodeIterator.END) {
	    if (compareStrings(dom.getNodeValue(node), rstring, op, dom)) {
		return true;
	    }
	}
	return false;
    }

    public static boolean compare(NodeIterator left, final String rstring,
				  int op, int node, DOM dom) {
	
	if (compareStrings(dom.getNodeValue(node), rstring, op, dom)) {
	    return true;
	}
	else {
	    return false;
	}
    }

    public static boolean compare(Object left, Object right,
				  int op, int node, DOM dom) { 
	boolean result = false;
	boolean hasSimpleArgs = hasSimpleType(left) && hasSimpleType(right);

	if (op != EQ && op != NE) {
	    
	    if (left instanceof Node || right instanceof Node) {
		if (left instanceof Boolean) {
		    right = new Boolean(booleanF(right));
		    hasSimpleArgs = true;
		}
		if (right instanceof Boolean) {
		    left = new Boolean(booleanF(left));
		    hasSimpleArgs = true;
		}
	    }

	    if (hasSimpleArgs) {
		switch (op) {
		case GT:
		    return numberF(left, dom) > numberF(right, dom);
		    
		case LT:
		    return numberF(left, dom) < numberF(right, dom);
		    
		case GE:
		    return numberF(left, dom) >= numberF(right, dom);
		    
		case LE:
		    return numberF(left, dom) <= numberF(right, dom);
		    
		default:
		    runTimeError(RUN_TIME_INTERNAL_ERR, ""compare()"");
		}
	    }
	    
	}

	if (hasSimpleArgs) {
	    if (left instanceof Boolean || right instanceof Boolean) {
		result = booleanF(left) == booleanF(right);
	    }
	    else if (left instanceof Double || right instanceof Double ||
		     left instanceof Integer || right instanceof Integer) {
		result = numberF(left, dom) == numberF(right, dom);
	    }
	    else { 
		result = stringF(left, dom).equals(stringF(right, dom));
	    }

	    if (op == Operators.NE) {
		result = !result;
	    }
	}
	else {
	    if (left instanceof Node) {
		left = new SingletonIterator(((Node)left).node);
	    }
	    if (right instanceof Node) {
		right = new SingletonIterator(((Node)right).node);
	    }

	    if (hasSimpleType(left) ||
		left instanceof DOM && right instanceof NodeIterator) {
		
		final Object temp = right; right = left; left = temp;
	    }

	    if (left instanceof DOM) {
		if (right instanceof Boolean) {
		    result = ((Boolean)right).booleanValue();
		    return result == (op == Operators.EQ);
		}

		final String sleft = ((DOM)left).getStringValue();

		if (right instanceof Number) {
		    result = ((Number)right).doubleValue() ==
			stringToReal(sleft);
		}
		else if (right instanceof String) {
		    result = sleft.equals((String)right);
		}
		else if (right instanceof DOM) {
		    result = sleft.equals(((DOM)right).getStringValue());
		}

		if (op == Operators.NE) {
		    result = !result;
		}
		return result;
	    }

	    

	    NodeIterator iter = ((NodeIterator)left).reset();

	    if (right instanceof NodeIterator) {
		result = compare(iter, (NodeIterator)right, op, node, dom);
	    }
	    else if (right instanceof String) {
		
		result = compare(iter, (String)right, op, dom);
	    }	
	    else if (right instanceof Number) {
		final double temp = ((Number)right).doubleValue();
		result = compare(iter, temp, op, dom);
	    }
	    else if (right instanceof Boolean) {
		boolean temp = ((Boolean)right).booleanValue();
		result = (iter.reset().next() != NodeIterator.END) == temp;
	    }
	    else if (right instanceof DOM) {
		result = compare(iter, ((DOM)right).getStringValue(),
				 op, dom);
	    }
	    else if (right == null) {
		return(false);
	    }
	    else {
		final String className = right.getClass().getName();
		runTimeError(INVALID_ARGUMENT_ERR, className, ""compare()"");
	    }
	}
	return result;
    }

    
    public static boolean testLanguage(String testLang, DOM dom, int node) {
	
	String nodeLang = dom.getLanguage(node);
	if (nodeLang == null)
	    return(false);
	else
	    nodeLang = nodeLang.toLowerCase();

	
	testLang = testLang.toLowerCase();
	if (testLang.length() == 2) {
	    return(nodeLang.startsWith(testLang));
	}
	else {
	    return(nodeLang.equals(testLang));
	}
    }

    private static boolean hasSimpleType(Object obj) {
	return obj instanceof Boolean || obj instanceof Double ||
	    obj instanceof Integer || obj instanceof String ||
	    obj instanceof Node || obj instanceof DOM; 
    }

    
    public static double stringToReal(String s) {
	try {
	    return Double.valueOf(s).doubleValue();
	}
	catch (NumberFormatException e) {
	    return Double.NaN;
	}
    }

    
    public static int stringToInt(String s) {
	try {
	    return Integer.parseInt(s);
	}
	catch (NumberFormatException e) {
	    return(-1); 
	}
    }

    private static double lowerBounds = 0.001;
    private static double upperBounds = 10000000;
    private static DecimalFormat defaultFormatter;
    private static String defaultPattern = """";

    static {
	NumberFormat f = NumberFormat.getInstance(Locale.getDefault());
	
	
	f.setMaximumFractionDigits(Integer.MAX_VALUE);
	defaultFormatter = (f instanceof DecimalFormat) ?
	    (DecimalFormat) f : new DecimalFormat();
	defaultFormatter.setGroupingUsed(false);
    }

    
    public static String realToString(double d) {
	final double m = Math.abs(d);
	if ((m >= lowerBounds) && (m < upperBounds)) {
	    final String result = Double.toString(d);
	    final int length = result.length();
	    
	    if ((result.charAt(length-2) == '.') &&
		(result.charAt(length-1) == '0'))
		return result.substring(0, length-2);
	    else
		return result;
	}
	else {
	    if (Double.isNaN(d) || Double.isInfinite(d))
		return(Double.toString(d));
	    return formatNumber(d, defaultPattern, defaultFormatter);
	}
    }

    
    public static int realToInt(double d) {
	return (int)d;
    }

    
    private static FieldPosition _fieldPosition = new FieldPosition(0);

    public static String formatNumber(double number, String pattern,
				      DecimalFormat formatter) {
	try {
	    StringBuffer result = new StringBuffer();
	    if (pattern != defaultPattern) {
		formatter.applyLocalizedPattern(pattern);
	    }

	    
 	    
	    
	    
	    
	    
	    
	    String localizedPattern = formatter.toPattern();
	    int index = localizedPattern.indexOf('.');
	    if ( index >= 1  && localizedPattern.charAt(index-1) == '#' ) {
		
		StringBuffer newpattern = new StringBuffer();
		newpattern.append(localizedPattern.substring(0, index-1));
                newpattern.append(""0"");
                newpattern.append(localizedPattern.substring(index));
		formatter.applyLocalizedPattern(newpattern.toString());
	    } else if (index == 0) {
                
                StringBuffer newpattern = new StringBuffer();
                newpattern.append(""0"");
                newpattern.append(localizedPattern);
		formatter.applyLocalizedPattern(newpattern.toString());
            }

	    formatter.format(number, result, _fieldPosition);
	    return(result.toString());
	}
	catch (IllegalArgumentException e) {
	    runTimeError(FORMAT_NUMBER_ERR, Double.toString(number), pattern);
	    return(EMPTYSTRING);
	}
    }
    
    
    public static NodeIterator referenceToNodeSet(Object obj) {
	
	if (obj instanceof Node) {
	    return(new SingletonIterator(((Node)obj).node));
	}
	
	else if (obj instanceof NodeIterator) {
	    return(((NodeIterator)obj).cloneIterator());
	}
	else {
	    final String className = obj.getClass().getName();
	    runTimeError(DATA_CONVERSION_ERR, ""reference"", className);
	    return null;
	}
    }

    
    public static NodeIterator nodeList2Iterator(org.w3c.dom.NodeList nodeList,
	Translet translet, DOM dom) 
    {
	int size = nodeList.getLength();

	
	DocumentBuilderFactory dfac = DocumentBuilderFactory.newInstance();
	DocumentBuilder docbldr = null;
	try {
	    docbldr = dfac.newDocumentBuilder();
	} catch (javax.xml.parsers.ParserConfigurationException e) {
	    runTimeError(RUN_TIME_INTERNAL_ERR, e.getMessage());
            return null;

	}
	
	Document doc = docbldr.newDocument();	
        org.w3c.dom.Node topElementNode = 
            doc.appendChild(doc.createElementNS("""", ""__top__""));

	
	for (int i=0; i<size; i++){
	    org.w3c.dom.Node curr = nodeList.item(i);
	    int nodeType = curr.getNodeType();
	    if (nodeType == org.w3c.dom.Node.DOCUMENT_NODE) {
		
		continue;
	    }
	    String value = null;
	    try {
	        value = curr.getNodeValue();
	    } catch (DOMException ex) {
		runTimeError(RUN_TIME_INTERNAL_ERR, ex.getMessage());
                return null;
	    }
	    String namespaceURI = curr.getNamespaceURI();
	    String nodeName = curr.getNodeName();
	    org.w3c.dom.Node newNode = null; 
	    switch (nodeType){
		case org.w3c.dom.Node.ATTRIBUTE_NODE: 
		     newNode = doc.createAttributeNS(namespaceURI,
			nodeName);
                     break;
		case org.w3c.dom.Node.CDATA_SECTION_NODE: 
		     newNode = doc.createCDATASection(value);
                     break;
		case org.w3c.dom.Node.COMMENT_NODE: 
		     newNode = doc.createComment(value);
                     break;
		case org.w3c.dom.Node.DOCUMENT_FRAGMENT_NODE: 
		     newNode = doc.createDocumentFragment();
                     break;
		case org.w3c.dom.Node.DOCUMENT_TYPE_NODE: 
		     
                     break;
		case org.w3c.dom.Node.ELEMENT_NODE: 
		     newNode = doc.createElementNS(namespaceURI, nodeName);
		     break;
		case org.w3c.dom.Node.ENTITY_NODE: 
		     
                     break;
		case org.w3c.dom.Node.ENTITY_REFERENCE_NODE: 
		     newNode = doc.createEntityReference(nodeName);
		     break;
		case org.w3c.dom.Node.NOTATION_NODE: 
		     
		     break;
		case org.w3c.dom.Node.PROCESSING_INSTRUCTION_NODE: 
		     newNode = doc.createProcessingInstruction(nodeName,
			value);
		     break;
		case org.w3c.dom.Node.TEXT_NODE: 
		     newNode = doc.createTextNode(value);
		     break;
	    }
	    try {
	        topElementNode.appendChild(newNode);
	    } catch (DOMException e) {
		runTimeError(RUN_TIME_INTERNAL_ERR, e.getMessage());
		return null;
	    }
	}
	
	DOMImpl idom = new DOMImpl();
	final DOM2SAX dom2sax = new DOM2SAX(doc);
	final DOMBuilder domBuilder = idom.getBuilder();
	dom2sax.setContentHandler(domBuilder);
	try {
	    dom2sax.parse(); 
	} 
        catch (java.io.IOException e){
	    runTimeError(RUN_TIME_INTERNAL_ERR, e.getMessage());
            return null;
	}
        catch (org.xml.sax.SAXException e){
	    runTimeError(RUN_TIME_INTERNAL_ERR, e.getMessage());
            return null;
	}
	

	if (dom instanceof MultiDOM) {
            final MultiDOM multiDOM = (MultiDOM) dom;

	    
	    DOMAdapter domAdapter = new DOMAdapter(idom, 
                translet.getNamesArray(),
		translet.getNamespaceArray());
            multiDOM.addDOMAdapter(domAdapter);

	    NodeIterator iter1 = multiDOM.getAxisIterator(Axis.CHILD);
	    NodeIterator iter2 = multiDOM.getAxisIterator(Axis.CHILD);
            NodeIterator iter = new AbsoluteIterator(
                new StepIterator(iter1, iter2));

 	    iter.setStartNode(DOM.ROOTNODE | domAdapter.getMultiDOMMask());
	    return iter;
	}
        else {
	    runTimeError(RUN_TIME_INTERNAL_ERR, ""nodeList2Iterator()"");
	    return null;
        }
    }

    
    public static DOM referenceToResultTree(Object obj) {
	try {
	    return ((DOM) obj);
	}
	catch (IllegalArgumentException e) {
	    final String className = obj.getClass().getName();
	    runTimeError(DATA_CONVERSION_ERR, ""reference"", className);
	    return null;
	}
    }

    
    public static NodeIterator getSingleNode(NodeIterator iterator) {
	int node = iterator.next();
	return(new SingletonIterator(node));
    }

    
    private static char[] _characterArray = new char[32];

    public static void copy(Object obj,
			    TransletOutputHandler handler,
			    int node,
			    DOM dom) {
	try {
	    if (obj instanceof NodeIterator) {
		NodeIterator iter = (NodeIterator) obj;
		dom.copy(iter.reset(), handler);
	    }
	    else if (obj instanceof Node) {
		dom.copy(((Node) obj).node, handler);
	    }
	    else if (obj instanceof DOM) {
		((DOM)obj).copy(1, handler);
	    }
	    else {
		String string = obj.toString();		
		final int length = string.length();
		if (length > _characterArray.length)
		    _characterArray = new char[length];
		string.getChars(0, length, _characterArray, 0);
		handler.characters(_characterArray, 0, length);
	    }
	}
	catch (TransletException e) {
	    runTimeError(RUN_TIME_COPY_ERR);
	}
    }
    
    
    public static String getPrefix(String qname) {
	final int index = qname.indexOf(':');
	return (index > 0) ? qname.substring(0, index) : null;
    }

    
    private static int prefixIndex = 0;
    public static String generatePrefix() {
	return (""ns"" + prefixIndex++);
    }

    
    public static String makeQName(String localName, String prefix) {
	return (new StringBuffer(prefix).append(':').append(localName).toString());
    }

    public static final int RUN_TIME_INTERNAL_ERR   = 0;
    public static final int RUN_TIME_COPY_ERR       = 1;
    public static final int DATA_CONVERSION_ERR     = 2;
    public static final int EXTERNAL_FUNC_ERR       = 3;
    public static final int EQUALITY_EXPR_ERR       = 4;
    public static final int INVALID_ARGUMENT_ERR    = 5;
    public static final int FORMAT_NUMBER_ERR       = 6;
    public static final int ITERATOR_CLONE_ERR      = 7;
    public static final int AXIS_SUPPORT_ERR        = 8;
    public static final int TYPED_AXIS_SUPPORT_ERR  = 9;
    public static final int STRAY_ATTRIBUTE_ERR     = 10; 
    public static final int STRAY_NAMESPACE_ERR     = 11;
    public static final int NAMESPACE_PREFIX_ERR    = 12;
    public static final int DOM_ADAPTER_INIT_ERR    = 13;

    
    
    private static String[] _errorMessages;
    
    public final static String ERROR_MESSAGES_KEY = ""error-messages"";

    static {
	String resource = ""org.apache.xalan.xsltc.runtime.ErrorMessages"";
	ResourceBundle bundle = ResourceBundle.getBundle(resource);
	_errorMessages  = bundle.getStringArray(ERROR_MESSAGES_KEY);
    }

    
    public static void runTimeError(int code) {
	throw new RuntimeException(_errorMessages[code]);
    }

    public static void runTimeError(int code, Object[] args) {
	final String message = MessageFormat.format(_errorMessages[code],args);
	throw new RuntimeException(message);
    }

    public static void runTimeError(int code, Object arg0) {
	runTimeError(code, new Object[]{ arg0 } );
    }

    public static void runTimeError(int code, Object arg0, Object arg1) {
	runTimeError(code, new Object[]{ arg0, arg1 } );
    }

    public static void consoleOutput(String msg) {
	System.out.println(msg);
    }

    
    public static String replace(String base, char ch, String str) {
	return (base.indexOf(ch) < 0) ? base : 
	    replace(base, String.valueOf(ch), new String[] { str });
    }

    public static String replace(String base, String delim, String[] str) {
	final int len = base.length();
	final StringBuffer result = new StringBuffer();

	for (int i = 0; i < len; i++) {
	    final char ch = base.charAt(i);
	    final int k = delim.indexOf(ch);

	    if (k >= 0) {
		result.append(str[k]);
	    }
	    else {
		result.append(ch);
	    }
	}
	return result.toString();
    }

    
}
"
org.apache.xpath.objects.XString,49,3,2,43,100,1176,34,12,46,1.0,743,0.0,1,0.606837607,0.122222222,3,21,14.14285714,16,1.8571,0,"
package org.apache.xpath.objects;


import java.util.Locale;

import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;


public class XString extends XObject implements XMLString
{

  
  public static XString EMPTYSTRING = new XString("""");

  
  protected XString(Object val)
  {
    super(val);
  }

  
  public XString(String val)
  {
    super(val);
  }

  
  public int getType()
  {
    return CLASS_STRING;
  }

  
  public String getTypeString()
  {
    return ""#STRING"";
  }

  
  public boolean hasString()
  {
    return true;
  }

  
  public double num()
  {
    return toDouble();
  }

  
  public double toDouble()
  {
    int end = length();
    
    if(0 == end)
      return Double.NaN;

    double result = 0.0;
    int start = 0;
    int punctPos = end-1;

    
    for (int i = start; i < end; i++)
    {
      char c = charAt(i);

      if (!XMLCharacterRecognizer.isWhiteSpace(c))
      {
        break;
      }
      else
        start++;
    }

    double sign = 1.0;

    if (start < end && charAt(start) == '-')
    {
      sign = -1.0;

      start++;
    }

    int digitsFound = 0;

    for (int i = start; i < end; i++)  
    {
      char c = charAt(i);

      if (c != '.')
      {
        if (XMLCharacterRecognizer.isWhiteSpace(c))
          break;
        else if (Character.isDigit(c))
        {
          result = result * 10.0 + (c - 0x30);

          digitsFound++;
        }
        else
        {
          return Double.NaN;
        }
      }
      else
      {
        punctPos = i;

        break;
      }
    }

    if (charAt(punctPos) == '.')  
    {
      double fractPart = 0.0;

      for (int i = end - 1; i > punctPos; i--)
      {
        char c = charAt(i);

        if (XMLCharacterRecognizer.isWhiteSpace(c))
          break;
        else if (Character.isDigit(c))
        {
          fractPart = fractPart / 10.0 + (c - 0x30);

          digitsFound++;
        }
        else
        {
          return Double.NaN;
        }
      }

      result += fractPart / 10.0;
    }

    if (0 == digitsFound)
      return Double.NaN;

    return result * sign;
  }

  
  public boolean bool()
  {
    return str().length() > 0;
  }

  
  public XMLString xstr()
  {
    return this;
  }

  
  public String str()
  {
    return (null != m_obj) ? ((String) m_obj) : """";
  }

  
  public int rtf(XPathContext support)
  {

    DTM frag = support.createDocumentFragment();

    frag.appendTextChild(str());

    return frag.getDocument();
  }

  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {

    String str = str();

    ch.characters(str.toCharArray(), 0, str.length());
  }

  
  public void dispatchAsComment(org.xml.sax.ext.LexicalHandler lh)
          throws org.xml.sax.SAXException
  {

    String str = str();

    lh.comment(str.toCharArray(), 0, str.length());
  }

  
  public int length()
  {
    return str().length();
  }

  
  public char charAt(int index)
  {
    return str().charAt(index);
  }

  
  public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)
  {
    str().getChars(srcBegin, srcEnd, dst, dstBegin);
  }

  
  public boolean equals(XObject obj2)
  {

    
    
    
    int t = obj2.getType();
    try
    {
	    if (XObject.CLASS_NODESET == t)
	      return obj2.equals(this);
	    
	    
	    
	    else if(XObject.CLASS_BOOLEAN == t)
	    	return obj2.bool() == bool();
	    
	    
	    else if(XObject.CLASS_NUMBER == t)
	    	return obj2.num() == num();
    }
    catch(javax.xml.transform.TransformerException te)
    {
    	throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }

    
    
    return xstr().equals(obj2.xstr());
  }

  
  public boolean equals(XMLString obj2)
  {

    if (!obj2.hasString())
      return obj2.equals(this);
    else
      return str().equals(obj2.toString());
  }

  
  public boolean equals(Object obj2)
  {

    if (null == obj2)
      return false;

      
      
      
    else if (obj2 instanceof XNodeSet)
      return obj2.equals(this);
    else if(obj2 instanceof XNumber)
    	return obj2.equals(this);
    else
      return str().equals(obj2.toString());
  }

  
  public boolean equalsIgnoreCase(String anotherString)
  {
    return str().equalsIgnoreCase(anotherString);
  }

  
  public int compareTo(XMLString xstr)
  {

    int len1 = this.length();
    int len2 = xstr.length();
    int n = Math.min(len1, len2);
    int i = 0;
    int j = 0;

    while (n-- != 0)
    {
      char c1 = this.charAt(i);
      char c2 = xstr.charAt(j);

      if (c1 != c2)
      {
        return c1 - c2;
      }

      i++;
      j++;
    }

    return len1 - len2;
  }

  
  public int compareToIgnoreCase(XMLString str)
  {
    
    
    
    
    
    
    
    
    throw new org.apache.xml.utils.WrappedRuntimeException(
      new java.lang.NoSuchMethodException(
        ""Java 1.2 method, not yet implemented""));
  }

  
  public boolean startsWith(String prefix, int toffset)
  {
    return str().startsWith(prefix, toffset);
  }

  
  public boolean startsWith(String prefix)
  {
    return startsWith(prefix, 0);
  }

  
  public boolean startsWith(XMLString prefix, int toffset)
  {

    int to = toffset;
    int tlim = this.length();
    int po = 0;
    int pc = prefix.length();

    
    if ((toffset < 0) || (toffset > tlim - pc))
    {
      return false;
    }

    while (--pc >= 0)
    {
      if (this.charAt(to) != prefix.charAt(po))
      {
        return false;
      }

      to++;
      po++;
    }

    return true;
  }

  
  public boolean startsWith(XMLString prefix)
  {
    return startsWith(prefix, 0);
  }

  
  public boolean endsWith(String suffix)
  {
    return str().endsWith(suffix);
  }

  
  public int hashCode()
  {
    return str().hashCode();
  }

  
  public int indexOf(int ch)
  {
    return str().indexOf(ch);
  }

  
  public int indexOf(int ch, int fromIndex)
  {
    return str().indexOf(ch, fromIndex);
  }

  
  public int lastIndexOf(int ch)
  {
    return str().lastIndexOf(ch);
  }

  
  public int lastIndexOf(int ch, int fromIndex)
  {
    return str().lastIndexOf(ch, fromIndex);
  }

  
  public int indexOf(String str)
  {
    return str().indexOf(str);
  }

  
  public int indexOf(XMLString str)
  {
    return str().indexOf(str.toString());
  }

  
  public int indexOf(String str, int fromIndex)
  {
    return str().indexOf(str, fromIndex);
  }

  
  public int lastIndexOf(String str)
  {
    return str().lastIndexOf(str);
  }

  
  public int lastIndexOf(String str, int fromIndex)
  {
    return str().lastIndexOf(str, fromIndex);
  }

  
  public XMLString substring(int beginIndex)
  {
    return new XString(str().substring(beginIndex));
  }

  
  public XMLString substring(int beginIndex, int endIndex)
  {
    return new XString(str().substring(beginIndex, endIndex));
  }

  
  public XMLString concat(String str)
  {

    
    return new XString(str().concat(str));
  }

  
  public XMLString toLowerCase(Locale locale)
  {
    return new XString(str().toLowerCase(locale));
  }

  
  public XMLString toLowerCase()
  {
    return new XString(str().toLowerCase());
  }

  
  public XMLString toUpperCase(Locale locale)
  {
    return new XString(str().toUpperCase(locale));
  }

  
  public XMLString toUpperCase()
  {
    return new XString(str().toUpperCase());
  }

  
  public XMLString trim()
  {
    return new XString(str().trim());
  }

  
  private static boolean isSpace(char ch)
  {
    return XMLCharacterRecognizer.isWhiteSpace(ch);  
  }

  
  public XMLString fixWhiteSpace(boolean trimHead, boolean trimTail,
                                 boolean doublePunctuationSpaces)
  {

    
    int len = this.length();
    char[] buf = new char[len];

    this.getChars(0, len, buf, 0);

    boolean edit = false;
    int s;

    for (s = 0; s < len; s++)
    {
      if (isSpace(buf[s]))
      {
        break;
      }
    }

    
    int d = s;
    boolean pres = false;

    for (; s < len; s++)
    {
      char c = buf[s];

      if (isSpace(c))
      {
        if (!pres)
        {
          if (' ' != c)
          {
            edit = true;
          }

          buf[d++] = ' ';

          if (doublePunctuationSpaces && (s != 0))
          {
            char prevChar = buf[s - 1];

            if (!((prevChar == '.') || (prevChar == '!')
                  || (prevChar == '?')))
            {
              pres = true;
            }
          }
          else
          {
            pres = true;
          }
        }
        else
        {
          edit = true;
          pres = true;
        }
      }
      else
      {
        buf[d++] = c;
        pres = false;
      }
    }

    if (trimTail && 1 <= d && ' ' == buf[d - 1])
    {
      edit = true;

      d--;
    }

    int start = 0;

    if (trimHead && 0 < d && ' ' == buf[0])
    {
      edit = true;

      start++;
    }

    XMLStringFactory xsf = XMLStringFactoryImpl.getFactory();

    return edit ? xsf.newstr(new String(buf, start, d - start)) : this;
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	visitor.visitStringLiteral(owner, this);
  }

}
"
org.apache.xalan.xsltc.StripFilter,1,1,0,5,1,0,5,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

import org.apache.xalan.xsltc.DOM;

public interface StripFilter {
    public boolean stripSpace(DOM dom, int node, int type);
}
"
org.apache.xalan.serialize.Serializer,9,1,0,8,9,36,7,1,9,2.0,9,0.0,0,0.0,0.333333333,0,0,0.0,1,1.0,0,"
package org.apache.xalan.serialize;

import java.io.Writer;
import java.io.OutputStream;
import java.io.IOException;
import java.util.Properties;

import org.xml.sax.ContentHandler;


public interface Serializer
{

  
  public void setOutputStream(OutputStream output);

  
  public OutputStream getOutputStream();

  
  public void setWriter(Writer writer);

  
  public Writer getWriter();

  
  public void setOutputFormat(Properties format);

  
  public Properties getOutputFormat();

  
  public ContentHandler asContentHandler() throws IOException;

  
  public DOMSerializer asDOMSerializer() throws IOException;

  
  public boolean reset();
}
"
org.apache.xalan.templates.ElemExsltFunction,7,4,0,18,28,15,4,14,6,0.5,166,1.0,0,0.97309417,0.314285714,4,7,22.57142857,1,0.8571,1,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.Expression;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xpath.objects.XRTreeFragSelectWrapper;
import org.apache.xml.utils.QName;
import org.apache.xalan.trace.SelectionEvent;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import org.apache.xalan.extensions.ExtensionsTable;

import javax.xml.transform.TransformerException;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.apache.xalan.extensions.ExtensionNamespaceSupport;
import org.apache.xalan.extensions.ExtensionHandlerExsltFunction;



public class ElemExsltFunction extends ElemTemplate
{
  
  
  public int getXSLToken()
  {
    return Constants.EXSLT_ELEMNAME_FUNCTION;
  }

    
  public String getNodeName()
  {
    return Constants.EXSLT_ELEMNAME_FUNCTION_STRING;
  }
  
  public void execute(TransformerImpl transformer, XObject[] args)
          throws TransformerException
  {
    XPathContext xctxt = transformer.getXPathContext();
    VariableStack vars = xctxt.getVarStack();
    
    
    NodeList children = this.getChildNodes();
    int numparams =0;
    for (int i = 0; i < args.length; i ++)
    {
      Node child = children.item(i);
      if (children.item(i) instanceof ElemParam)
      {
        numparams++;
        ElemParam param = (ElemParam)children.item(i);
        vars.setLocalVariable (param.m_index, args[i]);
      }
    }
    if (numparams < args.length)
      throw new TransformerException (""function called with too many args"");

    
    
    
    
    
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
    
    
    
    vars.setLocalVariable(_resultIndex, null);
    transformer.executeChildTemplates(this, true); 

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
    
    
    
    
  }
  
  
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    
    setResultIndex(cstate.addVariableName
      (new QName(Constants.S_EXSLT_COMMON_URL, ""result"")));
    
    
    String namespace = getName().getNamespace();
    String handlerClass = ""org.apache.xalan.extensions.ExtensionHandlerExsltFunction"";    
    Object[] args ={namespace, sroot};
    ExtensionNamespaceSupport extNsSpt = 
                         new ExtensionNamespaceSupport(namespace, handlerClass, args);
    sroot.getExtensionNamespacesManager().registerExtension(extNsSpt);
    
    
    if (!(namespace.equals(Constants.S_EXSLT_FUNCTIONS_URL)))
    {
      namespace = Constants.S_EXSLT_FUNCTIONS_URL;
      args = new Object[]{namespace, sroot};
      extNsSpt = new ExtensionNamespaceSupport(namespace, handlerClass, args);
      sroot.getExtensionNamespacesManager().registerExtension(extNsSpt);
    }
  }
  
  
  

  private int _resultIndex;
  
  
  void setResultIndex(int stackIndex)
  { 
      _resultIndex = stackIndex;
  }
  
  
  public int getResultIndex()
  {
    return _resultIndex;
  }
  
}"
org.apache.xalan.xsltc.runtime.output.SAXHTMLOutput,8,3,0,4,22,28,1,3,7,2.0,177,0.0,0,0.860465116,0.375,2,4,21.125,1,0.75,0,"

package org.apache.xalan.xsltc.runtime.output;

import java.util.Stack;
import java.io.IOException;

import org.xml.sax.SAXException;
import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xalan.xsltc.runtime.AttributeList;

public class SAXHTMLOutput extends SAXOutput { 

    public SAXHTMLOutput(ContentHandler handler, String encoding) 
	throws IOException 
    {
	super(handler, encoding);
    }

    public SAXHTMLOutput(ContentHandler handler, LexicalHandler lex, 
	String encoding) throws IOException
    {
	super(handler, lex, encoding);
    }
   
    public void endDocument() throws TransletException {
        try {
            
            if (_startTagOpen) {
		closeStartTag();
	    }

            
            _saxHandler.endDocument();
        } 
	catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    public void startElement(String elementName) throws TransletException {
    	try {
	    
            if (_startTagOpen) {
		closeStartTag();
	    }

            
            if (_lexHandler != null) {
                if ((_doctypeSystem != null) || (_doctypePublic != null))
                    _lexHandler.startDTD(elementName,
                             _doctypePublic,_doctypeSystem);
                _lexHandler = null;
            }

            _depth++;
            _elementName = elementName;
            _attributes.clear();
            _startTagOpen = true;
        } 
	catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    public void endElement(String elementName) throws TransletException {
        try {
            
            if (_startTagOpen) {
		closeStartTag();
	    }
            _saxHandler.endElement(EMPTYSTRING, elementName, elementName);
        } 
	catch (SAXException e) {
            throw new TransletException(e);
        }

    }

    public void attribute(String name, final String value) 
	throws TransletException
    {
	if (_startTagOpen) {
	    final String patchedName = patchName(name);
	    final String localName = getLocalName(patchedName);
	    final int index = _attributes.getIndex(name); 

	    if (index >= 0) {
		_attributes.setAttribute(index, EMPTYSTRING, localName,
			name, ""CDATA"", value);
	    }
	    else {
		_attributes.addAttribute(EMPTYSTRING, localName,
                name, ""CDATA"", value);
	    }
	}
    }

    
    public void characters(char[] ch, int off, int len)
        throws TransletException 
    {
	try {
            
            if (_startTagOpen) closeStartTag();
            _saxHandler.characters(ch, off, len);
        }
        catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    protected void closeStartTag() throws TransletException {
        try {
            _startTagOpen = false;

            
            _saxHandler.startElement(EMPTYSTRING, _elementName, 
		_elementName, _attributes);
        }
        catch (SAXException e) {
            throw new TransletException(e);
        }
    }
}
"
org.apache.xml.dtm.ref.CoroutineParser,8,1,0,1,8,28,0,1,8,2.0,8,0.0,0,0.0,0.28125,0,0,0.0,1,1.0,0,"

package org.apache.xml.dtm.ref;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import java.io.IOException;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.ContentHandler;
import org.xml.sax.XMLReader;


public interface CoroutineParser {

    
    public int getParserCoroutineID();

    
    public CoroutineManager getCoroutineManager();

  
  public void setContentHandler(ContentHandler handler);

  
  public void setLexHandler(org.xml.sax.ext.LexicalHandler handler);

  

  
  
  public Object doParse(InputSource source, int appCoroutine);

  
  public Object doMore (boolean parsemore, int appCoroutine);

  
  public void doTerminate(int appCoroutine);


    
  public void init( CoroutineManager co, int appCoroutineID, XMLReader parser );

} 
"
org.apache.xalan.xsltc.runtime.StringValueHandler,5,2,0,3,16,4,1,2,5,0.0,129,1.0,0,0.851851852,0.4,0,0,24.4,5,1.6,0,"

package org.apache.xalan.xsltc.runtime;

import org.apache.xalan.xsltc.*;

public final class StringValueHandler extends TransletOutputBase {

    private char[] _buffer = new char[32];
    private int _free = 0;
	
    public void characters(char[] ch, int off, int len) 
	throws TransletException 
    {
	if (_free + len >= _buffer.length) {
	    char[] newBuffer = new char[_free + len + 32];
	    System.arraycopy(_buffer, 0, newBuffer, 0, _free);
	    _buffer = newBuffer;
	}
	System.arraycopy(ch, off, _buffer, _free, len);
	_free += len;
    }

    public String getValue() {
	final int length = _free;
	_free = 0;		
	return new String(_buffer, 0, length);
    }

    public void characters(String characters) throws TransletException {
	characters(characters.toCharArray(), 0, characters.length());
    }

    
    public String getValueOfPI() {
	final String value = getValue();

	if (value.indexOf(""?>"") > 0) {
	    final int n = value.length(); 
	    final StringBuffer valueOfPI = new StringBuffer();

	    for (int i = 0; i < n;) {
		final char ch = value.charAt(i++);
		if (ch == '?' && value.charAt(i) == '>') {
		    valueOfPI.append(""? >""); i++;
		}
		else {
		    valueOfPI.append(ch);
		}
	    } 
	    return valueOfPI.toString();
	}
	return value;
    }
}
"
org.apache.xml.utils.CharKey,5,1,0,1,6,0,1,0,5,0.25,32,1.0,0,0.0,0.533333333,1,1,5.2,2,0.8,0,"package org.apache.xml.utils;


public class CharKey extends Object
{

  
  private char m_char;

  
  public CharKey(char key)
  {
    m_char = key;
  }
  
  
  public CharKey()
  {
  }
  
  
  public final void setChar(char c)
  {
    m_char = c;
  }



  
  public final int hashCode()
  {
    return (int)m_char;
  }

  
  public final boolean equals(Object obj)
  {
    return ((CharKey)obj).m_char == m_char;
  }
}"
org.apache.xalan.xsltc.compiler.util.Type,33,1,10,113,53,526,103,21,32,0.998046875,300,0.0,16,0.0,0.234375,0,0,7.606060606,2,1.0,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.NodeTest;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.Constants;

public abstract class Type implements Constants {
    public static final Type Int        = new IntType();
    public static final Type Real       = new RealType();
    public static final Type Boolean    = new BooleanType();
    public static final Type NodeSet    = new NodeSetType();
    public static final Type String     = new StringType();
    public static final Type ResultTree = new ResultTreeType();
    public static final Type Reference  = new ReferenceType();
    public static final Type Void       = new VoidType();
    public static final Type Object     = new ObjectType();

    public static final Type Node       = new NodeType(NodeTest.ANODE);
    public static final Type Root       = new NodeType(NodeTest.ROOT);
    public static final Type Element    = new NodeType(NodeTest.ELEMENT);
    public static final Type Attribute  = new NodeType(NodeTest.ATTRIBUTE);
    public static final Type Text       = new NodeType(NodeTest.TEXT);
    public static final Type Comment    = new NodeType(NodeTest.COMMENT);
    public static final Type Processing_Instruction = new NodeType(NodeTest.PI);

    
    public abstract String toString();

    
    public abstract boolean identicalTo(Type other);

    
    public boolean isNumber() {
	return false;
    }

    
    public boolean implementedAsMethod() {
	return false;
    }

    
    public boolean isSimple() {
	return false;
    }

    public abstract org.apache.bcel.generic.Type toJCType();

    
    public int distanceTo(Type type) {
	return type == this ? 0 : Integer.MAX_VALUE;
    }

    
    public abstract String toSignature();

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    toString(), type.toString());
	classGen.getParser().reportError(Constants.FATAL, err);
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     Type type) {
	FlowList fl = null;
	if (type == Type.Boolean) {
	    fl = translateToDesynthesized(classGen, methodGen,
					  (BooleanType)type);
	}
	else {
	    translateTo(classGen, methodGen, type);
	}
	return fl;
    }

     
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    toString(), type.toString());
	classGen.getParser().reportError(Constants.FATAL, err);
	return null;
    }

     
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    toString(), clazz.getClass().toString());
	classGen.getParser().reportError(Constants.FATAL, err);
    }

     
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen,
			      Class clazz) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    clazz.getClass().toString(), toString());
	classGen.getParser().reportError(Constants.FATAL, err);
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    toString(), ""[""+toString()+""]"");
	classGen.getParser().reportError(Constants.FATAL, err);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				    ""[""+toString()+""]"", toString());
	classGen.getParser().reportError(Constants.FATAL, err);
    }

    
    public String getClassName() {
	return(EMPTYSTRING);
    }

    public Instruction ADD() {
	return null;		
    }

    public Instruction SUB() {
	return null;		
    }

    public Instruction MUL() {
	return null;		
    }

    public Instruction DIV() {
	return null;		
    }

    public Instruction REM() {
	return null;		
    }

    public Instruction NEG() {
	return null;		
    }

    public Instruction LOAD(int slot) {
	return null;		
    }
	
    public Instruction STORE(int slot) {
	return null;		
    }

    public Instruction POP() {
	return POP;
    }

    public BranchInstruction GT(boolean tozero) {
	return null;		
    }

    public BranchInstruction GE(boolean tozero) {
	return null;		
    }

    public BranchInstruction LT(boolean tozero) {
	return null;		
    }

    public BranchInstruction LE(boolean tozero) {
	return null;		
    }

    public Instruction CMP(boolean less) {
	return null;		
    }
	
    public Instruction DUP() {
	return DUP;	
    }
}
"
org.apache.xalan.transformer.StackGuard,7,1,0,7,18,0,3,6,5,0.5,155,0.0,1,0.0,0.458333333,0,0,20.85714286,4,1.4286,1,"
package org.apache.xalan.transformer;




import javax.xml.transform.TransformerException;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;


public class StackGuard
{

  
  public static int m_recursionLimit = -1;
  
  TransformerImpl m_transformer;

  
  public int getRecursionLimit()
  {
    return m_recursionLimit;
  }

  
  public void setRecursionLimit(int limit)
  {
    m_recursionLimit = limit;
  }

  
  public StackGuard(TransformerImpl transformerImpl)
  {
    m_transformer = transformerImpl;
  }

  
  public int countLikeTemplates(ElemTemplate templ, int pos)
  {
  	ElemTemplateElement[] elems = m_transformer.getCurrentTemplateElements();
  	int count = 1;
    for (int i = pos-1; i >= 0; i--)
    {
    	if(elems[i] == templ)
    		count++;
    }
	
    return count;
  }

  
  
  private ElemTemplate getNextMatchOrNamedTemplate(int pos)
  {
  	ElemTemplateElement[] elems = m_transformer.getCurrentTemplateElements();
    for (int i = pos; i >= 0; i--)
    {
    	ElemTemplateElement elem = elems[i];
    	if(null != elem)
    	{
	    	if(elem.getXSLToken() == Constants.ELEMNAME_TEMPLATE)
	    	{
	    		return (ElemTemplate)elem;
	    	}
    	}
    }
  	return null;
  }

  
  public void checkForInfinateLoop() throws TransformerException
  {
    int nTemplates = m_transformer.getCurrentTemplateElementsCount();
    if(nTemplates < m_recursionLimit)
    	return;
    	
    if(m_recursionLimit <= 0)
    	return;  
    	
    
    
    for (int i = (nTemplates - 1); i >= m_recursionLimit; i--)
    {
    	ElemTemplate template = getNextMatchOrNamedTemplate(i);
    	
    	if(null == template)
    		break;
    		
    	int loopCount = countLikeTemplates(template, i);
    	
    	if (loopCount >= m_recursionLimit)
    	{
    		
    		
    		
    		
    		
    		String idIs = XSLMessages.createMessage(((null != template.getName()) ? ""nameIs"" : ""matchPatternIs""), null);
        	Object[] msgArgs = new Object[]{ new Integer(loopCount), idIs, 
                     ((null != template.getName()) ? template.getName().toString() 
    		   : template.getMatch().getPatternString()) };
        	String msg = XSLMessages.createMessage(""recursionTooDeep"", msgArgs);

    		throw new TransformerException(msg);
    	}
    }
  }

}
"
org.apache.xalan.serialize.WriterToUTF8Buffered,11,2,0,2,20,0,1,1,9,0.2,632,1.0,0,0.590909091,0.381818182,1,2,56.18181818,1,0.8182,0,"
package org.apache.xalan.serialize;

import java.io.*;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


public final class WriterToUTF8Buffered extends Writer
{

  
  private OutputStream m_os;

  
  private byte buf[];

  
  private int count;

  
  public WriterToUTF8Buffered(OutputStream out)
          throws UnsupportedEncodingException
  {
    this(out, 8 * 1024);
  }

  
  public WriterToUTF8Buffered(final OutputStream out, final int size)
  {

    m_os = out;

    if (size <= 0)
    {
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BUFFER_SIZE_LESSTHAN_ZERO, null)); 
    }

    buf = new byte[size];
    count = 0;
  }

  
  public void write(final int c) throws IOException
  {
    
    if (c < 0x80)
    {
      if (count >= buf.length)
        flushBuffer();
      buf[count++] = (byte) (c);
    }
    else if (c < 0x800)
    {
      if (count+1 >= buf.length)
        flushBuffer();
      buf[count++] = (byte) (0xc0 + (c >> 6));
      buf[count++] = (byte) (0x80 + (c & 0x3f));
    }
    else
    {
      if (count+2 >= buf.length)
        flushBuffer();
      buf[count++] = (byte) (0xe0 + (c >> 12));
      buf[count++] = (byte) (0x80 + ((c >> 6) & 0x3f));
      buf[count++] = (byte) (0x80 + (c & 0x3f));
    }
  }

  
  private final void writeDirect(
          final char chars[], final int start, final int length)
            throws java.io.IOException
  {

    final OutputStream os = m_os;

    int n = length+start;
    for (int i = start; i < n; i++)
    {
      final char c = chars[i];

      if (c < 0x80)
        os.write(c);
      else if (c < 0x800)
      {
        os.write(0xc0 + (c >> 6));
        os.write(0x80 + (c & 0x3f));
      }
      else
      {
        os.write(0xe0 + (c >> 12));
        os.write(0x80 + ((c >> 6) & 0x3f));
        os.write(0x80 + (c & 0x3f));
      }
    }
  }

  
  private final void writeDirect(final String s) throws IOException
  {

    final int n = s.length();
    final OutputStream os = m_os;

    for (int i = 0; i < n; i++)
    {
      final char c = s.charAt(i);

      if (c < 0x80)
        os.write(c);
      else if (c < 0x800)
      {
        os.write(0xc0 + (c >> 6));
        os.write(0x80 + (c & 0x3f));
      }
      else
      {
        os.write(0xe0 + (c >> 12));
        os.write(0x80 + ((c >> 6) & 0x3f));
        os.write(0x80 + (c & 0x3f));
      }
    }
  }

  
  public void write(final char chars[], final int start, final int length)
          throws java.io.IOException
  {

    
    
    

    int lengthx3 = (length << 1) + length;

    if (lengthx3 >= buf.length)
    {

      
      flushBuffer();
      writeDirect(chars, start, length);

      return;
    }

    if (lengthx3 > buf.length - count)
    {
      flushBuffer();
    }

    final OutputStream os = m_os;
    int n = length+start;
    for (int i = start; i < n; i++)
    {
      final char c = chars[i];

      if (c < 0x80)
        buf[count++] = (byte) (c);
      else if (c < 0x800)
      {
        buf[count++] = (byte) (0xc0 + (c >> 6));
        buf[count++] = (byte) (0x80 + (c & 0x3f));
      }
      else
      {
        buf[count++] = (byte) (0xe0 + (c >> 12));
        buf[count++] = (byte) (0x80 + ((c >> 6) & 0x3f));
        buf[count++] = (byte) (0x80 + (c & 0x3f));
      }
    }

  }

  
  public void write(final String s) throws IOException
  {

    final int length = s.length();

    
    
    

    int lengthx3 = (length << 1) + length;

    if (lengthx3 >= buf.length)
    {

      
      flushBuffer();
      writeDirect(s);

      return;
    }

    if (lengthx3 > buf.length - count)
    {
      flushBuffer();
    }

    final OutputStream os = m_os;

    for (int i = 0; i < length; i++)
    {
      final char c = s.charAt(i);

      if (c < 0x80)
        buf[count++] = (byte) (c);
      else if (c < 0x800)
      {
        buf[count++] = (byte) (0xc0 + (c >> 6));
        buf[count++] = (byte) (0x80 + (c & 0x3f));
      }
      else
      {
        buf[count++] = (byte) (0xe0 + (c >> 12));
        buf[count++] = (byte) (0x80 + ((c >> 6) & 0x3f));
        buf[count++] = (byte) (0x80 + (c & 0x3f));
      }
    }

  }

  
  public void flushBuffer() throws IOException
  {

    if (count > 0)
    {
      m_os.write(buf, 0, count);

      count = 0;
    }
  }

  
  public void flush() throws java.io.IOException
  {
    flushBuffer();
    m_os.flush();
  }

  
  public void close() throws java.io.IOException
  {
    flushBuffer();
    m_os.close();
  }

  
  public OutputStream getOutputStream()
  {
    return m_os;
  }
}
"
org.apache.xalan.xsltc.dom.EmptyFilter,2,1,0,1,3,1,0,1,2,2.0,7,0.0,0,0.0,0.75,0,0,2.5,1,0.5,0,"

package org.apache.xalan.xsltc.dom;

public final class EmptyFilter implements Filter {
    public boolean test(int node) {
	return true;
    }
}
"
org.apache.xpath.functions.FuncCeiling,2,4,0,5,7,1,0,5,2,2.0,15,0.0,0,0.979591837,0.75,1,6,6.5,1,0.5,0,"
package org.apache.xpath.functions;

import java.lang.Math;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;


public class FuncCeiling extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(Math.ceil(m_arg0.execute(xctxt).num()));
  }
}
"
org.apache.xalan.xsltc.compiler.Number,15,3,0,55,96,23,0,55,9,0.798319328,1308,1.0,8,0.811594203,0.214285714,2,3,85.06666667,14,3.1333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.ArrayList;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.Field;

import org.apache.xalan.xsltc.compiler.util.*;

final class Number extends Instruction implements Closure {
    private static final int LEVEL_SINGLE   = 0;
    private static final int LEVEL_MULTIPLE = 1;
    private static final int LEVEL_ANY      = 2;

    static final private String[] ClassNames = { 
	""org.apache.xalan.xsltc.dom.SingleNodeCounter"",	  
	""org.apache.xalan.xsltc.dom.MultipleNodeCounter"", 
	""org.apache.xalan.xsltc.dom.AnyNodeCounter""	  
    };

    static final private String[] FieldNames = { 
	""___single_node_counter"",		   
	""___multiple_node_counter"",		   
	""___any_node_counter""			   
    };

    private Pattern _from = null;
    private Pattern _count = null;
    private Expression _value = null;

    private AttributeValueTemplate _lang = null;
    private AttributeValueTemplate _format = null;
    private AttributeValueTemplate _letterValue = null;
    private AttributeValueTemplate _groupingSeparator = null;
    private AttributeValueTemplate _groupingSize = null;

    private int _level = LEVEL_SINGLE;
    private boolean _formatNeeded = false;

    private String _className = null;
    private ArrayList _closureVars = null;

     

    
    public boolean inInnerClass() {
	return (_className != null);
    }

    
    public Closure getParentClosure() {
	return null;
    }

    
    public String getInnerClassName() {
	return _className;
    }

    
    public void addVariable(VariableRefBase variableRef) {
	if (_closureVars == null) {
	    _closureVars = new ArrayList();
	}

	
	if (!_closureVars.contains(variableRef)) {
	    _closureVars.add(variableRef);
	}
    }

    

   public void parseContents(Parser parser) {
	final int count = _attributes.getLength();

	for (int i = 0; i < count; i++) {
	    final String name = _attributes.getQName(i);
	    final String value = _attributes.getValue(i);

	    if (name.equals(""value"")) {
		_value = parser.parseExpression(this, name, null);
	    }
	    else if (name.equals(""count"")) {
		_count = parser.parsePattern(this, name, null);
	    }
	    else if (name.equals(""from"")) {
		_from = parser.parsePattern(this, name, null);
	    }
	    else if (name.equals(""level"")) {
		if (value.equals(""single"")) {
		    _level = LEVEL_SINGLE;
		}
		else if (value.equals(""multiple"")) {
		    _level = LEVEL_MULTIPLE;
		}
		else if (value.equals(""any"")) {
		    _level = LEVEL_ANY;
		}
	    }
	    else if (name.equals(""format"")) {
		_format = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	    else if (name.equals(""lang"")) {
		_lang = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	    else if (name.equals(""letter-value"")) {
		_letterValue = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	    else if (name.equals(""grouping-separator"")) {
		_groupingSeparator = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	    else if (name.equals(""grouping-size"")) {
		_groupingSize = new AttributeValueTemplate(value, parser, this);
		_formatNeeded = true;
	    }
	}
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_value != null) {
	    Type tvalue = _value.typeCheck(stable);
	    if (tvalue instanceof RealType == false) {
		_value = new CastExpr(_value, Type.Real);
	    }
	}
	if (_count != null) {
	    _count.typeCheck(stable);
	}
	if (_from != null) {
	    _from.typeCheck(stable);
	}
	if (_format != null) {
	    _format.typeCheck(stable);
	}
	if (_lang != null) {
	    _lang.typeCheck(stable);
	}
	if (_letterValue != null) {
	    _letterValue.typeCheck(stable);
	}
	if (_groupingSeparator != null) {
	    _groupingSeparator.typeCheck(stable);
	}
	if (_groupingSize != null) {
	    _groupingSize.typeCheck(stable);
	}
	return Type.Void;
    }

    
    public boolean hasValue() {
	return _value != null;
    }

    
    public boolean isDefault() {
	return _from == null && _count == null;
    }

    private void compileDefault(ClassGenerator classGen,
			        MethodGenerator methodGen) {
	int index;
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();

	int[] fieldIndexes = getXSLTC().getNumberFieldIndexes();

	if (fieldIndexes[_level] == -1) {
	    Field defaultNode = new Field(ACC_PRIVATE, 
					  cpg.addUtf8(FieldNames[_level]),
					  cpg.addUtf8(NODE_COUNTER_SIG),
					  null, 
					  cpg.getConstantPool());

	    
	    classGen.addField(defaultNode);

	    
	    fieldIndexes[_level] = cpg.addFieldref(classGen.getClassName(), 
						   FieldNames[_level],
						   NODE_COUNTER_SIG);
	}

	
	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(fieldIndexes[_level]));
	final BranchHandle ifBlock1 = il.append(new IFNONNULL(null));

	
	index = cpg.addMethodref(ClassNames[_level],
				 ""getDefaultNodeCounter"", 
				 ""("" + TRANSLET_INTF_SIG
				 + DOM_INTF_SIG
				 + NODE_ITERATOR_SIG 
				 + "")"" + NODE_COUNTER_SIG);
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadIterator());
	il.append(new INVOKESTATIC(index));
	il.append(DUP);

	
	il.append(classGen.loadTranslet());
	il.append(SWAP);
	il.append(new PUTFIELD(fieldIndexes[_level]));
	final BranchHandle ifBlock2 = il.append(new GOTO(null));

	
	ifBlock1.setTarget(il.append(classGen.loadTranslet()));
	il.append(new GETFIELD(fieldIndexes[_level]));
	
	ifBlock2.setTarget(il.append(NOP));
    }

    
    private void compileConstructor(ClassGenerator classGen) {
	MethodGenerator cons;
	final InstructionList il = new InstructionList();
	final ConstantPoolGen cpg = classGen.getConstantPool();

	cons = new MethodGenerator(ACC_PUBLIC,
				   org.apache.bcel.generic.Type.VOID, 
				   new org.apache.bcel.generic.Type[] {
				       Util.getJCRefType(TRANSLET_INTF_SIG),
				       Util.getJCRefType(DOM_INTF_SIG),
				       Util.getJCRefType(NODE_ITERATOR_SIG)
				   },
				   new String[] {
				       ""dom"",
				       ""translet"",
				       ""iterator""
				   },
				   ""<init>"", _className, il, cpg);

	il.append(ALOAD_0);     
	il.append(ALOAD_1);     
	il.append(ALOAD_2);     
	il.append(new ALOAD(3));

	int index = cpg.addMethodref(ClassNames[_level],
				     ""<init>"", 
				     ""("" + TRANSLET_INTF_SIG
				     + DOM_INTF_SIG
				     + NODE_ITERATOR_SIG 
				     + "")V"");
	il.append(new INVOKESPECIAL(index));
	il.append(RETURN);
	
	cons.stripAttributes(true);
	cons.setMaxLocals();
	cons.setMaxStack();
	classGen.addMethod(cons.getMethod());
    }

    
    private void compileLocals(NodeCounterGenerator nodeCounterGen,
			       MatchGenerator matchGen,
			       InstructionList il) 
    {
	int field;
	LocalVariableGen local;
	ConstantPoolGen cpg = nodeCounterGen.getConstantPool();

	
	local = matchGen.addLocalVariable(""iterator"", 
					  Util.getJCRefType(NODE_ITERATOR_SIG),
					  null, null);
	field = cpg.addFieldref(NODE_COUNTER, ""_iterator"",
				ITERATOR_FIELD_SIG);
	il.append(ALOAD_0); 
	il.append(new GETFIELD(field));
	il.append(new ASTORE(local.getIndex()));
	matchGen.setIteratorIndex(local.getIndex());
	
	
	local = matchGen.addLocalVariable(""translet"", 
				  Util.getJCRefType(TRANSLET_SIG),
				  null, null);
	field = cpg.addFieldref(NODE_COUNTER, ""_translet"",
				""Lorg/apache/xalan/xsltc/Translet;"");
	il.append(ALOAD_0); 
	il.append(new GETFIELD(field));
	il.append(new CHECKCAST(cpg.addClass(TRANSLET_CLASS)));
	il.append(new ASTORE(local.getIndex()));
	nodeCounterGen.setTransletIndex(local.getIndex());

	
	local = matchGen.addLocalVariable(""document"", 
					  Util.getJCRefType(DOM_INTF_SIG),
					  null, null);
	field = cpg.addFieldref(_className, ""_document"", DOM_INTF_SIG);
	il.append(ALOAD_0); 
	il.append(new GETFIELD(field));
	
	il.append(new ASTORE(local.getIndex()));
	matchGen.setDomIndex(local.getIndex());
    }

    private void compilePatterns(ClassGenerator classGen,
				 MethodGenerator methodGen) 
    {
	int current;
	int field;
	LocalVariableGen local;
	MatchGenerator matchGen;
	NodeCounterGenerator nodeCounterGen;

	_className = getXSLTC().getHelperClassName();
	nodeCounterGen = new NodeCounterGenerator(_className,
						  ClassNames[_level],
						  toString(), 
						  ACC_PUBLIC | ACC_SUPER,
						  null,
						  classGen.getStylesheet());
	InstructionList il = null;
	ConstantPoolGen cpg = nodeCounterGen.getConstantPool();

	
	final int closureLen = (_closureVars == null) ? 0 : 
	    _closureVars.size();

	for (int i = 0; i < closureLen; i++) {
	    VariableBase var = 
		((VariableRefBase) _closureVars.get(i)).getVariable();

	    nodeCounterGen.addField(new Field(ACC_PUBLIC, 
					cpg.addUtf8(var.getVariable()),
					cpg.addUtf8(var.getType().toSignature()),
					null, cpg.getConstantPool()));
	}

	
	compileConstructor(nodeCounterGen);

	
	if (_from != null) {
	    il = new InstructionList();
	    matchGen =
		new MatchGenerator(ACC_PUBLIC | ACC_FINAL,
				   org.apache.bcel.generic.Type.BOOLEAN, 
				   new org.apache.bcel.generic.Type[] {
				       org.apache.bcel.generic.Type.INT,
				   },
				   new String[] {
				       ""node"",
				   },
				   ""matchesFrom"", _className, il, cpg);

	    compileLocals(nodeCounterGen,matchGen,il);

	    
	    il.append(matchGen.loadContextNode());
	    _from.translate(nodeCounterGen, matchGen);
	    _from.synthesize(nodeCounterGen, matchGen);
	    il.append(IRETURN);
		    
	    matchGen.stripAttributes(true);
	    matchGen.setMaxLocals();
	    matchGen.setMaxStack();
	    matchGen.removeNOPs();
	    nodeCounterGen.addMethod(matchGen.getMethod());
	}

	
	if (_count != null) {
	    il = new InstructionList();
	    matchGen = new MatchGenerator(ACC_PUBLIC | ACC_FINAL,
					  org.apache.bcel.generic.Type.BOOLEAN, 
					  new org.apache.bcel.generic.Type[] {
					      org.apache.bcel.generic.Type.INT,
					  },
					  new String[] {
					      ""node"",
					  },
					  ""matchesCount"", _className, il, cpg);

	    compileLocals(nodeCounterGen,matchGen,il);
	    
	    
	    il.append(matchGen.loadContextNode());
	    _count.translate(nodeCounterGen, matchGen);
	    _count.synthesize(nodeCounterGen, matchGen);
	    
	    il.append(IRETURN);
		    
	    matchGen.stripAttributes(true);
	    matchGen.setMaxLocals();
	    matchGen.setMaxStack();
	    matchGen.removeNOPs();
	    nodeCounterGen.addMethod(matchGen.getMethod());
	}
	
	getXSLTC().dumpClass(nodeCounterGen.getJavaClass());

	
	cpg = classGen.getConstantPool();
	il = methodGen.getInstructionList();

	final int index = cpg.addMethodref(_className, ""<init>"", 
					   ""("" + TRANSLET_INTF_SIG
					   + DOM_INTF_SIG 
					   + NODE_ITERATOR_SIG
					   + "")V"");
	il.append(new NEW(cpg.addClass(_className)));
	il.append(DUP);
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadIterator());
	il.append(new INVOKESPECIAL(index));

	
	for (int i = 0; i < closureLen; i++) {
	    final VariableRefBase varRef = (VariableRefBase) _closureVars.get(i);
	    final VariableBase var = varRef.getVariable();
	    final Type varType = var.getType();

	    
	    il.append(DUP);
	    il.append(var.loadInstruction());
	    il.append(new PUTFIELD(
		    cpg.addFieldref(_className, var.getVariable(), 
			varType.toSignature())));
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	int index;
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(classGen.loadTranslet());

	if (hasValue()) {
	    compileDefault(classGen, methodGen);
	    _value.translate(classGen, methodGen);

	    
	    index = cpg.addMethodref(MATH_CLASS, ""round"", ""(D)J"");
	    il.append(new INVOKESTATIC(index));
	    il.append(new L2I());

	    
	    index = cpg.addMethodref(NODE_COUNTER, 
				     ""setValue"", 
				     ""(I)"" + NODE_COUNTER_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}
	else if (isDefault()) {
	    compileDefault(classGen, methodGen);
	}
	else {
	    compilePatterns(classGen, methodGen);
	}

	
	if (!hasValue()) {
	    il.append(methodGen.loadContextNode());
	    index = cpg.addMethodref(NODE_COUNTER, 
				     SET_START_NODE, 
				     ""(I)"" + NODE_COUNTER_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}

	
	if (_formatNeeded) {
	    if (_format != null) {
		_format.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, ""1""));
	    }

	    if (_lang != null) {
		_lang.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, ""en"")); 	
	    }

	    if (_letterValue != null) {
		_letterValue.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, Constants.EMPTYSTRING));
	    }

	    if (_groupingSeparator != null) {
		_groupingSeparator.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, Constants.EMPTYSTRING));
	    }

	    if (_groupingSize != null) {
		_groupingSize.translate(classGen, methodGen);
	    }
	    else {
		il.append(new PUSH(cpg, ""0""));
	    }

	    index = cpg.addMethodref(NODE_COUNTER, ""getCounter"", 
				     ""("" + STRING_SIG + STRING_SIG 
				     + STRING_SIG + STRING_SIG 
				     + STRING_SIG + "")"" + STRING_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}
	else {
	    index = cpg.addMethodref(NODE_COUNTER, ""setDefaultFormatting"", 
				     ""()"" + NODE_COUNTER_SIG);
	    il.append(new INVOKEVIRTUAL(index));

	    index = cpg.addMethodref(NODE_COUNTER, ""getCounter"", 
				     ""()"" + STRING_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}

	
	il.append(methodGen.loadHandler());
	index = cpg.addMethodref(TRANSLET_CLASS,
				 CHARACTERSW,
				 CHARACTERSW_SIG);
	il.append(new INVOKEVIRTUAL(index));
    }
}
"
org.apache.xpath.compiler.XPathDumper,1,1,0,0,2,0,0,0,1,2.0,4,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xpath.compiler;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xpath.XPath;
import org.apache.xpath.compiler.XPathParser;


public class XPathDumper
{

  
}
"
org.apache.xalan.xsltc.runtime.TextOutput,48,1,0,8,106,388,1,7,26,0.895702962,2321,0.901960784,2,0.0,0.236702128,0,0,46.29166667,21,1.8958,0,"

package org.apache.xalan.xsltc.runtime;

import java.io.*;
import java.util.Stack;
import java.util.Enumeration;

import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.AttributesImpl;

import org.apache.xalan.xsltc.*;

public final class TextOutput implements TransletOutputHandler, Constants {

    
    public static final int UNKNOWN = 0; 
    public static final int XML     = 1;
    public static final int HTML    = 2;
    public static final int TEXT    = 3;
    public static final int QNAME   = 4;  

    
    
    private int	   _outputType = UNKNOWN;
    private String _encoding;
    private String _mediaType = ""text/html"";
    private String _doctypeSystem = null;
    private String _doctypePublic = null;

    private boolean   _escapeChars = false;
    private boolean   _startTagOpen = false;
    private boolean   _headTagOpen = false;
    private boolean   _cdataTagOpen = false;
    private boolean   _is8859Encoded = false;

    
    private Hashtable _cdata = null;

    private static final char[] AMP      = ""&amp;"".toCharArray();
    private static final char[] LT       = ""&lt;"".toCharArray();
    private static final char[] GT       = ""&gt;"".toCharArray();
    private static final char[] CRLF     = ""&#xA;"".toCharArray();
    private static final char[] QUOTE    = ""&quot;"".toCharArray();
    private static final char[] NBSP     = ""&nbsp;"".toCharArray();

    private static final char[] BEGCDATA = ""<![CDATA["".toCharArray();
    private static final char[] ENDCDATA = ""]]>"".toCharArray();
    private static final char[] CNTCDATA = ""]]]]><![CDATA[>"".toCharArray();
    private static final char[] BEGCOMM  = ""<!--"".toCharArray();
    private static final char[] ENDCOMM  = ""-->"".toCharArray();

    private static final int AMP_length   = AMP.length;
    private static final int LT_length    = LT.length;
    private static final int GT_length    = GT.length;
    private static final int CRLF_length  = CRLF.length;
    private static final int QUOTE_length = QUOTE.length;
    private static final int NBSP_length  = NBSP.length;
    private static final int BEGCOMM_length = BEGCOMM.length;
    private static final int ENDCOMM_length = ENDCOMM.length;

    private static final String HREF_STR        = ""href"";
    private static final String CITE_STR        = ""cite"";
    private static final String SRC_STR         = ""src"";
    private static final String CHAR_ESC_START  = ""&#"";
    private static final String CDATA_ESC_START = ""]]>&#"";
    private static final String CDATA_ESC_END   = "";<![CDATA["";

    private AttributesImpl _attributes = new AttributesImpl();
    private String         _elementName = null;

    
    private Hashtable _namespaces;
    
    
    private Stack     _nodeStack;
    
    private Stack     _prefixStack;

    
    private Stack     _qnameStack;

    
    
    private Stack     _cdataStack;

    
    private int _depth = 0;

    
    private ContentHandler _saxHandler;
    private LexicalHandler _lexHandler;

    
    public TextOutput(ContentHandler handler) throws IOException {
        _saxHandler = handler;
        init();
    }

    
    public TextOutput(ContentHandler handler, String encoding)
	throws IOException {
        _saxHandler = handler;
        init();
	_encoding = encoding;
	_is8859Encoded = _encoding.equalsIgnoreCase(""iso-8859-1"");	
    }

    
    public TextOutput(ContentHandler sax, LexicalHandler lex, String encoding)
	throws IOException {
        _saxHandler = sax;
	_lexHandler = lex;
        init();
	_encoding = encoding;
	_is8859Encoded = _encoding.equalsIgnoreCase(""iso-8859-1"");	
    }

    
    private void init() throws IOException {
	
	_outputType = UNKNOWN;
	_encoding = ""UTF-8"";
	_mediaType = ""text/html"";

	
	_escapeChars  = false;
	_startTagOpen = false;
	_cdataTagOpen = false;
	_qnameStack = new Stack();
	_cdataStack = new Stack();
	_cdataStack.push(new Integer(-1)); 

	
	initNamespaces();
    }

    
    public void close() {
	if ((_saxHandler != null) &&
	    (_saxHandler instanceof DefaultSAXOutputHandler)) {
	    ((DefaultSAXOutputHandler)_saxHandler).close();
	}
    }

    
    private void setTypeInternal(int type) {
	if (type == XML) {
	    _escapeChars = true;
	}
	else if (type == HTML) {
	    setIndent(true);
	    _escapeChars = true;
	}
	setType(type);
    }

    
    private void emitHeader() throws SAXException {
	
	if (_outputType == HTML) {
	    AttributeList attrs = new AttributeList();
	    attrs.add(""http-equiv"", ""Content-Type"");
	    attrs.add(""content"", _mediaType+""; charset=""+_encoding);
	    _saxHandler.startElement(EMPTYSTRING, EMPTYSTRING, ""meta"", attrs);
	    _saxHandler.endElement(EMPTYSTRING, EMPTYSTRING, ""meta"");
	}
    }

    
    public void closeStartTag() throws TransletException {
	try {
	    _startTagOpen = false;

	    
	    _saxHandler.startElement(getNamespaceURI(_elementName, true),
		getLocalName(_elementName), _elementName, _attributes);

	    
	    if (_headTagOpen) {
		emitHeader();
		_headTagOpen = false;
	    }
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    } 

    
    public boolean setEscaping(boolean escape) throws TransletException {

	
	if (_outputType == UNKNOWN) setTypeInternal(XML);

	
	boolean oldSetting = _escapeChars;
	_escapeChars = escape;

	
	if (_outputType == TEXT) _escapeChars = false; 

	return(oldSetting);
    }

    
    public void startDocument() throws TransletException {
        try {
            _saxHandler.startDocument();
	    
            if (_outputType == XML) _escapeChars = true;
        } catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    public void endDocument() throws TransletException {
        try {
            
            if (_outputType == UNKNOWN) setTypeInternal(XML);

	    
	    if (_startTagOpen) closeStartTag();
	    if (_cdataTagOpen) closeCDATA();

	    
            _saxHandler.endDocument();
        } catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    public void characters(String str) throws TransletException {
	try {
	    characters(str.toCharArray(), 0, str.length());
	}
	catch (SAXException e) {
            throw new TransletException(e);
	}
    }

    
    private void characters(char[] ch) throws SAXException {
	characters(ch, 0, ch.length);
    }

    
    private void startCDATA(char[] ch, int off, int len) throws SAXException {
	
	final int limit = off + len;
	int offset = off;

	
	_saxHandler.characters(BEGCDATA, 0, BEGCDATA.length);

	
	for (int i = offset; i < limit-2; i++) {
	    if (ch[i] == ']' && ch[i+1] == ']' && ch[i+2] == '>') {
		_saxHandler.characters(ch, offset, i - offset);
		_saxHandler.characters(CNTCDATA, 0, CNTCDATA.length);
		offset = i+3;
		i=i+2; 
	    }
	}

	
	if (offset < limit) _saxHandler.characters(ch, offset, limit - offset);

	_cdataTagOpen = true;
    }

    private void closeCDATA() throws SAXException {
	
	_saxHandler.characters(ENDCDATA, 0, ENDCDATA.length);
	_cdataTagOpen = false;
    }

    public void startCDATA() throws TransletException {
	
    }

    public void endCDATA() throws TransletException {
	
    }

    
    public void characters(char[] ch, int off, int len)	
	throws TransletException {
        try {
	    switch(_outputType) {
	    case UNKNOWN: 
		setTypeInternal(XML);
	    case XML:
		
		if (_startTagOpen) closeStartTag();

		
		
		
		
		
		Integer I = (Integer)_cdataStack.peek();
		if ((I.intValue() == _depth) && (!_cdataTagOpen)) {
		    startCDATA(ch, off, len);
		} 
		else if (_escapeChars) {
		    if (_cdataTagOpen) {
			escapeCDATA(ch, off, len);
		    } else {
			escapeCharacters(ch, off, len);
		    }
		} 
		else {
		    _saxHandler.characters(ch, off, len);
		}
		return;

	    case HTML:
		
		if (_startTagOpen) closeStartTag();

		
		
		if (_escapeChars) {
		    if (!_qnameStack.isEmpty()) {
			String qname = (String)_qnameStack.peek();
			qname = qname.toLowerCase();
			if ((qname.equals(""style""))||(qname.equals(""script""))) {
			    _saxHandler.characters(ch, off, len);
			    return;
			}
		    }
		    escapeCharacters(ch, off, len);
		}
		
		else {
		    _saxHandler.characters(ch, off, len);
		}
		return;

	    case TEXT:
		_saxHandler.characters(ch, off, len);
		return;
	    }
        }
	catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    public void startElement(String elementName) throws TransletException {
	try {
	    switch(_outputType) {

	    case UNKNOWN:
		
		
		if (elementName.toLowerCase().equals(""html""))
		    setTypeInternal(HTML);
		else
		    setTypeInternal(XML);
		startElement(elementName);
		return;

	    case XML:
		
		if (_startTagOpen) closeStartTag();
		if (_cdataTagOpen) closeCDATA();

		
		if (_lexHandler != null) {
		    if (_doctypeSystem != null)
			_lexHandler.startDTD(elementName,
					     _doctypePublic,_doctypeSystem);
		    _lexHandler = null;
		}

		_depth++;
		_elementName = elementName;
		_attributes.clear();
		_startTagOpen = true;
		_qnameStack.push(elementName);
		
		if ((_cdata != null) && (_cdata.get(elementName) != null))
		    _cdataStack.push(new Integer(_depth));
		
		return;

	    case HTML:
		
		if (_startTagOpen) closeStartTag();

		
		if (_lexHandler != null) {
		    if ((_doctypeSystem != null) || (_doctypePublic != null))
			_lexHandler.startDTD(elementName,
					     _doctypePublic,_doctypeSystem);
		    _lexHandler = null;
		}

		_depth++;
		_elementName = elementName;
		_attributes.clear();
		_startTagOpen = true;
		_qnameStack.push(elementName);

		
		if (elementName.toLowerCase().equals(""head""))
		    _headTagOpen = true;
		return;

	    case TEXT:
		
		return;
		
	    }
	}
	catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    private void escapeCharacters(char[] ch, int off, int len)
	throws SAXException {

	int limit = off + len;
	int offset = off;

	if (limit > ch.length) limit = ch.length;;


	
	for (int i = off; i < limit; i++) {
	    char current = ch[i];
	    switch (current) {
	    case '&':
		_saxHandler.characters(ch, offset, i - offset);
		_saxHandler.characters(AMP, 0, AMP_length);
		offset = i + 1;
		break;
	    case '<':
		_saxHandler.characters(ch, offset, i - offset);
		_saxHandler.characters(LT, 0, LT_length);
		offset = i + 1;
		break;
	    case '>':
		_saxHandler.characters(ch, offset, i - offset);
		_saxHandler.characters(GT, 0, GT_length);
		offset = i + 1;
		break;
	    case '':
		_saxHandler.characters(ch, offset, i - offset);
		_saxHandler.characters(NBSP, 0, NBSP_length);
		offset = i + 1;
		break;
	    default:
		if ( (current >= '' && current < '') ||
		     (_is8859Encoded && (current > '')) )
		{
		    StringBuffer buf = new StringBuffer(CHAR_ESC_START);
		    buf.append(Integer.toString((int)ch[i]));
		    buf.append(';');
		    final String esc = buf.toString();
		    final char[] chars = esc.toCharArray();
		    final int    strlen = esc.length();
		    _saxHandler.characters(ch, offset, i - offset);
		    _saxHandler.characters(chars, 0, strlen);
		    offset = i + 1;
		}
	    }
	}
	
	if (offset < limit) _saxHandler.characters(ch, offset, limit - offset);
    }

    
    private void escapeCDATA(char[] ch, int off, int len)
	throws SAXException {

	int limit = off + len;
	int offset = off;

	if (limit > ch.length) limit = ch.length;;

	
	for (int i = off; i < limit; i++) {
	    if (ch[i] > '') {
		StringBuffer buf = new StringBuffer(CDATA_ESC_START);
		buf.append(Integer.toString((int)ch[i]));
		buf.append(CDATA_ESC_END);
		final String esc = buf.toString();
		final char[] chars = esc.toCharArray();
		final int    strlen = esc.length();
		_saxHandler.characters(ch, offset, i - offset);
		_saxHandler.characters(chars, 0, strlen);
		offset = i + 1;
	    }
	}
	
	if (offset < limit) _saxHandler.characters(ch, offset, limit - offset);
    }

    
    private String escapeString(String value) {

	int i;
	char[] ch = value.toCharArray();
	int limit = ch.length;
	int offset = 0;
	StringBuffer buf = new StringBuffer();
	
	for (i = 0; i < limit; i++) {
	    switch (ch[i]) {
	    case '&':
		buf.append(ch, offset, i - offset);
		buf.append(AMP);
		offset = i + 1;
		break;
	    case '""':
		buf.append(ch, offset, i - offset);
		buf.append(QUOTE);
		offset = i + 1;
		break;
	    case '<':
		buf.append(ch, offset, i - offset);
		buf.append(LT);
		offset = i + 1;
		break;
	    case '>':
		buf.append(ch, offset, i - offset);
		buf.append(GT);
		offset = i + 1;
		break;
	    case '
':
		buf.append(ch, offset, i - offset);
		buf.append(CRLF);
		offset = i + 1;
		break;
	    }
	}
	if (offset < limit) {
	    buf.append(ch, offset, limit - offset);
	}
	return(buf.toString());
    }

    private String makeHHString(int i) {
	String s = Integer.toHexString(i).toUpperCase();
	if (s.length() == 1) {
	    s = ""0""+s;
	}
	return s;
    }

    
    private String escapeAttr(String base) {
	final int len = base.length() - 1;
	final String str = ""&quot;"";
	int pos;

	char[] ch = base.toCharArray();
	StringBuffer buf = new StringBuffer();
        for(int i=0; i<base.length(); i++){
	    if (ch[i] <= 0x20) {
		buf.append('%');
		buf.append(makeHHString(ch[i]));
	    } 
	    else if (ch[i] > '') {
		int high = (ch[i] >> 6) | 0xC0;
		int low  = (ch[i] & 0x3F) | 0x80;  
		buf.append('%');
		buf.append(makeHHString(high));
		buf.append('%');
		buf.append(makeHHString(low));
	    }
	    else {
		
		
	        switch (ch[i]) {
		    case '' :
		    case '""' :
		    case '{' :
		    case '}' :
		    case '|' :
		    case '\'     :
		    case '	'     :
		    case '^' :
		    case '~' :
		    case '[' :
		    case ']' :
		    case '`' :
		        buf.append('%');
		        buf.append(Integer.toHexString((int)ch[i]));
		        break;
		    case '&' :
			
			buf.append(""&"");
			break;
		    default:	
		        buf.append(ch[i]); break;
	        }
	    } 
  	}
	base = buf.toString();

	while ((pos = base.indexOf('""')) > -1) {
	    if (pos == 0) {
		final String after = base.substring(1);
		base = str + after;
	    }
	    else if (pos == len) {
		final String before = base.substring(0, pos);
		base = before + str;
	    }
	    else {
		final String before = base.substring(0, pos);
		final String after = base.substring(pos+1);
		base = before + str + after;
	    }
	}
	return base;
    }

    
    private String quickAndDirtyUrlEncode(String base) {
	final String pst20 = ""%20"";
	final int len = base.length() - 1;
	int pos;
	
	while ((pos = base.indexOf(' ')) > -1) {
	    if (pos == 0) {
		final String after = base.substring(1);
		base = pst20 + after;
	    }
	    else if (pos == len) {
		final String before = base.substring(0, pos);
		base = before + pst20;
	    }
	    else {
		final String before = base.substring(0, pos);
		final String after = base.substring(pos+1);
		base = before + pst20 + after;
	    }
	}
	return base;
    }

    
    private String getNamespaceURI(String qname, boolean isElement) 
	throws TransletException 
    {
	String uri = EMPTYSTRING;
	int col = qname.lastIndexOf(':');
	final String prefix = (col > 0) ? qname.substring(0, col) : EMPTYSTRING;

	if (prefix != EMPTYSTRING || isElement) { 
	    uri = lookupNamespace(prefix);
	    if (uri == null && !prefix.equals(XMLNS_PREFIX)) {
		BasisLibrary.runTimeError(BasisLibrary.NAMESPACE_PREFIX_ERR,
					  qname.substring(0, col));
	    }
	}
	return uri;
    }

    
    private static String getLocalName(String qname) throws TransletException {
	final int col = qname.lastIndexOf(':');
	return (col > 0) ? qname.substring(col + 1) : null;
    }

    
    private static String patchQName(String qname) throws TransletException {
	final int lastColon = qname.lastIndexOf(':');
	if (lastColon > 0) {
	    final int firstColon = qname.indexOf(':');
	    if (firstColon != lastColon) {
		return qname.substring(0, firstColon) + qname.substring(lastColon);
	    }
	}
	return qname;
    }

    
    public void attribute(String name, final String value)
	throws TransletException {

	if (_outputType == TEXT) return;

	final String patchedName = patchQName(name);
	final String localName = getLocalName(patchedName);
	final String uri = getNamespaceURI(patchedName, false);
	final int index = (localName == null) ?
				_attributes.getIndex(name) :	
				_attributes.getIndex(uri, localName);

	switch(_outputType) {
	case XML:
	    if (!_startTagOpen) {
		BasisLibrary.runTimeError(BasisLibrary.STRAY_ATTRIBUTE_ERR, patchedName);
	    }

	    
	    if (name.startsWith(XMLNS_PREFIX)) {
		namespace(name.length() > 6 ? name.substring(6) : EMPTYSTRING, value);
	    }
	    else {
		if (index >= 0) {	
		    _attributes.setAttribute(index, uri, localName, patchedName, ""CDATA"", 
			escapeString(value));	
		}
		else {
		    _attributes.addAttribute(uri, localName, patchedName, ""CDATA"", 
			escapeString(value));
		}
	    }
	    break;
	case HTML:
	    if (!_startTagOpen) {
		BasisLibrary.runTimeError(BasisLibrary.STRAY_ATTRIBUTE_ERR,name);
	    }

	    
	    final String tmp = name.toLowerCase();
	    if (tmp.equals(HREF_STR) || tmp.equals(SRC_STR) || tmp.equals(CITE_STR)) {
		if (index >= 0) {
		    _attributes.setAttribute(index, EMPTYSTRING, EMPTYSTRING, name, 
			""CDATA"", quickAndDirtyUrlEncode(escapeAttr(value)));
		}
		else {
		    _attributes.addAttribute(EMPTYSTRING, EMPTYSTRING, name, ""CDATA"",
			quickAndDirtyUrlEncode(escapeAttr(value)));
		}
	    }
	    else {
		if (index >= 0) {
		    _attributes.setAttribute(index, EMPTYSTRING, EMPTYSTRING, 
			name, ""CDATA"", escapeNonURLAttr(value));
		}
		else {
		    _attributes.addAttribute(EMPTYSTRING, EMPTYSTRING, 
			name, ""CDATA"", escapeNonURLAttr(value));
		}
	    }
	    break;
	}
    }

    
    private String escapeNonURLAttr(String base) {
	final int len = base.length() - 1;

	char[] ch = base.toCharArray();
	StringBuffer buf = new StringBuffer();
        for(int i=0; i<base.length(); i++){
	    if (ch[i] > '') {
	        buf.append(CHAR_ESC_START);
		buf.append(Integer.toString((int)ch[i]));
	        buf.append(';');
	    }
	    else {
	        buf.append(ch[i]); 
	    } 
  	}
	base = buf.toString();
	return base;
    }


    
    public void endElement(String elementName) throws TransletException {
	try {
	    switch(_outputType) {
	    case TEXT:
		
		return;
	    case XML:
		
		if (_startTagOpen) closeStartTag();
		if (_cdataTagOpen) closeCDATA();

		final String qname = (String) _qnameStack.pop();
		_saxHandler.endElement(getNamespaceURI(qname, true), 
		    getLocalName(qname), qname);

		popNamespaces();
		if (((Integer)_cdataStack.peek()).intValue() == _depth)
		    _cdataStack.pop();
		_depth--;
		return;
	    case HTML:
		
		if (_startTagOpen) closeStartTag();
		_saxHandler.endElement(EMPTYSTRING, EMPTYSTRING, 
		    (String)(_qnameStack.pop()));
		popNamespaces();
		_depth--;		
		return;
	    }

        } catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    public void comment(String comment) throws TransletException {
	try {
	    
            if (_startTagOpen) closeStartTag();
	    if (_cdataTagOpen) closeCDATA();

            
            if (_outputType == UNKNOWN) setTypeInternal(XML);

            
            _saxHandler.characters(BEGCOMM, 0, BEGCOMM_length);
            characters(comment);
            _saxHandler.characters(ENDCOMM, 0, ENDCOMM_length);
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }
    
    
    public void processingInstruction(String target, String data)
	throws TransletException {
        try {
	    
	    if (_startTagOpen) closeStartTag();
	    if (_cdataTagOpen) closeCDATA();

	    
	    if ((_lexHandler != null) && (_outputType == HTML)) {
		if ((_doctypeSystem != null) || (_doctypePublic != null))
		    _lexHandler.startDTD(""HTML"",_doctypePublic,_doctypeSystem);
		_lexHandler = null;
	    }

	    
            _saxHandler.processingInstruction(target, data);
        }
	catch (SAXException e) {
            throw new TransletException(e);
        }
    }

    
    private void initNamespaces() {
	_namespaces = new Hashtable();
	_nodeStack = new Stack();
	_prefixStack = new Stack();

	
	Stack stack;
	_namespaces.put(EMPTYSTRING, stack = new Stack());
	stack.push(EMPTYSTRING);
	_prefixStack.push(EMPTYSTRING);

	_namespaces.put(XML_PREFIX, stack = new Stack());
	stack.push(""http:
	_prefixStack.push(XML_PREFIX);

	_nodeStack.push(new Integer(-1));
	_depth = 0;
    }

    
    private void pushNamespace(String prefix, String uri) throws SAXException {
	
	if (prefix.equals(XML_PREFIX)) return;
	
	Stack stack;
	
	if ((stack = (Stack)_namespaces.get(prefix)) == null) {
	    stack = new Stack();
	    _namespaces.put(prefix, stack);
	}
	
	if (!stack.empty() && uri.equals(stack.peek())) return;
	
	stack.push(uri);

	_prefixStack.push(prefix);
	_nodeStack.push(new Integer(_depth));

	
	_saxHandler.startPrefixMapping(prefix, escapeString(uri));
    }

    
    private void popNamespace(String prefix) throws SAXException {
	
	if (prefix.equals(XML_PREFIX)) return;

	Stack stack;
	if ((stack = (Stack)_namespaces.get(prefix)) != null) {
	    stack.pop();
	    _saxHandler.endPrefixMapping(prefix);
	}
    }

    
    private void popNamespaces() throws TransletException {
	try {
	    while (true) {
		if (_nodeStack.isEmpty()) return;
		Integer i = (Integer)(_nodeStack.peek());
		if (i.intValue() != _depth) return;
		_nodeStack.pop();
		popNamespace((String)_prefixStack.pop());
	    }
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }

    
    private String lookupNamespace(String prefix) {
	final Stack stack = (Stack)_namespaces.get(prefix);
	return stack != null && !stack.isEmpty() ? (String)stack.peek() : null;
    }

    
    public void namespace(final String prefix, final String uri)
	throws TransletException {
	try {
	    if (_startTagOpen)
		pushNamespace(prefix, uri);
	    else {
		if ((prefix == EMPTYSTRING) && (uri == EMPTYSTRING)) return;
		BasisLibrary.runTimeError(BasisLibrary.STRAY_NAMESPACE_ERR,
					  prefix, uri);
	    }
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }

    
    
    public void setType(int type)  {
	try {
	    _outputType = type;
	    if ((_outputType == HTML) || (_outputType == XML))
		_escapeChars = true;
	    if (_encoding == null)
	    	_encoding = ""UTF-8"";
	    if (_saxHandler instanceof DefaultSAXOutputHandler)
		((DefaultSAXOutputHandler)_saxHandler).setOutputType(type);
	}
	catch (SAXException e) { }
    }

    
    public void setIndent(boolean indent) {
	if (_saxHandler instanceof DefaultSAXOutputHandler) {
            ((DefaultSAXOutputHandler)_saxHandler).setIndent(indent);
	}
    } 

    
    public void omitHeader(boolean value) {
	if (_saxHandler instanceof DefaultSAXOutputHandler) {
            ((DefaultSAXOutputHandler)_saxHandler).omitHeader(value);
	}
    }

    
    public void setVersion(String version) {
	if (_saxHandler instanceof DefaultSAXOutputHandler) {
            ((DefaultSAXOutputHandler)_saxHandler).setVersion(version);
	}
    }

    
    public void setStandalone(String standalone) {
	if (_saxHandler instanceof DefaultSAXOutputHandler) {
            ((DefaultSAXOutputHandler)_saxHandler).setStandalone(standalone);
	}
    }

    
    public void setDoctype(String system, String pub) {
	_doctypeSystem = system;
	_doctypePublic = pub;
    }

    
    public void setMediaType(String mediaType) {
	
	
	
	_mediaType = mediaType;
    }

     
    public void setCdataElements(Hashtable elements) {
	_cdata = elements;
    }

}
"
org.apache.xalan.processor.ProcessorUnknown,3,5,0,3,4,3,1,2,3,2.0,8,0.0,0,0.990697674,0.666666667,1,2,1.666666667,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemLiteralResult;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.ElemExtensionCall;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.Constants;
import org.apache.xpath.XPath;
import org.apache.xalan.templates.StylesheetRoot;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;


public class ProcessorUnknown extends ProcessorTemplateElem
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException{}

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException{}
}
"
org.apache.xml.dtm.ref.ChunkedIntArray,9,1,0,3,24,0,2,2,0,0.892857143,353,0.0,1,0.0,0.62962963,0,0,37.44444444,3,1.4444,0,"
package org.apache.xml.dtm.ref;
 
import org.w3c.dom.*;
import org.apache.xml.dtm.*;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;


final class ChunkedIntArray
{
  final int slotsize=4; 
  
  
  static final int lowbits=10; 
  static final int chunkalloc=1<<lowbits;
  static final int lowmask=chunkalloc-1;
  
  ChunksVector chunks=new ChunksVector();
  final int fastArray[] = new int[chunkalloc];
  int lastUsed=0;

  
  ChunkedIntArray(int slotsize)
  {
    if(this.slotsize<slotsize)
      throw new ArrayIndexOutOfBoundsException(XSLMessages.createMessage(XSLTErrorResources.ER_CHUNKEDINTARRAY_NOT_SUPPORTED, new Object[]{Integer.toString(slotsize)})); 
    else if (this.slotsize>slotsize)
      System.out.println(""*****WARNING: ChunkedIntArray(""+slotsize+"") wasting ""+(this.slotsize-slotsize)+"" words per slot"");
    chunks.addElement(fastArray);
  }
  
  int appendSlot(int w0, int w1, int w2, int w3)
  {
    
    {
      final int slotsize=4;
      int newoffset = (lastUsed+1)*slotsize;
      int chunkpos = newoffset >> lowbits;
      int slotpos = (newoffset & lowmask);

      
      if (chunkpos > chunks.size() - 1)
        chunks.addElement(new int[chunkalloc]);
      int[] chunk = chunks.elementAt(chunkpos);
      chunk[slotpos] = w0;
      chunk[slotpos+1] = w1;
      chunk[slotpos+2] = w2;
      chunk[slotpos+3] = w3;

      return ++lastUsed;
    }
  }
  
  int readEntry(int position, int offset) throws ArrayIndexOutOfBoundsException
  {
    
    {
      
      if (offset>=slotsize)
        throw new ArrayIndexOutOfBoundsException(XSLMessages.createMessage(XSLTErrorResources.ER_OFFSET_BIGGER_THAN_SLOT, null)); 
      position*=slotsize;
      int chunkpos = position >> lowbits;
      int slotpos = position & lowmask;
      int[] chunk = chunks.elementAt(chunkpos);
      return chunk[slotpos + offset];
    }
  }
  
  
  
  
  
  
  
  int specialFind(int startPos, int position)
  {
          
          
          int ancestor = startPos;
          while(ancestor > 0)
          {
                
                ancestor*=slotsize;
                int chunkpos = ancestor >> lowbits;
                int slotpos = ancestor & lowmask;
                int[] chunk = chunks.elementAt(chunkpos);
                                                        
                
                
                
                ancestor = chunk[slotpos + 1];

                if(ancestor == position)
                         break;
          }

          if (ancestor <= 0) 
          {
                  return position;
          }
          return -1;
  }
  
  
  int slotsUsed()
  {
    return lastUsed;
  }

  
  void discardLast()
  {
    --lastUsed;
  }

  
  void writeEntry(int position, int offset, int value) throws ArrayIndexOutOfBoundsException
  {
    
    {
      if (offset >= slotsize)
        throw new ArrayIndexOutOfBoundsException(XSLMessages.createMessage(XSLTErrorResources.ER_OFFSET_BIGGER_THAN_SLOT, null)); 
      position*=slotsize;
      int chunkpos = position >> lowbits;
      int slotpos = position & lowmask;
      int[] chunk = chunks.elementAt(chunkpos);
      chunk[slotpos + offset] = value; 
    }
  }

  
  void writeSlot(int position, int w0, int w1, int w2, int w3)
  {
      position *= slotsize;
      int chunkpos = position >> lowbits;
      int slotpos = (position & lowmask);

    
    if (chunkpos > chunks.size() - 1)
      chunks.addElement(new int[chunkalloc]);
    int[] chunk = chunks.elementAt(chunkpos);
    chunk[slotpos] = w0;
    chunk[slotpos + 1] = w1;
    chunk[slotpos + 2] = w2;
    chunk[slotpos + 3] = w3;
  }

  
  void readSlot(int position, int[] buffer)
  {
    
    {
      
      position *= slotsize;
      int chunkpos = position >> lowbits;
      int slotpos = (position & lowmask);

      
      if (chunkpos > chunks.size() - 1)
        chunks.addElement(new int[chunkalloc]);
      int[] chunk = chunks.elementAt(chunkpos);
      System.arraycopy(chunk,slotpos,buffer,0,slotsize);
    }
  }

  class ChunksVector
  {
    final int BLOCKSIZE = 64;
    int[] m_map[] = new int[BLOCKSIZE][];
    int m_mapSize = BLOCKSIZE;
    int pos = 0;
    
    ChunksVector()
    {
    }
    
    final int size()
    {
      return pos;
    }
    
    void addElement(int[] value)
    {
      if(pos >= m_mapSize)
      {
        int orgMapSize = m_mapSize;
        while(pos >= m_mapSize)
          m_mapSize+=BLOCKSIZE;
        int[] newMap[] = new int[m_mapSize][];
        System.arraycopy(m_map, 0, newMap, 0, orgMapSize);
        m_map = newMap;
      }
      
      
      m_map[pos] = value;
      pos++;
    }
    
    final int[] elementAt(int pos)
    {
      return m_map[pos];
    }
  }
}
"
org.apache.xalan.xsltc.compiler.BinOpExpr,7,3,0,15,36,0,0,15,6,0.814814815,242,0.444444444,2,0.934210526,0.285714286,2,8,32.28571429,3,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class BinOpExpr extends Expression {
    public static final int PLUS  = 0;
    public static final int MINUS = 1;
    public static final int TIMES = 2;
    public static final int DIV   = 3;
    public static final int MOD   = 4;
	
    private static final String[] Ops = {
	""+"", ""-"", ""*"", ""/"", ""%""
    };

    private int _op;
    private Expression _left, _right;
	
    public BinOpExpr(int op, Expression left, Expression right) {
	_op = op;
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    
    public boolean hasPositionCall() {
	if (_left.hasPositionCall()) return true;
	if (_right.hasPositionCall()) return true;
	return false;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tleft = _left.typeCheck(stable); 
	final Type tright = _right.typeCheck(stable);
	final MethodType ptype = lookupPrimop(stable, Ops[_op],
					      new MethodType(Type.Void,
							     tleft, tright)); 
	if (ptype != null) {
	    final Type arg1 = (Type) ptype.argsType().elementAt(0);
	    if (!arg1.identicalTo(tleft)) {
		_left = new CastExpr(_left, arg1);
	    }
	    final Type arg2 = (Type) ptype.argsType().elementAt(1);
	    if (!arg2.identicalTo(tright)) {
		_right = new CastExpr(_right, arg1);
	    }
	    return _type = ptype.resultType();
	}
	throw new TypeCheckError(this);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();

	_left.translate(classGen, methodGen);
	_right.translate(classGen, methodGen);

	switch (_op) {
	case PLUS:
	    il.append(_type.ADD());
	    break;
	case MINUS:
	    il.append(_type.SUB());
	    break;
	case TIMES:
	    il.append(_type.MUL());
	    break;
	case DIV:
	    il.append(_type.DIV());
	    break;
	case MOD:
	    il.append(_type.REM());
	    break;
	default:
	    ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_BINARY_OP_ERR, this);
	    getParser().reportError(Constants.ERROR, msg);
	}
    }

    public String toString() {
	return Ops[_op] + '(' + _left + "", "" + _right + ')';
    }
} 
"
org.apache.xalan.serialize.SerializerToText,16,2,0,4,24,120,2,2,14,2.0,229,0.0,0,0.821428571,0.3046875,1,7,13.3125,1,0.9375,0,"
package org.apache.xalan.serialize;

import org.xml.sax.*;

import java.util.*;

import java.io.*;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.templates.OutputProperties;

import javax.xml.transform.OutputKeys;


public class SerializerToText extends SerializerToXML
{

  
  public SerializerToText()
  {
    super();
  }

   
  public void setDocumentLocator(Locator locator)
  {

    
  }

  
  public void startDocument() throws org.xml.sax.SAXException
  {

    
  }

  
  public void endDocument() throws org.xml.sax.SAXException
  {
    flushWriter();
  }

  
  public void startElement(
          String namespaceURI, String localName, String name, Attributes atts)
            throws org.xml.sax.SAXException
  {

    
  }

  
  public void endElement(String namespaceURI, String localName, String name)
          throws org.xml.sax.SAXException
  {

    
  }

  
  public void characters(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    
    try
    {
      writeNormalizedChars(ch, start, length, false);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
    this.flushWriter();

    
  }

  
  public void charactersRaw(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    
    try
    {
      writeNormalizedChars(ch, start, length, false);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
    flushWriter();

    
  }
  
  
  protected int writeUTF16Surrogate(char c, char ch[], int i, int end)
          throws IOException, org.xml.sax.SAXException
  {

    
    int surrogateValue = getURF16SurrogateValue(c, ch, i, end);

    i++;

    
    m_writer.write(surrogateValue);

    return i;
  }

  
  
  void writeNormalizedChars(char ch[], int start, int length, boolean isCData)
          throws IOException, org.xml.sax.SAXException
  {

    int end = start + length;

    for (int i = start; i < end; i++)
    {
      char c = ch[i];

      if (CharInfo.S_LINEFEED == c)
      {
        m_writer.write(m_lineSep, 0, m_lineSepLen);
      }
      else if (isCData && (c > m_maxCharacter))
      {
        if (i != 0)
          m_writer.write(""]]>"");

        
        if (isUTF16Surrogate(c))
        {
          i = writeUTF16Surrogate(c, ch, i, end);
        }
        else
        {
          m_writer.write(c);
        }

        if ((i != 0) && (i < (end - 1)))
          m_writer.write(""<![CDATA["");
      }
      else if (isCData
               && ((i < (end - 2)) && (']' == c) && (']' == ch[i + 1])
                   && ('>' == ch[i + 2])))
      {
        m_writer.write(""]]]]><![CDATA[>"");

        i += 2;
      }
      else
      {
        if (c <= m_maxCharacter)
        {
          m_writer.write(c);
        }

        else if (isUTF16Surrogate(c))
        {
          i = writeUTF16Surrogate(c, ch, i, end);
        }
        else
        {
          m_writer.write(c);
        }
      }
    }
  }

  
  public void cdata(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    
    try
    {
      writeNormalizedChars(ch, start, length, false);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
    flushWriter();

    
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    try
    {
      writeNormalizedChars(ch, start, length, false);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
    flushWriter();
  }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {

    
  }

  
  public void comment(String data) throws org.xml.sax.SAXException
  {
    
  }

  
  public void comment(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {
    
  }

  
  public void entityReference(String name) throws org.xml.sax.SAXException
  {

    
  }
}
"
org.apache.xml.utils.PrefixResolver,4,1,0,67,4,6,67,0,4,2.0,4,0.0,0,0.0,0.583333333,0,0,0.0,1,1.0,0,"
package org.apache.xml.utils;


public interface PrefixResolver
{

  
  String getNamespaceForPrefix(String prefix);

  
  String getNamespaceForPrefix(String prefix, org.w3c.dom.Node context);

  
  public String getBaseIdentifier();
  
  public boolean handlesNullPrefixes();
}
"
org.apache.xalan.extensions.ExtensionHandlerJavaPackage,6,3,0,10,44,15,0,10,5,1.0,615,0.0,0,0.615384615,0.375,3,6,101.1666667,7,2.0,2,"
package org.apache.xalan.extensions;

import java.util.Hashtable;
import java.util.Vector;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.io.IOException;




import org.apache.xml.dtm.DTM;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.QName;

import org.apache.xpath.objects.XObject;
import javax.xml.transform.TransformerException;




public class ExtensionHandlerJavaPackage extends ExtensionHandlerJava
{

  
  public ExtensionHandlerJavaPackage(String namespaceUri,
                                     String scriptLang,
                                     String className)
  {
    super(namespaceUri, scriptLang, className);
  }


  

  public boolean isFunctionAvailable(String function) 
  {
    try
    {
      String fullName = m_className + function;
      int lastDot = fullName.lastIndexOf(""."");
      if (lastDot >= 0)
      {
        Class myClass = getClassForName(fullName.substring(0, lastDot));
        Method[] methods = myClass.getMethods();
        int nMethods = methods.length;
        function = fullName.substring(lastDot + 1);
        for (int i = 0; i < nMethods; i++)
        {
          if (methods[i].getName().equals(function))
            return true;
        }
      }
    }
    catch (ClassNotFoundException cnfe) {}

    return false;
  }


  

  public boolean isElementAvailable(String element) 
  {
    try
    {
      String fullName = m_className + element;
      int lastDot = fullName.lastIndexOf(""."");
      if (lastDot >= 0)
      {
        Class myClass = getClassForName(fullName.substring(0, lastDot));
        Method[] methods = myClass.getMethods();
        int nMethods = methods.length;
        element = fullName.substring(lastDot + 1);
        for (int i = 0; i < nMethods; i++)
        {
          if (methods[i].getName().equals(element))
          {
            Class[] paramTypes = methods[i].getParameterTypes();
            if ( (paramTypes.length == 2)
              && paramTypes[0].isAssignableFrom(
                                     org.apache.xalan.extensions.XSLProcessorContext.class)
              && paramTypes[1].isAssignableFrom(
                                       org.apache.xalan.templates.ElemExtensionCall.class) )
            {
              return true;
            }
          }
        }
      }
    }
    catch (ClassNotFoundException cnfe) {}

    return false;
  }


  

  public Object callFunction (String funcName, 
                              Vector args, 
                              Object methodKey,
                              ExpressionContext exprContext)
    throws TransformerException 
  {

    String className;
    String methodName;
    Class  classObj;
    Object targetObject;
    int lastDot = funcName.lastIndexOf(""."");
    Object[] methodArgs;
    Object[][] convertedArgs;
    Class[] paramTypes;

    try
    {

      if (funcName.endsWith("".new"")) {                   

        methodArgs = new Object[args.size()];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i);
        }
        Constructor c = (Constructor) getFromCache(methodKey, null, methodArgs);
        if (c != null)
        {
          try
          {
            paramTypes = c.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            return c.newInstance(convertedArgs[0]);
          }
          catch(Exception e)
          {
            
          }
        }
        className = m_className + funcName.substring(0, lastDot);
        try
        {
          classObj = getClassForName(className);
        }
        catch (ClassNotFoundException e) 
        {
          throw new TransformerException(e);
        }
        c = MethodResolver.getConstructor(classObj, 
                                          methodArgs,
                                          convertedArgs,
                                          exprContext);
        putToCache(methodKey, null, methodArgs, c);
        return c.newInstance(convertedArgs[0]);
      }

      else if (-1 != lastDot) {                         

        methodArgs = new Object[args.size()];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i);
        }
        Method m = (Method) getFromCache(methodKey, null, methodArgs);
        if (m != null)
        {
          try
          {
            paramTypes = m.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            return m.invoke(null, convertedArgs[0]);
          }
          catch(Exception e)
          {
            
          }
        }
        className = m_className + funcName.substring(0, lastDot);
        methodName = funcName.substring(lastDot + 1);
        try
        {
          classObj = getClassForName(className);
        }
        catch (ClassNotFoundException e) 
        {
          throw new TransformerException(e);
        }
        m = MethodResolver.getMethod(classObj,
                                     methodName,
                                     methodArgs, 
                                     convertedArgs,
                                     exprContext,
                                     MethodResolver.STATIC_ONLY);
        putToCache(methodKey, null, methodArgs, m);
        return m.invoke(null, convertedArgs[0]);
      }

      else {                                            

        if (args.size() < 1)
        {
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_INSTANCE_MTHD_CALL_REQUIRES, new Object[]{funcName })); 
                                    
        }
        targetObject = args.elementAt(0);
        if (targetObject instanceof XObject)          
          targetObject = ((XObject) targetObject).object();
        methodArgs = new Object[args.size() - 1];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i+1);
        }
        Method m = (Method) getFromCache(methodKey, targetObject, methodArgs);
        if (m != null)
        {
          try
          {
            paramTypes = m.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            return m.invoke(targetObject, convertedArgs[0]);
          }
          catch(Exception e)
          {
            
          }
        }
        classObj = targetObject.getClass();
        m = MethodResolver.getMethod(classObj,
                                     funcName,
                                     methodArgs, 
                                     convertedArgs,
                                     exprContext,
                                     MethodResolver.INSTANCE_ONLY);
        putToCache(methodKey, targetObject, methodArgs, m);
        return m.invoke(targetObject, convertedArgs[0]);
      }
    }
    catch (InvocationTargetException ite)
    {
      Throwable realException = ite.getTargetException();
      if (realException instanceof Exception)
        throw new TransformerException((Exception) realException);
      else
        throw new TransformerException(ite);
    }
    catch (Exception e)
    {
      
      throw new TransformerException(e);
    }
  }


  

  public void processElement (String localPart,
                              ElemTemplateElement element,
                              TransformerImpl transformer,
                              Stylesheet stylesheetTree,
                              Object methodKey)
    throws TransformerException, IOException
  {
    Object result = null;
    Class classObj;

    Method m = (Method) getFromCache(methodKey, null, null);
    if (null == m)
    {
      try
      {
        String fullName = m_className + localPart;
        int lastDot = fullName.lastIndexOf(""."");
        if (lastDot < 0)
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_ELEMENT_NAME, new Object[]{fullName })); 
        try
        {
          classObj = getClassForName(fullName.substring(0, lastDot));
        }
        catch (ClassNotFoundException e) 
        {
          throw new TransformerException(e);
        }
        localPart = fullName.substring(lastDot + 1);
        m = MethodResolver.getElementMethod(classObj, localPart);
        if (!Modifier.isStatic(m.getModifiers()))
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_ELEMENT_NAME_METHOD_STATIC, new Object[]{fullName })); 
      }
      catch (Exception e)
      {
        
        throw new TransformerException (e);
      }
      putToCache(methodKey, null, null, m);
    }

    XSLProcessorContext xpc = new XSLProcessorContext(transformer, 
                                                      stylesheetTree);

    try
    {
      result = m.invoke(null, new Object[] {xpc, element});
    }
    catch (Exception e)
    {
      
      throw new TransformerException (e);
    }

    if (result != null)
    {
      xpc.outputToResultTree (stylesheetTree, result);
    }
 
  }

}
"
org.apache.xml.utils.XMLStringFactory,5,1,1,17,6,10,15,2,5,2.0,8,0.0,0,0.0,0.4,0,0,0.6,1,0.8,0,"
package org.apache.xml.utils;


public abstract class XMLStringFactory
{

  
  public abstract XMLString newstr(String string);

  
  public abstract XMLString newstr(FastStringBuffer string, int start, 
                                   int length);

  
  public abstract XMLString newstr(char[] string, int start, 
                                   int length);
                                   
  
  public abstract XMLString emptystr();
}
"
org.apache.xalan.templates.ElemComment,5,3,0,4,17,10,0,4,5,2.0,74,0.0,0,0.98,0.466666667,2,5,13.8,16,3.8,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;


public class ElemComment extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_COMMENT;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_COMMENT_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
    try
    {
      
      
      
      
      
      
      
      
      String data = transformer.transformToString(this);

      transformer.getResultTreeHandler().comment(data);
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEndEvent(this);
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {

    
    case Constants.ELEMNAME_TEXTLITERALRESULT :
    case Constants.ELEMNAME_APPLY_TEMPLATES :
    case Constants.ELEMNAME_APPLY_IMPORTS :
    case Constants.ELEMNAME_CALLTEMPLATE :
    case Constants.ELEMNAME_FOREACH :
    case Constants.ELEMNAME_VALUEOF :
    case Constants.ELEMNAME_COPY_OF :
    case Constants.ELEMNAME_NUMBER :
    case Constants.ELEMNAME_CHOOSE :
    case Constants.ELEMNAME_IF :
    case Constants.ELEMNAME_TEXT :
    case Constants.ELEMNAME_COPY :
    case Constants.ELEMNAME_VARIABLE :
    case Constants.ELEMNAME_MESSAGE :

      
      
      
      
      
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
}
"
org.apache.xpath.res.XPATHErrorResources,8,3,0,1,21,28,1,0,7,1.142857143,273,0.0,0,0.857142857,0.225,0,0,17.375,2,0.875,0,"
package org.apache.xpath.res;

import java.io.IOException;
import java.io.InputStream;
import java.text.DecimalFormat;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;


public class XPATHErrorResources extends PropertyResourceBundle
{
  
  public XPATHErrorResources()
  	throws java.io.IOException
  {
    super(null);
  }
  
  public XPATHErrorResources(InputStream is) 
  	throws java.io.IOException
  {
  	super(is);
  }

  
  public static final String ERROR_SUFFIX = ""ER"";

  
  public static final String WARNING_SUFFIX = ""WR"";

















  

  

  
  public static final int ERROR0000 = 0;

  
  public static final int ER_CURRENT_NOT_ALLOWED_IN_MATCH = 1;


  
  public static final int ER_CURRENT_TAKES_NO_ARGS = 2;


  
  public static final int ER_DOCUMENT_REPLACED = 3;


  
  public static final int ER_CONTEXT_HAS_NO_OWNERDOC = 4;


  
  public static final int ER_LOCALNAME_HAS_TOO_MANY_ARGS = 5;


  
  public static final int ER_NAMESPACEURI_HAS_TOO_MANY_ARGS = 6;


  
  public static final int ER_NORMALIZESPACE_HAS_TOO_MANY_ARGS = 7;


  
  public static final int ER_NUMBER_HAS_TOO_MANY_ARGS = 8;


  
  public static final int ER_NAME_HAS_TOO_MANY_ARGS = 9;


  
  public static final int ER_STRING_HAS_TOO_MANY_ARGS = 10;


  
  public static final int ER_STRINGLENGTH_HAS_TOO_MANY_ARGS = 11;


  
  public static final int ER_TRANSLATE_TAKES_3_ARGS = 12;


  
  public static final int ER_UNPARSEDENTITYURI_TAKES_1_ARG = 13;


  
  public static final int ER_NAMESPACEAXIS_NOT_IMPLEMENTED = 14;


  
  public static final int ER_UNKNOWN_AXIS = 15;


  
  public static final int ER_UNKNOWN_MATCH_OPERATION = 16;


  
  public static final int ER_INCORRECT_ARG_LENGTH = 17;


  
  public static final int ER_CANT_CONVERT_TO_NUMBER = 18;


  
  public static final int ER_CANT_CONVERT_TO_NODELIST = 19;


  
  public static final int ER_CANT_CONVERT_TO_MUTABLENODELIST = 20;


  
  public static final int ER_CANT_CONVERT_TO_TYPE = 21;


  
  public static final int ER_EXPECTED_MATCH_PATTERN = 22;


  
  public static final int ER_COULDNOT_GET_VAR_NAMED = 23;


  
  public static final int ER_UNKNOWN_OPCODE = 24;


  
  public static final int ER_EXTRA_ILLEGAL_TOKENS = 25;


  
  public static final int ER_EXPECTED_DOUBLE_QUOTE = 26;


  
  public static final int ER_EXPECTED_SINGLE_QUOTE = 27;


  
  public static final int ER_EMPTY_EXPRESSION = 28;


  
  public static final int ER_EXPECTED_BUT_FOUND = 29;


  
  public static final int ER_INCORRECT_PROGRAMMER_ASSERTION = 30;


  
  public static final int ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL = 31;


  
  public static final int ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG = 32;


  
  public static final int ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG = 33;


  
  public static final int ER_PREDICATE_ILLEGAL_SYNTAX = 34;


  
  public static final int ER_ILLEGAL_AXIS_NAME = 35;


  
  public static final int ER_UNKNOWN_NODETYPE = 36;


  
  public static final int ER_PATTERN_LITERAL_NEEDS_BE_QUOTED = 37;


  
  public static final int ER_COULDNOT_BE_FORMATTED_TO_NUMBER = 38;


  
  public static final int ER_COULDNOT_CREATE_XMLPROCESSORLIAISON = 39;


  
  public static final int ER_DIDNOT_FIND_XPATH_SELECT_EXP = 40;


  
  public static final int ER_COULDNOT_FIND_ENDOP_AFTER_OPLOCATIONPATH = 41;


  
  public static final int ER_ERROR_OCCURED = 42;


  
  public static final int ER_ILLEGAL_VARIABLE_REFERENCE = 43;


  
  public static final int ER_AXES_NOT_ALLOWED = 44;


  
  public static final int ER_KEY_HAS_TOO_MANY_ARGS = 45;


  
  public static final int ER_COUNT_TAKES_1_ARG = 46;


  
  public static final int ER_COULDNOT_FIND_FUNCTION = 47;


  
  public static final int ER_UNSUPPORTED_ENCODING = 48;


  
  public static final int ER_PROBLEM_IN_DTM_NEXTSIBLING = 49;


  
  public static final int ER_CANNOT_WRITE_TO_EMPTYNODELISTIMPL = 50;


  
  public static final int ER_SETDOMFACTORY_NOT_SUPPORTED = 51;


  
  public static final int ER_PREFIX_MUST_RESOLVE = 52;


  
  public static final int ER_PARSE_NOT_SUPPORTED = 53;


  
  public static final int ER_CREATEDOCUMENT_NOT_SUPPORTED = 54;


  
  public static final int ER_CHILD_HAS_NO_OWNER_DOCUMENT = 55;


  
  public static final int ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT = 56;


  
  public static final int ER_SAX_API_NOT_HANDLED = 57;


  
  public static final int ER_IGNORABLE_WHITESPACE_NOT_HANDLED = 58;


  
  public static final int ER_DTM_CANNOT_HANDLE_NODES = 59;


  
  public static final int ER_XERCES_CANNOT_HANDLE_NODES = 60;


  
  public static final int ER_XERCES_PARSE_ERROR_DETAILS = 61;


  
  public static final int ER_XERCES_PARSE_ERROR = 62;


  
  public static final int ER_CANT_OUTPUT_TEXT_BEFORE_DOC = 63;


  
  public static final int ER_CANT_HAVE_MORE_THAN_ONE_ROOT = 64;


  
  public static final int ER_INVALID_UTF16_SURROGATE = 65;


  
  public static final int ER_OIERROR = 66;


  
  public static final int ER_CANNOT_CREATE_URL = 67;


  
  public static final int ER_XPATH_READOBJECT = 68;

  
  
  public static final int ER_FUNCTION_TOKEN_NOT_FOUND = 69;

  
   
  public static final int ER_ARG_LOCALNAME_NULL = 70;

  
   
  public static final int ER_CANNOT_DEAL_XPATH_TYPE = 71;

  
   
  public static final int ER_NODESET_NOT_MUTABLE = 72;

  
   
  public static final int ER_NODESETDTM_NOT_MUTABLE = 73;

  
   
  public static final int ER_VAR_NOT_RESOLVABLE = 74;

  
   
  public static final int ER_NULL_ERROR_HANDLER = 75;

  
   
  public static final int ER_PROG_ASSERT_UNKNOWN_OPCODE = 76;

  
   
  public static final int ER_ZERO_OR_ONE = 77;

  
  
   
  public static final int ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = 78;

  
   
  public static final int ER_ASNODEITERATOR_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER = 79;

  
   
  public static final int ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS = 80;

  
   
  public static final int ER_COULD_NOT_FIND_VAR = 81;

  
   
  public static final int ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING = 82;

  
   
  public static final int ER_FASTSTRINGBUFFER_CANNOT_BE_NULL = 83;

  
   
  public static final int ER_TWO_OR_THREE = 84;

  

  public static final int ER_VARIABLE_ACCESSED_BEFORE_BIND = 85;
  
  
  public static final int ER_FSB_CANNOT_TAKE_STRING = 86;
  
  
  public static final int ER_SETTING_WALKER_ROOT_TO_NULL = 87;
  
  
  public static final int ER_NODESETDTM_CANNOT_ITERATE = 88;
  
  
  public static final int ER_NODESET_CANNOT_ITERATE = 89;

  
  public static final int ER_NODESETDTM_CANNOT_INDEX = 90;
  
  
  public static final int ER_NODESET_CANNOT_INDEX = 91;

  
  public static final int ER_CANNOT_CALL_SETSHOULDCACHENODE = 92;
  
  
  public static final int ER_ONLY_ALLOWS = 93;
  
  
  public static final int ER_UNKNOWN_STEP = 94;
  
  
  public static final int ER_EXPECTED_REL_LOC_PATH = 95;


   
  public static final int ER_EXPECTED_LOC_PATH = 96;


   
  public static final int ER_EXPECTED_LOC_STEP = 97;


   
  public static final int ER_EXPECTED_NODE_TEST = 98;


   
  public static final int ER_EXPECTED_STEP_PATTERN = 99;

  
   
  public static final int ER_EXPECTED_REL_PATH_PATTERN = 100;
  
    
  public static final int ER_ARG_LOCALNAME_INVALID = 101;

  
  public static final int ER_ARG_PREFIX_INVALID = 102;

 



  
  

  
  public static final int WG_LOCALE_NAME_NOT_HANDLED = 1;


  
  public static final int WG_PROPERTY_NOT_SUPPORTED = 2;


  
  public static final int WG_DONT_DO_ANYTHING_WITH_NS = 3;


  
  public static final int WG_SECURITY_EXCEPTION = 4;


  
  public static final int WG_QUO_NO_LONGER_DEFINED = 5;


  
  public static final int WG_NEED_DERIVED_OBJECT_TO_IMPLEMENT_NODETEST = 6;


  
  public static final int WG_FUNCTION_TOKEN_NOT_FOUND = 7;


  
  public static final int WG_COULDNOT_FIND_FUNCTION = 8;


  
  public static final int WG_CANNOT_MAKE_URL_FROM = 9;


  
  public static final int WG_EXPAND_ENTITIES_NOT_SUPPORTED = 10;


  
  public static final int WG_ILLEGAL_VARIABLE_REFERENCE = 11;


  
  public static final int WG_UNSUPPORTED_ENCODING = 12;


  

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""Error: "";

  
  public static final String WARNING_HEADER = ""Warning: "";

  
  public static final String XSL_HEADER = ""XSL "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";











  
  public static final ResourceBundle loadResourceBundle(String className)
          throws MissingResourceException
  {

    Locale locale = Locale.getDefault();
    String suffix = getResourceSuffix(locale);

    try
    {

      
      return ResourceBundle.getBundle(className
              + suffix, locale);
    }
    catch (MissingResourceException e)
    {
      try  
      {

        
        
        return ResourceBundle.getBundle(className,
                new Locale(""en"", ""US""));
      }
      catch (MissingResourceException e2)
      {

        
        
        throw new MissingResourceException(
          ""Could not load any resource bundles."", className, """");
      }
    }
  }

  
  private static final String getResourceSuffix(Locale locale)
  {

    String suffix = ""_"" + locale.getLanguage();
    String country = locale.getCountry();

    if (country.equals(""TW""))
      suffix += ""_"" + country;

    return suffix;
  }

  
  public static String getMessageKey(int errorCode)
  {




    {
      DecimalFormat df = new DecimalFormat(""0000"");

      return ERROR_SUFFIX + df.format(errorCode);
    }
  }

  
  public static String getWarningKey(int errorCode)
  {




    {
      DecimalFormat df = new DecimalFormat(""0000"");

      return WARNING_SUFFIX + df.format(errorCode);
    }
  }

  
  public static String getMKey(int errorCode)
  {




    {
      DecimalFormat df = new DecimalFormat(""0000"");

      return ERROR_SUFFIX + df.format(errorCode);
    }
  }

  
  public static String getWKey(int errorCode)
  {




    {
      DecimalFormat df = new DecimalFormat(""0000"");

      return WARNING_SUFFIX + df.format(errorCode);
    }
  }
}
"
org.apache.xpath.axes.MatchPatternIterator,5,5,0,13,23,4,1,13,3,0.75,251,1.0,2,0.968992248,0.44,1,5,48.4,10,3.0,1,"
package org.apache.xpath.axes;

import java.util.Stack;

import org.apache.xpath.Expression;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.XPathContext;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.axes.SubContextList;
import org.apache.xpath.compiler.PsuedoNames;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.patterns.StepPattern;
import org.apache.xpath.VariableStack;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTMAxisTraverser;


public class MatchPatternIterator extends LocPathIterator
{

  
  protected StepPattern m_pattern;

  
  protected int m_superAxis = -1;

  
  protected DTMAxisTraverser m_traverser;
  
  
  private static final boolean DEBUG = false;
  


  
  MatchPatternIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {

    super(compiler, opPos, analysis, false);

    int firstStepPos = compiler.getFirstChildPos(opPos);

    m_pattern = WalkerFactory.loadSteps(this, compiler, firstStepPos, 0); 

    boolean fromRoot = false;
    boolean walkBack = false;
    boolean walkDescendants = false;
    boolean walkAttributes = false;

    if (0 != (analysis & (WalkerFactory.BIT_ROOT | 
                          WalkerFactory.BIT_ANY_DESCENDANT_FROM_ROOT)))
      fromRoot = true;
      
    if (0 != (analysis
              & (WalkerFactory.BIT_ANCESTOR
                 | WalkerFactory.BIT_ANCESTOR_OR_SELF
                 | WalkerFactory.BIT_PRECEDING
                 | WalkerFactory.BIT_PRECEDING_SIBLING 
                 | WalkerFactory.BIT_FOLLOWING
                 | WalkerFactory.BIT_FOLLOWING_SIBLING
                 | WalkerFactory.BIT_PARENT | WalkerFactory.BIT_FILTER)))
      walkBack = true;

    if (0 != (analysis
              & (WalkerFactory.BIT_DESCENDANT_OR_SELF
                 | WalkerFactory.BIT_DESCENDANT
                 | WalkerFactory.BIT_CHILD)))
      walkDescendants = true;

    if (0 != (analysis
              & (WalkerFactory.BIT_ATTRIBUTE | WalkerFactory.BIT_NAMESPACE)))
      walkAttributes = true;
      
    if(false || DEBUG)
    {
      System.out.print(""analysis: ""+Integer.toBinaryString(analysis));
      System.out.println("", ""+WalkerFactory.getAnalysisString(analysis));
    }
      
    if(fromRoot || walkBack)
    {
      if(walkAttributes)
      {
        m_superAxis = Axis.ALL;
      }
      else
      {
        m_superAxis = Axis.DESCENDANTSFROMROOT;
      }
    }
    else if(walkDescendants)
    {
      if(walkAttributes)
      {
        m_superAxis = Axis.ALLFROMNODE;
      }
      else
      {
        m_superAxis = Axis.DESCENDANTORSELF;
      }
    }
    else
    {
      m_superAxis = Axis.ALL;
    }
    if(false || DEBUG)
    {
      System.out.println(""axis: ""+Axis.names[m_superAxis]);
    }
    
  }
  
  
  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    m_traverser = m_cdtm.getAxisTraverser(m_superAxis);
  }
  
  
  protected int getNextNode()
  {
    m_lastFetched = (DTM.NULL == m_lastFetched)
                     ? m_traverser.first(m_context)
                     : m_traverser.next(m_context, m_lastFetched);
    return m_lastFetched;
  }

  
  public int nextNode()
  {      
  	if(m_foundLast)
  		return DTM.NULL;

    int next;
    
    org.apache.xpath.VariableStack vars;
    int savedStart;
    if (-1 != m_stackFrame)
    {
      vars = m_execContext.getVarStack();

      
      savedStart = vars.getStackFrame();

      vars.setStackFrame(m_stackFrame);
    }
    else
    {
      
      vars = null;
      savedStart = 0;
    }
    
    try
    {
      if(DEBUG)
        System.out.println(""m_pattern""+m_pattern.toString());

      do
      {
        next = getNextNode();
  
        if (DTM.NULL != next)
        {
          if(DTMIterator.FILTER_ACCEPT == acceptNode(next, m_execContext))
            break;
          else
            continue;
        }
        else
          break;
      }
      while (next != DTM.NULL);
      
      if (DTM.NULL != next)
      {
        if(DEBUG)
        {
          System.out.println(""next: ""+next);
          System.out.println(""name: ""+m_cdtm.getNodeName(next));
        }
        incrementCurrentPos();
  
        return next;
      }
      else
      {
        m_foundLast = true;
  
        return DTM.NULL;
      }
    }
    finally
    {
      if (-1 != m_stackFrame)
      {
        
        vars.setStackFrame(savedStart);
      }
    }

  }
  
  
  public short acceptNode(int n, XPathContext xctxt)
  {

    try
    {
      xctxt.pushCurrentNode(n);
      xctxt.pushIteratorRoot(m_context);
      if(DEBUG)
      {
        System.out.println(""traverser: ""+m_traverser);
        System.out.print(""node: ""+n);
        System.out.println("", ""+m_cdtm.getNodeName(n));
        
        System.out.println(""pattern: ""+m_pattern.toString());
        m_pattern.debugWhatToShow(m_pattern.getWhatToShow());
      }
      
      XObject score = m_pattern.execute(xctxt);
      
      if(DEBUG)
      {
        
        System.out.println(""score: ""+score);
        System.out.println(""skip: ""+(score == NodeTest.SCORE_NONE));
      }

      
::acceptNode - score: ""+score.num()+""::"");
      return (score == NodeTest.SCORE_NONE) ? DTMIterator.FILTER_SKIP 
                    : DTMIterator.FILTER_ACCEPT;
    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new RuntimeException(se.getMessage());
    }
    finally
    {
      xctxt.popCurrentNode();
      xctxt.popIteratorRoot();
    }

  }

}
"
org.apache.xalan.xsltc.compiler.Constants,0,1,0,6,0,0,5,1,0,2.0,188,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.InstructionConstants;

public interface Constants extends InstructionConstants {

    

    
    
    public final int INTERNAL        = 0;
    
    
    public final int UNSUPPORTED     = 1;
    
    
    public final int FATAL           = 2;
    
    
    public final int ERROR           = 3;
    
    
    public final int WARNING         = 4;

    public static final String EMPTYSTRING = """";

    public static final String NAMESPACE_FEATURE =
	""http:

    public static final String TRANSLET_INTF
	= ""org.apache.xalan.xsltc.Translet"";
    public static final String TRANSLET_INTF_SIG        
	= ""Lorg/apache/xalan/xsltc/Translet;"";
    
    public static final String ATTRIBUTES_SIG 
	= ""Lorg/apache/xalan/xsltc/runtime/Attributes;"";
    public static final String NODE_ITERATOR_SIG
	= ""Lorg/apache/xalan/xsltc/NodeIterator;"";
    public static final String DOM_INTF_SIG
	= ""Lorg/apache/xalan/xsltc/DOM;"";
    public static final String DOM_IMPL_CLASS
	= ""org/apache/xalan/xsltc/dom/DOMImpl"";
    public static final String DOM_IMPL_SIG
	= ""Lorg/apache/xalan/xsltc/dom/DOMImpl;"";
    public static final String DOM_ADAPTER_CLASS
	= ""org/apache/xalan/xsltc/dom/DOMAdapter"";
    public static final String DOM_ADAPTER_SIG
	= ""Lorg/apache/xalan/xsltc/dom/DOMAdapter;"";
    public static final String MULTI_DOM_CLASS
	= ""org.apache.xalan.xsltc.dom.MultiDOM"";
    public static final String MULTI_DOM_SIG
	= ""Lorg/apache/xalan/xsltc/dom/MultiDOM;"";

    public static final String STRING    
	= ""java.lang.String"";

    public static final int ACC_PUBLIC    
	= org.apache.bcel.Constants.ACC_PUBLIC;
    public static final int ACC_SUPER     
	= org.apache.bcel.Constants.ACC_SUPER;
    public static final int ACC_FINAL     
	= org.apache.bcel.Constants.ACC_FINAL;
    public static final int ACC_PRIVATE   
	= org.apache.bcel.Constants.ACC_PRIVATE;
    public static final int ACC_PROTECTED 
	= org.apache.bcel.Constants.ACC_PROTECTED;
    public static final int ACC_STATIC
	= org.apache.bcel.Constants.ACC_STATIC;

    public static final String STRING_SIG         
	= ""Ljava/lang/String;"";
    public static final String STRING_BUFFER_SIG  
	= ""Ljava/lang/StringBuffer;"";
    public static final String OBJECT_SIG         
	= ""Ljava/lang/Object;"";
    public static final String DOUBLE_SIG         
	= ""Ljava/lang/Double;"";
    public static final String INTEGER_SIG        
	= ""Ljava/lang/Integer;"";
    public static final String COLLATOR_CLASS
        = ""java/text/Collator"";
    public static final String COLLATOR_SIG
        = ""Ljava/text/Collator;"";

    public static final String NODE               
	= ""int"";
    public static final String NODE_ITERATOR      
	= ""org.apache.xalan.xsltc.NodeIterator"";
    public static final String NODE_ITERATOR_BASE
	= ""org.apache.xalan.xsltc.dom.NodeIteratorBase"";
    public static final String SORT_ITERATOR      
	= ""org.apache.xalan.xsltc.dom.SortingIterator"";
    public static final String SORT_ITERATOR_SIG     
	= ""Lorg.apache.xalan.xsltc.dom.SortingIterator;"";
    public static final String REVERSE_ITERATOR      
	= ""org.apache.xalan.xsltc.dom.ReverseIterator"";
    public static final String NODE_SORT_RECORD 
	= ""org.apache.xalan.xsltc.dom.NodeSortRecord"";
    public static final String NODE_SORT_FACTORY
	= ""org/apache/xalan/xsltc/dom/NodeSortRecordFactory"";
    public static final String NODE_SORT_RECORD_SIG 
	= ""Lorg/apache/xalan/xsltc/dom/NodeSortRecord;"";
    public static final String NODE_SORT_FACTORY_SIG
	= ""Lorg/apache/xalan/xsltc/dom/NodeSortRecordFactory;"";
    public static final String STRING_VALUE_HANDLER
	= ""org.apache.xalan.xsltc.runtime.StringValueHandler"";
    public static final String STRING_VALUE_HANDLER_SIG 
	= ""Lorg/apache/xalan/xsltc/runtime/StringValueHandler;"";
    public static final String OUTPUT_HANDLER
	= ""org/apache/xalan/xsltc/TransletOutputHandler"";
    public static final String OUTPUT_HANDLER_SIG
	= ""Lorg/apache/xalan/xsltc/TransletOutputHandler;"";
    public static final String FILTER_INTERFACE   
	= ""org.apache.xalan.xsltc.dom.Filter"";
    public static final String FILTER_INTERFACE_SIG   
	= ""Lorg/apache/xalan/xsltc/dom/Filter;"";
    public static final String UNION_ITERATOR_CLASS
	= ""org.apache.xalan.xsltc.dom.UnionIterator"";
    public static final String STEP_ITERATOR_CLASS
	= ""org.apache.xalan.xsltc.dom.StepIterator"";
    public static final String NTH_ITERATOR_CLASS
	= ""org.apache.xalan.xsltc.dom.NthIterator"";
    public static final String ABSOLUTE_ITERATOR
	= ""org.apache.xalan.xsltc.dom.AbsoluteIterator"";
    public static final String DUP_FILTERED_ITERATOR
	= ""org.apache.xalan.xsltc.dom.DupFilterIterator"";
    public static final String CURRENT_NODE_LIST_ITERATOR
	= ""org.apache.xalan.xsltc.dom.CurrentNodeListIterator"";
    public static final String CURRENT_NODE_LIST_FILTER
	= ""org.apache.xalan.xsltc.dom.CurrentNodeListFilter"";
    public static final String CURRENT_NODE_LIST_ITERATOR_SIG 
	= ""Lorg/apache/xalan/xsltc/dom/CurrentNodeListIterator;"";
    public static final String CURRENT_NODE_LIST_FILTER_SIG
	= ""Lorg/apache/xalan/xsltc/dom/CurrentNodeListFilter;"";
    public static final String FILTER_STEP_ITERATOR 
	= ""org.apache.xalan.xsltc.dom.FilteredStepIterator"";
    public static final String FILTER_ITERATOR 
	= ""org.apache.xalan.xsltc.dom.FilterIterator"";
    public static final String SINGLETON_ITERATOR 
	= ""org.apache.xalan.xsltc.dom.SingletonIterator"";
    public static final String MATCHING_ITERATOR 
	= ""org.apache.xalan.xsltc.dom.MatchingIterator"";
    public static final String NODE_SIG           
	= ""I"";
    public static final String GET_PARENT         
	= ""getParent"";
    public static final String GET_PARENT_SIG     
	= ""("" + NODE_SIG + "")"" + NODE_SIG;
    public static final String NEXT_SIG           
	= ""()"" + NODE_SIG;
    public static final String NEXT               
	= ""next"";
    public static final String MAKE_NODE          
	= ""makeNode"";
    public static final String MAKE_NODE_LIST     
	= ""makeNodeList"";
    public static final String STRING_TO_REAL     
	= ""stringToReal"";
    public static final String STRING_TO_REAL_SIG 
	= ""("" + STRING_SIG + "")D"";
    public static final String STRING_TO_INT     
	= ""stringToInt"";
    public static final String STRING_TO_INT_SIG 
	= ""("" + STRING_SIG + "")I"";

    public static final String XSLT_PACKAGE       
	= ""org.apache.xalan.xsltc"";
    public static final String COMPILER_PACKAGE   
	= XSLT_PACKAGE + "".compiler"";
    public static final String RUNTIME_PACKAGE    
	= XSLT_PACKAGE + "".runtime"";
    public static final String TRANSLET_CLASS     
	= RUNTIME_PACKAGE + "".AbstractTranslet"";

    public static final String TRANSLET_SIG        
	= ""Lorg/apache/xalan/xsltc/runtime/AbstractTranslet;"";
    public static final String UNION_ITERATOR_SIG  
	= ""Lorg/apache/xalan/xsltc/dom/UnionIterator;"";
    public static final String TRANSLET_OUTPUT_BASE_SIG    
	= ""Lorg/apache/xalan/xsltc/TransletOutputBase;"";
    public static final String TRANSLET_OUTPUT_SIG    
	= ""Lorg/apache/xalan/xsltc/TransletOutputHandler;"";
    public static final String MAKE_NODE_SIG       
	= ""(I)Lorg/w3c/dom/Node;"";
    public static final String MAKE_NODE_SIG2      
	= ""("" + NODE_ITERATOR_SIG + "")Lorg/w3c/dom/Node;"";
    public static final String MAKE_NODE_LIST_SIG  
	= ""(I)Lorg/w3c/dom/NodeList;"";
    public static final String MAKE_NODE_LIST_SIG2 
	= ""("" + NODE_ITERATOR_SIG + "")Lorg/w3c/dom/NodeList;"";

    public static final String LOAD_DOCUMENT_CLASS
	= ""org.apache.xalan.xsltc.dom.LoadDocument"";

    public static final String KEY_INDEX_CLASS
	= ""org/apache/xalan/xsltc/dom/KeyIndex"";
    public static final String KEY_INDEX_SIG
	= ""Lorg/apache/xalan/xsltc/dom/KeyIndex;"";

    public static final String DOM_INTF
	= ""org.apache.xalan.xsltc.DOM"";
    public static final String DOM_IMPL
	= ""org.apache.xalan.xsltc.dom.DOMImpl"";
    public static final String STRING_CLASS 		
	= ""java.lang.String"";
    public static final String OBJECT_CLASS 		
	= ""java.lang.Object"";
    public static final String BOOLEAN_CLASS 		
	= ""java.lang.Boolean"";
    public static final String STRING_BUFFER_CLASS
	= ""java.lang.StringBuffer"";

    public static final String TRANSLET_OUTPUT_BASE       
	= ""org.apache.xalan.xsltc.TransletOutputBase"";
    
    public static final String TRANSLET_OUTPUT_INTERFACE
	= ""org.apache.xalan.xsltc.TransletOutputHandler"";
    public static final String BASIS_LIBRARY_CLASS 
	= ""org.apache.xalan.xsltc.runtime.BasisLibrary"";
    public static final String ATTRIBUTE_LIST_IMPL_CLASS 
	= ""org.apache.xalan.xsltc.runtime.AttributeListImpl"";
    public static final String DOUBLE_CLASS       
	= ""java.lang.Double"";
    public static final String INTEGER_CLASS      
	= ""java.lang.Integer"";
    public static final String RUNTIME_NODE_CLASS 
	= ""org.apache.xalan.xsltc.runtime.Node"";
    public static final String MATH_CLASS         
	= ""java.lang.Math"";

    public static final String BOOLEAN_VALUE      
	= ""booleanValue"";
    public static final String BOOLEAN_VALUE_SIG  
	= ""()Z"";
    public static final String INT_VALUE          
	= ""intValue"";
    public static final String INT_VALUE_SIG      
	= ""()I"";
    public static final String DOUBLE_VALUE       
	= ""doubleValue"";
    public static final String DOUBLE_VALUE_SIG   
	= ""()D"";

    public static final String NODE_PNAME         
	= ""node"";
    public static final String TRANSLET_OUTPUT_PNAME 
	= ""handler"";
    public static final String ITERATOR_PNAME     
	= ""iterator"";
    public static final String DOCUMENT_PNAME     
	= ""document"";
    public static final String TRANSLET_PNAME     
	= ""translet"";

    public static final String GET_NODE_NAME      
	= ""getNodeName"";
    public static final String CHARACTERSW        
	= ""characters"";
    public static final String GET_CHILDREN       
	= ""getChildren"";
    public static final String GET_TYPED_CHILDREN 
	= ""getTypedChildren"";
    public static final String CHARACTERS         
	= ""characters"";
    public static final String APPLY_TEMPLATES    
	= ""applyTemplates"";
    public static final String GET_NODE_TYPE      
	= ""getNodeType"";
    public static final String GET_NODE_VALUE     
	= ""getNodeValue"";
    public static final String GET_ELEMENT_VALUE  
	= ""getElementValue"";
    public static final String GET_ATTRIBUTE_VALUE  
	= ""getAttributeValue"";
    public static final String HAS_ATTRIBUTE      
	= ""hasAttribute"";
    public static final String ADD_ITERATOR       
	= ""addIterator"";
    public static final String SET_START_NODE     
	= ""setStartNode"";
    public static final String RESET     	    
	= ""reset"";

    public static final String ATTR_SET_SIG
	= ""("" + TRANSLET_OUTPUT_SIG + NODE_ITERATOR_SIG + "")V"";

    public static final String GET_NODE_NAME_SIG   
	= ""("" + NODE_SIG + "")"" + STRING_SIG;
    public static final String CHARACTERSW_SIG     
	= ""(""  + STRING_SIG + TRANSLET_OUTPUT_SIG + "")V"";
    public static final String CHARACTERS_SIG     
	= ""("" + NODE_SIG + TRANSLET_OUTPUT_SIG + "")V"";
    public static final String GET_CHILDREN_SIG
	= ""("" + NODE_SIG +"")"" + NODE_ITERATOR_SIG;
    public static final String GET_TYPED_CHILDREN_SIG
	= ""(I)"" + NODE_ITERATOR_SIG;
    public static final String GET_NODE_TYPE_SIG
	= ""()S"";
    public static final String GET_NODE_VALUE_SIG
	= ""(I)"" + STRING_SIG;
    public static final String GET_ELEMENT_VALUE_SIG
	= ""(I)"" + STRING_SIG;
    public static final String GET_ATTRIBUTE_VALUE_SIG
	= ""(II)"" + STRING_SIG;
    public static final String HAS_ATTRIBUTE_SIG
	= ""(II)Z"";
    public static final String GET_ITERATOR_SIG
	= ""()"" + NODE_ITERATOR_SIG;

    public static final String NAMES_INDEX
	= ""namesArray"";
    public static final String NAMES_INDEX_SIG
	= ""["" + STRING_SIG;
    public static final String NAMESPACE_INDEX
	= ""namespaceArray"";
    public static final String NAMESPACE_INDEX_SIG
	= ""["" + STRING_SIG;

    public static final String DOM_FIELD
	= ""_dom"";
    public static final String FORMAT_SYMBOLS_FIELD	 
	= ""format_symbols"";

    public static final String ITERATOR_FIELD_SIG      
	= NODE_ITERATOR_SIG;
    public static final String NODE_FIELD		 
	= ""node"";
    public static final String NODE_FIELD_SIG		 
	= ""I"";
	
    public static final String EMPTYATTR_FIELD	     
	= ""EmptyAttributes"";
    public static final String ATTRIBUTE_LIST_FIELD    
	= ""attributeList"";
    public static final String CLEAR_ATTRIBUTES        
	= ""clear"";
    public static final String ADD_ATTRIBUTE           
	= ""addAttribute"";
    public static final String ATTRIBUTE_LIST_IMPL_SIG 
	= ""Lorg/apache/xalan/xsltc/runtime/AttributeListImpl;"";
    public static final String CLEAR_ATTRIBUTES_SIG    
	= ""()"" + ATTRIBUTE_LIST_IMPL_SIG;
    public static final String ADD_ATTRIBUTE_SIG   
	= ""("" + STRING_SIG + STRING_SIG + "")"" + ATTRIBUTE_LIST_IMPL_SIG;
	
    public static final String ADD_ITERATOR_SIG   
	= ""("" + NODE_ITERATOR_SIG +"")"" + UNION_ITERATOR_SIG;

    public static final String ORDER_ITERATOR
	= ""orderNodes"";
    public static final String ORDER_ITERATOR_SIG
	= ""(""+NODE_ITERATOR_SIG+""I)""+NODE_ITERATOR_SIG;
	
    public static final String SET_START_NODE_SIG   
	= ""("" + NODE_SIG + "")"" + NODE_ITERATOR_SIG;

    public static final String NODE_COUNTER 
	= ""org.apache.xalan.xsltc.dom.NodeCounter"";
    public static final String NODE_COUNTER_SIG 
	= ""Lorg/apache/xalan/xsltc/dom/NodeCounter;"";
    public static final String DEFAULT_NODE_COUNTER 
	= ""org.apache.xalan.xsltc.dom.DefaultNodeCounter"";
    public static final String DEFAULT_NODE_COUNTER_SIG 
	= ""Lorg/apache/xalan/xsltc/dom/DefaultNodeCounter;"";
    public static final String TRANSLET_FIELD 
	= ""translet"";
    public static final String TRANSLET_FIELD_SIG 
	= TRANSLET_SIG;

    public static final String RESET_SIG   	       
	= ""()"" + NODE_ITERATOR_SIG;
    public static final String GET_PARAMETER      
	= ""getParameter"";
    public static final String ADD_PARAMETER         
	= ""addParameter"";
    public static final String PUSH_PARAM_FRAME
	= ""pushParamFrame"";
    public static final String PUSH_PARAM_FRAME_SIG  
	= ""()V"";
    public static final String POP_PARAM_FRAME       
	= ""popParamFrame"";
    public static final String POP_PARAM_FRAME_SIG   
	= ""()V"";
    public static final String GET_PARAMETER_SIG     
	= ""("" + STRING_SIG + "")"" + OBJECT_SIG;
    public static final String ADD_PARAMETER_SIG
	= ""("" + STRING_SIG + OBJECT_SIG + ""Z)"" + OBJECT_SIG;

    public static final String STRIP_SPACE
	= ""stripSpace"";
    public static final String STRIP_SPACE_INTF
	= ""org/apache/xalan/xsltc/StripFilter"";
    public static final String STRIP_SPACE_SIG
	= ""Lorg/apache/xalan/xsltc/StripFilter;"";
    public static final String STRIP_SPACE_PARAMS
	= ""(Lorg/apache/xalan/xsltc/DOM;II)Z"";

    public static final String GET_NODE_VALUE_ITERATOR
	= ""getNodeValueIterator"";
    public static final String GET_NODE_VALUE_ITERATOR_SIG
	= ""(""+NODE_ITERATOR_SIG+""I""+STRING_SIG+""Z)""+NODE_ITERATOR_SIG;

    public static final int POSITION_INDEX = 2;
    public static final int LAST_INDEX     = 3;

    public static final String XMLNS_PREFIX = ""xmlns"";
    public static final String XMLNS_STRING = ""xmlns:"";
    public static final String XMLNS_URI 
	= ""http:
    public static final String XSLT_URI
	= ""http:
    public static final String XHTML_URI
	= ""http:
    public static final String TRANSLET_URI
	= ""http:
    public static final String FALLBACK_CLASS
	= ""org.apache.xalan.xsltc.compiler.Fallback"";
}
"
org.apache.xalan.xsltc.runtime.output.TransletOutputHandlerFactory,14,1,0,15,36,39,3,12,14,0.826923077,343,0.75,0,0.0,0.196428571,0,0,22.64285714,2,1.0714,0,"

package org.apache.xalan.xsltc.runtime.output;

import java.io.Writer;
import java.io.IOException;
import java.io.OutputStream;

import org.w3c.dom.Node;
import org.xml.sax.SAXException;
import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;
import org.apache.xalan.xsltc.runtime.*;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.TransletOutputHandler;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.xalan.xsltc.trax.SAX2DOM;

public class TransletOutputHandlerFactory {

    public static final int STREAM = 0;
    public static final int SAX    = 1;
    public static final int DOM    = 2;

    private String _encoding       = ""utf-8"";
    private String _method         = null;
    private int    _outputType     = STREAM;
    private OutputStream _ostream  = System.out;
    private Writer _writer         = null;
    private Node           _node   = null;
    private int _indentNumber      = -1;
    private ContentHandler _handler    = null;
    private LexicalHandler _lexHandler = null;

    static public TransletOutputHandlerFactory newInstance() {
	return new TransletOutputHandlerFactory();
    }

    public void setOutputType(int outputType) {
	_outputType = outputType;
    }

    public void setEncoding(String encoding) {
	if (encoding != null) {
	    _encoding = encoding;
	}
    }

    public void setOutputMethod(String method) {
	_method = method;
    }

    public void setOutputStream(OutputStream ostream) {
	_ostream = ostream;
    }

    public void setWriter(Writer writer) {
	_writer = writer;
    }

    public void setHandler(ContentHandler handler) {
        _handler = handler;
    }

    public void setLexicalHandler(LexicalHandler lex) {
	_lexHandler = lex;
    }

    public void setNode(Node node) {
	_node = node;
    }

    public Node getNode() {
	return (_handler instanceof SAX2DOM) ? ((SAX2DOM)_handler).getDOM() 
	   : null;
    }

    public void setIndentNumber(int value) {
	_indentNumber = value;
    }

    public TransletOutputHandler getTransletOutputHandler() 
	throws IOException, ParserConfigurationException 
    {
	switch (_outputType) {
	    case STREAM:
		StreamOutput result = null;

		if (_method == null) {
		    result = (_writer == null) ? 
			new StreamUnknownOutput(_ostream, _encoding) :
			new StreamUnknownOutput(_writer, _encoding);
		}
		else if (_method.equalsIgnoreCase(""xml"")) {
		    result = (_writer == null) ? 
			new StreamXMLOutput(_ostream, _encoding) :
			new StreamXMLOutput(_writer, _encoding);
		}
		else if (_method.equalsIgnoreCase(""html"")) {
		    result = (_writer == null) ? 
			new StreamHTMLOutput(_ostream, _encoding) :
			new StreamHTMLOutput(_writer, _encoding);
		}
		else if (_method.equalsIgnoreCase(""text"")) {
		    result = (_writer == null) ? 
			new StreamTextOutput(_ostream, _encoding) :
			new StreamTextOutput(_writer, _encoding);
		}

		if (result != null && _indentNumber >= 0) {
		    result.setIndentNumber(_indentNumber);
		}
		return result;
	    case DOM:
		_handler = (_node != null) ? new SAX2DOM(_node) : 
					     new SAX2DOM();
		_lexHandler = (LexicalHandler)_handler;
		
	    case SAX:
		if (_method == null) {
		    _method = ""xml"";    
		}

		if (_method.equalsIgnoreCase(""xml"")) {
		    return (_lexHandler == null) ? 
			new SAXXMLOutput(_handler, _encoding) :
			new SAXXMLOutput(_handler, _lexHandler, _encoding);
		}
		else if (_method.equalsIgnoreCase(""html"")) {
		    return (_lexHandler == null) ? 
			new SAXHTMLOutput(_handler, _encoding) :
			new SAXHTMLOutput(_handler, _lexHandler, _encoding);
		}
		else if (_method.equalsIgnoreCase(""text"")) {
		    return (_lexHandler == null) ? 
			new SAXTextOutput(_handler, _encoding) :
			new SAXTextOutput(_handler, _lexHandler, _encoding);
		}
	    break;
	}
	return null;
    }

    
    public TransletOutputHandler getOldTransletOutputHandler() throws IOException {
	DefaultSAXOutputHandler saxHandler =
	    new DefaultSAXOutputHandler(_ostream, _encoding);
	return new TextOutput((ContentHandler)saxHandler,
			      (LexicalHandler)saxHandler, _encoding);
    }
}
"
org.apache.xalan.serialize.Method,1,1,0,0,2,0,0,0,1,2.0,8,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xalan.serialize;


public final class Method
{

  
  public static final String XML = ""xml"";

  
  public static final String HTML = ""html"";

  
  public static final String XHTML = ""xhtml"";

  
  public static final String Text = ""text"";
}
"
org.apache.xml.utils.TreeWalker,10,1,0,12,59,0,7,5,7,0.305555556,596,0.75,1,0.0,0.44,0,0,58.2,1,0.7,0,"
package org.apache.xml.utils;

import org.w3c.dom.*;

import org.xml.sax.*;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.LocatorImpl;

import org.apache.xpath.DOM2Helper;
import org.apache.xpath.DOMHelper;
import org.apache.xml.utils.NodeConsumer;



public class TreeWalker
{

  
  private ContentHandler m_contentHandler = null;

  
  

  
  protected DOMHelper m_dh;
        
        
        private LocatorImpl m_locator = new LocatorImpl();

  
  public ContentHandler getContentHandler()
  {
    return m_contentHandler;
  }

  
  public void setContentHandler(ContentHandler ch)
  {
    m_contentHandler = ch;
  }
        
        
  public TreeWalker(ContentHandler contentHandler, DOMHelper dh, String systemId)
  {
    this.m_contentHandler = contentHandler;
                m_contentHandler.setDocumentLocator(m_locator);
                if (systemId != null)
                  m_locator.setSystemId(systemId);
                else {
                  try {
                    m_locator.setSystemId(System.getProperty(""user.dir""));
                  }
                  catch (SecurityException se) {
                    m_locator.setSystemId("""");
                  }
                }
    m_dh = dh;
  }

  
  public TreeWalker(ContentHandler contentHandler, DOMHelper dh)
  {
    this.m_contentHandler = contentHandler;
    m_contentHandler.setDocumentLocator(m_locator);
    try {
      m_locator.setSystemId(System.getProperty(""user.dir""));
    } 
    catch (SecurityException se){
      m_locator.setSystemId("""");
    }
    m_dh = dh;
  }
  
  
  public TreeWalker(ContentHandler contentHandler)
  {
    this.m_contentHandler = contentHandler;
                if (m_contentHandler != null)
                        m_contentHandler.setDocumentLocator(m_locator);
                try {
                  m_locator.setSystemId(System.getProperty(""user.dir""));
                } 
                catch (SecurityException se){
                  m_locator.setSystemId("""");
    }
    m_dh = new org.apache.xpath.DOM2Helper();
  }

  
  public void traverse(Node pos) throws org.xml.sax.SAXException
  {

   	this.m_contentHandler.startDocument();

    Node top = pos;

    while (null != pos)
    {
      startNode(pos);

      Node nextNode = pos.getFirstChild();

      while (null == nextNode)
      {
        endNode(pos);

        if (top.equals(pos))
          break;

        nextNode = pos.getNextSibling();

        if (null == nextNode)
        {
          pos = pos.getParentNode();

          if ((null == pos) || (top.equals(pos)))
          {
            if (null != pos)
              endNode(pos);

            nextNode = null;

            break;
          }
        }
      }

      pos = nextNode;
    }
    this.m_contentHandler.endDocument();
  }

  
  public void traverse(Node pos, Node top) throws org.xml.sax.SAXException
  {

	this.m_contentHandler.startDocument();
	
    while (null != pos)
    {
      startNode(pos);

      Node nextNode = pos.getFirstChild();

      while (null == nextNode)
      {
        endNode(pos);

        if ((null != top) && top.equals(pos))
          break;

        nextNode = pos.getNextSibling();

        if (null == nextNode)
        {
          pos = pos.getParentNode();

          if ((null == pos) || ((null != top) && top.equals(pos)))
          {
            nextNode = null;

            break;
          }
        }
      }

      pos = nextNode;
    }
    this.m_contentHandler.endDocument();
  }

  
  boolean nextIsRaw = false;
  
  
  private final void dispatachChars(Node node)
     throws org.xml.sax.SAXException
  {
    if(m_contentHandler instanceof org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.CharacterNodeHandler)
    {
      ((org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.CharacterNodeHandler)m_contentHandler).characters(node);
    }
    else
    {
      String data = ((Text) node).getData();
      this.m_contentHandler.characters(data.toCharArray(), 0, data.length());
    }
  }

  
  protected void startNode(Node node) throws org.xml.sax.SAXException
  {

    if (m_contentHandler instanceof NodeConsumer)
    {
      ((NodeConsumer) m_contentHandler).setOriginatingNode(node);
    }
                
                if (node instanceof Locator)
                {
                        Locator loc = (Locator)node;
                        m_locator.setColumnNumber(loc.getColumnNumber());
                        m_locator.setLineNumber(loc.getLineNumber());
                        m_locator.setPublicId(loc.getPublicId());
                        m_locator.setSystemId(loc.getSystemId());
                }
                else
                {
                        m_locator.setColumnNumber(0);
      m_locator.setLineNumber(0);
                }

    switch (node.getNodeType())
    {
    case Node.COMMENT_NODE :
    {
      String data = ((Comment) node).getData();

      if (m_contentHandler instanceof LexicalHandler)
      {
        LexicalHandler lh = ((LexicalHandler) this.m_contentHandler);

        lh.comment(data.toCharArray(), 0, data.length());
      }
    }
    break;
    case Node.DOCUMENT_FRAGMENT_NODE :

      
      break;
    case Node.DOCUMENT_NODE :
    
      break;
    case Node.ELEMENT_NODE :
      NamedNodeMap atts = ((Element) node).getAttributes();
      int nAttrs = atts.getLength();
      

      for (int i = 0; i < nAttrs; i++)
      {
        Node attr = atts.item(i);
        String attrName = attr.getNodeName();

        
        if (attrName.equals(""xmlns"") || attrName.startsWith(""xmlns:""))
        {
          
          int index;
          
          
          
          String prefix = (index = attrName.indexOf("":"")) < 0
                          ? """" : attrName.substring(index + 1);

          this.m_contentHandler.startPrefixMapping(prefix,
                                                   attr.getNodeValue());
        }
        
      }

      
      
      String ns = m_dh.getNamespaceOfNode(node);
      if(null == ns)
        ns = """";
      this.m_contentHandler.startElement(ns,
                                         m_dh.getLocalNameOfNode(node),
                                         node.getNodeName(),
                                         new AttList(atts, m_dh));
      break;
    case Node.PROCESSING_INSTRUCTION_NODE :
    {
      ProcessingInstruction pi = (ProcessingInstruction) node;
      String name = pi.getNodeName();

      
      if (name.equals(""xslt-next-is-raw""))
      {
        nextIsRaw = true;
      }
      else
      {
        this.m_contentHandler.processingInstruction(pi.getNodeName(),
                                                    pi.getData());
      }
    }
    break;
    case Node.CDATA_SECTION_NODE :
    {
      boolean isLexH = (m_contentHandler instanceof LexicalHandler);
      LexicalHandler lh = isLexH
                          ? ((LexicalHandler) this.m_contentHandler) : null;

      if (isLexH)
      {
        lh.startCDATA();
      }
      
      dispatachChars(node);

      {
        if (isLexH)
        {
          lh.endCDATA();
        }
      }
    }
    break;
    case Node.TEXT_NODE :
    {
      

      if (nextIsRaw)
      {
        nextIsRaw = false;

        m_contentHandler.processingInstruction(javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");
        dispatachChars(node);
        m_contentHandler.processingInstruction(javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");
      }
      else
      {
        dispatachChars(node);
      }
    }
    break;
    case Node.ENTITY_REFERENCE_NODE :
    {
      EntityReference eref = (EntityReference) node;

      if (m_contentHandler instanceof LexicalHandler)
      {
        ((LexicalHandler) this.m_contentHandler).startEntity(
          eref.getNodeName());
      }
      else
      {

        
      }
    }
    break;
    default :
    }
  }

  
  protected void endNode(Node node) throws org.xml.sax.SAXException
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_NODE :
      break;
      
    case Node.ELEMENT_NODE :
      String ns = m_dh.getNamespaceOfNode(node);
      if(null == ns)
        ns = """";
      this.m_contentHandler.endElement(ns,
                                         m_dh.getLocalNameOfNode(node),
                                         node.getNodeName());

      NamedNodeMap atts = ((Element) node).getAttributes();
      int nAttrs = atts.getLength();

      for (int i = 0; i < nAttrs; i++)
      {
        Node attr = atts.item(i);
        String attrName = attr.getNodeName();

        if (attrName.equals(""xmlns"") || attrName.startsWith(""xmlns:""))
        {
          int index;
          
          
          
          String prefix = (index = attrName.indexOf("":"")) < 0
                          ? """" : attrName.substring(index + 1);

          this.m_contentHandler.endPrefixMapping(prefix);
        }
      }
      break;
    case Node.CDATA_SECTION_NODE :
      break;
    case Node.ENTITY_REFERENCE_NODE :
    {
      EntityReference eref = (EntityReference) node;

      if (m_contentHandler instanceof LexicalHandler)
      {
        LexicalHandler lh = ((LexicalHandler) this.m_contentHandler);

        lh.endEntity(eref.getNodeName());
      }
    }
    break;
    default :
    }
  }
}  

"
org.apache.xalan.lib.sql.SQLErrorDocument,4,5,0,5,12,0,1,4,2,0.636363636,179,1.0,0,0.989528796,0.55,1,1,41.0,1,0.5,0,"

package org.apache.xalan.lib.sql;

import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTM;
import java.sql.SQLException;




public class SQLErrorDocument extends DTMDocument
{
  
  private static final String S_EXT_ERROR = ""ext-error"";
  
  private static final String S_SQL_ERROR = ""sql-error"";
  
  private static final String S_MESSAGE = ""message"";
  
  private static final String S_CODE = ""code"";

  
  private int m_ErrorExt_TypeID = DTM.NULL;
  
  private int m_Message_TypeID = DTM.NULL;
  
  private int m_Code_TypeID = DTM.NULL;

  
  private int m_SQLError_TypeID = DTM.NULL;

  
  private int m_rootID = DTM.NULL;
  
  private int m_extErrorID = DTM.NULL;
  
  private int m_MainMessageID = DTM.NULL;

  
  public SQLErrorDocument( DTMManager mgr, int ident, SQLException error )
  {
    super(mgr, ident);

    createExpandedNameTable();
    buildBasicStructure(error);

    int sqlError = addElement(2, m_SQLError_TypeID, m_extErrorID, m_MainMessageID);
    int element = DTM.NULL;

    element = addElementWithData(
      new Integer(error.getErrorCode()), 3,
      m_Code_TypeID, sqlError, element);

    element = addElementWithData(
      error.getLocalizedMessage(), 3,
      m_Message_TypeID, sqlError, element);


  }


  
  public SQLErrorDocument( DTMManager mgr, int ident, Exception error )
  {
    super(mgr, ident);
    createExpandedNameTable();
    buildBasicStructure(error);
  }

  
  private void buildBasicStructure( Exception e )
  {
    m_rootID = addElement(0, m_Document_TypeID, DTM.NULL, DTM.NULL);
    m_extErrorID = addElement(1, m_ErrorExt_TypeID, m_rootID, DTM.NULL);
    m_MainMessageID = addElementWithData
      (e.getLocalizedMessage(), 2, m_Message_TypeID, m_extErrorID, DTM.NULL);
  }

  
  protected void createExpandedNameTable( )
  {

    super.createExpandedNameTable();

    m_ErrorExt_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_EXT_ERROR, DTM.ELEMENT_NODE);

    m_SQLError_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SQL_ERROR, DTM.ELEMENT_NODE);

    m_Message_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_MESSAGE, DTM.ELEMENT_NODE);

    m_Code_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_CODE, DTM.ELEMENT_NODE);
  }

}"
org.apache.xalan.xsltc.compiler.ProcessingInstruction,4,3,0,21,26,0,0,21,3,0.333333333,123,1.0,1,0.949152542,0.4,2,5,29.5,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class ProcessingInstruction extends Instruction {

    private AttributeValue _name; 
    
    public void parseContents(Parser parser) {
	final String name  = getAttribute(""name"");
	_name = AttributeValue.create(this, name, parser);
	if (name.equals(""xml"")) {
	    reportError(this, parser, ErrorMsg.ILLEGAL_PI_ERR, ""xml"");
	}
	parseChildren(parser);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_name.typeCheck(stable);
	typeCheckContents(stable);
	return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	il.append(DUP);		
	
	
	_name.translate(classGen, methodGen);

	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       ""stringValueHandler"",
					       STRING_VALUE_HANDLER_SIG)));
	il.append(DUP);
	il.append(methodGen.storeHandler());

	
	translateContents(classGen, methodGen);

	
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_VALUE_HANDLER,
						     ""getValueOfPI"",
						     ""()"" + STRING_SIG)));
	
	final int processingInstruction =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""processingInstruction"", 
				      ""("" + STRING_SIG + STRING_SIG + "")V"");
	il.append(new INVOKEINTERFACE(processingInstruction, 3));
	
	il.append(methodGen.storeHandler());
    }
}
"
org.apache.xml.utils.StringToIntTable,8,1,0,2,12,0,2,0,8,0.523809524,217,0.833333333,0,0.0,0.583333333,0,0,25.375,4,1.875,0,"
package org.apache.xml.utils;


public class StringToIntTable
{

  public static final int INVALID_KEY = -10000;
  
  
  private int m_blocksize;

  
  private String m_map[];

  
  private int m_values[];

  
  private int m_firstFree = 0;

  
  private int m_mapSize;

  
  public StringToIntTable()
  {

    m_blocksize = 8;
    m_mapSize = m_blocksize;
    m_map = new String[m_blocksize];
    m_values = new int[m_blocksize];
  }

  
  public StringToIntTable(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new String[blocksize];
    m_values = new int[m_blocksize];
  }

  
  public final int getLength()
  {
    return m_firstFree;
  }

  
  public final void put(String key, int value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      String newMap[] = new String[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;

      int newValues[] = new int[m_mapSize];

      System.arraycopy(m_values, 0, newValues, 0, m_firstFree + 1);

      m_values = newValues;
    }

    m_map[m_firstFree] = key;
    m_values[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final int get(String key)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equals(key))
        return m_values[i];
    }

	return INVALID_KEY;
  }

  
  public final int getIgnoreCase(String key)
  {

    if (null == key)
        return INVALID_KEY;

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equalsIgnoreCase(key))
        return m_values[i];
    }

    return INVALID_KEY;
  }

  
  public final boolean contains(String key)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equals(key))
        return true;
    }

    return false;
  }
  
  
  public final String[] keys()
  {
    String [] keysArr = new String[m_firstFree];

    for (int i = 0; i < m_firstFree; i++)
    {
      keysArr[i] = m_map[i];
    }

    return keysArr;
  }  
}
"
org.apache.xpath.operations.Equals,3,3,0,6,7,3,1,5,3,2.0,40,0.0,0,0.953488372,0.555555556,2,2,12.33333333,1,0.6667,0,"
package org.apache.xpath.operations;

import javax.xml.transform.TransformerException;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;


public class Equals extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.equals(right) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    XObject left = m_left.execute(xctxt, true);
    XObject right = m_right.execute(xctxt, true);

    boolean result = left.equals(right) ? true : false;
	left.detach();
	right.detach();
    return result;
  }

}
"
org.apache.xalan.xsltc.compiler.LastCall,5,4,0,19,22,4,1,19,5,0.5,225,1.0,0,0.96969697,0.4,2,4,43.8,13,3.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.dom.Axis;

final class LastCall extends FunctionCall {

    private int _type = -1;

    public LastCall(QName fname) {
	super(fname);
    }

    public LastCall(QName fname, int type) {
	this(fname);
	_type = type;
    }

    public boolean hasPositionCall() {
	return true;
    }

    public boolean hasLastCall() {
	return true;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final InstructionList il = methodGen.getInstructionList();
	final ConstantPoolGen cpg = classGen.getConstantPool();

	boolean lastChild = false;

	
	
	if (getParent() instanceof Expression) {
	    if (getParent().getParent() instanceof Predicate) {
		Predicate pred = (Predicate)getParent().getParent();
		_type = pred.getPosType();
		if ((_type==DOM.ELEMENT) || (_type==DOM.ATTRIBUTE)) _type = -1;
	    }
	}

	
	
	if (getParent() instanceof Predicate) {
	    _type = ((Predicate)getParent()).getPosType();
	    if ((_type==DOM.ELEMENT) || (_type==DOM.ATTRIBUTE)) _type = -1;
	    if (getParent().getParent() instanceof Step) {
		lastChild = true;
	    }
	}

	if (methodGen instanceof CompareGenerator) {
	    il.append(((CompareGenerator)methodGen).loadLastNode());
	}
	else if (classGen.isExternal()) {
	    il.append(new ILOAD(LAST_INDEX));
	}
	else if (_type == -1) {
	    final int last = cpg.addInterfaceMethodref(NODE_ITERATOR,
						       ""getLast"", 
						       ""()I"");
	    final int git = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getTypedAxisIterator"", 
						      ""(II)""+NODE_ITERATOR_SIG);
	    final int start = cpg.addInterfaceMethodref(NODE_ITERATOR,
							""setStartNode"", 
							""(I)""+
							NODE_ITERATOR_SIG);
	    if (lastChild) {
		il.append(methodGen.loadDOM());
		il.append(new PUSH(cpg, Axis.CHILD));
		il.append(new PUSH(cpg, DOM.ELEMENT));
		il.append(new INVOKEINTERFACE(git, 3));
		il.append(methodGen.loadCurrentNode());
		il.append(new INVOKEINTERFACE(start, 2));
	    }
	    else {
		il.append(methodGen.loadIterator());
	    }
	    il.append(new INVOKEINTERFACE(last, 1));
	}
	else {
	    
	    final int last = cpg.addInterfaceMethodref(DOM_INTF,
						       ""getTypedLast"",
						       ""(II)I"");
	    il.append(methodGen.loadDOM());
	    il.append(new PUSH(cpg, _type));
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(last, 3));

	}
    }
}
"
org.apache.xml.dtm.ref.CoroutineManager,6,1,0,4,17,0,3,1,6,0.7,183,0.0,0,0.0,0.722222222,0,0,28.5,7,1.8333,0,"
package org.apache.xml.dtm.ref;

import java.util.*;
import org.apache.xml.dtm.*;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;



public class CoroutineManager
{
  
  BitSet m_activeIDs=new BitSet();

  
  static final int m_unreasonableId=1024;

  
  Object m_yield=null;

  
  final static int NOBODY=-1;
  final static int ANYBODY=-1;

  
  int m_nextCoroutine=NOBODY;
  
  
  public synchronized int co_joinCoroutineSet(int coroutineID)
  {
    if(coroutineID>=0)
      {
        if(coroutineID>=m_unreasonableId || m_activeIDs.get(coroutineID))
          return -1;
      }
    else
      {
        
        
        coroutineID=0;
        while(coroutineID<m_unreasonableId)
          {
            if(m_activeIDs.get(coroutineID))
              ++coroutineID;
            else
              break;
          }
        if(coroutineID>=m_unreasonableId)
          return -1;
      }

    m_activeIDs.set(coroutineID);
    return coroutineID;
  }

  
  public synchronized Object co_entry_pause(int thisCoroutine) throws java.lang.NoSuchMethodException
  {
    if(!m_activeIDs.get(thisCoroutine))
      throw new java.lang.NoSuchMethodException();

    while(m_nextCoroutine != thisCoroutine)
      {
        try 
          {
            wait();
          }
        catch(java.lang.InterruptedException e)
          {
            
            
          }
      }
    
    return m_yield;
  }

  
  public synchronized Object co_resume(Object arg_object,int thisCoroutine,int toCoroutine) throws java.lang.NoSuchMethodException
  {
    if(!m_activeIDs.get(toCoroutine))
      throw new java.lang.NoSuchMethodException(XSLMessages.createMessage(XSLTErrorResources.ER_COROUTINE_NOT_AVAIL, new Object[]{Integer.toString(toCoroutine)})); 

    
    
    m_yield=arg_object;
    m_nextCoroutine=toCoroutine;

    notify();
    while(m_nextCoroutine != thisCoroutine || m_nextCoroutine==ANYBODY || m_nextCoroutine==NOBODY)
      {
        try 
          {
            
            wait();
          }
        catch(java.lang.InterruptedException e)
          {
            
            
          }
      }

    if(m_nextCoroutine==NOBODY)
      {
        
        co_exit(thisCoroutine);
        
        
        throw new java.lang.NoSuchMethodException(XSLMessages.createMessage(XSLTErrorResources.ER_COROUTINE_CO_EXIT, null)); 
      }
    
    return m_yield;
  }
  
  
  public synchronized void co_exit(int thisCoroutine)
  {
    m_activeIDs.clear(thisCoroutine);
    m_nextCoroutine=NOBODY; 
    notify();
  }

  
  public synchronized void co_exit_to(Object arg_object,int thisCoroutine,int toCoroutine) throws java.lang.NoSuchMethodException
  {
    if(!m_activeIDs.get(toCoroutine))
      throw new java.lang.NoSuchMethodException(XSLMessages.createMessage(XSLTErrorResources.ER_COROUTINE_NOT_AVAIL, new Object[]{Integer.toString(toCoroutine)})); 
    
    
    
    m_yield=arg_object;
    m_nextCoroutine=toCoroutine;

    m_activeIDs.clear(thisCoroutine);

    notify();
  }
}
"
org.apache.xpath.functions.FuncStringLength,2,5,0,5,6,1,0,5,2,2.0,14,0.0,0,0.982142857,0.75,2,7,6.0,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XNodeSet;


public class FuncStringLength extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(getArg0AsString(xctxt).length());
  }
}
"
org.apache.xalan.xsltc.dom.NodeSortRecord,11,1,0,4,18,5,2,2,8,0.714285714,248,0.714285714,2,0.0,0.366666667,0,0,20.27272727,5,1.2727,0,"

package org.apache.xalan.xsltc.dom;

import java.util.Vector;
import java.text.Collator;
import java.text.CollationKey;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;


public abstract class NodeSortRecord {
    public static int COMPARE_STRING     = 0;
    public static int COMPARE_NUMERIC    = 1;

    public static int COMPARE_ASCENDING  = 0;
    public static int COMPARE_DESCENDING = 1;

    protected static Collator _collator = Collator.getInstance();

    protected int   _levels = 1;
    protected int[] _compareType;
    protected int[] _sortOrder;

    private AbstractTranslet _translet = null;

    private DOM    _dom = null;
    private int    _node;           
    private int    _last = 0;       
    private int    _scanned = 0;    

    private Object[] _values; 

     
    public NodeSortRecord(int node) {
	_node = node;
    }

    public NodeSortRecord() {
        this(0);
    }

    
    public final void initialize(int node, int last, DOM dom,
				 AbstractTranslet translet,
				 int[] order, int[] type) {
	_dom = dom;
	_node = node;
	_last = last;
	_translet = translet;
	_scanned = 0;

	_levels = order.length;
	_sortOrder = order;
	_compareType = type;

	_values = new Object[_levels];
    }

    
    public final int getNode() {
	return _node;
    }

    
    public final int compareDocOrder(NodeSortRecord other) {
	return _node - other._node;
    }

    
    private final CollationKey stringValue(int level) {
	
	if (_scanned <= level) {
	    
	    final String str = extractValueFromDOM(_dom, _node, level,
						   _translet, _last);
	    final CollationKey key = _collator.getCollationKey(str);
	    _values[_scanned++] = key;
	    return(key);
	}
	return((CollationKey)_values[level]);
    }
    
    private final Double numericValue(int level) {
	
	if (_scanned <= level) {
	    
	    final String str = extractValueFromDOM(_dom, _node, level,
						   _translet, _last);
	    Double num;
	    try {
		num = new Double(str);
	    }
	    
	    catch (NumberFormatException e) {
		num = new Double(Double.NEGATIVE_INFINITY);
	    }
	    _values[_scanned++] = num;
	    return(num);
	}
	return((Double)_values[level]);
    }

    
    public int compareTo(NodeSortRecord other) {
	int cmp, level;
	for (level = 0; level < _levels; level++) {
	    
	    if (_compareType[level] == COMPARE_NUMERIC) {
		final Double our = numericValue(level);
		final Double their = other.numericValue(level);
		cmp = our.compareTo(their);
	    }
	    else {
		final CollationKey our = stringValue(level);
		final CollationKey their = other.stringValue(level);
		cmp = our.compareTo(their);
	    }
	    
	    
	    if (cmp != 0) {
		return _sortOrder[level] == COMPARE_DESCENDING ? 0 - cmp : cmp;
	    }
	}
	
	return(_node - other._node);
    }

    
    public Collator getCollator() {
	return _collator;
    }

    
    public abstract String extractValueFromDOM(DOM dom, int current, int level,
					       AbstractTranslet translet,
					       int last);

}
"
org.apache.xalan.templates.TemplateSubPatternAssociation,15,1,0,8,25,49,2,6,12,0.833333333,139,0.833333333,3,0.0,0.208333333,0,0,7.866666667,6,1.2667,0,"
package org.apache.xalan.templates;

import java.io.Serializable;



import javax.xml.transform.TransformerException;

import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.patterns.StepPattern;
import org.apache.xml.utils.QName;


class TemplateSubPatternAssociation implements Serializable, Cloneable
{

  
  StepPattern m_stepPattern;

  
  private String m_pattern;

  
  private ElemTemplate m_template;

  
  private TemplateSubPatternAssociation m_next = null;

  
  private boolean m_wild;

  
  private String m_targetString;

  
  TemplateSubPatternAssociation(ElemTemplate template, StepPattern pattern, String pat)
  {

    m_pattern = pat;
    m_template = template;
    m_stepPattern = pattern;
    m_targetString = m_stepPattern.getTargetString();
    m_wild = m_targetString.equals(""*"");
  }

  
  public Object clone() throws CloneNotSupportedException
  {

    TemplateSubPatternAssociation tspa =
      (TemplateSubPatternAssociation) super.clone();

    tspa.m_next = null;

    return tspa;
  }

  
  public final String getTargetString()
  {
    return m_targetString;
  }

  
  public void setTargetString(String key)
  {
    m_targetString = key;
  }

  
  boolean matchMode(QName m1)
  {
    return matchModes(m1, m_template.getMode());
  }

  
  private boolean matchModes(QName m1, QName m2)
  {
    return (((null == m1) && (null == m2))
            || ((null != m1) && (null != m2) && m1.equals(m2)));
  }

  
  public boolean matches(XPathContext xctxt, int targetNode, QName mode)
          throws TransformerException
  {

    double score = m_stepPattern.getMatchScore(xctxt, targetNode);

    return (XPath.MATCH_SCORE_NONE != score)
           && matchModes(mode, m_template.getMode());
  }

  
  public final boolean isWild()
  {
    return m_wild;
  }

  
  public final StepPattern getStepPattern()
  {
    return m_stepPattern;
  }

  
  public final String getPattern()
  {
    return m_pattern;
  }

  
  public int getDocOrderPos()
  {
    return m_template.getUid();
  }

  
  public final int getImportLevel()
  {
    return m_template.getStylesheetComposed().getImportCountComposed();
  }

  
  public final ElemTemplate getTemplate()
  {
    return m_template;
  }

  
  public final TemplateSubPatternAssociation getNext()
  {
    return m_next;
  }

  
  public void setNext(TemplateSubPatternAssociation mp)
  {
    m_next = mp;
  }
}
"
org.apache.xalan.templates.AVTPartXPath,7,2,0,14,20,0,1,13,7,0.0,74,1.0,1,0.5,0.25974026,0,0,9.428571429,1,0.7143,0,"
package org.apache.xalan.templates;

import org.apache.xpath.*;
import org.apache.xpath.Expression;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xpath.ExpressionOwner;


import org.apache.xml.dtm.DTM;


public class AVTPartXPath extends AVTPart
{

  
  private XPath m_xpath;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_xpath.fixupVariables(vars, globalsSize);
  }
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return m_xpath.getExpression().canTraverseOutsideSubtree();
   }

  
  public AVTPartXPath(XPath xpath)
  {
    m_xpath = xpath;
  }

  
  public AVTPartXPath(
          String val, org.apache.xml.utils.PrefixResolver nsNode, 
          XPathParser xpathProcessor, XPathFactory factory, 
          XPathContext liaison)
            throws javax.xml.transform.TransformerException
  {
    m_xpath = new XPath(val, null, nsNode, XPath.SELECT, liaison.getErrorListener());
  }

  
  public String getSimpleString()
  {
    return ""{"" + m_xpath.getPatternString() + ""}"";
  }

  
  public void evaluate(
          XPathContext xctxt, FastStringBuffer buf, int context, org.apache.xml.utils.PrefixResolver nsNode)
            throws javax.xml.transform.TransformerException
  {

    XObject xobj = m_xpath.execute(xctxt, context, nsNode);

    if (null != xobj)
    {
      xobj.appendToFsb(buf);
    }
  }
  
  
  public void callVisitors(XSLTVisitor visitor)
  {
  	m_xpath.getExpression().callVisitors(m_xpath, visitor);
  }

}
"
org.apache.xpath.operations.UnaryOperation,11,2,4,12,20,0,6,7,11,0.2,88,1.0,1,0.75,0.227272727,1,7,6.909090909,3,1.3636,0,"
package org.apache.xpath.operations;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.objects.XObject;


public abstract class UnaryOperation extends Expression implements ExpressionOwner
{

  
  protected Expression m_right;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_right.fixupVariables(vars, globalsSize);
  }
  
  
  public boolean canTraverseOutsideSubtree()
  {

    if (null != m_right && m_right.canTraverseOutsideSubtree())
      return true;

    return false;
  }

  
  public void setRight(Expression r)
  {
    m_right = r;
    r.exprSetParent(this);
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    return operate(m_right.execute(xctxt));
  }

  
  public abstract XObject operate(XObject right)
    throws javax.xml.transform.TransformerException;

  
  public Expression getOperand(){
    return m_right;
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	if(visitor.visitUnaryOperation(owner, this))
  	{
  		m_right.callVisitors(this, visitor);
  	}
  }


  
  public Expression getExpression()
  {
    return m_right;
  }


  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_right = exp;
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	if(!m_right.deepEquals(((UnaryOperation)expr).m_right))
  		return false;
  		
  	return true;
  }



}
"
org.apache.xalan.processor.ProcessorGlobalParamDecl,3,5,0,6,10,3,1,5,1,2.0,30,0.0,0,0.990697674,0.583333333,1,2,9.0,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemParam;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;


class ProcessorGlobalParamDecl extends ProcessorTemplateElem
{

  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    
    handler.pushElemTemplateElement(elem);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    ElemParam v = (ElemParam) handler.getElemTemplateElement();

    handler.getStylesheet().appendChild(v);
    handler.getStylesheet().setParam(v);
    super.endElement(handler, uri, localName, rawName);
  }
}
"
org.apache.xalan.xsltc.compiler.util.NamedMethodGenerator,3,5,0,5,6,1,1,4,2,0.5,28,1.0,0,0.992805755,0.625,2,3,8.0,2,0.6667,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Vector;
import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.Template;


public final class NamedMethodGenerator extends MethodGenerator {
    protected static int CURRENT_INDEX  = 4;

    public NamedMethodGenerator(int access_flags, Type return_type,
				Type[] arg_types, String[] arg_names,
				String method_name, String class_name,
				InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
    }

    public int getLocalIndex(String name) {
	if (name.equals(""current"")) {
	    return CURRENT_INDEX;
	}
	return super.getLocalIndex(name);
    }
}
"
org.apache.xpath.axes.DescendantIterator,9,5,0,14,43,0,2,12,8,0.583333333,426,1.0,1,0.946969697,0.277777778,3,11,46.0,14,2.7778,1,"
package org.apache.xpath.axes;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.OpCodes;
import org.apache.xpath.patterns.NodeTest;


public class DescendantIterator extends LocPathIterator
{
  
  DescendantIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {

    super(compiler, opPos, analysis, false);

    int ops[] = compiler.getOpMap();
    int firstStepPos = compiler.getFirstChildPos(opPos);
    int stepType = ops[firstStepPos];

    boolean orSelf = (OpCodes.FROM_DESCENDANTS_OR_SELF == stepType);
    boolean fromRoot = false;
    if (OpCodes.FROM_SELF == stepType)
    {
      orSelf = true;
      
    }
    else if(OpCodes.FROM_ROOT == stepType)
    {
      fromRoot = true;
      
      int nextStepPos = compiler.getNextStepPos(firstStepPos);
      if(ops[nextStepPos] == OpCodes.FROM_DESCENDANTS_OR_SELF)
        orSelf = true;
      
    }
    
    
    int nextStepPos = firstStepPos;
    while(true)
    {
      nextStepPos = compiler.getNextStepPos(nextStepPos);
      if(nextStepPos > 0)
      {
        int stepOp = compiler.getOp(nextStepPos);
        if(OpCodes.ENDOP != stepOp)
          firstStepPos = nextStepPos;
        else
          break;
      }
      else
        break;
      
    }
    
    
    if((analysis & WalkerFactory.BIT_CHILD) != 0)
      orSelf = false;
      
    if(fromRoot)
    {
      if(orSelf)
        m_axis = Axis.DESCENDANTSORSELFFROMROOT;
      else
        m_axis = Axis.DESCENDANTSFROMROOT;
    }
    else if(orSelf)
      m_axis = Axis.DESCENDANTORSELF;
    else
      m_axis = Axis.DESCENDANT;

    int whatToShow = compiler.getWhatToShow(firstStepPos);

    if ((0 == (whatToShow
               & (DTMFilter.SHOW_ATTRIBUTE | DTMFilter.SHOW_ELEMENT
                  | DTMFilter.SHOW_PROCESSING_INSTRUCTION))) || 
                   (whatToShow == DTMFilter.SHOW_ALL))
      initNodeTest(whatToShow);
    else
    {
      initNodeTest(whatToShow, compiler.getStepNS(firstStepPos),
                              compiler.getStepLocalName(firstStepPos));
    }
    initPredicateInfo(compiler, firstStepPos);
  }
  
  
  public DescendantIterator()
  {
    super(null);
    m_axis = Axis.DESCENDANTSORSELFFROMROOT;
    int whatToShow = DTMFilter.SHOW_ALL;
    initNodeTest(whatToShow);
  }

  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    DescendantIterator clone = (DescendantIterator) super.cloneWithReset();
    clone.m_traverser = m_traverser;

    clone.resetProximityPositions();

    return clone;
  }

  
  public int nextNode()
  {
   	if(m_foundLast)
  		return DTM.NULL;

    if(DTM.NULL == m_lastFetched)
    {
      resetProximityPositions();
    }

    int next;
    
    org.apache.xpath.VariableStack vars;
    int savedStart;
    if (-1 != m_stackFrame)
    {
      vars = m_execContext.getVarStack();

      
      savedStart = vars.getStackFrame();

      vars.setStackFrame(m_stackFrame);
    }
    else
    {
      
      vars = null;
      savedStart = 0;
    }
    
    try
    {
      do
      {
        if(0 == m_extendedTypeID)
        {
          next = m_lastFetched = (DTM.NULL == m_lastFetched)
                       ? m_traverser.first(m_context)
                       : m_traverser.next(m_context, m_lastFetched);
        }
        else
        {
          next = m_lastFetched = (DTM.NULL == m_lastFetched)
                       ? m_traverser.first(m_context, m_extendedTypeID)
                       : m_traverser.next(m_context, m_lastFetched, 
                                          m_extendedTypeID);
        }
  
        if (DTM.NULL != next)
        {
          if(DTMIterator.FILTER_ACCEPT == acceptNode(next))
            break;
          else
            continue;
        }
        else
          break;
      }
      while (next != DTM.NULL);
  
      if (DTM.NULL != next)
      {
      	m_pos++;
        return next;
      }
      else
      {
        m_foundLast = true;
  
        return DTM.NULL;
      }
    }
    finally
    {
      if (-1 != m_stackFrame)
      {
        
        vars.setStackFrame(savedStart);
      }
    }
  }
  
  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    m_traverser = m_cdtm.getAxisTraverser(m_axis);
    
    String localName = getLocalName();
    String namespace = getNamespace();
    int what = m_whatToShow;
    
    
    if(DTMFilter.SHOW_ALL == what
       || localName == NodeTest.WILD
       || namespace == NodeTest.WILD)
    {
      m_extendedTypeID = 0;
    }
    else
    {
      int type = getNodeTypeTest(what);
      m_extendedTypeID = m_cdtm.getExpandedTypeID(namespace, localName, type);
    }
    
  }
  
  
  public int asNode(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
    if(getPredicateCount() > 0)
      return super.asNode(xctxt);

    int current = xctxt.getCurrentNode();
    
    DTM dtm = xctxt.getDTM(current);
    DTMAxisTraverser traverser = dtm.getAxisTraverser(m_axis);
    
    String localName = getLocalName();
    String namespace = getNamespace();
    int what = m_whatToShow;
    
    
    
    
    
    if(DTMFilter.SHOW_ALL == what
       || localName == NodeTest.WILD
       || namespace == NodeTest.WILD)
    {
      return traverser.first(current);
    }
    else
    {
      int type = getNodeTypeTest(what);
      int extendedType = dtm.getExpandedTypeID(namespace, localName, type);
      return traverser.first(current, extendedType);
    }
  }
  
  
  public void detach()
  {    
    m_traverser = null;    
    m_extendedTypeID = 0;
    
    
    super.detach();
  }
  
  
  public int getAxis()
  {
    return m_axis;
  }
  
  
  
  transient protected DTMAxisTraverser m_traverser;
  
  
  protected int m_axis;
  
  
  protected int m_extendedTypeID;
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(m_axis != ((DescendantIterator)expr).m_axis)
  		return false;
  		
  	return true;
  }

  
}
"
org.apache.xalan.processor.ProcessorTemplate,2,5,0,6,8,1,1,5,0,2.0,19,0.0,0,0.995327103,0.666666667,1,1,8.5,1,0.5,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;


class ProcessorTemplate extends ProcessorTemplateElem
{
  
  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    super.appendAndPush(handler, elem);
    elem.setDOMBackPointer(handler.getOriginatingNode());
    handler.getStylesheet().setTemplate((ElemTemplate) elem);
  }
}
"
org.apache.xpath.functions.FuncSubstringAfter,2,5,0,7,8,1,0,7,2,2.0,34,0.0,0,0.98245614,0.75,1,6,16.0,1,0.5,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;

import org.apache.xml.utils.XMLString;


public class FuncSubstringAfter extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XMLString s1 = m_arg0.execute(xctxt).xstr();
    XMLString s2 = m_arg1.execute(xctxt).xstr();
    int index = s1.indexOf(s2);

    return (-1 == index)
           ? XString.EMPTYSTRING
           : (XString)s1.substring(index + s2.length());
  }
}
"
org.apache.xalan.xsltc.compiler.IdPattern,1,6,0,1,2,0,1,1,1,2.0,6,0.0,0,1.0,1.0,0,0,5.0,0,0.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.*;

final class IdPattern extends IdKeyPattern {

    public IdPattern(String id) {
	super(""##id"",id);
    }

}
"
org.apache.xalan.extensions.ExpressionContext,6,1,0,18,6,15,16,3,6,2.0,6,0.0,0,0.0,0.5,0,0,0.0,1,1.0,1,"
package org.apache.xalan.extensions;

import org.w3c.dom.traversal.NodeIterator;
import org.w3c.dom.Node;
import org.apache.xpath.objects.XObject;


public interface ExpressionContext
{

  
  public Node getContextNode();

  
  public NodeIterator getContextNodes();

  
  public double toNumber(Node n);

  
  public String toString(Node n);

  
  public XObject getVariableOrParam(org.apache.xml.utils.QName qname)
            throws javax.xml.transform.TransformerException;
  
  
  public org.apache.xpath.XPathContext getXPathContext()
            throws javax.xml.transform.TransformerException;

}
"
org.apache.xalan.templates.ElemWhen,7,3,0,10,16,9,1,9,6,0.5,55,1.0,1,0.97029703,0.314285714,2,5,6.714285714,2,1.0,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;


public class ElemWhen extends ElemTemplateElement
{

  
  private XPath m_test;

  
  public void setTest(XPath v)
  {
    m_test = v;
  }

  
  public XPath getTest()
  {
    return m_test;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_WHEN;
  }
  
  
  public void compose(StylesheetRoot sroot) 
    throws javax.xml.transform.TransformerException
  {
    super.compose(sroot);
    java.util.Vector vnames = sroot.getComposeState().getVariableNames();
    if(null != m_test)
      m_test.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_WHEN_STRING;
  }

  
  public ElemWhen(){}
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  		m_test.getExpression().callVisitors(m_test, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xpath.XPath,17,1,0,60,64,78,44,16,17,0.96875,462,0.2,1,0.0,0.211764706,0,0,25.58823529,2,0.9412,0,"
package org.apache.xpath;

import java.io.Serializable;
import java.util.Vector;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;
import org.apache.xalan.res.XSLMessages;
import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.FunctionTable;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xpath.functions.Function;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;
import org.w3c.dom.Node;


public class XPath implements Serializable, ExpressionOwner
{

  
  private Expression m_mainExp;

  
  public Expression getExpression()
  {
    return m_mainExp;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_mainExp.fixupVariables(vars, globalsSize);
  }

  
  public void setExpression(Expression exp)
  {
  	if(null != m_mainExp)
    	exp.exprSetParent(m_mainExp.exprGetParent()); 
    m_mainExp = exp;
  }

  
  public SourceLocator getLocator()
  {
    return m_mainExp;
  }














  
  String m_patternString;

  
  public String getPatternString()
  {
    return m_patternString;
  }

  
  public static final int SELECT = 0;

  
  public static final int MATCH = 1;

  
  public XPath(
          String exprString, SourceLocator locator, PrefixResolver prefixResolver, int type,
          ErrorListener errorListener)
            throws javax.xml.transform.TransformerException
  {      
    if(null == errorListener)
      errorListener = new org.apache.xml.utils.DefaultErrorHandler();
    
    m_patternString = exprString;

    XPathParser parser = new XPathParser(errorListener, locator);
    Compiler compiler = new Compiler(errorListener, locator);

    if (SELECT == type)
      parser.initXPath(compiler, exprString, prefixResolver);
    else if (MATCH == type)
      parser.initMatchPattern(compiler, exprString, prefixResolver);
    else
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANNOT_DEAL_XPATH_TYPE, new Object[]{Integer.toString(type)})); 

    
    Expression expr = compiler.compile(0);

    
    this.setExpression(expr);
    
    if((null != locator) && locator instanceof ExpressionNode)
    {
    	expr.exprSetParent((ExpressionNode)locator);
    }

  }
  
  
  public XPath(
          String exprString, SourceLocator locator, PrefixResolver prefixResolver, int type)
            throws javax.xml.transform.TransformerException
  {  
    this(exprString, locator, prefixResolver, type, null);    
  }

  
  public XPath(Expression expr)
  {  
    this.setExpression(expr);   
  }
  
  
  public XObject execute(
          XPathContext xctxt, org.w3c.dom.Node contextNode, 
          PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {
    return execute(
          xctxt, xctxt.getDTMHandleFromNode(contextNode), 
          namespaceContext);
  }
  

  
  public XObject execute(
          XPathContext xctxt, int contextNode, PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    xctxt.pushNamespaceContext(namespaceContext);

    xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);

    XObject xobj = null;

    try
    {
      xobj = m_mainExp.execute(xctxt);
    }
    catch (TransformerException te)
    {
      te.setLocator(this.getLocator());
      ErrorListener el = xctxt.getErrorListener();
      if(null != el) 
      {
        el.error(te);
      }
      else
        throw te;
    }
    catch (Exception e)
    {
      while (e instanceof org.apache.xml.utils.WrappedRuntimeException)
      {
        e = ((org.apache.xml.utils.WrappedRuntimeException) e).getException();
      }
      

      String msg = e.getMessage();
      msg = (msg == null || msg.length()== 0)? ""Unknown error in XPath"" : msg;
      TransformerException te = new TransformerException(msg,
              getLocator(), e);
      ErrorListener el = xctxt.getErrorListener();
      
      if(null != el) 
      {
        el.fatalError(te);
      }
      else
        throw te;
    }
    finally
    {
      xctxt.popNamespaceContext();

      xctxt.popCurrentNodeAndExpression();
    }

    return xobj;
  }
  
  
  public boolean bool(
          XPathContext xctxt, int contextNode, PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    xctxt.pushNamespaceContext(namespaceContext);

    xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);

    try
    {
      return m_mainExp.bool(xctxt);
    }
    catch (TransformerException te)
    {
      te.setLocator(this.getLocator());
      ErrorListener el = xctxt.getErrorListener();
      if(null != el) 
      {
        el.error(te);
      }
      else
        throw te;
    }
    catch (Exception e)
    {
      while (e instanceof org.apache.xml.utils.WrappedRuntimeException)
      {
        e = ((org.apache.xml.utils.WrappedRuntimeException) e).getException();
      }
      

      String msg = e.getMessage();
      msg = (msg == null || msg.length()== 0)? ""Unknown error in XPath"" : msg;
      TransformerException te = new TransformerException(msg,
              getLocator(), e);
      ErrorListener el = xctxt.getErrorListener();
      
      if(null != el) 
      {
        el.fatalError(te);
      }
      else
        throw te;
    }
    finally
    {
      xctxt.popNamespaceContext();

      xctxt.popCurrentNodeAndExpression();
    }

    return false;
  }

  
  private static final boolean DEBUG_MATCHES = false;

  
  public double getMatchScore(XPathContext xctxt, int context)
          throws javax.xml.transform.TransformerException
  {

    xctxt.pushCurrentNode(context);
    xctxt.pushCurrentExpressionNode(context);

    try
    {
      XObject score = m_mainExp.execute(xctxt);

      if (DEBUG_MATCHES)
      {
        DTM dtm = xctxt.getDTM(context);
        System.out.println(""score: "" + score.num() + "" for ""
                           + dtm.getNodeName(context) + "" for xpath ""
                           + this.getPatternString());
      }

      return score.num();
    }
    finally
    {
      xctxt.popCurrentNode();
      xctxt.popCurrentExpressionNode();
    }

    
  }

  
  public void installFunction(String name, int funcIndex, Function func)
  {
    FunctionTable.installFunction(func, funcIndex);
  }

  
  public void warn(
          XPathContext xctxt, int sourceNode, int msg, Object[] args)
            throws javax.xml.transform.TransformerException
  {

    String fmsg = XSLMessages.createXPATHWarning(msg, args);
    ErrorListener ehandler = xctxt.getErrorListener();

    if (null != ehandler)
    {

      
      ehandler.warning(new TransformerException(fmsg, (SAXSourceLocator)xctxt.getSAXLocator()));
    }
  }

  
  public void assertion(boolean b, String msg)
  {

    if (!b)
    {
      String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ msg });

      throw new RuntimeException(fMsg);
    }
  }

  
  public void error(
          XPathContext xctxt, int sourceNode, int msg, Object[] args)
            throws javax.xml.transform.TransformerException
  {

    String fmsg = XSLMessages.createXPATHMessage(msg, args);
    ErrorListener ehandler = xctxt.getErrorListener();

    if (null != ehandler)
    {
      ehandler.fatalError(new TransformerException(fmsg,
                              (SAXSourceLocator)xctxt.getSAXLocator()));
    }
    else
    {
      SourceLocator slocator = xctxt.getSAXLocator();
      System.out.println(fmsg + ""; file "" + slocator.getSystemId()
                         + ""; line "" + slocator.getLineNumber() + ""; column ""
                         + slocator.getColumnNumber());
    }
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	m_mainExp.callVisitors(this, visitor);
  }

  
  public static final double MATCH_SCORE_NONE = Double.NEGATIVE_INFINITY;

  
  public static final double MATCH_SCORE_QNAME = 0.0;

  
  public static final double MATCH_SCORE_NSWILD = -0.25;

  
  public static final double MATCH_SCORE_NODETEST = -0.5;

  
  public static final double MATCH_SCORE_OTHER = 0.5;
}
"
org.apache.xalan.transformer.MsgMgr,14,1,0,13,23,55,12,2,13,0.153846154,212,1.0,2,0.0,0.427350427,0,0,14.0,1,0.8571,0,"
package org.apache.xalan.transformer;

import org.apache.xalan.res.XSLMessages;

import org.xml.sax.Locator;
import org.xml.sax.helpers.LocatorImpl;

import org.w3c.dom.Node;

import javax.xml.transform.TransformerException;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.dom.DOMLocator;
import javax.xml.transform.SourceLocator;


public class MsgMgr
{

  
  public MsgMgr(TransformerImpl transformer)
  {
    m_transformer = transformer;
  }

  
  private TransformerImpl m_transformer;

  
  private static XSLMessages m_XSLMessages = new XSLMessages();

  
  public void message(SourceLocator srcLctr, String msg, boolean terminate) throws TransformerException
  {

    ErrorListener errHandler = m_transformer.getErrorListener();

    if (null != errHandler)
    {
      errHandler.warning(new TransformerException(msg, srcLctr));
    }
    else
    {
      if (terminate)
        throw new TransformerException(msg, srcLctr);
      else
        System.out.println(msg);
    }
  }

  
  public void warn(SourceLocator srcLctr, int msg) throws TransformerException
  {
    warn(srcLctr, null, null, msg, null);
  }

  
  public void warn(SourceLocator srcLctr, int msg, Object[] args) throws TransformerException
  {
    warn(srcLctr, null, null, msg, args);
  }

  
  public void warn(SourceLocator srcLctr, Node styleNode, Node sourceNode, int msg)
          throws TransformerException
  {
    warn(srcLctr, styleNode, sourceNode, msg, null);
  }

  
  public void warn(SourceLocator srcLctr, Node styleNode, Node sourceNode, int msg, Object args[])
          throws TransformerException
  {

    String formattedMsg = m_XSLMessages.createWarning(msg, args);
    ErrorListener errHandler = m_transformer.getErrorListener();

    if (null != errHandler)
      errHandler.warning(new TransformerException(formattedMsg, srcLctr));
    else
      System.out.println(formattedMsg);
  }

  
  public void error(SourceLocator srcLctr, String msg) throws TransformerException
  {

    
    
    
    
    ErrorListener errHandler = m_transformer.getErrorListener();

    if (null != errHandler)
      errHandler.fatalError(new TransformerException(msg, srcLctr));
    else
      throw new TransformerException(msg, srcLctr);
  }

  
  public void error(SourceLocator srcLctr, int msg) throws TransformerException
  {
    error(srcLctr, null, null, msg, null);
  }

  
  public void error(SourceLocator srcLctr, int msg, Object[] args) throws TransformerException
  {
    error(srcLctr, null, null, msg, args);
  }

  
  public void error(SourceLocator srcLctr, int msg, Exception e) throws TransformerException
  {
    error(srcLctr, msg, null, e);
  }

  
  public void error(SourceLocator srcLctr, int msg, Object args[], Exception e) throws TransformerException
  {

    
    String formattedMsg = m_XSLMessages.createMessage(msg, args);

    
    
    
    
    ErrorListener errHandler = m_transformer.getErrorListener();

    if (null != errHandler)
      errHandler.fatalError(new TransformerException(formattedMsg, srcLctr));
    else
      throw new TransformerException(formattedMsg, srcLctr);
  }

  
  public void error(SourceLocator srcLctr, Node styleNode, Node sourceNode, int msg)
          throws TransformerException
  {
    error(srcLctr, styleNode, sourceNode, msg, null);
  }

  
  public void error(SourceLocator srcLctr, Node styleNode, Node sourceNode, int msg, Object args[])
          throws TransformerException
  {

    String formattedMsg = m_XSLMessages.createMessage(msg, args);

    
    
    
    
    ErrorListener errHandler = m_transformer.getErrorListener();

    if (null != errHandler)
      errHandler.fatalError(new TransformerException(formattedMsg, srcLctr));
    else
      throw new TransformerException(formattedMsg, srcLctr);
  }
}
"
org.apache.xalan.xsltc.dom.DOMImpl,116,1,0,60,203,4934,44,48,62,0.905590062,2911,1.0,6,0.0,0.103864734,0,0,23.85344828,13,2.0776,2,"

package org.apache.xalan.xsltc.dom;

import java.io.Externalizable;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.IOException;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Stack;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.DOMException;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Document;

import org.xml.sax.*;
import org.xml.sax.ext.*;
import org.xml.sax.helpers.AttributesImpl;
import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.util.IntegerArray;
import org.apache.xalan.xsltc.runtime.BasisLibrary;
import org.apache.xalan.xsltc.runtime.SAXAdapter;
import org.apache.xalan.xsltc.runtime.Hashtable;

public final class DOMImpl implements DOM, Externalizable {

    
    private final static String EMPTYSTRING = """";

    
    private final static NodeIterator EMPTYITERATOR = new NodeIterator() {
	    public NodeIterator reset() { return this; }
	    public NodeIterator setStartNode(int node) { return this; }
	    public int next() { return NULL; }
	    public void setMark() {}
	    public void gotoMark() {}
	    public int getLast() { return 0; }
	    public int getPosition() { return 0; }
	    public NodeIterator cloneIterator() { return this; }
	    public boolean isReverse() { return false; }
	    public NodeIterator resetOnce() { return this; }
	    public NodeIterator includeSelf() { return this; }
	    public void setRestartable(boolean isRestartable) { }
	};

    
    private int       _treeNodeLimit;
    private int       _firstAttributeNode;

    
    private short[]   _type;
    private Hashtable _types = null;
    private String[]  _namesArray;

    
    private int[]     _parent;
    private int[]     _nextSibling;
    private int[]     _offsetOrChild; 
    private int[]     _lengthOrAttr;  

    
    private char[]    _text;

    
    private String[]  _uriArray;
    private String[]  _prefixArray;
    private short[]   _namespace;
    private short[]   _prefix;
    private Hashtable _nsIndex = new Hashtable();

    
    private BitArray  _whitespace; 

    
    private BitArray  _dontEscape = null; 

    
    private String    _documentURI = null;
    static private int _documentURIIndex = 0;

    
    private Node[] _nodes;
    private NodeList[] _nodeLists;
    private static NodeList EmptyNodeList;
    private static NamedNodeMap EmptyNamedNodeMap;

    private final static String XML_LANG_ATTRIBUTE =
	""http:

    
    public void setDocumentURI(String uri) {
	_documentURI = uri;
    }

    
    public String getDocumentURI() {
	return (_documentURI != null) ? _documentURI : ""rtf"" + _documentURIIndex++;
    }

    public String getDocumentURI(int node) {
	return getDocumentURI();
    }

    public void setupMapping(String[] names, String[] namespaces) {
	
    }

    
    public String lookupNamespace(int node, String prefix) 
	throws TransletException 
    {
	int anode, nsnode;
	final AncestorIterator ancestors = new AncestorIterator();
	
	if (isElement(node)) {
	    ancestors.includeSelf();
	}

	ancestors.setStartNode(node);
	while ((anode = ancestors.next()) != NULL) {
	    final NodeIterator namespaces = 
		new NamespaceIterator().setStartNode(anode);

	    while ((nsnode = namespaces.next()) != NULL) {
		if (_prefixArray[_prefix[nsnode]].equals(prefix)) {
		    return getNodeValue(nsnode);
		}
	    }
	}

	
	throw new TransletException(""Namespace prefix '"" + prefix + ""' is undeclared."");
    }

    
    public boolean isElement(final int node) {
	final int type = _type[node];
	return ((node < _firstAttributeNode) && (type >= NTYPES));
    }

    
    public boolean isAttribute(final int node) {
	final int type = _type[node];
	return ((node >= _firstAttributeNode) && (type >= NTYPES));
    }

    
    public int getSize() {
	return(_type.length);
    }

    
    public void setFilter(StripFilter filter) { }


    
    public boolean lessThan(int node1, int node2) {
	
	if (node1 >= _firstAttributeNode) node1 = _parent[node1];
	if (node2 >= _firstAttributeNode) node2 = _parent[node2];
	return (node2 < _treeNodeLimit && node1 < node2);
    }

    
    public Node makeNode(int index) {
	if (_nodes == null) {
	    _nodes = new Node[_type.length];
	}
	return _nodes[index] != null ? _nodes[index]
				     : (_nodes[index] = new NodeImpl(index));
    }

    
    public Node makeNode(NodeIterator iter) {
	return makeNode(iter.next());
    }

    
    public NodeList makeNodeList(int index) {
	if (_nodeLists == null) {
	    _nodeLists = new NodeList[_type.length];
	}
	return _nodeLists[index] != null ? _nodeLists[index]
		     : (_nodeLists[index] = new NodeListImpl(index));
    }

    
    public NodeList makeNodeList(NodeIterator iter) {
	return new NodeListImpl(iter);
    }

    
    private NodeList getEmptyNodeList() {
	return EmptyNodeList != null ? EmptyNodeList
	    : (EmptyNodeList = new NodeListImpl(new int[0]));
    }

    
    private NamedNodeMap getEmptyNamedNodeMap() {
	return EmptyNamedNodeMap != null ? EmptyNamedNodeMap
	    : (EmptyNamedNodeMap = new NamedNodeMapImpl(new int[0]));
    }

    
    private final class NotSupportedException extends DOMException {
	public NotSupportedException() {
	    super(NOT_SUPPORTED_ERR, ""modification not supported"");
	}
    }

    
    private final class NodeListImpl implements NodeList {
	private final int[] _nodes;

	public NodeListImpl(int node) {
	    _nodes = new int[1];
	    _nodes[0] = node;
	}

	public NodeListImpl(int[] nodes) {
	    _nodes = nodes;
	}
                  
	public NodeListImpl(NodeIterator iter) {
	    final IntegerArray list = new IntegerArray();
	    int node;
	    while ((node = iter.next()) != NodeIterator.END) {
		list.add(node);
	    }         
	    _nodes = list.toIntArray();         
	}

	public int getLength() {
	    return _nodes.length;
	}
                  
	public Node item(int index) {
	    return makeNode(_nodes[index]);
	}
    }

                  
    
    private final class NamedNodeMapImpl implements NamedNodeMap {

	private final int[] _nodes;
		
	public NamedNodeMapImpl(int[] nodes) {
	    _nodes = nodes;
	}
		
	public int getLength() {
	    return _nodes.length;
	}
		
	public Node getNamedItem(String name) {
	    for (int i = 0; i < _nodes.length; i++) {
		if (name.equals(getNodeName(_nodes[i]))) {
		    return makeNode(_nodes[i]);
		}
	    }
	    return null;
	}
		
	public Node item(int index) {
	    return makeNode(_nodes[index]);
	}
		
	public Node removeNamedItem(String name) {
	    throw new NotSupportedException();
	}
		
	public Node setNamedItem(Node node) {
	    throw new NotSupportedException();
	}

	public Node getNamedItemNS(String uri, String local) {
	    return(getNamedItem(uri+':'+local));
	}

	public Node setNamedItemNS(Node node) {
	    throw new NotSupportedException();
	}

	public Node removeNamedItemNS(String uri, String local) {
	    throw new NotSupportedException();
	}

    }


    
    private final class NodeImpl implements Node {

	private final int _index;

	public NodeImpl(int index) {
	    _index = index;
	}

	public short getNodeType() {
	    switch (_type[_index]) {
	    case ROOT:
		return Node.DOCUMENT_NODE;
		
	    case TEXT:
		return Node.TEXT_NODE;
		
	    case PROCESSING_INSTRUCTION:
		return Node.PROCESSING_INSTRUCTION_NODE;
		
	    case COMMENT:
		return Node.COMMENT_NODE;
		
	    default:
		return _index < _firstAttributeNode
		    ? Node.ELEMENT_NODE : Node.ATTRIBUTE_NODE;
	    }
	}
		
	public Node getParentNode() {
	    final int parent = getParent(_index);
	    return parent > NULL ? makeNode(parent) : null;
	}
		
	public Node appendChild(Node node) throws DOMException {
	    throw new NotSupportedException();
	}
		
	public Node cloneNode(boolean deep) {
	    throw new NotSupportedException();
	}
		
	public NamedNodeMap getAttributes() {
	    if (getNodeType() == Node.ELEMENT_NODE) {
		int attribute = _lengthOrAttr[_index];
		
		while (_type[attribute] == NAMESPACE) {
		    attribute = _nextSibling[attribute];
		}
		if (attribute != NULL) {
		    final IntegerArray attributes = new IntegerArray(4);
		    do {
			attributes.add(attribute);
		    }
		    while ((attribute = _nextSibling[attribute]) != 0);
		    return new NamedNodeMapImpl(attributes.toIntArray());
		}
		else {
		    return getEmptyNamedNodeMap();
		}
	    }
	    else {
		return null;
	    }
	}

	public NodeList getChildNodes() {
	    if (hasChildNodes()) {
		final IntegerArray children = new IntegerArray(8);
		int child = _offsetOrChild[_index];
		do {
		    children.add(child);
		}
		while ((child = _nextSibling[child]) != 0);
		return new NodeListImpl(children.toIntArray());
	    }
	    else {
		return getEmptyNodeList();
	    }
	}
		
	public Node getFirstChild() {
	    return hasChildNodes()
		? makeNode(_offsetOrChild[_index])
		: null;
	}
		
	public Node getLastChild() {
	    return hasChildNodes()
		? makeNode(lastChild(_index))
		: null;
	}
		
	public Node getNextSibling() {
	    final int next = _nextSibling[_index];
	    return next != 0 ? makeNode(next) : null;
	}
		
	public String getNodeName() {
	    switch (_type[_index]) {
	    case ROOT:
		return ""#document"";
	    case TEXT:
		return ""#text"";
	    case PROCESSING_INSTRUCTION:
		return ""#pi"";
	    case COMMENT:
		return ""#comment"";
	    default:
		return DOMImpl.this.getNodeName(_index);
	    }
	}
		
	public String getNodeValue() throws DOMException {
	    return DOMImpl.this.getNodeValue(_index);
	}
		
	public Document getOwnerDocument() {
	    return null;
	}
		
	
	public Node getPreviousSibling() {
	    int node = _parent[_index];
	    if (node > NULL) {
		int prev = -1;
		node = _offsetOrChild[node];
		while (node != _index) {
		    node = _nextSibling[prev = node];
		}
		if (prev != -1) {
		    return makeNode(prev);
		}
	    }
	    return null;
	}
		
	public boolean hasChildNodes() {
	    switch (getNodeType()) {
	    case Node.ELEMENT_NODE:
	    case Node.DOCUMENT_NODE:
		return _offsetOrChild[_index] != 0;

	    default:
		return false;
	    }
	}
		
	public Node insertBefore(Node n1, Node n2) throws DOMException {
	    throw new NotSupportedException();
	}
		
	public Node removeChild(Node n) throws DOMException {
	    throw new NotSupportedException();
	}
		
	public Node replaceChild(Node n1, Node n2) throws DOMException {
	    throw new NotSupportedException();
	}
		
	public void setNodeValue(String s) throws DOMException {
	    throw new NotSupportedException();
	}

	public void normalize() {
	    throw new NotSupportedException();
	}

	public boolean isSupported(String feature, String version) {
	    return false;
	}

	public String getNamespaceURI() {
	    return _uriArray[_namespace[_type[_index] - NTYPES]];
	}

	public String getPrefix() {
	    return _prefixArray[_prefix[_index]];
	}

	public void setPrefix(String prefix) {
	    throw new NotSupportedException();
	}

	public String getLocalName() {
	    return DOMImpl.this.getLocalName(_index);
	}

	public boolean hasAttributes() {
	    int attribute = _lengthOrAttr[_index];
	    while (_type[attribute] == NAMESPACE) {
		attribute = _nextSibling[attribute];
	    }
	    return (attribute != NULL);
	}

    }

    
    private Filter _elementFilter;

    
    private Filter getElementFilter() {
	if (_elementFilter == null) {
	    _elementFilter = new Filter() {
		    public boolean test(int node) {
			return isElement(node);
		    }
		};
	}
	return _elementFilter;
    }

    
    private final class TypeFilter implements Filter {
	private final int _nodeType;
                  
	public TypeFilter(int type) {
	    _nodeType = type;
	}
                  
	public boolean test(int node) {
	    return _type[node] == _nodeType;
	}
    }

    
    public Filter getTypeFilter(int type) {
	return new TypeFilter(type);
    }


    
    private final class ChildrenIterator extends NodeIteratorBase {
	
	private int _currentChild;
	private int _last = -1;

	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		if (node >= _firstAttributeNode) node = NULL;
		if (node != _startNode) _last = -1;
		_startNode = node;
		if (_includeSelf) {
		    _currentChild = -1;
		}
		else {
		    if (hasChildren(node))
			_currentChild = _offsetOrChild[node];
		    else
			_currentChild = END;
		}
		return resetPosition();
	    }
	    return this;
	}

	public int next() {
	    int node = _currentChild;
	    if (_includeSelf) {
		if (node == -1) {
		    node = _startNode;
		    if (hasChildren(node))
			_currentChild = _offsetOrChild[node];
		    else
			_currentChild = END;
		    
		    
		    
		    return node;
		}
	    }
	    _currentChild = _nextSibling[node];
	    return returnNode(node);
	}

	public void setMark() {
	    _markedNode = _currentChild;
	}

	public void gotoMark() {
	    _currentChild = _markedNode;
	}

	public int getLast() {
	    if (_last == -1) {
		_last = 1;
		int node = _offsetOrChild[_startNode];
		while ((node = _nextSibling[node]) != END) _last++;
	    }
	    return(_last);
	}

    } 


    
    private final class ParentIterator extends NodeIteratorBase {
	
	private int _node;
	private int _nodeType = -1;
         
	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		_node = _parent[_startNode = node];
		return resetPosition();
	    }
	    return this;
	}
             
	public NodeIterator setNodeType(final int type) {
	    _nodeType = type;
	    return this;
	}

	public int next() {
	    int result = _node;
	    if ((_nodeType != -1) && (_type[_node] != _nodeType))
		result = END;
	    else
		result = _node;
	    _node = END;
	    return returnNode(result);
	}

	public void setMark() {
	    _markedNode = _node;
	}

	public void gotoMark() {
	    _node = _markedNode;
	}
    } 


    
    private final class TypedChildrenIterator extends NodeIteratorBase {
	private int _nodeType;
	
	private int _currentChild;
         
	public TypedChildrenIterator(int nodeType) {
	    _nodeType = nodeType;
	}

	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		if (node >= _firstAttributeNode) node = NULL;
		_currentChild = hasChildren(node)
		    ? _offsetOrChild[_startNode = node] : END;
		return resetPosition();
	    }
	    return this;
	}

	public NodeIterator cloneIterator() {
	    try {
		final TypedChildrenIterator clone =
		    (TypedChildrenIterator)super.clone();
		clone._nodeType = _nodeType;
		clone.setRestartable(false);
		return clone.reset();
	    }
	    catch (CloneNotSupportedException e) {
		BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
					  e.toString());
		return null;
	    }
	}

	public NodeIterator reset() {
	    _currentChild = hasChildren(_startNode) ? 
			    _offsetOrChild[_startNode] : END;
	    return resetPosition();
	}

	public int next() {
	    final short[] type = _type;
	    final int nodeType = _nodeType;
	    final int[] nextSibling = _nextSibling;

	    for (int node = _currentChild; node != END; node = nextSibling[node]) {
		if (type[node] == nodeType) {
		    _currentChild = nextSibling[node];
		    return returnNode(node);
		}
	    }
	    return END;
	}

	public void setMark() {
	    _markedNode = _currentChild;
	}

	public void gotoMark() {
	    _currentChild = _markedNode;
	}
    } 


    
    private final class NamespaceChildrenIterator extends NodeIteratorBase {
	private final int _nsType;
	private int _currentChild;
         
	public NamespaceChildrenIterator(final int type) {
	    _nsType = type;
	}

	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		if (node >= _firstAttributeNode) node = NULL;
		_currentChild = hasChildren(node)
		    ? _offsetOrChild[_startNode = node] : END;
		return resetPosition();
	    }
	    return this;
	}

	public int next() {
	    for (int node = _currentChild; node != END; 
		 node = _nextSibling[node]) {
		if (getNamespaceType(node) == _nsType) {
		    _currentChild = _nextSibling[node];
		    return returnNode(node);
		}
	    }
	    return END;
	}

	public void setMark() {
	    _markedNode = _currentChild;
	}

	public void gotoMark() {
	    _currentChild = _markedNode;
	}

    } 


    
    private final class NamespaceAttributeIterator extends NodeIteratorBase {

	private final int _nsType;
	private int _attribute;
         
	public NamespaceAttributeIterator(int nsType) {
	    super();
	    _nsType = nsType;
	}
                  
	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		for (node = _lengthOrAttr[_startNode = node];
		     node != NULL && getNamespaceType(node) != _nsType;
		     node = _nextSibling[node]);
		_attribute = node;
		return resetPosition();
	    }
	    return this;
	}
                  
	public int next() {
	    final int save = _attribute;
	    int node = save;
	    do {
		_attribute = _nextSibling[_attribute];
	    } while(_type[_attribute] == NAMESPACE);
	    
	    for (node = _lengthOrAttr[_startNode = node];
		 node != NULL && getNamespaceType(node) != _nsType;
		 node = _nextSibling[node]);
	    _attribute = node;

	    return returnNode(save);
	}

	public void setMark() {
	    _markedNode = _attribute;
	}

	public void gotoMark() {
	    _attribute = _markedNode;
	}
         
    } 


    
    private class FollowingSiblingIterator extends NodeIteratorBase {
	private int _node;
         
	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		if (node >= _firstAttributeNode) node = NULL;
		_node = _startNode = node;
		return resetPosition();
	    }
	    return this;
	}
                  
	public int next() {
	    return returnNode(_node = _nextSibling[_node]);
	}

	public void setMark() {
	    _markedNode = _node;
	}

	public void gotoMark() {
	    _node = _markedNode;
	}
    } 


    
    private final class TypedFollowingSiblingIterator
	extends FollowingSiblingIterator {
	private final int _nodeType;

	public TypedFollowingSiblingIterator(int type) {
	    _nodeType = type;
	}
         
	public int next() {
	    int node;
	    while ((node = super.next()) != NULL) {
		if (_type[node] == _nodeType) return(node);
		_position--;
	    }
	    return END;
	}

    } 


    
    private final class AttributeIterator extends NodeIteratorBase {
	private int _attribute;
         
	
	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		if (isElement(node)) {
		    _attribute = _lengthOrAttr[_startNode = node];
		    
		    while (_type[_attribute] == NAMESPACE) {
			_attribute = _nextSibling[_attribute];
		    }
		}
		else {
		    _attribute = NULL;
		}
		return resetPosition();
	    }
	    return this;
	}
                  
	public int next() {
	    final int node = _attribute;
	    _attribute = _nextSibling[_attribute];
	    return returnNode(node);
	}

	public void setMark() {
	    _markedNode = _attribute;
	}

	public void gotoMark() {
	    _attribute = _markedNode;
	}
    } 


    
    private final class TypedAttributeIterator extends NodeIteratorBase {
	private final int _nodeType;
	private int _attribute;
         
	public TypedAttributeIterator(int nodeType) {
	    _nodeType = nodeType;
	}
                  
	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		
		if (!isElement(node)) {
		    _attribute = END;
		    return resetPosition();
		}

		for (node = _lengthOrAttr[_startNode = node];
		     node != NULL && _type[node] != _nodeType;
		     node = _nextSibling[node]);
		_attribute = node;
		return resetPosition();
	    }
	    return this;
	}

	public NodeIterator reset() {
	    int node = _startNode;
	    for (node = _lengthOrAttr[node];
		 node != NULL && _type[node] != _nodeType;
		 node = _nextSibling[node]);
	    _attribute = node;
	    return resetPosition();
	}
                  
	public int next() {
	    final int node = _attribute;
	    _attribute = NULL;         
	    return returnNode(node);
	}

	public void setMark() {
	    _markedNode = _attribute;
	}

	public void gotoMark() {
	    _attribute = _markedNode;
	}
    } 


    
    private class NamespaceIterator extends NodeIteratorBase {
	
	protected int _node;
	protected int _ns;
         
	
	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		if (isElement(node)) {
		    _startNode = _node = node;
		    _ns = _lengthOrAttr[_node];
		    while ((_ns != DOM.NULL) && (_type[_ns] != NAMESPACE)) {
			_ns = _nextSibling[_ns];
		    }
		}
		else {
		    _ns = DOM.NULL;
		}
		return resetPosition();
	    }
	    return this;
	}
                  
	public int next() {
	    while (_node != NULL) {
		final int node = _ns;
		_ns = _nextSibling[_ns];

		while ((_ns == DOM.NULL) && (_node != DOM.NULL)) {
		    _node = _parent[_node];
		    _ns = _lengthOrAttr[_node];

		    while ((_ns != DOM.NULL) && (_type[_ns] != NAMESPACE)) {
			_ns = _nextSibling[_ns];
		    }
		}
		if (_type[node] == NAMESPACE)
		    return returnNode(node);
	    }
	    return NULL;
	}

	public void setMark() {
	    _markedNode = _ns;
	}

	public void gotoMark() {
	    _ns = _markedNode;
	}
	
    } 


    
    private final class TypedNamespaceIterator extends NamespaceIterator {

	final int _uriType;

	public TypedNamespaceIterator(int type) {
	    _uriType = type;
	}

	public int next() {
	    int node;

	    while ((node = _ns) != DOM.NULL) {
		_ns = _nextSibling[_ns];
		while ((_ns == DOM.NULL) && (_node != DOM.NULL)) {
		    _node = _parent[_node];
		    _ns = _lengthOrAttr[_node];
		    while ((_ns != DOM.NULL) && (_type[_ns] != NAMESPACE)) {
			_ns = _nextSibling[_ns];
		    }
		}
		if (_prefix[node] == _uriType) return returnNode(node);
	    }
	    return DOM.NULL;
	}
         
    } 


    
    private class PrecedingSiblingIterator extends NodeIteratorBase {

	private int _node;
	private int _mom;
         
	public boolean isReverse() {
	    return true;
	}
         
	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		if (node >= _firstAttributeNode) node = NULL;
		int tmp = NULL;
		_startNode = node;
		_mom = _parent[node];
		_node = _offsetOrChild[_mom];
		while ((_node != node) && (_node != NULL)) {
		    tmp = _node;
		    _node = _nextSibling[_node];
		}
		_node = tmp;
		return resetPosition();
	    }
	    return this;
	}

	public int next() {
	    
	    if (_node == NULL) return NULL;

	    int current = _offsetOrChild[_mom];

	    
	    int last = NULL;
	    while ((current != _node) && (current != NULL)) {
		last = current;
		current = _nextSibling[current];
	    }
	    current = _node;
	    _node = last;
	    return returnNode(current);
	}

	public void setMark() {
	    _markedNode = _node;
	}

	public void gotoMark() {
	    _node = _markedNode;
	}

    } 


    
    private final class TypedPrecedingSiblingIterator
	extends PrecedingSiblingIterator {
	private final int _nodeType;

	public TypedPrecedingSiblingIterator(int type) {
	    _nodeType = type;
	}
         
	public int next() {
	    int node;
	    while ((node = super.next()) != NULL && _type[node] != _nodeType)
		_position--;
	    return(node);
	}

    } 


    
    private class PrecedingIterator extends NodeIteratorBase {

	private int _node = 0;
	private int _mom = 0;

	public boolean isReverse() {
	    return true;
	}
         
	public NodeIterator cloneIterator() {
	    try {
		final PrecedingIterator clone = 
		    (PrecedingIterator)super.clone();
		clone.setRestartable(false);
		return clone.reset();
	    }
	    catch (CloneNotSupportedException e) {
		BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
					  e.toString());
		return null;
	    }
	}
         
	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		if (node >= _firstAttributeNode) node = _parent[node];
		_node = _startNode = node;
		_mom  = _parent[_startNode];
		return resetPosition();
	    }
	    return this;
	}
                  
	public int next() {
	    while (--_node > ROOTNODE) {
		if (_node < _mom) _mom = _parent[_mom];
		if (_node != _mom) return returnNode(_node);
	    }
	    return(NULL);
	}

	
	public NodeIterator reset() {
	    _node = _startNode;
	    _mom  = _parent[_startNode];
	    return resetPosition();
	}

	public void setMark() {
	    _markedNode = _node;
	}

	public void gotoMark() {
	    _node = _markedNode;
	}

    } 


    
    private final class TypedPrecedingIterator extends PrecedingIterator {
	private final int _nodeType;

	public TypedPrecedingIterator(int type) {
	    _nodeType = type;
	}
         
	public int next() {
	    int node;
	    while ((node = super.next()) != NULL && _type[node] != _nodeType)
		_position--; 
	    return node;
	}

    } 


    
    private class FollowingIterator extends NodeIteratorBase {
	
	protected int _node;
                  
	public NodeIterator setStartNode(int node) {
	    int skip = 0;
	    if (_isRestartable) {
		if (node >= _firstAttributeNode) {
		    skip = 1;
		    node = _parent[node];
		    int child = _offsetOrChild[node];
		    if (child != NULL) node = child;
		}
		_startNode = node;

		
		int current;
		while ((node = lastChild(current = node)) != NULL) { }

		_node = current - skip;
		
		return resetPosition();
	    }
	    return this;
	}
                      
	public int next() {
	    final int node = _node + 1;
	    return node < _firstAttributeNode ? returnNode(_node = node) : NULL;
	}

	public void setMark() {
	    _markedNode = _node;
	}

	public void gotoMark() {
	    _node = _markedNode;
	}
    } 


    
    private final class TypedFollowingIterator extends FollowingIterator {
	private final int _nodeType;

	public TypedFollowingIterator(int type) {
	    _nodeType = type;
	}
                  
	public int next() {
	    int node;
	    while ((node = super.next()) != NULL) {
		if (_type[node] == _nodeType) return(node);
		_position--;
	    }
	    return END;
	}
    } 


             
    private class AncestorIterator extends NodeIteratorBase {

	protected int _index;
	protected int _last = -1;

	public final boolean isReverse() {
	    return true;
	}

	public int getLast() {
	    if (_last > -1) return _last;
	    int count = 1;
	    int node = _startNode;
	    while ((node = _parent[node]) != ROOT) count++;
	    _last = count;
	    return(count);
	}
         
	public NodeIterator cloneIterator() {
	    try {
		final AncestorIterator clone = (AncestorIterator)super.clone();
		clone.setRestartable(false); 
		clone._startNode = _startNode;
		return clone.reset();
	    }
	    catch (CloneNotSupportedException e) {
		BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
					  e.toString());
		return null;
	    }
	}
                  
	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		_last = -1;
		if (_includeSelf) {
		    _startNode = node;
		}
		else if (node >= _firstAttributeNode) {
		    _startNode = node = _parent[node];
		}
		else {
		    _startNode = _parent[node];
		}
		_index = _startNode;
		return resetPosition();
	    }
	    return this;
	}

	public NodeIterator reset() {
	    _index = _startNode;
	    return resetPosition();
	}
                  
	public int next() {
	    if (_index >= 0) {
		final int node = _index;
		_index = (_index == 0) ? -1 : _parent[_index];
		return returnNode(node);
	    }
	    return(NULL);
	}

	public void setMark() {
	    _markedNode = _index;
	}

	public void gotoMark() {
	    _index = _markedNode;
	}
    } 


                 
    private final class TypedAncestorIterator extends AncestorIterator {

	private final int _nodeType;
                  
	public TypedAncestorIterator(int type) {
	    _nodeType = type;
	}

	public int next() {
	    int node;
	    while ((node = super.next()) != NULL) {
		if (_type[node] == _nodeType) return(node);
		_position--;
	    }
	    return(NULL);
	}

	public int getLast() {
	    if (_last > -1) return _last;
	    int count = 1;
	    int node = _startNode;
	    do {
		if (_type[node] == _nodeType) count++;
	    } while ((node = _parent[node]) != ROOT);
	    _last = count;
	    return(count);
	}

    } 


                 
    private class DescendantIterator extends NodeIteratorBase {
	
	protected int _node;
	
	protected int _limit;

	public NodeIterator setStartNode(int node) {
	    _startNode = node;
	    if (_isRestartable) {
		_node = _startNode = _includeSelf ? node - 1 : node;
		
		if (hasChildren(node) == false) {
		    
		    _limit = node + 1;
		}
		
		else if ((node = _nextSibling[node]) == 0) {
		    
		    _limit = _treeNodeLimit;
		}
		else {
		    _limit = leftmostDescendant(node);
		}
		return resetPosition();
	    }
	    return this;
	}

	public int next() {
	    while (++_node < _limit) {
		if (_type[_node] > TEXT) {
		    return(returnNode(_node));
		}
	    } 
	    return(NULL);
	}

	public void setMark() {
	    _markedNode = _node;
	}

	public void gotoMark() {
	    _node = _markedNode;
	}

    } 


                 
    private final class TypedDescendantIterator extends DescendantIterator {
	private final int _nodeType;
                  
	public TypedDescendantIterator(int nodeType) {
	    _nodeType = nodeType;
	}
                  
	public int next() {
	    final int limit = _limit;
	    final int type = _nodeType;
	    int node = _node + 1; 
	    
	    
	    while (node < limit && _type[node] != type) {
		++node;
	    }
	    return node < limit ? returnNode(_node = node) : NULL;
	}

    } 


                 
    private class NthDescendantIterator extends DescendantIterator {

	final NodeIterator _source;
	final int _pos;
	final int _ourtype;

	public NthDescendantIterator(NodeIterator source, int pos, int type) {
	    _source = source;
	    _ourtype = type;
	    _pos = pos;
	}

	public void setRestartable(boolean isRestartable) {
	    _isRestartable = isRestartable;
	    _source.setRestartable(isRestartable);
	}

	
	public NodeIterator setStartNode(int node) {
	    _source.setStartNode(node);
	    return this;
	}

	public int next() {
	    int node;
	    while ((node = _source.next()) != END) {
		int parent = _parent[node];
		int child = _offsetOrChild[parent];
		int pos = 0;

		if (_ourtype != -1) {
		    do {
			if (isElement(child) && _type[child] == _ourtype) pos++;
		    } while ((pos<_pos) && (child = _nextSibling[child]) != 0);
		}
		else {
		    do {
			if (isElement(child)) pos++;
		    } while ((pos<_pos) && (child = _nextSibling[child]) != 0);
		}

		if (node == child) return node; 
	    }
	    return(END);
	}

	public NodeIterator reset() {
	    _source.reset();
	    return this;
	}


    } 


                 
    private final class TypedSingletonIterator extends SingletonIterator {
	private final int _nodeType;

	public TypedSingletonIterator(int nodeType) {
	    _nodeType = nodeType;
	}
         
	public int next() {
	    final int result = super.next();
	    return _type[result] == _nodeType ? result : NULL;
	}
    } 


                 
    private final class StrippingIterator extends NodeIteratorBase {

	private static final int USE_PREDICATE  = 0;
	private static final int STRIP_SPACE    = 1;
	private static final int PRESERVE_SPACE = 2;

	private StripFilter _filter = null;
	private short[] _mapping = null;
	private final NodeIterator _source;
	private boolean _children = false;
	private int _action = USE_PREDICATE;
	private int _last = -1;

	public StrippingIterator(NodeIterator source,
				 short[] mapping,
				 StripFilter filter) {

	    _filter = filter;
	    _mapping = mapping;
	    _source = source;

	    if (_source instanceof ChildrenIterator ||
		_source instanceof TypedChildrenIterator) {
		_children = true;
	    }
	}

	public void setRestartable(boolean isRestartable) {
	    _isRestartable = isRestartable;
	    _source.setRestartable(isRestartable);
	}

	public NodeIterator setStartNode(int node) {
	    if (_children) {
		if (_filter.stripSpace((DOM)DOMImpl.this, node,
				       _mapping[_type[node]]))
		    _action = STRIP_SPACE;
		else
		    _action = PRESERVE_SPACE;
	    }

	    _source.setStartNode(node);
	    
	    return(this);
	}
    
	public int next() {
	    int node;
	    while ((node = _source.next()) != END) {
		switch(_action) {
		case STRIP_SPACE:
		    if (_whitespace.getBit(node)) continue;
		    
		case PRESERVE_SPACE:
		    return returnNode(node);
		case USE_PREDICATE:
		default:
		    if (_whitespace.getBit(node) &&
			_filter.stripSpace((DOM)DOMImpl.this, node,
					   _mapping[_type[_parent[node]]]))
			continue;
		    return returnNode(node);
		}
	    }
	    return END;
	}

	public NodeIterator reset() {
	    _source.reset();
	    return this;
	}

	public void setMark() {
	    _source.setMark();
	}

	public void gotoMark() {
	    _source.gotoMark();
	}

	public int getLast() {
	    
	    if (_last != -1) return _last;

	    int count = getPosition();
	    int node;

	    _source.setMark();
	    while ((node = _source.next()) != END) {
		switch(_action) {
		case STRIP_SPACE:
		    if (_whitespace.getBit(node))
			continue;
		    
		case PRESERVE_SPACE:
		    count++;
		    break;
		case USE_PREDICATE:
		default:
		    if (_whitespace.getBit(node) &&
			_filter.stripSpace((DOM)DOMImpl.this, node,
					   _mapping[_type[_parent[node]]]))
			continue;
		    else
			count++;
		}
	    }
	    _source.gotoMark();
	    _last = count;
	    return(count);
	}

    } 

    public NodeIterator strippingIterator(NodeIterator iterator,
					  short[] mapping,
					  StripFilter filter) {
	return(new StrippingIterator(iterator, mapping, filter));
    }

    
    private final class NodeValueIterator extends NodeIteratorBase {

	private NodeIterator _source;
	private String _value;
	private boolean _op;
	private final boolean _isReverse;
	private int _returnType = RETURN_PARENT;
	private int _pos;

	public NodeValueIterator(NodeIterator source, int returnType,
				 String value, boolean op) {
	    _source = source;
	    _returnType = returnType;
	    _value = value;
	    _op = op;
	    _isReverse = source.isReverse();
	}

	public boolean isReverse() {
	    return _isReverse;
	}
    
	public void setRestartable(boolean isRestartable) {
	    _isRestartable = isRestartable;
	    _source.setRestartable(isRestartable);
	}

	public NodeIterator cloneIterator() {
	    try {
		NodeValueIterator clone = (NodeValueIterator)super.clone();
		clone._source = _source.cloneIterator();
		clone.setRestartable(false);
		return clone.reset();
	    }
	    catch (CloneNotSupportedException e) {
		BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
					  e.toString());
		return null;
	    }
	}
    
	public NodeIterator reset() {
	    _source.reset();
	    return resetPosition();
	}

	public int next() {

	    int node;
	    while ((node = _source.next()) != END) {
		String val = getNodeValue(node);
		if (_value.equals(val) == _op) {
		    if (_returnType == RETURN_CURRENT)
			return returnNode(node);
		    else
			return returnNode(_parent[node]);
		}
	    }
	    return END;
	}

	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		_source.setStartNode(_startNode = node); 
		return resetPosition();
	    }
	    return this;
	}

	public void setMark() {
	    _source.setMark();
	    _pos = _position;
	}

	public void gotoMark() {
	    _source.gotoMark();
	    _position = _pos;
	}
    }                       

    public NodeIterator getNodeValueIterator(NodeIterator iterator, int type,
					     String value, boolean op) {
	return(new NodeValueIterator(iterator, type, value, op));
    }

    
    public NodeIterator orderNodes(NodeIterator source, int node) {
	return new DupFilterIterator(source);
    }

    
    private int leftmostDescendant(int node) {
	int current;
	while (_type[current = node] >= NTYPES 
	       && (node = _offsetOrChild[node]) != NULL) {
	}
	return current;
    }

    
    private int lastChild(int node) {
	if (isElement(node) || node == ROOTNODE) {
	    int child;
	    if ((child = _offsetOrChild[node]) != NULL) {
		while ((child = _nextSibling[node = child]) != NULL) {
		}
		return node;
	    }
	}
	return 0;
    }

    
    public int getParent(final int node) {
	return _parent[node];
    }

    public int getElementPosition(int node) {
	
	int match = 0;
	int curr  = _offsetOrChild[_parent[node]];
	if (isElement(curr)) match++;

	
	while (curr != node) {
	    curr = _nextSibling[curr];
	    if (isElement(curr)) match++;
	}

	
	return match;         
    }

    public int getAttributePosition(int attr) {
	
	int match = 1;
	int curr  = _lengthOrAttr[_parent[attr]];

	
	while (curr != attr) {
	    curr = _nextSibling[curr];
	    match++;
	}

	
	return match;         
    }

    
    public int getTypedPosition(int type, int node) {
	
	switch(type) {
	case ELEMENT:
	    return getElementPosition(node);
	case ATTRIBUTE:
	    return getAttributePosition(node);
	case -1:
	    type = _type[node];
	}

	
	int match = 0;
	int curr  = _offsetOrChild[_parent[node]];
	if (_type[curr] == type) match++;

	
	while (curr != node) {
	    curr = _nextSibling[curr];
	    if (_type[curr] == type) match++;
	}

	
	return match;         
    }

    
    public int getTypedLast(int type, int node) {
	
	if (type == -1) type = _type[node];

	
	int match = 0;
	int curr  = _offsetOrChild[_parent[node]];
	if (_type[curr] == type) match++;

	
	while (curr != NULL) {
	    curr = _nextSibling[curr];
	    if (_type[curr] == type) match++;
	}

	return match;         
    }

    
    public NodeIterator getIterator() {
	return new SingletonIterator(ROOTNODE);
    }

    
    public int getType(final int node) {
	return (node >= _type.length) ? 0 : _type[node];
    }
    
    
    public int getNamespaceType(final int node) {
	final int type = _type[node];
	return (type >= NTYPES) ? _namespace[type-NTYPES] 
	    : 0; 	
    }

    
    public short[] getTypeArray() {
	return _type;
    }

    
    public String getNodeValue(final int node) {
	
	if ((node == NULL) || (node > _treeNodeLimit)) return EMPTYSTRING;
	switch(_type[node]) {
	case ROOT:
	    return getNodeValue(_offsetOrChild[node]);
	case TEXT:
	    
	case COMMENT:
	    return makeStringValue(node);
	case PROCESSING_INSTRUCTION:
	    final String pistr = makeStringValue(node);
	    final int col = pistr.indexOf(' ');
	    return (col > 0) ?  pistr.substring(col+1) : pistr;
	default:
	    return (node < _firstAttributeNode) ? getElementValue(node) :
						  makeStringValue(node);
	}
    }

    private String getLocalName(int node) {
	final int type = _type[node] - NTYPES;
	final String qname = _namesArray[type];
	final String uri = _uriArray[_namespace[type]];

	if (uri != null) {
	    final int len = uri.length();
	    if (len > 0) return qname.substring(len+1);
	}
	return qname;
    }

    
    private Hashtable setupMapping(String[] namesArray) {
	final int nNames = namesArray.length;
	final Hashtable types = new Hashtable(nNames);
	for (int i = 0; i < nNames; i++) {
	    types.put(namesArray[i], new Integer(i + NTYPES));
	}
	return types;
    }

    
    public int getGeneralizedType(final String name) {
	final Integer type = (Integer)_types.get(name);
	if (type == null) {
	    
	    final int code = name.charAt(0) == '@' ? ATTRIBUTE : ELEMENT;
	    _types.put(name, new Integer(code));
	    return code;
	}
	else {
	    return type.intValue();
	}
    }

    
    public short[] getMapping(String[] names) {
	int i;
	final int namesLength = names.length;
	final int mappingLength = _namesArray.length + NTYPES;
	final short[] result = new short[mappingLength];

	
	for (i = 0; i < NTYPES; i++)
	    result[i] = (short)i;

	
	
	for (i = NTYPES; i < mappingLength; i++) {
	    final int type = i - NTYPES;
	    final String name = _namesArray[type];
	    final String uri = _uriArray[_namespace[type]];
	    int len = 0;
	    if (uri != null) {
		len = uri.length();
		if (len > 0) len++;
	    }
	    result[i] = (short) ((name.length() > 0 && name.charAt(len) == '@') ?
		ATTRIBUTE : ELEMENT);
	}

	
	for (i = 0; i < namesLength; i++) {
	    result[getGeneralizedType(names[i])] = (short)(i + NTYPES);
	}

	return result;
    }

    
    public short[] getReverseMapping(String[] names) {
	int i;
	final short[] result = new short[names.length + NTYPES];
	
	for (i = 0; i < NTYPES; i++) {
	    result[i] = (short)i;
	}
	
	for (i = 0; i < names.length; i++) {
	    result[i + NTYPES] = (short)getGeneralizedType(names[i]);
	    if (result[i + NTYPES] == ELEMENT)
		result[i + NTYPES] = NO_TYPE;
	}
	return result;
    }

    
    public short[] getNamespaceMapping(String[] namespaces) {
	int i;
	final int nsLength = namespaces.length;
	final int mappingLength = _uriArray.length;
	final short[] result = new short[mappingLength];

	
	for (i=0; i<mappingLength; i++)
	    result[i] = (-1);

	for (i=0; i<nsLength; i++) {
	    Integer type = (Integer)_nsIndex.get(namespaces[i]);
	    if (type != null) {
		result[type.intValue()] = (short)i;
	    }
	}

	return(result);
    }

    
    public short[] getReverseNamespaceMapping(String[] namespaces) {
	int i;
	final int length = namespaces.length;
	final short[] result = new short[length];

	for (i = 0; i < length; i++) {
	    Integer type = (Integer)_nsIndex.get(namespaces[i]);
	    result[i] = (type == null) ? -1 : type.shortValue();
	}
	return result;
    }

    
    public void writeExternal(ObjectOutput out) throws IOException {
	out.writeInt(_treeNodeLimit);      
	out.writeInt(_firstAttributeNode); 
	out.writeObject(_documentURI);     

	out.writeObject(_type);            
	out.writeObject(_namespace);       
	out.writeObject(_prefix);          

	out.writeObject(_parent);          
	out.writeObject(_nextSibling);     
	out.writeObject(_offsetOrChild);   
	out.writeObject(_lengthOrAttr);    

	out.writeObject(_text);            
	out.writeObject(_namesArray);      
	out.writeObject(_uriArray);        
	out.writeObject(_prefixArray);     

	out.writeObject(_whitespace);

	if (_dontEscape != null) {
	    out.writeObject(_dontEscape);
	}
	else {
	    out.writeObject(new BitArray(0));
	}

	out.flush();
    }

    
    public void readExternal(ObjectInput in)
	throws IOException, ClassNotFoundException {
	_treeNodeLimit = in.readInt();
	_firstAttributeNode = in.readInt();
	_documentURI = (String)in.readObject();

	_type          = (short[])in.readObject();
	_namespace     = (short[])in.readObject();
	_prefix        = (short[])in.readObject();

	_parent        = (int[])in.readObject();
	_nextSibling   = (int[])in.readObject();
	_offsetOrChild = (int[])in.readObject();
	_lengthOrAttr  = (int[])in.readObject();

	_text          = (char[])in.readObject();
	_namesArray    = (String[])in.readObject();
	_uriArray      = (String[])in.readObject();
	_prefixArray   = (String[])in.readObject();

	_whitespace    = (BitArray)in.readObject();

	_dontEscape    = (BitArray)in.readObject();
	if (_dontEscape.size() == 0) {
	    _dontEscape = null;
        }

	_types         = setupMapping(_namesArray);
    }

    
    public DOMImpl() {
	
	this(8*1024);
    }
         
    
    public DOMImpl(int size) {
	_type          = new short[size];
	_parent        = new int[size];
	_nextSibling   = new int[size];
	_offsetOrChild = new int[size];
	_lengthOrAttr  = new int[size];
	_text          = new char[size * 10];
	_whitespace    = new BitArray(size);
	_prefix        = new short[size];
	
    }

    
    public void print(int node, int level) {
	switch(_type[node]) {
	case ROOT:
	    print(_offsetOrChild[node], level);
	    break;
	case TEXT:
	case COMMENT:
	case PROCESSING_INSTRUCTION:
	    System.out.print(makeStringValue(node));
	    break;
	default:                  
	    final String name = getNodeName(node);
	    System.out.print(""<"" + name);
	    for (int a = _lengthOrAttr[node]; a != NULL; a = _nextSibling[a]) {
		System.out.print(""
"" + getNodeName(a) +
				 ""="""" + makeStringValue(a) + """""");
	    }
	    System.out.print('>');
	    for (int child = _offsetOrChild[node]; child != NULL;
		 child = _nextSibling[child]) {
		print(child, level + 1);
	    }
	    System.out.println(""</"" + name + '>');
	    break;
	}
    }

    
    public String getNodeName(final int node) {
	
	final short type = _type[node];
	switch(type) {
	case DOM.ROOT:
	case DOM.TEXT:
	case DOM.ELEMENT:
	case DOM.ATTRIBUTE:
	case DOM.COMMENT:
	    return EMPTYSTRING;
	case DOM.NAMESPACE:
	    final int index = _prefix[node];
	    return (index < _prefixArray.length) ? _prefixArray[index]
						 : EMPTYSTRING;
	case DOM.PROCESSING_INSTRUCTION:
	    final String pistr = makeStringValue(node);
	    final int col = pistr.indexOf(' ');
	    return (col > -1) ? pistr.substring(0,col) : pistr;
	default:
	    
	    String name  = getLocalName(node);
	    if (node >= _firstAttributeNode)
		name = name.substring(1);

	    final int pi = _prefix[node];
	    if (pi > 0) {
		final String prefix = _prefixArray[pi];
		if (prefix != EMPTYSTRING) {
		    name = prefix + ':' + name;
		}
	    }
	    return name;
	}
    }

    
    public String getNamespaceName(final int node) {
	if (_type[node] == NAMESPACE) {
	    return(EMPTYSTRING); 
	}
	else {
	    final int type = getNamespaceType(node);
	    final String name = _uriArray[type];
	    return (name == null) ? EMPTYSTRING : name;
	}
    }

    
    private String makeStringValue(final int node) {
	return new String(_text, _offsetOrChild[node], _lengthOrAttr[node]);
    }

    
    public int getAttributeNode(final int type, final int element) {
	for (int attr = _lengthOrAttr[element];
	     attr != NULL;
	     attr = _nextSibling[attr]) {
	    if (_type[attr] == type) return attr;
	}
	return NULL;
    }

    
    public String getAttributeValue(final int type, final int element) {
	final int attr = getAttributeNode(type, element);
	return (attr != NULL) ? makeStringValue(attr) : EMPTYSTRING;
    }

    
    public boolean hasAttribute(final int type, final int node) {
	return (getAttributeNode(type, node) != NULL);
    }

    
    public String getAttributeValue(final String name, final int element) {
	return getAttributeValue(getGeneralizedType(name), element);
    }
    
    
    private boolean hasChildren(final int node) {
	if (node < _firstAttributeNode) {
	    final int type = _type[node];
	    return(((type >= NTYPES) || (type == ROOT)) &&
		   (_offsetOrChild[node] != 0));
	}
	return(false);
    }

    
    public NodeIterator getChildren(final int node) {
	return hasChildren(node) ? new ChildrenIterator()
				 : EMPTYITERATOR;
    }

    
    public NodeIterator getTypedChildren(final int type) {
	return(new TypedChildrenIterator(type));
    }

    
    public NodeIterator getAxisIterator(final int axis) {
	NodeIterator iterator = null;

	switch (axis) {
	case Axis.SELF:
	    iterator = new SingletonIterator();
	    break;
	case Axis.CHILD:
	    iterator = new ChildrenIterator();
	    break;
	case Axis.PARENT:
	    return(new ParentIterator());
	case Axis.ANCESTOR:
	    return(new AncestorIterator());
	case Axis.ANCESTORORSELF:
	    return((new AncestorIterator()).includeSelf());
	case Axis.ATTRIBUTE:
	    return(new AttributeIterator());
	case Axis.DESCENDANT:
	    iterator = new DescendantIterator();
	    break;
	case Axis.DESCENDANTORSELF:
	    iterator = (new DescendantIterator()).includeSelf();
	    break;
	case Axis.FOLLOWING:
	    iterator = new FollowingIterator();
	    break;
	case Axis.PRECEDING:
	    iterator = new PrecedingIterator();
	    break;
	case Axis.FOLLOWINGSIBLING:
	    iterator = new FollowingSiblingIterator();
	    break;
	case Axis.PRECEDINGSIBLING:
	    iterator = new PrecedingSiblingIterator();
	    break;
	case Axis.NAMESPACE:
	    iterator = new NamespaceIterator();
	    break;
	default:
	    BasisLibrary.runTimeError(BasisLibrary.AXIS_SUPPORT_ERR,
				      Axis.names[axis]);
	}
	return(iterator);
    }

    
    public NodeIterator getTypedAxisIterator(int axis, int type) {
	

	
	if (axis == Axis.CHILD && type != ELEMENT) {
	    return new TypedChildrenIterator(type);
	}

	if (type == NO_TYPE) {
	    return EMPTYITERATOR;
	}

        if (type == ELEMENT && axis != Axis.NAMESPACE) {
	    return new FilterIterator(getAxisIterator(axis),
				      getElementFilter());
	}
	else {
	    switch (axis) {
	    case Axis.SELF:
		return new TypedSingletonIterator(type);
	    case Axis.PARENT:
		return new ParentIterator().setNodeType(type);
	    case Axis.ANCESTOR:
		return new TypedAncestorIterator(type);
	    case Axis.ANCESTORORSELF:
		return (new TypedAncestorIterator(type)).includeSelf();
	    case Axis.ATTRIBUTE:
		return new TypedAttributeIterator(type);
	    case Axis.DESCENDANT:
		return new TypedDescendantIterator(type);
	    case Axis.DESCENDANTORSELF:
		return (new TypedDescendantIterator(type)).includeSelf();
	    case Axis.FOLLOWING:
		return new TypedFollowingIterator(type);
	    case Axis.PRECEDING:
		return new TypedPrecedingIterator(type);
	    case Axis.FOLLOWINGSIBLING:
		return new TypedFollowingSiblingIterator(type);
	    case Axis.PRECEDINGSIBLING:
		return new TypedPrecedingSiblingIterator(type);
	    case Axis.NAMESPACE:
		return (type == ELEMENT) ?  
		    (NodeIterator) new NamespaceIterator() :
		    (NodeIterator) new TypedNamespaceIterator(type);
	    default:
		BasisLibrary.runTimeError(BasisLibrary.TYPED_AXIS_SUPPORT_ERR,
					  Axis.names[axis]);
	    }
	}
	return null;
    }

    
    public NodeIterator getNamespaceAxisIterator(int axis, int ns) {
	if (ns == NO_TYPE) {
	    return EMPTYITERATOR;
	}
	else {
	    switch (axis) {
	    case Axis.CHILD:
		return new NamespaceChildrenIterator(ns);
	    case Axis.ATTRIBUTE:
		return new NamespaceAttributeIterator(ns);
	    default:
		BasisLibrary.runTimeError(BasisLibrary.TYPED_AXIS_SUPPORT_ERR,
					  Axis.names[axis]);
	    }
	}
	return null;
    }

    
    public NodeIterator getTypedDescendantIterator(int type) {
	return (type == ELEMENT) ? (NodeIterator)
	    new FilterIterator(new DescendantIterator(), getElementFilter())
	    : (NodeIterator) new TypedDescendantIterator(type);
    }

    
    public NodeIterator getNthDescendant(int type, int n, boolean includeself) {
	NodeIterator source = (type == ELEMENT) ? (NodeIterator)
	     new FilterIterator(new DescendantIterator(), getElementFilter())
	     : (NodeIterator) new TypedDescendantIterator(type);

	if (includeself) {
	    ((NodeIteratorBase)source).includeSelf();
	}
	return new NthDescendantIterator(source, n, type);
    }

    
    public void characters(final int textNode, TransletOutputHandler handler)
	throws TransletException {
	handler.characters(_text,
			   _offsetOrChild[textNode],
			   _lengthOrAttr[textNode]);
    }

    
    public void copy(NodeIterator nodes, TransletOutputHandler handler)
	throws TransletException {
	int node;
	while ((node = nodes.next()) != NULL) {
	    copy(node, handler);
	}
    }

    
    public void copy(TransletOutputHandler handler) throws TransletException {
	copy(ROOTNODE, handler);
    }

    
    public void copy(final int node, TransletOutputHandler handler)
	throws TransletException {

	final int type = _type[node];

	switch(type) {
	case ROOT:
	    for (int c=_offsetOrChild[node]; c!=NULL; c=_nextSibling[c])
		copy(c, handler);
	    break;
	case PROCESSING_INSTRUCTION:
	    copyPI(node, handler);
	    break;
	case COMMENT:
	    handler.comment(new String(_text,
				       _offsetOrChild[node],
				       _lengthOrAttr[node]));
	    break;
	case TEXT:
	    boolean last = false;
	    boolean escapeBit = false;

	    if (_dontEscape != null) {	
		escapeBit = _dontEscape.getBit(node);
		if (escapeBit) {
		    last = handler.setEscaping(false);
		}	
	    }

	    handler.characters(_text,
			       _offsetOrChild[node],
			       _lengthOrAttr[node]);

            if (_dontEscape != null && escapeBit) {
		handler.setEscaping(last);
	    }	
	    break;
	case ATTRIBUTE:
	    shallowCopy(node, handler);
	    break;
	case NAMESPACE:
	    shallowCopy(node, handler);
	    break;
	default:
	    if (isElement(node)) {
		
		final String name = copyElement(node, type, handler);

		
		for (int a=_lengthOrAttr[node]; a!=NULL; a=_nextSibling[a]) {
		    if (_type[a] != NAMESPACE) {
			final String uri = getNamespaceName(a);
			if (uri != EMPTYSTRING) {
			    final String prefix = _prefixArray[_prefix[a]];
			    handler.namespace(prefix, uri);
			}
			handler.attribute(getNodeName(a), makeStringValue(a));
		    }
		    else {
			handler.namespace(_prefixArray[_prefix[a]],
					  makeStringValue(a));
		    }
		}
		
		for (int c=_offsetOrChild[node]; c!=NULL; c=_nextSibling[c])
		    copy(c, handler);
		
		handler.endElement(name);
	    }
	    
	    else {
		final String uri = getNamespaceName(node);
		if (uri != EMPTYSTRING) {
		    final String prefix = _prefixArray[_prefix[node]];
		    handler.namespace(prefix, uri);
		}
		handler.attribute(getNodeName(node), makeStringValue(node));
	    }
	    break;
	}
    }

     
    private void copyPI(final int node, TransletOutputHandler handler)
	throws TransletException {
	final char[] text = _text;
	final int start = _offsetOrChild[node];
	final int length = _lengthOrAttr[node];

	
	int i = start;
	while (text[i] != ' ') i++;

	final int len = i - start;
	final String target = new String(text, start, len);
	final String value  = new String(text, i + 1, length - len - 1);

	handler.processingInstruction(target, value);
    }

    
    public String shallowCopy(final int node, TransletOutputHandler handler)
	throws TransletException 
    {
	final int type = _type[node];

	switch(type) {
	case ROOT: 
	    return EMPTYSTRING;
	case TEXT:

	    handler.characters(_text,
			       _offsetOrChild[node],
			       _lengthOrAttr[node]);

	    return null;
	case PROCESSING_INSTRUCTION:
	    copyPI(node, handler);
	    return null;
	case COMMENT:
	    final String comment = new String(_text,
					      _offsetOrChild[node],
					      _lengthOrAttr[node]);
	    handler.comment(comment);
	    return null;
	case NAMESPACE:
	    handler.namespace(_prefixArray[_prefix[node]],
			      makeStringValue(node));
	    return null;
	default:
	    if (isElement(node)) {
		return(copyElement(node, type, handler));
	    }
	    else {
		final String uri = getNamespaceName(node);
		if (uri != EMPTYSTRING) {
		    final String prefix = _prefixArray[_prefix[node]];
		    handler.namespace(prefix, uri);
		}
		handler.attribute(getNodeName(node), makeStringValue(node));
		return null;
	    }
	}
    }

    private String copyElement(int node, int type,
			       TransletOutputHandler handler)
	throws TransletException 
    {
	type = type - NTYPES;
	String name = _namesArray[type];
	final int pi = _prefix[node];
	final int ui = _namespace[type];

	if (pi > 0) {
	    final String prefix = _prefixArray[pi];
	    final String uri = _uriArray[ui];
	    final String local = getLocalName(node);

	    name = prefix.equals(EMPTYSTRING) ? local : (prefix + ':' + local);
	    handler.startElement(name);
	    handler.namespace(prefix, uri);
	}
	else {
	    if (ui > 0) {
		handler.startElement(name = getLocalName(node));
		handler.namespace(EMPTYSTRING, _uriArray[ui]);
	    }
	    else {
		handler.startElement(name);
	    }
	}

	
	for (int a = _lengthOrAttr[node]; a != NULL; a = _nextSibling[a]) {
	    if (_type[a] == NAMESPACE) {
		handler.namespace(_prefixArray[_prefix[a]],
				  makeStringValue(a));
	    }
	}

	return name;
    }

    
    private String _cachedStringValue = null;

    public String getStringValue() {
	if (_cachedStringValue == null) {
	    _cachedStringValue = getElementValue(ROOTNODE);
	}
	return _cachedStringValue;
    }

    
    public String getElementValue(final int element) {
	
	final int child = _offsetOrChild[element];
	if (child == NULL)
	    return EMPTYSTRING;
	if ((_type[child] == TEXT) && (_nextSibling[child] == NULL))
	    return makeStringValue(child);
	else
	    return stringValueAux(new StringBuffer(), element).toString();
    }

    
    private StringBuffer stringValueAux(StringBuffer buffer, final int element) {
	for (int child = _offsetOrChild[element];
	     child != NULL;
	     child = _nextSibling[child]) {
	    switch (_type[child]) {
	    case TEXT:
		buffer.append(_text,
			      _offsetOrChild[child],
			      _lengthOrAttr[child]);
		break;
	    case PROCESSING_INSTRUCTION:
	    case COMMENT:
		
		break;
	    default:
		stringValueAux(buffer, child);
	    }
	}
	return buffer;
    }

    public String getTreeString() {
	StringBuffer buf = new StringBuffer();
	buf = getElementString(buf, ROOTNODE);
	return buf.toString();
    }

    
    private StringBuffer getElementString(StringBuffer buffer, int element) {
	String name = null;

	if (isElement(element)) {
	    if ((name = getNodeName(element)) != null) {
		buffer.append('<');
		buffer.append(name);

		int attribute = _lengthOrAttr[element];
		while (attribute != NULL) {
		    
		    if (_type[attribute] != NAMESPACE) {
			buffer.append(' ').append(getNodeName(attribute))
			      .append(""="""").append(getNodeValue(attribute))
			      .append('""');
		    }
		    attribute = _nextSibling[attribute];
		}

		if (_offsetOrChild[element] == NULL) {
		    buffer.append(""/>"");
		    return buffer;
		}
		buffer.append('>');
	    }
	}

	for (int child = _offsetOrChild[element];
	     child != NULL;
	     child = _nextSibling[child]) {
	    switch (_type[child]) {
	    case COMMENT:
		buffer.append(""<!--"");
		buffer.append(_text,
			      _offsetOrChild[child],
			      _lengthOrAttr[child]);
		buffer.append(""-->"");
		break;
	    case TEXT:
		buffer.append(_text,
			      _offsetOrChild[child],
			      _lengthOrAttr[child]);
		break;
	    case PROCESSING_INSTRUCTION:
		buffer.append(""<?"");
		buffer.append(_text,
			      _offsetOrChild[child],
			      _lengthOrAttr[child]);
		buffer.append(""?>"");
		break;
	    default:
		getElementString(buffer, child);
	    }
	}

	if (isElement(element) && name != null) {
	    buffer.append(""</"");
	    buffer.append(name);
	    buffer.append("">"");
	}

	return buffer;
    }

    
    public String getLanguage(int node) {
	final Integer langType = (Integer)_types.get(XML_LANG_ATTRIBUTE);
	if (langType != null) {
	    final int type = langType.intValue();
	    while (node != DOM.NULL) {
		int attr = _lengthOrAttr[node];
		while (attr != DOM.NULL) {
		    if (_type[attr] == type)
			return(getNodeValue(attr));
		    attr = _nextSibling[attr];
		}
		node = getParent(node);
	    }
	}
	return(null);
    }

    
    public DOMBuilder getBuilder() {
	return new DOMBuilderImpl();
    }

    
    public TransletOutputHandler getOutputDomBuilder() {
	return new SAXAdapter(new DOMBuilderImpl());
    }

    
    private static final boolean isWhitespaceChar(char c) {
	return c == 0x20 || c == 0x0A || c == 0x0D || c == 0x09;
    }


    
    
    
    private final class DOMBuilderImpl implements DOMBuilder {

	private final static int ATTR_ARRAY_SIZE = 32;
	private final static int REUSABLE_TEXT_SIZE = 32;
	private final static int INIT_STACK_LENGTH = 64;

	private Hashtable _shortTexts           = null;

	private Hashtable _names                = null;
	private int       _nextNameCode         = NTYPES;
	private int       _parentStackLength    = INIT_STACK_LENGTH;
	private int[]     _parentStack          = new int[INIT_STACK_LENGTH];
	private int[]     _previousSiblingStack = new int[INIT_STACK_LENGTH];
	private int       _sp;
	private int       _baseOffset           = 0;
	private int       _currentOffset        = 0;
	private int       _currentNode          = 0;

	
	private int       _currentAttributeNode = 1;
	private short[]   _type2        = new short[ATTR_ARRAY_SIZE];
	private short[]   _prefix2      = new short[ATTR_ARRAY_SIZE];
	private int[]     _parent2      = new int[ATTR_ARRAY_SIZE];
	private int[]     _nextSibling2 = new int[ATTR_ARRAY_SIZE];
	private int[]     _offset       = new int[ATTR_ARRAY_SIZE];
	private int[]     _length       = new int[ATTR_ARRAY_SIZE];

	
	private Hashtable _nsPrefixes   = new Hashtable();
	private int       _uriCount     = 0;
	private int       _prefixCount  = 0;

	private int       _nextNamespace = DOM.NULL;
	private int       _lastNamespace = DOM.NULL;
	
	
	
	private int[]   _xmlSpaceStack = new int[64];
	private int     _idx = 1;
	private boolean _preserve = false;

	private static final String XML_STRING = ""xml:"";
	private static final String XMLSPACE_STRING = ""xml:space"";
	private static final String PRESERVE_STRING = ""preserve"";
	private static final String XML_PREFIX   = ""xml"";
	private static final String XMLNS_PREFIX = ""xmlns"";

	private boolean _escaping = true;
	private boolean _disableEscaping = false;

	
	public DOMBuilderImpl() {
	    _xmlSpaceStack[0] = DOM.ROOTNODE;
	}

	
	private String getNamespaceURI(String prefix) {
	    
	    final Stack stack = (Stack)_nsPrefixes.get(prefix);
	    return (stack != null && !stack.empty()) ? (String) stack.peek()
		: EMPTYSTRING;
	}

	
	private void xmlSpaceDefine(String val, final int node) {
	    final boolean setting = val.equals(PRESERVE_STRING);
	    if (setting != _preserve) {
		_xmlSpaceStack[_idx++] = node;
		_preserve = setting;
	    }
	}

	
	private void xmlSpaceRevert(final int node) {
	    if (node == _xmlSpaceStack[_idx - 1]) {
		_idx--;
		_preserve = !_preserve;
	    }
	}

	
	private int nextNode() {
	    final int index = _currentNode++;
	    if (index == _type.length) {
		resizeArrays(_type.length * 2, index);
	    }
	    return index;
	}

	
	private int nextAttributeNode() {
	    final int index = _currentAttributeNode++;
	    if (index == _type2.length) {
		resizeArrays2(_type2.length * 2, index);
	    }
	    return index;
	}

	
	private void resizeTextArray(final int newSize) {
	    final char[] newText = new char[newSize];
	    System.arraycopy(_text, 0, newText, 0, _currentOffset);
	    _text = newText;
	}
	
	
	private void linkChildren(final int node) {
	    _parent[node] = _parentStack[_sp];
	    if (_previousSiblingStack[_sp] != 0) { 
		_nextSibling[_previousSiblingStack[_sp]] = node;
	    }
	    else {
		_offsetOrChild[_parentStack[_sp]] = node;
	    }
	    _previousSiblingStack[_sp] = node;
	}

	
	private void linkParent(final int node) {
	    if (++_sp >= _parentStackLength) {
		int length = _parentStackLength;
		_parentStackLength = length + INIT_STACK_LENGTH;

		final int newParent[] = new int[_parentStackLength];
		System.arraycopy(_parentStack,0,newParent,0,length);
		_parentStack = newParent;

		final int newSibling[] = new int[_parentStackLength];
		System.arraycopy(_previousSiblingStack,0,newSibling,0,length);
		_previousSiblingStack = newSibling;
	    }
	    _parentStack[_sp] = node;
	}

	
	private short makeElementNode(String uri, String localname)
	    throws SAXException {
	    final String name;
	    if (uri != EMPTYSTRING)
		name = uri + ':' + localname;
	    else
		name = localname;

	    
	    Integer obj = (Integer)_names.get(name);
	    if (obj == null) {
		_names.put(name, obj = new Integer(_nextNameCode++));
	    }
	    return (short)obj.intValue();
	}

	
	private short makeElementNode(String name, int col)
	    throws SAXException {
	    
	    if (col > -1) {
		final String uri = getNamespaceURI(name.substring(0, col));
		name = uri + name.substring(col);
	    }
	    
	    else {
		final String uri = getNamespaceURI(EMPTYSTRING);
		if (!uri.equals(EMPTYSTRING)) name = uri + ':' + name;
	    }

	    
	    Integer obj = (Integer)_names.get(name);
	    if (obj == null) {
		_names.put(name, obj = new Integer(_nextNameCode++));
	    }
	    return (short)obj.intValue();
	}

	
	private short registerPrefix(String prefix) {
	    Stack stack = (Stack)_nsPrefixes.get(prefix);
	    if (stack != null) {
		Integer obj = (Integer)stack.elementAt(0);
		return (short)obj.intValue();
	    }
	    return 0;
	}

	
	private int maybeReuseText(final int length) {
	    final int base = _baseOffset;
	    if (length <= REUSABLE_TEXT_SIZE) {
		
		char[] chars = new char[length];
		System.arraycopy(_text, base, chars, 0, length);
		final Integer offsetObj = (Integer)_shortTexts.get(chars);

		if (offsetObj != null) {
		    _currentOffset = base;       
		    return offsetObj.intValue(); 
		}
		else {
		    _shortTexts.put(chars, new Integer(base));
		}
	    }
	    _baseOffset = _currentOffset; 
	    return base;
	}

	
	private void storeTextRef(final int node) {
	    final int length = _currentOffset - _baseOffset;
	    _offsetOrChild[node] = maybeReuseText(length);
	    _lengthOrAttr[node]  = length;
	}
	
	
	private int makeTextNode(boolean isWhitespace) {
	    if (_currentOffset > _baseOffset) {

		final int node = nextNode();
		final int limit = _currentOffset;
		
		if (isWhitespace) {
		    _whitespace.setBit(node);
		}
		
		
		else if (!_preserve) {
		    int i = _baseOffset;
		    while (isWhitespaceChar(_text[i++]) && i < limit) ;
		    if ((i == limit) && isWhitespaceChar(_text[i-1])) {
			_whitespace.setBit(node);
		    }
		}
		_type[node] = TEXT;
		linkChildren(node);
		storeTextRef(node);

		if (_disableEscaping) {
		    if (_dontEscape == null) {
			_dontEscape = new BitArray(_whitespace.size());
		    }
		    _dontEscape.setBit(node);
		    _disableEscaping = false;
		}
		return node;
	    }
	    return -1;
	}

	
	private void storeAttrValRef(final int attributeNode) {
	    final int length = _currentOffset - _baseOffset;
	    _offset[attributeNode] = maybeReuseText(length);
	    _length[attributeNode] = length;
	}

	private int makeNamespaceNode(String prefix, String uri)
	    throws SAXException {

    	    final int node = nextAttributeNode();
	    _type2[node] = NAMESPACE;
	    characters(uri);
	    storeAttrValRef(node);
	    return node;	    
	}

	
	private int makeAttributeNode(int parent, Attributes attList, int i)
	    throws SAXException 
	{
    	    final int node = nextAttributeNode();
	    final String qname = attList.getQName(i);
	    String localName = attList.getLocalName(i);
	    final String value = attList.getValue(i);
	    StringBuffer namebuf = new StringBuffer(EMPTYSTRING);
	    
	    if (qname.startsWith(XMLSPACE_STRING)) {
		xmlSpaceDefine(attList.getValue(i), parent);
	    }

	    
	    if (localName == null) {
		localName = EMPTYSTRING;
	    }

	    
	    final String uri = attList.getURI(i);
	    if (uri != null && !uri.equals(EMPTYSTRING)) {
		namebuf.append(uri);
		namebuf.append(':');
	    }
	    namebuf.append('@');
	    namebuf.append(localName.length() > 0 ? localName : qname);

	    String name = namebuf.toString();

	    
	    Integer obj = (Integer)_names.get(name);
	    if (obj == null) {
		_type2[node] = (short)_nextNameCode;
		_names.put(name, obj = new Integer(_nextNameCode++));
	    }
	    else {
		_type2[node] = (short)obj.intValue();
	    }

	    final int col = qname.lastIndexOf(':');
	    if (col > 0) {
		_prefix2[node] = registerPrefix(qname.substring(0, col));
	    }

	    characters(attList.getValue(i));
	    storeAttrValRef(node);
	    return node;
	}
	
	
	
	

	
	public void characters(char[] ch, int start, int length) {
	    if (_currentOffset + length > _text.length) {
		resizeTextArray(
		    Math.max(_text.length * 2, _currentOffset + length));
	    }
	    System.arraycopy(ch, start, _text, _currentOffset, length);
	    _currentOffset += length;

	    _disableEscaping = !_escaping;	
	}

	
	public void startDocument() throws SAXException {
	    _shortTexts     = new Hashtable();
	    _names          = new Hashtable();
	    _sp             = 0;
	    _parentStack[0] = ROOTNODE;	
	    _currentNode    = ROOTNODE + 1;
	    _currentAttributeNode = 1;
	    _type2[0] = NAMESPACE;

	    definePrefixAndUri(EMPTYSTRING, EMPTYSTRING);
	    startPrefixMapping(XML_PREFIX, ""http:

	    _lengthOrAttr[ROOTNODE] = _nextNamespace;
	    _parent2[_nextNamespace] = ROOTNODE;
	    _nextNamespace = DOM.NULL;
	}

	
	public void endDocument() {
	    makeTextNode(false);

	    _shortTexts = null;
	    final int namesSize = _nextNameCode - NTYPES;

	    
	    _namesArray = new String[namesSize];
	    Enumeration keys = _names.keys();
	    while (keys.hasMoreElements()) {
		final String name = (String)keys.nextElement();
		final Integer idx = (Integer)_names.get(name);
		_namesArray[idx.intValue() - NTYPES] = name;
	    }

	    _names = null;
	    _types = setupMapping(_namesArray);

	    
	    resizeTextArray(_currentOffset);
	    
	    _firstAttributeNode = _currentNode;
	    shiftAttributes(_currentNode);
	    resizeArrays(_currentNode + _currentAttributeNode, _currentNode);
	    appendAttributes();
	    _treeNodeLimit = _currentNode + _currentAttributeNode;

	    
	    _namespace = new short[namesSize];
	    _uriArray = new String[_uriCount];
	    for (int i = 0; i<namesSize; i++) {
		final String qname = _namesArray[i];
		final int col = _namesArray[i].lastIndexOf(':');
		
		if ((!qname.startsWith(XML_STRING)) && (col > -1)) {
		    final String uri = _namesArray[i].substring(0, col);
		    final Integer idx = (Integer)_nsIndex.get(uri);
		    if (idx != null) {
			_namespace[i] = idx.shortValue();
			_uriArray[idx.intValue()] = uri;
		    }
		}
	    }

	    _prefixArray = new String[_prefixCount];
	    Enumeration p = _nsPrefixes.keys();
	    while (p.hasMoreElements()) {
		final String prefix = (String)p.nextElement();
		final Stack stack = (Stack)_nsPrefixes.get(prefix);
		final Integer I = (Integer)stack.elementAt(0);
		_prefixArray[I.shortValue()] = prefix;
	    }
	}
	
	
	public void startElement(String uri, String localName,
				 String qname, Attributes attributes)
	    throws SAXException 
	{

	    makeTextNode(false);

	    
	    final int node = nextNode();
	    linkChildren(node);
	    linkParent(node);

	    _lengthOrAttr[node] = DOM.NULL;

	    int last = -1;
	    final int count = attributes.getLength();

	    
	    if (_nextNamespace != DOM.NULL) {
		_lengthOrAttr[node] = _nextNamespace;

		while (_nextNamespace != DOM.NULL) {
		    _parent2[_nextNamespace] = node;
		    _nextNamespace = _nextSibling2[last = _nextNamespace];
		    
		    if (_nextNamespace == DOM.NULL && count > 0) {
			_nextSibling2[last] = _currentAttributeNode;
		    }
		}
	    }

	    
	    if (localName == null) {
		localName = EMPTYSTRING;
	    }

	    
	    boolean attrsAdded = false;
	    if (count > 0) {
		int attr = _currentAttributeNode;
		if (_lengthOrAttr[node] == DOM.NULL) {
		    _lengthOrAttr[node] = attr;
		}
		for (int i = 0; i < count; i++) {
		    if (!attributes.getQName(i).startsWith(XMLNS_PREFIX)) {
			attr = makeAttributeNode(node, attributes, i);
			_parent2[attr] = node;
			_nextSibling2[attr] = attr + 1;
			attrsAdded = true;
		    }
		}
		
		_nextSibling2[(!attrsAdded && last != -1) ? last : attr] = DOM.NULL;
	    }

	    final int col = qname.lastIndexOf(':');

	    
	    _type[node] = (uri != null && localName.length() > 0) ?
		makeElementNode(uri, localName) : makeElementNode(qname, col);

	    
	    if (col > -1) {
		_prefix[node] = registerPrefix(qname.substring(0, col));
	    }
	}
	
	
	public void endElement(String uri, String localName,
			       String qname) {
	    makeTextNode(false);

	    
	    xmlSpaceRevert(_parentStack[_sp]);
	    _previousSiblingStack[_sp--] = 0;
	}

	
	public void processingInstruction(String target, String data)
	    throws SAXException {

	    makeTextNode(false);

	    final int node = nextNode();
	    _type[node] = PROCESSING_INSTRUCTION;
	    linkChildren(node);
	    characters(target);
	    characters("" "");
	    characters(data);
	    storeTextRef(node);
	}

	
	public void ignorableWhitespace(char[] ch, int start, int length) {
	    if (_currentOffset + length > _text.length) {
		resizeTextArray(
		    Math.max(_text.length * 2, _currentOffset + length));
	    }
	    System.arraycopy(ch, start, _text, _currentOffset, length);
	    _currentOffset += length;
	    makeTextNode(true);
	}

	
	public void setDocumentLocator(Locator locator) {
	    
	}

	
	public void skippedEntity(String name) {
	    
	}

	
	public void startPrefixMapping(String prefix, String uri) 
	    throws SAXException 
	{
	    final Stack stack = definePrefixAndUri(prefix, uri);

	    makeTextNode(false);
	    int attr = makeNamespaceNode(prefix, uri);
	    if (_nextNamespace == DOM.NULL) {
		_nextNamespace = attr;
	    }
	    else {
		_nextSibling2[attr-1] = attr;
	    }
	    _nextSibling2[attr] = DOM.NULL;
	    _prefix2[attr] = ((Integer) stack.elementAt(0)).shortValue();
	}

	private Stack definePrefixAndUri(String prefix, String uri) 
	    throws SAXException 
	{
	    
	    Stack stack = (Stack)_nsPrefixes.get(prefix);
	    if (stack == null) {
		stack = new Stack();
		stack.push(new Integer(_prefixCount++));
		_nsPrefixes.put(prefix, stack);
	    }

	    
	    Integer idx;
	    if ((idx = (Integer)_nsIndex.get(uri)) == null) {
		_nsIndex.put(uri, idx = new Integer(_uriCount++));
	    }
	    stack.push(uri);

	    return stack;
	}

	
	public void endPrefixMapping(String prefix) {
	    
	    final Stack stack = (Stack)_nsPrefixes.get(prefix);
	    if ((stack != null) && (!stack.empty())) stack.pop();
	}

	
	public void comment(char[] ch, int start, int length) {
	    makeTextNode(false);
	    if (_currentOffset + length > _text.length) {
		resizeTextArray(
		    Math.max(_text.length * 2, _currentOffset + length));
	    }
	    System.arraycopy(ch, start, _text, _currentOffset, length);
	    _currentOffset += length;
	    final int node = makeTextNode(false);
	    _type[node] = COMMENT;
	}

	
	public void startCDATA() {}
	public void endCDATA() {}
	public void startDTD(String name, String publicId, String systemId) {}
	public void endDTD() {}
	public void startEntity(String name) {}
	public void endEntity(String name) {}

	
	private void characters(final String string) {
	    final int length = string.length();
	    if (_currentOffset + length > _text.length) {
		resizeTextArray(
		    Math.max(_text.length * 2, _currentOffset + length));
	    }
	    string.getChars(0, length, _text, _currentOffset);
	    _currentOffset += length;
	}

	private void resizeArrays(final int newSize, int length) {
	    if ((length < newSize) && (newSize == _currentNode))
		length = _currentNode;

	    
	    final short[] newType = new short[newSize];
	    System.arraycopy(_type, 0, newType, 0, length);
	    _type = newType;

	    
	    final int[] newParent = new int[newSize];
	    System.arraycopy(_parent, 0, newParent, 0, length);
	    _parent = newParent;

	    
	    final int[] newNextSibling = new int[newSize];
	    System.arraycopy(_nextSibling, 0, newNextSibling, 0, length);
	    _nextSibling = newNextSibling;

	    
	    final int[] newOffsetOrChild = new int[newSize];
	    System.arraycopy(_offsetOrChild, 0, newOffsetOrChild, 0,length);
	    _offsetOrChild = newOffsetOrChild;

	    
	    final int[] newLengthOrAttr = new int[newSize];
	    System.arraycopy(_lengthOrAttr, 0, newLengthOrAttr, 0, length);
	    _lengthOrAttr = newLengthOrAttr;

	    
	    _whitespace.resize(newSize);

	    
	    if (_dontEscape != null) {
		_dontEscape.resize(newSize);
	    }

	    
	    final short[] newPrefix = new short[newSize];
	    System.arraycopy(_prefix, 0, newPrefix, 0, length);
	    _prefix = newPrefix;
	}
	
	private void resizeArrays2(final int newSize, final int length) {
	    if (newSize > length) {
		
		final short[] newType = new short[newSize];
		System.arraycopy(_type2, 0, newType, 0, length);
		_type2 = newType;

		
		final int[] newParent = new int[newSize];
		System.arraycopy(_parent2, 0, newParent, 0, length);
		_parent2 = newParent;

		
		final int[] newNextSibling = new int[newSize];
		System.arraycopy(_nextSibling2, 0, newNextSibling, 0, length);
		_nextSibling2 = newNextSibling;

		
		final int[] newOffset = new int[newSize];
		System.arraycopy(_offset, 0, newOffset, 0, length);
		_offset = newOffset;

		
		final int[] newLength = new int[newSize];
		System.arraycopy(_length, 0, newLength, 0, length);
		_length = newLength;

		
		final short[] newPrefix = new short[newSize];
		System.arraycopy(_prefix2, 0, newPrefix, 0, length);
		_prefix2 = newPrefix;
	    }
	}
	
	private void shiftAttributes(final int shift) {
	    int i = 0;
	    int next = 0;
	    final int limit = _currentAttributeNode;
	    int lastParent = -1;

	    for (i = 0; i < limit; i++) {
		if (_parent2[i] != lastParent) {
		    lastParent = _parent2[i];
		    _lengthOrAttr[lastParent] = i + shift;
		}
		next = _nextSibling2[i];
		_nextSibling2[i] = next != 0 ? next + shift : 0;
	    }
	}
	
	private void appendAttributes() {
	    final int len = _currentAttributeNode;
	    if (len > 0) {
		final int dst = _currentNode;
		System.arraycopy(_type2,         0, _type,          dst, len);
		System.arraycopy(_prefix2,       0, _prefix,        dst, len);
		System.arraycopy(_parent2,       0, _parent,        dst, len);
		System.arraycopy(_nextSibling2,  0, _nextSibling,   dst, len);
		System.arraycopy(_offset,        0, _offsetOrChild, dst, len);
		System.arraycopy(_length,        0, _lengthOrAttr,  dst, len);
	    }
	}

 	public boolean setEscaping(boolean value) {
	    final boolean temp = _escaping;
	    _escaping = value; 
	    return temp;
    	}

    } 
}
"
org.apache.xalan.xsltc.compiler.ArgumentList,2,1,0,1,7,0,0,1,2,0.0,35,1.0,2,0.0,0.666666667,0,0,15.5,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

final class ArgumentList {
    private final Expression   _arg;
    private final ArgumentList _rest;
	
    public ArgumentList(Expression arg, ArgumentList rest) {
	_arg = arg;
	_rest = rest;
    }
		
    public String toString() {
	return _rest == null
	    ? _arg.toString()
	    : _arg.toString() + "", "" + _rest.toString();
    }
}
"
org.apache.xalan.templates.FuncKey,3,5,0,17,33,1,1,16,2,0.5,177,1.0,0,0.98245614,0.75,1,7,57.66666667,1,0.3333,0,"
package org.apache.xalan.templates;

import java.util.Vector;
import java.util.Hashtable;

import org.apache.xpath.functions.Function;
import org.apache.xpath.functions.Function2Args;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.axes.UnionPathIterator;
import org.apache.xml.utils.QName;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.KeyManager;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xpath.XPathContext;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import org.apache.xml.utils.XMLString;


public class FuncKey extends Function2Args
{

  
  static private Boolean ISTRUE = new Boolean(true);

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    
    TransformerImpl transformer = (TransformerImpl) xctxt.getOwnerObject();
    XNodeSet nodes = null;
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    int docContext = dtm.getDocumentRoot(context);

    if (DTM.NULL == docContext)
    {

      
    }

    String xkeyname = getArg0().execute(xctxt).str();
    QName keyname = new QName(xkeyname, xctxt.getNamespaceContext());
    XObject arg = getArg1().execute(xctxt);
    boolean argIsNodeSetDTM = (XObject.CLASS_NODESET == arg.getType());
    KeyManager kmgr = transformer.getKeyManager();
    
    
    if(argIsNodeSetDTM)
    {
    	XNodeSet ns = (XNodeSet)arg;
    	ns.setShouldCacheNodes(true);
    	int len = ns.getLength();
    	if(len <= 1)
    		argIsNodeSetDTM = false;
    }

    if (argIsNodeSetDTM)
    {
      Hashtable usedrefs = null;
      DTMIterator ni = arg.iter();
      int pos;
      UnionPathIterator upi = new UnionPathIterator();
      upi.exprSetParent(this);

      while (DTM.NULL != (pos = ni.nextNode()))
      {
        dtm = xctxt.getDTM(pos);
        XMLString ref = dtm.getStringValue(pos);

        if (null == ref)
          continue;

        if (null == usedrefs)
          usedrefs = new Hashtable();

        if (usedrefs.get(ref) != null)
        {
          continue;  
        }
        else
        {

          
          usedrefs.put(ref, ISTRUE);
        }

        XNodeSet nl =
          kmgr.getNodeSetDTMByKey(xctxt, docContext, keyname, ref,
                               xctxt.getNamespaceContext());
                               
        nl.setRoot(xctxt.getCurrentNode(), xctxt);



          upi.addIterator(nl);





        
      }

      int current = xctxt.getCurrentNode();
      upi.setRoot(current, xctxt);

      nodes = new XNodeSet(upi);
    }
    else
    {
      XMLString ref = arg.xstr();
      nodes = kmgr.getNodeSetDTMByKey(xctxt, docContext, keyname,
                                                ref,
                                                xctxt.getNamespaceContext());
      nodes.setRoot(xctxt.getCurrentNode(), xctxt);
    }

    return nodes;
  }
}
"
org.apache.xalan.lib.sql.XConnection,34,1,0,12,124,211,0,12,28,0.656565657,1600,1.0,3,0.0,0.196078431,0,0,45.79411765,7,1.6176,0,"
package org.apache.xalan.lib.sql;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.Date;
import java.sql.Timestamp;
import java.sql.Time;
import java.util.Properties;
import java.util.Vector;
import java.util.StringTokenizer;
import java.lang.IllegalArgumentException;
import org.w3c.dom.Element;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.NodeList;
import org.w3c.dom.Node;
import java.util.Vector;
import java.util.Enumeration;
import java.math.BigDecimal;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.ref.DTMManagerDefault;
import org.apache.xpath.XPathContext;
import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xpath.objects.XBooleanStatic;

import org.w3c.dom.*;
import java.sql.*;
import java.util.*;


public class XConnection
{

  
  private static final boolean DEBUG = false;

  
  private ConnectionPool m_ConnectionPool = null;

  
  private boolean m_DefaultPoolingEnabled = false;


  
  private Vector m_OpenSQLDocuments = new Vector();


  
  private ConnectionPoolManager m_PoolMgr = new ConnectionPoolManager();

  
  private Vector m_ParameterList = new Vector();

  
  private SQLErrorDocument m_Error = null;

  
  private boolean m_IsDefaultPool = false;

  
  private boolean m_IsStreamingEnabled = true;

  
  public XConnection( )
  {
  }

  
  
  
  
  
  public XConnection( ExpressionContext exprContext, String ConnPoolName )
  {
    connect(exprContext, ConnPoolName);
  }

  
  public XConnection( ExpressionContext exprContext, String driver, String dbURL )
  {
    connect(exprContext, driver, dbURL);
  }

  
  public XConnection( ExpressionContext exprContext, NodeList list )
  {
    connect(exprContext, list);
  }

  
  public XConnection( ExpressionContext exprContext, String driver, String dbURL, String user, String password )
  {
    connect(exprContext, driver, dbURL, user, password);
  }

  
  public XConnection( ExpressionContext exprContext, String driver, String dbURL, Element protocolElem )
  {
    connect(exprContext, driver, dbURL, protocolElem);
  }


  
  public XBooleanStatic connect( ExpressionContext exprContext, String ConnPoolName )
  {
    try
    {
      m_ConnectionPool = m_PoolMgr.getPool(ConnPoolName);

      if (m_ConnectionPool == null)
        throw new java.lang.IllegalArgumentException(""Invalid Pool Name"");

      m_IsDefaultPool = false;
      return new XBooleanStatic(true);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }

  }

  
  public XBooleanStatic connect( ExpressionContext exprContext, String driver, String dbURL )
  {
    try
    {
      init(driver, dbURL, new Properties());
      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }

  
  public XBooleanStatic connect( ExpressionContext exprContext, Element protocolElem )
  {
    try
    {
      initFromElement(protocolElem);
      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }

  
  public XBooleanStatic connect( ExpressionContext exprContext, NodeList list )
  {
    try
    {
      initFromElement( (Element) list.item(0) );
      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }

  
  public XBooleanStatic connect( ExpressionContext exprContext, String driver, String dbURL, String user, String password )
  {
    try
    {
      Properties prop = new Properties();
      prop.put(""user"", user);
      prop.put(""password"", password);

      init(driver, dbURL, prop);

      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }


  
  public XBooleanStatic connect( ExpressionContext exprContext, String driver, String dbURL, Element protocolElem )
  {
    try
    {
      Properties prop = new Properties();

      NamedNodeMap atts = protocolElem.getAttributes();

      for (int i = 0; i < atts.getLength(); i++)
      {
        prop.put(atts.item(i).getNodeName(), atts.item(i).getNodeValue());
      }

      init(driver, dbURL, prop);

      return new XBooleanStatic(true);
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return new XBooleanStatic(false);
    }
  }


  
  private void initFromElement( Element e )throws SQLException
  {

    Properties prop = new Properties();
    String driver = """";
    String dbURL = """";
    Node n = e.getFirstChild();

    if (null == n) return; 

    do
    {
      String nName = n.getNodeName();

      if (nName.equalsIgnoreCase(""dbdriver""))
      {
        driver = """";
        Node n1 = n.getFirstChild();
        if (null != n1)
        {
          driver = n1.getNodeValue();
        }
      }

      if (nName.equalsIgnoreCase(""dburl""))
      {
        dbURL = """";
        Node n1 = n.getFirstChild();
        if (null != n1)
        {
          dbURL = n1.getNodeValue();
        }
      }

      if (nName.equalsIgnoreCase(""password""))
      {
        String s = """";
        Node n1 = n.getFirstChild();
        if (null != n1)
        {
          s = n1.getNodeValue();
        }
        prop.put(""password"", s);
      }

      if (nName.equalsIgnoreCase(""user""))
      {
        String s = """";
        Node n1 = n.getFirstChild();
        if (null != n1)
        {
          s = n1.getNodeValue();
        }
        prop.put(""user"", s);
      }

      if (nName.equalsIgnoreCase(""protocol""))
      {
        String Name = """";

        NamedNodeMap attrs = n.getAttributes();
        Node n1 = attrs.getNamedItem(""name"");
        if (null != n1)
        {
          String s = """";
          Name = n1.getNodeValue();

          Node n2 = n.getFirstChild();
          if (null != n2) s = n2.getNodeValue();

          prop.put(Name, s);
        }
      }

    } while ( (n = n.getNextSibling()) != null);

    init(driver, dbURL, prop);
  }



  
  private void init( String driver, String dbURL, Properties prop )throws SQLException
  {
    Connection con = null;

    if (DEBUG)
      System.out.println(""XConnection, Connection Init"");

    String user = prop.getProperty(""user"");
    if (user == null) user = """";

    String passwd = prop.getProperty(""password"");
    if (passwd == null) passwd = """";


    String poolName = driver + dbURL + user + passwd;
    ConnectionPool cpool = m_PoolMgr.getPool(poolName);

    if (cpool == null)
    {

      if (DEBUG)
      {
        System.out.println(""XConnection, Creating Connection"");
        System.out.println("" Driver  :"" + driver);
        System.out.println("" URL     :"" + dbURL);
        System.out.println("" user    :"" + user);
        System.out.println("" passwd  :"" + passwd);
      }


      DefaultConnectionPool defpool = new DefaultConnectionPool();

      if ((DEBUG) && (defpool == null))
        System.out.println(""Failed to Create a Default Connection Pool"");

      defpool.setDriver(driver);
      defpool.setURL(dbURL);
      defpool.setProtocol(prop);

      
      
      if (m_DefaultPoolingEnabled) defpool.setPoolEnabled(true);

      m_PoolMgr.registerPool(poolName, defpool);
      m_ConnectionPool = defpool;
    }
    else
    {
      m_ConnectionPool = cpool;
    }

    m_IsDefaultPool = true;

    
    
    
    
    try
    {
      con = m_ConnectionPool.getConnection();
    }
    catch(SQLException e)
    {
      if (con != null)
      {
        m_ConnectionPool.releaseConnectionOnError(con);
        con = null;
      }
      throw e;
    }
    finally
    {
      m_ConnectionPool.releaseConnection(con);
    }
  }


  
  public DTM query( ExpressionContext exprContext, String queryString )
  {
    Connection con = null;
    Statement stmt = null;
    ResultSet rs = null;

    DTMManagerDefault mgrDefault = null;
    SQLDocument doc = null;

    try
    {
      if (DEBUG) System.out.println(""query()"");
      if (null == m_ConnectionPool)
      {
        
        return null;
      }

      try
      {
        con = m_ConnectionPool.getConnection();
        stmt = con.createStatement();
        rs = stmt.executeQuery(queryString);
      }
      catch(SQLException e)
      {
        
        
        
        
        try  { if (null != rs) rs.close(); }
        catch(Exception e1) {}
        try  { if (null != stmt) stmt.close(); }
        catch(Exception e1) { }
        try  {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        } catch(Exception e1) { }

        buildErrorDocument(exprContext, e);
        return null;
      }

      if (DEBUG) System.out.println(""..creatingSQLDocument"");

      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      doc =
        new SQLDocument(
          mgr, dtmIdent << DTMManager.IDENT_DTM_NODE_BITS ,
          m_ConnectionPool, con, stmt, rs, m_IsStreamingEnabled);

      if (null != doc)
      {
        if (DEBUG) System.out.println(""..returning Document"");

        
        mgrDefault.addDTM(doc, dtmIdent);

        
        m_OpenSQLDocuments.addElement(doc);
        return doc;
      }
      else
      {
        return null;
      }
    }
    catch(SQLException e)
    {
      if ((doc != null) && (mgrDefault != null))
      {
        doc.closeOnError();
        mgrDefault.release(doc, true);
      }
      buildErrorDocument(exprContext, e);
      return null;
    }
    catch (Exception e)
    {
      if ((doc != null) && (mgrDefault != null))
      {
        doc.closeOnError();
        mgrDefault.release(doc, true);
      }

      if (DEBUG) System.out.println(""exception in query()"");
      buildErrorDocument(exprContext, e);
      return null;
    }
    finally
    {
      if (DEBUG) System.out.println(""leaving query()"");
    }
  }

  
  public DTM pquery( ExpressionContext exprContext, String queryString )
  {
    Connection con = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;

    try
    {
      int indx;

      try
      {
        con = m_ConnectionPool.getConnection();
        stmt = con.prepareStatement(queryString);
      }
      catch(SQLException e)
      {
        
        
        
        
        try { if (null != stmt) stmt.close(); }
        catch(Exception e1) { }
        try {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        }  catch(Exception e1) {}

        
        
        throw e;
      }

      if (DEBUG) System.out.println(""..building Prepared Statement"");

      try
      {
        Enumeration enum = m_ParameterList.elements();
        indx = 1;
        while (enum.hasMoreElements())
        {
          QueryParameter qp = (QueryParameter) enum.nextElement();
          setParameter(indx, stmt, qp);
          indx++;
        }

        rs = stmt.executeQuery();
      }
      catch(SQLException e)
      {
        
        
        
        
        try { if (null != rs) rs.close();  }
        catch(Exception e1) {  }
        try { if (null != stmt) stmt.close(); }
        catch(Exception e1) {  }
        try  {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        } catch(Exception e1) { }

        
        
        throw e;
      }

      if (DEBUG) System.out.println(""..creatingSQLDocument"");

      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      DTMManagerDefault mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      SQLDocument doc =
        new SQLDocument(mgr, dtmIdent << DTMManager.IDENT_DTM_NODE_BITS,
        m_ConnectionPool, con, stmt, rs, m_IsStreamingEnabled);

      if (null != doc)
      {
        if (DEBUG) System.out.println(""..returning Document"");

        
        mgrDefault.addDTM(doc, dtmIdent);

        
        m_OpenSQLDocuments.addElement(doc);
        return doc;
      }
      else
      {
        
        return null;
      }
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return null;
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return null;
    }
  }


  
  public DTM pquery( ExpressionContext exprContext, String queryString, String typeInfo )
  {
    Connection con = null;
    PreparedStatement stmt = null;
    ResultSet rs = null;

    try
    {
      int indx;

      
      
      StringTokenizer plist = new StringTokenizer(typeInfo);

      
      
      
      
      indx = 0;
      while (plist.hasMoreTokens())
      {
        String value = plist.nextToken();
        QueryParameter qp = (QueryParameter) m_ParameterList.elementAt(indx);
        if ( null != qp )
        {
          qp.setType(value);
        }

        indx++;
      }

      try
      {
        con = m_ConnectionPool.getConnection();
        stmt = con.prepareStatement(queryString);
      }
      catch(SQLException e)
      {
        
        
        
        
        try { if (null != stmt) stmt.close(); }
        catch(Exception e1) { }
        try {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        } catch(Exception e1) { }

        
        
        throw e;
      }



      if (DEBUG) System.out.println(""..building Prepared Statement"");

      try
      {
        Enumeration enum = m_ParameterList.elements();
        indx = 1;
        while (enum.hasMoreElements())
        {
          QueryParameter qp = (QueryParameter) enum.nextElement();
          setParameter(indx, stmt, qp);
          indx++;
        }

        rs = stmt.executeQuery();
      }
      catch(SQLException e)
      {
        
        
        
        
        try { if (null != rs) rs.close(); }
        catch(Exception e1) {  }
        try { if (null != stmt) stmt.close(); }
        catch(Exception e1) {   }
        try {
          if (null != con) m_ConnectionPool.releaseConnectionOnError(con);
        } catch(Exception e1) {  }

        
        
        throw e;
      }


      if (DEBUG) System.out.println(""..creatingSQLDocument"");

      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      DTMManagerDefault mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      SQLDocument doc =
        new SQLDocument(mgr, dtmIdent << DTMManager.IDENT_DTM_NODE_BITS ,
        m_ConnectionPool, con, stmt, rs, m_IsStreamingEnabled);

      if (null != doc)
      {
        if (DEBUG) System.out.println(""..returning Document"");

        
        mgrDefault.addDTM(doc, dtmIdent);

        
        m_OpenSQLDocuments.addElement(doc);
        return doc;
      }
      else
      {
        
        return null;
      }
    }
    catch(SQLException e)
    {
      buildErrorDocument(exprContext, e);
      return null;
    }
    catch (Exception e)
    {
      buildErrorDocument(exprContext, e);
      return null;
    }
  }

  
  public void addParameter( String value )
  {
    addParameterWithType(value, null);
  }

  
  public void addParameterWithType( String value, String Type )
  {
    m_ParameterList.addElement( new QueryParameter(value, Type) );
  }


  
  public void addParameterFromElement( Element e )
  {
    NamedNodeMap attrs = e.getAttributes();
    Node Type = attrs.getNamedItem(""type"");
    Node n1  = e.getFirstChild();
    if (null != n1)
    {
      String value = n1.getNodeValue();
      if (value == null) value = """";
      m_ParameterList.addElement( new QueryParameter(value, Type.getNodeValue()) );
    }
  }


  
  public void addParameterFromElement( NodeList nl )
  {
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    int count = nl.getLength();
    for (int x=0; x<count; x++)
    {
      addParameters( (Element) nl.item(x));
    }
  }

  
  private void addParameters( Element elem )
  {
    
    
    
    
    
    
    
    
    
    

    Node n = elem.getFirstChild();

    if (null == n) return;

    do
    {
      if (n.getNodeType() == Node.ELEMENT_NODE)
      {
        NamedNodeMap attrs = n.getAttributes();
        Node Type = attrs.getNamedItem(""type"");
        String TypeStr;

        if (Type == null) TypeStr = ""string"";
        else TypeStr = Type.getNodeValue();

        Node n1  = n.getFirstChild();
        if (null != n1)
        {
          String value = n1.getNodeValue();
          if (value == null) value = """";


          m_ParameterList.addElement(
            new QueryParameter(value, TypeStr) );
        }
      }
    } while ( (n = n.getNextSibling()) != null);
  }

  
  public void clearParameters( )
  {
    m_ParameterList.removeAllElements();
  }

  
  public void enableDefaultConnectionPool( )
  {

    if (DEBUG)
      System.out.println(""Enabling Default Connection Pool"");

    m_DefaultPoolingEnabled = true;

    if (m_ConnectionPool == null) return;
    if (m_IsDefaultPool) return;

    m_ConnectionPool.setPoolEnabled(true);

  }

  
  public void disableDefaultConnectionPool( )
  {
    if (DEBUG)
      System.out.println(""Disabling Default Connection Pool"");

    m_DefaultPoolingEnabled = false;

    if (m_ConnectionPool == null) return;
    if (!m_IsDefaultPool) return;

    m_ConnectionPool.setPoolEnabled(false);
  }


  
  public void enableStreamingMode( )
  {

    if (DEBUG)
      System.out.println(""Enabling Streaming Mode"");

    m_IsStreamingEnabled = true;
  }

  
  public void disableStreamingMode( )
  {

    if (DEBUG)
      System.out.println(""Disable Streaming Mode"");

    m_IsStreamingEnabled = false;
  }

  
  public DTM getError( )
  {
    return m_Error;
  }

  
  public void close( )throws SQLException
  {

    if (DEBUG)
      System.out.println(""Entering XConnection.close"");

    
    
    
    
    while(m_OpenSQLDocuments.size() != 0)
    {
      SQLDocument d = (SQLDocument) m_OpenSQLDocuments.elementAt(0);
      d.close();
      m_OpenSQLDocuments.removeElementAt(0);
    }

    if (DEBUG)
      System.out.println(""Exiting XConnection.close"");

  }

  
  public void close( SQLDocument sqldoc )throws SQLException
  {
    if (DEBUG)
      System.out.println(""Entering XConnection.close"");

    int size = m_OpenSQLDocuments.size();

    for(int x=0; x<size; x++)
    {
      SQLDocument d = (SQLDocument) m_OpenSQLDocuments.elementAt(x);
      if (d == sqldoc)
      {
        d.close();
        m_OpenSQLDocuments.removeElementAt(x);
      }
    }
  }

  
  public void setParameter( int pos, PreparedStatement stmt, QueryParameter p )throws SQLException
  {
    String type = p.getType();
    if (type.equalsIgnoreCase(""string""))
    {
      stmt.setString(pos, p.getValue());
    }

    if (type.equalsIgnoreCase(""bigdecimal""))
    {
      stmt.setBigDecimal(pos, new BigDecimal(p.getValue()));
    }

    if (type.equalsIgnoreCase(""boolean""))
    {
      Integer i = new Integer( p.getValue() );
      boolean b = ((i.intValue() != 0) ? false : true);
      stmt.setBoolean(pos, b);
    }

    if (type.equalsIgnoreCase(""bytes""))
    {
      stmt.setBytes(pos, p.getValue().getBytes());
    }

    if (type.equalsIgnoreCase(""date""))
    {
      stmt.setDate(pos, Date.valueOf(p.getValue()));
    }

    if (type.equalsIgnoreCase(""double""))
    {
      Double d = new Double(p.getValue());
      stmt.setDouble(pos, d.doubleValue() );
    }

    if (type.equalsIgnoreCase(""float""))
    {
      Float f = new Float(p.getValue());
      stmt.setFloat(pos, f.floatValue());
    }

    if (type.equalsIgnoreCase(""long""))
    {
      Long l = new Long(p.getValue());
      stmt.setLong(pos, l.longValue());
    }

    if (type.equalsIgnoreCase(""short""))
    {
      Short s = new Short(p.getValue());
      stmt.setShort(pos, s.shortValue());
    }

    if (type.equalsIgnoreCase(""time""))
    {
      stmt.setTime(pos, Time.valueOf(p.getValue()) );
    }

    if (type.equalsIgnoreCase(""timestamp""))
    {

      stmt.setTimestamp(pos, Timestamp.valueOf(p.getValue()) );
    }

  }

  
  private void buildErrorDocument( ExpressionContext exprContext, SQLException excp )
  {
    try
    {
      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      DTMManagerDefault mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      m_Error = new SQLErrorDocument(mgr, dtmIdent << DTMManager.IDENT_DTM_NODE_BITS, excp);

      
      mgrDefault.addDTM(m_Error, dtmIdent);

    }
    catch(Exception e)
    {
      m_Error = null;
    }
  }

  
  private void buildErrorDocument( ExpressionContext exprContext, Exception excp )
  {
    try
    {
      DTMManager mgr =
        ((XPathContext.XPathExpressionContext)exprContext).getDTMManager();
      DTMManagerDefault mgrDefault = (DTMManagerDefault) mgr;
      int dtmIdent = mgrDefault.getFirstFreeDTMID();

      m_Error = new SQLErrorDocument(mgr, dtmIdent<<DTMManager.IDENT_DTM_NODE_BITS, excp);

      
      mgrDefault.addDTM(m_Error, dtmIdent);

    }
    catch(Exception e)
    {
      m_Error = null;
    }
  }

  
  protected void finalize( )
  {
    if (DEBUG) System.out.println(""In XConnection, finalize"");
    try
    {
      close();
    }
    catch(Exception e)
    {
      
    }
  }

}
"
org.apache.xalan.xsltc.compiler.Instruction,3,2,26,37,9,3,29,8,2,2.0,24,0.0,0,0.964285714,0.5,1,2,7.0,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.*;

abstract class Instruction extends SyntaxTreeNode {
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return typeCheckContents(stable);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ErrorMsg msg = new ErrorMsg(ErrorMsg.NOT_IMPLEMENTED_ERR,
				    getClass(), this);
	getParser().reportError(FATAL, msg);
    }
}
"
org.apache.xalan.transformer.NodeSorter,4,1,0,9,28,2,2,8,2,0.333333333,475,0.0,1,0.0,0.583333333,0,0,117.25,1,0.75,0,"
package org.apache.xalan.transformer;

import java.util.Vector;

import java.text.NumberFormat;
import java.text.CollationKey;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import org.apache.xpath.axes.ContextNodeList;
import org.apache.xpath.XPathContext;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xml.utils.NodeVector;

import javax.xml.transform.TransformerException;


public class NodeSorter
{

  
  XPathContext m_execContext;

  
  Vector m_keys;  






  
  public NodeSorter(XPathContext p)
  {
    m_execContext = p;
  }

  
  public void sort(DTMIterator v, Vector keys, XPathContext support)
          throws javax.xml.transform.TransformerException
  {

    m_keys = keys;

    
    int n = v.getLength();

    
    
    
    
    
    
    Vector nodes = new Vector();

    for (int i = 0; i < n; i++)
    {
      NodeCompareElem elem = new NodeCompareElem(v.item(i));

      nodes.addElement(elem);
    }

    Vector scratchVector = new Vector();

    mergesort(nodes, scratchVector, 0, n - 1, support);

    
    for (int i = 0; i < n; i++)
    {
      v.setItem(((NodeCompareElem) nodes.elementAt(i)).m_node, i);
    }
    v.setCurrentPos(0);

    
    
    
  }

  
  int compare(
          NodeCompareElem n1, NodeCompareElem n2, int kIndex, XPathContext support)
            throws TransformerException
  {

    int result = 0;
    NodeSortKey k = (NodeSortKey) m_keys.elementAt(kIndex);

    if (k.m_treatAsNumbers)
    {
      double n1Num, n2Num;

      if (kIndex == 0)
      {
        n1Num = ((Double) n1.m_key1Value).doubleValue();
        n2Num = ((Double) n2.m_key1Value).doubleValue();
      }
      else if (kIndex == 1)
      {
        n1Num = ((Double) n1.m_key2Value).doubleValue();
        n2Num = ((Double) n2.m_key2Value).doubleValue();
      }

      
      else
      {

        
        XObject r1 = k.m_selectPat.execute(m_execContext, n1.m_node,
                                           k.m_namespaceContext);
        XObject r2 = k.m_selectPat.execute(m_execContext, n2.m_node,
                                           k.m_namespaceContext);
        n1Num = r1.num();

        
        
        
        n2Num = r2.num();
        
      }

      if ((n1Num == n2Num) && ((kIndex + 1) < m_keys.size()))
      {
        result = compare(n1, n2, kIndex + 1, support);
      }
      else
      {
        double diff;
        if (Double.isNaN(n1Num))
        {
          if (Double.isNaN(n2Num))
            diff = 0.0;
          else
            diff = -1;
        }
        else if (Double.isNaN(n2Num))
           diff = 1;
        else
          diff = n1Num - n2Num;

        
        result = (int) ((diff < 0.0)
                        ? (k.m_descending ? 1 : -1)
                        : (diff > 0.0) ? (k.m_descending ? -1 : 1) : 0);
      }
    }  
    else
    {
      CollationKey n1String, n2String;

      if (kIndex == 0)
      {
        n1String = (CollationKey) n1.m_key1Value;
        n2String = (CollationKey) n2.m_key1Value;
      }
      else if (kIndex == 1)
      {
        n1String = (CollationKey) n1.m_key2Value;
        n2String = (CollationKey) n2.m_key2Value;
      }

      
      else
      {

        
        XObject r1 = k.m_selectPat.execute(m_execContext, n1.m_node,
                                           k.m_namespaceContext);
        XObject r2 = k.m_selectPat.execute(m_execContext, n2.m_node,
                                           k.m_namespaceContext);

        n1String = k.m_col.getCollationKey(r1.str());
        n2String = k.m_col.getCollationKey(r2.str());
      }

      
      
      result = n1String.compareTo(n2String);

      
      if (k.m_caseOrderUpper)
      {
        String tempN1 = n1String.getSourceString().toLowerCase();
        String tempN2 = n2String.getSourceString().toLowerCase();

        if (tempN1.equals(tempN2))
        {

          
          result = result == 0 ? 0 : -result;
        }
      }

      
      if (k.m_descending)
      {
        result = -result;
      }
    }  

    if (0 == result)
    {
      if ((kIndex + 1) < m_keys.size())
      {
        result = compare(n1, n2, kIndex + 1, support);
      }
    }

    if (0 == result)
    {

      
      
      
      
      DTM dtm = support.getDTM(n1.m_node); 
      result = dtm.isNodeAfter(n1.m_node, n2.m_node) ? -1 : 1;

      
    }

    return result;
  }

  
  void mergesort(Vector a, Vector b, int l, int r, XPathContext support)
          throws TransformerException
  {

    if ((r - l) > 0)
    {
      int m = (r + l) / 2;

      mergesort(a, b, l, m, support);
      mergesort(a, b, m + 1, r, support);

      int i, j, k;

      for (i = m; i >= l; i--)
      {

        
        
        if (i >= b.size())
          b.insertElementAt(a.elementAt(i), i);
        else
          b.setElementAt(a.elementAt(i), i);
      }

      i = l;

      for (j = (m + 1); j <= r; j++)
      {

        
        if (r + m + 1 - j >= b.size())
          b.insertElementAt(a.elementAt(j), r + m + 1 - j);
        else
          b.setElementAt(a.elementAt(j), r + m + 1 - j);
      }

      j = r;

      int compVal;

      for (k = l; k <= r; k++)
      {

        
        if (i == j)
          compVal = -1;
        else
          compVal = compare((NodeCompareElem) b.elementAt(i),
                            (NodeCompareElem) b.elementAt(j), 0, support);

        if (compVal < 0)
        {

          
          a.setElementAt(b.elementAt(i), k);

          i++;
        }
        else if (compVal > 0)
        {

          
          a.setElementAt(b.elementAt(j), k);

          j--;
        }
      }
    }
  }

  

  
  class NodeCompareElem
  {

    
    int m_node;

    
    int maxkey = 2;

    
    
    

    
    Object m_key1Value;

    
    Object m_key2Value;

    
    NodeCompareElem(int node) throws javax.xml.transform.TransformerException
    {

      boolean tryNextKey = true;

      m_node = node;

      if (!m_keys.isEmpty())
      {
        NodeSortKey k1 = (NodeSortKey) m_keys.elementAt(0);
        XObject r = k1.m_selectPat.execute(m_execContext, node,
                                           k1.m_namespaceContext);

        if (r == null)
          tryNextKey = false;

        double d;

        if (k1.m_treatAsNumbers)
        {
          d = r.num();

          
          m_key1Value = new Double(d);
        }
        else
        {
          m_key1Value = k1.m_col.getCollationKey(r.str());
        }

        if (r.getType() == XObject.CLASS_NODESET)
        {
          
          DTMIterator ni = ((XNodeSet)r).iterRaw();
          int current = ni.getCurrentNode();
          if(DTM.NULL == current)
            current = ni.nextNode();

          
          tryNextKey = (DTM.NULL != current);

          
        }

        if (m_keys.size() > 1)
        {
          NodeSortKey k2 = (NodeSortKey) m_keys.elementAt(1);

          if (!tryNextKey)
          {
            if (k2.m_treatAsNumbers)
              m_key2Value = new Double(0.0);
            else
              m_key2Value = k2.m_col.getCollationKey("""");
          }
          else
          {
            XObject r2 = k2.m_selectPat.execute(m_execContext, node,
                                                k2.m_namespaceContext);

            if (k2.m_treatAsNumbers)
            {
              d = r2.num();
              m_key2Value = new Double(d);
            }
            else
              m_key2Value = k2.m_col.getCollationKey(r2.str());
          }
        }

        
      }  
    }
  }  
}
"
org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl,21,3,0,3,43,0,0,3,19,0.5,498,1.0,0,0.5,0.220238095,1,2,22.47619048,3,1.0476,0,"


package org.apache.xalan.xsltc.trax;

import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;
import org.xml.sax.XMLFilter;
import org.xml.sax.InputSource;
import org.apache.xalan.xsltc.compiler.XSLTC;
import org.apache.xalan.xsltc.compiler.SourceLoader;


public class SmartTransformerFactoryImpl extends SAXTransformerFactory 
{

    private TransformerFactory _xsltcFactory = null;
    private TransformerFactory _xalanFactory = null;
    private TransformerFactory _currFactory = null;
    private ErrorListener      _errorlistener = null;
    private URIResolver        _uriresolver = null;

    
    public SmartTransformerFactoryImpl() { }

    private void createXSLTCTransformerFactory() {
	
 	final String xsltcMessage =
	    ""org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl ""+
            ""could not create an ""+
            ""org.apache.xalan.xsltc.trax.TransformerFactoryImpl."";
	
	
	try {
	    Class xsltcFactClass = Class.forName(
		""org.apache.xalan.xsltc.trax.TransformerFactoryImpl"");
	    _xsltcFactory = (org.apache.xalan.xsltc.trax.TransformerFactoryImpl)
		xsltcFactClass.newInstance();
	} 
	catch (ClassNotFoundException e) {
	    System.err.println(xsltcMessage);
	} 
 	catch (InstantiationException e) {
	    System.err.println(xsltcMessage);
	}
 	catch (IllegalAccessException e) {
	    System.err.println(xsltcMessage);
	}
	_currFactory = _xsltcFactory;
    }

    private void createXalanTransformerFactory() {
 	final String xalanMessage =
	    ""org.apache.xalan.xsltc.trax.SmartTransformerFactoryImpl ""+
	    ""could not create an ""+
	    ""org.apache.xalan.processor.TransformerFactoryImpl."";
	
	try {
	    Class xalanFactClass = Class.forName(
		""org.apache.xalan.processor.TransformerFactoryImpl"");
	    _xalanFactory = (org.apache.xalan.processor.TransformerFactoryImpl)
		xalanFactClass.newInstance();
	} 
	catch (ClassNotFoundException e) {
	    System.err.println(xalanMessage);
        }
 	catch (InstantiationException e) {
	    System.err.println(xalanMessage);
	}
 	catch (IllegalAccessException e) {
	    System.err.println(xalanMessage);
	}
	_currFactory = _xalanFactory;
    }

    public void setErrorListener(ErrorListener listener) 
	throws IllegalArgumentException 
    {
	_errorlistener = listener;
    }

    public ErrorListener getErrorListener() { 
	return _errorlistener;
    }

    public Object getAttribute(String name) 
	throws IllegalArgumentException 
    {
	
	if ((name.equals(""translet-name"")) || (name.equals(""debug""))) { 
	    if (_xsltcFactory == null) {
                createXSLTCTransformerFactory();
            }
            return _xsltcFactory.getAttribute(name); 
        }
        else {
	    if (_xalanFactory == null) {
	        createXalanTransformerFactory();
	    } 
	    return _xalanFactory.getAttribute(name);
        }
    }

    public void setAttribute(String name, Object value) 
	throws IllegalArgumentException { 
	
	if ((name.equals(""translet-name"")) || (name.equals(""debug""))) { 
	    if (_xsltcFactory == null) {
                createXSLTCTransformerFactory();
            }
            _xsltcFactory.setAttribute(name, value); 
        }
        else {
	    if (_xalanFactory == null) {
	        createXalanTransformerFactory();
	    } 
	    _xalanFactory.setAttribute(name, value);
        }
    }

    
    public boolean getFeature(String name) { 
	
        String[] features = {
            DOMSource.FEATURE,
            DOMResult.FEATURE,
            SAXSource.FEATURE,
            SAXResult.FEATURE,
            StreamSource.FEATURE,
            StreamResult.FEATURE
        };

        
        for (int i=0; i<features.length; i++) {
            if (name.equals(features[i])) return true;
	}

        
        return false;
    }

    public URIResolver getURIResolver() {
	return _uriresolver; 
    } 

    public void setURIResolver(URIResolver resolver) {
	_uriresolver = resolver;
    }

    public Source getAssociatedStylesheet(Source source, String media,
					  String title, String charset)
	throws TransformerConfigurationException 
    {
	if (_currFactory == null) {
            createXSLTCTransformerFactory();
        }
	return _currFactory.getAssociatedStylesheet(source, media,
		title, charset);
    }

    
    public Transformer newTransformer()
	throws TransformerConfigurationException 
    {
	if (_xalanFactory == null) {
            createXalanTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xalanFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xalanFactory.setURIResolver(_uriresolver);
	}
 	_currFactory = _xalanFactory;	 
	return _currFactory.newTransformer(); 
    }

    
    public Transformer newTransformer(Source source) throws
	TransformerConfigurationException 
    {
        if (_xalanFactory == null) {
            createXalanTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xalanFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xalanFactory.setURIResolver(_uriresolver);
	}
 	_currFactory = _xalanFactory;	 
	return _currFactory.newTransformer(source); 
    }

    
    public Templates newTemplates(Source source)
	throws TransformerConfigurationException 
    {
        if (_xsltcFactory == null) {
            createXSLTCTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xsltcFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xsltcFactory.setURIResolver(_uriresolver);
	}
 	_currFactory = _xsltcFactory;	 
	return _currFactory.newTemplates(source); 
    }

    
    public TemplatesHandler newTemplatesHandler() 
	throws TransformerConfigurationException 
    {
        if (_xsltcFactory == null) {
            createXSLTCTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xsltcFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xsltcFactory.setURIResolver(_uriresolver);
	}
	return ((SAXTransformerFactory)_xsltcFactory).newTemplatesHandler();
    }

    
    public TransformerHandler newTransformerHandler() 
	throws TransformerConfigurationException 
    {
        if (_xalanFactory == null) {
            createXalanTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xalanFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xalanFactory.setURIResolver(_uriresolver);
	}
	return ((SAXTransformerFactory)_xalanFactory).newTransformerHandler(); 
    }

    
    public TransformerHandler newTransformerHandler(Source src) 
	throws TransformerConfigurationException 
    {
        if (_xalanFactory == null) {
            createXalanTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xalanFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xalanFactory.setURIResolver(_uriresolver);
	}
	return 
            ((SAXTransformerFactory)_xalanFactory).newTransformerHandler(src); 
    }


    
    public TransformerHandler newTransformerHandler(Templates templates) 
	throws TransformerConfigurationException  
    {
        if (_xsltcFactory == null) {
            createXSLTCTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xsltcFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xsltcFactory.setURIResolver(_uriresolver);
	}
        return 
        ((SAXTransformerFactory)_xsltcFactory).newTransformerHandler(templates);
    }


    
    public XMLFilter newXMLFilter(Source src) 
	throws TransformerConfigurationException {
        if (_xsltcFactory == null) {
            createXSLTCTransformerFactory();
        }
	if (_errorlistener != null) {
	    _xsltcFactory.setErrorListener(_errorlistener);	    
	}
	if (_uriresolver != null) {
	    _xsltcFactory.setURIResolver(_uriresolver);
	}
	Templates templates = _xsltcFactory.newTemplates(src);
	if (templates == null ) return null;
	return newXMLFilter(templates); 
    }

    
    public XMLFilter newXMLFilter(Templates templates) 
	throws TransformerConfigurationException {
	try {
            return new org.apache.xalan.xsltc.trax.TrAXFilter(templates);
        }
        catch(TransformerConfigurationException e1) {
            if (_xsltcFactory == null) {
                createXSLTCTransformerFactory();
            }
	    ErrorListener errorListener = _xsltcFactory.getErrorListener();
            if(errorListener != null) {
                try {
                    errorListener.fatalError(e1);
                    return null;
                }
                catch( TransformerException e2) {
                    new TransformerConfigurationException(e2);
                }
            }
            throw e1;
        }
    }
}
"
org.apache.xalan.xsltc.compiler.BooleanExpr,7,3,0,20,16,1,1,19,7,0.333333333,70,1.0,0,0.922077922,0.371428571,2,8,8.857142857,2,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;


final class BooleanExpr extends Expression {
    private boolean _value;

    public BooleanExpr(boolean value) {
	_value = value;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_type = Type.Boolean;
	return _type;
    }

    public String toString() {
	return _value ? ""true()"" : ""false()"";
    }

    public boolean getValue() {
	return _value;
    }

    public boolean contextDependent() {
	return false;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }

    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	if (_value) {
	    il.append(NOP);	
	}
	else {
	    _falseList.add(il.append(new GOTO(null)));
	}
    }
}
"
org.apache.xpath.axes.ContextNodeList,12,1,0,1,12,66,1,0,12,2.0,12,0.0,0,0.0,0.444444444,0,0,0.0,1,1.0,0,"
package org.apache.xpath.axes;

import org.w3c.dom.Node;
import org.w3c.dom.traversal.NodeIterator;


public interface ContextNodeList
{

  
  public Node getCurrentNode();

  
  public int getCurrentPos();

  
  public void reset();

  
  public void setShouldCacheNodes(boolean b);

  
  public void runTo(int index);

  
  public void setCurrentPos(int i);

  
  public int size();

  
  public boolean isFresh();

  
  public NodeIterator cloneWithReset() throws CloneNotSupportedException;

  
  public Object clone() throws CloneNotSupportedException;

  
  public int getLast();

  
  public void setLast(int last);
}
"
org.apache.xml.utils.ElemDesc,4,1,0,0,10,0,0,0,0,1.266666667,90,0.0,0,0.0,0.833333333,0,0,15.25,4,2.0,0,"
package org.apache.xml.utils;

import java.util.Hashtable;


class ElemDesc
{

  
  Hashtable m_attrs = null;

  
  int m_flags;

  
  static final int EMPTY = (1 << 1);

  
  static final int FLOW = (1 << 2);

  
  static final int BLOCK = (1 << 3);

  
  static final int BLOCKFORM = (1 << 4);

  
  static final int BLOCKFORMFIELDSET = (1 << 5);

  
  static final int CDATA = (1 << 6);

  
  static final int PCDATA = (1 << 7);

  
  static final int RAW = (1 << 8);

  
  static final int INLINE = (1 << 9);

  
  static final int INLINEA = (1 << 10);

  
  static final int INLINELABEL = (1 << 11);

  
  static final int FONTSTYLE = (1 << 12);

  
  static final int PHRASE = (1 << 13);

  
  static final int FORMCTRL = (1 << 14);

  
  static final int SPECIAL = (1 << 15);

  
  static final int ASPECIAL = (1 << 16);

  
  static final int HEADMISC = (1 << 17);

  
  static final int HEAD = (1 << 18);

  
  static final int LIST = (1 << 19);

  
  static final int PREFORMATTED = (1 << 20);

  
  static final int WHITESPACESENSITIVE = (1 << 21);

  
  static final int ATTRURL = (1 << 1);

  
  static final int ATTREMPTY = (1 << 2);

  
  ElemDesc(int flags)
  {
    m_flags = flags;
  }

  
  boolean is(int flags)
  {
    
    return (m_flags & flags) != 0;
  }

  
  void setAttr(String name, int flags)
  {

    if (null == m_attrs)
      m_attrs = new Hashtable();

    m_attrs.put(name, new Integer(flags));
  }

  
  boolean isAttrFlagSet(String name, int flags)
  {

    if (null != m_attrs)
    {
      Integer _flags = (Integer) m_attrs.get(name);

      if (null != _flags)
      {
        return (_flags.intValue() & flags) != 0;
      }
    }

    return false;
  }
}
"
org.apache.xalan.xsltc.Translet,9,1,0,20,9,36,16,4,9,2.0,9,0.0,0,0.0,0.296296296,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

public interface Translet {

    public void transform(DOM document, TransletOutputHandler handler)
	throws TransletException;
    public void transform(DOM document, TransletOutputHandler[] handlers)
	throws TransletException;
    public void transform(DOM document, NodeIterator iterator,
			  TransletOutputHandler handler)
	throws TransletException;

    public Object addParameter(String name, Object value);

    public void buildKeys(DOM document, NodeIterator iterator,
			  TransletOutputHandler handler, int root)
	throws TransletException;
    public void addAuxiliaryClass(Class auxClass);
    public Class getAuxiliaryClass(String className);
    public String[] getNamesArray();
    public String[] getNamespaceArray();
}
"
org.apache.xalan.xsltc.compiler.util.ObjectType,14,2,0,30,39,71,6,25,13,0.538461538,167,1.0,0,0.733333333,0.222222222,2,3,10.85714286,2,1.0,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.Constants;

public final class ObjectType extends Type {

    private String _javaClassName = ""java.lang.Object""; 

    
    protected ObjectType() {}

    
    public ObjectType(String javaClassName) {
	_javaClassName = javaClassName;
    }

    public int hashCode() {
        return toString().hashCode();
    }

    public boolean equals(Object obj) {
        return (obj instanceof ObjectType);
    }

    public String getJavaClassName() {
	return _javaClassName;
    }

    public String toString() {
	return ""object"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	final StringBuffer result = new StringBuffer(""L"");
	result.append(_javaClassName.replace('.', '/')).append(';');
	return result.toString();
    }

    public org.apache.bcel.generic.Type toJCType() {
	return Util.getJCRefType(toSignature());
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	il.append(DUP);
	final BranchHandle ifNull = il.append(new IFNULL(null));
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(_javaClassName,
						    ""toString"",
						    ""()"" + STRING_SIG)));
	final BranchHandle gotobh = il.append(new GOTO(null));
	ifNull.setTarget(il.append(POP));
	il.append(new PUSH(cpg, """"));
	gotobh.setTarget(il.append(NOP));
    }

    
    public void translateFrom(ClassGenerator classGen, 
			      MethodGenerator methodGen, Class clazz) {
	methodGen.getInstructionList().append(NOP);
    }

    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}
"
org.apache.xalan.trace.TraceListenerEx,1,1,0,4,1,0,2,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xalan.trace;


public interface TraceListenerEx extends TraceListener
{

  
  public void selectEnd(EndSelectionEvent ev) throws javax.xml.transform.TransformerException;

}
"
org.apache.xpath.functions.FuncPosition,5,3,0,9,17,8,1,8,5,0.5,92,1.0,0,0.904761905,0.4,1,6,17.2,8,2.4,0,"
package org.apache.xpath.functions;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.axes.SubContextList;
import org.apache.xpath.axes.ContextNodeList;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.compiler.Compiler;


public class FuncPosition extends Function
{
  private boolean m_isTopLevel;
  
  
  public void postCompileStep(Compiler compiler)
  {
    m_isTopLevel = compiler.getLocationPathDepth() == -1;
  }

  
  public int getPositionInContextNodeList(XPathContext xctxt)
  {

    
    
    SubContextList iter = m_isTopLevel ? null : xctxt.getSubContextList();

    if (null != iter)
    {
      int prox = iter.getProximityPosition(xctxt);
 
      
      return prox;
    }

    DTMIterator cnl = xctxt.getContextNodeList();

    if (null != cnl)
    {
      int n = cnl.getCurrentNode();
      if(n == DTM.NULL)
      {
        if(cnl.getCurrentPos() == 0)
          return 0;
          
        
        
        
        
        
        try 
        { 
          cnl = cnl.cloneWithReset(); 
        }
        catch(CloneNotSupportedException cnse)
        {
          throw new org.apache.xml.utils.WrappedRuntimeException(cnse);
        }
        int currentNode = xctxt.getContextNode();
        
        while(DTM.NULL != (n = cnl.nextNode()))
        {
          if(n == currentNode)
            break;
        }
      }
      
      
      return cnl.getCurrentPos();
    }

    
    return -1;
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    double pos = (double) getPositionInContextNodeList(xctxt);
    
    return new XNumber(pos);
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }
}
"
org.apache.xalan.xsltc.cmdline.getopt.IllegalArgumentException,1,4,0,2,2,0,1,1,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.apache.xalan.xsltc.cmdline.getopt;

import org.apache.xalan.xsltc.cmdline.getopt.GetOptsException;

class IllegalArgumentException extends GetOptsException{
    public IllegalArgumentException(String msg){
	super(msg);
    }
}
"
org.apache.xalan.templates.ElemCopy,4,4,0,8,24,6,0,8,4,2.0,121,0.0,0,0.985365854,0.625,2,4,29.25,1,0.75,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xpath.*;

import java.util.*;

import org.apache.xml.utils.QName;
import org.apache.xalan.trace.*;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultTreeHandler;
import org.apache.xalan.transformer.ClonerToResultTree;

import javax.xml.transform.TransformerException;


public class ElemCopy extends ElemUse
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_COPY;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_COPY_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
                XPathContext xctxt = transformer.getXPathContext();
      
    try
    {
      int sourceNode = xctxt.getCurrentNode();
      xctxt.pushCurrentNode(sourceNode);
      DTM dtm = xctxt.getDTM(sourceNode);
      short nodeType = dtm.getNodeType(sourceNode);

      if ((DTM.DOCUMENT_NODE != nodeType) && (DTM.DOCUMENT_FRAGMENT_NODE != nodeType))
      {
        ResultTreeHandler rthandler = transformer.getResultTreeHandler();

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(this);
            
        
        ClonerToResultTree.cloneToResultTree(sourceNode, nodeType, dtm, 
                                             rthandler, false);

        if (DTM.ELEMENT_NODE == nodeType)
        {
          super.execute(transformer);
          rthandler.processNSDecls(sourceNode, nodeType, dtm);
          transformer.executeChildTemplates(this, true);
          
          String ns = dtm.getNamespaceURI(sourceNode);
          String localName = dtm.getLocalName(sourceNode);
          transformer.getResultTreeHandler().endElement(ns, localName,
                                                        dtm.getNodeName(sourceNode));
        }
        if (TransformerImpl.S_DEBUG)
		  transformer.getTraceManager().fireTraceEndEvent(this);         
      }
      else
      {
        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(this);

        super.execute(transformer);
        transformer.executeChildTemplates(this, true);

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEndEvent(this);
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      xctxt.popCurrentNode();
    }
  }
}
"
org.apache.xalan.xsltc.dom.StepIterator,8,2,1,4,21,0,2,3,8,0.238095238,157,1.0,2,0.588235294,0.34375,1,5,18.25,3,1.5,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public class StepIterator extends NodeIteratorBase {

    protected NodeIterator _source;
    protected NodeIterator _iterator;
    private int _pos = -1;

    public StepIterator(NodeIterator source, NodeIterator iterator) {
	_source = source;
	_iterator = iterator;
    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
	_iterator.setRestartable(true); 
    }

    public NodeIterator cloneIterator() {
	try {
	    final StepIterator clone = (StepIterator)super.clone();
	    clone._source = _source.cloneIterator();
	    clone._iterator = _iterator.cloneIterator();
	    clone.setRestartable(false);
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public NodeIterator setStartNode(int node) {
	if (_isRestartable) {
	    
	    _source.setStartNode(_startNode = node);

	    
	    
	    _iterator.setStartNode(_includeSelf ? _startNode : _source.next());
	    return resetPosition();
	}
	return this;
    }

    public NodeIterator reset() {
	_source.reset();
	
	_iterator.setStartNode(_includeSelf ? _startNode : _source.next());
	return resetPosition();
    }
    
    public int next() {
	for (int node;;) {
	    
	    if ((node = _iterator.next()) != END) {
		return returnNode(node);
	    }
	    
	    else if ((node = _source.next()) == END) {
		return END;
	    }
	    
	    else {
		_iterator.setStartNode(node);
	    }
	}
    }

    public void setMark() {
	_source.setMark();
	_iterator.setMark();
	_pos = _position;
    }

    public void gotoMark() {
	_source.gotoMark();
	_iterator.gotoMark();
	_position = _pos;
    }
}
"
org.apache.xalan.xsltc.compiler.StepPattern,18,6,1,57,94,31,9,49,11,0.810457516,1125,1.0,1,0.853448276,0.261904762,3,8,61.0,6,2.6111,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.Field;

import org.apache.xalan.xsltc.compiler.util.*;

class StepPattern extends RelativePathPattern {

    private static final int NO_CONTEXT = 0;
    private static final int SIMPLE_CONTEXT = 1;
    private static final int GENERAL_CONTEXT = 2;

    protected final int _axis;
    protected final int _nodeType;
    protected Vector _predicates;

    private Step    _step = null;
    private boolean _isEpsilon = false;
    private int     _contextCase;

    public StepPattern(int axis, int nodeType, Vector predicates) {
	_axis = axis;
	_nodeType = nodeType;
	_predicates = predicates;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Predicate exp = (Predicate)_predicates.elementAt(i);
		exp.setParser(parser);
		exp.setParent(this);
	    }
	}
    }

    public int getNodeType() {
	return _nodeType;
    }
    
    public StepPattern getKernelPattern() {
	return this;
    }
	
    public boolean isWildcard() {
	return _isEpsilon && hasPredicates() == false;
    }

    public StepPattern setPredicates(Vector predicates) {
	_predicates = predicates;
	return(this);
    }
    
    protected boolean hasPredicates() {
	return _predicates != null && _predicates.size() > 0;
    }

    public double getDefaultPriority() {
	if (hasPredicates()) {
	    return 0.5;
	}
	else {
	    switch(_nodeType) {
	    case -1:
		return -0.5;	
	    case 0:
		return 0.0;
	    default:
		return (_nodeType >= NodeTest.GTYPE) ? 0.0 : -0.5;
	    }
	}
    }
    
    public void reduceKernelPattern() {
	_isEpsilon = true;
    }
	
    public String toString() {
	final StringBuffer buffer = new StringBuffer(""stepPattern("""");
	buffer.append(Axis.names[_axis])
	    .append("""", "")
	    .append(_isEpsilon ? 
			(""epsilon{"" + Integer.toString(_nodeType) + ""}"") :
			 Integer.toString(_nodeType));
	if (_predicates != null)
	    buffer.append("", "").append(_predicates.toString());
	return buffer.append(')').toString();
    }
    
    private int analyzeCases() {
	boolean noContext = true;
	final int n = _predicates.size();

	for (int i = 0; i < n && noContext; i++) {
	    final Predicate pred = (Predicate)_predicates.elementAt(i);
	    if (pred.getExpr().hasPositionCall()) {
		noContext = false;
	    }
	}

	if (noContext) {
	    return NO_CONTEXT;
	}
	else if (n == 1) {
	    return SIMPLE_CONTEXT;
	}
	return GENERAL_CONTEXT;
    }

    private String getNextFieldName() {
	return  ""__step_pattern_iter_"" + getXSLTC().nextStepPatternSerial();
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (hasPredicates()) {
	    
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Predicate pred = (Predicate)_predicates.elementAt(i);
		pred.typeCheck(stable);
	    }

	    
	    _contextCase = analyzeCases();

	    
	    if (_contextCase == SIMPLE_CONTEXT) {
		_step = new Step(_axis, _nodeType, null);
		_step.setParser(getParser());
		_step.typeCheck(stable);
	    }
	    else if (_contextCase == GENERAL_CONTEXT) {
		final int len = _predicates.size();
		for (int i = 0; i < len; i++)
		    ((Predicate)_predicates.elementAt(i)).dontOptimize();
		_step = new Step(_axis, _nodeType, _predicates);
		_step.setParser(getParser());
		_step.typeCheck(stable);
	    }
	}
	return _axis == Axis.CHILD ? Type.Element : Type.Attribute;
    }

    private void translateKernel(ClassGenerator classGen, 
				 MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	
	if (_nodeType == DOM.ELEMENT) {
	    final int check = cpg.addInterfaceMethodref(DOM_INTF,
							""isElement"", ""(I)Z"");
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(new INVOKEINTERFACE(check, 2));
	
	    
	    final BranchHandle icmp = il.append(new IFNE(null));
	    _falseList.add(il.append(new GOTO_W(null)));
	    icmp.setTarget(il.append(NOP));
	}
	else if (_nodeType == DOM.ATTRIBUTE) {
	    final int check = cpg.addInterfaceMethodref(DOM_INTF,
							""isAttribute"", ""(I)Z"");
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(new INVOKEINTERFACE(check, 2));
	
	    
	    final BranchHandle icmp = il.append(new IFNE(null));
	    _falseList.add(il.append(new GOTO_W(null)));
	    icmp.setTarget(il.append(NOP));
	}
	else {
	    
	    final int getType = cpg.addInterfaceMethodref(DOM_INTF,
							  ""getType"", ""(I)I"");
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(new INVOKEINTERFACE(getType, 2));
	    il.append(new PUSH(cpg, _nodeType));
	
	    
	    final BranchHandle icmp = il.append(new IF_ICMPEQ(null));
	    _falseList.add(il.append(new GOTO_W(null)));
	    icmp.setTarget(il.append(NOP));
	}
    }

    private void translateNoContext(ClassGenerator classGen, 
				    MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadCurrentNode());
	il.append(SWAP);

	
	il.append(methodGen.storeCurrentNode());

	
	if (!_isEpsilon) {
	    il.append(methodGen.loadCurrentNode());
	    translateKernel(classGen, methodGen);
	}

	
	final int n = _predicates.size();
	for (int i = 0; i < n; i++) {
	    Predicate pred = (Predicate)_predicates.elementAt(i);
	    Expression exp = pred.getExpr();
	    exp.translateDesynthesized(classGen, methodGen);
	    _trueList.append(exp._trueList);
	    _falseList.append(exp._falseList);
	}

	
	InstructionHandle restore;
	restore = il.append(methodGen.storeCurrentNode());
	backPatchTrueList(restore);
	BranchHandle skipFalse = il.append(new GOTO(null));

	
	restore = il.append(methodGen.storeCurrentNode());
	backPatchFalseList(restore);
	_falseList.add(il.append(new GOTO(null)));

	
	skipFalse.setTarget(il.append(NOP));
    }

    private void translateSimpleContext(ClassGenerator classGen, 
					MethodGenerator methodGen) {
	int index;
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	LocalVariableGen match;
	match = methodGen.addLocalVariable(""step_pattern_tmp1"", 
					   Util.getJCRefType(NODE_SIG),
					   il.getEnd(), null);
	il.append(new ISTORE(match.getIndex()));

	
	if (!_isEpsilon) {
	    il.append(new ILOAD(match.getIndex()));
 	    translateKernel(classGen, methodGen);
	}

	
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadIterator());

	
	index = cpg.addMethodref(MATCHING_ITERATOR, ""<init>"", 
				 ""(I"" + NODE_ITERATOR_SIG + "")V"");
	il.append(new NEW(cpg.addClass(MATCHING_ITERATOR)));
	il.append(DUP);
	il.append(new ILOAD(match.getIndex()));
	_step.translate(classGen, methodGen);
	il.append(new INVOKESPECIAL(index));

	
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(match.getIndex()));
	index = cpg.addInterfaceMethodref(DOM_INTF, GET_PARENT, GET_PARENT_SIG);
	il.append(new INVOKEINTERFACE(index, 2));

	
	il.append(methodGen.setStartNode());

	
	il.append(methodGen.storeIterator());
	il.append(new ILOAD(match.getIndex()));
	il.append(methodGen.storeCurrentNode());

	
	Predicate pred = (Predicate) _predicates.elementAt(0);
	Expression exp = pred.getExpr();
	exp.translateDesynthesized(classGen, methodGen);

	
	InstructionHandle restore = il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
	exp.backPatchTrueList(restore);
	BranchHandle skipFalse = il.append(new GOTO(null));

	
	restore = il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
	exp.backPatchFalseList(restore);
	_falseList.add(il.append(new GOTO(null)));

	
	skipFalse.setTarget(il.append(NOP));
    }

    private void translateGeneralContext(ClassGenerator classGen, 
					 MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	int iteratorIndex = 0;
	BranchHandle ifBlock = null;
	LocalVariableGen iter, node, node2;
	final String iteratorName = getNextFieldName();

	
	node = methodGen.addLocalVariable(""step_pattern_tmp1"", 
					  Util.getJCRefType(NODE_SIG),
					  il.getEnd(), null);
	il.append(new ISTORE(node.getIndex()));

	
	iter = methodGen.addLocalVariable(""step_pattern_tmp2"", 
					  Util.getJCRefType(NODE_ITERATOR_SIG),
					  il.getEnd(), null);

	
	if (!classGen.isExternal()) {
	    final Field iterator =
		new Field(ACC_PRIVATE, 
			  cpg.addUtf8(iteratorName),
			  cpg.addUtf8(NODE_ITERATOR_SIG),
			  null, cpg.getConstantPool());
	    classGen.addField(iterator);
	    iteratorIndex = cpg.addFieldref(classGen.getClassName(), 
					    iteratorName,
					    NODE_ITERATOR_SIG);

	    il.append(classGen.loadTranslet());
	    il.append(new GETFIELD(iteratorIndex));
	    il.append(DUP);
	    il.append(new ASTORE(iter.getIndex()));
	    ifBlock = il.append(new IFNONNULL(null));
	    il.append(classGen.loadTranslet());
	}	

	
	_step.translate(classGen, methodGen);
	il.append(new ASTORE(iter.getIndex()));

	
	if (!classGen.isExternal()) {
	    il.append(new ALOAD(iter.getIndex()));
	    il.append(new PUTFIELD(iteratorIndex));
	    ifBlock.setTarget(il.append(NOP));
	}

	
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(node.getIndex()));
	int index = cpg.addInterfaceMethodref(DOM_INTF,
					      GET_PARENT, GET_PARENT_SIG);
	il.append(new INVOKEINTERFACE(index, 2));

	
	il.append(new ALOAD(iter.getIndex()));
	il.append(SWAP);
	il.append(methodGen.setStartNode());

	
	BranchHandle skipNext;
	InstructionHandle begin, next;
	node2 = methodGen.addLocalVariable(""step_pattern_tmp3"", 
					   Util.getJCRefType(NODE_SIG),
					   il.getEnd(), null);

	skipNext = il.append(new GOTO(null));
	next = il.append(new ALOAD(iter.getIndex()));
	begin = il.append(methodGen.nextNode());
	il.append(DUP);
	il.append(new ISTORE(node2.getIndex()));
	_falseList.add(il.append(new IFEQ(null)));	

	il.append(new ILOAD(node2.getIndex()));
	il.append(new ILOAD(node.getIndex()));
	il.append(new IF_ICMPLT(next));

	il.append(new ILOAD(node2.getIndex()));
	il.append(new ILOAD(node.getIndex()));
	_falseList.add(il.append(new IF_ICMPNE(null)));

	skipNext.setTarget(begin);
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (hasPredicates()) {
	    switch (_contextCase) {
	    case NO_CONTEXT:
		translateNoContext(classGen, methodGen);
		break;
		
	    case SIMPLE_CONTEXT:
		translateSimpleContext(classGen, methodGen);
		break;
		
	    default:
		translateGeneralContext(classGen, methodGen);
		break;
	    }
	}
	else if (isWildcard()) {
	    il.append(POP); 	
	}
	else {
	    translateKernel(classGen, methodGen);
	}
    }
}
"
org.apache.xalan.extensions.ExtensionHandlerExsltFunction,8,2,0,14,27,20,0,14,6,0.571428571,189,1.0,2,0.5,0.349206349,1,1,22.25,8,2.375,1,"
package org.apache.xalan.extensions;

import java.util.Vector;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.io.IOException;

import org.w3c.dom.NodeList;
import org.w3c.dom.Node;

import org.apache.xalan.transformer.TransformerImpl;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemExsltFunction;
import org.apache.xalan.templates.ElemExsltFuncResult;
import org.apache.xalan.templates.Constants;

import org.apache.xml.utils.QName;

import org.apache.xpath.XPathContext;
import org.apache.xpath.VariableStack;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import javax.xml.transform.TransformerException;


public class ExtensionHandlerExsltFunction extends ExtensionHandler
{
  private String m_namespace;
  private StylesheetRoot m_stylesheet;
  private static final QName RESULTQNAME = 
                  new QName(Constants.S_EXSLT_FUNCTIONS_URL,
                            Constants.EXSLT_ELEMNAME_FUNCRESULT_STRING);
    
  public ExtensionHandlerExsltFunction(String ns, StylesheetRoot stylesheet)
  {
    super(ns, ""xml""); 
    m_namespace = ns;
    m_stylesheet = stylesheet;
  }
  
  
  public void processElement(
    String localPart, ElemTemplateElement element, TransformerImpl transformer,
    Stylesheet stylesheetTree, Object methodKey) throws TransformerException, IOException
  {}
  
  
  public ElemExsltFunction getFunction(String funcName)
  {
    QName qname = new QName(m_namespace, funcName);
    ElemTemplate templ = m_stylesheet.getTemplateComposed(qname);
    if (templ != null && templ instanceof ElemExsltFunction)
      return (ElemExsltFunction) templ;
    else
      return null;    
  }
  
  
    
  public boolean isFunctionAvailable(String funcName)
  {
    return getFunction(funcName)!= null;
  }
    
   
  public boolean isElementAvailable(String elemName)
  {
    if (!(new QName(m_namespace, elemName).equals(RESULTQNAME)))
    {
      return false;
    }
    else
    {
      ElemTemplateElement elem = m_stylesheet.getFirstChildElem();
      while (elem != null && elem != m_stylesheet)
      {
        if (elem instanceof ElemExsltFuncResult && ancestorIsFunction(elem))
          return true;
        ElemTemplateElement  nextElem = elem.getFirstChildElem();
        if (nextElem == null)
          nextElem = elem.getNextSiblingElem();
        if (nextElem == null)
          nextElem = elem.getParentElem();
        elem = nextElem;
      }
    }
    return false;
  }

  
  private boolean ancestorIsFunction(ElemTemplateElement child)
  {
    while (child.getParentElem() != null 
           && !(child.getParentElem() instanceof StylesheetRoot))
    {
      if (child.getParentElem() instanceof ElemExsltFunction)
        return true;
      child = child.getParentElem();      
    }
    return false;
  }

  
  public Object callFunction(
      String funcName, Vector args, Object methodKey,
      ExpressionContext exprContext) throws TransformerException
  {
    XObject[] methodArgs;
    methodArgs = new XObject[args.size()];
    try
    {
      for (int i = 0; i < methodArgs.length; i++)
      {
        methodArgs[i] =  XObject.create(args.elementAt(i));
      }
      ElemExsltFunction elemFunc = getFunction(funcName);
      XPathContext context = exprContext.getXPathContext();
      TransformerImpl transformer = (TransformerImpl)context.getOwnerObject();
      elemFunc.execute(transformer, methodArgs);
      
      VariableStack varStack = context.getVarStack();
      XObject val = new XString(""""); 
      
      int resultIndex = elemFunc.getResultIndex();   
      if (varStack.isLocalSet(resultIndex))
        val = varStack.getLocalVariable(context, resultIndex);
      return val;
    }
    catch (Exception e)
    {
      
      throw new TransformerException(e);
    }
  }
  
}
"
org.apache.xalan.xsltc.compiler.NumberCall,3,4,0,12,15,3,0,12,3,2.0,59,0.0,0,0.979591837,0.444444444,3,13,18.66666667,3,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class NumberCall extends FunctionCall {

    public NumberCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (argumentCount() > 0) {
	    argument().typeCheck(stable);
	}
	return _type = Type.Real;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	Type targ;
	
	if (argumentCount() == 0) {
	    il.append(methodGen.loadContextNode());
	    targ = Type.Node;
	}
	else {
	    final Expression arg = argument();
	    arg.translate(classGen, methodGen);
	    arg.startResetIterator(classGen, methodGen);
	    targ = arg.getType();
	}

	if (!targ.identicalTo(Type.Real)) {
	    targ.translateTo(classGen, methodGen, Type.Real);
	}
    }
}
"
org.apache.xalan.processor.ProcessorNamespaceAlias,2,4,0,6,17,1,1,5,1,2.0,65,0.0,0,0.995260664,0.625,3,4,31.5,1,0.5,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.NamespaceAlias;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;


class ProcessorNamespaceAlias extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    NamespaceAlias na = new NamespaceAlias(handler.nextUid());

    setPropertiesFromAttributes(handler, rawName, attributes, na);
    String prefix = na.getStylesheetPrefix();
    if(prefix.equals(""#default""))
    {
      prefix = """";
      na.setStylesheetPrefix(prefix);
    }
    String stylesheetNS = handler.getNamespaceForPrefix(prefix);
    na.setStylesheetNamespace(stylesheetNS);
    prefix = na.getResultPrefix();
    if(prefix.equals(""#default""))
    {
      prefix = """";
      na.setResultPrefix(prefix);
    }
    String resultNS = handler.getNamespaceForPrefix(prefix);
    na.setResultNamespace(resultNS);
    handler.getStylesheet().setNamespaceAlias(na);
    handler.getStylesheet().appendChild(na);
  }
}
"
org.apache.xalan.xsltc.compiler.util.MultiHashtable,3,3,0,2,11,3,2,0,3,2.0,61,0.0,0,0.95,0.833333333,1,2,19.33333333,5,2.3333,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Vector;
import java.util.Hashtable;

public final class MultiHashtable extends Hashtable {
    public Object put(Object key, Object value) {
	Vector vector = (Vector)get(key);
	if (vector == null)
	    super.put(key, vector = new Vector());
	vector.add(value);
	return vector;
    }
	
    public Object maps(Object from, Object to) {
	if (from == null) return null;
	final Vector vector = (Vector) get(from);
	if (vector != null) {
	    final int n = vector.size();
	    for (int i = 0; i < n; i++) {
                final Object item = vector.elementAt(i);
		if (item.equals(to)) {
		    return item;
		}
	    }
	}
	return null;
    }
}
"
org.apache.xml.utils.ListingErrorHandler,17,1,0,4,52,50,0,4,16,0.65625,569,1.0,0,0.0,0.196078431,0,0,32.23529412,14,1.8824,0,"

package org.apache.xml.utils;

import java.io.BufferedReader;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.xml.sax.ErrorHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;



public class ListingErrorHandler implements ErrorHandler, ErrorListener
{
    protected PrintWriter m_pw = null;
  

    
    public ListingErrorHandler(PrintWriter pw)
    {
        if (null == pw)
            throw new NullPointerException(XSLMessages.createMessage(XSLTErrorResources.ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER, null));
            
            
        m_pw = pw;
    }

    
    public ListingErrorHandler()
    {
        m_pw = new PrintWriter(System.err, true);
    }


    
    
    public void warning (SAXParseException exception)
    	throws SAXException
    {
    	logExceptionLocation(m_pw, exception);
        
        
        m_pw.println(""warning: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnWarning())
            throw exception;
    }
    
    
    
    public void error (SAXParseException exception)
    	throws SAXException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""error: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnError())
            throw exception;
    }
    
    
    
    public void fatalError (SAXParseException exception)
    	throws SAXException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""fatalError: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnFatalError())
            throw exception;
    }


    

    
    public void warning(TransformerException exception)
        throws TransformerException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""warning: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnWarning())
            throw exception;
    }

    
    public void error(TransformerException exception)
        throws TransformerException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""error: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnError())
            throw exception;
    }

    
    public void fatalError(TransformerException exception)
        throws TransformerException
    {
    	logExceptionLocation(m_pw, exception);
        m_pw.println(""error: "" + exception.getMessage());
        m_pw.flush();

        if (getThrowOnError())
            throw exception;
    }



    


    
    public static void logExceptionLocation(PrintWriter pw, Throwable exception)
    {
        if (null == pw)
            pw = new PrintWriter(System.err, true);
        
        SourceLocator locator = null;
        Throwable cause = exception;

        
        do
        {
            
            if(cause instanceof SAXParseException)
            {
                
                
                
                
                
                locator = new SAXSourceLocator((SAXParseException)cause);
            }
            else if (cause instanceof TransformerException)
            {
                SourceLocator causeLocator = ((TransformerException)cause).getLocator();
                if(null != causeLocator)
                {
                    locator = causeLocator;
                }
            }
            
            
            if(cause instanceof TransformerException)
                cause = ((TransformerException)cause).getCause();
            else if(cause instanceof WrappedRuntimeException)
                cause = ((WrappedRuntimeException)cause).getException();
            else if(cause instanceof SAXException)
                cause = ((SAXException)cause).getException();
            else
                cause = null;
        }
        while(null != cause);

        
        
        
        if(null != locator)
        {
            String id = (locator.getPublicId() != locator.getPublicId())
                      ? locator.getPublicId()
                        : (null != locator.getSystemId())
                          ? locator.getSystemId() : ""SystemId-Unknown"";

            pw.print(id + "":Line="" + locator.getLineNumber()
                             + "";Column="" + locator.getColumnNumber()+"": "");
            pw.println(""exception:"" + exception.getMessage());
            pw.println(""root-cause:"" 
                       + ((null != cause) ? cause.getMessage() : ""null""));
            logSourceLine(pw, locator); 
        }
        else
        {
            pw.print(""SystemId-Unknown:locator-unavailable: "");
            pw.println(""exception:"" + exception.getMessage());
            pw.println(""root-cause:"" 
                       + ((null != cause) ? cause.getMessage() : ""null""));
        }
    }


    
    public static void logSourceLine(PrintWriter pw, SourceLocator locator)
    {
        if (null == locator)
            return;
            
        if (null == pw)
            pw = new PrintWriter(System.err, true);

        String url = locator.getSystemId();
        
        
        
        if (null == url)
        {
            pw.println(""line: (No systemId; cannot read file)"");
            pw.println();
            return;
        }
        
        

        try
        {
            int line = locator.getLineNumber();
            int column = locator.getColumnNumber();
            pw.println(""line: "" + getSourceLine(url, line));
            StringBuffer buf = new StringBuffer(""line: "");
            for (int i = 1; i < column; i++)
            {
                buf.append(' ');
            }
            buf.append('^');
            pw.println(buf.toString());
        }
        catch (Exception e)
        {
            pw.println(""line: logSourceLine unavailable due to: "" + e.getMessage());
            pw.println();
        }
    }


    
    protected static String getSourceLine(String sourceUrl, int lineNum)
            throws Exception
    {
        URL url = null;
        
        try
        {
            
            url = new URL(sourceUrl);
        }
        catch (java.net.MalformedURLException mue)
        {
            int indexOfColon = sourceUrl.indexOf(':');
            int indexOfSlash = sourceUrl.indexOf('/');
            
            if ((indexOfColon != -1)
                && (indexOfSlash != -1)
                && (indexOfColon < indexOfSlash))
            {
                
                
                throw mue;
            }
            else
            {
                
                url = new URL(SystemIDResolver.getAbsoluteURI(sourceUrl));
                
            }
        }
        
        String line = null;
        InputStream is = null;
        BufferedReader br = null;
        try
        {
            
            URLConnection uc = url.openConnection();
            is = uc.getInputStream();
            br = new BufferedReader(new InputStreamReader(is));

            
            
            for (int i = 1; i <= lineNum; i++)
            {
                line = br.readLine();
            }
            
        } 
        
        
        finally
        {
            br.close();
            is.close();
        }
        
        
        return line;
    }    


    

    
    public void setThrowOnWarning(boolean b)
    {
        throwOnWarning = b;
    }

    
    public boolean getThrowOnWarning()
    {
        return throwOnWarning;
    }

    
    protected boolean throwOnWarning = false;


    
    public void setThrowOnError(boolean b)
    {
        throwOnError = b;
    }

    
    public boolean getThrowOnError()
    {
        return throwOnError;
    }

    
    protected boolean throwOnError = true;


    
    public void setThrowOnFatalError(boolean b)
    {
        throwOnFatalError = b;
    }

    
    public boolean getThrowOnFatalError()
    {
        return throwOnFatalError;
    }

    
    protected boolean throwOnFatalError = true;

}
"
org.apache.xalan.serialize.WriterToUTF8,7,2,0,1,13,0,1,0,7,0.0,213,1.0,0,0.684210526,0.342857143,1,2,29.28571429,1,0.8571,0,"
package org.apache.xalan.serialize;

import java.io.*;


public class WriterToUTF8 extends Writer
{

  
  private final OutputStream m_os;

  
  public WriterToUTF8(OutputStream os) throws UnsupportedEncodingException
  {
    m_os = os;
  }

  
  public void write(final int c) throws IOException
  {

    if (c < 0x80)
      m_os.write(c);
    else if (c < 0x800)
    {
      m_os.write(0xc0 + (c >> 6));
      m_os.write(0x80 + (c & 0x3f));
    }
    else
    {
      m_os.write(0xe0 + (c >> 12));
      m_os.write(0x80 + ((c >> 6) & 0x3f));
      m_os.write(0x80 + (c & 0x3f));
    }
  }

  
  public void write(final char chars[], final int start, final int length)
          throws java.io.IOException
  {

    final OutputStream os = m_os;

    int n = length+start;
    for (int i = start; i < n; i++)
    {
      final char c = chars[i];

      if (c < 0x80)
        os.write(c);
      else if (c < 0x800)
      {
        os.write(0xc0 + (c >> 6));
        os.write(0x80 + (c & 0x3f));
      }
      else
      {
        os.write(0xe0 + (c >> 12));
        os.write(0x80 + ((c >> 6) & 0x3f));
        os.write(0x80 + (c & 0x3f));
      }
    }
  }

  
  public void write(final String s) throws IOException
  {

    final int n = s.length();
    final OutputStream os = m_os;

    for (int i = 0; i < n; i++)
    {
      final char c = s.charAt(i);

      if (c < 0x80)
        os.write(c);
      else if (c < 0x800)
      {
        os.write(0xc0 + (c >> 6));
        os.write(0x80 + (c & 0x3f));
      }
      else
      {
        os.write(0xe0 + (c >> 12));
        os.write(0x80 + ((c >> 6) & 0x3f));
        os.write(0x80 + (c & 0x3f));
      }
    }
  }

  
  public void flush() throws java.io.IOException
  {
    m_os.flush();
  }

  
  public void close() throws java.io.IOException
  {
    m_os.close();
  }

  
  public OutputStream getOutputStream()
  {
    return m_os;
  }
}
"
org.apache.xpath.functions.FuncRound,2,4,0,5,7,1,0,5,2,2.0,17,0.0,0,0.979591837,0.75,1,6,7.5,1,0.5,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;


public class FuncRound extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(java.lang.Math.floor(m_arg0.execute(xctxt).num()
                                            + 0.5));
  }
}
"
org.apache.xalan.transformer.XalanProperties,1,1,0,0,2,0,0,0,1,2.0,5,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"

package org.apache.xalan.transformer;


public class XalanProperties
{
  public final static String SOURCE_LOCATION
    = ""http:
}
"
org.apache.xalan.xsltc.runtime.Operators,1,1,0,3,1,0,3,0,0,2.0,36,0.0,0,0.0,0.0,0,0,28.0,0,0.0,0,"

package org.apache.xalan.xsltc.runtime;

public interface Operators {
    public static final int EQ = 0;
    public static final int NE = 1;
    public static final int GT = 2;
    public static final int LT = 3;
    public static final int GE = 4;
    public static final int LE = 5;
	
    public static final String[] names = {
	""="", ""!="", "">"", ""<"", "">="", ""<=""
    };
}
"
org.apache.xalan.trace.TraceListenerEx2,1,1,0,4,1,0,2,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xalan.trace;


public interface TraceListenerEx2 extends TraceListenerEx
{
  
  public void traceEnd(TracerEvent ev);
}
"
org.apache.xalan.xsltc.dom.AnyNodeCounter,4,2,1,5,10,6,1,5,4,2.0,58,0.0,0,0.823529412,0.5,1,4,13.5,5,1.75,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.NodeIterator;

public abstract class AnyNodeCounter extends NodeCounter {
    public AnyNodeCounter(Translet translet,
			  DOM document, NodeIterator iterator) {
	super(translet, document, iterator);
    }
	
    public NodeCounter setStartNode(int node) {
	_node = node;
	_nodeType = _document.getType(node);
	return this;
    }

    public String getCounter() {
	int result;
	if (_value != Integer.MIN_VALUE) {
	    result = _value;
	}
	else {
	    int next = _node;
	    result = 0;
	    while (next >= 0 && !matchesFrom(next)) {
		if (matchesCount(next)) {
		    ++result;	
		}
		--next;
	    }
	}
	return formatNumbers(result);
    }

    public static NodeCounter getDefaultNodeCounter(Translet translet,
						    DOM document,
						    NodeIterator iterator) {
	return new DefaultAnyNodeCounter(translet, document, iterator);
    }

    static class DefaultAnyNodeCounter extends AnyNodeCounter {
	public DefaultAnyNodeCounter(Translet translet,
				     DOM document, NodeIterator iterator) {
	    super(translet, document, iterator);
	}

	public String getCounter() {
	    int result;
	    if (_value != Integer.MIN_VALUE) {
		result = _value;
	    }
	    else {
		int next = _node;
		result = 0;
		final int ntype = _document.getType(_node); 
		while (next >= 0) {
		    if (ntype == _document.getType(next)) {
			result++;
		    }
		    next--;
		}
	    }
	    return formatNumbers(result);
	}
    }
}
"
org.apache.xpath.WhitespaceStrippingElementMatcher,2,1,0,2,2,1,1,1,2,2.0,2,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,0,"package org.apache.xpath;

import org.w3c.dom.Element;
import javax.xml.transform.TransformerException;


public interface WhitespaceStrippingElementMatcher
{
  
  public boolean shouldStripWhiteSpace(
          XPathContext support, Element targetElement) throws TransformerException;
  
  
  public boolean canStripWhiteSpace();
}"
org.apache.xalan.processor.TransformerFactoryImpl,25,3,0,23,103,210,12,13,20,0.916666667,979,0.357142857,0,0.465116279,0.199074074,1,2,37.6,17,1.76,3,"
package org.apache.xalan.processor;

import org.xml.sax.InputSource;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.XMLReader;

import javax.xml.transform.TransformerException;

import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.XMLFilter;

import org.w3c.dom.Node;

import org.apache.xml.utils.TreeWalker;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.DefaultErrorHandler;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.TransformerIdentityImpl;
import org.apache.xalan.transformer.TrAXFilter;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.Source;
import javax.xml.transform.URIResolver;
import javax.xml.transform.Templates;
import javax.xml.transform.sax.TemplatesHandler;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.ErrorListener;

import java.io.IOException;
import java.io.InputStream;
import java.io.BufferedInputStream;
import java.io.StringWriter;
import java.io.PrintWriter;
import java.io.StringReader;

import java.util.Properties;
import java.util.Enumeration;

import org.apache.xalan.transformer.XalanProperties;


public class TransformerFactoryImpl extends SAXTransformerFactory
{

  
  public static String XSLT_PROPERTIES =
    ""org/apache/xalan/res/XSLTInfo.properties"";

  
  private static boolean isInited = false;

  
  public TransformerFactoryImpl()
  {
    loadPropertyFileToSystem(XSLT_PROPERTIES);
  }

  
  private static final Class[] NO_CLASSES = new Class[0];

  
  private static final Object[] NO_OBJS = new Object[0];
  
  
  public static final String FEATURE_INCREMENTAL = ""http:

  
  public static final String FEATURE_OPTIMIZE = ""http:

  
  public static final String FEATURE_SOURCE_LOCATION = XalanProperties.SOURCE_LOCATION;

  
  private static void loadPropertyFileToSystem(String file)
  {

    if (false == isInited)
    {
      try
      {
        InputStream is = null;

        try
        {
          Properties props = new Properties();

          try {
            java.lang.reflect.Method getCCL = Thread.class.getMethod(""getContextClassLoader"", NO_CLASSES);
            if (getCCL != null) {
              ClassLoader contextClassLoader = (ClassLoader) getCCL.invoke(Thread.currentThread(), NO_OBJS);
              is = contextClassLoader.getResourceAsStream(file); 
            }
          }
          catch (Exception e) {}

          if (is == null) {
            
            
            
            is = TransformerFactoryImpl.class.getResourceAsStream(""/"" + file); 
          }

          
          BufferedInputStream bis = new BufferedInputStream(is);

          props.load(bis);  
          bis.close();  

          
          
          Properties systemProps = System.getProperties();
          Enumeration propEnum = props.propertyNames();

          while (propEnum.hasMoreElements())
          {
            String prop = (String) propEnum.nextElement();

            if (!systemProps.containsKey(prop))
              systemProps.put(prop, props.getProperty(prop));
          }

          System.setProperties(systemProps);

          isInited = true;
        }
        catch (Exception ex){}
      }
      catch (SecurityException se)
      {

        
        
      }
    }
  }

public javax.xml.transform.Templates processFromNode(Node node)
          throws TransformerConfigurationException
  {

    try
    {
      TemplatesHandler builder = newTemplatesHandler();
      TreeWalker walker = new TreeWalker(builder, new org.apache.xpath.DOM2Helper(), builder.getSystemId());

      walker.traverse(node);

      return builder.getTemplates();
    }
    catch (org.xml.sax.SAXException se)
    {
      if (m_errorListener != null)
      {
        try
        {
          m_errorListener.fatalError(new TransformerException(se));
        }
        catch (TransformerException ex)
        {
          throw new TransformerConfigurationException(ex);
        }

        return null;
      }
      else

        
        
        
        throw new TransformerConfigurationException(XSLMessages.createMessage(XSLTErrorResources.ER_PROCESSFROMNODE_FAILED, null), se); 
                                                    
    }
    catch (TransformerConfigurationException tce)
    {
      
      throw tce;
    }
   
    catch (Exception e)
    {
      if (m_errorListener != null)
      {
        try
        {
          m_errorListener.fatalError(new TransformerException(e));
        }
        catch (TransformerException ex)
        {
          throw new TransformerConfigurationException(ex);
        }

        return null;
      }
      else

        
        
        
        throw new TransformerConfigurationException(XSLMessages.createMessage(XSLTErrorResources.ER_PROCESSFROMNODE_FAILED, null), e); 
                                                    
    }
  }

  
  private String m_DOMsystemID = null;

  
  String getDOMsystemID()
  {
    return m_DOMsystemID;
  }

  
  javax.xml.transform.Templates processFromNode(Node node, String systemID)
          throws TransformerConfigurationException
  {

    m_DOMsystemID = systemID;

    return processFromNode(node);
  }

  
  public Source getAssociatedStylesheet(
          Source source, String media, String title, String charset)
            throws TransformerConfigurationException
  {

    String baseID;
    InputSource isource = null;
    Node node = null;
    XMLReader reader = null;

    if (source instanceof DOMSource)
    {
      DOMSource dsource = (DOMSource) source;

      node = dsource.getNode();
      baseID = dsource.getSystemId();
    }
    else
    {
      isource = SAXSource.sourceToInputSource(source);
      baseID = isource.getSystemId();
    }

    
    
    
    StylesheetPIHandler handler = new StylesheetPIHandler(baseID, media,
                                    title, charset);
    
    
    if (m_uriResolver != null) 
    {
      handler.setURIResolver(m_uriResolver); 
    }

    try
    {
      if (null != node)
      {
        TreeWalker walker = new TreeWalker(handler, new org.apache.xpath.DOM2Helper(), baseID);

        walker.traverse(node);
      }
      else
      {

        
        try
        {
          javax.xml.parsers.SAXParserFactory factory =
            javax.xml.parsers.SAXParserFactory.newInstance();

          factory.setNamespaceAware(true);

          javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser();

          reader = jaxpParser.getXMLReader();
        }
        catch (javax.xml.parsers.ParserConfigurationException ex)
        {
          throw new org.xml.sax.SAXException(ex);
        }
        catch (javax.xml.parsers.FactoryConfigurationError ex1)
        {
          throw new org.xml.sax.SAXException(ex1.toString());
        }
        catch (NoSuchMethodError ex2){}
        catch (AbstractMethodError ame){}

        if (null == reader)
        {
          reader = XMLReaderFactory.createXMLReader();
        }

        
        reader.setContentHandler(handler);
        reader.parse(isource);
      }
    }
    catch (StopParseException spe)
    {

      
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerConfigurationException(
        ""getAssociatedStylesheets failed"", se);
    }
    catch (IOException ioe)
    {
      throw new TransformerConfigurationException(
        ""getAssociatedStylesheets failed"", ioe);
    }

    return handler.getAssociatedStylesheet();
  }

  
  public TemplatesHandler newTemplatesHandler()
          throws TransformerConfigurationException
  {
    return new StylesheetHandler(this);
  }

  
  public boolean getFeature(String name)
  {

    
    
    if ((DOMResult.FEATURE == name) || (DOMSource.FEATURE == name)
            || (SAXResult.FEATURE == name) || (SAXSource.FEATURE == name)
            || (StreamResult.FEATURE == name)
            || (StreamSource.FEATURE == name)
            || (SAXTransformerFactory.FEATURE == name)
            || (SAXTransformerFactory.FEATURE_XMLFILTER == name))
      return true;
    else if ((DOMResult.FEATURE.equals(name))
             || (DOMSource.FEATURE.equals(name))
             || (SAXResult.FEATURE.equals(name))
             || (SAXSource.FEATURE.equals(name))
             || (StreamResult.FEATURE.equals(name))
             || (StreamSource.FEATURE.equals(name))
             || (SAXTransformerFactory.FEATURE.equals(name))
             || (SAXTransformerFactory.FEATURE_XMLFILTER.equals(name)))
      return true;
    else
      return false;
  }
  
  public static boolean m_optimize = true;
  
  
  public static boolean m_source_location = false;
  
  
  public void setAttribute(String name, Object value)
          throws IllegalArgumentException
  {
    if (name.equals(FEATURE_INCREMENTAL))
    {
      if(value instanceof Boolean)
      {
        
        org.apache.xml.dtm.DTMManager.setIncremental(((Boolean)value).booleanValue());
      }
      else if(value instanceof String)
      {
        
        org.apache.xml.dtm.DTMManager.setIncremental((new Boolean((String)value)).booleanValue());
      }
      else
      {
        
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BAD_VALUE, new Object[]{name, value})); 
      }
	}
    else if (name.equals(FEATURE_OPTIMIZE))
    {
      if(value instanceof Boolean)
      {
        
        m_optimize = ((Boolean)value).booleanValue();
      }
      else if(value instanceof String)
      {
        
        m_optimize = (new Boolean((String)value)).booleanValue();
      }
      else
      {
        
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BAD_VALUE, new Object[]{name, value})); 
      }
    }
    
    
    
    
    
    
    else if(name.equals(FEATURE_SOURCE_LOCATION))
    {
      if(value instanceof Boolean)
      {
        
        m_source_location = ((Boolean)value).booleanValue();
      }
      else if(value instanceof String)
      {
        
        m_source_location = (new Boolean((String)value)).booleanValue();
      }
      else
      {
        
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_BAD_VALUE, new Object[]{name, value})); 
      }
    }
    
    else
    {
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NOT_SUPPORTED, new Object[]{name})); 
    }
  }

  
  public Object getAttribute(String name) throws IllegalArgumentException
  {
    if (name.equals(FEATURE_INCREMENTAL))
    {
      return new Boolean(org.apache.xml.dtm.DTMManager.getIncremental());            
    }
    else if (name.equals(FEATURE_OPTIMIZE))
    {
      return new Boolean(m_optimize);
    }
    else if (name.equals(FEATURE_SOURCE_LOCATION))
    {
      return new Boolean(m_source_location);
    }
    else
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_ATTRIB_VALUE_NOT_RECOGNIZED, new Object[]{name})); 
  }

  
  public XMLFilter newXMLFilter(Source src)
          throws TransformerConfigurationException
  {

    Templates templates = newTemplates(src);
    if( templates==null ) return null;
    
    return newXMLFilter(templates);
  }

  
  public XMLFilter newXMLFilter(Templates templates)
          throws TransformerConfigurationException
  {
    try {
      return new TrAXFilter(templates);
    } catch( TransformerConfigurationException ex ) {
      if( m_errorListener != null) {
        try {
          m_errorListener.fatalError( ex );
          return null;
        } catch( TransformerException ex1 ) {
          new TransformerConfigurationException(ex1);
        }
      }
      throw ex;
    }
  }

  
  public TransformerHandler newTransformerHandler(Source src)
          throws TransformerConfigurationException
  {

    Templates templates = newTemplates(src);
    if( templates==null ) return null;
    
    return newTransformerHandler(templates);
  }

  
  public TransformerHandler newTransformerHandler(Templates templates)
          throws TransformerConfigurationException
  {
    try {
      TransformerImpl transformer =
        (TransformerImpl) templates.newTransformer();
      transformer.setURIResolver(m_uriResolver);
      TransformerHandler th =
        (TransformerHandler) transformer.getInputContentHandler(true);

      return th;
    } catch( TransformerConfigurationException ex ) {
      if( m_errorListener != null ) {
        try {
          m_errorListener.fatalError( ex );
          return null;
        } catch (TransformerException ex1 ) {
          ex=new TransformerConfigurationException(ex1);
        }
      }
      throw ex;
    }
    
  }












  
  public TransformerHandler newTransformerHandler()
          throws TransformerConfigurationException
  {















    return new TransformerIdentityImpl();
  }

  
  public Transformer newTransformer(Source source)
          throws TransformerConfigurationException
  {
    try {
      Templates tmpl=newTemplates( source );
      
      if( tmpl==null ) return null;
      Transformer transformer = tmpl.newTransformer();
      transformer.setURIResolver(m_uriResolver);
      return transformer;
    } catch( TransformerConfigurationException ex ) {
      if( m_errorListener != null ) {
        try {
          m_errorListener.fatalError( ex );
          return null;
        } catch( TransformerException ex1 ) {
          ex=new TransformerConfigurationException( ex1 );
        }
      }
      throw ex;
    }
  }

  
  public Transformer newTransformer() throws TransformerConfigurationException
  {















      return new TransformerIdentityImpl();
  }

  
  public Templates newTemplates(Source source)
          throws TransformerConfigurationException
  {

    TemplatesHandler builder = newTemplatesHandler();
    String baseID = source.getSystemId();

    if (null == baseID)
    {
      try
      {
        String currentDir = System.getProperty(""user.dir"");
        
        if (currentDir.startsWith(java.io.File.separator))
          baseID = ""file:
                   + source.getClass().getName();
        else
          baseID = ""file:
                   + source.getClass().getName();
      }
      catch (SecurityException se)
      {

        
        
      }
    }
    else
    {
      try
      {
        baseID = SystemIDResolver.getAbsoluteURI(baseID);
      }
      catch (TransformerException te)
      {
        throw new TransformerConfigurationException(te);
      }
    }

    builder.setSystemId(baseID);

    if (source instanceof DOMSource)
    {
      DOMSource dsource = (DOMSource) source;
      Node node = dsource.getNode();

      if (null != node)
        return processFromNode(node, baseID);
      else
      {
        String messageStr = XSLMessages.createMessage(
          XSLTErrorResources.ER_ILLEGAL_DOMSOURCE_INPUT, null);

        throw new IllegalArgumentException(messageStr);
      }
    }

    try
    {
      InputSource isource = SAXSource.sourceToInputSource(source);
      XMLReader reader = null;

      if (source instanceof SAXSource)
        reader = ((SAXSource) source).getXMLReader();
        
      boolean isUserReader = (reader != null);

      if (null == reader)
      {

        
        try
        {
          javax.xml.parsers.SAXParserFactory factory =
            javax.xml.parsers.SAXParserFactory.newInstance();

          factory.setNamespaceAware(true);

          javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser();

          reader = jaxpParser.getXMLReader();
        }
        catch (javax.xml.parsers.ParserConfigurationException ex)
        {
          throw new org.xml.sax.SAXException(ex);
        }
        catch (javax.xml.parsers.FactoryConfigurationError ex1)
        {
          throw new org.xml.sax.SAXException(ex1.toString());
        }
        catch (NoSuchMethodError ex2){}
        catch (AbstractMethodError ame){}
      }

      if (null == reader)
        reader = XMLReaderFactory.createXMLReader();

      
      
      
      try
      {
        if(!isUserReader)
          reader.setFeature(""http:
                            true);
      }
      catch (org.xml.sax.SAXException ex)
      {

        
      }

      reader.setContentHandler(builder);
      reader.parse(isource);
    }
    catch (org.xml.sax.SAXException se)
    {
      if (m_errorListener != null)
      {
        try
        {
          m_errorListener.fatalError(new TransformerException(se));
        }
        catch (TransformerException ex1)
        {
          throw new TransformerConfigurationException(ex1);
        }
      }
      else
        throw new TransformerConfigurationException(se.getMessage(), se);
    }
    catch (Exception e)
    {
      if (m_errorListener != null)
      {
        try
        {
          m_errorListener.fatalError(new TransformerException(e));

          return null;
        }
        catch (TransformerException ex1)
        {
          throw new TransformerConfigurationException(ex1);
        }
      }
      else
        throw new TransformerConfigurationException(e.getMessage(), e);
    }

    return builder.getTemplates();
  }

  
  URIResolver m_uriResolver;

  
  public void setURIResolver(URIResolver resolver)
  {
    m_uriResolver = resolver;
  }

  
  public URIResolver getURIResolver()
  {
    return m_uriResolver;
  }

  
  private ErrorListener m_errorListener = new DefaultErrorHandler();

  
  public ErrorListener getErrorListener()
  {
    return m_errorListener;
  }

  
  public void setErrorListener(ErrorListener listener)
          throws IllegalArgumentException
  {

    if (null == listener)
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_ERRORLISTENER, null));
      

    m_errorListener = listener;
  }
}
"
org.apache.xalan.xsltc.runtime.output.StreamXMLOutput,20,3,0,8,56,188,2,6,15,1.019736842,859,1.0,0,0.709677419,0.292857143,2,8,41.55,12,2.3,1,"

package org.apache.xalan.xsltc.runtime.output;

import java.util.Stack;
import java.util.Vector;

import java.io.Writer;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.runtime.*;
import org.apache.xalan.xsltc.runtime.Hashtable;

public class StreamXMLOutput extends StreamOutput {

    private static final String BEGCDATA = ""<![CDATA["";
    private static final String ENDCDATA = ""]]>"";
    private static final String CNTCDATA = ""]]]]><![CDATA[>"";
    private static final String BEGCOMM  = ""<!--"";
    private static final String ENDCOMM  = ""-->"";
    private static final String CDATA_ESC_START = ""]]>&#"";
    private static final String CDATA_ESC_END   = "";<![CDATA["";

    private String _elementName;

    public StreamXMLOutput(Writer writer, String encoding) {
	super(writer, encoding);
	initCDATA();
	initNamespaces();

    }

    public StreamXMLOutput(OutputStream out, String encoding) 
	throws IOException
    {
	super(out, encoding);
	initCDATA();
	initNamespaces();

    }

    public void startDocument() throws TransletException { 

	if (!_omitHeader) {
	    final StringBuffer header = new StringBuffer(""<?xml version="""");
	    header.append(_version).append("""" encoding="""").append(_encoding);
	    if (_standalone != null) {
		header.append("""" standalone="""").append(_standalone);
	    }
	    header.append(""""?>
"");

	    
	    _buffer.insert(0, header.toString());
	}
    }

    public void endDocument() throws TransletException { 

	
	outputBuffer();
    }

    public void startElement(String elementName) throws TransletException { 

	if (_startTagOpen) {
	    closeStartTag();
	}
	else if (_cdataTagOpen) {
	    endCDATA();
	}

	
	if (_firstElement) {
	    if (_doctypeSystem != null) {
		appendDTD(elementName);
	    }
	    _firstElement = false;
	}

	if (_indent) {
	    indent(_lineFeedNextStartTag);
	    _lineFeedNextStartTag = true;
	    _indentNextEndTag = false;
	    _indentLevel++;
	}

	_buffer.append('<').append(elementName);

	_depth++;
	_startTagOpen = true;
	_elementName = elementName;
    }

    public void endElement(String elementName) throws TransletException { 

	if (_cdataTagOpen) {
	    endCDATA();
	}

	if (_startTagOpen) {
	    appendAttributes();
	    _buffer.append(""/>"");
	    _startTagOpen = false;

	    if (_indent) {
		_indentLevel--;
		_indentNextEndTag = true;
	    }
	}
	else {
	    if (_indent) {
		_indentLevel--;

		if (_indentNextEndTag) {
		    indent(_indentNextEndTag);
		    _indentNextEndTag = true;
		    _lineFeedNextStartTag = true;
		}
	    }
	    _buffer.append(""</"").append(elementName).append('>');
	    _indentNextEndTag = true;
	}

	if (((Integer) _cdataStack.peek()).intValue() == _depth) {
	    _cdataStack.pop();
	}

	popNamespaces();
	_depth--;
    }

    public void characters(String characters) throws TransletException { 

	characters(characters.toCharArray(), 0, characters.length());
    }

    public void characters(char[] characters, int offset, int length)
	throws TransletException 
    {
	if (length <= 0) return;

	if (_startTagOpen) {
	    closeStartTag();
	}

	final Integer I = (Integer) _cdataStack.peek();
	if (I.intValue() == _depth && !_cdataTagOpen) {
	    startCDATA(characters, offset, length);
	} 
	else if (_escaping) {
	    if (_cdataTagOpen) {
		escapeCDATA(characters, offset, length);
	    } 
	    else {
		escapeCharacters(characters, offset, length);
	    }
	} 
	else {
	    _buffer.append(characters, offset, length);
	}
    }

    public void attribute(String name, String value)
	throws TransletException 
    { 

	if (_startTagOpen) {
	    int k;
	    final Attribute attr = 
		new Attribute(patchName(name), escapeString(value));

	    if ((k = _attributes.indexOf(attr)) >= 0) {
		_attributes.setElementAt(attr, k);
	    }
	    else {
		_attributes.add(attr);
	    }
	}
    }

    public void comment(String comment) throws TransletException { 
	if (_startTagOpen) {
	    closeStartTag();
	}
	else if (_cdataTagOpen) {
	    endCDATA();
	}
	appendComment(comment);
    }

    public void processingInstruction(String target, String data)
	throws TransletException 
    { 

	if (_startTagOpen) {
	    closeStartTag();
	}
	else if (_cdataTagOpen) {
	    endCDATA();
	}

	_buffer.append(""<?"").append(target).append(' ')
	       .append(data).append(""?>"");
    }

    public boolean setEscaping(boolean escape) throws TransletException 
    { 
	final boolean temp = _escaping;
	_escaping = escape;
	return temp; 
    }

   public void namespace(final String prefix, final String uri)
	throws TransletException 
    {

	String escaped = escapeString(uri);
	if (_startTagOpen) {
	    if (pushNamespace(prefix, escaped)) {
		_buffer.append(' ').append(XMLNS_PREFIX);
		if (prefix != null && prefix != EMPTYSTRING) {
		    _buffer.append(':').append(prefix);
		}
		_buffer.append(""="""").append(escaped).append('""');
	    }
	}
	else if (prefix != EMPTYSTRING || uri != EMPTYSTRING) {
	    BasisLibrary.runTimeError(BasisLibrary.STRAY_NAMESPACE_ERR,
				      prefix, escaped);
	}
    }

    protected void closeStartTag() throws TransletException {
	super.closeStartTag();

	if (_cdata != null) {
	    final String localName = getLocalName(_elementName);
	    final String uri = getNamespaceURI(_elementName, true);

	    final StringBuffer expandedName = (uri == EMPTYSTRING) ? 
		new StringBuffer(_elementName) :
		new StringBuffer(uri).append(':').append(localName);

	    if (_cdata.containsKey(expandedName.toString())) {
		_cdataStack.push(new Integer(_depth));
	    }
	}
    }

    
    private void startCDATA(char[] ch, int off, int len) {
	final int limit = off + len;
	int offset = off;

	
	_buffer.append(BEGCDATA);

	
	for (int i = offset; i < limit - 2; i++) {
	    if (ch[i] == ']' && ch[i + 1] == ']' && ch[i + 2] == '>') {
		_buffer.append(ch, offset, i - offset)
		       .append(CNTCDATA);
		offset = i + 3;
		i += 2; 	
	    }
	}

	
	if (offset < limit) {
	    _buffer.append(ch, offset, limit - offset);
	}
	_cdataTagOpen = true;
    }

    public void startCDATA() throws TransletException {
	_buffer.append(BEGCDATA);
	_cdataTagOpen = true;
    }

    public void endCDATA() throws TransletException {
	_buffer.append(ENDCDATA);
	_cdataTagOpen = false;
    }

    
    private void escapeCDATA(char[] ch, int off, int len) {
	int offset = off;
	int limit = off + len;

	if (limit > ch.length) {
	    limit = ch.length;
	}

	
	for (int i = off; i < limit; i++) {
	    final char current = ch[i];

	    if (current > '') {
		_buffer.append(ch, offset, i - offset)
		       .append(CDATA_ESC_START)
		       .append(Integer.toString((int) current))
		       .append(CDATA_ESC_END);
		offset = i + 1;
	    }
	}
	
	if (offset < limit) {
	    _buffer.append(ch, offset, limit - offset);
	}
    }

    
    private String escapeString(String value) {
	final char[] ch = value.toCharArray();
	final int limit = ch.length;
	StringBuffer result = new StringBuffer();
	
	int offset = 0;
	for (int i = 0; i < limit; i++) {
	    switch (ch[i]) {
	    case '&':
		result.append(ch, offset, i - offset).append(AMP);
		offset = i + 1;
		break;
	    case '""':
		result.append(ch, offset, i - offset).append(QUOT);
		offset = i + 1;
		break;
	    case '<':
		result.append(ch, offset, i - offset).append(LT);
		offset = i + 1;
		break;
	    case '>':
		result.append(ch, offset, i - offset).append(GT);
		offset = i + 1;
		break;
	    case '
':
		result.append(ch, offset, i - offset).append(CRLF);
		offset = i + 1;
		break;
	    }
	}

	if (offset < limit) {
	    result.append(ch, offset, limit - offset);
	}
	return result.toString();
    }

    
    protected void escapeCharacters(char[] ch, int off, int len) {
	int limit = off + len;
	int offset = off;

	if (limit > ch.length) {
	    limit = ch.length;
	}

	
	for (int i = off; i < limit; i++) {
	    final char current = ch[i];

	    switch (current) {
	    case '&':
		_buffer.append(ch, offset, i - offset).append(AMP);
		offset = i + 1;
		break;
	    case '<':
		_buffer.append(ch, offset, i - offset).append(LT);
		offset = i + 1;
		break;
	    case '>':
		_buffer.append(ch, offset, i - offset).append(GT);
		offset = i + 1;
		break;
	    default:
		if ((current >= '' && current < '') ||
		    (_is8859Encoded && current > ''))
		{
		    _buffer.append(ch, offset, i - offset)
			   .append(CHAR_ESC_START)
			   .append(Integer.toString((int)ch[i]))
			   .append(';');
		    offset = i + 1;
		}
	    }
	}
	
	if (offset < limit) {
	    _buffer.append(ch, offset, limit - offset);
	}
    }
}
"
org.apache.xalan.xsltc.runtime.TransletLoader,3,1,0,4,11,0,4,0,3,0.0,38,0.0,0,0.0,0.833333333,0,0,11.33333333,1,0.6667,0,"

package org.apache.xalan.xsltc.runtime;

import java.lang.Class;
import java.lang.ClassLoader;
import java.lang.Thread;

import java.net.*;	


final public class TransletLoader {
    
    ClassLoader _loader = null; 

    
    public TransletLoader() {
	
	ClassLoader loader = Thread.currentThread().getContextClassLoader();

	
	final String loaderName = loader.getClass().getName();
	if (loaderName.equals(""sun.misc.Launcher$ExtClassLoader"")) {
	    loader = ClassLoader.getSystemClassLoader();
	}
	_loader = loader;
    }

    
    public Class loadClass(String name) throws ClassNotFoundException {
	return(Class.forName(name, false, _loader));
    }

    
    public Class loadTranslet(String name) throws ClassNotFoundException {
	return(Class.forName(name, true, _loader));
    }
}
"
org.apache.xpath.ExpressionOwner,2,1,0,53,2,1,53,1,2,2.0,2,0.0,0,0.0,0.75,0,0,0.0,1,1.0,0,"package org.apache.xpath;


public interface ExpressionOwner
{
  
  public Expression getExpression();

  
  public void setExpression(Expression exp);


}

"
org.apache.xml.dtm.ref.sax2dtm.SAX2DTM,67,4,1,25,179,1873,3,23,57,0.911111111,2275,0.933333333,11,0.591194969,0.131313131,2,19,32.50746269,13,2.3284,1,"
package org.apache.xml.dtm.ref.sax2dtm;

import java.util.Hashtable;
import java.util.Vector;
import javax.xml.transform.Source;
import javax.xml.transform.SourceLocator;
import org.apache.xalan.transformer.XalanProperties;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;

import org.apache.xml.dtm.*;
import org.apache.xml.dtm.ref.*;
import org.apache.xml.utils.StringVector;
import org.apache.xml.utils.IntVector;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.SuballocatedIntVector;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.xml.sax.*;
import org.xml.sax.ext.*;


public class SAX2DTM extends DTMDefaultBaseIterators
        implements EntityResolver, DTDHandler, ContentHandler, ErrorHandler,
                   DeclHandler, LexicalHandler
{
  
  private static final boolean DEBUG = false;

  
  private IncrementalSAXSource m_incrementalSAXSource = null;

  
  
  protected FastStringBuffer m_chars = new FastStringBuffer(5, 13);

  
  protected SuballocatedIntVector m_data;

  
  transient protected IntStack m_parents = new IntStack();

  
  transient protected int m_previous = 0;

  
  transient protected java.util.Vector m_prefixMappings =
    new java.util.Vector();

  
  transient protected IntStack m_contextIndexes = new IntStack();

  
  transient private int m_textType = DTM.TEXT_NODE;

  
  transient private int m_coalescedTextType = DTM.TEXT_NODE;

  
  transient private Locator m_locator = null;

  
  transient private boolean m_insideDTD = false;

  
  protected DTMTreeWalker m_walker = new DTMTreeWalker();

  
  private DTMStringPool m_valuesOrPrefixes = new DTMStringPool();

  
  protected boolean m_endDocumentOccured = false;

  
  protected SuballocatedIntVector m_dataOrQName;

  
  protected Hashtable m_idAttributes = new Hashtable();

  
  static final String[] m_fixednames = { null, null,  
                                         null, ""#text"",  
                                         ""#cdata_section"", null,  
                                         null, null,  
                                         ""#comment"", ""#document"",  
                                         null, ""#document-fragment"",  
                                         null };  

  
  private Vector m_entities = null;

  
  private static final int ENTITY_FIELD_PUBLICID = 0;

  
  private static final int ENTITY_FIELD_SYSTEMID = 1;

  
  private static final int ENTITY_FIELD_NOTATIONNAME = 2;

  
  private static final int ENTITY_FIELD_NAME = 3;

  
  private static final int ENTITY_FIELDS_PER = 4;

  
  private int m_textPendingStart = -1;

  
  protected boolean m_useSourceLocationProperty = false;

   
  protected StringVector m_sourceSystemId;
   
  protected IntVector m_sourceLine;
   
  protected IntVector m_sourceColumn;
  
  
  public SAX2DTM(DTMManager mgr, Source source, int dtmIdentity,
                 DTMWSFilter whiteSpaceFilter,
                 XMLStringFactory xstringfactory,
                 boolean doIndexing)
  {

    super(mgr, source, dtmIdentity, whiteSpaceFilter, 
          xstringfactory, doIndexing);
          
    
    
    
    m_data = new SuballocatedIntVector(32, 1024);

    m_data.addElement(0);   

    m_dataOrQName = new SuballocatedIntVector(m_initialblocksize);
    
    
    
    
    
    m_useSourceLocationProperty=org.apache.xalan.processor.TransformerFactoryImpl.m_source_location;
    m_sourceSystemId = (m_useSourceLocationProperty) ? new StringVector() : null;
 	m_sourceLine = (m_useSourceLocationProperty) ?  new IntVector() : null;
    m_sourceColumn = (m_useSourceLocationProperty) ?  new IntVector() : null; 
  }

  
  protected int _dataOrQName(int identity)
  {

    if (identity < m_size)
      return m_dataOrQName.elementAt(identity);

    
    
    
    while (true)
    {
      boolean isMore = nextNode();

      if (!isMore)
        return NULL;
      else if (identity < m_size)
        return m_dataOrQName.elementAt(identity);
    }
  }

  
  public void clearCoRoutine()
  {
    clearCoRoutine(true);
  }

  
  public void clearCoRoutine(boolean callDoTerminate)
  {

    if (null != m_incrementalSAXSource)
    {
      if (callDoTerminate)
        m_incrementalSAXSource.deliverMoreNodes(false);

      m_incrementalSAXSource = null;
    }
  }

  
  public void setIncrementalSAXSource(IncrementalSAXSource incrementalSAXSource)
  {

    
    
    
    
    
    
    
    m_incrementalSAXSource = incrementalSAXSource;

    
    incrementalSAXSource.setContentHandler(this);
    incrementalSAXSource.setLexicalHandler(this);
    incrementalSAXSource.setDTDHandler(this);

    
    
    
    
  }

  
  public ContentHandler getContentHandler()
  {

    if (m_incrementalSAXSource instanceof IncrementalSAXSource_Filter)
      return (ContentHandler) m_incrementalSAXSource;
    else
      return this;
  }

  
  public LexicalHandler getLexicalHandler()
  {

    if (m_incrementalSAXSource instanceof IncrementalSAXSource_Filter)
      return (LexicalHandler) m_incrementalSAXSource;
    else
      return this;
  }

  
  public EntityResolver getEntityResolver()
  {
    return this;
  }

  
  public DTDHandler getDTDHandler()
  {
    return this;
  }

  
  public ErrorHandler getErrorHandler()
  {
    return this;
  }

  
  public DeclHandler getDeclHandler()
  {
    return this;
  }

  
  public boolean needsTwoThreads()
  {
    return null != m_incrementalSAXSource;
  }

  
  public void dispatchCharactersEvents(int nodeHandle, ContentHandler ch, 
                                       boolean normalize)
          throws SAXException
  {

    int identity = makeNodeIdentity(nodeHandle);
    int type = _type(identity);

    if (isTextType(type))
    {
      int dataIndex = m_dataOrQName.elementAt(identity);
      int offset = m_data.elementAt(dataIndex);
      int length = m_data.elementAt(dataIndex + 1);
      
      if(normalize)
        m_chars.sendNormalizedSAXcharacters(ch, offset, length);
      else
        m_chars.sendSAXcharacters(ch, offset, length);
    }
    else
    {
      int firstChild = _firstch(identity);

      if (DTM.NULL != firstChild)
      {
        int offset = -1;
        int length = 0;
        int level = _level(identity);

        identity = firstChild;

        while (DTM.NULL != identity && (_level(identity) > level))
        {
          type = _type(identity);

          if (isTextType(type))
          {
            int dataIndex = _dataOrQName(identity);

            if (-1 == offset)
            {
              offset = m_data.elementAt(dataIndex);
            }

            length += m_data.elementAt(dataIndex + 1);
          }

          identity = getNextNodeIdentity(identity);
        }

        if (length > 0)
        {
          if(normalize)
            m_chars.sendNormalizedSAXcharacters(ch, offset, length);
          else
            m_chars.sendSAXcharacters(ch, offset, length);
        }
      }
      else if(type != DTM.ELEMENT_NODE)
      {
        int dataIndex = _dataOrQName(identity);

        if (dataIndex < 0)
        {
          dataIndex = -dataIndex;
          dataIndex = m_data.elementAt(dataIndex + 1);
        }

        String str = m_valuesOrPrefixes.indexToString(dataIndex);

          if(normalize)
            FastStringBuffer.sendNormalizedSAXcharacters(str.toCharArray(), 
                                                         0, str.length(), ch);
          else
            ch.characters(str.toCharArray(), 0, str.length());
      }
    }
  }


  
  public String getNodeName(int nodeHandle)
  {

    int expandedTypeID = getExpandedTypeID(nodeHandle);
    
    int namespaceID = m_expandedNameTable.getNamespaceID(expandedTypeID);                     

    if (0 == namespaceID)
    {
      
      
      int type = getNodeType(nodeHandle);

      if (type == DTM.NAMESPACE_NODE)
      {
        if (null == m_expandedNameTable.getLocalName(expandedTypeID))
          return ""xmlns"";
        else
          return ""xmlns:"" + m_expandedNameTable.getLocalName(expandedTypeID);
      }
      else if (0 == m_expandedNameTable.getLocalNameID(expandedTypeID))
      {
        return m_fixednames[type];
      }
      else
        return m_expandedNameTable.getLocalName(expandedTypeID);
    }
    else
    {
      int qnameIndex = m_dataOrQName.elementAt(makeNodeIdentity(nodeHandle));

      if (qnameIndex < 0)
      {
        qnameIndex = -qnameIndex;
        qnameIndex = m_data.elementAt(qnameIndex);
      }

      return m_valuesOrPrefixes.indexToString(qnameIndex);
    }
  }

  
  public String getNodeNameX(int nodeHandle)
  {

    int expandedTypeID = getExpandedTypeID(nodeHandle);    
    int namespaceID = m_expandedNameTable.getNamespaceID(expandedTypeID);                      

    if (0 == namespaceID)
    {
      String name = m_expandedNameTable.getLocalName(expandedTypeID);

      if (name == null)
        return """";
      else
        return name;
    }
    else
    {
      int qnameIndex = m_dataOrQName.elementAt(makeNodeIdentity(nodeHandle));

      if (qnameIndex < 0)
      {
        qnameIndex = -qnameIndex;
        qnameIndex = m_data.elementAt(qnameIndex);
      }

      return m_valuesOrPrefixes.indexToString(qnameIndex);
    }
  }

  
  public boolean isAttributeSpecified(int attributeHandle)
  {

    
    return true;  
  }

  
  public String getDocumentTypeDeclarationSystemIdentifier()
  {

    
    error(XSLMessages.createMessage(XSLTErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return null;
  }

  
  protected int getNextNodeIdentity(int identity)
  {

    identity += 1;

    while (identity >= m_size)
    {
      if (null == m_incrementalSAXSource)
        return DTM.NULL;

      nextNode();
    }

    return identity;
  }

  
  public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {

    DTMTreeWalker treeWalker = m_walker;
    ContentHandler prevCH = treeWalker.getcontentHandler();

    if (null != prevCH)
    {
      treeWalker = new DTMTreeWalker();
    }

    treeWalker.setcontentHandler(ch);
    treeWalker.setDTM(this);

    try
    {
      treeWalker.traverse(nodeHandle);
    }
    finally
    {
      treeWalker.setcontentHandler(null);
    }
  }

  
  protected int getNumberOfNodes()
  {
    return m_size;
  }

  
  protected boolean nextNode()
  {

    if (null == m_incrementalSAXSource)
      return false;

    if (m_endDocumentOccured)
    {
      clearCoRoutine();

      return false;
    }

    Object gotMore = m_incrementalSAXSource.deliverMoreNodes(true);

    
    
    
    
    
    
    
    if (!(gotMore instanceof Boolean))
    {
      if(gotMore instanceof RuntimeException)
      {
        throw (RuntimeException)gotMore;
      }
      else if(gotMore instanceof Exception)
      {
        throw new WrappedRuntimeException((Exception)gotMore);
      }
      
      clearCoRoutine();

      return false;

      
    }

    if (gotMore != Boolean.TRUE)
    {

      
      clearCoRoutine();  

      
    }

    return true;
  }

  
  private final boolean isTextType(int type)
  {
    return (DTM.TEXT_NODE == type || DTM.CDATA_SECTION_NODE == type);
  }

















  
  protected int addNode(int type, int expandedTypeID,
                        int parentIndex, int previousSibling,
                        int dataOrPrefix, boolean canHaveFirstChild)
  {
    
    int nodeIndex = m_size++;

    
    if(m_dtmIdent.size() == (nodeIndex>>>DTMManager.IDENT_DTM_NODE_BITS))
    {
      try
      {
        if(m_mgr==null)
          throw new ClassCastException();
                                
                                
        DTMManagerDefault mgrD=(DTMManagerDefault)m_mgr;
        int id=mgrD.getFirstFreeDTMID();
        mgrD.addDTM(this,id,nodeIndex);
        m_dtmIdent.addElement(id<<DTMManager.IDENT_DTM_NODE_BITS);
      }
      catch(ClassCastException e)
      {
        
        
        
        error(XSLMessages.createMessage(XSLTErrorResources.ER_NO_DTMIDS_AVAIL, null));
      }
    }

    m_firstch.addElement(canHaveFirstChild ? NOTPROCESSED : DTM.NULL);
    m_nextsib.addElement(NOTPROCESSED);
    m_prevsib.addElement(previousSibling);
    m_parent.addElement(parentIndex);
    m_exptype.addElement(expandedTypeID);
    m_dataOrQName.addElement(dataOrPrefix);    

	if (m_useSourceLocationProperty && m_locator != null) 
	{
		m_sourceSystemId.addElement(m_locator.getSystemId());
		m_sourceLine.addElement(m_locator.getLineNumber());
		m_sourceColumn.addElement(m_locator.getColumnNumber());

		
		
		
		if (m_sourceSystemId.size() != m_size) 
		{
			System.err.println(""CODING ERROR in Source Location: "" + m_size
				+ "" != ""
				+ m_sourceSystemId.size());
			System.exit(1);
		}
	}


    if (DTM.NULL != previousSibling)
      m_nextsib.setElementAt(nodeIndex,previousSibling);

    
    

    
    switch(type)
    {
    case DTM.NAMESPACE_NODE:
      declareNamespaceInContext(parentIndex,nodeIndex);
      break;
    case DTM.ATTRIBUTE_NODE:
      break;
    default:
      if (DTM.NULL != parentIndex &&
	  NOTPROCESSED == m_firstch.elementAt(parentIndex))
        m_firstch.setElementAt(nodeIndex,parentIndex);
      break;
    }

    return nodeIndex;
  }

  
  public String getNodeValue(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int type = _type(identity);

    if (isTextType(type))
    {
      int dataIndex = _dataOrQName(identity);
      int offset = m_data.elementAt(dataIndex);
      int length = m_data.elementAt(dataIndex + 1);

      
      return m_chars.getString(offset, length);
    }
    else if (DTM.ELEMENT_NODE == type || DTM.DOCUMENT_FRAGMENT_NODE == type
             || DTM.DOCUMENT_NODE == type)
    {
      return null;
    }
    else
    {
      int dataIndex = _dataOrQName(identity);

      if (dataIndex < 0)
      {
        dataIndex = -dataIndex;
        dataIndex = m_data.elementAt(dataIndex + 1);
      }

      return m_valuesOrPrefixes.indexToString(dataIndex);
    }
  }

  
  public String getLocalName(int nodeHandle)
  {
    return m_expandedNameTable.getLocalName(_exptype(makeNodeIdentity(nodeHandle)));
  }

  
  public String getUnparsedEntityURI(String name)
  {

    String url = """";

    if (null == m_entities)
      return url;

    int n = m_entities.size();

    for (int i = 0; i < n; i += ENTITY_FIELDS_PER)
    {
      String ename = (String) m_entities.elementAt(i + ENTITY_FIELD_NAME);

      if (null != ename && ename.equals(name))
      {
        String nname = (String) m_entities.elementAt(i
                         + ENTITY_FIELD_NOTATIONNAME);

        if (null != nname)
        {

          
          
          
          
          
          
          
          
          
          url = (String) m_entities.elementAt(i + ENTITY_FIELD_SYSTEMID);

          if (null == url)
          {
            url = (String) m_entities.elementAt(i + ENTITY_FIELD_PUBLICID);
          }
        }

        break;
      }
    }

    return url;
  }

  
  public String getPrefix(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int type = _type(identity);

    if (DTM.ELEMENT_NODE == type)
    {
      int prefixIndex = _dataOrQName(identity);

      if (0 == prefixIndex)
        return """";
      else
      {
        String qname = m_valuesOrPrefixes.indexToString(prefixIndex);

        return getPrefix(qname, null);
      }
    }
    else if (DTM.ATTRIBUTE_NODE == type)
    {
      int prefixIndex = _dataOrQName(identity);

      if (prefixIndex < 0)
      {
        prefixIndex = m_data.elementAt(-prefixIndex);

        String qname = m_valuesOrPrefixes.indexToString(prefixIndex);

        return getPrefix(qname, null);
      }
    }

    return """";
  }

  
  public int getAttributeNode(int nodeHandle, String namespaceURI,
                              String name)
  {

    for (int attrH = getFirstAttribute(nodeHandle); DTM.NULL != attrH;
            attrH = getNextAttribute(attrH))
    {
      String attrNS = getNamespaceURI(attrH);
      String attrName = getLocalName(attrH);
      boolean nsMatch = namespaceURI == attrNS
                        || (namespaceURI != null
                            && namespaceURI.equals(attrNS));

      if (nsMatch && name.equals(attrName))
        return attrH;
    }

    return DTM.NULL;
  }

  
  public String getDocumentTypeDeclarationPublicIdentifier()
  {

    
    error(XSLMessages.createMessage(XSLTErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return null;
  }

  
  public String getNamespaceURI(int nodeHandle)
  {

    return m_expandedNameTable.getNamespace(_exptype(makeNodeIdentity(nodeHandle)));
  }

  
  public XMLString getStringValue(int nodeHandle)
  {
    int identity = makeNodeIdentity(nodeHandle);
    int type;
    if(identity==DTM.NULL) 
      type = DTM.NULL;
    else
      type= _type(identity);

    if (isTextType(type))
    {
      int dataIndex = _dataOrQName(identity);
      int offset = m_data.elementAt(dataIndex);
      int length = m_data.elementAt(dataIndex + 1);

      return m_xstrf.newstr(m_chars, offset, length);
    }
    else
    {
      int firstChild = _firstch(identity);

      if (DTM.NULL != firstChild)
      {
        int offset = -1;
        int length = 0;
        int level = _level(identity);

        identity = firstChild;

        while (DTM.NULL != identity && (_level(identity) > level))
        {
          type = _type(identity);

          if (isTextType(type))
          {
            int dataIndex = _dataOrQName(identity);

            if (-1 == offset)
            {
              offset = m_data.elementAt(dataIndex);
            }

            length += m_data.elementAt(dataIndex + 1);
          }

          identity = getNextNodeIdentity(identity);
        }

        if (length > 0)
        {
          return m_xstrf.newstr(m_chars, offset, length);
        }
      }
      else if(type != DTM.ELEMENT_NODE)
      {
        int dataIndex = _dataOrQName(identity);

        if (dataIndex < 0)
        {
          dataIndex = -dataIndex;
          dataIndex = m_data.elementAt(dataIndex + 1);
        }
        return m_xstrf.newstr(m_valuesOrPrefixes.indexToString(dataIndex));
      }
    }

    return m_xstrf.emptystr();
  }

  
  public int getElementById(String elementId)
  {

    Integer intObj;
    boolean isMore = true;

    do
    {
      intObj = (Integer) m_idAttributes.get(elementId);

      if (null != intObj)
        return makeNodeHandle(intObj.intValue());

      if (!isMore || m_endDocumentOccured)
        break;

      isMore = nextNode();
    }
    while (null == intObj);

    return DTM.NULL;
  }

  
  private String getPrefix(String qname, String uri)
  {

    String prefix;
    int uriIndex = -1;

    if (null != uri && uri.length() > 0)
    {

      do
      {
        uriIndex = m_prefixMappings.indexOf(uri, ++uriIndex);
      } while ( (uriIndex & 0x01) == 0);

      if (uriIndex >= 0)
      {
        prefix = (String) m_prefixMappings.elementAt(uriIndex - 1);
      }
      else if (null != qname)
      {
        int indexOfNSSep = qname.indexOf(':');

        if (qname.equals(""xmlns""))
          prefix = """";
        else if (qname.startsWith(""xmlns:""))
          prefix = qname.substring(indexOfNSSep + 1);
        else
          prefix = (indexOfNSSep > 0)
                   ? qname.substring(0, indexOfNSSep) : null;
      }
      else
      {
        prefix = null;  
      }
    }
    else if (null != qname)
    {
      int indexOfNSSep = qname.indexOf(':');

      if (qname.equals(""xmlns""))
        prefix = """";
      else if (qname.startsWith(""xmlns:""))
        prefix = qname.substring(indexOfNSSep + 1);
      else
        prefix = (indexOfNSSep > 0) ? qname.substring(0, indexOfNSSep) : null;
    }
    else
    {
      prefix = null;
    }

    return prefix;
  }

  
  public void setIDAttribute(String id, int elem)
  {
    m_idAttributes.put(id, new Integer(elem));
  }

  
  protected void charactersFlush()
  {

    if (m_textPendingStart >= 0)  
    {
      int length = m_chars.size() - m_textPendingStart;
      boolean doStrip = false;

      if (getShouldStripWhitespace())
      {
        doStrip = m_chars.isWhitespace(m_textPendingStart, length);
      }

      if (doStrip)
        m_chars.setLength(m_textPendingStart);  
      else
      {
        int exName = m_expandedNameTable.getExpandedTypeID(DTM.TEXT_NODE);
        int dataIndex = m_data.size();

        m_previous = addNode(m_coalescedTextType, exName,
                             m_parents.peek(), m_previous, dataIndex, false);

        m_data.addElement(m_textPendingStart);
        m_data.addElement(length);
      }

      
      m_textPendingStart = -1;
      m_textType = m_coalescedTextType = DTM.TEXT_NODE;
    }
  }

  
  
  

  
  public InputSource resolveEntity(String publicId, String systemId)
          throws SAXException
  {
    return null;
  }

  
  
  

  
  public void notationDecl(String name, String publicId, String systemId)
          throws SAXException
  {

    
  }

  
  public void unparsedEntityDecl(
          String name, String publicId, String systemId, String notationName)
            throws SAXException
  {

    if (null == m_entities)
    {
      m_entities = new Vector();
    }

    try
    {
      systemId = SystemIDResolver.getAbsoluteURI(systemId,
                                                 getDocumentBaseURI());
    }
    catch (Exception e)
    {
      throw new org.xml.sax.SAXException(e);
    }

    
    m_entities.addElement(publicId);

    
    m_entities.addElement(systemId);

    
    m_entities.addElement(notationName);

    
    m_entities.addElement(name);
  }

  
  
  

  
  public void setDocumentLocator(Locator locator)
  {
    m_locator = locator;
  }

  
  public void startDocument() throws SAXException
  {
    if (DEBUG)
      System.out.println(""startDocument"");

		
    int doc = addNode(DTM.DOCUMENT_NODE,
                      m_expandedNameTable.getExpandedTypeID(DTM.DOCUMENT_NODE),
                      DTM.NULL, DTM.NULL, 0, true);
		
    m_parents.push(doc);
    m_previous = DTM.NULL;
				
    m_contextIndexes.push(m_prefixMappings.size());  
  }

  
  public void endDocument() throws SAXException
  {
    if (DEBUG)
      System.out.println(""endDocument"");

		charactersFlush();

    m_nextsib.setElementAt(NULL,0);

    if (m_firstch.elementAt(0) == NOTPROCESSED)
      m_firstch.setElementAt(NULL,0);

    if (DTM.NULL != m_previous)
      m_nextsib.setElementAt(DTM.NULL,m_previous);

    m_parents = null;
    m_prefixMappings = null;
    m_contextIndexes = null;

    m_endDocumentOccured = true;
  }

  
  public void startPrefixMapping(String prefix, String uri)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""startPrefixMapping: prefix: "" + prefix + "", uri: ""
                         + uri);

    if(null == prefix)
      prefix = """";
    m_prefixMappings.addElement(prefix);  
    m_prefixMappings.addElement(uri);  
  }

  
  public void endPrefixMapping(String prefix) throws SAXException
  {
    if (DEBUG)
      System.out.println(""endPrefixMapping: prefix: "" + prefix);

    if(null == prefix)
      prefix = """";

    int index = m_contextIndexes.peek() - 1;

    do
    {
      index = m_prefixMappings.indexOf(prefix, ++index);
    } while ( (index >= 0) && ((index & 0x01) == 0x01) );


    if (index > -1)
    {
      m_prefixMappings.setElementAt(""%@$#^@#"", index);
      m_prefixMappings.setElementAt(""%@$#^@#"", index + 1);
    }

    
  }

  
  protected boolean declAlreadyDeclared(String prefix)
  {

    int startDecls = m_contextIndexes.peek();
    java.util.Vector prefixMappings = m_prefixMappings;
    int nDecls = prefixMappings.size();

    for (int i = startDecls; i < nDecls; i += 2)
    {
      String prefixDecl = (String) prefixMappings.elementAt(i);

      if (prefixDecl == null)
        continue;

      if (prefixDecl.equals(prefix))
        return true;
    }

    return false;
  }
	
	boolean m_pastFirstElement=false;

  
  public void startElement(
          String uri, String localName, String qName, Attributes attributes)
            throws SAXException
  {
   if (DEBUG)
	 {
      System.out.println(""startElement: uri: "" + uri + "", localname: ""
												 + localName + "", qname: ""+qName+"", atts: "" + attributes);

			boolean DEBUG_ATTRS=true;
			if(DEBUG_ATTRS & attributes!=null)
			{
				int n = attributes.getLength();
				if(n==0)
					System.out.println(""	empty attribute list"");
				else for (int i = 0; i < n; i++)
					System.out.println(""	 attr: uri: "" + attributes.getURI(i) +
														 "", localname: "" + attributes.getLocalName(i) +
														 "", qname: "" + attributes.getQName(i) +
														 "", type: "" + attributes.getType(i) +
														 "", value: "" + attributes.getValue(i)
														 );
			}
	 }
		
    charactersFlush();

    int exName = m_expandedNameTable.getExpandedTypeID(uri, localName, DTM.ELEMENT_NODE);
    String prefix = getPrefix(qName, uri);
    int prefixIndex = (null != prefix)
                      ? m_valuesOrPrefixes.stringToIndex(qName) : 0;
    int elemNode = addNode(DTM.ELEMENT_NODE, exName,
                           m_parents.peek(), m_previous, prefixIndex, true);

    if(m_indexing)
      indexNode(exName, elemNode);
    
    m_parents.push(elemNode);

    int startDecls = m_contextIndexes.peek();
    int nDecls = m_prefixMappings.size();
    int prev = DTM.NULL;

    if(!m_pastFirstElement)
    {
      
      prefix=""xml"";
      String declURL = ""http:
      exName = m_expandedNameTable.getExpandedTypeID(null, prefix, DTM.NAMESPACE_NODE);
      int val = m_valuesOrPrefixes.stringToIndex(declURL);
      prev = addNode(DTM.NAMESPACE_NODE, exName, elemNode,
                     prev, val, false);
      m_pastFirstElement=true;
    }
                        
    for (int i = startDecls; i < nDecls; i += 2)
    {
      prefix = (String) m_prefixMappings.elementAt(i);

      if (prefix == null)
        continue;

      String declURL = (String) m_prefixMappings.elementAt(i + 1);

      exName = m_expandedNameTable.getExpandedTypeID(null, prefix, DTM.NAMESPACE_NODE);

      int val = m_valuesOrPrefixes.stringToIndex(declURL);

      prev = addNode(DTM.NAMESPACE_NODE, exName, elemNode,
                     prev, val, false);
    }

    int n = attributes.getLength();

    for (int i = 0; i < n; i++)
    {
      String attrUri = attributes.getURI(i);
      String attrQName = attributes.getQName(i);
      String valString = attributes.getValue(i);

      prefix = getPrefix(attrQName, attrUri);

      int nodeType;

      if ((null != attrQName)
              && (attrQName.equals(""xmlns"")
                  || attrQName.startsWith(""xmlns:"")))
      {
        if (declAlreadyDeclared(prefix))
          continue;  

        nodeType = DTM.NAMESPACE_NODE;
      }
      else
      {
        nodeType = DTM.ATTRIBUTE_NODE;

        if (attributes.getType(i).equalsIgnoreCase(""ID""))
          setIDAttribute(valString, elemNode);
      }
      
      
      
      if(null == valString)
        valString = """";

      int val = m_valuesOrPrefixes.stringToIndex(valString);
      String attrLocalName = attributes.getLocalName(i);

      if (null != prefix)
      {
        
        prefixIndex = m_valuesOrPrefixes.stringToIndex(attrQName);

        int dataIndex = m_data.size();

        m_data.addElement(prefixIndex);
        m_data.addElement(val);

        val = -dataIndex;
      }

      exName = m_expandedNameTable.getExpandedTypeID(attrUri, attrLocalName, nodeType);
      prev = addNode(nodeType, exName, elemNode, prev, val,
                     false);
    }

    if (DTM.NULL != prev)
      m_nextsib.setElementAt(DTM.NULL,prev);

    if (null != m_wsfilter)
    {
      short wsv = m_wsfilter.getShouldStripSpace(makeNodeHandle(elemNode), this);
      boolean shouldStrip = (DTMWSFilter.INHERIT == wsv)
                            ? getShouldStripWhitespace()
                            : (DTMWSFilter.STRIP == wsv);

      pushShouldStripWhitespace(shouldStrip);
    }

    m_previous = DTM.NULL;

    m_contextIndexes.push(m_prefixMappings.size());  
  }

  
  public void endElement(String uri, String localName, String qName)
          throws SAXException
  {
   if (DEBUG)
      System.out.println(""endElement: uri: "" + uri + "", localname: ""
												 + localName + "", qname: ""+qName);

    charactersFlush();

    
    
    m_prefixMappings.setSize(m_contextIndexes.pop());

    
    m_prefixMappings.setSize(m_contextIndexes.pop());
    m_contextIndexes.push(m_prefixMappings.size());  

    int lastNode = m_previous;

    m_previous = m_parents.pop();

    if (NOTPROCESSED == m_firstch.elementAt(m_previous))
      m_firstch.setElementAt(DTM.NULL,m_previous);
    else if (DTM.NULL != lastNode)
      m_nextsib.setElementAt(DTM.NULL,lastNode);

    popShouldStripWhitespace();
  }

  
  public void characters(char ch[], int start, int length) throws SAXException
  {
    if (m_textPendingStart == -1)  
    {
      m_textPendingStart = m_chars.size();
      m_coalescedTextType = m_textType;
    }

    m_chars.append(ch, start, length);

    
    
    
    
    if (m_textType == DTM.TEXT_NODE)
      m_coalescedTextType = DTM.TEXT_NODE;
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws SAXException
  {
    
    
    characters(ch, start, length);
  }

  
  public void processingInstruction(String target, String data)
          throws SAXException
  {
    if (DEBUG)
		 System.out.println(""processingInstruction: target: "" + target +"", data: ""+data);

    charactersFlush();

    int exName = m_expandedNameTable.getExpandedTypeID(null, target,
                                         DTM.PROCESSING_INSTRUCTION_NODE);
    int dataIndex = m_valuesOrPrefixes.stringToIndex(data);

    m_previous = addNode(DTM.PROCESSING_INSTRUCTION_NODE, exName,
                         m_parents.peek(), m_previous,
                         dataIndex, false);
  }

  
  public void skippedEntity(String name) throws SAXException
  {

    
    
  }

  
  
  

  
  public void warning(SAXParseException e) throws SAXException
  {

    
    System.err.println(e.getMessage());
  }

  
  public void error(SAXParseException e) throws SAXException
  {
    throw e;
  }

  
  public void fatalError(SAXParseException e) throws SAXException
  {
    throw e;
  }

  
  
  

  
  public void elementDecl(String name, String model) throws SAXException
  {

    
  }

  
  public void attributeDecl(
          String eName, String aName, String type, String valueDefault, String value)
            throws SAXException
  {

    
  }

  
  public void internalEntityDecl(String name, String value)
          throws SAXException
  {

    
  }

  
  public void externalEntityDecl(
          String name, String publicId, String systemId) throws SAXException
  {

    
  }

  
  
  

  
  public void startDTD(String name, String publicId, String systemId)
          throws SAXException
  {

    m_insideDTD = true;
  }

  
  public void endDTD() throws SAXException
  {

    m_insideDTD = false;
  }

  
  public void startEntity(String name) throws SAXException
  {

    
  }

  
  public void endEntity(String name) throws SAXException
  {

    
  }

  
  public void startCDATA() throws SAXException
  {
    m_textType = DTM.CDATA_SECTION_NODE;
  }

  
  public void endCDATA() throws SAXException
  {
    m_textType = DTM.TEXT_NODE;
  }

  
  public void comment(char ch[], int start, int length) throws SAXException
  {

    if (m_insideDTD)      
      return;

    charactersFlush();

    int exName = m_expandedNameTable.getExpandedTypeID(DTM.COMMENT_NODE);

    
    
    int dataIndex = m_valuesOrPrefixes.stringToIndex(new String(ch, start,
                      length));

    m_previous = addNode(DTM.COMMENT_NODE, exName, 
                         m_parents.peek(), m_previous, dataIndex, false);
  }

  
  public void setProperty(String property, Object value)
  {
  }

  
  public SourceLocator getSourceLocatorFor(int node)
  {
    if (m_useSourceLocationProperty)
    {
      node = makeNodeIdentity(node);
      
      return new NodeLocator(null,
                             m_sourceSystemId.elementAt(node),
                             m_sourceLine.elementAt(node),
                             m_sourceColumn.elementAt(node));
    }
    else if(m_locator!=null)
    {
    	return new NodeLocator(null,m_locator.getSystemId(),-1,-1);
    }
    return null;
  }
}
"
org.apache.xpath.operations.Div,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.XPathContext;


public class Div extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() / right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (m_left.num(xctxt) / m_right.num(xctxt));
  }

}
"
org.apache.xalan.xsltc.compiler.Sort,19,3,0,64,101,119,2,64,13,0.85,1465,0.8,4,0.756756757,0.23923445,1,3,75.57894737,9,3.0526,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.ArrayList;
import java.util.StringTokenizer;
import java.util.NoSuchElementException;
import java.text.Collator;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;

import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Field;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.generic.*;
import org.apache.bcel.Constants;

import org.apache.xalan.xsltc.dom.*;
import org.apache.xalan.xsltc.compiler.util.*;


final class Sort extends Instruction implements Closure {

    private Expression     _select;
    private AttributeValue _order;
    private AttributeValue _caseOrder;
    private AttributeValue _dataType;

    private String         _data = null;
    public  String         _lang;
    public  String         _country;

    private String _className = null;
    private ArrayList _closureVars = null;
    private boolean _needsSortRecordFactory = false;

    

    
    public boolean inInnerClass() {
	return (_className != null);
    }

    
    public Closure getParentClosure() {
	return null;
    }

    
    public String getInnerClassName() {
	return _className;
    }

    
    public void addVariable(VariableRefBase variableRef) {
	if (_closureVars == null) {
	    _closureVars = new ArrayList();
	}

	
	if (!_closureVars.contains(variableRef)) {
	    _closureVars.add(variableRef);
	    _needsSortRecordFactory = true;
	}
    }

    

    private void setInnerClassName(String className) {
	_className = className;
    }

    
    public void parseContents(Parser parser) {

	final SyntaxTreeNode parent = getParent();
	if (!(parent instanceof ApplyTemplates) &&
	    !(parent instanceof ForEach)) {
	    reportError(this, parser, ErrorMsg.STRAY_SORT_ERR, null);
	    return;
	}

	
	_select = parser.parseExpression(this, ""select"", ""string(.)"");

	
	String val = getAttribute(""order"");
	if (val.length() == 0) val = ""ascending"";
	_order = AttributeValue.create(this, val, parser);

	
	val = getAttribute(""case-order"");
	if (val.length() == 0) val = ""upper-first"";
	_caseOrder = AttributeValue.create(this, val, parser);

	
	val = getAttribute(""data-type"");
	if (val.length() == 0) {
	    try {
		final Type type = _select.typeCheck(parser.getSymbolTable());
		if (type instanceof IntType)
		    val = ""number"";
		else
		    val = ""text"";
	    }
	    catch (TypeCheckError e) {
		val = ""text"";
	    }
	}
	_dataType = AttributeValue.create(this, val, parser);

	
	if ((val = getAttribute(""lang"")) != null) {
	    try {
		StringTokenizer st = new StringTokenizer(val,""-"",false);
		_lang = st.nextToken();
		_country = st.nextToken();
	    }
	    catch (NoSuchElementException e) { 
	    }
	}
    }
    
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tselect = _select.typeCheck(stable);

	
	
	if (!(tselect instanceof StringType)) {
	    _select = new CastExpr(_select, Type.String);
	}

	_order.typeCheck(stable);
	_caseOrder.typeCheck(stable);
	_dataType.typeCheck(stable);
	return Type.Void;
    }

    
    public void translateSortType(ClassGenerator classGen,
				  MethodGenerator methodGen) {
	_dataType.translate(classGen, methodGen);
    }
    
    public void translateSortOrder(ClassGenerator classGen,
				   MethodGenerator methodGen) {
	_order.translate(classGen, methodGen);
    }
    
    
    public void translateSelect(ClassGenerator classGen,
				MethodGenerator methodGen) {
	_select.translate(classGen,methodGen);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }

    
    public static void translateSortIterator(ClassGenerator classGen,
				      MethodGenerator methodGen,
				      Expression nodeSet,
				      Vector sortObjects) 
    {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int init = cpg.addMethodref(SORT_ITERATOR, ""<init>"",
					  ""(""
					  + NODE_ITERATOR_SIG
					  + NODE_SORT_FACTORY_SIG
					  + "")V"");	

	il.append(new NEW(cpg.addClass(SORT_ITERATOR)));
	il.append(DUP);

	
	if (nodeSet == null) {	
	    final int children = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getAxisIterator"",
							   ""(I)""+
							   NODE_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(new PUSH(cpg, Axis.CHILD));
	    il.append(new INVOKEINTERFACE(children, 2));
	}
	else {
	    nodeSet.translate(classGen, methodGen);
	}
	
	
	
	compileSortRecordFactory(sortObjects, classGen, methodGen);
	il.append(new INVOKESPECIAL(init));
    }


    
    public static void compileSortRecordFactory(Vector sortObjects,
	ClassGenerator classGen, MethodGenerator methodGen) 
    {
	String sortRecordClass = 
	    compileSortRecord(sortObjects, classGen, methodGen);

	boolean needsSortRecordFactory = false;
	final int nsorts = sortObjects.size();
	for (int i = 0; i < nsorts; i++) {
	    final Sort sort = (Sort) sortObjects.elementAt(i);
	    needsSortRecordFactory |= sort._needsSortRecordFactory;
	}

	String sortRecordFactoryClass = NODE_SORT_FACTORY;
	if (needsSortRecordFactory) {
	    sortRecordFactoryClass = 
		compileSortRecordFactory(sortObjects, classGen, methodGen, 
		    sortRecordClass);
	}

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	
	il.append(new NEW(cpg.addClass(sortRecordFactoryClass)));
	il.append(DUP);
	il.append(methodGen.loadDOM());
	il.append(new PUSH(cpg, sortRecordClass));
	il.append(classGen.loadTranslet());

	
	il.append(new PUSH(cpg, nsorts));
	il.append(new ANEWARRAY(cpg.addClass(STRING)));
	for (int level = 0; level < nsorts; level++) {
	    final Sort sort = (Sort)sortObjects.elementAt(level);
	    il.append(DUP);
	    il.append(new PUSH(cpg, level));
	    sort.translateSortOrder(classGen, methodGen);
	    il.append(AASTORE);
	}

	il.append(new PUSH(cpg, nsorts));
	il.append(new ANEWARRAY(cpg.addClass(STRING)));
	for (int level = 0; level < nsorts; level++) {
	    final Sort sort = (Sort)sortObjects.elementAt(level);
	    il.append(DUP);
	    il.append(new PUSH(cpg, level));
	    sort.translateSortType(classGen, methodGen);
	    il.append(AASTORE);
	}

	il.append(new INVOKESPECIAL(
	    cpg.addMethodref(sortRecordFactoryClass, ""<init>"", 
		""("" + DOM_INTF_SIG 
		    + STRING_SIG
		    + TRANSLET_INTF_SIG
		    + ""["" + STRING_SIG
		    + ""["" + STRING_SIG + "")V"")));

	
	final ArrayList dups = new ArrayList();

	for (int j = 0; j < nsorts; j++) {
	    final Sort sort = (Sort) sortObjects.get(j);
	    final int length = (sort._closureVars == null) ? 0 : 
		sort._closureVars.size();

	    for (int i = 0; i < length; i++) {
		VariableRefBase varRef = (VariableRefBase) sort._closureVars.get(i);

		
		if (dups.contains(varRef)) continue;

		final VariableBase var = varRef.getVariable();

		
		il.append(DUP);
		il.append(var.loadInstruction());
		il.append(new PUTFIELD(
			cpg.addFieldref(sortRecordFactoryClass, var.getVariable(), 
			    var.getType().toSignature())));
		dups.add(varRef);
	    }
	}
    }

    public static String compileSortRecordFactory(Vector sortObjects,
	ClassGenerator classGen, MethodGenerator methodGen, 
	String sortRecordClass)
    {
	final XSLTC  xsltc = ((Sort)sortObjects.firstElement()).getXSLTC();
	final String className = xsltc.getHelperClassName();

	final NodeSortRecordFactGenerator sortRecordFactory =
	    new NodeSortRecordFactGenerator(className,
					NODE_SORT_FACTORY,
					className + "".java"",
					ACC_PUBLIC | ACC_SUPER | ACC_FINAL,
					new String[] {},
					classGen.getStylesheet());

	ConstantPoolGen cpg = sortRecordFactory.getConstantPool();

	
	final int nsorts = sortObjects.size();
	final ArrayList dups = new ArrayList();

	for (int j = 0; j < nsorts; j++) {
	    final Sort sort = (Sort) sortObjects.get(j);
	    final int length = (sort._closureVars == null) ? 0 : 
		sort._closureVars.size();

	    for (int i = 0; i < length; i++) {
		final VariableRef varRef = (VariableRef) sort._closureVars.get(i);

		
		if (dups.contains(varRef)) continue;

		final VariableBase var = varRef.getVariable();
		sortRecordFactory.addField(new Field(ACC_PUBLIC, 
					   cpg.addUtf8(var.getVariable()),
					   cpg.addUtf8(var.getType().toSignature()),
					   null, cpg.getConstantPool()));
		dups.add(varRef);
	    }
	}

	
	final org.apache.bcel.generic.Type[] argTypes = 
	    new org.apache.bcel.generic.Type[5];
	argTypes[0] = Util.getJCRefType(DOM_INTF_SIG);
	argTypes[1] = Util.getJCRefType(STRING_SIG);
	argTypes[2] = Util.getJCRefType(TRANSLET_INTF_SIG);
	argTypes[3] = Util.getJCRefType(""["" + STRING_SIG);
	argTypes[4] = Util.getJCRefType(""["" + STRING_SIG);

	final String[] argNames = new String[5];
	argNames[0] = DOCUMENT_PNAME;
	argNames[1] = ""className"";
	argNames[2] = TRANSLET_PNAME;
	argNames[3] = ""order"";
	argNames[4] = ""type"";

	InstructionList il = new InstructionList();
	final MethodGenerator constructor =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID, 
				argTypes, argNames, ""<init>"", 
				className, il, cpg);

	
	il.append(ALOAD_0);
	il.append(ALOAD_1);
	il.append(ALOAD_2);
	il.append(new ALOAD(3));
	il.append(new ALOAD(4));
	il.append(new ALOAD(5));
	il.append(new INVOKESPECIAL(cpg.addMethodref(NODE_SORT_FACTORY,
	    ""<init>"", 
	    ""("" + DOM_INTF_SIG 
		+ STRING_SIG 
		+ TRANSLET_INTF_SIG 
		+ ""["" + STRING_SIG
		+ ""["" + STRING_SIG + "")V"")));
	il.append(RETURN);

	
	il = new InstructionList(); 
	final MethodGenerator makeNodeSortRecord =
	    new MethodGenerator(ACC_PUBLIC,
		Util.getJCRefType(NODE_SORT_RECORD_SIG), 
		new org.apache.bcel.generic.Type[] { 
		    org.apache.bcel.generic.Type.INT,
		    org.apache.bcel.generic.Type.INT },
		new String[] { ""node"", ""last"" }, ""makeNodeSortRecord"",
		className, il, cpg);

	il.append(ALOAD_0);
	il.append(ILOAD_1);
	il.append(ILOAD_2);
	il.append(new INVOKESPECIAL(cpg.addMethodref(NODE_SORT_FACTORY,
	    ""makeNodeSortRecord"", ""(II)"" + NODE_SORT_RECORD_SIG)));
	il.append(DUP);
	il.append(new CHECKCAST(cpg.addClass(sortRecordClass)));

	
	final int ndups = dups.size();
	for (int i = 0; i < ndups; i++) {
	    final VariableRef varRef = (VariableRef) dups.get(i);
	    final VariableBase var = varRef.getVariable();
	    final Type varType = var.getType();
	    
	    il.append(DUP);

	    
	    il.append(ALOAD_0);
	    il.append(new GETFIELD(
		cpg.addFieldref(className,
		    var.getVariable(), varType.toSignature())));

	    
	    il.append(new PUTFIELD(
		cpg.addFieldref(sortRecordClass,
		    var.getVariable(), varType.toSignature())));
	}
	il.append(POP);
	il.append(ARETURN);

	constructor.setMaxLocals();
	constructor.setMaxStack();
	sortRecordFactory.addMethod(constructor.getMethod());
	makeNodeSortRecord.setMaxLocals();
	makeNodeSortRecord.setMaxStack();
	sortRecordFactory.addMethod(makeNodeSortRecord.getMethod());
	xsltc.dumpClass(sortRecordFactory.getJavaClass());

	return className;
    }

    
    private static String compileSortRecord(Vector sortObjects,
					    ClassGenerator classGen,
					    MethodGenerator methodGen) {
	final XSLTC  xsltc = ((Sort)sortObjects.firstElement()).getXSLTC();
	final String className = xsltc.getHelperClassName();

	
	final NodeSortRecordGenerator sortRecord =
	    new NodeSortRecordGenerator(className,
					NODE_SORT_RECORD,
					""sort$0.java"",
					ACC_PUBLIC | ACC_SUPER | ACC_FINAL,
					new String[] {},
					classGen.getStylesheet());
	
	final ConstantPoolGen cpg = sortRecord.getConstantPool();	

	
	final int nsorts = sortObjects.size();
	final ArrayList dups = new ArrayList();

	for (int j = 0; j < nsorts; j++) {
	    final Sort sort = (Sort) sortObjects.get(j);

	    
	    sort.setInnerClassName(className);	

	    final int length = (sort._closureVars == null) ? 0 : 
		sort._closureVars.size();
	    for (int i = 0; i < length; i++) {
		final VariableRef varRef = (VariableRef) sort._closureVars.get(i);

		
		if (dups.contains(varRef)) continue;

		final VariableBase var = varRef.getVariable();
		sortRecord.addField(new Field(ACC_PUBLIC, 
				    cpg.addUtf8(var.getVariable()),
				    cpg.addUtf8(var.getType().toSignature()),
				    null, cpg.getConstantPool()));
		dups.add(varRef);
	    }
	}

	Method clinit = compileClassInit(sortObjects, sortRecord,
					 cpg, className);
	Method extract = compileExtract(sortObjects, sortRecord,
					cpg, className);
	sortRecord.addMethod(clinit);
	sortRecord.addEmptyConstructor(ACC_PUBLIC);
	sortRecord.addMethod(extract);

	
	for (int i = 0; i < sortObjects.size(); i++) {
	    if (((Sort)(sortObjects.elementAt(i)))._lang != null) {
		sortRecord.addMethod(compileGetCollator(sortObjects,
							sortRecord,
							cpg,
							className));
		i = sortObjects.size();
	    }
	}
	
	xsltc.dumpClass(sortRecord.getJavaClass());
	return className;
    }

    
    private static Method compileClassInit(Vector sortObjects,
					   NodeSortRecordGenerator sortRecord,
					   ConstantPoolGen cpg,
					   String className) {
	
	final InstructionList il = new InstructionList();
	final CompareGenerator classInit =
	    new CompareGenerator(ACC_PUBLIC | ACC_STATIC,
				 org.apache.bcel.generic.Type.VOID, 
				 new org.apache.bcel.generic.Type[] { },
				 new String[] { },
				 ""<clinit>"", className, il, cpg);

	final int initLocale =  cpg.addMethodref(""java/util/Locale"",
						 ""<init>"",
						 ""(Ljava/lang/String;""+
						 ""Ljava/lang/String;)V"");
	
	final int getCollator = cpg.addMethodref(COLLATOR_CLASS,
						 ""getInstance"",
						 ""(Ljava/util/Locale;)""+
						 COLLATOR_SIG);

	final int setStrength = cpg.addMethodref(COLLATOR_CLASS,
						 ""setStrength"", ""(I)V"");

	final int levels = sortObjects.size();

	

	
	String language = null;
	String country = null;
	Sort sort = (Sort)sortObjects.elementAt(0);

	for (int level = 0; level < levels; level++) {
	    if (language == null && sort._lang != null)
		language = sort._lang;
	    if (country == null && sort._country != null)
		country = sort._country;
	}

	
	final int collator =
	    cpg.addFieldref(className, ""_collator"", COLLATOR_SIG);

	if (language != null) {
	    
	    il.append(new NEW(cpg.addClass(""java/util/Locale"")));
	    il.append(DUP);
	    il.append(new PUSH(cpg, language));
	    il.append(new PUSH(cpg, (country != null ? country : EMPTYSTRING)));
	    il.append(new INVOKESPECIAL(initLocale));
	    
	    
	    il.append(new INVOKESTATIC(getCollator));
	    il.append(new PUTSTATIC(collator));
	}

	il.append(new GETSTATIC(collator));
	il.append(new ICONST(Collator.TERTIARY));
	il.append(new INVOKEVIRTUAL(setStrength));

	il.append(RETURN);

	classInit.stripAttributes(true);
	classInit.setMaxLocals();
	classInit.setMaxStack();
	classInit.removeNOPs();

	return classInit.getMethod();
    }


    
    private static Method compileExtract(Vector sortObjects,
					 NodeSortRecordGenerator sortRecord,
					 ConstantPoolGen cpg,
					 String className) {
	final InstructionList il = new InstructionList();
	
	
	final CompareGenerator extractMethod =
	    new CompareGenerator(ACC_PUBLIC | ACC_FINAL,
				 org.apache.bcel.generic.Type.STRING, 
				 new org.apache.bcel.generic.Type[] {
		                     Util.getJCRefType(DOM_INTF_SIG),
				     org.apache.bcel.generic.Type.INT,
				     org.apache.bcel.generic.Type.INT,
				     Util.getJCRefType(TRANSLET_SIG),
				     org.apache.bcel.generic.Type.INT
				 },
				 new String[] { ""dom"",
						""current"",
						""level"",
						""translet"",
						""last""
				 },
				 ""extractValueFromDOM"", className, il, cpg);

	
	final int levels = sortObjects.size();
	final int match[] = new int[levels];
	final InstructionHandle target[] = new InstructionHandle[levels];
	InstructionHandle tblswitch = null;

	
	if (levels > 1) {
	    
	    il.append(new ILOAD(extractMethod.getLocalIndex(""level"")));
	    
	    tblswitch = il.append(new NOP());
	}

	
	for (int level = 0; level < levels; level++) {
	    match[level] = level;
	    final Sort sort = (Sort)sortObjects.elementAt(level);
	    target[level] = il.append(NOP);
	    sort.translateSelect(sortRecord, extractMethod);
	    il.append(ARETURN);
	}
	
	
	if (levels > 1) {
	    
	    InstructionHandle defaultTarget =
		il.append(new PUSH(cpg, EMPTYSTRING));
	    il.insert(tblswitch,new TABLESWITCH(match, target, defaultTarget));
	    il.append(ARETURN);
	}

	extractMethod.stripAttributes(true);
	extractMethod.setMaxLocals();
	extractMethod.setMaxStack();
	extractMethod.removeNOPs();

	return extractMethod.getMethod();
    }

    
    private static Method compileGetCollator(Vector sortObjects,
					     NodeSortRecordGenerator sortRecord,
					     ConstantPoolGen cpg,
					     String className) {
	final InstructionList il = new InstructionList();
	
	final MethodGenerator getCollator =
	    new MethodGenerator(ACC_PUBLIC | ACC_FINAL,
				Util.getJCRefType(COLLATOR_SIG),
				new org.apache.bcel.generic.Type[] {},
				new String[] { },
				""getCollator"", className, il, cpg);

	
	final int collator =
	    cpg.addFieldref(className, ""collator"", COLLATOR_SIG);
	
	il.append(new GETSTATIC(collator));
	il.append(ARETURN);

	getCollator.stripAttributes(true);
	getCollator.setMaxLocals();
	getCollator.setMaxStack();
	getCollator.removeNOPs();

	return getCollator.getMethod();
    }
}
"
org.apache.xalan.serialize.SerializerToXML,71,1,2,24,151,1037,8,16,48,0.878405316,2724,0.604651163,6,0.0,0.133333333,0,0,36.76056338,12,1.507,2,"
package org.apache.xalan.serialize;

import java.io.Writer;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.io.IOException;

import java.util.Enumeration;
import java.util.Stack;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Properties;
import java.util.BitSet;

import org.xml.sax.*;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.ext.DeclHandler;

import org.w3c.dom.Node;

import org.apache.xalan.serialize.Serializer;
import org.apache.xalan.serialize.DOMSerializer;
import org.apache.xml.utils.QName;
import org.apache.xalan.templates.OutputProperties;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.TreeWalker;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;

import javax.xml.transform.Result;
import javax.xml.transform.OutputKeys;


public class SerializerToXML
        implements ContentHandler, LexicalHandler, DeclHandler, Serializer,
                   DOMSerializer
{

  
  protected Writer m_writer = null;

  
  boolean m_shouldFlush = true;

  
  

  
  protected String m_encoding = null;

  
  static boolean javaEncodingIsISO = false;

  
  public boolean m_shouldNotWriteXMLHeader = false;

  
  public String m_version = null;

  
  protected BoolStack m_elemStack = new BoolStack();

  
  protected BoolStack m_disableOutputEscapingStates = new BoolStack();

  
  protected BoolStack m_cdataSectionStates = new BoolStack();

  
  protected Vector m_cdataSectionNames = null;

  
  protected boolean m_inCData = false;

  
  protected boolean isEscapingDisabled()
  {
    return m_disableOutputEscapingStates.peekOrFalse();
  }

  
  protected boolean isCDataSection()
  {
    return m_inCData || m_cdataSectionStates.peekOrFalse();
  }

  
  protected final char[] m_lineSep =
    System.getProperty(""line.separator"").toCharArray();

  
  protected final int m_lineSepLen = m_lineSep.length;

  
  protected final void outputLineSep() throws org.xml.sax.SAXException
  {

    try
    {
      m_writer.write(m_lineSep, 0, m_lineSepLen);
    }
    catch (IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  protected boolean m_ispreserve = false;

  
  protected BoolStack m_preserves = new BoolStack();

  
  protected boolean m_isprevtext = false;

  
  protected boolean m_doIndent = false;

  
  protected int m_currentIndent = 0;

  
  public int m_indentAmount = 0;

  
  protected int level = 0;

  
  boolean m_startNewLine;

  
  boolean m_needToOutputDocTypeDecl = true;

  
  String m_doctypeSystem;

  
  String m_doctypePublic;

  
  boolean m_standalone = false;

  
  boolean m_standaloneWasSpecified = false;

  
  String m_mediatype;

  
  protected boolean m_inEntityRef = false;

  
  private boolean m_inDoctype = false;

  
  protected static CharInfo m_xmlcharInfo =
    new CharInfo(CharInfo.XML_ENTITIES_RESOURCE);

  
  protected CharInfo m_charInfo;

  
  private static Hashtable m_charInfos = null;

  
  boolean m_isUTF8 = false;

  
  protected int m_maxCharacter = Encodings.getLastPrintable();

  
  public boolean m_spaceBeforeClose = false;

  
  protected Properties m_format;

  
  private static final boolean DEBUG = false;

  
  private boolean m_inExternalDTD = false;

  
  public SerializerToXML()
  {
    m_charInfo = m_xmlcharInfo;
  }

  
  public void CopyFrom(SerializerToXML xmlListener)
  {

    m_writer = xmlListener.m_writer;

    
    m_encoding = xmlListener.m_encoding;
    javaEncodingIsISO = xmlListener.javaEncodingIsISO;
    m_shouldNotWriteXMLHeader = xmlListener.m_shouldNotWriteXMLHeader;

    
    m_elemStack = xmlListener.m_elemStack;

    
    
    m_ispreserve = xmlListener.m_ispreserve;
    m_preserves = xmlListener.m_preserves;
    m_isprevtext = xmlListener.m_isprevtext;
    m_doIndent = xmlListener.m_doIndent;
    m_currentIndent = xmlListener.m_currentIndent;
    m_indentAmount = xmlListener.m_indentAmount;
    level = xmlListener.level;
    m_startNewLine = xmlListener.m_startNewLine;
    m_needToOutputDocTypeDecl = xmlListener.m_needToOutputDocTypeDecl;
    m_doctypeSystem = xmlListener.m_doctypeSystem;
    m_doctypePublic = xmlListener.m_doctypePublic;
    m_standalone = xmlListener.m_standalone;
    m_mediatype = xmlListener.m_mediatype;
    m_maxCharacter = xmlListener.m_maxCharacter;
    m_spaceBeforeClose = xmlListener.m_spaceBeforeClose;
    m_inCData = xmlListener.m_inCData;

    
    m_pos = 0;
  }

  
  public synchronized void init(Writer writer, Properties format)
  {
    init(writer, format, false);
  }

  
  private synchronized void init(Writer writer, Properties format,
                                 boolean shouldFlush)
  {

    m_shouldFlush = shouldFlush;
    m_writer = writer;
    m_format = format;
    m_cdataSectionNames =
      OutputProperties.getQNameProperties(OutputKeys.CDATA_SECTION_ELEMENTS,
                                          format);
    m_indentAmount =
      OutputProperties.getIntProperty(OutputProperties.S_KEY_INDENT_AMOUNT,
                                      format);
    m_doIndent = OutputProperties.getBooleanProperty(OutputKeys.INDENT,
            format);
    m_shouldNotWriteXMLHeader =
      OutputProperties.getBooleanProperty(OutputKeys.OMIT_XML_DECLARATION,
                                          format);
    m_doctypeSystem = format.getProperty(OutputKeys.DOCTYPE_SYSTEM);
    m_doctypePublic = format.getProperty(OutputKeys.DOCTYPE_PUBLIC);
    m_standaloneWasSpecified = (null != format.get(OutputKeys.STANDALONE));
    m_standalone = OutputProperties.getBooleanProperty(OutputKeys.STANDALONE,
            format);
    m_mediatype = format.getProperty(OutputKeys.MEDIA_TYPE);

    if (null != m_doctypePublic)
    {
      if (m_doctypePublic.startsWith(""-
        m_spaceBeforeClose = true;
    }

    
    if (null == m_encoding)
      m_encoding =
        Encodings.getMimeEncoding(format.getProperty(OutputKeys.ENCODING));

    m_isUTF8 = m_encoding.equals(Encodings.DEFAULT_MIME_ENCODING);
    m_maxCharacter = Encodings.getLastPrintable(m_encoding);

    
    
    String entitiesFileName =
      (String) format.get(OutputProperties.S_KEY_ENTITIES);

    if (null != entitiesFileName)
    {
      try
      {
        m_charInfo = null;

        if (null == m_charInfos)
        {
          synchronized (m_xmlcharInfo)
          {
            if (null == m_charInfos)  
              m_charInfos = new Hashtable();
          }
        }
        else
        {
          m_charInfo = (CharInfo) m_charInfos.get(entitiesFileName);
        }

        if (null == m_charInfo)
        {
          try
          {
            m_charInfo = new CharInfo(entitiesFileName);
          }
          catch(Exception e)
          {
          	m_charInfo = null;
          }
        }

        if (null == m_charInfo)
        {
          String absoluteEntitiesFileName;

          if (entitiesFileName.indexOf(':') < 0)
          {
            absoluteEntitiesFileName =
              SystemIDResolver.getAbsoluteURIFromRelative(entitiesFileName);
          }
          else
          {
            absoluteEntitiesFileName =
              SystemIDResolver.getAbsoluteURI(entitiesFileName, null);
          }

          m_charInfo = new CharInfo(absoluteEntitiesFileName);

          m_charInfos.put(entitiesFileName, m_charInfo);
        }
      }
      catch (javax.xml.transform.TransformerException te)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(te);
      }
    }
  }

  
  public synchronized void init(OutputStream output, Properties format)
          throws UnsupportedEncodingException
  {

    if (null == format)
    {
      OutputProperties op = new OutputProperties(Method.XML);

      format = op.getProperties();
    }

    m_encoding =
      Encodings.getMimeEncoding(format.getProperty(OutputKeys.ENCODING));

    if (m_encoding.equalsIgnoreCase(""UTF-8""))
    {
      m_isUTF8 = true;
      if(output instanceof java.io.BufferedOutputStream)
      {
        init(new WriterToUTF8(output), format, true);
      }
      else if(output instanceof java.io.FileOutputStream)
      {
        init(new WriterToUTF8Buffered(output), format, true);
      }
      else
      {
        
        
        init(new WriterToUTF8(output), format, true);
      }
      
    }
    else if (m_encoding.equals(""WINDOWS-1250"")
             || m_encoding.equals(""US-ASCII"") || m_encoding.equals(""ASCII""))
    {
      init(new WriterToASCI(output), format, true);
    }
    else
    {
      Writer osw;

      try
      {
        osw = Encodings.getWriter(output, m_encoding);
      }
      catch (UnsupportedEncodingException uee)
      {
        System.out.println(""Warning: encoding """" + m_encoding
                           + """" not supported"" + "", using ""
                           + Encodings.DEFAULT_MIME_ENCODING);

        m_encoding = Encodings.DEFAULT_MIME_ENCODING;
        osw = Encodings.getWriter(output, m_encoding);
      }

      m_maxCharacter = Encodings.getLastPrintable(m_encoding);

      init(osw, format, true);
    }
    
  }

  
  public void setDocumentLocator(Locator locator)
  {

    
  }

  
  void outputDocTypeDecl(String name, boolean closeDecl)
          throws org.xml.sax.SAXException
  {
    try
    {
      final Writer writer = m_writer;
  
      writer.write(""<!DOCTYPE "");
      writer.write(name);
  
      if (null != m_doctypePublic)
      {
        writer.write("" PUBLIC """");
        writer.write(m_doctypePublic);
        writer.write('""');
      }
  
      if (null != m_doctypeSystem)
      {
        if (null == m_doctypePublic)
          writer.write("" SYSTEM """");
        else
          writer.write("" """");
  
        writer.write(m_doctypeSystem);
  
        if (closeDecl)
        {
          writer.write("""">"");
          writer.write(m_lineSep, 0, m_lineSepLen);;
        }
        else
          writer.write('""');
      }
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  void outputEntityDecl(String name, String value)
          throws org.xml.sax.SAXException
  {

    try
    {
      final Writer writer = m_writer;
      writer.write(""<!ENTITY "");
      writer.write(name);
      writer.write("" """");
      writer.write(value);
      writer.write("""">"");
      writer.write(m_lineSep, 0, m_lineSepLen);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  public void startDocument() throws org.xml.sax.SAXException
  {

    if (m_inEntityRef)
      return;

    m_needToOutputDocTypeDecl = true;
    m_startNewLine = false;

    if (m_shouldNotWriteXMLHeader == false)
    {
      String encoding = Encodings.getMimeEncoding(m_encoding);
      String version = (null == m_version) ? ""1.0"" : m_version;
      String standalone;

      if (m_standaloneWasSpecified)
      {
        standalone = "" standalone="""" + (m_standalone ? ""yes"" : ""no"") + """""";
      }
      else
      {
        standalone = """";
      }

      try
      {
        final Writer writer = m_writer;
        writer.write(""<?xml version="""");
        writer.write(version);
        writer.write("""" encoding="""");
        writer.write(encoding);
        writer.write('""');
        writer.write(standalone);
        writer.write(""?>"");
        writer.write(m_lineSep, 0, m_lineSepLen);
      }
      catch(IOException ioe)
      {
        throw new SAXException(ioe);
      }
    }
  }

  
  public void endDocument() throws org.xml.sax.SAXException
  {

    if (m_doIndent &&!m_isprevtext)
    {
      outputLineSep();
    }

    flushWriter();
  }

  
  public void startDTD(String name, String publicId, String systemId)
          throws org.xml.sax.SAXException
  {
    m_doctypeSystem = systemId;
    m_doctypePublic = publicId;

    if ((true == m_needToOutputDocTypeDecl))  
    {
      outputDocTypeDecl(name, false);
    }

    m_needToOutputDocTypeDecl = false;
    m_inDoctype = true;
  }

  
  public void endDTD() throws org.xml.sax.SAXException
  {
    try
    {
      if (!m_inDoctype)
        m_writer.write(""]>"");
      else
      {
        m_writer.write('>');
      }
  
      m_writer.write(m_lineSep, 0, m_lineSepLen);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }

    
  }

  
  public void startPrefixMapping(String prefix, String uri)
          throws org.xml.sax.SAXException{}

  
  public void endPrefixMapping(String prefix)
          throws org.xml.sax.SAXException{}

  
  protected static final boolean subPartMatch(String p, String t)
  {
    return (p == t) || ((null != p) && (p.equals(t)));
  }

  
  protected void pushState(String namespaceURI, String localName,
                           Vector qnames, BoolStack state)
  {

    boolean b;

    if (null != qnames)
    {
      b = false;

      if ((null != namespaceURI) && namespaceURI.length() == 0)
        namespaceURI = null;

      int nElems = qnames.size();

      for (int i = 0; i < nElems; i++)
      {
        QName q = (QName) qnames.elementAt(i);

        if (q.getLocalName().equals(localName)
                && subPartMatch(namespaceURI, q.getNamespaceURI()))
        {
          b = true;

          break;
        }
      }
    }
    else
    {
      b = state.peekOrFalse();
    }

    state.push(b);
  }

  
  public void startElement(
          String namespaceURI, String localName, String name, Attributes atts)
            throws org.xml.sax.SAXException
  {

    if (DEBUG)
    {
      System.out.println(""SerializerToXML - startElement: "" + namespaceURI
                         + "", "" + localName);

      int n = atts.getLength();

      for (int i = 0; i < n; i++)
      {
        System.out.println(""atts["" + i + ""]: "" + atts.getQName(i) + "" = ""
                           + atts.getValue(i));
      }

      if (null == namespaceURI)
      {
        (new RuntimeException(localName
                              + "" has a null namespace!"")).printStackTrace();
      }
    }

    if (m_inEntityRef)
      return;

    if ((true == m_needToOutputDocTypeDecl) && (null != m_doctypeSystem))
    {
      outputDocTypeDecl(name, true);
    }

    m_needToOutputDocTypeDecl = false;

    writeParentTagEnd();
    pushState(namespaceURI, localName, m_cdataSectionNames,
              m_cdataSectionStates);

    
    
    m_ispreserve = false;

    
    if (shouldIndent() && m_startNewLine)
    {
      indent(m_currentIndent);
    }

    m_startNewLine = true;

    try
    {
      m_writer.write('<');
      m_writer.write(name);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }

    int nAttrs = atts.getLength();

    for (int i = 0; i < nAttrs; i++)
    {
      processAttribute(atts.getQName(i), atts.getValue(i));
    }

    
    openElementForChildren();

    m_currentIndent += m_indentAmount;
    m_isprevtext = false;
  }

  
  protected void writeParentTagEnd() throws org.xml.sax.SAXException
  {

    
    if (!m_elemStack.peekOrTrue())
    {
      try
      {
        m_writer.write('>');
      }
      catch(IOException ioe)
      {
        throw new SAXException(ioe);
      }

      m_isprevtext = false;

      m_elemStack.setTop(true);
      m_preserves.push(m_ispreserve);
    }
  }

  
  protected void openElementForChildren()
  {

    
    m_elemStack.push(false);
  }

  
  protected boolean childNodesWereAdded()
  {
    return m_elemStack.isEmpty() ? false : m_elemStack.pop();
  }

  
  public void endElement(String namespaceURI, String localName, String name)
          throws org.xml.sax.SAXException
  {

    if (m_inEntityRef)
      return;

    m_currentIndent -= m_indentAmount;

    boolean hasChildNodes = childNodesWereAdded();

    try
    {
      final Writer writer = m_writer;
      if (hasChildNodes)
      {
        if (shouldIndent())
          indent(m_currentIndent);
  
        writer.write('<');
        writer.write('/');
        writer.write(name);
        writer.write('>');
      }
      else
      {
        if (m_spaceBeforeClose)
          writer.write("" />"");
        else
          writer.write(""/>"");
      }
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }

    if (hasChildNodes)
    {
      m_ispreserve = m_preserves.isEmpty() ? false : m_preserves.pop();
    }

    m_isprevtext = false;

    
    m_cdataSectionStates.pop();
  }

  
  protected void processAttribute(String name, String value)
          throws org.xml.sax.SAXException
  {
    try
    {
      final Writer writer = m_writer;
      writer.write(' ');
      writer.write(name);
      writer.write(""="""");
      writeAttrString(value, m_encoding);
      writer.write('""');
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  public void startNonEscaping() throws org.xml.sax.SAXException
  {
    m_disableOutputEscapingStates.push(true);
  }

  
  public void endNonEscaping() throws org.xml.sax.SAXException
  {
    m_disableOutputEscapingStates.pop();
  }

  
  public void startPreserving() throws org.xml.sax.SAXException
  {

    
    m_preserves.push(true);

    m_ispreserve = true;
  }

  
  public void endPreserving() throws org.xml.sax.SAXException
  {

    
    m_ispreserve = m_preserves.isEmpty() ? false : m_preserves.pop();
  }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {
    if (m_inEntityRef)
      return;

    if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
    {
      startNonEscaping();
    }
    else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
    {
      endNonEscaping();
    }
    else
    {
      try
      {
        final Writer writer = m_writer;
        writeParentTagEnd();
  
        if (shouldIndent())
          indent(m_currentIndent);
  
        writer.write('<');
        writer.write('?');
        writer.write(target);
  
        if (data.length() > 0 &&!Character.isSpaceChar(data.charAt(0)))
          writer.write(' ');
  
        int indexOfQLT = data.indexOf(""?>"");
  
        if (indexOfQLT >= 0)
        {
  
          
          if (indexOfQLT > 0)
          {
            writer.write(data.substring(0, indexOfQLT));
          }
  
          writer.write(""? >"");  
  
          if ((indexOfQLT + 2) < data.length())
          {
            writer.write(data.substring(indexOfQLT + 2));
          }
        }
        else
        {
          writer.write(data);
        }
  
        writer.write('?');
        writer.write('>');
  
        
        
        
        if (m_elemStack.isEmpty())
          writer.write(m_lineSep, 0, m_lineSepLen);
  
        m_startNewLine = true;
      }
      catch(IOException ioe)
      {
        throw new SAXException(ioe);
      }
    }
  }

  
  public void comment(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    if (m_inEntityRef)
      return;

    writeParentTagEnd();

    if (shouldIndent())
      indent(m_currentIndent);

    try
    {
      final Writer writer = m_writer;
      writer.write(""<!--"");
      writer.write(ch, start, length);
      writer.write(""-->"");
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }

    m_startNewLine = true;
  }

  
  public void startCDATA() throws org.xml.sax.SAXException
  {
    m_inCData = true;
  }

  
  public void endCDATA() throws org.xml.sax.SAXException
  {
    m_inCData = false;
  }

  
  public void cdata(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    try
    {
      writeParentTagEnd();

      m_ispreserve = true;

      if (shouldIndent())
        indent(m_currentIndent);

      boolean writeCDataBrackets = (((length >= 1) && canConvert(ch[start])));

      if (writeCDataBrackets)
      {
        m_writer.write(""<![CDATA["");
      }

      
      if (isEscapingDisabled())
      {
        charactersRaw(ch, start, length);
      }
      else
        writeNormalizedChars(ch, start, length, true);

      if (writeCDataBrackets)
      {
        m_writer.write(""]]>"");
      }
    }
    catch (IOException ioe)
    {
      throw new org.xml.sax.SAXException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_OIERROR, null),
        ioe);  
    }
  }

  
  protected int m_pos = 0;

  
  protected final void accum(char b) throws org.xml.sax.SAXException
  {

    try
    {
      m_writer.write(b);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }
  
  
  protected final void accum(char chars[], int start, int length)
          throws org.xml.sax.SAXException
  {

    try
    {
      m_writer.write(chars, start, length);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }
  
  protected final void accum(String s) throws org.xml.sax.SAXException
  {

    try
    {
      m_writer.write(s);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  public final void flushWriter() throws org.xml.sax.SAXException
  {

    if (null != m_writer)
    {
      try
      {
        if (m_writer instanceof WriterToUTF8Buffered)
        {
          if(m_shouldFlush)
            ((WriterToUTF8Buffered) m_writer).flush();
          else
            ((WriterToUTF8Buffered) m_writer).flushBuffer();
        }
        if (m_writer instanceof WriterToUTF8)
        {
          if(m_shouldFlush)
            m_writer.flush(); 
        }
        else if (m_writer instanceof WriterToASCI)
        {
          if(m_shouldFlush)
            m_writer.flush();
        }
        else
        {
          
          
          
          m_writer.flush(); 
        }
      }
      catch (IOException ioe)
      {
        throw new org.xml.sax.SAXException(ioe);
      }
    }
  }

  
  public void characters(char chars[], int start, int length)
          throws org.xml.sax.SAXException
  {
    if(0 == length)
      return;

    
    
    
    if (m_inCData || m_cdataSectionStates.peekOrFalse())
    {
      cdata(chars, start, length);

      return;
    }
    
    try
    {
      
      if (m_disableOutputEscapingStates.peekOrFalse())
      {
        charactersRaw(chars, start, length);
  
        return;
      }
    
      final Writer writer = m_writer;
      if (!m_elemStack.peekOrTrue())
      {
        writer.write('>');
  
        m_isprevtext = false;
  
        m_elemStack.setTop(true);
        m_preserves.push(m_ispreserve);
      }
  
      int startClean = start;
      int lengthClean = 0;
  
      
      int end = start + length;
      boolean checkWhite = true;
      final int maxCharacter = m_maxCharacter;
      final BitSet specialsMap = m_charInfo.m_specialsMap;
  
      for (int i = start; i < end; i++)
      {
        char ch = chars[i];
  
        if (checkWhite
                && ((ch > 0x20)
                    ||!((ch == 0x20) || (ch == 0x09) || (ch == 0xD)
                        || (ch == 0xA))))
        {
          m_ispreserve = true;
          checkWhite = false;
        }
  
        if ((canConvert(ch) && (!specialsMap.get(ch))) || ('""' == ch))
        {
          lengthClean++;
        }
        else
        {
          if (lengthClean > 0)
          {
            writer.write(chars, startClean, lengthClean);
  
            lengthClean = 0;
          }
  
          if (CharInfo.S_LINEFEED == ch)
          {
            writer.write(m_lineSep, 0, m_lineSepLen);
  
            startClean = i + 1;
          }
          else
          {
            startClean = accumDefaultEscape(ch, i, chars, end, false);
            i = startClean - 1;
          }
        }
      }
  
      if (lengthClean > 0)
      {
        writer.write(chars, startClean, lengthClean);
      }
    
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }


    m_isprevtext = true;
  }

  
  public void charactersRaw(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    try
    {
      if (m_inEntityRef)
        return;
  
      writeParentTagEnd();
  
      m_ispreserve = true;
  
      m_writer.write(ch, start, length);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  static final boolean isUTF16Surrogate(char c)
  {
    return (c & 0xFC00) == 0xD800;
  }

  
  int getURF16SurrogateValue(char c, char ch[], int i, int end)
          throws org.xml.sax.SAXException
  {

    int next;

    if (i + 1 >= end)
    {
      throw new org.xml.sax.SAXException(
        XSLMessages.createXPATHMessage(
          XPATHErrorResources.ER_INVALID_UTF16_SURROGATE,
          new Object[]{ Integer.toHexString((int) c) }));  

      
    }
    else
    {
      next = ch[++i];

      if (!(0xdc00 <= next && next < 0xe000))
        throw new org.xml.sax.SAXException(
          XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_INVALID_UTF16_SURROGATE,
            new Object[]{
              Integer.toHexString((int) c) + "" ""
              + Integer.toHexString(next) }));  

      
      next = ((c - 0xd800) << 10) + next - 0xdc00 + 0x00010000;
    }

    return next;
  }

  
  protected int writeUTF16Surrogate(char c, char ch[], int i, int end)
          throws IOException, org.xml.sax.SAXException
  {

    
    int surrogateValue = getURF16SurrogateValue(c, ch, i, end);

    i++;

    m_writer.write('&');
    m_writer.write('#');

    
    m_writer.write(Integer.toString(surrogateValue));
    m_writer.write(';');

    return i;
  }

  
  void writeNormalizedChars(char ch[], int start, int length, boolean isCData)
          throws IOException, org.xml.sax.SAXException
  {

    int end = start + length;

    for (int i = start; i < end; i++)
    {
      char c = ch[i];

      if (CharInfo.S_LINEFEED == c)
      {
        m_writer.write(m_lineSep, 0, m_lineSepLen);
      }
      else if (isCData && (!canConvert(c)))
      {
        if (i != 0)
          m_writer.write(""]]>"");

        
        if (isUTF16Surrogate(c))
        {
          i = writeUTF16Surrogate(c, ch, i, end);
        }
        else
        {
          m_writer.write(""&#"");

          String intStr = Integer.toString((int) c);

          m_writer.write(intStr);
          m_writer.write(';');
        }

        if ((i != 0) && (i < (end - 1)))
          m_writer.write(""<![CDATA["");
      }
      else if (isCData
               && ((i < (end - 2)) && (']' == c) && (']' == ch[i + 1])
                   && ('>' == ch[i + 2])))
      {
        m_writer.write(""]]]]><![CDATA[>"");

        i += 2;
      }
      else
      {
        if (canConvert(c))
        {
          m_writer.write(c);
        }

        
        else if (isUTF16Surrogate(c))
        {
          i = writeUTF16Surrogate(c, ch, i, end);
        }
        else
        {
          m_writer.write(""&#"");

          String intStr = Integer.toString((int) c);

          m_writer.write(intStr);
          m_writer.write(';');
        }
      }
    }
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    if (0 == length)
      return;

    characters(ch, start, length);
  }

  
  public void skippedEntity(String name) throws org.xml.sax.SAXException
  {

    
  }

  
  public void startEntity(String name) throws org.xml.sax.SAXException
  {
    if (name.equals(""[dtd]"")) 
      m_inExternalDTD = true;
    m_inEntityRef = true;
  }

  
  public void endEntity(String name) throws org.xml.sax.SAXException
  {
    if (name.equals(""[dtd]"")) 
      m_inExternalDTD = false;
    m_inEntityRef = false;
  }

  
  public void entityReference(String name) throws org.xml.sax.SAXException
  {
    writeParentTagEnd();

    if (shouldIndent())
      indent(m_currentIndent);

    try
    {
      final Writer writer = m_writer;
      writer.write(""&"");
      writer.write(name);
      writer.write("";"");
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }

  }

  

  
  public void elementDecl(String name, String model) throws SAXException
  {
    
    if (m_inExternalDTD) return; 
    
    try
    {
      final Writer writer = m_writer;
      if (m_inDoctype)
      {
        writer.write("" ["");
        writer.write(m_lineSep, 0, m_lineSepLen);
  
        m_inDoctype = false;
      }
  
      writer.write(""<!ELEMENT "");
      writer.write(name);
      writer.write(' ');
      writer.write(model);
      writer.write('>');
      writer.write(m_lineSep, 0, m_lineSepLen);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  private String m_elemName = """";

  
  public void attributeDecl(
          String eName, String aName, String type, String valueDefault, String value)
            throws SAXException
  {
    
    if (m_inExternalDTD) return; 

    try
    {
      final Writer writer = m_writer;
      if (m_inDoctype)
      {
        writer.write("" ["");
        writer.write(m_lineSep, 0, m_lineSepLen);
  
        m_inDoctype = false;
      }

       
      writer.write(""<!ATTLIST "");
      writer.write(eName);
      writer.write("" ""); 

      writer.write(aName);
      writer.write("" "");
      writer.write(type);
      if(valueDefault!=null)
      {
	writer.write("" "");
	writer.write(valueDefault);
      }
  
      
      
      writer.write("">"");
      writer.write(m_lineSep, 0, m_lineSepLen);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  public void internalEntityDecl(String name, String value)
          throws SAXException
  {
    
    if (m_inExternalDTD) return; 

    try
    {
      if (m_inDoctype)
      {
        m_writer.write("" ["");
        m_writer.write(m_lineSep, 0, m_lineSepLen);
  
        m_inDoctype = false;
      }
  
      outputEntityDecl(name, value);
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  public void externalEntityDecl(
          String name, String publicId, String systemId) throws SAXException{}

  
  protected int accumDefaultEntity(
          char ch, int i, char[] chars, int len, boolean escLF)
            throws org.xml.sax.SAXException
  {

    try
    {
      if (!escLF && CharInfo.S_LINEFEED == ch)
      {
        m_writer.write(m_lineSep, 0, m_lineSepLen);
      }
      else
      {
        if (m_charInfo.isSpecial(ch))
        {
          String entityRef = m_charInfo.getEntityNameForChar(ch);
  
          if (null != entityRef)
          {
            final Writer writer = m_writer;
            writer.write('&');
            writer.write(entityRef);
            writer.write(';');
          }
          else
            return i;
        }
        else
          return i;
      }
  
      return i + 1;
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  protected int accumDefaultEscape(
          char ch, int i, char[] chars, int len, boolean escLF)
            throws org.xml.sax.SAXException
  {

    int pos = accumDefaultEntity(ch, i, chars, len, escLF);

    if (i == pos)
    {
      pos++;

      try
      {
        if (0xd800 <= ch && ch < 0xdc00)
        {
  
          
          int next;
  
          if (i + 1 >= len)
          {
            throw new org.xml.sax.SAXException(
              XSLMessages.createXPATHMessage(
                XPATHErrorResources.ER_INVALID_UTF16_SURROGATE,
                new Object[]{ Integer.toHexString(ch) }));  
  
            
          }
          else
          {
            next = chars[++i];
  
            if (!(0xdc00 <= next && next < 0xe000))
              throw new org.xml.sax.SAXException(
                XSLMessages.createXPATHMessage(
                  XPATHErrorResources.ER_INVALID_UTF16_SURROGATE,
                  new Object[]{
                    Integer.toHexString(ch) + "" ""
                    + Integer.toHexString(next) }));  
  
            
            next = ((ch - 0xd800) << 10) + next - 0xdc00 + 0x00010000;
          }
  
          m_writer.write(""&#"");
          m_writer.write(Integer.toString(next));
          m_writer.write("";"");
  
          
        }
        else
        {
          if (!canConvert(ch) || (m_charInfo.isSpecial(ch)))
          {
            m_writer.write(""&#"");
            m_writer.write(Integer.toString(ch));
            m_writer.write("";"");
          }
          else
          {
            m_writer.write(ch);
          }
        }
      }
      catch(IOException ioe)
      {
        throw new SAXException(ioe);
      }
    }

    return pos;
  }
  
  
  Object m_charToByteConverter = null;
  
  
  java.lang.reflect.Method m_canConvertMeth;
  
  
  boolean m_triedToGetConverter = false;
  
  
  public boolean canConvert(char ch)
  {
    if(ch < 127)
    {
      if(ch >= 0x20 || (0x0A == ch || 0x0D == ch || 0x09 == ch) )
        return true;
      else
        return false;
    }
    
    if(null == m_charToByteConverter && false == m_triedToGetConverter)
    {
      m_triedToGetConverter = true;
      try
      {
        m_charToByteConverter = Encodings.getCharToByteConverter(m_encoding);
        if(null != m_charToByteConverter)
        {
          Class argsTypes[] = new Class[1];
          argsTypes[0] = Character.TYPE;
          Class convClass = m_charToByteConverter.getClass();
          m_canConvertMeth = convClass.getMethod(""canConvert"", argsTypes);
        }
      }
      catch(Exception e)
      {
       
        System.err.println(""Warning: ""+e.getMessage());
      }
    }
    if(null != m_charToByteConverter)
    {
      try
      {
        Object args[] = new Object[1];
        args[0] = new Character( ch );
        Boolean bool 
          = (Boolean)m_canConvertMeth.invoke(m_charToByteConverter, args);
        return bool.booleanValue() ? !Character.isISOControl(ch) : false;
      }
      catch(java.lang.reflect.InvocationTargetException ite)
      {
        
        System.err.println(""Warning: InvocationTargetException in canConvert!"");
      }
      catch(java.lang.IllegalAccessException iae)
      {
        
        System.err.println(""Warning: IllegalAccessException in canConvert!"");
      }
    }
    
    return ( ch <= m_maxCharacter );
  }


  
  public void writeAttrString(String string, String encoding)
          throws org.xml.sax.SAXException
  {

    try
    {
      final char[] stringChars = string.toCharArray();
      final int len = stringChars.length;
      final Writer writer = m_writer;
  
      for (int i = 0; i < len; i++)
      {
        char ch = stringChars[i];
  
        if (canConvert(ch) && (!m_charInfo.isSpecial(ch)))
        {
          writer.write(ch);
        }
        else
        {
  
          
          if ((CharInfo.S_CARRIAGERETURN == ch) && ((i + 1) < len)
                  && (CharInfo.S_LINEFEED == stringChars[i + 1]))
          {
            i++;
  
            ch = CharInfo.S_LINEFEED;
          }
  
          accumDefaultEscape(ch, i, stringChars, len, true);
        }
      }
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  protected boolean shouldIndent()
  {
    return m_doIndent && (!m_ispreserve &&!m_isprevtext);
  }

  
  public void printSpace(int n) throws org.xml.sax.SAXException
  {

    try
    {
      for (int i = 0; i < n; i++)
      {
        m_writer.write(' ');
      }
    }
    catch(IOException ioe)
    {
      throw new SAXException(ioe);
    }
  }

  
  public void indent(int n) throws org.xml.sax.SAXException
  {

    if (m_startNewLine)
      outputLineSep();

    if (m_doIndent)
    {
      printSpace(n);
    }
  }

  
  public void setOutputStream(OutputStream output)
  {

    try
    {
      init(output, m_format);
    }
    catch (UnsupportedEncodingException uee)
    {

      
    }
  }

  
  public OutputStream getOutputStream()
  {

    if (m_writer instanceof WriterToUTF8Buffered)
      return ((WriterToUTF8Buffered) m_writer).getOutputStream();
    if (m_writer instanceof WriterToUTF8)
      return ((WriterToUTF8) m_writer).getOutputStream();
    else if (m_writer instanceof WriterToASCI)
      return ((WriterToASCI) m_writer).getOutputStream();
    else
      return null;
  }

  
  public void setWriter(Writer writer)
  {
    m_writer = writer;
  }

  
  public Writer getWriter()
  {
    return m_writer;
  }

  
  public void setOutputFormat(Properties format)
  {

    boolean shouldFlush = m_shouldFlush;

    init(m_writer, format, false);

    m_shouldFlush = shouldFlush;
  }

  
  public Properties getOutputFormat()
  {
    return m_format;
  }

  
  public ContentHandler asContentHandler() throws IOException
  {
    return this;
  }

  
  public DOMSerializer asDOMSerializer() throws IOException
  {
    return this;  
  }

  
  public boolean reset()
  {
    return false;
  }

  
  public void serialize(Node node) throws IOException
  {

    try
    {
      TreeWalker walker = new TreeWalker(this,
                                         new org.apache.xpath.DOM2Helper());

      walker.traverse(node);
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new WrappedRuntimeException(se);
    }
  }
}  

"
org.apache.xpath.axes.HasPositionalPredChecker,4,2,0,18,7,0,1,17,4,0.166666667,93,1.0,0,0.8,0.4,0,0,21.75,12,4.0,0,"package org.apache.xpath.axes;

import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.functions.FuncLast;
import org.apache.xpath.functions.FuncPosition;
import org.apache.xpath.functions.Function;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.operations.Div;
import org.apache.xpath.operations.Minus;
import org.apache.xpath.operations.Mod;
import org.apache.xpath.operations.Mult;
import org.apache.xpath.operations.Plus;
import org.apache.xpath.operations.Quo;
import org.apache.xpath.operations.Variable;

public class HasPositionalPredChecker extends XPathVisitor
{
	private boolean m_hasPositionalPred = false;
	private int m_predDepth = 0;
	
	
	public static boolean check(LocPathIterator path)
	{
		HasPositionalPredChecker hppc = new HasPositionalPredChecker();
		path.callVisitors(null, hppc);
		return hppc.m_hasPositionalPred;
	}
	
	
	public boolean visitFunction(ExpressionOwner owner, Function func)
	{
		if((func instanceof FuncPosition) ||
		   (func instanceof FuncLast))
			m_hasPositionalPred = true;
		return true;
	}
	












	
  
  public boolean visitPredicate(ExpressionOwner owner, Expression pred)
  {
    m_predDepth++;

    if(m_predDepth == 1)
    {
      if((pred instanceof Variable) || 
         (pred instanceof XNumber) ||
         (pred instanceof Div) ||
         (pred instanceof Plus) ||
         (pred instanceof Minus) ||
         (pred instanceof Mod) ||
         (pred instanceof Quo) ||
         (pred instanceof Mult) ||
         (pred instanceof org.apache.xpath.operations.Number) ||
         (pred instanceof Function))
          m_hasPositionalPred = true;
      else
      	pred.callVisitors(owner, this);
    }

    m_predDepth--;

    
    return false;
  }


}

"
org.apache.xalan.xsltc.compiler.util.NodeCounterGenerator,4,4,0,5,6,4,1,4,4,0.666666667,26,1.0,0,0.964285714,0.45,0,0,5.25,1,0.75,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Stylesheet;


public final class NodeCounterGenerator extends ClassGenerator {
    private Instruction _aloadTranslet;

    public NodeCounterGenerator(String className, 
				String superClassName,
			        String fileName,
			        int accessFlags, 
				String[] interfaces,
			        Stylesheet stylesheet) {
	super(className, superClassName, fileName,
	      accessFlags, interfaces, stylesheet);
    }

    
    public void setTransletIndex(int index) {
	_aloadTranslet = new ALOAD(index);
    }

    
    public Instruction loadTranslet() {
	return _aloadTranslet;
    }
    
    
    public boolean isExternal() {
	return true;
    }
}
"
org.apache.xpath.functions.WrongNumberArgsException,1,3,0,12,2,0,12,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"
package org.apache.xpath.functions;


public class WrongNumberArgsException extends Exception
{

  
  public WrongNumberArgsException(String argsExpected)
  {

    super(argsExpected);
  }
}
"
org.apache.xalan.xsltc.compiler.TopLevelElement,5,2,10,27,17,10,16,11,4,2.0,56,0.0,0,0.931034483,0.44,1,4,10.2,1,0.8,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Enumeration;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

class TopLevelElement extends SyntaxTreeNode {

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return typeCheckContents(stable);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ErrorMsg msg = new ErrorMsg(ErrorMsg.NOT_IMPLEMENTED_ERR,
				    getClass(), this);
	getParser().reportError(FATAL, msg);
    }
	
    
    public InstructionList compile(ClassGenerator classGen,
				   MethodGenerator methodGen) {
	final InstructionList result, save = methodGen.getInstructionList();
	methodGen.setInstructionList(result = new InstructionList());
	translate(classGen, methodGen);
	methodGen.setInstructionList(save);
	return result;
    }

    public void display(int indent) {
	indent(indent);
	Util.println(""TopLevelElement"");
	displayContents(indent + IndentIncrement);
    }
}
"
org.apache.xalan.xsltc.compiler.XslAttribute,6,3,0,35,56,0,2,33,5,0.45,416,1.0,2,0.918032787,0.305555556,2,8,67.66666667,28,6.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class XslAttribute extends Instruction {

    private String _prefix;
    private AttributeValue _name; 	
    private AttributeValueTemplate _namespace = null;
    private boolean _ignore = false;

    
    public AttributeValue getName() {
	return _name;
    }

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Attribute "" + _name);
	displayContents(indent + IndentIncrement);
    }
		
    
    public void parseContents(Parser parser) {
	boolean generated = false;
	final SymbolTable stable = parser.getSymbolTable();

	String name = getAttribute(""name"");
	String namespace = getAttribute(""namespace"");
	QName qname = parser.getQName(name, false);
	final String prefix = qname.getPrefix();

	if ((prefix != null) && (prefix.equals(XMLNS_PREFIX))) {
	    reportError(this, parser, ErrorMsg.ILLEGAL_ATTR_NAME_ERR, name);
	    return;
	}

	
	final SyntaxTreeNode parent = getParent();
	final Vector siblings = parent.getContents();
	for (int i = 0; i < parent.elementCount(); i++) {
	    SyntaxTreeNode item = (SyntaxTreeNode)siblings.elementAt(i);
	    if (item == this) break;

	    
	    if (item instanceof XslAttribute) continue;
	    if (item instanceof UseAttributeSets) continue;
	    if (item instanceof LiteralAttribute) continue;
	    if (item instanceof Text) continue;

	    
	    
	    if (item instanceof If) continue;
	    if (item instanceof Choose) continue;
 	    if (item instanceof CopyOf) continue;
 	    if (item instanceof VariableBase) continue;
	    reportWarning(this, parser, ErrorMsg.STRAY_ATTRIBUTE_ERR, name);
	    _ignore = true;
	}

	
	if (namespace != null && namespace != Constants.EMPTYSTRING) {
	    _prefix = lookupPrefix(namespace);
	    _namespace = new AttributeValueTemplate(namespace, parser, this);
	}
	
	else if (prefix != null && prefix != Constants.EMPTYSTRING) {
	    _prefix = prefix;
	    namespace = lookupNamespace(prefix);
	    if (namespace != null) {
		_namespace = new AttributeValueTemplate(namespace, parser, this);
	    }
	}
	
	
	if (_namespace != null) {
	    
	    if (_prefix == null || _prefix == Constants.EMPTYSTRING) {
		if (prefix != null) {
		    _prefix = prefix;
		}
		else {
		    _prefix = stable.generateNamespacePrefix();
		    generated = true;
		}
	    }
	    else if (prefix != null && !prefix.equals(_prefix)) {
		_prefix = prefix;
	    }

	    name = _prefix + "":"" + qname.getLocalPart();

	    
	    if ((parent instanceof LiteralElement) && (!generated)) {
		((LiteralElement)parent).registerNamespace(_prefix,
							   namespace,
							   stable, false);
	    }
	}

	if (name.equals(XMLNS_PREFIX)) {
	    reportError(this, parser, ErrorMsg.ILLEGAL_ATTR_NAME_ERR, name);
	    return;
	}

	if (parent instanceof LiteralElement) {
	    ((LiteralElement)parent).addAttribute(this);
	}

	_name = AttributeValue.create(this, name, parser);
	parseChildren(parser);
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (!_ignore) {
	    _name.typeCheck(stable);
	    if (_namespace != null) {
		_namespace.typeCheck(stable);
	    }
	    typeCheckContents(stable);
	}
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_ignore) return;
	_ignore = true;

	
	if (_namespace != null) {
	    
	    il.append(methodGen.loadHandler());
	    il.append(new PUSH(cpg,_prefix));
	    _namespace.translate(classGen,methodGen);
	    il.append(methodGen.namespace());
	}

	
	il.append(methodGen.loadHandler());
	il.append(DUP);		
	
	
	_name.translate(classGen, methodGen);

	
	if ((elementCount() == 1) && (elementAt(0) instanceof Text)) {
	    il.append(new PUSH(cpg, ((Text)elementAt(0)).getText()));
	}
	else {
	    il.append(classGen.loadTranslet());
	    il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
						   ""stringValueHandler"",
						   STRING_VALUE_HANDLER_SIG)));
	    il.append(DUP);
	    il.append(methodGen.storeHandler());
	    
	    translateContents(classGen, methodGen);
	    
	    il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_VALUE_HANDLER,
							 ""getValue"",
							 ""()"" + STRING_SIG)));
	}

	
	il.append(methodGen.attribute());
	
	il.append(methodGen.storeHandler());
    }
}
"
org.apache.xalan.serialize.WriterToASCI,7,2,0,1,13,0,1,0,7,0.0,65,1.0,0,0.684210526,0.342857143,1,2,8.142857143,1,0.8571,0,"
package org.apache.xalan.serialize;

import java.io.*;


public class WriterToASCI extends Writer
{

  
  private final OutputStream m_os;

  
  public WriterToASCI(OutputStream os)
  {
    m_os = os;
  }

  
  public void write(char chars[], int start, int length)
          throws java.io.IOException
  {

    int n = length+start;

    for (int i = start; i < n; i++)
    {
      m_os.write(chars[i]);
    }
  }

  
  public void write(int c) throws IOException
  {
    m_os.write(c);
  }

  
  public void write(String s) throws IOException
  {
    int n = s.length();
    for (int i = 0; i < n; i++)
    {
      m_os.write(s.charAt(i));
    }
  }

  
  public void flush() throws java.io.IOException
  {
    m_os.flush();
  }

  
  public void close() throws java.io.IOException
  {
    m_os.close();
  }
  
  
  public OutputStream getOutputStream()
  {
    return m_os;
  }

}
"
org.apache.xalan.processor.ProcessorLRE,4,5,0,17,75,6,1,17,3,2.0,468,0.0,0,0.986111111,0.5,4,6,116.0,3,1.25,1,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemLiteralResult;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.ElemExtensionCall;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.XMLNSDecl;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xpath.XPath;
import org.apache.xalan.templates.StylesheetRoot;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;
import org.xml.sax.Locator;
import org.xml.sax.helpers.AttributesImpl;

import javax.xml.transform.TransformerConfigurationException;
import org.apache.xml.utils.SAXSourceLocator;

import java.util.Vector;


public class ProcessorLRE extends ProcessorTemplateElem
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    try
    {
      ElemTemplateElement p = handler.getElemTemplateElement();
      boolean excludeXSLDecl = false;
      boolean isLREAsStyleSheet = false;

      if (null == p)
      {

        
        XSLTElementProcessor lreProcessor = handler.popProcessor();
        XSLTElementProcessor stylesheetProcessor =
                                                  handler.getProcessorFor(Constants.S_XSLNAMESPACEURL, ""stylesheet"",
                                                                          ""xsl:stylesheet"");

        handler.pushProcessor(lreProcessor);

        Stylesheet stylesheet;
        try
        {
          stylesheet = new StylesheetRoot(handler.getSchema(), handler.getStylesheetProcessor().getErrorListener());
        }
        catch(TransformerConfigurationException tfe)
        {
          throw new TransformerException(tfe);
        }

        
        
        SAXSourceLocator slocator = new SAXSourceLocator();
        Locator locator = handler.getLocator();
        if(null != locator)
        {
          slocator.setLineNumber(locator.getLineNumber());
          slocator.setColumnNumber(locator.getColumnNumber());
          slocator.setPublicId(locator.getPublicId());
          slocator.setSystemId(locator.getSystemId());
        }
        stylesheet.setLocaterInfo(slocator);
        stylesheet.setPrefixes(handler.getNamespaceSupport());
        handler.pushStylesheet(stylesheet);

        isLREAsStyleSheet = true;

        AttributesImpl stylesheetAttrs = new AttributesImpl();
        AttributesImpl lreAttrs = new AttributesImpl();
        int n = attributes.getLength();

        for (int i = 0; i < n; i++)
        {
          String attrLocalName = attributes.getLocalName(i);
          String attrUri = attributes.getURI(i);
          String value = attributes.getValue(i);

          if ((null != attrUri) && attrUri.equals(Constants.S_XSLNAMESPACEURL))
          {
            stylesheetAttrs.addAttribute(null, attrLocalName, attrLocalName,
                                         attributes.getType(i),
                                         attributes.getValue(i));
          }
          else if ((attrLocalName.startsWith(""xmlns:"") || attrLocalName.equals(
                                                                               ""xmlns"")) && value.equals(Constants.S_XSLNAMESPACEURL))
          {

            
          }
          else
          {
            lreAttrs.addAttribute(attrUri, attrLocalName,
                                  attributes.getQName(i),
                                  attributes.getType(i),
                                  attributes.getValue(i));
          }
        }

        attributes = lreAttrs;

        
        
        
				try{
        stylesheetProcessor.setPropertiesFromAttributes(handler, ""stylesheet"",
                                                        stylesheetAttrs, stylesheet);
				}
				catch (Exception e)
				{
					
					
					
					
					
					
					String msg = e.getMessage();
					if (stylesheet.getDeclaredPrefixes() == null || 
						!declaredXSLNS(stylesheet))
					{
						msg = msg +""; "" + XSLMessages.createWarning(XSLTErrorResources.WG_OLD_XSLT_NS, null);
						
					}
					
						throw new org.xml.sax.SAXException(msg, e);
				}
        handler.pushElemTemplateElement(stylesheet);

        ElemTemplate template = new ElemTemplate();

        appendAndPush(handler, template);

        XPath rootMatch = new XPath(""/"", stylesheet, stylesheet, XPath.MATCH, 
             handler.getStylesheetProcessor().getErrorListener());

        template.setMatch(rootMatch);

        
        stylesheet.setTemplate(template);

        p = handler.getElemTemplateElement();
        excludeXSLDecl = true;
      }

      XSLTElementDef def = getElemDef();
      Class classObject = def.getClassObject();
      boolean isExtension = false;
      boolean isComponentDecl = false;
      boolean isUnknownTopLevel = false;

      while (null != p)
      {

        
        if (p instanceof ElemLiteralResult)
        {
          ElemLiteralResult parentElem = (ElemLiteralResult) p;

          isExtension = parentElem.containsExtensionElementURI(uri);
        }
        else if (p instanceof Stylesheet)
        {
          Stylesheet parentElem = (Stylesheet) p;

          isExtension = parentElem.containsExtensionElementURI(uri);

          if ((false == isExtension) && (null != uri)
              && uri.equals(Constants.S_BUILTIN_EXTENSIONS_URL))
          {
            isComponentDecl = true;
          }
          else
          {
            isUnknownTopLevel = true;
          }
        }

        if (isExtension)
          break;

        p = p.getParentElem();
      }

      ElemTemplateElement elem = null;

      try
      {
        if (isExtension)
        {

          
          elem = new ElemExtensionCall();
        }
        else if (isComponentDecl)
        {
          elem = (ElemTemplateElement) classObject.newInstance();
        }
        else if (isUnknownTopLevel)
        {

          
          elem = (ElemTemplateElement) classObject.newInstance();
        }
        else
        {
          elem = (ElemTemplateElement) classObject.newInstance();
        }

        elem.setDOMBackPointer(handler.getOriginatingNode());
        elem.setLocaterInfo(handler.getLocator());
        elem.setPrefixes(handler.getNamespaceSupport(), excludeXSLDecl);

        if (elem instanceof ElemLiteralResult)
        {
          ((ElemLiteralResult) elem).setNamespace(uri);
          ((ElemLiteralResult) elem).setLocalName(localName);
          ((ElemLiteralResult) elem).setRawName(rawName);
          ((ElemLiteralResult) elem).setIsLiteralResultAsStylesheet(
                                                                    isLREAsStyleSheet);
        }
      }
      catch (InstantiationException ie)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CREATING_ELEMLITRSLT, null, ie);
      }
      catch (IllegalAccessException iae)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CREATING_ELEMLITRSLT, null, iae);
      }

      setPropertiesFromAttributes(handler, rawName, attributes, elem);

      
      if (!isExtension && (elem instanceof ElemLiteralResult))
      {
        isExtension =
                     ((ElemLiteralResult) elem).containsExtensionElementURI(uri);

        if (isExtension)
        {

          
          elem = new ElemExtensionCall();

          elem.setLocaterInfo(handler.getLocator());
          elem.setPrefixes(handler.getNamespaceSupport());
          ((ElemLiteralResult) elem).setNamespace(uri);
          ((ElemLiteralResult) elem).setLocalName(localName);
          ((ElemLiteralResult) elem).setRawName(rawName);
          setPropertiesFromAttributes(handler, rawName, attributes, elem);
        }
      }

      appendAndPush(handler, elem);
    }
    catch(TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    ElemTemplateElement elem = handler.getElemTemplateElement();

    if (elem instanceof ElemLiteralResult)
    {
      if (((ElemLiteralResult) elem).getIsLiteralResultAsStylesheet())
      {
        handler.popStylesheet();
      }
    }

    super.endElement(handler, uri, localName, rawName);
  }
	
	private boolean declaredXSLNS(Stylesheet stylesheet)
	{
		Vector declaredPrefixes = stylesheet.getDeclaredPrefixes();
		int n = declaredPrefixes.size();

		for (int i = 0; i < n; i++)
		{
			XMLNSDecl decl = (XMLNSDecl) declaredPrefixes.elementAt(i);
			if(decl.getURI().equals(Constants.S_XSLNAMESPACEURL))
				return true;
		}
		return false;
	}
}
"
org.apache.xalan.xsltc.trax.SAX2TO,19,1,0,6,42,57,2,4,19,0.666666667,154,0.0,1,0.0,0.278195489,0,0,7.0,1,0.9474,0,"


package org.apache.xalan.xsltc.trax;

import java.util.ArrayList;

import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.Attributes;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.SAXException;

import org.apache.xalan.xsltc.runtime.Constants;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.TransletOutputHandler;

public class SAX2TO implements ContentHandler, LexicalHandler, Constants {

    static private class Pair {
	String left;
	String right;

	public Pair(String ll, String rr) {
	    left = ll; right = rr;
	}
    }

    TransletOutputHandler _handler;
    ArrayList _nsDeclarations = new ArrayList();

    public SAX2TO(TransletOutputHandler handler) {
	_handler = handler;
    }

    public void startDocument() throws TransletException {
	_handler.startDocument();
    }

    public void endDocument() throws TransletException {
	_handler.endDocument();
	_handler.close();
    }

    public void startElement(String namespace, String localName, String qName,
	Attributes attrs) throws TransletException
    {
	_handler.startElement(qName);

	int n = _nsDeclarations.size();
	for (int i = 0; i < n; i++) {
	    final Pair pair = (Pair) _nsDeclarations.get(i);
	    _handler.namespace(pair.left, pair.right);
	}
	_nsDeclarations.clear();

	n = attrs.getLength();
	for (int i = 0; i < n; i++) {
	    _handler.attribute(attrs.getQName(i), attrs.getValue(i));
	}
    }

    public void endElement(String namespace, String localName, String qName) 
	throws TransletException
    {
	_handler.endElement(qName);
    }

    public void startPrefixMapping(String prefix, String uri)
	throws TransletException
    {
	_nsDeclarations.add(new Pair(prefix, uri));
    }

    public void endPrefixMapping(String prefix) {
	
    }

    public void characters(char[] ch, int start, int length)
	throws TransletException
    {
	_handler.characters(ch, start, length);
    }

    public void processingInstruction(String target, String data)
	throws TransletException
    {
	_handler.processingInstruction(target, data);
    }

    public void comment(char[] ch, int start, int length) 
	throws TransletException
    {
	_handler.comment(new String(ch, start, length));
    }

    public void ignorableWhitespace(char[] ch, int start, int length)
	throws TransletException
    {
	_handler.characters(ch, start, length);
    }

    public void startCDATA() throws TransletException { 
	_handler.startCDATA();
    }

    public void endCDATA() throws TransletException { 
	_handler.endCDATA();
    }

    public void setDocumentLocator(Locator locator) {
    }

    public void skippedEntity(String name) {
    }

    public void startEntity(java.lang.String name) { 
    }

    public void endDTD() { 
    }

    public void endEntity(String name) { 
    }

    public void startDTD(String name, String publicId, String systemId)
        throws SAXException 
    { 
    }
}
"
org.apache.xalan.xsltc.runtime.output.StreamOutput,17,2,4,8,36,30,5,3,6,0.912946429,505,1.0,0,0.704545455,0.25,0,0,27.05882353,3,1.2353,1,"

package org.apache.xalan.xsltc.runtime.output;

import java.io.Writer;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import java.util.Vector;

import org.apache.xalan.xsltc.TransletException;

abstract class StreamOutput extends OutputBase {

    protected static final String AMP      = ""&amp;"";
    protected static final String LT       = ""&lt;"";
    protected static final String GT       = ""&gt;"";
    protected static final String CRLF     = ""&#xA;"";
    protected static final String APOS     = ""&apos;"";
    protected static final String QUOT     = ""&quot;"";
    protected static final String NBSP     = ""&nbsp;"";

    protected static final String CHAR_ESC_START  = ""&#"";

    protected static final char[] INDENT = ""                    "".toCharArray();
    protected static final int MAX_INDENT_LEVEL = (INDENT.length >> 1);
    protected static final int MAX_INDENT       = INDENT.length;

    protected static final int BUFFER_SIZE = 32 * 1024;
    protected static final int OUTPUT_BUFFER_SIZE = 4 * 1024;

    protected Writer  _writer;
    protected StringBuffer _buffer;

    protected boolean _is8859Encoded = false;
    protected boolean _indent     = false;
    protected boolean _omitHeader = false;
    protected String  _standalone = null;
    protected String  _version    = ""1.0"";

    protected boolean _lineFeedNextStartTag = false;
    protected boolean _linefeedNextEndTag   = false;
    protected boolean _indentNextEndTag     = false;
    protected int     _indentLevel          = 0;

    protected boolean _escaping     = true;
    protected String  _encoding     = ""UTF-8"";

    protected int     _indentNumber = 2;

    protected Vector _attributes = new Vector();

    static class Attribute {
	public String name, value;

	Attribute(String name, String value) {
	    this.name = name; 
	    this.value = value;
	}

	public int hashCode() {
	    return name.hashCode();
	}

	public boolean equals(Object obj) {
	    try {
		return name.equalsIgnoreCase(((Attribute) obj).name);
	    }
	    catch (ClassCastException e) {
		return false;
	    }
	}
    }

    protected StreamOutput(StreamOutput output) {
	_writer = output._writer;
	_encoding = output._encoding;
	_is8859Encoded = output._is8859Encoded;
	_buffer = output._buffer;
	_indentNumber = output._indentNumber;
    }

    protected StreamOutput(Writer writer, String encoding) {
	_writer = writer;
	_encoding = encoding;
	_is8859Encoded = encoding.equalsIgnoreCase(""iso-8859-1"");
	_buffer = new StringBuffer(BUFFER_SIZE);
    }

    protected StreamOutput(OutputStream out, String encoding) 
	throws IOException
    {
	try {
	    _writer = new OutputStreamWriter(out, _encoding = encoding);
	    _is8859Encoded = encoding.equalsIgnoreCase(""iso-8859-1"");
	}
	catch (UnsupportedEncodingException e) {
	    _writer = new OutputStreamWriter(out, _encoding = ""utf-8"");
	}
	_buffer = new StringBuffer(BUFFER_SIZE);
    }

    public void setIndentNumber(int value) {
	_indentNumber = value;
    }

    
    public void setDoctype(String system, String pub) {
	_doctypeSystem = system;
	_doctypePublic = pub;
    }

    public void setIndent(boolean indent) { 

	_indent = indent;
    }

    public void omitHeader(boolean value) {
        _omitHeader = value;
    }

    public void setStandalone(String standalone) {
	_standalone = standalone;
    }

    public void setVersion(String version) { 
	_version = version;
    }

    protected void outputBuffer() {
	try {
	    int n = 0;
	    final int length = _buffer.length();
	    final String output = _buffer.toString();

	    
	    if (length > OUTPUT_BUFFER_SIZE) {
		do {
		    _writer.write(output, n, OUTPUT_BUFFER_SIZE);
		    n += OUTPUT_BUFFER_SIZE;
		} while (n + OUTPUT_BUFFER_SIZE < length);
	    }
	    _writer.write(output, n, length - n);
	    _writer.flush();
	}
	catch (IOException e) {
	    
	}
    }

    protected void appendDTD(String name) {
	_buffer.append(""<!DOCTYPE "").append(name);
	if (_doctypePublic == null) {
	    _buffer.append("" SYSTEM"");
	}
	else {
	    _buffer.append("" PUBLIC """").append(_doctypePublic).append("""""");
	}
	if (_doctypeSystem != null) {
	    _buffer.append("" """").append(_doctypeSystem).append("""">
"");
	}
	else {
	    _buffer.append("">
"");
	}
    }

    
    protected void indent(boolean linefeed) {
        if (linefeed) {
            _buffer.append('
');
	}

	_buffer.append(INDENT, 0, 
	    _indentLevel < MAX_INDENT_LEVEL ? _indentLevel * _indentNumber 
		: MAX_INDENT);
    }

    
    protected void escapeCharacters(char[] ch, int off, int len) {
    }

    protected void appendAttributes() {
	
	if (!_attributes.isEmpty()) {
	    int i = 0;
	    final int length = _attributes.size();

	    do {
		final Attribute attr = (Attribute) _attributes.elementAt(i);
		_buffer.append(' ').append(attr.name).append(""="""")
		       .append(attr.value).append('""');
	    } while (++i < length);

	    _attributes.clear();
	}
    }

    protected void closeStartTag() throws TransletException {
	appendAttributes();
	_buffer.append('>');
	_startTagOpen = false;
    }

    
    protected void appendComment(String comment) 
	throws TransletException 
    {
	boolean lastIsDash = false;
	final int n = comment.length();

	_buffer.append(""<!--"");
	for (int i = 0; i < n; i++) {
	    final char ch = comment.charAt(i);
	    final boolean isDash = (ch == '-');

	    if (lastIsDash && isDash) {
		_buffer.append("" -"");
	    }
	    else {
		_buffer.append(ch);
	    }
	    lastIsDash = isDash;
	}
	if (lastIsDash) {
	    _buffer.append(' ');
	}
	_buffer.append(""-->"");
    }
}
"
org.apache.xpath.Expression,32,1,6,106,57,466,98,11,31,0.806451613,276,1.0,1,0.0,0.163461538,0,0,7.59375,3,1.2813,0,"
package org.apache.xpath;


import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;

import org.xml.sax.XMLReader;
import org.xml.sax.ContentHandler;

import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;

import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.XMLString;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTM;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.ErrorListener;


public abstract class Expression implements java.io.Serializable, ExpressionNode, XPathVisitable
{

  
  private ExpressionNode m_parent;

  
  public boolean canTraverseOutsideSubtree()
  {
    return false;
  }
  












  
  public XObject execute(XPathContext xctxt, int currentNode)
          throws javax.xml.transform.TransformerException
  {

    
    return execute(xctxt);
  }

  
  public XObject execute(
          XPathContext xctxt, int currentNode, DTM dtm, int expType)
            throws javax.xml.transform.TransformerException
  {

    
    return execute(xctxt);
  }

  
  public abstract XObject execute(XPathContext xctxt)
    throws javax.xml.transform.TransformerException;

  
  public XObject execute(XPathContext xctxt, boolean destructiveOK)
    throws javax.xml.transform.TransformerException
  {
  	return execute(xctxt);
  }


  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return execute(xctxt).num();
  }

  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return execute(xctxt).bool();
  }

  
  public XMLString xstr(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return execute(xctxt).xstr();
  }

  
  public boolean isNodesetExpr()
  {
    return false;
  }

  
  public int asNode(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
  	DTMIterator iter = execute(xctxt).iter();
    return iter.nextNode();
  }

  
  public DTMIterator asIterator(XPathContext xctxt, int contextNode)
          throws javax.xml.transform.TransformerException
  {

    try
    {
      xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);

      return execute(xctxt).iter();
    }
    finally
    {
      xctxt.popCurrentNodeAndExpression();
    }
  }
  
  
  public DTMIterator asIteratorRaw(XPathContext xctxt, int contextNode)
          throws javax.xml.transform.TransformerException
  {

    try
    {
      xctxt.pushCurrentNodeAndExpression(contextNode, contextNode);

      XNodeSet nodeset = (XNodeSet)execute(xctxt);
      return nodeset.iterRaw();
    }
    finally
    {
      xctxt.popCurrentNodeAndExpression();
    }
  }


  
  public void executeCharsToContentHandler(
          XPathContext xctxt, ContentHandler handler)
            throws javax.xml.transform.TransformerException,
                   org.xml.sax.SAXException
  {

    XObject obj = execute(xctxt);

    obj.dispatchCharactersEvents(handler);
    obj.detach();
  }

  
  public boolean isStableNumber()
  {
    return false;
  }

  
  public abstract void fixupVariables(java.util.Vector vars, int globalsSize);
  
  
  public abstract boolean deepEquals(Expression expr);
  
  
  protected final boolean isSameClass(Expression expr)
  {
  	if(null == expr)
  	  return false;
  	  
  	return (getClass() == expr.getClass());
  }

  
  public void warn(XPathContext xctxt, int msg, Object[] args)
          throws javax.xml.transform.TransformerException
  {

    java.lang.String fmsg = XSLMessages.createXPATHWarning(msg, args);

    if (null != xctxt)
    {
      ErrorListener eh = xctxt.getErrorListener();

      
      eh.warning(new TransformerException(fmsg, xctxt.getSAXLocator()));
    }
  }

  
  public void assertion(boolean b, java.lang.String msg)
  {

    if (!b)
    {
      java.lang.String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ msg });

      throw new RuntimeException(fMsg);
    }
  }

  
  public void error(XPathContext xctxt, int msg, Object[] args)
          throws javax.xml.transform.TransformerException
  {

    java.lang.String fmsg = XSLMessages.createXPATHMessage(msg, args);

    if (null != xctxt)
    {
      ErrorListener eh = xctxt.getErrorListener();
      TransformerException te = new TransformerException(fmsg, this);

      eh.fatalError(te);
    }
  }
  
  
  public ExpressionNode getExpressionOwner()
  {
  	ExpressionNode parent = exprGetParent();
  	while((null != parent) && (parent instanceof Expression))
  		parent = parent.exprGetParent();
  	return parent;
  }
  
  
  
  
  public void exprSetParent(ExpressionNode n)
  {
  	assertion(n != this, ""Can not parent an expression to itself!"");
  	m_parent = n;
  }
  
  public ExpressionNode exprGetParent()
  {
  	return m_parent;
  }

  
  public void exprAddChild(ExpressionNode n, int i)
  {
  	assertion(false, ""exprAddChild method not implemented!"");
  }

  
  public ExpressionNode exprGetChild(int i)
  {
  	return null;
  }

  
  public int exprGetNumChildren()
  {
  	return 0;
  }
  
  

  
  public String getPublicId()
  {
  	if(null == m_parent)
  	  return null;
  	return m_parent.getPublicId();
  }

  
  public String getSystemId()
  {
  	if(null == m_parent)
  	  return null;
  	return m_parent.getSystemId();
  }

  
  public int getLineNumber()
  {
  	if(null == m_parent)
  	  return 0;
  	return m_parent.getLineNumber();
  }

  
  public int getColumnNumber()
  {
  	if(null == m_parent)
  	  return 0;
  	return m_parent.getColumnNumber();
  }
}
"
org.apache.xpath.functions.FuncSubstring,4,6,0,10,16,6,0,10,3,2.0,113,0.0,0,0.955223881,0.5,2,8,27.25,1,0.75,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xml.utils.XMLString;


public class FuncSubstring extends Function3Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XMLString s1 = m_arg0.execute(xctxt).xstr();
    double start = m_arg1.execute(xctxt).num();
    int lenOfS1 = s1.length();
    XMLString substr;

    if (lenOfS1 <= 0)
      return XString.EMPTYSTRING;
    else
    {
      int startIndex;

      if (Double.isNaN(start))
      {

        
        
        start = -1000000;
        startIndex = 0;
      }
      else
      {
        start = Math.round(start);
        startIndex = (start > 0) ? (int) start - 1 : 0;
      }

      if (null != m_arg2)
      {
        double len = m_arg2.num(xctxt);
        int end = (int) (Math.round(len) + start) - 1;

        
        if (end < 0)
          end = 0;
        else if (end > lenOfS1)
          end = lenOfS1;

        if (startIndex > lenOfS1)
          startIndex = lenOfS1;

        substr = s1.substring(startIndex, end);
      }
      else
      {
        if (startIndex > lenOfS1)
          startIndex = lenOfS1;
        substr = s1.substring(startIndex);
      }
    }

    return (XString)substr; 
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum < 2)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_TWO_OR_THREE, null)); 
  }
}
"
org.apache.xalan.xsltc.compiler.AttributeValueTemplate,7,4,0,25,49,21,4,22,5,2.0,452,0.0,0,0.923076923,0.339285714,2,7,63.57142857,14,5.1429,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class AttributeValueTemplate extends AttributeValue {

    public AttributeValueTemplate(String value, Parser parser, 
	SyntaxTreeNode parent) 
    {
	setParent(parent);
	setParser(parser);
	if (check(value, parser)) {
	    parseAVTemplate(0, value, parser);
	}
    }

    private void parseAVTemplate(final int start, String text, Parser parser) {
	String str;

	if (text == null) return;

	
	int open = start - 2;
	do {
	    open = text.indexOf('{', open+2);
	} while ((open != -1) && 
		 (open < (text.length()-1)) && 
		 (text.charAt(open+1) == '{'));

	if (open != -1) {
	    
	    int close = open - 2;
	    do {
		close = text.indexOf('}', close+2);
	    } while ((close != -1) && 
		     (close < (text.length()-1)) && 
		     (text.charAt(close+1) == '}'));
	    
	    
	    if (open > start) {
		str = removeDuplicateBraces(text.substring(start, open));
		addElement(new LiteralExpr(str));
	    }
	    
	    if (close > open + 1) {
		str = text.substring(open + 1, close);
		str = removeDuplicateBraces(text.substring(open+1,close));
		addElement(parser.parseExpression(this, str));
	    }
	    
	    parseAVTemplate(close + 1, text, parser);
	    
	}
	else if (start < text.length()) {
	    
	    str = removeDuplicateBraces(text.substring(start));
	    addElement(new LiteralExpr(str));
	}
    }

    public String removeDuplicateBraces(String orig) {
	String result = orig;
	int index;

	while ((index = result.indexOf(""{{"")) != -1) {
	    result = result.substring(0,index) + 
		result.substring(index+1,result.length());
	}

	while ((index = result.indexOf(""}}"")) != -1) {
	    result = result.substring(0,index) + 
		result.substring(index+1,result.length());
	}

	return(result);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Vector contents = getContents();
	final int n = contents.size();
	for (int i = 0; i < n; i++) {
	    final Expression exp = (Expression)contents.elementAt(i);
	    if (!exp.typeCheck(stable).identicalTo(Type.String)) {
		contents.setElementAt(new CastExpr(exp, Type.String), i);
	    }
	}
	return _type = Type.String;
    }

    public String toString() {
	final StringBuffer buffer = new StringBuffer(""AVT:["");
	final int count = elementCount();
	for (int i = 0; i < count; i++) {
	    buffer.append(elementAt(i).toString());
	    if (i < count - 1)
		buffer.append(' ');
	}
	return buffer.append(']').toString();
    }
		
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (elementCount() == 1) {
	    final Expression exp = (Expression)elementAt(0);
	    exp.translate(classGen, methodGen);
	}
	else {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();
	    final int initBuffer = cpg.addMethodref(STRING_BUFFER_CLASS,
						    ""<init>"", ""()V"");
	    final Instruction append =
		new INVOKEVIRTUAL(cpg.addMethodref(STRING_BUFFER_CLASS,
						   ""append"",
						   ""("" + STRING_SIG + "")""
						   + STRING_BUFFER_SIG));
	    
	    final int toString = cpg.addMethodref(STRING_BUFFER_CLASS,
						  ""toString"",
						  ""()""+STRING_SIG);
	    il.append(new NEW(cpg.addClass(STRING_BUFFER_CLASS)));
	    il.append(DUP);
	    il.append(new INVOKESPECIAL(initBuffer));
	    
	    final Enumeration enum = elements();
	    while (enum.hasMoreElements()) {
		final Expression exp = (Expression)enum.nextElement();
		exp.translate(classGen, methodGen);
		il.append(append);
	    }
	    il.append(new INVOKEVIRTUAL(toString));
	}
    }

    private boolean check(String value, Parser parser) {
	
	if (value == null) return true;

	final char[] chars = value.toCharArray();
	int level = 0;
	for (int i = 0; i < chars.length; i++) {
	    switch (chars[i]) {
	    case '{':
		if (((i+1) == (chars.length)) || (chars[i+1] != '{'))
		    ++level;
		else
		    i++;
		break;
	    case '}':	
		if (((i+1) == (chars.length)) || (chars[i+1] != '}'))
		    --level;
		else
		    i++;
		break;
	    default:
		continue;
	    }
	    switch (level) {
	    case 0:
	    case 1:
		continue;
	    default:
		reportError(getParent(), parser,
			    ErrorMsg.ATTR_VAL_TEMPLATE_ERR, value);
		return false;
	    }
	}
	if (level != 0) {
	    reportError(getParent(), parser,
			ErrorMsg.ATTR_VAL_TEMPLATE_ERR, value);
	    return false;
	}
	return true;
    }
}
"
org.apache.xalan.xsltc.compiler.util.NodeSortRecordFactGenerator,2,4,0,3,3,1,1,2,2,2.0,13,0.0,0,0.987804878,0.6,0,0,5.5,1,0.5,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

import org.apache.xalan.xsltc.compiler.Stylesheet;


public final class NodeSortRecordFactGenerator extends ClassGenerator {

    public NodeSortRecordFactGenerator(String className, String superClassName,
				   String fileName,
				   int accessFlags, String[] interfaces,
				   Stylesheet stylesheet) {
	super(className, superClassName, fileName,
	      accessFlags, interfaces, stylesheet);
    }
    
    
    public boolean isExternal() {
	return true;
    }
}
"
org.apache.xml.dtm.ref.DTMNodeList,5,1,0,8,17,0,6,2,4,0.4375,115,1.0,2,0.0,0.45,0,0,21.2,4,1.6,2,"
package org.apache.xml.dtm.ref;
import org.apache.xml.dtm.*;
import org.w3c.dom.Node;
import org.w3c.dom.DOMException;


public class DTMNodeList implements org.w3c.dom.NodeList
{
  private DTMIterator dtm_iter;
  private boolean valid=true;
  private int m_firstChild;
  private DTM m_parentDTM;

  
  

  
  public DTMNodeList(DTMIterator dtmIterator)
    {
      int pos = dtmIterator.getCurrentPos();
      try
      {
        dtm_iter=(DTMIterator)dtmIterator.cloneWithReset();
      }
      catch(CloneNotSupportedException cnse) {}
      dtm_iter.setShouldCacheNodes(true);
      dtm_iter.runTo(-1);
      dtm_iter.setCurrentPos(pos);
    }

  
  public DTMNodeList(DTM parentDTM,int parentHandle)
  {
    dtm_iter=null;
    m_parentDTM=parentDTM;
    m_firstChild=parentDTM.getFirstChild(parentHandle);
  }

  
  DTMIterator getDTMIterator()
    {
      return dtm_iter;
    }
  

  
  

    
    public Node item(int index)
    {
      if(dtm_iter!=null)
      {
        int handle=dtm_iter.item(index);
        return dtm_iter.getDTM(handle).getNode(handle);
      }
      else
      {
        int handle=m_firstChild;
        while(--index>=0 && handle!=DTM.NULL)
          handle=m_parentDTM.getNextSibling(handle);
        return m_parentDTM.getNode(handle);
      }
    }

    
    public int getLength()
    {
      if(dtm_iter!=null)
      {
        return dtm_iter.getLength();
      }
      else
      {
        int count=0;
        for(int handle=m_firstChild;
            handle!=DTM.NULL;
            handle=m_parentDTM.getNextSibling(handle))
          ++count;
        return count;
      }
    }
}
"
org.apache.xml.utils.NamespaceSupport2,11,2,0,5,26,0,4,2,11,0.55,127,0.5,1,0.583333333,0.409090909,1,3,10.36363636,3,1.3636,0,"
package org.apache.xml.utils;

import java.util.EmptyStackException;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;


public class NamespaceSupport2
    extends org.xml.sax.helpers.NamespaceSupport
{
    
    
    

    private Context2 currentContext; 


    
    
    


    
    public final static String XMLNS =
        ""http:


    
    
    


    
    public NamespaceSupport2 ()
    {
        reset();
    }


    
    
    


    
    public void reset ()
    {
        
        
        
        currentContext = new Context2(null);
        currentContext.declarePrefix(""xml"", XMLNS);
    }


    
    public void pushContext ()
    {
        
        
        
        

        Context2 parentContext=currentContext;
        currentContext = parentContext.getChild();
        if (currentContext == null){
                currentContext = new Context2(parentContext);
            }
        else{
            
            
            currentContext.setParent(parentContext);
        }
    }


    
    public void popContext ()
    {
        Context2 parentContext=currentContext.getParent();
        if(parentContext==null)
            throw new EmptyStackException();
        else
            currentContext = parentContext;
    }



    
    
    


    
    public boolean declarePrefix (String prefix, String uri)
    {
        if (prefix.equals(""xml"") || prefix.equals(""xmlns"")) {
            return false;
        } else {
            currentContext.declarePrefix(prefix, uri);
            return true;
        }
    }


    
    public String [] processName (String qName, String[] parts,
                                  boolean isAttribute)
    {
        String[] name=currentContext.processName(qName, isAttribute);
        if(name==null)
            return null;

        
        
        System.arraycopy(name,0,parts,0,3);
        return parts;
    }


    
    public String getURI (String prefix)
    {
        return currentContext.getURI(prefix);
    }


    
    public Enumeration getPrefixes ()
    {
        return currentContext.getPrefixes();
    }


    
    public String getPrefix (String uri)
    {
        return currentContext.getPrefix(uri);
    }


    
    public Enumeration getPrefixes (String uri)
    {
        
        
        
        
        
        
        
        
        
        
        return new PrefixForUriEnumerator(this,uri,getPrefixes());       
    }
    

    
    public Enumeration getDeclaredPrefixes ()
    {
        return currentContext.getDeclaredPrefixes();
    }



}








class PrefixForUriEnumerator implements Enumeration
{
    private Enumeration allPrefixes;
    private String uri;
    private String lookahead=null;
    private NamespaceSupport2 nsup;
     
    
    
    PrefixForUriEnumerator(NamespaceSupport2 nsup,String uri, Enumeration allPrefixes)
    {
	this.nsup=nsup;
        this.uri=uri;
        this.allPrefixes=allPrefixes;
    }
        
    public boolean hasMoreElements()
    {
        if(lookahead!=null)
            return true;
            
        while(allPrefixes.hasMoreElements())
            {
                String prefix=(String)allPrefixes.nextElement();
                if(uri.equals(nsup.getURI(prefix)))
                    {
                        lookahead=prefix;
                        return true;
                    }
            }
        return false;
    }
        
    public Object nextElement()
    {
        if(hasMoreElements())
            {
                String tmp=lookahead;
                lookahead=null;
                return tmp;
            }
        else
            throw new java.util.NoSuchElementException();
    }
}


final class Context2 {

    
    
    
        
    
    private final static Enumeration EMPTY_ENUMERATION =
        new Vector().elements();

    
    
    
        
    Hashtable prefixTable;
    Hashtable uriTable;
    Hashtable elementNameTable;
    Hashtable attributeNameTable;
    String defaultNS = null;

    
    
    
        
    private Vector declarations = null;
    private boolean tablesDirty = false;
    private Context2 parent = null;
    private Context2 child = null;

    
    Context2 (Context2 parent)
    {
        if(parent==null)
            {
                prefixTable = new Hashtable();
                uriTable = new Hashtable();
                elementNameTable=null; 
                attributeNameTable=null; 
            }
        else
            setParent(parent);
    }

        
    
    Context2 getChild()
    {
        return child;
    }
        
    
    Context2 getParent()
    {
        return parent;
    }
        
    
    void setParent (Context2 parent)
    {
        this.parent = parent;
        parent.child = this;        
        declarations = null;
        prefixTable = parent.prefixTable;
        uriTable = parent.uriTable;
        elementNameTable = parent.elementNameTable;
        attributeNameTable = parent.attributeNameTable;
        defaultNS = parent.defaultNS;
        tablesDirty = false;
    }
        
        
    
    void declarePrefix (String prefix, String uri)
    {
                                
        if (!tablesDirty) {
            copyTables();
        }
        if (declarations == null) {
            declarations = new Vector();
        }
            
        prefix = prefix.intern();
        uri = uri.intern();
        if ("""".equals(prefix)) {
            if ("""".equals(uri)) {
                defaultNS = null;
            } else {
                defaultNS = uri;
            }
        } else {
            prefixTable.put(prefix, uri);
            uriTable.put(uri, prefix); 
        }
        declarations.addElement(prefix);
    }


    
    String [] processName (String qName, boolean isAttribute)
    {
        String name[];
        Hashtable table;
            
                                
        if (isAttribute) {
            if(elementNameTable==null)
                elementNameTable=new Hashtable();
            table = elementNameTable;
        } else {
            if(attributeNameTable==null)
                attributeNameTable=new Hashtable();
            table = attributeNameTable;
        }
            
                                
                                
                                
        name = (String[])table.get(qName);
        if (name != null) {
            return name;
        }
            
                                
                                
        name = new String[3];
        int index = qName.indexOf(':');
            
            
                                
        if (index == -1) {
            if (isAttribute || defaultNS == null) {
                name[0] = """";
            } else {
                name[0] = defaultNS;
            }
            name[1] = qName.intern();
            name[2] = name[1];
        }
            
                                
        else {
            String prefix = qName.substring(0, index);
            String local = qName.substring(index+1);
            String uri;
            if ("""".equals(prefix)) {
                uri = defaultNS;
            } else {
                uri = (String)prefixTable.get(prefix);
            }
            if (uri == null) {
                return null;
            }
            name[0] = uri;
            name[1] = local.intern();
            name[2] = qName.intern();
        }
            
                                
        table.put(name[2], name);
        tablesDirty = true;
        return name;
    }
        

    
    String getURI (String prefix)
    {
        if ("""".equals(prefix)) {
            return defaultNS;
        } else if (prefixTable == null) {
            return null;
        } else {
            return (String)prefixTable.get(prefix);
        }
    }


    
    String getPrefix (String uri)
    {
        if (uriTable == null) {
            return null;
        } else {
            return (String)uriTable.get(uri);
        }
    }
        
        
    
    Enumeration getDeclaredPrefixes ()
    {
        if (declarations == null) {
            return EMPTY_ENUMERATION;
        } else {
            return declarations.elements();
        }
    }
        
        
    
    Enumeration getPrefixes ()
    {
        if (prefixTable == null) {
            return EMPTY_ENUMERATION;
        } else {
            return prefixTable.keys();
        }
    }
        
    
    
    

         
    private void copyTables ()
    {
        
        prefixTable = (Hashtable)prefixTable.clone();
        uriTable = (Hashtable)uriTable.clone();

        
        
        
        
        
        if(elementNameTable!=null)
            elementNameTable=new Hashtable(); 
        if(attributeNameTable!=null)
            attributeNameTable=new Hashtable(); 
        tablesDirty = true;
    }

}



"
org.apache.xalan.extensions.ExtensionHandlerJava,3,2,2,3,7,0,2,1,2,0.5,32,1.0,0,0.75,0.666666667,0,0,9.0,1,0.6667,0,"
package org.apache.xalan.extensions;

import java.util.Hashtable;


public abstract class ExtensionHandlerJava extends ExtensionHandler
{

  
  protected String m_className = """";

  
  private Hashtable m_cachedMethods = new Hashtable();

  
  protected ExtensionHandlerJava(String namespaceUri, String scriptLang,
                                 String className)
  {

    super(namespaceUri, scriptLang);

    m_className = className;
  }

  
  public Object getFromCache(Object methodKey, Object objType,
                             Object[] methodArgs)
  {

    
    return m_cachedMethods.get(methodKey);
  }

  
  public Object putToCache(Object methodKey, Object objType,
                           Object[] methodArgs, Object methodObj)
  {

    
    return m_cachedMethods.put(methodKey, methodObj);
  }
}
"
org.apache.xalan.xsltc.trax.Util,3,1,0,6,23,3,2,4,3,2.0,141,0.0,0,0.0,0.333333333,0,0,46.0,1,0.6667,1,"

package org.apache.xalan.xsltc.trax;

import java.io.Reader;
import java.io.InputStream;

import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;

import org.w3c.dom.Document;
import org.xml.sax.InputSource;

import org.apache.xalan.xsltc.compiler.XSLTC;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.SourceLoader;

public final class Util {

    public static String baseName(String name) {
	return org.apache.xalan.xsltc.compiler.util.Util.baseName(name);
    }

    
    public static InputSource getInputSource(XSLTC xsltc, Source source)
	throws TransformerConfigurationException 
    {
	InputSource input = null;

	String systemId = source.getSystemId();
	if (systemId == null) {
	    systemId = """";
	}

	try {
	    
	    if (source instanceof SAXSource) {
		final SAXSource sax = (SAXSource)source;
		input = sax.getInputSource();
		
		xsltc.setXMLReader(sax.getXMLReader());
	    }
	    
	    else if (source instanceof DOMSource) {
		final DOMSource domsrc = (DOMSource)source;
		final Document dom = (Document)domsrc.getNode();
		final DOM2SAX dom2sax = new DOM2SAX(dom);
		xsltc.setXMLReader(dom2sax);  

	        
		input = SAXSource.sourceToInputSource(source);
		if (input == null){
		    input = new InputSource(domsrc.getSystemId());
		}
	    }
	    
	    else if (source instanceof StreamSource) {
		final StreamSource stream = (StreamSource)source;
		final InputStream istream = stream.getInputStream();
		final Reader reader = stream.getReader();

		
		if (istream != null) {
		    input = new InputSource(istream);
		}
		else if (reader != null) {
		    input = new InputSource(reader);
		}
		else {
		    input = new InputSource(systemId);
		}
	    }
	    else {
		ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_SOURCE_ERR);
		throw new TransformerConfigurationException(err.toString());
	    }
	    input.setSystemId(systemId);
	}
	catch (NullPointerException e) {
 	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR,
					""TransformerFactory.newTemplates()"");
	    throw new TransformerConfigurationException(err.toString());
	}
	catch (SecurityException e) {
 	    ErrorMsg err = new ErrorMsg(ErrorMsg.FILE_ACCESS_ERR, systemId);
	    throw new TransformerConfigurationException(err.toString());
	}
	finally {
	    return input;
	}
    }

}

"
org.apache.xpath.axes.OneStepIteratorForward,6,7,2,13,16,0,4,10,4,0.2,94,1.0,0,0.97080292,0.4,4,10,14.5,3,1.1667,0,"package org.apache.xpath.axes;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xpath.Expression;
import org.apache.xpath.compiler.Compiler;


public class OneStepIteratorForward extends ChildTestIterator
{
  
  protected int m_axis = -1;

  
  OneStepIteratorForward(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis);
    int firstStepPos = compiler.getFirstChildPos(opPos);
    
    m_axis = WalkerFactory.getAxisFromStep(compiler, firstStepPos);
    
  }
    
  
  public OneStepIteratorForward(int axis)
  {
    super(null);
    
    m_axis = axis;
    int whatToShow = DTMFilter.SHOW_ALL;
    initNodeTest(whatToShow);
  }

  

  
  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    m_traverser = m_cdtm.getAxisTraverser(m_axis);
    
  }
  







































  
  
  protected int getNextNode()
  {
    m_lastFetched = (DTM.NULL == m_lastFetched)
                     ? m_traverser.first(m_context)
                     : m_traverser.next(m_context, m_lastFetched);
    return m_lastFetched;
  }
  
  
  public int getAxis()
  {
    return m_axis;
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(m_axis != ((OneStepIteratorForward)expr).m_axis)
  		return false;
  		
  	return true;
  }

  
}"
org.apache.xpath.objects.XNull,8,5,0,5,10,28,2,3,8,2.0,31,0.0,0,0.951048951,0.416666667,3,19,2.875,2,1.0,0,"
package org.apache.xpath.objects;




import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import org.apache.xpath.XPathContext;
import org.apache.xpath.NodeSetDTM;


public class XNull extends XNodeSet
{

  
  public XNull()
  {
    super();
  }

  
  public int getType()
  {
    return CLASS_NULL;
  }

  
  public String getTypeString()
  {
    return ""#CLASS_NULL"";
  }

  

  public double num()
  {
    return 0.0;
  }

  
  public boolean bool()
  {
    return false;
  }

  
  public String str()
  {
    return """";
  }

  
  public int rtf(XPathContext support)
  {
    
    
    return DTM.NULL;
  }











  
  public boolean equals(XObject obj2)
  {
    return obj2.getType() == CLASS_NULL;
  }
}
"
org.apache.xalan.templates.ElemOtherwise,3,3,0,1,4,3,0,1,3,2.0,10,0.0,0,0.98989899,1.0,2,4,2.333333333,1,0.6667,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;


public class ElemOtherwise extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_OTHERWISE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_OTHERWISE_STRING;
  }
}
"
org.apache.xpath.XPathVisitable,1,1,0,26,1,0,24,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xpath;


public interface XPathVisitable
{
	
	public void callVisitors(ExpressionOwner owner, XPathVisitor visitor);
}

"
org.apache.xalan.transformer.KeyIterator,4,8,0,10,15,2,2,8,3,0.333333333,97,1.0,1,0.978571429,0.4375,2,2,22.75,4,1.5,0,"
package org.apache.xalan.transformer;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.KeyDeclaration;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.QName;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.OneStepIteratorForward;


public class KeyIterator extends OneStepIteratorForward
{

  
  private QName m_name;

  
  public QName getName()
  {
    return m_name;
  }

  
  private Vector m_keyDeclarations;

  
  public Vector getKeyDeclarations()
  {
    return m_keyDeclarations;
  }

  
  KeyIterator(QName name, Vector keyDeclarations)
  {
    super(Axis.ALL);
    m_keyDeclarations = keyDeclarations;
    
    m_name = name;
  }

  
  public short acceptNode(int testNode)
  {
    boolean foundKey = false;
    KeyIterator ki = (KeyIterator) m_lpi;
    org.apache.xpath.XPathContext xctxt = ki.getXPathContext();
    Vector keys = ki.getKeyDeclarations();

    QName name = ki.getName();
    try
    {
      
      int nDeclarations = keys.size();

      
      for (int i = 0; i < nDeclarations; i++)
      {
        KeyDeclaration kd = (KeyDeclaration) keys.elementAt(i);

        
        
        if (!kd.getName().equals(name))
          continue;

        foundKey = true;
        

        
        
        XPath matchExpr = kd.getMatch();
        double score = matchExpr.getMatchScore(xctxt, testNode);

        if (score == kd.getMatch().MATCH_SCORE_NONE)
          continue;

        return DTMIterator.FILTER_ACCEPT;

      } 
    }
    catch (TransformerException se)
    {

      
    }

    if (!foundKey)
      throw new RuntimeException(
        XSLMessages.createMessage(
          XSLTErrorResources.ER_NO_XSLKEY_DECLARATION,
          new Object[] { name.getLocalName()}));
          
    return DTMIterator.FILTER_REJECT;
  }

}
"
org.apache.xpath.operations.Neg,3,3,0,6,7,3,1,5,3,2.0,19,0.0,0,0.952380952,0.555555556,1,1,5.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.XPathContext;


public class Neg extends UnaryOperation
{

  
  public XObject operate(XObject right) throws javax.xml.transform.TransformerException
  {
    return new XNumber(-right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return -(m_right.num(xctxt));
  }

}
"
org.apache.xml.dtm.ref.DTMNodeIterator,9,1,0,11,19,0,7,4,9,0.5,101,1.0,1,0.0,0.555555556,0,0,10.0,2,1.0,0,"
package org.apache.xml.dtm.ref;
import org.apache.xml.dtm.*;
import org.w3c.dom.Node;
import org.w3c.dom.DOMException;
import org.w3c.dom.traversal.*;


public class DTMNodeIterator implements org.w3c.dom.traversal.NodeIterator
{
  private DTMIterator dtm_iter;
  private boolean valid=true;

  
  

  
  public DTMNodeIterator(DTMIterator dtmIterator)
    {
      try
      {
        dtm_iter=(DTMIterator)dtmIterator.clone();
      }
      catch(CloneNotSupportedException cnse)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(cnse);
      }
    }

  
  public DTMIterator getDTMIterator()
    {
      return dtm_iter;
    }
  

  
  

  
  public void detach() 
    {
      
      
      
      valid=false;
    }

  
  public boolean getExpandEntityReferences()
    {
      return false;
    }
  
  
  public NodeFilter getFilter() 
    {
      throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
    }
  

  
  public Node getRoot()
    {
      int handle=dtm_iter.getRoot();
      return dtm_iter.getDTM(handle).getNode(handle);
    }
  

  
  public int getWhatToShow()
    {
      return dtm_iter.getWhatToShow();
    }

  
  public Node nextNode() throws DOMException
    {
      if(!valid)
        throw new DTMDOMException(DOMException.INVALID_STATE_ERR);
      
      int handle=dtm_iter.nextNode();
      if (handle==-1)
        return null;
      return dtm_iter.getDTM(handle).getNode(handle);
    }
  

  
  public Node previousNode() 
    {
      if(!valid)
        throw new DTMDOMException(DOMException.INVALID_STATE_ERR);
      
      int handle=dtm_iter.previousNode();
      return dtm_iter.getDTM(handle).getNode(handle);
    }
}
"
org.apache.xpath.functions.FuncFloor,2,4,0,5,7,1,0,5,2,2.0,15,0.0,0,0.979591837,0.75,1,6,6.5,1,0.5,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;


public class FuncFloor extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(java.lang.Math.floor(m_arg0.execute(xctxt).num()));
  }
}
"
org.apache.xalan.lib.ExsltCommon,3,1,0,6,6,3,0,6,3,2.0,41,0.0,0,0.0,0.444444444,0,0,12.66666667,6,2.3333,0,"
package org.apache.xalan.lib;

import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.w3c.dom.traversal.NodeIterator;

import org.apache.xpath.NodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XRTreeFrag;

import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.DOMHelper;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xml.utils.XMLString;

import org.xml.sax.SAXNotSupportedException;

import java.util.Hashtable;
import java.util.StringTokenizer;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.xslt.EnvironmentCheck;

import javax.xml.parsers.*;


public class ExsltCommon
{
  
  public static String objectType (Object obj)
  {
    if (obj instanceof String)
      return ""string"";
    else if (obj instanceof Boolean)
      return ""boolean"";
    else if (obj instanceof Number)
      return ""number"";
    else if (obj instanceof DTMNodeIterator)
    {
      DTMIterator dtmI = ((DTMNodeIterator)obj).getDTMIterator();
      if (dtmI instanceof org.apache.xpath.axes.RTFIterator)
      	return ""RTF"";
      else
        return ""node-set"";
    }
    else
      return ""unknown"";
  }
    
  
  public static NodeSet nodeSet(ExpressionContext myProcessor, Object rtf)
  {
    return Extensions.nodeset(myProcessor, rtf);
  }
 
}"
org.apache.xpath.VariableStack,22,1,0,27,42,0,20,9,21,0.682539683,476,0.333333333,2,0.0,0.365079365,0,0,20.36363636,3,1.0,0,"
package org.apache.xpath;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;


import javax.xml.transform.TransformerException;


public class VariableStack implements Cloneable
{

  
  public VariableStack()
  {
    reset();
  }

  
  public synchronized Object clone() throws CloneNotSupportedException
  {

    VariableStack vs = (VariableStack) super.clone();

    
    vs._stackFrames = (XObject[]) _stackFrames.clone();
    vs._links = (int[]) _links.clone();

    return vs;
  }

  
  XObject[] _stackFrames = new XObject[XPathContext.RECURSIONLIMIT * 2];

  
  int _frameTop;

  
  private int _currentFrameBottom;

  
  int[] _links = new int[XPathContext.RECURSIONLIMIT];

  
  int _linksTop;

  
  public XObject elementAt(final int i)
  {
    return _stackFrames[i];
  }

  
  public int size()
  {
    return _frameTop;
  }

  
  public void reset()
  {

    _frameTop = 0;
    _linksTop = 0;

    
    
    
    _links[_linksTop++] = 0;
    _stackFrames = new XObject[_stackFrames.length]; 
  }

  
  public void setStackFrame(int sf)
  {
    _currentFrameBottom = sf;
  }

  
  public int getStackFrame()
  {
    return _currentFrameBottom;
  }

  
  public int link(final int size)
  {

    _currentFrameBottom = _frameTop;
    _frameTop += size;

    if (_frameTop >= _stackFrames.length)
    {
      XObject newsf[] = new XObject[_stackFrames.length + (1024 * 4) + size];

      System.arraycopy(_stackFrames, 0, newsf, 0, _stackFrames.length);

      _stackFrames = newsf;
    }

    if (_linksTop + 1 >= _links.length)
    {
      int newlinks[] = new int[_links.length + (1024 * 2)];

      System.arraycopy(_links, 0, newlinks, 0, _links.length);

      _links = newlinks;
    }

    _links[_linksTop++] = _currentFrameBottom;

    return _currentFrameBottom;
  }

  
  public  void unlink()
  {
    _frameTop = _links[--_linksTop];
    _currentFrameBottom = _links[_linksTop - 1];
  }
  
  
  public  void unlink(int currentFrame)
  {
    _frameTop = _links[--_linksTop];
    _currentFrameBottom = currentFrame; 
  }

  
  public void setLocalVariable(int index, XObject val)
  {
    _stackFrames[index + _currentFrameBottom] = val;
  }

  
  public void setLocalVariable(int index, XObject val, int stackFrame)
  {
    _stackFrames[index + stackFrame] = val;
  }

  
  public XObject getLocalVariable(XPathContext xctxt, int index)
          throws TransformerException
  {

    index += _currentFrameBottom;

    XObject val = _stackFrames[index];
    
    if(null == val)
      throw new TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VARIABLE_ACCESSED_BEFORE_BIND, null),
                     xctxt.getSAXLocator());
      

    
    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)
      return (_stackFrames[index] = val.execute(xctxt));

    return val;
  }

  
  public XObject getLocalVariable(int index, int frame)
          throws TransformerException
  {

    index += frame;

    XObject val = _stackFrames[index];

    return val;
  }
  
  
  public XObject getLocalVariable(XPathContext xctxt, int index, boolean destructiveOK)
          throws TransformerException
  {

    index += _currentFrameBottom;

    XObject val = _stackFrames[index];
    
    if(null == val)
      throw new TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VARIABLE_ACCESSED_BEFORE_BIND, null),
                     xctxt.getSAXLocator());
      

    
    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)
      return (_stackFrames[index] = val.execute(xctxt));

    return destructiveOK ? val : val.getFresh();
  }

  
  public boolean isLocalSet(int index) throws TransformerException
  {
    return (_stackFrames[index + _currentFrameBottom] != null);
  }

  
  private static XObject[] m_nulls = new XObject[1024];

  
  public void clearLocalSlots(int start, int len)
  {

    start += _currentFrameBottom;

    System.arraycopy(m_nulls, 0, _stackFrames, start, len);
  }

  
  public void setGlobalVariable(final int index, final XObject val)
  {
    _stackFrames[index] = val;
  }

  
  public XObject getGlobalVariable(XPathContext xctxt, final int index)
          throws TransformerException
  {

    XObject val = _stackFrames[index];

    
    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)
      return (_stackFrames[index] = val.execute(xctxt));

    return val;
  }
  
  
  public XObject getGlobalVariable(XPathContext xctxt, final int index, boolean destructiveOK)
          throws TransformerException
  {

    XObject val = _stackFrames[index];

    
    if (val.getType() == XObject.CLASS_UNRESOLVEDVARIABLE)
      return (_stackFrames[index] = val.execute(xctxt));

    return destructiveOK ? val : val.getFresh();
  }

  
  public XObject getVariableOrParam(
          XPathContext xctxt, org.apache.xml.utils.QName qname)
            throws javax.xml.transform.TransformerException
  {

    org.apache.xml.utils.PrefixResolver prefixResolver =
      xctxt.getNamespaceContext();

    
    
    
    
    

    if (prefixResolver instanceof org.apache.xalan.templates.ElemTemplateElement)
    {
      
      org.apache.xalan.templates.ElemVariable vvar;

      org.apache.xalan.templates.ElemTemplateElement prev =
        (org.apache.xalan.templates.ElemTemplateElement) prefixResolver;

      if (!(prev instanceof org.apache.xalan.templates.Stylesheet))
      {
        while ( !(prev.getParentNode() instanceof org.apache.xalan.templates.Stylesheet) )
        {
          org.apache.xalan.templates.ElemTemplateElement savedprev = prev;

          while (null != (prev = prev.getPreviousSiblingElem()))
          {
            if (prev instanceof org.apache.xalan.templates.ElemVariable)
            {
              vvar = (org.apache.xalan.templates.ElemVariable) prev;

              if (vvar.getName().equals(qname))
                return getLocalVariable(xctxt, vvar.getIndex());
            }
          }
          prev = savedprev.getParentElem();
        }
      }

      vvar = prev.getStylesheetRoot().getVariableOrParamComposed(qname);
      if (null != vvar)
        return getGlobalVariable(xctxt, vvar.getIndex());
    }

    throw new javax.xml.transform.TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VAR_NOT_RESOLVABLE, new Object[]{qname.toString()})); 
  }
}  

"
org.apache.xpath.axes.OneStepIterator,12,7,0,16,35,6,3,14,8,0.409090909,230,1.0,1,0.93006993,0.291666667,4,13,18.0,5,1.6667,2,"package org.apache.xpath.axes;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.Compiler;


public class OneStepIterator extends ChildTestIterator
{
  
  protected int m_axis = -1;

  
  protected DTMAxisIterator m_iterator;

  
  OneStepIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis);
    int firstStepPos = compiler.getFirstChildPos(opPos);
    
    m_axis = WalkerFactory.getAxisFromStep(compiler, firstStepPos);
    
  }
  
  
  
  public OneStepIterator(DTMAxisIterator iterator, int axis)
          throws javax.xml.transform.TransformerException
  {
    super(null);
    
    m_iterator = iterator;
    m_axis = axis;
    int whatToShow = DTMFilter.SHOW_ALL;
    initNodeTest(whatToShow);
  }
  
  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    if(m_axis > -1)
      m_iterator = m_cdtm.getAxisIterator(m_axis);
    m_iterator.setStartNode(m_context);
  }
  
  
  protected int getNextNode()
  {
    return m_lastFetched = m_iterator.next();
  }
  
  
  public Object clone() throws CloneNotSupportedException
  {
    
    
    OneStepIterator clone = (OneStepIterator) super.clone();

    if(m_iterator != null)
    {
      clone.m_iterator = m_iterator.cloneIterator();
    }
    return clone;
  }
  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    OneStepIterator clone = (OneStepIterator) super.cloneWithReset();
    clone.m_iterator = m_iterator;

    return clone;
  }



  
  public boolean isReverseAxes()
  {
    return m_iterator.isReverse();
  }

  
  protected int getProximityPosition(int predicateIndex)
  {
    if(!isReverseAxes())
      return super.getProximityPosition(predicateIndex);
      
    
    
    
    if(predicateIndex < 0)
      return -1;
      
    if (m_proximityPositions[predicateIndex] <= 0)
    {
      XPathContext xctxt = getXPathContext();
      try
      {
        OneStepIterator clone = (OneStepIterator) this.clone();
        
        int root = getRoot();
        xctxt.pushCurrentNode(root);
        clone.setRoot(root, xctxt);

        
        clone.m_predCount = predicateIndex;

        
        int count = 1;
        int next;

        while (DTM.NULL != (next = clone.nextNode()))
        {
          count++;
        }

        m_proximityPositions[predicateIndex] += count;
      }
      catch (CloneNotSupportedException cnse)
      {

        
      }
      finally
      {
        xctxt.popCurrentNode();
      }
    }

    return m_proximityPositions[predicateIndex];
  }

  
  protected void countProximityPosition(int i)
  {
    if(!isReverseAxes())
      super.countProximityPosition(i);
    else if (i < m_proximityPositions.length)
      m_proximityPositions[i]--;
  }
  
  
  public void reset()
  {

    super.reset();
    if(null != m_iterator)
      m_iterator.reset();
  }
  
  
  public int getAxis()
  {
    return m_axis;
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(m_axis != ((OneStepIterator)expr).m_axis)
  		return false;
  		
  	return true;
  }

  
}
"
org.apache.xalan.xsltc.trax.TransformerHandlerImpl,29,1,0,10,73,114,2,8,29,0.846428571,394,1.0,4,0.0,0.237068966,0,0,12.24137931,1,0.9655,0,"

package org.apache.xalan.xsltc.trax;

import org.xml.sax.*;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.transform.*;
import javax.xml.transform.sax.*;

import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.TransletOutputHandler;
import org.apache.xalan.xsltc.dom.DOMImpl;
import org.apache.xalan.xsltc.dom.DOMBuilder;
import org.apache.xalan.xsltc.dom.DTDMonitor;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;


public class TransformerHandlerImpl implements TransformerHandler, DeclHandler {

    private TransformerImpl  _transformer;
    private AbstractTranslet _translet = null;
    private String           _systemId;
    private DOMImpl          _dom = null;
    private ContentHandler   _handler = null;
    private LexicalHandler   _lexHandler = null;
    private DTDMonitor       _dtd = null;
    private Result           _result = null;

    private boolean          _done = false; 

    
    private boolean _isIdentity = false;

    
    protected TransformerHandlerImpl(TransformerImpl transformer) {
	
	_transformer = transformer;

	if (transformer.isIdentity()) {
	    
	    _handler = new DefaultHandler();
	    _isIdentity = true;
	}
	else {
	    
	    _translet = _transformer.getTranslet();

	    
	    _dom = new DOMImpl();
	    _handler = _dom.getBuilder();
	    _lexHandler = (LexicalHandler) _handler;

	    
	    _dtd = new DTDMonitor();
	}
    }

    
    public String getSystemId() {
	return _systemId;
    }

    
    public void setSystemId(String id) {
	_systemId = id;
    }

    
    public Transformer getTransformer() {
	return _transformer;
    }

    
    public void setResult(Result result) throws IllegalArgumentException {
	_result = result;

	if (_isIdentity) {
	    try {
		
		TransletOutputHandler outputHandler =
		    _transformer.getOutputHandler(result);
		_transformer.transferOutputProperties(outputHandler);

		_handler = new SAX2TO(outputHandler);
		_lexHandler = (LexicalHandler) _handler;
	    }
	    catch (TransformerException e) {
		_result = null;
	    }
	}
	else if (_done) {
	    
	    try {
		_transformer.setDOM(_dom);
		_transformer.transform(null, _result);
	    }
	    catch (TransformerException e) {
		
		throw new IllegalArgumentException(e.getMessage());
	    }
	}
    }

    
    public void characters(char[] ch, int start, int length) 
	throws SAXException 
    {
	_handler.characters(ch, start, length);
    }

    
    public void startDocument() throws SAXException {
	
	if (_result == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_SET_RESULT_ERR);
	    throw new SAXException(err.toString());
	}

	if (!_isIdentity) {
	    
	    _dom.setDocumentURI(_systemId);
	}

	
	_handler.startDocument();
    }

    
    public void endDocument() throws SAXException {
	
	_handler.endDocument();

	if (!_isIdentity) {
	    
	    if (_result != null) {
		try {
		    _transformer.setDOM(_dom);
		    _transformer.setDTDMonitor(_dtd);	
		    _transformer.transform(null, _result);
		}
		catch (TransformerException e) {
		    throw new SAXException(e);
		}
	    }
	    
	    _done = true;

	    
	    _transformer.setDOM(_dom);
	}
    }
	
    
    public void startElement(String uri, String localName,
			     String qname, Attributes attributes)
	throws SAXException 
    {
	_handler.startElement(uri, localName, qname, attributes);
    }
	
    
    public void endElement(String namespaceURI, String localName, String qname)
	throws SAXException 
    {
	_handler.endElement(namespaceURI, localName, qname);
    }

    
    public void processingInstruction(String target, String data)
	throws SAXException 
    {
	_handler.processingInstruction(target, data);
    }

    
    public void startCDATA() throws SAXException { 
	if (_lexHandler != null) {
	    _lexHandler.startCDATA();
	}
    }

    
    public void endCDATA() throws SAXException { 
	if (_lexHandler != null) {
	    _lexHandler.endCDATA();
	}
    }

    
    public void comment(char[] ch, int start, int length) 
	throws SAXException 
    { 
	if (_lexHandler != null) {
	    _lexHandler.comment(ch, start, length);
	}
    }

    
    public void ignorableWhitespace(char[] ch, int start, int length)
	throws SAXException 
    {
	_handler.ignorableWhitespace(ch, start, length);
    }

    
    public void setDocumentLocator(Locator locator) {
	_handler.setDocumentLocator(locator);
    }

    
    public void skippedEntity(String name) throws SAXException {
	_handler.skippedEntity(name);
    }

    
    public void startPrefixMapping(String prefix, String uri) 
	throws SAXException {
	_handler.startPrefixMapping(prefix, uri);
    }

    
    public void endPrefixMapping(String prefix) throws SAXException {
	_handler.endPrefixMapping(prefix);
    }

    
    public void startDTD(String name, String publicId, String systemId) 
	throws SAXException
    { 
	if (_lexHandler != null) {
	    _lexHandler.startDTD(name, publicId, systemId);
	}
    }

    
    public void endDTD() throws SAXException {
	if (_lexHandler != null) {
	    _lexHandler.endDTD();
	}
    }

    
    public void startEntity(String name) throws SAXException { 
	if (_lexHandler != null) {
	    _lexHandler.startEntity(name);
	}
    }

    
    public void endEntity(String name) throws SAXException { 
	if (_lexHandler != null) {
	    _lexHandler.endEntity(name);
	}
    }

    
    public void unparsedEntityDecl(String name, String publicId, 
	String systemId, String notationName) throws SAXException 
    {
	_dtd.unparsedEntityDecl(name, publicId, systemId, notationName);
    }

    
    public void notationDecl(String name, String publicId, String systemId) 
	throws SAXException
    {
	_dtd.notationDecl(name, publicId, systemId);
    }

    
    public void attributeDecl(String eName, String aName, String type, 
	String valueDefault, String value) throws SAXException 
    {
	_dtd.attributeDecl(eName, aName, type, valueDefault, value);
    }

    
    public void elementDecl(String name, String model) 
	throws SAXException
    {
	_dtd.elementDecl(name, model);
    }

    
    public void externalEntityDecl(String name, String publicId, String systemId) 
	throws SAXException
    {
	_dtd.externalEntityDecl(name, publicId, systemId);
    }

    
    public void internalEntityDecl(String name, String value) 
	throws SAXException
    {
	_dtd.internalEntityDecl(name, value);
    }
}
"
org.apache.xml.utils.RawCharacterHandler,1,1,0,0,1,0,0,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xml.utils;


public interface RawCharacterHandler
{

  
  public void charactersRaw(char ch[], int start, int length)
    throws javax.xml.transform.TransformerException;
}
"
org.apache.xalan.processor.ProcessorText,3,5,0,7,10,3,1,6,2,2.0,40,0.0,0,0.990697674,0.583333333,2,4,12.33333333,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemText;

import javax.xml.transform.TransformerException;


public class ProcessorText extends ProcessorTemplateElem
{

  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    
    ProcessorCharacters charProcessor =
      (ProcessorCharacters) handler.getProcessorFor(null, ""text()"", ""text"");

    charProcessor.setXslTextElement((ElemText) elem);

    ElemTemplateElement parent = handler.getElemTemplateElement();

    parent.appendChild(elem);
    elem.setDOMBackPointer(handler.getOriginatingNode());
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    ProcessorCharacters charProcessor 
      = (ProcessorCharacters) handler.getProcessorFor(null, ""text()"", ""text"");

    charProcessor.setXslTextElement(null);

  }
}
"
org.apache.xalan.xsltc.runtime.ErrorMessages,4,2,1,1,9,2,1,0,3,0.666666667,91,1.0,0,0.942857143,0.666666667,2,3,21.25,3,1.0,1,"

package org.apache.xalan.xsltc.runtime;

import java.util.Vector;
import java.util.Enumeration;
import java.util.ResourceBundle;

public class ErrorMessages extends ResourceBundle {

    
    private static final String errorMessages[] = {
	
	""Run-time internal error in ''{0}''"",
	
	""Run-time error when executing <xsl:copy>."",
	
	""Invalid conversion from ''{0}'' to ''{1}''."",
	
	""External function ''{0}'' not supported by XSLTC."",
	
	""Unknown argument type in equality expression."",
	
	""Invalid argument type ''{0}'' in call to ''{1}''"",
	
	""Attempting to format number ''{0}'' using pattern ''{1}''."",
	
	""Cannot clone iterator ''{0}''."",
	
	""Iterator for axis ''{0}'' not supported."",
	
	""Iterator for typed axis ''{0}'' not supported."",
	
	""Attribute ''{0}'' outside of element."",
	
	""Namespace declaration ''{0}''=''{1}'' outside of element."",
	
	""Namespace for prefix ''{0}'' has not been declared."",
	
	""DOMAdapter created using wrong type of source DOM.""
    };

    private static Vector _keys;

    static {
	_keys = new Vector();
	_keys.addElement(BasisLibrary.ERROR_MESSAGES_KEY);
    }

    public Enumeration getKeys() {
	return _keys.elements();
    }

    public Object handleGetObject(String key) {
	if (key == null) return null;
	if (key.equals(BasisLibrary.ERROR_MESSAGES_KEY)) return errorMessages;
	return(null);
    }

}
"
org.apache.xml.utils.res.XResources_ja_JP_HA,3,4,0,1,4,1,0,1,2,0.5,599,0.0,0,0.976190476,1.0,0,0,198.3333333,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_ja_JP_HA extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ja"" }, { ""help_language"", ""ja"" }, { ""language"", ""ja"" },
    { ""alphabet"",
      new char[]{ 0x3042, 0x3044, 0x3046, 0x3048, 0x304a, 0x304b, 0x304d,
                  0x304f, 0x3051, 0x3053, 0x3055, 0x3057, 0x3059, 0x305b,
                  0x305d, 0x305f, 0x3061, 0x3064, 0x3066, 0x3068, 0x306a,
                  0x306b, 0x306c, 0x306d, 0x306e, 0x306f, 0x3072, 0x3075,
                  0x3078, 0x307b, 0x307e, 0x307f, 0x3080, 0x3081, 0x3082,
                  0x3084, 0x3086, 0x3088, 0x3089, 0x308a, 0x308b, 0x308c,
                  0x308d, 0x308f, 0x3090, 0x3091, 0x3092, 0x3093 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    
    
    { ""multiplier"",
      new long[]{ Long.MAX_VALUE, Long.MAX_VALUE, 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4EAC, 0x5146, 0x5104, 0x4E07, 0x5343, 0x767e, 0x5341 } },

    
    { ""zero"", new char[0] },
    { ""digits"",
      new char[]{ 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03,
                  0x516B, 0x4E5D } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xalan.templates.ElemUnknown,2,5,0,2,3,1,0,2,2,2.0,6,0.0,0,0.995833333,0.75,1,1,2.0,1,0.5,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;
import org.xml.sax.helpers.*;

import java.util.StringTokenizer;

import org.apache.xml.utils.QName;
import org.apache.xml.utils.NameSpace;
import org.apache.xpath.XPathContext;
import org.apache.xml.utils.StringToStringTable;
import org.apache.xml.utils.NameSpace;
import org.apache.xml.utils.StringVector;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultTreeHandler;

import java.io.*;

import java.util.*;

import javax.xml.transform.TransformerException;


public class ElemUnknown extends ElemLiteralResult
{

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException{}
}
"
org.apache.xalan.xsltc.compiler.PositionCall,4,4,0,20,20,0,1,20,4,0.333333333,149,1.0,0,0.979591837,0.45,2,4,36.0,10,2.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.DOM;

final class PositionCall extends FunctionCall {

    private int _type = -1;

    public PositionCall(QName fname) {
	super(fname);
    }

    public PositionCall(QName fname, int type) {
	this(fname);
	_type = type;
    }

    public boolean hasPositionCall() {
	return true;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final InstructionList il = methodGen.getInstructionList();

	SyntaxTreeNode parent = getParent();
	SyntaxTreeNode granny = parent.getParent();

	
	
	if ((parent instanceof Expression) && (granny instanceof Predicate)) {
	    _type = ((Predicate)granny).getPosType();
	}
	else {
	    while ((granny != null) && !(granny instanceof StepPattern)) {
		parent = granny;
		granny = granny.getParent();
	    }
	    if ((parent instanceof Predicate) &&
		(granny instanceof StepPattern)){
		_type = ((StepPattern)granny).getNodeType();
	    }
	}

	if (methodGen instanceof CompareGenerator) {
	    il.append(((CompareGenerator)methodGen).loadCurrentNode());
	}
	else if (methodGen instanceof TestGenerator) {
	    il.append(new ILOAD(POSITION_INDEX));
	}
	else if (_type == -1) {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final int getPosition = cpg.addInterfaceMethodref(NODE_ITERATOR,
							      ""getPosition"", 
							      ""()I"");
	    il.append(methodGen.loadIterator());
	    il.append(new INVOKEINTERFACE(getPosition, 1));
	}
	else {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    
	    final int pos = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getTypedPosition"",
						      ""(II)I"");
	    il.append(methodGen.loadDOM());
	    il.append(new PUSH(cpg, _type));
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(pos, 3));
	}
    }
}
"
org.apache.xalan.templates.ElemVariablePsuedo,3,4,0,8,9,1,1,7,3,0.5,26,0.0,1,0.99086758,0.555555556,0,0,7.333333333,1,0.6667,0,"package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPath;

public class ElemVariablePsuedo extends ElemVariable
{
  XUnresolvedVariableSimple m_lazyVar;
	
  
  public void setSelect(XPath v)
  {
    super.setSelect(v);
    m_lazyVar = new XUnresolvedVariableSimple(this);
  }
  
  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    
    

    
    transformer.getXPathContext().getVarStack().setLocalVariable(m_index, m_lazyVar);
  }

}

"
org.apache.xalan.templates.XSLTVisitor,9,2,1,21,10,36,20,6,1,2.0,28,0.0,0,0.6,0.314814815,0,0,2.111111111,1,0.8889,0,"
package org.apache.xalan.templates;

import org.apache.xpath.XPathVisitor;
import org.apache.xpath.ExpressionOwner;


public class XSLTVisitor extends XPathVisitor
{
	
	boolean visitInstruction(ElemTemplateElement elem)
	{
		return true;
	}
	
	
	boolean visitStylesheet(ElemTemplateElement elem)
	{
		return true;
	}

	
	
	boolean visitTopLevelInstruction(ElemTemplateElement elem)
	{
		return true;
	}
	
	
	boolean visitTopLevelVariableOrParamDecl(ElemTemplateElement elem)
	{
		return true;
	}

	
	
	boolean visitVariableOrParamDecl(ElemVariable elem)
	{
		return true;
	}
	
	
	boolean visitLiteralResultElement(ElemLiteralResult elem)
	{
		return true;
	}
	
	
	boolean visitAVT(AVT elem)
	{
		return true;
	}


	
	boolean visitExtensionElement(ElemExtensionCall elem)
	{
		return true;
	}

}

"
org.apache.xalan.xsltc.compiler.DocumentCall,3,4,0,26,33,0,0,26,3,0.166666667,264,1.0,3,0.979591837,0.444444444,4,15,86.0,3,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class DocumentCall extends FunctionCall {

    private Expression _uri = null;
    private Expression _base = null;
    private Type       _uriType;

    
    public DocumentCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	final int ac = argumentCount();
	if ((ac < 1) || (ac > 2)) {
	    ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_ARG_ERR, this);
	    throw new TypeCheckError(msg);
	}

	
	_uri = argument(0);
	if (_uri instanceof LiteralExpr) {
	    LiteralExpr expr = (LiteralExpr)_uri;
	    if (expr.getValue().equals(EMPTYSTRING)) {
		Stylesheet stylesheet = getStylesheet();
		if (stylesheet == null) {
		    ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_ARG_ERR, this);
		    throw new TypeCheckError(msg);
		}
		_uri = new LiteralExpr(stylesheet.getSystemId(), EMPTYSTRING);
	    }
	}

	_uriType = _uri.typeCheck(stable);
	if ((_uriType != Type.NodeSet) && (_uriType != Type.String)) {
	    _uri = new CastExpr(_uri, Type.String);
	}

	
	if (ac == 2) {
	    _base = argument(1);
	    final Type baseType = _base.typeCheck(stable);
	    
	    if (baseType.identicalTo(Type.Node)) {
		_base = new CastExpr(_base, Type.NodeSet);
	    }
	    else if (baseType.identicalTo(Type.NodeSet)) {
		
	    }
	    else {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.DOCUMENT_ARG_ERR, this);
		throw new TypeCheckError(msg);
	    }
	}

	return _type = Type.NodeSet;
    }
	
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final int domField = cpg.addFieldref(classGen.getClassName(),
					     DOM_FIELD,
					     DOM_INTF_SIG);
	final String docParamList =
	    ""(""+OBJECT_SIG+STRING_SIG+STRING_SIG+TRANSLET_SIG+DOM_INTF_SIG+"")""+
	    NODE_ITERATOR_SIG;
	final int docIdx = cpg.addMethodref(LOAD_DOCUMENT_CLASS,
					    ""document"", docParamList);

	final int uriIdx = cpg.addInterfaceMethodref(DOM_INTF,
						     ""getDocumentURI"",
						     ""(I)""+STRING_SIG);

	final int nextIdx = cpg.addInterfaceMethodref(NODE_ITERATOR,
						      NEXT, NEXT_SIG);

	
	_uri.translate(classGen, methodGen);
	if (_uriType == Type.NodeSet)
	    _uri.startResetIterator(classGen, methodGen);

	
	il.append(methodGen.loadDOM());
	if (_base != null) {
	    _base.translate(classGen, methodGen);
	    il.append(new INVOKEINTERFACE(nextIdx, 1));
	}
	else {
	     il.append(methodGen.loadContextNode());
	}
	il.append(new INVOKEINTERFACE(uriIdx, 2));
	il.append(new PUSH(cpg, getStylesheet().getSystemId()));

	
	il.append(classGen.loadTranslet());
	il.append(DUP);
	il.append(new GETFIELD(domField));
	il.append(new INVOKESTATIC(docIdx));
    }

}
"
org.apache.xalan.xsltc.dom.Axis,1,1,0,5,1,0,5,0,0,2.0,136,0.0,0,0.0,0.0,0,0,119.0,0,0.0,0,"

package org.apache.xalan.xsltc.dom;



public interface Axis {

    public static final int ANCESTOR         =  0;
    public static final int ANCESTORORSELF   =  1;
    public static final int ATTRIBUTE        =  2;
    public static final int CHILD            =  3;
    public static final int DESCENDANT       =  4;
    public static final int DESCENDANTORSELF =  5;
    public static final int FOLLOWING        =  6;
    public static final int FOLLOWINGSIBLING =  7;
    public static final int NAMESPACEDECLS   =  8;
    public static final int NAMESPACE        =  9;
    public static final int PARENT           = 10;
    public static final int PRECEDING        = 11;
    public static final int PRECEDINGSIBLING = 12;
    public static final int SELF             = 13;
	
    public static final String[] names = {
	""ancestor"",
	""ancestor-or-self"",
	""attribute"",
	""child"",
	""descendant"",
	""descendant-or-self"",
	""following"",
	""following-sibling"",
	""namespace"",
	""namespace-decls"",
	""parent"",
	""preceding"",
	""preceding-sibling"",
	""self""
    };

    public static final boolean[] isReverse = {
	true,  
	true,  
	false, 
	false, 
	false, 
	false, 
	false, 
	false, 
	false, 
	false, 
	false, 
	true,  
	true,  
	false  
    };
}
"
org.apache.xalan.xsltc.compiler.GenerateIdCall,2,4,0,13,13,1,0,13,2,2.0,43,0.0,0,0.989690722,0.6,2,4,20.5,2,1.0,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class GenerateIdCall extends FunctionCall {
    public GenerateIdCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	if (argumentCount() == 0) {
	    il.append(new ILOAD(methodGen.getLocalIndex(""current"")));
	}
	else {			
	    argument().translate(classGen, methodGen);
	}
	final ConstantPoolGen cpg = classGen.getConstantPool();
	il.append(new INVOKESTATIC(cpg.addMethodref(BASIS_LIBRARY_CLASS,
						    ""generate_idF"",
						    
						    GET_NODE_NAME_SIG)));
    }
}
"
org.apache.xalan.trace.TracerEvent,3,1,0,7,15,3,4,3,3,1.0,183,0.0,3,0.0,0.388888889,0,0,58.66666667,5,3.3333,0,"
package org.apache.xalan.trace;

import org.w3c.dom.*;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;


public class TracerEvent implements java.util.EventListener
{

  
  public final ElemTemplateElement m_styleNode;

  
  public final TransformerImpl m_processor;

  
  public final Node m_sourceNode;

  
  public final QName m_mode;

  
  public TracerEvent(TransformerImpl processor, Node sourceNode, QName mode,
                     ElemTemplateElement styleNode)
  {

    this.m_processor = processor;
    this.m_sourceNode = sourceNode;
    this.m_mode = mode;
    this.m_styleNode = styleNode;
  }

  
  public static String printNode(Node n)
  {

    String r = n.hashCode() + "" "";

    if (n instanceof Element)
    {
      r += ""<"" + n.getNodeName();

      Node c = n.getFirstChild();

      while (null != c)
      {
        if (c instanceof Attr)
        {
          r += printNode(c) + "" "";
        }

        c = c.getNextSibling();
      }

      r += "">"";
    }
    else
    {
      if (n instanceof Attr)
      {
        r += n.getNodeName() + ""="" + n.getNodeValue();
      }
      else
      {
        r += n.getNodeName();
      }
    }

    return r;
  }

  
  public static String printNodeList(NodeList l)
  {

    String r = l.hashCode() + ""["";
    int len = l.getLength() - 1;
    int i = 0;

    while (i < len)
    {
      Node n = l.item(i);

      if (null != n)
      {
        r += printNode(n) + "", "";
      }

      ++i;
    }

    if (i == len)
    {
      Node n = l.item(len);

      if (null != n)
      {
        r += printNode(n);
      }
    }

    return r + ""]"";
  }
}
"
org.apache.xalan.processor.ProcessorKey,3,4,0,10,34,3,1,9,1,2.0,169,0.0,0,0.990566038,0.666666667,1,1,55.33333333,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.KeyDeclaration;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import java.util.Vector;


class ProcessorKey extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    KeyDeclaration kd = new KeyDeclaration(handler.getStylesheet(), handler.nextUid());

    kd.setDOMBackPointer(handler.getOriginatingNode());
    kd.setLocaterInfo(handler.getLocator());
    setPropertiesFromAttributes(handler, rawName, attributes, kd);
    handler.getStylesheet().setKey(kd);
  }

  
  void setPropertiesFromAttributes(
          StylesheetHandler handler, String rawName, Attributes attributes, 
          org.apache.xalan.templates.ElemTemplateElement target)
            throws org.xml.sax.SAXException
  {

    XSLTElementDef def = getElemDef();

    
    
    Vector processedDefs = new Vector();
    int nAttrs = attributes.getLength();

    for (int i = 0; i < nAttrs; i++)
    {
      String attrUri = attributes.getURI(i);
      String attrLocalName = attributes.getLocalName(i);
      XSLTAttributeDef attrDef = def.getAttributeDef(attrUri, attrLocalName);

      if (null == attrDef)
      {

        
        handler.error(attributes.getQName(i)
                      + ""attribute is not allowed on the "" + rawName
                      + "" element!"", null);
      }
      else
      {
        String valueString = attributes.getValue(i);

        if (valueString.indexOf(org.apache.xpath.compiler.Keywords.FUNC_KEY_STRING
                                + ""("") >= 0)
          handler.error(
            XSLMessages.createMessage(
            XSLTErrorResources.ER_INVALID_KEY_CALL, null), null);

        processedDefs.addElement(attrDef);
        attrDef.setAttrValue(handler, attrUri, attrLocalName,
                             attributes.getQName(i), attributes.getValue(i),
                             target);
      }
    }

    XSLTAttributeDef[] attrDefs = def.getAttributes();
    int nAttrDefs = attrDefs.length;

    for (int i = 0; i < nAttrDefs; i++)
    {
      XSLTAttributeDef attrDef = attrDefs[i];
      String defVal = attrDef.getDefault();

      if (null != defVal)
      {
        if (!processedDefs.contains(attrDef))
        {
          attrDef.setDefAttrValue(handler, target);
        }
      }

      if (attrDef.getRequired())
      {
        if (!processedDefs.contains(attrDef))
          handler.error(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_REQUIRES_ATTRIB, new Object[]{ rawName,
                                                                   attrDef.getName() }), null);
      }
    }
  }
}
"
org.apache.xpath.objects.XRTreeFragSelectWrapper,10,4,0,8,23,25,1,7,10,0.555555556,86,0.0,1,0.905263158,0.28,3,22,7.5,2,1.0,2,"package org.apache.xpath.objects;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMFilter;

import org.apache.xml.utils.XMLString;

import org.apache.xpath.DOMHelper;
import org.apache.xpath.XPathContext;
import org.apache.xpath.Expression;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;


public class XRTreeFragSelectWrapper extends XRTreeFrag implements Cloneable
{
  XObject m_selected;

  public XRTreeFragSelectWrapper(Expression expr)
  {
    super(expr);
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    ((Expression)m_obj).fixupVariables(vars, globalsSize);
  }
  
  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    try
    {
      m_selected = ((Expression)m_obj).execute(xctxt);
      m_selected.allowDetachToRelease(m_allowRelease);
      XRTreeFragSelectWrapper xrtf = (XRTreeFragSelectWrapper)this.clone();
      return xrtf;
    }
    catch(CloneNotSupportedException cnse)
    {
      throw new javax.xml.transform.TransformerException(cnse);
    }
    
  }
  
  
  public void detach()
  {
    if(m_allowRelease)
    {
      m_selected.detach();
      m_selected = null;
    }
    
    super.detach();
  }
  
  
  public double num()
    throws javax.xml.transform.TransformerException
  {

    return m_selected.num();
  }

  
  
  public XMLString xstr()
  {
    return m_selected.xstr();
  }

  
  public String str()
  {
    return m_selected.str();
  }
  
  
  public int getType()
  {
    return CLASS_STRING; 
  }

  
  public int rtf()
  {
    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER, null)); 
  }

  
  public DTMIterator asNodeIterator()
  {
    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_RTF_NOT_SUPPORTED_XRTREEFRAGSELECTWRAPPER, null)); 
  }

}"
org.apache.xalan.transformer.KeyRefIterator,3,7,0,20,26,0,1,19,2,0.0,171,0.75,3,0.985185185,0.444444444,3,4,54.66666667,6,3.0,0,"
package org.apache.xalan.transformer;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.NodeVector;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;
import java.util.Vector;
import org.apache.xml.utils.QName;
import org.apache.xalan.templates.KeyDeclaration;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


public class KeyRefIterator extends org.apache.xpath.axes.ChildTestIterator
{
  
  public KeyRefIterator(QName name, XMLString ref, Vector keyDecls, DTMIterator ki)
  {
    super(null);
    m_name = name;
    m_ref = ref;
    m_keyDeclarations = keyDecls;
    m_keysNodes = ki;
    setWhatToShow(org.apache.xml.dtm.DTMFilter.SHOW_ALL);
  }
  
  DTMIterator m_keysNodes;
  
  
  protected int getNextNode()
  {                  
  	int next;   
    while(DTM.NULL != (next = m_keysNodes.nextNode()))
    {
    	if(DTMIterator.FILTER_ACCEPT == filterNode(next))
    		break;
    }
    m_lastFetched = next;
    
    return next;
  }


  
  public short filterNode(int testNode)
  {
    boolean foundKey = false;
    Vector keys = m_keyDeclarations;

    QName name = m_name;
    KeyIterator ki = (KeyIterator)(((XNodeSet)m_keysNodes).getContainedIter());
    org.apache.xpath.XPathContext xctxt = ki.getXPathContext();
    
    if(null == xctxt)
    	assertion(false, ""xctxt can not be null here!"");

    try
    {
      XMLString lookupKey = m_ref;

      
      int nDeclarations = keys.size();

      
      for (int i = 0; i < nDeclarations; i++)
      {
        KeyDeclaration kd = (KeyDeclaration) keys.elementAt(i);

        
        
        if (!kd.getName().equals(name))
          continue;

        foundKey = true;
        

        
        
        XObject xuse = kd.getUse().execute(xctxt, testNode, ki.getPrefixResolver());

        if (xuse.getType() != xuse.CLASS_NODESET)
        {
          XMLString exprResult = xuse.xstr();

          if (lookupKey.equals(exprResult))
            return DTMIterator.FILTER_ACCEPT;
        }
        else
        {
          DTMIterator nl = ((XNodeSet)xuse).iterRaw();
          int useNode;
          
          while (DTM.NULL != (useNode = nl.nextNode()))
          {
            DTM dtm = getDTM(useNode);
            XMLString exprResult = dtm.getStringValue(useNode);
            if ((null != exprResult) && lookupKey.equals(exprResult))
              return DTMIterator.FILTER_ACCEPT;
          }
        }

      } 
    }
    catch (javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }

    if (!foundKey)
      throw new RuntimeException(
        XSLMessages.createMessage(
          XSLTErrorResources.ER_NO_XSLKEY_DECLARATION,
          new Object[] { name.getLocalName()}));
    return DTMIterator.FILTER_REJECT;
  }

  protected XMLString m_ref;
  protected QName m_name;

  
  protected Vector m_keyDeclarations;

}"
org.apache.xalan.processor.ProcessorPreserveSpace,2,4,1,9,14,1,2,7,1,2.0,50,0.0,0,0.995260664,0.625,2,2,24.0,1,0.5,0,"
package org.apache.xalan.processor;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.WhiteSpaceInfo;
import org.apache.xpath.XPath;

import java.util.Vector;


class ProcessorPreserveSpace extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, 
          Attributes attributes)
            throws org.xml.sax.SAXException
  {
    Stylesheet thisSheet = handler.getStylesheet();
	WhitespaceInfoPaths paths = new WhitespaceInfoPaths(thisSheet);
    setPropertiesFromAttributes(handler, rawName, attributes, paths);

    Vector xpaths = paths.getElements();

    for (int i = 0; i < xpaths.size(); i++)
    {
      WhiteSpaceInfo wsi = new WhiteSpaceInfo((XPath) xpaths.elementAt(i), false, thisSheet);
      wsi.setUid(handler.nextUid());

      thisSheet.setPreserveSpaces(wsi);
    }
    paths.clearElements();
  }
}
"
org.apache.xpath.operations.Plus,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.XPathContext;


public class Plus extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() + right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (m_right.num(xctxt) + m_left.num(xctxt));
  }

}
"
org.apache.xalan.transformer.TreeWalker2Result,4,2,0,6,25,0,1,5,2,0.444444444,152,0.0,2,0.727272727,0.5625,1,4,36.25,1,0.75,0,"
package org.apache.xalan.transformer;

import org.w3c.dom.Node;
import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xml.dtm.ref.DTMTreeWalker;
import org.apache.xml.utils.MutableAttrListImpl;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xpath.DOMHelper;
import org.apache.xpath.XPathContext;


public class TreeWalker2Result extends DTMTreeWalker
{

  
  TransformerImpl m_transformer;

  
  ResultTreeHandler m_handler;

  
  int m_startNode;

  
  public TreeWalker2Result(TransformerImpl transformer,
                           ResultTreeHandler handler)
  {

    super(handler, null);

    m_transformer = transformer;
    m_handler = handler;
  }

  
  public void traverse(int pos) throws org.xml.sax.SAXException
  {
    m_dtm = m_transformer.getXPathContext().getDTM(pos);
    m_startNode = pos;

    super.traverse(pos);
  }
        
        
  protected void endNode(int node) throws org.xml.sax.SAXException
  {
    super.endNode(node);
    if(DTM.ELEMENT_NODE == m_dtm.getNodeType(node))
    {
      m_transformer.getXPathContext().popCurrentNode();
    }
  }

  
  protected void startNode(int node) throws org.xml.sax.SAXException
  {

    XPathContext xcntxt = m_transformer.getXPathContext();
    try
    {
      
      if (DTM.ELEMENT_NODE == m_dtm.getNodeType(node))
      {
        xcntxt.pushCurrentNode(node);                   
                                        
        if(m_startNode != node)
        {
          super.startNode(node);
        }
        else
        {
          String elemName = m_dtm.getNodeName(node);
          String localName = m_dtm.getLocalName(node);
          String namespace = m_dtm.getNamespaceURI(node);
                                        
          
          m_handler.startElement(namespace, localName, elemName, null);

          boolean hasNSDecls = false;
          DTM dtm = m_dtm;
          for (int ns = dtm.getFirstNamespaceNode(node, true); 
               DTM.NULL != ns; ns = dtm.getNextNamespaceNode(node, ns, true))
          {
            m_handler.ensureNamespaceDeclDeclared(dtm, ns);
          }
                                                
          
          
          if(hasNSDecls)
          {
            m_handler.addNSDeclsToAttrs();
          }
                                                
          for (int attr = dtm.getFirstAttribute(node); 
               DTM.NULL != attr; attr = dtm.getNextAttribute(attr))
          {
            m_handler.addAttribute(attr);
          }
        }
                                
      }
      else
      {
        xcntxt.pushCurrentNode(node);
        super.startNode(node);
        xcntxt.popCurrentNode();
      }
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }
}
"
org.apache.xalan.xsltc.compiler.IntExpr,4,3,0,13,14,0,0,13,4,0.333333333,44,1.0,0,0.959459459,0.4,2,7,9.75,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class IntExpr extends Expression {
    private final int _value;

    public IntExpr(int value) {
        _value = value;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _type = Type.Int;
    }

    public String toString() {
	return ""int-expr("" + _value + ')';
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }
}
"
org.apache.xalan.processor.ProcessorExsltFunction,6,5,0,16,27,15,1,15,4,2.0,193,0.0,0,0.97706422,0.533333333,2,4,31.16666667,6,1.6667,2,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemLiteralResult;
import org.apache.xalan.templates.ElemElement;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.ElemExtensionCall;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemExsltFunction;
import org.apache.xalan.templates.ElemExsltFuncResult;
import org.apache.xalan.templates.ElemFallback;
import org.apache.xalan.templates.ElemVariable;
import org.apache.xalan.templates.ElemParam;
import org.apache.xalan.templates.ElemValueOf;
import org.apache.xalan.templates.Constants;
import org.apache.xpath.XPath;
import org.apache.xalan.templates.StylesheetRoot;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerConfigurationException;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.apache.xalan.res.XSLTErrorResources;



public class ProcessorExsltFunction extends ProcessorTemplateElem
{
  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws SAXException
  {
    
    String msg = """";
    if (!(handler.getElemTemplateElement() instanceof StylesheetRoot))
    {
      msg = ""func:function element must be top level."";
      handler.error(msg, new SAXException(msg));
    }
    super.startElement(handler, uri, localName, rawName, attributes);
       
    String val = attributes.getValue(""name"");
    int indexOfColon = val.indexOf("":"");
    if (indexOfColon > 0)
    {
      String prefix = val.substring(0, indexOfColon);
      String localVal = val.substring(indexOfColon + 1);
      String ns = handler.getNamespaceSupport().getURI(prefix);
      
      
    }
    else
    {
      msg = ""func:function name must have namespace"";
      handler.error(msg, new SAXException(msg));
    }
  }
  
  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws SAXException
  {
    
    super.appendAndPush(handler, elem);
    
    elem.setDOMBackPointer(handler.getOriginatingNode());
    handler.getStylesheet().setTemplate((ElemTemplate) elem);
  }
    
  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws SAXException
  {
   ElemTemplateElement function = handler.getElemTemplateElement();
   SourceLocator locator = handler.getLocator();
   validate(function, handler); 
   super.endElement(handler, uri, localName, rawName);   
  }
  
  
  public void validate(ElemTemplateElement elem, StylesheetHandler handler)
    throws SAXException
  {
    String msg = """";
    while (elem != null)
    { 
      
      if (elem instanceof ElemExsltFuncResult 
          && elem.getNextSiblingElem() != null 
          && !(elem.getNextSiblingElem() instanceof ElemFallback))
      {
        msg = ""func:result has an illegal following sibling (only xsl:fallback allowed)"";
        handler.error(msg, new SAXException(msg));
      }
      if (elem instanceof ElemValueOf ||
          (elem instanceof ElemLiteralResult || elem instanceof ElemElement)
          && !(ancestorIsOk(elem)))
      {
        msg =""misplaced literal result in a func:function container."";
        handler.error(msg, new SAXException(msg));
      }
      ElemTemplateElement nextElem = elem.getFirstChildElem();
      while (nextElem == null)
      {
        nextElem = elem.getNextSiblingElem();
        if (nextElem == null)
          elem = elem.getParentElem();
        if (elem == null || elem instanceof ElemExsltFunction)
          return; 
      }  
      elem = nextElem;
    }
  }
  
  
  
  boolean ancestorIsOk(ElemTemplateElement child)
  {
    while (child.getParentElem() != null && !(child.getParentElem() instanceof ElemExsltFunction))
    {
      ElemTemplateElement parent = child.getParentElem();
      if (parent instanceof ElemExsltFuncResult 
          || parent instanceof ElemVariable
          || parent instanceof ElemParam)
        return true;
      child = parent;      
    }
    return false;
  }
  
}"
org.apache.xalan.templates.ElemChoose,6,3,0,9,26,15,0,9,6,2.0,160,0.0,0,0.975124378,0.444444444,2,5,25.66666667,4,1.3333,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.objects.XObject;
import org.apache.xalan.trace.SelectionEvent;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;


public class ElemChoose extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_CHOOSE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_CHOOSE_STRING;
  }

  
  public ElemChoose(){}

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    boolean found = false;

    for (ElemTemplateElement childElem = getFirstChildElem();
            childElem != null; childElem = childElem.getNextSiblingElem())
    {
      int type = childElem.getXSLToken();

      if (Constants.ELEMNAME_WHEN == type)
      {
        found = true;

        ElemWhen when = (ElemWhen) childElem;

        
        XPathContext xctxt = transformer.getXPathContext();
        int sourceNode = xctxt.getCurrentNode();
        
        
        
        
        

        if (TransformerImpl.S_DEBUG)
        {
          XObject test = when.getTest().execute(xctxt, sourceNode, when);

          if (TransformerImpl.S_DEBUG)
            transformer.getTraceManager().fireSelectedEvent(sourceNode, when,
                    ""test"", when.getTest(), test);

          if (test.bool())
          {
            transformer.getTraceManager().fireTraceEvent(when);
            
            transformer.executeChildTemplates(when, true);

	        transformer.getTraceManager().fireTraceEndEvent(when); 
	                  
            return;
          }

        }
        else if (when.getTest().bool(xctxt, sourceNode, when))
        {
          transformer.executeChildTemplates(when, true);

          return;
        }
      }
      else if (Constants.ELEMNAME_OTHERWISE == type)
      {
        found = true;

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(childElem);

        
        transformer.executeChildTemplates(childElem, true);

        if (TransformerImpl.S_DEBUG)
	      transformer.getTraceManager().fireTraceEndEvent(childElem); 
        return;
      }
    }

    if (!found)
      transformer.getMsgMgr().error(
        this, XSLTErrorResources.ER_CHOOSE_REQUIRES_WHEN);
        
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this);         
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {
    case Constants.ELEMNAME_WHEN :
    case Constants.ELEMNAME_OTHERWISE :

      
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
  
  
  public boolean canAcceptVariables()
  {
  	return false;
  }

}
"
org.apache.xpath.compiler.Keywords,3,1,0,4,9,1,4,0,2,1.456896552,583,0.896551724,0,0.0,0.5,0,0,174.0,3,1.0,0,"
package org.apache.xpath.compiler;

import java.util.Hashtable;


public class Keywords
{

  
  static Hashtable m_keywords = new Hashtable();

  
  static Hashtable m_axisnames = new Hashtable();

  
  static Hashtable m_functions = new Hashtable();

  
  static Hashtable m_nodetypes = new Hashtable();

  
  private static final String FROM_ANCESTORS_STRING = ""ancestor"";

  
  private static final String FROM_ANCESTORS_OR_SELF_STRING =
    ""ancestor-or-self"";

  
  private static final String FROM_ATTRIBUTES_STRING = ""attribute"";

  
  private static final String FROM_CHILDREN_STRING = ""child"";

  
  private static final String FROM_DESCENDANTS_STRING = ""descendant"";

  
  private static final String FROM_DESCENDANTS_OR_SELF_STRING =
    ""descendant-or-self"";

  
  private static final String FROM_FOLLOWING_STRING = ""following"";

  
  private static final String FROM_FOLLOWING_SIBLINGS_STRING =
    ""following-sibling"";

  
  private static final String FROM_PARENT_STRING = ""parent"";

  
  private static final String FROM_PRECEDING_STRING = ""preceding"";

  
  private static final String FROM_PRECEDING_SIBLINGS_STRING =
    ""preceding-sibling"";

  
  private static final String FROM_SELF_STRING = ""self"";

  
  private static final String FROM_NAMESPACE_STRING = ""namespace"";

  
  private static final String FROM_SELF_ABBREVIATED_STRING = ""."";

  
  private static final String NODETYPE_COMMENT_STRING = ""comment"";

  
  private static final String NODETYPE_TEXT_STRING = ""text"";

  
  private static final String NODETYPE_PI_STRING = ""processing-instruction"";

  
  private static final String NODETYPE_NODE_STRING = ""node"";

  
  private static final String NODETYPE_ANYELEMENT_STRING = ""*"";

  
  private static final String FUNC_CURRENT_STRING = ""current"";

  
  private static final String FUNC_LAST_STRING = ""last"";

  
  private static final String FUNC_POSITION_STRING = ""position"";

  
  private static final String FUNC_COUNT_STRING = ""count"";

  
  static final String FUNC_ID_STRING = ""id"";

  
  public static final String FUNC_KEY_STRING = ""key"";

  
  private static final String FUNC_LOCAL_PART_STRING = ""local-name"";

  
  private static final String FUNC_NAMESPACE_STRING = ""namespace-uri"";

  
  private static final String FUNC_NAME_STRING = ""name"";

  
  private static final String FUNC_GENERATE_ID_STRING = ""generate-id"";

  
  private static final String FUNC_NOT_STRING = ""not"";

  
  private static final String FUNC_TRUE_STRING = ""true"";

  
  private static final String FUNC_FALSE_STRING = ""false"";

  
  private static final String FUNC_BOOLEAN_STRING = ""boolean"";

  
  private static final String FUNC_LANG_STRING = ""lang"";

  
  private static final String FUNC_NUMBER_STRING = ""number"";

  
  private static final String FUNC_FLOOR_STRING = ""floor"";

  
  private static final String FUNC_CEILING_STRING = ""ceiling"";

  
  private static final String FUNC_ROUND_STRING = ""round"";

  
  private static final String FUNC_SUM_STRING = ""sum"";

  
  private static final String FUNC_STRING_STRING = ""string"";

  
  private static final String FUNC_STARTS_WITH_STRING = ""starts-with"";

  
  private static final String FUNC_CONTAINS_STRING = ""contains"";

  
  private static final String FUNC_SUBSTRING_BEFORE_STRING =
    ""substring-before"";

  
  private static final String FUNC_SUBSTRING_AFTER_STRING = ""substring-after"";

  
  private static final String FUNC_NORMALIZE_SPACE_STRING = ""normalize-space"";

  
  private static final String FUNC_TRANSLATE_STRING = ""translate"";

  
  private static final String FUNC_CONCAT_STRING = ""concat"";

  
  private static final String FUNC_SYSTEM_PROPERTY_STRING = ""system-property"";

  
  private static final String FUNC_EXT_FUNCTION_AVAILABLE_STRING =
    ""function-available"";

  
  private static final String FUNC_EXT_ELEM_AVAILABLE_STRING =
    ""element-available"";

  
  private static final String FUNC_SUBSTRING_STRING = ""substring"";

  
  private static final String FUNC_STRING_LENGTH_STRING = ""string-length"";

  
  private static final String FUNC_UNPARSED_ENTITY_URI_STRING =
    ""unparsed-entity-uri"";

  

  
  private static final String FUNC_DOCLOCATION_STRING = ""document-location"";

  static
  {
    m_axisnames.put(FROM_ANCESTORS_STRING,
                    new Integer(OpCodes.FROM_ANCESTORS));
    m_axisnames.put(FROM_ANCESTORS_OR_SELF_STRING,
                    new Integer(OpCodes.FROM_ANCESTORS_OR_SELF));
    m_axisnames.put(FROM_ATTRIBUTES_STRING,
                    new Integer(OpCodes.FROM_ATTRIBUTES));
    m_axisnames.put(FROM_CHILDREN_STRING,
                    new Integer(OpCodes.FROM_CHILDREN));
    m_axisnames.put(FROM_DESCENDANTS_STRING,
                    new Integer(OpCodes.FROM_DESCENDANTS));
    m_axisnames.put(FROM_DESCENDANTS_OR_SELF_STRING,
                    new Integer(OpCodes.FROM_DESCENDANTS_OR_SELF));
    m_axisnames.put(FROM_FOLLOWING_STRING,
                    new Integer(OpCodes.FROM_FOLLOWING));
    m_axisnames.put(FROM_FOLLOWING_SIBLINGS_STRING,
                    new Integer(OpCodes.FROM_FOLLOWING_SIBLINGS));
    m_axisnames.put(FROM_PARENT_STRING,
                    new Integer(OpCodes.FROM_PARENT));
    m_axisnames.put(FROM_PRECEDING_STRING,
                    new Integer(OpCodes.FROM_PRECEDING));
    m_axisnames.put(FROM_PRECEDING_SIBLINGS_STRING,
                    new Integer(OpCodes.FROM_PRECEDING_SIBLINGS));
    m_axisnames.put(FROM_SELF_STRING,
                    new Integer(OpCodes.FROM_SELF));
    m_axisnames.put(FROM_NAMESPACE_STRING,
                    new Integer(OpCodes.FROM_NAMESPACE));
    m_nodetypes.put(NODETYPE_COMMENT_STRING,
                    new Integer(OpCodes.NODETYPE_COMMENT));
    m_nodetypes.put(NODETYPE_TEXT_STRING,
                    new Integer(OpCodes.NODETYPE_TEXT));
    m_nodetypes.put(NODETYPE_PI_STRING,
                    new Integer(OpCodes.NODETYPE_PI));
    m_nodetypes.put(NODETYPE_NODE_STRING,
                    new Integer(OpCodes.NODETYPE_NODE));
    m_nodetypes.put(NODETYPE_ANYELEMENT_STRING,
                    new Integer(OpCodes.NODETYPE_ANYELEMENT));
    m_keywords.put(FROM_SELF_ABBREVIATED_STRING,
                   new Integer(OpCodes.FROM_SELF));
    m_keywords.put(FUNC_ID_STRING,
                   new Integer(FunctionTable.FUNC_ID));
    m_keywords.put(FUNC_KEY_STRING,
                   new Integer(FunctionTable.FUNC_KEY));
    m_functions.put(FUNC_CURRENT_STRING,
                    new Integer(FunctionTable.FUNC_CURRENT));
    m_functions.put(FUNC_LAST_STRING,
                    new Integer(FunctionTable.FUNC_LAST));
    m_functions.put(FUNC_POSITION_STRING,
                    new Integer(FunctionTable.FUNC_POSITION));
    m_functions.put(FUNC_COUNT_STRING,
                    new Integer(FunctionTable.FUNC_COUNT));
    m_functions.put(FUNC_ID_STRING,
                    new Integer(FunctionTable.FUNC_ID));
    m_functions.put(FUNC_KEY_STRING,
                    new Integer(FunctionTable.FUNC_KEY));
    m_functions.put(FUNC_LOCAL_PART_STRING,
                    new Integer(FunctionTable.FUNC_LOCAL_PART));
    m_functions.put(FUNC_NAMESPACE_STRING,
                    new Integer(FunctionTable.FUNC_NAMESPACE));
    m_functions.put(FUNC_NAME_STRING,
                    new Integer(FunctionTable.FUNC_QNAME));
    m_functions.put(FUNC_GENERATE_ID_STRING,
                    new Integer(FunctionTable.FUNC_GENERATE_ID));
    m_functions.put(FUNC_NOT_STRING,
                    new Integer(FunctionTable.FUNC_NOT));
    m_functions.put(FUNC_TRUE_STRING,
                    new Integer(FunctionTable.FUNC_TRUE));
    m_functions.put(FUNC_FALSE_STRING,
                    new Integer(FunctionTable.FUNC_FALSE));
    m_functions.put(FUNC_BOOLEAN_STRING,
                    new Integer(FunctionTable.FUNC_BOOLEAN));
    m_functions.put(FUNC_LANG_STRING,
                    new Integer(FunctionTable.FUNC_LANG));
    m_functions.put(FUNC_NUMBER_STRING,
                    new Integer(FunctionTable.FUNC_NUMBER));
    m_functions.put(FUNC_FLOOR_STRING,
                    new Integer(FunctionTable.FUNC_FLOOR));
    m_functions.put(FUNC_CEILING_STRING,
                    new Integer(FunctionTable.FUNC_CEILING));
    m_functions.put(FUNC_ROUND_STRING,
                    new Integer(FunctionTable.FUNC_ROUND));
    m_functions.put(FUNC_SUM_STRING,
                    new Integer(FunctionTable.FUNC_SUM));
    m_functions.put(FUNC_STRING_STRING,
                    new Integer(FunctionTable.FUNC_STRING));
    m_functions.put(FUNC_STARTS_WITH_STRING,
                    new Integer(FunctionTable.FUNC_STARTS_WITH));
    m_functions.put(FUNC_CONTAINS_STRING,
                    new Integer(FunctionTable.FUNC_CONTAINS));
    m_functions.put(FUNC_SUBSTRING_BEFORE_STRING,
                    new Integer(FunctionTable.FUNC_SUBSTRING_BEFORE));
    m_functions.put(FUNC_SUBSTRING_AFTER_STRING,
                    new Integer(FunctionTable.FUNC_SUBSTRING_AFTER));
    m_functions.put(FUNC_NORMALIZE_SPACE_STRING,
                    new Integer(FunctionTable.FUNC_NORMALIZE_SPACE));
    m_functions.put(FUNC_TRANSLATE_STRING,
                    new Integer(FunctionTable.FUNC_TRANSLATE));
    m_functions.put(FUNC_CONCAT_STRING,
                    new Integer(FunctionTable.FUNC_CONCAT));

    
    m_functions.put(FUNC_SYSTEM_PROPERTY_STRING,
                    new Integer(FunctionTable.FUNC_SYSTEM_PROPERTY));
    m_functions.put(FUNC_EXT_FUNCTION_AVAILABLE_STRING,
                    new Integer(FunctionTable.FUNC_EXT_FUNCTION_AVAILABLE));
    m_functions.put(FUNC_EXT_ELEM_AVAILABLE_STRING,
                    new Integer(FunctionTable.FUNC_EXT_ELEM_AVAILABLE));
    m_functions.put(FUNC_SUBSTRING_STRING,
                    new Integer(FunctionTable.FUNC_SUBSTRING));
    m_functions.put(FUNC_STRING_LENGTH_STRING,
                    new Integer(FunctionTable.FUNC_STRING_LENGTH));
    m_functions.put(FUNC_UNPARSED_ENTITY_URI_STRING,
                    new Integer(FunctionTable.FUNC_UNPARSED_ENTITY_URI));

    
    m_functions.put(NODETYPE_COMMENT_STRING,
                    new Integer(OpCodes.NODETYPE_COMMENT));
    m_functions.put(NODETYPE_TEXT_STRING,
                    new Integer(OpCodes.NODETYPE_TEXT));
    m_functions.put(NODETYPE_PI_STRING,
                    new Integer(OpCodes.NODETYPE_PI));
    m_functions.put(NODETYPE_NODE_STRING,
                    new Integer(OpCodes.NODETYPE_NODE));
    m_functions.put(FUNC_DOCLOCATION_STRING,
                    new Integer(FunctionTable.FUNC_DOCLOCATION));
  }

  
  public static boolean functionAvailable(String methName)
  {

    try
    {
      Object tblEntry = m_functions.get(methName);

      if (null == tblEntry)
        return false;

      int funcType = ((Integer) tblEntry).intValue();

      switch (funcType)
      {
      case OpCodes.NODETYPE_COMMENT :
      case OpCodes.NODETYPE_TEXT :
      case OpCodes.NODETYPE_PI :
      case OpCodes.NODETYPE_NODE :
        return false;  
      default :
        return true;
      }
    }
    catch (Exception e)
    {
      return false;
    }
  }
}
"
org.apache.xpath.functions.FuncExtFunctionAvailable,2,4,0,8,14,1,0,8,2,2.0,72,0.0,0,0.979591837,0.75,2,7,35.0,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xml.utils.PrefixResolver;
import org.apache.xalan.templates.Constants;





import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.ExtensionsProvider;
import org.apache.xpath.compiler.Keywords;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class FuncExtFunctionAvailable extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String prefix;
    String namespace;
    String methName;

    String fullName = m_arg0.execute(xctxt).str();
    int indexOfNSSep = fullName.indexOf(':');

    if (indexOfNSSep < 0)
    {
      prefix = """";
      namespace = Constants.S_XSLNAMESPACEURL;
      methName = fullName;
    }
    else
    {
      prefix = fullName.substring(0, indexOfNSSep);
      namespace = xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);
      if (null == namespace)
        return XBoolean.S_FALSE;
        methName = fullName.substring(indexOfNSSep + 1);
    }

    if (namespace.equals(Constants.S_XSLNAMESPACEURL))
    {
      try
      {
        return Keywords.functionAvailable(methName) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
      }
      catch (Exception e)
      {
        return XBoolean.S_FALSE;
      }
    }
    else
    {
      
      ExtensionsProvider extProvider = (ExtensionsProvider)xctxt.getOwnerObject();
      return extProvider.functionAvailable(namespace, methName)
             ? XBoolean.S_TRUE : XBoolean.S_FALSE;
    }
  }
}
"
org.apache.xalan.xsltc.compiler.TransletOutput,5,3,0,20,30,0,0,20,4,0.75,144,1.0,1,0.933333333,0.333333333,2,6,27.4,3,1.2,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class TransletOutput extends Instruction {

    private Expression _filename;

    private final static String MISSING_FILE_ATTR =
	""The <xsltc:output> element requires a 'file' attribute."";

    
    public void display(int indent) {
	indent(indent);
	Util.println(""TransletOutput: "" + _filename);
    }
		
    
    public void parseContents(Parser parser) {
	
	String filename = getAttribute(""file"");

	
	if ((filename == null) || (filename.equals(EMPTYSTRING))) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""file"");
	}

	
	_filename = AttributeValue.create(this, filename, parser);
	parseChildren(parser);
    }
    
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type type = _filename.typeCheck(stable);
	if (type instanceof StringType == false) {
	    _filename = new CastExpr(_filename, Type.String);
	}
	typeCheckContents(stable);
	return Type.Void;
    }
    
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	
	final int open =  cpg.addMethodref(TRANSLET_CLASS,
					   ""openOutputHandler"",
					   ""(""+STRING_SIG+"")""+
					   TRANSLET_OUTPUT_SIG);

	final int close =  cpg.addMethodref(TRANSLET_CLASS,
					    ""closeOutputHandler"",
					    ""(""+TRANSLET_OUTPUT_SIG+"")V"");

	
	il.append(classGen.loadTranslet());
	_filename.translate(classGen, methodGen);
	il.append(new INVOKEVIRTUAL(open));

	
	il.append(methodGen.storeHandler());
	
	
	translateContents(classGen, methodGen);

	
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadHandler());
	il.append(new INVOKEVIRTUAL(close));

	
	il.append(methodGen.storeHandler());
    }
}

"
org.apache.xalan.lib.Extensions,12,1,0,15,62,66,2,13,9,0.909090909,477,0.0,0,0.0,0.25,0,0,38.58333333,5,2.0,1,"
package org.apache.xalan.lib;

import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.w3c.dom.traversal.NodeIterator;

import org.apache.xpath.NodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.DOMHelper;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xml.utils.XMLString;

import org.xml.sax.SAXNotSupportedException;

import java.util.Hashtable;
import java.util.StringTokenizer;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


import org.apache.xalan.xslt.EnvironmentCheck;

import javax.xml.parsers.*;


public class Extensions
{

  
  private Extensions(){}  

  
  public static NodeSet nodeset(ExpressionContext myProcessor, Object rtf)
  {

    String textNodeValue;

    if (rtf instanceof NodeIterator)
    {
      return new NodeSet((NodeIterator) rtf);
    }
    else
    {
      if (rtf instanceof String)
      {
        textNodeValue = (String) rtf;
      }
      else if (rtf instanceof Boolean)
      {
        textNodeValue = new XBoolean(((Boolean) rtf).booleanValue()).str();
      }
      else if (rtf instanceof Double)
      {
        textNodeValue = new XNumber(((Double) rtf).doubleValue()).str();
      }
      else
      {
        textNodeValue = rtf.toString();
      }

      
      
      try
      {
        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
        DocumentBuilder db = dbf.newDocumentBuilder();
        Document myDoc = db.newDocument();
        
        Text textNode = myDoc.createTextNode(textNodeValue);
        DocumentFragment docFrag = myDoc.createDocumentFragment();
  
        docFrag.appendChild(textNode);
  
        return new NodeSet(docFrag);
      }
      catch(ParserConfigurationException pce)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(pce);
      }
    }
  }

  
  public static NodeSet intersection(NodeIterator ni1, NodeIterator ni2)
          throws javax.xml.transform.TransformerException
  {

    NodeSet ns1 = new NodeSet(ni1);
    NodeSet ns2 = new NodeSet(ni2);
    NodeSet inter = new NodeSet();

    inter.setShouldCacheNodes(true);

    for (int i = 0; i < ns1.getLength(); i++)
    {
      Node n = ns1.elementAt(i);

      if (ns2.contains(n))
        inter.addElement(n);
    }

    return inter;
  }

  
  public static NodeSet difference(NodeIterator ni1, NodeIterator ni2)
          throws javax.xml.transform.TransformerException
  {

    NodeSet ns1 = new NodeSet(ni1);
    NodeSet ns2 = new NodeSet(ni2);

    
    NodeSet diff = new NodeSet();

    diff.setShouldCacheNodes(true);

    for (int i = 0; i < ns1.getLength(); i++)
    {
      Node n = ns1.elementAt(i);

      if (!ns2.contains(n))
        diff.addElement(n);
    }

    return diff;
  }

  
  public static NodeSet distinct(ExpressionContext myContext, NodeIterator ni)
          throws javax.xml.transform.TransformerException
  {

    
    

    NodeSet dist = new NodeSet();
    dist.setShouldCacheNodes(true);

    Hashtable stringTable = new Hashtable();

    Node currNode = ni.nextNode();

    while (currNode != null)
    {
      String key = myContext.toString(currNode);

      if (!stringTable.containsKey(key))
      {
        stringTable.put(key, currNode);
        dist.addElement(currNode);
      }
      currNode = ni.nextNode();
    }

    return dist;
  }

  
  public static boolean hasSameNodes(NodeIterator ni1, NodeIterator ni2)
  {

    NodeSet ns1 = new NodeSet(ni1);
    NodeSet ns2 = new NodeSet(ni2);

    if (ns1.getLength() != ns2.getLength())
      return false;

    for (int i = 0; i < ns1.getLength(); i++)
    {
      Node n = ns1.elementAt(i);

      if (!ns2.contains(n))
        return false;
    }

    return true;
  }

  
  public static XObject evaluate(
          ExpressionContext myContext, String xpathExpr)
            throws SAXNotSupportedException, Exception
  {

    if (myContext instanceof XPathContext.XPathExpressionContext)
    {
      try
      {
        XPathContext xctxt =
                    ((XPathContext.XPathExpressionContext) myContext).getXPathContext();
        XPath dynamicXPath = new XPath(xpathExpr, xctxt.getSAXLocator(),
                                       xctxt.getNamespaceContext(),
                                       XPath.SELECT);

        return dynamicXPath.execute(xctxt, myContext.getContextNode(),
                                    xctxt.getNamespaceContext());
      }
      catch (Exception e)
      {
        throw e;
      }
    }
    else
      throw new SAXNotSupportedException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_CONTEXT_PASSED, new Object[]{myContext })); 
                                         
  }

  
  public static NodeSet tokenize(ExpressionContext myContext,
                                 String toTokenize, String delims)
  {

    Document lDoc;

    
    try
    {
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
      DocumentBuilder db = dbf.newDocumentBuilder();
      lDoc = db.newDocument();
    }
    catch(ParserConfigurationException pce)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(pce);
    }

    StringTokenizer lTokenizer = new StringTokenizer(toTokenize, delims);
    NodeSet resultSet = new NodeSet();

    while (lTokenizer.hasMoreTokens())
    {
      resultSet.addNode(lDoc.createTextNode(lTokenizer.nextToken()));
    }

    return resultSet;
  }

  
  public static NodeSet tokenize(ExpressionContext myContext,
                                 String toTokenize)
  {
    return tokenize(myContext, toTokenize, "" 	

"");
  }

  
  public static Node checkEnvironment(ExpressionContext myContext)
  {

    Document factoryDocument;
    try
    {
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();
      DocumentBuilder db = dbf.newDocumentBuilder();
      factoryDocument = db.newDocument();
    }
    catch(ParserConfigurationException pce)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(pce);
    }

    Node resultNode = null;
    try
    {
      
      
      resultNode = checkEnvironmentUsingWhich(myContext, factoryDocument);

      if (null != resultNode)
        return resultNode;

      
      EnvironmentCheck envChecker = new EnvironmentCheck();
      Hashtable h = envChecker.getEnvironmentHash();
      resultNode = factoryDocument.createElement(""checkEnvironmentExtension"");
      envChecker.appendEnvironmentReport(resultNode, factoryDocument, h);
      envChecker = null;
    }
    catch(Exception e)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(e);
    }

    return resultNode;
  }

  
  private static Node checkEnvironmentUsingWhich(ExpressionContext myContext, 
        Document factoryDocument)
  {
    final String WHICH_CLASSNAME = ""org.apache.env.Which"";
    final String WHICH_METHODNAME = ""which"";
    final Class WHICH_METHOD_ARGS[] = { java.util.Hashtable.class,
                                        java.lang.String.class,
                                        java.lang.String.class };
    try
    {
      
      
      
      Class clazz = Class.forName(WHICH_CLASSNAME);
      if (null == clazz)
        return null;

      
      java.lang.reflect.Method method = clazz.getMethod(WHICH_METHODNAME, WHICH_METHOD_ARGS);
      Hashtable report = new Hashtable();

      
      Object[] methodArgs = { report, ""XmlCommons;Xalan;Xerces;Crimson;Ant"", """" };
      Object returnValue = method.invoke(null, methodArgs);

      
      Node resultNode = factoryDocument.createElement(""checkEnvironmentExtension"");
      org.apache.xml.utils.Hashtree2Node.appendHashToNode(report, ""whichReport"", 
            resultNode, factoryDocument);

      return resultNode;
    }
    catch (Throwable t)
    {
      
      return null;
    }
  }
}
"
org.apache.xalan.xsltc.trax.TransformerImpl,34,2,0,20,144,337,4,17,19,0.894660895,1704,1.0,6,0.288888889,0.131487889,0,0,48.5,18,2.7059,0,"

package org.apache.xalan.xsltc.trax;

import java.io.*;
import java.net.URL;
import java.net.URLConnection;
import java.net.MalformedURLException;
import java.net.UnknownHostException;
import java.net.UnknownServiceException;

import java.lang.IllegalArgumentException;
import java.util.Enumeration;
import java.util.StringTokenizer;

import org.xml.sax.*;
import org.xml.sax.ext.LexicalHandler;

import org.w3c.dom.Document;

import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.TransletOutputHandler;
import org.apache.xalan.xsltc.DOMCache;
import org.apache.xalan.xsltc.dom.*;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.runtime.*;
import org.apache.xalan.xsltc.runtime.output.*;
import org.apache.xalan.xsltc.compiler.*;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;

import java.util.Properties;

public final class TransformerImpl extends Transformer
    implements DOMCache, ErrorListener 
{
    private final static String EMPTY_STRING = """";
    private final static String NO_STRING    = ""no"";
    private final static String YES_STRING   = ""yes"";
    private final static String XML_STRING   = ""xml"";

    private final static String LEXICAL_HANDLER_PROPERTY =
	""http:
    private static final String NAMESPACE_FEATURE =
	""http:
    
    
    private AbstractTranslet _translet = null;

    
    private String _method = null;

    
    private String _encoding = null;

    
    private String _sourceSystemId = null;

    
    private ErrorListener _errorListener = this;

    
    private URIResolver _uriResolver = null;

    
    private Properties _properties, _propertiesClone;

    
    private TransletOutputHandlerFactory _tohFactory = null;

    
    private DOMImpl _dom = null;

    
    private DTDMonitor _dtdMonitor = null;

    
    private int _indentNumber;

    
    private TransformerFactoryImpl _tfactory = null;

    
    private boolean _isIdentity = false;

    
    private Hashtable _parameters = null;

    protected TransformerImpl(Properties outputProperties, int indentNumber, 
	TransformerFactoryImpl tfactory) 
    {
	this(null, outputProperties, indentNumber, tfactory);
	_isIdentity = true;
	
    }

    protected TransformerImpl(Translet translet, Properties outputProperties,
	int indentNumber, TransformerFactoryImpl tfactory) 
    {
	_translet = (AbstractTranslet) translet;
	_properties = createOutputProperties(outputProperties);
	_propertiesClone = (Properties) _properties.clone();
	_indentNumber = indentNumber;
	_tfactory = tfactory;
    }

    
    protected AbstractTranslet getTranslet() {
	return _translet;
    }

    public boolean isIdentity() {
	return _isIdentity;
    }

    
    public void transform(Source source, Result result)
	throws TransformerException 
    {
	if (!_isIdentity) {
	    if (_translet == null) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_TRANSLET_ERR);
		throw new TransformerException(err.toString());
	    }
	    
	    transferOutputProperties(_translet);
	}
	    
	final TransletOutputHandler toHandler = getOutputHandler(result);
	if (toHandler == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_HANDLER_ERR);
	    throw new TransformerException(err.toString());
	}

	if (_uriResolver != null && !_isIdentity) {
	    _translet.setDOMCache(this);
	}

	
	if (_isIdentity) {
	    transferOutputProperties(toHandler);
	}

	transform(source, toHandler, _encoding);

	if (result instanceof DOMResult) {
	    ((DOMResult)result).setNode(_tohFactory.getNode());
	}
    }

    
    public TransletOutputHandler getOutputHandler(Result result) 
	throws TransformerException 
    {
	
	_method = (String) _properties.get(OutputKeys.METHOD);

	
	_encoding = (String) _properties.getProperty(OutputKeys.ENCODING);

	_tohFactory = TransletOutputHandlerFactory.newInstance();
	_tohFactory.setEncoding(_encoding);
	if (_method != null) {
	    _tohFactory.setOutputMethod(_method);
	}

	
	if (_indentNumber >= 0) {
	    _tohFactory.setIndentNumber(_indentNumber);
	}

	
	try {
	    
	    if (result instanceof SAXResult) {
                final SAXResult target = (SAXResult)result;
                final ContentHandler handler = target.getHandler();

		_tohFactory.setHandler(handler);
		if (handler instanceof LexicalHandler) {
		    _tohFactory.setLexicalHandler((LexicalHandler) handler);
		}
		_tohFactory.setOutputType(TransletOutputHandlerFactory.SAX);
		return _tohFactory.getTransletOutputHandler();
            }
	    else if (result instanceof DOMResult) {
		_tohFactory.setNode(((DOMResult) result).getNode());
		_tohFactory.setOutputType(TransletOutputHandlerFactory.DOM);
		return _tohFactory.getTransletOutputHandler();
            }
	    else if (result instanceof StreamResult) {
		
		final StreamResult target = (StreamResult) result;	

		
		
		

		_tohFactory.setOutputType(TransletOutputHandlerFactory.STREAM);

		
		final Writer writer = target.getWriter();
		if (writer != null) {
		    _tohFactory.setWriter(writer);
		    return _tohFactory.getTransletOutputHandler();
		}

		
		final OutputStream ostream = target.getOutputStream();
		if (ostream != null) {
		    _tohFactory.setOutputStream(ostream);
		    return _tohFactory.getTransletOutputHandler();
		}

		
		String systemId = result.getSystemId();
		if (systemId == null) {
		    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_RESULT_ERR);
                    throw new TransformerException(err.toString());
		}

		
		
		
		URL url = null;
		if (systemId.startsWith(""file:"")) {
                    url = new URL(systemId);
		    _tohFactory.setOutputStream(
			new FileOutputStream(url.getFile()));
		    return _tohFactory.getTransletOutputHandler();
                }
                else if (systemId.startsWith(""http:"")) {
                    url = new URL(systemId);
                    final URLConnection connection = url.openConnection();
		    _tohFactory.setOutputStream(connection.getOutputStream());
		    return _tohFactory.getTransletOutputHandler();
                }
                else {
                    
                    url = new File(systemId).toURL();
		    _tohFactory.setOutputStream(
			new FileOutputStream(url.getFile()));
		    return _tohFactory.getTransletOutputHandler();
                }
	    }
	}
        
        catch (UnknownServiceException e) {
            throw new TransformerException(e);
        }
        catch (ParserConfigurationException e) {
            throw new TransformerException(e);
        }
        
        catch (IOException e) {
            throw new TransformerException(e);
        }
	return null;
    }

    
    protected void setDOM(DOMImpl dom) {
	_dom = dom;
    }

    
    protected void setDTDMonitor(DTDMonitor dtdMonitor) {
	_dtdMonitor = dtdMonitor;
    }

    
    private DOMImpl getDOM(Source source, int mask)
	throws TransformerException 
    {
	try {
	    DOMImpl dom = null;
	    DTDMonitor dtd = null;

	    
	    if (source != null) {
		_sourceSystemId = source.getSystemId();
	    }

	    if (source instanceof SAXSource) {
		
		final SAXSource sax = (SAXSource)source;
		XMLReader reader = sax.getXMLReader();
		final InputSource input = sax.getInputSource();

		
		if (reader == null) {
		    reader = _tfactory.getXMLReader();
		}

		
		dtd = new DTDMonitor();
		dtd.handleDTD(reader);

		
		dom = new DOMImpl();
		final DOMBuilder builder = dom.getBuilder();
		try {
		    reader.setProperty(LEXICAL_HANDLER_PROPERTY, builder);
		}
		catch (SAXException e) {
		    
		}
		reader.setContentHandler(builder);

		
		reader.parse(input);
		dom.setDocumentURI(_sourceSystemId);
	    }
	    else if (source instanceof DOMSource) {
		final DOMSource domsrc = (DOMSource) source;
		final org.w3c.dom.Node node = domsrc.getNode();
		final DOM2SAX dom2sax = new DOM2SAX(node);

		
		dtd = new DTDMonitor();
		dtd.handleDTD(dom2sax);

		
		
		dom = new DOMImpl();
		final DOMBuilder builder = dom.getBuilder();
		dom2sax.setContentHandler(builder);

		
		dom2sax.parse();
		dom.setDocumentURI(_sourceSystemId);
	    }
	    else if (source instanceof StreamSource) {
		
		final StreamSource stream = (StreamSource)source;
		final InputStream streamInput = stream.getInputStream();
		final Reader streamReader = stream.getReader();
		final XMLReader reader = _tfactory.getXMLReader();

		
		dtd = new DTDMonitor();
		dtd.handleDTD(reader);

		
		
		dom = new DOMImpl();
		final DOMBuilder builder = dom.getBuilder();
		try {
		    reader.setProperty(LEXICAL_HANDLER_PROPERTY, builder);
		}
		catch (SAXException e) {
		    
		}
		reader.setContentHandler(builder);

		InputSource input;
		if (streamInput != null) {
		    input = new InputSource(streamInput);
		    input.setSystemId(_sourceSystemId); 
		} 
		else if (streamReader != null) {
		    input = new InputSource(streamReader);
		    input.setSystemId(_sourceSystemId); 
		} 
		else if (_sourceSystemId != null) {
		    input = new InputSource(_sourceSystemId);
		} 
		else {
		    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
		    throw new TransformerException(err.toString());
		}

		
		reader.parse(input);
		dom.setDocumentURI(_sourceSystemId);
	    }
	    else if (source instanceof XSLTCSource) {
		final XSLTCSource xsltcsrc = (XSLTCSource)source;
		dtd = xsltcsrc.getDTD();
		dom = xsltcsrc.getDOM();
	    }
	    
	    else if (_dom != null) {
		dtd = _dtdMonitor;	   
		dom = _dom; _dom = null;   
	    }
	    else {
		return null;
	    }

	    
	    if (!_isIdentity) {
		_translet.setIndexSize(dom.getSize());

		
		dtd.buildIdIndex(dom, mask, _translet);

		
		_translet.setDTDMonitor(dtd);
	    }
	    return dom;

	}
	catch (FileNotFoundException e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
	catch (MalformedURLException e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
	catch (UnknownHostException e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
	catch (Exception e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
    }
 
    private void transformIdentity(Source source, TransletOutputHandler handler)
	throws Exception 
    {
	
	if (source != null) {
	    _sourceSystemId = source.getSystemId();
	}

	if (source instanceof StreamSource) {
	    final StreamSource stream = (StreamSource) source;
	    final InputStream streamInput = stream.getInputStream();
	    final Reader streamReader = stream.getReader();
	    final XMLReader reader = _tfactory.getXMLReader();

	    
	    try {
		reader.setProperty(LEXICAL_HANDLER_PROPERTY, handler);
	    }
	    catch (SAXException e) {
		
	    }
	    reader.setContentHandler(new SAX2TO(handler));

	    
	    InputSource input;
	    if (streamInput != null) {
		input = new InputSource(streamInput);
		input.setSystemId(_sourceSystemId); 
	    } 
	    else if (streamReader != null) {
		input = new InputSource(streamReader);
		input.setSystemId(_sourceSystemId); 
	    } 
	    else if (_sourceSystemId != null) {
		input = new InputSource(_sourceSystemId);
	    } 
	    else {
		ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
		throw new TransformerException(err.toString());
	    }

	    
	    reader.parse(input);
	}
	else if (source instanceof SAXSource) {
	    final SAXSource sax = (SAXSource) source;
	    XMLReader reader = sax.getXMLReader();
	    final InputSource input = sax.getInputSource();

	    
	    if (reader == null) {
		reader = _tfactory.getXMLReader();
	    }

	    
	    try {
		reader.setProperty(LEXICAL_HANDLER_PROPERTY, handler);
	    }
	    catch (SAXException e) {
		
	    }
	    reader.setContentHandler(new SAX2TO(handler));

	    
	    reader.parse(input);
	}
	else if (source instanceof DOMSource) {
	    final DOMSource domsrc = (DOMSource) source;
	    new DOM2TO(domsrc.getNode(), handler).parse();
	}
	else if (source instanceof XSLTCSource) {
	    final DOMImpl dom = ((XSLTCSource) source).getDOM();
	    dom.copy(handler);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_NO_SOURCE_ERR);
	    throw new TransformerException(err.toString());
	}
    }

    
    private void transform(Source source, TransletOutputHandler handler, 
	String encoding) throws TransformerException 
    {
	try {
	    if (_isIdentity) {
		transformIdentity(source, handler);
	    }
	    else {
		_translet.transform(getDOM(source, 0), handler);
	    }
	}
	catch (TransletException e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
	catch (RuntimeException e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
	catch (Exception e) {
	    if (_errorListener != null)	postErrorToListener(e.getMessage());
	    throw new TransformerException(e);
	}
    }

    
    public ErrorListener getErrorListener() {  
	return _errorListener; 
    }

    
    public void setErrorListener(ErrorListener listener)
	throws IllegalArgumentException {
        if (listener == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ERROR_LISTENER_NULL_ERR,
					""Transformer"");
            throw new IllegalArgumentException(err.toString());
	}
        _errorListener = listener;
    }

    
    private void postErrorToListener(String message) {
        try {
            _errorListener.error(new TransformerException(message));
	}
	catch (TransformerException e) {
            
        }
    }

    
    private void postWarningToListener(String message) {
        try {
            _errorListener.warning(new TransformerException(message));
        }
	catch (TransformerException e) {
            
        }
    }

    
    private String makeCDATAString(Hashtable cdata) {
	
	if (cdata == null) return null;

	StringBuffer result = new StringBuffer();

	
	Enumeration elements = cdata.keys();
	if (elements.hasMoreElements()) {
	    result.append((String)elements.nextElement());
	    while (elements.hasMoreElements()) {
		String element = (String)elements.nextElement();
		result.append(' ');
		result.append(element);
	    }
	}
	
	return(result.toString());
    }

    
    public Properties getOutputProperties() { 
	return (Properties) _properties.clone();
    }

    
    public String getOutputProperty(String name)
	throws IllegalArgumentException 
    {
	if (!validOutputProperty(name)) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
	    throw new IllegalArgumentException(err.toString());
	}
	return _properties.getProperty(name);
    }

    
    public void setOutputProperties(Properties properties) 
	throws IllegalArgumentException 
    {
	if (properties != null) {
	    final Enumeration names = properties.propertyNames();

	    while (names.hasMoreElements()) {
		final String name = (String) names.nextElement();

		
		if (isDefaultProperty(name, properties)) continue;

		if (validOutputProperty(name)) {
		    _properties.setProperty(name, properties.getProperty(name));
		}
		else {
		    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
		    throw new IllegalArgumentException(err.toString());
		}
	    }
	}
	else {
	    _properties = _propertiesClone;
	}
    }

    
    public void setOutputProperty(String name, String value)
	throws IllegalArgumentException 
    {
	if (!validOutputProperty(name)) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_UNKNOWN_PROP_ERR, name);
	    throw new IllegalArgumentException(err.toString());
	}
	_properties.setProperty(name, value);
    }

    
    private void transferOutputProperties(AbstractTranslet translet)
    {
	
	if (_properties == null) return;

	
	Enumeration names = _properties.propertyNames();
	while (names.hasMoreElements()) {
	    
	    String name  = (String) names.nextElement();
	    String value = (String) _properties.get(name);

	    
	    if (value == null) continue;

	    
	    if (name.equals(OutputKeys.ENCODING)) {
		translet._encoding = value;
	    }
	    else if (name.equals(OutputKeys.METHOD)) {
		translet._method = value;
	    }
	    else if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {
		translet._doctypePublic = value;
	    }
	    else if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {
		translet._doctypeSystem = value;
	    }
	    else if (name.equals(OutputKeys.MEDIA_TYPE)) {
		translet._mediaType = value;
	    }
	    else if (name.equals(OutputKeys.STANDALONE)) {
		translet._standalone = value;
	    }
	    else if (name.equals(OutputKeys.VERSION)) {
		translet._version = value;
	    }
	    else if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {
		translet._omitHeader = 
		    (value != null && value.toLowerCase().equals(""yes""));
	    }
	    else if (name.equals(OutputKeys.INDENT)) {
		translet._indent = 
		    (value != null && value.toLowerCase().equals(""yes""));
	    }
	    else if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {
		if (value != null) {
		    translet._cdata = null; 
		    StringTokenizer e = new StringTokenizer(value);
		    while (e.hasMoreTokens()) {
			translet.addCdataElement(e.nextToken());
		    }
		}
	    }
	}
    }

    
    public void transferOutputProperties(TransletOutputHandler handler)
    {
	
	if (_properties == null) return;

	String doctypePublic = null;
	String doctypeSystem = null;

	
	Enumeration names = _properties.propertyNames();
	while (names.hasMoreElements()) {
	    
	    String name  = (String) names.nextElement();
	    String value = (String) _properties.get(name);

	    
	    if (value == null) continue;

	    
	    if (name.equals(OutputKeys.DOCTYPE_PUBLIC)) {
		doctypePublic = value;
	    }
	    else if (name.equals(OutputKeys.DOCTYPE_SYSTEM)) {
		doctypeSystem = value;
	    }
	    else if (name.equals(OutputKeys.MEDIA_TYPE)) {
		handler.setMediaType(value);
	    }
	    else if (name.equals(OutputKeys.STANDALONE)) {
		handler.setStandalone(value);
	    }
	    else if (name.equals(OutputKeys.VERSION)) {
		handler.setVersion(value);
	    }
	    else if (name.equals(OutputKeys.OMIT_XML_DECLARATION)) {
		handler.omitHeader(
		    value != null && value.toLowerCase().equals(""yes""));
	    }
	    else if (name.equals(OutputKeys.INDENT)) {
		handler.setIndent( 
		    value != null && value.toLowerCase().equals(""yes""));
	    }
	    else if (name.equals(OutputKeys.CDATA_SECTION_ELEMENTS)) {
		if (value != null) {
		    Hashtable table = new Hashtable();
		    StringTokenizer e = new StringTokenizer(value);
		    while (e.hasMoreTokens()) {
			final String token = e.nextToken();
			table.put(token, token);
		    }
		    handler.setCdataElements(table);
		}
	    }
	}

	
	if (doctypePublic != null || doctypeSystem != null) {
	    handler.setDoctype(doctypeSystem, doctypePublic);
	}
    }

    
    private Properties createOutputProperties(Properties outputProperties) {
	final Properties defaults = new Properties();
	defaults.setProperty(OutputKeys.ENCODING, ""UTF-8"");
	defaults.setProperty(OutputKeys.METHOD, XML_STRING);
	defaults.setProperty(OutputKeys.INDENT, NO_STRING);
	defaults.setProperty(OutputKeys.MEDIA_TYPE, ""text/xml"");
	defaults.setProperty(OutputKeys.OMIT_XML_DECLARATION, NO_STRING);
	defaults.setProperty(OutputKeys.STANDALONE, NO_STRING);
	defaults.setProperty(OutputKeys.VERSION, ""1.0"");

	
	final Properties base = new Properties(defaults);
	if (outputProperties != null) {
	    final Enumeration names = outputProperties.propertyNames();
	    while (names.hasMoreElements()) {
		final String name = (String) names.nextElement();
		base.setProperty(name, outputProperties.getProperty(name));
	    }
	}

	
	final String method = base.getProperty(OutputKeys.METHOD);
	if (method != null) {
	    if (method.equals(""html"")) {
		defaults.setProperty(OutputKeys.INDENT, ""yes"");
		defaults.setProperty(OutputKeys.VERSION, ""4.0"");
		defaults.setProperty(OutputKeys.MEDIA_TYPE, ""text/html"");
	    }
	    else if (method.equals(""text"")) {
		defaults.setProperty(OutputKeys.MEDIA_TYPE, ""text/plain"");
	    }
	}

	return base; 
    }

    
    private boolean validOutputProperty(String name) {
	return (name.equals(OutputKeys.ENCODING) ||
		name.equals(OutputKeys.METHOD) ||
		name.equals(OutputKeys.INDENT) ||
		name.equals(OutputKeys.DOCTYPE_PUBLIC) ||
		name.equals(OutputKeys.DOCTYPE_SYSTEM) ||
		name.equals(OutputKeys.CDATA_SECTION_ELEMENTS) ||
		name.equals(OutputKeys.MEDIA_TYPE) ||
		name.equals(OutputKeys.OMIT_XML_DECLARATION)   ||
		name.equals(OutputKeys.STANDALONE) ||
		name.equals(OutputKeys.VERSION) ||
		name.charAt(0) == '{');
    }

    
    private boolean isDefaultProperty(String name, Properties properties) {
	return (properties.get(name) == null);
    }

    
    public void setParameter(String name, Object value) { 
	if (_isIdentity) {
	    if (_parameters == null) {
		_parameters = new Hashtable();
	    }
	    _parameters.put(name, value);
	}
	else {
	    _translet.addParameter(name, value, false);
	}
    }

    
    public void clearParameters() {  
	if (_isIdentity && _parameters != null) {
	    _parameters.clear();
	}
	else {
	    _translet.clearParameters();
	}
    }

    
    public final Object getParameter(String name) {
	if (_isIdentity) {
	    return (_parameters != null) ? _parameters.get(name) : null;
	}
	else {
	    return _translet.getParameter(name);
	}
    }

    
    public URIResolver getURIResolver() {
	return _uriResolver;
    }

    
    public void setURIResolver(URIResolver resolver) { 
	_uriResolver = resolver;
    }

    
    public DOMImpl retrieveDocument(String uri, int mask, Translet translet) {
	try {
	    return getDOM(_uriResolver.resolve(uri, _sourceSystemId), mask);
	}
	catch (TransformerException e) {
	    if (_errorListener != null)
		postErrorToListener(""File not found: "" + e.getMessage());
	    return(null);
	}
    }

    
    public void error(TransformerException e)
	throws TransformerException 
    {
	System.err.println(""ERROR: "" + e.getMessageAndLocation());
	throw(e); 	
    }

    
    public void fatalError(TransformerException e)
	throws TransformerException 
    {
	System.err.println(""FATAL: "" + e.getMessageAndLocation());
	Throwable wrapped = e.getException();
	if (wrapped != null) {
	    System.err.println(""     : ""+wrapped.getMessage());
	}
	throw(e);
    }

    
    public void warning(TransformerException e)
	throws TransformerException 
    {
	System.err.println(""WARNING: "" + e.getMessageAndLocation());
	Throwable wrapped = e.getException();
	if (wrapped != null) {
	    System.err.println(""       : ""+wrapped.getMessage());
	}
    }

}
"
org.apache.xalan.xsltc.runtime.output.StreamTextOutput,11,3,0,3,16,55,1,2,11,2.0,44,0.0,0,0.830188679,0.348484848,0,0,3.0,1,0.8182,0,"

package org.apache.xalan.xsltc.runtime.output;

import java.io.Writer;
import java.io.IOException;
import java.io.OutputStream;

import org.apache.xalan.xsltc.TransletException;

public class StreamTextOutput extends StreamOutput {

    public StreamTextOutput(Writer writer, String encoding) {
	super(writer, encoding);
    }

    public StreamTextOutput(OutputStream out, String encoding) 
	throws IOException
    {
	super(out, encoding);
    }

    public void startDocument() throws TransletException { 
    }

    public void endDocument() throws TransletException { 
	outputBuffer();
    }

    public void startElement(String elementName) 
	throws TransletException 
    {
    }

    public void endElement(String elementName) 
	throws TransletException 
    {
    }

    public void characters(String characters) 
	throws TransletException 
    { 
	_buffer.append(characters);
    }

    public void characters(char[] characters, int offset, int length)
	throws TransletException 
    { 
	_buffer.append(characters, offset, length);
    }

    public void comment(String comment) throws TransletException {
    }

    public void attribute(String name, String value) 
	throws TransletException 
    {
    }

    public void processingInstruction(String target, String data) 
	throws TransletException
    {
    }
}

"
org.apache.xpath.patterns.StepPattern,31,3,2,23,77,241,11,14,26,0.733333333,1095,0.4,2,0.641975309,0.180107527,2,9,34.16129032,17,3.0645,0,"
package org.apache.xpath.patterns;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.axes.SubContextList;
import org.apache.xpath.compiler.PsuedoNames;
import org.apache.xpath.objects.XObject;


public class StepPattern extends NodeTest implements SubContextList, ExpressionOwner
{

  
  protected int m_axis;

  
  public StepPattern(int whatToShow, String namespace, String name, int axis,
                     int axisForPredicate)
  {

    super(whatToShow, namespace, name);

    m_axis = axis;
  }

  
  public StepPattern(int whatToShow, int axis, int axisForPredicate)
  {

    super(whatToShow);

    m_axis = axis;
  }

  
  String m_targetString;  

  
  public void calcTargetString()
  {

    int whatToShow = getWhatToShow();

    switch (whatToShow)
    {
    case DTMFilter.SHOW_COMMENT :
      m_targetString = PsuedoNames.PSEUDONAME_COMMENT;
      break;
    case DTMFilter.SHOW_TEXT :
    case DTMFilter.SHOW_CDATA_SECTION :
    case (DTMFilter.SHOW_TEXT | DTMFilter.SHOW_CDATA_SECTION) :
      m_targetString = PsuedoNames.PSEUDONAME_TEXT;
      break;
    case DTMFilter.SHOW_ALL :
      m_targetString = PsuedoNames.PSEUDONAME_ANY;
      break;
    case DTMFilter.SHOW_DOCUMENT :
    case DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT :
      m_targetString = PsuedoNames.PSEUDONAME_ROOT;
      break;
    case DTMFilter.SHOW_ELEMENT :
      if (this.WILD == m_name)
        m_targetString = PsuedoNames.PSEUDONAME_ANY;
      else
        m_targetString = m_name;
      break;
    default :
      m_targetString = PsuedoNames.PSEUDONAME_ANY;
      break;
    }
  }

  
  public String getTargetString()
  {
    return m_targetString;
  }

  
  StepPattern m_relativePathPattern;

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {

    super.fixupVariables(vars, globalsSize);

    if (null != m_predicates)
    {
      for (int i = 0; i < m_predicates.length; i++)
      {
        m_predicates[i].fixupVariables(vars, globalsSize);
      }
    }

    if (null != m_relativePathPattern)
    {
      m_relativePathPattern.fixupVariables(vars, globalsSize);
    }
  }

  
  public void setRelativePathPattern(StepPattern expr)
  {

    m_relativePathPattern = expr;
    expr.exprSetParent(this);

    calcScore();
  }

  
  public StepPattern getRelativePathPattern()
  {
    return m_relativePathPattern;
  }

  
  
  
  
  
  
  
  

  
  public Expression[] getPredicates()
  {
    return m_predicates;
  }

  
  Expression[] m_predicates;

  
  public boolean canTraverseOutsideSubtree()
  {

    int n = getPredicateCount();

    for (int i = 0; i < n; i++)
    {
      if (getPredicate(i).canTraverseOutsideSubtree())
        return true;
    }

    return false;
  }

  
  public Expression getPredicate(int i)
  {
    return m_predicates[i];
  }

  
  public final int getPredicateCount()
  {
    return (null == m_predicates) ? 0 : m_predicates.length;
  }

  
  public void setPredicates(Expression[] predicates)
  {

    m_predicates = predicates;
    if(null != predicates)
    {
    	for(int i = 0; i < predicates.length; i++)
    	{
    		predicates[i].exprSetParent(this);
    	}
    }

    calcScore();
  }

  
  public void calcScore()
  {

    if ((getPredicateCount() > 0) || (null != m_relativePathPattern))
    {
      m_score = SCORE_OTHER;
    }
    else
      super.calcScore();

    if (null == m_targetString)
      calcTargetString();
  }

  
  public XObject execute(XPathContext xctxt, int currentNode)
          throws javax.xml.transform.TransformerException
  {

    DTM dtm = xctxt.getDTM(currentNode);

    if (dtm != null)
    {
      int expType = dtm.getExpandedTypeID(currentNode);

      return execute(xctxt, currentNode, dtm, expType);
    }

    return NodeTest.SCORE_NONE;
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return execute(xctxt, xctxt.getCurrentNode());
  }

  
  public XObject execute(
          XPathContext xctxt, int currentNode, DTM dtm, int expType)
            throws javax.xml.transform.TransformerException
  {

    if (m_whatToShow == NodeTest.SHOW_BYFUNCTION)
    {
      if (null != m_relativePathPattern)
      {
        return m_relativePathPattern.execute(xctxt);
      }
      else
        return NodeTest.SCORE_NONE;
    }

    XObject score;

    score = super.execute(xctxt, currentNode, dtm, expType);

    if (score == NodeTest.SCORE_NONE)
      return NodeTest.SCORE_NONE;

    if (getPredicateCount() != 0)
    {
      if (!executePredicates(xctxt, dtm, currentNode))
        return NodeTest.SCORE_NONE;
    }

    if (null != m_relativePathPattern)
      return m_relativePathPattern.executeRelativePathPattern(xctxt, dtm,
              currentNode);

    return score;
  }

  
  private final boolean checkProximityPosition(XPathContext xctxt,
          int predPos, DTM dtm, int context, int pos)
  {

    try
    {
      DTMAxisTraverser traverser =
        dtm.getAxisTraverser(Axis.PRECEDINGSIBLING);

      for (int child = traverser.first(context); DTM.NULL != child;
              child = traverser.next(context, child))
      {
        try
        {
          xctxt.pushCurrentNode(child);

          if (NodeTest.SCORE_NONE != super.execute(xctxt, child))
          {
            boolean pass = true;

            try
            {
              xctxt.pushSubContextList(this);

              for (int i = 0; i < predPos; i++)
              {
                xctxt.pushPredicatePos(i);
                try
                {
                  XObject pred = m_predicates[i].execute(xctxt);
                  
                  try
                  {
                    if (XObject.CLASS_NUMBER == pred.getType())
                    {
                      throw new Error(""Why: Should never have been called"");
                    }
                    else if (!pred.boolWithSideEffects())
                    {
                      pass = false;
    
                      break;
                    }
                  }
                  finally
                  {
                    pred.detach();
                  }
                }
                finally
                {
                  xctxt.popPredicatePos();
                }
              }
            }
            finally
            {
              xctxt.popSubContextList();
            }

            if (pass)
              pos--;

            if (pos < 1)
              return false;
          }
        }
        finally
        {
          xctxt.popCurrentNode();
        }
      }
    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new java.lang.RuntimeException(se.getMessage());
    }

    return (pos == 1);
  }

  
  private final int getProximityPosition(XPathContext xctxt, int predPos, 
                    boolean findLast)
  {

    int pos = 0;
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    int parent = dtm.getParent(context);

    try
    {
      DTMAxisTraverser traverser = dtm.getAxisTraverser(Axis.CHILD);

      for (int child = traverser.first(parent); DTM.NULL != child;
              child = traverser.next(parent, child))
      {
        try
        {
          xctxt.pushCurrentNode(child);

          if (NodeTest.SCORE_NONE != super.execute(xctxt, child))
          {
            boolean pass = true;

            try
            {
              xctxt.pushSubContextList(this);

              for (int i = 0; i < predPos; i++)
              {
                xctxt.pushPredicatePos(i);
                try
                {
                  XObject pred = m_predicates[i].execute(xctxt);
  
                  try
                  {
                    if (XObject.CLASS_NUMBER == pred.getType())
                    {
                      if ((pos + 1) != (int) pred.numWithSideEffects())
                      {
                        pass = false;
    
                        break;
                      }
                    }
                    else if (!pred.boolWithSideEffects())
                    {
                      pass = false;
    
                      break;
                    }
                  }
                  finally
                  {
                    pred.detach();
                  }
                }
                finally
                {
                  xctxt.popPredicatePos();
                }
              }
            }
            finally
            {
              xctxt.popSubContextList();
            }

            if (pass)
              pos++;

            if (!findLast && child == context)
            {
              return pos;
            }
          }
        }
        finally
        {
          xctxt.popCurrentNode();
        }
      }
    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new java.lang.RuntimeException(se.getMessage());
    }

    return pos;
  }

  
  public int getProximityPosition(XPathContext xctxt)
  {
    return getProximityPosition(xctxt, xctxt.getPredicatePos(), false);
  }
  
  
  public int getLastPos(XPathContext xctxt)
  {
    return getProximityPosition(xctxt, xctxt.getPredicatePos(), true);
  }

  
  protected final XObject executeRelativePathPattern(
          XPathContext xctxt, DTM dtm, int currentNode)
            throws javax.xml.transform.TransformerException
  {

    XObject score = NodeTest.SCORE_NONE;
    int context = currentNode;
    DTMAxisTraverser traverser;

    traverser = dtm.getAxisTraverser(m_axis);

    for (int relative = traverser.first(context); DTM.NULL != relative;
            relative = traverser.next(context, relative))
    {
      try
      {
        xctxt.pushCurrentNode(relative);

        score = execute(xctxt);

        if (score != NodeTest.SCORE_NONE)
          break;
      }
      finally
      {
        xctxt.popCurrentNode();
      }
    }

    return score;
  }

  
  protected final boolean executePredicates(
          XPathContext xctxt, DTM dtm, int currentNode)
            throws javax.xml.transform.TransformerException
  {

    boolean result = true;
    boolean positionAlreadySeen = false;
    int n = getPredicateCount();

    try
    {
      xctxt.pushSubContextList(this);

      for (int i = 0; i < n; i++)
      {
        xctxt.pushPredicatePos(i);

        try
        {
          XObject pred = m_predicates[i].execute(xctxt);

          try
          {
            if (XObject.CLASS_NUMBER == pred.getType())
            {
              int pos = (int) pred.num();
  
              if (positionAlreadySeen)
              {
                result = (pos == 1);
  
                break;
              }
              else
              {
                positionAlreadySeen = true;
  
                if (!checkProximityPosition(xctxt, i, dtm, currentNode, pos))
                {
                  result = false;
  
                  break;
                }
              }
            
            }
            else if (!pred.boolWithSideEffects())
            {
              result = false;
  
              break;
            }
          }
          finally
          {
            pred.detach();
          }
        }
        finally
        {
          xctxt.popPredicatePos();
        }
      }
    }
    finally
    {
      xctxt.popSubContextList();
    }

    return result;
  }

  
  public String toString()
  {

    StringBuffer buf = new StringBuffer();

    for (StepPattern pat = this; pat != null; pat = pat.m_relativePathPattern)
    {
      if (pat != this)
        buf.append(""/"");

      buf.append(Axis.names[pat.m_axis]);
      buf.append(""::"");

      if (0x000005000 == pat.m_whatToShow)
      {
        buf.append(""doc()"");
      }
      else if (DTMFilter.SHOW_BYFUNCTION == pat.m_whatToShow)
      {
        buf.append(""function()"");
      }
      else if (DTMFilter.SHOW_ALL == pat.m_whatToShow)
      {
        buf.append(""node()"");
      }
      else if (DTMFilter.SHOW_TEXT == pat.m_whatToShow)
      {
        buf.append(""text()"");
      }
      else if (DTMFilter.SHOW_PROCESSING_INSTRUCTION == pat.m_whatToShow)
      {
        buf.append(""processing-instruction("");

        if (null != pat.m_name)
        {
          buf.append(pat.m_name);
        }

        buf.append("")"");
      }
      else if (DTMFilter.SHOW_COMMENT == pat.m_whatToShow)
      {
        buf.append(""comment()"");
      }
      else if (null != pat.m_name)
      {
        if (DTMFilter.SHOW_ATTRIBUTE == pat.m_whatToShow)
        {
          buf.append(""@"");
        }

        if (null != pat.m_namespace)
        {
          buf.append(""{"");
          buf.append(pat.m_namespace);
          buf.append(""}"");
        }

        buf.append(pat.m_name);
      }
      else if (DTMFilter.SHOW_ATTRIBUTE == pat.m_whatToShow)
      {
        buf.append(""@"");
      }
      else if ((DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT)
               == pat.m_whatToShow)
      {
        buf.append(""doc-root()"");
      }
      else
      {
        buf.append(""?"" + Integer.toHexString(pat.m_whatToShow));
      }

      if (null != pat.m_predicates)
      {
        for (int i = 0; i < pat.m_predicates.length; i++)
        {
          buf.append(""["");
          buf.append(pat.m_predicates[i]);
          buf.append(""]"");
        }
      }
    }

    return buf.toString();
  }

  
  private static final boolean DEBUG_MATCHES = false;

  
  public double getMatchScore(XPathContext xctxt, int context)
          throws javax.xml.transform.TransformerException
  {

    xctxt.pushCurrentNode(context);
    xctxt.pushCurrentExpressionNode(context);

    try
    {
      XObject score = execute(xctxt);

      return score.num();
    }
    finally
    {
      xctxt.popCurrentNode();
      xctxt.popCurrentExpressionNode();
    }

    
  }

  
  public void setAxis(int axis)
  {
    m_axis = axis;
  }

  
  public int getAxis()
  {
    return m_axis;
  }
  
  class PredOwner implements ExpressionOwner
  {
  	int m_index;
  	
  	PredOwner(int index)
  	{
  		m_index = index;
  	}
  	
    
    public Expression getExpression()
    {
      return m_predicates[m_index];
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(StepPattern.this);
    	m_predicates[m_index] = exp;
    }
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	 	if(visitor.visitMatchPattern(owner, this))
  	 	{
  	 		callSubtreeVisitors(visitor);
  	 	}
  }

  
  protected void callSubtreeVisitors(XPathVisitor visitor)
  {
    if (null != m_predicates)
    {
      int n = m_predicates.length;
      for (int i = 0; i < n; i++)
      {
        ExpressionOwner predOwner = new PredOwner(i);
        if (visitor.visitPredicate(predOwner, m_predicates[i]))
        {
          m_predicates[i].callVisitors(predOwner, visitor);
        }
      }
    }
    if (null != m_relativePathPattern)
    {
      m_relativePathPattern.callVisitors(this, visitor);
    }
  }


  
  public Expression getExpression()
  {
    return m_relativePathPattern;
  }


  
  public void setExpression(Expression exp)
  {
    exp.exprSetParent(this);
  	m_relativePathPattern = (StepPattern)exp;
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	StepPattern sp = (StepPattern)expr;
  	
    if (null != m_predicates)
    {
        int n = m_predicates.length;
        if ((null == sp.m_predicates) || (sp.m_predicates.length != n))
              return false;
        for (int i = 0; i < n; i++)
        {
          if (!m_predicates[i].deepEquals(sp.m_predicates[i]))
          	return false; 
        }
    }
    else if (null != sp.m_predicates)
    	return false;
  		
  	if(null != m_relativePathPattern)
  	{
  		if(!m_relativePathPattern.deepEquals(sp.m_relativePathPattern))
  			return false;
  	}
  	else if(sp.m_relativePathPattern != null)
  		return false;
  		
  	return true;
  }



}
"
org.apache.xalan.transformer.TransformSnapshot,0,1,0,2,0,0,2,0,0,2.0,0,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"package org.apache.xalan.transformer;


public interface TransformSnapshot
{

}"
org.apache.xpath.functions.FunctionDef1Arg,8,4,9,18,21,28,9,9,4,2.0,110,0.0,0,0.872727273,0.5,2,5,12.75,2,1.125,0,"
package org.apache.xpath.functions;



import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XString;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;

import org.apache.xml.utils.XMLString;

import org.apache.xml.dtm.DTM;


public class FunctionDef1Arg extends FunctionOneArg
{

  
  protected int getArg0AsNode(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (null == m_arg0)
           ? xctxt.getCurrentNode() : m_arg0.asNode(xctxt);
  }
  
  
  public boolean Arg0IsNodesetExpr()
  {
    return (null == m_arg0) ? true : m_arg0.isNodesetExpr();
  }

  
  protected XMLString getArg0AsString(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    if(null == m_arg0)
    {
      int currentNode = xctxt.getCurrentNode();
      if(DTM.NULL == currentNode)
        return XString.EMPTYSTRING;
      else
      {
        DTM dtm = xctxt.getDTM(currentNode);
        return dtm.getStringValue(currentNode);
      }
      
    }
    else
      return m_arg0.execute(xctxt).xstr();   
  }

  
  protected double getArg0AsNumber(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    if(null == m_arg0)
    {
      int currentNode = xctxt.getCurrentNode();
      if(DTM.NULL == currentNode)
        return 0;
      else
      {
        DTM dtm = xctxt.getDTM(currentNode);
        XMLString str = dtm.getStringValue(currentNode);
        return str.toDouble();
      }
      
    }
    else
      return m_arg0.execute(xctxt).num();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum > 1)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_ZERO_OR_ONE, null)); 
  }

  
  public boolean canTraverseOutsideSubtree()
  {
    return (null == m_arg0) ? false : super.canTraverseOutsideSubtree();
  }
}
"
org.apache.xalan.templates.ElemSort,15,3,0,7,26,53,2,5,15,0.785714286,164,1.0,5,0.933333333,0.293333333,2,5,9.6,2,1.0,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;


public class ElemSort extends ElemTemplateElement
{

  
  private XPath m_selectExpression = null;

  
  public void setSelect(XPath v)
  {

    if (v.getPatternString().indexOf(""{"") < 0)
      m_selectExpression = v;
    else
      error(XSLTErrorResources.ER_NO_CURLYBRACE, null);
  }

  
  public XPath getSelect()
  {
    return m_selectExpression;
  }

  
  private AVT m_lang_avt = null;

  
  public void setLang(AVT v)
  {
    m_lang_avt = v;
  }

  
  public AVT getLang()
  {
    return m_lang_avt;
  }

  
  private AVT m_dataType_avt = null;

  
  public void setDataType(AVT v)
  {
    m_dataType_avt = v;
  }

  
  public AVT getDataType()
  {
    return m_dataType_avt;
  }

  
  private AVT m_order_avt = null;

  
  public void setOrder(AVT v)
  {
    m_order_avt = v;
  }

  
  public AVT getOrder()
  {
    return m_order_avt;
  }

  
  private AVT m_caseorder_avt = null;

  
  public void setCaseOrder(AVT v)
  {
    m_caseorder_avt = v;
  }

  
  public AVT getCaseOrder()
  {
    return m_caseorder_avt;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_SORT;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_SORT_STRING;
  }

  
  public Node appendChild(Node newChild) throws DOMException
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }
  
  
  public void compose(StylesheetRoot sroot) 
    throws javax.xml.transform.TransformerException
  {
    super.compose(sroot);
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_caseorder_avt)
      m_caseorder_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_dataType_avt)
      m_dataType_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_lang_avt)
      m_lang_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_order_avt)
      m_order_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_selectExpression)
      m_selectExpression.fixupVariables(vnames, cstate.getGlobalsSize());
  }
}
"
org.apache.xalan.templates.ElemExtensionDecl,14,3,0,10,41,27,1,9,14,0.666666667,290,1.0,2,0.937799043,0.25,3,4,19.5,2,1.0714,0,"
package org.apache.xalan.templates;

import java.util.Vector;

import org.apache.xml.utils.QName;
import org.apache.xml.utils.NameSpace;
import org.apache.xml.utils.StringToStringTable;
import org.apache.xml.utils.StringVector;
import org.apache.xalan.extensions.ExtensionHandler;
import org.apache.xalan.extensions.ExtensionHandlerGeneral;
import org.apache.xalan.extensions.ExtensionsTable;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;

import org.apache.xpath.XPathContext;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;


import org.apache.xalan.extensions.ExtensionNamespacesManager;
import org.apache.xalan.extensions.ExtensionNamespaceSupport;


public class ElemExtensionDecl extends ElemTemplateElement
{

  
  public ElemExtensionDecl()
  {

    
  }

  
  private String m_prefix = null;

  
  public void setPrefix(String v)
  {
    m_prefix = v;
  }

  
  public String getPrefix()
  {
    return m_prefix;
  }

  
  private StringVector m_functions = new StringVector();

  
  public void setFunctions(StringVector v)
  {
    m_functions = v;
  }

  
  public StringVector getFunctions()
  {
    return m_functions;
  }

  
  public String getFunction(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_functions)
      throw new ArrayIndexOutOfBoundsException();

    return (String) m_functions.elementAt(i);
  }

  
  public int getFunctionCount()
  {
    return (null != m_functions) ? m_functions.size() : 0;
  }

  
  private StringVector m_elements = null;

  
  public void setElements(StringVector v)
  {
    m_elements = v;
  }

  
  public StringVector getElements()
  {
    return m_elements;
  }

  
  public String getElement(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_elements)
      throw new ArrayIndexOutOfBoundsException();

    return (String) m_elements.elementAt(i);
  }

  
  public int getElementCount()
  {
    return (null != m_elements) ? m_elements.size() : 0;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_EXTENSIONDECL;
  }
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    String prefix = getPrefix();
    String declNamespace = getNamespaceForPrefix(prefix);
    String lang = null;
    String srcURL = null;
    String scriptSrc = null;
    if (null == declNamespace)
      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_NAMESPACE_DECL, new Object[]{prefix})); 
      
    for (ElemTemplateElement child = getFirstChildElem(); child != null;
          child = child.getNextSiblingElem())
    {
      if (Constants.ELEMNAME_EXTENSIONSCRIPT == child.getXSLToken())
      {
        ElemExtensionScript sdecl = (ElemExtensionScript) child;
        lang = sdecl.getLang();
        srcURL = sdecl.getSrc();
        ElemTemplateElement childOfSDecl = sdecl.getFirstChildElem();
        if (null != childOfSDecl)
        {
          if (Constants.ELEMNAME_TEXTLITERALRESULT
                  == childOfSDecl.getXSLToken())
          {
            ElemTextLiteral tl = (ElemTextLiteral) childOfSDecl;
            char[] chars = tl.getChars();
            scriptSrc = new String(chars);
            if (scriptSrc.trim().length() == 0)
              scriptSrc = null;
          }
        }
      }
    }
    if (null == lang)
      lang = ""javaclass"";
    if (lang.equals(""javaclass"") && (scriptSrc != null))
        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_ELEM_CONTENT_NOT_ALLOWED, new Object[]{scriptSrc})); 
        

    
    ExtensionNamespaceSupport extNsSpt = null;
    ExtensionNamespacesManager extNsMgr = sroot.getExtensionNamespacesManager();
    if (extNsMgr.namespaceIndex(declNamespace,
                                extNsMgr.getExtensions()) == -1)
    {
      if (lang.equals(""javaclass""))
      {
        if (null == srcURL)
        {
           extNsSpt = extNsMgr.defineJavaNamespace(declNamespace);
        }
        else if (extNsMgr.namespaceIndex(srcURL,
                                         extNsMgr.getExtensions()) == -1)
        {
          extNsSpt = extNsMgr.defineJavaNamespace(declNamespace, srcURL);
        }
      }
      else  
      {
        String handler = ""org.apache.xalan.extensions.ExtensionHandlerGeneral"";
        Object [] args = {declNamespace, this.m_elements, this.m_functions,
                          lang, srcURL, scriptSrc, getSystemId()};
        extNsSpt = new ExtensionNamespaceSupport(declNamespace, handler, args);
      }
    }
    if (extNsSpt != null)
      extNsMgr.registerExtension(extNsSpt);
  }

  
    
  public void runtimeInit(TransformerImpl transformer) throws TransformerException
  {

  }
}
"
org.apache.xalan.processor.ProcessorAttributeSet,3,4,0,7,19,3,1,6,2,2.0,54,0.0,0,0.990566038,0.666666667,2,3,17.0,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemAttributeSet;
import org.apache.xalan.templates.ElemTemplateElement;

import org.xml.sax.Attributes;
import javax.xml.transform.TransformerException;


class ProcessorAttributeSet extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    ElemAttributeSet eat = new ElemAttributeSet();

    eat.setLocaterInfo(handler.getLocator());
    try
    {
      eat.setPrefixes(handler.getNamespaceSupport());
    }
    catch(TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }

    eat.setDOMBackPointer(handler.getOriginatingNode());
    setPropertiesFromAttributes(handler, rawName, attributes, eat);
    handler.getStylesheet().setAttributeSet(eat);

    
    ElemTemplateElement parent = handler.getElemTemplateElement();

    parent.appendChild(eat);
    handler.pushElemTemplateElement(eat);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {
    handler.popElemTemplateElement();
  }
}
"
org.apache.xalan.templates.WhiteSpaceInfo,4,4,1,9,8,4,7,4,4,0.666666667,30,1.0,0,0.99086758,0.45,0,0,6.25,1,0.5,0,"
package org.apache.xalan.templates;

import org.apache.xpath.XPath;


public class WhiteSpaceInfo extends ElemTemplate
{

  
  private boolean m_shouldStripSpace;

  
  public boolean getShouldStripSpace()
  {
    return m_shouldStripSpace;
  }
  
  
  public WhiteSpaceInfo(Stylesheet thisSheet)
  {
  	setStylesheet(thisSheet);
  }


  
  public WhiteSpaceInfo(XPath matchPattern, boolean shouldStripSpace, Stylesheet thisSheet)
  {

    m_shouldStripSpace = shouldStripSpace;

    setMatch(matchPattern);

    setStylesheet(thisSheet);
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeWhiteSpaceInfo(this);
  }

}
"
org.apache.xalan.xsltc.cmdline.getopt.GetOpt,5,1,0,5,33,0,3,4,5,0.65,328,1.0,2,0.0,0.466666667,0,0,63.6,3,1.6,0,"

package org.apache.xalan.xsltc.cmdline.getopt; 

import java.util.ArrayList;
import java.util.ListIterator;
import java.util.List;

import org.apache.xalan.xsltc.cmdline.getopt.IllegalArgumentException;
import org.apache.xalan.xsltc.cmdline.getopt.MissingOptArgException;



public class GetOpt{
    public GetOpt(String[] args, String optString){
	theOptions = new ArrayList();		 
	int currOptIndex = 0; 
	theCmdArgs = new ArrayList(); 
	theOptionMatcher = new OptionMatcher(optString);
	
	for(int i=0; i<args.length; i++){
	    String token = args[i];
	    int tokenLength = token.length();
	    if(token.equals(""--"")){	    
	        currOptIndex = i+1;	    
                break;                      
	    }
	    else if(token.startsWith(""-"") && tokenLength == 2){ 
		
		theOptions.add(new Option(token.charAt(1)));	
	    }
	    else if(token.startsWith(""-"") && tokenLength > 2){
		
		
		
		for(int j=1; j<tokenLength; j++){
		    theOptions.add(new Option(token.charAt(j)));
		}
	    }		
	    else if(!token.startsWith(""-"")){
		
		
		if(theOptions.size() == 0){
		    currOptIndex = i;
		    break;		
		}
		else {
		    
		    
		    
		    int indexoflast=0;
		    indexoflast = theOptions.size()-1;
		    Option op = (Option)theOptions.get(indexoflast);
		    char opLetter = op.getArgLetter();
		    if(!op.hasArg() && theOptionMatcher.hasArg(opLetter)){
		        op.setArg(token);
		    }
		    else{
		        
		        
		        
		        
		        
		        currOptIndex = i;
		        break; 			
		    }
	  	}
	    }
	} 

        
	theOptionsIterator = theOptions.listIterator();

	
	for(int i=currOptIndex; i<args.length; i++){
	    String token = args[i];
	    theCmdArgs.add(token);
	}
    }


    
    public void printOptions(){
	for(ListIterator it=theOptions.listIterator(); it.hasNext();){
	    Option opt = (Option)it.next();
	    System.out.print(""OPT ="" + opt.getArgLetter());
	    String arg = opt.getArgument();
	    if(arg != null){
	       System.out.print("" "" + arg);
	    }
	    System.out.println();
	}
    }

    
    public int getNextOption() throws IllegalArgumentException, 
	MissingOptArgException
    {
	int retval = -1;
	if(theOptionsIterator.hasNext()){
	    theCurrentOption = (Option)theOptionsIterator.next();
	    char c = theCurrentOption.getArgLetter();
	    boolean shouldHaveArg = theOptionMatcher.hasArg(c);
	    String arg = theCurrentOption.getArgument();
	    if(!theOptionMatcher.match(c)){
		throw (new IllegalArgumentException(""Option "" +
			c + "" is not valid.""));
	    }
	    else if(shouldHaveArg && (arg == null)){
		throw (new MissingOptArgException(""Option "" + 
			c + "" is missing its argument.""));
	    }
	    retval = c;
	}
	return retval;
    }

    
    public String getOptionArg(){
	String retval = null;
	String tmp = theCurrentOption.getArgument();
	char c = theCurrentOption.getArgLetter();
	if(theOptionMatcher.hasArg(c)){
	    retval = tmp;
	}
	return retval;	
    }

    
    public String[] getCmdArgs(){
	String[] retval = new String[theCmdArgs.size()];
	int i=0;
        for(ListIterator it=theCmdArgs.listIterator(); it.hasNext();){
            retval[i++] = (String)it.next();
        }
	return retval;
    }


    private Option theCurrentOption = null;
    private ListIterator theOptionsIterator; 
    private List theOptions = null;
    private List theCmdArgs = null;
    private OptionMatcher theOptionMatcher = null;

    
    
    
    
    

    
    class Option{
        private char theArgLetter;
        private String theArgument = null;
        public Option(char argLetter) { theArgLetter = argLetter; }
        public void setArg(String arg) { 
	    theArgument = arg;
        }
        public boolean hasArg() { return (theArgument != null); } 
        public char getArgLetter() { return theArgLetter; }
        public String getArgument() { return theArgument; }
    } 


    
    
    
    class OptionMatcher{
        public OptionMatcher(String optString){
	    theOptString = optString;	
        }
        public boolean match(char c){
	    boolean retval = false;
	    if(theOptString.indexOf(c) != -1){
	        retval = true;
	    }
	    return retval;	
        }
        public boolean hasArg(char c){
	    boolean retval = false;
	    int index = theOptString.indexOf(c)+1; 
	    if (index == theOptString.length()){
	        
	        retval = false;
	    }
            else if(theOptString.charAt(index) == ':'){
                retval = true;
            }
            return retval;
        }
        private String theOptString = null;
    } 
}
    
"
org.apache.xalan.xsltc.compiler.AlternativePattern,8,4,0,18,27,0,1,17,8,0.142857143,135,1.0,2,0.925531915,0.270833333,2,3,15.625,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class AlternativePattern extends Pattern {
    private final Pattern _left;
    private final Pattern _right;
		
    
    public AlternativePattern(Pattern left, Pattern right) {
	_left = left;
	_right = right;
    }
		
    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }
    
    public Pattern getLeft() {
	return _left;
    }

    public Pattern getRight() {
	return _right;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_left.typeCheck(stable);
	_right.typeCheck(stable);
	return null;
    }

    public double getPriority() {
	double left = _left.getPriority();
	double right = _right.getPriority();
	
	if (left < right)
	    return(left);
	else
	    return(right);
    }

    public String toString() {
	return ""alternative("" + _left + "", "" + _right + ')';
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();

	_left.translate(classGen, methodGen);
	final InstructionHandle gotot = il.append(new GOTO(null));
	il.append(methodGen.loadContextNode());
	_right.translate(classGen, methodGen);

	_left._trueList.backPatch(gotot);
	_left._falseList.backPatch(gotot.getNext());

	_trueList.append(_right._trueList.add(gotot));
	_falseList.append(_right._falseList);
    }
}
"
org.apache.xalan.xsltc.compiler.Attribute,3,3,0,5,14,1,0,5,2,0.5,37,1.0,1,0.965517241,0.555555556,1,4,11.0,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.*;

final class Attribute extends Instruction {
    private QName _name;
	
    public void display(int indent) {
	indent(indent);
	Util.println(""Attribute "" + _name);
	displayContents(indent + IndentIncrement);
    }

    public void parseContents(Parser parser) {
	_name = parser.getQName(getAttribute(""name""));
	parseChildren(parser);
	
	
    }
}
"
org.apache.xml.utils.XMLString,37,1,0,41,37,666,41,0,37,2.0,37,0.0,0,0.0,0.191891892,1,1,0.0,1,1.0,0,"
package org.apache.xml.utils;

import java.util.Locale;


public interface XMLString
{

  
  public abstract void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
    throws org.xml.sax.SAXException;

  
  public abstract void dispatchAsComment(org.xml.sax.ext.LexicalHandler lh)
    throws org.xml.sax.SAXException;
    
  
  public XMLString fixWhiteSpace(boolean trimHead,
                                 boolean trimTail,
                                 boolean doublePunctuationSpaces);

  
  public abstract int length();

  
  public abstract char charAt(int index);

  
  public abstract void getChars(int srcBegin, int srcEnd, char dst[],
                                int dstBegin);
                                
  
  public abstract boolean equals(XMLString anObject);


  
  public abstract boolean equals(Object anObject);

  
  public abstract boolean equalsIgnoreCase(String anotherString);

  
  public abstract int compareTo(XMLString anotherString);

  
  public abstract int compareToIgnoreCase(XMLString str);

  
  public abstract boolean startsWith(String prefix, int toffset);

  
  public abstract boolean startsWith(XMLString prefix, int toffset);

  
  public abstract boolean startsWith(String prefix);

  
  public abstract boolean startsWith(XMLString prefix);

  
  public abstract boolean endsWith(String suffix);

  
  public abstract int hashCode();

  
  public abstract int indexOf(int ch);

  
  public abstract int indexOf(int ch, int fromIndex);

  
  public abstract int lastIndexOf(int ch);

  
  public abstract int lastIndexOf(int ch, int fromIndex);

  
  public abstract int indexOf(String str);

  
  public abstract int indexOf(XMLString str);

  
  public abstract int indexOf(String str, int fromIndex);

  
  public abstract int lastIndexOf(String str);

  
  public abstract int lastIndexOf(String str, int fromIndex);

  
  public abstract XMLString substring(int beginIndex);

  
  public abstract XMLString substring(int beginIndex, int endIndex);

  
  public abstract XMLString concat(String str);

  
  public abstract XMLString toLowerCase(Locale locale);

  
  public abstract XMLString toLowerCase();

  
  public abstract XMLString toUpperCase(Locale locale);

  
  public abstract XMLString toUpperCase();

  
  public abstract XMLString trim();

  
  public abstract String toString();
  
  
  public abstract boolean hasString();
  
  
  public double toDouble();
}
"
org.apache.xml.utils.NodeConsumer,1,1,0,3,1,0,3,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xml.utils;

import org.w3c.dom.Node;


public interface NodeConsumer
{

  
  public void setOriginatingNode(Node n);
}
"
org.apache.xalan.xsltc.compiler.Otherwise,4,3,0,11,12,6,1,10,3,2.0,43,0.0,0,0.949152542,0.4,1,4,9.75,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.*;

final class Otherwise extends Instruction {
    public void display(int indent) {
	indent(indent);
	Util.println(""Otherwise"");
	indent(indent + IndentIncrement);
	displayContents(indent + IndentIncrement);
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	typeCheckContents(stable);
	return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Parser parser = getParser();
	final ErrorMsg err = new ErrorMsg(ErrorMsg.STRAY_OTHERWISE_ERR, this);
	parser.reportError(Constants.ERROR, err);
    }
}
"
org.apache.xpath.functions.FuncNamespace,2,5,0,5,11,1,0,5,2,2.0,65,0.0,0,0.982142857,0.75,3,8,31.5,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncNamespace extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int context = getArg0AsNode(xctxt);
    
    String s;
    if(context != DTM.NULL)
    {
      DTM dtm = xctxt.getDTM(context);
      int t = dtm.getNodeType(context);
      if(t == DTM.ELEMENT_NODE)
      {
        s = dtm.getNamespaceURI(context);
      }
      else if(t == DTM.ATTRIBUTE_NODE)
      {

        
        

        s = dtm.getNodeName(context);
        if(s.startsWith(""xmlns:"") || s.equals(""xmlns""))
          return XString.EMPTYSTRING;

        s = dtm.getNamespaceURI(context);
      }
      else
        return XString.EMPTYSTRING;
    }
    else 
      return XString.EMPTYSTRING;
    
    return ((null == s) ? XString.EMPTYSTRING : new XString(s));
  }
}
"
org.apache.xpath.compiler.FunctionTable,5,1,0,7,14,0,3,4,4,1.211538462,391,0.051282051,1,0.0,0.375,0,0,69.4,2,0.8,0,"
package org.apache.xpath.compiler;

import org.apache.xpath.Expression;
import org.apache.xpath.functions.Function;


public class FunctionTable
{

  
  public static final int FUNC_CURRENT = 0;

  
  public static final int FUNC_LAST = 1;

  
  public static final int FUNC_POSITION = 2;

  
  public static final int FUNC_COUNT = 3;

  
  public static final int FUNC_ID = 4;

  
  public static final int FUNC_KEY = 5;

  
  public static final int FUNC_LOCAL_PART = 7;

  
  public static final int FUNC_NAMESPACE = 8;

  
  public static final int FUNC_QNAME = 9;

  
  public static final int FUNC_GENERATE_ID = 10;

  
  public static final int FUNC_NOT = 11;

  
  public static final int FUNC_TRUE = 12;

  
  public static final int FUNC_FALSE = 13;

  
  public static final int FUNC_BOOLEAN = 14;

  
  public static final int FUNC_NUMBER = 15;

  
  public static final int FUNC_FLOOR = 16;

  
  public static final int FUNC_CEILING = 17;

  
  public static final int FUNC_ROUND = 18;

  
  public static final int FUNC_SUM = 19;

  
  public static final int FUNC_STRING = 20;

  
  public static final int FUNC_STARTS_WITH = 21;

  
  public static final int FUNC_CONTAINS = 22;

  
  public static final int FUNC_SUBSTRING_BEFORE = 23;

  
  public static final int FUNC_SUBSTRING_AFTER = 24;

  
  public static final int FUNC_NORMALIZE_SPACE = 25;

  
  public static final int FUNC_TRANSLATE = 26;

  
  public static final int FUNC_CONCAT = 27;

  
  public static final int FUNC_SUBSTRING = 29;

  
  public static final int FUNC_STRING_LENGTH = 30;

  
  public static final int FUNC_SYSTEM_PROPERTY = 31;

  
  public static final int FUNC_LANG = 32;

  
  public static final int FUNC_EXT_FUNCTION_AVAILABLE = 33;

  
  public static final int FUNC_EXT_ELEM_AVAILABLE = 34;

  
  public static final int FUNC_UNPARSED_ENTITY_URI = 36;

  

  
  public static final int FUNC_DOCLOCATION = 35;

  
  public static FuncLoader m_functions[];

  
  private static final int NUM_BUILT_IN_FUNCS = 37;

  
  private static final int NUM_ALLOWABLE_ADDINS = 30;

  
  static int m_funcNextFreeIndex = NUM_BUILT_IN_FUNCS;

  static
  {
    m_functions = new FuncLoader[NUM_BUILT_IN_FUNCS + NUM_ALLOWABLE_ADDINS];
    m_functions[FUNC_CURRENT] = new FuncLoader(""FuncCurrent"", FUNC_CURRENT);
    m_functions[FUNC_LAST] = new FuncLoader(""FuncLast"", FUNC_LAST);
    m_functions[FUNC_POSITION] = new FuncLoader(""FuncPosition"",
                                                FUNC_POSITION);
    m_functions[FUNC_COUNT] = new FuncLoader(""FuncCount"", FUNC_COUNT);
    m_functions[FUNC_ID] = new FuncLoader(""FuncId"", FUNC_ID);
    m_functions[FUNC_KEY] =
      new FuncLoader(""org.apache.xalan.templates.FuncKey"", FUNC_KEY);

    
    m_functions[FUNC_LOCAL_PART] = new FuncLoader(""FuncLocalPart"",
            FUNC_LOCAL_PART);
    m_functions[FUNC_NAMESPACE] = new FuncLoader(""FuncNamespace"",
            FUNC_NAMESPACE);
    m_functions[FUNC_QNAME] = new FuncLoader(""FuncQname"", FUNC_QNAME);
    m_functions[FUNC_GENERATE_ID] = new FuncLoader(""FuncGenerateId"",
            FUNC_GENERATE_ID);
    m_functions[FUNC_NOT] = new FuncLoader(""FuncNot"", FUNC_NOT);
    m_functions[FUNC_TRUE] = new FuncLoader(""FuncTrue"", FUNC_TRUE);
    m_functions[FUNC_FALSE] = new FuncLoader(""FuncFalse"", FUNC_FALSE);
    m_functions[FUNC_BOOLEAN] = new FuncLoader(""FuncBoolean"", FUNC_BOOLEAN);
    m_functions[FUNC_LANG] = new FuncLoader(""FuncLang"", FUNC_LANG);
    m_functions[FUNC_NUMBER] = new FuncLoader(""FuncNumber"", FUNC_NUMBER);
    m_functions[FUNC_FLOOR] = new FuncLoader(""FuncFloor"", FUNC_FLOOR);
    m_functions[FUNC_CEILING] = new FuncLoader(""FuncCeiling"", FUNC_CEILING);
    m_functions[FUNC_ROUND] = new FuncLoader(""FuncRound"", FUNC_ROUND);
    m_functions[FUNC_SUM] = new FuncLoader(""FuncSum"", FUNC_SUM);
    m_functions[FUNC_STRING] = new FuncLoader(""FuncString"", FUNC_STRING);
    m_functions[FUNC_STARTS_WITH] = new FuncLoader(""FuncStartsWith"",
            FUNC_STARTS_WITH);
    m_functions[FUNC_CONTAINS] = new FuncLoader(""FuncContains"",
                                                FUNC_CONTAINS);
    m_functions[FUNC_SUBSTRING_BEFORE] = new FuncLoader(""FuncSubstringBefore"",
            FUNC_SUBSTRING_BEFORE);
    m_functions[FUNC_SUBSTRING_AFTER] = new FuncLoader(""FuncSubstringAfter"",
            FUNC_SUBSTRING_AFTER);
    m_functions[FUNC_NORMALIZE_SPACE] = new FuncLoader(""FuncNormalizeSpace"",
            FUNC_NORMALIZE_SPACE);
    m_functions[FUNC_TRANSLATE] = new FuncLoader(""FuncTranslate"",
            FUNC_TRANSLATE);
    m_functions[FUNC_CONCAT] = new FuncLoader(""FuncConcat"", FUNC_CONCAT);

    
    m_functions[FUNC_SYSTEM_PROPERTY] = new FuncLoader(""FuncSystemProperty"",
            FUNC_SYSTEM_PROPERTY);
    m_functions[FUNC_EXT_FUNCTION_AVAILABLE] =
      new FuncLoader(""FuncExtFunctionAvailable"", FUNC_EXT_FUNCTION_AVAILABLE);
    m_functions[FUNC_EXT_ELEM_AVAILABLE] =
      new FuncLoader(""FuncExtElementAvailable"", FUNC_EXT_ELEM_AVAILABLE);
    m_functions[FUNC_SUBSTRING] = new FuncLoader(""FuncSubstring"",
            FUNC_SUBSTRING);
    m_functions[FUNC_STRING_LENGTH] = new FuncLoader(""FuncStringLength"",
            FUNC_STRING_LENGTH);
    m_functions[FUNC_DOCLOCATION] = new FuncLoader(""FuncDoclocation"",
            FUNC_DOCLOCATION);
    m_functions[FUNC_UNPARSED_ENTITY_URI] =
      new FuncLoader(""FuncUnparsedEntityURI"", FUNC_UNPARSED_ENTITY_URI);
  }

  
  public static Function getFunction(int which)
          throws javax.xml.transform.TransformerException
  {
    return m_functions[which].getFunction();
  }

  
  public static int installFunction(String name, Expression func)
  {

    int funcIndex;
    Object funcIndexObj = Keywords.m_functions.get(name);

    if (null != funcIndexObj)
    {
      funcIndex = ((Integer) funcIndexObj).intValue();
    }
    else
    {
      funcIndex = m_funcNextFreeIndex;

      m_funcNextFreeIndex++;

      Keywords.m_functions.put(name, new Integer(funcIndex));
    }

    FuncLoader loader = new FuncLoader(func.getClass().getName(), funcIndex);

    m_functions[funcIndex] = loader;

    return funcIndex;
  }

  
  public static void installFunction(Expression func, int funcIndex)
  {

    FuncLoader loader = new FuncLoader(func.getClass().getName(), funcIndex);

    m_functions[funcIndex] = loader;
  }
}
"
org.apache.xml.utils.res.XResourceBundle,5,3,12,13,16,8,13,0,3,1.223684211,424,0.0,0,0.926829268,0.416666667,0,0,80.0,3,1.0,0,"
package org.apache.xml.utils.res;

import java.util.*;


public class XResourceBundle extends ListResourceBundle
{

  
  public static final String ERROR_RESOURCES =
    ""org.apache.xalan.res.XSLTErrorResources"", XSLT_RESOURCE =
    ""org.apache.xml.utils.res.XResourceBundle"", LANG_BUNDLE_NAME =
    ""org.apache.xml.utils.res.XResources"", MULT_ORDER =
    ""multiplierOrder"", MULT_PRECEDES = ""precedes"", MULT_FOLLOWS =
    ""follows"", LANG_ORIENTATION = ""orientation"", LANG_RIGHTTOLEFT =
    ""rightToLeft"", LANG_LEFTTORIGHT = ""leftToRight"", LANG_NUMBERING =
    ""numbering"", LANG_ADDITIVE = ""additive"", LANG_MULT_ADD =
    ""multiplicative-additive"", LANG_MULTIPLIER =
    ""multiplier"", LANG_MULTIPLIER_CHAR =
    ""multiplierChar"", LANG_NUMBERGROUPS = ""numberGroups"", LANG_NUM_TABLES =
    ""tables"", LANG_ALPHABET = ""alphabet"", LANG_TRAD_ALPHABET = ""tradAlphabet"";

  
  public static final XResourceBundle loadResourceBundle(
          String className, Locale locale) throws MissingResourceException
  {

    String suffix = getResourceSuffix(locale);

    
    try
    {
      
      
      String resourceName = className + suffix;
      return (XResourceBundle) ResourceBundle.getBundle(resourceName, locale);
    }
    catch (MissingResourceException e)
    {
      try  
      {

        
        
        return (XResourceBundle) ResourceBundle.getBundle(
          XSLT_RESOURCE, new Locale(""en"", ""US""));
      }
      catch (MissingResourceException e2)
      {

        
        
        throw new MissingResourceException(
          ""Could not load any resource bundles."", className, """");
      }
    }
  }

  
  private static final String getResourceSuffix(Locale locale)
  {

    String lang = locale.getLanguage();
    String country = locale.getCountry();
    String variant = locale.getVariant();
    String suffix = ""_"" + locale.getLanguage();

    if (lang.equals(""zh""))
      suffix += ""_"" + country;

    if (country.equals(""JP""))
      suffix += ""_"" + country + ""_"" + variant;

    return suffix;
  }

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""en"" }, { ""help_language"", ""en"" }, { ""language"", ""en"" },
    { ""alphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },
  };
}
"
org.apache.xalan.xsltc.compiler.WithParam,6,3,0,25,39,0,1,24,5,0.4,201,1.0,2,0.918032787,0.361111111,1,6,32.16666667,3,1.6667,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class WithParam extends Instruction {

    private QName _name;
    private Expression _select;

    
    public void display(int indent) {
	indent(indent);
	Util.println(""with-param "" + _name);
	if (_select != null) {
	    indent(indent + IndentIncrement);
	    Util.println(""select "" + _select.toString());
	}
	displayContents(indent + IndentIncrement);
    }

    
    public void parseContents(Parser parser) {
	final String name = getAttribute(""name"");
	if (name.length() > 0) {
	    _name = parser.getQName(name);
	}
        else {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""name"");
        }
	
	final String select = getAttribute(""select"");
	if (select.length() > 0) {
	    _select = parser.parseExpression(this, ""select"", null);
	}
	
	parseChildren(parser);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_select != null) {
	    final Type tselect = _select.typeCheck(stable);
	    if (tselect instanceof ReferenceType == false) {
		_select = new CastExpr(_select, Type.Reference);
	    }
	}
	else {
	    typeCheckContents(stable);
	}
	return Type.Void;
    }

    
    public void translateValue(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	
	if (_select != null) {
	    _select.translate(classGen, methodGen);
	    _select.startResetIterator(classGen, methodGen);
	}
	
	else if (hasContents()) {
	    compileResultTree(classGen, methodGen);
	}
	
	else {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();
	    il.append(new PUSH(cpg, Constants.EMPTYSTRING));
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	String name = Util.escape(_name.getLocalPart());

	
	il.append(classGen.loadTranslet());

	
	il.append(new PUSH(cpg, name)); 
	
	translateValue(classGen, methodGen);
	
	il.append(new PUSH(cpg, false));
	
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
						     ADD_PARAMETER,
						     ADD_PARAMETER_SIG)));
	il.append(POP); 
    }
}
"
org.apache.xalan.lib.PipeDocument,3,1,0,11,46,3,0,11,3,2.0,261,0.0,0,0.0,0.466666667,0,0,86.0,1,0.6667,0,"
package org.apache.xalan.lib;

import org.apache.xalan.extensions.XSLProcessorContext;
import org.apache.xalan.templates.ElemExtensionCall;
import org.apache.xalan.templates.ElemLiteralResult;
import org.apache.xalan.templates.AVT;
import org.apache.xalan.transformer.TransformerImpl;


import javax.xml.transform.TransformerFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.Templates;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.sax.SAXResult;


import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException; 


import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.Parser;
import org.xml.sax.helpers.ParserAdapter;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.XMLReader;
import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;


import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;


import org.apache.xalan.serialize.Serializer;
import org.apache.xalan.serialize.SerializerFactory;
import org.apache.xalan.templates.OutputProperties;


import org.apache.xpath.XPathContext;
import org.apache.xml.utils.SystemIDResolver;


import java.io.FileOutputStream;
import java.io.IOException;
import java.io.FileNotFoundException;
import java.util.Vector;
import java.util.Properties;


public class PipeDocument
{

  public void pipeDocument(XSLProcessorContext context, ElemExtensionCall elem)
	  throws TransformerException, TransformerConfigurationException, 
         SAXException, IOException, FileNotFoundException	   
  {
    try
    {
      SAXTransformerFactory saxTFactory = (SAXTransformerFactory) TransformerFactory.newInstance();
      
      
      String source =  elem.getAttribute(""source"", 
                                         context.getContextNode(),
                                         context.getTransformer());
      TransformerImpl transImpl = context.getTransformer();

      
      String baseURLOfSource = transImpl.getBaseURLOfSource();
      
      String absSourceURL = SystemIDResolver.getAbsoluteURI(source, baseURLOfSource);      

      
      String target =  elem.getAttribute(""target"", 
                                         context.getContextNode(),
                                         context.getTransformer());
      
      XPathContext xctxt = context.getTransformer().getXPathContext();
      int xt = xctxt.getDTMHandleFromNode(context.getContextNode());
 
      
      String sysId = elem.getSystemId();
      
      NodeList ssNodes = null;
      NodeList paramNodes = null;
      Node ssNode = null;
      Node paramNode = null;
      if (elem.hasChildNodes())
      {
        ssNodes = elem.getChildNodes();        
        
        Vector vTHandler = new Vector(ssNodes.getLength());
        
        
        
        
        
        for (int i = 0; i < ssNodes.getLength(); i++)
        {
          ssNode = ssNodes.item(i);
          if (ssNode.getNodeType() == ssNode.ELEMENT_NODE
              && ((Element)ssNode).getTagName().equals(""stylesheet"")
              && ssNode instanceof ElemLiteralResult)
          {
            AVT avt = ((ElemLiteralResult)ssNode).getLiteralResultAttribute(""href"");
            String href = avt.evaluate(xctxt,xt, elem);
            String absURI = SystemIDResolver.getAbsoluteURI(href, sysId);
            Templates tmpl = saxTFactory.newTemplates(new StreamSource(absURI));
            TransformerHandler tHandler = saxTFactory.newTransformerHandler(tmpl);
            Transformer trans = tHandler.getTransformer();
            
            
            vTHandler.addElement(tHandler);

            paramNodes = ssNode.getChildNodes();
            for (int j = 0; j < paramNodes.getLength(); j++)
            {
              paramNode = paramNodes.item(j);
              if (paramNode.getNodeType() == paramNode.ELEMENT_NODE 
                  && ((Element)paramNode).getTagName().equals(""param"")
                  && paramNode instanceof ElemLiteralResult)
              {
                 avt = ((ElemLiteralResult)paramNode).getLiteralResultAttribute(""name"");
                 String pName = avt.evaluate(xctxt,xt, elem);
                 avt = ((ElemLiteralResult)paramNode).getLiteralResultAttribute(""value"");
                 String pValue = avt.evaluate(xctxt,xt, elem);
                 trans.setParameter(pName, pValue);
               } 
             }
           }
         }
         usePipe(vTHandler, absSourceURL, target);
       }
     }
     catch (Exception e)
     {
       e.printStackTrace();
     }
  }
  
  public void usePipe(Vector vTHandler, String source, String target)
          throws TransformerException, TransformerConfigurationException, 
                 FileNotFoundException, IOException, SAXException, SAXNotRecognizedException
  {
    XMLReader reader = XMLReaderFactory.createXMLReader();
    TransformerHandler tHFirst = (TransformerHandler)vTHandler.firstElement();
    reader.setContentHandler(tHFirst);
    reader.setProperty(""http:
    for (int i = 1; i < vTHandler.size(); i++)
    {
      TransformerHandler tHFrom = (TransformerHandler)vTHandler.elementAt(i-1);
      TransformerHandler tHTo = (TransformerHandler)vTHandler.elementAt(i);
      tHFrom.setResult(new SAXResult(tHTo));      
    }
    TransformerHandler tHLast = (TransformerHandler)vTHandler.lastElement();
    Transformer trans = tHLast.getTransformer();
    Properties outputProps = trans.getOutputProperties();
    Serializer serializer = SerializerFactory.getSerializer(outputProps);
    serializer.setOutputStream(new FileOutputStream(target));
    tHLast.setResult(new SAXResult(serializer.asContentHandler()));
    
    reader.parse(source);
  }
 
}"
org.apache.xalan.xsltc.compiler.Variable,6,4,0,36,48,15,10,30,5,2.0,282,0.0,0,0.938271605,0.4,2,12,46.0,8,3.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.Field;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.dom.Axis;

final class Variable extends VariableBase {

    public int getIndex() {
	return (_local != null) ? _local.getIndex() : -1;
    }

    
    public void parseContents(Parser parser) {
	
	super.parseContents(parser);

	
	SyntaxTreeNode parent = getParent();
	if (parent instanceof Stylesheet) {
	    
	    _isLocal = false;
	    
	    Variable var = parser.getSymbolTable().lookupVariable(_name);
	    
	    if (var != null) {
		final int us = this.getImportPrecedence();
		final int them = var.getImportPrecedence();
		
		if (us == them) {
		    final String name = _name.toString();
		    reportError(this, parser, ErrorMsg.VARIABLE_REDEF_ERR,name);
		}
		
		else if (them > us) {
		    _ignore = true;
		    return;
		}
		else {
		    var.disable();
		}
		
	    }
	    ((Stylesheet)parent).addVariable(this);
	    parser.getSymbolTable().addVariable(this);
	}
	else {
	    _isLocal = true;
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	if (_select != null) {
	    _type = _select.typeCheck(stable);
	}
	
	else if (hasContents()) {
	    typeCheckContents(stable);
	    _type = Type.ResultTree;
	}
	else {
	    _type = Type.Reference;
	}
	
	
	
	return Type.Void;
    }

    
    public void initialize(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	if (isLocal() && !_refs.isEmpty()) {
	    
	    if (_local == null) {
		_local = methodGen.addLocalVariable2(_name.getLocalPart(),
						     _type.toJCType(),
						     il.getEnd());
	    }
	    
	    if ((_type instanceof IntType) ||
		(_type instanceof NodeType) ||
		(_type instanceof BooleanType))
		il.append(new ICONST(0)); 
	    else if (_type instanceof RealType)
		il.append(new DCONST(0)); 
	    else
		il.append(new ACONST_NULL()); 
	    il.append(_type.STORE(_local.getIndex()));
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final String name = getVariable();

	
	if (_ignore) return;
	_ignore = true;

	if (isLocal()) {
	    
	    translateValue(classGen, methodGen);

	    
	    if (_refs.isEmpty()) { 
		il.append(_type.POP());
		_local = null;
	    }
	    else {		   
		if (_local == null) mapRegister(methodGen);
		il.append(_type.STORE(_local.getIndex()));
	    }
	}
	else {
	    String signature = _type.toSignature();

	    
	    if (classGen.containsField(name) == null) {
		classGen.addField(new Field(ACC_PUBLIC, 
					    cpg.addUtf8(name),
					    cpg.addUtf8(signature),
					    null, cpg.getConstantPool()));

		
		il.append(classGen.loadTranslet());
		
		translateValue(classGen, methodGen);
		
		il.append(new PUTFIELD(cpg.addFieldref(classGen.getClassName(),
						       name, signature)));
	    }
	}
    }
}
"
org.apache.xpath.objects.XNodeSet,33,4,2,42,74,516,24,19,31,0.96875,600,0.0,6,0.801470588,0.173611111,3,29,17.0,2,1.1515,2,"
package org.apache.xpath.objects;




import org.w3c.dom.traversal.NodeIterator;
import org.w3c.dom.NodeList;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;

import org.apache.xpath.DOMHelper;
import org.apache.xpath.XPathContext;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.axes.ContextNodeList;
import org.apache.xpath.axes.NodeSequence;
import org.apache.xml.utils.StringVector;
import org.apache.xml.utils.XMLString;


public class XNodeSet extends NodeSequence
{  
  
  protected XNodeSet()
  {
  }

  
  public XNodeSet(DTMIterator val)
  {
  	super();
  	if(val instanceof XNodeSet)
  	{
	    setIter(((XNodeSet)val).m_iter);
	    m_dtmMgr = ((XNodeSet)val).m_dtmMgr;
	    m_last = ((XNodeSet)val).m_last;
	    if(!((XNodeSet)val).hasCache())
	    	((XNodeSet)val).setShouldCacheNodes(true);
	    m_obj = ((XNodeSet)val).m_obj;
  	}
  	else
    	setIter(val);
  }
  
  
  public XNodeSet(XNodeSet val)
  {
  	super();
    setIter(val.m_iter);
    m_dtmMgr = val.m_dtmMgr;
    m_last = val.m_last;
    if(!val.hasCache())
    	val.setShouldCacheNodes(true);
    m_obj = val.m_obj;
  }


  
  public XNodeSet(DTMManager dtmMgr) 
  {
    super(dtmMgr);
  }

  
  public XNodeSet(int n, DTMManager dtmMgr)
  {

    super(new NodeSetDTM(dtmMgr));
    m_dtmMgr = dtmMgr;

    if (DTM.NULL != n)
    {
      ((NodeSetDTM) m_obj).addNode(n);
      m_last = 1;
    }
    else
    	m_last = 0;
  }

  
  public int getType()
  {
    return CLASS_NODESET;
  }

  
  public String getTypeString()
  {
    return ""#NODESET"";
  }

  
  public double getNumberFromNode(int n)
  {
    XMLString xstr = m_dtmMgr.getDTM(n).getStringValue(n);
    return xstr.toDouble();
  }

  
  public double num()
  {

    int node = item(0);
    return (node != DTM.NULL) ? getNumberFromNode(node) : Double.NaN;
  }
  
  
  public double numWithSideEffects()
  {
    int node = nextNode();

    return (node != DTM.NULL) ? getNumberFromNode(node) : Double.NaN;
  }


  
  public boolean bool()
  {
    return (item(0) != DTM.NULL);
  }
  
  
  public boolean boolWithSideEffects()
  {
    return (nextNode() != DTM.NULL);
  }

  
  
  public XMLString getStringFromNode(int n)
  {
    
    
    if(DTM.NULL != n)
    {
      return m_dtmMgr.getDTM(n).getStringValue(n);
    }
    else
    {
      return org.apache.xpath.objects.XString.EMPTYSTRING;
    }
  }
  
  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {
    int node = item(0);
	
    if(node != DTM.NULL)
    {
      m_dtmMgr.getDTM(node).dispatchCharactersEvents(node, ch, false);
    }
    
  }
  
  
  public XMLString xstr()
  {
    int node = item(0);
    return (node != DTM.NULL) ? getStringFromNode(node) : XString.EMPTYSTRING;
  }
  
  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    XString xstring = (XString)xstr();
    xstring.appendToFsb(fsb);
  }
  

  
  public String str()
  {
    int node = item(0);
    return (node != DTM.NULL) ? getStringFromNode(node).toString() : """";   
  }
  
  
  public Object object()
  {
    if(null == m_obj)
    	return this;
    else
    	return m_obj;
  }

  
  


























  
  public NodeIterator nodeset() throws javax.xml.transform.TransformerException
  {
    return new org.apache.xml.dtm.ref.DTMNodeIterator(iter());
  }
  
  
  public NodeList nodelist() throws javax.xml.transform.TransformerException
  {
    return new org.apache.xml.dtm.ref.DTMNodeList(iter());
  }

  











  
  public DTMIterator iterRaw()
  {
    return this;
  }
  
  public void release(DTMIterator iter)
  {
  }
  
  
  public DTMIterator iter()
  {
    try
    {
    	if(hasCache())
      		return cloneWithReset();
      	else
      		return this; 
    }
    catch (CloneNotSupportedException cnse)
    {
      throw new RuntimeException(cnse.getMessage());
    }
  }
  
  
  public XObject getFresh()
  {
    try
    {
    	if(hasCache())
      		return (XObject)cloneWithReset();
      	else
      		return this; 
    }
    catch (CloneNotSupportedException cnse)
    {
      throw new RuntimeException(cnse.getMessage());
    }
  }

  
  public NodeSetDTM mutableNodeset()
  {
    NodeSetDTM mnl;

    if(m_obj instanceof NodeSetDTM)
    {
      mnl = (NodeSetDTM) m_obj;
    }
    else
    {
      mnl = new NodeSetDTM(iter());
      m_obj = mnl;
      setCurrentPos(0);
    }

    return mnl;
  }

  
  static LessThanComparator S_LT = new LessThanComparator();

  
  static LessThanOrEqualComparator S_LTE = new LessThanOrEqualComparator();

  
  static GreaterThanComparator S_GT = new GreaterThanComparator();

  
  static GreaterThanOrEqualComparator S_GTE =
    new GreaterThanOrEqualComparator();

  
  static EqualComparator S_EQ = new EqualComparator();

  
  static NotEqualComparator S_NEQ = new NotEqualComparator();

  
  public boolean compare(XObject obj2, Comparator comparator)
          throws javax.xml.transform.TransformerException
  {

    boolean result = false;
    int type = obj2.getType();

    if (XObject.CLASS_NODESET == type)
    {
      

      
      
      
      
      
      
      
      
      
      
      
      DTMIterator list1 = iterRaw();
      DTMIterator list2 = ((XNodeSet) obj2).iterRaw();
      int node1;
      java.util.Vector node2Strings = null;

      while (DTM.NULL != (node1 = list1.nextNode()))
      {
        XMLString s1 = getStringFromNode(node1);

        if (null == node2Strings)
        {
          int node2;

          while (DTM.NULL != (node2 = list2.nextNode()))
          {
            XMLString s2 = getStringFromNode(node2);

            if (comparator.compareStrings(s1, s2))
            {
              result = true;

              break;
            }

            if (null == node2Strings)
              node2Strings = new java.util.Vector();

            node2Strings.addElement(s2);
          }
        }
        else
        {
          int n = node2Strings.size();

          for (int i = 0; i < n; i++)
          {
            if (comparator.compareStrings(s1, (XMLString)node2Strings.elementAt(i)))
            {
              result = true;

              break;
            }
          }
        }
      }
      list1.reset();
      list2.reset();
    }
    else if (XObject.CLASS_BOOLEAN == type)
    {

      
      
      
      
      
      
      double num1 = bool() ? 1.0 : 0.0;
      double num2 = obj2.num();

      result = comparator.compareNumbers(num1, num2);
    }
    else if (XObject.CLASS_NUMBER == type)
    {

      
      
      
      
      
      
      
      DTMIterator list1 = iterRaw();
      double num2 = obj2.num();
      int node;

      while (DTM.NULL != (node = list1.nextNode()))
      {
        double num1 = getNumberFromNode(node);

        if (comparator.compareNumbers(num1, num2))
        {
          result = true;

          break;
        }
      }
      list1.reset();
    }
    else if (XObject.CLASS_RTREEFRAG == type)
    {
      XMLString s2 = obj2.xstr();
      DTMIterator list1 = iterRaw();
      int node;

      while (DTM.NULL != (node = list1.nextNode()))
      {
        XMLString s1 = getStringFromNode(node);

        if (comparator.compareStrings(s1, s2))
        {
          result = true;

          break;
        }
      }
      list1.reset();
    }
    else if (XObject.CLASS_STRING == type)
    {

      
      
      
      
      
      
      XMLString s2 = obj2.xstr();
      DTMIterator list1 = iterRaw();
      int node;

      while (DTM.NULL != (node = list1.nextNode()))
      {
        XMLString s1 = getStringFromNode(node);
        if (comparator.compareStrings(s1, s2))
        {
          result = true;

          break;
        }
      }
      list1.reset();
    }
    else
    {
      result = comparator.compareNumbers(this.num(), obj2.num());
    }

    return result;
  }

  
  public boolean lessThan(XObject obj2) throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_LT);
  }

  
  public boolean lessThanOrEqual(XObject obj2) throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_LTE);
  }

  
  public boolean greaterThan(XObject obj2) throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_GT);
  }

  
  public boolean greaterThanOrEqual(XObject obj2)
          throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_GTE);
  }

  
  public boolean equals(XObject obj2)
  {
    try
    {
      return compare(obj2, S_EQ);
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }

  
  public boolean notEquals(XObject obj2) throws javax.xml.transform.TransformerException
  {
    return compare(obj2, S_NEQ);
  }
}


abstract class Comparator
{

  
  abstract boolean compareStrings(XMLString s1, XMLString s2);

  
  abstract boolean compareNumbers(double n1, double n2);
}


class LessThanComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return (s1.toDouble() < s2.toDouble());
    
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 < n2;
  }
}


class LessThanOrEqualComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return (s1.toDouble() <= s2.toDouble());
    
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 <= n2;
  }
}


class GreaterThanComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return (s1.toDouble() > s2.toDouble());
    
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 > n2;
  }
}


class GreaterThanOrEqualComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return (s1.toDouble() >= s2.toDouble());
    
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 >= n2;
  }
}


class EqualComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return s1.equals(s2);
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 == n2;
  }
}


class NotEqualComparator extends Comparator
{

  
  boolean compareStrings(XMLString s1, XMLString s2)
  {
    return !s1.equals(s2);
  }

  
  boolean compareNumbers(double n1, double n2)
  {
    return n1 != n2;
  }
}
"
org.apache.xalan.templates.ElemNumber,42,3,0,29,135,617,4,28,27,0.860310421,2387,1.0,9,0.830508475,0.136298422,2,6,55.57142857,26,2.0952,0,"
package org.apache.xalan.templates;

import org.apache.xml.utils.res.XResourceBundle;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;

import org.xml.sax.*;

import java.util.*;

import java.text.DecimalFormatSymbols;
import java.text.NumberFormat;
import java.text.DecimalFormat;

import org.apache.xpath.*;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.PrefixResolverDefault;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.StringBufferPool;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xalan.res.*;
import org.apache.xalan.transformer.DecimalToRoman;
import org.apache.xalan.transformer.CountersTable;
import org.apache.xalan.transformer.ResultTreeHandler;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.NodeVector;

import javax.xml.transform.TransformerException;




public class ElemNumber extends ElemTemplateElement 
{

    private class MyPrefixResolver implements PrefixResolver {
        
        DTM dtm;
        int handle;
        boolean handleNullPrefix;
        
		
		public MyPrefixResolver(Node xpathExpressionContext, DTM dtm, int handle, boolean handleNullPrefix) {
            this.dtm = dtm;
            this.handle = handle;
            this.handleNullPrefix = handleNullPrefix;
		}

    	
		public String getNamespaceForPrefix(String prefix) {
            return dtm.getNamespaceURI(handle);
		}
        
        
        public String getNamespaceForPrefix(String prefix, Node context) {
            return getNamespaceForPrefix(prefix);
        }

		
		public String getBaseIdentifier() {
			return ElemNumber.this.getBaseIdentifier();
		}

		
		public boolean handlesNullPrefixes() {
			return handleNullPrefix;
		}

}
    
  
  private XPath m_countMatchPattern = null;

  
  public void setCount(XPath v)
  {
    m_countMatchPattern = v;
  }

  
  public XPath getCount()
  {
    return m_countMatchPattern;
  }

  
  private XPath m_fromMatchPattern = null;

  
  public void setFrom(XPath v)
  {
    m_fromMatchPattern = v;
  }

  
  public XPath getFrom()
  {
    return m_fromMatchPattern;
  }

  
  private int m_level = Constants.NUMBERLEVEL_SINGLE;

  
  public void setLevel(int v)
  {
    m_level = v;
  }

  
  public int getLevel()
  {
    return m_level;
  }

  
  private XPath m_valueExpr = null;

  
  public void setValue(XPath v)
  {
    m_valueExpr = v;
  }

  
  public XPath getValue()
  {
    return m_valueExpr;
  }

  
  private AVT m_format_avt = null;

  
  public void setFormat(AVT v)
  {
    m_format_avt = v;
  }

  
  public AVT getFormat()
  {
    return m_format_avt;
  }

  
  private AVT m_lang_avt = null;

  
  public void setLang(AVT v)
  {
    m_lang_avt = v;
  }

  
  public AVT getLang()
  {
    return m_lang_avt;
  }

  
  private AVT m_lettervalue_avt = null;

  
  public void setLetterValue(AVT v)
  {
    m_lettervalue_avt = v;
  }

  
  public AVT getLetterValue()
  {
    return m_lettervalue_avt;
  }

  
  private AVT m_groupingSeparator_avt = null;

  
  public void setGroupingSeparator(AVT v)
  {
    m_groupingSeparator_avt = v;
  }

  
  public AVT getGroupingSeparator()
  {
    return m_groupingSeparator_avt;
  }

  
  private AVT m_groupingSize_avt = null;

  
  public void setGroupingSize(AVT v)
  {
    m_groupingSize_avt = v;
  }

  
  public AVT getGroupingSize()
  {
    return m_groupingSize_avt;
  }

  

  

  
  private final static DecimalToRoman m_romanConvertTable[] = {
    new DecimalToRoman(1000, ""M"", 900, ""CM""),
    new DecimalToRoman(500, ""D"", 400, ""CD""),
    new DecimalToRoman(100L, ""C"", 90L, ""XC""),
    new DecimalToRoman(50L, ""L"", 40L, ""XL""),
    new DecimalToRoman(10L, ""X"", 9L, ""IX""),
    new DecimalToRoman(5L, ""V"", 4L, ""IV""),
    new DecimalToRoman(1L, ""I"", 1L, ""I"") };

  
  private static char[] m_alphaCountTable = null;
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_countMatchPattern)
      m_countMatchPattern.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_format_avt)
      m_format_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_fromMatchPattern)
      m_fromMatchPattern.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_groupingSeparator_avt)
      m_groupingSeparator_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_groupingSize_avt)
      m_groupingSize_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_lang_avt)
      m_lang_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_lettervalue_avt)
      m_lettervalue_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_valueExpr)
      m_valueExpr.fixupVariables(vnames, cstate.getGlobalsSize());
  }


  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_NUMBER;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_NUMBER_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

     if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    int sourceNode = transformer.getXPathContext().getCurrentNode();
    String countString = getCountString(transformer, sourceNode);

    try
    {
      transformer.getResultTreeHandler().characters(countString.toCharArray(),
                                                    0, countString.length());
    }
    catch(SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
	    transformer.getTraceManager().fireTraceEndEvent(this); 
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }

  
  int findAncestor(
          XPathContext xctxt, XPath fromMatchPattern, XPath countMatchPattern, 
          int context, ElemNumber namespaceContext)
            throws javax.xml.transform.TransformerException
  {
    DTM dtm = xctxt.getDTM(context);
    while (DTM.NULL != context)
    {
      if (null != fromMatchPattern)
      {
        if (fromMatchPattern.getMatchScore(xctxt, context)
                != XPath.MATCH_SCORE_NONE)
        {

          
          break;
        }
      }

      if (null != countMatchPattern)
      {
        if (countMatchPattern.getMatchScore(xctxt, context)
                != XPath.MATCH_SCORE_NONE)
        {
          break;
        }
      }

      context = dtm.getParent(context);
    }

    return context;
  }

  
  private int findPrecedingOrAncestorOrSelf(
          XPathContext xctxt, XPath fromMatchPattern, XPath countMatchPattern, 
          int context, ElemNumber namespaceContext)
            throws javax.xml.transform.TransformerException
  {
    DTM dtm = xctxt.getDTM(context);
    while (DTM.NULL != context)
    {
      if (null != fromMatchPattern)
      {
        if (fromMatchPattern.getMatchScore(xctxt, context)
                != XPath.MATCH_SCORE_NONE)
        {
          context = DTM.NULL;

          break;
        }
      }

      if (null != countMatchPattern)
      {
        if (countMatchPattern.getMatchScore(xctxt, context)
                != XPath.MATCH_SCORE_NONE)
        {
          break;
        }
      }

      int prevSibling = dtm.getPreviousSibling(context);

      if (DTM.NULL == prevSibling)
      {
        context = dtm.getParent(context);
      }
      else
      {

        
        context = dtm.getLastChild(prevSibling);

        if (context == DTM.NULL)
          context = prevSibling;
      }
    }

    return context;
  }

  
  XPath getCountMatchPattern(XPathContext support, int contextNode)
          throws javax.xml.transform.TransformerException
  {

    XPath countMatchPattern = m_countMatchPattern;
    DTM dtm = support.getDTM(contextNode);
    if (null == countMatchPattern)
    {
      switch (dtm.getNodeType(contextNode))
      {
      case DTM.ELEMENT_NODE :
        MyPrefixResolver resolver;

        if (dtm.getNamespaceURI(contextNode) == null) {
             resolver =  new MyPrefixResolver(dtm.getNode(contextNode), dtm,contextNode, false);
        } else {
            resolver = new MyPrefixResolver(dtm.getNode(contextNode), dtm,contextNode, true);
        }

        countMatchPattern = new XPath(dtm.getNodeName(contextNode), this, resolver,
                                      XPath.MATCH, support.getErrorListener());
        break;

      case DTM.ATTRIBUTE_NODE :

        
        countMatchPattern = new XPath(""@"" + dtm.getNodeName(contextNode), this,
                                      this, XPath.MATCH, support.getErrorListener());
        break;
      case DTM.CDATA_SECTION_NODE :
      case DTM.TEXT_NODE :

        
        countMatchPattern = new XPath(""text()"", this, this, XPath.MATCH, support.getErrorListener());
        break;
      case DTM.COMMENT_NODE :

        
        countMatchPattern = new XPath(""comment()"", this, this, XPath.MATCH, support.getErrorListener());
        break;
      case DTM.DOCUMENT_NODE :

        
        countMatchPattern = new XPath(""/"", this, this, XPath.MATCH, support.getErrorListener());
        break;
      case DTM.PROCESSING_INSTRUCTION_NODE :

        
        countMatchPattern = new XPath(""pi("" + dtm.getNodeName(contextNode)
                                      + "")"", this, this, XPath.MATCH, support.getErrorListener());
        break;
      default :
        countMatchPattern = null;
      }
    }

    return countMatchPattern;
  }

  
  String getCountString(TransformerImpl transformer, int sourceNode)
          throws TransformerException
  {

    long[] list = null;
    XPathContext xctxt = transformer.getXPathContext();
    CountersTable ctable = transformer.getCountersTable();

    if (null != m_valueExpr)
    {
      XObject countObj = m_valueExpr.execute(xctxt, sourceNode, this);
      long count = (long)java.lang.Math.floor(countObj.num()+ 0.5);

      list = new long[1];
      list[0] = count;
    }
    else
    {
      if (Constants.NUMBERLEVEL_ANY == m_level)
      {
        list = new long[1];
        list[0] = ctable.countNode(xctxt, this, sourceNode);
      }
      else
      {
        NodeVector ancestors =
          getMatchingAncestors(xctxt, sourceNode,
                               Constants.NUMBERLEVEL_SINGLE == m_level);
        int lastIndex = ancestors.size() - 1;

        if (lastIndex >= 0)
        {
          list = new long[lastIndex + 1];

          for (int i = lastIndex; i >= 0; i--)
          {
            int target = ancestors.elementAt(i);

            list[lastIndex - i] = ctable.countNode(xctxt, this, target);
          }
        }
      }
    }

    return (null != list)
           ? formatNumberList(transformer, list, sourceNode) : """";
  }

  
  public int getPreviousNode(XPathContext xctxt, int pos)
          throws TransformerException
  {

    XPath countMatchPattern = getCountMatchPattern(xctxt, pos);
    DTM dtm = xctxt.getDTM(pos);

    if (Constants.NUMBERLEVEL_ANY == m_level)
    {
      XPath fromMatchPattern = m_fromMatchPattern;

      
      
      
      while (DTM.NULL != pos)
      {

        
        
        
        int next = dtm.getPreviousSibling(pos);

        if (DTM.NULL == next)
        {
          next = dtm.getParent(pos);

          if ((DTM.NULL != next) && ((((null != fromMatchPattern) && (fromMatchPattern.getMatchScore(
                  xctxt, next) != XPath.MATCH_SCORE_NONE))) 
              || (dtm.getNodeType(next) == DTM.DOCUMENT_NODE)))
          {
            pos = DTM.NULL;  

            break;  
          }
        }
        else
        {

          
          int child = next;

          while (DTM.NULL != child)
          {
            child = dtm.getLastChild(next);

            if (DTM.NULL != child)
              next = child;
          }
        }

        pos = next;

        if ((DTM.NULL != pos)
                && ((null == countMatchPattern)
                    || (countMatchPattern.getMatchScore(xctxt, pos)
                        != XPath.MATCH_SCORE_NONE)))
        {
          break;
        }
      }
    }
    else  
    {
      while (DTM.NULL != pos)
      {
        pos = dtm.getPreviousSibling(pos);

        if ((DTM.NULL != pos)
                && ((null == countMatchPattern)
                    || (countMatchPattern.getMatchScore(xctxt, pos)
                        != XPath.MATCH_SCORE_NONE)))
        {
          break;
        }
      }
    }

    return pos;
  }

  
  public int getTargetNode(XPathContext xctxt, int sourceNode)
          throws TransformerException
  {

    int target = DTM.NULL;
    XPath countMatchPattern = getCountMatchPattern(xctxt, sourceNode);

    if (Constants.NUMBERLEVEL_ANY == m_level)
    {
      target = findPrecedingOrAncestorOrSelf(xctxt, m_fromMatchPattern,
                                             countMatchPattern, sourceNode,
                                             this);
    }
    else
    {
      target = findAncestor(xctxt, m_fromMatchPattern, countMatchPattern,
                            sourceNode, this);
    }

    return target;
  }

  
  NodeVector getMatchingAncestors(
          XPathContext xctxt, int node, boolean stopAtFirstFound)
            throws javax.xml.transform.TransformerException
  {

    NodeSetDTM ancestors = new NodeSetDTM(xctxt.getDTMManager());
    XPath countMatchPattern = getCountMatchPattern(xctxt, node);
    DTM dtm = xctxt.getDTM(node);

    while (DTM.NULL != node)
    {
      if ((null != m_fromMatchPattern)
              && (m_fromMatchPattern.getMatchScore(xctxt, node)
                  != XPath.MATCH_SCORE_NONE))
      {

        
        
        
        
        
        
        if (!stopAtFirstFound)
          break;
      }

      if (null == countMatchPattern)
        System.out.println(
          ""Programmers error! countMatchPattern should never be null!"");

      if (countMatchPattern.getMatchScore(xctxt, node)
              != XPath.MATCH_SCORE_NONE)
      {
        ancestors.addElement(node);

        if (stopAtFirstFound)
          break;
      }

      node = dtm.getParent(node);
    }

    return ancestors;
  }  

  
  Locale getLocale(TransformerImpl transformer, int contextNode)
          throws TransformerException
  {

    Locale locale = null;

    if (null != m_lang_avt)
    {
      XPathContext xctxt = transformer.getXPathContext();
      String langValue = m_lang_avt.evaluate(xctxt, contextNode, this);

      if (null != langValue)
      {

        
        
        
        locale = new Locale(langValue.toUpperCase(), """");

        
        if (null == locale)
        {
          transformer.getMsgMgr().warn(this, null, xctxt.getDTM(contextNode).getNode(contextNode),
                                       XSLTErrorResources.WG_LOCALE_NOT_FOUND,
                                       new Object[]{ langValue });  

          locale = Locale.getDefault();
        }
      }
    }
    else
    {
      locale = Locale.getDefault();
    }

    return locale;
  }

  
  private DecimalFormat getNumberFormatter(
          TransformerImpl transformer, int contextNode) throws TransformerException
  {
    
    
    
    Locale locale = (Locale)getLocale(transformer, contextNode).clone();

    
    DecimalFormat formatter = null;

    
    
    
    

    String digitGroupSepValue =
      (null != m_groupingSeparator_avt)
      ? m_groupingSeparator_avt.evaluate(
      transformer.getXPathContext(), contextNode, this) : null;
      
      
    
    
    if ((digitGroupSepValue != null) && (!m_groupingSeparator_avt.isSimple()) &&
        (digitGroupSepValue.length() != 1))
    {
            transformer.getMsgMgr().warn(
               this, XSLTErrorResources.WG_ILLEGAL_ATTRIBUTE_VALUE,
               new Object[]{ Constants.ATTRNAME_NAME, m_groupingSeparator_avt.getName()});   
    }                  
      
      
    String nDigitsPerGroupValue =
      (null != m_groupingSize_avt)
      ? m_groupingSize_avt.evaluate(
      transformer.getXPathContext(), contextNode, this) : null;

    
    if ((null != digitGroupSepValue) && (null != nDigitsPerGroupValue) &&
        
        (digitGroupSepValue.length() > 0))
    {
      try
      {
        formatter = (DecimalFormat) NumberFormat.getNumberInstance(locale);
        formatter.setGroupingSize(
          Integer.valueOf(nDigitsPerGroupValue).intValue());
        
        DecimalFormatSymbols symbols = formatter.getDecimalFormatSymbols();
        symbols.setGroupingSeparator(digitGroupSepValue.charAt(0));
        formatter.setDecimalFormatSymbols(symbols);
        formatter.setGroupingUsed(true);
      }
      catch (NumberFormatException ex)
      {
        formatter.setGroupingUsed(false);
      }
    }

    return formatter;
  }

  
  String formatNumberList(
          TransformerImpl transformer, long[] list, int contextNode)
            throws TransformerException
  {

    String numStr;
    FastStringBuffer formattedNumber = StringBufferPool.get();

    try
    {
      int nNumbers = list.length, numberWidth = 1;
      char numberType = '1';
      String formatToken, lastSepString = null, formatTokenString = null;

      
      
      
      
      
      
      
      String lastSep = ""."";
      boolean isFirstToken = true;  
      String formatValue =
        (null != m_format_avt)
        ? m_format_avt.evaluate(
        transformer.getXPathContext(), contextNode, this) : null;

      if (null == formatValue)
        formatValue = ""1"";

      NumberFormatStringTokenizer formatTokenizer =
        new NumberFormatStringTokenizer(formatValue);

      
      
      for (int i = 0; i < nNumbers; i++)
      {

        
        if (formatTokenizer.hasMoreTokens())
        {
          formatToken = formatTokenizer.nextToken();

          
          
          if (Character.isLetterOrDigit(
                  formatToken.charAt(formatToken.length() - 1)))
          {
            numberWidth = formatToken.length();
            numberType = formatToken.charAt(numberWidth - 1);
          }

          
          
          else if (formatTokenizer.isLetterOrDigitAhead())
          {
            formatTokenString = formatToken;

            
            
            
            while (formatTokenizer.nextIsSep())
            {
              formatToken = formatTokenizer.nextToken();
              formatTokenString += formatToken;
            }

            
            
            
            
            if (!isFirstToken)
              lastSep = formatTokenString;

            
            formatToken = formatTokenizer.nextToken();
            numberWidth = formatToken.length();
            numberType = formatToken.charAt(numberWidth - 1);
          }
          else  
          {

            
            
            lastSepString = formatToken;

            
            while (formatTokenizer.hasMoreTokens())
            {
              formatToken = formatTokenizer.nextToken();
              lastSepString += formatToken;
            }
          }  
        }  

        
        
        
        
        if (null != formatTokenString && isFirstToken)
        {
          formattedNumber.append(formatTokenString);
        }
        else if (null != lastSep &&!isFirstToken)
          formattedNumber.append(lastSep);

        getFormattedNumber(transformer, contextNode, numberType, numberWidth,
                           list[i], formattedNumber);

        isFirstToken = false;  
      }  

      
      
      while (formatTokenizer.isLetterOrDigitAhead())
      {
        formatTokenizer.nextToken();
      }

      if (lastSepString != null)
        formattedNumber.append(lastSepString);

      while (formatTokenizer.hasMoreTokens())
      {
        formatToken = formatTokenizer.nextToken();

        formattedNumber.append(formatToken);
      }

      numStr = formattedNumber.toString();
    }
    finally
    {
      StringBufferPool.free(formattedNumber);
    }

    return numStr;
  }  

  

  
  private void getFormattedNumber(
          TransformerImpl transformer, int contextNode, 
          char numberType, int numberWidth, long listElement, 
          FastStringBuffer formattedNumber)
            throws javax.xml.transform.TransformerException
  {


    String letterVal =
      (m_lettervalue_avt != null)
      ? m_lettervalue_avt.evaluate(
      transformer.getXPathContext(), contextNode, this) : null;

    switch (numberType)
    {
    case 'A' :
      if (m_alphaCountTable == null)
      {
        XResourceBundle thisBundle;

        thisBundle =
          (XResourceBundle) XResourceBundle.loadResourceBundle(
            org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, getLocale(transformer, contextNode));

        char[] alphabet;

        alphabet = (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET);
        m_alphaCountTable = alphabet;
      }

      int2alphaCount(listElement, m_alphaCountTable, formattedNumber);
      break;
    case 'a' :
      if (m_alphaCountTable == null)
      {
        XResourceBundle thisBundle;

        thisBundle =
          (XResourceBundle) XResourceBundle.loadResourceBundle(
            org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, getLocale(transformer, contextNode));

        char[] alphabet;

        alphabet = (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET);
        m_alphaCountTable = alphabet;
      }

      FastStringBuffer stringBuf = StringBufferPool.get();

      try
      {
        int2alphaCount(listElement, m_alphaCountTable, stringBuf);
        formattedNumber.append(
          stringBuf.toString().toLowerCase(
            getLocale(transformer, contextNode)));
      }
      finally
      {
        StringBufferPool.free(stringBuf);
      }
      break;
    case 'I' :
      formattedNumber.append(long2roman(listElement, true));
      break;
    case 'i' :
      formattedNumber.append(
        long2roman(listElement, true).toLowerCase(
          getLocale(transformer, contextNode)));
      break;
    case 0x3042 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ja"", ""JP"", ""HA""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        formattedNumber.append(
          int2singlealphaCount(
            listElement,
            (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET)));

      break;
    }
    case 0x3044 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ja"", ""JP"", ""HI""));

      if ((letterVal != null)
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        formattedNumber.append(
          int2singlealphaCount(
            listElement,
            (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET)));

      break;
    }
    case 0x30A2 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ja"", ""JP"", ""A""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        formattedNumber.append(
          int2singlealphaCount(
            listElement,
            (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET)));

      break;
    }
    case 0x30A4 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ja"", ""JP"", ""I""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        formattedNumber.append(
          int2singlealphaCount(
            listElement,
            (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET)));

      break;
    }
    case 0x4E00 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""zh"", ""CN""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
      {
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      }
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x58F9 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""zh"", ""TW""));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x0E51 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""th"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x05D0 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""he"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x10D0 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""ka"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x03B1 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""el"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    case 0x0430 :
    {
      XResourceBundle thisBundle;

      thisBundle = (XResourceBundle) XResourceBundle.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.LANG_BUNDLE_NAME, new Locale(""cy"", """"));

      if (letterVal != null
              && letterVal.equals(Constants.ATTRVAL_TRADITIONAL))
        formattedNumber.append(tradAlphaCount(listElement, thisBundle));
      else  
        int2alphaCount(listElement,
                       (char[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_ALPHABET),
                       formattedNumber);

      break;
    }
    default :  
      DecimalFormat formatter = getNumberFormatter(transformer, contextNode);
      String padString = formatter == null ? String.valueOf(0) : formatter.format(0);    
      String numString = formatter == null ? String.valueOf(listElement) : formatter.format(listElement);
      int nPadding = numberWidth - numString.length();

      for (int k = 0; k < nPadding; k++)
      {
        formattedNumber.append(padString);
      }

      formattedNumber.append(numString);
    }
  }
  
  
   String getZeroString()
   {
     return """"+0;
   }

  
  protected String int2singlealphaCount(long val, char[] table)
  {

    int radix = table.length;

    
    if (val > radix)
    {
      return getZeroString();
    }
    else
      return (new Character(table[(int)val - 1])).toString();  
  }

  
  protected void int2alphaCount(long val, char[] aTable,
                                FastStringBuffer stringBuf)
  {

    int radix = aTable.length;
    char[] table = new char[aTable.length];

    
    int i;

    for (i = 0; i < aTable.length - 1; i++)
    {
      table[i + 1] = aTable[i];
    }

    table[0] = aTable[i];

    
    
    
    char buf[] = new char[100];

    
    
    
    
    int charPos;

    charPos = buf.length - 1;  

    
    int lookupIndex = 1;  

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    long correction = 0;

    
    do
    {

      
      
      
      correction =
        ((lookupIndex == 0) || (correction != 0 && lookupIndex == radix - 1))
        ? (radix - 1) : 0;

      
      lookupIndex = (int)(val + correction) % radix;

      
      val = (val / radix);

      
      if (lookupIndex == 0 && val == 0)
        break;

      
      buf[charPos--] = table[lookupIndex];  
    }
    while (val > 0);

    stringBuf.append(buf, charPos + 1, (buf.length - charPos - 1));
  }

  
  protected String tradAlphaCount(long val, XResourceBundle thisBundle)
  {

    
    if (val > Long.MAX_VALUE)
    {
      this.error(XSLTErrorResources.ER_NUMBER_TOO_BIG);
      return XSLTErrorResources.ERROR_STRING;
    }
    char[] table = null;

    
    int lookupIndex = 1;  

    
    
    
    char buf[] = new char[100];

    
    
    
    
    int charPos;

    charPos = 0;  

    
    int[] groups = (int[]) thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_NUMBERGROUPS);

    
    String[] tables =
      (String[]) (thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_NUM_TABLES));

    
    
    String numbering = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.LANG_NUMBERING);

    
    if (numbering.equals(org.apache.xml.utils.res.XResourceBundle.LANG_MULT_ADD))
    {
      String mult_order = thisBundle.getString(org.apache.xml.utils.res.XResourceBundle.MULT_ORDER);
      long[] multiplier =
        (long[]) (thisBundle.getObject(org.apache.xml.utils.res.XResourceBundle.LANG_MULTIPLIER));
      char[] zeroChar = (char[]) thisBundle.getObject(""zero"");
      int i = 0;

      
      while (i < multiplier.length && val < multiplier[i])
      {
        i++;
      }

      do
      {
        if (i >= multiplier.length)
          break;  

        
        
        
        if (val < multiplier[i])
        {
          if (zeroChar.length == 0)
          {
            i++;
          }
          else
          {
            if (buf[charPos - 1] != zeroChar[0])
              buf[charPos++] = zeroChar[0];

            i++;
          }
        }
        else if (val >= multiplier[i])
        {
          long mult = val / multiplier[i];

          val = val % multiplier[i];  

          int k = 0;

          while (k < groups.length)
          {
            lookupIndex = 1;  

            if (mult / groups[k] <= 0)  
              k++;
            else
            {

              
              char[] THEletters = (char[]) thisBundle.getObject(tables[k]);

              table = new char[THEletters.length + 1];

              int j;

              for (j = 0; j < THEletters.length; j++)
              {
                table[j + 1] = THEletters[j];
              }

              table[0] = THEletters[j - 1];  

              
              lookupIndex = (int)mult / groups[k];

              
              if (lookupIndex == 0 && mult == 0)
                break;

              char multiplierChar = ((char[]) (thisBundle.getObject(
                org.apache.xml.utils.res.XResourceBundle.LANG_MULTIPLIER_CHAR)))[i];

              
              if (lookupIndex < table.length)
              {
                if (mult_order.equals(org.apache.xml.utils.res.XResourceBundle.MULT_PRECEDES))
                {
                  buf[charPos++] = multiplierChar;
                  buf[charPos++] = table[lookupIndex];
                }
                else
                {

                  
                  if (lookupIndex == 1 && i == multiplier.length - 1){}
                  else
                    buf[charPos++] = table[lookupIndex];

                  buf[charPos++] = multiplierChar;
                }

                break;  
              }
              else
                return XSLTErrorResources.ERROR_STRING;
            }  
          }  

          i++;
        }  
      }  
      while (i < multiplier.length);
    }

    
    int count = 0;
    String tableName;

    
    while (count < groups.length)
    {
      if (val / groups[count] <= 0)  
        count++;
      else
      {
        char[] theletters = (char[]) thisBundle.getObject(tables[count]);

        table = new char[theletters.length + 1];

        int j;

        
        for (j = 0; j < theletters.length; j++)
        {
          table[j + 1] = theletters[j];
        }

        table[0] = theletters[j - 1];  

        
        lookupIndex = (int)val / groups[count];

        
        val = val % groups[count];

        
        if (lookupIndex == 0 && val == 0)
          break;

        if (lookupIndex < table.length)
        {

          
          buf[charPos++] = table[lookupIndex];  
        }
        else
          return XSLTErrorResources.ERROR_STRING;

        count++;
      }
    }  

    
    return new String(buf, 0, charPos);
  }

  
  protected String long2roman(long val, boolean prefixesAreOK)
  {

    if (val <= 0)
    {
      return getZeroString();
    }

    String roman = """";
    int place = 0;

    if (val <= 3999L)
    {
      do
      {
        while (val >= m_romanConvertTable[place].m_postValue)
        {
          roman += m_romanConvertTable[place].m_postLetter;
          val -= m_romanConvertTable[place].m_postValue;
        }

        if (prefixesAreOK)
        {
          if (val >= m_romanConvertTable[place].m_preValue)
          {
            roman += m_romanConvertTable[place].m_preLetter;
            val -= m_romanConvertTable[place].m_preValue;
          }
        }

        place++;
      }
      while (val > 0);
    }
    else
    {
      roman = XSLTErrorResources.ERROR_STRING;
    }

    return roman;
  }  
  
  
  public void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  	{
	  	if(null != m_countMatchPattern)
	  		m_countMatchPattern.getExpression().callVisitors(m_countMatchPattern, visitor);
	  	if(null != m_fromMatchPattern)
	  		m_fromMatchPattern.getExpression().callVisitors(m_fromMatchPattern, visitor);
	  	if(null != m_valueExpr)
	  		m_valueExpr.getExpression().callVisitors(m_valueExpr, visitor);
	
	  	if(null != m_format_avt)
	  		m_format_avt.callVisitors(visitor);
	  	if(null != m_groupingSeparator_avt)
	  		m_groupingSeparator_avt.callVisitors(visitor);
	  	if(null != m_groupingSize_avt)
	  		m_groupingSize_avt.callVisitors(visitor);
	  	if(null != m_lang_avt)
	  		m_lang_avt.callVisitors(visitor);
	  	if(null != m_lettervalue_avt)
	  		m_lettervalue_avt.callVisitors(visitor);
  	}

    super.callChildVisitors(visitor, callAttrs);
  }


  
  class NumberFormatStringTokenizer
  {

    
    private int currentPosition;

    
    private int maxPosition;

    
    private String str;

    
    public NumberFormatStringTokenizer(String str)
    {
      this.str = str;
      maxPosition = str.length();
    }

    
    public void reset()
    {
      currentPosition = 0;
    }

    
    public String nextToken()
    {

      if (currentPosition >= maxPosition)
      {
        throw new NoSuchElementException();
      }

      int start = currentPosition;

      while ((currentPosition < maxPosition)
             && Character.isLetterOrDigit(str.charAt(currentPosition)))
      {
        currentPosition++;
      }

      if ((start == currentPosition)
              && (!Character.isLetterOrDigit(str.charAt(currentPosition))))
      {
        currentPosition++;
      }

      return str.substring(start, currentPosition);
    }

    
    public boolean isLetterOrDigitAhead()
    {

      int pos = currentPosition;

      while (pos < maxPosition)
      {
        if (Character.isLetterOrDigit(str.charAt(pos)))
          return true;

        pos++;
      }

      return false;
    }

    
    public boolean nextIsSep()
    {

      if (Character.isLetterOrDigit(str.charAt(currentPosition)))
        return false;
      else
        return true;
    }

    
    public boolean hasMoreTokens()
    {
      return (currentPosition >= maxPosition) ? false : true;
    }

    
    public int countTokens()
    {

      int count = 0;
      int currpos = currentPosition;

      while (currpos < maxPosition)
      {
        int start = currpos;

        while ((currpos < maxPosition)
               && Character.isLetterOrDigit(str.charAt(currpos)))
        {
          currpos++;
        }

        if ((start == currpos)
                && (Character.isLetterOrDigit(str.charAt(currpos)) == false))
        {
          currpos++;
        }

        count++;
      }

      return count;
    }
  }  



}
"
org.apache.xpath.compiler.OpCodes,1,1,0,0,2,0,0,0,1,2.0,68,0.015625,0,0.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xpath.compiler;


public class OpCodes
{

  
  public static final int ENDOP = -1;

  
  public static final int EMPTY = -2;

  
  public static final int ELEMWILDCARD = -3;

  
  public static final int OP_XPATH = 1;

  
  public static final int OP_OR = 2;

  
  public static final int OP_AND = 3;

  
  public static final int OP_NOTEQUALS = 4;

  
  public static final int OP_EQUALS = 5;

  
  public static final int OP_LTE = 6;

  
  public static final int OP_LT = 7;

  
  public static final int OP_GTE = 8;

  
  public static final int OP_GT = 9;

  
  public static final int OP_PLUS = 10;

  
  public static final int OP_MINUS = 11;

  
  public static final int OP_MULT = 12;

  
  public static final int OP_DIV = 13;

  
  public static final int OP_MOD = 14;

  
  public static final int OP_QUO = 15;

  
  public static final int OP_NEG = 16;

  
  public static final int OP_STRING = 17;

  
  public static final int OP_BOOL = 18;

  
  public static final int OP_NUMBER = 19;

  
  public static final int OP_UNION = 20;

  
  public static final int OP_LITERAL = 21;

  
  static final int FIRST_NODESET_OP = 22;

  
  public static final int OP_VARIABLE = 22;

  
  public static final int OP_GROUP = 23;

  
  public static final int OP_EXTFUNCTION = 24;

  
  public static final int OP_FUNCTION = 25;

  
  static final int LAST_NODESET_OP = 25;

  
  public static final int OP_ARGUMENT = 26;

  
  public static final int OP_NUMBERLIT = 27;

  
  public static final int OP_LOCATIONPATH = 28;

  
  
  

  
  public static final int OP_PREDICATE = 29;

  
  public static final int OP_MATCHPATTERN = 30;

  
  public static final int OP_LOCATIONPATHPATTERN = 31;

  
  public static final int NODETYPE_COMMENT = 1030;

  
  public static final int NODETYPE_TEXT = 1031;

  
  public static final int NODETYPE_PI = 1032;

  
  public static final int NODETYPE_NODE = 1033;

  
  public static final int NODENAME = 34;

  
  public static final int NODETYPE_ROOT = 35;

  
  public static final int NODETYPE_ANYELEMENT = 36;

  
  public static final int NODETYPE_FUNCTEST = 1034;

  
  public static final int AXES_START_TYPES = 37;

  
  public static final int FROM_ANCESTORS = 37;

  
  public static final int FROM_ANCESTORS_OR_SELF = 38;

  
  public static final int FROM_ATTRIBUTES = 39;

  
  public static final int FROM_CHILDREN = 40;

  
  public static final int FROM_DESCENDANTS = 41;

  
  public static final int FROM_DESCENDANTS_OR_SELF = 42;

  
  public static final int FROM_FOLLOWING = 43;

  
  public static final int FROM_FOLLOWING_SIBLINGS = 44;

  
  public static final int FROM_PARENT = 45;

  
  public static final int FROM_PRECEDING = 46;

  
  public static final int FROM_PRECEDING_SIBLINGS = 47;

  
  public static final int FROM_SELF = 48;

  
  public static final int FROM_NAMESPACE = 49;

  
  public static final int FROM_ROOT = 50;

  
  public static final int MATCH_ATTRIBUTE = 51;

  
  public static final int MATCH_ANY_ANCESTOR = 52;

  
  public static final int MATCH_IMMEDIATE_ANCESTOR = 53;

  
  public static final int AXES_END_TYPES = 53;

  
  private static final int NEXT_FREE_ID = 99;
}
"
org.apache.xalan.xsltc.compiler.ApplyTemplates,6,3,0,29,58,0,2,28,5,0.65,361,1.0,3,0.918032787,0.305555556,1,5,58.5,13,3.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;

import org.apache.xalan.xsltc.compiler.util.*;

final class ApplyTemplates extends Instruction {
    private Expression _select;
    private Type       _type = null;
    private QName      _modeName;
    private String     _functionName;
	
    public void display(int indent) {
	indent(indent);
	Util.println(""ApplyTemplates"");
	indent(indent + IndentIncrement);
	Util.println(""select "" + _select.toString());
	if (_modeName != null) {
	    indent(indent + IndentIncrement);
	    Util.println(""mode "" + _modeName);
	}
    }

    public boolean hasWithParams() {
	return hasContents();
    }

    public void parseContents(Parser parser) {
	final String select = getAttribute(""select"");
	final String mode   = getAttribute(""mode"");
	
	if (select.length() > 0) {
	    _select = parser.parseExpression(this, ""select"", null);
	}
	
	if (mode.length() > 0) {
	    _modeName = parser.getQNameIgnoreDefaultNs(mode);
	}
	
	
	_functionName =
	    parser.getTopLevelStylesheet().getMode(_modeName).functionName();
	parseChildren(parser);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_select != null) {
	    _type = _select.typeCheck(stable);
	    if (_type instanceof NodeType || _type instanceof ReferenceType) {
		_select = new CastExpr(_select, Type.NodeSet);
		_type = Type.NodeSet;
	    }
	    if (_type instanceof NodeSetType||_type instanceof ResultTreeType) {
		typeCheckContents(stable); 
		return Type.Void;
	    }
	    throw new TypeCheckError(this);
	}
	else {
	    typeCheckContents(stable);		
	    return Type.Void;
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	boolean setStartNodeCalled = false;
	final Stylesheet stylesheet = classGen.getStylesheet();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int current = methodGen.getLocalIndex(""current"");

	
	final Vector sortObjects = new Vector();
	final Enumeration children = elements();
	while (children.hasMoreElements()) {
	    final Object child = children.nextElement();
	    if (child instanceof Sort) {
		sortObjects.addElement(child);
	    }
	}

	
	if (stylesheet.hasLocalParams() || hasContents()) {
	    il.append(classGen.loadTranslet());
	    final int pushFrame = cpg.addMethodref(TRANSLET_CLASS,
						   PUSH_PARAM_FRAME,
						   PUSH_PARAM_FRAME_SIG);
	    il.append(new INVOKEVIRTUAL(pushFrame));
	    
	    translateContents(classGen, methodGen);
	}


	il.append(classGen.loadTranslet());

	
	if ((_type != null) && (_type instanceof ResultTreeType)) {
	    
	    if (sortObjects.size() > 0) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.RESULT_TREE_SORT_ERR,this);
		getParser().reportError(WARNING, err);
	    }
	    
	    _select.translate(classGen, methodGen);	
	    
	    _type.translateTo(classGen, methodGen, Type.NodeSet);
	}
	else {
	    il.append(methodGen.loadDOM());

	    
	    if (sortObjects.size() > 0) {
		Sort.translateSortIterator(classGen, methodGen,
					   _select, sortObjects);
		int setStartNode = cpg.addInterfaceMethodref(NODE_ITERATOR,
							     SET_START_NODE,
							     ""(I)""+
							     NODE_ITERATOR_SIG);
		il.append(methodGen.loadCurrentNode());
		il.append(new INVOKEINTERFACE(setStartNode,2));
		setStartNodeCalled = true;	
	    }
	    else {
		if (_select == null)
		    Mode.compileGetChildren(classGen, methodGen, current);
		else
		    _select.translate(classGen, methodGen);
	    }
	}

	if (_select != null && !setStartNodeCalled) {
	    _select.startResetIterator(classGen, methodGen);
	}

	
	final String className = classGen.getStylesheet().getClassName();
	il.append(methodGen.loadHandler());
	final String applyTemplatesSig = classGen.getApplyTemplatesSig();
	final int applyTemplates = cpg.addMethodref(className,
						    _functionName,
						    applyTemplatesSig);
	il.append(new INVOKEVIRTUAL(applyTemplates));
	
	
	if (stylesheet.hasLocalParams() || hasContents()) {
	    il.append(classGen.loadTranslet());
	    final int popFrame = cpg.addMethodref(TRANSLET_CLASS,
						  POP_PARAM_FRAME,
						  POP_PARAM_FRAME_SIG);
	    il.append(new INVOKEVIRTUAL(popFrame));
	}
    }
}
"
org.apache.xml.dtm.ref.DTMSafeStringPool,5,2,0,2,15,10,1,1,5,2.0,305,0.0,0,0.5,0.35,2,5,60.0,8,2.2,0,"

package org.apache.xml.dtm.ref;
import java.util.Vector;


public class DTMSafeStringPool
extends DTMStringPool
{
  public synchronized void removeAllElements()
    {
      super.removeAllElements();
    }

   
  public synchronized String indexToString(int i)
    throws java.lang.ArrayIndexOutOfBoundsException
    {
      return super.indexToString(i);
    }

   
  public synchronized int stringToIndex(String s)
    {
      return super.stringToIndex(s);
    }

  
  public static void main(String[] args)
  {
    String[] word={
      ""Zero"",""One"",""Two"",""Three"",""Four"",""Five"",
      ""Six"",""Seven"",""Eight"",""Nine"",""Ten"",
      ""Eleven"",""Twelve"",""Thirteen"",""Fourteen"",""Fifteen"",
      ""Sixteen"",""Seventeen"",""Eighteen"",""Nineteen"",""Twenty"",
      ""Twenty-One"",""Twenty-Two"",""Twenty-Three"",""Twenty-Four"",
      ""Twenty-Five"",""Twenty-Six"",""Twenty-Seven"",""Twenty-Eight"",
      ""Twenty-Nine"",""Thirty"",""Thirty-One"",""Thirty-Two"",
      ""Thirty-Three"",""Thirty-Four"",""Thirty-Five"",""Thirty-Six"",
      ""Thirty-Seven"",""Thirty-Eight"",""Thirty-Nine""};

    DTMStringPool pool=new DTMSafeStringPool();

    System.out.println(""If no complaints are printed below, we passed initial test."");

    for(int pass=0;pass<=1;++pass)
      {
        int i;

        for(i=0;i<word.length;++i)
          {
            int j=pool.stringToIndex(word[i]);
            if(j!=i)
              System.out.println(""	Mismatch populating pool: assigned ""+
                                 j+"" for create ""+i);
          }

        for(i=0;i<word.length;++i)
          {
            int j=pool.stringToIndex(word[i]);
            if(j!=i)
              System.out.println(""	Mismatch in stringToIndex: returned ""+
                                 j+"" for lookup ""+i);
          }

        for(i=0;i<word.length;++i)
          {
            String w=pool.indexToString(i);
            if(!word[i].equals(w))
              System.out.println(""	Mismatch in indexToString: returned""+
                                 w+"" for lookup ""+i);
          }
        
        pool.removeAllElements();
        
        System.out.println(""
Pass ""+pass+"" complete
"");
      } 
  }
} 
"
org.apache.xalan.templates.ElemIf,8,3,0,14,27,0,0,14,7,0.285714286,117,1.0,1,0.965517241,0.270833333,2,5,13.5,2,1.0,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.objects.XObject;
import org.apache.xalan.trace.SelectionEvent;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;


public class ElemIf extends ElemTemplateElement
{

  
  private XPath m_test = null;

  
  public void setTest(XPath v)
  {
    m_test = v;
  }

  
  public XPath getTest()
  {
    return m_test;
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {

    super.compose(sroot);

    java.util.Vector vnames = sroot.getComposeState().getVariableNames();

    if (null != m_test)
      m_test.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_IF;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_IF_STRING;
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    XPathContext xctxt = transformer.getXPathContext();
    int sourceNode = xctxt.getCurrentNode();

    if (TransformerImpl.S_DEBUG)
    {
      XObject test = m_test.execute(xctxt, sourceNode, this);

      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                ""test"", m_test, test);

      if (test.bool())
      {
      	
      	
      	
      	
        
        

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(this);

        transformer.executeChildTemplates(this, true);
        
        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEndEvent(this);
      }

      
      
      
      
    }
    else if (m_test.bool(xctxt, sourceNode, this))
    {
      transformer.executeChildTemplates(this, true);
    }
    
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  		m_test.getExpression().callVisitors(m_test, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xalan.xsltc.dom.DOMAdapter,42,1,0,10,85,0,4,6,42,0.783972125,437,1.0,2,0.0,0.235449735,0,0,9.238095238,6,1.1905,0,"

package org.apache.xalan.xsltc.dom;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.StripFilter;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.TransletOutputHandler;
import org.apache.xalan.xsltc.TransletException;

public final class DOMAdapter implements DOM {

    private final DOMImpl _domImpl;
    private short[] _mapping;
    private short[] _reverse;
    private short[] _NSmapping;
    private short[] _NSreverse;

    private StripFilter _filter = null;

    private int _multiDOMMask;
    
    public DOMAdapter(DOMImpl dom,
		      String[] namesArray,
		      String[] namespaceArray) 
    {
	_domImpl = dom;
	_mapping = dom.getMapping(namesArray);
	_reverse = dom.getReverseMapping(namesArray);
	_NSmapping = dom.getNamespaceMapping(namespaceArray);
	_NSreverse = dom.getReverseNamespaceMapping(namespaceArray);
    }

    public void setupMapping(String[] names, String[] namespaces) {
	_mapping = _domImpl.getMapping(names);
	_reverse = _domImpl.getReverseMapping(names);
	_NSmapping = _domImpl.getNamespaceMapping(namespaces);
	_NSreverse = _domImpl.getReverseNamespaceMapping(namespaces);
    }

    
    public NodeIterator getIterator() {
	return _domImpl.getIterator();
    }
    
    public String getStringValue() {
	return _domImpl.getStringValue();
    }

    public String getTreeString() {
	return _domImpl.getTreeString();
    }
    
    public int getMultiDOMMask() {
	return _multiDOMMask;
    }

    public void setMultiDOMMask(int mask) {
	_multiDOMMask = mask;
    }

    public NodeIterator getChildren(final int node) {
	NodeIterator iterator = _domImpl.getChildren(node);
	if (_filter == null) {
	    return iterator.setStartNode(node);
	}
	else {
	    iterator = _domImpl.strippingIterator(iterator, _mapping, _filter);
	    return iterator.setStartNode(node);
	}
    }

    public void setFilter(StripFilter filter) {
	_filter = filter;
    }
    
    public NodeIterator getTypedChildren(final int type) {
	NodeIterator iterator = _domImpl.getTypedChildren(_reverse[type]);
	if (_reverse[type] == DOM.TEXT && _filter != null) {
	    return _domImpl.strippingIterator(iterator,_mapping,_filter);
	}
	return iterator;
    }

    public NodeIterator getNamespaceAxisIterator(final int axis, final int ns) {
	return _domImpl.getNamespaceAxisIterator(axis,_NSreverse[ns]);
    }

    public NodeIterator getAxisIterator(final int axis) {
	NodeIterator iterator = _domImpl.getAxisIterator(axis);
	if (_filter != null) {
	    return _domImpl.strippingIterator(iterator, _mapping, _filter);
	}
	return iterator;
    }
    
    public NodeIterator getTypedAxisIterator(final int axis, final int type) {
	NodeIterator iterator;

	if (axis == Axis.NAMESPACE) {
	    iterator = (type == NO_TYPE || type > _NSreverse.length) ?
		_domImpl.getAxisIterator(axis) :
		_domImpl.getTypedAxisIterator(axis,_NSreverse[type]);
	}
	else {
	    iterator = _domImpl.getTypedAxisIterator(axis, _reverse[type]);
	}
	
	if (_reverse[type] == DOM.TEXT && _filter != null) {
	    iterator = _domImpl.strippingIterator(iterator, _mapping, _filter);
	}
	return iterator;
    }

    public NodeIterator getNthDescendant(int type, int n, boolean includeself) {
	return _domImpl.getNthDescendant(_reverse[type], n, includeself);
    }

    public NodeIterator getNodeValueIterator(NodeIterator iterator, int type,
					     String value, boolean op) 
    {
	return _domImpl.getNodeValueIterator(iterator, type, value, op);
    }

    public NodeIterator orderNodes(NodeIterator source, int node) {
	return _domImpl.orderNodes(source, node);
    }
        
    public int getType(final int node) {
	return _mapping[_domImpl.getType(node)];
    }

    public int getNamespaceType(final int node) {
	return _NSmapping[_domImpl.getNamespaceType(node)];
    }
    
    public int getParent(final int node) {
	return _domImpl.getParent(node);
    }

    public int getTypedPosition(int type, int node) {
	return _domImpl.getTypedPosition(_reverse[type], node);
    }

    public int getTypedLast(int type, int node) {
	return _domImpl.getTypedLast(_reverse[type], node);
    }

    public int getAttributeNode(final int type, final int element) {
	return _domImpl.getAttributeNode(_reverse[type], element);
    }
    
    public String getNodeName(final int node) {
	return _domImpl.getNodeName(node);
    }

    public String getNamespaceName(final int node) {
	return _domImpl.getNamespaceName(node);
    }
    
    public String getNodeValue(final int node) {
	return _domImpl.getNodeValue(node);
    }
    
    public void copy(final int node, TransletOutputHandler handler)
	throws TransletException {
	    _domImpl.copy(node, handler);
    }
    
    public void copy(NodeIterator nodes, TransletOutputHandler handler)
	throws TransletException {
	    _domImpl.copy(nodes, handler);
    }

    public String shallowCopy(final int node, TransletOutputHandler handler)
	throws TransletException {
	    return _domImpl.shallowCopy(node, handler);
    }
    
    public boolean lessThan(final int node1, final int node2) {
	return _domImpl.lessThan(node1, node2);
    }
    
    public void characters(final int textNode, TransletOutputHandler handler)
	throws TransletException {
	_domImpl.characters(textNode, handler);
    }

    public Node makeNode(int index) {
	return _domImpl.makeNode(index);
    }

    public Node makeNode(NodeIterator iter) {
	return _domImpl.makeNode(iter);
    }

    public NodeList makeNodeList(int index) {
	return _domImpl.makeNodeList(index);
    }

    public NodeList makeNodeList(NodeIterator iter) {
	return _domImpl.makeNodeList(iter);
    }

    public String getLanguage(int node) {
	return _domImpl.getLanguage(node);
    }

    public int getSize() {
	return _domImpl.getSize();
    }

    public void setDocumentURI(String uri) {
	_domImpl.setDocumentURI(uri);
    }

    public String getDocumentURI() {
	return(_domImpl.getDocumentURI());
    }

    public String getDocumentURI(int node) {
	return(_domImpl.getDocumentURI());
    }

    public boolean isElement(final int node) {
	return(_domImpl.isElement(node));
    }

    public boolean isAttribute(final int node) {
	return(_domImpl.isAttribute(node));
    }

    public String lookupNamespace(int node, String prefix) 
	throws TransletException 
    {
	return _domImpl.lookupNamespace(node, prefix);
    }
}
"
org.apache.xml.utils.NameSpace,1,1,0,1,2,0,1,0,1,2.0,16,0.0,1,0.0,1.0,0,0,12.0,0,0.0,0,"
package org.apache.xml.utils;

import java.io.Serializable;


public class NameSpace implements Serializable
{

  
  public NameSpace m_next = null;

  
  public String m_prefix;

  
  public String m_uri;  

  
  public NameSpace(String prefix, String uri)
  {
    m_prefix = prefix;
    m_uri = uri;
  }
}
"
org.apache.xpath.operations.Bool,3,3,0,6,7,3,1,5,3,2.0,24,0.0,0,0.952380952,0.555555556,1,1,7.0,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.Expression;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.XPathContext;


public class Bool extends UnaryOperation
{

  
  public XObject operate(XObject right) throws javax.xml.transform.TransformerException
  {

    if (XObject.CLASS_BOOLEAN == right.getType())
      return right;
    else
      return right.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return m_right.bool(xctxt);
  }


}
"
org.apache.xalan.xsltc.compiler.ConcatCall,3,4,0,22,22,3,0,22,3,2.0,131,0.0,0,0.979591837,0.444444444,3,14,42.66666667,5,2.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class ConcatCall extends FunctionCall {
    public ConcatCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	for (int i = 0; i < argumentCount(); i++) {
	    final Expression exp = argument(i);
	    if (!exp.typeCheck(stable).identicalTo(Type.String)) {
		setArgument(i, new CastExpr(exp, Type.String));
	    }
	}
	return _type = Type.String;
    }
	
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int nArgs = argumentCount();
	
	switch (nArgs) {
	case 0:
	    il.append(new PUSH(cpg, EMPTYSTRING));
	    break;
	    
	case 1:
	    argument().translate(classGen, methodGen);
	    break;

	default:
	    final int initBuffer = cpg.addMethodref(STRING_BUFFER_CLASS,
						    ""<init>"", ""()V"");
	    final Instruction append =
		new INVOKEVIRTUAL(cpg.addMethodref(STRING_BUFFER_CLASS,
						   ""append"",
						   ""(""+STRING_SIG+"")""
						   +STRING_BUFFER_SIG));
	    
	    final int toString = cpg.addMethodref(STRING_BUFFER_CLASS,
						  ""toString"",
						  ""()""+STRING_SIG);
	    
	    il.append(new NEW(cpg.addClass(STRING_BUFFER_CLASS)));
	    il.append(DUP);
	    il.append(new INVOKESPECIAL(initBuffer));
	    for (int i = 0; i < nArgs; i++) {
		argument(i).translate(classGen, methodGen);
		il.append(append);
	    }
	    il.append(new INVOKEVIRTUAL(toString));
	}
    }
}
"
org.apache.xalan.lib.Redirect,7,1,0,11,45,1,0,11,4,0.75,499,0.5,0,0.0,0.571428571,0,0,69.71428571,7,1.7143,0,"
package org.apache.xalan.lib;

import java.util.*;
import java.io.*;
import java.net.URL;

import org.xml.sax.ContentHandler;

import org.apache.xalan.extensions.XSLProcessorContext;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.ElemExtensionCall;
import org.apache.xalan.templates.OutputProperties;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.XPath;

import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.Result;
import javax.xml.transform.TransformerException;

import org.w3c.dom.*;


public class Redirect
{
  
  protected Hashtable m_formatterListeners = new Hashtable ();

  
  protected Hashtable m_outputStreams = new Hashtable ();

  
  public static final boolean DEFAULT_APPEND_OPEN = false;

  
  public static final boolean DEFAULT_APPEND_WRITE = false;

  
  public void open(XSLProcessorContext context, ElemExtensionCall elem)
    throws java.net.MalformedURLException,
           java.io.FileNotFoundException,
           java.io.IOException,
           javax.xml.transform.TransformerException
  {
    String fileName = getFilename(context, elem);
    Object flistener = m_formatterListeners.get(fileName);
    if(null == flistener)
    {
      String mkdirsExpr 
        = elem.getAttribute (""mkdirs"", context.getContextNode(), 
                                                  context.getTransformer());
      boolean mkdirs = (mkdirsExpr != null)
                       ? (mkdirsExpr.equals(""true"") || mkdirsExpr.equals(""yes"")) : true;

      
      String appendExpr = elem.getAttribute(""append"", context.getContextNode(), context.getTransformer());
	  boolean append = (appendExpr != null)
                       ? (appendExpr.equals(""true"") || appendExpr.equals(""yes"")) : DEFAULT_APPEND_OPEN;

      Object ignored = makeFormatterListener(context, elem, fileName, true, mkdirs, append);
    }
  }
  
  
  public void write(XSLProcessorContext context, ElemExtensionCall elem)
    throws java.net.MalformedURLException,
           java.io.FileNotFoundException,
           java.io.IOException,
           javax.xml.transform.TransformerException
  {
    String fileName = getFilename(context, elem);
    Object flObject = m_formatterListeners.get(fileName);
    ContentHandler formatter;
    boolean inTable = false;
    if(null == flObject)
    {
      String mkdirsExpr 
        = ((ElemExtensionCall)elem).getAttribute (""mkdirs"", 
                                                  context.getContextNode(), 
                                                  context.getTransformer());
      boolean mkdirs = (mkdirsExpr != null)
                       ? (mkdirsExpr.equals(""true"") || mkdirsExpr.equals(""yes"")) : true;

      
      String appendExpr = elem.getAttribute(""append"", context.getContextNode(), context.getTransformer());
	  boolean append = (appendExpr != null)
                       ? (appendExpr.equals(""true"") || appendExpr.equals(""yes"")) : DEFAULT_APPEND_WRITE;

      formatter = makeFormatterListener(context, elem, fileName, true, mkdirs, append);
    }
    else
    {
      inTable = true;
      formatter = (ContentHandler)flObject;
    }
    
    TransformerImpl transf = context.getTransformer();
    
    transf.executeChildTemplates(elem,
                                 context.getContextNode(),
                                 context.getMode(), formatter);
    
    if(!inTable)
    {
      OutputStream ostream = (OutputStream)m_outputStreams.get(fileName);
      if(null != ostream)
      {
        try
        {
          formatter.endDocument();
        }
        catch(org.xml.sax.SAXException se)
        {
          throw new TransformerException(se);
        }
        ostream.close();
        m_outputStreams.remove(fileName);
        m_formatterListeners.remove(fileName);
      }
    }
  }


  
  public void close(XSLProcessorContext context, ElemExtensionCall elem)
    throws java.net.MalformedURLException,
    java.io.FileNotFoundException,
    java.io.IOException,
    javax.xml.transform.TransformerException
  {
    String fileName = getFilename(context, elem);
    Object formatterObj = m_formatterListeners.get(fileName);
    if(null != formatterObj)
    {
      ContentHandler fl = (ContentHandler)formatterObj;
      try
      {
        fl.endDocument();
      }
      catch(org.xml.sax.SAXException se)
      {
        throw new TransformerException(se);
      }
      OutputStream ostream = (OutputStream)m_outputStreams.get(fileName);
      if(null != ostream)
      {
        ostream.close();
        m_outputStreams.remove(fileName);
      }
      m_formatterListeners.remove(fileName);
    }
  }

  
  private String getFilename(XSLProcessorContext context, ElemExtensionCall elem)
    throws java.net.MalformedURLException,
    java.io.FileNotFoundException,
    java.io.IOException,
    javax.xml.transform.TransformerException
  {
    String fileName;
    String fileNameExpr 
      = ((ElemExtensionCall)elem).getAttribute (""select"", 
                                                context.getContextNode(), 
                                                context.getTransformer());
    if(null != fileNameExpr)
    {
      org.apache.xpath.XPathContext xctxt 
        = context.getTransformer().getXPathContext();
      XPath myxpath = new XPath(fileNameExpr, elem, xctxt.getNamespaceContext(), XPath.SELECT);
      XObject xobj = myxpath.execute(xctxt, context.getContextNode(), elem);
      fileName = xobj.str();
      if((null == fileName) || (fileName.length() == 0))
      {
        fileName = elem.getAttribute (""file"", 
                                      context.getContextNode(), 
                                      context.getTransformer());
      }
    }
    else
    {
      fileName = elem.getAttribute (""file"", context.getContextNode(), 
                                                               context.getTransformer());
    }
    if(null == fileName)
    {
      context.getTransformer().getMsgMgr().error(elem, elem, 
                                     context.getContextNode(), 
                                     XSLTErrorResources.ER_REDIRECT_COULDNT_GET_FILENAME);
                              
    }
    return fileName;
  }
  
  
  
  
  private String urlToFileName(String base)
  {
    if(null != base)
    {
      if(base.startsWith(""file:
      {
        base = base.substring(7);
      }
      else if(base.startsWith(""file:
      {
        base = base.substring(6);
      }
      else if(base.startsWith(""file:
      {
        base = base.substring(5); 
      }
      else if(base.startsWith(""file:/""))
      {
        base = base.substring(5);
      }
      else if(base.startsWith(""file:""))
      {
        base = base.substring(4);
      }
    }
    return base;
  }

  
  private ContentHandler makeFormatterListener(XSLProcessorContext context,
                                               ElemExtensionCall elem,
                                               String fileName,
                                               boolean shouldPutInTable,
                                               boolean mkdirs, 
                                               boolean append)
    throws java.net.MalformedURLException,
    java.io.FileNotFoundException,
    java.io.IOException,
    javax.xml.transform.TransformerException
  {
    File file = new File(fileName);
    TransformerImpl transformer = context.getTransformer();
    String base;          

    if(!file.isAbsolute())
    {
      
      
      
      
      
  

      Result outputTarget = transformer.getOutputTarget();
      if ( (null != outputTarget) && ((base = outputTarget.getSystemId()) != null) ) {
        base = urlToFileName(base);
      }
      else
      {
        base = urlToFileName(transformer.getBaseURLOfSource());
      }

      if(null != base)
      {
        File baseFile = new File(base);
        file = new File(baseFile.getParent(), fileName);
      }
      
    }

    if(mkdirs)
    {
      String dirStr = file.getParent();
      if((null != dirStr) && (dirStr.length() > 0))
      {
        File dir = new File(dirStr);
        dir.mkdirs();
      }
    }

    
    
    OutputProperties format = transformer.getOutputFormat();

    
    
    
    
    
    
    FileOutputStream ostream = new FileOutputStream(file.getPath(), append);
    
    try
    {
      ContentHandler flistener 
        = transformer.createResultContentHandler(new StreamResult(ostream), format);
      try
      {
        flistener.startDocument();
      }
      catch(org.xml.sax.SAXException se)
      {
        throw new TransformerException(se);
      }
      if(shouldPutInTable)
      {
        m_outputStreams.put(fileName, ostream);
        m_formatterListeners.put(fileName, flistener);
      }
      return flistener;
    }
    catch(TransformerException te)
    {
      throw new javax.xml.transform.TransformerException(te);
    }
    
  }
}
"
org.apache.xalan.xsltc.compiler.Whitespace,14,3,0,33,79,89,1,32,7,1.030769231,805,0.3,0,0.821917808,0.207142857,2,5,55.78571429,11,3.5714,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.StringTokenizer;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;

import org.apache.bcel.classfile.JavaClass;
import org.apache.bcel.classfile.Field;
import org.apache.bcel.classfile.Method;
import org.apache.bcel.generic.*;

import org.apache.xalan.xsltc.dom.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class Whitespace extends TopLevelElement {
    
    public static final int USE_PREDICATE  = 0;
    public static final int STRIP_SPACE    = 1;
    public static final int PRESERVE_SPACE = 2;

    
    public static final int RULE_NONE      = 0; 
    public static final int RULE_ELEMENT   = 1; 
    public static final int RULE_NAMESPACE = 2; 
    public static final int RULE_ALL       = 3; 

    private String _elementList;
    private int    _action;
    private int    _importPrecedence;

    
    private final static class WhitespaceRule {
	private final int _action;
	private String _namespace; 
	private String _element;   
	private int    _type;
	private int    _priority;
	
	
	public WhitespaceRule(int action, String element, int precedence) {
 	    
	    _action = action;

	    
	    final int colon = element.indexOf(':');
	    if (colon >= 0) {
		_namespace = element.substring(0,colon);
		_element = element.substring(colon+1,element.length());
	    }
	    else {
		_namespace = Constants.EMPTYSTRING;
		_element = element;
	    }

	    
	    _priority = precedence << 2;

	    
	    if (_element.equals(""*"")) {
		if (_namespace == Constants.EMPTYSTRING) {
		    _type = RULE_ALL;       
		    _priority += 2;         
		}
		else {
		    _type = RULE_NAMESPACE; 
		    _priority += 1;         
		}
	    }
	    else {
		_type = RULE_ELEMENT;       
	    }
	}

	
	public int compareTo(WhitespaceRule other) {
	    return _priority < other._priority
		? -1
		: _priority > other._priority ? 1 : 0;
	}

	public int getAction() { return _action; }
	public int getStrength() { return _type; }
	public int getPriority() { return _priority; }
	public String getElement() { return _element; }
	public String getNamespace() { return _namespace; }
    }

    
    public void parseContents(Parser parser) {
	
	_action = _qname.getLocalPart().endsWith(""strip-space"") 
	    ? STRIP_SPACE : PRESERVE_SPACE;

	
	_importPrecedence = parser.getCurrentImportPrecedence();

	
	_elementList = getAttribute(""elements"");
	if (_elementList == null || _elementList.length() == 0) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""elements"");
	    return;
	}

	final SymbolTable stable = parser.getSymbolTable();
	StringTokenizer list = new StringTokenizer(_elementList);
	StringBuffer elements = new StringBuffer(Constants.EMPTYSTRING);

	while (list.hasMoreElements()) {
	    String token = list.nextToken();
	    String prefix;
	    String namespace;
	    int col;

	    if ((col = token.indexOf(':')) != -1) {
		prefix  = token.substring(0,col);
	    }
	    else {
		prefix = Constants.EMPTYSTRING;
	    }

	    namespace = lookupNamespace(prefix);
	    if (namespace != null)
		elements.append(namespace+"":""+
				token.substring(col+1,token.length()));
	    else
		elements.append(token);

	    if (list.hasMoreElements())
		elements.append("" "");
	}
	_elementList = elements.toString();
    }


    
    public Vector getRules() {
	final Vector rules = new Vector();
	
	final StringTokenizer list = new StringTokenizer(_elementList);
	while (list.hasMoreElements()) {
	    rules.add(new WhitespaceRule(_action,
					 list.nextToken(),
					 _importPrecedence));
	}
	return rules;
    }
    
    
    
    private static WhitespaceRule findContradictingRule(Vector rules,
							WhitespaceRule rule) {
	for (int i = 0; i < rules.size(); i++) {
	    
	    WhitespaceRule currentRule = (WhitespaceRule)rules.elementAt(i);
	    
	    if (currentRule == rule) {
		return null;
	    }
	    
	    
	    switch (currentRule.getStrength()) {
	    case RULE_ALL:
		return currentRule;
		
	    case RULE_ELEMENT:
		if (!rule.getElement().equals(currentRule.getElement())) {
		    break;
		}
		
	    case RULE_NAMESPACE:
		if (rule.getNamespace().equals(currentRule.getNamespace())) {
		    return currentRule;
		}
		break;
	    }
	}
	return null;
    }


    
    private static int prioritizeRules(Vector rules) {
	WhitespaceRule currentRule;
	int defaultAction = PRESERVE_SPACE;

	
	quicksort(rules, 0, rules.size()-1);

	
	
	
	boolean strip = false;
	for (int i = 0; i < rules.size(); i++) {
	    currentRule = (WhitespaceRule)rules.elementAt(i);
	    if (currentRule.getAction() == STRIP_SPACE) {
		strip = true;
	    }
	}
	
	if (!strip) {
	    rules.removeAllElements();
	    return PRESERVE_SPACE;
	}

	
	for (int idx = 0; idx < rules.size(); ) {
	    currentRule = (WhitespaceRule)rules.elementAt(idx);
	
	    
	    if (findContradictingRule(rules,currentRule) != null) {
		rules.remove(idx);
	    }
	    else {
		
		if (currentRule.getStrength() == RULE_ALL) {
		    defaultAction = currentRule.getAction();
		    for (int i = idx; i < rules.size(); i++) {
			rules.removeElementAt(i);
		    }
		}
		
		idx++;
	    }
	}

	
	if (rules.size() == 0) {
	    return defaultAction;
	}

	
	
	do {
	    currentRule = (WhitespaceRule)rules.lastElement();
	    if (currentRule.getAction() == defaultAction) {
		rules.removeElementAt(rules.size() - 1);
	    }
	    else {
		break;
	    }
	} while (rules.size() > 0);
	
	
	return defaultAction;
    }

    public static void compileStripSpace(BranchHandle strip[], 
					 int sCount,
					 InstructionList il) {
	final InstructionHandle target = il.append(ICONST_1);
	il.append(IRETURN);
	for (int i = 0; i < sCount; i++) {
	    strip[i].setTarget(target);
	}
    }

    public static void compilePreserveSpace(BranchHandle preserve[], 
					    int pCount,
					    InstructionList il) {
	final InstructionHandle target = il.append(ICONST_0);
	il.append(IRETURN);
	for (int i = 0; i < pCount; i++) {
	    preserve[i].setTarget(target);
	}
    }

    

    
    private static void compilePredicate(Vector rules,
					 int defaultAction,
					 ClassGenerator classGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();
	final XSLTC xsltc = classGen.getParser().getXSLTC();

	
	final MethodGenerator stripSpace =
	    new MethodGenerator(ACC_PUBLIC | ACC_FINAL ,
			org.apache.bcel.generic.Type.BOOLEAN, 
			new org.apache.bcel.generic.Type[] {
			    Util.getJCRefType(DOM_INTF_SIG),
			    org.apache.bcel.generic.Type.INT,
			    org.apache.bcel.generic.Type.INT
			},
			new String[] { ""dom"",""node"",""type"" },
			""stripSpace"",classGen.getClassName(),il,cpg);

	classGen.addInterface(""org/apache/xalan/xsltc/StripFilter"");

	final int paramDom = stripSpace.getLocalIndex(""dom"");
	final int paramCurrent = stripSpace.getLocalIndex(""node"");
	final int paramType = stripSpace.getLocalIndex(""type"");

	BranchHandle strip[] = new BranchHandle[rules.size()];
	BranchHandle preserve[] = new BranchHandle[rules.size()];
	int sCount = 0;
	int pCount = 0;

	
	for (int i = 0; i<rules.size(); i++) {
	    
	    WhitespaceRule rule = (WhitespaceRule)rules.elementAt(i);

	    
	    final int gns = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getNamespaceName"",
						      ""(I)Ljava/lang/String;"");

	    final int strcmp = cpg.addMethodref(""java/lang/String"",
						""compareTo"",
						""(Ljava/lang/String;)I"");

	    
	    if (rule.getStrength() == RULE_NAMESPACE) {
		il.append(new ALOAD(paramDom));
		il.append(new ILOAD(paramCurrent));
		il.append(new INVOKEINTERFACE(gns,2));
		il.append(new PUSH(cpg, rule.getNamespace()));
		il.append(new INVOKEVIRTUAL(strcmp));
		il.append(ICONST_0);

		if (rule.getAction() == STRIP_SPACE) {
		    strip[sCount++] = il.append(new IF_ICMPEQ(null));
		}
		else {
		    preserve[pCount++] = il.append(new IF_ICMPEQ(null));
		}
	    }
	    
	    else if (rule.getStrength() == RULE_ELEMENT) {
		
		final Parser parser = classGen.getParser();
		QName qname;
		if (rule.getNamespace() != Constants.EMPTYSTRING )
		    qname = parser.getQName(rule.getNamespace(), null,
					    rule.getElement());
		else
		    qname = parser.getQName(rule.getElement());

		
		final int elementType = xsltc.registerElement(qname);
		il.append(new ILOAD(paramType));
		il.append(new PUSH(cpg, elementType));

		
		if (rule.getAction() == STRIP_SPACE)
		    strip[sCount++] = il.append(new IF_ICMPEQ(null));
		else
		    preserve[pCount++] = il.append(new IF_ICMPEQ(null));
	    }
	}

	if (defaultAction == STRIP_SPACE) {
	    compileStripSpace(strip, sCount, il);
	    compilePreserveSpace(preserve, pCount, il);
	}
	else {
	    compilePreserveSpace(preserve, pCount, il);
	    compileStripSpace(strip, sCount, il);
	}

	stripSpace.stripAttributes(true);
	stripSpace.setMaxLocals();
	stripSpace.setMaxStack();
	stripSpace.removeNOPs();

	classGen.addMethod(stripSpace.getMethod());
    }

    
    private static void compileDefault(int defaultAction,
				       ClassGenerator classGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();
	final XSLTC xsltc = classGen.getParser().getXSLTC();

	
	final MethodGenerator stripSpace =
	    new MethodGenerator(ACC_PUBLIC | ACC_FINAL ,
			org.apache.bcel.generic.Type.BOOLEAN, 
			new org.apache.bcel.generic.Type[] {
			    Util.getJCRefType(DOM_INTF_SIG),
			    org.apache.bcel.generic.Type.INT,
			    org.apache.bcel.generic.Type.INT
			},
			new String[] { ""dom"",""node"",""type"" },
			""stripSpace"",classGen.getClassName(),il,cpg);

	classGen.addInterface(""org/apache/xalan/xsltc/StripFilter"");

	if (defaultAction == STRIP_SPACE)
	    il.append(ICONST_1);
	else
	    il.append(ICONST_0);
	il.append(IRETURN);

	stripSpace.stripAttributes(true);
	stripSpace.setMaxLocals();
	stripSpace.setMaxStack();
	stripSpace.removeNOPs();

	classGen.addMethod(stripSpace.getMethod());
    }


    
    public static int translateRules(Vector rules,
				     ClassGenerator classGen) {
	
	final int defaultAction = prioritizeRules(rules);
	
	if (rules.size() == 0) {
	    compileDefault(defaultAction,classGen);
	    return defaultAction;
	}
	
	compilePredicate(rules, defaultAction, classGen);
	
	return USE_PREDICATE;
    }

    
    private static void quicksort(Vector rules, int p, int r) {
	while (p < r) {
	    final int q = partition(rules, p, r);
	    quicksort(rules, p, q);
	    p = q + 1;
	}
    }
    
    
    private static int partition(Vector rules, int p, int r) {
	final WhitespaceRule x = (WhitespaceRule)rules.elementAt((p+r) >>> 1);
	int i = p - 1, j = r + 1;
	while (true) {
	    while (x.compareTo((WhitespaceRule)rules.elementAt(--j)) < 0) {
	    }
	    while (x.compareTo((WhitespaceRule)rules.elementAt(++i)) > 0) {
	    }
	    if (i < j) {
		final WhitespaceRule tmp = (WhitespaceRule)rules.elementAt(i);
		rules.setElementAt(rules.elementAt(j), i);
		rules.setElementAt(tmp, j);
	    }
	    else {
		return j;
	    }
	}
    }
    
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void; 
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
    }
}
"
org.apache.xpath.DOMOrder,1,1,0,1,1,0,1,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xpath;


public interface DOMOrder
{

  
  public int getUid();
}
"
org.apache.xalan.trace.PrintTraceListener,7,1,0,18,47,9,1,17,7,0.722222222,593,0.0,0,0.0,0.333333333,0,0,82.85714286,10,2.4286,1,"
package org.apache.xalan.trace;

import java.io.*;

import org.w3c.dom.*;
import org.w3c.dom.traversal.NodeIterator;

import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemTextLiteral;
import org.apache.xalan.templates.Constants;
import org.apache.xpath.axes.ContextNodeList;

import javax.xml.transform.SourceLocator;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.ref.DTMNodeProxy;


public class PrintTraceListener implements TraceListenerEx2
{

  
  public PrintTraceListener(java.io.PrintWriter pw)
  {
    m_pw = pw;
  }

  
  java.io.PrintWriter m_pw;

  
  public boolean m_traceTemplates = false;

  
  public boolean m_traceElements = false;

  
  public boolean m_traceGeneration = false;

  
  public boolean m_traceSelection = false;

  
  public void _trace(TracerEvent ev)
  {

    switch (ev.m_styleNode.getXSLToken())
    {
    case Constants.ELEMNAME_TEXTLITERALRESULT :
      if (m_traceElements)
      {
        m_pw.print(ev.m_styleNode.getSystemId()+ "" Line #"" + ev.m_styleNode.getLineNumber() + "", ""
                   + ""Column #"" + ev.m_styleNode.getColumnNumber() + "" -- ""
                   + ev.m_styleNode.getNodeName() + "": "");

        ElemTextLiteral etl = (ElemTextLiteral) ev.m_styleNode;
        String chars = new String(etl.getChars(), 0, etl.getChars().length);

        m_pw.println(""    "" + chars.trim());
      }
      break;
    case Constants.ELEMNAME_TEMPLATE :
      if (m_traceTemplates || m_traceElements)
      {
        ElemTemplate et = (ElemTemplate) ev.m_styleNode;

        m_pw.print(et.getSystemId()+ "" Line #"" + et.getLineNumber() + "", "" + ""Column #""
                   + et.getColumnNumber() + "": "" + et.getNodeName() + "" "");

        if (null != et.getMatch())
        {
          m_pw.print(""match='"" + et.getMatch().getPatternString() + ""' "");
        }

        if (null != et.getName())
        {
          m_pw.print(""name='"" + et.getName() + ""' "");
        }

        m_pw.println();
      }
      break;
    default :
      if (m_traceElements)
      {
        m_pw.println(ev.m_styleNode.getSystemId()+ "" Line #"" + ev.m_styleNode.getLineNumber() + "", ""
                     + ""Column #"" + ev.m_styleNode.getColumnNumber() + "": ""
                     + ev.m_styleNode.getNodeName());
      }
    }
  }
  
  int m_indent = 0;
  
  
  public void trace(TracerEvent ev)
  {







	_trace(ev);
  }
  
  
  public void traceEnd(TracerEvent ev)
  {








  }


  
  public void selected(SelectionEvent ev) throws javax.xml.transform.TransformerException
  {

    if (m_traceSelection)
    {
      ElemTemplateElement ete = (ElemTemplateElement) ev.m_styleNode;
      Node sourceNode = ev.m_sourceNode;
      
      SourceLocator locator = null;
      if (sourceNode instanceof DTMNodeProxy)
      {
        int nodeHandler = ((DTMNodeProxy)sourceNode).getDTMNodeNumber();      
        locator = ((DTMNodeProxy)sourceNode).getDTM().getSourceLocatorFor(nodeHandler);
      }

      if (locator != null)      
        m_pw.println(""Selected source node '"" + sourceNode.getNodeName()
                 + ""', at "" + locator);
      else
        m_pw.println(""Selected source node '"" + sourceNode.getNodeName() +""'"");

      if (ev.m_styleNode.getLineNumber() == 0)
      {

        
        
        ElemTemplateElement parent =
          (ElemTemplateElement) ete.getParentElem();

        if (parent == ete.getStylesheetRoot().getDefaultRootRule())
        {
          m_pw.print(""(default root rule) "");
        }
        else if (parent == ete.getStylesheetRoot().getDefaultTextRule())
        {
          m_pw.print(""(default text rule) "");
        }
        else if (parent == ete.getStylesheetRoot().getDefaultRule())
        {
          m_pw.print(""(default rule) "");
        }

        m_pw.print(ete.getNodeName() + "", "" + ev.m_attributeName + ""='""
                   + ev.m_xpath.getPatternString() + ""': "");
      }
      else
      {
        m_pw.print(ev.m_styleNode.getSystemId()+ "" Line #"" + ev.m_styleNode.getLineNumber() + "", ""
                   + ""Column #"" + ev.m_styleNode.getColumnNumber() + "": ""
                   + ete.getNodeName() + "", "" + ev.m_attributeName + ""='""
                   + ev.m_xpath.getPatternString() + ""': "");
      }

                        if (ev.m_selection.getType() == ev.m_selection.CLASS_NODESET)
                        {
                                m_pw.println();
                                
                                org.apache.xml.dtm.DTMIterator nl = ev.m_selection.iter();

                                try
                                {
                                        nl = nl.cloneWithReset();
                                }
                                catch(CloneNotSupportedException cnse)
                                {
                                        m_pw.println(""     [Can't trace nodelist because it it threw a CloneNotSupportedException]"");
                                        return;
                                }
                                int pos = nl.nextNode();

                                if (DTM.NULL == pos)
                                {
                                        m_pw.println(""     [empty node list]"");
                                }
                                else
                                {
                                        while (DTM.NULL != pos)
                                        {
                                                
                                                DTM dtm = ev.m_processor.getXPathContext().getDTM(pos);
                                                m_pw.print(""     "");
                                                m_pw.print(Integer.toHexString(pos));
                                                m_pw.print("": "");
                                                m_pw.println(dtm.getNodeName(pos));

                                                pos = nl.nextNode();
                                        }
                                }        
                        }
      else
      {
        m_pw.println(ev.m_selection.str());
      }
    }
  }
  
  
  public void selectEnd(EndSelectionEvent ev) 
     throws javax.xml.transform.TransformerException
  {
  	
  }


  
  public void generated(GenerateEvent ev)
  {

    if (m_traceGeneration)
    {
      switch (ev.m_eventtype)
      {
      case GenerateEvent.EVENTTYPE_STARTDOCUMENT :
        m_pw.println(""STARTDOCUMENT"");
        break;
      case GenerateEvent.EVENTTYPE_ENDDOCUMENT :
        m_pw.println(""ENDDOCUMENT"");
        break;
      case GenerateEvent.EVENTTYPE_STARTELEMENT :
        m_pw.println(""STARTELEMENT: "" + ev.m_name);
        break;
      case GenerateEvent.EVENTTYPE_ENDELEMENT :
        m_pw.println(""ENDELEMENT: "" + ev.m_name);
        break;
      case GenerateEvent.EVENTTYPE_CHARACTERS :
      {
        String chars = new String(ev.m_characters, ev.m_start, ev.m_length);

        m_pw.println(""CHARACTERS: "" + chars);
      }
      break;
      case GenerateEvent.EVENTTYPE_CDATA :
      {
        String chars = new String(ev.m_characters, ev.m_start, ev.m_length);

        m_pw.println(""CDATA: "" + chars);
      }
      break;
      case GenerateEvent.EVENTTYPE_COMMENT :
        m_pw.println(""COMMENT: "" + ev.m_data);
        break;
      case GenerateEvent.EVENTTYPE_PI :
        m_pw.println(""PI: "" + ev.m_name + "", "" + ev.m_data);
        break;
      case GenerateEvent.EVENTTYPE_ENTITYREF :
        m_pw.println(""ENTITYREF: "" + ev.m_name);
        break;
      case GenerateEvent.EVENTTYPE_IGNORABLEWHITESPACE :
        m_pw.println(""IGNORABLEWHITESPACE"");
        break;
      }
    }
  }
  

}
"
org.apache.xalan.xsltc.compiler.VariableBase,19,3,2,32,61,99,15,20,18,0.907407407,335,1.0,3,0.769230769,0.190789474,1,4,16.0,7,1.7368,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.Field;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.dom.Axis;

class VariableBase extends TopLevelElement {

    protected QName       _name;            
    protected String      _variable;        
    protected Type        _type;            
    protected boolean     _isLocal;         
    protected LocalVariableGen _local;      
    protected Instruction _loadInstruction; 
    protected Expression  _select;          
    protected String      select;           

    
    protected Vector      _refs = new Vector(2); 

    
    protected Vector      _dependencies = null;

    
    protected boolean    _ignore = false;

    
    protected int        _weight = 0;

    
    public void disable() {
	_ignore = true;
    }

    
    public void addReference(VariableRefBase vref) {
	_refs.addElement(vref);
    }

    
    public void removeReference(VariableRefBase vref) {
	_refs.remove(vref);
    }

    
    public void addDependency(VariableBase other) {
	if (_dependencies == null) {
	    _dependencies = new Vector();
	}
	if (!_dependencies.contains(other)) {
	    _dependencies.addElement(other);
	}
    }

    
    public Vector getDependencies() {
	return _dependencies;
    }

    
    public void mapRegister(MethodGenerator methodGen) {
        if (_local == null) {
            final InstructionList il = methodGen.getInstructionList();
	    final String name = _name.getLocalPart(); 
	    final org.apache.bcel.generic.Type varType = _type.toJCType();
            _local = methodGen.addLocalVariable2(name, varType, il.getEnd());
        }
    }

    
    public void unmapRegister(MethodGenerator methodGen) {
	if (_refs.isEmpty() && (_local != null)) {
	    _local.setEnd(methodGen.getInstructionList().getEnd());
	    methodGen.removeLocalVariable(_local);
	    _refs = null;
	    _local = null;
	}
    }

    
    public Instruction loadInstruction() {
	final Instruction instr = _loadInstruction;
	if (_loadInstruction == null) 
	    _loadInstruction = _type.LOAD(_local.getIndex());
	return _loadInstruction;
    }

    
    public Expression getExpression() {
	return(_select);
    }

    
    public String toString() {
	return(""variable(""+_name+"")"");
    }

    
    public void display(int indent) {
	indent(indent);
	System.out.println(""Variable "" + _name);
	if (_select != null) { 
	    indent(indent + IndentIncrement);
	    System.out.println(""select "" + _select.toString());
	}
	displayContents(indent + IndentIncrement);
    }

    
    public Type getType() {
	return _type;
    }

    
    public QName getName() {
	return _name;
    }

    
    public String getVariable() {
	return _variable;
    }

    
    public void setName(QName name) {
	_name = name;
	_variable = Util.escape(name.getLocalPart());
    }

    
    public boolean isLocal() {
	return _isLocal;
    }

    
    public void parseContents(Parser parser) {
	
	String name = getAttribute(""name"");
	if (name == null) name = EMPTYSTRING;

	if (name.length() > 0)
	    setName(parser.getQNameIgnoreDefaultNs(name));
        else
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""name"");

	
	VariableBase other = parser.lookupVariable(_name);
	if ((other != null) && (other.getParent() == getParent())) {
	    reportError(this, parser, ErrorMsg.VARIABLE_REDEF_ERR, name);
	}
	
	select = getAttribute(""select"");
	if (select.length() > 0) {
	    _select = getParser().parseExpression(this, ""select"", null);
	    if (_select.isDummy()) {
		reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""select"");
		return;
	    }
	}

	
	parseChildren(parser);
    }

    
    public void translateValue(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	
	if (_select != null) {
	    _select.translate(classGen, methodGen);
	    _select.startResetIterator(classGen, methodGen);
	}
	
	else if (hasContents()) {
	    compileResultTree(classGen, methodGen);
	}
	
	else {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();
	    il.append(new PUSH(cpg, Constants.EMPTYSTRING));
	}
    }

}
"
org.apache.xalan.xsltc.compiler.SourceLoader,1,1,0,6,1,0,6,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.xml.sax.InputSource;

public interface SourceLoader {

    
    public InputSource loadSource(String href, String context, XSLTC xsltc);

}
"
org.apache.xml.utils.SuballocatedByteVector,18,1,0,0,20,3,0,0,10,0.329411765,833,1.0,0,0.0,0.685185185,0,0,45.0,8,3.1111,0,"
package org.apache.xml.utils;


public class SuballocatedByteVector
{
  
  protected int m_blocksize;
  
  
  protected  int m_numblocks=32;
  
  
  protected byte m_map[][];

  
  protected int m_firstFree = 0;

  
  protected byte m_map0[];

  
  public SuballocatedByteVector()
  {
    this(2048);
  }

  
  public SuballocatedByteVector(int blocksize)
  {
    m_blocksize = blocksize;
    m_map0=new byte[blocksize];
    m_map = new byte[m_numblocks][];
    m_map[0]=m_map0;
  }
  
  
  public SuballocatedByteVector(int blocksize, int increaseSize)
  {
    
    this(blocksize);
  }


  
  public int size()
  {
    return m_firstFree;
  }
  
  
  private  void setSize(int sz)
  {
    if(m_firstFree<sz)
      m_firstFree = sz;
  }

  
  public  void addElement(byte value)
  {
    if(m_firstFree<m_blocksize)
      m_map0[m_firstFree++]=value;
    else
    {
      int index=m_firstFree/m_blocksize;
      int offset=m_firstFree%m_blocksize;
      ++m_firstFree;

      if(index>=m_map.length)
      {
        int newsize=index+m_numblocks;
        byte[][] newMap=new byte[newsize][];
        System.arraycopy(m_map, 0, newMap, 0, m_map.length);
        m_map=newMap;
      }
      byte[] block=m_map[index];
      if(null==block)
        block=m_map[index]=new byte[m_blocksize];
      block[offset]=value;
    }
  }
  
  
  private  void addElements(byte value, int numberOfElements)
  {
    if(m_firstFree+numberOfElements<m_blocksize)
      for (int i = 0; i < numberOfElements; i++) 
      {
        m_map0[m_firstFree++]=value;
      }
    else
    {
      int index=m_firstFree/m_blocksize;
      int offset=m_firstFree%m_blocksize;
      m_firstFree+=numberOfElements;
      while( numberOfElements>0)
      {
        if(index>=m_map.length)
        {
          int newsize=index+m_numblocks;
          byte[][] newMap=new byte[newsize][];
          System.arraycopy(m_map, 0, newMap, 0, m_map.length);
          m_map=newMap;
        }
        byte[] block=m_map[index];
        if(null==block)
          block=m_map[index]=new byte[m_blocksize];
        int copied=(m_blocksize-offset < numberOfElements)
          ? m_blocksize-offset : numberOfElements;
        numberOfElements-=copied;
        while(copied-- > 0)
          block[offset++]=value;

        ++index;offset=0;
      }
    }
  }
  
  
  private  void addElements(int numberOfElements)
  {
    int newlen=m_firstFree+numberOfElements;
    if(newlen>m_blocksize)
    {
      int index=m_firstFree%m_blocksize;
      int newindex=(m_firstFree+numberOfElements)%m_blocksize;
      for(int i=index+1;i<=newindex;++i)
        m_map[i]=new byte[m_blocksize];
    }
    m_firstFree=newlen;
  }
  
  
  private  void insertElementAt(byte value, int at)
  {
    if(at==m_firstFree)
      addElement(value);
    else if (at>m_firstFree)
    {
      int index=at/m_blocksize;
      if(index>=m_map.length)
      {
        int newsize=index+m_numblocks;
        byte[][] newMap=new byte[newsize][];
        System.arraycopy(m_map, 0, newMap, 0, m_map.length);
        m_map=newMap;
      }
      byte[] block=m_map[index];
      if(null==block)
        block=m_map[index]=new byte[m_blocksize];
      int offset=at%m_blocksize;
      block[offset]=value;
      m_firstFree=offset+1;
    }
    else
    {
      int index=at/m_blocksize;
      int maxindex=m_firstFree+1/m_blocksize;
      ++m_firstFree;
      int offset=at%m_blocksize;
      byte push;
      
      
      while(index<=maxindex)
      {
        int copylen=m_blocksize-offset-1;
        byte[] block=m_map[index];
        if(null==block)
        {
          push=0;
          block=m_map[index]=new byte[m_blocksize];
        }
        else
        {
          push=block[m_blocksize-1];
          System.arraycopy(block, offset , block, offset+1, copylen);
        }
        block[offset]=value;
        value=push;
        offset=0;
        ++index;
      }
    }
  }

  
  public void removeAllElements()
  {
    m_firstFree = 0;
  }

  
  private  boolean removeElement(byte s)
  {
    int at=indexOf(s,0);
    if(at<0)
      return false;
    removeElementAt(at);
    return true;
  }

  
  private  void removeElementAt(int at)
  {
    
    if(at<m_firstFree)
    {
      int index=at/m_blocksize;
      int maxindex=m_firstFree/m_blocksize;
      int offset=at%m_blocksize;
      
      while(index<=maxindex)
      {
        int copylen=m_blocksize-offset-1;
        byte[] block=m_map[index];
        if(null==block)
          block=m_map[index]=new byte[m_blocksize];
        else
          System.arraycopy(block, offset+1, block, offset, copylen);
        if(index<maxindex)
        {
          byte[] next=m_map[index+1];
          if(next!=null)
            block[m_blocksize-1]=(next!=null) ? next[0] : 0;
        }
        else
          block[m_blocksize-1]=0;
        offset=0;
        ++index;
      }
    }
    --m_firstFree;
  }

  
  public void setElementAt(byte value, int at)
  {
    if(at<m_blocksize)
    {
      m_map0[at]=value;
      return;
    }

    int index=at/m_blocksize;
    int offset=at%m_blocksize;
        
    if(index>=m_map.length)
    {
      int newsize=index+m_numblocks;
      byte[][] newMap=new byte[newsize][];
      System.arraycopy(m_map, 0, newMap, 0, m_map.length);
      m_map=newMap;
    }

    byte[] block=m_map[index];
    if(null==block)
      block=m_map[index]=new byte[m_blocksize];
    block[offset]=value;

    if(at>=m_firstFree)
      m_firstFree=at+1;
  }

  
  public byte elementAt(int i)
  {
    
    
    if(i<m_blocksize)
      return m_map0[i];

    return m_map[i/m_blocksize][i%m_blocksize];
  }

  
  private  boolean contains(byte s)
  {
    return (indexOf(s,0) >= 0);
  }

  
  public int indexOf(byte elem, int index)
  {
    if(index>=m_firstFree)
      return -1;
          
    int bindex=index/m_blocksize;
    int boffset=index%m_blocksize;
    int maxindex=m_firstFree/m_blocksize;
    byte[] block;
    
    for(;bindex<maxindex;++bindex)
    {
      block=m_map[bindex];
      if(block!=null)
        for(int offset=boffset;offset<m_blocksize;++offset)
          if(block[offset]==elem)
            return offset+bindex*m_blocksize;
      boffset=0; 
    }
    
    int maxoffset=m_firstFree%m_blocksize;
    block=m_map[maxindex];
    for(int offset=boffset;offset<maxoffset;++offset)
      if(block[offset]==elem)
        return offset+maxindex*m_blocksize;

    return -1;    
  }

  
  public int indexOf(byte elem)
  {
    return indexOf(elem,0);
  }

  
  private  int lastIndexOf(byte elem)
  {
    int boffset=m_firstFree%m_blocksize;
    for(int index=m_firstFree/m_blocksize;
        index>=0;
        --index)
    {
      byte[] block=m_map[index];
      if(block!=null)
        for(int offset=boffset; offset>=0; --offset)
          if(block[offset]==elem)
            return offset+index*m_blocksize;
      boffset=0; 
    }
    return -1;
  }

}
"
org.apache.xpath.operations.Lte,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class Lte extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.lessThanOrEqual(right) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.xsltc.compiler.FilterParentPath,6,3,0,27,31,0,2,25,6,0.333333333,213,1.0,2,0.934210526,0.305555556,2,7,34.0,4,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class FilterParentPath extends Expression {

    private Expression _filterExpr;
    private Expression _path;
    private boolean _hasDescendantAxis = false;

    public FilterParentPath(Expression filterExpr, Expression path) {
	(_path = path).setParent(this);
	(_filterExpr = filterExpr).setParent(this);
    }
		
    public void setParser(Parser parser) {
	super.setParser(parser);
	_filterExpr.setParser(parser);
	_path.setParser(parser);
    }
    
    public String toString() {
	return ""FilterParentPath("" + _filterExpr + "", "" + _path + ')';
    }

    public void setDescendantAxis() {
	_hasDescendantAxis = true;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type ftype = _filterExpr.typeCheck(stable);
	if (ftype instanceof NodeSetType == false) {
	    if (ftype instanceof ReferenceType)  {
		_filterExpr = new CastExpr(_filterExpr, Type.NodeSet);
	    }
	    
	    else if (ftype instanceof NodeType)  {
		_filterExpr = new CastExpr(_filterExpr, Type.NodeSet);
	    }
	    else {
		throw new TypeCheckError(this);
	    }
	}

	
	final Type ptype = _path.typeCheck(stable);
	if (!(ptype instanceof NodeSetType)) {
	    _path = new CastExpr(_path, Type.NodeSet);
	}

	return _type = Type.NodeSet;	
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	
	final int initSI = cpg.addMethodref(STEP_ITERATOR_CLASS,
					    ""<init>"",
					    ""(""
					    +NODE_ITERATOR_SIG
					    +NODE_ITERATOR_SIG
					    +"")V"");
	il.append(new NEW(cpg.addClass(STEP_ITERATOR_CLASS)));
	il.append(DUP);

	
	_filterExpr.translate(classGen, methodGen);
	_path.translate(classGen, methodGen);

	
	il.append(new INVOKESPECIAL(initSI));

	
        if (_hasDescendantAxis) {
	    final int incl = cpg.addMethodref(NODE_ITERATOR_BASE,
					      ""includeSelf"",
					      ""()"" + NODE_ITERATOR_SIG);
	    il.append(new INVOKEVIRTUAL(incl));
	}

	if (!(getParent() instanceof RelativeLocationPath) &&
	    !(getParent() instanceof FilterParentPath)) {
	    final int order = cpg.addInterfaceMethodref(DOM_INTF,
							ORDER_ITERATOR,
							ORDER_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(order, 3));
	}
    }
}
"
org.apache.xalan.xsltc.compiler.LocationPathPattern,12,4,3,16,17,52,7,9,12,0.840909091,96,1.0,1,0.887755102,0.236111111,2,3,6.666666667,6,1.4167,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.*;

public abstract class LocationPathPattern extends Pattern {
    private Template _template;
    private int _importPrecedence;
    private double _priority = Double.NaN;
    private int _position = 0;

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;		
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }
	
    public void setTemplate(final Template template) {
	_template = template;
	_priority = template.getPriority();
	_importPrecedence = template.getImportPrecedence();
	_position = template.getPosition();
    }
		
    public Template getTemplate() {
	return _template;
    }
		
    public final double getPriority() {
	return Double.isNaN(_priority) ? getDefaultPriority() : _priority;
    }
		
    public double getDefaultPriority() {
	return 0.5;
    }

    
    public boolean noSmallerThan(LocationPathPattern other) {
	if (_importPrecedence > other._importPrecedence) {
	    return true;
	}
	else if (_importPrecedence == other._importPrecedence) {
	    if (_priority > other._priority) {
		return true;
	    }
	    else if (_priority == other._priority) {
		if (_position > other._position) {
		    return true;
		}
	    }
	}
	return false;
    }
    
    
    public abstract StepPattern getKernelPattern();
	
    public abstract void reduceKernelPattern();
		
    public abstract boolean isWildcard();

    public String toString() {
	return ""root()"";
    }
}
"
org.apache.xalan.xsltc.trax.TemplatesHandlerImpl,8,2,0,9,39,10,1,9,7,0.714285714,180,1.0,1,0.915662651,0.267857143,1,1,21.0,8,1.75,0,"

package org.apache.xalan.xsltc.trax;

import javax.xml.transform.*;
import javax.xml.transform.sax.*;

import org.xml.sax.Locator;
import org.xml.sax.InputSource;

import org.apache.xalan.xsltc.compiler.*;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;


public class TemplatesHandlerImpl extends Parser 
    implements TemplatesHandler, SourceLoader 
{
    
    private String _systemId;

    
    private int _indentNumber;

    
    private URIResolver _uriResolver = null;

    
    private TransformerFactoryImpl _tfactory = null;

    
    protected TemplatesHandlerImpl(int indentNumber, 
	TransformerFactoryImpl tfactory) 
    {
	super(null);
	_indentNumber = indentNumber;
	_tfactory = tfactory;
    }

    
    public void init() {
	
	final XSLTC xsltc = new XSLTC();
	super.setXSLTC(xsltc);
	xsltc.init();
	super.init();
	xsltc.setParser(this);
	xsltc.setOutputType(XSLTC.BYTEARRAY_OUTPUT);
    }

    
    public String getSystemId() {
	return _systemId;
    }

    
    public void setSystemId(String id) {
	_systemId = id;
    }

    
    public void setURIResolver(URIResolver resolver) {
	_uriResolver = resolver;
    }

    
    public Templates getTemplates() {
	try {
	    final XSLTC xsltc = getXSLTC();

	    
	    if (_uriResolver != null) {
		xsltc.setSourceLoader(this);
	    }

	    
	    String transletName = TransformerFactoryImpl._defaultTransletName;
	    if (_systemId != null) {
		transletName = Util.baseName(_systemId);
	    }
	    xsltc.setClassName(transletName);

	    
	    transletName = xsltc.getClassName();

	    Stylesheet stylesheet = null;
	    SyntaxTreeNode root = getDocumentRoot();

	    
	    if (!errorsFound() && root != null) {
		
		stylesheet = makeStylesheet(root);
		stylesheet.setSystemId(_systemId);
		stylesheet.setParentStylesheet(null);
		setCurrentStylesheet(stylesheet);

		
		xsltc.setStylesheet(stylesheet);

		
		createAST(stylesheet);
	    }

	    
	    if (!errorsFound() && stylesheet != null) {
		stylesheet.setMultiDocument(xsltc.isMultiDocument());
		stylesheet.translate();
	    }

	    if (!errorsFound()) {
		
		final byte[][] bytecodes = xsltc.getBytecodes();
		if (bytecodes != null) {
		    final TemplatesImpl templates = 
			new TemplatesImpl(xsltc.getBytecodes(), transletName, 
			    getOutputProperties(), _indentNumber, _tfactory);

		    
		    if (_uriResolver != null) {
			templates.setURIResolver(_uriResolver);
		    }
		    return templates;
		}
	    }
	}
	catch (CompilerException e) {
	    
	}
	return null;
    }

    
    public void setDocumentLocator(Locator locator) {
	super.setDocumentLocator(locator);
  	setSystemId(locator.getSystemId());
    }

    
    public InputSource loadSource(String href, String context, XSLTC xsltc) {
	try {
	    
	    final Source source = _uriResolver.resolve(href, context);
	    if (source != null) {
		return Util.getInputSource(xsltc, source);
	    }
	}
	catch (TransformerException e) {
	    
	}
	return null;
    }
}


"
org.apache.xalan.templates.ElemTemplate,22,3,2,29,46,189,24,11,22,0.942857143,179,0.8,4,0.903225806,0.181818182,2,14,6.681818182,1,0.9545,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;


public class ElemTemplate extends ElemTemplateElement
{
  
  private String m_publicId;

  
  private String m_systemId;

  
  public String getPublicId()
  {
    return m_publicId;
  }

  
  public String getSystemId()
  {
    return m_systemId;
  }

  
  public void setLocaterInfo(SourceLocator locator)
  {

    m_publicId = locator.getPublicId();
    m_systemId = locator.getSystemId();

    super.setLocaterInfo(locator);
  }

  
  private Stylesheet m_stylesheet;

  
  public StylesheetComposed getStylesheetComposed()
  {
    return m_stylesheet.getStylesheetComposed();
  }

  
  public Stylesheet getStylesheet()
  {
    return m_stylesheet;
  }

  
  public void setStylesheet(Stylesheet sheet)
  {
    m_stylesheet = sheet;
  }

  
  public StylesheetRoot getStylesheetRoot()
  {
    return m_stylesheet.getStylesheetRoot();
  }

  
  private XPath m_matchPattern = null;

  
  public void setMatch(XPath v)
  {
    m_matchPattern = v;
  }

  
  public XPath getMatch()
  {
    return m_matchPattern;
  }

  
  private QName m_name = null;

  
  public void setName(QName v)
  {
    m_name = v;
  }

  
  public QName getName()
  {
    return m_name;
  }

  
  private QName m_mode;

  
  public void setMode(QName v)
  {
    m_mode = v;
  }

  
  public QName getMode()
  {
    return m_mode;
  }

  
  private double m_priority = XPath.MATCH_SCORE_NONE;

  
  public void setPriority(double v)
  {
    m_priority = v;
  }

  
  public double getPriority()
  {
    return m_priority;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_TEMPLATE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_TEMPLATE_STRING;
  }
  
  
  public int m_frameSize;
  
  
  int m_inArgsSize;
  
  
  private int[] m_argsQNameIDs;
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_matchPattern)
      m_matchPattern.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
      
    cstate.resetStackFrameSize();
    m_inArgsSize = 0;
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    super.endCompose(sroot);
    m_frameSize = cstate.getFrameSize();
    
    cstate.resetStackFrameSize();
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    XPathContext xctxt = transformer.getXPathContext();
    
    transformer.getStackGuard().checkForInfinateLoop();
    
    xctxt.pushRTFContext();

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

      


      transformer.executeChildTemplates(this, true);










    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);

    xctxt.popRTFContext();  
    }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeTemplates(this);
  }

}
"
org.apache.xalan.xsltc.compiler.XslElement,10,3,0,36,70,7,1,35,7,0.644444444,658,1.0,2,0.861538462,0.3,1,9,64.3,13,4.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import java.util.StringTokenizer;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class XslElement extends Instruction {

    private String  _prefix;
    private boolean _ignore = false;
    private boolean _isLiteralName = true;
    private AttributeValueTemplate _name; 
    private AttributeValueTemplate _namespace;

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Element "" + _name);
	displayContents(indent + IndentIncrement);
    }

    
    public boolean declaresDefaultNS() {
	return false;
    }

    
    private boolean isLiteral(String str) {
	final int length = str.length();
	for (int i = 0; i < length; i++) {
	    if (str.charAt(i) == '{' && str.charAt(i + 1) != '{') {
		return false;
	    }
	}
	return true;
    }

    
    private boolean isLegalName(String str) {
	if (str.indexOf(' ') > -1) {
	    return false;
	}
	final int colon = str.indexOf(':');
	if (colon == 0 || colon == str.length() - 1) {
	    return false;
	}
	final char first = str.charAt(0);
	if (!Character.isLetter(first) && first != '_') {
	    return false;
	}
	return true;
    }

    public void parseContents(Parser parser) {
	final SymbolTable stable = parser.getSymbolTable();

	
	String name = getAttribute(""name"");
	if (name == EMPTYSTRING) {
	    ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_ELEM_NAME_ERR,
					name, this);
	    parser.reportError(WARNING, msg);
	    parseChildren(parser);
	    _ignore = true; 	
	    return;
	}

	
	String namespace = getAttribute(""namespace"");

	
	_isLiteralName = isLiteral(name);
	if (_isLiteralName) {
	    if (!isLegalName(name)) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_ELEM_NAME_ERR,
					    name, this);
		parser.reportError(WARNING, msg);
		parseChildren(parser);
		_ignore = true; 	
		return;
	    }

	    final QName qname = parser.getQNameSafe(name);
	    String prefix = qname.getPrefix();
	    String local = qname.getLocalPart();
	    
	    if (prefix == null) {
		prefix = EMPTYSTRING;
	    }

	    if (!hasAttribute(""namespace"")) {
		namespace = lookupNamespace(prefix); 
		if (namespace == null) {
		    ErrorMsg err = new ErrorMsg(ErrorMsg.NAMESPACE_UNDEF_ERR,
						prefix, this);
		    parser.reportError(WARNING, err);
		    parseChildren(parser);
		    _ignore = true; 	
		    return;
		}
		_prefix = prefix;
		_namespace = new AttributeValueTemplate(namespace, parser, this);
	    }
	    else {
		if (prefix == EMPTYSTRING) {
		    if (isLiteral(namespace)) {
			prefix = lookupPrefix(namespace);
			if (prefix == null) {
			    prefix = stable.generateNamespacePrefix();
			}
		    }

		    
		    final StringBuffer newName = new StringBuffer(prefix);
		    if (prefix != EMPTYSTRING) {
			newName.append(':');
		    }
		    name = newName.append(local).toString();
		}
		_prefix = prefix;
		_namespace = new AttributeValueTemplate(namespace, parser, this);
	    }
	}
	else {
	    _namespace = (namespace == EMPTYSTRING) ? null :
			 new AttributeValueTemplate(namespace, parser, this);
	}

	_name = new AttributeValueTemplate(name, parser, this);

	final String useSets = getAttribute(""use-attribute-sets"");
	if (useSets.length() > 0) {
	    setFirstElement(new UseAttributeSets(useSets, parser));
	}

	parseChildren(parser);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (!_ignore) {
	    _name.typeCheck(stable);
	    if (_namespace != null) {
		_namespace.typeCheck(stable);
	    }
	}
	typeCheckContents(stable);
	return Type.Void;
    }

    
    public void translateLiteral(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (!_ignore) {
	    il.append(methodGen.loadHandler());
	    _name.translate(classGen, methodGen);
	    il.append(DUP2);
	    il.append(methodGen.startElement());

	    if (_namespace != null) {
		il.append(methodGen.loadHandler());
		il.append(new PUSH(cpg, _prefix));
		_namespace.translate(classGen,methodGen);
		il.append(methodGen.namespace());
	    }
	}

	translateContents(classGen, methodGen);

	if (!_ignore) {
	    il.append(methodGen.endElement());
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	LocalVariableGen local = null;
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	if (_isLiteralName) {
	    translateLiteral(classGen, methodGen);
	    return;
	}

	if (!_ignore) {
	    il.append(methodGen.loadHandler());
	    _name.translate(classGen, methodGen);

	    
	    il.append(DUP);
	    final int getPrefix = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""getPrefix"",
					      ""("" + STRING_SIG + "")"" + STRING_SIG);
	    il.append(new INVOKESTATIC(getPrefix));
	    il.append(DUP);
	    local = methodGen.addLocalVariable(""prefix"", 
					       org.apache.bcel.generic.Type.STRING,
					       il.getEnd(), null);
	    il.append(new ASTORE(local.getIndex()));

	    
	    final BranchHandle ifNotNull = il.append(new IFNONNULL(null));
	    if (_namespace != null) {
		final int generatePrefix = cpg.addMethodref(BASIS_LIBRARY_CLASS, 
							    ""generatePrefix"", 
							    ""()"" + STRING_SIG);
		il.append(new INVOKESTATIC(generatePrefix));
		il.append(DUP);
		il.append(new ASTORE(local.getIndex()));

		
		final int makeQName = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""makeQName"", 
				       ""("" + STRING_SIG + STRING_SIG + "")"" + STRING_SIG);
		il.append(new INVOKESTATIC(makeQName));
	    }
	    ifNotNull.setTarget(il.append(DUP2));
	    il.append(methodGen.startElement());

	    if (_namespace != null) {
		il.append(methodGen.loadHandler());
		il.append(new ALOAD(local.getIndex()));
		_namespace.translate(classGen, methodGen);
		il.append(methodGen.namespace());
	    }
	    else {
		
		il.append(new ALOAD(local.getIndex()));
		final BranchHandle ifNull = il.append(new IFNULL(null));
		il.append(methodGen.loadHandler());
		il.append(new ALOAD(local.getIndex()));

		il.append(methodGen.loadDOM());
		il.append(methodGen.loadCurrentNode());
		il.append(new ALOAD(local.getIndex()));

		final int lookupNamespace = cpg.addInterfaceMethodref(DOM_INTF, 
					""lookupNamespace"", 
				        ""(I"" + STRING_SIG + "")"" + STRING_SIG);
		il.append(new INVOKEINTERFACE(lookupNamespace, 3));
		il.append(methodGen.namespace());
		ifNull.setTarget(il.append(NOP));
	    }
	}

	translateContents(classGen, methodGen);

	if (!_ignore) {
	    il.append(methodGen.endElement());
	}
    }

    
    public void translateContents(ClassGenerator classGen,
				  MethodGenerator methodGen) {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    final SyntaxTreeNode item =
		(SyntaxTreeNode)getContents().elementAt(i);
	    if (_ignore && item instanceof XslAttribute) continue;
	    item.translate(classGen, methodGen);
	}
    }

}
"
org.apache.xml.dtm.ref.IncrementalSAXSource,5,1,0,6,5,10,6,0,5,2.0,5,0.0,0,0.0,0.333333333,0,0,0.0,1,1.0,0,"

package org.apache.xml.dtm.ref;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.ContentHandler;
import org.xml.sax.XMLReader;


public interface IncrementalSAXSource
{
  
  
  

  
  public void setContentHandler(ContentHandler handler);

  
  public void setLexicalHandler(org.xml.sax.ext.LexicalHandler handler);

  
  public void setDTDHandler(org.xml.sax.DTDHandler handler);

  
  
  

  
  public Object deliverMoreNodes (boolean parsemore);

  
  
  

  
  public void startParse(InputSource source) throws SAXException;
    
} 
"
org.apache.xalan.xsltc.compiler.util.ResultTreeType,22,2,0,43,58,201,9,36,21,0.523809524,715,1.0,0,0.622641509,0.199300699,2,4,31.45454545,7,1.5455,1,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.DOM;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.Constants;

public final class ResultTreeType extends Type {
    private final String _methodName;

    protected ResultTreeType() {
	_methodName = null;
    }

    public ResultTreeType(String methodName) {
	_methodName = methodName;
    }

    public String toString() {
	return ""result-tree"";
    }

    public boolean identicalTo(Type other) {
	return (other instanceof ResultTreeType);
    }

    public String toSignature() {
	return DOM_INTF_SIG;
    }

    public org.apache.bcel.generic.Type toJCType() {
	return Util.getJCRefType(toSignature());
    }

    public String getMethodName() {
	return _methodName;
    }

    public boolean implementedAsMethod() {
	return _methodName != null;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType)type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType)type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType)type);
	}
	else if (type == Type.NodeSet) {
	    translateTo(classGen, methodGen, (NodeSetType)type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType)type);
	}
	else if (type == Type.Object) {
	    translateTo(classGen, methodGen, (ObjectType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	
	
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(POP);      
	il.append(ICONST_1); 
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	
	if (_methodName == null) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  ""getStringValue"", 
						  ""()""+STRING_SIG);
	    il.append(new INVOKEINTERFACE(index, 1));
	}
	else {
	    final String className = classGen.getClassName();
	    final int current = methodGen.getLocalIndex(""current"");
	    
	    
	    il.append(classGen.loadTranslet());
	    if (classGen.isExternal()) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }
	    il.append(DUP);
	    il.append(new GETFIELD(cpg.addFieldref(className, ""_dom"",
						   DOM_INTF_SIG)));

	    
	    int index = cpg.addMethodref(STRING_VALUE_HANDLER, ""<init>"", ""()V"");
	    il.append(new NEW(cpg.addClass(STRING_VALUE_HANDLER)));
	    il.append(DUP);
	    il.append(DUP);
	    il.append(new INVOKESPECIAL(index));
	    
	    
	    final LocalVariableGen handler =
		methodGen.addLocalVariable(""rt_to_string_handler"", 
					   Util.getJCRefType(STRING_VALUE_HANDLER_SIG),
					   null, null);
	    il.append(new ASTORE(handler.getIndex()));

	    
	    index = cpg.addMethodref(className, _methodName,
				     ""(""+DOM_INTF_SIG+TRANSLET_OUTPUT_SIG+"")V"");
	    il.append(new INVOKEVIRTUAL(index));
	    
	    
	    il.append(new ALOAD(handler.getIndex()));
	    index = cpg.addMethodref(STRING_VALUE_HANDLER,
				     ""getValue"",
				     ""()"" + STRING_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	translateTo(classGen, methodGen, Type.String);
	Type.String.translateTo(classGen, methodGen, Type.Real);	
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_methodName == null) {
	    il.append(NOP);
	}
	else {
	    LocalVariableGen domBuilder, newDom;
	    final String className = classGen.getClassName();
	    final int current = methodGen.getLocalIndex(""current"");

	    
	    il.append(classGen.loadTranslet());
	    if (classGen.isExternal()) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }
	    il.append(methodGen.loadDOM());

	    
	    int index = cpg.addMethodref(DOM_IMPL, ""<init>"", ""(I)V"");
	    il.append(new NEW(cpg.addClass(DOM_IMPL)));
	    il.append(DUP);
	    il.append(DUP);
	    il.append(new PUSH(cpg, 64));
	    il.append(new INVOKESPECIAL(index));
	    
	    
	    newDom = methodGen.addLocalVariable(""rt_to_reference_dom"", 
						Util.getJCRefType(DOM_INTF_SIG),
						null, null);
	    il.append(new CHECKCAST(cpg.addClass(DOM_INTF_SIG)));
	    il.append(new ASTORE(newDom.getIndex()));

	    
	    index = cpg.addMethodref(DOM_IMPL,
				     ""getOutputDomBuilder"", 
				     ""()"" + TRANSLET_OUTPUT_SIG);
	    il.append(new INVOKEVIRTUAL(index));
	    il.append(DUP);
	    il.append(DUP);

	    
	    domBuilder =
		methodGen.addLocalVariable(""rt_to_reference_handler"", 
					   Util.getJCRefType(TRANSLET_OUTPUT_SIG),
					   null, null);
	    il.append(new ASTORE(domBuilder.getIndex()));

	    
	    index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE, 
					      ""startDocument"", ""()V"");
	    il.append(new INVOKEINTERFACE(index, 1));

	    
	    index = cpg.addMethodref(className,
				     _methodName,
				     ""(""
				     + DOM_INTF_SIG
				     + TRANSLET_OUTPUT_SIG
				     +"")V"");
	    il.append(new INVOKEVIRTUAL(index));

	    
	    il.append(new ALOAD(domBuilder.getIndex()));
	    index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE, 
					      ""endDocument"", ""()V"");
	    il.append(new INVOKEINTERFACE(index, 1));

	    
	    il.append(new ALOAD(newDom.getIndex()));
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    NodeSetType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(DUP);

	
	
	
	il.append(classGen.loadTranslet()); 
	il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       NAMES_INDEX,
					       NAMES_INDEX_SIG)));
	il.append(classGen.loadTranslet()); 
	il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       NAMESPACE_INDEX,
					       NAMESPACE_INDEX_SIG)));
	
	final int mapping = cpg.addInterfaceMethodref(DOM_INTF,
						      ""setupMapping"",
						      ""([""+STRING_SIG+
						      ""[""+STRING_SIG+"")V"");
	il.append(new INVOKEINTERFACE(mapping, 3));
	il.append(DUP);

	
	final int iter = cpg.addInterfaceMethodref(DOM_INTF,
						   ""getChildren"",
						   ""(I)""+NODE_ITERATOR_SIG);
	il.append(new PUSH(cpg, DOM.ROOTNODE));
	il.append(new INVOKEINTERFACE(iter, 2));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ObjectType type) {
	methodGen.getInstructionList().append(NOP);	
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	translateTo(classGen, methodGen, Type.Boolean);
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	final String className = clazz.getName();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (className.equals(""org.w3c.dom.Node"")) {
	    translateTo(classGen, methodGen, Type.NodeSet);
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE,
						  MAKE_NODE_SIG2);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else if (className.equals(""org.w3c.dom.NodeList"")) {
	    translateTo(classGen, methodGen, Type.NodeSet);
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE_LIST,
						  MAKE_NODE_LIST_SIG2);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else if (className.equals(""java.lang.Object"")) {
	    il.append(NOP);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), className);
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public String getClassName() {
	return(DOM_INTF);
    }

    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}
"
org.apache.xalan.xsltc.compiler.IdKeyPattern,9,5,2,28,26,22,3,26,9,0.75,158,1.0,1,0.925233645,0.259259259,3,4,16.22222222,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.*;

abstract class IdKeyPattern extends LocationPathPattern {

    protected RelativePathPattern _left = null;;
    private String _index = null;
    private String _value = null;;

    public IdKeyPattern(String index, String value) {
	_index = index;
	_value = value;
    }

    public String getIndexName() {
	return(_index);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.NodeSet;
    }
    
    public boolean isWildcard() {
	return false;
    }
    
    public void setLeft(RelativePathPattern left) {
	_left = left;
    }

    public StepPattern getKernelPattern() {
	return(null);
    }
    
    public void reduceKernelPattern() { }

    public String toString() {
	return ""id/keyPattern("" + _index + "", "" + _value + ')';
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getKeyIndex = cpg.addMethodref(TRANSLET_CLASS,
						 ""getKeyIndex"",
						 ""(Ljava/lang/String;)""+
						 KEY_INDEX_SIG);
	
	
	final int lookupId = cpg.addMethodref(KEY_INDEX_CLASS,
					      ""containsID"",
					      ""(ILjava/lang/Object;)I"");
	final int lookupKey = cpg.addMethodref(KEY_INDEX_CLASS,
					       ""containsKey"",
					       ""(ILjava/lang/Object;)I"");

	
	
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg,_index));
	il.append(new INVOKEVIRTUAL(getKeyIndex));
	
	
	
	il.append(SWAP);
	il.append(new PUSH(cpg,_value));
	if (this instanceof IdPattern)
	    il.append(new INVOKEVIRTUAL(lookupId));
	else
	    il.append(new INVOKEVIRTUAL(lookupKey));

	_trueList.add(il.append(new IFNE(null)));
	_falseList.add(il.append(new GOTO(null)));
    }

}

"
org.apache.xml.utils.res.XResources_ka,3,4,0,1,4,1,0,1,2,0.5,614,0.0,0,0.976190476,1.0,0,0,203.3333333,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_ka extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ka"" }, { ""help_language"", ""ka"" }, { ""language"", ""ka"" },
    { ""alphabet"",
      new char[]{ 0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6,
                  0x10f1, 0x10D7, 0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC,
                  0x10f2, 0x10DD, 0x10DE, 0x10DF, 0x10E0, 0x10E1, 0x10E2,
                  0x10E3, 0x10E4, 0x10E5, 0x10E6, 0x10E7, 0x10E8, 0x10E9,
                  0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10F4, 0x10EF,
                  0x10F0 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    { ""numberGroups"", new int[]{ 1000, 100, 10, 1 } },

    
    { ""digits"",
      new char[]{ 0x10D0, 0x10D1, 0x10D2, 0x10D3, 0x10D4, 0x10D5, 0x10D6,
                  0x10f1, 0x10D7 } },
    { ""tens"",
      new char[]{ 0x10D8, 0x10D9, 0x10DA, 0x10DB, 0x10DC, 0x10f2, 0x10DD,
                  0x10DE, 0x10DF } },
    { ""hundreds"",
      new char[]{ 0x10E0, 0x10E1, 0x10E2, 0x10E3, 0x10E4, 0x10E5, 0x10E6,
                  0x10E7, 0x10E8 } },
    { ""thousands"",
      new char[]{ 0x10E9, 0x10EA, 0x10EB, 0x10EC, 0x10ED, 0x10EE, 0x10F4,
                  0x10EF, 0x10F0 } },
    { ""tables"", new String[]{ ""thousands"", ""hundreds"", ""tens"", ""digits"" } }
  };
}
"
org.apache.xalan.templates.ElemAttribute,9,5,0,11,39,36,1,10,6,2.0,195,0.0,0,0.963800905,0.314814815,4,7,20.66666667,16,3.0,2,"
package org.apache.xalan.templates;



import org.apache.xml.dtm.DTM;

import javax.xml.transform.TransformerException;

import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultTreeHandler;
import org.apache.xpath.XPathContext;

import org.xml.sax.SAXException;


public class ElemAttribute extends ElemElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_ATTRIBUTE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_ATTRIBUTE_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    ResultTreeHandler rhandler = transformer.getResultTreeHandler();

    
    
    if (!rhandler.isElementPending())
    {
      
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEvent(this);

      XPathContext xctxt = transformer.getXPathContext();
      int sourceNode = xctxt.getCurrentNode();
      String attrName = m_name_avt.evaluate(xctxt, sourceNode, this);
      transformer.getMsgMgr().warn(this,
                                   XSLTErrorResources.WG_ILLEGAL_ATTRIBUTE,
                                   new Object[]{ attrName });

      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEndEvent(this);
      return;

      
    }
    
    super.execute(transformer);
    
  }
  
  
  protected String resolvePrefix(ResultTreeHandler rhandler,
                                 String prefix, String nodeNamespace)
    throws TransformerException
  {

    if (null != prefix && (prefix.length() == 0 || prefix.equals(""xmlns"")))
    {
      
      
      prefix = rhandler.getPrefix(nodeNamespace);

      
      if (null == prefix || prefix.length() == 0 || prefix.equals(""xmlns""))
      {
        if(nodeNamespace.length() > 0)
        {
          prefix = rhandler.getNewUniqueNSPrefix();
        }
        else
          prefix = """";
      }
    }
    return prefix;
  }
  
  
   protected boolean validateNodeName(String nodeName)
   {
      if(null == nodeName)
        return false;
      if(nodeName.equals(""xmlns""))
        return false;
      return super.validateNodeName(nodeName);
   }
  
  
  void constructNode(
          String nodeName, String prefix, String nodeNamespace, TransformerImpl transformer)
            throws TransformerException
  {

    if(null != nodeName && nodeName.length() > 0)
    {
      ResultTreeHandler rhandler = transformer.getResultTreeHandler();
      if(prefix != null && prefix.length() > 0)
      {
        try
        {
          rhandler.startPrefixMapping(prefix, nodeNamespace, false);
        }
        catch(SAXException se)
        {
          throw new TransformerException(se);
        }
      }
      String val = transformer.transformToString(this);
      String localName = QName.getLocalPart(nodeName);
      rhandler.addAttribute(nodeNamespace, localName, nodeName, ""CDATA"", val);
    }
  }


  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {

    
    case Constants.ELEMNAME_TEXTLITERALRESULT :
    case Constants.ELEMNAME_APPLY_TEMPLATES :
    case Constants.ELEMNAME_APPLY_IMPORTS :
    case Constants.ELEMNAME_CALLTEMPLATE :
    case Constants.ELEMNAME_FOREACH :
    case Constants.ELEMNAME_VALUEOF :
    case Constants.ELEMNAME_COPY_OF :
    case Constants.ELEMNAME_NUMBER :
    case Constants.ELEMNAME_CHOOSE :
    case Constants.ELEMNAME_IF :
    case Constants.ELEMNAME_TEXT :
    case Constants.ELEMNAME_COPY :
    case Constants.ELEMNAME_VARIABLE :
    case Constants.ELEMNAME_MESSAGE :

      
      
      
      
      
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
	
	public void setName(AVT v) {
        if (v.isSimple())
        {
            if (v.getSimpleString().equals(""xmlns""))
            {
                throw new IllegalArgumentException();
            }
        }
		super.setName(v);
	}

}
"
org.apache.xml.utils.StringVector,11,1,0,8,15,0,8,0,11,0.425,234,1.0,0,0.0,0.515151515,0,0,19.90909091,4,1.7273,0,"
package org.apache.xml.utils;


public class StringVector implements java.io.Serializable
{

  
  protected int m_blocksize;

  
  protected String m_map[];

  
  protected int m_firstFree = 0;

  
  protected int m_mapSize;

  
  public StringVector()
  {

    m_blocksize = 8;
    m_mapSize = m_blocksize;
    m_map = new String[m_blocksize];
  }

  
  public StringVector(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new String[blocksize];
  }

  
  public int getLength()
  {
    return m_firstFree;
  }

  
  public final int size()
  {
    return m_firstFree;
  }

  
  public final void addElement(String value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      String newMap[] = new String[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final String elementAt(int i)
  {
    return m_map[i];
  }

  
  public final boolean contains(String s)
  {

    if (null == s)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equals(s))
        return true;
    }

    return false;
  }

  
  public final boolean containsIgnoreCase(String s)
  {

    if (null == s)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equalsIgnoreCase(s))
        return true;
    }

    return false;
  }

  
  public final void push(String s)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      String newMap[] = new String[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = s;

    m_firstFree++;
  }

  
  public final String pop()
  {

    if (m_firstFree <= 0)
      return null;

    m_firstFree--;

    String s = m_map[m_firstFree];

    m_map[m_firstFree] = null;

    return s;
  }

  
  public final String peek()
  {
    return (m_firstFree <= 0) ? null : m_map[m_firstFree - 1];
  }
}
"
org.apache.xalan.xsltc.dom.DupFilterIterator,8,2,0,4,14,0,1,3,8,0.628571429,212,1.0,1,0.588235294,0.416666667,1,5,24.875,12,2.375,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.TransletException;

public final class DupFilterIterator extends NodeIteratorBase {

    private final static int INIT_DATA_SIZE = 16;

    private final NodeIterator _source; 
    private int[] _data = null;         
    private int _last = 0;              
    private int _current = 0;

    
    public DupFilterIterator(NodeIterator source) {
	
	_source = source;

	
	
	
	if (source instanceof KeyIndex) setStartNode(DOM.ROOTNODE);
    }

    
    public int next() {
	return _current < _last ? _data[_current++] : END;
    }

    
    public NodeIterator setStartNode(int node) {

	int i, j; 

	
	
	if ((_source instanceof KeyIndex) && (_data != null)) return this;

	
	
	if ((_data == null) || (node != _startNode)) {

	    _startNode = node;
	    _last = 0;
	    _source.setStartNode(node);
	    _data = new int[INIT_DATA_SIZE];

	    
	    while ((node = _source.next()) != END) {
		if (_last == _data.length) {
		    int[] newArray = new int[_data.length * 2];
		    System.arraycopy(_data, 0, newArray, 0, _last);
		    _data = newArray;
		}

		
		for (i=0; i<_last; i++) {
		    
		    if (_data[i] == node) {
			break;
		    }
		    
		    else if (_data[i] > node) {
			for (j = _last++; j>i; j--)
			    _data[j] = _data[j-1];
			_data[i] = node;
			break;
		    }
		}
		if (i == _last) _data[_last++] = node;
	    }
	}

	_current = 0;  
	return this;
    }

    
    public int getPosition() {
	return (_current);
    }

    
    public int getLast() {
	return _last;
    }

    
    public void setMark() {
	_source.setMark();
	_markedNode = _current;
    }

    
    public void gotoMark() {
	_source.gotoMark();
	_current = _markedNode;
    }

    public NodeIterator reset() {
	_current = 0;
	return(this);
    }

}
"
org.apache.xalan.serialize.EncodingInfo,1,1,0,1,2,0,1,0,1,2.0,16,0.0,0,0.0,1.0,0,0,12.0,0,0.0,0,"
package org.apache.xalan.serialize;


public class EncodingInfo extends Object
{

  
  final String name;

  
  final String javaName;

  
  final int lastPrintable;

  
  public EncodingInfo(String name, String javaName, int lastPrintable)
  {

    this.name = name;
    this.javaName = javaName;
    this.lastPrintable = lastPrintable;
  }
}
"
org.apache.xalan.xsltc.compiler.RelationalExpr,10,3,0,33,54,0,0,33,10,0.185185185,600,1.0,2,0.8875,0.257142857,2,9,58.7,7,2.5,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.runtime.Operators;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class RelationalExpr extends Expression implements Operators {
    private int _op;
    private Expression _left, _right;
		
    public RelationalExpr(int op, Expression left, Expression right) {
	_op = op;
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }

    
    public boolean hasPositionCall() {
	if (_left.hasPositionCall()) return true;
	if (_right.hasPositionCall()) return true;
	return false;
    }

    public boolean hasReferenceArgs() {
	return _left.getType() instanceof ReferenceType ||
	    _right.getType() instanceof ReferenceType;
    }

    public boolean hasNodeArgs() {
	return _left.getType() instanceof NodeType ||
	    _right.getType() instanceof NodeType;
    }

    public boolean hasNodeSetArgs() {
	return _left.getType() instanceof NodeSetType ||
	    _right.getType() instanceof NodeSetType;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	Type tleft = _left.typeCheck(stable); 
	Type tright = _right.typeCheck(stable);

	
	if (tleft instanceof ResultTreeType &&
	    tright instanceof ResultTreeType ) 
  	{
	    _right = new CastExpr(_right, Type.Real);
	    _left = new CastExpr(_left, Type.Real);
	    return _type = Type.Boolean; 
	}

	
	if (hasReferenceArgs()) {
	    Type type = null;
	    Type typeL = null;
	    Type typeR = null;
	    if (tleft instanceof ReferenceType) {
		if (_left instanceof VariableRefBase) {
		    VariableRefBase ref = (VariableRefBase)_left;
		    VariableBase var = ref.getVariable();
		    typeL = var.getType();
		}
	    }
	    if (tright instanceof ReferenceType) {
		if (_right instanceof VariableRefBase) {
		    VariableRefBase ref = (VariableRefBase)_right;
		    VariableBase var = ref.getVariable();
		    typeR = var.getType();
		}
	    }
	    
	    if (typeL == null)
		type = typeR;
	    else if (typeR == null)
		type = typeL;
	    else {
		type = Type.Real;
	    }
	    if (type == null) type = Type.Real;

	    _right = new CastExpr(_right, type);
            _left = new CastExpr(_left, type);
	    return _type = Type.Boolean;
	}

	if (hasNodeSetArgs()) {
	    
	    if (tright instanceof NodeSetType) {
		final Expression temp = _right; _right = _left; _left = temp;
		_op = (_op == Operators.GT) ? Operators.LT :
		    (_op == Operators.LT) ? Operators.GT :
		    (_op == Operators.GE) ? Operators.LE : Operators.GE;
		tright = _right.getType();
	    }

	    
	    if (tright instanceof NodeType) {
		_right = new CastExpr(_right, Type.NodeSet);
	    }
	    
	    if (tright instanceof IntType) {
		_right = new CastExpr(_right, Type.Real);
	    }
	    
	    if (tright instanceof ResultTreeType) {
		_right = new CastExpr(_right, Type.String);
	    }
	    return _type = Type.Boolean;
	}

	
	if (hasNodeArgs()) {
	    if (tleft instanceof BooleanType) {
		_right = new CastExpr(_right, Type.Boolean);
		tright = Type.Boolean;
	    }
	    if (tright instanceof BooleanType) {
		_left = new CastExpr(_left, Type.Boolean);
		tleft = Type.Boolean;
	    }
	}

	
	MethodType ptype = lookupPrimop(stable, Operators.names[_op],
					new MethodType(Type.Void, 
						       tleft, tright)); 

	if (ptype != null) {
	    Type arg1 = (Type) ptype.argsType().elementAt(0);
	    if (!arg1.identicalTo(tleft)) {
		_left = new CastExpr(_left, arg1);
	    }
	    Type arg2 = (Type) ptype.argsType().elementAt(1);
	    if (!arg2.identicalTo(tright)) {
		_right = new CastExpr(_right, arg1);				
	    }
	    return _type = ptype.resultType();
	}
	throw new TypeCheckError(this);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (hasNodeSetArgs() || hasReferenceArgs()) {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();

	    
	    _left.translate(classGen, methodGen);
	    _left.startResetIterator(classGen, methodGen);
	    _right.translate(classGen, methodGen);
	    _right.startResetIterator(classGen, methodGen);

	    il.append(new PUSH(cpg, _op));
	    il.append(methodGen.loadContextNode());
	    il.append(methodGen.loadDOM());

	    int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""compare"",
					 ""(""
					 + _left.getType().toSignature() 
					 + _right.getType().toSignature()
					 + ""I""
					 + NODE_SIG
					 + DOM_INTF_SIG
					 + "")Z"");
	    il.append(new INVOKESTATIC(index));
	}
	else {
	    translateDesynthesized(classGen, methodGen);
	    synthesize(classGen, methodGen);
	}
    }

    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	if (hasNodeSetArgs() || hasReferenceArgs()) {
	    translate(classGen, methodGen);
	    desynthesize(classGen, methodGen);
	}
	else {
	    BranchInstruction bi = null;
	    final InstructionList il = methodGen.getInstructionList();

	    _left.translate(classGen, methodGen);
	    _right.translate(classGen, methodGen);

	    

	    boolean tozero = false;
	    Type tleft = _left.getType(); 

	    if (tleft instanceof RealType) {
		il.append(tleft.CMP(_op == LT || _op == LE));
		tleft = Type.Int;
		tozero = true;
	    }

	    switch (_op) {
	    case LT:
		bi = tleft.GE(tozero);	
		break;
		
	    case GT:
		bi = tleft.LE(tozero);
		break;
		
	    case LE:
		bi = tleft.GT(tozero);
		break;
		
	    case GE:
		bi = tleft.LT(tozero);
		break;
		
	    default:
		ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_RELAT_OP_ERR,this);
		getParser().reportError(Constants.FATAL, msg);
	    }

	    _falseList.add(il.append(bi));		
	}
    }

    public String toString() {
	return Operators.names[_op] + '(' + _left + "", "" + _right + ')';
    }
}
"
org.apache.xalan.xsltc.DOM,37,1,0,27,37,666,24,4,37,1.027777778,51,0.0,0,0.0,0.27027027,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

public interface DOM {
    public final static int  FIRST_TYPE             = 0;

    public final static int  NO_TYPE                = -1;
    public final static int  ROOT                   = 0;
    public final static int  TEXT                   = 1;
    public final static int  NAMESPACE              = 2;
    public final static int  ELEMENT                = 3;
    public final static int  ATTRIBUTE              = 4;
    public final static int  PROCESSING_INSTRUCTION = 5;
    public final static int  COMMENT                = 6;
	
    public final static int  NTYPES                 = 7;
    
    
    public final static int NULL     = 0;
    
    public final static int ROOTNODE = 1;

    
    public final static int RETURN_CURRENT = 0;
    public final static int RETURN_PARENT  = 1;
    
    
    public NodeIterator getIterator();
    public String getStringValue();
    public String getTreeString(); 
	
    public NodeIterator getChildren(final int node);
    public NodeIterator getTypedChildren(final int type);
    public NodeIterator getAxisIterator(final int axis);
    public NodeIterator getTypedAxisIterator(final int axis, final int type);
    public NodeIterator getNthDescendant(int node, int n, boolean includeself);
    public NodeIterator getNamespaceAxisIterator(final int axis, final int ns);
    public NodeIterator getNodeValueIterator(NodeIterator iter, int returnType,
					     String value, boolean op);
    public NodeIterator orderNodes(NodeIterator source, int node);
    public String getNodeName(final int node);
    public String getNamespaceName(final int node);
    public int getType(final int node);
    public int getNamespaceType(final int node);
    public int getParent(final int node);
    public int getAttributeNode(final int gType, final int element);
    public String getNodeValue(final int node);
    public void copy(final int node, TransletOutputHandler handler)
	throws TransletException;
    public void copy(NodeIterator nodes, TransletOutputHandler handler)
	throws TransletException;
    public String shallowCopy(final int node, TransletOutputHandler handler)
	throws TransletException;
    public boolean lessThan(final int node1, final int node2);
    public void characters(final int textNode, TransletOutputHandler handler)
	throws TransletException;
    public Node makeNode(int index);
    public Node makeNode(NodeIterator iter);
    public NodeList makeNodeList(int index);
    public NodeList makeNodeList(NodeIterator iter);
    public String getLanguage(int node);
    public int getSize();
    public String getDocumentURI(int node);
    public int getTypedPosition(int type, int node);
    public int getTypedLast(int type, int node);
    public void setFilter(StripFilter filter);
    public void setupMapping(String[] names, String[] namespaces);
    public boolean isElement(final int node);
    public boolean isAttribute(final int node);
    public String lookupNamespace(int node, String prefix)
	throws TransletException;
}
"
org.apache.xalan.xsltc.DOMCache,1,1,0,6,1,0,4,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.dom.DOMImpl;

public interface DOMCache {

    
    public DOMImpl retrieveDocument(String uri, int mask, Translet translet);

}
"
org.apache.xpath.axes.NodeSequence,37,3,1,18,68,218,10,8,34,0.625,693,1.0,2,0.682692308,0.171171171,2,9,17.62162162,12,2.2432,4,"
package org.apache.xpath.axes;

import java.io.Serializable;

import java.util.Vector;
import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.utils.NodeVector;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;


public class NodeSequence extends XObject
  implements DTMIterator, Cloneable, PathComponent
{
  
  protected int m_last = -1;
  
  
  protected int m_next = 0;
    
  
  protected NodeVector getVector()
  {
  	return (NodeVector)m_obj;
  }
  
  
  protected void SetVector(NodeVector v)
  {
  	m_obj = v;
  }

  
  
  public boolean hasCache()
  {
  	return (m_obj != null);
  }


  
  protected DTMIterator m_iter;
  
  
  public final void setIter(DTMIterator iter)
  {
  	m_iter = iter;
  }
  
  
  public final DTMIterator getContainedIter()
  {
  	return m_iter;
  }
  
  
  protected DTMManager m_dtmMgr;
  
  
  
  
  public NodeSequence(DTMIterator iter, int context, XPathContext xctxt, boolean shouldCacheNodes)
  {
  	setIter(iter);
  	setRoot(context, xctxt);
  	setShouldCacheNodes(shouldCacheNodes);
  }
  
  
  public NodeSequence(Object nodeVector)
  {
  	super(nodeVector);
  	if(null != nodeVector)
  	{
  		assertion(nodeVector instanceof NodeVector, 
  			""Must have a NodeVector as the object for NodeSequence!"");
  		if(nodeVector instanceof DTMIterator)
  		{
  			setIter((DTMIterator)nodeVector);
  			m_last = ((DTMIterator)nodeVector).getLength();
  		}
  		
  	}
  }
  
  
  public NodeSequence(DTMManager dtmMgr)
  {
    super(new NodeVector());
    m_last = 0;
    m_dtmMgr = dtmMgr;
  }

  
  
  public NodeSequence()
  {
  }


  
  public DTM getDTM(int nodeHandle)
  {
  	DTMManager mgr = getDTMManager();
  	if(null != mgr)
    	return getDTMManager().getDTM(nodeHandle);
    else
    {
    	assertion(false, ""Can not get a DTM Unless a DTMManager has been set!"");
    	return null;
    }
  }

  
  public DTMManager getDTMManager()
  {
    return m_dtmMgr;
  }

  
  public int getRoot()
  {
  	if(null != m_iter)
    	return m_iter.getRoot();
  	else
  	{
  		
  		
  		
  		return DTM.NULL;
  	}
  }

  
  public void setRoot(int nodeHandle, Object environment)
  {
  	if(null != m_iter)
  	{
  		XPathContext xctxt = (XPathContext)environment;
  		m_dtmMgr = xctxt.getDTMManager();
  		m_iter.setRoot(nodeHandle, environment);
  		if(!m_iter.isDocOrdered())
  		{
  			if(!hasCache())
  				setShouldCacheNodes(true);
  			runTo(-1);
  			m_next=0;
  		}
  	}
  	else
  		assertion(false, ""Can not setRoot on a non-iterated NodeSequence!"");
  }

  
  public void reset()
  {
  	m_next = 0;
  	
  }

  
  public int getWhatToShow()
  {
    return hasCache() ? (DTMFilter.SHOW_ALL & ~DTMFilter.SHOW_ENTITY_REFERENCE) 
    	: m_iter.getWhatToShow();
  }

  
  public boolean getExpandEntityReferences()
  {
  	if(null != m_iter)
  		return m_iter.getExpandEntityReferences();
  	else
    	return true;
  }

  
  public int nextNode()
  {
    
    
    NodeVector vec = getVector();
    if (null != vec)
    {	
    	if(m_next < vec.size())
    	{
			int next = vec.elementAt(m_next);
	    	m_next++;
	    	return next;
    	}
    	else if((-1 != m_last) || (null == m_iter))
    	{
    		m_next++;
    		return DTM.NULL;
    	}
    }
    
  if (null == m_iter)
    return DTM.NULL;
  
 	int next = m_iter.nextNode();
    if(DTM.NULL != next)
    {
    	if(hasCache())
    	{
    		if(m_iter.isDocOrdered())
    	    {
    			getVector().addElement(next);
    			m_next++;
    		}
    		else
    		{
    			int insertIndex = addNodeInDocOrder(next);
    			if(insertIndex >= 0)
    				m_next++;
    		}
    	}
    	else
    		m_next++;
    }
    else
    {
    	m_last = m_next;
    	m_next++;
    }
    	
    return next;
  }

  
  public int previousNode()
  {
  	if(hasCache())
  	{
  		if(m_next <= 0)
  			return DTM.NULL;
  		else
  		{
  			m_next--;
  			return item(m_next);
  		}
  	}
  	else
  	{
	    int n = m_iter.previousNode();
	    m_next = m_iter.getCurrentPos();
	    return m_next;
  	}
  }

  
  public void detach()
  {
  	if(null != m_iter)
  		m_iter.detach();
  	super.detach();
  }

  
  public void allowDetachToRelease(boolean allowRelease)
  {
  	if((false == allowRelease) && !hasCache())
  	{
  		setShouldCacheNodes(true);
  	}
  	
  	if(null != m_iter)
  		m_iter.allowDetachToRelease(allowRelease);
  	super.allowDetachToRelease(allowRelease);
  }

  
  public int getCurrentNode()
  {
  	if(hasCache())
  	{
  		int currentIndex = m_next-1;
  		NodeVector vec = getVector();
  		if((currentIndex >= 0) && (currentIndex < vec.size()))
  			return vec.elementAt(currentIndex);
  		else
  			return DTM.NULL;
  	}
  	
  	if(null != m_iter)
  	{
    	return m_iter.getCurrentNode();
  	}
  	else
  		return DTM.NULL;
  }

  
  public boolean isFresh()
  {
    return (0 == m_next);
  }

  
  public void setShouldCacheNodes(boolean b)
  {
    if (b)
    {
      if(!hasCache())
      {
        SetVector(new NodeVector());
      }


    }
    else
      SetVector(null);
  }

  
  public boolean isMutable()
  {
    return hasCache(); 
  }

  
  public int getCurrentPos()
  {
    return m_next;
  }

  
  public void runTo(int index)
  {
    int n;
    
    if (-1 == index)
    {
      int pos = m_next;
      while (DTM.NULL != (n = nextNode()));
      m_next = pos;
    }
    else if(m_next == index)
    {
      return;
    }
    else if(hasCache() && m_next < getVector().size())
    {
      m_next = index;
    }
    else if((null == getVector()) && (index < m_next))
    {
      while ((m_next >= index) && DTM.NULL != (n = previousNode()));
    }
    else
    {   
      while ((m_next < index) && DTM.NULL != (n = nextNode()));
    }
    
  }

  
  public void setCurrentPos(int i)
  {
  	runTo(i);
  }

  
  public int item(int index)
  {
  	setCurrentPos(index);
  	int n = nextNode();
  	m_next = index;
  	return n;
  }

  
  public void setItem(int node, int index)
  {
  	NodeVector vec = getVector();
  	if(null != vec)
  	{
  		vec.setElementAt(node, index);
  		m_last = vec.size();
  	}
  	else
  		m_iter.setItem(node, index);
  }

  
  public int getLength()
  {
  	if(hasCache())
  	{
	  	if(-1 == m_last)
	  	{
	  		int pos = m_next;
	  		runTo(-1);
	  		m_next = pos;
	  	}
	    return m_last;
  	}
  	else
  	{
  		return m_iter.getLength();
  	}
  }

  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {
  	NodeSequence seq = (NodeSequence)super.clone();
    seq.m_next = 0;
    return seq;
  }
  
  
  public Object clone() throws CloneNotSupportedException
  {
  	return super.clone();
  }


  
  public boolean isDocOrdered()
  {
  	if(null != m_iter)
  		return m_iter.isDocOrdered();
  	else
    	return true; 
  }

  
  public int getAxis()
  {
  	if(null != m_iter)
    	return m_iter.getAxis();
    else
    {
    	assertion(false, ""Can not getAxis from a non-iterated node sequence!"");
    	return 0;
    }
  }

  
  public int getAnalysisBits()
  {
  	if((null != m_iter) && (m_iter instanceof PathComponent))
    	return ((PathComponent)m_iter).getAnalysisBits();
    else
    	return 0;
  }

  
  public void fixupVariables(Vector vars, int globalsSize)
  {
  	super.fixupVariables(vars, globalsSize);
  }  
  
  
   protected int addNodeInDocOrder(int node)
   {
      assertion(hasCache(), ""addNodeInDocOrder must be done on a mutable sequence!"");

      int insertIndex = -1;
      
      NodeVector vec = getVector();

      
      
      
      int size = vec.size(), i;

      for (i = size - 1; i >= 0; i--)
      {
        int child = vec.elementAt(i);

        if (child == node)
        {
          i = -2; 

          break;
        }

        DTM dtm = m_dtmMgr.getDTM(node);
        if (!dtm.isNodeAfter(node, child))
        {
          break;
        }
      }

      if (i != -2)
      {
        insertIndex = i + 1;

        vec.insertElementAt(node, insertIndex);
      }

      
      return insertIndex;
    } 
}

"
org.apache.xalan.xsltc.runtime.DefaultSAXOutputHandler,36,1,0,3,69,428,2,1,28,0.834920635,967,1.0,3,0.0,0.215873016,0,0,25.11111111,2,0.8889,0,"

package org.apache.xalan.xsltc.runtime;

import java.util.Vector;

import java.io.IOException;
import java.io.Writer;
import java.io.FileOutputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.BufferedWriter;

import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;

public class DefaultSAXOutputHandler implements ContentHandler, LexicalHandler {

    
    private Writer _writer;

    
    private Hashtable _endTags = new Hashtable();
    
    private Hashtable _attributeTemplates = new Hashtable();
    
    private Hashtable _emptyElements = new Hashtable();
    
    private String _element = null;

    
    private int	    _outputType = TextOutput.UNKNOWN;
    private String  _encoding   = ""UTF-8"";
    private String  _version    = ""1.0"";
    private String  _standalone = null;
    private boolean _indent = false;
    private boolean _omitHeader = false;

    
    private boolean _startTagOpen = false;

    
    private static final char[] BEGPI    = ""<?"".toCharArray();
    private static final char[] ENDPI    = ""?>"".toCharArray();
    private static final char[] GT_CR    = "">"".toCharArray();
    private static final char[] GT_LT_SL = ""></"".toCharArray();
    private static final char[] SL_GT    = ""/>"".toCharArray();
    private static final char[] XMLNS    = "" xmlns"".toCharArray();

    
    private static final char[] INDENT = ""                    "".toCharArray();
    private static final int MAX_INDENT_LEVEL = (INDENT.length >> 1);
    private static final int MAX_INDENT       = INDENT.length;

    private static final String EMPTYSTRING = """";

    private boolean _lineFeedNextStartTag = false;
    private boolean _linefeedNextEndTag = false;
    private boolean _indentNextEndTag = false;
    private int     _indentLevel = 0;

    
    private Vector _namespaceDecls = null;

    
    public DefaultSAXOutputHandler(Writer writer, String encoding)
	throws IOException {
	_writer = writer;
	_encoding = encoding;
	init();
    }

    
    public DefaultSAXOutputHandler(Writer writer) throws IOException {
	this(writer, ""UTF-8"");
    }

    
    public DefaultSAXOutputHandler(OutputStream out, String encoding)
	throws IOException {

        OutputStreamWriter writer;
        try {
            writer = new OutputStreamWriter(out, _encoding = encoding);
        }
        catch (java.io.UnsupportedEncodingException e) {
            writer = new OutputStreamWriter(out, _encoding = ""UTF-8"" );
        }
        _writer = new BufferedWriter(writer);
	init();
    }

    
    public DefaultSAXOutputHandler(String filename, String encoding)
	throws IOException {
	this(new FileOutputStream(filename), encoding);
    }

    
    private void init() throws IOException {

	
	
        final String[] tags = { ""area"", ""base"", ""basefont"", ""br"",
				""col"", ""frame"", ""hr"", ""img"", ""input"",
				""isindex"", ""link"", ""meta"", ""param"" };
        for (int i = 0; i < tags.length; i++)
            _emptyElements.put(tags[i],tags[i]);

	_endTags.clear();
	_outputType = TextOutput.UNKNOWN;
	_indent = false;
	_indentNextEndTag = false;
	_indentLevel = 0;
	_startTagOpen = false;
    }

    
    public void close() {
	try {
	    if (_writer != null) _writer.close();
	}
	catch (IOException e) {
	    
	}
    }

    
    private void emitHeader() throws SAXException {
	
	
	if (_omitHeader) return;

	
	StringBuffer buffer = new StringBuffer();
	buffer.append(""<?xml version="""");
	buffer.append(_version);
	buffer.append("""" encoding="""");
	buffer.append(_encoding);
	if ( _standalone != null ) {
	    buffer.append("""" standalone="""");
	    buffer.append(_standalone);
	}
	buffer.append(""""?>
"");
	characters(buffer.toString());
    }

    
    private void determineOutputType(String element) throws SAXException {
	
	if ((element != null) && (element.toLowerCase().equals(""html""))) {
	    _outputType = TextOutput.HTML;
	}
	
	else {
	    _outputType = TextOutput.XML;
	    emitHeader();
	}
    }

    
    public void startDocument() throws SAXException { 
    }

    
    public void endDocument() throws SAXException  { 
        try {
	    _writer.flush();
        } catch (IOException e) {
            throw new SAXException(e);
        }
    }

    
    public void startElement(String uri, String localname,
			     String elementName, Attributes attrs)
	throws SAXException {
	try {
	    
	    if (_outputType == TextOutput.UNKNOWN)
		determineOutputType(elementName);

            if (_startTagOpen) closeStartTag(true); 
            _element = elementName; 

	    
            if (_indent) {
		if (!_emptyElements.containsKey(elementName.toLowerCase())) {
		    indent(_lineFeedNextStartTag);
		    _lineFeedNextStartTag = true;
		    _indentNextEndTag = false;
		}
		_indentLevel++;
            }

	    
	    _writer.write('<');
	    _writer.write(elementName);
	    _startTagOpen = true;
	    _indentNextEndTag = false;

	    
	    if (_namespaceDecls != null) {
		int nDecls = _namespaceDecls.size();
		for (int i = 0; i < nDecls; i++) {
		    final String prefix = (String) _namespaceDecls.elementAt(i++);
		    _writer.write(XMLNS);
		    if ((prefix != null) && (prefix != EMPTYSTRING)) {
			_writer.write(':');
			_writer.write(prefix);
		    }
		    _writer.write('=');
		    _writer.write('""');
		    _writer.write((String) _namespaceDecls.elementAt(i));
		    _writer.write('""');
		}
		_namespaceDecls.clear();
	    }

	    
	    int attrCount = attrs.getLength();
	    for (int i = 0; i < attrCount; i++) {
		_writer.write(' ');
		_writer.write(attrs.getQName(i));
		_writer.write('=');
		_writer.write('""');
		_writer.write(attrs.getValue(i));
		_writer.write('""');
            }
	} catch (IOException e) {
            throw new SAXException(e);
        }
    }

    
    public void endElement(String uri, String localname,
			   String elementName)  throws SAXException {
	try {

            if (_indent) _indentLevel--;

            if (_startTagOpen) {
                closeStartTag(false);
            }
            else {
                if ((_indent) && (_indentNextEndTag)) {
		    indent(_indentNextEndTag);
		    _indentNextEndTag = true;
		}
                char[] endTag = (char[])_endTags.get(elementName);
                if (endTag == null) {
		    
		    
		    final int len = elementName.length();
		    final char[] src = elementName.toCharArray();
		    endTag = new char[len+3];
		    System.arraycopy(src, 0, endTag, 2, len);
		    endTag[0] = '<';
		    endTag[1] = '/';
		    endTag[len+2] = '>';
                    _endTags.put(elementName,endTag);
                }
                _writer.write(endTag);
            }
	    
	    _indentNextEndTag = true;
        } catch (IOException e) {
            throw new SAXException(e);
        }
    }

    
    private void characters(String str) throws SAXException{
	final char[] ch = str.toCharArray();
	characters(ch, 0, ch.length);
    }

    
    private void characters(char[] ch) throws SAXException{
	characters(ch, 0, ch.length);
    }

    
    public void characters(char[] ch, int off, int len) throws SAXException {
        try {
	    
	    if (_outputType == TextOutput.UNKNOWN)
		determineOutputType(null);
	    
            if (len == 0) return;

            
            if (_startTagOpen) closeStartTag(true);

            
	    _writer.write(ch, off, len);
        }
        catch (IOException e) {
            throw new SAXException(e);
        }
    }

    
    public void processingInstruction(String target, String data)
	throws SAXException {
	try {
            if (_startTagOpen) closeStartTag(true);
            _writer.write(BEGPI);
            _writer.write(target);
            _writer.write(' ');
            _writer.write(data);
            if (_outputType == TextOutput.HTML)
                _writer.write('>');
            else
                _writer.write(ENDPI);

        } catch (IOException e) {
            throw new SAXException(e);
        }
    }

    
    public void ignorableWhitespace(char[] ch, int start, int len) { }

    
    public void setDocumentLocator(Locator locator) { } 

    
    public void skippedEntity(String name) { }

    
    public void startPrefixMapping(String prefix, String uri) {
	if (_namespaceDecls == null) {
	    _namespaceDecls = new Vector(2);
	}
	_namespaceDecls.addElement(prefix);
	_namespaceDecls.addElement(uri);
    }

    
    public void endPrefixMapping(String prefix) {
	
    }

    
    public void startCDATA() { }
    public void endCDATA() { }
    public void comment(char[] ch, int start, int length) { }
    public void startEntity(java.lang.String name) { }
    public void endDTD() { }
    public void endEntity(String name) { }

    
    public void startDTD(String name, String publicId, String systemId)
	throws SAXException {
	try {
	    StringBuffer buf = new StringBuffer(""<!DOCTYPE "");
	    buf.append(name);
	    if (publicId == null) {
		buf.append("" SYSTEM"");
	    }
	    else {
		buf.append("" PUBLIC """");
		buf.append(publicId);
		buf.append("""""");
	    }
	    if (systemId != null) {
		buf.append("" """");
		buf.append(systemId);
		buf.append("""">
"");
	    }
	    else {
		buf.append("">
"");
	    }
	    _writer.write(buf.toString());
	}
        catch (IOException e) {
            throw new SAXException(e);
        }
    }

    
    private void indent(boolean linefeed) throws IOException {
        if (linefeed)
            _writer.write('
');
        if (_indentLevel < MAX_INDENT_LEVEL)
            _writer.write(INDENT, 0, (_indentLevel+_indentLevel));
        else
            _writer.write(INDENT, 0, MAX_INDENT);
    }

    
    private void closeStartTag(boolean content) throws SAXException {
        try {
            
            if (!content) {
                if (_outputType == TextOutput.HTML) {
                    
                    if (!_emptyElements.containsKey(_element.toLowerCase())){
                        _writer.write(GT_LT_SL);
                        _writer.write(_element);
			_writer.write('>');
                    }
		    else {
			_writer.write(GT_CR);
		    }
                }
                else {
                    
                    _writer.write(SL_GT);
                }
            }
            else {
		_writer.write('>');
            }
            _startTagOpen = false;
        }
        catch (IOException e) {
            throw new SAXException(e);
        }
    }

    
    public void setIndent(boolean indent) {
        _indent = indent;
    }

    
    public void setVersion(String version) {
	_version = version;
    }

    
    public void setStandalone(String standalone) {
	_standalone = standalone;
    }

    
    public void omitHeader(boolean value) {
        _omitHeader = value;
    }

    
    public void setOutputType(int type) throws SAXException {
	_outputType = type;
	if (_outputType == TextOutput.XML ) {
	    emitHeader();
	}
    }

}
"
org.apache.xalan.templates.ElemLiteralResult,32,4,2,17,84,354,6,12,28,0.88172043,657,1.0,2,0.86695279,0.180555556,3,19,19.25,10,1.8438,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;
import org.xml.sax.helpers.*;

import java.util.StringTokenizer;

import org.apache.xml.utils.QName;
import org.apache.xml.utils.NameSpace;
import org.apache.xpath.XPathContext;
import org.apache.xml.utils.StringToStringTable;
import org.apache.xml.utils.NameSpace;
import org.apache.xml.utils.StringVector;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultTreeHandler;

import javax.xml.transform.TransformerException;

import java.io.*;

import java.util.*;


public class ElemLiteralResult extends ElemUse
{

  
  private boolean isLiteralResultAsStylesheet = false;

  
  public void setIsLiteralResultAsStylesheet(boolean b)
  {
    isLiteralResultAsStylesheet = b;
  }

  
  public boolean getIsLiteralResultAsStylesheet()
  {
    return isLiteralResultAsStylesheet;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if (null != m_avts)
    {
      int nAttrs = m_avts.size();

      for (int i = (nAttrs - 1); i >= 0; i--)
      {
        AVT avt = (AVT) m_avts.elementAt(i);
        avt.fixupVariables(vnames, cstate.getGlobalsSize());
      } 
    }   
  }
  
  
  private Vector m_avts = null;

  
  private Vector m_xslAttr = null;

  
  public void addLiteralResultAttribute(AVT avt)
  {

    if (null == m_avts)
      m_avts = new Vector();

    m_avts.addElement(avt);
  }

  
  public void addLiteralResultAttribute(String att)
  {

    if (null == m_xslAttr)
      m_xslAttr = new Vector();

    m_xslAttr.addElement(att);
  }
  
  
  public void setXmlSpace(AVT avt)
  {
    
    addLiteralResultAttribute(avt);
    String val = avt.getSimpleString();
    if(val.equals(""default""))
    {
      super.setXmlSpace(Constants.ATTRVAL_STRIP);
    }
    else if(val.equals(""preserve""))
    {
      super.setXmlSpace(Constants.ATTRVAL_PRESERVE);
    }
    
  }


  
  public AVT getLiteralResultAttribute(String name)
  {

    if (null != m_avts)
    {
      int nAttrs = m_avts.size();

      for (int i = (nAttrs - 1); i >= 0; i--)
      {
        AVT avt = (AVT) m_avts.elementAt(i);

        if (avt.getRawName().equals(name))
        {
          return avt;
        }
      }  
    }

    return null;
  }

  
  public boolean containsExcludeResultPrefix(String prefix, String uri)
  {
    if (uri == null ||
				(null == m_excludeResultPrefixes &&
				 null == m_ExtensionElementURIs)
				)
      return super.containsExcludeResultPrefix(prefix, uri);

    if (prefix.length() == 0)
      prefix = Constants.ATTRVAL_DEFAULT_PREFIX;

    
    
		if(m_excludeResultPrefixes!=null)
			for (int i =0; i< m_excludeResultPrefixes.size(); i++)
			{
				if (uri.equals(getNamespaceForPrefix(m_excludeResultPrefixes.elementAt(i))))
					return true;
			}    
		
		
    if(m_ExtensionElementURIs!=null && m_ExtensionElementURIs.contains(uri))
       return true;

		return super.containsExcludeResultPrefix(prefix, uri);
  }

  
  public void resolvePrefixTables() throws TransformerException
  {

    super.resolvePrefixTables();

    StylesheetRoot stylesheet = getStylesheetRoot();

    if ((null != m_namespace) && (m_namespace.length() > 0))
    {
      NamespaceAlias nsa = stylesheet.getNamespaceAliasComposed(m_namespace);

      if (null != nsa)
      {
        m_namespace = nsa.getResultNamespace();

        
        String resultPrefix = nsa.getStylesheetPrefix();  

        if ((null != resultPrefix) && (resultPrefix.length() > 0))
          m_rawName = resultPrefix + "":"" + m_localName;
        else
          m_rawName = m_localName;
      }
    }

    if (null != m_avts)
    {
      int n = m_avts.size();

      for (int i = 0; i < n; i++)
      {
        AVT avt = (AVT) m_avts.elementAt(i);

        
        String ns = avt.getURI();

        if ((null != ns) && (ns.length() > 0))
        {
          NamespaceAlias nsa =
            stylesheet.getNamespaceAliasComposed(m_namespace); 

          if (null != nsa)
          {
            String namespace = nsa.getResultNamespace();

            
            String resultPrefix = nsa.getStylesheetPrefix();  
            String rawName = avt.getName();

            if ((null != resultPrefix) && (resultPrefix.length() > 0))
              rawName = resultPrefix + "":"" + rawName;

            avt.setURI(namespace);
            avt.setRawName(rawName);
          }
        }
      }
    }
  }

  
  boolean needToCheckExclude()
  {
    if (null == m_excludeResultPrefixes && null == m_prefixTable
				&& m_ExtensionElementURIs==null   	
				)
      return false;
    else
    {

      
      if (null == m_prefixTable)
        m_prefixTable = new Vector();

      return true;
    }
  }

  
  private String m_namespace;

  
  public void setNamespace(String ns)
  {
    if(null == ns) 
      ns = """";
    m_namespace = ns;
  }

  
  public String getNamespace()
  {
    return m_namespace;
  }

  
  private String m_localName;

  
  public void setLocalName(String localName)
  {
    m_localName = localName;
  }

  
  public String getLocalName()
  {
    return m_localName;
  }

  
  private String m_rawName;

  
  public void setRawName(String rawName)
  {
    m_rawName = rawName;
  }

  
  public String getRawName()
  {
    return m_rawName;
  }
	
 
  public String getPrefix()
  {
		int len=m_rawName.length()-m_localName.length()-1;
    return (len>0)
			? m_rawName.substring(0,len)
			: """";
  }


  
  private StringVector m_ExtensionElementURIs;

  
  public void setExtensionElementPrefixes(StringVector v)
  {
    m_ExtensionElementURIs = v;
  }

  
  public String getExtensionElementPrefix(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_ExtensionElementURIs)
      throw new ArrayIndexOutOfBoundsException();

    return m_ExtensionElementURIs.elementAt(i);
  }

  
  public int getExtensionElementPrefixCount()
  {
    return (null != m_ExtensionElementURIs)
           ? m_ExtensionElementURIs.size() : 0;
  }

  
  public boolean containsExtensionElementURI(String uri)
  {

    if (null == m_ExtensionElementURIs)
      return false;

    return m_ExtensionElementURIs.contains(uri);
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_LITERALRESULT;
  }

  
  public String getNodeName()
  {

    
    return m_rawName;
  }

  
  private String m_version;

  
  public void setVersion(String v)
  {
    m_version = v;
  }
  
  
  public String getVersion()
  {
    return m_version;
  }

  
  private StringVector m_excludeResultPrefixes;

  
  public void setExcludeResultPrefixes(StringVector v)
  {
    m_excludeResultPrefixes = v;
  }

  
  private boolean excludeResultNSDecl(String prefix, String uri)
          throws TransformerException
  {

    if (null != m_excludeResultPrefixes)
    {
      return containsExcludeResultPrefix(prefix, uri);
    }

    return false;
  }
  
  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    try
    {
      ResultTreeHandler rhandler = transformer.getResultTreeHandler();
			
			
			
			
			rhandler.startPrefixMapping(getPrefix(),getNamespace());

      
      executeNSDecls(transformer);
      rhandler.startElement(getNamespace(), getLocalName(), getRawName(), null);

      try
      {

        
        super.execute(transformer);

        
        
        if (null != m_avts)
        {
          int nAttrs = m_avts.size();

          for (int i = (nAttrs - 1); i >= 0; i--)
          {
            AVT avt = (AVT) m_avts.elementAt(i);
            XPathContext xctxt = transformer.getXPathContext();
            int sourceNode = xctxt.getCurrentNode();
            String stringedValue = avt.evaluate(xctxt, sourceNode, this);

            if (null != stringedValue)
            {

              
              
              
              
							
              rhandler.addAttribute(avt.getURI(), avt.getName(),
                                    avt.getRawName(), ""CDATA"", stringedValue);
            }
          }  
        }

        
        
        transformer.executeChildTemplates(this, true);
      }
      finally
      {
        
        
        rhandler.endElement(getNamespace(), getLocalName(), getRawName());
        unexecuteNSDecls(transformer);
				
				
				rhandler.endPrefixMapping(getPrefix());
      }
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }

  
  public Enumeration enumerateLiteralResultAttributes()
  {
    return (null == m_avts) ? null : m_avts.elements();
  }
  
    
    protected boolean accept(XSLTVisitor visitor)
    {
      return visitor.visitLiteralResultElement(this);
    }

    
    protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
    {
      if (callAttrs && null != m_avts)
      {
        int nAttrs = m_avts.size();

        for (int i = (nAttrs - 1); i >= 0; i--)
        {
          AVT avt = (AVT) m_avts.elementAt(i);
          avt.callVisitors(visitor);
        }
      }
      super.callChildVisitors(visitor, callAttrs);
    }

}
"
org.apache.xml.utils.SAXSourceLocator,8,2,0,17,29,0,17,0,8,0.285714286,119,0.0,0,0.666666667,0.34375,0,0,13.75,2,1.0,0,"
package org.apache.xml.utils;

import javax.xml.transform.SourceLocator;

import org.xml.sax.helpers.LocatorImpl;
import org.xml.sax.Locator;
import org.xml.sax.SAXParseException;

import java.io.Serializable;


public class SAXSourceLocator extends LocatorImpl
        implements SourceLocator, Serializable
{
  
  Locator m_locator;

  
  public SAXSourceLocator(){}

  
  public SAXSourceLocator(Locator locator)
  {
    m_locator = locator;
    this.setColumnNumber(locator.getColumnNumber());
    this.setLineNumber(locator.getLineNumber());
    this.setPublicId(locator.getPublicId());
    this.setSystemId(locator.getSystemId());
  }
  
  
  public SAXSourceLocator(javax.xml.transform.SourceLocator locator)
  {
    m_locator = null;
    this.setColumnNumber(locator.getColumnNumber());
    this.setLineNumber(locator.getLineNumber());
    this.setPublicId(locator.getPublicId());
    this.setSystemId(locator.getSystemId());
  }

  
  
  public SAXSourceLocator(SAXParseException spe)
  {
    this.setLineNumber( spe.getLineNumber() );
    this.setColumnNumber( spe.getColumnNumber() );
    this.setPublicId( spe.getPublicId() );
    this.setSystemId( spe.getSystemId() );
  }
  
  
  public String getPublicId()
  {
    return (null == m_locator) ? super.getPublicId() : m_locator.getPublicId();
  }

  
  public String getSystemId()
  {
    return (null == m_locator) ? super.getSystemId() : m_locator.getSystemId();
  }
  
  
  public int getLineNumber()
  {
    return (null == m_locator) ? super.getLineNumber() : m_locator.getLineNumber();
  }

  
  public int getColumnNumber()
  {
    return (null == m_locator) ? super.getColumnNumber() : m_locator.getColumnNumber();
  }
}
"
org.apache.xalan.xsltc.compiler.FunctionAvailableCall,9,4,0,21,41,24,0,21,5,0.53125,311,1.0,1,0.923076923,0.253968254,3,13,33.11111111,6,2.4444,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.lang.reflect.Modifier;
import java.lang.reflect.Method;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.runtime.TransletLoader;

final class FunctionAvailableCall extends FunctionCall {

    private Expression _arg; 
    private String     _nameOfFunct = null; 
    private String     _namespaceOfFunct = null; 	
    private boolean    _isFunctionAvailable = false; 

    
    public FunctionAvailableCall(QName fname, Vector arguments) {
	super(fname, arguments);
	_arg = (Expression)arguments.elementAt(0);
	_type = null; 

        if (_arg instanceof LiteralExpr) {
	    LiteralExpr arg = (LiteralExpr) _arg;
            _namespaceOfFunct = arg.getNamespace();
            _nameOfFunct = arg.getValue();

            if (_namespaceOfFunct != null &&
	        (_namespaceOfFunct.startsWith(JAVA_EXT_XSLTC) ||
		 _namespaceOfFunct.startsWith(JAVA_EXT_XALAN))) 
	    {
                _isFunctionAvailable = hasMethods();
            }
        }
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_type != null) {
	   return _type;
	}
	if (_arg instanceof LiteralExpr) {
	    return _type = Type.Boolean;
	}
	ErrorMsg err = new ErrorMsg(ErrorMsg.NEED_LITERAL_ERR,
			""function-available"", this);
	throw new TypeCheckError(err);
    }

    
    public Object evaluateAtCompileTime() {
	return getResult() ? Boolean.TRUE : Boolean.FALSE;
    }

    
    private String getClassName(String argValue){
	int colonSep = argValue.indexOf("":"");
	if (colonSep != -1) {
	    argValue = argValue.substring(colonSep+1);  
	}		
	int lastDot  = argValue.lastIndexOf(""."");
	if (lastDot != -1) {
	    argValue = argValue.substring(0, lastDot);
	}
	return argValue;
    }

    
    private String getMethodName(String argValue){
	int lastDot  = argValue.lastIndexOf(""."");
	if (lastDot != -1) {
	    argValue = argValue.substring(lastDot+1);
	}
	return argValue;
    }

    
    private String getExternalFunctionName() {
	int colonIndex = _nameOfFunct.indexOf("":"");
	String uri = _namespaceOfFunct + 
                    ""."" + _nameOfFunct.substring(colonIndex+1);
	try{
	    return getClassNameFromUri(uri); 
        } catch (TypeCheckError e) {
	    return null; 
        }
    }

    
    private boolean hasMethods() {
	LiteralExpr arg = (LiteralExpr)_arg;
	final String externalFunctName = getExternalFunctionName();

	if (externalFunctName == null) {
	    return false;
	}

	final String className = getClassName(externalFunctName);

	try {
	    TransletLoader loader = new TransletLoader();
	    final Class clazz = loader.loadClass(className);

	    if (clazz == null) {
		final ErrorMsg msg =
		    new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, className);
		getParser().reportError(Constants.ERROR, msg);
	    }
	    else {
		final String methodName = getMethodName(externalFunctName);
		final Method[] methods = clazz.getDeclaredMethods();

		for (int i = 0; i < methods.length; i++) {
		    final int mods = methods[i].getModifiers();

		    if (Modifier.isPublic(mods)
			&& Modifier.isStatic(mods)
			&& methods[i].getName().equals(methodName))
		    {
			return true;
		    }
		}
	    }
	}
	catch (ClassNotFoundException e) {
	    final ErrorMsg msg =
		new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, className);
		    getParser().reportError(Constants.ERROR, msg);
	}
        return false;   
    }

    
    public boolean getResult() {
	if (_nameOfFunct == null) { 
	    return false;
	}

        if (_namespaceOfFunct == null ||
            _namespaceOfFunct.equals(EMPTYSTRING) ||
	    _namespaceOfFunct.equals(EXT_XALAN) ||
	    _namespaceOfFunct.equals(TRANSLET_URI))
        {
            final Parser parser = getParser();
            _isFunctionAvailable = 
		parser.functionSupported(Util.getLocalName(_nameOfFunct));
        }
 	return _isFunctionAvailable;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	methodGen.getInstructionList().append(new PUSH(cpg, getResult()));
    }

}
"
org.apache.xalan.templates.ElemExtensionScript,6,3,0,2,7,3,1,1,6,0.6,33,1.0,0,0.975124378,0.666666667,1,2,4.166666667,1,0.8333,0,"
package org.apache.xalan.templates;


public class ElemExtensionScript extends ElemTemplateElement
{

  
  public ElemExtensionScript()
  {

    
  }

  
  private String m_lang = null;

  
  public void setLang(String v)
  {
    m_lang = v;
  }

  
  public String getLang()
  {
    return m_lang;
  }

  
  private String m_src = null;

  
  public void setSrc(String v)
  {
    m_src = v;
  }

  
  public String getSrc()
  {
    return m_src;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_EXTENSIONSCRIPT;
  }
}
"
org.apache.xpath.axes.WalkingIterator,17,5,1,19,41,0,8,13,16,0.4375,281,1.0,2,0.892857143,0.165775401,2,9,15.41176471,7,1.8824,0,"package org.apache.xpath.axes;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;



public class WalkingIterator extends LocPathIterator implements ExpressionOwner
{
  
  WalkingIterator(
          Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers)
            throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, shouldLoadWalkers);
    
    int firstStepPos = compiler.getFirstChildPos(opPos);

    if (shouldLoadWalkers)
    {
      m_firstWalker = WalkerFactory.loadWalkers(this, compiler, firstStepPos, 0);
      m_lastUsedWalker = m_firstWalker;
    }
  }
  
  
  public WalkingIterator(PrefixResolver nscontext)
  {

    super(nscontext);
  }
  
  
  
  public int getAnalysisBits()
  {
    int bits = 0;
    if (null != m_firstWalker)
    {    	
      AxesWalker walker = m_firstWalker;

      while (null != walker)
      {
        int bit = walker.getAnalysisBits();
        bits |= bit;
        walker = walker.getNextWalker();
      }       
    }
    return bits;
  }
  
  
  public Object clone() throws CloneNotSupportedException
  {

    WalkingIterator clone = (WalkingIterator) super.clone();

    
    
    if (null != m_firstWalker)
    {
      clone.m_firstWalker = m_firstWalker.cloneDeep(clone, null);
    }

    return clone;
  }
  
  
  public void reset()
  {

    super.reset();

    if (null != m_firstWalker)
    {
      m_lastUsedWalker = m_firstWalker;

      m_firstWalker.setRoot(m_context);
    }

  }
  
  
  public void setRoot(int context, Object environment)
  {

    super.setRoot(context, environment);
    
    if(null != m_firstWalker)
    {
      m_firstWalker.setRoot(context);
      m_lastUsedWalker = m_firstWalker;
    }
  }
  
  
  public int nextNode()
  {
  	if(m_foundLast)
  		return DTM.NULL;

    
    
    
    
    
    
    
    
    if (-1 == m_stackFrame)
    {
      return returnNextNode(m_firstWalker.nextNode());
    }
    else
    {
      VariableStack vars = m_execContext.getVarStack();

      
      int savedStart = vars.getStackFrame();

      vars.setStackFrame(m_stackFrame);

      int n = returnNextNode(m_firstWalker.nextNode());

      
      vars.setStackFrame(savedStart);

      return n;
    }
  }

  
  
  public final AxesWalker getFirstWalker()
  {
    return m_firstWalker;
  }
  
  
  public final void setFirstWalker(AxesWalker walker)
  {
    m_firstWalker = walker;
  }


  
  public final void setLastUsedWalker(AxesWalker walker)
  {
    m_lastUsedWalker = walker;
  }

  
  public final AxesWalker getLastUsedWalker()
  {
    return m_lastUsedWalker;
  }
  
  
  public void detach()
  {   
    if(m_allowDetach)
    {
	  	AxesWalker walker = m_firstWalker; 
	    while (null != walker)
	    {
	      walker.detach();
	      walker = walker.getNextWalker();
	    }
	
	    m_lastUsedWalker = null;
	    
	    
	    super.detach();
    }
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_predicateIndex = -1;

    AxesWalker walker = m_firstWalker;

    while (null != walker)
    {
      walker.fixupVariables(vars, globalsSize);
      walker = walker.getNextWalker();
    }
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	 	if(visitor.visitLocationPath(owner, this))
  	 	{
  	 		if(null != m_firstWalker)
  	 		{
  	 			m_firstWalker.callVisitors(this, visitor);
  	 		}
  	 	}
  }

  
  
  protected AxesWalker m_lastUsedWalker;

  
  protected AxesWalker m_firstWalker;

  
  public Expression getExpression()
  {
    return m_firstWalker;
  }


  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_firstWalker = (AxesWalker)exp;
  }
  
    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
                return false;

      AxesWalker walker1 = m_firstWalker;
      AxesWalker walker2 = ((WalkingIterator)expr).m_firstWalker;
      while ((null != walker1) && (null != walker2))
      {
        if(!walker1.deepEquals(walker2))
        	return false;
        walker1 = walker1.getNextWalker();
        walker2 = walker2.getNextWalker();
      }
      
      if((null != walker1) || (null != walker2))
      	return false;

      return true;
    }


}"
org.apache.xalan.xsltc.compiler.Template,22,3,0,28,72,121,10,22,21,0.852380952,485,1.0,4,0.740740741,0.140495868,2,7,20.59090909,8,2.0455,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import java.util.Hashtable;

import org.apache.xalan.xsltc.compiler.util.Type;

import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.JavaClass;

import org.apache.xalan.xsltc.compiler.util.*;

public final class Template extends TopLevelElement {

    private QName   _name;     
    private QName   _mode;     
    private Pattern _pattern;  
    private double  _priority; 
    private int     _position; 
    private boolean _disabled = false;
    private boolean _compiled = false;
    private boolean _hasParams = false;
    private boolean _simplified = false;

    public boolean hasParams() {
	return _hasParams;
    }

    public void hasParams(boolean hasParams) {
	_hasParams = hasParams;
    }

    public boolean isSimplified() {
	return(_simplified);
    }

    public void setSimplified() {
	_simplified = true;
    }

    public void disable() {
	_disabled = true;
    }

    public boolean disabled() {
	return(_disabled);
    }

    public double getPriority() {
	return _priority;
    }

    public int getPosition() {
	return(_position);
    }

    public boolean isNamed() {
	return _name != null;
    }

    public Pattern getPattern() {
	return _pattern;
    }

    public QName getName() {
	return _name;
    }

    public void setName(QName qname) {
	if (_name == null) _name = qname;
    }

    public QName getModeName() {
	return _mode;
    }

    
    public int compareTo(Object template) {
	Template other = (Template)template;
	if (_priority > other._priority)
	    return 1;
	else if (_priority < other._priority)
	    return -1;
	else if (_position > other._position)
	    return 1;
	else if (_position < other._position)
	    return -1;
	else
	    return 0;
    }

    public void display(int indent) {
	Util.println('
');
	indent(indent);
	if (_name != null) {
	    indent(indent);
	    Util.println(""name = "" + _name);
	}
	else if (_pattern != null) {
	    indent(indent);
	    Util.println(""match = "" + _pattern.toString());
	}
	if (_mode != null) {
	    indent(indent);
	    Util.println(""mode = "" + _mode);
	}
	displayContents(indent + IndentIncrement);
    }

    private boolean resolveNamedTemplates(Template other, Parser parser) {

	if (other == null) return true;

	SymbolTable stable = parser.getSymbolTable();

	final int us = this.getImportPrecedence();
	final int them = other.getImportPrecedence();

	if (us > them) {
	    other.disable();
	    return true;
	}
	else if (us < them) {
	    stable.addTemplate(other);
	    this.disable();
	    return true;
	}
	else {
	    return false;
	}
    }

    private Stylesheet _stylesheet = null;

    public Stylesheet getStylesheet() {
	return _stylesheet;
    }

    public void parseContents(Parser parser) {

	final String name     = getAttribute(""name"");
	final String mode     = getAttribute(""mode"");
	final String match    = getAttribute(""match"");
	final String priority = getAttribute(""priority"");

	_stylesheet = super.getStylesheet();

	if (name.length() > 0) {
	    _name = parser.getQNameIgnoreDefaultNs(name);
	}
	
	if (mode.length() > 0) {
	    _mode = parser.getQNameIgnoreDefaultNs(mode);
	}
	
	if (match.length() > 0) {
	    _pattern = parser.parsePattern(this, ""match"", null);
	}

	if (priority.length() > 0) {
	    _priority = Double.parseDouble(priority);
	}
	else {
	    if (_pattern != null)
		_priority = _pattern.getPriority();
	    else
		_priority = Double.NaN;
	}

	_position = parser.getTemplateIndex();

	
	if (_name != null) {
	    Template other = parser.getSymbolTable().addTemplate(this);
	    if (!resolveNamedTemplates(other, parser)) {
		ErrorMsg err =
		    new ErrorMsg(ErrorMsg.TEMPLATE_REDEF_ERR, _name, this);
		parser.reportError(Constants.ERROR, err);
	    }
	}

	parser.setTemplate(this);	
	parseChildren(parser);
	parser.setTemplate(null);	
    }

    
    public void parseSimplified(Stylesheet stylesheet, Parser parser) {

	_stylesheet = stylesheet;
	setParent(stylesheet);

	_name = null;
	_mode = null;
	_priority = Double.NaN;
	_pattern = parser.parsePattern(this, ""/"");

	final Vector contents = _stylesheet.getContents();
	final SyntaxTreeNode root = (SyntaxTreeNode)contents.elementAt(0);

	if (root instanceof LiteralElement) {
	    addElement(root);
	    root.setParent(this);
	    contents.set(0, this);
	    parser.setTemplate(this);
	    root.parseContents(parser);
	    parser.setTemplate(null);
	}
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_pattern != null) {
	    _pattern.typeCheck(stable);
	}

	return typeCheckContents(stable);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_disabled) return;
	
	String className = classGen.getClassName();

	if (_compiled && isNamed()){
	    String methodName = Util.escape(_name.toString());
	    il.append(classGen.loadTranslet());
	    il.append(methodGen.loadDOM());
	    il.append(methodGen.loadIterator());
	    il.append(methodGen.loadHandler()); 
	    il.append(methodGen.loadCurrentNode()); 
	    il.append(new INVOKEVIRTUAL(cpg.addMethodref(className,
							 methodName,
							 ""(""
							 + DOM_INTF_SIG
							 + NODE_ITERATOR_SIG
							 + TRANSLET_OUTPUT_SIG
							 + ""I)V"")));
	    return;
	}

	if (_compiled) return;
	_compiled = true; 
	
	final InstructionHandle start = il.getEnd();
	translateContents(classGen, methodGen);
	final InstructionHandle end = il.getEnd();
	il.setPositions(true);
    }
}
"
org.apache.xalan.trace.SelectionEvent,1,1,1,8,2,0,4,4,1,2.0,28,0.0,4,0.0,1.0,0,0,21.0,0,0.0,0,"
package org.apache.xalan.trace;

import org.w3c.dom.*;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;


public class SelectionEvent implements java.util.EventListener
{

  
  public final ElemTemplateElement m_styleNode;

  
  public final TransformerImpl m_processor;

  
  public final Node m_sourceNode;

  
  public final String m_attributeName;

  
  public final XPath m_xpath;

  
  public final XObject m_selection;

  
  public SelectionEvent(TransformerImpl processor, Node sourceNode,
                        ElemTemplateElement styleNode, String attributeName,
                        XPath xpath, XObject selection)
  {

    this.m_processor = processor;
    this.m_sourceNode = sourceNode;
    this.m_styleNode = styleNode;
    this.m_attributeName = attributeName;
    this.m_xpath = xpath;
    this.m_selection = selection;
  }
}
"
org.apache.xml.utils.synthetic.SynthesisException,4,3,0,6,5,0,6,0,2,1.095238095,54,0.0,0,0.944444444,0.666666667,0,0,10.75,1,0.25,0,"
package org.apache.xml.utils.synthetic;


public class SynthesisException extends Exception
{

  
  int code;

  

  
  public static final int SYNTAX = 0;

  
  public static final int UNSUPPORTED = 1;

  
  public static final int REIFIED = 2;

  
  public static final int UNREIFIED = 3;

  
  public static final int WRONG_OWNER = 4;

  
  public static final String[] errToString = {
    ""(Syntax error; specific message should be passed in)"",
    ""Feature not yet supported"",
    ""Can't change features of 'real' class"",
    ""Can't yet instantiate/invoke without 'real' class"",
    ""Can't add Member to an object other than its declarer"", };

  
  public SynthesisException(int code)
  {

    super(errToString[code]);

    this.code = code;
  }

  
  public SynthesisException(int code, String msg)
  {

    super(msg);

    this.code = code;
  }

  
  int getCode()
  {
    return code;
  }
}
"
org.apache.xalan.xsltc.dom.Filter,1,1,0,6,1,0,6,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.dom;

public interface Filter {
    public boolean test(int node);
}
"
org.apache.xpath.axes.WalkingIteratorSorted,5,6,0,5,13,0,1,5,3,0.25,129,1.0,0,0.979020979,0.366666667,1,1,24.6,17,4.0,0,"
package org.apache.xpath.axes;

import org.apache.xpath.XPathContext;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.compiler.Compiler;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.Axis;


public class WalkingIteratorSorted extends WalkingIterator
{



  
  
  protected boolean m_inNaturalOrderStatic = false;

  
  public WalkingIteratorSorted(PrefixResolver nscontext)
  {
    super(nscontext);
  }

  
  WalkingIteratorSorted(
          Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers)
            throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, shouldLoadWalkers);
  }
  
  
  public boolean isDocOrdered()
  {
    return m_inNaturalOrderStatic;
  }

    
  
  boolean canBeWalkedInNaturalDocOrderStatic()
  {

    if (null != m_firstWalker)
    {
      AxesWalker walker = m_firstWalker;
      int prevAxis = -1;
      boolean prevIsSimpleDownAxis = true;

      for(int i = 0; null != walker; i++)
      {
        int axis = walker.getAxis();
        
        if(walker.isDocOrdered())
        {
          boolean isSimpleDownAxis = ((axis == Axis.CHILD)
                                   || (axis == Axis.SELF)
                                   || (axis == Axis.ROOT));
          
          
          if(isSimpleDownAxis || (axis == -1))
            walker = walker.getNextWalker();
          else
          {
            boolean isLastWalker = (null == walker.getNextWalker());
            if(isLastWalker)
            {
              if(walker.isDocOrdered() && (axis == Axis.DESCENDANT || 
                 axis == Axis.DESCENDANTORSELF || axis == Axis.DESCENDANTSFROMROOT
                 || axis == Axis.DESCENDANTSORSELFFROMROOT) || (axis == Axis.ATTRIBUTE))
                return true;
            }
            return false;
          }
        }
        else
          return false;
      }
      return true;
    }
    return false;
  }


















































  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);

    int analysis = getAnalysisBits();
    if(WalkerFactory.isNaturalDocOrder(analysis))
    {
    	m_inNaturalOrderStatic = true;
    }
    else
    {
    	m_inNaturalOrderStatic = false;
    	
    	
    }
    
  }

}
"
org.apache.xalan.templates.NamespaceAlias,10,3,0,6,12,37,6,2,10,0.888888889,52,1.0,0,0.956097561,0.4,1,1,3.8,1,0.9,0,"
package org.apache.xalan.templates;


public class NamespaceAlias extends ElemTemplateElement
{
  
  
  public NamespaceAlias(int docOrderNumber)
  {
    super();
    m_docOrderNumber = docOrderNumber;
  }

  
  private String m_StylesheetPrefix;

  
  public void setStylesheetPrefix(String v)
  {
    m_StylesheetPrefix = v;
  }

  
  public String getStylesheetPrefix()
  {
    return m_StylesheetPrefix;
  }
  
  
  private String m_StylesheetNamespace;

  
  public void setStylesheetNamespace(String v)
  {
    m_StylesheetNamespace = v;
  }

  
  public String getStylesheetNamespace()
  {
    return m_StylesheetNamespace;
  }

  
  private String m_ResultPrefix;

  
  public void setResultPrefix(String v)
  {
    m_ResultPrefix = v;
  }

  
  public String getResultPrefix()
  {
    return m_ResultPrefix;
  }
  
  
  private String m_ResultNamespace;

  
  public void setResultNamespace(String v)
  {
    m_ResultNamespace = v;
  }

  
  public String getResultNamespace()
  {
    return m_ResultNamespace;
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeNamespaceAliases(this);
  }

}
"
org.apache.xalan.xsltc.compiler.util.ErrorMsg,18,1,0,51,33,3,51,2,15,1.015345269,485,0.086956522,0,0.0,0.411764706,0,0,20.83333333,3,0.7222,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.Stylesheet;
import org.apache.xalan.xsltc.compiler.SyntaxTreeNode;

import java.net.URL;
import java.util.Locale;
import java.util.ResourceBundle;
import java.text.MessageFormat;

public final class ErrorMsg {

    private int _code;
    private int _line;
    private String _message = null;
    private String _url = null;
    Object[] _params = null;

    
    public static final int MULTIPLE_STYLESHEET_ERR = 0;
    public static final int TEMPLATE_REDEF_ERR      = 1;
    public static final int TEMPLATE_UNDEF_ERR      = 2;
    public static final int VARIABLE_REDEF_ERR      = 3;
    public static final int VARIABLE_UNDEF_ERR      = 4;
    public static final int CLASS_NOT_FOUND_ERR     = 5;
    public static final int METHOD_NOT_FOUND_ERR    = 6;
    public static final int ARGUMENT_CONVERSION_ERR = 7;
    public static final int FILE_NOT_FOUND_ERR      = 8;
    public static final int INVALID_URI_ERR         = 9;
    public static final int FILE_ACCESS_ERR         = 10;
    public static final int MISSING_ROOT_ERR        = 11;
    public static final int NAMESPACE_UNDEF_ERR     = 12;
    public static final int FUNCTION_RESOLVE_ERR    = 13;
    public static final int NEED_LITERAL_ERR        = 14;
    public static final int XPATH_PARSER_ERR        = 15;
    public static final int REQUIRED_ATTR_ERR       = 16;
    public static final int ILLEGAL_CHAR_ERR        = 17;
    public static final int ILLEGAL_PI_ERR          = 18;
    public static final int STRAY_ATTRIBUTE_ERR     = 19;
    public static final int ILLEGAL_ATTRIBUTE_ERR   = 20;
    public static final int CIRCULAR_INCLUDE_ERR    = 21;
    public static final int RESULT_TREE_SORT_ERR    = 22;
    public static final int SYMBOLS_REDEF_ERR       = 23;
    public static final int XSL_VERSION_ERR         = 24;
    public static final int CIRCULAR_VARIABLE_ERR   = 25;
    public static final int ILLEGAL_BINARY_OP_ERR   = 26;
    public static final int ILLEGAL_ARG_ERR         = 27;
    public static final int DOCUMENT_ARG_ERR        = 28;
    public static final int MISSING_WHEN_ERR        = 29;
    public static final int MULTIPLE_OTHERWISE_ERR  = 30;
    public static final int STRAY_OTHERWISE_ERR     = 31;
    public static final int STRAY_WHEN_ERR          = 32;
    public static final int WHEN_ELEMENT_ERR        = 33;
    public static final int UNNAMED_ATTRIBSET_ERR   = 34;
    public static final int ILLEGAL_CHILD_ERR       = 35;
    public static final int ILLEGAL_ELEM_NAME_ERR   = 36;
    public static final int ILLEGAL_ATTR_NAME_ERR   = 37;
    public static final int ILLEGAL_TEXT_NODE_ERR   = 38;
    public static final int SAX_PARSER_CONFIG_ERR   = 39;
    public static final int INTERNAL_ERR            = 40;
    public static final int UNSUPPORTED_XSL_ERR     = 41;
    public static final int UNSUPPORTED_EXT_ERR     = 42;
    public static final int MISSING_XSLT_URI_ERR    = 43;
    public static final int MISSING_XSLT_TARGET_ERR = 44;
    public static final int NOT_IMPLEMENTED_ERR     = 45;
    public static final int NOT_STYLESHEET_ERR      = 46;
    public static final int ELEMENT_PARSE_ERR       = 47;
    public static final int KEY_USE_ATTR_ERR        = 48;
    public static final int OUTPUT_VERSION_ERR      = 49;
    public static final int ILLEGAL_RELAT_OP_ERR    = 50;
    public static final int ATTRIBSET_UNDEF_ERR     = 51;
    public static final int ATTR_VAL_TEMPLATE_ERR   = 52;
    public static final int UNKNOWN_SIG_TYPE_ERR    = 53;
    public static final int DATA_CONVERSION_ERR     = 54;

    
    public static final int NO_TRANSLET_CLASS_ERR   = 55;
    public static final int NO_MAIN_TRANSLET_ERR    = 56;
    public static final int TRANSLET_CLASS_ERR      = 57;
    public static final int TRANSLET_OBJECT_ERR     = 58;
    public static final int ERROR_LISTENER_NULL_ERR = 59;
    public static final int JAXP_UNKNOWN_SOURCE_ERR = 60;
    public static final int JAXP_NO_SOURCE_ERR      = 61;
    public static final int JAXP_COMPILE_ERR        = 62;
    public static final int JAXP_INVALID_ATTR_ERR   = 63;
    public static final int JAXP_SET_RESULT_ERR     = 64;
    public static final int JAXP_NO_TRANSLET_ERR    = 65;
    public static final int JAXP_NO_HANDLER_ERR     = 66;
    public static final int JAXP_NO_RESULT_ERR      = 67;
    public static final int JAXP_UNKNOWN_PROP_ERR   = 68;
    public static final int SAX2DOM_ADAPTER_ERR     = 69;
    public static final int XSLTC_SOURCE_ERR        = 70;

    
    public static final int COMPILE_STDIN_ERR       = 71;
    public static final int COMPILE_USAGE_STR       = 72;
    public static final int TRANSFORM_USAGE_STR     = 73;

    
    public static final int STRAY_SORT_ERR          = 74;
    public static final int UNSUPPORTED_ENCODING    = 75;
    public static final int SYNTAX_ERR              = 76;
    public static final int CONSTRUCTOR_NOT_FOUND   = 77;
    public static final int NO_JAVA_FUNCT_THIS_REF  = 78;

    
    
    private static String[] _errorMessages;
    private static String   _compileError;
    private static String   _compileWarning;
    private static String   _runtimeError;
    
    public final static String ERROR_MESSAGES_KEY   = ""error-messages"";
    public final static String COMPILER_ERROR_KEY   = ""compile-error"";
    public final static String COMPILER_WARNING_KEY = ""compile-warning"";
    public final static String RUNTIME_ERROR_KEY    = ""runtime-error"";

    static {
	ResourceBundle bundle = ResourceBundle.getBundle(""org.apache.xalan.xsltc.compiler.util.ErrorMessages"", Locale.getDefault());
	_errorMessages  = bundle.getStringArray(ERROR_MESSAGES_KEY);
	_compileError   = bundle.getString(COMPILER_ERROR_KEY);
	_compileWarning = bundle.getString(COMPILER_WARNING_KEY);
	_runtimeError   = bundle.getString(RUNTIME_ERROR_KEY);
    }

    public ErrorMsg(int code) {
	_code = code;
	_line = 0;
    }
	
    public ErrorMsg(String message) {
	_code = -1;
	_message = message;
	_line = 0;
    }

    public ErrorMsg(String message, int line) {
	_code = -1;
	_message = message;
	_line = line;
    }

    public ErrorMsg(int code, int line, Object param) {
	_code = code;
	_line = line;
	_params = new Object[] { param };
    }

    public ErrorMsg(int code, Object param) {
	this(code);
	_params = new Object[1];
	_params[0] = param;
    }

    public ErrorMsg(int code, Object param1, Object param2) {
	this(code);
	_params = new Object[2];
	_params[0] = param1;
	_params[1] = param2;
    }

    public ErrorMsg(int code, SyntaxTreeNode node) {
	_code = code;
	_url  = getFileName(node);
	_line = node.getLineNumber();
    }

    public ErrorMsg(int code, Object param1, SyntaxTreeNode node) {
	_code = code;
	_url  = getFileName(node);
	_line = node.getLineNumber();
	_params = new Object[1];
	_params[0] = param1;
    }

    public ErrorMsg(int code, Object param1, Object param2,
		    SyntaxTreeNode node) {
	_code = code;
	_url  = getFileName(node);
	_line = node.getLineNumber();
	_params = new Object[2];
	_params[0] = param1;
	_params[1] = param2;
    }

    public static String getCompileErrorMessage() {
	return _compileError;
    }

    public static String getCompileWarningMessage() {
	return _compileWarning;
    }

    public static String getTransletErrorMessage() {
	return _runtimeError;
    }

    private String getFileName(SyntaxTreeNode node) {
	Stylesheet stylesheet = node.getStylesheet();
	if (stylesheet != null)
	    return stylesheet.getSystemId();
	else
	    return null;
    }

    private String formatLine() {
	StringBuffer result = new StringBuffer();
	if (_url != null) {
	    result.append(_url);
	    result.append("": "");
	}
	if (_line > 0) {
	    result.append(""line "");
	    result.append(Integer.toString(_line));
	    result.append("": "");
	}
	return result.toString();
    }
	
    
    public String toString() {
	String suffix = (_params == null) ? 
	    (_code >= 0 ? new String(_errorMessages[_code]) : _message)
	    : MessageFormat.format(_errorMessages[_code], _params);
	return formatLine() + suffix;
    }
	
    public String toString(Object obj) {
	Object params[] = new Object[1];
	params[0] = obj.toString();
	String suffix = MessageFormat.format(_errorMessages[_code], params);
	return formatLine() + suffix;
    }
	
    public String toString(Object obj0, Object obj1) {
	Object params[] = new Object[2];
	params[0] = obj0.toString();
	params[1] = obj1.toString();
	String suffix = MessageFormat.format(_errorMessages[_code], params);
	return formatLine() + suffix;
    }
}

"
org.apache.xalan.transformer.TrAXFilter,7,2,0,3,35,1,1,2,6,0.5,199,1.0,1,0.85,0.265306122,1,6,27.14285714,6,1.7143,0,"package org.apache.xalan.transformer;

import java.io.IOException;

import javax.xml.transform.TransformerException;
import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.XMLFilter;
import org.xml.sax.ContentHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.DTDHandler;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.XMLFilterImpl;
import org.xml.sax.helpers.XMLReaderFactory;

import javax.xml.transform.Templates;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.ErrorListener;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;


public class TrAXFilter extends XMLFilterImpl
{
  private Templates m_templates;
  private TransformerImpl m_transformer;
    
  
  public TrAXFilter (Templates templates)
    throws TransformerConfigurationException
  {
    m_templates = templates;
    m_transformer = (TransformerImpl)templates.newTransformer();
  }
  
  
  public void setParent (XMLReader parent)
  { 
    super.setParent(parent);
    
    if(null != parent.getContentHandler())
      this.setContentHandler(parent.getContentHandler());

    
    
    
    setupParse ();
  }
  
  
  public void parse (InputSource input)
    throws org.xml.sax.SAXException, IOException
  {
    if(null == getParent())
    {
      XMLReader reader=null;

      
      try {
          javax.xml.parsers.SAXParserFactory factory=
              javax.xml.parsers.SAXParserFactory.newInstance();
          factory.setNamespaceAware( true );
          javax.xml.parsers.SAXParser jaxpParser=
              factory.newSAXParser();
          reader=jaxpParser.getXMLReader();
          
      } catch( javax.xml.parsers.ParserConfigurationException ex ) {
          throw new org.xml.sax.SAXException( ex );
      } catch( javax.xml.parsers.FactoryConfigurationError ex1 ) {
          throw new org.xml.sax.SAXException( ex1.toString() );
      } catch( NoSuchMethodError ex2 ) {
      }
      catch (AbstractMethodError ame){}

      XMLReader parent;
      if( reader==null )
          parent= XMLReaderFactory.createXMLReader();
      else
          parent=reader;
      try
      {
        parent.setFeature(""http:
                          true);
        
        


      }
      catch (org.xml.sax.SAXException se){}
      
      setParent(parent);
    }
    else
    {
      
      setupParse ();
    }
    if(null == m_transformer.getContentHandler())
    {
      throw new org.xml.sax.SAXException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_CALL_PARSE, null)); 
    }

    getParent().parse(input);
    Exception e = m_transformer.getExceptionThrown();
    if(null != e)
    {
      if(e instanceof org.xml.sax.SAXException)
        throw (org.xml.sax.SAXException)e;
      else
        throw new org.xml.sax.SAXException(e);
    }
  }
  
  
  public void parse (String systemId)
    throws org.xml.sax.SAXException, IOException
  {
    parse(new InputSource(systemId));
  }


  
  private void setupParse ()
  {
    XMLReader p = getParent();
    if (p == null) {
      throw new NullPointerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_PARENT_FOR_FILTER, null)); 
    }
    
    ContentHandler ch = m_transformer.getInputContentHandler();


    p.setContentHandler(ch);

    if(ch instanceof EntityResolver)
      p.setEntityResolver((EntityResolver)ch);
    else
      p.setEntityResolver(this);
    
    if(ch instanceof DTDHandler)
      p.setDTDHandler((DTDHandler)ch);
    else
      p.setDTDHandler(this);
    
    ErrorListener elistener = m_transformer.getErrorListener();
    if((null != elistener) && (elistener instanceof org.xml.sax.ErrorHandler))
      p.setErrorHandler((org.xml.sax.ErrorHandler)elistener);
    else
      p.setErrorHandler(this);
  }

  
  public void setContentHandler (ContentHandler handler)
  {
    m_transformer.setContentHandler(handler);
    
  }
  
  public void setErrorListener (ErrorListener handler)
  {
    m_transformer.setErrorListener(handler);
  }

}
"
org.apache.xalan.xsltc.dom.DocumentCache,8,1,0,7,54,6,1,7,3,0.660714286,399,1.0,0,0.0,0.339285714,0,0,47.875,7,2.375,0,"

package org.apache.xalan.xsltc.dom;

import java.io.PrintWriter;
import java.io.File;
import java.io.IOException;
import java.net.URL;
import java.net.URLDecoder;
import java.net.URLConnection;
import java.net.MalformedURLException;
import java.util.Hashtable;
import java.util.Date;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.XMLReader;
import org.xml.sax.SAXException;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.DOMCache;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.dom.DOMImpl;
import org.apache.xalan.xsltc.dom.DTDMonitor;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.runtime.Constants;

public final class DocumentCache implements DOMCache {

    private int       _size;
    private Hashtable _references;
    private String[]  _URIs;
    private int       _count;
    private int       _current;
    private SAXParser _parser;
    private XMLReader _reader;

    private static final int REFRESH_INTERVAL = 1000;

    
    public final class CachedDocument {
	
	
	private long _firstReferenced;
	private long _lastReferenced;
	private long _accessCount;
	private long _lastModified;
	private long _lastChecked;
	private long _buildTime;

	
	private DOMImpl    _dom = null;
	private DTDMonitor _dtdMonitor = null;
	
	
	public CachedDocument(String uri) {
	    
	    final long stamp = System.currentTimeMillis();
	    _firstReferenced = stamp;
	    _lastReferenced  = stamp;
	    _accessCount     = 0;
	    loadDocument(uri);

	    _buildTime = System.currentTimeMillis() - stamp;
	}

	
	public void loadDocument(String uri) {

	    _dom = new DOMImpl();
	    _dtdMonitor = new DTDMonitor();

	    try {
		final long stamp = System.currentTimeMillis();

		_reader.setContentHandler(_dom.getBuilder());
		_dtdMonitor.handleDTD(_reader);
		_reader.parse(uri);
		_dom.setDocumentURI(uri);

		
		
		final long thisTime = System.currentTimeMillis() - stamp;
		if (_buildTime > 0)
		    _buildTime = (_buildTime + thisTime) >>> 1;
		else
		    _buildTime = thisTime;
	    }
	    catch (Exception e) {
		_dom = null;
		_dtdMonitor = null;
	    }
	}

	public DOMImpl getDocument()       { return(_dom); }

	public DTDMonitor getDTDMonitor()  { return(_dtdMonitor); }

	public long getFirstReferenced()   { return(_firstReferenced); }

	public long getLastReferenced()    { return(_lastReferenced); }

	public long getAccessCount()       { return(_accessCount); }

	public void incAccessCount()       { _accessCount++; }

	public long getLastModified()      { return(_lastModified); }

	public void setLastModified(long t){ _lastModified = t; }

	public long getLatency()           { return(_buildTime); }

	public long getLastChecked()       { return(_lastChecked); }
	
	public void setLastChecked(long t) { _lastChecked = t; }

	public long getEstimatedSize() {
	    if (_dom != null)
		return(_dom.getSize() << 5); 
	    else
		return(0);
	}

    }

    
    public DocumentCache(int size) throws SAXException {
	_count = 0;
	_current = 0;
	_size  = size;
	_references = new Hashtable(_size+2);
	_URIs = new String[_size];

	try {
	    
	    final SAXParserFactory factory = SAXParserFactory.newInstance();
	    try {
		factory.setFeature(Constants.NAMESPACE_FEATURE,true);
	    }
	    catch (Exception e) {
		factory.setNamespaceAware(true);
	    }
	    _parser = factory.newSAXParser();
	    _reader = _parser.getXMLReader();
	}
	catch (ParserConfigurationException e) {
	    System.err.println(""Your SAX parser is not configured correctly."");
	    System.exit(-1);
	}
    }

    
    private final long getLastModified(String uri) {
	try {
	    URL url = new URL(uri);
	    URLConnection connection = url.openConnection();
	    long timestamp = connection.getLastModified();
	    
	    if (timestamp == 0){ 
	        if (""file"".equals(url.getProtocol())){
	            File localfile = new File(URLDecoder.decode(url.getFile()));
	            timestamp = localfile.lastModified();
	        }
	    }
	    return(timestamp);
	}
	
	catch (Exception e) {
	    return(System.currentTimeMillis());
	}
    }

    
    private CachedDocument lookupDocument(String uri) {
	return((CachedDocument)_references.get(uri));
    }

    
    private synchronized void insertDocument(String uri, CachedDocument doc) {
	if (_count < _size) {
	    
	    _URIs[_count++] = uri;
	    _current = 0;
	}
	else {
	    
	    _references.remove(_URIs[_current]);
	    
	    _URIs[_current] = uri;
	    if (++_current >= _size) _current = 0;
	}
	_references.put(uri, doc);
    }

    
    private synchronized void replaceDocument(String uri, CachedDocument doc) {
	CachedDocument old = (CachedDocument)_references.get(uri);
	if (doc == null)
	    insertDocument(uri, doc);
	else
	    _references.put(uri, doc);
    }

    
    public final DOMImpl retrieveDocument(String uri, int mask, Translet trs) {
	CachedDocument doc;

	
	if ((doc = lookupDocument(uri)) == null) {
	    doc = new CachedDocument(uri);
	    if (doc == null) return null; 
	    doc.setLastModified(getLastModified(uri));
	    insertDocument(uri, doc);
	}
	
	else {
	    long now = System.currentTimeMillis();
	    long chk = doc.getLastChecked();
	    doc.setLastChecked(now);
	    
	    if (now > (chk + REFRESH_INTERVAL)) {
		doc.setLastChecked(now);
		long last = getLastModified(uri);
		
		if (last > doc.getLastModified()) {
		    doc = new CachedDocument(uri);
		    if (doc == null) return null;
		    doc.setLastModified(getLastModified(uri));
		    replaceDocument(uri, doc);
		}
	    }
	    
	}

	
	final DOMImpl    dom = doc.getDocument();
	final DTDMonitor dtd = doc.getDTDMonitor();

	
	
	if (dom == null) return null;

	doc.incAccessCount(); 

	final AbstractTranslet translet = (AbstractTranslet)trs;

	
	translet.setIndexSize(dom.getSize());
	
	dtd.buildIdIndex(dom, mask, translet);
	
	translet.setUnparsedEntityURIs(dtd.getUnparsedEntityURIs());

	return(doc.getDocument());
    }

    
    public void getStatistics(PrintWriter out) {
	out.println(""<h2>DOM cache statistics</h2><center><table border=""2"">""+
		    ""<tr><td><b>Document URI</b></td>""+
		    ""<td><center><b>Build time</b></center></td>""+
		    ""<td><center><b>Access count</b></center></td>""+
		    ""<td><center><b>Last accessed</b></center></td>""+
		    ""<td><center><b>Last modified</b></center></td></tr>"");

	for (int i=0; i<_count; i++) {
	    CachedDocument doc = (CachedDocument)_references.get(_URIs[i]);
	    out.print(""<tr><td><a href=""""+_URIs[i]+"""">""+
		      ""<font size=-1>""+_URIs[i]+""</font></a></td>"");
	    out.print(""<td><center>""+doc.getLatency()+""ms</center></td>"");
	    out.print(""<td><center>""+doc.getAccessCount()+""</center></td>"");
	    out.print(""<td><center>""+(new Date(doc.getLastReferenced()))+
		      ""</center></td>"");
	    out.print(""<td><center>""+(new Date(doc.getLastModified()))+
		      ""</center></td>"");
	    out.println(""</tr>"");
	}

	out.println(""</table></center>"");
    }
}
"
org.apache.xml.dtm.DTMAxisIterator,10,1,0,26,10,45,26,0,10,1.111111111,11,0.0,0,0.0,0.55,0,0,0.0,1,1.0,0,"
package org.apache.xml.dtm;


public interface DTMAxisIterator extends Cloneable
{

  
  public static final int END = DTM.NULL;

  
  public int next();

  
  public DTMAxisIterator reset();

  
  public int getLast();

  
  public int getPosition();

  
  public void setMark();

  
  public void gotoMark();

  
  public DTMAxisIterator setStartNode(int node);

  
  public int getStartNode();

  
  public boolean isReverse();

  
  public DTMAxisIterator cloneIterator();
}
"
org.apache.xalan.lib.sql.QueryParameter,5,1,0,1,6,0,1,0,5,0.5,30,1.0,0,0.0,0.8,0,0,4.6,1,0.8,0,"

package org.apache.xalan.lib.sql;


public class QueryParameter         
{

  
  private String value;
  
  private String type;

  
  public QueryParameter( String v, String t )
  {
    value = v;
    type = t;
  }

  
  public String getValue( ) {
    return value;
  }

  
  public void setValue( String newValue ) {
    value = newValue;
  }

  
  public void setType( String newType ) {
    type = newType;
  }

  
  public String getType( ) {
    return type;
  }
}"
org.apache.xalan.xsltc.compiler.If,5,3,0,18,28,0,1,17,4,0.25,129,1.0,1,0.933333333,0.333333333,1,5,24.4,5,1.8,0,"

package org.apache.xalan.xsltc.compiler;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class If extends Instruction {

    private Expression _test;
    private boolean    _ignore = false;

    
    public void display(int indent) {
	indent(indent);
	Util.println(""If"");
	indent(indent + IndentIncrement);
	System.out.print(""test "");
	Util.println(_test.toString());
	displayContents(indent + IndentIncrement);
    }

    
    public void parseContents(Parser parser) {
	
	_test = parser.parseExpression(this, ""test"", null);

        
        if (_test.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""test"");
	    return;
        }

	
	
	Object result = _test.evaluateAtCompileTime();
	if (result != null && result instanceof Boolean) {
	    _ignore = !((Boolean) result).booleanValue();
	}

	parseChildren(parser);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	if (_test.typeCheck(stable) instanceof BooleanType == false) {
	    _test = new CastExpr(_test, Type.Boolean);
	}
	
	if (!_ignore) {
	    typeCheckContents(stable);
	}
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	_test.translateDesynthesized(classGen, methodGen);
	
	final InstructionHandle truec = il.getEnd();
	if (!_ignore) {
	    translateContents(classGen, methodGen);
	}
	_test.backPatchFalseList(il.append(NOP));
	_test.backPatchTrueList(truec.getNext());
    }
}
"
org.apache.xalan.processor.StopParseException,1,4,0,2,2,0,2,0,0,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"
package org.apache.xalan.processor;


public class StopParseException extends org.xml.sax.SAXException
{

  
  StopParseException()
  {
    super(""Stylesheet PIs found, stop the parse"");
  }
}
"
org.apache.xml.utils.res.XResources_he,3,4,0,1,4,1,0,1,2,0.5,426,0.0,0,0.976190476,1.0,0,0,140.6666667,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_he extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""he"" }, { ""help_language"", ""he"" }, { ""language"", ""he"" },
    { ""alphabet"",
      new char[]{ 0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6,
                  0x05D7, 0x05D8, 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD,
                  0x05DE, 0x05DF, 0x05E0, 0x05E1 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""RightToLeft"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    { ""numberGroups"", new int[]{ 10, 1 } },

    
    
    
    
    { ""digits"",
      new char[]{ 0x05D0, 0x05D1, 0x05D2, 0x05D3, 0x05D4, 0x05D5, 0x05D6,
                  0x05D7, 0x05D8 } },
    { ""tens"",
      new char[]{ 0x05D9, 0x05DA, 0x05DB, 0x05DC, 0x05DD, 0x05DE, 0x05DF,
                  0x05E0, 0x05E1 } },

    
    { ""tables"", new String[]{ ""tens"", ""digits"" } }
  };
}
"
org.apache.xalan.processor.StylesheetPIHandler,6,2,0,3,26,3,1,2,6,0.733333333,462,0.0,0,0.772727273,0.458333333,1,1,75.0,2,1.0,0,"
package org.apache.xalan.processor;

import org.xml.sax.helpers.DefaultHandler;
import javax.xml.transform.TransformerException;
import org.xml.sax.InputSource;
import org.xml.sax.Attributes;

import java.util.Vector;
import java.util.StringTokenizer;

import javax.xml.transform.Source;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.URIResolver;

import org.apache.xml.utils.SystemIDResolver;


public class StylesheetPIHandler extends DefaultHandler
{
  
  String m_baseID;

  
  String m_media;

  
  String m_title;

  
  String m_charset;

  
  Vector m_stylesheets = new Vector();
  
  
  
  
  URIResolver m_uriResolver;

  
  public void setURIResolver(URIResolver resolver)
  {
    m_uriResolver = resolver;
  }

  
  public URIResolver getURIResolver()
  {
    return m_uriResolver;
  }

  
  public StylesheetPIHandler(String baseID, String media, String title,
                             String charset)
  {

    m_baseID = baseID;
    m_media = media;
    m_title = title;
    m_charset = charset;
  }

  
  public Source getAssociatedStylesheet()
  {

    int sz = m_stylesheets.size();

    if (sz > 0)
    {
      Source source = (Source) m_stylesheets.elementAt(sz-1);
      return source;      
    }
    else
      return null;
  }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {

    if (target.equals(""xml-stylesheet""))
    {
      String href = null;  
      String type = null;  
      String title = null;  
      String media = null;  
      String charset = null;  
      boolean alternate = false;  
      StringTokenizer tokenizer = new StringTokenizer(data, "" 	=
"", true);
      boolean lookedAhead = false; 
      Source source = null;

      String token = """";
      while (tokenizer.hasMoreTokens())
      {        
        if (!lookedAhead)
          token = tokenizer.nextToken();
        else
          lookedAhead = false;
        if (tokenizer.hasMoreTokens() && 
               (token.equals("" "") || token.equals(""	"") || token.equals(""="")))
          continue;
          
        String name = token;  
        if (name.equals(""type""))
        { 
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          type = token.substring(1, token.length() - 1);
          
        }
        else if (name.equals(""href""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          href = token;
          if (tokenizer.hasMoreTokens())
          {
            token = tokenizer.nextToken();
            
            
            
            
            
            
            
            
            while ( token.equals(""="") && tokenizer.hasMoreTokens())
            {  
              href = href + token + tokenizer.nextToken();
              if (tokenizer.hasMoreTokens())
              {  
                token = tokenizer.nextToken();
                lookedAhead = true;
              }
              else
              {
                break;
              }
            }
          }
          href = href.substring(1, href.length() - 1);
          try
          { 
            
            if (m_uriResolver != null) 
            {
              source = m_uriResolver.resolve(href, m_baseID);
            } 
           else 
            {
              href = SystemIDResolver.getAbsoluteURI(href, m_baseID);
              source = new SAXSource(new InputSource(href));
            }            
          }
          catch(TransformerException te)
          {
            throw new org.xml.sax.SAXException(te);
          }
        }
        else if (name.equals(""title""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          title = token.substring(1, token.length() - 1);
        }
        else if (name.equals(""media""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          media = token.substring(1, token.length() - 1);
        }
        else if (name.equals(""charset""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
              (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          charset = token.substring(1, token.length() - 1);
        }
        else if (name.equals(""alternate""))
        {
          token = tokenizer.nextToken();
          while (tokenizer.hasMoreTokens() && 
               (token.equals("" "" ) || token.equals(""	"") || token.equals(""="")))
            token = tokenizer.nextToken();
          alternate = token.substring(1, token.length()
                                             - 1).equals(""yes"");
        }
        
      }

      if ((null != type) 
          && (type.equals(""text/xsl"") || type.equals(""text/xml"") || type.equals(""application/xml+xslt""))  
          && (null != href))
      {
        if (null != m_media)
        {
          if (null != media)
          {
            if (!media.equals(m_media))
              return;
          }
          else
            return;
        }

        if (null != m_charset)
        {
          if (null != charset)
          {
            if (!charset.equals(m_charset))
              return;
          }
          else
            return;
        }

        if (null != m_title)
        {
          if (null != title)
          {
            if (!title.equals(m_title))
              return;
          }
          else
            return;
        }

        m_stylesheets.addElement(source);
      }
    }
  }
  
  
  
  public void startElement(
          String namespaceURI, String localName, String qName, Attributes atts)
            throws org.xml.sax.SAXException
  {
    throw new StopParseException();
  }
}
"
org.apache.xalan.xsltc.compiler.CastExpr,9,3,0,58,46,0,33,25,8,0.583333333,508,1.0,2,0.91025641,0.3125,2,7,55.11111111,5,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class CastExpr extends Expression {
    private final Expression _left;

    
    static private MultiHashtable InternalTypeMap = new MultiHashtable();

    static {
	
	InternalTypeMap.put(Type.Boolean, Type.Boolean);
	InternalTypeMap.put(Type.Boolean, Type.Real);
	InternalTypeMap.put(Type.Boolean, Type.String);
	InternalTypeMap.put(Type.Boolean, Type.Reference);

	InternalTypeMap.put(Type.Real, Type.Real);
	InternalTypeMap.put(Type.Real, Type.Int);
	InternalTypeMap.put(Type.Real, Type.Boolean);
	InternalTypeMap.put(Type.Real, Type.String);
	InternalTypeMap.put(Type.Real, Type.Reference);

	InternalTypeMap.put(Type.Int, Type.Int);
	InternalTypeMap.put(Type.Int, Type.Real);
	InternalTypeMap.put(Type.Int, Type.Boolean);
	InternalTypeMap.put(Type.Int, Type.String);
	InternalTypeMap.put(Type.Int, Type.Reference);

	InternalTypeMap.put(Type.String, Type.String);
	InternalTypeMap.put(Type.String, Type.Boolean);
	InternalTypeMap.put(Type.String, Type.Real);
	InternalTypeMap.put(Type.String, Type.Reference);

	InternalTypeMap.put(Type.NodeSet, Type.NodeSet);
	InternalTypeMap.put(Type.NodeSet, Type.Boolean);
	InternalTypeMap.put(Type.NodeSet, Type.Real);
	InternalTypeMap.put(Type.NodeSet, Type.String);
	InternalTypeMap.put(Type.NodeSet, Type.Node);
	InternalTypeMap.put(Type.NodeSet, Type.Reference);
	InternalTypeMap.put(Type.NodeSet, Type.Object);

	InternalTypeMap.put(Type.Node, Type.Node);
	InternalTypeMap.put(Type.Node, Type.Boolean);
	InternalTypeMap.put(Type.Node, Type.Real);
	InternalTypeMap.put(Type.Node, Type.String);
	InternalTypeMap.put(Type.Node, Type.NodeSet);
	InternalTypeMap.put(Type.Node, Type.Reference);
	InternalTypeMap.put(Type.Node, Type.Object);

	InternalTypeMap.put(Type.ResultTree, Type.ResultTree);
	InternalTypeMap.put(Type.ResultTree, Type.Boolean);
	InternalTypeMap.put(Type.ResultTree, Type.Real);
	InternalTypeMap.put(Type.ResultTree, Type.String);
	InternalTypeMap.put(Type.ResultTree, Type.NodeSet);
	InternalTypeMap.put(Type.ResultTree, Type.Reference);
	InternalTypeMap.put(Type.ResultTree, Type.Object);

	InternalTypeMap.put(Type.Reference, Type.Reference);
	InternalTypeMap.put(Type.Reference, Type.Boolean);
	InternalTypeMap.put(Type.Reference, Type.Int);
	InternalTypeMap.put(Type.Reference, Type.Real);
	InternalTypeMap.put(Type.Reference, Type.String);
	InternalTypeMap.put(Type.Reference, Type.Node);
	InternalTypeMap.put(Type.Reference, Type.NodeSet);
	InternalTypeMap.put(Type.Reference, Type.ResultTree);
	InternalTypeMap.put(Type.Reference, Type.Object);

	InternalTypeMap.put(Type.Object, Type.String);

	InternalTypeMap.put(Type.Void, Type.String);
    }

    private boolean _typeTest = false;

    
    public CastExpr(Expression left, Type type) throws TypeCheckError {
	_left = left;
	_type = type;		

	if ((_left instanceof Step) && (_type == Type.Boolean)) {
	    Step step = (Step)_left;
	    if ((step.getAxis() == Axis.SELF) && (step.getNodeType() != -1)) 
		_typeTest = true;
	}
	
	
	setParser(left.getParser());
	setParent(left.getParent());
	left.setParent(this);
	typeCheck(left.getParser().getSymbolTable());
    }
		
    public Expression getExpr() {
	return _left;
    }

    
    public boolean hasPositionCall() {
	return(_left.hasPositionCall());
    }

    public boolean hasLastCall() {
	return(_left.hasLastCall());
    }

    public String toString() {
	return ""cast("" + _left + "", "" + _type + "")"";
    }

    	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	Type tleft = _left.getType();
	if (tleft == null) {
	    tleft = _left.typeCheck(stable);
	}
	if (tleft instanceof NodeType) {
	    tleft = Type.Node;	
	}
	else if (tleft instanceof ResultTreeType) {
	    tleft = Type.ResultTree; 
	}
	if (InternalTypeMap.maps(tleft, _type) != null) {
	    return _type;
	}
	throw new TypeCheckError(this);	
    }

    public void translateDesynthesized(ClassGenerator classGen, 
				       MethodGenerator methodGen) {
	FlowList fl;
	final Type ltype = _left.getType();

	
	
	
	if (_typeTest) {
	    final ConstantPoolGen cpg = classGen.getConstantPool();
	    final InstructionList il = methodGen.getInstructionList();

	    final int idx = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getType"", ""(I)I"");
	    il.append(new SIPUSH((short)((Step)_left).getNodeType()));
	    il.append(methodGen.loadDOM());
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(idx, 2));
	    _falseList.add(il.append(new IF_ICMPNE(null)));
	}
	else {

	    _left.translate(classGen, methodGen);
	    if (_type != ltype) {
		_left.startResetIterator(classGen, methodGen);
		if (_type instanceof BooleanType) {
		    fl = ltype.translateToDesynthesized(classGen, methodGen,
							_type);
		    if (fl != null) {
			_falseList.append(fl);
		    }
		}
		else {
		    ltype.translateTo(classGen, methodGen, _type);	
		}
	    }
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Type ltype = _left.getType();
	_left.translate(classGen, methodGen);
	if (_type.identicalTo(ltype) == false) {
	    _left.startResetIterator(classGen, methodGen);
	    ltype.translateTo(classGen, methodGen, _type);
	}
    }
}
"
org.apache.xml.utils.res.XResources_hy,3,4,0,1,4,1,0,1,2,0.5,614,0.0,0,0.976190476,1.0,0,0,203.3333333,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_hy extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""hy"" }, { ""help_language"", ""hy"" }, { ""language"", ""hy"" },
    { ""alphabet"",
      new char[]{ 0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567,
                  0x0568, 0x0569, 0x056A, 0x056B, 0x056C, 0x056D, 0x056E,
                  0x056F, 0x0567, 0x0568, 0x0572, 0x0573, 0x0574, 0x0575,
                  0x0576, 0x0577, 0x0578, 0x0579, 0x057A, 0x057B, 0x057C,
                  0x057D, 0x057E, 0x057F, 0x0580, 0x0581, 0x0582, 0x0583,
                  0x0584 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    { ""numberGroups"", new int[]{ 1000, 100, 10, 1 } },

    
    
    
    
    { ""digits"",
      new char[]{ 0x0561, 0x0562, 0x0563, 0x0564, 0x0565, 0x0566, 0x0567,
                  0x0568, 0x0569 } },
    { ""tens"",
      new char[]{ 0x056A, 0x056B, 0x056C, 0x056D, 0x056E, 0x056F, 0x0567,
                  0x0568, 0x0572 } },
    { ""hundreds"",
      new char[]{ 0x0573, 0x0574, 0x0575, 0x0576, 0x0577, 0x0578, 0x0579,
                  0x057A, 0x057B } },
    { ""thousands"",
      new char[]{ 0x057C, 0x057D, 0x057E, 0x057F, 0x0580, 0x0581, 0x0582,
                  0x0583, 0x0584 } },
    { ""tables"", new String[]{ ""thousands"", ""hundreds"", ""tens"", ""digits"" } }
  };
}
"
org.apache.xalan.templates.ElemValueOf,11,3,0,17,41,15,3,15,10,0.7,228,1.0,1,0.951456311,0.233766234,2,5,19.45454545,4,1.2727,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xalan.trace.SelectionEvent;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultTreeHandler;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.XMLString;

import javax.xml.transform.TransformerException;


public class ElemValueOf extends ElemTemplateElement
{

  
  private XPath m_selectExpression = null;

  
  private boolean m_isDot = false;

  
  public void setSelect(XPath v)
  {

    if (null != v)
    {
      String s = v.getPatternString();

      m_isDot = (null != s) && s.equals(""."");
    }

    m_selectExpression = v;
  }

  
  public XPath getSelect()
  {
    return m_selectExpression;
  }

  
  private boolean m_disableOutputEscaping = false;

  
  public void setDisableOutputEscaping(boolean v)
  {
    m_disableOutputEscaping = v;
  }

  
  public boolean getDisableOutputEscaping()
  {
    return m_disableOutputEscaping;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_VALUEOF;
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {

    super.compose(sroot);

    java.util.Vector vnames = sroot.getComposeState().getVariableNames();

    if (null != m_selectExpression)
      m_selectExpression.fixupVariables(
        vnames, sroot.getComposeState().getGlobalsSize());
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_VALUEOF_STRING;
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    XPathContext xctxt = transformer.getXPathContext();
    ResultTreeHandler rth = transformer.getResultTreeHandler();

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    try
    {
      
      if (false && m_isDot && !TransformerImpl.S_DEBUG)
      {
        int child = xctxt.getCurrentNode();
        DTM dtm = xctxt.getDTM(child);

        xctxt.pushCurrentNode(child);

        if (m_disableOutputEscaping)
          rth.processingInstruction(
            javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");

        try
        {
          dtm.dispatchCharactersEvents(child, rth, false);
        }
        finally
        {
          if (m_disableOutputEscaping)
            rth.processingInstruction(
              javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");

          xctxt.popCurrentNode();
        }
      }
      else
      {
        xctxt.pushNamespaceContext(this);

        int current = xctxt.getCurrentNode();

        xctxt.pushCurrentNodeAndExpression(current, current);

        if (m_disableOutputEscaping)
          rth.processingInstruction(
            javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");

        try
        {
          Expression expr = m_selectExpression.getExpression();

          if (TransformerImpl.S_DEBUG)
          {
            XObject obj = expr.execute(xctxt);

            transformer.getTraceManager().fireSelectedEvent(current, this,
                    ""select"", m_selectExpression, obj);
            obj.dispatchCharactersEvents(rth);
          }
          else
          {
            expr.executeCharsToContentHandler(xctxt, rth);
          }
        }
        finally
        {
          if (m_disableOutputEscaping)
            rth.processingInstruction(
              javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");

          xctxt.popNamespaceContext();
          xctxt.popCurrentNodeAndExpression();
        }
      }
    }
    catch (SAXException se)
    {
      throw new TransformerException(se);
    }
    catch (RuntimeException re) {
    	TransformerException te = new TransformerException(re);
    	te.setLocator(this);
    	throw te;
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
	    transformer.getTraceManager().fireTraceEndEvent(this); 
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  		m_selectExpression.getExpression().callVisitors(m_selectExpression, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xalan.xsltc.runtime.Parameter,2,1,0,2,3,0,2,0,2,0.0,29,0.0,0,0.0,0.875,0,0,12.0,0,0.0,0,"

package org.apache.xalan.xsltc.runtime;

public class Parameter {

    public String  _name;
    public Object  _value;
    public boolean _isDefault;

    public Parameter(String name, Object value) {
	_name = name;
	_value = value;
	_isDefault = true;
    }

    public Parameter(String name, Object value, boolean isDefault) {
	_name = name;
	_value = value;
	_isDefault = isDefault;
    }
}
"
org.apache.xalan.xsltc.compiler.FlowList,7,1,0,29,17,0,26,3,7,0.0,155,1.0,0,0.0,0.464285714,0,0,21.0,4,1.8571,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Iterator;
import org.apache.bcel.generic.*;

public final class FlowList {
    private Vector _elements;

    public FlowList() {
	_elements = null;
    }

    public FlowList(InstructionHandle bh) {
	_elements = new Vector();
	_elements.addElement(bh);
    }

    public FlowList(FlowList list) {
	_elements = list._elements;
    }

    public FlowList add(InstructionHandle bh) {
	if (_elements == null) {
	    _elements = new Vector();
	}
	_elements.addElement(bh);
	return this;
    }

    public FlowList append(FlowList right) {
	if (_elements == null) {
	    _elements = right._elements;
	}
	else {
	    final Vector temp = right._elements;
	    if (temp != null) {
		final int n = temp.size();
		for (int i = 0; i < n; i++) {
		    _elements.addElement(temp.elementAt(i));
		}
	    }
	}
	return this;
    }

    
    public void backPatch(InstructionHandle target) {
	if (_elements != null) {
	    final int n = _elements.size();
	    for (int i = 0; i < n; i++) {
		BranchHandle bh = (BranchHandle)_elements.elementAt(i);
		bh.setTarget(target);
	    }
	    _elements.clear();		
	}
    }

    
    public FlowList copyAndRedirect(InstructionList oldList, 
	InstructionList newList) 
    {
	final FlowList result = new FlowList();
	if (_elements == null) {
	    return result;
	}

	final int n = _elements.size();
	final Iterator oldIter = oldList.iterator();
	final Iterator newIter = newList.iterator();
	
	while (oldIter.hasNext()) {
	    final InstructionHandle oldIh = (InstructionHandle) oldIter.next();
	    final InstructionHandle newIh = (InstructionHandle) newIter.next();

	    for (int i = 0; i < n; i++) {
		if (_elements.elementAt(i) == oldIh) {
		    result.add(newIh);
		}
	    }
	}
	return result;
    }
}
"
org.apache.xalan.templates.Constants,1,1,0,0,2,0,0,0,1,2.0,353,0.0,0,0.0,1.0,0,0,3.0,0,0.0,1,"
package org.apache.xalan.templates;

import org.apache.xml.utils.res.XResourceBundle;


public class Constants
{

  
  public static final String 
	S_XMLNAMESPACEURI = ""http:
	S_XSLNAMESPACEURL = ""http:
	S_OLDXSLNAMESPACEURL = ""http:

  
  public static final String 
	S_VENDOR = ""Apache Software Foundation"", 
	S_VENDORURL = ""http:

  
  public static final String 
    S_BUILTIN_EXTENSIONS_URL = ""http:
  
  
  public static final String 
    S_EXTENSIONS_JAVA_URL = ""http:
    S_EXTENSIONS_LOTUSXSL_JAVA_URL = ""http:
    S_EXTENSIONS_XALANLIB_URL = ""http:
  
  
  public static final String
    S_EXSLT_COMMON_URL = ""http:
    S_EXSLT_MATH_URL = ""http:
    S_EXSLT_SETS_URL = ""http:
    S_EXSLT_DATETIME_URL = ""http:
    S_EXSLT_FUNCTIONS_URL = ""http:
    
    
  
  public static final double XSLTVERSUPPORTED = 1.0;

  
  public static final int ELEMNAME_UNDEFINED = -1, ELEMNAME_WITHPARAM = 2,
                          ELEMNAME_ADDATTRIBUTE = 4, ELEMNAME_ANCHOR = 22,

  
  ELEMNAME_APPLY_TEMPLATES = 50, ELEMNAME_USE = 34, ELEMNAME_CHILDREN = 6,
                                 ELEMNAME_CHOOSE = 37, ELEMNAME_COMMENT = 59,  
                                 ELEMNAME_CONSTRUCT = 7,  
                                 ELEMNAME_CONTENTS = 8, ELEMNAME_COPY = 9,
                                 ELEMNAME_COPY_OF = 74,
                                 ELEMNAME_DECIMALFORMAT = 83,
                                 ELEMNAME_DEFINEATTRIBUTESET = 40,

  
  
  ELEMNAME_DEFINESCRIPT = 11, ELEMNAME_DISPLAYIF = 12,  
                              ELEMNAME_EMPTY = 14, ELEMNAME_EVAL = 15,
                              ELEMNAME_EXPECTEDCHILDREN = 16,
                              ELEMNAME_EXTENSION = 54,
                              ELEMNAME_EXTENSIONHANDLER = 63,
                              ELEMNAME_FOREACH = 28, ELEMNAME_KEY = 31,
                              ELEMNAME_IF = 36, ELEMNAME_IMPORT = 26,
                              ELEMNAME_INCLUDE = 27,
                              ELEMNAME_CALLTEMPLATE = 17,
                              ELEMNAME_PARAMVARIABLE = 41,
                              ELEMNAME_NUMBER = 35, ELEMNAME_NSALIAS = 84,
                              ELEMNAME_OTHERWISE = 39, ELEMNAME_PI = 58,
                              ELEMNAME_PRESERVESPACE = 33,
                              ELEMNAME_REMOVEATTRIBUTE = 5,
                              ELEMNAME_TEMPLATE = 19, ELEMNAME_SORT = 64,
                              ELEMNAME_STRIPSPACE = 32,
                              ELEMNAME_STYLESHEET = 25, ELEMNAME_TEXT = 42,
                              ELEMNAME_VALUEOF = 30, ELEMNAME_WHEN = 38,

  
  ELEMNAME_ROOT = 44, ELEMNAME_ANY = 45, ELEMNAME_ELEMENT = 46,
                      ELEMNAME_TARGETELEMENT = 47, ELEMNAME_ATTRIBUTE = 48,
                      ELEMNAME_TARGETATTRIBUTE = 49, ELEMNAME_URL = 52,  
                      ELEMNAME_CALL = 55,  

  
  ELEMNAME_FALLBACK = 57,  
  ELEMNAME_TARGETPI = 60,  
  ELEMNAME_TARGETCOMMENT = 61,  
  ELEMNAME_TARGETTEXT = 62,  
  ELEMNAME_CSSSTYLECONVERSION = 65,  
  ELEMNAME_COUNTER = 66, ELEMNAME_COUNTERS = 67,
  ELEMNAME_COUNTERINCREMENT = 68, ELEMNAME_COUNTERRESET = 69,
  ELEMNAME_COUNTERSCOPE = 71, ELEMNAME_APPLY_IMPORTS = 72,
  ELEMNAME_VARIABLE = 73, ELEMNAME_MESSAGE = 75, ELEMNAME_LOCALE = 76,
  ELEMNAME_LITERALRESULT = 77, ELEMNAME_TEXTLITERALRESULT = 78,
  ELEMNAME_EXTENSIONCALL = 79, ELEMNAME_EXTENSIONDECL = 85,
  ELEMNAME_EXTENSIONSCRIPT = 86, ELEMNAME_OUTPUT = 80,
  ELEMNAME_COMPONENT = 81, ELEMNAME_SCRIPT = 82;

  

  
  public static final String       
	  ELEMNAME_ANCHOR_STRING = ""anchor"",
      ELEMNAME_ANY_STRING = ""any"",  
      ELEMNAME_APPLY_IMPORTS_STRING = ""apply-imports"",
      ELEMNAME_APPLY_TEMPLATES_STRING = ""apply-templates"",
      ELEMNAME_ARG_STRING = ""arg"",
      ELEMNAME_ATTRIBUTESET_STRING = ""attribute-set"",
      ELEMNAME_ATTRIBUTE_STRING = ""attribute"",  
      ELEMNAME_CALLTEMPLATEARG_STRING = ""invoke-arg"",
      ELEMNAME_CALLTEMPLATE_STRING = ""call-template"",
      ELEMNAME_CALL_STRING = ""call"",
      ELEMNAME_CHILDREN_STRING = ""children"",
      ELEMNAME_CHOOSE_STRING = ""choose"",
      ELEMNAME_COMMENT_STRING = ""comment"",
      ELEMNAME_COMPONENT_STRING = ""component"",
      ELEMNAME_CONSTRUCT_STRING = ""construct"",  
      ELEMNAME_CONTENTS_STRING = ""contents"", 
      ELEMNAME_COPY_OF_STRING =""copy-of"",
      ELEMNAME_COPY_STRING = ""copy"",
      ELEMNAME_COUNTERINCREMENT_STRING = ""counter-increment"",
      ELEMNAME_COUNTERRESET_STRING = ""counter-reset"",
      ELEMNAME_COUNTERSCOPE_STRING = ""counter-scope"",
      ELEMNAME_COUNTERS_STRING = ""counters"",
      ELEMNAME_COUNTER_STRING = ""counter"",
      ELEMNAME_CSSSTYLECONVERSION_STRING = ""css-style-conversion"",
      ELEMNAME_DECIMALFORMAT_STRING = ""decimal-format"",
      ELEMNAME_DISPLAYIF_STRING = ""display-if"",  
      ELEMNAME_ELEMENT_STRING = ""element"",  
      ELEMNAME_EMPTY_STRING = ""empty"",
      ELEMNAME_EVAL_STRING = ""eval"",
      ELEMNAME_EXPECTEDCHILDREN_STRING = ""expectedchildren"",
      ELEMNAME_EXTENSIONHANDLER_STRING = ""code-dispatcher"",
      ELEMNAME_EXTENSION_STRING = ""functions"",
      ELEMNAME_FALLBACK_STRING = ""fallback"",
      ELEMNAME_FOREACH_STRING = ""for-each"",
      ELEMNAME_IF_STRING = ""if"",
      ELEMNAME_IMPORT_STRING = ""import"",
      ELEMNAME_INCLUDE_STRING = ""include"",
      ELEMNAME_KEY_STRING = ""key"",
      ELEMNAME_LOCALE_STRING = ""locale"",
      ELEMNAME_MESSAGE_STRING = ""message"",
      ELEMNAME_NSALIAS_STRING = ""namespace-alias"",
      ELEMNAME_NUMBER_STRING = ""number"",
      ELEMNAME_OTHERWISE_STRING = ""otherwise"",
      ELEMNAME_OUTPUT_STRING = ""output"",
      ELEMNAME_PARAMVARIABLE_STRING = ""param"",
      ELEMNAME_PI_OLD_STRING = ""pi"",
      ELEMNAME_PI_STRING = ""processing-instruction"",
      ELEMNAME_PRESERVESPACE_STRING = ""preserve-space"",
      ELEMNAME_ROOT_STRING = ""root"",  
      ELEMNAME_SCRIPT_STRING = ""script"",
      ELEMNAME_SORT_STRING = ""sort"",
      ELEMNAME_STRIPSPACE_STRING = ""strip-space"",
      ELEMNAME_STYLESHEET_STRING = ""stylesheet"",
      ELEMNAME_TARGETATTRIBUTE_STRING = ""target-attribute"",  
      ELEMNAME_TARGETCOMMENT_STRING = ""target-comment"",
      ELEMNAME_TARGETELEMENT_STRING = ""target-element"",  
      ELEMNAME_TARGETPI_STRING = ""target-pi"",
      ELEMNAME_TARGETTEXT_STRING = ""target-text"",
      ELEMNAME_TEMPLATE_STRING = ""template"",
      ELEMNAME_TEXT_STRING = ""text"",
      ELEMNAME_TRANSFORM_STRING = ""transform"",
      ELEMNAME_URL_STRING = ""uri"",  
      ELEMNAME_USE_STRING = ""use"",
      ELEMNAME_VALUEOF_STRING = ""value-of"",
      ELEMNAME_VARIABLE_STRING = ""variable"",
      ELEMNAME_WHEN_STRING = ""when"",
      ELEMNAME_WITHPARAM_STRING = ""with-param"";
  
  
  public static final String
    EXSLT_ELEMNAME_FUNCTION_STRING = ""function"",
    EXSLT_ELEMNAME_FUNCRESULT_STRING = ""result"";
  public static final int
    EXSLT_ELEMNAME_FUNCTION = 88,
    EXSLT_ELEMNAME_FUNCRESULT = 89;
  
  
  
  public static final String
	  ATTRNAME_AMOUNT = ""amount"",
      ATTRNAME_ANCESTOR = ""ancestor"",
      ATTRNAME_ARCHIVE = ""archive"",
      ATTRNAME_ATTRIBUTE = ""attribute"",
      ATTRNAME_ATTRIBUTE_SET = ""attribute-set"",
      ATTRNAME_CASEORDER = ""case-order"",
      ATTRNAME_CLASS = ""class"",
      ATTRNAME_CLASSID = ""classid"",
      ATTRNAME_CODEBASE = ""codebase"",
      ATTRNAME_CODETYPE = ""type"",
      ATTRNAME_CONDITION = ""condition"",
      ATTRNAME_COPYTYPE = ""copy-type"",
      ATTRNAME_COUNT = ""count"",
      ATTRNAME_DATATYPE = ""data-type"",
      ATTRNAME_DECIMALSEPARATOR = ""decimal-separator"",
      ATTRNAME_DEFAULT = ""default"",
      ATTRNAME_DEFAULTSPACE = ""default-space"",
      ATTRNAME_DEPTH = ""with-children"",
      ATTRNAME_DIGIT = ""digit"",
      ATTRNAME_DIGITGROUPSEP = ""digit-group-sep"",
      ATTRNAME_DISABLE_OUTPUT_ESCAPING = ""disable-output-escaping"",
      ATTRNAME_ELEMENT = ""element"",
      ATTRNAME_ELEMENTS = ""elements"",
      ATTRNAME_EXCLUDE_RESULT_PREFIXES =""exclude-result-prefixes"",
      ATTRNAME_EXPR = ""expr"",
      ATTRNAME_EXTENSIONELEMENTPREFIXES = ""extension-element-prefixes"",
      ATTRNAME_FORMAT = ""format"",
      ATTRNAME_FROM = ""from"",
      ATTRNAME_GROUPINGSEPARATOR = ""grouping-separator"",
      ATTRNAME_GROUPINGSIZE = ""grouping-size"",
      ATTRNAME_HREF = ""href"",
      ATTRNAME_ID = ""id"",
      ATTRNAME_IMPORTANCE = ""importance"",
      ATTRNAME_INDENTRESULT = ""indent-result"",
      ATTRNAME_INFINITY = ""infinity"",
      ATTRNAME_LANG = ""lang"",
      ATTRNAME_LETTERVALUE = ""letter-value"",
      ATTRNAME_LEVEL = ""level"",
      ATTRNAME_MATCH = ""match"",
      ATTRNAME_METHOD = ""calls"",
      ATTRNAME_MINUSSIGN = ""minus-sign"",
      ATTRNAME_MODE = ""mode"",
      ATTRNAME_NAME = ""name"",
      ATTRNAME_NAMESPACE = ""namespace"",
      ATTRNAME_NAN = ""NaN"",
      ATTRNAME_NDIGITSPERGROUP = ""n-digits-per-group"",
      ATTRNAME_NS = ""ns"",
      ATTRNAME_ONLY = ""only"",
      ATTRNAME_ORDER = ""order"",
      ATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = ""cdata-section-elements"",
      ATTRNAME_OUTPUT_DOCTYPE_PUBLIC = ""doctype-public"",
      ATTRNAME_OUTPUT_DOCTYPE_SYSTEM = ""doctype-system"",
      ATTRNAME_OUTPUT_ENCODING = ""encoding"",
      ATTRNAME_OUTPUT_INDENT = ""indent"",
      ATTRNAME_OUTPUT_MEDIATYPE = ""media-type"",
      ATTRNAME_OUTPUT_METHOD = ""method"",  
      ATTRNAME_OUTPUT_OMITXMLDECL = ""omit-xml-declaration"",
      ATTRNAME_OUTPUT_STANDALONE = ""standalone"",
      ATTRNAME_OUTPUT_VERSION = ""version"",
      ATTRNAME_PATTERNSEPARATOR = ""pattern-separator"",
      ATTRNAME_PERCENT = ""percent"",
      ATTRNAME_PERMILLE = ""per-mille"",
      ATTRNAME_PRIORITY = ""priority"",
      ATTRNAME_REFID = ""refID"",
      ATTRNAME_RESULTNS = ""result-ns"",
      ATTRNAME_RESULT_PREFIX = ""result-prefix"",
      ATTRNAME_SELECT = ""select"",
      ATTRNAME_SEQUENCESRC = ""sequence-src"",
      ATTRNAME_STYLE = ""style"",
      ATTRNAME_STYLESHEET_PREFIX = ""stylesheet-prefix"",
      ATTRNAME_TERMINATE = ""terminate"",
      ATTRNAME_TEST = ""test"",
      ATTRNAME_TOSTRING = ""to-string"",
      ATTRNAME_TYPE = ""type"",
      ATTRNAME_USE = ""use"",
      ATTRNAME_USEATTRIBUTESETS = ""use-attribute-sets"",
      ATTRNAME_VALUE = ""value"",
      ATTRNAME_VERSION = ""version"",
      ATTRNAME_XMLNS = ""xmlns:"", 
      ATTRNAME_XMLNSDEF = ""xmlns"", 
      ATTRNAME_XMLSPACE = ""xml:space"", 
      ATTRNAME_ZERODIGIT = ""zero-digit"";

  
  public static final int TATTRNAME_OUTPUT_METHOD = 1, TATTRNAME_AMOUNT = 2,
                          TATTRNAME_ANCESTOR = 3, TATTRNAME_ARCHIVE = 4,
                          TATTRNAME_ATTRIBUTE = 5,
                          TATTRNAME_ATTRIBUTE_SET = 6,
                          TATTRNAME_CASEORDER = 7, TATTRNAME_CLASS = 8,
                          TATTRNAME_CLASSID = 9, TATTRNAME_CODEBASE = 10,
                          TATTRNAME_CODETYPE = 11, TATTRNAME_CONDITION = 12,
                          TATTRNAME_COPYTYPE = 13, TATTRNAME_COUNT = 14,
                          TATTRNAME_DATATYPE = 15, TATTRNAME_DEFAULT = 16,
                          TATTRNAME_DEFAULTSPACE = 17, TATTRNAME_DEPTH = 18,
                          TATTRNAME_DIGITGROUPSEP = 19,
                          TATTRNAME_DISABLE_OUTPUT_ESCAPING = 20,
                          TATTRNAME_ELEMENT = 21, TATTRNAME_ELEMENTS = 22,
                          TATTRNAME_EXPR = 23,
                          TATTRNAME_EXTENSIONELEMENTPREFIXES = 24,
                          TATTRNAME_FORMAT = 25, TATTRNAME_FROM = 26,
                          TATTRNAME_GROUPINGSEPARATOR = 27,
                          TATTRNAME_GROUPINGSIZE = 28, TATTRNAME_HREF = 29,
                          TATTRNAME_ID = 30, TATTRNAME_IMPORTANCE = 31,
                          TATTRNAME_INDENTRESULT = 32, TATTRNAME_LANG = 33,
                          TATTRNAME_LETTERVALUE = 34, TATTRNAME_LEVEL = 35,
                          TATTRNAME_MATCH = 36, TATTRNAME_METHOD = 37,
                          TATTRNAME_MODE = 38, TATTRNAME_NAME = 39,
                          TATTRNAME_NAMESPACE = 40,
                          TATTRNAME_NDIGITSPERGROUP = 41, TATTRNAME_NS = 42,
                          TATTRNAME_ONLY = 43, TATTRNAME_ORDER = 44,
                          TATTRNAME_OUTPUT_CDATA_SECTION_ELEMENTS = 45,
                          TATTRNAME_OUTPUT_DOCTYPE_PUBLIC = 46,
                          TATTRNAME_OUTPUT_DOCTYPE_SYSTEM = 47,
                          TATTRNAME_OUTPUT_ENCODING = 48,
                          TATTRNAME_OUTPUT_INDENT = 49,
                          TATTRNAME_OUTPUT_MEDIATYPE = 50,
                          TATTRNAME_OUTPUT_STANDALONE = 51,
                          TATTRNAME_OUTPUT_VERSION = 52,
                          TATTRNAME_OUTPUT_OMITXMLDECL = 53,
                          TATTRNAME_PRIORITY = 54, TATTRNAME_REFID = 55,
                          TATTRNAME_RESULTNS = 56, TATTRNAME_SELECT = 57,
                          TATTRNAME_SEQUENCESRC = 58, TATTRNAME_STYLE = 59,
                          TATTRNAME_TEST = 60, TATTRNAME_TOSTRING = 61,
                          TATTRNAME_TYPE = 62, TATTRNAME_USE = 63,
                          TATTRNAME_USEATTRIBUTESETS = 64,
                          TATTRNAME_VALUE = 65, TATTRNAME_XMLNSDEF = 66,
                          TATTRNAME_XMLNS = 67, TATTRNAME_XMLSPACE = 68,
                          TATTRNAME_EXCLUDE_RESULT_PREFIXES = 69;

  
  public static final String ATTRVAL_OUTPUT_METHOD_HTML = ""html"",
                             ATTRVAL_OUTPUT_METHOD_XML = ""xml"",
                             ATTRVAL_OUTPUT_METHOD_TEXT = ""text"";

  
  
  public static final int ATTRVAL_PRESERVE = 1, ATTRVAL_STRIP = 2;

  
  
  public static final boolean ATTRVAL_YES = true, ATTRVAL_NO = false;

  
  
  public static final String ATTRVAL_ALPHABETIC = ""alphabetic"",
                             ATTRVAL_OTHER = ""other"",
                             ATTRVAL_TRADITIONAL = ""traditional"";

  
  
  public static final String ATTRVAL_SINGLE = ""single"",
                             ATTRVAL_MULTI = ""multiple"", ATTRVAL_ANY = ""any"";

  
  
  public static final String ATTRVAL_DEFAULT_PREFIX = ""#default"";

 
  public static final int NUMBERLETTER_ALPHABETIC = 1, NUMBERLETTER_TRADITIONAL = 2;
  
  
  public static final int NUMBERLEVEL_SINGLE = 1, NUMBERLEVEL_MULTI = 2,
                          NUMBERLEVEL_ANY = 3, MAX_MULTI_COUNTING_DEPTH = 32;

  
  
  public static final String ATTRVAL_THIS = ""."", ATTRVAL_PARENT = "".."",
                             ATTRVAL_ANCESTOR = ""ancestor"", ATTRVAL_ID = ""id"";

  
  
  public static final String ATTRVAL_DATATYPE_TEXT = ""text"",
                             ATTRVAL_DATATYPE_NUMBER = ""number"",
                             ATTRVAL_ORDER_ASCENDING = ""ascending"",
                             ATTRVAL_ORDER_DESCENDING = ""descending"",
                             ATTRVAL_CASEORDER_UPPER = ""upper-first"",
                             ATTRVAL_CASEORDER_LOWER = ""lower-first"";

 
  public static final int SORTDATATYPE_TEXT = 1, SORTDATATYPE_NUMBER = 2;

  
  public static final int SORTORDER_ASCENDING = 1, SORTORDER_DESCENDING = 2;
  
  
  public static final int SORTCASEORDER_UPPERFIRST = 1, SORTCASEORDER_LOWERFIRST = 2;
  
  
  public static final String ATTRVAL_INFINITY = ""Infinity"",
                             ATTRVAL_NAN = ""NaN"",
                             DEFAULT_DECIMAL_FORMAT = ""#default"";

  
  
  public static final String ATTRNAME_XXXX = ""XXXX"";
}
"
org.apache.xalan.templates.ElemFallback,5,3,0,5,12,10,2,3,5,2.0,39,0.0,0,0.98,0.7,2,4,6.8,1,0.8,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;


import org.apache.xalan.trace.SelectionEvent;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;


public class ElemFallback extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_FALLBACK;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_FALLBACK_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
  }

  
  public void executeFallback(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (Constants.ELEMNAME_EXTENSIONCALL == m_parentNode.getXSLToken())
    {

      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEvent(this);

      transformer.executeChildTemplates(this, true);

      if (TransformerImpl.S_DEBUG)
	    transformer.getTraceManager().fireTraceEndEvent(this); 
    }
    else
    {

      
      System.out.println(
        ""Error!  parent of xsl:fallback must be an extension element!"");
    }
  }
}
"
org.apache.xalan.templates.ElemEmpty,1,3,0,1,2,0,0,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xalan.transformer.TransformerImpl;


public class ElemEmpty extends ElemTemplateElement
{

  
  public ElemEmpty(){}
}
"
org.apache.xalan.res.XSLTErrorResources,8,3,0,1,21,28,1,0,7,1.142857143,430,0.0,0,0.857142857,0.225,0,0,17.375,2,0.875,3,"
package org.apache.xalan.res;

import java.io.IOException;
import java.io.InputStream;
import java.text.DecimalFormat;
import java.util.Locale;
import java.util.MissingResourceException;
import java.util.PropertyResourceBundle;
import java.util.ResourceBundle;


public class XSLTErrorResources extends PropertyResourceBundle
{
  public XSLTErrorResources()
  	throws java.io.IOException
  {
    super(null);
  }
  
  public XSLTErrorResources(InputStream is) 
  	throws java.io.IOException
  {
  	super(is);
  }

  
  public static final String ERROR_SUFFIX = ""ER"";

  
  public static final String WARNING_SUFFIX = ""WR"";













  

  
  public static final int ERROR0000 = 0;


  
  public static final int ER_NO_CURLYBRACE = 1;


  
  public static final int ER_ILLEGAL_ATTRIBUTE = 2;


  
  public static final int ER_NULL_SOURCENODE_APPLYIMPORTS = 3;


  
  public static final int ER_CANNOT_ADD = 4;


  
  public static final int ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES = 5;


  
  public static final int ER_NO_NAME_ATTRIB = 6;


  
  public static final int ER_TEMPLATE_NOT_FOUND = 7;


  
  public static final int ER_CANT_RESOLVE_NAME_AVT = 8;


  
  public static final int ER_REQUIRES_ATTRIB = 9;


  
  public static final int ER_MUST_HAVE_TEST_ATTRIB = 10;


  
  public static final int ER_BAD_VAL_ON_LEVEL_ATTRIB = 11;


  
  public static final int ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = 12;


  
  public static final int ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = 13;


  
  public static final int ER_NEED_MATCH_ATTRIB = 14;


  
  public static final int ER_NEED_NAME_OR_MATCH_ATTRIB = 15;


  
  public static final int ER_CANT_RESOLVE_NSPREFIX = 16;


  
  public static final int ER_ILLEGAL_VALUE = 17;


  
  public static final int ER_NO_OWNERDOC = 18;


  
  public static final int ER_ELEMTEMPLATEELEM_ERR = 19;


  
  public static final int ER_NULL_CHILD = 20;


  
  public static final int ER_NEED_SELECT_ATTRIB = 21;


  
  public static final int ER_NEED_TEST_ATTRIB = 22;


  
  public static final int ER_NEED_NAME_ATTRIB = 23;


  
  public static final int ER_NO_CONTEXT_OWNERDOC = 24;


  
  public static final int ER_COULD_NOT_CREATE_XML_PROC_LIAISON = 25;


  
  public static final int ER_PROCESS_NOT_SUCCESSFUL = 26;


  
  public static final int ER_NOT_SUCCESSFUL = 27;


  
  public static final int ER_ENCODING_NOT_SUPPORTED = 28;


  
  public static final int ER_COULD_NOT_CREATE_TRACELISTENER = 29;


  
  public static final int ER_KEY_REQUIRES_NAME_ATTRIB = 30;


  
  public static final int ER_KEY_REQUIRES_MATCH_ATTRIB = 31;


  
  public static final int ER_KEY_REQUIRES_USE_ATTRIB = 32;


  
  public static final int ER_REQUIRES_ELEMENTS_ATTRIB = 33;


  
  public static final int ER_MISSING_PREFIX_ATTRIB = 34;


  
  public static final int ER_BAD_STYLESHEET_URL = 35;


  
  public static final int ER_FILE_NOT_FOUND = 36;


  
  public static final int ER_IOEXCEPTION = 37;


  
  public static final int ER_NO_HREF_ATTRIB = 38;


  
  public static final int ER_STYLESHEET_INCLUDES_ITSELF = 39;


  
  public static final int ER_PROCESSINCLUDE_ERROR = 40;


  
  public static final int ER_MISSING_LANG_ATTRIB = 41;


  
  public static final int ER_MISSING_CONTAINER_ELEMENT_COMPONENT = 42;


  
  public static final int ER_CAN_ONLY_OUTPUT_TO_ELEMENT = 43;


  
  public static final int ER_PROCESS_ERROR = 44;


  
  public static final int ER_UNIMPLNODE_ERROR = 45;


  
  public static final int ER_NO_SELECT_EXPRESSION = 46;


  
  public static final int ER_CANNOT_SERIALIZE_XSLPROCESSOR = 47;


  
  public static final int ER_NO_INPUT_STYLESHEET = 48;


  
  public static final int ER_FAILED_PROCESS_STYLESHEET = 49;


  
  public static final int ER_COULDNT_PARSE_DOC = 50;


  
  public static final int ER_COULDNT_FIND_FRAGMENT = 51;


  
  public static final int ER_NODE_NOT_ELEMENT = 52;


  
  public static final int ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB = 53;


  
  public static final int ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB = 54;


  
  public static final int ER_NO_CLONE_OF_DOCUMENT_FRAG = 55;


  
  public static final int ER_CANT_CREATE_ITEM = 56;


  
  public static final int ER_XMLSPACE_ILLEGAL_VALUE = 57;


  
  public static final int ER_NO_XSLKEY_DECLARATION = 58;


  
  public static final int ER_CANT_CREATE_URL = 59;


  
  public static final int ER_XSLFUNCTIONS_UNSUPPORTED = 60;


  
  public static final int ER_PROCESSOR_ERROR = 61;


  
  public static final int ER_NOT_ALLOWED_INSIDE_STYLESHEET = 62;


  
  public static final int ER_RESULTNS_NOT_SUPPORTED = 63;


  
  public static final int ER_DEFAULTSPACE_NOT_SUPPORTED = 64;


  
  public static final int ER_INDENTRESULT_NOT_SUPPORTED = 65;


  
  public static final int ER_ILLEGAL_ATTRIB = 66;


  
  public static final int ER_UNKNOWN_XSL_ELEM = 67;


  
  public static final int ER_BAD_XSLSORT_USE = 68;


  
  public static final int ER_MISPLACED_XSLWHEN = 69;


  
  public static final int ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE = 70;


  
  public static final int ER_MISPLACED_XSLOTHERWISE = 71;


  
  public static final int ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE = 72;


  
  public static final int ER_NOT_ALLOWED_INSIDE_TEMPLATE = 73;


  
  public static final int ER_UNKNOWN_EXT_NS_PREFIX = 74;


  
  public static final int ER_IMPORTS_AS_FIRST_ELEM = 75;


  
  public static final int ER_IMPORTING_ITSELF = 76;


  
  public static final int ER_XMLSPACE_ILLEGAL_VAL = 77;


  
  public static final int ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL = 78;


  
  public static final int ER_SAX_EXCEPTION = 79;


  
  public static final int ER_FUNCTION_NOT_SUPPORTED = 80;


  
  public static final int ER_XSLT_ERROR = 81;


  
  public static final int ER_CURRENCY_SIGN_ILLEGAL = 82;


  
  public static final int ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM = 83;


  
  public static final int ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER = 84;


  
  public static final int ER_REDIRECT_COULDNT_GET_FILENAME = 85;


  
  public static final int ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT = 86;


  
  public static final int ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX = 87;


  
  public static final int ER_MISSING_NS_URI = 88;


  
  public static final int ER_MISSING_ARG_FOR_OPTION = 89;


  
  public static final int ER_INVALID_OPTION = 90;


  
  public static final int ER_MALFORMED_FORMAT_STRING = 91;


  
  public static final int ER_STYLESHEET_REQUIRES_VERSION_ATTRIB = 92;


  
  public static final int ER_ILLEGAL_ATTRIBUTE_VALUE = 93;


  
  public static final int ER_CHOOSE_REQUIRES_WHEN = 94;


  
  public static final int ER_NO_APPLY_IMPORT_IN_FOR_EACH = 95;


  
  public static final int ER_CANT_USE_DTM_FOR_OUTPUT = 96;


  
  public static final int ER_CANT_USE_DTM_FOR_INPUT = 97;


  
  public static final int ER_CALL_TO_EXT_FAILED = 98;


  
  public static final int ER_PREFIX_MUST_RESOLVE = 99;


  
  public static final int ER_INVALID_UTF16_SURROGATE = 100;


  
  public static final int ER_XSLATTRSET_USED_ITSELF = 101;


  
  public static final int ER_CANNOT_MIX_XERCESDOM = 102;


  
  public static final int ER_TOO_MANY_LISTENERS = 103;


  
  public static final int ER_IN_ELEMTEMPLATEELEM_READOBJECT = 104;


  
  public static final int ER_DUPLICATE_NAMED_TEMPLATE = 105;


  
  public static final int ER_INVALID_KEY_CALL = 106;

  
  
  public static final int ER_REFERENCING_ITSELF = 107;

  
  
  public static final int ER_ILLEGAL_DOMSOURCE_INPUT = 108;

	
	
  public static final int ER_CLASS_NOT_FOUND_FOR_OPTION = 109;

	
	
  public static final int ER_REQUIRED_ELEM_NOT_FOUND = 110;

  
  
  public static final int ER_INPUT_CANNOT_BE_NULL = 111;

  
  
  public static final int ER_URI_CANNOT_BE_NULL = 112;

  
  
  public static final int ER_FILE_CANNOT_BE_NULL = 113;

  
   
  public static final int ER_SOURCE_CANNOT_BE_NULL = 114;

  
  
  public static final int ER_CANNOT_OVERWRITE_CAUSE = 115;

  
  
  public static final int ER_CANNOT_INIT_BSFMGR = 116;

  
  
  public static final int ER_CANNOT_CMPL_EXTENSN = 117;

  
  
  public static final int ER_CANNOT_CREATE_EXTENSN = 118;

  
  
  public static final int ER_INSTANCE_MTHD_CALL_REQUIRES = 119;

  
  
  public static final int ER_INVALID_ELEMENT_NAME = 120;

  
   
  public static final int ER_ELEMENT_NAME_METHOD_STATIC = 121;

  
   
  public static final int ER_EXTENSION_FUNC_UNKNOWN = 122;

  
   
  public static final int ER_MORE_MATCH_CONSTRUCTOR = 123;

  
   
  public static final int ER_MORE_MATCH_METHOD = 124;

  
   
  public static final int ER_MORE_MATCH_ELEMENT = 125;

  
   
  public static final int ER_INVALID_CONTEXT_PASSED = 126;

  
   
  public static final int ER_POOL_EXISTS = 127;

  
   
  public static final int ER_NO_DRIVER_NAME = 128;

  
   
  public static final int ER_NO_URL = 129;

  
   
  public static final int ER_POOL_SIZE_LESSTHAN_ONE = 130;

  
   
  public static final int ER_INVALID_DRIVER = 131;

  
   
  public static final int ER_NO_STYLESHEETROOT = 132;

  
   
  public static final int ER_ILLEGAL_XMLSPACE_VALUE = 133;

  
   
  public static final int ER_PROCESSFROMNODE_FAILED = 134;

  
   
  public static final int ER_RESOURCE_COULD_NOT_LOAD = 135;

   
  
   
  public static final int ER_BUFFER_SIZE_LESSTHAN_ZERO = 136;

  
   
  public static final int ER_UNKNOWN_ERROR_CALLING_EXTENSION = 137;

  
   
  public static final int ER_NO_NAMESPACE_DECL = 138;

  
   
  public static final int ER_ELEM_CONTENT_NOT_ALLOWED = 139;

  
   
  public static final int ER_STYLESHEET_DIRECTED_TERMINATION = 140;

  
   
  public static final int ER_ONE_OR_TWO = 141;

  
   
  public static final int ER_TWO_OR_THREE = 142;

  
   
  public static final int ER_COULD_NOT_LOAD_RESOURCE = 143;

  
   
  public static final int ER_CANNOT_INIT_DEFAULT_TEMPLATES = 144;

  
   
  public static final int ER_RESULT_NULL = 145;

    
   
  public static final int ER_RESULT_COULD_NOT_BE_SET = 146;

  
   
  public static final int ER_NO_OUTPUT_SPECIFIED = 147;

  
   
  public static final int ER_CANNOT_TRANSFORM_TO_RESULT_TYPE = 148;

  
   
  public static final int ER_CANNOT_TRANSFORM_SOURCE_TYPE = 149;

  
   
  public static final int ER_NULL_CONTENT_HANDLER = 150;

  
   
  public static final int ER_NULL_ERROR_HANDLER = 151;

  
   
  public static final int ER_CANNOT_CALL_PARSE = 152;

  
   
  public static final int ER_NO_PARENT_FOR_FILTER = 153;

  
  
   
  public static final int ER_NO_STYLESHEET_IN_MEDIA = 154;

  
   
  public static final int ER_NO_STYLESHEET_PI = 155;

  
   
  public static final int ER_NO_DEFAULT_IMPL = 156;

  
   
  public static final int ER_CHUNKEDINTARRAY_NOT_SUPPORTED = 157;

  
   
  public static final int ER_OFFSET_BIGGER_THAN_SLOT = 158;

  
   
  public static final int ER_COROUTINE_NOT_AVAIL = 159;

  
   
  public static final int ER_COROUTINE_CO_EXIT = 160;

  
   
  public static final int ER_COJOINROUTINESET_FAILED = 161;

  
   
  public static final int ER_COROUTINE_PARAM = 162;

  
   
  public static final int ER_PARSER_DOTERMINATE_ANSWERS = 163;

  
   
  public static final int ER_NO_PARSE_CALL_WHILE_PARSING = 164;

  
   
  public static final int ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED = 165;

  
   
  public static final int ER_ITERATOR_AXIS_NOT_IMPLEMENTED = 166;

  
   
  public static final int ER_ITERATOR_CLONE_NOT_SUPPORTED = 167;

  
   
  public static final int ER_UNKNOWN_AXIS_TYPE = 168;

  
   
  public static final int ER_AXIS_NOT_SUPPORTED = 169;

  
   
  public static final int ER_NO_DTMIDS_AVAIL = 170;

  
   
  public static final int ER_NOT_SUPPORTED = 171;

  
   
  public static final int ER_NODE_NON_NULL = 172;

  
   
  public static final int ER_COULD_NOT_RESOLVE_NODE = 173;

  
   
  public static final int ER_STARTPARSE_WHILE_PARSING = 174;

  
   
  public static final int ER_STARTPARSE_NEEDS_SAXPARSER = 175;

  
   
  public static final int ER_COULD_NOT_INIT_PARSER = 176;

  
   
  public static final int ER_PROPERTY_VALUE_BOOLEAN = 177;

  
   
  public static final int ER_EXCEPTION_CREATING_POOL = 178;

  
   
  public static final int ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE = 179;

  
   
  public static final int ER_SCHEME_REQUIRED = 180;

  
   
  public static final int ER_NO_SCHEME_IN_URI = 181;

  
   
  public static final int ER_NO_SCHEME_INURI = 182;

  
   
  public static final int ER_PATH_INVALID_CHAR = 183;

  
   
  public static final int ER_SCHEME_FROM_NULL_STRING = 184;

  
   
  public static final int ER_SCHEME_NOT_CONFORMANT = 185;

  
   
  public static final int ER_HOST_ADDRESS_NOT_WELLFORMED = 186;

  
   
  public static final int ER_PORT_WHEN_HOST_NULL = 187;

  
   
  public static final int ER_INVALID_PORT = 188;

  
   
  public static final int ER_FRAG_FOR_GENERIC_URI = 189;

  
   
  public static final int ER_FRAG_WHEN_PATH_NULL = 190;

  
   
  public static final int ER_FRAG_INVALID_CHAR = 191;

  
 
  
   
  public static final int ER_PARSER_IN_USE = 192;

  
   
  public static final int ER_CANNOT_CHANGE_WHILE_PARSING = 193;

  
   
  public static final int ER_SELF_CAUSATION_NOT_PERMITTED = 194;

  
   
  public static final int ER_COULD_NOT_FIND_EXTERN_SCRIPT = 195;

  
  
  public static final int ER_RESOURCE_COULD_NOT_FIND = 196;

  
   
  public static final int ER_OUTPUT_PROPERTY_NOT_RECOGNIZED = 197;

  
   
  public static final int ER_NO_USERINFO_IF_NO_HOST = 198;

  
   
  public static final int ER_NO_PORT_IF_NO_HOST = 199;

  
   
  public static final int ER_NO_QUERY_STRING_IN_PATH = 200;

  
   
  public static final int ER_NO_FRAGMENT_STRING_IN_PATH = 201;

  
   
  public static final int ER_CANNOT_INIT_URI_EMPTY_PARMS = 202;

  
   
  public static final int ER_FAILED_CREATING_ELEMLITRSLT = 203;

  
   
  public static final int ER_VALUE_SHOULD_BE_NUMBER = 204;


  
   
  public static final int ER_VALUE_SHOULD_EQUAL = 205;

 
   
  public static final int ER_FAILED_CALLING_METHOD = 206;

  
   
  public static final int ER_FAILED_CREATING_ELEMTMPL = 207;

  
   
  public static final int ER_CHARS_NOT_ALLOWED = 208;

  
  
  public static final int ER_ATTR_NOT_ALLOWED = 209;

  
  
  public static final int ER_METHOD_NOT_SUPPORTED = 210;

 
  
  public static final int ER_BAD_VALUE = 211;

  
  
  public static final int ER_ATTRIB_VALUE_NOT_FOUND = 212;

  
  
  public static final int ER_ATTRIB_VALUE_NOT_RECOGNIZED = 213;


  
  public static final int ER_INCRSAXSRCFILTER_NOT_RESTARTABLE = 214;

  
  
  public static final int ER_XMLRDR_NOT_BEFORE_STARTPARSE = 215;

  
  
  public static final int ER_NULL_URI_NAMESPACE = 216;

  
  
  public static final int ER_NUMBER_TOO_BIG = 217;
  

  public static final int ER_NO_DRIVER_NAME_SPECIFIED = 228;


  public static final int ER_NO_URL_SPECIFIED = 229; 


  public static final int ER_POOLSIZE_LESS_THAN_ONE = 230;


  public static final int ER_INVALID_DRIVER_NAME = 231;


  public static final int ER_ERRORLISTENER = 232;


  public static final int ER_ASSERT_NO_TEMPLATE_PARENT = 233;


  public static final int ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR = 234;


  public static final int ER_AXIS_TRAVERSER_NOT_SUPPORTED = 235;


  public static final int ER_ERRORHANDLER_CREATED_WITH_NULL_PRINTWRITER = 236;

  
  public static final int ER_NOT_ALLOWED_IN_POSITION = 237;

  
  public static final int ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION = 238;
  
  
  
  public static final int INVALID_TCHAR = 239;
  
  
  public static final int ER_SYSTEMID_UNKNOWN = 240;
    
  
  public static final int ER_LOCATION_UNKNOWN = 241;
  
  
  
  public static final int INVALID_QNAME = 242;   
   
  
  public static final int INVALID_ENUM = 243;
   
  
  public static final int INVALID_NMTOKEN = 244;
      
  
  public static final int INVALID_NCNAME = 245;  
   
  
  public static final int INVALID_BOOLEAN = 246;  

  
  public static final int INVALID_NUMBER = 247;
  
  


   
  

  

  
  public static final int WG_FOUND_CURLYBRACE = 1;


  
  public static final int WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR = 2;


  
  public static final int WG_EXPR_ATTRIB_CHANGED_TO_SELECT = 3;


  
  public static final int WG_NO_LOCALE_IN_FORMATNUMBER = 4;


  
  public static final int WG_LOCALE_NOT_FOUND = 5;


  
  public static final int WG_CANNOT_MAKE_URL_FROM = 6;


  
  public static final int WG_CANNOT_LOAD_REQUESTED_DOC = 7;


  
  public static final int WG_CANNOT_FIND_COLLATOR = 8;


  
  public static final int WG_FUNCTIONS_SHOULD_USE_URL = 9;


  
  public static final int WG_ENCODING_NOT_SUPPORTED_USING_UTF8 = 10;


  
  public static final int WG_ENCODING_NOT_SUPPORTED_USING_JAVA = 11;


  
  public static final int WG_SPECIFICITY_CONFLICTS = 12;


  
  public static final int WG_PARSING_AND_PREPARING = 13;


  
  public static final int WG_ATTR_TEMPLATE = 14;


  
  public static final int WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE =
    15;


  
  public static final int WG_ATTRIB_NOT_HANDLED = 16;


  
  public static final int WG_NO_DECIMALFORMAT_DECLARATION = 17;


  
  public static final int WG_OLD_XSLT_NS = 18;


  
  public static final int WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED = 19;


  
  public static final int WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE = 20;


  
  public static final int WG_ILLEGAL_ATTRIBUTE = 21;


  
  public static final int WG_COULD_NOT_RESOLVE_PREFIX = 22;


  
  public static final int WG_STYLESHEET_REQUIRES_VERSION_ATTRIB = 23;


  
  public static final int WG_ILLEGAL_ATTRIBUTE_NAME = 24;


  
  public static final int WG_ILLEGAL_ATTRIBUTE_VALUE = 25;


  
  public static final int WG_EMPTY_SECOND_ARG = 26;
  
  
  public static final int WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML = 27;
  
  
  public static final int WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME = 28;  
  
  
  
  
  public static final int WG_INVALID_TCHAR = 239;
  
  
  
  public static final int WG_INVALID_QNAME = 242;
  
   
  
  public static final int WG_INVALID_ENUM = 243;
  
   
  
  public static final int WG_INVALID_NMTOKEN = 244;
  
      
  
  public static final int WG_INVALID_NCNAME = 245;
  
   
  
  public static final int WG_INVALID_BOOLEAN = 246;
  

  
  public static final int WG_INVALID_NUMBER = 247;
  

  

  

  
  public static final String BAD_CODE = ""BAD_CODE"";

  
  public static final String FORMAT_FAILED = ""FORMAT_FAILED"";

  
  public static final String ERROR_STRING = ""#error"";

  
  public static final String ERROR_HEADER = ""Error: "";

  
  public static final String WARNING_HEADER = ""Warning: "";

  
  public static final String XSL_HEADER = ""XSLT "";

  
  public static final String XML_HEADER = ""XML "";

  
  public static final String QUERY_HEADER = ""PATTERN "";











  
  public static final ResourceBundle loadResourceBundle(String className)
          throws MissingResourceException
  {

    Locale locale = Locale.getDefault();
    String suffix = getResourceSuffix(locale);

    try
    {

      
      return ResourceBundle.getBundle(className
              + suffix, locale);
    } 
    catch (MissingResourceException e)
    {
      try  
      {

        
        
        return ResourceBundle.getBundle(className,
                new Locale(""en"", ""US""));
      }
      catch (MissingResourceException e2)
      {

        
        
        throw new MissingResourceException(
          ""Could not load any resource bundles."", className, """");
      }
    }
  }

  
  private static final String getResourceSuffix(Locale locale)
  {

    String suffix = ""_"" + locale.getLanguage();
    String country = locale.getCountry();

    if (country.equals(""TW""))
      suffix += ""_"" + country;

    return suffix;
  }

  
  public static String getMessageKey(int errorCode)
  {




    {
      DecimalFormat df = new DecimalFormat(""0000"");

      return ERROR_SUFFIX + df.format(errorCode);
    }
  }

  
  public static String getWarningKey(int errorCode)
  {




    {
      DecimalFormat df = new DecimalFormat(""0000"");

      return WARNING_SUFFIX + df.format(errorCode);
    }
  }

  
  public static String getMKey(int errorCode)
  {



    {
      DecimalFormat df = new DecimalFormat(""0000"");

      return ERROR_SUFFIX + df.format(errorCode);
    }
  }

  
  public static String getWKey(int errorCode)
  {




    {
      DecimalFormat df = new DecimalFormat(""0000"");

      return WARNING_SUFFIX + df.format(errorCode);
    }
  }
}
"
org.apache.xalan.xsltc.compiler.UnsupportedElement,7,2,0,11,24,5,1,11,6,0.583333333,131,1.0,2,0.9,0.238095238,1,5,17.42857143,6,1.8571,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Vector;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;

import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class UnsupportedElement extends SyntaxTreeNode {

    private Fallback _fallback = null;
    private ErrorMsg _message = null;

    
    public UnsupportedElement(String uri, String prefix, String local) {
	super(uri, prefix, local);
    }

    
    public void setErrorMessage(ErrorMsg message) {
	_message = message;
    }

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Unsupported element = "" + _qname.getNamespace() +
		     "":"" + _qname.getLocalPart());
	displayContents(indent + IndentIncrement);
    }


    
    private SyntaxTreeNode findFallback(SyntaxTreeNode root) {

	
	if (root == null) return null;

	
	if (root instanceof Fallback) return((Fallback)root);

	
	Vector children = root.getContents();
	if (children != null) {
	    final int count = children.size();
	    for (int i = 0; i < count; i++) {
		SyntaxTreeNode child = (SyntaxTreeNode)children.elementAt(i);
		SyntaxTreeNode node = findFallback(child);
		if (node != null) return node;
	    }
	}
	return null;
    }

    
    public void parseContents(Parser parser) {
	_fallback = (Fallback)findFallback(this);
	if (_fallback != null) {
	    _fallback.activate();
	    _fallback.parseContents(parser);
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_fallback == null) {
	    throw new TypeCheckError(_message);
	}
	return(_fallback.typeCheck(stable));
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (_fallback != null) _fallback.translate(classGen, methodGen);
    }
}
"
org.apache.xalan.xsltc.compiler.Closure,4,1,0,6,4,6,6,1,4,2.0,4,0.0,0,0.0,0.625,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.compiler;

public interface Closure {

    
    public boolean inInnerClass();

    
    public Closure getParentClosure();

    
    public String getInnerClassName();

    
    public void addVariable(VariableRefBase variableRef);
}
"
org.apache.xalan.templates.ElemText,6,3,0,3,11,9,2,1,6,0.6,49,1.0,0,0.975124378,0.444444444,2,5,7.0,3,1.1667,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import java.io.*;

import java.util.*;


public class ElemText extends ElemTemplateElement
{

  
  private boolean m_disableOutputEscaping = false;

  
  public void setDisableOutputEscaping(boolean v)
  {
    m_disableOutputEscaping = v;
  }

  
  public boolean getDisableOutputEscaping()
  {
    return m_disableOutputEscaping;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_TEXT;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_TEXT_STRING;
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {
    case Constants.ELEMNAME_TEXTLITERALRESULT :
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
}
"
org.apache.xalan.xsltc.compiler.BooleanCall,3,4,0,8,11,0,0,8,3,0.0,51,1.0,1,0.979591837,0.444444444,3,13,15.66666667,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class BooleanCall extends FunctionCall {

    private Expression _arg = null;

    public BooleanCall(QName fname, Vector arguments) {
	super(fname, arguments);
	_arg = argument(0);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_arg.typeCheck(stable);
	return _type = Type.Boolean;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	_arg.translate(classGen, methodGen);
	final Type targ = _arg.getType();
	if (!targ.identicalTo(Type.Boolean)) {
	    _arg.startResetIterator(classGen, methodGen);
	    targ.translateTo(classGen, methodGen, Type.Boolean);
	}
    }
}
"
org.apache.xpath.XPathProcessorException,2,5,0,4,4,1,3,1,2,2.0,11,0.0,0,1.0,0.833333333,0,0,4.5,0,0.0,0,"
package org.apache.xpath;


public class XPathProcessorException extends XPathException
{

  
  public XPathProcessorException(String message)
  {
    super(message);
  }
  

  
  public XPathProcessorException(String message, Exception e)
  {
    super(message, e);
  }
}
"
org.apache.xalan.transformer.TransformerIdentityImpl,43,2,0,12,139,575,1,11,41,0.863945578,1086,0.785714286,2,0.236363636,0.153100775,0,0,23.93023256,2,1.0465,0,"
package org.apache.xalan.transformer;

import java.util.Properties;
import java.util.Hashtable;

import java.io.IOException;


import javax.xml.transform.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.stream.*;
import javax.xml.parsers.*;

import org.xml.sax.*;
import org.xml.sax.helpers.*;
import org.xml.sax.ext.*;

import org.apache.xalan.serialize.*;
import org.apache.xml.utils.DOMBuilder;
import org.apache.xml.utils.TreeWalker;
import org.apache.xalan.templates.OutputProperties;
import org.apache.xalan.serialize.Method;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;

import org.w3c.dom.*;


public class TransformerIdentityImpl extends Transformer
        implements TransformerHandler, DeclHandler
{

  
  public TransformerIdentityImpl()
  {
    m_outputFormat = new OutputProperties(Method.XML);
  }

  
  public void setResult(Result result) throws IllegalArgumentException
  {
    if(null == result)
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_NULL, null)); 
    m_result = result;
  }

  
  public void setSystemId(String systemID)
  {
    m_systemID = systemID;
  }

  
  public String getSystemId()
  {
    return m_systemID;
  }

  
  public Transformer getTransformer()
  {
    return this;
  }

  
  private void createResultContentHandler(Result outputTarget)
          throws TransformerException
  {

    if (outputTarget instanceof SAXResult)
    {
      SAXResult saxResult = (SAXResult) outputTarget;

      m_resultContentHandler = saxResult.getHandler();
      m_resultLexicalHandler = saxResult.getLexicalHandler();

      if (m_resultContentHandler instanceof Serializer)
      {

        
        m_serializer = (Serializer) m_resultContentHandler;
      }
    }
    else if (outputTarget instanceof DOMResult)
    {
      DOMResult domResult = (DOMResult) outputTarget;
      Node outputNode = domResult.getNode();
      Document doc;
      short type;

      if (null != outputNode)
      {
        type = outputNode.getNodeType();
        doc = (Node.DOCUMENT_NODE == type)
              ? (Document) outputNode : outputNode.getOwnerDocument();
      }
      else
      {
        try
        {
          DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

          dbf.setNamespaceAware(true);

          DocumentBuilder db = dbf.newDocumentBuilder();

          doc = db.newDocument();
        }
        catch (ParserConfigurationException pce)
        {
          throw new TransformerException(pce);
        }

        outputNode = doc;
        type = outputNode.getNodeType();

        ((DOMResult) outputTarget).setNode(outputNode);
      }

      m_resultContentHandler =
        (Node.DOCUMENT_FRAGMENT_NODE == type)
        ? new DOMBuilder(doc, (DocumentFragment) outputNode)
        : new DOMBuilder(doc, outputNode);
      m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;
    }
    else if (outputTarget instanceof StreamResult)
    {
      StreamResult sresult = (StreamResult) outputTarget;
      String method = m_outputFormat.getProperty(OutputKeys.METHOD);

      try
      {
        Serializer serializer =
          SerializerFactory.getSerializer(m_outputFormat.getProperties());

        m_serializer = serializer;

        if (null != sresult.getWriter())
          serializer.setWriter(sresult.getWriter());
        else if (null != sresult.getOutputStream())
          serializer.setOutputStream(sresult.getOutputStream());
        else if (null != sresult.getSystemId())
        {
          String fileURL = sresult.getSystemId();

          if (fileURL.startsWith(""file:
          {
            if (fileURL.substring(8).indexOf("":"") >0)
              fileURL = fileURL.substring(8);
            else 
              fileURL = fileURL.substring(7);
          }

          m_outputStream = new java.io.FileOutputStream(fileURL);
          serializer.setOutputStream(m_outputStream);
        }
        else
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_OUTPUT_SPECIFIED, null)); 

        m_resultContentHandler = serializer.asContentHandler();
      }
      catch (IOException ioe)
      {
        throw new TransformerException(ioe);
      }
    }
    else
    {
      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_TO_RESULT_TYPE, new Object[]{outputTarget.getClass().getName()})); 
                                    
                                    
    }

    if (m_resultContentHandler instanceof DTDHandler)
      m_resultDTDHandler = (DTDHandler) m_resultContentHandler;
    
    if (m_resultContentHandler instanceof DeclHandler)
      m_resultDeclHandler = (DeclHandler) m_resultContentHandler;

    if (m_resultContentHandler instanceof LexicalHandler)
      m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;
  }

  
  public void transform(Source source, Result outputTarget)
          throws TransformerException
  {

    createResultContentHandler(outputTarget);

    try
    {
      if (source instanceof DOMSource)
      {
        DOMSource dsource = (DOMSource) source;
  
        m_systemID = dsource.getSystemId();
  
        Node dNode = dsource.getNode();
  
        if (null != dNode)
        {
          try
          {
            if(dNode.getNodeType() != Node.DOCUMENT_NODE)
              this.startDocument();
            try
            {
              if(dNode.getNodeType() == Node.ATTRIBUTE_NODE)
              {
                String data = dNode.getNodeValue();
                char[] chars = data.toCharArray();
                characters(chars, 0, chars.length);
              }
              else
              {
                TreeWalker walker = new TreeWalker(this, new org.apache.xpath.DOM2Helper(), m_systemID);
                walker.traverse(dNode);
              }
            }
            finally
            {
              if(dNode.getNodeType() != Node.DOCUMENT_NODE)
                this.endDocument();
            }
          }
          catch (SAXException se)
          {
            throw new TransformerException(se);
          }
  
          return;
        }
        else
        {
          String messageStr = XSLMessages.createMessage(
            XSLTErrorResources.ER_ILLEGAL_DOMSOURCE_INPUT, null);
  
          throw new IllegalArgumentException(messageStr);
        }
      }
  
      InputSource xmlSource = SAXSource.sourceToInputSource(source);
  
      if (null == xmlSource)
      {
        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_SOURCE_TYPE, new Object[]{source.getClass().getName()})); 
                                       
      }
  
      if (null != xmlSource.getSystemId())
        m_systemID = xmlSource.getSystemId();
  
      try
      {
        XMLReader reader = null;
  
        if (source instanceof SAXSource)
          reader = ((SAXSource) source).getXMLReader();
          
        boolean isUserReader = (reader != null);
  
        if (null == reader)
        {
  
          
          try
          {
            javax.xml.parsers.SAXParserFactory factory =
              javax.xml.parsers.SAXParserFactory.newInstance();
  
            factory.setNamespaceAware(true);
  
            javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser();
  
            reader = jaxpParser.getXMLReader();
          }
          catch (javax.xml.parsers.ParserConfigurationException ex)
          {
            throw new org.xml.sax.SAXException(ex);
          }
          catch (javax.xml.parsers.FactoryConfigurationError ex1)
          {
            throw new org.xml.sax.SAXException(ex1.toString());
          }
          catch (NoSuchMethodError ex2){}
          catch (AbstractMethodError ame){}
        }
  
        if (null == reader)
        {
          reader = XMLReaderFactory.createXMLReader();
        }
  
        try
        {
          reader.setFeature(""http:
                            true);
        
        



        }
        catch (org.xml.sax.SAXException se)
        {
  
          
        }
  
        
        
        ContentHandler inputHandler = this;
  
        reader.setContentHandler(inputHandler);
  
        if (inputHandler instanceof org.xml.sax.DTDHandler)
          reader.setDTDHandler((org.xml.sax.DTDHandler) inputHandler);
  
        try
        {
          if (inputHandler instanceof org.xml.sax.ext.LexicalHandler)
            reader.setProperty(""http:
                               inputHandler);
  
          if (inputHandler instanceof org.xml.sax.ext.DeclHandler)
            reader.setProperty(
              ""http:
              inputHandler);
        }
        catch (org.xml.sax.SAXException se){}
  
        try
        {
          if (inputHandler instanceof org.xml.sax.ext.LexicalHandler)
            reader.setProperty(""http:
                               inputHandler);
  
          if (inputHandler instanceof org.xml.sax.ext.DeclHandler)
            reader.setProperty(""http:
                               inputHandler);
        }
        catch (org.xml.sax.SAXNotRecognizedException snre){}
  
        reader.parse(xmlSource);
      }
      catch (org.apache.xml.utils.WrappedRuntimeException wre)
      {
        Throwable throwable = wre.getException();
  
        while (throwable
               instanceof org.apache.xml.utils.WrappedRuntimeException)
        {
          throwable =
            ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();
        }
  
        throw new TransformerException(wre.getException());
      }
      catch (org.xml.sax.SAXException se)
      {
        throw new TransformerException(se);
      }
      catch (IOException ioe)
      {
        throw new TransformerException(ioe);
      }
    }
    finally
    {
      if(null != m_outputStream)
      {
        try
        {
          m_outputStream.close();
        }
        catch(IOException ioe){}
        m_outputStream = null;
      }
    }
  }

  
  public void setParameter(String name, Object value)
  {

    if (null == m_params)
    {
      m_params = new Hashtable();
    }

    m_params.put(name, value);
  }

  
  public Object getParameter(String name)
  {

    if (null == m_params)
      return null;

    return m_params.get(name);
  }

  
  public void clearParameters()
  {

    if (null == m_params)
      return;

    m_params.clear();
  }

  
  public void setURIResolver(URIResolver resolver)
  {
    m_URIResolver = resolver;
  }

  
  public URIResolver getURIResolver()
  {
    return m_URIResolver;
  }

  
  public void setOutputProperties(Properties oformat)
          throws IllegalArgumentException
  {

    if (null != oformat)
    {

      
      String method = (String) oformat.get(OutputKeys.METHOD);

      if (null != method)
        m_outputFormat = new OutputProperties(method);
      else
        m_outputFormat = new OutputProperties();
    }

    if (null != oformat)
    {
      m_outputFormat.copyFrom(oformat);
    }
  }

  
  public Properties getOutputProperties()
  {
    return (Properties) m_outputFormat.getProperties().clone();
  }

  
  public void setOutputProperty(String name, String value)
          throws IllegalArgumentException
  {

    if (!m_outputFormat.isLegalPropertyKey(name))
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{name})); 
                                         

    m_outputFormat.setProperty(name, value);
  }

  
  public String getOutputProperty(String name) throws IllegalArgumentException
  {

    String value = null;
    OutputProperties props = m_outputFormat;

    value = props.getProperty(name);

    if (null == value)
    {
      if (!props.isLegalPropertyKey(name))
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{name})); 
                                          
    }

    return value;
  }

  
  public void setErrorListener(ErrorListener listener)
          throws IllegalArgumentException
  {
    m_errorListener = listener;
  }

  
  public ErrorListener getErrorListener()
  {
    return m_errorListener;
  }

  
  
  

  
  public void notationDecl(String name, String publicId, String systemId)
          throws SAXException
  {
    if (null != m_resultDTDHandler)
      m_resultDTDHandler.notationDecl(name, publicId, systemId);
  }

  
  public void unparsedEntityDecl(
          String name, String publicId, String systemId, String notationName)
            throws SAXException
  {

    if (null != m_resultDTDHandler)
      m_resultDTDHandler.unparsedEntityDecl(name, publicId, systemId,
                                            notationName);
  }

  
  
  

  
  public void setDocumentLocator(Locator locator)
  {
    try
    {
      if (null == m_resultContentHandler)
        createResultContentHandler(m_result);
    }
    catch (TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }

    m_resultContentHandler.setDocumentLocator(locator);
  }

  
  public void startDocument() throws SAXException
  {

    try
    {
      if (null == m_resultContentHandler)
        createResultContentHandler(m_result);
    }
    catch (TransformerException te)
    {
      throw new SAXException(te.getMessage(), te);
    }

    
    m_flushedStartDoc = false;
    m_foundFirstElement = false;
  }
  
  boolean m_flushedStartDoc = false;
  
  protected final void flushStartDoc()
     throws SAXException
  {
    if(!m_flushedStartDoc)
    {
      m_resultContentHandler.startDocument();
      m_flushedStartDoc = true;
    }
  }

  
  public void endDocument() throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.endDocument();
  }

  
  public void startPrefixMapping(String prefix, String uri)
          throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.startPrefixMapping(prefix, uri);
  }

  
  public void endPrefixMapping(String prefix) throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.endPrefixMapping(prefix);
  }

  
  public void startElement(
          String uri, String localName, String qName, Attributes attributes)
            throws SAXException
  {

    if (!m_foundFirstElement && null != m_serializer)
    {
      m_foundFirstElement = true;

      Serializer newSerializer;

      try
      {
        newSerializer = SerializerSwitcher.switchSerializerIfHTML(uri,
                localName, m_outputFormat.getProperties(), m_serializer);
      }
      catch (TransformerException te)
      {
        throw new SAXException(te);
      }

      if (newSerializer != m_serializer)
      {
        try
        {
          m_resultContentHandler = newSerializer.asContentHandler();
        }
        catch (IOException ioe)  
        {
          throw new SAXException(ioe);
        }

        if (m_resultContentHandler instanceof DTDHandler)
          m_resultDTDHandler = (DTDHandler) m_resultContentHandler;

        if (m_resultContentHandler instanceof LexicalHandler)
          m_resultLexicalHandler = (LexicalHandler) m_resultContentHandler;

        m_serializer = newSerializer;
      }
    }
    flushStartDoc();
    m_resultContentHandler.startElement(uri, localName, qName, attributes);
  }

  
  public void endElement(String uri, String localName, String qName)
          throws SAXException
  {
    m_resultContentHandler.endElement(uri, localName, qName);
  }

  
  public void characters(char ch[], int start, int length) throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.characters(ch, start, length);
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws SAXException
  {
    m_resultContentHandler.ignorableWhitespace(ch, start, length);
  }

  
  public void processingInstruction(String target, String data)
          throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.processingInstruction(target, data);
  }

  
  public void skippedEntity(String name) throws SAXException
  {
    flushStartDoc();
    m_resultContentHandler.skippedEntity(name);
  }

  
  public void startDTD(String name, String publicId, String systemId)
          throws SAXException
  {
    flushStartDoc();
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.startDTD(name, publicId, systemId);
  }

  
  public void endDTD() throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.endDTD();
  }

  
  public void startEntity(String name) throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.startEntity(name);
  }

  
  public void endEntity(String name) throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.endEntity(name);
  }

  
  public void startCDATA() throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.startCDATA();
  }

  
  public void endCDATA() throws SAXException
  {
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.endCDATA();
  }

  
  public void comment(char ch[], int start, int length) throws SAXException
  {
    flushStartDoc();
    if (null != m_resultLexicalHandler)
      m_resultLexicalHandler.comment(ch, start, length);
  }
  
  
  
  
    public void elementDecl (String name, String model)
        throws SAXException
    {
                        if (null != m_resultDeclHandler)
                                m_resultDeclHandler.elementDecl(name, model);
    }


    
    public void attributeDecl (String eName,
                                        String aName,
                                        String type,
                                        String valueDefault,
                                        String value)
        throws SAXException
    {
      if (null != m_resultDeclHandler)
                                m_resultDeclHandler.attributeDecl(eName, aName, type, valueDefault, value);
    }


    
    public void internalEntityDecl (String name, String value)
        throws SAXException
    {
      if (null != m_resultDeclHandler)
                                m_resultDeclHandler.internalEntityDecl(name, value); 
    }


    
    public void externalEntityDecl (String name, String publicId,
                                             String systemId)
        throws SAXException
    {
      if (null != m_resultDeclHandler)
                                m_resultDeclHandler.externalEntityDecl(name, publicId, systemId);
    }
  
  
  private java.io.FileOutputStream m_outputStream = null;

  
  private ContentHandler m_resultContentHandler;

  
  private LexicalHandler m_resultLexicalHandler;

  
  private DTDHandler m_resultDTDHandler;
  
  
  private DeclHandler m_resultDeclHandler;

  
  private Serializer m_serializer;

  
  private Result m_result;

  
  private String m_systemID;

  
  private Hashtable m_params;

  
  private ErrorListener m_errorListener =
    new org.apache.xml.utils.DefaultErrorHandler();

  
  URIResolver m_URIResolver;

  
  private OutputProperties m_outputFormat;

  
  boolean m_foundFirstElement;
}
"
org.apache.xpath.operations.Minus,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.XPathContext;


public class Minus extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() - right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (m_left.num(xctxt) - m_right.num(xctxt));
  }

}
"
org.apache.xalan.xsltc.compiler.util.MatchGenerator,10,5,0,9,16,27,1,8,9,0.844444444,79,1.0,0,0.945205479,0.263888889,2,5,6.4,2,0.9,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Template;

public final class MatchGenerator extends MethodGenerator {
    private static int CURRENT_INDEX = 1;

    private int _iteratorIndex = INVALID_INDEX;

    private final Instruction _iloadCurrent;
    private final Instruction _istoreCurrent;
    private Instruction _aloadDom;
    
    public MatchGenerator(int access_flags, Type return_type, 
			  Type[] arg_types, String[] arg_names, 
			  String method_name, String class_name,
			  InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
	
	_iloadCurrent = new ILOAD(CURRENT_INDEX);
	_istoreCurrent = new ISTORE(CURRENT_INDEX);
    }

    public Instruction loadCurrentNode() {
	return _iloadCurrent;
    }

    public Instruction storeCurrentNode() {
	return _istoreCurrent;
    }
    
    public int getHandlerIndex() {
	return INVALID_INDEX;		
    }

    
    public Instruction loadDOM() {
	return _aloadDom;
    }

    
    public void setDomIndex(int domIndex) {
	_aloadDom = new ALOAD(domIndex);
    }

    
    public int getIteratorIndex() {
	return _iteratorIndex;
    }

    
    public void setIteratorIndex(int iteratorIndex) {
	_iteratorIndex = iteratorIndex;
    }

    public int getLocalIndex(String name) {
	if (name.equals(""current"")) {
	    return CURRENT_INDEX;
	}
	return super.getLocalIndex(name);
    }
}
"
org.apache.xpath.compiler.OpMap,21,1,1,12,29,76,11,1,20,0.858333333,409,0.166666667,0,0.0,0.404761905,0,0,18.19047619,8,1.6667,1,"
package org.apache.xpath.compiler;

import java.util.Vector;

import org.apache.xml.utils.QName;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;


public class OpMap
{

  
  protected String m_currentPattern;

  
  public String toString()
  {
    return m_currentPattern;
  }

  
  public String getPatternString()
  {
    return m_currentPattern;
  }

  
  static final int MAXTOKENQUEUESIZE = 500;

  
  public Object[] m_tokenQueue = new Object[MAXTOKENQUEUESIZE];

  
  public Object[] getTokenQueue()
  {
    return m_tokenQueue;
  }

  
  public Object getToken(int pos)
  {
    return m_tokenQueue[pos];
  }

  
  public int m_tokenQueueSize = 0;

  
  public int getTokenQueueSize()
  {
    return m_tokenQueueSize;
  }

  
  public int m_opMap[] = null;

  
  public int[] getOpMap()
  {
    return m_opMap;
  }

  

  
  public static final int MAPINDEX_LENGTH = 1;

  
  void shrink()
  {

    int map[] = m_opMap;
    int n = m_opMap[MAPINDEX_LENGTH];
    ;

    m_opMap = new int[n + 4];

    int i;

    for (i = 0; i < n; i++)
    {
      m_opMap[i] = map[i];
    }

    m_opMap[i] = 0;
    m_opMap[i + 1] = 0;
    m_opMap[i + 2] = 0;

    Object[] tokens = m_tokenQueue;

    n = m_tokenQueueSize;
    m_tokenQueue = new Object[n + 4];

    for (i = 0; i < n; i++)
    {
      m_tokenQueue[i] = tokens[i];
    }

    m_tokenQueue[i] = null;
    m_tokenQueue[i + 1] = null;
    m_tokenQueue[i + 2] = null;
  }

  
  public int getOp(int opPos)
  {
    return m_opMap[opPos];
  }

  
  public int getNextOpPos(int opPos)
  {
    return opPos + m_opMap[opPos + 1];
  }

  
  public int getNextStepPos(int opPos)
  {

    int stepType = getOp(opPos);

    if ((stepType >= OpCodes.AXES_START_TYPES)
            && (stepType <= OpCodes.AXES_END_TYPES))
    {
      return getNextOpPos(opPos);
    }
    else if ((stepType >= OpCodes.FIRST_NODESET_OP)
             && (stepType <= OpCodes.LAST_NODESET_OP))
    {
      int newOpPos = getNextOpPos(opPos);

      while (OpCodes.OP_PREDICATE == getOp(newOpPos))
      {
        newOpPos = getNextOpPos(newOpPos);
      }

      stepType = getOp(newOpPos);

      if (!((stepType >= OpCodes.AXES_START_TYPES)
            && (stepType <= OpCodes.AXES_END_TYPES)))
      {
        return OpCodes.ENDOP;
      }

      return newOpPos;
    }
    else
    {
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_UNKNOWN_STEP, new Object[]{new Integer(stepType).toString()})); 
      
    }
  }

  
  public static int getNextOpPos(int[] opMap, int opPos)
  {
    return opPos + opMap[opPos + 1];
  }

  
  public int getFirstPredicateOpPos(int opPos)
     throws javax.xml.transform.TransformerException
  {

    int stepType = m_opMap[opPos];

    if ((stepType >= OpCodes.AXES_START_TYPES)
            && (stepType <= OpCodes.AXES_END_TYPES))
    {
      return opPos + m_opMap[opPos + 2];
    }
    else if ((stepType >= OpCodes.FIRST_NODESET_OP)
             && (stepType <= OpCodes.LAST_NODESET_OP))
    {
      return opPos + m_opMap[opPos + 1];
    }
    else if(-2 == stepType)
    {
      return -2;
    }
    else
    {
      error(org.apache.xpath.res.XPATHErrorResources.ER_UNKNOWN_OPCODE,
            new Object[]{ String.valueOf(stepType) });  
      return -1;
    }
  }
  
  
  public void error(int msg, Object[] args) throws javax.xml.transform.TransformerException
  {

    java.lang.String fmsg = org.apache.xalan.res.XSLMessages.createXPATHMessage(msg, args);
    

    throw new javax.xml.transform.TransformerException(fmsg);
  }


  
  public static int getFirstChildPos(int opPos)
  {
    return opPos + 2;
  }

  
  public int getArgLength(int opPos)
  {
    return m_opMap[opPos + MAPINDEX_LENGTH];
  }

  
  public int getArgLengthOfStep(int opPos)
  {
    return m_opMap[opPos + MAPINDEX_LENGTH + 1] - 3;
  }

  
  public static int getFirstChildPosOfStep(int opPos)
  {
    return opPos + 3;
  }

  
  public int getStepTestType(int opPosOfStep)
  {
    return m_opMap[opPosOfStep + 3];  
  }

  
  public String getStepNS(int opPosOfStep)
  {

    int argLenOfStep = getArgLengthOfStep(opPosOfStep);

    
    if (argLenOfStep == 3)
    {
      int index = m_opMap[opPosOfStep + 4];

      if (index >= 0)
        return (String) m_tokenQueue[index];
      else if (OpCodes.ELEMWILDCARD == index)
        return NodeTest.WILD;
      else
        return null;
    }
    else
      return null;
  }

  
  public String getStepLocalName(int opPosOfStep)
  {

    int argLenOfStep = getArgLengthOfStep(opPosOfStep);

    
    int index;

    switch (argLenOfStep)
    {
    case 0 :
      index = OpCodes.EMPTY;
      break;
    case 1 :
      index = OpCodes.ELEMWILDCARD;
      break;
    case 2 :
      index = m_opMap[opPosOfStep + 4];
      break;
    case 3 :
      index = m_opMap[opPosOfStep + 5];
      break;
    default :
      index = OpCodes.EMPTY;
      break;  
    }

    
    
    if (index >= 0)
      return (String) m_tokenQueue[index].toString();
    else if (OpCodes.ELEMWILDCARD == index)
      return NodeTest.WILD;
    else
      return null;
  }

}
"
org.apache.xalan.xsltc.compiler.util.Util,18,1,0,44,38,151,43,1,17,0.941176471,258,0.0,0,0.0,0.235294118,0,0,13.27777778,5,1.5556,1,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.Constants;

public final class Util {
    static public char filesep;

    static {
	String temp = System.getProperty(""file.separator"", ""/"");
	filesep = temp.charAt(0);
    }

    public static String noExtName(String name) {
	final int index = name.lastIndexOf('.');
	return name.substring(0, index >= 0 ? index : name.length());
    }

    
    public static String baseName(String name) {
	int index = name.lastIndexOf('/');
	if (index < 0) {
	    index = name.lastIndexOf('\');
	}
	return name.substring(index + 1);
    }

    
    public static String pathName(String name) {
	int index = name.lastIndexOf('/');
	if (index < 0) {
	    index = name.lastIndexOf('\');
	}
	return name.substring(0, index + 1);
    }

    
    public static String toJavaName(String name) {
	if (name.length() > 0) {
	    final StringBuffer result = new StringBuffer();

	    char ch = name.charAt(0);
	    result.append(Character.isJavaIdentifierStart(ch) ? ch : '_');

	    final int n = name.length();
	    for (int i = 1; i < n; i++) {
		ch = name.charAt(i);
		result.append(Character.isJavaIdentifierPart(ch)  ? ch : '_');
	    }
	    return result.toString();
	}
	return name;
    }

    public static Type getJCRefType(String signature) {
	return Type.getType(signature);
    }

    public static String internalName(String cname) {
	return cname.replace('.', filesep);
    }

    public static void println(String s) {
	System.out.println(s);
    }

    public static void println(char ch) {
	System.out.println(ch);
    }

    public static void TRACE1() {
	System.out.println(""TRACE1"");
    }

    public static void TRACE2() {
	System.out.println(""TRACE2"");
    }

    public static void TRACE3() {
	System.out.println(""TRACE3"");
    }

    
    public static String replace(String base, char ch, String str) {
	return (base.indexOf(ch) < 0) ? base : 
	    replace(base, String.valueOf(ch), new String[] { str });
    }

    public static String replace(String base, String delim, String[] str) {
	final int len = base.length();
	final StringBuffer result = new StringBuffer();

	for (int i = 0; i < len; i++) {
	    final char ch = base.charAt(i);
	    final int k = delim.indexOf(ch);

	    if (k >= 0) {
		result.append(str[k]);
	    }
	    else {
		result.append(ch);
	    }
	}
	return result.toString();
    }

    
    public static String escape(String input) {
	return replace(input, "".-/:"", 
	    new String[] { ""$dot$"", ""$dash$"", ""$slash$"", ""$colon$"" });
    }

    public static String getLocalName(String qname) {
	final int index = qname.lastIndexOf("":"");
	return (index > 0) ? qname.substring(index + 1) : qname;
    }

    public static String getPrefix(String qname) {
	final int index = qname.lastIndexOf("":"");
	return (index > 0) ? qname.substring(0, index) : 
	    Constants.EMPTYSTRING;
    }
}

"
org.apache.xalan.xsltc.compiler.FilteredAbsoluteLocationPath,7,3,0,21,28,0,0,21,7,0.0,143,1.0,1,0.934210526,0.285714286,2,7,19.28571429,2,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class FilteredAbsoluteLocationPath extends Expression {
    private Expression _path;	

    public FilteredAbsoluteLocationPath() {
	_path = null;
    }

    public FilteredAbsoluteLocationPath(Expression path) {
	_path = path;
	if (path != null) {
	    _path.setParent(this);
	}
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_path != null) {
	    _path.setParser(parser);
	}
    }

    public Expression getPath() {
	return(_path);
    }
    
    public String toString() {
	return ""FilteredAbsoluteLocationPath("" +
	    (_path != null ? _path.toString() : ""null"") + ')';
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_path != null) {
	    final Type ptype = _path.typeCheck(stable);
	    if (ptype instanceof NodeType) {		
		_path = new CastExpr(_path, Type.NodeSet);
	    }
	}
	return _type = Type.NodeSet;	
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	if (_path != null) {
	    final int initDFI = cpg.addMethodref(DUP_FILTERED_ITERATOR,
						""<init>"",
						""(""
						+ NODE_ITERATOR_SIG
						+ "")V"");
	    
	    il.append(new NEW(cpg.addClass(DUP_FILTERED_ITERATOR)));
	    il.append(DUP);

	    
	    _path.translate(classGen, methodGen);

	    
	    il.append(new INVOKESPECIAL(initDFI));
	}
	else {
	    final int git = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getIterator"",
						      ""()""+NODE_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(new INVOKEINTERFACE(git, 1));
	}
    }
}
"
org.apache.xpath.functions.FuncCurrent,3,3,0,10,12,3,1,9,3,2.0,50,0.0,0,0.95,0.5,1,6,15.66666667,1,0.6667,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.axes.PredicatedNodeTest;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.axes.ContextNodeList;
import org.apache.xpath.axes.SubContextList;


public class FuncCurrent extends Function
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    
    Object subContextList = xctxt.getSubContextList();
    int currentNode;

    
    if (null != subContextList && subContextList instanceof PredicatedNodeTest)
    {
      
      
      LocPathIterator lpi = xctxt.getCurrentNodeList();

      currentNode = lpi.getCurrentContextNode();  
        
    }
    else if(xctxt.getIteratorRoot() != DTM.NULL)
    {
      currentNode = xctxt.getIteratorRoot();
    }
    else
    {
      DTMIterator cnl = xctxt.getContextNodeList();

      if (null != cnl)
      {
        
        currentNode = cnl.getCurrentNode();
      }
      else
        currentNode = DTM.NULL;
    }
    
    
    
    
    
    
    
    
    

    return new XNodeSet(currentNode, xctxt.getDTMManager());
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }

}
"
org.apache.xalan.templates.ElemCopyOf,9,3,0,20,45,6,0,20,8,0.375,217,0.0,1,0.960784314,0.238095238,2,5,23.0,2,1.0,0,"
package org.apache.xalan.templates;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.ref.DTMTreeWalker;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.objects.XObject;
import org.apache.xalan.trace.SelectionEvent;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.QName;
import org.apache.xalan.transformer.TreeWalker2Result;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultTreeHandler;

import javax.xml.transform.TransformerException;


public class ElemCopyOf extends ElemTemplateElement
{

  
  public XPath m_selectExpression = null;

  
  public void setSelect(XPath expr)
  {
    m_selectExpression = expr;
  }

  
  public XPath getSelect()
  {
    return m_selectExpression;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    m_selectExpression.fixupVariables(cstate.getVariableNames(), cstate.getGlobalsSize());
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_COPY_OF;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_COPY_OF_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
    	transformer.getTraceManager().fireTraceEvent(this);

    try
    {
      XPathContext xctxt = transformer.getXPathContext();
      int sourceNode = xctxt.getCurrentNode();
      XObject value = m_selectExpression.execute(xctxt, sourceNode, this);

      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                                                        ""select"", m_selectExpression, value);

      ResultTreeHandler handler = transformer.getResultTreeHandler();

      if (null != value)
                        {
        int type = value.getType();
        String s;

        switch (type)
        {
        case XObject.CLASS_BOOLEAN :
        case XObject.CLASS_NUMBER :
        case XObject.CLASS_STRING :
          s = value.str();

          handler.characters(s.toCharArray(), 0, s.length());
          break;
        case XObject.CLASS_NODESET :

          
          DTMIterator nl = value.iter();

          
          DTMTreeWalker tw = new TreeWalker2Result(transformer, handler);
          int pos;

          while (DTM.NULL != (pos = nl.nextNode()))
          {
            DTM dtm = xctxt.getDTMManager().getDTM(pos);
            short t = dtm.getNodeType(pos);

            
            
            if (t == DTM.DOCUMENT_NODE)
            {
              for (int child = dtm.getFirstChild(pos); child != DTM.NULL;
                   child = dtm.getNextSibling(child))
              {
                tw.traverse(child);
              }
            }
            else if (t == DTM.ATTRIBUTE_NODE)
            {
              handler.addAttribute(pos);
            }
            else
            {
              tw.traverse(pos);
            }
          }
          
          break;
        case XObject.CLASS_RTREEFRAG :
          handler.outputResultTreeFragment(value,
                                           transformer.getXPathContext());
          break;
        default :
          
          s = value.str();

          handler.characters(s.toCharArray(), 0, s.length());
          break;
        }
      }
                        
      
      
      
      

    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEndEvent(this);
    }

  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  		m_selectExpression.getExpression().callVisitors(m_selectExpression, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xalan.xsltc.compiler.UseAttributeSets,4,3,0,21,30,0,5,17,4,0.833333333,127,1.0,0,0.949152542,0.416666667,1,3,30.25,4,2.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Iterator;
import java.util.Enumeration;
import java.util.StringTokenizer;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class UseAttributeSets extends Instruction {

    
    private final static String ATTR_SET_NOT_FOUND =
	"""";

    
    private final Vector _sets = new Vector(2);

    
    public UseAttributeSets(String setNames, Parser parser) {
	setParser(parser);
	addAttributeSets(setNames);
    }

    
    public void addAttributeSets(String setNames) {
	if ((setNames != null) && (!setNames.equals(Constants.EMPTYSTRING))) {
	    final StringTokenizer tokens = new StringTokenizer(setNames);
	    while (tokens.hasMoreTokens()) {
		final QName qname = 
		    getParser().getQNameIgnoreDefaultNs(tokens.nextToken());
		_sets.add(qname);
	    }
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final SymbolTable symbolTable = getParser().getSymbolTable();

	
	for (int i=0; i<_sets.size(); i++) {
	    
	    final QName name = (QName)_sets.elementAt(i);
	    
	    final AttributeSet attrs = symbolTable.lookupAttributeSet(name);
	    
	    if (attrs != null) {
		final String methodName = attrs.getMethodName();
		il.append(classGen.loadTranslet());
		il.append(methodGen.loadHandler());
		il.append(methodGen.loadIterator());
		final int method = cpg.addMethodref(classGen.getClassName(),
						    methodName, ATTR_SET_SIG);
		il.append(new INVOKESPECIAL(method));
	    }
	    
	    else {
		final Parser parser = getParser();
		final String atrs = name.toString();
		reportError(this, parser, ErrorMsg.ATTRIBSET_UNDEF_ERR, atrs);
	    }
	}
    }
}
"
org.apache.xpath.functions.Function2Args,9,4,7,20,23,6,12,9,8,0.375,123,0.0,1,0.857142857,0.355555556,3,9,12.55555556,6,1.7778,0,"
package org.apache.xpath.functions;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;


public class Function2Args extends FunctionOneArg
{

  
  Expression m_arg1;

  
  public Expression getArg1()
  {
    return m_arg1;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    if(null != m_arg1)
      m_arg1.fixupVariables(vars, globalsSize);
  }


  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {

    
    if (argNum == 0)
      super.setArg(arg, argNum);
    else if (1 == argNum)
    {
      m_arg1 = arg;
      arg.exprSetParent(this);
    }
    else
		  reportWrongNumberArgs();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum != 2)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""two"", null));
  }
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return super.canTraverseOutsideSubtree() 
    ? true : m_arg1.canTraverseOutsideSubtree();
   }
   
  class Arg1Owner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_arg1;
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(Function2Args.this);
    	m_arg1 = exp;
    }
  }

   
  
  public void callArgVisitors(XPathVisitor visitor)
  {
  	super.callArgVisitors(visitor);
  	if(null != m_arg1)
  		m_arg1.callVisitors(new Arg1Owner(), visitor);
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(null != m_arg1)
  	{
  		if(null == ((Function2Args)expr).m_arg1)
  			return false;
  			
  		if(!m_arg1.deepEquals(((Function2Args)expr).m_arg1))
  			return false;
  	}
  	else if(null != ((Function2Args)expr).m_arg1)
  		return false;
  		
  	return true;
  }

}
"
org.apache.xpath.objects.XBoolean,10,3,1,26,17,1,24,3,9,0.703703704,99,0.0,2,0.91025641,0.333333333,2,22,8.6,3,1.3,1,"
package org.apache.xpath.objects;

import org.w3c.dom.*;


public class XBoolean extends XObject
{

  
  public static XBoolean S_TRUE = new XBooleanStatic(true);

  
  public static XBoolean S_FALSE = new XBooleanStatic(false);

  
  boolean m_val;

  
  public XBoolean(boolean b)
  {

    super();

    m_val = b;
  }
  
  
  public XBoolean(Boolean b)
  {

    super();

    m_val = b.booleanValue();
    m_obj = b;
  }


  
  public int getType()
  {
    return CLASS_BOOLEAN;
  }

  
  public String getTypeString()
  {
    return ""#BOOLEAN"";
  }

  
  public double num()
  {
    return m_val ? 1.0 : 0.0;
  }

  
  public boolean bool()
  {
    return m_val;
  }

  
  public String str()
  {
    return m_val ? ""true"" : ""false"";
  }

  
  public Object object()
  {
    if(null == m_obj)
      m_obj = m_val ? S_TRUE : S_FALSE;
    return m_obj;
  }

  
  public boolean equals(XObject obj2)
  {

    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.equals(this);

    try
    {
      return m_val == obj2.bool();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }

}
"
org.apache.xpath.axes.UnionPathIterator,16,5,0,23,52,46,4,22,13,0.6,561,1.0,2,0.899280576,0.2,2,13,33.9375,9,2.4375,1,"
package org.apache.xpath.axes;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;
import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.OpCodes;


public class UnionPathIterator extends LocPathIterator
        implements Cloneable, DTMIterator, java.io.Serializable, PathComponent
{

  
  public UnionPathIterator()
  {

    super();

    
    
    m_iterators = null;
    m_exprs = null;
  }

  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);

    try
    {
      if (null != m_exprs)
      {
        int n = m_exprs.length;
        DTMIterator newIters[] = new DTMIterator[n];
  
        for (int i = 0; i < n; i++)
        {
          DTMIterator iter = m_exprs[i].asIterator(m_execContext, context);
          newIters[i] = iter;
          iter.nextNode();
        }
        m_iterators = newIters;
      }
    }
    catch(Exception e)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(e);
    }
  }
  
  
  public void addIterator(DTMIterator expr)
  {

    
    
    if (null == m_iterators)
    {
      m_iterators = new DTMIterator[1];
      m_iterators[0] = expr;
    }
    else
    {
      DTMIterator[] exprs = m_iterators;
      int len = m_iterators.length;

      m_iterators = new DTMIterator[len + 1];

      System.arraycopy(exprs, 0, m_iterators, 0, len);

      m_iterators[len] = expr;
    }
    expr.nextNode();
    if(expr instanceof Expression)
    	((Expression)expr).exprSetParent(this);
  }
  
  
  public void detach()
  {    
    if(null != m_iterators)
    {
    	int n = m_iterators.length;
    	for(int i = 0; i < n; i++)
    	{
    		m_iterators[i].detach();
    	}
    	m_iterators = null;
    }
  }


  
  public UnionPathIterator(Compiler compiler, int opPos)
          throws javax.xml.transform.TransformerException
  {

    super();

    opPos = compiler.getFirstChildPos(opPos);

    loadLocationPaths(compiler, opPos, 0);
  }
  
  
  public static LocPathIterator createUnionIterator(Compiler compiler, int opPos)
          throws javax.xml.transform.TransformerException
  {
  	
  	
  	
  	
  	UnionPathIterator upi = new UnionPathIterator(compiler, opPos);
  	int nPaths = upi.m_exprs.length;
  	boolean isAllChildIterators = true;
  	for(int i = 0; i < nPaths; i++)
  	{
  		LocPathIterator lpi = upi.m_exprs[i];
  		
  		if(lpi.getAxis() != Axis.CHILD)
  		{
  			isAllChildIterators = false;
  			break;
  		}
  		else
  		{
  			
  			if(HasPositionalPredChecker.check(lpi))
  			{
  				isAllChildIterators = false;
  				break;
  			}
  		}
  	}
  	if(isAllChildIterators)
  	{
  		UnionChildIterator uci = new UnionChildIterator();
  		
	  	for(int i = 0; i < nPaths; i++)
	  	{
	  		PredicatedNodeTest lpi = upi.m_exprs[i];
	  		
	  		
	  		
	  		uci.addNodeTest(lpi);
	  	}
	  	return uci;
  		
  	}
  	else
  		return upi;
  }
  
  
  public int getAnalysisBits()
  {
    int bits = 0;
    
    if (m_exprs != null)
    {
      int n = m_exprs.length;

      for (int i = 0; i < n; i++)
      {
      	int bit = m_exprs[i].getAnalysisBits();
        bits |= bit;
      }
    }

    return bits;
  }
  
  
  private void readObject(java.io.ObjectInputStream stream)
          throws java.io.IOException, javax.xml.transform.TransformerException
  {
    try
    {
      stream.defaultReadObject();
      m_clones =  new IteratorPool(this);
    }
    catch (ClassNotFoundException cnfe)
    {
      throw new javax.xml.transform.TransformerException(cnfe);
    }
  }

  
  public Object clone() throws CloneNotSupportedException
  {

    UnionPathIterator clone = (UnionPathIterator) super.clone();












    return clone;
  }
  
  
  
  protected LocPathIterator createDTMIterator(
          Compiler compiler, int opPos) throws javax.xml.transform.TransformerException
  {
    LocPathIterator lpi = (LocPathIterator)WalkerFactory.newDTMIterator(compiler, opPos, 
                                      (compiler.getLocationPathDepth() <= 0));
    return lpi;
  }

  
  protected void loadLocationPaths(Compiler compiler, int opPos, int count)
          throws javax.xml.transform.TransformerException
  {

    
    int steptype = compiler.getOpMap()[opPos];

    if (steptype == OpCodes.OP_LOCATIONPATH)
    {
      loadLocationPaths(compiler, compiler.getNextOpPos(opPos), count + 1);

      m_exprs[count] = createDTMIterator(compiler, opPos);
      m_exprs[count].exprSetParent(this);
    }
    else
    {

      
      
      switch (steptype)
      {
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
        loadLocationPaths(compiler, compiler.getNextOpPos(opPos), count + 1);

        WalkingIterator iter =
          new WalkingIterator(compiler.getNamespaceContext());
        iter.exprSetParent(this);
          
        if(compiler.getLocationPathDepth() <= 0)
          iter.setIsTopLevel(true);

        iter.m_firstWalker = new org.apache.xpath.axes.FilterExprWalker(iter);

        iter.m_firstWalker.init(compiler, opPos, steptype);

        m_exprs[count] = iter;
        break;
      default :
        m_exprs = new LocPathIterator[count];
      }
    }
  }

  
  public int nextNode()
  {
  	if(m_foundLast)
  		return DTM.NULL;

    
    
    int earliestNode = DTM.NULL;

    if (null != m_iterators)
    {
      int n = m_iterators.length;
      int iteratorUsed = -1;

      for (int i = 0; i < n; i++)
      {
        int node = m_iterators[i].getCurrentNode();

        if (DTM.NULL == node)
          continue;
        else if (DTM.NULL == earliestNode)
        {
          iteratorUsed = i;
          earliestNode = node;
        }
        else
        {
          if (node == earliestNode)
          {

            
            m_iterators[i].nextNode();
          }
          else
          {
            DTM dtm = getDTM(node);

            if (dtm.isNodeAfter(node, earliestNode))
            {
              iteratorUsed = i;
              earliestNode = node;
            }
          }
        }
      }

      if (DTM.NULL != earliestNode)
      {
        m_iterators[iteratorUsed].nextNode();

        incrementCurrentPos();
      }
      else
        m_foundLast = true;
    }

    m_lastFetched = earliestNode;

    return earliestNode;
  }
            
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    for (int i = 0; i < m_exprs.length; i++) 
    {
      m_exprs[i].fixupVariables(vars, globalsSize);
    }
    
  }
  
  
  protected LocPathIterator[] m_exprs;

    
  
  protected DTMIterator[] m_iterators;
      
  
  public int getAxis()
  {
    
    return -1;
  }
  
  class iterOwner implements ExpressionOwner
  {
  	int m_index;
  	
  	iterOwner(int index)
  	{
  		m_index = index;
  	}
  	
    
    public Expression getExpression()
    {
      return m_exprs[m_index];
    }


    
    public void setExpression(Expression exp)
    {
    	
    	if(!(exp instanceof LocPathIterator))
    	{
    		
    		
    		WalkingIterator wi = new WalkingIterator(getPrefixResolver());
    		FilterExprWalker few = new FilterExprWalker(wi);
    		wi.setFirstWalker(few);
    		few.setInnerExpression(exp);
    		wi.exprSetParent(UnionPathIterator.this);
    		few.exprSetParent(wi);
    		exp.exprSetParent(few);
    		exp = wi;
    	}
    	else
    		exp.exprSetParent(UnionPathIterator.this);
    	m_exprs[m_index] = (LocPathIterator)exp;
    }


  }

  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	 	if(visitor.visitUnionPath(owner, this))
  	 	{
  	 		if(null != m_exprs)
  	 		{
  	 			int n = m_exprs.length;
  	 			for(int i = 0; i < n; i++)
  	 			{
  	 				m_exprs[i].callVisitors(new iterOwner(i), visitor);
  	 			}
  	 		}
  	 	}
  }
  
    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
            return false;

      UnionPathIterator upi = (UnionPathIterator) expr;

      if (null != m_exprs)
      {
        int n = m_exprs.length;
        
        if((null == upi.m_exprs) || (upi.m_exprs.length != n))
        	return false;
        
        for (int i = 0; i < n; i++)
        {
          if(!m_exprs[i].deepEquals(upi.m_exprs[i]))
          	return false;
        }
      }
      else if (null != upi.m_exprs)
      {
          return false;
      }

      return true;
    }


}
"
org.apache.xalan.xsltc.compiler.TestSeq,11,1,0,15,45,0,1,15,9,0.633333333,360,1.0,2,0.0,0.222222222,0,0,31.18181818,11,2.4545,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Hashtable;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.Iterator;

import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;


final class TestSeq {

    
    private int _kernelType;

    
    private Vector _patterns = null;

    
    private Mode _mode = null;

    
    private Template _default = null;

    
    private InstructionList _instructionList;

    
    private InstructionHandle _start = null;

    
    public TestSeq(Vector patterns, Mode mode) {
	this(patterns, -2, mode);
    }

    public TestSeq(Vector patterns, int kernelType, Mode mode) {
	_patterns = patterns;
	_kernelType = kernelType;
	_mode = mode;
    }

    
    public String toString() {
	final int count = _patterns.size();
	final StringBuffer result = new StringBuffer();

	for (int i = 0; i < count; i++) {
	    final LocationPathPattern pattern =
		(LocationPathPattern) _patterns.elementAt(i);

	    if (i == 0) {
		result.append(""Testseq for kernel "" + _kernelType)
		      .append('
');
	    }
	    result.append(""   pattern "" + i + "": "")
	          .append(pattern.toString())
		  .append('
');
	}
	return result.toString();
    }

    
    public InstructionList getInstructionList() {
	return _instructionList;
    }

    
    public double getPriority() {
	final Template template = (_patterns.size() == 0) ? _default 
	    : ((Pattern) _patterns.elementAt(0)).getTemplate();
	return template.getPriority();
    }

    
    public int getPosition() {
	final Template template = (_patterns.size() == 0) ? _default 
	    : ((Pattern) _patterns.elementAt(0)).getTemplate();
	return template.getPosition();
    }

    
    public void reduce() {
	final Vector newPatterns = new Vector();

	final int count = _patterns.size();
	for (int i = 0; i < count; i++) {
	    final LocationPathPattern pattern =
		(LocationPathPattern)_patterns.elementAt(i);
		
	    
	    pattern.reduceKernelPattern();
			
	    
	    if (pattern.isWildcard()) {
		_default = pattern.getTemplate();
		break; 		
	    }
	    else {
		newPatterns.addElement(pattern);
	    }
	}
	_patterns = newPatterns;
    }

    
    public void findTemplates(Dictionary templates) {
	if (_default != null) {
	    templates.put(_default, this);
	}
	for (int i = 0; i < _patterns.size(); i++) {
	    final LocationPathPattern pattern =
		(LocationPathPattern)_patterns.elementAt(i);
	    templates.put(pattern.getTemplate(), this);
	}
    }

    
    private InstructionHandle getTemplateHandle(Template template) {
	return (InstructionHandle)_mode.getTemplateInstructionHandle(template);
    }

    
    private LocationPathPattern getPattern(int n) {
	return (LocationPathPattern)_patterns.elementAt(n);
    }

    
    public InstructionHandle compile(ClassGenerator classGen,
				     MethodGenerator methodGen,
				     InstructionHandle continuation) 
    {
	
	if (_start != null) {
	    return _start;
	}

	
	final int count = _patterns.size();
	if (count == 0) {
	    return (_start = getTemplateHandle(_default));
	}

	
	InstructionHandle fail = (_default == null) ? continuation
	    : getTemplateHandle(_default);
	
	
	for (int n = count - 1; n >= 0; n--) {
	    final LocationPathPattern pattern = getPattern(n);
	    final Template template = pattern.getTemplate();
	    final InstructionList il = new InstructionList();

	    
	    il.append(methodGen.loadCurrentNode());

	    
	    InstructionList ilist = _mode.getInstructionList(pattern);
	    if (ilist == null) {
		ilist = pattern.compile(classGen, methodGen);
		_mode.addInstructionList(pattern, ilist);
	    }

	    
	    InstructionList copyOfilist = ilist.copy();

	    FlowList trueList = pattern.getTrueList();
	    if (trueList != null) {
		trueList = trueList.copyAndRedirect(ilist, copyOfilist);
	    }
	    FlowList falseList = pattern.getFalseList();
	    if (falseList != null) {
		falseList = falseList.copyAndRedirect(ilist, copyOfilist);
	    }

	    il.append(copyOfilist);

	    
	    final InstructionHandle gtmpl = getTemplateHandle(template);
	    final InstructionHandle success = il.append(new GOTO_W(gtmpl));

	    if (trueList != null) {
		trueList.backPatch(success);
	    }
	    if (falseList != null) {
		falseList.backPatch(fail);
	    } 

	    
	    fail = il.getStart();

	    
	    if (_instructionList != null) {
		il.append(_instructionList);
	    }

	    
	    _instructionList = il;
	}
	return (_start = fail);
    }
}
"
org.apache.xml.dtm.ref.ExpandedNameTable,10,1,0,15,24,0,13,3,9,0.970760234,247,0.210526316,3,0.0,0.475,0,0,21.8,4,1.5,1,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.DTM;

import java.util.Vector;
import java.util.Hashtable;


public class ExpandedNameTable
{

  
  private DTMStringPool m_locNamesPool;

  
  private DTMStringPool m_namespaceNames;
  
  
  private  Vector m_extendedTypes;
  
  
  private int m_nextType;
    
  
  public static final int ELEMENT = ((int)DTM.ELEMENT_NODE) ;
  public static final int ATTRIBUTE = ((int)DTM.ATTRIBUTE_NODE) ;
  public static final int TEXT = ((int)DTM.TEXT_NODE) ;
  public static final int CDATA_SECTION = ((int)DTM.CDATA_SECTION_NODE) ;
  public static final int ENTITY_REFERENCE = ((int)DTM.ENTITY_REFERENCE_NODE) ;
  public static final int ENTITY = ((int)DTM.ENTITY_NODE) ;
  public static final int PROCESSING_INSTRUCTION = ((int)DTM.PROCESSING_INSTRUCTION_NODE) ;
  public static final int COMMENT = ((int)DTM.COMMENT_NODE) ;
  public static final int DOCUMENT = ((int)DTM.DOCUMENT_NODE) ;
  public static final int DOCUMENT_TYPE = ((int)DTM.DOCUMENT_TYPE_NODE) ;
  public static final int DOCUMENT_FRAGMENT =((int)DTM.DOCUMENT_FRAGMENT_NODE) ;
  public static final int NOTATION = ((int)DTM.NOTATION_NODE) ;
  public static final int NAMESPACE = ((int)DTM.NAMESPACE_NODE) ;
  
  Hashtable m_hashtable = new Hashtable();
  
	
	ExtendedType hashET=new ExtendedType(-1,"""","""");  
  

  
  public ExpandedNameTable()
  {
    m_locNamesPool = new DTMSafeStringPool();
    m_namespaceNames = new DTMSafeStringPool();
    initExtendedTypes(); 
  }

  
  public ExpandedNameTable(DTMStringPool locNamesPool,
                           DTMStringPool namespaceNames)
  {
    m_locNamesPool = locNamesPool;
    m_namespaceNames = namespaceNames;
    initExtendedTypes();
  }
  
  
  private void initExtendedTypes()
  {
    m_extendedTypes = new Vector();
    int i;
    for (i = 0; i < DTM.NTYPES; i++)
    {
      ExtendedType newET = new ExtendedType(i, """", """"); 
      m_extendedTypes.addElement(newET); 
      m_hashtable.put(newET, new Integer(i));
    }
    m_nextType = m_extendedTypes.size();
  }

  
  public int getExpandedTypeID(String namespace, String localName, int type)
  {
    
    if (null == namespace) 
      namespace = """";
    if (null == localName) 
      localName = """";
    
    
    
    
    hashET.redefine(type,namespace,localName);
    
    Object eType;
    if ((eType = m_hashtable.get(hashET)) != null )
      return ((Integer)eType).intValue();
    
    ExtendedType newET=new ExtendedType(type, namespace, localName);
    m_extendedTypes.addElement(newET);
    m_hashtable.put(newET, new Integer(m_nextType));
    return m_nextType++;
  }
  
  
  public int getExpandedTypeID(int type)
  {    
    return type;    
  }

  
  public String getLocalName(int ExpandedNameID)
  {
    
    ExtendedType etype = (ExtendedType)m_extendedTypes.elementAt (ExpandedNameID);
    return etype.localName;
  }
  
  
  public  final int getLocalNameID(int ExpandedNameID)
  {
    
    ExtendedType etype = (ExtendedType)m_extendedTypes.elementAt (ExpandedNameID);
    if (etype.localName.equals(""""))
      return 0;
    else
    return ExpandedNameID;
  }


  
  public String getNamespace(int ExpandedNameID)
  {

    
    
    ExtendedType etype = (ExtendedType)m_extendedTypes.elementAt (ExpandedNameID);
    return (etype.namespace.equals("""") ? null : etype.namespace); 
  }
  
  
  public  final int getNamespaceID(int ExpandedNameID)
  {
    
    ExtendedType etype = (ExtendedType)m_extendedTypes.elementAt (ExpandedNameID);
    if (etype.namespace.equals(""""))
      return 0;
    else
    return ExpandedNameID;
  }
  
  
  public final short getType(int ExpandedNameID)
  {
    
    ExtendedType etype = (ExtendedType)m_extendedTypes.elementAt (ExpandedNameID);
    return (short)etype.nodetype;
  }
  
  
  
  private class ExtendedType
  {
    protected int nodetype;
    protected String namespace;
    protected String localName;
    protected int hash;
    
    protected ExtendedType (int nodetype, String namespace, String localName)
    {
      this.nodetype = nodetype;
      this.namespace = namespace;
      this.localName = localName;
      this.hash=nodetype+namespace.hashCode()+localName.hashCode();
    }

	
    protected void redefine(int nodetype, String namespace, String localName)
    {
      this.nodetype = nodetype;
      this.namespace = namespace;
      this.localName = localName;
      this.hash=nodetype+namespace.hashCode()+localName.hashCode();
    }
    
    
    public int hashCode() 
    {
    	return hash;
    }

    
	public boolean equals(Object other)
	{
		
		
		
		try
		{
			ExtendedType et=(ExtendedType)other;
			return et.nodetype==this.nodetype &&
				et.localName.equals(this.localName) &&
				et.namespace.equals(this.namespace);
		}
		catch(ClassCastException e)
		{
			return false;
		}
		catch(NullPointerException e)
		{
			return false;
		}
	}
  }
  
}
"
org.apache.xalan.processor.ProcessorDecimalFormat,2,4,0,6,9,1,1,5,1,2.0,27,0.0,0,0.995260664,0.625,2,2,12.5,1,0.5,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.DecimalFormatProperties;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;


class ProcessorDecimalFormat extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    DecimalFormatProperties dfp = new DecimalFormatProperties(handler.nextUid());

    setPropertiesFromAttributes(handler, rawName, attributes, dfp);
    handler.getStylesheet().setDecimalFormat(dfp);
    
    handler.getStylesheet().appendChild(dfp);
  }
}
"
org.apache.xalan.xsltc.dom.SortingIterator,11,2,0,5,26,0,0,5,8,0.666666667,271,1.0,3,0.5,0.309090909,1,5,23.09090909,4,1.6364,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public final class SortingIterator extends NodeIteratorBase {
    private final static int INIT_DATA_SIZE = 16;
    private NodeIterator _source;
    private NodeSortRecordFactory _factory;
    private NodeSortRecord[] _data;
    private int _free = 0;
    private int _current;	

    public SortingIterator(NodeIterator source, 
			   NodeSortRecordFactory factory) {
	_source = source;
	_factory = factory;
    }

    public int next() {
	return _current < _free ? _data[_current++].getNode() : END;
    }
	
    public NodeIterator setStartNode(int node) {
	try {
	    _source.setStartNode(_startNode = node);
	    _data = new NodeSortRecord[INIT_DATA_SIZE];
	    _free = 0;

	    
	    while ((node = _source.next()) != END) {
		addRecord(_factory.makeNodeSortRecord(node,_free));
	    }
	    
	    quicksort(0, _free - 1);

	    _current = 0;
	    return this;
	}
	catch (Exception e) {
	    return this;
	}
    }
	
    public int getPosition() {
	return _current == 0 ? 1 : _current;
    }

    public int getLast() {
	return _free;
    }

    public void setMark() {
	_source.setMark();
	_markedNode = _current;
    }

    public void gotoMark() {
	_source.gotoMark();
	_current = _markedNode;
    }
    
    
    public NodeIterator cloneIterator() {
	try {
	    final SortingIterator clone = (SortingIterator) super.clone();
	    clone._source = _source.cloneIterator();  
	    clone._factory = _factory;		
	    clone._data = _data;		
	    clone._free = _free;
	    clone._current = _current;
	    clone.setRestartable(false);
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }

    private void addRecord(NodeSortRecord record) {
	if (_free == _data.length) {
	    NodeSortRecord[] newArray = new NodeSortRecord[_data.length * 2];
	    System.arraycopy(_data, 0, newArray, 0, _free);
	    _data = newArray;
	}
	_data[_free++] = record;
    }

    private void quicksort(int p, int r) {
	while (p < r) {
	    final int q = partition(p, r);
	    quicksort(p, q);
	    p = q + 1;
	}
    }
    
    private int partition(int p, int r) {
	final NodeSortRecord x = _data[(p + r) >>> 1];
	int i = p - 1;
	int j = r + 1;
	while (true) {
	    while (x.compareTo(_data[--j]) < 0);
	    while (x.compareTo(_data[++i]) > 0);
	    if (i < j) {
		final NodeSortRecord t = _data[i];
		_data[i] = _data[j];
		_data[j] = t;
	    }
	    else {
		return(j);
	    }
	}
    }
}
"
org.apache.xalan.xsltc.runtime.ErrorMessages_no,3,4,0,1,5,1,0,1,2,0.5,79,1.0,0,0.975,0.75,2,3,25.0,3,1.0,0,"

package org.apache.xalan.xsltc.runtime;

import java.util.Vector;
import java.util.Enumeration;
import java.util.ResourceBundle;

public class ErrorMessages_no extends ErrorMessages {

    
    
    private static final String errorMessages[] = {
	
	""Intern programfeil i ''{0}''"",
	
	""Programfeil under utfing av <xsl:copy>."",
	
	""Ugyldig konvertering av ''{0}'' fra ''{1}''."",
	
	""Ekstern funksjon ''{0}'' er ikke stttet av XSLTC."",
	
	""Ugyldig argument i EQUALITY uttrykk."",
	
	""Ugyldig argument ''{0}'' i kall til ''{1}''"",
	
	""Forsk p  formattere nummer ''{0}'' med ''{1}''."",
	
	""Kan ikke klone iterator ''{0}''."",
	
	""Iterator for axis ''{0}'' er ikke stttet."",
	
	""Iterator for typet axis ''{0}'' er ikke stttet."",
	
	""Attributt ''{0}'' utenfor element."",
	
	""Navnedeklarasjon ''{0}''=''{1}'' utenfor element."",
	
	""Prefix ''{0}'' er ikke deklartert."",
	
	""Forsk p  instansiere DOMAdapter med feil type DOM.""
    };

    public Object handleGetObject(String key) {
	if (key == null) return null;
	if (key.equals(BasisLibrary.ERROR_MESSAGES_KEY)) return errorMessages;
	return(null);
    }

}
"
org.apache.xml.utils.res.XResources_el,3,4,0,1,4,1,0,1,2,0.5,575,0.0,0,0.976190476,1.0,0,0,190.3333333,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_el extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""el"" }, { ""help_language"", ""el"" }, { ""language"", ""el"" },
    { ""alphabet"",
      new char[]{ 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03b6, 0x03b7,
                  0x03b8, 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be,
                  0x03bf, 0x03c0, 0x03c1, 0x03c2, 0x03c3, 0x03c4, 0x03c5,
                  0x03c6, 0x03c7, 0x03c8, 0x03c9 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""precedes"" },

    
    
    
    { ""numberGroups"", new int[]{ 100, 10, 1 } },

    
    { ""multiplier"", new long[]{ 1000 } },
    { ""multiplierChar"", new char[]{ 0x03d9 } },

    
    { ""zero"", new char[0] },

    
    { ""digits"",
      new char[]{ 0x03b1, 0x03b2, 0x03b3, 0x03b4, 0x03b5, 0x03db, 0x03b6,
                  0x03b7, 0x03b8 } },
    { ""tens"",
      new char[]{ 0x03b9, 0x03ba, 0x03bb, 0x03bc, 0x03bd, 0x03be, 0x03bf,
                  0x03c0, 0x03df } },
    { ""hundreds"",
      new char[]{ 0x03c1, 0x03c2, 0x03c4, 0x03c5, 0x03c6, 0x03c7, 0x03c8,
                  0x03c9, 0x03e1 } },

    
    
    { ""tables"", new String[]{ ""hundreds"", ""tens"", ""digits"" } }
  };
}
"
org.apache.xml.dtm.DTMDOMException,2,5,0,3,3,1,3,0,2,2.0,12,0.0,0,1.0,0.833333333,0,0,5.0,0,0.0,0,"
package org.apache.xml.dtm;


public class DTMDOMException extends org.w3c.dom.DOMException
{
  
  public DTMDOMException(short code, String message)
  {
    super(code, message);
  }

  
  public DTMDOMException(short code)
  {
    super(code, """");
  }
}
"
org.apache.xalan.xsltc.dom.ReverseIterator,8,2,0,2,14,0,0,2,8,0.666666667,152,1.0,1,0.588235294,0.416666667,1,5,17.25,5,1.5,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.TransletException;

public final class ReverseIterator extends NodeIteratorBase {

    private final static int INIT_DATA_SIZE = 16;
    private final NodeIterator _source;
    private int[] _data = null;
    private int _last = 0;
    private int _current = 0;
    private int _start = -1;

    public ReverseIterator(NodeIterator source) {
	_source = source;
    }

    public int next() {
	return _current > 0 ? _data[--_current] : END;
    }
	
    public NodeIterator setStartNode(int node) {
	if ((_data == null) || (node != _start)) {
	    _start = node;
	    _source.setStartNode(node);
	    _data = new int[INIT_DATA_SIZE];
	    _last = 0;
	    
	    while ((node = _source.next()) != END) {
		if (_last == _data.length) {
		    int[] newArray = new int[_data.length * 2];
		    System.arraycopy(_data, 0, newArray, 0, _last);
		    _data = newArray;
		}
		_data[_last++] = node;
	    }
	}
	_startNode = _current = _last;
	return this;
    }

    public NodeIterator reset() {
	_current = _startNode;
	return this;
    }

    public int getPosition() {
	return (_last - _current);
    }

    public int getLast() {
	return _last;
    }

    public void setMark() {
	_source.setMark();
	_markedNode = _current;
    }

    public void gotoMark() {
	_source.gotoMark();
	_current = _markedNode;
    }

}
"
org.apache.xpath.XPathException,13,4,1,6,25,8,4,2,12,0.541666667,257,0.5,0,0.771428571,0.269230769,2,4,18.61538462,5,1.8462,0,"
package org.apache.xpath;

import java.io.PrintStream;
import java.io.PrintWriter;

import javax.xml.transform.TransformerException;
import org.w3c.dom.Node;


public class XPathException extends TransformerException
{

  
  Object m_styleNode = null;

  
  public Object getStylesheetNode()
  {
    return m_styleNode;
  }
  
  
  public void setStylesheetNode(Object styleNode)
  {
    m_styleNode = styleNode;
  }


  
  protected Exception m_exception;

  
  public XPathException(String message, ExpressionNode ex)
  {
    super(message);
    this.setLocator(ex);
    setStylesheetNode(getStylesheetNode(ex));
  }
  
  
  public XPathException(String message)
  {
    super(message);
  }

  
  
  public org.w3c.dom.Node getStylesheetNode(ExpressionNode ex)
  {
  	
    ExpressionNode owner = getExpressionOwner(ex);

    if (null != owner && owner instanceof org.w3c.dom.Node)
    {
		return ((org.w3c.dom.Node)owner);
    }
    return null;

  }
  
  
  protected ExpressionNode getExpressionOwner(ExpressionNode ex)
  {
  	ExpressionNode parent = ex.exprGetParent();
  	while((null != parent) && (parent instanceof Expression))
  		parent = parent.exprGetParent();
  	return parent;
  }



  
  public XPathException(String message, Object styleNode)
  {

    super(message);

    m_styleNode = styleNode;
  }

  
  public XPathException(String message, Node styleNode, Exception e)
  {

    super(message);

    m_styleNode = styleNode;
    this.m_exception = e;
  }

  
  public XPathException(String message, Exception e)
  {

    super(message);

    this.m_exception = e;
  }

  
  public void printStackTrace(java.io.PrintStream s)
  {

    if (s == null)
      s = System.err;

    try
    {
      super.printStackTrace(s);
    }
    catch (Exception e){}

    Throwable exception = m_exception;

    for (int i = 0; (i < 10) && (null != exception); i++)
    {
      s.println(""---------"");
      exception.printStackTrace(s);

      if (exception instanceof TransformerException)
      {
        TransformerException se = (TransformerException) exception;
        Throwable prev = exception;

        exception = se.getException();

        if (prev == exception)
          break;
      }
      else
      {
        exception = null;
      }
    }
  }

  
  public String getMessage()
  {

    String lastMessage = super.getMessage();
    Throwable exception = m_exception;

    while (null != exception)
    {
      String nextMessage = exception.getMessage();

      if (null != nextMessage)
        lastMessage = nextMessage;

      if (exception instanceof TransformerException)
      {
        TransformerException se = (TransformerException) exception;
        Throwable prev = exception;

        exception = se.getException();

        if (prev == exception)
          break;
      }
      else
      {
        exception = null;
      }
    }

    return (null != lastMessage) ? lastMessage : """";
  }

  
  public void printStackTrace(java.io.PrintWriter s)
  {

    if (s == null)
      s = new java.io.PrintWriter(System.err);

    try
    {
      super.printStackTrace(s);
    }
    catch (Exception e){}

    Throwable exception = m_exception;

    for (int i = 0; (i < 10) && (null != exception); i++)
    {
      s.println(""---------"");

      try
      {
        exception.printStackTrace(s);
      }
      catch (Exception e)
      {
        s.println(""Could not print stack trace..."");
      }

      if (exception instanceof TransformerException)
      {
        TransformerException se = (TransformerException) exception;
        Throwable prev = exception;

        exception = se.getException();

        if (prev == exception)
        {
          exception = null;

          break;
        }
      }
      else
      {
        exception = null;
      }
    }
  }

  
  public Throwable getException()
  {
    return m_exception;
  }
}
"
org.apache.xalan.xsltc.trax.XSLTCSource,10,1,0,5,33,0,1,4,8,0.472222222,182,1.0,2,0.0,0.4,0,0,16.8,2,0.9,0,"


package org.apache.xalan.xsltc.trax;

import java.io.File;
import java.io.IOException;

import org.xml.sax.XMLReader;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.InputSource;
import org.xml.sax.ext.LexicalHandler;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;

import javax.xml.transform.Source;

import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.dom.DOMImpl;
import org.apache.xalan.xsltc.dom.DOMBuilder;
import org.apache.xalan.xsltc.dom.DTDMonitor;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;

public final class XSLTCSource implements Source {

    private String     _systemId = null;
    private DOMImpl    _dom      = null;
    private DTDMonitor _dtd      = null;

    private final static String LEXICAL_HANDLER_PROPERTY =
	""http:

    
    public XSLTCSource(int size) {
	_dom = new DOMImpl(size);
	_dtd = new DTDMonitor();
    }

    
    public XSLTCSource() {
	_dom = new DOMImpl();
	_dtd = new DTDMonitor();
    }

    
    public void setSystemId(String systemId) {
	if ((new File(systemId)).exists())
	    _systemId = ""file:""+systemId;
	else
	    _systemId = systemId;
	_dom.setDocumentURI(_systemId);
    }

    
    public String getSystemId() {
	return(_systemId);
    }

    
    public void build(XMLReader reader, String systemId) throws SAXException {
	try {
	    
	    if ((systemId == null) && (_systemId == null)) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.XSLTC_SOURCE_ERR);
		throw new SAXException(err.toString());
	    }

	    
	    if (systemId == null) systemId = _systemId;
	    setSystemId(systemId);

	    
	    
	    
	    InputSource input = new InputSource(systemId);

	    
	    
	    
	    _dtd.handleDTD(reader);

	    DOMBuilder builder = _dom.getBuilder();

	    
	    reader.setContentHandler(builder);
	    try {
		reader.setProperty(LEXICAL_HANDLER_PROPERTY, builder);
	    }
	    catch (SAXException e) {
		
	    }

	    
	    reader.parse(input);
	}
	catch (IOException e) {
	    throw new SAXException(e);
	}
    }

    
    public void build(String systemId) throws SAXException {
	try {
	    
	    final SAXParserFactory factory = SAXParserFactory.newInstance();
	    final SAXParser parser = factory.newSAXParser();
	    final XMLReader reader = parser.getXMLReader();

	    build(reader, systemId);
	}
	catch (ParserConfigurationException e) {
	    throw new SAXException(e);
	}
    }

    
    public void build(XMLReader reader) throws SAXException {
	build(reader, _systemId);
    }

    
    public void build() throws SAXException {
	build(_systemId);
    }    

    
    protected DOMImpl getDOM() {
	return(_dom);
    }

    
    protected DTDMonitor getDTD() {
	return(_dtd);
    }

}
"
org.apache.xalan.templates.XUnresolvedVariable,6,3,0,7,23,9,1,7,6,0.833333333,134,1.0,1,0.934210526,0.361111111,2,12,20.33333333,1,0.8333,0,"
package org.apache.xalan.templates;

import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.VariableStack;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xpath.objects.XString;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


import org.apache.xml.dtm.DTM;


public class XUnresolvedVariable extends XObject
{  
  
  transient private int m_context;
  
  
  transient private TransformerImpl m_transformer;
  
  
  transient private int m_varStackPos = -1;

  
  transient private int m_varStackContext;
  
  
  private boolean m_isGlobal;
  
  
  transient private boolean m_doneEval = true;
  
  
  public XUnresolvedVariable(ElemVariable obj, int sourceNode, 
                             TransformerImpl transformer,
                             int varStackPos, int varStackContext,
                             boolean isGlobal)
  {
    super(obj);
    m_context = sourceNode;
    m_transformer = transformer;
    
    
    
    m_varStackPos = varStackPos;
    
    
    m_varStackContext = varStackContext;
    
    m_isGlobal = isGlobal;
  }
    
  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    if (!m_doneEval) 
    {
      this.m_transformer.getMsgMgr().error      
        (xctxt.getSAXLocator(), XSLTErrorResources.ER_REFERENCING_ITSELF, 
          new Object[]{((ElemVariable)this.object()).getName().getLocalName()}); 
    }
    VariableStack vars = xctxt.getVarStack();
    
    
    int currentFrame = vars.getStackFrame();
    
   

    ElemVariable velem = (ElemVariable)m_obj;
    try
    {
      m_doneEval = false;
      if(-1 != velem.m_frameSize)
      	vars.link(velem.m_frameSize);
      XObject var = velem.getValue(m_transformer, m_context);
      m_doneEval = true;
      return var;
    }
    finally
    {
      
      
      
      if(-1 != velem.m_frameSize)
	  	vars.unlink(currentFrame);
    }
  }
  
  
  public void setVarStackPos(int top)
  {
    m_varStackPos = top;
  }

  
  public void setVarStackContext(int bottom)
  {
    m_varStackContext = bottom;
  }
  
  
  public int getType()
  {
    return CLASS_UNRESOLVEDVARIABLE;
  }
  
  
  public String getTypeString()
  {
    return ""XUnresolvedVariable ("" + object().getClass().getName() + "")"";
  }


}
"
org.apache.xml.utils.MutableAttrListImpl,5,2,0,2,18,10,2,0,5,2.0,107,0.0,0,0.888888889,0.6,1,2,20.4,4,1.8,0,"
package org.apache.xml.utils;

import org.apache.xml.utils.StringVector;

import org.xml.sax.Attributes;

import java.io.Serializable;

import org.xml.sax.helpers.AttributesImpl;


public class MutableAttrListImpl extends AttributesImpl
        implements Serializable
{



public MutableAttrListImpl()
  {
    super();
  }

  
  public MutableAttrListImpl(Attributes atts)
  {
    super(atts);
  }

  
  public void addAttribute(String uri, String localName, String qName,
                           String type, String value)
  {

    if (null == uri)
      uri = """";

    
    
    int index = this.getIndex(qName);
    
   
    

    if (index >= 0)
      this.setAttribute(index, uri, localName, qName, type, value);
    else
      super.addAttribute(uri, localName, qName, type, value);
  }

  
  public void addAttributes(Attributes atts)
  {

    int nAtts = atts.getLength();

    for (int i = 0; i < nAtts; i++)
    {
      String uri = atts.getURI(i);

      if (null == uri)
        uri = """";

      String localName = atts.getLocalName(i);
      String qname = atts.getQName(i);
      int index = this.getIndex(uri, localName);
      
      if (index >= 0)
        this.setAttribute(index, uri, localName, qname, atts.getType(i),
                          atts.getValue(i));
      else
        addAttribute(uri, localName, qname, atts.getType(i),
                     atts.getValue(i));
    }
  }

  
  public boolean contains(String name)
  {
    return getValue(name) != null;
  }
}


"
org.apache.xalan.serialize.ElemDesc,4,1,0,2,8,0,1,1,0,1.269230769,80,0.0,1,0.0,0.833333333,0,0,12.5,3,1.75,0,"
package org.apache.xalan.serialize;

import org.apache.xml.utils.StringToIntTable;


class ElemDesc
{

  
  int m_flags;

  
  StringToIntTable m_attrs = null;

  
  static final int EMPTY = (1 << 1);

  
  static final int FLOW = (1 << 2);

  
  static final int BLOCK = (1 << 3);

  
  static final int BLOCKFORM = (1 << 4);

  
  static final int BLOCKFORMFIELDSET = (1 << 5);

  
  static final int CDATA = (1 << 6);

  
  static final int PCDATA = (1 << 7);

  
  static final int RAW = (1 << 8);

  
  static final int INLINE = (1 << 9);

  
  static final int INLINEA = (1 << 10);

  
  static final int INLINELABEL = (1 << 11);

  
  static final int FONTSTYLE = (1 << 12);

  
  static final int PHRASE = (1 << 13);

  
  static final int FORMCTRL = (1 << 14);

  
  static final int SPECIAL = (1 << 15);

  
  static final int ASPECIAL = (1 << 16);

  
  static final int HEADMISC = (1 << 17);

  
  static final int HEAD = (1 << 18);

  
  static final int LIST = (1 << 19);

  
  static final int PREFORMATTED = (1 << 20);

  
  static final int WHITESPACESENSITIVE = (1 << 21);

  
  static final int HEADELEM = (1 << 22);

  
  static final int ATTRURL = (1 << 1);

  
  static final int ATTREMPTY = (1 << 2);

  
  ElemDesc(int flags)
  {
    m_flags = flags;
  }

  
  boolean is(int flags)
  {

    
    return (m_flags & flags) != 0;
  }

  
  void setAttr(String name, int flags)
  {

    if (null == m_attrs)
      m_attrs = new StringToIntTable();

    m_attrs.put(name, flags);
  }

  
  boolean isAttrFlagSet(String name, int flags)
  {
    return (null != m_attrs) ? ((m_attrs.getIgnoreCase(name) & flags) != 0) : false;
  }
}
"
org.apache.xalan.transformer.Counter,3,1,0,5,8,0,1,4,0,0.833333333,84,0.0,2,0.0,0.466666667,0,0,25.0,4,2.0,0,"
package org.apache.xalan.transformer;


import org.apache.xml.dtm.DTM;

import org.apache.xml.utils.NodeVector;
import org.apache.xpath.NodeSetDTM;  
import org.apache.xpath.XPathContext;

import javax.xml.transform.TransformerException;

import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPath;
import org.apache.xalan.templates.ElemNumber;


public class Counter
{

  
  static final int MAXCOUNTNODES = 500;

  
  int m_countNodesStartCount = 0;

  
  NodeSetDTM m_countNodes;

  
  int m_fromNode = DTM.NULL;

  
  ElemNumber m_numberElem;

  
  int m_countResult;

  
  Counter(ElemNumber numberElem, NodeSetDTM countNodes) throws TransformerException
  {
    m_countNodes = countNodes;
    m_numberElem = numberElem;
  }

  

  
  int getPreviouslyCounted(XPathContext support, int node)
  {

    int n = m_countNodes.size();

    m_countResult = 0;

    for (int i = n - 1; i >= 0; i--)
    {
      int countedNode = m_countNodes.elementAt(i);

      if (node == countedNode)
      {

        
        
        m_countResult = i + 1 + m_countNodesStartCount;

        break;
      }
      
      DTM dtm = support.getDTM(countedNode);

      
      
      if (dtm.isNodeAfter(countedNode, node))
        break;
    }

    return m_countResult;
  }

  
  int getLast()
  {

    int size = m_countNodes.size();

    return (size > 0) ? m_countNodes.elementAt(size - 1) : DTM.NULL;
  }
}
"
org.apache.xalan.xsltc.compiler.NotCall,3,4,0,16,12,3,1,15,3,2.0,56,0.0,0,0.979591837,0.6,2,6,17.66666667,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class NotCall extends FunctionCall {
    public NotCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	argument().translate(classGen, methodGen);
	il.append(ICONST_1);
	il.append(IXOR);
    }

    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	final Expression exp = argument();
	exp.translateDesynthesized(classGen, methodGen);
	final BranchHandle gotoh = il.append(new GOTO(null));
	_trueList = exp._falseList; 	
	_falseList = exp._trueList;
	_falseList.add(gotoh);
    }
}
"
org.apache.xalan.templates.ElemUse,7,3,4,9,16,0,4,6,6,0.166666667,119,1.0,1,0.97029703,0.428571429,0,0,15.85714286,2,1.0,0,"
package org.apache.xalan.templates;

import java.util.Vector;

import org.apache.xml.dtm.DTM;

import javax.xml.transform.TransformerException;

import org.apache.xpath.*;
import org.apache.xml.utils.QName;

import java.util.StringTokenizer;

import org.apache.xalan.transformer.TransformerImpl;


public class ElemUse extends ElemTemplateElement
{

  
  private QName m_attributeSetsNames[] = null;

  
  public void setUseAttributeSets(Vector v)
  {

    int n = v.size();

    m_attributeSetsNames = new QName[n];

    for (int i = 0; i < n; i++)
    {
      m_attributeSetsNames[i] = (QName) v.elementAt(i);
    }
  }

  
  public void setUseAttributeSets(QName[] v)
  {
    m_attributeSetsNames = v;
  }

  
  public QName[] getUseAttributeSets()
  {
    return m_attributeSetsNames;
  }
  
  
  public void applyAttrSets(
          TransformerImpl transformer, StylesheetRoot stylesheet)
            throws TransformerException
  {
    applyAttrSets(transformer, stylesheet, m_attributeSetsNames);
  }

  
  private void applyAttrSets(
          TransformerImpl transformer, StylesheetRoot stylesheet, QName attributeSetsNames[])
            throws TransformerException
  {

    if (null != attributeSetsNames)
    {
      int nNames = attributeSetsNames.length;

      for (int i = 0; i < nNames; i++)
      {
        QName qname = attributeSetsNames[i];
        Vector attrSets = stylesheet.getAttributeSetComposed(qname);

        if (null != attrSets)
        {
          int nSets = attrSets.size();

          
          
          for (int k = nSets-1; k >= 0 ; k--)
          {
            ElemAttributeSet attrSet =
              (ElemAttributeSet) attrSets.elementAt(k);

            attrSet.execute(transformer);
          }
        }
      }
    }
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    if (null != m_attributeSetsNames)
    {
      applyAttrSets(transformer, getStylesheetRoot(),
                    m_attributeSetsNames);
    }
    
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this); 
  }
}
"
org.apache.xpath.functions.Function3Args,9,5,4,14,23,6,6,9,8,0.375,124,0.0,1,0.875,0.355555556,4,15,12.66666667,6,1.7778,0,"
package org.apache.xpath.functions;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;


public class Function3Args extends Function2Args
{

  
  Expression m_arg2;

  
  public Expression getArg2()
  {
    return m_arg2;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    if(null != m_arg2)
      m_arg2.fixupVariables(vars, globalsSize);
  }

  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {

    if (argNum < 2)
      super.setArg(arg, argNum);
    else if (2 == argNum)
    {
      m_arg2 = arg;
      arg.exprSetParent(this);
    }
    else
		  reportWrongNumberArgs();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum != 3)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""three"", null));
  }
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return super.canTraverseOutsideSubtree() 
    ? true : m_arg2.canTraverseOutsideSubtree();
   }
   
  class Arg2Owner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_arg2;
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(Function3Args.this);
    	m_arg2 = exp;
    }
  }

   
  
  public void callArgVisitors(XPathVisitor visitor)
  {
  	super.callArgVisitors(visitor);
  	if(null != m_arg2)
  		m_arg2.callVisitors(new Arg2Owner(), visitor);
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(null != m_arg2)
  	{
  		if(null == ((Function3Args)expr).m_arg2)
  			return false;

  		if(!m_arg2.deepEquals(((Function3Args)expr).m_arg2))
  			return false;
  	}
  	else if (null != ((Function3Args)expr).m_arg2)
  		return false;
  		
  	return true;
  }


}
"
org.apache.xpath.objects.XObjectFactory,3,1,0,13,19,3,1,13,3,2.0,207,0.0,0,0.0,0.444444444,0,0,68.0,11,5.3333,0,"package org.apache.xpath.objects;

import org.apache.xml.dtm.*;
import org.apache.xpath.XPathContext;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.axes.OneStepIterator;


public class XObjectFactory
{
  
  
  static public XObject create(Object val)
  {

    XObject result;

    if (val instanceof XObject)
    {
      result = (XObject) val;
    }
    else if (val instanceof String)
    {
      result = new XString((String) val);
    }
    else if (val instanceof Boolean)
    {
      result = new XBoolean((Boolean)val);
    }
    else if (val instanceof Double)
    {
      result = new XNumber(((Double) val));
    }
    else
    {
      result = new XObject(val);
    }

    return result;
  }
  
  
  static public XObject create(Object val, XPathContext xctxt)
  {

    XObject result;

    if (val instanceof XObject)
    {
      result = (XObject) val;
    }
    else if (val instanceof String)
    {
      result = new XString((String) val);
    }
    else if (val instanceof Boolean)
    {
      result = new XBoolean((Boolean)val);
    }
    else if (val instanceof Number)
    {
      result = new XNumber(((Number) val));
    }
    else if (val instanceof DTM)
    {
      DTM dtm = (DTM)val;
      try
      {
        int dtmRoot = dtm.getDocument();
        DTMAxisIterator iter = dtm.getAxisIterator(Axis.SELF);
        iter.setStartNode(dtmRoot);
        DTMIterator iterator = new OneStepIterator(iter, Axis.SELF);
        iterator.setRoot(dtmRoot, xctxt);
        result = new XNodeSet(iterator);
      }
      catch(Exception ex)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(ex);
      }
    }
    else if (val instanceof DTMAxisIterator)
    {
      DTMAxisIterator iter = (DTMAxisIterator)val;
      try
      {
        DTMIterator iterator = new OneStepIterator(iter, Axis.SELF);
        iterator.setRoot(iter.getStartNode(), xctxt);
        result = new XNodeSet(iterator);
      }
      catch(Exception ex)
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(ex);
      }
    }
    else if (val instanceof DTMIterator)
    {
      result = new XNodeSet((DTMIterator) val);
    }
    
    
    else if (val instanceof org.w3c.dom.Node)
    {
      result = new XNodeSetForDOM((org.w3c.dom.Node)val, xctxt);
    }
    
    
    else if (val instanceof org.w3c.dom.NodeList)
    {
      result = new XNodeSetForDOM((org.w3c.dom.NodeList)val, xctxt);
    }
    else if (val instanceof org.w3c.dom.traversal.NodeIterator)
    {
      result = new XNodeSetForDOM((org.w3c.dom.traversal.NodeIterator)val, xctxt);
    }
    else
    {
      result = new XObject(val);
    }

    return result;
  }
}"
org.apache.xalan.templates.TemplateList,22,1,0,19,74,121,3,18,9,0.680272109,943,0.857142857,4,0.0,0.180952381,0,0,41.54545455,19,3.0455,0,"
package org.apache.xalan.templates;

import java.util.Hashtable;
import java.util.Vector;
import java.util.Enumeration;

import java.io.Serializable;


import org.apache.xml.dtm.DTM;

import org.apache.xml.dtm.ref.ExpandedNameTable;

import javax.xml.transform.TransformerException;

import org.apache.xml.utils.QName;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.XPath;
import org.apache.xpath.compiler.PsuedoNames;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.Expression;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xpath.XPathContext;
import org.apache.xpath.patterns.StepPattern;
import org.apache.xpath.patterns.UnionPattern;


public class TemplateList implements java.io.Serializable
{

  
  public TemplateList()
  {
    super();
  }

  
  public void setTemplate(ElemTemplate template)
  {
    if (null != template.getName())
    {
      ElemTemplate existingTemplate = (ElemTemplate) m_namedTemplates.get(template.getName());
      if (null == existingTemplate)
      {
        m_namedTemplates.put(template.getName(), template);
      }
      else
      {
        int existingPrecedence =
                        existingTemplate.getStylesheetComposed().getImportCountComposed();
        int newPrecedence = template.getStylesheetComposed().getImportCountComposed();
        if (newPrecedence > existingPrecedence)
        {
          
          m_namedTemplates.put(template.getName(), template);
        }
        else if (newPrecedence == existingPrecedence)
          template.error(XSLTErrorResources.ER_DUPLICATE_NAMED_TEMPLATE,
                       new Object[]{ template.getName() });
      }
    }

    XPath matchXPath = template.getMatch();

    if (null != matchXPath)
    {
      Expression matchExpr = matchXPath.getExpression();

      if (matchExpr instanceof StepPattern)
      {
        insertPatternInTable((StepPattern) matchExpr, template);
      }
      else if (matchExpr instanceof UnionPattern)
      {
        UnionPattern upat = (UnionPattern) matchExpr;
        StepPattern[] pats = upat.getPatterns();
        int n = pats.length;

        for (int i = 0; i < n; i++)
        {
          insertPatternInTable(pats[i], template);
        }
      }
      else
      {

        
      }
    }
  }

  
  static boolean DEBUG = false;

  
  void dumpAssociationTables()
  {

    Enumeration associations = m_patternTable.elements();

    while (associations.hasMoreElements())
    {
      TemplateSubPatternAssociation head =
        (TemplateSubPatternAssociation) associations.nextElement();

      while (null != head)
      {
        System.out.print(""("" + head.getTargetString() + "", ""
                         + head.getPattern() + "")"");

        head = head.getNext();
      }

      System.out.println(""
....."");
    }

    TemplateSubPatternAssociation head = m_wildCardPatterns;

    System.out.print(""wild card list: "");

    while (null != head)
    {
      System.out.print(""("" + head.getTargetString() + "", ""
                       + head.getPattern() + "")"");

      head = head.getNext();
    }

    System.out.println(""
....."");
  }

  
  public void compose(StylesheetRoot sroot)
  {

    if (DEBUG)
    {
      System.out.println(""Before wildcard insert..."");
      dumpAssociationTables();
    }

    if (null != m_wildCardPatterns)
    {
      Enumeration associations = m_patternTable.elements();

      while (associations.hasMoreElements())
      {
        TemplateSubPatternAssociation head =
          (TemplateSubPatternAssociation) associations.nextElement();
        TemplateSubPatternAssociation wild = m_wildCardPatterns;

        while (null != wild)
        {
          try
          {
            head = insertAssociationIntoList(
              head, (TemplateSubPatternAssociation) wild.clone(), true);
          }
          catch (CloneNotSupportedException cnse){}

          wild = wild.getNext();
        }
      }
    }

    if (DEBUG)
    {
      System.out.println(""After wildcard insert..."");
      dumpAssociationTables();
    }
  }

  
  private TemplateSubPatternAssociation
              insertAssociationIntoList(TemplateSubPatternAssociation head,
                                         TemplateSubPatternAssociation item,
                                         boolean isWildCardInsert)
  {

    
    
    

    double priority = getPriorityOrScore(item);
    double workPriority;
    int importLevel = item.getImportLevel();
    int docOrder = item.getDocOrderPos();
    TemplateSubPatternAssociation insertPoint = head;
    TemplateSubPatternAssociation next;
    boolean insertBefore;         
                                  
                                  

    
    
    
    
    
    
    
    
    

    while (true)
    {
      next = insertPoint.getNext();
      if (null == next)
        break;
      else
      {
        workPriority = getPriorityOrScore(next);
        if (importLevel > next.getImportLevel())
          break;
        else if (importLevel < next.getImportLevel())
          insertPoint = next;
        else if (priority > workPriority)               
          break;
        else if (priority < workPriority)
          insertPoint = next;
        else if (docOrder >= next.getDocOrderPos())     
          break;
        else
          insertPoint = next;
      }
    }

    if ( (null == next) || (insertPoint == head) )      
    {
      workPriority = getPriorityOrScore(insertPoint);
      if (importLevel > insertPoint.getImportLevel())
        insertBefore = true;
      else if (importLevel < insertPoint.getImportLevel())
        insertBefore = false;
      else if (priority > workPriority)
        insertBefore = true;
      else if (priority < workPriority)
        insertBefore = false;
      else if (docOrder >= insertPoint.getDocOrderPos())
        insertBefore = true;
      else
        insertBefore = false;
    }
    else
      insertBefore = false;

    
    
    if (isWildCardInsert)
    {
      if (insertBefore)
      {
        item.setNext(insertPoint);

        String key = insertPoint.getTargetString();

        item.setTargetString(key);
        putHead(key, item);
        return item;
      }
      else
      {
        item.setNext(next);
        insertPoint.setNext(item);
        return head;
      }
    }
    else
    {
      if (insertBefore)
      {
        item.setNext(insertPoint);

        if (insertPoint.isWild() || item.isWild())
          m_wildCardPatterns = item;
        else
          putHead(item.getTargetString(), item);
        return item;
      }
      else
      {
        item.setNext(next);
        insertPoint.setNext(item);
        return head;
      }
    }
  }

  
  private void insertPatternInTable(StepPattern pattern, ElemTemplate template)
  {

    String target = pattern.getTargetString();

    if (null != target)
    {
      String pstring = template.getMatch().getPatternString();
      TemplateSubPatternAssociation association =
        new TemplateSubPatternAssociation(template, pattern, pstring);

      
      boolean isWildCard = association.isWild();
      TemplateSubPatternAssociation head = isWildCard
                                           ? m_wildCardPatterns
                                           : getHead(target);

      if (null == head)
      {
        if (isWildCard)
          m_wildCardPatterns = association;
        else
          putHead(target, association);
      }
      else
      {
        insertAssociationIntoList(head, association, false);
      }
    }
  }

  
  private double getPriorityOrScore(TemplateSubPatternAssociation matchPat)
  {

    double priority = matchPat.getTemplate().getPriority();

    if (priority == XPath.MATCH_SCORE_NONE)
    {
      Expression ex = matchPat.getStepPattern();

      if (ex instanceof NodeTest)
      {
        return ((NodeTest) ex).getDefaultScore();
      }
    }

    return priority;
  }

  
  public ElemTemplate getTemplate(QName qname)
  {
    return (ElemTemplate) m_namedTemplates.get(qname);
  }

  
  public TemplateSubPatternAssociation getHead(XPathContext xctxt, 
                                               int targetNode, DTM dtm)
  {
    short targetNodeType = dtm.getNodeType(targetNode);
    TemplateSubPatternAssociation head;

    switch (targetNodeType)
    {
    case DTM.ELEMENT_NODE :
    case DTM.ATTRIBUTE_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getLocalName(targetNode));
      break;
    case DTM.TEXT_NODE :
    case DTM.CDATA_SECTION_NODE :
      head = m_textPatterns;
      break;
    case DTM.ENTITY_REFERENCE_NODE :
    case DTM.ENTITY_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getNodeName(targetNode)); 
      break;
    case DTM.PROCESSING_INSTRUCTION_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getLocalName(targetNode));
      break;
    case DTM.COMMENT_NODE :
      head = m_commentPatterns;
      break;
    case DTM.DOCUMENT_NODE :
    case DTM.DOCUMENT_FRAGMENT_NODE :
      head = m_docPatterns;
      break;
    case DTM.NOTATION_NODE :
    default :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getNodeName(targetNode)); 
    }

    return (null == head) ? m_wildCardPatterns : head;
  }
  
  
  public ElemTemplate getTemplateFast(XPathContext xctxt,
                                int targetNode,
                                int expTypeID,
                                QName mode,
                                int maxImportLevel,
                                boolean quietConflictWarnings,
                                DTM dtm)
            throws TransformerException
  {
    
    TemplateSubPatternAssociation head;

    switch (dtm.getNodeType(targetNode))
    {
    case DTM.ELEMENT_NODE :
    case DTM.ATTRIBUTE_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getLocalNameFromExpandedNameID(expTypeID));
      break;
    case DTM.TEXT_NODE :
    case DTM.CDATA_SECTION_NODE :
      head = m_textPatterns;
      break;
    case DTM.ENTITY_REFERENCE_NODE :
    case DTM.ENTITY_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getNodeName(targetNode)); 
      break;
    case DTM.PROCESSING_INSTRUCTION_NODE :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getLocalName(targetNode));
      break;
    case DTM.COMMENT_NODE :
      head = m_commentPatterns;
      break;
    case DTM.DOCUMENT_NODE :
    case DTM.DOCUMENT_FRAGMENT_NODE :
      head = m_docPatterns;
      break;
    case DTM.NOTATION_NODE :
    default :
      head = (TemplateSubPatternAssociation) m_patternTable.get(
        dtm.getNodeName(targetNode)); 
    }

    if(null == head)
    {
      head = m_wildCardPatterns;
      if(null == head)
        return null;
    }                                              

    
    
    
    xctxt.pushNamespaceContextNull();
    try
    {
      do
      {
        if ( (maxImportLevel > -1) && (head.getImportLevel() > maxImportLevel) )
        {
          continue;
        }
        ElemTemplate template = head.getTemplate();        
        xctxt.setNamespaceContext(template);
        
        if ((head.m_stepPattern.execute(xctxt, targetNode, dtm, expTypeID) != NodeTest.SCORE_NONE)
                && head.matchMode(mode))
        {
          if (quietConflictWarnings)
            checkConflicts(head, xctxt, targetNode, mode);

          return template;
        }
      }
      while (null != (head = head.getNext()));
    }
    finally
    {
      xctxt.popNamespaceContext();
    }

    return null;
  }  

  
  public ElemTemplate getTemplate(XPathContext xctxt,
                                int targetNode,
                                QName mode,
                                boolean quietConflictWarnings,
                                DTM dtm)
            throws TransformerException
  {

    TemplateSubPatternAssociation head = getHead(xctxt, targetNode, dtm);

    if (null != head)
    {
      
      
      
      xctxt.pushNamespaceContextNull();
      xctxt.pushCurrentNodeAndExpression(targetNode, targetNode);
      try
      {
        do
        {
          ElemTemplate template = head.getTemplate();        
          xctxt.setNamespaceContext(template);
          
          if ((head.m_stepPattern.execute(xctxt, targetNode) != NodeTest.SCORE_NONE)
                  && head.matchMode(mode))
          {
            if (quietConflictWarnings)
              checkConflicts(head, xctxt, targetNode, mode);

            return template;
          }
        }
        while (null != (head = head.getNext()));
      }
      finally
      {
        xctxt.popCurrentNodeAndExpression();
        xctxt.popNamespaceContext();
      }
    }

    return null;
  }  
  
  
  public ElemTemplate getTemplate(XPathContext xctxt,
                                int targetNode,
                                QName mode,
                                int maxImportLevel, int endImportLevel,
                                boolean quietConflictWarnings,
                                DTM dtm)
            throws TransformerException
  {

    TemplateSubPatternAssociation head = getHead(xctxt, targetNode, dtm);

    if (null != head)
    {
      
      
      
      xctxt.pushNamespaceContextNull();
      xctxt.pushCurrentNodeAndExpression(targetNode, targetNode);
      try
      {
        do
        {
          if ( (maxImportLevel > -1) && (head.getImportLevel() > maxImportLevel))
          {
            continue;
          }
          if (head.getImportLevel()<= maxImportLevel - endImportLevel)
            return null;
          ElemTemplate template = head.getTemplate();        
          xctxt.setNamespaceContext(template);
          
          if ((head.m_stepPattern.execute(xctxt, targetNode) != NodeTest.SCORE_NONE)
                  && head.matchMode(mode))
          {
            if (quietConflictWarnings)
              checkConflicts(head, xctxt, targetNode, mode);

            return template;
          }
        }
        while (null != (head = head.getNext()));
      }
      finally
      {
        xctxt.popCurrentNodeAndExpression();
        xctxt.popNamespaceContext();
      }
    }

    return null;
  }  

  
  public TemplateWalker getWalker()
  {
    return new TemplateWalker();
  }

  
  private void checkConflicts(TemplateSubPatternAssociation head,
                              XPathContext xctxt, int targetNode, QName mode)
  {

    
  }

  
  private void addObjectIfNotFound(Object obj, Vector v)
  {

    int n = v.size();
    boolean addIt = true;

    for (int i = 0; i < n; i++)
    {
      if (v.elementAt(i) == obj)
      {
        addIt = false;

        break;
      }
    }

    if (addIt)
    {
      v.addElement(obj);
    }
  }

  
  private Hashtable m_namedTemplates = new Hashtable(89);

  
  private Hashtable m_patternTable = new Hashtable(89);

  
  private TemplateSubPatternAssociation m_wildCardPatterns = null;

  
  private TemplateSubPatternAssociation m_textPatterns = null;

  
  private TemplateSubPatternAssociation m_docPatterns = null;

  
  private TemplateSubPatternAssociation m_commentPatterns = null;

  
  private Hashtable getNamedTemplates()
  {
    return m_namedTemplates;
  }

  
  private void setNamedTemplates(Hashtable v)
  {
    m_namedTemplates = v;
  }

  
  private TemplateSubPatternAssociation getHead(String key)
  {
    return (TemplateSubPatternAssociation) m_patternTable.get(key);
  }

  
  private void putHead(String key, TemplateSubPatternAssociation assoc)
  {

    if (key.equals(PsuedoNames.PSEUDONAME_TEXT))
      m_textPatterns = assoc;
    else if (key.equals(PsuedoNames.PSEUDONAME_ROOT))
      m_docPatterns = assoc;
    else if (key.equals(PsuedoNames.PSEUDONAME_COMMENT))
      m_commentPatterns = assoc;

    m_patternTable.put(key, assoc);
  }

  
  public class TemplateWalker
  {
    private Enumeration hashIterator;
    private boolean inPatterns;
    private TemplateSubPatternAssociation curPattern;

    private Hashtable m_compilerCache = new Hashtable();

    private TemplateWalker()
    {
      hashIterator = m_patternTable.elements();
      inPatterns = true;
      curPattern = null;
    }

    public ElemTemplate next()
    {

      ElemTemplate retValue = null;
      ElemTemplate ct;

      while (true)
      {
        if (inPatterns)
        {
          if (null != curPattern)
            curPattern = curPattern.getNext();

          if (null != curPattern)
            retValue = curPattern.getTemplate();
          else
          {
            if (hashIterator.hasMoreElements())
            {
              curPattern = (TemplateSubPatternAssociation) hashIterator.nextElement();
              retValue =  curPattern.getTemplate();
            }
            else
            {
              inPatterns = false;
              hashIterator = m_namedTemplates.elements();
            }
          }
        }

        if (!inPatterns)
        {
          if (hashIterator.hasMoreElements())
            retValue = (ElemTemplate) hashIterator.nextElement();
          else
            return null;
        }

        ct = (ElemTemplate) m_compilerCache.get(new Integer(retValue.getUid()));
        if (null == ct)
        {
          m_compilerCache.put(new Integer(retValue.getUid()), retValue);
          return retValue;
        }
      }
    }
  }

}
"
org.apache.xml.dtm.DTMConfigurationException,6,5,0,2,11,15,1,1,6,2.0,34,0.0,0,1.0,0.625,0,0,4.666666667,0,0.0,0,"package org.apache.xml.dtm;

import javax.xml.transform.SourceLocator;


public class DTMConfigurationException extends DTMException {

    
    public DTMConfigurationException() {
        super(""Configuration Error"");
    }

    
    public DTMConfigurationException(String msg) {
        super(msg);
    }

    
    public DTMConfigurationException(Throwable e) {
        super(e);
    }

    
    public DTMConfigurationException(String msg, Throwable e) {
        super(msg, e);
    }

    
    public DTMConfigurationException(String message,
                                             SourceLocator locator) {
        super(message, locator);
    }

    
    public DTMConfigurationException(String message,
                                             SourceLocator locator,
                                             Throwable e) {
        super(message, locator, e);
    }
}"
org.apache.xpath.functions.FuncLast,5,3,0,8,12,8,1,7,5,0.5,59,1.0,0,0.904761905,0.4,1,6,10.6,2,1.0,0,"
package org.apache.xpath.functions;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.axes.ContextNodeList;
import org.apache.xpath.axes.SubContextList;
import org.apache.xpath.compiler.Compiler;



public class FuncLast extends Function
{
  
  private boolean m_isTopLevel;
  
  
  public void postCompileStep(Compiler compiler)
  {
    m_isTopLevel = compiler.getLocationPathDepth() == -1;
  }

  
  public int getCountOfContextNodeList(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    
    
    SubContextList iter = m_isTopLevel ? null : xctxt.getSubContextList();

    
    if (null != iter)
      return iter.getLastPos(xctxt);

    DTMIterator cnl = xctxt.getContextNodeList();
    int count;
    if(null != cnl)
    {
      count = cnl.getLength();
      
    }
    else
      count = 0;   
    return count;
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    XNumber xnum = new XNumber((double) getCountOfContextNodeList(xctxt));
    
    return xnum;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }

}
"
org.apache.xpath.axes.UnionChildIterator,3,7,0,11,14,0,1,10,3,0.0,119,1.0,0,0.985185185,0.555555556,3,3,38.33333333,5,2.3333,0,"
package org.apache.xpath.axes;

import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.patterns.NodeTest;


public class UnionChildIterator extends ChildTestIterator
{
  
  private PredicatedNodeTest[] m_nodeTests = null;

  
  public UnionChildIterator()
  {
    super(null);
  }

  
  public void addNodeTest(PredicatedNodeTest test)
  {

    
    
    if (null == m_nodeTests)
    {
      m_nodeTests = new PredicatedNodeTest[1];
      m_nodeTests[0] = test;
    }
    else
    {
      PredicatedNodeTest[] tests = m_nodeTests;
      int len = m_nodeTests.length;

      m_nodeTests = new PredicatedNodeTest[len + 1];

      System.arraycopy(tests, 0, m_nodeTests, 0, len);

      m_nodeTests[len] = test;
    }
    test.exprSetParent(this);
  }

  
  public short acceptNode(int n)
  {
    XPathContext xctxt = getXPathContext();
    try
    {
      xctxt.pushCurrentNode(n);
      for (int i = 0; i < m_nodeTests.length; i++)
      {
        PredicatedNodeTest pnt = m_nodeTests[i];
        XObject score = pnt.execute(xctxt, n);
        if (score != NodeTest.SCORE_NONE)
        {
          
          if (pnt.getPredicateCount() > 0)
          {
            if (pnt.executePredicates(n, xctxt))
              return DTMIterator.FILTER_ACCEPT;
          }
          else
            return DTMIterator.FILTER_ACCEPT;

        }
      }
    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new RuntimeException(se.getMessage());
    }
    finally
    {
      xctxt.popCurrentNode();
    }
    return DTMIterator.FILTER_SKIP;
  }

}"
org.apache.xalan.transformer.QueuedEvents,7,1,1,5,10,13,3,2,2,0.861111111,99,0.75,2,0.0,0.571428571,0,0,11.42857143,1,0.8571,0,"
package org.apache.xalan.transformer;

import java.util.Stack;
import java.util.Vector;

import org.apache.xml.utils.ObjectPool;

import org.xml.sax.Attributes;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.MutableAttrListImpl;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemTemplate;



public abstract class QueuedEvents
{

  
  protected int m_eventCount = 0;

  
  

  
  
  
  public boolean m_docPending = false;
  protected boolean m_docEnded = false;
  
  
  public boolean m_elemIsPending = false;

  
  public boolean m_elemIsEnded = false;
  
  
  protected MutableAttrListImpl m_attributes = new MutableAttrListImpl();

  
  protected boolean m_nsDeclsHaveBeenAdded = false;

  
  protected String m_name;

  
  protected String m_url;

  
  protected String m_localName;
  
  
  
  protected Vector m_namespaces = null;











  
  protected void reInitEvents()
  {
  }

  
  public void reset()
  {
    pushDocumentEvent();
    reInitEvents();
  }

  
  void pushDocumentEvent()
  {

    
    
    m_docPending = true;

    m_eventCount++;
  }

  
  void popEvent()
  {
    m_elemIsPending = false;
    m_attributes.clear();

    m_nsDeclsHaveBeenAdded = false;
    m_name = null;
    m_url = null;
    m_localName = null;
    m_namespaces = null;

    m_eventCount--;
  }

  
  private org.apache.xalan.serialize.Serializer m_serializer;

  
  void setSerializer(org.apache.xalan.serialize.Serializer s)
  {
    m_serializer = s;
  }

  
  org.apache.xalan.serialize.Serializer getSerializer()
  {
    return m_serializer;
  }
}
"
org.apache.xpath.functions.FuncNormalizeSpace,3,5,0,6,11,3,0,6,3,2.0,45,0.0,0,0.964912281,0.666666667,2,7,14.0,1,0.6667,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XMLStringFactoryImpl;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xml.utils.FastStringBuffer;

import org.apache.xml.dtm.DTM;
import org.xml.sax.ContentHandler;


public class FuncNormalizeSpace extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    XMLString s1 = getArg0AsString(xctxt);

    return (XString)s1.fixWhiteSpace(true, true, false);
  }
  
  
  public void executeCharsToContentHandler(XPathContext xctxt, 
                                              ContentHandler handler)
    throws javax.xml.transform.TransformerException,
           org.xml.sax.SAXException
  {
    if(Arg0IsNodesetExpr())
    {
      int node = getArg0AsNode(xctxt);
      if(DTM.NULL != node)
      {
        DTM dtm = xctxt.getDTM(node);
        dtm.dispatchCharactersEvents(node, handler, true);
      }
    }
    else
    {
      XObject obj = execute(xctxt);
      obj.dispatchCharactersEvents(handler);
    }
  }

}
"
org.apache.xalan.xsltc.runtime.output.StreamHTMLOutput,25,3,0,7,57,232,2,5,18,0.901041667,807,1.0,1,0.676923077,0.217592593,2,6,30.96,18,2.24,1,"

package org.apache.xalan.xsltc.runtime.output;

import java.util.Vector;

import java.io.Writer;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.runtime.*;
import org.apache.xalan.xsltc.runtime.Hashtable;

public class StreamHTMLOutput extends StreamOutput {

    private static final String HREF_STR = ""href"";
    private static final String CITE_STR = ""cite"";
    private static final String SRC_STR  = ""src"";

    private static final Hashtable _emptyElements = new Hashtable();
    private static final String[] tags = { ""area"", ""base"", ""basefont"", ""br"",
					   ""col"", ""frame"", ""hr"", ""img"", ""input"",
					   ""isindex"", ""link"", ""meta"", ""param"" };
    static {
        for (int i = 0; i < tags.length; i++) {
            _emptyElements.put(tags[i], """");
	}
    }

    private boolean _headTagOpen = false;
    private boolean _inStyleScript = false;
    private String  _mediaType     = ""text/html"";

    public StreamHTMLOutput(StreamOutput output) {
	super(output);
	setIndent(true);  

    }

    public StreamHTMLOutput(Writer writer, String encoding) {
	super(writer, encoding);
	setIndent(true);  

    }

    public StreamHTMLOutput(OutputStream out, String encoding) 
	throws IOException
    {
	super(out, encoding);
	setIndent(true);  

    }

    public void startDocument() throws TransletException { 
	
    }

    public void endDocument() throws TransletException { 
	
	outputBuffer();
    }

    public void startElement(String elementName) throws TransletException { 
	if (_startTagOpen) {
	    closeStartTag();
	}

	
	if (_firstElement) {
	    if (_doctypeSystem != null || _doctypePublic != null) {
		appendDTD(elementName);
	    }
	    _firstElement = false;
	}

	if (_indent) {
	    if (!_emptyElements.containsKey(elementName.toLowerCase())) {
		indent(_lineFeedNextStartTag);
		_lineFeedNextStartTag = true;
		_indentNextEndTag = false;
	    }
	    _indentLevel++;
	}

	_buffer.append('<').append(elementName);
	_startTagOpen = true;
	_indentNextEndTag = false;

	if (elementName.equalsIgnoreCase(""head"")) {
	    _headTagOpen = true;
	}
	else if (elementName.equalsIgnoreCase(""style"") || 
		 elementName.equalsIgnoreCase(""script"")) 
	{
	    _inStyleScript = true;
	}
    }

    public void endElement(String elementName) 
	throws TransletException 
    { 
	if (_inStyleScript && 
	    (elementName.equalsIgnoreCase(""style"") || 
	     elementName.equalsIgnoreCase(""script""))) 
	{
	    _inStyleScript = false;
	}

	if (_startTagOpen) {
	    appendAttributes();
	    if (_emptyElements.containsKey(elementName.toLowerCase())) {
		_buffer.append('>');
	    }
	    else {
		closeStartTag();
		_buffer.append(""</"").append(elementName).append('>');
	    }
	    _startTagOpen = false;

	    if (_indent) {
		_indentLevel--;
		_indentNextEndTag = true;
	    }
	}
	else {
	    if (_indent) {
		_indentLevel--;

		if (_indentNextEndTag) {
		    indent(_indentNextEndTag);
		    _indentNextEndTag = true;
		    _lineFeedNextStartTag = true;
		}
	    }
	    _buffer.append(""</"").append(elementName).append('>');
	    _indentNextEndTag = true;
	}
    }

    public void characters(String characters)
	throws TransletException 
    { 
	if (_startTagOpen) {
	    closeStartTag();
	}

	if (_escaping && !_inStyleScript) {
	    escapeCharacters(characters.toCharArray(), 0, characters.length());
	}
	else {
	    _buffer.append(characters);
	}
    }

    public void characters(char[] characters, int offset, int length)
	throws TransletException 
    { 
	if (_startTagOpen) {
	    closeStartTag();
	}

	if (_escaping && !_inStyleScript) {
	    escapeCharacters(characters, offset, length);
	}
	else {
	    _buffer.append(characters, offset, length);
	}
    }

    public void attribute(String name, String value)
	throws TransletException 
    { 

	if (_startTagOpen) {
	    int k;
	    Attribute attr;

	    if (name.equalsIgnoreCase(HREF_STR) || 
		name.equalsIgnoreCase(SRC_STR)  || 
		name.equals(CITE_STR)) 
	    {
		attr = new Attribute(name, escapeURL(value));
	    }
	    else {
		attr = new Attribute(name, escapeNonURL(value));
	    }

	    if ((k = _attributes.indexOf(attr)) >= 0) {
		_attributes.setElementAt(attr, k);
	    }
	    else {
		_attributes.add(attr);
	    }
	}
    }

    public void comment(String comment) throws TransletException { 
	if (_startTagOpen) {
	    closeStartTag();
	}
	appendComment(comment);
    }

    public void processingInstruction(String target, String data)
	throws TransletException 
    { 
	if (_startTagOpen) {
	    closeStartTag();
	}

	
	if (_firstElement) {
	    if (_doctypeSystem != null || _doctypePublic != null) {
		appendDTD(""html"");
	    }
	    _firstElement = false;
	}

	
	_buffer.append(""<?"").append(target).append(' ')
	    .append(data).append('>');
    }

    public boolean setEscaping(boolean escape) throws TransletException 
    { 
	final boolean temp = _escaping;
	_escaping = escape;
	return temp; 
    }

    public void close() { 
	try {
	    _writer.close();
	}
	catch (Exception e) {
	    
	}
    }

    public void namespace(String prefix, String uri) throws TransletException 
    { 
	
    }

    public void setCdataElements(Hashtable elements) { 
	
    }

    public void setType(int type) { 
	
    }

    
    public void setMediaType(String mediaType) {
	_mediaType = mediaType;
    }

    
    private String escapeNonURL(String base) {
	final int length = base.length();
	final StringBuffer result = new StringBuffer();

        for (int i = 0; i < length; i++){
	    final char ch = base.charAt(i);

	    if ((ch >= '' && ch < '') ||
		(_is8859Encoded && ch > ''))
	    {
	        result.append(CHAR_ESC_START)
		      .append(Integer.toString((int) ch))
		      .append(';');
	    }
	    else {
	        result.append(ch); 
	    } 
  	}
	return result.toString();
    }

    
    private String escapeURL(String base) {
	final char[] chs = base.toCharArray();
	final StringBuffer result = new StringBuffer();

	final int length = chs.length;
        for (int i = 0; i < length; i++) {
	    final char ch = chs[i];

	    if (ch <= 0x20) {
		result.append('%').append(makeHHString(ch));
	    } 
	    else if (ch > '') {
		result.append('%')
		      .append(makeHHString((ch >> 6) | 0xC0))
		      .append('%')
		      .append(makeHHString((ch & 0x3F) | 0x80));
	    }
	    else {
		
	        switch (ch) {
		    case '' :
		    case '{' :
		    case '}' :
		    case '|' :
		    case '\'     :
		    case '	'     :
		    case '^' :
		    case '~' :
		    case '[' :
		    case ']' :
		    case '`' :
		    case ' ' :
		        result.append('%')
		              .append(Integer.toHexString((int) ch));
		        break;
		    case '""':
			result.append(""%22"");
			break;
		    default:	
		        result.append(ch); 
			break;
	        }
	    } 
  	}
	return result.toString();
    }

    private String makeHHString(int i) {
	final String s = Integer.toHexString(i).toUpperCase();
	return (s.length() == 1) ? ""0"" + s : s;
    }

    
    private void appendHeader() {
	_buffer.append(""<meta http-equiv=""Content-Type"" content="""")
	       .append(_mediaType).append(""; charset="")
	       .append(_encoding).append("""">"");
    }

    protected void closeStartTag() throws TransletException {
	super.closeStartTag();

	
	if (_headTagOpen) {
	    appendHeader();
	    _headTagOpen = false;
	}
    } 

    
    protected void escapeCharacters(char[] ch, int off, int len) {
	int limit = off + len;
	int offset = off;

	if (limit > ch.length) {
	    limit = ch.length;
	}

	
	for (int i = off; i < limit; i++) {
	    final char current = ch[i];

	    switch (current) {
	    case '&':
		_buffer.append(ch, offset, i - offset).append(AMP);
		offset = i + 1;
		break;
	    case '<':
		_buffer.append(ch, offset, i - offset).append(LT);
		offset = i + 1;
		break;
	    case '>':
		_buffer.append(ch, offset, i - offset).append(GT);
		offset = i + 1;
		break;
	    case '':
		_buffer.append(ch, offset, i - offset).append(NBSP);
		offset = i + 1;
		break;
	    default:
		if ((current >= '' && current < '') ||
		    (_is8859Encoded && current > ''))
		{
		    _buffer.append(ch, offset, i - offset)
			   .append(CHAR_ESC_START)
			   .append(Integer.toString((int)ch[i]))
			   .append(';');
		    offset = i + 1;
		}
	    }
	}
	
	if (offset < limit) {
	    _buffer.append(ch, offset, limit - offset);
	}
    }
}
"
org.apache.xalan.xsltc.dom.NthIterator,11,2,0,2,20,0,0,2,11,0.566666667,120,1.0,1,0.5,0.340909091,1,5,9.636363636,5,1.3636,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public final class NthIterator extends NodeIteratorBase {
    
    private NodeIterator _source;
    private final int _position;
    private boolean _ready;

    public NthIterator(NodeIterator source, int n) {
	_source = source;
	_position = n;
    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }
    
    public int next() {
	if (_ready && _position > 0) {
	    _ready = false;
	    
	    final int pos = _position;
	    for (int n = pos - 1; n-- > 0;) {
		if (_source.next() == NodeIterator.END) {
		    return NodeIterator.END;
		}
	    }
	    return _source.next();
	}
	return NodeIterator.END;
    }
	
    public NodeIterator setStartNode(final int node) {
	if (_isRestartable) {
	    _source.setStartNode(node);
	    _ready = true;
	}
	return this;
    }
	
    public NodeIterator reset() {
	_source.reset();
	_ready = true;
	return this;
    }
    
    public int getLast() {
	return 1;
    }
    
    public int getPosition() {
	return 1;
    }
    
    public boolean isReverse() {
	return _source.isReverse();
    }
    
    public void setMark() {
	_source.setMark();
    }
    
    public void gotoMark() {
	_source.gotoMark();
    }

    public NodeIterator cloneIterator() {
	NodeIterator clone = _source.cloneIterator();
	NthIterator other = new NthIterator(clone, _position);
	other.setRestartable(false);
	return other.reset();
    }
}
"
org.apache.xalan.templates.StylesheetComposed,11,4,1,17,43,39,11,10,9,0.8,333,1.0,0,0.964285714,0.309090909,1,2,28.90909091,4,1.5455,0,"
package org.apache.xalan.templates;

import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;

import javax.xml.transform.TransformerConfigurationException;
import org.apache.xpath.XPath;
import org.apache.xml.utils.QName;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPathContext;

import org.w3c.dom.Node;
import org.w3c.dom.Element;

import javax.xml.transform.TransformerException;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;


public class StylesheetComposed extends Stylesheet
{

  
  public StylesheetComposed(Stylesheet parent)
  {
    super(parent);
  }

  
  public boolean isAggregatedType()
  {
    return true;
  }

  
  public void recompose(Vector recomposableElements) throws TransformerException
  {

    
    

    

    int n = getIncludeCountComposed();

    for (int i = -1; i < n; i++)
    {
      Stylesheet included = getIncludeComposed(i);

      

      int s = included.getOutputCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getOutput(j));
      }

      

      s = included.getAttributeSetCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getAttributeSet(j));
      }

      

      s = included.getDecimalFormatCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getDecimalFormat(j));
      }

      

      s = included.getKeyCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getKey(j));
      }

      

      s = included.getNamespaceAliasCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getNamespaceAlias(j));
      }

      

      s = included.getTemplateCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getTemplate(j));
      }

      

      s = included.getVariableOrParamCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getVariableOrParam(j));
      }

      

      s = included.getStripSpaceCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getStripSpace(j));
      }

      s = included.getPreserveSpaceCount();
      for (int j = 0; j < s; j++)
      {
        recomposableElements.addElement(included.getPreserveSpace(j));
      }
    }
  }

  
  private int m_importNumber = -1;

  
  private int m_importCountComposed;
  
  
  private int m_endImportCountComposed;

  
  void recomposeImports()
  {

    m_importNumber = getStylesheetRoot().getImportNumber(this);

    StylesheetRoot root = getStylesheetRoot();
    int globalImportCount = root.getGlobalImportCount();

    m_importCountComposed = (globalImportCount - m_importNumber) - 1;
    
    
    int count = getImportCount();
    if ( count > 0)
    {
      m_endImportCountComposed += count;
      while (count > 0)
        m_endImportCountComposed += this.getImport(--count).getEndImportCountComposed();
    }
    
    
    
    count = getIncludeCountComposed();
    while (count>0)
    {
      int imports = getIncludeComposed(--count).getImportCount();
      m_endImportCountComposed += imports;
      while (imports > 0)
        m_endImportCountComposed +=getIncludeComposed(count).getImport(--imports).getEndImportCountComposed();
     
    }                                                            
  }

  
  public StylesheetComposed getImportComposed(int i)
          throws ArrayIndexOutOfBoundsException
  {

    StylesheetRoot root = getStylesheetRoot();

    
    
    
    
    return root.getGlobalImport(1 + m_importNumber + i);
  }

  
  public int getImportCountComposed()
  {
    return m_importCountComposed;
  }
  
  
  public int getEndImportCountComposed()
  {
    return m_endImportCountComposed;
  }
  

  
  private transient Vector m_includesComposed;

  
  void recomposeIncludes(Stylesheet including)
  {

    int n = including.getIncludeCount();

    if (n > 0)
    {
      if (null == m_includesComposed)
        m_includesComposed = new Vector();

      for (int i = 0; i < n; i++)
      {
        Stylesheet included = including.getInclude(i);
        m_includesComposed.addElement(included);
        recomposeIncludes(included);
      }
    }
  }

  
  public Stylesheet getIncludeComposed(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (-1 == i)
      return this;

    if (null == m_includesComposed)
      throw new ArrayIndexOutOfBoundsException();

    return (Stylesheet) m_includesComposed.elementAt(i);
  }

  
  public int getIncludeCountComposed()
  {
    return (null != m_includesComposed) ? m_includesComposed.size() : 0;
  }

  
  public void recomposeTemplates(boolean flushFirst) throws TransformerException
  {

  }
}
"
org.apache.xalan.serialize.Encodings,11,1,0,6,43,23,4,2,8,0.925,419,0.375,1,0.0,0.3,0,0,36.36363636,10,3.1818,1,"
package org.apache.xalan.serialize;

import java.io.InputStream;
import java.io.Writer;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import java.net.URL;

import java.util.Enumeration;
import java.util.Properties;


public class Encodings extends Object
{

  
  static final int m_defaultLastPrintable = 0x7F;

  
  static final String ENCODINGS_FILE = ""org/apache/xalan/serialize/Encodings.properties"";
  
  
  private static final Class[] NO_CLASSES = new Class[0];

  
  private static final Object[] NO_OBJS = new Object[0];



  
  public static Writer getWriter(OutputStream output, String encoding)
          throws UnsupportedEncodingException
  {

    for (int i = 0; i < _encodings.length; ++i)
    {
      if (_encodings[i].name.equalsIgnoreCase(encoding))
      {
        try
        {
          return new OutputStreamWriter(output, _encodings[i].javaName);
        }
        catch( java.lang.IllegalArgumentException iae) 
        {
          
        }
        catch (UnsupportedEncodingException usee)
        {

          
        }
      }
    }

    try
    {
      return new OutputStreamWriter(output, encoding);
    }
    catch( java.lang.IllegalArgumentException iae) 
    {
      throw new UnsupportedEncodingException(encoding);
    }
  }

  
  public static Object getCharToByteConverter(String encoding)
  {

    Class charToByteConverterClass = null;
    java.lang.reflect.Method getConverterMethod = null;

    try
    {
      charToByteConverterClass = Class.forName(""sun.io.CharToByteConverter"");
      Class argTypes[] = new Class[1];
      argTypes[0] = String.class;
      getConverterMethod
        = charToByteConverterClass.getMethod(""getConverter"", argTypes);
    }
    catch(Exception e)
    {
      System.err.println(""Warning: Could not get charToByteConverterClass!"");
      return null;
    }
    Object args[] = new Object[1];
    for (int i = 0; i < _encodings.length; ++i)
    {
      if (_encodings[i].name.equalsIgnoreCase(encoding))
      {
        try
        {
          args[0] = _encodings[i].javaName;
          Object converter = getConverterMethod.invoke(null, args);
          if(null != converter)
            return converter;
        }
        catch( Exception iae)
        {
          
        }
      }
    }

    return null;
  }

  
  public static int getLastPrintable(String encoding)
  {

    for (int i = 0; i < _encodings.length; ++i)
    {
      if (_encodings[i].name.equalsIgnoreCase(encoding)
              || _encodings[i].javaName.equalsIgnoreCase(encoding))
        return _encodings[i].lastPrintable;
    }

    return m_defaultLastPrintable;
  }

  
  public static int getLastPrintable()
  {
    return m_defaultLastPrintable;
  }

  
  public static final String DEFAULT_MIME_ENCODING = ""UTF-8"";

  
  public static String getMimeEncoding(String encoding)
  {

    if (null == encoding)
    {
      try
      {

        
        
        
        encoding = System.getProperty(""file.encoding"", ""UTF8"");

        if (null != encoding)
        {

          
          String jencoding =
            (encoding.equalsIgnoreCase(""Cp1252"") || encoding.equalsIgnoreCase(
            ""ISO8859_1"") || encoding.equalsIgnoreCase(""8859_1"")
            || encoding.equalsIgnoreCase(""UTF8"")) ? DEFAULT_MIME_ENCODING
              : convertJava2MimeEncoding(
              encoding);

          encoding = (null != jencoding) ? jencoding : DEFAULT_MIME_ENCODING;
        }
        else
        {
          encoding = DEFAULT_MIME_ENCODING;
        }
      }
      catch (SecurityException se)
      {
        encoding = DEFAULT_MIME_ENCODING;
      }
    }
    else
    {
      encoding = convertJava2MimeEncoding(encoding);
    }

    return encoding;
  }

  
  public static String convertJava2MimeEncoding(String encoding)
  {

    for (int i = 0; i < _encodings.length; ++i)
    {
      if (_encodings[i].javaName.equalsIgnoreCase(encoding))
      {
        return _encodings[i].name;
      }
    }

    return encoding;
  }

  
  public static String convertMime2JavaEncoding(String encoding)
  {

    for (int i = 0; i < _encodings.length; ++i)
    {
      if (_encodings[i].name.equalsIgnoreCase(encoding))
      {
        return _encodings[i].javaName;
      }
    }

    return encoding;
  }


  
  private static EncodingInfo[] loadEncodingInfo()
  {
    URL url = null;
    try {
      String urlString = null;
      try {
        urlString = System.getProperty(""org.apache.xalan.serialize.encodings"", """");
      }
      catch (SecurityException e) {}
      
      if (urlString != null && urlString.length() > 0)
        url = new URL (urlString);
      if (url == null) {
        ClassLoader cl = null;          
        try{
          java.lang.reflect.Method getCCL = Thread.class.getMethod(""getContextClassLoader"", NO_CLASSES);
          if (getCCL != null) {
            cl = (ClassLoader) getCCL.invoke(Thread.currentThread(), NO_OBJS);
          }
        }
        catch (Exception e) {}
        if (cl != null) {
          url = cl.getResource(ENCODINGS_FILE);
        }
      }
      if (url == null)
        url = ClassLoader.getSystemResource(ENCODINGS_FILE);

      Properties props = new Properties ();
      if (url != null) {
        InputStream is = url.openStream();
        props.load(is);
        is.close();
      }
      else {
      
      
      
      
      
      
      }

      int totalEntries = props.size();
      EncodingInfo[] ret = new EncodingInfo[totalEntries];
      Enumeration keys = props.keys();
      for (int i = 0; i < totalEntries; ++i) {
        String mimeName = (String) keys.nextElement();
        String val = props.getProperty(mimeName);
        int pos = val.indexOf(' ');
        String javaName;
        int lastPrintable;
        if (pos < 0)
        {
          
          
          
          javaName = val;
          lastPrintable = 0x00FF;
        }
        else
        {
          javaName = val.substring(0, pos);
          lastPrintable =
                         Integer.decode(val.substring(pos).trim()).intValue();
        }
        ret [i] = new EncodingInfo (mimeName, javaName, lastPrintable);
      }
      return ret;
    } catch (java.net.MalformedURLException mue) {
      throw new org.apache.xml.utils.WrappedRuntimeException(mue);
    }
    catch (java.io.IOException ioe) {
      throw new org.apache.xml.utils.WrappedRuntimeException(ioe);
    }
  }

  private static final EncodingInfo[] _encodings = loadEncodingInfo();
}
"
org.apache.xpath.operations.And,3,3,0,6,7,3,1,5,3,2.0,42,0.0,0,0.953488372,0.833333333,1,6,13.0,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.Expression;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;

import org.w3c.dom.Node;


public class And extends Operation
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XObject expr1 = m_left.execute(xctxt);

    if (expr1.bool())
    {
      XObject expr2 = m_right.execute(xctxt);

      return expr2.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;
    }
    else
      return XBoolean.S_FALSE;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return (m_left.bool(xctxt) && m_right.bool(xctxt));
  }

}
"
org.apache.xalan.templates.ElemApplyImport,5,3,0,6,17,10,0,6,5,2.0,69,0.0,0,0.98,0.466666667,2,5,12.8,1,0.8,0,"
package org.apache.xalan.templates;



import org.apache.xml.dtm.DTM;

import javax.xml.transform.TransformerException;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;


public class ElemApplyImport extends ElemTemplateElement
{

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_APPLY_IMPORTS;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_APPLY_IMPORTS_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (transformer.currentTemplateRuleIsNull())
    {
      transformer.getMsgMgr().error(this,
        XSLTErrorResources.ER_NO_APPLY_IMPORT_IN_FOR_EACH);  
    }

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    int sourceNode = transformer.getXPathContext().getCurrentNode();
    if (DTM.NULL != sourceNode)
    {

      
      
      transformer.applyTemplateToNode(this, null, sourceNode);
    }
    else  
    {
      transformer.getMsgMgr().error(this,
        XSLTErrorResources.ER_NULL_SOURCENODE_APPLYIMPORTS);  
    }
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    error(XSLTErrorResources.ER_CANNOT_ADD,
          new Object[]{ newChild.getNodeName(),
                        this.getNodeName() });  

    
    return null;
  }
}
"
org.apache.xpath.XPathContext,81,2,1,171,136,2426,155,22,78,0.936206897,1294,0.793103448,11,0.195876289,0.069318182,0,0,14.61728395,5,1.2716,3,"
package org.apache.xpath;


import java.io.File;
import java.io.IOException;

import java.util.Stack;
import java.util.Vector;

import java.lang.reflect.Method;


import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.NSInfo;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.NodeVector;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xpath.axes.ContextNodeList;
import org.apache.xpath.axes.SubContextList;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XString;

import org.apache.xalan.extensions.ExpressionContext;


import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;



import javax.xml.transform.URIResolver;
import javax.xml.transform.TransformerException;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.dom.DOMSource;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.Source;
import javax.xml.transform.ErrorListener;

import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.dtm.Axis;


import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xml.utils.IntStack;

import org.apache.xpath.axes.DescendantIterator;


import org.apache.xml.dtm.ref.sax2dtm.SAX2RTFDTM;


public class XPathContext extends DTMManager 
{
	IntStack m_last_pushed_rtfdtm=new IntStack();	
  
  private Vector m_rtfdtm_stack=null;
  
  private int m_which_rtfdtm=-1;
  
 
  private SAX2RTFDTM m_global_rtfdtm=null;
  
	
  
  protected DTMManager m_dtmManager = DTMManager.newInstance(
                   org.apache.xpath.objects.XMLStringFactoryImpl.getFactory());
  
  
   public DTMManager getDTMManager()
   {
     return m_dtmManager;
   }
  
  
  public DTM getDTM(javax.xml.transform.Source source, boolean unique, 
                    DTMWSFilter wsfilter,
                    boolean incremental,
                    boolean doIndexing)
  {
    return m_dtmManager.getDTM(source, unique, wsfilter, 
                               incremental, doIndexing);
  }
                             
  
  public DTM getDTM(int nodeHandle)
  {
    return m_dtmManager.getDTM(nodeHandle);
  }

  
  public int getDTMHandleFromNode(org.w3c.dom.Node node)
  {
    return m_dtmManager.getDTMHandleFromNode(node);
  }


  
  public int getDTMIdentity(DTM dtm)
  {
    return m_dtmManager.getDTMIdentity(dtm);
  }

  
  public DTM createDocumentFragment()
  {
    return m_dtmManager.createDocumentFragment();
  }

  
  public boolean release(DTM dtm, boolean shouldHardDelete)
  {
    
    
    
    
    
    if(m_rtfdtm_stack!=null && m_rtfdtm_stack.contains(dtm))
    {
      return false;
    }
  	
    return m_dtmManager.release(dtm, shouldHardDelete);
  }

  
  public DTMIterator createDTMIterator(Object xpathCompiler, int pos)
  {
    return m_dtmManager.createDTMIterator(xpathCompiler, pos);
  }

  
  public DTMIterator createDTMIterator(String xpathString,
          PrefixResolver presolver)
  {
    return m_dtmManager.createDTMIterator(xpathString, presolver);
  }

  
  public DTMIterator createDTMIterator(int whatToShow,
          DTMFilter filter, boolean entityReferenceExpansion)
  {
    return m_dtmManager.createDTMIterator(whatToShow, filter, entityReferenceExpansion);
  }
  
  
  public DTMIterator createDTMIterator(int node)
  {
    
    DTMIterator iter = new org.apache.xpath.axes.OneStepIteratorForward(Axis.SELF);
    iter.setRoot(node, this);
    return iter;
    
  }

  
  public XPathContext()
  {
    m_prefixResolvers[m_prefixResolversTop++] = null;
    m_currentNodes[m_currentNodesFirstFree++] = DTM.NULL;
    m_currentNodes[m_currentExpressionNodesFirstFree++] = DTM.NULL;
    m_saxLocations[m_saxLocationsTop++] = null;
  }

  
  public XPathContext(Object owner)
  {
    m_owner = owner;
    try {
      m_ownerGetErrorListener = m_owner.getClass().getMethod(""getErrorListener"", new Class[] {});
    }
    catch (NoSuchMethodException nsme) {}
    m_prefixResolvers[m_prefixResolversTop++] = null;
    m_currentNodes[m_currentNodesFirstFree++] = DTM.NULL;
    m_currentNodes[m_currentExpressionNodesFirstFree++] = DTM.NULL;
    m_saxLocations[m_saxLocationsTop++] = null;
  }

  
  public void reset()
  {
  	
  	if(m_rtfdtm_stack!=null)
  		 for (java.util.Enumeration e = m_rtfdtm_stack.elements() ; e.hasMoreElements() ;) 
  		 	m_dtmManager.release((DTM)e.nextElement(), true);

    m_rtfdtm_stack=null; 
    m_which_rtfdtm=-1;
    
    if(m_global_rtfdtm!=null)
  		 	m_dtmManager.release(m_global_rtfdtm,true);
    m_global_rtfdtm=null;
  	
    m_dtmManager = DTMManager.newInstance(
                   org.apache.xpath.objects.XMLStringFactoryImpl.getFactory());
                   
    m_saxLocations = new SourceLocator[RECURSIONLIMIT];
	m_saxLocationsTop = 0;
    
	m_axesIteratorStack = new Stack();
	m_contextNodeLists = new Stack();
	m_currentExpressionNodes = new int[RECURSIONLIMIT];
	m_currentExpressionNodesFirstFree = 0;
	m_currentNodes = new int[RECURSIONLIMIT];
	m_currentNodesFirstFree = 0;
	m_iteratorRoots = new NodeVector();
	m_predicatePos = new IntStack();
	m_predicateRoots = new NodeVector();
	m_prefixResolvers = new PrefixResolver[RECURSIONLIMIT];
	int m_prefixResolversTop = 0;
	
	m_prefixResolvers[m_prefixResolversTop++] = null;
    m_currentNodes[m_currentNodesFirstFree++] = DTM.NULL;
    m_currentNodes[m_currentExpressionNodesFirstFree++] = DTM.NULL;
    m_saxLocations[m_saxLocationsTop++] = null;
  }

  
  SourceLocator[] m_saxLocations = new SourceLocator[RECURSIONLIMIT];
  int m_saxLocationsTop = 0;

  
  public void setSAXLocator(SourceLocator location)
  {
    m_saxLocations[m_saxLocationsTop-1] = location;
  }
  
  
  public void pushSAXLocator(SourceLocator location)
  {
    m_saxLocations[m_saxLocationsTop++] = location;
  }
  
  
  public void pushSAXLocatorNull()
  {
    m_saxLocationsTop++;
  }


  
  public void popSAXLocator()
  {
    m_saxLocationsTop--;
  }

  
  public SourceLocator getSAXLocator()
  {
    return m_saxLocations[m_saxLocationsTop-1];
  }

  
  private Object m_owner;

  
  private Method m_ownerGetErrorListener;

  
  public Object getOwnerObject()
  {
    return m_owner;
  }

  

  
  private VariableStack m_variableStacks = new VariableStack();

  
  public final VariableStack getVarStack()
  {
    return m_variableStacks;
  }

  
  public final void setVarStack(VariableStack varStack)
  {
    m_variableStacks = varStack;
  }

  

  
  private SourceTreeManager m_sourceTreeManager = new SourceTreeManager();

  
  public final SourceTreeManager getSourceTreeManager()
  {
    return m_sourceTreeManager;
  }

  
  public void setSourceTreeManager(SourceTreeManager mgr)
  {
    m_sourceTreeManager = mgr;
  }
  
  

  
  private ErrorListener m_errorListener;

  
  private ErrorListener m_defaultErrorListener;

  
  public final ErrorListener getErrorListener()
  {

    if (null != m_errorListener)
        return m_errorListener;

    ErrorListener retval = null;

    try {
      if (null != m_ownerGetErrorListener)
        retval = (ErrorListener) m_ownerGetErrorListener.invoke(m_owner, new Object[] {});
    }
    catch (Exception e) {}

    if (null == retval)
    {
      if (null == m_defaultErrorListener) 
        m_defaultErrorListener = new org.apache.xml.utils.DefaultErrorHandler();
      retval = m_defaultErrorListener;
    }

    return retval;
  }

  
  public void setErrorListener(ErrorListener listener) throws IllegalArgumentException
  {
    if (listener == null) 
      throw new IllegalArgumentException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, null)); 
    m_errorListener = listener;
  }


  

  
  private URIResolver m_uriResolver;

  
  public final URIResolver getURIResolver()
  {
    return m_uriResolver;
  }

  
  public void setURIResolver(URIResolver resolver)
  {
    m_uriResolver = resolver;
  }

  

  
  public XMLReader m_primaryReader;

  
  public final XMLReader getPrimaryReader()
  {
    return m_primaryReader;
  }

  
  public void setPrimaryReader(XMLReader reader)
  {
    m_primaryReader = reader;
  }

  


  
  private static XSLMessages m_XSLMessages = new XSLMessages();

  
  private void assertion(boolean b, String msg) throws javax.xml.transform.TransformerException
  {

    ErrorListener errorHandler = getErrorListener();

    if (errorHandler != null)
    {
      errorHandler.fatalError(
        new TransformerException(
          m_XSLMessages.createMessage(
            XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
            new Object[]{ msg }), (SAXSourceLocator)this.getSAXLocator()));
    }
  }

  
  
  
  
  
  private Stack m_contextNodeLists = new Stack();
  
  public Stack getContextNodeListsStack() { return m_contextNodeLists; }
  public void setContextNodeListsStack(Stack s) { m_contextNodeLists = s; }

  
  public final DTMIterator getContextNodeList()
  {

    if (m_contextNodeLists.size() > 0)
      return (DTMIterator) m_contextNodeLists.peek();
    else
      return null;
  }

  
  public final void pushContextNodeList(DTMIterator nl)
  {
    m_contextNodeLists.push(nl);
  }

  
  public final void popContextNodeList()
  {
  	if(m_contextNodeLists.isEmpty())
  	  System.err.println(""Warning: popContextNodeList when stack is empty!"");
  	else
      m_contextNodeLists.pop();
  }

  
  public static final int RECURSIONLIMIT = (1024*4);

  
  private int m_currentNodes[] = new int[RECURSIONLIMIT];
  protected int m_currentNodesFirstFree = 0;
   

  
  public int[] getCurrentNodeStack() {return m_currentNodes; }
  public void setCurrentNodeStack(int[] nv) { m_currentNodes = nv; }

  
  public final int getCurrentNode()
  {
    return m_currentNodes[m_currentNodesFirstFree-1];
  }
  
  
  public final void pushCurrentNodeAndExpression(int cn, int en)
  {
    m_currentNodes[m_currentNodesFirstFree++] = cn;
    m_currentExpressionNodes[m_currentExpressionNodesFirstFree++] = cn;
  }

  
  public final void popCurrentNodeAndExpression()
  {
    m_currentNodesFirstFree--;
    m_currentExpressionNodesFirstFree--;
  }
  
  
  public final void pushExpressionState(int cn, int en, PrefixResolver nc)
  {
    m_currentNodes[m_currentNodesFirstFree++] = cn;
    m_currentExpressionNodes[m_currentExpressionNodesFirstFree++] = cn;
    m_prefixResolvers[m_prefixResolversTop++] = nc;
  }
  
  
  public final void popExpressionState()
  {
    m_currentNodesFirstFree--;
    m_currentExpressionNodesFirstFree--;
    m_prefixResolversTop--;
  }



  
  public final void pushCurrentNode(int n)
  {
    m_currentNodes[m_currentNodesFirstFree++] = n;
  }
  
  public int getCurrentNodeFirstFree()
  {
    return m_currentNodesFirstFree;
  }

  
  public final void popCurrentNode()
  {
    m_currentNodesFirstFree--;
  }
  
  
  public final void pushPredicateRoot(int n)
  {
    m_predicateRoots.push(n);
  }

  
  public final void popPredicateRoot()
  {
    m_predicateRoots.popQuick();
  }

  
  public final int getPredicateRoot()
  {
    return m_predicateRoots.peepOrNull();
  }
  
  
  public final void pushIteratorRoot(int n)
  {
    m_iteratorRoots.push(n);
  }

  
  public final void popIteratorRoot()
  {
    m_iteratorRoots.popQuick();
  }

  
  public final int getIteratorRoot()
  {
    return m_iteratorRoots.peepOrNull();
  }
  
  
  private NodeVector m_iteratorRoots = new NodeVector();

  
  private NodeVector m_predicateRoots = new NodeVector();

  
  private int m_currentExpressionNodes[] = new int[RECURSIONLIMIT];
  protected int m_currentExpressionNodesFirstFree = 0;
  
     
  public int[] getCurrentExpressionNodeStack() { return m_currentExpressionNodes; }
  public void setCurrentExpressionNodeStack(int[] nv) { m_currentExpressionNodes = nv; }
  public int getCurrentExpressionNodesFirstFree()
  {
    return m_currentExpressionNodesFirstFree;
  }

  
  private IntStack m_predicatePos = new IntStack();
  
  public final int getPredicatePos()
  {
    return m_predicatePos.peek();
  }

  public final void pushPredicatePos(int n)
  {
    m_predicatePos.push(n);
  }

  public final void popPredicatePos()
  {
    m_predicatePos.pop();
  }

  
  public final int getCurrentExpressionNode()
  {
    return m_currentExpressionNodes[m_currentExpressionNodesFirstFree-1];
  }

  
  public final void pushCurrentExpressionNode(int n)
  {
    m_currentExpressionNodes[m_currentExpressionNodesFirstFree++] = n;
  }

  
  public final void popCurrentExpressionNode()
  {
    m_currentExpressionNodesFirstFree--;
  }
  
  private PrefixResolver[] m_prefixResolvers 
                                   = new PrefixResolver[RECURSIONLIMIT];
  private int m_prefixResolversTop = 0;

  
  public final PrefixResolver getNamespaceContext()
  {
    return m_prefixResolvers[m_prefixResolversTop-1];
  }

  
  public final void setNamespaceContext(PrefixResolver pr)
  {
    m_prefixResolvers[m_prefixResolversTop-1] = pr;
  }

  
  public final void pushNamespaceContext(PrefixResolver pr)
  {
    m_prefixResolvers[m_prefixResolversTop++] = pr;
  }
  
  
  public final void pushNamespaceContextNull()
  {
    m_prefixResolversTop++;
  }

  
  public final void popNamespaceContext()
  {
    m_prefixResolversTop--;
  }

  
  
  

  
  private Stack m_axesIteratorStack = new Stack();
  
  public Stack getAxesIteratorStackStacks() { return m_axesIteratorStack; }
  public void setAxesIteratorStackStacks(Stack s) { m_axesIteratorStack = s; }

  
  public final void pushSubContextList(SubContextList iter)
  {
    m_axesIteratorStack.push(iter);
  }

  
  public final void popSubContextList()
  {
    m_axesIteratorStack.pop();
  }

  
  public SubContextList getSubContextList()
  {
    return m_axesIteratorStack.isEmpty()
           ? null : (SubContextList) m_axesIteratorStack.peek();
  }
  
  
  public org.apache.xpath.axes.LocPathIterator getCurrentNodeList()
  {
    for (int i = m_axesIteratorStack.size()-1; i >= 0; i--) 
    {
      org.apache.xpath.axes.PredicatedNodeTest iter 
       = (org.apache.xpath.axes.PredicatedNodeTest)m_axesIteratorStack.elementAt(i);
      org.apache.xpath.axes.LocPathIterator lpi = iter.getLocPathIterator();
      if(lpi.getIsTopLevel())
        return lpi;
    }
    return null;
  }


  
  
  

  
  public final int getContextNode()
  {
    return this.getCurrentNode();
  }

  
  public final DTMIterator getContextNodes()
  {

    try
    {
      DTMIterator cnl = getContextNodeList();

      if (null != cnl)
        return cnl.cloneWithReset();
      else
        return null;  
    }
    catch (CloneNotSupportedException cnse)
    {
      return null;  
    }
  }
  
  XPathExpressionContext expressionContext = new XPathExpressionContext();
  
  
  public ExpressionContext getExpressionContext()
  {
    return expressionContext;
  }
  
  public class XPathExpressionContext implements ExpressionContext
  {
    
     public XPathContext getXPathContext()
     {
       return XPathContext.this;
     }

    
     public DTMManager getDTMManager()
     {
       return m_dtmManager;
     }
    
    
    public org.w3c.dom.Node getContextNode()
    {
      int context = getCurrentNode();
      
      return getDTM(context).getNode(context);
    }
  
    
    public org.w3c.dom.traversal.NodeIterator getContextNodes()
    {
      return new org.apache.xml.dtm.ref.DTMNodeIterator(getContextNodeList());
    }
  
    
    public double toNumber(org.w3c.dom.Node n)
    {
      
      int nodeHandle = getDTMHandleFromNode(n);
      DTM dtm = getDTM(nodeHandle);
      XString xobj = (XString)dtm.getStringValue(nodeHandle);
      return xobj.num();
    }
  
    
    public String toString(org.w3c.dom.Node n)
    {
      
      int nodeHandle = getDTMHandleFromNode(n);
      DTM dtm = getDTM(nodeHandle);
      XMLString strVal = dtm.getStringValue(nodeHandle);
      return strVal.toString();
    }

    

    public final XObject getVariableOrParam(org.apache.xml.utils.QName qname)
              throws javax.xml.transform.TransformerException
    {
      return m_variableStacks.getVariableOrParam(XPathContext.this, qname);
    }

  }

 
  public DTM getGlobalRTFDTM()
  {
  	
  	
  	
  	
  	
  	
  	
  	
  	

	
	
	
	if( m_global_rtfdtm==null || m_global_rtfdtm.isTreeIncomplete() )
	{
  		m_global_rtfdtm=(SAX2RTFDTM)m_dtmManager.getDTM(null,true,null,false,false);
	}
    return m_global_rtfdtm;
  }
  



  
  public DTM getRTFDTM()
  {
  	SAX2RTFDTM rtfdtm;

  	
  	
  	
  	
  	
  	
  	
  	
  	

	if(m_rtfdtm_stack==null)
	{
		m_rtfdtm_stack=new Vector();
  		rtfdtm=(SAX2RTFDTM)m_dtmManager.getDTM(null,true,null,false,false);
    m_rtfdtm_stack.addElement(rtfdtm);
		++m_which_rtfdtm;
	}
	else if(m_which_rtfdtm<0)
	{
		rtfdtm=(SAX2RTFDTM)m_rtfdtm_stack.elementAt(++m_which_rtfdtm);
	}
	else
	{
		rtfdtm=(SAX2RTFDTM)m_rtfdtm_stack.elementAt(m_which_rtfdtm);
  		
	  	
 	 	
  		
  		
  		
  		
  		if(rtfdtm.isTreeIncomplete())
	  	{
	  		if(++m_which_rtfdtm < m_rtfdtm_stack.size())
				rtfdtm=(SAX2RTFDTM)m_rtfdtm_stack.elementAt(m_which_rtfdtm);
	  		else
	  		{
		  		rtfdtm=(SAX2RTFDTM)m_dtmManager.getDTM(null,true,null,false,false);
          m_rtfdtm_stack.addElement(rtfdtm); 	
	  		}
 	 	}
	}
		
    return rtfdtm;
  }
  
  
  public void pushRTFContext()
  {
  	m_last_pushed_rtfdtm.push(m_which_rtfdtm);
  	if(null!=m_rtfdtm_stack)
	  	((SAX2RTFDTM)(getRTFDTM())).pushRewindMark();
  }
  
  
  public void popRTFContext()
  {
  	if(null==m_rtfdtm_stack)
  		return;
  
  	int previous=m_last_pushed_rtfdtm.pop();
  	if(m_which_rtfdtm==previous)
  	{
  		if(previous>=0) 
  		{
	  		boolean isEmpty=((SAX2RTFDTM)(m_rtfdtm_stack.elementAt(previous))).popRewindMark();
  		}
  	}
  	else while(m_which_rtfdtm!=previous)
  	{
  		
  		
  		
  		boolean isEmpty=((SAX2RTFDTM)(m_rtfdtm_stack.elementAt(m_which_rtfdtm))).popRewindMark();
  		--m_which_rtfdtm; 
  	}
  }
}
"
org.apache.xalan.lib.sql.ConnectionPoolManager,6,1,0,3,16,0,1,2,5,0.3,69,0.0,0,0.0,0.6,0,0,10.16666667,3,1.3333,0,"


 package org.apache.xalan.lib.sql;

import java.util.Hashtable;
import java.lang.IllegalArgumentException;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


public class ConnectionPoolManager
{
  
  static Hashtable m_poolTable = null;
  
  static boolean m_isInit = false;

  
  public ConnectionPoolManager( )
  {
    init();
  }

  
  public synchronized void init( )
  {
    
    if (m_isInit == true) return;


    
    
    
    m_poolTable = new Hashtable();

    m_isInit = true;
  }

  
  public synchronized void registerPool( String name, ConnectionPool pool )
  {
    if ( m_poolTable.containsKey(name) )
    {
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_POOL_EXISTS, null)); 
    }

    m_poolTable.put(name, pool);
  }

  
  public synchronized void removePool( String name )
  {
    ConnectionPool pool = getPool(name);

    if (null != pool)
    {
      
      
      
      
      pool.setPoolEnabled(false);


      
      
      
      
      if ( ! pool.hasActiveConnections() ) m_poolTable.remove(name);
    }

  }


  
  public synchronized ConnectionPool getPool( String name )
  {
    return (ConnectionPool) m_poolTable.get(name);
  }

}"
org.apache.xalan.xsltc.dom.ExtendedSAX,1,1,0,2,1,0,2,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xalan.xsltc.dom;

import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;

public interface ExtendedSAX extends ContentHandler, LexicalHandler { 
    public boolean setEscaping(boolean escape);
}
"
org.apache.xalan.processor.XSLTSchema,6,2,0,27,47,3,5,25,2,0.7875,2654,0.03125,0,0.848484848,0.444444444,1,2,436.0,36,6.6667,2,"
package org.apache.xalan.processor;

import java.util.Hashtable;

import org.apache.xalan.templates.*;
import org.apache.xml.utils.QName;


public class XSLTSchema extends XSLTElementDef
{

  
  XSLTSchema()
  {
    build();
  }

  
  void build()
  {
	
    XSLTAttributeDef hrefAttr = new XSLTAttributeDef(null, ""href"",
                                  XSLTAttributeDef.T_URL, true, false,XSLTAttributeDef.ERROR);
                                  
	
    XSLTAttributeDef elementsAttr = new XSLTAttributeDef(null, ""elements"",
                                      XSLTAttributeDef.T_SIMPLEPATTERNLIST,
                                      true, false, XSLTAttributeDef.ERROR);
                                      
    
    
    
    
    XSLTAttributeDef methodAttr = new XSLTAttributeDef(null, ""method"",
                                    XSLTAttributeDef.T_QNAME, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef versionAttr = new XSLTAttributeDef(null, ""version"",
                                     XSLTAttributeDef.T_NMTOKEN, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef encodingAttr = new XSLTAttributeDef(null, ""encoding"",
                                      XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef omitXmlDeclarationAttr = new XSLTAttributeDef(null,
                                                ""omit-xml-declaration"",
                                                XSLTAttributeDef.T_YESNO,
                                                false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef standaloneAttr = new XSLTAttributeDef(null,
                                        ""standalone"",
                                        XSLTAttributeDef.T_YESNO, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef doctypePublicAttr = new XSLTAttributeDef(null,
                                           ""doctype-public"",
                                           XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef doctypeSystemAttr = new XSLTAttributeDef(null,
                                           ""doctype-system"",
                                           XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef cdataSectionElementsAttr = new XSLTAttributeDef(null,
                                                  ""cdata-section-elements"",
                                                  XSLTAttributeDef.T_QNAMES_RESOLVE_NULL,
                                                  false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef indentAttr = new XSLTAttributeDef(null, ""indent"",
                                    XSLTAttributeDef.T_YESNO, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef mediaTypeAttr = new XSLTAttributeDef(null, ""media-type"",
                                       XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.ERROR);
                                       
                  
    
    
    
    XSLTAttributeDef nameAttrRequired = new XSLTAttributeDef(null, ""name"",
                                          XSLTAttributeDef.T_QNAME, true, false,XSLTAttributeDef.ERROR);
	
    
    
    XSLTAttributeDef nameAVTRequired = new XSLTAttributeDef(null, ""name"",
                                         XSLTAttributeDef.T_AVT_QNAME, true, true,XSLTAttributeDef.WARNING);
            

    
    
    
    XSLTAttributeDef nameAVT_NCNAMERequired = new XSLTAttributeDef(null, ""name"",
                                         XSLTAttributeDef.T_NCNAME, true, true,XSLTAttributeDef.WARNING);
                                        
    
    
    
    XSLTAttributeDef nameAttrOpt_ERROR = new XSLTAttributeDef(null, ""name"",
                                     XSLTAttributeDef.T_QNAME, false, false,XSLTAttributeDef.ERROR);

    
    XSLTAttributeDef useAttr = new XSLTAttributeDef(null, ""use"",
                                 XSLTAttributeDef.T_EXPR, true, false,XSLTAttributeDef.ERROR);
           
    
    XSLTAttributeDef namespaceAVTOpt = new XSLTAttributeDef(null,
                                         ""namespace"",XSLTAttributeDef.T_URL,
                                         false, true,XSLTAttributeDef.WARNING);
    
    XSLTAttributeDef decimalSeparatorAttr = new XSLTAttributeDef(null,
                                              ""decimal-separator"",
                                              XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, ""."");
    XSLTAttributeDef infinityAttr = new XSLTAttributeDef(null, ""infinity"",
                                      XSLTAttributeDef.T_CDATA, false,XSLTAttributeDef.ERROR,""Infinity"");
    XSLTAttributeDef minusSignAttr = new XSLTAttributeDef(null, ""minus-sign"",
                                       XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR,""-"");
    XSLTAttributeDef NaNAttr = new XSLTAttributeDef(null, ""NaN"",
                                 XSLTAttributeDef.T_CDATA, false,XSLTAttributeDef.ERROR, ""NaN"");
    XSLTAttributeDef percentAttr = new XSLTAttributeDef(null, ""percent"",
                                     XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, ""%"");
    XSLTAttributeDef perMilleAttr = new XSLTAttributeDef(null, ""per-mille"",
                                      XSLTAttributeDef.T_CHAR,
                                      false, false,XSLTAttributeDef.ERROR );
    XSLTAttributeDef zeroDigitAttr = new XSLTAttributeDef(null, ""zero-digit"",
                                       XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, ""0"");
    XSLTAttributeDef digitAttr = new XSLTAttributeDef(null, ""digit"",
                                   XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, ""#"");
    XSLTAttributeDef patternSeparatorAttr = new XSLTAttributeDef(null,
                                              ""pattern-separator"",
                                              XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR, "";"");
    
    XSLTAttributeDef groupingSeparatorAttr = new XSLTAttributeDef(null,
                                               ""grouping-separator"",
                                               XSLTAttributeDef.T_CHAR, false,XSLTAttributeDef.ERROR,"","");

                                              
    
    XSLTAttributeDef useAttributeSetsAttr = new XSLTAttributeDef(null,
                                              ""use-attribute-sets"",
                                              XSLTAttributeDef.T_QNAMES,
                                              false, false, XSLTAttributeDef.ERROR);

    
    XSLTAttributeDef testAttrRequired = new XSLTAttributeDef(null, ""test"",   
                                          XSLTAttributeDef.T_EXPR, true, false,XSLTAttributeDef.ERROR);
      
      
    
    
    XSLTAttributeDef selectAttrRequired = new XSLTAttributeDef(null,
                                            ""select"",
                                            XSLTAttributeDef.T_EXPR, true, false,XSLTAttributeDef.ERROR);

    
    
    XSLTAttributeDef selectAttrOpt = new XSLTAttributeDef(null, ""select"",
                                       XSLTAttributeDef.T_EXPR, false, false,XSLTAttributeDef.ERROR);

    
    
    
    XSLTAttributeDef selectAttrDefNode = new XSLTAttributeDef(null, ""select"",
                                           XSLTAttributeDef.T_EXPR, false,XSLTAttributeDef.ERROR, ""node()"");
    
    
    
    XSLTAttributeDef selectAttrDefDot = new XSLTAttributeDef(null, ""select"",
                                          XSLTAttributeDef.T_EXPR, false,XSLTAttributeDef.ERROR, ""."");
    
    XSLTAttributeDef matchAttrRequired = new XSLTAttributeDef(null, ""match"",
                                           XSLTAttributeDef.T_PATTERN, true, false,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef matchAttrOpt = new XSLTAttributeDef(null, ""match"",
                                      XSLTAttributeDef.T_PATTERN, false, false,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef priorityAttr = new XSLTAttributeDef(null, ""priority"",
                                     XSLTAttributeDef.T_NUMBER, false, false,XSLTAttributeDef.ERROR);
                                     
    
    XSLTAttributeDef modeAttr = new XSLTAttributeDef(null, ""mode"",
                                     XSLTAttributeDef.T_QNAME, false, false,XSLTAttributeDef.ERROR);
   
    XSLTAttributeDef spaceAttr =
      new XSLTAttributeDef(Constants.S_XMLNAMESPACEURI, ""space"", false, false, false, XSLTAttributeDef.WARNING,
                           ""default"", Constants.ATTRVAL_STRIP, ""preserve"",
                           Constants.ATTRVAL_PRESERVE);
                           
                         
    XSLTAttributeDef spaceAttrLiteral =
      new XSLTAttributeDef(Constants.S_XMLNAMESPACEURI, ""space"", 
                                          XSLTAttributeDef.T_URL, false, true,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef stylesheetPrefixAttr = new XSLTAttributeDef(null,
                                              ""stylesheet-prefix"",
                                              XSLTAttributeDef.T_CDATA, true, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef resultPrefixAttr = new XSLTAttributeDef(null,
                                          ""result-prefix"",
                                          XSLTAttributeDef.T_CDATA, true, false,XSLTAttributeDef.ERROR);
                                          
    
    XSLTAttributeDef disableOutputEscapingAttr = new XSLTAttributeDef(null,
                                                   ""disable-output-escaping"",
                                                   XSLTAttributeDef.T_YESNO,
                                                   false, false,XSLTAttributeDef.ERROR);
                                                   
	
    XSLTAttributeDef levelAttr = new XSLTAttributeDef(null, ""level"", false, false, false, XSLTAttributeDef.ERROR,
                                   ""single"", Constants.NUMBERLEVEL_SINGLE,
                                   ""multiple"", Constants.NUMBERLEVEL_MULTI,
                                   ""any"", Constants.NUMBERLEVEL_ANY);
    levelAttr.setDefault(""single"");
    XSLTAttributeDef countAttr = new XSLTAttributeDef(null, ""count"",
                                   XSLTAttributeDef.T_PATTERN, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef fromAttr = new XSLTAttributeDef(null, ""from"",
                                  XSLTAttributeDef.T_PATTERN, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef valueAttr = new XSLTAttributeDef(null, ""value"",
                                   XSLTAttributeDef.T_EXPR, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef formatAttr = new XSLTAttributeDef(null, ""format"",
                                    XSLTAttributeDef.T_CDATA, false, true,XSLTAttributeDef.ERROR);
    formatAttr.setDefault(""1"");
    
    
    XSLTAttributeDef langAttr = new XSLTAttributeDef(null, ""lang"",
                                  XSLTAttributeDef.T_NMTOKEN, false, true,XSLTAttributeDef.ERROR);
   
    
    XSLTAttributeDef letterValueAttr = new XSLTAttributeDef(null,
                                         ""letter-value"",
                                         false, true, false, XSLTAttributeDef.ERROR,
                                         ""alphabetic"", Constants.NUMBERLETTER_ALPHABETIC,
                                         ""traditional"", Constants.NUMBERLETTER_TRADITIONAL);
    
    XSLTAttributeDef groupingSeparatorAVT = new XSLTAttributeDef(null,
                                              ""grouping-separator"",
                                              XSLTAttributeDef.T_CHAR, false, true,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef groupingSizeAttr = new XSLTAttributeDef(null,
                                          ""grouping-size"",
                                          XSLTAttributeDef.T_NUMBER, false, true,XSLTAttributeDef.ERROR);
   
   
    XSLTAttributeDef dataTypeAttr = new XSLTAttributeDef(null, ""data-type"", false, true, true, XSLTAttributeDef.ERROR,
                                    ""text"", Constants.SORTDATATYPE_TEXT ,""number"", Constants.SORTDATATYPE_TEXT);
	dataTypeAttr.setDefault(""text"");
	
	
    XSLTAttributeDef orderAttr = new XSLTAttributeDef(null, ""order"", false, true, false,XSLTAttributeDef.ERROR,
                                    ""ascending"", Constants.SORTORDER_ASCENDING, 
                                    ""descending"", Constants.SORTORDER_DESCENDING);
    orderAttr.setDefault(""ascending"");

    
    XSLTAttributeDef caseOrderAttr = new XSLTAttributeDef(null, ""case-order"", false, true, false,XSLTAttributeDef.ERROR,
                                       ""upper-first"", Constants.SORTCASEORDER_UPPERFIRST ,
                                       ""lower-first"", Constants.SORTCASEORDER_LOWERFIRST);
	    
    
    XSLTAttributeDef terminateAttr = new XSLTAttributeDef(null, ""terminate"",
                                       XSLTAttributeDef.T_YESNO, false, false,XSLTAttributeDef.ERROR);
    terminateAttr.setDefault(""no"");

	
    XSLTAttributeDef xslExcludeResultPrefixesAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL,
                           ""exclude-result-prefixes"",
                           XSLTAttributeDef.T_STRINGLIST, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef xslExtensionElementPrefixesAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL,
                           ""extension-element-prefixes"",
                           XSLTAttributeDef.T_PREFIX_URLLIST, false, false,XSLTAttributeDef.ERROR);
    
    XSLTAttributeDef xslUseAttributeSetsAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL, ""use-attribute-sets"",
                           XSLTAttributeDef.T_QNAMES, false, false,XSLTAttributeDef.ERROR);
    XSLTAttributeDef xslVersionAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL, ""version"",
                           XSLTAttributeDef.T_NMTOKEN, false, false,XSLTAttributeDef.ERROR);
                           
    XSLTElementDef charData = new XSLTElementDef(this, null, ""text()"",
                                null , null , null,  
                                new ProcessorCharacters(),
                                ElemTextLiteral.class );

    charData.setType(XSLTElementDef.T_PCDATA);

    XSLTElementDef whiteSpaceOnly = new XSLTElementDef(this, null, ""text()"",
                                      null , null ,
                                      null,  
                                      null,
                                      ElemTextLiteral.class );

    charData.setType(XSLTElementDef.T_PCDATA);

    XSLTAttributeDef resultAttr = new XSLTAttributeDef(null, ""*"",
                                    XSLTAttributeDef.T_AVT, false, true,XSLTAttributeDef.WARNING);
    XSLTAttributeDef xslResultAttr =
      new XSLTAttributeDef(Constants.S_XSLNAMESPACEURL, ""*"",
                           XSLTAttributeDef.T_CDATA, false, false,XSLTAttributeDef.WARNING);
                           
    XSLTElementDef[] templateElements = new XSLTElementDef[22];
    XSLTElementDef[] templateElementsAndParams = new XSLTElementDef[23];
    XSLTElementDef[] templateElementsAndSort = new XSLTElementDef[23];
    
    XSLTElementDef[] exsltFunctionElements = new XSLTElementDef[23];
    
    XSLTElementDef[] charTemplateElements = new XSLTElementDef[15];
    XSLTElementDef resultElement = new XSLTElementDef(this, null, ""*"",
                                     null ,
                                     templateElements ,
                                     new XSLTAttributeDef[]{
                                       spaceAttrLiteral, 
                                       xslExcludeResultPrefixesAttr,
                                       xslExtensionElementPrefixesAttr,
                                       xslUseAttributeSetsAttr,
                                       xslVersionAttr,
                                       xslResultAttr,
                                       resultAttr }, 
                                        new ProcessorLRE(),
                                     ElemLiteralResult.class , 20, true);
    XSLTElementDef unknownElement =
      new XSLTElementDef(this, ""*"", ""unknown"", null ,
                         templateElementsAndParams ,
                         new XSLTAttributeDef[]{ xslExcludeResultPrefixesAttr,
                                                 xslExtensionElementPrefixesAttr,
                                                 xslUseAttributeSetsAttr,
                                                 xslVersionAttr,
                                                 xslResultAttr,
                                                 resultAttr }, 
                                                                                                 new ProcessorUnknown(),
                         ElemUnknown.class , 20, true);
    XSLTElementDef xslValueOf = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""value-of"",
                                  null , null ,
                                  new XSLTAttributeDef[]{ selectAttrRequired,
                                                          disableOutputEscapingAttr }, 
                                               new ProcessorTemplateElem(),
                                  ElemValueOf.class , 20, true);
    XSLTElementDef xslCopyOf = new XSLTElementDef(this,
                                 Constants.S_XSLNAMESPACEURL, ""copy-of"",
                                 null , null ,
                                 new XSLTAttributeDef[]{ selectAttrRequired },
                                 new ProcessorTemplateElem(),
                                 ElemCopyOf.class , 20, true);
    XSLTElementDef xslNumber = new XSLTElementDef(this,
                                 Constants.S_XSLNAMESPACEURL, ""number"",
                                 null , null ,
                                 new XSLTAttributeDef[]{ levelAttr,
                                                         countAttr,
                                                         fromAttr,
                                                         valueAttr,
                                                         formatAttr,
                                                         langAttr,
                                                         letterValueAttr,
                                                         groupingSeparatorAVT,
                                                         groupingSizeAttr }, 
                                        new ProcessorTemplateElem(),
                                 ElemNumber.class , 20, true);

    
    
    XSLTElementDef xslSort = new XSLTElementDef(this,
                                                Constants.S_XSLNAMESPACEURL,
                                                ""sort"", null ,
                                                null ,
                                                new XSLTAttributeDef[]{
                                                  selectAttrDefDot,
                                                  langAttr,
                                                  dataTypeAttr,
                                                  orderAttr,
                                                  caseOrderAttr }, 
                                       new ProcessorTemplateElem(),
                                                ElemSort.class, 19, true );
    XSLTElementDef xslWithParam = new XSLTElementDef(this,
                                    Constants.S_XSLNAMESPACEURL,
                                    ""with-param"", null ,
                                    templateElements ,  
                                    new XSLTAttributeDef[]{ nameAttrRequired,
                                                            selectAttrOpt }, new ProcessorTemplateElem(),
                                                                             ElemWithParam.class , 19, true);
    XSLTElementDef xslApplyTemplates = new XSLTElementDef(this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""apply-templates"", null ,
                                         new XSLTElementDef[]{ xslSort,
                                                               xslWithParam } , new XSLTAttributeDef[]{
                                                                 selectAttrDefNode,
                                                                 modeAttr }, 
                                                                        new ProcessorTemplateElem(),
                                         ElemApplyTemplates.class , 20, true);
    XSLTElementDef xslApplyImports =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""apply-imports"",
                         null , null ,
                         new XSLTAttributeDef[]{},
                         new ProcessorTemplateElem(),
                         ElemApplyImport.class );
    XSLTElementDef xslForEach = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""for-each"",
                                  null , templateElementsAndSort,  
                                  new XSLTAttributeDef[]{ selectAttrRequired,
                                                          spaceAttr }, 
                                               new ProcessorTemplateElem(),
                                  ElemForEach.class , true, false, true, 20, true);
    XSLTElementDef xslIf = new XSLTElementDef(this,
                                              Constants.S_XSLNAMESPACEURL,
                                              ""if"", null ,
                                              templateElements ,  
                                              new XSLTAttributeDef[]{
                                                testAttrRequired,
                                                spaceAttr }, new ProcessorTemplateElem(),
                                                             ElemIf.class , 20, true);
    XSLTElementDef xslWhen =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""when"",
                         null , templateElements ,  
                                                new XSLTAttributeDef[]{
                                                  testAttrRequired,
                                                  spaceAttr }, new ProcessorTemplateElem(),
                                                               ElemWhen.class ,
                                                                                                false, true, 1, true);
    XSLTElementDef xslOtherwise = new XSLTElementDef(this,
                                    Constants.S_XSLNAMESPACEURL, ""otherwise"",
                                    null ,
                                    templateElements ,  
                                    new XSLTAttributeDef[]{ spaceAttr },
                                    new ProcessorTemplateElem(),
                                    ElemOtherwise.class ,
                                                       false, false, 2, false);
    XSLTElementDef xslChoose = new XSLTElementDef(this,
                                 Constants.S_XSLNAMESPACEURL, ""choose"",
                                 null ,
                                 new XSLTElementDef[]{ xslWhen,
                                                       xslOtherwise } , 
                                        new XSLTAttributeDef[]{ spaceAttr },
                                 new ProcessorTemplateElem(),
                                 ElemChoose.class , true, false, true, 20, true);                                
    XSLTElementDef xslAttribute = new XSLTElementDef(this,
                                    Constants.S_XSLNAMESPACEURL, ""attribute"",
                                    null ,
                                    charTemplateElements ,  
                                    new XSLTAttributeDef[]{ nameAVTRequired,
                                                            namespaceAVTOpt,
                                                            spaceAttr }, 
                                    new ProcessorTemplateElem(),
                                    ElemAttribute.class , 20, true);
    XSLTElementDef xslCallTemplate =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""call-template"",
                         null ,
                         new XSLTElementDef[]{ xslWithParam } ,
                         new XSLTAttributeDef[]{ nameAttrRequired },
                         new ProcessorTemplateElem(),
                         ElemCallTemplate.class , 20, true);
    XSLTElementDef xslVariable = new XSLTElementDef(this,
                                   Constants.S_XSLNAMESPACEURL, ""variable"",
                                   null ,
                                   templateElements ,  
                                   new XSLTAttributeDef[]{ nameAttrRequired,
                                                           selectAttrOpt }, 
                                  new ProcessorTemplateElem(),
                                   ElemVariable.class , 20, true);
    XSLTElementDef xslParam = new XSLTElementDef(this,
                                Constants.S_XSLNAMESPACEURL, ""param"",
                                null ,
                                templateElements ,  
                                new XSLTAttributeDef[]{ nameAttrRequired,
                                                        selectAttrOpt }, 
                                       new ProcessorTemplateElem(),
                                ElemParam.class , 19, true);
    XSLTElementDef xslText =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""text"",
                         null ,
                         new XSLTElementDef[]{ charData } ,
                         new XSLTAttributeDef[]{ disableOutputEscapingAttr },
                         new ProcessorText(),
                         ElemText.class , 20, true);
    XSLTElementDef xslProcessingInstruction =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL,
                         ""processing-instruction"", null ,
                         charTemplateElements ,  
                         new XSLTAttributeDef[]{
                                                  nameAVT_NCNAMERequired,
                                                  spaceAttr }, 
                                        new ProcessorTemplateElem(),
                          ElemPI.class , 20, true);
    XSLTElementDef xslElement = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""element"",
                                  null ,
                                  templateElements ,  
                                  new XSLTAttributeDef[]{ nameAVTRequired,
                                                          namespaceAVTOpt,
                                                          useAttributeSetsAttr,
                                                          spaceAttr }, 
                                               new ProcessorTemplateElem(),
                                  ElemElement.class , 20, true);
    XSLTElementDef xslComment = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""comment"",
                                  null ,
                                  charTemplateElements ,  
                                  new XSLTAttributeDef[]{ spaceAttr },
                                  new ProcessorTemplateElem(),
                                  ElemComment.class , 20, true);
    XSLTElementDef xslCopy =
      new XSLTElementDef(this, Constants.S_XSLNAMESPACEURL, ""copy"",
                         null , templateElements ,  
                          new XSLTAttributeDef[]{
                                                  spaceAttr,
                                                  useAttributeSetsAttr }, 
                                        new ProcessorTemplateElem(),
                          ElemCopy.class , 20, true);
    XSLTElementDef xslMessage = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""message"",
                                  null ,
                                  templateElements ,  
                                  new XSLTAttributeDef[]{ terminateAttr },
                                  new ProcessorTemplateElem(),
                                  ElemMessage.class , 20, true);
    XSLTElementDef xslFallback = new XSLTElementDef(this,
                                   Constants.S_XSLNAMESPACEURL, ""fallback"",
                                   null ,
                                   templateElements ,  
                                   new XSLTAttributeDef[]{ spaceAttr },
                                   new ProcessorTemplateElem(),
                                   ElemFallback.class , 20, true);
    
    XSLTElementDef exsltFunction =
                                  new XSLTElementDef(this, 
                                  Constants.S_EXSLT_FUNCTIONS_URL, 
                                  ""function"",
                                  null ,
                                  exsltFunctionElements ,
                                  new XSLTAttributeDef[]{ nameAttrRequired },
                                  new ProcessorExsltFunction(),
                                  ElemExsltFunction.class );
    XSLTElementDef exsltResult =
                                  new XSLTElementDef(this, 
                                  Constants.S_EXSLT_FUNCTIONS_URL, 
                                  ""result"",
                                  null ,
                                  templateElements ,
                                  new XSLTAttributeDef[]{ selectAttrOpt },
                                  new ProcessorExsltFuncResult(),
                                  ElemExsltFuncResult.class  );            
    

    int i = 0;

    templateElements[i++] = charData;  

    
    templateElements[i++] = xslApplyTemplates;
    templateElements[i++] = xslCallTemplate;
    templateElements[i++] = xslApplyImports;
    templateElements[i++] = xslForEach;
    templateElements[i++] = xslValueOf;
    templateElements[i++] = xslCopyOf;
    templateElements[i++] = xslNumber;
    templateElements[i++] = xslChoose;
    templateElements[i++] = xslIf;
    templateElements[i++] = xslText;
    templateElements[i++] = xslCopy;
    templateElements[i++] = xslVariable;
    templateElements[i++] = xslMessage;
    templateElements[i++] = xslFallback;

    
    templateElements[i++] = xslProcessingInstruction;
    templateElements[i++] = xslComment;
    templateElements[i++] = xslElement;
    templateElements[i++] = xslAttribute;
    templateElements[i++] = resultElement;
    templateElements[i++] = unknownElement;
    templateElements[i++] = exsltResult;

    int k;

    for (k = 0; k < i; k++)
    {
      templateElementsAndParams[k] = templateElements[k];
      templateElementsAndSort[k] = templateElements[k];
      exsltFunctionElements[k]     = templateElements[k];

    }

    templateElementsAndParams[k] = xslParam;
    templateElementsAndSort[k] = xslSort;
    exsltFunctionElements[k]   = xslParam;

    i = 0;
    charTemplateElements[i++] = charData;  

    
    charTemplateElements[i++] = xslApplyTemplates;
    charTemplateElements[i++] = xslCallTemplate;
    charTemplateElements[i++] = xslApplyImports;
    charTemplateElements[i++] = xslForEach;
    charTemplateElements[i++] = xslValueOf;
    charTemplateElements[i++] = xslCopyOf;
    charTemplateElements[i++] = xslNumber;
    charTemplateElements[i++] = xslChoose;
    charTemplateElements[i++] = xslIf;
    charTemplateElements[i++] = xslText;
    charTemplateElements[i++] = xslCopy;
    charTemplateElements[i++] = xslVariable;
    charTemplateElements[i++] = xslMessage;
    charTemplateElements[i++] = xslFallback;

    XSLTElementDef importDef = new XSLTElementDef(this,
                                 Constants.S_XSLNAMESPACEURL, ""import"",
                                 null , null ,
                                 new XSLTAttributeDef[]{ hrefAttr },  
                                 new ProcessorImport(),
                                 null ,
                                        1, true);
    XSLTElementDef includeDef = new XSLTElementDef(this,
                                  Constants.S_XSLNAMESPACEURL, ""include"",
                                  null , null ,  
                                  new XSLTAttributeDef[]{ hrefAttr },
                                  new ProcessorInclude(),
                                  null ,
                                               20, true);
    XSLTElementDef[] topLevelElements = new XSLTElementDef[]
                                 {includeDef,
                                  importDef,
                                  
                                  whiteSpaceOnly,
                                  unknownElement,
                                  new XSLTElementDef(
                                         this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""strip-space"",
                                         null ,
                                         null ,
                                         new XSLTAttributeDef[]{
                                                elementsAttr },
                                                new ProcessorStripSpace(),
                                         null , 20, true),
                                  new XSLTElementDef(
                                         this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""preserve-space"",
                                         null ,
                                         null ,
                                         new XSLTAttributeDef[]{
                                                 elementsAttr },
                                                 new ProcessorPreserveSpace(),
                                         null , 20, true),
                                  new XSLTElementDef(
                                         this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""output"",
                                         null ,
                                         null ,
                                         new XSLTAttributeDef[]{
                                                  methodAttr,
                                                  versionAttr,
                                                  encodingAttr,
                                                  omitXmlDeclarationAttr,
                                                  standaloneAttr,
                                                  doctypePublicAttr,
                                                  doctypeSystemAttr,
                                                  cdataSectionElementsAttr,
                                                  indentAttr,
                                                  mediaTypeAttr,
                                                  XSLTAttributeDef.m_foreignAttr }, 
                                          new ProcessorOutputElem(), null , 20, true), 
                                  new XSLTElementDef(
                                          this,
                                          Constants.S_XSLNAMESPACEURL,
                                          ""key"",
                                          null ,
                                          null ,  
                                          new XSLTAttributeDef[]{ nameAttrRequired,
                                                  matchAttrRequired,
                                                  useAttr }, 
                                          new ProcessorKey(), null , 20, true),
                                  new XSLTElementDef(
                                          this,
                                          Constants.S_XSLNAMESPACEURL,
                                          ""decimal-format"",
                                          null ,
                                          null ,  
                                          new XSLTAttributeDef[]{
                                                  nameAttrOpt_ERROR,
                                                  decimalSeparatorAttr,
                                                  groupingSeparatorAttr,
                                                  infinityAttr,
                                                  minusSignAttr,
                                                  NaNAttr,
                                                  percentAttr,
                                                  perMilleAttr,
                                                  zeroDigitAttr,
                                                  digitAttr,
                                                  patternSeparatorAttr }, 
                                           new ProcessorDecimalFormat(),
                                           null , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""attribute-set"",
                                           null ,
                                           new XSLTElementDef[]{
                                                   xslAttribute } ,
                                           new XSLTAttributeDef[]{
                                                   nameAttrRequired,
                                                   useAttributeSetsAttr }, 
                                           new ProcessorAttributeSet(),
                                           null , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""variable"",
                                           null ,
                                           templateElements ,
                                           new XSLTAttributeDef[]{
                                                   nameAttrRequired,
                                                   selectAttrOpt }, 
                                           new ProcessorGlobalVariableDecl(),
                                           ElemVariable.class , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""param"",
                                           null ,
                                           templateElements ,
                                           new XSLTAttributeDef[]{
                                                   nameAttrRequired,
                                                   selectAttrOpt }, 
                                           new ProcessorGlobalParamDecl(),
                                           ElemParam.class , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""template"",
                                           null ,
                                           templateElementsAndParams ,
                                           new XSLTAttributeDef[]{
                                                   matchAttrOpt,
                                                   nameAttrOpt_ERROR,
                                                   priorityAttr,
                                                   modeAttr,
                                                   spaceAttr }, 
                                           new ProcessorTemplate(), ElemTemplate.class , true, 20, true), 
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_XSLNAMESPACEURL,
                                           ""namespace-alias"",
                                           null ,
                                          null ,  
                                           new XSLTAttributeDef[]{ 
                                                   stylesheetPrefixAttr,
                                                   resultPrefixAttr }, 
                                           new ProcessorNamespaceAlias(), null , 20, true),
                                  new XSLTElementDef(
                                           this,
                                           Constants.S_BUILTIN_EXTENSIONS_URL,
                                           ""component"",
                                           null ,
                                           new XSLTElementDef[]{
                                                    new XSLTElementDef(
                                                        this,
                                                        Constants.S_BUILTIN_EXTENSIONS_URL,
                                                        ""script"",
                                                        null ,
                                                    new XSLTElementDef[]{ 
                                                        charData } ,
                                                        new XSLTAttributeDef[]{
                                                            new XSLTAttributeDef(
                                                                null,
                                                                ""lang"",
                                                                XSLTAttributeDef.T_NMTOKEN,
                                                                true, false,XSLTAttributeDef.WARNING),
                                                            new XSLTAttributeDef(
                                                                null, ""src"", XSLTAttributeDef.T_URL, false, false,XSLTAttributeDef.WARNING) }, 
                                                                new ProcessorLRE(),
                                                                ElemExtensionScript.class , 20, true) },  
                                                            new XSLTAttributeDef[]{ 
                                                                new XSLTAttributeDef(
                                                                    null, ""prefix"", XSLTAttributeDef.T_NMTOKEN, true, false,XSLTAttributeDef.WARNING),
                                                                new XSLTAttributeDef(
                                                                    null, ""elements"", XSLTAttributeDef.T_STRINGLIST, false, false,XSLTAttributeDef.WARNING),
                                                                new XSLTAttributeDef(
                                                                    null, ""functions"", XSLTAttributeDef.T_STRINGLIST, false, false,XSLTAttributeDef.WARNING) }, 
                                                    new ProcessorLRE(), ElemExtensionDecl.class ),
                                  exsltFunction};  
    
    XSLTAttributeDef excludeResultPrefixesAttr =
      new XSLTAttributeDef(null, ""exclude-result-prefixes"",
                           XSLTAttributeDef.T_STRINGLIST, false,false,XSLTAttributeDef.WARNING);
    XSLTAttributeDef extensionElementPrefixesAttr =
      new XSLTAttributeDef(null, ""extension-element-prefixes"",
                           XSLTAttributeDef.T_PREFIX_URLLIST, false,false,XSLTAttributeDef.WARNING);
    XSLTAttributeDef idAttr = new XSLTAttributeDef(null, ""id"",
                                XSLTAttributeDef.T_CDATA, false,false,XSLTAttributeDef.WARNING);
    XSLTAttributeDef versionAttrRequired = new XSLTAttributeDef(null,
                                             ""version"",
                                             XSLTAttributeDef.T_NMTOKEN,
                                             true,false,XSLTAttributeDef.WARNING);
    XSLTElementDef stylesheetElemDef = new XSLTElementDef(this,
                                         Constants.S_XSLNAMESPACEURL,
                                         ""stylesheet"", ""transform"",
                                         topLevelElements,
                                         new XSLTAttributeDef[]{
                                           extensionElementPrefixesAttr,
                                           excludeResultPrefixesAttr,
                                           idAttr,
                                           versionAttrRequired,
                                           spaceAttr }, new ProcessorStylesheetElement(),  
                                         null  ,
                                         true, -1, false);

    importDef.setElements(new XSLTElementDef[]{ stylesheetElemDef,
                                                resultElement,
                                                unknownElement });
    includeDef.setElements(new XSLTElementDef[]{ stylesheetElemDef,
                                                 resultElement,
                                                 unknownElement });
    build(null, null, null, new XSLTElementDef[]{ stylesheetElemDef,
                                                  whiteSpaceOnly,
                                                  resultElement,
                                                  unknownElement }, null,
                                                                    new ProcessorStylesheetDoc(),  
                                                                    null  
                                                                      );
  }

  
  private Hashtable m_availElems = new Hashtable();
  
  
  public Hashtable getElemsAvailable() 
  {
    return m_availElems;
  }

  
  void addAvailableElement(QName elemName)
  {
    m_availElems.put(elemName, elemName);
  }

  
  public boolean elementAvailable(QName elemName)
  {
    return m_availElems.containsKey(elemName);
  }
}

"
org.apache.xalan.xsltc.compiler.util.ErrorMessages_no,3,4,0,1,5,1,0,1,2,0.5,349,1.0,0,0.975,0.75,2,3,115.0,6,2.0,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Vector;
import java.util.Enumeration;
import java.util.ResourceBundle;

public final class ErrorMessages_no extends ErrorMessages {
    
    
    
    private static final String errorMessages[] = { 
	
	""En fil kan bare innehold ett stilark."",
	
	""<xsl:template> ''{0}'' er allerede definert i dette stilarket."",
	
	""<xsl:template> ''{0}'' er ikke definert i dette stilarket."",
	
	""Variabel ''{0}'' er allerede definert."",
	
	""Variabel eller parameter ''{0}'' er ikke definert."",
	
	""Finner ikke klassen ''{0}''."",
	
	""Finner ikke ekstern funksjon ''{0}'' (m v e6re deklarert bde 'static' og 'public')."",
	
	""Kan ikke konvertere argument/retur type i kall til funksjon ''{0}''"",
	
	""Finner ikke fil eller URI ''{0}''."",
	
	""Ugyldig URI ''{0}''."",
	
	""Kan ikke pne fil eller URI ''{0}''."",
	
	""Forvented <xsl:stylesheet> eller <xsl:transform> element."",
	
	""Prefiks ''{0}'' er ikke deklarert."",
	
	""Kunne ikke resolvere kall til funksjon ''{0}''."",
	
	""Argument til ''{0}'' m v e6re ordrett tekst."",
	
	""Kunne ikke tolke XPath uttrykk ''{0}''."",
	
	""Ndvendig attributt ''{0}'' er ikke deklarert."",
	
	""Ugyldig bokstav/tegn ''{0}'' i XPath uttrykk."",
	
	""Ugyldig navn ''{0}'' for prosesserings-instruksjon."",
	
	""Attributt ''{0}'' utenfor element."",
	
	""Ugyldig attributt ''{0}''."",
	
	""Sirkul  e6 import/include; stilark ''{0}'' er alt lest."",
	
	""Result-tre fragmenter kan ikke sorteres (<xsl:sort> elementer vil ""+
	""bli ignorert). Du m sortere nodene mens du bygger treet."",
	
	""Formatterings-symboler ''{0}'' er alt definert."",
	
	""XSL versjon ''{0}'' er ikke stttet av XSLTC."",
	
	""Sirkul e6r variabel/parameter referanse i ''{0}''."",
	
	""Ugyldig operator for bin e6rt uttrykk."",
	
	""Ugyldig parameter i funksjons-kall."",
	
	""Andre argument til document() m v e6re et node-sett."",
	
	""Du m deklarere minst ett <xsl:when> element innenfor <xsl:choose>."",
	
	""Kun ett <xsl:otherwise> element kan deklareres innenfor <xsl:choose>."",
	
	""<xsl:otherwise> kan kun benyttes innenfor <xsl:choose>."",
	
	""<xsl:when> kan kun benyttes innenfor <xsl:choose>."",
	
	""Kun <xsl:when> og <xsl:otherwise> kan benyttes innenfor <xsl:choose>."",
	
	""<xsl:attribute-set> element manger 'name' attributt."",
	
	""Ugyldig element."",
	
	""''{0}'' er ikke et gyldig navn for et element."",
	
	""''{0}'' er ikke et gyldig navn for et attributt."",
	
	""Du kan ikke plassere tekst utenfor et <xsl:stylesheet> element."",
	
	""JAXP parser er ikke korrekt konfigurert."",
	
	""XSLTC-intern feil: ''{0}''"",
	
	""Sttter ikke XSL element ''{0}''."",
	
	""XSLTC sttter ikke utvidet funksjon ''{0}''."",
	
	""Dette dokumentet er ikke et XSL stilark ""+
	""(xmlns:xsl='http:
	
	""Kan ikke finne stilark ved navn ''{0}'' i dette dokumentet."",
	
	""Ikke implementert/gjenkjent: ''{0}''."",
	
	""Dokumentet inneholder ikke et XSL stilark"",
	
	""Kan ikke tolke element ''{0}''"",
	
	""'use'-attributtet i <xsl:key> m v e6re node, node-sett, tekst eller nummer."",
	
	""Det genererte XML dokumentet m gis versjon 1.0"",
	
	""Ugyldig operator for relasjons-uttrykk."",
	
	""Finner ikke <xsl:attribute-set> element med navn ''{0}''."",
	
	""Kan ikke tolke attributt ''{0}''."",
	
	""Ukjent data-type i signatur for klassen ''{0}''."",
	
	""Kan ikke oversette mellom data-type ''{0}'' og ''{1}''."",

	
	""Dette Templates objected inneholder ingen translet klasse definisjon."",
	
	""Dette Templates objected inneholder ingen klasse ved navn ''{0}''."",
	
	""Kan ikke laste translet-klasse ''{0}''."",
	
	""Translet klassen er lastet man kan instansieres."",
	
	""ErrorListener for ''{0}'' forskt satt til 'null'."",
	
	""Kun StreamSource, SAXSource og DOMSOurce er stttet av XSLTC"",
	
	""Source objekt sendt til ''{0}'' har intet innhold."",
	
	""Kan ikke kompilere stilark."",
	
	""TransformerFactory gjenkjenner ikke attributtet ''{0}''."",
	
	""setResult() m kalles fr startDocument()."",
	
	""Transformer objektet inneholder ikken noen translet instans."",
	
	""Ingen 'handler' er satt for  ta imot generert dokument."",
	
	""Result objektet sendt til ''{0}'' er ikke gyldig."",
	
	""Forsker  lese ugyldig attributt ''{0}'' fra Transformer."",
	
	""Kan ikke instansiere SAX2DOM adapter: ''{0}''."",
	
	""XSLTCSource.build() kalt uten at 'systemId' er definert."",

	
	""Du kan ikke bruke -i uten  ogs angi klasse-navn med -o."",
	
	""Bruk:
"" + 
	""   xsltc [-o <klasse>] [-d <katalog>] [-j <arkiv>]
""+
	""         [-p <pakke>] [-x] [-s] [-u] <stilark>|-i

""+
	""   Der:  <klasse> er navnet du vil gi den kompilerte java klassen.
""+
	""         <stilark> er ett eller flere XSL stilark, eller dersom -u
""+
	""         er benyttet, en eller flere URL'er til stilark.
""+
	""         <katalog> katalog der klasse filer vil plasseres.
""+
	""         <arkiv> er en JAR-fil der klassene vil plasseres
""+
	""         <pakke> er an Java 'package' klassene vil legges i.

""+
	""   Annet:
""+
	""         -i tvinger kompilatoren til  lese fra stdin.
""+
	""         -o ignoreres dersom flere enn ett silark kompileres.
""+
	""         -x slr p debug meldinger.
""+
	""         -s blokkerer alle kall til System.exit()."",
	
	""Bruk: 
"" +
	""   xslt  [-j <arkiv>] {-u <url> | <dokument>} <klasse>
""+
	""         [<param>=<verdi> ...]

"" +
	""   Der:  <dokument> er XML dokumentet som skal behandles.
"" +
	""         <url> er en URL til XML dokumentet som skal behandles.
"" +
	""         <klasse> er Java klassen som skal benyttes.
"" +
	""         <arkiv> er en JAR-fil som klassen leses fra.
""+
	""   Annet:
""+
	""         -x slr p debug meldinger.
""+
	""         -s blokkerer alle kall til System.exit()."",

	
	""<xsl:sort> kan bare brukes under <xsl:for-each> eller <xsl:apply-templates>."",
	
	""Karaktersett ''{0}'' er ikke stttet av denne JVM."",
	
	""Syntax error in ''{0}''.""  
    };

    public Object handleGetObject(String key) {
	if (key == null) return null;
	if (key.equals(ErrorMsg.ERROR_MESSAGES_KEY))
	    return errorMessages;
 	else if (key.equals(ErrorMsg.COMPILER_ERROR_KEY))
	    return ""Kompilator-feil: "";
	else if (key.equals(ErrorMsg.COMPILER_WARNING_KEY))
	    return ""Advarsel : "";	    
 	else if (key.equals(ErrorMsg.RUNTIME_ERROR_KEY))
	    return ""Kjrefeil: "";
	return(null);
    }

}
"
org.apache.xalan.xsltc.compiler.AncestorPattern,10,6,0,35,46,1,2,33,10,0.518518519,302,1.0,2,0.925233645,0.242857143,3,4,28.9,8,1.6,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class AncestorPattern extends RelativePathPattern {

    private final Pattern _left;	
    private final RelativePathPattern _right;
    private InstructionHandle _loop;
		
    public AncestorPattern(RelativePathPattern right) {
	this(null, right);
    }

    public AncestorPattern(Pattern left, RelativePathPattern right) {
	_left = left;
	(_right = right).setParent(this);
	if (left != null) {
	    left.setParent(this);
	}
    }
	
    public InstructionHandle getLoopHandle() {
	return _loop;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_left != null) {
	    _left.setParser(parser);
	}
	_right.setParser(parser);
    }
    
    public boolean isWildcard() {
	
	return false;
    }
	
    public StepPattern getKernelPattern() {
	return _right.getKernelPattern();
    }

    public void reduceKernelPattern() {
	_right.reduceKernelPattern();
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_left != null) {
	    _left.typeCheck(stable);
	}
	return _right.typeCheck(stable);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	InstructionHandle parent;
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final LocalVariableGen local =
	    methodGen.addLocalVariable2(""app"", Util.getJCRefType(NODE_SIG),
					il.getEnd());

	final org.apache.bcel.generic.Instruction loadLocal =
	    new ILOAD(local.getIndex());
	final org.apache.bcel.generic.Instruction storeLocal =
	    new ISTORE(local.getIndex());

	if (_right instanceof StepPattern) {
	    il.append(DUP);
	    il.append(storeLocal);
	    _right.translate(classGen, methodGen);
	    il.append(methodGen.loadDOM());
	    il.append(loadLocal);
	}
	else {
	    _right.translate(classGen, methodGen);

	    if (_right instanceof AncestorPattern) {
		il.append(methodGen.loadDOM());
		il.append(SWAP);
	    }
	}

	if (_left != null) {
	    final int getParent = cpg.addInterfaceMethodref(DOM_INTF,
							    GET_PARENT,
							    GET_PARENT_SIG);
	    parent = il.append(new INVOKEINTERFACE(getParent, 2));
	    
	    il.append(DUP);
	    il.append(storeLocal);
	    _falseList.add(il.append(new IFEQ(null)));
	    il.append(loadLocal);

	    _left.translate(classGen, methodGen);

	    final SyntaxTreeNode p = getParent();
	    if (p == null || p instanceof Instruction ||
		p instanceof TopLevelElement) 
	    {
		
	    }
	    else {
		il.append(loadLocal);
	    }

	    final BranchHandle exit = il.append(new GOTO(null));
	    _loop = il.append(methodGen.loadDOM());
	    il.append(loadLocal);
	    local.setEnd(_loop);
	    il.append(new GOTO(parent));
	    exit.setTarget(il.append(NOP));
	    _left.backPatchFalseList(_loop);

	    _trueList.append(_left._trueList);	
	}
	else {
	    il.append(POP2);
	}
	
	
	if (_right instanceof AncestorPattern) {
	    final AncestorPattern ancestor = (AncestorPattern) _right;
	    _falseList.backPatch(ancestor.getLoopHandle());    
	}

	_trueList.append(_right._trueList);
	_falseList.append(_right._falseList);
    }

    public String toString() {
	return ""AncestorPattern("" + _left + "", "" + _right + ')';
    }
}
"
org.apache.xpath.patterns.ContextMatchStepPattern,3,4,0,8,16,3,1,8,3,2.0,176,0.0,0,0.975903614,0.583333333,2,12,57.66666667,1,0.6667,0,"
package org.apache.xpath.patterns;

import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.Axis;
import org.apache.xpath.axes.WalkerFactory; 


public class ContextMatchStepPattern extends StepPattern
{

  
  public ContextMatchStepPattern(int axis, int paxis)
  {
    super(DTMFilter.SHOW_ALL, axis, paxis);
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    if (xctxt.getIteratorRoot() == xctxt.getCurrentNode())
      return getStaticScore();
    else
      return this.SCORE_NONE;
  }
  
  
  public XObject executeRelativePathPattern(
          XPathContext xctxt, StepPattern prevStep)
            throws javax.xml.transform.TransformerException
  {

    XObject score = NodeTest.SCORE_NONE;
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);

    if (null != dtm)
    {
      int predContext = xctxt.getCurrentNode();
      DTMAxisTraverser traverser;
      
      int axis = m_axis;
      
      boolean needToTraverseAttrs = WalkerFactory.isDownwardAxisOfMany(axis);
      boolean iterRootIsAttr = (dtm.getNodeType(xctxt.getIteratorRoot()) 
                                 == DTM.ATTRIBUTE_NODE);

      if((Axis.PRECEDING == axis) && iterRootIsAttr)
      {
        axis = Axis.PRECEDINGANDANCESTOR;
      }
      
      traverser = dtm.getAxisTraverser(axis);

      for (int relative = traverser.first(context); DTM.NULL != relative;
              relative = traverser.next(context, relative))
      {
        try
        {
          xctxt.pushCurrentNode(relative);

          score = execute(xctxt);

          if (score != NodeTest.SCORE_NONE)
          {
	      
	      
	      if (executePredicates(xctxt, dtm, context))
		  return score;
	      
	      score = NodeTest.SCORE_NONE;
          }
          
          if(needToTraverseAttrs && iterRootIsAttr
             && (DTM.ELEMENT_NODE == dtm.getNodeType(relative)))
          {
            int xaxis = Axis.ATTRIBUTE;
            for (int i = 0; i < 2; i++) 
            {            
              DTMAxisTraverser atraverser = dtm.getAxisTraverser(xaxis);
        
              for (int arelative = atraverser.first(relative); 
                      DTM.NULL != arelative;
                      arelative = atraverser.next(relative, arelative))
              {
                try
                {
                  xctxt.pushCurrentNode(arelative);
        
                  score = execute(xctxt);
        
                  if (score != NodeTest.SCORE_NONE)
                  {
		      
		      
        
                    if (score != NodeTest.SCORE_NONE)
                      return score;
                  }
                }
                finally
                {
                  xctxt.popCurrentNode();
                }
              }
              xaxis = Axis.NAMESPACE;
            }
          }

        }
        finally
        {
          xctxt.popCurrentNode();
        }
      }

    }

    return score;
  }

}
"
org.apache.xalan.xsltc.compiler.util.TypeCheckError,6,3,0,88,14,0,87,2,6,0.1,97,0.0,2,0.894736842,0.4,1,1,14.83333333,3,0.6667,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.SyntaxTreeNode;

public class TypeCheckError extends Exception {
    ErrorMsg _error = null;
    SyntaxTreeNode _node = null;
	
    public TypeCheckError(SyntaxTreeNode node) {
	super();
	_node = node;
    }

    public TypeCheckError(ErrorMsg error) {
	super();
	_error = error;
    }
	
    public TypeCheckError(int code, Object param) {
	super();
	_error = new ErrorMsg(code, param);
    }

    public TypeCheckError(int code, Object param1, Object param2) {
	super();
	_error = new ErrorMsg(code, param1, param2);
    }

    public ErrorMsg getErrorMsg() {
        return _error;
    }

    public String toString() {
	String result;

	if (_error != null) {
	    result = _error.toString();
	}
	else if (_node != null) {
	    result = ""Type check error in "" + _node.toString() + ""."";
	}
	else {
	    result = ""Type check error (no line information)."";
	}

	return result;
    }
}
"
org.apache.xalan.xsltc.compiler.NameCall,3,5,0,11,11,3,0,11,3,2.0,37,0.0,0,0.99,0.533333333,3,5,11.33333333,1,0.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.compiler.util.Type;

final class NameCall extends NameBase {

    
    public NameCall(QName fname) {
	super(fname);
    }

    
    public NameCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

     
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final int getName = cpg.addInterfaceMethodref(DOM_INTF,
						      GET_NODE_NAME,
						      GET_NODE_NAME_SIG);
	super.translate(classGen, methodGen);
	il.append(new INVOKEINTERFACE(getName, 2));
    }
}
"
org.apache.xalan.xsltc.dom.NodeSortRecordFactory,5,1,0,7,14,4,1,6,3,0.75,127,1.0,2,0.0,0.416666667,0,0,22.8,1,0.6,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.runtime.TransletLoader;

public class NodeSortRecordFactory {

    private static int DESCENDING = ""descending"".length();
    private static int NUMBER     = ""number"".length();

    private final DOM      _dom;
    private final String   _className;
    private Class _class;
    private int   _order[];
    private int   _type[];
    private final AbstractTranslet _translet;

    private Class loadTranslet(String name) throws ClassNotFoundException {
	
	try {
	    return Class.forName(name);
	}
	catch (ClassNotFoundException e) {
	    
	}

	
	TransletLoader loader = new TransletLoader();
	return loader.loadTranslet(name);
    }

    
    public NodeSortRecordFactory(DOM dom, String className, Translet translet,
				 String order[], String type[])
	throws TransletException {
	try {
	    _dom = dom;
	    _className = className;
	    
	    _class = translet.getAuxiliaryClass(className);
	    
	    if (_class == null) _class = loadTranslet(className);
	    _translet = (AbstractTranslet)translet;

	    int levels = order.length;
	    _order = new int[levels];
	    _type = new int[levels];
	    for (int i = 0; i < levels; i++) {
		if (order[i].length() == DESCENDING)
		    _order[i] = NodeSortRecord.COMPARE_DESCENDING;
		if (type[i].length() == NUMBER)
		    _type[i] = NodeSortRecord.COMPARE_NUMERIC;
	    }
	}
	catch (ClassNotFoundException e) {
	    throw new TransletException(e);
	}
    }

    
    public NodeSortRecord makeNodeSortRecord(int node, int last)
	throws ExceptionInInitializerError,
	       LinkageError,
	       IllegalAccessException,
	       InstantiationException,
	       SecurityException,
	       TransletException {

	final NodeSortRecord sortRecord =
	    (NodeSortRecord)_class.newInstance();
	sortRecord.initialize(node, last, _dom, _translet, _order, _type);
	return sortRecord;
    }

    public String getClassName() {
	return _className;
    }
}
"
org.apache.xpath.objects.XRTreeFrag,19,3,1,21,43,87,6,15,18,0.6,336,0.2,3,0.816091954,0.184210526,2,24,16.42105263,9,1.6842,1,"
package org.apache.xpath.objects;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionNode;
import org.apache.xpath.XPathContext;
import org.w3c.dom.NodeList;

import org.apache.xml.dtm.Axis;
import org.apache.xpath.axes.RTFIterator;


public class XRTreeFrag extends XObject implements Cloneable
{
  DTM m_dtm;
  int m_dtmRoot;
  XPathContext m_xctxt;
  boolean m_allowRelease = false;













  
  
  public XRTreeFrag(int root, XPathContext xctxt, ExpressionNode parent)
  {
    super(null);
    
    
    exprSetParent(parent);
    m_dtmRoot = root;
    m_xctxt = xctxt;
    m_dtm = xctxt.getDTM(root);
  }
  
  
  public XRTreeFrag(int root, XPathContext xctxt)
  {
    super(null);
    
    
    m_dtmRoot = root;
    m_xctxt = xctxt;
    m_dtm = xctxt.getDTM(root);
  }

  
  
  public Object object()
  {
    if (m_xctxt != null)
      return new org.apache.xml.dtm.ref.DTMNodeIterator((DTMIterator)(new org.apache.xpath.NodeSetDTM(m_dtmRoot, m_xctxt.getDTMManager())));
    else
      return super.object();
  }
  
  
  public XRTreeFrag(Expression expr)
  {
    super(expr);
  }
  
  
  protected void finalize() throws Throwable
  {
    try
    {
      destruct();
    }
    finally
    {
      super.finalize();  
    }
  }
  
  
  public void allowDetachToRelease(boolean allowRelease)
  {
    m_allowRelease = allowRelease;
  }

  
  public void detach()
  {
    if(m_allowRelease)
    {
    	
    	
      
      int ident = m_xctxt.getDTMIdentity(m_dtm);
      DTM foundDTM = m_xctxt.getDTM(ident);      
      if(foundDTM == m_dtm)
      {
        m_xctxt.release(m_dtm, true);
        m_dtm = null;
        m_xctxt = null;
      }
      m_obj = null;
    }
  }
  
  
  public void destruct()
  {
    if(null != m_dtm)
    {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int ident = m_xctxt.getDTMIdentity(m_dtm);
      DTM foundDTM = m_xctxt.getDTM(ident);      
      if(foundDTM == m_dtm)
      {
        m_xctxt.release(m_dtm, true);
        m_dtm = null;
        m_xctxt = null;
      }
    }
    m_obj = null;
 }

  
  public int getType()
  {
    return CLASS_RTREEFRAG;
  }

  
  public String getTypeString()
  {
    return ""#RTREEFRAG"";
  }

  
  public double num()
    throws javax.xml.transform.TransformerException
  {

    XMLString s = xstr();

    return s.toDouble();
  }

  
  public boolean bool()
  {
    return true;
  }
  
  private XMLString m_xmlStr = null;
  
  
  public XMLString xstr()
  {
    if(null == m_xmlStr)
      m_xmlStr = m_dtm.getStringValue(m_dtmRoot);
    
    return m_xmlStr;
  }
  
  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    XString xstring = (XString)xstr();
    xstring.appendToFsb(fsb);
  }


  
  public String str()
  {
    String str = m_dtm.getStringValue(m_dtmRoot).toString();

    return (null == str) ? """" : str;
  }

  
  public int rtf()
  {
    return m_dtmRoot;
  }

  
  public DTMIterator asNodeIterator()
  {
    DTMIterator iter = new RTFIterator(Axis.SELF);
    iter.setRoot(m_dtmRoot, m_xctxt);    
    return iter;
  }

  
  public NodeList convertToNodeset()
  {

    if (m_obj instanceof NodeList)
      return (NodeList) m_obj;
    else
      return new org.apache.xml.dtm.ref.DTMNodeList(asNodeIterator());
  }

  
  public boolean equals(XObject obj2)
  {

    try
    {
      if (XObject.CLASS_NODESET == obj2.getType())
      {
  
        
        
        
        return obj2.equals(this);
      }
      else if (XObject.CLASS_BOOLEAN == obj2.getType())
      {
        return bool() == obj2.bool();
      }
      else if (XObject.CLASS_NUMBER == obj2.getType())
      {
        return num() == obj2.num();
      }
      else if (XObject.CLASS_NODESET == obj2.getType())
      {
        return xstr().equals(obj2.xstr());
      }
      else if (XObject.CLASS_STRING == obj2.getType())
      {
        return xstr().equals(obj2.xstr());
      }
      else if (XObject.CLASS_RTREEFRAG == obj2.getType())
      {
  
        
        return xstr().equals(obj2.xstr());
      }
      else
      {
        return super.equals(obj2);
      }
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }

}
"
org.apache.xml.dtm.ref.DTMDefaultBaseIterators,3,3,3,40,31,3,30,33,3,2.0,242,0.0,0,0.978723404,0.523809524,0,0,79.66666667,2,1.3333,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;

import javax.xml.transform.Source;

import org.apache.xml.utils.XMLStringFactory;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;



public abstract class DTMDefaultBaseIterators extends DTMDefaultBaseTraversers
{

  
  public DTMDefaultBaseIterators(DTMManager mgr, Source source,
                                 int dtmIdentity,
                                 DTMWSFilter whiteSpaceFilter,
                                 XMLStringFactory xstringfactory,
                                 boolean doIndexing)
  {
    super(mgr, source, dtmIdentity, whiteSpaceFilter, 
          xstringfactory, doIndexing);
  }

  
  public DTMAxisIterator getTypedAxisIterator(int axis, int type)
  {

    DTMAxisIterator iterator = null;

    

    
    
    
    
    
    
    
    
    {
      switch (axis)
      {
      case Axis.SELF :
        iterator = new TypedSingletonIterator(type);
        break;
      case Axis.CHILD :
        iterator = new TypedChildrenIterator(type);
        break;
      case Axis.PARENT :
        return (new ParentIterator().setNodeType(type));
      case Axis.ANCESTOR :
        return (new TypedAncestorIterator(type));
      case Axis.ANCESTORORSELF :
        return ((new TypedAncestorIterator(type)).includeSelf());
      case Axis.ATTRIBUTE :
        return (new TypedAttributeIterator(type));
      case Axis.DESCENDANT :
        iterator = new TypedDescendantIterator(type);
        break;
      case Axis.DESCENDANTORSELF :
        iterator = (new TypedDescendantIterator(type)).includeSelf();
        break;
      case Axis.FOLLOWING :
        iterator = new TypedFollowingIterator(type);
        break;
      case Axis.PRECEDING :
        iterator = new TypedPrecedingIterator(type);
        break;
      case Axis.FOLLOWINGSIBLING :
        iterator = new TypedFollowingSiblingIterator(type);
        break;
      case Axis.PRECEDINGSIBLING :
        iterator = new TypedPrecedingSiblingIterator(type);
        break;
      case Axis.NAMESPACE :
        iterator = new TypedNamespaceIterator(type);
        break;
      case Axis.ROOT :
        iterator = new TypedRootIterator(type);
        break;
      default :
        throw new DTMException(XSLMessages.createMessage(XSLTErrorResources.ER_TYPED_ITERATOR_AXIS_NOT_IMPLEMENTED, new Object[]{Axis.names[axis]})); 
                               
      }
    }

    return (iterator);
  }

  
  public DTMAxisIterator getAxisIterator(final int axis)
  {

    DTMAxisIterator iterator = null;

    switch (axis)
    {
    case Axis.SELF :
      iterator = new SingletonIterator();
      break;
    case Axis.CHILD :
      iterator = new ChildrenIterator();
      break;
    case Axis.PARENT :
      return (new ParentIterator());
    case Axis.ANCESTOR :
      return (new AncestorIterator());
    case Axis.ANCESTORORSELF :
      return ((new AncestorIterator()).includeSelf());
    case Axis.ATTRIBUTE :
      return (new AttributeIterator());
    case Axis.DESCENDANT :
      iterator = new DescendantIterator();
      break;
    case Axis.DESCENDANTORSELF :
      iterator = (new DescendantIterator()).includeSelf();
      break;
    case Axis.FOLLOWING :
      iterator = new FollowingIterator();
      break;
    case Axis.PRECEDING :
      iterator = new PrecedingIterator();
      break;
    case Axis.FOLLOWINGSIBLING :
      iterator = new FollowingSiblingIterator();
      break;
    case Axis.PRECEDINGSIBLING :
      iterator = new PrecedingSiblingIterator();
      break;
    case Axis.NAMESPACE :
      iterator = new NamespaceIterator();
      break;
    case Axis.ROOT :
      iterator = new RootIterator();
      break;
    default :
      throw new DTMException(XSLMessages.createMessage(XSLTErrorResources.ER_ITERATOR_AXIS_NOT_IMPLEMENTED, new Object[]{Axis.names[axis]})); 
                             
    }

    return (iterator);
  }

  
  private abstract class InternalAxisIteratorBase extends DTMAxisIteratorBase
  {

    
    
    
    
    
    
    

    
    protected int _currentNode;

    
    public void setMark()
    {
      _markedNode = _currentNode;
    }

    
    public void gotoMark()
    {
      _currentNode = _markedNode;
    }
  }  

  
  private final class ChildrenIterator extends InternalAxisIteratorBase
  {

    
    public DTMAxisIterator setStartNode(final int node)
    {

      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = NOTPROCESSED;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      _currentNode = (NOTPROCESSED == _currentNode)
                     ? getFirstChild(_startNode)
                     : getNextSibling(_currentNode);

      return returnNode(_currentNode);
    }
  }  

  
  private final class ParentIterator extends InternalAxisIteratorBase
  {

    
    private int _nodeType = -1;

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = getParent(node);

        return resetPosition();
      }

      return this;
    }

    
    public DTMAxisIterator setNodeType(final int type)
    {

      _nodeType = type;

      return this;
    }

    
    public int next()
    {

      int result = _currentNode;

      if ((_nodeType != -1) && (getExpandedTypeID(_currentNode) != _nodeType))
        result = END;
      else
        result = _currentNode;

      _currentNode = END;

      return returnNode(result);
    }
  }  

  
  private final class TypedChildrenIterator extends InternalAxisIteratorBase
  {

    
    private final int _nodeType;

    
    public TypedChildrenIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = NOTPROCESSED;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      for (int node = (NOTPROCESSED == _currentNode)
                      ? getFirstChild(_startNode)
                      : getNextSibling(_currentNode); node
                        != END; node = getNextSibling(node))
      {
        if (getExpandedTypeID(node) == _nodeType)
        {
          _currentNode = node;

          return returnNode(node);
        }
      }

      return END;
    }
  }  

  
  private final class NamespaceChildrenIterator
          extends InternalAxisIteratorBase
  {

    
    private final int _nsType;

    
    public NamespaceChildrenIterator(final int type)
    {
      _nsType = type;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = NOTPROCESSED;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      for (int node = (NOTPROCESSED == _currentNode)
                      ? getFirstChild(_startNode)
                      : getNextSibling(_currentNode); node
                        != END; node = getNextSibling(node))
      {
        if (getNamespaceType(node) == _nsType)
        {
          _currentNode = node;

          return returnNode(node);
        }
      }

      return END;
    }
  }  
  
  
  private class NamespaceIterator
          extends InternalAxisIteratorBase
  {

    
    public NamespaceIterator()
    {

      super();
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = getFirstNamespaceNode(node, true);

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      int node = _currentNode;

      if (DTM.NULL != node)
        _currentNode = getNextNamespaceNode(_startNode, node, true);

      return returnNode(node);
    }
  }  
  
  
  private class TypedNamespaceIterator extends NamespaceIterator
  {

    
    private final int _nodeType;

    
    public TypedNamespaceIterator(int nodeType)
    {
      super();
      _nodeType = nodeType;
    }

    
    public int next()
    {

      for (int node = super.next(); node != END; node = super.next())
      {
        if (getExpandedTypeID(node) == _nodeType)
        {
          _currentNode = node;

          return returnNode(node);
        }
      }

      return END;
    }
  }  
  
  
  private class RootIterator
          extends InternalAxisIteratorBase
  {

    
    public RootIterator()
    {

      super();
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = getDocumentRoot(node);
        _currentNode = NULL;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      if(_startNode == _currentNode)
        return NULL;

      _currentNode = _startNode;

      return returnNode(_startNode);
    }
  }  
  
  
  private class TypedRootIterator extends RootIterator
  {

    
    private final int _nodeType;

    
    public TypedRootIterator(int nodeType)
    {
      super();
      _nodeType = nodeType;
    }

    
    public int next()
    {

      for (int node = super.next(); node != END; node = super.next())
      {
        if (getExpandedTypeID(node) == _nodeType)
        {
          _currentNode = node;

          return returnNode(node);
        }
      }

      return END;
    }
  }  

  
  private final class NamespaceAttributeIterator
          extends InternalAxisIteratorBase
  {

    
    private final int _nsType;

    
    public NamespaceAttributeIterator(int nsType)
    {

      super();

      _nsType = nsType;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = getFirstNamespaceNode(node, false);

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      int node = _currentNode;

      if (DTM.NULL != node)
        _currentNode = getNextNamespaceNode(_startNode, node, false);

      return returnNode(node);
    }
  }  

  
  private class FollowingSiblingIterator extends InternalAxisIteratorBase
  {

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _currentNode = _startNode = node;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
      return returnNode(_currentNode = getNextSibling(_currentNode));
    }
  }  

  
  private final class TypedFollowingSiblingIterator
          extends FollowingSiblingIterator
  {

    
    private final int _nodeType;

    
    public TypedFollowingSiblingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {

      int node;

      while ((node = super.next()) != NULL
             && getExpandedTypeID(node) != _nodeType){}

      return node;
    }
  }  

  
  private final class AttributeIterator extends InternalAxisIteratorBase
  {

    

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = node;
        _currentNode = getFirstAttribute(node);

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      final int node = _currentNode;

      _currentNode = getNextAttribute(node);

      return returnNode(node);
    }
  }  

  
  private final class TypedAttributeIterator extends InternalAxisIteratorBase
  {

    
    private final int _nodeType;

    
    public TypedAttributeIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = node;

        for (node = getFirstAttribute(node); node != END;
                node = getNextAttribute(node))
        {
          if (getExpandedTypeID(node) == _nodeType)
            break;
        }

        _currentNode = node;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      final int node = _currentNode;

      
      
      _currentNode = NULL;

      return returnNode(node);
    }
  }  

  
  private class PrecedingSiblingIterator extends InternalAxisIteratorBase
  {

    
    public boolean isReverse()
    {
      return true;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {
      if (_isRestartable)
      {
        _startNode = node;

        if(node == NULL)
        {
          _currentNode = node;
          return resetPosition();
        }
          
        int type = m_expandedNameTable.getType(getExpandedTypeID(node));
        if(ExpandedNameTable.ATTRIBUTE == type 
           || ExpandedNameTable.NAMESPACE == type )
        {
          _currentNode = node;
        }
        else
				{
					
					_currentNode = getParent(node);
					if(NULL!=_currentNode)	
						_currentNode = getFirstChild(_currentNode);
					else
						_currentNode = node;
				}

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      if (_currentNode == _startNode)
      {
        return NULL;
      }
      else
      {
        final int node = _currentNode;
        _currentNode = getNextSibling(node);

        return returnNode(node);
      }
    }
  }  

  
  private final class TypedPrecedingSiblingIterator
          extends PrecedingSiblingIterator
  {

    
    private final int _nodeType;

    
    public TypedPrecedingSiblingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {

      int node;

      while ((node = super.next()) != NULL
             && getExpandedTypeID(node) != _nodeType){}

      return node;
    }
  }  

  
  private class PrecedingIterator extends InternalAxisIteratorBase
  {

    
    private final int _maxAncestors = 8;

    
    private int[] _stack = new int[_maxAncestors];

    
    private int _sp, _oldsp;

    

    
    public boolean isReverse()
    {
      return true;
    }

    
    public DTMAxisIterator cloneIterator()
    {
      _isRestartable = false;

      try
      {
        final PrecedingIterator clone = (PrecedingIterator) super.clone();
        final int[] stackCopy = new int[_stack.length];
        System.arraycopy(_stack, 0, stackCopy, 0, _stack.length);

        clone._stack = stackCopy;

        
        return clone;
      }
      catch (CloneNotSupportedException e)
      {
        throw new DTMException(XSLMessages.createMessage(XSLTErrorResources.ER_ITERATOR_CLONE_NOT_SUPPORTED, null)); 
      }
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        node = makeNodeIdentity(node);

        
        int parent, index;

        _startNode = node;
        _stack[index = 0] = node;

		parent=node;
		while ((parent = _parent(parent)) != NULL)
		{
			if (++index == _stack.length)
			{
				final int[] stack = new int[index + 4];
				System.arraycopy(_stack, 0, stack, 0, index);
				_stack = stack;
			}
			_stack[index] = parent;
        }
        if(index>0)
	        --index; 

        _currentNode=_stack[index]; 

        _oldsp = _sp = index;

        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {
    	
    	
    	
   		for(++_currentNode; 
   			_sp>=0; 
   			++_currentNode)
   		{
   			if(_currentNode < _stack[_sp])
   			{
   				if(_type(_currentNode) != ATTRIBUTE_NODE &&
   					_type(_currentNode) != NAMESPACE_NODE)
   					return returnNode(makeNodeHandle(_currentNode));
   			}
   			else
   				--_sp;
   		}
   		return NULL;
    }

    

    
    public DTMAxisIterator reset()
    {

      _sp = _oldsp;

      return resetPosition();
    }
  }  

  
  private final class TypedPrecedingIterator extends PrecedingIterator
  {

    
    private final int _nodeType;

    
    public TypedPrecedingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {

      int node;

      while ((node = super.next()) != NULL
             && getExpandedTypeID(node) != _nodeType){}

      return node;
    }
  }  

  
  private class FollowingIterator extends InternalAxisIteratorBase
  {
    DTMAxisTraverser m_traverser; 
    
    public FollowingIterator()
    {
      m_traverser = getAxisTraverser(Axis.FOLLOWING);
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        _startNode = node;

        
        
        
        
        
        _currentNode = m_traverser.first(node);

        
        return resetPosition();
      }

      return this;
    }

    
    public int next()
    {

      int node = _currentNode;

      _currentNode = m_traverser.next(_startNode, _currentNode);

      return returnNode(node);
    }
  }  

  
  private final class TypedFollowingIterator extends FollowingIterator
  {

    
    private final int _nodeType;

    
    public TypedFollowingIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {

      int node;

      while ((node = super.next()) != NULL
             && getExpandedTypeID(node) != _nodeType){}

      return returnNode(node);
    }
  }  

  
  private class AncestorIterator extends InternalAxisIteratorBase
  {
    org.apache.xml.utils.NodeVector m_ancestors = 
         new org.apache.xml.utils.NodeVector();
         
    int m_ancestorsPos;
    
    
    int m_realStartNode;
    
    
    public int getStartNode()
    {
      return m_realStartNode;
    }

    
    public final boolean isReverse()
    {
      return true;
    }

    
    public int getLast()
    {
      return (_startNode);
    }

    
    public DTMAxisIterator cloneIterator()
    {
      _isRestartable = false;  

      try
      {
        final AncestorIterator clone = (AncestorIterator) super.clone();

        clone._startNode = _startNode;

        
        return clone;
      }
      catch (CloneNotSupportedException e)
      {
        throw new DTMException(XSLMessages.createMessage(XSLTErrorResources.ER_ITERATOR_CLONE_NOT_SUPPORTED, null)); 
      }
    }

    
    public DTMAxisIterator setStartNode(int node)
    {
      m_realStartNode = node;

      if (_isRestartable)
      {
        if (_includeSelf)
          _startNode = node;
        else
          _startNode = getParent(node);

        node = _startNode;
        while (node != END)
        {
          m_ancestors.addElement(node);
          node = getParent(node);
        }
        m_ancestorsPos = m_ancestors.size()-1;

        _currentNode = (m_ancestorsPos>=0)
                               ? m_ancestors.elementAt(m_ancestorsPos)
                               : DTM.NULL;

        return resetPosition();
      }

      return this;
    }

    
    public DTMAxisIterator reset()
    {

      m_ancestorsPos = m_ancestors.size()-1;

      _currentNode = (m_ancestorsPos>=0) ? m_ancestors.elementAt(m_ancestorsPos)
                                         : DTM.NULL;

      return resetPosition();
    }

    
    public int next()
    {

      int next = _currentNode;
      
      int pos = --m_ancestorsPos;

      _currentNode = (pos >= 0) ? m_ancestors.elementAt(m_ancestorsPos)
                                : DTM.NULL;
      
      return returnNode(next);
    }
  }  

  
  private final class TypedAncestorIterator extends AncestorIterator
  {

    
    private final int _nodeType;

    
    public TypedAncestorIterator(int type)
    {
      _nodeType = type;
    }

    
    public int next()
    {

      int node;

      while ((node = super.next()) != NULL)
      {
        if (getExpandedTypeID(node) == _nodeType)
          return returnNode(node);
      }

      return (NULL);
    }

    
    public int getLast()
    {

      int last = NULL;
      int curr = _startNode;

      while (curr != NULL)
      {
        if (getExpandedTypeID(curr) == _nodeType)
          last = curr;

        curr = getParent(curr);
      }

      return (last);
    }
  }  

  
  private class DescendantIterator extends InternalAxisIteratorBase
  {

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isRestartable)
      {
        node = makeNodeIdentity(node);
        _startNode = node;

        if (_includeSelf)
          node--;

        _currentNode = node;

        return resetPosition();
      }

      return this;
    }

    
    protected boolean isDescendant(int identity)
    {
      return (_startNode == identity) || _parent(identity) >= _startNode;
    }

    
    public int next()
    {

      while (true)
      {
        int node = ++_currentNode;
        int type = _type(node);

        if (NULL == type ||!isDescendant(node))
          return END;

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type)
          continue;

        return returnNode(makeNodeHandle(node));  
      }
    }
  }  

  
  private final class TypedDescendantIterator extends DescendantIterator
  {

    
    private final int _nodeType;

    
    public TypedDescendantIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    
    public int next()
    {

      int node;

      while ((node = super.next()) != NULL
             && getExpandedTypeID(node) != _nodeType){}

      return node;
    }
  }  

  
  private class NthDescendantIterator extends DescendantIterator
  {

    
    int _pos;

    
    public NthDescendantIterator(int pos)
    {
      _pos = pos;
    }

    
    public int next()
    {

      
      int node;

      while ((node = super.next()) != END)
      {
        node = makeNodeIdentity(node);

        int parent = _parent(node);
        int child = _firstch(parent);
        int pos = 0;

        do
        {
          int type = _type(child);

          if (ELEMENT_NODE == type)
            pos++;
        }
        while ((pos < _pos) && (child = _nextsib(child)) != END);

        if (node == child)
          return node;
      }

      return (END);
    }
  }  

  
  private class SingletonIterator extends InternalAxisIteratorBase
  {

    
    private boolean _isConstant;

    
    public SingletonIterator()
    {
      this(Integer.MIN_VALUE, false);
    }

    
    public SingletonIterator(int node)
    {
      this(node, false);
    }

    
    public SingletonIterator(int node, boolean constant)
    {
      _currentNode = _startNode = node;
      _isConstant = constant;
    }

    
    public DTMAxisIterator setStartNode(int node)
    {

      if (_isConstant)
      {
        _currentNode = _startNode;

        return resetPosition();
      }
      else if (_isRestartable)
      {
        if (_currentNode == Integer.MIN_VALUE)
        {
          _currentNode = _startNode = node;
        }

        return resetPosition();
      }

      return this;
    }

    
    public DTMAxisIterator reset()
    {

      if (_isConstant)
      {
        _currentNode = _startNode;

        return resetPosition();
      }
      else
      {
        final boolean temp = _isRestartable;

        _isRestartable = true;

        setStartNode(_startNode);

        _isRestartable = temp;
      }

      return this;
    }

    
    public int next()
    {

      final int result = _currentNode;

      _currentNode = END;

      return returnNode(result);
    }
  }

  
  private final class TypedSingletonIterator extends SingletonIterator
  {

    
    private final int _nodeType;

    
    public TypedSingletonIterator(int nodeType)
    {
      _nodeType = nodeType;
    }

    
    public int next()
    {

      final int result = super.next();

      return getExpandedTypeID(result) == _nodeType ? result : NULL;
    }
  }  
}
"
org.apache.xalan.xsltc.compiler.StringLengthCall,2,4,0,13,13,1,0,13,2,2.0,44,0.0,0,0.989690722,0.6,2,4,21.0,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class StringLengthCall extends FunctionCall {
    public StringLengthCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	if (argumentCount() > 0) {
	    argument().translate(classGen, methodGen);
	}
	else {
	    il.append(methodGen.loadContextNode());
	    Type.Node.translateTo(classGen, methodGen, Type.String);
	}
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_CLASS,
						     ""length"", ""()I"")));
    }
}
"
org.apache.xalan.xsltc.runtime.AttributeList,16,1,0,4,38,58,3,1,16,0.741666667,261,1.0,1,0.0,0.453125,0,0,14.8125,3,1.3125,0,"

package org.apache.xalan.xsltc.runtime;

import org.xml.sax.SAXException;
import org.xml.sax.Attributes;

import java.util.Vector;
import java.util.Enumeration;

public class AttributeList implements org.xml.sax.Attributes {

    private final static String EMPTYSTRING = """";
    private final static String CDATASTRING = ""CDATA"";

    private Hashtable _attributes;
    private Vector    _names;
    private Vector    _qnames;
    private Vector    _values;
    private Vector    _uris;
    private int       _length;

    
    public AttributeList() {
	_attributes = new Hashtable();
	_names  = new Vector();
	_values = new Vector();
	_qnames = new Vector();
	_uris   = new Vector();
	_length = 0;
    }

    
    public AttributeList(org.xml.sax.Attributes attributes) {
	this();
	if (attributes != null) {
	    final int count = attributes.getLength();
	    for (int i = 0; i < count; i++) {
		add(attributes.getQName(i),attributes.getValue(i));
	    }
	}
    }

    
    public int getLength() {
	return(_length);
    }

    
    public String getURI(int index) {
	if (index < _length)
	    return((String)_uris.elementAt(index));
	else
	    return(null);
    }

    
    public String getLocalName(int index) {
	if (index < _length)
	    return((String)_names.elementAt(index));
	else
	    return(null);
    }

    
    public String getQName(int pos) {
	if (pos < _length)
	    return((String)_qnames.elementAt(pos));
	else
	    return(null);
    }

    
    public String getType(int index) {
	return(CDATASTRING);
    }

    
    public int getIndex(String namespaceURI, String localPart) {
	return(0);
    }

    
    public int getIndex(String qname) {
	return(0);
    }

    
    public String getType(String uri, String localName) {
	return(CDATASTRING);
    }

    
    public String getType(String qname) {
	return(CDATASTRING);
    }

    
    public String getValue(int pos) {
	if (pos < _length)
	    return((String)_values.elementAt(pos));
	else
	    return(null);
    }

    
    public String getValue(String qname) {
	final Integer obj = (Integer)_attributes.get(qname);
	if (obj == null) return null;
	return(getValue(obj.intValue()));
    }

    
    public String getValue(String uri, String localName) {
	return(getValue(uri+':'+localName));
    }

    
    public void add(String qname, String value) {
	
	Integer obj = (Integer)_attributes.get(qname);
	if (obj == null) {
	    _attributes.put(qname, obj = new Integer(_length++));
	    _qnames.addElement(qname);
	    _values.addElement(value);
	    int col = qname.lastIndexOf(':');
	    if (col > -1) {
		_uris.addElement(qname.substring(0,col));
		_names.addElement(qname.substring(col+1));
	    }
	    else {
		_uris.addElement(EMPTYSTRING);
		_names.addElement(qname);
	    }
	}
	else {
	    final int index = obj.intValue();
	    _values.set(index, value);
	}
    }

    
    public void clear() {
	_length = 0;
	_attributes.clear();
	_names.removeAllElements();
	_values.removeAllElements();
	_qnames.removeAllElements();
	_uris.removeAllElements();
    }
    
}
"
org.apache.xalan.processor.XSLTAttributeDef,43,1,0,13,91,783,4,9,1,0.962585034,1954,0.166666667,2,0.0,0.328042328,0,0,43.46511628,19,1.5349,1,"
package org.apache.xalan.processor;

import org.apache.xml.utils.StringToIntTable;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.xalan.templates.AVT;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.StringVector;
import org.apache.xml.utils.XMLChar;
import org.apache.xpath.XPath;

import javax.xml.transform.TransformerException;

 

public class XSLTAttributeDef
{
   
   static final int FATAL = 0;
   static final int ERROR = 1;
   static final int WARNING = 2;
   
   
  
  XSLTAttributeDef(String namespace, String name, int type, boolean required, boolean supportsAVT, int errorType)
  {
    this.m_namespace = namespace;
    this.m_name = name;
    this.m_type = type;
    this.m_required = required;
    this.m_supportsAVT = supportsAVT;
    this.m_errorType = errorType;
  }

  
  XSLTAttributeDef(String namespace, String name, int type, boolean supportsAVT, int errorType, String defaultVal)
  {

    this.m_namespace = namespace;
    this.m_name = name;
    this.m_type = type;
    this.m_required = false;
    this.m_supportsAVT = supportsAVT;  
    this.m_errorType = errorType;      
    this.m_default = defaultVal;
   }

  
  XSLTAttributeDef(String namespace, String name, boolean required, boolean supportsAVT, 
                    boolean prefixedQNameValAllowed, int errorType, String k1, int v1, String k2, int v2)
  {

    this.m_namespace = namespace;
    this.m_name = name;
	this.m_type = prefixedQNameValAllowed ? this.T_ENUM_OR_PQNAME : this.T_ENUM;    
    this.m_required = required;
    this.m_supportsAVT = supportsAVT;    
    this.m_errorType = errorType;    
    m_enums = new StringToIntTable(2);

    m_enums.put(k1, v1);
    m_enums.put(k2, v2);
  }

  
  XSLTAttributeDef(String namespace, String name, boolean required, boolean supportsAVT,
                    boolean prefixedQNameValAllowed, int errorType, String k1, int v1, String k2, int v2, String k3, int v3)
  {

    this.m_namespace = namespace;
    this.m_name = name;
	this.m_type = prefixedQNameValAllowed ? this.T_ENUM_OR_PQNAME : this.T_ENUM;    
    this.m_required = required;
    this.m_supportsAVT = supportsAVT; 
    this.m_errorType = errorType;      
    m_enums = new StringToIntTable(3);

    m_enums.put(k1, v1);
    m_enums.put(k2, v2);
    m_enums.put(k3, v3);
  }

  
  XSLTAttributeDef(String namespace, String name, boolean required, boolean supportsAVT,
                   boolean prefixedQNameValAllowed, int errorType, String k1, int v1, String k2, int v2, 
                   String k3, int v3, String k4, int v4)
  {

    this.m_namespace = namespace;
    this.m_name = name;
	this.m_type = prefixedQNameValAllowed ? this.T_ENUM_OR_PQNAME : this.T_ENUM;    
    this.m_required = required;
    this.m_supportsAVT = supportsAVT;      
    this.m_errorType = errorType; 
    m_enums = new StringToIntTable(4);

    m_enums.put(k1, v1);
    m_enums.put(k2, v2);
    m_enums.put(k3, v3);
    m_enums.put(k4, v4);
  }

  
  static final int T_CDATA = 1,

  
  T_URL = 2,

  
  
  T_AVT = 3,  

  
  T_PATTERN = 4,

  
  T_EXPR = 5,

  
  
  T_CHAR = 6,

  
  T_NUMBER = 7,

  
  T_YESNO = 8,

  
  
  T_QNAME = 9,

  
  
  T_QNAMES = 10,

  
  T_ENUM = 11,

  
  T_SIMPLEPATTERNLIST = 12,

  
  T_NMTOKEN = 13,

  
  T_STRINGLIST = 14,

  
  T_PREFIX_URLLIST = 15,
  
  
  T_ENUM_OR_PQNAME = 16,

  
  T_NCNAME = 17,
  
  
  T_AVT_QNAME = 18,
  
  
  
  T_QNAMES_RESOLVE_NULL = 19;
  

  
  static XSLTAttributeDef m_foreignAttr = new XSLTAttributeDef(""*"", ""*"",
                                            XSLTAttributeDef.T_CDATA,false, false, WARNING);

  
  static String S_FOREIGNATTR_SETTER = ""setForeignAttr"";

  
  private String m_namespace;

  
  String getNamespace()
  {
    return m_namespace;
  }

  
  private String m_name;

  
  String getName()
  {
    return m_name;
  }

  
  private int m_type;

  
  int getType()
  {
    return m_type;
  }

  
  private StringToIntTable m_enums;

  
  private int getEnum(String key)
  {
    return m_enums.get(key);
  }

 
  private String[] getEnumNames()
  {
    return m_enums.keys();
  }

  
  private String m_default;

  
  String getDefault()
  {
    return m_default;
  }

  
  void setDefault(String def)
  {
    m_default = def;
  }

  
  private boolean m_required;

  
  boolean getRequired()
  {
    return m_required;
  }

  
  private boolean m_supportsAVT;

  
  boolean getSupportsAVT()
  {
    return m_supportsAVT;
  }
  
  int m_errorType = this.WARNING;
  
  
  int getErrorType()
  {
    return m_errorType;
  }
  
  String m_setterString = null;

  
  public String getSetterMethodName()
  {

    if (null == m_setterString)
    {
      if (m_foreignAttr == this)
      {
        return S_FOREIGNATTR_SETTER;
      }
      else if (m_name.equals(""*""))
      {
        m_setterString = ""addLiteralResultAttribute"";

        return m_setterString;
      }

      StringBuffer outBuf = new StringBuffer();

      outBuf.append(""set"");

      if ((m_namespace != null)
              && m_namespace.equals(Constants.S_XMLNAMESPACEURI))
      {
        outBuf.append(""Xml"");
      }

      int n = m_name.length();

      for (int i = 0; i < n; i++)
      {
        char c = m_name.charAt(i);

        if ('-' == c)
        {
          i++;

          c = m_name.charAt(i);
          c = Character.toUpperCase(c);
        }
        else if (0 == i)
        {
          c = Character.toUpperCase(c);
        }

        outBuf.append(c);
      }

      m_setterString = outBuf.toString();
    }

    return m_setterString;
  }

  
  AVT processAVT(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    try
    {
      AVT avt = new AVT(handler, uri, name, rawName, value, owner);

      return avt;
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  Object processCDATA(StylesheetHandler handler, String uri, String name,
                      String rawName, String value, ElemTemplateElement owner)
                      throws org.xml.sax.SAXException
  {
  	if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	      return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }  		
  	} else {  	  	
	    return value;
  	}
  }

  
  Object processCHAR(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {
	if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	
		  
		  if ((avt.isSimple()) && (value.length() != 1)) {
		  	handleError(handler, XSLTErrorResources.INVALID_TCHAR, new Object[] {name, value},null);
            return null;
		  }	
	      return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }
	} else {    
	    if (value.length() != 1)
	    {
            handleError(handler, XSLTErrorResources.INVALID_TCHAR, new Object[] {name, value},null);
            return null;
	    }

	    return new Character(value.charAt(0));
	}
  }

  
  Object processENUM(StylesheetHandler handler, String uri, String name,
                     String rawName, String value, ElemTemplateElement owner)
                     throws org.xml.sax.SAXException
  {

	AVT avt = null;
	if (getSupportsAVT()) {
	    try
	    {
	      avt = new AVT(handler, uri, name, rawName, value, owner);
	      
	      
	      if (!avt.isSimple()) return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }
	}    
	
    int retVal = this.getEnum(value);
    
	if (retVal == StringToIntTable.INVALID_KEY) 
    {
       StringBuffer enumNamesList = getListOfEnums();
       handleError(handler, XSLTErrorResources.INVALID_ENUM,new Object[]{name, value, enumNamesList.toString() },null);
       return null;
    }

	if (getSupportsAVT()) return avt;
	else return new Integer(retVal);	

  }

  
  Object processENUM_OR_PQNAME(StylesheetHandler handler, String uri, String name,
                     String rawName, String value, ElemTemplateElement owner)
                     throws org.xml.sax.SAXException
  {

	Object objToReturn = null;
	
	if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	      if (!avt.isSimple()) return avt;
	      else objToReturn = avt;
	    }  
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }
	}    
	
    
  	int enum = this.getEnum(value);
    
    if (enum != StringToIntTable.INVALID_KEY) 
    {
        if (objToReturn == null) objToReturn = new Integer(enum);
    }

    
    else
    {
        try 
        {
			QName qname = new QName(value, handler, true);
            if (objToReturn == null) objToReturn = qname;	
	        
			if (qname.getPrefix() == null) {
	           StringBuffer enumNamesList = getListOfEnums();

 	           enumNamesList.append("" <qname-but-not-ncname>"");
               handleError(handler,XSLTErrorResources.INVALID_ENUM,new Object[]{name, value, enumNamesList.toString() },null); 
               return null;
        
	        }            
        }
        catch (IllegalArgumentException ie) 
        {
           StringBuffer enumNamesList = getListOfEnums();
           enumNamesList.append("" <qname-but-not-ncname>"");
           
           handleError(handler,XSLTErrorResources.INVALID_ENUM,new Object[]{name, value, enumNamesList.toString() },ie); 
           return null;

        }
        catch (RuntimeException re)
        {
           StringBuffer enumNamesList = getListOfEnums();
           enumNamesList.append("" <qname-but-not-ncname>"");

           handleError(handler,XSLTErrorResources.INVALID_ENUM,new Object[]{name, value, enumNamesList.toString() },re); 
           return null;
        }    
  	}
  	
  	return objToReturn;
  }

  
  Object processEXPR(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    try
    {
      XPath expr = handler.createXPath(value, owner);

      return expr;
    }
    catch (TransformerException te)
    {
      org.xml.sax.SAXException se = new org.xml.sax.SAXException(te);
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  Object processNMTOKEN(StylesheetHandler handler, String uri, String name,
                        String rawName, String value, ElemTemplateElement owner)
             throws org.xml.sax.SAXException
  {
  	
  	if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	
		  
		  if ((avt.isSimple()) && (!XMLChar.isValidNmtoken(value))) {
            handleError(handler,XSLTErrorResources.INVALID_NMTOKEN, new Object[] {name,value},null);
            return null;
		  }	
	      return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }  		
  	} else {
  		if (!XMLChar.isValidNmtoken(value)) {
            handleError(handler,XSLTErrorResources.INVALID_NMTOKEN, new Object[] {name,value},null);
            return null;
  		}
  	}	  			
    return value;
  }

  
  Object processPATTERN(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    try
    {
      XPath pattern = handler.createMatchPatternXPath(value, owner);

      return pattern;
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  Object processNUMBER(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {


	if (getSupportsAVT()) 
	{
		Double val;
		AVT avt = null;
	    try
	    {
	      avt = new AVT(handler, uri, name, rawName, value, owner);
	      
	      
	      if (avt.isSimple()) 
	      {
	      	val = Double.valueOf(value);
	      }
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    } 
	    catch (NumberFormatException nfe)
	    {
	     	handleError(handler,XSLTErrorResources.INVALID_NUMBER, new Object[] {name, value}, nfe);
            return null;
	    }
	    return avt;
	
	} 
	else
    {
	    try
	    {
	      return Double.valueOf(value);
	    }
	    catch (NumberFormatException nfe)
	    {
            handleError(handler,XSLTErrorResources.INVALID_NUMBER, new Object[] {name, value}, nfe);
            return null;
	    }
    }    
  }

  
  Object processQNAME(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

     try 
        {	
   	      QName qname = new QName(value, handler, true);
          return qname;
        }
        catch (IllegalArgumentException ie)
        {
            
            handleError(handler,XSLTErrorResources.INVALID_QNAME, new Object[] {name, value},ie);
            return null;
        }
        catch (RuntimeException re) {
            
            handleError(handler,XSLTErrorResources.INVALID_QNAME, new Object[] {name, value},re);
            return null;
        }
  	}
 

  
  Object processAVT_QNAME(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

       AVT avt = null;
       try
       {
          avt = new AVT(handler, uri, name, rawName, value, owner);
    
          
          if (avt.isSimple())
          {
             int indexOfNSSep = value.indexOf(':');

             if (indexOfNSSep >= 0) 
             {   
                  String prefix = value.substring(0, indexOfNSSep);
                  if (!XMLChar.isValidNCName(prefix))
                  {
                     handleError(handler,XSLTErrorResources.INVALID_QNAME,new Object[]{name,value },null);
                     return null;
                  }
             }
                 
             String localName =  (indexOfNSSep < 0)
                 ? value : value.substring(indexOfNSSep + 1); 
             
             if ((localName == null) || (localName.length() == 0) ||
                 (!XMLChar.isValidNCName(localName)))
             {    
                     handleError(handler,XSLTErrorResources.INVALID_QNAME,new Object[]{name,value },null );
                     return null;
             }
          }  
        }
        catch (TransformerException te)
        {
           
          throw new org.xml.sax.SAXException(te);
        } 
    
    return avt;
 }

  
  Object processNCNAME(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {
    
    if (getSupportsAVT()) 
    {
        AVT avt = null;
        try
        {
          avt = new AVT(handler, uri, name, rawName, value, owner);
    
          
          if ((avt.isSimple()) &&  (!XMLChar.isValidNCName(value))) 
          {
             handleError(handler,XSLTErrorResources.INVALID_NCNAME,new Object[] {name,value},null);
             return null;
          }      
          return avt;
        }
        catch (TransformerException te)
        {
           
          throw new org.xml.sax.SAXException(te);
        } 
        
    } else {
        if (!XMLChar.isValidNCName(value)) 
        {
            handleError(handler,XSLTErrorResources.INVALID_NCNAME,new Object[] {name,value},null);
            return null;
        }
        return value;
    }
 }

  
  Vector processQNAMES(
          StylesheetHandler handler, String uri, String name, String rawName, String value)
            throws org.xml.sax.SAXException
  {

    StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
    int nQNames = tokenizer.countTokens();
    Vector qnames = new Vector(nQNames);

    for (int i = 0; i < nQNames; i++)
    {
      
      qnames.addElement(new QName(tokenizer.nextToken(), handler));
    }

    return qnames;
  }

 
  final Vector processQNAMESRNU(StylesheetHandler handler, String uri,
    String name, String rawName, String value)
    throws org.xml.sax.SAXException
  {

    StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
    int nQNames = tokenizer.countTokens();
    Vector qnames = new Vector(nQNames);

    String defaultURI = handler.getNamespaceForPrefix("""");
    for (int i = 0; i < nQNames; i++)
    {
      String tok = tokenizer.nextToken();
      if (tok.indexOf(':') == -1) {
        qnames.addElement(new QName(defaultURI,tok));
      } else {
        qnames.addElement(new QName(tok, handler));
      }
    }
    return qnames;
  }

  
  Vector processSIMPLEPATTERNLIST(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    try
    {
      StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
      int nPatterns = tokenizer.countTokens();
      Vector patterns = new Vector(nPatterns);

      for (int i = 0; i < nPatterns; i++)
      {
        XPath pattern =
          handler.createMatchPatternXPath(tokenizer.nextToken(), owner);

        patterns.addElement(pattern);
      }

      return patterns;
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  StringVector processSTRINGLIST(StylesheetHandler handler, String uri,
                                 String name, String rawName, String value)
  {

    StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
    int nStrings = tokenizer.countTokens();
    StringVector strings = new StringVector(nStrings);

    for (int i = 0; i < nStrings; i++)
    {
      strings.addElement(tokenizer.nextToken());
    }

    return strings;
  }

  
  StringVector processPREFIX_URLLIST(
          StylesheetHandler handler, String uri, String name, String rawName, String value)
            throws org.xml.sax.SAXException
  {

    StringTokenizer tokenizer = new StringTokenizer(value, "" 	

"");
    int nStrings = tokenizer.countTokens();
    StringVector strings = new StringVector(nStrings);

    for (int i = 0; i < nStrings; i++)
    {
      String prefix = tokenizer.nextToken();
      String url = handler.getNamespaceForPrefix(prefix);

      strings.addElement(url);
    }

    return strings;
  }

  
  Object processURL(
          StylesheetHandler handler, String uri, String name, String rawName, String value, ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    if (getSupportsAVT()) {
	    try
	    {
	      AVT avt = new AVT(handler, uri, name, rawName, value, owner);
	
		  
		 
			   
			    
			    
		  
	      return avt;
	    }
	    catch (TransformerException te)
	    {
	      throw new org.xml.sax.SAXException(te);
	    }  		
     } else {
    
    
    
     	
	    return value;
    }
  }

  
  private Boolean processYESNO(
          StylesheetHandler handler, String uri, String name, String rawName, String value)
            throws org.xml.sax.SAXException
  {

    
    if (!(value.equals(""yes"") || value.equals(""no"")))
    {
      handleError(handler, XSLTErrorResources.INVALID_BOOLEAN, new Object[] {name,value}, null);
      return null;
   }
 
     return new Boolean(value.equals(""yes"") ? true : false);
  }

  
  Object processValue(
          StylesheetHandler handler, String uri, String name, String rawName, String value,
          ElemTemplateElement owner)
            throws org.xml.sax.SAXException
  {

    int type = getType();
    Object processedValue = null;

    switch (type)
    {
    case T_AVT :
      processedValue = processAVT(handler, uri, name, rawName, value, owner);
      break;
    case T_CDATA :
      processedValue = processCDATA(handler, uri, name, rawName, value, owner);
      break;
    case T_CHAR :
      processedValue = processCHAR(handler, uri, name, rawName, value, owner);
      break;
    case T_ENUM :
      processedValue = processENUM(handler, uri, name, rawName, value, owner);
      break;
    case T_EXPR :
      processedValue = processEXPR(handler, uri, name, rawName, value, owner);
      break;
    case T_NMTOKEN :
      processedValue = processNMTOKEN(handler, uri, name, rawName, value, owner);
      break;
    case T_PATTERN :
      processedValue = processPATTERN(handler, uri, name, rawName, value, owner);
      break;
    case T_NUMBER :
      processedValue = processNUMBER(handler, uri, name, rawName, value, owner);
      break;
    case T_QNAME :
      processedValue = processQNAME(handler, uri, name, rawName, value, owner);
      break;
    case T_QNAMES :
      processedValue = processQNAMES(handler, uri, name, rawName, value);
      break;
	case T_QNAMES_RESOLVE_NULL:
      processedValue = processQNAMESRNU(handler, uri, name, rawName, value);
      break;
    case T_SIMPLEPATTERNLIST :
      processedValue = processSIMPLEPATTERNLIST(handler, uri, name, rawName,
                                                value, owner);
      break;
    case T_URL :
      processedValue = processURL(handler, uri, name, rawName, value, owner);
      break;
    case T_YESNO :
      processedValue = processYESNO(handler, uri, name, rawName, value);
      break;
    case T_STRINGLIST :
      processedValue = processSTRINGLIST(handler, uri, name, rawName, value);
      break;
    case T_PREFIX_URLLIST :
      processedValue = processPREFIX_URLLIST(handler, uri, name, rawName,
                                             value);
      break;
    case T_ENUM_OR_PQNAME :
    	processedValue = processENUM_OR_PQNAME(handler, uri, name, rawName, value, owner);
    	break;
    case T_NCNAME :
        processedValue = processNCNAME(handler, uri, name, rawName, value, owner);
        break;
    case T_AVT_QNAME :
        processedValue = processAVT_QNAME(handler, uri, name, rawName, value, owner);
        break;
    default :
    }

    return processedValue;
  }

  
  void setDefAttrValue(StylesheetHandler handler, ElemTemplateElement elem)
          throws org.xml.sax.SAXException
  {
    setAttrValue(handler, this.getNamespace(), this.getName(),
                 this.getName(), this.getDefault(), elem);
  }

  
  private Class getPrimativeClass(Object obj)
  {

    if (obj instanceof XPath)
      return XPath.class;

    Class cl = obj.getClass();

    if (cl == Double.class)
    {
      cl = double.class;
    }

    if (cl == Float.class)
    {
      cl = float.class;
    }
    else if (cl == Boolean.class)
    {
      cl = boolean.class;
    }
    else if (cl == Byte.class)
    {
      cl = byte.class;
    }
    else if (cl == Character.class)
    {
      cl = char.class;
    }
    else if (cl == Short.class)
    {
      cl = short.class;
    }
    else if (cl == Integer.class)
    {
      cl = int.class;
    }
    else if (cl == Long.class)
    {
      cl = long.class;
    }

    return cl;
  }
  
  
  private StringBuffer getListOfEnums() 
  {
     StringBuffer enumNamesList = new StringBuffer();            
     String [] enumValues = this.getEnumNames();

     for (int i = 0; i < enumValues.length; i++)
     {
        if (i > 0)
        {
           enumNamesList.append(' ');
        }
        enumNamesList.append(enumValues[i]);
    }        
    return enumNamesList;
  }

  
  boolean setAttrValue(
          StylesheetHandler handler, String attrUri, String attrLocalName, 
          String attrRawName, String attrValue, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {
    if(attrRawName.equals(""xmlns"") || attrRawName.startsWith(""xmlns:""))
      return true;
      
    String setterString = getSetterMethodName();

    
    
    if (null != setterString)
    {
      try
      {
        Method meth;
        Object[] args;

        if(setterString.equals(S_FOREIGNATTR_SETTER))
        {
          
          if( attrUri==null) attrUri="""";
          
          Class sclass = attrUri.getClass();
          Class[] argTypes = new Class[]{ sclass, sclass,
                                      sclass, sclass };
  
          meth = elem.getClass().getMethod(setterString, argTypes);
  
          args = new Object[]{ attrUri, attrLocalName,
                                      attrRawName, attrValue };
        }
        else
        {
          Object value = processValue(handler, attrUri, attrLocalName,
                                      attrRawName, attrValue, elem);
          
          
          if (null == value) return false;
                                      
          
          Class[] argTypes = new Class[]{ getPrimativeClass(value) };
  
          try
          {
            meth = elem.getClass().getMethod(setterString, argTypes);
          }
          catch (NoSuchMethodException nsme)
          {
            Class cl = ((Object) value).getClass();
  
            
            argTypes[0] = cl;
            meth = elem.getClass().getMethod(setterString, argTypes);
          }
  
          args = new Object[]{ value };
        }

        meth.invoke(elem, args);
      }
      catch (NoSuchMethodException nsme)
      {
        if (!setterString.equals(S_FOREIGNATTR_SETTER)) 
        {
          handler.error(XSLTErrorResources.ER_FAILED_CALLING_METHOD, new Object[]{setterString}, nsme);
          return false;
        }
      }
      catch (IllegalAccessException iae)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CALLING_METHOD, new Object[]{setterString}, iae);
        return false;
      }
      catch (InvocationTargetException nsme)
      {
        handleError(handler, XSLTErrorResources.WG_ILLEGAL_ATTRIBUTE_VALUE,
            new Object[]{ Constants.ATTRNAME_NAME, getName()}, nsme);
        return false;
      }
    }
    
    return true;
  }
  
  private void handleError(StylesheetHandler handler, int msg, Object [] args, Exception exc) throws org.xml.sax.SAXException
  {
    switch (getErrorType()) 
    {
        case (FATAL):
        case (ERROR):
                handler.error(msg, args, exc);          
                break;
        case (WARNING):
                handler.warn(msg, args);       
        default: break;
    }
  }
}
"
org.apache.xalan.xsltc.compiler.LiteralExpr,8,3,0,19,18,4,6,13,5,0.571428571,75,1.0,0,0.922077922,0.325,2,8,8.125,1,0.75,0,"


package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class LiteralExpr extends Expression {
    private final String _value;
    private final String _namespace;

    
    public LiteralExpr(String value) {
	_value = value;
	_namespace = null;
    }

    
    public LiteralExpr(String value, String namespace) {
	_value = value;
	_namespace = namespace.equals(Constants.EMPTYSTRING) ? null : namespace;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _type = Type.String;
    }

    public String toString() {
	return ""literal-expr("" + _value + ')';
    }

    protected boolean contextDependent() {
	return false;
    }

    protected String getValue() {
	return _value;
    }

    protected String getNamespace() {
	return _namespace;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }
}
"
org.apache.xalan.xsltc.compiler.Text,10,3,0,21,32,0,4,18,7,0.583333333,262,1.0,0,0.875,0.266666667,2,6,24.8,10,2.1,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class Text extends Instruction {

    private String _text;
    private boolean _escaping = true;
    private boolean _ignore = false;
    private boolean _textElement = false;

    
    public Text() {
	_textElement = true;
    }

    
    public Text(String text) {
	_text = text;
    }

    
    protected String getText() {
	return _text;
    }

    
    protected void setText(String text) {
	if (_text == null)
	    _text = text;
	else
	    _text = _text + text;
    }

    public void display(int indent) {
	indent(indent);
	Util.println(""Text"");
	indent(indent + IndentIncrement);
	Util.println(_text);
    }
		
    public void parseContents(Parser parser) {
        final String str = getAttribute(""disable-output-escaping"");
	if ((str != null) && (str.equals(""yes""))) _escaping = false;

	parseChildren(parser);

	if (_text == null) {
	    if (_textElement) {
		_text = EMPTYSTRING;
	    }
	    else {
		_ignore = true;
	    }
	}
	else if (_textElement) {
	    if (_text.length() == 0) _ignore = true;
	}
	else if (getParent() instanceof LiteralElement) {
	    LiteralElement element = (LiteralElement)getParent();
	    String space = element.getAttribute(""xml:space"");
	    if ((space == null) || (!space.equals(""preserve"")))
		if (_text.trim().length() == 0) _ignore = true;
	}
	else {
	    if (_text.trim().length() == 0) _ignore = true;
	}
    }

    public void ignore() {
	_ignore = true;
    }

    public boolean isTextElement() {
	return _textElement;
    }

    protected boolean contextDependent() {
	return false;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (!_ignore) {
	    
	    final int esc = cpg.addInterfaceMethodref(OUTPUT_HANDLER,
						      ""setEscaping"", ""(Z)Z"");
	    if (!_escaping) {
		il.append(methodGen.loadHandler());
		il.append(new PUSH(cpg, false));
		il.append(new INVOKEINTERFACE(esc, 2));
	    }

	    final int characters = cpg.addInterfaceMethodref(OUTPUT_HANDLER,
							     ""characters"",
							     ""("" + STRING_SIG + "")V"");
	    il.append(methodGen.loadHandler());
	    il.append(new PUSH(cpg, _text));
	    il.append(new INVOKEINTERFACE(characters, 2));

	    
	    
	    if (!_escaping) {
		il.append(methodGen.loadHandler());
		il.append(SWAP);
		il.append(new INVOKEINTERFACE(esc, 2));
		il.append(POP);
	    }
	}
	translateContents(classGen, methodGen);
    }
}
"
org.apache.xml.utils.BoolStack,13,1,0,6,16,0,6,0,12,0.361111111,160,1.0,0,0.0,0.41025641,0,0,11.07692308,2,1.2308,0,"
package org.apache.xml.utils;

import java.util.EmptyStackException;


public final class BoolStack implements Cloneable
{

  
  private boolean m_values[];

  
  private int m_allocatedSize;

  
  private int m_index;

  
  public BoolStack()
  {
    this(32);
  }

  
  public BoolStack(int size)
  {

    m_allocatedSize = size;
    m_values = new boolean[size];
    m_index = -1;
  }

  
  public final int size()
  {
    return m_index + 1;
  }

  
  public final boolean push(boolean val)
  {

    if (m_index == m_allocatedSize - 1)
      grow();

    return (m_values[++m_index] = val);
  }

  
  public final boolean pop()
  {
    return m_values[m_index--];
  }

  
  public final boolean popAndTop()
  {

    m_index--;

    return (m_index >= 0) ? m_values[m_index] : false;
  }

  
  public final void setTop(boolean b)
  {
    m_values[m_index] = b;
  }

  
  public final boolean peek()
  {
    return m_values[m_index];
  }

  
  public final boolean peekOrFalse()
  {
    return (m_index > -1) ? m_values[m_index] : false;
  }

  
  public final boolean peekOrTrue()
  {
    return (m_index > -1) ? m_values[m_index] : true;
  }

  
  public boolean isEmpty()
  {
    return (m_index == -1);
  }

  
  private void grow()
  {

    m_allocatedSize *= 2;

    boolean newVector[] = new boolean[m_allocatedSize];

    System.arraycopy(m_values, 0, newVector, 0, m_index + 1);

    m_values = newVector;
  }
  
  public Object clone() 
    throws CloneNotSupportedException
  {
    return super.clone();
  }

}
"
org.apache.xpath.functions.FuncDoclocation,2,5,0,5,9,1,0,5,2,2.0,43,0.0,0,0.982142857,0.75,2,7,20.5,1,0.5,0,"
package org.apache.xpath.functions;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncDoclocation extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int whereNode = getArg0AsNode(xctxt);
    String fileLocation = null;

    if (DTM.NULL != whereNode)
    {
      DTM dtm = xctxt.getDTM(whereNode);
      
      
      if (DTM.DOCUMENT_FRAGMENT_NODE ==  dtm.getNodeType(whereNode))
      {
        whereNode = dtm.getFirstChild(whereNode);
      }

      if (DTM.NULL != whereNode)
      {        
        fileLocation = dtm.getDocumentBaseURI();


      }
    }

    return new XString((null != fileLocation) ? fileLocation : """");
  }
}
"
org.apache.xalan.processor.ProcessorStripSpace,2,5,0,9,14,1,1,8,1,2.0,50,0.0,0,0.995283019,0.625,2,2,24.0,1,0.5,0,"
package org.apache.xalan.processor;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.WhiteSpaceInfo;
import org.apache.xpath.XPath;

import java.util.Vector;


class ProcessorStripSpace extends ProcessorPreserveSpace
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {
    Stylesheet thisSheet = handler.getStylesheet();
	WhitespaceInfoPaths paths = new WhitespaceInfoPaths(thisSheet);
    setPropertiesFromAttributes(handler, rawName, attributes, paths);

    Vector xpaths = paths.getElements();

    for (int i = 0; i < xpaths.size(); i++)
    {
      WhiteSpaceInfo wsi = new WhiteSpaceInfo((XPath) xpaths.elementAt(i), true, thisSheet);
      wsi.setUid(handler.nextUid());

      thisSheet.setStripSpaces(wsi);
    }
    paths.clearElements();

  }
}
"
org.apache.xalan.xsltc.compiler.XSLTC,53,1,0,24,140,1026,19,9,47,0.89516129,1204,0.870967742,3,0.0,0.106918239,0,0,21.13207547,17,1.6792,0,"

package org.apache.xalan.xsltc.compiler;

import java.io.*;
import java.util.Set;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Properties;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Date;
import java.util.Map;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.jar.*;

import org.xml.sax.*;

import javax.xml.parsers.*;

import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.cmdline.getopt.*;
import org.apache.xalan.xsltc.DOM;
import org.apache.bcel.classfile.JavaClass;

public final class XSLTC {

    
    private Parser _parser;

    
    private XMLReader _reader = null;

    
    private SourceLoader _loader = null;
    
    
    private Stylesheet _stylesheet = null;

    
    
    private int _modeSerial         = 1;
    private int _stylesheetSerial   = 1;
    private int _stepPatternSerial  = 1;
    private int _helperClassSerial  = 0;
    private int _attributeSetSerial = 0;
    
    private int[] _numberFieldIndexes;
    
    
    private int       _nextGType;  
    private Vector    _namesIndex; 
    private Hashtable _elements;   
    private Hashtable _attributes; 

    
    private int       _nextNSType; 
    private Vector    _namespaceIndex; 
    private Hashtable _namespaces; 

    
    public static final int FILE_OUTPUT        = 0;
    public static final int JAR_OUTPUT         = 1;
    public static final int BYTEARRAY_OUTPUT   = 2;
    public static final int CLASSLOADER_OUTPUT = 3;

    
    private boolean _debug = false;      
    private String  _jarFileName = null; 
    private String  _className = null;   
    private String  _packageName = null; 
    private File    _destDir = null;     
    private int     _outputType = FILE_OUTPUT; 

    private Vector  _classes;
    private boolean _callsNodeset = false;
    private boolean _multiDocument = false;
    private boolean _templateInlining = true;

    
    public XSLTC() {
	_parser = new Parser(this);
    }

    
    public void setParser(Parser parser) {
	_parser = parser;
    }

    
    public void setOutputType(int type) {
	_outputType = type;
    }

    
    public Properties getOutputProperties() {
	return _parser.getOutputProperties();
    }

    
    public void init() {
	reset();
	_reader = null;
	_classes = new Vector();
    }
    
    
    private void reset() {
	_nextGType      = DOM.NTYPES;
	_elements       = new Hashtable();
	_attributes     = new Hashtable();
	_namespaces     = new Hashtable();
	_namespaces.put("""",new Integer(_nextNSType));
	_namesIndex     = new Vector(128);
	_namespaceIndex = new Vector(32);
	_parser.init();
	
	_modeSerial         = 1;
	_stylesheetSerial   = 1;
	_stepPatternSerial  = 1;
	_helperClassSerial  = 0;
	_attributeSetSerial = 0;
	_multiDocument      = false;
	_numberFieldIndexes = new int[] {
	    -1, 	
	    -1, 	
	    -1		
	};
    }

        
    public void setSourceLoader(SourceLoader loader) {
	_loader = loader;
    }

    
    public void setTemplateInlining(boolean templateInlining) {
	_templateInlining = templateInlining;
    }

    
    public void setPIParameters(String media, String title, String charset) {
	_parser.setPIParameters(media, title, charset);
    }
    
    
    public boolean compile(URL url) {
	try {
	    
	    final InputStream stream = url.openStream();
	    final InputSource input = new InputSource(stream);
	    input.setSystemId(url.toString());
	    return compile(input, _className);
	}
	catch (IOException e) {
	    _parser.reportError(Constants.FATAL, new ErrorMsg(e.getMessage()));
	    return false;
	}
    }

    
    public boolean compile(URL url, String name) {
	try {
	    
	    final InputStream stream = url.openStream();
	    final InputSource input = new InputSource(stream);
	    input.setSystemId(url.toString());
	    return compile(input, name);
	}
	catch (IOException e) {
	    _parser.reportError(Constants.FATAL, new ErrorMsg(e.getMessage()));
	    return false;
	}
    }

    
    public boolean compile(InputStream stream, String name) {
	final InputSource input = new InputSource(stream);
	input.setSystemId(name); 
	return compile(input, name);
    }

    
    public boolean compile(InputSource input, String name) {
	try {
	    
	    reset();

	    
	    String systemId = null; 
	    if (input != null) {
	        systemId = input.getSystemId();
	    }

	    
	    if (_className == null) {
		if (name != null)
		    setClassName(name);
		else if ((systemId != null) && (!systemId.equals("""")))
		    setClassName(Util.baseName(systemId));
		else
		    setClassName(""GregorSamsa""); 
	    }

	    
	    SyntaxTreeNode element = null;
	    if (_reader == null) {
		element = _parser.parse(input);
	    }
	    else {
		element = _parser.parse(_reader, input);
	    }

	    
	    if ((!_parser.errorsFound()) && (element != null)) {
		
		_stylesheet = _parser.makeStylesheet(element);
		_stylesheet.setSourceLoader(_loader);
		_stylesheet.setSystemId(systemId);
		_stylesheet.setParentStylesheet(null);
		_stylesheet.setTemplateInlining(_templateInlining);
		_parser.setCurrentStylesheet(_stylesheet);

		
		_parser.createAST(_stylesheet);
	    }
	    
	    if ((!_parser.errorsFound()) && (_stylesheet != null)) {
		_stylesheet.setCallsNodeset(_callsNodeset);
		_stylesheet.setMultiDocument(_multiDocument);

		
		synchronized (getClass()) {
		    _stylesheet.translate();
		}
	    }
	}
	catch (Exception e) {
	    if (_debug) e.printStackTrace();
	    _parser.reportError(Constants.FATAL, new ErrorMsg(e.getMessage()));
	}
	catch (Error e) {
	    if (_debug) e.printStackTrace();
	    _parser.reportError(Constants.FATAL, new ErrorMsg(e.getMessage()));
	}
	finally {
	    _reader = null; 
	    return !_parser.errorsFound();
	}
    }

    
    public boolean compile(Vector stylesheets) {
	
	final int count = stylesheets.size();
	
	
	if (count == 0) return true;

	
	
	if (count == 1) {
	    final Object url = stylesheets.firstElement();
	    if (url instanceof URL)
		return compile((URL)url);
	    else
		return false;
	}
	else {
	    
	    final Enumeration urls = stylesheets.elements();
	    while (urls.hasMoreElements()) {
		_className = null; 
		final Object url = urls.nextElement();
		if (url instanceof URL) {
		    if (!compile((URL)url)) return false;
		}
	    }
	}
	return true;
    }

    
    public byte[][] getBytecodes() {
	final int count = _classes.size();
	final byte[][] result = new byte[count][1];
	for (int i = 0; i < count; i++)
	    result[i] = (byte[])_classes.elementAt(i);
	return result;
    }

    
    public byte[][] compile(String name, InputSource input) {
	_outputType = BYTEARRAY_OUTPUT;
	if (compile(input, name))
	    return getBytecodes();
	else
	    return null;
    }

    
    public void setXMLReader(XMLReader reader) {
	_reader = reader;
    }

    
    public Vector getErrors() {
	return _parser.getErrors();
    }

    
    public Vector getWarnings() {
	return _parser.getWarnings();
    }

    
    public void printErrors() {
	_parser.printErrors();
    }

    
    public void printWarnings() {
	_parser.printWarnings();
    }

    
    protected void setMultiDocument(boolean flag) {
	_multiDocument = flag;
    }

    public boolean isMultiDocument() {
	return _multiDocument;
    }

    
    protected void setCallsNodeset(boolean flag) {
	if (flag) setMultiDocument(flag);
	_callsNodeset = flag;
    }

    public boolean callsNodeset() {
	return _callsNodeset;
    }

    
    public void setClassName(String className) {
	final String base  = Util.baseName(className);
	final String noext = Util.noExtName(base); 
	String name  = Util.toJavaName(noext);

	if (_packageName == null)
	    _className = name;
	else
	    _className = _packageName + '.' + name;
    }
    
    
    public String getClassName() {
	return _className;
    }

    
    private String classFileName(final String className) {
	return className.replace('.', File.separatorChar) + "".class"";
    }
    
    
    private File getOutputFile(String className) {
	if (_destDir != null)
	    return new File(_destDir, classFileName(className));
	else
	    return new File(classFileName(className));
    }

    
    public boolean setDestDirectory(String dstDirName) {
	final File dir = new File(dstDirName);
	if (dir.exists() || dir.mkdirs()) {
	    _destDir = dir;
	    return true;
	}
	else {
	    _destDir = null;
	    return false;
	}
    }

    
    public void setPackageName(String packageName) {
	_packageName = packageName;
	if (_className != null) setClassName(_className);
    }

    
    public void setJarFileName(String jarFileName) {
	final String JAR_EXT = "".jar"";
	if (jarFileName.endsWith(JAR_EXT))
	    _jarFileName = jarFileName;
	else
	    _jarFileName = jarFileName + JAR_EXT;
	_outputType = JAR_OUTPUT;
    }

    public String getJarFileName() {
	return _jarFileName;
    }

    
    public void setStylesheet(Stylesheet stylesheet) {
	if (_stylesheet == null) _stylesheet = stylesheet;
    }

    
    public Stylesheet getStylesheet() {
	return _stylesheet;
    }
   
    
    public int registerAttribute(QName name) {
	Integer code = (Integer)_attributes.get(name.toString());
	if (code == null) {
	    code = new Integer(_nextGType++);
	    _attributes.put(name.toString(), code);
	    final String uri = name.getNamespace();
	    final String local = ""@""+name.getLocalPart();
	    if ((uri != null) && (!uri.equals("""")))
		_namesIndex.addElement(uri+"":""+local);
	    else
		_namesIndex.addElement(local);
	    if (name.getLocalPart().equals(""*"")) {
		registerNamespace(name.getNamespace());
	    }
	}
	return code.intValue();
    }

    
    public int registerElement(QName name) {
	
	Integer code = (Integer)_elements.get(name.toString());
	if (code == null) {
	    _elements.put(name.toString(), code = new Integer(_nextGType++));
	    _namesIndex.addElement(name.toString());
	}
	if (name.getLocalPart().equals(""*"")) {
	    registerNamespace(name.getNamespace());
	}
	return code.intValue();
    }

    
    public int registerNamespace(QName name) {
	final SymbolTable stable = _parser.getSymbolTable();
	final String uri = stable.lookupNamespace(name.toString());
	final int code = registerNamespace(uri);
	return code; 
    }

    
    public int registerNamespace(String namespaceURI) {
	Integer code = (Integer)_namespaces.get(namespaceURI);
	if (code == null) {
	    code = new Integer(_nextNSType++);
	    _namespaces.put(namespaceURI,code);
	    _namespaceIndex.addElement(namespaceURI);
	}
	return code.intValue();
    }
    
    public int nextModeSerial() {
	return _modeSerial++;
    }

    public int nextStylesheetSerial() {
	return _stylesheetSerial++;
    }

    public int nextStepPatternSerial() {
	return _stepPatternSerial++;
    }

    public int[] getNumberFieldIndexes() {
	return _numberFieldIndexes;
    }

    public int nextHelperClassSerial() {
	return _helperClassSerial++;
    }
    
    public int nextAttributeSetSerial() {
	return _attributeSetSerial++;
    }

    public Vector getNamesIndex() {
	return _namesIndex;
    }

    public Vector getNamespaceIndex() {
	return _namespaceIndex;
    }
    
    
    public String getHelperClassName() {
	return getClassName() + '$' + _helperClassSerial++;
    }
   
    public void dumpClass(JavaClass clazz) {
	try {
	    switch (_outputType) {
	    case FILE_OUTPUT:
		clazz.dump(
		    new BufferedOutputStream(
			new FileOutputStream(
			    getOutputFile(clazz.getClassName()))));
		break;
	    case JAR_OUTPUT:
		_classes.addElement(clazz);	 
		break;
	    case BYTEARRAY_OUTPUT:
	    case CLASSLOADER_OUTPUT:
		ByteArrayOutputStream out = new ByteArrayOutputStream(2048);
		clazz.dump(out);
		_classes.addElement(out.toByteArray());
		break;
	    }
	}
	catch (Exception e) {
	    e.printStackTrace();
	}
    }

    
    private String entryName(File f) throws IOException {
	return f.getName().replace(File.separatorChar, '/');
    }
    
    
    public void outputToJar() throws IOException {
	
	final Manifest manifest = new Manifest();
	final java.util.jar.Attributes atrs = manifest.getMainAttributes();
	atrs.put(java.util.jar.Attributes.Name.MANIFEST_VERSION,""1.2"");

	final Map map = manifest.getEntries();
	
	Enumeration classes = _classes.elements();
	final String now = (new Date()).toString();
	final java.util.jar.Attributes.Name dateAttr = 
	    new java.util.jar.Attributes.Name(""Date"");
	while (classes.hasMoreElements()) {
	    final JavaClass clazz = (JavaClass)classes.nextElement();
	    final String className = clazz.getClassName().replace('.','/');
	    final java.util.jar.Attributes attr = new java.util.jar.Attributes();
	    attr.put(dateAttr, now);
	    map.put(className+"".class"", attr);
	}

	final File jarFile = new File(_destDir, _jarFileName);
	final JarOutputStream jos =
	    new JarOutputStream(new FileOutputStream(jarFile), manifest);
	classes = _classes.elements();
	while (classes.hasMoreElements()) {
	    final JavaClass clazz = (JavaClass)classes.nextElement();
	    final String className = clazz.getClassName().replace('.','/');
	    jos.putNextEntry(new JarEntry(className+"".class""));
	    final ByteArrayOutputStream out = new ByteArrayOutputStream(2048);
	    clazz.dump(out); 
	    out.writeTo(jos);
	}
	jos.close();
    }

    
    public void setDebug(boolean debug) {
	_debug = debug;
    }

    
    public boolean debug() {
	return _debug;
    }

}
"
org.apache.xml.utils.synthetic.reflection.Constructor,5,2,0,3,13,4,2,3,5,1.0,61,1.0,3,0.904761905,0.5,1,1,10.0,1,0.4,0,"
package org.apache.xml.utils.synthetic.reflection;

import java.lang.reflect.InvocationTargetException;

import org.apache.xml.utils.synthetic.SynthesisException;


public class Constructor extends EntryPoint implements Member
{

  
  private org.apache.xml.utils.synthetic.Class declaringclass = null;

  
  private java.lang.reflect.Constructor realconstructor = null;

  
  private org.apache.xml.utils.synthetic.Class[] parametertypes;

  
  private String[] parameternames;

  
  private org.apache.xml.utils.synthetic.Class[] exceptiontypes;

  
  private int modifiers;

  
  public Constructor(org.apache.xml.utils.synthetic.Class declaringclass)
  {
    super(declaringclass);
  }

  
  public Constructor(java.lang.reflect.Constructor ctor,
                     org.apache.xml.utils.synthetic.Class declaringclass)
  {
    super(ctor, declaringclass);
  }

  
  public Constructor(java.lang.reflect.Constructor realconstructor)
  {
    super(realconstructor);
  }

  
  public int hashCode()
  {
    return getDeclaringClass().getName().hashCode();
  }

  
  public Object newInstance(Object initargs[])
          throws InstantiationException, IllegalAccessException,
                 IllegalArgumentException,
                 java.lang.reflect.InvocationTargetException
  {

    if (realep != null)
      return ((java.lang.reflect.Constructor) realep).newInstance(initargs);
    else
      throw new InstantiationException(
        ""Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation"");
  }
}
"
org.apache.xalan.xsltc.trax.DOM2SAX,25,1,0,3,70,254,3,0,20,0.902777778,559,1.0,0,0.0,0.152727273,0,0,21.12,3,1.08,0,"


package org.apache.xalan.xsltc.trax;

import java.util.Stack;
import java.util.Vector;
import java.util.Hashtable;

import org.xml.sax.XMLReader;
import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.Locator;
import org.xml.sax.ErrorHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.AttributesImpl;
import org.xml.sax.AttributeList;
import org.xml.sax.helpers.AttributeListImpl;

import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import java.io.IOException;
import org.w3c.dom.Entity;
import org.w3c.dom.Notation;

public class DOM2SAX implements XMLReader, Locator {

    private final static String EMPTYSTRING = """";
    private static final String XMLNS_PREFIX = ""xmlns"";

    private Node _dom = null;
    private ContentHandler _sax = null;
    private LexicalHandler _lex = null;
    private Hashtable _nsPrefixes = new Hashtable();

    public DOM2SAX(Node root) {
	_dom = root;
    }

    public ContentHandler getContentHandler() { 
	return _sax;
    }

    public void setContentHandler(ContentHandler handler) throws 
	NullPointerException 
    {
	_sax = handler;
	if (handler instanceof LexicalHandler) {
	    _lex = (LexicalHandler) handler;
	}
    }

    
    private boolean startPrefixMapping(String prefix, String uri) 
	throws SAXException 
    {
	boolean pushed = true;
	Stack uriStack = (Stack) _nsPrefixes.get(prefix);

	if (uriStack != null) {
	    if (uriStack.isEmpty()) {
		_sax.startPrefixMapping(prefix, uri);
		uriStack.push(uri);
	    }
	    else {
		final String lastUri = (String) uriStack.peek();
		if (!lastUri.equals(uri)) {
		    _sax.startPrefixMapping(prefix, uri);
		    uriStack.push(uri);
		}
		else {
		    pushed = false;
		}
	    }	
	}
	else {
	    _sax.startPrefixMapping(prefix, uri);
	    _nsPrefixes.put(prefix, uriStack = new Stack());
	    uriStack.push(uri);
	}
	return pushed;
    }

    
    private void endPrefixMapping(String prefix) 
	throws SAXException
    {
	final Stack uriStack = (Stack) _nsPrefixes.get(prefix);

	if (uriStack != null) {
	    _sax.endPrefixMapping(prefix);
	    uriStack.pop();
	}
    }

    
    private static String getLocalName(Node node) {
	final String localName = node.getLocalName();

	if (localName == null) {
	    final String qname = node.getNodeName();
	    final int col = qname.lastIndexOf(':');
	    return (col > 0) ? qname.substring(col + 1) : qname;
	}
	return localName;
    }

    public void parse(InputSource unused) throws IOException, SAXException {
        parse(_dom);
    }

    public void parse() throws IOException, SAXException {
	if (_dom != null) {
	    boolean isIncomplete = 
		(_dom.getNodeType() != org.w3c.dom.Node.DOCUMENT_NODE);

	    if (isIncomplete) {
		_sax.startDocument();
		parse(_dom);
		_sax.endDocument();
	    }
	    else {
		parse(_dom);
	    }
	}
    }

    
    private void parse(Node node) throws IOException, SAXException {
        Node first = null;
 	if (node == null) return;

        switch (node.getNodeType()) {
	case Node.ATTRIBUTE_NODE:         
	case Node.DOCUMENT_FRAGMENT_NODE:
	case Node.DOCUMENT_TYPE_NODE :
	case Node.ENTITY_NODE :
	case Node.ENTITY_REFERENCE_NODE:
	case Node.NOTATION_NODE :
	    
	    break;
	case Node.CDATA_SECTION_NODE:
	    final String cdata = node.getNodeValue();
	    if (_lex != null) {
		_lex.startCDATA();
	        _sax.characters(cdata.toCharArray(), 0, cdata.length());
		_lex.endCDATA();
 	    } 
	    else {
		
		
	        _sax.characters(cdata.toCharArray(), 0, cdata.length());
	    }	
	    break;

	case Node.COMMENT_NODE:           
	    if (_lex != null) {
		final String value = node.getNodeValue();
		_lex.comment(value.toCharArray(), 0, value.length());
	    }
	    break;
	case Node.DOCUMENT_NODE:
	    _sax.setDocumentLocator(this);

	    _sax.startDocument();
	    Node next = node.getFirstChild();
	    while (next != null) {
		parse(next);
		next = next.getNextSibling();
	    }
	    _sax.endDocument();
	    break;

	case Node.ELEMENT_NODE:
	    String prefix;
	    Vector pushedPrefixes = new Vector();
	    final AttributesImpl attrs = new AttributesImpl();
	    final NamedNodeMap map = node.getAttributes();
	    final int length = map.getLength();

	    
	    for (int i = 0; i < length; i++) {
		final Node attr = map.item(i);
		final String qnameAttr = attr.getNodeName();

		
		if (qnameAttr.startsWith(XMLNS_PREFIX)) {
		    final String uriAttr = attr.getNodeValue();
		    final int colon = qnameAttr.lastIndexOf(':');
		    prefix = (colon > 0) ? qnameAttr.substring(colon + 1) : EMPTYSTRING;
		    if (startPrefixMapping(prefix, uriAttr)) {
			pushedPrefixes.addElement(prefix);
		    }
		}
	    }

	    
	    for (int i = 0; i < length; i++) {
		final Node attr = map.item(i);
		final String qnameAttr = attr.getNodeName();

		
		if (!qnameAttr.startsWith(XMLNS_PREFIX)) {
		    final String uriAttr = attr.getNamespaceURI();
		    final String localNameAttr = getLocalName(attr);

		    
		    if (uriAttr != null) {	
			final int colon = qnameAttr.lastIndexOf(':');
			prefix = (colon > 0) ? qnameAttr.substring(0, colon) : EMPTYSTRING;
			if (startPrefixMapping(prefix, uriAttr)) {
			    pushedPrefixes.addElement(prefix);
			}
		    }

		    
		    attrs.addAttribute(attr.getNamespaceURI(), getLocalName(attr), 
			qnameAttr, ""CDATA"", attr.getNodeValue());
		}
	    }

	    
	    final String qname = node.getNodeName();
	    final String uri = node.getNamespaceURI();
	    final String localName = getLocalName(node);

	    
	    if (uri != null) {	
		final int colon = qname.lastIndexOf(':');
		prefix = (colon > 0) ? qname.substring(0, colon) : EMPTYSTRING;
		if (startPrefixMapping(prefix, uri)) {
		    pushedPrefixes.addElement(prefix);
		}
	    }

	    
	    _sax.startElement(uri, localName, qname, attrs);

	    
	    next = node.getFirstChild();
	    while (next != null) {
		parse(next);
		next = next.getNextSibling();
	    }

	    
	    _sax.endElement(uri, localName, qname);

	    
	    final int nPushedPrefixes = pushedPrefixes.size();
	    for (int i = 0; i < nPushedPrefixes; i++) {
		endPrefixMapping((String) pushedPrefixes.elementAt(i));
	    }
	    break;

	case Node.PROCESSING_INSTRUCTION_NODE:
	    _sax.processingInstruction(node.getNodeName(),
				       node.getNodeValue());
	    break;

	case Node.TEXT_NODE:
	    final String data = node.getNodeValue();
	    _sax.characters(data.toCharArray(), 0, data.length());
	    break;
	}
    }

    
    public DTDHandler getDTDHandler() { 
	return null;
    }

    
    public ErrorHandler getErrorHandler() {
	return null;
    }

    
    public boolean getFeature(String name) throws SAXNotRecognizedException,
	SAXNotSupportedException
    {
	return false;
    }

    
    public void setFeature(String name, boolean value) throws 
	SAXNotRecognizedException, SAXNotSupportedException 
    {
    }

    
    public void parse(String sysId) throws IOException, SAXException {
	throw new IOException(""This method is not yet implemented."");
    }

    
    public void setDTDHandler(DTDHandler handler) throws NullPointerException {
    }

    
    public void setEntityResolver(EntityResolver resolver) throws 
	NullPointerException 
    {
    }

    
    public EntityResolver getEntityResolver() {
	return null;
    }

    
    public void setErrorHandler(ErrorHandler handler) throws 
	NullPointerException
    {
    }

    
    public void setProperty(String name, Object value) throws
	SAXNotRecognizedException, SAXNotSupportedException {
    }

    
    public Object getProperty(String name) throws SAXNotRecognizedException,
	SAXNotSupportedException
    {
	return null;
    }

    
    public int getColumnNumber() { 
	return 0; 
    }
    
    
    public int getLineNumber() { 
	return 0; 
    }

    
    public String getPublicId() { 
	return null; 
    }

    
    public String getSystemId() { 
	return null; 
    }

    
    private String getNodeTypeFromCode(short code) {
	String retval = null;
	switch (code) {
	case Node.ATTRIBUTE_NODE : 
	    retval = ""ATTRIBUTE_NODE""; break; 
	case Node.CDATA_SECTION_NODE :
	    retval = ""CDATA_SECTION_NODE""; break; 
	case Node.COMMENT_NODE :
	    retval = ""COMMENT_NODE""; break; 
	case Node.DOCUMENT_FRAGMENT_NODE :
	    retval = ""DOCUMENT_FRAGMENT_NODE""; break; 
	case Node.DOCUMENT_NODE :
	    retval = ""DOCUMENT_NODE""; break; 
	case Node.DOCUMENT_TYPE_NODE :
	    retval = ""DOCUMENT_TYPE_NODE""; break; 
	case Node.ELEMENT_NODE :
	    retval = ""ELEMENT_NODE""; break; 
	case Node.ENTITY_NODE :
	    retval = ""ENTITY_NODE""; break; 
	case Node.ENTITY_REFERENCE_NODE :
	    retval = ""ENTITY_REFERENCE_NODE""; break; 
	case Node.NOTATION_NODE :
	    retval = ""NOTATION_NODE""; break; 
	case Node.PROCESSING_INSTRUCTION_NODE :
	    retval = ""PROCESSING_INSTRUCTION_NODE""; break; 
	case Node.TEXT_NODE:
	    retval = ""TEXT_NODE""; break; 
        }
	return retval;
    }
}
"
org.apache.xalan.xsltc.compiler.RoundCall,2,4,0,18,13,1,0,18,2,2.0,61,0.0,0,0.989690722,0.6,2,4,29.5,1,0.5,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class RoundCall extends FunctionCall {

    public RoundCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	argument().translate(classGen, methodGen);
	il.append(DUP2);

	
	il.append(new INVOKESTATIC(cpg.addMethodref(""java.lang.Double"",
						    ""isNaN"", ""(D)Z"")));
	final BranchHandle skip = il.append(new IFNE(null));
	il.append(new INVOKESTATIC(cpg.addMethodref(MATH_CLASS,
						    ""round"", ""(D)J"")));
	il.append(L2D);
	skip.setTarget(il.append(NOP));
    }
}
"
org.apache.xalan.transformer.ResultNameSpace,1,1,0,0,2,0,0,0,1,2.0,16,0.0,1,0.0,1.0,0,0,12.0,0,0.0,0,"
package org.apache.xalan.transformer;


public class ResultNameSpace
{

  
  public ResultNameSpace m_next = null;

  
  public String m_prefix;

  
  public String m_uri;  

  
  public ResultNameSpace(String prefix, String uri)
  {
    m_prefix = prefix;
    m_uri = uri;
  }
}
"
org.apache.xpath.operations.Gte,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class Gte extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.greaterThanOrEqual(right)
           ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xml.dtm.ref.DTMNodeProxy,120,1,0,10,148,5942,5,5,118,0.798319328,1019,0.0,1,0.0,0.185807656,0,0,7.466666667,4,1.1833,0,"
package org.apache.xml.dtm.ref;

import org.w3c.dom.*;
import org.apache.xml.dtm.*;
import org.apache.xml.dtm.Axis;


public class DTMNodeProxy
  implements Node, Document, Text, Element, Attr,
                   ProcessingInstruction, Comment, DocumentFragment
{

  
  public DTM dtm;

  
  int node;
        
  
  static final DOMImplementation implementation=new DTMNodeProxyImplementation();

  
  DTMNodeProxy(DTM dtm, int node)
  {
    this.dtm = dtm;
    this.node = node;
  }

  
  public final DTM getDTM()
  {
    return dtm;
  }

  
  public final int getDTMNodeNumber()
  {
    return node;
  }

  
  public final boolean equals(Node node)
  {

    try
    {
      DTMNodeProxy dtmp = (DTMNodeProxy) node;

      
      
      return (dtmp.node == this.node) && (dtmp.dtm == this.dtm);
    }
    catch (ClassCastException cce)
    {
      return false;
    }
  }

  
  public final boolean equals(Object node)
  {

    try
    {

      
      
      
      return equals((Node) node);
    }
    catch (ClassCastException cce)
    {
      return false;
    }
  }

  
  public final boolean sameNodeAs(Node other)
  {

    if (!(other instanceof DTMNodeProxy))
      return false;

    DTMNodeProxy that = (DTMNodeProxy) other;

    return this.dtm == that.dtm && this.node == that.node;
  }

  
  public final String getNodeName()
  {
    return dtm.getNodeName(node);
  }

  
  public final String getTarget()
  {
    return dtm.getNodeName(node);
  }  

  
  public final String getLocalName()
  {
    return dtm.getLocalName(node);
  }

  
  public final String getPrefix()
  {
    return dtm.getPrefix(node);
  }

  
  public final void setPrefix(String prefix) throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final String getNamespaceURI()
  {
    return dtm.getNamespaceURI(node);
  }

  
  public final boolean supports(String feature, String version)
  {
    return implementation.hasFeature(feature,version);
    
  }

  
  public final boolean isSupported(String feature, String version)
  {
    return implementation.hasFeature(feature,version);
    
  }

  
  public final String getNodeValue() throws DOMException
  {
    return dtm.getNodeValue(node);
  }

  
  public final void setNodeValue(String nodeValue) throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final short getNodeType()
  {
    return (short) dtm.getNodeType(node);
  }

  
  public final Node getParentNode()
  {

    if (getNodeType() == Node.ATTRIBUTE_NODE)
      return null;

    int newnode = dtm.getParent(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final Node getOwnerNode()
  {

    int newnode = dtm.getParent(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final NodeList getChildNodes()
  {
                
    
    
    
    return new DTMNodeList(dtm,node);

    
  }

  
  public final Node getFirstChild()
  {

    int newnode = dtm.getFirstChild(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final Node getLastChild()
  {

    int newnode = dtm.getLastChild(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final Node getPreviousSibling()
  {

    int newnode = dtm.getPreviousSibling(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  
  public final Node getNextSibling()
  {

    
    if (dtm.getNodeType(node) == Node.ATTRIBUTE_NODE)
      return null;

    int newnode = dtm.getNextSibling(node);

    return (newnode == DTM.NULL) ? null : dtm.getNode(newnode);
  }

  

  
  public final NamedNodeMap getAttributes()
  {

    return new DTMNamedNodeMap(dtm, node);
  }

  
  public boolean hasAttribute(String name)
  {
    return DTM.NULL != dtm.getAttributeNode(node,null,name);
  }

  
  public boolean hasAttributeNS(String name, String x)
  {
    return DTM.NULL != dtm.getAttributeNode(node,x,name);
  }

  
  public final Document getOwnerDocument()
  {
  	
	return (Document)(dtm.getNode(dtm.getOwnerDocument(node)));
  }

  
  public final Node insertBefore(Node newChild, Node refChild)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final Node replaceChild(Node newChild, Node oldChild)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final Node removeChild(Node oldChild) throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final Node appendChild(Node newChild) throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final boolean hasChildNodes()
  {
    return (DTM.NULL != dtm.getFirstChild(node));
  }

  
  public final Node cloneNode(boolean deep)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final DocumentType getDoctype()
  {
    return null;
  }

  
  public final DOMImplementation getImplementation()
  {
    return implementation;
  }

  
  public final Element getDocumentElement()
  {
		int dochandle=dtm.getDocument();
		int elementhandle=dtm.NULL;
		for(int kidhandle=dtm.getFirstChild(dochandle);
				kidhandle!=dtm.NULL;
				kidhandle=dtm.getNextSibling(kidhandle))
		{
			switch(dtm.getNodeType(kidhandle))
			{
			case Node.ELEMENT_NODE:
				if(elementhandle!=dtm.NULL) 
				{
					elementhandle=dtm.NULL; 
					kidhandle=dtm.getLastChild(dochandle); 
				}
				else
					elementhandle=kidhandle;
				break;
				
			
			case Node.COMMENT_NODE:
			case Node.PROCESSING_INSTRUCTION_NODE:
			case Node.DOCUMENT_TYPE_NODE:
				break;
					
			default:
				elementhandle=dtm.NULL; 
				kidhandle=dtm.getLastChild(dochandle); 
				break;
			}
		}
		if(elementhandle==dtm.NULL)
			throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
		else
			return (Element)(dtm.getNode(elementhandle));
  }

  
  public final Element createElement(String tagName) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final DocumentFragment createDocumentFragment()
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Text createTextNode(String data)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Comment createComment(String data)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final CDATASection createCDATASection(String data)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final ProcessingInstruction createProcessingInstruction(
                                                                 String target, String data) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr createAttribute(String name) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final EntityReference createEntityReference(String name)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final NodeList getElementsByTagName(String tagname)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Node importNode(Node importedNode, boolean deep)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public final Element createElementNS(
                                       String namespaceURI, String qualifiedName) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr createAttributeNS(
                                      String namespaceURI, String qualifiedName) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final NodeList getElementsByTagNameNS(String namespaceURI,
                                               String localName)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Element getElementById(String elementId)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Text splitText(int offset) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final String getData() throws DOMException
  {
    return dtm.getNodeValue(node);
  }

  
  public final void setData(String data) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final int getLength()
  {
    
    return dtm.getNodeValue(node).length();
  }

  
  public final String substringData(int offset, int count) throws DOMException
  {
    return getData().substring(offset,offset+count);
  }

  
  public final void appendData(String arg) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void insertData(int offset, String arg) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void deleteData(int offset, int count) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void replaceData(int offset, int count, String arg)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final String getTagName()
  {
    return dtm.getNodeName(node);
  }

  
  public final String getAttribute(String name)
  {

    DTMNamedNodeMap  map = new DTMNamedNodeMap(dtm, node);
    Node node = map.getNamedItem(name);
    return (null == node) ? null : node.getNodeValue();
  }

  
  public final void setAttribute(String name, String value)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void removeAttribute(String name) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr getAttributeNode(String name)
  {

    DTMNamedNodeMap  map = new DTMNamedNodeMap(dtm, node);
    return (Attr)map.getNamedItem(name);
  }

  
  public final Attr setAttributeNode(Attr newAttr) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr removeAttributeNode(Attr oldAttr) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public boolean hasAttributes()
  {
    return DTM.NULL != dtm.getFirstAttribute(node);
  }

  
  public final void normalize()
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final String getAttributeNS(String namespaceURI, String localName)
  {
    DTMNamedNodeMap  map = new DTMNamedNodeMap(dtm, node);
    Node node = map.getNamedItemNS(namespaceURI,localName);
    return (null == node) ? null : node.getNodeValue();
  }

  
  public final void setAttributeNS(
                                   String namespaceURI, String qualifiedName, String value)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final void removeAttributeNS(String namespaceURI, String localName)
    throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr getAttributeNodeNS(String namespaceURI, String localName)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Attr setAttributeNodeNS(Attr newAttr) throws DOMException
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final String getName()
  {
    return dtm.getNodeName(node);
  }

  
  public final boolean getSpecified()
  {
    
    
    
    
    return true;
  }

  
  public final String getValue()
  {
    return dtm.getNodeValue(node);
  }

  
  public final void setValue(String value)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public final Element getOwnerElement()
  {
    if (getNodeType() != Node.ATTRIBUTE_NODE)
      return null;
    
    
    int newnode = dtm.getParent(node);
    return (newnode == DTM.NULL) ? null : (Element)(dtm.getNode(newnode));
  }

  
  public Node adoptNode(Node source) throws DOMException
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public String getEncoding()
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public void setEncoding(String encoding)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public boolean getStandalone()
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public void setStandalone(boolean standalone)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public boolean getStrictErrorChecking()
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public void setStrictErrorChecking(boolean strictErrorChecking)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public String getVersion()
  {

    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }

  
  public void setVersion(String version)
  {
    throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
  }
        
        
  
  static class DTMNodeProxyImplementation implements DOMImplementation
  {
    public DocumentType createDocumentType(String qualifiedName,String publicId, String systemId)
    {
      throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);
    }
    public Document createDocument(String namespaceURI,String qualfiedName,DocumentType doctype)                        
    {
      
      throw new DTMDOMException(DOMException.NOT_SUPPORTED_ERR);        
    }
    
    public boolean hasFeature(String feature,String version)
    {
      if( (""CORE"".equals(feature.toUpperCase()) || ""XML"".equals(feature.toUpperCase())) 
					&& 
          (""1.0"".equals(version) || ""2.0"".equals(version))
          )
        return true;
      return false;
    }
  }
}
"
org.apache.xalan.xsltc.compiler.Stylesheet,54,2,0,70,185,1235,27,55,43,0.948113208,1914,0.916666667,6,0.504672897,0.10130719,2,7,34.0,9,2.1296,2,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Iterator;
import java.net.URL;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;

import org.apache.bcel.generic.*;
import org.apache.bcel.util.*;
import org.apache.bcel.classfile.JavaClass;

import org.apache.xalan.xsltc.compiler.util.MethodGenerator;
import org.apache.xalan.xsltc.compiler.util.ClassGenerator;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.compiler.util.Util;

import org.apache.xalan.xsltc.DOM;

public final class Stylesheet extends SyntaxTreeNode {

    private String       _version;
    private QName        _name;
    private String       _systemId;
    private Stylesheet   _parentStylesheet;
	
    
    private Vector _globals = new Vector();

    
    private Boolean _hasLocalParams = null;

    
    private String _className;
    
    
    private final Vector _templates = new Vector();

    private int _nextModeSerial = 1;
    private final Hashtable _modes = new Hashtable();
    private final Hashtable _extensions = new Hashtable();

    public  Stylesheet _importedFrom = null;
    public  Stylesheet _includedFrom = null;
    private int _importPrecedence = 1;
    private Mode _defaultMode;
    private boolean _multiDocument = false;
    private boolean _callsNodeset = false;

    
    private Hashtable _keys = new Hashtable();

    private boolean _numberFormattingUsed = false;

    private boolean _simplified = false;

    private SourceLoader _loader = null;

    private boolean _templateInlining = true;

    private boolean _forwardReference = false;

    private Properties _outputProperties = null;

    public void setForwardReference() {
	_forwardReference = true;
    }

    public boolean getTemplateInlining() {
	return _templateInlining;
    }

    public void setTemplateInlining(boolean flag) {
	_templateInlining = flag;
    }

    public boolean isSimplified() {
	return(_simplified);
    }

    public void setSimplified() {
	_simplified = true;
    }
    
    public void setOutputProperty(String key, String value) {
	if (_outputProperties == null) {
	    _outputProperties = new Properties();
	}
	_outputProperties.setProperty(key, value);
    }

    public void setOutputProperties(Properties props) {
	_outputProperties = props;
    }

    public Properties getOutputProperties() {
	return _outputProperties;
    }

    public void setMultiDocument(boolean flag) {	
	_multiDocument = flag;
    }

    public boolean isMultiDocument() {
	return _multiDocument;
    }

    public void setCallsNodeset(boolean flag) {
	if (flag) setMultiDocument(flag);
	_callsNodeset = flag;
    }

    public boolean callsNodeset() {
	return _callsNodeset;
    }

    public void numberFormattingUsed() {
	_numberFormattingUsed = true;
    }

    public void setImportPrecedence(final int precedence) {
	
	_importPrecedence = precedence;

	
	final Enumeration elements = elements();
	while (elements.hasMoreElements()) {
	    SyntaxTreeNode child = (SyntaxTreeNode)elements.nextElement();
	    if (child instanceof Include) {
		Stylesheet included = ((Include)child).getIncludedStylesheet();
		if (included != null) included.setImportPrecedence(precedence);
	    }
	}

	
	if (_importedFrom != null) {
	    if (_importedFrom.getImportPrecedence() < precedence) {
		final Parser parser = getParser();
		final int nextPrecedence = parser.getNextImportPrecedence();
		_importedFrom.setImportPrecedence(nextPrecedence);
	    }
	}
	
	else if (_includedFrom != null) {
	    if (_includedFrom.getImportPrecedence() != precedence)
		_includedFrom.setImportPrecedence(precedence);
	}
    }
    
    public int getImportPrecedence() {
	return _importPrecedence;
    }

    public boolean checkForLoop(String systemId) {
	
	if (_systemId != null && _systemId.equals(systemId)) {
	    return true;
	}
	
	if (_parentStylesheet != null) 
	    return _parentStylesheet.checkForLoop(systemId);
	
	return false;
    }
    
    public void setParser(Parser parser) {
	super.setParser(parser);
	_name = makeStylesheetName(""__stylesheet_"");
    }
    
    public void setParentStylesheet(Stylesheet parent) {
	_parentStylesheet = parent;
    }
    
    public Stylesheet getParentStylesheet() {
	return _parentStylesheet;
    }

    public void setImportingStylesheet(Stylesheet parent) {
	_importedFrom = parent;
    }

    public void setIncludingStylesheet(Stylesheet parent) {
	_importedFrom = parent;
    }

    public void setSystemId(String systemId) {
	_systemId = systemId;
    }
    
    public String getSystemId() {
	return _systemId;
    }

    public void setSourceLoader(SourceLoader loader) {
	_loader = loader;
    }
    
    public SourceLoader getSourceLoader() {
	return _loader;
    }

    private QName makeStylesheetName(String prefix) {
	return getParser().getQName(prefix+getXSLTC().nextStylesheetSerial());
    }

    
    public boolean hasGlobals() {
	return _globals.size() > 0;
    }

    
    public boolean hasLocalParams() {
	if (_hasLocalParams == null) {
	    final int n = _templates.size();
	    for (int i = 0; i < n; i++) {
		final Template template = (Template)_templates.elementAt(i);
		if (template.hasParams()) {
		    _hasLocalParams = new Boolean(true);
		    return true;
		}
	    }
	    _hasLocalParams = new Boolean(false);
	    return false;
	}
	else {
	    return _hasLocalParams.booleanValue();
	}
    }

    
    protected void addPrefixMapping(String prefix, String uri) {
	if (prefix.equals(EMPTYSTRING) && uri.equals(XHTML_URI)) return;
	super.addPrefixMapping(prefix, uri);
    }

    
    private void extensionURI(String prefixes, SymbolTable stable) {
	if (prefixes != null) {
	    StringTokenizer tokens = new StringTokenizer(prefixes);
	    while (tokens.hasMoreTokens()) {
		final String prefix = tokens.nextToken();
		final String uri = lookupNamespace(prefix);
		if (uri != null) {
		    _extensions.put(uri, prefix);
		}
	    }
	}
    }

    public boolean isExtension(String uri) {
	return (_extensions.get(uri) != null);
    }

    public void excludeExtensionPrefixes(Parser parser) {
	final SymbolTable stable = parser.getSymbolTable();
    	final String excludePrefixes = getAttribute(""exclude-result-prefixes"");
	final String extensionPrefixes = getAttribute(""extension-element-prefixes"");
	
	
	stable.excludeURI(Constants.XSLT_URI);
	stable.excludeNamespaces(excludePrefixes);
	stable.excludeNamespaces(extensionPrefixes);
	extensionURI(extensionPrefixes, stable);
    }

    
    public void parseContents(Parser parser) {
	final SymbolTable stable = parser.getSymbolTable();

	

	
	addPrefixMapping(""xml"", ""http:

	
	final Stylesheet sheet = stable.addStylesheet(_name, this);
	if (sheet != null) {
	    
	    ErrorMsg err = new ErrorMsg(ErrorMsg.MULTIPLE_STYLESHEET_ERR,this);
	    parser.reportError(Constants.ERROR, err);
	}

	
	
	
	
	
	if (_simplified) {
	    stable.excludeURI(XSLT_URI);
	    Template template = new Template();
	    template.parseSimplified(this, parser);
	}
	
	else {
	    parseOwnChildren(parser);
	}
    }

    
    public final void parseOwnChildren(Parser parser) {
	final Vector contents = getContents();
	final int count = contents.size();

	
	
	for (int i = 0; i < count; i++) {
	    SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
	    if ((child instanceof VariableBase) ||
		(child instanceof NamespaceAlias)) {
		parser.getSymbolTable().setCurrentNode(child);
		child.parseContents(parser);
	    }
	}

	
	for (int i = 0; i < count; i++) {
	    SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
	    if (!(child instanceof VariableBase) && 
		!(child instanceof NamespaceAlias)) {
		parser.getSymbolTable().setCurrentNode(child);
		child.parseContents(parser);
	    }

	    
	    
	    if (!_templateInlining && (child instanceof Template)) {
		Template template = (Template)child;
		String name = ""template$dot$"" + template.getPosition();
		template.setName(parser.getQName(name));
	    }
	}
    }

    public void processModes() {
	if (_defaultMode == null)
	    _defaultMode = new Mode(null, this, Constants.EMPTYSTRING);
	_defaultMode.processPatterns(_keys);
	final Enumeration modes = _modes.elements();
	while (modes.hasMoreElements()) {
	    final Mode mode = (Mode)modes.nextElement();
	    mode.processPatterns(_keys);
	}
    }
	
    private void compileModes(ClassGenerator classGen) {
	_defaultMode.compileApplyTemplates(classGen);
	final Enumeration modes = _modes.elements();
	while (modes.hasMoreElements()) {
	    final Mode mode = (Mode)modes.nextElement();
	    mode.compileApplyTemplates(classGen);
	}
    }

    public Mode getMode(QName modeName) {
	if (modeName == null) {
	    if (_defaultMode == null) {
		_defaultMode = new Mode(null, this, Constants.EMPTYSTRING);
	    }
	    return _defaultMode;
	}
	else {
	    Mode mode = (Mode)_modes.get(modeName);
	    if (mode == null) {
		final String suffix = Integer.toString(_nextModeSerial++);
		_modes.put(modeName, mode = new Mode(modeName, this, suffix));
	    }
	    return mode;
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final int count = _globals.size();
	for (int i = 0; i < count; i++) {
	    final VariableBase var = (VariableBase)_globals.elementAt(i);
	    var.typeCheck(stable);
	}
	return typeCheckContents(stable);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	translate();
    }

    private void addDOMField(ClassGenerator classGen) {
	final FieldGen fgen = new FieldGen(ACC_PUBLIC,
					   Util.getJCRefType(DOM_INTF_SIG),
					   DOM_FIELD,
					   classGen.getConstantPool());
	classGen.addField(fgen.getField());
    }

    
    public void translate() {
	Output lastOutputElement = null;
	_className = getXSLTC().getClassName();

	
	final ClassGenerator classGen =
	    new ClassGenerator(_className,
			       TRANSLET_CLASS,
			       Constants.EMPTYSTRING,
			       ACC_PUBLIC | ACC_SUPER,
			       null, this);
	
	addDOMField(classGen);

	
	
	compileTransform(classGen);

	
	final Enumeration elements = elements();
	while (elements.hasMoreElements()) {
	    Object element = elements.nextElement();
	    
	    if (element instanceof Template) {
		
		final Template template = (Template)element;
		_templates.addElement(template);
		getMode(template.getModeName()).addTemplate(template);
	    }
	    
	    else if (element instanceof AttributeSet) {
		((AttributeSet)element).translate(classGen, null);
	    }
	    else if (element instanceof Output) {
		
		Output output = (Output)element;
		if (output.enabled()) lastOutputElement = output;
	    }
	    else {
		
		
		
	    }
	}

	processModes();
	compileModes(classGen);
	compileConstructor(classGen, lastOutputElement);

	if (!getParser().errorsFound()) {
	    getXSLTC().dumpClass(classGen.getJavaClass());
	}
    }

    
    private void compileConstructor(ClassGenerator classGen, Output output) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();

	final MethodGenerator constructor =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID, 
				null, null, ""<init>"", 
				_className, il, cpg);

	
	il.append(classGen.loadTranslet());
	il.append(new INVOKESPECIAL(cpg.addMethodref(TRANSLET_CLASS,
						     ""<init>"", ""()V"")));

	
	final Vector names = getXSLTC().getNamesIndex();
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, names.size()));
	il.append(new ANEWARRAY(cpg.addClass(STRING)));		

	for (int i = 0; i < names.size(); i++) {
	    final String name = (String)names.elementAt(i);
	    il.append(DUP);
	    il.append(new PUSH(cpg, i));
	    il.append(new PUSH(cpg, name));
	    il.append(AASTORE);
	}
	il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       NAMES_INDEX,
					       NAMES_INDEX_SIG)));

	
	final Vector namespaces = getXSLTC().getNamespaceIndex();
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, namespaces.size()));
	il.append(new ANEWARRAY(cpg.addClass(STRING)));		

	for (int i = 0; i < namespaces.size(); i++) {
	    final String ns = (String)namespaces.elementAt(i);
	    il.append(DUP);
	    il.append(new PUSH(cpg, i));
	    il.append(new PUSH(cpg, ns));
	    il.append(AASTORE);
	}
	il.append(new PUTFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       NAMESPACE_INDEX,
					       NAMESPACE_INDEX_SIG)));

	
	if (output != null) {
	    
	    output.translate(classGen, constructor);
	}

	
	
	if (_numberFormattingUsed)
	    DecimalFormatting.translateDefaultDFS(classGen, constructor);

	il.append(RETURN);

	constructor.stripAttributes(true);
	constructor.setMaxLocals();
	constructor.setMaxStack();
	classGen.addMethod(constructor.getMethod());
    }

    
    private String compileTopLevel(ClassGenerator classGen,
				   Enumeration elements) {

	final ConstantPoolGen cpg = classGen.getConstantPool();

	final org.apache.bcel.generic.Type[] argTypes = {
	    Util.getJCRefType(DOM_INTF_SIG),
	    Util.getJCRefType(NODE_ITERATOR_SIG),
	    Util.getJCRefType(TRANSLET_OUTPUT_SIG)
	};

	final String[] argNames = {
	    DOCUMENT_PNAME, ITERATOR_PNAME, TRANSLET_OUTPUT_PNAME
	};

	final InstructionList il = new InstructionList();

	final MethodGenerator toplevel =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames,
				""topLevel"", _className, il,
				classGen.getConstantPool());

	toplevel.addException(""org.apache.xalan.xsltc.TransletException"");

	
	final LocalVariableGen current = 
	    toplevel.addLocalVariable(""current"",
				    org.apache.bcel.generic.Type.INT,
				    il.getEnd(), null);

	final int setFilter = cpg.addInterfaceMethodref(DOM_INTF,
			       ""setFilter"",
			       ""(Lorg/apache/xalan/xsltc/StripFilter;)V"");

	il.append(new PUSH(cpg, DOM.ROOTNODE));
	il.append(new ISTORE(current.getIndex()));

	
	_globals = resolveReferences(_globals);
	final int count = _globals.size();
	for (int i = 0; i < count; i++) {
	    final VariableBase var = (VariableBase)_globals.elementAt(i);
	    var.translate(classGen,toplevel);
	}

	
	Vector whitespaceRules = new Vector();
	while (elements.hasMoreElements()) {
	    final Object element = elements.nextElement();
	    
	    if (element instanceof DecimalFormatting) {
		((DecimalFormatting)element).translate(classGen,toplevel);
	    }
	    
	    else if (element instanceof Whitespace) {
		whitespaceRules.addAll(((Whitespace)element).getRules());
	    }
	}

	
	if (whitespaceRules.size() > 0) {
	    Whitespace.translateRules(whitespaceRules,classGen);
	}

	if (classGen.containsMethod(STRIP_SPACE, STRIP_SPACE_PARAMS) != null) {
	    il.append(toplevel.loadDOM());
	    il.append(classGen.loadTranslet());
	    il.append(new INVOKEINTERFACE(setFilter, 2));
	}

	il.append(RETURN);

	
	toplevel.stripAttributes(true);
	toplevel.setMaxLocals();
	toplevel.setMaxStack();
	toplevel.removeNOPs();

	classGen.addMethod(toplevel.getMethod());
	
	return(""(""+DOM_INTF_SIG+NODE_ITERATOR_SIG+TRANSLET_OUTPUT_SIG+"")V"");
    }

    
    private Vector resolveReferences(Vector input) {

	
	for (int i = 0; i < input.size(); i++) {
	    final VariableBase var = (VariableBase) input.elementAt(i);
	    final Vector dep  = var.getDependencies();
	    final int depSize = (dep != null) ? dep.size() : 0;

	    for (int j = 0; j < depSize; j++) {
		final VariableBase depVar = (VariableBase) dep.elementAt(j);
		if (!input.contains(depVar)) {
		    input.addElement(depVar);
		}
	    }
	}

	

	Vector result = new Vector();
	while (input.size() > 0) {
	    boolean changed = false;
	    for (int i = 0; i < input.size(); ) {
		final VariableBase var = (VariableBase)input.elementAt(i);
		final Vector dep = var.getDependencies();
		if (dep == null || result.containsAll(dep)) {
		    result.addElement(var);
		    input.remove(i);
		    changed = true;
		}
		else {
		    i++;
		}
	    }

	    
	    if (!changed) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.CIRCULAR_VARIABLE_ERR,
					    input.toString(), this);
		getParser().reportError(Constants.ERROR, err);
		return(result);
	    }
	}

	

	return result;
    }

    
    private String compileBuildKeys(ClassGenerator classGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();

	final org.apache.bcel.generic.Type[] argTypes = {
	    Util.getJCRefType(DOM_INTF_SIG),
	    Util.getJCRefType(NODE_ITERATOR_SIG),
	    Util.getJCRefType(TRANSLET_OUTPUT_SIG),
	    org.apache.bcel.generic.Type.INT
	};

	final String[] argNames = {
	    DOCUMENT_PNAME, ITERATOR_PNAME, TRANSLET_OUTPUT_PNAME, ""current""
	};

	final InstructionList il = new InstructionList();

	final MethodGenerator buildKeys =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames,
				""buildKeys"", _className, il,
				classGen.getConstantPool());

	final int domField = cpg.addFieldref(getClassName(),
					     DOM_FIELD,
					     DOM_INTF_SIG);

	buildKeys.addException(""org.apache.xalan.xsltc.TransletException"");

	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(domField));  
	il.append(new ASTORE(1));
	
	final Enumeration elements = elements();
	
	while (elements.hasMoreElements()) {
	    
	    final Object element = elements.nextElement();
	    if (element instanceof Key) {
		final Key key = (Key)element;
		key.translate(classGen, buildKeys);
		_keys.put(key.getName(),key);
	    }
	}
	
	il.append(RETURN);
	
	
	buildKeys.stripAttributes(true);
	buildKeys.setMaxLocals();
	buildKeys.setMaxStack();
	buildKeys.removeNOPs();

	classGen.addMethod(buildKeys.getMethod());
	
	return(""(""+DOM_INTF_SIG+NODE_ITERATOR_SIG+TRANSLET_OUTPUT_SIG+""I)V"");
    }

    
    private void compileTransform(ClassGenerator classGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();

	
	final org.apache.bcel.generic.Type[] argTypes = 
	    new org.apache.bcel.generic.Type[3];
	argTypes[0] = Util.getJCRefType(DOM_INTF_SIG);
	argTypes[1] = Util.getJCRefType(NODE_ITERATOR_SIG);
	argTypes[2] = Util.getJCRefType(TRANSLET_OUTPUT_SIG);

	final String[] argNames = new String[3];
	argNames[0] = DOCUMENT_PNAME;
	argNames[1] = ITERATOR_PNAME;
	argNames[2] = TRANSLET_OUTPUT_PNAME;

	final InstructionList il = new InstructionList();
	final MethodGenerator transf =
	    new MethodGenerator(ACC_PUBLIC,
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames,
				""transform"",
				_className,
				il,
				classGen.getConstantPool());
	transf.addException(""org.apache.xalan.xsltc.TransletException"");

	
	final LocalVariableGen current = 
	    transf.addLocalVariable(""current"",
				    org.apache.bcel.generic.Type.INT,
				    il.getEnd(), null);
	final String applyTemplatesSig = classGen.getApplyTemplatesSig();
	final int applyTemplates = cpg.addMethodref(getClassName(),
						    ""applyTemplates"",
						    applyTemplatesSig);
	final int domField = cpg.addFieldref(getClassName(),
					     DOM_FIELD,
					     DOM_INTF_SIG);

	
	il.append(classGen.loadTranslet());
	
	
	if (isMultiDocument()) {
	    il.append(new NEW(cpg.addClass(MULTI_DOM_CLASS)));
	    il.append(DUP);
	}
	
	il.append(classGen.loadTranslet());
	il.append(transf.loadDOM());
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
						     ""makeDOMAdapter"",
						     ""(""+DOM_INTF_SIG+"")""+
						     DOM_ADAPTER_SIG)));
	

	if (isMultiDocument()) {
	    final int init = cpg.addMethodref(MULTI_DOM_CLASS,
					      ""<init>"",
					      ""(""+DOM_INTF_SIG+"")V"");
	    il.append(new INVOKESPECIAL(init));
	    
	}
	
	
	il.append(new PUTFIELD(domField));

	
	il.append(new PUSH(cpg, DOM.ROOTNODE));
	il.append(new ISTORE(current.getIndex()));

	
	il.append(classGen.loadTranslet());
	il.append(transf.loadHandler());
	final int index = cpg.addMethodref(TRANSLET_CLASS,
					   ""transferOutputSettings"",
					   ""(""+OUTPUT_HANDLER_SIG+"")V"");
	il.append(new INVOKEVIRTUAL(index));

	
	final String keySig = compileBuildKeys(classGen);
	final int    keyIdx = cpg.addMethodref(getClassName(),
					       ""buildKeys"", keySig);
	il.append(classGen.loadTranslet());     
	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(domField));      
	il.append(transf.loadIterator());       
	il.append(transf.loadHandler());        
	il.append(new PUSH(cpg, DOM.ROOTNODE)); 
	il.append(new INVOKEVIRTUAL(keyIdx));

	
	final Enumeration toplevel = elements();
	if ((_globals.size() > 0) || (toplevel.hasMoreElements())) {
	    
	    final String topLevelSig = compileTopLevel(classGen, toplevel);
	    
	    final int topLevelIdx = cpg.addMethodref(getClassName(),
						     ""topLevel"",
						     topLevelSig);
	    
	    il.append(classGen.loadTranslet()); 
	    il.append(classGen.loadTranslet());
	    il.append(new GETFIELD(domField));  
	    il.append(transf.loadIterator());
	    il.append(transf.loadHandler());    
	    il.append(new INVOKEVIRTUAL(topLevelIdx));
	}
	
	
	il.append(transf.loadHandler());
	il.append(transf.startDocument());

	
	il.append(classGen.loadTranslet());
	
	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(domField));
	
	il.append(transf.loadIterator());
	il.append(transf.loadHandler());
	il.append(new INVOKEVIRTUAL(applyTemplates));
	
	il.append(transf.loadHandler());
	il.append(transf.endDocument());

	il.append(RETURN);

	
	transf.stripAttributes(true);
	transf.setMaxLocals();
	transf.setMaxStack();
	transf.removeNOPs();

	classGen.addMethod(transf.getMethod());
    }

    
    private void peepHoleOptimization(MethodGenerator methodGen) {
	final String pattern = ""`ALOAD'`POP'`Instruction'"";
	final InstructionList il = methodGen.getInstructionList();
	final InstructionFinder find = new InstructionFinder(il);
	for(Iterator iter=find.search(pattern); iter.hasNext(); ) {
	    InstructionHandle[] match = (InstructionHandle[])iter.next();
	    try {
		il.delete(match[0], match[1]);
	    } 
	    catch (TargetLostException e) {
            	
            }
	}
    }

    public int addParam(Param param) {
	_globals.addElement(param);
	return _globals.size() - 1;
    }

    public int addVariable(Variable global) {
	_globals.addElement(global);
	return _globals.size() - 1;
    }

    public void display(int indent) {
	indent(indent);
	Util.println(""Stylesheet"");
	displayContents(indent + IndentIncrement);
    }

    
    public String getNamespace(String prefix) {
	return lookupNamespace(prefix);
    }

    public String getClassName() {
	return _className;
    }

    public Vector getTemplates() {
	return _templates;
    }
}
"
org.apache.xpath.operations.Mod,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.XPathContext;


public class Mod extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() % right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return (m_left.num(xctxt) % m_right.num(xctxt));
  }

}
"
org.apache.xalan.xsltc.compiler.Message,4,3,0,22,23,0,0,22,3,0.333333333,115,1.0,0,0.949152542,0.4,2,5,27.5,2,1.25,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;

import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.JavaClass;

import org.apache.xalan.xsltc.compiler.util.*;

final class Message extends Instruction {
    private boolean _terminate = false;
	
    public void parseContents(Parser parser) {
	String termstr = getAttribute(""terminate"");
	if (termstr != null) {
            _terminate = termstr.equals(""yes"");
	}
	parseChildren(parser);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	typeCheckContents(stable);
	return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(classGen.loadTranslet());

	
	compileResultTree(classGen, methodGen);
	
	final int toStr = cpg.addInterfaceMethodref(DOM_INTF,
						    ""getTreeString"",
						    ""()""+STRING_SIG);
	il.append(new INVOKEINTERFACE(toStr, 1));

	
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
						     ""displayMessage"",
						     ""(""+STRING_SIG+"")V"")));

	
	
	if (_terminate == true) {
	    
	    final int einit = cpg.addMethodref(""java.lang.RuntimeException"",
					       ""<init>"",
					       ""(Ljava/lang/String;)V"");
	    il.append(new NEW(cpg.addClass(""java.lang.RuntimeException"")));
	    il.append(DUP);
	    il.append(new PUSH(cpg,""Termination forced by an "" +
			           ""xsl:message instruction""));
	    il.append(new INVOKESPECIAL(einit));
	    il.append(ATHROW);
	}
    }
    
}
"
org.apache.xpath.compiler.PsuedoNames,1,1,0,0,2,0,0,0,1,2.0,10,0.0,0,0.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xpath.compiler;


public class PsuedoNames
{

  
  public static final String PSEUDONAME_ANY = ""*"";

  
  public static final String PSEUDONAME_ROOT = ""/"";

  
  public static final String PSEUDONAME_TEXT = ""#text"";

  
  public static final String PSEUDONAME_COMMENT = ""#comment"";

  
  public static final String PSEUDONAME_PI = ""#pi"";

  
  public static final String PSEUDONAME_OTHER = ""*"";
}
"
org.apache.xalan.transformer.TransformerHandlerImpl,36,1,0,9,100,0,2,8,33,0.817582418,914,0.923076923,2,0.0,0.176623377,0,0,24.02777778,7,1.1944,0,"
package org.apache.xalan.transformer;

import java.io.IOException;

import org.xml.sax.XMLReader;
import org.xml.sax.XMLFilter;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;
import org.xml.sax.Attributes;
import org.xml.sax.EntityResolver;
import org.xml.sax.DTDHandler;
import org.xml.sax.ContentHandler;
import org.xml.sax.ErrorHandler;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.ext.LexicalHandler;

import org.apache.xpath.objects.XString;


import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.Transformer;
import javax.xml.transform.Result;

import org.apache.xpath.XPathContext;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.ref.IncrementalSAXSource;
import org.apache.xml.dtm.ref.IncrementalSAXSource_Filter;
import org.apache.xml.dtm.ref.sax2dtm.SAX2DTM;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;



public class TransformerHandlerImpl
        implements EntityResolver, DTDHandler, ContentHandler, ErrorHandler,
                   LexicalHandler, TransformerHandler, DeclHandler
{
  
  private boolean m_insideParse = false;

  
  
  

  
  public TransformerHandlerImpl(TransformerImpl transformer,
                                boolean doFragment, String baseSystemID)
  {

    super();

    m_transformer = transformer;
    m_baseSystemID = baseSystemID;

    XPathContext xctxt = transformer.getXPathContext();
    DTM dtm = xctxt.getDTM(null, true, transformer, true, true);
    
    m_dtm = dtm;
    dtm.setDocumentBaseURI(baseSystemID);

    m_contentHandler = dtm.getContentHandler();
    m_dtdHandler = dtm.getDTDHandler();
    m_entityResolver = dtm.getEntityResolver();
    m_errorHandler = dtm.getErrorHandler();
    m_lexicalHandler = dtm.getLexicalHandler();
  }
  
  
  protected void clearCoRoutine()
  {
    clearCoRoutine(null);
  }
  
  
  protected void clearCoRoutine(SAXException ex)
  {
    if(null != ex)
      m_transformer.setExceptionThrown(ex);
    
    if(m_dtm instanceof SAX2DTM)
    {
      if(DEBUG)
        System.err.println(""In clearCoRoutine..."");
      try
      {
        SAX2DTM sax2dtm = ((SAX2DTM)m_dtm);          
        if(null != m_contentHandler 
           && m_contentHandler instanceof IncrementalSAXSource_Filter)
        {
          IncrementalSAXSource_Filter sp =
            (IncrementalSAXSource_Filter)m_contentHandler;
          
          sp.deliverMoreNodes(false);
        }
        
        sax2dtm.clearCoRoutine(true);
        m_contentHandler = null;
        m_dtdHandler = null;
        m_entityResolver = null;
        m_errorHandler = null;
        m_lexicalHandler = null;
      }
      catch(Throwable throwable)
      {
        throwable.printStackTrace();
      }
      
      if(DEBUG)
        System.err.println(""...exiting clearCoRoutine"");
    }
  }
  
  
  
  

  
  public void setResult(Result result) throws IllegalArgumentException
  {

    if (null == result)
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_NULL, null)); 

    try
    {
      ContentHandler handler =
        m_transformer.createResultContentHandler(result);

      m_transformer.setContentHandler(handler);
    }
    catch (javax.xml.transform.TransformerException te)
    {
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_RESULT_COULD_NOT_BE_SET, null)); 
    }

    m_result = result;
  }

  
  public void setSystemId(String systemID)
  {
    m_baseSystemID = systemID;
    m_dtm.setDocumentBaseURI(systemID);
  }

  
  public String getSystemId()
  {
    return m_baseSystemID;
  }

  
  public Transformer getTransformer()
  {
    return m_transformer;
  }

  
  
  

  
  public InputSource resolveEntity(String publicId, String systemId)
          throws SAXException, IOException
  {

    if (m_entityResolver != null)
    {
      return m_entityResolver.resolveEntity(publicId, systemId);
    }
    else
    {
      return null;
    }
  }

  
  
  

  
  public void notationDecl(String name, String publicId, String systemId)
          throws SAXException
  {

    if (m_dtdHandler != null)
    {
      m_dtdHandler.notationDecl(name, publicId, systemId);
    }
  }

  
  public void unparsedEntityDecl(
          String name, String publicId, String systemId, String notationName)
            throws SAXException
  {

    if (m_dtdHandler != null)
    {
      m_dtdHandler.unparsedEntityDecl(name, publicId, systemId, notationName);
    }
  }

  
  
  

  
  public void setDocumentLocator(Locator locator)
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#setDocumentLocator: ""
                         + locator.getSystemId());

    this.m_locator = locator;
    
    if(null == m_baseSystemID)
    {
      setSystemId(locator.getSystemId());
    }

    if (m_contentHandler != null)
    {
      m_contentHandler.setDocumentLocator(locator);
    }
  }

  
  public void startDocument() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startDocument"");
      
    m_insideParse = true;

   

    if (m_contentHandler != null)
    {
      
      if(DTMManager.getIncremental())
      {
        m_transformer.setSourceTreeDocForThread(m_dtm.getDocument());
            
        int cpriority = Thread.currentThread().getPriority();
    
        
        
        m_transformer.runTransformThread( cpriority );
      }

      
      
      
      
      m_contentHandler.startDocument();
   }
        
   
   

  }

  
  public void endDocument() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endDocument"");

    m_insideParse = false;
    
    if (m_contentHandler != null)
    {
      m_contentHandler.endDocument();
    }
    
    if(DTMManager.getIncremental())
    {
      m_transformer.waitTransformThread();
    }
    else
    {
      m_transformer.setSourceTreeDocForThread(m_dtm.getDocument());
      m_transformer.run();
    }
   
  }

  
  public void startPrefixMapping(String prefix, String uri)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startPrefixMapping: ""
                         + prefix + "", "" + uri);

    if (m_contentHandler != null)
    {
      m_contentHandler.startPrefixMapping(prefix, uri);
    }
  }

  
  public void endPrefixMapping(String prefix) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endPrefixMapping: ""
                         + prefix);

    if (m_contentHandler != null)
    {
      m_contentHandler.endPrefixMapping(prefix);
    }
  }

  
  public void startElement(
          String uri, String localName, String qName, Attributes atts)
            throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startElement: "" + qName);

    if (m_contentHandler != null)
    {
      m_contentHandler.startElement(uri, localName, qName, atts);
    }
  }

  
  public void endElement(String uri, String localName, String qName)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endElement: "" + qName);

    if (m_contentHandler != null)
    {
      m_contentHandler.endElement(uri, localName, qName);
    }
  }

  
  public void characters(char ch[], int start, int length) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#characters: "" + start + "", ""
                         + length);

    if (m_contentHandler != null)
    {
      m_contentHandler.characters(ch, start, length);
    }
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#ignorableWhitespace: ""
                         + start + "", "" + length);

    if (m_contentHandler != null)
    {
      m_contentHandler.ignorableWhitespace(ch, start, length);
    }
  }

  
  public void processingInstruction(String target, String data)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#processingInstruction: ""
                         + target + "", "" + data);

    if (m_contentHandler != null)
    {
      m_contentHandler.processingInstruction(target, data);
    }
  }

  
  public void skippedEntity(String name) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#skippedEntity: "" + name);

    if (m_contentHandler != null)
    {
      m_contentHandler.skippedEntity(name);
    }
  }

  
  
  

  
  public void warning(SAXParseException e) throws SAXException
  {
    
    
    
    
    javax.xml.transform.ErrorListener errorListener = m_transformer.getErrorListener();
    if(errorListener instanceof ErrorHandler)
    {
      ((ErrorHandler)errorListener).warning(e);
    }
    else
    {
      try
      {
        errorListener.warning(new javax.xml.transform.TransformerException(e));
      }
      catch(javax.xml.transform.TransformerException te)
      {
        throw e;
      }
    }
  }

  
  public void error(SAXParseException e) throws SAXException
  {
    
    

    
    
    
    
    javax.xml.transform.ErrorListener errorListener = m_transformer.getErrorListener();
    if(errorListener instanceof ErrorHandler)
    {
      ((ErrorHandler)errorListener).error(e);
      if(null != m_errorHandler)
        m_errorHandler.error(e); 
    }
    else
    {
      try
      {
        errorListener.error(new javax.xml.transform.TransformerException(e));
        if(null != m_errorHandler)
          m_errorHandler.error(e); 
      }
      catch(javax.xml.transform.TransformerException te)
      {
        throw e;
      }
    }
  }

  
  public void fatalError(SAXParseException e) throws SAXException
  {
    if(null != m_errorHandler)
    {
      try
      {
        m_errorHandler.fatalError(e);
      }
      catch(SAXParseException se)
      {
        
      }
      
    }

    
    
    
    
    javax.xml.transform.ErrorListener errorListener = m_transformer.getErrorListener();
    
    if(errorListener instanceof ErrorHandler)
    {
      ((ErrorHandler)errorListener).fatalError(e);
      if(null != m_errorHandler)
        m_errorHandler.fatalError(e); 
    }
    else
    {
      try
      {
        errorListener.fatalError(new javax.xml.transform.TransformerException(e));
        if(null != m_errorHandler)
          m_errorHandler.fatalError(e); 
      }
      catch(javax.xml.transform.TransformerException te)
      {
        throw e;
      }
    }
  }

  
  
  

  
  public void startDTD(String name, String publicId, String systemId)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startDTD: "" + name + "", ""
                         + publicId + "", "" + systemId);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startDTD(name, publicId, systemId);
    }
  }

  
  public void endDTD() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endDTD"");

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.endDTD();
    }
  }

  
  public void startEntity(String name) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startEntity: "" + name);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startEntity(name);
    }
  }

  
  public void endEntity(String name) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endEntity: "" + name);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.endEntity(name);
    }
  }

  
  public void startCDATA() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#startCDATA"");

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startCDATA();
    }
  }

  
  public void endCDATA() throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#endCDATA"");

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.endCDATA();
    }
  }

  
  public void comment(char ch[], int start, int length) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#comment: "" + start + "", ""
                         + length);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.comment(ch, start, length);
    }
  }

  
  
  

  
  public void elementDecl(String name, String model) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#elementDecl: "" + name + "", ""
                         + model);

    if (null != m_declHandler)
    {
      m_declHandler.elementDecl(name, model);
    }
  }

  
  public void attributeDecl(
          String eName, String aName, String type, String valueDefault, String value)
            throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#attributeDecl: "" + eName
                         + "", "" + aName + "", etc..."");

    if (null != m_declHandler)
    {
      m_declHandler.attributeDecl(eName, aName, type, valueDefault, value);
    }
  }

  
  public void internalEntityDecl(String name, String value)
          throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#internalEntityDecl: "" + name
                         + "", "" + value);

    if (null != m_declHandler)
    {
      m_declHandler.internalEntityDecl(name, value);
    }
  }

  
  public void externalEntityDecl(
          String name, String publicId, String systemId) throws SAXException
  {

    if (DEBUG)
      System.out.println(""TransformerHandlerImpl#externalEntityDecl: "" + name
                         + "", "" + publicId + "", "" + systemId);

    if (null != m_declHandler)
    {
      m_declHandler.externalEntityDecl(name, publicId, systemId);
    }
  }

  
  
  

  
  private static boolean DEBUG = false;

  
  private TransformerImpl m_transformer;

  
  private String m_baseSystemID;

  
  private Result m_result = null;

  
  private Locator m_locator = null;

  
  private EntityResolver m_entityResolver = null;

  
  private DTDHandler m_dtdHandler = null;

  
  private ContentHandler m_contentHandler = null;

  
  private ErrorHandler m_errorHandler = null;

  
  private LexicalHandler m_lexicalHandler = null;

  
  private DeclHandler m_declHandler = null;
  
  
  DTM m_dtm;
}
"
org.apache.xalan.extensions.XSLProcessorContext,7,1,1,25,49,5,6,19,7,0.733333333,321,1.0,4,0.0,0.392857143,0,0,44.14285714,1,0.8571,0,"
package org.apache.xalan.extensions;

import org.w3c.dom.Node;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.traversal.NodeIterator;
import org.apache.xml.dtm.*;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultTreeHandler;
import org.apache.xalan.transformer.ClonerToResultTree;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xml.utils.QName;

import javax.xml.transform.TransformerException;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.DescendantIterator;
import org.apache.xpath.axes.OneStepIterator;

import org.apache.xml.dtm.DTM;




public class XSLProcessorContext
{

  
  public XSLProcessorContext(TransformerImpl transformer,
                             Stylesheet stylesheetTree)
  {

    this.transformer = transformer;
    this.stylesheetTree = stylesheetTree;
    
    org.apache.xpath.XPathContext xctxt = transformer.getXPathContext();
    this.mode = transformer.getMode();
    this.sourceNode = xctxt.getCurrentNode();
    this.sourceTree = xctxt.getDTM(this.sourceNode);
  }

  
  private TransformerImpl transformer;

  
  public TransformerImpl getTransformer()
  {
    return transformer;
  }

  
  private Stylesheet stylesheetTree;

  
  public Stylesheet getStylesheet()
  {
    return stylesheetTree;
  }

  
  private org.apache.xml.dtm.DTM sourceTree;

  
  public org.w3c.dom.Node getSourceTree()
  {
    return sourceTree.getNode(sourceTree.getDocumentRoot(sourceNode));
  }

  
  private int sourceNode;

  
  public org.w3c.dom.Node getContextNode()
  {
    return sourceTree.getNode(sourceNode);
  }

  
  private QName mode;

  
  public QName getMode()
  {
    return mode;
  }

  
  public void outputToResultTree(Stylesheet stylesheetTree, Object obj)
          throws TransformerException, java.net.MalformedURLException,
                 java.io.FileNotFoundException, java.io.IOException
  {

    try
    {
      ResultTreeHandler rtreeHandler = transformer.getResultTreeHandler();
      XPathContext xctxt = transformer.getXPathContext();
      XObject value;

      
      
      
      
      if (obj instanceof XObject)
      {
        value = (XObject) obj;
      }
      else if (obj instanceof String)
      {
        value = new XString((String) obj);
      }
      else if (obj instanceof Boolean)
      {
        value = new XBoolean(((Boolean) obj).booleanValue());
      }
      else if (obj instanceof Double)
      {
        value = new XNumber(((Double) obj).doubleValue());
      }
      else if (obj instanceof DocumentFragment)
      {
        int handle = xctxt.getDTMHandleFromNode((DocumentFragment)obj);
        
        value = new XRTreeFrag(handle, xctxt);
      }
      else if (obj instanceof DTM)
      {
        DTM dtm = (DTM)obj;
        DTMIterator iterator = new DescendantIterator();
        
        
        
        
        
        iterator.setRoot(dtm.getDocument(), xctxt);
        value = new XNodeSet(iterator);
      }
      else if (obj instanceof DTMAxisIterator)
      {
        DTMAxisIterator iter = (DTMAxisIterator)obj;
        DTMIterator iterator = new OneStepIterator(iter, -1);
        value = new XNodeSet(iterator);
      }
      else if (obj instanceof DTMIterator)
      {
        value = new XNodeSet((DTMIterator) obj);
      }
      else if (obj instanceof NodeIterator)
      {
        value = new XNodeSet(new org.apache.xpath.NodeSetDTM(((NodeIterator)obj), xctxt));
      }
      else if (obj instanceof org.w3c.dom.Node)
      {
        value =
          new XNodeSet(xctxt.getDTMHandleFromNode((org.w3c.dom.Node) obj),
                       xctxt.getDTMManager());
      }
      else
      {
        value = new XString(obj.toString());
      }

      int type = value.getType();
      String s;

      switch (type)
      {
      case XObject.CLASS_BOOLEAN :
      case XObject.CLASS_NUMBER :
      case XObject.CLASS_STRING :
        s = value.str();

        rtreeHandler.characters(s.toCharArray(), 0, s.length());
        break;

      case XObject.CLASS_NODESET :  
        DTMIterator nl = value.iter();
        
        int pos;

        while (DTM.NULL != (pos = nl.nextNode()))
        {
          DTM dtm = nl.getDTM(pos);
          int top = pos;

          while (DTM.NULL != pos)
          {
            rtreeHandler.flushPending();
            ClonerToResultTree.cloneToResultTree(pos, dtm.getNodeType(pos), 
                                                   dtm, rtreeHandler, true);

            int nextNode = dtm.getFirstChild(pos);

            while (DTM.NULL == nextNode)
            {
              if (DTM.ELEMENT_NODE == dtm.getNodeType(pos))
              {
                rtreeHandler.endElement("""", """", dtm.getNodeName(pos));
              }

              if (top == pos)
                break;

              nextNode = dtm.getNextSibling(pos);

              if (DTM.NULL == nextNode)
              {
                pos = dtm.getParent(pos);

                if (top == pos)
                {
                  if (DTM.ELEMENT_NODE == dtm.getNodeType(pos))
                  {
                    rtreeHandler.endElement("""", """", dtm.getNodeName(pos));
                  }

                  nextNode = DTM.NULL;

                  break;
                }
              }
            }

            pos = nextNode;
          }
        }
        break;
      case XObject.CLASS_RTREEFRAG :
        rtreeHandler.outputResultTreeFragment(value,
                                              transformer.getXPathContext());
        break;
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }

  
}
"
org.apache.xpath.XPathVisitor,13,1,5,42,14,78,40,13,13,2.0,40,0.0,0,0.0,0.203296703,0,0,2.076923077,1,0.9231,0,"
package org.apache.xpath;

import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.axes.UnionPathIterator;
import org.apache.xpath.functions.Function;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XString;
import org.apache.xpath.operations.Operation;
import org.apache.xpath.operations.UnaryOperation;
import org.apache.xpath.operations.Variable;
import org.apache.xpath.patterns.StepPattern;
import org.apache.xpath.patterns.UnionPattern;


public class XPathVisitor
{
	
	public boolean visitLocationPath(ExpressionOwner owner, LocPathIterator path)
	{
		return true;
	}

	
	public boolean visitUnionPath(ExpressionOwner owner, UnionPathIterator path)
	{
		return true;
	}
	
	
	public boolean visitStep(ExpressionOwner owner, NodeTest step)
	{
		return true;
	}
		
	
	public boolean visitPredicate(ExpressionOwner owner, Expression pred)
	{
		return true;
	}

	
	public boolean visitBinaryOperation(ExpressionOwner owner, Operation op)
	{
		return true;
	}

	
	public boolean visitUnaryOperation(ExpressionOwner owner, UnaryOperation op)
	{
		return true;
	}
	
	
	public boolean visitVariableRef(ExpressionOwner owner, Variable var)
	{
		return true;
	}

	
	public boolean visitFunction(ExpressionOwner owner, Function func)
	{
		return true;
	}
	
	
	public boolean visitMatchPattern(ExpressionOwner owner, StepPattern pattern)
	{
		return true;
	}
	
	
	public boolean visitUnionPattern(ExpressionOwner owner, UnionPattern pattern)
	{
		return true;
	}
	
	
	public boolean visitStringLiteral(ExpressionOwner owner, XString str)
	{
		return true;
	}


	
	public boolean visitNumberLiteral(ExpressionOwner owner, XNumber num)
	{
		return true;
	}


}

"
org.apache.xalan.xsltc.trax.TemplatesImpl,15,1,0,7,34,15,4,6,8,0.619047619,331,1.0,1,0.0,0.19047619,0,0,20.46666667,1,0.8667,1,"

package org.apache.xalan.xsltc.trax;

import java.io.Serializable;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.IOException;
import java.util.Properties;
import java.security.AccessController;
import java.security.PrivilegedAction;

import javax.xml.transform.*;

import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.compiler.*;
import org.apache.xalan.xsltc.runtime.*;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;

public final class TemplatesImpl implements Templates, Serializable {

    
    private static String ABSTRACT_TRANSLET 
	= ""org.apache.xalan.xsltc.runtime.AbstractTranslet"";

    
    private String _name = null;

    
    private byte[][] _bytecodes = null;

    
    private Class[] _class = null;

    
    private int _transletIndex = -1;
    
    
    private Properties _outputProperties; 

    
    private int _indentNumber;

    
    private URIResolver _uriResolver = null;

    
    private TransformerFactoryImpl _tfactory = null;

    private class TransletClassLoader extends ClassLoader {

	protected TransletClassLoader(ClassLoader parent){
	    super(parent);
	}
	public Class defineClass(byte[] b) {
	    return super.defineClass(null, b, 0, b.length);
	}
    }

   
    protected TemplatesImpl(byte[][] bytecodes, String transletName,
	Properties outputProperties, int indentNumber,
	TransformerFactoryImpl tfactory) 
    {
	_bytecodes = bytecodes;
	_name      = transletName;
	_outputProperties = outputProperties;
	_indentNumber = indentNumber;
	_tfactory = tfactory;
    }

    public synchronized void writeExternal(ObjectOutput out) 
	throws IOException 
    {
	out.writeObject(_name);
	out.writeObject(_bytecodes);
	out.flush();
    }

    public synchronized void readExternal(ObjectInput in)
	throws IOException, ClassNotFoundException 
    {
	_name      = (String)in.readObject();
	_bytecodes = (byte[][])in.readObject();
	_class     = null; 
    }

     
    public synchronized void setURIResolver(URIResolver resolver) {
	_uriResolver = resolver;
    }

    
    protected synchronized void setTransletBytecodes(byte[][] bytecodes) {
	_bytecodes = bytecodes;
    }

    
    public synchronized byte[][] getTransletBytecodes() {
	return _bytecodes;
    }

    
    public synchronized Class[] getTransletClasses() {
	try {
	    if (_class == null) defineTransletClasses();
	}
	catch (TransformerConfigurationException e) {
	    
	}
	return _class;
    }

    
    public synchronized int getTransletIndex() {
	try {
	    if (_class == null) defineTransletClasses();
	}
	catch (TransformerConfigurationException e) {
	    
	}
	return _transletIndex;
    }

    
    protected synchronized void setTransletName(String name) {
	_name = name;
    }

    
    protected synchronized String getTransletName() {
	return _name;
    }

    
    private void defineTransletClasses()
	throws TransformerConfigurationException {

	if (_bytecodes == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.NO_TRANSLET_CLASS_ERR);
	    throw new TransformerConfigurationException(err.toString());
	}

	TransletClassLoader loader = 
	    (TransletClassLoader) AccessController.doPrivileged(
		new PrivilegedAction() {
			public Object run() {
			    
			    return new TransletClassLoader(
				Thread.currentThread().getContextClassLoader());
			}
		    }
		);

	try {
	    final int classCount = _bytecodes.length;
	    _class = new Class[classCount];

	    for (int i = 0; i < classCount; i++) {
		_class[i] = loader.defineClass(_bytecodes[i]);
		final Class superClass = _class[i].getSuperclass();

		
		if (superClass.getName().equals(ABSTRACT_TRANSLET)) {
		    _transletIndex = i;
		}
	    }

	    if (_transletIndex < 0) {
		ErrorMsg err= new ErrorMsg(ErrorMsg.NO_MAIN_TRANSLET_ERR, _name);
		throw new TransformerConfigurationException(err.toString());
	    }
	}
	catch (ClassFormatError e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_CLASS_ERR, _name);
	    throw new TransformerConfigurationException(err.toString());
	}
	catch (LinkageError e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
	    throw new TransformerConfigurationException(err.toString());
	}
    }

    
    private Translet getTransletInstance()
	throws TransformerConfigurationException {
	try {
	    if (_name == null) return null;

	    if (_class == null) defineTransletClasses();

	    
	    
	    Translet translet = (Translet) _class[_transletIndex].newInstance();
	    final int classCount = _bytecodes.length;
	    for (int i = 0; i < classCount; i++) {
		if (i != _transletIndex) {
		    translet.addAuxiliaryClass(_class[i]);
		}
	    }
	    return translet;
	}
	catch (InstantiationException e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
	    throw new TransformerConfigurationException(err.toString());
	}
	catch (IllegalAccessException e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TRANSLET_OBJECT_ERR, _name);
	    throw new TransformerConfigurationException(err.toString());
	}
    }

    
    public synchronized Transformer newTransformer()
	throws TransformerConfigurationException 
    {
	final TransformerImpl transformer =
	    new TransformerImpl(getTransletInstance(), _outputProperties,
			        _indentNumber, _tfactory);
	if (_uriResolver != null) {
	    transformer.setURIResolver(_uriResolver);
	}
	return transformer;
    }

    
    public synchronized Properties getOutputProperties() { 
	try {
	    return newTransformer().getOutputProperties();
	}
	catch (TransformerConfigurationException e) {
	    return null;
	}
    }

}

"
org.apache.xalan.xsltc.compiler.Key,6,3,0,42,56,0,1,41,5,0.55,531,1.0,4,0.923076923,0.361111111,2,4,86.83333333,4,1.6667,1,"

package org.apache.xalan.xsltc.compiler;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.compiler.util.Type;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.dom.Axis;

final class Key extends TopLevelElement {

    private QName      _name;     
    private Pattern    _match;    
    private Expression _use;      
    private Type       _useType;  

    
    public void parseContents(Parser parser) {

	
	_name = parser.getQNameIgnoreDefaultNs(getAttribute(""name""));
	_match = parser.parsePattern(this, ""match"", null);
	_use = parser.parseExpression(this, ""use"", null);

        
        if (_name == null) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""name"");
	    return;
        }
        if (_match.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""match"");
	    return;
        }
        if (_use.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""use"");
	    return;
        }
    }

    
    public String getName() {
	return _name.toString();
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_match.typeCheck(stable);
	_useType = _use.typeCheck(stable);

	
	if (_useType instanceof NodeType) {
	    _use = new CastExpr(_use, Type.String);
	    _useType = Type.String;
	}

	
	if (!(_useType instanceof StringType) &&
	    !(_useType instanceof NodeSetType) &&
	    !(_useType instanceof RealType)) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.KEY_USE_ATTR_ERR, this);
	    throw new TypeCheckError(err);
	}

	return Type.Void;
    }

    
    public void traverseNodeSet(ClassGenerator classGen,
				MethodGenerator methodGen,
				int buildKeyIndex) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getNodeValue = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getNodeValue"",
							   ""(I)""+STRING_SIG);

	
	
	
	final LocalVariableGen parentNode =
	    methodGen.addLocalVariable(""parentNode"",
				       Util.getJCRefType(""I""),
				       il.getEnd(), null);

	
	il.append(new ISTORE(parentNode.getIndex()));

	
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadIterator());

	
	_use.translate(classGen, methodGen);
	_use.startResetIterator(classGen, methodGen);
	il.append(methodGen.storeIterator());

	final BranchHandle nextNode = il.append(new GOTO(null));
	final InstructionHandle loop = il.append(NOP);

	
	il.append(classGen.loadTranslet());
	
	il.append(new PUSH(cpg, _name.toString()));
	il.append(new ILOAD(parentNode.getIndex()));

	
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadCurrentNode());
	il.append(new INVOKEINTERFACE(getNodeValue, 2));

	
	il.append(new INVOKEVIRTUAL(buildKeyIndex));

	nextNode.setTarget(il.append(methodGen.loadIterator()));
	il.append(methodGen.nextNode());

	il.append(DUP);
	il.append(methodGen.storeCurrentNode());
	il.append(new IFNE(loop)); 

	
	il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int current = methodGen.getLocalIndex(""current"");

	
	final int key = cpg.addMethodref(TRANSLET_CLASS,
					 ""buildKeyIndex"",
					 ""(""+STRING_SIG+""I""+OBJECT_SIG+"")V"");

	
	final int git = cpg.addInterfaceMethodref(DOM_INTF,
						  ""getAxisIterator"",
						  ""(I)""+NODE_ITERATOR_SIG);

	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadIterator());

	
	il.append(methodGen.loadDOM());	
	il.append(new PUSH(cpg,Axis.DESCENDANT));
	il.append(new INVOKEINTERFACE(git, 2));

	
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.setStartNode());
	il.append(methodGen.storeIterator());

	
	final BranchHandle nextNode = il.append(new GOTO(null));
	final InstructionHandle loop = il.append(NOP);

	
	il.append(methodGen.loadCurrentNode());
	_match.translate(classGen, methodGen);
	_match.synthesize(classGen, methodGen); 
	final BranchHandle skipNode = il.append(new IFEQ(null));
	
	
	
	if (_useType instanceof RealType) {
	    final int dbl = cpg.addMethodref(DOUBLE_CLASS,""<init>"", ""(D)V"");

	    il.append(classGen.loadTranslet());
	    il.append(new PUSH(cpg, _name.toString()));
	    il.append(methodGen.loadCurrentNode());
	    il.append(new NEW(cpg.addClass(DOUBLE_CLASS)));
	    il.append(DUP);
	    _use.translate(classGen,methodGen);
	    il.append(new INVOKESPECIAL(dbl));
	    il.append(new INVOKEVIRTUAL(key));

	}
	else if (_useType instanceof StringType) {
	    il.append(classGen.loadTranslet());
	    il.append(new PUSH(cpg, _name.toString()));
	    il.append(methodGen.loadCurrentNode());
	    _use.translate(classGen,methodGen);
	    il.append(new INVOKEVIRTUAL(key));
	}
	
	
	else {
	    
	    il.append(methodGen.loadCurrentNode());
	    traverseNodeSet(classGen,methodGen,key);
	}
	
	
	final InstructionHandle skip = il.append(NOP);
	
	il.append(methodGen.loadIterator());
	il.append(methodGen.nextNode());
	il.append(DUP);
	il.append(methodGen.storeCurrentNode());
	il.append(new IFNE(loop));

	
	il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
	
	nextNode.setTarget(skip);
	skipNode.setTarget(skip);
    }
}
"
org.apache.xalan.xsltc.runtime.AbstractTranslet,36,1,0,25,96,516,10,16,35,0.929142857,831,0.52,9,0.0,0.142592593,0,0,21.38888889,12,2.0556,0,"

package org.apache.xalan.xsltc.runtime;

import java.io.FileWriter;
import java.util.ArrayList;
import java.util.Enumeration;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;

import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.dom.DOMAdapter;
import org.apache.xalan.xsltc.dom.DOMImpl;
import org.apache.xalan.xsltc.dom.KeyIndex;
import org.apache.xalan.xsltc.dom.DTDMonitor;
import org.apache.xalan.xsltc.util.IntegerArray;
import org.apache.xalan.xsltc.runtime.output.*;

public abstract class AbstractTranslet implements Translet {

    
    
    public String  _version = ""1.0"";
    public String  _method = null;
    public String  _encoding = ""UTF-8"";
    public boolean _omitHeader = false;
    public String  _standalone = null;
    public String  _doctypePublic = null;
    public String  _doctypeSystem = null;
    public boolean _indent = false;
    public String  _mediaType = null;
    public Hashtable _cdata = null;

    
    protected String[] namesArray;
    protected String[] namespaceArray;

    
    protected StringValueHandler stringValueHandler = new StringValueHandler();

    
    private final static String EMPTYSTRING = """";

    
    
    public void printInternalState() {
	System.out.println(""-------------------------------------"");
	System.out.println(""AbstractTranslet this = "" + this);
	System.out.println(""pbase = "" + pbase);
	System.out.println(""vframe = "" + pframe);
	System.out.println(""paramsStack.size() = "" + paramsStack.size());
	System.out.println(""namesArray.size = "" + namesArray.length);
	System.out.println(""namespaceArray.size = "" + namespaceArray.length);
	System.out.println("""");
	System.out.println(""Total memory = "" + Runtime.getRuntime().totalMemory());
    }

    
    public final DOMAdapter makeDOMAdapter(DOM dom)
	throws TransletException {
	if (dom instanceof DOMImpl)
	    return new DOMAdapter((DOMImpl)dom, namesArray, namespaceArray);
	BasisLibrary.runTimeError(BasisLibrary.DOM_ADAPTER_INIT_ERR);
	return null;
    }

    

    
    
    protected int pbase = 0, pframe = 0;
    protected ArrayList paramsStack = new ArrayList();

    
    public final void pushParamFrame() {
	paramsStack.add(pframe, new Integer(pbase));
	pbase = ++pframe;
    }

    
    public final void popParamFrame() {
	if (pbase > 0) {
	    final int oldpbase = ((Integer)paramsStack.get(--pbase)).intValue();
	    for (int i = pframe - 1; i >= pbase; i--) {
		paramsStack.remove(i);
	    }
	    pframe = pbase; pbase = oldpbase;
	}
    }

    
    public final Object addParameter(String name, Object value) {
	name = BasisLibrary.replace(name, "".-"", 
				    new String[] { ""$dot$"", ""$dash$"" });
	return addParameter(name, value, false);
    }

    
    public final Object addParameter(String name, Object value, 
	boolean isDefault) 
    {
	
	for (int i = pframe - 1; i >= pbase; i--) {
	    final Parameter param = (Parameter) paramsStack.get(i);

	    if (param._name.equals(name)) {
		
		
		if (param._isDefault || !isDefault) {
		    param._value = value;
		    param._isDefault = isDefault;
		    return value;
		}
		return param._value;
	    }
	}

	
	paramsStack.add(pframe++, new Parameter(name, value, isDefault));
	return value;
    }

    
    public void clearParameters() {  
	pbase = pframe = 0;
	paramsStack.clear();
    }

    
    public final Object getParameter(String name) {
	for (int i = pframe - 1; i >= pbase; i--) {
	    final Parameter param = (Parameter)paramsStack.get(i);
	    if (param._name.equals(name)) return param._value;
	}
	return null;
    }

    

    
    
    
    private MessageHandler _msgHandler = null;

    
    public final void setMessageHandler(MessageHandler handler) {
	_msgHandler = handler;
    }

    
    public final void displayMessage(String msg) {
	if (_msgHandler == null) {
            System.err.println(msg);
	}
	else {
	    _msgHandler.displayMessage(msg);
	}
    }

    

    
    public Hashtable _formatSymbols = null;

    
    public void addDecimalFormat(String name, DecimalFormatSymbols symbols) {
	
	if (_formatSymbols == null) _formatSymbols = new Hashtable();

	
	if (name == null) name = EMPTYSTRING;

	
	final DecimalFormat df = new DecimalFormat();
	if (symbols != null) {
	    df.setDecimalFormatSymbols(symbols);
	}
	_formatSymbols.put(name, df);
    }

    
    public final DecimalFormat getDecimalFormat(String name) {

	if (_formatSymbols != null) {
	    
	    if (name == null) name = EMPTYSTRING;

	    DecimalFormat df = (DecimalFormat)_formatSymbols.get(name);
	    if (df == null) df = (DecimalFormat)_formatSymbols.get(EMPTYSTRING);
	    return df;
	}
	return(null);
    }

    

    
    public Hashtable _unparsedEntities = null;

    
    public final String getUnparsedEntity(String name) {
	final String uri = (String)_unparsedEntities.get(name);
	return uri == null ? EMPTYSTRING : uri;
    }

    
    public final void addUnparsedEntity(String name, String uri) {
	if (_unparsedEntities == null)
	    _unparsedEntities = new Hashtable();
	if (_unparsedEntities.containsKey(name) == false)
	    _unparsedEntities.put(name, uri);
    }
    
    
    public final void setUnparsedEntityURIs(Hashtable table) {
	if (_unparsedEntities == null)
	    _unparsedEntities = table;
	else {
	    Enumeration keys = table.keys();
	    while (keys.hasMoreElements()) {
		String name = (String)keys.nextElement();
		_unparsedEntities.put(name,table.get(name));
	    }
	}
    }

    
    public final void setDTDMonitor(DTDMonitor monitor) {
	setUnparsedEntityURIs(monitor.getUnparsedEntityURIs());
    }

    

    
    private Hashtable _keyIndexes = null;
    private KeyIndex  _emptyKeyIndex = new KeyIndex(1);
    private int       _indexSize = 0;

    
    public void setIndexSize(int size) {
	if (size > _indexSize) _indexSize = size;
    }

    
    public KeyIndex createKeyIndex() {
	return(new KeyIndex(_indexSize));
    }

    
    public void buildKeyIndex(String name, int node, Object value) {
	if (_keyIndexes == null) _keyIndexes = new Hashtable();
	
	KeyIndex index = (KeyIndex)_keyIndexes.get(name);
	if (index == null) {
	    _keyIndexes.put(name, index = new KeyIndex(_indexSize));
	}
	index.add(value, node);
    }

    
    public KeyIndex getKeyIndex(String name) {
	
	if (_keyIndexes == null) return(_emptyKeyIndex);

	
	final KeyIndex index = (KeyIndex)_keyIndexes.get(name);

	
	if (index == null) return(_emptyKeyIndex);

	return(index);
    }

    
    public void buildKeys(DOM document, NodeIterator iterator,
			  TransletOutputHandler handler,
			  int root) throws TransletException {
    }

    

    
    private DOMCache _domCache = null;

    
    public void setDOMCache(DOMCache cache) {
	_domCache = cache;
    }

    
    public DOMCache getDOMCache() {
	return(_domCache);
    }

    

    public TransletOutputHandler openOutputHandler(String filename) 
	throws TransletException 
    {
	try {
	    final TransletOutputHandlerFactory factory 
		= TransletOutputHandlerFactory.newInstance();

	    factory.setEncoding(_encoding);
	    factory.setOutputMethod(_method);
	    factory.setWriter(new FileWriter(filename));
	    factory.setOutputType(TransletOutputHandlerFactory.STREAM);

	    final TransletOutputHandler handler 
		= factory.getTransletOutputHandler();

	    transferOutputSettings(handler);
	    handler.startDocument();
	    return handler;
	}
	catch (Exception e) {
	    throw new TransletException(e);
	}
    }

    public void closeOutputHandler(TransletOutputHandler handler) {
	try {
	    handler.endDocument();
	    handler.close();
	}
	catch (Exception e) {
	    
	}
    }

    

    
    public abstract void transform(DOM document, NodeIterator iterator,
				   TransletOutputHandler handler)
	throws TransletException;

    
    public final void transform(DOM document, TransletOutputHandler handler) 
	throws TransletException {
	transform(document, document.getIterator(), handler);
    }
	
    
    public final void characters(final String string,
				 TransletOutputHandler handler) 
	throws TransletException {
	final int length = string.length();
	handler.characters(string.toCharArray(), 0, length);
    }

    
    public void addCdataElement(String name) {
	if (_cdata == null) _cdata = new Hashtable();
	_cdata.put(name, name);
    }

    
    protected void transferOutputSettings(TransletOutputHandler handler) {
	if (_method != null) {
	    if (_method.equals(""xml"")) {
	        if (_standalone != null) {
		    handler.setStandalone(_standalone);
		}
		if (_omitHeader) {
		    handler.omitHeader(true);
		}
		handler.setCdataElements(_cdata);
		if (_version != null) {
		    handler.setVersion(_version);
		}
		handler.setIndent(_indent);
		if (_doctypeSystem != null) {
		    handler.setDoctype(_doctypeSystem, _doctypePublic);
		}
	    }
	    else if (_method.equals(""html"")) {
		handler.setIndent(_indent);
		handler.setDoctype(_doctypeSystem, _doctypePublic);
		if (_mediaType != null) {
		    handler.setMediaType(_mediaType);
		}
	    }
	}
	else {
	    handler.setCdataElements(_cdata);
	    if (_version != null) {
		handler.setVersion(_version);
	    }
	    if (_standalone != null) {
		handler.setStandalone(_standalone);
	    }
	    if (_omitHeader) {
		handler.omitHeader(true);
	    }
	    handler.setIndent(_indent);
	    handler.setDoctype(_doctypeSystem, _doctypePublic);
	}
    }

    private Hashtable _auxClasses = null;

    public void addAuxiliaryClass(Class auxClass) {
	if (_auxClasses == null) _auxClasses = new Hashtable();
	_auxClasses.put(auxClass.getName(), auxClass);
    }

    public Class getAuxiliaryClass(String className) {
	if (_auxClasses == null) return null;
	return((Class)_auxClasses.get(className));
    }

    
    public String[] getNamesArray() {
	return namesArray;
    }
    public String[] getNamespaceArray() {
	return namespaceArray;
    }
}
"
org.apache.xpath.functions.FuncGenerateId,2,5,0,4,10,1,0,4,2,2.0,28,0.0,0,0.982142857,0.75,2,7,13.0,1,0.5,0,"
package org.apache.xpath.functions;



import org.apache.xml.dtm.DTM;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncGenerateId extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int which = getArg0AsNode(xctxt);

    if (DTM.NULL != which)
    {
      
      
      
      
      
      
      return new XString(""N"" + Integer.toHexString(which).toUpperCase());
    }
    else
      return XString.EMPTYSTRING;
  }
}
"
org.apache.xml.dtm.DTMAxisTraverser,5,1,12,28,6,10,28,0,5,2.0,19,0.0,0,0.0,0.9,0,0,2.8,1,0.8,0,"
package org.apache.xml.dtm;


public abstract class DTMAxisTraverser
{

  
  public int first(int context)
  {
    return next(context, context);
  }

  
  public int first(int context, int extendedTypeID)
  {
    return next(context, context, extendedTypeID);
  }

  
  public abstract int next(int context, int current);

  
  public abstract int next(int context, int current, int extendedTypeID);
}
"
org.apache.xpath.axes.AttributeIterator,3,7,0,5,6,3,1,4,1,2.0,31,0.0,0,0.985185185,0.555555556,3,5,9.333333333,2,1.0,0,"
package org.apache.xpath.axes;

import javax.xml.transform.TransformerException;

import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.objects.XObject;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMFilter;


public class AttributeIterator extends ChildTestIterator
{

  
  AttributeIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis);
  }
    
  
  protected int getNextNode()
  {
    m_lastFetched = (DTM.NULL == m_lastFetched)
                     ? m_cdtm.getFirstAttribute(m_context)
                     : m_cdtm.getNextAttribute(m_lastFetched);
    return m_lastFetched;
  }
  
  
  public int getAxis()
  {
    return org.apache.xml.dtm.Axis.ATTRIBUTE;
  }



}
"
org.apache.xalan.xsltc.compiler.CopyOf,5,3,0,26,32,0,1,25,4,0.25,253,1.0,1,0.933333333,0.333333333,1,3,49.4,5,1.8,0,"

package org.apache.xalan.xsltc.compiler;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class CopyOf extends Instruction {
    private Expression _select;
	
    public void display(int indent) {
	indent(indent);
	Util.println(""CopyOf"");
	indent(indent + IndentIncrement);
	Util.println(""select "" + _select.toString());
    }

    public void parseContents(Parser parser) {
	_select = parser.parseExpression(this, ""select"", null);
        
        if (_select.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""select"");
	    return;
        }
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tselect = _select.typeCheck(stable);
	if (tselect instanceof NodeType ||
	    tselect instanceof NodeSetType ||
	    tselect instanceof ReferenceType ||
	    tselect instanceof ResultTreeType) {
	    
	}
	else {
	    _select = new CastExpr(_select, Type.String);
	}
	return Type.Void;
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final Type tselect = _select.getType();

	final String CPY1_SIG = ""(""+NODE_ITERATOR_SIG+TRANSLET_OUTPUT_SIG+"")V"";
	final int cpy1 = cpg.addInterfaceMethodref(DOM_INTF, ""copy"", CPY1_SIG);

	final String CPY2_SIG = ""(""+NODE_SIG+TRANSLET_OUTPUT_SIG+"")V"";
	final int cpy2 = cpg.addInterfaceMethodref(DOM_INTF, ""copy"", CPY2_SIG);

	if (tselect instanceof NodeSetType) {
	    il.append(methodGen.loadDOM());

	    
	    _select.translate(classGen, methodGen);	
	    _select.startResetIterator(classGen, methodGen);

	    
	    il.append(methodGen.loadHandler());
	    il.append(new INVOKEINTERFACE(cpy1, 3));
	}
	else if (tselect instanceof NodeType) {
	    il.append(methodGen.loadDOM());
	    _select.translate(classGen, methodGen);	
	    il.append(methodGen.loadHandler());
	    il.append(new INVOKEINTERFACE(cpy2, 3));
	}
	else if (tselect instanceof ResultTreeType) {
	    _select.translate(classGen, methodGen);	
	    
	    il.append(ICONST_1);
	    il.append(methodGen.loadHandler());
	    il.append(new INVOKEINTERFACE(cpy2, 3));
	}
	else if (tselect instanceof ReferenceType) {
	    _select.translate(classGen, methodGen);
	    il.append(methodGen.loadHandler());
	    il.append(methodGen.loadCurrentNode());
	    il.append(methodGen.loadDOM());
	    final int copy = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""copy"",
					      ""("" 
					      + OBJECT_SIG  
					      + TRANSLET_OUTPUT_SIG 
					      + NODE_SIG
					      + DOM_INTF_SIG
					      + "")V"");
	    il.append(new INVOKESTATIC(copy));
	}
	else {
	    il.append(classGen.loadTranslet());
	    _select.translate(classGen, methodGen);
	    il.append(methodGen.loadHandler());
	    il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
							 CHARACTERSW,
							 CHARACTERSW_SIG)));
	}

    }
}
"
org.apache.xalan.xsltc.compiler.Output,6,3,0,21,40,0,2,21,5,0.8,706,1.0,0,0.923076923,0.333333333,3,7,114.3333333,28,7.3333,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Properties;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.io.OutputStreamWriter;
import javax.xml.transform.OutputKeys;

import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.JavaClass;

import org.apache.xalan.xsltc.compiler.util.*;

final class Output extends TopLevelElement {

    

    
    
    private String  _version;
    private String  _method;
    private String  _encoding;
    private boolean _omitHeader = false;
    private String  _standalone;
    private String  _doctypePublic;
    private String  _doctypeSystem;
    private String  _cdata;
    private boolean _indent = false;
    private String  _mediaType;

    
    private boolean _disabled = false;

    
    private final static String STRING_SIG = ""Ljava/lang/String;"";
    private final static String XML_VERSION = ""1.0"";
    private final static String HTML_VERSION = ""4.0"";

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Output "" + _method);
    }

    
    public void disable() {
	_disabled = true;
    }

    public boolean enabled() {
	return !_disabled;
    }

    
    public void parseContents(Parser parser) {
	final Properties outputProperties = new Properties();

	
	parser.setOutput(this);

	
	if (_disabled) return;

	String attrib = null;

	
	_version = getAttribute(""version"");
	if (_version == null || _version.equals(Constants.EMPTYSTRING)) {
	    _version = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.VERSION, _version);
	}

	
	_method = getAttribute(""method"");
	if (_method.equals(Constants.EMPTYSTRING)) {
	    _method = null;
	}
	if (_method != null) {
	    _method = _method.toLowerCase();
	    outputProperties.setProperty(OutputKeys.METHOD, _method);
	}

	
	_encoding = getAttribute(""encoding"");
	if (_encoding.equals(Constants.EMPTYSTRING)) {
	    _encoding = null;
	}
	else {
	    try {
		OutputStreamWriter writer =
		    new OutputStreamWriter(System.out, _encoding);
	    }
	    catch (java.io.UnsupportedEncodingException e) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.UNSUPPORTED_ENCODING,
					    _encoding, this);
		parser.reportError(Constants.WARNING, msg);
	    }
	    outputProperties.setProperty(OutputKeys.ENCODING, _encoding);
	}

	
	attrib = getAttribute(""omit-xml-declaration"");
	if (attrib != null && !attrib.equals(Constants.EMPTYSTRING)) {
	    if (attrib.equals(""yes"")) {
		_omitHeader = true;
	    }
	    outputProperties.setProperty(OutputKeys.OMIT_XML_DECLARATION, attrib);
	}

	
	_standalone = getAttribute(""standalone"");
	if (_standalone.equals(Constants.EMPTYSTRING)) {
	    _standalone = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.STANDALONE, _standalone);
	}

	
	_doctypeSystem = getAttribute(""doctype-system"");
	if (_doctypeSystem.equals(Constants.EMPTYSTRING)) {
	    _doctypeSystem = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, _doctypeSystem);
	}


	_doctypePublic = getAttribute(""doctype-public"");
	if (_doctypePublic.equals(Constants.EMPTYSTRING)) {
	    _doctypePublic = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, _doctypePublic);
	}

	
	_cdata = getAttribute(""cdata-section-elements"");
	if (_cdata != null && _cdata.equals(Constants.EMPTYSTRING)) {
	    _cdata = null;
	}
	else {
	    StringBuffer expandedNames = new StringBuffer();
	    StringTokenizer tokens = new StringTokenizer(_cdata);

	    
	    while (tokens.hasMoreTokens()) {
		expandedNames.append(parser.getQName(tokens.nextToken()).toString())
			     .append(' ');
	    }
	    _cdata = expandedNames.toString();

	    outputProperties.setProperty(OutputKeys.CDATA_SECTION_ELEMENTS, _cdata);
	}

	
	attrib = getAttribute(""indent"");
	if (attrib != null && !attrib.equals(EMPTYSTRING)) {
	    if (attrib.equals(""yes"")) {
		_indent = true;
	    }
	    outputProperties.setProperty(OutputKeys.INDENT, attrib);
	}
	else if (_method != null && _method.equals(""html"")) {
	    _indent = true;
	}

	
	_mediaType = getAttribute(""media-type"");
	if (_mediaType.equals(Constants.EMPTYSTRING)) {
	    _mediaType = null;
	}
	else {
	    outputProperties.setProperty(OutputKeys.MEDIA_TYPE, _mediaType);
	}

	
	if (_method != null) {
	    if (_method.equals(""html"")) {
		if (_version == null) {
		    _version = HTML_VERSION;
		}
		if (_mediaType == null) {
		    _mediaType = ""text/html"";
		}
	    }
	    else if (_method.equals(""text"")) {
		if (_mediaType == null) {
		    _mediaType = ""text/plain"";
		}
	    }
	}

	
	parser.getCurrentStylesheet().setOutputProperties(outputProperties);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	
	if (_disabled) return;

	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();

	int field = 0;
        il.append(classGen.loadTranslet());

	
	if ((_version != null) && (!_version.equals(XML_VERSION))) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_version"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _version));
	    il.append(new PUTFIELD(field));
	}

	
	if (_method != null) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_method"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _method));
	    il.append(new PUTFIELD(field));
	}

	
	if (_encoding != null) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_encoding"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _encoding));
	    il.append(new PUTFIELD(field));
	}

	
	if (_omitHeader) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_omitHeader"", ""Z"");
	    il.append(DUP);
	    il.append(new PUSH(cpg, _omitHeader));
	    il.append(new PUTFIELD(field));
	}

	
	if (_standalone != null) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_standalone"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _standalone));
	    il.append(new PUTFIELD(field));
	}

	
	field = cpg.addFieldref(TRANSLET_CLASS,""_doctypeSystem"",STRING_SIG);
	il.append(DUP);
	il.append(new PUSH(cpg, _doctypeSystem));
	il.append(new PUTFIELD(field));
	field = cpg.addFieldref(TRANSLET_CLASS,""_doctypePublic"",STRING_SIG);
	il.append(DUP);
	il.append(new PUSH(cpg, _doctypePublic));
	il.append(new PUTFIELD(field));
	
	
	if (_mediaType != null) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_mediaType"", STRING_SIG);
	    il.append(DUP);
	    il.append(new PUSH(cpg, _mediaType));
	    il.append(new PUTFIELD(field));
	}

	
	if (_indent) {
	    field = cpg.addFieldref(TRANSLET_CLASS, ""_indent"", ""Z"");
	    il.append(DUP);
	    il.append(new PUSH(cpg, _indent));
	    il.append(new PUTFIELD(field));
	}

	
	if (_cdata != null) {
	    int index = cpg.addMethodref(TRANSLET_CLASS,
					 ""addCdataElement"",
					 ""(Ljava/lang/String;)V"");

	    StringTokenizer tokens = new StringTokenizer(_cdata);
	    while (tokens.hasMoreTokens()) {
		il.append(DUP);
		il.append(new PUSH(cpg, tokens.nextToken()));
		il.append(new INVOKEVIRTUAL(index));
	    }
	}
	il.append(POP); 
    }

}
"
org.apache.xpath.SourceTree,1,1,0,1,2,0,1,0,1,2.0,12,0.0,0,0.0,1.0,0,0,9.0,0,0.0,0,"
package org.apache.xpath;




public class SourceTree
{

  
  public SourceTree(int root, String url)
  {
    m_root = root;
    m_url = url;
  }

  
  public String m_url;

  
  public int m_root;
}
"
org.apache.xalan.xsltc.compiler.util.CompareGenerator,11,5,0,16,23,37,3,13,10,0.916666667,141,1.0,0,0.93877551,0.225,2,5,10.72727273,2,0.9091,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.*;

import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.xalan.xsltc.compiler.Template;

public final class CompareGenerator extends MethodGenerator {

    private static int DOM_INDEX      = 1;
    private static int CURRENT_INDEX  = 2;
    private static int LEVEL_INDEX    = 3;
    private static int TRANSLET_INDEX = 4;
    private static int LAST_INDEX     = 5;
    private int ITERATOR_INDEX = 6;

    private final Instruction _iloadCurrent;
    private final Instruction _istoreCurrent;
    private final Instruction _aloadDom;
    private final Instruction _iloadLast;
    private final Instruction _aloadIterator;
    private final Instruction _astoreIterator;

    public CompareGenerator(int access_flags, Type return_type,
			    Type[] arg_types, String[] arg_names,
			    String method_name, String class_name,
			    InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
	
	_iloadCurrent = new ILOAD(CURRENT_INDEX);
	_istoreCurrent = new ISTORE(CURRENT_INDEX);
	_aloadDom = new ALOAD(DOM_INDEX);
	_iloadLast = new ILOAD(LAST_INDEX);

	LocalVariableGen iterator =
	    addLocalVariable(""iterator"",
			     Util.getJCRefType(Constants.NODE_ITERATOR_SIG),
			     null, null);
	ITERATOR_INDEX = iterator.getIndex();
	_aloadIterator = new ALOAD(ITERATOR_INDEX);
	_astoreIterator = new ASTORE(ITERATOR_INDEX);
	il.append(new ACONST_NULL());
	il.append(storeIterator());
    }

    public Instruction loadLastNode() {
	return _iloadLast;
    }

    public Instruction loadCurrentNode() {
	return _iloadCurrent;
    }

    public Instruction storeCurrentNode() {
	return _istoreCurrent;
    }

    public Instruction loadDOM() {
	return _aloadDom;
    }

    public int getHandlerIndex() {
	return INVALID_INDEX;		
    }

    public int getIteratorIndex() {
	return INVALID_INDEX;
    }

    public Instruction storeIterator() {
	return _astoreIterator;
    }
    
    public Instruction loadIterator() {
	return _aloadIterator;
    }

    
    public int getLocalIndex(String name) {
	if (name.equals(""current"")) {
	    return CURRENT_INDEX;
	}
	return super.getLocalIndex(name);
    }
}
"
org.apache.xpath.axes.ChildIterator,4,5,0,6,9,6,1,5,3,2.0,64,0.0,0,0.9765625,0.4375,1,6,15.0,4,1.5,0,"
package org.apache.xpath.axes;

import javax.xml.transform.TransformerException;

import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.XPathContext;
import org.apache.xml.utils.PrefixResolver;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;


public class ChildIterator extends LocPathIterator
{

  
  ChildIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, false);
  }
  
  
  public int asNode(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
    int current = xctxt.getCurrentNode();
    
    DTM dtm = xctxt.getDTM(current);
    
    return dtm.getFirstChild(current);
  }

  
  public int nextNode()
  {
  	if(m_foundLast)
  		return DTM.NULL;

    int next;

    m_lastFetched = next = (DTM.NULL == m_lastFetched)
                           ? m_cdtm.getFirstChild(m_context)
                           : m_cdtm.getNextSibling(m_lastFetched);

    
    if (DTM.NULL != next)
    {
      m_pos++;
      return next;
    }
    else
    {
      m_foundLast = true;

      return DTM.NULL;
    }
  }
  
  
  public int getAxis()
  {
    return org.apache.xml.dtm.Axis.CHILD;
  }


}
"
org.apache.xml.dtm.DTMIterator,25,1,0,53,25,300,52,2,25,1.041666667,28,0.0,0,0.0,0.34,0,0,0.0,1,1.0,0,"
package org.apache.xml.dtm;


public interface DTMIterator
{

  
  
  

  
  public static final short FILTER_ACCEPT = 1;

  
  public static final short FILTER_REJECT = 2;

  
  public static final short FILTER_SKIP = 3;
    
  
  public DTM getDTM(int nodeHandle);
  
  
  public DTMManager getDTMManager();

  
  public int getRoot();

  
  public void setRoot(int nodeHandle, Object environment);
  
  
  public void reset();

  
  public int getWhatToShow();

  
  public boolean getExpandEntityReferences();

  
  public int nextNode();

  
  public int previousNode();

  
  public void detach();
  
  
  public void allowDetachToRelease(boolean allowRelease);

  
  public int getCurrentNode();

  
  public boolean isFresh();

  

  
  public void setShouldCacheNodes(boolean b);
  
  
  public boolean isMutable();

  
  public int getCurrentPos();

  
  public void runTo(int index);

  
  public void setCurrentPos(int i);

  
  public int item(int index);
  
  
  public void setItem(int node, int index);
  
  
  public int getLength();
    
  
  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException;

  
  public Object clone() throws CloneNotSupportedException;
  
  
  public boolean isDocOrdered();
  
  
  public int getAxis();

}
"
org.apache.xpath.Arg,15,1,0,3,21,0,1,2,15,0.628571429,158,1.0,2,0.0,0.311111111,0,0,9.2,2,0.8667,0,"
package org.apache.xpath;

import org.apache.xml.utils.QName;
import org.apache.xpath.objects.XObject;


public class Arg
{

  
  private QName m_qname;

  
  public final QName getQName()
  {
    return m_qname;
  }

  
  public final void setQName(QName name)
  {
    m_qname = name;
  }

  
  private XObject m_val;

  
  public final XObject getVal()
  {
    return m_val;
  }

  
  public final void setVal(XObject val)
  {
    m_val = val;
  }
  
  
  public void detach()
  {
    if(null != m_val)
    {
      m_val.allowDetachToRelease(true);
      m_val.detach();
    }
  }


  
  private String m_expression;

  
  public String getExpression()
  {
    return m_expression;
  }

  
  public void setExpression(String expr)
  {
    m_expression = expr;
  }

  
  private boolean m_isFromWithParam;

  
   public boolean isFromWithParam()
   {
    return m_isFromWithParam;
   }

  
  private boolean m_isVisible;

  
   public boolean isVisible()
   {
    return m_isVisible;
   }
   
  
   public void setIsVisible(boolean b)
   {
    m_isVisible = b;
   }

  
  public Arg()
  {

    m_qname = new QName("""");
    ;  
    m_val = null;
    m_expression = null;
    m_isVisible = true;
    m_isFromWithParam = false;
  }

  
  public Arg(QName qname, String expression, boolean isFromWithParam)
  {

    m_qname = qname;
    m_val = null;
    m_expression = expression;
    m_isFromWithParam = isFromWithParam;
    m_isVisible = !isFromWithParam;
  }

  
  public Arg(QName qname, XObject val)
  {

    m_qname = qname;
    m_val = val;
    m_isVisible = true;
    m_isFromWithParam = false;
    m_expression = null;
  }
  
  
  public boolean equals(Object obj) 
  {
    if(obj instanceof QName)
    {
      return m_qname.equals(obj);
    }
    else
      return super.equals(obj);
  }

  
  public Arg(QName qname, XObject val, boolean isFromWithParam)
  {

    m_qname = qname;
    m_val = val;
    m_isFromWithParam = isFromWithParam;
    m_isVisible = !isFromWithParam;
    m_expression = null;
  }
}
"
org.apache.xalan.xsltc.compiler.RealExpr,4,3,0,13,14,0,0,13,4,0.333333333,44,1.0,0,0.959459459,0.4,2,7,9.75,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class RealExpr extends Expression {
    private double _value;

    public RealExpr(double value) {
	_value = value;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _type = Type.Real;
    }

    public String toString() {
	return ""real-expr("" + _value + ')';
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }
}
"
org.apache.xalan.trace.GenerateEvent,5,1,0,5,6,0,4,1,5,1.0,92,0.0,1,0.0,0.666666667,0,0,13.8,0,0.0,0,"
package org.apache.xalan.trace;

import org.xml.sax.*;

import java.util.*;

import java.io.*;

import org.apache.xalan.transformer.TransformerImpl;


public class GenerateEvent implements java.util.EventListener
{

  
  public TransformerImpl m_processor;

  
  public int m_eventtype;

  
  public static final int EVENTTYPE_STARTDOCUMENT = 1;

  
  public static final int EVENTTYPE_ENDDOCUMENT = 2;

  
  public static final int EVENTTYPE_STARTELEMENT = 3;

  
  public static final int EVENTTYPE_ENDELEMENT = 4;

  
  public static final int EVENTTYPE_CHARACTERS = 5;

  
  public static final int EVENTTYPE_IGNORABLEWHITESPACE = 6;

  
  public static final int EVENTTYPE_PI = 7;

  
  public static final int EVENTTYPE_COMMENT = 8;

  
  public static final int EVENTTYPE_ENTITYREF = 9;

  
  public static final int EVENTTYPE_CDATA = 10;

  
  public char m_characters[];

  
  public int m_start;

  
  public int m_length;

  
  public String m_name;

  
  public String m_data;

  
  public Attributes m_atts;

  
  public GenerateEvent(TransformerImpl processor, int eventType)
  {
    m_processor = processor;
    m_eventtype = eventType;
  }

  
  public GenerateEvent(TransformerImpl processor, int eventType, String name,
                       Attributes atts)
  {

    m_name = name;
    m_atts = atts;
    m_processor = processor;
    m_eventtype = eventType;
  }

  
  public GenerateEvent(TransformerImpl processor, int eventType, char ch[],
                       int start, int length)
  {

    m_characters = ch;
    m_start = start;
    m_length = length;
    m_processor = processor;
    m_eventtype = eventType;
  }

  
  public GenerateEvent(TransformerImpl processor, int eventType, String name,
                       String data)
  {

    m_name = name;
    m_data = data;
    m_processor = processor;
    m_eventtype = eventType;
  }

  
  public GenerateEvent(TransformerImpl processor, int eventType, String data)
  {

    m_data = data;
    m_processor = processor;
    m_eventtype = eventType;
  }
}
"
org.apache.xml.dtm.ref.DTMNamedNodeMap,9,1,0,3,16,24,2,2,8,0.708333333,143,0.0,1,0.0,0.4,0,0,14.55555556,3,1.5556,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;
import org.w3c.dom.*;

import java.util.Vector;


public class DTMNamedNodeMap implements NamedNodeMap
{

  
  DTM dtm;

  
  int element;

  
  short m_count = -1;

  
  DTMNamedNodeMap(DTM dtm, int element)
  {
    this.dtm = dtm;
    this.element = element;
  }

  
  public int getLength()
  {

    if (m_count == -1)
    {
      short count = 0;

      for (int n = dtm.getFirstAttribute(element); n != -1;
              n = dtm.getNextAttribute(n))
      {
        ++count;
      }

      m_count = count;
    }

    return (int) m_count;
  }

  
  public Node getNamedItem(String name)
  {

    for (int n = dtm.getFirstAttribute(element); n != -1;
            n = dtm.getNextAttribute(n))
    {
      if (dtm.getNodeName(n).equals(name))
        return dtm.getNode(n);
    }

    return null;
  }

  
  public Node item(int i)
  {

    int count = 0;

    for (int n = dtm.getFirstAttribute(element); n != -1;
            n = dtm.getNextAttribute(n))
    {
      if (count == i)
        return dtm.getNode(n);
      else
        ++count;
    }

    return null;
  }

  
  public Node setNamedItem(Node newNode)
  {
    throw new DTMException(DTMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public Node removeNamedItem(String name)
  {
    throw new DTMException(DTMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public Node getNamedItemNS(String namespaceURI, String localName)
  {
    throw new DTMException(DTMException.NOT_SUPPORTED_ERR);
  }

  
  public Node setNamedItemNS(Node arg) throws DOMException
  {
    throw new DTMException(DTMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public Node removeNamedItemNS(String namespaceURI, String localName)
          throws DOMException
  {
    throw new DTMException(DTMException.NO_MODIFICATION_ALLOWED_ERR);
  }

  
  public class DTMException extends org.w3c.dom.DOMException
  {

    
    public DTMException(short code, String message)
    {
      super(code, message);
    }

    
    public DTMException(short code)
    {
      super(code, """");
    }
  }
}
"
org.apache.xml.utils.NSInfo,3,1,0,1,4,0,1,0,3,0.642857143,55,0.0,0,0.0,0.666666667,0,0,15.0,0,0.0,0,"
package org.apache.xml.utils;


public class NSInfo
{

  
  public NSInfo(boolean hasProcessedNS, boolean hasXMLNSAttrs)
  {

    m_hasProcessedNS = hasProcessedNS;
    m_hasXMLNSAttrs = hasXMLNSAttrs;
    m_namespace = null;
    m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED;
  }

  

  
  public NSInfo(boolean hasProcessedNS, boolean hasXMLNSAttrs,
                int ancestorHasXMLNSAttrs)
  {

    m_hasProcessedNS = hasProcessedNS;
    m_hasXMLNSAttrs = hasXMLNSAttrs;
    m_ancestorHasXMLNSAttrs = ancestorHasXMLNSAttrs;
    m_namespace = null;
  }

  
  public NSInfo(String namespace, boolean hasXMLNSAttrs)
  {

    m_hasProcessedNS = true;
    m_hasXMLNSAttrs = hasXMLNSAttrs;
    m_namespace = namespace;
    m_ancestorHasXMLNSAttrs = ANCESTORXMLNSUNPROCESSED;
  }

  
  public String m_namespace;

  
  public boolean m_hasXMLNSAttrs;

  
  public boolean m_hasProcessedNS;

  
  public int m_ancestorHasXMLNSAttrs;

  
  public static final int ANCESTORXMLNSUNPROCESSED = 0;

  
  public static final int ANCESTORHASXMLNS = 1;

  
  public static final int ANCESTORNOXMLNS = 2;
}
"
org.apache.xalan.xsltc.compiler.FunctionCall,25,3,23,62,126,68,25,37,15,0.848958333,1894,0.9375,4,0.76344086,0.131410256,3,10,74.12,15,2.92,3,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import java.util.Hashtable;

import java.lang.reflect.*;

import org.apache.bcel.generic.NEW;
import org.apache.bcel.generic.IFEQ;
import org.apache.bcel.generic.PUSH;
import org.apache.bcel.generic.INVOKESTATIC;
import org.apache.bcel.generic.INVOKEVIRTUAL;
import org.apache.bcel.generic.INVOKESPECIAL;
import org.apache.bcel.generic.ConstantPoolGen;
import org.apache.bcel.generic.InstructionList;
import org.apache.bcel.generic.InstructionConstants;
import org.apache.bcel.generic.InvokeInstruction;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.runtime.TransletLoader;

class FunctionCall extends Expression {

    
    private QName  _fname;
    
    private final Vector _arguments;
    
    private final static Vector EMPTY_ARG_LIST = new Vector(0);

    
    protected final static String EXT_XSLTC = 
	TRANSLET_URI;

    protected final static String JAVA_EXT_XSLTC = 
	EXT_XSLTC + ""/java"";

    protected final static String EXT_XALAN =
	""http:

    protected final static String JAVA_EXT_XALAN =
	""http:

    
    Expression _thisArgument = null;

    
    private String      _className;
    private Method      _chosenMethod;
    private Constructor _chosenConstructor;
    private MethodType  _chosenMethodType;

    
    private boolean    unresolvedExternal;

    
    private boolean     _isExtConstructor = false; 

    
    private static final MultiHashtable _internal2Java = new MultiHashtable();

    
    private static final Hashtable _java2Internal = new Hashtable();

    
    static class JavaType {
	public Class  type;
	public int distance;
	
	public JavaType(Class type, int distance){
	    this.type = type;
	    this.distance = distance;
	}
	public boolean equals(Object query){
	    return query.equals(type);
	}
    } 

    
    static {

	try {
	    final Class objectClass   = Class.forName(""java.lang.Object"");
	    final Class stringClass   = Class.forName(""java.lang.String"");
	    final Class nodeClass     = Class.forName(""org.w3c.dom.Node"");
	    final Class nodeListClass = Class.forName(""org.w3c.dom.NodeList"");

	    
	    _internal2Java.put(Type.Boolean, new JavaType(Boolean.TYPE,0));

	    _internal2Java.put(Type.Int, new JavaType(Character.TYPE, 6)); 
	    _internal2Java.put(Type.Int, new JavaType(Byte.TYPE, 5));
	    _internal2Java.put(Type.Int, new JavaType(Short.TYPE, 4));
	    _internal2Java.put(Type.Int, new JavaType(Integer.TYPE, 0));
	    _internal2Java.put(Type.Int, new JavaType(Long.TYPE, 1));
	    _internal2Java.put(Type.Int, new JavaType(Float.TYPE, 2));
	    _internal2Java.put(Type.Int, new JavaType(Double.TYPE, 3));

	    _internal2Java.put(Type.Real, new JavaType(Character.TYPE, 6)); 
	    _internal2Java.put(Type.Real, new JavaType(Byte.TYPE, 5));
	    _internal2Java.put(Type.Real, new JavaType(Short.TYPE, 4));
	    _internal2Java.put(Type.Real, new JavaType(Integer.TYPE, 3));
	    _internal2Java.put(Type.Real, new JavaType(Long.TYPE, 2));
	    _internal2Java.put(Type.Real, new JavaType(Float.TYPE, 1));
	    _internal2Java.put(Type.Real, new JavaType(Double.TYPE, 0));

	    _internal2Java.put(Type.String, new JavaType(stringClass, 0)); 

	    _internal2Java.put(Type.Node, new JavaType(nodeClass, 0));  
	    _internal2Java.put(Type.Node, new JavaType(nodeListClass, 1));

	    _internal2Java.put(Type.NodeSet, new JavaType(Integer.TYPE, 10)); 
	    _internal2Java.put(Type.NodeSet, new JavaType(nodeClass, 1)); 
	    _internal2Java.put(Type.NodeSet, new JavaType(nodeListClass,0)); 

	    _internal2Java.put(Type.ResultTree, new JavaType(nodeClass, 1)); 
	    _internal2Java.put(Type.ResultTree, new JavaType(nodeListClass,0));
	    _internal2Java.put(Type.ResultTree, new JavaType(objectClass,2));

	    _internal2Java.put(Type.Reference, new JavaType(objectClass,0));

	    
	    _java2Internal.put(Boolean.TYPE, Type.Boolean); 

	    _java2Internal.put(Character.TYPE, Type.Real); 
	    _java2Internal.put(Byte.TYPE, Type.Real);
	    _java2Internal.put(Short.TYPE, Type.Real);
	    _java2Internal.put(Integer.TYPE, Type.Real);
	    _java2Internal.put(Long.TYPE, Type.Real);
	    _java2Internal.put(Float.TYPE, Type.Real);
	    _java2Internal.put(Double.TYPE, Type.Real);

	    _java2Internal.put(stringClass, Type.String);

	    _java2Internal.put(objectClass, Type.Reference);

	    
	    
	    _java2Internal.put(nodeListClass, Type.NodeSet);
	}
	catch (ClassNotFoundException e) {
	    System.err.println(e);
	}
    }
		
    public FunctionCall(QName fname, Vector arguments) {
	_fname = fname;
	_arguments = arguments;
	_type = null;
    }

    public FunctionCall(QName fname) {
	this(fname, EMPTY_ARG_LIST);
    }

    public String getName() {
	return(_fname.toString());
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_arguments != null) {
	    final int n = _arguments.size();
	    for (int i = 0; i < n; i++) {
		final Expression exp = (Expression)_arguments.elementAt(i);
		exp.setParser(parser);
		exp.setParent(this);
	    }
	}
    }

    public String getClassNameFromUri(String uri) 
	throws TypeCheckError
    {
	final int length = 
	    uri.startsWith(JAVA_EXT_XSLTC) ? JAVA_EXT_XSLTC.length() + 1 :
	    uri.startsWith(JAVA_EXT_XALAN) ? JAVA_EXT_XALAN.length() + 1 : 0;

	if (length == 0) {
	    throw new TypeCheckError(this);
	}
	return (uri.length() > length) ? uri.substring(length) : EMPTYSTRING;
    }

    
    public Type typeCheck(SymbolTable stable) 
	throws TypeCheckError 
    {
	if (_type != null) return _type;

	final String namespace = _fname.getNamespace();
	final String local = _fname.getLocalPart();

	if (isExtension()) {
	    _fname = new QName(null, null, local);
	    return typeCheckStandard(stable);
	}
	else if (isStandard()) {
	    return typeCheckStandard(stable);
	}
	
	else {
	    try {
		
		_className = getClassNameFromUri(namespace);

		final int pos = local.lastIndexOf('.');
		if (pos > 0) {
		    _className = _className + local.substring(0, pos);
		    _fname = new QName(namespace, null, 
			local.substring(pos + 1));
		}
		else {
		    _fname = new QName(namespace, null, local);
		}
		return typeCheckExternal(stable);
	    } 
	    catch (TypeCheckError e) {
		ErrorMsg errorMsg = e.getErrorMsg();
		if (errorMsg == null) {
		    final String name = _fname.getLocalPart();
		    errorMsg = new ErrorMsg(ErrorMsg.METHOD_NOT_FOUND_ERR, name);
		}
		getParser().reportError(ERROR, errorMsg);
		return _type = Type.Void;
	    }
	}
    }

    
    public Type typeCheckStandard(SymbolTable stable) throws TypeCheckError {
	_fname.clearNamespace(); 	

	final int n = _arguments.size();
	final Vector argsType = typeCheckArgs(stable);
	final MethodType args = new MethodType(Type.Void, argsType);
	final MethodType ptype =
	    lookupPrimop(stable, _fname.getLocalPart(), args);

	if (ptype != null) {
	    for (int i = 0; i < n; i++) {
		final Type argType = (Type) ptype.argsType().elementAt(i);
		final Expression exp = (Expression)_arguments.elementAt(i);
		if (!argType.identicalTo(exp.getType())) {
		    try {
			_arguments.setElementAt(new CastExpr(exp, argType), i);
		    }
		    catch (TypeCheckError e) {
			throw new TypeCheckError(this);	
		    }
		}
	    }
	    _chosenMethodType = ptype;
	    return _type = ptype.resultType();
	}
	throw new TypeCheckError(this);
    }

   

    public Type typeCheckConstructor(SymbolTable stable) throws TypeCheckError{
        final Vector constructors = findConstructors();
	if (constructors == null) {
            
            throw new TypeCheckError(ErrorMsg.CONSTRUCTOR_NOT_FOUND, 
		_className);
        
	}

	final int nConstructors = constructors.size();
	final int nArgs = _arguments.size();
	final Vector argsType = typeCheckArgs(stable);

	
	int bestConstrDistance = Integer.MAX_VALUE;
	_type = null;			
	for (int j, i = 0; i < nConstructors; i++) {
	    
	    final Constructor constructor = 
		(Constructor)constructors.elementAt(i);
	    final Class[] paramTypes = constructor.getParameterTypes();

	    Class extType = null;
	    int currConstrDistance = 0;
	    for (j = 0; j < nArgs; j++) {
		
		extType = paramTypes[j];
		final Type intType = (Type)argsType.elementAt(j);
		Object match = _internal2Java.maps(intType, extType);
		if (match != null) {
		    currConstrDistance += ((JavaType)match).distance;
		}
		else {
		    
		    currConstrDistance = Integer.MAX_VALUE;
		    break;
		} 
	    }

	    if (j == nArgs && currConstrDistance < bestConstrDistance ) {
	        _chosenConstructor = constructor;
	        _isExtConstructor = true;
		bestConstrDistance = currConstrDistance;
		_type = new ObjectType(_className);
	    }
	}

	if (_type != null) {
	    return _type;
	}

	final StringBuffer buf = new StringBuffer(_className);
	buf.append('.').append(_fname.getLocalPart()).append('(');
	for (int i = 0; i < nArgs; i++) {
	    final Type intType = (Type)argsType.elementAt(i);
	    buf.append(intType.toString());
	    if (i < nArgs - 1) buf.append("", "");
	}
	buf.append(')');
	throw new TypeCheckError(ErrorMsg.ARGUMENT_CONVERSION_ERR, 
	    buf.toString());
    }


    
    public Type typeCheckExternal(SymbolTable stable) throws TypeCheckError {
	int nArgs = _arguments.size();
	final String name = _fname.getLocalPart();

	
	if (_className.length() == 0) {
	    if (nArgs > 0) {
		_thisArgument = (Expression) _arguments.elementAt(0);
		_arguments.remove(0); nArgs--;  
		Type type = _thisArgument.typeCheck(stable);	
		if (type instanceof ObjectType) {
		    _className = ((ObjectType) type).getJavaClassName();
		}
		else {
		    
                    throw new TypeCheckError(ErrorMsg.NO_JAVA_FUNCT_THIS_REF, 
			name);
		}
            }
            else {
		
		final Parser parser = getParser();
		if (parser != null) {
		    reportWarning(this, parser, ErrorMsg.FUNCTION_RESOLVE_ERR,
				  _fname.toString());
		}
		unresolvedExternal = true;
		return _type = Type.Int;	
            }	     
	}
 	
	else if (_fname.getLocalPart().equals(""new"")) {
	    return typeCheckConstructor(stable);
	}

	final Vector methods = findMethods();
	
	if (methods == null) {
	    
	    throw new TypeCheckError(ErrorMsg.METHOD_NOT_FOUND_ERR, name);
	}

	Class extType = null;
	final int nMethods = methods.size();
	final Vector argsType = typeCheckArgs(stable);

	
	int bestMethodDistance  = Integer.MAX_VALUE;
	_type = null;                       
	for (int j, i = 0; i < nMethods; i++) {

	    
	    final Method method = (Method)methods.elementAt(i);
	    final Class[] paramTypes = method.getParameterTypes();
	    
	    int currMethodDistance = 0;
	    for (j = 0; j < nArgs; j++) {
		
		extType = paramTypes[j];
		final Type intType = (Type)argsType.elementAt(j);
		Object match = _internal2Java.maps(intType, extType);
		if (match != null) {
		   currMethodDistance += 
			((JavaType)match).distance; 
		}
		else {
		    
		    currMethodDistance = Integer.MAX_VALUE;
		    break;
		}
	    }

	    if (j == nArgs) {
		
		extType = method.getReturnType();
		_type = extType.getName().equals(""void"") ? Type.Void
		    : (Type) _java2Internal.get(extType);

		
		if (_type != null && currMethodDistance < bestMethodDistance) {
		    _chosenMethod = method;
		    bestMethodDistance = currMethodDistance;
		}
	    }
	}

	if (_type != null) {
	    if (_type == Type.NodeSet){
                getXSLTC().setMultiDocument(true);
            }
	    return _type;
	}

	final StringBuffer buf = new StringBuffer(_className);
	buf.append('.').append(_fname.getLocalPart()).append('(');
	for (int i = 0; i < nArgs; i++) {
	    final Type intType = (Type)argsType.elementAt(i);
	    buf.append(intType.toString());
	    if (i < nArgs - 1) buf.append("", "");
	}
	buf.append(')');
	throw new TypeCheckError(ErrorMsg.ARGUMENT_CONVERSION_ERR, 
	    buf.toString());
    }

    
    public Vector typeCheckArgs(SymbolTable stable) throws TypeCheckError {
	final Vector result = new Vector();
	final Enumeration e = _arguments.elements();	
	while (e.hasMoreElements()) {
	    final Expression exp = (Expression)e.nextElement();
	    result.addElement(exp.typeCheck(stable));
	}
	return result;
    }

    protected final Expression argument(int i) {
	return (Expression)_arguments.elementAt(i);
    }

    protected final Expression argument() {
	return argument(0);
    }
    
    protected final int argumentCount() {
	return _arguments.size();
    }

    protected final void setArgument(int i, Expression exp) {
	_arguments.setElementAt(exp, i);
    }

    
    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) 
    {
	Type type = Type.Boolean;
	if (_chosenMethodType != null)
	    type = _chosenMethodType.resultType();

	final InstructionList il = methodGen.getInstructionList();
	translate(classGen, methodGen);

	if ((type instanceof BooleanType) || (type instanceof IntType)) {
	    _falseList.add(il.append(new IFEQ(null)));
	}
    }


    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final int n = argumentCount();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	int index;

	
	if (isStandard() || isExtension()) {
	    for (int i = 0; i < n; i++) {
		final Expression exp = argument(i);
		exp.translate(classGen, methodGen);
		exp.startResetIterator(classGen, methodGen);
	    }

	    
	    final String name = _fname.toString().replace('-', '_') + ""F"";
	    String args = Constants.EMPTYSTRING;

	    
	    if (name.equals(""sumF"")) {
		args = DOM_INTF_SIG;
		il.append(methodGen.loadDOM());
	    }
	    else if (name.equals(""normalize_spaceF"")) {
		if (_chosenMethodType.toSignature(args).
		    equals(""()Ljava/lang/String;"")) {
		    args = ""I""+DOM_INTF_SIG;
		    il.append(methodGen.loadContextNode());
		    il.append(methodGen.loadDOM());
		}
	    }

	    
	    index = cpg.addMethodref(BASIS_LIBRARY_CLASS, name,
				     _chosenMethodType.toSignature(args));
	    il.append(new INVOKESTATIC(index));
	}
	
	
	else if (unresolvedExternal) {
	    index = cpg.addMethodref(BASIS_LIBRARY_CLASS,
				     ""unresolved_externalF"",
				     ""(Ljava/lang/String;)V"");
	    il.append(new PUSH(cpg, _fname.toString()));
	    il.append(new INVOKESTATIC(index));
	}
	else if (_isExtConstructor) {
	    final String clazz = 
		_chosenConstructor.getDeclaringClass().getName();
	    Class[] paramTypes = _chosenConstructor.getParameterTypes();
	    
	    il.append(new NEW(cpg.addClass(_className)));
	    il.append(InstructionConstants.DUP);

	    for (int i = 0; i < n; i++) {
		final Expression exp = argument(i);
		exp.translate(classGen, methodGen);
		
		exp.startResetIterator(classGen, methodGen);
		exp.getType().translateTo(classGen, methodGen, paramTypes[i]);
	    }

	    final StringBuffer buffer = new StringBuffer();
	    buffer.append('(');
	    for (int i = 0; i < paramTypes.length; i++) {
		buffer.append(getSignature(paramTypes[i]));
	    }
	    buffer.append(')');
	    buffer.append(""V"");

	    index = cpg.addMethodref(clazz,
				     ""<init>"", 
				     buffer.toString());
	    il.append(new INVOKESPECIAL(index));

	    
	    (Type.Object).translateFrom(classGen, methodGen, 
				_chosenConstructor.getDeclaringClass());
	    
	}
	
	else {
	    final String clazz = _chosenMethod.getDeclaringClass().getName();
	    Class[] paramTypes = _chosenMethod.getParameterTypes();

	    
	    if (_thisArgument != null) {
		_thisArgument.translate(classGen, methodGen);
	    }

	    for (int i = 0; i < n; i++) {
		final Expression exp = argument(i);
		exp.translate(classGen, methodGen);
		
		exp.startResetIterator(classGen, methodGen);
		exp.getType().translateTo(classGen, methodGen, paramTypes[i]);
	    }

	    final StringBuffer buffer = new StringBuffer();
	    buffer.append('(');
	    for (int i = 0; i < paramTypes.length; i++) {
		buffer.append(getSignature(paramTypes[i]));
	    }
	    buffer.append(')');
	    buffer.append(getSignature(_chosenMethod.getReturnType()));

	    index = cpg.addMethodref(clazz,
				     _fname.getLocalPart(),
				     buffer.toString());
	    il.append(_thisArgument != null ?
		(InvokeInstruction) new INVOKEVIRTUAL(index) : 
                (InvokeInstruction) new INVOKESTATIC(index));

	    
	    _type.translateFrom(classGen, methodGen,
				_chosenMethod.getReturnType());
	}
    }

    public String toString() {
	return ""funcall("" + _fname + "", "" + _arguments + ')';
    }

    public boolean isStandard() {
	final String namespace = _fname.getNamespace();
	return (namespace == null) || (namespace.equals(Constants.EMPTYSTRING));
    }

    public boolean isExtension() {
	final String namespace = _fname.getNamespace();
	return (namespace != null) && (namespace.equals(EXT_XSLTC) 
	    || namespace.equals(EXT_XALAN));
    }

    
    private Vector findMethods() {
	Vector result = null;
	final String namespace = _fname.getNamespace();

	if (namespace.startsWith(JAVA_EXT_XSLTC) ||
	    namespace.startsWith(JAVA_EXT_XALAN)) {
	    final int nArgs = _arguments.size();
	    try {
		TransletLoader loader = new TransletLoader();
		final Class clazz = loader.loadClass(_className);

		if (clazz == null) {
		    final ErrorMsg msg =
			new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
		    getParser().reportError(Constants.ERROR, msg);
		}
		else {
		    final String methodName = _fname.getLocalPart();
		    final Method[] methods = clazz.getDeclaredMethods();

		    for (int i = 0; i < methods.length; i++) {
			final int mods = methods[i].getModifiers();
			
			if (Modifier.isPublic(mods)
			    && methods[i].getName().equals(methodName)
			    && methods[i].getParameterTypes().length == nArgs)
			    {
				if (result == null) {
				    result = new Vector();
				}
				result.addElement(methods[i]);
			    }
		    }
		}
	    }
	    catch (ClassNotFoundException e) {
		final ErrorMsg msg =
		    new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
		getParser().reportError(Constants.ERROR, msg);
	    }
	}
	return result;
    }

    
    private Vector findConstructors() {
        Vector result = null;
        final String namespace = _fname.getNamespace();

        if (namespace.startsWith(JAVA_EXT_XSLTC) ||
            namespace.startsWith(JAVA_EXT_XALAN)) {
            final int nArgs = _arguments.size();
            try {
                TransletLoader loader = new TransletLoader();
                final Class clazz = loader.loadClass(_className);

                if (clazz == null) {
                    final ErrorMsg msg =
                        new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
                    getParser().reportError(Constants.ERROR, msg);
                }
                else {
                    final Constructor[] constructors = clazz.getConstructors();

                    for (int i = 0; i < constructors.length; i++) {
                        final int mods = constructors[i].getModifiers();
                        
                        if (Modifier.isPublic(mods) &&
                           constructors[i].getParameterTypes().length == nArgs)
                        {
                            if (result == null) {
                                result = new Vector();
                            }
                            result.addElement(constructors[i]);
                        }
                    }
                }
            }
            catch (ClassNotFoundException e) {
                final ErrorMsg msg =
                    new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, _className);
                getParser().reportError(Constants.ERROR, msg);
            }
        }
        return result;
    }


    
    static final String getSignature(Class clazz) {
	if (clazz.isArray()) {
	    final StringBuffer sb = new StringBuffer();
	    Class cl = clazz;
	    while (cl.isArray()) {
		sb.append(""["");
		cl = cl.getComponentType();
	    }
	    sb.append(getSignature(cl));
	    return sb.toString();
	}
	else if (clazz.isPrimitive()) {
	    if (clazz == Integer.TYPE) {
		return ""I"";
	    }
	    else if (clazz == Byte.TYPE) {
		return ""B"";
	    }
	    else if (clazz == Long.TYPE) {
		return ""J"";
	    }
	    else if (clazz == Float.TYPE) {
		return ""F"";
	    }
	    else if (clazz == Double.TYPE) {
		return ""D"";
	    }
	    else if (clazz == Short.TYPE) {
		return ""S"";
	    }
	    else if (clazz == Character.TYPE) {
		return ""C"";
	    }
	    else if (clazz == Boolean.TYPE) {
		return ""Z"";
	    }
	    else if (clazz == Void.TYPE) {
		return ""V"";
	    }
	    else {
		final String name = clazz.toString();
		ErrorMsg err = new ErrorMsg(ErrorMsg.UNKNOWN_SIG_TYPE_ERR,name);
		throw new Error(err.toString());
	    }
	}
	else {
	    return ""L"" + clazz.getName().replace('.', '/') + ';';
	}
    }

    
    static final String getSignature(Method meth) {
	final StringBuffer sb = new StringBuffer();
	sb.append('(');
	final Class[] params = meth.getParameterTypes(); 
	for (int j = 0; j < params.length; j++) {
	    sb.append(getSignature(params[j]));
	}
	return sb.append(')').append(getSignature(meth.getReturnType()))
	    .toString();
    }

    
    static final String getSignature(Constructor cons) {
	final StringBuffer sb = new StringBuffer();
	sb.append('(');
	final Class[] params = cons.getParameterTypes(); 
	for (int j = 0; j < params.length; j++) {
	    sb.append(getSignature(params[j]));
	}
	return sb.append("")V"").toString();
    }
}
"
org.apache.xpath.axes.SelfIteratorNoPredicate,5,5,0,9,8,10,3,6,4,2.0,52,0.0,0,0.9765625,0.45,1,4,9.4,3,1.0,1,"package org.apache.xpath.axes;

import javax.xml.transform.TransformerException;

import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.XPathContext;
import org.apache.xml.utils.PrefixResolver;



import org.apache.xml.dtm.DTM;


public class SelfIteratorNoPredicate extends LocPathIterator
{

  
  SelfIteratorNoPredicate(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, false);
  }
  
  
  public SelfIteratorNoPredicate()
          throws javax.xml.transform.TransformerException
  {
    super(null);
  }


  
  public int nextNode()
  {
    int next;
    DTM dtm = m_cdtm;

    m_lastFetched = next = (DTM.NULL == m_lastFetched)
                           ? m_context
                           : DTM.NULL;

    
    if (DTM.NULL != next)
    {
      m_pos++;

      return next;
    }
    else
    {
      m_foundLast = true;

      return DTM.NULL;
    }
  }
  
  
  public int asNode(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
    return xctxt.getCurrentNode();
  }
  
  
  public int getLastPos(XPathContext xctxt)
  {
    return 1;
  }


}"
org.apache.xml.utils.SerializableLocatorImpl,10,1,0,0,15,37,0,0,10,0.777777778,64,1.0,0,0.0,0.375,0,0,5.0,1,0.8,0,"
package org.apache.xml.utils;



public class SerializableLocatorImpl
implements org.xml.sax.Locator, java.io.Serializable

{
    
    public SerializableLocatorImpl ()
    {
    }
    
    
    
    public SerializableLocatorImpl (org.xml.sax.Locator locator)
    {
        setPublicId(locator.getPublicId());
        setSystemId(locator.getSystemId());
        setLineNumber(locator.getLineNumber());
        setColumnNumber(locator.getColumnNumber());
    }
    
    
    
    
    
    
    
    
    public String getPublicId ()
    {
        return publicId;
    }
    
    
    
    public String getSystemId ()
    {
        return systemId;
    }
    
    
    
    public int getLineNumber ()
    {
        return lineNumber;
    }
    
    
    
    public int getColumnNumber ()
    {
        return columnNumber;
    }
    
    
    
    
    
    
    
    
    public void setPublicId (String publicId)
    {
        this.publicId = publicId;
    }
    
    
    
    public void setSystemId (String systemId)
    {
        this.systemId = systemId;
    }
    
    
    
    public void setLineNumber (int lineNumber)
    {
        this.lineNumber = lineNumber;
    }
    
    
    
    public void setColumnNumber (int columnNumber)
    {
        this.columnNumber = columnNumber;
    }
    
    
    
    
    
    
    
    private String publicId;
    
    
    private String systemId;
    
    
    private int lineNumber;
    
    
    private int columnNumber;
    
}


"
org.apache.xalan.processor.ProcessorImport,3,5,0,2,4,3,1,1,0,2.0,10,0.0,0,0.990950226,1.0,1,1,2.333333333,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xml.utils.TreeWalker;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetComposed;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.InputSource;
import org.xml.sax.EntityResolver;

import java.net.URL;

import java.io.IOException;

import javax.xml.transform.URIResolver;

import org.w3c.dom.Node;


class ProcessorImport extends ProcessorInclude
{

  
  protected int getStylesheetType()
  {
    return StylesheetHandler.STYPE_IMPORT;
  }

  
  protected int getStylesheetInclErr()
  {
    return XSLTErrorResources.ER_IMPORTING_ITSELF;
  }

}
"
org.apache.xalan.xsltc.dom.BitArray,17,1,0,4,24,0,4,0,16,0.653409091,621,0.818181818,0,0.0,0.291666667,0,0,34.88235294,10,2.2353,0,"

package org.apache.xalan.xsltc.dom;

import java.io.Externalizable;
import java.io.ObjectInput;
import java.io.ObjectOutput;
import java.io.IOException;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.NodeIterator;


public class BitArray implements Externalizable {

    private int[] _bits;
    private int   _bitSize;
    private int   _intSize;
    private int   _mask;

    
    
    private final static int[] _masks = {
	0x80000000, 0x40000000, 0x20000000, 0x10000000,
	0x08000000, 0x04000000, 0x02000000, 0x01000000,
	0x00800000, 0x00400000, 0x00200000, 0x00100000,
	0x00080000, 0x00040000, 0x00020000, 0x00010000,
	0x00008000, 0x00004000, 0x00002000, 0x00001000,
	0x00000800, 0x00000400, 0x00000200, 0x00000100,
	0x00000080, 0x00000040, 0x00000020, 0x00000010,
	0x00000008, 0x00000004, 0x00000002, 0x00000001 };

    
    public BitArray() {
	this(32);
    }

    public BitArray(int size) {
	if (size < 32) size = 32;
	_bitSize = size;
	_intSize = (_bitSize >>> 5) + 1;
	_bits = new int[_intSize + 1];
    }

    public BitArray(int size, int[] bits) {
	if (size < 32) size = 32;
	_bitSize = size;
	_intSize = (_bitSize >>> 5) + 1;
	_bits = bits;
    }

        
    public void setMask(int mask) {
	_mask = mask;
    }

    
    public int getMask() {
	return(_mask);
    }

    
    public final int size() {
	return(_bitSize);
    }

    
    public final boolean getBit(int bit) {
	return((_bits[bit>>>5] & _masks[bit%32]) != 0);
    }

    
    public final int getNextBit(int startBit) {
	for (int i = (startBit >>> 5) ; i<=_intSize; i++) {
	    int bits = _bits[i];
	    if (bits != 0) {
		for (int b = (startBit % 32); b<32; b++) {
		    if ((bits & _masks[b]) != 0) {
			return((i << 5) + b);
		    }
		}
	    }
	    startBit = 0;
	}
	return(NodeIterator.END);
    }

    
    private int _pos = Integer.MAX_VALUE;
    private int _node = 0;
    private int _int = 0;
    private int _bit = 0;

    public final int getBitNumber(int pos) {

	
	if (pos == _pos) return(_node);
	
	
	
	if (pos < _pos) {
	    _int = _bit = _pos = 0;
	}

	
	for ( ; _int <= _intSize; _int++) {
	    int bits = _bits[_int];
	    if (bits != 0) { 
		for ( ; _bit < 32; _bit++) {
		    if ((bits & _masks[_bit]) != 0) {
			if (++_pos == pos) {
			    _node = ((_int << 5) + _bit) - 1;
			    return (_node);
			}
		    }
		}
		_bit = 0;
	    }
	}
	return(0);
    }

    
    public final int[] data() {
	return(_bits);
    }

    int _first = Integer.MAX_VALUE; 
    int _last  = Integer.MIN_VALUE; 

    
    public final void setBit(int bit) {
	if (bit >= _bitSize) return;
	final int i = (bit >>> 5);
	if (i < _first) _first = i;
	if (i > _last) _last = i;
	_bits[i] |= _masks[bit % 32];
    }

    
    public final BitArray merge(BitArray other) {
	
	if (_last == -1) {
	    _bits = other._bits;
	}
	
	else if (other._last != -1) {
	    int start = (_first < other._first) ? _first : other._first;
	    int stop  = (_last > other._last) ? _last : other._last;

	    
	    if (other._intSize > _intSize) {
		if (stop > _intSize) stop = _intSize;
		for (int i=start; i<=stop; i++)
		    other._bits[i] |= _bits[i];
		_bits = other._bits;
	    }
	    
	    else {
		if (stop > other._intSize) stop = other._intSize;
		for (int i=start; i<=stop; i++)
		    _bits[i] |= other._bits[i];
	    }
	}
	return(this);
    }

    
    public final void resize(int newSize) {
	if (newSize > _bitSize) {
	    _intSize = (newSize >>> 5) + 1;
	    final int[] newBits = new int[_intSize + 1];
	    System.arraycopy(_bits, 0, newBits, 0, (_bitSize>>>5) + 1);
	    _bits = newBits;
	    _bitSize = newSize;
	}
    }

    public BitArray cloneArray() {
	return(new BitArray(_intSize, _bits));
    }

    public void writeExternal(ObjectOutput out) throws IOException {
	out.writeInt(_bitSize);
	out.writeInt(_mask);
	out.writeObject(_bits);
	out.flush();
    }

    
    public void readExternal(ObjectInput in)
	throws IOException, ClassNotFoundException {
	_bitSize = in.readInt();
	_intSize = (_bitSize >>> 5) + 1;
	_mask    = in.readInt();
	_bits    = (int[])in.readObject();
    }

}


    
"
org.apache.xalan.templates.ElemMessage,6,3,0,5,17,3,0,5,6,0.4,60,1.0,0,0.975124378,0.444444444,2,4,8.833333333,1,0.8333,0,"
package org.apache.xalan.templates;



import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;


public class ElemMessage extends ElemTemplateElement
{

  
  private boolean m_terminate = Constants.ATTRVAL_NO;  

  
  public void setTerminate(boolean v)
  {
    m_terminate = v;
  }

  
  public boolean getTerminate()
  {
    return m_terminate;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_MESSAGE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_MESSAGE_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    String data = transformer.transformToString(this);

    transformer.getMsgMgr().message(this, data, m_terminate);
    
    if(m_terminate)
      transformer.getErrorListener().fatalError(new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_STYLESHEET_DIRECTED_TERMINATION, null))); 
    
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this); 
  }
}
"
org.apache.xpath.functions.FuncBoolean,2,4,0,5,5,1,0,5,2,2.0,15,0.0,0,0.979591837,0.75,1,6,6.5,1,0.5,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class FuncBoolean extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return m_arg0.execute(xctxt).bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
  

}
"
org.apache.xml.dtm.ref.DTMAxisIteratorBase,16,1,1,24,23,92,22,2,14,0.888888889,133,1.0,0,0.0,0.5625,0,0,6.9375,3,1.125,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;


public abstract class DTMAxisIteratorBase implements DTMAxisIterator
{

  
  private int _last = -1;

  
  private int _position = 0;

  
  protected int _markedNode;

  
  protected int _startNode = DTMAxisIterator.END;

  
  protected boolean _includeSelf = false;

  
  protected boolean _isRestartable = true;
  
  
  public int getStartNode()
  {
    return _startNode;
  }

  
  public DTMAxisIterator reset()
  {

    final boolean temp = _isRestartable;

    _isRestartable = true;

    setStartNode(_startNode);

    _isRestartable = temp;

    return this;
  }

  
  public DTMAxisIterator includeSelf()
  {

    _includeSelf = true;

    return this;
  }

  
  public int getLast()
  {

    if (_last == -1)		
    {
      
      
      
      
      
      

      final int temp = _position; 
      setMark();

      reset();			
      do
      {
        _last++;
      }
      while (next() != END);

      gotoMark();		
      _position = temp;
    }

    return _last;
  }

  
  public int getPosition()
  {
    return _position == 0 ? 1 : _position;
  }

  
  public boolean isReverse()
  {
    return false;
  }

  
  public DTMAxisIterator cloneIterator()
  {

    try
    {
      final DTMAxisIteratorBase clone = (DTMAxisIteratorBase) super.clone();

      

      
      return clone;
    }
    catch (CloneNotSupportedException e)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(e);
    }
  }

  
  protected final int returnNode(final int node)
  {
    _position++;

    return node;
  }

  
  protected final DTMAxisIterator resetPosition()
  {

    _position = 0;

    return this;
  }
  
  
  public boolean isDocOrdered()
  {
    return true;
  }
  
  
  public int getAxis()
  {
    return -1;
  }

}
"
org.apache.xml.dtm.ref.CustomStringPool,4,2,0,1,15,0,0,1,4,0.833333333,62,0.0,0,0.571428571,0.5,1,4,14.0,3,1.5,0,"

package org.apache.xml.dtm.ref;
import java.util.Vector;
import java.util.Hashtable;


public class CustomStringPool extends DTMStringPool {
        
        
        
        final Hashtable m_stringToInt = new Hashtable();
        public static final int NULL=-1;

        public CustomStringPool()
        {
                super();
                
                
                
        }

        public void removeAllElements()
        {
                m_intToString.removeAllElements();
                if (m_stringToInt != null) 
                        m_stringToInt.clear();
        }

        
        public String indexToString(int i)
        throws java.lang.ArrayIndexOutOfBoundsException
        {
                return(String) m_intToString.elementAt(i);
        }

        
        public int stringToIndex(String s)
        {
                if (s==null) return NULL;
                Integer iobj=(Integer)m_stringToInt.get(s);
                if (iobj==null) {
                        m_intToString.addElement(s);
                        iobj=new Integer(m_intToString.size());
                        m_stringToInt.put(s,iobj);
                }
                return iobj.intValue();
        }
}
"
org.apache.xpath.SourceTreeManager,13,1,0,8,45,42,4,5,13,0.625,345,0.5,0,0.0,0.340659341,0,0,25.38461538,5,1.8462,0,"
package org.apache.xpath;

import java.net.MalformedURLException;

import java.io.File;
import java.io.IOException;

import java.util.StringTokenizer;
import java.util.Vector;

import org.apache.xpath.objects.XString;




import org.apache.xml.dtm.DTM;

import javax.xml.transform.URIResolver;
import javax.xml.transform.TransformerException;

import org.xml.sax.InputSource;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.XMLReader;
import org.xml.sax.ContentHandler;
import org.xml.sax.EntityResolver;


import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xpath.res.XPATHErrorResources;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.Source;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.TransformerException;


public class SourceTreeManager
{

  
  private Vector m_sourceTree = new Vector();

  
  public void reset()
  {
    m_sourceTree = new Vector();
  }

  
  URIResolver m_uriResolver;

  
  public void setURIResolver(URIResolver resolver)
  {
    m_uriResolver = resolver;
  }

  
  public URIResolver getURIResolver()
  {
    return m_uriResolver;
  }

  
  public String findURIFromDoc(int owner)
  {
    int n = m_sourceTree.size();

    for (int i = 0; i < n; i++)
    {
      SourceTree sTree = (SourceTree) m_sourceTree.elementAt(i);

      if (owner == sTree.m_root)
        return sTree.m_url;
    }

    return null;
  }

  
  public Source resolveURI(
          String base, String urlString, SourceLocator locator)
            throws TransformerException, IOException
  {

    Source source = null;

    if (null != m_uriResolver)
    {
      source = m_uriResolver.resolve(urlString, base);
    }

    if (null == source)
    {
      String uri = SystemIDResolver.getAbsoluteURI(urlString, base);

      source = new StreamSource(uri);
    }

    return source;
  }

  
  public void removeDocumentFromCache(int n)
  {
    if(DTM.NULL ==n)
      return;
    for(int i=m_sourceTree.size()-1;i>=0;--i)
    {
      SourceTree st=(SourceTree)m_sourceTree.elementAt(i);
      if(st!=null && st.m_root==n)
      {
	m_sourceTree.removeElementAt(i);
	return;
      }
    }
  }
  


  
  public void putDocumentInCache(int n, Source source)
  {

    int cachedNode = getNode(source);

    if (DTM.NULL != cachedNode)
    {
      if (!(cachedNode == n))
        throw new RuntimeException(
          ""Programmer's Error!  ""
          + ""putDocumentInCache found reparse of doc: ""
          + source.getSystemId());
      return;
    }
    if (null != source.getSystemId())
    {
      m_sourceTree.addElement(new SourceTree(n, source.getSystemId()));
    }
  }

  
  public int getNode(Source source)
  {




    
    String url = source.getSystemId();

    if (null == url)
      return DTM.NULL;

    int n = m_sourceTree.size();

    
    for (int i = 0; i < n; i++)
    {
      SourceTree sTree = (SourceTree) m_sourceTree.elementAt(i);

      
      
      if (url.equals(sTree.m_url))
        return sTree.m_root;
    }

    
    return DTM.NULL;
  }

  
  public int getSourceTree(
          String base, String urlString, SourceLocator locator, XPathContext xctxt)
            throws TransformerException
  {

    
    try
    {
      Source source = this.resolveURI(base, urlString, locator);

      
      return getSourceTree(source, locator, xctxt);
    }
    catch (IOException ioe)
    {
      throw new TransformerException(ioe.getMessage(), locator, ioe);
    }

    
  }

  
  public int getSourceTree(Source source, SourceLocator locator, XPathContext xctxt)
          throws TransformerException
  {

    int n = getNode(source);

    if (DTM.NULL != n)
      return n;

    n = parseToNode(source, locator, xctxt);

    if (DTM.NULL != n)
      putDocumentInCache(n, source);

    return n;
  }

  
  public int parseToNode(Source source, SourceLocator locator, XPathContext xctxt)
          throws TransformerException
  {

    try
    {      
      Object xowner = xctxt.getOwnerObject();
      DTM dtm;
      if(null != xowner && xowner instanceof org.apache.xml.dtm.DTMWSFilter)
      {
        dtm = xctxt.getDTM(source, false, 
                          (org.apache.xml.dtm.DTMWSFilter)xowner, false, true);
      }
      else
      {
        dtm = xctxt.getDTM(source, false, null, false, true);
      }
      return dtm.getDocument();
    }
    catch (Exception e)
    {
      
      throw new TransformerException(e.getMessage(), locator, e);
    }

  }

  
  public static XMLReader getXMLReader(Source inputSource, SourceLocator locator)
          throws TransformerException
  {

    try
    {
      XMLReader reader = (inputSource instanceof SAXSource)
                         ? ((SAXSource) inputSource).getXMLReader() : null;
                         
      boolean isUserReader = (reader != null);

      if (null == reader)
      {
        try {
          javax.xml.parsers.SAXParserFactory factory=
              javax.xml.parsers.SAXParserFactory.newInstance();
          factory.setNamespaceAware( true );
          javax.xml.parsers.SAXParser jaxpParser=
              factory.newSAXParser();
          reader=jaxpParser.getXMLReader();
          
        } catch( javax.xml.parsers.ParserConfigurationException ex ) {
          throw new org.xml.sax.SAXException( ex );
        } catch( javax.xml.parsers.FactoryConfigurationError ex1 ) {
            throw new org.xml.sax.SAXException( ex1.toString() );
        } catch( NoSuchMethodError ex2 ) {
        }
        catch (AbstractMethodError ame){}
        if(null == reader)
          reader = XMLReaderFactory.createXMLReader();
      }

      try
      {
        reader.setFeature(""http:
                          true);
        
        



      }
      catch (org.xml.sax.SAXException se)
      {

        
        
      }

      return reader;
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se.getMessage(), locator, se);
    }
  }
}
"
org.apache.xalan.xsltc.compiler.IllegalCharException,1,3,0,0,2,0,0,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.apache.xalan.xsltc.compiler;

class IllegalCharException extends Exception {
    public IllegalCharException(String s) {
	super(s);
    }
}
"
org.apache.xalan.xsltc.compiler.FilterExpr,7,3,0,25,38,0,2,24,6,0.083333333,282,1.0,1,0.922077922,0.306122449,2,9,39.0,3,1.7143,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

class FilterExpr extends Expression {
    private Expression   _primary;
    private final Vector _predicates;

    public FilterExpr(Expression primary, Vector predicates) {
	_primary = primary;
	_predicates = predicates;
	primary.setParent(this);
    }

    protected Expression getExpr() {
	if (_primary instanceof CastExpr)
	    return ((CastExpr)_primary).getExpr();
	else
	    return _primary;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_primary.setParser(parser);
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Expression exp = (Expression)_predicates.elementAt(i);
		exp.setParser(parser);
		exp.setParent(this);
	    }
	}
    }
    
    public String toString() {
	return ""filter-expr("" + _primary + "", "" + _predicates + "")"";
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	Type ptype = _primary.typeCheck(stable);

	if (ptype instanceof NodeSetType == false) {
	    if (ptype instanceof ReferenceType)  {
		_primary = new CastExpr(_primary, Type.NodeSet);
	    }
	    else {
		throw new TypeCheckError(this);
	    }
	}

	int n = _predicates.size();
	for (int i = 0; i < n; i++) {
	    Expression pred = (Expression)_predicates.elementAt(i);
	    pred.typeCheck(stable);
	}
	return _type = Type.NodeSet;	
    }
	
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (_predicates.size() > 0) {
	    translatePredicates(classGen, methodGen);
	}
	else {
	    _primary.translate(classGen, methodGen);
	    _primary.startResetIterator(classGen, methodGen);
	}
    }

    
    public void translatePredicates(ClassGenerator classGen,
				    MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_predicates.size() == 0) {
	    translate(classGen, methodGen);
	}
	else {
	    final int initCNLI = cpg.addMethodref(CURRENT_NODE_LIST_ITERATOR,
						  ""<init>"",
						  ""(""+NODE_ITERATOR_SIG+""Z""+
						  CURRENT_NODE_LIST_FILTER_SIG +
						  NODE_SIG+TRANSLET_SIG+"")V"");

	    Predicate predicate = (Predicate)_predicates.lastElement();
	    _predicates.remove(predicate);

	    if (predicate.isNthPositionFilter()) {
		final int start = cpg.addInterfaceMethodref(NODE_ITERATOR,
							    ""setStartNode"", 
							    ""(I)""+
							    NODE_ITERATOR_SIG);
		final int reset = cpg.addInterfaceMethodref(NODE_ITERATOR,
							    ""reset"",
							    ""()""+
							    NODE_ITERATOR_SIG);
		translatePredicates(classGen, methodGen); 
		predicate.translate(classGen, methodGen); 
		il.append(new INVOKEINTERFACE(start,2));
		il.append(new INVOKEINTERFACE(reset,1));

		final int sngl = cpg.addMethodref(BASIS_LIBRARY_CLASS,
						  ""getSingleNode"",
						  ""(""+NODE_ITERATOR_SIG+"")""+
						  NODE_ITERATOR_SIG);
		il.append(new INVOKESTATIC(sngl));
	    }
	    else {
		
		il.append(new NEW(cpg.addClass(CURRENT_NODE_LIST_ITERATOR)));
		il.append(DUP);
		translatePredicates(classGen, methodGen); 
		il.append(ICONST_1);
		predicate.translate(classGen, methodGen);
		il.append(methodGen.loadCurrentNode());
		il.append(classGen.loadTranslet());
		il.append(new INVOKESPECIAL(initCNLI));
	    }
	}
    }
}
"
org.apache.xalan.templates.AVT,14,1,0,23,44,29,11,13,14,0.769230769,546,1.0,0,0.0,0.206349206,0,0,37.64285714,4,1.8571,0,"
package org.apache.xalan.templates;

import org.apache.xml.dtm.DTM;

import java.util.Vector;
import java.util.StringTokenizer;

import org.apache.xml.utils.StringBufferPool;
import org.apache.xml.utils.FastStringBuffer;

import javax.xml.transform.TransformerException;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.processor.StylesheetHandler;

import javax.xml.transform.ErrorListener;


public class AVT implements java.io.Serializable, XSLTVisitable
{

  
  private String m_simpleString = null;

  
  private Vector m_parts = null;

  
  private String m_rawName;

  
  public String getRawName()
  {
    return m_rawName;
  }

  
  public void setRawName(String rawName)
  {
    m_rawName = rawName;
  }

  
  private String m_name;

  
  public String getName()
  {
    return m_name;
  }

  
  public void setName(String name)
  {
    m_name = name;
  }

  
  private String m_uri;

  
  public String getURI()
  {
    return m_uri;
  }

  
  public void setURI(String uri)
  {
    m_uri = uri;
  }

  
  public AVT(StylesheetHandler handler, String uri, String name, 
             String rawName, String stringedValue,
             ElemTemplateElement owner)
          throws javax.xml.transform.TransformerException
  {

    m_uri = uri;
    m_name = name;
    m_rawName = rawName;

    StringTokenizer tokenizer = new StringTokenizer(stringedValue, ""{}""'"",
                                  true);
    int nTokens = tokenizer.countTokens();

    if (nTokens < 2)
    {
      m_simpleString = stringedValue;  
    }
    else
    {
      FastStringBuffer buffer = StringBufferPool.get();
      FastStringBuffer exprBuffer = StringBufferPool.get();

      try
      {
        m_parts = new Vector(nTokens + 1);

        String t = null;  
        String lookahead = null;  
        String error = null;  

        while (tokenizer.hasMoreTokens())
        {
          if (lookahead != null)
          {
            t = lookahead;
            lookahead = null;
          }
          else
            t = tokenizer.nextToken();

          if (t.length() == 1)
          {
            switch (t.charAt(0))
            {
            case ('""') :
            case (''') :
            {

              
              buffer.append(t);

              break;
            }
            case ('{') :
            {

              try
              {
                
                lookahead = tokenizer.nextToken();

                if (lookahead.equals(""{""))
                {

                  
                  buffer.append(lookahead);

                  lookahead = null;

                  break;  
                }

                
                else
                {
                  if (buffer.length() > 0)
                  {
                    m_parts.addElement(new AVTPartSimple(buffer.toString()));
                    buffer.setLength(0);
                  }

                  exprBuffer.setLength(0);

                  while (null != lookahead)
                  {
                    if (lookahead.length() == 1)
                    {
                      switch (lookahead.charAt(0))
                      {
                      case ''' :
                      case '""' :
                        {

                          
                          exprBuffer.append(lookahead);

                          String quote = lookahead;

                          
                          lookahead = tokenizer.nextToken();

                          while (!lookahead.equals(quote))
                          {
                            exprBuffer.append(lookahead);

                            lookahead = tokenizer.nextToken();
                          }

                          exprBuffer.append(lookahead);

                          lookahead = tokenizer.nextToken();

                          break;
                        }
                      case '{' :
                        {

                          
                          error = XSLMessages.createMessage(
                                                            XSLTErrorResources.ER_NO_CURLYBRACE, null);  
                          
                          lookahead = null;  

                          break;
                        }
                      case '}' :
                        {

                          
                          
                          buffer.setLength(0);

                          XPath xpath =
                                       handler.createXPath(exprBuffer.toString(), owner);

                          m_parts.addElement(new AVTPartXPath(xpath));

                          lookahead = null;  

                          break;
                        }
                      default :
                        {

                          
                          exprBuffer.append(lookahead);

                          lookahead = tokenizer.nextToken();
                        }
                      }  
                    }  
                    else
                    {

                      
                      exprBuffer.append(lookahead);

                      lookahead = tokenizer.nextToken();
                    }
                  }  

                  if (error != null)
                  {
                    break;  
                  }
                }

                break;
              }
              catch (java.util.NoSuchElementException ex)
              {
                error = XSLMessages.createMessage(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE, new Object[]{ name, stringedValue }); 
                break;
              }
            }
            case ('}') :
            {
              lookahead = tokenizer.nextToken();

              if (lookahead.equals(""}""))
              {

                
                buffer.append(lookahead);

                lookahead = null;  
              }
              else
              {

                
                try
                {
                  handler.warn(XSLTErrorResources.WG_FOUND_CURLYBRACE, null);  
                }
                catch (org.xml.sax.SAXException se)
                {
                  throw new TransformerException(se);
                }

                buffer.append(""}"");

                
              }

              break;
            }
            default :
            {

              
              buffer.append(t);
            }
            }  
          }  
          else
          {

            
            buffer.append(t);
          }

          if (null != error)
          {
            try
            {
              handler.warn(XSLTErrorResources.WG_ATTR_TEMPLATE,
                           new Object[]{ error });  
            }
            catch (org.xml.sax.SAXException se)
            {
              throw new TransformerException(se);
            }

            break;
          }
        }  

        if (buffer.length() > 0)
        {
          m_parts.addElement(new AVTPartSimple(buffer.toString()));
          buffer.setLength(0);
        }
      }
      finally
      {
        StringBufferPool.free(buffer);
        StringBufferPool.free(exprBuffer);
      }
    }  

    if (null == m_parts && (null == m_simpleString))
    {

      
      m_simpleString = """";
    }
  }

  
  public String getSimpleString()
  {

    if (null != m_simpleString)
    {
      return m_simpleString;
    }
    else if (null != m_parts)
    {
      FastStringBuffer buf = StringBufferPool.get();
      String s;

      try
      {
        buf.setLength(0);

        int n = m_parts.size();

        for (int i = 0; i < n; i++)
        {
          AVTPart part = (AVTPart) m_parts.elementAt(i);

          buf.append(part.getSimpleString());
        }

        s = buf.toString();
      }
      finally
      {
        StringBufferPool.free(buf);
      }

      return s;
    }
    else
    {
      return """";
    }
  }

  
  public String evaluate(
          XPathContext xctxt, int context, org.apache.xml.utils.PrefixResolver nsNode)
            throws javax.xml.transform.TransformerException
  {

    FastStringBuffer buf = StringBufferPool.get();

    try
    {
      if (null != m_simpleString)
      {
        return m_simpleString;
      }
      else if (null != m_parts)
      {
        buf.setLength(0);

        int n = m_parts.size();

        for (int i = 0; i < n; i++)
        {
          AVTPart part = (AVTPart) m_parts.elementAt(i);

          part.evaluate(xctxt, buf, context, nsNode);
        }

        return buf.toString();
      }
      else
      {
        return """";
      }
    }
    finally
    {
      StringBufferPool.free(buf);
    }
  }

  
  public boolean isContextInsensitive()
  {
    return null != m_simpleString;
  }

  
  public boolean canTraverseOutsideSubtree()
  {

    if (null != m_parts)
    {
      int n = m_parts.size();

      for (int i = 0; i < n; i++)
      {
        AVTPart part = (AVTPart) m_parts.elementAt(i);

        if (part.canTraverseOutsideSubtree())
          return true;
      }
    }

    return false;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    if (null != m_parts)
    {
      int n = m_parts.size();

      for (int i = 0; i < n; i++)
      {
        AVTPart part = (AVTPart) m_parts.elementAt(i);

        part.fixupVariables(vars, globalsSize);
      }
    }
  }
  
  
  public void callVisitors(XSLTVisitor visitor)
  {
  	if(visitor.visitAVT(this) && (null != m_parts))
  	{
      int n = m_parts.size();

      for (int i = 0; i < n; i++)
      {
        AVTPart part = (AVTPart) m_parts.elementAt(i);

        part.callVisitors(visitor);
      }  		
  	}
  }


  
  public boolean isSimple() {
  	return m_simpleString != null;
  }

}
"
org.apache.xpath.functions.FuncFalse,3,3,0,4,4,3,0,4,3,2.0,9,0.0,0,0.95,0.5,1,6,2.0,1,0.6667,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class FuncFalse extends Function
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return XBoolean.S_FALSE;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }

}
"
org.apache.xalan.xsltc.compiler.LiteralElement,13,3,0,28,76,42,5,24,9,0.783333333,663,1.0,1,0.823529412,0.207692308,2,11,49.61538462,18,4.5385,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Hashtable;
import java.util.Enumeration;
import java.util.Vector;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class LiteralElement extends Instruction {

    private String _name;
    private LiteralElement _literalElemParent;
    private Vector _attributeElements = null;
    private Hashtable _accessedPrefixes = null;

    private final static String XMLNS_STRING = ""xmlns"";

    
    public QName getName() {
	return _qname;
    }
 
    
    public void display(int indent) {
	indent(indent);
	Util.println(""LiteralElement name = "" + _name);
	displayContents(indent + IndentIncrement);
    }

    
    private String accessedNamespace(String prefix) {
	if (_accessedPrefixes == null)
	    return(null);
	else
	    return((String)_accessedPrefixes.get(prefix));
    }

    
    public void registerNamespace(String prefix, String uri,
				  SymbolTable stable, boolean declared) {

	
	if (_literalElemParent != null) {
	    final String parentUri = _literalElemParent.accessedNamespace(prefix);
	    if (parentUri == null) {
		_literalElemParent.registerNamespace(prefix, uri, stable, declared);
		return;
	    }
	    if (parentUri.equals(uri)) return;
	}

	
	if (_accessedPrefixes == null) {
	    _accessedPrefixes = new Hashtable();
	}
	else {
	    if (!declared) {
		
		final String old = (String)_accessedPrefixes.get(prefix);
		if (old != null) {
		    if (old.equals(uri))
			return;
		    else 
			prefix = stable.generateNamespacePrefix();
		}
	    }
	}

	if (!prefix.equals(""xml"")) {
	    _accessedPrefixes.put(prefix,uri);
	}
    }

    
    private String translateQName(QName qname, SymbolTable stable) {
	
	String localname = qname.getLocalPart();
	String prefix = qname.getPrefix();

	
	if (prefix == null)
	    prefix = Constants.EMPTYSTRING;
	else if (prefix.equals(XMLNS_STRING))
	    return(XMLNS_STRING);
	
	
	final String alternative = stable.lookupPrefixAlias(prefix);
	if (alternative != null) {
	    stable.excludeNamespaces(prefix);
	    prefix = alternative;
	}

	
	String uri = lookupNamespace(prefix);
	if (uri == null) return(localname);

	
	registerNamespace(prefix, uri, stable, false);

	
	if (prefix != Constants.EMPTYSTRING)
	    return(prefix+"":""+localname);
	else
	    return(localname);
    }

    
    public void addAttribute(SyntaxTreeNode attribute) {
	if (_attributeElements == null) {
	    _attributeElements = new Vector(2);
	}
	_attributeElements.add(attribute);
    }

    
    public void setFirstAttribute(SyntaxTreeNode attribute) {
	if (_attributeElements == null) {
	    _attributeElements = new Vector(2);
	}
	_attributeElements.insertElementAt(attribute,0);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	if (_attributeElements != null) {
	    final int count = _attributeElements.size();
	    for (int i = 0; i < count; i++) {
		SyntaxTreeNode node = 
		    (SyntaxTreeNode)_attributeElements.elementAt(i);
		node.typeCheck(stable);
	    }
	}
	typeCheckContents(stable);
	return Type.Void;
    }

    
    public Enumeration getNamespaceScope(SyntaxTreeNode node) {
	Hashtable all = new Hashtable();
	
	while (node != null) {
	    Hashtable mapping = node.getPrefixMapping();
	    if (mapping != null) {
		Enumeration prefixes = mapping.keys();
		while (prefixes.hasMoreElements()) {
		    String prefix = (String)prefixes.nextElement();
		    if (!all.containsKey(prefix)) {
			all.put(prefix, mapping.get(prefix));
		    }
		}
	    }
	    node = node.getParent();
	}
	return(all.keys());
    }

    
    public void parseContents(Parser parser) {
	final SymbolTable stable = parser.getSymbolTable();
	stable.setCurrentNode(this);

	
	SyntaxTreeNode _literalElemParent = getParent();
	while (_literalElemParent != null && !(_literalElemParent instanceof LiteralElement)) {
	    _literalElemParent = _literalElemParent.getParent();
	}

	if (!(_literalElemParent instanceof LiteralElement)) {
	    _literalElemParent = null;
	}

	_name = translateQName(_qname, stable);

	
	final int count = _attributes.getLength();
	for (int i = 0; i < count; i++) {
	    final QName qname = parser.getQName(_attributes.getQName(i));
	    final String uri = qname.getNamespace();
	    final String val = _attributes.getValue(i);

	    
	    
	    
	    if (qname == parser.getUseAttributeSets()) {
		setFirstAttribute(new UseAttributeSets(val, parser));
	    }
	    
	    else if (qname == parser.getExtensionElementPrefixes()) {
		stable.excludeNamespaces(val);
	    }
	    
	    else if (qname == parser.getExcludeResultPrefixes()) {
		stable.excludeNamespaces(val);
	    }
	    else {
		
		final String prefix = qname.getPrefix();
		if (prefix != null && prefix.equals(XMLNS_PREFIX) ||
		    prefix == null && qname.getLocalPart().equals(""xmlns"") ||
		    uri != null && uri.equals(XSLT_URI))
		{
		    continue;	
		}

		
		final String name = translateQName(qname, stable);
		LiteralAttribute attr = new LiteralAttribute(name, val, parser);
		addAttribute(attr);
		attr.setParent(this);
		attr.parseContents(parser);
	    }
	}

	
	
	final Enumeration include = getNamespaceScope(this);
	while (include.hasMoreElements()) {
	    final String prefix = (String)include.nextElement();
	    if (!prefix.equals(""xml"")) {
		final String uri = lookupNamespace(prefix);
		if (uri != null && !stable.isExcludedNamespace(uri)) {
		    registerNamespace(prefix, uri, stable, true);
		}
	    }
	}

	parseChildren(parser);

	
	for (int i = 0; i < count; i++) {
	    final QName qname = parser.getQName(_attributes.getQName(i));
	    final String val = _attributes.getValue(i);

	    
	    if (qname == parser.getExtensionElementPrefixes()) {
		stable.unExcludeNamespaces(val);
	    }
	    
	    else if (qname == parser.getExcludeResultPrefixes()) {
		stable.unExcludeNamespaces(val);
	    }
	}
    }

    protected boolean contextDependent() {
	return dependentContents();
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	il.append(new PUSH(cpg, _name));
	il.append(DUP2); 		
	il.append(methodGen.startElement());

	
	for (int i = 0; i < elementCount(); i++) {
	    final SyntaxTreeNode item = (SyntaxTreeNode) elementAt(i);
	    if (item instanceof Variable) {
		item.translate(classGen, methodGen);
		removeElement(item);	
	    }
	}

	
	if (_accessedPrefixes != null) {
	    boolean declaresDefaultNS = false;
	    Enumeration e = _accessedPrefixes.keys();

	    while (e.hasMoreElements()) {
		final String prefix = (String)e.nextElement();
		final String uri = (String)_accessedPrefixes.get(prefix);

		if (uri != Constants.EMPTYSTRING || 
			prefix != Constants.EMPTYSTRING) 
		{
		    if (prefix == Constants.EMPTYSTRING) {
			declaresDefaultNS = true;
		    }
		    il.append(methodGen.loadHandler());
		    il.append(new PUSH(cpg,prefix));
		    il.append(new PUSH(cpg,uri));
		    il.append(methodGen.namespace());
		}
	    }

	    
	    if (!declaresDefaultNS && (_parent instanceof XslElement)
		    && ((XslElement) _parent).declaresDefaultNS()) 
	    {
		il.append(methodGen.loadHandler());
		il.append(new PUSH(cpg, Constants.EMPTYSTRING));
		il.append(new PUSH(cpg, Constants.EMPTYSTRING));
		il.append(methodGen.namespace());
	    }
	}

	
	if (_attributeElements != null) {
	    final int count = _attributeElements.size();
	    for (int i = 0; i < count; i++) {
		SyntaxTreeNode node = 
		    (SyntaxTreeNode)_attributeElements.elementAt(i);
		node.translate(classGen, methodGen);
	    }
	}
	
	
	translateContents(classGen, methodGen);

	
	il.append(methodGen.endElement());
    }
}
"
org.apache.xpath.NodeSetDTM,56,2,1,21,84,714,14,7,56,0.739393939,839,0.833333333,1,0.363636364,0.160714286,1,4,13.875,9,1.5714,0,"
package org.apache.xpath;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.w3c.dom.traversal.NodeIterator;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;

import org.apache.xml.utils.NodeVector;
import org.apache.xpath.axes.ContextNodeList;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;



public class NodeSetDTM extends NodeVector
        implements  DTMIterator, 
        Cloneable
{

  
  public NodeSetDTM(DTMManager dtmManager)
  {
    super();
    m_manager = dtmManager;
  }

  
  public NodeSetDTM(int blocksize, int dummy, DTMManager dtmManager)
  {
    super(blocksize);
    m_manager = dtmManager;
  }

  














  
  public NodeSetDTM(NodeSetDTM nodelist)
  {

    super();
    m_manager = nodelist.getDTMManager();
    m_root = nodelist.getRoot();

    addNodes((DTMIterator) nodelist);
  }

  
  public NodeSetDTM(DTMIterator ni)
  {

    super();

    m_manager = ni.getDTMManager();
    m_root = ni.getRoot();
    addNodes(ni);
  }
  
  
  public NodeSetDTM(NodeIterator iterator, XPathContext xctxt)
  {

    super();

    Node node;
    m_manager = xctxt.getDTMManager();

    while (null != (node = iterator.nextNode()))
    {
      int handle = xctxt.getDTMHandleFromNode(node);
      addNodeInDocOrder(handle, xctxt);
    }
  }
  
  
  public NodeSetDTM(NodeList nodeList, XPathContext xctxt)
  {

    super();

    m_manager = xctxt.getDTMManager();

    int n = nodeList.getLength();
    for (int i = 0; i < n; i++) 
    {
      Node node = nodeList.item(i);
      int handle = xctxt.getDTMHandleFromNode(node);
      
      addNode(handle); 
    } 
  }


  
  public NodeSetDTM(int node, DTMManager dtmManager)
  {

    super();
    m_manager = dtmManager;

    addNode(node);
  }
  
  
  public void setEnvironment(Object environment)
  {
    
  }


  
  public int getRoot()
  {
    if(DTM.NULL == m_root)
    {
      if(size() > 0)
        return item(0);
      else
        return DTM.NULL;
    }
    else
      return m_root;
  }
  
  
  public void setRoot(int context, Object environment)
  {
    
  }

  
  public Object clone() throws CloneNotSupportedException
  {

    NodeSetDTM clone = (NodeSetDTM) super.clone();

    return clone;
  }

  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    NodeSetDTM clone = (NodeSetDTM) clone();

    clone.reset();

    return clone;
  }

  
  public void reset()
  {
    m_next = 0;
  }

  
  public int getWhatToShow()
  {
    return DTMFilter.SHOW_ALL & ~DTMFilter.SHOW_ENTITY_REFERENCE;
  }

  
  public DTMFilter getFilter()
  {
    return null;
  }

  
  public boolean getExpandEntityReferences()
  {
    return true;
  }
  
  
  public DTM getDTM(int nodeHandle)
  {
    
    return m_manager.getDTM(nodeHandle);
  }
  
  
  DTMManager m_manager;
  
  
  public DTMManager getDTMManager()
  {
    
    return m_manager;
  }

  
  public int nextNode()
  {

    if ((m_next) < this.size())
    {
      int next = this.elementAt(m_next);

      m_next++;

      return next;
    }
    else
      return DTM.NULL;
  }

  
  public int previousNode()
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE, null)); 

    if ((m_next - 1) > 0)
    {
      m_next--;

      return this.elementAt(m_next);
    }
    else
      return DTM.NULL;
  }

  
  public void detach(){}
  
  
  public void allowDetachToRelease(boolean allowRelease)
  {
    
  }


  
  public boolean isFresh()
  {
    return (m_next == 0);
  }

  
  public void runTo(int index)
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_INDEX, null)); 

    if ((index >= 0) && (m_next < m_firstFree))
      m_next = index;
    else
      m_next = m_firstFree - 1;
  }

  
  public int item(int index)
  {

    runTo(index);

    return this.elementAt(index);
  }

  
  public int getLength()
  {

    runTo(-1);

    return this.size();
  }

  
  public void addNode(int n)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    this.addElement(n);
  }

  
  public void insertNode(int n, int pos)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    insertElementAt(n, pos);
  }

  
  public void removeNode(int n)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    this.removeElement(n);
  }

  

































  

























  
  public void addNodes(DTMIterator iterator)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    if (null != iterator)  
    {
      int obj;

      while (DTM.NULL != (obj = iterator.nextNode()))
      {
        addElement(obj);
      }
    }

    
  }

  




























  
  public void addNodesInDocOrder(DTMIterator iterator, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    int node;

    while (DTM.NULL != (node = iterator.nextNode()))
    {
      addNodeInDocOrder(node, support);
    }
  }

  
































































  
  public int addNodeInDocOrder(int node, boolean test, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    int insertIndex = -1;

    if (test)
    {

      
      
      
      int size = size(), i;

      for (i = size - 1; i >= 0; i--)
      {
        int child = elementAt(i);

        if (child == node)
        {
          i = -2;  

          break;
        }

        DTM dtm = support.getDTM(node);
        if (!dtm.isNodeAfter(node, child))
        {
          break;
        }
      }

      if (i != -2)
      {
        insertIndex = i + 1;

        insertElementAt(node, insertIndex);
      }
    }
    else
    {
      insertIndex = this.size();

      boolean foundit = false;

      for (int i = 0; i < insertIndex; i++)
      {
        if (i == node)
        {
          foundit = true;

          break;
        }
      }

      if (!foundit)
        addElement(node);
    }

    
    return insertIndex;
  }  

  
  public int addNodeInDocOrder(int node, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    return addNodeInDocOrder(node, true, support);
  }  

  
  public int size()
  {
    return super.size();
  }

  
  public void addElement(int value)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.addElement(value);
  }

  
  public void insertElementAt(int value, int at)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.insertElementAt(value, at);
  }

  
  public void appendNodes(NodeVector nodes)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.appendNodes(nodes);
  }

  
  public void removeAllElements()
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.removeAllElements();
  }

  
  public boolean removeElement(int s)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    return super.removeElement(s);
  }

  
  public void removeElementAt(int i)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.removeElementAt(i);
  }

  
  public void setElementAt(int node, int index)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.setElementAt(node, index);
  }
  
  
  public void setItem(int node, int index)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_NOT_MUTABLE, null)); 

    super.setElementAt(node, index);
  }

  
  public int elementAt(int i)
  {

    runTo(i);

    return super.elementAt(i);
  }
  
  
  public boolean contains(int s)
  {

    runTo(-1);

    return super.contains(s);
  }

  
  public int indexOf(int elem, int index)
  {

    runTo(-1);

    return super.indexOf(elem, index);
  }

  
  public int indexOf(int elem)
  {

    runTo(-1);

    return super.indexOf(elem);
  }

  
  transient protected int m_next = 0;

  
  public int getCurrentPos()
  {
    return m_next;
  }

  
  public void setCurrentPos(int i)
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_INDEX, null)); 

    m_next = i;
  }

  
  public int getCurrentNode()
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        ""This NodeSetDTM can not do indexing or counting functions!"");

    int saved = m_next;
    
    
    
    int current = (m_next > 0) ? m_next-1 : m_next; 
    int n = (current < m_firstFree) ? elementAt(current) : DTM.NULL;
    m_next = saved; 
    return n;
  }

  
  transient protected boolean m_mutable = true;

  
  transient protected boolean m_cacheNodes = true;
  
  
  protected int m_root = DTM.NULL;

  
  public boolean getShouldCacheNodes()
  {
    return m_cacheNodes;
  }

  
  public void setShouldCacheNodes(boolean b)
  {

    if (!isFresh())
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANNOT_CALL_SETSHOULDCACHENODE, null)); 

    m_cacheNodes = b;
    m_mutable = true;
  }
  
  
  public boolean isMutable()
  {
    return m_mutable;
  }
  
  transient private int m_last = 0;
  
  public int getLast()
  {
    return m_last;
  }
  
  public void setLast(int last)
  {
    m_last = last;
  }
  
  
  public boolean isDocOrdered()
  {
    return true;
  }
  
  
  public int getAxis()
  {
    return -1;
  }
  

}
"
org.apache.xpath.compiler.Lexer,10,1,0,5,25,3,1,5,0,0.611111111,815,0.5,3,0.0,0.3125,0,0,79.9,11,2.8,1,"
package org.apache.xpath.compiler;

import org.apache.xml.utils.PrefixResolver;

import java.util.Vector;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xpath.XPath;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.OpCodes;
import org.apache.xpath.compiler.XPathParser;


class Lexer
{

  
  private Compiler m_compiler;

  
  PrefixResolver m_namespaceContext;

  
  XPathParser m_processor;

  
  static final int TARGETEXTRA = 10000;

  
  private int m_patternMap[] = new int[100];

  
  private int m_patternMapSize;

  
  Lexer(Compiler compiler, PrefixResolver resolver,
        XPathParser xpathProcessor)
  {

    m_compiler = compiler;
    m_namespaceContext = resolver;
    m_processor = xpathProcessor;
  }

  
  void tokenize(String pat) throws javax.xml.transform.TransformerException
  {
    tokenize(pat, null);
  }

  
  void tokenize(String pat, Vector targetStrings)
          throws javax.xml.transform.TransformerException
  {

    m_compiler.m_tokenQueueSize = 0;
    m_compiler.m_currentPattern = pat;
    m_patternMapSize = 0;
    m_compiler.m_opMap = new int[OpMap.MAXTOKENQUEUESIZE * 5];

    int nChars = pat.length();
    int startSubstring = -1;
    int posOfNSSep = -1;
    boolean isStartOfPat = true;
    boolean isAttrName = false;
    boolean isNum = false;

    
    
    int nesting = 0;

    
    for (int i = 0; i < nChars; i++)
    {
      char c = pat.charAt(i);

      switch (c)
      {
      case '""' :
      {
        if (startSubstring != -1)
        {
          isNum = false;
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;

          if (-1 != posOfNSSep)
          {
            posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, i);
          }
          else
          {
            addToTokenQueue(pat.substring(startSubstring, i));
          }
        }

        startSubstring = i;

        for (i++; (i < nChars) && ((c = pat.charAt(i)) != '""'); i++);

        if (c == '""' && i < nChars)
        {
          addToTokenQueue(pat.substring(startSubstring, i + 1));

          startSubstring = -1;
        }
        else
        {
          m_processor.error(XPATHErrorResources.ER_EXPECTED_DOUBLE_QUOTE,
                            null);  
        }
      }
      break;
      case ''' :
        if (startSubstring != -1)
        {
          isNum = false;
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;

          if (-1 != posOfNSSep)
          {
            posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, i);
          }
          else
          {
            addToTokenQueue(pat.substring(startSubstring, i));
          }
        }

        startSubstring = i;

        for (i++; (i < nChars) && ((c = pat.charAt(i)) != '''); i++);

        if (c == ''' && i < nChars)
        {
          addToTokenQueue(pat.substring(startSubstring, i + 1));

          startSubstring = -1;
        }
        else
        {
          m_processor.error(XPATHErrorResources.ER_EXPECTED_SINGLE_QUOTE,
                            null);  
        }
        break;
      case 0x0A :
      case 0x0D :
      case ' ' :
      case '	' :
        if (startSubstring != -1)
        {
          isNum = false;
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;

          if (-1 != posOfNSSep)
          {
            posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, i);
          }
          else
          {
            addToTokenQueue(pat.substring(startSubstring, i));
          }

          startSubstring = -1;
        }
        break;
      case '@' :
        isAttrName = true;

      
      case '-' :
        if ('-' == c)
        {
          if (!(isNum || (startSubstring == -1)))
          {
            break;
          }

          isNum = false;
        }

      
      case '(' :
      case '[' :
      case ')' :
      case ']' :
      case '|' :
      case '/' :
      case '*' :
      case '+' :
      case '=' :
      case ',' :
      case '\' :  
      case '^' :  
      case '!' :  
      case '$' :
      case '<' :
      case '>' :
        if (startSubstring != -1)
        {
          isNum = false;
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;

          if (-1 != posOfNSSep)
          {
            posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, i);
          }
          else
          {
            addToTokenQueue(pat.substring(startSubstring, i));
          }

          startSubstring = -1;
        }
        else if (('/' == c) && isStartOfPat)
        {
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
        }
        else if ('*' == c)
        {
          isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);
          isAttrName = false;
        }

        if (0 == nesting)
        {
          if ('|' == c)
          {
            if (null != targetStrings)
            {
              recordTokenString(targetStrings);
            }

            isStartOfPat = true;
          }
        }

        if ((')' == c) || (']' == c))
        {
          nesting--;
        }
        else if (('(' == c) || ('[' == c))
        {
          nesting++;
        }

        addToTokenQueue(pat.substring(i, i + 1));
        break;
      case ':' :
        if (i>0)
        {
          if (posOfNSSep == (i - 1))
          {
            if (startSubstring != -1)
            {
              if (startSubstring < (i - 1))
                addToTokenQueue(pat.substring(startSubstring, i - 1));
            }

            isNum = false;
            isAttrName = false;
            startSubstring = -1;
            posOfNSSep = -1;

            addToTokenQueue(pat.substring(i - 1, i + 1));

            break;
          }
          else
          {
            posOfNSSep = i;
          }
        }

      
      default :
        if (-1 == startSubstring)
        {
          startSubstring = i;
          isNum = Character.isDigit(c);
        }
        else if (isNum)
        {
          isNum = Character.isDigit(c);
        }
      }
    }

    if (startSubstring != -1)
    {
      isNum = false;
      isStartOfPat = mapPatternElemPos(nesting, isStartOfPat, isAttrName);

      if ((-1 != posOfNSSep) || 
         ((m_namespaceContext != null) && (m_namespaceContext.handlesNullPrefixes())))
      {
        posOfNSSep = mapNSTokens(pat, startSubstring, posOfNSSep, nChars);
      }
      else
      {
        addToTokenQueue(pat.substring(startSubstring, nChars));
      }
    }

    if (0 == m_compiler.m_tokenQueueSize)
    {
      m_processor.error(XPATHErrorResources.ER_EMPTY_EXPRESSION, null);  
    }
    else if (null != targetStrings)
    {
      recordTokenString(targetStrings);
    }

    m_processor.m_queueMark = 0;
  }

  
  private boolean mapPatternElemPos(int nesting, boolean isStart,
                                    boolean isAttrName)
  {

    if (0 == nesting)
    {
      if(m_patternMapSize >= m_patternMap.length)
      {
        int patternMap[] = m_patternMap;
        int len = m_patternMap.length;
        m_patternMap = new int[m_patternMapSize + 100];
        System.arraycopy(patternMap, 0, m_patternMap, 0, len);
      } 
      if (!isStart)
      {
        m_patternMap[m_patternMapSize - 1] -= TARGETEXTRA;
      }
      m_patternMap[m_patternMapSize] =
        (m_compiler.m_tokenQueueSize - (isAttrName ? 1 : 0)) + TARGETEXTRA;

      m_patternMapSize++;

      isStart = false;
    }

    return isStart;
  }

  
  private int getTokenQueuePosFromMap(int i)
  {

    int pos = m_patternMap[i];

    return (pos >= TARGETEXTRA) ? (pos - TARGETEXTRA) : pos;
  }

  
  private final void resetTokenMark(int mark)
  {

    int qsz = m_compiler.m_tokenQueueSize;

    m_processor.m_queueMark = (mark > 0)
                              ? ((mark <= qsz) ? mark - 1 : mark) : 0;

    if (m_processor.m_queueMark < qsz)
    {
      m_processor.m_token =
        (String) m_compiler.m_tokenQueue[m_processor.m_queueMark++];
      m_processor.m_tokenChar = m_processor.m_token.charAt(0);
    }
    else
    {
      m_processor.m_token = null;
      m_processor.m_tokenChar = 0;
    }
  }

  
  final int getKeywordToken(String key)
  {

    int tok;

    try
    {
      Integer itok = (Integer) Keywords.m_keywords.get(key);

      tok = (null != itok) ? itok.intValue() : 0;
    }
    catch (NullPointerException npe)
    {
      tok = 0;
    }
    catch (ClassCastException cce)
    {
      tok = 0;
    }

    return tok;
  }

  
  private void recordTokenString(Vector targetStrings)
  {

    int tokPos = getTokenQueuePosFromMap(m_patternMapSize - 1);

    resetTokenMark(tokPos + 1);

    if (m_processor.lookahead('(', 1))
    {
      int tok = getKeywordToken(m_processor.m_token);

      switch (tok)
      {
      case OpCodes.NODETYPE_COMMENT :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_COMMENT);
        break;
      case OpCodes.NODETYPE_TEXT :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_TEXT);
        break;
      case OpCodes.NODETYPE_NODE :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ANY);
        break;
      case OpCodes.NODETYPE_ROOT :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ROOT);
        break;
      case OpCodes.NODETYPE_ANYELEMENT :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ANY);
        break;
      case OpCodes.NODETYPE_PI :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ANY);
        break;
      default :
        targetStrings.addElement(PsuedoNames.PSEUDONAME_ANY);
      }
    }
    else
    {
      if (m_processor.tokenIs('@'))
      {
        tokPos++;

        resetTokenMark(tokPos + 1);
      }

      if (m_processor.lookahead(':', 1))
      {
        tokPos += 2;
      }

      targetStrings.addElement(m_compiler.m_tokenQueue[tokPos]);
    }
  }

  
  private final void addToTokenQueue(String s)
  {
    m_compiler.m_tokenQueue[m_compiler.m_tokenQueueSize++] = s;
  }

  
  private int mapNSTokens(String pat, int startSubstring, int posOfNSSep,
                          int posOfScan)
           throws javax.xml.transform.TransformerException
 {

    String prefix = """";
    
    if ((startSubstring >= 0) && (posOfNSSep >= 0))
    {
       prefix = pat.substring(startSubstring, posOfNSSep);
    }
    String uName;

    if ((null != m_namespaceContext) &&!prefix.equals(""*"")
            &&!prefix.equals(""xmlns""))
    {
      try
      {
        if (prefix.length() > 0)
          uName = ((PrefixResolver) m_namespaceContext).getNamespaceForPrefix(
            prefix);
        else
        {

          
          
          
          if (false)
          {
            addToTokenQueue("":"");

            String s = pat.substring(posOfNSSep + 1, posOfScan);

            if (s.length() > 0)
              addToTokenQueue(s);

            return -1;
          }
          else
          {
            uName =
              ((PrefixResolver) m_namespaceContext).getNamespaceForPrefix(
                prefix);
          }
        }
      }
      catch (ClassCastException cce)
      {
        uName = m_namespaceContext.getNamespaceForPrefix(prefix);
      }
    }
    else
    {
      uName = prefix;
    }

    if ((null != uName) && (uName.length() > 0))
    {
      addToTokenQueue(uName);
      addToTokenQueue("":"");

      String s = pat.substring(posOfNSSep + 1, posOfScan);

      if (s.length() > 0)
        addToTokenQueue(s);
    }
    else
    {

      
      m_processor.error(XPATHErrorResources.ER_PREFIX_MUST_RESOLVE,
                 new String[] {prefix});  


      
    }

    return -1;
  }
}
"
org.apache.xalan.xsltc.runtime.output.SAXOutput,8,2,3,7,16,18,3,4,6,0.8,114,1.0,0,0.837837838,0.5,1,1,12.625,1,0.75,0,"

package org.apache.xalan.xsltc.runtime.output;

import java.util.Stack;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.helpers.AttributesImpl;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.Constants;

abstract class SAXOutput extends OutputBase implements Constants { 

    protected ContentHandler _saxHandler;
    protected LexicalHandler _lexHandler = null;
    protected AttributesImpl _attributes = new AttributesImpl();
    protected String	     _elementName = null;
    protected String         _encoding = null; 

    public SAXOutput(ContentHandler handler, String encoding) {
	_saxHandler = handler;
	_encoding = encoding;	
    } 

    public SAXOutput(ContentHandler hdler, LexicalHandler lex, String encoding) {
	_saxHandler = hdler;
	_lexHandler = lex;
	_encoding = encoding;
    }

    public void startDocument() throws TransletException {
	try {
	    _saxHandler.startDocument();
	} 
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }

    public void characters(String  characters)
       throws TransletException
    {
	characters(characters.toCharArray(), 0, characters.length());	
    }

    public void comment(String comment) throws TransletException {
	try {
	    
            if (_startTagOpen) {
		closeStartTag();
	    }
	    else if (_cdataTagOpen) {
		closeCDATA();
	    }

	    
	    if (_lexHandler != null) {
		_lexHandler.comment(comment.toCharArray(), 0, comment.length());
	    }
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }

    public void processingInstruction(String target, String data) 
	throws TransletException 
    {
        
    }

    protected void closeStartTag() throws TransletException {
    }

    protected void closeCDATA() throws SAXException {
        
    }
}
"
org.apache.xalan.xsltc.trax.TrAXFilter,6,2,0,4,25,13,2,2,5,0.9,104,1.0,1,0.871794872,0.305555556,1,1,16.0,2,1.0,0,"


package org.apache.xalan.xsltc.trax;

import org.xml.sax.XMLFilter;
import org.xml.sax.helpers.XMLFilterImpl;
import javax.xml.transform.Templates;
import javax.xml.transform.TransformerConfigurationException;



public class TrAXFilter extends XMLFilterImpl {
    public TrAXFilter(Templates templates)  throws 
	TransformerConfigurationException
    {
	 
    }
}
"
org.apache.xml.utils.QName,28,1,0,54,49,268,50,4,28,0.562962963,732,0.8,0,0.0,0.285714286,1,1,24.96428571,9,1.4286,0,"
package org.apache.xml.utils;

import java.util.Stack;
import java.util.StringTokenizer;

import org.w3c.dom.Element;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;


public class QName implements java.io.Serializable
{

  
  protected String _localName;

  
  protected String _namespaceURI;

  
  protected String _prefix;

  
  public static final String S_XMLNAMESPACEURI =
    ""http:

  
  private int m_hashCode;

  
  public QName(){}

  
  public QName(String namespaceURI, String localName)
  {
    this(namespaceURI, localName, false); 
  }

  
  public QName(String namespaceURI, String localName, boolean validate) 
  {

    
    
    if (localName == null)
      throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_LOCALNAME_NULL, null)); 

    if (validate) 
    {
        if (!XMLChar.isValidNCName(localName))
        {
            throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }
    
    _namespaceURI = namespaceURI;
    _localName = localName;
    m_hashCode = toString().hashCode();
  }
  
  
  public QName(String namespaceURI, String prefix, String localName)
  {
     this(namespaceURI, prefix, localName, false);
  }
  
 
  public QName(String namespaceURI, String prefix, String localName, boolean validate)
  {

    
    
    if (localName == null)
      throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_LOCALNAME_NULL, null)); 

    if (validate)
    {    
        if (!XMLChar.isValidNCName(localName))
        {
            throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }

        if ((null != prefix) && (!XMLChar.isValidNCName(prefix)))
        {
            throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_PREFIX_INVALID,null )); 
        }

    }
    _namespaceURI = namespaceURI;
    _prefix = prefix;
    _localName = localName;
    m_hashCode = toString().hashCode();
  }  

  
  public QName(String localName)
  {
    this(localName, false);
  }
  
  
  public QName(String localName, boolean validate)
  {

    
    
    if (localName == null)
      throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_LOCALNAME_NULL, null)); 

    if (validate)
    {    
        if (!XMLChar.isValidNCName(localName))
        {
            throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }
    _namespaceURI = null;
    _localName = localName;
    m_hashCode = toString().hashCode();
  }  

  
  public QName(String qname, Stack namespaces)
  {
    this(qname, namespaces, false);
  }

  
  public QName(String qname, Stack namespaces, boolean validate)
  {

    String namespace = null;
    String prefix = null;
    int indexOfNSSep = qname.indexOf(':');

    if (indexOfNSSep > 0)
    {
      prefix = qname.substring(0, indexOfNSSep);

      if (prefix.equals(""xml""))
      {
        namespace = S_XMLNAMESPACEURI;
      }
      
      else if (prefix.equals(""xmlns""))
      {
        return;
      }
      else
      {
        int depth = namespaces.size();

        for (int i = depth - 1; i >= 0; i--)
        {
          NameSpace ns = (NameSpace) namespaces.elementAt(i);

          while (null != ns)
          {
            if ((null != ns.m_prefix) && prefix.equals(ns.m_prefix))
            {
              namespace = ns.m_uri;
              i = -1;

              break;
            }

            ns = ns.m_next;
          }
        }
      }

      if (null == namespace)
      {
        throw new RuntimeException(
          XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_PREFIX_MUST_RESOLVE,
            new Object[]{ prefix }));  
      }
    }

    _localName = (indexOfNSSep < 0)
                 ? qname : qname.substring(indexOfNSSep + 1);
                 
    if (validate)
    {
        if ((_localName == null) || (!XMLChar.isValidNCName(_localName))) 
        {
           throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }                 
    _namespaceURI = namespace;
    _prefix = prefix;
    m_hashCode = toString().hashCode();
  }

  
  public QName(String qname, Element namespaceContext,
               PrefixResolver resolver)
  {
      this(qname, namespaceContext, resolver, false);
  }

  
  public QName(String qname, Element namespaceContext,
               PrefixResolver resolver, boolean validate)
  {

    _namespaceURI = null;

    int indexOfNSSep = qname.indexOf(':');

    if (indexOfNSSep > 0)
    {
      if (null != namespaceContext)
      {
        String prefix = qname.substring(0, indexOfNSSep);

        _prefix = prefix;

        if (prefix.equals(""xml""))
        {
          _namespaceURI = S_XMLNAMESPACEURI;
        }
        
        
        else if (prefix.equals(""xmlns""))
        {
          return;
        }
        else
        {
          _namespaceURI = resolver.getNamespaceForPrefix(prefix,
                  namespaceContext);
        }

        if (null == _namespaceURI)
        {
          throw new RuntimeException(
            XSLMessages.createXPATHMessage(
              XPATHErrorResources.ER_PREFIX_MUST_RESOLVE,
              new Object[]{ prefix }));  
        }
      }
      else
      {

        
      }
    }

    _localName = (indexOfNSSep < 0)
                 ? qname : qname.substring(indexOfNSSep + 1);

    if (validate)
    {
        if ((_localName == null) || (!XMLChar.isValidNCName(_localName))) 
        {
           throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }                 
                 
    m_hashCode = toString().hashCode();
  }


  
  public QName(String qname, PrefixResolver resolver)
  {
    this(qname, resolver, false);
  }

  
  public QName(String qname, PrefixResolver resolver, boolean validate)
  {

	String prefix = null;
    _namespaceURI = null;

    int indexOfNSSep = qname.indexOf(':');

    if (indexOfNSSep > 0)
    {
      prefix = qname.substring(0, indexOfNSSep);

      if (prefix.equals(""xml""))
      {
        _namespaceURI = S_XMLNAMESPACEURI;
      }
      else
      {
        _namespaceURI = resolver.getNamespaceForPrefix(prefix);
      }

      if (null == _namespaceURI)
      {
        throw new RuntimeException(
          XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_PREFIX_MUST_RESOLVE,
            new Object[]{ prefix }));  
      }
    }

	_localName = (indexOfNSSep < 0)
                 ? qname : qname.substring(indexOfNSSep + 1);   
                 
    if (validate)
    {
        if ((_localName == null) || (!XMLChar.isValidNCName(_localName))) 
        {
           throw new IllegalArgumentException(XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_ARG_LOCALNAME_INVALID,null )); 
        }
    }                 

              
    m_hashCode = toString().hashCode();
    _prefix = prefix;
  }

  
  public String getNamespaceURI()
  {
    return _namespaceURI;
  }

  
  public String getPrefix()
  {
    return _prefix;
  }

  
  public String getLocalName()
  {
    return _localName;
  }

  
  public String toString()
  {

    return _prefix != null
           ? (_prefix + "":"" + _localName)
           : (_namespaceURI != null
              ? (""{""+_namespaceURI + ""}"" + _localName) : _localName);
  }
  
  
  public String toNamespacedString()
  {

    return (_namespaceURI != null
              ? (""{""+_namespaceURI + ""}"" + _localName) : _localName);
  }


  
  public String getNamespace()
  {
    return getNamespaceURI();
  }

  
  public String getLocalPart()
  {
    return getLocalName();
  }

  
  public int hashCode()
  {
    return m_hashCode;
  }

  
  public boolean equals(String ns, String localPart)
  {

    String thisnamespace = getNamespaceURI();

    return getLocalName().equals(localPart)
           && (((null != thisnamespace) && (null != ns))
               ? thisnamespace.equals(ns)
               : ((null == thisnamespace) && (null == ns)));
  }

  
  public boolean equals(Object object)
  {

    if (object == this)
      return true;

    if (object instanceof QName) {
      QName qname = (QName) object;
      String thisnamespace = getNamespaceURI();
      String thatnamespace = qname.getNamespaceURI();

      return getLocalName().equals(qname.getLocalName())
             && (((null != thisnamespace) && (null != thatnamespace))
                 ? thisnamespace.equals(thatnamespace)
                 : ((null == thisnamespace) && (null == thatnamespace)));
    }
    else
      return false;
  }

  
  public static QName getQNameFromString(String name)
  {

    StringTokenizer tokenizer = new StringTokenizer(name, ""{}"", false);
    QName qname;
    String s1 = tokenizer.nextToken();
    String s2 = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;

    if (null == s2)
      qname = new QName(null, s1);
    else
      qname = new QName(s1, s2);

    return qname;
  }

  
  public static boolean isXMLNSDecl(String attRawName)
  {

    return (attRawName.startsWith(""xmlns"")
            && (attRawName.equals(""xmlns"")
                || attRawName.startsWith(""xmlns:"")));
  }

  
  public static String getPrefixFromXMLNSDecl(String attRawName)
  {

    int index = attRawName.indexOf(':');

    return (index >= 0) ? attRawName.substring(index + 1) : """";
  }

  
  public static String getLocalPart(String qname)
  {

    int index = qname.indexOf(':');

    return (index < 0) ? qname : qname.substring(index + 1);
  }

  
  public static String getPrefixPart(String qname)
  {

    int index = qname.indexOf(':');

    return (index >= 0) ? qname.substring(0, index) : """";
  }
}
"
org.apache.xpath.operations.Variable,16,2,1,25,51,50,7,19,16,0.746666667,356,0.8,1,0.666666667,0.1875,2,9,20.9375,9,2.25,0,"
package org.apache.xpath.operations;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemVariable;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.QName;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionNode;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.axes.PathComponent;
import org.apache.xpath.axes.WalkerFactory;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;



public class Variable extends Expression implements PathComponent
{
  
  private boolean m_fixUpWasCalled = false;

  
  protected QName m_qname;
  
  
  protected int m_index;
  
  
  public void setIndex(int index)
  {
  	m_index = index;
  }
  
  
  public int getIndex()
  {
  	return m_index;
  }
  
  
  public void setIsGlobal(boolean isGlobal)
  {
  	m_isGlobal = isGlobal;
  }
  
  
  public boolean getGlobal()
  {
  	return m_isGlobal;
  }

  
  

  
  protected boolean m_isGlobal = false;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    m_fixUpWasCalled = true;
    int sz = vars.size();

    for (int i = vars.size()-1; i >= 0; i--) 
    {
      QName qn = (QName)vars.elementAt(i);
      
      if(qn.equals(m_qname))
      {
        
        if(i < globalsSize)
        {
          m_isGlobal = true;
          m_index = i;
        }
        else
        {
          m_index = i-globalsSize;
        }
          
        return;
      }
    }
    
    java.lang.String msg = XSLMessages.createXPATHMessage(XPATHErrorResources.ER_COULD_NOT_FIND_VAR, 
                                             new Object[]{m_qname.toString()});
                                             
    TransformerException te = new TransformerException(msg, this);
                                             
    throw new org.apache.xml.utils.WrappedRuntimeException(te);
    
  }


  
  public void setQName(QName qname)
  {
    m_qname = qname;
  }
  
  
  public QName getQName()
  {
    return m_qname;
  }
  
  
  public XObject execute(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
  	return execute(xctxt, false);
  }


  
  public XObject execute(XPathContext xctxt, boolean destructiveOK) throws javax.xml.transform.TransformerException
  {
  	org.apache.xml.utils.PrefixResolver xprefixResolver = xctxt.getNamespaceContext();

    
    
    if(m_fixUpWasCalled)
    {    
      XObject result;
      if(m_isGlobal)
        result = xctxt.getVarStack().getGlobalVariable(xctxt, m_index, destructiveOK);
      else
        result = xctxt.getVarStack().getLocalVariable(xctxt, m_index, destructiveOK);
  
      if (null == result)
      {
        
        warn(xctxt, XPATHErrorResources.WG_ILLEGAL_VARIABLE_REFERENCE,
             new Object[]{ m_qname.getLocalPart() });  
  
  
  
        
        result = new XNodeSet(xctxt.getDTMManager());
      }
  
      return result;
    }
    else
    {
      
      
      synchronized(this)
      {
      	org.apache.xalan.templates.ElemVariable vvar= getElemVariable();
      	if(null != vvar)
      	{
          m_index = vvar.getIndex();
          m_isGlobal = vvar.getIsTopLevel();
          m_fixUpWasCalled = true;
          return execute(xctxt);
      	}
      }
      throw new javax.xml.transform.TransformerException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_VAR_NOT_RESOLVABLE, new Object[]{m_qname.toString()})); 
    }
  }
  
  
  public org.apache.xalan.templates.ElemVariable getElemVariable()
  {
  	
    
    
    
    
    
    
    org.apache.xpath.ExpressionNode owner = getExpressionOwner();

    if (null != owner && owner instanceof org.apache.xalan.templates.ElemTemplateElement)
    {

      org.apache.xalan.templates.ElemVariable vvar;

      org.apache.xalan.templates.ElemTemplateElement prev = 
        (org.apache.xalan.templates.ElemTemplateElement) owner;

      if (!(prev instanceof org.apache.xalan.templates.Stylesheet))
      {            
        while ( !(prev.getParentNode() instanceof org.apache.xalan.templates.Stylesheet) )
        {
          org.apache.xalan.templates.ElemTemplateElement savedprev = prev;

          while (null != (prev = prev.getPreviousSiblingElem()))
          {
            if(prev instanceof org.apache.xalan.templates.ElemVariable)
            {
              vvar = (org.apache.xalan.templates.ElemVariable) prev;
            
              if (vvar.getName().equals(m_qname))
              {
                return vvar;
              }
            }
          }
          prev = savedprev.getParentElem();
        }
      }

      vvar = prev.getStylesheetRoot().getVariableOrParamComposed(m_qname);
      if (null != vvar)
      {
        return vvar;
      }

    }
    return null;

  }
  
  
  public boolean isStableNumber()
  {
    return true;
  }
  
  
  public int getAnalysisBits()
  {
  	org.apache.xalan.templates.ElemVariable vvar = getElemVariable();
  	if(null != vvar)
  	{
  		XPath xpath = vvar.getSelect();
  		if(null != xpath)
  		{
	  		Expression expr = xpath.getExpression();
	  		if(null != expr && expr instanceof PathComponent)
	  		{
	  			return ((PathComponent)expr).getAnalysisBits();
	  		}
  		}
  	}
    return WalkerFactory.BIT_FILTER;
  }


  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	visitor.visitVariableRef(owner, this);
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	if(!m_qname.equals(((Variable)expr).m_qname))
  		return false;
  		
  	
  	
    if(getElemVariable() != ((Variable)expr).getElemVariable())
    	return false;
  		
  	return true;
  }
  
  static final java.lang.String PSUEDOVARNAMESPACE = ""http:
  
  
  public boolean isPsuedoVarRef()
  {
  	java.lang.String ns = m_qname.getNamespaceURI();
  	if((null != ns) && ns.equals(PSUEDOVARNAMESPACE))
  	{
  		if(m_qname.getLocalName().startsWith(""#""))
  			return true;
  	}
  	return false;
  }
  

}
"
org.apache.xalan.xsltc.compiler.AbsoluteLocationPath,7,3,0,22,28,0,1,21,7,0.0,143,1.0,1,0.934210526,0.285714286,2,7,19.28571429,2,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class AbsoluteLocationPath extends Expression {
    private Expression _path;	

    public AbsoluteLocationPath() {
	_path = null;
    }

    public AbsoluteLocationPath(Expression path) {
	_path = path;
	if (path != null) {
	    _path.setParent(this);
	}
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_path != null) {
	    _path.setParser(parser);
	}
    }

    public Expression getPath() {
	return(_path);
    }
    
    public String toString() {
	return ""AbsoluteLocationPath("" +
	    (_path != null ? _path.toString() : ""null"") + ')';
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_path != null) {
	    final Type ptype = _path.typeCheck(stable);
	    if (ptype instanceof NodeType) {		
		_path = new CastExpr(_path, Type.NodeSet);
	    }
	}
	return _type = Type.NodeSet;	
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	if (_path != null) {
	    final int initAI = cpg.addMethodref(ABSOLUTE_ITERATOR,
						""<init>"",
						""(""
						+ NODE_ITERATOR_SIG
						+ "")V"");
	    
	    il.append(new NEW(cpg.addClass(ABSOLUTE_ITERATOR)));
	    il.append(DUP);

	    
	    _path.translate(classGen, methodGen);

	    
	    il.append(new INVOKESPECIAL(initAI));
	}
	else {
	    final int gitr = cpg.addInterfaceMethodref(DOM_INTF,
						       ""getIterator"",
						       ""()""+NODE_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(new INVOKEINTERFACE(gitr, 1));
	}
    }
}
"
org.apache.xml.utils.DOMBuilder,30,1,0,4,62,223,2,2,28,0.634482759,460,0.6,0,0.0,0.2,0,0,14.16666667,5,1.0667,0,"
package org.apache.xml.utils;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xml.utils.NodeVector;
import java.util.Stack;

import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.Attributes;

import org.w3c.dom.*;  


public class DOMBuilder
        implements ContentHandler, LexicalHandler
{

  
  public Document m_doc;

  
  protected Node m_currentNode = null;

  
  public DocumentFragment m_docFrag = null;

  
  protected Stack m_elemStack = new Stack();

  
  public DOMBuilder(Document doc, Node node)
  {
    m_doc = doc;
    m_currentNode = node;
  }

  
  public DOMBuilder(Document doc, DocumentFragment docFrag)
  {
    m_doc = doc;
    m_docFrag = docFrag;
  }

  
  public DOMBuilder(Document doc)
  {
    m_doc = doc;
  }

  
  public Node getRootNode()
  {
    return (null != m_docFrag) ? (Node) m_docFrag : (Node) m_doc;
  }

  
  public Node getCurrentNode()
  {
    return m_currentNode;
  }

  
  public java.io.Writer getWriter()
  {
    return null;
  }

  
  protected void append(Node newNode) throws org.xml.sax.SAXException
  {

    Node currentNode = m_currentNode;

    if (null != currentNode)
    {
      currentNode.appendChild(newNode);

      
    }
    else if (null != m_docFrag)
    {
      m_docFrag.appendChild(newNode);
    }
    else
    {
      boolean ok = true;
      short type = newNode.getNodeType();

      if (type == Node.TEXT_NODE)
      {
        String data = newNode.getNodeValue();

        if ((null != data) && (data.trim().length() > 0))
        {
          throw new org.xml.sax.SAXException(
            XSLMessages.createXPATHMessage(
              XPATHErrorResources.ER_CANT_OUTPUT_TEXT_BEFORE_DOC, null));  
        }

        ok = false;
      }
      else if (type == Node.ELEMENT_NODE)
      {
        if (m_doc.getDocumentElement() != null)
        {
          throw new org.xml.sax.SAXException(
            XSLMessages.createXPATHMessage(
              XPATHErrorResources.ER_CANT_HAVE_MORE_THAN_ONE_ROOT, null));  
        }
      }

      if (ok)
        m_doc.appendChild(newNode);
    }
  }

  
  public void setDocumentLocator(Locator locator)
  {

    
  }

  
  public void startDocument() throws org.xml.sax.SAXException
  {

    
  }

  
  public void endDocument() throws org.xml.sax.SAXException
  {

    
  }

  
  public void startElement(
          String ns, String localName, String name, Attributes atts)
            throws org.xml.sax.SAXException
  {

    Element elem;

	
	
    if ((null == ns) || (ns.length() == 0))
      elem = m_doc.createElementNS(null,name);
    else
      elem = m_doc.createElementNS(ns, name);

    append(elem);

    try
    {
      int nAtts = atts.getLength();
  
      if (0 != nAtts)
      {
        for (int i = 0; i < nAtts; i++)
        {
  
          
          
          if (atts.getType(i).equalsIgnoreCase(""ID""))
            setIDAttribute(atts.getValue(i), elem);
  
          String attrNS = atts.getURI(i);
          
          if("""".equals(attrNS))
            attrNS = null; 
  
          
          
          
          String attrQName = atts.getQName(i);
          
          elem.setAttributeNS(attrNS,attrQName, atts.getValue(i));
        }
      }
      
      
  
      m_elemStack.push(elem);
  
      m_currentNode = elem;
      
      
    }
    catch(java.lang.Exception de)
    {
      
      throw new org.xml.sax.SAXException(de);
    }
    
  }

  
  public void endElement(String ns, String localName, String name)
          throws org.xml.sax.SAXException
  {
    m_elemStack.pop();
    m_currentNode = m_elemStack.isEmpty() ? null : (Node)m_elemStack.peek();
  }

  
  public void setIDAttribute(String id, Element elem)
  {

    
  }

  
  public void characters(char ch[], int start, int length) throws org.xml.sax.SAXException
  {
    if(isOutsideDocElem()
       && org.apache.xml.utils.XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return;  

    if (m_inCData)
    {
      cdata(ch, start, length);

      return;
    }

    String s = new String(ch, start, length);
    Text text = m_doc.createTextNode(s);

    append(text);
  }

  
  public void charactersRaw(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {
    if(isOutsideDocElem()  
       && org.apache.xml.utils.XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return;  


    String s = new String(ch, start, length);

    append(m_doc.createProcessingInstruction(""xslt-next-is-raw"",
                                             ""formatter-to-dom""));
    append(m_doc.createTextNode(s));
  }

  
  public void startEntity(String name) throws org.xml.sax.SAXException
  {

    
    
  }

  
  public void endEntity(String name) throws org.xml.sax.SAXException{}

  
  public void entityReference(String name) throws org.xml.sax.SAXException
  {
    append(m_doc.createEntityReference(name));
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {
    if(isOutsideDocElem())
      return;  

    String s = new String(ch, start, length);

    append(m_doc.createTextNode(s));
  }
  
  
   private boolean isOutsideDocElem()
   {
      return (null == m_docFrag) && m_elemStack.size() == 0 && (null == m_currentNode || m_currentNode.getNodeType() == Node.DOCUMENT_NODE);
   }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {
    append(m_doc.createProcessingInstruction(target, data));
  }

  
  public void comment(char ch[], int start, int length) throws org.xml.sax.SAXException
  {
    append(m_doc.createComment(new String(ch, start, length)));
  }

  
  protected boolean m_inCData = false;

  
  public void startCDATA() throws org.xml.sax.SAXException
  {
    m_inCData = true;
  }

  
  public void endCDATA() throws org.xml.sax.SAXException
  {
    m_inCData = false;
  }

  
  public void cdata(char ch[], int start, int length) throws org.xml.sax.SAXException
  {
    if(isOutsideDocElem()  
       && org.apache.xml.utils.XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return;  

    String s = new String(ch, start, length);

    append(m_doc.createCDATASection(s));
  }

  
  public void startDTD(String name, String publicId, String systemId)
          throws org.xml.sax.SAXException
  {

    
  }

  
  public void endDTD() throws org.xml.sax.SAXException
  {

    
  }

  
  public void startPrefixMapping(String prefix, String uri)
          throws org.xml.sax.SAXException
  {

    
  }

  
  public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException{}

  
  public void skippedEntity(String name) throws org.xml.sax.SAXException{}
}
"
org.apache.xalan.xsltc.compiler.util.TestGenerator,13,5,0,11,20,54,2,9,12,0.9,119,1.0,0,0.926174497,0.21875,2,5,7.384615385,2,0.9231,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Template;

public final class TestGenerator extends MethodGenerator {
    private static int CONTEXT_NODE_INDEX = 1;
    private static int CURRENT_NODE_INDEX = 4;
    private static int ITERATOR_INDEX = 6;

    private Instruction _aloadDom;
    private final Instruction _iloadCurrent;
    private final Instruction _iloadContext;
    private final Instruction _istoreCurrent;
    private final Instruction _istoreContext;
    private final Instruction _astoreIterator;
    private final Instruction _aloadIterator;

    public TestGenerator(int access_flags, Type return_type,
			 Type[] arg_types, String[] arg_names,
			 String method_name, String class_name,
			 InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
	
	_iloadCurrent  = new ILOAD(CURRENT_NODE_INDEX);
	_istoreCurrent = new ISTORE(CURRENT_NODE_INDEX);
	_iloadContext  = new ILOAD(CONTEXT_NODE_INDEX);
	_istoreContext  = new ILOAD(CONTEXT_NODE_INDEX);
	_astoreIterator = new ASTORE(ITERATOR_INDEX);
	_aloadIterator  = new ALOAD(ITERATOR_INDEX);
    }

    public int getHandlerIndex() {
	return INVALID_INDEX;		
    }

    public int getIteratorIndex() {
	return ITERATOR_INDEX;		
    }

    public void setDomIndex(int domIndex) {
	_aloadDom = new ALOAD(domIndex);
    }

    public Instruction loadDOM() {
	return _aloadDom;
    }

    public Instruction loadCurrentNode() {
	return _iloadCurrent;
    }

    
    public Instruction loadContextNode() {
	return _iloadContext;
    }

    public Instruction storeContextNode() {
	return _istoreContext;
    }

    public Instruction storeCurrentNode() {
	return _istoreCurrent;
    }

    public Instruction storeIterator() {
	return _astoreIterator;
    }
    
    public Instruction loadIterator() {
	return _aloadIterator;
    }

    public int getLocalIndex(String name) {
	if (name.equals(""current"")) {
	    return CURRENT_NODE_INDEX;
	}
	else {
	    return super.getLocalIndex(name);
	}
    }
}
"
org.apache.xml.utils.WrongParserException,1,4,0,0,2,0,0,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"
package org.apache.xml.utils;


public class WrongParserException extends RuntimeException
{

  
  public WrongParserException(String message)
  {
    super(message);
  }
}
"
org.apache.xalan.xsltc.compiler.AbsolutePathPattern,8,5,0,33,44,0,1,33,8,0.142857143,241,1.0,1,0.933962264,0.270833333,3,4,29.0,6,1.875,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class AbsolutePathPattern extends LocationPathPattern {
    private final RelativePathPattern _left; 

    public AbsolutePathPattern(RelativePathPattern left) {
	_left = left;
	if (left != null) {
	    left.setParent(this);
	}
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_left != null)
	    _left.setParser(parser);
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _left == null ? Type.Root : _left.typeCheck(stable);
    }

    public boolean isWildcard() {
	return false;
    }
	
    public StepPattern getKernelPattern() {
	return _left != null ? _left.getKernelPattern() : null;
    }
	
    public void reduceKernelPattern() {
	_left.reduceKernelPattern();
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_left != null) {
	    if (_left instanceof StepPattern) {
		final LocalVariableGen local = 
		    
		    methodGen.addLocalVariable2(""apptmp"", 
						Util.getJCRefType(NODE_SIG),
						il.getEnd());
		il.append(DUP);
		il.append(new ISTORE(local.getIndex()));
		_left.translate(classGen, methodGen);
		il.append(methodGen.loadDOM());
		local.setEnd(il.append(new ILOAD(local.getIndex())));
		methodGen.removeLocalVariable(local);
	    }
	    else {
		_left.translate(classGen, methodGen);
	    }
	}

	final int getParent = cpg.addInterfaceMethodref(DOM_INTF,
							GET_PARENT,
							GET_PARENT_SIG);
	final int getType = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getType"", ""(I)I"");

	InstructionHandle begin = il.append(methodGen.loadDOM());
	il.append(SWAP);
	il.append(new INVOKEINTERFACE(getParent, 2));
	if (_left instanceof AncestorPattern) {	
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	}
	il.append(new INVOKEINTERFACE(getType, 2));
	il.append(new PUSH(cpg, DOM.ROOT));
	
	final BranchHandle skip = il.append(new IF_ICMPEQ(null));
	_falseList.add(il.append(new GOTO_W(null)));
	skip.setTarget(il.append(NOP));

	if (_left != null) {
	    _left.backPatchTrueList(begin);
	    
	    
	    if (_left instanceof AncestorPattern) {
		final AncestorPattern ancestor = (AncestorPattern) _left;
		_falseList.backPatch(ancestor.getLoopHandle());		
	    }
	    _falseList.append(_left._falseList);
	}
    }
	
    public String toString() {
	return ""absolutePathPattern("" + (_left != null ? _left.toString() : "")"");
    }
}
"
org.apache.xalan.templates.AVTPart,7,1,2,8,8,21,3,5,7,2.0,13,0.0,0,0.0,0.306122449,0,0,0.857142857,1,0.8571,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.apache.xpath.XPathContext;
import org.apache.xml.utils.FastStringBuffer;


public abstract class AVTPart implements java.io.Serializable, XSLTVisitable
{

  
  public AVTPart(){}

  
  public abstract String getSimpleString();

  
  public abstract void evaluate(
    XPathContext xctxt, FastStringBuffer buf, int context,
      org.apache.xml.utils.PrefixResolver nsNode)
        throws javax.xml.transform.TransformerException;

  
  public void setXPathSupport(XPathContext support){}
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return false;
   }
   
  
  public abstract void fixupVariables(java.util.Vector vars, int globalsSize);


}
"
org.apache.xalan.xsltc.runtime.Attributes,7,1,0,1,8,21,0,1,7,1.0,30,1.0,1,0.0,0.5,0,0,3.0,1,0.8571,0,"

package org.apache.xalan.xsltc.runtime;

import org.xml.sax.AttributeList;
import org.apache.xalan.xsltc.DOM;

public final class Attributes implements AttributeList {
    private int _element;
    private DOM _document;

    public Attributes(DOM document, int element) {
	_element = element;
	_document = document;
    }

    public int getLength() {
	return 0;
    }

    public String getName(int i) {
	return null;
    }

    public String getType(int i) {
	return null;
    }

    public String getType(String name) {
	return null;
    }

    public String getValue(int i) {
	return null;
    }

    public String getValue(String name) {
	return null;
    }
}
"
org.apache.xpath.axes.FilterExprIteratorSimple,16,5,0,19,44,8,4,16,14,0.75,261,1.0,2,0.899280576,0.18125,3,10,15.0625,4,1.4375,0,"package org.apache.xpath.axes;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XNodeSet;


public class FilterExprIteratorSimple extends LocPathIterator
{
  
  private Expression m_expr;

  
  transient private XNodeSet m_exprObj;

  private boolean m_mustHardReset = false;
  private boolean m_canDetachNodeset = true;

  
  public FilterExprIteratorSimple()
  {
    super(null);
  }
  
  
  public FilterExprIteratorSimple(Expression expr)
  {
    super(null);
    m_expr = expr;
  }
  
  
  public void setRoot(int context, Object environment)
  {
  	super.setRoot(context, environment);
  	m_exprObj = executeFilterExpr(context, m_execContext, getPrefixResolver(), 
  	                  getIsTopLevel(), m_stackFrame, m_expr);
  }

  
  public static XNodeSet executeFilterExpr(int context, XPathContext xctxt, 
  												PrefixResolver prefixResolver,
  												boolean isTopLevel,
  												int stackFrame,
  												Expression expr )
    throws org.apache.xml.utils.WrappedRuntimeException
  {
    PrefixResolver savedResolver = xctxt.getNamespaceContext();
    XNodeSet result = null;

    try
    {
      xctxt.pushCurrentNode(context);
      xctxt.setNamespaceContext(prefixResolver);

      
      
      
      

      if (isTopLevel)
      {
        
        VariableStack vars = xctxt.getVarStack();

        
        int savedStart = vars.getStackFrame();
        vars.setStackFrame(stackFrame);

        result = (org.apache.xpath.objects.XNodeSet) expr.execute(xctxt);
        result.setShouldCacheNodes(true);

        
        vars.setStackFrame(savedStart);
      }
      else
          result = (org.apache.xpath.objects.XNodeSet) expr.execute(xctxt);

    }
    catch (javax.xml.transform.TransformerException se)
    {

      
      throw new org.apache.xml.utils.WrappedRuntimeException(se);
    }
    finally
    {
      xctxt.popCurrentNode();
      xctxt.setNamespaceContext(savedResolver);
    }
    return result;
  }
  
  
  public int nextNode()
  {
  	if(m_foundLast)
  		return DTM.NULL;

    int next;

    if (null != m_exprObj)
    {
      m_lastFetched = next = m_exprObj.nextNode();
    }
    else
      m_lastFetched = next = DTM.NULL;

    
    if (DTM.NULL != next)
    {
      m_pos++;
      return next;
    }
    else
    {
      m_foundLast = true;

      return DTM.NULL;
    }
  }
  
  
  public void detach()
  {  
    if(m_allowDetach)
    {
  		super.detach();
  		m_exprObj.detach();
  		m_exprObj = null;
    }
  }

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    m_expr.fixupVariables(vars, globalsSize);
  }

  
  public Expression getInnerExpression()
  {
    return m_expr;
  }

  
  public void setInnerExpression(Expression expr)
  {
    expr.exprSetParent(this);
    m_expr = expr;
  }

  
  public int getAnalysisBits()
  {
    if (null != m_expr && m_expr instanceof PathComponent)
    {
      return ((PathComponent) m_expr).getAnalysisBits();
    }
    return WalkerFactory.BIT_FILTER;
  }

  
  public boolean isDocOrdered()
  {
    return m_exprObj.isDocOrdered();
  }

  class filterExprOwner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_expr;
    }

    
    public void setExpression(Expression exp)
    {
      exp.exprSetParent(FilterExprIteratorSimple.this);
      m_expr = exp;
    }

  }

  
  public void callPredicateVisitors(XPathVisitor visitor)
  {
    m_expr.callVisitors(new filterExprOwner(), visitor);

    super.callPredicateVisitors(visitor);
  }

  
  public boolean deepEquals(Expression expr)
  {
    if (!super.deepEquals(expr))
      return false;

    FilterExprIteratorSimple fet = (FilterExprIteratorSimple) expr;
    if (!m_expr.deepEquals(fet.m_expr))
      return false;

    return true;
  }
  
  
  public int getAxis()
  {
  	if(null != m_exprObj)
    	return m_exprObj.getAxis();
    else
    	return Axis.FILTEREDLIST;
  }


}

"
org.apache.xml.dtm.ref.DTMManagerDefault,16,2,0,25,85,76,6,22,16,0.8,736,0.8,2,0.558823529,0.215909091,1,1,44.6875,25,4.125,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;

import java.util.Vector;


import javax.xml.parsers.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.Source;
import javax.xml.transform.SourceLocator;


import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.dtm.ref.dom2dtm.DOM2DTM;
import org.apache.xml.dtm.ref.sax2dtm.SAX2DTM;
import org.apache.xml.dtm.ref.sax2dtm.SAX2RTFDTM;




import org.w3c.dom.Document;
import org.w3c.dom.Node;


import org.xml.sax.InputSource;
import org.xml.sax.XMLReader;
import org.xml.sax.ContentHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.helpers.XMLReaderFactory;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.LexicalHandler;

import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;


public class DTMManagerDefault extends DTMManager
{
  

  
  private static final boolean DUMPTREE = false;

  
  private static final boolean DEBUG = false;

  
  protected DTM m_dtms[] = new DTM[256];
	
  
  int m_dtm_offsets[] = new int[256];

  
  synchronized public void addDTM(DTM dtm, int id) {	addDTM(dtm,id,0); }

	
  
  synchronized public void addDTM(DTM dtm, int id, int offset)
  {
		if(id>=IDENT_MAX_DTMS)
		{
			
	    throw new DTMException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_DTMIDS_AVAIL, null)); 
		}
		
		
		
		
		
		
		int oldlen=m_dtms.length;
		if(oldlen<=id)
		{
			
			
			
			
			
			int newlen=Math.min((id+256),IDENT_MAX_DTMS);

			DTM new_m_dtms[] = new DTM[newlen];
			System.arraycopy(m_dtms,0,new_m_dtms,0,oldlen);
			m_dtms=new_m_dtms;
			int new_m_dtm_offsets[] = new int[newlen];
			System.arraycopy(m_dtm_offsets,0,new_m_dtm_offsets,0,oldlen);
			m_dtm_offsets=new_m_dtm_offsets;
		}
		
    m_dtms[id] = dtm;
		m_dtm_offsets[id]=offset;
    dtm.documentRegistration();
		
		
  }

  
  synchronized public int getFirstFreeDTMID()
  {
    int n = m_dtms.length;
    for (int i = 1; i < n; i++)
    {
      if(null == m_dtms[i])
      {
        return i;
      }
    }
		return n; 
  }

  
  private ExpandedNameTable m_expandedNameTable =
    new ExpandedNameTable();

  
  public DTMManagerDefault(){}


  
  synchronized public DTM getDTM(Source source, boolean unique,
                                 DTMWSFilter whiteSpaceFilter,
                                 boolean incremental, boolean doIndexing)
  {

    if(DEBUG && null != source)
      System.out.println(""Starting ""+
                         (unique ? ""UNIQUE"" : ""shared"")+
                         "" source: ""+source.getSystemId()
                         );

    XMLStringFactory xstringFactory = m_xsf;
    int dtmPos = getFirstFreeDTMID();
    int documentID = dtmPos << IDENT_DTM_NODE_BITS;

    if ((null != source) && source instanceof DOMSource)
    {
      DOM2DTM dtm = new DOM2DTM(this, (DOMSource) source, documentID,
                                whiteSpaceFilter, xstringFactory, doIndexing);

      addDTM(dtm, dtmPos, 0);

      
      
      
      

      return dtm;
    }
    else
    {
      boolean isSAXSource = (null != source)
        ? (source instanceof SAXSource) : true;
      boolean isStreamSource = (null != source)
        ? (source instanceof StreamSource) : false;

      if (isSAXSource || isStreamSource)
      {
        XMLReader reader;
        InputSource xmlSource;

        if (null == source)
        {
          xmlSource = null;
          reader = null;
        }
        else
        {
          reader = getXMLReader(source);
          xmlSource = SAXSource.sourceToInputSource(source);

          String urlOfSource = xmlSource.getSystemId();

          if (null != urlOfSource)
          {
            try
            {
              urlOfSource = SystemIDResolver.getAbsoluteURI(urlOfSource);
            }
            catch (Exception e)
            {

              
              System.err.println(""Can not absolutize URL: "" + urlOfSource);
            }

            xmlSource.setSystemId(urlOfSource);
          }
        }

        SAX2DTM dtm;
        if(source==null && unique && !incremental && !doIndexing)
        {
          
          
          
          
          
          
          
          dtm = new SAX2RTFDTM(this, source, documentID, whiteSpaceFilter,
                               xstringFactory, doIndexing);
        }
        
        else 
        {
          dtm = new SAX2DTM(this, source, documentID, whiteSpaceFilter,
                            xstringFactory, doIndexing);
        }

        
        
        
        addDTM(dtm, dtmPos, 0);


        boolean haveXercesParser =
          (null != reader)
          && (reader.getClass().getName().equals(""org.apache.xerces.parsers.SAXParser"") );
        
        if (haveXercesParser)
          incremental = true;  
        
        
        
        if (this.m_incremental && incremental )
        {
          IncrementalSAXSource coParser=null;

          if (haveXercesParser)
          {
            
            try {
              coParser=org.apache.xml.dtm.ref.IncrementalSAXSource_Xerces.createIncrementalSAXSource();
            }  catch( Exception ex ) {
              ex.printStackTrace();
              coParser=null;
            }
          }

          if( coParser==null ) {
            
            if (null == reader)
              coParser = new IncrementalSAXSource_Filter();
            else
            {
              IncrementalSAXSource_Filter filter=new IncrementalSAXSource_Filter();
              filter.setXMLReader(reader);
              coParser=filter;
            }

          }

			
        
          
          
          dtm.setIncrementalSAXSource(coParser);

          if (null == xmlSource)
          {

            
            return dtm;
          }

          if(null == reader.getErrorHandler())
            reader.setErrorHandler(dtm);
          reader.setDTDHandler(dtm);

          try
          {

            
            
            coParser.startParse(xmlSource);
          }
          catch (RuntimeException re)
          {

            dtm.clearCoRoutine();

            throw re;
          }
          catch (Exception e)
          {

            dtm.clearCoRoutine();

            throw new org.apache.xml.utils.WrappedRuntimeException(e);
          }
        }
        else
        {
          if (null == reader)
          {

            
            return dtm;
          }

          
          reader.setContentHandler(dtm);
          reader.setDTDHandler(dtm);
          if(null == reader.getErrorHandler())
            reader.setErrorHandler(dtm);

          try
          {
            reader.setProperty(
                               ""http:
          }
          catch (SAXNotRecognizedException e){}
          catch (SAXNotSupportedException e){}

          try
          {
            reader.parse(xmlSource);
          }
          catch (RuntimeException re)
          {

            dtm.clearCoRoutine();

            throw re;
          }
          catch (Exception e)
          {

            dtm.clearCoRoutine();

            throw new org.apache.xml.utils.WrappedRuntimeException(e);
          }
        }

        if (DUMPTREE)
        {
          System.out.println(""Dumping SAX2DOM"");
          dtm.dumpDTM(System.err);
        }

        return dtm;
      }
      else
      {

        
        
        throw new DTMException(XSLMessages.createMessage(XSLTErrorResources.ER_NOT_SUPPORTED, new Object[]{source})); 
      }
    }
  }

  
  synchronized public int getDTMHandleFromNode(org.w3c.dom.Node node)
  {
    if(null == node)
      throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NODE_NON_NULL, null)); 

    if (node instanceof org.apache.xml.dtm.ref.DTMNodeProxy)
      return ((org.apache.xml.dtm.ref.DTMNodeProxy) node).getDTMNodeNumber();
		
    else
    {
      
      
      
      
      
      
      
      
      
      
      
      
      
      
			
			
			
			
			
			
			
			int max = m_dtms.length;
      for(int i = 0; i < max; i++)
        {
          DTM thisDTM=m_dtms[i];
          if((null != thisDTM) && thisDTM instanceof DOM2DTM)
          {
            int handle=((DOM2DTM)thisDTM).getHandleOfNode(node);
            if(handle!=DTM.NULL) return handle;
          }
         }

			
			
			
			
			
			
			
			
			
			
			
			
			
			
			

			
      
      
      Node root = node;
      Node p = (root.getNodeType() == Node.ATTRIBUTE_NODE) ? ((org.w3c.dom.Attr)root).getOwnerElement() : root.getParentNode();
      for (; p != null; p = p.getParentNode())
      {
        root = p;
      }

      DOM2DTM dtm = (DOM2DTM) getDTM(new javax.xml.transform.dom.DOMSource(root),
																		 false, null, true, true);

      int handle;
      
      if(node instanceof org.apache.xml.dtm.ref.dom2dtm.DOM2DTMdefaultNamespaceDeclarationNode)
      {
				
				
				
				handle=dtm.getHandleOfNode(((org.w3c.dom.Attr)node).getOwnerElement());
				handle=dtm.getAttributeNode(handle,node.getNamespaceURI(),node.getLocalName());
      }
      else
				handle = ((DOM2DTM)dtm).getHandleOfNode(node);

      if(DTM.NULL == handle)
        throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_RESOLVE_NODE, null)); 

      return handle;
    }
  }

  
  synchronized public XMLReader getXMLReader(Source inputSource)
  {

    try
    {
      XMLReader reader = (inputSource instanceof SAXSource)
                         ? ((SAXSource) inputSource).getXMLReader() : null;

      boolean isUserReader = (reader != null);

      if (null == reader)
      {
        try
        {
          javax.xml.parsers.SAXParserFactory factory =
            javax.xml.parsers.SAXParserFactory.newInstance();

          factory.setNamespaceAware(true);

          javax.xml.parsers.SAXParser jaxpParser = factory.newSAXParser();

          reader = jaxpParser.getXMLReader();
        }
        catch (javax.xml.parsers.ParserConfigurationException ex)
        {
          throw new org.xml.sax.SAXException(ex);
        }
        catch (javax.xml.parsers.FactoryConfigurationError ex1)
        {
          throw new org.xml.sax.SAXException(ex1.toString());
        }
        catch (NoSuchMethodError ex2){}
        catch (AbstractMethodError ame){}

        if (null == reader)
          reader = XMLReaderFactory.createXMLReader();
      }

      try
      {
        reader.setFeature(""http:
                          true);
      }
      catch (org.xml.sax.SAXException se)
      {

        
        
      }

        
        















      return reader;
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new DTMException(se.getMessage(), se);
    }
  }

  
  synchronized public DTM getDTM(int nodeHandle)
  {
    try
    {
      
      return m_dtms[nodeHandle >>> IDENT_DTM_NODE_BITS];
    }
    catch(java.lang.ArrayIndexOutOfBoundsException e)
    {
      if(nodeHandle==DTM.NULL)
				return null;		
      else
				throw e;		
    }    
  }

  
  synchronized public int getDTMIdentity(DTM dtm)
  {
	
	
	if(dtm instanceof DTMDefaultBase)
	{
		DTMDefaultBase dtmdb=(DTMDefaultBase)dtm;
		if(dtmdb.getManager()==this)
			return dtmdb.getDTMIDs().elementAt(0);
		else
			return -1;
	}
				
    int n = m_dtms.length;

    for (int i = 0; i < n; i++)
    {
      DTM tdtm = m_dtms[i];

      if (tdtm == dtm && m_dtm_offsets[i]==0)
        return i << IDENT_DTM_NODE_BITS;
    }

    return -1;
  }

  
  synchronized public boolean release(DTM dtm, boolean shouldHardDelete)
  {
    if(DEBUG)
    {
      System.out.println(""Releasing ""+
			 (shouldHardDelete ? ""HARD"" : ""soft"")+
			 "" dtm=""+
			 
			 
			 dtm.getDocumentBaseURI()
			 );
    }

    if (dtm instanceof SAX2DTM)
    {
      ((SAX2DTM) dtm).clearCoRoutine();
    }

		
		
		
		
		
		
		
		
		if(dtm instanceof DTMDefaultBase)
		{
			org.apache.xml.utils.SuballocatedIntVector ids=((DTMDefaultBase)dtm).getDTMIDs();
			for(int i=ids.size()-1;i>=0;--i)
				m_dtms[ids.elementAt(i)>>>DTMManager.IDENT_DTM_NODE_BITS]=null;
		}
		else
		{
			int i = getDTMIdentity(dtm);
		    if (i >= 0)
			{
				m_dtms[i >>> DTMManager.IDENT_DTM_NODE_BITS] = null;
			}
		}

    dtm.documentRelease();
    return true;
  }

  
  synchronized public DTM createDocumentFragment()
  {

    try
    {
      DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();

      dbf.setNamespaceAware(true);

      DocumentBuilder db = dbf.newDocumentBuilder();
      Document doc = db.newDocument();
      Node df = doc.createDocumentFragment();

      return getDTM(new DOMSource(df), true, null, false, false);
    }
    catch (Exception e)
    {
      throw new DTMException(e);
    }
  }

  
  synchronized public DTMIterator createDTMIterator(int whatToShow, DTMFilter filter,
                                       boolean entityReferenceExpansion)
  {

    
    return null;
  }

  
  synchronized public DTMIterator createDTMIterator(String xpathString,
                                       PrefixResolver presolver)
  {

    
    return null;
  }

  
  synchronized public DTMIterator createDTMIterator(int node)
  {

    
    return null;
  }

  
  synchronized public DTMIterator createDTMIterator(Object xpathCompiler, int pos)
  {

    
    return null;
  }

  
  public ExpandedNameTable getExpandedNameTable(DTM dtm)
  {
    return m_expandedNameTable;
  }
}
"
org.apache.xpath.objects.XStringForFSB,31,4,0,10,57,117,1,10,29,0.5,904,0.5,0,0.802721088,0.150537634,4,20,28.03225806,15,3.0,1,"
package org.apache.xpath.objects;

import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xml.utils.XMLCharacterRecognizer;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;

import java.util.Locale;


public class XStringForFSB extends XString
{

  
  int m_start;

  
  int m_length;

  
  protected String m_strCache = null;

  
  protected int m_hash = 0;

  
  public XStringForFSB(FastStringBuffer val, int start, int length)
  {

    super(val);

    m_start = start;
    m_length = length;

    if (null == val)
      throw new IllegalArgumentException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_FASTSTRINGBUFFER_CANNOT_BE_NULL, null));
  }

  
  private XStringForFSB(String val)
  {

    super(val);

    throw new IllegalArgumentException(
      XSLMessages.createXPATHMessage(XPATHErrorResources.ER_FSB_CANNOT_TAKE_STRING, null)); 
  }

  
  public FastStringBuffer fsb()
  {
    return ((FastStringBuffer) m_obj);
  }
  
  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    
    fsb.append(str());
  }

  
  public boolean hasString()
  {
    return (null != m_strCache);
  }







  
  public Object object()
  {
    return str();
  }

  
  public String str()
  {

    if (null == m_strCache)
    {
      m_strCache = fsb().getString(m_start, m_length);






















      
    }

    return m_strCache;
  }

  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {
    fsb().sendSAXcharacters(ch, m_start, m_length);
  }

  
  public void dispatchAsComment(org.xml.sax.ext.LexicalHandler lh)
          throws org.xml.sax.SAXException
  {
    fsb().sendSAXComment(lh, m_start, m_length);
  }

  
  public int length()
  {
    return m_length;
  }

  
  public char charAt(int index)
  {
    return fsb().charAt(m_start + index);
  }

  
  public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)
  {

    
    
    int n = srcEnd - srcBegin;

    if (n > m_length)
      n = m_length;

    if (n > (dst.length - dstBegin))
      n = (dst.length - dstBegin);

    int end = srcBegin + m_start + n;
    int d = dstBegin;
    FastStringBuffer fsb = fsb();

    for (int i = srcBegin + m_start; i < end; i++)
    {
      dst[d++] = fsb.charAt(i);
    }
  }

  
  public boolean equals(XMLString obj2)
  {

    if (this == obj2)
    {
      return true;
    }

    int n = m_length;

    if (n == obj2.length())
    {
      FastStringBuffer fsb = fsb();
      int i = m_start;
      int j = 0;

      while (n-- != 0)
      {
        if (fsb.charAt(i) != obj2.charAt(j))
        {
          return false;
        }

        i++;
        j++;
      }

      return true;
    }

    return false;
  }

  
  public boolean equals(XObject obj2)
  {

    if (this == obj2)
    {
      return true;
    }
    if(obj2.getType() == XObject.CLASS_NUMBER)
    	return obj2.equals(this);

    String str = obj2.str();
    int n = m_length;

    if (n == str.length())
    {
      FastStringBuffer fsb = fsb();
      int i = m_start;
      int j = 0;

      while (n-- != 0)
      {
        if (fsb.charAt(i) != str.charAt(j))
        {
          return false;
        }

        i++;
        j++;
      }

      return true;
    }

    return false;
  }

  
  public boolean equals(String anotherString)
  {

    int n = m_length;

    if (n == anotherString.length())
    {
      FastStringBuffer fsb = fsb();
      int i = m_start;
      int j = 0;

      while (n-- != 0)
      {
        if (fsb.charAt(i) != anotherString.charAt(j))
        {
          return false;
        }

        i++;
        j++;
      }

      return true;
    }

    return false;
  }

  
  public boolean equals(Object obj2)
  {

    if (null == obj2)
      return false;
      
    if(obj2 instanceof XNumber)
    	return obj2.equals(this);

      
      
      
    else if (obj2 instanceof XNodeSet)
      return obj2.equals(this);
    else if (obj2 instanceof XStringForFSB)
      return equals((XMLString) this);
    else
      return equals(obj2.toString());
  }

  
  public boolean equalsIgnoreCase(String anotherString)
  {
    return (m_length == anotherString.length())
           ? str().equalsIgnoreCase(anotherString) : false;
  }

  
  public int compareTo(XMLString xstr)
  {

    int len1 = m_length;
    int len2 = xstr.length();
    int n = Math.min(len1, len2);
    FastStringBuffer fsb = fsb();
    int i = m_start;
    int j = 0;

    while (n-- != 0)
    {
      char c1 = fsb.charAt(i);
      char c2 = xstr.charAt(j);

      if (c1 != c2)
      {
        return c1 - c2;
      }

      i++;
      j++;
    }

    return len1 - len2;
  }

  
  public int compareToIgnoreCase(XMLString xstr)
  {

    int len1 = m_length;
    int len2 = xstr.length();
    int n = Math.min(len1, len2);
    FastStringBuffer fsb = fsb();
    int i = m_start;
    int j = 0;

    while (n-- != 0)
    {
      char c1 = Character.toLowerCase(fsb.charAt(i));
      char c2 = Character.toLowerCase(xstr.charAt(j));

      if (c1 != c2)
      {
        return c1 - c2;
      }

      i++;
      j++;
    }

    return len1 - len2;
  }

  
  public int hashCode()
  {
    
    
    
    
    
    


    return super.hashCode(); 
  }

  
  public boolean startsWith(XMLString prefix, int toffset)
  {

    FastStringBuffer fsb = fsb();
    int to = m_start + toffset;
    int tlim = m_start + m_length;
    int po = 0;
    int pc = prefix.length();

    
    if ((toffset < 0) || (toffset > m_length - pc))
    {
      return false;
    }

    while (--pc >= 0)
    {
      if (fsb.charAt(to) != prefix.charAt(po))
      {
        return false;
      }

      to++;
      po++;
    }

    return true;
  }

  
  public boolean startsWith(XMLString prefix)
  {
    return startsWith(prefix, 0);
  }

  
  public int indexOf(int ch)
  {
    return indexOf(ch, 0);
  }

  
  public int indexOf(int ch, int fromIndex)
  {

    int max = m_start + m_length;
    FastStringBuffer fsb = fsb();

    if (fromIndex < 0)
    {
      fromIndex = 0;
    }
    else if (fromIndex >= m_length)
    {

      
      return -1;
    }

    for (int i = m_start + fromIndex; i < max; i++)
    {
      if (fsb.charAt(i) == ch)
      {
        return i - m_start;
      }
    }

    return -1;
  }

  
  public XMLString substring(int beginIndex)
  {

    int len = m_length - beginIndex;

    if (len <= 0)
      return XString.EMPTYSTRING;
    else
    {
      int start = m_start + beginIndex;

      return new XStringForFSB(fsb(), start, len);
    }
  }

  
  public XMLString substring(int beginIndex, int endIndex)
  {

    int len = endIndex - beginIndex;

    if (len > m_length)
      len = m_length;

    if (len <= 0)
      return XString.EMPTYSTRING;
    else
    {
      int start = m_start + beginIndex;

      return new XStringForFSB(fsb(), start, len);
    }
  }

  
  public XMLString concat(String str)
  {

    
    return new XString(str().concat(str));
  }

  
  public XMLString trim()
  {
    return fixWhiteSpace(true, true, false);
  }

  
  private static boolean isSpace(char ch)
  {
    return XMLCharacterRecognizer.isWhiteSpace(ch);  
  }

  
  public XMLString fixWhiteSpace(boolean trimHead, boolean trimTail,
                                 boolean doublePunctuationSpaces)
  {

    int end = m_length + m_start;
    char[] buf = new char[m_length];
    FastStringBuffer fsb = fsb();
    boolean edit = false;

    
    int d = 0;
    boolean pres = false;

    for (int s = m_start; s < end; s++)
    {
      char c = fsb.charAt(s);

      if (isSpace(c))
      {
        if (!pres)
        {
          if (' ' != c)
          {
            edit = true;
          }

          buf[d++] = ' ';

          if (doublePunctuationSpaces && (d != 0))
          {
            char prevChar = buf[d - 1];

            if (!((prevChar == '.') || (prevChar == '!')
                  || (prevChar == '?')))
            {
              pres = true;
            }
          }
          else
          {
            pres = true;
          }
        }
        else
        {
          edit = true;
          pres = true;
        }
      }
      else
      {
        buf[d++] = c;
        pres = false;
      }
    }

    if (trimTail && 1 <= d && ' ' == buf[d - 1])
    {
      edit = true;

      d--;
    }

    int start = 0;

    if (trimHead && 0 < d && ' ' == buf[0])
    {
      edit = true;

      start++;
    }

    XMLStringFactory xsf = XMLStringFactoryImpl.getFactory();

    return edit ? xsf.newstr(buf, start, d - start) : this;
  }

  
  public double toDouble()
  {
    int end = m_length+m_start;
    if(0 == end)
      return Double.NaN;

    int start = m_start;
    FastStringBuffer fsb = fsb();
      
    long longResult=0;
    boolean isNegative=false;
    boolean trailingSpace=false;
    int[] digitsFound={0,0}; 
    int digitType=0;    
    double doubleResult;
    
    
    while(start< end &&
          XMLCharacterRecognizer.isWhiteSpace( fsb.charAt(start) )
          )
      ++start;
    
    if (start < end && fsb.charAt(start) == '-')
    {
      isNegative=true;
      start++;
    }
    
    
    for (int i = start; i < end; i++)
    {
      char c = fsb.charAt(i);

      if(XMLCharacterRecognizer.isWhiteSpace(c))
      {
				trailingSpace=true;
        break;                  
      }
      else if(trailingSpace)
	return Double.NaN;	
	
      switch(c)
      {
      case '.':
        if(digitType==0)
          digitType=1;
        else
          return Double.NaN;    
	break;
	
      case '0':			
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        longResult = longResult * 10 + (c - '0'); 
        ++digitsFound[digitType]; 
	break;

      default:
        return Double.NaN;      
      }
    }

    if(0 ==digitsFound[0]&& 0==digitsFound[1])
      return Double.NaN;

    
    
    
    
    
                
    long scale=1;               
    for(int i=digitsFound[1];i>0;--i) 
      scale*=10;
                
    doubleResult=((double)longResult)/scale;
                
    if(isNegative)
      doubleResult *= -1;
    return doubleResult;
  }

}
"
org.apache.xpath.functions.Function,9,2,7,21,15,36,15,8,8,2.0,51,0.0,0,0.789473684,0.285714286,1,7,4.666666667,2,1.1111,0,"
package org.apache.xpath.functions;



import javax.xml.transform.TransformerException;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.objects.XObject;


public abstract class Function extends Expression
{

  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {
			
      reportWrongNumberArgs();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum != 0)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""zero"", null));
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    
    System.out.println(""Error! Function.execute should not be called!"");

    return null;
  }
  
  
  public void callArgVisitors(XPathVisitor visitor)
  {
  }

  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	if(visitor.visitFunction(owner, this))
  	{
  		callArgVisitors(visitor);
  	}
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	return true;
  }

  
  public void postCompileStep(Compiler compiler)
  {
    
  }
}
"
org.apache.xalan.xsltc.TransletOutputHandler,22,1,0,22,22,231,20,2,22,2.0,22,0.0,0,0.0,0.303030303,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

import java.io.*;
import org.apache.xalan.xsltc.runtime.Hashtable;

public interface TransletOutputHandler {

    public void startDocument() throws TransletException;
    public void endDocument() throws TransletException;
    public void startElement(String elementName) throws TransletException;
    public void endElement(String elementName) throws TransletException;
    public void characters(String characters) throws TransletException;
    public void characters(char[] characters, int offset, int length)
	throws TransletException;
    public void attribute(String attributeName, String attributeValue)
	throws TransletException;
    public void namespace(String prefix, String uri) throws TransletException;
    public void comment(String comment) throws TransletException;
    public void processingInstruction(String target, String data)
	throws TransletException;
    public void startCDATA() throws TransletException;
    public void endCDATA() throws TransletException;
    public void setType(int type);
    public void setIndent(boolean indent);
    public void omitHeader(boolean value);
    public boolean setEscaping(boolean escape) throws TransletException;
    public void setCdataElements(Hashtable elements);
    public void setDoctype(String system, String pub);
    public void setMediaType(String mediaType);
    public void setStandalone(String standalone);
    public void setVersion(String version);
    public void close();

}
"
org.apache.xalan.transformer.CountersTable,5,3,0,7,23,8,3,5,2,0.875,198,0.5,1,0.904761905,0.44,0,0,38.2,2,1.2,0,"
package org.apache.xalan.transformer;

import java.util.Hashtable;
import java.util.Vector;


import org.apache.xml.dtm.DTM;

import javax.xml.transform.TransformerException;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.NodeSetDTM;
import org.apache.xalan.templates.ElemNumber;


public class CountersTable extends Hashtable
{

  
  public CountersTable(){}

  
  Vector getCounters(ElemNumber numberElem)
  {

    Vector counters = (Vector) this.get(numberElem);

    return (null == counters) ? putElemNumber(numberElem) : counters;
  }

  
  Vector putElemNumber(ElemNumber numberElem)
  {

    Vector counters = new Vector();

    this.put(numberElem, counters);

    return counters;
  }

  
  transient private NodeSetDTM m_newFound;

  
  void appendBtoFList(NodeSetDTM flist, NodeSetDTM blist)
  {

    int n = blist.size();

    for (int i = (n - 1); i >= 0; i--)
    {
      flist.addElement(blist.item(i));
    }
  }

  

  
  transient int m_countersMade = 0;

  
  public int countNode(XPathContext support, ElemNumber numberElem, int node)
          throws TransformerException
  {

    int count = 0;
    Vector counters = getCounters(numberElem);
    int nCounters = counters.size();

    
    
    int target = numberElem.getTargetNode(support, node);

    if (DTM.NULL != target)
    {
      for (int i = 0; i < nCounters; i++)
      {
        Counter counter = (Counter) counters.elementAt(i);

        count = counter.getPreviouslyCounted(support, target);

        if (count > 0)
          return count;
      }

      
      
      
      
      
      
      count = 0;
      if (m_newFound == null)
        m_newFound = new NodeSetDTM(support.getDTMManager());

      for (; DTM.NULL != target;
              target = numberElem.getPreviousNode(support, target))
      {

        
        
        
        if (0 != count)
        {
          for (int i = 0; i < nCounters; i++)
          {
            Counter counter = (Counter) counters.elementAt(i);
            int cacheLen = counter.m_countNodes.size();

            if ((cacheLen > 0)
                    && (counter.m_countNodes.elementAt(cacheLen
                                                      - 1) == target))
            {
              count += (cacheLen + counter.m_countNodesStartCount);

              if (cacheLen > 0)
                appendBtoFList(counter.m_countNodes, m_newFound);

              m_newFound.removeAllElements();

              return count;
            }
          }
        }

        m_newFound.addElement(target);

        count++;
      }

      
      
      Counter counter = new Counter(numberElem, new NodeSetDTM(support.getDTMManager()));

      m_countersMade++;  

      appendBtoFList(counter.m_countNodes, m_newFound);
      m_newFound.removeAllElements();
      counters.addElement(counter);
    }

    return count;
  }
}
"
org.apache.xalan.xsltc.compiler.CallTemplate,6,3,0,20,40,3,0,20,5,0.4,183,1.0,1,0.918032787,0.305555556,1,6,29.33333333,5,1.6667,0,"

package org.apache.xalan.xsltc.compiler;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class CallTemplate extends Instruction {
    private QName _name;

    public void display(int indent) {
	indent(indent);
	System.out.print(""CallTemplate"");
	Util.println("" name "" + _name);
	displayContents(indent + IndentIncrement);
    }
		
    public boolean hasWithParams() {
	return elementCount() > 0;
    }

    public void parseContents(Parser parser) {
	_name = parser.getQNameIgnoreDefaultNs(getAttribute(""name""));
	parseChildren(parser);
    }
		
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Template template = stable.lookupTemplate(_name);
	if (template != null) {
	    typeCheckContents(stable);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.TEMPLATE_UNDEF_ERR,_name,this);
	    throw new TypeCheckError(err);
	}
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Stylesheet stylesheet = classGen.getStylesheet();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();


	if (stylesheet.hasLocalParams() || hasContents()) {
	    
	    final int push = cpg.addMethodref(TRANSLET_CLASS, 
					      PUSH_PARAM_FRAME,
					      PUSH_PARAM_FRAME_SIG);
	    il.append(classGen.loadTranslet());
	    il.append(new INVOKEVIRTUAL(push));
	    
	    translateContents(classGen, methodGen);
	}

	final String className = stylesheet.getClassName();
	
	String methodName = Util.escape(_name.toString());

	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadIterator());
	il.append(methodGen.loadHandler());
	il.append(methodGen.loadCurrentNode());
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(className,
						     methodName,
						     ""(""
						     + DOM_INTF_SIG
						     + NODE_ITERATOR_SIG
						     + TRANSLET_OUTPUT_SIG
						     + NODE_SIG
						     +"")V"")));
	

	if (stylesheet.hasLocalParams() || hasContents()) {
	    
	    final int pop = cpg.addMethodref(TRANSLET_CLASS,
					     POP_PARAM_FRAME,
					     POP_PARAM_FRAME_SIG);
	    il.append(classGen.loadTranslet());
	    il.append(new INVOKEVIRTUAL(pop));
	}
    }
} 
"
org.apache.xalan.xsltc.NodeIterator,10,1,0,53,10,45,53,0,10,1.111111111,11,0.0,0,0.0,0.4,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc;

public interface NodeIterator extends Cloneable {
    public static final int END = DOM.NULL;

    
    public int next();

    
    public NodeIterator reset();

    
    public int getLast();

    
    public int getPosition();

    
    public void setMark();

    
    public void gotoMark();

    
    public NodeIterator setStartNode(int node);

    
    public boolean isReverse();

    
    public NodeIterator cloneIterator();

    
    public void setRestartable(boolean isRestartable);

}
"
org.apache.xalan.xsltc.compiler.NameBase,5,4,3,19,21,0,3,16,5,0.25,149,1.0,2,0.96969697,0.366666667,3,14,28.4,4,1.2,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

class NameBase extends FunctionCall {

    private Expression _param = null;
    private Type       _paramType = Type.Node;

    
    public NameBase(QName fname) {
	super(fname);
    }

    
    public NameBase(QName fname, Vector arguments) {
	super(fname, arguments);
	_param = argument(0);
    }


    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	switch(argumentCount()) {
	case 0:
	    _paramType = Type.Node;
	    break;
	case 1:
	    _paramType = _param.typeCheck(stable);
	    break;
	default:
	    throw new TypeCheckError(this);
	}

	
	if ((_paramType != Type.NodeSet) &&
	    (_paramType != Type.Node) &&
	    (_paramType != Type.Reference)) {
	    throw new TypeCheckError(this);
	}

	return (_type = Type.String);
    }

    public Type getType() {
	return _type;
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	il.append(methodGen.loadDOM());
	
	
	if (argumentCount() == 0) {
	    il.append(methodGen.loadContextNode());
	}
	
	else if (_paramType == Type.Node) {
	    _param.translate(classGen, methodGen);
	}
	else if (_paramType == Type.Reference) {
	    _param.translate(classGen, methodGen);
	    il.append(new INVOKESTATIC(cpg.addMethodref
				       (BASIS_LIBRARY_CLASS,
					""referenceToNodeSet"",
					""(Ljava/lang/Object;)"" +
					""Lorg/apache/xalan/xsltc/"" +
					""NodeIterator;"")));
	    il.append(methodGen.nextNode());
	}
	
	else {
	    _param.translate(classGen, methodGen);
	    _param.startResetIterator(classGen, methodGen);
	    il.append(methodGen.nextNode());
	}
    }
}
"
org.apache.xalan.xsltc.compiler.util.BooleanType,20,2,0,52,51,190,17,39,19,2.0,288,0.0,0,0.634615385,0.245,1,2,13.4,4,1.4,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.Constants;

public final class BooleanType extends Type {
    protected BooleanType() {}

    public String toString() {
	return ""boolean"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""Z"";
    }

    public boolean isSimple() {
	return true;
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.BOOLEAN;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final BranchHandle falsec = il.append(new IFEQ(null));
	il.append(new PUSH(cpg, ""true""));
	final BranchHandle truec = il.append(new GOTO(null));
	falsec.setTarget(il.append(new PUSH(cpg, ""false"")));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	methodGen.getInstructionList().append(I2D);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new NEW(cpg.addClass(BOOLEAN_CLASS)));
	il.append(DUP_X1);
	il.append(SWAP);
	il.append(new INVOKESPECIAL(cpg.addMethodref(BOOLEAN_CLASS,
						     ""<init>"",
						     ""(Z)V"")));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	if (clazz == java.lang.Boolean.TYPE) {
	    methodGen.getInstructionList().append(NOP);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen, 
			      Class clazz) {
	translateTo(classGen, methodGen, clazz);
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new CHECKCAST(cpg.addClass(BOOLEAN_CLASS)));
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(BOOLEAN_CLASS,
						     BOOLEAN_VALUE, 
						     BOOLEAN_VALUE_SIG)));
    }

    public Instruction LOAD(int slot) {
	return new ILOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ISTORE(slot);
    }

    public BranchInstruction GT(boolean tozero) {
	return tozero ? (BranchInstruction) new IFGT(null) : 
	    (BranchInstruction) new IF_ICMPGT(null);
    }

    public BranchInstruction GE(boolean tozero) {
	return tozero ? (BranchInstruction) new IFGE(null) : 
	    (BranchInstruction) new IF_ICMPGE(null);
    }

    public BranchInstruction LT(boolean tozero) {
	return tozero ? (BranchInstruction) new IFLT(null) : 
	    (BranchInstruction) new IF_ICMPLT(null);
    }

    public BranchInstruction LE(boolean tozero) {
	return tozero ? (BranchInstruction) new IFLE(null) : 
	    (BranchInstruction) new IF_ICMPLE(null);
    }
}
"
org.apache.xml.utils.synthetic.reflection.Method,6,2,0,5,16,15,3,4,6,2.0,58,0.0,0,0.863636364,0.388888889,2,3,8.666666667,1,0.5,0,"
package org.apache.xml.utils.synthetic.reflection;

import java.lang.reflect.InvocationTargetException;

import org.apache.xml.utils.synthetic.SynthesisException;


public class Method extends EntryPoint implements Member
{

  
  public Method(String name,
                org.apache.xml.utils.synthetic.Class declaringclass)
  {

    super(declaringclass);

    this.name = name;
  }

  
  public Method(java.lang.reflect.Method ctor,
                org.apache.xml.utils.synthetic.Class declaringclass)
  {
    super(ctor, declaringclass);
  }

  
  public Method(java.lang.reflect.Method realmethod)
  {
    super(realmethod);
  }

  

  
  public int hashCode()
  {
    return getDeclaringClass().getName().hashCode() ^ getName().hashCode();
  }

  
  public Object invoke(Object obj, Object args[])
          throws IllegalAccessException, IllegalArgumentException,
                 java.lang.reflect.InvocationTargetException
  {

    if (realep != null)
      return ((java.lang.reflect.Method) realep).invoke(obj, args);
    else
      throw new IllegalAccessException(
        ""Un-reified org.apache.xml.utils.synthetic.Class doesn't yet support invocation"");
  }

  
  public void setReturnType(org.apache.xml.utils.synthetic.Class returntype)
          throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.returntype = returntype;
  }
}
"
org.apache.xalan.templates.RedundentExprEliminator,38,3,0,29,122,607,1,29,6,0.9,1852,0.0,2,0.357142857,0.194594595,0,0,47.47368421,15,3.7632,0,"
package org.apache.xalan.templates;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionNode;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPath;
import org.apache.xpath.axes.AxesWalker;
import org.apache.xpath.axes.FilterExprIteratorSimple;
import org.apache.xpath.axes.FilterExprWalker;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.axes.SelfIteratorNoPredicate;
import org.apache.xpath.axes.WalkerFactory;
import org.apache.xpath.axes.WalkingIterator;
import org.apache.xpath.operations.Variable;
import org.apache.xpath.operations.VariableSafeAbsRef;
import org.w3c.dom.DOMException;


public class RedundentExprEliminator extends XSLTVisitor
{
  Vector m_paths;
  Vector m_absPaths;
  boolean m_isSameContext;
  AbsPathChecker m_absPathChecker = new AbsPathChecker();
  
  static int m_uniquePsuedoVarID = 1;
  static final String PSUEDOVARNAMESPACE = Constants.S_VENDORURL+""/xalan/psuedovar"";
 
  public static boolean DEBUG = false;
  public static boolean DIAGNOSE_NUM_PATHS_REDUCED = false;
  public static boolean DIAGNOSE_MULTISTEPLIST = false;

  
  VarNameCollector m_varNameCollector = new VarNameCollector();

  
  public RedundentExprEliminator()
  {
    m_isSameContext = true;
    m_absPaths = new Vector();
    m_paths = null;
  }
  
  
  
  public void eleminateRedundentLocals(ElemTemplateElement psuedoVarRecipient)
  {
    eleminateRedundent(psuedoVarRecipient, m_paths);
  }
  
  
  public void eleminateRedundentGlobals(StylesheetRoot stylesheet)
  {
    eleminateRedundent(stylesheet, m_absPaths);
  }

  
  
  protected void eleminateRedundent(ElemTemplateElement psuedoVarRecipient, Vector paths)
  {
    int n = paths.size();
    int numPathsEliminated = 0;
    int numUniquePathsEliminated = 0;
    for (int i = 0; i < n; i++)
    {
      ExpressionOwner owner = (ExpressionOwner) paths.elementAt(i);
      if (null != owner)
      {
        int found = findAndEliminateRedundant(i + 1, i, owner, psuedoVarRecipient, paths);
        if (found > 0)
                  numUniquePathsEliminated++;
        numPathsEliminated += found;
      }
    }
    
    eleminateSharedPartialPaths(psuedoVarRecipient, paths);
    
    if(DIAGNOSE_NUM_PATHS_REDUCED)
		diagnoseNumPaths(paths, numPathsEliminated, numUniquePathsEliminated);
  }
  
  
  protected void eleminateSharedPartialPaths(ElemTemplateElement psuedoVarRecipient, Vector paths)
  {
  	MultistepExprHolder list = createMultistepExprList(paths);
  	if(null != list)
  	{
  		if(DIAGNOSE_MULTISTEPLIST)
        	list.diagnose();
        	
        boolean isGlobal = (paths == m_absPaths);
        	
        
        
        int longestStepsCount = list.m_stepCount;
    	for (int i = longestStepsCount-1; i >= 1; i--)
    	{
    		MultistepExprHolder next = list;
        	while(null != next)
        	{
        		if(next.m_stepCount < i)
        			break;
				list = matchAndEliminatePartialPaths(next, list, isGlobal, i, psuedoVarRecipient);
				next = next.m_next;
        	}
    	}
  	}
  }

  
  protected MultistepExprHolder matchAndEliminatePartialPaths(MultistepExprHolder testee, 
                                               MultistepExprHolder head,
                                               boolean isGlobal,
                                               int lengthToTest,
                                               ElemTemplateElement varScope)
  {  	
  	if(null == testee.m_exprOwner)
  		return head;
  		
    
    WalkingIterator iter1 = (WalkingIterator) testee.m_exprOwner.getExpression();
    if(partialIsVariable(testee, lengthToTest))
    	return head;
    MultistepExprHolder matchedPaths = null;
    MultistepExprHolder matchedPathsTail = null;
    MultistepExprHolder meh = head;
    while( null != meh)
    {
      if ((meh != testee) && (null != meh.m_exprOwner))
      {
	      WalkingIterator iter2 = (WalkingIterator) meh.m_exprOwner.getExpression();
	      if (stepsEqual(iter1, iter2, lengthToTest))
	      {
	        if (null == matchedPaths)
	        {
	          try
	          {
	          	matchedPaths = (MultistepExprHolder)testee.clone();
	          	testee.m_exprOwner = null; 
	          }
	          catch(CloneNotSupportedException cnse){}
	          matchedPathsTail = matchedPaths;
	          matchedPathsTail.m_next = null;
	        }
	       
	        try
	        {
	          matchedPathsTail.m_next = (MultistepExprHolder)meh.clone();
	          meh.m_exprOwner = null; 
	        }
	        catch(CloneNotSupportedException cnse){}
	        matchedPathsTail = matchedPathsTail.m_next;
	        matchedPathsTail.m_next = null;
	      }
      }
      meh = meh.m_next;
    }
    	
	int matchCount = 0;
	if(null != matchedPaths)
	{
		ElemTemplateElement root = isGlobal ? varScope : findCommonAncestor(matchedPaths);
		WalkingIterator sharedIter = (WalkingIterator)matchedPaths.m_exprOwner.getExpression();
		WalkingIterator newIter = createIteratorFromSteps(sharedIter, lengthToTest);
		ElemVariable var = createPsuedoVarDecl(root, newIter, isGlobal);
		if(DIAGNOSE_MULTISTEPLIST)
			System.err.println(""Created var: ""+var.getName()+(isGlobal ? ""(Global)"" : """"));
		while(null != matchedPaths)
		{
			ExpressionOwner owner = matchedPaths.m_exprOwner;
			WalkingIterator iter = (WalkingIterator)owner.getExpression();
			
			if(DIAGNOSE_MULTISTEPLIST)
				diagnoseLineNumber(iter);
			
			LocPathIterator newIter2 = 
			    changePartToRef(var.getName(), iter, lengthToTest, isGlobal);
			owner.setExpression(newIter2);
			
			matchedPaths = matchedPaths.m_next;
		}
	}
	
	if(DIAGNOSE_MULTISTEPLIST)
		diagnoseMultistepList(matchCount, lengthToTest, isGlobal);
    return head;
  }
  
  
  boolean partialIsVariable(MultistepExprHolder testee, int lengthToTest)
  {
  	if(1 == lengthToTest)
  	{
  		WalkingIterator wi = (WalkingIterator)testee.m_exprOwner.getExpression();
  		if(wi.getFirstWalker() instanceof FilterExprWalker)
  			return true;
  	}
  	return false;
  }

  
  protected void diagnoseLineNumber(Expression expr)
  {
    ElemTemplateElement e = getElemFromExpression(expr);
    System.err.println(""   "" + e.getSystemId() + "" Line "" + e.getLineNumber());
  }
      
  
  protected ElemTemplateElement findCommonAncestor(MultistepExprHolder head)
  {
  	
  	int numExprs = head.getLength();
  	
  	
  	
    ElemTemplateElement[] elems = new ElemTemplateElement[numExprs];
    int[] ancestorCounts = new int[numExprs];
    
    
    
  	MultistepExprHolder next = head;
  	int shortestAncestorCount = 10000;
  	for(int i = 0; i < numExprs; i++)
  	{
  		ElemTemplateElement elem = 
  			getElemFromExpression(next.m_exprOwner.getExpression());
  		elems[i] = elem;
  		int numAncestors = countAncestors(elem);
  		ancestorCounts[i] = numAncestors;
  		if(numAncestors < shortestAncestorCount)
  		{
  			shortestAncestorCount = numAncestors;
  		}
  		next = next.m_next;
  	}
  	
  	
  	for(int i = 0; i < numExprs; i++)
  	{
  		if(ancestorCounts[i] > shortestAncestorCount)
  		{
  			int numStepCorrection = ancestorCounts[i] - shortestAncestorCount;
  			for(int j = 0; j < numStepCorrection; j++)
  			{
  				elems[i] = elems[i].getParentElem();
  			}
  		}
  	}
  	
  	
  	
  	ElemTemplateElement first = null;
  	while(shortestAncestorCount-- >= 0)
  	{
  		boolean areEqual = true;
  		first = elems[0];
  		for(int i = 1; i < numExprs; i++)
  		{
  			if(first != elems[i])
  			{
  				areEqual = false;
  				break;
  			}
  		}
  		
  		
  		if(areEqual && isNotSameAsOwner(head, first) && first.canAcceptVariables())
  		{
  			if(DIAGNOSE_MULTISTEPLIST)
  			{
  				System.err.print(first.getClass().getName());
  				System.err.println("" at   "" + first.getSystemId() + "" Line "" + first.getLineNumber());
  			}
  			return first;
  		}
   			
  		for(int i = 0; i < numExprs; i++)
  		{
  			elems[i] = elems[i].getParentElem();
  		}
  	}
  	
  	assertion(false, ""Could not find common ancestor!!!"");
  	return null;
  }
  
  
  protected boolean isNotSameAsOwner(MultistepExprHolder head, ElemTemplateElement ete)
  {
  	MultistepExprHolder next = head;
  	while(null != next)
  	{
  		ElemTemplateElement elemOwner = getElemFromExpression(next.m_exprOwner.getExpression());
  		if(elemOwner == ete)
  			return false;
  		next = next.m_next;
  	}
  	return true;
  }
  
  
  protected int countAncestors(ElemTemplateElement elem)
  {
  	int count = 0;
  	while(null != elem)
  	{
  		count++;
  		elem = elem.getParentElem();
  	}
  	return count;
  }

  
  protected void diagnoseMultistepList(
      int matchCount,
      int lengthToTest,
      boolean isGlobal)
  {
      if (matchCount > 0)
        {
        System.err.print(
          ""Found multistep matches: "" + matchCount + "", "" + lengthToTest + "" length"");
        if (isGlobal)
              System.err.println("" (global)"");
        else
              System.err.println();
      }
  }
  
  
  protected LocPathIterator changePartToRef(final QName uniquePsuedoVarName, WalkingIterator wi, 
                                 final int numSteps, final boolean isGlobal)
  {
  	Variable var = new Variable();
  	var.setQName(uniquePsuedoVarName);
  	var.setIsGlobal(isGlobal);
  	if(isGlobal)
  	{	ElemTemplateElement elem = getElemFromExpression(wi);
  		StylesheetRoot root = elem.getStylesheetRoot();
  		Vector vars = root.getVariablesAndParamsComposed();
  		var.setIndex(vars.size()-1);
  	}
  	
  	
  	AxesWalker walker = wi.getFirstWalker();
  	for(int i = 0; i < numSteps; i++)
  	{
  		assertion(null != walker, ""Walker should not be null!"");
  		walker = walker.getNextWalker();
  	}
  	
  	if(null != walker)
  	{
  	
  	  FilterExprWalker few = new FilterExprWalker(wi);
  	  few.setInnerExpression(var);
  	  few.exprSetParent(wi);
  	  few.setNextWalker(walker);
  	  walker.setPrevWalker(few);
  	  wi.setFirstWalker(few);
  	  return wi;
  	}
  	else
  	{
  	  FilterExprIteratorSimple feis = new FilterExprIteratorSimple(var);
  	  feis.exprSetParent(wi.exprGetParent());
  	  return feis;
  	}
  }
  
  
  protected WalkingIterator createIteratorFromSteps(final WalkingIterator wi, int numSteps)
  {
  	WalkingIterator newIter = new WalkingIterator(wi.getPrefixResolver());
  	try
  	{
  		AxesWalker walker = (AxesWalker)wi.getFirstWalker().clone();
  		newIter.setFirstWalker(walker);
  		walker.setLocPathIterator(newIter);
  		for(int i = 1; i < numSteps; i++)
  		{
  			AxesWalker next = (AxesWalker)walker.getNextWalker().clone();
  			walker.setNextWalker(next);
  			next.setLocPathIterator(newIter);
  			walker = next;
  		}
  		walker.setNextWalker(null);
  	}
  	catch(CloneNotSupportedException cnse)
  	{
  		throw new WrappedRuntimeException(cnse);
  	}
  	return newIter;
  }
    
  
  protected boolean stepsEqual(WalkingIterator iter1, WalkingIterator iter2, 
                                         int numSteps)
  {
  	AxesWalker aw1 = iter1.getFirstWalker();
  	AxesWalker aw2 = iter2.getFirstWalker();
  	
  	for(int i = 0; (i < numSteps); i++)
  	{
  		if((null == aw1) || (null == aw2))
  		 	return false;
  		 	
  		if(!aw1.deepEquals(aw2))
  			return false;
  		
  		aw1 = aw1.getNextWalker();
  		aw2 = aw2.getNextWalker();
  	}
  	
  	assertion((null != aw1) || (null != aw2), ""Total match is incorrect!"");
  	
  	return true;
  }
  
  
  protected MultistepExprHolder createMultistepExprList(Vector paths)
  {
  	MultistepExprHolder first = null;
  	int n = paths.size();
  	for(int i = 0; i < n; i++)
  	{
  		ExpressionOwner eo = (ExpressionOwner)paths.elementAt(i);
  		if(null == eo)
  			continue;
  			
  		
  		LocPathIterator lpi = (LocPathIterator)eo.getExpression();
  		int numPaths = countSteps(lpi);
  		if(numPaths > 1)
  		{
  			if(null == first)
  				first = new MultistepExprHolder(eo, numPaths, null);
  			else
  				first = first.addInSortedOrder(eo, numPaths);
  		}
  	}
  	
  	if((null == first) || (first.getLength() <= 1))
  		return null;
  	else
  		return first;
  }
  
  
  protected int findAndEliminateRedundant(int start, int firstOccuranceIndex,
                         ExpressionOwner firstOccuranceOwner, 
                         ElemTemplateElement psuedoVarRecipient,
                         Vector paths) 
                 throws org.w3c.dom.DOMException 
  {
	MultistepExprHolder head = null;
	MultistepExprHolder tail = null;
	int numPathsFound = 0;
	int n = paths.size();
	
	Expression expr1 = firstOccuranceOwner.getExpression();
	if(DEBUG)
		assertIsLocPathIterator(expr1, firstOccuranceOwner);
	boolean isGlobal = (paths == m_absPaths);
	LocPathIterator lpi = (LocPathIterator)expr1;
	int stepCount = countSteps(lpi);
	for(int j = start; j < n; j++)
	{
		ExpressionOwner owner2 = (ExpressionOwner)paths.elementAt(j);
		if(null != owner2)
		{
			Expression expr2 = owner2.getExpression();
			boolean isEqual = expr2.deepEquals(lpi);
			if(isEqual)
			{  		
				LocPathIterator lpi2  = (LocPathIterator)expr2;				
				if(null == head)
				{
					head = new MultistepExprHolder(firstOccuranceOwner, stepCount, null);
					tail = head;
					numPathsFound++;
				}
				tail.m_next = new MultistepExprHolder(owner2, stepCount, null);
				tail = tail.m_next;
	
				
				paths.setElementAt(null, j);
				
				
				numPathsFound++;
			}
		}
	}
	
	
	if((0 == numPathsFound) && isGlobal)
	{
      head = new MultistepExprHolder(firstOccuranceOwner, stepCount, null);
      numPathsFound++;
	}
	
	if(null != head)
	{
		ElemTemplateElement root = isGlobal ? psuedoVarRecipient : findCommonAncestor(head);
		LocPathIterator sharedIter = (LocPathIterator)head.m_exprOwner.getExpression();
		ElemVariable var = createPsuedoVarDecl(root, sharedIter, isGlobal);
		if(DIAGNOSE_MULTISTEPLIST)
			System.err.println(""Created var: ""+var.getName()+(isGlobal ? ""(Global)"" : """"));
		QName uniquePsuedoVarName = var.getName();
		while(null != head)
		{
			ExpressionOwner owner = head.m_exprOwner;	
			if(DIAGNOSE_MULTISTEPLIST)
				diagnoseLineNumber(owner.getExpression());
			changeToVarRef(uniquePsuedoVarName, owner, paths, root);
			head = head.m_next;
		}
		
		
		paths.setElementAt(var.getSelect(), firstOccuranceIndex);
	}
	
	return numPathsFound;
  } 
  
  
  protected int oldFindAndEliminateRedundant(int start, int firstOccuranceIndex,
                         ExpressionOwner firstOccuranceOwner, 
                         ElemTemplateElement psuedoVarRecipient,
                         Vector paths) 
                 throws org.w3c.dom.DOMException 
  {
	QName uniquePsuedoVarName = null;
	boolean foundFirst = false;
	int numPathsFound = 0;
	int n = paths.size();
	Expression expr1 = firstOccuranceOwner.getExpression();
	if(DEBUG)
		assertIsLocPathIterator(expr1, firstOccuranceOwner);
	boolean isGlobal = (paths == m_absPaths);
	LocPathIterator lpi = (LocPathIterator)expr1;
	for(int j = start; j < n; j++)
	{
		ExpressionOwner owner2 = (ExpressionOwner)paths.elementAt(j);
		if(null != owner2)
		{
			Expression expr2 = owner2.getExpression();
			boolean isEqual = expr2.deepEquals(lpi);
			if(isEqual)
			{  		
				LocPathIterator lpi2  = (LocPathIterator)expr2;				
				if(!foundFirst)
				{
					foundFirst = true;
					
					
					
				    ElemVariable var = createPsuedoVarDecl(psuedoVarRecipient, lpi, isGlobal);
				    if(null == var)
				    	return 0;
				    uniquePsuedoVarName = var.getName();
	
					changeToVarRef(uniquePsuedoVarName, firstOccuranceOwner, 
					               paths, psuedoVarRecipient);
					               
					
					
					paths.setElementAt(var.getSelect(), firstOccuranceIndex);
					numPathsFound++;
				}
	
				changeToVarRef(uniquePsuedoVarName, owner2, paths, psuedoVarRecipient);
	
				
				paths.setElementAt(null, j);
				
				
				numPathsFound++;
			}
		}
	}
	
	
	if((0 == numPathsFound) && (paths == m_absPaths))
	{
      ElemVariable var = createPsuedoVarDecl(psuedoVarRecipient, lpi, true);
      if(null == var)
        return 0;
	  uniquePsuedoVarName = var.getName();
      changeToVarRef(uniquePsuedoVarName, firstOccuranceOwner, paths, psuedoVarRecipient);
      paths.setElementAt(var.getSelect(), firstOccuranceIndex);
      numPathsFound++;
	}
	return numPathsFound;
  }
  
  
  protected int countSteps(LocPathIterator lpi)
  {
  	if(lpi instanceof WalkingIterator)
  	{
  		WalkingIterator wi = (WalkingIterator)lpi;
  		AxesWalker aw = wi.getFirstWalker();
  		int count = 0;
  		while(null != aw)
  		{
  			count++;
  			aw = aw.getNextWalker();
  		}
  		return count;
  	}
  	else
  		return 1;
  }
  
  
  protected void changeToVarRef(QName varName, ExpressionOwner owner, 
                                Vector paths, ElemTemplateElement psuedoVarRecipient) 
  {
	Variable varRef = (paths == m_absPaths) ? new VariableSafeAbsRef() : new Variable();
	varRef.setQName(varName);
	if(paths == m_absPaths)
	{
		StylesheetRoot root = (StylesheetRoot)psuedoVarRecipient;
		Vector globalVars = root.getVariablesAndParamsComposed();
		
		
		varRef.setIndex(globalVars.size()-1);
		varRef.setIsGlobal(true);
	}
	owner.setExpression(varRef);
  }

  
  protected ElemVariable createPsuedoVarDecl(
      ElemTemplateElement psuedoVarRecipient,
      LocPathIterator lpi, boolean isGlobal)
      throws org.w3c.dom.DOMException
  {
    QName uniquePsuedoVarName = new QName (PSUEDOVARNAMESPACE, ""#""+m_uniquePsuedoVarID);
    m_uniquePsuedoVarID++;
  		
  	if(isGlobal)
  	{
  	  return createGlobalPsuedoVarDecl(uniquePsuedoVarName, 
  	                                  (StylesheetRoot)psuedoVarRecipient, lpi);
  	}
  	else						
      return createLocalPsuedoVarDecl(uniquePsuedoVarName, psuedoVarRecipient, lpi);
  }
  
  
  protected ElemVariable createGlobalPsuedoVarDecl(QName uniquePsuedoVarName,
                                           StylesheetRoot stylesheetRoot, 
                                           LocPathIterator lpi) 
        throws org.w3c.dom.DOMException 
  {
  	ElemVariable psuedoVar = new ElemVariable();
  	psuedoVar.setIsTopLevel(true);
	XPath xpath = new XPath(lpi);
	psuedoVar.setSelect(xpath);
	psuedoVar.setName(uniquePsuedoVarName);
	
	Vector globalVars = stylesheetRoot.getVariablesAndParamsComposed();
	psuedoVar.setIndex(globalVars.size());
	globalVars.addElement(psuedoVar);
	return psuedoVar;
  }

  
  

  
  protected ElemVariable createLocalPsuedoVarDecl(QName uniquePsuedoVarName,
                                           ElemTemplateElement psuedoVarRecipient, 
                                           LocPathIterator lpi) 
        throws org.w3c.dom.DOMException 
  {
		ElemVariable psuedoVar = new ElemVariablePsuedo();
		
		XPath xpath = new XPath(lpi);
		psuedoVar.setSelect(xpath);
		psuedoVar.setName(uniquePsuedoVarName);

		ElemVariable var = addVarDeclToElem(psuedoVarRecipient, lpi, psuedoVar);
		
		lpi.exprSetParent(var);
		
		return var;
  }

  
  protected ElemVariable addVarDeclToElem(
    ElemTemplateElement psuedoVarRecipient,
    LocPathIterator lpi,
    ElemVariable psuedoVar)
    throws org.w3c.dom.DOMException
  {
    
    ElemTemplateElement ete = psuedoVarRecipient.getFirstChildElem();

    lpi.callVisitors(null, m_varNameCollector);

    
    
    
    
    if (m_varNameCollector.getVarCount() > 0)
    {
      ElemTemplateElement baseElem = getElemFromExpression(lpi);
      ElemVariable varElem = getPrevVariableElem(baseElem);
      while (null != varElem)
      {
        if (m_varNameCollector.doesOccur(varElem.getName()))
          {
          psuedoVarRecipient = varElem.getParentElem();
          ete = varElem.getNextSiblingElem();
          break;
        }
        varElem = getPrevVariableElem(varElem);
      }
    }

    if ((null != ete) && (Constants.ELEMNAME_PARAMVARIABLE == ete.getXSLToken()))
    {
      
      if(isParam(lpi))
        return null;

      while (null != ete)
      {
        ete = ete.getNextSiblingElem();
        if ((null != ete) && Constants.ELEMNAME_PARAMVARIABLE != ete.getXSLToken())
            break;
      }
    }
    psuedoVarRecipient.insertBefore(psuedoVar, ete);
    m_varNameCollector.reset();
    return psuedoVar;
  }
    
  
  protected boolean isParam(ExpressionNode expr)
  {
  	while(null != expr)
  	{
  		if(expr instanceof ElemTemplateElement)
  			break;
  		expr = expr.exprGetParent();
  	}
  	if(null != expr)
  	{
  		ElemTemplateElement ete = (ElemTemplateElement)expr;
  		while(null != ete)
  		{
  			int type = ete.getXSLToken();
  			switch(type)
  			{
  				case Constants.ELEMNAME_PARAMVARIABLE:
  					return true;
  				case Constants.ELEMNAME_TEMPLATE:
  				case Constants.ELEMNAME_STYLESHEET:
  					return false;
  			}
  			ete = ete.getParentElem();
  		}
  	}
  	return false;
  	
  }
  
  
  protected ElemVariable getPrevVariableElem(ElemTemplateElement elem)
  {
  	
  	
  	while(null != (elem = getPrevElementWithinContext(elem)))
  	{
  		int type = elem.getXSLToken();
  			
  		if((Constants.ELEMNAME_VARIABLE == type) ||
  		   (Constants.ELEMNAME_PARAMVARIABLE == type))
  		{
  			return (ElemVariable)elem;
  		}
  	}
  	return null;
  }
  
  
  protected ElemTemplateElement getPrevElementWithinContext(ElemTemplateElement elem)
  {
  	ElemTemplateElement prev = elem.getPreviousSiblingElem();
  	if(null == prev)
  		prev = elem.getParentElem();
  	if(null != prev)
  	{
  	  int type = prev.getXSLToken();
  	  if((Constants.ELEMNAME_FOREACH == type) || 
  	     (Constants.ELEMNAME_TEMPLATE == type) ||
  	     (Constants.ELEMNAME_STYLESHEET == type))
  	  {
  	  	prev = null;
  	  }
  	}
  	return prev;
  }
  
  
  protected ElemTemplateElement getElemFromExpression(Expression expr)
  {
  	ExpressionNode parent = expr.exprGetParent();
  	while(null != parent)
  	{
  		if(parent instanceof ElemTemplateElement)
  			return (ElemTemplateElement)parent;
  		parent = parent.exprGetParent();
  	}
  	throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_ASSERT_NO_TEMPLATE_PARENT, null));
  	
  }
      
  
  public boolean isAbsolute(LocPathIterator path)
  {
  	int analysis = path.getAnalysisBits();
    boolean isAbs = (WalkerFactory.isSet(analysis, WalkerFactory.BIT_ROOT) || 
           WalkerFactory.isSet(analysis, WalkerFactory.BIT_ANY_DESCENDANT_FROM_ROOT));
    if(isAbs)
    {
    	isAbs = m_absPathChecker.checkAbsolute(path);
    }
    return isAbs;
  }


  
  public boolean visitLocationPath(ExpressionOwner owner, LocPathIterator path)
  {
  	
  	
  	if(path instanceof SelfIteratorNoPredicate)
  	{
  		return true;
  	}
  	else if(path instanceof WalkingIterator)
  	{
  		WalkingIterator wi = (WalkingIterator)path;
  		AxesWalker aw = wi.getFirstWalker();
  		if((aw instanceof FilterExprWalker) && (null == aw.getNextWalker()))
  		{
  			FilterExprWalker few = (FilterExprWalker)aw;
  			Expression exp = few.getInnerExpression();
  			if(exp instanceof Variable)
  				return true;
  		}
  	}

    if (isAbsolute(path) && (null != m_absPaths))
    {
      if(DEBUG)
        validateNewAddition(m_absPaths, owner, path);
      m_absPaths.addElement(owner);
    }
    else if (m_isSameContext && (null != m_paths))
    {
      if(DEBUG)
        validateNewAddition(m_paths, owner, path);
      m_paths.addElement(owner);
    }

    return true;
  }

  
  public boolean visitPredicate(ExpressionOwner owner, Expression pred)
  {
    boolean savedIsSame = m_isSameContext;
    m_isSameContext = false;

    
    pred.callVisitors(owner, this);

    m_isSameContext = savedIsSame;

    
    
    return false;
  }
  
  
   boolean visitTopLevelInstruction(ElemTemplateElement elem)
   {
     int type = elem.getXSLToken();
     switch(type)
     {
       case Constants.ELEMNAME_TEMPLATE :
         return visitInstruction(elem);
       default:
         return true;
     }
   }


  
  boolean visitInstruction(ElemTemplateElement elem)
  {
    int type = elem.getXSLToken();
    switch (type)
    {
      case Constants.ELEMNAME_CALLTEMPLATE :
      case Constants.ELEMNAME_TEMPLATE :
      case Constants.ELEMNAME_FOREACH :
        {
          
          
          if(type == Constants.ELEMNAME_FOREACH)
          {
            ElemForEach efe = (ElemForEach) elem;
   		    
  		    Expression select = efe.getSelect();
  		    select.callVisitors(efe, this);
          }
         
  		  Vector savedPaths = m_paths;
  		  m_paths = new Vector();
  		    
  		  
  		  
  		  
  		  elem.callChildVisitors(this, false);  		
  		  eleminateRedundentLocals(elem);
  		    
  		  m_paths = savedPaths;
 
          
          return false;
        }
      case Constants.ELEMNAME_NUMBER :
      case Constants.ELEMNAME_SORT :
        
        
        boolean savedIsSame = m_isSameContext;
        m_isSameContext = false;
        elem.callChildVisitors(this);
        m_isSameContext = savedIsSame;
        return false;
        
      default :
        return true;
    }
  }
  
  
  
  
  protected void diagnoseNumPaths(Vector paths, int numPathsEliminated,  
                                  int numUniquePathsEliminated) 
  {
		if (numPathsEliminated > 0)
		{ 
		  if(paths == m_paths)
		  {
		    System.err.println(""Eliminated "" + numPathsEliminated + "" total paths!"");
		    System.err.println(
		      ""Consolodated "" + numUniquePathsEliminated + "" redundent paths!"");
		  }
		  else
		  {
		    System.err.println(""Eliminated "" + numPathsEliminated + "" total global paths!"");
		    System.err.println(
		      ""Consolodated "" + numUniquePathsEliminated + "" redundent global paths!"");
		  }
		}  
  }


  
  private final void assertIsLocPathIterator(Expression expr1, ExpressionOwner eo) 
    throws RuntimeException 
  {
		if(!(expr1 instanceof LocPathIterator))
		{
			String errMsg;
			if(expr1 instanceof Variable)
			{
				errMsg = ""Programmer's assertion: expr1 not an iterator: ""+
				          ((Variable)expr1).getQName();
			}
			else
			{
				errMsg = ""Programmer's assertion: expr1 not an iterator: ""+
				          expr1.getClass().getName();
			}
			throw new RuntimeException(errMsg + "", ""+
				          eo.getClass().getName()+"" ""+
				          expr1.exprGetParent());
		}
  }


  
  private static void validateNewAddition(Vector paths, ExpressionOwner owner, 
                                          LocPathIterator path) 
		throws RuntimeException 
  {
  	assertion(owner.getExpression() == path, ""owner.getExpression() != path!!!"");
	int n = paths.size();
	
	for(int i = 0; i < n; i++)
	{
		ExpressionOwner ew = (ExpressionOwner)paths.elementAt(i);
		assertion(ew != owner, ""duplicate owner on the list!!!"");
		assertion(ew.getExpression() != path, ""duplicate expression on the list!!!"");
	}
  }
  
  
  protected static void assertion(boolean b, String msg)
  {
  	if(!b)
  	{
  		throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR, new Object[]{msg}));
  		
  	}
  }
  
  
  class MultistepExprHolder implements Cloneable
  {
	ExpressionOwner m_exprOwner; 
	final int m_stepCount;
	MultistepExprHolder m_next;
	
	
	public Object clone()
		throws CloneNotSupportedException
	{
		return super.clone();
	}
	
	
  	MultistepExprHolder(ExpressionOwner exprOwner, int stepCount, MultistepExprHolder next)
  	{
  		m_exprOwner = exprOwner;
  		assertion(null != m_exprOwner, ""exprOwner can not be null!"");
  		m_stepCount = stepCount;
  		m_next = next;
  	}
	
	
	MultistepExprHolder addInSortedOrder(ExpressionOwner exprOwner, int stepCount)
	{
		MultistepExprHolder first = this;
		MultistepExprHolder next = this;
		MultistepExprHolder prev = null;
		while(null != next)
		{
			if(stepCount >= next.m_stepCount)
			{
				MultistepExprHolder newholder = new MultistepExprHolder(exprOwner, stepCount, next);
				if(null == prev)
					first = newholder;
				else
					prev.m_next = newholder;
					
				return first;
			}
			prev = next;
			next = next.m_next;
		}
		
		prev.m_next = new MultistepExprHolder(exprOwner, stepCount, null);
		return first;
	}
	
	
	MultistepExprHolder unlink(MultistepExprHolder itemToRemove)
	{
		MultistepExprHolder first = this;
		MultistepExprHolder next = this;
		MultistepExprHolder prev = null;
		while(null != next)
		{
			if(next == itemToRemove)
			{
				if(null == prev)
					first = next.m_next;
				else
					prev.m_next = next.m_next;
				
				next.m_next = null;
					
				return first;
			}
			prev = next;
			next = next.m_next;
		}
		
		assertion(false, ""unlink failed!!!"");
		return null;
	}
		
	
	int getLength()
	{
		int count = 0;
		MultistepExprHolder next = this;
		while(null != next)
		{
			count++;
			next = next.m_next;
		}
		return count;
	}
	
    
    protected void diagnose()
    {
      System.err.print(""Found multistep iterators: "" + this.getLength() + ""  "");
      MultistepExprHolder next = this;
      while (null != next)
      {
        System.err.print("""" + next.m_stepCount);
        next = next.m_next;
        if (null != next)
              System.err.print("", "");
      }
      System.err.println();
    }
	
  }

}"
org.apache.xml.utils.synthetic.TestDriver,7,1,0,6,31,15,1,6,4,0.833333333,189,0.5,0,0.0,0.233333333,0,0,25.71428571,2,0.8571,0,"


package org.apache.xml.utils.synthetic;

import org.apache.xml.utils.synthetic.Class;
import org.apache.xml.utils.synthetic.reflection.*;


public class TestDriver
{

  
  public static int sampleField = 32;

  
  private boolean inTest = false;

  
  public static void main(String[] args)
  {

    
    try
    {
      System.out.println(""Proxying java.awt.Frame..."");

      Class myC = Class.forName(""java.awt.Frame"");

      myC.toSource(System.out, 0);
      System.out.println(
        ""
Proxying org.apache.xml.utils.synthetic.TestDriver..."");

      myC =
        Class.forName(""com.ibm.org.apache.xml.utils.synthetic.TestDriver"");

      myC.toSource(System.out, 0);
    }
    catch (ClassNotFoundException e)
    {
      System.out.println(""Couldn't proxy: "");
      e.printStackTrace();
    }

    
    try
    {
      System.out.println(""
Build a new beast..."");

      Class myC = Class.declareClass(
        ""com.ibm.org.apache.xml.utils.synthetic.BuildMe"");
      Class inner = myC.declareInnerClass(""island"");

      inner.addExtends(Class.forName(""java.lang.String""));

      Method m = inner.declareMethod(""getValue"");

      m.setReturnType(Class.forName(""java.lang.String""));
      m.getBody().append(""return toString();"");
      myC.toSource(System.out, 0);
    }
    catch (ClassNotFoundException e)
    {
      e.printStackTrace();
    }
    catch (SynthesisException e)
    {
      e.printStackTrace();
    }
    catch (IllegalStateException e)
    {
      System.out.println(""Unwritten function: "" + e);
      e.printStackTrace();
    }
  }

  
  public static void dumpClass(Class C)
  {

    System.out.println(""toString(): "" + C);
    System.out.println(""	isPrimitive(): "" + C.isPrimitive());
    System.out.println(""	isInterface(): "" + C.isInterface());
    System.out.println(""	isInstance(""foo""): "" + C.isInstance(""foo""));
    System.out.println(""	isArray(): "" + C.isArray());
    System.out.println(""	getRealClass(): "" + C.getRealClass());
  }

  
  public void quickcheck()
  {

    Inner a = new Inner();

    a.setTest(!a.getTest());
  }

  
  private class Inner
  {

    
    public boolean getTest()
    {
      return inTest;
    }

    
    public void setTest(boolean test)
    {
      inTest = test;
    }
  }
}
"
org.apache.xalan.templates.ElemExtensionCall,9,5,0,20,50,32,4,17,7,1.025,272,0.0,1,0.967611336,0.351851852,3,7,28.66666667,5,1.5556,2,"
package org.apache.xalan.templates;

import java.io.*;

import java.util.*;



import org.xml.sax.*;
import org.xml.sax.helpers.*;

import java.util.StringTokenizer;

import org.apache.xml.utils.QName;
import org.apache.xml.utils.NameSpace;
import org.apache.xml.utils.StringToStringTable;
import org.apache.xpath.XPathContext;
import org.apache.xml.utils.MutableAttrListImpl;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.XPathContext;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.extensions.ExtensionHandler;
import org.apache.xalan.extensions.ExtensionsTable;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;

import org.apache.xml.dtm.DTM;


public class ElemExtensionCall extends ElemLiteralResult
{

  
  String m_extns;

  
  String m_lang;

  
  String m_srcURL;

  
  String m_scriptSrc;

  
  ElemExtensionDecl m_decl = null;

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_EXTENSIONCALL;
  }

  

  
  
  
  
  

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    m_extns = this.getNamespace();   
    m_decl = getElemExtensionDecl(sroot, m_extns);
    
    
    if (m_decl == null)
      sroot.getExtensionNamespacesManager().registerExtension(m_extns);
  }
 
  
  private ElemExtensionDecl getElemExtensionDecl(StylesheetRoot stylesheet,
          String namespace)
  {

    ElemExtensionDecl decl = null;
    int n = stylesheet.getGlobalImportCount();

    for (int i = 0; i < n; i++)
    {
      Stylesheet imported = stylesheet.getGlobalImport(i);

      for (ElemTemplateElement child = imported.getFirstChildElem();
              child != null; child = child.getNextSiblingElem())
      {
        if (Constants.ELEMNAME_EXTENSIONDECL == child.getXSLToken())
        {
          decl = (ElemExtensionDecl) child;

          String prefix = decl.getPrefix();
          String declNamespace = child.getNamespaceForPrefix(prefix);

          if (namespace.equals(declNamespace))
          {
            return decl;
          }
        }
      }
    }

    return decl;
  }
  
  
  public void executeFallbacks(
          TransformerImpl transformer)
            throws TransformerException
  {
    for (ElemTemplateElement child = m_firstChild; child != null;
             child = child.m_nextSibling)
    {
      if (child.getXSLToken() == Constants.ELEMNAME_FALLBACK)
      {
        try
        {
          transformer.pushElemTemplateElement(child);
          ((ElemFallback) child).executeFallback(transformer);
        }
        finally
        {
          transformer.popElemTemplateElement();
        }
      }
    }

  }


  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    try
    {
      transformer.getResultTreeHandler().flushPending();

      ExtensionsTable etable = transformer.getExtensionsTable();
      ExtensionHandler nsh = etable.get(m_extns);

      if (null == nsh)
      {
        executeFallbacks(transformer);
        return;
      }

      try
      {
        nsh.processElement(this.getLocalName(), this, transformer,
                           getStylesheet(), this);
      }
      catch (Exception e)
      {

        
        
        String msg = e.getMessage();
        
        TransformerException te;
        if(e instanceof TransformerException)
        {
          te = (TransformerException)e;
        }
        else
        {
          if(null != msg)
            te = new TransformerException(e);
          else
            te = new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_UNKNOWN_ERROR_CALLING_EXTENSION, null), e); 
        }
        if(null == te.getLocator())
          te.setLocator(this);

        if (null != msg)
        {
          if (msg.indexOf(""fatal"") >= 0)
          {
            transformer.getErrorListener().fatalError(te);
          }
          else if(e instanceof RuntimeException)      
            transformer.getErrorListener().error(te); 
          else
            transformer.getErrorListener().warning(te);

        }
        else      
          transformer.getErrorListener().error(te); 

        executeFallbacks(
          transformer);
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      transformer.getErrorListener().fatalError(new TransformerException(se));
    }
  }

  
  public String getAttribute(String rawName)
  {

    AVT avt = getLiteralResultAttribute(rawName);

    if ((null != avt) && avt.getRawName().equals(rawName))
    {
      return avt.getSimpleString();
    }

    return null;
  }

  
  public String getAttribute(
          String rawName, org.w3c.dom.Node sourceNode, TransformerImpl transformer)
            throws TransformerException
  {

    AVT avt = getLiteralResultAttribute(rawName);

    if ((null != avt) && avt.getRawName().equals(rawName))
    {
      XPathContext xctxt = transformer.getXPathContext();

      return avt.evaluate(xctxt, 
            xctxt.getDTMHandleFromNode(sourceNode), 
            this);
    }

    return null;
  }
  
  
  protected boolean accept(XSLTVisitor visitor)
  {
  	return visitor.visitExtensionElement(this);
  }

  
}
"
org.apache.xml.utils.res.XResources_zh_TW,3,4,0,1,4,1,0,1,2,0.5,499,0.0,0,0.976190476,1.0,0,0,165.0,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_zh_TW extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""zh"" }, { ""help_language"", ""zh"" }, { ""language"", ""zh"" },
    { ""alphabet"",
      new char[]{ 0xff21, 0xff22, 0xff23, 0xff24, 0xff25, 0xff26, 0xff27,
                  0xff28, 0xff29, 0xff2a, 0xff2b, 0xff2c, 0xff2d, 0xff2e,
                  0xff2f, 0xff30, 0xff31, 0xff32, 0xff33, 0xff34, 0xff35,
                  0xff36, 0xff37, 0xff38, 0xff39, 0xff3a } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    { ""zero"", new char[]{ 0x96f6 } },

    
    { ""multiplier"", new long[]{ 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x5104, 0x842c, 0x4edf, 0x4f70, 0x62fe } },
    { ""digits"",
      new char[]{ 0x58f9, 0x8cb3, 0x53c3, 0x8086, 0x4f0d, 0x9678, 0x67d2,
                  0x634c, 0x7396 } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xalan.processor.ProcessorStylesheetDoc,1,4,0,2,2,0,1,1,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xalan.processor;


public class ProcessorStylesheetDoc extends XSLTElementProcessor
{
}
"
org.apache.xalan.templates.ElemTemplateElement,84,2,29,101,125,3056,91,17,75,0.913654618,1279,0.75,3,0.567708333,0.090336134,1,12,14.08333333,9,1.5595,1,"
package org.apache.xalan.templates;

import java.lang.InstantiationException;

import java.io.Serializable;

import java.util.Enumeration;
import java.util.Vector;


import org.apache.xml.utils.UnImplNode;
import org.apache.xml.utils.NameSpace;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.StringToStringTable;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultNameSpace;
import org.apache.xalan.transformer.ResultTreeHandler;
import org.apache.xpath.VariableStack;
import org.apache.xpath.WhitespaceStrippingElementMatcher;
import org.apache.xpath.ExpressionNode;


import javax.xml.transform.Templates;
import javax.xml.transform.SourceLocator;


import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.DOMException;
import org.w3c.dom.Document;
import org.apache.xml.dtm.DTM;


import org.xml.sax.Locator;
import javax.xml.transform.TransformerException;

import org.xml.sax.helpers.NamespaceSupport;
import org.apache.xml.utils.NamespaceSupport2;


public class ElemTemplateElement extends UnImplNode
        implements PrefixResolver, Serializable, ExpressionNode, 
                   WhitespaceStrippingElementMatcher, XSLTVisitable
{

  
  public ElemTemplateElement(){}

  
  public boolean isCompiledTemplate()
  {
    return false;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_UNDEFINED;
  }

  
  public String getNodeName()
  {
    return ""Unknown XSLT Element"";
  }
  
  
  public String getLocalName()
  {

    return getNodeName();
  }


  
  public void runtimeInit(TransformerImpl transformer) throws TransformerException{}

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException{}

  
  public StylesheetComposed getStylesheetComposed()
  {
    return m_parentNode.getStylesheetComposed();
  }

  
  public Stylesheet getStylesheet()
  {
    return (null==m_parentNode) ? null : m_parentNode.getStylesheet();
  }

  
  public StylesheetRoot getStylesheetRoot()
  {
    return m_parentNode.getStylesheetRoot();
  }

  
  public void recompose(StylesheetRoot root) throws TransformerException
  {
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    resolvePrefixTables();
    ElemTemplateElement t = getFirstChildElem();
    m_hasTextLitOnly = ((t != null) 
              && (t.getXSLToken() == Constants.ELEMNAME_TEXTLITERALRESULT) 
              && (t.getNextSiblingElem() == null));
              
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    cstate.pushStackMark();
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    cstate.popStackMark();
  }

  
  protected boolean isValidNCName(String s)
  {

    int len = s.length();
    char c = s.charAt(0);

    if (!(Character.isLetter(c) || (c == '_')))
      return false;

    if (len > 0)
    {
      for (int i = 1; i < len; i++)
      {
        c = s.charAt(i);

        if (!(Character.isLetterOrDigit(c) || (c == '_') || (c == '-')
              || (c == '.')))
          return false;
      }
    }

    return true;
  }

  
  public void error(int msg, Object[] args)
  {

    String themsg = XSLMessages.createMessage(msg, args);

    error(
      XSLMessages.createMessage(
        XSLTErrorResources.ER_ELEMTEMPLATEELEM_ERR, new Object[]{ themsg }));  
  }
  
  
  public void error(int msg)
  {
    error(msg, null);
  }
  
  
  public void error(String msg)
  {
    throw new RuntimeException(msg);
  }
  

  
  
  public Node appendChild(Node newChild) throws DOMException
  {

    if (null == newChild)
    {
      error(XSLTErrorResources.ER_NULL_CHILD, null);  
    }

    ElemTemplateElement elem = (ElemTemplateElement) newChild;

    if (null == m_firstChild)
    {
      m_firstChild = elem;
    }
    else
    {
      ElemTemplateElement last = (ElemTemplateElement) getLastChild();

      last.m_nextSibling = elem;
    }

    elem.m_parentNode = this;

    return newChild;
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement elem)
  {

    if (null == elem)
    {
      error(XSLTErrorResources.ER_NULL_CHILD, null);  
    }

    if (null == m_firstChild)
    {
      m_firstChild = elem;
    }
    else
    {
      ElemTemplateElement last = getLastChildElem();

      last.m_nextSibling = elem;
    }

    elem.setParentElem(this);

    return elem;
  }


  
  public boolean hasChildNodes()
  {
    return (null != m_firstChild);
  }

  
  public short getNodeType()
  {
    return org.w3c.dom.Node.ELEMENT_NODE;
  }

  
  public NodeList getChildNodes()
  {
    return this;
  }

  
  public ElemTemplateElement removeChild(ElemTemplateElement childETE)
  {

    if (childETE == null || childETE.m_parentNode != this)
      return null;

    
    if (childETE == m_firstChild)
      m_firstChild = childETE.m_nextSibling;
    else
    {
      ElemTemplateElement prev = childETE.getPreviousSiblingElem();

      prev.m_nextSibling = childETE.m_nextSibling;
    }

    
    childETE.m_parentNode = null;
    childETE.m_nextSibling = null;

    return childETE;
  }

  
  public Node replaceChild(Node newChild, Node oldChild) throws DOMException
  {

    if (oldChild == null || oldChild.getParentNode() != this)
      return null;

    ElemTemplateElement newChildElem = ((ElemTemplateElement) newChild);
    ElemTemplateElement oldChildElem = ((ElemTemplateElement) oldChild);

    
    ElemTemplateElement prev =
      (ElemTemplateElement) oldChildElem.getPreviousSibling();

    if (null != prev)
      prev.m_nextSibling = newChildElem;

    
    if (m_firstChild == oldChildElem)
      m_firstChild = newChildElem;

    newChildElem.m_parentNode = this;
    oldChildElem.m_parentNode = null;
    newChildElem.m_nextSibling = oldChildElem.m_nextSibling;
    oldChildElem.m_nextSibling = null;

    
    
    return newChildElem;
  }
  
  
  public Node insertBefore(Node newChild, Node refChild) throws DOMException
  {
  	if(null == refChild)
  	{
  		appendChild(newChild);
  		return newChild;
  	}
  	
  	if(newChild == refChild)
  	{
  		
  		return newChild;
  	}

    Node node = m_firstChild; 
    Node prev = null;  
    boolean foundit = false;
    
    while (null != node)
    {
    	
    	if(newChild == node)
    	{
    		if(null != prev)
    			((ElemTemplateElement)prev).m_nextSibling = 
    				(ElemTemplateElement)node.getNextSibling();
    		else
    			m_firstChild = (ElemTemplateElement)node.getNextSibling();
    		node = node.getNextSibling();
    		continue; 
    	}
    	if(refChild == node)
    	{
    		if(null != prev)
    		{
    			((ElemTemplateElement)prev).m_nextSibling = (ElemTemplateElement)newChild;
    		}
    		else
    		{
    			m_firstChild = (ElemTemplateElement)newChild;
    		}
    		((ElemTemplateElement)newChild).m_nextSibling = (ElemTemplateElement)refChild;
    		((ElemTemplateElement)newChild).setParentElem(this);
    		prev = newChild;
    		node = node.getNextSibling();
    		foundit = true;
    		continue;
    	}
    	prev = node;
    	node = node.getNextSibling();
    }
    
    if(!foundit)
    	throw new DOMException(DOMException.NOT_FOUND_ERR, 
    		""refChild was not found in insertBefore method!"");
    else
    	return newChild;
  }


  
  public ElemTemplateElement replaceChild(ElemTemplateElement newChildElem, 
                                          ElemTemplateElement oldChildElem)
  {

    if (oldChildElem == null || oldChildElem.getParentElem() != this)
      return null;

    
    ElemTemplateElement prev =
      oldChildElem.getPreviousSiblingElem();

    if (null != prev)
      prev.m_nextSibling = newChildElem;

    
    if (m_firstChild == oldChildElem)
      m_firstChild = newChildElem;

    newChildElem.m_parentNode = this;
    oldChildElem.m_parentNode = null;
    newChildElem.m_nextSibling = oldChildElem.m_nextSibling;
    oldChildElem.m_nextSibling = null;

    
    
    return newChildElem;
  }

  
  public int getLength()
  {

    
    
    
    int count = 0;

    for (ElemTemplateElement node = m_firstChild; node != null;
            node = node.m_nextSibling)
    {
      count++;
    }

    return count;
  }  

  
  public Node item(int index)
  {

    
    
    
    ElemTemplateElement node = m_firstChild;

    for (int i = 0; i < index && node != null; i++)
    {
      node = node.m_nextSibling;
    }

    return node;
  }  

  
  public Document getOwnerDocument()
  {
    return getStylesheet();
  }
  
  
  public ElemTemplate getOwnerXSLTemplate()
  {
  	ElemTemplateElement el = this;
  	int type = el.getXSLToken();
  	while((null != el) && (type != Constants.ELEMNAME_TEMPLATE))
  	{
    	el = el.getParentElem();
    	if(null != el)
  			type = el.getXSLToken();
  	}
  	return (ElemTemplate)el;
  }


  
  public String getTagName()
  {
    return getNodeName();
  }
  
  
  public boolean hasTextLitOnly()
  {
    return m_hasTextLitOnly;
  }

  
  public String getBaseIdentifier()
  {

    
    return this.getSystemId();
  }

  
  private int m_lineNumber;

  
  public int getLineNumber()
  {
    return m_lineNumber;
  }

  
  private int m_columnNumber;

  
  public int getColumnNumber()
  {
    return m_columnNumber;
  }

  
  public String getPublicId()
  {
    return (null != m_parentNode) ? m_parentNode.getPublicId() : null;
  }

  
  public String getSystemId()
  {
    Stylesheet sheet=getStylesheet();
    return (sheet==null) ? null : sheet.getHref();
  }

  
  public void setLocaterInfo(SourceLocator locator)
  {
    m_lineNumber = locator.getLineNumber();
    m_columnNumber = locator.getColumnNumber();
  }

  
  private boolean m_defaultSpace = true;

  
  private boolean m_hasTextLitOnly = false;

  
  protected boolean m_hasVariableDecl = false;
  
  public boolean hasVariableDecl()
  {
    return m_hasVariableDecl;
  }

  
  public void setXmlSpace(int v)
  {
    m_defaultSpace = ((Constants.ATTRVAL_STRIP == v) ? true : false);
  }

  
  public boolean getXmlSpace()
  {
    return m_defaultSpace;
  }

  
  private Vector m_declaredPrefixes;

  
  public Vector getDeclaredPrefixes()
  {
    return m_declaredPrefixes;
  }

  
  public void setPrefixes(NamespaceSupport nsSupport) throws TransformerException
  {
    setPrefixes(nsSupport, false);
  }

  
  public void setPrefixes(NamespaceSupport nsSupport, boolean excludeXSLDecl)
          throws TransformerException
  {

    Enumeration decls = nsSupport.getDeclaredPrefixes();

    while (decls.hasMoreElements())
    {
      String prefix = (String) decls.nextElement();

      if (null == m_declaredPrefixes)
        m_declaredPrefixes = new Vector();

      String uri = nsSupport.getURI(prefix);

      if (excludeXSLDecl && uri.equals(Constants.S_XSLNAMESPACEURL))
        continue;

      
      XMLNSDecl decl = new XMLNSDecl(prefix, uri, false);

      m_declaredPrefixes.addElement(decl);
    }
  }

  
  public String getNamespaceForPrefix(String prefix, org.w3c.dom.Node context)
  {
    this.error(XSLTErrorResources.ER_CANT_RESOLVE_NSPREFIX, null);

    return null;
  }

  
  public String getNamespaceForPrefix(String prefix)
  {





    Vector nsDecls = m_declaredPrefixes;

    if (null != nsDecls)
    {
      int n = nsDecls.size();
      if(prefix.equals(Constants.ATTRVAL_DEFAULT_PREFIX))
      {
        prefix = """";
      }

      for (int i = 0; i < n; i++)
      {
        XMLNSDecl decl = (XMLNSDecl) nsDecls.elementAt(i);

        if (prefix.equals(decl.getPrefix()))
          return decl.getURI();
      }
    }

    
    if (null != m_parentNode)
      return m_parentNode.getNamespaceForPrefix(prefix);

    
    
    
    if(""xml"".equals(prefix))
      return ""http:

    
    return null;
  }

  
  Vector m_prefixTable;

  
  public Vector getPrefixes()
  {
    return m_prefixTable;
  }
  
  
  public boolean containsExcludeResultPrefix(String prefix, String uri)
  {
    ElemTemplateElement parent = this.getParentElem();
    if(null != parent)
      return parent.containsExcludeResultPrefix(prefix, uri);
      
    return false;
  }

  
  private boolean excludeResultNSDecl(String prefix, String uri)
          throws TransformerException
  {

    if (uri != null)
    {
      if (uri.equals(Constants.S_XSLNAMESPACEURL)
              || getStylesheet().containsExtensionElementURI(uri)
              || uri.equals(Constants.S_BUILTIN_EXTENSIONS_URL))
        return true;

      if (containsExcludeResultPrefix(prefix, uri))
        return true;
    }

    return false;
  }
  
  
  public void resolvePrefixTables() throws TransformerException
  {
    
    m_prefixTable = null;

    
    
    
    
    if (null != this.m_declaredPrefixes)
    {
      StylesheetRoot stylesheet = this.getStylesheetRoot();
      
      
      
      int n = m_declaredPrefixes.size();

      for (int i = 0; i < n; i++)
      {
        XMLNSDecl decl = (XMLNSDecl) m_declaredPrefixes.elementAt(i);
        String prefix = decl.getPrefix();
        String uri = decl.getURI();
        if(null == uri)
          uri = """";
        boolean shouldExclude = excludeResultNSDecl(prefix, uri);

        
        if (null == m_prefixTable)
          m_prefixTable = new Vector();

        NamespaceAlias nsAlias = stylesheet.getNamespaceAliasComposed(uri);
        if(null != nsAlias)
        {
          
          
          
          
          
          
          decl = new XMLNSDecl(nsAlias.getStylesheetPrefix(), 
                              nsAlias.getResultNamespace(), shouldExclude);
        }
        else
          decl = new XMLNSDecl(prefix, uri, shouldExclude);

        m_prefixTable.addElement(decl);
        
      }
    }

    ElemTemplateElement parent = this.getParentNodeElem();

    if (null != parent)
    {

      
      Vector prefixes = parent.m_prefixTable;

      if (null == m_prefixTable && !needToCheckExclude())
      {

        
        this.m_prefixTable = parent.m_prefixTable;
      }
      else
      {

        
        int n = prefixes.size();
        
        for (int i = 0; i < n; i++)
        {
          XMLNSDecl decl = (XMLNSDecl) prefixes.elementAt(i);
          boolean shouldExclude = excludeResultNSDecl(decl.getPrefix(),
                                                      decl.getURI());

          if (shouldExclude != decl.getIsExcluded())
          {
            decl = new XMLNSDecl(decl.getPrefix(), decl.getURI(),
                                 shouldExclude);
          }
          
          
          addOrReplaceDecls(decl);
        }
      }
    }
    else if (null == m_prefixTable)
    {

      
      m_prefixTable = new Vector();
    }
  }
  
  
  void addOrReplaceDecls(XMLNSDecl newDecl)
  {
      int n = m_prefixTable.size();

        for (int i = n - 1; i >= 0; i--)
        {
          XMLNSDecl decl = (XMLNSDecl) m_prefixTable.elementAt(i);

          if (decl.getPrefix().equals(newDecl.getPrefix()))
          {
            return;
          }
        }
      m_prefixTable.addElement(newDecl);    
    
  }
  
  
  boolean needToCheckExclude()
  {
    return false;    
  } 

  
  void executeNSDecls(TransformerImpl transformer) throws TransformerException
  {

    try
    {
      if (null != m_prefixTable)
      {
        ResultTreeHandler rhandler = transformer.getResultTreeHandler();
        int n = m_prefixTable.size();

        for (int i = n - 1; i >= 0; i--)
        {
          XMLNSDecl decl = (XMLNSDecl) m_prefixTable.elementAt(i);

          if (!decl.getIsExcluded())
          {
            rhandler.startPrefixMapping(decl.getPrefix(), decl.getURI(), true);
          }
        }
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }

  
  void unexecuteNSDecls(TransformerImpl transformer) throws TransformerException
  {

    try
    {
      if (null != m_prefixTable)
      {
        ResultTreeHandler rhandler = transformer.getResultTreeHandler();
        int n = m_prefixTable.size();

        for (int i = 0; i < n; i++)
        {
          XMLNSDecl decl = (XMLNSDecl) m_prefixTable.elementAt(i);

          if (!decl.getIsExcluded())
          {
            rhandler.endPrefixMapping(decl.getPrefix());
          }
        }
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }
  
  
  protected int m_docOrderNumber = -1;
  
  
  public void setUid(int i)
  {
    m_docOrderNumber = i;
  }

  
  public int getUid()
  {
    return m_docOrderNumber;
  }


  
  protected ElemTemplateElement m_parentNode;

  
  public Node getParentNode()
  {
    return m_parentNode;
  }

  
  public ElemTemplateElement getParentElem()
  {
    return m_parentNode;
  }

  
  public void setParentElem(ElemTemplateElement p)
  {
    m_parentNode = p;
  }

  
  ElemTemplateElement m_nextSibling;

  
  public Node getNextSibling()
  {
    return m_nextSibling;
  }

  
  public Node getPreviousSibling()
  {

    Node walker = getParentNode(), prev = null;

    if (walker != null)
      for (walker = walker.getFirstChild(); walker != null;
              prev = walker, walker = walker.getNextSibling())
      {
        if (walker == this)
          return prev;
      }

    return null;
  }

  
  public ElemTemplateElement getPreviousSiblingElem()
  {

    ElemTemplateElement walker = getParentNodeElem();
    ElemTemplateElement prev = null;

    if (walker != null)
      for (walker = walker.getFirstChildElem(); walker != null;
              prev = walker, walker = walker.getNextSiblingElem())
      {
        if (walker == this)
          return prev;
      }

    return null;
  }


  
  public ElemTemplateElement getNextSiblingElem()
  {
    return m_nextSibling;
  }
  
  
  public ElemTemplateElement getParentNodeElem()
  {
    return m_parentNode;
  }


  
  ElemTemplateElement m_firstChild;

  
  public Node getFirstChild()
  {
    return m_firstChild;
  }

  
  public ElemTemplateElement getFirstChildElem()
  {
    return m_firstChild;
  }

  
  public Node getLastChild()
  {

    ElemTemplateElement lastChild = null;

    for (ElemTemplateElement node = m_firstChild; node != null;
            node = node.m_nextSibling)
    {
      lastChild = node;
    }

    return lastChild;
  }

  
  public ElemTemplateElement getLastChildElem()
  {

    ElemTemplateElement lastChild = null;

    for (ElemTemplateElement node = m_firstChild; node != null;
            node = node.m_nextSibling)
    {
      lastChild = node;
    }

    return lastChild;
  }


  
  transient private org.w3c.dom.Node m_DOMBackPointer;

  
  public org.w3c.dom.Node getDOMBackPointer()
  {
    return m_DOMBackPointer;
  }

  
  public void setDOMBackPointer(org.w3c.dom.Node n)
  {
    m_DOMBackPointer = n;
  }

  
  public int compareTo(Object o) throws ClassCastException {
    
    ElemTemplateElement ro = (ElemTemplateElement) o;
    int roPrecedence = ro.getStylesheetComposed().getImportCountComposed();
    int myPrecedence = this.getStylesheetComposed().getImportCountComposed();

    if (myPrecedence < roPrecedence)
      return -1;
    else if (myPrecedence > roPrecedence)
      return 1;
    else
      return this.getUid() - ro.getUid();
  }
  
  
  public boolean shouldStripWhiteSpace(
          org.apache.xpath.XPathContext support, 
          org.w3c.dom.Element targetElement) throws TransformerException
  {
    StylesheetRoot sroot = this.getStylesheetRoot();
    return (null != sroot) ? sroot.shouldStripWhiteSpace(support, targetElement) :false;
  }
  
  
  public boolean canStripWhiteSpace()
  {
    StylesheetRoot sroot = this.getStylesheetRoot();
    return (null != sroot) ? sroot.canStripWhiteSpace() : false;
  }
  
  
  public boolean canAcceptVariables()
  {
  	return true;
  }
  
  
  
  
  public void exprSetParent(ExpressionNode n)
  {
  	
  	
  	setParentElem((ElemTemplateElement)n);
  }
  
  
  public ExpressionNode exprGetParent()
  {
  	return getParentElem();
  }

  
  public void exprAddChild(ExpressionNode n, int i)
  {
  	appendChild((ElemTemplateElement)n);
  }

  
  public ExpressionNode exprGetChild(int i)
  {
  	return (ExpressionNode)item(i);
  }

  
  public int exprGetNumChildren()
  {
  	return getLength();
  }
  
  
  protected boolean accept(XSLTVisitor visitor)
  {
  	return visitor.visitInstruction(this);
  }

  
  public void callVisitors(XSLTVisitor visitor)
  {
  	if(accept(visitor))
  	{
		callChildVisitors(visitor);
  	}
  }

  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttributes)
  {
    for (ElemTemplateElement node = m_firstChild;
      node != null;
      node = node.m_nextSibling)
      {
      node.callVisitors(visitor);
    }
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor)
  {
  	callChildVisitors(visitor, true);
  }


	
	public boolean handlesNullPrefixes() {
		return false;
	}

}
"
org.apache.xml.utils.IntStack,10,2,0,6,16,45,5,1,10,2.0,143,0.0,0,0.666666667,0.8,1,14,13.3,2,1.1,1,"
package org.apache.xml.utils;

import java.util.EmptyStackException;


public class IntStack extends IntVector
{

  
  public IntStack()
  {
    super();
  }

  
  public IntStack(int blocksize)
  {
    super(blocksize);
  }

  
  public int push(int i)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = i;

    m_firstFree++;

    return i;
  }

  
  public int pop()
  {
    return m_map[--m_firstFree];
  }

  

  public void quickPop(int n)
  {
    m_firstFree -= n;
  }

  
  public int peek()
  {
    try {
      return m_map[m_firstFree - 1];
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      throw new EmptyStackException();
    }
  }

  
  public int peek(int n)
  {
    try {
      return m_map[m_firstFree-(1+n)];
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      throw new EmptyStackException();
    }
  }

  
  public void setTop(int val)
  {
    try {
      m_map[m_firstFree - 1] = val;
    }
    catch (ArrayIndexOutOfBoundsException e)
    {
      throw new EmptyStackException();
    }
  }

  
  public boolean empty()
  {
    return m_firstFree == 0;
  }

  
  public int search(int o)
  {

    int i = lastIndexOf(o);

    if (i >= 0)
    {
      return size() - i;
    }

    return -1;
  }
}
"
org.apache.xalan.lib.sql.ConnectionPool,14,1,0,4,14,91,4,0,14,2.0,14,0.0,0,0.0,0.273809524,0,0,0.0,1,1.0,0,"

package org.apache.xalan.lib.sql;

import java.util.Properties;
import java.lang.String;
import java.sql.Connection;
import java.sql.SQLException;
import java.sql.*;


public interface ConnectionPool
{

  
  public boolean isEnabled( );

  
  public void setDriver( String d );

  
  public void setURL( String url );

  
  public void freeUnused( );


  
  public boolean hasActiveConnections( );

  
  public void setPassword( String p );

  
  public void setUser( String u );


  
  public void setMinConnections( int n );

  
  public boolean testConnection( );

  
  public Connection getConnection( )throws SQLException;

   
  public void releaseConnection( Connection con )throws SQLException;

   
  public void releaseConnectionOnError( Connection con )throws SQLException;


  
  public void setPoolEnabled( final boolean flag );

  
  public void setProtocol(Properties p);


}"
org.apache.xpath.NodeSet,61,1,0,8,71,714,4,4,60,0.629166667,1450,0.875,0,0.0,0.219262295,0,0,22.63934426,9,2.2131,0,"
package org.apache.xpath;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.traversal.NodeIterator;
import org.w3c.dom.traversal.NodeFilter;
import org.w3c.dom.DOMException;

import org.apache.xml.utils.NodeVector;
import org.apache.xpath.axes.ContextNodeList;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;



public class NodeSet
        implements NodeList, NodeIterator, Cloneable, ContextNodeList
{

  
  public NodeSet()
  {
    m_blocksize = 32;
    m_mapSize = 0;
  }

  
  public NodeSet(int blocksize)
  {
    m_blocksize = blocksize;
    m_mapSize = 0;
  }

  
  public NodeSet(NodeList nodelist)
  {

    this(32);

    addNodes(nodelist);
  }

  
  public NodeSet(NodeSet nodelist)
  {

    this(32);

    addNodes((NodeIterator) nodelist);
  }

  
  public NodeSet(NodeIterator ni)
  {

    this(32);

    addNodes(ni);
  }

  
  public NodeSet(Node node)
  {

    this(32);

    addNode(node);
  }

  
  public Node getRoot()
  {
    return null;
  }

  
  public NodeIterator cloneWithReset() throws CloneNotSupportedException
  {

    NodeSet clone = (NodeSet) clone();

    clone.reset();

    return clone;
  }

  
  public void reset()
  {
    m_next = 0;
  }

  
  public int getWhatToShow()
  {
    return NodeFilter.SHOW_ALL & ~NodeFilter.SHOW_ENTITY_REFERENCE;
  }

  
  public NodeFilter getFilter()
  {
    return null;
  }

  
  public boolean getExpandEntityReferences()
  {
    return true;
  }

  
  public Node nextNode() throws DOMException
  {

    if ((m_next) < this.size())
    {
      Node next = this.elementAt(m_next);

      m_next++;

      return next;
    }
    else
      return null;
  }

  
  public Node previousNode() throws DOMException
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_ITERATE, null)); 

    if ((m_next - 1) > 0)
    {
      m_next--;

      return this.elementAt(m_next);
    }
    else
      return null;
  }

  
  public void detach(){}

  
  public boolean isFresh()
  {
    return (m_next == 0);
  }

  
  public void runTo(int index)
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_INDEX, null)); 

    if ((index >= 0) && (m_next < m_firstFree))
      m_next = index;
    else
      m_next = m_firstFree - 1;
  }

  
  public Node item(int index)
  {

    runTo(index);

    return (Node) this.elementAt(index);
  }

  
  public int getLength()
  {

    runTo(-1);

    return this.size();
  }

  
  public void addNode(Node n)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    this.addElement(n);
  }

  
  public void insertNode(Node n, int pos)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    insertElementAt(n, pos);
  }

  
  public void removeNode(Node n)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    this.removeElement(n);
  }

  
  public void addNodes(NodeList nodelist)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null != nodelist)  
    {
      int nChildren = nodelist.getLength();

      for (int i = 0; i < nChildren; i++)
      {
        Node obj = nodelist.item(i);

        if (null != obj)
        {
          addElement(obj);
        }
      }
    }

    
  }

  
  public void addNodes(NodeSet ns)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    addNodes((NodeIterator) ns);
  }

  
  public void addNodes(NodeIterator iterator)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null != iterator)  
    {
      Node obj;

      while (null != (obj = iterator.nextNode()))
      {
        addElement(obj);
      }
    }

    
  }

  
  public void addNodesInDocOrder(NodeList nodelist, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    int nChildren = nodelist.getLength();

    for (int i = 0; i < nChildren; i++)
    {
      Node node = nodelist.item(i);

      if (null != node)
      {
        addNodeInDocOrder(node, support);
      }
    }
  }

  
  public void addNodesInDocOrder(NodeIterator iterator, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    Node node;

    while (null != (node = iterator.nextNode()))
    {
      addNodeInDocOrder(node, support);
    }
  }

  
  private boolean addNodesInDocOrder(int start, int end, int testIndex,
                                     NodeList nodelist, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    boolean foundit = false;
    int i;
    Node node = nodelist.item(testIndex);

    for (i = end; i >= start; i--)
    {
      Node child = (Node) elementAt(i);

      if (child == node)
      {
        i = -2;  

        break;
      }

      if (!DOM2Helper.isNodeAfter(node, child))
      {
        insertElementAt(node, i + 1);

        testIndex--;

        if (testIndex > 0)
        {
          boolean foundPrev = addNodesInDocOrder(0, i, testIndex, nodelist,
                                                 support);

          if (!foundPrev)
          {
            addNodesInDocOrder(i, size() - 1, testIndex, nodelist, support);
          }
        }

        break;
      }
    }

    if (i == -1)
    {
      insertElementAt(node, 0);
    }

    return foundit;
  }

  
  public int addNodeInDocOrder(Node node, boolean test, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    int insertIndex = -1;

    if (test)
    {

      
      
      
      int size = size(), i;

      for (i = size - 1; i >= 0; i--)
      {
        Node child = (Node) elementAt(i);

        if (child == node)
        {
          i = -2;  

          break;
        }

        if (!DOM2Helper.isNodeAfter(node, child))
        {
          break;
        }
      }

      if (i != -2)
      {
        insertIndex = i + 1;

        insertElementAt(node, insertIndex);
      }
    }
    else
    {
      insertIndex = this.size();

      boolean foundit = false;

      for (int i = 0; i < insertIndex; i++)
      {
        if (this.item(i).equals(node))
        {
          foundit = true;

          break;
        }
      }

      if (!foundit)
        addElement(node);
    }

    
    return insertIndex;
  }  

  
  public int addNodeInDocOrder(Node node, XPathContext support)
  {

    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    return addNodeInDocOrder(node, true, support);
  }  


  
  transient protected int m_next = 0;

  
  public int getCurrentPos()
  {
    return m_next;
  }

  
  public void setCurrentPos(int i)
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_INDEX, null)); 

    m_next = i;
  }

  
  public Node getCurrentNode()
  {

    if (!m_cacheNodes)
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_CANNOT_INDEX, null)); 

    int saved = m_next;
    Node n = (m_next < m_firstFree) ? elementAt(m_next) : null;
    m_next = saved; 
    return n;
  }

  
  transient protected boolean m_mutable = true;

  
  transient protected boolean m_cacheNodes = true;

  
  public boolean getShouldCacheNodes()
  {
    return m_cacheNodes;
  }

  
  public void setShouldCacheNodes(boolean b)
  {

    if (!isFresh())
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_CANNOT_CALL_SETSHOULDCACHENODE, null)); 

    m_cacheNodes = b;
    m_mutable = true;
  }
  
  
  transient private int m_last = 0;
  
  public int getLast()
  {
    return m_last;
  }
  
  public void setLast(int last)
  {
    m_last = last;
  }
  
  
  private int m_blocksize;

  
  Node m_map[];

  
  protected int m_firstFree = 0;

  
  private int m_mapSize;  

  
  public Object clone() throws CloneNotSupportedException
  {

    NodeSet clone = (NodeSet) super.clone();

    if ((null != this.m_map) && (this.m_map == clone.m_map))
    {
      clone.m_map = new Node[this.m_map.length];

      System.arraycopy(this.m_map, 0, clone.m_map, 0, this.m_map.length);
    }

    return clone;
  }

  
  public int size()
  {
    return m_firstFree;
  }

  
  public void addElement(Node value)
  {
    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if ((m_firstFree + 1) >= m_mapSize)
    {
      if (null == m_map)
      {
        m_map = new Node[m_blocksize];
        m_mapSize = m_blocksize;
      }
      else
      {
        m_mapSize += m_blocksize;

        Node newMap[] = new Node[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

        m_map = newMap;
      }
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final void push(Node value)
  {

    int ff = m_firstFree;

    if ((ff + 1) >= m_mapSize)
    {
      if (null == m_map)
      {
        m_map = new Node[m_blocksize];
        m_mapSize = m_blocksize;
      }
      else
      {
        m_mapSize += m_blocksize;

        Node newMap[] = new Node[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, ff + 1);

        m_map = newMap;
      }
    }

    m_map[ff] = value;

    ff++;

    m_firstFree = ff;
  }

  
  public final Node pop()
  {

    m_firstFree--;

    Node n = m_map[m_firstFree];

    m_map[m_firstFree] = null;

    return n;
  }

  
  public final Node popAndTop()
  {

    m_firstFree--;

    m_map[m_firstFree] = null;

    return (m_firstFree == 0) ? null : m_map[m_firstFree - 1];
  }

  
  public final void popQuick()
  {

    m_firstFree--;

    m_map[m_firstFree] = null;
  }

  
  public final Node peepOrNull()
  {
    return ((null != m_map) && (m_firstFree > 0))
           ? m_map[m_firstFree - 1] : null;
  }

  
  public final void pushPair(Node v1, Node v2)
  {

    if (null == m_map)
    {
      m_map = new Node[m_blocksize];
      m_mapSize = m_blocksize;
    }
    else
    {
      if ((m_firstFree + 2) >= m_mapSize)
      {
        m_mapSize += m_blocksize;

        Node newMap[] = new Node[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, m_firstFree);

        m_map = newMap;
      }
    }

    m_map[m_firstFree] = v1;
    m_map[m_firstFree + 1] = v2;
    m_firstFree += 2;
  }

  
  public final void popPair()
  {

    m_firstFree -= 2;
    m_map[m_firstFree] = null;
    m_map[m_firstFree + 1] = null;
  }

  
  public final void setTail(Node n)
  {
    m_map[m_firstFree - 1] = n;
  }

  
  public final void setTailSub1(Node n)
  {
    m_map[m_firstFree - 2] = n;
  }

  
  public final Node peepTail()
  {
    return m_map[m_firstFree - 1];
  }

  
  public final Node peepTailSub1()
  {
    return m_map[m_firstFree - 2];
  }

  
  public void insertElementAt(Node value, int at)
  {
    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null == m_map)
    {
      m_map = new Node[m_blocksize];
      m_mapSize = m_blocksize;
    }
    else if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      Node newMap[] = new Node[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    if (at <= (m_firstFree - 1))
    {
      System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);
    }

    m_map[at] = value;

    m_firstFree++;
  }

  
  public void appendNodes(NodeSet nodes)
  {

    int nNodes = nodes.size();

    if (null == m_map)
    {
      m_mapSize = nNodes + m_blocksize;
      m_map = new Node[m_mapSize];
    }
    else if ((m_firstFree + nNodes) >= m_mapSize)
    {
      m_mapSize += (nNodes + m_blocksize);

      Node newMap[] = new Node[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + nNodes);

      m_map = newMap;
    }

    System.arraycopy(nodes.m_map, 0, m_map, m_firstFree, nNodes);

    m_firstFree += nNodes;
  }

  
  public void removeAllElements()
  {

    if (null == m_map)
      return;

    for (int i = 0; i < m_firstFree; i++)
    {
      m_map[i] = null;
    }

    m_firstFree = 0;
  }

  
  public boolean removeElement(Node s)
  {
    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null == m_map)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      Node node = m_map[i];

      if ((null != node) && node.equals(s))
      {
        if (i > m_firstFree)
          System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
        else
          m_map[i] = null;

        m_firstFree--;

        return true;
      }
    }

    return false;
  }

  
  public void removeElementAt(int i)
  {

    if (null == m_map)
      return;

    if (i > m_firstFree)
      System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
    else
      m_map[i] = null;
  }

  
  public void setElementAt(Node node, int index)
  {
    if (!m_mutable)
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESET_NOT_MUTABLE, null)); 

    if (null == m_map)
    {
      m_map = new Node[m_blocksize];
      m_mapSize = m_blocksize;
    }

    m_map[index] = node;
  }

  
  public Node elementAt(int i)
  {

    if (null == m_map)
      return null;

    return m_map[i];
  }

  
  public boolean contains(Node s)
  {
    runTo(-1);

    if (null == m_map)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      Node node = m_map[i];

      if ((null != node) && node.equals(s))
        return true;
    }

    return false;
  }

  
  public int indexOf(Node elem, int index)
  {
    runTo(-1);

    if (null == m_map)
      return -1;

    for (int i = index; i < m_firstFree; i++)
    {
      Node node = m_map[i];

      if ((null != node) && node.equals(elem))
        return i;
    }

    return -1;
  }

  
  public int indexOf(Node elem)
  {
    runTo(-1);

    if (null == m_map)
      return -1;

    for (int i = 0; i < m_firstFree; i++)
    {
      Node node = m_map[i];

      if ((null != node) && node.equals(elem))
        return i;
    }

    return -1;
  }

}
"
org.apache.xalan.xsltc.compiler.Parser,75,1,1,96,196,2497,86,23,59,0.933783784,3247,1.0,9,0.0,0.093333333,0,0,41.89333333,13,2.2667,1,"

package org.apache.xalan.xsltc.compiler;

import java.io.*;
import java.net.URL;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Dictionary;
import java.util.Enumeration;
import java.util.StringTokenizer;
import java.util.Stack;
import java.net.MalformedURLException;

import javax.xml.parsers.*;

import org.w3c.dom.*;
import org.xml.sax.*;

import java_cup.runtime.Symbol;

import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.runtime.AttributeList;

public class Parser implements Constants, ContentHandler {

    private static final String XSL = ""xsl"";            
    private static final String TRANSLET = ""translet""; 

    private Locator _locator = null;

    private XSLTC _xsltc;             
    private XPathParser _xpathParser; 
    private Vector _errors;           
    private Vector _warnings;         

    private Hashtable   _instructionClasses; 
    private Hashtable   _instructionAttrs;;  
    private Hashtable   _qNames;
    private Hashtable   _namespaces;
    private QName       _useAttributeSets;
    private QName       _excludeResultPrefixes;
    private QName       _extensionElementPrefixes;
    private Hashtable   _variableScope;
    private Stylesheet  _currentStylesheet;
    private SymbolTable _symbolTable; 
    private Output      _output = null;
    private Template    _template;    

    private boolean     _rootNamespaceDef = false; 

    private SyntaxTreeNode _root = null;

    private String _target;

    private int _currentImportPrecedence = 1;

    public Parser(XSLTC xsltc) {
	_xsltc = xsltc;
    }

    public void init() {
	_qNames              = new Hashtable(512);
	_namespaces          = new Hashtable();
	_instructionClasses  = new Hashtable();
	_instructionAttrs    = new Hashtable();
	_variableScope       = new Hashtable();
	_template            = null;
	_errors              = new Vector();
	_warnings            = new Vector();
	_symbolTable         = new SymbolTable();
	_xpathParser         = new XPathParser(this);
	_currentStylesheet   = null;
	_currentImportPrecedence = 1;
	
	initStdClasses();
	initInstructionAttrs();
	initExtClasses();
	initSymbolTable();
	
	_useAttributeSets =
	    getQName(XSLT_URI, XSL, ""use-attribute-sets"");
	_excludeResultPrefixes =
	    getQName(XSLT_URI, XSL, ""exclude-result-prefixes"");
	_extensionElementPrefixes =
	    getQName(XSLT_URI, XSL, ""extension-element-prefixes"");
    }

    public void setOutput(Output output) {
	if (_output != null) {
	    if (_output.getImportPrecedence() <= output.getImportPrecedence()) {
		_output.disable();
		_output = output;
	    }
	    else {
		output.disable();
	    }
	}
	else {
	    _output = output;
	}
    }

    public Output getOutput() {
	return _output;
    }

    public Properties getOutputProperties() {
	return getTopLevelStylesheet().getOutputProperties();
    }

    public void addVariable(Variable var) {
	addVariableOrParam(var);
    }

    public void addParameter(Param param) {
	addVariableOrParam(param);
    }

    private void addVariableOrParam(VariableBase var) {
	Object existing = _variableScope.get(var.getName());
	if (existing != null) {
	    if (existing instanceof Stack) {
		Stack stack = (Stack)existing;
		stack.push(var);
	    }
	    else if (existing instanceof VariableBase) {
		Stack stack = new Stack();
		stack.push(existing);
		stack.push(var);
		_variableScope.put(var.getName(), stack);
	    }
	}
	else {
	    _variableScope.put(var.getName(), var);
	}
    }

    public void removeVariable(QName name) {
	Object existing = _variableScope.get(name);
	if (existing instanceof Stack) {
	    Stack stack = (Stack)existing;
	    if (!stack.isEmpty()) stack.pop();
	    if (!stack.isEmpty()) return;
	}
	_variableScope.remove(name);
    }

    public VariableBase lookupVariable(QName name) {
	Object existing = _variableScope.get(name);
	if (existing instanceof VariableBase) {
	    return((VariableBase)existing);
	}
	else if (existing instanceof Stack) {
	    Stack stack = (Stack)existing;
	    return((VariableBase)stack.peek());
	}
	return(null);
    }

    public void setXSLTC(XSLTC xsltc) {
	_xsltc = xsltc;
    }

    public XSLTC getXSLTC() {
	return _xsltc;
    }

    public int getCurrentImportPrecedence() {
	return _currentImportPrecedence;
    }
    
    public int getNextImportPrecedence() {
	return ++_currentImportPrecedence;
    }

    public void setCurrentStylesheet(Stylesheet stylesheet) {
	_currentStylesheet = stylesheet;
    }

    public Stylesheet getCurrentStylesheet() {
	return _currentStylesheet;
    }
    
    public Stylesheet getTopLevelStylesheet() {
	return _xsltc.getStylesheet();
    }

    public QName getQNameSafe(final String stringRep) {
	
	final int colon = stringRep.lastIndexOf(':');
	if (colon != -1) {
	    final String prefix = stringRep.substring(0, colon);
	    final String localname = stringRep.substring(colon + 1);
	    String namespace = null;
	    
	    
	    if (prefix.equals(XMLNS_PREFIX) == false) {
		namespace = _symbolTable.lookupNamespace(prefix);
		if (namespace == null) namespace = EMPTYSTRING;
	    }
	    return getQName(namespace, prefix, localname);
	}
	else {
	    final String uri = stringRep.equals(XMLNS_PREFIX) ? null
		: _symbolTable.lookupNamespace(EMPTYSTRING);
	    return getQName(uri, null, stringRep);
	}
    }
    
    public QName getQName(final String stringRep) {
	return getQName(stringRep, true, false);    
    }

    public QName getQNameIgnoreDefaultNs(final String stringRep) {
	return getQName(stringRep, true, true);
    }

    public QName getQName(final String stringRep, boolean reportError) {
	return getQName(stringRep, reportError, false);
    }

    private QName getQName(final String stringRep, boolean reportError,
	boolean ignoreDefaultNs) 
    {
	
	final int colon = stringRep.lastIndexOf(':');
	if (colon != -1) {
	    final String prefix = stringRep.substring(0, colon);
	    final String localname = stringRep.substring(colon + 1);
	    String namespace = null;
	    
	    
	    if (prefix.equals(XMLNS_PREFIX) == false) {
		namespace = _symbolTable.lookupNamespace(prefix);
		if (namespace == null && reportError) {
		    final int line = _locator.getLineNumber();
		    ErrorMsg err = new ErrorMsg(ErrorMsg.NAMESPACE_UNDEF_ERR,
						line, prefix);
		    reportError(ERROR, err);
		}
	    }
	    return getQName(namespace, prefix, localname);
	}
	else {
	    if (stringRep.equals(XMLNS_PREFIX)) {
		ignoreDefaultNs = true;
	    }
	    final String defURI = ignoreDefaultNs ? null 
				  : _symbolTable.lookupNamespace(EMPTYSTRING);
	    return getQName(defURI, null, stringRep);
	}
    }

    public QName getQName(String namespace, String prefix, String localname) {
	if (namespace == null || namespace.equals(EMPTYSTRING)) {
	    QName name = (QName)_qNames.get(localname);
	    if (name == null) {
		name = new QName(null, prefix, localname);
		_qNames.put(localname, name);
	    }
	    return name;
	}
	else {
	    Dictionary space = (Dictionary)_namespaces.get(namespace);
	    if (space == null) {
		final QName name = new QName(namespace, prefix, localname);
		_namespaces.put(namespace, space = new Hashtable());
		space.put(localname, name);
		return name;
	    }
	    else {
		QName name = (QName)space.get(localname);
		if (name == null) {
		    name = new QName(namespace, prefix, localname);
		    space.put(localname, name);
		}
		return name;
	    }
	}
    }
    
    public QName getQName(String scope, String name) {
	return getQName(scope + name);
    }

    public QName getQName(QName scope, QName name) {
	return getQName(scope.toString() + name.toString());
    }

    public QName getUseAttributeSets() {
	return _useAttributeSets;
    }

    public QName getExtensionElementPrefixes() {
	return _extensionElementPrefixes;
    }

    public QName getExcludeResultPrefixes() {
	return _excludeResultPrefixes;
    }
    
    
    public Stylesheet makeStylesheet(SyntaxTreeNode element) 
	throws CompilerException {
	try {
	    Stylesheet stylesheet;

	    if (element instanceof Stylesheet) {
		stylesheet = (Stylesheet)element;
	    }
	    else {
		stylesheet = new Stylesheet();
		stylesheet.setSimplified();
		stylesheet.addElement(element);
		stylesheet.setAttributes(element.getAttributes());

		
		if (element.lookupNamespace(EMPTYSTRING) == null) {
		    element.addPrefixMapping(EMPTYSTRING, EMPTYSTRING);
		}
	    }
	    stylesheet.setParser(this);
	    return stylesheet;
	}
	catch (ClassCastException e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.NOT_STYLESHEET_ERR, element);
	    throw new CompilerException(err.toString());
	}
    }
    
    
    public void createAST(Stylesheet stylesheet) {
	try {
	    if (stylesheet != null) {
		stylesheet.parseContents(this);
		final int precedence = stylesheet.getImportPrecedence();
		final Enumeration elements = stylesheet.elements();
		while (elements.hasMoreElements()) {
		    Object child = elements.nextElement();
		    if (child instanceof Text) {
			final int l = _locator.getLineNumber();
			ErrorMsg err =
			    new ErrorMsg(ErrorMsg.ILLEGAL_TEXT_NODE_ERR,l,null);
			reportError(ERROR, err);
		    }
		}
		if (!errorsFound()) {
		    stylesheet.typeCheck(_symbolTable);
		}
	    }
	}
	catch (TypeCheckError e) {
	    reportError(ERROR, new ErrorMsg(e.toString()));
	}
    }

    
    public SyntaxTreeNode parse(XMLReader reader, InputSource input) {
	try {
	    
	    reader.setContentHandler(this);
	    reader.parse(input);
	    
	    return (SyntaxTreeNode)getStylesheet(_root);	
	}
	catch (IOException e) {
	    if (_xsltc.debug()) e.printStackTrace();
	    reportError(ERROR,new ErrorMsg(e.getMessage()));
	}
	catch (SAXException e) {
	    Throwable ex = e.getException();
	    if (_xsltc.debug()) {
		e.printStackTrace();
		if (ex != null) ex.printStackTrace();
	    }
	    reportError(ERROR, new ErrorMsg(e.getMessage()));
	}
	catch (CompilerException e) {
	    if (_xsltc.debug()) e.printStackTrace();
	    reportError(ERROR, new ErrorMsg(e.getMessage()));
	}
	catch (Exception e) {
	    if (_xsltc.debug()) e.printStackTrace();
	    reportError(ERROR, new ErrorMsg(e.getMessage()));
	}
	return null;
    }

    
    public SyntaxTreeNode parse(InputSource input) {
	try {
	    
	    final SAXParserFactory factory = SAXParserFactory.newInstance();
	    try {
		factory.setFeature(Constants.NAMESPACE_FEATURE,true);
	    }
	    catch (Exception e) {
		factory.setNamespaceAware(true);
	    }
	    final SAXParser parser = factory.newSAXParser();
	    final XMLReader reader = parser.getXMLReader();
	    return(parse(reader, input));
	}
	catch (ParserConfigurationException e) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.SAX_PARSER_CONFIG_ERR);
	    reportError(ERROR, err);
	}
	catch (SAXParseException e){
	    reportError(ERROR, new ErrorMsg(e.getMessage(),e.getLineNumber()));
	}
	catch (SAXException e) {
	    reportError(ERROR, new ErrorMsg(e.getMessage()));
	}
	return null;
    }

    public SyntaxTreeNode getDocumentRoot() {
	return _root;
    }

    private String _PImedia = null;
    private String _PItitle = null;
    private String _PIcharset = null;

    
    protected void setPIParameters(String media, String title, String charset) {
	_PImedia = media;
	_PItitle = title;
	_PIcharset = charset;
    }

    
    private SyntaxTreeNode getStylesheet(SyntaxTreeNode root)
	throws CompilerException {

	
	
	if (_target == null) {
	    if (!_rootNamespaceDef) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.MISSING_XSLT_URI_ERR);
		throw new CompilerException(msg.toString());
	    }
	    return(root);
	}

	
	if (_target.charAt(0) == '#') {
	    SyntaxTreeNode element = findStylesheet(root, _target.substring(1));
	    if (element == null) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.MISSING_XSLT_TARGET_ERR,
					    _target, root);
		throw new CompilerException(msg.toString());
	    }
	    return(element);
	}
	else {
	    return(loadExternalStylesheet(_target));
	}
    }

    
    private SyntaxTreeNode findStylesheet(SyntaxTreeNode root, String href) {

	if (root == null) return null;

	if (root instanceof Stylesheet) {
	    String id = root.getAttribute(""id"");
	    if (id.equals(href)) return root;
	}
	Vector children = root.getContents();
	if (children != null) {
	    final int count = children.size();
	    for (int i = 0; i < count; i++) {
		SyntaxTreeNode child = (SyntaxTreeNode)children.elementAt(i);
		SyntaxTreeNode node = findStylesheet(child, href);
		if (node != null) return node;
	    }
	}
	return null;	
    }

    
    private SyntaxTreeNode loadExternalStylesheet(String location)
	throws CompilerException {

	InputSource source;

	
	if ((new File(location)).exists())
	    source = new InputSource(""file:""+location);
	else
	    source = new InputSource(location);

	SyntaxTreeNode external = (SyntaxTreeNode)parse(source);
	return(external);
    }

    private void initAttrTable(String elementName, String[] attrs) {
	_instructionAttrs.put(getQName(XSLT_URI, XSL, elementName),
				attrs);
    }

    private void initInstructionAttrs() {
	initAttrTable(""template"", 
	    new String[] {""match"", ""name"", ""priority"", ""mode""});
	initAttrTable(""stylesheet"", 
	    new String[] {""id"", ""version"", ""extension-element-prefixes"",
		""exclude-result-prefixes""});
	initAttrTable(""transform"",
	    new String[] {""id"", ""version"", ""extension-element-prefixes"",
		""exclude-result-prefixes""});
	initAttrTable(""text"", new String[] {""disable-output-escaping""}); 
	initAttrTable(""if"", new String[] {""test""}); 
	initAttrTable(""choose"", new String[] {}); 
	initAttrTable(""when"", new String[] {""test""}); 
	initAttrTable(""otherwise"", new String[] {}); 
	initAttrTable(""for-each"", new String[] {""select""}); 
	initAttrTable(""message"", new String[] {""terminate""}); 
	initAttrTable(""number"", 
	    new String[] {""level"", ""count"", ""from"", ""value"", ""format"", ""lang"",
		""letter-value"", ""grouping-separator"", ""grouping-size""});
		initAttrTable(""comment"", new String[] {}); 
	initAttrTable(""copy"", new String[] {""use-attribute-sets""}); 
	initAttrTable(""copy-of"", new String[] {""select""}); 
	initAttrTable(""param"", new String[] {""name"", ""select""}); 
	initAttrTable(""with-param"", new String[] {""name"", ""select""}); 
	initAttrTable(""variable"", new String[] {""name"", ""select""}); 
	initAttrTable(""output"", 
	    new String[] {""method"", ""version"", ""encoding"", 
		""omit-xml-declaration"", ""standalone"", ""doctype-public"",
		""doctype-system"", ""cdata-section-elements"", ""indent"",
		""media-type""}); 
	initAttrTable(""sort"", 
	   new String[] {""select"", ""order"", ""case-order"", ""lang"", ""data-type""});
	initAttrTable(""key"", new String[] {""name"", ""match"", ""use""}); 
	initAttrTable(""fallback"", new String[] {}); 
	initAttrTable(""attribute"", new String[] {""name"", ""namespace""}); 
	initAttrTable(""attribute-set"", 
	    new String[] {""name"", ""use-attribute-sets""}); 
	initAttrTable(""value-of"", 
	    new String[] {""select"", ""disable-output-escaping""}); 
	initAttrTable(""element"", 
	    new String[] {""name"", ""namespace"", ""use-attribute-sets""}); 
	initAttrTable(""call-template"", new String[] {""name""}); 
	initAttrTable(""apply-templates"", new String[] {""select"", ""mode""}); 
	initAttrTable(""apply-imports"", new String[] {}); 
	initAttrTable(""decimal-format"", 
	    new String[] {""name"", ""decimal-separator"", ""grouping-separator"",
		""infinity"", ""minus-sign"", ""NaN"", ""percent"", ""per-mille"",
		""zero-digit"", ""digit"", ""pattern-separator""}); 
	initAttrTable(""import"", new String[] {""href""}); 
	initAttrTable(""include"", new String[] {""href""}); 
	initAttrTable(""strip-space"", new String[] {""elements""}); 
	initAttrTable(""preserve-space"", new String[] {""elements""}); 
	initAttrTable(""processing-instruction"", new String[] {""name""}); 
	initAttrTable(""namespace-alias"", 
	   new String[] {""stylesheet-prefix"", ""result-prefix""}); 
    }



    
    private void initStdClasses() {
	initStdClass(""template"", ""Template"");
	initStdClass(""stylesheet"", ""Stylesheet"");
	initStdClass(""transform"", ""Stylesheet"");
	initStdClass(""text"", ""Text"");
	initStdClass(""if"", ""If"");
	initStdClass(""choose"", ""Choose"");
	initStdClass(""when"", ""When"");
	initStdClass(""otherwise"", ""Otherwise"");
	initStdClass(""for-each"", ""ForEach"");
	initStdClass(""message"", ""Message"");
	initStdClass(""number"", ""Number"");
	initStdClass(""comment"", ""Comment"");
	initStdClass(""copy"", ""Copy"");
	initStdClass(""copy-of"", ""CopyOf"");
	initStdClass(""param"", ""Param"");
	initStdClass(""with-param"", ""WithParam"");
	initStdClass(""variable"", ""Variable"");
	initStdClass(""output"", ""Output"");
	initStdClass(""sort"", ""Sort"");
	initStdClass(""key"", ""Key"");
	initStdClass(""fallback"", ""Fallback"");
	initStdClass(""attribute"", ""XslAttribute"");
	initStdClass(""attribute-set"", ""AttributeSet"");
	initStdClass(""value-of"", ""ValueOf"");
	initStdClass(""element"", ""XslElement"");
	initStdClass(""call-template"", ""CallTemplate"");
	initStdClass(""apply-templates"", ""ApplyTemplates"");
	initStdClass(""apply-imports"", ""ApplyImports"");
	initStdClass(""decimal-format"", ""DecimalFormatting"");
	initStdClass(""import"", ""Import"");
	initStdClass(""include"", ""Include"");
	initStdClass(""strip-space"", ""Whitespace"");
	initStdClass(""preserve-space"", ""Whitespace"");
	initStdClass(""processing-instruction"", ""ProcessingInstruction"");
	initStdClass(""namespace-alias"", ""NamespaceAlias"");
    }
    
    private void initStdClass(String elementName, String className) {
	_instructionClasses.put(getQName(XSLT_URI, XSL, elementName),
				COMPILER_PACKAGE + '.' + className);
    }

    public boolean elementSupported(String namespace, String localName) {
	return(_instructionClasses.get(getQName(namespace, XSL, localName)) != null);
    }

    public boolean functionSupported(String fname) {
	return(_symbolTable.lookupPrimop(fname) != null);
    }

    private void initExtClasses() {
	initExtClass(""output"", ""TransletOutput"");
    }

    private void initExtClass(String elementName, String className) {
	_instructionClasses.put(getQName(TRANSLET_URI, TRANSLET, elementName),
				COMPILER_PACKAGE + '.' + className);
    }

    
    private void initSymbolTable() {
	MethodType I_V  = new MethodType(Type.Int, Type.Void);
	MethodType I_R  = new MethodType(Type.Int, Type.Real);
	MethodType I_S  = new MethodType(Type.Int, Type.String);
	MethodType I_D  = new MethodType(Type.Int, Type.NodeSet);
	MethodType R_I  = new MethodType(Type.Real, Type.Int);
	MethodType R_V  = new MethodType(Type.Real, Type.Void);
	MethodType R_R  = new MethodType(Type.Real, Type.Real);
	MethodType R_D  = new MethodType(Type.Real, Type.NodeSet);
	MethodType R_O  = new MethodType(Type.Real, Type.Reference);
	MethodType I_I  = new MethodType(Type.Int, Type.Int);
 	MethodType D_O  = new MethodType(Type.NodeSet, Type.Reference);
	MethodType D_V  = new MethodType(Type.NodeSet, Type.Void);
	MethodType D_S  = new MethodType(Type.NodeSet, Type.String);
	MethodType D_D  = new MethodType(Type.NodeSet, Type.NodeSet);
	MethodType A_V  = new MethodType(Type.Node, Type.Void);
	MethodType S_V  = new MethodType(Type.String, Type.Void);
	MethodType S_S  = new MethodType(Type.String, Type.String);
	MethodType S_A  = new MethodType(Type.String, Type.Node);
	MethodType S_D  = new MethodType(Type.String, Type.NodeSet);
	MethodType S_O  = new MethodType(Type.String, Type.Reference);
	MethodType B_O  = new MethodType(Type.Boolean, Type.Reference);
	MethodType B_V  = new MethodType(Type.Boolean, Type.Void);
	MethodType B_B  = new MethodType(Type.Boolean, Type.Boolean);
	MethodType B_S  = new MethodType(Type.Boolean, Type.String);
	MethodType D_X  = new MethodType(Type.NodeSet, Type.Object);
	MethodType R_RR = new MethodType(Type.Real, Type.Real, Type.Real);
	MethodType I_II = new MethodType(Type.Int, Type.Int, Type.Int);
	MethodType B_RR = new MethodType(Type.Boolean, Type.Real, Type.Real);
	MethodType B_II = new MethodType(Type.Boolean, Type.Int, Type.Int);
	MethodType S_SS = new MethodType(Type.String, Type.String, Type.String);
	MethodType S_DS = new MethodType(Type.String, Type.Real, Type.String);
	MethodType S_SR = new MethodType(Type.String, Type.String, Type.Real);

	MethodType D_SS =
	    new MethodType(Type.NodeSet, Type.String, Type.String);
	MethodType D_SD = 
	    new MethodType(Type.NodeSet, Type.String, Type.NodeSet);
	MethodType B_BB =
	    new MethodType(Type.Boolean, Type.Boolean, Type.Boolean);
	MethodType B_SS =
	    new MethodType(Type.Boolean, Type.String, Type.String);
	MethodType S_SD =
	    new MethodType(Type.String, Type.String, Type.NodeSet);
	MethodType S_DSS =
	    new MethodType(Type.String, Type.Real, Type.String, Type.String);
	MethodType S_SRR =
	    new MethodType(Type.String, Type.String, Type.Real, Type.Real);
	MethodType S_SSS =
	    new MethodType(Type.String, Type.String, Type.String, Type.String);

	

	

	_symbolTable.addPrimop(""current"", A_V);
	_symbolTable.addPrimop(""last"", I_V);
	_symbolTable.addPrimop(""position"", I_V);
	_symbolTable.addPrimop(""true"", B_V);
	_symbolTable.addPrimop(""false"", B_V);
	_symbolTable.addPrimop(""not"", B_B);
	_symbolTable.addPrimop(""name"", S_V);
	_symbolTable.addPrimop(""name"", S_A);
	_symbolTable.addPrimop(""generate-id"", S_V);
	_symbolTable.addPrimop(""generate-id"", S_A);
	_symbolTable.addPrimop(""ceiling"", R_R);
	_symbolTable.addPrimop(""floor"", R_R);
	_symbolTable.addPrimop(""round"", R_R);
	_symbolTable.addPrimop(""contains"", B_SS);
	_symbolTable.addPrimop(""number"", R_O);
	_symbolTable.addPrimop(""number"", R_V);
	_symbolTable.addPrimop(""boolean"", B_O);
	_symbolTable.addPrimop(""string"", S_O);
	_symbolTable.addPrimop(""string"", S_V);
	_symbolTable.addPrimop(""translate"", S_SSS);
	_symbolTable.addPrimop(""string-length"", I_V);
	_symbolTable.addPrimop(""string-length"", I_S);
	_symbolTable.addPrimop(""starts-with"", B_SS);
	_symbolTable.addPrimop(""format-number"", S_DS);
	_symbolTable.addPrimop(""format-number"", S_DSS);
	_symbolTable.addPrimop(""unparsed-entity-uri"", S_S);
	_symbolTable.addPrimop(""key"", D_SS);
	_symbolTable.addPrimop(""key"", D_SD);
	_symbolTable.addPrimop(""id"", D_S);
	_symbolTable.addPrimop(""id"", D_D);
	_symbolTable.addPrimop(""namespace-uri"", S_V);
	_symbolTable.addPrimop(""function-available"", B_S);
	_symbolTable.addPrimop(""element-available"", B_S);
	_symbolTable.addPrimop(""document"", D_S);
	_symbolTable.addPrimop(""document"", D_V);

	
	_symbolTable.addPrimop(""count"", I_D);
	_symbolTable.addPrimop(""sum"", R_D);
	_symbolTable.addPrimop(""local-name"", S_V);
	_symbolTable.addPrimop(""local-name"", S_D);
	_symbolTable.addPrimop(""namespace-uri"", S_V);
	_symbolTable.addPrimop(""namespace-uri"", S_D);
	_symbolTable.addPrimop(""substring"", S_SR);
	_symbolTable.addPrimop(""substring"", S_SRR);
	_symbolTable.addPrimop(""substring-after"", S_SS);
	_symbolTable.addPrimop(""substring-before"", S_SS);
	_symbolTable.addPrimop(""normalize-space"", S_V);
	_symbolTable.addPrimop(""normalize-space"", S_S);
	_symbolTable.addPrimop(""system-property"", S_S);

	
	_symbolTable.addPrimop(""nodeset"", D_X);

	
	_symbolTable.addPrimop(""+"", R_RR);	
	_symbolTable.addPrimop(""-"", R_RR);	
	_symbolTable.addPrimop(""*"", R_RR);	
	_symbolTable.addPrimop(""/"", R_RR);	
	_symbolTable.addPrimop(""%"", R_RR);	

	
	
	_symbolTable.addPrimop(""+"", I_II);	
	_symbolTable.addPrimop(""-"", I_II);	
	_symbolTable.addPrimop(""*"", I_II);	

	 
	_symbolTable.addPrimop(""<"",  B_RR);	
	_symbolTable.addPrimop(""<="", B_RR);	
	_symbolTable.addPrimop("">"",  B_RR);	
	_symbolTable.addPrimop("">="", B_RR);	

	
	_symbolTable.addPrimop(""<"",  B_II);	
	_symbolTable.addPrimop(""<="", B_II);	
	_symbolTable.addPrimop("">"",  B_II);	
	_symbolTable.addPrimop("">="", B_II);	

	
	_symbolTable.addPrimop(""<"",  B_BB);	
	_symbolTable.addPrimop(""<="", B_BB);	
	_symbolTable.addPrimop("">"",  B_BB);	
	_symbolTable.addPrimop("">="", B_BB);	

	
	_symbolTable.addPrimop(""or"", B_BB);	
	_symbolTable.addPrimop(""and"", B_BB);	

	
	_symbolTable.addPrimop(""u-"", R_R);	
	_symbolTable.addPrimop(""u-"", I_I);	
    }

    public SymbolTable getSymbolTable() {
	return _symbolTable;
    }

    public Template getTemplate() {
	return _template;
    }

    public void setTemplate(Template template) {
	_template = template;
    }

    private int _templateIndex = 0;

    public int getTemplateIndex() {
	return(_templateIndex++);
    }

    

    private boolean versionIsOne = true;

    public SyntaxTreeNode makeInstance(String uri, String prefix, 
	String local, Attributes attributes)
    {
	SyntaxTreeNode node = null;
	QName  qname = getQName(uri, prefix, local);
	String className = (String)_instructionClasses.get(qname);

	if (className != null) {
	    try {
		final Class clazz = Class.forName(className);
		node = (SyntaxTreeNode)clazz.newInstance();
		node.setQName(qname);
		node.setParser(this);
		if (_locator != null) {
		    node.setLineNumber(_locator.getLineNumber());
		}
		if (node instanceof Stylesheet) {
		    _xsltc.setStylesheet((Stylesheet)node);
		}
		checkForSuperfluousAttributes(node, attributes);
	    }
	    catch (ClassNotFoundException e) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR, node);
		reportError(ERROR, err);
	    }
	    catch (Exception e) {
		ErrorMsg err = new ErrorMsg(ErrorMsg.INTERNAL_ERR,
					    e.getMessage(), node);
		reportError(FATAL, err);
	    }
	}
	else {
	    if (uri != null) {
		
		if (uri.equals(XSLT_URI)) {
		    node = new UnsupportedElement(uri, prefix, local);
		    UnsupportedElement element = (UnsupportedElement)node;
		    ErrorMsg msg = new ErrorMsg(ErrorMsg.UNSUPPORTED_XSL_ERR,
						_locator.getLineNumber(),local);
		    element.setErrorMessage(msg);
		}
		
		else if (uri.equals(TRANSLET_URI)) {
		    node = new UnsupportedElement(uri, prefix, local);
		    UnsupportedElement element = (UnsupportedElement)node;
		    ErrorMsg msg = new ErrorMsg(ErrorMsg.UNSUPPORTED_EXT_ERR,
						_locator.getLineNumber(),local);
		    element.setErrorMessage(msg);
		}
		
		else {
		    Stylesheet sheet = _xsltc.getStylesheet();
		    if ((sheet != null) && (sheet.isExtension(uri))) {
			if (sheet != (SyntaxTreeNode)_parentStack.peek()) {
			    node = new UnsupportedElement(uri, prefix, local);
			    UnsupportedElement elem = (UnsupportedElement)node;
			    ErrorMsg msg =
				new ErrorMsg(ErrorMsg.UNSUPPORTED_EXT_ERR,
					     _locator.getLineNumber(),
					     prefix+"":""+local);
			    elem.setErrorMessage(msg);
			}
		    }
		}
	    }
	    if (node == null) node = new LiteralElement();
	}
	if ((node != null) && (node instanceof LiteralElement)) {
	    ((LiteralElement)node).setQName(qname);
	}
	return(node);
    }

    
    private void checkForSuperfluousAttributes(SyntaxTreeNode node, 
	Attributes attrs)
    {
	QName qname = node.getQName();
	boolean isStylesheet = (node instanceof Stylesheet); 
        String[] legal = (String[]) _instructionAttrs.get(qname);
	if (versionIsOne && legal != null) {
	    int j;
	    final int n = attrs.getLength();

	    for (int i = 0; i < n; i++) {
	        final String attrQName = attrs.getQName(i);

	        if (isStylesheet && attrQName.equals(""version"")) {
	            versionIsOne = attrs.getValue(i).equals(""1.0"");
	        }

		
	        if (attrQName.startsWith(""xml"") ||
		    attrQName.indexOf(':') > 0) continue;

	        for (j = 0; j < legal.length; j++) {
	            if (attrQName.equalsIgnoreCase(legal[j])) {
		        break;
		    }	
	        }
	        if (j == legal.length) {
	            final ErrorMsg err = 
		        new ErrorMsg(ErrorMsg.ILLEGAL_ATTRIBUTE_ERR, 
				attrQName, node);
		    reportError(WARNING, err);
	        }
	    }
        }	
    }


    
    public Expression parseExpression(SyntaxTreeNode parent, String exp) {
	return (Expression)parseTopLevel(parent, ""<EXPRESSION>""+exp, null);
    }

    
    public Expression parseExpression(SyntaxTreeNode parent,
				      String attr, String def) {
	
        String exp = parent.getAttribute(attr);
	
        if ((exp.length() == 0) && (def != null)) exp = def;
	
        return (Expression)parseTopLevel(parent, ""<EXPRESSION>""+exp, exp);
    }

    
    public Pattern parsePattern(SyntaxTreeNode parent, String pattern) {
	return (Pattern)parseTopLevel(parent, ""<PATTERN>""+pattern, pattern);
    }

    
    public Pattern parsePattern(SyntaxTreeNode parent,
				String attr, String def) {
	
        String pattern = parent.getAttribute(attr);
	
	if ((pattern.length() == 0) && (def != null)) pattern = def;
	
        return (Pattern)parseTopLevel(parent, ""<PATTERN>""+pattern, pattern);
    }

    
    private SyntaxTreeNode parseTopLevel(SyntaxTreeNode parent, String text,
					 String expression) {
	int line = 0;
	if (_locator != null) line = _locator.getLineNumber();

	try {
	    _xpathParser.setScanner(new XPathLexer(new StringReader(text)));
	    Symbol result = _xpathParser.parse(expression, line);
	    if (result != null) {
		final SyntaxTreeNode node = (SyntaxTreeNode)result.value;
		if (node != null) {
		    node.setParser(this);
		    node.setParent(parent);
		    node.setLineNumber(line);
		    return node;
		}
	    } 
	    reportError(ERROR, new ErrorMsg(ErrorMsg.XPATH_PARSER_ERR,
					    expression, parent));
	}
	catch (Exception e) {
	    if (_xsltc.debug()) e.printStackTrace();
	    reportError(ERROR, new ErrorMsg(ErrorMsg.XPATH_PARSER_ERR,
					    expression, parent));
	}

	
	SyntaxTreeNode.Dummy.setParser(this);
        return SyntaxTreeNode.Dummy; 
    }

    

    
    public boolean errorsFound() {
	return _errors.size() > 0;
    }

    
    public void printErrors() {
	final int size = _errors.size();
	if (size > 0) {
	    System.err.println(ErrorMsg.getCompileErrorMessage());
	    for (int i = 0; i < size; i++) {
		System.err.println(""  "" + _errors.elementAt(i));
	    }
	}
    }

    
    public void printWarnings() {
	final int size = _warnings.size();
	if (size > 0) {
	    System.err.println(ErrorMsg.getCompileWarningMessage());
	    for (int i = 0; i < size; i++) {
		System.err.println(""  "" + _warnings.elementAt(i));
	    }
	}
    }

    
    public void reportError(final int category, final ErrorMsg error) {
	switch (category) {
	case Constants.INTERNAL:
	    
	    
	    _errors.addElement(error);
	    break;
	case Constants.UNSUPPORTED:
	    
	    
	    _errors.addElement(error);
	    break;
	case Constants.FATAL:
	    
	    
	    _errors.addElement(error);
	    break;
	case Constants.ERROR:
	    
	    
	    _errors.addElement(error);
	    break;
	case Constants.WARNING:
	    
	    
	    _warnings.addElement(error);
	    break;
	}
    }

    public Vector getErrors() {
	return _errors;
    }

    public Vector getWarnings() {
	return _warnings;
    }

    

    private Stack _parentStack = null;
    private Hashtable _prefixMapping = null;

    
    public void startDocument() {
	_root = null;
	_target = null;
	_prefixMapping = null;
	_parentStack = new Stack();
    }

    
    public void endDocument() { }


    
    public void startPrefixMapping(String prefix, String uri) {
	if (_prefixMapping == null) {
	    _prefixMapping = new Hashtable();
	}
	_prefixMapping.put(prefix, uri);
    }

    
    public void endPrefixMapping(String prefix) { }

    
    public void startElement(String uri, String localname,
			     String qname, Attributes attributes) 
	throws SAXException {
	final int col = qname.lastIndexOf(':');
	final String prefix = (col == -1) ? null : qname.substring(0, col);

	SyntaxTreeNode element = makeInstance(uri, prefix, 
					localname, attributes);
	if (element == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ELEMENT_PARSE_ERR,
					prefix+':'+localname);
	    throw new SAXException(err.toString());
	}

	
	
	if (_root == null) {
	    if ((_prefixMapping == null) ||
		(_prefixMapping.containsValue(Constants.XSLT_URI) == false))
		_rootNamespaceDef = false;
	    else
		_rootNamespaceDef = true;
	    _root = element;
	}
	else {
	    SyntaxTreeNode parent = (SyntaxTreeNode)_parentStack.peek();
	    parent.addElement(element);
	    element.setParent(parent);
	}
	element.setAttributes((Attributes)new AttributeList(attributes));
	element.setPrefixMapping(_prefixMapping);
	
	if (element instanceof Stylesheet) {
	    
	    
	    
	    getSymbolTable().setCurrentNode(element);
	    ((Stylesheet)element).excludeExtensionPrefixes(this);
	}

	_prefixMapping = null;
	_parentStack.push(element);
    }

    
    public void endElement(String uri, String localname, String qname) {
	_parentStack.pop();
    }

    
    public void characters(char[] ch, int start, int length) {
	String string = new String(ch, start, length);
	SyntaxTreeNode parent = (SyntaxTreeNode)_parentStack.peek();

	if (string.length() == 0) return;

	
	
	if (parent instanceof Text) {
	    ((Text)parent).setText(string);
	    return;
	}

	
	if (parent instanceof Stylesheet) return;

	SyntaxTreeNode bro = parent.lastChild();
	if ((bro != null) && (bro instanceof Text)) {
	    Text text = (Text)bro;
	    if (!text.isTextElement()) {
		if ((length > 1) || ( ((int)ch[0]) < 0x100)) {
		    text.setText(string);
		    return;
		}
	    }
	}

	
	parent.addElement(new Text(string));
    }

    private String getTokenValue(String token) {
	final int start = token.indexOf('""');
	final int stop = token.lastIndexOf('""');
	return token.substring(start+1, stop);
    }

    
    public void processingInstruction(String name, String value) {
	
	if ((_target == null) && (name.equals(""xml-stylesheet""))) {

	    String href = null;    
	    String media = null;   
	    String title = null;   
	    String charset = null; 

	    
	    StringTokenizer tokens = new StringTokenizer(value);
	    while (tokens.hasMoreElements()) {
		String token = (String)tokens.nextElement();
		if (token.startsWith(""href""))
		    href = getTokenValue(token);
		else if (token.startsWith(""media""))
		    media = getTokenValue(token);
		else if (token.startsWith(""title""))
		    title = getTokenValue(token);
		else if (token.startsWith(""charset""))
		    charset = getTokenValue(token);
	    }

	    
	    
	    if ( ((_PImedia == null) || (_PImedia.equals(media))) &&
		 ((_PItitle == null) || (_PImedia.equals(title))) &&
		 ((_PIcharset == null) || (_PImedia.equals(charset))) ) {
		_target = href;
	    }
	}
    }

    
    public void ignorableWhitespace(char[] ch, int start, int length) { }

    
    public void skippedEntity(String name) { }

    
    public void setDocumentLocator(Locator locator) {
	_locator = locator;
    }

}
"
org.apache.xalan.xsltc.compiler.Mode,30,1,0,46,138,309,4,44,12,0.847549909,2953,1.0,6,0.0,0.1625,0,0,96.8,40,5.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Iterator;
import java.util.HashSet;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.bcel.util.*;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.DOM;


final class Mode implements Constants {

    
    private final QName _name;

    
    private final Stylesheet _stylesheet; 

    
    private final String _methodName;

    
    private Vector _templates; 

    
    private Vector _nodeGroup = null;

    
    private TestSeq _nodeTestSeq = null;

    
    private Vector _idxGroup = null;

    
    private TestSeq _idxTestSeq = null;

    
    private Vector[] _patternGroups;

    
    private TestSeq[] _testSeq;

    
    private Hashtable _preCompiled = new Hashtable();

    
    private Hashtable _neededTemplates = new Hashtable();

    
    private Hashtable _namedTemplates = new Hashtable();

    
    private Hashtable _templateIHs = new Hashtable();

    
    private Hashtable _templateILs = new Hashtable();

    
    private LocationPathPattern _rootPattern = null;

    
    private Hashtable _importLevels = null;

    
    private Hashtable _keys = null;

    
    private int _currentIndex;

    
    public Mode(QName name, Stylesheet stylesheet, String suffix) {
	_name = name;
	_stylesheet = stylesheet;
	_methodName = APPLY_TEMPLATES + suffix;
	_templates = new Vector();
	_patternGroups = new Vector[32];
    }

    
    public String functionName() {
	return _methodName;
    }

    public String functionName(int min, int max) {
	if (_importLevels == null) {
	    _importLevels = new Hashtable();
	}
	_importLevels.put(new Integer(max), new Integer(min));
	return _methodName + '_' + max;
    }

    
    public void addInstructionList(Pattern pattern, 
	InstructionList ilist) 
    {
	_preCompiled.put(pattern, ilist);
    }

    
    public InstructionList getInstructionList(Pattern pattern) {
	return (InstructionList) _preCompiled.get(pattern);
    }

    
    private String getClassName() {
	return _stylesheet.getClassName();
    }

    public Stylesheet getStylesheet() {
	return _stylesheet;
    }

    public void addTemplate(Template template) {
	_templates.addElement(template);
    }

    private Vector quicksort(Vector templates, int p, int r) {
	if (p < r) {
	    final int q = partition(templates, p, r);
	    quicksort(templates, p, q);
	    quicksort(templates, q + 1, r);
	}
	return templates;
    }
    
    private int partition(Vector templates, int p, int r) {
	final Template x = (Template)templates.elementAt(p);
	int i = p - 1;
	int j = r + 1;
	while (true) {
	    while (x.compareTo((Template)templates.elementAt(--j)) > 0);
	    while (x.compareTo((Template)templates.elementAt(++i)) < 0);
	    if (i < j) {
		templates.set(j, templates.set(i, templates.elementAt(j)));
	    }
	    else {
		return j;
	    }
	}
    }

    
    public void processPatterns(Hashtable keys) {
	_keys = keys;



	_templates = quicksort(_templates, 0, _templates.size() - 1);



	
	final Enumeration templates = _templates.elements();
	while (templates.hasMoreElements()) {
	    
	    final Template template = (Template)templates.nextElement();

	    
	    if (template.isNamed() && !template.disabled()) {
		_namedTemplates.put(template, this);
	    }

	    
	    final Pattern pattern = template.getPattern();
	    if (pattern != null) {
		flattenAlternative(pattern, template, keys);
	    }
	}
	prepareTestSequences();
    }

    
    private void flattenAlternative(Pattern pattern,
				    Template template,
				    Hashtable keys) {
	
	
	
	if (pattern instanceof IdKeyPattern) {
	    final IdKeyPattern idkey = (IdKeyPattern)pattern;
	    idkey.setTemplate(template);
	    if (_idxGroup == null) _idxGroup = new Vector();
	    _idxGroup.add(pattern);
	}
	
	else if (pattern instanceof AlternativePattern) {
	    final AlternativePattern alt = (AlternativePattern)pattern;
	    flattenAlternative(alt.getLeft(), template, keys);
	    flattenAlternative(alt.getRight(), template, keys);
	}
	
	else if (pattern instanceof LocationPathPattern) {
	    final LocationPathPattern lpp = (LocationPathPattern)pattern;
	    lpp.setTemplate(template);
	    addPatternToGroup(lpp);
	}
    }

    
    private void addPatternToGroup(final LocationPathPattern lpp) {
	
	if (lpp instanceof IdKeyPattern) {
	    addPattern(-1, lpp);
	}
	
	else {
	    
	    final StepPattern kernel = lpp.getKernelPattern();
	    if (kernel != null) {
		addPattern(kernel.getNodeType(), lpp);
	    }
	    else if (_rootPattern == null ||
		     lpp.noSmallerThan(_rootPattern)) {
		_rootPattern = lpp;
	    }
	}
    }

    
    private void addPattern(int kernelType, LocationPathPattern pattern) {
	
	final int oldLength = _patternGroups.length;
	if (kernelType >= oldLength) {
	    Vector[] newGroups = new Vector[kernelType * 2];
	    System.arraycopy(_patternGroups, 0, newGroups, 0, oldLength);
	    _patternGroups = newGroups;
	}
	
	
	Vector patterns;

	
	patterns = (kernelType == -1) ? _nodeGroup : _patternGroups[kernelType];

	
	if (patterns == null) {
	    patterns = new Vector(2);
	    patterns.addElement(pattern);

	    if (kernelType == -1) {
		_nodeGroup = patterns;
	    }
	    else {
		_patternGroups[kernelType] = patterns;
	    }
	}
	
	else {
	    boolean inserted = false;
	    for (int i = 0; i < patterns.size(); i++) {
		final LocationPathPattern lppToCompare =
		    (LocationPathPattern)patterns.elementAt(i);
		if (pattern.noSmallerThan(lppToCompare)) {
		    inserted = true;
		    patterns.insertElementAt(pattern, i);
		    break;
		}
	    }
	    if (inserted == false) {
		patterns.addElement(pattern);
	    }
	}
    }
    
    
    private void prepareTestSequences() {
	final Vector names = _stylesheet.getXSLTC().getNamesIndex();

	final Vector starGroup = _patternGroups[DOM.ELEMENT];
	final Vector atStarGroup = _patternGroups[DOM.ATTRIBUTE];

	
	if (starGroup != null || atStarGroup != null || _nodeGroup != null) {
	    final int n = _patternGroups.length;

	    for (int m, i = DOM.NTYPES; i < n; i++) {
		if (_patternGroups[i] == null) continue;

		final String name = (String) names.elementAt(i - DOM.NTYPES);

		if (isAttributeName(name)) {
		    
		    m = (atStarGroup != null) ? atStarGroup.size() : 0;
		    for (int j = 0; j < m; j++) {
			addPattern(i, 
			    (LocationPathPattern) atStarGroup.elementAt(j));
		    }
		}
		else {
		    
		    m = (starGroup != null) ? starGroup.size() : 0;
		    for (int j = 0; j < m; j++) {
			addPattern(i, 
			    (LocationPathPattern) starGroup.elementAt(j));
		    }

		    
		    m = (_nodeGroup != null) ? _nodeGroup.size() : 0;
		    for (int j = 0; j < m; j++) {
			addPattern(i, 
			    (LocationPathPattern) _nodeGroup.elementAt(j));
		    }
		}
	    }
	}

	_testSeq = new TestSeq[DOM.NTYPES + names.size()];
	
	final int n = _patternGroups.length;
	for (int i = 0; i < n; i++) {
	    final Vector patterns = _patternGroups[i];
	    if (patterns != null) {
		final TestSeq testSeq = new TestSeq(patterns, i, this);
		testSeq.reduce();
		_testSeq[i] = testSeq;
		testSeq.findTemplates(_neededTemplates);
	    }
	}

	if ((_nodeGroup != null) && (_nodeGroup.size() > 0)) {
	    _nodeTestSeq = new TestSeq(_nodeGroup, -1, this);
	    _nodeTestSeq.reduce();
	    _nodeTestSeq.findTemplates(_neededTemplates);
	}

	if ((_idxGroup != null) && (_idxGroup.size() > 0)) {
	    _idxTestSeq = new TestSeq(_idxGroup, this);
	    _idxTestSeq.reduce();
	    _idxTestSeq.findTemplates(_neededTemplates);
	}
	
	if (_rootPattern != null) {
	    
	    _neededTemplates.put(_rootPattern.getTemplate(), this);
	}
    }

    private void compileNamedTemplate(Template template,
				      ClassGenerator classGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();
	String methodName = Util.escape(template.getName().toString());

	final NamedMethodGenerator methodGen =
	    new NamedMethodGenerator(ACC_PUBLIC,
				     org.apache.bcel.generic.Type.VOID,
				     new org.apache.bcel.generic.Type[] {
					 Util.getJCRefType(DOM_INTF_SIG),
					 Util.getJCRefType(NODE_ITERATOR_SIG),
					 Util.getJCRefType(TRANSLET_OUTPUT_SIG),
					 org.apache.bcel.generic.Type.INT
				     },
				     new String[] {
					 DOCUMENT_PNAME,
					 ITERATOR_PNAME,
					 TRANSLET_OUTPUT_PNAME,
					 NODE_PNAME
				     },
				     methodName,
				     getClassName(),
				     il, cpg);
	
	il.append(template.compile(classGen, methodGen));
	il.append(RETURN);
	
	methodGen.stripAttributes(true);
	methodGen.setMaxLocals();
	methodGen.setMaxStack();
	methodGen.removeNOPs();
	classGen.addMethod(methodGen.getMethod());
    }

    private void compileTemplates(ClassGenerator classGen,
				  MethodGenerator methodGen,
				  InstructionHandle next) 
    {
        Enumeration templates = _namedTemplates.keys();
        while (templates.hasMoreElements()) {
            final Template template = (Template)templates.nextElement();
            compileNamedTemplate(template, classGen);
        }

	templates = _neededTemplates.keys();
	while (templates.hasMoreElements()) {
	    final Template template = (Template)templates.nextElement();
	    if (template.hasContents()) {
		
		InstructionList til = template.compile(classGen, methodGen);
		til.append(new GOTO_W(next));
		_templateILs.put(template, til);
		_templateIHs.put(template, til.getStart());
	    }
	    else {
		
		_templateIHs.put(template, next);
	    }
	}
    }
	
    private void appendTemplateCode(InstructionList body) {
	final Enumeration templates = _neededTemplates.keys();
	while (templates.hasMoreElements()) {
	    final Object iList =
		_templateILs.get(templates.nextElement());
	    if (iList != null) {
		body.append((InstructionList)iList);
	    }
	}
    }

    private void appendTestSequences(InstructionList body) {
	final int n = _testSeq.length;
	for (int i = 0; i < n; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    if (testSeq != null) {
		InstructionList il = testSeq.getInstructionList();
		if (il != null)
		    body.append(il);
		
	    }
	}
    }

    public static void compileGetChildren(ClassGenerator classGen,
					  MethodGenerator methodGen,
					  int node) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int git = cpg.addInterfaceMethodref(DOM_INTF,
						  GET_CHILDREN,
						  GET_CHILDREN_SIG);
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(node));
	il.append(new INVOKEINTERFACE(git, 2));
    }

    
    private InstructionList compileDefaultRecursion(ClassGenerator classGen,
						    MethodGenerator methodGen,
						    InstructionHandle next) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();
	final String applyTemplatesSig = classGen.getApplyTemplatesSig();
	final int git = cpg.addInterfaceMethodref(DOM_INTF,
						  GET_CHILDREN,
						  GET_CHILDREN_SIG);
	final int applyTemplates = cpg.addMethodref(getClassName(),
						    functionName(),
						    applyTemplatesSig);
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(_currentIndex));
	il.append(new INVOKEINTERFACE(git, 2));
	il.append(methodGen.loadHandler());
	il.append(new INVOKEVIRTUAL(applyTemplates));
	il.append(new GOTO_W(next));
	return il;
    }

    
    private InstructionList compileDefaultText(ClassGenerator classGen,
					       MethodGenerator methodGen,
					       InstructionHandle next) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = new InstructionList();

	final int chars = cpg.addInterfaceMethodref(DOM_INTF,
						    CHARACTERS,
						    CHARACTERS_SIG);
	il.append(methodGen.loadDOM());
	il.append(new ILOAD(_currentIndex));
	il.append(methodGen.loadHandler());
	il.append(new INVOKEINTERFACE(chars, 3));
	il.append(new GOTO_W(next));
	return il;
    }

    private InstructionList compileNamespaces(ClassGenerator classGen,
					      MethodGenerator methodGen,
					      boolean[] isNamespace,
					      boolean[] isAttribute,
					      boolean attrFlag,
					      InstructionHandle defaultTarget) {
	final XSLTC xsltc = classGen.getParser().getXSLTC();
	final ConstantPoolGen cpg = classGen.getConstantPool();

	
	final Vector namespaces = xsltc.getNamespaceIndex();
	final Vector names = xsltc.getNamesIndex();
	final int namespaceCount = namespaces.size() + 1;
	final int namesCount = names.size();

	final InstructionList il = new InstructionList();
	final int[] types = new int[namespaceCount];
	final InstructionHandle[] targets = new InstructionHandle[types.length];

	if (namespaceCount > 0) {
	    boolean compiled = false;

	    
	    for (int i = 0; i < namespaceCount; i++) {
		targets[i] = defaultTarget;
		types[i] = i;
	    }

	    
	    for (int i = DOM.NTYPES; i < (DOM.NTYPES+namesCount); i++) {
		if ((isNamespace[i]) && (isAttribute[i] == attrFlag)) {
		    String name = (String)names.elementAt(i-DOM.NTYPES);
		    String namespace = name.substring(0,name.lastIndexOf(':'));
		    final int type = xsltc.registerNamespace(namespace);
		    
		    if ((i < _testSeq.length) &&
			(_testSeq[i] != null)) {
			targets[type] =
			    (_testSeq[i]).compile(classGen,
						       methodGen,
						       defaultTarget);
			compiled = true;
		    }
		}
	    }

	    
	    if (!compiled) return(null);
		
	    
	    final int getNS = cpg.addInterfaceMethodref(DOM_INTF,
							""getNamespaceType"",
							""(I)I"");
	    il.append(methodGen.loadDOM());
	    il.append(new ILOAD(_currentIndex));
	    il.append(new INVOKEINTERFACE(getNS, 2));
	    il.append(new SWITCH(types, targets, defaultTarget));
	    return(il);
	}
	else {
	    return(null);
	}
    }

   
    public void compileApplyTemplates(ClassGenerator classGen) {
	final XSLTC xsltc = classGen.getParser().getXSLTC();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final Vector names = xsltc.getNamesIndex();

	
	final org.apache.bcel.generic.Type[] argTypes =
	    new org.apache.bcel.generic.Type[3];
	argTypes[0] = Util.getJCRefType(DOM_INTF_SIG);
	argTypes[1] = Util.getJCRefType(NODE_ITERATOR_SIG);
	argTypes[2] = Util.getJCRefType(TRANSLET_OUTPUT_SIG);

	final String[] argNames = new String[3];
	argNames[0] = DOCUMENT_PNAME;
	argNames[1] = ITERATOR_PNAME;
	argNames[2] = TRANSLET_OUTPUT_PNAME;

	final InstructionList mainIL = new InstructionList();
	final MethodGenerator methodGen =
	    new MethodGenerator(ACC_PUBLIC | ACC_FINAL, 
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames, functionName(),
				getClassName(), mainIL,
				classGen.getConstantPool());
	methodGen.addException(""org.apache.xalan.xsltc.TransletException"");

	
	final LocalVariableGen current;
	current = methodGen.addLocalVariable2(""current"",
					      org.apache.bcel.generic.Type.INT,
					      mainIL.getEnd());
	_currentIndex = current.getIndex();

	
	
	final InstructionList body = new InstructionList();
	body.append(NOP);

	
	
	final InstructionList ilLoop = new InstructionList();
	ilLoop.append(methodGen.loadIterator());
	ilLoop.append(methodGen.nextNode());
	ilLoop.append(DUP);
	ilLoop.append(new ISTORE(_currentIndex));

	
	
        final BranchHandle ifeq = ilLoop.append(new IFEQ(null));
	final BranchHandle loop = ilLoop.append(new GOTO_W(null));
	ifeq.setTarget(ilLoop.append(RETURN)); 	
	final InstructionHandle ihLoop = ilLoop.getStart();

	
	InstructionList ilRecurse =
	    compileDefaultRecursion(classGen, methodGen, ihLoop);
	InstructionHandle ihRecurse = ilRecurse.getStart();

	
	InstructionList ilText =
	    compileDefaultText(classGen, methodGen, ihLoop);
	InstructionHandle ihText = ilText.getStart();

	
	final int[] types = new int[DOM.NTYPES + names.size()];
	for (int i = 0; i < types.length; i++) {
	    types[i] = i;
	}

	
	final boolean[] isAttribute = new boolean[types.length];
	final boolean[] isNamespace = new boolean[types.length];
	for (int i = 0; i < names.size(); i++) {
	    final String name = (String)names.elementAt(i);
	    isAttribute[i + DOM.NTYPES] = isAttributeName(name);
	    isNamespace[i + DOM.NTYPES] = isNamespaceName(name);
	}

	
	compileTemplates(classGen, methodGen, ihLoop);

	
	final TestSeq elemTest = _testSeq[DOM.ELEMENT];
	InstructionHandle ihElem = ihRecurse;
	if (elemTest != null)
	    ihElem = elemTest.compile(classGen, methodGen, ihRecurse);

	
	final TestSeq attrTest = _testSeq[DOM.ATTRIBUTE];
	InstructionHandle ihAttr = ihText;
	if (attrTest != null)
	    ihAttr = attrTest.compile(classGen, methodGen, ihAttr);

	
	InstructionList ilKey = null;
	if (_idxTestSeq != null) {
	    loop.setTarget(_idxTestSeq.compile(classGen, methodGen, body.getStart()));
	    ilKey = _idxTestSeq.getInstructionList();
	}
	else {
	    loop.setTarget(body.getStart());
	}

	
	
	if (_nodeTestSeq != null) {
	    
	    double nodePrio = _nodeTestSeq.getPriority();
	    int    nodePos  = _nodeTestSeq.getPosition();
	    double elemPrio = (0 - Double.MAX_VALUE);
	    int    elemPos  = Integer.MIN_VALUE;

	    if (elemTest != null) {
		elemPrio = elemTest.getPriority();
		elemPos  = elemTest.getPosition();
	    }
	    if (elemPrio == Double.NaN || elemPrio < nodePrio || 
		(elemPrio == nodePrio && elemPos < nodePos)) 
	    {
		ihElem = _nodeTestSeq.compile(classGen, methodGen, ihLoop);
	    }

	    
	    final TestSeq textTest = _testSeq[DOM.TEXT];
	    double textPrio = (0 - Double.MAX_VALUE);
	    int    textPos  = Integer.MIN_VALUE;

	    if (textTest != null) {
		textPrio = textTest.getPriority();
		textPos  = textTest.getPosition();
	    }
	    if (textPrio == Double.NaN || textPrio < nodePrio ||
	        (textPrio == nodePrio && textPos < nodePos)) 
	    {
		ihText = _nodeTestSeq.compile(classGen, methodGen, ihLoop);
		_testSeq[DOM.TEXT] = _nodeTestSeq;
	    }
	}

	
	InstructionHandle elemNamespaceHandle = ihElem;
	InstructionList nsElem = compileNamespaces(classGen, methodGen,
						   isNamespace, isAttribute,
						   false, ihElem);
	if (nsElem != null) elemNamespaceHandle = nsElem.getStart();

	
	InstructionHandle attrNamespaceHandle = ihAttr;
	InstructionList nsAttr = compileNamespaces(classGen, methodGen,
						   isNamespace, isAttribute,
						   true, ihAttr);
	if (nsAttr != null) attrNamespaceHandle = nsAttr.getStart();

	
	final InstructionHandle[] targets = new InstructionHandle[types.length];
	for (int i = DOM.NTYPES; i < targets.length; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    
	    if (isNamespace[i]) {
		if (isAttribute[i])
		    targets[i] = attrNamespaceHandle;
		else
		    targets[i] = elemNamespaceHandle;
	    }
	    
	    else if (testSeq != null) {
		if (isAttribute[i])
		    targets[i] = testSeq.compile(classGen, methodGen,
						 attrNamespaceHandle);
		else
		    targets[i] = testSeq.compile(classGen, methodGen,
						 elemNamespaceHandle);
	    }
	    else {
		targets[i] = ihLoop;
	    }
	}


	
	targets[DOM.ROOT] = _rootPattern != null
	    ? getTemplateInstructionHandle(_rootPattern.getTemplate())
	    : ihRecurse;
	
	
	targets[DOM.TEXT] = _testSeq[DOM.TEXT] != null
	    ? _testSeq[DOM.TEXT].compile(classGen, methodGen, ihText)
	    : ihText;

	
	targets[DOM.NAMESPACE] = ihLoop;

	
	targets[DOM.ELEMENT] = elemNamespaceHandle;

	
	targets[DOM.ATTRIBUTE] = attrNamespaceHandle;

	
	InstructionHandle ihPI = ihLoop;
	if (_nodeTestSeq != null) ihPI = ihElem;
	if (_testSeq[DOM.PROCESSING_INSTRUCTION] != null)
	    targets[DOM.PROCESSING_INSTRUCTION] =
		_testSeq[DOM.PROCESSING_INSTRUCTION].
		compile(classGen, methodGen, ihPI);
	else
	    targets[DOM.PROCESSING_INSTRUCTION] = ihPI;
	
	
	InstructionHandle ihComment = ihLoop;
	if (_nodeTestSeq != null) ihComment = ihElem;
	targets[DOM.COMMENT] = _testSeq[DOM.COMMENT] != null
	    ? _testSeq[DOM.COMMENT].compile(classGen, methodGen, ihComment)
	    : ihComment;

	
	for (int i = DOM.NTYPES; i < targets.length; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    
	    if ((testSeq == null) || (isNamespace[i])) {
		if (isAttribute[i])
		    targets[i] = attrNamespaceHandle;
		else
		    targets[i] = elemNamespaceHandle;
	    }
	    
	    else {
		if (isAttribute[i])
		    targets[i] = testSeq.compile(classGen, methodGen,
						 attrNamespaceHandle);
		else
		    targets[i] = testSeq.compile(classGen, methodGen,
						 elemNamespaceHandle);
	    }
	}

	if (ilKey != null) body.insert(ilKey);

	
	final int getType = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getType"", ""(I)I"");
	body.append(methodGen.loadDOM());
	body.append(new ILOAD(_currentIndex));
	body.append(new INVOKEINTERFACE(getType, 2));

	
	InstructionHandle disp = body.append(new SWITCH(types, targets, ihLoop));

	
	appendTestSequences(body);
	
	appendTemplateCode(body);

	
	if (nsElem != null) body.append(nsElem);
	
	if (nsAttr != null) body.append(nsAttr);

	
	body.append(ilRecurse);
	
	body.append(ilText);

	
	mainIL.append(new GOTO_W(ihLoop));
	mainIL.append(body);
	
	mainIL.append(ilLoop);

	peepHoleOptimization(methodGen);
	methodGen.stripAttributes(true);
	
	methodGen.setMaxLocals();
	methodGen.setMaxStack();
	methodGen.removeNOPs();
	classGen.addMethod(methodGen.getMethod());

	
	if (_importLevels != null) {
	    Enumeration levels = _importLevels.keys();
	    while (levels.hasMoreElements()) {
		Integer max = (Integer)levels.nextElement();
		Integer min = (Integer)_importLevels.get(max);
		compileApplyImports(classGen, min.intValue(), max.intValue());
	    }
	}
    }

    private void compileTemplateCalls(ClassGenerator classGen,
				      MethodGenerator methodGen,
				      InstructionHandle next, int min, int max){
        Enumeration templates = _neededTemplates.keys();
	while (templates.hasMoreElements()) {
	    final Template template = (Template)templates.nextElement();
	    final int prec = template.getImportPrecedence();
	    if ((prec >= min) && (prec < max)) {
		if (template.hasContents()) {
		    InstructionList til = template.compile(classGen, methodGen);
		    til.append(new GOTO_W(next));
		    _templateILs.put(template, til);
		    _templateIHs.put(template, til.getStart());
		}
		else {
		    
		    _templateIHs.put(template, next);
		}
	    }
	}
    }


    public void compileApplyImports(ClassGenerator classGen, int min, int max) {
	final XSLTC xsltc = classGen.getParser().getXSLTC();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final Vector names      = xsltc.getNamesIndex();

	
	_namedTemplates = new Hashtable();
	_neededTemplates = new Hashtable();
	_templateIHs = new Hashtable();
	_templateILs = new Hashtable();
	_patternGroups = new Vector[32];
	_rootPattern = null;

	
	Vector oldTemplates = _templates;

	
	_templates = new Vector();
	final Enumeration templates = oldTemplates.elements();
	while (templates.hasMoreElements()) {
	    final Template template = (Template)templates.nextElement();
	    final int prec = template.getImportPrecedence();
	    if ((prec >= min) && (prec < max)) addTemplate(template);
	}

	
	processPatterns(_keys);

	
	final org.apache.bcel.generic.Type[] argTypes =
	    new org.apache.bcel.generic.Type[3];
	argTypes[0] = Util.getJCRefType(DOM_INTF_SIG);
	argTypes[1] = Util.getJCRefType(NODE_ITERATOR_SIG);
	argTypes[2] = Util.getJCRefType(TRANSLET_OUTPUT_SIG);

	final String[] argNames = new String[3];
	argNames[0] = DOCUMENT_PNAME;
	argNames[1] = ITERATOR_PNAME;
	argNames[2] = TRANSLET_OUTPUT_PNAME;

	final InstructionList mainIL = new InstructionList();
	final MethodGenerator methodGen =
	    new MethodGenerator(ACC_PUBLIC | ACC_FINAL, 
				org.apache.bcel.generic.Type.VOID,
				argTypes, argNames, functionName()+'_'+max,
				getClassName(), mainIL,
				classGen.getConstantPool());
	methodGen.addException(""org.apache.xalan.xsltc.TransletException"");

	
	final LocalVariableGen current;
	current = methodGen.addLocalVariable2(""current"",
					      org.apache.bcel.generic.Type.INT,
					      mainIL.getEnd());
	_currentIndex = current.getIndex();

	
	
	final InstructionList body = new InstructionList();
	body.append(NOP);

	
	
	final InstructionList ilLoop = new InstructionList();
	ilLoop.append(methodGen.loadIterator());
	ilLoop.append(methodGen.nextNode());
	ilLoop.append(DUP);
	ilLoop.append(new ISTORE(_currentIndex));

	
	
        final BranchHandle ifeq = ilLoop.append(new IFEQ(null));
	final BranchHandle loop = ilLoop.append(new GOTO_W(null));
	ifeq.setTarget(ilLoop.append(RETURN)); 
	final InstructionHandle ihLoop = ilLoop.getStart();

	
	InstructionList ilRecurse =
	    compileDefaultRecursion(classGen, methodGen, ihLoop);
	InstructionHandle ihRecurse = ilRecurse.getStart();

	
	InstructionList ilText =
	    compileDefaultText(classGen, methodGen, ihLoop);
	InstructionHandle ihText = ilText.getStart();

	
	final int[] types = new int[DOM.NTYPES + names.size()];
	for (int i = 0; i < types.length; i++) {
	    types[i] = i;
	}

	final boolean[] isAttribute = new boolean[types.length];
	final boolean[] isNamespace = new boolean[types.length];
	for (int i = 0; i < names.size(); i++) {
	    final String name = (String)names.elementAt(i);
	    isAttribute[i+DOM.NTYPES] = isAttributeName(name);
	    isNamespace[i+DOM.NTYPES] = isNamespaceName(name);
	}

	
	compileTemplateCalls(classGen, methodGen, ihLoop, min, max);

	
	final TestSeq elemTest = _testSeq[DOM.ELEMENT];
	InstructionHandle ihElem = ihRecurse;
	if (elemTest != null) {
	    ihElem = elemTest.compile(classGen, methodGen, ihLoop);
	}

	
	final TestSeq attrTest = _testSeq[DOM.ATTRIBUTE];
	InstructionHandle ihAttr = ihLoop;
	if (attrTest != null) {
	    ihAttr = attrTest.compile(classGen, methodGen, ihAttr);
	}

	
	InstructionList ilKey = null;
	if (_idxTestSeq != null) {
	    loop.setTarget(_idxTestSeq.compile(classGen, methodGen, body.getStart()));
	    ilKey = _idxTestSeq.getInstructionList();
	}
	else {
	    loop.setTarget(body.getStart());
	}

	
	
	if (_nodeTestSeq != null) {
	    
	    double nodePrio = _nodeTestSeq.getPriority();
	    int    nodePos  = _nodeTestSeq.getPosition();
	    double elemPrio = (0 - Double.MAX_VALUE);
	    int    elemPos  = Integer.MIN_VALUE;

	    if (elemTest != null) {
		elemPrio = elemTest.getPriority();
		elemPos  = elemTest.getPosition();
	    }

	    if (elemPrio == Double.NaN || elemPrio < nodePrio || 
		(elemPrio == nodePrio && elemPos < nodePos)) 
	    {
		ihElem = _nodeTestSeq.compile(classGen, methodGen, ihLoop);
	    }

	    
	    final TestSeq textTest = _testSeq[DOM.TEXT];
	    double textPrio = (0 - Double.MAX_VALUE);
	    int    textPos  = Integer.MIN_VALUE;

	    if (textTest != null) {
		textPrio = textTest.getPriority();
		textPos  = textTest.getPosition();
	    }

	    if (textPrio == Double.NaN || textPrio < nodePrio ||
	        (textPrio == nodePrio && textPos < nodePos)) 
	    {
		ihText = _nodeTestSeq.compile(classGen, methodGen, ihLoop);
		_testSeq[DOM.TEXT] = _nodeTestSeq;
	    }
	}

	
	InstructionHandle elemNamespaceHandle = ihElem;
	InstructionList nsElem = compileNamespaces(classGen, methodGen,
						   isNamespace, isAttribute,
						   false, ihElem);
	if (nsElem != null) elemNamespaceHandle = nsElem.getStart();

	
	InstructionList nsAttr = compileNamespaces(classGen, methodGen,
						   isNamespace, isAttribute,
						   true, ihAttr);
	InstructionHandle attrNamespaceHandle = ihAttr;
	if (nsAttr != null) attrNamespaceHandle = nsAttr.getStart();

	
	final InstructionHandle[] targets = new InstructionHandle[types.length];
	for (int i = DOM.NTYPES; i < targets.length; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    
	    if (isNamespace[i]) {
		if (isAttribute[i])
		    targets[i] = attrNamespaceHandle;
		else
		    targets[i] = elemNamespaceHandle;
	    }
	    
	    else if (testSeq != null) {
		if (isAttribute[i])
		    targets[i] = testSeq.compile(classGen, methodGen,
						 attrNamespaceHandle);
		else
		    targets[i] = testSeq.compile(classGen, methodGen,
						 elemNamespaceHandle);
	    }
	    else {
		targets[i] = ihLoop;
	    }
	}

	
	targets[DOM.ROOT] = _rootPattern != null
	    ? getTemplateInstructionHandle(_rootPattern.getTemplate())
	    : ihRecurse;
	
	
	targets[DOM.TEXT] = _testSeq[DOM.TEXT] != null
	    ? _testSeq[DOM.TEXT].compile(classGen, methodGen, ihText)
	    : ihText;

	
	targets[DOM.NAMESPACE] = ihLoop;

	
	targets[DOM.ELEMENT] = elemNamespaceHandle;

	
	targets[DOM.ATTRIBUTE] = attrNamespaceHandle;

	
	InstructionHandle ihPI = ihLoop;
	if (_nodeTestSeq != null) ihPI = ihElem;
	if (_testSeq[DOM.PROCESSING_INSTRUCTION] != null) {
	    targets[DOM.PROCESSING_INSTRUCTION] =
		_testSeq[DOM.PROCESSING_INSTRUCTION].
		compile(classGen, methodGen, ihPI);
	}
	else {
	    targets[DOM.PROCESSING_INSTRUCTION] = ihPI;
	}
	
	
	InstructionHandle ihComment = ihLoop;
	if (_nodeTestSeq != null) ihComment = ihElem;
	targets[DOM.COMMENT] = _testSeq[DOM.COMMENT] != null
	    ? _testSeq[DOM.COMMENT].compile(classGen, methodGen, ihComment)
	    : ihComment;

	
	for (int i = DOM.NTYPES; i < targets.length; i++) {
	    final TestSeq testSeq = _testSeq[i];
	    
	    if ((testSeq == null) || (isNamespace[i])) {
		if (isAttribute[i])
		    targets[i] = attrNamespaceHandle;
		else
		    targets[i] = elemNamespaceHandle;
	    }
	    
	    else {
		if (isAttribute[i])
		    targets[i] = testSeq.compile(classGen, methodGen,
						 attrNamespaceHandle);
		else
		    targets[i] = testSeq.compile(classGen, methodGen,
						 elemNamespaceHandle);
	    }
	}

	if (ilKey != null) body.insert(ilKey);

	
	final int getType = cpg.addInterfaceMethodref(DOM_INTF,
						      ""getType"", ""(I)I"");
	body.append(methodGen.loadDOM());
	body.append(new ILOAD(_currentIndex));
	body.append(new INVOKEINTERFACE(getType, 2));

	
	InstructionHandle disp = body.append(new SWITCH(types,targets,ihLoop));

	
	appendTestSequences(body);
	
	appendTemplateCode(body);

	
	if (nsElem != null) body.append(nsElem);
	
	if (nsAttr != null) body.append(nsAttr);

	
	body.append(ilRecurse);
	
	body.append(ilText);

	
	mainIL.append(new GOTO_W(ihLoop));
	mainIL.append(body);
	
	mainIL.append(ilLoop);

	peepHoleOptimization(methodGen);
	methodGen.stripAttributes(true);
	
	methodGen.setMaxLocals();
	methodGen.setMaxStack();
	methodGen.removeNOPs();
	classGen.addMethod(methodGen.getMethod());

	
	_templates = oldTemplates;
    }

    
    private void peepHoleOptimization(MethodGenerator methodGen) {
	InstructionList il = methodGen.getInstructionList();
	InstructionFinder find = new InstructionFinder(il);
	InstructionHandle ih;
	String pattern;

	
	pattern = ""`ALOAD'`POP'`Instruction'"";
	for(Iterator iter=find.search(pattern); iter.hasNext();){
	    InstructionHandle[] match = (InstructionHandle[])iter.next();
	    try {
		if ((!match[0].hasTargeters()) && (!match[1].hasTargeters())) {
                    il.delete(match[0], match[1]);
                }
	    }
	    catch (TargetLostException e) {
                
            }
	}
	
	pattern = ""`ILOAD'`ALOAD'`SWAP'`Instruction'"";
	for(Iterator iter=find.search(pattern); iter.hasNext();){
            InstructionHandle[] match = (InstructionHandle[])iter.next();
            try {
                org.apache.bcel.generic.Instruction iload;
                org.apache.bcel.generic.Instruction aload;
                if ((!match[0].hasTargeters()) &&
                    (!match[1].hasTargeters()) &&
                    (!match[2].hasTargeters())) {
                    iload = match[0].getInstruction();
                    aload = match[1].getInstruction();
                    il.insert(match[0], aload);
                    il.insert(match[0], iload);
                    il.delete(match[0], match[2]);
                }
            }
            catch (TargetLostException e) {
                
            }
        }

        
	pattern = ""`ALOAD_1'`ALOAD_1'`Instruction'"";
        for(Iterator iter=find.search(pattern); iter.hasNext();){
            InstructionHandle[] match = (InstructionHandle[])iter.next();
            try {
	        org.apache.bcel.generic.Instruction iload;
                org.apache.bcel.generic.Instruction aload;
                if ((!match[0].hasTargeters()) && (!match[1].hasTargeters())) {
                    il.insert(match[1], new DUP());
                    il.delete(match[1]);
                }
            }
            catch (TargetLostException e) {
                
            }
        }

    }

    public InstructionHandle getTemplateInstructionHandle(Template template) {
	return (InstructionHandle)_templateIHs.get(template);
    }

    
    private static boolean isAttributeName(String qname) {
	final int col = qname.lastIndexOf(':') + 1;
	return (qname.charAt(col) == '@');
    }

    
    private static boolean isNamespaceName(String qname) {
	final int col = qname.lastIndexOf(':');
	return (col > -1 && qname.charAt(qname.length()-1) == '*');
    }
}
"
org.apache.xml.utils.IntVector,18,1,1,4,20,0,4,0,18,0.382352941,458,1.0,0,0.0,0.916666667,0,0,24.22222222,4,1.8889,1,"
package org.apache.xml.utils;


public class IntVector
{

  
  protected int m_blocksize;

  
  protected int m_map[]; 

  
  protected int m_firstFree = 0;

  
  protected int m_mapSize;

  
  public IntVector()
  {

    m_blocksize = 32;
    m_mapSize = m_blocksize;
    m_map = new int[m_blocksize];
  }

  
  public IntVector(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new int[blocksize];
  }
  
  
  public IntVector(int blocksize, int increaseSize)
  {

    m_blocksize = increaseSize;
    m_mapSize = blocksize;
    m_map = new int[blocksize];
  }


  
  public final int size()
  {
    return m_firstFree;
  }
  
  
  public final void setSize(int sz)
  {
    m_firstFree = sz;
  }


  
  public final void addElement(int value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }
  
  
  public final void addElements(int value, int numberOfElements)
  {

    if ((m_firstFree + numberOfElements) >= m_mapSize)
    {
      m_mapSize += (m_blocksize+numberOfElements);

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    for (int i = 0; i < numberOfElements; i++) 
    {
      m_map[m_firstFree] = value;
      m_firstFree++;
    }
  }
  
  
  public final void addElements(int numberOfElements)
  {

    if ((m_firstFree + numberOfElements) >= m_mapSize)
    {
      m_mapSize += (m_blocksize+numberOfElements);

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }
    
    m_firstFree += numberOfElements;
  }
  

  
  public final void insertElementAt(int value, int at)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    if (at <= (m_firstFree - 1))
    {
      System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);
    }

    m_map[at] = value;

    m_firstFree++;
  }

  
  public final void removeAllElements()
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      m_map[i] = java.lang.Integer.MIN_VALUE;
    }

    m_firstFree = 0;
  }

  
  public final boolean removeElement(int s)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i] == s)
      {
        if ((i + 1) < m_firstFree)
          System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
        else
          m_map[i] = java.lang.Integer.MIN_VALUE;

        m_firstFree--;

        return true;
      }
    }

    return false;
  }

  
  public final void removeElementAt(int i)
  {

    if (i > m_firstFree)
      System.arraycopy(m_map, i + 1, m_map, i, m_firstFree);
    else
      m_map[i] = java.lang.Integer.MIN_VALUE;

    m_firstFree--;
  }

  
  public final void setElementAt(int value, int index)
  {
    m_map[index] = value;
  }

  
  public final int elementAt(int i)
  {
    return m_map[i];
  }

  
  public final boolean contains(int s)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i] == s)
        return true;
    }

    return false;
  }

  
  public final int indexOf(int elem, int index)
  {

    for (int i = index; i < m_firstFree; i++)
    {
      if (m_map[i] == elem)
        return i;
    }

    return java.lang.Integer.MIN_VALUE;
  }

  
  public final int indexOf(int elem)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i] == elem)
        return i;
    }

    return java.lang.Integer.MIN_VALUE;
  }

  
  public final int lastIndexOf(int elem)
  {

    for (int i = (m_firstFree - 1); i >= 0; i--)
    {
      if (m_map[i] == elem)
        return i;
    }

    return java.lang.Integer.MIN_VALUE;
  }
}
"
org.apache.xalan.lib.ExsltMath,5,1,0,2,18,10,0,2,5,2.0,198,0.0,0,0.0,0.6,0,0,38.6,4,2.0,2,"
package org.apache.xalan.lib;

import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.w3c.dom.traversal.NodeIterator;

import org.apache.xpath.NodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XRTreeFrag;

import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.DOMHelper;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xml.utils.XMLString;

import org.xml.sax.SAXNotSupportedException;

import java.util.Hashtable;
import java.util.StringTokenizer;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.xslt.EnvironmentCheck;

import javax.xml.parsers.*;


public class ExsltMath
{
  
  public static String max (ExpressionContext expCon, NodeIterator ni)
  {
    NodeSet ns = new NodeSet(ni);
    Node maxNode = null;
    double m = Double.MIN_VALUE;
    for (int i = 0; i < ns.getLength(); i++)
    {
      Node n = ns.elementAt(i);
      double d = expCon.toNumber(n);
      if (Double.isNaN(d))
        return ""NaN"";
      else if (d > m)
      {
        m = d;
        maxNode = n;
      }
    }
    return expCon.toString(maxNode);      
  }

  
  public static String min (ExpressionContext expCon, NodeIterator ni)
  {
    NodeSet ns = new NodeSet(ni);
    Node minNode = null;
    double m = Double.MAX_VALUE;
    for (int i = 0; i < ns.getLength(); i++)
    {
      Node n = ns.elementAt(i);
      double d = expCon.toNumber(n);
      if (Double.isNaN(d))
        return ""NaN"";
      else if (d < m)
      {
        m = d;
        minNode = n;
      }
    }
    return expCon.toString(minNode);
  }
  
  
  public static NodeSet highest (ExpressionContext expCon, NodeIterator ni)
    throws java.lang.CloneNotSupportedException
  {    
    NodeSet ns = new NodeSet(ni);
    NodeIterator niClone = ns.cloneWithReset();
    double high = new Double(max(expCon, niClone)).doubleValue();
    NodeSet highNodes = new NodeSet();
    highNodes.setShouldCacheNodes(true);
    
    if (Double.isNaN(high))
      return highNodes;  
    
     for (int i = 0; i < ns.getLength(); i++)
    {
      Node n = ns.elementAt(i);
      double d = expCon.toNumber(n); 
      if (d == high)
      highNodes.addElement(n);
    }
    return highNodes;
  }
  
  
  public static NodeSet lowest (ExpressionContext expCon, NodeIterator ni)
    throws java.lang.CloneNotSupportedException
  {
    NodeSet ns = new NodeSet(ni);
    NodeIterator niClone = ns.cloneWithReset();
    double low = new Double(min(expCon, niClone)).doubleValue();

    NodeSet lowNodes = new NodeSet();
    lowNodes.setShouldCacheNodes(true);
    
    if (Double.isNaN(low))
      return lowNodes;  
    
     for (int i = 0; i < ns.getLength(); i++)
    {
      Node n = ns.elementAt(i);
      double d = expCon.toNumber(n); 
      if (d == low)
      lowNodes.addElement(n);
    }
    return lowNodes;
  }  
}"
org.apache.xalan.xsltc.compiler.util.ErrorMessages,4,2,1,1,9,2,1,0,3,0.666666667,378,1.0,0,0.942857143,0.666666667,2,3,93.0,6,1.75,1,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Vector;
import java.util.Enumeration;
import java.util.ResourceBundle;

public class ErrorMessages extends ResourceBundle {

    
    private static final String errorMessages[] = { 
	
	""More than one stylesheet defined in the same file."",
	
	""Template ''{0}'' already defined in this stylesheet."",
	
	""Template ''{0}'' not defined in this stylesheet."",
	
	""Variable ''{0}'' is multiply defined in the same scope."",
	
	""Variable or parameter ''{0}'' is undefined."",
	
	""Cannot find class ''{0}''."",
	
	""Cannot find external method ''{0}'' (must be public)."",
	
	""Cannot convert argument/return type in call to method ''{0}''"",
	
	""File or URI ''{0}'' not found."",
	
	""Invalid URI ''{0}''."",
	
	""Cannot open file or URI ''{0}''."",
	
	""<xsl:stylesheet> or <xsl:transform> element expected."",
	
	""Namespace prefix ''{0}'' is undeclared."",
	
	""Unable to resolve call to function ''{0}''."",
	
	""Argument to ''{0}'' must be a literal string."",
	
	""Error parsing XPath expression ''{0}''."",
	
	""Required attribute ''{0}'' is missing."",
	
	""Illegal character ''{0}'' in XPath expression."",
	
	""Illegal name ''{0}'' for processing instruction."",
	
	""Attribute ''{0}'' outside of element."",
	
	""Illegal attribute ''{0}''."",
	
	""Circular import/include. Stylesheet ''{0}'' already loaded."",
	
	""Result-tree fragments cannot be sorted (<xsl:sort> elements are ""+
	""ignored). You must sort the nodes when creating the result tree."",
	
	""Decimal formatting ''{0}'' is already defined."",
	
	""XSL version ''{0}'' is not supported by XSLTC."",
	
	""Circular variable/parameter reference in ''{0}''."",
	
	""Unknown operator for binary expression."",
	
	""Illegal argument(s) for function call."",
	
	""Second argument to document() function must be a node-set."",
	
	""At least one <xsl:when> element required in <xsl:choose>."",
	
	""Only one <xsl:otherwise> element allowed in <xsl:choose>."",
	
	""<xsl:otherwise> can only be used within <xsl:choose>."",
	
	""<xsl:when> can only be used within <xsl:choose>."",
	
	""Only <xsl:when> and <xsl:otherwise> elements allowed in <xsl:choose>."",
	
	""<xsl:attribute-set> is missing the 'name' attribute."",
	
	""Illegal child element."",
	
	""You cannot call an element ''{0}''"",
	
	""You cannot call an attribute ''{0}''"",
	
	""Text data outside of top-level <xsl:stylesheet> element."",
	
	""JAXP parser not configured correctly"",
	
	""Unrecoverable XSLTC-internal error: ''{0}''"",
	
	""Unsupported XSL element ''{0}''."",
	
	""Unrecognised XSLTC extension ''{0}''."",
	
	""The input document is not a stylesheet ""+
	""(the XSL namespace is not declared in the root element)."",
	
	""Could not find stylesheet target ''{0}''."",
	
	""Not implemented: ''{0}''."",
	
	""The input document does not contain an XSL stylesheet."",
	
	""Could not parse element ''{0}''"",
	
	""The use-attribute of <key> must be node, node-set, string or number."",
	
	""Output XML document version should be 1.0"",
	
	""Unknown operator for relational expression"",
	
	""Attempting to use non-existing attribute set ''{0}''."",
	
	""Cannot parse attribute value template ''{0}''."",
	
	""Unknown data-type in signature for class ''{0}''."",
	
	""Cannot convert data-type ''{0}'' to ''{1}''."",

	
	""This Templates does not contain a valid translet class definition."",
	
	""This Templates does not contain a class with the name ''{0}''."",
	
	""Could not load the translet class ''{0}''."",
	
	""Translet class loaded, but unable to create translet instance."",
	
	""Attempting to set ErrorListener for ''{0}'' to null"",
	
	""Only StreamSource, SAXSource and DOMSOurce are supported by XSLTC"",
	
	""Source object passed to ''{0}'' has no contents."",
	
	""Could not compile stylesheet"",
	
	""TransformerFactory does not recognise attribute ''{0}''."",
	
	""setResult() must be called prior to startDocument()."",
	
	""The transformer has no encapsulated translet object."",
	
	""No defined output handler for transformation result."",
	
	""Result object passed to ''{0}'' is invalid."",
	
	""Attempting to access invalid Transformer property ''{0}''."",
	
	""Could not crate SAX2DOM adapter: ''{0}''."",
	
	""XSLTCSource.build() called without systemId being set."",

	
	""The -i option must be used with the -o option."",

	
	""SYNOPSIS
"" +
	""   java org.apache.xalan.xsltc.cmdline.Compile [-o <output>]
"" +
	""      [-d <directory>] [-j <jarfile>] [-p <package>]
"" +
	""      [-n] [-x] [-s] [-u] [-v] [-h] { <stylesheet> | -i }

"" +
	""OPTIONS
"" +
	""   -o <output>    assigns the name <output> to the generated
"" +
	""                  translet. By default the translet name
"" +
	""                  is taken from the <stylesheet> name. This option
""+
	""                  is ignored if compiling multiple stylesheets.
"" +
	""   -d <directory> specifies a destination directory for translet
"" +
	""   -j <jarfile>   packages translet classes into a jar file of the
""+
 	""                  name specified as <jarfile>
""+
	""   -p <package>   specifies a package name prefix for all generated
""+
	""                  translet classes.
"" +
	""   -n             disables template inlining to reduce method
"" +
	""                  length.
""+
	""   -x             turns on additional debugging message output
"" +
	""   -s             disables calling System.exit
"" +
	""   -u             interprets <stylesheet> arguments as URLs
"" +
	""   -i             forces compiler to read stylesheet from stdin
"" +
	""   -v             prints the version of the compiler
"" +
	""   -h             prints this usage statement
"",  
 
	
	""SYNOPSIS 
"" +
	""   java org.apache.xalan.xsltc.cmdline.Transform [-j <jarfile>]
""+
        ""      [-x] [-s] [-n <iterations>] {-u <document_url> | <document>}
"" +  
        ""      <class> [<param1>=<value1> ...]

"" +
        ""   uses the translet <class> to transform an XML document 
""+
	""   specified as <document>. The translet <class> is either in
""+
	""   the user's CLASSPATH or in the optionally specified <jarfile>.
""+
	""OPTIONS
"" +
	""   -j <jarfile>    specifies a jarfile from which to load translet
""+
	""   -x              turns on additional debugging message output
"" +
	""   -s              disables calling System.exit
"" +
	""   -n <iterations> runs the transformation <iterations> times and
"" +
	""                   displays profiling information
"" +
	""   -u <document_url> specifies XML input document as a URL
"", 


	
	""<xsl:sort> can only be used within <xsl:for-each> or <xsl:apply-templates>."",
	
	""Output encoding ''{0}'' is not supported on this JVM."",
	
	""Syntax error in ''{0}''."",
	
	""Cannot find external constructor ''{0}''."",
	
	""First argument to non-static Java function ''{0}'' is not valid object ref.""
    };

    private static Vector _keys;

    static {
	_keys = new Vector();
	_keys.addElement(ErrorMsg.ERROR_MESSAGES_KEY);
	_keys.addElement(ErrorMsg.COMPILER_ERROR_KEY);
	_keys.addElement(ErrorMsg.COMPILER_WARNING_KEY);
	_keys.addElement(ErrorMsg.RUNTIME_ERROR_KEY);
    }

    public Enumeration getKeys() {
	return _keys.elements();
    }

    public Object handleGetObject(String key) {
	if (key == null) return null;
	if (key.equals(ErrorMsg.ERROR_MESSAGES_KEY))
	    return errorMessages;
 	else if (key.equals(ErrorMsg.COMPILER_ERROR_KEY))
	    return ""Compiler error(s): "";
	else if (key.equals(ErrorMsg.COMPILER_WARNING_KEY))
	    return ""Compiler warning(s): "";	    
 	else if (key.equals(ErrorMsg.RUNTIME_ERROR_KEY))
	    return ""Translet error(s): "";
	return(null);
    }

}
"
org.apache.xalan.xsltc.compiler.KeyCall,4,4,0,38,46,0,1,37,3,0.083333333,562,1.0,4,0.96969697,0.458333333,3,7,138.5,12,3.5,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class KeyCall extends FunctionCall {

    private Expression _name;      
    private Expression _value;     
    private Type       _valueType; 
    private QName      _resolvedQName = null;

    
    public KeyCall(QName fname, Vector arguments) {
	super(fname, arguments);
	switch(argumentCount()) {
	case 1:
	    _name = null;
	    _value = argument(0);
	    break;
	case 2:
	    _name = argument(0);
	    _value = argument(1);
	    break;
	default:
	    _name = _value = null;
	    break;
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type returnType = super.typeCheck(stable);

	
	
	if (_name != null) {
	    final Type nameType = _name.typeCheck(stable); 

	    if (_name instanceof LiteralExpr) {
		final LiteralExpr literal = (LiteralExpr) _name;
		_resolvedQName = 
		    getParser().getQNameIgnoreDefaultNs(literal.getValue());
	    }
	    else if (nameType instanceof StringType == false) {
		_name = new CastExpr(_name, Type.String);
	    }
	}

	
	
	
	
	
	
	
	_valueType = _value.typeCheck(stable);

	if ((_valueType != Type.NodeSet) &&
	    (_valueType != Type.ResultTree) &&
	    (_valueType != Type.String) &&
	    (_valueType != Type.Real) &&
	    (_valueType != Type.Int)) {
	    _value = new CastExpr(_value, Type.String);
	}

	return returnType;
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	
	final int dupInit = cpg.addMethodref(DUP_FILTERED_ITERATOR,
					     ""<init>"",
					     ""(""+NODE_ITERATOR_SIG+"")V"");
	il.append(new NEW(cpg.addClass(DUP_FILTERED_ITERATOR)));
	il.append(DUP);
	translateCall(classGen, methodGen);
	il.append(new INVOKESPECIAL(dupInit));
    }

    
    private void translateCall(ClassGenerator classGen,
			      MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getNodeValue = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getNodeValue"",
							   ""(I)""+STRING_SIG);

	
	final int getKeyIndex = cpg.addMethodref(TRANSLET_CLASS,
						 ""getKeyIndex"",
						 ""(Ljava/lang/String;)""+
						 KEY_INDEX_SIG);

	
	final int lookupId = cpg.addMethodref(KEY_INDEX_CLASS,
					      ""lookupId"",
					      ""(Ljava/lang/Object;)V"");
	final int lookupKey = cpg.addMethodref(KEY_INDEX_CLASS,
					       ""lookupKey"",
					       ""(Ljava/lang/Object;)V"");

	
	final int merge = cpg.addMethodref(KEY_INDEX_CLASS,
					   ""merge"",
					   ""(""+KEY_INDEX_SIG+"")V"");

	
	final int indexConstructor = cpg.addMethodref(TRANSLET_CLASS,
						      ""createKeyIndex"",
						      ""()""+KEY_INDEX_SIG);
	
	
	final LocalVariableGen returnIndex =
	    methodGen.addLocalVariable(""returnIndex"",
				       Util.getJCRefType(KEY_INDEX_SIG),
				       il.getEnd(), null);

	
	final LocalVariableGen searchIndex =
	    methodGen.addLocalVariable(""searchIndex"",
				       Util.getJCRefType(KEY_INDEX_SIG),
				       il.getEnd(), null);

	
	
	
	if (_valueType == Type.NodeSet || _valueType == Type.ResultTree) {
	    
	    il.append(methodGen.loadCurrentNode());
	    il.append(methodGen.loadIterator());

	    
	    _value.translate(classGen, methodGen);
	    _value.startResetIterator(classGen, methodGen);
	    il.append(methodGen.storeIterator());

	    
	    il.append(classGen.loadTranslet());
	    il.append(new INVOKEVIRTUAL(indexConstructor));
	    il.append(new ASTORE(returnIndex.getIndex()));

	    
	    il.append(classGen.loadTranslet());
	    if (_name == null) {
		il.append(new PUSH(cpg,""##id""));
	    }
	    else if (_resolvedQName != null) {
		il.append(new PUSH(cpg, _resolvedQName.toString()));
	    }
	    else {
		_name.translate(classGen, methodGen);
	    }

	    il.append(new INVOKEVIRTUAL(getKeyIndex));
	    il.append(new ASTORE(searchIndex.getIndex()));

	    

	    
	    
	    final BranchHandle nextNode = il.append(new GOTO(null));
	    final InstructionHandle loop = il.append(NOP);

	    
	    il.append(new ALOAD(returnIndex.getIndex()));
	    
	    
	    il.append(new ALOAD(searchIndex.getIndex()));
	    il.append(DUP);
	    il.append(methodGen.loadDOM());
	    il.append(methodGen.loadCurrentNode());
	    il.append(new INVOKEINTERFACE(getNodeValue, 2));
	    if (_name == null) {
		il.append(new INVOKEVIRTUAL(lookupId));
	    }
	    else {
		il.append(new INVOKEVIRTUAL(lookupKey));
	    }

	    
	    il.append(new INVOKEVIRTUAL(merge));
		
	    
	    nextNode.setTarget(il.append(methodGen.loadIterator()));
	    il.append(methodGen.nextNode());
	    il.append(DUP);
	    il.append(methodGen.storeCurrentNode());
	    il.append(new IFNE(loop));

	    

	    
	    il.append(methodGen.storeIterator());
	    il.append(methodGen.storeCurrentNode());

	    
	    il.append(new ALOAD(returnIndex.getIndex()));
	}
	
	
	else {
	    
	    
	    il.append(classGen.loadTranslet());
	    if (_name == null) {
		il.append(new PUSH(cpg,""##id""));
	    }
	    else if (_resolvedQName != null) {
		il.append(new PUSH(cpg, _resolvedQName.toString()));
	    }
	    else {
		_name.translate(classGen, methodGen);
	    }
	    il.append(new INVOKEVIRTUAL(getKeyIndex));

	    
	    
	    il.append(DUP);

	    if (_valueType == Type.Int || _valueType == Type.Real) {
		final int dbl = cpg.addMethodref(DOUBLE_CLASS,""<init>"", ""(D)V"");
		il.append(new NEW(cpg.addClass(DOUBLE_CLASS)));
		il.append(DUP);
		_value.translate(classGen, methodGen);
		if (_valueType == Type.Int)
		    il.append(new I2D());
		il.append(new INVOKESPECIAL(dbl));
	    }
	    else {
		_value.translate(classGen, methodGen);
	    }

	    if (_name == null) {
		il.append(new INVOKEVIRTUAL(lookupId));
	    }
	    else {
		il.append(new INVOKEVIRTUAL(lookupKey));
	    }
	}
    }
}
"
org.apache.xpath.objects.XObject,42,2,7,146,68,819,133,15,40,0.953929539,465,0.111111111,0,0.428571429,0.120879121,2,8,9.857142857,4,1.1667,0,"
package org.apache.xpath.objects;

import org.w3c.dom.DocumentFragment;


import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;
import org.apache.xml.dtm.*;

import java.io.Serializable;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPathException;
import org.apache.xpath.XPathVisitor;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xml.utils.XMLString;


public class XObject extends Expression implements Serializable, Cloneable
{

  
  protected Object m_obj;  

  
  public XObject(){}

  
  public XObject(Object obj)
  {
    m_obj = obj;
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return this;
  }

  
  public void allowDetachToRelease(boolean allowRelease){}

  
  public void detach(){}

  
  public void destruct()
  {

    if (null != m_obj)
    {
      allowDetachToRelease(true);
      detach();

      m_obj = null;
    }
  }
  
  
  public void reset()
  {
  }

  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {
    xstr().dispatchCharactersEvents(ch);
  }

  
  static public XObject create(Object val)
  {
    return XObjectFactory.create(val);
  }
  
  
  static public XObject create(Object val, XPathContext xctxt)
  {
    return XObjectFactory.create(val, xctxt);
  }

  
  public static final int CLASS_NULL = -1;

  
  public static final int CLASS_UNKNOWN = 0;

  
  public static final int CLASS_BOOLEAN = 1;

  
  public static final int CLASS_NUMBER = 2;

  
  public static final int CLASS_STRING = 3;

  
  public static final int CLASS_NODESET = 4;

  
  public static final int CLASS_RTREEFRAG = 5;

  
  public static final int CLASS_UNRESOLVEDVARIABLE = 600;

  
  public int getType()
  {
    return CLASS_UNKNOWN;
  }

  
  public String getTypeString()
  {
    return ""#UNKNOWN ("" + object().getClass().getName() + "")"";
  }

  
  public double num() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NUMBER,
          new Object[]{ getTypeString() });  

    return 0.0;
  }
  
  
  public double numWithSideEffects()  throws javax.xml.transform.TransformerException
  {
    return num();
  }

  
  public boolean bool() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NUMBER,
          new Object[]{ getTypeString() });  

    return false;
  }
  
  
  public boolean boolWithSideEffects() throws javax.xml.transform.TransformerException
  {
    return bool();
  }


  
  public XMLString xstr()
  {
    return XMLStringFactoryImpl.getFactory().newstr(str());
  }

  
  public String str()
  {
    return (m_obj != null) ? m_obj.toString() : """";
  }

  
  public String toString()
  {
    return str();
  }

  
  public int rtf(XPathContext support)
  {

    int result = rtf();

    if (DTM.NULL == result)
    {
      DTM frag = support.createDocumentFragment();

      
      frag.appendTextChild(str());

      result = frag.getDocument();
    }

    return result;
  }
  
  
  public DocumentFragment rtree(XPathContext support)
  {
    DocumentFragment docFrag = null;
    int result = rtf();

    if (DTM.NULL == result)
    {
      DTM frag = support.createDocumentFragment();

      
      frag.appendTextChild(str());

      docFrag = (DocumentFragment)frag.getNode(frag.getDocument());
    }
    else
    {
      DTM frag = support.getDTM(result);
      docFrag = (DocumentFragment)frag.getNode(frag.getDocument());
    }

    return docFrag;
  }
  
  
  
  public DocumentFragment rtree()
  {
    return null;
  }

  
  public int rtf()
  {
    return DTM.NULL;
  }

  
  public Object object()
  {
    return m_obj;
  }

  
  public DTMIterator iter() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NODELIST,
          new Object[]{ getTypeString() });  

    return null;
  }
  
  
  public XObject getFresh()
  {
    return this;
  }

  
  
  public NodeIterator nodeset() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NODELIST,
          new Object[]{ getTypeString() });  

    return null;
  }
  
  
  public NodeList nodelist() throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_NODELIST,
          new Object[]{ getTypeString() });  

    return null;
  }


  
  public NodeSetDTM mutableNodeset()
          throws javax.xml.transform.TransformerException
  {

    error(XPATHErrorResources.ER_CANT_CONVERT_TO_MUTABLENODELIST,
          new Object[]{ getTypeString() });  

    return (NodeSetDTM) m_obj;
  }

  
  public Object castToType(int t, XPathContext support)
          throws javax.xml.transform.TransformerException
  {

    Object result;

    switch (t)
    {
    case CLASS_STRING :
      result = str();
      break;
    case CLASS_NUMBER :
      result = new Double(num());
      break;
    case CLASS_NODESET :
      result = iter();
      break;
    case CLASS_BOOLEAN :
      result = new Boolean(bool());
      break;
    case CLASS_UNKNOWN :
      result = m_obj;
      break;

    
    
    
    
    default :
      error(XPATHErrorResources.ER_CANT_CONVERT_TO_TYPE,
            new Object[]{ getTypeString(),
                          Integer.toString(t) });  

      result = null;
    }

    return result;
  }

  
  public boolean lessThan(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.greaterThan(this);

    return this.num() < obj2.num();
  }

  
  public boolean lessThanOrEqual(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.greaterThanOrEqual(this);

    return this.num() <= obj2.num();
  }

  
  public boolean greaterThan(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.lessThan(this);

    return this.num() > obj2.num();
  }

  
  public boolean greaterThanOrEqual(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.lessThanOrEqual(this);

    return this.num() >= obj2.num();
  }

  
  public boolean equals(XObject obj2)
  {

    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.equals(this);

    if (null != m_obj)
    {
      return m_obj.equals(obj2.m_obj);
    }
    else
    {
      return obj2.m_obj == null;
    }
  }

  
  public boolean notEquals(XObject obj2)
          throws javax.xml.transform.TransformerException
  {

    
    
    
    if (obj2.getType() == XObject.CLASS_NODESET)
      return obj2.notEquals(this);

    return !equals(obj2);
  }

  
  protected void error(int msg)
          throws javax.xml.transform.TransformerException
  {
    error(msg, null);
  }

  
  protected void error(int msg, Object[] args)
          throws javax.xml.transform.TransformerException
  {

    String fmsg = XSLMessages.createXPATHMessage(msg, args);

    
    
    
    
    
    {
      throw new XPathException(fmsg, this);
    }
  }
  
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }


  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    fsb.append(str());
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	assertion(false, ""callVisitors should not be called for this object!!!"");
  }

  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	
  	
  	
  	if(!this.equals((XObject)expr))
  		return false;
  		
  	return true;
  }

}
"
org.apache.xml.utils.SystemIDResolver,4,1,0,14,23,6,12,2,4,2.0,295,0.0,0,0.0,0.5,0,0,72.75,6,2.0,1,"
package org.apache.xml.utils;

import javax.xml.transform.TransformerException;

import org.apache.xml.utils.URI;
import org.apache.xml.utils.URI.MalformedURIException;

import java.io.*;

import java.lang.StringBuffer;


public class SystemIDResolver
{

  
  public static String getAbsoluteURIFromRelative(String uri)
  {

    String curdir = """";
    try {
      curdir = System.getProperty(""user.dir"");
    }
    catch (SecurityException se) {}

    if (null != curdir)
    {
      String base;
      if (curdir.startsWith(File.separator))
        base = ""file:
      else
        base = ""file:
        
      if (uri != null)
        
        
        
        
        uri = base + System.getProperty(""file.separator"") + uri;
      else
        uri = base + System.getProperty(""file.separator"");
    }

    if (null != uri && (uri.indexOf('\') > -1))
      uri = uri.replace('\', '/');

    return uri;
  }
  
  
  public static String getAbsoluteURI(String url)
          throws TransformerException
  {
    if (url.startsWith(""..""))
      url = new File(url).getAbsolutePath();
      
    if (url.startsWith(File.separator))
    {
      
      
      url = ""file:
    }
    else if (url.indexOf(':') < 0)
    {
      
      
      
      url = getAbsoluteURIFromRelative(url);
    }

    
    
    
    
    
    
    
    
    
    

    return url;
  }


  
  public static String getAbsoluteURI(String urlString, String base)
          throws TransformerException
  {
    boolean isAbsouteUrl = false;
    boolean needToResolve = false;    
 
    
    
    
    
    
    
    
    
    
    
    
    if (urlString.indexOf(':') > 0)
    {
      
      
      isAbsouteUrl = true;
    }
    else if (urlString.startsWith(File.separator))
    {
      
      
      urlString = ""file:
      isAbsouteUrl = true;
    }

    if ((!isAbsouteUrl) && ((null == base)
            || (base.indexOf(':') < 0)))
    {
      if (base != null && base.startsWith(File.separator))
        base = ""file:
      else
        base = getAbsoluteURIFromRelative(base);
    }

    
    if ((null != base) && needToResolve) 
         
    {
      if(base.equals(urlString))
      {
        base = """";
      }
      else
      {
        urlString = urlString.substring(5);
        isAbsouteUrl = false;
      }
    }   

    
    if (null != base && (base.indexOf('\') > -1))
      base = base.replace('\', '/');

    if (null != urlString && (urlString.indexOf('\') > -1))
      urlString = urlString.replace('\', '/');

    URI uri;

    try
    {
      if ((null == base) || (base.length() == 0) || (isAbsouteUrl))
      {
        uri = new URI(urlString);
      }
      else
      {
        URI baseURI = new URI(base);

        uri = new URI(baseURI, urlString);
      }
    }
    catch (MalformedURIException mue)
    {
      throw new TransformerException(mue);
    }

    String uriStr = uri.toString();
    
    
    
    if((Character.isLetter(uriStr.charAt(0)) && (uriStr.charAt(1) == ':') 
     && (uriStr.charAt(2) == '/') && (uriStr.length() == 3 || uriStr.charAt(3) != '/'))
       || ((uriStr.charAt(0) == '/') && (uriStr.length() == 1 || uriStr.charAt(1) != '/')))
    {
    	uriStr = ""file:
    }
    return uriStr;
  }
}
"
org.apache.xml.dtm.ref.DTMStringPool,5,1,2,6,24,0,5,1,5,0.6,419,0.0,1,0.0,0.35,0,0,81.8,8,3.4,0,"

package org.apache.xml.dtm.ref;



import org.apache.xml.utils.IntVector;
import java.util.Vector;


public class DTMStringPool
{
  Vector m_intToString;
  static final int HASHPRIME=101;
  int[] m_hashStart=new int[HASHPRIME];
  IntVector m_hashChain;
  public static final int NULL=-1;

  public DTMStringPool()
    {
      m_intToString=new Vector();
      m_hashChain=new IntVector(512);
      removeAllElements();
      
      
      stringToIndex("""");
    }
  
  public void removeAllElements()
    {
      m_intToString.removeAllElements();
      for(int i=0;i<HASHPRIME;++i)
        m_hashStart[i]=NULL;
      m_hashChain.removeAllElements();
    }

   
  public String indexToString(int i)
    throws java.lang.ArrayIndexOutOfBoundsException
    {
      if(i==NULL) return null;
      return (String) m_intToString.elementAt(i);
    }

   
  public int stringToIndex(String s)
    {
      if(s==null) return NULL;
      
      int hashslot=s.hashCode()%HASHPRIME;
      if(hashslot<0) hashslot=-hashslot;

      
      int hashlast=m_hashStart[hashslot];
      int hashcandidate=hashlast;
      while(hashcandidate!=NULL)
        {
          if(m_intToString.elementAt(hashcandidate).equals(s))
            return hashcandidate;

          hashlast=hashcandidate;
          hashcandidate=m_hashChain.elementAt(hashcandidate);
        }
      
      
      int newIndex=m_intToString.size();
      m_intToString.addElement(s);

      m_hashChain.addElement(NULL);	
      if(hashlast==NULL)  
        m_hashStart[hashslot]=newIndex;
      else 
        m_hashChain.setElementAt(newIndex,hashlast);

      return newIndex;
    }

  
  public static void main(String[] args)
  {
    String[] word={
      ""Zero"",""One"",""Two"",""Three"",""Four"",""Five"",
      ""Six"",""Seven"",""Eight"",""Nine"",""Ten"",
      ""Eleven"",""Twelve"",""Thirteen"",""Fourteen"",""Fifteen"",
      ""Sixteen"",""Seventeen"",""Eighteen"",""Nineteen"",""Twenty"",
      ""Twenty-One"",""Twenty-Two"",""Twenty-Three"",""Twenty-Four"",
      ""Twenty-Five"",""Twenty-Six"",""Twenty-Seven"",""Twenty-Eight"",
      ""Twenty-Nine"",""Thirty"",""Thirty-One"",""Thirty-Two"",
      ""Thirty-Three"",""Thirty-Four"",""Thirty-Five"",""Thirty-Six"",
      ""Thirty-Seven"",""Thirty-Eight"",""Thirty-Nine""};

    DTMStringPool pool=new DTMStringPool();

    System.out.println(""If no complaints are printed below, we passed initial test."");

    for(int pass=0;pass<=1;++pass)
      {
        int i;

        for(i=0;i<word.length;++i)
          {
            int j=pool.stringToIndex(word[i]);
            if(j!=i)
              System.out.println(""	Mismatch populating pool: assigned ""+
                                 j+"" for create ""+i);
          }

        for(i=0;i<word.length;++i)
          {
            int j=pool.stringToIndex(word[i]);
            if(j!=i)
              System.out.println(""	Mismatch in stringToIndex: returned ""+
                                 j+"" for lookup ""+i);
          }

        for(i=0;i<word.length;++i)
          {
            String w=pool.indexToString(i);
            if(!word[i].equals(w))
              System.out.println(""	Mismatch in indexToString: returned""+
                                 w+"" for lookup ""+i);
          }
        
        pool.removeAllElements();
        
        System.out.println(""
Pass ""+pass+"" complete
"");
      } 
  }
}
"
org.apache.xpath.functions.FuncNot,2,4,0,5,5,1,0,5,2,2.0,15,0.0,0,0.979591837,0.75,1,6,6.5,1,0.5,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class FuncNot extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return m_arg0.execute(xctxt).bool() ? XBoolean.S_FALSE : XBoolean.S_TRUE;
  }
}
"
org.apache.xalan.templates.XMLNSDecl,4,1,0,2,5,0,2,0,4,0.666666667,28,1.0,0,0.0,0.5,0,0,5.25,1,0.75,0,"
package org.apache.xalan.templates;


public class XMLNSDecl
        implements java.io.Serializable 
{

  
  public XMLNSDecl(String prefix, String uri, boolean isExcluded)
  {

    m_prefix = prefix;
    m_uri = uri;
    m_isExcluded = isExcluded;
  }

  
  private String m_prefix;

  
  public String getPrefix()
  {
    return m_prefix;
  }

  
  private String m_uri;

  
  public String getURI()
  {
    return m_uri;
  }

  
  private boolean m_isExcluded;

  
  public boolean getIsExcluded()
  {
    return m_isExcluded;
  }
}
"
org.apache.xpath.functions.FuncSystemProperty,5,4,0,8,37,6,0,8,3,0.65,253,0.4,0,0.941176471,0.4375,2,7,48.6,4,1.2,0,"
package org.apache.xpath.functions;

import java.util.Properties;

import java.io.BufferedInputStream;
import java.io.InputStream;

import java.lang.ClassLoader;

import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.res.XPATHErrorResources;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XString;


public class FuncSystemProperty extends FunctionOneArg
{

  
  static String XSLT_PROPERTIES = ""org/apache/xalan/res/XSLTInfo.properties"";
	
	
  private static final Class[] NO_CLASSES = new Class[0];

  
  private static final Object[] NO_OBJS = new Object[0];


  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String fullName = m_arg0.execute(xctxt).str();
    int indexOfNSSep = fullName.indexOf(':');
    String result;
    String propName = """";
    
    
    Properties xsltInfo = new Properties();

    loadPropertyFile(XSLT_PROPERTIES, xsltInfo);

    if (indexOfNSSep > 0)
    {
      String prefix = (indexOfNSSep >= 0)
                      ? fullName.substring(0, indexOfNSSep) : """";
      String namespace;

      namespace = xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);
      propName = (indexOfNSSep < 0)
                 ? fullName : fullName.substring(indexOfNSSep + 1);

      if (namespace.startsWith(""http:
              || namespace.equals(""http:
      {
        result = xsltInfo.getProperty(propName);

        if (null == result)
        {
          warn(xctxt, XPATHErrorResources.WG_PROPERTY_NOT_SUPPORTED,
               new Object[]{ fullName });  

          return XString.EMPTYSTRING;
        }
      }
      else
      {
        warn(xctxt, XPATHErrorResources.WG_DONT_DO_ANYTHING_WITH_NS,
             new Object[]{ namespace,
                           fullName });  

        try
        {
          result = System.getProperty(propName);

          if (null == result)
          {

            
            return XString.EMPTYSTRING;
          }
        }
        catch (SecurityException se)
        {
          warn(xctxt, XPATHErrorResources.WG_SECURITY_EXCEPTION,
               new Object[]{ fullName });  

          return XString.EMPTYSTRING;
        }
      }
    }
    else
    {
      try
      {
        result = System.getProperty(fullName);

        if (null == result)
        {

          
          return XString.EMPTYSTRING;
        }
      }
      catch (SecurityException se)
      {
        warn(xctxt, XPATHErrorResources.WG_SECURITY_EXCEPTION,
             new Object[]{ fullName });  

        return XString.EMPTYSTRING;
      }
    }

    if (propName.equals(""version"") && result.length() > 0)
    {
      try
      {
        
        return new XNumber(1.0);
      }
      catch (Exception ex)
      {
        return new XString(result);
      }
    }
    else
      return new XString(result);
  }

  
  public void loadPropertyFile(String file, Properties target)
  {

    InputStream is = null;

    try
    {
      try {
        java.lang.reflect.Method getCCL = Thread.class.getMethod(""getContextClassLoader"", NO_CLASSES);
        if (getCCL != null) {
          ClassLoader contextClassLoader = (ClassLoader) getCCL.invoke(Thread.currentThread(), NO_OBJS);
          is = contextClassLoader.getResourceAsStream(file); 
        }
      }
      catch (Exception e) {}

      if (is == null) {
        
        
        
        is = FuncSystemProperty.class.getResourceAsStream(""/"" + file); 
      }

      
      BufferedInputStream bis = new BufferedInputStream(is);

      target.load(bis);  
      bis.close();  
    }
    catch (Exception ex)
    {
      
      throw new org.apache.xml.utils.WrappedRuntimeException(ex);
    }
  }
}
"
org.apache.xalan.xsltc.cmdline.Compile,4,1,0,4,40,0,0,4,3,0.333333333,240,1.0,0,0.0,0.333333333,0,0,58.0,12,3.75,0,"

package org.apache.xalan.xsltc.cmdline;

import java.io.*;
import java.util.Vector;
import java.net.URL;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.TransletOutputHandler;

import org.apache.xalan.xsltc.compiler.XSLTC;
import org.apache.xalan.xsltc.compiler.util.Util;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.xalan.xsltc.cmdline.getopt.*;

public final class Compile {

    
    private static int VERSION_MAJOR = 1;
    private static int VERSION_MINOR = 2;
    private static int VERSION_DELTA = 0;
 

    
    
    
    
    private static boolean _allowExit = true;

    public static void printUsage() {
        StringBuffer vers = new StringBuffer(""XSLTC version "" + 
	    VERSION_MAJOR + ""."" + VERSION_MINOR + 
	    ((VERSION_DELTA > 0) ? ("".""+VERSION_DELTA) : ("""")));
	System.err.println(vers + ""
"" + 
		new ErrorMsg(ErrorMsg.COMPILE_USAGE_STR));
	if (_allowExit) System.exit(-1);
    }

    
    public static void main(String[] args) {
	try {
	    boolean inputIsURL = false;
	    boolean useStdIn = false;
	    boolean classNameSet = false;
	    final GetOpt getopt = new GetOpt(args, ""o:d:j:p:uxhsinv"");
	    if (args.length < 1) printUsage();

	    final XSLTC xsltc = new XSLTC();
	    xsltc.init();

	    int c;
	    while ((c = getopt.getNextOption()) != -1) {
		switch(c) {
		case 'i':
		    useStdIn = true;
		    break;
		case 'o':
		    xsltc.setClassName(getopt.getOptionArg());
		    classNameSet = true;
		    break;
		case 'd':
		    xsltc.setDestDirectory(getopt.getOptionArg());
		    break;
		case 'p':
		    xsltc.setPackageName(getopt.getOptionArg());
		    break;
		case 'j':  
		    xsltc.setJarFileName(getopt.getOptionArg());
		    break;
		case 'x':
		    xsltc.setDebug(true);
		    break;
		case 'u':
		    inputIsURL = true;
		    break;
		case 's':
		    _allowExit = false;
		    break;
		case 'n':
		    xsltc.setTemplateInlining(false);
		    break;
		case 'v':
		    
		case 'h':
		default:
		    printUsage();
		    break; 
		}
	    }

	    boolean compileOK;

	    if (useStdIn) {
		if (!classNameSet) {
		    System.err.println(new ErrorMsg(ErrorMsg.COMPILE_STDIN_ERR));
		    if (_allowExit) System.exit(-1);
		}
		compileOK = xsltc.compile(System.in, xsltc.getClassName());
	    }
	    else {
		
		final String[] stylesheetNames = getopt.getCmdArgs();
		final Vector   stylesheetVector = new Vector();
		for (int i = 0; i < stylesheetNames.length; i++) {
		    final String name = stylesheetNames[i];
		    URL url;
		    if (inputIsURL)
			url = new URL(name);
		    else
			url = (new File(name)).toURL();
		    stylesheetVector.addElement(url);
		}
		compileOK = xsltc.compile(stylesheetVector);
	    }

	    
	    if (compileOK) {
		xsltc.printWarnings();
		if (xsltc.getJarFileName() != null) xsltc.outputToJar();
		if (_allowExit) System.exit(0);
	    }
	    else {
		xsltc.printWarnings();
		xsltc.printErrors();
		if (_allowExit) System.exit(-1);
	    }
	}
	catch (GetOptsException ex) {
	    System.err.println(ex);
	    printUsage(); 
	}
	catch (Exception e) {
	    e.printStackTrace();
	    if (_allowExit) System.exit(-1);
	}
    }

}
"
org.apache.xalan.transformer.XSLInfiniteLoopException,2,1,0,0,3,1,0,0,1,2.0,7,0.0,0,0.0,1.0,0,0,2.5,1,0.5,0,"
package org.apache.xalan.transformer;


class XSLInfiniteLoopException
{

  
  XSLInfiniteLoopException()
  {
    super();
  }

  
  public String getMessage()
  {
    return ""Processing Terminated."";
  }
}
"
org.apache.xalan.xsltc.compiler.ContainsCall,5,4,0,20,22,4,0,20,5,0.25,126,1.0,2,0.96,0.4,3,14,23.8,1,0.8,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.TypeCheckError;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class ContainsCall extends FunctionCall {

    private Expression _base = null;
    private Expression _token = null;

    
    public ContainsCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public boolean isBoolean() {
	return true;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	if (argumentCount() != 2) {
	    throw new TypeCheckError(ErrorMsg.ILLEGAL_ARG_ERR, getName(), this);
	}

	
	_base = argument(0);
	Type baseType = _base.typeCheck(stable);	
	if (baseType != Type.String)
	    _base = new CastExpr(_base, Type.String);

	
	_token = argument(1);
	Type tokenType = _token.typeCheck(stable);	
	if (tokenType != Type.String)
	    _token = new CastExpr(_token, Type.String);

	return _type = Type.Boolean;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	translateDesynthesized(classGen, methodGen);
	synthesize(classGen, methodGen);
    }

    
    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	_base.translate(classGen, methodGen);
	_token.translate(classGen, methodGen);
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_CLASS,
						     ""indexOf"",
						     ""(""+STRING_SIG+"")I"")));
	_falseList.add(il.append(new IFLT(null)));
    }
}
"
org.apache.xalan.xsltc.dom.NodeIteratorBase,14,1,28,40,22,55,38,2,12,0.807692308,140,1.0,0,0.0,0.404761905,0,0,8.571428571,3,1.2143,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public abstract class NodeIteratorBase implements NodeIterator {
    private int _last = -1;
    protected int _position = 0;

    protected int _markedNode;
    protected int _startNode = NodeIterator.END;
    protected boolean _includeSelf = false;
    protected boolean _isRestartable = true;

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
    }

    public NodeIterator reset() {
	final boolean temp = _isRestartable;
	_isRestartable = true;
	
	setStartNode(_includeSelf ? _startNode + 1 : _startNode);
	_isRestartable = temp;
	return this;
    }

    public NodeIterator includeSelf() {
	_includeSelf = true;
	return this;
    }

    public int getLast() {
	if (_last == -1) {
	    final int temp = _position;
	    setMark();
	    reset();
	    do {
		_last++;
	    } while (next() != END);
	    gotoMark();
	    _position = temp;
	}
	return _last;
    }

    public int getPosition() {
	return _position == 0 ? 1 : _position;
    }

    public boolean isReverse() {
	return false;
    }
    
    public NodeIterator cloneIterator() {
	try {
	    final NodeIteratorBase clone = (NodeIteratorBase)super.clone();
	    clone._isRestartable = false;
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    protected final int returnNode(final int node) {
	_position++;
	return node;
    }
    
    protected final NodeIterator resetPosition() {
	_position = 0;
	return this;
    }

}
"
org.apache.xalan.processor.XSLTElementDef,37,1,1,8,57,440,6,4,0,0.793209877,804,0.722222222,3,0.0,0.289189189,0,0,20.24324324,15,2.2162,1,"
package org.apache.xalan.processor;

import org.xml.sax.ContentHandler;

import org.apache.xalan.templates.Constants;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import java.util.Hashtable;
import java.util.Enumeration;


public class XSLTElementDef
{

  
  XSLTElementDef(){}

  
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject)
  {
    build(namespace, name, nameAlias, elements, attributes, contentHandler,
          classObject);
    if ( (null != namespace)
    &&  (namespace.equals(Constants.S_XSLNAMESPACEURL)
        || namespace.equals(Constants.S_BUILTIN_EXTENSIONS_URL)) )
    {
      schema.addAvailableElement(new QName(namespace, name));
      if(null != nameAlias)
        schema.addAvailableElement(new QName(namespace, nameAlias));
    } 
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, boolean has_required)
  {
		this.m_has_required = has_required;
    build(namespace, name, nameAlias, elements, attributes, contentHandler,
          classObject);
    if ( (null != namespace)
    &&  (namespace.equals(Constants.S_XSLNAMESPACEURL)
        || namespace.equals(Constants.S_BUILTIN_EXTENSIONS_URL)) )
    {
      schema.addAvailableElement(new QName(namespace, name));
      if(null != nameAlias)
        schema.addAvailableElement(new QName(namespace, nameAlias));
    } 
		
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 boolean has_required, boolean required)
  {
    this(schema, namespace, name,  nameAlias,
                 elements, attributes,
                 contentHandler, classObject, has_required);
		this.m_required = required;
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 boolean has_required, boolean required, int order, 
								 boolean multiAllowed)
  {
		this(schema, namespace, name,  nameAlias,
                 elements, attributes,
                 contentHandler, classObject, has_required, required);    
		this.m_order = order;
		this.m_multiAllowed = multiAllowed;
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 boolean has_required, boolean required, boolean has_order, int order, 
								 boolean multiAllowed)
  {
		this(schema, namespace, name,  nameAlias,
                 elements, attributes,
                 contentHandler, classObject, has_required, required);    
		this.m_order = order;
		this.m_multiAllowed = multiAllowed;
    this.m_isOrdered = has_order;		
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 boolean has_order, int order, boolean multiAllowed)
  {
    this(schema, namespace, name,  nameAlias,
                 elements, attributes,
                 contentHandler, classObject, 
								 order, multiAllowed);
		this.m_isOrdered = has_order;		
  }
	
	
  XSLTElementDef(XSLTSchema schema, String namespace, String name, String nameAlias,
                 XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
                 XSLTElementProcessor contentHandler, Class classObject, 
								 int order, boolean multiAllowed)
  {
    this(schema, namespace, name, nameAlias, elements, attributes, contentHandler,
          classObject);
    this.m_order = order;
		this.m_multiAllowed = multiAllowed;
  }

  
  XSLTElementDef(Class classObject, XSLTElementProcessor contentHandler,
                 int type)
  {

    this.m_classObject = classObject;
    this.m_type = type;

    setElementProcessor(contentHandler);
  }

  
  void build(String namespace, String name, String nameAlias,
             XSLTElementDef[] elements, XSLTAttributeDef[] attributes,
             XSLTElementProcessor contentHandler, Class classObject)
  {

    this.m_namespace = namespace;
    this.m_name = name;
    this.m_nameAlias = nameAlias;
    this.m_elements = elements;
    this.m_attributes = attributes;

    setElementProcessor(contentHandler);

    this.m_classObject = classObject;
		
		if (hasRequired() && m_elements != null)
		{
			int n = m_elements.length;
			for (int i = 0; i < n; i++)
			{
				XSLTElementDef def = m_elements[i];
				
				if (def != null && def.getRequired())
				{
					if (m_requiredFound == null)			
						m_requiredFound = new Hashtable();
					m_requiredFound.put(def.getName(), ""xsl:"" +def.getName()); 
				}
			}
		}
  }

  
  private static boolean equalsMayBeNull(Object obj1, Object obj2)
  {
    return (obj2 == obj1)
           || ((null != obj1) && (null != obj2) && obj2.equals(obj1));
  }

  
  private static boolean equalsMayBeNullOrZeroLen(String s1, String s2)
  {

    int len1 = (s1 == null) ? 0 : s1.length();
    int len2 = (s2 == null) ? 0 : s2.length();

    return (len1 != len2) ? false 
						 : (len1 == 0) ? true 
								 : s1.equals(s2);
  }

  
  static final int T_ELEMENT = 1, T_PCDATA = 2, T_ANY = 3;

  
  private int m_type = T_ELEMENT;

  
  int getType()
  {
    return m_type;
  }

  
  void setType(int t)
  {
    m_type = t;
  }

  
  private String m_namespace;

  
  String getNamespace()
  {
    return m_namespace;
  }

  
  private String m_name;

  
  String getName()
  {
    return m_name;
  }

  
  private String m_nameAlias;

  
  String getNameAlias()
  {
    return m_nameAlias;
  }

  
  private XSLTElementDef[] m_elements;

  
  XSLTElementDef[] getElements()
  {
    return m_elements;
  }

  
  void setElements(XSLTElementDef[] defs)
  {
    m_elements = defs;
  }

  
  private boolean QNameEquals(String uri, String localName)
  {

    return (equalsMayBeNullOrZeroLen(m_namespace, uri)
            && (equalsMayBeNullOrZeroLen(m_name, localName)
                || equalsMayBeNullOrZeroLen(m_nameAlias, localName)));
  }

  
  XSLTElementProcessor getProcessorFor(String uri, String localName) 
	{

    XSLTElementProcessor elemDef = null;  

    if (null == m_elements)
      return null;

    int n = m_elements.length;
    int order = -1;
		boolean multiAllowed = true;
    for (int i = 0; i < n; i++)
    {
      XSLTElementDef def = m_elements[i];

      
      
      
      if (def.m_name.equals(""*""))
      {
				
        
        if (!equalsMayBeNullOrZeroLen(uri, Constants.S_XSLNAMESPACEURL))
				{
          elemDef = def.m_elementProcessor;
				  order = def.getOrder();
					multiAllowed = def.getMultiAllowed();
				}
      }
			else if (def.QNameEquals(uri, localName))
			{	
				if (def.getRequired())
					this.setRequiredFound(def.getName(), true);
				order = def.getOrder();
				multiAllowed = def.getMultiAllowed();
				elemDef = def.m_elementProcessor;
				break;
			}
		}		
		
		if (elemDef != null && this.isOrdered())
		{			
			int lastOrder = getLastOrder();
			if (order > lastOrder)
				setLastOrder(order);
			else if (order == lastOrder && !multiAllowed)
			{
				return null;
			}
			else if (order < lastOrder && order > 0)
			{
				return null;
			}
		}

    return elemDef;
  }

  
  XSLTElementProcessor getProcessorForUnknown(String uri, String localName)
  {

    
    if (null == m_elements)
      return null;

    int n = m_elements.length;

    for (int i = 0; i < n; i++)
    {
      XSLTElementDef def = m_elements[i];

      if (def.m_name.equals(""unknown"") && uri.length() > 0)
      {
        return def.m_elementProcessor;
      }
    }

    return null;
  }

  
  private XSLTAttributeDef[] m_attributes;

  
  XSLTAttributeDef[] getAttributes()
  {
    return m_attributes;
  }

  
  XSLTAttributeDef getAttributeDef(String uri, String localName)
  {

    XSLTAttributeDef defaultDef = null;
    XSLTAttributeDef[] attrDefs = getAttributes();
    int nAttrDefs = attrDefs.length;

    for (int k = 0; k < nAttrDefs; k++)
    {
      XSLTAttributeDef attrDef = attrDefs[k];
      String uriDef = attrDef.getNamespace();
      String nameDef = attrDef.getName();
      
      if (nameDef.equals(""*"") && (equalsMayBeNullOrZeroLen(uri, uriDef) || 
          (uriDef != null && uriDef.equals(""*"") && uri!=null && uri.length() > 0 )))
      {
        return attrDef;
      }
      else if (nameDef.equals(""*"") && (uriDef == null))
      {

        
        
        defaultDef = attrDef;
      }
      else if (equalsMayBeNullOrZeroLen(uri, uriDef)
               && localName.equals(nameDef))
      {
        return attrDef;
      }
    }

    if (null == defaultDef)
    {
      if (uri.length() > 0 && !equalsMayBeNullOrZeroLen(uri, Constants.S_XSLNAMESPACEURL))
      {
        return XSLTAttributeDef.m_foreignAttr;
      }
    }

    return defaultDef;
  }

  
  private XSLTElementProcessor m_elementProcessor;

  
  XSLTElementProcessor getElementProcessor()
  {
    return m_elementProcessor;
  }

  
  void setElementProcessor(XSLTElementProcessor handler)
  {

    if (handler != null)
    {
      m_elementProcessor = handler;

      m_elementProcessor.setElemDef(this);
    }
  }

  
  private Class m_classObject;

  
  Class getClassObject()
  {
    return m_classObject;
  }
	
	
  private boolean m_has_required = false;

  
  boolean hasRequired()
  {
    return m_has_required;
  }
	
	
  private boolean m_required = false;

  
  boolean getRequired()
  {
    return m_required;
  }
	
	Hashtable m_requiredFound;
	
	
  void setRequiredFound(String elem, boolean found)
  {
   if (m_requiredFound.get(elem) != null) 
		 m_requiredFound.remove(elem);
  }
	
	
  boolean getRequiredFound()
  {
		if (m_requiredFound == null)
			return true;
    return m_requiredFound.isEmpty();
  }
	
	
  String getRequiredElem()
  {
		if (m_requiredFound == null)
			return null;
		Enumeration elems = m_requiredFound.elements();
		String s = """";
		boolean first = true;
		while (elems.hasMoreElements())
		{
			if (first)
				first = false;
			else
			 s = s + "", "";
			s = s + (String)elems.nextElement();
		}
    return s;
  }
	
	boolean m_isOrdered = false;	
	
	
  boolean isOrdered()
  {
		
			return m_isOrdered;
  }
	
	
  private int m_order = -1;
	
	
  int getOrder()
  {
    return m_order;
  }
	
	
  private int m_lastOrder = -1;
	
	
  int getLastOrder()
  {
    return m_lastOrder;
  }
	
	
  void setLastOrder(int order)
  {
    m_lastOrder = order ;
  }
	
	
  private boolean m_multiAllowed = true;
	
	
  boolean getMultiAllowed()
  {
    return m_multiAllowed;
  }
}
"
org.apache.xalan.xsltc.compiler.Pattern,4,3,2,17,5,6,11,6,4,2.0,7,0.0,0,0.959459459,0.4375,2,4,0.75,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.*;

public abstract class Pattern extends Expression {
    
    public abstract Type typeCheck(SymbolTable stable) throws TypeCheckError;

    
    public abstract void translate(ClassGenerator classGen,
				   MethodGenerator methodGen);

    
    public abstract double getPriority();
}
"
org.apache.xalan.transformer.NumeratorFormatter,4,1,0,3,11,4,1,3,0,1.095238095,360,0.428571429,3,0.0,0.428571429,0,0,87.25,7,3.5,0,"
package org.apache.xalan.transformer;

import org.w3c.dom.Element;
import org.w3c.dom.Node;

import java.util.Locale;
import java.util.NoSuchElementException;


class NumeratorFormatter
{

  
  protected Element m_xslNumberElement;

  
  NumberFormatStringTokenizer m_formatTokenizer;

  
  Locale m_locale;

  
  java.text.NumberFormat m_formatter;

  
  TransformerImpl m_processor;

  
  private final static DecimalToRoman m_romanConvertTable[] = {
    new DecimalToRoman(1000, ""M"", 900, ""CM""),
    new DecimalToRoman(500, ""D"", 400, ""CD""),
    new DecimalToRoman(100L, ""C"", 90L, ""XC""),
    new DecimalToRoman(50L, ""L"", 40L, ""XL""),
    new DecimalToRoman(10L, ""X"", 9L, ""IX""),
    new DecimalToRoman(5L, ""V"", 4L, ""IV""),
    new DecimalToRoman(1L, ""I"", 1L, ""I"") };

  
  private final static char[] m_alphaCountTable = { 'Z',  
                                                    'A', 'B', 'C', 'D', 'E',
                                                    'F', 'G', 'H', 'I', 'J',
                                                    'K', 'L', 'M', 'N', 'O',
                                                    'P', 'Q', 'R', 'S', 'T',
                                                    'U', 'V', 'W', 'X', 'Y' };

  
  NumeratorFormatter(Element xslNumberElement, TransformerImpl processor)
  {
    m_xslNumberElement = xslNumberElement;
    m_processor = processor;
  }  

  
  protected String int2alphaCount(int val, char[] table)
  {

    int radix = table.length;

    
    
    
    char buf[] = new char[100];

    
    int charPos = buf.length - 1;  

    
    int lookupIndex = 1;  

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    int correction = 0;

    
    do
    {

      
      
      
      correction =
        ((lookupIndex == 0) || (correction != 0 && lookupIndex == radix - 1))
        ? (radix - 1) : 0;

      
      lookupIndex = (val + correction) % radix;

      
      val = (val / radix);

      
      if (lookupIndex == 0 && val == 0)
        break;

      
      buf[charPos--] = table[lookupIndex];
    }
    while (val > 0);

    return new String(buf, charPos + 1, (buf.length - charPos - 1));
  }

  
  String long2roman(long val, boolean prefixesAreOK)
  {

    if (val <= 0)
    {
      return ""#E("" + val + "")"";
    }

    String roman = """";
    int place = 0;

    if (val <= 3999L)
    {
      do
      {
        while (val >= m_romanConvertTable[place].m_postValue)
        {
          roman += m_romanConvertTable[place].m_postLetter;
          val -= m_romanConvertTable[place].m_postValue;
        }

        if (prefixesAreOK)
        {
          if (val >= m_romanConvertTable[place].m_preValue)
          {
            roman += m_romanConvertTable[place].m_preLetter;
            val -= m_romanConvertTable[place].m_preValue;
          }
        }

        place++;
      }
      while (val > 0);
    }
    else
    {
      roman = ""#error"";
    }

    return roman;
  }  

  
  class NumberFormatStringTokenizer
  {

    
    private int currentPosition;

    
    private int maxPosition;

    
    private String str;

    
    NumberFormatStringTokenizer(String str)
    {
      this.str = str;
      maxPosition = str.length();
    }
    
    
    void reset()
    {
      currentPosition = 0;
    }

    
    String nextToken()
    {

      if (currentPosition >= maxPosition)
      {
        throw new NoSuchElementException();
      }

      int start = currentPosition;

      while ((currentPosition < maxPosition)
             && Character.isLetterOrDigit(str.charAt(currentPosition)))
      {
        currentPosition++;
      }

      if ((start == currentPosition)
              && (!Character.isLetterOrDigit(str.charAt(currentPosition))))
      {
        currentPosition++;
      }

      return str.substring(start, currentPosition);
    }

    
    boolean hasMoreTokens()
    {
      return (currentPosition >= maxPosition) ? false : true;
    }

    
    int countTokens()
    {

      int count = 0;
      int currpos = currentPosition;

      while (currpos < maxPosition)
      {
        int start = currpos;

        while ((currpos < maxPosition)
               && Character.isLetterOrDigit(str.charAt(currpos)))
        {
          currpos++;
        }

        if ((start == currpos)
                && (Character.isLetterOrDigit(str.charAt(currpos)) == false))
        {
          currpos++;
        }

        count++;
      }

      return count;
    }
  }  
}
"
org.apache.xalan.xsltc.compiler.StringCall,3,4,0,14,17,3,0,14,3,2.0,75,0.0,0,0.979591837,0.444444444,3,13,24.0,3,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class StringCall extends FunctionCall {
    public StringCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final int argc = argumentCount();
	if (argc > 1) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ILLEGAL_ARG_ERR, this);
	    throw new TypeCheckError(err);
	}

	if (argc > 0) {
	    argument().typeCheck(stable);
	}
	return _type = Type.String;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	Type targ;

	if (argumentCount() == 0) {
	    il.append(methodGen.loadContextNode());
	    targ = Type.Node;
	}
	else {
	    final Expression arg = argument();
	    arg.translate(classGen, methodGen);
	    arg.startResetIterator(classGen, methodGen);
	    targ = arg.getType();
	}

	if (!targ.identicalTo(Type.String)) {
	    targ.translateTo(classGen, methodGen, Type.String);
	}
    }
}
"
org.apache.xalan.extensions.MethodResolver,13,1,0,11,70,66,2,9,6,0.952898551,1997,0.043478261,7,0.0,0.266666667,0,0,150.8461538,14,3.2308,1,"

package org.apache.xalan.extensions;

import java.lang.reflect.Method;
import java.lang.reflect.Constructor;
import java.lang.reflect.Modifier;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xml.dtm.*;
import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xml.dtm.ref.DTMNodeList;
import org.apache.xml.dtm.ref.DTMNodeProxy;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import javax.xml.transform.TransformerException;


public class MethodResolver
{

  
  public static final int STATIC_ONLY         = 1;

  
  public static final int INSTANCE_ONLY       = 2;

  
  public static final int STATIC_AND_INSTANCE = 3;

  
  public static final int DYNAMIC             = 4;

  
  public static Constructor getConstructor(Class classObj, 
                                           Object[] argsIn, 
                                           Object[][] argsOut,
                                           ExpressionContext exprContext)
    throws NoSuchMethodException,
           SecurityException,
           TransformerException
  {
    Constructor bestConstructor = null;
    Class[] bestParamTypes = null;
    Constructor[] constructors = classObj.getConstructors();
    int nMethods = constructors.length;
    int bestScore = Integer.MAX_VALUE;
    int bestScoreCount = 0;
    for(int i = 0; i < nMethods; i++)
    {
      Constructor ctor = constructors[i];
      Class[] paramTypes = ctor.getParameterTypes();
      int numberMethodParams = paramTypes.length;
      int paramStart = 0;
      boolean isFirstExpressionContext = false;
      int scoreStart;
      
      
      
      if(numberMethodParams == (argsIn.length+1))
      {
        Class javaClass = paramTypes[0];
        
        if(ExpressionContext.class.isAssignableFrom(javaClass))
        {
          isFirstExpressionContext = true;
          scoreStart = 0;
          paramStart++;
          
        }
        else
          continue;
      }
      else
          scoreStart = 1000;
      
      if(argsIn.length == (numberMethodParams - paramStart))
      {
        
        int score = scoreMatch(paramTypes, paramStart, argsIn, scoreStart);
        
        if(-1 == score)	
          continue;
        if(score < bestScore)
        {
          
          bestConstructor = ctor;
          bestParamTypes = paramTypes;
          bestScore = score;
          bestScoreCount = 1;
        }
        else if (score == bestScore)
          bestScoreCount++;
      }
    }

    if(null == bestConstructor)
    {
      throw new NoSuchMethodException(errString(""function"", ""constructor"", classObj,
                                                                        """", 0, argsIn));
    }
    
    else
      convertParams(argsIn, argsOut, bestParamTypes, exprContext);
    
    return bestConstructor;
  }

  
  
  public static Method getMethod(Class classObj,
                                 String name, 
                                 Object[] argsIn, 
                                 Object[][] argsOut,
                                 ExpressionContext exprContext,
                                 int searchMethod)
    throws NoSuchMethodException,
           SecurityException,
           TransformerException
  {
    
    
    if (name.indexOf(""-"")>0)
      name = replaceDash(name);
    Method bestMethod = null;
    Class[] bestParamTypes = null;
    Method[] methods = classObj.getMethods();
    int nMethods = methods.length;
    int bestScore = Integer.MAX_VALUE;
    int bestScoreCount = 0;
    boolean isStatic;
    for(int i = 0; i < nMethods; i++)
    {
      Method method = methods[i];
      
      int xsltParamStart = 0;
      if(method.getName().equals(name))
      {
        isStatic = Modifier.isStatic(method.getModifiers());
        switch(searchMethod)
        {
          case STATIC_ONLY:
            if (!isStatic)
            {
              continue;
            }
            break;

          case INSTANCE_ONLY:
            if (isStatic)
            {
              continue;
            }
            break;

          case STATIC_AND_INSTANCE:
            break;

          case DYNAMIC:
            if (!isStatic)
              xsltParamStart = 1;
        }
        int javaParamStart = 0;
        Class[] paramTypes = method.getParameterTypes();
        int numberMethodParams = paramTypes.length;
        boolean isFirstExpressionContext = false;
        int scoreStart;
        
        
        
        int argsLen = (null != argsIn) ? argsIn.length : 0;
        if(numberMethodParams == (argsLen-xsltParamStart+1))
        {
          Class javaClass = paramTypes[0];
          if(ExpressionContext.class.isAssignableFrom(javaClass))
          {
            isFirstExpressionContext = true;
            scoreStart = 0;
            javaParamStart++;
          }
          else
          {
            continue;
          }
        }
        else
            scoreStart = 1000;
        
        if((argsLen - xsltParamStart) == (numberMethodParams - javaParamStart))
        {
          
          int score = scoreMatch(paramTypes, javaParamStart, argsIn, scoreStart);
          
          if(-1 == score)
            continue;
          if(score < bestScore)
          {
            
            bestMethod = method;
            bestParamTypes = paramTypes;
            bestScore = score;
            bestScoreCount = 1;
          }
          else if (score == bestScore)
            bestScoreCount++;
        }
      }
    }
    
    if (null == bestMethod)
    {
      throw new NoSuchMethodException(errString(""function"", ""method"", classObj,
                                                                name, searchMethod, argsIn));
    }
    
    else
      convertParams(argsIn, argsOut, bestParamTypes, exprContext);
    
    return bestMethod;
  }
  
  
  private static String replaceDash(String name)
  {
    char dash = '-';
    StringBuffer buff = new StringBuffer("""");
    for (int i=0; i<name.length(); i++)
    {
      if (name.charAt(i) == dash)
      {}
      else if (i > 0 && name.charAt(i-1) == dash)
        buff.append(Character.toUpperCase(name.charAt(i)));
      else
        buff.append(name.charAt(i));
    }
    return buff.toString();
  }
  
  
  public static Method getElementMethod(Class classObj,
                                        String name)
    throws NoSuchMethodException,
           SecurityException,
           TransformerException
  {
    
    
    Method bestMethod = null;
    Method[] methods = classObj.getMethods();
    int nMethods = methods.length;
    int bestScoreCount = 0;
    for(int i = 0; i < nMethods; i++)
    {
      Method method = methods[i];
      
      if(method.getName().equals(name))
      {
        Class[] paramTypes = method.getParameterTypes();
        if ( (paramTypes.length == 2)
           && paramTypes[1].isAssignableFrom(org.apache.xalan.templates.ElemExtensionCall.class)
                                         && paramTypes[0].isAssignableFrom(org.apache.xalan.extensions.XSLProcessorContext.class) )
        {
          if ( ++bestScoreCount == 1 )
            bestMethod = method;
          else
            break;
        }
      }
    }
    
    if (null == bestMethod)
    {
      throw new NoSuchMethodException(errString(""element"", ""method"", classObj,
                                                                        name, 0, null));
    }
    else if (bestScoreCount > 1)
      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_MORE_MATCH_ELEMENT, new Object[]{name})); 
    
    return bestMethod;
  }
  

  
  public static void convertParams(Object[] argsIn, 
                                   Object[][] argsOut, Class[] paramTypes,
                                   ExpressionContext exprContext)
    throws javax.xml.transform.TransformerException
  {
    
    if (paramTypes == null)
      argsOut[0] = null;
    else
    {
      int nParams = paramTypes.length;
      argsOut[0] = new Object[nParams];
      int paramIndex = 0;
      if((nParams > 0) 
         && ExpressionContext.class.isAssignableFrom(paramTypes[0]))
      {
        argsOut[0][0] = exprContext;
        
        paramIndex++;
      }

      if (argsIn != null)
      {
        for(int i = argsIn.length - nParams + paramIndex ; paramIndex < nParams; i++, paramIndex++)
        {
          
          argsOut[0][paramIndex] = convert(argsIn[i], paramTypes[paramIndex]);
        }
      }
    }
  }
  
  
  static class ConversionInfo
  {
    ConversionInfo(Class cl, int score)
    {
      m_class = cl;
      m_score = score;
    }
    
    Class m_class;  
    int m_score; 
  }
  
  private static final int SCOREBASE=1;
  
  
  static ConversionInfo[] m_javaObjConversions = {
    new ConversionInfo(Double.TYPE, 11),
    new ConversionInfo(Float.TYPE, 12),
    new ConversionInfo(Long.TYPE, 13),
    new ConversionInfo(Integer.TYPE, 14),
    new ConversionInfo(Short.TYPE, 15),
    new ConversionInfo(Character.TYPE, 16),
    new ConversionInfo(Byte.TYPE, 17),
    new ConversionInfo(java.lang.String.class, 18)
  };
  
  
  static ConversionInfo[] m_booleanConversions = {
    new ConversionInfo(Boolean.TYPE, 0),
    new ConversionInfo(java.lang.Boolean.class, 1),
    new ConversionInfo(java.lang.Object.class, 2),
    new ConversionInfo(java.lang.String.class, 3)
  };

  
  static ConversionInfo[] m_numberConversions = {
    new ConversionInfo(Double.TYPE, 0),
    new ConversionInfo(java.lang.Double.class, 1),
    new ConversionInfo(Float.TYPE, 3),
    new ConversionInfo(Long.TYPE, 4),
    new ConversionInfo(Integer.TYPE, 5),
    new ConversionInfo(Short.TYPE, 6),
    new ConversionInfo(Character.TYPE, 7),
    new ConversionInfo(Byte.TYPE, 8),
    new ConversionInfo(Boolean.TYPE, 9),
    new ConversionInfo(java.lang.String.class, 10),
    new ConversionInfo(java.lang.Object.class, 11)
  };

  
  static ConversionInfo[] m_stringConversions = {
    new ConversionInfo(java.lang.String.class, 0),
    new ConversionInfo(java.lang.Object.class, 1),
    new ConversionInfo(Character.TYPE, 2),
    new ConversionInfo(Double.TYPE, 3),
    new ConversionInfo(Float.TYPE, 3),
    new ConversionInfo(Long.TYPE, 3),
    new ConversionInfo(Integer.TYPE, 3),
    new ConversionInfo(Short.TYPE, 3),
    new ConversionInfo(Byte.TYPE, 3),
    new ConversionInfo(Boolean.TYPE, 4)
  };

  
  static ConversionInfo[] m_rtfConversions = {
    new ConversionInfo(org.w3c.dom.traversal.NodeIterator.class, 0),
    new ConversionInfo(org.w3c.dom.NodeList.class, 1),
    new ConversionInfo(org.w3c.dom.Node.class, 2),
    new ConversionInfo(java.lang.String.class, 3),
    new ConversionInfo(java.lang.Object.class, 5),
    new ConversionInfo(Character.TYPE, 6),
    new ConversionInfo(Double.TYPE, 7),
    new ConversionInfo(Float.TYPE, 7),
    new ConversionInfo(Long.TYPE, 7),
    new ConversionInfo(Integer.TYPE, 7),
    new ConversionInfo(Short.TYPE, 7),
    new ConversionInfo(Byte.TYPE, 7),
    new ConversionInfo(Boolean.TYPE, 8)
  };
  
  
  static ConversionInfo[] m_nodesetConversions = {
    new ConversionInfo(org.w3c.dom.traversal.NodeIterator.class, 0),
    new ConversionInfo(org.w3c.dom.NodeList.class, 1),
    new ConversionInfo(org.w3c.dom.Node.class, 2),
    new ConversionInfo(java.lang.String.class, 3),
    new ConversionInfo(java.lang.Object.class, 5),
    new ConversionInfo(Character.TYPE, 6),
    new ConversionInfo(Double.TYPE, 7),
    new ConversionInfo(Float.TYPE, 7),
    new ConversionInfo(Long.TYPE, 7),
    new ConversionInfo(Integer.TYPE, 7),
    new ConversionInfo(Short.TYPE, 7),
    new ConversionInfo(Byte.TYPE, 7),
    new ConversionInfo(Boolean.TYPE, 8)
  };
  
  
  static ConversionInfo[][] m_conversions = 
  {
    m_javaObjConversions, 
    m_booleanConversions, 
    m_numberConversions,  
    m_stringConversions,  
    m_nodesetConversions, 
    m_rtfConversions      
  };
  
  
  public static int scoreMatch(Class[] javaParamTypes, int javaParamsStart,
                               Object[] xsltArgs, int score)
  {
    if ((xsltArgs == null) || (javaParamTypes == null))
      return score;
    int nParams = xsltArgs.length;
    for(int i = nParams - javaParamTypes.length + javaParamsStart, javaParamTypesIndex = javaParamsStart; 
        i < nParams; 
        i++, javaParamTypesIndex++)
    {
      Object xsltObj = xsltArgs[i];
      int xsltClassType = (xsltObj instanceof XObject) 
                          ? ((XObject)xsltObj).getType() 
                            : XObject.CLASS_UNKNOWN;
      Class javaClass = javaParamTypes[javaParamTypesIndex];
      
      
      
      
      if(xsltClassType == XObject.CLASS_NULL)
      {
        
        
        if(!javaClass.isPrimitive())
        {
          
          score += 10;
          continue;
        }
        else
          return -1;  
      }
      
      ConversionInfo[] convInfo = m_conversions[xsltClassType];
      int nConversions = convInfo.length;
      int k;
      for(k = 0; k < nConversions; k++)
      {
        ConversionInfo cinfo = convInfo[k];
        if(javaClass.isAssignableFrom(cinfo.m_class))
        {
          score += cinfo.m_score;
          break; 
        }
      }

      if (k == nConversions)
      {
        
        
        
        

        
        
        
        
        

        
        
        
        
        
        
        
        
        
        
        
                                
        
        

        if (XObject.CLASS_UNKNOWN == xsltClassType)
        {
          Class realClass = null;

          if (xsltObj instanceof XObject)
          {
            Object realObj = ((XObject) xsltObj).object();
            if (null != realObj)
            {
              realClass = realObj.getClass();
            }
            else
            {
              
              score += 10;
              continue;
            }
          }
          else
          {
            realClass = xsltObj.getClass();
          }

          if (javaClass.isAssignableFrom(realClass))
          {
            score += 0;         
          }
          else
            return -1;
        }
        else
          return -1;
      }
    }
    return score;
  }
  
  
  static Object convert(Object xsltObj, Class javaClass)
    throws javax.xml.transform.TransformerException
  {
    if(xsltObj instanceof XObject)
    {
      XObject xobj = ((XObject)xsltObj);
      int xsltClassType = xobj.getType();

      switch(xsltClassType)
      {
      case XObject.CLASS_NULL:
        return null;
        
      case XObject.CLASS_BOOLEAN:
        {
          if(javaClass == java.lang.String.class)
            return xobj.str();
          else
            return new Boolean(xobj.bool());
        }
        
      case XObject.CLASS_NUMBER:
        {
          if(javaClass == java.lang.String.class)
            return xobj.str();
          else if(javaClass == Boolean.TYPE)
            return new Boolean(xobj.bool());
          else 
          {
            return convertDoubleToNumber(xobj.num(), javaClass);
          }
        }
        
        
      case XObject.CLASS_STRING:
        {
          if((javaClass == java.lang.String.class) ||
             (javaClass == java.lang.Object.class))
            return xobj.str();
          else if(javaClass == Character.TYPE)
          {
            String str = xobj.str();
            if(str.length() > 0)
              return new Character(str.charAt(0));
            else
              return null; 
          }
          else if(javaClass == Boolean.TYPE)
            return new Boolean(xobj.bool());
          else 
          {
            return convertDoubleToNumber(xobj.num(), javaClass);
          }
        }
        
        
      case XObject.CLASS_RTREEFRAG:
        {
          
          
          
          
          
          
          if ( (javaClass == NodeIterator.class) ||
               (javaClass == java.lang.Object.class) )
          {
            DTMIterator dtmIter = ((XRTreeFrag) xobj).asNodeIterator();
            return new DTMNodeIterator(dtmIter);
          }
          else if (javaClass == NodeList.class)
          {
            return ((XRTreeFrag) xobj).convertToNodeset();
          }
          
          
          else if(javaClass == Node.class)
          {
            DTMIterator iter = ((XRTreeFrag) xobj).asNodeIterator();
            int rootHandle = iter.nextNode();
            DTM dtm = iter.getDTM(rootHandle);
            return dtm.getNode(dtm.getFirstChild(rootHandle));
          }
          else if(javaClass == java.lang.String.class)
          {
            return xobj.str();
          }
          else if(javaClass == Boolean.TYPE)
          {
            return new Boolean(xobj.bool());
          }
          else if(javaClass.isPrimitive())
          {
            return convertDoubleToNumber(xobj.num(), javaClass);
          }
          else
          {
            DTMIterator iter = ((XRTreeFrag) xobj).asNodeIterator();
            int rootHandle = iter.nextNode();
            DTM dtm = iter.getDTM(rootHandle);
            Node child = dtm.getNode(dtm.getFirstChild(rootHandle));

            if(javaClass.isAssignableFrom(child.getClass()))
              return child;
            else
              return null;
          }
        }
        
        
      case XObject.CLASS_NODESET:
        {
          
          
          
          
          
          
          if ( (javaClass == NodeIterator.class) ||
               (javaClass == java.lang.Object.class) )
          {
            return xobj.nodeset();
          }
          
          
          else if(javaClass == NodeList.class)
          {
            return xobj.nodelist();
          }
          
          
          else if(javaClass == Node.class)
          {
            
            
            DTMIterator ni = xobj.iter();
            int handle = ni.nextNode();           
            return ni.getDTM(handle).getNode(handle); 
          }
          else if(javaClass == java.lang.String.class)
          {
            return xobj.str();
          }
          else if(javaClass == Boolean.TYPE)
          {
            return new Boolean(xobj.bool());
          }
          else if(javaClass.isPrimitive())
          {
            return convertDoubleToNumber(xobj.num(), javaClass);
          }
          else
          {
            DTMIterator iter = xobj.iter();
            int childHandle = iter.nextNode();
            DTM dtm = iter.getDTM(childHandle);
            Node child = dtm.getNode(childHandle);
            if(javaClass.isAssignableFrom(child.getClass()))
              return child;
            else
              return null;
          }
        }
        
        
        
      } 
      xsltObj = xobj.object();
      
    } 
    
    
    if (null != xsltObj)
    {
      if(javaClass == java.lang.String.class)
      {
        return xsltObj.toString();
      }
      else if(javaClass.isPrimitive())
      {
        
        XString xstr = new XString(xsltObj.toString());
        double num = xstr.num();
        return convertDoubleToNumber(num, javaClass);
      }
      else if(javaClass == java.lang.Class.class)
      {
        return xsltObj.getClass();
      }
      else
      {
        
        return xsltObj;
      }
                }
    else
    {
      
      return xsltObj;
    }
  }
  
  
  static Object convertDoubleToNumber(double num, Class javaClass)
  {
    
    
    
    if((javaClass == Double.TYPE) ||
       (javaClass == java.lang.Double.class))
      return new Double(num);
    else if(javaClass == Float.TYPE)
      return new Float(num);
    else if(javaClass == Long.TYPE)
    {
      
      
      return new Long((long)num);
    }
    else if(javaClass == Integer.TYPE)
    {
      
      
      return new Integer((int)num);
    }
    else if(javaClass == Short.TYPE)
    {
      
      
      return new Short((short)num);
    }
    else if(javaClass == Character.TYPE)
    {
      
      
      return new Character((char)num);
    }
    else if(javaClass == Byte.TYPE)
    {
      
      
      return new Byte((byte)num);
    }
    else     
    {
      return new Double(num);
    }
  }


  
  private static String errString(String callType,    
                                  String searchType,  
                                  Class classObj,
                                  String funcName,
                                  int searchMethod,
                                  Object[] xsltArgs)
  {
    String resultString = ""For extension "" + callType
                                              + "", could not find "" + searchType + "" "";
    switch (searchMethod)
    {
      case STATIC_ONLY:
        return resultString + ""static "" + classObj.getName() + ""."" 
                            + funcName + ""([ExpressionContext,] "" + errArgs(xsltArgs, 0) + "")."";

      case INSTANCE_ONLY:
        return resultString + classObj.getName() + "".""
                            + funcName + ""([ExpressionContext,] "" + errArgs(xsltArgs, 0) + "")."";

      case STATIC_AND_INSTANCE:
        return resultString + classObj.getName() + ""."" + funcName + ""([ExpressionContext,] "" + errArgs(xsltArgs, 0) + "").
""
                            + ""Checked both static and instance methods."";

      case DYNAMIC:
        return resultString + ""static "" + classObj.getName() + ""."" + funcName
                            + ""([ExpressionContext, ]"" + errArgs(xsltArgs, 0) + "") nor
""
                            + classObj + ""."" + funcName + ""([ExpressionContext,] "" + errArgs(xsltArgs, 1) + "")."";

      default:
        if (callType.equals(""function""))      
        {
          return resultString + classObj.getName()
                                  + ""([ExpressionContext,] "" + errArgs(xsltArgs, 0) + "")."";
        }
        else                                  
        {
          return resultString + classObj.getName() + ""."" + funcName
                    + ""(org.apache.xalan.extensions.XSLProcessorContext, ""
                    + ""org.apache.xalan.templates.ElemExtensionCall)."";
        }
    }
    
  }


  private static String errArgs(Object[] xsltArgs, int startingArg)
  {
    StringBuffer returnArgs = new StringBuffer();
    for (int i = startingArg; i < xsltArgs.length; i++)
    {
      if (i != startingArg)
        returnArgs.append("", "");
      if (xsltArgs[i] instanceof XObject)
        returnArgs.append(((XObject) xsltArgs[i]).getTypeString());      
      else
        returnArgs.append(xsltArgs[i].getClass().getName());
    }
    return returnArgs.toString();
  }

}
"
org.apache.xalan.serialize.CharInfo,6,1,0,5,39,3,3,2,3,0.86,292,0.4,1,0.0,0.666666667,0,0,46.0,1,0.6667,0,"
package org.apache.xalan.serialize;

import java.util.BitSet;

import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;

import java.net.*;

import java.util.Hashtable;

import org.apache.xml.utils.CharKey;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


public class CharInfo
{

  
  BitSet m_specialsMap = new BitSet(65535);

  
  private Hashtable m_charToEntityRef = new Hashtable();

  
  public static String HTML_ENTITIES_RESOURCE = ""HTMLEntities.res"";

  
  public static String XML_ENTITIES_RESOURCE = ""XMLEntities.res"";

  
  public static char S_LINEFEED = 0x0A;

  
  public static char S_CARRIAGERETURN = 0x0D;

  
  private static final Class[] NO_CLASSES = new Class[0];

  
  private static final Object[] NO_OBJS = new Object[0];


  
  public CharInfo(String entitiesResource)
  {

    InputStream is = null;
    BufferedReader reader = null;
    int index;
    String name;
    String value;
    int code;
    String line;

    try
    {
      try
      {
        
        
        
        ClassLoader cl = CharInfo.class.getClassLoader();

        if (cl == null) {
          is = ClassLoader.getSystemResourceAsStream(entitiesResource);
        } else {
          is = cl.getResourceAsStream(entitiesResource);
        }
      }
      catch (Exception e) {}

      if (is == null)
        is = CharInfo.class.getResourceAsStream(entitiesResource);

      if (is == null)
      {
        URL url = new URL(entitiesResource);

        is = url.openStream();
      }

      if (is == null)
        throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_RESOURCE_COULD_NOT_FIND, new Object[]{entitiesResource, entitiesResource }));

      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      try
      {
	reader = new BufferedReader(new InputStreamReader(is, ""UTF-8""));
      }
      catch(java.io.UnsupportedEncodingException e)
      {
	reader = new BufferedReader(new InputStreamReader(is));
      }

      line = reader.readLine();

      while (line != null)
      {
        if (line.length() == 0 || line.charAt(0) == '#')
        {
          line = reader.readLine();

          continue;
        }

        index = line.indexOf(' ');

        if (index > 1)
        {
          name = line.substring(0, index);

          ++index;

          if (index < line.length())
          {
            value = line.substring(index);
            index = value.indexOf(' ');

            if (index > 0)
              value = value.substring(0, index);

            code = Integer.parseInt(value);

            defineEntity(name, (char) code);
          }
        }

        line = reader.readLine();
      }

      is.close();
      m_specialsMap.set(S_LINEFEED);
      m_specialsMap.set(S_CARRIAGERETURN);
    }
    catch (Exception except)
    {
      throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_RESOURCE_COULD_NOT_LOAD, new Object[]{entitiesResource,  except.toString(), entitiesResource, except.toString() }));
    }
    finally
    {
      if (is != null)
      {
        try
        {
          is.close();
        }
        catch (Exception except){}
      }
    }
  }

  
  protected void defineEntity(String name, char value)
  {
    CharKey character = new CharKey(value);

    m_charToEntityRef.put(character, name);
    m_specialsMap.set(value);
  }
  
  private CharKey m_charKey = new CharKey();

  
  synchronized 
  public String getEntityNameForChar(char value)
  {
    
    m_charKey.setChar(value);
    return (String) m_charToEntityRef.get(m_charKey);
  }

  
  public boolean isSpecial(char value)
  {
    return m_specialsMap.get(value);
  }
}
"
org.apache.xalan.xsltc.runtime.Node,1,1,0,1,2,0,1,0,1,2.0,12,0.0,0,0.0,1.0,0,0,9.0,0,0.0,0,"

package org.apache.xalan.xsltc.runtime;


public class Node {
    public int node;
    public int type;
	
    public Node(int n, int t) {
	node = n;
	type = t;
    }
}
"
org.apache.xalan.templates.StylesheetRoot,50,5,0,59,120,1069,51,25,34,0.939909297,990,0.944444444,11,0.853658537,0.079130435,3,6,18.44,10,1.6,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import java.util.*;

import java.net.MalformedURLException;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;

import java.io.*;

import org.xml.sax.*;
import org.xml.sax.helpers.*;

import org.apache.xalan.serialize.*;
import org.apache.xml.utils.*;
import org.apache.xpath.*;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xalan.trace.*;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.processor.XSLTSchema;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.Templates;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.ErrorListener;

import org.apache.xml.dtm.ref.ExpandedNameTable;

import org.apache.xml.utils.StringVector;
import org.apache.xalan.extensions.ExtensionNamespaceSupport;
import org.apache.xalan.extensions.ExtensionHandler;
import org.apache.xalan.extensions.ExtensionNamespacesManager;


public class StylesheetRoot extends StylesheetComposed
        implements java.io.Serializable, Templates
{

  
  public StylesheetRoot(ErrorListener errorListener) throws TransformerConfigurationException
  {

    super(null);

    setStylesheetRoot(this);

    try
    {
      m_selectDefault = new XPath(""node()"", this, this, XPath.SELECT, errorListener);

      initDefaultRule(errorListener);
    }
    catch (TransformerException se)
    {
      throw new TransformerConfigurationException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_INIT_DEFAULT_TEMPLATES, null), se); 
    }
  }

  
  private Hashtable m_availElems;
  
  
  public StylesheetRoot(XSLTSchema schema, ErrorListener listener) throws TransformerConfigurationException
  {

    this(listener);
    m_availElems = schema.getElemsAvailable();
  }

  
  public boolean isRoot()
  {
    return true;
  }

  
  public Hashtable getAvailableElements()
  {
    return m_availElems;
  }
  
  private ExtensionNamespacesManager m_extNsMgr = null;
  
  
  public ExtensionNamespacesManager getExtensionNamespacesManager()
  {
     if (m_extNsMgr == null)
       m_extNsMgr = new ExtensionNamespacesManager();
     return m_extNsMgr;
  }
  
  
  public Vector getExtensions()
  {
    return m_extNsMgr != null ? m_extNsMgr.getExtensions() : null;
  }  

  

  

  
  public Transformer newTransformer()
  {
    return new TransformerImpl(this);
  }
  

  public Properties getDefaultOutputProps()
  {
    return m_outputProperties.getProperties();
  }
  
  
  public Properties getOutputProperties()
  {    
    return (Properties)getDefaultOutputProps().clone();
  }

  

  
  public void recompose() throws TransformerException
  {
    

      Vector recomposableElements = new Vector();

    

    if (null == m_globalImportList)
    {

      Vector importList = new Vector();

      addImports(this, true, importList);            

      
      
      
      
      

      m_globalImportList = new StylesheetComposed[importList.size()];

      for (int i =  0, j= importList.size() -1; i < importList.size(); i++)
      {  
        m_globalImportList[j] = (StylesheetComposed) importList.elementAt(i);
        
        
        
        m_globalImportList[j].recomposeIncludes(m_globalImportList[j]);
        
        m_globalImportList[j--].recomposeImports();        
      }
    }    
    
    int n = getGlobalImportCount();

    for (int i = 0; i < n; i++)
    {
      StylesheetComposed imported = getGlobalImport(i);
      imported.recompose(recomposableElements);
    }

    

    QuickSort2(recomposableElements, 0, recomposableElements.size() - 1);

    

    m_outputProperties = new OutputProperties(Method.XML);
    
    m_attrSets = new Hashtable();
    m_decimalFormatSymbols = new Hashtable();
    m_keyDecls = new Vector();
    m_namespaceAliasComposed = new Hashtable();
    m_templateList = new TemplateList();
    m_variables = new Vector();

    
    
    
    
    for (int i = recomposableElements.size() - 1; i >= 0; i--)
      ((ElemTemplateElement) recomposableElements.elementAt(i)).recompose(this);
    
    initComposeState();

    
    m_templateList.compose(this);
    
    
    m_outputProperties.compose(this);
    m_outputProperties.endCompose(this);
    
    
    
    
    n = getGlobalImportCount();

    for (int i = 0; i < n; i++)
    {
      StylesheetComposed imported = this.getGlobalImport(i);
      int includedCount = imported.getIncludeCountComposed();
      for (int j = -1; j < includedCount; j++)
      {
        Stylesheet included = imported.getIncludeComposed(j);
        composeTemplates(included);
      }
    }
    
    if (m_extNsMgr != null)
      m_extNsMgr.registerUnregisteredNamespaces();

    clearComposeState();
  }

  
  void composeTemplates(ElemTemplateElement templ) throws TransformerException
  {

    templ.compose(this);

    for (ElemTemplateElement child = templ.getFirstChildElem();
            child != null; child = child.getNextSiblingElem())
    {
      composeTemplates(child);
    }
    
    templ.endCompose(this);
  }

  
  private StylesheetComposed[] m_globalImportList;

  
  protected void addImports(Stylesheet stylesheet, boolean addToList, Vector importList)
  {

    

    int n = stylesheet.getImportCount();

    if (n > 0)
    {
      for (int i = 0; i < n; i++)
      {
        Stylesheet imported = stylesheet.getImport(i);

        addImports(imported, true, importList);
      }
    }

    n = stylesheet.getIncludeCount();

    if (n > 0)
    {
      for (int i = 0; i < n; i++)
      {
        Stylesheet included = stylesheet.getInclude(i);

        addImports(included, false, importList);
      }
    }

    if (addToList)
      importList.addElement(stylesheet);

  }

  
  public StylesheetComposed getGlobalImport(int i)
  {
    return m_globalImportList[i];
  }

  
  public int getGlobalImportCount()
  {
          return (m_globalImportList!=null)
                        ? m_globalImportList.length 
                          : 1;
  }

  
  public int getImportNumber(StylesheetComposed sheet)
  {

    if (this == sheet)
      return 0;

    int n = getGlobalImportCount();

    for (int i = 0; i < n; i++)
    {
      if (sheet == getGlobalImport(i))
        return i;
    }

    return -1;
  }

  
  private OutputProperties m_outputProperties;

  
  void recomposeOutput(OutputProperties oprops)
    throws TransformerException
  {
    
    m_outputProperties.copyFrom(oprops);
  }

  
  public OutputProperties getOutputComposed()
  {

    
    
    return m_outputProperties;
  }

  
  private boolean m_outputMethodSet = false;

  
  public boolean isOutputMethodSet()
  {
    return m_outputMethodSet;
  }

  
  private Hashtable m_attrSets;

  
  void recomposeAttributeSets(ElemAttributeSet attrSet)
  {
    Vector attrSetList = (Vector) m_attrSets.get(attrSet.getName());

    if (null == attrSetList)
    {
      attrSetList = new Vector();

      m_attrSets.put(attrSet.getName(), attrSetList);
    }

    attrSetList.addElement(attrSet);
  }

  
  public Vector getAttributeSetComposed(QName name)
          throws ArrayIndexOutOfBoundsException
  {
    return (Vector) m_attrSets.get(name);
  }

  
  private Hashtable m_decimalFormatSymbols;

  
  void recomposeDecimalFormats(DecimalFormatProperties dfp)
  {
    DecimalFormatSymbols oldDfs =
                  (DecimalFormatSymbols) m_decimalFormatSymbols.get(dfp.getName());
    if (null == oldDfs)
    {
      m_decimalFormatSymbols.put(dfp.getName(), dfp.getDecimalFormatSymbols());
    }
    else if (!dfp.getDecimalFormatSymbols().equals(oldDfs))
    {
      String themsg;
      if (dfp.getName().equals(new QName("""")))
      {
        
        themsg = XSLMessages.createWarning(
                          XSLTErrorResources.WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
                          new Object[0]);
      }
      else
      {
        
        themsg = XSLMessages.createWarning(
                          XSLTErrorResources.WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
                          new Object[] {dfp.getName()});
      }

      error(themsg);   
    }

  }

  
  public DecimalFormatSymbols getDecimalFormatComposed(QName name)
  {
    return (DecimalFormatSymbols) m_decimalFormatSymbols.get(name);
  }

  
  private Vector m_keyDecls;

  
  void recomposeKeys(KeyDeclaration keyDecl)
  {
    m_keyDecls.addElement(keyDecl);
  }

  
  public Vector getKeysComposed()
  {
    return m_keyDecls;
  }

  
  private Hashtable m_namespaceAliasComposed;

  
  void recomposeNamespaceAliases(NamespaceAlias nsAlias)
  {
    m_namespaceAliasComposed.put(nsAlias.getStylesheetNamespace(),
                                 nsAlias);
  }

  
  public NamespaceAlias getNamespaceAliasComposed(String uri)
  {
    return (NamespaceAlias) ((null == m_namespaceAliasComposed) 
                    ? null : m_namespaceAliasComposed.get(uri));
  }

  
  private TemplateList m_templateList;

  
  void recomposeTemplates(ElemTemplate template)
  {
    m_templateList.setTemplate(template);
  }

  
  public final TemplateList getTemplateListComposed()
  {
    return m_templateList;
  }

  
  public final void setTemplateListComposed(TemplateList templateList)
  {
    m_templateList = templateList;
  }

  
  public ElemTemplate getTemplateComposed(XPathContext xctxt,
                                          int targetNode,
                                          QName mode,
                                          boolean quietConflictWarnings,
                                          DTM dtm)
            throws TransformerException
  {
    return m_templateList.getTemplate(xctxt, targetNode, mode, 
                                      quietConflictWarnings,
                                      dtm);
  }
  
  
  public ElemTemplate getTemplateComposed(XPathContext xctxt,
                                          int targetNode,
                                          QName mode,
                                          int maxImportLevel, int endImportLevel,
                                          boolean quietConflictWarnings,
                                          DTM dtm)
            throws TransformerException
  {
    return m_templateList.getTemplate(xctxt, targetNode, mode, 
                                      maxImportLevel, endImportLevel,
                                      quietConflictWarnings,
                                      dtm);
  }

  
  public ElemTemplate getTemplateComposed(QName qname)
  {
    return m_templateList.getTemplate(qname);
  }
  
  
  private Vector m_variables;

  
  void recomposeVariables(ElemVariable elemVar)
  {
    
    if (getVariableOrParamComposed(elemVar.getName()) == null)
    {
      elemVar.setIsTopLevel(true);        
      elemVar.setIndex(m_variables.size());
      m_variables.addElement(elemVar);
    }
  }

  
  public ElemVariable getVariableOrParamComposed(QName qname)
  {
    if (null != m_variables)
    {
      int n = m_variables.size();

      for (int i = 0; i < n; i++)
      {
        ElemVariable var = (ElemVariable)m_variables.elementAt(i);
        if(var.getName().equals(qname))
          return var;
      }
    }

    return null;
  }

  
  public Vector getVariablesAndParamsComposed()
  {
    return m_variables;
  }

  
  private TemplateList m_whiteSpaceInfoList;

  
  void recomposeWhiteSpaceInfo(WhiteSpaceInfo wsi)
  {
    if (null == m_whiteSpaceInfoList)
      m_whiteSpaceInfoList = new TemplateList();

    m_whiteSpaceInfoList.setTemplate(wsi);
  }

  
  public boolean shouldCheckWhitespace()
  {
    return null != m_whiteSpaceInfoList;
  }

  
  public WhiteSpaceInfo getWhiteSpaceInfo(
          XPathContext support, int targetElement, DTM dtm) throws TransformerException
  {

    if (null != m_whiteSpaceInfoList)
      return (WhiteSpaceInfo) m_whiteSpaceInfoList.getTemplate(support,
              targetElement, null, false, dtm);
    else
      return null;
  }
  
  
  public boolean shouldStripWhiteSpace(
          XPathContext support, int targetElement) throws TransformerException
  {
    if (null != m_whiteSpaceInfoList)
    {
      while(DTM.NULL != targetElement)
      {
        DTM dtm = support.getDTM(targetElement);
        WhiteSpaceInfo info = (WhiteSpaceInfo) m_whiteSpaceInfoList.getTemplate(support,
                targetElement, null, false, dtm);
        if(null != info)
          return info.getShouldStripSpace();
        
        int parent = dtm.getParent(targetElement);
        if(DTM.NULL != parent && DTM.ELEMENT_NODE == dtm.getNodeType(parent))
          targetElement = parent;
        else
          targetElement = DTM.NULL;
      }
    }
    return false;
  }
  
  
  public boolean canStripWhiteSpace()
  {
    return (null != m_whiteSpaceInfoList);
  }
  


  
  private ElemTemplate m_defaultTextRule;

  
  public final ElemTemplate getDefaultTextRule()
  {
    return m_defaultTextRule;
  }

  
  private ElemTemplate m_defaultRule;

  
  public final ElemTemplate getDefaultRule()
  {
    return m_defaultRule;
  }

  
  private ElemTemplate m_defaultRootRule;

  
  public final ElemTemplate getDefaultRootRule()
  {
    return m_defaultRootRule;
  }
  
  
  private ElemTemplate m_startRule;

  
  public final ElemTemplate getStartRule()
  {
    return m_startRule;
  }


  
  XPath m_selectDefault;

  
  private void initDefaultRule(ErrorListener errorListener) throws TransformerException
  {

    
    m_defaultRule = new ElemTemplate();

    m_defaultRule.setStylesheet(this);

    XPath defMatch = new XPath(""*"", this, this, XPath.MATCH, errorListener);

    m_defaultRule.setMatch(defMatch);

    ElemApplyTemplates childrenElement = new ElemApplyTemplates();

    childrenElement.setIsDefaultTemplate(true);
    childrenElement.setSelect(m_selectDefault);
    m_defaultRule.appendChild(childrenElement);
    
    m_startRule = m_defaultRule;

    
    m_defaultTextRule = new ElemTemplate();

    m_defaultTextRule.setStylesheet(this);

    defMatch = new XPath(""text() | @*"", this, this, XPath.MATCH, errorListener);

    m_defaultTextRule.setMatch(defMatch);

    ElemValueOf elemValueOf = new ElemValueOf();

    m_defaultTextRule.appendChild(elemValueOf);

    XPath selectPattern = new XPath(""."", this, this, XPath.SELECT, errorListener);

    elemValueOf.setSelect(selectPattern);

    
    m_defaultRootRule = new ElemTemplate();

    m_defaultRootRule.setStylesheet(this);

    defMatch = new XPath(""/"", this, this, XPath.MATCH, errorListener);

    m_defaultRootRule.setMatch(defMatch);

    childrenElement = new ElemApplyTemplates();

    childrenElement.setIsDefaultTemplate(true);
    m_defaultRootRule.appendChild(childrenElement);
    childrenElement.setSelect(m_selectDefault);
  }

  

  private void QuickSort2(Vector v, int lo0, int hi0)
    {
      int lo = lo0;
      int hi = hi0;

      if ( hi0 > lo0)
      {
        
        
        ElemTemplateElement midNode = (ElemTemplateElement) v.elementAt( ( lo0 + hi0 ) / 2 );

        
        while( lo <= hi )
        {
          
          
          while( (lo < hi0) && (((ElemTemplateElement) v.elementAt(lo)).compareTo(midNode) < 0) )
          {
            ++lo;
          } 

          
          
          while( (hi > lo0) && (((ElemTemplateElement) v.elementAt(hi)).compareTo(midNode) > 0) )          {
            --hi;
          }

          
          if( lo <= hi )
          {
            ElemTemplateElement node = (ElemTemplateElement) v.elementAt(lo);
            v.setElementAt(v.elementAt(hi), lo);
            v.setElementAt(node, hi);

            ++lo;
            --hi;
          }
        }

        
        
        if( lo0 < hi )
        {
          QuickSort2( v, lo0, hi );
        }

        
        
        if( lo < hi0 )
        {
          QuickSort2( v, lo, hi0 );
        }
      }
    } 
    
    private ComposeState m_composeState;
    
    
    void initComposeState()
    {
      m_composeState = new ComposeState();
    }

    
    ComposeState getComposeState()
    {
      return m_composeState;
    }
    
    
    private void clearComposeState()
    {
      m_composeState = null;
    }
    
    
    class ComposeState
    {
      ComposeState()
      {
        int size = m_variables.size();
        for (int i = 0; i < size; i++) 
        {
          ElemVariable ev = (ElemVariable)m_variables.elementAt(i);
          m_variableNames.addElement(ev.getName());
        }
        
      }
      
      private ExpandedNameTable m_ent = new ExpandedNameTable();
      
      
      public int getQNameID(QName qname)
      {
        
        return m_ent.getExpandedTypeID(qname.getNamespace(), 
                                       qname.getLocalName(),
                                       
                                       
                                       org.apache.xml.dtm.DTM.ELEMENT_NODE);
      }
      
      
      private java.util.Vector m_variableNames = new java.util.Vector();
            
      
      int addVariableName(final org.apache.xml.utils.QName qname)
      {
        int pos = m_variableNames.size();
        m_variableNames.addElement(qname);
        int frameSize = m_variableNames.size() - getGlobalsSize();
        if(frameSize > m_maxStackFrameSize)
          m_maxStackFrameSize++;
        return pos;
      }
      
      void resetStackFrameSize()
      {
        m_maxStackFrameSize = 0;
      }
      
      int getFrameSize()
      {
        return m_maxStackFrameSize;
      }
      
      
      int getCurrentStackFrameSize()
      {
        return m_variableNames.size();
      }
      
      
      void setCurrentStackFrameSize(int sz)
      {
        m_variableNames.setSize(sz);
      }
      
      int getGlobalsSize()
      {
        return m_variables.size();
      }
      
      IntStack m_marks = new IntStack();
      
      void pushStackMark()
      {
        m_marks.push(getCurrentStackFrameSize());
      }
      
      void popStackMark()
      {
        int mark = m_marks.pop();
        setCurrentStackFrameSize(mark);
      }
      
      
      java.util.Vector getVariableNames()
      {
        return m_variableNames;
      }
      
      private int m_maxStackFrameSize;

    }
}
"
org.apache.xalan.templates.XUnresolvedVariableSimple,4,3,0,6,15,6,1,5,4,2.0,39,0.0,0,0.959459459,0.5,2,12,8.75,1,0.75,0,"package org.apache.xalan.templates;

import javax.xml.transform.TransformerException;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;



public class XUnresolvedVariableSimple extends XObject
{
  public XUnresolvedVariableSimple(ElemVariable obj)
  {
    super(obj);
  }
    
	
  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
  	Expression expr = ((ElemVariable)m_obj).getSelect().getExpression();
    XObject xobj = expr.execute(xctxt);
    xobj.allowDetachToRelease(false);
    return xobj;
  }
  
  
  public int getType()
  {
    return CLASS_UNRESOLVEDVARIABLE;
  }
  
  
  public String getTypeString()
  {
    return ""XUnresolvedVariableSimple ("" + object().getClass().getName() + "")"";
  }


}

"
org.apache.xalan.templates.AbsPathChecker,4,2,0,8,6,0,1,7,4,0.0,37,1.0,0,0.8,0.45,0,0,8.0,3,1.25,0,"
package org.apache.xalan.templates;

import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.functions.FuncCurrent;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.functions.Function;
import org.apache.xpath.operations.Variable;


public class AbsPathChecker extends XPathVisitor
{
	private boolean m_isAbs = true;
	
	
	public boolean checkAbsolute(LocPathIterator path)
	{
		m_isAbs = true;
		path.callVisitors(null, this);
		return m_isAbs;
	}
	
	
	public boolean visitFunction(ExpressionOwner owner, Function func)
	{
		if((func instanceof FuncCurrent) ||
		   (func instanceof FuncExtFunction))
			m_isAbs = false;
		return true;
	}
	
	
	public boolean visitVariableRef(ExpressionOwner owner, Variable var)
	{
		m_isAbs = false;
		return true;
	}
}

"
org.apache.xml.utils.synthetic.JavaUtils,5,1,0,0,18,4,0,0,3,0.625,157,1.0,0,0.0,0.25,0,0,30.0,6,1.8,0,"

package org.apache.xml.utils.synthetic;

import java.io.IOException;


public class JavaUtils
{
        
        private static boolean cantLoadCompiler=false; 

        
        private static boolean debug = false;
  
         
        public static void setDebug(boolean newDebug)
        {
            debug=newDebug;
        }

        
        public static boolean JDKcompile(String fileName, String classPath)
        {
                String moreClassPath=
                        System.getProperty(""org.apache.xml.utils.synthetic.moreclasspath"","""")
                        .trim();
                if(moreClassPath.length()>0)
                        classPath=moreClassPath+';'+classPath;
                                                                                                  
                if (debug)
                {
                        System.err.println (""JavaEngine: Compiling "" + fileName);
                        System.err.println (""JavaEngine: Classpath is "" + classPath);
                }
    
                String code_option = debug ? ""-g"" : ""-O"";

                
            if(!cantLoadCompiler)
                {
                        String args[] = {
                                code_option,
                            ""-classpath"", classPath,
                                fileName
                        };
                                










                }
    
                
                
                
                String javac_command=
                        System.getProperty(""org.apache.xml.utils.synthetic.javac"",""javac"");
            String args[] = {
                        javac_command,
                        code_option,
                        ""-classpath"", classPath,
                        fileName
                        };
                try
                {
                        Process p=java.lang.Runtime.getRuntime().exec(args);
                        int compileOK=waitHardFor(p); 
                        return compileOK==0; 
                }
                catch(IOException e)
                {
                        System.err.println(""ERROR: IO exception during exec(javac)."");
                }
                catch(SecurityException e)
                {
                        System.err.println(""ERROR: Unable to create subprocess to exec(javac)."");
                }
                
                
                return false;
        }

  
  static int waitHardFor(java.lang.Process p)
  {
    boolean done=false;
    while(!done)
        try
        {
            p.waitFor();
            done=true;
        }
        catch(InterruptedException e)
        {
            System.err.println(""(Compiler process wait interrupted and resumed)"");
        }
     int ev=p.exitValue();  
     return ev;
  }
        
}
"
org.apache.xalan.Version,9,1,0,1,15,36,0,1,9,2.0,69,0.0,0,0.0,0.111111111,0,0,6.666666667,2,1.0,0,"
package org.apache.xalan;


public class Version
{

  
  public static String getVersion()
  {
    return getProduct()+"" ""+getImplementationLanguage()+"" ""
           +getMajorVersionNum()+"".""+getReleaseVersionNum()+"".""
           +( (getDevelopmentVersionNum() > 0) ? 
               (""D""+getDevelopmentVersionNum()) : (""""+getMaintenanceVersionNum()));
  }

  
  public static void main(String argv[])
  {
    System.out.println(getVersion());
  }

  
  public static String getProduct()
  {
    return ""Xalan"";
  }

  
  public static String getImplementationLanguage()
  {
    return ""Java"";
  }

  
  public static int getMajorVersionNum()
  {
    
    
    
    
    return org.apache.xalan.processor.XSLProcessorVersion.VERSION;
    
  }

  
  public static int getReleaseVersionNum()
  {
    
    return org.apache.xalan.processor.XSLProcessorVersion.RELEASE;
  }

  
  public static int getMaintenanceVersionNum()
  {
    
    return org.apache.xalan.processor.XSLProcessorVersion.MAINTENANCE;
  }

  
  public static int getDevelopmentVersionNum()
  {
    
    return org.apache.xalan.processor.XSLProcessorVersion.DEVELOPMENT;
  }
}
"
org.apache.xpath.objects.XMLStringFactoryImpl,7,2,0,8,11,19,4,6,6,0.833333333,39,1.0,1,0.444444444,0.333333333,0,0,4.428571429,1,0.7143,0,"
package org.apache.xpath.objects;

import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xml.utils.FastStringBuffer;


public class XMLStringFactoryImpl extends XMLStringFactory
{
  
  private static XMLStringFactory m_xstringfactory =
    new XMLStringFactoryImpl();

  
  public static XMLStringFactory getFactory()
  {
    return m_xstringfactory;
  }

  
  public XMLString newstr(String string)
  {
    return new XString(string);
  }

  
  public XMLString newstr(FastStringBuffer fsb, int start, int length)
  {
    return new XStringForFSB(fsb, start, length);
  }
  
  
  public XMLString newstr(char[] string, int start, int length)
  {
    return new XStringForChars(string, start, length);
  }
  
  
  public XMLString emptystr()
  {
    return XString.EMPTYSTRING;
  }

}
"
org.apache.xpath.operations.VariableSafeAbsRef,2,3,0,10,11,1,1,9,2,2.0,39,0.0,0,0.97826087,0.666666667,1,1,18.5,1,0.5,0,"package org.apache.xpath.operations;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;



public class VariableSafeAbsRef extends Variable
{
	
  
  public XObject execute(XPathContext xctxt, boolean destructiveOK) 
  	throws javax.xml.transform.TransformerException
  {
  	XNodeSet xns = (XNodeSet)super.execute(xctxt, destructiveOK);
  	DTMManager dtmMgr = xctxt.getDTMManager();
  	int context = xctxt.getContextNode();
  	if(dtmMgr.getDTM(xns.getRoot()).getDocument() != 
  	   dtmMgr.getDTM(context).getDocument())
  	{
  		Expression expr = (Expression)xns.getContainedIter();
  		xns = (XNodeSet)expr.asIterator(xctxt, context);
  	}
  	return xns;
  }

}

"
org.apache.xalan.templates.ElemAttributeSet,8,4,0,10,24,16,6,7,8,0.571428571,97,0.0,1,0.966507177,0.3,2,4,11.0,3,1.125,0,"
package org.apache.xalan.templates;

import org.w3c.dom.Node;
import org.w3c.dom.DOMException;

import javax.xml.transform.TransformerException;

import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;

import java.util.Stack;

import org.apache.xalan.transformer.TransformerImpl;


public class ElemAttributeSet extends ElemUse
{

  
  public QName m_qname = null;

  
  public void setName(QName name)
  {
    m_qname = name;
  }

  
  public QName getName()
  {
    return m_qname;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_DEFINEATTRIBUTESET;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_ATTRIBUTESET_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (transformer.isRecursiveAttrSet(this))
    {
      throw new TransformerException(
        XSLMessages.createMessage(
          XSLTErrorResources.ER_XSLATTRSET_USED_ITSELF,
          new Object[]{ m_qname.getLocalPart() }));  
    }

    transformer.pushElemAttributeSet(this);
    super.execute(transformer);

    ElemAttribute attr = (ElemAttribute) getFirstChildElem();

    while (null != attr)
    {
      attr.execute(transformer);

      attr = (ElemAttribute) attr.getNextSiblingElem();
    }

    transformer.popElemAttributeSet();
  }

  
  public ElemTemplateElement appendChildElem(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {
    case Constants.ELEMNAME_ATTRIBUTE :
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeAttributeSets(this);
  }

}
"
org.apache.xalan.templates.ElemForEach,18,3,1,25,83,79,6,21,17,0.735294118,492,0.5,1,0.920187793,0.136752137,2,6,26.11111111,4,1.2778,2,"
package org.apache.xalan.templates;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;


import org.apache.xml.dtm.ref.ExpandedNameTable;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.Expression;
import org.apache.xpath.axes.ContextNodeList;
import org.apache.xpath.objects.XObject;

import java.util.Vector;

import org.apache.xml.utils.QName;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.NodeSorter;
import org.apache.xalan.transformer.ResultTreeHandler;
import org.apache.xalan.transformer.ClonerToResultTree;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;
import org.apache.xpath.ExpressionOwner;


public class ElemForEach extends ElemTemplateElement implements ExpressionOwner
{
  
  static final boolean DEBUG = false;
  
  
  public boolean m_doc_cache_off=false;
  
  
  public ElemForEach(){}

  
  protected Expression m_selectExpression = null;

  
  public void setSelect(XPath xpath)
  {
    m_selectExpression = xpath.getExpression();
  }

  
  public Expression getSelect()
  {
    return m_selectExpression;
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {

    super.compose(sroot);

    int length = getSortElemCount();

    for (int i = 0; i < length; i++)
    {
      getSortElem(i).compose(sroot);
    }

    java.util.Vector vnames = sroot.getComposeState().getVariableNames();

    if (null != m_selectExpression)
      m_selectExpression.fixupVariables(
        vnames, sroot.getComposeState().getGlobalsSize());
    else
    {
      m_selectExpression =
        getStylesheetRoot().m_selectDefault.getExpression();
    }
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    int length = getSortElemCount();

    for (int i = 0; i < length; i++)
    {
      getSortElem(i).endCompose(sroot);
    }
    
    super.endCompose(sroot);
  }


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  protected Vector m_sortElems = null;

  
  public int getSortElemCount()
  {
    return (m_sortElems == null) ? 0 : m_sortElems.size();
  }

  
  public ElemSort getSortElem(int i)
  {
    return (ElemSort) m_sortElems.elementAt(i);
  }

  
  public void setSortElem(ElemSort sortElem)
  {

    if (null == m_sortElems)
      m_sortElems = new Vector();

    m_sortElems.addElement(sortElem);
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_FOREACH;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_FOREACH_STRING;
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    transformer.pushCurrentTemplateRuleIsNull(true);    
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    try
    {
      transformSelectedNodes(transformer);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
	    transformer.getTraceManager().fireTraceEndEvent(this); 
      transformer.popCurrentTemplateRuleIsNull();
    }
  }

  
  protected ElemTemplateElement getTemplateMatch()
  {
    return this;
  }

  
  public DTMIterator sortNodes(
          XPathContext xctxt, Vector keys, DTMIterator sourceNodes)
            throws TransformerException
  {

    NodeSorter sorter = new NodeSorter(xctxt);
    sourceNodes.setShouldCacheNodes(true);
    sourceNodes.runTo(-1);
    xctxt.pushContextNodeList(sourceNodes);

    try
    {
      sorter.sort(sourceNodes, keys, xctxt);
      sourceNodes.setCurrentPos(0);
    }
    finally
    {
      xctxt.popContextNodeList();
    }

    return sourceNodes;
  }

  
  public void transformSelectedNodes(TransformerImpl transformer)
          throws TransformerException
  {

    final XPathContext xctxt = transformer.getXPathContext();
    final int sourceNode = xctxt.getCurrentNode();
    DTMIterator sourceNodes = m_selectExpression.asIterator(xctxt,
            sourceNode);

    try
    {

      final Vector keys = (m_sortElems == null)
              ? null
              : transformer.processSortKeys(this, sourceNode);

      
      if (null != keys)
        sourceNodes = sortNodes(xctxt, keys, sourceNodes);

      if (TransformerImpl.S_DEBUG)
      {
        transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                ""select"", new XPath(m_selectExpression),
                new org.apache.xpath.objects.XNodeSet(sourceNodes));
      }

      final ResultTreeHandler rth = transformer.getResultTreeHandler();
      ContentHandler chandler = rth.getContentHandler();

      xctxt.pushCurrentNode(DTM.NULL);

      int[] currentNodes = xctxt.getCurrentNodeStack();
      int currentNodePos = xctxt.getCurrentNodeFirstFree() - 1;

      xctxt.pushCurrentExpressionNode(DTM.NULL);

      int[] currentExpressionNodes = xctxt.getCurrentExpressionNodeStack();
      int currentExpressionNodePos =
              xctxt.getCurrentExpressionNodesFirstFree() - 1;

      xctxt.pushSAXLocatorNull();
      xctxt.pushContextNodeList(sourceNodes);
      transformer.pushElemTemplateElement(null);

      
      
      DTM dtm = xctxt.getDTM(sourceNode);
      int docID = sourceNode & DTMManager.IDENT_DTM_DEFAULT;
      int child;

      while (DTM.NULL != (child = sourceNodes.nextNode()))
      {
        currentNodes[currentNodePos] = child;
        currentExpressionNodes[currentExpressionNodePos] = child;

        if ((child & DTMManager.IDENT_DTM_DEFAULT) != docID)
        {
          dtm = xctxt.getDTM(child);
          docID = sourceNode & DTMManager.IDENT_DTM_DEFAULT;
        }

        
        final int nodeType = dtm.getNodeType(child); 

        
        if (TransformerImpl.S_DEBUG)
        {
           transformer.getTraceManager().fireTraceEvent(this);
        }

        
        
        
        for (ElemTemplateElement t = this.m_firstChild; t != null;
             t = t.m_nextSibling)
        {
          xctxt.setSAXLocator(t);
          transformer.setCurrentElement(t);
          t.execute(transformer);
        }
        
        if (TransformerImpl.S_DEBUG)
        {
         
          
          transformer.setCurrentElement(null);
          transformer.getTraceManager().fireTraceEndEvent(this);
        }


	 	
	 	
	 	
	 	
	 	
	 	
	 	
		
	 	
	 	
	 	if(m_doc_cache_off)
		{
	 	  if(DEBUG)
	 	    System.out.println(""JJK***** CACHE RELEASE *****
""+
				       ""	dtm=""+dtm.getDocumentBaseURI());
	  	
	  	
	 	
	 	  xctxt.getSourceTreeManager().removeDocumentFromCache(dtm.getDocument());
	 	  xctxt.release(dtm,false);
	 	}
      }
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireSelectedEndEvent(sourceNode, this,
                ""select"", new XPath(m_selectExpression),
                new org.apache.xpath.objects.XNodeSet(sourceNodes));

      xctxt.popSAXLocator();
      xctxt.popContextNodeList();
      transformer.popElemTemplateElement();
      xctxt.popCurrentExpressionNode();
      xctxt.popCurrentNode();
      sourceNodes.detach();
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    if (Constants.ELEMNAME_SORT == type)
    {
      setSortElem((ElemSort) newChild);

      return newChild;
    }
    else
      return super.appendChild(newChild);
  }
  
  
  public void callChildVisitors(XSLTVisitor visitor, boolean callAttributes)
  {
  	if(callAttributes && (null != m_selectExpression))
  		m_selectExpression.callVisitors(this, visitor);
  		
    int length = getSortElemCount();

    for (int i = 0; i < length; i++)
    {
      getSortElem(i).callVisitors(visitor);
    }

    super.callChildVisitors(visitor, callAttributes);
  }

  
  public Expression getExpression()
  {
    return m_selectExpression;
  }

  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_selectExpression = exp;
  }

}
"
org.apache.xalan.extensions.ExtensionHandlerJavaClass,6,3,0,9,37,0,0,9,5,0.76,505,0.4,0,0.615384615,0.375,2,6,82.33333333,8,2.3333,2,"

package org.apache.xalan.extensions;

import java.util.Vector;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.io.IOException;



import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xml.utils.QName;

import org.apache.xpath.objects.XObject;
import javax.xml.transform.TransformerException;



public class ExtensionHandlerJavaClass extends ExtensionHandlerJava
{

  private Class m_classObj = null;

  

  private Object m_defaultInstance = null;


  
  public ExtensionHandlerJavaClass(String namespaceUri,
                                   String scriptLang,
                                   String className)
  {
    super(namespaceUri, scriptLang, className);
    try
    {
      m_classObj = getClassForName(className);
    }
    catch (ClassNotFoundException e)
    {
      
    }
  }


  

  public boolean isFunctionAvailable(String function) 
  {
    Method[] methods = m_classObj.getMethods();
    int nMethods = methods.length;
    for (int i = 0; i < nMethods; i++)
    {
      if (methods[i].getName().equals(function))
        return true;
    }
    return false;
  }


  

  public boolean isElementAvailable(String element) 
  {
    Method[] methods = m_classObj.getMethods();
    int nMethods = methods.length;
    for (int i = 0; i < nMethods; i++)
    {
      if (methods[i].getName().equals(element))
      {
        Class[] paramTypes = methods[i].getParameterTypes();
        if ( (paramTypes.length == 2)
          && paramTypes[0].isAssignableFrom(
                                     org.apache.xalan.extensions.XSLProcessorContext.class)
          && paramTypes[1].isAssignableFrom(org.apache.xalan.templates.ElemExtensionCall.class) )
        {
          return true;
        }
      }
    }
    return false;
  }


  

  public Object callFunction (String funcName, 
                              Vector args, 
                              Object methodKey,
                              ExpressionContext exprContext)
    throws TransformerException 
  {

    Object[] methodArgs;
    Object[][] convertedArgs;
    Class[] paramTypes;

    try
    {
      if (funcName.equals(""new"")) {                   

        methodArgs = new Object[args.size()];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i);
        }
        Constructor c = (Constructor) getFromCache(methodKey, null, methodArgs);
        if (c != null)
        {
          try
          {
            paramTypes = c.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            return c.newInstance(convertedArgs[0]);
          }
          catch(Exception e)
          {
            
          }
        }
        c = MethodResolver.getConstructor(m_classObj, 
                                          methodArgs,
                                          convertedArgs,
                                          exprContext);
        putToCache(methodKey, null, methodArgs, c);
        return c.newInstance(convertedArgs[0]);
      }

      else
      {

        int resolveType;
        Object targetObject = null;
        methodArgs = new Object[args.size()];
        convertedArgs = new Object[1][];
        for (int i = 0; i < methodArgs.length; i++)
        {
          methodArgs[i] = args.elementAt(i);
        }
        Method m = (Method) getFromCache(methodKey, null, methodArgs);
        if (m != null)
        {
          try
          {
            paramTypes = m.getParameterTypes();
            MethodResolver.convertParams(methodArgs, convertedArgs, paramTypes, exprContext);
            if (Modifier.isStatic(m.getModifiers()))
              return m.invoke(null, convertedArgs[0]);
            else
            {
              
              
              int nTargetArgs = convertedArgs[0].length;
              if (ExpressionContext.class.isAssignableFrom(paramTypes[0]))
                nTargetArgs--;
              if (methodArgs.length <= nTargetArgs)
                return m.invoke(m_defaultInstance, convertedArgs[0]);
              else  
              {
                targetObject = methodArgs[0];
                
                if (targetObject instanceof XObject)
                  targetObject = ((XObject) targetObject).object();
                  
                return m.invoke(targetObject, convertedArgs[0]);
              }
            }
          }
          catch(Exception e)
          {
            
          }
        }

        if (args.size() > 0)
        {
          targetObject = methodArgs[0];

          if (targetObject instanceof XObject)
            targetObject = ((XObject) targetObject).object();

          if (m_classObj.isAssignableFrom(targetObject.getClass()))
            resolveType = MethodResolver.DYNAMIC;
          else
            resolveType = MethodResolver.STATIC_AND_INSTANCE;
        }
        else
        {
          targetObject = null;
          resolveType = MethodResolver.STATIC_AND_INSTANCE;
        }

        m = MethodResolver.getMethod(m_classObj,
                                     funcName,
                                     methodArgs, 
                                     convertedArgs,
                                     exprContext,
                                     resolveType);
        putToCache(methodKey, null, methodArgs, m);

        if (MethodResolver.DYNAMIC == resolveType)          
          return m.invoke(targetObject, convertedArgs[0]);
        else                                  
        {
          if (Modifier.isStatic(m.getModifiers()))
            return m.invoke(null, convertedArgs[0]);
          else
          {
            if (null == m_defaultInstance)
            {
              m_defaultInstance = m_classObj.newInstance();
            }
            return m.invoke(m_defaultInstance, convertedArgs[0]);
          }  
        }

      }
    }
    catch (InvocationTargetException ite)
    {
      Throwable realException = ite.getTargetException();
      if (realException instanceof Exception)
        throw new TransformerException((Exception) realException);
      else
        throw new TransformerException(ite);
    }
    catch (Exception e)
    {
      
      throw new TransformerException(e);
    }
  }


  

  public void processElement(String localPart,
                             ElemTemplateElement element,
                             TransformerImpl transformer,
                             Stylesheet stylesheetTree,
                             Object methodKey)
    throws TransformerException, IOException
  {
    Object result = null;

    Method m = (Method) getFromCache(methodKey, null, null);
    if (null == m)
    {
      try
      {
        m = MethodResolver.getElementMethod(m_classObj, localPart);
        if ( (null == m_defaultInstance) && !Modifier.isStatic(m.getModifiers()) )
          m_defaultInstance = m_classObj.newInstance();
      }
      catch (Exception e)
      {
        
        throw new TransformerException (e.getMessage (), e);
      }
      putToCache(methodKey, null, null, m);
    }

    XSLProcessorContext xpc = new XSLProcessorContext(transformer, 
                                                      stylesheetTree);

    try
    {
      result = m.invoke(m_defaultInstance, new Object[] {xpc, element});
    }
    catch (InvocationTargetException e)
    {
      Throwable targetException = e.getTargetException();
      
      if (targetException != null)
        throw new TransformerException (targetException.getMessage (), targetException);
      else
        throw new TransformerException (e.getMessage (), e);
    }
    catch (Exception e)
    {
      
      throw new TransformerException (e.getMessage (), e);
    }

    if (result != null)
    {
      xpc.outputToResultTree (stylesheetTree, result);
    }
 
  }
 
}
"
org.apache.xml.dtm.DTM,66,1,0,77,66,2145,74,3,66,1.015384615,81,0.0,0,0.0,0.277056277,0,0,0.0,1,1.0,0,"
package org.apache.xml.dtm;

import org.apache.xml.utils.XMLString;

import javax.xml.transform.SourceLocator;


public interface DTM
{

  
  public static final int NULL = -1;

  
  
  
  
  

  
  public static final short ELEMENT_NODE = 1;

  
  public static final short ATTRIBUTE_NODE = 2;

  
  public static final short TEXT_NODE = 3;

  
  public static final short CDATA_SECTION_NODE = 4;

  
  public static final short ENTITY_REFERENCE_NODE = 5;

  
  public static final short ENTITY_NODE = 6;

  
  public static final short PROCESSING_INSTRUCTION_NODE = 7;

  
  public static final short COMMENT_NODE = 8;

  
  public static final short DOCUMENT_NODE = 9;

  
  public static final short DOCUMENT_TYPE_NODE = 10;

  
  public static final short DOCUMENT_FRAGMENT_NODE = 11;

  
  public static final short NOTATION_NODE = 12;

  
  public static final short NAMESPACE_NODE = 13;
  
  
  public static final short  NTYPES = 14;

  
  
  

  
  public void setFeature(String featureId, boolean state);

  
  public void setProperty(String property, Object value);

  

  
  public DTMAxisTraverser getAxisTraverser(final int axis);

  
  public DTMAxisIterator getAxisIterator(final int axis);

  
  public DTMAxisIterator getTypedAxisIterator(final int axis, final int type);

  
  public boolean hasChildNodes(int nodeHandle);

  
  public int getFirstChild(int nodeHandle);

  
  public int getLastChild(int nodeHandle);

  
  public int getAttributeNode(int elementHandle, String namespaceURI,
                              String name);

  
  public int getFirstAttribute(int nodeHandle);

  
  public int getFirstNamespaceNode(int nodeHandle, boolean inScope);

  
  public int getNextSibling(int nodeHandle);

  
  public int getPreviousSibling(int nodeHandle);

  
  public int getNextAttribute(int nodeHandle);

  
  public int getNextNamespaceNode(int baseHandle, int namespaceHandle,
                                  boolean inScope);

  
  public int getParent(int nodeHandle);

  
  public int getDocument();

  
  public int getOwnerDocument(int nodeHandle);

  
  public int getDocumentRoot(int nodeHandle);

  
  public XMLString getStringValue(int nodeHandle);

  
  public int getStringValueChunkCount(int nodeHandle);

  
  public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
                                    int[] startAndLen);

  
  public int getExpandedTypeID(int nodeHandle);

  
  public int getExpandedTypeID(String namespace, String localName, int type);

  
  public String getLocalNameFromExpandedNameID(int ExpandedNameID);

  
  public String getNamespaceFromExpandedNameID(int ExpandedNameID);

  
  public String getNodeName(int nodeHandle);

  
  public String getNodeNameX(int nodeHandle);

  
  public String getLocalName(int nodeHandle);

  
  public String getPrefix(int nodeHandle);

  
  public String getNamespaceURI(int nodeHandle);

  
  public String getNodeValue(int nodeHandle);

  
  public short getNodeType(int nodeHandle);

  
  public short getLevel(int nodeHandle);

  

  
  public boolean isSupported(String feature, String version);

  
  public String getDocumentBaseURI();

  
  public void setDocumentBaseURI(String baseURI);

  
  public String getDocumentSystemIdentifier(int nodeHandle);

  
  public String getDocumentEncoding(int nodeHandle);

  
  public String getDocumentStandalone(int nodeHandle);

  
  public String getDocumentVersion(int documentHandle);

  
  public boolean getDocumentAllDeclarationsProcessed();

  
  public String getDocumentTypeDeclarationSystemIdentifier();

  
  public String getDocumentTypeDeclarationPublicIdentifier();

  
  public int getElementById(String elementId);

  
  public String getUnparsedEntityURI(String name);

  

  
  public boolean supportsPreStripping();

  
  public boolean isNodeAfter(int firstNodeHandle, int secondNodeHandle);

  
  public boolean isCharacterElementContentWhitespace(int nodeHandle);

  
  public boolean isDocumentAllDeclarationsProcessed(int documentHandle);

  
  public boolean isAttributeSpecified(int attributeHandle);

  

  
  public void dispatchCharactersEvents(
    int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize)
      throws org.xml.sax.SAXException;

  
  public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
    throws org.xml.sax.SAXException;

  
  public org.w3c.dom.Node getNode(int nodeHandle);

  
  

  
  public boolean needsTwoThreads();

  
  
  
  
  

  
  public org.xml.sax.ContentHandler getContentHandler();

  
  public org.xml.sax.ext.LexicalHandler getLexicalHandler();

  
  public org.xml.sax.EntityResolver getEntityResolver();

  
  public org.xml.sax.DTDHandler getDTDHandler();

  
  public org.xml.sax.ErrorHandler getErrorHandler();

  
  public org.xml.sax.ext.DeclHandler getDeclHandler();

  
  public void appendChild(int newChild, boolean clone, boolean cloneDepth);

  
  public void appendTextChild(String str);

  
  public SourceLocator getSourceLocatorFor(int node);

  
  public void documentRegistration();

  

   public void documentRelease();
}
"
org.apache.xalan.xsltc.dom.KeyIndex,17,1,0,5,35,0,2,3,17,0.7109375,375,1.0,2,0.0,0.341176471,0,0,20.58823529,6,2.1176,1,"

package org.apache.xalan.xsltc.dom;

import java.util.Vector;
import java.util.StringTokenizer;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.Hashtable;

public class KeyIndex implements NodeIterator {

    private Hashtable _index = new Hashtable();
    private BitArray  _nodes = null;
    private int       _pos = 0;
    private int       _mark = 0;
    private int       _save = 0;
    private int       _start = 0;
    private int       _arraySize = 0;
    private int       _node = -1;

    
    public KeyIndex(int size) {
	_arraySize = size;
    }

    public void setRestartable(boolean flag) {
	    
    }
 
    
    public void add(Object value, int node) {
	if ((_nodes = (BitArray)_index.get(value)) == null) {
	    _nodes = new BitArray(_arraySize);
	    _nodes.setMask(node & 0xff000000);
	    _index.put(value,_nodes);
	}
	_nodes.setBit(node & 0x00ffffff);

	
    }

    
    public void merge(KeyIndex other) {
	
	if (other != null) {
	    if (other._nodes != null) {
		
		if (_nodes == null)
		    _nodes = other._nodes;
		else
		    _nodes = _nodes.merge(other._nodes);
	    }
	}
    }

    
    public void lookupId(Object value) {
	if (value instanceof String) {
	    final String string = (String)value;
	    if (string.indexOf(' ') > -1) {
		StringTokenizer values = new StringTokenizer(string);
		while (values.hasMoreElements()) {
		    BitArray nodes = (BitArray)_index.get(values.nextElement());
		    if (nodes != null) {
			if (_nodes == null)
			    _nodes = nodes;
			else
			    _nodes = _nodes.merge(nodes);
		    }
		}
		return;
	    }
	}
	_nodes = (BitArray)_index.get(value);
    }

    
    public void lookupKey(Object value) {
	_nodes = (BitArray)_index.get(value);
    }

    
    public int next() {
	if (_nodes == null) return(END);
	if ((_node = _nodes.getNextBit(++_node)) == END) return(END);
	_pos++;
	return(_node | _nodes.getMask());
    }

    public int containsID(int node, Object value) { 
	if (value instanceof String) {
	    final String string = (String)value;
	    if (string.indexOf(' ') > -1) {
		StringTokenizer values = new StringTokenizer(string);
		while (values.hasMoreElements()) {
		    BitArray nodes = (BitArray)_index.get(values.nextElement());
		    if ((nodes != null) && (nodes.getBit(node))) return(1);
		}
		return(0);
	    }
	}

	BitArray nodes = (BitArray)_index.get(value);
	if ((nodes != null) && (nodes.getBit(node))) return(1);
	return(0);
    }

    public int containsKey(int node, Object value) { 
	BitArray nodes = (BitArray)_index.get(value);
	if ((nodes != null) && (nodes.getBit(node))) return(1);
	return(0);
    }

    
    public NodeIterator reset() {
	_pos = _start;
	_node = _start - 1;
	return(this);
    }

    
    public int getLast() {
	if (_nodes == null)
	    return(0);
	else
	    return(_nodes.size()); 
    }

    
    public int getPosition() {
	return(_pos);
    }

    
    public void setMark() {
	_mark = _pos;
	_save = _node;
    }

    
    public void gotoMark() {
	_pos = _mark;
	_node = _save;
    }

    
    public NodeIterator setStartNode(int start) {
	if (start == END) {
	    _nodes = null;
	}
	else if (_nodes != null) {
	    
	    
	    _start = _nodes.getBitNumber(start-1); 
	    _node = _start - 1;
	}
	return((NodeIterator)this);
    }

    
    public boolean isReverse() {
	return(false);
    }

    
    public NodeIterator cloneIterator() {
	KeyIndex other = new KeyIndex(_arraySize);

	other._index = _index;
	other._nodes = _nodes.cloneArray();
	other._pos   = _pos;
	other._start = _start;
	other._node  = _node;

	return(other);
    }

}
"
org.apache.xalan.extensions.ExtensionHandler,8,1,3,13,17,26,9,4,5,0.942857143,91,0.8,0,0.0,0.339285714,0,0,9.75,1,0.75,1,"
package org.apache.xalan.extensions;

import java.util.Vector;
import java.lang.reflect.Method;

import java.io.IOException;

import javax.xml.transform.TransformerException;

import org.w3c.dom.Element;
import org.w3c.dom.Node;

import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xml.utils.QName;


import org.apache.xalan.transformer.TransformerImpl;


public abstract class ExtensionHandler
{

  
  protected String m_namespaceUri; 

  
  protected String m_scriptLang;

  
  private static final Object NO_OBJS[] = new Object[0];

  
  private static Method getCCL;

  static
  {
    try
    {
      getCCL = Thread.class.getMethod(""getContextClassLoader"", new Class[0]);
    }
    catch (Exception e)
    {
      getCCL = null;
    }
  }

  
  public static Class getClassForName(String className)
      throws ClassNotFoundException
  {
    Class result = null;
    
    
    if(className.equals(""org.apache.xalan.xslt.extensions.Redirect""))
      className = ""org.apache.xalan.lib.Redirect"";
      
    if (getCCL != null)
    {
      try {
        ClassLoader contextClassLoader =
                              (ClassLoader) getCCL.invoke(Thread.currentThread(), NO_OBJS);
        result = contextClassLoader.loadClass(className);
      }
      catch (ClassNotFoundException cnfe)
      {
        result = Class.forName(className);
      }
      catch (Exception e)
      {
        getCCL = null;
        result = Class.forName(className);
      }
    }

    else
       result = Class.forName(className);

    return result;
 }


  
  protected ExtensionHandler(String namespaceUri, String scriptLang)
  {
    m_namespaceUri = namespaceUri;
    m_scriptLang = scriptLang;
  }

  
  public abstract boolean isFunctionAvailable(String function);

  
  public abstract boolean isElementAvailable(String element);

  
  public abstract Object callFunction(
    String funcName, Vector args, Object methodKey,
      ExpressionContext exprContext) throws TransformerException;

  
  public abstract void processElement(
    String localPart, ElemTemplateElement element, TransformerImpl transformer,
      Stylesheet stylesheetTree, Object methodKey) throws TransformerException, IOException;
}
"
org.apache.xml.dtm.ref.NodeLocator,6,1,0,1,11,0,1,0,6,0.65,57,1.0,0,0.0,0.444444444,0,0,7.833333333,1,0.8333,0,"

package org.apache.xml.dtm.ref;

import javax.xml.transform.SourceLocator;


public class NodeLocator implements SourceLocator
{
  protected String m_publicId;
  protected String m_systemId;
  protected int m_lineNumber;
  protected int m_columnNumber;

  
  public NodeLocator(String publicId, String systemId,
                     int lineNumber, int columnNumber)
  {
    this.m_publicId = publicId;
    this.m_systemId = systemId;
    this.m_lineNumber = lineNumber;
    this.m_columnNumber = columnNumber;
  }

  
  public String getPublicId()
  {
    return m_publicId;
  }

  
  public String getSystemId()
  {
    return m_systemId;
  }

  
  public int getLineNumber()
  {
    return m_lineNumber;
  }

  
  public int getColumnNumber()
  {
    return m_columnNumber;
  }

  
  public String toString()
  {
    return ""file '"" + m_systemId
      + ""', line #"" + m_lineNumber
      + "", column #"" + m_columnNumber;
  }
}
"
org.apache.xml.dtm.DTMFilter,2,1,0,5,2,1,5,0,2,2.0,17,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xml.dtm;


public interface DTMFilter
{

  
  
  

  
  public static final int SHOW_ALL = 0xFFFFFFFF;

  
  public static final int SHOW_ELEMENT = 0x00000001;

  
  public static final int SHOW_ATTRIBUTE = 0x00000002;

  
  public static final int SHOW_TEXT = 0x00000004;

  
  public static final int SHOW_CDATA_SECTION = 0x00000008;

  
  public static final int SHOW_ENTITY_REFERENCE = 0x00000010;

  
  public static final int SHOW_ENTITY = 0x00000020;

  
  public static final int SHOW_PROCESSING_INSTRUCTION = 0x00000040;

  
  public static final int SHOW_COMMENT = 0x00000080;

  
  public static final int SHOW_DOCUMENT = 0x00000100;

  
  public static final int SHOW_DOCUMENT_TYPE = 0x00000200;

  
  public static final int SHOW_DOCUMENT_FRAGMENT = 0x00000400;

  
  public static final int SHOW_NOTATION = 0x00000800;
  
  
  public static final int SHOW_NAMESPACE = 0x00001000;

  
  public static final int SHOW_BYFUNCTION = 0x00010000;

  
  public short acceptNode(int nodeHandle, int whatToShow);
  
  
  public short acceptNode(int nodeHandle, int whatToShow, int expandedName);
 
}
"
org.apache.xalan.transformer.NodeSortKey,1,1,0,6,10,0,3,4,0,2.0,80,0.0,3,0.0,1.0,0,0,71.0,0,0.0,0,"
package org.apache.xalan.transformer;

import java.util.Locale;

import org.apache.xpath.XPath;

import java.text.Collator;

import org.apache.xalan.res.XSLTErrorResources;


class NodeSortKey
{

  
  XPath m_selectPat;

  
  boolean m_treatAsNumbers;

  
  boolean m_descending;

  
  boolean m_caseOrderUpper;

  
  Collator m_col;

  
  Locale m_locale;

  
  org.apache.xml.utils.PrefixResolver m_namespaceContext;

  
  TransformerImpl m_processor;  

  
  NodeSortKey(
          TransformerImpl transformer, XPath selectPat, boolean treatAsNumbers, 
          boolean descending, String langValue, boolean caseOrderUpper, 
          org.apache.xml.utils.PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    m_processor = transformer;
    m_namespaceContext = namespaceContext;
    m_selectPat = selectPat;
    m_treatAsNumbers = treatAsNumbers;
    m_descending = descending;
    m_caseOrderUpper = caseOrderUpper;

    if (null != langValue && m_treatAsNumbers == false)
    {
      
      
      
      
      
      
      
      
      
      
      m_locale = new Locale(langValue.toLowerCase(), 
                  Locale.getDefault().getCountry());
                  
      
      
      

      if (null == m_locale)
      {

        
        m_locale = Locale.getDefault();
      }
    }
    else
    {
      m_locale = Locale.getDefault();
    }

    m_col = Collator.getInstance(m_locale);

    if (null == m_col)
    {
      m_processor.getMsgMgr().warn(null, XSLTErrorResources.WG_CANNOT_FIND_COLLATOR,
                                   new Object[]{ langValue });  

      m_col = Collator.getInstance();
    }
  }
}
"
org.apache.xpath.axes.PathComponent,1,1,0,8,1,0,8,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xpath.axes;


public interface PathComponent
{
  
  public int getAnalysisBits();

}

"
org.apache.xalan.lib.ExsltSets,7,1,0,4,19,21,0,4,7,2.0,158,0.0,0,0.0,0.380952381,0,0,21.57142857,6,2.5714,0,"
package org.apache.xalan.lib;

import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.NodeList;
import org.w3c.dom.Text;
import org.w3c.dom.traversal.NodeIterator;

import org.apache.xpath.NodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XRTreeFrag;

import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.DOMHelper;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xml.utils.XMLString;

import org.xml.sax.SAXNotSupportedException;

import java.util.Hashtable;
import java.util.StringTokenizer;

import org.apache.xalan.extensions.ExpressionContext;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.xslt.EnvironmentCheck;

import javax.xml.parsers.*;


public class ExsltSets
{   
  
  public static NodeSet leading (NodeIterator ni1, NodeIterator ni2)
  {
    NodeSet ns1 = new NodeSet(ni1);
    NodeSet ns2 = new NodeSet(ni2);
    NodeSet leadNodes = new NodeSet();
    if (ns2.getLength() == 0)
      return ns1;
    Node endNode = ns2.elementAt(0);
    if (!ns1.contains(endNode))
      return leadNodes; 
    for (int i = 0; i < ns1.getLength(); i++)
    {
      Node testNode = ns1.elementAt(i);
      if (DOMHelper.isNodeAfter(testNode, endNode) 
          && !(DOMHelper.isNodeTheSame(testNode, endNode)))
        leadNodes.addElement(testNode);
    }
    return leadNodes;
  }
  
  
  public static NodeSet trailing (NodeIterator ni1, NodeIterator ni2)
  {
    NodeSet ns1 = new NodeSet(ni1);
    NodeSet ns2 = new NodeSet(ni2);
    NodeSet trailNodes = new NodeSet();
    if (ns2.getLength() == 0)
      return ns1;
    Node startNode = ns2.elementAt(0);
    if (!ns1.contains(startNode))
      return trailNodes; 
    for (int i = 0; i < ns1.getLength(); i++)
    {
      Node testNode = ns1.elementAt(i);
      if (DOMHelper.isNodeAfter(startNode, testNode) 
          && !(DOMHelper.isNodeTheSame(startNode, testNode)))
        trailNodes.addElement(testNode);          
    }
    return trailNodes;
  }
  
  
  public static NodeSet intersection(NodeIterator ni1, NodeIterator ni2)
          throws javax.xml.transform.TransformerException
  {
    return Extensions.intersection(ni1, ni2);
  }
  
  
  public static NodeSet difference(NodeIterator ni1, NodeIterator ni2)
          throws javax.xml.transform.TransformerException
  {
    return Extensions.difference(ni1, ni2);
  }
  
  
  public static NodeSet distinct(ExpressionContext myContext, NodeIterator ni)
          throws javax.xml.transform.TransformerException
  {
    return Extensions.distinct(myContext, ni);
  }
  
  
  public static boolean hasSameNode(NodeIterator ni1, NodeIterator ni2)
  {
    
    NodeSet ns1 = new NodeSet(ni1);
    NodeSet ns2 = new NodeSet(ni2);

    for (int i = 0; i < ns1.getLength(); i++)
    {
      if (ns2.contains(ns1.elementAt(i)))
        return true;
    }
    return false;
  }
  
}"
org.apache.xalan.xsltc.trax.OutputSettings,2,1,0,0,4,1,0,0,2,1.0,47,1.0,0,0.0,1.0,0,0,18.0,1,0.5,0,"

package org.apache.xalan.xsltc.trax;

import javax.xml.transform.*;

import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.compiler.*;
import org.apache.xalan.xsltc.runtime.*;

import java.util.Properties;

public final class OutputSettings {
    
    private String _cdata_section_elements = null;
    private String _doctype_public = null;
    private String _encoding = null;
    private String _indent = null;
    private String _media_type = null;
    private String _method = null;
    private String _omit_xml_declaration = null;
    private String _standalone = null;
    private String _version = null;

    public Properties getProperties() {
	Properties properties = new Properties();
	return(properties);
    }

    
}
"
org.apache.xalan.templates.FuncDocument,8,5,0,17,66,28,1,16,6,2.0,543,0.0,0,0.888888889,0.475,3,8,66.875,1,0.875,1,"
package org.apache.xalan.templates;

import java.util.Vector;

import java.io.StringWriter;
import java.io.PrintWriter;
import java.io.IOException;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;

import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.functions.Function;
import org.apache.xpath.functions.Function2Args;
import org.apache.xpath.functions.WrongNumberArgsException;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.SourceTreeManager;
import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xpath.XPathContext;
import org.apache.xalan.transformer.TransformerImpl;

import org.xml.sax.InputSource;
import org.xml.sax.Locator;

import javax.xml.transform.TransformerException;
import javax.xml.transform.SourceLocator;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.Source;

import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xml.utils.XMLString;


public class FuncDocument extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    
    int docContext = dtm.getDocumentRoot(context);
    XObject arg = (XObject) this.getArg0().execute(xctxt);

    String base = """";
    Expression arg1Expr = this.getArg1();

    if (null != arg1Expr)
    {

      
      
      
      
      XObject arg2 = arg1Expr.execute(xctxt);

      if (XObject.CLASS_NODESET == arg2.getType())
      {
        int baseNode = arg2.iter().nextNode();

        if (baseNode == DTM.NULL)
          warn(xctxt, XSLTErrorResources.WG_EMPTY_SECOND_ARG, null);
        
        DTM baseDTM = xctxt.getDTM(baseNode);
        base = baseDTM.getDocumentBaseURI();

        
        










      }
      else
      {
        base = arg2.str();
      }
    }
    else
    {

      
      
      
      
      
      
      
      
      
      assertion(null != xctxt.getNamespaceContext(), ""Namespace context can not be null!"");
      base = xctxt.getNamespaceContext().getBaseIdentifier();
    }

    XNodeSet nodes = new XNodeSet(xctxt.getDTMManager());
    NodeSetDTM mnl = nodes.mutableNodeset();
    DTMIterator iterator = (XObject.CLASS_NODESET == arg.getType())
                            ? arg.iter() : null;
    int pos = DTM.NULL;

    while ((null == iterator) || (DTM.NULL != (pos = iterator.nextNode())))
    {
      XMLString ref = (null != iterator)
                   ? xctxt.getDTM(pos).getStringValue(pos) : arg.xstr();
      
      
      
      
      
      
      
      
      
      if (null == arg1Expr && DTM.NULL != pos)
      {
        DTM baseDTM = xctxt.getDTM(pos);
        base = baseDTM.getDocumentBaseURI();
      }

      if (null == ref)
        continue;

      if (DTM.NULL == docContext)
      {
        error(xctxt, XSLTErrorResources.ER_NO_CONTEXT_OWNERDOC, null);  
      }

      
      
      
      
      
      
      int indexOfColon = ref.indexOf(':');
      int indexOfSlash = ref.indexOf('/');

      if ((indexOfColon != -1) && (indexOfSlash != -1)
              && (indexOfColon < indexOfSlash))
      {

        
        base = null;
      }

      int newDoc = getDoc(xctxt, context, ref.toString(), base);

      
      if (DTM.NULL != newDoc)
      {
        
        if (!mnl.contains(newDoc))
        {
          mnl.addElement(newDoc);
        }
      }

      if (null == iterator || newDoc == DTM.NULL)
        break;
    }

    return nodes;
  }

  
  int getDoc(XPathContext xctxt, int context, String uri, String base)
          throws javax.xml.transform.TransformerException
  {

    
    SourceTreeManager treeMgr = xctxt.getSourceTreeManager();
    Source source;
   
    int newDoc;
    try
    {
      source = treeMgr.resolveURI(base, uri, xctxt.getSAXLocator());
      newDoc = treeMgr.getNode(source);
    }
    catch (IOException ioe)
    {
      throw new TransformerException(ioe.getMessage(), 
        (SourceLocator)xctxt.getSAXLocator(), ioe);
    }
    catch(TransformerException te)
    {
      throw new TransformerException(te);
    }

    if (DTM.NULL != newDoc)
      return newDoc;

    
    if (uri.length() == 0)
    {
      
      uri = xctxt.getNamespaceContext().getBaseIdentifier();
      try
      {
        source = treeMgr.resolveURI(base, uri, xctxt.getSAXLocator());
      }
      catch (IOException ioe)
      {
        throw new TransformerException(ioe.getMessage(), 
          (SourceLocator)xctxt.getSAXLocator(), ioe);
      }
    }

    String diagnosticsString = null;

    try
    {
      if ((null != uri) && (uri.toString().length() > 0))
      {
        newDoc = treeMgr.getSourceTree(source, xctxt.getSAXLocator(), xctxt);

        
      }
      else
        warn(xctxt, XSLTErrorResources.WG_CANNOT_MAKE_URL_FROM,
             new Object[]{ ((base == null) ? """" : base) + uri });  
    }
    catch (Throwable throwable)
    {

      
      newDoc = DTM.NULL;

      
      while (throwable
             instanceof org.apache.xml.utils.WrappedRuntimeException)
      {
        throwable =
          ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();
      }

      if ((throwable instanceof NullPointerException)
              || (throwable instanceof ClassCastException))
      {
        throw new org.apache.xml.utils.WrappedRuntimeException(
          (Exception) throwable);
      }

      StringWriter sw = new StringWriter();
      PrintWriter diagnosticsWriter = new PrintWriter(sw);

      if (throwable instanceof TransformerException)
      {
        TransformerException spe = (TransformerException) throwable;

        {
          Throwable e = spe;

          while (null != e)
          {
            if (null != e.getMessage())
            {
              diagnosticsWriter.println("" ("" + e.getClass().getName() + ""): ""
                                        + e.getMessage());
            }

            if (e instanceof TransformerException)
            {
              TransformerException spe2 = (TransformerException) e;

              SourceLocator locator = spe2.getLocator();
              if ((null != locator) && (null != locator.getSystemId()))
                diagnosticsWriter.println(""   ID: "" + locator.getSystemId()
                                          + "" Line #"" + locator.getLineNumber()
                                          + "" Column #""
                                          + locator.getColumnNumber());

              e = spe2.getException();

              if (e instanceof org.apache.xml.utils.WrappedRuntimeException)
                e = ((org.apache.xml.utils.WrappedRuntimeException) e).getException();
            }
            else
              e = null;
          }
        }
      }
      else
      {
        diagnosticsWriter.println("" ("" + throwable.getClass().getName()
                                  + ""): "" + throwable.getMessage());
      }

      diagnosticsString = throwable.getMessage(); 
    }

    if (DTM.NULL == newDoc)
    {

      
      if (null != diagnosticsString)
      {
        warn(xctxt, XSLTErrorResources.WG_CANNOT_LOAD_REQUESTED_DOC,
             new Object[]{ diagnosticsString });  
      }
      else
        warn(xctxt, XSLTErrorResources.WG_CANNOT_LOAD_REQUESTED_DOC,
             new Object[]{
               uri == null
               ? ((base == null) ? """" : base) + uri : uri.toString() });  
    }
    else
    {
      
      
      
    }

    return newDoc;
  }

  
  public void error(XPathContext xctxt, int msg, Object args[])
          throws javax.xml.transform.TransformerException
  {

    String formattedMsg = XSLMessages.createMessage(msg, args);
    ErrorListener errHandler = xctxt.getErrorListener();
    TransformerException spe = new TransformerException(formattedMsg,
                              (SourceLocator)xctxt.getSAXLocator());

    if (null != errHandler)
      errHandler.error(spe);
    else
      System.out.println(formattedMsg);
  }

  
  public void warn(XPathContext xctxt, int msg, Object args[])
          throws javax.xml.transform.TransformerException
  {

    String formattedMsg = XSLMessages.createWarning(msg, args);
    ErrorListener errHandler = xctxt.getErrorListener();
    TransformerException spe = new TransformerException(formattedMsg,
                              (SourceLocator)xctxt.getSAXLocator());

    if (null != errHandler)
      errHandler.warning(spe);
    else
      System.out.println(formattedMsg);
  }

 
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if ((argNum < 1) || (argNum > 2))
      reportWrongNumberArgs();
  }
  
  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createMessage(XSLTErrorResources.ER_ONE_OR_TWO, null)); 
  }
  
  
  public boolean isNodesetExpr()
  {
    return true;
  }

}
"
org.apache.xml.dtm.DTMException,15,4,1,9,35,0,8,1,15,0.392857143,357,0.0,0,0.62962963,0.311111111,1,2,22.66666667,8,2.0,0,"package org.apache.xml.dtm;


import java.lang.reflect.Method;
import java.lang.IllegalAccessException;
import java.lang.reflect.InvocationTargetException;

import javax.xml.transform.SourceLocator;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;




public class DTMException extends RuntimeException {

    
    SourceLocator locator;

    
    public SourceLocator getLocator() {
        return locator;
    }

    
    public void setLocator(SourceLocator location) {
        locator = location;
    }

    
    Throwable containedException;

    
    public Throwable getException() {
        return containedException;
    }

    
    public Throwable getCause() {

        return ((containedException == this)
                ? null
                : containedException);
    }

    
    public synchronized Throwable initCause(Throwable cause) {

        if ((this.containedException == null) && (cause != null)) {
            throw new IllegalStateException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_OVERWRITE_CAUSE, null)); 
        }

        if (cause == this) {
            throw new IllegalArgumentException(
                XSLMessages.createMessage(XSLTErrorResources.ER_SELF_CAUSATION_NOT_PERMITTED, null)); 
        }

        this.containedException = cause;

        return this;
    }

    
    public DTMException(String message) {

        super(message);

        this.containedException = null;
        this.locator            = null;
    }

    
    public DTMException(Throwable e) {

        super(e.getMessage());

        this.containedException = e;
        this.locator            = null;
    }

    
    public DTMException(String message, Throwable e) {

        super(((message == null) || (message.length() == 0))
              ? e.getMessage()
              : message);

        this.containedException = e;
        this.locator            = null;
    }

    
    public DTMException(String message, SourceLocator locator) {

        super(message);

        this.containedException = null;
        this.locator            = locator;
    }

    
    public DTMException(String message, SourceLocator locator,
                                Throwable e) {

        super(message);

        this.containedException = e;
        this.locator            = locator;
    }

    
    public String getMessageAndLocation() {

        StringBuffer sbuffer = new StringBuffer();
        String       message = super.getMessage();

        if (null != message) {
            sbuffer.append(message);
        }

        if (null != locator) {
            String systemID = locator.getSystemId();
            int    line     = locator.getLineNumber();
            int    column   = locator.getColumnNumber();

            if (null != systemID) {
                sbuffer.append(""; SystemID: "");
                sbuffer.append(systemID);
            }

            if (0 != line) {
                sbuffer.append(""; Line#: "");
                sbuffer.append(line);
            }

            if (0 != column) {
                sbuffer.append(""; Column#: "");
                sbuffer.append(column);
            }
        }

        return sbuffer.toString();
    }

    
    public String getLocationAsString() {

        if (null != locator) {
            StringBuffer sbuffer  = new StringBuffer();
            String       systemID = locator.getSystemId();
            int          line     = locator.getLineNumber();
            int          column   = locator.getColumnNumber();

            if (null != systemID) {
                sbuffer.append(""; SystemID: "");
                sbuffer.append(systemID);
            }

            if (0 != line) {
                sbuffer.append(""; Line#: "");
                sbuffer.append(line);
            }

            if (0 != column) {
                sbuffer.append(""; Column#: "");
                sbuffer.append(column);
            }

            return sbuffer.toString();
        } else {
            return null;
        }
    }

    
    public void printStackTrace() {
        printStackTrace(new java.io.PrintWriter(System.err, true));
    }

    
    public void printStackTrace(java.io.PrintStream s) {
        printStackTrace(new java.io.PrintWriter(s));
    }

    
    public void printStackTrace(java.io.PrintWriter s) {

        if (s == null) {
            s = new java.io.PrintWriter(System.err, true);
        }

        try {
            String locInfo = getLocationAsString();

            if (null != locInfo) {
                s.println(locInfo);
            }

            super.printStackTrace(s);
        } catch (Throwable e) {}

        Throwable exception = getException();

        for (int i = 0; (i < 10) && (null != exception); i++) {
            s.println(""---------"");

            try {
                if (exception instanceof DTMException) {
                    String locInfo =
                        ((DTMException) exception)
                            .getLocationAsString();

                    if (null != locInfo) {
                        s.println(locInfo);
                    }
                }

                exception.printStackTrace(s);
            } catch (Throwable e) {
                s.println(""Could not print stack trace..."");
            }

            try {
                Method meth =
                    ((Object) exception).getClass().getMethod(""getException"",
                        null);

                if (null != meth) {
                    Throwable prev = exception;

                    exception = (Throwable) meth.invoke(exception, null);

                    if (prev == exception) {
                        break;
                    }
                } else {
                    exception = null;
                }
            } catch (InvocationTargetException ite) {
                exception = null;
            } catch (IllegalAccessException iae) {
                exception = null;
            } catch (NoSuchMethodException nsme) {
                exception = null;
            }
        }
    }
}"
org.apache.xalan.extensions.ExtensionsTable,6,1,0,8,21,0,2,6,6,0.5,146,0.5,1,0.0,0.380952381,0,0,23.0,1,0.8333,1,"
package org.apache.xalan.extensions;

import java.util.Hashtable;
import java.util.Vector;
import org.apache.xml.utils.StringVector;

import org.apache.xpath.objects.XNull;
import org.apache.xpath.XPathProcessorException;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import org.apache.xalan.transformer.TransformerImpl;

import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.TemplateList;

import org.apache.xpath.XPathContext;

import org.apache.xml.utils.QName;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public class ExtensionsTable
{  
  
  public Hashtable m_extensionFunctionNamespaces = new Hashtable();
  
  
  private StylesheetRoot m_sroot;
  
  
  public ExtensionsTable(StylesheetRoot sroot)
    throws javax.xml.transform.TransformerException
  {
    m_sroot = sroot;
    Vector extensions = m_sroot.getExtensions();
    for (int i = 0; i < extensions.size(); i++)
    {
      ExtensionNamespaceSupport extNamespaceSpt = 
                 (ExtensionNamespaceSupport)extensions.elementAt(i);
      ExtensionHandler extHandler = extNamespaceSpt.launch();
        if (extHandler != null)
          addExtensionNamespace(extNamespaceSpt.getNamespace(), extHandler);
      }
    }
       
  
  public ExtensionHandler get(String extns)
  {
    return (ExtensionHandler) m_extensionFunctionNamespaces.get(extns);
  }

  
  public void addExtensionNamespace(String uri, ExtensionHandler extNS)
  {
    m_extensionFunctionNamespaces.put(uri, extNS);
  }

  
  public boolean functionAvailable(String ns, String funcName)
          throws javax.xml.transform.TransformerException
  {
    boolean isAvailable = false;
    
    if (null != ns)
    {
      ExtensionHandler extNS = 
           (ExtensionHandler) m_extensionFunctionNamespaces.get(ns);
      if (extNS != null)
        isAvailable = extNS.isFunctionAvailable(funcName);
    }
    return isAvailable;
  }
  
  
  public boolean elementAvailable(String ns, String elemName)
          throws javax.xml.transform.TransformerException
  {
    boolean isAvailable = false;
    if (null != ns)
    {
      ExtensionHandler extNS = 
               (ExtensionHandler) m_extensionFunctionNamespaces.get(ns);
      if (extNS != null) 
        isAvailable = extNS.isElementAvailable(elemName);
    } 
    return isAvailable;        
  }  
  
  
  public Object extFunction(String ns, String funcName, 
                            Vector argVec, Object methodKey, 
                            ExpressionContext exprContext)
            throws javax.xml.transform.TransformerException
  {
    Object result = null;
    if (null != ns)
    {
      ExtensionHandler extNS =
        (ExtensionHandler) m_extensionFunctionNamespaces.get(ns);
      if (null != extNS)
      {
        try
        {
          result = extNS.callFunction(funcName, argVec, methodKey,
                                      exprContext);
        }
        catch (javax.xml.transform.TransformerException e)
        {
          throw e;
        }
        catch (Exception e)
        {
          throw new javax.xml.transform.TransformerException(e);
        }
      }
      else
      {
        throw new XPathProcessorException(XSLMessages.createMessage(XSLTErrorResources.ER_EXTENSION_FUNC_UNKNOWN, new Object[]{ns, funcName })); 
        
      }
    }
    return result;    
  }
}
"
org.apache.xml.utils.StringToStringTable,11,1,0,1,15,0,1,0,11,0.45,286,1.0,0,0.0,0.606060606,0,0,24.63636364,4,2.1818,0,"
package org.apache.xml.utils;


public class StringToStringTable
{

  
  private int m_blocksize;

  
  private String m_map[];

  
  private int m_firstFree = 0;

  
  private int m_mapSize;

  
  public StringToStringTable()
  {

    m_blocksize = 16;
    m_mapSize = m_blocksize;
    m_map = new String[m_blocksize];
  }

  
  public StringToStringTable(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new String[blocksize];
  }

  
  public final int getLength()
  {
    return m_firstFree;
  }

  
  public final void put(String key, String value)
  {

    if ((m_firstFree + 2) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      String newMap[] = new String[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = key;

    m_firstFree++;

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final String get(String key)
  {

    for (int i = 0; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(key))
        return m_map[i + 1];
    }

    return null;
  }

  
  public final void remove(String key)
  {

    for (int i = 0; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(key))
      {
        if ((i + 2) < m_firstFree)
          System.arraycopy(m_map, i + 2, m_map, i, m_firstFree - (i + 2));

        m_firstFree -= 2;
        m_map[m_firstFree] = null;
        m_map[m_firstFree + 1] = null;

        break;
      }
    }
  }

  
  public final String getIgnoreCase(String key)
  {

    if (null == key)
      return null;

    for (int i = 0; i < m_firstFree; i += 2)
    {
      if (m_map[i].equalsIgnoreCase(key))
        return m_map[i + 1];
    }

    return null;
  }

  
  public final String getByValue(String val)
  {

    for (int i = 1; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(val))
        return m_map[i - 1];
    }

    return null;
  }

  
  public final String elementAt(int i)
  {
    return m_map[i];
  }

  
  public final boolean contains(String key)
  {

    for (int i = 0; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(key))
        return true;
    }

    return false;
  }

  
  public final boolean containsValue(String val)
  {

    for (int i = 1; i < m_firstFree; i += 2)
    {
      if (m_map[i].equals(val))
        return true;
    }

    return false;
  }
}
"
org.apache.xalan.xsltc.compiler.UnparsedEntityUriCall,3,4,0,17,14,0,0,17,3,0.0,62,1.0,1,0.979591837,0.444444444,3,13,19.33333333,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class UnparsedEntityUriCall extends FunctionCall {
    private Expression _entity;

    public UnparsedEntityUriCall(QName fname, Vector arguments) {
	super(fname, arguments);
	_entity = argument();
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type entity = _entity.typeCheck(stable);
	if (entity instanceof StringType == false) {
	    _entity = new CastExpr(_entity, Type.String);
	}
	return _type = Type.String;
    }
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	
	il.append(classGen.loadTranslet());
	
	_entity.translate(classGen, methodGen);
	
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
						     ""getUnparsedEntity"",
						     ""(Ljava/lang/String;)""+
						     ""Ljava/lang/String;"")));
    }
}
"
org.apache.xalan.xsltc.runtime.output.SAXTextOutput,11,3,0,3,19,55,1,2,11,2.0,79,0.0,0,0.804347826,0.363636364,0,0,6.181818182,1,0.8182,0,"

package org.apache.xalan.xsltc.runtime.output;

import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.SAXException;

import org.apache.xalan.xsltc.TransletException;

public class SAXTextOutput extends SAXOutput {

    public SAXTextOutput(ContentHandler handler, String encoding) 
    {
    	super(handler, encoding);
    }

    public SAXTextOutput(ContentHandler handler, LexicalHandler lex, 
        String encoding)
    {
        super(handler, lex, encoding);
    }

    public void startDocument() throws TransletException { 
	try {
	    _saxHandler.startDocument();
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }

    public void endDocument() throws TransletException { 
	try {
	    _saxHandler.endDocument();
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }

    public void startElement(String elementName) 
	throws TransletException 
    {
    }

    public void endElement(String elementName) 
	throws TransletException 
    {
    }

    public void characters(String characters) 
	throws TransletException 
    { 
	try {
	    _saxHandler.characters(characters.toCharArray(), 0, 
		characters.length());
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }

    public void characters(char[] characters, int offset, int length)
	throws TransletException 
    { 
	try {
	    _saxHandler.characters(characters, offset, length);
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }

    public void comment(String comment) throws TransletException {
    }

    public void attribute(String name, String value) 
	throws TransletException 
    {
    }

    public void processingInstruction(String target, String data) 
	throws TransletException
    {
    }
}

"
org.apache.xalan.xsltc.compiler.Copy,5,3,0,31,42,4,0,31,4,0.5,253,1.0,1,0.933333333,0.333333333,1,6,49.4,4,1.6,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import java.util.StringTokenizer;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class Copy extends Instruction {
    private UseAttributeSets _useSets;
    
    public void parseContents(Parser parser) {
	final String useSets = getAttribute(""use-attribute-sets"");
	if (useSets.length() > 0) {
	    _useSets = new UseAttributeSets(useSets, parser);
	}
	parseChildren(parser);
    }
    
    public void display(int indent) {
	indent(indent);
	Util.println(""Copy"");
	indent(indent + IndentIncrement);
	displayContents(indent + IndentIncrement);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_useSets != null) {
	    _useSets.typeCheck(stable);
	}
	typeCheckContents(stable);
	return Type.Void;
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final LocalVariableGen name =
	    methodGen.addLocalVariable2(""name"",
					Util.getJCRefType(STRING_SIG),
					il.getEnd());
	final LocalVariableGen length =
	    methodGen.addLocalVariable2(""length"",
					Util.getJCRefType(""I""),
					il.getEnd());

	
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadHandler());
	final int cpy = cpg.addInterfaceMethodref(DOM_INTF,
						  ""shallowCopy"",
						  ""(""
						  + NODE_SIG
						  + TRANSLET_OUTPUT_SIG
						  + "")"" + STRING_SIG); 
	il.append(new INVOKEINTERFACE(cpy, 3));
	il.append(DUP);
	il.append(new ASTORE(name.getIndex()));
	final BranchHandle ifBlock1 = il.append(new IFNULL(null));

	
	il.append(new ALOAD(name.getIndex()));
	final int lengthMethod = cpg.addMethodref(STRING_CLASS,""length"",""()I"");
	il.append(new INVOKEVIRTUAL(lengthMethod));
	il.append(new ISTORE(length.getIndex()));

	
	if (_useSets != null) {
	    
	    
	    final SyntaxTreeNode parent = getParent();
	    if ((parent instanceof LiteralElement) ||
		(parent instanceof LiteralElement)) {
		_useSets.translate(classGen, methodGen);
	    }
	    
	    
	    else {
		
		il.append(new ILOAD(length.getIndex()));
		final BranchHandle ifBlock2 = il.append(new IFEQ(null));
		
		_useSets.translate(classGen, methodGen);
		
		ifBlock2.setTarget(il.append(NOP));
	    }
	}

	
	translateContents(classGen, methodGen);

	
	
	il.append(new ILOAD(length.getIndex()));
	final BranchHandle ifBlock3 = il.append(new IFEQ(null));
	il.append(methodGen.loadHandler());
	il.append(new ALOAD(name.getIndex()));
	il.append(methodGen.endElement());
	
	final InstructionHandle end = il.append(NOP);
	ifBlock1.setTarget(end);
	ifBlock3.setTarget(end);
	methodGen.removeLocalVariable(name);
	methodGen.removeLocalVariable(length);
    }
}
"
org.apache.xalan.xsltc.compiler.util.RtMethodGenerator,5,5,0,7,8,6,0,7,5,0.916666667,41,1.0,0,0.971830986,0.325,1,2,6.6,1,0.8,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Vector;
import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.Template;


public final class RtMethodGenerator extends MethodGenerator {
    private static final int HANDLER_INDEX = 2;
    private final Instruction _astoreHandler;
    private final Instruction _aloadHandler;

    public RtMethodGenerator(int access_flags, Type return_type,
			     Type[] arg_types, String[] arg_names,
			     String method_name, String class_name,
			     InstructionList il, ConstantPoolGen cp) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cp);
	
	_astoreHandler = new ASTORE(HANDLER_INDEX);
	_aloadHandler  = new ALOAD(HANDLER_INDEX);
    }

    public int getIteratorIndex() {
	return INVALID_INDEX;		
    }
    
    public final Instruction storeHandler() {
	return _astoreHandler;
    }

    public final Instruction loadHandler() {
	return _aloadHandler;
    }

    public int getLocalIndex(String name) {
	return INVALID_INDEX;		
    }
}
"
org.apache.xalan.xsltc.dom.StripWhitespaceFilter,1,1,0,1,1,0,0,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;

public interface StripWhitespaceFilter {
    public boolean stripSpace(DOM dom, int node, int type);
}
"
org.apache.xalan.xsltc.compiler.UnaryOpExpr,6,3,0,14,28,0,0,14,6,0.0,101,1.0,1,0.934210526,0.305555556,2,8,15.66666667,1,0.8333,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class UnaryOpExpr extends Expression {
    private Expression _left;
	
    public UnaryOpExpr(Expression left) {
	(_left = left).setParent(this);
    }

    
    public boolean hasPositionCall() {
	return(_left.hasPositionCall());
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tleft = _left.typeCheck(stable); 
	final MethodType ptype = lookupPrimop(stable, ""u-"",
					      new MethodType(Type.Void,
							     tleft)); 
	
	if (ptype != null) {
	    final Type arg1 = (Type) ptype.argsType().elementAt(0);
	    if (!arg1.identicalTo(tleft)) {
		_left = new CastExpr(_left, arg1);
	    }
	    return _type = ptype.resultType();
	}

	throw new TypeCheckError(this);
    }

    public String toString() {
	return ""u-"" + '(' + _left + ')';
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	InstructionList il = methodGen.getInstructionList();
	_left.translate(classGen, methodGen);
	il.append(_type.NEG());
    }
}

"
org.apache.xalan.xsltc.compiler.DecimalFormatting,5,3,0,23,30,4,2,22,4,1.0,496,1.0,1,0.9375,0.4,3,6,97.6,17,4.4,0,"

package org.apache.xalan.xsltc.compiler;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;

import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;

import org.apache.xalan.xsltc.runtime.AttributeList;
import org.apache.xalan.xsltc.compiler.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class DecimalFormatting extends TopLevelElement {

    private static final String DFS_CLASS = ""java.text.DecimalFormatSymbols"";
    private static final String DFS_SIG   = ""Ljava/text/DecimalFormatSymbols;"";

    private QName _name = null;

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }

    
    public void parseContents(Parser parser) {
	
	_name = parser.getQNameIgnoreDefaultNs(getAttribute(""name""));
	if (_name == null) {
	    _name = parser.getQNameIgnoreDefaultNs(EMPTYSTRING);
	}

	
	SymbolTable stable = parser.getSymbolTable();
	if (stable.getDecimalFormatting(_name) != null) {
	    reportWarning(this, parser, ErrorMsg.SYMBOLS_REDEF_ERR,
		_name.toString());
	}
	else {
	    stable.addDecimalFormatting(_name, this);
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	
	
	final int init = cpg.addMethodref(DFS_CLASS, ""<init>"", ""()V"");

	
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, _name.toString()));

	
	
	il.append(new NEW(cpg.addClass(DFS_CLASS)));
	il.append(DUP);
	il.append(new INVOKESPECIAL(init));

	String tmp = getAttribute(""NaN"");
	if ((tmp == null) || (tmp.equals(EMPTYSTRING))) {
	    int nan = cpg.addMethodref(DFS_CLASS,
				       ""setNaN"", ""(Ljava/lang/String;)V"");
	    il.append(DUP);
	    il.append(new PUSH(cpg, ""NaN""));
	    il.append(new INVOKEVIRTUAL(nan));
	}

	tmp = getAttribute(""infinity"");
	if ((tmp == null) || (tmp.equals(EMPTYSTRING))) {
	    int inf = cpg.addMethodref(DFS_CLASS,
				       ""setInfinity"",
				       ""(Ljava/lang/String;)V"");
	    il.append(DUP);
	    il.append(new PUSH(cpg, ""Infinity""));
	    il.append(new INVOKEVIRTUAL(inf));
	}
	    
	final int nAttributes = _attributes.getLength();
	for (int i = 0; i < nAttributes; i++) {
	    final String name = _attributes.getQName(i);
	    final String value = _attributes.getValue(i);

	    boolean valid = true;
	    int method = 0;

	    if (name.equals(""decimal-separator"")) {
		
		method = cpg.addMethodref(DFS_CLASS,
					  ""setDecimalSeparator"", ""(C)V"");
	    }
	    else if (name.equals(""grouping-separator"")) {
		method =  cpg.addMethodref(DFS_CLASS,
					   ""setGroupingSeparator"", ""(C)V"");
	    }
	    else if (name.equals(""minus-sign"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setMinusSign"", ""(C)V"");
	    }
	    else if (name.equals(""percent"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setPercent"", ""(C)V"");
	    }
	    else if (name.equals(""per-mille"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setPerMill"", ""(C)V"");
	    }
	    else if (name.equals(""zero-digit"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setZeroDigit"", ""(C)V"");
	    }
	    else if (name.equals(""digit"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setDigit"", ""(C)V"");
	    }
	    else if (name.equals(""pattern-separator"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setPatternSeparator"", ""(C)V"");
	    }
	    else if (name.equals(""NaN"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setNaN"", ""(Ljava/lang/String;)V"");
	        il.append(DUP);
		il.append(new PUSH(cpg, value));
		il.append(new INVOKEVIRTUAL(method));
		valid = false;
	    }
	    else if (name.equals(""infinity"")) {
		method = cpg.addMethodref(DFS_CLASS,
					  ""setInfinity"",
					  ""(Ljava/lang/String;)V"");
	        il.append(DUP);
		il.append(new PUSH(cpg, value));
		il.append(new INVOKEVIRTUAL(method));
		valid = false;
	    }
	    else {
		valid = false;
	    }

	    if (valid) {
		il.append(DUP);
		il.append(new PUSH(cpg, value.charAt(0)));
		il.append(new INVOKEVIRTUAL(method));
	    }

	}

	final int put = cpg.addMethodref(TRANSLET_CLASS,
					 ""addDecimalFormat"",
					 ""(""+STRING_SIG+DFS_SIG+"")V"");
	il.append(new INVOKEVIRTUAL(put));
    }

    
    public static void translateDefaultDFS(ClassGenerator classGen,
					   MethodGenerator methodGen) {

	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();
	final int init = cpg.addMethodref(DFS_CLASS, ""<init>"", ""()V"");

	
	
	il.append(classGen.loadTranslet());
	il.append(new PUSH(cpg, EMPTYSTRING));

	
	
	il.append(new NEW(cpg.addClass(DFS_CLASS)));
	il.append(DUP);
	il.append(new INVOKESPECIAL(init));

	int nan = cpg.addMethodref(DFS_CLASS,
				   ""setNaN"", ""(Ljava/lang/String;)V"");
	il.append(DUP);
	il.append(new PUSH(cpg, ""NaN""));
	il.append(new INVOKEVIRTUAL(nan));

	int inf = cpg.addMethodref(DFS_CLASS,
				   ""setInfinity"",
				   ""(Ljava/lang/String;)V"");
	il.append(DUP);
	il.append(new PUSH(cpg, ""Infinity""));
	il.append(new INVOKEVIRTUAL(inf));

	final int put = cpg.addMethodref(TRANSLET_CLASS,
					 ""addDecimalFormat"",
					 ""(""+STRING_SIG+DFS_SIG+"")V"");
	il.append(new INVOKEVIRTUAL(put));
    }
}
"
org.apache.xalan.xsltc.dom.AbsoluteIterator,8,2,0,3,21,0,1,3,8,0.428571429,105,0.5,1,0.588235294,0.34375,1,5,11.875,3,1.125,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public final class AbsoluteIterator extends NodeIteratorBase {
    private NodeIterator _source;
	
    public AbsoluteIterator(NodeIterator source) {
	_source = source;
    }

    public int next() {
	return returnNode(_source.next());
    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }
	
    int _mask = -1;

    public NodeIterator setStartNode(int node) {
	if (_mask == -1) {
            _mask = node & 0xFF000000;
        }
	_startNode = _mask | DOM.ROOTNODE;
	if (_isRestartable) {
	    resetPosition();
	    return _source.setStartNode(_startNode = _mask | DOM.ROOTNODE);
	}
	return reset();
    }

    public NodeIterator cloneIterator() {
	try {
	    final AbsoluteIterator clone = (AbsoluteIterator)super.clone();
	    clone.setRestartable(false);
	    clone._source = _source.cloneIterator();
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }

    public NodeIterator reset() {
	_source.reset();
	return resetPosition();
    }
    
    public void setMark() {
	_source.setMark();
    }

    public void gotoMark() {
	_source.gotoMark();
    }
}
"
org.apache.xalan.xsltc.compiler.NamespaceUriCall,3,5,0,11,11,3,0,11,3,2.0,37,0.0,0,0.99,0.533333333,3,5,11.33333333,1,0.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class NamespaceUriCall extends NameBase {

    
    public NamespaceUriCall(QName fname) {
	super(fname);
    }

    
    public NamespaceUriCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getNamespace = cpg.addInterfaceMethodref(DOM_INTF,
							   ""getNamespaceName"",
							   ""(I)""+STRING_SIG);
	super.translate(classGen, methodGen);
	il.append(new INVOKEINTERFACE(getNamespace, 2));
    }
}
"
org.apache.xalan.templates.ElemElement,13,4,1,15,50,30,2,13,9,0.583333333,388,1.0,2,0.943925234,0.230769231,2,6,28.69230769,8,1.6923,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultTreeHandler;

import javax.xml.transform.TransformerException;


public class ElemElement extends ElemUse
{

  
  protected AVT m_name_avt = null;

  
  public void setName(AVT v)
  {
    m_name_avt = v;
  }

  
  public AVT getName()
  {
    return m_name_avt;
  }

  
  protected AVT m_namespace_avt = null;

  
  public void setNamespace(AVT v)
  {
    m_namespace_avt = v;
  }

  
  public AVT getNamespace()
  {
    return m_namespace_avt;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_name_avt)
      m_name_avt.fixupVariables(vnames, cstate.getGlobalsSize());
    if(null != m_namespace_avt)
      m_namespace_avt.fixupVariables(vnames, cstate.getGlobalsSize());
  }


  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_ELEMENT;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_ELEMENT_STRING;
  }
  
  
   protected boolean validateNodeName(String nodeName)
   {
    if(nodeName == null)
      return false;

    int len = nodeName.length();
    
    if(len == 0)
      return false;
      
    int indexOfNSSep = nodeName.indexOf(':');

    if(indexOfNSSep + 1 == len)
      return false;
      
    if(indexOfNSSep == 0)
      return false;
      
    String localName = QName.getLocalPart(nodeName);
      
    if(isValidNCName(localName))
    {
      String prefix = QName.getPrefixPart(nodeName);
      if(prefix.length() == 0)
        return true;
      if(isValidNCName(prefix))
        return true;
    }

    return false;
   }
   
  
  protected String resolvePrefix(ResultTreeHandler rhandler,
                                 String prefix, String nodeNamespace)
    throws TransformerException
  {









    return prefix;
  }
    
  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
      
 	ResultTreeHandler rhandler = transformer.getResultTreeHandler();
    XPathContext xctxt = transformer.getXPathContext();
    int sourceNode = xctxt.getCurrentNode();
    
    
    String nodeName = m_name_avt == null ? null : m_name_avt.evaluate(xctxt, sourceNode, this);

    String prefix = null;
    String nodeNamespace = """";

    
    if ((nodeName != null) && (!m_name_avt.isSimple()) && (!validateNodeName(nodeName)))
    {
      transformer.getMsgMgr().warn(
        this, XSLTErrorResources.WG_ILLEGAL_ATTRIBUTE_VALUE,
        new Object[]{ Constants.ATTRNAME_NAME, nodeName });

      nodeName = null;
    }

    else if (nodeName != null)
    {
      prefix = QName.getPrefixPart(nodeName);

      if (null != m_namespace_avt)
      {
        nodeNamespace = m_namespace_avt.evaluate(xctxt, sourceNode, this);
        if (null == nodeNamespace || 
            (prefix != null && prefix.length()>0 && nodeNamespace.length()== 0) )
          transformer.getMsgMgr().error(
              this, XSLTErrorResources.ER_NULL_URI_NAMESPACE);
        else
        {
        

        prefix = resolvePrefix(rhandler, prefix, nodeNamespace);
        if (null == prefix)
          prefix = """";

        if (prefix.length() > 0)
          nodeName = (prefix + "":"" + QName.getLocalPart(nodeName));
        else
          nodeName = QName.getLocalPart(nodeName);
        }
      }

      
      
      else    
      {
        try
        {
          
          nodeNamespace = getNamespaceForPrefix(prefix);

          
          
          

          if ( (null == nodeNamespace) && (prefix.length() == 0) )
            nodeNamespace = """";
          else if (null == nodeNamespace)
          {
            transformer.getMsgMgr().warn(
              this, XSLTErrorResources.WG_COULD_NOT_RESOLVE_PREFIX,
              new Object[]{ prefix });

            nodeName = null;
          }

        }
        catch (Exception ex)
        {
          transformer.getMsgMgr().warn(
            this, XSLTErrorResources.WG_COULD_NOT_RESOLVE_PREFIX,
            new Object[]{ prefix });

          nodeName = null;
        }
      }
    }

    constructNode(nodeName, prefix, nodeNamespace, transformer);

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
  }
  
  
  void constructNode(
          String nodeName, String prefix, String nodeNamespace, TransformerImpl transformer)
            throws TransformerException
  {

    boolean shouldAddAttrs;

    try
    {
      ResultTreeHandler rhandler = transformer.getResultTreeHandler();

      if (null == nodeName)
      {
        shouldAddAttrs = false;
      }
      else
      {
        
        executeNSDecls(transformer);

        if (null != prefix)
        {
          rhandler.startPrefixMapping(prefix, nodeNamespace, true);
        }

        rhandler.startElement(nodeNamespace, QName.getLocalPart(nodeName),
                              nodeName, null);

        super.execute(transformer);

        shouldAddAttrs = true;
      }

      transformer.executeChildTemplates(this, shouldAddAttrs);

      
      if (null != nodeName)
      {
        rhandler.endElement(nodeNamespace, QName.getLocalPart(nodeName),
                            nodeName);
        if (null != prefix)
        {
          rhandler.endPrefixMapping(prefix);
        }
        unexecuteNSDecls(transformer);
      }
    }
    catch (SAXException se)
    {
      throw new TransformerException(se);
    }
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs)
  	{
  	  if(null != m_name_avt)
  		m_name_avt.callVisitors(visitor);
  		
  	  if(null != m_namespace_avt)
  		m_namespace_avt.callVisitors(visitor);
  	}
  		
    super.callChildVisitors(visitor, callAttrs);
  }

}
"
org.apache.xpath.functions.FuncString,2,5,0,5,4,1,0,5,2,2.0,10,0.0,0,0.982142857,0.75,2,7,4.0,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XNodeSet;


public class FuncString extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return (XString)getArg0AsString(xctxt);
  }
}
"
org.apache.xalan.transformer.SerializerSwitcher,4,1,0,6,23,6,2,4,3,2.0,157,0.0,0,0.0,0.4,0,0,38.25,1,0.75,0,"
package org.apache.xalan.transformer;

import java.io.Writer;
import java.io.OutputStream;

import java.util.Properties;

import org.apache.xalan.templates.StylesheetRoot;

import org.xml.sax.ContentHandler;

import javax.xml.transform.TransformerException;
import javax.xml.transform.OutputKeys;

import org.apache.xalan.serialize.Serializer;
import org.apache.xalan.serialize.SerializerFactory;
import org.apache.xalan.serialize.Method;
import org.apache.xalan.templates.OutputProperties;


public class SerializerSwitcher
{

  
  public static void switchSerializerIfHTML(
          TransformerImpl transformer, String ns, String localName)
            throws TransformerException
  {

    if (null == transformer)
      return;

    if (((null == ns) || (ns.length() == 0))
            && localName.equalsIgnoreCase(""html""))
    {
      
      
      
      if (null != transformer.getOutputPropertyNoDefault(OutputKeys.METHOD))
        return;

      
      
      Properties prevProperties = transformer.getOutputFormat().getProperties();
      
      
      
      
      OutputProperties htmlOutputProperties = new OutputProperties(Method.HTML);

      htmlOutputProperties.copyFrom(prevProperties, true);
      Properties htmlProperties = htmlOutputProperties.getProperties();

      try
      {
        Serializer oldSerializer = transformer.getSerializer();

        if (null != oldSerializer)
        {
          Serializer serializer =
            SerializerFactory.getSerializer(htmlProperties);

          Writer writer = oldSerializer.getWriter();

          if (null != writer)
            serializer.setWriter(writer);
          else
          {
            OutputStream os = oldSerializer.getOutputStream();

            if (null != os)
              serializer.setOutputStream(os);
          }

          transformer.setSerializer(serializer);

          ContentHandler ch = serializer.asContentHandler();

          transformer.setContentHandler(ch);
        }
      }
      catch (java.io.IOException e)
      {
        throw new TransformerException(e);
      }
    }
  }
  
  
  private static String getOutputPropertyNoDefault(String qnameString, Properties props)
    throws IllegalArgumentException
  {    
    String value = (String)props.get(qnameString);
    
    return value;
  }
  
  
  public static Serializer switchSerializerIfHTML(
          String ns, String localName, Properties props, Serializer oldSerializer)
            throws TransformerException
  {
    Serializer newSerializer = oldSerializer;

    if (((null == ns) || (ns.length() == 0))
            && localName.equalsIgnoreCase(""html""))
    {
      
      
      
      if (null != getOutputPropertyNoDefault(OutputKeys.METHOD, props))
        return newSerializer;

      
      
      Properties prevProperties = props;
      
      
      
      
      OutputProperties htmlOutputProperties = new OutputProperties(Method.HTML);

      htmlOutputProperties.copyFrom(prevProperties, true);
      Properties htmlProperties = htmlOutputProperties.getProperties();


      {
        if (null != oldSerializer)
        {
          Serializer serializer =
            SerializerFactory.getSerializer(htmlProperties);

          Writer writer = oldSerializer.getWriter();

          if (null != writer)
            serializer.setWriter(writer);
          else
          {
            OutputStream os = serializer.getOutputStream();

            if (null != os)
              serializer.setOutputStream(os);
          }
          newSerializer = serializer;
        }
      }




    }
    return newSerializer;
  }
  
}
"
org.apache.xalan.lib.sql.ObjectArray,7,1,0,3,19,0,3,1,6,0.25,432,1.0,1,0.0,0.464285714,0,0,60.14285714,3,1.4286,0,"package org.apache.xalan.lib.sql;

import java.util.Vector;


public class ObjectArray
{
  
  private int m_minArraySize = 10;
  
  private Vector m_Arrays = new Vector(200);

  
  private _ObjectArray m_currentArray;


  
  private int m_nextSlot;


  
  public ObjectArray( )
  {
    
    
    
    init(10);
  }

  
  public ObjectArray( final int minArraySize )
  {
    init(minArraySize);
  }

  
  private void init( int size )
  {
    m_minArraySize = size;
    m_currentArray = new _ObjectArray(m_minArraySize);
  }

  
  public Object getAt( final int idx )
  {
    int arrayIndx = idx / m_minArraySize;
    int arrayOffset = idx - (arrayIndx * m_minArraySize);

    
    
    
    if (arrayIndx < m_Arrays.size())
    {
      _ObjectArray a = (_ObjectArray)m_Arrays.elementAt(arrayIndx);
      return a.objects[arrayOffset];
    }
    else
    {
      

      
      
      
      return m_currentArray.objects[arrayOffset];
    }
  }

  
  public void setAt( final int idx, final Object obj )
  {
    int arrayIndx = idx / m_minArraySize;
    int arrayOffset = idx - (arrayIndx * m_minArraySize);

    
    
    
    if (arrayIndx < m_Arrays.size())
    {
      _ObjectArray a = (_ObjectArray)m_Arrays.elementAt(arrayIndx);
      a.objects[arrayOffset] = obj;
    }
    else
    {
      

      
      
      
      m_currentArray.objects[arrayOffset] = obj;
    }
  }



  
  public int append( Object o )
  {
    if (m_nextSlot >= m_minArraySize)
    {
      m_Arrays.addElement(m_currentArray);
      m_nextSlot = 0;
      m_currentArray = new _ObjectArray(m_minArraySize);
    }

    m_currentArray.objects[m_nextSlot] = o;

    int pos = (m_Arrays.size() * m_minArraySize) + m_nextSlot;

    m_nextSlot++;

    return pos;
  }


  
  class _ObjectArray
  {
    
    public Object[] objects;
    
    public _ObjectArray( int size )
    {
      objects = new Object[size];
    }
  }

  
  public static void main( String[] args )
  {
    String[] word={
      ""Zero"",""One"",""Two"",""Three"",""Four"",""Five"",
      ""Six"",""Seven"",""Eight"",""Nine"",""Ten"",
      ""Eleven"",""Twelve"",""Thirteen"",""Fourteen"",""Fifteen"",
      ""Sixteen"",""Seventeen"",""Eighteen"",""Nineteen"",""Twenty"",
      ""Twenty-One"",""Twenty-Two"",""Twenty-Three"",""Twenty-Four"",
      ""Twenty-Five"",""Twenty-Six"",""Twenty-Seven"",""Twenty-Eight"",
      ""Twenty-Nine"",""Thirty"",""Thirty-One"",""Thirty-Two"",
      ""Thirty-Three"",""Thirty-Four"",""Thirty-Five"",""Thirty-Six"",
      ""Thirty-Seven"",""Thirty-Eight"",""Thirty-Nine""};

    ObjectArray m_ObjectArray = new ObjectArray();
    
    for (int x =0; x< word.length; x++)
    {
      System.out.print("" - "" + m_ObjectArray.append(word[x]));
    }

    System.out.println(""
"");
    
    for (int x =0; x< word.length; x++)
    {
      String s = (String) m_ObjectArray.getAt(x);
      System.out.println(s);
    }

    
    System.out.println((String) m_ObjectArray.getAt(5));
    System.out.println((String) m_ObjectArray.getAt(10));
    System.out.println((String) m_ObjectArray.getAt(20));
    System.out.println((String) m_ObjectArray.getAt(2));
    System.out.println((String) m_ObjectArray.getAt(15));
    System.out.println((String) m_ObjectArray.getAt(30));
    System.out.println((String) m_ObjectArray.getAt(6));
    System.out.println((String) m_ObjectArray.getAt(8));

    
    System.out.println((String) m_ObjectArray.getAt(40));

  }
}
"
org.apache.xalan.serialize.SerializerToHTML,22,2,0,10,80,173,2,8,15,0.857142857,2190,0.875,4,0.775280899,0.232804233,2,30,98.18181818,3,1.1364,0,"
package org.apache.xalan.serialize;

import java.util.Stack;

import java.io.Writer;
import java.io.IOException;

import java.util.Hashtable;
import java.util.Vector;
import java.util.Properties;
import java.util.BitSet;

import org.xml.sax.*;

import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.Trie;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xml.utils.StringToIntTable;
import org.apache.xalan.templates.OutputProperties;

import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;


public class SerializerToHTML extends SerializerToXML
{

  
  protected BoolStack m_isRawStack = new BoolStack();

  
  private boolean m_inBlockElem = false;

  
  protected static CharInfo m_htmlcharInfo =
    new CharInfo(CharInfo.HTML_ENTITIES_RESOURCE);

  
  static Trie m_elementFlags = new Trie();

  static
  {

    
    m_elementFlags.put(""BASEFONT"", new ElemDesc(0 | ElemDesc.EMPTY));
    m_elementFlags.put(""FRAME"",
                       new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
    m_elementFlags.put(""FRAMESET"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""NOFRAMES"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""ISINDEX"",
                       new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
    m_elementFlags.put(""APPLET"",
                       new ElemDesc(0 | ElemDesc.WHITESPACESENSITIVE));
    m_elementFlags.put(""CENTER"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""DIR"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""MENU"", new ElemDesc(0 | ElemDesc.BLOCK));

    
    m_elementFlags.put(""TT"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
    m_elementFlags.put(""I"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
    m_elementFlags.put(""B"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
    m_elementFlags.put(""BIG"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
    m_elementFlags.put(""SMALL"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
    m_elementFlags.put(""EM"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""STRONG"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""DFN"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""CODE"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""SAMP"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""KBD"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""VAR"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""CITE"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""ABBR"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""ACRONYM"", new ElemDesc(0 | ElemDesc.PHRASE));
    m_elementFlags.put(""SUP"",
                       new ElemDesc(0 | ElemDesc.SPECIAL
                                    | ElemDesc.ASPECIAL));
    m_elementFlags.put(""SUB"",
                       new ElemDesc(0 | ElemDesc.SPECIAL
                                    | ElemDesc.ASPECIAL));
    m_elementFlags.put(""SPAN"",
                       new ElemDesc(0 | ElemDesc.SPECIAL
                                    | ElemDesc.ASPECIAL));
    m_elementFlags.put(""BDO"",
                       new ElemDesc(0 | ElemDesc.SPECIAL
                                    | ElemDesc.ASPECIAL));
    m_elementFlags.put(""BR"",
                       new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL
                                    | ElemDesc.EMPTY | ElemDesc.BLOCK));
    m_elementFlags.put(""BODY"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""ADDRESS"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                    | ElemDesc.BLOCKFORMFIELDSET));
    m_elementFlags.put(""DIV"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                    | ElemDesc.BLOCKFORMFIELDSET));
    m_elementFlags.put(""A"", new ElemDesc(0 | ElemDesc.SPECIAL));
    m_elementFlags.put(""MAP"",
                       new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL
                                    | ElemDesc.BLOCK));
    m_elementFlags.put(""AREA"",
                       new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
    m_elementFlags.put(""LINK"",
                       new ElemDesc(0 | ElemDesc.HEADMISC | ElemDesc.EMPTY
                                    | ElemDesc.BLOCK));
    m_elementFlags.put(""IMG"",
                       new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL
                                    | ElemDesc.EMPTY
                                    | ElemDesc.WHITESPACESENSITIVE));
    m_elementFlags.put(""OBJECT"",
                       new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL
                                    | ElemDesc.HEADMISC
                                    | ElemDesc.WHITESPACESENSITIVE));
    m_elementFlags.put(""PARAM"", new ElemDesc(0 | ElemDesc.EMPTY));
    m_elementFlags.put(""HR"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                    | ElemDesc.BLOCKFORMFIELDSET
                                    | ElemDesc.EMPTY));
    m_elementFlags.put(""P"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                    | ElemDesc.BLOCKFORMFIELDSET));
    m_elementFlags.put(""H1"",
                       new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
    m_elementFlags.put(""H2"",
                       new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
    m_elementFlags.put(""H3"",
                       new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
    m_elementFlags.put(""H4"",
                       new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
    m_elementFlags.put(""H5"",
                       new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
    m_elementFlags.put(""H6"",
                       new ElemDesc(0 | ElemDesc.HEAD | ElemDesc.BLOCK));
    m_elementFlags.put(""PRE"",
                       new ElemDesc(0 | ElemDesc.PREFORMATTED
                                    | ElemDesc.BLOCK));
    m_elementFlags.put(""Q"",
                       new ElemDesc(0 | ElemDesc.SPECIAL
                                    | ElemDesc.ASPECIAL));
    m_elementFlags.put(""BLOCKQUOTE"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                    | ElemDesc.BLOCKFORMFIELDSET));
    m_elementFlags.put(""INS"", new ElemDesc(0));
    m_elementFlags.put(""DEL"", new ElemDesc(0));
    m_elementFlags.put(""DL"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                    | ElemDesc.BLOCKFORMFIELDSET));
    m_elementFlags.put(""DT"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""DD"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""OL"",
                       new ElemDesc(0 | ElemDesc.LIST | ElemDesc.BLOCK));
    m_elementFlags.put(""UL"",
                       new ElemDesc(0 | ElemDesc.LIST | ElemDesc.BLOCK));
    m_elementFlags.put(""LI"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""FORM"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""LABEL"", new ElemDesc(0 | ElemDesc.FORMCTRL));
    m_elementFlags.put(""INPUT"",
                       new ElemDesc(0 | ElemDesc.FORMCTRL
                                    | ElemDesc.INLINELABEL | ElemDesc.EMPTY));
    m_elementFlags.put(""SELECT"",
                       new ElemDesc(0 | ElemDesc.FORMCTRL
                                    | ElemDesc.INLINELABEL));
    m_elementFlags.put(""OPTGROUP"", new ElemDesc(0));
    m_elementFlags.put(""OPTION"", new ElemDesc(0));
    m_elementFlags.put(""TEXTAREA"",
                       new ElemDesc(0 | ElemDesc.FORMCTRL
                                    | ElemDesc.INLINELABEL));
    m_elementFlags.put(""FIELDSET"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM));
    m_elementFlags.put(""LEGEND"", new ElemDesc(0));
    m_elementFlags.put(""BUTTON"",
                       new ElemDesc(0 | ElemDesc.FORMCTRL
                                    | ElemDesc.INLINELABEL));
    m_elementFlags.put(""TABLE"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                    | ElemDesc.BLOCKFORMFIELDSET));
    m_elementFlags.put(""CAPTION"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""THEAD"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""TFOOT"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""TBODY"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""COLGROUP"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""COL"",
                       new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
    m_elementFlags.put(""TR"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""TH"", new ElemDesc(0));
    m_elementFlags.put(""TD"", new ElemDesc(0));
    m_elementFlags.put(""HEAD"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.HEADELEM));
    m_elementFlags.put(""TITLE"", new ElemDesc(0 | ElemDesc.BLOCK));
    m_elementFlags.put(""BASE"",
                       new ElemDesc(0 | ElemDesc.EMPTY | ElemDesc.BLOCK));
    m_elementFlags.put(""META"",
                       new ElemDesc(0 | ElemDesc.HEADMISC | ElemDesc.EMPTY
                                    | ElemDesc.BLOCK));
    m_elementFlags.put(""STYLE"",
                       new ElemDesc(0 | ElemDesc.HEADMISC | ElemDesc.RAW
                                    | ElemDesc.BLOCK));
    m_elementFlags.put(""SCRIPT"",
                       new ElemDesc(0 | ElemDesc.SPECIAL | ElemDesc.ASPECIAL
                                    | ElemDesc.HEADMISC | ElemDesc.RAW));
    m_elementFlags.put(""NOSCRIPT"",
                       new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                    | ElemDesc.BLOCKFORMFIELDSET));
    m_elementFlags.put(""HTML"", new ElemDesc(0 | ElemDesc.BLOCK));

    
    
    
    m_elementFlags.put(""FONT"", new ElemDesc(0 | ElemDesc.FONTSTYLE));

    
    m_elementFlags.put(""S"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
    m_elementFlags.put(""STRIKE"", new ElemDesc(0 | ElemDesc.FONTSTYLE));

    
    m_elementFlags.put(""U"", new ElemDesc(0 | ElemDesc.FONTSTYLE));

    
    m_elementFlags.put(""NOBR"", new ElemDesc(0 | ElemDesc.FONTSTYLE));
    
     
     m_elementFlags.put(""IFRAME"",
                                        new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                                                     | ElemDesc.BLOCKFORMFIELDSET));
     
     m_elementFlags.put(""LAYER"",
                                        new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                                                     | ElemDesc.BLOCKFORMFIELDSET));
     m_elementFlags.put(""ILAYER"",
                                        new ElemDesc(0 | ElemDesc.BLOCK | ElemDesc.BLOCKFORM
                                                                     | ElemDesc.BLOCKFORMFIELDSET));
  
    ElemDesc elemDesc;

    elemDesc = (ElemDesc) m_elementFlags.get(""AREA"");

    elemDesc.setAttr(""HREF"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""NOHREF"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""BASE"");

    elemDesc.setAttr(""HREF"", ElemDesc.ATTRURL);

    elemDesc = (ElemDesc) m_elementFlags.get(""BLOCKQUOTE"");

    elemDesc.setAttr(""CITE"", ElemDesc.ATTRURL);

    elemDesc = (ElemDesc) m_elementFlags.get(""Q"");

    elemDesc.setAttr(""CITE"", ElemDesc.ATTRURL);

    elemDesc = (ElemDesc) m_elementFlags.get(""INS"");

    elemDesc.setAttr(""CITE"", ElemDesc.ATTRURL);

    elemDesc = (ElemDesc) m_elementFlags.get(""DEL"");

    elemDesc.setAttr(""CITE"", ElemDesc.ATTRURL);

    elemDesc = (ElemDesc) m_elementFlags.get(""A"");

    elemDesc.setAttr(""HREF"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""NAME"", ElemDesc.ATTRURL);
    
    elemDesc = (ElemDesc) m_elementFlags.get(""LINK"");
    elemDesc.setAttr(""HREF"", ElemDesc.ATTRURL);

    elemDesc = (ElemDesc) m_elementFlags.get(""INPUT"");

    elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""USEMAP"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""CHECKED"", ElemDesc.ATTREMPTY);
    elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);
    elemDesc.setAttr(""ISMAP"", ElemDesc.ATTREMPTY);
    elemDesc.setAttr(""READONLY"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""SELECT"");

    elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);
    elemDesc.setAttr(""MULTIPLE"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""OPTGROUP"");

    elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""OPTION"");

    elemDesc.setAttr(""SELECTED"", ElemDesc.ATTREMPTY);
    elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""TEXTAREA"");

    elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);
    elemDesc.setAttr(""READONLY"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""BUTTON"");

    elemDesc.setAttr(""DISABLED"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""SCRIPT"");

    elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""FOR"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""DEFER"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""IMG"");

    elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""LONGDESC"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""USEMAP"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""ISMAP"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""OBJECT"");

    elemDesc.setAttr(""CLASSID"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""CODEBASE"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""DATA"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""ARCHIVE"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""USEMAP"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""DECLARE"", ElemDesc.ATTREMPTY);

    elemDesc = (ElemDesc) m_elementFlags.get(""FORM"");

    elemDesc.setAttr(""ACTION"", ElemDesc.ATTRURL);

    elemDesc = (ElemDesc) m_elementFlags.get(""HEAD"");

    elemDesc.setAttr(""PROFILE"", ElemDesc.ATTRURL);

    
    elemDesc = (ElemDesc) m_elementFlags.get(""FRAME"");

    elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""LONGDESC"", ElemDesc.ATTRURL);
 
    
    elemDesc = (ElemDesc) m_elementFlags.get(""IFRAME"");
 
    elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
    elemDesc.setAttr(""LONGDESC"", ElemDesc.ATTRURL);
 
    
    elemDesc = (ElemDesc) m_elementFlags.get(""LAYER"");
 
    elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
 
    elemDesc = (ElemDesc) m_elementFlags.get(""ILAYER"");
 
    elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
 
    elemDesc = (ElemDesc) m_elementFlags.get(""DIV"");

    elemDesc.setAttr(""SRC"", ElemDesc.ATTRURL);
  }

  
  static private ElemDesc m_dummy = new ElemDesc(0 | ElemDesc.BLOCK);

  
  private boolean m_specialEscapeURLs = true;

  
  private boolean m_omitMetaTag = false;

  
  public void setSpecialEscapeURLs(boolean bool)
  {
    m_specialEscapeURLs = bool;
  }

  
  public void setOmitMetaTag(boolean bool)
  {
    m_omitMetaTag = bool;
  }

  
  public void setOutputFormat(Properties format)
  {

    m_specialEscapeURLs =
      OutputProperties.getBooleanProperty(OutputProperties.S_USE_URL_ESCAPING,
                                          format);

    m_omitMetaTag =
      OutputProperties.getBooleanProperty(OutputProperties.S_OMIT_META_TAG,
                                          format);
                            
    super.setOutputFormat(format);
  }

  
  public boolean getSpecialEscapeURLs()
  {
    return m_specialEscapeURLs;
  }

  
  public boolean getOmitMetaTag()
  {
    return m_omitMetaTag;
  }

  
  ElemDesc getElemDesc(String name)
  {

    if (null != name)
    {
      Object obj = m_elementFlags.get(name);

      if (null != obj)
        return (ElemDesc) obj;
    }

    return m_dummy;
  }

  
  public SerializerToHTML()
  {

    super();
    m_charInfo = m_htmlcharInfo;
  }

  
  private String m_currentElementName = null;

  
  public void startDocument() throws org.xml.sax.SAXException
  {

    m_needToOutputDocTypeDecl = true;
    m_startNewLine = false;
    m_shouldNotWriteXMLHeader = true;

    if (true == m_needToOutputDocTypeDecl)
    {
      if ((null != m_doctypeSystem) || (null != m_doctypePublic))
      {
        accum(""<!DOCTYPE HTML"");

        if (null != m_doctypePublic)
        {
          accum("" PUBLIC """");
          accum(m_doctypePublic);
          accum("""""");
        }

        if (null != m_doctypeSystem)
        {
          if (null == m_doctypePublic)
            accum("" SYSTEM """");
          else
            accum("" """");

          accum(m_doctypeSystem);
          accum("""""");
        }

        accum("">"");
        outputLineSep();
      }
    }

    m_needToOutputDocTypeDecl = false;
  }

  
  public void startElement(
          String namespaceURI, String localName, String name, Attributes atts)
            throws org.xml.sax.SAXException
  {
    

    if (null != namespaceURI && namespaceURI.length() > 0)
    {
      super.startElement(namespaceURI, localName, name, atts);

      return;
    }

    boolean savedDoIndent = m_doIndent;
    boolean noLineBreak;

    writeParentTagEnd();
    pushState(
      namespaceURI, localName,
      m_cdataSectionNames, m_cdataSectionStates);

    
    
    ElemDesc elemDesc = getElemDesc(name);

    
    boolean isBlockElement = elemDesc.is(ElemDesc.BLOCK);
    boolean isHeadElement = elemDesc.is(ElemDesc.HEADELEM);

    
    if (m_ispreserve)
      m_ispreserve = false;
    else if (m_doIndent && (null != m_currentElementName)
             && (!m_inBlockElem || isBlockElement)

    
    )
    {
      m_startNewLine = true;

      indent(m_currentIndent);
    }

    m_inBlockElem = !isBlockElement;

    m_isRawStack.push(elemDesc.is(ElemDesc.RAW));

    m_currentElementName = name;

    
    this.accum('<');
    this.accum(name);

    int nAttrs = atts.getLength();

    for (int i = 0; i < nAttrs; i++)
    {
      processAttribute(atts.getQName(i), elemDesc, atts.getValue(i));
    }

    
    openElementForChildren();

    m_currentIndent += this.m_indentAmount;
    m_isprevtext = false;
    m_doIndent = savedDoIndent;

    if (isHeadElement)
    {
      writeParentTagEnd();

      if (!m_omitMetaTag)
      {
        if (m_doIndent)
          indent(m_currentIndent);

        accum(
          ""<META http-equiv=""Content-Type"" content=""text/html; charset="");

        
        String encoding = Encodings.getMimeEncoding(m_encoding);

        accum(encoding);
        accum('""');
        accum('>');
      }
    }
  }

  
  public void endElement(String namespaceURI, String localName, String name)
          throws org.xml.sax.SAXException
  {
    
    if (null != namespaceURI && namespaceURI.length() > 0)
    {
      super.endElement(namespaceURI, localName, name);

      return;
    }

    m_currentIndent -= this.m_indentAmount;

    boolean hasChildNodes = childNodesWereAdded();

    
    
    m_isRawStack.pop();

    ElemDesc elemDesc = getElemDesc(name);

    
    boolean isBlockElement = elemDesc.is(ElemDesc.BLOCK);
    boolean shouldIndent = false;

    if (m_ispreserve)
    {
      m_ispreserve = false;
    }
    else if (m_doIndent && (!m_inBlockElem || isBlockElement))
    {
      m_startNewLine = true;
      shouldIndent = true;

      
    }

    m_inBlockElem = !isBlockElement;

    if (hasChildNodes)
    {
      if (shouldIndent)
        indent(m_currentIndent);

      this.accum(""</"");
      this.accum(name);
      this.accum('>');

      m_currentElementName = name;
    }
    else
    {
      if (!elemDesc.is(ElemDesc.EMPTY))
      {
        this.accum('>');

        
        
        

        this.accum('<');
        this.accum('/');
        this.accum(name);
        this.accum('>');
      }
      else
      {
        this.accum('>');
      }
    }

    if (elemDesc.is(ElemDesc.WHITESPACESENSITIVE))
      m_ispreserve = true;

    if (hasChildNodes)
    {
      if (!m_preserves.isEmpty())
        m_preserves.pop();
    }

    m_isprevtext = false;

    
    m_cdataSectionStates.pop();
  }

  
  protected void processAttribute(
          String name, ElemDesc elemDesc, String value)
            throws org.xml.sax.SAXException
  {

    this.accum(' ');

    if (((value.length() == 0) || value.equalsIgnoreCase(name))
            && elemDesc.isAttrFlagSet(name, ElemDesc.ATTREMPTY))
    {
      this.accum(name);
    }
    else
    {
      this.accum(name);
      this.accum('=');

      this.accum('""');
      if (elemDesc.isAttrFlagSet(name, ElemDesc.ATTRURL))
        writeAttrURI(value, m_specialEscapeURLs);
      else
        writeAttrString(value, this.m_encoding);
      this.accum('""');

    }
  }
  
  
   private boolean isASCIIDigit(char c)
   {
      return (c >= '0' && c <= '9');
   }
   
 
  private String makeHHString(int i)
  {
    String s = Integer.toHexString(i).toUpperCase();
    if(s.length() == 1)
    {
      s = ""0""+s;
    }
    return s;
  }
    
  
  private boolean isHHSign(String str) 
  {
    boolean sign = true;  
    try {
      char r = (char)Integer.parseInt(str,16);
    } catch (NumberFormatException e) {
      sign = false;  
    }
    return sign;
  }
  
  
  public void writeAttrURI(String string, boolean doURLEscaping)
          throws org.xml.sax.SAXException
  {
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    char[] stringArray = string.toCharArray();
    int len = stringArray.length;
        
    for (int i = 0; i < len; i++)
    {
      char ch = stringArray[i];

      if ((ch < 32) || (ch > 126))
      {
        if (doURLEscaping)
        {
          
          
          
          
          
          
          
          
          
          
          if(ch <= 0x7F)
          {
            accum('%');
            accum(makeHHString(ch));          
          }
          else if(ch <= 0x7FF)
          {
            
            
            int high = (ch >> 6) | 0xC0;  
            int low = (ch & 0x3F) | 0x80; 
            accum('%');
            accum(makeHHString(high));
            accum('%');
            accum(makeHHString(low));
          }
          else if( isUTF16Surrogate(ch) ) 
          {
            
            
            
            
            
            
            
            
            int highSurrogate = ((int) ch) & 0x03FF;
            
            
            
            
            
            int wwww = ((highSurrogate & 0x03C0) >> 6);
            int uuuuu = wwww+1;  
            
            
            int zzzz = (highSurrogate & 0x003C) >> 2;
            
            
            int yyyyyy = ((highSurrogate & 0x0003) << 4) & 0x30;
            
            
            ch = stringArray[++i];
            
            
            int lowSurrogate = ((int) ch) & 0x03FF;
            
            
            yyyyyy = yyyyyy | ((lowSurrogate & 0x03C0) >> 6);
            
            
            int xxxxxx = (lowSurrogate & 0x003F);
            
            int byte1 = 0xF0 | (uuuuu >> 2); 
            int byte2 = 0x80 | (((uuuuu & 0x03) << 4) & 0x30) | zzzz;
            int byte3 = 0x80 | yyyyyy;
            int byte4 = 0x80 | xxxxxx;
            
            accum('%');
            accum(makeHHString(byte1));
            accum('%');
            accum(makeHHString(byte2));
            accum('%');
            accum(makeHHString(byte3));
            accum('%');
            accum(makeHHString(byte4));
          }
          else 
          {
            int high = (ch >> 12) | 0xE0; 
            int middle = ((ch & 0x0FC0) >> 6) | 0x80; 
            int low = (ch & 0x3F) | 0x80; 
            accum('%');
            accum(makeHHString(high));
            accum('%');
            accum(makeHHString(middle));
            accum('%');
            accum(makeHHString(low));
          }

        }
        else if (canConvert(ch))
        {
          accum(ch);
        }
        else
        {
          accum(""&#"");
          accum(Integer.toString(ch));
          accum(';');
        }
      }
      else if('%' == ch)
      {
        
        
          


          

        

       
            accum(ch);
       
               
      } 
      
      
      
      else if (ch == '""')
      {
        
        if (doURLEscaping)
          accum(""%22"");
        else
          accum(""&quot;""); 
      }
      else
      {
        accum(ch);
      }
    }
              
  }

  
  public void writeAttrString(String string, String encoding)
          throws org.xml.sax.SAXException
  {

    final char chars[] = string.toCharArray();
    final int strLen = chars.length;

    for (int i = 0; i < strLen; i++)
    {
      char ch = chars[i];

      
      
      
      
      if (canConvert(ch) && (!m_charInfo.isSpecial(ch)))
      {
        accum(ch);
      }
      else if ('<' == ch || '>' == ch)
      {
        accum(ch);  
      }
      else if (('&' == ch) && ((i + 1) < strLen) && ('{' == chars[i + 1]))
      {
        accum(ch);  
      }
      else
      {
        int pos = accumDefaultEntity(ch, i, chars, strLen, false);

        if (i != pos)
        {
          i = pos - 1;
        }
        else
        {
          if (isUTF16Surrogate(ch))
          {
            try
            {
              i = writeUTF16Surrogate(ch, chars, i, strLen);
            }
            catch(IOException ioe)
            {
              throw new SAXException(ioe);
            }
          }

          
          

          
          String entityName = m_charInfo.getEntityNameForChar(ch);

          if (null != entityName)
          {
            accum('&');
            accum(entityName);
            accum(';');
          }
          else if (canConvert(ch))
          {
            accum(ch);  
          }
          else
          {
            accum(""&#"");
            accum(Integer.toString(ch));
            accum(';');
          }
        }
      }
    }
  }

  
  private int copyEntityIntoBuf(String s, int pos)
          throws org.xml.sax.SAXException
  {

    int l = s.length();

    accum('&');

    for (int i = 0; i < l; i++)
    {
      accum(s.charAt(i));
    }

    accum(';');

    return pos;
  }

  
  public void characters(char chars[], int start, int length)
          throws org.xml.sax.SAXException
  {

    if (m_isRawStack.peekOrFalse())
    {
      try
      {
        writeParentTagEnd();

        m_ispreserve = true;

        if (shouldIndent())
          indent(m_currentIndent);

        
        
        writeNormalizedChars(chars, start, length, false);

        
        return;
      }
      catch (IOException ioe)
      {
        throw new org.xml.sax.SAXException(
          XSLMessages.createXPATHMessage(
          XPATHErrorResources.ER_OIERROR, null), ioe);  
      }
    }
    else
    {
      super.characters(chars, start, length);
    }
  }

  
  public void cdata(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    if ((null != m_currentElementName)
            && (m_currentElementName.equalsIgnoreCase(""SCRIPT"")
                || m_currentElementName.equalsIgnoreCase(""STYLE"")))
    {
      try
      {
        writeParentTagEnd();

        m_ispreserve = true;

        if (shouldIndent())
          indent(m_currentIndent);

        
        writeNormalizedChars(ch, start, length, true);
      }
      catch (IOException ioe)
      {
        throw new org.xml.sax.SAXException(
          XSLMessages.createXPATHMessage(
          XPATHErrorResources.ER_OIERROR, null), ioe);  
      }
    }

    
    else
    {
      super.cdata(ch, start, length);
    }
  }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {

    
    
    if (target.equals(Result.PI_DISABLE_OUTPUT_ESCAPING))
    {
      startNonEscaping();
    }
    else if (target.equals(Result.PI_ENABLE_OUTPUT_ESCAPING))
    {
      endNonEscaping();
    }
    else
    {
      writeParentTagEnd();

      if (shouldIndent())
        indent(m_currentIndent);

      this.accum(""<?"" + target);

      if (data.length() > 0 &&!Character.isSpaceChar(data.charAt(0)))
        this.accum("" "");

      this.accum(data + "">"");  
      
      
      
      
      if (m_elemStack.isEmpty())
         outputLineSep();

      m_startNewLine = true;
    }
  }

  
  public void entityReference(String name) throws org.xml.sax.SAXException
  {

    this.accum(""&"");
    this.accum(name);
    this.accum("";"");
  }
}

"
org.apache.xalan.xslt.EnvironmentCheck,22,1,0,1,77,219,1,0,5,0.972789116,2261,0.142857143,0,0.0,0.227513228,0,0,101.1363636,8,3.4091,0,"
package org.apache.xalan.xslt;

import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;

import java.lang.reflect.Method;
import java.lang.reflect.Field;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.StringTokenizer;
import java.util.Vector;


import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;


public class EnvironmentCheck
{

  
  public static void main(String[] args)
  {
    
    PrintWriter sendOutputTo = new PrintWriter(System.out, true);

    
    for (int i = 0; i < args.length; i++)
    {
      if (""-out"".equalsIgnoreCase(args[i]))
      {
        i++;

        if (i < args.length)
        {
          try
          {
            sendOutputTo = new PrintWriter(new FileWriter(args[i], true));
          }
          catch (Exception e)
          {
            System.err.println(""# WARNING: -out "" + args[i] + "" threw ""
                               + e.toString());
          }
        }
        else
        {
          System.err.println(
            ""# WARNING: -out argument should have a filename, output sent to console"");
        }
      }
    }

    EnvironmentCheck app = new EnvironmentCheck();
    app.checkEnvironment(sendOutputTo);
  }

  
  public boolean checkEnvironment(PrintWriter pw)
  {

    
    if (null != pw)
      outWriter = pw;

    
    Hashtable hash = getEnvironmentHash();

    
    boolean environmentHasErrors = writeEnvironmentReport(hash);

    if (environmentHasErrors)
    {
      
      
      logMsg(""# WARNING: Potential problems found in your environment!"");
      logMsg(""#    Check any 'ERROR' items above against the Xalan FAQs"");
      logMsg(""#    to correct potential problems with your classes/jars"");
      logMsg(""#    http:
      if (null != outWriter)
        outWriter.flush();
      return false;
    }
    else
    {
      logMsg(""# YAHOO! Your environment seems to be OK."");
      if (null != outWriter)
        outWriter.flush();
      return true;
    }
  }

  
  public Hashtable getEnvironmentHash()
  {
    
    Hashtable hash = new Hashtable();

    
    
    
    checkJAXPVersion(hash);
    checkProcessorVersion(hash);
    checkParserVersion(hash);
    checkAntVersion(hash);
    checkDOMVersion(hash);
    checkSAXVersion(hash);
    checkSystemProperties(hash);

    return hash;
  }

  
  protected boolean writeEnvironmentReport(Hashtable h)
  {

    if (null == h)
    {
      logMsg(""# ERROR: writeEnvironmentReport called with null Hashtable"");
      return false;
    }

    boolean errors = false;

    logMsg(
      ""#---- BEGIN writeEnvironmentReport($Revision: 1.13 $): Useful stuff found: ----"");

    
    for (Enumeration enum = h.keys(); 
         enum.hasMoreElements();
        
        )
    {
      Object key = enum.nextElement();
      String keyStr = (String) key;
      try
      {
        
        if (keyStr.startsWith(FOUNDCLASSES))
        {
          Vector v = (Vector) h.get(keyStr);
          errors |= logFoundJars(v, keyStr);
        }
        
        else
        {
          
          
          
          
          if (keyStr.startsWith(ERROR))
          {
            errors = true;
          }
          logMsg(keyStr + ""="" + h.get(keyStr));
        }
      }
      catch (Exception e)
      {
        logMsg(""Reading-"" + key + ""= threw: "" + e.toString());
      }
    }

    logMsg(
      ""#----- END writeEnvironmentReport: Useful properties found: -----"");

    return errors;
  }

  
  public static final String ERROR = ""ERROR."";

  
  public static final String WARNING = ""WARNING."";

  
  public static final String ERROR_FOUND = ""At least one error was found!"";

  
  public static final String VERSION = ""version."";

  
  public static final String FOUNDCLASSES = ""foundclasses."";

  
  public static final String CLASS_PRESENT = ""present-unknown-version"";

  
  public static final String CLASS_NOTPRESENT = ""not-present"";

  
  public String[] jarNames =
  {
    ""xalan.jar"", ""xalansamples.jar"", ""xalanj1compat.jar"", ""xalanservlet.jar"",
    ""xerces.jar"",       
    ""xercesImpl.jar"",   
    ""testxsl.jar"", 
    ""crimson.jar"", 
    ""lotusxsl.jar"", 
    ""jaxp.jar"", ""parser.jar"", ""dom.jar"", ""sax.jar"", ""xml.jar"", 
    ""xml-apis.jar"",
    ""xsltc.jar""
  };

  
  protected boolean logFoundJars(Vector v, String desc)
  {

    if ((null == v) || (v.size() < 1))
      return false;

    boolean errors = false;

    logMsg(""#---- BEGIN Listing XML-related jars in: "" + desc + "" ----"");

    for (int i = 0; i < v.size(); i++)
    {
      Hashtable subhash = (Hashtable) v.elementAt(i);

      for (Enumeration enum = subhash.keys(); 
           enum.hasMoreElements();
           
          )
      {
        Object key = enum.nextElement();
        String keyStr = (String) key;
        try
        {
          if (keyStr.startsWith(ERROR))
          {
            errors = true;
          }
          logMsg(keyStr + ""="" + subhash.get(keyStr));

        }
        catch (Exception e)
        {
          errors = true;
          logMsg(""Reading-"" + key + ""= threw: "" + e.toString());
        }
      }
    }

    logMsg(""#----- END Listing XML-related jars in: "" + desc + "" -----"");

    return errors;
  }

  
  public void appendEnvironmentReport(Node container, Document factory, Hashtable h)
  {
    if ((null == container) || (null == factory))
    {
      return;
    }
  
    try
    {
      Element envCheckNode = factory.createElement(""EnvironmentCheck"");
      envCheckNode.setAttribute(""version"", ""$Revision: 1.13 $"");
      container.appendChild(envCheckNode);

      if (null == h)
      {
        Element statusNode = factory.createElement(""status"");
        statusNode.setAttribute(""result"", ""ERROR"");
        statusNode.appendChild(factory.createTextNode(""appendEnvironmentReport called with null Hashtable!""));
        envCheckNode.appendChild(statusNode);
        return;
      }

      boolean errors = false;

      Element hashNode = factory.createElement(""environment"");
      envCheckNode.appendChild(hashNode);
      
      for (Enumeration enum = h.keys(); 
           enum.hasMoreElements();
          
          )
      {
        Object key = enum.nextElement();
        String keyStr = (String) key;
        try
        {
          
          if (keyStr.startsWith(FOUNDCLASSES))
          {
            Vector v = (Vector) h.get(keyStr);
            
            errors |= appendFoundJars(hashNode, factory, v, keyStr);
          }
          
          else 
          {
            
            
            
            
            if (keyStr.startsWith(ERROR))
            {
              errors = true;
            }
            Element node = factory.createElement(""item"");
            node.setAttribute(""key"", keyStr);
            node.appendChild(factory.createTextNode((String)h.get(keyStr)));
            hashNode.appendChild(node);
          }
        }
        catch (Exception e)
        {
          errors = true;
          Element node = factory.createElement(""item"");
          node.setAttribute(""key"", keyStr);
          node.appendChild(factory.createTextNode(ERROR + "" Reading "" + key + "" threw: "" + e.toString()));
          hashNode.appendChild(node);
        }
      } 

      Element statusNode = factory.createElement(""status"");
      statusNode.setAttribute(""result"", (errors ? ""ERROR"" : ""OK"" ));
      envCheckNode.appendChild(statusNode);
    }
    catch (Exception e2)
    {
      System.err.println(""appendEnvironmentReport threw: "" + e2.toString());
      e2.printStackTrace();
    }
  }    

  
  protected boolean appendFoundJars(Node container, Document factory, 
        Vector v, String desc)
  {

    if ((null == v) || (v.size() < 1))
      return false;

    boolean errors = false;

    for (int i = 0; i < v.size(); i++)
    {
      Hashtable subhash = (Hashtable) v.elementAt(i);

      for (Enumeration enum = subhash.keys(); 
           enum.hasMoreElements();
           
          )
      {
        Object key = enum.nextElement();
        try
        {
          String keyStr = (String) key;
          if (keyStr.startsWith(ERROR))
          {
            errors = true;
          }
          Element node = factory.createElement(""foundJar"");
          node.setAttribute(""name"", keyStr.substring(0, keyStr.indexOf(""-"")));
          node.setAttribute(""desc"", keyStr.substring(keyStr.indexOf(""-"") + 1));
          node.appendChild(factory.createTextNode((String)subhash.get(keyStr)));
          container.appendChild(node);
        }
        catch (Exception e)
        {
          errors = true;
          Element node = factory.createElement(""foundJar"");
          node.appendChild(factory.createTextNode(ERROR + "" Reading "" + key + "" threw: "" + e.toString()));
          container.appendChild(node);
        }
      }
    }
    return errors;
  }

  
  protected void checkSystemProperties(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    
    try
    {
      String javaVersion = System.getProperty(""java.version"");

      h.put(""java.version"", javaVersion);
    }
    catch (SecurityException se)
    {

      
      h.put(
        ""java.version"",
        ""WARNING: SecurityException thrown accessing system version properties"");
    }

    
    
    try
    {

      
      String cp = System.getProperty(""java.class.path"");

      h.put(""java.class.path"", cp);

      Vector classpathJars = checkPathForJars(cp, jarNames);

      if (null != classpathJars)
        h.put(FOUNDCLASSES + ""java.class.path"", classpathJars);

      
      String othercp = System.getProperty(""sun.boot.class.path"");

      if (null != othercp)
      {
        h.put(""sun.boot.class.path"", othercp);

        classpathJars = checkPathForJars(othercp, jarNames);

        if (null != classpathJars)
          h.put(FOUNDCLASSES + ""sun.boot.class.path"", classpathJars);
      }

      
      
      othercp = System.getProperty(""java.ext.dirs"");

      if (null != othercp)
      {
        h.put(""java.ext.dirs"", othercp);

        classpathJars = checkPathForJars(othercp, jarNames);

        if (null != classpathJars)
          h.put(FOUNDCLASSES + ""java.ext.dirs"", classpathJars);
      }

      
      
      
    }
    catch (SecurityException se2)
    {
      
      h.put(
        ""java.class.path"",
        ""WARNING: SecurityException thrown accessing system classpath properties"");
    }
  }

  
  protected Vector checkPathForJars(String cp, String[] jars)
  {

    if ((null == cp) || (null == jars) || (0 == cp.length())
            || (0 == jars.length))
      return null;

    Vector v = new Vector();
    StringTokenizer st = new StringTokenizer(cp, File.pathSeparator);

    while (st.hasMoreTokens())
    {

      
      String filename = st.nextToken();

      for (int i = 0; i < jars.length; i++)
      {
        if (filename.indexOf(jars[i]) > -1)
        {
          File f = new File(filename);

          if (f.exists())
          {

            
            
            try
            {
              Hashtable h = new Hashtable(2);
              
              h.put(jars[i] + ""-path"", f.getAbsolutePath());
              h.put(jars[i] + ""-apparent.version"",
                    getApparentVersion(jars[i], f.length()));
              v.addElement(h);
            }
            catch (Exception e)
            {

              
            }
          }
          else
          {
            Hashtable h = new Hashtable(2);
            
            h.put(jars[i] + ""-path"", WARNING + "" Classpath entry: "" 
                  + filename + "" does not exist"");
            h.put(jars[i] + ""-apparent.version"", CLASS_NOTPRESENT);
            v.addElement(h);
          }
        }
      }
    }

    return v;
  }

  
  protected String getApparentVersion(String jarName, long jarSize)
  {
    
    
    
    String foundSize = (String) jarVersions.get(new Long(jarSize));

    if ((null != foundSize) && (foundSize.startsWith(jarName)))
    {
      return foundSize;
    }
    else
    {
      if (""xerces.jar"".equalsIgnoreCase(jarName)
              || ""xercesImpl.jar"".equalsIgnoreCase(jarName)
              || ""xalan.jar"".equalsIgnoreCase(jarName))
      {

        
        
        
        return jarName + "" "" + WARNING + CLASS_PRESENT;
      }
      else
      {

        
        return jarName + "" "" + CLASS_PRESENT;
      }
    }
  }

  
  protected void checkJAXPVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    final Class noArgs[] = new Class[0];
    Class clazz = null;

    try
    {
      final String JAXP1_CLASS = ""javax.xml.parsers.DocumentBuilder"";
      final String JAXP11_METHOD = ""getDOMImplementation"";

      clazz = classForName(JAXP1_CLASS);

      Method method = clazz.getMethod(JAXP11_METHOD, noArgs);

      
      h.put(VERSION + ""JAXP"", ""1.1"");
    }
    catch (Exception e)
    {
      if (null != clazz)
      {

        
        
        h.put(ERROR + VERSION + ""JAXP"", ""1.0.1"");
        h.put(ERROR, ERROR_FOUND);
      }
      else
      {
        
        
        
        h.put(ERROR + VERSION + ""JAXP"", CLASS_NOTPRESENT);
        h.put(ERROR, ERROR_FOUND);
      }
    }
  }

  
  protected void checkProcessorVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    try
    {
      final String XALAN1_VERSION_CLASS =
        ""org.apache.xalan.xslt.XSLProcessorVersion"";
      Class clazz = classForName(XALAN1_VERSION_CLASS);

      
      StringBuffer buf = new StringBuffer();
      Field f = clazz.getField(""PRODUCT"");

      buf.append(f.get(null));
      buf.append(';');

      f = clazz.getField(""LANGUAGE"");

      buf.append(f.get(null));
      buf.append(';');

      f = clazz.getField(""S_VERSION"");

      buf.append(f.get(null));
      buf.append(';');
      h.put(VERSION + ""xalan1"", buf.toString());
    }
    catch (Exception e1)
    {
      h.put(VERSION + ""xalan1"", CLASS_NOTPRESENT);
    }

    try
    {
      
      
      final String XALAN2_VERSION_CLASS =
        ""org.apache.xalan.processor.XSLProcessorVersion"";
      Class clazz = classForName(XALAN2_VERSION_CLASS);

      
      StringBuffer buf = new StringBuffer();
      Field f = clazz.getField(""S_VERSION"");
      buf.append(f.get(null));

      h.put(VERSION + ""xalan2x"", buf.toString());
    }
    catch (Exception e2)
    {
      h.put(VERSION + ""xalan2x"", CLASS_NOTPRESENT);
    }
    try
    {
      
      final String XALAN2_2_VERSION_CLASS =
        ""org.apache.xalan.Version"";
      final String XALAN2_2_VERSION_METHOD = ""getVersion"";
      final Class noArgs[] = new Class[0];

      Class clazz = classForName(XALAN2_2_VERSION_CLASS);
      Method method = clazz.getMethod(XALAN2_2_VERSION_METHOD, noArgs);
      Object returnValue = method.invoke(null, new Object[0]);

      h.put(VERSION + ""xalan2_2"", (String)returnValue);
    }
    catch (Exception e2)
    {
      h.put(VERSION + ""xalan2_2"", CLASS_NOTPRESENT);
    }
  }

  
  protected void checkParserVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    try
    {
      final String XERCES1_VERSION_CLASS = ""org.apache.xerces.framework.Version"";
      Class clazz = classForName(XERCES1_VERSION_CLASS);

      
      Field f = clazz.getField(""fVersion"");
      String parserVersion = (String) f.get(null);

      h.put(VERSION + ""xerces1"", parserVersion);
    }
    catch (Exception e)
    {
      h.put(VERSION + ""xerces1"", CLASS_NOTPRESENT);
    }

    
    try
    {
      final String XERCES2_VERSION_CLASS = ""org.apache.xerces.impl.Version"";
      Class clazz = classForName(XERCES2_VERSION_CLASS);

      
      Field f = clazz.getField(""fVersion"");
      String parserVersion = (String) f.get(null);

      h.put(VERSION + ""xerces2"", parserVersion);
    }
    catch (Exception e)
    {
      h.put(VERSION + ""xerces2"", CLASS_NOTPRESENT);
    }

    try
    {
      final String CRIMSON_CLASS = ""org.apache.crimson.parser.Parser2"";
      Class clazz = classForName(CRIMSON_CLASS);

      
      h.put(VERSION + ""crimson"", CLASS_PRESENT);
    }
    catch (Exception e)
    {
      h.put(VERSION + ""crimson"", CLASS_NOTPRESENT);
    }
  }

  
  protected void checkAntVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    try
    {
      final String ANT_VERSION_CLASS = ""org.apache.tools.ant.Main"";
      final String ANT_VERSION_METHOD = ""getAntVersion""; 
      final Class noArgs[] = new Class[0];

      Class clazz = classForName(ANT_VERSION_CLASS);
      Method method = clazz.getMethod(ANT_VERSION_METHOD, noArgs);
      Object returnValue = method.invoke(null, new Object[0]);

      h.put(VERSION + ""ant"", (String)returnValue);
    }
    catch (Exception e)
    {
      h.put(VERSION + ""ant"", CLASS_NOTPRESENT);
    }
  }

  
  protected void checkDOMVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    final String DOM_LEVEL2_CLASS = ""org.w3c.dom.Document"";
    final String DOM_LEVEL2_METHOD = ""createElementNS"";  
    final String DOM_LEVEL2WD_CLASS = ""org.w3c.dom.Node"";
    final String DOM_LEVEL2WD_METHOD = ""supported"";  
    final String DOM_LEVEL2FD_CLASS = ""org.w3c.dom.Node"";
    final String DOM_LEVEL2FD_METHOD = ""isSupported"";  
    final Class twoStringArgs[] = { java.lang.String.class,
                                    java.lang.String.class };

    try
    {
      Class clazz = classForName(DOM_LEVEL2_CLASS);
      Method method = clazz.getMethod(DOM_LEVEL2_METHOD, twoStringArgs);

      
      
      h.put(VERSION + ""DOM"", ""2.0"");

      try
      {

        
        
        clazz = classForName(DOM_LEVEL2WD_CLASS);
        method = clazz.getMethod(DOM_LEVEL2WD_METHOD, twoStringArgs);

        h.put(ERROR + VERSION + ""DOM.draftlevel"", ""2.0wd"");
        h.put(ERROR, ERROR_FOUND);
      }
      catch (Exception e2)
      {
        try
        {

          
          clazz = classForName(DOM_LEVEL2FD_CLASS);
          method = clazz.getMethod(DOM_LEVEL2FD_METHOD, twoStringArgs);

          h.put(VERSION + ""DOM.draftlevel"", ""2.0fd"");
        }
        catch (Exception e3)
        {
          h.put(ERROR + VERSION + ""DOM.draftlevel"", ""2.0unknown"");
          h.put(ERROR, ERROR_FOUND);
        }
      }
    }
    catch (Exception e)
    {
      h.put(ERROR + VERSION + ""DOM"",
            ""ERROR attempting to load DOM level 2 class: "" + e.toString());
      h.put(ERROR, ERROR_FOUND);
    }

    
    
    
    
  }

  
  protected void checkSAXVersion(Hashtable h)
  {

    if (null == h)
      h = new Hashtable();

    final String SAX_VERSION1_CLASS = ""org.xml.sax.Parser"";
    final String SAX_VERSION1_METHOD = ""parse"";  
    final String SAX_VERSION2_CLASS = ""org.xml.sax.XMLReader"";
    final String SAX_VERSION2_METHOD = ""parse"";  
    final String SAX_VERSION2BETA_CLASSNF = ""org.xml.sax.helpers.AttributesImpl"";
    final String SAX_VERSION2BETA_METHODNF = ""setAttributes"";  
    final Class oneStringArg[] = { java.lang.String.class };
    
    final Class attributesArg[] = { org.xml.sax.Attributes.class };

    try
    {
      
      
      Class clazz = classForName(SAX_VERSION2BETA_CLASSNF);
      Method method = clazz.getMethod(SAX_VERSION2BETA_METHODNF, attributesArg);

      
      
      h.put(VERSION + ""SAX"", ""2.0"");
    }
    catch (Exception e)
    {
      
      h.put(ERROR + VERSION + ""SAX"",
            ""ERROR attempting to load SAX version 2 class: "" + e.toString());
      h.put(ERROR, ERROR_FOUND);
            
      try
      {
        Class clazz = classForName(SAX_VERSION2_CLASS);
        Method method = clazz.getMethod(SAX_VERSION2_METHOD, oneStringArg);

        
        
        
        h.put(VERSION + ""SAX-backlevel"", ""2.0beta2-or-earlier"");
      }
      catch (Exception e2)
      {
        
        h.put(ERROR + VERSION + ""SAX"",
              ""ERROR attempting to load SAX version 2 class: "" + e.toString());
        h.put(ERROR, ERROR_FOUND);
          
        try
        {
          Class clazz = classForName(SAX_VERSION1_CLASS);
          Method method = clazz.getMethod(SAX_VERSION1_METHOD, oneStringArg);

          
          
          
          h.put(VERSION + ""SAX-backlevel"", ""1.0"");
        }
        catch (Exception e3)
        {
          
          
          h.put(ERROR + VERSION + ""SAX-backlevel"",
                ""ERROR attempting to load SAX version 1 class: "" + e3.toString());
            
        }
      }
    }
  }

  
  protected static Class classForName(String className)
        throws ClassNotFoundException
  {
    ClassLoader classLoader = findClassLoader();
    if (classLoader == null) 
    {
      return Class.forName(className);
    } 
    else 
    {
      return classLoader.loadClass(className);
    }
  }
  
  
  protected static ClassLoader findClassLoader()
        throws ClassNotFoundException
  {
    ClassLoader classLoader = null;
    Method m = null;

    try 
    {
      m = Thread.class.getMethod(""getContextClassLoader"", null);
    } 
    catch (NoSuchMethodException e) 
    {
      
      return EnvironmentCheck.class.getClassLoader();
    }
    try 
    {
      return (ClassLoader) m.invoke(Thread.currentThread(), null);
    } 
    catch (Exception e) 
    {
      throw new RuntimeException(e.toString());
    }
  }

  
  protected static Hashtable jarVersions = new Hashtable();

  
  static 
  {
    
    jarVersions.put(new Long(857192), ""xalan.jar from xalan-j_1_1"");
    jarVersions.put(new Long(440237), ""xalan.jar from xalan-j_1_2"");
    jarVersions.put(new Long(436094), ""xalan.jar from xalan-j_1_2_1"");
    jarVersions.put(new Long(426249), ""xalan.jar from xalan-j_1_2_2"");
    jarVersions.put(new Long(702536), ""xalan.jar from xalan-j_2_0_0"");
    jarVersions.put(new Long(720930), ""xalan.jar from xalan-j_2_0_1"");
    jarVersions.put(new Long(732330), ""xalan.jar from xalan-j_2_1_0"");
    jarVersions.put(new Long(872241), ""xalan.jar from xalan-j_2_2_D10"");
    jarVersions.put(new Long(882739), ""xalan.jar from xalan-j_2_2_D11"");
    jarVersions.put(new Long(923866), ""xalan.jar from xalan-j_2_2_0"");
    jarVersions.put(new Long(905872), ""xalan.jar from xalan-j_2_3_D1"");
    jarVersions.put(new Long(906122), ""xalan.jar from xalan-j_2_3_0"");
    jarVersions.put(new Long(906248), ""xalan.jar from xalan-j_2_3_1"");
    jarVersions.put(new Long(997276), ""xalan.jar from xalan-j_2_4_0"");


    

    jarVersions.put(new Long(857171), ""xalan.jar from lotusxsl-j_1_0_1"");
    jarVersions.put(new Long(802165), ""xalan.jar from lotusxsl-j_2_0_0"");
    jarVersions.put(new Long(857692), ""xalan.jar from lotusxsl-j_2_2"");

    jarVersions.put(new Long(596540), ""xsltc.jar from xalan-j_2_2_0"");
    jarVersions.put(new Long(590247), ""xsltc.jar from xalan-j_2_3_D1"");
    jarVersions.put(new Long(589914), ""xsltc.jar from xalan-j_2_3_0"");
    jarVersions.put(new Long(589915), ""xsltc.jar from xalan-j_2_3_1"");
    jarVersions.put(new Long(1328227), ""xsltc.jar from xalan-j_2_4_0"");
    jarVersions.put(new Long(1268634), ""xsltc.jar-bundled from xalan-j_2_3_0"");

    jarVersions.put(new Long(100196), ""xml-apis.jar from xalan-j_2_2_0 or xalan-j_2_3_D1"");
    jarVersions.put(new Long(108484), ""xml-apis.jar from xalan-j_2_3_0, or xalan-j_2_3_1 from xml-commons-1.0.b2"");
    jarVersions.put(new Long(109049), ""xml-apis.jar from xalan-j_2_4_0 from xml-commons RIVERCOURT1 branch"");
    

    
    
    jarVersions.put(new Long(424490), ""xalan.jar from Xerces Tools releases - ERROR:DO NOT USE!"");

    jarVersions.put(new Long(1591855), ""xerces.jar from xalan-j_1_1 from xerces-1..."");
    jarVersions.put(new Long(1498679), ""xerces.jar from xalan-j_1_2 from xerces-1_2_0.bin"");
    jarVersions.put(new Long(1484896), ""xerces.jar from xalan-j_1_2_1 from xerces-1_2_1.bin"");
    jarVersions.put(new Long(804460),  ""xerces.jar from xalan-j_1_2_2 from xerces-1_2_2.bin"");
    jarVersions.put(new Long(1499244), ""xerces.jar from xalan-j_2_0_0 from xerces-1_2_3.bin"");
    jarVersions.put(new Long(1605266), ""xerces.jar from xalan-j_2_0_1 from xerces-1_3_0.bin"");
    jarVersions.put(new Long(904030), ""xerces.jar from xalan-j_2_1_0 from xerces-1_4.bin"");
    jarVersions.put(new Long(1190776), ""xerces.jar from lotusxsl_1_0_1 apparently-from xerces-1_0_3.bin"");
    jarVersions.put(new Long(1489400), ""xerces.jar from lotusxsl-j_2_0_0 from XML4J-3_1_1"");
    jarVersions.put(new Long(1787796), ""xerces.jar from lotusxsl-j_2_2 or xerces-1_4_1.bin"");
    jarVersions.put(new Long(904030), ""xerces.jar from xerces-1_4_0.bin"");
    jarVersions.put(new Long(1802885), ""xerces.jar from xerces-1_4_2.bin"");
    jarVersions.put(new Long(1734594), ""xerces.jar from Xerces-J-bin.2.0.0.beta3"");
    jarVersions.put(new Long(1808883), ""xerces.jar from xalan-j_2_2_D10,D11,D12 or xerces-1_4_3.bin"");
    jarVersions.put(new Long(1803877), ""xerces.jar from XML4J-3_2_1"");
    jarVersions.put(new Long(1812019), ""xerces.jar from xalan-j_2_2_0"");
    jarVersions.put(new Long(1720292), ""xercesImpl.jar from xalan-j_2_3_D1"");
    jarVersions.put(new Long(1730053), ""xercesImpl.jar from xalan-j_2_3_0 or xalan-j_2_3_1 from xerces-2_0_0"");
    jarVersions.put(new Long(972027), ""xercesImpl.jar from xalan-j_2_4_0 from xerces-2_1"");

    jarVersions.put(new Long(37485), ""xalanj1compat.jar from xalan-j_2_0_0"");
    jarVersions.put(new Long(38100), ""xalanj1compat.jar from xalan-j_2_0_1"");

    jarVersions.put(new Long(18779), ""xalanservlet.jar from xalan-j_2_0_0"");
    jarVersions.put(new Long(21453), ""xalanservlet.jar from xalan-j_2_0_1"");
    jarVersions.put(new Long(24826), ""xalanservlet.jar from xalan-j_2_3_1 or xalan-j_2_4_0"");

    
    jarVersions.put(new Long(5618), ""jaxp.jar from jaxp1.0.1"");
    jarVersions.put(new Long(136133), ""parser.jar from jaxp1.0.1"");
    jarVersions.put(new Long(28404), ""jaxp.jar from jaxp-1.1"");
    jarVersions.put(new Long(187162), ""crimson.jar from jaxp-1.1"");
    jarVersions.put(new Long(801714), ""xalan.jar from jaxp-1.1"");
    jarVersions.put(new Long(196399), ""crimson.jar from crimson-1.1.1"");
    jarVersions.put(new Long(33323), ""jaxp.jar from crimson-1.1.1 or jakarta-ant-1.4.1b1"");
    jarVersions.put(new Long(152717), ""crimson.jar from crimson-1.1.2beta2"");
    jarVersions.put(new Long(88143), ""xml-apis.jar from crimson-1.1.2beta2"");
    jarVersions.put(new Long(206384), ""crimson.jar from crimson-1.1.3 or jakarta-ant-1.4.1b1"");

    
    jarVersions.put(new Long(136198), ""parser.jar from jakarta-ant-1.3 or 1.2"");
    jarVersions.put(new Long(5537), ""jaxp.jar from jakarta-ant-1.3 or 1.2"");

    
    
    jarVersions.put(new Long(120274), ""lotusxsl.jar from lotusxsl-0_16_4"");
    jarVersions.put(new Long(120293), ""lotusxsl.jar from lotusxsl-0_16_5"");
    jarVersions.put(new Long(283777), ""lotusxsl.jar from lotusxsl-0_17_2"");
    jarVersions.put(new Long(305577), ""lotusxsl.jar from lotusxsl-0_17_3"");
    jarVersions.put(new Long(304500), ""lotusxsl.jar from lotusxsl-0_17_4"");
    jarVersions.put(new Long(714959), ""lotusxsl.jar from lotusxsl-0_18_1"");
    jarVersions.put(new Long(717674), ""lotusxsl.jar from lotusxsl-0_18_2"");
    jarVersions.put(new Long(752343), ""lotusxsl.jar from lotusxsl-0_18_3"");
    jarVersions.put(new Long(907101), ""lotusxsl.jar from lotusxsl-0_18_4"");
  }

  
  protected PrintWriter outWriter = new PrintWriter(System.out, true);

  
  protected void logMsg(String s)
  {
    outWriter.println(s);
  }
}
"
org.apache.xalan.xsltc.dom.DOMBuilder,0,1,0,11,0,0,10,1,0,2.0,0,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"
package org.apache.xalan.xsltc.dom;

import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;

public interface DOMBuilder extends  ExtendedSAX { }
"
org.apache.xml.dtm.ref.DTMDefaultBase,97,1,1,64,139,4474,51,14,72,0.941666667,2010,0.96,14,0.0,0.151442308,0,0,19.46391753,12,2.1031,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;
import org.apache.xml.utils.SuballocatedIntVector;
import org.apache.xml.utils.SuballocatedByteVector;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.StringBufferPool;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.TreeWalker;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.XMLCharacterRecognizer;

import java.util.Vector;

import org.xml.sax.ContentHandler;

import org.apache.xml.utils.NodeVector;

import javax.xml.transform.Source;

import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import java.io.*; 


public abstract class DTMDefaultBase implements DTM
{
	static boolean JJK_DEBUG=false;

	
  
  protected int m_size = 0;

  
  protected SuballocatedIntVector m_exptype;

  
  protected SuballocatedIntVector m_firstch;

  
  protected SuballocatedIntVector m_nextsib;

  
  protected SuballocatedIntVector m_prevsib;

  
  protected SuballocatedIntVector m_parent;

  
  protected Vector m_namespaceDeclSets = null;

  
  protected SuballocatedIntVector m_namespaceDeclSetElements = null;

  
  protected int[][][] m_elemIndexes;

  
  protected int m_initialblocksize = 512;  

  
  protected int m_blocksize = 2 * 1024;

  
  protected static final int NOTPROCESSED = DTM.NULL - 1;

  
  protected DTMManager m_mgr;
  
  protected DTMManagerDefault m_mgrDefault=null;

  
  protected SuballocatedIntVector m_dtmIdent=new SuballocatedIntVector();

  
  

  
  protected String m_documentBaseURI;

  
  protected DTMWSFilter m_wsfilter;

  
  protected boolean m_shouldStripWS = false;

  
  protected BoolStack m_shouldStripWhitespaceStack;

  
  protected XMLStringFactory m_xstrf;

  
  protected ExpandedNameTable m_expandedNameTable;

  
  protected boolean m_indexing;

  
  public DTMDefaultBase(DTMManager mgr, Source source, int dtmIdentity,
                        DTMWSFilter whiteSpaceFilter,
                        XMLStringFactory xstringfactory, boolean doIndexing)
  {
    if(false == doIndexing)
    {
      m_initialblocksize = 8;
      m_blocksize = 16;
    }

    m_exptype = new SuballocatedIntVector(m_initialblocksize);
    m_firstch = new SuballocatedIntVector(m_initialblocksize);
    m_nextsib = new SuballocatedIntVector(m_initialblocksize);
    m_prevsib = new SuballocatedIntVector(m_initialblocksize);
    m_parent = new SuballocatedIntVector(m_initialblocksize);

    m_mgr = mgr;
    if(mgr instanceof DTMManagerDefault)
      m_mgrDefault=(DTMManagerDefault)mgr;
    
    m_documentBaseURI = (null != source) ? source.getSystemId() : null;
    m_dtmIdent.setElementAt(dtmIdentity,0);
    m_wsfilter = whiteSpaceFilter;
    m_xstrf = xstringfactory;
    m_indexing = doIndexing;

    if (doIndexing)
    {
      m_expandedNameTable = new ExpandedNameTable();
    }
    else
    {
      
      
      m_expandedNameTable = m_mgrDefault.getExpandedNameTable(this);
    }

    if (null != whiteSpaceFilter)
    {
      m_shouldStripWhitespaceStack = new BoolStack();

      pushShouldStripWhitespace(false);
    }
  }

  
  protected void ensureSizeOfIndex(int namespaceID, int LocalNameID)
  {

    if (null == m_elemIndexes)
    {
      m_elemIndexes = new int[namespaceID + 20][][];
    }
    else if (m_elemIndexes.length <= namespaceID)
    {
      int[][][] indexes = m_elemIndexes;

      m_elemIndexes = new int[namespaceID + 20][][];

      System.arraycopy(indexes, 0, m_elemIndexes, 0, indexes.length);
    }

    int[][] localNameIndex = m_elemIndexes[namespaceID];

    if (null == localNameIndex)
    {
      localNameIndex = new int[LocalNameID + 100][];
      m_elemIndexes[namespaceID] = localNameIndex;
    }
    else if (localNameIndex.length <= LocalNameID)
    {
      int[][] indexes = localNameIndex;

      localNameIndex = new int[LocalNameID + 100][];

      System.arraycopy(indexes, 0, localNameIndex, 0, indexes.length);

      m_elemIndexes[namespaceID] = localNameIndex;
    }

    int[] elemHandles = localNameIndex[LocalNameID];

    if (null == elemHandles)
    {
      elemHandles = new int[128];
      localNameIndex[LocalNameID] = elemHandles;
      elemHandles[0] = 1;
    }
    else if (elemHandles.length <= elemHandles[0] + 1)
    {
      int[] indexes = elemHandles;

      elemHandles = new int[elemHandles[0] + 1024];

      System.arraycopy(indexes, 0, elemHandles, 0, indexes.length);

      localNameIndex[LocalNameID] = elemHandles;
    }
  }

  
  protected void indexNode(int expandedTypeID, int identity)
  {

    ExpandedNameTable ent = m_expandedNameTable;
    short type = ent.getType(expandedTypeID);

    if (DTM.ELEMENT_NODE == type)
    {
      int namespaceID = ent.getNamespaceID(expandedTypeID);
      int localNameID = ent.getLocalNameID(expandedTypeID);

      ensureSizeOfIndex(namespaceID, localNameID);

      int[] index = m_elemIndexes[namespaceID][localNameID];

      index[index[0]] = identity;

      index[0]++;
    }
  }

  
  protected int findGTE(int[] list, int start, int len, int value)
  {

    int low = start;
    int high = start + (len - 1);
    int end = high;

    while (low <= high)
    {
      int mid = (low + high) / 2;
      int c = list[mid];

      if (c > value)
        high = mid - 1;
      else if (c < value)
        low = mid + 1;
      else
        return mid;
    }

    return (low <= end && list[low] > value) ? low : -1;
  }

  
  int findElementFromIndex(int nsIndex, int lnIndex, int firstPotential)
  {

    int[][][] indexes = m_elemIndexes;

    if (null != indexes && nsIndex < indexes.length)
    {
      int[][] lnIndexs = indexes[nsIndex];

      if (null != lnIndexs && lnIndex < lnIndexs.length)
      {
        int[] elems = lnIndexs[lnIndex];

        if (null != elems)
        {
          int pos = findGTE(elems, 1, elems[0], firstPotential);

          if (pos > -1)
          {
            return elems[pos];
          }
        }
      }
    }

    return NOTPROCESSED;
  }

  
  protected abstract int getNextNodeIdentity(int identity);

  
  protected abstract boolean nextNode();

  
  protected abstract int getNumberOfNodes();

  
  protected DTMAxisTraverser[] m_traversers;













  
  protected short _type(int identity)
  {

    int info = _exptype(identity);

    if (NULL != info)
      return m_expandedNameTable.getType(info);
    else
      return NULL;
  }

  
  protected int _exptype(int identity)
  {
    
    
    
    while (identity>=m_size)
    {
      if (!nextNode() && identity >= m_size)
        return NULL;
    }
    return m_exptype.elementAt(identity);

  }

  
  protected int _level(int identity)
  {
    while (identity>=m_size)
    {
      boolean isMore = nextNode();
      if (!isMore && identity >= m_size)
        return NULL;
    }

    int i=0;
    while(NULL != (identity=_parent(identity)))
      ++i;
    return i;
  }

  
  protected int _firstch(int identity)
  {

    
    int info = (identity >= m_size) ? NOTPROCESSED : m_firstch.elementAt(identity);

    
    
    
    while (info == NOTPROCESSED)
    {
      boolean isMore = nextNode();

      if (identity >= m_size &&!isMore)
        return NULL;
      else
      {
        info = m_firstch.elementAt(identity);
        if(info == NOTPROCESSED && !isMore)
          return NULL;
      }
    }

    return info;
  }

  
  protected int _nextsib(int identity)
  {

    
    int info = (identity >= m_size) ? NOTPROCESSED : m_nextsib.elementAt(identity);

    
    
    
    while (info == NOTPROCESSED)
    {
      boolean isMore = nextNode();

      if (identity >= m_size &&!isMore)
        return NULL;
      else
      {
        info = m_nextsib.elementAt(identity);
        if(info == NOTPROCESSED && !isMore)
          return NULL;
      }
    }

    return info;
  }

  
  protected int _prevsib(int identity)
  {

    if (identity < m_size)
      return m_prevsib.elementAt(identity);

    
    
    
    while (true)
    {
      boolean isMore = nextNode();

      if (identity >= m_size && !isMore)
        return NULL;
      else if (identity < m_size)
        return m_prevsib.elementAt(identity);
    }
  }

  
  protected int _parent(int identity)
  {

    if (identity < m_size)
      return m_parent.elementAt(identity);

    
    
    
    while (true)
    {
      boolean isMore = nextNode();

      if (identity >= m_size && !isMore)
        return NULL;
      else if (identity < m_size)
        return m_parent.elementAt(identity);
    }
  }

  
  public void dumpDTM(OutputStream os)
  {
    try
    {
      if(os==null)
      {
	      File f = new File(""DTMDump""+((Object)this).hashCode()+"".txt"");
 	      System.err.println(""Dumping... ""+f.getAbsolutePath());
 	      os=new FileOutputStream(f);
      }
      PrintStream ps = new PrintStream(os);

      while (nextNode()){}

      int nRecords = m_size;

      ps.println(""Total nodes: "" + nRecords);

      for (int index = 0; index < nRecords; ++index)
      {
      	int i=makeNodeHandle(index);
        ps.println(""=========== index="" + index + "" handle="" + i + "" ==========="");
        ps.println(""NodeName: "" + getNodeName(i));
        ps.println(""NodeNameX: "" + getNodeNameX(i));
        ps.println(""LocalName: "" + getLocalName(i));
        ps.println(""NamespaceURI: "" + getNamespaceURI(i));
        ps.println(""Prefix: "" + getPrefix(i));

        int exTypeID = _exptype(index);

        ps.println(""Expanded Type ID: ""
                           + Integer.toHexString(exTypeID));

        int type = _type(index);
        String typestring;

        switch (type)
        {
        case DTM.ATTRIBUTE_NODE :
          typestring = ""ATTRIBUTE_NODE"";
          break;
        case DTM.CDATA_SECTION_NODE :
          typestring = ""CDATA_SECTION_NODE"";
          break;
        case DTM.COMMENT_NODE :
          typestring = ""COMMENT_NODE"";
          break;
        case DTM.DOCUMENT_FRAGMENT_NODE :
          typestring = ""DOCUMENT_FRAGMENT_NODE"";
          break;
        case DTM.DOCUMENT_NODE :
          typestring = ""DOCUMENT_NODE"";
          break;
        case DTM.DOCUMENT_TYPE_NODE :
          typestring = ""DOCUMENT_NODE"";
          break;
        case DTM.ELEMENT_NODE :
          typestring = ""ELEMENT_NODE"";
          break;
        case DTM.ENTITY_NODE :
          typestring = ""ENTITY_NODE"";
          break;
        case DTM.ENTITY_REFERENCE_NODE :
          typestring = ""ENTITY_REFERENCE_NODE"";
          break;
        case DTM.NAMESPACE_NODE :
          typestring = ""NAMESPACE_NODE"";
          break;
        case DTM.NOTATION_NODE :
          typestring = ""NOTATION_NODE"";
          break;
        case DTM.NULL :
          typestring = ""NULL"";
          break;
        case DTM.PROCESSING_INSTRUCTION_NODE :
          typestring = ""PROCESSING_INSTRUCTION_NODE"";
          break;
        case DTM.TEXT_NODE :
          typestring = ""TEXT_NODE"";
          break;
        default :
          typestring = ""Unknown!"";
          break;
        }

        ps.println(""Type: "" + typestring);

        int firstChild = _firstch(index);

        if (DTM.NULL == firstChild)
          ps.println(""First child: DTM.NULL"");
        else if (NOTPROCESSED == firstChild)
          ps.println(""First child: NOTPROCESSED"");
        else
          ps.println(""First child: "" + firstChild);

        int prevSibling = _prevsib(index);

        if (DTM.NULL == prevSibling)
          ps.println(""Prev sibling: DTM.NULL"");
        else if (NOTPROCESSED == prevSibling)
          ps.println(""Prev sibling: NOTPROCESSED"");
        else
          ps.println(""Prev sibling: "" + prevSibling);

        int nextSibling = _nextsib(index);

        if (DTM.NULL == nextSibling)
          ps.println(""Next sibling: DTM.NULL"");
        else if (NOTPROCESSED == nextSibling)
          ps.println(""Next sibling: NOTPROCESSED"");
        else
          ps.println(""Next sibling: "" + nextSibling);

        int parent = _parent(index);

        if (DTM.NULL == parent)
          ps.println(""Parent: DTM.NULL"");
        else if (NOTPROCESSED == parent)
          ps.println(""Parent: NOTPROCESSED"");
        else
          ps.println(""Parent: "" + parent);

        int level = _level(index);

        ps.println(""Level: "" + level);
        ps.println(""Node Value: "" + getNodeValue(i));
        ps.println(""String Value: "" + getStringValue(i));
      }
    }
    catch(IOException ioe)
    {
      ioe.printStackTrace(System.err);
      System.exit(-1);
    }
  }
  
  
  public String dumpNode(int nodeHandle)
  {	  
	  if(nodeHandle==DTM.NULL)
		  return ""[null]"";
		  
        String typestring;
        switch (getNodeType(nodeHandle))
        {
        case DTM.ATTRIBUTE_NODE :
          typestring = ""ATTR"";
          break;
        case DTM.CDATA_SECTION_NODE :
          typestring = ""CDATA"";
          break;
        case DTM.COMMENT_NODE :
          typestring = ""COMMENT"";
          break;
        case DTM.DOCUMENT_FRAGMENT_NODE :
          typestring = ""DOC_FRAG"";
          break;
        case DTM.DOCUMENT_NODE :
          typestring = ""DOC"";
          break;
        case DTM.DOCUMENT_TYPE_NODE :
          typestring = ""DOC_TYPE"";
          break;
        case DTM.ELEMENT_NODE :
          typestring = ""ELEMENT"";
          break;
        case DTM.ENTITY_NODE :
          typestring = ""ENTITY"";
          break;
        case DTM.ENTITY_REFERENCE_NODE :
          typestring = ""ENT_REF"";
          break;
        case DTM.NAMESPACE_NODE :
          typestring = ""NAMESPACE"";
          break;
        case DTM.NOTATION_NODE :
          typestring = ""NOTATION"";
          break;
        case DTM.NULL :
          typestring = ""null"";
          break;
        case DTM.PROCESSING_INSTRUCTION_NODE :
          typestring = ""PI"";
          break;
        case DTM.TEXT_NODE :
          typestring = ""TEXT"";
          break;
        default :
          typestring = ""Unknown!"";
          break;
        }

      StringBuffer sb=new StringBuffer();
	  sb.append(""[""+nodeHandle+"": ""+typestring+
				""(0x""+Integer.toHexString(getExpandedTypeID(nodeHandle))+"") ""+
				getNodeNameX(nodeHandle)+"" {""+getNamespaceURI(nodeHandle)+""}""+
				""=""""+ getNodeValue(nodeHandle)+""""]"");
	  return sb.toString();
  }

  

  
  public void setFeature(String featureId, boolean state){}

  

  
  public boolean hasChildNodes(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int firstChild = _firstch(identity);

    return firstChild != DTM.NULL;
  }
	
  
  final protected int makeNodeHandle(int nodeIdentity)
  {
    if(NULL==nodeIdentity) return NULL;
		
    if(JJK_DEBUG && nodeIdentity>DTMManager.IDENT_NODE_DEFAULT)
      System.err.println(""GONK! (only useful in limited situations)"");

    return m_dtmIdent.elementAt(nodeIdentity >>> DTMManager.IDENT_DTM_NODE_BITS)
      + (nodeIdentity & DTMManager.IDENT_NODE_DEFAULT) ;											
  }
	
  
  final protected int makeNodeIdentity(int nodeHandle)
  {
    if(NULL==nodeHandle) return NULL;

    if(m_mgrDefault!=null)
    {
      
      
      

      int whichDTMindex=nodeHandle>>>DTMManager.IDENT_DTM_NODE_BITS;

      
      
      
      
      if(m_mgrDefault.m_dtms[whichDTMindex]!=this)
	return NULL;
      else
	return
	  m_mgrDefault.m_dtm_offsets[whichDTMindex]
	  | (nodeHandle & DTMManager.IDENT_NODE_DEFAULT);
    }
	  
    int whichDTMid=m_dtmIdent.indexOf(nodeHandle & DTMManager.IDENT_DTM_DEFAULT);
    return (whichDTMid==NULL) 
      ? NULL
      : (whichDTMid << DTMManager.IDENT_DTM_NODE_BITS)
      + (nodeHandle & DTMManager.IDENT_NODE_DEFAULT);
  }


  
  public int getFirstChild(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int firstChild = _firstch(identity);

    return makeNodeHandle(firstChild);
  }

  
  public int getLastChild(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int child = _firstch(identity);
    int lastChild = DTM.NULL;

    while (child != DTM.NULL)
    {
      lastChild = child;
      child = _nextsib(child);
    }

    return makeNodeHandle(lastChild);
  }

  
  public abstract int getAttributeNode(int nodeHandle, String namespaceURI,
                                       String name);

  
  public int getFirstAttribute(int nodeHandle)
  {

    int type = getNodeType(nodeHandle);

    if (DTM.ELEMENT_NODE == type)
    {

      
      int identity = makeNodeIdentity(nodeHandle);

      while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
      {

        
        type = _type(identity);

        if (type == DTM.ATTRIBUTE_NODE)
        {
          return makeNodeHandle(identity);
        }
        else if (DTM.NAMESPACE_NODE != type)
        {
          break;
        }
      }
    }

    return DTM.NULL;
  }

  
  public int getNextSibling(int nodeHandle)
  {
    return makeNodeHandle(_nextsib(makeNodeIdentity(nodeHandle)));
  }

  
  public int getPreviousSibling(int nodeHandle)
  {
    return makeNodeHandle(_prevsib(makeNodeIdentity(nodeHandle)));
  }

  
  public int getNextAttribute(int nodeHandle)
  {

    int type = getNodeType(nodeHandle);

    if (DTM.ATTRIBUTE_NODE == type)
    {
      
      int identity = makeNodeIdentity(nodeHandle);

      while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
      {
        type = _type(identity);

        if (type == DTM.ATTRIBUTE_NODE)
        {
          return makeNodeHandle(identity);
        }
        else if (type != DTM.NAMESPACE_NODE)
        {
          break;
        }
      }
    }

    return DTM.NULL;
  }

  
  private Vector m_namespaceLists = null;  


  
  protected void declareNamespaceInContext(int elementNodeIndex,int namespaceNodeIndex)
  {
    SuballocatedIntVector nsList=null;
    if(m_namespaceDeclSets==null)
      {

        
        m_namespaceDeclSetElements=new SuballocatedIntVector();
        m_namespaceDeclSetElements.addElement(elementNodeIndex);
        m_namespaceDeclSets=new Vector();
        nsList=new SuballocatedIntVector();
        m_namespaceDeclSets.addElement(nsList);
      }
    else
      {
        
        
        int last=m_namespaceDeclSetElements.size()-1;
	        
        if(last>=0 && elementNodeIndex==m_namespaceDeclSetElements.elementAt(last))
          {
            nsList=(SuballocatedIntVector)m_namespaceDeclSets.elementAt(last);
          }
      }
    if(nsList==null)
      {
        m_namespaceDeclSetElements.addElement(elementNodeIndex);
        nsList=new SuballocatedIntVector();
        m_namespaceDeclSets.addElement(nsList);

        SuballocatedIntVector inherited= findNamespaceContext(_parent(elementNodeIndex));

        if(inherited!=null)
          {
            
            
            
            int isize=inherited.size();
            for(int i=0;i<isize;++i)
              {
                nsList.addElement(inherited.elementAt(i));
              }
          }
      }

    
    
    
    
    int newEType=_exptype(namespaceNodeIndex);

    for(int i=nsList.size()-1;i>=0;--i)
      {
        if(newEType==getExpandedTypeID(nsList.elementAt(i)))
          {
            nsList.setElementAt(makeNodeHandle(namespaceNodeIndex),i);
            return;
          }
      }
    nsList.addElement(makeNodeHandle(namespaceNodeIndex));
  }

  
  protected SuballocatedIntVector findNamespaceContext(int elementNodeIndex)
  {
    if (null!=m_namespaceDeclSetElements)
      {
        
        
        int wouldBeAt=findInSortedSuballocatedIntVector(m_namespaceDeclSetElements,
                                            elementNodeIndex);
        if(wouldBeAt>=0) 
          return (SuballocatedIntVector) m_namespaceDeclSets.elementAt(wouldBeAt);
        if(wouldBeAt == -1) 
          return null; 

        
        
        wouldBeAt=-1-wouldBeAt;

        
        int candidate=m_namespaceDeclSetElements.elementAt(-- wouldBeAt);
        int ancestor=_parent(elementNodeIndex);
        while(wouldBeAt>=0 && ancestor>0)
          {
            candidate=m_namespaceDeclSetElements.elementAt(wouldBeAt);

            if(candidate==ancestor) 
                return (SuballocatedIntVector)m_namespaceDeclSets.elementAt(wouldBeAt);
            else if(candidate<ancestor) 
                ancestor=_parent(ancestor);
            else 
              --wouldBeAt;
          }
      }

    return null; 
  }

  
  protected int findInSortedSuballocatedIntVector(SuballocatedIntVector vector, int lookfor)
  {
    
    int i = 0;
    if(vector != null) {
      int first = 0;
      int last  = vector.size() - 1;

      while (first <= last) {
        i = (first + last) / 2;
        int test = lookfor-vector.elementAt(i);
        if(test == 0) {
          return i; 
        }
        else if (test < 0) {
          last = i - 1; 
        }
        else {
          first = i + 1; 
        }
      }

      if (first > i) {
        i = first; 
      }
    }

    return -1 - i; 
  }


  
  public int getFirstNamespaceNode(int nodeHandle, boolean inScope)
  {
        if(inScope)
        {
            SuballocatedIntVector nsContext=findNamespaceContext(makeNodeIdentity(nodeHandle));
            if(nsContext==null || nsContext.size()<1)
              return NULL;

            return nsContext.elementAt(0);
          }
        else
          {
            
            
            
            
            
            
            int identity = makeNodeIdentity(nodeHandle);
            while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
              {
                int type = _type(identity);
                if (type == DTM.NAMESPACE_NODE)
                    return makeNodeHandle(identity);
                else if (DTM.ATTRIBUTE_NODE != type)
                    break;
              }
            return NULL;
          }
  }

  
  public int getNextNamespaceNode(int baseHandle, int nodeHandle,
                                  boolean inScope)
  {
        if(inScope)
          {
            
            
            
            

                SuballocatedIntVector nsContext=findNamespaceContext(makeNodeIdentity(baseHandle));

            if(nsContext==null)
              return NULL;
            int i=1 + nsContext.indexOf(nodeHandle);
            if(i<=0 || i==nsContext.size())
              return NULL;

            return nsContext.elementAt(i);
          }
        else
          {
            
            int identity = makeNodeIdentity(nodeHandle);
            while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
              {
                int type = _type(identity);
                if (type == DTM.NAMESPACE_NODE)
                  {
                    return makeNodeHandle(identity);
                  }
                else if (type != DTM.ATTRIBUTE_NODE)
                  {
                    break;
                  }
              }
          }
     return DTM.NULL;
  }

  
  public int getParent(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);

    if (identity > 0)
      return makeNodeHandle(_parent(identity));
    else
      return DTM.NULL;
  }

  
  public int getDocument()
  {
    return m_dtmIdent.elementAt(0); 
  }

  
  public int getOwnerDocument(int nodeHandle)
  {

    if (DTM.DOCUMENT_NODE == getNodeType(nodeHandle))
  	    return DTM.NULL;

    return getDocumentRoot(nodeHandle);
  }

  
  public int getDocumentRoot(int nodeHandle)
  {
    return getDocument();
  }

  
  public abstract XMLString getStringValue(int nodeHandle);

  
  public int getStringValueChunkCount(int nodeHandle)
  {

    
    error(XSLMessages.createMessage(XSLTErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return 0;
  }

  
  public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
                                    int[] startAndLen)
  {

    
    error(XSLMessages.createMessage(XSLTErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return null;
  }

  
  public int getExpandedTypeID(int nodeHandle)
  {
    
    
    int id=makeNodeIdentity(nodeHandle);
    if(id==NULL)
      return NULL;
    return _exptype(id);
  }

  
  public int getExpandedTypeID(String namespace, String localName, int type)
  {

    ExpandedNameTable ent = m_expandedNameTable;

    return ent.getExpandedTypeID(namespace, localName, type);
  }

  
  public String getLocalNameFromExpandedNameID(int expandedNameID)
  {
    return m_expandedNameTable.getLocalName(expandedNameID);
  }

  
  public String getNamespaceFromExpandedNameID(int expandedNameID)
  {
    return m_expandedNameTable.getNamespace(expandedNameID);
  }

  
  public int getNamespaceType(final int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);
    int expandedNameID = _exptype(identity);

    return m_expandedNameTable.getNamespaceID(expandedNameID);
  }

  
  public abstract String getNodeName(int nodeHandle);

  
  public String getNodeNameX(int nodeHandle)
  {

    
    error(XSLMessages.createMessage(XSLTErrorResources.ER_METHOD_NOT_SUPPORTED, null));

    return null;
  }

  
  public abstract String getLocalName(int nodeHandle);

  
  public abstract String getPrefix(int nodeHandle);

  
  public abstract String getNamespaceURI(int nodeHandle);

  
  public abstract String getNodeValue(int nodeHandle);

  
  public short getNodeType(int nodeHandle)
  {
    return m_expandedNameTable.getType(_exptype(makeNodeIdentity(nodeHandle))); 
  }

  
  public short getLevel(int nodeHandle)
  {
    
    int identity = makeNodeIdentity(nodeHandle);
    return (short) (_level(identity) + 1);
  }

  

  
  public boolean isSupported(String feature, String version)
  {

    
    return false;
  }

  
  public String getDocumentBaseURI()
  {
    return m_documentBaseURI;
  }

  
  public void setDocumentBaseURI(String baseURI)
  {
    m_documentBaseURI = baseURI;
  }

  
  public String getDocumentSystemIdentifier(int nodeHandle)
  {

    
    return m_documentBaseURI;
  }

  
  public String getDocumentEncoding(int nodeHandle)
  {

    
    return ""UTF-8"";
  }

  
  public String getDocumentStandalone(int nodeHandle)
  {
    return null;
  }

  
  public String getDocumentVersion(int documentHandle)
  {
    return null;
  }

  
  public boolean getDocumentAllDeclarationsProcessed()
  {

    
    return true;
  }

  
  public abstract String getDocumentTypeDeclarationSystemIdentifier();

  
  public abstract String getDocumentTypeDeclarationPublicIdentifier();

  
  public abstract int getElementById(String elementId);

  
  public abstract String getUnparsedEntityURI(String name);

  

  
  public boolean supportsPreStripping()
  {
    return true;
  }

  
  public boolean isNodeAfter(int nodeHandle1, int nodeHandle2)
  {
		
    int index1 = makeNodeIdentity(nodeHandle1);
    int index2 = makeNodeIdentity(nodeHandle2);

    return index1!=NULL & index2!=NULL & index1 <= index2;
  }

  
  public boolean isCharacterElementContentWhitespace(int nodeHandle)
  {

    
    return false;
  }

  
  public boolean isDocumentAllDeclarationsProcessed(int documentHandle)
  {
    return true;
  }

  
  public abstract boolean isAttributeSpecified(int attributeHandle);

  

  
  public abstract void dispatchCharactersEvents(
    int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize)
      throws org.xml.sax.SAXException;

  
  public abstract void dispatchToEvents(
    int nodeHandle, org.xml.sax.ContentHandler ch)
      throws org.xml.sax.SAXException;

  
  public org.w3c.dom.Node getNode(int nodeHandle)
  {
    return new DTMNodeProxy(this, nodeHandle);
  }

  

  
  public void appendChild(int newChild, boolean clone, boolean cloneDepth)
  {
    error(XSLMessages.createMessage(XSLTErrorResources.ER_METHOD_NOT_SUPPORTED, null));
  }

  
  public void appendTextChild(String str)
  {
    error(XSLMessages.createMessage(XSLTErrorResources.ER_METHOD_NOT_SUPPORTED, null));
  }

  
  protected void error(String msg)
  {
    throw new DTMException(msg);
  }

  
  protected boolean getShouldStripWhitespace()
  {
    return m_shouldStripWS;
  }

  
  protected void pushShouldStripWhitespace(boolean shouldStrip)
  {

    m_shouldStripWS = shouldStrip;

    if (null != m_shouldStripWhitespaceStack)
      m_shouldStripWhitespaceStack.push(shouldStrip);
  }

  
  protected void popShouldStripWhitespace()
  {
    if (null != m_shouldStripWhitespaceStack)
      m_shouldStripWS = m_shouldStripWhitespaceStack.popAndTop();
  }

  
  protected void setShouldStripWhitespace(boolean shouldStrip)
  {

    m_shouldStripWS = shouldStrip;

    if (null != m_shouldStripWhitespaceStack)
      m_shouldStripWhitespaceStack.setTop(shouldStrip);
  }

  
   public void documentRegistration()
   {
   }

  
   public void documentRelease()
   {
   }

	 
	 public DTMManager getManager()
	 {
		 return m_mgr;
	 }

	 
	 public SuballocatedIntVector getDTMIDs()
	 {
		 if(m_mgr==null) return null;
		 return m_dtmIdent;
	 }
}
"
org.apache.xpath.axes.FilterExprIterator,14,6,0,15,32,0,1,15,11,0.730769231,163,1.0,2,0.914285714,0.234693878,4,8,10.35714286,3,1.2143,0,"package org.apache.xpath.axes;

import java.util.Vector;

import org.apache.xml.dtm.DTM;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XNodeSet;

public class FilterExprIterator extends BasicTestIterator
{
  
  private Expression m_expr;

  
  transient private XNodeSet m_exprObj;

  private boolean m_mustHardReset = false;
  private boolean m_canDetachNodeset = true;

  
  public FilterExprIterator()
  {
    super(null);
  }
  
  
  public FilterExprIterator(Expression expr)
  {
    super(null);
    m_expr = expr;
  }

  
  public void setRoot(int context, Object environment)
  {
  	super.setRoot(context, environment);
 	
  	m_exprObj = FilterExprIteratorSimple.executeFilterExpr(context, 
  	                  m_execContext, getPrefixResolver(), 
  	                  getIsTopLevel(), m_stackFrame, m_expr);
   }


  
  protected int getNextNode()
  {
    if (null != m_exprObj)
    {
      m_lastFetched = m_exprObj.nextNode();
    }
    else
      m_lastFetched = DTM.NULL;

    return m_lastFetched;
  }
  
  
  public void detach()
  {  
  	super.detach();
  	m_exprObj.detach();
  	m_exprObj = null;
  }

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    m_expr.fixupVariables(vars, globalsSize);
  }

  
  public Expression getInnerExpression()
  {
    return m_expr;
  }

  
  public void setInnerExpression(Expression expr)
  {
    expr.exprSetParent(this);
    m_expr = expr;
  }

  
  public int getAnalysisBits()
  {
    if (null != m_expr && m_expr instanceof PathComponent)
    {
      return ((PathComponent) m_expr).getAnalysisBits();
    }
    return WalkerFactory.BIT_FILTER;
  }

  
  public boolean isDocOrdered()
  {
    return m_exprObj.isDocOrdered();
  }

  class filterExprOwner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_expr;
    }

    
    public void setExpression(Expression exp)
    {
      exp.exprSetParent(FilterExprIterator.this);
      m_expr = exp;
    }

  }

  
  public void callPredicateVisitors(XPathVisitor visitor)
  {
    m_expr.callVisitors(new filterExprOwner(), visitor);

    super.callPredicateVisitors(visitor);
  }

  
  public boolean deepEquals(Expression expr)
  {
    if (!super.deepEquals(expr))
      return false;

    FilterExprIterator fet = (FilterExprIterator) expr;
    if (!m_expr.deepEquals(fet.m_expr))
      return false;

    return true;
  }

}"
org.apache.xalan.templates.FuncFormatNumb,5,6,0,16,36,10,1,15,4,2.0,186,0.0,0,0.941176471,0.5,2,8,36.2,1,0.8,0,"
package org.apache.xalan.templates;

import java.util.Vector;

import org.apache.xml.utils.QName;
import org.apache.xpath.functions.Function;
import org.apache.xpath.functions.Function3Args;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.XPath;
import org.apache.xpath.Expression;
import org.apache.xpath.functions.WrongNumberArgsException;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import org.w3c.dom.Node;

import javax.xml.transform.TransformerException;
import javax.xml.transform.ErrorListener;
import org.apache.xml.utils.SAXSourceLocator;


public class FuncFormatNumb extends Function3Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    
    ElemTemplateElement templElem =
      (ElemTemplateElement) xctxt.getNamespaceContext();
    StylesheetRoot ss = templElem.getStylesheetRoot();
    java.text.DecimalFormat formatter = null;
    java.text.DecimalFormatSymbols dfs = null;
    double num = getArg0().execute(xctxt).num();
    String patternStr = getArg1().execute(xctxt).str();

    
    if (patternStr.indexOf(0x00A4) > 0)
      ss.error(XSLTErrorResources.ER_CURRENCY_SIGN_ILLEGAL);  

    
    
    try
    {
      Expression arg2Expr = getArg2();

      if (null != arg2Expr)
      {
        String dfName = arg2Expr.execute(xctxt).str();
        QName qname = new QName(dfName, xctxt.getNamespaceContext());

        dfs = ss.getDecimalFormatComposed(qname);

        if (null == dfs)
        {
          warn(xctxt, XSLTErrorResources.WG_NO_DECIMALFORMAT_DECLARATION,
               new Object[]{ dfName });  

          
        }
        else
        {

          
          formatter = new java.text.DecimalFormat();

          formatter.setDecimalFormatSymbols(dfs);
          formatter.applyLocalizedPattern(patternStr);
        }
      }

      
      if (null == formatter)
      {

        
        if (ss.getDecimalFormatCount() > 0)
          dfs = ss.getDecimalFormatComposed(new QName(""""));

        if (dfs != null)
        {
          formatter = new java.text.DecimalFormat();

          formatter.setDecimalFormatSymbols(dfs);
          formatter.applyLocalizedPattern(patternStr);
        }
        else
        {
          dfs = new java.text.DecimalFormatSymbols(java.util.Locale.US);

          dfs.setInfinity(Constants.ATTRVAL_INFINITY);
          dfs.setNaN(Constants.ATTRVAL_NAN);

          formatter = new java.text.DecimalFormat();

          formatter.setDecimalFormatSymbols(dfs);

          if (null != patternStr)
            formatter.applyLocalizedPattern(patternStr);
        }
      }

      return new XString(formatter.format(num));
    }
    catch (Exception iae)
    {
      templElem.error(XSLTErrorResources.ER_MALFORMED_FORMAT_STRING,
                      new Object[]{ patternStr });

      return XString.EMPTYSTRING;

      
    }
  }

  
  public void warn(XPathContext xctxt, int msg, Object args[])
          throws javax.xml.transform.TransformerException
  {

    String formattedMsg = XSLMessages.createWarning(msg, args);
    ErrorListener errHandler = xctxt.getErrorListener();

    errHandler.warning(new TransformerException(formattedMsg,
                                             (SAXSourceLocator)xctxt.getSAXLocator()));
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if ((argNum > 3) || (argNum < 2))
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createMessage(XSLTErrorResources.ER_TWO_OR_THREE, null)); 
  }
}
"
org.apache.xalan.lib.sql.SQLDocument,10,5,0,8,53,0,1,7,5,0.883141762,1073,1.0,1,0.954545455,0.211111111,2,8,100.5,11,3.4,2,"

package org.apache.xalan.lib.sql;

import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTM;
import java.sql.Connection;
import java.sql.Statement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.*;
import org.apache.xml.dtm.ref.*;


public class SQLDocument extends DTMDocument
{

  
  private boolean DEBUG = false;

  
  private static final String S_NAMESPACE = ""http:


  
  private static final String S_SQL = ""sql"";

  
  private static final String S_ROW_SET = ""row-set"";

  
  private static final String S_METADATA = ""metadata"";

  
  private static final String S_COLUMN_HEADER = ""column-header"";

  
  private static final String S_ROW = ""row"";

  
  private static final String S_COL = ""col"";

  
  private static final String S_CATALOGUE_NAME = ""catalogue-name"";
  
  private static final String S_DISPLAY_SIZE = ""column-display-size"";
  
  private static final String S_COLUMN_LABEL = ""column-label"";
  
  private static final String S_COLUMN_NAME = ""column-name"";
  
  private static final String S_COLUMN_TYPE = ""column-type"";
  
  private static final String S_COLUMN_TYPENAME = ""column-typename"";
  
  private static final String S_PRECISION = ""precision"";
  
  private static final String S_SCALE = ""scale"";
  
  private static final String S_SCHEMA_NAME = ""schema-name"";
  
  private static final String S_TABLE_NAME = ""table-name"";
  
  private static final String S_CASESENSITIVE = ""case-sensitive"";
  
  private static final String S_DEFINITLEYWRITABLE = ""definitley-writable"";
  
  private static final String S_ISNULLABLE = ""nullable"";
  
  private static final String S_ISSIGNED = ""signed"";
  
  private static final String S_ISWRITEABLE = ""writable"";
  
  private static final String S_ISSEARCHABLE = ""searchable"";

  
  private int m_SQL_TypeID = 0;
  
  private int m_MetaData_TypeID = 0;
  
  private int m_ColumnHeader_TypeID = 0;
  
  private int m_RowSet_TypeID = 0;
  
  private int m_Row_TypeID = 0;
  
  private int m_Col_TypeID = 0;

  
  private int m_ColAttrib_CATALOGUE_NAME_TypeID = 0;
  
  private int m_ColAttrib_DISPLAY_SIZE_TypeID = 0;
  
  private int m_ColAttrib_COLUMN_LABEL_TypeID = 0;
  
  private int m_ColAttrib_COLUMN_NAME_TypeID = 0;
  
  private int m_ColAttrib_COLUMN_TYPE_TypeID = 0;
  
  private int m_ColAttrib_COLUMN_TYPENAME_TypeID = 0;
  
  private int m_ColAttrib_PRECISION_TypeID = 0;
  
  private int m_ColAttrib_SCALE_TypeID = 0;
  
  private int m_ColAttrib_SCHEMA_NAME_TypeID = 0;
  
  private int m_ColAttrib_TABLE_NAME_TypeID = 0;
  
  private int m_ColAttrib_CASESENSITIVE_TypeID = 0;
  
  private int m_ColAttrib_DEFINITLEYWRITEABLE_TypeID = 0;
  
  private int m_ColAttrib_ISNULLABLE_TypeID = 0;
  
  private int m_ColAttrib_ISSIGNED_TypeID = 0;
  
  private int m_ColAttrib_ISWRITEABLE_TypeID = 0;
  
  private int m_ColAttrib_ISSEARCHABLE_TypeID = 0;

  
  private Connection m_Connection = null;

  
  private Statement m_Statement = null;

  
  private ResultSet m_ResultSet = null;

  
  private ConnectionPool m_ConnectionPool = null;


  
  private int[] m_ColHeadersIdx;

  
  private int m_ColCount;

  
  private int m_MetaDataIdx = DTM.NULL;

  
  private int m_RowSetIdx = DTM.NULL;

  
  private int m_SQLIdx = DTM.NULL;

  
  private int m_FirstRowIdx = DTM.NULL;

  
  private int m_LastRowIdx = DTM.NULL;

  
  private boolean m_StreamingMode = true;

  
  public SQLDocument( DTMManager mgr, int ident, ConnectionPool pool, Connection con, Statement stmt, ResultSet data, boolean streamingMode )throws SQLException
  {
    super(mgr, ident);

    m_Connection = con;
    m_Statement  = stmt;
    m_ResultSet  = data;
    m_ConnectionPool = pool;
    m_StreamingMode = streamingMode;

    createExpandedNameTable();
    extractSQLMetaData(m_ResultSet.getMetaData());

    
    
    
    
    addRowToDTMFromResultSet();




  }


  
  private void extractSQLMetaData( ResultSetMetaData meta )
  {
    
    
    

    
    m_DocumentIdx = addElement(0, m_Document_TypeID, DTM.NULL, DTM.NULL);

    
    m_SQLIdx = addElement(1, m_SQL_TypeID,  m_DocumentIdx, DTM.NULL);

    
    m_MetaDataIdx = addElement(1, m_MetaData_TypeID,  m_SQLIdx, DTM.NULL);

    try
    {
      m_ColCount = meta.getColumnCount();
      m_ColHeadersIdx = new int[m_ColCount];
    }
    catch(Exception e)
    {
      error(""ERROR Extracting Metadata"");
    }

    
    
    int lastColHeaderIdx = DTM.NULL;

    
    int i = 1;
    for (i=1; i<= m_ColCount; i++)
    {
      m_ColHeadersIdx[i-1] =
        addElement(2,m_ColumnHeader_TypeID, m_MetaDataIdx, lastColHeaderIdx);

      lastColHeaderIdx = m_ColHeadersIdx[i-1];
      

      try
      {
        addAttributeToNode(
          meta.getColumnName(i),
          m_ColAttrib_COLUMN_NAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_COLUMN_NAME_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.getColumnLabel(i),
          m_ColAttrib_COLUMN_LABEL_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_COLUMN_LABEL_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.getCatalogName(i),
          m_ColAttrib_CATALOGUE_NAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_CATALOGUE_NAME_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          new Integer(meta.getColumnDisplaySize(i)),
          m_ColAttrib_DISPLAY_SIZE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_DISPLAY_SIZE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          new Integer(meta.getColumnType(i)),
          m_ColAttrib_COLUMN_TYPE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_COLUMN_TYPE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.getColumnTypeName(i),
          m_ColAttrib_COLUMN_TYPENAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_COLUMN_TYPENAME_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          new Integer(meta.getPrecision(i)),
          m_ColAttrib_PRECISION_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_PRECISION_TypeID, lastColHeaderIdx);
      }
      try
      {
        addAttributeToNode(
          new Integer(meta.getScale(i)),
          m_ColAttrib_SCALE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_SCALE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.getSchemaName(i),
          m_ColAttrib_SCHEMA_NAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_SCHEMA_NAME_TypeID, lastColHeaderIdx);
      }
      try
      {
        addAttributeToNode(
          meta.getTableName(i),
          m_ColAttrib_TABLE_NAME_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_TABLE_NAME_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isCaseSensitive(i) ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_CASESENSITIVE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_CASESENSITIVE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isDefinitelyWritable(i) ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_DEFINITLEYWRITEABLE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_DEFINITLEYWRITEABLE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isNullable(i) != 0 ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_ISNULLABLE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_ISNULLABLE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isSigned(i) ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_ISSIGNED_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_ISSIGNED_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isWritable(i) == true ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_ISWRITEABLE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_ISWRITEABLE_TypeID, lastColHeaderIdx);
      }

      try
      {
        addAttributeToNode(
          meta.isSearchable(i) == true ? S_ISTRUE : S_ISFALSE,
          m_ColAttrib_ISSEARCHABLE_TypeID, lastColHeaderIdx);
      }
      catch(Exception e)
      {
        addAttributeToNode(
          S_ATTRIB_NOT_SUPPORTED,
          m_ColAttrib_ISSEARCHABLE_TypeID, lastColHeaderIdx);
      }

    }

  }

  
  protected void createExpandedNameTable( )
  {
    super.createExpandedNameTable();

    m_SQL_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SQL, DTM.ELEMENT_NODE);

    m_MetaData_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_METADATA, DTM.ELEMENT_NODE);

    m_ColumnHeader_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_HEADER, DTM.ELEMENT_NODE);
    m_RowSet_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ROW_SET, DTM.ELEMENT_NODE);
    m_Row_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ROW, DTM.ELEMENT_NODE);
    m_Col_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COL, DTM.ELEMENT_NODE);


    m_ColAttrib_CATALOGUE_NAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_CATALOGUE_NAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_DISPLAY_SIZE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_DISPLAY_SIZE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_COLUMN_LABEL_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_LABEL, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_COLUMN_NAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_NAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_COLUMN_TYPE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_TYPE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_COLUMN_TYPENAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_COLUMN_TYPENAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_PRECISION_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_PRECISION, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_SCALE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SCALE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_SCHEMA_NAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_SCHEMA_NAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_TABLE_NAME_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_TABLE_NAME, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_CASESENSITIVE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_CASESENSITIVE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_DEFINITLEYWRITEABLE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_DEFINITLEYWRITABLE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_ISNULLABLE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISNULLABLE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_ISSIGNED_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISSIGNED, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_ISWRITEABLE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISWRITEABLE, DTM.ATTRIBUTE_NODE);
    m_ColAttrib_ISSEARCHABLE_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_ISSEARCHABLE, DTM.ATTRIBUTE_NODE);
  }


  
  private boolean addRowToDTMFromResultSet( )
  {
    try
    {


      
      
      if (m_RowSetIdx == DTM.NULL)
      {
        m_RowSetIdx = addElement(1, m_RowSet_TypeID,  m_SQLIdx, m_MetaDataIdx);
      }

      
      
      if ( ! m_ResultSet.next())
      {
        
        
        
        

        if (m_StreamingMode)
        {
          
          m_nextsib.setElementAt(DTM.NULL, m_LastRowIdx);
        }

        return false;
      }

      
      if (m_FirstRowIdx == DTM.NULL)
      {
        m_FirstRowIdx =
          addElement(2, m_Row_TypeID, m_RowSetIdx, DTM.NULL);
        m_LastRowIdx = m_FirstRowIdx;

        if (m_StreamingMode)
        {
          
          m_nextsib.setElementAt(m_LastRowIdx, m_LastRowIdx);
        }

      }
      else
      {
        
        
        if (! m_StreamingMode)
        {
          m_LastRowIdx = addElement(3, m_Row_TypeID, m_RowSetIdx, m_LastRowIdx);
        }
      }

      
      
      int colID = _firstch(m_LastRowIdx);

      
      int pcolID = DTM.NULL;

      
      for (int i=1; i<= m_ColCount; i++)
      {
        
        
        Object o = m_ResultSet.getObject(i);

        
        
        
        if (colID == DTM.NULL)
        {
          pcolID = addElementWithData(o,3,m_Col_TypeID, m_LastRowIdx, pcolID);
          cloneAttributeFromNode(pcolID, m_ColHeadersIdx[i-1]);
        }
        else
        {
          
          
          int dataIdent = _firstch(colID);
          if (dataIdent == DTM.NULL)
          {
            error(""Streaming Mode, Data Error"");
          }
          else
          {
            m_ObjectArray.setAt(dataIdent, o);
          }
        } 

        
        
        
        if (colID != DTM.NULL)
        {
          colID = _nextsib(colID);
        }

      } 
    }
    catch(Exception e)
    {
      if (DEBUG)
      {
        System.out.println(
          ""SQL Error Fetching next row ["" + e.getLocalizedMessage() + ""]"");
      }

      error(""SQL Error Fetching next row ["" + e.getLocalizedMessage() + ""]"");
    }

    
    return true;
  }


  
  public void close( )
  {
    if (DEBUG) System.out.println(""close()"");

    try { if (null != m_ResultSet) m_ResultSet.close(); }
    catch(Exception e) { }
    try { if (null != m_Statement) m_Statement.close(); }
    catch(Exception e) { }
    try {
      if (null != m_Connection)
        m_ConnectionPool.releaseConnection(m_Connection);
    } catch(Exception e) { }
  }

  
  public void closeOnError( )
  {
    if (DEBUG) System.out.println(""close()"");

    try  { if (null != m_ResultSet) m_ResultSet.close();   }
    catch(Exception e) { }
    try  { if (null != m_Statement) m_Statement.close();
    } catch(Exception e) { }
    try {
      if (null != m_Connection)
        m_ConnectionPool.releaseConnectionOnError(m_Connection);
    } catch(Exception e) { }
  }



  
  protected boolean nextNode( )
  {
    if (DEBUG) System.out.println(""nextNode()"");
    try
    {
      return false;

    }
    catch(Exception e)
    {
      return false;
    }
  }

  
  protected int _nextsib( int identity )
  {
    
    
    
    

    int id = _exptype(identity);
    if (
      ( id == m_Row_TypeID) &&
      (identity >= m_LastRowIdx))
    {
      if (DEBUG) System.out.println(""reading from the ResultSet"");
      addRowToDTMFromResultSet();
    }

    return super._nextsib(identity);
  }

  public void documentRegistration()
  {
    if (DEBUG) System.out.println(""Document Registration"");
  }

  public void documentRelease()
  {
    if (DEBUG) System.out.println(""Document Release"");
  }


}
"
org.apache.xalan.client.XSLTProcessorApplet,29,5,0,2,73,300,1,2,21,0.879251701,782,0.857142857,1,0.94214876,0.344827586,3,5,25.24137931,10,1.5172,0,"
package org.apache.xalan.client;

import java.applet.Applet;

import java.awt.Graphics;

import java.net.URL;
import java.net.MalformedURLException;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.StringReader;
import java.io.IOException;
import java.io.InputStream;

import java.util.Properties;


import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


import javax.xml.transform.Result;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.Templates;
import javax.xml.transform.Source;
import javax.xml.transform.Result;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;


public class XSLTProcessorApplet extends Applet
{

  
  TransformerFactory m_tfactory = null;

  
  private String m_styleURL;

  
  private String m_documentURL;

  
  
  

  
  private final String PARAM_styleURL = ""styleURL"";

  
  private final String PARAM_documentURL = ""documentURL"";


  
  

  
  private String m_styleURLOfCached = null;

  
  private String m_documentURLOfCached = null;

  
  private URL m_codeBase = null;
  
  
  private String m_treeURL = null;

  
  private URL m_documentBase = null;

  
  transient private Thread m_callThread = null;

  
  transient private TrustedAgent m_trustedAgent = null;

  
  transient private Thread m_trustedWorker = null;

  
  transient private String m_htmlText = null;
  
  
  transient private String m_sourceText = null;
  
  
  transient private String m_nameOfIDAttrOfElemToModify = null;

  
  transient private String m_elemIdToModify = null;

  
  transient private String m_attrNameToSet = null;

  
  transient private String m_attrValueToSet = null;

  
  public XSLTProcessorApplet(){}

  
  public String getAppletInfo()
  {
    return ""Name: XSLTProcessorApplet
"" + ""Author: Scott Boag"";
  }

  
  public String[][] getParameterInfo()
  {

    String[][] info =
    {
      { PARAM_styleURL, ""String"", ""URL to an XSL stylesheet"" },
      { PARAM_documentURL, ""String"", ""URL to an XML document"" },
    };

    return info;
  }

  
  public void init()
  {

    
    
    
    
    
    String param;

    
    
    param = getParameter(PARAM_styleURL);

    if (param != null)
      setStyleURL(param);

    
    
    param = getParameter(PARAM_documentURL);

    if (param != null)
      setDocumentURL(param);

    m_codeBase = this.getCodeBase();
    m_documentBase = this.getDocumentBase();

    
    
    
    
    
    
    resize(320, 240);
  }
  
    
  public void start()
  {

    m_trustedAgent = new TrustedAgent();
    Thread currentThread = Thread.currentThread();
    m_trustedWorker = new Thread(currentThread.getThreadGroup(),
                                 m_trustedAgent);
    m_trustedWorker.start();
    try
    {
      m_tfactory = TransformerFactory.newInstance();
      this.showStatus(""Causing Transformer and Parser to Load and JIT..."");

      
      StringReader xmlbuf = new StringReader(""<?xml version='1.0'?><foo/>"");
      StringReader xslbuf = new StringReader(
        ""<?xml version='1.0'?><xsl:stylesheet xmlns:xsl='http:
      PrintWriter pw = new PrintWriter(new StringWriter());

      synchronized (m_tfactory)
      {
        Templates templates = m_tfactory.newTemplates(new StreamSource(xslbuf));
        Transformer transformer = templates.newTransformer();
        transformer.transform(new StreamSource(xmlbuf), new StreamResult(pw));
      }
      System.out.println(""Primed the pump!"");
      this.showStatus(""Ready to go!"");
    }
    catch (Exception e)
    {
      this.showStatus(""Could not prime the pump!"");
      System.out.println(""Could not prime the pump!"");
      e.printStackTrace();
    }
  }

  
  public void paint(Graphics g){}  
  
  
  public void stop()
  {
    if (null != m_trustedWorker)
    {
      m_trustedWorker.stop();

      
      m_trustedWorker = null;
    }

    m_styleURLOfCached = null;
    m_documentURLOfCached = null;
  }   
  
  
  public void destroy()
  {
    if (null != m_trustedWorker)
    {
      m_trustedWorker.stop();

      
      m_trustedWorker = null;
    }
    m_styleURLOfCached = null;
    m_documentURLOfCached = null;
  }

  
  public void setStyleURL(String urlString)
  {
    m_styleURL = urlString;
  }

  
  public void setDocumentURL(String urlString)
  {
    m_documentURL = urlString;
  }

  
  public void freeCache()
  {
    m_styleURLOfCached = null;
    m_documentURLOfCached = null;
  }

  
  public void setStyleSheetAttribute(String nameOfIDAttrOfElemToModify,
                                     String elemId, String attrName,
                                     String value)
  {
    m_nameOfIDAttrOfElemToModify = nameOfIDAttrOfElemToModify;
    m_elemIdToModify = elemId;
    m_attrNameToSet = attrName;
    m_attrValueToSet = value;
  }

  
  transient String m_key;

  
  transient String m_expression;

  
  public void setStylesheetParam(String key, String expr)
  {
    m_key = key;
    m_expression = expr;
  }

  
  public String escapeString(String s)
  {
    StringBuffer sb = new StringBuffer();
    int length = s.length();

    for (int i = 0; i < length; i++)
    {
      char ch = s.charAt(i);

      if ('<' == ch)
      {
        sb.append(""&lt;"");
      }
      else if ('>' == ch)
      {
        sb.append(""&gt;"");
      }
      else if ('&' == ch)
      {
        sb.append(""&amp;"");
      }
      else if (0xd800 <= ch && ch < 0xdc00)
      {
        
        int next;

        if (i + 1 >= length)
        {
          throw new RuntimeException(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_INVALID_UTF16_SURROGATE,
              new Object[]{ Integer.toHexString(ch) }));  

          
        }
        else
        {
          next = s.charAt(++i);

          if (!(0xdc00 <= next && next < 0xe000))
            throw new RuntimeException(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_INVALID_UTF16_SURROGATE,
                new Object[]{
                  Integer.toHexString(ch) + "" ""
                  + Integer.toHexString(next) }));  

          
          next = ((ch - 0xd800) << 10) + next - 0xdc00 + 0x00010000;
        }
        sb.append(""&#x"");
        sb.append(Integer.toHexString(next));
        sb.append("";"");
      }
      else
      {
        sb.append(ch);
      }
    }
    return sb.toString();
  }

  
  public String getHtmlText()
  {
    m_trustedAgent.m_getData = true;
    m_callThread = Thread.currentThread();
    try
    {
      synchronized (m_callThread)
      {
        m_callThread.wait();
      }
    }
    catch (InterruptedException ie)
    {
      System.out.println(ie.getMessage());
    }
    return m_htmlText;
  }

  
  public String getTreeAsText(String treeURL) throws IOException
  {
    m_treeURL = treeURL;
    m_trustedAgent.m_getData = true;
    m_trustedAgent.m_getSource = true;
    m_callThread = Thread.currentThread();
    try
    {
      synchronized (m_callThread)
      {
        m_callThread.wait();
      }
    }
    catch (InterruptedException ie)
    {
      System.out.println(ie.getMessage());
    }
    return m_sourceText;
  }
  
  
  private String getSource() throws TransformerException
  {
    StringWriter osw = new StringWriter();
    PrintWriter pw = new PrintWriter(osw, false);
    String text = """";
    try
    {
      URL docURL = new URL(m_documentBase, m_treeURL);
      synchronized (m_tfactory)
      {
        Transformer transformer = m_tfactory.newTransformer();
        StreamSource source = new StreamSource(docURL.toString());    
        StreamResult result = new StreamResult(pw);
        transformer.transform(source, result);
        text = osw.toString();
      }
    }
    catch (MalformedURLException e)
    {
      e.printStackTrace();
      System.exit(-1);
    }      
    catch (Exception any_error)
    {
      any_error.printStackTrace();
    }
    return text;
  }

  
  public String getSourceTreeAsText() throws Exception
  {
    return getTreeAsText(m_documentURL);
  }

  
  public String getStyleTreeAsText() throws Exception
  {
    return getTreeAsText(m_styleURL);
  }

  
  public String getResultTreeAsText() throws Exception
  {
    return escapeString(getHtmlText());
  }

  
  public String transformToHtml(String doc, String style)
  {

    if (null != doc)
    {
      m_documentURL = doc;
    }

    if (null != style)
    {
      m_styleURL = style;
    }

    return getHtmlText();
  }

  
  public String transformToHtml(String doc)
  {

    if (null != doc)
    {
      m_documentURL = doc;
    }

    m_styleURL = null;

    return getHtmlText();
  }


  
  private String processTransformation() throws TransformerException
  {
    String htmlData = null;
    this.showStatus(""Waiting for Transformer and Parser to finish loading and JITing..."");
    
    synchronized (m_tfactory)
    {
     URL documentURL = null;
      URL styleURL = null;
      StringWriter osw = new StringWriter();
      PrintWriter pw = new PrintWriter(osw, false);
      StreamResult result = new StreamResult(pw);
    
      this.showStatus(""Begin Transformation..."");
      try
      {
        documentURL = new URL(m_codeBase, m_documentURL);
        StreamSource xmlSource = new StreamSource(documentURL.toString());

        styleURL = new URL(m_codeBase, m_styleURL);
        StreamSource xslSource = new StreamSource(styleURL.toString());

        Transformer transformer = m_tfactory.newTransformer(xslSource);

        if (null != m_key)
          transformer.setParameter(m_key, m_expression);
      
         transformer.transform(xmlSource, result);
      }
      catch (TransformerConfigurationException tfe)
      {
        tfe.printStackTrace();
        System.exit(-1);
      }
      catch (MalformedURLException e)
      {
        e.printStackTrace();
        System.exit(-1);
      }
	  
      this.showStatus(""Transformation Done!"");
      htmlData = osw.toString();
    }
    return htmlData;
  }

  
  class TrustedAgent implements Runnable
  {

    
    public boolean m_getData = false;

    
    public boolean m_getSource = false;

    
    public void run()
    {
      while (true)
      {
        m_trustedWorker.yield();

        if (m_getData)  
        {
          try
          {
            m_getData = false;
            m_htmlText = null;
            m_sourceText = null;
            if (m_getSource)  
            {
              m_getSource = false;
              m_sourceText = getSource();
            }
            else              
              m_htmlText = processTransformation();
          }
          catch (Exception e)
          {
            e.printStackTrace();
          }
          finally
          {
            synchronized (m_callThread)
            {
              m_callThread.notify();
            }
          }
        }
        else
        {
          try
          {
            m_trustedWorker.sleep(50);
          }
          catch (InterruptedException ie)
          {
            ie.printStackTrace();
          }
        }
      }
    }
  }
}
"
org.apache.xalan.xslt.Process,4,1,0,8,96,6,0,8,2,2.0,1490,0.0,0,0.0,0.25,0,0,371.5,86,22.0,1,"
package org.apache.xalan.xslt;

import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.io.StringReader;
import java.util.Properties;
import java.util.ResourceBundle;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.FactoryConfigurationError;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Source;
import javax.xml.transform.Templates;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.TransformerFactoryConfigurationError;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.sax.SAXTransformerFactory;
import javax.xml.transform.sax.TransformerHandler;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;
import org.apache.xalan.processor.TransformerFactoryImpl;
import org.apache.xalan.processor.XSLProcessorVersion;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.trace.PrintTraceListener;
import org.apache.xalan.trace.TraceManager;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.XalanProperties;
import org.apache.xml.utils.DefaultErrorHandler;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xml.utils.res.XResourceBundle;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.Node;
import org.xml.sax.ContentHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ErrorHandler;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.XMLReader;
import org.xml.sax.helpers.XMLReaderFactory;


public class Process
{

  
  protected static void printArgOptions(ResourceBundle resbundle)
  {

    System.out.println(resbundle.getString(""xslProc_option""));  
    System.out.println(resbundle.getString(""optionIN""));  
    System.out.println(resbundle.getString(""optionXSL""));  
    System.out.println(resbundle.getString(""optionOUT""));  

    
    System.out.println(resbundle.getString(""optionV""));  
    System.out.println(resbundle.getString(""optionQC""));  

    
    System.out.println(resbundle.getString(""optionTT""));  
    System.out.println(resbundle.getString(""optionTG""));  
    System.out.println(resbundle.getString(""optionTS""));  
    System.out.println(resbundle.getString(""optionTTC""));  
    System.out.println(resbundle.getString(""optionTCLASS""));  

    
    System.out.println(resbundle.getString(""optionEDUMP""));  
    System.out.println(resbundle.getString(""optionXML""));  
    System.out.println(resbundle.getString(""optionTEXT""));  
    System.out.println(resbundle.getString(""optionHTML""));  
    System.out.println(resbundle.getString(""optionPARAM""));  
    System.out.println(resbundle.getString(""optionLINENUMBERS"")); 
    
    System.out.println(resbundle.getString(""optionMEDIA""));
    System.out.println(resbundle.getString(""optionFLAVOR""));
    System.out.println(resbundle.getString(""optionDIAG""));
    System.out.println(resbundle.getString(""optionURIRESOLVER""));  
    System.out.println(resbundle.getString(""optionENTITYRESOLVER""));  
    System.out.println(resbundle.getString(""optionCONTENTHANDLER""));  
    System.out.println(resbundle.getString(""optionINCREMENTAL""));
    System.out.println(resbundle.getString(""optionNOOPTIMIMIZE""));
    System.out.println(resbundle.getString(""optionRL""));
  }
  
  
  public static void main(String argv[])
  {
    
    
    boolean doStackDumpOnError = false;
    boolean setQuietMode = false;
    boolean doDiag = false;

    
    

    
    java.io.PrintWriter diagnosticsWriter = new PrintWriter(System.err, true);
    java.io.PrintWriter dumpWriter = diagnosticsWriter;
    ResourceBundle resbundle =
      (XSLMessages.loadResourceBundle(
        org.apache.xml.utils.res.XResourceBundle.ERROR_RESOURCES));
    String flavor = ""s2s"";

    if (argv.length < 1)
    {
      printArgOptions(resbundle);
    }
    else
    {
      TransformerFactory tfactory;

      try
      {
        tfactory = TransformerFactory.newInstance();
      }
      catch (TransformerFactoryConfigurationError pfe)
      {
        pfe.printStackTrace(dumpWriter);
        diagnosticsWriter.println(
          XSLMessages.createMessage(
            XSLTErrorResources.ER_NOT_SUCCESSFUL, null));  

        tfactory = null;  

        doExit(-1);
      }

      boolean formatOutput = false;
      boolean useSourceLocation = false;
      String inFileName = null;
      String outFileName = null;
      String dumpFileName = null;
      String xslFileName = null;
      String treedumpFileName = null;
      PrintTraceListener tracer = null;
      String outputType = null;
      String media = null;
      Vector params = new Vector();
      boolean quietConflictWarnings = false;
      URIResolver uriResolver = null;
      EntityResolver entityResolver = null;
      ContentHandler contentHandler = null;
      int recursionLimit=-1;

      for (int i = 0; i < argv.length; i++)
      {
        if (""-TT"".equalsIgnoreCase(argv[i]))
        {
          if (null == tracer)
            tracer = new PrintTraceListener(diagnosticsWriter);

          tracer.m_traceTemplates = true;

          
        }
        else if (""-TG"".equalsIgnoreCase(argv[i]))
        {
          if (null == tracer)
            tracer = new PrintTraceListener(diagnosticsWriter);

          tracer.m_traceGeneration = true;

          
        }
        else if (""-TS"".equalsIgnoreCase(argv[i]))
        {
          if (null == tracer)
            tracer = new PrintTraceListener(diagnosticsWriter);

          tracer.m_traceSelection = true;

          
        }
        else if (""-TTC"".equalsIgnoreCase(argv[i]))
        {
          if (null == tracer)
            tracer = new PrintTraceListener(diagnosticsWriter);

          tracer.m_traceElements = true;

          
        }
        else if (""-INDENT"".equalsIgnoreCase(argv[i]))
        {
          int indentAmount;

          if (((i + 1) < argv.length) && (argv[i + 1].charAt(0) != '-'))
          {
            indentAmount = Integer.parseInt(argv[++i]);
          }
          else
          {
            indentAmount = 0;
          }

          
          
        }
        else if (""-IN"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
            inFileName = argv[++i];
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-IN"" }));  
        }
        else if (""-MEDIA"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
            media = argv[++i];
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-MEDIA"" }));  
        }
        else if (""-OUT"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
            outFileName = argv[++i];
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-OUT"" }));  
        }
        else if (""-XSL"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
            xslFileName = argv[++i];
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-XSL"" }));  
        }
        else if (""-FLAVOR"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
          {
            flavor = argv[++i];
          }
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-FLAVOR"" }));  
        }
        else if (""-PARAM"".equalsIgnoreCase(argv[i]))
        {
          if (i + 2 < argv.length)
          {
            String name = argv[++i];

            params.addElement(name);

            String expression = argv[++i];

            params.addElement(expression);
          }
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-PARAM"" }));  
        }
        else if (""-TREEDUMP"".equalsIgnoreCase(argv[i]))  
        {
          if (i + 1 < argv.length)
            treedumpFileName = argv[++i];
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-treedump"" }));  
        }
        else if (""-F"".equalsIgnoreCase(argv[i]))  
        {
          formatOutput = true;
        }
        else if (""-E"".equalsIgnoreCase(argv[i]))
        {

          
          
        }
        else if (""-V"".equalsIgnoreCase(argv[i]))
        {
          diagnosticsWriter.println(resbundle.getString(""version"")  
                                    + XSLProcessorVersion.S_VERSION + "", "" +

          
          resbundle.getString(""version2""));  
        }
        else if (""-QC"".equalsIgnoreCase(argv[i]))
        {
          quietConflictWarnings = true;
        }
        else if (""-Q"".equalsIgnoreCase(argv[i]))
        {
          setQuietMode = true;
        }

        
        else if (""-DIAG"".equalsIgnoreCase(argv[i]))
        {
          doDiag = true;
        }
        else if (""-XML"".equalsIgnoreCase(argv[i]))
        {
          outputType = ""xml"";
        }
        else if (""-TEXT"".equalsIgnoreCase(argv[i]))
        {
          outputType = ""text"";
        }
        else if (""-HTML"".equalsIgnoreCase(argv[i]))
        {
          outputType = ""html"";
        }
        else if (""-EDUMP"".equalsIgnoreCase(argv[i]))
        {
          doStackDumpOnError = true;

          if (((i + 1) < argv.length) && (argv[i + 1].charAt(0) != '-'))
          {
            dumpFileName = argv[++i];
          }
        }
        else if (""-URIRESOLVER"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
          {
            try
            {
              uriResolver =
                (URIResolver) Class.forName(argv[++i]).newInstance();

              tfactory.setURIResolver(uriResolver);
            }
            catch (Exception cnfe)
            {
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_CLASS_NOT_FOUND_FOR_OPTION,
                  new Object[]{ ""-URIResolver"" }));
              doExit(-1);
            }
          }
          else
          {
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-URIResolver"" }));  
            doExit(-1);
          }
        }
        else if (""-ENTITYRESOLVER"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
          {
            try
            {
              entityResolver =
                (EntityResolver) Class.forName(argv[++i]).newInstance();
            }
            catch (Exception cnfe)
            {
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_CLASS_NOT_FOUND_FOR_OPTION,
                  new Object[]{ ""-EntityResolver"" }));
              doExit(-1);
            }
          }
          else
          {
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-EntityResolver"" }));  
            doExit(-1);
          }
        }
        else if (""-CONTENTHANDLER"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
          {
            try
            {
              contentHandler =
                (ContentHandler) Class.forName(argv[++i]).newInstance();
            }
            catch (Exception cnfe)
            {
              System.err.println(
                XSLMessages.createMessage(
                  XSLTErrorResources.ER_CLASS_NOT_FOUND_FOR_OPTION,
                  new Object[]{ ""-ContentHandler"" }));
              doExit(-1);
            }
          }
          else
          {
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-ContentHandler"" }));  
            doExit(-1);
          }
        }
        else if (""-L"".equalsIgnoreCase(argv[i]))
          useSourceLocation = true;
        else if (""-INCREMENTAL"".equalsIgnoreCase(argv[i]))
        {
          tfactory.setAttribute
            (""http:
             java.lang.Boolean.TRUE);
        }
        else if (""-NOOPTIMIZE"".equalsIgnoreCase(argv[i]))
        {
          
          
          
          
          
          tfactory.setAttribute
            (""http:
             java.lang.Boolean.FALSE);
	}
        else if (""-RL"".equalsIgnoreCase(argv[i]))
        {
          if (i + 1 < argv.length)
            recursionLimit = Integer.parseInt(argv[++i]);
          else
            System.err.println(
              XSLMessages.createMessage(
                XSLTErrorResources.ER_MISSING_ARG_FOR_OPTION,
                new Object[]{ ""-rl"" }));  
        }

        else
          System.err.println(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_INVALID_OPTION, new Object[]{ argv[i] }));  
      }

      
      
      try
      {
        long start = System.currentTimeMillis();

        if (null != dumpFileName)
        {
          dumpWriter = new PrintWriter(new FileWriter(dumpFileName));
        }

        Templates stylesheet = null;

        if (null != xslFileName)
        {
          if (flavor.equals(""d2d""))
          {

            
            DocumentBuilderFactory dfactory =
              DocumentBuilderFactory.newInstance();

            dfactory.setNamespaceAware(true);

            DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
            Node xslDOM = docBuilder.parse(new InputSource(xslFileName));

            stylesheet = tfactory.newTemplates(new DOMSource(xslDOM,
                    xslFileName));
          }
          else
          {
            
            stylesheet = tfactory.newTemplates(new StreamSource(xslFileName));
            
          }
        }

        PrintWriter resultWriter;
        StreamResult strResult;

        if (null != outFileName)
        {
          strResult = new StreamResult(new FileOutputStream(outFileName));
          
          
          
          
          strResult.setSystemId(outFileName);
        }
        else
        {
          strResult = new StreamResult(System.out);
	  
	  
	  
	  
        }

        SAXTransformerFactory stf = (SAXTransformerFactory) tfactory;
        
		
        if (useSourceLocation)
           stf.setAttribute(XalanProperties.SOURCE_LOCATION, Boolean.TRUE);        

        
        
        if (null == stylesheet)
        {
          Source source =
            stf.getAssociatedStylesheet(new StreamSource(inFileName), media,
                                        null, null);

          if (null != source)
            stylesheet = tfactory.newTemplates(source);
          else
          {
            if (null != media)
              throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_STYLESHEET_IN_MEDIA, new Object[]{inFileName, media})); 
                                            
                                            
            else
              throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_STYLESHEET_PI, new Object[]{inFileName})); 
                                             
          }
        }

        if (null != stylesheet)
        {
          Transformer transformer = flavor.equals(""th"") ? null : stylesheet.newTransformer();

          
          if (null != outputType)
          {
            transformer.setOutputProperty(OutputKeys.METHOD, outputType);
          }

          if (transformer instanceof TransformerImpl)
          {
            TransformerImpl impl = ((TransformerImpl) transformer);
            TraceManager tm = impl.getTraceManager();

            if (null != tracer)
              tm.addTraceListener(tracer);

            impl.setQuietConflictWarnings(quietConflictWarnings);

			
            if (useSourceLocation)
              impl.setProperty(XalanProperties.SOURCE_LOCATION, Boolean.TRUE);

	    if(recursionLimit>0)
	      impl.setRecursionLimit(recursionLimit);

            
            
          }

          int nParams = params.size();

          for (int i = 0; i < nParams; i += 2)
          {
            transformer.setParameter((String) params.elementAt(i),
                                     (String) params.elementAt(i + 1));
          }

          if (uriResolver != null)
            transformer.setURIResolver(uriResolver);

          if (null != inFileName)
          {
            if (flavor.equals(""d2d""))
            {

              
              DocumentBuilderFactory dfactory =
                DocumentBuilderFactory.newInstance();

              dfactory.setCoalescing(true);
              dfactory.setNamespaceAware(true);

              DocumentBuilder docBuilder = dfactory.newDocumentBuilder();

              if (entityResolver != null)
                docBuilder.setEntityResolver(entityResolver);

              Node xmlDoc = docBuilder.parse(new InputSource(inFileName));
              Document doc = docBuilder.newDocument();
              org.w3c.dom.DocumentFragment outNode =
                doc.createDocumentFragment();

              transformer.transform(new DOMSource(xmlDoc, inFileName),
                                    new DOMResult(outNode));

              
              Transformer serializer = stf.newTransformer();
              Properties serializationProps =
                stylesheet.getOutputProperties();

              serializer.setOutputProperties(serializationProps);

              if (contentHandler != null)
              {
                SAXResult result = new SAXResult(contentHandler);

                serializer.transform(new DOMSource(outNode), result);
              }
              else
                serializer.transform(new DOMSource(outNode), strResult);
            }
            else if (flavor.equals(""th""))
            {
              for (int i = 0; i < 1; i++) 
              {
              

              
              XMLReader reader = null;

              
              try
              {
                javax.xml.parsers.SAXParserFactory factory =
                  javax.xml.parsers.SAXParserFactory.newInstance();

                factory.setNamespaceAware(true);

                javax.xml.parsers.SAXParser jaxpParser =
                  factory.newSAXParser();

                reader = jaxpParser.getXMLReader();
              }
              catch (javax.xml.parsers.ParserConfigurationException ex)
              {
                throw new org.xml.sax.SAXException(ex);
              }
              catch (javax.xml.parsers.FactoryConfigurationError ex1)
              {
                throw new org.xml.sax.SAXException(ex1.toString());
              }
              catch (NoSuchMethodError ex2){}
              catch (AbstractMethodError ame){}

              if (null == reader)
              {
                reader = XMLReaderFactory.createXMLReader();
              }
              
              stf.setAttribute(org.apache.xalan.processor.TransformerFactoryImpl.FEATURE_INCREMENTAL, 
                 Boolean.TRUE);
                 
              TransformerHandler th = stf.newTransformerHandler(stylesheet);
              
              reader.setContentHandler(th);
              reader.setDTDHandler(th);
              
              if(th instanceof org.xml.sax.ErrorHandler)
                reader.setErrorHandler((org.xml.sax.ErrorHandler)th);
              
              try
              {
                reader.setProperty(
                  ""http:
              }
              catch (org.xml.sax.SAXNotRecognizedException e){}
              catch (org.xml.sax.SAXNotSupportedException e){}
              try
              {
                reader.setFeature(""http:
                                  true);
              } catch (org.xml.sax.SAXException se) {}
        
              try
              {
                reader.setFeature(""http:
                                  true);
              } catch (org.xml.sax.SAXException se) {}
              
              th.setResult(strResult);
              
              
              
              {



                reader.parse(new InputSource(inFileName));
                
                
                
              }
              
              















              
              }
            }
            else
            {
              if (entityResolver != null)
              {
                XMLReader reader = null;

                
                try
                {
                  javax.xml.parsers.SAXParserFactory factory =
                    javax.xml.parsers.SAXParserFactory.newInstance();

                  factory.setNamespaceAware(true);

                  javax.xml.parsers.SAXParser jaxpParser =
                    factory.newSAXParser();

                  reader = jaxpParser.getXMLReader();
                }
                catch (javax.xml.parsers.ParserConfigurationException ex)
                {
                  throw new org.xml.sax.SAXException(ex);
                }
                catch (javax.xml.parsers.FactoryConfigurationError ex1)
                {
                  throw new org.xml.sax.SAXException(ex1.toString());
                }
                catch (NoSuchMethodError ex2){}
                catch (AbstractMethodError ame){}

                if (null == reader)
                {
                  reader = XMLReaderFactory.createXMLReader();
                }

                reader.setEntityResolver(entityResolver);

                if (contentHandler != null)
                {
                  SAXResult result = new SAXResult(contentHandler);

                  transformer.transform(
                    new SAXSource(reader, new InputSource(inFileName)),
                    result);
                }
                else
                {
                  transformer.transform(
                    new SAXSource(reader, new InputSource(inFileName)),
                    strResult);
                }
              }
              else if (contentHandler != null)
              {
                SAXResult result = new SAXResult(contentHandler);

                transformer.transform(new StreamSource(inFileName), result);
              }
              else
              {
                
                transformer.transform(new StreamSource(inFileName),
                                      strResult);
                
              }
            }
          }
          else
          {
            StringReader reader =
              new StringReader(""<?xml version=""1.0""?> <doc/>"");

            transformer.transform(new StreamSource(reader), strResult);
          }
        }
        else
        {
          diagnosticsWriter.println(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_NOT_SUCCESSFUL, null));  
          doExit(-1);
        }

        long stop = System.currentTimeMillis();
        long millisecondsDuration = stop - start;

        if (doDiag)
        {
        	Object[] msgArgs = new Object[]{ inFileName, xslFileName, new Long(millisecondsDuration) };
        	String msg = XSLMessages.createMessage(""diagTiming"", msgArgs);
        	diagnosticsWriter.println('
');
          	diagnosticsWriter.println(msg);
        }
          
      }
      catch (Throwable throwable)
      {
        while (throwable
               instanceof org.apache.xml.utils.WrappedRuntimeException)
        {
          throwable =
            ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();
        }

        if ((throwable instanceof NullPointerException)
                || (throwable instanceof ClassCastException))
          doStackDumpOnError = true;

        diagnosticsWriter.println();

        if (doStackDumpOnError)
          throwable.printStackTrace(dumpWriter);
        else
        {
          DefaultErrorHandler.printLocation(diagnosticsWriter, throwable);
          diagnosticsWriter.println(
            XSLMessages.createMessage(XSLTErrorResources.ER_XSLT_ERROR, null)
            + "" ("" + throwable.getClass().getName() + ""): ""
            + throwable.getMessage());
        }

        
        if (null != dumpFileName)
        {
          dumpWriter.close();
        }

        doExit(-1);
      }

      if (null != dumpFileName)
      {
        dumpWriter.close();
      }

      if (null != diagnosticsWriter)
      {

        
      }

      
      
      
      diagnosticsWriter.println("""");  
    }
  }
  
  
  static void doExit(int i)
  {
          System.exit(i);
  }
}
"
org.apache.xpath.DOMHelper,26,1,1,17,84,315,12,5,23,0.884444444,1119,0.888888889,6,0.0,0.22,0,0,41.69230769,40,4.9615,0,"
package org.apache.xpath;

import java.util.Hashtable;
import java.util.Vector;

import org.w3c.dom.*;

import javax.xml.transform.TransformerException;

import org.apache.xml.utils.NSInfo;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.StringBufferPool;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;


import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.apache.xml.dtm.ref.DTMNodeProxy;


public class DOMHelper
{

  
  public static Document createDocument()
  {

    try
    {

      
      
      DocumentBuilderFactory dfactory = DocumentBuilderFactory.newInstance();

      dfactory.setNamespaceAware(true);
      dfactory.setValidating(true);

      DocumentBuilder docBuilder = dfactory.newDocumentBuilder();
      Document outNode = docBuilder.newDocument();

      return outNode;
    }
    catch (ParserConfigurationException pce)
    {
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(
          XPATHErrorResources.ER_CREATEDOCUMENT_NOT_SUPPORTED, null));  

      
    }
  }

  
  public boolean shouldStripSourceNode(Node textNode)
          throws javax.xml.transform.TransformerException
  {

    
    return false;
  }

  
  public String getUniqueID(Node node)
  {
    return ""N"" + Integer.toHexString(node.hashCode()).toUpperCase();
  }

  
  public static boolean isNodeAfter(Node node1, Node node2)
  {
    if (node1 == node2 || isNodeTheSame(node1, node2))
      return true;

        
    boolean isNodeAfter = true;
        
    Node parent1 = getParentOfNode(node1);
    Node parent2 = getParentOfNode(node2);          

    
    if (parent1 == parent2 || isNodeTheSame(parent1, parent2))  
    {
      if (null != parent1)
        isNodeAfter = isNodeAfterSibling(parent1, node1, node2);
      else
      {
                  
                  
                  
                  
                  
                  
                  
          
      }
    }
    else
    {

      
      
          
          
      
                
                
                
                
      
      int nParents1 = 2, nParents2 = 2;  

      while (parent1 != null)
      {
        nParents1++;

        parent1 = getParentOfNode(parent1);
      }

      while (parent2 != null)
      {
        nParents2++;

        parent2 = getParentOfNode(parent2);
      }

          
          
      Node startNode1 = node1, startNode2 = node2;

      
          
      if (nParents1 < nParents2)
      {
        
        int adjust = nParents2 - nParents1;

        for (int i = 0; i < adjust; i++)
        {
          startNode2 = getParentOfNode(startNode2);
        }
      }
      else if (nParents1 > nParents2)
      {
        
        int adjust = nParents1 - nParents2;

        for (int i = 0; i < adjust; i++)
        {
          startNode1 = getParentOfNode(startNode1);
        }
      }

      Node prevChild1 = null, prevChild2 = null;  

      
      while (null != startNode1)
      {
        if (startNode1 == startNode2 || isNodeTheSame(startNode1, startNode2))  
        {
          if (null == prevChild1)  
          {

            
            isNodeAfter = (nParents1 < nParents2) ? true : false;

            break;  
          }
          else 
          {
                        
            isNodeAfter = isNodeAfterSibling(startNode1, prevChild1,
                                             prevChild2);

            break;  
          }
        }  

                
        prevChild1 = startNode1;
        startNode1 = getParentOfNode(startNode1);
        prevChild2 = startNode2;
        startNode2 = getParentOfNode(startNode2);
      }  
    }  
        
        
        
        
    
    return isNodeAfter;
  }  

  
  public static boolean isNodeTheSame(Node node1, Node node2)
  {
    if (node1 instanceof DTMNodeProxy && node2 instanceof DTMNodeProxy)
      return ((DTMNodeProxy)node1).equals((DTMNodeProxy)node2);
    else
      return false;
  }

  
  private static boolean isNodeAfterSibling(Node parent, Node child1,
                                            Node child2)
  {

    boolean isNodeAfterSibling = false;
    short child1type = child1.getNodeType();
    short child2type = child2.getNodeType();

    if ((Node.ATTRIBUTE_NODE != child1type)
            && (Node.ATTRIBUTE_NODE == child2type))
    {

      
      isNodeAfterSibling = false;
    }
    else if ((Node.ATTRIBUTE_NODE == child1type)
             && (Node.ATTRIBUTE_NODE != child2type))
    {

      
      isNodeAfterSibling = true;
    }
    else if (Node.ATTRIBUTE_NODE == child1type)
    {
      NamedNodeMap children = parent.getAttributes();
      int nNodes = children.getLength();
      boolean found1 = false, found2 = false;

          
      for (int i = 0; i < nNodes; i++)
      {
        Node child = children.item(i);

        if (child1 == child || isNodeTheSame(child1, child))
        {
          if (found2)
          {
            isNodeAfterSibling = false;

            break;
          }

          found1 = true;
        }
        else if (child2 == child || isNodeTheSame(child2, child))
        {
          if (found1)
          {
            isNodeAfterSibling = true;

            break;
          }

          found2 = true;
        }
      }
    }
    else
    {
                
                
                
                
                
                
                
                
                
                
                
      Node child = parent.getFirstChild();
      boolean found1 = false, found2 = false;

      while (null != child)
      {

        
        if (child1 == child || isNodeTheSame(child1, child))
        {
          if (found2)
          {
            isNodeAfterSibling = false;

            break;
          }

          found1 = true;
        }
        else if (child2 == child || isNodeTheSame(child2, child))
        {
          if (found1)
          {
            isNodeAfterSibling = true;

            break;
          }

          found2 = true;
        }

        child = child.getNextSibling();
      }
    }

    return isNodeAfterSibling;
  }  

  
  
  

  
  public short getLevel(Node n)
  {

    short level = 1;

    while (null != (n = getParentOfNode(n)))
    {
      level++;
    }

    return level;
  }

  
  public String getNamespaceForPrefix(String prefix, Element namespaceContext)
  {

    int type;
    Node parent = namespaceContext;
    String namespace = null;

    if (prefix.equals(""xml""))
    {
      namespace = QName.S_XMLNAMESPACEURI; 
    }
        else if(prefix.equals(""xmlns""))
    {
          
          
          
          
          
      namespace = ""http:
    }
    else
    {
          
          String declname=(prefix=="""")
                        ? ""xmlns""
                        : ""xmlns:""+prefix;
                                           
          
      while ((null != parent) && (null == namespace)
             && (((type = parent.getNodeType()) == Node.ELEMENT_NODE)
                 || (type == Node.ENTITY_REFERENCE_NODE)))
      {
        if (type == Node.ELEMENT_NODE)
        {
                        
                        
                        
                        
                        
                        
                        
                        
                
                        Attr attr=((Element)parent).getAttributeNode(declname);
                        if(attr!=null)
                        {
                namespace = attr.getNodeValue();
                break;
                        }
                }

        parent = getParentOfNode(parent);
      }
    }

    return namespace;
  }

  
  Hashtable m_NSInfos = new Hashtable();

  
  protected static final NSInfo m_NSInfoUnProcWithXMLNS = new NSInfo(false,
                                                            true);

  
  protected static final NSInfo m_NSInfoUnProcWithoutXMLNS = new NSInfo(false,
                                                               false);

  
  protected static final NSInfo m_NSInfoUnProcNoAncestorXMLNS =
    new NSInfo(false, false, NSInfo.ANCESTORNOXMLNS);

  
  protected static final NSInfo m_NSInfoNullWithXMLNS = new NSInfo(true,
                                                          true);

  
  protected static final NSInfo m_NSInfoNullWithoutXMLNS = new NSInfo(true,
                                                             false);

  
  protected static final NSInfo m_NSInfoNullNoAncestorXMLNS =
    new NSInfo(true, false, NSInfo.ANCESTORNOXMLNS);

  
  protected Vector m_candidateNoAncestorXMLNS = new Vector();

  
  public String getNamespaceOfNode(Node n)
  {

    String namespaceOfPrefix;
    boolean hasProcessedNS;
    NSInfo nsInfo;
    short ntype = n.getNodeType();

    if (Node.ATTRIBUTE_NODE != ntype)
    {
      Object nsObj = m_NSInfos.get(n);  

      nsInfo = (nsObj == null) ? null : (NSInfo) nsObj;
      hasProcessedNS = (nsInfo == null) ? false : nsInfo.m_hasProcessedNS;
    }
    else
    {
      hasProcessedNS = false;
      nsInfo = null;
    }

    if (hasProcessedNS)
    {
      namespaceOfPrefix = nsInfo.m_namespace;
    }
    else
    {
      namespaceOfPrefix = null;

      String nodeName = n.getNodeName();
      int indexOfNSSep = nodeName.indexOf(':');
      String prefix;

      if (Node.ATTRIBUTE_NODE == ntype)
      {
        if (indexOfNSSep > 0)
        {
          prefix = nodeName.substring(0, indexOfNSSep);
        }
        else
        {

          
          
          return namespaceOfPrefix;
        }
      }
      else
      {
        prefix = (indexOfNSSep >= 0)
                 ? nodeName.substring(0, indexOfNSSep) : """";
      }

      boolean ancestorsHaveXMLNS = false;
      boolean nHasXMLNS = false;

      if (prefix.equals(""xml""))
      {
        namespaceOfPrefix = QName.S_XMLNAMESPACEURI;
      }
      else
      {
        int parentType;
        Node parent = n;

        while ((null != parent) && (null == namespaceOfPrefix))
        {
          if ((null != nsInfo)
                  && (nsInfo.m_ancestorHasXMLNSAttrs
                      == nsInfo.ANCESTORNOXMLNS))
          {
            break;
          }

          parentType = parent.getNodeType();

          if ((null == nsInfo) || nsInfo.m_hasXMLNSAttrs)
          {
            boolean elementHasXMLNS = false;

            if (parentType == Node.ELEMENT_NODE)
            {
              NamedNodeMap nnm = parent.getAttributes();

              for (int i = 0; i < nnm.getLength(); i++)
              {
                Node attr = nnm.item(i);
                String aname = attr.getNodeName();

                if (aname.charAt(0) == 'x')
                {
                  boolean isPrefix = aname.startsWith(""xmlns:"");

                  if (aname.equals(""xmlns"") || isPrefix)
                  {
                    if (n == parent)
                      nHasXMLNS = true;

                    elementHasXMLNS = true;
                    ancestorsHaveXMLNS = true;

                    String p = isPrefix ? aname.substring(6) : """";

                    if (p.equals(prefix))
                    {
                      namespaceOfPrefix = attr.getNodeValue();

                      break;
                    }
                  }
                }
              }
            }

            if ((Node.ATTRIBUTE_NODE != parentType) && (null == nsInfo)
                    && (n != parent))
            {
              nsInfo = elementHasXMLNS
                       ? m_NSInfoUnProcWithXMLNS : m_NSInfoUnProcWithoutXMLNS;

              m_NSInfos.put(parent, nsInfo);
            }
          }

          if (Node.ATTRIBUTE_NODE == parentType)
          {
            parent = getParentOfNode(parent);
          }
          else
          {
            m_candidateNoAncestorXMLNS.addElement(parent);
            m_candidateNoAncestorXMLNS.addElement(nsInfo);

            parent = parent.getParentNode();
          }

          if (null != parent)
          {
            Object nsObj = m_NSInfos.get(parent);  

            nsInfo = (nsObj == null) ? null : (NSInfo) nsObj;
          }
        }

        int nCandidates = m_candidateNoAncestorXMLNS.size();

        if (nCandidates > 0)
        {
          if ((false == ancestorsHaveXMLNS) && (null == parent))
          {
            for (int i = 0; i < nCandidates; i += 2)
            {
              Object candidateInfo = m_candidateNoAncestorXMLNS.elementAt(i
                                       + 1);

              if (candidateInfo == m_NSInfoUnProcWithoutXMLNS)
              {
                m_NSInfos.put(m_candidateNoAncestorXMLNS.elementAt(i),
                              m_NSInfoUnProcNoAncestorXMLNS);
              }
              else if (candidateInfo == m_NSInfoNullWithoutXMLNS)
              {
                m_NSInfos.put(m_candidateNoAncestorXMLNS.elementAt(i),
                              m_NSInfoNullNoAncestorXMLNS);
              }
            }
          }

          m_candidateNoAncestorXMLNS.removeAllElements();
        }
      }

      if (Node.ATTRIBUTE_NODE != ntype)
      {
        if (null == namespaceOfPrefix)
        {
          if (ancestorsHaveXMLNS)
          {
            if (nHasXMLNS)
              m_NSInfos.put(n, m_NSInfoNullWithXMLNS);
            else
              m_NSInfos.put(n, m_NSInfoNullWithoutXMLNS);
          }
          else
          {
            m_NSInfos.put(n, m_NSInfoNullNoAncestorXMLNS);
          }
        }
        else
        {
          m_NSInfos.put(n, new NSInfo(namespaceOfPrefix, nHasXMLNS));
        }
      }
    }

    return namespaceOfPrefix;
  }

  
  public String getLocalNameOfNode(Node n)
  {

    String qname = n.getNodeName();
    int index = qname.indexOf(':');

    return (index < 0) ? qname : qname.substring(index + 1);
  }

  
  public String getExpandedElementName(Element elem)
  {

    String namespace = getNamespaceOfNode(elem);

    return (null != namespace)
           ? namespace + "":"" + getLocalNameOfNode(elem)
           : getLocalNameOfNode(elem);
  }

  
  public String getExpandedAttributeName(Attr attr)
  {

    String namespace = getNamespaceOfNode(attr);

    return (null != namespace)
           ? namespace + "":"" + getLocalNameOfNode(attr)
           : getLocalNameOfNode(attr);
  }

  
  
  

  
  public boolean isIgnorableWhitespace(Text node)
  {

    boolean isIgnorable = false;  

    
    
    
        
        
        
    return isIgnorable;
  }

  
  public Node getRoot(Node node)
  {

    Node root = null;

    while (node != null)
    {
      root = node;
      node = getParentOfNode(node);
    }

    return root;
  }

  
  public Node getRootNode(Node n)
  {
    int nt = n.getNodeType();
    return ( (Node.DOCUMENT_NODE == nt) || (Node.DOCUMENT_FRAGMENT_NODE == nt) ) 
           ? n : n.getOwnerDocument();
  }

  
  public boolean isNamespaceNode(Node n)
  {

    if (Node.ATTRIBUTE_NODE == n.getNodeType())
    {
      String attrName = n.getNodeName();

      return (attrName.startsWith(""xmlns:"") || attrName.equals(""xmlns""));
    }

    return false;
  }

  
  public static Node getParentOfNode(Node node) throws RuntimeException
  {
    Node parent;
    short nodeType = node.getNodeType();

    if (Node.ATTRIBUTE_NODE == nodeType)
    {
      Document doc = node.getOwnerDocument();
          

          
          
          
          
          
          
          
          
          
          DOMImplementation impl=doc.getImplementation();
          if(impl!=null && impl.hasFeature(""Core"",""2.0""))
          {
                  parent=((Attr)node).getOwnerElement();
                  return parent;
          }

          

      Element rootElem = doc.getDocumentElement();

      if (null == rootElem)
      {
        throw new RuntimeException(
          XSLMessages.createXPATHMessage(
            XPATHErrorResources.ER_CHILD_HAS_NO_OWNER_DOCUMENT_ELEMENT,
            null));  
      }

      parent = locateAttrParent(rootElem, node);

        }
    else
    {
      parent = node.getParentNode();

      
      
      
      
    }

    return parent;
  }

  
  public Element getElementByID(String id, Document doc)
  {
    return null;
  }

  
  public String getUnparsedEntityURI(String name, Document doc)
  {

    String url = """";
    DocumentType doctype = doc.getDoctype();

    if (null != doctype)
    {
      NamedNodeMap entities = doctype.getEntities();
      if(null == entities)
        return url;
      Entity entity = (Entity) entities.getNamedItem(name);
      if(null == entity)
        return url;
      
      String notationName = entity.getNotationName();

      if (null != notationName)  
      {
        
        
        
        
        
        
        
        
        
        url = entity.getSystemId();

        if (null == url)
        {
          url = entity.getPublicId();
        }
        else
        {
          
          
        }        
      }
    }

    return url;
  }

  
  private static Node locateAttrParent(Element elem, Node attr)
  {

    Node parent = null;

        
        
        
        
        
        Attr check=elem.getAttributeNode(attr.getNodeName());
        if(check==attr)
                parent = elem;

    if (null == parent)
    {
      for (Node node = elem.getFirstChild(); null != node;
              node = node.getNextSibling())
      {
        if (Node.ELEMENT_NODE == node.getNodeType())
        {
          parent = locateAttrParent((Element) node, attr);

          if (null != parent)
            break;
        }
      }
    }

    return parent;
  }

  
  protected Document m_DOMFactory = null;

  
  public void setDOMFactory(Document domFactory)
  {
    this.m_DOMFactory = domFactory;
  }

  
  public Document getDOMFactory()
  {

    if (null == this.m_DOMFactory)
    {
      this.m_DOMFactory = createDocument();
    }

    return this.m_DOMFactory;
  }

  
  public static String getNodeData(Node node)
  {

    FastStringBuffer buf = StringBufferPool.get();
    String s;

    try
    {
      getNodeData(node, buf);

      s = (buf.length() > 0) ? buf.toString() : """";
    }
    finally
    {
      StringBufferPool.free(buf);
    }

    return s;
  }

  
  public static void getNodeData(Node node, FastStringBuffer buf)
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_FRAGMENT_NODE :
    case Node.DOCUMENT_NODE :
    case Node.ELEMENT_NODE :
    {
      for (Node child = node.getFirstChild(); null != child;
              child = child.getNextSibling())
      {
        getNodeData(child, buf);
      }
    }
    break;
    case Node.TEXT_NODE :
    case Node.CDATA_SECTION_NODE :
      buf.append(node.getNodeValue());
      break;
    case Node.ATTRIBUTE_NODE :
      buf.append(node.getNodeValue());
      break;
    case Node.PROCESSING_INSTRUCTION_NODE :
      
      break;
    default :
      
      break;
    }
  }
}
"
org.apache.xalan.xsltc.compiler.util.NodeSortRecordGenerator,3,4,0,5,5,1,1,4,3,1.0,25,1.0,0,0.975903614,0.466666667,0,0,6.666666667,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

import org.apache.xalan.xsltc.compiler.Stylesheet;


public final class NodeSortRecordGenerator extends ClassGenerator {
    private static final int TRANSLET_INDEX = 4;   
    private final Instruction _aloadTranslet;

    public NodeSortRecordGenerator(String className, String superClassName,
				   String fileName,
				   int accessFlags, String[] interfaces,
				   Stylesheet stylesheet) {
	super(className, superClassName, fileName,
	      accessFlags, interfaces, stylesheet);
	_aloadTranslet = new ALOAD(TRANSLET_INDEX);
    }
    
    
    public Instruction loadTranslet() {
	return _aloadTranslet;
    }

    
    public boolean isExternal() {
	return true;
    }

}
"
org.apache.xalan.xsltc.compiler.CurrentCall,2,4,0,8,6,1,0,8,2,2.0,13,0.0,0,0.989690722,0.625,2,4,5.5,1,0.5,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class CurrentCall extends FunctionCall {
    public CurrentCall(QName fname) {
	super(fname);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	methodGen.getInstructionList().append(methodGen.loadCurrentNode());
    }
}
"
org.apache.xalan.xsltc.compiler.CeilingCall,2,4,0,12,10,1,0,12,2,2.0,31,0.0,0,0.989690722,0.6,2,5,14.5,1,0.5,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class CeilingCall extends FunctionCall {
    public CeilingCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	argument(0).translate(classGen, methodGen);
	il.append(new INVOKESTATIC(cpg.addMethodref(MATH_CLASS,
						    ""ceil"", ""(D)D"")));
    }
}
"
org.apache.xalan.xsltc.compiler.When,7,3,0,14,25,0,1,13,6,0.5,118,1.0,1,0.903225806,0.285714286,1,5,15.57142857,5,1.4286,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.*;

final class When extends Instruction {

    private Expression _test;
    private boolean _ignore = false;

    public void display(int indent) {
	indent(indent);
	Util.println(""When"");
	indent(indent + IndentIncrement);
	System.out.print(""test "");
	Util.println(_test.toString());
	displayContents(indent + IndentIncrement);
    }
		
    public Expression getTest() {
	return _test;
    }

    public boolean ignore() {
	return(_ignore);
    }

    public void parseContents(Parser parser) {
	_test = parser.parseExpression(this, ""test"", null);

	
	
	Object result = _test.evaluateAtCompileTime();
	if (result != null && result instanceof Boolean) {
	    _ignore = !((Boolean) result).booleanValue();
	}

	parseChildren(parser);

	
	if (_test.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""test"");
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	if (_test.typeCheck(stable) instanceof BooleanType == false) {
	    _test = new CastExpr(_test, Type.Boolean);
	}
	
	if (!_ignore) {
	    typeCheckContents(stable);
	}

	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ErrorMsg msg = new ErrorMsg(ErrorMsg.STRAY_WHEN_ERR, this);
	getParser().reportError(Constants.ERROR, msg);
    }
}
"
org.apache.xpath.functions.FuncTrue,3,3,0,4,4,3,0,4,3,2.0,9,0.0,0,0.95,0.5,1,6,2.0,1,0.6667,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class FuncTrue extends Function
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return XBoolean.S_TRUE;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }

}
"
org.apache.xpath.functions.FuncLocalPart,2,5,0,5,9,1,0,5,2,2.0,42,0.0,0,0.982142857,0.75,3,8,20.0,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncLocalPart extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int context = getArg0AsNode(xctxt);
    if(DTM.NULL == context)
      return XString.EMPTYSTRING;
    DTM dtm = xctxt.getDTM(context);
    String s = (context != DTM.NULL) ? dtm.getLocalName(context) : """";
    if(s.startsWith(""#"") || s.equals(""xmlns""))
      return XString.EMPTYSTRING;

    return new XString(s);
  }
}
"
org.apache.xpath.functions.FuncCount,2,4,0,6,8,1,0,6,2,2.0,23,0.0,0,0.979591837,0.75,1,6,10.5,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XString;


public class FuncCount extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {












	DTMIterator nl = m_arg0.asIterator(xctxt, xctxt.getCurrentNode());
	int i = nl.getLength();	
	nl.detach();

    return new XNumber((double) i);
  }
}
"
org.apache.xalan.lib.ExsltDatetime,43,1,0,4,74,903,0,4,36,1.023809524,1326,0.0,0,0.0,0.168604651,0,0,29.65116279,5,1.2791,3,"

package org.apache.xalan.lib;


import java.util.Date;
import java.util.TimeZone;
import java.util.Calendar;
import java.text.SimpleDateFormat;
import java.text.DateFormat;
import java.text.ParseException;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XBoolean;
import org.apache.xpath.objects.XObject;



public class ExsltDatetime
{
    
    static final String dt = ""yyyy-MM-dd'T'HH:mm:ss"";
    static final String d = ""yyyy-MM-dd"";
    static final String gym = ""yyyy-MM"";
    static final String gy = ""yyyy"";
    static final String gmd = ""MM-dd"";
    static final String gm = ""MM"";
    static final String gd = ""dd"";
    static final String t = ""HH:mm:ss"";

    
    public static XString dateTime()
    {
      Calendar cal = Calendar.getInstance();
      Date datetime = cal.getTime();
      
      SimpleDateFormat dateFormat = new SimpleDateFormat(dt);
      
      StringBuffer buff = new StringBuffer(dateFormat.format(datetime));
      
      
      int offset = cal.get(Calendar.ZONE_OFFSET) + cal.get(Calendar.DST_OFFSET);
      
      
      if (offset == 0)
        buff.append(""Z"");
      else
      {
        
        int hrs = offset/(60*60*1000);
        
        int min = offset%(60*60*1000);
        char posneg = hrs < 0? '-': '+';
        buff.append(posneg + formatDigits(hrs) + ':' + formatDigits(min));
      }
      return new XString(buff.toString());
    }
    
    
    private static String formatDigits(int q)
    {
      String dd = String.valueOf(Math.abs(q));
      return dd.length() == 1 ? '0' + dd : dd;
    }

    
    public static XString date(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String leader = edz[0];
      String datetime = edz[1];
      String zone = edz[2];
      if (datetime == null || zone == null) 
        return new XString("""");
                    
      String[] formatsIn = {dt, d};
      String formatOut = d;
      Date date = testFormats(datetime, formatsIn);
      if (date == null) return new XString("""");
      
      SimpleDateFormat dateFormat = new SimpleDateFormat(formatOut);
      dateFormat.setLenient(false);
      String dateOut = dateFormat.format(date);      
      if (dateOut.length() == 0)
          return new XString("""");
      else        
        return new XString(leader + dateOut + zone);
    }
    
    
    
    public static XString date()
    {
      String datetime = dateTime().toString();
      String date = datetime.substring(0, datetime.indexOf(""T""));
      String zone = datetime.substring(getZoneStart(datetime));
      return new XString(date + zone);
    }
    
    
    public static XString time(String timeIn)
      throws ParseException      
    {
      String[] edz = getEraDatetimeZone(timeIn);
      String time = edz[1];
      String zone = edz[2];
      if (time == null || zone == null) 
        return new XString("""");
                    
      String[] formatsIn = {dt, d};
      String formatOut =  t;
      Date date = testFormats(time, formatsIn);
      if (date == null) return new XString("""");
      SimpleDateFormat dateFormat = new SimpleDateFormat(formatOut);
      String out = dateFormat.format(date);
      return new XString(out + zone);
    }

    
    public static XString time()
    {
      String datetime = dateTime().toString();
      String time = datetime.substring(datetime.indexOf(""T"")+1);
      String zone = datetime.substring(getZoneStart(datetime));      
      return new XString(time + zone);
    } 
       
    
    public static XNumber year(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      boolean ad = edz[0].length() == 0; 
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);
      
      String[] formats = {dt, d, gym, gy};
      double yr = getNumber(datetime, formats, Calendar.YEAR);
      if (ad || yr == Double.NaN)
        return new XNumber(yr);
      else
        return new XNumber(-yr);
    }
     
    
    public static XNumber year()
    {
      Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.YEAR));
    }
    
    
    public static XNumber monthInYear(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null)
        return new XNumber(Double.NaN);      
      
      String[] formats = {dt, d, gym};
      return new XNumber(getNumber(datetime, formats, Calendar.MONTH));
    }
    
    
    public static XNumber monthInYear()
    {      
      Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.MONTH));
   }
    
    
    public static XNumber weekInYear(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);      
      
      String[] formats = {dt, d};
      return new XNumber(getNumber(datetime, formats, Calendar.WEEK_OF_YEAR));
    }
        
    
    public static XNumber weekInYear()
    {
       Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.WEEK_OF_YEAR));
   }

    
    public static XNumber dayInYear(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);            
      
      String[] formats = {dt, d};
      return new XNumber(getNumber(datetime, formats, Calendar.DAY_OF_YEAR));
    }
    
    
    public static XNumber dayInYear()
    {
       Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.DAY_OF_YEAR));
   }
    

    
    public static XNumber dayInMonth(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      String[] formats = {dt, d, gmd, gd};
      double day = getNumber(datetime, formats, Calendar.DAY_OF_MONTH);
      return new XNumber(day);
    }
    
    
    public static XNumber dayInMonth()
    {
      Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.DAY_OF_MONTH));
   }
    
    
    public static XNumber dayOfWeekInMonth(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);            

      String[] formats =  {dt, d};
      return new XNumber(getNumber(datetime, formats, Calendar.DAY_OF_WEEK_IN_MONTH));
    }
    
    
    public static XNumber dayOfWeekInMonth()
    {
       Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.DAY_OF_WEEK_IN_MONTH));
   }
      
    
    
    public static XNumber dayInWeek(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);            

      String[] formats = {dt, d};
      return new XNumber(getNumber(datetime, formats, Calendar.DAY_OF_WEEK));
    }
    
    
    public static XNumber dayInWeek()
    {
       Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.DAY_OF_WEEK));
   }        

    
    public static XNumber hourInDay(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);            
      
      String[] formats = {d, t};
      return new XNumber(getNumber(datetime, formats, Calendar.HOUR_OF_DAY));
    }
    
    
    public static XNumber hourInDay()
    {
       Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.HOUR_OF_DAY));
   }
    
    
    public static XNumber minuteInHour(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);            
      
      String[] formats = {dt,t};
      return new XNumber(getNumber(datetime, formats, Calendar.MINUTE));
    }    
    
    
   public static XNumber minuteInHour()
    {
       Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.MINUTE));
   }    

    
    public static XNumber secondInMinute(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);            
      
      String[] formats = {dt, t};
      return new XNumber(getNumber(datetime, formats, Calendar.SECOND));
    }

    
    public static XNumber secondInMinute()
    {
       Calendar cal = Calendar.getInstance();
      return new XNumber(cal.get(Calendar.SECOND));
    }
       
    
    public static XObject leapYear(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XNumber(Double.NaN);            
            
      String[] formats = {dt, d, gym, gy};
      double dbl = getNumber(datetime, formats, Calendar.YEAR);
      if (dbl == Double.NaN) 
        return new XNumber(Double.NaN);
      int yr = (int)dbl;
      return new XBoolean(yr % 400 == 0 || (yr % 100 != 0 && yr % 4 == 0));
    }
    
    
    public static XBoolean leapYear()
    {
      Calendar cal = Calendar.getInstance();
      int yr = (int)cal.get(Calendar.YEAR);
      return new XBoolean(yr % 400 == 0 || (yr % 100 != 0 && yr % 4 == 0));      
    }    
       
    
    public static XString monthName(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XString("""");
      
      String[] formatsIn = {dt, d, gym, gm};
      String formatOut = ""MMMM"";
      return new XString (getNameOrAbbrev(datetimeIn, formatsIn, formatOut));    
    }
    
    
    public static XString monthName()
    {
      Calendar cal = Calendar.getInstance();
      String format = ""MMMM"";
      return new XString(getNameOrAbbrev(format));  
    }
        
    
    public static XString monthAbbreviation(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XString("""");
      
      String[] formatsIn = {dt, d, gym, gm};
      String formatOut = ""MMM"";
      return new XString (getNameOrAbbrev(datetimeIn, formatsIn, formatOut));
    }
    
    
    public static XString monthAbbreviation()
    {
      String format = ""MMM"";
      return new XString(getNameOrAbbrev(format));  
    }
        
    
    public static XString dayName(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XString("""");
            
      String[] formatsIn = {dt, d};
      String formatOut = ""EEEE"";
      return new XString (getNameOrAbbrev(datetimeIn, formatsIn, formatOut));    
    }
    
    
    public static XString dayName()
    {
      String format = ""EEEE"";
      return new XString(getNameOrAbbrev(format));        
    }    
    
    
    public static XString dayAbbreviation(String datetimeIn)
      throws ParseException
    {
      String[] edz = getEraDatetimeZone(datetimeIn);
      String datetime = edz[1];
      if (datetime == null) 
        return new XString("""");            
      
      String[] formatsIn = {dt, d};
      String formatOut = ""EEE"";
      return new XString (getNameOrAbbrev(datetimeIn, formatsIn, formatOut));
    }
    
    
    public static XString dayAbbreviation()
    {
      String format = ""EEE"";
      return new XString(getNameOrAbbrev(format));              
    }
    
    
    private static String[] getEraDatetimeZone(String in)
    {
      String leader = """";
      String datetime = in;
      String zone = """";
      if (in.charAt(0)=='-')
      {
        leader = ""-""; 
        datetime = in.substring(1);
      }
      int z = getZoneStart(datetime);
      if (z > 0)
      {
        zone = datetime.substring(z);
        datetime = datetime.substring(0, z);
      }
      else if (z == -2)
        zone = null;
      
      return new String[]{leader, datetime, zone};  
    }    
    
    
    private static int getZoneStart (String datetime)
    {
      if (datetime.indexOf(""Z"") == datetime.length()-1)
        return datetime.indexOf(""Z"");
      else if (
               (datetime.lastIndexOf(""-"") == datetime.length()-6 &&
                datetime.charAt(datetime.length()-3) == ':')               
                || 
                (datetime.indexOf(""+"") == datetime.length() -6)
              )
      {
        try
        {
          SimpleDateFormat dateFormat = new SimpleDateFormat(""HH:mm"");
          dateFormat.setLenient(false);
          Date d = dateFormat.parse(datetime.substring(datetime.length() -5));
          return datetime.length()-6;
        }
        catch (ParseException pe)
        {
          System.out.println(""ParseException "" + pe.getErrorOffset());
          return -2; 
        }

      }
        return -1; 
    }
    
    
    private static Date testFormats (String in, String[] formats)
      throws ParseException
    {
      for (int i = 0; i <formats.length; i++)
      {
        try
        {
          SimpleDateFormat dateFormat = new SimpleDateFormat(formats[i]);
          dateFormat.setLenient(false);          
          return dateFormat.parse(in);
        }
        catch (ParseException pe)
        {
          if (pe.getErrorOffset() < in.length())
            return null;
        }
      }
      return null;
    }
    
    
    
    private static double getNumber(String in, String[] formats, int calField)
      throws ParseException
    {
      Calendar cal = Calendar.getInstance();
      cal.setLenient(false);
      
      Date date = testFormats(in, formats);
      if (date == null) return Double.NaN;
      cal.setTime(date);
      return cal.get(calField);
    }    
     
    
    private static String getNameOrAbbrev(String in, 
                                         String[] formatsIn,
                                         String formatOut)
      throws ParseException
    {
      for (int i = 0; i <formatsIn.length; i++) 
      {
        try
        {
          SimpleDateFormat dateFormat = new SimpleDateFormat(formatsIn[i]);
          dateFormat.setLenient(false);
          Date dt = dateFormat.parse(in);          
          dateFormat.applyPattern(formatOut);
          return dateFormat.format(dt);
        }
        catch (ParseException pe)
        {
          
          
          
          if (pe.getErrorOffset() < in.length())
            return """";
        }
      }
      return """";
    }
    
    private static String getNameOrAbbrev(String format)
    {
      Calendar cal = Calendar.getInstance();
      SimpleDateFormat dateFormat = new SimpleDateFormat(format);
      return dateFormat.format(cal.getTime());
    }

}"
org.apache.xalan.templates.ElemTextLiteral,11,3,0,8,20,29,5,4,11,0.825,114,1.0,0,0.951456311,0.340909091,2,5,9.0,2,1.0,0,"
package org.apache.xalan.templates;


 
import org.xml.sax.*;

import org.apache.xml.utils.QName;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.transformer.ResultTreeHandler;

import javax.xml.transform.TransformerException;


public class ElemTextLiteral extends ElemTemplateElement
{

  
  private boolean m_preserveSpace;

  
  public void setPreserveSpace(boolean v)
  {
    m_preserveSpace = v;
  }

  
  public boolean getPreserveSpace()
  {
    return m_preserveSpace;
  }

  
  private char m_ch[];
  
  
  private String m_str;

  
  public void setChars(char[] v)
  {
    m_ch = v;
  }

  
  public char[] getChars()
  {
    return m_ch;
  }
  
  
  public synchronized String getNodeValue()
  {

    if(null == m_str)
    {
      m_str = new String(m_ch);
    }

    return m_str;
  }


  
  private boolean m_disableOutputEscaping = false;

  
  public void setDisableOutputEscaping(boolean v)
  {
    m_disableOutputEscaping = v;
  }

  
  public boolean getDisableOutputEscaping()
  {
    return m_disableOutputEscaping;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_TEXTLITERALRESULT;
  }

  
  public String getNodeName()
  {
    return ""#Text"";
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
    try
    {
      ResultTreeHandler rth = transformer.getResultTreeHandler();
      if (m_disableOutputEscaping)
      {
        rth.processingInstruction(javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");
      }

      rth.characters(m_ch, 0, m_ch.length);

      if (m_disableOutputEscaping)
      {
        rth.processingInstruction(javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");
      }
    }
    catch(SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEndEvent(this);
    }
  }
}
"
org.apache.xalan.xsltc.dom.MatchingIterator,10,2,0,3,22,0,0,3,10,0.666666667,121,1.0,1,0.526315789,0.35,1,5,10.7,4,1.3,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public final class MatchingIterator extends NodeIteratorBase {
    private NodeIterator _source;
    private final int    _match;
    private int          _matchPos, _matchLast = -1;
	
    public MatchingIterator(int match, NodeIterator source) {
	_source = source;
	_match = match;
    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }

    public NodeIterator cloneIterator() {
	try {
	    final MatchingIterator clone = (MatchingIterator)super.clone();
	    clone._source = _source.cloneIterator();
	    clone.setRestartable(false);
	    return clone;
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public NodeIterator setStartNode(int node) {
	if (_isRestartable) {
	    
	    _source.setStartNode(node);

	    
	    _matchPos = 1;
	    _matchLast = -1;
	    while ( ((node = _source.next()) != END) && (node != _match) )
		_matchPos++;
	}
	return this;
    }

    public NodeIterator reset() {
	_source.reset();
	return this;
    }
    
    public int next() {
	return _source.next();
    }
	
    public int getLast() {
	if (_matchLast == -1)
	    _matchLast = _source.getLast();
	return _matchLast;
    }

    public int getPosition() {
	return _matchPos;
    }

    public void setMark() {
	_source.setMark();
    }

    public void gotoMark() {
	_source.gotoMark();
    }
}
"
org.apache.xalan.processor.ProcessorInclude,7,4,1,11,48,15,2,9,3,0.333333333,282,1.0,0,0.972222222,0.5,1,1,39.14285714,1,0.8571,0,"
package org.apache.xalan.processor;

import org.apache.xml.utils.TreeWalker;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;
import org.xml.sax.XMLReader;
import org.xml.sax.InputSource;
import org.xml.sax.EntityResolver;

import java.net.URL;

import java.io.IOException;

import org.xml.sax.helpers.XMLReaderFactory;

import javax.xml.transform.URIResolver;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.sax.SAXSource;
import javax.xml.transform.stream.StreamSource;
import javax.xml.transform.Source;
import javax.xml.transform.TransformerException;

import org.w3c.dom.Node;

import org.apache.xml.utils.SystemIDResolver;


class ProcessorInclude extends XSLTElementProcessor
{

  
  private String m_href = null;

  
  public String getHref()
  {
    return m_href;
  }

  
  public void setHref(String baseIdent)
  {
    
    m_href = baseIdent;
  }

  
  protected int getStylesheetType()
  {
    return StylesheetHandler.STYPE_INCLUDE;
  }

  
  protected int getStylesheetInclErr()
  {
    return XSLTErrorResources.ER_STYLESHEET_INCLUDES_ITSELF;
  }

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {


    setPropertiesFromAttributes(handler, rawName, attributes, this);

    try
    {
      String hrefUrl = SystemIDResolver.getAbsoluteURI(getHref(),
                           handler.getBaseIdentifier());    

      if (handler.importStackContains(hrefUrl))
      {
        throw new org.xml.sax.SAXException(
          XSLMessages.createMessage(
          getStylesheetInclErr(), new Object[]{ hrefUrl }));  
      }

      handler.pushImportURL(hrefUrl);

      int savedStylesheetType = handler.getStylesheetType();

      handler.setStylesheetType(this.getStylesheetType());
      handler.pushNewNamespaceSupport();

      try
      {
        parse(handler, uri, localName, rawName, attributes);
      }
      finally
      {
        handler.setStylesheetType(savedStylesheetType);
        handler.popImportURL();
        handler.popNamespaceSupport();
      }
    }
    catch(TransformerException te)
    {
      handler.error(te.getMessage(), te);
    }
  }

  
  protected void parse(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {
    TransformerFactoryImpl processor = handler.getStylesheetProcessor();
    URIResolver uriresolver = processor.getURIResolver();

    try
    {
      Source source = null;

      if (null != uriresolver)
      {
        source = uriresolver.resolve(getHref(),
                                     handler.getBaseIdentifier());

        if (null != source && source instanceof DOMSource)
        {
          Node node = ((DOMSource)source).getNode();
          
          String systemId = source.getSystemId();
          if (systemId == null)
          {
            systemId = SystemIDResolver.getAbsoluteURI(getHref(),
                         handler.getBaseIdentifier());
            
          }
          
          TreeWalker walker = new TreeWalker(handler, new org.apache.xpath.DOM2Helper(), systemId);

          try
          {
            walker.traverse(node);
          }
          catch(org.xml.sax.SAXException se)
          {
            throw new TransformerException(se);
          }
          return;
        }
      }
      
      if(null == source)
      {
        String absURL = SystemIDResolver.getAbsoluteURI(getHref(),
                          handler.getBaseIdentifier());

        source = new StreamSource(absURL);
      }
      
      XMLReader reader = null;
      
      if(source instanceof SAXSource)
      {
        SAXSource saxSource = (SAXSource)source;
        reader = saxSource.getXMLReader(); 
      }
      
      boolean isUserReader = (reader != null);
      
      InputSource inputSource = SAXSource.sourceToInputSource(source);

      if (null == reader)
      {  
        
        try {
          javax.xml.parsers.SAXParserFactory factory=
                                                     javax.xml.parsers.SAXParserFactory.newInstance();
          factory.setNamespaceAware( true );
          javax.xml.parsers.SAXParser jaxpParser=
                                                 factory.newSAXParser();
          reader=jaxpParser.getXMLReader();
          
        } catch( javax.xml.parsers.ParserConfigurationException ex ) {
          throw new org.xml.sax.SAXException( ex );
        } catch( javax.xml.parsers.FactoryConfigurationError ex1 ) {
            throw new org.xml.sax.SAXException( ex1.toString() );
        } 
        catch( NoSuchMethodError ex2 ) 
        {
        }
        catch (AbstractMethodError ame){}
      }
      if (null == reader)
        reader = XMLReaderFactory.createXMLReader();

      if (null != reader)
      {
        reader.setContentHandler(handler);
        try
        {
          if(!isUserReader)
            reader.setFeature(""http:
                              true);
        }
        catch(org.xml.sax.SAXException se) {}
        
        handler.pushBaseIndentifier(inputSource.getSystemId());

        try
        {
          reader.parse(inputSource);
        }
        finally
        {
          handler.popBaseIndentifier();
        }
      }
    }
    catch (IOException ioe)
    {
      handler.error(XSLTErrorResources.ER_IOEXCEPTION,
                    new Object[]{ getHref() }, ioe);
    }
    catch(TransformerException te)
    {
      handler.error(te.getMessage(), te);
    }
  }
}
"
org.apache.xalan.xsltc.compiler.ParentLocationPath,11,4,0,23,38,0,2,22,11,0.64,380,1.0,3,0.879518072,0.204545455,2,7,33.09090909,35,4.8182,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class ParentLocationPath extends RelativeLocationPath {
    private Expression _step;
    private final RelativeLocationPath _path;
    private Type stype;
    private boolean _orderNodes = false;
    private boolean _axisMismatch = false;

    public ParentLocationPath(RelativeLocationPath path, Expression step) {
	_path = path;
	_step = step;
	_path.setParent(this);
	_step.setParent(this);

	if (_step instanceof Step) {
	    _axisMismatch = checkAxisMismatch();
	}
    }
		
    public void setAxis(int axis) {
	_path.setAxis(axis);
    }

    public int getAxis() {
	return _path.getAxis();
    }

    public RelativeLocationPath getPath() {
	return(_path);
    }

    public Expression getStep() {
	return(_step);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_step.setParser(parser);
	_path.setParser(parser);
    }
    
    public String toString() {
	return ""ParentLocationPath("" + _path + "", "" + _step + ')';
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	stype = _step.typeCheck(stable);
	_path.typeCheck(stable);

	if (_axisMismatch) enableNodeOrdering();

	return _type = Type.NodeSet;	
    }

    public void enableNodeOrdering() {
	SyntaxTreeNode parent = getParent();
	if (parent instanceof ParentLocationPath)
	    ((ParentLocationPath)parent).enableNodeOrdering();
	else {
	    _orderNodes = true;
	}
    }

    
    public boolean checkAxisMismatch() {

	int left = _path.getAxis();
	int right = ((Step)_step).getAxis();

	if (((left == Axis.ANCESTOR) || (left == Axis.ANCESTORORSELF)) &&
	    ((right == Axis.CHILD) ||
	     (right == Axis.DESCENDANT) ||
	     (right == Axis.DESCENDANTORSELF) ||
	     (right == Axis.PARENT) ||
	     (right == Axis.PRECEDING) ||
	     (right == Axis.PRECEDINGSIBLING)))
	    return true;

	if ((left == Axis.CHILD) &&
	    (right == Axis.ANCESTOR) ||
	    (right == Axis.ANCESTORORSELF) ||
	    (right == Axis.PARENT) ||
	    (right == Axis.PRECEDING))
	    return true;

	if ((left == Axis.DESCENDANT) || (left == Axis.DESCENDANTORSELF))
	    return true;

	if (((left == Axis.FOLLOWING) || (left == Axis.FOLLOWINGSIBLING)) &&
	    ((right == Axis.FOLLOWING) ||
	     (right == Axis.PARENT) ||
	     (right == Axis.PRECEDING) ||
	     (right == Axis.PRECEDINGSIBLING)))
	    return true;

	if (((left == Axis.PRECEDING) || (left == Axis.PRECEDINGSIBLING)) &&
	    ((right == Axis.DESCENDANT) ||
	     (right == Axis.DESCENDANTORSELF) ||
	     (right == Axis.FOLLOWING) ||
	     (right == Axis.FOLLOWINGSIBLING) ||
	     (right == Axis.PARENT) ||
	     (right == Axis.PRECEDING) ||
	     (right == Axis.PRECEDINGSIBLING)))
	    return true;

	if ((right == Axis.FOLLOWING) && (left == Axis.CHILD)) {
	    
	    
	    
	    
	    if (_path instanceof Step) {
		int type = ((Step)_path).getNodeType();
		if (type == DOM.ATTRIBUTE) return true;
	    }
	}

	return false;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int initSI = cpg.addMethodref(STEP_ITERATOR_CLASS,
					    ""<init>"",
					    ""(""
					    +NODE_ITERATOR_SIG
					    +NODE_ITERATOR_SIG
					    +"")V"");
	il.append(new NEW(cpg.addClass(STEP_ITERATOR_CLASS)));
	il.append(DUP);

	
	_path.translate(classGen, methodGen); 
	_step.translate(classGen, methodGen);

	
	il.append(new INVOKESPECIAL(initSI));

	
	Expression stp = _step;
	if (stp instanceof ParentLocationPath)
	    stp = ((ParentLocationPath)stp).getStep();

	if ((_path instanceof Step) && (stp instanceof Step)) {
	    final int path = ((Step)_path).getAxis();
	    final int step = ((Step)stp).getAxis();
	    if ((path == Axis.DESCENDANTORSELF && step == Axis.CHILD) ||
		(path == Axis.PRECEDING        && step == Axis.PARENT)) {
		final int incl = cpg.addMethodref(NODE_ITERATOR_BASE,
						  ""includeSelf"",
						  ""()"" + NODE_ITERATOR_SIG);
		il.append(new INVOKEVIRTUAL(incl));
	    }
	}

	
	if (_orderNodes) {
	    final int order = cpg.addInterfaceMethodref(DOM_INTF,
							ORDER_ITERATOR,
							ORDER_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(order, 3));
	}
    }
}
"
org.apache.xalan.xsltc.dom.MultiDOM,42,1,0,11,86,0,4,9,41,0.887195122,572,1.0,2,0.0,0.19047619,0,0,12.42857143,3,1.1429,1,"

package org.apache.xalan.xsltc.dom;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.StripFilter;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.TransletOutputHandler;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.Hashtable;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public final class MultiDOM implements DOM {

    private static final int NO_TYPE = DOM.FIRST_TYPE - 2;
    private static final int INITIAL_SIZE = 4;
    private static final int CLR = 0x00FFFFFF;
    private static final int SET = 0xFF000000;
    
    private DOM[] _adapters;
    private int _free;
    private int _size;

    private Hashtable _documents = new Hashtable();

    private final class AxisIterator implements NodeIterator {
	private final int _axis;
	private final int _type;

	private int _mask;
	private NodeIterator _source = null;
	
	public AxisIterator(final int axis, final int type) {
	    _axis = axis;
	    _type = type;
	}
	
	public int next() {
	    if (_source == null) return(END);
	    if (_mask == 0) return _source.next();
	    final int node = _source.next();
	    return node != END ? (node | _mask) : END;
	}
	
	public void setRestartable(boolean flag) {
	    _source.setRestartable(flag);
	}

	public NodeIterator setStartNode(final int node) {
	    final int dom = node >>> 24;
	    final int mask = node & SET;

	    
	    if (_source == null || _mask != mask) {
		if (_type == NO_TYPE) {
		    _source = _adapters[dom].getAxisIterator(_axis);
		}
		else if (_axis == Axis.CHILD && _type != ELEMENT) {
		    _source = _adapters[dom].getTypedChildren(_type);
		}
		else {
		    _source = _adapters[dom].getTypedAxisIterator(_axis, _type);
		}
	    }

	    _mask = mask;
	    _source.setStartNode(node & CLR);
	    return this;
	}

	public NodeIterator reset() {
	    if (_source != null) _source.reset();
	    return this;
	}
    
	public int getLast() {
	    return _source.getLast();
	}
    
	public int getPosition() {
	    return _source.getPosition();
	}
    
	public boolean isReverse() {
	    return (_source == null) ? false : _source.isReverse();
	}
    
	public void setMark() {
	    _source.setMark();
	}
    
	public void gotoMark() {
	    _source.gotoMark();
	}
    
	public NodeIterator cloneIterator() {
	    final AxisIterator clone = new AxisIterator(_axis, _type);
	    clone._source = _source.cloneIterator();
	    clone._mask = _mask;
	    return clone;
	}

    } 


    
    private final class NodeValueIterator extends NodeIteratorBase {

	private NodeIterator _source;
	private String _value;
	private boolean _op;
	private final boolean _isReverse;
	private int _returnType = RETURN_PARENT;

	public NodeValueIterator(NodeIterator source, int returnType,
				 String value, boolean op) {
	    _source = source;
	    _returnType = returnType;
	    _value = value;
	    _op = op;
	    _isReverse = source.isReverse();
	}

	public boolean isReverse() {
	    return _isReverse;
	}
    
	public NodeIterator cloneIterator() {
	    try {
		NodeValueIterator clone = (NodeValueIterator)super.clone();
		clone._source = _source.cloneIterator();
		clone.setRestartable(false);
		return clone.reset();
	    }
	    catch (CloneNotSupportedException e) {
		BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
					  e.toString());
		return null;
	    }
	}

	public void setRestartable(boolean isRestartable) {
	    _isRestartable = isRestartable;
	    _source.setRestartable(isRestartable);
	}

	public NodeIterator reset() {
	    _source.reset();
	    return resetPosition();
	}

	public int next() {

	    int node;
	    while ((node = _source.next()) != END) {
		String val = getNodeValue(node);
		if (_value.equals(val) == _op) {
		    if (_returnType == RETURN_CURRENT)
			return returnNode(node);
		    else
			return returnNode(getParent(node));
		}
	    }
	    return END;
	}

	public NodeIterator setStartNode(int node) {
	    if (_isRestartable) {
		_source.setStartNode(_startNode = node); 
		return resetPosition();
	    }
	    return this;
	}

	public void setMark() {
	    _source.setMark();
	}

	public void gotoMark() {
	    _source.gotoMark();
	}
    }                       

    public MultiDOM(DOM main) {
	_size = INITIAL_SIZE;
	_free = 1;
	_adapters = new DOM[INITIAL_SIZE];
	_adapters[0] = main;
    }

    public int nextMask() {
	return(_free << 24);
    }

    public void setupMapping(String[] names, String[] namespaces) {
	
    }

    public int addDOMAdapter(DOMAdapter dom) {
	
	final int domNo = _free++;
	if (domNo == _size) {
	    final DOMAdapter[] newArray = new DOMAdapter[_size *= 2];
	    System.arraycopy(_adapters, 0, newArray, 0, domNo);
	    _adapters = newArray;
	}
	_adapters[domNo] = dom;

	
	String uri = dom.getDocumentURI(0);
	_documents.put(uri, new Integer(domNo));
	
	
	dom.setMultiDOMMask(domNo << 24);
	return (domNo << 24);
    }
    
    public int getDocumentMask(String uri) {
	Integer domIdx = (Integer)_documents.get(uri);
	if (domIdx == null)
	    return(-1);
	else
	    return((domIdx.intValue() << 24));
    }

    
    public NodeIterator getIterator() {
	
	return _adapters[0].getIterator();
    }
    
    public String getStringValue() {
	return _adapters[0].getStringValue();
    }

    public String getTreeString() {
	return _adapters[0].getTreeString();
    }
    
    public NodeIterator getChildren(final int node) {
	return (node & SET) == 0
	    ? _adapters[0].getChildren(node)
	    : getAxisIterator(Axis.CHILD).setStartNode(node);
    }
    
    public NodeIterator getTypedChildren(final int type) {
	return new AxisIterator(Axis.CHILD, type);
    }
    
    public NodeIterator getAxisIterator(final int axis) {
	return new AxisIterator(axis, NO_TYPE);
    }
    
    public NodeIterator getTypedAxisIterator(final int axis, final int type) {
	return new AxisIterator(axis, type);
    }

    public NodeIterator getNthDescendant(int node, int n, boolean includeself) {
	return _adapters[node>>>24].getNthDescendant(node & CLR,n,includeself);
    }

    public NodeIterator getNodeValueIterator(NodeIterator iterator, int type,
					     String value, boolean op) {
	return(new NodeValueIterator(iterator, type, value, op));
    }

    public NodeIterator getNamespaceAxisIterator(final int axis, final int ns) {
	NodeIterator iterator = _adapters[0].getNamespaceAxisIterator(axis,ns);
	return(iterator);	
    }

    public NodeIterator orderNodes(NodeIterator source, int node) {
	return _adapters[node>>>24].orderNodes(source, node & CLR);
    }

    public int getType(final int node) {
	return _adapters[node>>>24].getType(node & CLR);
    }

    public int getNamespaceType(final int node) {
	return _adapters[node>>>24].getNamespaceType(node & CLR);
    }
    
    public int getParent(final int node) {
	return _adapters[node>>>24].getParent(node & CLR) | node&SET;
    }
    
    public int getTypedPosition(int type, int node) {
	return _adapters[node>>>24].getTypedPosition(type, node&CLR);
    }

    public int getTypedLast(int type, int node) {
	return _adapters[node>>>24].getTypedLast(type, node&CLR);
    }

    public int getAttributeNode(final int type, final int el) {
	return _adapters[el>>>24].getAttributeNode(type, el&CLR) | el&SET;
    }
    
    public String getNodeName(final int node) {
	return _adapters[node>>>24].getNodeName(node & CLR);
    }

    public String getNamespaceName(final int node) {
	return _adapters[node>>>24].getNamespaceName(node & CLR);
    }
    
    public String getNodeValue(final int node) {
	return _adapters[node>>>24].getNodeValue(node & CLR);
    }
    
    public void copy(final int node, TransletOutputHandler handler)
	throws TransletException {
	_adapters[node>>>24].copy(node & CLR, handler);
    }
    
    public void copy(NodeIterator nodes, TransletOutputHandler handler)
	throws TransletException {
	int node;
	while ((node = nodes.next()) != DOM.NULL) {
	    _adapters[node>>>24].copy(node & CLR, handler);
	}
    }


    public String shallowCopy(final int node, TransletOutputHandler handler)
	throws TransletException {
	return _adapters[node>>>24].shallowCopy(node & CLR, handler);
    }
    
    public boolean lessThan(final int node1, final int node2) {
	final int dom1 = node1>>>24;
	final int dom2 = node2>>>24;
	return dom1 == dom2
	    ? _adapters[dom1].lessThan(node1 & CLR, node2 & CLR)
	    : dom1 < dom2;
    }
    
    public void characters(final int textNode, TransletOutputHandler handler)
	throws TransletException {
	    _adapters[textNode>>>24].characters(textNode & CLR, handler);
    }

    public void setFilter(StripFilter filter) {
	for (int dom=0; dom<_free; dom++) {
	    _adapters[dom].setFilter(filter);
	}
    }

    public Node makeNode(int index) {
	return _adapters[index>>>24].makeNode(index & CLR);
    }

    public Node makeNode(NodeIterator iter) {
	
	return _adapters[0].makeNode(iter);
    }

    public NodeList makeNodeList(int index) {
	return _adapters[index>>>24].makeNodeList(index & CLR);
    }

    public NodeList makeNodeList(NodeIterator iter) {
	
	return _adapters[0].makeNodeList(iter);
    }

    public String getLanguage(int node) {
	return _adapters[node>>>24].getLanguage(node & CLR);
    }

    public int getSize() {
	int size = 0;
	for (int i=0; i<_size; i++)
	    size += _adapters[i].getSize();
	return(size);
    }

    public String getDocumentURI(int node) {
	return _adapters[node>>>24].getDocumentURI(0);
    }

    public boolean isElement(final int node) {
	return(_adapters[node>>>24].isElement(node & CLR));
    }

    public boolean isAttribute(final int node) {
	return(_adapters[node>>>24].isAttribute(node & CLR));
    }

    public String lookupNamespace(int node, String prefix) 
	throws TransletException
    {
	return _adapters[node>>>24].lookupNamespace(node, prefix);
    }
}
"
org.apache.xalan.serialize.SerializerFactory,3,1,0,7,14,3,4,3,2,1.0,69,1.0,0,0.0,0.5,0,0,21.66666667,4,1.3333,0,"
package org.apache.xalan.serialize;

import javax.xml.transform.OutputKeys;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Properties;
import java.util.StringTokenizer;

import java.io.IOException;
import java.io.InputStream;

import org.apache.xalan.templates.OutputProperties;
import org.apache.xml.utils.WrappedRuntimeException;


public abstract class SerializerFactory
{

  

  

  
  private static Hashtable _formats = new Hashtable();

  
  public static Serializer getSerializer(Properties format)
  {

    Serializer ser = null;

    try
    {
      Class cls;
      String method = format.getProperty(OutputKeys.METHOD);

      if (method == null)
        throw new IllegalArgumentException(
          ""The output format has a null method name"");

      cls = null;  

      if (cls == null)
      {
        String className =
          format.getProperty(OutputProperties.S_KEY_CONTENT_HANDLER);

        if (null == className)
        {
          throw new IllegalArgumentException(
            ""The output format must have a '""
            + OutputProperties.S_KEY_CONTENT_HANDLER + ""' property!"");
        }

        cls = Class.forName(className);

        
      }

      ser = (Serializer) cls.newInstance();

      ser.setOutputFormat(format);
    }
    catch (Exception e)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(e);
    }

    return ser;
  }
}
"
org.apache.xalan.serialize.DOMSerializer,1,1,0,3,1,0,3,0,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xalan.serialize;

import java.io.IOException;

import org.w3c.dom.Node;


public interface DOMSerializer
{
  
  public void serialize(Node node) throws IOException;
}
"
org.apache.xalan.templates.ElemVariable,22,3,3,38,68,155,20,24,19,0.828571429,383,0.8,2,0.907407407,0.168181818,2,15,16.18181818,4,1.0909,1,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.Expression;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xpath.objects.XRTreeFragSelectWrapper;
import org.apache.xml.utils.QName;
import org.apache.xalan.trace.SelectionEvent;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;


public class ElemVariable extends ElemTemplateElement
{

  
  public ElemVariable(){}

  
  protected int m_index;
  
  
  int m_frameSize = -1;

  
  
  public void setIndex(int index)
  {
    m_index = index;
  }

  
  public int getIndex()
  {
    return m_index;
  }

  
  private XPath m_selectPattern;

  
  public void setSelect(XPath v)
  {
    m_selectPattern = v;
  }

  
  public XPath getSelect()
  {
    return m_selectPattern;
  }

  
  protected QName m_qname;

  
  public void setName(QName v)
  {
    m_qname = v;
  }

  
  public QName getName()
  {
    return m_qname;
  }

  
  private boolean m_isTopLevel = false;

  
  public void setIsTopLevel(boolean v)
  {
    m_isTopLevel = v;
  }

  
  public boolean getIsTopLevel()
  {
    return m_isTopLevel;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_VARIABLE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_VARIABLE_STRING;
  }

  
  public ElemVariable(ElemVariable param) throws TransformerException
  {

    m_selectPattern = param.m_selectPattern;
    m_qname = param.m_qname;
    m_isTopLevel = param.m_isTopLevel;

    
    
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    int sourceNode = transformer.getXPathContext().getCurrentNode();
  
    XObject var = getValue(transformer, sourceNode);

    
    transformer.getXPathContext().getVarStack().setLocalVariable(m_index, var);
    
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this);         
  }

  
  public XObject getValue(TransformerImpl transformer, int sourceNode)
          throws TransformerException
  {

    XObject var;
    XPathContext xctxt = transformer.getXPathContext();

    xctxt.pushCurrentNode(sourceNode);
 
    try
    {
      if (null != m_selectPattern)
      {
        var = m_selectPattern.execute(xctxt, sourceNode, this);

        var.allowDetachToRelease(false);

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                  ""select"", m_selectPattern, var);
      }
      else if (null == getFirstChildElem())
      {
        var = XString.EMPTYSTRING;
      }
      else
      {

        
        
        
        
        int df;

		
		
		
		
		
		try
		{
			
			if(m_parentNode instanceof Stylesheet) 
				df = transformer.transformToGlobalRTF(this);
			else
				df = transformer.transformToRTF(this);
    	}
		finally{ 
			
			}

        var = new XRTreeFrag(df, xctxt, this);
      }
    }
    finally
    {      
      xctxt.popCurrentNode();
    }

    return var;
  }
  
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    
    if(null == m_selectPattern  
       && org.apache.xalan.processor.TransformerFactoryImpl.m_optimize)
    {
      XPath newSelect = rewriteChildToExpression(this);
      if(null != newSelect)
        m_selectPattern = newSelect;
    }
    
    StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    
    
    
    java.util.Vector vnames = cstate.getVariableNames();
    if(null != m_selectPattern)
      m_selectPattern.fixupVariables(vnames, cstate.getGlobalsSize());
      
    
    
    if(!(m_parentNode instanceof Stylesheet))
    {
      m_index = cstate.addVariableName(m_qname) - cstate.getGlobalsSize();
    }
    else
    {
    	
    	
    	
		cstate.resetStackFrameSize();
    }
    
    
    
    super.compose(sroot);
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    super.endCompose(sroot);
    if(m_parentNode instanceof Stylesheet)
    {
    	StylesheetRoot.ComposeState cstate = sroot.getComposeState();
    	m_frameSize = cstate.getFrameSize();
    	cstate.resetStackFrameSize();
    }
  }

  
  









  
  static XPath rewriteChildToExpression(ElemTemplateElement varElem)
          throws TransformerException
  {

    ElemTemplateElement t = varElem.getFirstChildElem();

    
    
    if (null != t && null == t.getNextSiblingElem())
    {
      int etype = t.getXSLToken();

      if (Constants.ELEMNAME_VALUEOF == etype)
      {
        ElemValueOf valueof = (ElemValueOf) t;

        
        if (valueof.getDisableOutputEscaping() == false
                && valueof.getDOMBackPointer() == null)
        {
          varElem.m_firstChild = null;

          return new XPath(new XRTreeFragSelectWrapper(valueof.getSelect().getExpression()));
        }
      }
      else if (Constants.ELEMNAME_TEXTLITERALRESULT == etype)
      {
        ElemTextLiteral lit = (ElemTextLiteral) t;

        if (lit.getDisableOutputEscaping() == false
                && lit.getDOMBackPointer() == null)
        {
          String str = lit.getNodeValue();
          XString xstr = new XString(str);

          varElem.m_firstChild = null;

          return new XPath(new XRTreeFragSelectWrapper(xstr));
        }
      }
    }

    return null;
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeVariables(this);
  }
  
  
  public void setParentElem(ElemTemplateElement p)
  {
    super.setParentElem(p);
    p.m_hasVariableDecl = true;
  }
  
  
  protected boolean accept(XSLTVisitor visitor)
  {
  	return visitor.visitVariableOrParamDecl(this);
  }

  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(null != m_selectPattern)
  		m_selectPattern.getExpression().callVisitors(m_selectPattern, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }
  
  
  public boolean isPsuedoVar()
  {
  	java.lang.String ns = m_qname.getNamespaceURI();
  	if((null != ns) && ns.equals(RedundentExprEliminator.PSUEDOVARNAMESPACE))
  	{
  		if(m_qname.getLocalName().startsWith(""#""))
  			return true;
  	}
  	return false;
  }


}
"
org.apache.xalan.transformer.DecimalToRoman,1,1,0,2,2,0,2,0,1,2.0,20,0.0,0,0.0,1.0,0,0,15.0,0,0.0,0,"
package org.apache.xalan.transformer;


public class DecimalToRoman
{

  
  public DecimalToRoman(long postValue, String postLetter, long preValue,
                        String preLetter)
  {

    this.m_postValue = postValue;
    this.m_postLetter = postLetter;
    this.m_preValue = preValue;
    this.m_preLetter = preLetter;
  }

  
  public long m_postValue;

  
  public String m_postLetter;

  
  public long m_preValue;

  
  public String m_preLetter;
}
"
org.apache.xalan.xsltc.compiler.Comment,4,3,0,19,20,6,0,19,3,2.0,92,0.0,0,0.949152542,0.4,1,3,22.0,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import javax.xml.parsers.*;

import org.xml.sax.*;

import java.util.Vector;
import java.util.Enumeration;

import org.apache.xalan.xsltc.compiler.util.Type;

import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.JavaClass;

import org.apache.xalan.xsltc.compiler.util.*;

final class Comment extends Instruction {

    public void parseContents(Parser parser) {
	parseChildren(parser);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	typeCheckContents(stable);
	return Type.String;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	il.append(DUP);		

	
	il.append(classGen.loadTranslet());
	il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					       ""stringValueHandler"",
					       STRING_VALUE_HANDLER_SIG)));
	il.append(DUP);
	il.append(methodGen.storeHandler());

	
	translateContents(classGen, methodGen);

	
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_VALUE_HANDLER,
						     ""getValue"",
						     ""()"" + STRING_SIG)));
	
	final int comment =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""comment"", 
				      ""("" + STRING_SIG + "")V"");
	il.append(new INVOKEINTERFACE(comment, 2));
	
	il.append(methodGen.storeHandler());
    }
}
"
org.apache.xalan.xsltc.compiler.Fallback,6,3,0,13,12,0,1,12,5,0.2,49,1.0,0,0.918032787,0.333333333,1,3,7.0,2,1.1667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import java.util.StringTokenizer;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class Fallback extends Instruction {

    private boolean _active = false;

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_active) {
	    return(typeCheckContents(stable));
	}
	else {
	    return Type.Void;
	}
    }

    
    public void activate() {
	_active = true;
    }

    public String toString() {
	return(""fallback"");
    }

    
    public void parseContents(Parser parser) {
	if (_active) parseChildren(parser);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_active) translateContents(classGen, methodGen);
    }
}
"
org.apache.xml.utils.res.XResources_ja_JP_HI,3,4,0,1,4,1,0,1,2,0.5,595,0.0,0,0.976190476,1.0,0,0,197.0,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_ja_JP_HI extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ja"" }, { ""help_language"", ""ja"" }, { ""language"", ""ja"" },
    { ""alphabet"",
      new char[]{ 0x3044, 0x308d, 0x306f, 0x306b, 0x307b, 0x3078, 0x3068,
                  0x3061, 0x308a, 0x306c, 0x308b, 0x3092, 0x308f, 0x304b,
                  0x3088, 0x305f, 0x308c, 0x305d, 0x3064, 0x306d, 0x306a,
                  0x3089, 0x3080, 0x3046, 0x3090, 0x306e, 0x304a, 0x304f,
                  0x3084, 0x307e, 0x3051, 0x3075, 0x3053, 0x3048, 0x3066,
                  0x3042, 0x3055, 0x304d, 0x3086, 0x3081, 0x307f, 0x3057,
                  0x3091, 0x3072, 0x3082, 0x305b, 0x3059 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    
    
    { ""multiplier"",
      new long[]{ Long.MAX_VALUE, Long.MAX_VALUE, 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4EAC, 0x5146, 0x5104, 0x4E07, 0x5343, 0x767e, 0x5341 } },

    
    { ""zero"", new char[0] },
    { ""digits"",
      new char[]{ 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03,
                  0x516B, 0x4E5D } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xpath.XPathAPI,10,1,0,6,21,45,1,5,10,2.0,116,0.0,0,0.0,0.5,0,0,10.6,1,0.9,0,"
package org.apache.xpath;

import javax.xml.transform.TransformerException;

import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.traversal.NodeIterator;
import org.w3c.dom.NodeList;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xpath.XPathContext;
import org.apache.xml.utils.PrefixResolverDefault;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.objects.XObject;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xml.dtm.ref.DTMNodeList;
import org.apache.xml.dtm.ref.DTMManagerDefault;


public class XPathAPI
{

  
  public static Node selectSingleNode(Node contextNode, String str)
          throws TransformerException
  {
    return selectSingleNode(contextNode, str, contextNode);
  }

  
  public static Node selectSingleNode(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    NodeIterator nl = selectNodeIterator(contextNode, str, namespaceNode);

    
    return nl.nextNode();
  }

  
  public static NodeIterator selectNodeIterator(Node contextNode, String str)
          throws TransformerException
  {
    return selectNodeIterator(contextNode, str, contextNode);
  }

  
  public static NodeIterator selectNodeIterator(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    XObject list = eval(contextNode, str, namespaceNode);

    
    return list.nodeset();
  }

  
  public static NodeList selectNodeList(Node contextNode, String str)
          throws TransformerException
  {
    return selectNodeList(contextNode, str, contextNode);
  }

  
  public static NodeList selectNodeList(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    XObject list = eval(contextNode, str, namespaceNode);

    
    return list.nodelist();
  }

  
  public static XObject eval(Node contextNode, String str)
          throws TransformerException
  {
    return eval(contextNode, str, contextNode);
  }

  
  public static XObject eval(Node contextNode, String str, Node namespaceNode)
          throws TransformerException
  {

    
    
    
    
    
    XPathContext xpathSupport = new XPathContext();

    
    
    
    
    PrefixResolverDefault prefixResolver = new PrefixResolverDefault(
      (namespaceNode.getNodeType() == Node.DOCUMENT_NODE)
      ? ((Document) namespaceNode).getDocumentElement() : namespaceNode);

    
    XPath xpath = new XPath(str, null, prefixResolver, XPath.SELECT, null);

    
    
    int ctxtNode = xpathSupport.getDTMHandleFromNode(contextNode);

    return xpath.execute(xpathSupport, ctxtNode, prefixResolver);
  }

  
  public static XObject eval(
          Node contextNode, String str, PrefixResolver prefixResolver)
            throws TransformerException
  {

    
    
    
    
    
    
    XPath xpath = new XPath(str, null, prefixResolver, XPath.SELECT, null);

    
    XPathContext xpathSupport = new XPathContext();
    int ctxtNode = xpathSupport.getDTMHandleFromNode(contextNode);

    return xpath.execute(xpathSupport, ctxtNode, prefixResolver);
  }
}
"
org.apache.xalan.xsltc.compiler.SymbolTable,25,1,0,91,47,214,88,10,24,0.891666667,494,1.0,1,0.0,0.185454545,0,0,18.36,5,2.2,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Hashtable;
import java.util.Enumeration;
import java.util.StringTokenizer;

import org.apache.xalan.xsltc.compiler.util.*;

final class SymbolTable {

    
    private final Hashtable _stylesheets = new Hashtable();
    private final Hashtable _primops     = new Hashtable();

    
    private Hashtable _variables = null;
    private Hashtable _templates = null;
    private Hashtable _attributeSets = null;
    private Hashtable _aliases = null;
    private Hashtable _excludedURI = null;
    private Hashtable _decimalFormats = null;

    public DecimalFormatting getDecimalFormatting(QName name) {
	if (_decimalFormats == null) return null;
	return((DecimalFormatting)_decimalFormats.get(name));
    }

    public void addDecimalFormatting(QName name, DecimalFormatting symbols) {
	if (_decimalFormats == null) _decimalFormats = new Hashtable();
	_decimalFormats.put(name, symbols);
    }

    public Stylesheet addStylesheet(QName name, Stylesheet node) {
	return (Stylesheet)_stylesheets.put(name, node);
    }
	
    public Stylesheet lookupStylesheet(QName name) {
	return (Stylesheet)_stylesheets.get(name);
    }

    public Template addTemplate(Template template) {
	final QName name = template.getName();
	if (_templates == null) _templates = new Hashtable();
	return (Template)_templates.put(name, template);
    }
	
    public Template lookupTemplate(QName name) {
	if (_templates == null) return null;
	return (Template)_templates.get(name);
    }

    public Variable addVariable(Variable variable) {
	if (_variables == null) _variables = new Hashtable();
	final String name = variable.getName().getStringRep();
	return (Variable)_variables.put(name, variable);
    }
	
    public Param addParam(Param parameter) {
	if (_variables == null) _variables = new Hashtable();
	final String name = parameter.getName().getStringRep();
	return (Param)_variables.put(name, parameter);
    }
	
    public Variable lookupVariable(QName qname) {
	if (_variables == null) return null;
	final String name = qname.getStringRep();
	final Object obj = _variables.get(name);
	return obj instanceof Variable ? (Variable)obj : null;
    }

    public Param lookupParam(QName qname) {
	if (_variables == null) return null;
	final String name = qname.getStringRep();
	final Object obj = _variables.get(name);
	return obj instanceof Param ? (Param)obj : null;
    }
	
    public SyntaxTreeNode lookupName(QName qname) {
	if (_variables == null) return null;
	final String name = qname.getStringRep();
	return (SyntaxTreeNode)_variables.get(name);
    }

    public AttributeSet addAttributeSet(AttributeSet atts) {
	if (_attributeSets == null) _attributeSets = new Hashtable();
	return (AttributeSet)_attributeSets.put(atts.getName(), atts);
    }

    public AttributeSet lookupAttributeSet(QName name) {
	if (_attributeSets == null) return null;
	return (AttributeSet)_attributeSets.get(name);
    }

    
    public void addPrimop(String name, MethodType mtype) {
	Vector methods = (Vector)_primops.get(name);
	if (methods == null) {
	    _primops.put(name, methods = new Vector());
	}
	methods.addElement(mtype);
    }
	
    
    public Vector lookupPrimop(String name) {
	return (Vector)_primops.get(name);
    }

    
    private int _nsCounter = 0;

    public String generateNamespacePrefix() {
	return(new String(""ns""+(_nsCounter++)));
    }

    
    private SyntaxTreeNode _current = null;

    public void setCurrentNode(SyntaxTreeNode node) {
	_current = node;
    }

    public String lookupNamespace(String prefix) {
	if (_current == null) return(Constants.EMPTYSTRING);
	return(_current.lookupNamespace(prefix));
    }

     
    public void addPrefixAlias(String prefix, String alias) {
	if (_aliases == null) _aliases = new Hashtable();
	_aliases.put(prefix,alias);
    }

     
    public String lookupPrefixAlias(String prefix) {
	if (_aliases == null) return null;
	return (String)_aliases.get(prefix);
    }

    
    public void excludeURI(String uri) {
	
	if (uri == null) return;

	
	if (_excludedURI == null) _excludedURI = new Hashtable();

	
	Integer refcnt = (Integer)_excludedURI.get(uri);
	if (refcnt == null)
	    refcnt = new Integer(1);
	else
	    refcnt = new Integer(refcnt.intValue() + 1);
	_excludedURI.put(uri,refcnt);
    }

    
    public void excludeNamespaces(String prefixes) {
	if (prefixes != null) {
	    StringTokenizer tokens = new StringTokenizer(prefixes);
	    while (tokens.hasMoreTokens()) {
		final String prefix = tokens.nextToken();
		final String uri;
		if (prefix.equals(""#default""))
		    uri = lookupNamespace(Constants.EMPTYSTRING);
		else
		    uri = lookupNamespace(prefix);
		if (uri != null) excludeURI(uri);
	    }
	}
    }

    
    public boolean isExcludedNamespace(String uri) {
	if (uri != null && _excludedURI != null) {
	    final Integer refcnt = (Integer)_excludedURI.get(uri);
	    return (refcnt != null && refcnt.intValue() > 0);
	}
	return false;
    }

    
    public void unExcludeNamespaces(String prefixes) {
	if (_excludedURI == null) return;
	if (prefixes != null) {
	    StringTokenizer tokens = new StringTokenizer(prefixes);
	    while (tokens.hasMoreTokens()) {
		final String prefix = tokens.nextToken();
		final String uri;
		if (prefix.equals(""#default""))
		    uri = lookupNamespace(Constants.EMPTYSTRING);
		else
		    uri = lookupNamespace(prefix);
		Integer refcnt = (Integer)_excludedURI.get(uri);
		if (refcnt != null)
		    _excludedURI.put(uri, new Integer(refcnt.intValue() - 1));
	    }
	}	
    }

}

"
org.apache.xpath.compiler.FuncLoader,3,1,0,3,11,0,2,1,3,0.5,64,1.0,0,0.0,0.555555556,0,0,19.66666667,1,0.6667,0,"
package org.apache.xpath.compiler;

import java.lang.Class;

import org.apache.xpath.res.XPATHErrorResources;

import org.w3c.dom.Node;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.functions.Function;


public class FuncLoader
{

  
  private int m_funcID;

  
  private String m_funcName;

  
  public String getName()
  {
    return m_funcName;
  }

  
  public FuncLoader(String funcName, int funcID)
  {

    super();

    m_funcID = funcID;
    m_funcName = funcName;
  }

  
  public Function getFunction() throws javax.xml.transform.TransformerException
  {

    try
    {
      Class function;

      
      if (m_funcName.indexOf(""."") < 0)
      {

        
        
        
        String classname = ""org.apache.xpath.functions."" + m_funcName;

        function = Class.forName(classname);
      }
      else
        function = Class.forName(m_funcName);

      Function func = (Function) function.newInstance();

      return func;
    }
    catch (ClassNotFoundException e)
    {
      throw new javax.xml.transform.TransformerException(e);
    }
    catch (IllegalAccessException e)
    {
      throw new javax.xml.transform.TransformerException(e);
    }
    catch (InstantiationException e)
    {
      throw new javax.xml.transform.TransformerException(e);
    }
  }
}
"
org.apache.xalan.res.XSLMessages,15,1,0,92,33,69,90,2,13,0.836734694,442,1.0,0,0.0,0.333333333,0,0,28.0,7,2.5333,0,"
package org.apache.xalan.res;

import java.util.Locale;
import java.util.ResourceBundle;
import java.util.ListResourceBundle;
import java.util.MissingResourceException;

import org.apache.xpath.res.XPATHErrorResources;


public class XSLMessages
{

  
  private Locale fLocale = Locale.getDefault();

  
  private static ResourceBundle XSLTBundle = null;

  
  private static ResourceBundle XPATHBundle = null;

  
  private static final String XSLT_ERROR_RESOURCES =
    ""org.apache.xalan.res.XSLTErrorResources"";

  
  private static final String XPATH_ERROR_RESOURCES =
    ""org.apache.xpath.res.XPATHErrorResources"";

  
  private static String BAD_CODE = ""BAD_CODE"";

  
  private static String FORMAT_FAILED = ""FORMAT_FAILED"";

  
   public void setLocale(Locale locale)
  {
    fLocale = locale;
  }

  
  public Locale getLocale()
  {
    return fLocale;
  }

  
  public static final String createXPATHWarning(int errorCode, Object args[])  
  {

    if (XPATHBundle == null)
      XPATHBundle =
        loadResourceBundle(XPATH_ERROR_RESOURCES);

    ResourceBundle fResourceBundle = XPATHBundle;

    if (fResourceBundle != null)
    {
      String msgKey = XPATHErrorResources.getWarningKey(errorCode);

      return createXPATHMsg(fResourceBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }

  
  public static final String createXPATHMessage(int errorCode, Object args[])  
  {

    if (XPATHBundle == null)
      XPATHBundle =
        loadResourceBundle(XPATH_ERROR_RESOURCES);

    ResourceBundle fResourceBundle = XPATHBundle;

    if (fResourceBundle != null)
    {
      String msgKey = XPATHErrorResources.getMessageKey(errorCode);

      return createXPATHMsg(fResourceBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }
  
  
  public static final String createXPATHMessage(String msgKey, Object args[])  
  {

    if (XPATHBundle == null)
      XPATHBundle =
        loadResourceBundle(XPATH_ERROR_RESOURCES);

    ResourceBundle fResourceBundle = XPATHBundle;

    if (fResourceBundle != null)
    {
      return createXPATHMsg(fResourceBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }


  
  public static final String createXPATHMsg(ResourceBundle fResourceBundle,
                                            String msgKey, Object args[])  
  {

    String fmsg = null;
    boolean throwex = false;
    String msg = null;

    if (msgKey != null)
      msg = fResourceBundle.getString(msgKey);

    if (msg == null)
    {
      msg = fResourceBundle.getString(XPATHErrorResources.BAD_CODE);
      throwex = true;
    }

    if (args != null)
    {
      try
      {

        
        
        
        int n = args.length;

        for (int i = 0; i < n; i++)
        {
          if (null == args[i])
            args[i] = """";
        }

        fmsg = java.text.MessageFormat.format(msg, args);
      }
      catch (Exception e)
      {
        fmsg = fResourceBundle.getString(XPATHErrorResources.FORMAT_FAILED);
        fmsg += "" "" + msg;
      }
    }
    else
      fmsg = msg;

    if (throwex)
    {
      throw new RuntimeException(fmsg);
    }

    return fmsg;
  }

  
  public static final String createWarning(int errorCode, Object args[])  
  {

    if (XSLTBundle == null)
      XSLTBundle =
        loadResourceBundle(XSLT_ERROR_RESOURCES);

    ResourceBundle fResourceBundle = XSLTBundle;

    if (fResourceBundle != null)
    {
      String msgKey = XSLTErrorResources.getWarningKey(errorCode);

      return createMsg(fResourceBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }
  
  
  public static final String createMessage(String msgKey, Object args[])  
  {

    if (XSLTBundle == null)
      XSLTBundle =
        loadResourceBundle(XSLT_ERROR_RESOURCES);

    ResourceBundle fResourceBundle = XSLTBundle;

    if (fResourceBundle != null)
    {
      return createMsg(fResourceBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }

  
  public static final String createMessage(int errorCode, Object args[])  
  {

    if (XSLTBundle == null)
      XSLTBundle =
        loadResourceBundle(XSLT_ERROR_RESOURCES);

    ResourceBundle fResourceBundle = XSLTBundle;

    if (fResourceBundle != null)
    {
      String msgKey = XSLTErrorResources.getMessageKey(errorCode);

      return createMsg(fResourceBundle, msgKey, args);
    }
    else
      return ""Could not load any resource bundles."";
  }

  
  public static final String createMsg(ResourceBundle fResourceBundle,
                                       String msgKey, Object args[])  
  {

    String fmsg = null;
    boolean throwex = false;
    String msg = null;

    if (msgKey != null)
      msg = fResourceBundle.getString(msgKey);

    if (msg == null)
    {
      msg = fResourceBundle.getString(BAD_CODE);
      throwex = true;
    }

    if (args != null)
    {
      try
      {

        
        
        
        int n = args.length;

        for (int i = 0; i < n; i++)
        {
          if (null == args[i])
            args[i] = """";
        }

        fmsg = java.text.MessageFormat.format(msg, args);
      }
      catch (Exception e)
      {
        fmsg = fResourceBundle.getString(FORMAT_FAILED);
        fmsg += "" "" + msg;
      }
    }
    else
      fmsg = msg;

    if (throwex)
    {
      throw new RuntimeException(fmsg);
    }

    return fmsg;
  }

  
  public String createMessage(String bundleName, int errorCode, Object args[])
          throws Exception
  {

    boolean throwex = false;
    int majorCode;
    int minorCode;
    String fmsg = null;
    ResourceBundle aResourceBundle = null;

    aResourceBundle = loadResourceBundle(bundleName);

    String msgKey = XSLTErrorResources.getMessageKey(errorCode);
    String msg = null;

    if (msgKey != null)
      msg = aResourceBundle.getString(msgKey);

    if (msg == null)
    {
      msg = aResourceBundle.getString(BAD_CODE);
      throwex = true;
    }

    if (args != null)
    {
      try
      {

        
        
        
        int n = args.length;

        for (int i = 0; i < n; i++)
        {
          if (null == args[i])
            args[i] = """";
        }

        fmsg = java.text.MessageFormat.format(msg, args);
      }
      catch (Exception e)
      {
        fmsg = aResourceBundle.getString(FORMAT_FAILED);
        fmsg += "" "" + msg;
      }
    }
    else
      fmsg = msg;

    if (throwex)
    {
      throw new RuntimeException(fmsg);
    }

    return fmsg;
  }

  
  public static final ResourceBundle loadResourceBundle(String className)
          throws MissingResourceException
  {

    Locale locale = Locale.getDefault();

    
    try
    {

      
      
      return ResourceBundle.getBundle(className, locale);
    }
    catch (MissingResourceException e)
    {
      try  
      {

        
        
        return ResourceBundle.getBundle(
          XSLT_ERROR_RESOURCES, new Locale(""en"", ""US""));
      }
      catch (MissingResourceException e2)
      {

        
        
        throw new MissingResourceException(
          ""Could not load any resource bundles."" + className, className, """");
      }
    }
  }

  
  private static final String getResourceSuffix(Locale locale)
  {

    String suffix = ""_"" + locale.getLanguage();
    String country = locale.getCountry();

    if (country.equals(""TW""))
      suffix += ""_"" + country;

    return suffix;
  }
}
"
org.apache.xalan.xsltc.runtime.TransletOutputBase,24,1,1,4,25,276,1,3,24,2.0,52,0.0,0,0.0,0.298611111,0,0,1.166666667,1,0.9583,0,"

package org.apache.xalan.xsltc.runtime;


import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.runtime.Hashtable;

public class TransletOutputBase implements TransletOutputHandler {
    public void startDocument() throws TransletException {}
    public void endDocument() throws TransletException {}
    public void characters(String characters) throws TransletException {}
    public void characters(char[] characters, int offset, int length)
	throws TransletException {}
    public void startElement(String elementName) throws TransletException {}
    public void endElement(String elementName) throws TransletException {}
    public void attribute(String attributeName, String attributeValue)
	throws TransletException {}
    public void namespace(String prefix, String uri)
	throws TransletException {}
    public void comment(String comment) throws TransletException {}
    public void processingInstruction(String target, String data)
	throws TransletException {}
    public boolean setEscaping(boolean escape) 
	throws TransletException { return true; }
    public void startCDATA() throws TransletException {}
    public void endCDATA() throws TransletException {}
    public String expandQName(String withPrefix) { return(withPrefix); }
    public void setType(int type) {}
    public void setIndent(boolean indent) {}
    public void omitHeader(boolean value) {}
    public void setCdataElements(Hashtable elements) {}
    public void setDoctype(String system, String pub) {}
    public void setMediaType(String mediaType) {}
    public void setStandalone(String standalone) {}
    public void setVersion(String version) {}
    public void close() {}
}
"
org.apache.xml.dtm.ref.IncrementalSAXSource_Filter,42,1,0,10,89,335,6,5,39,0.667917448,875,0.923076923,1,0.0,0.125396825,0,0,19.52380952,6,1.2857,0,"

package org.apache.xml.dtm.ref;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import org.xml.sax.SAXParseException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.ErrorHandler;
import org.xml.sax.Locator;
import org.xml.sax.Attributes;
import org.xml.sax.XMLReader;
import java.io.IOException;
import org.apache.xml.dtm.ref.IncrementalSAXSource;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;


public class IncrementalSAXSource_Filter
implements IncrementalSAXSource, ContentHandler, DTDHandler, LexicalHandler, ErrorHandler, Runnable
{
  boolean DEBUG=false; 

  
  
  
  private CoroutineManager fCoroutineManager = null;
  private int fControllerCoroutineID = -1;
  private int fSourceCoroutineID = -1;

  private ContentHandler clientContentHandler=null; 
  private LexicalHandler clientLexicalHandler=null; 
  private DTDHandler clientDTDHandler=null; 
  private ErrorHandler clientErrorHandler=null; 
  private int eventcounter;
  private int frequency=5;

  
  
  
  private boolean fNoMoreEvents=false;

  
  private XMLReader fXMLReader=null;
  private InputSource fXMLReaderInputSource=null;

  
  
  

  public IncrementalSAXSource_Filter() {
    this.init( new CoroutineManager(), -1, -1);
  }
  
  
  public IncrementalSAXSource_Filter(CoroutineManager co, int controllerCoroutineID)
  {
    this.init( co, controllerCoroutineID, -1 );
  }

  
  
  
  static public IncrementalSAXSource createIncrementalSAXSource(CoroutineManager co, int controllerCoroutineID) {
    return new IncrementalSAXSource_Filter(co, controllerCoroutineID);
  }

  
  
  

  public void init( CoroutineManager co, int controllerCoroutineID,
                    int sourceCoroutineID)
  {
    if(co==null)
      co = new CoroutineManager();
    fCoroutineManager = co;
    fControllerCoroutineID = co.co_joinCoroutineSet(controllerCoroutineID);
    fSourceCoroutineID = co.co_joinCoroutineSet(sourceCoroutineID);
    if (fControllerCoroutineID == -1 || fSourceCoroutineID == -1)
      throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_COJOINROUTINESET_FAILED, null)); 

    fNoMoreEvents=false;
    eventcounter=frequency;
  }
    
  
  public void setXMLReader(XMLReader eventsource)
  {
    fXMLReader=eventsource;
    eventsource.setContentHandler(this);
    eventsource.setDTDHandler(this);
    eventsource.setErrorHandler(this); 

    
    try 
    {
      eventsource.
        setProperty(""http:
                    this);
    }
    catch(SAXNotRecognizedException e)
    {
      
    }
    catch(SAXNotSupportedException e)
    {
      
    }

    
    
  }

  
  public void setContentHandler(ContentHandler handler)
  {
    clientContentHandler=handler;
  }
  
  public void setDTDHandler(DTDHandler handler)
  {
    clientDTDHandler=handler;
  }
  
  
  
  
  public void setLexicalHandler(LexicalHandler handler)
  {
    clientLexicalHandler=handler;
  }
  
  
  public void setErrHandler(ErrorHandler handler)
  {
    clientErrorHandler=handler;
  }

  
  
  public void setReturnFrequency(int events)
  {
    if(events<1) events=1;
    frequency=eventcounter=events;
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  public void characters(char[] ch, int start, int length)
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.characters(ch,start,length);
  }
  public void endDocument() 
       throws org.xml.sax.SAXException
  {
    
    if(clientContentHandler!=null)
      clientContentHandler.endDocument();

    eventcounter=0;     
    co_yield(false);
  }
  public void endElement(java.lang.String namespaceURI, java.lang.String localName,
      java.lang.String qName) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.endElement(namespaceURI,localName,qName);
  }
  public void endPrefixMapping(java.lang.String prefix) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.endPrefixMapping(prefix);
  }
  public void ignorableWhitespace(char[] ch, int start, int length) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.ignorableWhitespace(ch,start,length);
  }
  public void processingInstruction(java.lang.String target, java.lang.String data) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.processingInstruction(target,data);
  }
  public void setDocumentLocator(Locator locator) 
  {
    if(--eventcounter<=0)
      {
        
        
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.setDocumentLocator(locator);
  }
  public void skippedEntity(java.lang.String name) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.skippedEntity(name);
  }
  public void startDocument() 
       throws org.xml.sax.SAXException
  {
    co_entry_pause();

    
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.startDocument();
  }
  public void startElement(java.lang.String namespaceURI, java.lang.String localName,
      java.lang.String qName, Attributes atts) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.startElement(namespaceURI, localName, qName, atts);
  }
  public void startPrefixMapping(java.lang.String prefix, java.lang.String uri) 
       throws org.xml.sax.SAXException
  {
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
    if(clientContentHandler!=null)
      clientContentHandler.startPrefixMapping(prefix,uri);
  }

  
  
  
  
  
  
  
  
  
  
  public void comment(char[] ch, int start, int length) 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.comment(ch,start,length);
  }
  public void endCDATA() 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.endCDATA();
  }
  public void endDTD() 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.endDTD();
  }
  public void endEntity(java.lang.String name) 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.endEntity(name);
  }
  public void startCDATA() 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.startCDATA();
  }
  public void startDTD(java.lang.String name, java.lang.String publicId,
      java.lang.String systemId) 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler. startDTD(name, publicId, systemId);
  }
  public void startEntity(java.lang.String name) 
       throws org.xml.sax.SAXException
  {
    if(null!=clientLexicalHandler)
      clientLexicalHandler.startEntity(name);
  }

  
  
  
  public void notationDecl(String a, String b, String c) throws SAXException
  {
  	if(null!=clientDTDHandler)
	  	clientDTDHandler.notationDecl(a,b,c);
  }
  public void unparsedEntityDecl(String a, String b, String c, String d)  throws SAXException
  {
  	if(null!=clientDTDHandler)
	  	clientDTDHandler.unparsedEntityDecl(a,b,c,d);
  }
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  public void error(SAXParseException exception) throws SAXException
  {
    if(null!=clientErrorHandler)
      clientErrorHandler.error(exception);
  }
  
  public void fatalError(SAXParseException exception) throws SAXException
  {
    
    
    if(null!=clientErrorHandler)
      clientErrorHandler.error(exception);

    eventcounter=0;     
    co_yield(false);

  }
  
  public void warning(SAXParseException exception) throws SAXException
  {
    if(null!=clientErrorHandler)
      clientErrorHandler.error(exception);
  }
  

  
  
  

  public int getSourceCoroutineID() {
    return fSourceCoroutineID;
  }
  public int getControllerCoroutineID() {
    return fControllerCoroutineID;
  }

  
  public CoroutineManager getCoroutineManager()
  {
    return fCoroutineManager;
  }

  
  protected void count_and_yield(boolean moreExpected) throws SAXException
  {
    if(!moreExpected) eventcounter=0;
    
    if(--eventcounter<=0)
      {
        co_yield(true);
        eventcounter=frequency;
      }
  }

  
  private void co_entry_pause() throws SAXException
  {
    if(fCoroutineManager==null)
    {
      
      init(null,-1,-1);
    }

    try
    {
      Object arg=fCoroutineManager.co_entry_pause(fSourceCoroutineID);
      if(arg==Boolean.FALSE)
        co_yield(false);
    }
    catch(NoSuchMethodException e)
    {
      
      
      if(DEBUG) e.printStackTrace();
      throw new SAXException(e);
    }
  }

  
  private void co_yield(boolean moreRemains) throws SAXException
  {
    
    if(fNoMoreEvents)
      return;

    try 
    {
      Object arg=Boolean.FALSE;
      if(moreRemains)
      {
        
        arg = fCoroutineManager.co_resume(Boolean.TRUE, fSourceCoroutineID,
                                          fControllerCoroutineID);
        
      }

      
      if(arg==Boolean.FALSE)
      {
        fNoMoreEvents=true;
        
        if(fXMLReader!=null)    
          throw new StopException(); 
        
        
        fCoroutineManager.co_exit_to(Boolean.FALSE, fSourceCoroutineID,
                                     fControllerCoroutineID);
      }
    }
    catch(NoSuchMethodException e)
    {
      
      
      fNoMoreEvents=true;
      fCoroutineManager.co_exit(fSourceCoroutineID);
      throw new SAXException(e);
    }
  }

  
  
  

  
  public void startParse(InputSource source) throws SAXException
  {
    if(fNoMoreEvents)
      throw new SAXException(XSLMessages.createMessage(XSLTErrorResources.ER_INCRSAXSRCFILTER_NOT_RESTARTABLE, null)); 
    if(fXMLReader==null)
      throw new SAXException(XSLMessages.createMessage(XSLTErrorResources.ER_XMLRDR_NOT_BEFORE_STARTPARSE, null)); 

    fXMLReaderInputSource=source;
    
    
    org.apache.xalan.transformer.TransformerImpl.runTransformThread(this);
  }
  
  
  public void run()
  {
    
    if(fXMLReader==null) return;

    if(DEBUG)System.out.println(""IncrementalSAXSource_Filter parse thread launched"");

    
    Object arg=Boolean.FALSE;

    
    
    
    
    try
    {
      fXMLReader.parse(fXMLReaderInputSource);
    }
    catch(IOException ex)
    {
      arg=ex;
    }
    catch(StopException ex)
    {
      
      if(DEBUG)System.out.println(""Active IncrementalSAXSource_Filter normal stop exception"");
    }
    catch (SAXException ex)
    {
      Exception inner=ex.getException();
      if(inner instanceof StopException){
        
        if(DEBUG)System.out.println(""Active IncrementalSAXSource_Filter normal stop exception"");
      }
      else
      {
        
        if(DEBUG)
        {
          System.out.println(""Active IncrementalSAXSource_Filter UNEXPECTED SAX exception: ""+inner);
          inner.printStackTrace();
        }                
        arg=ex;
      }
    } 
    
    
    fXMLReader=null;

    try
    {
      
      fNoMoreEvents=true;
      fCoroutineManager.co_exit_to(arg, fSourceCoroutineID,
                                   fControllerCoroutineID);
    }
    catch(java.lang.NoSuchMethodException e)
    {
      
      
      e.printStackTrace(System.err);
      fCoroutineManager.co_exit(fSourceCoroutineID);
    }
  }

  
  class StopException extends RuntimeException
  {
  }

  
  public Object deliverMoreNodes(boolean parsemore)
  {
    
    if(fNoMoreEvents)
      return Boolean.FALSE;

    try 
    {
      Object result =
        fCoroutineManager.co_resume(parsemore?Boolean.TRUE:Boolean.FALSE,
                                    fControllerCoroutineID, fSourceCoroutineID);
      if(result==Boolean.FALSE)
        fCoroutineManager.co_exit(fControllerCoroutineID);

      return result;
    }
      
    
    
    
    catch(NoSuchMethodException e)
      {
        return e;
      }
  }
  

  
  
      
} 
"
org.apache.xalan.templates.ElemWithParam,11,3,0,22,33,15,2,20,10,0.825,168,0.5,2,0.951456311,0.191919192,2,9,13.90909091,3,1.0909,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import javax.xml.transform.TransformerException;


public class ElemWithParam extends ElemTemplateElement
{
  
  int m_index;

  
  private XPath m_selectPattern = null;

  
  public void setSelect(XPath v)
  {
    m_selectPattern = v;
  }

  
  public XPath getSelect()
  {
    return m_selectPattern;
  }

  
  private QName m_qname = null;
  
  int m_qnameID;

  
  public void setName(QName v)
  {
    m_qname = v;
  }

  
  public QName getName()
  {
    return m_qname;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_WITHPARAM;
  }


  
  public String getNodeName()
  {
    return Constants.ELEMNAME_WITHPARAM_STRING;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    
    if(null == m_selectPattern  
       && org.apache.xalan.processor.TransformerFactoryImpl.m_optimize)
    {
      XPath newSelect = ElemVariable.rewriteChildToExpression(this);
      if(null != newSelect)
        m_selectPattern = newSelect;
    }
    m_qnameID = sroot.getComposeState().getQNameID(m_qname);
    super.compose(sroot);
    
    java.util.Vector vnames = sroot.getComposeState().getVariableNames();
    if(null != m_selectPattern)
      m_selectPattern.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
      
    
  }
  
  
  public void setParentElem(ElemTemplateElement p)
  {
    super.setParentElem(p);
    p.m_hasVariableDecl = true;
  }
  
  
  public XObject getValue(TransformerImpl transformer, int sourceNode)
          throws TransformerException
  {

    XObject var;
    XPathContext xctxt = transformer.getXPathContext();

    xctxt.pushCurrentNode(sourceNode);

    try
    {
      if (null != m_selectPattern)
      {
        var = m_selectPattern.execute(xctxt, sourceNode, this);

        var.allowDetachToRelease(false);

        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                  ""select"", m_selectPattern, var);
      }
      else if (null == getFirstChildElem())
      {
        var = XString.EMPTYSTRING;
      }
      else
      {

        
        int df = transformer.transformToRTF(this);

        var = new XRTreeFrag(df, xctxt, this);
      }
    }
    finally
    {
      xctxt.popCurrentNode();
    }

    return var;
  }
  
  
  protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
  {
  	if(callAttrs && (null != m_selectPattern))
  		m_selectPattern.getExpression().callVisitors(m_selectPattern, visitor);
    super.callChildVisitors(visitor, callAttrs);
  }



}
"
org.apache.xalan.xsltc.compiler.LogicalExpr,10,3,0,20,41,0,0,20,9,0.62962963,362,0.666666667,2,0.898734177,0.26984127,2,9,34.6,8,2.4,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class LogicalExpr extends Expression {

    public static final int OR  = 0;
    public static final int AND = 1;
	
    private final int  _op;     
    private Expression _left;   
    private Expression _right;  

    private static final String[] Ops = { ""or"", ""and"" };

    
    public LogicalExpr(int op, Expression left, Expression right) {
	_op = op;
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    
    public boolean hasPositionCall() {
	return (_left.hasPositionCall() || _right.hasPositionCall());
    }

    
    public Object evaluateAtCompileTime() {
	final Object leftb = _left.evaluateAtCompileTime();
	final Object rightb = _right.evaluateAtCompileTime();

	
	if (leftb == null || rightb == null) {
	    return null;
	}

	if (_op == AND) {
	    return (leftb == Boolean.TRUE && rightb == Boolean.TRUE) ?
		Boolean.TRUE : Boolean.FALSE;
	}
	else {
	    return (leftb == Boolean.TRUE || rightb == Boolean.TRUE) ?
		Boolean.TRUE : Boolean.FALSE;
	}
    }

    
    public int getOp() {
	return(_op);
    }

    
    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }

    
    public String toString() {
	return Ops[_op] + '(' + _left + "", "" + _right + ')';
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	
	Type tleft = _left.typeCheck(stable); 
	Type tright = _right.typeCheck(stable);

	
	MethodType wantType = new MethodType(Type.Void, tleft, tright);
	MethodType haveType = lookupPrimop(stable, Ops[_op], wantType);

	
	if (haveType != null) {
	    
	    Type arg1 = (Type)haveType.argsType().elementAt(0);
	    if (!arg1.identicalTo(tleft))
		_left = new CastExpr(_left, arg1);
	    
	    Type arg2 = (Type) haveType.argsType().elementAt(1);
	    if (!arg2.identicalTo(tright))
		_right = new CastExpr(_right, arg1);
	    
	    return _type = haveType.resultType();
	}
	throw new TypeCheckError(this);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	translateDesynthesized(classGen, methodGen);
	synthesize(classGen, methodGen);
    }

    
    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {

	final InstructionList il = methodGen.getInstructionList();
	final SyntaxTreeNode parent = getParent();

	
	if (_op == AND) {

	    
	    _left.translateDesynthesized(classGen, methodGen);

	    
	    InstructionHandle middle = il.append(NOP);

	    
	    _right.translateDesynthesized(classGen, methodGen);

	    
	    InstructionHandle after = il.append(NOP);

	    
	    _falseList.append(_right._falseList.append(_left._falseList));

	    
	    
	    if ((_left instanceof LogicalExpr) &&
		(((LogicalExpr)_left).getOp() == OR)) {
		_left.backPatchTrueList(middle);
	    }
	    else if (_left instanceof NotCall) {
		_left.backPatchTrueList(middle);
	    }
	    else {
		_trueList.append(_left._trueList);
	    }

	    
	    
	    if ((_right instanceof LogicalExpr) &&
		(((LogicalExpr)_right).getOp() == OR)) {
		_right.backPatchTrueList(after);
	    }
	    else if (_right instanceof NotCall) {
		_right.backPatchTrueList(after);
	    }
	    else {
		_trueList.append(_right._trueList);
	    }
	} 
	
	else {
	    
	    _left.translateDesynthesized(classGen, methodGen);

	    
	    
	    InstructionHandle ih = il.append(new GOTO(null));

	    
	    _right.translateDesynthesized(classGen, methodGen);

	    _left._trueList.backPatch(ih);
	    _left._falseList.backPatch(ih.getNext());
			
	    _falseList.append(_right._falseList);
	    _trueList.add(ih).append(_right._trueList);
	}
    }
}
"
org.apache.xalan.xsltc.runtime.SAXAdapter,26,1,0,8,42,243,1,7,25,0.693333333,205,1.0,2,0.0,0.258241758,0,0,6.769230769,1,0.9615,1,"

package org.apache.xalan.xsltc.runtime;

import org.xml.sax.*;
import org.xml.sax.ext.*;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.TransletOutputHandler;
import org.apache.xalan.xsltc.dom.DOMBuilder;

public final class SAXAdapter implements TransletOutputHandler {

    private final DOMBuilder _domBuilder;
    private final AttributeList  _attributes = new AttributeList();

    private String _openElementName;
    
    public SAXAdapter(DOMBuilder domBuilder) {
	_domBuilder = domBuilder;
    }

    private void maybeEmitStartElement() throws SAXException {
	if (_openElementName != null) {
	    _domBuilder.startElement(null, null, _openElementName, _attributes);
	    _openElementName = null;
	}
    }

    public void startDocument() throws TransletException {
	try {
	    _domBuilder.startDocument();
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }
    
    public void endDocument() throws TransletException {
	try {
	    _domBuilder.endDocument();
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }
    
    public void characters(String characters) throws TransletException {
	characters(characters.toCharArray(), 0, characters.length());
    }

    public void characters(char[] characters, int offset, int length)
	throws TransletException {
	try {
	    maybeEmitStartElement();
	    _domBuilder.characters(characters, offset, length);
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }
    
    public void startElement(String elementName) throws TransletException {
	try {
	    maybeEmitStartElement();
	    _openElementName = elementName;
	    _attributes.clear();
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }
    
    public void endElement(String elementName) throws TransletException {
	try {
	    maybeEmitStartElement();
	    _domBuilder.endElement(null, null, elementName);
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }
    
    public void attribute(String name, String value)
	throws TransletException {
	if (_openElementName != null) {
	    _attributes.add(name, value);
	}
	else {
	    BasisLibrary.runTimeError(BasisLibrary.STRAY_ATTRIBUTE_ERR, name);
	}
    }
    
    public void namespace(String prefix, String uri)
	throws TransletException {
	
    }

    public void comment(String comment) throws TransletException {
	try {
	    maybeEmitStartElement();
	    if (_domBuilder != null) {
		char[] chars = comment.toCharArray();
		_domBuilder.comment(chars, 0, chars.length);
	    }
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }
    
    public void processingInstruction(String target, String data)
	throws TransletException {
	try {
	    maybeEmitStartElement();
	    _domBuilder.processingInstruction(target, data);
	}
	catch (SAXException e) {
	    throw new TransletException(e);
	}
    }

    public boolean setEscaping(boolean escape) throws TransletException {
	return _domBuilder.setEscaping(escape);
    }

    
    public void startCDATA() throws TransletException {}
    public void endCDATA() throws TransletException {}
    public void setType(int type) {}
    public void setHeader(String header) {}
    public void setIndent(boolean indent) {}
    public void omitHeader(boolean value) {}
    public void setCdataElements(Hashtable elements) {}
    public void setDoctype(String system, String pub) {}
    public void setMediaType(String mediaType) {}
    public void setStandalone(String standalone) {}
    public void setVersion(String version) {}
    public void close() {}
    public String getPrefix(String uri) { return(""""); }
}
"
org.apache.xpath.functions.FunctionOneArg,11,3,15,33,20,0,25,8,10,0.3,113,0.0,1,0.791666667,0.345454545,2,4,9.181818182,6,1.5455,0,"
package org.apache.xpath.functions;

import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;


public class FunctionOneArg extends Function implements ExpressionOwner
{

  
  Expression m_arg0;

  
  public Expression getArg0()
  {
    return m_arg0;
  }
  
  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {

    if (0 == argNum)
    {
      m_arg0 = arg;
      arg.exprSetParent(this);
    }
    else
      reportWrongNumberArgs();
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum != 1)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""one"", null));
  }
  
  
   public boolean canTraverseOutsideSubtree()
   {
    return m_arg0.canTraverseOutsideSubtree();
   }
   
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    if(null != m_arg0)
      m_arg0.fixupVariables(vars, globalsSize);
  }
  
  
  public void callArgVisitors(XPathVisitor visitor)
  {
  	if(null != m_arg0)
  		m_arg0.callVisitors(this, visitor);
  }


  
  public Expression getExpression()
  {
    return m_arg0;
  }


  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_arg0 = exp;
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!super.deepEquals(expr))
  		return false;
  		
  	if(null != m_arg0)
  	{
  		if(null == ((FunctionOneArg)expr).m_arg0)
  			return false;
  			
  		if(!m_arg0.deepEquals(((FunctionOneArg)expr).m_arg0))
  			return false;
  	}
  	else if(null != ((FunctionOneArg)expr).m_arg0)
  		return false;

  	return true;
  }



}
"
org.apache.xpath.compiler.Compiler,45,2,0,60,111,932,24,40,15,0.568181818,1193,0.6,1,0.328125,0.175925926,0,0,25.4,12,1.2222,1,"
package org.apache.xpath.compiler;

import org.apache.xpath.operations.And;
import org.apache.xpath.operations.Bool;
import org.apache.xpath.operations.Div;
import org.apache.xpath.operations.Equals;
import org.apache.xpath.operations.Gt;
import org.apache.xpath.operations.Gte;
import org.apache.xpath.operations.Lt;
import org.apache.xpath.operations.Lte;
import org.apache.xpath.operations.Minus;
import org.apache.xpath.operations.Mod;
import org.apache.xpath.operations.Mult;
import org.apache.xpath.operations.Neg;
import org.apache.xpath.operations.NotEquals;
import org.apache.xpath.operations.Operation;
import org.apache.xpath.operations.Or;
import org.apache.xpath.operations.Plus;
import org.apache.xpath.operations.UnaryOperation;
import org.apache.xpath.operations.Variable;
import org.apache.xpath.objects.*;
import org.apache.xpath.axes.*;
import org.apache.xpath.patterns.*;
import org.apache.xpath.functions.Function;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xpath.functions.WrongNumberArgsException;
import org.apache.xpath.*;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.PrefixResolver;
import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.SourceLocator;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.Axis;

import javax.xml.transform.ErrorListener;
import javax.xml.transform.TransformerException;


public class Compiler extends OpMap
{

  
  public Compiler(ErrorListener errorHandler, SourceLocator locator)
  {
    m_errorHandler = errorHandler;
    m_locator = locator;
  }

  
  public Compiler()
  {
    m_errorHandler = null;
    m_locator = null;
  }

  
  public Expression compile(int opPos) throws TransformerException
  {

    int op = m_opMap[opPos];

    Expression expr = null;
    
    switch (op)
    {
    case OpCodes.OP_XPATH :
      expr = compile(opPos + 2); break;
    case OpCodes.OP_OR :
      expr = or(opPos); break;
    case OpCodes.OP_AND :
      expr = and(opPos); break;
    case OpCodes.OP_NOTEQUALS :
      expr = notequals(opPos); break;
    case OpCodes.OP_EQUALS :
      expr = equals(opPos); break;
    case OpCodes.OP_LTE :
      expr = lte(opPos); break;
    case OpCodes.OP_LT :
      expr = lt(opPos); break;
    case OpCodes.OP_GTE :
      expr = gte(opPos); break;
    case OpCodes.OP_GT :
      expr = gt(opPos); break;
    case OpCodes.OP_PLUS :
      expr = plus(opPos); break;
    case OpCodes.OP_MINUS :
      expr = minus(opPos); break;
    case OpCodes.OP_MULT :
      expr = mult(opPos); break;
    case OpCodes.OP_DIV :
      expr = div(opPos); break;
    case OpCodes.OP_MOD :
      expr = mod(opPos); break;


    case OpCodes.OP_NEG :
      expr = neg(opPos); break;
    case OpCodes.OP_STRING :
      expr = string(opPos); break;
    case OpCodes.OP_BOOL :
      expr = bool(opPos); break;
    case OpCodes.OP_NUMBER :
      expr = number(opPos); break;
    case OpCodes.OP_UNION :
      expr = union(opPos); break;
    case OpCodes.OP_LITERAL :
      expr = literal(opPos); break;
    case OpCodes.OP_VARIABLE :
      expr = variable(opPos); break;
    case OpCodes.OP_GROUP :
      expr = group(opPos); break;
    case OpCodes.OP_NUMBERLIT :
      expr = numberlit(opPos); break;
    case OpCodes.OP_ARGUMENT :
      expr = arg(opPos); break;
    case OpCodes.OP_EXTFUNCTION :
      expr = compileExtension(opPos); break;
    case OpCodes.OP_FUNCTION :
      expr = compileFunction(opPos); break;
    case OpCodes.OP_LOCATIONPATH :
      expr = locationPath(opPos); break;
    case OpCodes.OP_PREDICATE :
      expr = null; break;  
    case OpCodes.OP_MATCHPATTERN :
      expr = matchPattern(opPos + 2); break;
    case OpCodes.OP_LOCATIONPATHPATTERN :
      expr = locationPathPattern(opPos); break;
    case OpCodes.OP_QUO:
      error(XPATHErrorResources.ER_UNKNOWN_OPCODE,
            new Object[]{ ""quo"" });  
      break;
    default :
      error(XPATHErrorResources.ER_UNKNOWN_OPCODE,
            new Object[]{ Integer.toString(m_opMap[opPos]) });  
    }



    return expr;
  }

  
  private Expression compileOperation(Operation operation, int opPos)
          throws TransformerException
  {

    int leftPos = getFirstChildPos(opPos);
    int rightPos = getNextOpPos(leftPos);

    operation.setLeftRight(compile(leftPos), compile(rightPos));

    return operation;
  }

  
  private Expression compileUnary(UnaryOperation unary, int opPos)
          throws TransformerException
  {

    int rightPos = getFirstChildPos(opPos);

    unary.setRight(compile(rightPos));

    return unary;
  }

  
  protected Expression or(int opPos) throws TransformerException
  {
    return compileOperation(new Or(), opPos);
  }

  
  protected Expression and(int opPos) throws TransformerException
  {
    return compileOperation(new And(), opPos);
  }

  
  protected Expression notequals(int opPos) throws TransformerException
  {
    return compileOperation(new NotEquals(), opPos);
  }

  
  protected Expression equals(int opPos) throws TransformerException
  {
    return compileOperation(new Equals(), opPos);
  }

  
  protected Expression lte(int opPos) throws TransformerException
  {
    return compileOperation(new Lte(), opPos);
  }

  
  protected Expression lt(int opPos) throws TransformerException
  {
    return compileOperation(new Lt(), opPos);
  }

  
  protected Expression gte(int opPos) throws TransformerException
  {
    return compileOperation(new Gte(), opPos);
  }

  
  protected Expression gt(int opPos) throws TransformerException
  {
    return compileOperation(new Gt(), opPos);
  }

  
  protected Expression plus(int opPos) throws TransformerException
  {
    return compileOperation(new Plus(), opPos);
  }

  
  protected Expression minus(int opPos) throws TransformerException
  {
    return compileOperation(new Minus(), opPos);
  }

  
  protected Expression mult(int opPos) throws TransformerException
  {
    return compileOperation(new Mult(), opPos);
  }

  
  protected Expression div(int opPos) throws TransformerException
  {
    return compileOperation(new Div(), opPos);
  }

  
  protected Expression mod(int opPos) throws TransformerException
  {
    return compileOperation(new Mod(), opPos);
  }

  





  
  protected Expression neg(int opPos) throws TransformerException
  {
    return compileUnary(new Neg(), opPos);
  }

  
  protected Expression string(int opPos) throws TransformerException
  {
    return compileUnary(new org.apache.xpath.operations.String(), opPos);
  }

  
  protected Expression bool(int opPos) throws TransformerException
  {
    return compileUnary(new org.apache.xpath.operations.Bool(), opPos);
  }

  
  protected Expression number(int opPos) throws TransformerException
  {
    return compileUnary(new org.apache.xpath.operations.Number(), opPos);
  }

  
  protected Expression literal(int opPos)
  {

    opPos = getFirstChildPos(opPos);

    return (XString) m_tokenQueue[m_opMap[opPos]];
  }

  
  protected Expression numberlit(int opPos)
  {

    opPos = getFirstChildPos(opPos);

    return (XNumber) m_tokenQueue[m_opMap[opPos]];
  }

  
  protected Expression variable(int opPos) throws TransformerException
  {

    Variable var = new Variable();

    opPos = getFirstChildPos(opPos);

    int nsPos = m_opMap[opPos];
    java.lang.String namespace 
      = (OpCodes.EMPTY == nsPos) ? null 
                                   : (java.lang.String) m_tokenQueue[nsPos];
    java.lang.String localname 
      = (java.lang.String) m_tokenQueue[m_opMap[opPos+1]];
    QName qname = new QName(namespace, localname);

    var.setQName(qname);

    return var;
  }

  
  protected Expression group(int opPos) throws TransformerException
  {

    
    return compile(opPos + 2);
  }

  
  protected Expression arg(int opPos) throws TransformerException
  {

    
    return compile(opPos + 2);
  }

  
  protected Expression union(int opPos) throws TransformerException
  {
    locPathDepth++;
    try
    {
      return UnionPathIterator.createUnionIterator(this, opPos);
    }
    finally
    {
      locPathDepth--;
    }
  }
  
  private int locPathDepth = -1;
  
  
  public int getLocationPathDepth()
  {
    return locPathDepth;
  }

  
  public Expression locationPath(int opPos) throws TransformerException
  {
    locPathDepth++;
    try
    {
      DTMIterator iter = WalkerFactory.newDTMIterator(this, opPos, (locPathDepth == 0));
      return (Expression)iter; 
    }
    finally
    {
      locPathDepth--;
    }
  }

  
  public Expression predicate(int opPos) throws TransformerException
  {
    return compile(opPos + 2);
  }

  
  protected Expression matchPattern(int opPos) throws TransformerException
  {
    locPathDepth++;
    try
    {
      
      int nextOpPos = opPos;
      int i;

      for (i = 0; m_opMap[nextOpPos] == OpCodes.OP_LOCATIONPATHPATTERN; i++)
      {
        nextOpPos = getNextOpPos(nextOpPos);
      }

      if (i == 1)
        return compile(opPos);

      UnionPattern up = new UnionPattern();
      StepPattern[] patterns = new StepPattern[i];

      for (i = 0; m_opMap[opPos] == OpCodes.OP_LOCATIONPATHPATTERN; i++)
      {
        nextOpPos = getNextOpPos(opPos);
        patterns[i] = (StepPattern) compile(opPos);
        opPos = nextOpPos;
      }

      up.setPatterns(patterns);

      return up;
    }
    finally
    {
      locPathDepth--;
    }
  }

  
  public Expression locationPathPattern(int opPos)
          throws TransformerException
  {

    opPos = getFirstChildPos(opPos);

    return stepPattern(opPos, 0, null);
  }

  
  public int getWhatToShow(int opPos)
  {

    int axesType = getOp(opPos);
    int testType = getOp(opPos + 3);

    
    switch (testType)
    {
    case OpCodes.NODETYPE_COMMENT :
      return DTMFilter.SHOW_COMMENT;
    case OpCodes.NODETYPE_TEXT :

      return DTMFilter.SHOW_TEXT | DTMFilter.SHOW_CDATA_SECTION ;
    case OpCodes.NODETYPE_PI :
      return DTMFilter.SHOW_PROCESSING_INSTRUCTION;
    case OpCodes.NODETYPE_NODE :

      switch (axesType)
      {
      case OpCodes.FROM_NAMESPACE:
        return DTMFilter.SHOW_NAMESPACE;
      case OpCodes.FROM_ATTRIBUTES :
      case OpCodes.MATCH_ATTRIBUTE :
        return DTMFilter.SHOW_ATTRIBUTE;
      case OpCodes.FROM_SELF:
      case OpCodes.FROM_ANCESTORS_OR_SELF:
      case OpCodes.FROM_DESCENDANTS_OR_SELF:
        return DTMFilter.SHOW_ALL;
      default:
        if (getOp(0) == OpCodes.OP_MATCHPATTERN)
          return ~DTMFilter.SHOW_ATTRIBUTE
                  & ~DTMFilter.SHOW_DOCUMENT
                  & ~DTMFilter.SHOW_DOCUMENT_FRAGMENT;
        else
          return ~DTMFilter.SHOW_ATTRIBUTE;
      }
    case OpCodes.NODETYPE_ROOT :
      return DTMFilter.SHOW_DOCUMENT | DTMFilter.SHOW_DOCUMENT_FRAGMENT;
    case OpCodes.NODETYPE_FUNCTEST :
      return NodeTest.SHOW_BYFUNCTION;
    case OpCodes.NODENAME :
      switch (axesType)
      {
      case OpCodes.FROM_NAMESPACE :
        return DTMFilter.SHOW_NAMESPACE;
      case OpCodes.FROM_ATTRIBUTES :
      case OpCodes.MATCH_ATTRIBUTE :
        return DTMFilter.SHOW_ATTRIBUTE;

      
      case OpCodes.MATCH_ANY_ANCESTOR :
      case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
        return DTMFilter.SHOW_ELEMENT;

      
      default :
        return DTMFilter.SHOW_ELEMENT;
      }
    default :
      
      return DTMFilter.SHOW_ALL;
    }
  }
  
private static final boolean DEBUG = false;

  
  protected StepPattern stepPattern(
          int opPos, int stepCount, StepPattern ancestorPattern)
            throws TransformerException
  {

    int startOpPos = opPos;
    int stepType = getOpMap()[opPos];

    if (OpCodes.ENDOP == stepType)
    {
      return null;
    }
    
    boolean addMagicSelf = true;

    int endStep = getNextOpPos(opPos);

    
    StepPattern pattern;
    
    
    int argLen;

    switch (stepType)
    {
    case OpCodes.OP_FUNCTION :
      if(DEBUG)
        System.out.println(""MATCH_FUNCTION: ""+m_currentPattern); 
      addMagicSelf = false;
      argLen = m_opMap[opPos + OpMap.MAPINDEX_LENGTH];
      pattern = new FunctionPattern(compileFunction(opPos), Axis.PARENT, Axis.CHILD);
      break;
    case OpCodes.FROM_ROOT :
      if(DEBUG)
        System.out.println(""FROM_ROOT, ""+m_currentPattern);
      addMagicSelf = false;
      argLen = getArgLengthOfStep(opPos);
      opPos = getFirstChildPosOfStep(opPos);
      pattern = new StepPattern(DTMFilter.SHOW_DOCUMENT | 
                                DTMFilter.SHOW_DOCUMENT_FRAGMENT,
                                Axis.PARENT, Axis.CHILD);
      break;
    case OpCodes.MATCH_ATTRIBUTE :
     if(DEBUG)
        System.out.println(""MATCH_ATTRIBUTE: ""+getStepLocalName(startOpPos)+"", ""+m_currentPattern);
      argLen = getArgLengthOfStep(opPos);
      opPos = getFirstChildPosOfStep(opPos);
      pattern = new StepPattern(DTMFilter.SHOW_ATTRIBUTE,
                                getStepNS(startOpPos),
                                getStepLocalName(startOpPos),
                                Axis.PARENT, Axis.ATTRIBUTE);
      break;
    case OpCodes.MATCH_ANY_ANCESTOR :
      if(DEBUG)
        System.out.println(""MATCH_ANY_ANCESTOR: ""+getStepLocalName(startOpPos)+"", ""+m_currentPattern);
      argLen = getArgLengthOfStep(opPos);
      opPos = getFirstChildPosOfStep(opPos);
      int what = getWhatToShow(startOpPos);
      
      if(0x00000500 == what)
        addMagicSelf = false;
      pattern = new StepPattern(getWhatToShow(startOpPos),
                                        getStepNS(startOpPos),
                                        getStepLocalName(startOpPos),
                                        Axis.ANCESTOR, Axis.CHILD);
      break;
    case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
      if(DEBUG)
        System.out.println(""MATCH_IMMEDIATE_ANCESTOR: ""+getStepLocalName(startOpPos)+"", ""+m_currentPattern);
      argLen = getArgLengthOfStep(opPos);
      opPos = getFirstChildPosOfStep(opPos);
      pattern = new StepPattern(getWhatToShow(startOpPos),
                                getStepNS(startOpPos),
                                getStepLocalName(startOpPos),
                                Axis.PARENT, Axis.CHILD);
      break;
    default :
      error(XPATHErrorResources.ER_UNKNOWN_MATCH_OPERATION, null);  

      return null;
    }

    pattern.setPredicates(getCompiledPredicates(opPos + argLen));
    if(null == ancestorPattern)
    {
      
      
      
      
      
      
      
      
      
	
    }
    else
    {
      
      pattern.setRelativePathPattern(ancestorPattern);
    }

    StepPattern relativePathPattern = stepPattern(endStep, stepCount + 1,
                                        pattern);

    return (null != relativePathPattern) ? relativePathPattern : pattern;
  }

  
  public Expression[] getCompiledPredicates(int opPos)
          throws TransformerException
  {

    int count = countPredicates(opPos);

    if (count > 0)
    {
      Expression[] predicates = new Expression[count];

      compilePredicates(opPos, predicates);

      return predicates;
    }

    return null;
  }

  
  public int countPredicates(int opPos) throws TransformerException
  {

    int count = 0;

    while (OpCodes.OP_PREDICATE == getOp(opPos))
    {
      count++;

      opPos = getNextOpPos(opPos);
    }

    return count;
  }

  
  private void compilePredicates(int opPos, Expression[] predicates)
          throws TransformerException
  {

    for (int i = 0; OpCodes.OP_PREDICATE == getOp(opPos); i++)
    {
      predicates[i] = predicate(opPos);
      opPos = getNextOpPos(opPos);
    }
  }

  
  Expression compileFunction(int opPos) throws TransformerException
  {

    int endFunc = opPos + m_opMap[opPos + 1] - 1;

    opPos = getFirstChildPos(opPos);

    int funcID = m_opMap[opPos];

    opPos++;

    if (-1 != funcID)
    {
      Function func = FunctionTable.getFunction(funcID);

      func.postCompileStep(this);
      
      try
      {
        int i = 0;

        for (int p = opPos; p < endFunc; p = getNextOpPos(p), i++)
        {

          
          
          func.setArg(compile(p), i);
        }

        func.checkNumberArgs(i);
      }
      catch (WrongNumberArgsException wnae)
      {
        java.lang.String name = FunctionTable.m_functions[funcID].getName();

        m_errorHandler.fatalError( new TransformerException(
                  XSLMessages.createXPATHMessage(XPATHErrorResources.ER_ONLY_ALLOWS, 
                      new Object[]{name, wnae.getMessage()}), m_locator)); 
              
      }

      return func;
    }
    else
    {
      error(XPATHErrorResources.ER_FUNCTION_TOKEN_NOT_FOUND, null);  

      return null;
    }
  }

  
  private Expression compileExtension(int opPos)
          throws TransformerException
  {

    int endExtFunc = opPos + m_opMap[opPos + 1] - 1;

    opPos = getFirstChildPos(opPos);

    java.lang.String ns = (java.lang.String) m_tokenQueue[m_opMap[opPos]];

    opPos++;

    java.lang.String funcName =
      (java.lang.String) m_tokenQueue[m_opMap[opPos]];

    opPos++;

    
    
    

    Function extension = new FuncExtFunction(ns, funcName, 
         String.valueOf(opPos)
       + String.valueOf(hashCode())
       + String.valueOf(System.currentTimeMillis()));

    try
    {
      int i = 0;

      while (opPos < endExtFunc)
      {
        int nextOpPos = getNextOpPos(opPos);

        extension.setArg(this.compile(opPos), i);

        opPos = nextOpPos;

        i++;
      }
    }
    catch (WrongNumberArgsException wnae)
    {
      ;  
    }

    return extension;
  }

  
  public void warn(int msg, Object[] args) throws TransformerException
  {

    java.lang.String fmsg = XSLMessages.createXPATHWarning(msg, args);

    if (null != m_errorHandler)
    {
      m_errorHandler.warning(new TransformerException(fmsg, m_locator));
    }
    else
    {
      System.out.println(fmsg
                          +""; file ""+m_locator.getSystemId()
                          +""; line ""+m_locator.getLineNumber()
                          +""; column ""+m_locator.getColumnNumber());
    }
  }

  
  public void assertion(boolean b, java.lang.String msg)
  {

    if (!b)
    {
      java.lang.String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ msg });

      throw new RuntimeException(fMsg);
    }
  }

  
  public void error(int msg, Object[] args) throws TransformerException
  {

    java.lang.String fmsg = XSLMessages.createXPATHMessage(msg, args);
    

    if (null != m_errorHandler)
    {
      m_errorHandler.fatalError(new TransformerException(fmsg, m_locator));
    }
    else
    {

      
      
      
      
      throw new TransformerException(fmsg, (SAXSourceLocator)m_locator);
    }
  }

  
  private PrefixResolver m_currentPrefixResolver = null;

  
  public PrefixResolver getNamespaceContext()
  {
    return m_currentPrefixResolver;
  }

  
  public void setNamespaceContext(PrefixResolver pr)
  {
    m_currentPrefixResolver = pr;
  }

  
  ErrorListener m_errorHandler;

  
  SourceLocator m_locator;
}
"
org.apache.xalan.xsltc.util.IntegerArray,19,1,0,4,25,0,4,0,18,0.513888889,256,1.0,0,0.0,0.394736842,0,0,12.26315789,3,1.2105,1,"

package org.apache.xalan.xsltc.util;

public final class IntegerArray {
    private static final int InitialSize = 32;
    
    private int[] _array;
    private int   _size;
    private int   _free = 0;
  
    public IntegerArray() {
	this(InitialSize);
    }
  
    public IntegerArray(int size) {
	_array = new int[_size = size];
    }

    public IntegerArray(int[] array) {
	this(array.length);
	System.arraycopy(array, 0, _array, 0, _free = _size);
    }

    public void clear() {
	_free = 0;
    }

    public Object clone() {
	final IntegerArray clone = new IntegerArray(_array);
	clone._free = _free;
	return clone;
    }

    public int[] toIntArray() {
	final int[] result = new int[cardinality()];
	System.arraycopy(_array, 0, result, 0, cardinality());
	return result;
    }

    public final int at(int index) {
	return _array[index];
    }

    public final void set(int index, int value) {
	_array[index] = value;
    }

    public int indexOf(int n) {
	for (int i = 0; i < _free; i++) {
	    if (n == _array[i]) return i;
	}
	return -1;
    }

    public final void add(int value) {
	if (_free == _size) {
	    growArray(_size * 2);
	}
	_array[_free++] = value;
    }
  
    
    public void addNew(int value) {
	for (int i = 0; i < _free; i++) {
	    if (_array[i] == value) return;  
	}
	add(value);
    }

    private void growArray(int size) {
	final int[] newArray = new int[_size = size];
	System.arraycopy(_array, 0, newArray, 0, _free);
	_array = newArray;
    }

    public int popLast() {
	return _array[--_free];
    }

    public int last() {
	return _array[_free - 1];
    }

    public void setLast(int n) {
	_array[_free - 1] = n;
    }

    public void pop() {
	_free--;
    }

    public void pop(int n) {
	_free -= n;
    }
  
    public final int cardinality() {
	return _free;
    }

    public void print(java.io.PrintStream out) {
	if (_free > 0) {
	    for (int i = 0; i < _free - 1; i++) {
		out.print(_array[i]);
		out.print(' ');
	    }
	    out.println(_array[_free - 1]);
	}
	else {
	    out.println(""IntegerArray: empty"");
	}
    }
}
"
org.apache.xml.utils.synthetic.Class,65,1,0,7,134,508,6,5,59,0.7375,2306,0.85,12,0.0,0.1515625,0,0,34.16923077,18,1.8462,0,"
package org.apache.xml.utils.synthetic;

import org.apache.xml.utils.synthetic.SynthesisException;
import org.apache.xml.utils.synthetic.reflection.Constructor;
import org.apache.xml.utils.synthetic.reflection.Method;
import org.apache.xml.utils.synthetic.reflection.Field;

import java.lang.reflect.Modifier;




public class Class extends Object implements java.io.Serializable
{

  
  private static java.util.Hashtable global_classtable =
    new java.util.Hashtable();

  
  private java.lang.String name;

  
  private java.lang.Class realclass = null;

  
  private int modifiers;

  
  private boolean isInterface = false;

  
  private Class superclass = null;

  
  private Class declaringclass = null;

  
  private Class[] interfaces = new Class[0];

  
  private Class[] allclasses = new Class[0];

  
  private Class[] declaredclasses = new Class[0];

  
  private Constructor[] allconstructors = new Constructor[0];

  
  private Constructor[] declaredconstructors = new Constructor[0];

  
  private Method[] allmethods = new Method[0];

  
  private Method[] declaredmethods = new Method[0];

  
  private Field[] allfields = new Field[0];

  
  private Field[] declaredfields = new Field[0];

  
  private Class[] innerclasses = new Class[0];

  
  Class(java.lang.Class realclass)
  {

    this(realclass.getName());

    try
    {
      setRealClass(realclass);
    }
    catch (SynthesisException e)
    {
      e.printStackTrace();
    }
  }

  
  Class(String fullname)
  {

    this.name = fullname;

    global_classtable.put(fullname, this);
  }

  
  public static Class forClass(java.lang.Class cls)
  {

    if (cls == null)
      return null;

    Class ret = (Class) (global_classtable.get(cls.getName()));

    if (null == ret)
      ret = new Class(cls);

    return ret;
  }

  
  public Class forNameInContext(String classname)
          throws ClassNotFoundException
  {

    for (int i = innerclasses.length - 1; i >= 0; --i)
    {
      if (classname.equals(innerclasses[i].getShortName()))
        return innerclasses[i];
    }

    return forName(classname);
  }

  
  public static Class forName(String className) throws ClassNotFoundException
  {

    
    
    
    if (className.endsWith(""]""))
    {
      StringBuffer arrayname = new StringBuffer();

      for (int i = className.indexOf('['); i != -1;
              i = className.indexOf('[', i + 1))
      {
        arrayname.append('[');
      }

      
      
      
      
      String classname = className.substring(0, className.indexOf('['));

      if (""byte"".equals(classname))
        arrayname.append('B');
      else if (""char"".equals(classname))
        arrayname.append('C');
      else if (""double"".equals(classname))
        arrayname.append('D');
      else if (""float"".equals(classname))
        arrayname.append('F');
      else if (""int"".equals(classname))
        arrayname.append('I');
      else if (""long"".equals(classname))
        arrayname.append('J');
      else if (""short"".equals(classname))
        arrayname.append('S');
      else if (""boolean"".equals(classname))
        arrayname.append('Z');
      else
        arrayname.append('L').append(classname).append(';');

      
      return forName(arrayname.toString());
    }

    Class ret = (Class) (global_classtable.get(className));

    if (null == ret)
    {

      
      
      
      if (""boolean"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Boolean.TYPE;
      }
      else if (""byte"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Byte.TYPE;
      }
      else if (""char"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Character.TYPE;
      }
      else if (""short"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Short.TYPE;
      }
      else if (""int"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Integer.TYPE;
      }
      else if (""long"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Long.TYPE;
      }
      else if (""float"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Float.TYPE;
      }
      else if (""double"".equals(className))
      {
        ret = new Class(className);
        ret.realclass = java.lang.Double.TYPE;
      }
      else if (""void"".equals(className))
      {

        
        
        ret = new Class(className);
        ret.realclass = java.lang.Class.forName(""java.lang.Object"");
      }

      
      
      
      else
        ret = new Class(java.lang.Class.forName(className));
    }

    return ret;
  }

  
  public static Class declareClass(String className) throws SynthesisException
  {

    Class ret = (Class) (global_classtable.get(className));

    if (null == ret)
      ret = new Class(className);

    if (ret.realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    return ret;
  }

  
  public static Class reallyDeclareClass(String className)
  {

    Class ret = (Class) (global_classtable.get(className));

    if (null != ret)
      global_classtable.remove(ret);

    ret = new Class(className);

    return ret;
  }

  
  public Class[] getClasses()
  {

    if (realclass != null && allclasses == null)
    {
      java.lang.Class[] realDE = realclass.getClasses();

      allclasses = new Class[realDE.length];

      for (int i = 0; i < realDE.length; ++i)
      {
        allclasses[i] = forClass(realDE[i]);
      }
    }

    return allclasses;
  }

  
  public ClassLoader getClassLoader()
  {
    return (realclass == null) ? null : realclass.getClassLoader();
  }

  
  public Class getComponentType()
  {
    return realclass == null ? null : new Class(realclass.getComponentType());
  }

  
  public Constructor getConstructor(Class parameterTypes[])
          throws NoSuchMethodException, SecurityException, SynthesisException
  {

    if (realclass == null)
      throw new SynthesisException(SynthesisException.UNREIFIED);

    java.lang.Class[] real = new java.lang.Class[parameterTypes.length];

    for (int i = 0; i < parameterTypes.length; ++i)
    {
      if ((real[i] = parameterTypes[i].getRealClass()) == null)
        throw new SynthesisException(SynthesisException.UNREIFIED);
    }

    return new Constructor(realclass.getConstructor(real), this);
  }

  
  public Constructor[] getConstructors() throws SecurityException
  {

    if (realclass != null && allconstructors == null)
    {
      java.lang.reflect.Constructor[] realDC = realclass.getConstructors();

      allconstructors = new Constructor[realDC.length];

      for (int i = 0; i < realDC.length; ++i)
      {
        allconstructors[i] = new Constructor(realDC[i], this);
      }
    }

    return allconstructors;
  }

  
  public Class[] getDeclaredClasses() throws SecurityException
  {

    
    if (realclass != null && declaredclasses == null)
    {
      java.lang.Class[] realDE = realclass.getDeclaredClasses();

      declaredclasses = new Class[realDE.length];

      for (int i = 0; i < realDE.length; ++i)
      {
        declaredclasses[i] = forClass(realDE[i]);

        if (!realDE[i].isInterface())
          superclass = declaredclasses[i];
      }
    }

    return declaredclasses;
  }

  
  public void addExtends(Class newclass) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Class[] scratch = new Class[declaredclasses.length + 1];

    System.arraycopy(declaredclasses, 0, scratch, 0, declaredclasses.length);

    scratch[declaredclasses.length] = newclass;
    declaredclasses = scratch;
  }

  
  public Constructor getDeclaredConstructor(Class parameterTypes[])
          throws NoSuchMethodException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Constructor declareConstructor() throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Constructor newctor = new Constructor(this);
    Constructor[] scratch = new Constructor[declaredconstructors.length + 1];

    System.arraycopy(declaredconstructors, 0, scratch, 0,
                     declaredconstructors.length);

    scratch[declaredconstructors.length] = newctor;
    declaredconstructors = scratch;
    scratch = new Constructor[allconstructors.length + 1];

    System.arraycopy(allconstructors, 0, scratch, 0, allconstructors.length);

    scratch[allconstructors.length] = newctor;
    allconstructors = scratch;

    return newctor;
  }

  
  public Class declareInterface(Class newifce) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    if (!newifce.isInterface())
      throw new SynthesisException(SynthesisException.SYNTAX,
                                   newifce.getName() + "" isn't an interface"");

    Class[] scratch = new Class[interfaces.length + 1];

    System.arraycopy(interfaces, 0, scratch, 0, interfaces.length);

    scratch[interfaces.length] = newifce;
    interfaces = scratch;
    scratch = new Class[allclasses.length + 1];

    System.arraycopy(allclasses, 0, scratch, 0, allclasses.length);

    scratch[allclasses.length] = newifce;
    allclasses = scratch;

    return newifce;
  }

  
  public Constructor[] getDeclaredConstructors() throws SecurityException
  {

    if (realclass != null && declaredconstructors == null)
    {
      java.lang.reflect.Constructor[] realDC =
        realclass.getDeclaredConstructors();

      declaredconstructors = new Constructor[realDC.length];

      for (int i = 0; i < realDC.length; ++i)
      {
        declaredconstructors[i] = new Constructor(realDC[i], this);
      }
    }

    return declaredconstructors;
  }

  
  public Field getDeclaredField(String name)
          throws NoSuchFieldException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Field declareField(String name) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Field newfield = new Field(name, this);
    Field[] scratch = new Field[declaredfields.length + 1];

    System.arraycopy(declaredfields, 0, scratch, 0, declaredfields.length);

    scratch[declaredfields.length] = newfield;
    declaredfields = scratch;
    scratch = new Field[allfields.length + 1];

    System.arraycopy(allfields, 0, scratch, 0, allfields.length);

    scratch[allfields.length] = newfield;
    allfields = scratch;

    return newfield;
  }

  
  public Field[] getDeclaredFields() throws SecurityException
  {

    if (realclass != null && declaredfields == null)
    {
      java.lang.reflect.Field[] realDF = realclass.getDeclaredFields();

      declaredfields = new Field[realDF.length];

      for (int i = 0; i < realDF.length; ++i)
      {
        declaredfields[i] = new Field(realDF[i], this);
      }
    }

    return declaredfields;
  }

  
  public Method getDeclaredMethod(String name, Class parameterTypes[])
          throws NoSuchMethodException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Method declareMethod(String name) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Method newMethod = new Method(name, this);
    Method[] scratch = new Method[declaredmethods.length + 1];

    System.arraycopy(declaredmethods, 0, scratch, 0, declaredmethods.length);

    scratch[declaredmethods.length] = newMethod;
    declaredmethods = scratch;
    scratch = new Method[allmethods.length + 1];

    System.arraycopy(allmethods, 0, scratch, 0, allmethods.length);

    scratch[allmethods.length] = newMethod;
    allmethods = scratch;

    return newMethod;
  }

  
  public Method[] getDeclaredMethods() throws SecurityException
  {

    if (realclass != null && declaredmethods == null)
    {
      java.lang.reflect.Method[] realDM = realclass.getDeclaredMethods();

      declaredmethods = new Method[realDM.length];

      for (int i = 0; i < realDM.length; ++i)
      {
        declaredmethods[i] = new Method(realDM[i], this);
      }
    }

    return declaredmethods;
  }

  
  public Class getDeclaringClass()
  {

    if (realclass != null && declaringclass == null)
    {
      java.lang.Class dc = realclass.getDeclaringClass();

      if (dc == null)
        declaringclass = null;
      else
        declaringclass = forClass(dc);
    }

    return declaringclass;
  }

  
  private void addInnerClass(Class newclass) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    if (newclass.getDeclaringClass() != this)
      throw new SynthesisException(SynthesisException.WRONG_OWNER);

    Class[] scratch = new Class[innerclasses.length + 1];

    System.arraycopy(innerclasses, 0, scratch, 0, innerclasses.length);

    scratch[innerclasses.length] = newclass;
    innerclasses = scratch;
  }

  
  public Class declareInnerClass(String className) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    String relativeName = getName() + ""$"" + className;
    Class newclass = (Class) (global_classtable.get(relativeName));

    if (newclass != null)
      throw new SynthesisException(SynthesisException.SYNTAX,
                                   ""Inner class "" + name + "" already exists"");

    newclass = new Class(className);
    newclass.declaringclass = this;

    Class[] scratch = new Class[innerclasses.length + 1];

    System.arraycopy(innerclasses, 0, scratch, 0, innerclasses.length);

    scratch[innerclasses.length] = newclass;
    innerclasses = scratch;

    return newclass;
  }

  
  public Class[] getInnerClasses()
  {
    return innerclasses;
  }

  
  public Field getField(String name)
          throws NoSuchFieldException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Field[] getFields() throws SecurityException
  {

    if (realclass != null && allfields == null)
    {
      java.lang.reflect.Field[] realDF = realclass.getFields();

      allfields = new Field[realDF.length];

      for (int i = 0; i < realDF.length; ++i)
      {
        allfields[i] = new Field(realDF[i], this);
      }
    }

    return allfields;
  }

  
  public Class[] getInterfaces()
  {

    if (realclass != null && interfaces == null)
    {
      java.lang.Class[] realI = realclass.getInterfaces();

      interfaces = new Class[realI.length];

      for (int i = 0; i < realI.length; ++i)
      {
        interfaces[i] = forClass(realI[i]);
      }
    }

    return interfaces;
  }

  
  public void addImplements(Class newclass) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    Class[] scratch = new Class[interfaces.length + 1];

    System.arraycopy(interfaces, 0, scratch, 0, interfaces.length);

    scratch[interfaces.length] = newclass;
    interfaces = scratch;
  }

  
  public Method getMethod(String name, Class parameterTypes[])
          throws NoSuchMethodException, SecurityException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Method[] getMethods() throws SecurityException
  {

    if (realclass != null && allmethods == null)
    {
      java.lang.reflect.Method[] realDM = realclass.getMethods();

      allmethods = new Method[realDM.length];

      for (int i = 0; i < realDM.length; ++i)
      {
        allmethods[i] = new Method(realDM[i], this);
      }
    }

    return allmethods;
  }

  
  public int getModifiers()
  {
    return modifiers;
  }

  
  public void setModifiers(int modifiers) throws SynthesisException
  {

    if (this.realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.modifiers = modifiers;
  }

  
  public java.lang.String getName()
  {
    return name;
  }

  
  public java.lang.String getJavaName()
  {

    if (name.charAt(0) != '[')
      return name;

    
    
    int count = name.lastIndexOf('[');
    StringBuffer jname = new StringBuffer(name.substring(count + 2));

    
    jname.setLength(jname.length() - 1);

    while (count-- >= 0)
    {
      jname.append(""[]"");
    }

    return jname.toString();
  }

  
  public java.lang.String getShortName()
  {

    int start = name.lastIndexOf(""."");

    if (start != 0 || name.charAt(0) == '.')
      ++start;

    if (declaringclass != null)
    {
      int d = name.lastIndexOf('$', start);

      if (d != 0)
        start = d + 1;
    }

    return name.substring(start);
  }

  
  public java.lang.String getJavaShortName()
  {

    String shortname = getShortName();

    if (shortname.charAt(0) != '[')
      return shortname;

    
    
    int count = shortname.lastIndexOf('[');
    StringBuffer jname = new StringBuffer(shortname.substring(count + 2));

    
    jname.setLength(jname.length() - 1);

    while (count-- >= 0)
    {
      jname.append(""[]"");
    }

    return jname.toString();
  }

  
  public java.lang.String getPackageName()
  {

    int start = name.lastIndexOf(""."");

    return name.substring(0, start);
  }

  
  public java.lang.Class getRealClass()
  {
    return realclass;
  }

  
  public void setRealClass(java.lang.Class realclass)
          throws SynthesisException
  {

    if (this.realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.realclass = realclass;
    this.modifiers = realclass.getModifiers();
    this.isInterface = realclass.isInterface();

    
    this.declaringclass = null;
    this.interfaces = null;
    this.declaredconstructors = null;
    this.allconstructors = null;
    this.declaredmethods = null;
    this.allmethods = null;
    this.declaredfields = null;
    this.allfields = null;
    this.declaredclasses = null;
    this.allclasses = null;
    this.superclass = null;
  }

  
  public void setSuperClass(Class superclass) throws SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.superclass = superclass;
  }

  
  public void setSuperClass(java.lang.Class superclass)
          throws ClassNotFoundException, SynthesisException
  {

    if (realclass != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.superclass = Class.forClass(superclass);
  }

  
  public java.net.URL getResource(String name)
  {
    throw new java.lang.IllegalStateException();
  }

  
  public java.io.InputStream getResourceAsStream(String name)
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Object[] getSigners()
  {
    throw new java.lang.IllegalStateException();
  }

  
  public Class getSuperclass()
  {

    if (realclass != null && superclass == null)
    {
      superclass = forClass(realclass.getSuperclass());

      
    }

    if (superclass == null)
      superclass = forClass(Object.class);

    return superclass;
  }

  
  public boolean isArray()
  {
    return realclass != null && realclass.isArray();
  }

  
  public boolean isAssignableFrom(Class cls)
  {

    if (realclass != null && cls.realclass != null)
      return realclass.isAssignableFrom(cls.realclass);

    throw new java.lang.IllegalStateException();
  }

  
  public boolean isAssignableFrom(java.lang.Class cls)
  {

    if (realclass != null)
      return realclass.isAssignableFrom((java.lang.Class) cls);

    throw new java.lang.IllegalStateException();
  }

  
  public boolean isInstance(Object obj)
  {

    if (realclass != null)
      return realclass.isInstance(obj);

    
    
    throw new java.lang.IllegalStateException();
  }

  
  public boolean isInterface()
  {
    return (realclass != null) ? realclass.isInterface() : isInterface;
  }

  
  public void isInterface(boolean isInterface) throws SynthesisException
  {

    if (realclass == null)
      this.isInterface = isInterface;
    else if (realclass.isInterface() != isInterface)
      throw new SynthesisException(SynthesisException.REIFIED);
  }

  
  public boolean isPrimitive()
  {
    return realclass != null && realclass.isPrimitive();
  }

  
  public Object newInstance()
          throws InstantiationException, IllegalAccessException
  {
    throw new java.lang.IllegalStateException();
  }

  
  public String toString()
  {

    if (realclass != null)
      return realclass.toString();
    else if (isInterface())
      return ""interface "" + name;
    else
      return ""class "" + name;
  }

  
  public void toSource(java.io.OutputStream out, int depth)
  {

    java.io.PrintWriter writer = new java.io.PrintWriter(out);

    toSource(writer, depth);
  }

  
  public void toSource(java.io.PrintWriter out, int depth)
  {

    String tab = tabset(depth);

    if (realclass != null)
      out.println(
        tab
        + """");
    else
      out.println(
        tab
        + """");

    
    if (getDeclaringClass() == null)
      out.println(tab + ""package "" + getPackageName() + "";"");

    out.print(tab + Modifier.toString(getModifiers()));

    if (isInterface())
      out.print("" interface "");
    else
      out.print("" class "");

    out.println(getJavaShortName());

    if (superclass != null)
    {
      out.print('
' + tab + "" extends "" + superclass.getJavaName());
    }

    Class[] ext = getInterfaces();

    if (ext != null & ext.length > 0)
    {

      
      
      out.print('
' + tab + (isInterface ? "" extends "" : "" implements "")
                + ext[0].getName());

      for (int i = 1; i < ext.length; ++i)
      {
        out.print("", "" + ext[i].getJavaName());
      }

      out.print(""
"");
    }

    out.print(tab + ""{
"");

    tab = tabset(++depth);

    
    Field[] fields = null;

    try
    {
      fields = getDeclaredFields();
    }
    catch (SecurityException e)
    {
      out.println(tab + ""
    }

    if (fields != null)
    {
      for (int i = 0; i < fields.length; ++i)
      {
        out.println(tab + fields[i].toSource());
      }
    }

    
    Constructor[] ctors = null;

    try
    {
      ctors = getDeclaredConstructors();
    }
    catch (SecurityException e)
    {
      out.println(tab + ""
    }

    if (ctors != null)
    {
      for (int i = 0; i < ctors.length; ++i)
      {
        out.print(ctors[i].toSource(tab));
      }
    }

    
    Method[] methods = null;

    try
    {
      methods = getDeclaredMethods();
    }
    catch (SecurityException e)
    {
      out.println(tab + ""
    }

    if (methods != null)
    {
      for (int i = 0; i < methods.length; ++i)
      {
        out.print('
');
        out.print(methods[i].toSource(tab));
      }
    }

    
    Class[] inners = getInnerClasses();

    if (inners != null)
    {
      for (int i = 0; i < inners.length; ++i)
      {
        out.print('
');
        inners[i].toSource(out, depth);
      }
    }

    
    tab = tabset(--depth);

    out.print(tab + ""}
"");
    out.flush();
  }

  
  private String tabset(int depth)
  {

    StringBuffer t = new StringBuffer();

    while (depth-- > 0)
    {
      t.append(""    "");
    }

    return t.toString();
  }

  

  
  static final int[] val = { Modifier.ABSTRACT, Modifier.FINAL,
                             Modifier.INTERFACE, Modifier.NATIVE,
                             Modifier.PRIVATE, Modifier.PROTECTED,
                             Modifier.PUBLIC, Modifier.STATIC,
                             Modifier.SYNCHRONIZED, Modifier.TRANSIENT,
                             Modifier.VOLATILE };

  
  static final String[] kwd = { ""abstract"", ""final"", ""interface"", ""native"",
                                ""private"", ""protected"", ""public"", ""static"",
                                ""synchronized"", ""transient"", ""volatile"" };

  
  static public int modifierFromString(String t)
  {

    for (int i = 0; i < kwd.length; ++i)
    {
      if (kwd[i].equals(t))
        return val[i];
    }

    return 0;
  }

  
  static public int modifiersFromString(String s)
  {

    int mods = 0;
    java.util.StringTokenizer parts = new java.util.StringTokenizer(s);

    while (parts.hasMoreTokens())
    {
      String t = parts.nextToken();

      mods |= modifierFromString(t);
    }

    return mods;
  }
}
"
org.apache.xml.utils.StringToStringTableVector,10,1,0,1,14,0,0,1,10,0.472222222,180,1.0,1,0.0,0.4,0,0,16.6,3,1.6,0,"
package org.apache.xml.utils;


public class StringToStringTableVector
{

  
  private int m_blocksize;

  
  private StringToStringTable m_map[];

  
  private int m_firstFree = 0;

  
  private int m_mapSize;

  
  public StringToStringTableVector()
  {

    m_blocksize = 8;
    m_mapSize = m_blocksize;
    m_map = new StringToStringTable[m_blocksize];
  }

  
  public StringToStringTableVector(int blocksize)
  {

    m_blocksize = blocksize;
    m_mapSize = blocksize;
    m_map = new StringToStringTable[blocksize];
  }

  
  public final int getLength()
  {
    return m_firstFree;
  }

  
  public final int size()
  {
    return m_firstFree;
  }

  
  public final void addElement(StringToStringTable value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      StringToStringTable newMap[] = new StringToStringTable[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final String get(String key)
  {

    for (int i = m_firstFree - 1; i >= 0; --i)
    {
      String nsuri = m_map[i].get(key);

      if (nsuri != null)
        return nsuri;
    }

    return null;
  }

  
  public final boolean containsKey(String key)
  {

    for (int i = m_firstFree - 1; i >= 0; --i)
    {
      if (m_map[i].get(key) != null)
        return true;
    }

    return false;
  }

  
  public final void removeLastElem()
  {

    if (m_firstFree > 0)
    {
      m_map[m_firstFree] = null;

      m_firstFree--;
    }
  }

  
  public final StringToStringTable elementAt(int i)
  {
    return m_map[i];
  }

  
  public final boolean contains(StringToStringTable s)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (m_map[i].equals(s))
        return true;
    }

    return false;
  }
}
"
org.apache.xml.dtm.ref.IncrementalSAXSource_Xerces,14,1,0,9,51,27,1,8,10,0.596153846,755,0.05,0,0.0,0.162393162,0,0,51.5,9,1.5,0,"

package org.apache.xml.dtm.ref;

import org.xml.sax.InputSource;
import org.xml.sax.SAXException;
import java.io.IOException;
import org.apache.xerces.parsers.SAXParser;
import org.xml.sax.XMLReader;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;



public class IncrementalSAXSource_Xerces
  implements IncrementalSAXSource
{
  
  
  
  
  
  
  Method fParseSomeSetup=null; 
  Method fParseSome=null; 
  Object fPullParserConfig=null; 
  Method fConfigSetInput=null; 
  Method fConfigParse=null; 
  Method fSetInputSource=null; 
  Constructor fConfigInputSourceCtor=null; 
  Method fConfigSetByteStream=null; 
  Method fConfigSetCharStream=null; 
  Method fConfigSetEncoding=null; 
  Method fReset=null; 
  
  
  
  
  SAXParser fIncrementalParser;
  private boolean fParseInProgress=false;

  
  
  

  
  public IncrementalSAXSource_Xerces() 
		throws NoSuchMethodException
	{
		try
		{
			
			
			
			
			
			
			
			
			
			
			
			Class me=this.getClass();
			
			
			Class xniConfigClass=me.forName(""org.apache.xerces.xni.parser.XMLParserConfiguration"");
			Class[] args1={xniConfigClass};
			Constructor ctor=SAXParser.class.getConstructor(args1);
			
			
			
			
			Class xniStdConfigClass=me.forName(""org.apache.xerces.parsers.StandardParserConfiguration"");
			fPullParserConfig=xniStdConfigClass.newInstance();
			Object[] args2={fPullParserConfig};
			fIncrementalParser = (SAXParser)ctor.newInstance(args2);
			
			
			
			
			Class fXniInputSourceClass=me.forName(""org.apache.xerces.xni.parser.XMLInputSource"");
			Class[] args3={fXniInputSourceClass};
			fConfigSetInput=xniStdConfigClass.getMethod(""setInputSource"",args3);

			Class[] args4={String.class,String.class,String.class};
			fConfigInputSourceCtor=fXniInputSourceClass.getConstructor(args4);
			Class[] args5={java.io.InputStream.class};
			fConfigSetByteStream=fXniInputSourceClass.getMethod(""setByteStream"",args5);
			Class[] args6={java.io.Reader.class};
			fConfigSetCharStream=fXniInputSourceClass.getMethod(""setCharacterStream"",args6);
			Class[] args7={String.class};
			fConfigSetEncoding=fXniInputSourceClass.getMethod(""setEncoding"",args7);

			Class[] argsb={Boolean.TYPE};
			fConfigParse=xniStdConfigClass.getMethod(""parse"",argsb);			
			Class[] noargs=new Class[0];
			fReset=fIncrementalParser.getClass().getMethod(""reset"",noargs);
		}
		catch(Exception e)
		{
	    
			
			
			
			IncrementalSAXSource_Xerces dummy=new IncrementalSAXSource_Xerces(new SAXParser());
			this.fParseSomeSetup=dummy.fParseSomeSetup;
			this.fParseSome=dummy.fParseSome;
			this.fIncrementalParser=dummy.fIncrementalParser;
		}
  }

  
  public IncrementalSAXSource_Xerces(SAXParser parser) 
    throws NoSuchMethodException  
  {
		
		
		
		
		
    fIncrementalParser=parser;
		Class me=parser.getClass();
    Class[] parms={InputSource.class};
    fParseSomeSetup=me.getMethod(""parseSomeSetup"",parms);
    parms=new Class[0];
    fParseSome=me.getMethod(""parseSome"",parms);
    
    
  }

  
  
  
  static public IncrementalSAXSource createIncrementalSAXSource() 
	{
		try
		{
			return new IncrementalSAXSource_Xerces();
		}
		catch(NoSuchMethodException e)
		{
			
			
			IncrementalSAXSource_Filter iss=new IncrementalSAXSource_Filter();
			iss.setXMLReader(new SAXParser());
			return iss;
		}
  }
	
  static public IncrementalSAXSource
  createIncrementalSAXSource(SAXParser parser) {
		try
		{
			return new IncrementalSAXSource_Xerces(parser);
		}
		catch(NoSuchMethodException e)
		{
			
			
			IncrementalSAXSource_Filter iss=new IncrementalSAXSource_Filter();
			iss.setXMLReader(parser);
			return iss;
		}
  }

  
  
  

  
  public void setContentHandler(org.xml.sax.ContentHandler handler)
  {
    
    
    ((XMLReader)fIncrementalParser).setContentHandler(handler);
  }

  
  public void setLexicalHandler(org.xml.sax.ext.LexicalHandler handler)
  {
    
    try 
    {
      
      
      ((XMLReader)fIncrementalParser).setProperty(""http:
                                     handler);
    }
    catch(org.xml.sax.SAXNotRecognizedException e)
    {
      
    }
    catch(org.xml.sax.SAXNotSupportedException e)
    {
      
    }
  }
  
  
  public void setDTDHandler(org.xml.sax.DTDHandler handler)
  {
    
    
    ((XMLReader)fIncrementalParser).setDTDHandler(handler);
  }

  
  
  public void startParse(InputSource source) throws SAXException
  {
    if (fIncrementalParser==null)
      throw new SAXException(XSLMessages.createMessage(XSLTErrorResources.ER_STARTPARSE_NEEDS_SAXPARSER, null)); 
    if (fParseInProgress)
      throw new SAXException(XSLMessages.createMessage(XSLTErrorResources.ER_STARTPARSE_WHILE_PARSING, null)); 

    boolean ok=false;

    try
    {
      ok = parseSomeSetup(source);
    }
    catch(Exception ex)
    {
      throw new SAXException(ex);
    }
    
    if(!ok)
      throw new SAXException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_INIT_PARSER, null)); 
  }

  
  
  public Object deliverMoreNodes (boolean parsemore)
  {
    if(!parsemore)
    {
      fParseInProgress=false;
      return Boolean.FALSE;
    }

    Object arg;
    try {
      boolean keepgoing = parseSome();
      arg = keepgoing ? Boolean.TRUE : Boolean.FALSE;
    } catch (SAXException ex) {
      arg = ex;
    } catch (IOException ex) {
      arg = ex;
    } catch (Exception ex) {
      arg = new SAXException(ex);
    }
    return arg;
  }
	
	
	private boolean parseSomeSetup(InputSource source) 
		throws SAXException, IOException, IllegalAccessException, 
					 java.lang.reflect.InvocationTargetException,
					 java.lang.InstantiationException
	{
		if(fConfigSetInput!=null)
		{
			
			
			Object[] parms1={source.getPublicId(),source.getSystemId(),null};
			Object xmlsource=fConfigInputSourceCtor.newInstance(parms1);
			Object[] parmsa={source.getByteStream()};
			fConfigSetByteStream.invoke(xmlsource,parmsa);
			parmsa[0]=source.getCharacterStream();
			fConfigSetCharStream.invoke(xmlsource,parmsa);
			parmsa[0]=source.getEncoding();
			fConfigSetEncoding.invoke(xmlsource,parmsa);

			
			
			
			
			Object[] noparms=new Object[0];
			fReset.invoke(fIncrementalParser,noparms);
			
			parmsa[0]=xmlsource;
			fConfigSetInput.invoke(fPullParserConfig,parmsa);
			
			
			return parseSome();
		}
		else
		{
			Object[] parm={source};
			Object ret=fParseSomeSetup.invoke(fIncrementalParser,parm);
			return ((Boolean)ret).booleanValue();
		}
	}
	
	static final Object[] noparms=new Object[0]; 
	static final Object[] parmsfalse={Boolean.FALSE};
	private boolean parseSome()
		throws SAXException, IOException, IllegalAccessException,
					 java.lang.reflect.InvocationTargetException
	{
		
		if(fConfigSetInput!=null)
		{
			Object ret=(Boolean)(fConfigParse.invoke(fPullParserConfig,parmsfalse));
			return ((Boolean)ret).booleanValue();
		}
		else
		{
			Object ret=fParseSome.invoke(fIncrementalParser,noparms);
			return ((Boolean)ret).booleanValue();
		}
	}
	

  
  
  public static void main(String args[])
  {
    System.out.println(""Starting..."");

    CoroutineManager co = new CoroutineManager();
    int appCoroutineID = co.co_joinCoroutineSet(-1);
    if (appCoroutineID == -1)
    {
      System.out.println(""ERROR: Couldn't allocate coroutine number.
"");
      return;
    }
    IncrementalSAXSource parser=
      createIncrementalSAXSource();

    
    org.apache.xml.serialize.XMLSerializer trace;
    trace=new org.apache.xml.serialize.XMLSerializer(System.out,null);
    parser.setContentHandler(trace);
    parser.setLexicalHandler(trace);

    

    for(int arg=0;arg<args.length;++arg)
    {
      try
      {
        InputSource source = new InputSource(args[arg]);
        Object result=null;
        boolean more=true;
        parser.startParse(source);
        for(result = parser.deliverMoreNodes(more);
            result==Boolean.TRUE;
            result = parser.deliverMoreNodes(more))
        {
          System.out.println(""
Some parsing successful, trying more.
"");
            
          
          if(arg+1<args.length && ""!"".equals(args[arg+1]))
          {
            ++arg;
            more=false;
          }
            
        }
        
        if (result instanceof Boolean && ((Boolean)result)==Boolean.FALSE)
        {
          System.out.println(""
Parser ended (EOF or on request).
"");
        }
        else if (result == null) {
          System.out.println(""
UNEXPECTED: Parser says shut down prematurely.
"");
        }
        else if (result instanceof Exception) {
          throw new org.apache.xml.utils.WrappedRuntimeException((Exception)result);
          
Parser threw exception:"");
          
        }
        
      }

      catch(SAXException e)
      {
        e.printStackTrace();
      }
    }
    
  }

  
} 
"
org.apache.xalan.xsltc.compiler.ParameterRef,3,4,0,22,31,3,1,21,3,2.0,152,0.0,0,0.974358974,0.5,2,3,49.66666667,8,3.0,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class ParameterRef extends VariableRefBase {

    public ParameterRef(Param param) {
	super(param);
    }

    public String toString() {
	return ""parameter-ref(""+_variable.getName()+'/'+_variable.getType()+')';
    }

   public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final String name = _variable.getVariable();
	final String signature = _type.toSignature();

	if (_variable.isLocal()) {
	    if (classGen.isExternal()) {
		Closure variableClosure = _closure;
		while (variableClosure != null) {
		    if (variableClosure.inInnerClass()) break;
		    variableClosure = variableClosure.getParentClosure();
		}
	    
		if (variableClosure != null) {
		    il.append(ALOAD_0);
		    il.append(new GETFIELD(
			cpg.addFieldref(variableClosure.getInnerClassName(), 
			    name, signature)));
		}
		else {
		    il.append(_variable.loadInstruction());
		    _variable.removeReference(this);
		}
	    }
	    else {
		il.append(_variable.loadInstruction());
		_variable.removeReference(this);
	    }
	}
	else {
	    final String className = classGen.getClassName();
	    il.append(classGen.loadTranslet());
	    if (classGen.isExternal()) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }
	    il.append(new GETFIELD(cpg.addFieldref(className,name,signature)));
	}

	if (_variable.getType() instanceof NodeSetType) {
	    
	    final int clone = cpg.addInterfaceMethodref(NODE_ITERATOR,
						       ""cloneIterator"",
						       ""()"" + 
							NODE_ITERATOR_SIG);
	    il.append(new INVOKEINTERFACE(clone, 1));
	}
    }
}
"
org.apache.xalan.xsltc.compiler.ApplyImports,7,3,0,25,47,17,1,24,5,0.888888889,237,1.0,1,0.903225806,0.30952381,1,4,32.42857143,6,1.7143,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;

import org.apache.xalan.xsltc.compiler.util.*;

final class ApplyImports extends Instruction {

    private QName      _modeName;
    private String     _functionName;
    private int        _precedence;

    public void display(int indent) {
	indent(indent);
	Util.println(""ApplyTemplates"");
	indent(indent + IndentIncrement);
	if (_modeName != null) {
	    indent(indent + IndentIncrement);
	    Util.println(""mode "" + _modeName);
	}
    }

    
    public boolean hasWithParams() {
	return hasContents();
    }

    
    private int getMinPrecedence(int max) {
	Stylesheet stylesheet = getStylesheet();
	Stylesheet root = getParser().getTopLevelStylesheet();

	int min = max;

	Enumeration templates = root.getContents().elements();
	while (templates.hasMoreElements()) {
	    SyntaxTreeNode child = (SyntaxTreeNode)templates.nextElement();
	    if (child instanceof Template) {
		Stylesheet curr = child.getStylesheet();
		while ((curr != null) && (curr != stylesheet)) {
		    if (curr._importedFrom != null)
			curr = curr._importedFrom;
		    else if (curr._includedFrom != null)
			curr = curr._includedFrom;
		    else
			curr = null;
		}
		if (curr == stylesheet) {
		    int prec = child.getStylesheet().getImportPrecedence();
		    if (prec < min) min = prec;
		}
	    }
	}
	return (min);
    }

    
    public void parseContents(Parser parser) {
	
	
	Stylesheet stylesheet = getStylesheet();
	stylesheet.setTemplateInlining(false);

	
	Template template = getTemplate();
	_modeName = template.getModeName();
	_precedence = template.getImportPrecedence();

	
	stylesheet = parser.getTopLevelStylesheet();

	
	
	final int maxPrecedence = _precedence;
	final int minPrecedence = getMinPrecedence(maxPrecedence);
	final Mode mode = stylesheet.getMode(_modeName);
	_functionName = mode.functionName(minPrecedence, maxPrecedence);

	parseChildren(parser);	
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	typeCheckContents(stable);		
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Stylesheet stylesheet = classGen.getStylesheet();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int current = methodGen.getLocalIndex(""current"");

	
	il.append(classGen.loadTranslet());
	il.append(methodGen.loadDOM());
	
	int init = cpg.addMethodref(SINGLETON_ITERATOR,
				    ""<init>"", ""(""+NODE_SIG+"")V"");
	il.append(new NEW(cpg.addClass(SINGLETON_ITERATOR)));
	il.append(DUP);
	il.append(methodGen.loadCurrentNode());
	il.append(new INVOKESPECIAL(init));

	il.append(methodGen.loadHandler());

	
	final String className = classGen.getStylesheet().getClassName();
	final String signature = classGen.getApplyTemplatesSig();
	final int applyTemplates = cpg.addMethodref(className,
						    _functionName,
						    signature);
	il.append(new INVOKEVIRTUAL(applyTemplates));
    }

}
"
org.apache.xpath.functions.FunctionMultiArgs,8,6,1,10,23,8,2,9,7,0.428571429,214,0.0,1,0.901408451,0.375,5,22,25.625,7,2.5,1,"
package org.apache.xpath.functions;

import java.util.Vector;

import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.functions.Function3Args.Arg2Owner;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;


public class FunctionMultiArgs extends Function3Args
{

  
  Expression[] m_args;

  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {

    if (argNum < 3)
      super.setArg(arg, argNum);
    else
    {
      if (null == m_args)
      {
        m_args = new Expression[1];
        m_args[0] = arg;
      }
      else
      {

        
        Expression[] args = new Expression[m_args.length + 1];

        System.arraycopy(m_args, 0, args, 0, m_args.length);

        args[m_args.length] = arg;
        m_args = args;
      }
      arg.exprSetParent(this);
    }
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    if(null != m_args)
    {
      for (int i = 0; i < m_args.length; i++) 
      {
        m_args[i].fixupVariables(vars, globalsSize);
      }
    }
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException{}

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
    String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ ""Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called."" });

    throw new RuntimeException(fMsg);
  }

  
  public boolean canTraverseOutsideSubtree()
  {

    if (super.canTraverseOutsideSubtree())
      return true;
    else
    {
      int n = m_args.length;

      for (int i = 0; i < n; i++)
      {
        if (m_args[i].canTraverseOutsideSubtree())
          return true;
      }

      return false;
    }
  }
  
  class ArgMultiOwner implements ExpressionOwner
  {
  	int m_argIndex;
  	
  	ArgMultiOwner(int index)
  	{
  		m_argIndex = index;
  	}
  	
    
    public Expression getExpression()
    {
      return m_args[m_argIndex];
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(FunctionMultiArgs.this);
    	m_args[m_argIndex] = exp;
    }
  }

   
    
    public void callArgVisitors(XPathVisitor visitor)
    {
      super.callArgVisitors(visitor);
      if (null != m_args)
      {
        int n = m_args.length;
        for (int i = 0; i < n; i++)
        {
          m_args[i].callVisitors(new ArgMultiOwner(i), visitor);
        }
      }
    }
    
    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
            return false;

      FunctionMultiArgs fma = (FunctionMultiArgs) expr;
      if (null != m_args)
      {
        int n = m_args.length;
        if ((null == fma) || (fma.m_args.length != n))
              return false;

        for (int i = 0; i < n; i++)
        {
          if (!m_args[i].deepEquals(fma.m_args[i]))
                return false;
        }

      }
      else if (null != fma.m_args)
      {
          return false;
      }

      return true;
    }
}
"
org.apache.xml.dtm.Axis,1,1,0,3,1,0,3,0,0,2.0,111,0.0,0,0.0,0.0,0,0,88.0,0,0.0,0,"
package org.apache.xml.dtm;


public interface Axis
{

  
  public static final int ANCESTOR = 0;

  
  public static final int ANCESTORORSELF = 1;

  
  public static final int ATTRIBUTE = 2;

  
  public static final int CHILD = 3;

  
  public static final int DESCENDANT = 4;

  
  public static final int DESCENDANTORSELF = 5;

  
  public static final int FOLLOWING = 6;

  
  public static final int FOLLOWINGSIBLING = 7;

  
  public static final int NAMESPACEDECLS = 8;

  
  public static final int NAMESPACE = 9;

  
  public static final int PARENT = 10;

  
  public static final int PRECEDING = 11;

  
  public static final int PRECEDINGSIBLING = 12;

  
  public static final int SELF = 13;

  
  public static final int ALLFROMNODE = 14;

  
  public static final int PRECEDINGANDANCESTOR = 15;
  
  
  
  
  
  public static final int ALL = 16;

  
  public static final int DESCENDANTSFROMROOT = 17;

  
  public static final int DESCENDANTSORSELFFROMROOT = 18;

  
  public static final int ROOT = 19;

  
  public static final int FILTEREDLIST = 20;


  
  public static final String[] names =
  {
    ""ancestor"",  
    ""ancestor-or-self"",  
    ""attribute"",  
    ""child"",  
    ""descendant"",  
    ""descendant-or-self"",  
    ""following"",  
    ""following-sibling"",  
    ""namespace-decls"",  
    ""namespace"",  
    ""parent"",  
    ""preceding"",  
    ""preceding-sibling"",  
    ""self"",  
    ""all-from-node"",  
    ""preceding-and-ancestor"",  
    ""all"",  
    ""descendants-from-root"",  
    ""descendants-or-self-from-root"",  
    ""root"",  
    ""filtered-list""  
  };
}
"
org.apache.xpath.functions.FuncConcat,4,7,0,10,13,6,0,10,3,2.0,81,0.0,0,0.96,0.5,3,8,19.25,1,0.75,0,"
package org.apache.xpath.functions;



import javax.xml.transform.TransformerException;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncConcat extends FunctionMultiArgs
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    StringBuffer sb = new StringBuffer();

    
    sb.append(m_arg0.execute(xctxt).str());
    sb.append(m_arg1.execute(xctxt).str());

    if (null != m_arg2)
      sb.append(m_arg2.execute(xctxt).str());

    if (null != m_args)
    {
      for (int i = 0; i < m_args.length; i++)
      {
        sb.append(m_args[i].execute(xctxt).str());
      }
    }

    return new XString(sb.toString());
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException
  {
    if (argNum < 2)
      reportWrongNumberArgs();
  }

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
      throw new WrongNumberArgsException(XSLMessages.createXPATHMessage(""gtone"", null));
  }
}
"
org.apache.xpath.functions.FuncId,3,4,0,11,27,3,0,11,2,2.0,169,0.0,0,0.96,0.476190476,1,6,55.33333333,8,3.0,0,"
package org.apache.xpath.functions;

import java.util.Hashtable;
import java.util.StringTokenizer;

import org.apache.xpath.res.XPATHErrorResources;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.DOMHelper;
import org.apache.xpath.XPath;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xml.utils.StringVector;


public class FuncId extends FunctionOneArg
{

  
  private StringVector getNodesByID(XPathContext xctxt, int docContext,
                                    String refval, StringVector usedrefs,
                                    NodeSetDTM nodeSet, boolean mayBeMore)
  {

    if (null != refval)
    {
      String ref = null;

      StringTokenizer tokenizer = new StringTokenizer(refval);
      boolean hasMore = tokenizer.hasMoreTokens();
      DTM dtm = xctxt.getDTM(docContext);

      while (hasMore)
      {
        ref = tokenizer.nextToken();
        hasMore = tokenizer.hasMoreTokens();

        if ((null != usedrefs) && usedrefs.contains(ref))
        {
          ref = null;

          continue;
        }

        int node = dtm.getElementById(ref);

        if (DTM.NULL != node)
          nodeSet.addNodeInDocOrder(node, xctxt);

        if ((null != ref) && (hasMore || mayBeMore))
        {
          if (null == usedrefs)
            usedrefs = new StringVector();

          usedrefs.addElement(ref);
        }
      }
    }

    return usedrefs;
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    int docContext = dtm.getDocument();

    if (DTM.NULL == docContext)
      error(xctxt, XPATHErrorResources.ER_CONTEXT_HAS_NO_OWNERDOC, null);

    XObject arg = m_arg0.execute(xctxt);
    int argType = arg.getType();
    XNodeSet nodes = new XNodeSet(xctxt.getDTMManager());
    NodeSetDTM nodeSet = nodes.mutableNodeset();

    if (XObject.CLASS_NODESET == argType)
    {
      DTMIterator ni = arg.iter();
      StringVector usedrefs = null;
      int pos = ni.nextNode();

      while (DTM.NULL != pos)
      {
        DTM ndtm = ni.getDTM(pos);
        String refval = ndtm.getStringValue(pos).toString();

        pos = ni.nextNode();
        usedrefs = getNodesByID(xctxt, docContext, refval, usedrefs, nodeSet,
                                DTM.NULL != pos);
      }
      
    }
    else if (XObject.CLASS_NULL == argType)
    {
      return nodes;
    }
    else
    {
      String refval = arg.str();

      getNodesByID(xctxt, docContext, refval, null, nodeSet, false);
    }

    return nodes;
  }
}
"
org.apache.xml.dtm.ref.sax2dtm.SAX2RTFDTM,9,5,0,12,32,18,2,10,8,0.78125,392,0.25,6,0.954285714,0.26984127,2,20,41.66666667,10,2.8889,0,"
package org.apache.xml.dtm.ref.sax2dtm;

import java.util.Hashtable;
import java.util.Vector;
import javax.xml.transform.Source;
import javax.xml.transform.SourceLocator;
import org.apache.xalan.transformer.XalanProperties;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;

import org.apache.xml.dtm.*;
import org.apache.xml.dtm.ref.*;
import org.apache.xml.utils.StringVector;
import org.apache.xml.utils.IntVector;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.SuballocatedIntVector;
import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.xml.sax.*;
import org.xml.sax.ext.*;


public class SAX2RTFDTM extends SAX2DTM
{
  
  private static final boolean DEBUG = false;
  
  
  private int m_currentDocumentNode=NULL;
  
  
  IntStack mark_size=new IntStack();
  
  IntStack mark_data_size=new IntStack();
  
  IntStack mark_char_size=new IntStack();
  
  IntStack mark_doq_size=new IntStack();
  
  IntStack mark_nsdeclset_size=new IntStack();
  
  IntStack mark_nsdeclelem_size=new IntStack();
  
  public SAX2RTFDTM(DTMManager mgr, Source source, int dtmIdentity,
                 DTMWSFilter whiteSpaceFilter,
                 XMLStringFactory xstringfactory,
                 boolean doIndexing)
  {
    super(mgr, source, dtmIdentity, whiteSpaceFilter, 
          xstringfactory, doIndexing);
          
    
    
    m_useSourceLocationProperty=false; 
    m_sourceSystemId = (m_useSourceLocationProperty) ? new StringVector() : null;
 	m_sourceLine = (m_useSourceLocationProperty) ?  new IntVector() : null;
    m_sourceColumn = (m_useSourceLocationProperty) ?  new IntVector() : null;
    
  }
  
  
  public int getDocument()
  {
    return makeNodeHandle(m_currentDocumentNode);
  }

  
  public int getDocumentRoot(int nodeHandle)
  {
    for(int id=makeNodeIdentity(nodeHandle);
		id!=NULL;
		id=_parent(id))
		if(_type(id)==DTM.DOCUMENT_NODE)
  			return makeNodeHandle(id);

    return DTM.NULL; 
  }
  
  
  protected int _documentRoot(int nodeIdentifier)
  {
  	if(nodeIdentifier==NULL) return NULL;
  	
    for(int parent=_parent(nodeIdentifier);
    	parent!=NULL;
    	nodeIdentifier=parent,parent=_parent(nodeIdentifier))
    	;
    
    return nodeIdentifier;
  }

  
  public void startDocument() throws SAXException
  {
    
    m_endDocumentOccured = false;
    m_prefixMappings = new java.util.Vector();
    m_contextIndexes = new IntStack();
    m_parents = new IntStack();
    
    m_currentDocumentNode=m_size;
    super.startDocument();
  }
  
  
  public void endDocument() throws SAXException
  {
    charactersFlush();

    m_nextsib.setElementAt(NULL,m_currentDocumentNode);

    if (m_firstch.elementAt(m_currentDocumentNode) == NOTPROCESSED)
      m_firstch.setElementAt(NULL,m_currentDocumentNode);

    if (DTM.NULL != m_previous)
      m_nextsib.setElementAt(DTM.NULL,m_previous);

    m_parents = null;
    m_prefixMappings = null;
    m_contextIndexes = null;

    m_currentDocumentNode= NULL; 
    m_endDocumentOccured = true;
  }
  

  
  public void pushRewindMark()
  {
    if(m_indexing || m_elemIndexes!=null) 
      throw new java.lang.NullPointerException(""Coding error; Don't try to mark/rewind an indexed DTM"");

    
    
    mark_size.push(m_size);
    mark_nsdeclset_size.push( (m_namespaceDeclSets==null) ? 0 : m_namespaceDeclSets.size() );
    mark_nsdeclelem_size.push( (m_namespaceDeclSetElements==null) ? 0 : m_namespaceDeclSetElements.size() );
    
    
    mark_data_size.push(m_data.size());
    mark_char_size.push(m_chars.size());
    mark_doq_size.push(m_dataOrQName.size());	
  }
  
  
  public boolean popRewindMark()
  {
    boolean top=mark_size.empty();
    
    m_size=top ? 0 : mark_size.pop();
    m_exptype.setSize(m_size);
    m_firstch.setSize(m_size);
    m_nextsib.setSize(m_size);
    m_prevsib.setSize(m_size);
    m_parent.setSize(m_size);

    m_elemIndexes=null;

    int ds= top ? 0 : mark_nsdeclset_size.pop();
    if (m_namespaceDeclSets!=null)
      m_namespaceDeclSets.setSize(ds);
      
    int ds1= top ? 0 : mark_nsdeclelem_size.pop();
    if (m_namespaceDeclSetElements!=null)
      m_namespaceDeclSetElements.setSize(ds1);
  
    
    m_data.setSize(top ? 0 : mark_data_size.pop());
    m_chars.setLength(top ? 0 : mark_char_size.pop());
    m_dataOrQName.setSize(top ? 0 : mark_doq_size.pop());

    
    return m_size==0;
  }
  
  
  public boolean isTreeIncomplete()
  {
  	return !m_endDocumentOccured;
  	
  }
}
"
org.apache.xalan.processor.XSLProcessorVersion,3,1,0,2,9,1,2,0,2,1.0,67,0.0,0,0.0,0.5,0,0,19.0,1,0.3333,0,"
package org.apache.xalan.processor;


public class XSLProcessorVersion
{

  
  public static void main(String argv[])
  {
    System.out.println(S_VERSION);
  }

  
  public static final String PRODUCT = ""Xalan"";

  
  public static String LANGUAGE = ""Java"";

  
  public static int VERSION = 2;

  
  public static int RELEASE = 4;

  
  public static int MAINTENANCE = 0;

  
  public static int DEVELOPMENT = 0;
  
  
  public static String S_VERSION = PRODUCT+"" ""+LANGUAGE+"" ""
                                   +VERSION+"".""+RELEASE+"".""
                                   +(DEVELOPMENT > 0 ? (""D""+DEVELOPMENT) 
                                     : (""""+MAINTENANCE));

}
"
org.apache.xalan.templates.Stylesheet,74,3,2,48,113,2539,38,17,70,0.966051221,1136,0.913043478,4,0.728624535,0.073443008,3,19,14.04054054,16,1.8378,0,"
package org.apache.xalan.templates;


import java.io.ObjectInputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;

import java.text.DecimalFormatSymbols;

import java.util.Hashtable;
import java.util.Stack;
import java.util.Vector;


import org.apache.xml.utils.SystemIDResolver;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.StringVector;
import org.apache.xpath.XPath;




import org.apache.xml.dtm.DTM;


import javax.xml.transform.TransformerException;
import org.xml.sax.Locator;

import javax.xml.transform.SourceLocator;


public class Stylesheet extends ElemTemplateElement
        implements java.io.Serializable 
{

  
  public Stylesheet(Stylesheet parent)
  {

    if (null != parent)
    {
      m_stylesheetParent = parent;
      m_stylesheetRoot = parent.getStylesheetRoot();
    }
  }

  
  public Stylesheet getStylesheet()
  {
    return this;
  }

  
  public boolean isAggregatedType()
  {
    return false;
  }

  
  public boolean isRoot()
  {
    return false;
  }

  
  public static final String STYLESHEET_EXT = "".lxc"";

  
  private void readObject(ObjectInputStream stream)
          throws IOException, TransformerException
  {

    
    try
    {
      stream.defaultReadObject();
    }
    catch (ClassNotFoundException cnfe)
    {
      throw new TransformerException(cnfe);
    }

    
  }

  
  private void writeObject(ObjectOutputStream stream) throws IOException
  {

    
    stream.defaultWriteObject();

    
  }

  

  
  private String m_XmlnsXsl;

  
  public void setXmlnsXsl(String v)
  {
    m_XmlnsXsl = v;
  }

  
  public String getXmlnsXsl()
  {
    return m_XmlnsXsl;
  }

  
  private StringVector m_ExtensionElementURIs;

  
  public void setExtensionElementPrefixes(StringVector v)
  {
    m_ExtensionElementURIs = v;
  }

  
  public String getExtensionElementPrefix(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_ExtensionElementURIs)
      throw new ArrayIndexOutOfBoundsException();

    return m_ExtensionElementURIs.elementAt(i);
  }

  
  public int getExtensionElementPrefixCount()
  {
    return (null != m_ExtensionElementURIs)
           ? m_ExtensionElementURIs.size() : 0;
  }

  
  public boolean containsExtensionElementURI(String uri)
  {

    if (null == m_ExtensionElementURIs)
      return false;

    return m_ExtensionElementURIs.contains(uri);
  }

  
  private StringVector m_ExcludeResultPrefixs;

  
  public void setExcludeResultPrefixes(StringVector v)
  {
    m_ExcludeResultPrefixs = v;
  }

  
  public String getExcludeResultPrefix(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_ExcludeResultPrefixs)
      throw new ArrayIndexOutOfBoundsException();

    return m_ExcludeResultPrefixs.elementAt(i);
  }

  
  public int getExcludeResultPrefixCount()
  {
    return (null != m_ExcludeResultPrefixs)
           ? m_ExcludeResultPrefixs.size() : 0;
  }

  
  public boolean containsExcludeResultPrefix(String prefix, String uri) 
  {

    if (null == m_ExcludeResultPrefixs || uri == null )
      return false;
    
    
    
    for (int i =0; i< m_ExcludeResultPrefixs.size(); i++)
    {
      if (uri.equals(getNamespaceForPrefix(m_ExcludeResultPrefixs.elementAt(i))))
        return true;
    }
    
    return false;

  
  }

  
  private String m_Id;

  
  public void setId(String v)
  {
    m_Id = v;
  }

  
  public String getId()
  {
    return m_Id;
  }

  
  private String m_Version;

  
  public void setVersion(String v)
  {
    m_Version = v;
  }

  
  public String getVersion()
  {
    return m_Version;
  }

  
  private Vector m_imports;

  
  public void setImport(StylesheetComposed v)
  {

    if (null == m_imports)
      m_imports = new Vector();

    
    
    m_imports.addElement(v);
  }

  
  public StylesheetComposed getImport(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_imports)
      throw new ArrayIndexOutOfBoundsException();

    return (StylesheetComposed) m_imports.elementAt(i);
  }

  
  public int getImportCount()
  {
    return (null != m_imports) ? m_imports.size() : 0;
  }

  
  private Vector m_includes;

  
  public void setInclude(Stylesheet v)
  {

    if (null == m_includes)
      m_includes = new Vector();

    m_includes.addElement(v);
  }

  
  public Stylesheet getInclude(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_includes)
      throw new ArrayIndexOutOfBoundsException();

    return (Stylesheet) m_includes.elementAt(i);
  }

  
  public int getIncludeCount()
  {
    return (null != m_includes) ? m_includes.size() : 0;
  }

  
  Stack m_DecimalFormatDeclarations;

  
  public void setDecimalFormat(DecimalFormatProperties edf)
  {

    if (null == m_DecimalFormatDeclarations)
      m_DecimalFormatDeclarations = new Stack();

    
    
    m_DecimalFormatDeclarations.push(edf);
  }

  
  public DecimalFormatProperties getDecimalFormat(QName name)
  {

    if (null == m_DecimalFormatDeclarations)
      return null;

    int n = getDecimalFormatCount();

    for (int i = (n - 1); i >= 0; i++)
    {
      DecimalFormatProperties dfp = getDecimalFormat(i);

      if (dfp.getName().equals(name))
        return dfp;
    }

    return null;
  }

  
  public DecimalFormatProperties getDecimalFormat(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_DecimalFormatDeclarations)
      throw new ArrayIndexOutOfBoundsException();

    return (DecimalFormatProperties) m_DecimalFormatDeclarations.elementAt(i);
  }

  
  public int getDecimalFormatCount()
  {
    return (null != m_DecimalFormatDeclarations)
           ? m_DecimalFormatDeclarations.size() : 0;
  }

  
  private Vector m_whitespaceStrippingElements;

  
  public void setStripSpaces(WhiteSpaceInfo wsi)
  {

    if (null == m_whitespaceStrippingElements)
    {
      m_whitespaceStrippingElements = new Vector();
    }

    m_whitespaceStrippingElements.addElement(wsi);
  }

  
  public WhiteSpaceInfo getStripSpace(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_whitespaceStrippingElements)
      throw new ArrayIndexOutOfBoundsException();

    return (WhiteSpaceInfo) m_whitespaceStrippingElements.elementAt(i);
  }

  
  public int getStripSpaceCount()
  {
    return (null != m_whitespaceStrippingElements)
           ? m_whitespaceStrippingElements.size() : 0;
  }

  
  private Vector m_whitespacePreservingElements;

  
  public void setPreserveSpaces(WhiteSpaceInfo wsi)
  {

    if (null == m_whitespacePreservingElements)
    {
      m_whitespacePreservingElements = new Vector();
    }

    m_whitespacePreservingElements.addElement(wsi);
  }

  
  public WhiteSpaceInfo getPreserveSpace(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_whitespacePreservingElements)
      throw new ArrayIndexOutOfBoundsException();

    return (WhiteSpaceInfo) m_whitespacePreservingElements.elementAt(i);
  }

  
  public int getPreserveSpaceCount()
  {
    return (null != m_whitespacePreservingElements)
           ? m_whitespacePreservingElements.size() : 0;
  }

  
  private Vector m_output;

  
  public void setOutput(OutputProperties v)
  {
    if (null == m_output)
    {
      m_output = new Vector();
    }

    m_output.addElement(v);
  }

  
  public OutputProperties getOutput(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_output)
      throw new ArrayIndexOutOfBoundsException();

    return (OutputProperties) m_output.elementAt(i);
  }

  
  public int getOutputCount()
  {
    return (null != m_output)
           ? m_output.size() : 0;
  }

  
  private Vector m_keyDeclarations;

  
  public void setKey(KeyDeclaration v)
  {

    if (null == m_keyDeclarations)
      m_keyDeclarations = new Vector();

    m_keyDeclarations.addElement(v);
  }

  
  public KeyDeclaration getKey(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_keyDeclarations)
      throw new ArrayIndexOutOfBoundsException();

    return (KeyDeclaration) m_keyDeclarations.elementAt(i);
  }

  
  public int getKeyCount()
  {
    return (null != m_keyDeclarations) ? m_keyDeclarations.size() : 0;
  }

  
  private Vector m_attributeSets;

  
  public void setAttributeSet(ElemAttributeSet attrSet)
  {

    if (null == m_attributeSets)
    {
      m_attributeSets = new Vector();
    }

    m_attributeSets.addElement(attrSet);
  }

  
  public ElemAttributeSet getAttributeSet(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_attributeSets)
      throw new ArrayIndexOutOfBoundsException();

    return (ElemAttributeSet) m_attributeSets.elementAt(i);
  }

  
  public int getAttributeSetCount()
  {
    return (null != m_attributeSets) ? m_attributeSets.size() : 0;
  }

  
  private Vector m_topLevelVariables;

  
  public void setVariable(ElemVariable v)
  {

    if (null == m_topLevelVariables)
      m_topLevelVariables = new Vector();

    m_topLevelVariables.addElement(v);
  }
  
  
  public ElemVariable getVariableOrParam(QName qname)
  {

    if (null != m_topLevelVariables)
    {
      int n = getVariableOrParamCount();

      for (int i = 0; i < n; i++)
      {
        ElemVariable var = (ElemVariable) getVariableOrParam(i);

        if (var.getName().equals(qname))
          return var;
      }
    }

    return null;
  }


  
  public ElemVariable getVariable(QName qname)
  {

    if (null != m_topLevelVariables)
    {
      int n = getVariableOrParamCount();

      for (int i = 0; i < n; i++)
      {
        ElemVariable var = getVariableOrParam(i);
        if((var.getXSLToken() == Constants.ELEMNAME_VARIABLE) &&
           (var.getName().equals(qname)))
          return var;
      }
    }

    return null;
  }

  
  public ElemVariable getVariableOrParam(int i) throws ArrayIndexOutOfBoundsException
  {

    if (null == m_topLevelVariables)
      throw new ArrayIndexOutOfBoundsException();

    return (ElemVariable) m_topLevelVariables.elementAt(i);
  }

  
  public int getVariableOrParamCount()
  {
    return (null != m_topLevelVariables) ? m_topLevelVariables.size() : 0;
  }

  
  public void setParam(ElemParam v)
  {
    setVariable(v);
  }

  
  public ElemParam getParam(QName qname)
  {

    if (null != m_topLevelVariables)
    {
      int n = getVariableOrParamCount();

      for (int i = 0; i < n; i++)
      {
        ElemVariable var = getVariableOrParam(i);
        if((var.getXSLToken() == Constants.ELEMNAME_PARAMVARIABLE) &&
           (var.getName().equals(qname)))
          return (ElemParam)var;
      }
    }

    return null;
  }

  
  private Vector m_templates;

  
  public void setTemplate(ElemTemplate v)
  {

    if (null == m_templates)
      m_templates = new Vector();

    m_templates.addElement(v);
    v.setStylesheet(this);
  }

  
  public ElemTemplate getTemplate(int i) throws TransformerException
  {

    if (null == m_templates)
      throw new ArrayIndexOutOfBoundsException();

    return (ElemTemplate) m_templates.elementAt(i);
  }

  
  public int getTemplateCount()
  {
    return (null != m_templates) ? m_templates.size() : 0;
  }

  
  private Vector m_prefix_aliases;

  
  public void setNamespaceAlias(NamespaceAlias na)
  {

    if (m_prefix_aliases == null)
      m_prefix_aliases = new Vector();

    m_prefix_aliases.addElement(na);
  }

  
  public NamespaceAlias getNamespaceAlias(int i)
          throws ArrayIndexOutOfBoundsException
  {

    if (null == m_prefix_aliases)
      throw new ArrayIndexOutOfBoundsException();

    return (NamespaceAlias) m_prefix_aliases.elementAt(i);
  }

  
  public int getNamespaceAliasCount()
  {
    return (null != m_prefix_aliases) ? m_prefix_aliases.size() : 0;
  }

  
  private Hashtable m_NonXslTopLevel;

  
  public void setNonXslTopLevel(QName name, Object obj)
  {

    if (null == m_NonXslTopLevel)
      m_NonXslTopLevel = new Hashtable();

    m_NonXslTopLevel.put(name, obj);
  }

  
  public Object getNonXslTopLevel(QName name)
  {
    return (null != m_NonXslTopLevel) ? m_NonXslTopLevel.get(name) : null;
  }

  

  
  private String m_href = null;

  
  private String m_publicId;

  
  private String m_systemId;

  
  public String getHref()
  {
    return m_href;
  }

  
  public void setHref(String baseIdent)
  {
    m_href = baseIdent;
  }

  
  public void setLocaterInfo(SourceLocator locator)
  {

    if (null != locator)
    {
      m_publicId = locator.getPublicId();
      m_systemId = locator.getSystemId();

      if (null != m_systemId)
      {
        try
        {
          m_href = SystemIDResolver.getAbsoluteURI(m_systemId, null);
        }
        catch (TransformerException se)
        {

          
        }
      }

      super.setLocaterInfo(locator);
    }
  }

  
  private StylesheetRoot m_stylesheetRoot;

  
  public StylesheetRoot getStylesheetRoot()
  {
    return m_stylesheetRoot;
  }

  
  public void setStylesheetRoot(StylesheetRoot v)
  {
    m_stylesheetRoot = v;
  }

  
  private Stylesheet m_stylesheetParent;

  
  public Stylesheet getStylesheetParent()
  {
    return m_stylesheetParent;
  }

  
  public void setStylesheetParent(Stylesheet v)
  {
    m_stylesheetParent = v;
  }

  
  public StylesheetComposed getStylesheetComposed()
  {

    Stylesheet sheet = this;

    while (!sheet.isAggregatedType())
    {
      sheet = sheet.getStylesheetParent();
    }

    return (StylesheetComposed) sheet;
  }

  
  public short getNodeType()
  {
    return DTM.DOCUMENT_NODE;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_STYLESHEET;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_STYLESHEET_STRING;
  }

  
  public void replaceTemplate(ElemTemplate v, int i) throws TransformerException
  {

    if (null == m_templates)
      throw new ArrayIndexOutOfBoundsException();

    replaceChild(v, (ElemTemplateElement)m_templates.elementAt(i));
    m_templates.setElementAt(v, i);
    v.setStylesheet(this);
  }
  
    
    protected void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
    {
      int s = getImportCount();
      for (int j = 0; j < s; j++)
      {
      	getImport(j).callVisitors(visitor);
      }
   
      s = getIncludeCount();
      for (int j = 0; j < s; j++)
      {
      	getInclude(j).callVisitors(visitor);
      }

      s = getOutputCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getOutput(j));
      }

      

      s = getAttributeSetCount();
      for (int j = 0; j < s; j++)
      {
      	ElemAttributeSet attrSet = getAttributeSet(j);
        if (visitor.visitTopLevelInstruction(attrSet))
        {
          attrSet.callChildVisitors(visitor);
        }
      }
      

      s = getDecimalFormatCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getDecimalFormat(j));
      }

      

      s = getKeyCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getKey(j));
      }

      

      s = getNamespaceAliasCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getNamespaceAlias(j));
      }

      

      s = getTemplateCount();
      for (int j = 0; j < s; j++)
      {
        try
        {
          ElemTemplate template = getTemplate(j);
          if (visitor.visitTopLevelInstruction(template))
          {
            template.callChildVisitors(visitor);
          }
        }
        catch (TransformerException te)
        {
          throw new org.apache.xml.utils.WrappedRuntimeException(te);
        }
      }

      

      s = getVariableOrParamCount();
      for (int j = 0; j < s; j++)
      {
      	ElemVariable var = getVariableOrParam(j);
        if (visitor.visitTopLevelVariableOrParamDecl(var))
        {
          var.callChildVisitors(visitor);
        }
      }

      

      s = getStripSpaceCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getStripSpace(j));
      }

      s = getPreserveSpaceCount();
      for (int j = 0; j < s; j++)
      {
        visitor.visitTopLevelInstruction(getPreserveSpace(j));
      }
      
      if(null != m_NonXslTopLevel)
      {
      	java.util.Enumeration enum = m_NonXslTopLevel.elements();
      	while(enum.hasMoreElements())
      	{
      	  ElemTemplateElement elem = (ElemTemplateElement)enum.nextElement();
          if (visitor.visitTopLevelInstruction(elem))
          {
            elem.callChildVisitors(visitor);
          }
      		
      	}
      }
    }
        
          
  
  protected boolean accept(XSLTVisitor visitor)
  {
  	return visitor.visitStylesheet(this);
  }

  
}
"
org.apache.xalan.xsltc.dom.LoadDocument,3,1,0,15,49,3,0,15,3,1.5,329,1.0,0,0.0,0.533333333,0,0,108.3333333,1,0.6667,1,"

package org.apache.xalan.xsltc.dom;

import java.net.URL;
import java.io.File;
import java.io.FileNotFoundException;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.XMLReader;
import org.xml.sax.SAXException;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.DOMCache;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;

public final class LoadDocument {

    private static final String NAMESPACE_FEATURE =
	""http:

    
    public static NodeIterator document(String uri, String base,
					AbstractTranslet translet, DOM dom)
	throws Exception 
    {
	final String originalUri = uri;
	MultiDOM multiplexer = (MultiDOM)dom;

	
	
	if (uri == null || uri.equals("""")) {
	    return new SingletonIterator(DOM.NULL,true);
	}

	
	if (base != null && !base.equals("""")) {
	    if (!uri.startsWith(base)     &&   
		!uri.startsWith(""/"")      &&   
		!uri.startsWith(""http:/"") &&   
		!uri.startsWith(""file:/"")) {   
		uri = base + uri;
	    }
	}

	
	final File file = new File(uri);
	if (file.exists()) {
	    uri = file.toURL().toExternalForm();
	}
	
	
	int mask = multiplexer.getDocumentMask(uri);
	if (mask != -1) {
	    return new SingletonIterator(DOM.ROOTNODE | mask, true);
	}

	
	DOMCache cache = translet.getDOMCache();
	DOMImpl newdom;

	mask = multiplexer.nextMask(); 

	if (cache != null) {
	    newdom = cache.retrieveDocument(originalUri, mask, translet);
	    if (newdom == null) {
		final Exception e = new FileNotFoundException(originalUri);
		throw new TransletException(e);
	    }
	}
	else {
	    
	    
	    final SAXParserFactory factory = SAXParserFactory.newInstance();
	    try {
		factory.setFeature(NAMESPACE_FEATURE,true);
	    }
	    catch (Exception e) {
		factory.setNamespaceAware(true);
	    }
	    final SAXParser parser = factory.newSAXParser();
	    final XMLReader reader = parser.getXMLReader();

	    
	    newdom = new DOMImpl();
	    reader.setContentHandler(newdom.getBuilder());
	    
	    DTDMonitor dtdMonitor = new DTDMonitor();
	    dtdMonitor.handleDTD(reader);

	    newdom.setDocumentURI(uri);
	    reader.parse(uri);

	    
	    translet.setIndexSize(newdom.getSize());
	    
	    dtdMonitor.buildIdIndex(newdom, mask, translet);
	    
	    translet.setUnparsedEntityURIs(dtdMonitor.getUnparsedEntityURIs());
	}

	
	final DOMAdapter domAdapter = translet.makeDOMAdapter(newdom);
	mask = multiplexer.addDOMAdapter(domAdapter);

	
	translet.buildKeys((DOM)newdom, null, null, DOM.ROOTNODE | mask);

	
	return new SingletonIterator(DOM.ROOTNODE | mask, true);
    }

    
    public static NodeIterator document(Object arg,String xmlURI,String xslURI,
					AbstractTranslet translet, DOM dom)
	throws TransletException {
	try {

	    
	    if (xmlURI != null) {
		final int sep = xmlURI.lastIndexOf('/') + 1;
		xmlURI = xmlURI.substring(0, sep); 
	    }
	    else {
		xmlURI = """";
	    }

	    
	    if (xslURI != null) {
		final int sep = xslURI.lastIndexOf('/') + 1;
		xslURI = xslURI.substring(0, sep); 
	    }
	    else {
		xslURI = """";
	    }

	    
	    
	    if (arg instanceof String) {
		
		try {
		    return document((String)arg, xmlURI, translet, dom);
		}
		
		catch (java.io.FileNotFoundException e) {
		    return document((String)arg, xslURI, translet, dom);
		}
		catch (org.xml.sax.SAXParseException e) {
		    return document((String)arg, xslURI, translet, dom);
		}
	    }
	    
	    
	    else if (arg instanceof NodeIterator) {
		UnionIterator union = new UnionIterator(dom);
		NodeIterator iterator = (NodeIterator)arg;
		int node;

		while ((node = iterator.next()) != DOM.NULL) {
		    String uri = dom.getNodeValue(node);
		    
		    if ((xmlURI == null) || xmlURI.equals("""")) {
			xmlURI = dom.getDocumentURI(node);
			final int sep = xmlURI.lastIndexOf('/') + 1;
			xmlURI = xmlURI.substring(0, sep);
		    }
		    
		    try {
			union.addIterator(document(uri, xmlURI, translet, dom));
		    }
		    
		    catch (java.io.FileNotFoundException e) {
			union.addIterator(document(uri, xslURI, translet, dom));
		    }
		}
		return(union);
	    }
	    else {
		final String err = ""document(""+arg.toString()+"")"";
		throw new IllegalArgumentException(err);
	    }
	}
	catch (TransletException e) {
	    throw e;
	}
	catch (Exception e) {
	    throw new TransletException(e);
	}
    }

}
"
org.apache.xalan.xsltc.compiler.AttributeValue,2,3,2,10,8,1,7,5,1,2.0,44,0.0,0,0.986111111,0.5,0,0,21.0,3,1.5,0,"

package org.apache.xalan.xsltc.compiler;
import org.apache.xalan.xsltc.compiler.util.*;

abstract class AttributeValue extends Expression {

    public static final AttributeValue create(SyntaxTreeNode parent,
					      String text, Parser parser) {

	AttributeValue result;
	if (text.indexOf('{') != -1) {
	    result = new AttributeValueTemplate(text, parser, parent);
	}
	else if (text.indexOf('}') != -1) {
	    result = new AttributeValueTemplate(text, parser, parent);
	}
	else {
	    result = new SimpleAttributeValue(text);
	    result.setParser(parser);
	    result.setParent(parent);
	}
	return result;
    }
}
"
org.apache.xalan.xsltc.dom.FilteredStepIterator,3,3,0,5,13,0,0,5,3,0.0,59,1.0,1,0.909090909,0.555555556,2,7,18.33333333,3,1.3333,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public final class FilteredStepIterator extends StepIterator {

    private Filter _filter;
	
    public FilteredStepIterator(NodeIterator source,
				NodeIterator iterator,
				Filter filter) {
	super(source, iterator);
	_filter = filter;
    }

    public NodeIterator cloneIterator() {
	try {
	    final FilteredStepIterator clone =
		(FilteredStepIterator)super.clone();
	    clone._source = _source.cloneIterator();
	    clone._iterator = _iterator.cloneIterator();
	    clone._filter = _filter;
	    clone.setRestartable(false);
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }

    public int next() {
	int node;
	while ((node = super.next()) != END) {
	    if (_filter.test(node))
		return returnNode(node);
	}
	return(node);
    }

}
"
org.apache.xalan.xsltc.compiler.LiteralAttribute,5,3,0,21,24,0,2,19,4,0.25,84,1.0,1,0.933333333,0.314285714,1,4,15.4,1,0.8,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class LiteralAttribute extends Instruction {

    private final String  _name;         
    private final AttributeValue _value; 

    
    public LiteralAttribute(String name, String value, Parser parser) {
	_name = name;
	_value = AttributeValue.create(this, value, parser);
    }

    public void display(int indent) {
	indent(indent);
	Util.println(""LiteralAttribute name="" + _name + "" value="" + _value);
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_value.typeCheck(stable);
	typeCheckContents(stable);
	return Type.Void;
    }

    protected boolean contextDependent() {
	return _value.contextDependent();
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadHandler());
	
	il.append(new PUSH(cpg, _name));
	
	_value.translate(classGen, methodGen);
	
	il.append(methodGen.attribute());
    }
}
"
org.apache.xalan.processor.ProcessorOutputElem,14,4,0,9,40,0,1,8,13,0.076923077,174,1.0,1,0.941704036,0.295918367,2,3,11.35714286,1,0.9286,0,"
package org.apache.xalan.processor;

import javax.xml.transform.OutputKeys;

import java.util.Hashtable;

import org.apache.xalan.templates.OutputProperties;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.ElemTemplateElement;

import org.apache.xml.utils.QName;
import org.apache.xml.utils.SystemIDResolver;

import javax.xml.transform.TransformerException;

import org.xml.sax.Attributes;


class ProcessorOutputElem extends XSLTElementProcessor
{

  
  private OutputProperties m_outputProperties;

  
  public void setCdataSectionElements(java.util.Vector newValue)
  {
    m_outputProperties.setQNameProperties(OutputKeys.CDATA_SECTION_ELEMENTS, newValue);
  }

  
  public void setDoctypePublic(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.DOCTYPE_PUBLIC, newValue);
  }

  
  public void setDoctypeSystem(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.DOCTYPE_SYSTEM, newValue);
  }

  
  public void setEncoding(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.ENCODING, newValue);
  }

  
  public void setIndent(boolean newValue)
  {
    m_outputProperties.setBooleanProperty(OutputKeys.INDENT, newValue);
  }

  
  public void setMediaType(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.MEDIA_TYPE, newValue);
  }

  
  public void setMethod(org.apache.xml.utils.QName newValue)
  {
    m_outputProperties.setQNameProperty(OutputKeys.METHOD, newValue);
  }

  
  public void setOmitXmlDeclaration(boolean newValue)
  {
    m_outputProperties.setBooleanProperty(OutputKeys.OMIT_XML_DECLARATION, newValue);
  }

  
  public void setStandalone(boolean newValue)
  {
    m_outputProperties.setBooleanProperty(OutputKeys.STANDALONE, newValue);
  }

  
  public void setVersion(String newValue)
  {
    m_outputProperties.setProperty(OutputKeys.VERSION, newValue);
  }
  
  
  public void setForeignAttr(String attrUri, String attrLocalName, String attrRawName, String attrValue)
  {
    QName key = new QName(attrUri, attrLocalName);
    m_outputProperties.setProperty(key, attrValue);
  }
  
  
  public void addLiteralResultAttribute(String attrUri, String attrLocalName, String attrRawName, String attrValue)
  {
    QName key = new QName(attrUri, attrLocalName);
    m_outputProperties.setProperty(key, attrValue);
  }

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {
    
    m_outputProperties = new OutputProperties();

    m_outputProperties.setDOMBackPointer(handler.getOriginatingNode());
    m_outputProperties.setLocaterInfo(handler.getLocator());
    m_outputProperties.setUid(handler.nextUid());
    setPropertiesFromAttributes(handler, rawName, attributes, this);
    
    
    
    String entitiesFileName =
      (String) m_outputProperties.getProperties().get(OutputProperties.S_KEY_ENTITIES);

    if (null != entitiesFileName)
    {
      try
      {
        String absURL = SystemIDResolver.getAbsoluteURI(entitiesFileName,
                    handler.getBaseIdentifier());
        m_outputProperties.getProperties().put(OutputProperties.S_KEY_ENTITIES, absURL);
      }
      catch(TransformerException te)
      {
        handler.error(te.getMessage(), te);
      }
    }
    
    handler.getStylesheet().setOutput(m_outputProperties);
    
    ElemTemplateElement parent = handler.getElemTemplateElement();
    parent.appendChild(m_outputProperties);
    
    m_outputProperties = null;
  }
}"
org.apache.xalan.xsltc.compiler.UnionPathExpr,6,3,0,24,36,0,2,23,5,0.5,289,1.0,3,0.934210526,0.285714286,2,8,46.5,7,2.5,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xalan.xsltc.compiler.util.Type;

import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class UnionPathExpr extends Expression {

    private final Expression _pathExpr;
    private final Expression _rest;
    private boolean _reverse = false;

    
    private Expression[] _components;
    
    public UnionPathExpr(Expression pathExpr, Expression rest) {
	_pathExpr = pathExpr;
	_rest     = rest;
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	
	final Vector components = new Vector();
	flatten(components);
	final int size = components.size();
	_components = (Expression[])components.toArray(new Expression[size]);
	for (int i = 0; i < size; i++) {
	    _components[i].setParser(parser);
	    _components[i].setParent(this);
	    if (_components[i] instanceof Step) {
		final Step step = (Step)_components[i];
		final int axis = step.getAxis();
		final int type = step.getNodeType();
		
		if ((axis == Axis.ATTRIBUTE) || (type == DOM.ATTRIBUTE)) {
		    _components[i] = _components[0];
		    _components[0] = step;
		}
		
		if (Axis.isReverse[axis]) _reverse = true;
	    }
	}
	
	if (getParent() instanceof Expression) _reverse = false;
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final int length = _components.length;
	for (int i = 0; i < length; i++) {
	    if (_components[i].typeCheck(stable) != Type.NodeSet) {
		_components[i] = new CastExpr(_components[i], Type.NodeSet);
	    }
	}
	return _type = Type.NodeSet;	
    }

    public String toString() {
	return ""union("" + _pathExpr + "", "" + _rest + ')';
    }
	
    private void flatten(Vector components) {
	components.addElement(_pathExpr);
	if (_rest != null) {
	    if (_rest instanceof UnionPathExpr) {
		((UnionPathExpr)_rest).flatten(components);
	    }
	    else {
		components.addElement(_rest);
	    }
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final int init = cpg.addMethodref(UNION_ITERATOR_CLASS,
					  ""<init>"",
					  ""(""+DOM_INTF_SIG+"")V"");
	final int iter = cpg.addMethodref(UNION_ITERATOR_CLASS,
					  ADD_ITERATOR,
					  ADD_ITERATOR_SIG);

	
	il.append(new NEW(cpg.addClass(UNION_ITERATOR_CLASS)));
	il.append(DUP);
	il.append(methodGen.loadDOM());
	il.append(new INVOKESPECIAL(init));

	
	final int length = _components.length;
	for (int i = 0; i < length; i++) {
	    _components[i].translate(classGen, methodGen);
	    il.append(new INVOKEVIRTUAL(iter));
	}

	
	if (_reverse) {
	    final int order = cpg.addInterfaceMethodref(DOM_INTF,
							ORDER_ITERATOR,
							ORDER_ITERATOR_SIG);
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	    il.append(methodGen.loadContextNode());
	    il.append(new INVOKEINTERFACE(order, 3));

	}
    }
}
"
org.apache.xalan.transformer.KeyManager,2,1,0,10,14,0,2,8,2,0.0,104,1.0,0,0.0,0.583333333,0,0,50.5,1,0.5,0,"
package org.apache.xalan.transformer;

import java.util.Vector;



import org.apache.xml.dtm.DTM;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.objects.XNodeSet;


public class KeyManager
{

  
  private transient Vector m_key_tables = null;

  
  public XNodeSet getNodeSetDTMByKey(
          XPathContext xctxt, int doc, QName name, XMLString ref, PrefixResolver nscontext)
            throws javax.xml.transform.TransformerException
  {

    XNodeSet nl = null;
    ElemTemplateElement template = (ElemTemplateElement) nscontext;  

    if ((null != template)
            && null != template.getStylesheetRoot().getKeysComposed())
    {
      boolean foundDoc = false;

      if (null == m_key_tables)
      {
        m_key_tables = new Vector(4);
      }
      else
      {
        int nKeyTables = m_key_tables.size();

        for (int i = 0; i < nKeyTables; i++)
        {
          KeyTable kt = (KeyTable) m_key_tables.elementAt(i);

          if (kt.getKeyTableName().equals(name) && doc == kt.getDocKey())
          {
            nl = kt.getNodeSetDTMByKey(name, ref);

            if (nl != null)
            {
              foundDoc = true;

              break;
            }
          }
        }
      }

      if ((null == nl) &&!foundDoc )
      {
        KeyTable kt =
          new KeyTable(doc, nscontext, name,
                       template.getStylesheetRoot().getKeysComposed(),
                       xctxt);

        m_key_tables.addElement(kt);

        if (doc == kt.getDocKey())
        {
          foundDoc = true;
          nl = kt.getNodeSetDTMByKey(name, ref);
        }
      }
    }

    return nl;
  }
}
"
org.apache.xalan.xsltc.compiler.Param,6,4,0,36,62,15,8,32,5,2.0,369,0.0,0,0.938271605,0.305555556,3,15,60.5,7,2.8333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;

import org.apache.bcel.generic.Instruction;
import org.apache.bcel.generic.*;
import org.apache.bcel.classfile.Field;

import org.apache.xalan.xsltc.compiler.util.*;

final class Param extends VariableBase {

    
    public String toString() {
	return(""param(""+_name+"")"");
    }

    
    public void display(int indent) {
	indent(indent);
	System.out.println(""param "" + _name);
	if (_select != null) {
	    indent(indent + IndentIncrement);
	    System.out.println(""select "" + _select.toString());
	}
	displayContents(indent + IndentIncrement);
    }

    
    public void parseContents(Parser parser) {

	
	super.parseContents(parser);

	
	final SyntaxTreeNode parent = getParent();
	if (parent instanceof Stylesheet) {
	    
	    _isLocal = false;
	    
	    Param param = parser.getSymbolTable().lookupParam(_name);
	    
	    if (param != null) {
		final int us = this.getImportPrecedence();
		final int them = param.getImportPrecedence();
		
		if (us == them) {
		    final String name = _name.toString();
		    reportError(this, parser, ErrorMsg.VARIABLE_REDEF_ERR,name);
		}
		
		else if (them > us) {
		    _ignore = true;
		    return;
		}
		else {
		    param.disable();
		}
	    }
	    
	    ((Stylesheet)parent).addParam(this);
	    parser.getSymbolTable().addParam(this);
	}
	else if (parent instanceof Template) {
	    _isLocal = true;
	    ((Template)parent).hasParams(true);
	}
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	if (_select != null) {
	    _type = _select.typeCheck(stable); 
	    if (_type instanceof ReferenceType == false) {
		_select = new CastExpr(_select, Type.Reference);
	    }
	}
	
	else if (hasContents()) {
	    typeCheckContents(stable);
	}
	_type = Type.Reference;

	
	
	return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_ignore) return;
	_ignore = true;

	final String name = getVariable();
	final String signature = _type.toSignature();
	final String className = _type.getClassName();

	if (isLocal()) {

	    il.append(classGen.loadTranslet());
	    il.append(new PUSH(cpg, name));
	    translateValue(classGen, methodGen);
	    il.append(new PUSH(cpg, true));

	    
	    il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
							 ADD_PARAMETER,
							 ADD_PARAMETER_SIG)));
	    if (className != EMPTYSTRING) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }

	    _type.translateUnBox(classGen, methodGen);

	    if (_refs.isEmpty()) { 
		il.append(_type.POP());
		_local = null;
	    }
	    else {		
		_local = methodGen.addLocalVariable2(name,
						     _type.toJCType(),
						     il.getEnd());
		
		il.append(_type.STORE(_local.getIndex()));
	    }
	}
	else {
	    if (classGen.containsField(name) == null) {
		classGen.addField(new Field(ACC_PUBLIC, cpg.addUtf8(name),
					    cpg.addUtf8(signature),
					    null, cpg.getConstantPool()));
		il.append(classGen.loadTranslet());
		il.append(DUP);
		il.append(new PUSH(cpg, name));
		translateValue(classGen, methodGen);
		il.append(new PUSH(cpg, true));

		
		il.append(new INVOKEVIRTUAL(cpg.addMethodref(TRANSLET_CLASS,
						     ADD_PARAMETER,
						     ADD_PARAMETER_SIG)));

		_type.translateUnBox(classGen, methodGen);

		
		if (className != EMPTYSTRING) {
		    il.append(new CHECKCAST(cpg.addClass(className)));
		}
		il.append(new PUTFIELD(cpg.addFieldref(classGen.getClassName(),
						       name, signature)));
	    }
	}
    }

}
"
org.apache.xml.utils.synthetic.reflection.Field,33,1,0,3,73,0,1,3,33,0.75,469,0.0,2,0.0,0.158508159,1,1,13.03030303,6,1.303,0,"
package org.apache.xml.utils.synthetic.reflection;

import org.apache.xml.utils.synthetic.Class;
import org.apache.xml.utils.synthetic.SynthesisException;


public class Field extends Object implements Member
{

  
  public String name, initializer = null;

  
  int modifiers;

  
  java.lang.reflect.Field realfield = null;

  
  Class declaringClass, type;

  
  public Field(java.lang.reflect.Field realfield,
               org.apache.xml.utils.synthetic.Class declaringClass)
  {

    this(realfield.getName(), declaringClass);

    this.realfield = realfield;
    this.type =
      org.apache.xml.utils.synthetic.Class.forClass(realfield.getType());
  }

  
  public Field(String name,
               org.apache.xml.utils.synthetic.Class declaringClass)
  {
    this.name = name;
    this.declaringClass = declaringClass;
  }

  
  public boolean equals(Object obj)
  {

    if (realfield != null)
      return realfield.equals(obj);
    else if (obj instanceof Field)
    {
      Field objf = (Field) obj;

      return (declaringClass.equals(objf.declaringClass)
              && name.equals(objf.name) && type.equals(objf.type));
    }
    else
      return false;
  }

  
  public Object get(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.get(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public boolean getBoolean(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getBoolean(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public byte getByte(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getByte(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public char getChar(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getChar(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public org.apache.xml.utils.synthetic.Class getDeclaringClass()
  {

    if (realfield != null)
      return org.apache.xml.utils.synthetic.Class.forClass(
        realfield.getDeclaringClass());

    throw new java.lang.IllegalStateException();
  }

  
  public double getDouble(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getDouble(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public float getFloat(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getFloat(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public int getInt(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getInt(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public long getLong(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getLong(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public int getModifiers()
  {

    if (realfield != null)
      modifiers = realfield.getModifiers();

    return modifiers;
  }

  
  public String getInitializer()
  {
    return initializer;
  }

  
  public void setInitializer(String i) throws SynthesisException
  {

    if (realfield != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    initializer = i;
  }

  
  public java.lang.String getName()
  {
    return name;
  }

  
  public short getShort(Object obj)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      return realfield.getShort(obj);

    throw new java.lang.IllegalStateException();
  }

  
  public Class getType()
  {

    if (realfield != null)
      type = Class.forClass(realfield.getType());

    return type;
  }

  
  public void setType(org.apache.xml.utils.synthetic.Class type)
          throws SynthesisException
  {

    if (realfield != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.type = type;
  }

  
  public int hashCode()
  {

    if (realfield != null)
      return realfield.hashCode();
    else
      return declaringClass.getName().hashCode() ^ name.hashCode();
  }

  
  public void set(Object obj, Object value)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.set(obj, value);

    throw new java.lang.IllegalStateException();
  }

  
  public void setBoolean(Object obj, boolean z)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setBoolean(obj, z);

    throw new java.lang.IllegalStateException();
  }

  
  public void setByte(Object obj, byte b)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setByte(obj, b);

    throw new java.lang.IllegalStateException();
  }

  
  public void setChar(Object obj, char c)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setChar(obj, c);

    throw new java.lang.IllegalStateException();
  }

  
  public void setDeclaringClass(
          org.apache.xml.utils.synthetic.Class declaringClass)
  {
    this.declaringClass = declaringClass;
  }

  
  public void setDouble(Object obj, double d)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setDouble(obj, d);

    throw new java.lang.IllegalStateException();
  }

  
  public void setFloat(Object obj, float f)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setFloat(obj, f);

    throw new java.lang.IllegalStateException();
  }

  
  public void setInt(Object obj, int i)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setInt(obj, i);

    throw new java.lang.IllegalStateException();
  }

  
  public void setLong(Object obj, long l)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setLong(obj, l);

    throw new java.lang.IllegalStateException();
  }

  
  public void setModifiers(int modifiers) throws SynthesisException
  {

    if (realfield != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.modifiers = modifiers;
  }

  
  public void setShort(Object obj, short s)
          throws IllegalArgumentException, IllegalAccessException
  {

    if (realfield != null)
      realfield.setShort(obj, s);

    throw new java.lang.IllegalStateException();
  }

  
  public String toString()
  {

    if (realfield != null)
      return realfield.toString();

    throw new java.lang.IllegalStateException();
  }

  
  public String toSource()
  {

    StringBuffer sb = new StringBuffer(
      java.lang.reflect.Modifier.toString(getModifiers())).append(' ').append(
      getType().getJavaName()).append(' ').append(getName());
    String i = getInitializer();

    if (i != null && i.length() > 0)
      sb.append('=').append(i);

    sb.append(';');

    return sb.toString();
  }
}
"
org.apache.xml.utils.UnImplNode,107,1,1,3,117,5671,2,1,107,2.0,648,0.0,0,0.0,0.191069574,0,0,5.056074766,1,0.9907,0,"
package org.apache.xml.utils;

import org.w3c.dom.*;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;


public class UnImplNode implements Node, Element, NodeList, Document
{

  
  public UnImplNode(){}

  
  public void error(int msg)
  {

    System.out.println(""DOM ERROR! class: "" + this.getClass().getName());

    throw new RuntimeException(XSLMessages.createMessage(msg, null));
  }

  
  public void error(int msg, Object[] args)
  {

    System.out.println(""DOM ERROR! class: "" + this.getClass().getName());

    throw new RuntimeException(XSLMessages.createMessage(msg, args));  
  }

  
  public Node appendChild(Node newChild) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean hasChildNodes()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public short getNodeType()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return 0;
  }

  
  public Node getParentNode()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public NodeList getChildNodes()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node getFirstChild()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node getLastChild()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node getNextSibling()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public int getLength()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return 0;
  }  

  
  public Node item(int index)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }  

  
  public Document getOwnerDocument()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public String getTagName()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public String getNodeName()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void normalize()
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public NodeList getElementsByTagName(String name)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Attr removeAttributeNode(Attr oldAttr) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Attr setAttributeNode(Attr newAttr) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean hasAttribute(String name)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public boolean hasAttributeNS(String name, String x)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public Attr getAttributeNode(String name)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void removeAttribute(String name) throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public void setAttribute(String name, String value) throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public String getAttribute(String name)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean hasAttributes()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public NodeList getElementsByTagNameNS(String namespaceURI,
                                         String localName)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Attr setAttributeNodeNS(Attr newAttr) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Attr getAttributeNodeNS(String namespaceURI, String localName)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void removeAttributeNS(String namespaceURI, String localName)
          throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public void setAttributeNS(
          String namespaceURI, String qualifiedName, String value)
            throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public String getAttributeNS(String namespaceURI, String localName)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node getPreviousSibling()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node cloneNode(boolean deep)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public String getNodeValue() throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void setNodeValue(String nodeValue) throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  

  
  
  
  
  

  
  public void setValue(String value) throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  

  
  
  
  

  
  public Element getOwnerElement()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean getSpecified()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return false;
  }

  
  public NamedNodeMap getAttributes()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node insertBefore(Node newChild, Node refChild) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node replaceChild(Node newChild, Node oldChild) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public Node removeChild(Node oldChild) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public boolean isSupported(String feature, String version)
  {
    return false;
  }

  
  public String getNamespaceURI()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public String getPrefix()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public void setPrefix(String prefix) throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  
  }

  
  public String getLocalName()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);  

    return null;
  }

  
  public DocumentType getDoctype()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public DOMImplementation getImplementation()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Element getDocumentElement()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Element createElement(String tagName) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public DocumentFragment createDocumentFragment()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Text createTextNode(String data)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Comment createComment(String data)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public CDATASection createCDATASection(String data) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public ProcessingInstruction createProcessingInstruction(
          String target, String data) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Attr createAttribute(String name) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public EntityReference createEntityReference(String name)
          throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Node importNode(Node importedNode, boolean deep) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Element createElementNS(String namespaceURI, String qualifiedName)
          throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Attr createAttributeNS(String namespaceURI, String qualifiedName)
          throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Element getElementById(String elementId)
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public void setData(String data) throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public String substringData(int offset, int count) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public void appendData(String arg) throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public void insertData(int offset, String arg) throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public void deleteData(int offset, int count) throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public void replaceData(int offset, int count, String arg)
          throws DOMException
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public Text splitText(int offset) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public Node adoptNode(Node source) throws DOMException
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public String getEncoding()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public void setEncoding(String encoding)
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public boolean getStandalone()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return false;
  }

  
  public void setStandalone(boolean standalone)
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public boolean getStrictErrorChecking()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return false;
  }

  
  public void setStrictErrorChecking(boolean strictErrorChecking)
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }

  
  public String getVersion()
  {

    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);

    return null;
  }

  
  public void setVersion(String version)
  {
    error(XSLTErrorResources.ER_FUNCTION_NOT_SUPPORTED);
  }
}
"
org.apache.xpath.XPathFactory,1,1,0,5,1,0,3,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xpath;



import org.apache.xml.utils.PrefixResolver;

import javax.xml.transform.SourceLocator;


public interface XPathFactory
{

  
  XPath create(String exprString, SourceLocator locator,
               PrefixResolver prefixResolver, int type);
}
"
org.apache.xalan.processor.ProcessorGlobalVariableDecl,3,5,0,6,10,3,1,5,1,2.0,30,0.0,0,0.990697674,0.583333333,1,2,9.0,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemVariable;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;


class ProcessorGlobalVariableDecl extends ProcessorTemplateElem
{

  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    
    handler.pushElemTemplateElement(elem);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    ElemVariable v = (ElemVariable) handler.getElemTemplateElement();

    handler.getStylesheet().appendChild(v);
    handler.getStylesheet().setVariable(v);
    super.endElement(handler, uri, localName, rawName);
  }
}
"
org.apache.xalan.xsltc.compiler.util.FilterGenerator,4,4,0,6,6,2,2,4,3,0.666666667,29,1.0,0,0.975903614,0.466666667,0,0,5.75,1,0.5,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Stylesheet;


public final class FilterGenerator extends ClassGenerator {
    private static int TRANSLET_INDEX = 5;   
    private final Instruction _aloadTranslet;

    public FilterGenerator(String className, String superClassName,
			   String fileName,
			   int accessFlags, String[] interfaces,
			   Stylesheet stylesheet) {
	super(className, superClassName, fileName,
	      accessFlags, interfaces, stylesheet);
	
	_aloadTranslet = new ALOAD(TRANSLET_INDEX);
    }

    
    public final Instruction loadTranslet() {
	return _aloadTranslet;
    }
    
    
    public boolean isExternal() {
	return true;
    }
}
"
org.apache.xpath.axes.WalkerFactory,51,1,0,27,115,1275,11,25,40,1.02,2159,0.0,0,0.0,0.181372549,0,0,40.82352941,18,3.3333,1,"
package org.apache.xpath.axes;

import org.apache.xpath.compiler.OpCodes;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.FunctionTable;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.patterns.StepPattern;
import org.apache.xpath.patterns.ContextMatchStepPattern;
import org.apache.xpath.patterns.FunctionPattern;
import org.apache.xpath.Expression;
import org.apache.xpath.objects.XNumber;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;

import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.Axis;


public class WalkerFactory
{

  
  static AxesWalker loadOneWalker(
          WalkingIterator lpi, Compiler compiler, int stepOpCodePos)
            throws javax.xml.transform.TransformerException
  {

    AxesWalker firstWalker = null;
    int stepType = compiler.getOpMap()[stepOpCodePos];

    if (stepType != OpCodes.ENDOP)
    {

      
      
      firstWalker = createDefaultWalker(compiler, stepType, lpi, 0);

      firstWalker.init(compiler, stepOpCodePos, stepType);
    }

    return firstWalker;
  }

  
  static AxesWalker loadWalkers(
          WalkingIterator lpi, Compiler compiler, int stepOpCodePos, int stepIndex)
            throws javax.xml.transform.TransformerException
  {

    int stepType;
    AxesWalker firstWalker = null;
    AxesWalker walker, prevWalker = null;
    int ops[] = compiler.getOpMap();
    int analysis = analyze(compiler, stepOpCodePos, stepIndex);

    while (OpCodes.ENDOP != (stepType = ops[stepOpCodePos]))
    {
      walker = createDefaultWalker(compiler, stepOpCodePos, lpi, analysis);

      walker.init(compiler, stepOpCodePos, stepType);
      walker.exprSetParent(lpi);

      
      if (null == firstWalker)
      {
        firstWalker = walker;
      }
      else
      {
        prevWalker.setNextWalker(walker);
        walker.setPrevWalker(prevWalker);
      }

      prevWalker = walker;
      stepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (stepOpCodePos < 0)
        break;
    }

    return firstWalker;
  }
  
  public static boolean isSet(int analysis, int bits)
  {
    return (0 != (analysis & bits));
  }
  
  public static void diagnoseIterator(String name, int analysis, Compiler compiler)
  {
    System.out.println(compiler.toString()+"", ""+name+"", ""
                             + Integer.toBinaryString(analysis) + "", ""
                             + getAnalysisString(analysis));
  }

  
  public static DTMIterator newDTMIterator(
          Compiler compiler, int opPos,
          boolean isTopLevel)
            throws javax.xml.transform.TransformerException
  {

    int firstStepPos = compiler.getFirstChildPos(opPos);
    int analysis = analyze(compiler, firstStepPos, 0);
    boolean isOneStep = isOneStep(analysis);
    DTMIterator iter;

    
    if (isOneStep && walksSelfOnly(analysis) && 
        isWild(analysis) && !hasPredicate(analysis))
    {
      if (DEBUG_ITERATOR_CREATION)
        diagnoseIterator(""SelfIteratorNoPredicate"", analysis, compiler);

      
      
      iter = new SelfIteratorNoPredicate(compiler, opPos, analysis);
    }
    
    else if (walksChildrenOnly(analysis) && isOneStep)
    {

      
      if (isWild(analysis) && !hasPredicate(analysis))
      {
        if (DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""ChildIterator"", analysis, compiler);

        
        iter = new ChildIterator(compiler, opPos, analysis);
      }
      else
      {
        if (DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""ChildTestIterator"", analysis, compiler);

        
        iter = new ChildTestIterator(compiler, opPos, analysis);
      }
    }
    
    else if (isOneStep && walksAttributes(analysis))
    {
      if (DEBUG_ITERATOR_CREATION)
        diagnoseIterator(""AttributeIterator"", analysis, compiler);

      
      
      iter = new AttributeIterator(compiler, opPos, analysis);
    }
    else if(isOneStep && !walksFilteredList(analysis))
    {
      if( !walksNamespaces(analysis) 
      && (walksInDocOrder(analysis) || isSet(analysis, BIT_PARENT)))
      {
        if (false || DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""OneStepIteratorForward"", analysis, compiler);
  
        
        
        iter = new OneStepIteratorForward(compiler, opPos, analysis);
      }
      else
      {
        if (false || DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""OneStepIterator"", analysis, compiler);
  
        
        
        iter = new OneStepIterator(compiler, opPos, analysis);
      }
    }

    
    
    
    
    
    
    
    
    
    
    
    
    else if (isOptimizableForDescendantIterator(compiler, firstStepPos, 0)
              
              
              
             )
    {
      if (DEBUG_ITERATOR_CREATION)
        diagnoseIterator(""DescendantIterator"", analysis, compiler);

      iter = new DescendantIterator(compiler, opPos, analysis);
    }
    else
    { 
      if(isNaturalDocOrder(compiler, firstStepPos, 0, analysis))
      {
        if (false || DEBUG_ITERATOR_CREATION)
        {
          diagnoseIterator(""WalkingIterator"", analysis, compiler);
        }
  
        iter = new WalkingIterator(compiler, opPos, analysis, true);
      }
      else
      {




        if (DEBUG_ITERATOR_CREATION)
          diagnoseIterator(""WalkingIteratorSorted"", analysis, compiler);

        iter = new WalkingIteratorSorted(compiler, opPos, analysis, true);
      }
    }
    if(iter instanceof LocPathIterator)
      ((LocPathIterator)iter).setIsTopLevel(isTopLevel);
      
    return iter;
  }
  
  
  public static int getAxisFromStep(
          Compiler compiler, int stepOpCodePos)
            throws javax.xml.transform.TransformerException
  {

    int ops[] = compiler.getOpMap();
    int stepType = ops[stepOpCodePos];

    switch (stepType)
    {
    case OpCodes.FROM_FOLLOWING :
      return Axis.FOLLOWING;
    case OpCodes.FROM_FOLLOWING_SIBLINGS :
      return Axis.FOLLOWINGSIBLING;
    case OpCodes.FROM_PRECEDING :
      return Axis.PRECEDING;
    case OpCodes.FROM_PRECEDING_SIBLINGS :
      return Axis.PRECEDINGSIBLING;
    case OpCodes.FROM_PARENT :
      return Axis.PARENT;
    case OpCodes.FROM_NAMESPACE :
      return Axis.NAMESPACE;
    case OpCodes.FROM_ANCESTORS :
      return Axis.ANCESTOR;
    case OpCodes.FROM_ANCESTORS_OR_SELF :
      return Axis.ANCESTORORSELF;
    case OpCodes.FROM_ATTRIBUTES :
      return Axis.ATTRIBUTE;
    case OpCodes.FROM_ROOT :
      return Axis.ROOT;
    case OpCodes.FROM_CHILDREN :
      return Axis.CHILD;
    case OpCodes.FROM_DESCENDANTS_OR_SELF :
      return Axis.DESCENDANTORSELF;
    case OpCodes.FROM_DESCENDANTS :
      return Axis.DESCENDANT;
    case OpCodes.FROM_SELF :
      return Axis.SELF;
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
    case OpCodes.OP_VARIABLE :
      return Axis.FILTEREDLIST;
    }

    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                               
   }
    
    
    static public int getAnalysisBitFromAxes(int axis)
    {
      switch (axis) 
        {
        case Axis.ANCESTOR :
          return BIT_ANCESTOR;
        case Axis.ANCESTORORSELF :
          return BIT_ANCESTOR_OR_SELF;
        case Axis.ATTRIBUTE :
          return BIT_ATTRIBUTE;
        case Axis.CHILD :
          return BIT_CHILD;
        case Axis.DESCENDANT :
          return BIT_DESCENDANT;
        case Axis.DESCENDANTORSELF :
          return BIT_DESCENDANT_OR_SELF;
        case Axis.FOLLOWING :
          return BIT_FOLLOWING;
        case Axis.FOLLOWINGSIBLING :
          return BIT_FOLLOWING_SIBLING;
        case Axis.NAMESPACE :
        case Axis.NAMESPACEDECLS :
          return BIT_NAMESPACE;
        case Axis.PARENT :
          return BIT_PARENT;
        case Axis.PRECEDING :
          return BIT_PRECEDING;
        case Axis.PRECEDINGSIBLING :
          return BIT_PRECEDING_SIBLING;
        case Axis.SELF :
          return BIT_SELF;
        case Axis.ALLFROMNODE :
          return BIT_DESCENDANT_OR_SELF;
          
        case Axis.DESCENDANTSFROMROOT :
        case Axis.ALL :
        case Axis.DESCENDANTSORSELFFROMROOT :
          return BIT_ANY_DESCENDANT_FROM_ROOT;
        case Axis.ROOT :
          return BIT_ROOT;
        case Axis.FILTEREDLIST :
          return BIT_FILTER;
        default :
          return BIT_FILTER;
      }
    }
  
  static boolean functionProximateOrContainsProximate(Compiler compiler, 
                                                      int opPos)
  {
    int endFunc = opPos + compiler.getOp(opPos + 1) - 1;
    opPos = compiler.getFirstChildPos(opPos);
    int funcID = compiler.getOp(opPos);
    
    
    
    switch(funcID)
    {
      case FunctionTable.FUNC_LAST:
      case FunctionTable.FUNC_POSITION:
        return true;
      default:
        opPos++;
        int i = 0;
        for (int p = opPos; p < endFunc; p = compiler.getNextOpPos(p), i++)
        {
          int innerExprOpPos = p+2;
          int argOp = compiler.getOp(innerExprOpPos);
          boolean prox = isProximateInnerExpr(compiler, innerExprOpPos);
          if(prox)
            return true;
        }

    }
    return false;
  }
  
  static boolean isProximateInnerExpr(Compiler compiler, int opPos)
  {
    int op = compiler.getOp(opPos);
    int innerExprOpPos = opPos+2;
    switch(op)
    {
      case OpCodes.OP_ARGUMENT:
        if(isProximateInnerExpr(compiler, innerExprOpPos))
          return true;
        break;
      case OpCodes.OP_VARIABLE:
      case OpCodes.OP_NUMBERLIT:
      case OpCodes.OP_LITERAL:
      case OpCodes.OP_LOCATIONPATH:
        break; 
      case OpCodes.OP_FUNCTION:
        boolean isProx = functionProximateOrContainsProximate(compiler, opPos);
        if(isProx)
          return true;
        break;
      case OpCodes.OP_GT:
      case OpCodes.OP_GTE:
      case OpCodes.OP_LT:
      case OpCodes.OP_LTE:
      case OpCodes.OP_EQUALS:
        int leftPos = compiler.getFirstChildPos(op);
        int rightPos = compiler.getNextOpPos(leftPos);
        isProx = isProximateInnerExpr(compiler, leftPos);
        if(isProx)
          return true;
        isProx = isProximateInnerExpr(compiler, rightPos);
        if(isProx)
          return true;
        break;
      default:
        return true; 
    }
    return false;
  }
    
  
  public static boolean mightBeProximate(Compiler compiler, int opPos, int stepType)
          throws javax.xml.transform.TransformerException
  {

    boolean mightBeProximate = false;
    int argLen;

    switch (stepType)
    {
    case OpCodes.OP_VARIABLE :
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
      argLen = compiler.getArgLength(opPos);
      break;
    default :
      argLen = compiler.getArgLengthOfStep(opPos);
    }

    int predPos = compiler.getFirstPredicateOpPos(opPos);
    int count = 0;

    while (OpCodes.OP_PREDICATE == compiler.getOp(predPos))
    {
      count++;
      
      int innerExprOpPos = predPos+2;
      int predOp = compiler.getOp(innerExprOpPos);

      switch(predOp)
      {
        case OpCodes.OP_VARIABLE:
        	return true; 
        case OpCodes.OP_LOCATIONPATH:
          
          break;
        case OpCodes.OP_NUMBER:
        case OpCodes.OP_NUMBERLIT:
          return true; 
        case OpCodes.OP_FUNCTION:
          boolean isProx 
            = functionProximateOrContainsProximate(compiler, innerExprOpPos);
          if(isProx)
            return true;
          break;
        case OpCodes.OP_GT:
        case OpCodes.OP_GTE:
        case OpCodes.OP_LT:
        case OpCodes.OP_LTE:
        case OpCodes.OP_EQUALS:
          int leftPos = compiler.getFirstChildPos(innerExprOpPos);
          int rightPos = compiler.getNextOpPos(leftPos);
          isProx = isProximateInnerExpr(compiler, leftPos);
          if(isProx)
            return true;
          isProx = isProximateInnerExpr(compiler, rightPos);
          if(isProx)
            return true;
          break;
        default:
          return true; 
      }

      predPos = compiler.getNextOpPos(predPos);
    }

    return mightBeProximate;
  }
  
  
  private static boolean isOptimizableForDescendantIterator(
          Compiler compiler, int stepOpCodePos, int stepIndex)
            throws javax.xml.transform.TransformerException
  {

    int stepType;
    int ops[] = compiler.getOpMap();
    int stepCount = 0;
    boolean foundDorDS = false;
    boolean foundSelf = false;
    boolean foundDS = false;
    
    int nodeTestType = OpCodes.NODETYPE_NODE;
    
    while (OpCodes.ENDOP != (stepType = ops[stepOpCodePos]))
    {
      
      
      if(nodeTestType != OpCodes.NODETYPE_NODE && nodeTestType != OpCodes.NODETYPE_ROOT)
        return false;
        
      stepCount++;
      if(stepCount > 3)
        return false;
        
      boolean mightBeProximate = mightBeProximate(compiler, stepOpCodePos, stepType);
      if(mightBeProximate)
        return false;

      switch (stepType)
      {
      case OpCodes.FROM_FOLLOWING :
      case OpCodes.FROM_FOLLOWING_SIBLINGS :
      case OpCodes.FROM_PRECEDING :
      case OpCodes.FROM_PRECEDING_SIBLINGS :
      case OpCodes.FROM_PARENT :
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
      case OpCodes.FROM_NAMESPACE :
      case OpCodes.FROM_ANCESTORS :
      case OpCodes.FROM_ANCESTORS_OR_SELF :
      case OpCodes.FROM_ATTRIBUTES :
      case OpCodes.MATCH_ATTRIBUTE :
      case OpCodes.MATCH_ANY_ANCESTOR :
      case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
        return false;
      case OpCodes.FROM_ROOT :
        if(1 != stepCount)
          return false;
        break;
      case OpCodes.FROM_CHILDREN :
        if(!foundDS && !(foundDorDS && foundSelf))
          return false;
        break;
      case OpCodes.FROM_DESCENDANTS_OR_SELF :
        foundDS = true;
      case OpCodes.FROM_DESCENDANTS :
        if(3 == stepCount)
          return false;
        foundDorDS = true;
        break;
      case OpCodes.FROM_SELF :
        if(1 != stepCount)
          return false;
        foundSelf = true;
        break;
      default :
        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                  
      }
      
      nodeTestType = compiler.getStepTestType(stepOpCodePos);

      int nextStepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (nextStepOpCodePos < 0)
        break;
        
      if(OpCodes.ENDOP != ops[nextStepOpCodePos])
      {
        if(compiler.countPredicates(stepOpCodePos) > 0)
        {
          return false;
        }
      }
      
      stepOpCodePos = nextStepOpCodePos;
    }

    return true;
  }

  
  private static int analyze(
          Compiler compiler, int stepOpCodePos, int stepIndex)
            throws javax.xml.transform.TransformerException
  {

    int stepType;
    int ops[] = compiler.getOpMap();
    int stepCount = 0;
    int analysisResult = 0x00000000;  

    while (OpCodes.ENDOP != (stepType = ops[stepOpCodePos]))
    {
      stepCount++;

      
      
      
      
      
      boolean predAnalysis = analyzePredicate(compiler, stepOpCodePos,
                                              stepType);

      if (predAnalysis)
        analysisResult |= BIT_PREDICATE;

      switch (stepType)
      {
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
        analysisResult |= BIT_FILTER;
        break;
      case OpCodes.FROM_ROOT :
        analysisResult |= BIT_ROOT;
        break;
      case OpCodes.FROM_ANCESTORS :
        analysisResult |= BIT_ANCESTOR;
        break;
      case OpCodes.FROM_ANCESTORS_OR_SELF :
        analysisResult |= BIT_ANCESTOR_OR_SELF;
        break;
      case OpCodes.FROM_ATTRIBUTES :
        analysisResult |= BIT_ATTRIBUTE;
        break;
      case OpCodes.FROM_NAMESPACE :
        analysisResult |= BIT_NAMESPACE;
        break;
      case OpCodes.FROM_CHILDREN :
        analysisResult |= BIT_CHILD;
        break;
      case OpCodes.FROM_DESCENDANTS :
        analysisResult |= BIT_DESCENDANT;
        break;
      case OpCodes.FROM_DESCENDANTS_OR_SELF :

        
        if (2 == stepCount && BIT_ROOT == analysisResult)
        {
          analysisResult |= BIT_ANY_DESCENDANT_FROM_ROOT;
        }

        analysisResult |= BIT_DESCENDANT_OR_SELF;
        break;
      case OpCodes.FROM_FOLLOWING :
        analysisResult |= BIT_FOLLOWING;
        break;
      case OpCodes.FROM_FOLLOWING_SIBLINGS :
        analysisResult |= BIT_FOLLOWING_SIBLING;
        break;
      case OpCodes.FROM_PRECEDING :
        analysisResult |= BIT_PRECEDING;
        break;
      case OpCodes.FROM_PRECEDING_SIBLINGS :
        analysisResult |= BIT_PRECEDING_SIBLING;
        break;
      case OpCodes.FROM_PARENT :
        analysisResult |= BIT_PARENT;
        break;
      case OpCodes.FROM_SELF :
        analysisResult |= BIT_SELF;
        break;
      case OpCodes.MATCH_ATTRIBUTE :
        analysisResult |= (BIT_MATCH_PATTERN | BIT_ATTRIBUTE);
        break;
      case OpCodes.MATCH_ANY_ANCESTOR :
        analysisResult |= (BIT_MATCH_PATTERN | BIT_ANCESTOR);
        break;
      case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
        analysisResult |= (BIT_MATCH_PATTERN | BIT_PARENT);
        break;
      default :
        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                   
      }

      if (OpCodes.NODETYPE_NODE == ops[stepOpCodePos + 3])  
      {
        analysisResult |= BIT_NODETEST_ANY;
      }

      stepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (stepOpCodePos < 0)
        break;
    }

    analysisResult |= (stepCount & BITS_COUNT);

    return analysisResult;
  }
  
  
  public static boolean isDownwardAxisOfMany(int axis)
  {
    return ((Axis.DESCENDANTORSELF == axis) ||
          (Axis.DESCENDANT == axis) 
          || (Axis.FOLLOWING == axis) 

          || (Axis.PRECEDING == axis) 

          );
  }

  
  static StepPattern loadSteps(
          MatchPatternIterator mpi, Compiler compiler, int stepOpCodePos, 
                                                       int stepIndex)
            throws javax.xml.transform.TransformerException
  {
    if (DEBUG_PATTERN_CREATION)
    {
      System.out.println(""================"");
      System.out.println(""loadSteps for: ""+compiler.getPatternString());
    }
    int stepType;
    StepPattern step = null;
    StepPattern firstStep = null, prevStep = null;
    int ops[] = compiler.getOpMap();
    int analysis = analyze(compiler, stepOpCodePos, stepIndex);

    while (OpCodes.ENDOP != (stepType = ops[stepOpCodePos]))
    {
      step = createDefaultStepPattern(compiler, stepOpCodePos, mpi, analysis,
                                      firstStep, prevStep);

      if (null == firstStep)
      {
        firstStep = step;
      }
      else
      {

        
        step.setRelativePathPattern(prevStep);
      }

      prevStep = step;
      stepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (stepOpCodePos < 0)
        break;
    }
    
    int axis = Axis.SELF;
    int paxis = Axis.SELF;
    StepPattern tail = step;
    for (StepPattern pat = step; null != pat; 
         pat = pat.getRelativePathPattern()) 
    {
      int nextAxis = pat.getAxis();
      
      pat.setAxis(axis);
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      int whatToShow = pat.getWhatToShow();
      if(whatToShow == DTMFilter.SHOW_ATTRIBUTE || 
         whatToShow == DTMFilter.SHOW_NAMESPACE)
      {
        int newAxis = (whatToShow == DTMFilter.SHOW_ATTRIBUTE) ? 
                       Axis.ATTRIBUTE : Axis.NAMESPACE;
        if(isDownwardAxisOfMany(axis))
        {
          StepPattern attrPat = new StepPattern(whatToShow, 
                                    pat.getNamespace(),
                                    pat.getLocalName(),
                                
                                                newAxis, 0); 
          XNumber score = pat.getStaticScore();
          pat.setNamespace(null);
          pat.setLocalName(NodeTest.WILD);
          attrPat.setPredicates(pat.getPredicates());
          pat.setPredicates(null);
          pat.setWhatToShow(DTMFilter.SHOW_ELEMENT);
          StepPattern rel = pat.getRelativePathPattern();
          pat.setRelativePathPattern(attrPat);
          attrPat.setRelativePathPattern(rel);
          attrPat.setStaticScore(score);
          
          
          
          
          
          if(Axis.PRECEDING == pat.getAxis())
            pat.setAxis(Axis.PRECEDINGANDANCESTOR);
            
          else if(Axis.DESCENDANT == pat.getAxis())
            pat.setAxis(Axis.DESCENDANTORSELF);
          
          pat = attrPat;
        }
        else if(Axis.CHILD == pat.getAxis())
        {
          
          
          pat.setAxis(Axis.ATTRIBUTE);
        }
      }
      axis = nextAxis;
      
      tail = pat;
    }
    
    if(axis < Axis.ALL)
    {
      StepPattern selfPattern = new ContextMatchStepPattern(axis, paxis);
      
      XNumber score = tail.getStaticScore();
      tail.setRelativePathPattern(selfPattern);
      tail.setStaticScore(score);
      selfPattern.setStaticScore(score);
    }        

    if (DEBUG_PATTERN_CREATION)
    {
      System.out.println(""Done loading steps: ""+step.toString());
            
      System.out.println("""");
    }
    return step;  
  }

  
  private static StepPattern createDefaultStepPattern(
          Compiler compiler, int opPos, MatchPatternIterator mpi, 
          int analysis, StepPattern tail, StepPattern head)
            throws javax.xml.transform.TransformerException
  {

    int stepType = compiler.getOp(opPos);
    boolean simpleInit = false;
    int totalNumberWalkers = (analysis & BITS_COUNT);
    boolean prevIsOneStepDown = true;
    int firstStepPos = compiler.getFirstChildPos(opPos);
    
    int whatToShow = compiler.getWhatToShow(opPos);
    StepPattern ai = null;
    int axis, predicateAxis;
    
    switch (stepType)
    {
    case OpCodes.OP_VARIABLE :
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
      prevIsOneStepDown = false;

      Expression expr;

      switch (stepType)
      {
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
        expr = compiler.compile(opPos);
        break;
      default :
        expr = compiler.compile(opPos + 2);
      }

      axis = Axis.FILTEREDLIST;
      predicateAxis = Axis.FILTEREDLIST;
      ai = new FunctionPattern(expr, axis, predicateAxis);
      simpleInit = true;
      break;
    case OpCodes.FROM_ROOT :
      whatToShow = DTMFilter.SHOW_DOCUMENT
                   | DTMFilter.SHOW_DOCUMENT_FRAGMENT;

      axis = Axis.ROOT;
      predicateAxis = Axis.ROOT;
      ai = new StepPattern(DTMFilter.SHOW_DOCUMENT | 
                                DTMFilter.SHOW_DOCUMENT_FRAGMENT,
                                axis, predicateAxis);
      break;
    case OpCodes.FROM_ATTRIBUTES :
      whatToShow = DTMFilter.SHOW_ATTRIBUTE;
      axis = Axis.PARENT;
      predicateAxis = Axis.ATTRIBUTE;
      
      break;
    case OpCodes.FROM_NAMESPACE :
      whatToShow = DTMFilter.SHOW_NAMESPACE;
      axis = Axis.PARENT;
      predicateAxis = Axis.NAMESPACE;
      
      break;
    case OpCodes.FROM_ANCESTORS :
      axis = Axis.DESCENDANT;
      predicateAxis = Axis.ANCESTOR;
      break;
    case OpCodes.FROM_CHILDREN :
      axis = Axis.PARENT;
      predicateAxis = Axis.CHILD;
      break;
    case OpCodes.FROM_ANCESTORS_OR_SELF :
      axis = Axis.DESCENDANTORSELF;
      predicateAxis = Axis.ANCESTORORSELF;
      break;
    case OpCodes.FROM_SELF :
      axis = Axis.SELF;
      predicateAxis = Axis.SELF;
      break;
    case OpCodes.FROM_PARENT :
      axis = Axis.CHILD;
      predicateAxis = Axis.PARENT;
      break;
    case OpCodes.FROM_PRECEDING_SIBLINGS :
      axis = Axis.FOLLOWINGSIBLING;
      predicateAxis = Axis.PRECEDINGSIBLING;
      break;
    case OpCodes.FROM_PRECEDING :
      axis = Axis.FOLLOWING;
      predicateAxis = Axis.PRECEDING;
      break;
    case OpCodes.FROM_FOLLOWING_SIBLINGS :
      axis = Axis.PRECEDINGSIBLING;
      predicateAxis = Axis.FOLLOWINGSIBLING;
      break;
    case OpCodes.FROM_FOLLOWING :
      axis = Axis.PRECEDING;
      predicateAxis = Axis.FOLLOWING;
      break;
    case OpCodes.FROM_DESCENDANTS_OR_SELF :
      axis = Axis.ANCESTORORSELF;
      predicateAxis = Axis.DESCENDANTORSELF;
      break;
    case OpCodes.FROM_DESCENDANTS :
      axis = Axis.ANCESTOR;
      predicateAxis = Axis.DESCENDANT;
      break;
    default :
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                 
    }
    if(null == ai)
    {
      whatToShow = compiler.getWhatToShow(opPos); 
      ai = new StepPattern(whatToShow, compiler.getStepNS(opPos),
                                compiler.getStepLocalName(opPos),
                                axis, predicateAxis);
    }
   
    if (false || DEBUG_PATTERN_CREATION)
    {
      System.out.print(""new step: ""+ ai);
      System.out.print("", axis: "" + Axis.names[ai.getAxis()]);
      System.out.print("", predAxis: "" + Axis.names[ai.getAxis()]);
      System.out.print("", what: "");
      System.out.print(""    "");
      ai.debugWhatToShow(ai.getWhatToShow());
    }

    int argLen = compiler.getFirstPredicateOpPos(opPos);

    ai.setPredicates(compiler.getCompiledPredicates(argLen));

    return ai;
  }

  
  static boolean analyzePredicate(Compiler compiler, int opPos, int stepType)
          throws javax.xml.transform.TransformerException
  {

    int argLen;

    switch (stepType)
    {
    case OpCodes.OP_VARIABLE :
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
      argLen = compiler.getArgLength(opPos);
      break;
    default :
      argLen = compiler.getArgLengthOfStep(opPos);
    }

    int pos = compiler.getFirstPredicateOpPos(opPos);
    int nPredicates = compiler.countPredicates(pos);

    return (nPredicates > 0) ? true : false;
  }

  
  private static AxesWalker createDefaultWalker(Compiler compiler, int opPos,
          WalkingIterator lpi, int analysis)
  {

    AxesWalker ai = null;
    int stepType = compiler.getOp(opPos);

    
    boolean simpleInit = false;
    int totalNumberWalkers = (analysis & BITS_COUNT);
    boolean prevIsOneStepDown = true;

    switch (stepType)
    {
    case OpCodes.OP_VARIABLE :
    case OpCodes.OP_EXTFUNCTION :
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_GROUP :
      prevIsOneStepDown = false;

      if (DEBUG_WALKER_CREATION)
        System.out.println(""new walker:  FilterExprWalker: "" + analysis
                           + "", "" + compiler.toString());

      ai = new FilterExprWalker(lpi);
      simpleInit = true;
      break;
    case OpCodes.FROM_ROOT :
      ai = new AxesWalker(lpi, Axis.ROOT);
      break;
    case OpCodes.FROM_ANCESTORS :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.ANCESTOR);
      break;
    case OpCodes.FROM_ANCESTORS_OR_SELF :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.ANCESTORORSELF);
      break;
    case OpCodes.FROM_ATTRIBUTES :
      ai = new AxesWalker(lpi, Axis.ATTRIBUTE);
      break;
    case OpCodes.FROM_NAMESPACE :
      ai = new AxesWalker(lpi, Axis.NAMESPACE);
      break;
    case OpCodes.FROM_CHILDREN :
      ai = new AxesWalker(lpi, Axis.CHILD);
      break;
    case OpCodes.FROM_DESCENDANTS :
      prevIsOneStepDown = false;
      ai = new AxesWalker(lpi, Axis.DESCENDANT);
      break;
    case OpCodes.FROM_DESCENDANTS_OR_SELF :
      prevIsOneStepDown = false;
      ai = new AxesWalker(lpi, Axis.DESCENDANTORSELF);
      break;
    case OpCodes.FROM_FOLLOWING :
      prevIsOneStepDown = false;
      ai = new AxesWalker(lpi, Axis.FOLLOWING);
      break;
    case OpCodes.FROM_FOLLOWING_SIBLINGS :
      prevIsOneStepDown = false;
      ai = new AxesWalker(lpi, Axis.FOLLOWINGSIBLING);
      break;
    case OpCodes.FROM_PRECEDING :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.PRECEDING);
      break;
    case OpCodes.FROM_PRECEDING_SIBLINGS :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.PRECEDINGSIBLING);
      break;
    case OpCodes.FROM_PARENT :
      prevIsOneStepDown = false;
      ai = new ReverseAxesWalker(lpi, Axis.PARENT);
      break;
    case OpCodes.FROM_SELF :
      ai = new AxesWalker(lpi, Axis.SELF);
      break;
    default :
      throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                 
    }

    if (simpleInit)
    {
      ai.initNodeTest(DTMFilter.SHOW_ALL);
    }
    else
    {
      int whatToShow = compiler.getWhatToShow(opPos);

      
      if ((0 == (whatToShow
                 & (DTMFilter.SHOW_ATTRIBUTE | DTMFilter.SHOW_NAMESPACE | DTMFilter.SHOW_ELEMENT
                    | DTMFilter.SHOW_PROCESSING_INSTRUCTION))) || (whatToShow == DTMFilter.SHOW_ALL))
        ai.initNodeTest(whatToShow);
      else
      {
        ai.initNodeTest(whatToShow, compiler.getStepNS(opPos),
                        compiler.getStepLocalName(opPos));
      }
    }

    return ai;
  }
  
  public static String getAnalysisString(int analysis)
  {
    StringBuffer buf = new StringBuffer();
    buf.append(""count: ""+getStepCount(analysis)+"" "");
    if((analysis & BIT_NODETEST_ANY) != 0)
    {
      buf.append(""NTANY|"");
    }
    if((analysis & BIT_PREDICATE) != 0)
    {
      buf.append(""PRED|"");
    }
    if((analysis & BIT_ANCESTOR) != 0)
    {
      buf.append(""ANC|"");
    }
    if((analysis & BIT_ANCESTOR_OR_SELF) != 0)
    {
      buf.append(""ANCOS|"");
    }
    if((analysis & BIT_ATTRIBUTE) != 0)
    {
      buf.append(""ATTR|"");
    }
    if((analysis & BIT_CHILD) != 0)
    {
      buf.append(""CH|"");
    }
    if((analysis & BIT_DESCENDANT) != 0)
    {
      buf.append(""DESC|"");
    }
    if((analysis & BIT_DESCENDANT_OR_SELF) != 0)
    {
      buf.append(""DESCOS|"");
    }
    if((analysis & BIT_FOLLOWING) != 0)
    {
      buf.append(""FOL|"");
    }
    if((analysis & BIT_FOLLOWING_SIBLING) != 0)
    {
      buf.append(""FOLS|"");
    }
    if((analysis & BIT_NAMESPACE) != 0)
    {
      buf.append(""NS|"");
    }
    if((analysis & BIT_PARENT) != 0)
    {
      buf.append(""P|"");
    }
    if((analysis & BIT_PRECEDING) != 0)
    {
      buf.append(""PREC|"");
    }
    if((analysis & BIT_PRECEDING_SIBLING) != 0)
    {
      buf.append(""PRECS|"");
    }
    if((analysis & BIT_SELF) != 0)
    {
      buf.append("".|"");
    }
    if((analysis & BIT_FILTER) != 0)
    {
      buf.append(""FLT|"");
    }
    if((analysis & BIT_ROOT) != 0)
    {
      buf.append(""R|"");
    }
    return buf.toString();
  }

  
  static final boolean DEBUG_PATTERN_CREATION = false;

  
  static final boolean DEBUG_WALKER_CREATION = false;

  
  static final boolean DEBUG_ITERATOR_CREATION = false;
  
  public static boolean hasPredicate(int analysis)
  {
    return (0 != (analysis & BIT_PREDICATE));
  }

  public static boolean isWild(int analysis)
  {
    return (0 != (analysis & BIT_NODETEST_ANY));
  }

  public static boolean walksAncestors(int analysis)
  {
    return isSet(analysis, BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF);
  }
  
  public static boolean walksAttributes(int analysis)
  {
    return (0 != (analysis & BIT_ATTRIBUTE));
  }

  public static boolean walksNamespaces(int analysis)
  {
    return (0 != (analysis & BIT_NAMESPACE));
  }  

  public static boolean walksChildren(int analysis)
  {
    return (0 != (analysis & BIT_CHILD));
  }

  public static boolean walksDescendants(int analysis)
  {
    return isSet(analysis, BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF);
  }

  public static boolean walksSubtree(int analysis)
  {
    return isSet(analysis, BIT_DESCENDANT | BIT_DESCENDANT_OR_SELF | BIT_CHILD);
  }
  
  public static boolean walksSubtreeOnlyMaybeAbsolute(int analysis)
  {
    return walksSubtree(analysis)
           && !walksExtraNodes(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           ;
  }
  
  public static boolean walksSubtreeOnly(int analysis)
  {
    return walksSubtreeOnlyMaybeAbsolute(analysis) 
           && !isAbsolute(analysis) 
           ;
  }

  public static boolean walksFilteredList(int analysis)
  {
    return isSet(analysis, BIT_FILTER);
  }
  
  public static boolean walksSubtreeOnlyFromRootOrContext(int analysis)
  {
    return walksSubtree(analysis)
           && !walksExtraNodes(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isSet(analysis, BIT_FILTER) 
           ;
  }

  public static boolean walksInDocOrder(int analysis)
  {
    return (walksSubtreeOnlyMaybeAbsolute(analysis)
           || walksExtraNodesOnly(analysis)
           || walksFollowingOnlyMaybeAbsolute(analysis)) 
           && !isSet(analysis, BIT_FILTER) 
           ;
  }
  
  public static boolean walksFollowingOnlyMaybeAbsolute(int analysis)
  {
    return isSet(analysis, BIT_SELF | BIT_FOLLOWING_SIBLING | BIT_FOLLOWING)
           && !walksSubtree(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           ;
  }
  
  public static boolean walksUp(int analysis)
  {
    return isSet(analysis, BIT_PARENT | BIT_ANCESTOR | BIT_ANCESTOR_OR_SELF);
  }
  
  public static boolean walksSideways(int analysis)
  {
    return isSet(analysis, BIT_FOLLOWING | BIT_FOLLOWING_SIBLING | 
                           BIT_PRECEDING | BIT_PRECEDING_SIBLING);
  }
  
  public static boolean walksExtraNodes(int analysis)
  {
    return isSet(analysis, BIT_NAMESPACE | BIT_ATTRIBUTE);
  }

  public static boolean walksExtraNodesOnly(int analysis)
  {
    return walksExtraNodes(analysis)
           && !isSet(analysis, BIT_SELF) 
           && !walksSubtree(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }

  public static boolean isAbsolute(int analysis)
  {
    return isSet(analysis, BIT_ROOT | BIT_FILTER);
  }
  
  public static boolean walksChildrenOnly(int analysis)
  {
    return walksChildren(analysis)
           && !isSet(analysis, BIT_SELF)
           && !walksExtraNodes(analysis)
           && !walksDescendants(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && (!isAbsolute(analysis) || isSet(analysis, BIT_ROOT))
           ;
  }
  
  public static boolean walksChildrenAndExtraAndSelfOnly(int analysis)
  {
    return walksChildren(analysis)
           && !walksDescendants(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && (!isAbsolute(analysis) || isSet(analysis, BIT_ROOT))
           ;
  }
  
  public static boolean walksDescendantsAndExtraAndSelfOnly(int analysis)
  {
    return !walksChildren(analysis)
           && walksDescendants(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && (!isAbsolute(analysis) || isSet(analysis, BIT_ROOT))
           ;
  }
  
  public static boolean walksSelfOnly(int analysis)
  {
    return isSet(analysis, BIT_SELF) 
           && !walksSubtree(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }

  
  public static boolean walksUpOnly(int analysis)
  {
    return !walksSubtree(analysis) 
           && walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }
  
  public static boolean walksDownOnly(int analysis)
  {
    return walksSubtree(analysis) 
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }

  public static boolean walksDownExtraOnly(int analysis)
  {
    return walksSubtree(analysis) &&  walksExtraNodes(analysis)
           && !walksUp(analysis) 
           && !walksSideways(analysis) 
           && !isAbsolute(analysis) 
           ;
  }
  
  public static boolean canSkipSubtrees(int analysis)
  {
    return isSet(analysis, BIT_CHILD) | walksSideways(analysis);
  }
  
  public static boolean canCrissCross(int analysis)
  {
    
    if(walksSelfOnly(analysis))
      return false;
    else if(walksDownOnly(analysis) && !canSkipSubtrees(analysis))
      return false;
    else if(walksChildrenAndExtraAndSelfOnly(analysis))
      return false;
    else if(walksDescendantsAndExtraAndSelfOnly(analysis))
      return false;
    else if(walksUpOnly(analysis))
      return false;
    else if(walksExtraNodesOnly(analysis))
      return false;
    else if(walksSubtree(analysis) 
           && (walksSideways(analysis) 
            || walksUp(analysis) 
            || canSkipSubtrees(analysis)))
      return true;
    else
      return false;
  }
  
  
  static public boolean isNaturalDocOrder(int analysis)
  {
    if(canCrissCross(analysis) || isSet(analysis, BIT_NAMESPACE) ||
       walksFilteredList(analysis))
      return false;
      
    if(walksInDocOrder(analysis))
      return true;
      
    return false;
  }
  
  
  private static boolean isNaturalDocOrder(
          Compiler compiler, int stepOpCodePos, int stepIndex, int analysis)
            throws javax.xml.transform.TransformerException
  {
    if(canCrissCross(analysis))
      return false;
      
    
    
    if(isSet(analysis, BIT_NAMESPACE))
      return false;
      
    
    
    
    
    
    
    if(isSet(analysis, BIT_FOLLOWING | BIT_FOLLOWING_SIBLING) && 
       isSet(analysis, BIT_PRECEDING | BIT_PRECEDING_SIBLING))
      return  false;
      
    
    
    
    
    
    int stepType;
    int ops[] = compiler.getOpMap();
    int stepCount = 0;
    boolean foundWildAttribute = false;
    
    
    
    
    int potentialDuplicateMakingStepCount = 0;
    
    while (OpCodes.ENDOP != (stepType = ops[stepOpCodePos]))
    {        
      stepCount++;
        
      switch (stepType)
      {
      case OpCodes.FROM_ATTRIBUTES :
      case OpCodes.MATCH_ATTRIBUTE :
        if(foundWildAttribute) 
          return false;
        
        
        
        
        String localName = compiler.getStepLocalName(stepOpCodePos);
        
        if(localName.equals(""*""))
        {
          foundWildAttribute = true;
        }
        break;
      case OpCodes.FROM_FOLLOWING :
      case OpCodes.FROM_FOLLOWING_SIBLINGS :
      case OpCodes.FROM_PRECEDING :
      case OpCodes.FROM_PRECEDING_SIBLINGS :
      case OpCodes.FROM_PARENT :
      case OpCodes.OP_VARIABLE :
      case OpCodes.OP_EXTFUNCTION :
      case OpCodes.OP_FUNCTION :
      case OpCodes.OP_GROUP :
      case OpCodes.FROM_NAMESPACE :
      case OpCodes.FROM_ANCESTORS :
      case OpCodes.FROM_ANCESTORS_OR_SELF :      
      case OpCodes.MATCH_ANY_ANCESTOR :
      case OpCodes.MATCH_IMMEDIATE_ANCESTOR :
      case OpCodes.FROM_DESCENDANTS_OR_SELF :
      case OpCodes.FROM_DESCENDANTS :
        if(potentialDuplicateMakingStepCount > 0)
            return false;
        potentialDuplicateMakingStepCount++;
      case OpCodes.FROM_ROOT :
      case OpCodes.FROM_CHILDREN :
      case OpCodes.FROM_SELF :
        if(foundWildAttribute)
          return false;
        break;
      default :
        throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NULL_ERROR_HANDLER, new Object[]{Integer.toString(stepType)})); 
                                  
      }

      int nextStepOpCodePos = compiler.getNextStepPos(stepOpCodePos);

      if (nextStepOpCodePos < 0)
        break;
              
      stepOpCodePos = nextStepOpCodePos;
    }

    return true;
  }
  
  public static boolean isOneStep(int analysis)
  {
    return (analysis & BITS_COUNT) == 0x00000001;
  }

  public static int getStepCount(int analysis)
  {
    return (analysis & BITS_COUNT);
  }

  
  public static final int BITS_COUNT = 0x000000FF;

  
  public static final int BITS_RESERVED = 0x00000F00;

  
  public static final int BIT_PREDICATE = (0x00001000);

  
  public static final int BIT_ANCESTOR = (0x00001000 << 1);

  
  public static final int BIT_ANCESTOR_OR_SELF = (0x00001000 << 2);

  
  public static final int BIT_ATTRIBUTE = (0x00001000 << 3);

  
  public static final int BIT_CHILD = (0x00001000 << 4);

  
  public static final int BIT_DESCENDANT = (0x00001000 << 5);

  
  public static final int BIT_DESCENDANT_OR_SELF = (0x00001000 << 6);

  
  public static final int BIT_FOLLOWING = (0x00001000 << 7);

  
  public static final int BIT_FOLLOWING_SIBLING = (0x00001000 << 8);

  
  public static final int BIT_NAMESPACE = (0x00001000 << 9);

  
  public static final int BIT_PARENT = (0x00001000 << 10);

  
  public static final int BIT_PRECEDING = (0x00001000 << 11);

  
  public static final int BIT_PRECEDING_SIBLING = (0x00001000 << 12);

  
  public static final int BIT_SELF = (0x00001000 << 13);

  
  public static final int BIT_FILTER = (0x00001000 << 14);

  
  public static final int BIT_ROOT = (0x00001000 << 15);

  
  public static final int BITMASK_TRAVERSES_OUTSIDE_SUBTREE = (BIT_NAMESPACE  
                                                                | BIT_PRECEDING_SIBLING
                                                                | BIT_PRECEDING
                                                                | BIT_FOLLOWING_SIBLING
                                                                | BIT_FOLLOWING
                                                                | BIT_PARENT  
                                                                | BIT_ANCESTOR_OR_SELF
                                                                | BIT_ANCESTOR
                                                                | BIT_FILTER
                                                                | BIT_ROOT);

  
  public static final int BIT_BACKWARDS_SELF = (0x00001000 << 16);

  
  public static final int BIT_NODETEST_ANY = (0x00001000 << 18);

  

  
  public static final int BIT_MATCH_PATTERN = (0x00001000 << 19);
}
"
org.apache.xpath.axes.SubContextList,2,1,0,6,2,1,6,1,2,2.0,2,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xpath.axes;

import org.apache.xpath.XPathContext;


 

public interface SubContextList
{

  
  public int getLastPos(XPathContext xctxt);

  
  public int getProximityPosition(XPathContext xctxt);
}
"
org.apache.xalan.xsltc.compiler.SyntaxTreeNode,52,1,5,111,110,942,87,36,10,0.911764706,942,1.0,6,0.0,0.16399287,0,0,16.88461538,6,1.75,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import java.util.Hashtable;
import java.net.URL;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;


public abstract class SyntaxTreeNode implements Constants {

    
    private Parser _parser;

    
    protected SyntaxTreeNode _parent;          
    private Stylesheet       _stylesheet;      
    private Template         _template;        
    private final Vector _contents = new Vector(2); 

    
    protected QName _qname;                    
    private int _line;                         
    protected Attributes _attributes = null;   
    private   Hashtable _prefixMapping = null; 

    
    protected static final SyntaxTreeNode Dummy = new AbsolutePathPattern(null);

    
    protected static final int IndentIncrement = 4;
    private static final char[] _spaces = 
	""                                                       "".toCharArray();

    
    public SyntaxTreeNode() {
	_line = 0;
	_qname = null;
    }

    
    public SyntaxTreeNode(int line) {
	_line = line;
	_qname = null;
    }

    
    public SyntaxTreeNode(String uri, String prefix, String local) {
	_line = 0;
	setQName(uri, prefix, local);
    }

    
    protected final void setLineNumber(int line) {
	_line = line;
    }

    
    public final int getLineNumber() {
	return _line;
    }

    
    protected void setQName(QName qname) {
	_qname = qname;
    }

    
    protected void setQName(String uri, String prefix, String localname) {
	_qname = new QName(uri, prefix, localname);
    }

    
    protected QName getQName() {
	return(_qname);
    }

    
    protected void setAttributes(Attributes attributes) {
	_attributes = attributes;
    }

    
    protected String getAttribute(String qname) {
	if (_attributes == null) {
	    return EMPTYSTRING;
	}
	final String value = _attributes.getValue(qname);
	return (value == null || value.equals(EMPTYSTRING)) ? 
	    EMPTYSTRING : value;
    }

    protected boolean hasAttribute(String qname) {
	return (_attributes != null && _attributes.getValue(qname) != null);
    }

    
    protected Attributes getAttributes() {
	return(_attributes);
    }

    
    protected void setPrefixMapping(Hashtable mapping) {
	_prefixMapping = mapping;
    }

    
    protected Hashtable getPrefixMapping() {
	return _prefixMapping;
    }

    
    protected void addPrefixMapping(String prefix, String uri) {
	if (_prefixMapping == null)
	    _prefixMapping = new Hashtable();
	_prefixMapping.put(prefix, uri);
    }

    
    protected String lookupNamespace(String prefix) {
	
	String uri = null;

	
	if (_prefixMapping != null)
	    uri = (String)_prefixMapping.get(prefix);
	
	if ((uri == null) && (_parent != null)) {
	    uri = _parent.lookupNamespace(prefix);
	    if ((prefix == Constants.EMPTYSTRING) && (uri == null))
		uri = Constants.EMPTYSTRING;
	}
	
	return(uri);
    }

    
    protected String lookupPrefix(String uri) {
	
	String prefix = null;

	
	if ((_prefixMapping != null) &&
	    (_prefixMapping.contains(uri))) {
	    Enumeration prefixes = _prefixMapping.keys();
	    while (prefixes.hasMoreElements()) {
		prefix = (String)prefixes.nextElement();
		String mapsTo = (String)_prefixMapping.get(prefix);
		if (mapsTo.equals(uri)) return(prefix);
	    }
	}
	
	else if (_parent != null) {
	    prefix = _parent.lookupPrefix(uri);
	    if ((uri == Constants.EMPTYSTRING) && (prefix == null))
		prefix = Constants.EMPTYSTRING;
	}
	return(prefix);
    }

    
    protected void setParser(Parser parser) {
	_parser = parser;
    }

    
    public final Parser getParser() {
	return _parser;
    }

    
    protected void setParent(SyntaxTreeNode parent) {
	if (_parent == null)
	    _parent = parent;
    }

    
    protected final SyntaxTreeNode getParent() {
	return _parent;
    }

    
    protected final boolean isDummy() {
        return this == Dummy;
    }

    
    protected int getImportPrecedence() {
	Stylesheet stylesheet = getStylesheet();
	if (stylesheet == null) return Integer.MIN_VALUE;
	return stylesheet.getImportPrecedence();
    }

    
    public Stylesheet getStylesheet() {
	if (_stylesheet == null) {
	    SyntaxTreeNode parent = this;
	    while (parent != null) {
		if (parent instanceof Stylesheet)
		    return((Stylesheet)parent);
		parent = parent.getParent();
	    }
	    _stylesheet = (Stylesheet)parent;
	}
	return(_stylesheet);
    }

    
    protected Template getTemplate() {
	if (_template == null) {
	    SyntaxTreeNode parent = this;
	    while ((parent != null) && (!(parent instanceof Template)))
		parent = parent.getParent();
	    _template = (Template)parent;
	}
	return(_template);
    }

    
    protected final XSLTC getXSLTC() {
	return _parser.getXSLTC();
    }

    
    protected final SymbolTable getSymbolTable() {
	return (_parser == null) ? null : _parser.getSymbolTable();
    }

    
    public void parseContents(Parser parser) {
	parseChildren(parser);
    }

    
    protected final void parseChildren(Parser parser) {

	Vector locals = null;	
	
	final int count = _contents.size();
	for (int i=0; i<count; i++) {
	    SyntaxTreeNode child = (SyntaxTreeNode)_contents.elementAt(i);
	    parser.getSymbolTable().setCurrentNode(child);
	    child.parseContents(parser);
	    
	    final QName varOrParamName = updateScope(parser, child);
	    if (varOrParamName != null) {
		if (locals == null) {
		    locals = new Vector(2);
		}
		locals.addElement(varOrParamName);
	    }
	}

	parser.getSymbolTable().setCurrentNode(this);

	
	if (locals != null) {
	    final int nLocals = locals.size();
	    for (int i = 0; i < nLocals; i++) {
		parser.removeVariable((QName)locals.elementAt(i));
	    }
	}
    }
   
    
    protected QName updateScope(Parser parser, SyntaxTreeNode node) {
	if (node instanceof Variable) {
	    final Variable var = (Variable)node;
	    parser.addVariable(var);
	    return var.getName();
	}
	else if (node instanceof Param) {
	    final Param param = (Param)node;
	    parser.addParameter(param);
	    return param.getName();
	}
	else {
	    return null;
	}
    }

    
    public abstract Type typeCheck(SymbolTable stable) throws TypeCheckError;

    
    protected Type typeCheckContents(SymbolTable stable) throws TypeCheckError {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
	    item.typeCheck(stable);
	}
	return Type.Void;
    }

    
    public abstract void translate(ClassGenerator classGen,
				   MethodGenerator methodGen);

    
    protected void translateContents(ClassGenerator classGen,
				     MethodGenerator methodGen) {
	
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    final SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
	    item.translate(classGen, methodGen);
	}

	
	
	
	
	
	for (int i = 0; i < n; i++) {
	    if( _contents.elementAt(i) instanceof VariableBase) {
		final VariableBase var = (VariableBase)_contents.elementAt(i);
		var.unmapRegister(methodGen);
	    }
	}
    }

    
    protected void compileResultTree(ClassGenerator classGen,
				     MethodGenerator methodGen) 
    {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final Stylesheet stylesheet = classGen.getStylesheet();

	
	il.append(methodGen.loadHandler());

	final String DOM_CLASS = classGen.getDOMClass();

	
	int index = cpg.addMethodref(DOM_IMPL, ""<init>"", ""(I)V"");
	il.append(new NEW(cpg.addClass(DOM_IMPL)));
	il.append(DUP);
	il.append(DUP);
	il.append(new PUSH(cpg, 64));
	il.append(new INVOKESPECIAL(index));

	
	index = cpg.addMethodref(DOM_IMPL,
				 ""getOutputDomBuilder"",
				 ""()"" + TRANSLET_OUTPUT_SIG);

	il.append(new INVOKEVIRTUAL(index));
	il.append(DUP);
	il.append(methodGen.storeHandler());

	
	il.append(methodGen.startDocument());

	
	translateContents(classGen, methodGen);

	
	il.append(methodGen.loadHandler());
	il.append(methodGen.endDocument());

	
	if (!DOM_CLASS.equals(DOM_IMPL_CLASS)) {
	    
	    index = cpg.addMethodref(DOM_ADAPTER_CLASS,
				     ""<init>"",
				     ""(""+DOM_IMPL_SIG+
				     ""[""+STRING_SIG+
				     ""[""+STRING_SIG+"")V"");
	    il.append(new NEW(cpg.addClass(DOM_ADAPTER_CLASS)));
	    il.append(new DUP_X1());
	    il.append(SWAP);

	    
	    if (!stylesheet.callsNodeset()) {
		il.append(new ICONST(0));
		il.append(new ANEWARRAY(cpg.addClass(STRING)));
		il.append(DUP);
		il.append(new INVOKESPECIAL(index));
	    }
	    else {
		
		il.append(ALOAD_0);
		il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					   NAMES_INDEX,
					   NAMES_INDEX_SIG))); 
		il.append(ALOAD_0);
		il.append(new GETFIELD(cpg.addFieldref(TRANSLET_CLASS,
					   NAMESPACE_INDEX,
					   NAMESPACE_INDEX_SIG)));

		
		il.append(new INVOKESPECIAL(index));

		
		il.append(DUP);
		il.append(methodGen.loadDOM());
		il.append(new CHECKCAST(cpg.addClass(classGen.getDOMClass())));
		il.append(SWAP);
		index = cpg.addMethodref(MULTI_DOM_CLASS,
					 ""addDOMAdapter"",
					 ""("" + DOM_ADAPTER_SIG + "")I"");
		il.append(new INVOKEVIRTUAL(index));
		il.append(POP);		
	    }
	}

	
	il.append(SWAP);
	il.append(methodGen.storeHandler());
    }

    
    protected boolean contextDependent() {
	return true;
    }

    
    protected boolean dependentContents() {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    final SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
	    if (item.contextDependent()) {
		return true;
	    }
	}
	return false;
    }

    
    protected final void addElement(SyntaxTreeNode element) {
	_contents.addElement(element);
	element.setParent(this);
    }

    
    protected final void setFirstElement(SyntaxTreeNode element) {
	_contents.insertElementAt(element,0);
	element.setParent(this);
    }

    
    protected final void removeElement(SyntaxTreeNode element) {
	_contents.remove(element);
	element.setParent(null);
    }

    
    protected final Vector getContents() {
	return _contents;
    }

    
    protected final boolean hasContents() {
	return elementCount() > 0;
    }

    
    protected final int elementCount() {
	return _contents.size();
    }

    
    protected final Enumeration elements() {
	return _contents.elements();
    }

    
    protected final Object elementAt(int pos) {
	return _contents.elementAt(pos);
    }

    
    protected final SyntaxTreeNode lastChild() {
	if (_contents.size() == 0) return null;
	return (SyntaxTreeNode)_contents.lastElement();
    }

    
    public void display(int indent) {
	displayContents(indent);
    }

    
    protected void displayContents(int indent) {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    SyntaxTreeNode item = (SyntaxTreeNode)_contents.elementAt(i);
	    item.display(indent);
	}
    }

    
    protected final void indent(int indent) {
	System.out.print(new String(_spaces, 0, indent));
    }

    
    protected void reportError(SyntaxTreeNode element, Parser parser,
			       int errorCode, String message) {
	final ErrorMsg error = new ErrorMsg(errorCode, message, element);
        parser.reportError(Constants.ERROR, error);
    }

    
    protected  void reportWarning(SyntaxTreeNode element, Parser parser,
				  int errorCode, String message) {
	final ErrorMsg error = new ErrorMsg(errorCode, message, element);
        parser.reportError(Constants.WARNING, error);
    }

}
"
org.apache.xalan.xsltc.compiler.util.RealType,27,3,0,45,56,351,14,36,26,2.0,504,0.0,0,0.573770492,0.202020202,1,3,17.66666667,8,1.7778,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.Constants;

public final class RealType extends NumberType {
    protected RealType() {}

    public String toString() {
	return ""real"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""D"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.DOUBLE;
    }

    
    public int distanceTo(Type type) {
	if (type == this) {
	    return 0;
	}
	else if (type == Type.Int) {
	    return 1;
	}
	else {
	    return Integer.MAX_VALUE;
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else if (type == Type.Int) {
	    translateTo(classGen, methodGen, (IntType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKESTATIC(cpg.addMethodref(BASIS_LIBRARY_CLASS,
						    ""realToString"",
						    ""(D)"" + STRING_SIG)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	FlowList falsel = translateToDesynthesized(classGen, methodGen, type);
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsel.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    IntType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKESTATIC(cpg.addMethodref(BASIS_LIBRARY_CLASS,
						    ""realToInt"",""(D)I"")));
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	LocalVariableGen local;
	final FlowList flowlist = new FlowList();
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(DUP2);
	local = methodGen.addLocalVariable(""real_to_boolean_tmp"", 
					   org.apache.bcel.generic.Type.DOUBLE,
					   il.getEnd(), null);
	il.append(new DSTORE(local.getIndex()));

	
	il.append(DCONST_0);
	il.append(DCMPG);
	flowlist.add(il.append(new IFEQ(null)));

	
	
	il.append(new DLOAD(local.getIndex()));
	il.append(new DLOAD(local.getIndex()));
	il.append(DCMPG);
	flowlist.add(il.append(new IFNE(null)));	
	return flowlist;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new NEW(cpg.addClass(DOUBLE_CLASS)));
	il.append(DUP_X2);
	il.append(DUP_X2);
	il.append(POP);
	il.append(new INVOKESPECIAL(cpg.addMethodref(DOUBLE_CLASS,
						     ""<init>"", ""(D)V"")));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    final Class clazz) {
	final InstructionList il = methodGen.getInstructionList();
	if (clazz == Character.TYPE) {
	    il.append(D2I);
	    il.append(I2C);
	}
	else if (clazz == Byte.TYPE) {
	    il.append(D2I);
	    il.append(I2B);
	}
	else if (clazz == Short.TYPE) {
	    il.append(D2I);
	    il.append(I2S);
	}
	else if (clazz == Integer.TYPE) {
	    il.append(D2I);
	}
	else if (clazz == Long.TYPE) {
	    il.append(D2L);
	}
	else if (clazz == Float.TYPE) {
	    il.append(D2F);
	}
	else if (clazz == Double.TYPE) {
	    il.append(NOP);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen, 
			      Class clazz) {
	InstructionList il = methodGen.getInstructionList();

	if (clazz == Character.TYPE || clazz == Byte.TYPE ||
	    clazz == Short.TYPE || clazz == Integer.TYPE) {
	    il.append(I2D);
	}
	else if (clazz == Long.TYPE) {
	    il.append(L2D);
	}
	else if (clazz == Float.TYPE) {
	    il.append(F2D);
	}
	else if (clazz == Double.TYPE) {
	    il.append(NOP);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new CHECKCAST(cpg.addClass(DOUBLE_CLASS)));
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(DOUBLE_CLASS,
						     DOUBLE_VALUE, 
						     DOUBLE_VALUE_SIG)));
    }

    public Instruction ADD() {
	return InstructionConstants.DADD;
    }

    public Instruction SUB() {
	return InstructionConstants.DSUB;
    }

    public Instruction MUL() {
	return InstructionConstants.DMUL;
    }

    public Instruction DIV() {
	return InstructionConstants.DDIV;
    }

    public Instruction REM() {
	return InstructionConstants.DREM;
    }

    public Instruction NEG() {
	return InstructionConstants.DNEG;
    }

    public Instruction LOAD(int slot) {
	return new DLOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new DSTORE(slot);
    }

    public Instruction POP() {
	return POP2;
    }
    
    public Instruction CMP(boolean less) {
	return less ? InstructionConstants.DCMPG : InstructionConstants.DCMPL;
    }

    public Instruction DUP() {
	return DUP2;
    }
}

"
org.apache.xpath.operations.Or,3,3,0,6,7,3,1,5,3,2.0,42,0.0,0,0.953488372,0.833333333,1,6,13.0,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.Expression;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;

import org.w3c.dom.Node;


public class Or extends Operation
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XObject expr1 = m_left.execute(xctxt);

    if (!expr1.bool())
    {
      XObject expr2 = m_right.execute(xctxt);

      return expr2.bool() ? XBoolean.S_TRUE : XBoolean.S_FALSE;
    }
    else
      return XBoolean.S_TRUE;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return (m_left.bool(xctxt) || m_right.bool(xctxt));
  }

}
"
org.apache.xalan.xsltc.TransletException,3,4,0,27,5,3,27,0,3,2.0,16,0.0,0,1.0,0.555555556,0,0,4.333333333,0,0.0,0,"

package org.apache.xalan.xsltc;

import org.xml.sax.SAXException;

public final class TransletException extends SAXException {

    public TransletException() {
	super(""Translet error"");
    }
    
    public TransletException(Exception e) {
	super(e.toString());
    }
    
    public TransletException(String message) {
	super(message);
    }
}
"
org.apache.xalan.xsltc.runtime.Hashtable,15,1,0,22,26,1,21,2,14,0.553571429,483,1.0,1,0.0,0.383333333,0,0,30.93333333,6,2.4667,0,"

package org.apache.xalan.xsltc.runtime;

import java.io.*;
import java.util.Enumeration;




class HashtableEntry {
    int hash;
    Object key;
    Object value;
    HashtableEntry next;

    protected Object clone() {
	HashtableEntry entry = new HashtableEntry();
	entry.hash = hash;
	entry.key = key;
	entry.value = value;
	entry.next = (next != null) ? (HashtableEntry)next.clone() : null;
	return entry;
    }
}


public class Hashtable {

    private transient HashtableEntry table[]; 
    private transient int count;              
    private int threshold;                    
    private float loadFactor;                 

    
    public Hashtable(int initialCapacity, float loadFactor) {
	if (initialCapacity <= 0) initialCapacity = 11;
	if (loadFactor <= 0.0) loadFactor = 0.75f;
	this.loadFactor = loadFactor;
	table = new HashtableEntry[initialCapacity];
	threshold = (int)(initialCapacity * loadFactor);
    }

    
    public Hashtable(int initialCapacity) {
	this(initialCapacity, 0.75f);
    }

    
    public Hashtable() {
	this(101, 0.75f);
    }

    
    public int size() {
	return count;
    }

    
    public boolean isEmpty() {
	return count == 0;
    }

    
    public Enumeration keys() {
	return new HashtableEnumerator(table, true);
    }

    
    public Enumeration elements() {
	return new HashtableEnumerator(table, false);
    }

    
    public boolean contains(Object value) {

	if (value == null) throw new NullPointerException();

	int i;
	HashtableEntry e;
	HashtableEntry tab[] = table;

	for (i = tab.length ; i-- > 0 ;) {
	    for (e = tab[i] ; e != null ; e = e.next) {
		if (e.value.equals(value)) {
		    return true;
		}
	    }
	}
	return false;
    }

    
    public boolean containsKey(Object key) {
	HashtableEntry e;
	HashtableEntry tab[] = table;
	int hash = key.hashCode();
	int index = (hash & 0x7FFFFFFF) % tab.length;

	for (e = tab[index] ; e != null ; e = e.next)
	    if ((e.hash == hash) && e.key.equals(key))
		return true;

	return false;
    }

    
    public Object get(Object key) {
	HashtableEntry e;
	HashtableEntry tab[] = table;
	int hash = key.hashCode();
	int index = (hash & 0x7FFFFFFF) % tab.length;

	for (e = tab[index] ; e != null ; e = e.next) 
	    if ((e.hash == hash) && e.key.equals(key)) 
		return e.value;

	return null;
    }

    
    protected void rehash() {
	HashtableEntry e, old;
	int i, index;
	int oldCapacity = table.length;
	HashtableEntry oldTable[] = table;

	int newCapacity = oldCapacity * 2 + 1;
	HashtableEntry newTable[] = new HashtableEntry[newCapacity];

	threshold = (int)(newCapacity * loadFactor);
	table = newTable;

	for (i = oldCapacity ; i-- > 0 ;) {
	    for (old = oldTable[i] ; old != null ; ) {
		e = old;
		old = old.next;
		index = (e.hash & 0x7FFFFFFF) % newCapacity;
		e.next = newTable[index];
		newTable[index] = e;
	    }
	}
    }

    
    public Object put(Object key, Object value) {
	
	if (value == null) throw new NullPointerException();

	
	HashtableEntry e;
	HashtableEntry tab[] = table;
	int hash = key.hashCode();
	int index = (hash & 0x7FFFFFFF) % tab.length;

	for (e = tab[index] ; e != null ; e = e.next) {
	    if ((e.hash == hash) && e.key.equals(key)) {
		Object old = e.value;
		e.value = value;
		return old;
	    }
	}

	
	if (count >= threshold) {
	    rehash();
	    return put(key, value);
	} 

	
	e = new HashtableEntry();
	e.hash = hash;
	e.key = key;
	e.value = value;
	e.next = tab[index];
	tab[index] = e;
	count++;
	return null;
    }

    
    public Object remove(Object key) {
	HashtableEntry e, prev;
	HashtableEntry tab[] = table;
	int hash = key.hashCode();
	int index = (hash & 0x7FFFFFFF) % tab.length;
	for (e = tab[index], prev = null ; e != null ; prev = e, e = e.next) {
	    if ((e.hash == hash) && e.key.equals(key)) {
		if (prev != null)
		    prev.next = e.next;
		else
		    tab[index] = e.next;
		count--;
		return e.value;
	    }
	}
	return null;
    }

    
    public void clear() {
	HashtableEntry tab[] = table;
	for (int index = tab.length; --index >= 0; )
	    tab[index] = null;
	count = 0;
    }

    
    public String toString() {
	int i;
	int max = size() - 1;
	StringBuffer buf = new StringBuffer();
	Enumeration k = keys();
	Enumeration e = elements();
	buf.append(""{"");

	for (i = 0; i <= max; i++) {
	    String s1 = k.nextElement().toString();
	    String s2 = e.nextElement().toString();
	    buf.append(s1 + ""="" + s2);
	    if (i < max) buf.append("", "");
	}
	buf.append(""}"");
	return buf.toString();
    }

    
    class HashtableEnumerator implements Enumeration {
	boolean keys;
	int index;
	HashtableEntry table[];
	HashtableEntry entry;

	HashtableEnumerator(HashtableEntry table[], boolean keys) {
	    this.table = table;
	    this.keys = keys;
	    this.index = table.length;
	}
	
	public boolean hasMoreElements() {
	    if (entry != null) {
		return true;
	    }
	    while (index-- > 0) {
		if ((entry = table[index]) != null) {
		    return true;
		}
	    }
	    return false;
	}

	public Object nextElement() {
	    if (entry == null) {
		while ((index-- > 0) && ((entry = table[index]) == null));
	    }
	    if (entry != null) {
		HashtableEntry e = entry;
		entry = e.next;
		return keys ? e.key : e.value;
	    }
	    return null;
	}
    }

}
"
org.apache.xpath.compiler.XPathParser,58,1,0,13,88,0,4,10,5,0.679425837,3479,0.454545455,2,0.0,0.163793103,0,0,58.79310345,6,1.4828,1,"
package org.apache.xpath.compiler;

import java.util.Vector;
import java.util.Hashtable;

import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.XPathProcessorException;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XNumber;
import org.apache.xalan.res.XSLMessages;

import javax.xml.transform.TransformerException;
import org.xml.sax.Locator;
import org.xml.sax.helpers.LocatorImpl;

import javax.xml.transform.TransformerConfigurationException;
import javax.xml.transform.TransformerException;
import javax.xml.transform.ErrorListener;


public class XPathParser
{
	
	
	
	static public final String CONTINUE_AFTER_FATAL_ERROR=""CONTINUE_AFTER_FATAL_ERROR"";

  
  private OpMap m_ops;

  
  transient String m_token;

  
  transient char m_tokenChar = 0;

  
  int m_queueMark = 0;

  
  protected final static int FILTER_MATCH_FAILED     = 0;
  protected final static int FILTER_MATCH_PRIMARY    = 1;
  protected final static int FILTER_MATCH_PREDICATES = 2;

  
  public XPathParser(ErrorListener errorListener, javax.xml.transform.SourceLocator sourceLocator)
  {
    m_errorListener = errorListener;
    m_sourceLocator = sourceLocator;
  }

  
  PrefixResolver m_namespaceContext;

  
  public void initXPath(
          Compiler compiler, String expression, PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    m_ops = compiler;
    m_namespaceContext = namespaceContext;

    Lexer lexer = new Lexer(compiler, namespaceContext, this);

    lexer.tokenize(expression);

    m_ops.m_opMap[0] = OpCodes.OP_XPATH;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] = 2;
    
    
	
	
	
	
	
	
	
	
	try {

      nextToken();
      Expr();

      if (null != m_token)
      {
        String extraTokens = """";

        while (null != m_token)
        {
          extraTokens += ""'"" + m_token + ""'"";

          nextToken();

          if (null != m_token)
            extraTokens += "", "";
        }

        error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
              new Object[]{ extraTokens });  
      }

    } 
    catch (org.apache.xpath.XPathProcessorException e)
    {
	  if(CONTINUE_AFTER_FATAL_ERROR.equals(e.getMessage()))
	  {
		
		
		
		initXPath(compiler, ""/.."",  namespaceContext);
	  }
	  else
		throw e;
    }

    compiler.shrink();
  }

  
  public void initMatchPattern(
          Compiler compiler, String expression, PrefixResolver namespaceContext)
            throws javax.xml.transform.TransformerException
  {

    m_ops = compiler;
    m_namespaceContext = namespaceContext;

    Lexer lexer = new Lexer(compiler, namespaceContext, this);

    lexer.tokenize(expression);

    m_ops.m_opMap[0] = OpCodes.OP_MATCHPATTERN;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] = 2;

    nextToken();
    Pattern();

    if (null != m_token)
    {
      String extraTokens = """";

      while (null != m_token)
      {
        extraTokens += ""'"" + m_token + ""'"";

        nextToken();

        if (null != m_token)
          extraTokens += "", "";
      }

      error(XPATHErrorResources.ER_EXTRA_ILLEGAL_TOKENS,
            new Object[]{ extraTokens });  
    }

    
    m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = OpCodes.ENDOP;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

    m_ops.shrink();
  }

  
  private ErrorListener m_errorListener;
  
  
  javax.xml.transform.SourceLocator m_sourceLocator;

  
  public void setErrorHandler(ErrorListener handler)
  {
    m_errorListener = handler;
  }

  
  public ErrorListener getErrorListener()
  {
    return m_errorListener;
  }

  
  final boolean tokenIs(String s)
  {
    return (m_token != null) ? (m_token.equals(s)) : (s == null);
  }

  
  final boolean tokenIs(char c)
  {
    return (m_token != null) ? (m_tokenChar == c) : false;
  }

  
  final boolean lookahead(char c, int n)
  {

    int pos = (m_queueMark + n);
    boolean b;

    if ((pos <= m_ops.m_tokenQueueSize) && (pos > 0)
            && (m_ops.m_tokenQueueSize != 0))
    {
      String tok = ((String) m_ops.m_tokenQueue[pos - 1]);

      b = (tok.length() == 1) ? (tok.charAt(0) == c) : false;
    }
    else
    {
      b = false;
    }

    return b;
  }

  
  private final boolean lookbehind(char c, int n)
  {

    boolean isToken;
    int lookBehindPos = m_queueMark - (n + 1);

    if (lookBehindPos >= 0)
    {
      String lookbehind = (String) m_ops.m_tokenQueue[lookBehindPos];

      if (lookbehind.length() == 1)
      {
        char c0 = (lookbehind == null) ? '|' : lookbehind.charAt(0);

        isToken = (c0 == '|') ? false : (c0 == c);
      }
      else
      {
        isToken = false;
      }
    }
    else
    {
      isToken = false;
    }

    return isToken;
  }

  
  private final boolean lookbehindHasToken(int n)
  {

    boolean hasToken;

    if ((m_queueMark - n) > 0)
    {
      String lookbehind = (String) m_ops.m_tokenQueue[m_queueMark - (n - 1)];
      char c0 = (lookbehind == null) ? '|' : lookbehind.charAt(0);

      hasToken = (c0 == '|') ? false : true;
    }
    else
    {
      hasToken = false;
    }

    return hasToken;
  }

  
  private final boolean lookahead(String s, int n)
  {

    boolean isToken;

    if ((m_queueMark + n) <= m_ops.m_tokenQueueSize)
    {
      String lookahead = (String) m_ops.m_tokenQueue[m_queueMark + (n - 1)];

      isToken = (lookahead != null) ? lookahead.equals(s) : (s == null);
    }
    else
    {
      isToken = (null == s);
    }

    return isToken;
  }

  
  private final void nextToken()
  {

    if (m_queueMark < m_ops.m_tokenQueueSize)
    {
      m_token = (String) m_ops.m_tokenQueue[m_queueMark++];
      m_tokenChar = m_token.charAt(0);
    }
    else
    {
      m_token = null;
      m_tokenChar = 0;
    }
  }

  
  private final String getTokenRelative(int i)
  {

    String tok;
    int relative = m_queueMark + i;

    if ((relative > 0) && (relative < m_ops.m_tokenQueueSize))
    {
      tok = (String) m_ops.m_tokenQueue[relative];
    }
    else
    {
      tok = null;
    }

    return tok;
  }

  
  private final void prevToken()
  {

    if (m_queueMark > 0)
    {
      m_queueMark--;

      m_token = (String) m_ops.m_tokenQueue[m_queueMark];
      m_tokenChar = m_token.charAt(0);
    }
    else
    {
      m_token = null;
      m_tokenChar = 0;
    }
  }

  
  private final void consumeExpected(String expected)
          throws javax.xml.transform.TransformerException
  {

    if (tokenIs(expected))
    {
      nextToken();
    }
    else
    {
      error(XPATHErrorResources.ER_EXPECTED_BUT_FOUND, new Object[]{ expected,
                                                                     m_token });  

	  
	  
	  
		throw new XPathProcessorException(CONTINUE_AFTER_FATAL_ERROR);
	}
  }

  
  private final void consumeExpected(char expected)
          throws javax.xml.transform.TransformerException
  {

    if (tokenIs(expected))
    {
      nextToken();
    }
    else
    {
      error(XPATHErrorResources.ER_EXPECTED_BUT_FOUND,
            new Object[]{ String.valueOf(expected),
                          m_token });  

	  
	  
	  
		throw new XPathProcessorException(CONTINUE_AFTER_FATAL_ERROR);
    }
  }

  
  void warn(int msg, Object[] args) throws TransformerException
  {

    String fmsg = XSLMessages.createXPATHWarning(msg, args);
    ErrorListener ehandler = this.getErrorListener();

    if (null != ehandler)
    {
      
      ehandler.warning(new TransformerException(fmsg, m_sourceLocator));
    }
    else
    {
      
      System.err.println(fmsg);
    }
  }

  
  private void assertion(boolean b, String msg)
  {

    if (!b)
    {
      String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ msg });

      throw new RuntimeException(fMsg);
    }
  }

  
  void error(int msg, Object[] args) throws TransformerException
  {

    String fmsg = XSLMessages.createXPATHMessage(msg, args);
    ErrorListener ehandler = this.getErrorListener();

    TransformerException te = new TransformerException(fmsg, m_sourceLocator);
    if (null != ehandler)
    {
      
      ehandler.fatalError(te);
    }
    else
    {
      
      throw te;
    }
  }

  
  protected String dumpRemainingTokenQueue()
  {

    int q = m_queueMark;
    String returnMsg;

    if (q < m_ops.m_tokenQueueSize)
    {
      String msg = ""
 Remaining tokens: ("";

      while (q < m_ops.m_tokenQueueSize)
      {
        String t = (String) m_ops.m_tokenQueue[q++];

        msg += ("" '"" + t + ""'"");
      }

      returnMsg = msg + "")"";
    }
    else
    {
      returnMsg = """";
    }

    return returnMsg;
  }

  
  final int getFunctionToken(String key)
  {

    int tok;

    try
    {
      tok = ((Integer) (Keywords.m_functions.get(key))).intValue();
    }
    catch (NullPointerException npe)
    {
      tok = -1;
    }
    catch (ClassCastException cce)
    {
      tok = -1;
    }

    return tok;
  }

  
  void insertOp(int pos, int length, int op)
  {

    int totalLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    for (int i = totalLen - 1; i >= pos; i--)
    {
      m_ops.m_opMap[i + length] = m_ops.m_opMap[i];
    }

    m_ops.m_opMap[pos] = op;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] = totalLen + length;
  }

  
  void appendOp(int length, int op)
  {

    int totalLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    m_ops.m_opMap[totalLen] = op;
    m_ops.m_opMap[totalLen + OpMap.MAPINDEX_LENGTH] = length;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] = totalLen + length;
  }

  

  
  protected void Expr() throws javax.xml.transform.TransformerException
  {
    OrExpr();
  }

  
  protected void OrExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    AndExpr();

    if ((null != m_token) && tokenIs(""or""))
    {
      nextToken();
      insertOp(opPos, 2, OpCodes.OP_OR);
      OrExpr();

      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
    }
  }

  
  protected void AndExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    EqualityExpr(-1);

    if ((null != m_token) && tokenIs(""and""))
    {
      nextToken();
      insertOp(opPos, 2, OpCodes.OP_AND);
      AndExpr();

      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
    }
  }

  
  protected int EqualityExpr(int addPos) throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    if (-1 == addPos)
      addPos = opPos;

    RelationalExpr(-1);

    if (null != m_token)
    {
      if (tokenIs('!') && lookahead('=', 1))
      {
        nextToken();
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_NOTEQUALS);

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = EqualityExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
      else if (tokenIs('='))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_EQUALS);

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = EqualityExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
    }

    return addPos;
  }

  
  protected int RelationalExpr(int addPos) throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    if (-1 == addPos)
      addPos = opPos;

    AdditiveExpr(-1);

    if (null != m_token)
    {
      if (tokenIs('<'))
      {
        nextToken();

        if (tokenIs('='))
        {
          nextToken();
          insertOp(addPos, 2, OpCodes.OP_LTE);
        }
        else
        {
          insertOp(addPos, 2, OpCodes.OP_LT);
        }

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = RelationalExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
      else if (tokenIs('>'))
      {
        nextToken();

        if (tokenIs('='))
        {
          nextToken();
          insertOp(addPos, 2, OpCodes.OP_GTE);
        }
        else
        {
          insertOp(addPos, 2, OpCodes.OP_GT);
        }

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = RelationalExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
    }

    return addPos;
  }

  
  protected int AdditiveExpr(int addPos) throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    if (-1 == addPos)
      addPos = opPos;

    MultiplicativeExpr(-1);

    if (null != m_token)
    {
      if (tokenIs('+'))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_PLUS);

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = AdditiveExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
      else if (tokenIs('-'))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_MINUS);

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = AdditiveExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
    }

    return addPos;
  }

  
  protected int MultiplicativeExpr(int addPos) throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    if (-1 == addPos)
      addPos = opPos;

    UnaryExpr();

    if (null != m_token)
    {
      if (tokenIs('*'))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_MULT);

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = MultiplicativeExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
      else if (tokenIs(""div""))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_DIV);

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = MultiplicativeExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
      else if (tokenIs(""mod""))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_MOD);

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = MultiplicativeExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
      else if (tokenIs(""quo""))
      {
        nextToken();
        insertOp(addPos, 2, OpCodes.OP_QUO);

        int opPlusLeftHandLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - addPos;

        addPos = MultiplicativeExpr(addPos);
        m_ops.m_opMap[addPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[addPos + opPlusLeftHandLen + 1] + opPlusLeftHandLen;
        addPos += 2;
      }
    }

    return addPos;
  }

  
  protected void UnaryExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];
    boolean isNeg = false;

    if (m_tokenChar == '-')
    {
      nextToken();
      appendOp(2, OpCodes.OP_NEG);

      isNeg = true;
    }

    UnionExpr();

    if (isNeg)
      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
  }

  
  protected void StringExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    appendOp(2, OpCodes.OP_STRING);
    Expr();

    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
  }

  
  protected void BooleanExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    appendOp(2, OpCodes.OP_BOOL);
    Expr();

    int opLen = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

    if (opLen == 2)
    {
      error(XPATHErrorResources.ER_BOOLEAN_ARG_NO_LONGER_OPTIONAL, null);  
    }

    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] = opLen;
  }

  
  protected void NumberExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    appendOp(2, OpCodes.OP_NUMBER);
    Expr();

    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
  }

  
  protected void UnionExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];
    boolean continueOrLoop = true;
    boolean foundUnion = false;

    do
    {
      PathExpr();

      if (tokenIs('|'))
      {
        if (false == foundUnion)
        {
          foundUnion = true;

          insertOp(opPos, 2, OpCodes.OP_UNION);
        }

        nextToken();
      }
      else
      {
        break;
      }

      
    }
    while (continueOrLoop);

    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
  }

  
  protected void PathExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    int filterExprMatch = FilterExpr();

    if (filterExprMatch != FILTER_MATCH_FAILED)
    {
      
      
      boolean locationPathStarted = (filterExprMatch==FILTER_MATCH_PREDICATES);

      if (tokenIs('/'))
      {
        nextToken();

        if (!locationPathStarted)
        {
          
          insertOp(opPos, 2, OpCodes.OP_LOCATIONPATH);

          locationPathStarted = true;
        }

        if (!RelativeLocationPath())
        {
          
          error(XPATHErrorResources.ER_EXPECTED_REL_LOC_PATH, null);
        }

      }

      
      if (locationPathStarted)
      {
        m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = OpCodes.ENDOP;
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;
        m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
      }
    }
    else
    {
      LocationPath();
    }
  }

  
  protected int FilterExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    int filterMatch;

    if (PrimaryExpr())
    {
      if (tokenIs('['))
      {

        
        insertOp(opPos, 2, OpCodes.OP_LOCATIONPATH);

        while (tokenIs('['))
        {
          Predicate();
        }

        filterMatch = FILTER_MATCH_PREDICATES;
      }
      else
      {
        filterMatch = FILTER_MATCH_PRIMARY;
      }
    }
    else
    {
      filterMatch = FILTER_MATCH_FAILED;
    }

    return filterMatch;

    
  }

  
  protected boolean PrimaryExpr() throws javax.xml.transform.TransformerException
  {

    boolean matchFound;
    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    if ((m_tokenChar == ''') || (m_tokenChar == '""'))
    {
      appendOp(2, OpCodes.OP_LITERAL);
      Literal();

      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

      matchFound = true;
    }
    else if (m_tokenChar == '$')
    {
      nextToken();  
      appendOp(2, OpCodes.OP_VARIABLE);
      QName();
      
      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

      matchFound = true;
    }
    else if (m_tokenChar == '(')
    {
      nextToken();
      appendOp(2, OpCodes.OP_GROUP);
      Expr();
      consumeExpected(')');

      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

      matchFound = true;
    }
    else if ((null != m_token) && ((('.' == m_tokenChar) && (m_token.length() > 1) && Character.isDigit(
            m_token.charAt(1))) || Character.isDigit(m_tokenChar)))
    {
      appendOp(2, OpCodes.OP_NUMBERLIT);
      Number();

      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

      matchFound = true;
    }
    else if (lookahead('(', 1) || (lookahead(':', 1) && lookahead('(', 3)))
    {
      matchFound = FunctionCall();
    }
    else
    {
      matchFound = false;
    }

    return matchFound;
  }

  
  protected void Argument() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    appendOp(2, OpCodes.OP_ARGUMENT);
    Expr();

    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
  }

  
  protected boolean FunctionCall() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    if (lookahead(':', 1))
    {
      appendOp(4, OpCodes.OP_EXTFUNCTION);

      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH + 1] = m_queueMark - 1;

      nextToken();
      consumeExpected(':');

      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH + 2] = m_queueMark - 1;

      nextToken();
    }
    else
    {
      int funcTok = getFunctionToken(m_token);

      if (-1 == funcTok)
      {
        error(XPATHErrorResources.ER_COULDNOT_FIND_FUNCTION,
              new Object[]{ m_token });  
      }

      switch (funcTok)
      {
      case OpCodes.NODETYPE_PI :
      case OpCodes.NODETYPE_COMMENT :
      case OpCodes.NODETYPE_TEXT :
      case OpCodes.NODETYPE_NODE :
        
        return false;
      default :
        appendOp(3, OpCodes.OP_FUNCTION);

        m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH + 1] = funcTok;
      }

      nextToken();
    }

    consumeExpected('(');

    while (!tokenIs(')') && m_token != null)
    {
      if (tokenIs(','))
      {
        error(XPATHErrorResources.ER_FOUND_COMMA_BUT_NO_PRECEDING_ARG, null);  
      }

      Argument();

      if (!tokenIs(')'))
      {
        consumeExpected(',');

        if (tokenIs(')'))
        {
          error(XPATHErrorResources.ER_FOUND_COMMA_BUT_NO_FOLLOWING_ARG,
                null);  
        }
      }
    }

    consumeExpected(')');

    
    m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = OpCodes.ENDOP;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;
    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

    return true;
  }

  

  
  protected void LocationPath() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    
    appendOp(2, OpCodes.OP_LOCATIONPATH);

    boolean seenSlash = tokenIs('/');

    if (seenSlash)
    {
      appendOp(4, OpCodes.FROM_ROOT);

      
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 2] = 4;
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 1] =
        OpCodes.NODETYPE_ROOT;

      nextToken();
    }

    if (m_token != null)
    {
      if (!RelativeLocationPath() && !seenSlash)
      {
        
        
        error(XPATHErrorResources.ER_EXPECTED_LOC_PATH, 
              new Object [] {m_token});
      }
    }

    
    m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = OpCodes.ENDOP;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;
    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
  }

  
  protected boolean RelativeLocationPath()
               throws javax.xml.transform.TransformerException
  {
    if (!Step())
    {
      return false;
    }

    while (tokenIs('/'))
    {
      nextToken();

      if (!Step())
      {
        
        
        error(XPATHErrorResources.ER_EXPECTED_LOC_STEP, null);
      }
    }

    return true;
  }

  
  protected boolean Step() throws javax.xml.transform.TransformerException
  {
    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    boolean doubleSlash = tokenIs('/');

    
    
    
    if (doubleSlash)
    {
      nextToken();

      appendOp(2, OpCodes.FROM_DESCENDANTS_OR_SELF);

      
      
      
      

      
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] =
        OpCodes.NODETYPE_NODE;
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

      
      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH + 1] =
          m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

      
      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
          m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

      opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];
    }

    if (tokenIs("".""))
    {
      nextToken();

      if (tokenIs('['))
      {
        error(XPATHErrorResources.ER_PREDICATE_ILLEGAL_SYNTAX, null);  
      }

      appendOp(4, OpCodes.FROM_SELF);

      
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 2] = 4;
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 1] =
        OpCodes.NODETYPE_NODE;
    }
    else if (tokenIs(""..""))
    {
      nextToken();
      appendOp(4, OpCodes.FROM_PARENT);

      
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 2] = 4;
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 1] =
        OpCodes.NODETYPE_NODE;
    }

    
    
    
    else if (tokenIs('*') || tokenIs('@') || tokenIs('_')
             || (m_token!= null && Character.isLetter(m_token.charAt(0))))
    {
      Basis();

      while (tokenIs('['))
      {
        Predicate();
      }

      
      m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
    }
    else
    {
      
      if (doubleSlash)
      {
        
        error(XPATHErrorResources.ER_EXPECTED_LOC_STEP, null);
      }

      return false;
    }

    return true;
  }

  
  protected void Basis() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];
    int axesType;

    
    if (lookahead(""::"", 1))
    {
      axesType = AxisName();

      nextToken();
      nextToken();
    }
    else if (tokenIs('@'))
    {
      axesType = OpCodes.FROM_ATTRIBUTES;

      appendOp(2, axesType);
      nextToken();
    }
    else
    {
      axesType = OpCodes.FROM_CHILDREN;

      appendOp(2, axesType);
    }

    
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

    NodeTest(axesType);

    
    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH + 1] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
  }

  
  protected int AxisName() throws javax.xml.transform.TransformerException
  {

    Object val = Keywords.m_axisnames.get(m_token);

    if (null == val)
    {
      error(XPATHErrorResources.ER_ILLEGAL_AXIS_NAME,
            new Object[]{ m_token });  
    }

    int axesType = ((Integer) val).intValue();

    appendOp(2, axesType);

    return axesType;
  }

  
  protected void NodeTest(int axesType) throws javax.xml.transform.TransformerException
  {

    if (lookahead('(', 1))
    {
      Object nodeTestOp = Keywords.m_nodetypes.get(m_token);

      if (null == nodeTestOp)
      {
        error(XPATHErrorResources.ER_UNKNOWN_NODETYPE,
              new Object[]{ m_token });  
      }
      else
      {
        nextToken();

        int nt = ((Integer) nodeTestOp).intValue();

        m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = nt;
        m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

        consumeExpected('(');

        if (OpCodes.NODETYPE_PI == nt)
        {
          if (!tokenIs(')'))
          {
            Literal();
          }
        }

        consumeExpected(')');
      }
    }
    else
    {

      
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = OpCodes.NODENAME;
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

      if (lookahead(':', 1))
      {
        if (tokenIs('*'))
        {
          m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] =
            OpCodes.ELEMWILDCARD;
        }
        else
        {
          m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = m_queueMark
                  - 1;

          
          
          if (!Character.isLetter(m_tokenChar) && !tokenIs('_'))
          {
            
            error(XPATHErrorResources.ER_EXPECTED_NODE_TEST, null);
          }
        }

        nextToken();
        consumeExpected(':');
      }
      else
      {
        m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = OpCodes.EMPTY;
      }

      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

      if (tokenIs('*'))
      {
        m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] =
          OpCodes.ELEMWILDCARD;
      }
      else
      {
        if (OpCodes.FROM_NAMESPACE == axesType)
        {
          String prefix = (String) this.m_ops.m_tokenQueue[m_queueMark - 1];
          String namespace =
            ((PrefixResolver) m_namespaceContext).getNamespaceForPrefix(
              prefix);

          this.m_ops.m_tokenQueue[m_queueMark - 1] = namespace;
        }

        m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = m_queueMark - 1;

        
        
        if (!Character.isLetter(m_tokenChar) && !tokenIs('_'))
        {
          
          error(XPATHErrorResources.ER_EXPECTED_NODE_TEST, null);
        }
      }

      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

      nextToken();
    }
  }

  
  protected void Predicate() throws javax.xml.transform.TransformerException
  {

    if (tokenIs('['))
    {
      nextToken();
      PredicateExpr();
      consumeExpected(']');
    }
  }

  
  protected void PredicateExpr() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    appendOp(2, OpCodes.OP_PREDICATE);
    Expr();

    
    m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = OpCodes.ENDOP;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;
    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
  }

  
  protected void QName() throws javax.xml.transform.TransformerException
  {
    
    if(lookahead(':', 1))
    {
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = m_queueMark - 1;
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

      nextToken();
      consumeExpected(':');
    }
    else
    {
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = OpCodes.EMPTY;
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;
    }
    
    
    m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = m_queueMark - 1;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

    nextToken();
  }

  
  protected void NCName()
  {

    m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = m_queueMark - 1;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

    nextToken();
  }

  
  protected void Literal() throws javax.xml.transform.TransformerException
  {

    int last = m_token.length() - 1;
    char c0 = m_tokenChar;
    char cX = m_token.charAt(last);

    if (((c0 == '""') && (cX == '""')) || ((c0 == ''') && (cX == ''')))
    {

      
      
      int tokenQueuePos = m_queueMark - 1;

      m_ops.m_tokenQueue[tokenQueuePos] = null;

      Object obj = new XString(m_token.substring(1, last));

      m_ops.m_tokenQueue[tokenQueuePos] = obj;

      
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = tokenQueuePos;
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

      nextToken();
    }
    else
    {
      error(XPATHErrorResources.ER_PATTERN_LITERAL_NEEDS_BE_QUOTED,
            new Object[]{ m_token });  
    }
  }

  
  protected void Number() throws javax.xml.transform.TransformerException
  {

    if (null != m_token)
    {

      
      
      double num;

      try
      {
        num = Double.valueOf(m_token).doubleValue();
      }
      catch (NumberFormatException nfe)
      {
        num = 0.0;  

        error(XPATHErrorResources.ER_COULDNOT_BE_FORMATTED_TO_NUMBER,
              new Object[]{ m_token });  
      }

      m_ops.m_tokenQueue[m_queueMark - 1] = new XNumber(num);
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = m_queueMark - 1;
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

      nextToken();
    }
  }

  

  
  protected void Pattern() throws javax.xml.transform.TransformerException
  {

    while (true)
    {
      LocationPathPattern();

      if (tokenIs('|'))
      {
        nextToken();
      }
      else
      {
        break;
      }
    }
  }

  
  protected void LocationPathPattern() throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];

    final int RELATIVE_PATH_NOT_PERMITTED = 0;
    final int RELATIVE_PATH_PERMITTED     = 1;
    final int RELATIVE_PATH_REQUIRED      = 2;

    int relativePathStatus = RELATIVE_PATH_NOT_PERMITTED;

    appendOp(2, OpCodes.OP_LOCATIONPATHPATTERN);

    if (lookahead('(', 1)
            && (tokenIs(Keywords.FUNC_ID_STRING)
                || tokenIs(Keywords.FUNC_KEY_STRING)))
    {
      IdKeyPattern();

      if (tokenIs('/'))
      {
        nextToken();

        if (tokenIs('/'))
        {
          appendOp(4, OpCodes.MATCH_ANY_ANCESTOR);

          nextToken();
        }
        else
        {
          appendOp(4, OpCodes.MATCH_IMMEDIATE_ANCESTOR);
        }

        
        m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 2] = 4;
        m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 1] =
          OpCodes.NODETYPE_FUNCTEST;

        relativePathStatus = RELATIVE_PATH_REQUIRED;
      }
    }
    else if (tokenIs('/'))
    {
      if (lookahead('/', 1))
      {
        appendOp(4, OpCodes.MATCH_ANY_ANCESTOR);
        
        
        
        
        
        nextToken();

        relativePathStatus = RELATIVE_PATH_REQUIRED;
      }
      else
      {
        appendOp(4, OpCodes.FROM_ROOT);

        relativePathStatus = RELATIVE_PATH_PERMITTED;
      }


      
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 2] = 4;
      m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - 1] =
        OpCodes.NODETYPE_ROOT;

      nextToken();
    }
    else
    {
      relativePathStatus = RELATIVE_PATH_REQUIRED;
    }

    if (relativePathStatus != RELATIVE_PATH_NOT_PERMITTED)
    {
      if (!tokenIs('|') && (null != m_token))
      {
        RelativePathPattern();
      }
      else if (relativePathStatus == RELATIVE_PATH_REQUIRED)
      {
        
        error(XPATHErrorResources.ER_EXPECTED_REL_PATH_PATTERN, null);
      }
    }

    
    m_ops.m_opMap[m_ops.m_opMap[OpMap.MAPINDEX_LENGTH]] = OpCodes.ENDOP;
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;
    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;
  }

  
  protected void IdKeyPattern() throws javax.xml.transform.TransformerException
  {
    FunctionCall();
  }

  
  protected void RelativePathPattern()
              throws javax.xml.transform.TransformerException
  {

    
    
    boolean trailingSlashConsumed = StepPattern(false);

    while (tokenIs('/'))
    {
      nextToken();

      
      
      
      trailingSlashConsumed = StepPattern(!trailingSlashConsumed);
    }
  }

  
  protected boolean StepPattern(boolean isLeadingSlashPermitted)
            throws javax.xml.transform.TransformerException
  {
    return AbbreviatedNodeTestStep(isLeadingSlashPermitted);
  }

  
  protected boolean AbbreviatedNodeTestStep(boolean isLeadingSlashPermitted)
            throws javax.xml.transform.TransformerException
  {

    int opPos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];
    int axesType;

    
    int matchTypePos = -1;

    if (tokenIs('@'))
    {
      axesType = OpCodes.MATCH_ATTRIBUTE;

      appendOp(2, axesType);
      nextToken();
    }
    else if (this.lookahead(""::"", 1))
    {
      if (tokenIs(""attribute""))
      {
        axesType = OpCodes.MATCH_ATTRIBUTE;

        appendOp(2, axesType);
      }
      else if (tokenIs(""child""))
      {
        matchTypePos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];
        axesType = OpCodes.MATCH_IMMEDIATE_ANCESTOR;

        appendOp(2, axesType);
      }
      else
      {
        axesType = -1;

        this.error(XPATHErrorResources.ER_AXES_NOT_ALLOWED,
                   new Object[]{ this.m_token });
      }

      nextToken();
      nextToken();
    }
    else if (tokenIs('/'))
    {
      if (!isLeadingSlashPermitted)
      {
        
        error(XPATHErrorResources.ER_EXPECTED_STEP_PATTERN, null);
      }
      axesType = OpCodes.MATCH_ANY_ANCESTOR;

      appendOp(2, axesType);
      nextToken();
    }
    else
    {
      matchTypePos = m_ops.m_opMap[OpMap.MAPINDEX_LENGTH];
      axesType = OpCodes.MATCH_IMMEDIATE_ANCESTOR;

      appendOp(2, axesType);
    }

    
    m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] += 1;

    NodeTest(axesType);

    
    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH + 1] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

    while (tokenIs('['))
    {
      Predicate();
    }

    boolean trailingSlashConsumed;

    
    
    
    
    
    
    
    
    
    
    
    
    if ((matchTypePos > -1) && tokenIs('/') && lookahead('/', 1))
    {
      m_ops.m_opMap[matchTypePos] = OpCodes.MATCH_ANY_ANCESTOR;

      nextToken();

      trailingSlashConsumed = true;
    }
    else
    {
      trailingSlashConsumed = false;
    }

    
    m_ops.m_opMap[opPos + OpMap.MAPINDEX_LENGTH] =
      m_ops.m_opMap[OpMap.MAPINDEX_LENGTH] - opPos;

    return trailingSlashConsumed;
  }
}
"
org.apache.xalan.transformer.ResultTreeHandler,64,2,0,38,159,878,20,22,58,0.820512821,1706,0.692307692,5,0.088235294,0.126116071,1,1,25.453125,6,1.3906,2,"
package org.apache.xalan.transformer;

import java.util.Enumeration;

import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.trace.TraceManager;
import org.apache.xalan.trace.GenerateEvent;
import org.apache.xml.utils.MutableAttrListImpl;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.TreeWalker;
import org.apache.xml.utils.ObjectPool;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.XPathContext;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMFilter;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.SAXParseException;
import org.xml.sax.SAXException;
import org.xml.sax.ErrorHandler;

import org.xml.sax.helpers.NamespaceSupport;
import org.apache.xml.utils.NamespaceSupport2;
import org.xml.sax.Locator;

import javax.xml.transform.TransformerException;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.Transformer;


public class ResultTreeHandler extends QueuedEvents
        implements ContentHandler, LexicalHandler, TransformState,
        org.apache.xml.dtm.ref.dom2dtm.DOM2DTM.CharacterNodeHandler,
        ErrorHandler
{

  
  private static final boolean DEBUG = false;

  
  public ResultTreeHandler(){}

  
  public ResultTreeHandler(TransformerImpl transformer,
                           ContentHandler realHandler)
  {
    init(transformer, realHandler);
  }

  
  public void init(TransformerImpl transformer, ContentHandler realHandler)
  {

    m_transformer = transformer;

    
    TraceManager tracer = transformer.getTraceManager();

    if ((null != tracer) && tracer.hasTraceListeners())
      m_tracer = tracer;
    else
      m_tracer = null;

    
    m_contentHandler = realHandler;

    
    if (m_contentHandler instanceof LexicalHandler)
      m_lexicalHandler = (LexicalHandler) m_contentHandler;
    else
      m_lexicalHandler = null;

    m_isTransformClient = (m_contentHandler instanceof TransformerClient);

    m_cloner = new ClonerToResultTree(transformer, this);

    
    
    if (null != m_transformer)
      m_stylesheetRoot = m_transformer.getStylesheet();

    pushDocumentEvent();  
  }

  
  public void startDocument() throws org.xml.sax.SAXException{}

  
  public void endDocument() throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (!m_docEnded)
    {
      m_contentHandler.endDocument();

      if (null != m_tracer)
      {
        GenerateEvent ge =
          new GenerateEvent(m_transformer,
                            GenerateEvent.EVENTTYPE_ENDDOCUMENT, null);

        m_tracer.fireGenerateEvent(ge);
      }

      m_docEnded = true;
      m_docPending = false;
    }
  }

  
  public void startElement(
          String ns, String localName, String name, Attributes atts)
            throws org.xml.sax.SAXException
  {

    if (DEBUG)
    {
      if (m_elemIsPending)
        System.out.println(""(ResultTreeHandler#startElement - pended: ""
                           + m_url + ""#"" + m_localName);

      System.out.println(""ResultTreeHandler#startElement: "" + ns + ""#""
                         + localName);

      
      
      
      
    }

    if(m_docPending)
      checkForSerializerSwitch(ns, localName);
      
    flushPending(true);

    if (!m_nsContextPushed)
    {
      if (DEBUG)
        System.out.println(
          ""ResultTreeHandler#startElement - push(startElement)"");

      m_nsSupport.pushContext();

      m_nsContextPushed = true;
    }
    
    if (ns != null)
      ensurePrefixIsDeclared(ns, name);

    m_name = name;
    m_url = ns;
    m_localName = localName;

    if (null != atts)
      m_attributes.addAttributes(atts);

    m_elemIsPending = true;
    m_elemIsEnded = false;
    
    if(m_isTransformClient && (null != m_transformer))
    {
      m_snapshot.m_currentElement = m_transformer.getCurrentElement();
      m_snapshot.m_currentTemplate = m_transformer.getCurrentTemplate();
      m_snapshot.m_matchedTemplate = m_transformer.getMatchedTemplate();
      int currentNodeHandle = m_transformer.getCurrentNode();
      DTM dtm = m_transformer.getXPathContext().getDTM(currentNodeHandle);
      m_snapshot.m_currentNode = dtm.getNode(currentNodeHandle);
      m_snapshot.m_matchedNode = m_transformer.getMatchedNode();
      m_snapshot.m_contextNodeList = m_transformer.getContextNodeList(); 
    }
    

    m_eventCount++;
  }

  
  public void endElement(String ns, String localName, String name)
          throws org.xml.sax.SAXException
  {

    if (DEBUG)
    {
      if (m_elemIsPending)
        System.out.println(""(ResultTreeHandler#endElement - pended: ""
                           + m_url + ""#"" + m_localName);

      System.out.println(""ResultTreeHandler#endElement: "" + ns + ""#""
                         + localName);
    }

    flushPending(true);
    m_contentHandler.endElement(ns, localName, name);

    if (null != m_tracer)
    {
      GenerateEvent ge = new GenerateEvent(m_transformer,
                                           GenerateEvent.EVENTTYPE_ENDELEMENT,
                                           name, (Attributes)null);

      m_tracer.fireGenerateEvent(ge);
    }

    sendEndPrefixMappings();
    popEvent();

    if (DEBUG)
      System.out.println(""ResultTreeHandler#startElement pop: "" + localName);

    m_nsSupport.popContext();
  }

  
  boolean m_nsContextPushed = false;

  
  public void startPrefixMapping(String prefix, String uri)
          throws org.xml.sax.SAXException
  {
    startPrefixMapping(prefix, uri, true);
  }

  
  public void startPrefixMapping(
          String prefix, String uri, boolean shouldFlush)
            throws org.xml.sax.SAXException
  {

    if (shouldFlush)
      flushPending(false);

    if (!m_nsContextPushed)
    {
      if (DEBUG)
        System.out.println(
          ""ResultTreeHandler#startPrefixMapping push(startPrefixMapping: ""
          + prefix + "")"");

      m_nsSupport.pushContext();

      m_nsContextPushed = true;
    }

    if (null == prefix)
      prefix = """";  

    String existingURI = m_nsSupport.getURI(prefix);

    if (null == existingURI)
      existingURI = """";

    if (null == uri)
      uri = """";

    if (!existingURI.equals(uri))
    {
      if (DEBUG)
      {
        System.out.println(""ResultTreeHandler#startPrefixMapping Prefix: ""
                           + prefix);
        System.out.println(""ResultTreeHandler#startPrefixMapping uri: ""
                           + uri);
      }

      m_nsSupport.declarePrefix(prefix, uri);
    }
  }

  
  public void endPrefixMapping(String prefix)
          throws org.xml.sax.SAXException{}

  
  public void characters(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    
    
    
    

    
    if (DEBUG)
    {
      System.out.print(""ResultTreeHandler#characters: "");

      int n = start + length;

      for (int i = start; i < n; i++)
      {
        if (Character.isWhitespace(ch[i]))
          System.out.print(""\"" + ((int) ch[i]));
        else
          System.out.print(ch[i]);
      }

      System.out.println("""");
    }

    flushPending(true);
    m_contentHandler.characters(ch, start, length);

    if (null != m_tracer)
    {
      GenerateEvent ge = new GenerateEvent(m_transformer,
                                           GenerateEvent.EVENTTYPE_CHARACTERS,
                                           ch, start, length);

      m_tracer.fireGenerateEvent(ge);
    }
  }
  
  public void characters(org.w3c.dom.Node node)
          throws org.xml.sax.SAXException
  {

    flushPending(true);
    
    if(m_isTransformClient)
      m_snapshot.m_currentNode = node;

    String data = node.getNodeValue();
    char [] ch = null;
    int length = 0;
    if (data != null)
    {
    ch = data.toCharArray();
    length = data.length();
    m_contentHandler.characters(ch, 0, length);
    }
    
    if (null != m_tracer)
    {
      GenerateEvent ge = new GenerateEvent(m_transformer,
                                           GenerateEvent.EVENTTYPE_CHARACTERS,
                                           ch, 0, length);

      m_tracer.fireGenerateEvent(ge);
    }  
    if(m_isTransformClient)
      m_snapshot.m_currentNode = null;
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    if (m_docPending
            && XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
      return;

    flushPending(true);
    m_contentHandler.ignorableWhitespace(ch, start, length);

    if (null != m_tracer)
    {
      GenerateEvent ge =
        new GenerateEvent(m_transformer,
                          GenerateEvent.EVENTTYPE_IGNORABLEWHITESPACE, ch,
                          start, length);

      m_tracer.fireGenerateEvent(ge);
    }
  }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {

    flushPending(true);
    m_contentHandler.processingInstruction(target, data);

    if (null != m_tracer)
    {
      GenerateEvent ge = new GenerateEvent(m_transformer,
                                           GenerateEvent.EVENTTYPE_PI,
                                           target, data);

      m_tracer.fireGenerateEvent(ge);
    }
  }

  
  public void comment(String data) throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.comment(data.toCharArray(), 0, data.length());
    }

    if (null != m_tracer)
    {
      GenerateEvent ge = new GenerateEvent(m_transformer,
                                           GenerateEvent.EVENTTYPE_COMMENT,
                                           data);

      m_tracer.fireGenerateEvent(ge);
    }
  }

  
  public void comment(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.comment(ch, start, length);
    }

    if (null != m_tracer)
    {
      GenerateEvent ge = new GenerateEvent(m_transformer,
                                           GenerateEvent.EVENTTYPE_COMMENT,
                                           new String(ch, start, length));

      m_tracer.fireGenerateEvent(ge);
    }
  }

  
  public void entityReference(String name) throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startEntity(name);
      m_lexicalHandler.endEntity(name);
    }

    if (null != m_tracer)
    {
      GenerateEvent ge = new GenerateEvent(m_transformer,
                                           GenerateEvent.EVENTTYPE_ENTITYREF,
                                           name);

      m_tracer.fireGenerateEvent(ge);
    }
  }

  
  public void startEntity(String name) throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startEntity(name);
    }
  }

  
  public void endEntity(String name) throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.endEntity(name);
    }

    if (null != m_tracer)
    {
      GenerateEvent ge = new GenerateEvent(m_transformer,
                                           GenerateEvent.EVENTTYPE_ENTITYREF,
                                           name);

      m_tracer.fireGenerateEvent(ge);
    }
  }

  
  public void startDTD(String s1, String s2, String s3)
          throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startDTD(s1, s2, s3);
    }
  }

  
  public void endDTD() throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.endDTD();
    }
  }

  
  public void startCDATA() throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.startCDATA();
    }
  }

  
  public void endCDATA() throws org.xml.sax.SAXException
  {

    flushPending(true);

    if (null != m_lexicalHandler)
    {
      m_lexicalHandler.endCDATA();
    }
  }

  
  public void skippedEntity(String name) throws org.xml.sax.SAXException{}

  
  public void setNSDeclsHaveBeenAdded(boolean b)
  {

    m_nsDeclsHaveBeenAdded = b;
  }

  
  void flushDocEvent() throws org.xml.sax.SAXException
  {

    if (m_docPending)
    {
      m_contentHandler.startDocument();

      if (null != m_tracer)
      {
        GenerateEvent ge =
          new GenerateEvent(m_transformer,
                            GenerateEvent.EVENTTYPE_STARTDOCUMENT);

        m_tracer.fireGenerateEvent(ge);
      }

      if (m_contentHandler instanceof TransformerClient)
      {
        ((TransformerClient) m_contentHandler).setTransformState(this);
      }

      m_docPending = false;
    }
  }
  
  
  void flushElem() throws org.xml.sax.SAXException
  {

    if (m_elemIsPending)
    {
      if (null != m_name)
      {
        try
        {
          m_contentHandler.startElement(m_url, m_localName, m_name,
                                      m_attributes);
        }
        catch(Exception re)
        {
          
          
          
          
          
          throw new SAXParseException(re.getMessage(), 
          m_transformer.getCurrentElement().getPublicId(), 
          m_transformer.getCurrentElement().getSystemId(), 
          m_transformer.getCurrentElement().getLineNumber(), 
          m_transformer.getCurrentElement().getColumnNumber(), 
          re);
        }
        
        if(null != m_tracer)
        {
          GenerateEvent ge =
            new GenerateEvent(m_transformer,
                              GenerateEvent.EVENTTYPE_STARTELEMENT, m_name,
                                      m_attributes);
  
          m_tracer.fireGenerateEvent(ge);
        }
        if(m_isTransformClient)
          m_snapshot.m_currentNode = null;
      }

      m_elemIsPending = false;
      m_attributes.clear();
  
      m_nsDeclsHaveBeenAdded = false;
      m_name = null;
      m_url = null;
      m_localName = null;
      m_namespaces = null;

      
    }
  }


  
  public final void flushPending() throws org.xml.sax.SAXException
  {
    flushPending(true);
  }

  
  public final void flushPending(boolean flushPrefixes)
          throws org.xml.sax.SAXException
  {

    if (flushPrefixes && m_docPending)
    {
      flushDocEvent();
    }

    if (m_elemIsPending)
    {
      
      
      if (!m_nsDeclsHaveBeenAdded)

          startAndAddPrefixMappings();  
      else                              
          sendStartPrefixMappings();


      if (DEBUG)
      {
        System.out.println(""ResultTreeHandler#flushPending - start flush: ""
                           + m_name);
      }

      flushElem();

      if (DEBUG)
      {
        System.out.println(
          ""ResultTreeHandler#flushPending - after flush, isPending: ""
          + m_elemIsPending);
      }

      m_nsContextPushed = false;
    }
  }

  
  public void outputResultTreeFragment(XObject obj, XPathContext support)
          throws org.xml.sax.SAXException
  {

    int doc = obj.rtf();
    DTM dtm = support.getDTM(doc);

    if(null != dtm)
    {
	    for (int n = dtm.getFirstChild(doc); DTM.NULL != n;
	            n = dtm.getNextSibling(n))
	    {
	      flushPending(true);  
	      dtm.dispatchToEvents(n, this);
	    }
    }
  }

  
  public void setDocumentLocator(Locator locator){}

  
  public void ensurePrefixIsDeclared(String ns, String rawName)
          throws org.xml.sax.SAXException
  {

    if (ns != null && ns.length() > 0)
    {
      int index;
      String prefix = (index = rawName.indexOf("":"")) < 0
                      ? """" : rawName.substring(0, index);

      if (null != prefix)
      {
        String foundURI = m_nsSupport.getURI(prefix);

        if ((null == foundURI) ||!foundURI.equals(ns))
        {
          startPrefixMapping(prefix, ns, false);
                                        
          
          

          m_attributes.addAttribute(""http:
                                    prefix, 
                                    ""xmlns""+(prefix.length()==0 ? """" : "":"")+prefix, 
                                    ""CDATA"", ns);
        }
      }
    }
  }

  
  public void ensureNamespaceDeclDeclared(DTM dtm, int namespace)
          throws org.xml.sax.SAXException
  {

    String uri = dtm.getNodeValue(namespace);
    String prefix = dtm.getNodeNameX(namespace);

    if ((uri != null && uri.length() > 0) && (null != prefix))
    {
      String foundURI = m_nsSupport.getURI(prefix);

      if ((null == foundURI) ||!foundURI.equals(uri))
      {
        startPrefixMapping(prefix, uri, false);
      }
    }
  }

  
  protected void sendStartPrefixMappings() throws org.xml.sax.SAXException
  {
    Enumeration prefixes = m_nsSupport.getDeclaredPrefixes();
    ContentHandler handler = m_contentHandler;
    while (prefixes.hasMoreElements())
    {
      String prefix = (String) prefixes.nextElement();
      handler.startPrefixMapping(prefix, m_nsSupport.getURI(prefix));
    }
  }

  
  protected void startAndAddPrefixMappings() throws org.xml.sax.SAXException
  {

    Enumeration prefixes = m_nsSupport.getDeclaredPrefixes();
    ContentHandler handler = m_contentHandler;

    while (prefixes.hasMoreElements())
    {
      String prefix = (String) prefixes.nextElement();
      String uri=m_nsSupport.getURI(prefix);
      
      
      handler.startPrefixMapping(prefix, uri);

      
      boolean isDefault = (prefix.length() == 0);
      String name;

      if (isDefault)
      {
        
        name = ""xmlns"";
      }
      else
        name = ""xmlns:"" + prefix;

      if (null == uri)
        uri = """";

      m_attributes.addAttribute(""http:
                                prefix, name, ""CDATA"", uri);
    }
    m_nsDeclsHaveBeenAdded=true;
  }

  
  protected void sendEndPrefixMappings() throws org.xml.sax.SAXException
  {

    Enumeration prefixes = m_nsSupport.getDeclaredPrefixes();
    ContentHandler handler = m_contentHandler;

    while (prefixes.hasMoreElements())
    {
      String prefix = (String) prefixes.nextElement();

      handler.endPrefixMapping(prefix);
    }
  }

  
  private void checkForSerializerSwitch(String ns, String localName)
          throws org.xml.sax.SAXException
  {

    try
    {
      if (m_docPending)
      {
        SerializerSwitcher.switchSerializerIfHTML(m_transformer, ns,
                                                  localName);
      }
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  public void addNSDeclsToAttrs()
  {

    Enumeration prefixes = m_nsSupport.getDeclaredPrefixes();

    while (prefixes.hasMoreElements())
    {
      String prefix = (String) prefixes.nextElement();
      boolean isDefault = (prefix.length() == 0);
      String name;

      if (isDefault)
      {

        
        name = ""xmlns"";
      }
      else
        name = ""xmlns:"" + prefix;

      String uri = m_nsSupport.getURI(prefix);

      if (null == uri)
        uri = """";

      m_attributes.addAttribute(""http:
                                prefix, name, ""CDATA"", uri);
      
      m_nsDeclsHaveBeenAdded = true;        
    }

  }

  
  public void processNSDecls(int src, int type, DTM dtm)
          throws TransformerException
  {

    try
    {
      if (type == DTM.ELEMENT_NODE)
      {
        for (int namespace = dtm.getFirstNamespaceNode(src, true);
                DTM.NULL != namespace;
                namespace = dtm.getNextNamespaceNode(src, namespace, true))
        {

          
          String prefix = dtm.getNodeNameX(namespace);
          String desturi = getURI(prefix);
          String srcURI = dtm.getNodeValue(namespace);

          if (!srcURI.equalsIgnoreCase(desturi))
          {
            this.startPrefixMapping(prefix, srcURI, false);
          }
        }
      }
      else if (type == DTM.NAMESPACE_NODE)
			{
          String prefix = dtm.getNodeNameX(src);
          String desturi = getURI(prefix);
          String srcURI = dtm.getNodeValue(src);

          if (!srcURI.equalsIgnoreCase(desturi))
          {
            this.startPrefixMapping(prefix, srcURI, false);
          }
			}
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }

  
  public String getURI(String prefix)
  {
    return m_nsSupport.getURI(prefix);
  }

  
  public String getPrefix(String namespace)
  {

    
    Enumeration enum = m_nsSupport.getPrefixes();

    while (enum.hasMoreElements())
    {
      String prefix = (String) enum.nextElement();

      if (m_nsSupport.getURI(prefix).equals(namespace))
        return prefix;
    }

    return null;
  }

  
  public NamespaceSupport getNamespaceSupport()
  {
    return m_nsSupport;
  }

  
  
  
  
  
  
  
  
  
  
  
  

  
  public final ContentHandler getContentHandler()
  {
    return m_contentHandler;
  }

  
  public void setContentHandler(ContentHandler ch)
  {

    m_contentHandler = ch;

    m_isTransformClient = (m_contentHandler instanceof TransformerClient);

    if (m_contentHandler instanceof LexicalHandler)
      m_lexicalHandler = (LexicalHandler) m_contentHandler;
    else
      m_lexicalHandler = null;

    reInitEvents();
  }

  
  public int getUniqueNSValue()
  {
    return m_uniqueNSValue++;
  }

  
  public String getNewUniqueNSPrefix()
  {
    return S_NAMESPACEPREFIX + String.valueOf(getUniqueNSValue());
  }

  
  public MutableAttrListImpl getPendingAttributes()
  {
    return m_attributes;
  }

  
  public void addAttribute(
          String uri, String localName, String rawName, String type, String value)
            throws TransformerException
  {
    
    
    
    
    if (m_elemIsPending)
    {
      
      
      
	addNSDeclsToAttrs();

      if (null == uri)  
	uri = """";

      try
      {
	if (!rawName.equals(""xmlns""))  
	  ensurePrefixIsDeclared(uri, rawName);
      }
      catch (org.xml.sax.SAXException se)
      {
	throw new TransformerException(se);
      }
      
      if (DEBUG)
	System.out.println(""ResultTreeHandler#addAttribute Adding attr: ""
			   + localName + "", "" + uri);

      if (!isDefinedNSDecl(rawName, value))
	m_attributes.addAttribute(uri, localName, rawName, type, value);
    }
  }

  
  public boolean isDefinedNSDecl(String rawName, String value)
  {

    if (rawName.equals(""xmlns"") || rawName.startsWith(""xmlns:""))
    {
      int index;
      String prefix = (index = rawName.indexOf("":"")) < 0
                      ? """" : rawName.substring(0, index);
      String definedURI = m_nsSupport.getURI(prefix);

      if (null != definedURI)
      {
        if (definedURI.equals(value))
        {
          return true;
        }
        else
          return false;
      }
      else
        return false;
    }
    else
      return false;
  }

  
  public boolean isDefinedNSDecl(int attr)
  {

    DTM dtm = m_transformer.getXPathContext().getDTM(attr);

    if (DTM.NAMESPACE_NODE == dtm.getNodeType(attr))
    {

      
      String prefix = dtm.getNodeNameX(attr);
      String uri = getURI(prefix);

      if ((null != uri) && uri.equals(dtm.getStringValue(attr)))
        return true;
    }

    return false;
  }

  
  public boolean isDefinedNSDecl(int attr, DTM dtm)
  {

    if (DTM.NAMESPACE_NODE == dtm.getNodeType(attr))
    {

      
      String prefix = dtm.getNodeNameX(attr);
      String uri = getURI(prefix);

      if ((null != uri) && uri.equals(dtm.getStringValue(attr)))
        return true;
    }

    return false;
  }

  
  public void addAttribute(int attr) throws TransformerException
  {

    DTM dtm = m_transformer.getXPathContext().getDTM(attr);

    if (isDefinedNSDecl(attr, dtm))
      return;

    String ns = dtm.getNamespaceURI(attr);

    if (ns == null)
      ns = """";

    
    addAttribute(ns, dtm.getLocalName(attr), dtm.getNodeName(attr), ""CDATA"",
                 dtm.getNodeValue(attr));
  }  

  
  public void addAttributes(int src) throws TransformerException
  {

    DTM dtm = m_transformer.getXPathContext().getDTM(src);

    for (int node = dtm.getFirstAttribute(src); DTM.NULL != node;
            node = dtm.getNextAttribute(node))
    {
      addAttribute(node);
    }
  }

  
  public final boolean isElementPending()
  {
    
    return m_elemIsPending;
  }

  
  public ElemTemplateElement getCurrentElement()
  {

    if (m_elemIsPending)
      return m_snapshot.m_currentElement;
    else
      return m_transformer.getCurrentElement();
  }

  
  public org.w3c.dom.Node getCurrentNode()
  {
    
    if (m_snapshot.m_currentNode != null)
    {
      return m_snapshot.m_currentNode;
    }
    else
    {
      DTM dtm = m_transformer.getXPathContext().getDTM(m_transformer.getCurrentNode());
      return dtm.getNode(m_transformer.getCurrentNode());
    }
  }

  
  public ElemTemplate getCurrentTemplate()
  {

    if (m_elemIsPending)
      return m_snapshot.m_currentTemplate;
    else
      return m_transformer.getCurrentTemplate();
  }

  
  public ElemTemplate getMatchedTemplate()
  {

    if (m_elemIsPending)
      return m_snapshot.m_matchedTemplate;
    else
      return m_transformer.getMatchedTemplate();
  }

  
  public org.w3c.dom.Node getMatchedNode()
  {

    if (m_elemIsPending)
    {
      DTM dtm = m_transformer.getXPathContext().getDTM(m_snapshot.m_matchedNode);
      return dtm.getNode(m_snapshot.m_matchedNode);
    }
    else
    {
      DTM dtm = m_transformer.getXPathContext().getDTM(m_transformer.getMatchedNode());
      return dtm.getNode(m_transformer.getMatchedNode());
    }
  }

  
  public org.w3c.dom.traversal.NodeIterator getContextNodeList()
  {

    if (m_elemIsPending)
    {
      return new org.apache.xml.dtm.ref.DTMNodeIterator(m_snapshot.m_contextNodeList);
    }
    else
      return new org.apache.xml.dtm.ref.DTMNodeIterator(m_transformer.getContextNodeList());
  }

  
  public Transformer getTransformer()
  {
    return m_transformer;
  }
  
  
  
  
  
  public void warning (SAXParseException exception)
    throws SAXException
  {
    if (m_contentHandler instanceof ErrorHandler)
      ((ErrorHandler)m_contentHandler).warning(exception);
  }
    
    
   
  public void error (SAXParseException exception)
    throws SAXException
  {
    if (m_contentHandler instanceof ErrorHandler)
      ((ErrorHandler)m_contentHandler).error(exception);
  }
    
    
   
  public void fatalError (SAXParseException exception)
    throws SAXException
  {      
    m_elemIsPending = false;
    m_docEnded = true;
    m_docPending = false;
    
    if (m_contentHandler instanceof ErrorHandler)
      ((ErrorHandler)m_contentHandler).fatalError(exception);
  }
  
  boolean m_isTransformClient = false;

  
  NamespaceSupport m_nsSupport = new NamespaceSupport2();

  
  private TransformerImpl m_transformer;

  
  private ContentHandler m_contentHandler;

  
  private LexicalHandler m_lexicalHandler;

  
  private StylesheetRoot m_stylesheetRoot = null;

  
  private int m_uniqueNSValue = 0;

  
  private static final String S_NAMESPACEPREFIX = ""ns"";

  
  public ClonerToResultTree m_cloner;

  
  private TraceManager m_tracer;
  
  private QueuedStateSnapshot m_snapshot = new QueuedStateSnapshot();

  
  
  
  class QueuedStateSnapshot
  {
    
    ElemTemplateElement m_currentElement;
    
    
    org.w3c.dom.Node m_currentNode;
    
    
    ElemTemplate m_currentTemplate;
    
    
    ElemTemplate m_matchedTemplate;
    
    
    int m_matchedNode;
    
    
    DTMIterator m_contextNodeList;
  }
}
"
org.apache.xml.dtm.ref.dom2dtm.DOM2DTMdefaultNamespaceDeclarationNode,46,1,0,3,53,1009,2,1,45,0.966666667,245,0.0,0,0.0,0.190217391,0,0,4.195652174,1,0.9783,0,"

package org.apache.xml.dtm.ref.dom2dtm;

import org.w3c.dom.*;
import org.apache.xml.dtm.ref.dom2dtm.DOM2DTM;
import org.apache.xml.dtm.ref.*;
import org.apache.xml.dtm.*;


public class DOM2DTMdefaultNamespaceDeclarationNode implements Attr
{
  final String NOT_SUPPORTED_ERR=""Unsupported operation on pseudonode"";
  
  Element pseudoparent;
  String prefix,uri,nodename;
  int handle;
  DOM2DTMdefaultNamespaceDeclarationNode(Element pseudoparent,String prefix,String uri,int handle)
  {
    this.pseudoparent=pseudoparent;
    this.prefix=prefix;
    this.uri=uri;
    this.handle=handle;
    this.nodename=""xmlns:""+prefix;
  }
  public String getNodeName() {return nodename;}
  public String getName() {return nodename;}
  public String getNamespaceURI() {return ""http:
  public String getPrefix() {return prefix;}
  public String getLocalName() {return prefix;}
  public String getNodeValue() {return uri;}
  public String getValue() {return uri;}
  public Element getOwnerElement() {return pseudoparent;}
  
  public boolean isSupported(String feature, String version) {return false;}
  public boolean hasChildNodes() {return false;}
  public boolean hasAttributes() {return false;}
  public Node getParentNode() {return null;}
  public Node getFirstChild() {return null;}
  public Node getLastChild() {return null;}
  public Node getPreviousSibling() {return null;}
  public Node getNextSibling() {return null;}
  public boolean getSpecified() {return false;}
  public void normalize() {return;}
  public NodeList getChildNodes() {return null;}
  public NamedNodeMap getAttributes() {return null;}
  public short getNodeType() {return Node.ATTRIBUTE_NODE;}
  public void setNodeValue(String value) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public void setValue(String value) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public void setPrefix(String value) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Node insertBefore(Node a, Node b) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Node replaceChild(Node a, Node b) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Node appendChild(Node a) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Node removeChild(Node a) {throw new DTMException(NOT_SUPPORTED_ERR);}
  public Document getOwnerDocument() {return pseudoparent.getOwnerDocument();}
  public Node cloneNode(boolean deep) {throw new DTMException(NOT_SUPPORTED_ERR);}
	
	
	public int getHandleOfNode()		
	{
		return handle;
	}
}

"
org.apache.xml.utils.XMLCharacterRecognizer,5,1,0,8,10,10,8,0,5,2.0,85,0.0,0,0.0,0.2,0,0,16.0,5,3.0,0,"
package org.apache.xml.utils;


public class XMLCharacterRecognizer
{

  
  public static boolean isWhiteSpace(char ch)
  {
    return (ch == 0x20) || (ch == 0x09) || (ch == 0xD) || (ch == 0xA);
  }

  
  public static boolean isWhiteSpace(char ch[], int start, int length)
  {

    int end = start + length;

    for (int s = start; s < end; s++)
    {
      if (!isWhiteSpace(ch[s]))
        return false;
    }

    return true;
  }

  
  public static boolean isWhiteSpace(StringBuffer buf)
  {

    int n = buf.length();

    for (int i = 0; i < n; i++)
    {
      if (!isWhiteSpace(buf.charAt(i)))
        return false;
    }

    return true;
  }
  
  
  public static boolean isWhiteSpace(String s)
  {

    if(null != s)
    {
      int n = s.length();
  
      for (int i = 0; i < n; i++)
      {
        if (!isWhiteSpace(s.charAt(i)))
          return false;
      }
    }

    return true;
  }

}
"
org.apache.xml.dtm.ref.DTMTreeWalker,10,1,1,6,41,0,3,3,7,0.333333333,437,0.666666667,1,0.0,0.475,0,0,42.4,1,0.8,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;
import org.w3c.dom.*;

import org.xml.sax.*;
import org.xml.sax.ext.LexicalHandler;

import org.apache.xml.utils.NodeConsumer;
import org.apache.xml.utils.XMLString;


public class DTMTreeWalker
{

  
  private ContentHandler m_contentHandler = null;

  
  protected DTM m_dtm;
  
  
  public void setDTM(DTM dtm)
  {
    m_dtm = dtm;
  }

  
  public ContentHandler getcontentHandler()
  {
    return m_contentHandler;
  }
  
  
  public void setcontentHandler(ContentHandler ch)
  {
    m_contentHandler = ch;
  }

  
  
  public DTMTreeWalker()
  {
  }
  
  
  public DTMTreeWalker(ContentHandler contentHandler, DTM dtm)
  {
    this.m_contentHandler = contentHandler;
    m_dtm = dtm;
  }
  
  
  public void traverse(int pos) throws org.xml.sax.SAXException
  {
    

    int top = pos;		

    while (DTM.NULL != pos)
    {
      startNode(pos);
      int nextNode = m_dtm.getFirstChild(pos);
      while (DTM.NULL == nextNode)
      {
        endNode(pos);

        if (top == pos)
          break;

        nextNode = m_dtm.getNextSibling(pos);

        if (DTM.NULL == nextNode)
        {
          pos = m_dtm.getParent(pos);

          if ((DTM.NULL == pos) || (top == pos))
          {
            
            
            if (DTM.NULL != pos)
              endNode(pos);

            nextNode = DTM.NULL;

            break;
          }
        }
      }

      pos = nextNode;
    }
  }

  
  public void traverse(int pos, int top) throws org.xml.sax.SAXException
  {
    
    
    
    

    while (DTM.NULL != pos)
    {
      startNode(pos);
      int nextNode = m_dtm.getFirstChild(pos);
      while (DTM.NULL == nextNode)
      {
        endNode(pos);

        if ((DTM.NULL != top) && top == pos)
          break;

        nextNode = m_dtm.getNextSibling(pos);

        if (DTM.NULL == nextNode)
        {
          pos = m_dtm.getParent(pos);

          if ((DTM.NULL == pos) || ((DTM.NULL != top) && (top == pos)))
          {
            nextNode = DTM.NULL;

            break;
          }
        }
      }

      pos = nextNode;
    }
  }

  
  boolean nextIsRaw = false;
  
  
  private final void dispatachChars(int node)
     throws org.xml.sax.SAXException
  {
    m_dtm.dispatchCharactersEvents(node, m_contentHandler, false);
  }

  
  protected void startNode(int node) throws org.xml.sax.SAXException
  {

    if (m_contentHandler instanceof NodeConsumer)
    {
      

    }

    switch (m_dtm.getNodeType(node))
    {
    case DTM.COMMENT_NODE :
    {
      XMLString data = m_dtm.getStringValue(node);

      if (m_contentHandler instanceof LexicalHandler)
      {
        LexicalHandler lh = ((LexicalHandler) this.m_contentHandler);
        data.dispatchAsComment(lh);
      }
    }
    break;
    case DTM.DOCUMENT_FRAGMENT_NODE :

      
      break;
    case DTM.DOCUMENT_NODE :
      this.m_contentHandler.startDocument();
      break;
    case DTM.ELEMENT_NODE :
      DTM dtm = m_dtm;           

      for (int nsn = dtm.getFirstNamespaceNode(node, true); DTM.NULL != nsn;
           nsn = dtm.getNextNamespaceNode(node, nsn, true))
      {
        
        String prefix = dtm.getNodeNameX(nsn);

        this.m_contentHandler.startPrefixMapping(prefix, dtm.getNodeValue(nsn));
        
      }

      
      
      String ns = dtm.getNamespaceURI(node);
      if(null == ns)
        ns = """";
        
      
      org.xml.sax.helpers.AttributesImpl attrs = 
                            new org.xml.sax.helpers.AttributesImpl();
              
      for (int i = dtm.getFirstAttribute(node); 
           i != DTM.NULL; 
           i = dtm.getNextAttribute(i)) 
      {
        attrs.addAttribute(dtm.getNamespaceURI(i), 
                           dtm.getLocalName(i), 
                           dtm.getNodeName(i), 
                           ""CDATA"", 
                           dtm.getNodeValue(i));
      }
      
        
      this.m_contentHandler.startElement(ns,
                                         m_dtm.getLocalName(node),
                                         m_dtm.getNodeName(node),
                                         attrs);
      break;
    case DTM.PROCESSING_INSTRUCTION_NODE :
    {
      String name = m_dtm.getNodeName(node);

      
      if (name.equals(""xslt-next-is-raw""))
      {
        nextIsRaw = true;
      }
      else
      {
        this.m_contentHandler.processingInstruction(name,
                                                    m_dtm.getNodeValue(node));
      }
    }
    break;
    case DTM.CDATA_SECTION_NODE :
    {
      boolean isLexH = (m_contentHandler instanceof LexicalHandler);
      LexicalHandler lh = isLexH
                          ? ((LexicalHandler) this.m_contentHandler) : null;

      if (isLexH)
      {
        lh.startCDATA();
      }
      
      dispatachChars(node);

      {
        if (isLexH)
        {
          lh.endCDATA();
        }
      }
    }
    break;
    case DTM.TEXT_NODE :
    {
      if (nextIsRaw)
      {
        nextIsRaw = false;

        m_contentHandler.processingInstruction(javax.xml.transform.Result.PI_DISABLE_OUTPUT_ESCAPING, """");
        dispatachChars(node);
        m_contentHandler.processingInstruction(javax.xml.transform.Result.PI_ENABLE_OUTPUT_ESCAPING, """");
      }
      else
      {
        dispatachChars(node);
      }
    }
    break;
    case DTM.ENTITY_REFERENCE_NODE :
    {
      if (m_contentHandler instanceof LexicalHandler)
      {
        ((LexicalHandler) this.m_contentHandler).startEntity(
          m_dtm.getNodeName(node));
      }
      else
      {

        
      }
    }
    break;
    default :
    }
  }

  
  protected void endNode(int node) throws org.xml.sax.SAXException
  {

    switch (m_dtm.getNodeType(node))
    {
    case DTM.DOCUMENT_NODE :
      this.m_contentHandler.endDocument();
      break;
    case DTM.ELEMENT_NODE :
      String ns = m_dtm.getNamespaceURI(node);
      if(null == ns)
        ns = """";
      this.m_contentHandler.endElement(ns,
                                         m_dtm.getLocalName(node),
                                         m_dtm.getNodeName(node));

      for (int nsn = m_dtm.getFirstNamespaceNode(node, true); DTM.NULL != nsn;
           nsn = m_dtm.getNextNamespaceNode(node, nsn, true))
      {
        
        String prefix = m_dtm.getNodeNameX(nsn);

        this.m_contentHandler.endPrefixMapping(prefix);
      }
      break;
    case DTM.CDATA_SECTION_NODE :
      break;
    case DTM.ENTITY_REFERENCE_NODE :
    {
      if (m_contentHandler instanceof LexicalHandler)
      {
        LexicalHandler lh = ((LexicalHandler) this.m_contentHandler);

        lh.endEntity(m_dtm.getNodeName(node));
      }
    }
    break;
    default :
    }
  }
}  

"
org.apache.xalan.xsltc.dom.MultipleNodeCounter,4,2,1,6,19,0,1,6,4,0.333333333,162,1.0,1,0.823529412,0.5,1,4,39.25,11,3.25,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.util.IntegerArray;

public abstract class MultipleNodeCounter extends NodeCounter {
    private NodeIterator _precSiblings = null;

    public MultipleNodeCounter(Translet translet,
			       DOM document, NodeIterator iterator) {
	super(translet, document, iterator);
    }
	
    public NodeCounter setStartNode(int node) {
	_node = node;
	_nodeType = _document.getType(node);
	_precSiblings = _document.getAxisIterator(PRECEDINGSIBLING);
	return this;
    }

    public String getCounter() {
	if (_value != Integer.MIN_VALUE) {
	    return formatNumbers(_value);
	}

	IntegerArray ancestors = new IntegerArray();

	
	int next = _node;
	ancestors.add(next);		
	while ((next = _document.getParent(next)) > END && 
	       !matchesFrom(next)) {
	    ancestors.add(next);
	}

	
	final int nAncestors = ancestors.cardinality();
	final int[] counters = new int[nAncestors]; 
	for (int i = 0; i < nAncestors; i++) {
	    counters[i] = Integer.MIN_VALUE;
	}

	
	for (int j = 0, i = nAncestors - 1; i >= 0 ; i--, j++) {
	    final int counter = counters[j];
	    final int ancestor = ancestors.at(i);

	    if (matchesCount(ancestor)) {
		_precSiblings.setStartNode(ancestor);
		while ((next = _precSiblings.next()) != END) {
		    if (matchesCount(next)) {
			counters[j] = (counters[j] == Integer.MIN_VALUE) ? 1 
			    : counters[j] + 1;		
		    }
		}
		
		counters[j] = counters[j] == Integer.MIN_VALUE
		    ? 1 
		    : counters[j] + 1;	
	    }
	}
	return formatNumbers(counters);
    }

    public static NodeCounter getDefaultNodeCounter(Translet translet,
						    DOM document,
						    NodeIterator iterator) {
	return new DefaultMultipleNodeCounter(translet, document, iterator);
    }

    static class DefaultMultipleNodeCounter extends MultipleNodeCounter {
	public DefaultMultipleNodeCounter(Translet translet,
					  DOM document,
					  NodeIterator iterator) {
	    super(translet, document, iterator);
	}
    }
}
"
org.apache.xalan.transformer.ClonerToResultTree,2,1,0,6,24,1,4,4,2,1.0,118,1.0,2,0.0,0.583333333,0,0,57.0,1,0.5,0,"
package org.apache.xalan.transformer;

import org.apache.xalan.templates.Stylesheet;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.utils.XMLString;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;

import org.apache.xpath.XPathContext;
import org.apache.xalan.res.XSLTErrorResources;


public class ClonerToResultTree
{

  
  private ResultTreeHandler m_rth;

  
  private TransformerImpl m_transformer;

  
  public ClonerToResultTree(TransformerImpl transformer,
                            ResultTreeHandler rth)
  {
    m_rth = rth;
    m_transformer = transformer;
  }



















































































  
  
  public static void cloneToResultTree(int node, int nodeType, DTM dtm, 
                                             ResultTreeHandler rth,
                                             boolean shouldCloneAttributes)
    throws TransformerException
  {

    try
    {
      switch (nodeType)
      {
      case DTM.TEXT_NODE :
        dtm.dispatchCharactersEvents(node, rth, false);
        break;
      case DTM.DOCUMENT_FRAGMENT_NODE :
      case DTM.DOCUMENT_NODE :
        
        
        break;
      case DTM.ELEMENT_NODE :
        {
          
          
          String ns = dtm.getNamespaceURI(node);
          if (ns==null) ns="""";
          String localName = dtm.getLocalName(node);
          rth.startElement(ns, localName, dtm.getNodeNameX(node), null);
          
	  
	  
	  
          if (shouldCloneAttributes)
          {
            rth.addAttributes(node);
            rth.processNSDecls(node, nodeType, dtm);
          }
        }
        break;
      case DTM.CDATA_SECTION_NODE :
        rth.startCDATA();          
        dtm.dispatchCharactersEvents(node, rth, false);
        rth.endCDATA();
        break;
      case DTM.ATTRIBUTE_NODE :
        rth.addAttribute(node);
        break;
			case DTM.NAMESPACE_NODE:
				
				
				
				
  			rth.processNSDecls(node,DTM.NAMESPACE_NODE,dtm);
				break;
      case DTM.COMMENT_NODE :
        XMLString xstr = dtm.getStringValue (node);
        xstr.dispatchAsComment(rth);
        break;
      case DTM.ENTITY_REFERENCE_NODE :
        rth.entityReference(dtm.getNodeNameX(node));
        break;
      case DTM.PROCESSING_INSTRUCTION_NODE :
        {
          
          rth.processingInstruction(dtm.getNodeNameX(node), 
                                      dtm.getNodeValue(node));
        }
        break;
      default :
        
        throw new  TransformerException(
                         ""Can't clone node: ""+dtm.getNodeName(node));
      }
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
  }  
}
"
org.apache.xml.utils.PrefixResolverDefault,5,1,0,4,17,8,3,1,5,1.0,108,0.0,0,0.0,0.6,0,0,20.2,12,3.0,0,"
package org.apache.xml.utils;

import org.w3c.dom.Node;
import org.w3c.dom.NamedNodeMap;


public class PrefixResolverDefault implements PrefixResolver
{

  
  Node m_context;

  
  public static final String S_XMLNAMESPACEURI =
    ""http:

  
  public PrefixResolverDefault(Node xpathExpressionContext)
  {
    m_context = xpathExpressionContext;
  }

  
  public String getNamespaceForPrefix(String prefix)
  {
    return getNamespaceForPrefix(prefix, m_context);
  }

  
  public String getNamespaceForPrefix(String prefix,
                                      org.w3c.dom.Node namespaceContext)
  {

    Node parent = namespaceContext;
    String namespace = null;

    if (prefix.equals(""xml""))
    {
      namespace = S_XMLNAMESPACEURI;
    }
    else
    {
      int type;

      while ((null != parent) && (null == namespace)
             && (((type = parent.getNodeType()) == Node.ELEMENT_NODE)
                 || (type == Node.ENTITY_REFERENCE_NODE)))
      {
        if (type == Node.ELEMENT_NODE)
        {
          NamedNodeMap nnm = parent.getAttributes();

          for (int i = 0; i < nnm.getLength(); i++)
          {
            Node attr = nnm.item(i);
            String aname = attr.getNodeName();
            boolean isPrefix = aname.startsWith(""xmlns:"");

            if (isPrefix || aname.equals(""xmlns""))
            {
              int index = aname.indexOf(':');
              String p = isPrefix ? aname.substring(index + 1) : """";

              if (p.equals(prefix))
              {
                namespace = attr.getNodeValue();

                break;
              }
            }
          }
        }

        parent = parent.getParentNode();
      }
    }

    return namespace;
  }

  
  public String getBaseIdentifier()
  {
    return null;
  }
	
	public boolean handlesNullPrefixes() {
		return false;
	}

}
"
org.apache.xalan.xsltc.compiler.Step,18,4,0,41,70,21,6,38,14,0.588235294,900,1.0,0,0.811111111,0.238095238,2,9,48.77777778,20,4.0556,1,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xalan.xsltc.DOM;

final class Step extends RelativeLocationPath {

    
    private int _axis;

    
    private Vector _predicates;

    
    private boolean _hadPredicates = false;

    
    private int _nodeType;

    public Step(int axis, int nodeType, Vector predicates) {
	_axis = axis;
	_nodeType = nodeType;
	_predicates = predicates;
    }

    
    public void setParser(Parser parser) {
	super.setParser(parser);
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Predicate exp = (Predicate)_predicates.elementAt(i);
		exp.setParser(parser);
		exp.setParent(this);
	    }
	}
    }
    
    
    public int getAxis() {
	return _axis;
    }
	
    
    public void setAxis(int axis) {
	_axis = axis;
    }

    
    public int getNodeType() {
	return _nodeType;
    }

    
    public Vector getPredicates() {
	return _predicates;
    }

    
    public void addPredicates(Vector predicates) {
	if (_predicates == null)
	    _predicates = predicates;
	else
	    _predicates.addAll(predicates);
    }

    
    private boolean hasParentPattern() {
	final SyntaxTreeNode parent = getParent();
	return (parent instanceof ParentPattern ||
		parent instanceof ParentLocationPath ||
		parent instanceof UnionPathExpr ||
		parent instanceof FilterParentPath);
    }
    
    
    private boolean hasPredicates() {
	return _predicates != null && _predicates.size() > 0;
    }

    
    private boolean isPredicate() {
	SyntaxTreeNode parent = this;
	while (parent != null) {
	    parent = parent.getParent();
	    if (parent instanceof Predicate) return true;
	}
	return false;
    }

    
    public boolean isAbbreviatedDot() {
	return _nodeType == NodeTest.ANODE && _axis == Axis.SELF;
    }


    
    public boolean isAbbreviatedDDot() {
	return _nodeType == NodeTest.ANODE && _axis == Axis.PARENT;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	
	_hadPredicates = hasPredicates();

	
	if (isAbbreviatedDot()) {
	    _type =  (hasParentPattern()) ? Type.NodeSet : Type.Node;
	}
	else {
	    _type = Type.NodeSet;
	}

	
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Expression pred = (Expression)_predicates.elementAt(i);
		pred.typeCheck(stable);
	    }
	}

	
	return _type;
    }

    
    private boolean reverseNodeSet() {
	
	if ((_axis == Axis.ANCESTOR)  || (_axis == Axis.ANCESTORORSELF) ||
	    (_axis == Axis.PRECEDING) || (_axis == Axis.PRECEDINGSIBLING)) {

	    
	    
	    
	    
	    SyntaxTreeNode parent = this;
	    do {
		
		parent = parent.getParent();

		
		if (parent instanceof ApplyImports) return true;
		if (parent instanceof ApplyTemplates) return true;
		if (parent instanceof ForEach) return true;
		if (parent instanceof FilterParentPath) return true;
		if (parent instanceof FilterExpr) return true;
		if (parent instanceof WithParam) return true;
		if (parent instanceof ValueOf) return true;

	    } while (parent != null && parent instanceof Instruction == false);
	}
	return false;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (hasPredicates()) {
	    translatePredicates(classGen, methodGen);

	    
	    if (_predicates.size() == 0) {
		orderIterator(classGen, methodGen);
	    }
	}
	else {
	    
	    if ((_axis == Axis.ATTRIBUTE) &&
		(_nodeType != NodeTest.ATTRIBUTE) && (!hasParentPattern())) {
		int iter = cpg.addInterfaceMethodref(DOM_INTF,
						     ""getTypedAxisIterator"",
						     ""(II)""+NODE_ITERATOR_SIG);
		il.append(methodGen.loadDOM());
		il.append(new PUSH(cpg, Axis.ATTRIBUTE));
		il.append(new PUSH(cpg, _nodeType));
		il.append(new INVOKEINTERFACE(iter, 3));
		return;
	    }

	    
	    if (isAbbreviatedDot()) {
		if (_type == Type.Node) {
		    
		    il.append(methodGen.loadContextNode());
		}
		else {
		    
		    int init = cpg.addMethodref(SINGLETON_ITERATOR,
						""<init>"", ""(""+NODE_SIG+"")V"");
		    il.append(new NEW(cpg.addClass(SINGLETON_ITERATOR)));
		    il.append(DUP);
		    il.append(methodGen.loadContextNode());
		    il.append(new INVOKESPECIAL(init));
		}
		return;
	    }

	    
	    SyntaxTreeNode parent = getParent();
	    if ((parent instanceof ParentLocationPath) &&
		(parent.getParent() instanceof ParentLocationPath)) {
		if ((_nodeType == NodeTest.ELEMENT) && (!_hadPredicates)) {
		    _nodeType = NodeTest.ANODE;
		}
	    }

	    
	    switch (_nodeType) {
	    case NodeTest.ATTRIBUTE:
		_axis = Axis.ATTRIBUTE;
	    case NodeTest.ANODE:
		
		int git = cpg.addInterfaceMethodref(DOM_INTF,
						    ""getAxisIterator"",
						    ""(I)""+NODE_ITERATOR_SIG);
		il.append(methodGen.loadDOM());
		il.append(new PUSH(cpg, _axis));
		il.append(new INVOKEINTERFACE(git, 2));
		break;
	    default:
		final XSLTC xsltc = getParser().getXSLTC();
		final Vector ni = xsltc.getNamesIndex();
		String name = null;
		int star = 0;
		
		if (_nodeType >= DOM.NTYPES) {
		    name = (String)ni.elementAt(_nodeType-DOM.NTYPES);
		    star = name.lastIndexOf('*');
		}
		
		if (star > 1) {
		    final String namespace;
		    if (_axis == Axis.ATTRIBUTE)
			namespace = name.substring(0,star-2);
		    else
			namespace = name.substring(0,star-1);

		    final int nsType = xsltc.registerNamespace(namespace);
		    final int ns = cpg.addInterfaceMethodref(DOM_INTF,
						    ""getNamespaceAxisIterator"",
						    ""(II)""+NODE_ITERATOR_SIG);
		    il.append(methodGen.loadDOM());
		    il.append(new PUSH(cpg, _axis));
		    il.append(new PUSH(cpg, nsType));
		    il.append(new INVOKEINTERFACE(ns, 3));
		    break;
		}
	    case NodeTest.ELEMENT:
		
		final int ty = cpg.addInterfaceMethodref(DOM_INTF,
						""getTypedAxisIterator"",
						""(II)""+NODE_ITERATOR_SIG);
		
		il.append(methodGen.loadDOM());
		il.append(new PUSH(cpg, _axis));
		il.append(new PUSH(cpg, _nodeType));
		il.append(new INVOKEINTERFACE(ty, 3));

		break;
	    }

	    
	    if (!_hadPredicates) {
		orderIterator(classGen, methodGen);
	    }
	}
    }


    
    public void translatePredicates(ClassGenerator classGen,
				    MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	int idx = 0;

	if (_predicates.size() == 0) {
	    translate(classGen, methodGen);
	}
	else {
	    final Predicate predicate = (Predicate)_predicates.lastElement();
	    _predicates.remove(predicate);

	    
	    
	    
	    
	    
	    
	    
	    if (predicate.isNodeValueTest()) {
		Step step = predicate.getStep();

		il.append(methodGen.loadDOM());
		
		
		if (step.isAbbreviatedDot()) {
		    translate(classGen, methodGen);
		    il.append(new ICONST(DOM.RETURN_CURRENT));
		}
		
		
		else {
		    ParentLocationPath path = new ParentLocationPath(this,step);
		    try {
			path.typeCheck(getParser().getSymbolTable());
		    }
		    catch (TypeCheckError e) { }
		    path.translate(classGen, methodGen);
		    il.append(new ICONST(DOM.RETURN_PARENT));
		}
		predicate.translate(classGen, methodGen);
		idx = cpg.addInterfaceMethodref(DOM_INTF,
						GET_NODE_VALUE_ITERATOR,
						GET_NODE_VALUE_ITERATOR_SIG);
		il.append(new INVOKEINTERFACE(idx, 5));
	    }
	    
	    else if (predicate.isNthDescendant()) {
		il.append(methodGen.loadDOM());
		il.append(new ICONST(NodeTest.ELEMENT));
		predicate.translate(classGen, methodGen);
		il.append(new ICONST(0));
		idx = cpg.addInterfaceMethodref(DOM_INTF,
						""getNthDescendant"",
						""(IIZ)""+NODE_ITERATOR_SIG);
		il.append(new INVOKEINTERFACE(idx, 4));
	    }
	    
	    else if (predicate.isNthPositionFilter()) {
		idx = cpg.addMethodref(NTH_ITERATOR_CLASS,
				       ""<init>"",
				       ""(""+NODE_ITERATOR_SIG+""I)V"");
		il.append(new NEW(cpg.addClass(NTH_ITERATOR_CLASS)));
		il.append(DUP);
		translatePredicates(classGen, methodGen); 
		predicate.translate(classGen, methodGen);
		il.append(new INVOKESPECIAL(idx));
	    }
	    else {
		idx = cpg.addMethodref(CURRENT_NODE_LIST_ITERATOR,
				       ""<init>"",
				       ""(""
				       + NODE_ITERATOR_SIG
				       + CURRENT_NODE_LIST_FILTER_SIG
				       + NODE_SIG
				       + TRANSLET_SIG
				       + "")V"");
		
		il.append(new NEW(cpg.addClass(CURRENT_NODE_LIST_ITERATOR)));
		il.append(DUP);
		translatePredicates(classGen, methodGen); 
		predicate.translateFilter(classGen, methodGen);
		
		il.append(methodGen.loadCurrentNode());
		il.append(classGen.loadTranslet());
		if (classGen.isExternal()) {
		    final String className = classGen.getClassName();
		    il.append(new CHECKCAST(cpg.addClass(className)));
		}
		il.append(new INVOKESPECIAL(idx));
	    }
	}
    }


    
    public void orderIterator(ClassGenerator classGen,
			      MethodGenerator methodGen) {
	
	if (!reverseNodeSet()) return;

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int init = cpg.addMethodref(REVERSE_ITERATOR, ""<init>"",
					  ""(""+NODE_ITERATOR_SIG+"")V"");
	il.append(new NEW(cpg.addClass(REVERSE_ITERATOR)));
	il.append(DUP_X1);
	il.append(SWAP);
	il.append(new INVOKESPECIAL(init));
    }


    
    public String toString() {
	final StringBuffer buffer = new StringBuffer(""step("""");
	buffer.append(Axis.names[_axis]).append("""", "").append(_nodeType);
	if (_predicates != null) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Predicate pred = (Predicate)_predicates.elementAt(i);
		buffer.append("", "").append(pred.toString());
	    }
	}
	return buffer.append(')').toString();
    }
}
"
org.apache.xalan.xsltc.compiler.UnresolvedRef,7,4,0,17,22,0,0,17,5,0.625,153,1.0,4,0.926829268,0.30952381,2,4,20.28571429,6,1.7143,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class UnresolvedRef extends VariableRefBase {

    private QName           _variableName = null;
    private VariableRefBase _ref = null;
    private VariableBase    _var = null;
    private Stylesheet      _sheet = null;

    public UnresolvedRef(QName name) {
	super();
	_variableName = name;
	_sheet = getStylesheet();
    }

    public QName getName() {
	return(_variableName);
    }

    private ErrorMsg reportError() {
	ErrorMsg err = new ErrorMsg(ErrorMsg.VARIABLE_UNDEF_ERR,
				    _variableName, this);
	getParser().reportError(Constants.ERROR, err);
	return(err);
    }

    private VariableRefBase resolve(Parser parser, SymbolTable stable) {
	
	
	VariableBase ref = parser.lookupVariable(_variableName);
	if (ref == null) ref = (VariableBase)stable.lookupName(_variableName);
	if (ref == null) {
	    reportError();
	    return null;
	}
	
	
	
	if ((_var = findParentVariable()) != null) _var.addDependency(ref);

	
	if (ref instanceof Variable)
	    return(new VariableRef((Variable)ref));
	else if (ref instanceof Param)
	    return(new ParameterRef((Param)ref));
	else
	    return null;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (_ref != null) {
	    final String name = _variableName.toString();
	    ErrorMsg err = new ErrorMsg(ErrorMsg.CIRCULAR_VARIABLE_ERR,
					name, this);
	}
	if ((_ref = resolve(getParser(), stable)) != null) {
	    return (_type = _ref.typeCheck(stable));
	}
	throw new TypeCheckError(reportError());
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	if (_ref != null)
	    _ref.translate(classGen, methodGen);
	else
	    reportError();
    }

    public String toString() {
	return ""unresolved-ref()"";
    }

}
"
org.apache.xpath.operations.Lt,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class Lt extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.lessThan(right) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.transformer.TransformerImpl,123,2,0,106,355,6589,67,56,115,0.93969555,3260,0.714285714,18,0.097014925,0.057650273,1,2,25.16260163,5,1.3821,7,"
package org.apache.xalan.transformer;


import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.util.Enumeration;
import java.util.NoSuchElementException;
import java.util.Properties;
import java.util.Stack;
import java.util.StringTokenizer;
import java.util.Vector;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.OutputKeys;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.URIResolver;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.sax.SAXResult;
import javax.xml.transform.stream.StreamResult;
import org.apache.xalan.processor.TransformerFactoryImpl;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.serialize.Method;
import org.apache.xalan.serialize.Serializer;
import org.apache.xalan.serialize.SerializerFactory;
import org.apache.xalan.templates.AVT;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemAttributeSet;
import org.apache.xalan.templates.ElemForEach;
import org.apache.xalan.templates.ElemSort;
import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemTextLiteral;
import org.apache.xalan.templates.ElemVariable;
import org.apache.xalan.templates.OutputProperties;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetComposed;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.WhiteSpaceInfo;
import org.apache.xalan.templates.XUnresolvedVariable;
import org.apache.xalan.trace.TraceManager;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.DOMBuilder;
import org.apache.xml.utils.NodeVector;
import org.apache.xml.utils.ObjectPool;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.SAXSourceLocator;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xpath.Arg;
import org.apache.xpath.DOMHelper;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.w3c.dom.Document;
import org.w3c.dom.DocumentFragment;
import org.w3c.dom.Node;
import org.w3c.dom.Text;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;
import org.xml.sax.SAXParseException;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ext.LexicalHandler;


import org.apache.xpath.ExtensionsProvider;
import org.apache.xalan.extensions.ExtensionsTable;


public class TransformerImpl extends Transformer
        implements Runnable, DTMWSFilter, ExtensionsProvider
{

  
  

  
  private Boolean m_reentryGuard = new Boolean(true);

  
  private java.io.FileOutputStream m_outputStream = null;

  
  private boolean m_parserEventsOnMain = true;

  
  private Thread m_transformThread;

  
  private String m_urlOfSource = null;

  
  private Result m_outputTarget = null;

  
  private OutputProperties m_outputFormat;

  
  private Serializer m_serializer;

  
  ContentHandler m_inputContentHandler;

  
  private ContentHandler m_outputContentHandler = null;

  
  
  
  
  
  

  
  DocumentBuilder m_docBuilder = null;

  
  private ObjectPool m_textResultHandlerObjectPool =
    new ObjectPool(""org.apache.xalan.transformer.ResultTreeHandler"");

  
  private ObjectPool m_stringWriterObjectPool =
    new ObjectPool(""java.io.StringWriter"");

  
  private OutputProperties m_textformat = new OutputProperties(Method.Text);

  
  
  
  
  
  
  
  
  
  
  

  
  ElemTemplateElement[] m_currentTemplateElements 
      = new ElemTemplateElement[XPathContext.RECURSIONLIMIT];
  
  
  int m_currentTemplateElementsTop = 0;

  
  Stack m_currentMatchTemplates = new Stack();

  
  NodeVector m_currentMatchedNodes = new NodeVector();

  
  private StylesheetRoot m_stylesheetRoot = null;

  
  private boolean m_quietConflictWarnings = true;

  
  private XPathContext m_xcontext;

  
  private StackGuard m_stackGuard;

  
  private ResultTreeHandler m_resultTreeHandler;

  
  private KeyManager m_keyManager = new KeyManager();

  
  Stack m_attrSetStack = null;

  
  CountersTable m_countersTable = null;

  
  BoolStack m_currentTemplateRuleIsNull = new BoolStack();

  
  private MsgMgr m_msgMgr;

  
  public static boolean S_DEBUG = false;

  
  private ErrorListener m_errorHandler =
    new org.apache.xml.utils.DefaultErrorHandler();

  
  private TraceManager m_traceManager = new TraceManager(this);

  
  private Exception m_exceptionThrown = null;

  
  private Source m_xmlSource;

  
  private int m_doc;

  
  private boolean m_isTransformDone = false;

  
  private boolean m_hasBeenReset = false;

  
  private boolean m_shouldReset = true;

  
  public void setShouldReset(boolean shouldReset)
  {
    m_shouldReset = shouldReset;
  }

  
  private Stack m_modes = new Stack();

  
  
  

  
  public TransformerImpl(StylesheetRoot stylesheet)
   
  {
    setStylesheet(stylesheet);
    setXPathContext(new XPathContext(this));
    getXPathContext().setNamespaceContext(stylesheet);
    m_stackGuard = new StackGuard(this);
  }
  
  

  
  private ExtensionsTable m_extensionsTable = null;

  
  public ExtensionsTable getExtensionsTable()
  {
    return m_extensionsTable;
  }

  
  void setExtensionsTable(StylesheetRoot sroot)
       throws javax.xml.transform.TransformerException
  {
    try
    {
      if (sroot.getExtensions() != null)
        m_extensionsTable = new ExtensionsTable(sroot);
    }
    catch (javax.xml.transform.TransformerException te)
    {te.printStackTrace();}
  }
  
  
  
  public boolean functionAvailable(String ns, String funcName)
          throws javax.xml.transform.TransformerException
  {
    return getExtensionsTable().functionAvailable(ns, funcName);
  }
  
  public boolean elementAvailable(String ns, String elemName)
          throws javax.xml.transform.TransformerException
  {
    return getExtensionsTable().elementAvailable(ns, elemName);   
  }
   
  public Object extFunction(String ns, String funcName, 
                            Vector argVec, Object methodKey)
            throws javax.xml.transform.TransformerException
  {
    return getExtensionsTable().extFunction(ns, funcName, 
                                        argVec, methodKey,
                                        getXPathContext().getExpressionContext());   
  }
  
  

  
  public void reset()
  {

    if (!m_hasBeenReset && m_shouldReset)
    {
      m_hasBeenReset = true;

      if (this.m_outputStream != null)
      {
        try
        {
          m_outputStream.close();
        }
        catch (java.io.IOException ioe){}
      }

      m_outputStream = null;

      
      
      m_countersTable = null;

      m_xcontext.reset();
      
      m_xcontext.getVarStack().reset();
      resetUserParameters();
      

      int n = m_currentTemplateElements.length;
      for (int i = 0; i < n; i++) 
      {
        m_currentTemplateElements[i] = null;
      }
      m_currentTemplateElementsTop = 0;
      
      m_currentMatchTemplates.removeAllElements();
      m_currentMatchedNodes.removeAllElements();
      
      m_resultTreeHandler = null;
      m_outputTarget = null;
      m_keyManager = new KeyManager();
      m_attrSetStack = null;
      m_countersTable = null;
      m_currentTemplateRuleIsNull = new BoolStack();
      m_xmlSource = null;
      m_doc = DTM.NULL;
      m_isTransformDone = false;
      m_transformThread = null;

      
      
      m_xcontext.getSourceTreeManager().reset();
    }

    
  }

  
  public boolean getProperty(String property)
  {
    return false;
  }

  
  public void setProperty(String property, Object value)
  {
  }

  

  
  public boolean isParserEventsOnMain()
  {
    return m_parserEventsOnMain;
  }

  
  public Thread getTransformThread()
  {
    return m_transformThread;
  }

  
  public void setTransformThread(Thread t)
  {
    m_transformThread = t;
  }

  
  private boolean m_hasTransformThreadErrorCatcher = false;

  
  public boolean hasTransformThreadErrorCatcher()
  {
    return m_hasTransformThreadErrorCatcher;
  }
        
        
  public void transform(Source source) throws TransformerException
  {
                transform(source, true); 
        }

  
  public void transform(Source source, boolean shouldRelease) throws TransformerException
  {

    try
    {
      String base = source.getSystemId();
      
      
      if(null == base)
      {
        base = m_stylesheetRoot.getBaseIdentifier();
      }

      
      if(null == base)
      {
        String currentDir = """";
        try {
          currentDir = System.getProperty(""user.dir"");
        }
        catch (SecurityException se) {}
              
        if (currentDir.startsWith(java.io.File.separator))
          base = ""file:
        else
          base = ""file:
        
        base = base + java.io.File.separatorChar
               + source.getClass().getName();
      }
      setBaseURLOfSource(base);
      DTMManager mgr = m_xcontext.getDTMManager();
      DTM dtm = mgr.getDTM(source, false, this, true, true);
      dtm.setDocumentBaseURI(base);
      
      boolean hardDelete = true;  

      try
      {
      	
      	
      	
        this.transformNode(dtm.getDocument());
      }
      finally
      {
        if (shouldRelease)
          mgr.release(dtm, hardDelete);
      }

      
      
      
      
      
      Exception e = getExceptionThrown();

      if (null != e)
      {
        if (e instanceof javax.xml.transform.TransformerException)
        {
          throw (javax.xml.transform.TransformerException) e;
        }
        else if (e instanceof org.apache.xml.utils.WrappedRuntimeException)
        {
          fatalError(
              ((org.apache.xml.utils.WrappedRuntimeException) e).getException());
        }
        else
        {
          throw new javax.xml.transform.TransformerException(e);
        }
      }
      else if (null != m_resultTreeHandler)
      {
        m_resultTreeHandler.endDocument();
      }
    }
    catch (org.apache.xml.utils.WrappedRuntimeException wre)
    {
      Throwable throwable = wre.getException();

      while (throwable
             instanceof org.apache.xml.utils.WrappedRuntimeException)
      {
        throwable =
          ((org.apache.xml.utils.WrappedRuntimeException) throwable).getException();
      }

      fatalError(throwable);
    }

    
    catch (org.xml.sax.SAXParseException spe)
    {
      fatalError(spe);
    }
    catch (org.xml.sax.SAXException se)
    {
      m_errorHandler.fatalError(new TransformerException(se));
    }
    finally
    {
      m_hasTransformThreadErrorCatcher = false;

      
      reset();
    }
  }
  
  private void fatalError(Throwable throwable) throws TransformerException
  {
    if (throwable instanceof org.xml.sax.SAXParseException)
      m_errorHandler.fatalError(new TransformerException(throwable.getMessage(),new SAXSourceLocator((org.xml.sax.SAXParseException)throwable)));
    else
      m_errorHandler.fatalError(new TransformerException(throwable));
    
  }

  
  public String getBaseURLOfSource()
  {
    return m_urlOfSource;
  }

  
  public void setBaseURLOfSource(String base)
  {
    m_urlOfSource = base;
  }

  
  public Result getOutputTarget()
  {
    return m_outputTarget;
  }

  
  public void setOutputTarget(Result outputTarget)
  {
    m_outputTarget = outputTarget;
  }

  
  public String getOutputProperty(String qnameString)
          throws IllegalArgumentException
  {

    String value = null;
    OutputProperties props = getOutputFormat();

    value = props.getProperty(qnameString);

    if (null == value)
    {
      if (!props.isLegalPropertyKey(qnameString))
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{qnameString})); 
                                           
    }

    return value;
  }

  
  public String getOutputPropertyNoDefault(String qnameString)
          throws IllegalArgumentException
  {

    String value = null;
    OutputProperties props = getOutputFormat();

    value = (String) props.getProperties().get(qnameString);

    if (null == value)
    {
      if (!props.isLegalPropertyKey(qnameString))
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{qnameString})); 
                                          
    }

    return value;
  }

  
  public void setOutputProperty(String name, String value)
          throws IllegalArgumentException
  {

    synchronized (m_reentryGuard)
    {

      
      
      if (null == m_outputFormat)
      {
        m_outputFormat =
          (OutputProperties) getStylesheet().getOutputComposed().clone();
      }

      if (!m_outputFormat.isLegalPropertyKey(name))
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_OUTPUT_PROPERTY_NOT_RECOGNIZED, new Object[]{name})); 
                                           

      m_outputFormat.setProperty(name, value);
    }
  }

  
  public void setOutputProperties(Properties oformat)
  {

    synchronized (m_reentryGuard)
    {
      if (null != oformat)
      {

        
        String method = (String) oformat.get(OutputKeys.METHOD);

        if (null != method)
          m_outputFormat = new OutputProperties(method);
        else if(m_outputFormat==null)
          m_outputFormat = new OutputProperties();
      }

      if (null != oformat)
      {
        m_outputFormat.copyFrom(oformat);
      }

      
      
      
      m_outputFormat.copyFrom(m_stylesheetRoot.getOutputProperties());
    }
  }

  
  public Properties getOutputProperties()
  {
    return (Properties) getOutputFormat().getProperties().clone();
  }

  
  public ContentHandler createResultContentHandler(Result outputTarget)
          throws TransformerException
  {
    return createResultContentHandler(outputTarget, getOutputFormat());
  }

  
  public ContentHandler createResultContentHandler(
          Result outputTarget, OutputProperties format)
            throws TransformerException
  {

    ContentHandler handler = null;

    
    
    org.w3c.dom.Node outputNode = null;

    if (outputTarget instanceof DOMResult)
    {
      outputNode = ((DOMResult) outputTarget).getNode();

      org.w3c.dom.Document doc;
      short type;

      if (null != outputNode)
      {
        type = outputNode.getNodeType();
        doc = (org.w3c.dom.Node.DOCUMENT_NODE == type)
              ? (org.w3c.dom.Document) outputNode
              : outputNode.getOwnerDocument();
      }
      else
      {
        doc = org.apache.xpath.DOMHelper.createDocument();
        outputNode = doc;
        type = outputNode.getNodeType();

        ((DOMResult) outputTarget).setNode(outputNode);
      }

      handler =
        (org.w3c.dom.Node.DOCUMENT_FRAGMENT_NODE == type)
        ? new DOMBuilder(doc, (org.w3c.dom.DocumentFragment) outputNode)
        : new DOMBuilder(doc, outputNode);
    }
    else if (outputTarget instanceof SAXResult)
    {
      handler = ((SAXResult) outputTarget).getHandler();

      if (null == handler)
        throw new IllegalArgumentException(
          ""handler can not be null for a SAXResult"");
    }

    
    
    else if (outputTarget instanceof StreamResult)
    {
      StreamResult sresult = (StreamResult) outputTarget;
      String method = format.getProperty(OutputKeys.METHOD);

      try
      {
        Serializer serializer =
          SerializerFactory.getSerializer(format.getProperties());

        if (null != sresult.getWriter())
          serializer.setWriter(sresult.getWriter());
        else if (null != sresult.getOutputStream())
          serializer.setOutputStream(sresult.getOutputStream());
        else if (null != sresult.getSystemId())
        {
          String fileURL = sresult.getSystemId();

          if (fileURL.startsWith(""file:
          {
            if (fileURL.substring(8).indexOf("":"") >0)
              fileURL = fileURL.substring(8);
            else 
              fileURL = fileURL.substring(7);
          }

          m_outputStream = new java.io.FileOutputStream(fileURL);

          serializer.setOutputStream(m_outputStream);
        }
        else
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_OUTPUT_SPECIFIED, null)); 

        handler = serializer.asContentHandler();

        this.setSerializer(serializer);
      }
      catch (UnsupportedEncodingException uee)
      {
        throw new TransformerException(uee);
      }
      catch (IOException ioe)
      {
        throw new TransformerException(ioe);
      }
    }
    else
    {
      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_TRANSFORM_TO_RESULT_TYPE, new Object[]{outputTarget.getClass().getName()})); 
                                     
                                     
    }

    return handler;
  }
        
        
  public void transform(Source xmlSource, Result outputTarget)
          throws TransformerException
  {
                transform(xmlSource, outputTarget, true);
        }

  
  public void transform(Source xmlSource, Result outputTarget, boolean shouldRelease)
          throws TransformerException
  {

    synchronized (m_reentryGuard)
    {
      ContentHandler handler = createResultContentHandler(outputTarget);

      m_outputTarget = outputTarget;

      this.setContentHandler(handler);
      transform(xmlSource, shouldRelease);
    }
  }

  
  public void transformNode(int node, Result outputTarget)
          throws TransformerException
  {
    

    ContentHandler handler = createResultContentHandler(outputTarget);

    m_outputTarget = outputTarget;

    this.setContentHandler(handler);
    transformNode(node);
  }

  
  public void transformNode(int node) throws TransformerException
  {
    
    setExtensionsTable(getStylesheet());
    
    synchronized (m_outputContentHandler)
    {
      m_hasBeenReset = false;
      
      XPathContext xctxt = getXPathContext();
      DTM dtm = xctxt.getDTM(node);

      try
      {
        pushGlobalVars(node);

        
        
        
        StylesheetRoot stylesheet = this.getStylesheet();
        int n = stylesheet.getGlobalImportCount();

        for (int i = 0; i < n; i++)
        {
          StylesheetComposed imported = stylesheet.getGlobalImport(i);
          int includedCount = imported.getIncludeCountComposed();

          for (int j = -1; j < includedCount; j++)
          {
            Stylesheet included = imported.getIncludeComposed(j);

            included.runtimeInit(this);

            for (ElemTemplateElement child = included.getFirstChildElem();
                    child != null; child = child.getNextSiblingElem())
            {
              child.runtimeInit(this);
            }
          }
        }
        
        
        DTMIterator dtmIter = new org.apache.xpath.axes.SelfIteratorNoPredicate();
        dtmIter.setRoot(node, xctxt);
        xctxt.pushContextNodeList(dtmIter);
        try
        {
          this.applyTemplateToNode(null, null, node);
        }
        finally
        {
          xctxt.popContextNodeList();
        }
        

        
        if (null != m_resultTreeHandler)
        {
          m_resultTreeHandler.endDocument();
        }
      }
      catch (Exception se)
      {

        
        
        
        
        
        
        
        while(se instanceof org.apache.xml.utils.WrappedRuntimeException)
        {
          Exception e = ((org.apache.xml.utils.WrappedRuntimeException)se).getException();
          if(null != e)
            se = e;
        }
        
        if (null != m_resultTreeHandler)
        {
          try
          {
            if(se instanceof org.xml.sax.SAXParseException)
              m_resultTreeHandler.fatalError((org.xml.sax.SAXParseException)se);
            else if(se instanceof TransformerException)
            {
              TransformerException te = ((TransformerException)se);
              SAXSourceLocator sl = new SAXSourceLocator( te.getLocator() );
              m_resultTreeHandler.fatalError(new org.xml.sax.SAXParseException(te.getMessage(), sl, te)); 
            }
            else
            {
              m_resultTreeHandler.fatalError(new org.xml.sax.SAXParseException(se.getMessage(), new SAXSourceLocator(), se)); 
            }             
          }
          catch (Exception e){}
        }        
        
        if(se instanceof TransformerException)
        {
          m_errorHandler.fatalError((TransformerException)se);
        }
        else if(se instanceof org.xml.sax.SAXParseException)
        {
          m_errorHandler.fatalError(new TransformerException(se.getMessage(), 
                      new SAXSourceLocator((org.xml.sax.SAXParseException)se), 
                      se));
        }
        else
        {
          m_errorHandler.fatalError(new TransformerException(se));
        }
        
      }
      finally
      {
        this.reset();
      }
    }
  }

  
  public ContentHandler getInputContentHandler()
  {
    return getInputContentHandler(false);
  }

  
  public ContentHandler getInputContentHandler(boolean doDocFrag)
  {

    if (null == m_inputContentHandler)
    {

      
      
      m_inputContentHandler = new TransformerHandlerImpl(this, doDocFrag,
              m_urlOfSource);
    }

    return m_inputContentHandler;
  }

  
  public DeclHandler getInputDeclHandler()
  {

    if (m_inputContentHandler instanceof DeclHandler)
      return (DeclHandler) m_inputContentHandler;
    else
      return null;
  }

  
  public LexicalHandler getInputLexicalHandler()
  {

    if (m_inputContentHandler instanceof LexicalHandler)
      return (LexicalHandler) m_inputContentHandler;
    else
      return null;
  }

  
  public void setOutputFormat(OutputProperties oformat)
  {
    m_outputFormat = oformat;
  }

  
  public OutputProperties getOutputFormat()
  {

    
    
    OutputProperties format = (null == m_outputFormat)
                              ? getStylesheet().getOutputComposed()
                              : m_outputFormat;

    return format;
  }

  
  public Serializer getSerializer()
  {
    return m_serializer;
  }

  
  public void setSerializer(Serializer s)
  {
    m_serializer = s;
  }
  
  
  public void setParameter(String name, String namespace, Object value)
  {

    VariableStack varstack = getXPathContext().getVarStack();
    QName qname = new QName(namespace, name);
    XObject xobject = XObject.create(value, getXPathContext());
    
    StylesheetRoot sroot = m_stylesheetRoot;
    Vector vars = sroot.getVariablesAndParamsComposed();
    int i = vars.size();
    while (--i >= 0)
    {
      ElemVariable variable = (ElemVariable)vars.elementAt(i);
      if(variable.getXSLToken() == Constants.ELEMNAME_PARAMVARIABLE && 
         variable.getName().equals(qname))
      {
          varstack.setGlobalVariable(i, xobject);
      }
    }
  }

  
  Vector m_userParams;

  
  public void setParameter(String name, Object value)
  {

    StringTokenizer tokenizer = new StringTokenizer(name, ""{}"", false);

    try
    {

      
      
      String s1 = tokenizer.nextToken();
      String s2 = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;

      if (null == m_userParams)
        m_userParams = new Vector();

      if (null == s2)
      {
        replaceOrPushUserParam(new QName(s1), XObject.create(value, getXPathContext()));
        setParameter(s1, null, value);
      }
      else
      {
        replaceOrPushUserParam(new QName(s1, s2), XObject.create(value, getXPathContext()));
        setParameter(s2, s1, value);
      }
    }
    catch (java.util.NoSuchElementException nsee)
    {

      
    }
  }

  
  private void replaceOrPushUserParam(QName qname, XObject xval)
  {

    int n = m_userParams.size();

    for (int i = n - 1; i >= 0; i--)
    {
      Arg arg = (Arg) m_userParams.elementAt(i);

      if (arg.getQName().equals(qname))
      {
        m_userParams.setElementAt(new Arg(qname, xval, true), i);

        return;
      }
    }

    m_userParams.addElement(new Arg(qname, xval, true));
  }

  
  public Object getParameter(String name)
  {

    try
    {

      
      
      
      QName qname = QName.getQNameFromString(name);

      if (null == m_userParams)
        return null;

      int n = m_userParams.size();

      for (int i = n - 1; i >= 0; i--)
      {
        Arg arg = (Arg) m_userParams.elementAt(i);

        if (arg.getQName().equals(qname))
        {
          return arg.getVal().object();
        }
      }

      return null;
    }
    catch (java.util.NoSuchElementException nsee)
    {

      
      return null;
    }
  }
  
  
  private void resetUserParameters()
  {

    try
    {
      
      if (null == m_userParams)
        return;

      int n = m_userParams.size();
      for (int i = n - 1; i >= 0; i--)
      {
        Arg arg = (Arg) m_userParams.elementAt(i);
        QName name = arg.getQName();
        
        
        String s1 = name.getNamespace();
        String s2 = name.getLocalPart();

        setParameter(s2, s1, arg.getVal().object());
        
      }
      
    }
    catch (java.util.NoSuchElementException nsee)
    {
      
      
    }
  }

  
  public void setParameters(Properties params)
  {

    clearParameters();

    Enumeration names = params.propertyNames();

    while (names.hasMoreElements())
    {
      String name = params.getProperty((String) names.nextElement());
      StringTokenizer tokenizer = new StringTokenizer(name, ""{}"", false);

      try
      {

        
        
        String s1 = tokenizer.nextToken();
        String s2 = tokenizer.hasMoreTokens() ? tokenizer.nextToken() : null;

        if (null == s2)
          setParameter(s1, null, params.getProperty(name));
        else
          setParameter(s2, s1, params.getProperty(name));
      }
      catch (java.util.NoSuchElementException nsee)
      {

        
      }
    }
  }

  
  public void clearParameters()
  {

    synchronized (m_reentryGuard)
    {
      VariableStack varstack = new VariableStack();

      m_xcontext.setVarStack(varstack);

      m_userParams = null;
    }
  }


  
  protected void pushGlobalVars(int contextNode) throws TransformerException
  {

    XPathContext xctxt = m_xcontext;
    VariableStack vs = xctxt.getVarStack();
    StylesheetRoot sr = getStylesheet();
    Vector vars = sr.getVariablesAndParamsComposed();
    
    int i = vars.size();
    vs.link(i);

    while (--i >= 0)
    {
      ElemVariable v = (ElemVariable) vars.elementAt(i);

      
      XObject xobj = new XUnresolvedVariable(v, contextNode, this,
                                     vs.getStackFrame(), 0, true);
      
      if(null == vs.elementAt(i))                               
        vs.setGlobalVariable(i, xobj);
    }

  }

  
  public void setURIResolver(URIResolver resolver)
  {

    synchronized (m_reentryGuard)
    {
      m_xcontext.getSourceTreeManager().setURIResolver(resolver);
    }
  }

  
  public URIResolver getURIResolver()
  {
    return m_xcontext.getSourceTreeManager().getURIResolver();
  }

  

  
  public void setContentHandler(ContentHandler handler)
  {

    if (handler == null)
    {
      throw new NullPointerException(XSLMessages.createMessage(XSLTErrorResources.ER_NULL_CONTENT_HANDLER, null)); 
    }
    else
    {
      m_outputContentHandler = handler;

      if (null == m_resultTreeHandler)
        m_resultTreeHandler = new ResultTreeHandler(this, handler);
      else
        m_resultTreeHandler.setContentHandler(handler);
    }
  }

  
  public ContentHandler getContentHandler()
  {
    return m_outputContentHandler;
  }

  
  public int transformToRTF(ElemTemplateElement templateParent)
          throws TransformerException
  {
    
    
    DTM dtmFrag = m_xcontext.getRTFDTM();
    return transformToRTF(templateParent,dtmFrag);
  }
  
  
  public int transformToGlobalRTF(ElemTemplateElement templateParent)
          throws TransformerException
  {
    
    
    DTM dtmFrag = m_xcontext.getGlobalRTFDTM();
    return transformToRTF(templateParent,dtmFrag);
  }
  
  
  private int transformToRTF(ElemTemplateElement templateParent,DTM dtmFrag)
          throws TransformerException
  {

    XPathContext xctxt = m_xcontext;
    
    ContentHandler rtfHandler = dtmFrag.getContentHandler();

    
    
    
    
    int resultFragment; 

    
    ResultTreeHandler savedRTreeHandler = this.m_resultTreeHandler;

    
    m_resultTreeHandler = new ResultTreeHandler(this, rtfHandler);

    ResultTreeHandler rth = m_resultTreeHandler;

    try
    {
      rth.startDocument();
      
      
      
      
      rth.flushPending(); 
 
      try
      {

        
        executeChildTemplates(templateParent, true);

        
        rth.flushPending();
        
        
        
        
        
	resultFragment = dtmFrag.getDocument();      
      }
      finally
      {
        rth.endDocument();
      }
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {

      
      this.m_resultTreeHandler = savedRTreeHandler;
    }

    return resultFragment;
  }

  
  public ObjectPool getStringWriterPool()
  {
    return m_stringWriterObjectPool;
  }

  
  public String transformToString(ElemTemplateElement elem)
          throws TransformerException
  {
    ElemTemplateElement firstChild = elem.getFirstChildElem();
    if(null == firstChild)
      return """";
    if(elem.hasTextLitOnly() && org.apache.xalan.processor.TransformerFactoryImpl.m_optimize)
    {
      return ((ElemTextLiteral)firstChild).getNodeValue();
    }

    
    ResultTreeHandler savedRTreeHandler = this.m_resultTreeHandler;

    
    
    StringWriter sw = (StringWriter) m_stringWriterObjectPool.getInstance();

    m_resultTreeHandler =
      (ResultTreeHandler) m_textResultHandlerObjectPool.getInstance();

    Serializer serializer = m_resultTreeHandler.getSerializer();

    try
    {
      if (null == serializer)
      {
        serializer =
          SerializerFactory.getSerializer(m_textformat.getProperties());

        m_resultTreeHandler.setSerializer(serializer);
        serializer.setWriter(sw);

        ContentHandler shandler = serializer.asContentHandler();

        m_resultTreeHandler.init(this, shandler);
      }
      else
      {

        
        
        
        
        
      }
    }
    catch (IOException ioe)
    {
      throw new TransformerException(ioe);
    }

    String result;

    try
    {
      this.m_resultTreeHandler.startDocument();

      
      executeChildTemplates(elem, true);
      this.m_resultTreeHandler.endDocument();

      result = sw.toString();
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      sw.getBuffer().setLength(0);

      try
      {
        sw.close();
      }
      catch (Exception ioe){}

      m_stringWriterObjectPool.freeInstance(sw);
      m_textResultHandlerObjectPool.freeInstance(m_resultTreeHandler);
      m_resultTreeHandler.reset();

      
      m_resultTreeHandler = savedRTreeHandler;
    }

    return result;
  }

  
  public boolean applyTemplateToNode(ElemTemplateElement xslInstruction,  
                                     ElemTemplate template, int child)
                                             throws TransformerException
  {

    DTM dtm = m_xcontext.getDTM(child);
    short nodeType = dtm.getNodeType(child);
    boolean isDefaultTextRule = false;

    if (null == template)
    {
      int maxImportLevel, endImportLevel=0;
      boolean isApplyImports = ((xslInstruction == null)
                                ? false
                                : xslInstruction.getXSLToken()
                                  == Constants.ELEMNAME_APPLY_IMPORTS);

      if (isApplyImports)
      {
        maxImportLevel =
          xslInstruction.getStylesheetComposed().getImportCountComposed() - 1;
        endImportLevel =
          xslInstruction.getStylesheetComposed().getEndImportCountComposed();
      }
      else
      {
        maxImportLevel = -1;
      }

      
      
      
      
      
      
      if (isApplyImports && (maxImportLevel == -1))
      {
        template = null;
      }
      else
      {

        
        
        XPathContext xctxt = m_xcontext;

        try
        {
          xctxt.pushNamespaceContext(xslInstruction);

          QName mode = this.getMode();
          
          if (isApplyImports)
            template = m_stylesheetRoot.getTemplateComposed(xctxt, child, mode,
                  maxImportLevel, endImportLevel, m_quietConflictWarnings, dtm);
          else
            template = m_stylesheetRoot.getTemplateComposed(xctxt, child, mode,
                  m_quietConflictWarnings, dtm);
          
        }
        finally
        {
          xctxt.popNamespaceContext();
        }
      }

      
      
      if (null == template)
      {
        switch (nodeType)
        {
        case DTM.DOCUMENT_FRAGMENT_NODE :
        case DTM.ELEMENT_NODE :
          template = m_stylesheetRoot.getDefaultRule();
          break;
        case DTM.CDATA_SECTION_NODE :
        case DTM.TEXT_NODE :
        case DTM.ATTRIBUTE_NODE :
          template = m_stylesheetRoot.getDefaultTextRule();
          isDefaultTextRule = true;
          break;
        case DTM.DOCUMENT_NODE :
          template = m_stylesheetRoot.getDefaultRootRule();
          break;
        default :

          
          return false;
        }
      }
    }

    
    
    try
    {
      pushElemTemplateElement(template);
      m_xcontext.pushCurrentNode(child);
      pushPairCurrentMatched(template, child);
      
      
      DTMIterator cnl = new org.apache.xpath.NodeSetDTM(child, m_xcontext.getDTMManager());
      m_xcontext.pushContextNodeList(cnl);

      if (isDefaultTextRule)
      {
        switch (nodeType)
        {
        case DTM.CDATA_SECTION_NODE :
        case DTM.TEXT_NODE :
          ClonerToResultTree.cloneToResultTree(child, nodeType, 
                                        dtm, getResultTreeHandler(), false);
          break;
        case DTM.ATTRIBUTE_NODE :
          dtm.dispatchCharactersEvents(child, getResultTreeHandler(), false);
          break;
        }
      }
      else
      {

        
         
        if (TransformerImpl.S_DEBUG)
          getTraceManager().fireTraceEvent(template);
        
        
        
        
        
        
        
        
        
        m_xcontext.setSAXLocator(template);
        
        m_xcontext.getVarStack().link(template.m_frameSize);
        executeChildTemplates(template, true);
        
        if (TransformerImpl.S_DEBUG)
          getTraceManager().fireTraceEndEvent(template);
      }
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      m_xcontext.getVarStack().unlink();
      m_xcontext.popCurrentNode();
      m_xcontext.popContextNodeList();
      popCurrentMatched();
      popElemTemplateElement();
    }

    return true;
  }
  
  
  
  public void executeChildTemplates(
          ElemTemplateElement elem, org.w3c.dom.Node context, QName mode, ContentHandler handler)
            throws TransformerException
  {

    XPathContext xctxt = m_xcontext;

    try
    {
      if(null != mode)
        pushMode(mode);
      xctxt.pushCurrentNode(xctxt.getDTMHandleFromNode(context));
      executeChildTemplates(elem, handler);
    }
    finally
    {
      xctxt.popCurrentNode();
      
      
      
      if (null != mode)
        popMode();
    }
  }

  
  public void executeChildTemplates(
          ElemTemplateElement elem, ContentHandler handler)
            throws TransformerException
  {

    ResultTreeHandler rth = this.getResultTreeHandler();

    
    
    
    ContentHandler savedRTHHandler = rth.getContentHandler();
    ContentHandler savedHandler = this.getContentHandler();

    try
    {
      getResultTreeHandler().flushPending();
      this.setContentHandler(handler);

      
      executeChildTemplates(elem, true);
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    finally
    {
      this.setContentHandler(savedHandler);

      
      
      rth.setContentHandler(savedRTHHandler);
    }
  }

  
  public void executeChildTemplates(
          ElemTemplateElement elem, boolean shouldAddAttrs)
            throws TransformerException
  {

    
    ElemTemplateElement t = elem.getFirstChildElem();

    if (null == t)
      return;      
    
    if(elem.hasTextLitOnly() && org.apache.xalan.processor.TransformerFactoryImpl.m_optimize)
    {      
      char[] chars = ((ElemTextLiteral)t).getChars();
      try
      {
        
        this.pushElemTemplateElement(t);
        m_resultTreeHandler.characters(chars, 0, chars.length);
      }
      catch(SAXException se)
      {
        throw new TransformerException(se);
      }
      finally
      {
        this.popElemTemplateElement();
      }
      return;
    }







    XPathContext xctxt = m_xcontext;
    xctxt.pushSAXLocatorNull();
    int currentTemplateElementsTop = m_currentTemplateElementsTop;
    m_currentTemplateElementsTop++;

    try
    {
      
      
      for (; t != null; t = t.getNextSiblingElem())
      {
        if (!shouldAddAttrs
                && t.getXSLToken() == Constants.ELEMNAME_ATTRIBUTE)
          continue;

        xctxt.setSAXLocator(t);
        m_currentTemplateElements[currentTemplateElementsTop] = t;
        t.execute(this);
      }
    }
    catch(RuntimeException re)
    {
    	TransformerException te = new TransformerException(re);
    	te.setLocator(t);
    	throw te;
    }
    finally
    {
      m_currentTemplateElementsTop--;
      xctxt.popSAXLocator();
    }

    


  }

  
  public Vector processSortKeys(ElemForEach foreach, int sourceNodeContext)
          throws TransformerException
  {

    Vector keys = null;
    XPathContext xctxt = m_xcontext;
    int nElems = foreach.getSortElemCount();

    if (nElems > 0)
      keys = new Vector();

    
    for (int i = 0; i < nElems; i++)
    {
      ElemSort sort = foreach.getSortElem(i);
      
      if (TransformerImpl.S_DEBUG)
        getTraceManager().fireTraceEvent(sort);
     
      String langString =
        (null != sort.getLang())
        ? sort.getLang().evaluate(xctxt, sourceNodeContext, foreach) : null;
      String dataTypeString = sort.getDataType().evaluate(xctxt,
                                sourceNodeContext, foreach);

      if (dataTypeString.indexOf("":"") >= 0)
        System.out.println(
          ""TODO: Need to write the hooks for QNAME sort data type"");
      else if (!(dataTypeString.equalsIgnoreCase(Constants.ATTRVAL_DATATYPE_TEXT))
               &&!(dataTypeString.equalsIgnoreCase(
                 Constants.ATTRVAL_DATATYPE_NUMBER)))
        foreach.error(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE,
                      new Object[]{ Constants.ATTRNAME_DATATYPE,
                                    dataTypeString });

      boolean treatAsNumbers =
        ((null != dataTypeString) && dataTypeString.equals(
        Constants.ATTRVAL_DATATYPE_NUMBER)) ? true : false;
      String orderString = sort.getOrder().evaluate(xctxt, sourceNodeContext,
                             foreach);

      if (!(orderString.equalsIgnoreCase(Constants.ATTRVAL_ORDER_ASCENDING))
              &&!(orderString.equalsIgnoreCase(
                Constants.ATTRVAL_ORDER_DESCENDING)))
        foreach.error(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE,
                      new Object[]{ Constants.ATTRNAME_ORDER,
                                    orderString });

      boolean descending =
        ((null != orderString) && orderString.equals(
        Constants.ATTRVAL_ORDER_DESCENDING)) ? true : false;
      AVT caseOrder = sort.getCaseOrder();
      boolean caseOrderUpper;

      if (null != caseOrder)
      {
        String caseOrderString = caseOrder.evaluate(xctxt, sourceNodeContext,
                                                    foreach);

        if (!(caseOrderString.equalsIgnoreCase(Constants.ATTRVAL_CASEORDER_UPPER))
                &&!(caseOrderString.equalsIgnoreCase(
                  Constants.ATTRVAL_CASEORDER_LOWER)))
          foreach.error(XSLTErrorResources.ER_ILLEGAL_ATTRIBUTE_VALUE,
                        new Object[]{ Constants.ATTRNAME_CASEORDER,
                                      caseOrderString });

        caseOrderUpper =
          ((null != caseOrderString) && caseOrderString.equals(
          Constants.ATTRVAL_CASEORDER_UPPER)) ? true : false;
      }
      else
      {
        caseOrderUpper = false;
      }

      keys.addElement(new NodeSortKey(this, sort.getSelect(), treatAsNumbers,
                                      descending, langString, caseOrderUpper,
                                      foreach));
      if (TransformerImpl.S_DEBUG)
        getTraceManager().fireTraceEndEvent(sort);
     }

    return keys;
  }

  
  
  
  
  
  public Vector getElementCallstack()
  {
  	Vector elems = new Vector();
  	int nStackSize = m_currentTemplateElementsTop;
  	for(int i = 0; i < nStackSize; i++)
  	{
  		ElemTemplateElement elem = m_currentTemplateElements[i];
  		if(null != elem)
  		{
  			elems.addElement(elem);
  		}
  	}
  	return elems;
  }
  
  
  public int getCurrentTemplateElementsCount()
  {
  	return m_currentTemplateElementsTop;
  }
  
  
  
  public ElemTemplateElement[] getCurrentTemplateElements()
  {
  	return m_currentTemplateElements;
  }

  
  public void pushElemTemplateElement(ElemTemplateElement elem)
  {
    m_currentTemplateElements[m_currentTemplateElementsTop++] = elem;
  }

  
  public void popElemTemplateElement()
  {
    m_currentTemplateElementsTop--;
  }

  
  public void setCurrentElement(ElemTemplateElement e)
  {
    m_currentTemplateElements[m_currentTemplateElementsTop-1] = e;
  }

  
  public ElemTemplateElement getCurrentElement()
  {
    return (m_currentTemplateElementsTop > 0) ? 
        m_currentTemplateElements[m_currentTemplateElementsTop-1] : null;
  }

  
  public int getCurrentNode()
  {
    return m_xcontext.getCurrentNode();
  }
  
  
  public Vector getTemplateCallstack()
  {
  	Vector elems = new Vector();
  	int nStackSize = m_currentTemplateElementsTop;
  	for(int i = 0; i < nStackSize; i++)
  	{
  		ElemTemplateElement elem = m_currentTemplateElements[i];
  		if(null != elem && (elem.getXSLToken() != Constants.ELEMNAME_TEMPLATE))
  		{
  			elems.addElement(elem);
  		}
  	}
  	return elems;
  }


  
  public ElemTemplate getCurrentTemplate()
  {

    ElemTemplateElement elem = getCurrentElement();

    while ((null != elem)
           && (elem.getXSLToken() != Constants.ELEMNAME_TEMPLATE))
    {
      elem = elem.getParentElem();
    }

    return (ElemTemplate) elem;
  }

  
  public void pushPairCurrentMatched(ElemTemplateElement template, int child)
  {
    m_currentMatchTemplates.push(template);
    m_currentMatchedNodes.push(child);
  }

  
  public void popCurrentMatched()
  {
    m_currentMatchTemplates.pop();
    m_currentMatchedNodes.pop();
  }

  
  public ElemTemplate getMatchedTemplate()
  {
    return (ElemTemplate) m_currentMatchTemplates.peek();
  }

  
  public int getMatchedNode()
  {
    return m_currentMatchedNodes.peepTail();
  }

  
  public DTMIterator getContextNodeList()
  {

    try
    {
      DTMIterator cnl = m_xcontext.getContextNodeList();

      return (cnl == null) ? null : (DTMIterator) cnl.cloneWithReset();
    }
    catch (CloneNotSupportedException cnse)
    {

      
      return null;
    }
  }

  
  public Transformer getTransformer()
  {
    return this;
  }

  
  
  

  
  public void setStylesheet(StylesheetRoot stylesheetRoot)
  {
    m_stylesheetRoot = stylesheetRoot;
  }

  
  public final StylesheetRoot getStylesheet()
  {
    return m_stylesheetRoot;
  }

  
  public boolean getQuietConflictWarnings()
  {
    return m_quietConflictWarnings;
  }

  
  public void setQuietConflictWarnings(boolean b)
  {
    m_quietConflictWarnings = b;
  }

  
  public void setXPathContext(XPathContext xcontext)
  {
    m_xcontext = xcontext;
  }

  
  public final XPathContext getXPathContext()
  {
    return m_xcontext;
  }

  
  public StackGuard getStackGuard()
  {
    return m_stackGuard;
  }

  
  public int getRecursionLimit()
  {
    return m_stackGuard.getRecursionLimit();
  }

  
  public void setRecursionLimit(int limit)
  {
    m_stackGuard.setRecursionLimit(limit);
  }

  
  public ResultTreeHandler getResultTreeHandler()
  {
    return m_resultTreeHandler;
  }

  
  public KeyManager getKeyManager()
  {
    return m_keyManager;
  }

  
  public boolean isRecursiveAttrSet(ElemAttributeSet attrSet)
  {

    if (null == m_attrSetStack)
    {
      m_attrSetStack = new Stack();
    }

    if (!m_attrSetStack.empty())
    {
      int loc = m_attrSetStack.search(attrSet);

      if (loc > -1)
      {
        return true;
      }
    }

    return false;
  }

  
  public void pushElemAttributeSet(ElemAttributeSet attrSet)
  {
    m_attrSetStack.push(attrSet);
  }

  
  public void popElemAttributeSet()
  {
    m_attrSetStack.pop();
  }

  
  public CountersTable getCountersTable()
  {

    if (null == m_countersTable)
      m_countersTable = new CountersTable();

    return m_countersTable;
  }

  
  public boolean currentTemplateRuleIsNull()
  {
    return ((!m_currentTemplateRuleIsNull.isEmpty())
            && (m_currentTemplateRuleIsNull.peek() == true));
  }

  
  public void pushCurrentTemplateRuleIsNull(boolean b)
  {
    m_currentTemplateRuleIsNull.push(b);
  }

  
  public void popCurrentTemplateRuleIsNull()
  {
    m_currentTemplateRuleIsNull.pop();
  }

  
  public MsgMgr getMsgMgr()
  {

    if (null == m_msgMgr)
      m_msgMgr = new MsgMgr(this);

    return m_msgMgr;
  }

  
  public void setErrorListener(ErrorListener listener)
          throws IllegalArgumentException
  {

    synchronized (m_reentryGuard)
    {
      if (listener == null)
        throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NULL_ERROR_HANDLER, null)); 

      m_errorHandler = listener;
    }
  }

  
  public ErrorListener getErrorListener()
  {
    return m_errorHandler;
  }

  
  public TraceManager getTraceManager()
  {
    return m_traceManager;
  }

  
  public boolean getFeature(String name)
          throws SAXNotRecognizedException, SAXNotSupportedException
  {

    if (""http:
      return true;
    else if (""http:
      return true;

    throw new SAXNotRecognizedException(name);
  }

  

  
  public QName getMode()
  {
    return m_modes.isEmpty() ? null : (QName) m_modes.peek();
  }

  

  
  public void pushMode(QName mode)
  {
    m_modes.push(mode);
  }

  

  
  public void popMode()
  {
    m_modes.pop();
  }

  
  
  

  
  public static class ThreadControler
  {

    
    public Thread run(Runnable task, int priority)
    {

      Thread t = new Thread(task);

      t.start();

      
      
      return t;
    }

    
    public void waitThread(Thread worker, Runnable task)
            throws InterruptedException
    {

      
      worker.join();
    }
  }

  
  static ThreadControler tpool = new ThreadControler();

  
  public static void setThreadControler(ThreadControler tp)
  {
    tpool = tp;
  }

  
  public void runTransformThread(int priority)
  {

    
    Thread t = tpool.run(this, priority);

    this.setTransformThread(t);
  }

  
  public void runTransformThread()
  {
    tpool.run(this, -1);
  }
  
  
  public static void runTransformThread(Runnable runnable)
  {
    tpool.run(runnable, -1);
  }

  
  public void waitTransformThread() throws SAXException
  {

    
    
    
    
    
    Thread transformThread = this.getTransformThread();

    if (null != transformThread)
    {
      try
      {
        tpool.waitThread(transformThread, this);

        if (!this.hasTransformThreadErrorCatcher())
        {
          Exception e = this.getExceptionThrown();

          if (null != e)
          {
            e.printStackTrace();
            throw new org.xml.sax.SAXException(e);
          }
        }

        this.setTransformThread(null);
      }
      catch (InterruptedException ie){}
    }
  }

  
  public Exception getExceptionThrown()
  {
    return m_exceptionThrown;
  }

  
  public void setExceptionThrown(Exception e)
  {
    m_exceptionThrown = e;
  }

  
  public void setSourceTreeDocForThread(int doc)
  {
    m_doc = doc;
  }

  
  public void setXMLSource(Source source)
  {
    m_xmlSource = source;
  }

  
  public boolean isTransformDone()
  {

    synchronized (this)
    {
      return m_isTransformDone;
    }
  }

  
  public void setIsTransformDone(boolean done)
  {

    synchronized (this)
    {
      m_isTransformDone = done;
    }
  }

  
  void postExceptionFromThread(Exception e)
  {

    
    
    
    
    
    
    
    
    
    
    
    
    
    ContentHandler ch = getContentHandler();

    
    
    
    
    
    m_isTransformDone = true;
    m_exceptionThrown = e;
    ;  

    synchronized (this)
    {

      
      
      
      
      notifyAll();

      
      
      
      
      
      
      
    }
  }

  
  public void run()
  {

    m_hasBeenReset = false;

    try
    {

      
      
      try
      {
        m_isTransformDone = false;
        
        






        transformNode(m_doc);
        
      }
      catch (Exception e)
      {
        

        
        if (null != m_transformThread)
          postExceptionFromThread(e);   
        else 
          throw new RuntimeException(e.getMessage());
      }
      finally
      {
        m_isTransformDone = true;

        if (m_inputContentHandler instanceof TransformerHandlerImpl)
        {
          ((TransformerHandlerImpl) m_inputContentHandler).clearCoRoutine();
        }

        
        
        
        
      }
    }
    catch (Exception e)
    {

      
      if (null != m_transformThread)
        postExceptionFromThread(e);
      else 
        throw new RuntimeException(e.getMessage());         
    }
  }

  

  
  public TransformSnapshot getSnapshot()
  {
    return new TransformSnapshotImpl(this);
  }

  
  public void executeFromSnapshot(TransformSnapshot ts)
          throws TransformerException
  {

    ElemTemplateElement template = getMatchedTemplate();
    int child = getMatchedNode();

    pushElemTemplateElement(template);  
    m_xcontext.pushCurrentNode(child);  
    this.executeChildTemplates(template, true);  
  }

  
  public void resetToStylesheet(TransformSnapshot ts)
  {
    ((TransformSnapshotImpl) ts).apply(this);
  }

  
  public void stopTransformation(){}

  
  public short getShouldStripSpace(int elementHandle, DTM dtm)
  {

    try
    {
      org.apache.xalan.templates.WhiteSpaceInfo info =
        m_stylesheetRoot.getWhiteSpaceInfo(m_xcontext, elementHandle, dtm);

      if (null == info)
      {
        return DTMWSFilter.INHERIT;
      }
      else
      {

        
        return info.getShouldStripSpace()
               ? DTMWSFilter.STRIP : DTMWSFilter.NOTSTRIP;
      }
    }
    catch (TransformerException se)
    {
      return DTMWSFilter.INHERIT;
    }
  }
}  

"
org.apache.xml.utils.AttList,13,1,0,2,27,0,1,1,13,0.694444444,168,0.0,1,0.0,0.4,0,0,11.69230769,6,1.6923,0,"
package org.apache.xml.utils;

import org.w3c.dom.*;

import org.xml.sax.*;

import org.apache.xpath.DOMHelper;
import org.apache.xpath.DOM2Helper;


public class AttList implements Attributes
{

  
  NamedNodeMap m_attrs;

  
  int m_lastIndex;

  
  

  
  DOMHelper m_dh;















  
  public AttList(NamedNodeMap attrs, DOMHelper dh)
  {

    m_attrs = attrs;
    m_lastIndex = m_attrs.getLength() - 1;
    m_dh = dh;
  }

  
  public int getLength()
  {
    return m_attrs.getLength();
  }

  
  public String getURI(int index)
  {
    String ns = m_dh.getNamespaceOfNode(((Attr) m_attrs.item(index)));
    if(null == ns)
      ns = """";
    return ns;
  }

  
  public String getLocalName(int index)
  {
    return m_dh.getLocalNameOfNode(((Attr) m_attrs.item(index)));
  }

  
  public String getQName(int i)
  {
    return ((Attr) m_attrs.item(i)).getName();
  }

  
  public String getType(int i)
  {
    return ""CDATA"";  
  }

  
  public String getValue(int i)
  {
    return ((Attr) m_attrs.item(i)).getValue();
  }

  
  public String getType(String name)
  {
    return ""CDATA"";  
  }

  
  public String getType(String uri, String localName)
  {
    return ""CDATA"";  
  }

  
  public String getValue(String name)
  {
    Attr attr = ((Attr) m_attrs.getNamedItem(name));
    return (null != attr) 
          ? attr.getValue() : null;
  }

  
  public String getValue(String uri, String localName)
  {
		Node a=m_attrs.getNamedItemNS(uri,localName);
		return (a==null) ? null : a.getNodeValue();
  }

  
  public int getIndex(String uri, String localPart)
  {
    for(int i=m_attrs.getLength()-1;i>=0;--i)
    {
      Node a=m_attrs.item(i);
      String u=a.getNamespaceURI();
      if( (u==null ? uri==null : u.equals(uri))
	  &&
	  a.getLocalName().equals(localPart) )
	return i;
    }
    return -1;
  }

  
  public int getIndex(String qName)
  {
    for(int i=m_attrs.getLength()-1;i>=0;--i)
    {
      Node a=m_attrs.item(i);
      if(a.getNodeName().equals(qName) )
	return i;
    }
    return -1;
  }
}

"
org.apache.xml.utils.ObjectPool,7,1,0,4,20,0,2,2,7,0.166666667,119,1.0,0,0.0,0.342857143,0,0,15.71428571,2,0.7143,0,"
package org.apache.xml.utils;

import java.util.*;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;



public class ObjectPool implements java.io.Serializable
{

  
  private final Class objectType;

  
  private final Vector freeStack;

  
  public ObjectPool(Class type)
  {
    objectType = type;
    freeStack = new Vector();
  }
  
  
  public ObjectPool(String className)
  {
    try
    {
      objectType = Class.forName(className);
    }
    catch(ClassNotFoundException cnfe)
    {
      throw new WrappedRuntimeException(cnfe);
    }
    freeStack = new Vector();
  }


  
  public ObjectPool(Class type, int size)
  {
    objectType = type;
    freeStack = new Vector(size);
  }

  
  public ObjectPool()
  {
    objectType = null;
    freeStack = new Vector();
  }

  
  public synchronized Object getInstanceIfFree()
  {

    
    if (!freeStack.isEmpty())
    {

      
      Object result = freeStack.lastElement();

      freeStack.setSize(freeStack.size() - 1);

      return result;
    }

    return null;
  }

  
  public synchronized Object getInstance()
  {

    
    if (freeStack.isEmpty())
    {

      
      try
      {
        return objectType.newInstance();
      }
      catch (InstantiationException ex){}
      catch (IllegalAccessException ex){}

      
      throw new RuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_EXCEPTION_CREATING_POOL, null)); 
    }
    else
    {

      
      Object result = freeStack.lastElement();

      freeStack.setSize(freeStack.size() - 1);

      return result;
    }
  }

  
  public synchronized void freeInstance(Object obj)
  {

    
    
    
    
    freeStack.addElement(obj);
    
    
    
    
    
  }
}
"
org.apache.xalan.lib.NodeInfo,9,1,0,3,20,36,0,3,9,2.0,204,0.0,0,0.0,0.333333333,0,0,21.66666667,4,2.6667,0,"

package org.apache.xalan.lib;

import org.apache.xml.dtm.ref.DTMNodeProxy;
import org.apache.xalan.extensions.ExpressionContext;

import javax.xml.transform.SourceLocator;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;


public class NodeInfo
{
  
  public static String systemId(ExpressionContext context)
  {
    Node contextNode = context.getContextNode();
    int nodeHandler = ((DTMNodeProxy)contextNode).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)contextNode).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getSystemId();
    else
      return null;
  }

  
  public static String systemId(NodeList nodeList)
  {
    if (nodeList == null || nodeList.getLength() == 0)
      return null;
    
    Node node = nodeList.item(0);
    int nodeHandler = ((DTMNodeProxy)node).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)node).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getSystemId();
    else
      return null;
  }

  
  public static String publicId(ExpressionContext context)
  {
    Node contextNode = context.getContextNode();
    int nodeHandler = ((DTMNodeProxy)contextNode).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)contextNode).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getPublicId();
    else
      return null;
  }

  
  public static String publicId(NodeList nodeList)
  {
    if (nodeList == null || nodeList.getLength() == 0)
      return null;
    
    Node node = nodeList.item(0);
    int nodeHandler = ((DTMNodeProxy)node).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)node).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getPublicId();
    else
      return null;
  }

  
  public static int lineNumber(ExpressionContext context)
  {
    Node contextNode = context.getContextNode();
    int nodeHandler = ((DTMNodeProxy)contextNode).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)contextNode).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getLineNumber();
    else
      return -1;
  }

  
  public static int lineNumber(NodeList nodeList)
  {
    if (nodeList == null || nodeList.getLength() == 0)
      return -1;
    
    Node node = nodeList.item(0);
    int nodeHandler = ((DTMNodeProxy)node).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)node).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getLineNumber();
    else
      return -1;
  }

  
  public static int columnNumber(ExpressionContext context)
  {
    Node contextNode = context.getContextNode();
    int nodeHandler = ((DTMNodeProxy)contextNode).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)contextNode).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getColumnNumber();
    else
      return -1;
  }

  
  public static int columnNumber(NodeList nodeList)
  {
    if (nodeList == null || nodeList.getLength() == 0)
      return -1;
    
    Node node = nodeList.item(0);
    int nodeHandler = ((DTMNodeProxy)node).getDTMNodeNumber();
    SourceLocator locator = ((DTMNodeProxy)node).getDTM()
      .getSourceLocatorFor(nodeHandler);

    if (locator != null)
      return locator.getColumnNumber();
    else
      return -1;
  }
}
"
org.apache.xalan.xsltc.compiler.Expression,18,2,21,101,43,115,79,24,17,0.838235294,238,1.0,3,0.76056338,0.285714286,1,2,12.0,6,1.4444,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.compiler.util.*;

import java.util.Vector;

import org.apache.bcel.generic.*;

abstract class Expression extends SyntaxTreeNode {
    
    protected Type _type;

    
    protected boolean _startReset = false;

    
    protected FlowList _trueList = new FlowList();

    
    protected FlowList _falseList = new FlowList();

    public Type getType() {
	return _type;
    }

    public abstract String toString();

    public boolean hasPositionCall() {
	return false;		
    }

    public boolean hasLastCall() {
	return false;
    }
		
    
    public Object evaluateAtCompileTime() {
	return null;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return typeCheckContents(stable);
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	ErrorMsg msg = new ErrorMsg(ErrorMsg.NOT_IMPLEMENTED_ERR,
				    getClass(), this);
	getParser().reportError(FATAL, msg);
    }
	
    
    public final InstructionList compile(ClassGenerator classGen,
					 MethodGenerator methodGen) {
	final InstructionList result, save = methodGen.getInstructionList();
	methodGen.setInstructionList(result = new InstructionList());
	translate(classGen, methodGen);
	methodGen.setInstructionList(save);
	return result;
    }

    
    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	translate(classGen, methodGen);
	if (_type instanceof BooleanType) {
	    desynthesize(classGen, methodGen);
	}
    }

    
    public void startResetIterator(ClassGenerator classGen,
				   MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_startReset) {
	    return;			
	}
	_startReset = true;

	if (_type instanceof NodeSetType == false) {
	    return;		
	}

	if ( (this instanceof VariableRefBase) == false ) {
	    il.append(methodGen.loadContextNode());
	    il.append(methodGen.setStartNode());
	}
    }

    
    public void synthesize(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	_trueList.backPatch(il.append(ICONST_1));
	final BranchHandle truec = il.append(new GOTO_W(null));
	_falseList.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    public void desynthesize(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	final InstructionList il = methodGen.getInstructionList();
	_falseList.add(il.append(new IFEQ(null)));
    }

    public FlowList getFalseList() {
	return _falseList;
    }

    public FlowList getTrueList() {
	return _trueList;
    }

    public void backPatchFalseList(InstructionHandle ih) {
	_falseList.backPatch(ih);
    }

    public void backPatchTrueList(InstructionHandle ih) {
	_trueList.backPatch(ih);
    }

    
    public MethodType lookupPrimop(SymbolTable stable, String op,
				   MethodType ctype) {
	MethodType result = null;
	final Vector primop = stable.lookupPrimop(op);
	if (primop != null) {
	    final int n = primop.size();
	    int minDistance = Integer.MAX_VALUE;
	    for (int i = 0; i < n; i++) {
		final MethodType ptype = (MethodType) primop.elementAt(i);
		
		if (ptype.argsCount() != ctype.argsCount()) {
		    continue;
		}
				
		
		if (result == null) {
		    result = ptype;		
		}

		
		final int distance = ctype.distanceTo(ptype);
		if (distance < minDistance) {
		    minDistance = distance;
		    result = ptype;
		}
	    }		
	}	
	return result;
    }	
}
"
org.apache.xalan.xsltc.dom.SingleNodeCounter,5,2,1,5,16,2,1,5,4,0.625,107,0.5,1,0.823529412,0.5,1,4,20.0,9,2.2,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.NodeIterator;

public abstract class SingleNodeCounter extends NodeCounter {
    static private final int[] EmptyArray = new int[] { };
    NodeIterator _countSiblings = null;

    public SingleNodeCounter(Translet translet,
			     DOM document,
			     NodeIterator iterator) {
	super(translet, document, iterator);
    }

    public NodeCounter setStartNode(int node) {
	_node = node;
	_nodeType = _document.getType(node);
	_countSiblings = _document.getAxisIterator(PRECEDINGSIBLING);
	return this;
    }

    public String getCounter() {
	int result;
	if (_value != Integer.MIN_VALUE) {
	    result = _value;
	}
	else {
	    int next = _node;
	    result = 0;
	    if (!matchesCount(next)) {
		while ((next = _document.getParent(next)) > END) {
		    if (matchesCount(next)) {
			break;		
		    }
		    if (matchesFrom(next)) {
			next = END;
			break;		
		    }
		}
	    }

	    if (next != END) {
		_countSiblings.setStartNode(next);
		do {
		    if (matchesCount(next)) result++;
		} while ((next = _countSiblings.next()) != END);
	    }
	    else {
		
		return formatNumbers(EmptyArray);
	    }
	}
	return formatNumbers(result);
    }

    public static NodeCounter getDefaultNodeCounter(Translet translet,
						    DOM document,
						    NodeIterator iterator) {
	return new DefaultSingleNodeCounter(translet, document, iterator);
    }

    static class DefaultSingleNodeCounter extends SingleNodeCounter {
	public DefaultSingleNodeCounter(Translet translet,
					DOM document, NodeIterator iterator) {
	    super(translet, document, iterator);
	}

	public NodeCounter setStartNode(int node) {
	    _node = node;
	    _nodeType = _document.getType(node);
	    _countSiblings =
		_document.getTypedAxisIterator(PRECEDINGSIBLING,
					       _document.getType(node));
	    return this;
	}

	public String getCounter() {
	    int result;
	    if (_value != Integer.MIN_VALUE) {
		result = _value;
	    }
	    else {
		int next;
		result = 1;
		_countSiblings.setStartNode(_node);
		while ((next = _countSiblings.next()) != END) {
		    result++;
		}
	    }
	    return formatNumbers(result);
	}
    }
}

"
org.apache.xpath.CachedXPathAPI,12,1,0,5,23,54,0,5,12,0.454545455,139,1.0,1,0.0,0.533333333,0,0,10.5,1,0.8333,0,"
package org.apache.xpath;

import javax.xml.transform.TransformerException;

import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.traversal.NodeIterator;
import org.w3c.dom.NodeList;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xpath.XPathContext;
import org.apache.xml.utils.PrefixResolverDefault;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.objects.XObject;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xml.dtm.ref.DTMNodeList;
import org.apache.xml.dtm.ref.DTMManagerDefault;


public class CachedXPathAPI
{
  
  protected XPathContext xpathSupport;

  
  public CachedXPathAPI()
  {
    xpathSupport = new XPathContext();
  }
  
  
  public CachedXPathAPI(CachedXPathAPI priorXPathAPI)
  {
    xpathSupport = priorXPathAPI.xpathSupport;
  }


  
  public XPathContext getXPathContext()
  {
    return this.xpathSupport;
  }
  

  
  public  Node selectSingleNode(Node contextNode, String str)
          throws TransformerException
  {
    return selectSingleNode(contextNode, str, contextNode);
  }

  
  public  Node selectSingleNode(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    NodeIterator nl = selectNodeIterator(contextNode, str, namespaceNode);

    
    return nl.nextNode();
  }

  
  public  NodeIterator selectNodeIterator(Node contextNode, String str)
          throws TransformerException
  {
    return selectNodeIterator(contextNode, str, contextNode);
  }

  
  public  NodeIterator selectNodeIterator(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    XObject list = eval(contextNode, str, namespaceNode);

    
    return list.nodeset();
  }

  
  public  NodeList selectNodeList(Node contextNode, String str)
          throws TransformerException
  {
    return selectNodeList(contextNode, str, contextNode);
  }

  
  public  NodeList selectNodeList(
          Node contextNode, String str, Node namespaceNode)
            throws TransformerException
  {

    
    XObject list = eval(contextNode, str, namespaceNode);

    
    return list.nodelist();
  }

  
  public  XObject eval(Node contextNode, String str)
          throws TransformerException
  {
    return eval(contextNode, str, contextNode);
  }

  
  public  XObject eval(Node contextNode, String str, Node namespaceNode)
          throws TransformerException
  {

    
    
    
    
    

    
    
    
    
    PrefixResolverDefault prefixResolver = new PrefixResolverDefault(
      (namespaceNode.getNodeType() == Node.DOCUMENT_NODE)
      ? ((Document) namespaceNode).getDocumentElement() : namespaceNode);

    
    XPath xpath = new XPath(str, null, prefixResolver, XPath.SELECT, null);

    
    
    int ctxtNode = xpathSupport.getDTMHandleFromNode(contextNode);

    return xpath.execute(xpathSupport, ctxtNode, prefixResolver);
  }

  
  public  XObject eval(
          Node contextNode, String str, PrefixResolver prefixResolver)
            throws TransformerException
  {

    
    
    
    
    
    
    XPath xpath = new XPath(str, null, prefixResolver, XPath.SELECT, null);

    
    XPathContext xpathSupport = new XPathContext();
    int ctxtNode = xpathSupport.getDTMHandleFromNode(contextNode);

    return xpath.execute(xpathSupport, ctxtNode, prefixResolver);
  }
}
"
org.apache.xalan.xsltc.compiler.ForEach,6,3,0,31,54,3,2,30,5,0.6,314,1.0,2,0.918032787,0.361111111,1,5,51.0,9,2.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class ForEach extends Instruction {

    private Expression _select;
    private Type       _type;

    public void display(int indent) {
	indent(indent);
	Util.println(""ForEach"");
	indent(indent + IndentIncrement);
	Util.println(""select "" + _select.toString());
	displayContents(indent + IndentIncrement);
    }
		
    public void parseContents(Parser parser) {
	_select = parser.parseExpression(this, ""select"", null);

	parseChildren(parser);

        
        if (_select.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""select"");
	    return;
        }
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_type = _select.typeCheck(stable);

	if (_type instanceof ReferenceType || _type instanceof NodeType) {
	    _select = new CastExpr(_select, Type.NodeSet);
	    typeCheckContents(stable);
	    return Type.Void;
	}
	if (_type instanceof NodeSetType||_type instanceof ResultTreeType) {
	    typeCheckContents(stable);
	    return Type.Void;
	}
	throw new TypeCheckError(this);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	il.append(methodGen.loadCurrentNode());
	il.append(methodGen.loadIterator());
		
	
	final Vector sortObjects = new Vector();
	Enumeration children = elements();
	while (children.hasMoreElements()) {
	    final Object child = children.nextElement();
	    if (child instanceof Sort) {
		sortObjects.addElement(child);
	    }
	}

	if ((_type != null) && (_type instanceof ResultTreeType)) {
	    
	    il.append(methodGen.loadDOM());

	    
	    if (sortObjects.size() > 0) {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.RESULT_TREE_SORT_ERR,this);
		getParser().reportError(WARNING, msg);
	    }

	    
	    _select.translate(classGen, methodGen);
	    
	    _type.translateTo(classGen, methodGen, Type.NodeSet);
	    
	    il.append(SWAP);
	    il.append(methodGen.storeDOM());
	}
	else {
	    
	    if (sortObjects.size() > 0) {
		Sort.translateSortIterator(classGen, methodGen,
					   _select, sortObjects);
	    }
	    else {
		_select.translate(classGen, methodGen);
	    }
	    if (!(_type instanceof ReferenceType)) {
		_select.startResetIterator(classGen, methodGen);
	    }
	}


	
	il.append(methodGen.storeIterator());

	
	initializeVariables(classGen, methodGen);

	final BranchHandle nextNode = il.append(new GOTO(null));
	final InstructionHandle loop = il.append(NOP);

	translateContents(classGen, methodGen);
		    
	nextNode.setTarget(il.append(methodGen.loadIterator()));
	il.append(methodGen.nextNode());
	il.append(DUP);
	il.append(methodGen.storeCurrentNode());
	il.append(new IFNE(loop));

	
	if ((_type != null) && (_type instanceof ResultTreeType)) {
	    il.append(methodGen.storeDOM());	    
	}

	
	il.append(methodGen.storeIterator());
	il.append(methodGen.storeCurrentNode());
    }

    
    public void initializeVariables(ClassGenerator classGen,
				   MethodGenerator methodGen) {
	final int n = elementCount();
	for (int i = 0; i < n; i++) {
	    final Object child = getContents().elementAt(i);
	    if (child instanceof Variable) {
		Variable var = (Variable)child;
		var.initialize(classGen, methodGen);
	    }
	}
    }

}
"
org.apache.xpath.DOM2Helper,11,2,1,13,29,53,10,3,11,0.8,125,1.0,0,0.705882353,0.327272727,1,5,10.27272727,4,1.4545,0,"
package org.apache.xpath;

import java.io.IOException;

import java.util.StringTokenizer;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.DOMHelper;

import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Text;
import org.w3c.dom.Attr;
import org.xml.sax.InputSource;
import org.xml.sax.Parser;

import javax.xml.parsers.*;

import javax.xml.transform.TransformerException;


public class DOM2Helper extends DOMHelper
{

  
  public DOM2Helper(){}

  
  public void checkNode(Node node) throws TransformerException
  {

    
    
    
  }

  
  public boolean supportsSAX()
  {
    return true;
  }

  
  private Document m_doc;

  
  public void setDocument(Document doc)
  {
    m_doc = doc;
  }

  
  public Document getDocument()
  {
    return m_doc;
  }

  
  public void parse(InputSource source) throws TransformerException
  {

    try
    {

      
      
      
      DocumentBuilderFactory builderFactory =
        DocumentBuilderFactory.newInstance();

      builderFactory.setNamespaceAware(true);
      builderFactory.setValidating(true);

      DocumentBuilder parser = builderFactory.newDocumentBuilder();

      

      parser.setErrorHandler(
        new org.apache.xml.utils.DefaultErrorHandler());

      
      
      
      
      
      setDocument(parser.parse(source));
    }
    catch (org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    catch (ParserConfigurationException pce)
    {
      throw new TransformerException(pce);
    }
    catch (IOException ioe)
    {
      throw new TransformerException(ioe);
    }

    
  }

  
  public Element getElementByID(String id, Document doc)
  {
    return doc.getElementById(id);
  }

  
  public static boolean isNodeAfter(Node node1, Node node2)
  {

    
    
    if(node1 instanceof DOMOrder && node2 instanceof DOMOrder)
    {
      int index1 = ((DOMOrder) node1).getUid();
      int index2 = ((DOMOrder) node2).getUid();

      return index1 <= index2;
    }
    else
    {

      
      
      return DOMHelper.isNodeAfter(node1, node2);
    }
  }

  
  public static Node getParentOfNode(Node node)
  {
          Node parent=node.getParentNode();
          if(parent==null && (Node.ATTRIBUTE_NODE == node.getNodeType()) )
           parent=((Attr) node).getOwnerElement();
          return parent;
  }

  
  public String getLocalNameOfNode(Node n)
  {

    String name = n.getLocalName();

    return (null == name) ? super.getLocalNameOfNode(n) : name;
  }

  
  public String getNamespaceOfNode(Node n)
  {
    return n.getNamespaceURI();
  }

  
  
}
"
org.apache.xpath.axes.ReverseAxesWalker,8,5,0,8,24,26,1,7,4,0.571428571,200,1.0,1,0.936363636,0.4375,2,8,23.875,4,1.875,1,"
package org.apache.xpath.axes;

import java.util.Vector;

import org.apache.xpath.axes.LocPathIterator;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.compiler.OpCodes;
import org.apache.xpath.objects.XObject;

import javax.xml.transform.TransformerException;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.dtm.Axis;


public class ReverseAxesWalker extends AxesWalker
{

  
  ReverseAxesWalker(LocPathIterator locPathIterator, int axis)
  {
    super(locPathIterator, axis);
  }
  
  
  public void setRoot(int root)
  {
    super.setRoot(root);
    m_iterator = getDTM(root).getAxisIterator(m_axis);
    m_iterator.setStartNode(root);
  }
  
  
  protected int getNextNode()
  {
    if (m_foundLast)
      return DTM.NULL;

    int next = m_iterator.next();
    
    if (m_isFresh)
      m_isFresh = false;

    if (DTM.NULL == next)
      this.m_foundLast = true;

    return next;
  }


  
  public boolean isReverseAxes()
  {
    return true;
  }











  
  protected int getProximityPosition(int predicateIndex)
  {
    
    
    
    if(predicateIndex < 0)
      return -1;
      
    int count = m_proximityPositions[predicateIndex];
      
    if (count <= 0)
    {
      AxesWalker savedWalker = wi().getLastUsedWalker();

      try
      {
        ReverseAxesWalker clone = (ReverseAxesWalker) this.clone();

        clone.setRoot(this.getRoot());

        clone.setPredicateCount(predicateIndex);

        clone.setPrevWalker(null);
        clone.setNextWalker(null);
        wi().setLastUsedWalker(clone);

        
        count++;
        int next;

        while (DTM.NULL != (next = clone.nextNode()))
        {
          count++;
        }

        m_proximityPositions[predicateIndex] = count;
      }
      catch (CloneNotSupportedException cnse)
      {

        
      }
      finally
      {
        wi().setLastUsedWalker(savedWalker);
      }
    }
    
    return count;
  }

  
  protected void countProximityPosition(int i)
  {
    if (i < m_proximityPositions.length)
      m_proximityPositions[i]--;
  }

  
  public int getLastPos(XPathContext xctxt)
  {

    int count = 0;
    AxesWalker savedWalker = wi().getLastUsedWalker();

    try
    {
      ReverseAxesWalker clone = (ReverseAxesWalker) this.clone();

      clone.setRoot(this.getRoot());

      clone.setPredicateCount(this.getPredicateCount() - 1);

      clone.setPrevWalker(null);
      clone.setNextWalker(null);
      wi().setLastUsedWalker(clone);

      
      
      int next;

      while (DTM.NULL != (next = clone.nextNode()))
      {
        count++;
      }
    }
    catch (CloneNotSupportedException cnse)
    {

      
    }
    finally
    {
      wi().setLastUsedWalker(savedWalker);
    }

    return count;
  }
  
  
  public boolean isDocOrdered()
  {
    return false;  
  }
  
  
  protected DTMAxisIterator m_iterator;
}
"
org.apache.xalan.xsltc.compiler.FormatNumberCall,3,4,0,25,24,0,0,25,3,0.0,191,1.0,4,0.979591837,0.444444444,3,13,61.33333333,3,1.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class FormatNumberCall extends FunctionCall {
    private Expression _value;
    private Expression _format;
    private Expression _name;
    private QName      _resolvedQName = null;

    public FormatNumberCall(QName fname, Vector arguments) {
	super(fname, arguments);
	_value = argument(0);
	_format = argument(1);
	_name = argumentCount() == 3 ? argument(2) : null;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	getStylesheet().numberFormattingUsed();

	final Type tvalue = _value.typeCheck(stable);
	if (tvalue instanceof RealType == false) {
	    _value = new CastExpr(_value, Type.Real);
	}
	final Type tformat = _format.typeCheck(stable);
	if (tformat instanceof StringType == false) {
	    _format = new CastExpr(_format, Type.String);
	}
	if (argumentCount() == 3) {
	    final Type tname = _name.typeCheck(stable);

	    if (_name instanceof LiteralExpr) {
		final LiteralExpr literal = (LiteralExpr) _name;
		_resolvedQName = 
		    getParser().getQNameIgnoreDefaultNs(literal.getValue());
	    }
	    else if (tname instanceof StringType == false) {
		_name = new CastExpr(_name, Type.String);
	    }
	}
	return _type = Type.String;
    }
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	_value.translate(classGen, methodGen);
	_format.translate(classGen, methodGen);

	final int fn3arg = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					    ""formatNumber"",
					    ""(DLjava/lang/String;""+
					    ""Ljava/text/DecimalFormat;)""+
					    ""Ljava/lang/String;"");
	final int get = cpg.addMethodref(TRANSLET_CLASS,
					 ""getDecimalFormat"",
					 ""(Ljava/lang/String;)""+
					 ""Ljava/text/DecimalFormat;"");
	
	il.append(classGen.loadTranslet());
	if (_name == null) {
	    il.append(new PUSH(cpg, EMPTYSTRING));
	}
	else if (_resolvedQName != null) {
	    il.append(new PUSH(cpg, _resolvedQName.toString()));
	}
	else {
	    _name.translate(classGen, methodGen);
	}
	il.append(new INVOKEVIRTUAL(get));
	il.append(new INVOKESTATIC(fn3arg));
    }
}
"
org.apache.xpath.functions.FuncQname,2,5,0,5,7,1,0,5,2,2.0,35,0.0,0,0.982142857,0.75,2,7,16.5,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;




import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xml.utils.QName;


public class FuncQname extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    int context = getArg0AsNode(xctxt);
    XObject val;

    if (DTM.NULL != context)
    {
      DTM dtm = xctxt.getDTM(context);
      String qname = dtm.getNodeNameX(context);
      val = (null == qname) ? XString.EMPTYSTRING : new XString(qname);
    }
    else
    {
      val = XString.EMPTYSTRING;
    }

    return val;
  }
}
"
org.apache.xpath.axes.IteratorPool,4,1,0,4,13,0,2,2,4,0.166666667,76,1.0,1,0.0,0.75,0,0,17.5,2,1.0,0,"package org.apache.xpath.axes;

import java.util.*;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.WrappedRuntimeException;


public class IteratorPool implements java.io.Serializable
{

  
  private final DTMIterator m_orig;

  
  private final Vector m_freeStack;

  
  public IteratorPool(DTMIterator original)
  {
    m_orig = original;
    m_freeStack = new Vector();
  }
  
  
  public synchronized DTMIterator getInstanceOrThrow()
    throws CloneNotSupportedException
  {
    
    if (m_freeStack.isEmpty())
    {

      
      return (DTMIterator)m_orig.clone();
    }
    else
    {
      
      DTMIterator result = (DTMIterator)m_freeStack.lastElement();

      m_freeStack.setSize(m_freeStack.size() - 1);

      return result;
    }
  }
  
  
  public synchronized DTMIterator getInstance()
  {
    
    if (m_freeStack.isEmpty())
    {

      
      try
      {
        return (DTMIterator)m_orig.clone();
      }
      catch (Exception ex)
      {
        throw new WrappedRuntimeException(ex);
      }
    }
    else
    {
      
      DTMIterator result = (DTMIterator)m_freeStack.lastElement();

      m_freeStack.setSize(m_freeStack.size() - 1);

      return result;
    }
  }

  
  public synchronized void freeInstance(DTMIterator obj)
  {
    m_freeStack.addElement(obj);
  }
}"
org.apache.xalan.xsltc.compiler.RelativeLocationPath,3,3,2,4,4,3,3,1,2,2.0,6,0.0,0,0.97260274,0.666666667,0,0,1.0,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

abstract class RelativeLocationPath extends Expression {
    public abstract int getAxis();
    public abstract void setAxis(int axis);
}
"
org.apache.xpath.ExtensionsProvider,3,1,0,4,3,3,4,0,3,2.0,3,0.0,0,0.0,0.666666667,0,0,0.0,1,1.0,1,"
package org.apache.xpath;

import java.util.Vector;


public interface ExtensionsProvider
{
  
  
  public boolean functionAvailable(String ns, String funcName)
          throws javax.xml.transform.TransformerException;
  
  
  public boolean elementAvailable(String ns, String elemName)
          throws javax.xml.transform.TransformerException;
   
  
  public Object extFunction(String ns, String funcName, 
                            Vector argVec, Object methodKey)
            throws javax.xml.transform.TransformerException;
}
"
org.apache.xalan.xsltc.compiler.util.StringStack,4,5,0,0,8,6,0,0,4,2.0,20,0.0,0,0.963855422,0.625,0,0,4.0,1,0.75,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Stack;

public final class StringStack extends Stack {
    public String peekString() {
	return (String) super.peek();
    }
	
    public String popString() {
	return (String) super.pop();
    }
	
    public String pushString(String val) {
	return (String) super.push(val);
    }		
}
"
org.apache.xalan.xsltc.compiler.NamespaceAlias,4,3,0,9,8,6,1,8,3,1.0,30,1.0,0,0.952380952,0.4,2,4,6.0,1,0.75,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import java.util.StringTokenizer;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class NamespaceAlias extends TopLevelElement {

    private String sPrefix;
    private String rPrefix;
	
    
    public void parseContents(Parser parser) {
	sPrefix = getAttribute(""stylesheet-prefix"");
	rPrefix = getAttribute(""result-prefix"");
	parser.getSymbolTable().addPrefixAlias(sPrefix,rPrefix);
    }
	
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }
	
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }
}
"
org.apache.xml.utils.XMLChar,23,1,0,2,26,181,2,0,22,0.97979798,3198,0.0,0,0.0,0.25,0,0,137.6521739,17,3.913,0,"

package org.apache.xml.utils;


public class XMLChar {

    
    
    

    
    public static final byte[] CHARS = new byte[1 << 16];

    
    public static final int MASK_VALID = 0x01;

    
    public static final int MASK_SPACE = 0x02;

    
    public static final int MASK_NAME_START = 0x04;

    
    public static final int MASK_NAME = 0x08;

    
    public static final int MASK_PUBID = 0x10;
    
    
    public static final int MASK_CONTENT = 0x20;

    
    public static final int MASK_NCNAME_START = 0x40;

    
    public static final int MASK_NCNAME = 0x80;

    
    
    

    static {
        
        
        
        
        

        int charRange[] = { 
            0x0009, 0x000A, 0x000D, 0x000D, 0x0020, 0xD7FF, 0xE000, 0xFFFD,
        };

        
        
        

        int spaceChar[] = { 
            0x0020, 0x0009, 0x000D, 0x000A,
        };

        
        
        
        

        int nameChar[] = { 
            0x002D, 0x002E, 
        };

        
        
        

        int nameStartChar[] = { 
            0x003A, 0x005F, 
        };

        
        
        

        int pubidChar[] = {
            0x000A, 0x000D, 0x0020, 0x0021, 0x0023, 0x0024, 0x0025, 0x003D,
            0x005F
        };

        int pubidRange[] = {
            0x0027, 0x003B, 0x003F, 0x005A, 0x0061, 0x007A
        };

        
        
        

        int letterRange[] = {
            
            0x0041, 0x005A, 0x0061, 0x007A, 0x00C0, 0x00D6, 0x00D8, 0x00F6,
            0x00F8, 0x0131, 0x0134, 0x013E, 0x0141, 0x0148, 0x014A, 0x017E,
            0x0180, 0x01C3, 0x01CD, 0x01F0, 0x01F4, 0x01F5, 0x01FA, 0x0217,
            0x0250, 0x02A8, 0x02BB, 0x02C1, 0x0388, 0x038A, 0x038E, 0x03A1,
            0x03A3, 0x03CE, 0x03D0, 0x03D6, 0x03E2, 0x03F3, 0x0401, 0x040C,
            0x040E, 0x044F, 0x0451, 0x045C, 0x045E, 0x0481, 0x0490, 0x04C4,
            0x04C7, 0x04C8, 0x04CB, 0x04CC, 0x04D0, 0x04EB, 0x04EE, 0x04F5,
            0x04F8, 0x04F9, 0x0531, 0x0556, 0x0561, 0x0586, 0x05D0, 0x05EA,
            0x05F0, 0x05F2, 0x0621, 0x063A, 0x0641, 0x064A, 0x0671, 0x06B7,
            0x06BA, 0x06BE, 0x06C0, 0x06CE, 0x06D0, 0x06D3, 0x06E5, 0x06E6,
            0x0905, 0x0939, 0x0958, 0x0961, 0x0985, 0x098C, 0x098F, 0x0990,
            0x0993, 0x09A8, 0x09AA, 0x09B0, 0x09B6, 0x09B9, 0x09DC, 0x09DD,
            0x09DF, 0x09E1, 0x09F0, 0x09F1, 0x0A05, 0x0A0A, 0x0A0F, 0x0A10,
            0x0A13, 0x0A28, 0x0A2A, 0x0A30, 0x0A32, 0x0A33, 0x0A35, 0x0A36,
            0x0A38, 0x0A39, 0x0A59, 0x0A5C, 0x0A72, 0x0A74, 0x0A85, 0x0A8B,
            0x0A8F, 0x0A91, 0x0A93, 0x0AA8, 0x0AAA, 0x0AB0, 0x0AB2, 0x0AB3,
            0x0AB5, 0x0AB9, 0x0B05, 0x0B0C, 0x0B0F, 0x0B10, 0x0B13, 0x0B28,
            0x0B2A, 0x0B30, 0x0B32, 0x0B33, 0x0B36, 0x0B39, 0x0B5C, 0x0B5D,
            0x0B5F, 0x0B61, 0x0B85, 0x0B8A, 0x0B8E, 0x0B90, 0x0B92, 0x0B95,
            0x0B99, 0x0B9A, 0x0B9E, 0x0B9F, 0x0BA3, 0x0BA4, 0x0BA8, 0x0BAA,
            0x0BAE, 0x0BB5, 0x0BB7, 0x0BB9, 0x0C05, 0x0C0C, 0x0C0E, 0x0C10,
            0x0C12, 0x0C28, 0x0C2A, 0x0C33, 0x0C35, 0x0C39, 0x0C60, 0x0C61,
            0x0C85, 0x0C8C, 0x0C8E, 0x0C90, 0x0C92, 0x0CA8, 0x0CAA, 0x0CB3,
            0x0CB5, 0x0CB9, 0x0CE0, 0x0CE1, 0x0D05, 0x0D0C, 0x0D0E, 0x0D10,
            0x0D12, 0x0D28, 0x0D2A, 0x0D39, 0x0D60, 0x0D61, 0x0E01, 0x0E2E,
            0x0E32, 0x0E33, 0x0E40, 0x0E45, 0x0E81, 0x0E82, 0x0E87, 0x0E88,
            0x0E94, 0x0E97, 0x0E99, 0x0E9F, 0x0EA1, 0x0EA3, 0x0EAA, 0x0EAB,
            0x0EAD, 0x0EAE, 0x0EB2, 0x0EB3, 0x0EC0, 0x0EC4, 0x0F40, 0x0F47,
            0x0F49, 0x0F69, 0x10A0, 0x10C5, 0x10D0, 0x10F6, 0x1102, 0x1103,
            0x1105, 0x1107, 0x110B, 0x110C, 0x110E, 0x1112, 0x1154, 0x1155,
            0x115F, 0x1161, 0x116D, 0x116E, 0x1172, 0x1173, 0x11AE, 0x11AF,
            0x11B7, 0x11B8, 0x11BC, 0x11C2, 0x1E00, 0x1E9B, 0x1EA0, 0x1EF9,
            0x1F00, 0x1F15, 0x1F18, 0x1F1D, 0x1F20, 0x1F45, 0x1F48, 0x1F4D,
            0x1F50, 0x1F57, 0x1F5F, 0x1F7D, 0x1F80, 0x1FB4, 0x1FB6, 0x1FBC,
            0x1FC2, 0x1FC4, 0x1FC6, 0x1FCC, 0x1FD0, 0x1FD3, 0x1FD6, 0x1FDB,
            0x1FE0, 0x1FEC, 0x1FF2, 0x1FF4, 0x1FF6, 0x1FFC, 0x212A, 0x212B,
            0x2180, 0x2182, 0x3041, 0x3094, 0x30A1, 0x30FA, 0x3105, 0x312C,
            0xAC00, 0xD7A3,
            
            0x3021, 0x3029, 0x4E00, 0x9FA5,
        };
        int letterChar[] = {
            
            0x0386, 0x038C, 0x03DA, 0x03DC, 0x03DE, 0x03E0, 0x0559, 0x06D5,
            0x093D, 0x09B2, 0x0A5E, 0x0A8D, 0x0ABD, 0x0AE0, 0x0B3D, 0x0B9C,
            0x0CDE, 0x0E30, 0x0E84, 0x0E8A, 0x0E8D, 0x0EA5, 0x0EA7, 0x0EB0,
            0x0EBD, 0x1100, 0x1109, 0x113C, 0x113E, 0x1140, 0x114C, 0x114E,
            0x1150, 0x1159, 0x1163, 0x1165, 0x1167, 0x1169, 0x1175, 0x119E,
            0x11A8, 0x11AB, 0x11BA, 0x11EB, 0x11F0, 0x11F9, 0x1F59, 0x1F5B,
            0x1F5D, 0x1FBE, 0x2126, 0x212E,
            
            0x3007,
        };

        
        
        

        int combiningCharRange[] = {
            0x0300, 0x0345, 0x0360, 0x0361, 0x0483, 0x0486, 0x0591, 0x05A1,
            0x05A3, 0x05B9, 0x05BB, 0x05BD, 0x05C1, 0x05C2, 0x064B, 0x0652,
            0x06D6, 0x06DC, 0x06DD, 0x06DF, 0x06E0, 0x06E4, 0x06E7, 0x06E8,
            0x06EA, 0x06ED, 0x0901, 0x0903, 0x093E, 0x094C, 0x0951, 0x0954,
            0x0962, 0x0963, 0x0981, 0x0983, 0x09C0, 0x09C4, 0x09C7, 0x09C8,
            0x09CB, 0x09CD, 0x09E2, 0x09E3, 0x0A40, 0x0A42, 0x0A47, 0x0A48,
            0x0A4B, 0x0A4D, 0x0A70, 0x0A71, 0x0A81, 0x0A83, 0x0ABE, 0x0AC5,
            0x0AC7, 0x0AC9, 0x0ACB, 0x0ACD, 0x0B01, 0x0B03, 0x0B3E, 0x0B43,
            0x0B47, 0x0B48, 0x0B4B, 0x0B4D, 0x0B56, 0x0B57, 0x0B82, 0x0B83,
            0x0BBE, 0x0BC2, 0x0BC6, 0x0BC8, 0x0BCA, 0x0BCD, 0x0C01, 0x0C03,
            0x0C3E, 0x0C44, 0x0C46, 0x0C48, 0x0C4A, 0x0C4D, 0x0C55, 0x0C56,
            0x0C82, 0x0C83, 0x0CBE, 0x0CC4, 0x0CC6, 0x0CC8, 0x0CCA, 0x0CCD,
            0x0CD5, 0x0CD6, 0x0D02, 0x0D03, 0x0D3E, 0x0D43, 0x0D46, 0x0D48,
            0x0D4A, 0x0D4D, 0x0E34, 0x0E3A, 0x0E47, 0x0E4E, 0x0EB4, 0x0EB9,
            0x0EBB, 0x0EBC, 0x0EC8, 0x0ECD, 0x0F18, 0x0F19, 0x0F71, 0x0F84,
            0x0F86, 0x0F8B, 0x0F90, 0x0F95, 0x0F99, 0x0FAD, 0x0FB1, 0x0FB7,
            0x20D0, 0x20DC, 0x302A, 0x302F,
        };

        int combiningCharChar[] = {
            0x05BF, 0x05C4, 0x0670, 0x093C, 0x094D, 0x09BC, 0x09BE, 0x09BF,
            0x09D7, 0x0A02, 0x0A3C, 0x0A3E, 0x0A3F, 0x0ABC, 0x0B3C, 0x0BD7,
            0x0D57, 0x0E31, 0x0EB1, 0x0F35, 0x0F37, 0x0F39, 0x0F3E, 0x0F3F,
            0x0F97, 0x0FB9, 0x20E1, 0x3099, 0x309A,
        };

        
        
        

        int digitRange[] = {
            0x0030, 0x0039, 0x0660, 0x0669, 0x06F0, 0x06F9, 0x0966, 0x096F,
            0x09E6, 0x09EF, 0x0A66, 0x0A6F, 0x0AE6, 0x0AEF, 0x0B66, 0x0B6F,
            0x0BE7, 0x0BEF, 0x0C66, 0x0C6F, 0x0CE6, 0x0CEF, 0x0D66, 0x0D6F,
            0x0E50, 0x0E59, 0x0ED0, 0x0ED9, 0x0F20, 0x0F29,
        };

        
        
        

        int extenderRange[] = {
            0x3031, 0x3035, 0x309D, 0x309E, 0x30FC, 0x30FE,
        };

        int extenderChar[] = {
            0x00B7, 0x02D0, 0x02D1, 0x0387, 0x0640, 0x0E46, 0x0EC6, 0x3005,
        };

        
        
', '
', ']'
        

        int specialChar[] = {
            '<', '&', '
', '
', ']',
        };

        
        
        

        
        for (int i = 0; i < charRange.length; i += 2) {
            for (int j = charRange[i]; j <= charRange[i + 1]; j++) {
                CHARS[j] |= MASK_VALID | MASK_CONTENT;
            }
        }

        
        for (int i = 0; i < specialChar.length; i++) {
            CHARS[specialChar[i]] = (byte)(CHARS[specialChar[i]] & ~MASK_CONTENT);
        }

        
        for (int i = 0; i < spaceChar.length; i++) {
            CHARS[spaceChar[i]] |= MASK_SPACE;
        }

        
        for (int i = 0; i < nameStartChar.length; i++) {
            CHARS[nameStartChar[i]] |= MASK_NAME_START | MASK_NAME | 
                                       MASK_NCNAME_START | MASK_NCNAME;
        }
        for (int i = 0; i < letterRange.length; i += 2) {
            for (int j = letterRange[i]; j <= letterRange[i + 1]; j++) {
                CHARS[j] |= MASK_NAME_START | MASK_NAME |
                            MASK_NCNAME_START | MASK_NCNAME;
            }
        }
        for (int i = 0; i < letterChar.length; i++) {
            CHARS[letterChar[i]] |= MASK_NAME_START | MASK_NAME |
                                    MASK_NCNAME_START | MASK_NCNAME;
        }

        
        for (int i = 0; i < nameChar.length; i++) {
            CHARS[nameChar[i]] |= MASK_NAME | MASK_NCNAME;
        }
        for (int i = 0; i < digitRange.length; i += 2) {
            for (int j = digitRange[i]; j <= digitRange[i + 1]; j++) {
                CHARS[j] |= MASK_NAME | MASK_NCNAME;
            }
        }
        for (int i = 0; i < combiningCharRange.length; i += 2) {
            for (int j = combiningCharRange[i]; j <= combiningCharRange[i + 1]; j++) {
                CHARS[j] |= MASK_NAME | MASK_NCNAME;
            }
        }
        for (int i = 0; i < combiningCharChar.length; i++) {
            CHARS[combiningCharChar[i]] |= MASK_NAME | MASK_NCNAME;
        }
        for (int i = 0; i < extenderRange.length; i += 2) {
            for (int j = extenderRange[i]; j <= extenderRange[i + 1]; j++) {
                CHARS[j] |= MASK_NAME | MASK_NCNAME;
            }
        }
        for (int i = 0; i < extenderChar.length; i++) {
            CHARS[extenderChar[i]] |= MASK_NAME | MASK_NCNAME;
        }

        
        CHARS[':'] &= ~(MASK_NCNAME_START | MASK_NCNAME);

        
        for (int i = 0; i < pubidChar.length; i++) {
            CHARS[pubidChar[i]] |= MASK_PUBID;
        }
        for (int i = 0; i < pubidRange.length; i += 2) {
            for (int j = pubidRange[i]; j <= pubidRange[i + 1]; j++) {
                CHARS[j] |= MASK_PUBID;
            }
        }

    } 

    
    
    

    
    public static boolean isSupplemental(int c) {
        return (c >= 0x10000 && c <= 0x10FFFF);
    }

    
    public static int supplemental(char h, char l) {
        return (h - 0xD800) * 0x400 + (l - 0xDC00) + 0x10000;
    }

    
    public static char highSurrogate(int c) {
        return (char) (((c - 0x00010000) >> 10) + 0xD800);
    }

    
    public static char lowSurrogate(int c) {
        return (char) (((c - 0x00010000) & 0x3FF) + 0xDC00);
    }

    
    public static boolean isHighSurrogate(int c) {
        return (0xD800 <= c && c <= 0xDBFF);
    }

    
    public static boolean isLowSurrogate(int c) {
        return (0xDC00 <= c && c <= 0xDFFF);
    }


    
    public static boolean isValid(int c) {
        return (c < 0x10000 && (CHARS[c] & MASK_VALID) != 0) ||
               (0x10000 <= c && c <= 0x10FFFF);
    } 

    
    public static boolean isInvalid(int c) {
        return !isValid(c);
    } 

    
    public static boolean isContent(int c) {
        return (c < 0x10000 && (CHARS[c] & MASK_CONTENT) != 0) ||
               (0x10000 <= c && c <= 0x10FFFF);
    } 

    
    public static boolean isMarkup(int c) {
        return c == '<' || c == '&' || c == '%';
    } 

    
    public static boolean isSpace(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_SPACE) != 0;
    } 

    
    public static boolean isNameStart(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_NAME_START) != 0;
    } 

    
    public static boolean isName(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_NAME) != 0;
    } 

    
    public static boolean isNCNameStart(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_NCNAME_START) != 0;
    } 

    
    public static boolean isNCName(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_NCNAME) != 0;
    } 

    
    public static boolean isPubid(int c) {
        return c < 0x10000 && (CHARS[c] & MASK_PUBID) != 0;
    } 

    
    
    public static boolean isValidName(String name) {
        if (name.length() == 0)
            return false;
        char ch = name.charAt(0);
        if( isNameStart(ch) == false)
           return false;
        for (int i = 1; i < name.length(); i++ ) {
           ch = name.charAt(i);
           if( isName( ch ) == false ){
              return false;
           }
        }
        return true;
    } 
    

    
    
    public static boolean isValidNCName(String ncName) {
        if (ncName.length() == 0)
            return false;
        char ch = ncName.charAt(0);
        if( isNCNameStart(ch) == false)
           return false;
        for (int i = 1; i < ncName.length(); i++ ) {
           ch = ncName.charAt(i);
           if( isNCName( ch ) == false ){
              return false;
           }
        }
        return true;
    } 

    
    
    public static boolean isValidNmtoken(String nmtoken) {
        if (nmtoken.length() == 0)
            return false;
        for (int i = 0; i < nmtoken.length(); i++ ) {
           char ch = nmtoken.charAt(i);
           if(  ! isName( ch ) ){
              return false;
           }
        }
        return true;
    } 





    

    
    public static boolean isValidIANAEncoding(String ianaEncoding) {
        if (ianaEncoding != null) {
            int length = ianaEncoding.length();
            if (length > 0) {
                char c = ianaEncoding.charAt(0);
                if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
                    for (int i = 1; i < length; i++) {
                        c = ianaEncoding.charAt(i);
                        if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                            (c < '0' || c > '9') && c != '.' && c != '_' &&
                            c != '-') {
                            return false;
                        }
                    }
                    return true;
                }
            }
        }
        return false;
    } 

    
    public static boolean isValidJavaEncoding(String javaEncoding) {
        if (javaEncoding != null) {
            int length = javaEncoding.length();
            if (length > 0) {
                for (int i = 1; i < length; i++) {
                    char c = javaEncoding.charAt(i);
                    if ((c < 'A' || c > 'Z') && (c < 'a' || c > 'z') &&
                        (c < '0' || c > '9') && c != '.' && c != '_' &&
                        c != '-') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    } 

} 
"
org.apache.xalan.extensions.ExtensionHandlerGeneral,7,2,0,15,50,11,0,15,5,0.911111111,555,0.866666667,0,0.545454545,0.351851852,0,0,76.14285714,2,1.0,1,"
package org.apache.xalan.extensions;

import java.util.Hashtable;
import java.util.Vector;

import java.io.IOException;
import java.net.URL;
import java.net.URLConnection;
import java.io.InputStream;



import org.apache.xml.dtm.DTM;

import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.SystemIDResolver;

import javax.xml.transform.TransformerException;


import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.XPathProcessorException;
import org.apache.xml.utils.StringVector;

import java.lang.reflect.Method;

import org.apache.xml.dtm.ref.DTMNodeIterator;
import org.apache.xml.dtm.ref.DTMNodeList;
import org.apache.xml.dtm.DTMIterator;


public class ExtensionHandlerGeneral extends ExtensionHandler
{

  
  private String m_scriptSrc;   

  
  private String m_scriptSrcURL;  

  
  private Hashtable m_functions = new Hashtable();  

  
  private Hashtable m_elements = new Hashtable();   

  
  

  
  private Object m_mgr;  

  
  private Object m_engine;  

  

  
  private static final String BSF_MANAGER = ""com.ibm.bsf.BSFManager"";

  
  private static Class managerClass;

  
  private static Method mgrLoadScriptingEngine;

  
  private static final String BSF_ENGINE = ""com.ibm.bsf.BSFEngine"";

  
  private static Method engineExec;   

  
  private static Method engineCall;   

  
  private static final Integer NEG1INT = new Integer(-1);

  static
  {
    try
    {
      
                        managerClass = ExtensionHandler.getClassForName(BSF_MANAGER);
      mgrLoadScriptingEngine = managerClass.getMethod(""loadScriptingEngine"",
              new Class[]{ String.class });

      
                        Class engineClass = ExtensionHandler.getClassForName(BSF_ENGINE);

      engineExec = engineClass.getMethod(""exec"", new Class[]{ String.class,
                                                              Integer.TYPE,
                                                              Integer.TYPE,
                                                              Object.class });
      engineCall = engineClass.getMethod(""call"", new Class[]{ Object.class,
                                                              String.class,
                                                              Class.forName(
                                                                ""[Ljava.lang.Object;"") });
    }
    catch (Exception e)
    {
      managerClass = null;
      mgrLoadScriptingEngine = null;
      engineExec = null;
      engineCall = null;

      e.printStackTrace();
    }
  }

  
  public ExtensionHandlerGeneral(
          String namespaceUri, StringVector elemNames, StringVector funcNames, String scriptLang, String scriptSrcURL, String scriptSrc, String systemId)
            throws TransformerException
  {

    super(namespaceUri, scriptLang);

    if (elemNames != null)
    {
      Object junk = new Object();
      int n = elemNames.size();

      for (int i = 0; i < n; i++)
      {
        String tok = elemNames.elementAt(i);

        m_elements.put(tok, junk);  
      }
    }

    if (funcNames != null)
    {
      Object junk = new Object();
      int n = funcNames.size();

      for (int i = 0; i < n; i++)
      {
        String tok = funcNames.elementAt(i);

        m_functions.put(tok, junk);  
      }
    }

    m_scriptSrcURL = scriptSrcURL;
    m_scriptSrc = scriptSrc;

    if (m_scriptSrcURL != null)
    {
      URL url = null;
      try{
        url = new URL(m_scriptSrcURL);
      }
      catch (java.net.MalformedURLException mue)
      {
        int indexOfColon = m_scriptSrcURL.indexOf(':');
        int indexOfSlash = m_scriptSrcURL.indexOf('/');

        if ((indexOfColon != -1) && (indexOfSlash != -1)
            && (indexOfColon < indexOfSlash))
        {
          
          url = null;
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_FIND_EXTERN_SCRIPT, new Object[]{m_scriptSrcURL}), mue); 
          
        }
        else
        {
          try{
            url = new URL(new URL(SystemIDResolver.getAbsoluteURI(systemId)), m_scriptSrcURL);          
          }        
          catch (java.net.MalformedURLException mue2)
          {
            throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_FIND_EXTERN_SCRIPT, new Object[]{m_scriptSrcURL}), mue2); 
          
          }
        }
      }
      if (url != null)
      {
        try
        {
          URLConnection uc = url.openConnection();
          InputStream is = uc.getInputStream();
          byte []bArray = new byte[uc.getContentLength()];
          is.read(bArray);
          m_scriptSrc = new String(bArray);
          
        }
        catch (IOException ioe)
        {
          throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_FIND_EXTERN_SCRIPT, new Object[]{m_scriptSrcURL}), ioe); 
          
        }
      }
      
    }
   
    if (null == managerClass)
      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_INIT_BSFMGR, null)); 

    try
    {
      m_mgr = managerClass.newInstance();
      m_engine = mgrLoadScriptingEngine.invoke(m_mgr,
                                               new Object[]{ scriptLang });

      
      engineExec.invoke(m_engine, new Object[]{ ""XalanScript"", NEG1INT,
                                                NEG1INT, m_scriptSrc });
    }
    catch (Exception e)
    {
      e.printStackTrace();

      throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_CMPL_EXTENSN, null), e); 
    }
  }

  
  public boolean isFunctionAvailable(String function)
  {
    return (m_functions.get(function) != null);
  }

  
  public boolean isElementAvailable(String element)
  {
    return (m_elements.get(element) != null);
  }

  
  public Object callFunction(
          String funcName, Vector args, Object methodKey, ExpressionContext exprContext)
            throws TransformerException
  {

    Object[] argArray;

    try
    {
      argArray = new Object[args.size()];

      for (int i = 0; i < argArray.length; i++)
      {
        Object o = args.elementAt(i);

        argArray[i] = (o instanceof XObject) ? ((XObject) o).object() : o;
        o = argArray[i];
        if(null != o && o instanceof DTMIterator)
        {
          argArray[i] = new DTMNodeList((DTMIterator)o);
        }
      }

      return engineCall.invoke(m_engine, new Object[]{ null, funcName,
                                                       argArray });
    }
    catch (Exception e)
    {
      e.printStackTrace();

      String msg = e.getMessage();

      if (null != msg)
      {
        if (msg.startsWith(""Stopping after fatal error:""))
        {
          msg = msg.substring(""Stopping after fatal error:"".length());
        }

        
        throw new TransformerException(e);
      }
      else
      {

        
        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_CREATE_EXTENSN, new Object[]{funcName, e })); 
                               
      }
    }
  }

  
  public void processElement(
          String localPart, ElemTemplateElement element, TransformerImpl transformer, 
          Stylesheet stylesheetTree, Object methodKey)
            throws TransformerException, IOException
  {

    Object result = null;
    XSLProcessorContext xpc = new XSLProcessorContext(transformer, stylesheetTree);

    try
    {
      Vector argv = new Vector(2);

      argv.addElement(xpc);
      argv.addElement(element);

      result = callFunction(localPart, argv, methodKey,
                            transformer.getXPathContext().getExpressionContext());
    }
    catch (XPathProcessorException e)
    {

      
      throw new TransformerException(e.getMessage(), e);
    }

    if (result != null)
    {
      xpc.outputToResultTree(stylesheetTree, result);
    }
  }
}
"
org.apache.xalan.xsltc.runtime.output.StreamUnknownOutput,22,3,0,10,55,0,1,9,21,0.55952381,460,1.0,1,0.6875,0.25,2,2,19.36363636,1,0.9091,0,"

package org.apache.xalan.xsltc.runtime.output;

import java.util.ArrayList;

import java.io.Writer;
import java.io.IOException;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;

import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.runtime.*;
import org.apache.xalan.xsltc.runtime.Hashtable;

public class StreamUnknownOutput extends StreamOutput {

    private StreamOutput _handler;

    private boolean      _isHtmlOutput = false;
    private boolean      _firstTagOpen = false;
    private boolean      _firstElement = true;
    private String       _firstTagPrefix, _firstTag;

    private ArrayList    _attributes = null;
    private ArrayList    _namespaces = null;

    
    private String       _mediaType          = null;
    private boolean      _callStartDocument  = false;
    private boolean      _callSetVersion     = false;
    private boolean      _callSetDoctype     = false;

    static class Pair {
	public String name, value;

	public Pair(String name, String value) {
	    this.name = name;
	    this.value = value;
	}
    }

    public StreamUnknownOutput(Writer writer, String encoding) {
	super(writer, encoding);
	_handler = new StreamXMLOutput(writer, encoding);

    }

    public StreamUnknownOutput(OutputStream out, String encoding) 
	throws IOException
    {
	super(out, encoding);
	_handler = new StreamXMLOutput(out, encoding);

    }

    public void startDocument() 
	throws TransletException 
    { 
	_callStartDocument = true;
    }

    public void endDocument() 
	throws TransletException 
    { 
	if (_firstTagOpen) {
	    initStreamOutput();
	}
	else if (_callStartDocument) {
	    _handler.startDocument();
	}
	_handler.endDocument();
    }

    public void startElement(String elementName) 
	throws TransletException 
    { 

	if (_firstElement) {
	    _firstElement = false;

	    _firstTag = elementName;
	    _firstTagPrefix = BasisLibrary.getPrefix(elementName);
	    if (_firstTagPrefix == null) {
		_firstTagPrefix = EMPTYSTRING;
	    }

	    _firstTagOpen = true;
	    _isHtmlOutput = BasisLibrary.getLocalName(elementName)
				        .equalsIgnoreCase(""html"");
	}
	else {
	    if (_firstTagOpen) {
		initStreamOutput();
	    }
	    _handler.startElement(elementName);
	}
    }

    public void endElement(String elementName) 
	throws TransletException 
    { 
	if (_firstTagOpen) {
	    initStreamOutput();
	}
	_handler.endElement(elementName);
    }

    public void characters(String characters) 
	throws TransletException 
    { 
	if (_firstTagOpen) {
	    initStreamOutput();
	}
	_handler.characters(characters);
    }

    public void characters(char[] characters, int offset, int length)
	throws TransletException 
    { 
	if (_firstTagOpen) {
	    initStreamOutput();
	}
	_handler.characters(characters, offset, length);
    }

    public void attribute(String name, String value)
	throws TransletException 
    { 
	if (_firstTagOpen) {
	    if (_attributes == null) {
		_attributes = new ArrayList();
	    }
	    _attributes.add(new Pair(name, value));
	}
	else {
	    _handler.attribute(name, value);
	}
    }

    public void namespace(String prefix, String uri)
	throws TransletException 
    {

	if (_firstTagOpen) {
	    if (_namespaces == null) {
		_namespaces = new ArrayList();
	    }
	    _namespaces.add(new Pair(prefix, uri));

	    
	    if (_firstTagPrefix.equals(prefix) && !uri.equals(EMPTYSTRING)) {
		_isHtmlOutput = false;
	    }
	}
	else {
	    _handler.namespace(prefix, uri);
	}
    }

    public void comment(String comment) 
	throws TransletException 
    { 
	if (_firstTagOpen) {
	    initStreamOutput();
	}
	_handler.comment(comment);
    }

    public void processingInstruction(String target, String data)
	throws TransletException 
    { 
	if (_firstTagOpen) {
	    initStreamOutput();
	}
	_handler.processingInstruction(target, data);
    }

    public void setDoctype(String system, String pub) {
	_handler.setDoctype(system, pub);

	
	super.setDoctype(system, pub);
	_callSetDoctype = true;
    }

    
    public void setIndent(boolean indent) { 
	_handler.setIndent(indent);
    }

    public void setVersion(String version) { 
	_handler.setVersion(version);

	
	super.setVersion(version);
	_callSetVersion = true;
    }

    public void omitHeader(boolean value) {
	_handler.omitHeader(value);
    }

    public void setStandalone(String standalone) {
	_handler.setStandalone(standalone);
    }

    public void setMediaType(String mediaType) { 
	_handler.setMediaType(mediaType);
	_mediaType = mediaType;
    }

    public boolean setEscaping(boolean escape) 
	throws TransletException 
    { 
	return _handler.setEscaping(escape);
    }

    public void setCdataElements(Hashtable elements) { 
	_handler.setCdataElements(elements);
    }

    public void setIndentNumber(int value) {
	_handler.setIndentNumber(value);
    }

    private void initStreamOutput() 
	throws TransletException 
    {

	
	if (_isHtmlOutput) {
	    _handler = new StreamHTMLOutput(_handler);

	    if (_callSetVersion) {
		_handler.setVersion(_version);
	    }
	    if (_callSetDoctype) {
		_handler.setDoctype(_doctypeSystem, _doctypePublic);
	    }
	    if (_mediaType != null) {
		_handler.setMediaType(_mediaType);
	    }
	}

	
	if (_callStartDocument) {
	    _handler.startDocument();
	    _callStartDocument = false;
	}

	
	_handler.startElement(_firstTag);

	
	if (_namespaces != null) {
	    final int n = _namespaces.size();
	    for (int i = 0; i < n; i++) {
		final Pair pair = (Pair) _namespaces.get(i);
		_handler.namespace(pair.name, pair.value);
	    }
	}

	
	if (_attributes != null) {
	    final int n = _attributes.size();
	    for (int i = 0; i < n; i++) {
		final Pair pair = (Pair) _attributes.get(i);
		_handler.attribute(pair.name, pair.value);
	    }
	}

	
	_firstTagOpen = false;
    }
}
"
org.apache.xalan.templates.DecimalFormatProperties,25,3,0,6,49,0,4,3,25,0.520833333,161,0.5,1,0.890909091,0.253333333,1,1,5.36,2,1.0,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;

import org.apache.xpath.*;

import java.util.*;

import java.text.NumberFormat;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;

import org.apache.xml.utils.QName;
import org.apache.xalan.res.*;
import org.apache.xalan.transformer.TransformerImpl;


public class DecimalFormatProperties extends ElemTemplateElement
{

  
  DecimalFormatSymbols m_dfs;

  
  public DecimalFormatProperties(int docOrderNumber)
  {

    m_dfs = new java.text.DecimalFormatSymbols();

    
    m_dfs.setInfinity(Constants.ATTRVAL_INFINITY);
    m_dfs.setNaN(Constants.ATTRVAL_NAN);

    m_docOrderNumber = docOrderNumber;
  }

  
  public DecimalFormatSymbols getDecimalFormatSymbols()
  {
    return m_dfs;
  }

  
  private QName m_qname = null;

  
  public void setName(QName qname)
  {
    m_qname = qname;
  }

  
  public QName getName()
  {

    if (m_qname == null)
      return new QName("""");
    else
      return m_qname;
  }

  
  public void setDecimalSeparator(char ds)
  {
    m_dfs.setDecimalSeparator(ds);
  }

  
  public char getDecimalSeparator()
  {
    return m_dfs.getDecimalSeparator();
  }

  
  public void setGroupingSeparator(char gs)
  {
    m_dfs.setGroupingSeparator(gs);
  }

  
  public char getGroupingSeparator()
  {
    return m_dfs.getGroupingSeparator();
  }

  
  public void setInfinity(String inf)
  {
    m_dfs.setInfinity(inf);
  }

  
  public String getInfinity()
  {
    return m_dfs.getInfinity();
  }

  
  public void setMinusSign(char v)
  {
    m_dfs.setMinusSign(v);
  }

  
  public char getMinusSign()
  {
    return m_dfs.getMinusSign();
  }

  
  public void setNaN(String v)
  {
    m_dfs.setNaN(v);
  }

  
  public String getNaN()
  {
    return m_dfs.getNaN();
  }

  
  public void setPercent(char v)
  {
    m_dfs.setPercent(v);
  }

  
  public char getPercent()
  {
    return m_dfs.getPercent();
  }

  
  public void setPerMille(char v)
  {
    m_dfs.setPerMill(v);
  }

  
  public char getPerMille()
  {
    return m_dfs.getPerMill();
  }

  
  public void setZeroDigit(char v)
  {
    m_dfs.setZeroDigit(v);
  }

  
  public char getZeroDigit()
  {
    return m_dfs.getZeroDigit();
  }

  
  public void setDigit(char v)
  {
    m_dfs.setDigit(v);
  }

  
  public char getDigit()
  {
    return m_dfs.getDigit();
  }

  
  public void setPatternSeparator(char v)
  {
    m_dfs.setPatternSeparator(v);
  }

  
  public char getPatternSeparator()
  {
    return m_dfs.getPatternSeparator();
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeDecimalFormats(this);
  }

}
"
org.apache.xalan.transformer.TransformSnapshotImpl,2,1,0,13,34,0,1,13,0,0.066666667,283,0.866666667,6,0.0,1.0,0,0,133.0,4,2.0,1,"
package org.apache.xalan.transformer;

import org.apache.xpath.XPathContext;
import org.apache.xpath.VariableStack;
import org.apache.xpath.axes.ContextNodeList;
import org.apache.xml.utils.NodeVector;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xalan.templates.ElemTemplateElement;

import java.util.Stack;

import org.xml.sax.helpers.NamespaceSupport;
import org.apache.xml.utils.NamespaceSupport2;

import java.util.Enumeration;


class TransformSnapshotImpl implements TransformSnapshot
{

  
  private VariableStack m_variableStacks;

  
  private int[] m_currentNodes;

  
  private int[] m_currentExpressionNodes;

  
  private Stack m_contextNodeLists;

  
  private DTMIterator m_contextNodeList;

  
  private Stack m_axesIteratorStack;

  
  private BoolStack m_currentTemplateRuleIsNull;

  
  private ElemTemplateElement[] m_currentTemplateElements;

  
  private Stack m_currentMatchTemplates;

  
  private NodeVector m_currentMatchNodes;

  
  private CountersTable m_countersTable;

  
  private Stack m_attrSetStack;

  
  boolean m_nsContextPushed;

  
  private NamespaceSupport m_nsSupport;

  
  int m_eventCount;

  
  TransformSnapshotImpl(TransformerImpl transformer)
  {

    try
    {

      
      ResultTreeHandler rtf = transformer.getResultTreeHandler();

      m_eventCount = rtf.m_eventCount;

      
      m_nsSupport = new NamespaceSupport2();

      Enumeration prefixes = rtf.m_nsSupport.getPrefixes();

      while (prefixes.hasMoreElements())
      {
        String prefix = (String) prefixes.nextElement();
        String uri = rtf.m_nsSupport.getURI(prefix);

        m_nsSupport.declarePrefix(prefix, uri);
      }

      m_nsContextPushed = rtf.m_nsContextPushed;

      XPathContext xpc = transformer.getXPathContext();

      m_variableStacks = (VariableStack) xpc.getVarStack().clone();
      m_currentNodes = (int[]) xpc.getCurrentNodeStack().clone();
      m_currentExpressionNodes =
        (int[]) xpc.getCurrentExpressionNodeStack().clone();
      m_contextNodeLists = (Stack) xpc.getContextNodeListsStack().clone();

      if (!m_contextNodeLists.empty())
        m_contextNodeList =
          (DTMIterator) xpc.getContextNodeList().clone();

      m_axesIteratorStack = (Stack) xpc.getAxesIteratorStackStacks().clone();
      m_currentTemplateRuleIsNull =
        (BoolStack) transformer.m_currentTemplateRuleIsNull.clone();
      m_currentTemplateElements =
        (ElemTemplateElement[]) transformer.m_currentTemplateElements.clone();
      m_currentMatchTemplates =
        (Stack) transformer.m_currentMatchTemplates.clone();
      m_currentMatchNodes =
        (NodeVector) transformer.m_currentMatchedNodes.clone();
      m_countersTable =
        (CountersTable) transformer.getCountersTable().clone();

      if (transformer.m_attrSetStack != null)
        m_attrSetStack = (Stack) transformer.m_attrSetStack.clone();
    }
    catch (CloneNotSupportedException cnse)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(cnse);
    }
  }

  
  void apply(TransformerImpl transformer)
  {

    try
    {

      
      ResultTreeHandler rtf = transformer.getResultTreeHandler();

      if (rtf != null)
      {
        rtf.m_eventCount = 1;  

        
        rtf.m_nsSupport = new NamespaceSupport();

        Enumeration prefixes = m_nsSupport.getPrefixes();

        while (prefixes.hasMoreElements())
        {
          String prefix = (String) prefixes.nextElement();
          String uri = m_nsSupport.getURI(prefix);

          rtf.m_nsSupport.declarePrefix(prefix, uri);
        }

        rtf.m_nsContextPushed = m_nsContextPushed;
      }

      XPathContext xpc = transformer.getXPathContext();

      xpc.setVarStack((VariableStack) m_variableStacks.clone());
      xpc.setCurrentNodeStack((int[]) m_currentNodes.clone());
      xpc.setCurrentExpressionNodeStack(
        (int[]) m_currentExpressionNodes.clone());
      xpc.setContextNodeListsStack((Stack) m_contextNodeLists.clone());

      if (m_contextNodeList != null)
        xpc.pushContextNodeList((DTMIterator) m_contextNodeList.clone());

      xpc.setAxesIteratorStackStacks((Stack) m_axesIteratorStack.clone());

      transformer.m_currentTemplateRuleIsNull =
        (BoolStack) m_currentTemplateRuleIsNull.clone();
      transformer.m_currentTemplateElements =
        (ElemTemplateElement[]) m_currentTemplateElements.clone();
      transformer.m_currentMatchTemplates =
        (Stack) m_currentMatchTemplates.clone();
      transformer.m_currentMatchedNodes =
        (NodeVector) m_currentMatchNodes.clone();
      transformer.m_countersTable = (CountersTable) m_countersTable.clone();

      if (m_attrSetStack != null)
        transformer.m_attrSetStack = (Stack) m_attrSetStack.clone();
    }
    catch (CloneNotSupportedException cnse)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(cnse);
    }
  }
}
"
org.apache.xml.utils.DefaultErrorHandler,13,1,1,13,36,58,10,3,13,0.666666667,260,0.0,0,0.0,0.307692308,0,0,18.92307692,11,2.0,0,"
package org.apache.xml.utils;

import org.xml.sax.*;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.TransformerException;
import javax.xml.transform.SourceLocator;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
 
import java.io.PrintWriter;
import java.io.PrintStream;



public class DefaultErrorHandler implements ErrorHandler, ErrorListener
{
  PrintWriter m_pw;

  
  public DefaultErrorHandler(PrintWriter pw)
  {
    m_pw = pw;
  }
  
  
  public DefaultErrorHandler(PrintStream pw)
  {
    m_pw = new PrintWriter(pw, true);
  }
  
  
  public DefaultErrorHandler()
  {
    m_pw = new PrintWriter(System.err, true);
  }


  
  public void warning(SAXParseException exception) throws SAXException
  {
    printLocation(m_pw, exception);
    m_pw.println(""Parser warning: "" + exception.getMessage());
  }

  
  public void error(SAXParseException exception) throws SAXException
  {
    
    

    throw exception;
  }

  
  public void fatalError(SAXParseException exception) throws SAXException
  {
    
    

    throw exception;
  }
  
  
  public void warning(TransformerException exception) throws TransformerException
  {
    printLocation(m_pw, exception);

    m_pw.println(exception.getMessage());
  }

  
  public void error(TransformerException exception) throws TransformerException
  {
    
    

    throw exception;
  }

  
  public void fatalError(TransformerException exception) throws TransformerException
  {
    
    

    throw exception;
  }
  
  public static void ensureLocationSet(TransformerException exception)
  {
    
    SourceLocator locator = null;
    Throwable cause = exception;
    
    
    do
    {
      if(cause instanceof SAXParseException)
      {
        locator = new SAXSourceLocator((SAXParseException)cause);
      }
      else if (cause instanceof TransformerException)
      {
        SourceLocator causeLocator = ((TransformerException)cause).getLocator();
        if(null != causeLocator)
          locator = causeLocator;
      }
      
      if(cause instanceof TransformerException)
        cause = ((TransformerException)cause).getCause();
      else if(cause instanceof SAXException)
        cause = ((SAXException)cause).getException();
      else
        cause = null;
    }
    while(null != cause);
    
    exception.setLocator(locator);
  }
  
  public static void printLocation(PrintStream pw, TransformerException exception)
  {
    printLocation(new PrintWriter(pw), exception);
  }
  
  public static void printLocation(java.io.PrintStream pw, org.xml.sax.SAXParseException exception)
  {
    printLocation(new PrintWriter(pw), exception);
  }
  
  public static void printLocation(PrintWriter pw, Throwable exception)
  {
    SourceLocator locator = null;
    Throwable cause = exception;
    
    
    do
    {
      if(cause instanceof SAXParseException)
      {
        locator = new SAXSourceLocator((SAXParseException)cause);
      }
      else if (cause instanceof TransformerException)
      {
        SourceLocator causeLocator = ((TransformerException)cause).getLocator();
        if(null != causeLocator)
          locator = causeLocator;
      }
      if(cause instanceof TransformerException)
        cause = ((TransformerException)cause).getCause();
      else if(cause instanceof WrappedRuntimeException)
        cause = ((WrappedRuntimeException)cause).getException();
      else if(cause instanceof SAXException)
        cause = ((SAXException)cause).getException();
      else
        cause = null;
    }
    while(null != cause);
        
    if(null != locator)
    {
      
      String id = (null != locator.getPublicId() )
                  ? locator.getPublicId()
                    : (null != locator.getSystemId())
                      ? locator.getSystemId() : XSLMessages.createMessage(XSLTErrorResources.ER_SYSTEMID_UNKNOWN, null); 

      pw.print(id + ""; "" +XSLMessages.createMessage(""line"", null) + locator.getLineNumber()
                         + ""; "" +XSLMessages.createMessage(""column"", null) + locator.getColumnNumber()+""; "");
    }
    else
      pw.print(""(""+XSLMessages.createMessage(XSLTErrorResources.ER_LOCATION_UNKNOWN, null)+"")"");
  }
}
"
org.apache.xalan.xsltc.compiler.util.NodeType,22,2,0,46,54,211,14,35,20,0.619047619,452,1.0,0,0.622641509,0.215909091,2,4,19.5,7,1.3182,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.NodeTest;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.Constants;

public final class NodeType extends Type {
    private final int _type;

    protected NodeType() {
	this(NodeTest.ANODE);
    }

    protected NodeType(int type) {
	_type = type;
    }

    public int getType() {
	return _type;
    }

    public String toString() {
	return ""node-type"";
    }

    public boolean identicalTo(Type other) {
	return other instanceof NodeType;
    }

    public int hashCode() {
	return _type;
    }

    public String toSignature() {
	return ""I"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.INT;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.NodeSet) {
	    translateTo(classGen, methodGen, (NodeSetType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else if (type == Type.Object) {
	    translateTo(classGen, methodGen, (ObjectType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	switch (_type) {
	case NodeTest.ROOT:
	case NodeTest.ELEMENT:
	    il.append(methodGen.loadDOM());
	    il.append(SWAP); 
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  GET_ELEMENT_VALUE,
						  GET_ELEMENT_VALUE_SIG);
	    il.append(new INVOKEINTERFACE(index, 2));
	    break;

	case NodeTest.ANODE:
	case NodeTest.COMMENT:
	case NodeTest.ATTRIBUTE:
	case NodeTest.PI:
	    il.append(methodGen.loadDOM());
	    il.append(SWAP); 
	    index = cpg.addInterfaceMethodref(DOM_INTF,
					      GET_NODE_VALUE,
					      GET_NODE_VALUE_SIG);
	    il.append(new INVOKEINTERFACE(index, 2));
	    break;
	    
	default:
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	    break;
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	FlowList falsel = translateToDesynthesized(classGen, methodGen, type);
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsel.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	translateTo(classGen, methodGen, Type.String);
	Type.String.translateTo(classGen, methodGen, Type.Real);	
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    NodeSetType type) {
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();

	
	il.append(new NEW(cpg.addClass(SINGLETON_ITERATOR)));
	il.append(DUP_X1);
	il.append(SWAP);
	final int init = cpg.addMethodref(SINGLETON_ITERATOR, ""<init>"",
					  ""("" + NODE_SIG +"")V"");
	il.append(new INVOKESPECIAL(init));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ObjectType type) {
	    methodGen.getInstructionList().append(NOP);	
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new NEW(cpg.addClass(RUNTIME_NODE_CLASS)));
	il.append(DUP_X1);
	il.append(SWAP);
	il.append(new PUSH(cpg, _type));
	il.append(new INVOKESPECIAL(cpg.addMethodref(RUNTIME_NODE_CLASS,
						     ""<init>"", ""(II)V"")));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	il.append(methodGen.loadDOM());
	il.append(SWAP);		

	String className = clazz.getName();
	if (className.equals(""org.w3c.dom.Node"")) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE,
						  MAKE_NODE_SIG);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else if (className.equals(""org.w3c.dom.NodeList"")) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE_LIST,
						  MAKE_NODE_LIST_SIG);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), className);
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new CHECKCAST(cpg.addClass(RUNTIME_NODE_CLASS)));
	il.append(new GETFIELD(cpg.addFieldref(RUNTIME_NODE_CLASS,
					       NODE_FIELD,
					       NODE_FIELD_SIG)));
    }

    
    public String getClassName() {
	return(RUNTIME_NODE_CLASS);
    }

    public Instruction LOAD(int slot) {
	return new ILOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ISTORE(slot);
    }
}

"
org.apache.xpath.objects.XStringForChars,12,4,0,5,22,4,1,4,11,0.484848485,148,0.333333333,0,0.921875,0.25,3,15,11.08333333,2,1.0,0,"package org.apache.xpath.objects;

import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xml.utils.XMLCharacterRecognizer;

import org.apache.xalan.res.XSLMessages;
import org.apache.xpath.res.XPATHErrorResources;

import java.util.Locale;



public class XStringForChars extends XString
{
  
  int m_start;
  
  
  int m_length;
  
  protected String m_strCache = null;
  
  
  public XStringForChars(char[] val, int start, int length)
  {
    super(val);
    m_start = start;
    m_length = length;
    if(null == val)
      throw new IllegalArgumentException(
                          XSLMessages.createXPATHMessage(XPATHErrorResources.ER_FASTSTRINGBUFFER_CANNOT_BE_NULL, null)); 
  }


  
  private XStringForChars(String val)
  {
    super(val);
    throw new IllegalArgumentException(
                      XSLMessages.createXPATHMessage(XPATHErrorResources.ER_XSTRINGFORCHARS_CANNOT_TAKE_STRING, null)); 
  }
  
  
  public FastStringBuffer fsb()
  {
    throw new RuntimeException(XSLMessages.createXPATHMessage(XPATHErrorResources.ER_FSB_NOT_SUPPORTED_XSTRINGFORCHARS, null)); 
  }
  
  
  public void appendToFsb(org.apache.xml.utils.FastStringBuffer fsb)
  {
    fsb.append((char[])m_obj, m_start, m_length);
  }

  
  
  public boolean hasString()
  {
    return (null != m_strCache);
  }

  
  
  public String str()
  {
    if(null == m_strCache)
      m_strCache = new String((char[])m_obj, m_start, m_length);
    
    return m_strCache;
  }
  

  
  public Object object()
  {
    return str();
  }

  
  public void dispatchCharactersEvents(org.xml.sax.ContentHandler ch)
      throws org.xml.sax.SAXException
  {
    ch.characters((char[])m_obj, m_start, m_length);
  }
      
  
  public void dispatchAsComment(org.xml.sax.ext.LexicalHandler lh)
      throws org.xml.sax.SAXException
  {
    lh.comment((char[])m_obj, m_start, m_length);
  }
  
  
  public int length()
  {
    return m_length;
  }

  
  public char charAt(int index)
  {
    return ((char[])m_obj)[index+m_start];
  }

  
  public void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)
  {
    System.arraycopy((char[])m_obj, m_start+srcBegin, dst, dstBegin, srcEnd);
  }
  
}"
org.apache.xalan.xsltc.compiler.util.ClassGenerator,10,3,4,123,15,27,119,6,9,0.888888889,87,1.0,2,0.898734177,0.288888889,0,0,6.9,1,0.8,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.Constants;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Stylesheet;


public class ClassGenerator extends ClassGen {
    protected static int TRANSLET_INDEX = 0;
    protected static int INVALID_INDEX  = -1;

    private Stylesheet _stylesheet;
    private final Parser _parser;		
    
    private final Instruction _aloadTranslet;
    private final String _domClass;
    private final String _domClassSig;
    private final String _applyTemplatesSig;

    public ClassGenerator(String class_name, String super_class_name,
			  String file_name,
			  int access_flags, String[] interfaces,
			  Stylesheet stylesheet) {
	super(class_name, super_class_name, file_name,
	      access_flags, interfaces);
	_stylesheet = stylesheet;
	_parser = stylesheet.getParser();
	_aloadTranslet = new ALOAD(TRANSLET_INDEX);
	
	if (stylesheet.isMultiDocument()) {
	    _domClass = ""org.apache.xalan.xsltc.dom.MultiDOM"";
	    _domClassSig = ""Lorg/apache/xalan/xsltc/dom/MultiDOM;"";
	}
	else {
	    _domClass = ""org.apache.xalan.xsltc.dom.DOMAdapter"";
	    _domClassSig = ""Lorg/apache/xalan/xsltc/dom/DOMAdapter;"";
	}
	_applyTemplatesSig = ""("" 
	    + Constants.DOM_INTF_SIG
	    + Constants.NODE_ITERATOR_SIG
	    + Constants.TRANSLET_OUTPUT_SIG
	    + "")V""; 
    }

    public final Parser getParser() {
	return _parser;
    }

    public final Stylesheet getStylesheet() {
	return _stylesheet;
    }

    
    public final String getClassName() {
	return _stylesheet.getClassName();
    }

    public Instruction loadTranslet() {
	return _aloadTranslet;
    }

    public final String getDOMClass() {
	return _domClass;
    }

    public final String getDOMClassSig() {
	return _domClassSig;
    }

    public final String getApplyTemplatesSig() {
	return _applyTemplatesSig;
    }

    
    public boolean isExternal() {
	return false;
    }
}
"
org.apache.xalan.xsltc.util.JavaCupRedirect,3,1,0,1,15,3,0,1,3,1.5,124,1.0,0,0.0,0.333333333,0,0,40.0,6,2.6667,0,"

package org.apache.xalan.xsltc.util;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.InputStream;


public class JavaCupRedirect {

    private final static String ERRMSG = 
		 ""You must supply a filename with the -stdin option."";

    public static void main (String args[]) {

		 
         
		 boolean systemExitOK = true;

		 
		 InputStream input = null;

		 
		 final int argc = args.length;

		 
		 String[] new_args = new String[argc - 2];
		 int new_argc = 0;

		 
		 for (int i = 0; i < argc; i++) {
		     
		     if (args[i].equals(""-stdin"")) {
		 		 
		 		 if ((++i >= argc) || (args[i].startsWith(""-""))) {
		 		     System.err.println(ERRMSG);
		 		     doSystemExit(systemExitOK);
		 		 }
		 		 try {
		 		     input = new FileInputStream(args[i]);
		 		 }
		 		 catch (FileNotFoundException e) {
		 		     System.err.println(""Could not open file ""+args[i]);
		 		     doSystemExit(systemExitOK);
		 		 }
		 		 catch (SecurityException e) {
		 		     System.err.println(""No permission to file ""+args[i]);
		 		     doSystemExit(systemExitOK);
		 		 }
		     }
		     else {
		 		 if (new_argc == new_args.length) {
		 		     System.err.println(""Missing -stdin option!"");
		 		     doSystemExit(systemExitOK);
		 		 }
		 		 new_args[new_argc++] = args[i];
		     }
		 }

		 System.setIn(input);
		 try {
		     java_cup.Main.main(new_args);
		 }
		 catch (Exception e) {
		     System.err.println(""Error running JavaCUP:"");
		     e.printStackTrace();
		     doSystemExit(systemExitOK);
		 }
    }
    public static void doSystemExit (boolean doExit) {
        if (doExit)
            System.exit(-1);
    }
}"
org.apache.xalan.xsltc.compiler.KeyPattern,1,6,0,1,2,0,0,1,1,2.0,6,0.0,0,1.0,1.0,0,0,5.0,0,0.0,0,"

package org.apache.xalan.xsltc.compiler;

final class KeyPattern extends IdKeyPattern {

    public KeyPattern(String index, String value) {
	super(index,value);
    }    

}
"
org.apache.xpath.axes.ChildTestIterator,6,6,5,13,13,3,7,7,4,0.4,65,1.0,1,0.96969697,0.366666667,2,4,9.666666667,2,0.8333,1,"
package org.apache.xpath.axes;

import javax.xml.transform.TransformerException;

import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.patterns.NodeTest;
import org.apache.xpath.objects.XObject;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.Axis;


public class ChildTestIterator extends BasicTestIterator
{
  
  transient protected DTMAxisTraverser m_traverser;
  
  



  
  ChildTestIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis);
  }
  
  
  public ChildTestIterator(DTMAxisTraverser traverser)
  {

    super(null);

    m_traverser = traverser;
  }

  
  protected int getNextNode()
  {                     
    if(true )
    {
      m_lastFetched = (DTM.NULL == m_lastFetched)
                   ? m_traverser.first(m_context)
                   : m_traverser.next(m_context, m_lastFetched);
    }








    return m_lastFetched;
  }

  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    ChildTestIterator clone = (ChildTestIterator) super.cloneWithReset();
    clone.m_traverser = m_traverser;

    return clone;
  }
  

  
  public void setRoot(int context, Object environment)
  {
    super.setRoot(context, environment);
    m_traverser = m_cdtm.getAxisTraverser(Axis.CHILD);
    

















    
  }
  
  
  public int getAxis()
  {
    return org.apache.xml.dtm.Axis.CHILD;
  }


}
"
org.apache.xalan.xsltc.dom.SingletonIterator,8,2,1,6,11,0,4,2,8,0.214285714,105,1.0,0,0.666666667,0.5,1,6,11.875,4,1.125,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;

public class SingletonIterator extends NodeIteratorBase {
    private int _node;
    private final boolean _isConstant;

    public SingletonIterator() {
	this(Integer.MIN_VALUE, false);
    }

    public SingletonIterator(int node) {
	this(node, false);
    }

    public SingletonIterator(int node, boolean constant) {
	_node = _startNode = node;
	_isConstant = constant;
    }
    
    
    public NodeIterator setStartNode(int node) {
	if (_isConstant) {
	    _node = _startNode;
	    return resetPosition();
	}
	else if (_isRestartable) {
	    if (_node <= 0)
		_node = _startNode = node;
	    return resetPosition();
	}
	return this;
    }
	
    public NodeIterator reset() {
	if (_isConstant) {
	    _node = _startNode;
	    return resetPosition();
	}
	else {
	    final boolean temp = _isRestartable;
	    _isRestartable = true;
	    setStartNode(_startNode);
	    _isRestartable = temp;
	}
	return this;
    }
    
    public int next() {
	final int result = _node;
	_node = NodeIterator.END;
	return returnNode(result);
    }

    public void setMark() {
	_markedNode = _node;
    }

    public void gotoMark() {
	_node = _markedNode;
    }
}
"
org.apache.xpath.objects.XNumber,13,3,0,41,36,22,37,5,12,0.416666667,307,0.0,0,0.865853659,0.182692308,2,22,22.53846154,11,2.3077,2,"
package org.apache.xpath.objects;

import javax.xml.transform.TransformerException;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;


public class XNumber extends XObject
{

  
  double m_val;

  
  public XNumber(double d)
  {
    super();

    m_val = d;
  }
  
  
  public XNumber(Number num)
  {

    super();

    m_val = num.doubleValue();
    m_obj = num;
  }

  
  public int getType()
  {
    return CLASS_NUMBER;
  }

  
  public String getTypeString()
  {
    return ""#NUMBER"";
  }

  
  public double num()
  {
    return m_val;
  }
  
  
  public double num(XPathContext xctxt) 
    throws javax.xml.transform.TransformerException
  {

    return m_val;
  }

  
  public boolean bool()
  {
    return (Double.isNaN(m_val) || (m_val == 0.0)) ? false : true;
  }























































































































































  
  public String str()
  {

    if (Double.isNaN(m_val))
    {
      return ""NaN"";
    }
    else if (Double.isInfinite(m_val))
    {
      if (m_val > 0)
        return ""Infinity"";
      else
        return ""-Infinity"";
    }

    double num = m_val;
    String s = Double.toString(num);
    int len = s.length();

    if (s.charAt(len - 2) == '.' && s.charAt(len - 1) == '0')
    {
      s = s.substring(0, len - 2);

      if (s.equals(""-0""))
        return ""0"";

      return s;
    }

    int e = s.indexOf('E');

    if (e < 0)
      return s;

    int exp = Integer.parseInt(s.substring(e + 1));
    String sign;

    if (s.charAt(0) == '-')
    {
      sign = ""-"";
      s = s.substring(1);

      --e;
    }
    else
      sign = """";

    int nDigits = e - 2;

    if (exp >= nDigits)
      return sign + s.substring(0, 1) + s.substring(2, e)
             + zeros(exp - nDigits);

    if (exp > 0)
      return sign + s.substring(0, 1) + s.substring(2, 2 + exp) + "".""
             + s.substring(2 + exp, e);

    return sign + ""0."" + zeros(-1 - exp) + s.substring(0, 1)
           + s.substring(2, e);
  }


  
  static private String zeros(int n)
  {
    if (n < 1)
      return """";

    char[] buf = new char[n];

    for (int i = 0; i < n; i++)
    {
      buf[i] = '0';
    }

    return new String(buf);
  }

  
  public Object object()
  {
    if(null == m_obj)
      m_obj = new Double(m_val);
    return m_obj;
  }

  
  public boolean equals(XObject obj2)
  {

    
    
    
    int t = obj2.getType();
    try
    {
	    if (t == XObject.CLASS_NODESET)
	      return obj2.equals(this);
	    else if(t == XObject.CLASS_BOOLEAN)
	      return obj2.bool() == bool();
		else
	       return m_val == obj2.num();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }
  
  
  public boolean isStableNumber()
  {
    return true;
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	visitor.visitNumberLiteral(owner, this);
  }


}
"
org.apache.xpath.axes.RTFIterator,2,8,0,4,4,1,2,2,1,2.0,12,0.0,0,1.0,0.833333333,0,0,5.0,0,0.0,1,"
package org.apache.xpath.axes;

import javax.xml.transform.TransformerException;
import org.apache.xpath.compiler.Compiler;

public class RTFIterator extends OneStepIteratorForward {

	
	RTFIterator(Compiler compiler, int opPos, int analysis)
		throws TransformerException {
		super(compiler, opPos, analysis);
	}

	
	public RTFIterator(int axis) {
		super(axis);
	}

}

"
org.apache.xalan.processor.WhitespaceInfoPaths,4,5,0,5,6,0,2,3,3,0.333333333,23,1.0,0,0.986486486,0.5,0,0,4.5,1,0.75,0,"package org.apache.xalan.processor;

import org.apache.xalan.templates.WhiteSpaceInfo;
import java.util.Vector;
import org.apache.xalan.templates.Stylesheet;

public class WhitespaceInfoPaths extends WhiteSpaceInfo
{
	
  
  private Vector m_elements;

  
  public void setElements(Vector elems)
  {
    m_elements = elems;
  }

  
  Vector getElements()
  {
    return m_elements;
  }
  
  public void clearElements()
  {
  	m_elements = null;
  }

 
  public WhitespaceInfoPaths(Stylesheet thisSheet)
  {
  	super(thisSheet);
  	setStylesheet(thisSheet);
  }


}

"
org.apache.xalan.xsltc.compiler.util.IntType,27,3,0,48,58,351,8,42,26,2.0,393,0.0,0,0.573770492,0.202020202,1,3,13.55555556,8,1.6296,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.Constants;

public final class IntType extends NumberType {
    protected IntType() {}

    public String toString() {
	return ""int"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""I"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.INT;
    }

    
    public int distanceTo(Type type) {
	if (type == this) {
	    return 0;
	}
	else if (type == Type.Real) {
	    return 1;
	}
	else
	    return Integer.MAX_VALUE;
    }
    
    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    final Type type) {
	if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	methodGen.getInstructionList().append(I2D);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKESTATIC(cpg.addMethodref(INTEGER_CLASS,
						    ""toString"",
						    ""(I)"" + STRING_SIG)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	final BranchHandle falsec = il.append(new IFEQ(null));
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsec.setTarget(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new NEW(cpg.addClass(INTEGER_CLASS)));
	il.append(DUP_X1);
	il.append(SWAP);
	il.append(new INVOKESPECIAL(cpg.addMethodref(INTEGER_CLASS,
						     ""<init>"", ""(I)V"")));
    }


    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	final InstructionList il = methodGen.getInstructionList();
	if (clazz == Character.TYPE) {
	    il.append(I2C);
	}
	else if (clazz == Byte.TYPE) {
	    il.append(I2B);
	}
	else if (clazz == Short.TYPE) {
	    il.append(I2S);
	}
	else if (clazz == Integer.TYPE) {
	    il.append(NOP);
	}
	else if (clazz == Long.TYPE) {
	    il.append(I2L);
	}
	else if (clazz == Float.TYPE) {
	    il.append(I2F);
	}
	else if (clazz == Double.TYPE) {
	    il.append(I2D);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new CHECKCAST(cpg.addClass(INTEGER_CLASS)));
	final int index = cpg.addMethodref(INTEGER_CLASS,
					   INT_VALUE, 
					   INT_VALUE_SIG);
	il.append(new INVOKEVIRTUAL(index));
    }

    public Instruction ADD() {
	return InstructionConstants.IADD;
    }

    public Instruction SUB() {
	return InstructionConstants.ISUB;
    }

    public Instruction MUL() {
	return InstructionConstants.IMUL;
    }

    public Instruction DIV() {
	return InstructionConstants.IDIV;
    }

    public Instruction REM() {
	return InstructionConstants.IREM;
    }

    public Instruction NEG() {
	return InstructionConstants.INEG;
    }

    public Instruction LOAD(int slot) {
	return new ILOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ISTORE(slot);
    }

    public BranchInstruction GT(boolean tozero) {
	return tozero ? (BranchInstruction) new IFGT(null) : 
	    (BranchInstruction) new IF_ICMPGT(null);
    }

    public BranchInstruction GE(boolean tozero) {
	return tozero ? (BranchInstruction) new IFGE(null) : 
	    (BranchInstruction) new IF_ICMPGE(null);
    }

    public BranchInstruction LT(boolean tozero) {
	return tozero ? (BranchInstruction) new IFLT(null) : 
	    (BranchInstruction) new IF_ICMPLT(null);
    }

    public BranchInstruction LE(boolean tozero) {
	return tozero ? (BranchInstruction) new IFLE(null) : 
	    (BranchInstruction) new IF_ICMPLE(null);
    }
}
"
org.apache.xalan.xsltc.compiler.util.NodeSetType,21,2,0,44,49,210,15,32,19,2.0,450,0.0,0,0.622641509,0.238095238,2,4,20.42857143,7,1.4762,1,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.Constants;

public final class NodeSetType extends Type {
    protected NodeSetType() {}

    public String toString() {
	return ""node-set"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return NODE_ITERATOR_SIG;
    }

    public org.apache.bcel.generic.Type toJCType() {
	return new org.apache.bcel.generic.ObjectType(NODE_ITERATOR);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.Node) {
	    translateTo(classGen, methodGen, (NodeType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else if (type == Type.Object) {
	    translateTo(classGen, methodGen, (ObjectType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateFrom(ClassGenerator classGen, 
	MethodGenerator methodGen, Class clazz) 
    {
		
  	InstructionList il = methodGen.getInstructionList();
	ConstantPoolGen cpg = classGen.getConstantPool();
	if (clazz.getName().equals(""org.w3c.dom.NodeList"")) {
	   
	   
	   
	   il.append(classGen.loadTranslet());   
	   il.append(methodGen.loadDOM());   	 
	   final int convert = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					""nodeList2Iterator"",
					""(""		
					 + ""Lorg/w3c/dom/NodeList;""
					 + TRANSLET_INTF_SIG 
					 + DOM_INTF_SIG 
					 + "")"" + NODE_ITERATOR_SIG );
	   il.append(new INVOKESTATIC(convert));
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
		toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	} 
    }


    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	FlowList falsel = translateToDesynthesized(classGen, methodGen, type);
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsel.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final InstructionList il = methodGen.getInstructionList();
	getFirstNode(classGen, methodGen);
	il.append(DUP);
	final BranchHandle falsec = il.append(new IFEQ(null));
	Type.Node.translateTo(classGen, methodGen, type);
	final BranchHandle truec = il.append(new GOTO(null));
	falsec.setTarget(il.append(POP));
	il.append(new PUSH(classGen.getConstantPool(), """"));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	translateTo(classGen, methodGen, Type.String);
	Type.String.translateTo(classGen, methodGen, Type.Real);	
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    NodeType type) {
	getFirstNode(classGen, methodGen);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ObjectType type) {
	    methodGen.getInstructionList().append(NOP);	
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	getFirstNode(classGen, methodGen);
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final String className = clazz.getName();

	il.append(methodGen.loadDOM());
	il.append(SWAP);

	if (className.equals(""org.w3c.dom.Node"")) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE,
						  MAKE_NODE_SIG2);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else if (className.equals(""org.w3c.dom.NodeList"")) {
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  MAKE_NODE_LIST,
						  MAKE_NODE_LIST_SIG2);
	    il.append(new INVOKEINTERFACE(index, 2));
	}
	else if (className.equals(""int"")) {
	    int next = cpg.addInterfaceMethodref(NODE_ITERATOR,
						  ""next"", ""()I"");
	    int index = cpg.addInterfaceMethodref(DOM_INTF,
						  GET_NODE_VALUE,
						  ""(I)""+STRING_SIG);
	    int str = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					STRING_TO_INT,
					STRING_TO_INT_SIG);

	    
	    il.append(new INVOKEINTERFACE(next, 1));
	    
	    il.append(new INVOKEINTERFACE(index, 2));
	    
	    il.append(new INVOKESTATIC(str));
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), className);
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }
    
    
    private void getFirstNode(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKEINTERFACE(cpg.addInterfaceMethodref(NODE_ITERATOR,
								NEXT,
								NEXT_SIG), 1));
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public String getClassName() {
	return(NODE_ITERATOR);
    }


    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}
"
org.apache.xml.utils.res.XResources_ja_JP_A,3,4,0,1,4,1,0,1,2,0.5,599,0.0,0,0.976190476,1.0,0,0,198.3333333,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_ja_JP_A extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ja"" }, { ""help_language"", ""ja"" }, { ""language"", ""ja"" },
    { ""alphabet"",
      new char[]{ 0x30a2, 0x30a4, 0x30a6, 0x30a8, 0x30aa, 0x30ab, 0x30ad,
                  0x30af, 0x30b1, 0x30b3, 0x30b5, 0x30b7, 0x30b9, 0x30bb,
                  0x30bd, 0x30bf, 0x30c1, 0x30c4, 0x30c6, 0x30c8, 0x30ca,
                  0x30cb, 0x30cc, 0x30cd, 0x30ce, 0x30cf, 0x30d2, 0x30d5,
                  0x30d8, 0x30db, 0x30de, 0x30df, 0x30e0, 0x30e1, 0x30e2,
                  0x30e4, 0x30e6, 0x30e8, 0x30e9, 0x30ea, 0x30eb, 0x30ec,
                  0x30ed, 0x30ef, 0x30f0, 0x30f1, 0x30f2, 0x30f3 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    
    
    { ""multiplier"",
      new long[]{ Long.MAX_VALUE, Long.MAX_VALUE, 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4EAC, 0x5146, 0x5104, 0x4E07, 0x5343, 0x767e, 0x5341 } },

    
    { ""zero"", new char[0] },
    { ""digits"",
      new char[]{ 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03,
                  0x516B, 0x4E5D } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xml.utils.res.XResources_ja_JP_I,3,4,0,1,4,1,0,1,2,0.5,595,0.0,0,0.976190476,1.0,0,0,197.0,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_ja_JP_I extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""ja"" }, { ""help_language"", ""ja"" }, { ""language"", ""ja"" },
    { ""alphabet"",
      new char[]{ 0x30a4, 0x30ed, 0x30cf, 0x30cb, 0x30db, 0x30d8, 0x30c8,
                  0x30c1, 0x30ea, 0x30cc, 0x30eb, 0x30f2, 0x30ef, 0x30ab,
                  0x30e8, 0x30bf, 0x30ec, 0x30bd, 0x30c4, 0x30cd, 0x30ca,
                  0x30e9, 0x30e0, 0x30a6, 0x30f0, 0x30ce, 0x30aa, 0x30af,
                  0x30e4, 0x30de, 0x30b1, 0x30d5, 0x30b3, 0x30a8, 0x30c6,
                  0x30a2, 0x30b5, 0x30ad, 0x30e6, 0x30e1, 0x30df, 0x30b7,
                  0x30f1, 0x30d2, 0x30e2, 0x30bb, 0x30b9 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    
    
    { ""multiplier"",
      new long[]{ Long.MAX_VALUE, Long.MAX_VALUE, 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4EAC, 0x5146, 0x5104, 0x4E07, 0x5343, 0x767e, 0x5341 } },

    
    { ""zero"", new char[0] },
    { ""digits"",
      new char[]{ 0x4E00, 0x4E8C, 0x4E09, 0x56DB, 0x4E94, 0x516D, 0x4E03,
                  0x516B, 0x4E5D } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xpath.functions.FuncContains,2,5,0,6,7,1,0,6,2,2.0,36,0.0,0,0.98245614,0.75,1,6,17.0,1,0.5,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class FuncContains extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String s1 = m_arg0.execute(xctxt).str();
    String s2 = m_arg1.execute(xctxt).str();

    
    if (s1.length() == 0 && s2.length() == 0)
      return XBoolean.S_TRUE;

    int index = s1.indexOf(s2);

    return (index > -1) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.xsltc.compiler.util.MethodType,14,2,0,10,29,0,8,2,14,0.269230769,332,1.0,1,0.785714286,0.410714286,1,1,22.57142857,6,1.6429,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Vector;

public final class MethodType extends Type {
    private final Type _resultType;	
    private final Vector _argsType;
	
    public MethodType(Type resultType) {
	_argsType = null;
	_resultType = resultType;
    }

    public MethodType(Type resultType, Type arg1) {
	if (arg1 != Type.Void) {
	    _argsType = new Vector();
	    _argsType.addElement(arg1);
	}
	else {
	    _argsType = null;
	}
	_resultType = resultType;
    }

    public MethodType(Type resultType, Type arg1, Type arg2) {
	_argsType = new Vector(2);
	_argsType.addElement(arg1);
	_argsType.addElement(arg2);
	_resultType = resultType;
    }

    public MethodType(Type resultType, Type arg1, Type arg2, Type arg3) {
	_argsType = new Vector(3);
	_argsType.addElement(arg1);
	_argsType.addElement(arg2);
	_argsType.addElement(arg3);
	_resultType = resultType;
    }

    public MethodType(Type resultType, Vector argsType) {
	_resultType = resultType;
	_argsType = argsType.size() > 0 ? argsType : null;
    }

    public String toString() {
	StringBuffer result = new StringBuffer(""method{"");
	if (_argsType != null) {
	    final int count = _argsType.size();
	    for (int i=0; i<count; i++) {
		result.append(_argsType.elementAt(i));
		if (i != (count-1)) result.append(',');
	    }
	}
	else {
	    result.append(""void"");
	}
	result.append('}');
	return result.toString();
    }

    public String toSignature() {
	return toSignature("""");
    }

    
    public String toSignature(String lastArgSig) {
	final StringBuffer buffer = new StringBuffer();
	buffer.append('(');
	if (_argsType != null) {
	    final int n = _argsType.size();
	    for (int i = 0; i < n; i++) {
		buffer.append(((Type)_argsType.elementAt(i)).toSignature());
	    }
	}
	return buffer
	    .append(lastArgSig)
	    .append(')')
	    .append(_resultType.toSignature())
	    .toString();
    }

    public org.apache.bcel.generic.Type toJCType() {
	return null;	
    }

    public boolean identicalTo(Type other) {
	boolean result = false;
	if (other instanceof MethodType) {
	    final MethodType temp = (MethodType) other;
	    if (_resultType.identicalTo(temp._resultType)) {
		final int len = argsCount();
		result = len == temp.argsCount();
		for (int i = 0; i < len && result; i++) {
		    final Type arg1 = (Type)_argsType.elementAt(i);
		    final Type arg2 = (Type)temp._argsType.elementAt(i);
		    result = arg1.identicalTo(arg2);
		}
	    }
	}
	return result;	
    }
	
    public int distanceTo(Type other) {
	int result = Integer.MAX_VALUE;
	if (other instanceof MethodType) {
	    final MethodType mtype = (MethodType) other;
	    if (_argsType != null) {
		final int len = _argsType.size();
		if (len == mtype._argsType.size()) {
		    result = 0;
		    for (int i = 0; i < len; i++) {
			Type arg1 = (Type) _argsType.elementAt(i);
			Type arg2 = (Type) mtype._argsType.elementAt(i);
			final int temp = arg1.distanceTo(arg2);
			if (temp == Integer.MAX_VALUE) {
			    result = temp;  
			    break;
			}
			else {
			    result += arg1.distanceTo(arg2);
			}
		    }
		}
	    }
	    else if (mtype._argsType == null) {
		result = 0;   
	    }
	}
	return result;
    }
		
    public Type resultType() {
	return _resultType;
    }
		
    public Vector argsType() {
	return _argsType;
    }

    public int argsCount() {
	return _argsType == null ? 0 : _argsType.size();
    }
}
"
org.apache.xml.utils.FastStringBuffer,28,1,0,20,42,0,19,1,21,0.62962963,1676,0.0625,1,0.0,0.242798354,0,0,58.28571429,11,3.0,1,"
package org.apache.xml.utils;


public class FastStringBuffer
{
  
  static final int DEBUG_FORCE_INIT_BITS=0;
  
  	
  	
  	
  	
  	
  	
	static boolean DEBUG_FORCE_FIXED_CHUNKSIZE=true;

	
	public static final int SUPPRESS_LEADING_WS=0x01;
	
	
	public static final int SUPPRESS_TRAILING_WS=0x02;
	
	
	public static final int SUPPRESS_BOTH
		= SUPPRESS_LEADING_WS | SUPPRESS_TRAILING_WS;

	
	private static final int CARRY_WS=0x04;

	
  int m_chunkBits = 15;

  
  int m_maxChunkBits = 15;

  
  int m_rebundleBits = 2;

  
  int m_chunkSize;  

  
  int m_chunkMask;  

  
  char[][] m_array;

  
  int m_lastChunk = 0;

  
  int m_firstFree = 0;

  
  FastStringBuffer m_innerFSB = null;

  
  public FastStringBuffer(int initChunkBits, int maxChunkBits,
                          int rebundleBits)
  {
    if(DEBUG_FORCE_INIT_BITS!=0) initChunkBits=DEBUG_FORCE_INIT_BITS;
    
    
    
    
    
    
    
    
    if(DEBUG_FORCE_FIXED_CHUNKSIZE) maxChunkBits=initChunkBits;
    

    m_array = new char[16][];

    
    if (initChunkBits > maxChunkBits)
      initChunkBits = maxChunkBits;

    m_chunkBits = initChunkBits;
    m_maxChunkBits = maxChunkBits;
    m_rebundleBits = rebundleBits;
    m_chunkSize = 1 << (initChunkBits);
    m_chunkMask = m_chunkSize - 1;
    m_array[0] = new char[m_chunkSize];
  }

  
  public FastStringBuffer(int initChunkBits, int maxChunkBits)
  {
    this(initChunkBits, maxChunkBits, 2);
  }

  
  public FastStringBuffer(int initChunkBits)
  {
    this(initChunkBits, 15, 2);
  }

  
  public FastStringBuffer()
  {

    
    
    
    
    
    this(10, 15, 2);
  }

  
  public final int size()
  {
    return (m_lastChunk << m_chunkBits) + m_firstFree;
  }

  
  public final int length()
  {
    return (m_lastChunk << m_chunkBits) + m_firstFree;
  }

  
  public final void reset()
  {

    m_lastChunk = 0;
    m_firstFree = 0;

    
    FastStringBuffer innermost = this;

    while (innermost.m_innerFSB != null)
    {
      innermost = innermost.m_innerFSB;
    }

    m_chunkBits = innermost.m_chunkBits;
    m_chunkSize = innermost.m_chunkSize;
    m_chunkMask = innermost.m_chunkMask;

    
    m_innerFSB = null;
    m_array = new char[16][0];
    m_array[0] = new char[m_chunkSize];
  }

  
  public final void setLength(int l)
  {
    m_lastChunk = l >>> m_chunkBits;

    if (m_lastChunk == 0 && m_innerFSB != null)
    {
      
      m_innerFSB.setLength(l, this);
    }
    else
    {
      m_firstFree = l & m_chunkMask;
      
	  
	  
	  
	  
	  
      if(m_firstFree==0 && m_lastChunk>0)
      {
      	--m_lastChunk;
      	m_firstFree=m_chunkSize;
      }
    }
  }

  
  private final void setLength(int l, FastStringBuffer rootFSB)
  {

    m_lastChunk = l >>> m_chunkBits;

    if (m_lastChunk == 0 && m_innerFSB != null)
    {
      m_innerFSB.setLength(l, rootFSB);
    }
    else
    {

      
      
      rootFSB.m_chunkBits = m_chunkBits;
      rootFSB.m_maxChunkBits = m_maxChunkBits;
      rootFSB.m_rebundleBits = m_rebundleBits;
      rootFSB.m_chunkSize = m_chunkSize;
      rootFSB.m_chunkMask = m_chunkMask;
      rootFSB.m_array = m_array;
      rootFSB.m_innerFSB = m_innerFSB;
      rootFSB.m_lastChunk = m_lastChunk;

      
      rootFSB.m_firstFree = l & m_chunkMask;
    }
  }

  
  public final String toString()
  {

    int length = (m_lastChunk << m_chunkBits) + m_firstFree;

    return getString(new StringBuffer(length), 0, 0, length).toString();
  }

  
  public final void append(char value)
  {
    
    char[] chunk;

    
    
    boolean lastchunk = (m_lastChunk + 1 == m_array.length);

    if (m_firstFree < m_chunkSize)  
      chunk = m_array[m_lastChunk];
    else
    {

      
      int i = m_array.length;

      if (m_lastChunk + 1 == i)
      {
        char[][] newarray = new char[i + 16][];

        System.arraycopy(m_array, 0, newarray, 0, i);

        m_array = newarray;
      }

      
      chunk = m_array[++m_lastChunk];

      if (chunk == null)
      {

        
        if (m_lastChunk == 1 << m_rebundleBits
                && m_chunkBits < m_maxChunkBits)
        {

          
          
          m_innerFSB = new FastStringBuffer(this);
        }

        
        chunk = m_array[m_lastChunk] = new char[m_chunkSize];
      }

      m_firstFree = 0;
    }

    
    chunk[m_firstFree++] = value;
  }

  
  public final void append(String value)
  {

    if (value == null) 
      return;
    int strlen = value.length();

    if (0 == strlen)
      return;

    int copyfrom = 0;
    char[] chunk = m_array[m_lastChunk];
    int available = m_chunkSize - m_firstFree;

    
    while (strlen > 0)
    {

      
      if (available > strlen)
        available = strlen;

      value.getChars(copyfrom, copyfrom + available, m_array[m_lastChunk],
                     m_firstFree);

      strlen -= available;
      copyfrom += available;

      
      if (strlen > 0)
      {

        
        int i = m_array.length;

        if (m_lastChunk + 1 == i)
        {
          char[][] newarray = new char[i + 16][];

          System.arraycopy(m_array, 0, newarray, 0, i);

          m_array = newarray;
        }

        
        chunk = m_array[++m_lastChunk];

        if (chunk == null)
        {

          
          if (m_lastChunk == 1 << m_rebundleBits
                  && m_chunkBits < m_maxChunkBits)
          {

            
            
            m_innerFSB = new FastStringBuffer(this);
          }

          
          chunk = m_array[m_lastChunk] = new char[m_chunkSize];
        }

        available = m_chunkSize;
        m_firstFree = 0;
      }
    }

    
    m_firstFree += available;
  }

  
  public final void append(StringBuffer value)
  {

    if (value == null) 
      return;
    int strlen = value.length();

    if (0 == strlen)
      return;

    int copyfrom = 0;
    char[] chunk = m_array[m_lastChunk];
    int available = m_chunkSize - m_firstFree;

    
    while (strlen > 0)
    {

      
      if (available > strlen)
        available = strlen;

      value.getChars(copyfrom, copyfrom + available, m_array[m_lastChunk],
                     m_firstFree);

      strlen -= available;
      copyfrom += available;

      
      if (strlen > 0)
      {

        
        int i = m_array.length;

        if (m_lastChunk + 1 == i)
        {
          char[][] newarray = new char[i + 16][];

          System.arraycopy(m_array, 0, newarray, 0, i);

          m_array = newarray;
        }

        
        chunk = m_array[++m_lastChunk];

        if (chunk == null)
        {

          
          if (m_lastChunk == 1 << m_rebundleBits
                  && m_chunkBits < m_maxChunkBits)
          {

            
            
            m_innerFSB = new FastStringBuffer(this);
          }

          
          chunk = m_array[m_lastChunk] = new char[m_chunkSize];
        }

        available = m_chunkSize;
        m_firstFree = 0;
      }
    }

    
    m_firstFree += available;
  }

  
  public final void append(char[] chars, int start, int length)
  {

    int strlen = length;

    if (0 == strlen)
      return;

    int copyfrom = start;
    char[] chunk = m_array[m_lastChunk];
    int available = m_chunkSize - m_firstFree;

    
    while (strlen > 0)
    {

      
      if (available > strlen)
        available = strlen;

      System.arraycopy(chars, copyfrom, m_array[m_lastChunk], m_firstFree,
                       available);

      strlen -= available;
      copyfrom += available;

      
      if (strlen > 0)
      {

        
        int i = m_array.length;

        if (m_lastChunk + 1 == i)
        {
          char[][] newarray = new char[i + 16][];

          System.arraycopy(m_array, 0, newarray, 0, i);

          m_array = newarray;
        }

        
        chunk = m_array[++m_lastChunk];

        if (chunk == null)
        {

          
          if (m_lastChunk == 1 << m_rebundleBits
                  && m_chunkBits < m_maxChunkBits)
          {

            
            
            m_innerFSB = new FastStringBuffer(this);
          }

          
          chunk = m_array[m_lastChunk] = new char[m_chunkSize];
        }

        available = m_chunkSize;
        m_firstFree = 0;
      }
    }

    
    m_firstFree += available;
  }

  
  public final void append(FastStringBuffer value)
  {

    
    
    
    
    if (value == null) 
      return;
    int strlen = value.length();

    if (0 == strlen)
      return;

    int copyfrom = 0;
    char[] chunk = m_array[m_lastChunk];
    int available = m_chunkSize - m_firstFree;

    
    while (strlen > 0)
    {

      
      if (available > strlen)
        available = strlen;

      int sourcechunk = (copyfrom + value.m_chunkSize - 1)
                        >>> value.m_chunkBits;
      int sourcecolumn = copyfrom & value.m_chunkMask;
      int runlength = value.m_chunkSize - sourcecolumn;

      if (runlength > available)
        runlength = available;

      System.arraycopy(value.m_array[sourcechunk], sourcecolumn,
                       m_array[m_lastChunk], m_firstFree, runlength);

      if (runlength != available)
        System.arraycopy(value.m_array[sourcechunk + 1], 0,
                         m_array[m_lastChunk], m_firstFree + runlength,
                         available - runlength);

      strlen -= available;
      copyfrom += available;

      
      if (strlen > 0)
      {

        
        int i = m_array.length;

        if (m_lastChunk + 1 == i)
        {
          char[][] newarray = new char[i + 16][];

          System.arraycopy(m_array, 0, newarray, 0, i);

          m_array = newarray;
        }

        
        chunk = m_array[++m_lastChunk];

        if (chunk == null)
        {

          
          if (m_lastChunk == 1 << m_rebundleBits
                  && m_chunkBits < m_maxChunkBits)
          {

            
            
            m_innerFSB = new FastStringBuffer(this);
          }

          
          chunk = m_array[m_lastChunk] = new char[m_chunkSize];
        }

        available = m_chunkSize;
        m_firstFree = 0;
      }
    }

    
    m_firstFree += available;
  }

  
  public boolean isWhitespace(int start, int length)
  {

    int sourcechunk = start >>> m_chunkBits;
    int sourcecolumn = start & m_chunkMask;
    int available = m_chunkSize - sourcecolumn;
    boolean chunkOK;

    while (length > 0)
    {
      int runlength = (length <= available) ? length : available;

      if (sourcechunk == 0 && m_innerFSB != null)
        chunkOK = m_innerFSB.isWhitespace(sourcecolumn, runlength);
      else
        chunkOK = org.apache.xml.utils.XMLCharacterRecognizer.isWhiteSpace(
          m_array[sourcechunk], sourcecolumn, runlength);

      if (!chunkOK)
        return false;

      length -= runlength;

      ++sourcechunk;

      sourcecolumn = 0;
      available = m_chunkSize;
    }

    return true;
  }

  
  public String getString(int start, int length)
  {
    return getString(new StringBuffer(length), start >>> m_chunkBits,
                     start & m_chunkMask, length).toString();
  }

  
  StringBuffer getString(StringBuffer sb, int start, int length)
  {
    return getString(sb, start >>> m_chunkBits, start & m_chunkMask, length);
  }

  
  StringBuffer getString(StringBuffer sb, int startChunk, int startColumn,
                         int length)
  {

    int stop = (startChunk << m_chunkBits) + startColumn + length;
    int stopChunk = stop >>> m_chunkBits;
    int stopColumn = stop & m_chunkMask;

    
    
    for (int i = startChunk; i < stopChunk; ++i)
    {
      if (i == 0 && m_innerFSB != null)
        m_innerFSB.getString(sb, startColumn, m_chunkSize - startColumn);
      else
        sb.append(m_array[i], startColumn, m_chunkSize - startColumn);

      startColumn = 0;  
    }

    if (stopChunk == 0 && m_innerFSB != null)
      m_innerFSB.getString(sb, startColumn, stopColumn - startColumn);
    else if (stopColumn > startColumn)
      sb.append(m_array[stopChunk], startColumn, stopColumn - startColumn);

    return sb;
  }

  
  public char charAt(int pos)
  {
    int startChunk = pos >>> m_chunkBits;

    if (startChunk == 0 && m_innerFSB != null)
      return m_innerFSB.charAt(pos & m_chunkMask);
    else
      return m_array[startChunk][pos & m_chunkMask];
  }

  
  public void sendSAXcharacters(
          org.xml.sax.ContentHandler ch, int start, int length)
            throws org.xml.sax.SAXException
  {

    int stop = start + length;
    int startChunk = start >>> m_chunkBits;
    int startColumn = start & m_chunkMask;
    int stopChunk = stop >>> m_chunkBits;
    int stopColumn = stop & m_chunkMask;

    for (int i = startChunk; i < stopChunk; ++i)
    {
      if (i == 0 && m_innerFSB != null)
        m_innerFSB.sendSAXcharacters(ch, startColumn,
                                     m_chunkSize - startColumn);
      else
        ch.characters(m_array[i], startColumn, m_chunkSize - startColumn);

      startColumn = 0;  
    }

    
    if (stopChunk == 0 && m_innerFSB != null)
      m_innerFSB.sendSAXcharacters(ch, startColumn, stopColumn - startColumn);
    else if (stopColumn > startColumn)
    {
      ch.characters(m_array[stopChunk], startColumn,
                    stopColumn - startColumn);
    }
  }
  
  
  public int sendNormalizedSAXcharacters(
          org.xml.sax.ContentHandler ch, int start, int length)
            throws org.xml.sax.SAXException
  {
	
    
    
	
	int stateForNextChunk=SUPPRESS_LEADING_WS;

    int stop = start + length;
    int startChunk = start >>> m_chunkBits;
    int startColumn = start & m_chunkMask;
    int stopChunk = stop >>> m_chunkBits;
    int stopColumn = stop & m_chunkMask;

    for (int i = startChunk; i < stopChunk; ++i)
    {
      if (i == 0 && m_innerFSB != null)
				stateForNextChunk=
        m_innerFSB.sendNormalizedSAXcharacters(ch, startColumn,
                                     m_chunkSize - startColumn);
      else
				stateForNextChunk=
        sendNormalizedSAXcharacters(m_array[i], startColumn, 
                                    m_chunkSize - startColumn, 
																		ch,stateForNextChunk);

      startColumn = 0;  
    }

    
    if (stopChunk == 0 && m_innerFSB != null)
			stateForNextChunk= 
      m_innerFSB.sendNormalizedSAXcharacters(ch, startColumn, stopColumn - startColumn);
    else if (stopColumn > startColumn)
    {
			stateForNextChunk= 
      sendNormalizedSAXcharacters(m_array[stopChunk], 
																	startColumn, stopColumn - startColumn,
																	ch, stateForNextChunk | SUPPRESS_TRAILING_WS);
    }
		return stateForNextChunk;
  }
  
  static final char[] SINGLE_SPACE = {' '};
	  
  
  static int sendNormalizedSAXcharacters(char ch[], 
             int start, int length, 
             org.xml.sax.ContentHandler handler,
						 int edgeTreatmentFlags)
          throws org.xml.sax.SAXException
  {
    int end = length + start;
    int scanpos=start;
		
    
    
    
    
    
    if (XMLCharacterRecognizer.isWhiteSpace(ch[scanpos]))
    {
        if(0 == (edgeTreatmentFlags&SUPPRESS_LEADING_WS) )
            handler.characters(SINGLE_SPACE, 0, 1);

        while(++scanpos < end)
        {
            char c = ch[scanpos];
            if(!XMLCharacterRecognizer.isWhiteSpace(c))
                break;
        }
    }

	
    boolean whiteSpaceFound = false;  
    
    boolean needToFlushSpace = 0!=(edgeTreatmentFlags&CARRY_WS); 
    
    int datapos = scanpos;	
    for (; scanpos < end; scanpos++)
    {
      char c = ch[scanpos];

      if (XMLCharacterRecognizer.isWhiteSpace(c))
      {
        if (!whiteSpaceFound)
        {
          whiteSpaceFound = true;
          int len = (scanpos-datapos);
          if( len > 0)
          {
            if(needToFlushSpace)
              handler.characters(SINGLE_SPACE, 0, 1);
              
            handler.characters(ch, datapos, len);
            needToFlushSpace = true;
          }
          datapos = scanpos+1;
        }
        else
        {
          int nonwhitescan = scanpos+1; 
          for (; nonwhitescan < end; nonwhitescan++)
          {
            c = ch[nonwhitescan];
            if(!XMLCharacterRecognizer.isWhiteSpace(c))
              break;
          }

          if(nonwhitescan == end)
          {
            end = scanpos;
            break; 
          }

          int len = (scanpos-datapos);
          if(len > 0)
          {
            if(needToFlushSpace)
            {
              handler.characters(SINGLE_SPACE, 0, 1);
              needToFlushSpace = false;
            }
              
            handler.characters(ch, datapos, len);
          }

          whiteSpaceFound = false;
          datapos = scanpos = nonwhitescan;
        }
      }
      else
      {
        whiteSpaceFound = false;
      }
    }

    if (whiteSpaceFound)
      scanpos--;
    
    int len = (scanpos-datapos);

	
	
    if(len > 0)
    {
      if(needToFlushSpace) 
        handler.characters(SINGLE_SPACE, 0, 1); 
  
  	  handler.characters(ch, datapos, len);
  	  edgeTreatmentFlags &= ~(SUPPRESS_LEADING_WS | CARRY_WS);
    }
    
    
    
    
    
	if(whiteSpaceFound && 0==(edgeTreatmentFlags&SUPPRESS_TRAILING_WS))
	{
        
		edgeTreatmentFlags |= SUPPRESS_LEADING_WS | CARRY_WS;
    }
		
	return edgeTreatmentFlags;
  }
  
  
  public static void sendNormalizedSAXcharacters(char ch[], 
             int start, int length, 
             org.xml.sax.ContentHandler handler)
          throws org.xml.sax.SAXException
  {
		sendNormalizedSAXcharacters(ch, start, length, 
             handler, SUPPRESS_BOTH);
	}
		
	
  public void sendSAXComment(
          org.xml.sax.ext.LexicalHandler ch, int start, int length)
            throws org.xml.sax.SAXException
  {

    
    String comment = getString(start, length);
    ch.comment(comment.toCharArray(), 0, length);
  }

  
  private void getChars(int srcBegin, int srcEnd, char dst[], int dstBegin)
  {
    
  }

  
  private FastStringBuffer(FastStringBuffer source)
  {

    
    m_chunkBits = source.m_chunkBits;
    m_maxChunkBits = source.m_maxChunkBits;
    m_rebundleBits = source.m_rebundleBits;
    m_chunkSize = source.m_chunkSize;
    m_chunkMask = source.m_chunkMask;
    m_array = source.m_array;
    m_innerFSB = source.m_innerFSB;

    
    
    m_lastChunk = source.m_lastChunk - 1;
    m_firstFree = source.m_chunkSize;

    
    source.m_array = new char[16][];
    source.m_innerFSB = this;

    
    
    
    source.m_lastChunk = 1;
    source.m_firstFree = 0;
    source.m_chunkBits += m_rebundleBits;
    source.m_chunkSize = 1 << (source.m_chunkBits);
    source.m_chunkMask = source.m_chunkSize - 1;
  }
}
"
org.apache.xpath.functions.FuncSubstringBefore,2,5,0,6,8,1,0,6,2,2.0,34,0.0,0,0.98245614,0.75,1,6,16.0,1,0.5,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncSubstringBefore extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String s1 = m_arg0.execute(xctxt).str();
    String s2 = m_arg1.execute(xctxt).str();
    int index = s1.indexOf(s2);

    return (-1 == index)
           ? XString.EMPTYSTRING : new XString(s1.substring(0, index));
  }
}
"
org.apache.xalan.templates.OutputProperties,42,3,0,18,103,547,12,8,37,0.918292683,1046,0.4,0,0.837606838,0.233062331,0,0,23.42857143,13,2.0,4,"
package org.apache.xalan.templates;

import java.io.BufferedInputStream;
import java.io.InputStream;
import java.io.IOException;

import java.util.Vector;
import java.util.Hashtable;
import java.util.Properties;
import java.util.Enumeration;

import java.lang.Cloneable;

import org.w3c.dom.Document;

import org.apache.xml.utils.QName;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.WrappedRuntimeException;
import org.apache.xalan.serialize.Method;
import org.apache.xalan.extensions.ExtensionHandler;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;


import javax.xml.transform.TransformerException;
import javax.xml.transform.OutputKeys;


public class OutputProperties extends ElemTemplateElement
        implements Cloneable
{

  
  public OutputProperties()
  {
    this(Method.XML);
  }

  
  public OutputProperties(Properties defaults)
  {
    m_properties = new Properties(defaults);
  }

  
  public OutputProperties(String method)
  {
    m_properties = new Properties(getDefaultMethodProperties(method));
  }
  
  static final String S_XSLT_PREFIX = ""xslt.output."";
  static final int S_XSLT_PREFIX_LEN = S_XSLT_PREFIX.length();
  static final String S_XALAN_PREFIX = ""org.apache.xslt."";
  static final int S_XALAN_PREFIX_LEN = S_XALAN_PREFIX.length();
  
  
  static final String S_BUILTIN_EXTENSIONS_UNIVERSAL=
        ""{""+Constants.S_BUILTIN_EXTENSIONS_URL+""}"";
  
  
  static private String fixupPropertyString(String s, boolean doClipping)
  {
    int index;
    if (doClipping && s.startsWith(S_XSLT_PREFIX))
    {
      s = s.substring(S_XSLT_PREFIX_LEN);
    }
    if (s.startsWith(S_XALAN_PREFIX))
    {
      s = S_BUILTIN_EXTENSIONS_UNIVERSAL + s.substring(S_XALAN_PREFIX_LEN);
    }
    if ((index = s.indexOf(""\u003a"")) > 0)
    {
      String temp = s.substring(index+6);
      s = s.substring(0, index) + "":"" + temp;

    }
    return s;
  }
  
  
  static private Properties loadPropertiesFile(String resourceName, Properties defaults)
    throws IOException
  {

    
    
    

    Properties props = new Properties(defaults);

    InputStream is = null;
    BufferedInputStream bis = null;

    try {
      try {
        java.lang.reflect.Method getCCL = Thread.class.getMethod(""getContextClassLoader"", NO_CLASSES);
        if (getCCL != null) {
          ClassLoader contextClassLoader = (ClassLoader) getCCL.invoke(Thread.currentThread(), NO_OBJS);
          is = contextClassLoader.getResourceAsStream(""org/apache/xalan/templates/"" + resourceName);
        }
      }
      catch (Exception e) {}

      if ( is == null ) {
        is = OutputProperties.class.getResourceAsStream(resourceName);
      }
      
      bis = new BufferedInputStream(is);
      props.load(bis);
    } 
    catch (IOException ioe) {
      if ( defaults == null ) {
        throw ioe;
      }
      else {
        throw new WrappedRuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_LOAD_RESOURCE, new Object[]{resourceName}), ioe); 
      }
    }
    catch (SecurityException se) {
      
      if ( defaults == null ) {
        throw se;
      }
      else {
        throw new WrappedRuntimeException(XSLMessages.createMessage(XSLTErrorResources.ER_COULD_NOT_LOAD_RESOURCE, new Object[]{resourceName}), se); 
      }
    } 
    finally {
      if ( bis != null ) {
        bis.close();
      }
      if (is != null ) {
        is.close();
      }
    }
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    Enumeration keys = ((Properties) props.clone()).keys();
    while(keys.hasMoreElements())
    {
      String key = (String)keys.nextElement();
      
      
      
      String value = null;
      try {
        value = System.getProperty(key);
      }
      catch (SecurityException se) {
        
      }
      if (value == null)      
        value = (String)props.get(key);                       
      
      String newKey = fixupPropertyString(key, true);
      String newValue = null;
      try {
        newValue = System.getProperty(newKey);
      }
      catch (SecurityException se) {
        
      }
      if (newValue == null)
        newValue = fixupPropertyString(value, false);
      else
        newValue = fixupPropertyString(newValue, false);
       
      if(key != newKey || value != newValue)
      {
        props.remove(key);
        props.put(newKey, newValue);
      }
      
    }
    
    return props;
  }

  
  static public Properties getDefaultMethodProperties(String method)
  {
    String fileName = null;
    Properties defaultProperties = null;
    
    
    try
    {
      synchronized (m_synch_object)
      {
        if (null == m_xml_properties)  
        {
          fileName = ""output_xml.properties"";
          m_xml_properties = loadPropertiesFile(fileName, null);
        }
      }

      if (method.equals(Method.XML))
      {
        defaultProperties = m_xml_properties;
      }
      else if (method.equals(Method.HTML))
      {
            if (null == m_html_properties)  
            {
              fileName = ""output_html.properties"";
              m_html_properties = loadPropertiesFile(fileName,
                                                     m_xml_properties);
            }

        defaultProperties = m_html_properties;
      }
      else if (method.equals(Method.Text))
      {
            if (null == m_text_properties)  
            {
              fileName = ""output_text.properties"";
              m_text_properties = loadPropertiesFile(fileName,
                                                     m_xml_properties);
              if(null == m_text_properties.getProperty(OutputKeys.ENCODING))
              {
                String mimeEncoding = org.apache.xalan.serialize.Encodings.getMimeEncoding(null);
                m_text_properties.put(OutputKeys.ENCODING, mimeEncoding);
              }
            }

        defaultProperties = m_text_properties;
      }
      else
      {

        
        defaultProperties = m_xml_properties;
      }
    }
    catch (IOException ioe)
    {
      throw new WrappedRuntimeException(
            ""Output method is ""+method+"" could not load ""+fileName+"" (check CLASSPATH)"",
             ioe);
    }

    return defaultProperties;
  }

  
  public Object clone()
  {

    try
    {
      OutputProperties cloned = (OutputProperties) super.clone();

      cloned.m_properties = (Properties) cloned.m_properties.clone();

      return cloned;
    }
    catch (CloneNotSupportedException e)
    {
      return null;
    }
  }

  
  public void setProperty(QName key, String value)
  {
    setProperty(key.toNamespacedString(), value);
  }

  
  public void setProperty(String key, String value)
  {
    if(key.equals(OutputKeys.METHOD))
    {
      setMethodDefaults(value);
    }
    m_properties.put(key, value);
  }

  
  public String getProperty(QName key)
  {
    return m_properties.getProperty(key.toNamespacedString());
  }

  
  public String getProperty(String key)
  {
    return m_properties.getProperty(key);
  }

  
  public void setBooleanProperty(QName key, boolean value)
  {
    m_properties.put(key.toNamespacedString(), value ? ""yes"" : ""no"");
  }

  
  public void setBooleanProperty(String key, boolean value)
  {
    m_properties.put(key, value ? ""yes"" : ""no"");
  }

  
  public boolean getBooleanProperty(QName key)
  {
    return getBooleanProperty(key.toNamespacedString());
  }

  
  public boolean getBooleanProperty(String key)
  {
    return getBooleanProperty(key, m_properties);
  }

  
  public static boolean getBooleanProperty(String key, Properties props)
  {

    String s = props.getProperty(key);

    if (null == s ||!s.equals(""yes""))
      return false;
    else
      return true;
  }
  
  
  public void setIntProperty(QName key, int value)
  {
    setIntProperty(key.toNamespacedString(), value);
  }

  
  public void setIntProperty(String key, int value)
  {
    m_properties.put(key, Integer.toString(value));
  }

  
  public int getIntProperty(QName key)
  {
    return getIntProperty(key.toNamespacedString());
  }

  
  public int getIntProperty(String key)
  {
    return getIntProperty(key, m_properties);
  }

  
  public static int getIntProperty(String key, Properties props)
  {

    String s = props.getProperty(key);

    if (null == s)
      return 0;
    else
      return Integer.parseInt(s);
  }

  
  public void setQNameProperty(QName key, QName value)
  {
    setQNameProperty(key.toNamespacedString(), value);
  }
  
  
  public void setMethodDefaults(String method)
  {
    String defaultMethod = m_properties.getProperty(OutputKeys.METHOD);
    if((null == defaultMethod) || !defaultMethod.equals(method))
    {
      Properties savedProps = m_properties;
      Properties newDefaults = getDefaultMethodProperties(method);
      m_properties = new Properties(newDefaults);
      copyFrom(savedProps, false);
    }
  }
  

  
  public void setQNameProperty(String key, QName value)
  {
    setProperty(key, value.toNamespacedString());
  }

  
  public QName getQNameProperty(QName key)
  {
    return getQNameProperty(key.toNamespacedString());
  }

  
  public QName getQNameProperty(String key)
  {
    return getQNameProperty(key, m_properties);
  }

  
  public static QName getQNameProperty(String key, Properties props)
  {

    String s = props.getProperty(key);

    if (null != s)
      return QName.getQNameFromString(s);
    else
      return null;
  }

  
  public void setQNameProperties(QName key, Vector v)
  {
    setQNameProperties(key.toNamespacedString(), v);
  }

  
  public void setQNameProperties(String key, Vector v)
  {

    int s = v.size();

    
    FastStringBuffer fsb = new FastStringBuffer(9,9);

    for (int i = 0; i < s; i++)
    {
      QName qname = (QName) v.elementAt(i);

      fsb.append(qname.toNamespacedString());
      
      if (i < s-1) 
        fsb.append(' ');
    }

    m_properties.put(key, fsb.toString());
  }

  
  public Vector getQNameProperties(QName key)
  {
    return getQNameProperties(key.toNamespacedString());
  }

  
  public Vector getQNameProperties(String key)
  {
    return getQNameProperties(key, m_properties);
  }

  
  public static Vector getQNameProperties(String key, Properties props)
  {

    String s = props.getProperty(key);

    if (null != s)
    {
      Vector v = new Vector();
      int l = s.length();
      boolean inCurly = false;
      FastStringBuffer buf = new FastStringBuffer();

      
      
      
      for (int i = 0; i < l; i++)
      {
        char c = s.charAt(i);

        if (Character.isWhitespace(c))
        {
          if (!inCurly)
          {
            if (buf.length() > 0)
            {
              QName qname = QName.getQNameFromString(buf.toString());
              v.addElement(qname);
              buf.reset();
            }
            continue;
          }
        }
        else if ('{' == c)
          inCurly = true;
        else if ('}' == c)
          inCurly = false;

        buf.append(c);
      }

      if (buf.length() > 0)
      {
        QName qname = QName.getQNameFromString(buf.toString());
        v.addElement(qname);
        buf.reset();
      }

      return v;
    }
    else
      return null;
  }

  
  public void recompose(StylesheetRoot root)
    throws TransformerException
  {
    root.recomposeOutput(this);
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {

    super.compose(sroot);

    m_propertiesLevels = null;
  }

  
  public Properties getProperties()
  {
    return m_properties;
  }
  
  
  public void copyFrom(Properties src)
  {
    copyFrom(src, true);
  }

  
  public void copyFrom(Properties src, boolean shouldResetDefaults)
  {

    Enumeration enum = src.keys();

    while (enum.hasMoreElements())
    {
      String key = (String) enum.nextElement();
      Object oldValue = m_properties.get(key);
      if (null == oldValue)
      {
        String val = (String) src.get(key);
        
        if(shouldResetDefaults && key.equals(OutputKeys.METHOD))
        {
          setMethodDefaults(val);
        }

        m_properties.put(key, val);
      }
      else if (key.equals(OutputKeys.CDATA_SECTION_ELEMENTS))
      {
        m_properties.put(key, (String) oldValue + "" "" + (String) src.get(key));
      }
    }
  }

  
  public void copyFrom(OutputProperties opsrc)
    throws TransformerException
  {
    checkDuplicates(opsrc);
    copyFrom(opsrc.getProperties());
  }

  
  private void checkDuplicates(OutputProperties newProps)
    throws TransformerException
  {

    if (null == m_propertiesLevels)
      m_propertiesLevels = new Hashtable();

    
    

    int newPrecedence = newProps.getStylesheetComposed().getImportCountComposed();

    Properties p = newProps.getProperties();
    Enumeration enum = p.keys();

    while (enum.hasMoreElements())
    {
      String key = (String) enum.nextElement();

      if (key.equals(OutputKeys.CDATA_SECTION_ELEMENTS))
        continue;

      
      
      Integer oldPrecedence = (Integer) m_propertiesLevels.get(key);
      if (null == oldPrecedence)
      {
        m_propertiesLevels.put(key, new Integer(newPrecedence));
      }
      else if (newPrecedence >= oldPrecedence.intValue())
      {
        String oldValue = (String) this.m_properties.get(key);
        String newValue = (String) newProps.m_properties.get(key);
        if ( ((oldValue == null) && (newValue != null)) || !oldValue.equals(newValue) )
        {
          String msg = key + "" can not be multiply defined at the same ""
                       + ""import level! Old value = "" 
                       + oldValue + ""; New value = "" + newValue;
          throw new TransformerException(msg, newProps);
        }
      }
    }
}

  
  public boolean isLegalPropertyKey(String key)
  {

    return (key.equals(OutputKeys.CDATA_SECTION_ELEMENTS)
            || key.equals(OutputKeys.DOCTYPE_PUBLIC)
            || key.equals(OutputKeys.DOCTYPE_SYSTEM)
            || key.equals(OutputKeys.ENCODING)
            || key.equals(OutputKeys.INDENT)
            || key.equals(OutputKeys.MEDIA_TYPE)
            || key.equals(OutputKeys.METHOD)
            || key.equals(OutputKeys.OMIT_XML_DECLARATION)
            || key.equals(OutputKeys.STANDALONE)
            || key.equals(OutputKeys.VERSION)
            || (key.length() > 0) && (key.charAt(0) == '{'));
  }

  
  private transient Hashtable m_propertiesLevels;

  
  private Properties m_properties = null;

  

  
  public static String S_KEY_INDENT_AMOUNT =
    S_BUILTIN_EXTENSIONS_UNIVERSAL+""indent-amount"";

  
  public static String S_KEY_CONTENT_HANDLER =
    S_BUILTIN_EXTENSIONS_UNIVERSAL+""content-handler"";

  
  public static String S_KEY_ENTITIES =
    S_BUILTIN_EXTENSIONS_UNIVERSAL+""entities"";

  
  public static String S_USE_URL_ESCAPING =
    S_BUILTIN_EXTENSIONS_UNIVERSAL+""use-url-escaping"";

  
  public static String S_OMIT_META_TAG =
    S_BUILTIN_EXTENSIONS_UNIVERSAL+""omit-meta-tag"";

  
  private static Properties m_xml_properties = null;

  
  private static Properties m_html_properties = null;

  
  private static Properties m_text_properties = null;

  
  private static Integer m_synch_object = new Integer(1);

  
  private static final Class[] NO_CLASSES = new Class[0];

  
  private static final Object[] NO_OBJS = new Object[0];

}
"
org.apache.xpath.operations.Number,3,3,0,7,8,3,2,5,3,2.0,23,0.0,0,0.952380952,0.555555556,1,1,6.666666667,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.XPathContext;


public class Number extends UnaryOperation
{

  
  public XObject operate(XObject right) throws javax.xml.transform.TransformerException
  {

    if (XObject.CLASS_NUMBER == right.getType())
      return right;
    else
      return new XNumber(right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    return m_right.num(xctxt);
  }

}
"
org.apache.xml.utils.URI,42,1,0,3,68,375,1,2,29,0.780487805,2042,1.0,0,0.0,0.226480836,0,0,47.33333333,33,3.1429,1,"
package org.apache.xml.utils;

import java.io.IOException;
import java.io.Serializable;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;


public class URI implements Serializable
{

  
  public static class MalformedURIException extends IOException
  {

    
    public MalformedURIException()
    {
      super();
    }

    
    public MalformedURIException(String p_msg)
    {
      super(p_msg);
    }
  }

  
  private static final String RESERVED_CHARACTERS = "";/?:@&=+$,"";

  
  private static final String MARK_CHARACTERS = ""-_.!~*'() "";

  
  private static final String SCHEME_CHARACTERS = ""+-."";

  
  private static final String USERINFO_CHARACTERS = "";:&=+$,"";

  
  private String m_scheme = null;

  
  private String m_userinfo = null;

  
  private String m_host = null;

  
  private int m_port = -1;

  
  private String m_path = null;

  
  private String m_queryString = null;

  
  private String m_fragment = null;

  
  private static boolean DEBUG = false;

  
  public URI(){}

  
  public URI(URI p_other)
  {
    initialize(p_other);
  }

  
  public URI(String p_uriSpec) throws MalformedURIException
  {
    this((URI) null, p_uriSpec);
  }

  
  public URI(URI p_base, String p_uriSpec) throws MalformedURIException
  {
    initialize(p_base, p_uriSpec);
  }

  
  public URI(String p_scheme, String p_schemeSpecificPart)
          throws MalformedURIException
  {

    if (p_scheme == null || p_scheme.trim().length() == 0)
    {
      throw new MalformedURIException(
        ""Cannot construct URI with null/empty scheme!"");
    }

    if (p_schemeSpecificPart == null
            || p_schemeSpecificPart.trim().length() == 0)
    {
      throw new MalformedURIException(
        ""Cannot construct URI with null/empty scheme-specific part!"");
    }

    setScheme(p_scheme);
    setPath(p_schemeSpecificPart);
  }

  
  public URI(String p_scheme, String p_host, String p_path, String p_queryString, String p_fragment)
          throws MalformedURIException
  {
    this(p_scheme, null, p_host, -1, p_path, p_queryString, p_fragment);
  }

  
  public URI(String p_scheme, String p_userinfo, String p_host, int p_port, String p_path, String p_queryString, String p_fragment)
          throws MalformedURIException
  {

    if (p_scheme == null || p_scheme.trim().length() == 0)
    {
      throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_SCHEME_REQUIRED, null)); 
    }

    if (p_host == null)
    {
      if (p_userinfo != null)
      {
        throw new MalformedURIException(
          XSLMessages.createMessage(XSLTErrorResources.ER_NO_USERINFO_IF_NO_HOST, null)); 
      }

      if (p_port != -1)
      {
        throw new MalformedURIException(
          XSLMessages.createMessage(XSLTErrorResources.ER_NO_PORT_IF_NO_HOST, null)); 
      }
    }

    if (p_path != null)
    {
      if (p_path.indexOf('?') != -1 && p_queryString != null)
      {
        throw new MalformedURIException(
          XSLMessages.createMessage(XSLTErrorResources.ER_NO_QUERY_STRING_IN_PATH, null)); 
      }

      if (p_path.indexOf('#') != -1 && p_fragment != null)
      {
        throw new MalformedURIException(
          XSLMessages.createMessage(XSLTErrorResources.ER_NO_FRAGMENT_STRING_IN_PATH, null)); 
      }
    }

    setScheme(p_scheme);
    setHost(p_host);
    setPort(p_port);
    setUserinfo(p_userinfo);
    setPath(p_path);
    setQueryString(p_queryString);
    setFragment(p_fragment);
  }

  
  private void initialize(URI p_other)
  {

    m_scheme = p_other.getScheme();
    m_userinfo = p_other.getUserinfo();
    m_host = p_other.getHost();
    m_port = p_other.getPort();
    m_path = p_other.getPath();
    m_queryString = p_other.getQueryString();
    m_fragment = p_other.getFragment();
  }

  
  private void initialize(URI p_base, String p_uriSpec)
          throws MalformedURIException
  {

    if (p_base == null
            && (p_uriSpec == null || p_uriSpec.trim().length() == 0))
    {
      throw new MalformedURIException(
        XSLMessages.createMessage(XSLTErrorResources.ER_CANNOT_INIT_URI_EMPTY_PARMS, null)); 
    }

    
    if (p_uriSpec == null || p_uriSpec.trim().length() == 0)
    {
      initialize(p_base);

      return;
    }

    String uriSpec = p_uriSpec.trim();
    int uriSpecLen = uriSpec.length();
    int index = 0;

    
    if (uriSpec.indexOf(':') == -1)
    {
      if (p_base == null)
      {
        throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_SCHEME_IN_URI, new Object[]{uriSpec})); 
      }
    }
    else
    {
      initializeScheme(uriSpec);

      index = m_scheme.length() + 1;
    }

    
    if (((index + 1) < uriSpecLen)
            && (uriSpec.substring(index).startsWith(""
    {
      index += 2;

      int startPos = index;

      
      char testChar = ' ';

      while (index < uriSpecLen)
      {
        testChar = uriSpec.charAt(index);

        if (testChar == '/' || testChar == '?' || testChar == '#')
        {
          break;
        }

        index++;
      }

      
      
      if (index > startPos)
      {
        initializeAuthority(uriSpec.substring(startPos, index));
      }
      else
      {
        m_host = """";
      }
    }

    initializePath(uriSpec.substring(index));

    
    
    
    
    
    if (p_base != null)
    {

      
      
      
      
      
      
      
      if (m_path.length() == 0 && m_scheme == null && m_host == null)
      {
        m_scheme = p_base.getScheme();
        m_userinfo = p_base.getUserinfo();
        m_host = p_base.getHost();
        m_port = p_base.getPort();
        m_path = p_base.getPath();

        if (m_queryString == null)
        {
          m_queryString = p_base.getQueryString();
        }

        return;
      }

      
      
      if (m_scheme == null)
      {
        m_scheme = p_base.getScheme();
      }
      else
      {
        return;
      }

      
      
      if (m_host == null)
      {
        m_userinfo = p_base.getUserinfo();
        m_host = p_base.getHost();
        m_port = p_base.getPort();
      }
      else
      {
        return;
      }

      
      if (m_path.length() > 0 && m_path.startsWith(""/""))
      {
        return;
      }

      
      
      String path = new String();
      String basePath = p_base.getPath();

      
      if (basePath != null)
      {
        int lastSlash = basePath.lastIndexOf('/');

        if (lastSlash != -1)
        {
          path = basePath.substring(0, lastSlash + 1);
        }
      }

      
      path = path.concat(m_path);

      
      index = -1;

      while ((index = path.indexOf(""/./"")) != -1)
      {
        path = path.substring(0, index + 1).concat(path.substring(index + 3));
      }

      
      if (path.endsWith(""/.""))
      {
        path = path.substring(0, path.length() - 1);
      }

      
      
      index = -1;

      int segIndex = -1;
      String tempString = null;

      while ((index = path.indexOf(""/../"")) > 0)
      {
        tempString = path.substring(0, path.indexOf(""/../""));
        segIndex = tempString.lastIndexOf('/');

        if (segIndex != -1)
        {
          if (!tempString.substring(segIndex++).equals(""..""))
          {
            path = path.substring(0, segIndex).concat(path.substring(index
                    + 4));
          }
        }
      }

      
      
      if (path.endsWith(""/..""))
      {
        tempString = path.substring(0, path.length() - 3);
        segIndex = tempString.lastIndexOf('/');

        if (segIndex != -1)
        {
          path = path.substring(0, segIndex + 1);
        }
      }

      m_path = path;
    }
  }

  
  private void initializeScheme(String p_uriSpec) throws MalformedURIException
  {

    int uriSpecLen = p_uriSpec.length();
    int index = 0;
    String scheme = null;
    char testChar = ' ';

    while (index < uriSpecLen)
    {
      testChar = p_uriSpec.charAt(index);

      if (testChar == ':' || testChar == '/' || testChar == '?'
              || testChar == '#')
      {
        break;
      }

      index++;
    }

    scheme = p_uriSpec.substring(0, index);

    if (scheme.length() == 0)
    {
      throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_SCHEME_INURI, null)); 
    }
    else
    {
      setScheme(scheme);
    }
  }

  
  private void initializeAuthority(String p_uriSpec)
          throws MalformedURIException
  {

    int index = 0;
    int start = 0;
    int end = p_uriSpec.length();
    char testChar = ' ';
    String userinfo = null;

    
    if (p_uriSpec.indexOf('@', start) != -1)
    {
      while (index < end)
      {
        testChar = p_uriSpec.charAt(index);

        if (testChar == '@')
        {
          break;
        }

        index++;
      }

      userinfo = p_uriSpec.substring(start, index);

      index++;
    }

    
    String host = null;

    start = index;

    while (index < end)
    {
      testChar = p_uriSpec.charAt(index);

      if (testChar == ':')
      {
        break;
      }

      index++;
    }

    host = p_uriSpec.substring(start, index);

    int port = -1;

    if (host.length() > 0)
    {

      
      if (testChar == ':')
      {
        index++;

        start = index;

        while (index < end)
        {
          index++;
        }

        String portStr = p_uriSpec.substring(start, index);

        if (portStr.length() > 0)
        {
          for (int i = 0; i < portStr.length(); i++)
          {
            if (!isDigit(portStr.charAt(i)))
            {
              throw new MalformedURIException(
                portStr + "" is invalid. Port should only contain digits!"");
            }
          }

          try
          {
            port = Integer.parseInt(portStr);
          }
          catch (NumberFormatException nfe)
          {

            
          }
        }
      }
    }

    setHost(host);
    setPort(port);
    setUserinfo(userinfo);
  }

  
  private void initializePath(String p_uriSpec) throws MalformedURIException
  {

    if (p_uriSpec == null)
    {
      throw new MalformedURIException(
        ""Cannot initialize path from null string!"");
    }

    int index = 0;
    int start = 0;
    int end = p_uriSpec.length();
    char testChar = ' ';

    
    while (index < end)
    {
      testChar = p_uriSpec.charAt(index);

      if (testChar == '?' || testChar == '#')
      {
        break;
      }

      
      if (testChar == '%')
      {
        if (index + 2 >= end ||!isHex(p_uriSpec.charAt(index + 1))
                ||!isHex(p_uriSpec.charAt(index + 2)))
        {
          throw new MalformedURIException(
            XSLMessages.createMessage(XSLTErrorResources.ER_PATH_CONTAINS_INVALID_ESCAPE_SEQUENCE, null)); 
        }
      }
      else if (!isReservedCharacter(testChar)
               &&!isUnreservedCharacter(testChar))
      {
        if ('\' != testChar)
          throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_PATH_INVALID_CHAR, new Object[]{String.valueOf(testChar)})); 
                                          
      }

      index++;
    }

    m_path = p_uriSpec.substring(start, index);

    
    if (testChar == '?')
    {
      index++;

      start = index;

      while (index < end)
      {
        testChar = p_uriSpec.charAt(index);

        if (testChar == '#')
        {
          break;
        }

        if (testChar == '%')
        {
          if (index + 2 >= end ||!isHex(p_uriSpec.charAt(index + 1))
                  ||!isHex(p_uriSpec.charAt(index + 2)))
          {
            throw new MalformedURIException(
              ""Query string contains invalid escape sequence!"");
          }
        }
        else if (!isReservedCharacter(testChar)
                 &&!isUnreservedCharacter(testChar))
        {
          throw new MalformedURIException(
            ""Query string contains invalid character:"" + testChar);
        }

        index++;
      }

      m_queryString = p_uriSpec.substring(start, index);
    }

    
    if (testChar == '#')
    {
      index++;

      start = index;

      while (index < end)
      {
        testChar = p_uriSpec.charAt(index);

        if (testChar == '%')
        {
          if (index + 2 >= end ||!isHex(p_uriSpec.charAt(index + 1))
                  ||!isHex(p_uriSpec.charAt(index + 2)))
          {
            throw new MalformedURIException(
              ""Fragment contains invalid escape sequence!"");
          }
        }
        else if (!isReservedCharacter(testChar)
                 &&!isUnreservedCharacter(testChar))
        {
          throw new MalformedURIException(
            ""Fragment contains invalid character:"" + testChar);
        }

        index++;
      }

      m_fragment = p_uriSpec.substring(start, index);
    }
  }

  
  public String getScheme()
  {
    return m_scheme;
  }

  
  public String getSchemeSpecificPart()
  {

    StringBuffer schemespec = new StringBuffer();

    if (m_userinfo != null || m_host != null || m_port != -1)
    {
      schemespec.append(""
    }

    if (m_userinfo != null)
    {
      schemespec.append(m_userinfo);
      schemespec.append('@');
    }

    if (m_host != null)
    {
      schemespec.append(m_host);
    }

    if (m_port != -1)
    {
      schemespec.append(':');
      schemespec.append(m_port);
    }

    if (m_path != null)
    {
      schemespec.append((m_path));
    }

    if (m_queryString != null)
    {
      schemespec.append('?');
      schemespec.append(m_queryString);
    }

    if (m_fragment != null)
    {
      schemespec.append('#');
      schemespec.append(m_fragment);
    }

    return schemespec.toString();
  }

  
  public String getUserinfo()
  {
    return m_userinfo;
  }

  
  public String getHost()
  {
    return m_host;
  }

  
  public int getPort()
  {
    return m_port;
  }

  
  public String getPath(boolean p_includeQueryString,
                        boolean p_includeFragment)
  {

    StringBuffer pathString = new StringBuffer(m_path);

    if (p_includeQueryString && m_queryString != null)
    {
      pathString.append('?');
      pathString.append(m_queryString);
    }

    if (p_includeFragment && m_fragment != null)
    {
      pathString.append('#');
      pathString.append(m_fragment);
    }

    return pathString.toString();
  }

  
  public String getPath()
  {
    return m_path;
  }

  
  public String getQueryString()
  {
    return m_queryString;
  }

  
  public String getFragment()
  {
    return m_fragment;
  }

  
  public void setScheme(String p_scheme) throws MalformedURIException
  {

    if (p_scheme == null)
    {
      throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_SCHEME_FROM_NULL_STRING, null)); 
    }

    if (!isConformantSchemeName(p_scheme))
    {
      throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_SCHEME_NOT_CONFORMANT, null)); 
    }

    m_scheme = p_scheme.toLowerCase();
  }

  
  public void setUserinfo(String p_userinfo) throws MalformedURIException
  {

    if (p_userinfo == null)
    {
      m_userinfo = null;
    }
    else
    {
      if (m_host == null)
      {
        throw new MalformedURIException(
          ""Userinfo cannot be set when host is null!"");
      }

      
      
      int index = 0;
      int end = p_userinfo.length();
      char testChar = ' ';

      while (index < end)
      {
        testChar = p_userinfo.charAt(index);

        if (testChar == '%')
        {
          if (index + 2 >= end ||!isHex(p_userinfo.charAt(index + 1))
                  ||!isHex(p_userinfo.charAt(index + 2)))
          {
            throw new MalformedURIException(
              ""Userinfo contains invalid escape sequence!"");
          }
        }
        else if (!isUnreservedCharacter(testChar)
                 && USERINFO_CHARACTERS.indexOf(testChar) == -1)
        {
          throw new MalformedURIException(
            ""Userinfo contains invalid character:"" + testChar);
        }

        index++;
      }
    }

    m_userinfo = p_userinfo;
  }

  
  public void setHost(String p_host) throws MalformedURIException
  {

    if (p_host == null || p_host.trim().length() == 0)
    {
      m_host = p_host;
      m_userinfo = null;
      m_port = -1;
    }
    else if (!isWellFormedAddress(p_host))
    {
      throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_HOST_ADDRESS_NOT_WELLFORMED, null)); 
    }

    m_host = p_host;
  }

  
  public void setPort(int p_port) throws MalformedURIException
  {

    if (p_port >= 0 && p_port <= 65535)
    {
      if (m_host == null)
      {
        throw new MalformedURIException(
          XSLMessages.createMessage(XSLTErrorResources.ER_PORT_WHEN_HOST_NULL, null)); 
      }
    }
    else if (p_port != -1)
    {
      throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_PORT, null)); 
    }

    m_port = p_port;
  }

  
  public void setPath(String p_path) throws MalformedURIException
  {

    if (p_path == null)
    {
      m_path = null;
      m_queryString = null;
      m_fragment = null;
    }
    else
    {
      initializePath(p_path);
    }
  }

  
  public void appendPath(String p_addToPath) throws MalformedURIException
  {

    if (p_addToPath == null || p_addToPath.trim().length() == 0)
    {
      return;
    }

    if (!isURIString(p_addToPath))
    {
      throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_PATH_INVALID_CHAR, new Object[]{p_addToPath})); 
    }

    if (m_path == null || m_path.trim().length() == 0)
    {
      if (p_addToPath.startsWith(""/""))
      {
        m_path = p_addToPath;
      }
      else
      {
        m_path = ""/"" + p_addToPath;
      }
    }
    else if (m_path.endsWith(""/""))
    {
      if (p_addToPath.startsWith(""/""))
      {
        m_path = m_path.concat(p_addToPath.substring(1));
      }
      else
      {
        m_path = m_path.concat(p_addToPath);
      }
    }
    else
    {
      if (p_addToPath.startsWith(""/""))
      {
        m_path = m_path.concat(p_addToPath);
      }
      else
      {
        m_path = m_path.concat(""/"" + p_addToPath);
      }
    }
  }

  
  public void setQueryString(String p_queryString)
          throws MalformedURIException
  {

    if (p_queryString == null)
    {
      m_queryString = null;
    }
    else if (!isGenericURI())
    {
      throw new MalformedURIException(
        ""Query string can only be set for a generic URI!"");
    }
    else if (getPath() == null)
    {
      throw new MalformedURIException(
        ""Query string cannot be set when path is null!"");
    }
    else if (!isURIString(p_queryString))
    {
      throw new MalformedURIException(
        ""Query string contains invalid character!"");
    }
    else
    {
      m_queryString = p_queryString;
    }
  }

  
  public void setFragment(String p_fragment) throws MalformedURIException
  {

    if (p_fragment == null)
    {
      m_fragment = null;
    }
    else if (!isGenericURI())
    {
      throw new MalformedURIException(
        XSLMessages.createMessage(XSLTErrorResources.ER_FRAG_FOR_GENERIC_URI, null)); 
    }
    else if (getPath() == null)
    {
      throw new MalformedURIException(
        XSLMessages.createMessage(XSLTErrorResources.ER_FRAG_WHEN_PATH_NULL, null)); 
    }
    else if (!isURIString(p_fragment))
    {
      throw new MalformedURIException(XSLMessages.createMessage(XSLTErrorResources.ER_FRAG_INVALID_CHAR, null)); 
    }
    else
    {
      m_fragment = p_fragment;
    }
  }

  
  public boolean equals(Object p_test)
  {

    if (p_test instanceof URI)
    {
      URI testURI = (URI) p_test;

      if (((m_scheme == null && testURI.m_scheme == null) || (m_scheme != null && testURI.m_scheme != null && m_scheme.equals(
              testURI.m_scheme))) && ((m_userinfo == null && testURI.m_userinfo == null) || (m_userinfo != null && testURI.m_userinfo != null && m_userinfo.equals(
              testURI.m_userinfo))) && ((m_host == null && testURI.m_host == null) || (m_host != null && testURI.m_host != null && m_host.equals(
              testURI.m_host))) && m_port == testURI.m_port && ((m_path == null && testURI.m_path == null) || (m_path != null && testURI.m_path != null && m_path.equals(
              testURI.m_path))) && ((m_queryString == null && testURI.m_queryString == null) || (m_queryString != null && testURI.m_queryString != null && m_queryString.equals(
              testURI.m_queryString))) && ((m_fragment == null && testURI.m_fragment == null) || (m_fragment != null && testURI.m_fragment != null && m_fragment.equals(
              testURI.m_fragment))))
      {
        return true;
      }
    }

    return false;
  }

  
  public String toString()
  {

    StringBuffer uriSpecString = new StringBuffer();

    if (m_scheme != null)
    {
      uriSpecString.append(m_scheme);
      uriSpecString.append(':');
    }

    uriSpecString.append(getSchemeSpecificPart());

    return uriSpecString.toString();
  }

  
  public boolean isGenericURI()
  {

    
    
    return (m_host != null);
  }

  
  public static boolean isConformantSchemeName(String p_scheme)
  {

    if (p_scheme == null || p_scheme.trim().length() == 0)
    {
      return false;
    }

    if (!isAlpha(p_scheme.charAt(0)))
    {
      return false;
    }

    char testChar;

    for (int i = 1; i < p_scheme.length(); i++)
    {
      testChar = p_scheme.charAt(i);

      if (!isAlphanum(testChar) && SCHEME_CHARACTERS.indexOf(testChar) == -1)
      {
        return false;
      }
    }

    return true;
  }

  
  public static boolean isWellFormedAddress(String p_address)
  {

    if (p_address == null)
    {
      return false;
    }

    String address = p_address.trim();
    int addrLength = address.length();

    if (addrLength == 0 || addrLength > 255)
    {
      return false;
    }

    if (address.startsWith(""."") || address.startsWith(""-""))
    {
      return false;
    }

    
    
    
    int index = address.lastIndexOf('.');

    if (address.endsWith("".""))
    {
      index = address.substring(0, index).lastIndexOf('.');
    }

    if (index + 1 < addrLength && isDigit(p_address.charAt(index + 1)))
    {
      char testChar;
      int numDots = 0;

      
      
      
      for (int i = 0; i < addrLength; i++)
      {
        testChar = address.charAt(i);

        if (testChar == '.')
        {
          if (!isDigit(address.charAt(i - 1))
                  || (i + 1 < addrLength &&!isDigit(address.charAt(i + 1))))
          {
            return false;
          }

          numDots++;
        }
        else if (!isDigit(testChar))
        {
          return false;
        }
      }

      if (numDots != 3)
      {
        return false;
      }
    }
    else
    {

      
      
      char testChar;

      for (int i = 0; i < addrLength; i++)
      {
        testChar = address.charAt(i);

        if (testChar == '.')
        {
          if (!isAlphanum(address.charAt(i - 1)))
          {
            return false;
          }

          if (i + 1 < addrLength &&!isAlphanum(address.charAt(i + 1)))
          {
            return false;
          }
        }
        else if (!isAlphanum(testChar) && testChar != '-')
        {
          return false;
        }
      }
    }

    return true;
  }

  
  private static boolean isDigit(char p_char)
  {
    return p_char >= '0' && p_char <= '9';
  }

  
  private static boolean isHex(char p_char)
  {
    return (isDigit(p_char) || (p_char >= 'a' && p_char <= 'f')
            || (p_char >= 'A' && p_char <= 'F'));
  }

  
  private static boolean isAlpha(char p_char)
  {
    return ((p_char >= 'a' && p_char <= 'z')
            || (p_char >= 'A' && p_char <= 'Z'));
  }

  
  private static boolean isAlphanum(char p_char)
  {
    return (isAlpha(p_char) || isDigit(p_char));
  }

  
  private static boolean isReservedCharacter(char p_char)
  {
    return RESERVED_CHARACTERS.indexOf(p_char) != -1;
  }

  
  private static boolean isUnreservedCharacter(char p_char)
  {
    return (isAlphanum(p_char) || MARK_CHARACTERS.indexOf(p_char) != -1);
  }

  
  private static boolean isURIString(String p_uric)
  {

    if (p_uric == null)
    {
      return false;
    }

    int end = p_uric.length();
    char testChar = ' ';

    for (int i = 0; i < end; i++)
    {
      testChar = p_uric.charAt(i);

      if (testChar == '%')
      {
        if (i + 2 >= end ||!isHex(p_uric.charAt(i + 1))
                ||!isHex(p_uric.charAt(i + 2)))
        {
          return false;
        }
        else
        {
          i += 2;

          continue;
        }
      }

      if (isReservedCharacter(testChar) || isUnreservedCharacter(testChar))
      {
        continue;
      }
      else
      {
        return false;
      }
    }

    return true;
  }
}
"
org.apache.xpath.operations.Mult,3,3,0,7,7,3,2,5,3,2.0,25,0.0,0,0.953488372,0.555555556,1,1,7.333333333,1,0.6667,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.XPathContext;


public class Mult extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber(left.num() * right.num());
  }
  
  
  public double num(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return (m_left.num(xctxt) * m_right.num(xctxt));
  }

}
"
org.apache.xpath.axes.BasicTestIterator,7,5,2,12,23,21,3,10,2,2.0,163,0.0,0,0.9765625,0.371428571,2,4,22.28571429,11,1.8571,0,"package org.apache.xpath.axes;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.VariableStack;
import org.apache.xpath.compiler.Compiler;


public abstract class BasicTestIterator extends LocPathIterator
{
  
  protected BasicTestIterator()
  {
  }


  
  protected BasicTestIterator(PrefixResolver nscontext)
  {

    super(nscontext);
  }

  
  protected BasicTestIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, false);
    
    int firstStepPos = compiler.getFirstChildPos(opPos);
    int whatToShow = compiler.getWhatToShow(firstStepPos);

    if ((0 == (whatToShow
               & (DTMFilter.SHOW_ATTRIBUTE 
               | DTMFilter.SHOW_NAMESPACE 
               | DTMFilter.SHOW_ELEMENT
               | DTMFilter.SHOW_PROCESSING_INSTRUCTION))) 
               || (whatToShow == DTMFilter.SHOW_ALL))
      initNodeTest(whatToShow);
    else
    {
      initNodeTest(whatToShow, compiler.getStepNS(firstStepPos),
                              compiler.getStepLocalName(firstStepPos));
    }
    initPredicateInfo(compiler, firstStepPos);
  }

  
  protected BasicTestIterator(
          Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers)
            throws javax.xml.transform.TransformerException
  {
    super(compiler, opPos, analysis, shouldLoadWalkers);
  }

	
  
  protected abstract int getNextNode();

  
  public int nextNode()
  {      
  	if(m_foundLast)
  	{
  		m_lastFetched = DTM.NULL;
  		return DTM.NULL;
  	}
  		
    if(DTM.NULL == m_lastFetched)
    {
      resetProximityPositions();
    }

    int next;
    
    org.apache.xpath.VariableStack vars;
    int savedStart;
    if (-1 != m_stackFrame)
    {
      vars = m_execContext.getVarStack();

      
      savedStart = vars.getStackFrame();

      vars.setStackFrame(m_stackFrame);
    }
    else
    {
      
      vars = null;
      savedStart = 0;
    }
    
    try
    {
      do
      {
        next = getNextNode();
  
        if (DTM.NULL != next)
        {
          if(DTMIterator.FILTER_ACCEPT == acceptNode(next))
            break;
          else
            continue;
        }
        else
          break;
      }
      while (next != DTM.NULL);
  
      if (DTM.NULL != next)
      {
      	m_pos++;
        return next;
      }
      else
      {
        m_foundLast = true;
  
        return DTM.NULL;
      }
    }
    finally
    {
      if (-1 != m_stackFrame)
      {
        
        vars.setStackFrame(savedStart);
      }
    }
  }
  
  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {

    ChildTestIterator clone = (ChildTestIterator) super.cloneWithReset();

    clone.resetProximityPositions();

    return clone;
  }


}

"
org.apache.xalan.xsltc.compiler.ValueOf,5,3,0,24,32,0,1,23,4,0.375,177,1.0,1,0.933333333,0.333333333,2,5,34.0,4,1.8,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.bcel.generic.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class ValueOf extends Instruction {
    private Expression _select;
    private boolean _escaping = true;
	
    public void display(int indent) {
	indent(indent);
	Util.println(""ValueOf"");
	indent(indent + IndentIncrement);
	Util.println(""select "" + _select.toString());
    }
		
    public void parseContents(Parser parser) {
	_select = parser.parseExpression(this, ""select"", null);

        
        if (_select.isDummy()) {
	    reportError(this, parser, ErrorMsg.REQUIRED_ATTR_ERR, ""select"");
	    return;
        }
        final String str = getAttribute(""disable-output-escaping"");
	if ((str != null) && (str.equals(""yes""))) _escaping = false;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	Type type = _select.typeCheck(stable);
	if ((type != null) && (type.identicalTo(Type.String) == false))
	    _select = new CastExpr(_select, Type.String);
	return Type.Void;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final int setEscaping = cpg.addInterfaceMethodref(OUTPUT_HANDLER,
							  ""setEscaping"",""(Z)Z"");
	final int characters = cpg.addMethodref(TRANSLET_CLASS,
						CHARACTERSW,
						CHARACTERSW_SIG);

	
	if (!_escaping) {
	    il.append(methodGen.loadHandler());
	    il.append(new PUSH(cpg,false));
	    il.append(new INVOKEINTERFACE(setEscaping,2));
	}

	
	il.append(classGen.loadTranslet());
	_select.translate(classGen, methodGen);	
	il.append(methodGen.loadHandler());
	il.append(new INVOKEVIRTUAL(characters));

	
	if (!_escaping) {
	    il.append(methodGen.loadHandler());
	    il.append(SWAP);
	    il.append(new INVOKEINTERFACE(setEscaping,2));
	    il.append(POP);
	}
    }
}
"
org.apache.xml.utils.Hashtree2Node,2,1,0,1,22,1,1,0,2,2.0,145,0.0,0,0.0,0.5,0,0,71.5,8,4.0,0,"

package org.apache.xml.utils;

import java.util.Enumeration;
import java.util.Hashtable;
import java.util.StringTokenizer;
import java.util.Vector;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;


public abstract class Hashtree2Node
{

    
    public static void appendHashToNode(Hashtable hash, String name, 
            Node container, Document factory)
    {
        
        if ((null == container) || (null == factory) || (null == hash))
        {
            return;
        }

        
        String elemName = null;
        if ((null == name) || ("""".equals(name)))
            elemName = ""appendHashToNode"";
        else
            elemName = name;

        try
        {
            Element hashNode = factory.createElement(elemName);
            container.appendChild(hashNode);

            Enumeration enum = hash.keys();
            Vector v = new Vector();

            while (enum.hasMoreElements())
            {
                Object key = enum.nextElement();
                String keyStr = key.toString();
                Object item = hash.get(key);

                if (item instanceof Hashtable)
                {
                    
                    
                    
                    v.addElement(keyStr);
                    v.addElement((Hashtable) item);
                }
                else
                {
                    try
                    {
                        
                        Element node = factory.createElement(""item"");
                        node.setAttribute(""key"", keyStr);
                        node.appendChild(factory.createTextNode((String)item));
                        hashNode.appendChild(node);
                    }
                    catch (Exception e)
                    {
                        Element node = factory.createElement(""item"");
                        node.setAttribute(""key"", keyStr);
                        node.appendChild(factory.createTextNode(""ERROR: Reading "" + key + "" threw: "" + e.toString()));
                        hashNode.appendChild(node);
                    }
                }
            }

            
            enum = v.elements();
            while (enum.hasMoreElements())
            {
                
                String n = (String) enum.nextElement();
                Hashtable h = (Hashtable) enum.nextElement();

                appendHashToNode(h, n, hashNode, factory);
            }
        }
        catch (Exception e2)
        {
            
            
            e2.printStackTrace();
        }
    }    
}
"
org.apache.xalan.processor.ProcessorStylesheetElement,3,4,0,9,29,3,2,9,2,2.0,107,0.0,0,0.990566038,0.666666667,1,1,34.66666667,1,0.6667,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xalan.templates.StylesheetComposed;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;

import javax.xml.transform.TransformerConfigurationException;


class ProcessorStylesheetElement extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

		super.startElement(handler, uri, localName, rawName, attributes);
    try
    {
      int stylesheetType = handler.getStylesheetType();
      Stylesheet stylesheet;

      if (stylesheetType == StylesheetHandler.STYPE_ROOT)
      {
        try
        {
          stylesheet = new StylesheetRoot(handler.getSchema(), handler.getStylesheetProcessor().getErrorListener());
        }
        catch(TransformerConfigurationException tfe)
        {
          throw new TransformerException(tfe);
        }
      }
      else
      {
        Stylesheet parent = handler.getStylesheet();

        if (stylesheetType == StylesheetHandler.STYPE_IMPORT)
        {
          StylesheetComposed sc = new StylesheetComposed(parent);

          parent.setImport(sc);

          stylesheet = sc;
        }
        else
        {
          stylesheet = new Stylesheet(parent);

          parent.setInclude(stylesheet);
        }
      }

      stylesheet.setDOMBackPointer(handler.getOriginatingNode());
      stylesheet.setLocaterInfo(handler.getLocator());

      stylesheet.setPrefixes(handler.getNamespaceSupport());
      handler.pushStylesheet(stylesheet);
      setPropertiesFromAttributes(handler, rawName, attributes,
                                  handler.getStylesheet());
      handler.pushElemTemplateElement(handler.getStylesheet());
    }
    catch(TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {
		super.endElement(handler, uri, localName, rawName);
    handler.popElemTemplateElement();
    handler.popStylesheet();
  }
}
"
org.apache.xalan.xsltc.dom.DTDMonitor,13,1,0,11,41,38,8,4,12,0.944444444,265,1.0,2,0.0,0.269230769,0,0,18.92307692,9,1.6923,0,"

package org.apache.xalan.xsltc.dom;

import java.util.Enumeration;

import org.xml.sax.XMLReader;
import org.xml.sax.DTDHandler;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.SAXException;
import org.xml.sax.SAXNotRecognizedException;
import org.xml.sax.SAXNotSupportedException;

import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.runtime.Hashtable;

final public class DTDMonitor implements DTDHandler, DeclHandler {

    private final static String EMPTYSTRING = """";

    
    private final static String ID_INDEX_NAME = ""##id"";
    
    private Hashtable _idAttributes = new Hashtable(); 
    
    private Hashtable _unparsedEntities = new Hashtable();

    
    private final static String DECL_HANDLER_PROP =
	""http:

    
    private final static String NO_DTD_SUPPORT_STR =
	""Your SAX parser does not handle DTD declarations"";

    
    public DTDMonitor() { }

    
    public DTDMonitor(XMLReader reader) throws RuntimeException {
	handleDTD(reader);
    }

    
    public void handleDTD(XMLReader reader) throws RuntimeException {
	try {
	    reader.setProperty(DECL_HANDLER_PROP, this);
	    reader.setDTDHandler(this);
	}
	catch (SAXNotRecognizedException e) {
	    throw(new RuntimeException(NO_DTD_SUPPORT_STR));
	}
	catch (SAXNotSupportedException e) {
	    throw(new RuntimeException(NO_DTD_SUPPORT_STR));
	}
    }

    
    public void notationDecl(String name, String publicId, String systemId)
	throws SAXException { }

    
    public void unparsedEntityDecl(String name, String publicId,
				   String systemId, String notation)
	throws SAXException {
	if (_unparsedEntities.containsKey(name) == false) {
	    _unparsedEntities.put(name, systemId);
	}
    }

    public Hashtable getUnparsedEntityURIs() {
	return(_unparsedEntities);
    }

    
    public void attributeDecl(String element, String attribute, String type,
			      String[] options, String defaultValue,
			      boolean fixed, boolean required) {
	_idAttributes.put(element, ""@""+attribute);
    }

    
    public void attributeDecl(String element, String attribute, 
			      String type, String defaultValue, String value) {
	
	
	
	
	
	if (type.equals(""ID"") || (type.equals(""IDREF"")))
	    _idAttributes.put(element, ""@""+attribute);
    }
    
    
    public void elementDecl(String element, String model) { }
                 
    
    public void externalEntityDecl(String name, String pid, String sid) { }
                 

    
    public void internalEntityDecl(String name, String value) { }

    
    private final String getIdAttrName(String elemtName) {
        final String idAttrName = (String)_idAttributes.get(elemtName);
        return ((idAttrName == null) ? """" : idAttrName);
    }

    
    public final void buildIdIndex(DOMImpl dom, int mask,
				   AbstractTranslet translet) {

	
	int node, attr, type, typeCache;

	
	translet.setIndexSize(dom.getSize());

	
	if ((_idAttributes == null) || (_idAttributes.isEmpty())) return;

	
	
	
	
	
	Enumeration elements = _idAttributes.keys();
	if (elements.nextElement() instanceof String) {
	    Hashtable newAttributes = new Hashtable();
	    elements = _idAttributes.keys();
	    while (elements.hasMoreElements()) {
		String element = (String)elements.nextElement();
		String attribute = (String)_idAttributes.get(element);
		int elemType = dom.getGeneralizedType(element);
		int attrType = dom.getGeneralizedType(attribute);
		newAttributes.put(new Integer(elemType), new Integer(attrType));
	    }
	    _idAttributes = newAttributes;
	}

	
	final NodeIterator iter = dom.getAxisIterator(Axis.DESCENDANT);
	iter.setStartNode(DOM.ROOTNODE);

	Integer E = new Integer(typeCache = 0);
	Integer A = null;

	while ((node = iter.next()) != NodeIterator.END) {
	    
	    type = dom.getType(node);
	    if (type != typeCache) {
		E = new Integer(typeCache = type);
		A = (Integer)_idAttributes.get(E);
	    }

	    
	    if (A != null) {
		
		if ((attr = dom.getAttributeNode(A.intValue(), node)) != 0) {
		    final String value = dom.getNodeValue(attr);
		    translet.buildKeyIndex(ID_INDEX_NAME, mask|node, value);
		}
	    }
	}
    }

}

"
org.apache.xalan.xsltc.dom.CurrentNodeListFilter,1,1,0,3,1,0,1,2,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;

public interface CurrentNodeListFilter {
    public abstract boolean test(int node, int position, int last, int current,
				 AbstractTranslet translet, NodeIterator iter);
}
"
org.apache.xalan.xsltc.compiler.util.SlotAllocator,4,1,0,4,16,0,1,3,3,0.5,242,1.0,0,0.0,0.4375,0,0,58.5,6,3.0,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.*;

final class SlotAllocator {

    private int   _firstAvailableSlot;
    private int   _size = 8;
    private int   _free = 0;
    private int[] _slotsTaken = new int[_size];
    
    public void initialize(LocalVariableGen[] vars) {
	final int length = vars.length;
	int slot = 0, size, index;

	for (int i = 0; i < length; i++) {
	    size  = vars[i].getType().getSize();
	    index = vars[i].getIndex();
	    slot  = Math.max(slot, index + size);
	}
	_firstAvailableSlot = slot;
    }

    public int allocateSlot(Type type) {
	final int size = type.getSize();
	final int limit = _free;
	int slot = _firstAvailableSlot, where = 0;

	if (_free + size > _size) {
	    final int[] array = new int[_size *= 2];
	    for (int j = 0; j < limit; j++)
		array[j] = _slotsTaken[j];
	    _slotsTaken = array;
	}

	while (where < limit) {
	    if (slot + size <= _slotsTaken[where]) {
		
		for (int j = limit - 1; j >= where; j--)
		    _slotsTaken[j + size] = _slotsTaken[j];
		break;
	    }
	    else {
		slot = _slotsTaken[where++] + 1;
	    }
	}
	
	for (int j = 0; j < size; j++)
	    _slotsTaken[where + j] = slot + j;
	
	_free += size;
	return slot;
    }

    public void releaseSlot(LocalVariableGen lvg) {
	final int size = lvg.getType().getSize();
	final int slot = lvg.getIndex();
	final int limit = _free;
	
	for (int i = 0; i < limit; i++) {
	    if (_slotsTaken[i] == slot) {
		int j = i + size;
		while (j < limit) {
		    _slotsTaken[i++] = _slotsTaken[j++];
		}
		_free -= size;
		return;
	    }
	}
	String state = ""Variable slot allocation error""+
	               ""(size=""+size+"", slot=""+slot+"", limit=""+limit+"")"";
	ErrorMsg err = new ErrorMsg(ErrorMsg.INTERNAL_ERR, state);
	throw new Error(err.toString());
    }
}
"
org.apache.xalan.trace.TraceManager,13,1,0,40,32,0,27,14,13,0.333333333,293,1.0,1,0.0,0.211538462,0,0,21.38461538,4,1.7692,1,"
package org.apache.xalan.trace;

import java.util.Vector;
import java.util.TooManyListenersException;

import org.w3c.dom.Node;

import org.apache.xml.utils.QName;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.XPath;


public class TraceManager
{

  
  private TransformerImpl m_transformer;

  
  public TraceManager(TransformerImpl transformer)
  {
    m_transformer = transformer;
  }

  
  private Vector m_traceListeners = null;

  
  public void addTraceListener(TraceListener tl)
          throws TooManyListenersException
  {

    TransformerImpl.S_DEBUG = true;

    if (null == m_traceListeners)
      m_traceListeners = new Vector();

    m_traceListeners.addElement(tl);
  }

  
  public void removeTraceListener(TraceListener tl)
  {

    if (null != m_traceListeners)
    {
      m_traceListeners.removeElement(tl);
    }
  }

  
  public void fireGenerateEvent(GenerateEvent te)
  {

    if (null != m_traceListeners)
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);

        tl.generated(te);
      }
    }
  }

  
  public boolean hasTraceListeners()
  {
    return (null != m_traceListeners);
  }

  
  public void fireTraceEvent(ElemTemplateElement styleNode)
  {

    if (hasTraceListeners())
    {
      int sourceNode = m_transformer.getXPathContext().getCurrentNode();
      Node source = m_transformer.getXPathContext().getDTM(
        sourceNode).getNode(sourceNode);

      fireTraceEvent(new TracerEvent(m_transformer, source, 
                     m_transformer.getMode(),  
                                     styleNode));
    }
  }

  
  public void fireTraceEndEvent(ElemTemplateElement styleNode)
  {

    if (hasTraceListeners())
    {
      int sourceNode = m_transformer.getXPathContext().getCurrentNode();
      Node source = m_transformer.getXPathContext().getDTM(
        sourceNode).getNode(sourceNode);

      fireTraceEndEvent(new TracerEvent(m_transformer, source,
                     m_transformer.getMode(),  
                                     styleNode));
    }
  }

  
  public void fireTraceEndEvent(TracerEvent te)
  {

    if (hasTraceListeners())
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);
        if(tl instanceof TraceListenerEx2)
        {
          ((TraceListenerEx2)tl).traceEnd(te);
        }
      }
    }
  }



  
  public void fireTraceEvent(TracerEvent te)
  {

    if (hasTraceListeners())
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);

        tl.trace(te);
      }
    }
  }

  
  public void fireSelectedEvent(
          int sourceNode, ElemTemplateElement styleNode, String attributeName, 
          XPath xpath, XObject selection)
            throws javax.xml.transform.TransformerException
  {

    if (hasTraceListeners())
    {
      Node source = m_transformer.getXPathContext().getDTM(
        sourceNode).getNode(sourceNode);
        
      fireSelectedEvent(new SelectionEvent(m_transformer, source, styleNode,
                                           attributeName, xpath, selection));
    }
  }
  
  
  public void fireSelectedEndEvent(
          int sourceNode, ElemTemplateElement styleNode, String attributeName, 
          XPath xpath, XObject selection)
            throws javax.xml.transform.TransformerException
  {

    if (hasTraceListeners())
    {
      Node source = m_transformer.getXPathContext().getDTM(
        sourceNode).getNode(sourceNode);
        
      fireSelectedEndEvent(new EndSelectionEvent(m_transformer, source, styleNode,
                                           attributeName, xpath, selection));
    }
  }
  
  
  public void fireSelectedEndEvent(EndSelectionEvent se)
          throws javax.xml.transform.TransformerException
  {

    if (hasTraceListeners())
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);

        if(tl instanceof TraceListenerEx)
          ((TraceListenerEx)tl).selectEnd(se);
      }
    }
  }

  
  public void fireSelectedEvent(SelectionEvent se)
          throws javax.xml.transform.TransformerException
  {

    if (hasTraceListeners())
    {
      int nListeners = m_traceListeners.size();

      for (int i = 0; i < nListeners; i++)
      {
        TraceListener tl = (TraceListener) m_traceListeners.elementAt(i);

        tl.selected(se);
      }
    }
  }
}
"
org.apache.xalan.xsltc.compiler.util.AttributeSetMethodGenerator,8,5,0,11,15,14,1,10,7,0.839285714,100,1.0,0,0.958333333,0.476190476,1,2,10.5,1,0.75,0,"

package org.apache.xalan.xsltc.compiler.util;

import java.util.Vector;
import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.Template;

public final class AttributeSetMethodGenerator extends MethodGenerator {
    private static int HANDLER_INDEX = 1;
    private static int ITERATOR_INDEX = 2;

    private static final org.apache.bcel.generic.Type[] argTypes =
	new org.apache.bcel.generic.Type[2];
    private static final String[] argNames = new String[2];
    
    static {
	argTypes[0] = Util.getJCRefType(TRANSLET_OUTPUT_SIG);
	argNames[0] = TRANSLET_OUTPUT_PNAME;
	argTypes[1] = Util.getJCRefType(NODE_ITERATOR_SIG);
	argNames[1] = ITERATOR_PNAME;
    }

    private final Instruction _astoreHandler;
    private final Instruction _aloadHandler;
    private final Instruction _astoreIterator;
    private final Instruction _aloadIterator;
    
    public AttributeSetMethodGenerator(String methodName, ClassGen classGen) {
	super(org.apache.bcel.Constants.ACC_PRIVATE,
	      org.apache.bcel.generic.Type.VOID,
	      argTypes, argNames, methodName, 
	      classGen.getClassName(),
	      new InstructionList(),
	      classGen.getConstantPool());
	
	_astoreHandler  = new ASTORE(HANDLER_INDEX);
	_aloadHandler   = new ALOAD(HANDLER_INDEX);
	_astoreIterator = new ASTORE(ITERATOR_INDEX);
	_aloadIterator  = new ALOAD(ITERATOR_INDEX);
    }

    public Instruction storeIterator() {
	return _astoreIterator;
    }
    
    public Instruction loadIterator() {
	return _aloadIterator;
    }

    public int getIteratorIndex() {
	return ITERATOR_INDEX;
    }

    public Instruction storeHandler() {
	return _astoreHandler;
    }

    public Instruction loadHandler() {
	return _aloadHandler;
    }

    public int getLocalIndex(String name) {
	return INVALID_INDEX;	
    }
}
"
org.apache.xml.utils.res.XResources_cy,3,4,0,1,4,1,0,1,2,0.5,583,0.0,0,0.976190476,1.0,0,0,193.0,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;




public class XResources_cy extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

 
  static final Object[][] contents =
  {
    { ""ui_language"", ""cy"" }, { ""help_language"", ""cy"" }, { ""language"", ""cy"" },
    { ""alphabet"",
      new char[]{ 0x0430, 0x0432, 0x0433, 0x0434, 0x0435, 0x0437, 0x0438,
                  0x0439, 0x04A9, 0x0457, 0x043A, 0x043B, 0x043C, 0x043D,
                  0x046F, 0x043E, 0x043F, 0x0447, 0x0440, 0x0441, 0x0442,
                  0x0443, 0x0444, 0x0445, 0x0470, 0x0460, 0x0446 } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""precedes"" },

    
    
    
    { ""numberGroups"", new int[]{ 100, 10, 1 } },

    
    { ""multiplier"", new long[]{ 1000 } },
    { ""multiplierChar"", new char[]{ 0x03D9 } },

    
    { ""zero"", new char[0] },

    
    { ""digits"",
      new char[]{ 0x0430, 0x0432, 0x0433, 0x0434, 0x0435, 0x0437, 0x0438,
                  0x0439, 0x04A9 } },
    { ""tens"",
      new char[]{ 0x0457, 0x043A, 0x043B, 0x043C, 0x043D, 0x046F, 0x043E,
                  0x043F, 0x0447 } },
    { ""hundreds"",
      new char[]{ 0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0470,
                  0x0460, 0x0446 } },
    { ""tables"", new String[]{ ""hundreds"", ""tens"", ""digits"" } }
  };
}
"
org.apache.xalan.xsltc.compiler.QName,10,1,0,56,18,17,56,0,10,0.777777778,106,1.0,0,0.0,0.4,1,1,9.1,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

final class QName {
    private final String _localname;
    private String _prefix;
    private String _namespace;
    private String _stringRep;
    private int    _hashCode;

    public QName(String namespace, String prefix, String localname) {
	_namespace = namespace;
	_prefix    = prefix;
	_localname = localname;

	_stringRep = 
	    (namespace != null && !namespace.equals(Constants.EMPTYSTRING)) ?
	    (namespace + ':' + localname) : localname;

	_hashCode  = _stringRep.hashCode() + 19; 
    }

    public void clearNamespace() {
	_namespace = Constants.EMPTYSTRING;
    }

    public String toString() {
	return _stringRep;
    }

    public String getStringRep() {
	return _stringRep;
    }

    public boolean equals(Object other) {
	return (this == other);
    }

    public String getLocalPart() {
	return _localname;
    }

    public String getNamespace() {
	return _namespace;
    }

    public String getPrefix() {
	return _prefix;
    }

    public int hashCode() {
	return _hashCode;
    }

    public String dump() {
	return new String(""QName: "" + _namespace + ""("" + _prefix + ""):"" 
	    + _localname);
    }
}
"
org.apache.xalan.processor.XSLTElementProcessor,15,3,11,21,48,101,17,6,10,0.821428571,280,1.0,2,0.933333333,0.348148148,0,0,17.53333333,1,0.9333,0,"
package org.apache.xalan.processor;

import org.xml.sax.InputSource;
import org.xml.sax.Attributes;
import org.xml.sax.EntityResolver;
import org.xml.sax.DTDHandler;
import org.xml.sax.ContentHandler;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Constants;
import org.apache.xml.utils.IntStack;

import org.xml.sax.helpers.AttributesImpl;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.TransformerException;

import java.util.Vector;


public class XSLTElementProcessor extends ElemTemplateElement
{

  
  XSLTElementProcessor(){}
	
	private IntStack m_savedLastOrder;

  
  private XSLTElementDef m_elemDef;

  
  XSLTElementDef getElemDef()
  {
    return m_elemDef;
  }

  
  void setElemDef(XSLTElementDef def)
  {
    m_elemDef = def;
  }

  
  public InputSource resolveEntity(
          StylesheetHandler handler, String publicId, String systemId)
            throws org.xml.sax.SAXException
  {
    return null;
  }

  
  public void notationDecl(StylesheetHandler handler, String name,
                           String publicId, String systemId)
  {

    
  }

  
  public void unparsedEntityDecl(StylesheetHandler handler, String name,
                                 String publicId, String systemId,
                                 String notationName)
  {

    
  }

  
  public void startNonText(StylesheetHandler handler) throws org.xml.sax.SAXException
  {

    
  }

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    if (m_savedLastOrder == null)
				m_savedLastOrder = new IntStack();
			m_savedLastOrder.push(getElemDef().getLastOrder());
			getElemDef().setLastOrder(-1);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {
		if (m_savedLastOrder != null && !m_savedLastOrder.empty())
			getElemDef().setLastOrder(m_savedLastOrder.pop());
		
		if (!getElemDef().getRequiredFound())
			handler.error(XSLTErrorResources.ER_REQUIRED_ELEM_NOT_FOUND, new Object[]{getElemDef().getRequiredElem()}, null);
  }

  
  public void characters(
          StylesheetHandler handler, char ch[], int start, int length)
            throws org.xml.sax.SAXException
  {
    handler.error(XSLTErrorResources.ER_CHARS_NOT_ALLOWED, null, null);
                  
  }

  
  public void ignorableWhitespace(
          StylesheetHandler handler, char ch[], int start, int length)
            throws org.xml.sax.SAXException
  {

    
  }

  
  public void processingInstruction(
          StylesheetHandler handler, String target, String data)
            throws org.xml.sax.SAXException
  {

    
  }

  
  public void skippedEntity(StylesheetHandler handler, String name)
          throws org.xml.sax.SAXException
  {

    
  }

  
  void setPropertiesFromAttributes(
          StylesheetHandler handler, String rawName, Attributes attributes, 
          ElemTemplateElement target)
            throws org.xml.sax.SAXException
  {
    setPropertiesFromAttributes(handler, rawName, attributes, target, true);
  }

  
  Attributes setPropertiesFromAttributes(
          StylesheetHandler handler, String rawName, Attributes attributes, 
          ElemTemplateElement target, boolean throwError)
            throws org.xml.sax.SAXException
  {

    XSLTElementDef def = getElemDef();
    AttributesImpl undefines = throwError ? null : new AttributesImpl();

    
    
    Vector processedDefs = new Vector();

    
    Vector errorDefs = new Vector();    
    int nAttrs = attributes.getLength();

    for (int i = 0; i < nAttrs; i++)
    {
      String attrUri = attributes.getURI(i);
      
      if((null != attrUri) && (attrUri.length() == 0)
                           && (attributes.getQName(i).startsWith(""xmlns:"") || 
                               attributes.getQName(i).equals(""xmlns"")))
      {
        attrUri = org.apache.xalan.templates.Constants.S_XMLNAMESPACEURI;
      }
      String attrLocalName = attributes.getLocalName(i);
      XSLTAttributeDef attrDef = def.getAttributeDef(attrUri, attrLocalName);

      if (null == attrDef)
      {
        if (throwError)
        {

          
          handler.error(XSLTErrorResources.ER_ATTR_NOT_ALLOWED, new Object[]{attributes.getQName(i), rawName}, null);
                        
                       
        }
        else
        {
          undefines.addAttribute(attrUri, attrLocalName,
                                 attributes.getQName(i),
                                 attributes.getType(i),
                                 attributes.getValue(i));
        }
      }
      else
      {
        

        boolean success = attrDef.setAttrValue(handler, attrUri, attrLocalName,
                             attributes.getQName(i), attributes.getValue(i),
                             target);
                             
        
        if (success)
            processedDefs.addElement(attrDef);
        else
            errorDefs.addElement(attrDef);
      }
    }

    XSLTAttributeDef[] attrDefs = def.getAttributes();
    int nAttrDefs = attrDefs.length;

    for (int i = 0; i < nAttrDefs; i++)
    {
      XSLTAttributeDef attrDef = attrDefs[i];
      String defVal = attrDef.getDefault();

      if (null != defVal)
      {
        if (!processedDefs.contains(attrDef))
        {
          attrDef.setDefAttrValue(handler, target);
        }
      }

      if (attrDef.getRequired())
      {
        if ((!processedDefs.contains(attrDef)) && (!errorDefs.contains(attrDef)))
          handler.error(
            XSLMessages.createMessage(
              XSLTErrorResources.ER_REQUIRES_ATTRIB, new Object[]{ rawName,
                                                                   attrDef.getName() }), null);
      }
    }

    return undefines;
  }
}
"
org.apache.xalan.templates.ElemPI,8,3,0,10,33,8,0,10,8,0.428571429,164,1.0,1,0.965517241,0.3,2,5,19.375,16,2.75,0,"
package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xml.utils.QName;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;


public class ElemPI extends ElemTemplateElement
{

  
  private AVT m_name_atv = null;

  
  public void setName(AVT v)
  {
    m_name_atv = v;
  }

  
  public AVT getName()
  {
    return m_name_atv;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    java.util.Vector vnames = sroot.getComposeState().getVariableNames();
    if(null != m_name_atv)
      m_name_atv.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
  }



  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_PI;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_PI_STRING;
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    XPathContext xctxt = transformer.getXPathContext();
    int sourceNode = xctxt.getCurrentNode();
    
    String piName = m_name_atv == null ? null : m_name_atv.evaluate(xctxt, sourceNode, this);
    
    
    if (piName == null) return;

    if (piName.equalsIgnoreCase(""xml""))
    {
     	transformer.getMsgMgr().warn(
        this, XSLTErrorResources.WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
              new Object[]{ Constants.ATTRNAME_NAME, piName });
		return;
    }
    
    
    
    else if ((!m_name_atv.isSimple()) && (!isValidNCName(piName)))
    {
     	transformer.getMsgMgr().warn(
        this, XSLTErrorResources.WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
              new Object[]{ Constants.ATTRNAME_NAME, piName });
		return;    	
    }

    
    
    
    
    
    
    
    
    String data = transformer.transformToString(this);

    try
    {
      transformer.getResultTreeHandler().processingInstruction(piName, data);
    }
    catch(org.xml.sax.SAXException se)
    {
      throw new TransformerException(se);
    }
    
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    switch (type)
    {

    
    case Constants.ELEMNAME_TEXTLITERALRESULT :
    case Constants.ELEMNAME_APPLY_TEMPLATES :
    case Constants.ELEMNAME_APPLY_IMPORTS :
    case Constants.ELEMNAME_CALLTEMPLATE :
    case Constants.ELEMNAME_FOREACH :
    case Constants.ELEMNAME_VALUEOF :
    case Constants.ELEMNAME_COPY_OF :
    case Constants.ELEMNAME_NUMBER :
    case Constants.ELEMNAME_CHOOSE :
    case Constants.ELEMNAME_IF :
    case Constants.ELEMNAME_TEXT :
    case Constants.ELEMNAME_COPY :
    case Constants.ELEMNAME_VARIABLE :
    case Constants.ELEMNAME_MESSAGE :

      
      
      
      
      
      break;
    default :
      error(XSLTErrorResources.ER_CANNOT_ADD,
            new Object[]{ newChild.getNodeName(),
                          this.getNodeName() });  

    
    }

    return super.appendChild(newChild);
  }
}
"
org.apache.xml.dtm.ref.DTMDefaultBaseTraversers,2,2,1,33,26,1,24,29,2,2.0,213,0.0,0,0.989130435,0.642857143,0,0,105.5,5,2.5,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;

import javax.xml.transform.Source;

import org.apache.xml.utils.XMLStringFactory;

import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;



public abstract class DTMDefaultBaseTraversers extends DTMDefaultBase
{

  
  public DTMDefaultBaseTraversers(DTMManager mgr, Source source,
                                  int dtmIdentity,
                                  DTMWSFilter whiteSpaceFilter,
                                  XMLStringFactory xstringfactory,
                                  boolean doIndexing)
  {
    super(mgr, source, dtmIdentity, whiteSpaceFilter, xstringfactory,
          doIndexing);
  }

  
  public DTMAxisTraverser getAxisTraverser(final int axis)
  {

    DTMAxisTraverser traverser;

    if (null == m_traversers)  
    {
      m_traversers = new DTMAxisTraverser[Axis.names.length];
      traverser = null;
    }
    else
    {
      traverser = m_traversers[axis];  

      if (traverser != null)
        return traverser;
    }

    switch (axis)  
    {
    case Axis.ANCESTOR :
      traverser = new AncestorTraverser();
      break;
    case Axis.ANCESTORORSELF :
      traverser = new AncestorOrSelfTraverser();
      break;
    case Axis.ATTRIBUTE :
      traverser = new AttributeTraverser();
      break;
    case Axis.CHILD :
      traverser = new ChildTraverser();
      break;
    case Axis.DESCENDANT :
      traverser = new DescendantTraverser();
      break;
    case Axis.DESCENDANTORSELF :
      traverser = new DescendantOrSelfTraverser();
      break;
    case Axis.FOLLOWING :
      traverser = new FollowingTraverser();
      break;
    case Axis.FOLLOWINGSIBLING :
      traverser = new FollowingSiblingTraverser();
      break;
    case Axis.NAMESPACE :
      traverser = new NamespaceTraverser();
      break;
    case Axis.NAMESPACEDECLS :
      traverser = new NamespaceDeclsTraverser();
      break;
    case Axis.PARENT :
      traverser = new ParentTraverser();
      break;
    case Axis.PRECEDING :
      traverser = new PrecedingTraverser();
      break;
    case Axis.PRECEDINGSIBLING :
      traverser = new PrecedingSiblingTraverser();
      break;
    case Axis.SELF :
      traverser = new SelfTraverser();
      break;
    case Axis.ALL :
      traverser = new AllFromRootTraverser();
      break;
    case Axis.ALLFROMNODE :
      traverser = new AllFromNodeTraverser();
      break;
    case Axis.PRECEDINGANDANCESTOR :
      traverser = new PrecedingAndAncestorTraverser();
      break;
    case Axis.DESCENDANTSFROMROOT :
      traverser = new DescendantFromRootTraverser();
      break;
    case Axis.DESCENDANTSORSELFFROMROOT :
      traverser = new DescendantOrSelfFromRootTraverser();
      break;
    case Axis.ROOT :
      traverser = new RootTraverser();
      break;
    case Axis.FILTEREDLIST :
      return null; 
    default :
      throw new DTMException(XSLMessages.createMessage(XSLTErrorResources.ER_UNKNOWN_AXIS_TYPE, new Object[]{Integer.toString(axis)})); 
    }

    if (null == traverser)
      throw new DTMException(XSLMessages.createMessage(XSLTErrorResources.ER_AXIS_TRAVERSER_NOT_SUPPORTED, new Object[]{Axis.names[axis]}));
      
      

    m_traversers[axis] = traverser;

    return traverser;
  }

  
  private class AncestorTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
			return getParent(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      current = makeNodeIdentity(current);

      while (DTM.NULL != (current = m_parent.elementAt(current)))
      {
        if (m_exptype.elementAt(current) == expandedTypeID)
          return makeNodeHandle(current);
      }

      return NULL;
    }
  }

  
  private class AncestorOrSelfTraverser extends AncestorTraverser
  {

    
    public int first(int context)
    {
      return context;
    }

    
    public int first(int context, int expandedTypeID)
    {
			return (getExpandedTypeID(context) == expandedTypeID)
             ? context : next(context, context, expandedTypeID);
    }
  }

  
  private class AttributeTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
      return (context == current)
             ? getFirstAttribute(context) : getNextAttribute(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      current = (context == current)
                ? getFirstAttribute(context) : getNextAttribute(current);

      do
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }
      while (DTM.NULL != (current = getNextAttribute(current)));

      return NULL;
    }
  }

  
  private class ChildTraverser extends DTMAxisTraverser
  {
    
    
    protected int getNextIndexed(int axisRoot, int nextPotential,
                                 int expandedTypeID)
    {

      int nsIndex = m_expandedNameTable.getNamespaceID(expandedTypeID);
      int lnIndex = m_expandedNameTable.getLocalNameID(expandedTypeID);

      for (; ; ) 
      {
        int nextID = findElementFromIndex(nsIndex, lnIndex, nextPotential);

        if (NOTPROCESSED != nextID)
        {
          int parentID = m_parent.elementAt(nextID);
          
          
          if(parentID == axisRoot)
            return nextID;
          
          
          
          if(parentID < axisRoot)
              return NULL;
          
          
          
          
          
          
          do
          {
            parentID = m_parent.elementAt(parentID);
            if(parentID < axisRoot)
              return NULL;
          }
            while(parentID > axisRoot);
          
          
          nextPotential = nextID+1;
          continue;
        }

        nextNode();
        
        if(!(m_nextsib.elementAt(axisRoot) == NOTPROCESSED))
          break;
      }

      return DTM.NULL;
    }
        
    
    public int first(int context)
    {
      return getFirstChild(context);
    }
  
    
    public int first(int context, int expandedTypeID)
    {
      if(true)
      {
        int identity = makeNodeIdentity(context);
        
        int firstMatch = getNextIndexed(identity, _firstch(identity),
                                 expandedTypeID);
       
        return makeNodeHandle(firstMatch);
      }
      else
      {
				
        for (int current = _firstch(makeNodeIdentity(context)); 
             DTM.NULL != current; 
             current = _nextsib(current)) 
        {
          if (m_exptype.elementAt(current) == expandedTypeID)
              return makeNodeHandle(current);
        }
        return NULL;
      }
    }

    
    public int next(int context, int current)
    {
      return getNextSibling(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      for (current = _nextsib(makeNodeIdentity(current)); 
           DTM.NULL != current; 
           current = _nextsib(current)) 
      {
        if (m_exptype.elementAt(current) == expandedTypeID)
            return makeNodeHandle(current);
      }
      
      return NULL;
    }
  }

  
  private abstract class IndexedDTMAxisTraverser extends DTMAxisTraverser
  {

    
    protected final boolean isIndexed(int expandedTypeID)
    {
      return (m_indexing
              && ExpandedNameTable.ELEMENT
                 == m_expandedNameTable.getType(expandedTypeID)); 
    }

    
    protected abstract boolean isAfterAxis(int axisRoot, int identity);

    
    protected abstract boolean axisHasBeenProcessed(int axisRoot);

    
    protected int getNextIndexed(int axisRoot, int nextPotential,
                                 int expandedTypeID)
    {

      int nsIndex = m_expandedNameTable.getNamespaceID(expandedTypeID);
      int lnIndex = m_expandedNameTable.getLocalNameID(expandedTypeID);

      while(true)
      {
        int next = findElementFromIndex(nsIndex, lnIndex, nextPotential);

        if (NOTPROCESSED != next)
        {
          if (isAfterAxis(axisRoot, next))
            return NULL;

          
          return next;
        }
        else if(axisHasBeenProcessed(axisRoot))
          break;

        nextNode();
      }

      return DTM.NULL;
    }
  }

  
  private class DescendantTraverser extends IndexedDTMAxisTraverser
  {
    
    protected int getFirstPotential(int identity)
    {
      return identity + 1;
    }
    
    
    protected boolean axisHasBeenProcessed(int axisRoot)
    {
      return !(m_nextsib.elementAt(axisRoot) == NOTPROCESSED);
    }
    
    
    protected int getSubtreeRoot(int handle)
    {
      return makeNodeIdentity(handle);
    }

    
    protected boolean isDescendant(int subtreeRootIdentity, int identity)
    {
      return _parent(identity) >= subtreeRootIdentity;
    }

    
    protected boolean isAfterAxis(int axisRoot, int identity)
    {   
      
			
			
      do
      {
        if(identity == axisRoot)
          return false;
        identity = m_parent.elementAt(identity);
      }
        while(identity >= axisRoot);
        
      return true;
    }

    
    public int first(int context, int expandedTypeID)
    {

      if (isIndexed(expandedTypeID))
      {
        int identity = getSubtreeRoot(context);
        int firstPotential = getFirstPotential(identity);

        return makeNodeHandle(getNextIndexed(identity, firstPotential, expandedTypeID));
      }

      return next(context, context, expandedTypeID);
    }

    
    public int next(int context, int current)
    {

      int subtreeRootIdent = getSubtreeRoot(context);

      for (current = makeNodeIdentity(current) + 1; ; current++)
      {
        int type = _type(current);  

        if (!isDescendant(subtreeRootIdent, current))
          return NULL;

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type)
          continue;

        return makeNodeHandle(current);  
      }
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      int subtreeRootIdent = getSubtreeRoot(context);

      current = makeNodeIdentity(current) + 1;

      if (isIndexed(expandedTypeID))
      {
        return makeNodeHandle(getNextIndexed(subtreeRootIdent, current, expandedTypeID));
      }

      for (; ; current++)
      {
        int exptype = _exptype(current);  

        if (!isDescendant(subtreeRootIdent, current))
          return NULL;

        if (exptype != expandedTypeID)
          continue;

        return makeNodeHandle(current);  
      }
    }
  }

  
  private class DescendantOrSelfTraverser extends DescendantTraverser
  {

    
    protected int getFirstPotential(int identity)
    {
      return identity;
    }

    
    public int first(int context)
    {
      return context;
    }
  }

  
  private class AllFromNodeTraverser extends DescendantOrSelfTraverser
  {

    
    public int next(int context, int current)
    {

      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) + 1; ; current++)
      {
        
        
        
        
        
        _exptype(current);  

        if (!isDescendant(subtreeRootIdent, current))
          return NULL;

        return makeNodeHandle(current);  
      }
    }
  }

  
  private class FollowingTraverser extends DescendantTraverser
  {

    
    public int first(int context)
    {
			
			context=makeNodeIdentity(context);

      int first;
      int type = _type(context);

      if ((DTM.ATTRIBUTE_NODE == type) || (DTM.NAMESPACE_NODE == type))
      {
        context = _parent(context);
        first = _firstch(context);

        if (NULL != first)
          return makeNodeHandle(first);
      }

      do
      {
        first = _nextsib(context);

        if (NULL == first)
          context = _parent(context);
      }
      while (NULL == first && NULL != context);

      return makeNodeHandle(first);
    }

    
    public int first(int context, int expandedTypeID)
    {
			
			
      int first;
      int type = getNodeType(context);

      if ((DTM.ATTRIBUTE_NODE == type) || (DTM.NAMESPACE_NODE == type))
      {
        context = getParent(context);
        first = getFirstChild(context);

        if (NULL != first)
        {
          if (getExpandedTypeID(first) == expandedTypeID)
            return first;
          else
            return next(context, first, expandedTypeID);
        }
      }

      do
      {
        first = getNextSibling(context);

        if (NULL == first)
          context = getParent(context);
        else
        {
          if (getExpandedTypeID(first) == expandedTypeID)
            return first;
          else
            return next(context, first, expandedTypeID);
        }
      }
      while (NULL == first && NULL != context);

      return first;
    }

    
    public int next(int context, int current)
    {
			
			current=makeNodeIdentity(current);

      while (true)
      {
        current++; 

				
        int type = _type(current);  

        if (NULL == type)
          return NULL;

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type)
          continue;

        return makeNodeHandle(current);  
      }
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
			current=makeNodeIdentity(current);

      while (true)
      {
        current++;

        int etype = _exptype(current);  

        if (NULL == etype)
          return NULL;

        if (etype != expandedTypeID)
          continue;

        return makeNodeHandle(current);  
      }
    }
  }

  
  private class FollowingSiblingTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
      return getNextSibling(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      while (DTM.NULL != (current = getNextSibling(current)))
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }

      return NULL;
    }
  }

  
  private class NamespaceDeclsTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {

      return (context == current)
             ? getFirstNamespaceNode(context, false)
             : getNextNamespaceNode(context, current, false);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      current = (context == current)
                ? getFirstNamespaceNode(context, false)
                : getNextNamespaceNode(context, current, false);

      do
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }
      while (DTM.NULL
             != (current = getNextNamespaceNode(context, current, false)));

      return NULL;
    }
  }

  
  private class NamespaceTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {

      return (context == current)
             ? getFirstNamespaceNode(context, true)
             : getNextNamespaceNode(context, current, true);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      current = (context == current)
                ? getFirstNamespaceNode(context, true)
                : getNextNamespaceNode(context, current, true);

      do
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }
      while (DTM.NULL
             != (current = getNextNamespaceNode(context, current, true)));

      return NULL;
    }
  }

  
  private class ParentTraverser extends DTMAxisTraverser
  {
    
    public int first(int context)
    {
      return getParent(context);
    }
  
    
    public int first(int current, int expandedTypeID)
    {
			
      current = makeNodeIdentity(current);

      while (NULL != (current = m_parent.elementAt(current)))
      {
        if (m_exptype.elementAt(current) == expandedTypeID)
          return makeNodeHandle(current);
      }

      return NULL;
    }


    
    public int next(int context, int current)
    {

      return NULL;
    }
    


    
    public int next(int context, int current, int expandedTypeID)
    {

      return NULL;
    }
  }

  
  private class PrecedingTraverser extends DTMAxisTraverser
  {

    
    protected boolean isAncestor(int contextIdent, int currentIdent)
    {
			
			
      for (contextIdent = m_parent.elementAt(contextIdent); DTM.NULL != contextIdent;
              contextIdent = m_parent.elementAt(contextIdent))
      {
        if (contextIdent == currentIdent)
          return true;
      }

      return false;
    }

    
    public int next(int context, int current)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) - 1; current >= 0; current--)
      {
        short type = _type(current);

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type
                || isAncestor(subtreeRootIdent, current))
          continue;

        return makeNodeHandle(current);  
      }

      return NULL;
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) - 1; current >= 0; current--)
      {
        int exptype = m_exptype.elementAt(current);

        if (exptype != expandedTypeID
                || isAncestor(subtreeRootIdent, current))
          continue;

        return makeNodeHandle(current);  
      }

      return NULL;
    }
  }

  
  private class PrecedingAndAncestorTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context );

      for (current = makeNodeIdentity(current) - 1; current >= 0; current--)
      {
        short type = _type(current);

        if (ATTRIBUTE_NODE == type || NAMESPACE_NODE == type)
          continue;

        return makeNodeHandle(current);  
      }

      return NULL;
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) - 1; current >= 0; current--)
      {
        int exptype = m_exptype.elementAt(current);

        if (exptype != expandedTypeID)
          continue;

        return makeNodeHandle(current);  
      }

      return NULL;
    }
  }

  
  private class PrecedingSiblingTraverser extends DTMAxisTraverser
  {

    
    public int next(int context, int current)
    {
      return getPreviousSibling(current);
    }

    
    public int next(int context, int current, int expandedTypeID)
    {

      while (DTM.NULL != (current = getPreviousSibling(current)))
      {
        if (getExpandedTypeID(current) == expandedTypeID)
          return current;
      }

      return NULL;
    }
  }

  
  private class SelfTraverser extends DTMAxisTraverser
  {

    
    public int first(int context)
    {
      return context;
    }

    
    public int first(int context, int expandedTypeID)
    {
      return (getExpandedTypeID(context) == expandedTypeID) ? context : NULL;
    }

    
    public int next(int context, int current)
    {
      return NULL;
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
      return NULL;
    }
  }

  
  private class AllFromRootTraverser extends AllFromNodeTraverser
  {

    
    public int first(int context)
    {
      return getDocumentRoot(context);
    }

    
    public int first(int context, int expandedTypeID)
    {
      return (getExpandedTypeID(getDocumentRoot(context)) == expandedTypeID)
             ? context : next(context, context, expandedTypeID);
    }

    
    public int next(int context, int current)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) + 1; ; current++)
      {
				
        int type = _type(current);  
        if (type == NULL)
          return NULL;

        return makeNodeHandle(current);  
      }
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
			
      int subtreeRootIdent = makeNodeIdentity(context);

      for (current = makeNodeIdentity(current) + 1; ; current++)
      {
        int exptype = _exptype(current);  

        if (exptype == NULL)
          return NULL;

        if (exptype != expandedTypeID)
          continue;

        return makeNodeHandle(current);  
      }
    }
  }

  
  private class RootTraverser extends AllFromRootTraverser
  {

    
    public int next(int context, int current)
    {
      return NULL;
    }

    
    public int next(int context, int current, int expandedTypeID)
    {
      return NULL;
    }
  }

  
  private class DescendantOrSelfFromRootTraverser extends DescendantTraverser
  {

    
    protected int getFirstPotential(int identity)
    {
      return identity;
    }

    
    protected int getSubtreeRoot(int handle)
    {
			
      return makeNodeIdentity(getDocument());
    }

    
    public int first(int context)
    {
      return getDocumentRoot(context);
    }
    
    
    public int first(int context, int expandedTypeID)
    {
      if (isIndexed(expandedTypeID))
      {
        int identity = 0;
        int firstPotential = getFirstPotential(identity);

        return makeNodeHandle(getNextIndexed(identity, firstPotential, expandedTypeID));
      }

      int root = first(context); 
      return next(root, root, expandedTypeID);
    }
  }
  
  
  private class DescendantFromRootTraverser extends DescendantTraverser
  {

    
    protected int getFirstPotential(int identity)
    {
      return _firstch(0);
    }

    
    protected int getSubtreeRoot(int handle)
    {
      return 0;
    }

    
    public int first(int context)
    {
      return makeNodeHandle(_firstch(0));
    }
    
    
    public int first(int context, int expandedTypeID)
    {
      if (isIndexed(expandedTypeID))
      {
        int identity = 0; 
        int firstPotential = getFirstPotential(identity);

        return makeNodeHandle(getNextIndexed(identity, firstPotential, expandedTypeID));
      }

      int root = getDocumentRoot(context); 
      return next(root, root, expandedTypeID);
    }
    
  }

}
"
org.apache.xalan.xsltc.compiler.Import,5,3,0,14,43,4,0,14,4,0.5,233,1.0,1,0.9375,0.36,2,5,45.4,10,2.6,0,"

package org.apache.xalan.xsltc.compiler;

import java.io.File;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.Enumeration;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.*;

import org.apache.bcel.generic.*;

final class Import extends TopLevelElement {

    private Stylesheet _imported = null;

    public Stylesheet getImportedStylesheet() {
	return _imported;
    }

    public void parseContents(final Parser parser) {
	final Stylesheet context = parser.getCurrentStylesheet();

	try {
	    String docToLoad = getAttribute(""href"");
	    if (context.checkForLoop(docToLoad)) {
		final int errno = ErrorMsg.CIRCULAR_INCLUDE_ERR;
		final ErrorMsg msg = new ErrorMsg(errno, docToLoad, this);
		parser.reportError(Constants.FATAL, msg);
		return;
	    }

	    String currLoadedDoc = context.getSystemId();
	    SourceLoader loader = context.getSourceLoader();
	    InputSource input = null;

	    if (loader != null) {
		final XSLTC xsltc = parser.getXSLTC();
		input = loader.loadSource(docToLoad, currLoadedDoc, xsltc);
	    }
	    else {
		File file = new File(currLoadedDoc);
		if (file.exists()) currLoadedDoc = ""file:""+currLoadedDoc;
		final URL url = new URL(new URL(currLoadedDoc), docToLoad);
		docToLoad = url.toString();
		input = new InputSource(docToLoad);
	    }

	    
	    if (input == null) {
		final ErrorMsg msg = 
		    new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, docToLoad, this);
		parser.reportError(Constants.FATAL, msg);
		return;
	    }

	    SyntaxTreeNode root = parser.parse(input);

	    if (root == null) return;
	    _imported = parser.makeStylesheet(root);
	    if (_imported == null) return;

	    _imported.setSourceLoader(loader);
	    _imported.setSystemId(docToLoad);
	    _imported.setParentStylesheet(context);
	    _imported.setImportingStylesheet(context);

	    
	    final int currPrecedence = parser.getCurrentImportPrecedence();
	    final int nextPrecedence = parser.getNextImportPrecedence();
	    _imported.setImportPrecedence(currPrecedence);
	    context.setImportPrecedence(nextPrecedence);
	    parser.setCurrentStylesheet(_imported);
	    _imported.parseContents(parser);

	    final Enumeration elements = _imported.elements();
	    final Stylesheet topStylesheet = parser.getTopLevelStylesheet();
	    while (elements.hasMoreElements()) {
		final Object element = elements.nextElement();
		if (element instanceof TopLevelElement) {
		    if (element instanceof Variable) {
			topStylesheet.addVariable((Variable) element);
		    }
		    else if (element instanceof Param) {
			topStylesheet.addParam((Param) element);
		    }
		    else {
			topStylesheet.addElement((TopLevelElement) element);
		    }
		}
	    }
	}
	catch (Exception e) {
	    e.printStackTrace();
	}
	finally {
	    parser.setCurrentStylesheet(context);
	}
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }
}
"
org.apache.xml.utils.NodeVector,30,1,1,7,33,0,7,0,30,0.422413793,933,1.0,0,0.0,0.4,0,0,29.96666667,5,2.1667,0,"
package org.apache.xml.utils;

import java.io.Serializable;

import org.apache.xml.dtm.DTM;


public class NodeVector implements Serializable, Cloneable
{

  
  private int m_blocksize;

  
  private int m_map[];

  
  protected int m_firstFree = 0;

  
  private int m_mapSize;  

  
  public NodeVector()
  {
    m_blocksize = 32;
    m_mapSize = 0;
  }

  
  public NodeVector(int blocksize)
  {
    m_blocksize = blocksize;
    m_mapSize = 0;
  }

  
  public Object clone() throws CloneNotSupportedException
  {

    NodeVector clone = (NodeVector) super.clone();

    if ((null != this.m_map) && (this.m_map == clone.m_map))
    {
      clone.m_map = new int[this.m_map.length];

      System.arraycopy(this.m_map, 0, clone.m_map, 0, this.m_map.length);
    }

    return clone;
  }

  
  public int size()
  {
    return m_firstFree;
  }

  
  public void addElement(int value)
  {

    if ((m_firstFree + 1) >= m_mapSize)
    {
      if (null == m_map)
      {
        m_map = new int[m_blocksize];
        m_mapSize = m_blocksize;
      }
      else
      {
        m_mapSize += m_blocksize;

        int newMap[] = new int[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

        m_map = newMap;
      }
    }

    m_map[m_firstFree] = value;

    m_firstFree++;
  }

  
  public final void push(int value)
  {

    int ff = m_firstFree;

    if ((ff + 1) >= m_mapSize)
    {
      if (null == m_map)
      {
        m_map = new int[m_blocksize];
        m_mapSize = m_blocksize;
      }
      else
      {
        m_mapSize += m_blocksize;

        int newMap[] = new int[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, ff + 1);

        m_map = newMap;
      }
    }

    m_map[ff] = value;

    ff++;

    m_firstFree = ff;
  }

  
  public final int pop()
  {

    m_firstFree--;

    int n = m_map[m_firstFree];

    m_map[m_firstFree] = DTM.NULL;

    return n;
  }

  
  public final int popAndTop()
  {

    m_firstFree--;

    m_map[m_firstFree] = DTM.NULL;

    return (m_firstFree == 0) ? DTM.NULL : m_map[m_firstFree - 1];
  }

  
  public final void popQuick()
  {

    m_firstFree--;

    m_map[m_firstFree] = DTM.NULL;
  }

  
  public final int peepOrNull()
  {
    return ((null != m_map) && (m_firstFree > 0))
           ? m_map[m_firstFree - 1] : DTM.NULL;
  }

  
  public final void pushPair(int v1, int v2)
  {

    if (null == m_map)
    {
      m_map = new int[m_blocksize];
      m_mapSize = m_blocksize;
    }
    else
    {
      if ((m_firstFree + 2) >= m_mapSize)
      {
        m_mapSize += m_blocksize;

        int newMap[] = new int[m_mapSize];

        System.arraycopy(m_map, 0, newMap, 0, m_firstFree);

        m_map = newMap;
      }
    }

    m_map[m_firstFree] = v1;
    m_map[m_firstFree + 1] = v2;
    m_firstFree += 2;
  }

  
  public final void popPair()
  {

    m_firstFree -= 2;
    m_map[m_firstFree] = DTM.NULL;
    m_map[m_firstFree + 1] = DTM.NULL;
  }

  
  public final void setTail(int n)
  {
    m_map[m_firstFree - 1] = n;
  }

  
  public final void setTailSub1(int n)
  {
    m_map[m_firstFree - 2] = n;
  }

  
  public final int peepTail()
  {
    return m_map[m_firstFree - 1];
  }

  
  public final int peepTailSub1()
  {
    return m_map[m_firstFree - 2];
  }

  
  public void insertInOrder(int value)
  {

    for (int i = 0; i < m_firstFree; i++)
    {
      if (value < m_map[i])
      {
        insertElementAt(value, i);

        return;
      }
    }

    addElement(value);
  }

  
  public void insertElementAt(int value, int at)
  {

    if (null == m_map)
    {
      m_map = new int[m_blocksize];
      m_mapSize = m_blocksize;
    }
    else if ((m_firstFree + 1) >= m_mapSize)
    {
      m_mapSize += m_blocksize;

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + 1);

      m_map = newMap;
    }

    if (at <= (m_firstFree - 1))
    {
      System.arraycopy(m_map, at, m_map, at + 1, m_firstFree - at);
    }

    m_map[at] = value;

    m_firstFree++;
  }

  
  public void appendNodes(NodeVector nodes)
  {

    int nNodes = nodes.size();

    if (null == m_map)
    {
      m_mapSize = nNodes + m_blocksize;
      m_map = new int[m_mapSize];
    }
    else if ((m_firstFree + nNodes) >= m_mapSize)
    {
      m_mapSize += (nNodes + m_blocksize);

      int newMap[] = new int[m_mapSize];

      System.arraycopy(m_map, 0, newMap, 0, m_firstFree + nNodes);

      m_map = newMap;
    }

    System.arraycopy(nodes.m_map, 0, m_map, m_firstFree, nNodes);

    m_firstFree += nNodes;
  }

  
  public void removeAllElements()
  {

    if (null == m_map)
      return;

    for (int i = 0; i < m_firstFree; i++)
    {
      m_map[i] = DTM.NULL;
    }

    m_firstFree = 0;
  }
  
  
  public void RemoveAllNoClear()
  {

    if (null == m_map)
      return;

    m_firstFree = 0;
  }

  
  public boolean removeElement(int s)
  {

    if (null == m_map)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      int node = m_map[i];

      if (node == s)
      {
        if (i > m_firstFree)
          System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
        else
          m_map[i] = DTM.NULL;

        m_firstFree--;

        return true;
      }
    }

    return false;
  }

  
  public void removeElementAt(int i)
  {

    if (null == m_map)
      return;

    if (i > m_firstFree)
      System.arraycopy(m_map, i + 1, m_map, i - 1, m_firstFree - i);
    else
      m_map[i] = DTM.NULL;
  }

  
  public void setElementAt(int node, int index)
  {

    if (null == m_map)
    {
      m_map = new int[m_blocksize];
      m_mapSize = m_blocksize;
    }
    
    if(index == -1)
    	addElement(node);

    m_map[index] = node;
  }

  
  public int elementAt(int i)
  {

    if (null == m_map)
      return DTM.NULL;

    return m_map[i];
  }

  
  public boolean contains(int s)
  {

    if (null == m_map)
      return false;

    for (int i = 0; i < m_firstFree; i++)
    {
      int node = m_map[i];

      if (node == s)
        return true;
    }

    return false;
  }

  
  public int indexOf(int elem, int index)
  {

    if (null == m_map)
      return -1;

    for (int i = index; i < m_firstFree; i++)
    {
      int node = m_map[i];

      if (node == elem)
        return i;
    }

    return -1;
  }

  
  public int indexOf(int elem)
  {

    if (null == m_map)
      return -1;

    for (int i = 0; i < m_firstFree; i++)
    {
      int node = m_map[i];

      if (node == elem)
        return i;
    }

    return -1;
  }

  
  public void sort(int a[], int lo0, int hi0) throws Exception
  {

    int lo = lo0;
    int hi = hi0;

    
    if (lo >= hi)
    {
      return;
    }
    else if (lo == hi - 1)
    {

      
      if (a[lo] > a[hi])
      {
        int T = a[lo];

        a[lo] = a[hi];
        a[hi] = T;
      }

      return;
    }

    
    int pivot = a[(lo + hi) / 2];

    a[(lo + hi) / 2] = a[hi];
    a[hi] = pivot;

    while (lo < hi)
    {

      
      while (a[lo] <= pivot && lo < hi)
      {
        lo++;
      }

      
      while (pivot <= a[hi] && lo < hi)
      {
        hi--;
      }

      
      if (lo < hi)
      {
        int T = a[lo];

        a[lo] = a[hi];
        a[hi] = T;

        
      }

      
      
      
    }

    
    a[hi0] = a[hi];
    a[hi] = pivot;

    
    sort(a, lo0, lo - 1);
    sort(a, hi + 1, hi0);
  }

  
  public void sort() throws Exception
  {
    sort(m_map, 0, m_firstFree - 1);
  }
}
"
org.apache.xml.dtm.DTMWSFilter,1,1,0,15,1,0,14,1,1,2.0,4,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"package org.apache.xml.dtm;


public interface DTMWSFilter
{
  
  public static final short NOTSTRIP = 1;

  
  public static final short STRIP = 2;

  
  public static final short INHERIT = 3;

  
  public short getShouldStripSpace(int elementHandle, DTM dtm);
  
}"
org.apache.xalan.templates.XSLTVisitable,1,1,0,4,1,0,3,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"package org.apache.xalan.templates;


public interface XSLTVisitable
{
	
	public void callVisitors(XSLTVisitor visitor);
}

"
org.apache.xalan.xsltc.trax.DOM2TO,22,1,0,2,49,221,1,1,20,0.964285714,327,1.0,1,0.0,0.143939394,0,0,13.68181818,2,1.0,1,"

package org.apache.xalan.xsltc.trax;

import org.w3c.dom.Node;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import java.io.IOException;
import org.w3c.dom.Entity;
import org.w3c.dom.Notation;

import org.xml.sax.*;

import org.apache.xalan.xsltc.TransletOutputHandler;

public class DOM2TO implements XMLReader, Locator {

    private final static String EMPTYSTRING = """";
    private static final String XMLNS_PREFIX = ""xmlns"";

    
    private Node _dom;

    
    private TransletOutputHandler _handler;

    public DOM2TO(Node root, TransletOutputHandler handler) {
	_dom = root;
	_handler = handler;
    }

    public ContentHandler getContentHandler() { 
	return null;
    }

    public void setContentHandler(ContentHandler handler) {
	
    }

    public void parse(InputSource unused) throws IOException, SAXException {
        parse(_dom);
    }

    public void parse() throws IOException, SAXException {
	if (_dom != null) {
	    boolean isIncomplete = 
		(_dom.getNodeType() != org.w3c.dom.Node.DOCUMENT_NODE);

	    if (isIncomplete) {
		_handler.startDocument();
		parse(_dom);
		_handler.endDocument();
	    }
	    else {
		parse(_dom);
	    }
	}
    }

    
    private void parse(Node node) 
	throws IOException, SAXException 
    {
 	if (node == null) return;

        switch (node.getNodeType()) {
	case Node.ATTRIBUTE_NODE:         
	case Node.DOCUMENT_FRAGMENT_NODE:
	case Node.DOCUMENT_TYPE_NODE :
	case Node.ENTITY_NODE :
	case Node.ENTITY_REFERENCE_NODE:
	case Node.NOTATION_NODE :
	    
	    break;
	case Node.CDATA_SECTION_NODE:
	    _handler.startCDATA();
	    _handler.characters(node.getNodeValue());
	    _handler.endCDATA();
	    break;

	case Node.COMMENT_NODE:           
	    _handler.comment(node.getNodeValue());
	    break;

	case Node.DOCUMENT_NODE:
	    _handler.startDocument();
	    Node next = node.getFirstChild();
	    while (next != null) {
		parse(next);
		next = next.getNextSibling();
	    }
	    _handler.endDocument();
	    break;

	case Node.ELEMENT_NODE:
	    
	    final String qname = node.getNodeName();
	    _handler.startElement(qname);
	    String prefix;
	    final NamedNodeMap map = node.getAttributes();
	    final int length = map.getLength();

	    
	    for (int i = 0; i < length; i++) {
		int colon;
		final Node attr = map.item(i);
		final String qnameAttr = attr.getNodeName();

		if (qnameAttr.startsWith(XMLNS_PREFIX)) {
		    final String uriAttr = attr.getNodeValue();
		    colon = qnameAttr.lastIndexOf(':');
		    prefix = (colon > 0) ? qnameAttr.substring(colon + 1) 
			: EMPTYSTRING;
		    _handler.namespace(prefix, uriAttr);
		}
		else {
		    final String uriAttr = attr.getNamespaceURI();
		    
		    if (uriAttr != null && !uriAttr.equals(EMPTYSTRING) ) {	
			colon = qnameAttr.lastIndexOf(':');
			prefix = (colon > 0) ? qnameAttr.substring(0, colon) 
			    : EMPTYSTRING;
			_handler.namespace(prefix, uriAttr);
		    }
		    _handler.attribute(qnameAttr, attr.getNodeValue());
		}
	    }

	    
	    final String uri = node.getNamespaceURI();

	    
	    if (uri != null) {	
		final int colon = qname.lastIndexOf(':');
		prefix = (colon > 0) ? qname.substring(0, colon) : EMPTYSTRING;
		_handler.namespace(prefix, uri);
	    }

	    
	    next = node.getFirstChild();
	    while (next != null) {
		parse(next);
		next = next.getNextSibling();
	    }

	    
	    _handler.endElement(qname);
	    break;

	case Node.PROCESSING_INSTRUCTION_NODE:
	    _handler.processingInstruction(node.getNodeName(),
					   node.getNodeValue());
	    break;

	case Node.TEXT_NODE:
	    _handler.characters(node.getNodeValue());
	    break;
	}
    }

    
    public DTDHandler getDTDHandler() { 
	return null;
    }

    
    public ErrorHandler getErrorHandler() {
	return null;
    }

    
    public boolean getFeature(String name) throws SAXNotRecognizedException,
	SAXNotSupportedException
    {
	return false;
    }

    
    public void setFeature(String name, boolean value) throws 
	SAXNotRecognizedException, SAXNotSupportedException 
    {
    }

    
    public void parse(String sysId) throws IOException, SAXException {
	throw new IOException(""This method is not yet implemented."");
    }

    
    public void setDTDHandler(DTDHandler handler) throws NullPointerException {
    }

    
    public void setEntityResolver(EntityResolver resolver) throws 
	NullPointerException 
    {
    }

    
    public EntityResolver getEntityResolver() {
	return null;
    }

    
    public void setErrorHandler(ErrorHandler handler) throws 
	NullPointerException
    {
    }

    
    public void setProperty(String name, Object value) throws
	SAXNotRecognizedException, SAXNotSupportedException {
    }

    
    public Object getProperty(String name) throws SAXNotRecognizedException,
	SAXNotSupportedException
    {
	return null;
    }

    
    public int getColumnNumber() { 
	return 0; 
    }
    
    
    public int getLineNumber() { 
	return 0; 
    }

    
    public String getPublicId() { 
	return null; 
    }

    
    public String getSystemId() { 
	return null; 
    }

    
    private String getNodeTypeFromCode(short code) {
	String retval = null;
	switch (code) {
	case Node.ATTRIBUTE_NODE : 
	    retval = ""ATTRIBUTE_NODE""; break; 
	case Node.CDATA_SECTION_NODE :
	    retval = ""CDATA_SECTION_NODE""; break; 
	case Node.COMMENT_NODE :
	    retval = ""COMMENT_NODE""; break; 
	case Node.DOCUMENT_FRAGMENT_NODE :
	    retval = ""DOCUMENT_FRAGMENT_NODE""; break; 
	case Node.DOCUMENT_NODE :
	    retval = ""DOCUMENT_NODE""; break; 
	case Node.DOCUMENT_TYPE_NODE :
	    retval = ""DOCUMENT_TYPE_NODE""; break; 
	case Node.ELEMENT_NODE :
	    retval = ""ELEMENT_NODE""; break; 
	case Node.ENTITY_NODE :
	    retval = ""ENTITY_NODE""; break; 
	case Node.ENTITY_REFERENCE_NODE :
	    retval = ""ENTITY_REFERENCE_NODE""; break; 
	case Node.NOTATION_NODE :
	    retval = ""NOTATION_NODE""; break; 
	case Node.PROCESSING_INSTRUCTION_NODE :
	    retval = ""PROCESSING_INSTRUCTION_NODE""; break; 
	case Node.TEXT_NODE:
	    retval = ""TEXT_NODE""; break; 
        }
	return retval;
    }
}
"
org.apache.xalan.trace.TraceListener,3,1,0,8,3,3,5,3,3,2.0,3,0.0,0,0.0,0.5,0,0,0.0,1,1.0,0,"
package org.apache.xalan.trace;

import org.w3c.dom.*;


public interface TraceListener extends java.util.EventListener
{

  
  public void trace(TracerEvent ev);

  
  public void selected(SelectionEvent ev) throws javax.xml.transform.TransformerException;

  
  public void generated(GenerateEvent ev);
}
"
org.apache.xml.utils.res.XResources_en,3,4,0,1,4,1,0,1,2,0.5,314,0.0,0,0.976190476,1.0,0,0,103.3333333,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_en extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""en"" }, { ""help_language"", ""en"" }, { ""language"", ""en"" },
    { ""alphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""additive"" },

    
    
    
    
    
    
    
    
    
    
    
    
  };
}
"
org.apache.xalan.xsltc.compiler.VariableRefBase,7,3,3,16,21,0,10,9,7,0.416666667,146,1.0,2,0.934210526,0.357142857,2,4,19.57142857,3,1.1429,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

class VariableRefBase extends Expression {

    
    protected final VariableBase _variable; 

    
    protected Closure _closure = null;

    public VariableRefBase(VariableBase variable) {
	_variable = variable;
	variable.addReference(this);
    }

    public VariableRefBase() {
	_variable = null;
    }

    
    public VariableBase getVariable() {
	return _variable;
    }

    
    public VariableBase findParentVariable() {
	SyntaxTreeNode node = this;
	while (node != null && !(node instanceof VariableBase)) {
	    node = node.getParent();
	}
	return (VariableBase) node;
    }

    
    public boolean equals(Object obj) {
	try {
	    return (_variable == ((VariableRefBase) obj)._variable);
	} 
	catch (ClassCastException e) {
	    return false;
	}
    }

    
    public String toString() {
	return ""variable-ref(""+_variable.getName()+'/'+_variable.getType()+')';
    }

    public Type typeCheck(SymbolTable stable) 
	throws TypeCheckError 
    {
	
	if (_type != null) return _type;

	
	if (_variable.isLocal()) {
	    SyntaxTreeNode node = getParent();
	    do {
		if (node instanceof Closure) {
		    _closure = (Closure) node;
		    break;
		}
		if (node instanceof TopLevelElement) {
		    break;	
		}
		node = node.getParent();
	    } while (node != null);

	    if (_closure != null) {
		_closure.addVariable(this);
	    }
	}

	
	VariableBase parent = findParentVariable();
	if (parent != null) parent.addDependency(_variable);

        
        _type = _variable.getType();

        
        
        if (_type == null) {
            _variable.typeCheck(stable);
            _type = _variable.getType();
        }

        
        return _type;
    }

}
"
org.apache.xalan.templates.ElemCallTemplate,13,4,1,16,49,40,1,15,13,0.638888889,352,0.666666667,3,0.946902655,0.188034188,4,11,25.84615385,2,1.1538,0,"
package org.apache.xalan.templates;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.TransformerException;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.utils.QName;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;


public class ElemCallTemplate extends ElemForEach
{

  
  public QName m_templateName = null;

  
  public void setName(QName name)
  {
    m_templateName = name;
  }

  
  public QName getName()
  {
    return m_templateName;
  }

  
  private ElemTemplate m_template = null;

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_CALLTEMPLATE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_CALLTEMPLATE_STRING;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    
    
    
    int length = getParamElemCount();
    for (int i = 0; i < length; i++) 
    {
      ElemWithParam ewp = getParamElem(i);
      ewp.compose(sroot);
    }
    
    if ((null != m_templateName) && (null == m_template))
    {
      m_template =
        this.getStylesheetRoot().getTemplateComposed(m_templateName);
        
      if(null == m_template)
        return; 
    
      length = getParamElemCount();
      for (int i = 0; i < length; i++) 
      {
        ElemWithParam ewp = getParamElem(i);
        ewp.m_index = -1;
        
        
        int etePos = 0;
        for (ElemTemplateElement ete = m_template.getFirstChildElem(); 
             null != ete; ete = ete.getNextSiblingElem()) 
        {
          if(ete.getXSLToken() == Constants.ELEMNAME_PARAMVARIABLE)
          {
            ElemParam ep = (ElemParam)ete;
            if(ep.getName().equals(ewp.getName()))
            {
              ewp.m_index = etePos;
            }
          }
          else
            break;
          etePos++;
        }
        
      }
    }
  }
  
  
  public void endCompose(StylesheetRoot sroot) throws TransformerException
  {
    int length = getParamElemCount();
    for (int i = 0; i < length; i++) 
    {
      ElemWithParam ewp = getParamElem(i);
      ewp.endCompose(sroot);
    }    
    
    super.endCompose(sroot);
  }

  
  public void execute(
          TransformerImpl transformer)
            throws TransformerException
  {

    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);

    if (null != m_template)
    {
      XPathContext xctxt = transformer.getXPathContext();
      VariableStack vars = xctxt.getVarStack();

      int thisframe = vars.getStackFrame();
      int nextFrame = vars.link(m_template.m_frameSize);
      
      
      
      if(m_template.m_inArgsSize > 0)
      {
        vars.clearLocalSlots(0, m_template.m_inArgsSize);
      
        if(null != m_paramElems)
        {
          int currentNode = xctxt.getCurrentNode();
          vars.setStackFrame(thisframe);
          int size = m_paramElems.length;
          
          for (int i = 0; i < size; i++) 
          {
            ElemWithParam ewp = m_paramElems[i];
            if(ewp.m_index >= 0)
            {
              XObject obj = ewp.getValue(transformer, currentNode);
              
              
              
              
              vars.setLocalVariable(ewp.m_index, obj, nextFrame);
            }
          }
          vars.setStackFrame(nextFrame);
        }
      }
      
      SourceLocator savedLocator = xctxt.getSAXLocator();

      try
      {
        xctxt.setSAXLocator(m_template);

        
        transformer.pushElemTemplateElement(m_template);
        m_template.execute(transformer);
      }
      finally
      {
        transformer.popElemTemplateElement();
        xctxt.setSAXLocator(savedLocator);
        
        
        
        
        
        
        
        
        
        vars.unlink(thisframe);
      }
    }
    else
    {
      transformer.getMsgMgr().error(this, XSLTErrorResources.ER_TEMPLATE_NOT_FOUND,
                                    new Object[]{ m_templateName });  
    }
    
    if (TransformerImpl.S_DEBUG)
	  transformer.getTraceManager().fireTraceEndEvent(this); 

  }
  
  
  protected ElemWithParam[] m_paramElems = null;

  
  public int getParamElemCount()
  {
    return (m_paramElems == null) ? 0 : m_paramElems.length;
  }

  
  public ElemWithParam getParamElem(int i)
  {
    return m_paramElems[i];
  }

  
  public void setParamElem(ElemWithParam ParamElem)
  {
    if (null == m_paramElems)
    {
      m_paramElems = new ElemWithParam[1];
      m_paramElems[0] = ParamElem;
    }
    else
    {
      
      
      int length = m_paramElems.length;
      ElemWithParam[] ewp = new ElemWithParam[length + 1];
      System.arraycopy(m_paramElems, 0, ewp, 0, length);
      m_paramElems = ewp;
      ewp[length] = ParamElem;
    }
  }

  
  public ElemTemplateElement appendChild(ElemTemplateElement newChild)
  {

    int type = ((ElemTemplateElement) newChild).getXSLToken();

    if (Constants.ELEMNAME_WITHPARAM == type)
    {
      setParamElem((ElemWithParam) newChild);
    }

    
    
    return super.appendChild(newChild);
  }
  
    
    public void callChildVisitors(XSLTVisitor visitor, boolean callAttrs)
    {











      super.callChildVisitors(visitor, callAttrs);
    }
}
"
org.apache.xpath.operations.Gt,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class Gt extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return left.greaterThan(right) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.xsltc.cmdline.Transform,8,1,0,12,67,8,0,12,4,0.74025974,683,1.0,1,0.0,0.30952381,0,0,83.0,18,4.5,0,"

package org.apache.xalan.xsltc.cmdline;

import java.io.*;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.UnknownHostException;
import java.util.Vector;

import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.xml.sax.XMLReader;
import org.xml.sax.SAXException;
import org.xml.sax.ContentHandler;
import org.xml.sax.ext.LexicalHandler;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.TransletOutputHandler;

import org.apache.xalan.xsltc.runtime.*;
import org.apache.xalan.xsltc.dom.DOMImpl;
import org.apache.xalan.xsltc.dom.DOMBuilder;
import org.apache.xalan.xsltc.dom.Axis;
import org.apache.xalan.xsltc.dom.DTDMonitor;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;

import org.apache.xalan.xsltc.runtime.output.*;

final public class Transform {

    
    static private boolean _useOldOutputSystem = false;

    private TransletOutputHandler _handler;

    private String  _fileName;
    private String  _className;
    private String  _jarFileSrc;
    private boolean _isJarFileSpecified = false;
    private Vector  _params = null;
    private boolean _uri, _debug;
    private int     _iterations;

    private static boolean _allowExit = true;

    public Transform(String className, String fileName,
		     boolean uri, boolean debug, int iterations) {
	_fileName = fileName;
	_className = className;
	_uri = uri;
	_debug = debug;
	_iterations = iterations;
    }

    public void setParameters(Vector params) {
	_params = params;
    }

    private void setJarFileInputSrc(boolean flag,  String jarFile) {
	
	
	
	
	
	_isJarFileSpecified = flag;
	
	_jarFileSrc = jarFile;	
    }

    private Class loadTranslet(String name) throws ClassNotFoundException {
	
	try {
	    return Class.forName(name);
	}
	catch (ClassNotFoundException e) {
	    
	}

	
	TransletLoader loader = new TransletLoader();
	return loader.loadTranslet(name);
    }

    private void doTransform() {
	try {
	    
	    final Class clazz = loadTranslet(_className);
	    final Translet translet = (Translet)clazz.newInstance();

	    
	    final SAXParserFactory factory = SAXParserFactory.newInstance();
	    try {
		factory.setFeature(Constants.NAMESPACE_FEATURE,true);
	    }
	    catch (Exception e) {
		factory.setNamespaceAware(true);
	    }
	    final SAXParser parser = factory.newSAXParser();
	    final XMLReader reader = parser.getXMLReader();

	    
	    final DOMImpl dom = new DOMImpl();
	    DOMBuilder builder = dom.getBuilder();
	    reader.setContentHandler(builder);

	    try {
		String prop = ""http:
		reader.setProperty(prop, builder);
	    }
	    catch (SAXException e) {
		
	    }
	    
	    
	    final DTDMonitor dtdMonitor = new DTDMonitor(reader);
	    AbstractTranslet _translet = (AbstractTranslet)translet;
	    dom.setDocumentURI(_fileName);
	    if (_uri)
		reader.parse(_fileName);
	    else
		reader.parse(new File(_fileName).toURL().toExternalForm());

	    builder = null;

	    
	    dtdMonitor.buildIdIndex(dom, 0, _translet);
	    
	    _translet.setDTDMonitor(dtdMonitor);

	    
	    int n = _params.size();
	    for (int i = 0; i < n; i++) {
		Parameter param = (Parameter) _params.elementAt(i);
		translet.addParameter(param._name, param._value);
	    }

	    
	    TransletOutputHandlerFactory tohFactory = 
		TransletOutputHandlerFactory.newInstance();
	    tohFactory.setOutputType(TransletOutputHandlerFactory.STREAM);
	    tohFactory.setEncoding(_translet._encoding);
	    tohFactory.setOutputMethod(_translet._method);

	    if (_iterations == -1) {
		translet.transform(dom, _useOldOutputSystem ?
					tohFactory.getOldTransletOutputHandler() :
					tohFactory.getTransletOutputHandler());
	    }
	    else if (_iterations > 0) {
		long mm = System.currentTimeMillis();
		for (int i = 0; i < _iterations; i++) {
		    translet.transform(dom, _useOldOutputSystem ?
					    tohFactory.getOldTransletOutputHandler() :
					    tohFactory.getTransletOutputHandler());
		}
		mm = System.currentTimeMillis() - mm;

		System.err.println(""
<!--"");
		System.err.println(""  transform  = "" + (mm / _iterations) + "" ms"");
		System.err.println(""  throughput = "" + (1000.0 / (mm / _iterations)) + "" tps"");
		System.err.println(""-->"");
	    }
	}
	catch (TransletException e) {
	    if (_debug) e.printStackTrace();
	    System.err.println(ErrorMsg.getTransletErrorMessage()+
			       e.getMessage());
	    if (_allowExit) System.exit(-1);	    
	}
	catch (RuntimeException e) {
	    if (_debug) e.printStackTrace();
	    System.err.println(ErrorMsg.getTransletErrorMessage()+
			       e.getMessage());
	    if (_allowExit) System.exit(-1);
	}
	catch (FileNotFoundException e) {
	    if (_debug) e.printStackTrace();
	    ErrorMsg err = new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, _fileName);
	    System.err.println(ErrorMsg.getTransletErrorMessage()+
			       err.toString());
	    if (_allowExit) System.exit(-1);
	}
	catch (MalformedURLException e) {
	    if (_debug) e.printStackTrace();
	    ErrorMsg err = new ErrorMsg(ErrorMsg.INVALID_URI_ERR, _fileName);
	    System.err.println(ErrorMsg.getTransletErrorMessage()+
			       err.toString());
	    if (_allowExit) System.exit(-1);
	}
	catch (ClassNotFoundException e) {
	    if (_debug) e.printStackTrace();
	    ErrorMsg err= new ErrorMsg(ErrorMsg.CLASS_NOT_FOUND_ERR,_className);
	    System.err.println(ErrorMsg.getTransletErrorMessage()+
			       err.toString());
	    if (_allowExit) System.exit(-1);
	}
        catch (UnknownHostException e) {
	    if (_debug) e.printStackTrace();
	    ErrorMsg err = new ErrorMsg(ErrorMsg.INVALID_URI_ERR, _fileName);
	    System.err.println(ErrorMsg.getTransletErrorMessage()+
			       err.toString());
	    if (_allowExit) System.exit(-1);
        }
	catch (SAXException e) {
	    Exception ex = e.getException();
	    if (_debug) {
		if (ex != null) ex.printStackTrace();
		e.printStackTrace();
	    }
	    System.err.print(ErrorMsg.getTransletErrorMessage());
	    if (ex != null)
		System.err.println(ex.getMessage());
	    else
		System.err.println(e.getMessage());
	    if (_allowExit) System.exit(-1);
	}
	catch (Exception e) {
	    if (_debug) e.printStackTrace();
	    System.err.println(ErrorMsg.getTransletErrorMessage()+
			       e.getMessage());
	    if (_allowExit) System.exit(-1);
	}
    }

    public static void printUsage() {
	System.err.println(new ErrorMsg(ErrorMsg.TRANSFORM_USAGE_STR));
	if (_allowExit) System.exit(-1);
    }

    public static void main(String[] args) {
	try {
	    if (args.length > 0) {
		int i;
		int iterations = -1;
		boolean uri = false, debug = false;
		boolean isJarFileSpecified = false;
		String  jarFile = null;

		
		for (i = 0; i < args.length && args[i].charAt(0) == '-'; i++) {
		    if (args[i].equals(""-u"")) {
			uri = true;
		    }
		    else if (args[i].equals(""-x"")) {
			debug = true;
		    }
		    else if (args[i].equals(""-s"")) {
			_allowExit = false;
		    }
		    else if (args[i].equals(""-j"")) {
			isJarFileSpecified = true;	
			jarFile = args[++i];
		    }
		    else if (args[i].equals(""-e"")) {
			_useOldOutputSystem = true;
		    }
		    else if (args[i].equals(""-n"")) {
			try {
			    iterations = Integer.parseInt(args[++i]);
			}
			catch (NumberFormatException e) {
			    
			}
		    }
		    else {
			printUsage();
		    }
		}

		
		if (args.length - i < 2) printUsage();

		
		Transform handler = new Transform(args[i+1], args[i], uri,
		    debug, iterations);
		handler.setJarFileInputSrc(isJarFileSpecified,	jarFile);

		
		Vector params = new Vector();
		for (i += 2; i < args.length; i++) {
		    final int equal = args[i].indexOf('=');
		    if (equal > 0) {
			final String name  = args[i].substring(0, equal);
			final String value = args[i].substring(equal+1);
			params.addElement(new Parameter(name, value));
		    }
		    else {
			printUsage();
		    }
		}

		if (i == args.length) {
		    handler.setParameters(params);
		    handler.doTransform();
		    if (_allowExit) System.exit(0);
		}
	    } else {
		printUsage();
	    }
	}
	catch (Exception e) {
	    e.printStackTrace();
	}
    }
}
"
org.apache.xalan.templates.VarNameCollector,5,2,0,5,12,0,1,4,4,0.0,34,0.0,0,0.75,0.4,0,0,5.6,1,0.8,0,"package org.apache.xalan.templates;

import java.util.Vector;

import org.apache.xml.utils.QName;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.operations.Variable;


public class VarNameCollector extends XPathVisitor
{
	Vector m_refs = new Vector();
	
	
	public void reset()
	{
		m_refs.removeAllElements(); 
	}
	
	
	public int getVarCount()
	{
		return m_refs.size();
	}
	
	
	boolean doesOccur(QName refName)
	{
		return m_refs.contains(refName);
	}

	
	public boolean visitVariableRef(ExpressionOwner owner, Variable var)
	{
		m_refs.addElement(var.getQName());
		return true;
	}

}

"
org.apache.xalan.xsltc.runtime.output.OutputBase,32,1,2,12,54,470,7,5,23,0.95601173,371,1.0,2,0.0,0.286458333,0,0,10.25,5,1.3125,1,"

package org.apache.xalan.xsltc.runtime.output;

import java.util.Stack;

import org.apache.xalan.xsltc.*;
import org.apache.xalan.xsltc.runtime.*;
import org.apache.xalan.xsltc.runtime.Hashtable;

import org.apache.xalan.xsltc.TransletException;
import org.apache.xalan.xsltc.TransletOutputHandler;
import org.apache.xalan.xsltc.runtime.Hashtable;

public abstract class OutputBase implements TransletOutputHandler, Constants {

    
    protected String  _doctypeSystem = null;

    
    protected String  _doctypePublic = null;

    
    protected int _depth = 0;

    
    protected Hashtable _namespaces;

    
    protected Stack _nodeStack;

    
    protected Stack _prefixStack;

    
    protected Hashtable _cdata = null;

    
    protected Stack _cdataStack;

    
    protected boolean _cdataTagOpen = false;

    
    protected boolean _startTagOpen  = false;
 
    
    protected boolean _firstElement = true;

    
    protected void initCDATA() {
	
	_cdataStack = new Stack();
	_cdataStack.push(new Integer(-1)); 	
    }

    protected void initNamespaces() {
	
	_namespaces = new Hashtable();
	_nodeStack = new Stack();
	_prefixStack = new Stack();

	
	Stack stack;
	_namespaces.put(EMPTYSTRING, stack = new Stack());
	stack.push(EMPTYSTRING);
	_prefixStack.push(EMPTYSTRING);

	_namespaces.put(XML_PREFIX, stack = new Stack());
	stack.push(""http:
	_prefixStack.push(XML_PREFIX);

	_nodeStack.push(new Integer(-1));
	_depth = 0;
    }

    
    public void setDoctype(String system, String pub) {
        _doctypeSystem = system;
        _doctypePublic = pub;

    }

    public void setCdataElements(Hashtable elements) { 
	_cdata = elements;
    }

 
    
    protected static String patchName(String qname) throws TransletException {
        final int lastColon = qname.lastIndexOf(':');
        if (lastColon > 0) {
            final int firstColon = qname.indexOf(':');
            if (firstColon != lastColon) {
                return qname.substring(0, firstColon) + 
		    qname.substring(lastColon);
            }
        }
        return qname;
    }

    
    protected boolean pushNamespace(String prefix, String uri) {
	
	if (prefix.startsWith(XML_PREFIX)) {
	    return false;
	}
	
	Stack stack;
	
	if ((stack = (Stack)_namespaces.get(prefix)) == null) {
	    _namespaces.put(prefix, stack = new Stack());
	}

	if (!stack.empty() && uri.equals(stack.peek())) {
	    return false;
	}

	stack.push(uri);
	_prefixStack.push(prefix);
	_nodeStack.push(new Integer(_depth));
	return true;
    }

    
    protected boolean popNamespace(String prefix) {
	
	if (prefix.startsWith(XML_PREFIX)) {
	    return false;
	}

	Stack stack;
	if ((stack = (Stack)_namespaces.get(prefix)) != null) {
	    stack.pop();
	    return true;
	}
	return false;
    }

    
    protected void popNamespaces() {
	while (true) {
	    if (_nodeStack.isEmpty()) return;
	    Integer i = (Integer)(_nodeStack.peek());
	    if (i.intValue() != _depth) return;
	    _nodeStack.pop();
	    popNamespace((String)_prefixStack.pop());
	}
    }

    
    protected String lookupNamespace(String prefix) {
        final Stack stack = (Stack)_namespaces.get(prefix);
        return stack != null && !stack.isEmpty() ? (String)stack.peek() : null;
    }

    
    protected static String getLocalName(String qname) {
        final int col = qname.lastIndexOf(':');
        return (col > 0) ? qname.substring(col + 1) : qname;
    }

    
    protected String getNamespaceURI(String qname, boolean isElement)
        throws TransletException
    {
        String uri = EMPTYSTRING;
        int col = qname.lastIndexOf(':');
        final String prefix = (col > 0) ? qname.substring(0, col) : EMPTYSTRING;

        if (prefix != EMPTYSTRING || isElement) {
            uri = lookupNamespace(prefix);
            if (uri == null && !prefix.equals(XMLNS_PREFIX)) {
                BasisLibrary.runTimeError(BasisLibrary.NAMESPACE_PREFIX_ERR,
                                          qname.substring(0, col));
            }
        }
        return uri;
    }

    public void startCDATA() throws TransletException { }
    public void endCDATA() throws TransletException { }
    public void namespace(String prefix, String uri) throws TransletException { }
    public void setType(int type) { }
    public void setIndent(boolean indent) { }
    public void omitHeader(boolean value) { }
    public boolean setEscaping(boolean escape) throws TransletException { return true; }
    public void setMediaType(String mediaType) { }
    public void setStandalone(String standalone) { }
    public void setVersion(String version) { }
    public void close() { }

}
"
org.apache.xalan.xsltc.compiler.StartsWithCall,3,4,0,18,17,0,0,18,3,0.0,108,1.0,2,0.979591837,0.444444444,3,14,34.33333333,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class StartsWithCall extends FunctionCall {

    private Expression _base = null;
    private Expression _token = null;

    
    public StartsWithCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	
	if (argumentCount() != 2) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ILLEGAL_ARG_ERR,
					getName(), this);
	    throw new TypeCheckError(err);
	}

	
	_base = argument(0);
	Type baseType = _base.typeCheck(stable);	
	if (baseType != Type.String)
	    _base = new CastExpr(_base, Type.String);

	
	_token = argument(1);
	Type tokenType = _token.typeCheck(stable);	
	if (tokenType != Type.String)
	    _token = new CastExpr(_token, Type.String);

	return _type = Type.Boolean;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	_base.translate(classGen, methodGen);
	_token.translate(classGen, methodGen);
	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_CLASS,
						     ""startsWith"", 
						     ""(""+STRING_SIG+"")Z"")));
    }
}
"
org.apache.xalan.xsltc.compiler.AttributeSet,8,3,0,26,54,6,3,25,7,0.80952381,279,1.0,3,0.895522388,0.3,2,5,33.125,7,2.25,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;
import java.util.StringTokenizer;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class AttributeSet extends TopLevelElement {

    
    private static final String AttributeSetPrefix = ""$as$"";
    
    
    private QName            _name;
    private UseAttributeSets _useSets;
    private AttributeSet     _mergeSet;
    private String           _method;
    private boolean          _ignore = false;
    
    
    public QName getName() {
	return _name;
    }

    
    public String getMethodName() {
	return _method;
    }

    
    public void ignore() {
	_ignore = true;
    }

    
    public void parseContents(Parser parser) {
	
	
	_name = parser.getQNameIgnoreDefaultNs(getAttribute(""name""));
	if ((_name == null) || (_name.equals(EMPTYSTRING))) {
	    ErrorMsg msg = new ErrorMsg(ErrorMsg.UNNAMED_ATTRIBSET_ERR, this);
	    parser.reportError(Constants.ERROR, msg);
	}

	
	final String useSets = getAttribute(""use-attribute-sets"");
	if (useSets.length() > 0) {
	    _useSets = new UseAttributeSets(useSets, parser);
	}

	
	
	final Vector contents = getContents();
	final int count = contents.size();
	for (int i=0; i<count; i++) {
	    SyntaxTreeNode child = (SyntaxTreeNode)contents.elementAt(i);
	    if (child instanceof XslAttribute) {
		parser.getSymbolTable().setCurrentNode(child);
		child.parseContents(parser);
	    }
	    else if (child instanceof Text) {
		
	    }
	    else {
		ErrorMsg msg = new ErrorMsg(ErrorMsg.ILLEGAL_CHILD_ERR, this);
		parser.reportError(Constants.ERROR, msg);
	    }
	}

	
	parser.getSymbolTable().setCurrentNode(this);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	if (_ignore) return (Type.Void);

        
	_mergeSet = stable.addAttributeSet(this);

	_method = AttributeSetPrefix + getXSLTC().nextAttributeSetSerial();

	if (_useSets != null) _useSets.typeCheck(stable);
	typeCheckContents(stable);
	return Type.Void;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	if (_ignore) return;

	
	methodGen = new AttributeSetMethodGenerator(_method, classGen);

        
        
        if (_mergeSet != null) {
            final ConstantPoolGen cpg = classGen.getConstantPool();
            final InstructionList il = methodGen.getInstructionList();
            final String methodName = _mergeSet.getMethodName();

            il.append(classGen.loadTranslet());
            il.append(methodGen.loadHandler());
            il.append(methodGen.loadIterator());
            final int method = cpg.addMethodref(classGen.getClassName(),
                                                methodName, ATTR_SET_SIG);
            il.append(new INVOKESPECIAL(method));
        }

	
	
	if (_useSets != null) _useSets.translate(classGen, methodGen);

	
	final Enumeration attributes = elements();
	while (attributes.hasMoreElements()) {
	    SyntaxTreeNode element = (SyntaxTreeNode)attributes.nextElement();
	    if (element instanceof XslAttribute) {
		final XslAttribute attribute = (XslAttribute)element;
		attribute.translate(classGen, methodGen);
	    }
	}
	final InstructionList il = methodGen.getInstructionList();
	il.append(RETURN);
	
	methodGen.stripAttributes(true);
	methodGen.setMaxLocals();
	methodGen.setMaxStack();
	methodGen.removeNOPs();
	classGen.addMethod(methodGen.getMethod());
    }

    public String toString() {
	StringBuffer buf = new StringBuffer(""attribute-set: "");
	
	final Enumeration attributes = elements();
	while (attributes.hasMoreElements()) {
	    final XslAttribute attribute =
		(XslAttribute)attributes.nextElement();
	    buf.append(attribute);
	}
	return(buf.toString());
    }
}
"
org.apache.xalan.extensions.ExpressionVisitor,2,2,0,7,6,0,1,6,2,0.0,23,1.0,1,0.923076923,0.625,0,0,10.0,2,1.0,0,"
package org.apache.xalan.extensions;

import org.apache.xpath.XPathVisitor;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.functions.Function;
import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xalan.templates.StylesheetRoot;


public class ExpressionVisitor extends XPathVisitor
{
  private StylesheetRoot m_sroot;
  
  
  public ExpressionVisitor (StylesheetRoot sroot)
  {
    m_sroot = sroot;
  }
  
  
  public boolean visitFunction(ExpressionOwner owner, Function func)
	{
    if (func instanceof FuncExtFunction)
    {
      String namespace = ((FuncExtFunction)func).getNamespace();
      m_sroot.getExtensionNamespacesManager().registerExtension(namespace);      
    }
		return true;
	}
}"
org.apache.xalan.xsltc.compiler.CompilerException,4,3,0,2,9,0,2,0,4,0.333333333,40,1.0,0,0.944444444,0.5,1,1,8.75,2,0.5,0,"

package org.apache.xalan.xsltc.compiler;

public final class CompilerException extends Exception {

    private String _msg;

    public CompilerException() {
	super();
    }
    
    public CompilerException(Exception e) {
	super(e.toString());
	_msg = e.toString(); 
    }
    
    public CompilerException(String message) {
	super(message);
	_msg = message;
    }

    public String getMessage() {
	final int col = _msg.indexOf(':');

	if (col > -1)
	    return(_msg.substring(col));
	else
	    return(_msg);
    }
}
"
org.apache.xalan.xsltc.compiler.Choose,3,3,0,26,36,3,1,25,2,2.0,245,0.0,0,0.965517241,0.5,2,4,80.66666667,15,5.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.Enumeration;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class Choose extends Instruction {

    
    public void display(int indent) {
	indent(indent);
	Util.println(""Choose"");
	indent(indent + IndentIncrement);
	displayContents(indent + IndentIncrement);
    }
	
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final Vector whenElements = new Vector();
	Otherwise otherwise = null;
	Enumeration elements = elements();

	
	ErrorMsg error = null;
	final int line = getLineNumber();

	
	while (elements.hasMoreElements()) {
	    Object element = elements.nextElement();
	    
	    if (element instanceof When) {
		whenElements.addElement(element);
	    }
	    
	    else if (element instanceof Otherwise) {
		if (otherwise == null) {
		    otherwise = (Otherwise)element;
		}
		else {
		    error = new ErrorMsg(ErrorMsg.MULTIPLE_OTHERWISE_ERR, this);
		    getParser().reportError(Constants.ERROR, error);
		}
	    }
	    else if (element instanceof Text) {
		((Text)element).ignore();
	    }
	    
	    else {
		error = new ErrorMsg(ErrorMsg.WHEN_ELEMENT_ERR, this);
		getParser().reportError(Constants.ERROR, error);
	    }
	}

	
	if (whenElements.size() == 0) {
	    error = new ErrorMsg(ErrorMsg.MISSING_WHEN_ERR, this);
	    getParser().reportError(Constants.ERROR, error);
	    return;
	}

	InstructionList il = methodGen.getInstructionList();

	
	
	BranchHandle nextElement = null;
	Vector exitHandles = new Vector();
	InstructionHandle exit = null;

	Enumeration whens = whenElements.elements();
	while (whens.hasMoreElements()) {
	    final When when = (When)whens.nextElement();
	    final Expression test = when.getTest();

	    InstructionHandle truec = il.getEnd();

	    if (nextElement != null) 
		nextElement.setTarget(il.append(NOP));
	    test.translateDesynthesized(classGen, methodGen);

	    if (test instanceof FunctionCall) {
		FunctionCall call = (FunctionCall)test;
		try {
		    Type type = call.typeCheck(getParser().getSymbolTable());
		    if (type != Type.Boolean) {
			test._falseList.add(il.append(new IFEQ(null)));
		    }
		}
		catch (TypeCheckError e) { 
		    
		}
	    }
	    
	    truec = il.getEnd();

	    
	    
	    if (!when.ignore()) when.translateContents(classGen, methodGen);

	    
	    exitHandles.addElement(il.append(new GOTO(null)));
	    if (whens.hasMoreElements() || otherwise != null) {
		nextElement = il.append(new GOTO(null));
		test.backPatchFalseList(nextElement);
	    }
	    else
		test.backPatchFalseList(exit = il.append(NOP));
	    test.backPatchTrueList(truec.getNext());
	}
	
	
	if (otherwise != null) {
	    nextElement.setTarget(il.append(NOP));
	    otherwise.translateContents(classGen, methodGen);
	    exit = il.append(NOP);
	}

	
	Enumeration exitGotos = exitHandles.elements();
	while (exitGotos.hasMoreElements()) {
	    BranchHandle gotoExit = (BranchHandle)exitGotos.nextElement();
	    gotoExit.setTarget(exit);
	}
    }
}
"
org.apache.xalan.transformer.TransformState,7,1,0,4,7,21,2,2,7,2.0,7,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xalan.transformer;

import org.apache.xalan.templates.ElemTemplate;
import org.apache.xalan.templates.ElemTemplateElement;

import org.w3c.dom.Node;
import org.w3c.dom.traversal.NodeIterator;

import javax.xml.transform.Transformer;


public interface TransformState
{

  
  ElemTemplateElement getCurrentElement();

  
  Node getCurrentNode();

  
  ElemTemplate getCurrentTemplate();

  
  ElemTemplate getMatchedTemplate();

  
  Node getMatchedNode();

  
  NodeIterator getContextNodeList();

  
  Transformer getTransformer();
}
"
org.apache.xalan.xsltc.compiler.ProcessingInstructionPattern,6,7,0,26,39,5,0,26,6,0.6,289,1.0,0,0.959349593,0.333333333,4,8,46.83333333,4,1.5,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.dom.Axis;

final class ProcessingInstructionPattern extends StepPattern {

    private String _name = null;
    private boolean _typeChecked = false;

    
    public ProcessingInstructionPattern(String name) {
	super(Axis.CHILD, DOM.PROCESSING_INSTRUCTION, null);
	_name = name;
	
    }

    
    public String toString() {
	if (_predicates == null)
	    return ""processing-instruction(""+_name+"")"";
	else
	    return ""processing-instruction(""+_name+"")""+_predicates;
    }

    public void reduceKernelPattern() {
	_typeChecked = true;
    }

    public boolean isWildcard() {
	return false;
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (hasPredicates()) {
	    
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		final Predicate pred = (Predicate)_predicates.elementAt(i);
		pred.typeCheck(stable);
	    }
	}
	return Type.NodeSet;
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	int gname = cpg.addInterfaceMethodref(DOM_INTF,
					      ""getNodeName"",
					      ""(I)Ljava/lang/String;"");
	int cmp = cpg.addMethodref(STRING_CLASS,
				   ""equals"", ""(Ljava/lang/Object;)Z"");

	
	il.append(methodGen.loadCurrentNode());
	il.append(SWAP);

	
	il.append(methodGen.storeCurrentNode());

	
	if (!_typeChecked) {
	    il.append(methodGen.loadCurrentNode());
	    final int getType = cpg.addInterfaceMethodref(DOM_INTF,
							  ""getType"", ""(I)I"");
	    il.append(methodGen.loadDOM());
	    il.append(methodGen.loadCurrentNode());
	    il.append(new INVOKEINTERFACE(getType, 2));
	    il.append(new PUSH(cpg, DOM.PROCESSING_INSTRUCTION));
	    _falseList.add(il.append(new IF_ICMPEQ(null)));
	}

	
	il.append(new PUSH(cpg, _name));
	
	il.append(methodGen.loadDOM());
	il.append(methodGen.loadCurrentNode());
	il.append(new INVOKEINTERFACE(gname, 2));
	
	il.append(new INVOKEVIRTUAL(cmp));
	_falseList.add(il.append(new IFEQ(null)));
		
	
	if (hasPredicates()) {
	    final int n = _predicates.size();
	    for (int i = 0; i < n; i++) {
		Predicate pred = (Predicate)_predicates.elementAt(i);
		Expression exp = pred.getExpr();
		exp.translateDesynthesized(classGen, methodGen);
		_trueList.append(exp._trueList);
		_falseList.append(exp._falseList);
	    }
	}

	
	InstructionHandle restore;
	restore = il.append(methodGen.storeCurrentNode());
	backPatchTrueList(restore);
	BranchHandle skipFalse = il.append(new GOTO(null));

	
	restore = il.append(methodGen.storeCurrentNode());
	backPatchFalseList(restore);
	_falseList.add(il.append(new GOTO(null)));

	
	skipFalse.setTarget(il.append(NOP));
    }
}
"
org.apache.xml.utils.synthetic.reflection.EntryPoint,22,1,2,6,49,71,4,5,20,0.706349206,827,0.833333333,4,0.0,0.272727273,1,1,36.04545455,16,2.7727,0,"
package org.apache.xml.utils.synthetic.reflection;

import java.lang.reflect.InvocationTargetException;

import org.apache.xml.utils.synthetic.SynthesisException;




abstract public class EntryPoint implements Member
{

  
  protected Object realep;

  
  private org.apache.xml.utils.synthetic.Class declaringclass = null;

  
  protected org.apache.xml.utils.synthetic.Class returntype = null;

  
  private String[] parameternames = new String[0];

  
  private org.apache.xml.utils.synthetic.Class[] parametertypes =
    new org.apache.xml.utils.synthetic.Class[0];

  
  private org.apache.xml.utils.synthetic.Class[] exceptiontypes =
    new org.apache.xml.utils.synthetic.Class[0];
  ;

  
  private int modifiers;

  
  protected String name = null;  

  

  
  private StringBuffer body = null;

  
  private String language = null;

  

  
  Class[] realE, realP;

  
  public EntryPoint(org.apache.xml.utils.synthetic.Class declaringclass)
  {
    this.declaringclass = declaringclass;
  }

  
  protected EntryPoint(
          Object ep, org.apache.xml.utils.synthetic.Class declaringclass)
            throws IllegalArgumentException
  {

    realep = ep;
    this.declaringclass = declaringclass;

    if (ep instanceof java.lang.reflect.Method)
    {
      java.lang.reflect.Method m = (java.lang.reflect.Method) ep;

      if (declaringclass == null)
      {
        declaringclass = org.apache.xml.utils.synthetic.Class.forClass(
          m.getDeclaringClass());
      }

      name = m.getName();
      modifiers = m.getModifiers();
      returntype =
        org.apache.xml.utils.synthetic.Class.forClass(m.getReturnType());
      realP = m.getParameterTypes();
      realE = m.getExceptionTypes();
    }
    else if (ep instanceof java.lang.reflect.Constructor)
    {
      java.lang.reflect.Constructor c = (java.lang.reflect.Constructor) ep;

      if (declaringclass == null)
      {
        declaringclass = org.apache.xml.utils.synthetic.Class.forClass(
          c.getDeclaringClass());
      }

      name = declaringclass.getShortName();
      modifiers = c.getModifiers();
      returntype = declaringclass;
      realP = c.getParameterTypes();
      realE = c.getExceptionTypes();
    }
    else
      throw new IllegalArgumentException();
  }

  
  protected EntryPoint(Object ep) throws IllegalArgumentException
  {
    this(ep, null);
  }

  
  public boolean equals(Object obj)
  {

    EntryPoint otherep = null;

    if (obj instanceof EntryPoint)
      otherep = (EntryPoint) obj;
    else if (obj instanceof java.lang.reflect.Constructor
             || obj instanceof java.lang.reflect.Method)
      otherep = (EntryPoint) obj;

    return (otherep != null && ((this instanceof Constructor && otherep instanceof Constructor) || (this instanceof Method && otherep instanceof Method && this.getName().equals(
      otherep.getName()))) && otherep.getDeclaringClass().equals(
        declaringclass) && otherep.getParameterTypes().equals(
        parametertypes));
  }

  
  public org.apache.xml.utils.synthetic.Class getDeclaringClass()
  {
    return declaringclass;
  }

  
  public org.apache.xml.utils.synthetic.Class getReturnType()
  {
    return returntype;
  }

  
  public org.apache.xml.utils.synthetic.Class[] getExceptionTypes()
  {

    if (realep != null && exceptiontypes == null)
    {
      exceptiontypes =
        new org.apache.xml.utils.synthetic.Class[realE.length];

      for (int i = 0; i < realE.length; ++i)
      {
        exceptiontypes[i] =
          org.apache.xml.utils.synthetic.Class.forClass(realE[i]);
      }

      realE = null;
    }

    return exceptiontypes;
  }

  
  public void addExceptionType(
          org.apache.xml.utils.synthetic.Class exception)
            throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    org.apache.xml.utils.synthetic.Class[] e =
      new org.apache.xml.utils.synthetic.Class[exceptiontypes.length + 1];

    System.arraycopy(exceptiontypes, 0, e, 0, exceptiontypes.length);

    e[exceptiontypes.length] = exception;
    exceptiontypes = e;
  }

  
  public int getModifiers()
  {
    return modifiers;
  }

  
  public java.lang.String getName()
  {

    if (this instanceof Constructor)
      return declaringclass.getShortName();

    return name;
  }

  
  public void setName(String name) throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.name = name;
  }

  
  public org.apache.xml.utils.synthetic.Class[] getParameterTypes()
  {

    if (realep != null && parametertypes == null)
    {
      parametertypes =
        new org.apache.xml.utils.synthetic.Class[realP.length];

      for (int i = 0; i < realP.length; ++i)
      {
        parametertypes[i] =
          org.apache.xml.utils.synthetic.Class.forClass(realP[i]);
      }

      realP = null;
    }

    return parametertypes;
  }

  
  public String[] getParameterNames()
  {
    return parameternames;
  }

  
  public void addParameter(
          org.apache.xml.utils.synthetic.Class type, String name)
            throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    org.apache.xml.utils.synthetic.Class[] types =
      new org.apache.xml.utils.synthetic.Class[parametertypes.length + 1];

    System.arraycopy(parametertypes, 0, types, 0, parametertypes.length);

    types[parametertypes.length] = type;
    parametertypes = types;

    String[] names = new String[parameternames.length + 1];

    System.arraycopy(parameternames, 0, names, 0, parameternames.length);

    names[parameternames.length] = name;
    parameternames = names;
  }

  
  abstract public int hashCode();

  
  public void setDeclaringClass(
          org.apache.xml.utils.synthetic.Class declaringClass)
            throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.declaringclass = declaringClass;
  }

  
  public void setModifiers(int modifiers) throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.modifiers = modifiers;
  }

  
  public String toString()
  {

    StringBuffer sb =
      new StringBuffer(java.lang.reflect.Modifier.toString(getModifiers()));

    if (this instanceof org.apache.xml.utils.synthetic.reflection.Method)
      sb.append(' ').append(getReturnType()).append(
        getDeclaringClass().getName()).append('.').append(getName());
    else
      sb.append(getDeclaringClass().getName());

    sb.append('(');

    org.apache.xml.utils.synthetic.Class[] p = getParameterTypes();

    if (p != null && p.length > 0)
    {
      sb.append(p[0].getName());

      for (int i = 1; i < p.length; ++i)
      {
        sb.append(',').append(p[i].getName());
      }
    }

    sb.append(')');

    if (this instanceof org.apache.xml.utils.synthetic.reflection.Method)
    {
      p = getExceptionTypes();

      if (p != null && p.length > 0)
      {
        sb.append("" throws "").append(p[0].getName());

        for (int i = 1; i < p.length; ++i)
        {
          sb.append(',').append(p[i].getName());
        }
      }
    }

    return sb.toString();
  }

  
  public void setBody(String language, StringBuffer body)
          throws SynthesisException
  {

    if (realep != null)
      throw new SynthesisException(SynthesisException.REIFIED);

    this.language = language;
    this.body = body;
  }

  
  public StringBuffer getBody()
  {

    if (body == null)
      body = new StringBuffer();

    return body;
  }

  
  public String getLanguage()
  {
    return language;
  }

  
  public String toSource(String basetab)
  {

    StringBuffer sb = new StringBuffer();

    sb.append(basetab).append(
      java.lang.reflect.Modifier.toString(getModifiers()));

    if (this instanceof org.apache.xml.utils.synthetic.reflection.Method)
    {
      if (returntype != null)
        sb.append("" "").append(getReturnType().getJavaName());
      else
        sb.append("" void"");
    }

    sb.append("" "").append(getName()).append(""("");

    org.apache.xml.utils.synthetic.Class[] types = getParameterTypes();

    if (types != null & types.length > 0)
    {
      sb.append(types[0].getJavaName());

      if (parameternames != null)
        sb.append(' ').append(parameternames[0]);

      for (int i = 1; i < types.length; ++i)
      {
        sb.append(',').append(types[i].getJavaName());

        if (parameternames != null)
          sb.append(' ').append(parameternames[i]);
      }
    }

    sb.append(')');

    types = getExceptionTypes();

    if (types != null & types.length > 0)
    {
      sb.append("" throws "").append(types[0].getJavaName());

      for (int i = 1; i < types.length; ++i)
      {
        sb.append(',').append(types[i].getJavaName());
      }
    }

    if (body == null)
      sb.append(""; 
"");
    else
    {
      sb.append(""
"" + basetab + ""{
"");

      if (language == null || ""java"".equals(language))
      {
        sb.append(basetab + ""
"");
        sb.append(basetab + body + ""
"");
      }
      else
      {
        sb.append(basetab + ""
"");
      }

      sb.append(basetab + ""}
"");
    }

    return sb.toString();
  }
}
"
org.apache.xpath.operations.NotEquals,2,3,0,4,4,1,1,3,2,2.0,13,0.0,0,0.976190476,0.75,1,1,5.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class NotEquals extends Operation
{

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return (left.notEquals(right)) ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xpath.functions.FuncExtFunction,8,3,0,11,21,8,3,8,7,0.714285714,137,0.0,0,0.844444444,0.285714286,2,8,15.625,3,1.125,2,"
package org.apache.xpath.functions;

import java.util.Vector;

import org.apache.xpath.Expression;
import org.apache.xpath.XPathContext;
import org.apache.xpath.ExtensionsProvider;
import org.apache.xpath.objects.*;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xalan.extensions.ExtensionsTable;
import org.apache.xml.dtm.DTMIterator;


import org.w3c.dom.DocumentFragment;
import org.w3c.dom.traversal.NodeIterator;

import org.apache.xml.dtm.*;
import org.apache.xpath.axes.*;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;


public class FuncExtFunction extends Function
{

  
  String m_namespace;

  
  String m_extensionName;

  
  Object m_methodKey;

  
  Vector m_argVec = new Vector();

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {

    if (null != m_argVec)
    {
      int nArgs = m_argVec.size();

      for (int i = 0; i < nArgs; i++)
      {
        Expression arg = (Expression) m_argVec.elementAt(i);

        arg.fixupVariables(vars, globalsSize);
      }
    }
  }
  
  public String getNamespace()
  {
    return m_namespace;
  }
  public String getFunctionName()
  {
    return m_extensionName;
  }

  
  public FuncExtFunction(java.lang.String namespace,
                         java.lang.String extensionName, Object methodKey)
  {
    
    m_namespace = namespace;
    m_extensionName = extensionName;
    m_methodKey = methodKey;
  }

  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    XObject result;
    Vector argVec = new Vector();
    int nArgs = m_argVec.size();

    for (int i = 0; i < nArgs; i++)
    {
      Expression arg = (Expression) m_argVec.elementAt(i);
      
      XObject xobj = arg.execute(xctxt);

      argVec.addElement(xobj);
    }
    
    ExtensionsProvider extProvider = (ExtensionsProvider)xctxt.getOwnerObject();
    Object val = extProvider.extFunction(m_namespace, m_extensionName, 
                                         argVec, m_methodKey);

    if (null != val)
    {
      result = XObject.create(val, xctxt);
    }
    else
    {
      result = new XNull();
    }

    return result;
  }

  
  public void setArg(Expression arg, int argNum)
          throws WrongNumberArgsException
  {
    m_argVec.addElement(arg);
  }

  
  public void checkNumberArgs(int argNum) throws WrongNumberArgsException{}

  
  protected void reportWrongNumberArgs() throws WrongNumberArgsException {
    String fMsg = XSLMessages.createXPATHMessage(
        XPATHErrorResources.ER_INCORRECT_PROGRAMMER_ASSERTION,
        new Object[]{ ""Programmer's assertion:  the method FunctionMultiArgs.reportWrongNumberArgs() should never be called."" });

    throw new RuntimeException(fMsg);
  }
}
"
org.apache.xpath.functions.FuncSum,2,4,0,8,11,1,0,8,2,2.0,44,0.0,0,0.979591837,0.75,1,6,21.0,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.DOMHelper;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XString;

import org.apache.xml.utils.XMLString;


public class FuncSum extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    DTMIterator nodes = m_arg0.asIterator(xctxt, xctxt.getCurrentNode());
    double sum = 0.0;
    int pos;

    while (DTM.NULL != (pos = nodes.nextNode()))
    {
      DTM dtm = nodes.getDTM(pos);
      XMLString s = dtm.getStringValue(pos);

      if (null != s)
        sum += s.toDouble();
    }
    nodes.detach();

    return new XNumber(sum);
  }
}
"
org.apache.xalan.xsltc.compiler.FloorCall,2,4,0,12,10,1,0,12,2,2.0,26,0.0,0,0.989690722,0.6,2,4,12.0,1,0.5,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class FloorCall extends FunctionCall {
    public FloorCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	argument().translate(classGen, methodGen);
	methodGen.getInstructionList()
	    .append(new INVOKESTATIC(classGen.getConstantPool()
				     .addMethodref(MATH_CLASS,
						   ""floor"", ""(D)D"")));
    }
}
"
org.apache.xalan.templates.KeyDeclaration,9,3,0,10,17,16,6,6,9,0.75,79,1.0,3,0.960784314,0.296296296,1,2,7.444444444,1,0.8889,0,"
package org.apache.xalan.templates;

import org.apache.xpath.XPath;
import org.apache.xml.utils.QName;


public class KeyDeclaration extends ElemTemplateElement
{

  
  public KeyDeclaration(Stylesheet parentNode, int docOrderNumber)
  {
    m_parentNode = parentNode;
    setUid(docOrderNumber);
  }

  
  private QName m_name;

  
  public void setName(QName name)
  {
    m_name = name;
  }

  
  public QName getName()
  {
    return m_name;
  }

  
  private XPath m_matchPattern = null;

  
  public void setMatch(XPath v)
  {
    m_matchPattern = v;
  }

  
  public XPath getMatch()
  {
    return m_matchPattern;
  }

  
  private XPath m_use;

  
  public void setUse(XPath v)
  {
    m_use = v;
  }

  
  public XPath getUse()
  {
    return m_use;
  }
  
  
  public void compose(StylesheetRoot sroot) 
    throws javax.xml.transform.TransformerException
  {
    super.compose(sroot);
    java.util.Vector vnames = sroot.getComposeState().getVariableNames();
    if(null != m_matchPattern)
      m_matchPattern.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
    if(null != m_use)
      m_use.fixupVariables(vnames, sroot.getComposeState().getGlobalsSize());
  }

  
  public void recompose(StylesheetRoot root)
  {
    root.recomposeKeys(this);
  }

}
"
org.apache.xml.utils.res.XResources_zh_CN,3,4,0,1,4,1,0,1,2,0.5,499,0.0,0,0.976190476,1.0,0,0,165.0,1,0.3333,0,"
package org.apache.xml.utils.res;

import org.apache.xml.utils.res.XResourceBundle;

import java.util.*;






public class XResources_zh_CN extends XResourceBundle
{

  
  public Object[][] getContents()
  {
    return contents;
  }

  
  static final Object[][] contents =
  {
    { ""ui_language"", ""zh"" }, { ""help_language"", ""zh"" }, { ""language"", ""zh"" },
    { ""alphabet"",
      new char[]{ 0xff21, 0xff22, 0xff23, 0xff24, 0xff25, 0xff26, 0xff27,
                  0xff28, 0xff29, 0xff2a, 0xff2b, 0xff2c, 0xff2d, 0xff2e,
                  0xff2f, 0xff30, 0xff31, 0xff32, 0xff33, 0xff34, 0xff35,
                  0xff36, 0xff37, 0xff38, 0xff39, 0xff3a } },
    { ""tradAlphabet"",
      new char[]{ 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
                  'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
                  'Y', 'Z' } },

    
    { ""orientation"", ""LeftToRight"" },

    
    { ""numbering"", ""multiplicative-additive"" },
    { ""multiplierOrder"", ""follows"" },

    
    
    
    { ""numberGroups"", new int[]{ 1 } },

    
    { ""zero"", new char[]{ 0x96f6 } },

    
    { ""multiplier"", new long[]{ 100000000, 10000, 1000, 100, 10 } },
    { ""multiplierChar"",
      new char[]{ 0x4ebf, 0x4e07, 0x5343, 0x767e, 0x5341 } },
    { ""digits"",
      new char[]{ 0x4e00, 0x4e8c, 0x4e09, 0x56db, 0x4e94, 0x516d, 0x4e03,
                  0x516b, 0x4e5d } }, { ""tables"", new String[]{ ""digits"" } }
  };
}
"
org.apache.xpath.functions.FuncTranslate,2,6,0,7,12,1,0,7,2,2.0,70,0.0,0,0.984615385,0.75,1,6,34.0,1,0.5,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xpath.objects.XString;


public class FuncTranslate extends Function3Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String theFirstString = m_arg0.execute(xctxt).str();
    String theSecondString = m_arg1.execute(xctxt).str();
    String theThirdString = m_arg2.execute(xctxt).str();
    int theFirstStringLength = theFirstString.length();
    int theThirdStringLength = theThirdString.length();

    
    
    StringBuffer sbuffer = new StringBuffer();

    for (int i = 0; i < theFirstStringLength; i++)
    {
      char theCurrentChar = theFirstString.charAt(i);
      int theIndex = theSecondString.indexOf(theCurrentChar);

      if (theIndex < 0)
      {

        
        
        sbuffer.append(theCurrentChar);
      }
      else if (theIndex < theThirdStringLength)
      {

        
        
        sbuffer.append(theThirdString.charAt(theIndex));
      }
      else
      {

        
        
        
        
        
      }
    }

    return new XString(sbuffer.toString());
  }
}
"
org.apache.xalan.xsltc.compiler.util.NumberType,3,2,2,5,4,3,4,1,3,2.0,10,0.0,0,0.942857143,1.0,0,0,2.333333333,1,0.6667,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;

public abstract class NumberType extends Type {
    public boolean isNumber() {
	return true;
    }

    public boolean isSimple() {
	return true;
    }
}

"
org.apache.xalan.processor.ProcessorCharacters,5,4,0,9,31,2,2,7,4,0.333333333,151,1.0,1,0.981308411,0.4,1,2,28.6,1,0.8,0,"
package org.apache.xalan.processor;

import java.lang.StringBuffer;
import org.w3c.dom.Node;

import javax.xml.transform.TransformerException;

import org.apache.xalan.templates.ElemText;
import org.apache.xalan.templates.ElemTextLiteral;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.Constants;
import org.apache.xml.utils.XMLCharacterRecognizer;


public class ProcessorCharacters extends XSLTElementProcessor
{

  
  public void startNonText(StylesheetHandler handler) throws org.xml.sax.SAXException
  {
    if (this == handler.getCurrentProcessor())
    {
      handler.popProcessor();
    }

    int nChars = m_accumulator.length();

    if ((nChars > 0)
            && ((null != m_xslTextElement)
                ||!XMLCharacterRecognizer.isWhiteSpace(m_accumulator)) 
                || handler.isSpacePreserve())
    {
      ElemTextLiteral elem = new ElemTextLiteral();

      elem.setDOMBackPointer(m_firstBackPointer);
      elem.setLocaterInfo(handler.getLocator());
      try
      {
        elem.setPrefixes(handler.getNamespaceSupport());
      }
      catch(TransformerException te)
      {
        throw new org.xml.sax.SAXException(te);
      }

      boolean doe = (null != m_xslTextElement)
                    ? m_xslTextElement.getDisableOutputEscaping() : false;

      elem.setDisableOutputEscaping(doe);
      elem.setPreserveSpace(true);

      char[] chars = new char[nChars];

      m_accumulator.getChars(0, nChars, chars, 0);
      elem.setChars(chars);

      ElemTemplateElement parent = handler.getElemTemplateElement();

      parent.appendChild(elem);
    }

    m_accumulator.setLength(0);
    m_firstBackPointer = null;
  }
  
  protected Node m_firstBackPointer = null;

  
  public void characters(
          StylesheetHandler handler, char ch[], int start, int length)
            throws org.xml.sax.SAXException
  {

    m_accumulator.append(ch, start, length);
    
    if(null == m_firstBackPointer)
      m_firstBackPointer = handler.getOriginatingNode();

    
    if (this != handler.getCurrentProcessor())
      handler.pushProcessor(this);
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    
    
    
    startNonText(handler);
    handler.getCurrentProcessor().endElement(handler, uri, localName,
                                             rawName);
    handler.popProcessor();
  }

  
  private StringBuffer m_accumulator = new StringBuffer();

  
  private ElemText m_xslTextElement;

  
  void setXslTextElement(ElemText xslTextElement)
  {
    m_xslTextElement = xslTextElement;
  }
}
"
org.apache.xalan.extensions.ExtensionNamespacesManager,9,1,0,7,29,12,5,2,8,0.625,453,1.0,0,0.0,0.416666667,0,0,49.0,7,2.5556,0,"
package org.apache.xalan.extensions;

import org.apache.xalan.templates.Constants;
import java.util.Vector;


public class ExtensionNamespacesManager
{
  
  private Vector m_extensions = new Vector();
  
  private Vector m_predefExtensions = new Vector(7);
  
  private Vector m_unregisteredExtensions = new Vector();
  
  
  public ExtensionNamespacesManager()
  {
    setPredefinedNamespaces();
  }
  
  
  public void registerExtension(String namespace)
  {
    if (namespaceIndex(namespace, m_extensions) == -1)
    {
      int predef = namespaceIndex(namespace, m_predefExtensions);
      if (predef !=-1)
        m_extensions.addElement(m_predefExtensions.elementAt(predef));
      else if (!(m_unregisteredExtensions.contains(namespace)))
        m_unregisteredExtensions.addElement(namespace);       
    }
  }
  
    
  public void registerExtension(ExtensionNamespaceSupport extNsSpt)
  {
    String namespace = extNsSpt.getNamespace();
    if (namespaceIndex(namespace, m_extensions) == -1)
    {
      m_extensions.addElement(extNsSpt);
      if (m_unregisteredExtensions.contains(namespace))
        m_unregisteredExtensions.removeElement(namespace);
    }
    
  }
  
  
  public int namespaceIndex(String namespace, Vector extensions)
  {
    for (int i = 0; i < extensions.size(); i++)
    {
      if (((ExtensionNamespaceSupport)extensions.elementAt(i)).getNamespace().equals(namespace))
        return i;
    }
    return -1;
  }
  
    
  
  public Vector getExtensions()
  {
    return m_extensions;
  }
  
  
  public void registerUnregisteredNamespaces()
  {
    for (int i = 0; i < m_unregisteredExtensions.size(); i++)
    {
      String ns = (String)m_unregisteredExtensions.elementAt(i);
      ExtensionNamespaceSupport extNsSpt = defineJavaNamespace(ns);
      if (extNsSpt != null)
        m_extensions.addElement(extNsSpt);
    }    
  }
  
    
  public ExtensionNamespaceSupport defineJavaNamespace(String ns)
  {
    return defineJavaNamespace(ns, ns);
  }
  public ExtensionNamespaceSupport defineJavaNamespace(String ns, String classOrPackage)
  {
    if(null == ns || ns.trim().length() == 0) 
      return null;

    
    
    
    String className = classOrPackage;
    if (className.startsWith(""class:""))
      className = className.substring(6);

    int lastSlash = className.lastIndexOf(""/"");
    if (-1 != lastSlash)
      className = className.substring(lastSlash + 1);
      
    
    
    if(null == className || className.trim().length() == 0) 
      return null;
    
    try
    {
      ExtensionHandler.getClassForName(className);
      return new ExtensionNamespaceSupport(
                           ns, 
                           ""org.apache.xalan.extensions.ExtensionHandlerJavaClass"",                                         
                           new Object[]{ns, ""javaclass"", className});
    }
    catch (ClassNotFoundException e)
    {
      return new ExtensionNamespaceSupport(
                            ns, 
                            ""org.apache.xalan.extensions.ExtensionHandlerJavaPackage"",
                            new Object[]{ns, ""javapackage"", className + "".""});
    }
  }
  

  
  
  
  private void setPredefinedNamespaces()
  {    
    String uri = Constants.S_EXTENSIONS_JAVA_URL;
    String handlerClassName = ""org.apache.xalan.extensions.ExtensionHandlerJavaPackage"";
    String lang = ""javapackage"";
    String lib = """";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
   
    uri = Constants.S_EXTENSIONS_LOTUSXSL_JAVA_URL;
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
    
    uri = Constants.S_EXTENSIONS_XALANLIB_URL;
    handlerClassName = ""org.apache.xalan.extensions.ExtensionHandlerJavaClass"";
    lang = ""javaclass""; 
    lib = ""org.apache.xalan.lib.Extensions"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
    
    
    
    uri = Constants.S_EXSLT_COMMON_URL;
    lib = ""org.apache.xalan.lib.ExsltCommon"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));

    uri = Constants.S_EXSLT_MATH_URL;
    lib = ""org.apache.xalan.lib.ExsltMath"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
    
    uri = Constants.S_EXSLT_SETS_URL;
    lib = ""org.apache.xalan.lib.ExsltSets"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
    
    uri = Constants.S_EXSLT_DATETIME_URL;
    lib = ""org.apache.xalan.lib.ExsltDatetime"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
                                             
    uri = ""http:
    lib = ""org.apache.xalan.lib.ExsltDynamic"";
    m_predefExtensions.addElement(new ExtensionNamespaceSupport(uri, handlerClassName,
                                             new Object[]{uri, lang, lib}));
                                             
  }    
  
}"
org.apache.xalan.extensions.ExtensionNamespaceSupport,3,1,0,5,12,0,4,1,3,0.5,133,0.0,0,0.0,0.555555556,0,0,42.0,1,0.6667,0,"package org.apache.xalan.extensions;

import java.lang.reflect.Constructor;
import javax.xml.transform.TransformerException;


public class ExtensionNamespaceSupport
{
  
  
  String m_namespace = null;
  String m_handlerClass = null;
  Class [] m_sig = null;  
  Object [] m_args = null;
 
  public ExtensionNamespaceSupport(String namespace, 
                                   String handlerClass, 
                                   Object[] constructorArgs)
  {
    m_namespace = namespace;
    m_handlerClass = handlerClass;
    m_args = constructorArgs;
    
    m_sig = new Class[m_args.length];
    for (int i = 0; i < m_args.length; i++)
    {
      if (m_args[i] != null)
        m_sig[i] = m_args[i].getClass();
      else 
      {
        m_sig = null;
        break;
      }
    }
  }
  
  public String getNamespace()
  {
    return m_namespace;
  }
  
  
  public ExtensionHandler launch()
    throws TransformerException
  {
    ExtensionHandler handler = null;
    try
    {
      Class cl = ExtensionHandler.getClassForName(m_handlerClass);
      Constructor con = null;
      
      if (m_sig != null)
        con = cl.getConstructor(m_sig);
      else 
      {
        Constructor[] cons = cl.getConstructors();
        for (int i = 0; i < cons.length; i ++)
        {
          if (cons[i].getParameterTypes().length == m_args.length)
          {
            con = cons[i];
            break;
          }
        }
      }
      
      if (con != null)
        handler = (ExtensionHandler)con.newInstance(m_args);
      else
        throw new TransformerException(""ExtensionHandler constructor not found"");
    }
    catch (Exception e)
    {
      throw new TransformerException(e);
    }
    return handler;
  }

}"
org.apache.xalan.processor.ProcessorExsltFuncResult,2,5,0,8,8,1,1,7,2,2.0,57,0.0,0,0.995327103,0.625,1,1,27.5,1,0.5,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemExsltFunction;
import org.apache.xalan.templates.ElemExsltFuncResult;
import org.apache.xalan.templates.ElemVariable;
import org.apache.xalan.templates.ElemParam;
import org.apache.xalan.templates.ElemFallback;
import org.apache.xalan.res.XSLTErrorResources;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;
import org.xml.sax.SAXException;

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.lang.NoSuchMethodException;
import java.lang.InstantiationException;
import java.lang.IllegalAccessException;

import java.util.Vector;


public class ProcessorExsltFuncResult extends ProcessorTemplateElem
{
  
  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws SAXException
  {
    String msg = """";

    super.startElement(handler, uri, localName, rawName, attributes);
    ElemTemplateElement ancestor = handler.getElemTemplateElement().getParentElem();
    while (ancestor != null && !(ancestor instanceof ElemExsltFunction))
    {
      if (ancestor instanceof ElemVariable 
          || ancestor instanceof ElemParam
          || ancestor instanceof ElemExsltFuncResult)
      {
        msg = ""func:result cannot appear within a variable, parameter, or another func:result."";
        handler.error(msg, new SAXException(msg));
      }
      ancestor = ancestor.getParentElem();
    }
    if (ancestor == null)
    {
      msg = ""func:result must appear in a func:function element"";
      handler.error(msg, new SAXException(msg));
    }
  }
}"
org.apache.xalan.processor.ProcessorTemplateElem,4,4,8,14,23,6,9,5,3,2.0,94,0.0,0,0.985915493,0.55,1,1,22.5,1,0.75,0,"
package org.apache.xalan.processor;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.res.XSLTErrorResources;

import javax.xml.transform.TransformerException;
import org.xml.sax.Attributes;

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;
import java.lang.NoSuchMethodException;
import java.lang.InstantiationException;
import java.lang.IllegalAccessException;

import java.util.Vector;


public class ProcessorTemplateElem extends XSLTElementProcessor
{

  
  public void startElement(
          StylesheetHandler handler, String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {

    super.startElement(handler, uri, localName, rawName, attributes);
    try
    {
      
      XSLTElementDef def = getElemDef();
      Class classObject = def.getClassObject();
      ElemTemplateElement elem = null;

      try
      {
        elem = (ElemTemplateElement) classObject.newInstance();

        elem.setDOMBackPointer(handler.getOriginatingNode());
        elem.setLocaterInfo(handler.getLocator());
        elem.setPrefixes(handler.getNamespaceSupport());
      }
      catch (InstantiationException ie)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CREATING_ELEMTMPL, null, ie);
      }
      catch (IllegalAccessException iae)
      {
        handler.error(XSLTErrorResources.ER_FAILED_CREATING_ELEMTMPL, null, iae);
      }

      setPropertiesFromAttributes(handler, rawName, attributes, elem);
      appendAndPush(handler, elem);
    }
    catch(TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  protected void appendAndPush(
          StylesheetHandler handler, ElemTemplateElement elem)
            throws org.xml.sax.SAXException
  {

    ElemTemplateElement parent = handler.getElemTemplateElement();
    if(null != parent)  
    {
      parent.appendChild(elem);
      handler.pushElemTemplateElement(elem);
    }
  }

  
  public void endElement(
          StylesheetHandler handler, String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {
    super.endElement(handler, uri, localName, rawName);
    handler.popElemTemplateElement();
  }
}
"
org.apache.xalan.lib.sql.DefaultConnectionPool,19,1,0,4,47,57,1,3,16,0.784722222,395,1.0,0,0.0,0.218045113,0,0,19.36842105,3,1.2105,3,"
package org.apache.xalan.lib.sql;

import java.sql.Connection;
import java.sql.DatabaseMetaData;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.util.Enumeration;
import java.util.Properties;
import java.util.Vector;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


public class DefaultConnectionPool implements ConnectionPool
{
  
  private static final boolean DEBUG = false;

  
  private String m_driver = new String("""");
  
  private String m_url = new String("""");


  
  private int m_PoolMinSize = 1;


  
  private Properties m_ConnectionProtocol = new Properties();

  
  private Vector m_pool = new Vector();

  
  private boolean m_IsActive = false;

  
  public DefaultConnectionPool( ) {}


  
  public boolean isEnabled( )
  {
    return m_IsActive;
  }

  
  public void setDriver( String d )
  {
    m_driver = d;
  }

  
  public void setURL( String url )
  {
    m_url = url;
  }

  
  public void freeUnused( )
  {
    
    
    for ( int x = 0; x < m_pool.size(); x++ )
    {


      PooledConnection pcon =
        (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.inUse() == false )
      {
        if (DEBUG)
        {
          System.err.println(""Closing JDBC Connection "" + x);
        }

        pcon.close();
      }
    }

  }

  
  public boolean hasActiveConnections( )
  {
    return (m_pool.size() > 0);
  }


  
  public void setPassword( String p )
  {
    m_ConnectionProtocol.put(""password"", p);
  }

  
  public void setUser( String u )
  {
    m_ConnectionProtocol.put(""user"", u);
  }

  
  public void setProtocol( Properties p )
  {
    Enumeration e = p.keys();
    while (e.hasMoreElements())
    {
      String key = (String) e.nextElement();
      m_ConnectionProtocol.put(key, p.getProperty(key));
    }
  }


  
  public void setMinConnections( int n )
  {
    m_PoolMinSize = n;
  }

  
  public boolean testConnection( )
  {
    try
    {
      if (DEBUG)
      {
        System.out.println(""Testing Connection"");
      }

      Connection conn = getConnection();

      if (DEBUG)
      {
        DatabaseMetaData dma = conn.getMetaData();

        System.out.println(""
Connected to "" + dma.getURL());
        System.out.println(""Driver   "" + dma.getDriverName());
        System.out.println(""Version  "" + dma.getDriverVersion());
        System.out.println("""");
      }

      if (conn == null) return false;

      releaseConnection(conn);

      if (DEBUG)
      {
        System.out.println(""Testing Connection, SUCCESS"");
      }

      return true;
    }
    catch(Exception e)
    {
      if (DEBUG)
      {
        System.out.println(""Testing Connection, FAILED"");
        e.printStackTrace();
      }

      return false;
    }

  }


  
  
  public synchronized Connection getConnection( )throws IllegalArgumentException, SQLException
  {

    PooledConnection pcon = null;

    
    
    
    
    if ( m_pool.size() < m_PoolMinSize ) { initializePool(); }

    
    for ( int x = 0; x < m_pool.size(); x++ )
    {

      pcon = (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.inUse() == false )
      {
        
        pcon.setInUse(true);
        
        
        return pcon.getConnection();
      }
    }

    
    

    
    Connection con = createConnection();

    
    
    pcon = new PooledConnection(con);

    
    pcon.setInUse(true);

    
    m_pool.addElement(pcon);

    
    return pcon.getConnection();
  }

  
  public synchronized void releaseConnection( Connection con )throws SQLException
  {

    
    for ( int x = 0; x < m_pool.size(); x++ )
    {

      PooledConnection pcon =
        (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.getConnection() == con )
      {
        if (DEBUG)
        {
          System.out.println(""Releasing Connection "" + x);
        }

        if (! isEnabled())
        {
          con.close();
          m_pool.removeElementAt(x);
          if (DEBUG)
          {
            System.out.println(""-->Inactive Pool, Closing connection"");
          }

        }
        else
        {
          
          
          pcon.setInUse(false);
        }

        break;
      }
    }
  }


  
  public synchronized void releaseConnectionOnError( Connection con )throws SQLException
  {

    
    for ( int x = 0; x < m_pool.size(); x++ )
    {

      PooledConnection pcon =
        (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.getConnection() == con )
      {
        if (DEBUG)
        {
          System.out.println(""Releasing Connection On Error"" + x);
        }

        con.close();
        m_pool.removeElementAt(x);
        if (DEBUG)
        {
          System.out.println(""-->Inactive Pool, Closing connection"");
        }
        break;
      }
    }
  }


  
  private Connection createConnection( )throws SQLException
  {
    Connection con = null;

    
    con = DriverManager.getConnection( m_url, m_ConnectionProtocol );

    return con;
  }

  
  
  public synchronized void initializePool( )throws IllegalArgumentException, SQLException
  {

     
     if ( m_driver == null )
     {
       throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_DRIVER_NAME_SPECIFIED, null));
       
     }

     if ( m_url == null )
     {
       throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_URL_SPECIFIED, null));
       
     }

     if ( m_PoolMinSize < 1 )
     {
       throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_POOLSIZE_LESS_THAN_ONE, null));
       
     }

     
     

     try
     {
       Class.forName( m_driver );
     }
     catch(ClassNotFoundException e)
     {
       throw new IllegalArgumentException(XSLMessages.createMessage(XSLTErrorResources.ER_INVALID_DRIVER_NAME, null));
       
     }

     
     
     if ( !m_IsActive) return;

    
    do
    {

      Connection con = createConnection();

      if ( con != null )
      {

        
        
        PooledConnection pcon = new PooledConnection(con);

        
        addConnection(pcon);

        if (DEBUG) System.out.println(""Adding DB Connection to the Pool"");
      }
    }
    while (m_pool.size() < m_PoolMinSize);
  }

  
  
  private void addConnection( PooledConnection value )
  {
    
    m_pool.addElement(value);
  }


  
  protected void finalize( )throws Throwable
  {
    if (DEBUG)
    {
      System.out.println(""In Default Connection Pool, Finalize"");
    }

    
    
    for ( int x = 0; x < m_pool.size(); x++ )
    {

      if (DEBUG)
      {
        System.out.println(""Closing JDBC Connection "" + x);
      }

      PooledConnection pcon =
        (PooledConnection) m_pool.elementAt(x);

      
      if ( pcon.inUse() == false ) { pcon.close();  }
      else
      {
        if (DEBUG)
        {
          System.out.println(""--> Force close"");
        }

        
        
        try
        {
          java.lang.Thread.sleep(30000);
          pcon.close();
        }
        catch (InterruptedException ie)
        {
          if (DEBUG) System.err.println(ie.getMessage());
        }
      }
    }

    if (DEBUG)
    {
      System.out.println(""Exit Default Connection Pool, Finalize"");
    }

    super.finalize();
  }

  
  public void setPoolEnabled( final boolean flag )
  {

  }


}
"
org.apache.xalan.templates.ElemExsltFuncResult,5,4,0,10,15,10,3,7,5,2.0,62,0.0,0,0.981900452,0.6,3,7,11.4,3,1.2,1,"package org.apache.xalan.templates;


import org.apache.xml.dtm.DTM;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.Expression;
import org.apache.xpath.objects.XObjectFactory;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;
import org.apache.xpath.objects.XRTreeFrag;
import org.apache.xpath.objects.XRTreeFragSelectWrapper;
import org.apache.xml.utils.QName;
import org.apache.xalan.trace.SelectionEvent;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;


public class ElemExsltFuncResult extends ElemVariable
{
 
  
  public void execute(TransformerImpl transformer) throws TransformerException
  {    
    XPathContext context = transformer.getXPathContext();
    VariableStack varStack = context.getVarStack();
    
    ElemExsltFunction owner = getOwnerFunction();
    if (owner != null)
    {
      int resultIndex = owner.getResultIndex();
      
      
      
      if (varStack.isLocalSet(resultIndex))
        throw new TransformerException
          (""An EXSLT function cannot set more than one result!"");
      int sourceNode = context.getCurrentNode();
      
      XObject var = getValue(transformer, sourceNode);   
      varStack.setLocalVariable(resultIndex, var);
    }    
  }

  
  public int getXSLToken()
  {
    return Constants.EXSLT_ELEMNAME_FUNCRESULT;
  }
  
  
   public String getNodeName()
  {
    return Constants.EXSLT_ELEMNAME_FUNCRESULT_STRING;
  }
  
  
  public ElemExsltFunction getOwnerFunction()
  {
  	ElemTemplateElement elem = this;
  	while((elem != null) && !(elem instanceof ElemExsltFunction))
  	{
    	elem = elem.getParentElem();
  	}
  	return (ElemExsltFunction)elem;
  }
  
}
"
org.apache.xml.utils.WrappedRuntimeException,3,4,0,35,5,0,35,0,3,0.0,22,1.0,0,0.944444444,0.666666667,0,0,6.0,1,0.3333,0,"
package org.apache.xml.utils;


public class WrappedRuntimeException extends RuntimeException
{

  
  private Exception m_exception;

  
  public WrappedRuntimeException(Exception e)
  {

    super(e.getMessage());

    m_exception = e;
  }

  
  public WrappedRuntimeException(String msg, Exception e)
  {

    super(msg);

    m_exception = e;
  }
  
  
  public Exception getException()
  {
    return m_exception;
  }
}
"
org.apache.xalan.templates.ElemParam,6,4,0,18,21,15,7,11,6,1.0,80,0.0,0,0.981900452,0.375,3,8,12.16666667,1,0.6667,0,"
package org.apache.xalan.templates;

import org.w3c.dom.*;

import org.xml.sax.*;

import org.apache.xpath.*;
import org.apache.xpath.objects.XObject;
import org.apache.xalan.trace.*;
import org.apache.xml.utils.QName;
import org.apache.xalan.transformer.TransformerImpl;

import javax.xml.transform.TransformerException;


public class ElemParam extends ElemVariable
{
  int m_qnameID;

  
  public ElemParam(){}

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_PARAMVARIABLE;
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_PARAMVARIABLE_STRING;
  }

  
  public ElemParam(ElemParam param) throws TransformerException
  {
    super(param);
  }

  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
    m_qnameID = sroot.getComposeState().getQNameID(m_qname);
    if(m_parentNode.getXSLToken() == Constants.ELEMNAME_TEMPLATE)
      ((ElemTemplate)m_parentNode).m_inArgsSize++;
  }
  
  
  public void execute(TransformerImpl transformer) throws TransformerException
  {
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEvent(this);
      
    VariableStack vars = transformer.getXPathContext().getVarStack();
    
    if(!vars.isLocalSet(m_index))
    {

      int sourceNode = transformer.getXPathContext().getCurrentNode();
      XObject var = getValue(transformer, sourceNode);
  
      
      transformer.getXPathContext().getVarStack().setLocalVariable(m_index, var);
    }
    
    if (TransformerImpl.S_DEBUG)
      transformer.getTraceManager().fireTraceEndEvent(this);
  }
  
}
"
org.apache.xpath.patterns.FunctionPattern,7,4,0,14,18,0,3,12,6,0.166666667,156,0.0,1,0.931034483,0.367346939,3,17,21.14285714,2,1.0,0,"
package org.apache.xpath.patterns;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.patterns.StepPattern.PredOwner;


public class FunctionPattern extends StepPattern
{

  
  public FunctionPattern(Expression expr, int axis, int predaxis)
  {

    super(0, null, null, axis, predaxis);

    m_functionExpr = expr;
  }

  
  public final void calcScore()
  {

    m_score = SCORE_OTHER;

    if (null == m_targetString)
      calcTargetString();
  }

  
  Expression m_functionExpr;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    m_functionExpr.fixupVariables(vars, globalsSize);
  }

  
  
  public XObject execute(XPathContext xctxt, int context)
          throws javax.xml.transform.TransformerException
  {

    DTMIterator nl = m_functionExpr.asIterator(xctxt, context);
    XNumber score = SCORE_NONE;

    if (null != nl)
    {
      int n;

      while (DTM.NULL != (n = nl.nextNode()))
      {
        score = (n == context) ? SCORE_OTHER : SCORE_NONE;

        if (score == SCORE_OTHER)
        {
          context = n;

          break;
        }
      }

      
    }
    nl.detach();

    return score;
  }
  
  
  public XObject execute(XPathContext xctxt, int context, 
                         DTM dtm, int expType)
          throws javax.xml.transform.TransformerException
  {

    DTMIterator nl = m_functionExpr.asIterator(xctxt, context);
    XNumber score = SCORE_NONE;

    if (null != nl)
    {
      int n;

      while (DTM.NULL != (n = nl.nextNode()))
      {
        score = (n == context) ? SCORE_OTHER : SCORE_NONE;

        if (score == SCORE_OTHER)
        {
          context = n;

          break;
        }
      }

      nl.detach();
    }

    return score;
  }
  
  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    int context = xctxt.getCurrentNode();
    DTMIterator nl = m_functionExpr.asIterator(xctxt, context);
    XNumber score = SCORE_NONE;

    if (null != nl)
    {
      int n;

      while (DTM.NULL != (n = nl.nextNode()))
      {
        score = (n == context) ? SCORE_OTHER : SCORE_NONE;

        if (score == SCORE_OTHER)
        {
          context = n;

          break;
        }
      }

      nl.detach();
    }

    return score;
  }
  
  class FunctionOwner implements ExpressionOwner
  {
    
    public Expression getExpression()
    {
      return m_functionExpr;
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(FunctionPattern.this);
    	m_functionExpr = exp;
    }
  }
  
  
  protected void callSubtreeVisitors(XPathVisitor visitor)
  {
    m_functionExpr.callVisitors(new FunctionOwner(), visitor);
    super.callSubtreeVisitors(visitor);
  }

}
"
org.apache.xalan.xsltc.dom.CurrentNodeListIterator,12,2,0,6,31,6,0,6,11,0.602272727,245,1.0,4,0.5,0.319444444,1,5,18.75,3,1.3333,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;
import org.apache.xalan.xsltc.util.IntegerArray;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public final class CurrentNodeListIterator extends NodeIteratorBase {

    private boolean _docOrder;
    private NodeIterator _source;
    private final CurrentNodeListFilter _filter;
    private IntegerArray _nodes = new IntegerArray();
	
    private int _current;	
    private int _last = -1;		
	
    private final int _currentNode;
    private AbstractTranslet _translet;

    public CurrentNodeListIterator(NodeIterator source, 
				   CurrentNodeListFilter filter,
				   int currentNode,
				   AbstractTranslet translet) 
    {
	this(source, !source.isReverse(), filter, currentNode, translet);
    }

    public CurrentNodeListIterator(NodeIterator source, boolean docOrder,
				   CurrentNodeListFilter filter,
				   int currentNode,
				   AbstractTranslet translet) 
    {
	_source = source;
	_filter = filter;
	_translet = translet;
	_docOrder = docOrder;
	_currentNode = currentNode;
    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }

    public boolean isReverse() {
	return !_docOrder;
    }

    public NodeIterator cloneIterator() {
	try {
	    final CurrentNodeListIterator clone =
		(CurrentNodeListIterator)super.clone();
	    clone._nodes = (IntegerArray)_nodes.clone();
	    clone.setRestartable(false);
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public NodeIterator reset() {
	_current = 0;
	return resetPosition();
    }

    public int next() {
	final int last = _nodes.cardinality();
	final int currentNode = _currentNode;
	final AbstractTranslet translet = _translet;

	for (int index = _current; index < last; ) {
	    final int node = _nodes.at(index++); 	
	    if (_filter.test(node, index, last, currentNode, translet, this)) {
		_current = index;
		return returnNode(node);
	    }
	}
	return END;
    }

    public NodeIterator setStartNode(int node) {
	NodeIterator retval = this;
	
	if (_isRestartable) {
	    _source.setStartNode(_startNode = node);

	    _nodes.clear();
	    while ((node = _source.next()) != END) {
		_nodes.add(node);
	    }
	    _current = 0;
	    retval = resetPosition();
	}
	return retval;
    }
	
    public int getLast() {
	if (_last == -1) {
	    _last = computePositionOfLast();
	}
	return _last;
    }

    public void setMark() {
	_source.setMark();
	_markedNode = _current;
    }

    public void gotoMark() {
	_source.gotoMark();
	_current = _markedNode;
    }

    private int computePositionOfLast() {
        final int last = _nodes.cardinality();
        final int currNode = _currentNode;
	final AbstractTranslet translet = _translet;

	int lastPosition = 0;
	for (int index = _current; index < last; ) {
            int nodeIndex = _nodes.at(index++); 	
            if (_filter.test(nodeIndex, index, last, currNode, translet, this)) {
                lastPosition++;
            }
        }
	return lastPosition;
    }
}

"
org.apache.xpath.functions.FuncLang,2,4,0,6,15,1,0,6,2,2.0,73,0.0,0,0.979591837,0.75,1,6,35.5,1,0.5,0,"
package org.apache.xpath.functions;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class FuncLang extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String lang = m_arg0.execute(xctxt).str();
    int parent = xctxt.getCurrentNode();
    boolean isLang = false;
    DTM dtm = xctxt.getDTM(parent);

    while (DTM.NULL != parent)
    {
      if (DTM.ELEMENT_NODE == dtm.getNodeType(parent))
      {
        int langAttr = dtm.getAttributeNode(parent, ""http:

        if (DTM.NULL != langAttr)
        {
          String langVal = dtm.getNodeValue(langAttr);
          
          if (langVal.toLowerCase().startsWith(lang.toLowerCase()))
          {
            int valLen = lang.length();

            if ((langVal.length() == valLen)
                    || (langVal.charAt(valLen) == '-'))
            {
              isLang = true;
            }
          }

          break;
        }
      }

      parent = dtm.getParent(parent);
    }

    return isLang ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xpath.functions.FuncUnparsedEntityURI,2,4,0,6,10,1,0,6,2,2.0,30,0.0,0,0.979591837,0.75,1,6,14.0,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;



import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;

import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class FuncUnparsedEntityURI extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String name = m_arg0.execute(xctxt).str();
    int context = xctxt.getCurrentNode();
    DTM dtm = xctxt.getDTM(context);
    int doc = dtm.getDocument();
    
    String uri = dtm.getUnparsedEntityURI(name);

    return new XString(uri);
  }
}
"
org.apache.xalan.templates.ElemApplyTemplates,9,5,0,21,84,20,1,21,9,0.6875,586,1.0,1,0.965811966,0.311111111,5,10,63.88888889,1,0.8889,1,"
package org.apache.xalan.templates;


import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xalan.transformer.ResultTreeHandler;
import org.apache.xalan.transformer.StackGuard;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.QName;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPath;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XObject;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;


public class ElemApplyTemplates extends ElemCallTemplate
{

  
  private QName m_mode = null;

  
  public void setMode(QName mode)
  {
    m_mode = mode;
  }

  
  public QName getMode()
  {
    return m_mode;
  }

  
  private boolean m_isDefaultTemplate = false;
  






  
  public void setIsDefaultTemplate(boolean b)
  {
    m_isDefaultTemplate = b;
  }

  
  public int getXSLToken()
  {
    return Constants.ELEMNAME_APPLY_TEMPLATES;
  }
  
  
  public void compose(StylesheetRoot sroot) throws TransformerException
  {
    super.compose(sroot);
  }

  
  public String getNodeName()
  {
    return Constants.ELEMNAME_APPLY_TEMPLATES_STRING;
  }

  
  public void execute(TransformerImpl transformer) throws TransformerException
  {

    transformer.pushCurrentTemplateRuleIsNull(false);

    boolean pushMode = false;

    try
    {
      
      
      
      
      QName mode = transformer.getMode();

      if (!m_isDefaultTemplate)
      {
        if (((null == mode) && (null != m_mode))
                || ((null != mode) &&!mode.equals(m_mode)))
        {
          pushMode = true;

          transformer.pushMode(m_mode);
        }
      }
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEvent(this);

      transformSelectedNodes(transformer);
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireTraceEndEvent(this);

      if (pushMode)
        transformer.popMode();

      transformer.popCurrentTemplateRuleIsNull();
    }
  }

  
  
  public void transformSelectedNodes(TransformerImpl transformer)
            throws TransformerException
  {

    final XPathContext xctxt = transformer.getXPathContext();
    final int sourceNode = xctxt.getCurrentNode();
    DTMIterator sourceNodes = m_selectExpression.asIterator(xctxt, sourceNode);
    VariableStack vars = xctxt.getVarStack();
    int nParams = getParamElemCount();
    int thisframe = vars.getStackFrame();
    StackGuard guard = transformer.getStackGuard();
    boolean check = (guard.getRecursionLimit() > -1) ? true : false;
      
    try
    {

      final Vector keys = (m_sortElems == null)
                          ? null
                          : transformer.processSortKeys(this, sourceNode);

      
      if (null != keys)
        sourceNodes = sortNodes(xctxt, keys, sourceNodes);

      if (TransformerImpl.S_DEBUG)
      {
        transformer.getTraceManager().fireSelectedEvent(sourceNode, this,
                ""select"", new XPath(m_selectExpression),
                new org.apache.xpath.objects.XNodeSet(sourceNodes));
      }

      final ResultTreeHandler rth = transformer.getResultTreeHandler();
      ContentHandler chandler = rth.getContentHandler();
      final StylesheetRoot sroot = transformer.getStylesheet();
      final TemplateList tl = sroot.getTemplateListComposed();
      final boolean quiet = transformer.getQuietConflictWarnings();
      
      
      DTM dtm = xctxt.getDTM(sourceNode);
      
      int argsFrame = -1;
      if(nParams > 0)
      {
        
        
        
        argsFrame = vars.link(nParams);
        vars.setStackFrame(thisframe);
        
        for (int i = 0; i < nParams; i++) 
        {
          ElemWithParam ewp = m_paramElems[i];
          XObject obj = ewp.getValue(transformer, sourceNode);
          
          vars.setLocalVariable(i, obj, argsFrame);
        }
        vars.setStackFrame(argsFrame);
      }
      
      xctxt.pushCurrentNode(DTM.NULL);
      int[] currentNodes = xctxt.getCurrentNodeStack();
      int currentNodePos = xctxt.getCurrentNodeFirstFree() - 1;
      
      xctxt.pushCurrentExpressionNode(DTM.NULL);
      int[] currentExpressionNodes = xctxt.getCurrentExpressionNodeStack();
      int currentExpressionNodePos = xctxt.getCurrentExpressionNodesFirstFree() - 1;

      xctxt.pushSAXLocatorNull();
      xctxt.pushContextNodeList(sourceNodes);
      transformer.pushElemTemplateElement(null);
      
      
      int child;
      while (DTM.NULL != (child = sourceNodes.nextNode()))
      {
        currentNodes[currentNodePos] = child;
        currentExpressionNodes[currentExpressionNodePos] = child;

        if(xctxt.getDTM(child) != dtm)
        {
          dtm = xctxt.getDTM(child);
        }
        
        final int exNodeType = dtm.getExpandedTypeID(child);
        final int nodeType = dtm.getNodeType(child);

        final QName mode = transformer.getMode();

        ElemTemplate template = tl.getTemplateFast(xctxt, child, exNodeType, mode, 
                                      -1, quiet, dtm);

        
        
        if (null == template)
        {
          switch (nodeType)
          {
          case DTM.DOCUMENT_FRAGMENT_NODE :
          case DTM.ELEMENT_NODE :
            template = sroot.getDefaultRule();
            
            break;
          case DTM.ATTRIBUTE_NODE :
          case DTM.CDATA_SECTION_NODE :
          case DTM.TEXT_NODE :
            
            
            transformer.pushPairCurrentMatched(sroot.getDefaultTextRule(), child);
            transformer.setCurrentElement(sroot.getDefaultTextRule());
            
            dtm.dispatchCharactersEvents(child, rth, false);
            transformer.popCurrentMatched();
            continue;
          case DTM.DOCUMENT_NODE :
            template = sroot.getDefaultRootRule();
            break;
          default :

            
            continue;
          }
        }
        else
        {
        	transformer.setCurrentElement(template);
        }
                
        transformer.pushPairCurrentMatched(template, child);
        if (check)
	        guard.checkForInfinateLoop();

        int currentFrameBottom;  
        if(template.m_frameSize > 0)
        {
          xctxt.pushRTFContext();
          currentFrameBottom = vars.getStackFrame();  
          vars.link(template.m_frameSize);
          
          
          if( template.m_inArgsSize > 0)
          {
            int paramIndex = 0;
            for (ElemTemplateElement elem = template.getFirstChildElem(); 
                 null != elem; elem = elem.getNextSiblingElem()) 
            {
              if(Constants.ELEMNAME_PARAMVARIABLE == elem.getXSLToken())
              {
                ElemParam ep = (ElemParam)elem;
                
                int i;
                for (i = 0; i < nParams; i++) 
                {
                  ElemWithParam ewp = m_paramElems[i];
                  if(ewp.m_qnameID == ep.m_qnameID)
                  {
                    XObject obj = vars.getLocalVariable(i, argsFrame);
                    vars.setLocalVariable(paramIndex, obj);
                    break;
                  }
                }
                if(i == nParams)
                  vars.setLocalVariable(paramIndex, null);
              }
              else
                break;
              paramIndex++;
            }
            
          }
        }
        else
        	currentFrameBottom = 0;

        
        if (TransformerImpl.S_DEBUG)
          transformer.getTraceManager().fireTraceEvent(template);

        
        
        
        for (ElemTemplateElement t = template.m_firstChild; 
             t != null; t = t.m_nextSibling)
        {
          xctxt.setSAXLocator(t);
          try
          {
          	transformer.pushElemTemplateElement(t);
          	t.execute(transformer);
          }
          finally
          {
          	transformer.popElemTemplateElement();
          }
        }
        
        if (TransformerImpl.S_DEBUG)
	      transformer.getTraceManager().fireTraceEndEvent(template); 
	    
        if(template.m_frameSize > 0)
        {
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          
          vars.unlink(currentFrameBottom);
          xctxt.popRTFContext();
        }
          
        transformer.popCurrentMatched();
        
      } 
    }
    catch (SAXException se)
    {
      transformer.getErrorListener().fatalError(new TransformerException(se));
    }
    finally
    {
      if (TransformerImpl.S_DEBUG)
        transformer.getTraceManager().fireSelectedEndEvent(sourceNode, this,
                ""select"", new XPath(m_selectExpression),
                new org.apache.xpath.objects.XNodeSet(sourceNodes));
      
      
      if(nParams > 0)
        vars.unlink(thisframe);
      xctxt.popSAXLocator();
      xctxt.popContextNodeList();
      transformer.popElemTemplateElement();
      xctxt.popCurrentExpressionNode();
      xctxt.popCurrentNode();
      sourceNodes.detach();
    }
  }

}
"
org.apache.xalan.xsltc.dom.UnionIterator,9,2,0,6,25,0,1,5,8,0.607142857,369,1.0,2,0.555555556,0.361111111,1,6,39.22222222,6,2.6667,2,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.BasisLibrary;


public final class UnionIterator extends NodeIteratorBase {
    
    final private DOM _dom;

    private final static class LookAheadIterator {
	public int node, markedNode;
	public final NodeIterator iterator;
		
	public LookAheadIterator(NodeIterator iterator) {
	    this.iterator = iterator;
	}
		
	public int step() {
	    node = iterator.next();
	    return node;
	}

	public void setMark() {
	    markedNode = node;
	    iterator.setMark();
	}

	public void gotoMark() {
	    node = markedNode;
	    iterator.gotoMark();
	}

    } 

    private static final int InitSize = 8;
  
    private int            _heapSize = 0;
    private int            _size = InitSize;
    private LookAheadIterator[] _heap = new LookAheadIterator[InitSize];
    private int            _free = 0;
  
    
    
    private int _returnedLast;

    public UnionIterator(DOM dom) {
	_dom = dom;
    }

    public NodeIterator cloneIterator() {
	final LookAheadIterator[] heapCopy = 
	    new LookAheadIterator[_heap.length];
	try {
	    final UnionIterator clone = (UnionIterator)super.clone();
	    System.arraycopy(_heap, 0, heapCopy, 0, _heap.length);
	    clone.setRestartable(false);
	    clone._heap = heapCopy;
	    return clone.reset();
	} 
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public UnionIterator addIterator(NodeIterator iterator) {
	if (_free == _size) {
	    LookAheadIterator[] newArray = new LookAheadIterator[_size *= 2];
	    System.arraycopy(_heap, 0, newArray, 0, _free);
	    _heap = newArray;
	}
	_heapSize++;
	_heap[_free++] = new LookAheadIterator(iterator);
	return this;
    }
  
    public int next() {
	while (_heapSize > 0) {
	    final int smallest = _heap[0].node;
	    if (smallest == END) { 
		if (_heapSize > 1) {
		    
		    final LookAheadIterator temp = _heap[0];
		    _heap[0] = _heap[--_heapSize];
		    _heap[_heapSize] = temp;
		}
		else {
		    return END;
		}
	    }
	    else if (smallest == _returnedLast) {	
		_heap[0].step(); 
	    }
	    else {
		_heap[0].step(); 
		heapify(0);
		return returnNode(_returnedLast = smallest);
	    }
	    
	    heapify(0);
	}
	return END;
    }
  
    public NodeIterator setStartNode(int node) {
	if (_isRestartable) {
	    _startNode = node;
	    for (int i = 0; i < _free; i++) {
		_heap[i].iterator.setStartNode(node);
		_heap[i].step();	
	    }
	    
	    for (int i = (_heapSize = _free)/2; i >= 0; i--) {
		heapify(i);
	    }
	    _returnedLast = END;
	    return resetPosition();
	}
	return this;
    }
	
    private void heapify(int i) {
	for (int r, l, smallest;;) {
	    r = (i + 1) << 1; l = r - 1;
	    smallest = l < _heapSize 
		&& _dom.lessThan(_heap[l].node, _heap[i].node) ? l : i;
	    if (r < _heapSize && _dom.lessThan(_heap[r].node,
					       _heap[smallest].node)) {
		smallest = r;
	    }
	    if (smallest != i) {
		final LookAheadIterator temp = _heap[smallest];
		_heap[smallest] = _heap[i];
		_heap[i] = temp;
		i = smallest;
	    }
	    else
		break;
	}
    }

    public void setMark() {
	for (int i = 0; i < _free; i++) {
	    _heap[i].setMark();
	}
    }

    public void gotoMark() {
	for (int i = 0; i < _free; i++) {
	    _heap[i].gotoMark();
	}
    }

    public NodeIterator reset() {
	super.reset();
	for (int i = 0; i < _free; i++) {
	    _heap[i].iterator.reset();
	}
	return resetPosition();
    }

}
"
org.apache.xml.dtm.ref.dom2dtm.DOM2DTM,38,4,0,19,117,581,1,19,28,0.86977887,1628,0.545454545,1,0.717557252,0.142857143,2,18,41.55263158,42,4.6316,1,"
package org.apache.xml.dtm.ref.dom2dtm;

import org.apache.xml.dtm.ref.*;
import org.apache.xml.dtm.*;
import org.apache.xml.utils.SuballocatedIntVector;
import org.apache.xml.utils.IntStack;
import org.apache.xml.utils.BoolStack;
import org.apache.xml.utils.StringBufferPool;
import org.apache.xml.utils.FastStringBuffer;
import org.apache.xml.utils.TreeWalker;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.XMLCharacterRecognizer;

import org.w3c.dom.*;

import java.util.Vector;

import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.SourceLocator;
import org.xml.sax.ContentHandler;

import org.apache.xml.utils.NodeVector;

import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.res.XSLMessages;


public class DOM2DTM extends DTMDefaultBaseIterators
{
  static final boolean JJK_DEBUG=false;
  static final boolean JJK_NEWCODE=true;
  
  
  static final String NAMESPACE_DECL_NS=""http:
  
  
  transient private Node m_pos;
  
  private int m_last_parent=0;
  
  private int m_last_kid=NULL;

  
  transient private Node m_root;

  
  boolean m_processedFirstElement=false;
        
  
  transient private boolean m_nodesAreProcessed;

  
  protected Vector m_nodes = new Vector();

  
  public DOM2DTM(DTMManager mgr, DOMSource domSource, 
                 int dtmIdentity, DTMWSFilter whiteSpaceFilter,
                 XMLStringFactory xstringfactory,
                 boolean doIndexing)
  {
    super(mgr, domSource, dtmIdentity, whiteSpaceFilter, 
          xstringfactory, doIndexing);

    
    m_pos=m_root = domSource.getNode();
    
    m_last_parent=m_last_kid=NULL;
    m_last_kid=addNode(m_root, m_last_parent,m_last_kid, NULL);

    
    
    
    
    
    
    
		
		
		
    if(ELEMENT_NODE == m_root.getNodeType())
    {
      NamedNodeMap attrs=m_root.getAttributes();
      int attrsize=(attrs==null) ? 0 : attrs.getLength();
      if(attrsize>0)
      {
        int attrIndex=NULL; 
        for(int i=0;i<attrsize;++i)
        {
          
          
          
          attrIndex=addNode(attrs.item(i),0,attrIndex,NULL);
          m_firstch.setElementAt(DTM.NULL,attrIndex);
        }
        
        
        m_nextsib.setElementAt(DTM.NULL,attrIndex);

        
      } 
    } 

    
    m_nodesAreProcessed = false;
  }

  
  protected int addNode(Node node, int parentIndex,
                        int previousSibling, int forceNodeType)
  {
    int nodeIndex = m_nodes.size();

    
    if(m_dtmIdent.size() == (nodeIndex>>>DTMManager.IDENT_DTM_NODE_BITS))
    {
      try
      {
        if(m_mgr==null)
          throw new ClassCastException();
                                
                                
        DTMManagerDefault mgrD=(DTMManagerDefault)m_mgr;
        int id=mgrD.getFirstFreeDTMID();
        mgrD.addDTM(this,id,nodeIndex);
        m_dtmIdent.addElement(id<<DTMManager.IDENT_DTM_NODE_BITS);
      }
      catch(ClassCastException e)
      {
        
        
        
        error(XSLMessages.createMessage(XSLTErrorResources.ER_NO_DTMIDS_AVAIL, null));
      }
    }

    m_size++;
    
    
    int type;
    if(NULL==forceNodeType)
        type = node.getNodeType();
    else
        type=forceNodeType;
        
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    if (Node.ATTRIBUTE_NODE == type)
    {
      String name = node.getNodeName();

      if (name.startsWith(""xmlns:"") || name.equals(""xmlns""))
      {
        type = DTM.NAMESPACE_NODE;
      }
    }
    
    m_nodes.addElement(node);
    
    m_firstch.setElementAt(NOTPROCESSED,nodeIndex);
    m_nextsib.setElementAt(NOTPROCESSED,nodeIndex);
    m_prevsib.setElementAt(previousSibling,nodeIndex);
    m_parent.setElementAt(parentIndex,nodeIndex);
    
    if(DTM.NULL != parentIndex && 
       type != DTM.ATTRIBUTE_NODE && 
       type != DTM.NAMESPACE_NODE)
    {
      
      if(NOTPROCESSED == m_firstch.elementAt(parentIndex))
        m_firstch.setElementAt(nodeIndex,parentIndex);
    }
    
    String nsURI = node.getNamespaceURI();

    
    
    
    String localName =  (type == Node.PROCESSING_INSTRUCTION_NODE) ? 
                         node.getNodeName() :
                         node.getLocalName();
                         
    
    if(((type == Node.ELEMENT_NODE) || (type == Node.ATTRIBUTE_NODE)) 
        && null == localName)
      localName = node.getNodeName(); 
      
    ExpandedNameTable exnt = m_expandedNameTable;

    
    
    
    
    
    
    
    
    if(node.getLocalName()==null &&
       (type==Node.ELEMENT_NODE || type==Node.ATTRIBUTE_NODE))
      {
        
      }
    
    int expandedNameID = (null != localName) 
       ? exnt.getExpandedTypeID(nsURI, localName, type) :
         exnt.getExpandedTypeID(type);

    m_exptype.setElementAt(expandedNameID,nodeIndex);
    
    indexNode(expandedNameID, nodeIndex);

    if (DTM.NULL != previousSibling)
      m_nextsib.setElementAt(nodeIndex,previousSibling);

    
    
    if (type == DTM.NAMESPACE_NODE)
        declareNamespaceInContext(parentIndex,nodeIndex);

    return nodeIndex;
  }
  
  
  protected int getNumberOfNodes()
  {
    return m_nodes.size();
  }
  
 
  protected boolean nextNode()
  {
    
    
    
    
    
    if (m_nodesAreProcessed)
      return false;
        
    
    
    Node pos=m_pos; 
    Node next=null;
    int nexttype=NULL;

    
    do
      {
        
        if (pos.hasChildNodes()) 
          {
            next = pos.getFirstChild();

            
            
            if(next!=null && DOCUMENT_TYPE_NODE==next.getNodeType())
              next=next.getNextSibling();

            
            
            if(ENTITY_REFERENCE_NODE!=pos.getNodeType())
              {
                m_last_parent=m_last_kid;
                m_last_kid=NULL;
                
                if(null != m_wsfilter)
                {
                  short wsv =
                    m_wsfilter.getShouldStripSpace(makeNodeHandle(m_last_parent),this);
                  boolean shouldStrip = (DTMWSFilter.INHERIT == wsv) 
                    ? getShouldStripWhitespace() 
                    : (DTMWSFilter.STRIP == wsv);
                  pushShouldStripWhitespace(shouldStrip);
                } 
              }
          }

        
        else 
          {
            if(m_last_kid!=NULL)
              {
                
                
                if(m_firstch.elementAt(m_last_kid)==NOTPROCESSED)
                  m_firstch.setElementAt(NULL,m_last_kid);
              }
                        
            while(m_last_parent != NULL)
              {
                
                
                next = pos.getNextSibling();
                if(next!=null && DOCUMENT_TYPE_NODE==next.getNodeType())
                  next=next.getNextSibling();

                if(next!=null)
                  break; 
                
                
                pos=pos.getParentNode();
                if(pos==null)
                  {
                    
                    if(JJK_DEBUG)
                      {
                        System.out.println(""***** DOM2DTM Pop Control Flow problem"");
                        for(;;); 
                      }
                  }
                
                
                
                
                if(pos!=null && ENTITY_REFERENCE_NODE == pos.getNodeType())
                  {
                    
                    if(JJK_DEBUG)
                      System.out.println(""***** DOM2DTM popping EntRef"");
                  }
                else
                  {
                    popShouldStripWhitespace();
                    
                    if(m_last_kid==NULL)
                      m_firstch.setElementAt(NULL,m_last_parent); 
                    else
                      m_nextsib.setElementAt(NULL,m_last_kid); 
                    m_last_parent=m_parent.elementAt(m_last_kid=m_last_parent);
                  }
              }
            if(m_last_parent==NULL)
              next=null;
          }
                
        if(next!=null)
          nexttype=next.getNodeType();
                
        
        
        
        
        
        if (ENTITY_REFERENCE_NODE == nexttype)
          pos=next;
      }
    while (ENTITY_REFERENCE_NODE == nexttype); 
        
    
    if(next==null)
      {
        m_nextsib.setElementAt(NULL,0);
        m_nodesAreProcessed = true;
        m_pos=null;
                
        if(JJK_DEBUG)
          {
            System.out.println(""***** DOM2DTM Crosscheck:"");
            for(int i=0;i<m_nodes.size();++i)
              System.out.println(i+"":	""+m_firstch.elementAt(i)+""	""+m_nextsib.elementAt(i));
          }
                
        return false;
      }

    
    
    
    
    
    
    
    
    
    
    
    
    
    
        
    boolean suppressNode=false;
    Node lastTextNode=null;

    nexttype=next.getNodeType();
        
    
    if(TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype)
      {
        
        suppressNode=((null != m_wsfilter) && getShouldStripWhitespace());

        
        
        Node n=next;
        while(n!=null)
          {
            lastTextNode=n;
            
            if(TEXT_NODE == n.getNodeType())
              nexttype=TEXT_NODE;
            
            
            suppressNode &=
              XMLCharacterRecognizer.isWhiteSpace(n.getNodeValue());
                        
            n=logicalNextDOMTextNode(n);
          }
      }
        
    
    
    
    
    
    else if(PROCESSING_INSTRUCTION_NODE==nexttype)
      {
        suppressNode = (pos.getNodeName().toLowerCase().equals(""xml""));
      }
        
        
    if(!suppressNode)
      {
        
        
        
        int nextindex=addNode(next,m_last_parent,m_last_kid,
			      nexttype);
	
        m_last_kid=nextindex;

        if(ELEMENT_NODE == nexttype)
          {
            int attrIndex=NULL; 
            
            
            NamedNodeMap attrs=next.getAttributes();
            int attrsize=(attrs==null) ? 0 : attrs.getLength();
            if(attrsize>0)
              {
                for(int i=0;i<attrsize;++i)
                  {
                    
                    
                    
                    attrIndex=addNode(attrs.item(i),
                                      nextindex,attrIndex,NULL);
                    m_firstch.setElementAt(DTM.NULL,attrIndex);

                    
                    
		    
		    
		    
		    
		    
		    
		    
                    if(!m_processedFirstElement
                       && ""xmlns:xml"".equals(attrs.item(i).getNodeName()))
                      m_processedFirstElement=true; 
                  }
                
                
              } 
            if(!m_processedFirstElement)
            {
              
              
              
              
              
              
              attrIndex=addNode(new DOM2DTMdefaultNamespaceDeclarationNode(
																	(Element)next,""xml"",NAMESPACE_DECL_NS,
																	makeNodeHandle(((attrIndex==NULL)?nextindex:attrIndex)+1)
																	),
                                nextindex,attrIndex,NULL);      
              m_firstch.setElementAt(DTM.NULL,attrIndex);
              m_processedFirstElement=true;
            }
            if(attrIndex!=NULL)
              m_nextsib.setElementAt(DTM.NULL,attrIndex);
          } 
      } 

    
    if(TEXT_NODE == nexttype || CDATA_SECTION_NODE == nexttype)
      {
        
                
        next=lastTextNode;      
      }
        
    
    m_pos=next;
    return true;
  }  


  
  public Node getNode(int nodeHandle)
  {

    int identity = makeNodeIdentity(nodeHandle);

    return (Node) m_nodes.elementAt(identity);
  }

  
  protected Node lookupNode(int nodeIdentity)
  {
    return (Node) m_nodes.elementAt(nodeIdentity);
  }

  
  protected int getNextNodeIdentity(int identity)
  {

    identity += 1;

    if (identity >= m_nodes.size())
    {
      if (!nextNode())
        identity = DTM.NULL;
    }

    return identity;
  }

  
  private int getHandleFromNode(Node node)
  {
    if (null != node)
    {
      int len = m_nodes.size();        
      boolean isMore;
      int i = 0;
      do
      {          
        for (; i < len; i++)
        {
          if (m_nodes.elementAt(i) == node)
            return makeNodeHandle(i);
        }

        isMore = nextNode();
  
        len = m_nodes.size();
            
      } 
      while(isMore || i < len);
    }
    
    return DTM.NULL;
  }

  
  public int getHandleOfNode(Node node)
  {
    if (null != node)
    {
      
      
      
      if((m_root==node) ||
         (m_root.getNodeType()==DOCUMENT_NODE &&
          m_root==node.getOwnerDocument()) ||
         (m_root.getNodeType()!=DOCUMENT_NODE &&
          m_root.getOwnerDocument()==node.getOwnerDocument())
         )
        {
          
          
          
          
          
          for(Node cursor=node;
              cursor!=null;
              cursor=
                (cursor.getNodeType()!=ATTRIBUTE_NODE)
                ? cursor.getParentNode()
                : ((org.w3c.dom.Attr)cursor).getOwnerElement())
            {
              if(cursor==m_root)
                
                return getHandleFromNode(node); 
            } 
        } 
    } 

    return DTM.NULL;
  }

  
  public int getAttributeNode(int nodeHandle, String namespaceURI,
                              String name)
  {

    
    if (null == namespaceURI)
      namespaceURI = """";

    int type = getNodeType(nodeHandle);

    if (DTM.ELEMENT_NODE == type)
    {

      
      int identity = makeNodeIdentity(nodeHandle);

      while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
      {
        
        type = _type(identity);

				
				
				
				
				
				
				
        if (type == DTM.ATTRIBUTE_NODE || type==DTM.NAMESPACE_NODE)
        {
          Node node = lookupNode(identity);
          String nodeuri = node.getNamespaceURI();

          if (null == nodeuri)
            nodeuri = """";

          String nodelocalname = node.getLocalName();

          if (nodeuri.equals(namespaceURI) && name.equals(nodelocalname))
            return makeNodeHandle(identity);
        }
				
        else 
        {
          break;
        }
      }
    }

    return DTM.NULL;
  }

  
  public XMLString getStringValue(int nodeHandle)
  {

    int type = getNodeType(nodeHandle);
    Node node = getNode(nodeHandle);
    
    
    if(DTM.ELEMENT_NODE == type || DTM.DOCUMENT_NODE == type 
    || DTM.DOCUMENT_FRAGMENT_NODE == type)
    {
      FastStringBuffer buf = StringBufferPool.get();
      String s;
  
      try
      {
        getNodeData(node, buf);
  
        s = (buf.length() > 0) ? buf.toString() : """";
      }
      finally
      {
        StringBufferPool.free(buf);
      }
  
      return m_xstrf.newstr( s );
    }
    else if(TEXT_NODE == type || CDATA_SECTION_NODE == type)
    {
      
      
      
      
      
      
      
      FastStringBuffer buf = StringBufferPool.get();
      while(node!=null)
      {
        buf.append(node.getNodeValue());
        node=logicalNextDOMTextNode(node);
      }
      String s=(buf.length() > 0) ? buf.toString() : """";
      StringBufferPool.free(buf);
      return m_xstrf.newstr( s );
    }
    else
      return m_xstrf.newstr( node.getNodeValue() );
  }
  
  
  protected static void getNodeData(Node node, FastStringBuffer buf)
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_FRAGMENT_NODE :
    case Node.DOCUMENT_NODE :
    case Node.ELEMENT_NODE :
    {
      for (Node child = node.getFirstChild(); null != child;
              child = child.getNextSibling())
      {
        getNodeData(child, buf);
      }
    }
    break;
    case Node.TEXT_NODE :
    case Node.CDATA_SECTION_NODE :
    case Node.ATTRIBUTE_NODE :	
      buf.append(node.getNodeValue());
      break;
    case Node.PROCESSING_INSTRUCTION_NODE :
      
      break;
    default :
      
      break;
    }
  }

  
  public String getNodeName(int nodeHandle)
  {

    Node node = getNode(nodeHandle);

    
    return node.getNodeName();
  }

  
  public String getNodeNameX(int nodeHandle)
  {

    String name;
    short type = getNodeType(nodeHandle);

    switch (type)
    {
    case DTM.NAMESPACE_NODE :
    {
      Node node = getNode(nodeHandle);

      
      name = node.getNodeName();
      if(name.startsWith(""xmlns:""))
      {
        name = QName.getLocalPart(name);
      }
      else if(name.equals(""xmlns""))
      {
        name = """";
      }
    }
    break;
    case DTM.ATTRIBUTE_NODE :
    case DTM.ELEMENT_NODE :
    case DTM.ENTITY_REFERENCE_NODE :
    case DTM.PROCESSING_INSTRUCTION_NODE :
    {
      Node node = getNode(nodeHandle);

      
      name = node.getNodeName();
    }
    break;
    default :
      name = """";
    }

    return name;
  }

  
  public String getLocalName(int nodeHandle)
  {
    if(JJK_NEWCODE)
    {
      int id=makeNodeIdentity(nodeHandle);
      if(NULL==id) return null;
      Node newnode=(Node)m_nodes.elementAt(id);
      String newname=newnode.getLocalName();
      if (null == newname)
      {
	
	String qname = newnode.getNodeName();
	if('#'==newnode.getNodeName().charAt(0))
	{
	  
	  
	  newname="""";
	}
	else
	{
	  int index = qname.indexOf(':');
	  newname = (index < 0) ? qname : qname.substring(index + 1);
	}
      }
      return newname;
    }
    else
    {
      String name;
      short type = getNodeType(nodeHandle);
      switch (type)
      {
      case DTM.ATTRIBUTE_NODE :
      case DTM.ELEMENT_NODE :
      case DTM.ENTITY_REFERENCE_NODE :
      case DTM.NAMESPACE_NODE :
      case DTM.PROCESSING_INSTRUCTION_NODE :
	{
	  Node node = getNode(nodeHandle);
	  
	  
	  name = node.getLocalName();
	  
	  if (null == name)
	  {
	    String qname = node.getNodeName();
	    int index = qname.indexOf(':');
	    
	    name = (index < 0) ? qname : qname.substring(index + 1);
	  }
	}
	break;
      default :
	name = """";
      }
      return name;
    }
  }

  
  public String getPrefix(int nodeHandle)
  {

    String prefix;
    short type = getNodeType(nodeHandle);

    switch (type)
    {
    case DTM.NAMESPACE_NODE :
    {
      Node node = getNode(nodeHandle);

      
      String qname = node.getNodeName();
      int index = qname.indexOf(':');

      prefix = (index < 0) ? """" : qname.substring(index + 1);
    }
    break;
    case DTM.ATTRIBUTE_NODE :
    case DTM.ELEMENT_NODE :
    {
      Node node = getNode(nodeHandle);

      
      String qname = node.getNodeName();
      int index = qname.indexOf(':');

      prefix = (index < 0) ? """" : qname.substring(0, index);
    }
    break;
    default :
      prefix = """";
    }

    return prefix;
  }

  
  public String getNamespaceURI(int nodeHandle)
  {
    if(JJK_NEWCODE)
    {
      int id=makeNodeIdentity(nodeHandle);
      if(id==NULL) return null;
      Node node=(Node)m_nodes.elementAt(id);
      return node.getNamespaceURI();
    }
    else
    {
      String nsuri;
      short type = getNodeType(nodeHandle);
      
      switch (type)
      {
      case DTM.ATTRIBUTE_NODE :
      case DTM.ELEMENT_NODE :
      case DTM.ENTITY_REFERENCE_NODE :
      case DTM.NAMESPACE_NODE :
      case DTM.PROCESSING_INSTRUCTION_NODE :
	{
	  Node node = getNode(nodeHandle);
	  
	  
	  nsuri = node.getNamespaceURI();
	  
	  
	}
	break;
      default :
	nsuri = null;
      }

      return nsuri;
    }
    
  }
  
  
  private Node logicalNextDOMTextNode(Node n)
  {
        Node p=n.getNextSibling();
        if(p==null)
        {
                
                for(n=n.getParentNode();
                        n!=null && ENTITY_REFERENCE_NODE == n.getNodeType();
                        n=n.getParentNode())
                {
                        p=n.getNextSibling();
                        if(p!=null)
                                break;
                }
        }
        n=p;
        while(n!=null && ENTITY_REFERENCE_NODE == n.getNodeType())
        {
                
                if(n.hasChildNodes())
                        n=n.getFirstChild();
                else
                        n=n.getNextSibling();
        }
        if(n!=null)
        {
                
                int ntype=n.getNodeType();
                if(TEXT_NODE != ntype && CDATA_SECTION_NODE != ntype)
                        n=null;
        }
        return n;
  }

  
  public String getNodeValue(int nodeHandle)
  {
    
    
    
    int type = _exptype(makeNodeIdentity(nodeHandle));
    type=(NULL != type) ? getNodeType(nodeHandle) : NULL;
    
    if(TEXT_NODE!=type && CDATA_SECTION_NODE!=type)
      return getNode(nodeHandle).getNodeValue();
    
    
    
    
    
    
    
    
    Node node = getNode(nodeHandle);
    Node n=logicalNextDOMTextNode(node);
    if(n==null)
      return node.getNodeValue();
    
    FastStringBuffer buf = StringBufferPool.get();
        buf.append(node.getNodeValue());
    while(n!=null)
    {
      buf.append(n.getNodeValue());
      n=logicalNextDOMTextNode(n);
    }
    String s = (buf.length() > 0) ? buf.toString() : """";
    StringBufferPool.free(buf);
    return s;
  }

  
  public String getDocumentTypeDeclarationSystemIdentifier()
  {

    Document doc;

    if (m_root.getNodeType() == Node.DOCUMENT_NODE)
      doc = (Document) m_root;
    else
      doc = m_root.getOwnerDocument();

    if (null != doc)
    {
      DocumentType dtd = doc.getDoctype();

      if (null != dtd)
      {
        return dtd.getSystemId();
      }
    }

    return null;
  }

  
  public String getDocumentTypeDeclarationPublicIdentifier()
  {

    Document doc;

    if (m_root.getNodeType() == Node.DOCUMENT_NODE)
      doc = (Document) m_root;
    else
      doc = m_root.getOwnerDocument();

    if (null != doc)
    {
      DocumentType dtd = doc.getDoctype();

      if (null != dtd)
      {
        return dtd.getPublicId();
      }
    }

    return null;
  }

  
  public int getElementById(String elementId)
  {

    Document doc = (m_root.getNodeType() == Node.DOCUMENT_NODE) 
        ? (Document) m_root : m_root.getOwnerDocument();
        
    if(null != doc)
    {
      Node elem = doc.getElementById(elementId);
      if(null != elem)
      {
        int elemHandle = getHandleFromNode(elem);
        
        if(DTM.NULL == elemHandle)
        {
          int identity = m_nodes.size()-1;
          while (DTM.NULL != (identity = getNextNodeIdentity(identity)))
          {
            Node node = getNode(identity);
            if(node == elem)
            {
              elemHandle = getHandleFromNode(elem);
              break;
            }
           }
        }
        
        return elemHandle;
      }
    
    }
    return DTM.NULL;
  }

  
  public String getUnparsedEntityURI(String name)
  {

    String url = """";
    Document doc = (m_root.getNodeType() == Node.DOCUMENT_NODE) 
        ? (Document) m_root : m_root.getOwnerDocument();

    if (null != doc)
    {
      DocumentType doctype = doc.getDoctype();
  
      if (null != doctype)
      {
        NamedNodeMap entities = doctype.getEntities();
        if(null == entities)
          return url;
        Entity entity = (Entity) entities.getNamedItem(name);
        if(null == entity)
          return url;
        
        String notationName = entity.getNotationName();
  
        if (null != notationName)  
        {
          
          
          
          
          
          
          
          
          
          url = entity.getSystemId();
  
          if (null == url)
          {
            url = entity.getPublicId();
          }
          else
          {
            
            
          }        
        }
      }
    }

    return url;
  }

  
  public boolean isAttributeSpecified(int attributeHandle)
  {
    int type = getNodeType(attributeHandle);

    if (DTM.ATTRIBUTE_NODE == type)
    {
      Attr attr = (Attr)getNode(attributeHandle);
      return attr.getSpecified();
    }
    return false;
  }

  
  public void setIncrementalSAXSource(IncrementalSAXSource source)
  {
  }
  
  
  public org.xml.sax.ContentHandler getContentHandler()
  {
      return null;
  }
  
  
  public org.xml.sax.ext.LexicalHandler getLexicalHandler()
  {

    return null;
  }

  
  
  public org.xml.sax.EntityResolver getEntityResolver()
  {

    return null;
  }
  
  
  public org.xml.sax.DTDHandler getDTDHandler()
  {

    return null;
  }

  
  public org.xml.sax.ErrorHandler getErrorHandler()
  {

    return null;
  }
  
  
  public org.xml.sax.ext.DeclHandler getDeclHandler()
  {

    return null;
  }  

  
  public boolean needsTwoThreads()
  {
    return false;
  }

  
  
  
  private static boolean isSpace(char ch)
  {
    return XMLCharacterRecognizer.isWhiteSpace(ch);  
  }

  
  public void dispatchCharactersEvents(
          int nodeHandle, org.xml.sax.ContentHandler ch, 
          boolean normalize)
            throws org.xml.sax.SAXException
  {
    if(normalize)
    {
      XMLString str = getStringValue(nodeHandle);
      str = str.fixWhiteSpace(true, true, false);
      str.dispatchCharactersEvents(ch);
    }
    else
    {
      int type = getNodeType(nodeHandle);
      Node node = getNode(nodeHandle);
      dispatchNodeData(node, ch, 0);
          
          
          if(TEXT_NODE == type || CDATA_SECTION_NODE == type)
          {
                  while( null != (node=logicalNextDOMTextNode(node)) )
                  {
                      dispatchNodeData(node, ch, 0);
                  }
          }
    }
  }
  
  
  protected static void dispatchNodeData(Node node, 
                                         org.xml.sax.ContentHandler ch, 
                                         int depth)
            throws org.xml.sax.SAXException
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_FRAGMENT_NODE :
    case Node.DOCUMENT_NODE :
    case Node.ELEMENT_NODE :
    {
      for (Node child = node.getFirstChild(); null != child;
              child = child.getNextSibling())
      {
        dispatchNodeData(child, ch, depth+1);
      }
    }
    break;
    case Node.PROCESSING_INSTRUCTION_NODE : 
    case Node.COMMENT_NODE :
      if(0 != depth)
        break;
        
        
    case Node.TEXT_NODE :
    case Node.CDATA_SECTION_NODE :
    case Node.ATTRIBUTE_NODE :
      String str = node.getNodeValue();
      if(ch instanceof CharacterNodeHandler)
      {
        ((CharacterNodeHandler)ch).characters(node);
      }
      else
      {
        ch.characters(str.toCharArray(), 0, str.length());
      }
      break;



    default :
      
      break;
    }
  }
  
  TreeWalker m_walker = new TreeWalker(null);
  
  
  public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
          throws org.xml.sax.SAXException
  {
    TreeWalker treeWalker = m_walker;
    ContentHandler prevCH = treeWalker.getContentHandler();
    
    if(null != prevCH)
    {
      treeWalker = new TreeWalker(null);
    }
    treeWalker.setContentHandler(ch);
    
    try
    {
      Node node = getNode(nodeHandle);
      treeWalker.traverse(node);
    }
    finally
    {
      treeWalker.setContentHandler(null);
    }
  }
  
  public interface CharacterNodeHandler
  {
    public void characters(Node node)
            throws org.xml.sax.SAXException;
  }

  
  public void setProperty(String property, Object value)
  {
  }
  
  
  public SourceLocator getSourceLocatorFor(int node)
  {
    return null;
  }
}


"
org.apache.xml.dtm.ref.DTMDocumentImpl,110,1,0,13,149,5191,0,13,96,0.943807339,1853,0.666666667,8,0.0,0.11983945,0,0,15.62727273,10,1.5364,0,"
package org.apache.xml.dtm.ref;

import org.apache.xml.dtm.*;
import java.util.Hashtable;

import java.util.Vector;

import javax.xml.transform.SourceLocator;

import org.apache.xml.dtm.ref.ChunkedIntArray;
import org.apache.xml.utils.FastStringBuffer;

import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.Attributes;
import org.xml.sax.ext.LexicalHandler;

import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;


public class DTMDocumentImpl
implements DTM, org.xml.sax.ContentHandler, org.xml.sax.ext.LexicalHandler
{

        
        protected static final byte DOCHANDLE_SHIFT = 22;
        
        
        protected static final int NODEHANDLE_MASK = (1 << (DOCHANDLE_SHIFT + 1)) - 1;
        
        
        protected static final int DOCHANDLE_MASK = -1 - NODEHANDLE_MASK;

        int m_docHandle = NULL;		 
        int m_docElement = NULL;	 

        
        int currentParent = 0;			
        int previousSibling = 0;		
        protected int m_currentNode = -1;		

        
        
        

        private boolean previousSiblingWasParent = false;
        
        int gotslot[] = new int[4];

        
        private boolean done = false;
        boolean m_isError = false;

        private final boolean DEBUG = false;

        
        protected String m_documentBaseURI;

  
  private IncrementalSAXSource m_incrSAXSource=null;


        

        
        
        
        
        ChunkedIntArray nodes = new ChunkedIntArray(4);

        
        
        private FastStringBuffer m_char = new FastStringBuffer();
        
        
        private int m_char_current_start=0;

        
        
        
        
        
        private DTMStringPool m_localNames = new DTMStringPool();
        private DTMStringPool m_nsNames = new DTMStringPool();
        private DTMStringPool m_prefixNames = new DTMStringPool();

        
        
        
        
        
        
        private ExpandedNameTable m_expandedNames=
                new ExpandedNameTable(m_localNames,m_nsNames);

        private XMLStringFactory m_xsf;


        
        public DTMDocumentImpl(DTMManager mgr, int documentNumber,
                               DTMWSFilter whiteSpaceFilter,
                               XMLStringFactory xstringfactory){
                initDocument(documentNumber);	 
                m_xsf = xstringfactory;
        }

  
  public void setIncrementalSAXSource(IncrementalSAXSource source)
  {
    m_incrSAXSource=source;

    
    source.setContentHandler(this);
    source.setLexicalHandler(this);

    
    
    
    
    
  }

        
        private final int appendNode(int w0, int w1, int w2, int w3)
        {
                
                int slotnumber = nodes.appendSlot(w0, w1, w2, w3);

                if (DEBUG) System.out.println(slotnumber+"": ""+w0+"" ""+w1+"" ""+w2+"" ""+w3);

                if (previousSiblingWasParent)
                        nodes.writeEntry(previousSibling,2,slotnumber);

                previousSiblingWasParent = false;	

                return slotnumber;
        }

        

        
        public void setFeature(String featureId, boolean state) {};

        
        public void setLocalNameTable(DTMStringPool poolRef) {
                m_localNames = poolRef;
        }

        
        public DTMStringPool getLocalNameTable() {
                 return m_localNames;
         }

        
        public void setNsNameTable(DTMStringPool poolRef) {
                m_nsNames = poolRef;
        }

        
        public DTMStringPool getNsNameTable() {
                 return m_nsNames;
         }

        
        public void setPrefixNameTable(DTMStringPool poolRef) {
                m_prefixNames = poolRef;
        }

        
        public DTMStringPool getPrefixNameTable() {
                return m_prefixNames;
        }

         
         void setContentBuffer(FastStringBuffer buffer) {
                 m_char = buffer;
         }

         
         FastStringBuffer getContentBuffer() {
                 return m_char;
         }

  
  public org.xml.sax.ContentHandler getContentHandler()
  {
    if (m_incrSAXSource instanceof IncrementalSAXSource_Filter)
      return (ContentHandler) m_incrSAXSource;
    else
      return this;
  }

  
  public LexicalHandler getLexicalHandler()
  {

    if (m_incrSAXSource instanceof IncrementalSAXSource_Filter)
      return (LexicalHandler) m_incrSAXSource;
    else
      return this;
  }

  
  public org.xml.sax.EntityResolver getEntityResolver()
  {

    return null;
  }

  
  public org.xml.sax.DTDHandler getDTDHandler()
  {

    return null;
  }

  
  public org.xml.sax.ErrorHandler getErrorHandler()
  {

    return null;
  }

  
  public org.xml.sax.ext.DeclHandler getDeclHandler()
  {

    return null;
  }

  
  public boolean needsTwoThreads()
  {
    return null!=m_incrSAXSource;
  }

  
  
  
  

  public void characters(char[] ch, int start, int length)
       throws org.xml.sax.SAXException
  {
    
    
    
    m_char.append(ch,start,length);
  }

  
  private void processAccumulatedText()
  {
    int len=m_char.length();
    if(len!=m_char_current_start)
      {
        
        appendTextChild(m_char_current_start,len-m_char_current_start);
        m_char_current_start=len;
      }
  }
  public void endDocument()
       throws org.xml.sax.SAXException
  {
    
    
    appendEndDocument();
  }
  public void endElement(java.lang.String namespaceURI, java.lang.String localName,
      java.lang.String qName)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();
    
    
    appendEndElement();
  }
  public void endPrefixMapping(java.lang.String prefix)
       throws org.xml.sax.SAXException
  {
    
  }
  public void ignorableWhitespace(char[] ch, int start, int length)
       throws org.xml.sax.SAXException
  {
    
  }
  public void processingInstruction(java.lang.String target, java.lang.String data)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();
    
  }
  public void setDocumentLocator(Locator locator)
  {
    
  }
  public void skippedEntity(java.lang.String name)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();
    
  }
  public void startDocument()
       throws org.xml.sax.SAXException
  {
    appendStartDocument();
  }
  public void startElement(java.lang.String namespaceURI, java.lang.String localName,
      java.lang.String qName, Attributes atts)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();

    
    String prefix=null;
    int colon=qName.indexOf(':');
    if(colon>0)
      prefix=qName.substring(0,colon);

    
    System.out.println(""Prefix=""+prefix+"" index=""+m_prefixNames.stringToIndex(prefix));
    appendStartElement(m_nsNames.stringToIndex(namespaceURI),
                     m_localNames.stringToIndex(localName),
                     m_prefixNames.stringToIndex(prefix)); 

    
    
    
    int nAtts=(atts==null) ? 0 : atts.getLength();
    
    for(int i=nAtts-1;i>=0;--i)
      {
        qName=atts.getQName(i);
        if(qName.startsWith(""xmlns:"") || ""xmlns"".equals(qName))
          {
            prefix=null;
            colon=qName.indexOf(':');
            if(colon>0)
              {
                prefix=qName.substring(0,colon);
              }
            else
              {
                
                prefix=null; 
              }


            appendNSDeclaration(
                                    m_prefixNames.stringToIndex(prefix),
                                    m_nsNames.stringToIndex(atts.getValue(i)),
                                    atts.getType(i).equalsIgnoreCase(""ID""));
          }
      }

    for(int i=nAtts-1;i>=0;--i)
      {
        qName=atts.getQName(i);
        if(!(qName.startsWith(""xmlns:"") || ""xmlns"".equals(qName)))
          {
            
            
            
            prefix=null;
            colon=qName.indexOf(':');
            if(colon>0)
              {
                prefix=qName.substring(0,colon);
                localName=qName.substring(colon+1);
              }
            else
              {
                prefix=""""; 
                localName=qName;
              }


            m_char.append(atts.getValue(i)); 
            int contentEnd=m_char.length();

            if(!(""xmlns"".equals(prefix) || ""xmlns"".equals(qName)))
              appendAttribute(m_nsNames.stringToIndex(atts.getURI(i)),
                                  m_localNames.stringToIndex(localName),
                                  m_prefixNames.stringToIndex(prefix),
                                  atts.getType(i).equalsIgnoreCase(""ID""),
                                  m_char_current_start, contentEnd-m_char_current_start);
            m_char_current_start=contentEnd;
          }
      }
  }
  public void startPrefixMapping(java.lang.String prefix, java.lang.String uri)
       throws org.xml.sax.SAXException
  {
    
  }

  
  
  
  
  public void comment(char[] ch, int start, int length)
       throws org.xml.sax.SAXException
  {
    processAccumulatedText();

    m_char.append(ch,start,length); 
    appendComment(m_char_current_start,length);
    m_char_current_start+=length;
  }
  public void endCDATA()
       throws org.xml.sax.SAXException
  {
    
  }
  public void endDTD()
       throws org.xml.sax.SAXException
  {
    
  }
  public void endEntity(java.lang.String name)
       throws org.xml.sax.SAXException
  {
    
  }
  public void startCDATA()
       throws org.xml.sax.SAXException
  {
    
  }
  public void startDTD(java.lang.String name, java.lang.String publicId,
      java.lang.String systemId)
       throws org.xml.sax.SAXException
  {
    
  }
  public void startEntity(java.lang.String name)
       throws org.xml.sax.SAXException
  {
    
  }


  
  
  
  
  

        
        final void initDocument(int documentNumber)
        {
                
                m_docHandle = documentNumber<<DOCHANDLE_SHIFT;

                
                nodes.writeSlot(0,DOCUMENT_NODE,-1,-1,0);
                
                done = false;
        }


































































































































































































































































































































































        

        
        public boolean hasChildNodes(int nodeHandle) {
                return(getFirstChild(nodeHandle) != NULL);
        }

        
        public int getFirstChild(int nodeHandle) {

                
                nodeHandle &= NODEHANDLE_MASK;
                
                nodes.readSlot(nodeHandle, gotslot);

                
                short type = (short) (gotslot[0] & 0xFFFF);

                
                if ((type == ELEMENT_NODE) || (type == DOCUMENT_NODE) ||
                                (type == ENTITY_REFERENCE_NODE)) {

                        
                        
                        
                        
                        
                        

                        int kid = nodeHandle + 1;
                        nodes.readSlot(kid, gotslot);
                        while (ATTRIBUTE_NODE == (gotslot[0] & 0xFFFF)) {
                                
                                kid = gotslot[2];
                                
                                if (kid == NULL) return NULL;
                                nodes.readSlot(kid, gotslot);
                        }
                        
                        if (gotslot[1] == nodeHandle)
                        {
                          int firstChild = kid | m_docHandle;

                          return firstChild;
                        }
                }
                

                return NULL;
        }

        
        public int getLastChild(int nodeHandle) {
                
                nodeHandle &= NODEHANDLE_MASK;
                
                int lastChild = NULL;
                for (int nextkid = getFirstChild(nodeHandle); nextkid != NULL;
                                nextkid = getNextSibling(nextkid)) {
                        lastChild = nextkid;
                }
                return lastChild | m_docHandle;
        }

        
        public int getAttributeNode(int nodeHandle, String namespaceURI, String name) {
                int nsIndex = m_nsNames.stringToIndex(namespaceURI),
                                                                        nameIndex = m_localNames.stringToIndex(name);
                nodeHandle &= NODEHANDLE_MASK;
                nodes.readSlot(nodeHandle, gotslot);
                short type = (short) (gotslot[0] & 0xFFFF);
                
                if (type == ELEMENT_NODE)
                        nodeHandle++;
                
                while (type == ATTRIBUTE_NODE) {
                        if ((nsIndex == (gotslot[0] << 16)) && (gotslot[3] == nameIndex))
                                return nodeHandle | m_docHandle;
                        
                        nodeHandle = gotslot[2];
                        nodes.readSlot(nodeHandle, gotslot);
                }
                return NULL;
        }

        
        public int getFirstAttribute(int nodeHandle) {
                nodeHandle &= NODEHANDLE_MASK;

                
                
                
                

                
                if (ELEMENT_NODE != (nodes.readEntry(nodeHandle, 0) & 0xFFFF))
                        return NULL;
                
                nodeHandle++;
                return(ATTRIBUTE_NODE == (nodes.readEntry(nodeHandle, 0) & 0xFFFF)) ?
                nodeHandle | m_docHandle : NULL;
        }

        
        public int getFirstNamespaceNode(int nodeHandle, boolean inScope) {

                return NULL;
        }

        
        public int getNextSibling(int nodeHandle) {
                nodeHandle &= NODEHANDLE_MASK;
                
                if (nodeHandle == 0)
                        return NULL;

                short type = (short) (nodes.readEntry(nodeHandle, 0) & 0xFFFF);
                if ((type == ELEMENT_NODE) || (type == ATTRIBUTE_NODE) ||
                                (type == ENTITY_REFERENCE_NODE)) {
                        int nextSib = nodes.readEntry(nodeHandle, 2);
                        if (nextSib == NULL)
                                return NULL;
                        if (nextSib != 0)
                                return (m_docHandle | nextSib);
                        
                }
                
                int thisParent = nodes.readEntry(nodeHandle, 1);

                if (nodes.readEntry(++nodeHandle, 1) == thisParent)
                        return (m_docHandle | nodeHandle);

                return NULL;
        }

        
        public int getPreviousSibling(int nodeHandle) {
                nodeHandle &= NODEHANDLE_MASK;
                
                if (nodeHandle == 0)
                        return NULL;

                int parent = nodes.readEntry(nodeHandle, 1);
                int kid = NULL;
                for (int nextkid = getFirstChild(parent); nextkid != nodeHandle;
                                nextkid = getNextSibling(nextkid)) {
                        kid = nextkid;
                }
                return kid | m_docHandle;
        }

        
        public int getNextAttribute(int nodeHandle) {
                nodeHandle &= NODEHANDLE_MASK;
                nodes.readSlot(nodeHandle, gotslot);

                
                
                
                
                short type = (short) (gotslot[0] & 0xFFFF);

                if (type == ELEMENT_NODE) {
                        return getFirstAttribute(nodeHandle);
                } else if (type == ATTRIBUTE_NODE) {
                        if (gotslot[2] != NULL)
                                return (m_docHandle | gotslot[2]);
                }
                return NULL;
        }

        
        public int getNextNamespaceNode(int baseHandle,int namespaceHandle, boolean inScope) {
                
                return NULL;
        }

        
        public int getNextDescendant(int subtreeRootHandle, int nodeHandle) {
                subtreeRootHandle &= NODEHANDLE_MASK;
                nodeHandle &= NODEHANDLE_MASK;
                
                if (nodeHandle == 0)
                        return NULL;
                while (!m_isError) {
                        
                        if (done && (nodeHandle > nodes.slotsUsed()))
                                break;
                        if (nodeHandle > subtreeRootHandle) {
                                nodes.readSlot(nodeHandle+1, gotslot);
                                if (gotslot[2] != 0) {
                                        short type = (short) (gotslot[0] & 0xFFFF);
                                        if (type == ATTRIBUTE_NODE) {
                                                nodeHandle +=2;
                                        } else {
                                                int nextParentPos = gotslot[1];
                                                if (nextParentPos >= subtreeRootHandle)
                                                        return (m_docHandle | (nodeHandle+1));
                                                else
                                                        break;
                                        }
                                } else if (!done) {
                                        
                                } else
                                        break;
                        } else {
                                nodeHandle++;
                        }
                }
                
                return NULL;
        }

        
        public int getNextFollowing(int axisContextHandle, int nodeHandle) {
                
                return NULL;
        }

        
        public int getNextPreceding(int axisContextHandle, int nodeHandle) {
                
                nodeHandle &= NODEHANDLE_MASK;
                while (nodeHandle > 1) {
                        nodeHandle--;
                        if (ATTRIBUTE_NODE == (nodes.readEntry(nodeHandle, 0) & 0xFFFF))
                                continue;

                        
                        
                        

                        
                        
                        

                        return (m_docHandle | nodes.specialFind(axisContextHandle, nodeHandle));
                }
                return NULL;
        }

        
        public int getParent(int nodeHandle) {
                

                
                return (m_docHandle | nodes.readEntry(nodeHandle, 1));
        }

        
        public int getDocumentRoot() {
                return (m_docHandle | m_docElement);
        }

        
        public int getDocument() {
                return m_docHandle;
        }

        
        public int getOwnerDocument(int nodeHandle) {
                
                if ((nodeHandle & NODEHANDLE_MASK) == 0)
                        return NULL;
                return (nodeHandle & DOCHANDLE_MASK);
        }

        
        public int getDocumentRoot(int nodeHandle) {
                
                if ((nodeHandle & NODEHANDLE_MASK) == 0)
                        return NULL;
                return (nodeHandle & DOCHANDLE_MASK);
        }

        
        public XMLString getStringValue(int nodeHandle) {
        
        nodes.readSlot(nodeHandle, gotslot);
        int nodetype=gotslot[0] & 0xFF;
        String value=null;

        switch (nodetype) {
        case TEXT_NODE:
        case COMMENT_NODE:
        case CDATA_SECTION_NODE:
                value= m_char.getString(gotslot[2], gotslot[3]);
                break;
        case PROCESSING_INSTRUCTION_NODE:
        case ATTRIBUTE_NODE:
        case ELEMENT_NODE:
        case ENTITY_REFERENCE_NODE:
        default:
                break;
        }
        return m_xsf.newstr( value );

        }

        
        
        public int getStringValueChunkCount(int nodeHandle)
        {
                
                return 0;
        }

        
        
        public char[] getStringValueChunk(int nodeHandle, int chunkIndex,
                                                                                                                                                int[] startAndLen) {return new char[0];}

        
        public int getExpandedTypeID(int nodeHandle) {
           nodes.readSlot(nodeHandle, gotslot);
           String qName = m_localNames.indexToString(gotslot[3]);
           
           
           int colonpos = qName.indexOf("":"");
           String localName = qName.substring(colonpos+1);
           
           String namespace = m_nsNames.indexToString(gotslot[0] << 16);
           
           String expandedName = namespace + "":"" + localName;
           int expandedNameID = m_nsNames.stringToIndex(expandedName);

        return expandedNameID;
        }


        
        public int getExpandedTypeID(String namespace, String localName, int type) {
           
          
          
          
          
           String expandedName = namespace + "":"" + localName;
           int expandedNameID = m_nsNames.stringToIndex(expandedName);

           return expandedNameID;
        }


        
        public String getLocalNameFromExpandedNameID(int ExpandedNameID) {

           
           String expandedName = m_localNames.indexToString(ExpandedNameID);
           
           int colonpos = expandedName.indexOf("":"");
           String localName = expandedName.substring(colonpos+1);
           return localName;
        }


        
        public String getNamespaceFromExpandedNameID(int ExpandedNameID) {

           String expandedName = m_localNames.indexToString(ExpandedNameID);
           
           int colonpos = expandedName.indexOf("":"");
           String nsName = expandedName.substring(0, colonpos);

        return nsName;
        }


        
        static final String[] fixednames=
        {
                null,null,							
                null,""#text"",						
                ""#cdata_section"",null,	
                null,null,							
                ""#comment"",""#document"",	
                null,""#document-fragment"", 
                null};									

        
        public String getNodeName(int nodeHandle) {
                nodes.readSlot(nodeHandle, gotslot);
                short type = (short) (gotslot[0] & 0xFFFF);
                String name = fixednames[type];
                if (null == name) {
                  int i=gotslot[3];
                  System.out.println(""got i=""+i+"" ""+(i>>16)+""/""+(i&0xffff));

                  name=m_localNames.indexToString(i & 0xFFFF);
                  String prefix=m_prefixNames.indexToString(i >>16);
                  if(prefix!=null && prefix.length()>0)
                    name=prefix+"":""+name;
                }
                return name;
        }

        
        public String getNodeNameX(int nodeHandle) {return null;}

        
        public String getLocalName(int nodeHandle) {
                nodes.readSlot(nodeHandle, gotslot);
                short type = (short) (gotslot[0] & 0xFFFF);
                String name = """";
                if ((type==ELEMENT_NODE) || (type==ATTRIBUTE_NODE)) {
                  int i=gotslot[3];
                  name=m_localNames.indexToString(i & 0xFFFF);
                  if(name==null) name="""";
                }
                return name;
        }

        
        public String getPrefix(int nodeHandle) {
                nodes.readSlot(nodeHandle, gotslot);
                short type = (short) (gotslot[0] & 0xFFFF);
                String name = """";
                if((type==ELEMENT_NODE) || (type==ATTRIBUTE_NODE)) {
                  int i=gotslot[3];
                  name=m_prefixNames.indexToString(i >>16);
                  if(name==null) name="""";
                }
                return name;
        }

        
        public String getNamespaceURI(int nodeHandle) {return null;}

        
        public String getNodeValue(int nodeHandle)
        {
                nodes.readSlot(nodeHandle, gotslot);
                int nodetype=gotslot[0] & 0xFF;		
                String value=null;

                switch (nodetype) {			
                case ATTRIBUTE_NODE:
                        nodes.readSlot(nodeHandle+1, gotslot);
                case TEXT_NODE:
                case COMMENT_NODE:
                case CDATA_SECTION_NODE:
                        value=m_char.getString(gotslot[2], gotslot[3]);		
                        break;
                case PROCESSING_INSTRUCTION_NODE:
                case ELEMENT_NODE:
                case ENTITY_REFERENCE_NODE:
                default:
                        break;
                }
                return value;
        }

        
        public short getNodeType(int nodeHandle) {
                return(short) (nodes.readEntry(nodeHandle, 0) & 0xFFFF);
        }

        
        public short getLevel(int nodeHandle) {
                short count = 0;
                while (nodeHandle != 0) {
                        count++;
                        nodeHandle = nodes.readEntry(nodeHandle, 1);
                }
                return count;
        }

        

        
        public boolean isSupported(String feature, String version) {return false;}

        
        public String getDocumentBaseURI()
        {

          return m_documentBaseURI;
        }

        
        public void setDocumentBaseURI(String baseURI)
        {

          m_documentBaseURI = baseURI;
        }

        
        public String getDocumentSystemIdentifier(int nodeHandle) {return null;}

        
        public String getDocumentEncoding(int nodeHandle) {return null;}

        
        public String getDocumentStandalone(int nodeHandle) {return null;}

        
        public String getDocumentVersion(int documentHandle) {return null;}

        
        public boolean getDocumentAllDeclarationsProcessed() {return false;}

        
        public String getDocumentTypeDeclarationSystemIdentifier() {return null;}

        
        public String getDocumentTypeDeclarationPublicIdentifier() {return null;}

        
        public int getElementById(String elementId) {return 0;}

        
        public String getUnparsedEntityURI(String name) {return null;}


        

        
        public boolean supportsPreStripping() {return false;}

        
        public boolean isNodeAfter(int nodeHandle1, int nodeHandle2) {return false;}

        
        public boolean isCharacterElementContentWhitespace(int nodeHandle) {return false;}

        
        public boolean isDocumentAllDeclarationsProcessed(int documentHandle) {return false;}

        
        public boolean isAttributeSpecified(int attributeHandle) {return false;}

        

        
        public void dispatchCharactersEvents(
                                                                                                                                                        int nodeHandle, org.xml.sax.ContentHandler ch, boolean normalize)
        throws org.xml.sax.SAXException {}

        

        public void dispatchToEvents(int nodeHandle, org.xml.sax.ContentHandler ch)
        throws org.xml.sax.SAXException {}

        
        public org.w3c.dom.Node getNode(int nodeHandle)
        {
          return null;
        }

        
        
        
        

        
        public void appendChild(int newChild, boolean clone, boolean cloneDepth) {
                boolean sameDoc = ((newChild & DOCHANDLE_MASK) == m_docHandle);
                if (clone || !sameDoc) {

                } else {

                }
        }

        
        public void appendTextChild(String str) {
                
          
        }


  
  
  
  

  
  void appendTextChild(int m_char_current_start,int contentLength)
  {
    
    
    int w0 = TEXT_NODE;
    
    int w1 = currentParent;
    
    int w2 = m_char_current_start;
    
    int w3 = contentLength;

    int ourslot = appendNode(w0, w1, w2, w3);
    previousSibling = ourslot;
  }

  
  void appendComment(int m_char_current_start,int contentLength)
  {
    
    
    int w0 = COMMENT_NODE;
    
    int w1 = currentParent;
    
    int w2 = m_char_current_start;
    
    int w3 = contentLength;

    int ourslot = appendNode(w0, w1, w2, w3);
    previousSibling = ourslot;
  }


  
  void appendStartElement(int namespaceIndex,int localNameIndex, int prefixIndex)
  {
                
                
                
                

                
                int w0 = (namespaceIndex << 16) | ELEMENT_NODE;
                
                int w1 = currentParent;
                
                int w2 = 0;
                
                int w3 = localNameIndex | prefixIndex<<16;
                System.out.println(""set w3=""+w3+"" ""+(w3>>16)+""/""+(w3&0xffff));

                
                int ourslot = appendNode(w0, w1, w2, w3);
                currentParent = ourslot;
                previousSibling = 0;

                
                if (m_docElement == NULL)
                        m_docElement = ourslot;
  }

  
  void appendNSDeclaration(int prefixIndex, int namespaceIndex,
                           boolean isID)
  {
    
    
    
    

    
    

    

    final int namespaceForNamespaces=m_nsNames.stringToIndex(""http:

    
    int w0 = NAMESPACE_NODE | (m_nsNames.stringToIndex(""http:

    
    int w1 = currentParent;
    
    int w2 = 0;
    
    int w3 = namespaceIndex;
    
    int ourslot = appendNode(w0, w1, w2, w3);
    previousSibling = ourslot;	
    previousSiblingWasParent = false;
    return ;
  }

  
  void appendAttribute(int namespaceIndex, int localNameIndex, int prefixIndex,
                       boolean isID,
                       int m_char_current_start, int contentLength)
  {
    

    
    int w0 = ATTRIBUTE_NODE | namespaceIndex<<16;

    
    int w1 = currentParent;
    
    int w2 = 0;
    
    int w3 = localNameIndex | prefixIndex<<16;
    System.out.println(""set w3=""+w3+"" ""+(w3>>16)+""/""+(w3&0xffff));
    
    int ourslot = appendNode(w0, w1, w2, w3);
    previousSibling = ourslot;	

    

    
    w0 = TEXT_NODE;
    
    w1 = ourslot;
    
    w2 = m_char_current_start;
    
    w3 = contentLength;
    appendNode(w0, w1, w2, w3);

    
    previousSiblingWasParent = true;
    return ;
  }

  
  public DTMAxisTraverser getAxisTraverser(final int axis)
  {
    return null;
  }

  
  public DTMAxisIterator getAxisIterator(final int axis)
  {
    
    return null;
  }

  
  public DTMAxisIterator getTypedAxisIterator(final int axis, final int type)
  {
    
    return null;
  }


  
  void appendEndElement()
  {
    

    if (previousSiblingWasParent)
      nodes.writeEntry(previousSibling, 2, NULL);

    
    previousSibling = currentParent;
    nodes.readSlot(currentParent, gotslot);
    currentParent = gotslot[1] & 0xFFFF;

    
    
    previousSiblingWasParent = true;

    
    
  }

  
  void appendStartDocument()
  {

    
    
    m_docElement = NULL;	 
    initDocument(0);
  }

  
  void appendEndDocument()
  {
    done = true;
    
    
  }

  
  public void setProperty(String property, Object value)
  {
  }

  
  public SourceLocator getSourceLocatorFor(int node)
  {
    return null;
  }


  
   public void documentRegistration()
   {
   }

  
   public void documentRelease()
   {
   }


}
"
org.apache.xalan.xsltc.compiler.EqualityExpr,12,3,0,40,49,0,1,39,11,0.333333333,836,1.0,2,0.865853659,0.238095238,2,8,68.41666667,18,3.25,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.xalan.xsltc.runtime.Operators;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class EqualityExpr extends Expression implements Operators {
    private final int _op;
    private Expression _left;
    private Expression _right;
		
    public EqualityExpr(int op, Expression left, Expression right) {
	_op = op;
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }
    
    public String toString() {
	return Operators.names[_op] + '(' + _left + "", "" + _right + ')';
    }

    public Expression getLeft() {
	return _left;
    }

    public Expression getRight() {
	return _right;
    }

    public boolean getOp() {
	return (_op != Operators.NE);
    }

    
    public boolean hasPositionCall() {
	if (_left.hasPositionCall()) return true;
	if (_right.hasPositionCall()) return true;
	return false;
    }

    public boolean hasLastCall() {
	if (_left.hasLastCall()) return true;
	if (_right.hasLastCall()) return true;
	return false;
    }

    private void swapArguments() {
	final Expression temp = _left;
	_left = _right;
	_right = temp;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	final Type tleft = _left.typeCheck(stable); 
	final Type tright = _right.typeCheck(stable);

	if (tleft.isSimple() && tright.isSimple()) {
	    if (tleft != tright) {
		if (tleft instanceof BooleanType) {
		    _right = new CastExpr(_right, Type.Boolean);
		}
		else if (tright instanceof BooleanType) {
		    _left = new CastExpr(_left, Type.Boolean);
		}
		else if (tleft instanceof NumberType || 
			 tright instanceof NumberType) {
		    _left = new CastExpr(_left, Type.Real);
		    _right = new CastExpr(_right, Type.Real);
		}
		else {		
		    _left = new CastExpr(_left,   Type.String);
		    _right = new CastExpr(_right, Type.String);
		}
	    }
	}
	else if (tleft instanceof ReferenceType) {
	    _right = new CastExpr(_right, Type.Reference);
	}
	else if (tright instanceof ReferenceType) {
	    _left = new CastExpr(_left, Type.Reference);
	}
	
	else if (tleft instanceof NodeType && tright == Type.String) {
	    _left = new CastExpr(_left, Type.String);
	}
	else if (tleft == Type.String && tright instanceof NodeType) {
	    _right = new CastExpr(_right, Type.String);
	}
	
	else if (tleft instanceof NodeType && tright instanceof NodeType) {
	    _left = new CastExpr(_left, Type.String);
	    _right = new CastExpr(_right, Type.String);
	}
	else if (tleft instanceof NodeType && tright instanceof NodeSetType) {
	    
	}
	else if (tleft instanceof NodeSetType && tright instanceof NodeType) {
	    swapArguments();	
	}
	else {	
	    

	    
	    if (tleft instanceof NodeType) {
		_left = new CastExpr(_left, Type.NodeSet);
	    }
	    if (tright instanceof NodeType) {
		_right = new CastExpr(_right, Type.NodeSet);
	    }

	    
	    if (tleft.isSimple() ||
		tleft instanceof ResultTreeType &&
		tright instanceof NodeSetType) {
		swapArguments();
	    }

	    
	    if (_right.getType() instanceof IntType) {
		_right = new CastExpr(_right, Type.Real);
	    }
	}
	return _type = Type.Boolean;
    }

    public void translateDesynthesized(ClassGenerator classGen,
				       MethodGenerator methodGen) {
	final Type tleft = _left.getType();
	final InstructionList il = methodGen.getInstructionList();

	if (tleft instanceof BooleanType) {
	    _left.translate(classGen, methodGen);
	    _right.translate(classGen, methodGen);
	    _falseList.add(il.append(_op == Operators.EQ ? 
				     (BranchInstruction)new IF_ICMPNE(null) :
				     (BranchInstruction)new IF_ICMPEQ(null)));
	}
	else if (tleft instanceof NumberType) {
	    _left.translate(classGen, methodGen);
	    _right.translate(classGen, methodGen);

	    if (tleft instanceof RealType) {
		il.append(DCMPG);
		_falseList.add(il.append(_op == Operators.EQ ? 
					 (BranchInstruction)new IFNE(null) : 
					 (BranchInstruction)new IFEQ(null)));
	    }
	    else {
		_falseList.add(il.append(_op == Operators.EQ ? 
					 (BranchInstruction)new IF_ICMPNE(null) :
					 (BranchInstruction)new IF_ICMPEQ(null)));
	    }
	}
	else {
	    translate(classGen, methodGen);
	    desynthesize(classGen, methodGen);
	}
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final Type tleft = _left.getType();
	Type tright = _right.getType();

	if (tleft instanceof BooleanType || tleft instanceof NumberType) {
	    translateDesynthesized(classGen, methodGen);
	    synthesize(classGen, methodGen);
	    return;
	}

	if (tleft instanceof StringType) {
	    final int equals = cpg.addMethodref(STRING_CLASS,
						""equals"",
						""("" + OBJECT_SIG +"")Z"");
	    _left.translate(classGen, methodGen);
	    _right.translate(classGen, methodGen);
	    il.append(new INVOKEVIRTUAL(equals));

	    if (_op == Operators.NE) {
		il.append(ICONST_1);
		il.append(IXOR);			
	    }
	    return;
	}

	BranchHandle truec, falsec;
	
	if (tleft instanceof ResultTreeType) {
	    if (tright instanceof BooleanType) {
		_right.translate(classGen, methodGen);
		if (_op == Operators.NE) {
		    il.append(ICONST_1);
		    il.append(IXOR); 
		}
		return;
	    }

	    if (tright instanceof RealType) {
		_left.translate(classGen, methodGen);
		tleft.translateTo(classGen, methodGen, Type.Real);
		_right.translate(classGen, methodGen);

		il.append(DCMPG);
		falsec = il.append(_op == Operators.EQ ? 
				   (BranchInstruction) new IFNE(null) : 
				   (BranchInstruction) new IFEQ(null));
		il.append(ICONST_1);
		truec = il.append(new GOTO(null));
		falsec.setTarget(il.append(ICONST_0));
		truec.setTarget(il.append(NOP));
		return;
	    }

	    

	    _left.translate(classGen, methodGen);
	    tleft.translateTo(classGen, methodGen, Type.String);
	    _right.translate(classGen, methodGen);

	    if (tright instanceof ResultTreeType) {
		tright.translateTo(classGen, methodGen, Type.String);
	    }

	    final int equals = cpg.addMethodref(STRING_CLASS,
						""equals"",
						""("" +OBJECT_SIG+ "")Z"");
	    il.append(new INVOKEVIRTUAL(equals));

	    if (_op == Operators.NE) {
		il.append(ICONST_1);
		il.append(IXOR);			
	    }
	    return;
	}

	if (tleft instanceof NodeSetType && tright instanceof BooleanType) {
	    _left.translate(classGen, methodGen);
	    _left.startResetIterator(classGen, methodGen);
	    Type.NodeSet.translateTo(classGen, methodGen, Type.Boolean);
	    _right.translate(classGen, methodGen);

	    il.append(IXOR); 
	    if (_op == EQ) {
		il.append(ICONST_1);
		il.append(IXOR); 
	    }
	    return;
	}

	if (tleft instanceof NodeSetType && tright instanceof StringType) {
	    _left.translate(classGen, methodGen);
	    _left.startResetIterator(classGen, methodGen); 
	    _right.translate(classGen, methodGen);
	    il.append(new PUSH(cpg, _op));
	    il.append(methodGen.loadDOM());
	    final int cmp = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					     ""compare"",
					     ""(""
					     + tleft.toSignature() 
					     + tright.toSignature()
					     + ""I""
					     + DOM_INTF_SIG
					     + "")Z"");
	    il.append(new INVOKESTATIC(cmp));
	    return;
	}

	
	_left.translate(classGen, methodGen);
	_left.startResetIterator(classGen, methodGen);
	_right.translate(classGen, methodGen);
	_right.startResetIterator(classGen, methodGen);

	
	if (tright instanceof ResultTreeType) {
	    tright.translateTo(classGen, methodGen, Type.String);	
	    tright = Type.String;
	}

	
	il.append(new PUSH(cpg, _op));
	il.append(methodGen.loadContextNode());
	il.append(methodGen.loadDOM());

	final int compare = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					     ""compare"",
					     ""(""
					     + tleft.toSignature() 
					     + tright.toSignature()
					     + ""I""
					     + NODE_SIG
					     + DOM_INTF_SIG
					     + "")Z"");
	il.append(new INVOKESTATIC(compare));
    }
}
"
org.apache.xalan.xsltc.runtime.Constants,0,1,0,5,0,0,5,0,0,2.0,14,0.0,0,0.0,0.0,0,0,0.0,0,0.0,0,"

package org.apache.xalan.xsltc.runtime;

import org.apache.xalan.xsltc.DOM;


public interface Constants {

    final static int ANY       = -1;
    final static int ATTRIBUTE = -2;
    final static int ROOT      = DOM.ROOT;
    final static int TEXT      = DOM.TEXT;
    final static int ELEMENT   = DOM.ELEMENT;
    final static int COMMENT   = DOM.COMMENT;
    final static int PROCESSING_INSTRUCTION = DOM.PROCESSING_INSTRUCTION;

    public static String XSLT_URI = ""http:
    public static final String NAMESPACE_FEATURE =
	""http:

    public static final String EMPTYSTRING = """";
    public static final String XML_PREFIX = ""xml"";
    public static final String XMLNS_PREFIX = ""xmlns"";
    public static final String XMLNS_STRING = ""xmlns:"";
    public static final String XMLNS_URI = ""http:
}
"
org.apache.xpath.operations.Quo,2,3,0,4,5,1,1,3,2,2.0,16,0.0,0,0.976190476,0.75,1,1,7.0,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;


public class Quo extends Operation
{

  

  
  public XObject operate(XObject left, XObject right)
          throws javax.xml.transform.TransformerException
  {
    return new XNumber((int) (left.num() / right.num()));
  }
}
"
org.apache.xpath.FoundIndex,1,4,0,0,2,0,0,0,1,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"
package org.apache.xpath;


public class FoundIndex extends RuntimeException
{

  
  public FoundIndex(){}
}
"
org.apache.xpath.axes.FilterExprWalker,18,5,0,22,48,19,5,18,16,0.75,244,1.0,2,0.858333333,0.185185185,4,14,12.33333333,3,1.3333,0,"
package org.apache.xpath.axes;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xalan.templates.FuncKey;
import org.apache.xml.dtm.Axis;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.VariableStack;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.compiler.OpCodes;
import org.apache.xpath.objects.XNodeSet;


public class FilterExprWalker extends AxesWalker
{

  
  public FilterExprWalker(WalkingIterator locPathIterator)
  {
    super(locPathIterator, Axis.FILTEREDLIST);
  }

  
  public void init(Compiler compiler, int opPos, int stepType)
          throws javax.xml.transform.TransformerException
  {

    super.init(compiler, opPos, stepType);

    
    switch (stepType)
    {
    case OpCodes.OP_FUNCTION :
    case OpCodes.OP_EXTFUNCTION :
    	m_mustHardReset = true;
    case OpCodes.OP_GROUP :
    case OpCodes.OP_VARIABLE :
      m_expr = compiler.compile(opPos);
      m_expr.exprSetParent(this);
      if((OpCodes.OP_FUNCTION == stepType) && (m_expr instanceof org.apache.xalan.templates.FuncKey))
      {
      	
      	m_canDetachNodeset = false;
      }
      break;
    default :
      m_expr = compiler.compile(opPos + 2);
      m_expr.exprSetParent(this);
    }














  }
  
  
  public void detach()
  {  
  	super.detach();
  	m_exprObj.detach();
  	m_exprObj = null;
  }

  
  public void setRoot(int root)
  {

    super.setRoot(root);

  	m_exprObj = FilterExprIteratorSimple.executeFilterExpr(root, 
  	                  m_lpi.getXPathContext(), m_lpi.getPrefixResolver(), 
  	                  m_lpi.getIsTopLevel(), m_lpi.m_stackFrame, m_expr);

  }

  
  public Object clone() throws CloneNotSupportedException
  {

    FilterExprWalker clone = (FilterExprWalker) super.clone();

    
    if (null != m_exprObj)
      clone.m_exprObj = (XNodeSet) m_exprObj.clone();

    return clone;
  }
  
  
  public short acceptNode(int n)
  {

    try
    {
      if (getPredicateCount() > 0)
      {
        countProximityPosition(0);

        if (!executePredicates(n, m_lpi.getXPathContext()))
          return DTMIterator.FILTER_SKIP;
      }

      return DTMIterator.FILTER_ACCEPT;
    }
    catch (javax.xml.transform.TransformerException se)
    {
      throw new RuntimeException(se.getMessage());
    }
  }

  
  public int getNextNode()
  {

    if (null != m_exprObj)
    {
       int next = m_exprObj.nextNode();
       return next;
    }
    else
      return DTM.NULL;
  }
  
  
  public int getLastPos(XPathContext xctxt)
  {
    return m_exprObj.getLength();
  }
  
  
  private Expression m_expr;

  
  transient private XNodeSet m_exprObj;
  
  private boolean m_mustHardReset = false;
  private boolean m_canDetachNodeset = true;

  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    super.fixupVariables(vars, globalsSize);
    m_expr.fixupVariables(vars, globalsSize);
  }
  
  
  public Expression getInnerExpression()
  {
  	return m_expr;
  }
  
  
  public void setInnerExpression(Expression expr)
  {
  	expr.exprSetParent(this);
  	m_expr = expr;
  }

  
  
  public int getAnalysisBits()
  {
      if (null != m_expr && m_expr instanceof PathComponent)
      {
        return ((PathComponent) m_expr).getAnalysisBits();
      }
      return WalkerFactory.BIT_FILTER;
  }
  
  
  public boolean isDocOrdered()
  {
    return m_exprObj.isDocOrdered();
  }
  
  
  public int getAxis()
  {
    return m_exprObj.getAxis();
  }
  
  class filterExprOwner implements ExpressionOwner
  {
      
    public Expression getExpression()
    {
      return m_expr;
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(FilterExprWalker.this);
    	m_expr = exp;
    }

  }
  
	
	public void callPredicateVisitors(XPathVisitor visitor)
	{
	  m_expr.callVisitors(new filterExprOwner(), visitor);
	  
	  super.callPredicateVisitors(visitor);
	} 


    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
                return false;

      FilterExprWalker walker = (FilterExprWalker)expr;
      if(!m_expr.deepEquals(walker.m_expr))
      	return false;

      return true;
    }

	

}
"
org.apache.xalan.xsltc.compiler.Include,5,3,0,14,49,4,1,14,4,0.5,319,1.0,1,0.9375,0.36,2,5,62.6,13,3.2,0,"

package org.apache.xalan.xsltc.compiler;

import java.io.File;
import java.io.FileNotFoundException;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.Enumeration;

import javax.xml.parsers.*;

import org.xml.sax.*;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.*;

import org.apache.bcel.generic.*;

final class Include extends TopLevelElement {

    private Stylesheet _included = null;

    public Stylesheet getIncludedStylesheet() {
	return _included;
    }

    public void parseContents(final Parser parser) {
	final Stylesheet context = parser.getCurrentStylesheet();

	String docToLoad = getAttribute(""href"");
	try {
	    if (context.checkForLoop(docToLoad)) {
		final int errno = ErrorMsg.CIRCULAR_INCLUDE_ERR;
		final ErrorMsg msg = new ErrorMsg(errno, docToLoad, this);
		parser.reportError(Constants.FATAL, msg);
		return;
	    }

	    String currLoadedDoc = context.getSystemId();
	    SourceLoader loader = context.getSourceLoader();
	    InputSource input = null;

	    if (loader != null) {
		final XSLTC xsltc = parser.getXSLTC();
		input = loader.loadSource(docToLoad, currLoadedDoc, xsltc);
	    }
	    else {
		
		if ((currLoadedDoc != null) && (currLoadedDoc.length() > 0)) {
		    File file = new File(currLoadedDoc);
		    if (file.exists()) {
		        currLoadedDoc = ""file:"" + file.getCanonicalPath();
		    }
		    final URL url = new URL(new URL(currLoadedDoc), docToLoad);
		    docToLoad = url.toString();
		    input = new InputSource(docToLoad);
		}
		else {
		    File file = new File(System.getProperty(""user.dir""),
			docToLoad);
		    if (file.exists()) {
			docToLoad = ""file:"" + file.getCanonicalPath();
		    }
		    else {
			throw new FileNotFoundException(
			  ""Could not load file "" + docToLoad);
		    }
		    input = new InputSource(docToLoad);
		}
	    }

	    
	    if (input == null) {
		final ErrorMsg msg = 
		    new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, docToLoad, this);
		parser.reportError(Constants.FATAL, msg);
		return;
	    }

	    final SyntaxTreeNode root = parser.parse(input);
	    if (root == null) return;
	    _included = parser.makeStylesheet(root);
	    if (_included == null) return;

	    _included.setSourceLoader(loader);
	    _included.setSystemId(docToLoad);
	    _included.setParentStylesheet(context);
	    _included.setIncludingStylesheet(context);
	    _included.setTemplateInlining(context.getTemplateInlining());

	    
	    
	    final int precedence = context.getImportPrecedence();
	    _included.setImportPrecedence(precedence);
	    parser.setCurrentStylesheet(_included);
	    _included.parseContents(parser);

	    final Enumeration elements = _included.elements();
	    final Stylesheet topStylesheet = parser.getTopLevelStylesheet();
	    while (elements.hasMoreElements()) {
		final Object element = elements.nextElement();
		if (element instanceof TopLevelElement) {
		    if (element instanceof Variable) {
			topStylesheet.addVariable((Variable) element);
		    }
		    else if (element instanceof Param) {
			topStylesheet.addParam((Param) element);
		    }
		    else {
			topStylesheet.addElement((TopLevelElement) element);
		    }
		}
	    }
	}
	catch (FileNotFoundException e) {
	    
	    context.setSystemId(getAttribute(""href""));

	    final ErrorMsg msg = 
		new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, docToLoad, this);
	    parser.reportError(Constants.FATAL, msg);
	}
	catch (MalformedURLException e) {
	    
	    context.setSystemId(getAttribute(""href""));

	    final ErrorMsg msg = 
		new ErrorMsg(ErrorMsg.FILE_NOT_FOUND_ERR, docToLoad, this);
	    parser.reportError(Constants.FATAL, msg);
	}
	catch (Exception e) {
	    e.printStackTrace();
	}
	finally {
	    parser.setCurrentStylesheet(context);
	}
    }
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return Type.Void;
    }
    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	
    }
}
"
org.apache.xalan.processor.StylesheetHandler,71,2,0,47,152,2163,25,25,33,0.941326531,1340,0.75,6,0.197674419,0.108035714,1,1,17.47887324,7,1.3239,1,"
package org.apache.xalan.processor;

import java.net.URL;

import java.io.IOException;

import javax.xml.transform.sax.TemplatesHandler;
import javax.xml.transform.Templates;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerConfigurationException;

import java.util.Stack;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.templates.ElemUnknown;
import org.apache.xalan.templates.ElemForEach;
import org.apache.xalan.templates.StylesheetRoot;
import org.apache.xalan.templates.Stylesheet;
import org.apache.xml.utils.NodeConsumer;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.XMLCharacterRecognizer;
import org.apache.xml.utils.BoolStack;
import org.apache.xpath.compiler.FunctionTable;
import org.apache.xpath.compiler.XPathParser;
import org.apache.xpath.functions.Function;
import org.apache.xpath.XPathFactory;
import org.apache.xpath.XPath;

import org.apache.xpath.functions.FuncExtFunction;
import org.apache.xalan.extensions.ExpressionVisitor;
import org.w3c.dom.Node;

import org.xml.sax.Attributes;
import org.xml.sax.ContentHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.InputSource;
import org.xml.sax.Locator;

import org.xml.sax.helpers.NamespaceSupport;
import org.apache.xml.utils.NamespaceSupport2;
import org.xml.sax.helpers.DefaultHandler;

import javax.xml.transform.SourceLocator;
import javax.xml.transform.ErrorListener;
import javax.xml.transform.TransformerException;

import org.apache.xml.utils.SAXSourceLocator;


public class StylesheetHandler extends DefaultHandler
        implements TemplatesHandler, PrefixResolver, NodeConsumer
{

  
  public StylesheetHandler(TransformerFactoryImpl processor)
          throws TransformerConfigurationException
  {

    
    init(processor);
  }

  
  private static boolean m_xpathFunctionsInited = false;

  
  void init(TransformerFactoryImpl processor)
  {

    
    
    if (false == m_xpathFunctionsInited)
    {
      synchronized (this)
      {
        if (false == m_xpathFunctionsInited)
        {
          m_xpathFunctionsInited = true;

          Function func = new org.apache.xalan.templates.FuncDocument();

          FunctionTable.installFunction(""document"", func);

          
          
          func = new org.apache.xalan.templates.FuncFormatNumb();

          FunctionTable.installFunction(""format-number"", func);
        }
      }
    }

    m_stylesheetProcessor = processor;

    
    m_processors.push(m_schema.getElementProcessor());
    this.pushNewNamespaceSupport();

    
    
  }

  
  public XPath createXPath(String str, ElemTemplateElement owningTemplate)
          throws javax.xml.transform.TransformerException
  {
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();
    XPath xpath = new XPath(str, owningTemplate, this, XPath.SELECT, handler);
    
    xpath.callVisitors(xpath, new ExpressionVisitor(getStylesheetRoot()));
    return xpath;
  }

  
  XPath createMatchPatternXPath(String str, ElemTemplateElement owningTemplate)
          throws javax.xml.transform.TransformerException
  {
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();
    return new XPath(str, owningTemplate, this, XPath.MATCH, handler);
  }

  
  public String getNamespaceForPrefix(String prefix)
  {
    return this.getNamespaceSupport().getURI(prefix);
  }

  
  public String getNamespaceForPrefix(String prefix, org.w3c.dom.Node context)
  {

    
    
    assertion(true, ""can't process a context node in StylesheetHandler!"");

    return null;
  }

  
  private boolean stackContains(Stack stack, String url)
  {

    int n = stack.size();
    boolean contains = false;

    for (int i = 0; i < n; i++)
    {
      String url2 = (String) stack.elementAt(i);

      if (url2.equals(url))
      {
        contains = true;

        break;
      }
    }

    return contains;
  }

  
  
  

  
  public Templates getTemplates()
  {
    return getStylesheetRoot();
  }

  
  public void setSystemId(String baseID)
  {
    pushBaseIndentifier(baseID);
  }

  
  public String getSystemId()
  {
    return this.getBaseIdentifier();
  }

  
  
  

  
  public InputSource resolveEntity(String publicId, String systemId)
          throws org.xml.sax.SAXException
  {
    return getCurrentProcessor().resolveEntity(this, publicId, systemId);
  }

  
  
  

  
  public void notationDecl(String name, String publicId, String systemId)
  {
    getCurrentProcessor().notationDecl(this, name, publicId, systemId);
  }

  
  public void unparsedEntityDecl(String name, String publicId,
                                 String systemId, String notationName)
  {
    getCurrentProcessor().unparsedEntityDecl(this, name, publicId, systemId,
                                             notationName);
  }

  
  XSLTElementProcessor getProcessorFor(
          String uri, String localName, String rawName)
            throws org.xml.sax.SAXException
  {

    XSLTElementProcessor currentProcessor = getCurrentProcessor();
    XSLTElementDef def = currentProcessor.getElemDef();
    XSLTElementProcessor elemProcessor = def.getProcessorFor(uri, localName);

    if (null == elemProcessor
            && ((null == getStylesheet()
                || Double.valueOf(getStylesheet().getVersion()).doubleValue()
                   > Constants.XSLTVERSUPPORTED) 
                ||(!uri.equals(Constants.S_XSLNAMESPACEURL) &&
                            currentProcessor instanceof ProcessorStylesheetElement)
                || getElemVersion() > Constants.XSLTVERSUPPORTED
        ))
    {
      elemProcessor = def.getProcessorForUnknown(uri, localName);
    }

    if (null == elemProcessor)
      error(XSLMessages.createMessage(XSLTErrorResources.ER_NOT_ALLOWED_IN_POSITION, new Object[]{rawName}),null);
            
                
    return elemProcessor;
  }

  
  
  

  
  public void setDocumentLocator(Locator locator)
  {

    
    m_stylesheetLocatorStack.push(new SAXSourceLocator(locator));
  }

  
  private int m_stylesheetLevel = -1;

  
  public void startDocument() throws org.xml.sax.SAXException
  {
    m_stylesheetLevel++;
    pushSpaceHandling(false);
  }

  
  private boolean m_parsingComplete = false;

  
  public boolean isStylesheetParsingComplete()
  {
    return m_parsingComplete;
  }

  
  public void endDocument() throws org.xml.sax.SAXException
  {

    try
    {
      if (null != getStylesheetRoot())
      {
        if (0 == m_stylesheetLevel)
          getStylesheetRoot().recompose();        
      }
      else
        throw new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_STYLESHEETROOT, null)); 

      XSLTElementProcessor elemProcessor = getCurrentProcessor();

      if (null != elemProcessor)
        elemProcessor.startNonText(this);

      m_stylesheetLevel--;			
      
      popSpaceHandling();

      
      
      
      
      
      m_parsingComplete = (m_stylesheetLevel < 0);
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }
  
  private java.util.Vector m_prefixMappings = new java.util.Vector();

  
  public void startPrefixMapping(String prefix, String uri)
          throws org.xml.sax.SAXException
  {

    
    
    
    
    m_prefixMappings.addElement(prefix); 
    m_prefixMappings.addElement(uri); 
  }

  
  public void endPrefixMapping(String prefix) throws org.xml.sax.SAXException
  {

    
  }

  
  private void flushCharacters() throws org.xml.sax.SAXException
  {

    XSLTElementProcessor elemProcessor = getCurrentProcessor();

    if (null != elemProcessor)
      elemProcessor.startNonText(this);
  }

  
  public void startElement(
          String uri, String localName, String rawName, Attributes attributes)
            throws org.xml.sax.SAXException
  {
    NamespaceSupport nssupport = this.getNamespaceSupport();
    nssupport.pushContext();
    
    int n = m_prefixMappings.size();

    for (int i = 0; i < n; i++) 
    {
      String prefix = (String)m_prefixMappings.elementAt(i++);
      String nsURI = (String)m_prefixMappings.elementAt(i);
      nssupport.declarePrefix(prefix, nsURI);
    }
    
    m_prefixMappings.removeAllElements(); 

    m_elementID++;

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    checkForFragmentID(attributes);

    if (!m_shouldProcess)
      return;

    flushCharacters();
    
    pushSpaceHandling(attributes);

    XSLTElementProcessor elemProcessor = getProcessorFor(uri, localName,
                                           rawName);

    if(null != elemProcessor)  
    {
      this.pushProcessor(elemProcessor);
      elemProcessor.startElement(this, uri, localName, rawName, attributes);
    }
    else
    {
      m_shouldProcess = false;
      popSpaceHandling();
    }
                
  }

  
  public void endElement(String uri, String localName, String rawName)
          throws org.xml.sax.SAXException
  {

    m_elementID--;

    if (!m_shouldProcess)
      return;

    if ((m_elementID + 1) == m_fragmentID)
      m_shouldProcess = false;

    flushCharacters();
    
    popSpaceHandling();

    XSLTElementProcessor p = getCurrentProcessor();

    p.endElement(this, uri, localName, rawName);
    this.popProcessor();
    this.getNamespaceSupport().popContext();
  }

  
  public void characters(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    if (!m_shouldProcess)
      return;

    XSLTElementProcessor elemProcessor = getCurrentProcessor();
    XSLTElementDef def = elemProcessor.getElemDef();

    if (def.getType() != XSLTElementDef.T_PCDATA)
      elemProcessor = def.getProcessorFor(null, ""text()"");

    if (null == elemProcessor)
    {

      
      if (!XMLCharacterRecognizer.isWhiteSpace(ch, start, length))
        error(
          XSLMessages.createMessage(XSLTErrorResources.ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION, null),null);
          
    }
    else
      elemProcessor.characters(this, ch, start, length);
  }

  
  public void ignorableWhitespace(char ch[], int start, int length)
          throws org.xml.sax.SAXException
  {

    if (!m_shouldProcess)
      return;

    getCurrentProcessor().ignorableWhitespace(this, ch, start, length);
  }

  
  public void processingInstruction(String target, String data)
          throws org.xml.sax.SAXException
  {
    if (!m_shouldProcess)
      return;

    
    
    
    
    
    
    
    
    
    String prefix="""",ns="""", localName=target;
    int colon=target.indexOf(':');
    if(colon>=0)
    {
      ns=getNamespaceForPrefix(prefix=target.substring(0,colon));
      localName=target.substring(colon+1);
    }

    try
    {
      
      
      
      
      
      
      
      if(
	 ""xalan:doc-cache-off"".equals(target) ||
	   (""doc-cache-off"".equals(localName) &&
	    ns.equals(""org.apache.xalan.xslt.extensions.Redirect"") )
	 )
      {
	if(!(m_elems.peek() instanceof ElemForEach))
          throw new TransformerException
	    (""xalan:doc-cache-off not allowed here!"", 
	     getLocator());
        ElemForEach elem = (ElemForEach)m_elems.peek();

        elem.m_doc_cache_off = true;

	
      }
    }
    catch(Exception e)
    {
      
      
    }


    flushCharacters();
    getCurrentProcessor().processingInstruction(this, target, data);
  }

  
  public void skippedEntity(String name) throws org.xml.sax.SAXException
  {

    if (!m_shouldProcess)
      return;

    getCurrentProcessor().skippedEntity(this, name);
  }

  
  public void warn(int msg, Object args[]) throws org.xml.sax.SAXException
  {

    String formattedMsg = m_XSLMessages.createWarning(msg, args);
    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();

    try
    {
      if (null != handler)
        handler.warning(new TransformerException(formattedMsg, locator));
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  private void assertion(boolean condition, String msg) throws RuntimeException
  {
    if (!condition)
      throw new RuntimeException(msg);
  }

  
  protected void error(String msg, Exception e)
          throws org.xml.sax.SAXException
  {

    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();
    TransformerException pe;

    if (!(e instanceof TransformerException))
    {
      pe = (null == e)
           ? new TransformerException(msg, locator)
           : new TransformerException(msg, locator, e);
    }
    else
      pe = (TransformerException) e;

    if (null != handler)
    {
      try
      {
        handler.error(pe);
      }
      catch (TransformerException te)
      {
        throw new org.xml.sax.SAXException(te);
      }
    }
    else
      throw new org.xml.sax.SAXException(pe);
  }

  
  protected void error(int msg, Object args[], Exception e)
          throws org.xml.sax.SAXException
  {

    String formattedMsg = m_XSLMessages.createMessage(msg, args);

    error(formattedMsg, e);
  }

  
  public void warning(org.xml.sax.SAXParseException e)
          throws org.xml.sax.SAXException
  {

    String formattedMsg = e.getMessage();
    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();

    try
    {
      handler.warning(new TransformerException(formattedMsg, locator));
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  public void error(org.xml.sax.SAXParseException e)
          throws org.xml.sax.SAXException
  {

    String formattedMsg = e.getMessage();
    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();

    try
    {
      handler.error(new TransformerException(formattedMsg, locator));
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  public void fatalError(org.xml.sax.SAXParseException e)
          throws org.xml.sax.SAXException
  {

    String formattedMsg = e.getMessage();
    SAXSourceLocator locator = getLocator();
    ErrorListener handler = m_stylesheetProcessor.getErrorListener();

    try
    {
      handler.fatalError(new TransformerException(formattedMsg, locator));
    }
    catch (TransformerException te)
    {
      throw new org.xml.sax.SAXException(te);
    }
  }

  
  private boolean m_shouldProcess = true;

  
  private String m_fragmentIDString;

  
  private int m_elementID = 0;

  
  private int m_fragmentID = 0;

  
  private void checkForFragmentID(Attributes attributes)
  {

    if (!m_shouldProcess)
    {
      if ((null != attributes) && (null != m_fragmentIDString))
      {
        int n = attributes.getLength();

        for (int i = 0; i < n; i++)
        {
          String name = attributes.getQName(i);

          if (name.equals(Constants.ATTRNAME_ID))
          {
            String val = attributes.getValue(i);

            if (val.equalsIgnoreCase(m_fragmentIDString))
            {
              m_shouldProcess = true;
              m_fragmentID = m_elementID;
            }
          }
        }
      }
    }
  }

  
  private TransformerFactoryImpl m_stylesheetProcessor;

  
  TransformerFactoryImpl getStylesheetProcessor()
  {
    return m_stylesheetProcessor;
  }

  
  static final int STYPE_ROOT = 1;

  
  static final int STYPE_INCLUDE = 2;

  
  static final int STYPE_IMPORT = 3;

  
  private int m_stylesheetType = STYPE_ROOT;

  
  int getStylesheetType()
  {
    return m_stylesheetType;
  }

  
  void setStylesheetType(int type)
  {
    m_stylesheetType = type;
  }

  
  private Stack m_stylesheets = new Stack();

  
  Stylesheet getStylesheet()
  {
    return (m_stylesheets.size() == 0)
           ? null : (Stylesheet) m_stylesheets.peek();
  }

  
  Stylesheet getLastPoppedStylesheet()
  {
    return m_lastPoppedStylesheet;
  }

  
  public StylesheetRoot getStylesheetRoot()
  {
    return m_stylesheetRoot;
  }

  
  StylesheetRoot m_stylesheetRoot;
        
        
  Stylesheet m_lastPoppedStylesheet;

  
  public void pushStylesheet(Stylesheet s)
  {

    if (m_stylesheets.size() == 0)
      m_stylesheetRoot = (StylesheetRoot) s;

    m_stylesheets.push(s);
  }

  
  Stylesheet popStylesheet()
  {

    
    
    
    if (!m_stylesheetLocatorStack.isEmpty())
      m_stylesheetLocatorStack.pop();

    if (!m_stylesheets.isEmpty())
      m_lastPoppedStylesheet = (Stylesheet) m_stylesheets.pop();

    
    return m_lastPoppedStylesheet;
  }

  
  private Stack m_processors = new Stack();

  
  XSLTElementProcessor getCurrentProcessor()
  {
    return (XSLTElementProcessor) m_processors.peek();
  }

  
  void pushProcessor(XSLTElementProcessor processor)
  {
    m_processors.push(processor);
  }

  
  XSLTElementProcessor popProcessor()
  {
    return (XSLTElementProcessor) m_processors.pop();
  }

  
  private XSLTSchema m_schema = new XSLTSchema();

  
  XSLTSchema getSchema()
  {
    return m_schema;
  }

  
  private Stack m_elems = new Stack();

  
  ElemTemplateElement getElemTemplateElement()
  {

    try
    {
      return (ElemTemplateElement) m_elems.peek();
    }
    catch (java.util.EmptyStackException ese)
    {
      return null;
    }
  }  

  
  private int m_docOrderCount = 0;

  
  int nextUid()
  {
    return m_docOrderCount++;
  }

  
  void pushElemTemplateElement(ElemTemplateElement elem)
  {

    if (elem.getUid() == -1)
      elem.setUid(nextUid());

    m_elems.push(elem);
  }

  
  ElemTemplateElement popElemTemplateElement()
  {
    return (ElemTemplateElement) m_elems.pop();
  }

  
  
  private static XSLMessages m_XSLMessages = new XSLMessages();

  
  XSLMessages getXSLMessages()
  {
    return m_XSLMessages;
  }

  
  Stack m_baseIdentifiers = new Stack();

  
  void pushBaseIndentifier(String baseID)
  {

    if (null != baseID)
    {
      int posOfHash = baseID.indexOf('#');

      if (posOfHash > -1)
      {
        m_fragmentIDString = baseID.substring(posOfHash + 1);
        m_shouldProcess = false;
      }
      else
        m_shouldProcess = true;
    }
    else
      m_shouldProcess = true;

    m_baseIdentifiers.push(baseID);
  }

  
  String popBaseIndentifier()
  {
    return (String) m_baseIdentifiers.pop();
  }

  
  public String getBaseIdentifier()
  {

    
    
    
    String base = (String) (m_baseIdentifiers.isEmpty()
                            ? null : m_baseIdentifiers.peek());

    
    if (null == base)
    {
      SourceLocator locator = getLocator();

      base = (null == locator) ? """" : locator.getSystemId();
    }

    return base;
  }

  
  private Stack m_stylesheetLocatorStack = new Stack();

  
  public SAXSourceLocator getLocator()
  {

    if (m_stylesheetLocatorStack.isEmpty())
    {
      SAXSourceLocator locator = new SAXSourceLocator();

      locator.setSystemId(this.getStylesheetProcessor().getDOMsystemID());

      return locator;

      
    }

    return ((SAXSourceLocator) m_stylesheetLocatorStack.peek());
  }

  
  private Stack m_importStack = new Stack();

  
  void pushImportURL(String hrefUrl)
  {
    m_importStack.push(hrefUrl);
  }

  
  boolean importStackContains(String hrefUrl)
  {
    return stackContains(m_importStack, hrefUrl);
  }

  
  String popImportURL()
  {
    return (String) m_importStack.pop();
  }

  
  private boolean warnedAboutOldXSLTNamespace = false;

  
  Stack m_nsSupportStack = new Stack();

  
  void pushNewNamespaceSupport()
  {
    m_nsSupportStack.push(new NamespaceSupport2());
  }

  
  void popNamespaceSupport()
  {
    m_nsSupportStack.pop();
  }

  
  NamespaceSupport getNamespaceSupport()
  {
    return (NamespaceSupport) m_nsSupportStack.peek();
  }

  
  private Node m_originatingNode;

  
  public void setOriginatingNode(Node n)
  {
    m_originatingNode = n;
  }

  
  public Node getOriginatingNode()
  {
    return m_originatingNode;
  }
  
  
  private BoolStack m_spacePreserveStack = new BoolStack();
  
  
  boolean isSpacePreserve()
  {
    return m_spacePreserveStack.peek();
  }
  
  
  void popSpaceHandling()
  {
    m_spacePreserveStack.pop();
  }
  
  
  void pushSpaceHandling(boolean b)
    throws org.xml.sax.SAXParseException
  {
    m_spacePreserveStack.push(b);
  }
  
  
  void pushSpaceHandling(Attributes attrs)
    throws org.xml.sax.SAXParseException
  {    
    String value = attrs.getValue(""xml:space"");
    if(null == value)
    {
      m_spacePreserveStack.push(m_spacePreserveStack.peekOrFalse());
    }
    else if(value.equals(""preserve""))
    {
      m_spacePreserveStack.push(true);
    }
    else if(value.equals(""default""))
    {
      m_spacePreserveStack.push(false);
    }
    else
    {
      SAXSourceLocator locator = getLocator();
      ErrorListener handler = m_stylesheetProcessor.getErrorListener();
  
      try
      {
        handler.error(new TransformerException(XSLMessages.createMessage(XSLTErrorResources.ER_ILLEGAL_XMLSPACE_VALUE, null), locator)); 
      }
      catch (TransformerException te)
      {
        throw new org.xml.sax.SAXParseException(te.getMessage(), locator, te);
      }
      m_spacePreserveStack.push(m_spacePreserveStack.peek());
    }
  }
  
  private double getElemVersion()
  {
    ElemTemplateElement elem = getElemTemplateElement();
    double version = -1; 
    while ((version == -1 || version == Constants.XSLTVERSUPPORTED) && elem != null)
    {
      try{
      version = Double.valueOf(elem.getVersion()).doubleValue();
      }
      catch (Exception ex)
      {
        version = -1;
      }
      elem = elem.getParentElem();
      }
    return (version == -1)? Constants.XSLTVERSUPPORTED : version;
  }
	
	public boolean handlesNullPrefixes() {
		return false;
	}

}



"
org.apache.xalan.lib.sql.PooledConnection,5,1,0,1,9,0,1,0,5,0.5,41,1.0,0,0.0,0.466666667,0,0,6.8,1,0.8,0,"
package org.apache.xalan.lib.sql;

import java.sql.*;
import java.sql.Connection;


public class PooledConnection
{

  
  
  private Connection connection = null;
  
  
  private boolean inuse = false;

  
  
  
  public PooledConnection( Connection value )
  {
    if ( value != null ) { connection = value; }
  }

  
  public Connection getConnection( )
  {
    
    return connection;
  }

  
  public void setInUse( boolean value )
  {
    inuse = value;
  }

  
  public boolean inUse( ) { return inuse; }

  
  public void close( )
  {
    try
    {
      connection.close();
    }
    catch (SQLException sqle)
    {
      System.err.println(sqle.getMessage());
    }
  }
}
"
org.apache.xalan.trace.EndSelectionEvent,1,2,0,8,2,0,3,5,1,2.0,10,0.0,0,0.0,1.0,0,0,9.0,0,0.0,0,"package org.apache.xalan.trace;

import org.w3c.dom.*;

import org.apache.xalan.templates.ElemTemplateElement;
import org.apache.xalan.transformer.TransformerImpl;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;


public class EndSelectionEvent extends SelectionEvent
{

  
  public EndSelectionEvent(TransformerImpl processor, Node sourceNode,
                        ElemTemplateElement styleNode, String attributeName,
                        XPath xpath, XObject selection)
  {

    super(processor, sourceNode, styleNode, attributeName, xpath, selection);
  }
}"
org.apache.xalan.xsltc.compiler.util.ReferenceType,20,2,0,41,44,190,18,30,19,2.0,353,0.0,0,0.634615385,0.230769231,2,4,16.65,8,1.45,1,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.Constants;

public final class ReferenceType extends Type {
    protected ReferenceType() {}

    public String toString() {
	return ""reference"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""Ljava/lang/Object;"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.OBJECT;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.NodeSet) {
	    translateTo(classGen, methodGen, (NodeSetType) type);
	}
	else if (type == Type.Node) {
	    translateTo(classGen, methodGen, (NodeType) type);
	}
	else if (type == Type.ResultTree) {
	    translateTo(classGen, methodGen, (ResultTreeType) type);
	}
	else if (type == Type.Object) {
	    translateTo(classGen, methodGen, (ObjectType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.INTERNAL_ERR, type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final int current = methodGen.getLocalIndex(""current"");
	ConstantPoolGen cpg = classGen.getConstantPool();
	InstructionList il = methodGen.getInstructionList();

	il.append(new ILOAD(current));
	il.append(methodGen.loadDOM());
	final int stringF = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					     ""stringF"", 
					     ""(""
					     + OBJECT_SIG
					     + NODE_SIG
					     + DOM_INTF_SIG
					     + "")"" + STRING_SIG);
	il.append(new INVOKESTATIC(stringF));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    RealType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	il.append(methodGen.loadDOM());
	int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""numberF"", 
				     ""("" 
				     + OBJECT_SIG
				     + DOM_INTF_SIG
				     + "")D"");
	il.append(new INVOKESTATIC(index));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""booleanF"", 
				     ""("" 
				     + OBJECT_SIG
				     + "")Z"");
	il.append(new INVOKESTATIC(index));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    NodeSetType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""referenceToNodeSet"", 
				     ""(""
				     + OBJECT_SIG
				     + "")""
				     + NODE_ITERATOR_SIG);
	il.append(new INVOKESTATIC(index));
	
	
	index = cpg.addInterfaceMethodref(NODE_ITERATOR, RESET, RESET_SIG);
	il.append(new INVOKEINTERFACE(index, 1));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    NodeType type) {
	translateTo(classGen, methodGen, Type.NodeSet);
	Type.NodeSet.translateTo(classGen, methodGen, type);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ResultTreeType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	int index = cpg.addMethodref(BASIS_LIBRARY_CLASS, ""referenceToResultTree"", 
				     ""("" + OBJECT_SIG + "")"" + DOM_INTF_SIG);
	il.append(new INVOKESTATIC(index));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ObjectType type) {
	methodGen.getInstructionList().append(NOP);	
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) {
	if (clazz.getName().equals(""java.lang.Object"")) {
	    methodGen.getInstructionList().append(NOP);	
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen, 
			      Class clazz) {
	if (clazz.getName().equals(""java.lang.Object"")) {
	    methodGen.getInstructionList().append(NOP);	
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
				toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
        } 
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	InstructionList il = methodGen.getInstructionList();
	translateTo(classGen, methodGen, type);
	return new FlowList(il.append(new IFEQ(null)));
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
    }


    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}

"
org.apache.xalan.xsltc.compiler.SimpleAttributeValue,5,4,0,14,10,4,1,14,4,0.5,38,1.0,0,0.947368421,0.36,2,8,6.4,1,0.8,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.bcel.generic.*;

final class SimpleAttributeValue extends AttributeValue {

    private String _value; 

    
    public SimpleAttributeValue(String value) {
	_value = value;
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	return _type = Type.String;
    }
    
    public String toString() {
	return _value;
    }
	
    protected boolean contextDependent() {
	return false;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(cpg, _value));
    }
}
"
org.apache.xalan.xsltc.compiler.VariableRef,2,4,0,22,25,1,2,20,2,2.0,137,0.0,0,0.987012987,0.625,2,3,67.5,9,4.5,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class VariableRef extends VariableRefBase {

    public VariableRef(Variable variable) {
	super(variable);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	if (_type.implementedAsMethod()) return;

	final String name = _variable.getVariable();
	final String signature = _type.toSignature();

	if (_variable.isLocal()) {
	    if (classGen.isExternal()) {
		Closure variableClosure = _closure;
		while (variableClosure != null) {
		    if (variableClosure.inInnerClass()) break;
		    variableClosure = variableClosure.getParentClosure();
		}
	    
		if (variableClosure != null) {
		    il.append(ALOAD_0);
		    il.append(new GETFIELD(
			cpg.addFieldref(variableClosure.getInnerClassName(), 
			    name, signature)));
		}
		else {
		    il.append(_variable.loadInstruction());
		    _variable.removeReference(this);
		}
	    }
	    else {
		il.append(_variable.loadInstruction());
		_variable.removeReference(this);
	    }
	}
	else {
	    final String className = classGen.getClassName();
	    il.append(classGen.loadTranslet());
	    if (classGen.isExternal()) {
		il.append(new CHECKCAST(cpg.addClass(className)));
	    }
	    il.append(new GETFIELD(cpg.addFieldref(className,name,signature)));
	}

	if (_variable.getType() instanceof NodeSetType) {
	    
	    final int clone = cpg.addInterfaceMethodref(NODE_ITERATOR,
						       ""cloneIterator"",
						       ""()"" + 
							NODE_ITERATOR_SIG);
	    il.append(new INVOKEINTERFACE(clone, 1));
	}
    }
}
"
org.apache.xpath.objects.XNodeSetForDOM,7,5,0,7,18,0,1,6,7,0.0,115,0.0,0,0.978417266,0.285714286,3,14,15.28571429,1,0.4286,0,"package org.apache.xpath.objects;

import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.w3c.dom.traversal.NodeIterator;

import org.apache.xml.dtm.*;
import org.apache.xpath.NodeSetDTM;
import org.apache.xpath.XPathContext;


public class XNodeSetForDOM extends XNodeSet
{
  Object m_origObj;

  public XNodeSetForDOM(Node node, DTMManager dtmMgr)
  {
    m_dtmMgr = dtmMgr;
    m_origObj = node;
    int dtmHandle = dtmMgr.getDTMHandleFromNode(node);
    m_obj = new NodeSetDTM(dtmMgr);
    ((NodeSetDTM) m_obj).addNode(dtmHandle);
  }
  
  
  public XNodeSetForDOM(XNodeSet val)
  {
  	super(val);
  	if(val instanceof XNodeSetForDOM)
    	m_origObj = ((XNodeSetForDOM)val).m_origObj;
  }
  
  public XNodeSetForDOM(NodeList nodeList, XPathContext xctxt)
  {
    m_dtmMgr = xctxt.getDTMManager();
    m_origObj = nodeList;

    
    
    
    
    org.apache.xpath.NodeSetDTM nsdtm=new org.apache.xpath.NodeSetDTM(nodeList, xctxt);
    m_last=nsdtm.getLength();
    m_obj = nsdtm;   
  }

  public XNodeSetForDOM(NodeIterator nodeIter, XPathContext xctxt)
  {
    m_dtmMgr = xctxt.getDTMManager();
    m_origObj = nodeIter;

    
    
    
    
    org.apache.xpath.NodeSetDTM nsdtm=new org.apache.xpath.NodeSetDTM(nodeIter, xctxt);
    m_last=nsdtm.getLength();
    m_obj = nsdtm;   
  }
  
  
  public Object object()
  {
    return m_origObj;
  }
  
  
  public NodeIterator nodeset() throws javax.xml.transform.TransformerException
  {
    return (m_origObj instanceof NodeIterator) 
                   ? (NodeIterator)m_origObj : super.nodeset();      
  }
  
  
  public NodeList nodelist() throws javax.xml.transform.TransformerException
  {
    return (m_origObj instanceof NodeList) 
                   ? (NodeList)m_origObj : super.nodelist();      
  }



}"
org.apache.xalan.xsltc.compiler.util.VoidType,8,2,0,14,19,28,1,14,7,2.0,82,0.0,0,0.825,0.375,2,3,9.25,2,1.25,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.Constants;

public final class VoidType extends Type {
    protected VoidType() {}

    public String toString() {
	return ""void"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""V"";
    }

    public org.apache.bcel.generic.Type toJCType() {
	return null;	
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.String) {
	    translateTo(classGen, methodGen, (StringType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    StringType type) {
	final InstructionList il = methodGen.getInstructionList();
	il.append(new PUSH(classGen.getConstantPool(), """"));
    }

    
    public void translateFrom(ClassGenerator classGen, MethodGenerator methodGen, 
			      Class clazz) {
	if (!clazz.getName().equals(""void"")) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }
}
"
org.apache.xpath.functions.FuncNumber,2,5,0,4,5,1,0,4,2,2.0,12,0.0,0,0.982142857,0.75,2,7,5.0,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xpath.res.XPATHErrorResources;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XNumber;
import org.apache.xpath.objects.XNodeSet;


public class FuncNumber extends FunctionDef1Arg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return new XNumber(getArg0AsNumber(xctxt));
  }
}
"
org.apache.xpath.patterns.UnionPattern,9,2,0,12,20,0,4,10,8,0.125,212,1.0,1,0.789473684,0.197530864,1,7,22.44444444,7,2.4444,0,"
package org.apache.xpath.patterns;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.objects.XObject;


public class UnionPattern extends Expression
{

  
  private StepPattern[] m_patterns;
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    for (int i = 0; i < m_patterns.length; i++) 
    {
      m_patterns[i].fixupVariables(vars, globalsSize);
    }
  }

  
  
   public boolean canTraverseOutsideSubtree()
   {
     if(null != m_patterns)
     {
      int n = m_patterns.length;
      for (int i = 0; i < n; i++) 
      {
        if(m_patterns[i].canTraverseOutsideSubtree())
          return true;
      }
     }
     return false;
   }

  
  public void setPatterns(StepPattern[] patterns)
  {
    m_patterns = patterns;
    if(null != patterns)
    {
    	for(int i = 0; i < patterns.length; i++)
    	{
    		patterns[i].exprSetParent(this);
    	}
    }
    
  }

  
  public StepPattern[] getPatterns()
  {
    return m_patterns;
  }

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    XObject bestScore = null;
    int n = m_patterns.length;

    for (int i = 0; i < n; i++)
    {
      XObject score = m_patterns[i].execute(xctxt);

      if (score != NodeTest.SCORE_NONE)
      {
        if (null == bestScore)
          bestScore = score;
        else if (score.num() > bestScore.num())
          bestScore = score;
      }
    }

    if (null == bestScore)
    {
      bestScore = NodeTest.SCORE_NONE;
    }

    return bestScore;
  }
  
  class UnionPathPartOwner implements ExpressionOwner
  {
  	int m_index;
  	
  	UnionPathPartOwner(int index)
  	{
  		m_index = index;
  	}
  	
    
    public Expression getExpression()
    {
      return m_patterns[m_index];
    }


    
    public void setExpression(Expression exp)
    {
    	exp.exprSetParent(UnionPattern.this);
    	m_patterns[m_index] = (StepPattern)exp;
    }
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	visitor.visitUnionPattern(owner, this);
  	if(null != m_patterns)
  	{
  		int n = m_patterns.length;
  		for(int i = 0; i < n; i++)
  		{
  			m_patterns[i].callVisitors(new UnionPathPartOwner(i), visitor);
  		}
  	}
  }
  
  
  public boolean deepEquals(Expression expr)
  {
  	if(!isSameClass(expr))
  		return false;
  		
  	UnionPattern up = (UnionPattern)expr;
  		
  	if(null != m_patterns)
  	{
  		int n = m_patterns.length;
  		if((null == up.m_patterns) || (up.m_patterns.length != n))
  			return false;
  			
  		for(int i = 0; i < n; i++)
  		{
  			if(!m_patterns[i].deepEquals(up.m_patterns[i]))
  				return false;
  		}
  	}
  	else if(up.m_patterns != null)
  		return false;
  		
  	return true;
  	
  }



}
"
org.apache.xalan.transformer.KeyTable,5,1,0,10,15,2,1,9,4,0.5,68,1.0,1,0.0,0.342857143,0,0,12.2,1,0.8,1,"
package org.apache.xalan.transformer;

import java.util.Hashtable;
import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.QName;
import org.apache.xml.utils.XMLString;
import org.apache.xpath.XPathContext;
import org.apache.xpath.objects.XNodeSet;


public class KeyTable
{

  
  private int m_docKey;

  
  public int getDocKey()
  {
    return m_docKey;
  }

  
  private XNodeSet m_keyNodes;
  
  KeyIterator getKeyIterator()
  {
  	return (KeyIterator)(m_keyNodes.getContainedIter());
  }

  
  public KeyTable(
          int doc, PrefixResolver nscontext, QName name, Vector keyDeclarations, XPathContext xctxt)
            throws javax.xml.transform.TransformerException
  {

    m_docKey = doc;
    KeyIterator ki = new KeyIterator(name, keyDeclarations);
    
    m_keyNodes = new XNodeSet(ki);
    m_keyNodes.allowDetachToRelease(false);
    
    m_keyNodes.setRoot(doc, xctxt);

  }  

  
  public XNodeSet getNodeSetDTMByKey(QName name, XMLString ref)
  {
  	Vector keyDecls = getKeyIterator().getKeyDeclarations();
  	org.apache.xml.dtm.DTMIterator keyNodes = m_keyNodes.iter();
	XNodeSet refNodes = new XNodeSet( new KeyRefIterator(name, ref, keyDecls, keyNodes) );
	
	
	return refNodes;

  }

  
  public QName getKeyTableName()
  {
    return getKeyIterator().getName();
  }
  
}
"
org.apache.xalan.xsltc.compiler.LocalNameCall,3,5,0,12,13,3,0,12,3,2.0,50,0.0,0,0.99,0.533333333,3,5,15.66666667,1,0.3333,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class LocalNameCall extends NameBase {

    
    public LocalNameCall(QName fname) {
	super(fname);
    }

    
    public LocalNameCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	final int getNodeName = cpg.addInterfaceMethodref(DOM_INTF,
							  ""getNodeName"",
							  ""(I)""+STRING_SIG);

	final int getLocalName = cpg.addMethodref(BASIS_LIBRARY_CLASS,
						  ""getLocalName"",
						  ""(Ljava/lang/String;)""+
						  ""Ljava/lang/String;"");
	super.translate(classGen, methodGen);
	il.append(new INVOKEINTERFACE(getNodeName, 2));
	il.append(new INVOKESTATIC(getLocalName));
    }
}
"
org.apache.xalan.xsltc.cmdline.getopt.GetOptsException,1,3,2,3,2,0,3,0,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.apache.xalan.xsltc.cmdline.getopt; 

public class GetOptsException extends Exception{
    public GetOptsException(String msg){
	super(msg);
    }
}
"
org.apache.xalan.xsltc.dom.NodeCounter,15,1,3,9,39,91,5,4,7,0.811688312,824,0.818181818,3,0.0,0.267857143,0,0,52.46666667,14,3.4667,0,"

package org.apache.xalan.xsltc.dom;

import java.util.Vector;
import org.apache.xalan.xsltc.DOM;
import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.dom.Axis;

public abstract class NodeCounter implements Axis {
    public static final int END = DOM.NULL;

    protected int _node = END;
    protected int _nodeType = DOM.FIRST_TYPE - 1;
    protected int _value = Integer.MIN_VALUE;

    public final DOM          _document;
    public final NodeIterator _iterator;
    public final Translet     _translet;

    protected String _format;
    protected String _lang;
    protected String _letterValue;
    protected String _groupSep;
    protected int    _groupSize;

    private boolean separFirst = true;
    private boolean separLast = false;
    private Vector separToks = null;
    private Vector formatToks = null;
    private int nSepars  = 0;
    private int nFormats = 0;

    private static String[] Thousands = 
        {"""", ""m"", ""mm"", ""mmm"" };
    private static String[] Hundreds = 
	{"""", ""c"", ""cc"", ""ccc"", ""cd"", ""d"", ""dc"", ""dcc"", ""dccc"", ""cm""};
    private static String[] Tens = 
	{"""", ""x"", ""xx"", ""xxx"", ""xl"", ""l"", ""lx"", ""lxx"", ""lxxx"", ""xc""};
    private static String[] Ones = 
	{"""", ""i"", ""ii"", ""iii"", ""iv"", ""v"", ""vi"", ""vii"", ""viii"", ""ix""};

    protected NodeCounter(Translet translet,
			  DOM document, NodeIterator iterator) {
	_translet = translet;
	_document = document;
	_iterator = iterator;
    }

    
    abstract public NodeCounter setStartNode(int node);

    
    public NodeCounter setValue(int value) {
	_value = value;
	return this;
    }

    
    protected void setFormatting(String format, String lang, String letterValue,
				 String groupSep, String groupSize) {
	_lang = lang;
	_format = format;
	_groupSep = groupSep;
	_letterValue = letterValue;

	try {
	    _groupSize = Integer.parseInt(groupSize);
	}
	catch (NumberFormatException e) {
	    _groupSize = 0;
	}

	final int length = _format.length();
	boolean isFirst = true;
	separFirst = true;
	separLast = false;

        separToks = new Vector();
        formatToks = new Vector();

	
	for (int j = 0, i = 0; i < length;) {
            char c = _format.charAt(i);
            for (j = i; Character.isLetterOrDigit(c);) {
                if (++i == length) break;
		c = _format.charAt(i);
            }
            if (i > j) {
                if (isFirst) {
                    separToks.addElement(""."");
                    isFirst = separFirst = false;
                }
                formatToks.addElement(_format.substring(j, i));
            }

            if (i == length) break;

            c = _format.charAt(i);
            for (j = i; !Character.isLetterOrDigit(c);) {
                if (++i == length) break;
                c = _format.charAt(i);
                isFirst = false;
            }
            if (i > j) {
                separToks.addElement(_format.substring(j, i));
            }
        }

	nSepars = separToks.size();
	nFormats = formatToks.size(); 
	if (nSepars > nFormats) separLast = true;

	if (separFirst) nSepars--;
	if (separLast) nSepars--;
	if (nSepars == 0) {
	    separToks.insertElementAt(""."", 1);
 	    nSepars++;
	}
	if (separFirst) nSepars ++;
    }

    
    public NodeCounter setDefaultFormatting() {
	setFormatting(""1"", ""en"", ""alphabetic"", null, null);
	return this;
    }

    
    abstract public String getCounter();

    
    public String getCounter(String format, String lang, String letterValue,
			     String groupSep, String groupSize) {
	setFormatting(format, lang, letterValue, groupSep, groupSize);
	return getCounter();
    }

    
    public boolean matchesCount(int node) {
	return _nodeType == _document.getType(node);
    }

    
    public boolean matchesFrom(int node) {
	return false;
    }

    
    protected String formatNumbers(int value) {
	return formatNumbers(new int[] { value });
    }

    
    protected String formatNumbers(int[] values) {
	final int nValues = values.length;
	final int length = _format.length();

	boolean isEmpty = true;
	for (int i = 0; i < nValues; i++)
	    if (values[i] != Integer.MIN_VALUE)
		isEmpty = false;
	if (isEmpty) return("""");

	
	boolean isFirst = true;
	int t = 0, n = 0, s = 1;
	final StringBuffer buffer = new StringBuffer();

	
	if (separFirst) buffer.append((String)separToks.elementAt(0));

	
	while (n < nValues) {
	    final int value = values[n];
	    if (value != Integer.MIN_VALUE) {
		if (!isFirst) buffer.append((String) separToks.elementAt(s++));
		formatValue(value, (String)formatToks.elementAt(t++), buffer);
		if (t == nFormats) t--;
		if (s >= nSepars) s--;
		isFirst = false;
	    }
	    n++;
	}

	
	if (separLast) buffer.append((String)separToks.lastElement());
	return buffer.toString();
    }

    
    private void formatValue(int value, String format, StringBuffer buffer) {

        char c = format.charAt(0);
        if (Character.isDigit(c)) {
            char zero = (char)(c - Character.getNumericValue(c));

            StringBuffer temp = buffer;
            if (_groupSize > 0) {
                temp = new StringBuffer();
            }
            String s = """";
            int n = value;
            while (n > 0) {
                s = (char) ((int) zero + (n % 10)) + s;
                n = n / 10;
            }
                
            for (int i = 0; i < format.length() - s.length(); i++) {
                temp.append(zero);
            }
            temp.append(s);
            
            if (_groupSize > 0) {
                for (int i = 0; i < temp.length(); i++) {
                    if (i != 0 && ((temp.length() - i) % _groupSize) == 0) {
                        buffer.append(_groupSep);
                    }
                    buffer.append(temp.charAt(i));
                }
            }
        } 
	else if (c == 'i' && !_letterValue.equals(""alphabetic"")) {
            buffer.append(romanValue(value));
        } 
	else if (c == 'I' && !_letterValue.equals(""alphabetic"")) {
            buffer.append(romanValue(value).toUpperCase());
        } 
	else {
            int min = (int) c;
            int max = (int) c;
            while (Character.isLetterOrDigit((char) (max+1))) {
		max++;
	    }
            buffer.append(alphaValue(value, min, max));
        }
    }

    private String alphaValue(int value, int min, int max) {
        if (value <= 0) {
	    return """" + value;
	}

        int range = max - min + 1;
        char last = (char)(((value-1) % range) + min);
        if (value > range) {
            return alphaValue((value-1) / range, min, max) + last;
        } 
	else {
            return """" + last;
        }
    }

    private String romanValue(int n) {
        if (n <= 0 || n > 4000) {
	    return """" + n;
	}
        return
	    Thousands[n / 1000] +
	    Hundreds[(n / 100) % 10] +
	    Tens[(n/10) % 10] +
	    Ones[n % 10];
    }
}

"
org.apache.xpath.functions.FuncExtElementAvailable,2,4,0,10,17,1,0,10,2,2.0,87,0.0,0,0.979591837,0.75,2,7,42.5,1,0.5,0,"
package org.apache.xpath.functions;

import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.QName;
import org.apache.xalan.extensions.ExtensionsTable;
import org.apache.xalan.templates.Constants;
import org.apache.xalan.transformer.TransformerImpl;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.ExtensionsProvider;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class FuncExtElementAvailable extends FunctionOneArg
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {

    String prefix;
    String namespace;
    String methName;

    String fullName = m_arg0.execute(xctxt).str();
    int indexOfNSSep = fullName.indexOf(':');

    if (indexOfNSSep < 0)
    {
      prefix = """";
      namespace = Constants.S_XSLNAMESPACEURL;
      methName = fullName;
    }
    else
    {
      prefix = fullName.substring(0, indexOfNSSep);
      namespace = xctxt.getNamespaceContext().getNamespaceForPrefix(prefix);
      if (null == namespace)
        return XBoolean.S_FALSE;
      methName= fullName.substring(indexOfNSSep + 1);
    }

    if (namespace.equals(Constants.S_XSLNAMESPACEURL)
    ||  namespace.equals(Constants.S_BUILTIN_EXTENSIONS_URL))
    {
      try
      {
        TransformerImpl transformer = (TransformerImpl) xctxt.getOwnerObject();
        return transformer.getStylesheet().getAvailableElements().containsKey(
                                                            new QName(namespace, methName))
               ? XBoolean.S_TRUE : XBoolean.S_FALSE;
      }
      catch (Exception e)
      {
        return XBoolean.S_FALSE;
      }
    }
    else
    {
      
      ExtensionsProvider extProvider = (ExtensionsProvider)xctxt.getOwnerObject();
      return extProvider.elementAvailable(namespace, methName)
             ? XBoolean.S_TRUE : XBoolean.S_FALSE;
    }
  }
}
"
org.apache.xml.dtm.DTMManager,21,1,2,43,49,196,36,8,17,0.975,299,0.4,1,0.0,0.15,0,0,12.76190476,10,1.3333,1,"
package org.apache.xml.dtm;

import java.io.IOException;
import java.io.File;
import java.io.FileInputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.BufferedReader;

import java.util.Properties;
import java.util.Enumeration;

import org.apache.xml.utils.PrefixResolver;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;

import org.apache.xalan.res.XSLMessages;
import org.apache.xalan.res.XSLTErrorResources;


public abstract class DTMManager
{

  
  private static final String defaultPropName =
    ""org.apache.xml.dtm.DTMManager"";

  
  protected XMLStringFactory m_xsf = null;

  
  protected DTMManager(){}

  
  public XMLStringFactory getXMLStringFactory()
  {
    return m_xsf;
  }

  
  public void setXMLStringFactory(XMLStringFactory xsf)
  {
    m_xsf = xsf;
  }

  
  public static DTMManager newInstance(XMLStringFactory xsf) 
           throws DTMConfigurationException
  {

    String classname = findFactory(defaultPropName,
                                   ""org.apache.xml.dtm.ref.DTMManagerDefault"");

    if (classname == null)
    {
      throw new DTMConfigurationException(XSLMessages.createMessage(XSLTErrorResources.ER_NO_DEFAULT_IMPL, null)); 
    }

    DTMManager factoryImpl;

    try
    {
      Class clazz = Class.forName(classname);

      factoryImpl = (DTMManager) clazz.newInstance();
    }
    catch (ClassNotFoundException cnfe)
    {
      throw new DTMConfigurationException(cnfe);
    }
    catch (IllegalAccessException iae)
    {
      throw new DTMConfigurationException(iae);
    }
    catch (InstantiationException ie)
    {
      throw new DTMConfigurationException(ie);
    }
    factoryImpl.setXMLStringFactory(xsf);

    return factoryImpl;
  }

  
  public abstract DTM getDTM(javax.xml.transform.Source source,
                             boolean unique, DTMWSFilter whiteSpaceFilter,
                             boolean incremental, boolean doIndexing);

  
  public abstract DTM getDTM(int nodeHandle);

  
  public abstract int getDTMHandleFromNode(org.w3c.dom.Node node);

  
  public abstract DTM createDocumentFragment();

  
  public abstract boolean release(DTM dtm, boolean shouldHardDelete);

  
  public abstract DTMIterator createDTMIterator(Object xpathCompiler,
          int pos);

  
  public abstract DTMIterator createDTMIterator(String xpathString,
          PrefixResolver presolver);

  
  public abstract DTMIterator createDTMIterator(int whatToShow,
          DTMFilter filter, boolean entityReferenceExpansion);

  
  public abstract DTMIterator createDTMIterator(int node);
  
  
  public static boolean m_incremental = false;  
  
  
  public synchronized static boolean getIncremental()
  {
    return m_incremental;  
  }
  
  
  public synchronized static void setIncremental(boolean incremental)
  {
    m_incremental = incremental;  
  }
  
  

  

  
  private static String foundFactory = null;

  
  private static boolean debug;

  static
  {
    try
    {
      debug = System.getProperty(""dtm.debug"") != null;
    }
    catch (SecurityException ex){}
  }

  
  private static String findFactory(String factoryId, String defaultFactory)
  {

    
    try
    {
      String systemProp = null;

      try
      {
        systemProp = System.getProperty(factoryId);
      }
      catch (SecurityException se){}

      if (systemProp != null)
      {
        if (debug)
        {
          System.err.println(""DTM: found system property"" + systemProp);
        }

        return systemProp;
      }
    }
    catch (SecurityException se){}

    if (foundFactory != null)
    {
      return foundFactory;
    }

    
    try
    {
      String javah = System.getProperty(""java.home"");
      String configFile = javah + File.separator + ""lib"" + File.separator
                          + ""jaxp.properties"";
      File f = new File(configFile);

      if (f.exists())
      {
        Properties props = new Properties();

        props.load(new FileInputStream(f));

        foundFactory = props.getProperty(factoryId);

        if (debug)
        {
          System.err.println(""DTM: found java.home property "" + foundFactory);
        }

        if (foundFactory != null)
        {
          return foundFactory;
        }
      }
    }
    catch (Exception ex)
    {
      if (debug)
      {
        ex.printStackTrace();
      }
    }

    String serviceId = ""META-INF/services/"" + factoryId;

    
    try
    {
      ClassLoader cl = DTMManager.class.getClassLoader();
      InputStream is = null;

      if (cl == null)
      {
        is = ClassLoader.getSystemResourceAsStream(serviceId);
      }
      else
      {
        is = cl.getResourceAsStream(serviceId);
      }

      if (is != null)
      {
        if (debug)
        {
          System.err.println(""DTM: found  "" + serviceId);
        }

        BufferedReader rd = new BufferedReader(new InputStreamReader(is, ""UTF-8""));

        foundFactory = rd.readLine();

        rd.close();

        if (debug)
        {
          System.err.println(""DTM: loaded from services: "" + foundFactory);
        }

        if ((foundFactory != null) &&!"""".equals(foundFactory))
        {
          return foundFactory;
        }
      }
    }
    catch (Exception ex)
    {
      if (debug)
      {
        ex.printStackTrace();
      }
    }

    return defaultFactory;
  }


  
  public static final int IDENT_DTM_NODE_BITS = 16;
    

  
  public static final int IDENT_NODE_DEFAULT = (1<<IDENT_DTM_NODE_BITS)-1;


  
  public static final int IDENT_DTM_DEFAULT = ~IDENT_NODE_DEFAULT;

  
  public static final int IDENT_MAX_DTMS = (IDENT_DTM_DEFAULT >>> IDENT_DTM_NODE_BITS) + 1;


  
  public abstract int getDTMIdentity(DTM dtm);

  
  public int getDTMIdentityMask()
  {
    return IDENT_DTM_DEFAULT;
  }

  
  public int getNodeIdentityMask()
  {
    return IDENT_NODE_DEFAULT;
  }

}
"
org.apache.xalan.xsltc.ProcessorVersion,3,1,0,0,9,1,0,0,2,0.5,44,1.0,0,0.0,0.5,0,0,12.66666667,2,0.6667,0,"

package org.apache.xalan.xsltc;



public class ProcessorVersion {
    private static int MAJOR = 1;
    private static int MINOR = 0;
    private static int DELTA = 0;

    public static void main(String[] args) {
	System.out.println(""XSLTC version "" + MAJOR + ""."" + MINOR +
	    ((DELTA > 0) ? ("".""+DELTA) : ("""")));
    }
}
"
org.apache.xpath.objects.XBooleanStatic,2,4,0,5,5,0,3,3,2,0.0,25,0.0,0,0.987341772,0.666666667,2,3,11.0,2,1.0,0,"
package org.apache.xpath.objects;

import org.w3c.dom.*;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;


public class XBooleanStatic extends XBoolean
{

  
  boolean m_val;

  
  public XBooleanStatic(boolean b)
  {

    super(b);

    m_val = b;
  }

  
  public boolean equals(XObject obj2)
  {
    try
    {
      return m_val == obj2.bool();
    }
    catch(javax.xml.transform.TransformerException te)
    {
      throw new org.apache.xml.utils.WrappedRuntimeException(te);
    }
  }
}
"
org.apache.xalan.transformer.TransformerClient,1,1,0,2,1,0,1,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xalan.transformer;


public interface TransformerClient
{

  
  void setTransformState(TransformState ts);
}
"
org.apache.xpath.functions.FuncStartsWith,2,5,0,7,6,1,0,7,2,2.0,21,0.0,0,0.98245614,0.75,1,6,9.5,1,0.5,0,"
package org.apache.xpath.functions;



import java.util.Vector;

import org.apache.xpath.XPathContext;
import org.apache.xpath.XPath;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XBoolean;


public class FuncStartsWith extends Function2Args
{

  
  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException
  {
    return m_arg0.execute(xctxt).xstr().startsWith(m_arg1.execute(xctxt).xstr())
           ? XBoolean.S_TRUE : XBoolean.S_FALSE;
  }
}
"
org.apache.xalan.lib.sql.DTMDocument,95,4,2,15,191,0,2,13,66,0.920621931,2509,1.0,2,0.5,0.197894737,1,25,25.27368421,11,2.0421,2,"

package org.apache.xalan.lib.sql;

import org.apache.xml.dtm.DTMManager;
import org.apache.xml.dtm.DTMWSFilter;
import org.apache.xml.dtm.ref.DTMDefaultBaseIterators;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMAxisIterator;
import org.apache.xml.utils.XMLString;
import org.apache.xml.utils.XMLStringFactory;
import org.apache.xml.utils.SuballocatedIntVector;
import org.w3c.dom.Node;
import org.xml.sax.ext.DeclHandler;
import org.xml.sax.ErrorHandler;
import org.xml.sax.DTDHandler;
import org.xml.sax.EntityResolver;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.ContentHandler;
import java.io.IOException;
import java.io.File;
import java.io.PrintStream;
import java.io.FileOutputStream;
import org.xml.sax.*;
import javax.xml.transform.SourceLocator;
import org.apache.xml.utils.*;
import org.apache.xml.dtm.*;
import org.xml.sax.ext.*;


public class DTMDocument extends DTMDefaultBaseIterators
{

  
  public interface CharacterNodeHandler
  {
    
    public void characters( Node node )throws org.xml.sax.SAXException ;
  }

  
  private boolean DEBUG = false;

  
  protected static final String S_NAMESPACE = ""http:

  
  protected static final String S_ATTRIB_NOT_SUPPORTED = ""Not Supported"";
  
  protected static final String S_ISTRUE = ""true"";
  
  protected static final String S_ISFALSE = ""false"";

  
  protected static final String S_DOCUMENT = ""#root"";
  
  protected static final String S_TEXT_NODE = ""#text"";
  
  protected static final String S_ELEMENT_NODE = ""#element"";

  
  protected int m_Document_TypeID = 0;
  
  protected int m_TextNode_TypeID = 0;


  
  protected ObjectArray m_ObjectArray = new ObjectArray();

  
  protected SuballocatedIntVector m_attribute;

  
  protected int m_DocumentIdx;


  
  public DTMDocument( DTMManager mgr, int ident )
  {
    super(mgr, null, ident,
      null, mgr.getXMLStringFactory(), true);

    m_attribute = new SuballocatedIntVector(m_initialblocksize);
  }

  
  private int allocateNodeObject( Object o )
  {
    
    m_size++;
    return m_ObjectArray.append(o);
  }

  
  protected int addElementWithData( Object o, int level, int extendedType, int parent, int prevsib )
  {
    int elementIdx = addElement(level,extendedType,parent,prevsib);

    int data = allocateNodeObject(o);
    m_firstch.setElementAt(data,elementIdx);

    m_exptype.setElementAt(m_TextNode_TypeID, data);
    
    m_parent.setElementAt(elementIdx, data);

    m_prevsib.setElementAt(DTM.NULL, data);
    m_nextsib.setElementAt(DTM.NULL, data);
    m_attribute.setElementAt(DTM.NULL, data);
    m_firstch.setElementAt(DTM.NULL, data);

    return elementIdx;
  }

  
  protected int addElement( int level, int extendedType, int parent, int prevsib )
  {
    int node = DTM.NULL;

    try
    {
      
      node = allocateNodeObject(S_ELEMENT_NODE);

      m_exptype.setElementAt(extendedType, node);
      m_nextsib.setElementAt(DTM.NULL, node);
      m_prevsib.setElementAt(prevsib, node);

      m_parent.setElementAt(parent, node);
      m_firstch.setElementAt(DTM.NULL, node);
      
      m_attribute.setElementAt(DTM.NULL, node);

      if (prevsib != DTM.NULL)
      {
        
        
        if (m_nextsib.elementAt(prevsib) != DTM.NULL)
          m_nextsib.setElementAt(m_nextsib.elementAt(prevsib), node);

        
        m_nextsib.setElementAt(node, prevsib);
      }

       
      
      
      
      
      if ((parent != DTM.NULL) && (m_prevsib.elementAt(node) == DTM.NULL))
      {
        m_firstch.setElementAt(node, parent);
      }
    }
    catch(Exception e)
    {
      error(""Error in addElement: ""+e.getMessage());
    }

    return node;
  }

  
  protected int addAttributeToNode( Object o, int extendedType, int pnode )
  {
    int attrib = DTM.NULL;
    int prevsib = DTM.NULL;
    int lastattrib = DTM.NULL;
    int value = DTM.NULL;

    try
    {
      
      attrib = allocateNodeObject(o);

      m_attribute.setElementAt(DTM.NULL, attrib);
      m_exptype.setElementAt(extendedType, attrib);
      

      
      m_nextsib.setElementAt(DTM.NULL, attrib);
      m_prevsib.setElementAt(DTM.NULL,attrib);
      
      
      
      m_parent.setElementAt(pnode, attrib);
      m_firstch.setElementAt(DTM.NULL, attrib);

      if (m_attribute.elementAt(pnode) != DTM.NULL)
      {
        
        
        lastattrib = m_attribute.elementAt(pnode);
        m_nextsib.setElementAt(lastattrib, attrib);
        m_prevsib.setElementAt(attrib, lastattrib);
      }
      
      
      m_attribute.setElementAt(attrib, pnode);
    }
    catch(Exception e)
    {
      error(""Error in addAttributeToNode: ""+e.getMessage());
    }

    return attrib;
  }

  
  protected void cloneAttributeFromNode( int toNode, int fromNode )
  {
   try
    {
      if (m_attribute.elementAt(toNode) != DTM.NULL)
      {
        error(""Cloneing Attributes, where from Node already had addtibures assigned"");
      }

      m_attribute.setElementAt(m_attribute.elementAt(fromNode), toNode);
    }
    catch(Exception e)
    {
      error(""Cloning attributes"");
    }
  }


  
  public int getFirstAttribute( int parm1 )
  {
    if (DEBUG) System.out.println(""getFirstAttribute(""+ parm1+"")"");
    int nodeIdx = makeNodeIdentity(parm1);
    if (nodeIdx != DTM.NULL)
    {
      int attribIdx =  m_attribute.elementAt(nodeIdx);
      return makeNodeHandle(attribIdx);
    }
    else return DTM.NULL;
  }

 
  public String getNodeValue( int parm1 )
  {
    if (DEBUG) System.out.println(""getNodeValue("" + parm1 + "")"");
    try
    {
      Object o = m_ObjectArray.getAt(makeNodeIdentity(parm1));
      if (o != null)
      {
        return o.toString();
      }
      else
      {
        return """";
      }
    }
    catch(Exception e)
    {
      error(""Getting String Value"");
      return null;
    }
  }


  
  public XMLString getStringValue( int parm1 )
  {
    int nodeIdx = makeNodeIdentity(parm1);
    if (DEBUG) System.out.println(""getStringValue("" + nodeIdx + "")"");
    try
    {
      Object o = m_ObjectArray.getAt(nodeIdx);
      if (o != null)
      {
        return m_xstrf.newstr(o.toString());
      }
      else
      {
        return m_xstrf.emptystr();
      }
    }
    catch(Exception e)
    {
      error(""Getting String Value"");
      return null;
    }
  }


  
  public int getNextAttribute( int parm1 )
  {
    int nodeIdx = makeNodeIdentity(parm1);
    if (DEBUG) System.out.println(""getNextAttribute("" + nodeIdx + "")"");
    if (nodeIdx != DTM.NULL) return makeNodeHandle(m_nextsib.elementAt(nodeIdx));
    else return DTM.NULL;
  }


  
  protected int getNumberOfNodes( )
  {
    if (DEBUG) System.out.println(""getNumberOfNodes()"");
    return m_size;
  }

  
  protected boolean nextNode( )
  {
    if (DEBUG) System.out.println(""nextNode()"");
    return false;
  }


  
  protected void createExpandedNameTable( )
  {
    m_Document_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_DOCUMENT, DTM.DOCUMENT_NODE);

    m_TextNode_TypeID =
      m_expandedNameTable.getExpandedTypeID(S_NAMESPACE, S_TEXT_NODE, DTM.TEXT_NODE);
  }


  
  public void dumpDTM( )
  {
    try
    {

      File f = new File(""DTMDump.txt"");
      System.err.println(""Dumping... ""+f.getAbsolutePath());
      PrintStream ps = new PrintStream(new FileOutputStream(f));

      while (nextNode()){}

      int nRecords = m_size;

      ps.println(""Total nodes: "" + nRecords);

      for (int i = 0; i < nRecords; i++)
      {
        ps.println(""=========== "" + i + "" ==========="");
        ps.println(""NodeName: "" + getNodeName(makeNodeHandle(i)));
        ps.println(""NodeNameX: "" + getNodeNameX(makeNodeHandle(i)));
        ps.println(""LocalName: "" + getLocalName(makeNodeHandle(i)));
        ps.println(""NamespaceURI: "" + getNamespaceURI(makeNodeHandle(i)));
        ps.println(""Prefix: "" + getPrefix(makeNodeHandle(i)));

        int exTypeID = getExpandedTypeID(makeNodeHandle(i));

        ps.println(""Expanded Type ID: ""
                           + Integer.toHexString(exTypeID));

        int type = getNodeType(makeNodeHandle(i));
        String typestring;

        switch (type)
        {
        case DTM.ATTRIBUTE_NODE :
          typestring = ""ATTRIBUTE_NODE"";
          break;
        case DTM.CDATA_SECTION_NODE :
          typestring = ""CDATA_SECTION_NODE"";
          break;
        case DTM.COMMENT_NODE :
          typestring = ""COMMENT_NODE"";
          break;
        case DTM.DOCUMENT_FRAGMENT_NODE :
          typestring = ""DOCUMENT_FRAGMENT_NODE"";
          break;
        case DTM.DOCUMENT_NODE :
          typestring = ""DOCUMENT_NODE"";
          break;
        case DTM.DOCUMENT_TYPE_NODE :
          typestring = ""DOCUMENT_NODE"";
          break;
        case DTM.ELEMENT_NODE :
          typestring = ""ELEMENT_NODE"";
          break;
        case DTM.ENTITY_NODE :
          typestring = ""ENTITY_NODE"";
          break;
        case DTM.ENTITY_REFERENCE_NODE :
          typestring = ""ENTITY_REFERENCE_NODE"";
          break;
        case DTM.NAMESPACE_NODE :
          typestring = ""NAMESPACE_NODE"";
          break;
        case DTM.NOTATION_NODE :
          typestring = ""NOTATION_NODE"";
          break;
        case DTM.NULL :
          typestring = ""NULL"";
          break;
        case DTM.PROCESSING_INSTRUCTION_NODE :
          typestring = ""PROCESSING_INSTRUCTION_NODE"";
          break;
        case DTM.TEXT_NODE :
          typestring = ""TEXT_NODE"";
          break;
        default :
          typestring = ""Unknown!"";
          break;
        }

        ps.println(""Type: "" + typestring);

        int firstChild = _firstch(i);

        if (DTM.NULL == firstChild)
          ps.println(""First child: DTM.NULL"");
        else if (NOTPROCESSED == firstChild)
          ps.println(""First child: NOTPROCESSED"");
        else
          ps.println(""First child: "" + firstChild);

        int prevSibling = _prevsib(i);

        if (DTM.NULL == prevSibling)
          ps.println(""Prev sibling: DTM.NULL"");
        else if (NOTPROCESSED == prevSibling)
          ps.println(""Prev sibling: NOTPROCESSED"");
        else
          ps.println(""Prev sibling: "" + prevSibling);

        int nextSibling = _nextsib(i);

        if (DTM.NULL == nextSibling)
          ps.println(""Next sibling: DTM.NULL"");
        else if (NOTPROCESSED == nextSibling)
          ps.println(""Next sibling: NOTPROCESSED"");
        else
          ps.println(""Next sibling: "" + nextSibling);

        int parent = _parent(i);

        if (DTM.NULL == parent)
          ps.println(""Parent: DTM.NULL"");
        else if (NOTPROCESSED == parent)
          ps.println(""Parent: NOTPROCESSED"");
        else
          ps.println(""Parent: "" + parent);

        int level = _level(i);

        ps.println(""Level: "" + level);
        ps.println(""Node Value: "" + getNodeValue(i));
        ps.println(""String Value: "" + getStringValue(i));

        ps.println(""First Attribute Node: "" + m_attribute.elementAt(i));
      }

    }
    catch(IOException ioe)
    {
      ioe.printStackTrace(System.err);
      System.exit(-1);
    }
  }


  
  protected static void dispatchNodeData( Node node, ContentHandler ch, int depth )throws org.xml.sax.SAXException
  {

    switch (node.getNodeType())
    {
    case Node.DOCUMENT_FRAGMENT_NODE :
    case Node.DOCUMENT_NODE :
    case Node.ELEMENT_NODE :
    {
      for (Node child = node.getFirstChild(); null != child;
              child = child.getNextSibling())
      {
        dispatchNodeData(child, ch, depth+1);
      }
    }
    break;
    case Node.PROCESSING_INSTRUCTION_NODE : 
    case Node.COMMENT_NODE :
      if(0 != depth)
        break;
        
        
    case Node.TEXT_NODE :
    case Node.CDATA_SECTION_NODE :
    case Node.ATTRIBUTE_NODE :
      String str = node.getNodeValue();
      if(ch instanceof CharacterNodeHandler)
      {
        ((CharacterNodeHandler)ch).characters(node);
      }
      else
      {
        ch.characters(str.toCharArray(), 0, str.length());
      }
      break;



    default :
      
      break;
    }
  }

  
  
  
  
  


  
  public void setProperty( String property, Object value )
  {
  }

  
  public SourceLocator getSourceLocatorFor( int node )
  {
    return null;
  }

  
  protected int getNextNodeIdentity( int parm1 )
  {
    if (DEBUG) System.out.println(""getNextNodeIdenty("" + parm1 + "")"");
    return DTM.NULL;
  }

  
  public int getAttributeNode( int parm1, String parm2, String parm3 )
  {
    if (DEBUG)
    {
      System.out.println(
        ""getAttributeNode("" +
        parm1 + "","" +
        parm2 + "","" +
        parm3 + "")"");
    }
    return DTM.NULL;
  }

  
  public String getLocalName( int parm1 )
  {

      int exID = getExpandedTypeID(parm1);

    if (DEBUG)
    {
      DEBUG = false;
      System.out.print(""getLocalName("" + parm1 + "") -> "");
      System.out.println(""..."" + getLocalNameFromExpandedNameID(exID) );
      DEBUG = true;
    }

    return getLocalNameFromExpandedNameID(exID);
  }

  
  public String getNodeName( int parm1 )
  {

    int exID = getExpandedTypeID( parm1 );
    if (DEBUG)
    {
      DEBUG = false;
      System.out.print(""getLocalName("" + parm1 + "") -> "");
      System.out.println(""..."" + getLocalNameFromExpandedNameID(exID) );
      DEBUG = true;
    }
    return getLocalNameFromExpandedNameID(exID);
  }

   
  public boolean isAttributeSpecified( int parm1 )
  {
    if (DEBUG) System.out.println(""isAttributeSpecified("" + parm1 + "")"");
    return false;
  }

  
  public String getUnparsedEntityURI( String parm1 )
  {
    if (DEBUG) System.out.println(""getUnparsedEntityURI("" + parm1 + "")"");
    return """";
  }

  
  public DTDHandler getDTDHandler( )
  {
    if (DEBUG) System.out.println(""getDTDHandler()"");
    return null;
  }

  
  public String getPrefix( int parm1 )
  {
    if (DEBUG) System.out.println(""getPrefix("" + parm1  + "")"");
    return """";
  }

  
  public EntityResolver getEntityResolver( )
  {
    if (DEBUG) System.out.println(""getEntityResolver()"");
    return null;
  }

  
  public String getDocumentTypeDeclarationPublicIdentifier( )
  {
    if (DEBUG) System.out.println(""get_DTD_PubId()"");
    return """";
  }

  
  public LexicalHandler getLexicalHandler( )
  {
    if (DEBUG) System.out.println(""getLexicalHandler()"");
    return null;
  }
  
  public boolean needsTwoThreads( )
  {
    if (DEBUG) System.out.println(""needsTwoThreads()"");
    return false;
  }

  
  public ContentHandler getContentHandler( )
  {
    if (DEBUG) System.out.println(""getContentHandler()"");
    return null;
  }

  
  public void dispatchToEvents( int parm1, ContentHandler parm2 )throws org.xml.sax.SAXException
  {
    if (DEBUG)
    {
      System.out.println(
      ""dispathcToEvents("" +
      parm1 + "","" +
      parm2 + "")"");
    }
    return;
  }

  
  public String getNamespaceURI( int parm1 )
  {
    if (DEBUG) System.out.println(""getNamespaceURI("" +parm1+"")"");
    return """";
  }

  
  public void dispatchCharactersEvents( int nodeHandle, ContentHandler ch, boolean normalize )throws org.xml.sax.SAXException
  {
    if (DEBUG)
    {
      System.out.println(""dispatchCharacterEvents("" +
      nodeHandle + "","" +
      ch + "","" +
      normalize + "")"");
    }

    if(normalize)
    {
      XMLString str = getStringValue(nodeHandle);
      str = str.fixWhiteSpace(true, true, false);
      str.dispatchCharactersEvents(ch);
    }
    else
    {
      int type = getNodeType(nodeHandle);
      Node node = getNode(nodeHandle);
      dispatchNodeData(node, ch, 0);
    }
  }

  
  public boolean supportsPreStripping( )
  {
    if (DEBUG) System.out.println(""supportsPreStripping()"");
    return super.supportsPreStripping();
  }

  
  protected int _exptype( int parm1 )
  {
    if (DEBUG) System.out.println(""_exptype("" + parm1 + "")"");
    return super._exptype( parm1);
  }

  
  protected SuballocatedIntVector findNamespaceContext( int parm1 )
  {
    if (DEBUG) System.out.println(""SuballocatedIntVector("" + parm1 + "")"");
    return super.findNamespaceContext( parm1);
  }

  
  protected int _prevsib( int parm1 )
  {
    if (DEBUG) System.out.println(""_prevsib("" + parm1+ "")"");
    return super._prevsib( parm1);
  }


  
  protected short _type( int parm1 )
  {
    if (DEBUG) System.out.println(""_type("" + parm1 + "")"");
    return super._type( parm1);
  }

  
  public Node getNode( int parm1 )
  {
    if (DEBUG) System.out.println(""getNode("" + parm1 + "")"");
    return super.getNode( parm1);
  }

  
  public int getPreviousSibling( int parm1 )
  {
    if (DEBUG) System.out.println(""getPrevSib("" + parm1 + "")"");
    return super.getPreviousSibling( parm1);
  }

  
  public String getDocumentStandalone( int parm1 )
  {
    if (DEBUG) System.out.println(""getDOcStandAlone("" + parm1 + "")"");
    return super.getDocumentStandalone( parm1);
  }

  
  public String getNodeNameX( int parm1 )
  {
    if (DEBUG) System.out.println(""getNodeNameX("" + parm1 + "")"");
    
    return getNodeName(parm1);

  }

  
  public void setFeature( String parm1, boolean parm2 )
  {
    if (DEBUG)
    {
      System.out.println(
        ""setFeature("" +
        parm1 + "","" +
        parm2 + "")"");
    }
    super.setFeature( parm1,  parm2);
  }

  
  protected int _parent( int parm1 )
  {
    if (DEBUG) System.out.println(""_parent("" + parm1 + "")"");
    return super._parent( parm1);
  }

  
  protected void indexNode( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""indexNode(""+parm1+"",""+parm2+"")"");
    super.indexNode( parm1,  parm2);
  }

  
  protected boolean getShouldStripWhitespace( )
  {
    if (DEBUG) System.out.println(""getShouldStripWS()"");
    return super.getShouldStripWhitespace();
  }

  
  protected void popShouldStripWhitespace( )
  {
    if (DEBUG) System.out.println(""popShouldStripWS()"");
    super.popShouldStripWhitespace();
  }

  
  public boolean isNodeAfter( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""isNodeAfter("" + parm1 + "","" + parm2 + "")"");
    return super.isNodeAfter( parm1,  parm2);
  }

  
  public int getNamespaceType( int parm1 )
  {
    if (DEBUG) System.out.println(""getNamespaceType("" + parm1 + "")"");
    return super.getNamespaceType( parm1);
  }

  
  protected int _level( int parm1 )
  {
    if (DEBUG) System.out.println(""_level("" + parm1 + "")"");
    return super._level( parm1);
  }


  
  protected void pushShouldStripWhitespace( boolean parm1 )
  {
    if (DEBUG) System.out.println(""push_ShouldStripWS("" + parm1 + "")"");
    super.pushShouldStripWhitespace( parm1);
  }

  
  public String getDocumentVersion( int parm1 )
  {
    if (DEBUG) System.out.println(""getDocVer(""+parm1+"")"");
    return super.getDocumentVersion( parm1);
  }

  
  public boolean isSupported( String parm1, String parm2 )
  {
    if (DEBUG) System.out.println(""isSupported(""+parm1+"",""+parm2+"")"");
    return super.isSupported( parm1,  parm2);
  }


  
  protected void setShouldStripWhitespace( boolean parm1 )
  {
    if (DEBUG) System.out.println(""set_ShouldStripWS(""+parm1+"")"");
    super.setShouldStripWhitespace( parm1);
  }


  
  protected void ensureSizeOfIndex( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""ensureSizeOfIndex(""+parm1+"",""+parm2+"")"");
    super.ensureSizeOfIndex( parm1,  parm2);
  }

  
  protected void ensureSize( int parm1 )
  {
    if (DEBUG) System.out.println(""ensureSize(""+parm1+"")"");

    
    
    
  }

  
  public String getDocumentEncoding( int parm1 )
  {
    if (DEBUG) System.out.println(""getDocumentEncoding(""+parm1+"")"");
    return super.getDocumentEncoding( parm1);
  }

  
  public void appendChild( int parm1, boolean parm2, boolean parm3 )
  {
    if (DEBUG)
    {
      System.out.println(
        ""appendChild("" +
        parm1 + "","" +
        parm2 + "","" +
        parm3 + "")"");
    }
    super.appendChild( parm1,  parm2,  parm3);
  }

  
  public short getLevel( int parm1 )
  {
    if (DEBUG) System.out.println(""getLevel(""+parm1+"")"");
    return super.getLevel( parm1);
  }

  
  public String getDocumentBaseURI( )
  {
    if (DEBUG) System.out.println(""getDocBaseURI()"");
    return super.getDocumentBaseURI();
  }

  
  public int getNextNamespaceNode( int parm1, int parm2, boolean parm3 )
  {
    if (DEBUG)
    {
      System.out.println(
      ""getNextNamesapceNode("" +
      parm1 + "","" +
      parm2 + "","" +
      parm3 + "")"");
    }
    return super.getNextNamespaceNode( parm1,  parm2,  parm3);
  }

  
  public void appendTextChild( String parm1 )
  {
    if (DEBUG) System.out.println(""appendTextChild("" + parm1 + "")"");
    super.appendTextChild( parm1);
  }

  
  protected int findGTE( int[] parm1, int parm2, int parm3, int parm4 )
  {
    if (DEBUG)
    {
      System.out.println(
      ""findGTE(""+
      parm1 + "","" +
      parm2 + "","" +
      parm3 + "")"");
    }
    return super.findGTE( parm1,  parm2,  parm3,  parm4);
  }

  
  public int getFirstNamespaceNode( int parm1, boolean parm2 )
  {
    if (DEBUG) System.out.println(""getFirstNamespaceNode()"");
    return super.getFirstNamespaceNode( parm1,  parm2);
  }

  
  public int getStringValueChunkCount( int parm1 )
  {
    if (DEBUG) System.out.println(""getStringChunkCount("" + parm1 + "")"");
    return super.getStringValueChunkCount( parm1);
  }

  
  public int getLastChild( int parm1 )
  {
    if (DEBUG) System.out.println(""getLastChild("" + parm1 + "")"");
    return super.getLastChild( parm1);
  }

  
  public boolean hasChildNodes( int parm1 )
  {
    if (DEBUG) System.out.println(""hasChildNodes("" + parm1 + "")"");
    return super.hasChildNodes( parm1);
  }

  
  public short getNodeType( int parm1 )
  {
    if (DEBUG)
    {
      DEBUG=false;
      System.out.print(""getNodeType("" + parm1 + "") "");
      int exID = getExpandedTypeID(parm1);
      String name = getLocalNameFromExpandedNameID(exID);
      System.out.println(
        "".. Node name ["" + name + ""]"" +
        ""["" + getNodeType( parm1) + ""]"");

      DEBUG=true;
    }

    return super.getNodeType( parm1);
  }

  
  public boolean isCharacterElementContentWhitespace( int parm1 )
  {
    if (DEBUG) System.out.println(""isCharacterElementContentWhitespace("" + parm1 +"")"");
    return super.isCharacterElementContentWhitespace( parm1);
  }

  
  public int getFirstChild( int parm1 )
  {
    if (DEBUG) System.out.println(""getFirstChild("" + parm1 + "")"");
    return super.getFirstChild( parm1);
  }

  
  public String getDocumentSystemIdentifier( int parm1 )
  {
    if (DEBUG) System.out.println(""getDocSysID("" + parm1 + "")"");
    return super.getDocumentSystemIdentifier( parm1);
  }

  
  protected void declareNamespaceInContext( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""declareNamespaceContext(""+parm1+"",""+parm2+"")"");
    super.declareNamespaceInContext( parm1,  parm2);
  }

  
  public String getNamespaceFromExpandedNameID( int parm1 )
  {
    if (DEBUG)
    {
      DEBUG = false;
      System.out.print(""getNamespaceFromExpandedNameID(""+parm1+"")"");
      System.out.println(""..."" + super.getNamespaceFromExpandedNameID( parm1) );
      DEBUG = true;
    }
    return super.getNamespaceFromExpandedNameID( parm1);
  }

  
  public String getLocalNameFromExpandedNameID( int parm1 )
  {
    if (DEBUG)
    {
      DEBUG = false;
      System.out.print(""getLocalNameFromExpandedNameID(""+parm1+"")"");
      System.out.println(""..."" + super.getLocalNameFromExpandedNameID( parm1));
      DEBUG = true;
    }
    return super.getLocalNameFromExpandedNameID( parm1);
  }

  
  public int getExpandedTypeID( int parm1 )
  {
    if (DEBUG) System.out.println(""getExpandedTypeID(""+parm1+"")"");
    return super.getExpandedTypeID( parm1);
  }

  
  public int getDocument( )
  {
    if (DEBUG) System.out.println(""getDocument()"");
    return super.getDocument();
  }


  
  protected int findInSortedSuballocatedIntVector( SuballocatedIntVector parm1, int parm2 )
  {
    if (DEBUG)
    {
      System.out.println(
      ""findInSortedSubAlloctedVector("" +
      parm1 + "","" +
      parm2 + "")"");
    }
    return super.findInSortedSuballocatedIntVector( parm1,  parm2);
  }

  
  public boolean isDocumentAllDeclarationsProcessed( int parm1 )
  {
    if (DEBUG) System.out.println(""isDocumentAllDeclProc(""+parm1+"")"");
    return super.isDocumentAllDeclarationsProcessed( parm1);
  }

  
  protected void error( String parm1 )
  {
    if (DEBUG) System.out.println(""error(""+parm1+"")"");
    super.error( parm1);
  }


  
  protected int _firstch( int parm1 )
  {
    if (DEBUG) System.out.println(""_firstch(""+parm1+"")"");
    return super._firstch( parm1);
  }

  
  public int getOwnerDocument( int parm1 )
  {
    if (DEBUG) System.out.println(""getOwnerDoc(""+parm1+"")"");
    return super.getOwnerDocument( parm1);
  }

  
  protected int _nextsib( int parm1 )
  {
    if (DEBUG) System.out.println(""_nextSib(""+parm1+"")"");
    return super._nextsib( parm1);
  }

  
  public int getNextSibling( int parm1 )
  {
    if (DEBUG) System.out.println(""getNextSibling(""+parm1+"")"");
    return super.getNextSibling( parm1);
  }


  
  public boolean getDocumentAllDeclarationsProcessed( )
  {
    if (DEBUG) System.out.println(""getDocAllDeclProc()"");
    return super.getDocumentAllDeclarationsProcessed();
  }

  
  public int getParent( int parm1 )
  {
    if (DEBUG) System.out.println(""getParent(""+parm1+"")"");
    return super.getParent( parm1);
  }

  
  public int getExpandedTypeID( String parm1, String parm2, int parm3 )
  {
    if (DEBUG) System.out.println(""getExpandedTypeID()"");
    return super.getExpandedTypeID( parm1,  parm2,  parm3);
  }

  
  public void setDocumentBaseURI( String parm1 )
  {
    if (DEBUG) System.out.println(""setDocBaseURI()"");
    super.setDocumentBaseURI( parm1);
  }

  
  public char[] getStringValueChunk( int parm1, int parm2, int[] parm3 )
  {
    if (DEBUG)
    {
      System.out.println(""getStringChunkValue("" +
      parm1 + "","" +
      parm2 + "")"");
    }
    return super.getStringValueChunk( parm1,  parm2,  parm3);
  }

  
  public DTMAxisTraverser getAxisTraverser( int parm1 )
  {
    if (DEBUG) System.out.println(""getAxixTraverser(""+parm1+"")"");
    return super.getAxisTraverser( parm1);
  }

  
  public DTMAxisIterator getTypedAxisIterator( int parm1, int parm2 )
  {
    if (DEBUG) System.out.println(""getTypedAxisIterator(""+parm1+"",""+parm2+"")"");
    return super.getTypedAxisIterator( parm1,  parm2);
  }

  
  public DTMAxisIterator getAxisIterator( int parm1 )
  {
    if (DEBUG) System.out.println(""getAxisIterator(""+parm1+"")"");
    return super.getAxisIterator( parm1);
  }
  
  public int getElementById( String parm1 )
  {
    if (DEBUG) System.out.println(""getElementByID(""+parm1+"")"");
    return DTM.NULL;
  }

  
  public DeclHandler getDeclHandler( )
  {
    if (DEBUG) System.out.println(""getDeclHandler()"");
    return null;
  }

  
  public ErrorHandler getErrorHandler( )
  {
    if (DEBUG) System.out.println(""getErrorHandler()"");
    return null;
  }

  
  public String getDocumentTypeDeclarationSystemIdentifier( )
  {
    if (DEBUG) System.out.println(""get_DTD-SID()"");
    return null;
  }


}
"
org.apache.xpath.operations.String,2,3,0,5,4,1,1,4,2,2.0,9,0.0,0,0.975609756,0.75,1,1,3.5,1,0.5,0,"
package org.apache.xpath.operations;

import org.apache.xpath.objects.XObject;
import org.apache.xpath.objects.XString;


public class String extends UnaryOperation
{

  
  public XObject operate(XObject right) throws javax.xml.transform.TransformerException
  {
    return (XString)right.xstr(); 
  }
}
"
org.apache.xalan.xsltc.compiler.Predicate,21,3,0,65,104,68,6,64,20,0.765,1066,1.0,4,0.78021978,0.210884354,2,8,49.28571429,12,3.1429,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.ArrayList;

import org.apache.bcel.classfile.JavaClass;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.xalan.xsltc.compiler.util.ReferenceType;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;
import org.apache.bcel.classfile.Field;

final class Predicate extends Expression implements Closure {

    private Expression _exp = null; 
    private boolean _nthPositionFilter = false;
    private boolean _nthDescendant = false;
    private boolean _canOptimize = true;
    private int     _ptype = -1;

    private String _className = null;
    private ArrayList _closureVars = null;
    private Closure _parentClosure = null;

    public Predicate(Expression exp) {
	(_exp = exp).setParent(this);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_exp.setParser(parser);
    }

    public boolean isNthDescendant() {
	return _nthDescendant;
    }

    public boolean isNthPositionFilter() {
	return _nthPositionFilter;
    }

    public void dontOptimize() {
	_canOptimize = false;
    }

    

    
    public boolean inInnerClass() {
	return (_className != null);
    }

    
    public Closure getParentClosure() {
	if (_parentClosure == null) {
	    SyntaxTreeNode node = getParent();
	    do {
		if (node instanceof Closure) {
		    _parentClosure = (Closure) node;
		    break;
		}
		if (node instanceof TopLevelElement) {
		    break;	
		}
		node = node.getParent();
	    } while (node != null);
	}
	return _parentClosure;
    }

    
    public String getInnerClassName() {
	return _className;
    }

    
    public void addVariable(VariableRefBase variableRef) {
	if (_closureVars == null) {
	    _closureVars = new ArrayList();
	}

	
	if (!_closureVars.contains(variableRef)) {
	    _closureVars.add(variableRef);

	    
	    Closure parentClosure = getParentClosure();
	    if (parentClosure != null) {
		parentClosure.addVariable(variableRef);
	    }
	}
    }

    

    public int getPosType() {
	if (_ptype == -1) {
	    SyntaxTreeNode parent = getParent();
	    if (parent instanceof StepPattern) {
		_ptype = ((StepPattern)parent).getNodeType();
	    }
	    else if (parent instanceof AbsoluteLocationPath) {
		AbsoluteLocationPath path = (AbsoluteLocationPath)parent;
		Expression exp = path.getPath();
		if (exp instanceof Step) {
		    _ptype = ((Step)exp).getNodeType();
		}
	    }
	    else if (parent instanceof VariableRefBase) {
		final VariableRefBase ref = (VariableRefBase)parent;
		final VariableBase var = ref.getVariable();
		final Expression exp = var.getExpression();
		if (exp instanceof Step) {
		    _ptype = ((Step)exp).getNodeType();
		}
	    }
	    else if (parent instanceof Step) {
		_ptype = ((Step)parent).getNodeType();
	    }
	}
	return _ptype;
    }

    public boolean parentIsPattern() {
	return (getParent() instanceof Pattern);
    }

    public Expression getExpr() {
	return _exp;
    }

    public String toString() {
	if (isNthPositionFilter())
	    return ""pred(["" + _exp + ""],""+getPosType()+"")"";
	else
	    return ""pred("" + _exp + ')';
    }
	
    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {

	Type texp = _exp.typeCheck(stable);

	
	if (texp instanceof ReferenceType) {
	    _exp = new CastExpr(_exp, texp = Type.Real);
	}

	
	
	
	if (texp instanceof ResultTreeType) {
	    _exp = new CastExpr(_exp, Type.Boolean);
	    _exp = new CastExpr(_exp, Type.Real);
	    texp = _exp.typeCheck(stable);
	}

	
	if (texp instanceof NumberType) {

	    
	    if (texp instanceof IntType == false) {
		_exp = new CastExpr(_exp, Type.Int);
	    }

	    SyntaxTreeNode parent = getParent();

	    
	    if ((_exp instanceof LastCall) ||
		(parent instanceof Pattern) ||
		(parent instanceof FilterExpr)) {

		final QName position = getParser().getQNameIgnoreDefaultNs(""position"");
		final PositionCall positionCall = new PositionCall(position);
		positionCall.setParser(getParser());
		positionCall.setParent(this);

		_exp = new EqualityExpr(EqualityExpr.EQ, positionCall, _exp);
		if (_exp.typeCheck(stable) != Type.Boolean) {
		    _exp = new CastExpr(_exp, Type.Boolean);
		}

		if (parent instanceof Pattern) {
 		    _nthPositionFilter = true;
		}
		else if (parent instanceof FilterExpr) {
		    FilterExpr filter = (FilterExpr)parent;
		    Expression fexp = filter.getExpr();

		    if (fexp instanceof KeyCall)
			_canOptimize = false;
		    else if (fexp instanceof VariableRefBase)
		        _canOptimize = false;
		    else if (fexp instanceof ParentLocationPath)
			_canOptimize = false;
		    else if (fexp instanceof UnionPathExpr)
			_canOptimize = false;
		    else if (_exp.hasPositionCall() && _exp.hasLastCall())
			_canOptimize = false;
		    else if (filter.getParent() instanceof FilterParentPath)
			_canOptimize = false;
		    if (_canOptimize)
			_nthPositionFilter = true;
		}
		return _type = Type.Boolean;
	    }
	    
	    else {
		if ((parent != null) && (parent instanceof Step)) {
		    parent = parent.getParent();
		    if ((parent != null) &&
			(parent instanceof AbsoluteLocationPath)) {
			
			_nthDescendant = true;
			return _type = Type.NodeSet;
		    }
		}
		_nthPositionFilter = true;
		return _type = Type.NodeSet;
	    }
	}
	else if (texp instanceof BooleanType) {
	    if (_exp.hasPositionCall())
		_nthPositionFilter = true;
	}
	
	else {
	    _exp = new CastExpr(_exp, Type.Boolean);
	}
	_nthPositionFilter = false;

	return _type = Type.Boolean;
    }
	
    
    private void compileFilter(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	TestGenerator testGen;
	LocalVariableGen local;
	FilterGenerator filterGen;

	_className = getXSLTC().getHelperClassName();
	filterGen = new FilterGenerator(_className,
					""java.lang.Object"",
					toString(), 
					ACC_PUBLIC | ACC_SUPER,
					new String[] {
					    CURRENT_NODE_LIST_FILTER
					},
					classGen.getStylesheet());	

	final ConstantPoolGen cpg = filterGen.getConstantPool();
	final int length = (_closureVars == null) ? 0 : _closureVars.size();

	
	for (int i = 0; i < length; i++) {
	    VariableBase var = ((VariableRefBase) _closureVars.get(i)).getVariable();

	    filterGen.addField(new Field(ACC_PUBLIC, 
					cpg.addUtf8(var.getVariable()),
					cpg.addUtf8(var.getType().toSignature()),
					null, cpg.getConstantPool()));
	}

	final InstructionList il = new InstructionList();
	testGen = new TestGenerator(ACC_PUBLIC | ACC_FINAL,
				    org.apache.bcel.generic.Type.BOOLEAN, 
				    new org.apache.bcel.generic.Type[] {
					org.apache.bcel.generic.Type.INT,
					org.apache.bcel.generic.Type.INT,
					org.apache.bcel.generic.Type.INT,
					org.apache.bcel.generic.Type.INT,
					Util.getJCRefType(TRANSLET_SIG),
					Util.getJCRefType(NODE_ITERATOR_SIG)
				    },
				    new String[] {
					""node"",
					""position"",
					""last"",
					""current"",
					""translet"",
					""iterator""
				    },
				    ""test"", _className, il, cpg);
		
	
	local = testGen.addLocalVariable(""document"",
					 Util.getJCRefType(DOM_INTF_SIG),
					 null, null);
	final String className = classGen.getClassName();
	il.append(filterGen.loadTranslet());
	il.append(new CHECKCAST(cpg.addClass(className)));
	il.append(new GETFIELD(cpg.addFieldref(className,
					       DOM_FIELD, DOM_INTF_SIG)));
	il.append(new ASTORE(local.getIndex()));

	
	testGen.setDomIndex(local.getIndex());

	_exp.translate(filterGen, testGen);
	il.append(IRETURN);
	
	testGen.stripAttributes(true);
	testGen.setMaxLocals();
	testGen.setMaxStack();
	testGen.removeNOPs();
	filterGen.addEmptyConstructor(ACC_PUBLIC);
	filterGen.addMethod(testGen.getMethod());
		
	getXSLTC().dumpClass(filterGen.getJavaClass());
    }

    
    public boolean isBooleanTest() {
	return (_exp instanceof BooleanExpr);
    }

    
    public boolean isNodeValueTest() {
	if (!_canOptimize) return false;
	return (getStep() != null && getCompareValue() != null);
    }

    private Expression _value = null;
    private Step _step = null;

    
    public Expression getCompareValue() {
	if (_value != null) return _value;
	if (_exp == null) return null;

	if (_exp instanceof EqualityExpr) {
	    EqualityExpr exp = (EqualityExpr)_exp;
	    Expression left = exp.getLeft();
	    Expression right = exp.getRight();

	    Type tleft = left.getType();
	    Type tright = right.getType();

	    
	    if (left instanceof CastExpr) left = ((CastExpr)left).getExpr();
	    if (right instanceof CastExpr) right = ((CastExpr)right).getExpr();
	    
	    try {
		if ((tleft == Type.String) && (!(left instanceof Step)))
		    _value = exp.getLeft();
		if (left instanceof VariableRefBase) 
		    _value = new CastExpr(left, Type.String);
		if (_value != null) return _value;
	    }
	    catch (TypeCheckError e) { }

	    try {
		if ((tright == Type.String) && (!(right instanceof Step)))
		    _value = exp.getRight();
		if (right instanceof VariableRefBase)
		    _value = new CastExpr(right, Type.String);
		if (_value != null) return _value;
	    }
	    catch (TypeCheckError e) { }

	}
	return null;
    }

    
    public Step getStep() {
	if (_step != null) return _step;
	if (_exp == null) return null;

	if (_exp instanceof EqualityExpr) {
	    EqualityExpr exp = (EqualityExpr)_exp;
	    Expression left = exp.getLeft();
	    Expression right = exp.getRight();

	    if (left instanceof CastExpr) left = ((CastExpr)left).getExpr();
	    if (left instanceof Step) _step = (Step)left;
	    
	    if (right instanceof CastExpr) right = ((CastExpr)right).getExpr();
	    if (right instanceof Step) _step = (Step)right;
	}
	return _step;
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {

	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (_nthPositionFilter || _nthDescendant) {
	    _exp.translate(classGen, methodGen);
	}
	else if (isNodeValueTest() && (getParent() instanceof Step)) {
	    _value.translate(classGen, methodGen);
	    il.append(new CHECKCAST(cpg.addClass(STRING_CLASS)));
	    il.append(new PUSH(cpg, ((EqualityExpr)_exp).getOp()));
	}
	else {
	    translateFilter(classGen, methodGen);
	}
    }

    
    public void translateFilter(ClassGenerator classGen,
				MethodGenerator methodGen) 
    {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	
	compileFilter(classGen, methodGen);
	
	
	il.append(new NEW(cpg.addClass(_className)));
	il.append(DUP);
	il.append(new INVOKESPECIAL(cpg.addMethodref(_className,
						     ""<init>"", ""()V"")));

	
	final int length = (_closureVars == null) ? 0 : _closureVars.size();

	for (int i = 0; i < length; i++) {
	    VariableRefBase varRef = (VariableRefBase) _closureVars.get(i);
	    VariableBase var = varRef.getVariable();
	    Type varType = var.getType();

	    il.append(DUP);

	    
	    Closure variableClosure = _parentClosure;
	    while (variableClosure != null) {
		if (variableClosure.inInnerClass()) break;
		variableClosure = variableClosure.getParentClosure();
	    }

	    
	    if (variableClosure != null) {
		il.append(ALOAD_0);
		il.append(new GETFIELD(
		    cpg.addFieldref(variableClosure.getInnerClassName(), 
			var.getVariable(), varType.toSignature())));
	    }
	    else {
		
		il.append(var.loadInstruction());
	    }

	    
	    il.append(new PUTFIELD(
		    cpg.addFieldref(_className, var.getVariable(), 
			varType.toSignature())));
	}
    }
}
"
org.apache.xml.utils.Trie,3,1,0,2,8,0,2,1,3,0.75,100,0.0,1,0.0,0.666666667,0,0,31.66666667,4,2.3333,0,"
package org.apache.xml.utils;


public class Trie
{

  
  public static final int ALPHA_SIZE = 128;

  
  Node m_Root;

  
  public Trie()
  {
    m_Root = new Node();
  }

  
  public Object put(String key, Object value)
  {

    final int len = key.length();
    Node node = m_Root;

    for (int i = 0; i < len; i++)
    {
      Node nextNode = node.m_nextChar[Character.toUpperCase(key.charAt(i))];

      if (nextNode != null)
      {
        node = nextNode;
      }
      else
      {
        for (; i < len; i++)
        {
          Node newNode = new Node();

          node.m_nextChar[Character.toUpperCase(key.charAt(i))] = newNode;
          node = newNode;
        }

        break;
      }
    }

    Object ret = node.m_Value;

    node.m_Value = value;

    return ret;
  }

  
  public Object get(String key)
  {

    final int len = key.length();
    Node node = m_Root;

    for (int i = 0; i < len; i++)
    {
      try
      {
        node = node.m_nextChar[Character.toUpperCase(key.charAt(i))];
      }
      catch (ArrayIndexOutOfBoundsException e)
      {

        
        node = null;
      }

      if (node == null)
        return null;
    }

    return node.m_Value;
  }

  
  class Node
  {

    
    Node()
    {
      m_nextChar = new Node[ALPHA_SIZE];
      m_Value = null;
    }

    
    Node m_nextChar[];

    
    Object m_Value;
  }
}
"
org.apache.xml.utils.StringBufferPool,5,1,0,6,13,4,4,2,3,0.75,44,0.5,1,0.0,0.25,0,0,7.4,1,0.6,0,"
package org.apache.xml.utils;


public class StringBufferPool
{

  
  private static ObjectPool m_stringBufPool =
    new ObjectPool(org.apache.xml.utils.FastStringBuffer.class);

  
  public synchronized static FastStringBuffer get()
  {
    return (FastStringBuffer) m_stringBufPool.getInstance();
  }

  
  public synchronized static void free(FastStringBuffer sb)
  {
    
    
    
    sb.setLength(0);
    m_stringBufPool.freeInstance(sb);
  }
}
"
org.apache.xalan.templates.AVTPartSimple,5,2,0,6,7,4,1,5,5,0.5,22,1.0,0,0.555555556,0.325,0,0,3.2,1,0.8,0,"
package org.apache.xalan.templates;



import org.apache.xpath.XPathContext;
import org.apache.xml.utils.FastStringBuffer;


public class AVTPartSimple extends AVTPart
{

  
  private String m_val;

  
  public AVTPartSimple(String val)
  {
    m_val = val;
  }

  
  public String getSimpleString()
  {
    return m_val;
  }
  
  
  public void fixupVariables(java.util.Vector vars, int globalsSize)
  {
    
  }


  
  public void evaluate(XPathContext xctxt, FastStringBuffer buf,
                       int context,
                       org.apache.xml.utils.PrefixResolver nsNode)
  {
    buf.append(m_val);
  }
  
  public void callVisitors(XSLTVisitor visitor)
  {
  	
  }


}
"
org.apache.xalan.xsltc.trax.TransformerFactoryImpl,27,3,0,11,87,201,5,10,24,0.783653846,697,1.0,0,0.444444444,0.171328671,1,2,24.51851852,3,1.0741,2,"

package org.apache.xalan.xsltc.trax;

import java.io.File;
import java.io.Reader;
import java.io.InputStream;
import java.io.ByteArrayInputStream;
import java.net.URL;
import java.net.MalformedURLException;
import java.util.Vector;
import java.util.Hashtable;
import java.util.Properties;

import javax.xml.transform.*;
import javax.xml.transform.sax.*;
import javax.xml.transform.dom.*;
import javax.xml.transform.stream.*;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.*;
import org.w3c.dom.Document;

import org.apache.xalan.xsltc.Translet;
import org.apache.xalan.xsltc.runtime.AbstractTranslet;

import org.apache.xalan.xsltc.compiler.XSLTC;
import org.apache.xalan.xsltc.compiler.SourceLoader;
import org.apache.xalan.xsltc.compiler.CompilerException;
import org.apache.xalan.xsltc.compiler.util.ErrorMsg;


public class TransformerFactoryImpl
    extends SAXTransformerFactory implements SourceLoader, ErrorListener 
{
    
    private ErrorListener _errorListener = this; 

    
    private URIResolver _uriResolver = null;

    
    protected static String _defaultTransletName = ""GregorSamsa"";

    
    private Hashtable _piParams = null;

    
    private class PIParamWrapper {
	public String _media = null;
	public String _title = null;
	public String _charset = null;
	
	public PIParamWrapper(String media, String title, String charset) {
	    _media = media;
	    _title = title;
	    _charset = charset;
	}
    }

    
    private boolean _debug = false;

    
    private boolean _disableInlining = false;

    
    private int _indentNumber = -1;

    
    private XMLReader _xmlReader = null;

    
    public TransformerFactoryImpl() {
    }

    
    public void setErrorListener(ErrorListener listener) 
	throws IllegalArgumentException 
    {
	if (listener == null) {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.ERROR_LISTENER_NULL_ERR,
					""TransformerFactory"");
            throw new IllegalArgumentException(err.toString());
	}
	_errorListener = listener;
    }

    
    public ErrorListener getErrorListener() { 
	return _errorListener;
    }

    
    public Object getAttribute(String name) 
	throws IllegalArgumentException 
    { 
	
	if (name.equals(""translet-name"")) {
	    return _defaultTransletName;
	}

	
	ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_INVALID_ATTR_ERR, name);
	throw new IllegalArgumentException(err.toString());
    }

    
    public void setAttribute(String name, Object value) 
	throws IllegalArgumentException 
    { 
	
	
	if (name.equals(""translet-name"") && value instanceof String) {
	    _defaultTransletName = (String) value;
	    return;
	}
	else if (name.equals(""debug"")) {
	    if (value instanceof Boolean) {
		_debug = ((Boolean) value).booleanValue();
		return;
	    }
	    else if (value instanceof String) {
		_debug = ((String) value).equalsIgnoreCase(""true"");
		return;
	    }
	}
	else if (name.equals(""disable-inlining"")) {
	    if (value instanceof Boolean) {
		_disableInlining = ((Boolean) value).booleanValue();
		return;
	    }
	    else if (value instanceof String) {
		_disableInlining = ((String) value).equalsIgnoreCase(""true"");
		return;
	    }
	}
	else if (name.equals(""indent-number"")) {
	    if (value instanceof String) {
		try {
		    _indentNumber = Integer.parseInt((String) value);
		    return;
		}
		catch (NumberFormatException e) {
		    
		}
	    }
	    else if (value instanceof Integer) {
		_indentNumber = ((Integer) value).intValue();
		return;
	    }
	}

	
	final ErrorMsg err 
	    = new ErrorMsg(ErrorMsg.JAXP_INVALID_ATTR_ERR, name);
	throw new IllegalArgumentException(err.toString());
    }

    
    public boolean getFeature(String name) { 
	
	String[] features = {
	    DOMSource.FEATURE,
	    DOMResult.FEATURE,
	    SAXSource.FEATURE,
	    SAXResult.FEATURE,
	    StreamSource.FEATURE,
	    StreamResult.FEATURE
	};

	
	for (int i =0; i < features.length; i++) {
	    if (name.equals(features[i])) {
		return true;
	    }
	}
	
	return false;
    }

        
    public URIResolver getURIResolver() {
	return _uriResolver;
    } 

        
    public void setURIResolver(URIResolver resolver) {
	_uriResolver = resolver;
    }

    
    public Source getAssociatedStylesheet(Source source, String media,
					  String title, String charset)
	throws TransformerConfigurationException 
    {
	
	if (_piParams == null) {
	    _piParams = new Hashtable();
	}
	
	_piParams.put(source, new PIParamWrapper(media, title, charset));
	
	return source;
    }

        
    public Transformer newTransformer()
	throws TransformerConfigurationException 
    { 
	TransformerImpl result = new TransformerImpl(new Properties(), 
	    _indentNumber, this);
	if (_uriResolver != null) {
	    result.setURIResolver(_uriResolver);
	}
	return result;
    }

    
    public Transformer newTransformer(Source source) throws
	TransformerConfigurationException 
    {
	final Templates templates = newTemplates(source);
	final Transformer transformer = templates.newTransformer();
	if (_uriResolver != null) {
	    transformer.setURIResolver(_uriResolver);
	}
	return(transformer);
    }

    
    private void passWarningsToListener(Vector messages) 
	throws TransformerException 
    {
	if (_errorListener == null || messages == null) {
	    return;
	}
	
	final int count = messages.size();
	for (int pos = 0; pos < count; pos++) {
	    String message = messages.elementAt(pos).toString();
	    _errorListener.error(
		new TransformerConfigurationException(message));
	}
    }

    
    private void passErrorsToListener(Vector messages) {
	try {
	    if (_errorListener == null || messages == null) {
		return;
	    }
	    
	    final int count = messages.size();
	    for (int pos = 0; pos < count; pos++) {
		String message = messages.elementAt(pos).toString();
		_errorListener.error(new TransformerException(message));
	    }
	}
	catch (TransformerException e) {
	    
	}
    }

    
    public Templates newTemplates(Source source)
	throws TransformerConfigurationException 
    {
	
	final XSLTC xsltc = new XSLTC();
	if (_debug) xsltc.setDebug(true);
	if (_disableInlining) xsltc.setTemplateInlining(false);
	xsltc.init();

	
	if (_uriResolver != null) {
	    xsltc.setSourceLoader(this);
	}

	
	
	if ((_piParams != null) && (_piParams.get(source) != null)) {
	    
	    PIParamWrapper p = (PIParamWrapper)_piParams.get(source);
	    
	    if (p != null) {
		xsltc.setPIParameters(p._media, p._title, p._charset);
	    }
	}

	
	final InputSource input = Util.getInputSource(xsltc, source);
	byte[][] bytecodes = xsltc.compile(null, input);
	final String transletName = xsltc.getClassName();

	
	if (_errorListener != this) {
	    try {
		passWarningsToListener(xsltc.getWarnings());
	    }
	    catch (TransformerException e) {
		throw new TransformerConfigurationException(e);
	    }
	}
	else {
	    xsltc.printWarnings();
	}

	
	if (bytecodes == null) {
	    
	    if (_errorListener != null) {
		passErrorsToListener(xsltc.getErrors());
	    }
	    else {
		xsltc.printErrors();
	    }
	    ErrorMsg err = new ErrorMsg(ErrorMsg.JAXP_COMPILE_ERR);
	    throw new TransformerConfigurationException(err.toString());
	}

	return new TemplatesImpl(bytecodes, transletName, 
	    xsltc.getOutputProperties(), _indentNumber, this);
    }

    
    public TemplatesHandler newTemplatesHandler() 
	throws TransformerConfigurationException 
    { 
	final TemplatesHandlerImpl handler = 
	    new TemplatesHandlerImpl(_indentNumber, this);
	handler.init();
	if (_uriResolver != null) {
	    handler.setURIResolver(_uriResolver);
	}
	return handler;
    }

    
    public TransformerHandler newTransformerHandler() 
	throws TransformerConfigurationException 
    {
	final Transformer transformer = newTransformer();
	if (_uriResolver != null) {
	    transformer.setURIResolver(_uriResolver);
	}
	return new TransformerHandlerImpl((TransformerImpl) transformer);
    }

    
    public TransformerHandler newTransformerHandler(Source src) 
	throws TransformerConfigurationException 
    { 
	final Transformer transformer = newTransformer(src);
	if (_uriResolver != null) {
	    transformer.setURIResolver(_uriResolver);
	}
	return new TransformerHandlerImpl((TransformerImpl) transformer);
    }

        
    public TransformerHandler newTransformerHandler(Templates templates) 
	throws TransformerConfigurationException  
    {
	final Transformer transformer = templates.newTransformer();
	final TransformerImpl internal = (TransformerImpl)transformer;
	return new TransformerHandlerImpl(internal);
    }

    
    public XMLFilter newXMLFilter(Source src) 
	throws TransformerConfigurationException 
    {
	Templates templates = newTemplates(src);
	if (templates == null) return null; 
	return newXMLFilter(templates);
    }

    
    public XMLFilter newXMLFilter(Templates templates) 
	throws TransformerConfigurationException 
    {
	try {
      	    return new org.apache.xalan.xsltc.trax.TrAXFilter(templates);
    	}
	catch (TransformerConfigurationException e1) {
      	    if (_errorListener != null) {
                try {
          	    _errorListener.fatalError(e1);
          	    return null;
        	}
		catch (TransformerException e2) {
          	    new TransformerConfigurationException(e2);
        	}
      	    }
      	    throw e1;
    	}
    }

    
    public void error(TransformerException e)
	throws TransformerException 
    {
	System.err.println(""ERROR: ""+e.getMessageAndLocation());
	Throwable wrapped = e.getException();
	if (wrapped != null) {
	    System.err.println(""     : ""+wrapped.getMessage());
	}
	throw e; 	
    }

    
    public void fatalError(TransformerException e)
	throws TransformerException 
    {
	System.err.println(""FATAL: ""+e.getMessageAndLocation());
	Throwable wrapped = e.getException();
	if (wrapped != null) {
	    System.err.println(""     : ""+wrapped.getMessage());
	}
	throw e;
    }

    
    public void warning(TransformerException e)
	throws TransformerException 
    {
	System.err.println(""WARNING: ""+e.getMessageAndLocation());
	Throwable wrapped = e.getException();
	if (wrapped != null) {
	    System.err.println(""       : ""+wrapped.getMessage());
	}
    }

    
    public InputSource loadSource(String href, String context, XSLTC xsltc) {
	try {
	    if (_uriResolver != null) {
		final Source source = _uriResolver.resolve(href, context);
		if (source != null) {
		    return Util.getInputSource(xsltc, source);
		}
	    }
	}
	catch (TransformerException e) {
	    
	}
	return null;
    }

    public XMLReader getXMLReader() throws Exception {
	if (_xmlReader == null) {
	    final SAXParserFactory pfactory 
		= SAXParserFactory.newInstance();
	    pfactory.setNamespaceAware(true);
	    _xmlReader = pfactory.newSAXParser().getXMLReader();
	}
	return _xmlReader;
    }
}
"
org.apache.xml.utils.SuballocatedIntVector,18,1,0,13,20,3,13,0,11,0.294117647,860,1.0,0,0.0,0.916666667,0,0,46.38888889,8,3.1111,0,"
package org.apache.xml.utils;


public class SuballocatedIntVector
{
  
  protected int m_blocksize;

  
  protected int m_SHIFT, m_MASK;
  
  
  protected  int m_numblocks=32;
  
  
  protected int m_map[][];

  
  protected int m_firstFree = 0;

  
  protected int m_map0[];


  
  public SuballocatedIntVector()
  {
    this(2048);
  }

  
  public SuballocatedIntVector(int blocksize)
  {
    
    for(m_SHIFT=0;0!=(blocksize>>>=1);++m_SHIFT)
      ;
    m_blocksize=1<<m_SHIFT;
    m_MASK=m_blocksize-1;
		
    m_map0=new int[m_blocksize];
    m_map = new int[m_numblocks][];
    m_map[0]=m_map0;
  }
	
  
  public SuballocatedIntVector(int blocksize,int increasesize)
  {
    this(blocksize);
  }

  
  public int size()
  {
    return m_firstFree;
  }
  
  
  public void setSize(int sz)
  {
    if(m_firstFree>sz) 
      m_firstFree = sz;
  }

  
  public  void addElement(int value)
  {
    if(m_firstFree<m_blocksize)
      m_map0[m_firstFree++]=value;
    else
    {
      
      
      
      
      
      

      int index=m_firstFree>>>m_SHIFT;
      int offset=m_firstFree&m_MASK;

      if(index>=m_map.length)
      {
	int newsize=index+m_numblocks;
	int[][] newMap=new int[newsize][];
	System.arraycopy(m_map, 0, newMap, 0, m_map.length);
	m_map=newMap;
      }
      int[] block=m_map[index];
      if(null==block)
	block=m_map[index]=new int[m_blocksize];
      block[offset]=value;

      ++m_firstFree;
    }
  }
  
  
  private  void addElements(int value, int numberOfElements)
  {
    if(m_firstFree+numberOfElements<m_blocksize)
      for (int i = 0; i < numberOfElements; i++) 
      {
        m_map0[m_firstFree++]=value;
      }
    else
    {
      int index=m_firstFree>>>m_SHIFT;
      int offset=m_firstFree&m_MASK;
      m_firstFree+=numberOfElements;
      while( numberOfElements>0)
      {
        if(index>=m_map.length)
        {
          int newsize=index+m_numblocks;
          int[][] newMap=new int[newsize][];
          System.arraycopy(m_map, 0, newMap, 0, m_map.length);
          m_map=newMap;
        }
        int[] block=m_map[index];
        if(null==block)
          block=m_map[index]=new int[m_blocksize];
        int copied=(m_blocksize-offset < numberOfElements)
          ? m_blocksize-offset : numberOfElements;
        numberOfElements-=copied;
        while(copied-- > 0)
          block[offset++]=value;

        ++index;offset=0;
      }
    }
  }
  
  
  private  void addElements(int numberOfElements)
  {
    int newlen=m_firstFree+numberOfElements;
    if(newlen>m_blocksize)
    {
      int index=m_firstFree>>>m_SHIFT;
      int newindex=(m_firstFree+numberOfElements)>>>m_SHIFT;
      for(int i=index+1;i<=newindex;++i)
        m_map[i]=new int[m_blocksize];
    }
    m_firstFree=newlen;
  }
  
  
  private  void insertElementAt(int value, int at)
  {
    if(at==m_firstFree)
      addElement(value);
    else if (at>m_firstFree)
    {
      int index=at>>>m_SHIFT;
      if(index>=m_map.length)
      {
        int newsize=index+m_numblocks;
        int[][] newMap=new int[newsize][];
        System.arraycopy(m_map, 0, newMap, 0, m_map.length);
        m_map=newMap;
      }
      int[] block=m_map[index];
      if(null==block)
        block=m_map[index]=new int[m_blocksize];
      int offset=at&m_MASK;
          block[offset]=value;
          m_firstFree=offset+1;
        }
    else
    {
      int index=at>>>m_SHIFT;
      int maxindex=m_firstFree>>>m_SHIFT; 
      ++m_firstFree;
      int offset=at&m_MASK;
      int push;
      
      
      while(index<=maxindex)
      {
        int copylen=m_blocksize-offset-1;
        int[] block=m_map[index];
        if(null==block)
        {
          push=0;
          block=m_map[index]=new int[m_blocksize];
        }
        else
        {
          push=block[m_blocksize-1];
          System.arraycopy(block, offset , block, offset+1, copylen);
        }
        block[offset]=value;
        value=push;
        offset=0;
        ++index;
      }
    }
  }

  
  public void removeAllElements()
  {
    m_firstFree = 0;
  }

  
  private  boolean removeElement(int s)
  {
    int at=indexOf(s,0);
    if(at<0)
      return false;
    removeElementAt(at);
    return true;
  }

  
  private  void removeElementAt(int at)
  {
        
    if(at<m_firstFree)
    {
      int index=at>>>m_SHIFT;
      int maxindex=m_firstFree>>>m_SHIFT;
      int offset=at&m_MASK;
      
      while(index<=maxindex)
      {
        int copylen=m_blocksize-offset-1;
        int[] block=m_map[index];
        if(null==block)
          block=m_map[index]=new int[m_blocksize];
        else
          System.arraycopy(block, offset+1, block, offset, copylen);
        if(index<maxindex)
        {
          int[] next=m_map[index+1];
          if(next!=null)
            block[m_blocksize-1]=(next!=null) ? next[0] : 0;
        }
        else
          block[m_blocksize-1]=0;
        offset=0;
        ++index;
      }
    }
    --m_firstFree;
  }

  
  public void setElementAt(int value, int at)
  {
    if(at<m_blocksize)
      m_map0[at]=value;
    else
    {
      int index=at>>>m_SHIFT;
      int offset=at&m_MASK;
        
      if(index>=m_map.length)
      {
	int newsize=index+m_numblocks;
	int[][] newMap=new int[newsize][];
	System.arraycopy(m_map, 0, newMap, 0, m_map.length);
	m_map=newMap;
      }

      int[] block=m_map[index];
      if(null==block)
	block=m_map[index]=new int[m_blocksize];
      block[offset]=value;
    }

    if(at>=m_firstFree)
      m_firstFree=at+1;
  }
  

  
  public int elementAt(int i)
  {
    
    if(i<m_blocksize)
      return m_map0[i];

    return m_map[i>>>m_SHIFT][i&m_MASK];
  }

  
  private  boolean contains(int s)
  {
    return (indexOf(s,0) >= 0);
  }

  
  public int indexOf(int elem, int index)
  {
        if(index>=m_firstFree)
                return -1;
          
    int bindex=index>>>m_SHIFT;
    int boffset=index&m_MASK;
    int maxindex=m_firstFree>>>m_SHIFT;
    int[] block;
    
    for(;bindex<maxindex;++bindex)
    {
      block=m_map[bindex];
      if(block!=null)
        for(int offset=boffset;offset<m_blocksize;++offset)
          if(block[offset]==elem)
            return offset+bindex*m_blocksize;
      boffset=0; 
    }
    
    int maxoffset=m_firstFree&m_MASK;
    block=m_map[maxindex];
    for(int offset=boffset;offset<maxoffset;++offset)
      if(block[offset]==elem)
        return offset+maxindex*m_blocksize;

    return -1;    
  }

  
  public int indexOf(int elem)
  {
    return indexOf(elem,0);
  }

  
  private  int lastIndexOf(int elem)
  {
    int boffset=m_firstFree&m_MASK;
    for(int index=m_firstFree>>>m_SHIFT;
        index>=0;
        --index)
    {
      int[] block=m_map[index];
      if(block!=null)
        for(int offset=boffset; offset>=0; --offset)
          if(block[offset]==elem)
            return offset+index*m_blocksize;
      boffset=0; 
    }
    return -1;
  }

}
"
org.apache.xalan.xsltc.cmdline.getopt.MissingOptArgException,1,4,0,2,2,0,1,1,1,2.0,5,0.0,0,1.0,1.0,0,0,4.0,0,0.0,0,"

package org.apache.xalan.xsltc.cmdline.getopt; 

import org.apache.xalan.xsltc.cmdline.getopt.GetOptsException;

class MissingOptArgException extends GetOptsException{
    public MissingOptArgException(String msg){
	super(msg);
    }
}
"
org.apache.xalan.xsltc.compiler.ElementAvailableCall,5,4,0,19,19,10,0,19,5,2.0,85,0.0,0,0.96,0.333333333,3,12,16.0,2,1.2,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;
import java.util.HashSet;
import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class ElementAvailableCall extends FunctionCall {

    public ElementAvailableCall(QName fname, Vector arguments) {
	super(fname, arguments);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	if (argument() instanceof LiteralExpr) {
	    return _type = Type.Boolean;
	}
	ErrorMsg err = new ErrorMsg(ErrorMsg.NEED_LITERAL_ERR,
				    ""element-available"", this);
	throw new TypeCheckError(err);
    }

    
    public Object evaluateAtCompileTime() {
	return getResult() ? Boolean.TRUE : Boolean.FALSE;
    }

    
    public boolean getResult() {
	try {
	    final LiteralExpr arg = (LiteralExpr) argument();
	    final String qname = arg.getValue();
	    final int index = qname.indexOf(':');
	    final String localName = (index > 0) ? 
		qname.substring(index + 1) : qname;
	    return getParser().elementSupported(arg.getNamespace(), 
					        localName);
	}
	catch (ClassCastException e) {
	    return false;
	}
    }

    
    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final boolean result = getResult();
	methodGen.getInstructionList().append(new PUSH(cpg, result));
    }
}
"
org.apache.xpath.ExpressionNode,5,1,0,41,5,10,41,0,5,2.0,5,0.0,0,0.0,0.6,0,0,0.0,1,1.0,0,"
package org.apache.xpath;

import javax.xml.transform.SourceLocator;


public interface ExpressionNode extends SourceLocator
{
  
  public void exprSetParent(ExpressionNode n);
  public ExpressionNode exprGetParent();

  
  public void exprAddChild(ExpressionNode n, int i);

  
  public ExpressionNode exprGetChild(int i);

  
  public int exprGetNumChildren();
}

"
org.apache.xpath.axes.LocPathIterator,52,4,8,46,84,1030,28,22,45,0.85130719,658,0.833333333,4,0.616,0.145104895,2,9,11.42307692,10,1.3846,1,"
package org.apache.xpath.axes;


import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.Serializable;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMFilter;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xml.dtm.DTMManager;
import org.apache.xml.utils.PrefixResolver;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.objects.XNodeSet;
import org.apache.xpath.objects.XObject;
import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;
import org.xml.sax.ContentHandler;
import org.xml.sax.SAXException;


public abstract class LocPathIterator extends PredicatedNodeTest
        implements Cloneable, DTMIterator, java.io.Serializable, PathComponent
{
	
  
  protected LocPathIterator()
  {
  }


  
  protected LocPathIterator(PrefixResolver nscontext)
  {

    setLocPathIterator(this);
    m_prefixResolver = nscontext;
  }

  
  protected LocPathIterator(Compiler compiler, int opPos, int analysis)
          throws javax.xml.transform.TransformerException
  {
    this(compiler, opPos, analysis, true);
  }

  
  protected LocPathIterator(
          Compiler compiler, int opPos, int analysis, boolean shouldLoadWalkers)
            throws javax.xml.transform.TransformerException
  {
    setLocPathIterator(this);
  }
  
  
  public int getAnalysisBits()
  {
  	int axis = getAxis();
  	int bit = WalkerFactory.getAnalysisBitFromAxes(axis);
  	return bit;
  }
  
  
  private void readObject(java.io.ObjectInputStream stream)
          throws java.io.IOException, javax.xml.transform.TransformerException
  {
    try
    {
      stream.defaultReadObject();
      m_clones =  new IteratorPool(this);
    }
    catch (ClassNotFoundException cnfe)
    {
      throw new javax.xml.transform.TransformerException(cnfe);
    }
  }
  
  
  public void setEnvironment(Object environment)
  {
    
  }
  
  
  public DTM getDTM(int nodeHandle)
  {
    
    return m_execContext.getDTM(nodeHandle);
  }
  
  
  public DTMManager getDTMManager()
  {
    return m_execContext.getDTMManager();
  }
  
  
  public XObject execute(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {

    XNodeSet iter = new XNodeSet((LocPathIterator)m_clones.getInstance());

    iter.setRoot(xctxt.getCurrentNode(), xctxt);

    return iter;
  }
    
  
  public void executeCharsToContentHandler(
          XPathContext xctxt, org.xml.sax.ContentHandler handler)
            throws javax.xml.transform.TransformerException,
                   org.xml.sax.SAXException
  {
    LocPathIterator clone = (LocPathIterator)m_clones.getInstance();

    int current = xctxt.getCurrentNode();
    clone.setRoot(current, xctxt);
    
    int node = clone.nextNode();
    DTM dtm = clone.getDTM(node);
    clone.detach();
	
    if(node != DTM.NULL)
    {
      dtm.dispatchCharactersEvents(node, handler, false);
    }
  }
  
  
  public DTMIterator asIterator(
          XPathContext xctxt, int contextNode)
            throws javax.xml.transform.TransformerException
  {
    XNodeSet iter = new XNodeSet((LocPathIterator)m_clones.getInstance());

    iter.setRoot(contextNode, xctxt);

    return iter;
  }

  
  
  public boolean isNodesetExpr()
  {
    return true;
  }
  
  
  public int asNode(XPathContext xctxt)
    throws javax.xml.transform.TransformerException
  {
    DTMIterator iter = (DTMIterator)m_clones.getInstance();
    
    int current = xctxt.getCurrentNode();
    
    iter.setRoot(current, xctxt);

    int next = iter.nextNode();
    
    iter.detach();
    return next;
  }
  
  
  public boolean bool(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return (asNode(xctxt) != DTM.NULL);
  }


  
  public void setIsTopLevel(boolean b)
  {
    m_isTopLevel = b;
  }

  
  public boolean getIsTopLevel()
  {
    return m_isTopLevel;
  }
  
  
  public void setRoot(int context, Object environment)
  {

    m_context = context;
    
    XPathContext xctxt = (XPathContext)environment;
    m_execContext = xctxt;
    m_cdtm = xctxt.getDTM(context);
    
    m_currentContextNode = context; 
    
    
    if(null == m_prefixResolver)
    	m_prefixResolver = xctxt.getNamespaceContext();
        
    m_lastFetched = DTM.NULL;
    m_foundLast = false;
    m_pos = 0;
    m_length = -1;

    if (m_isTopLevel)
      this.m_stackFrame = xctxt.getVarStack().getStackFrame();
      
    
  }

  
  protected void setNextPosition(int next)
  {
    assertion(false, ""setNextPosition not supported in this iterator!"");
  }

  
  public final int getCurrentPos()
  {
    return m_pos;
  }


  
  public void setShouldCacheNodes(boolean b)
  {

    assertion(false, ""setShouldCacheNodes not supported by this iterater!"");
  }
  
  
  public boolean isMutable()
  {
    return false;
  }

  
  public void setCurrentPos(int i)
  {
  	assertion(false, ""setCurrentPos not supported by this iterator!"");
  }
  
  
  public void incrementCurrentPos()
  {
  	m_pos++;
  }


  
  public int size()
  {
	assertion(false, ""size() not supported by this iterator!"");
	return 0;
  }

  
  public int item(int index)
  {
	assertion(false, ""item(int index) not supported by this iterator!"");
	return 0;
  }
  
  
  public void setItem(int node, int index)
  {
	assertion(false, ""setItem not supported by this iterator!"");
  }

  
  public int getLength()
  {      
  	boolean isPredicateTest = (this == m_execContext.getSubContextList());
  	int predCount = getPredicateCount();
  	
  	if(-1 != m_length && !isPredicateTest)
  		return m_length;
  	
  	if(m_foundLast)
  		return m_pos;
  		
    int pos = (m_predicateIndex >= 0) ? getProximityPosition() : m_pos;
              
    LocPathIterator clone;

    try
    {
      clone = (LocPathIterator) clone();        
    }
    catch (CloneNotSupportedException cnse)
    {
      return -1;
    }

    
    
    
    if(predCount > 0 && isPredicateTest)
    {
      
      clone.m_predCount = predCount - 1;
    }

    int next;

    while (DTM.NULL != (next = clone.nextNode()))
    {
      pos++;
    }
    
    if(!isPredicateTest)
      m_length = pos;
    
    return pos;
  }

  
  public boolean isFresh()
  {
    return (m_pos == 0);
  }

  
  public int previousNode()
  {
    throw new RuntimeException(
      XSLMessages.createXPATHMessage(XPATHErrorResources.ER_NODESETDTM_CANNOT_ITERATE, null)); 
  }

  
  public int getWhatToShow()
  {

    
    return DTMFilter.SHOW_ALL & ~DTMFilter.SHOW_ENTITY_REFERENCE;
  }

  
  public DTMFilter getFilter()
  {
    return null;
  }

  
  public int getRoot()
  {
    return m_context;
  }

  
  public boolean getExpandEntityReferences()
  {
    return true;
  }
  
  
  protected boolean m_allowDetach = true;
  
  
  public void allowDetachToRelease(boolean allowRelease)
  {
    m_allowDetach = allowRelease;
  }

  
  public void detach()
  {    
    if(m_allowDetach)
    {
      
      
      m_execContext = null;
      
      m_cdtm = null;
      m_length = -1;
      m_pos = 0;
      m_lastFetched = DTM.NULL;
      m_context = DTM.NULL;
      m_currentContextNode = DTM.NULL;
      
      m_clones.freeInstance(this);
    }
  }
  
  
  public void reset()
  {
  	assertion(false, ""This iterator can not reset!"");
  }

  
  public DTMIterator cloneWithReset() throws CloneNotSupportedException
  {
    LocPathIterator clone;

    clone = (LocPathIterator)m_clones.getInstanceOrThrow();
    clone.m_execContext = m_execContext;
    clone.m_cdtm = m_cdtm;
    
    clone.m_context = m_context;
    clone.m_currentContextNode = m_currentContextNode;
    clone.m_stackFrame = m_stackFrame;

    

    return clone;
  }

















  
  public abstract int nextNode();

  
  protected int returnNextNode(int nextNode)
  {

    if (DTM.NULL != nextNode)
    {
      m_pos++;
    }

    m_lastFetched = nextNode;

    if (DTM.NULL == nextNode)
      m_foundLast = true;

    return nextNode;
  }

  
  public int getCurrentNode()
  {
    return m_lastFetched;
  }

  
  public void runTo(int index)
  {

    if (m_foundLast || ((index >= 0) && (index <= getCurrentPos())))
      return;

    int n;

    if (-1 == index)
    {
      while (DTM.NULL != (n = nextNode()));
    }
    else
    {
      while (DTM.NULL != (n = nextNode()))
      {
        if (getCurrentPos() >= index)
          break;
      }
    }
  }

  
  public final boolean getFoundLast()
  {
    return m_foundLast;
  }

  
  public final XPathContext getXPathContext()
  {
    return m_execContext;
  }

  
  public final int getContext()
  {
    return m_context;
  }

  
  public final int getCurrentContextNode()
  {
    return m_currentContextNode;
  }

  
  public final void setCurrentContextNode(int n)
  {
    m_currentContextNode = n;
  }
  











  
  public final PrefixResolver getPrefixResolver()
  {
  	if(null == m_prefixResolver)
  	{
    	m_prefixResolver = (PrefixResolver)getExpressionOwner();
  	}

    return m_prefixResolver;
  }
        




















  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	 	if(visitor.visitLocationPath(owner, this))
  	 	{
  	 		visitor.visitStep(owner, this);
  	 		callPredicateVisitors(visitor);
  	 	}
  }  

  
  
  
  
  transient protected IteratorPool m_clones = new IteratorPool(this);
  
  
  transient protected DTM m_cdtm;
  
  
  transient int m_stackFrame = -1;

  
  private boolean m_isTopLevel = false;

  
  transient public int m_lastFetched = DTM.NULL;

  
  transient protected int m_context = DTM.NULL;

  
  transient protected int m_currentContextNode = DTM.NULL;
  
  
  transient protected int m_pos = 0;
  
  transient protected int m_length = -1;

  
  private PrefixResolver m_prefixResolver;

  
  transient protected XPathContext m_execContext;
  
  
  public boolean isDocOrdered()
  {
    return true;
  }
  
  
  public int getAxis()
  {
    return -1;
  }









  
  public int getLastPos(XPathContext xctxt)
  {
    return getLength();
  }


}
"
org.apache.xalan.xsltc.trax.SAX2DOM,21,1,0,2,51,134,1,1,21,0.716666667,292,1.0,0,0.0,0.265306122,0,0,12.76190476,7,1.381,1,"


package org.apache.xalan.xsltc.trax;

import java.util.Stack;
import java.util.Vector;

import org.xml.sax.ContentHandler;
import org.xml.sax.Locator;
import org.xml.sax.Attributes;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.ProcessingInstruction;
import org.w3c.dom.Comment;
import org.w3c.dom.DOMException;
import org.w3c.dom.Element;
import org.w3c.dom.Text;
import org.w3c.dom.Attr;
import org.xml.sax.ext.LexicalHandler;
import org.xml.sax.SAXException;

import org.apache.xalan.xsltc.runtime.Constants;

public class SAX2DOM implements ContentHandler, LexicalHandler, Constants {

    private Document _root = null;
    private Stack _nodeStk = new Stack();
    private Vector _namespaceDecls = null;

    public SAX2DOM() throws ParserConfigurationException {
	final DocumentBuilderFactory factory = 
		DocumentBuilderFactory.newInstance();
	_root = factory.newDocumentBuilder().newDocument();
    }

    public SAX2DOM(Node root) throws ParserConfigurationException {
	if (root != null) {
	    _root = (Document) root;   
	}
	else {
	    final DocumentBuilderFactory factory = 
		DocumentBuilderFactory.newInstance();
	    _root = factory.newDocumentBuilder().newDocument();
	}
    }

    public Node getDOM() {
	return _root;
    }

    public void characters(char[] ch, int start, int length) {
	final Node last = (Node)_nodeStk.peek();

	
	if (last != _root) {
	    final String text = new String(ch, start, length);
	    last.appendChild(_root.createTextNode(text));
	}
    }

    public void startDocument() {
	_nodeStk.push(_root);
    }

    public void endDocument() {
    }

    public void startElement(String namespace, String localName, String qName,
	Attributes attrs) 
    {
	final Element tmp = (Element)_root.createElementNS(namespace, qName);

	
	if (_namespaceDecls != null) {
	    final int nDecls = _namespaceDecls.size();
	    for (int i = 0; i < nDecls; i++) {
		final String prefix = (String) _namespaceDecls.elementAt(i++);

		if (prefix == null || prefix.equals(EMPTYSTRING)) {
		    tmp.setAttributeNS(XMLNS_URI, XMLNS_PREFIX,
			(String) _namespaceDecls.elementAt(i));
		}
		else {
		    tmp.setAttributeNS(XMLNS_URI, XMLNS_STRING + prefix, 
			(String) _namespaceDecls.elementAt(i));
		}
	    }
	    _namespaceDecls.clear();
	}

	
	final int nattrs = attrs.getLength();
	for (int i = 0; i < nattrs; i++) {
	    if (attrs.getLocalName(i) == null) {
		tmp.setAttribute(attrs.getQName(i), attrs.getValue(i));
	    }
	    else {
		tmp.setAttributeNS(attrs.getURI(i), attrs.getQName(i), 
		    attrs.getValue(i));
	    }
	}

	
	Node last = (Node)_nodeStk.peek();
	last.appendChild(tmp);

	
	_nodeStk.push(tmp);
    }

    public void endElement(String namespace, String localName, String qName) {
	_nodeStk.pop();  
    }

    public void startPrefixMapping(String prefix, String uri) {
	if (_namespaceDecls == null) {
	    _namespaceDecls = new Vector(2);
	}
	_namespaceDecls.addElement(prefix);
	_namespaceDecls.addElement(uri);
    }

    public void endPrefixMapping(String prefix) {
	
    }

    
    public void ignorableWhitespace(char[] ch, int start, int length) {
    }

    
    public void processingInstruction(String target, String data) {
	final Node last = (Node)_nodeStk.peek();
	ProcessingInstruction pi = _root.createProcessingInstruction(
		target, data);
	if (pi != null)  last.appendChild(pi);
    }

    
    public void setDocumentLocator(Locator locator) {
    }

    
    public void skippedEntity(String name) {
    }


    
    public void comment(char[] ch, int start, int length) {
	final Node last = (Node)_nodeStk.peek();
	Comment comment = _root.createComment(new String(ch,start,length));
	if (comment != null) last.appendChild(comment);
    }

    
    public void startCDATA() { }
    public void endCDATA() { }
    public void startEntity(java.lang.String name) { }
    public void endDTD() { }
    public void endEntity(String name) { }
    public void startDTD(String name, String publicId, String systemId)
        throws SAXException { }

}
"
org.apache.xalan.xsltc.compiler.ParentPattern,8,6,0,31,41,0,1,30,8,0.285714286,253,1.0,2,0.933962264,0.25,4,5,30.375,8,1.75,0,"

package org.apache.xalan.xsltc.compiler;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class ParentPattern extends RelativePathPattern {
    private final Pattern _left;
    private final RelativePathPattern _right;
		
    public ParentPattern(Pattern left, RelativePathPattern right) {
	(_left = left).setParent(this);
	(_right = right).setParent(this);
    }

    public void setParser(Parser parser) {
	super.setParser(parser);
	_left.setParser(parser);
	_right.setParser(parser);
    }
    
    public boolean isWildcard() {
	return false;
    }
	
    public StepPattern getKernelPattern() {
	return _right.getKernelPattern();
    }
	
    public void reduceKernelPattern() {
	_right.reduceKernelPattern();
    }

    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_left.typeCheck(stable);
	return _right.typeCheck(stable);
    }

    public void translate(ClassGenerator classGen, MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	final LocalVariableGen local =
	    methodGen.addLocalVariable2(""ppt"", 
					Util.getJCRefType(NODE_SIG),
					il.getEnd());
	
	final org.apache.bcel.generic.Instruction loadLocal =
	    new ILOAD(local.getIndex());
	final org.apache.bcel.generic.Instruction storeLocal =
	    new ISTORE(local.getIndex());

	if (_right.isWildcard()) {
	    il.append(methodGen.loadDOM());
	    il.append(SWAP);
	}
	else if (_right instanceof StepPattern) {
	    il.append(DUP);
	    il.append(storeLocal);
	    
	    _right.translate(classGen, methodGen);
	    
	    il.append(methodGen.loadDOM());
	    local.setEnd(il.append(loadLocal));
	}
	else {
	    _right.translate(classGen, methodGen);

	    if (_right instanceof AncestorPattern) {
		il.append(methodGen.loadDOM());
		il.append(SWAP);
	    }
	}

	final int getParent = cpg.addInterfaceMethodref(DOM_INTF,
							GET_PARENT,
							GET_PARENT_SIG);
	il.append(new INVOKEINTERFACE(getParent, 2));

	final SyntaxTreeNode p = getParent();
	if (p == null || p instanceof Instruction || 
	    p instanceof TopLevelElement) 
	{
	    _left.translate(classGen, methodGen);
	}
	else {
	    il.append(DUP);
	    il.append(storeLocal);
	    
	    _left.translate(classGen, methodGen);

	    il.append(methodGen.loadDOM());
	    local.setEnd(il.append(loadLocal));
	}

	methodGen.removeLocalVariable(local);
	
	
	if (_right instanceof AncestorPattern) {
	    final AncestorPattern ancestor = (AncestorPattern) _right;
	    _left.backPatchFalseList(ancestor.getLoopHandle());    
	}

	_trueList.append(_right._trueList.append(_left._trueList));
	_falseList.append(_right._falseList.append(_left._falseList));
    }

    public String toString() {
	return ""Parent("" + _left + "", "" + _right + ')';
    }
}
"
org.apache.xalan.xsltc.compiler.util.StringType,18,2,0,44,42,153,18,30,17,2.0,268,0.0,0,0.66,0.283950617,2,4,13.88888889,4,1.2778,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Parser;
import org.apache.xalan.xsltc.compiler.FlowList;
import org.apache.xalan.xsltc.compiler.Constants;

public class StringType extends Type {
    protected StringType() {}

    public String toString() {
	return ""string"";
    }

    public boolean identicalTo(Type other) {
	return this == other;
    }

    public String toSignature() {
	return ""Ljava/lang/String;"";
    }

    public boolean isSimple() {
	return true;
    }

    public org.apache.bcel.generic.Type toJCType() {
	return org.apache.bcel.generic.Type.STRING;
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Type type) {
	if (type == Type.Boolean) {
	    translateTo(classGen, methodGen, (BooleanType) type);
	}
	else if (type == Type.Real) {
	    translateTo(classGen, methodGen, (RealType) type);
	}
	else if (type == Type.Reference) {
	    translateTo(classGen, methodGen, (ReferenceType) type);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), type.toString());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    BooleanType type) {
	final InstructionList il = methodGen.getInstructionList();
	FlowList falsel = translateToDesynthesized(classGen, methodGen, type);
	il.append(ICONST_1);
	final BranchHandle truec = il.append(new GOTO(null));
	falsel.backPatch(il.append(ICONST_0));
	truec.setTarget(il.append(NOP));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen,
			    RealType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();
	il.append(new INVOKESTATIC(cpg.addMethodref(BASIS_LIBRARY_CLASS,
						    STRING_TO_REAL,
						    STRING_TO_REAL_SIG)));
    }

    
    public FlowList translateToDesynthesized(ClassGenerator classGen, 
					     MethodGenerator methodGen, 
					     BooleanType type) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	il.append(new INVOKEVIRTUAL(cpg.addMethodref(STRING_CLASS,
						     ""length"", ""()I"")));
	return new FlowList(il.append(new IFEQ(null)));
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    ReferenceType type) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public void translateTo(ClassGenerator classGen, MethodGenerator methodGen, 
			    Class clazz) 
    {
	if (clazz.getName().equals(""java.lang.String"")) {
	    
	    methodGen.getInstructionList().append(NOP);
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }
    
    
    public void translateFrom(ClassGenerator classGen, 
	MethodGenerator methodGen, Class clazz) 
    {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	if (clazz.getName().equals(""java.lang.String"")) {
	    
	    il.append(DUP);
	    final BranchHandle ifNonNull = il.append(new IFNONNULL(null));
	    il.append(POP);
	    il.append(new PUSH(cpg, """"));
	    ifNonNull.setTarget(il.append(NOP));
	}
	else {
	    ErrorMsg err = new ErrorMsg(ErrorMsg.DATA_CONVERSION_ERR,
					toString(), clazz.getName());
	    classGen.getParser().reportError(Constants.FATAL, err);
	}
    }

     
    public void translateBox(ClassGenerator classGen,
			     MethodGenerator methodGen) {
	translateTo(classGen, methodGen, Type.Reference);
    }

     
    public void translateUnBox(ClassGenerator classGen,
			       MethodGenerator methodGen) {
	methodGen.getInstructionList().append(NOP);
    }

    
    public String getClassName() {
	return(STRING_CLASS);
    }


    public Instruction LOAD(int slot) {
	return new ALOAD(slot);
    }
	
    public Instruction STORE(int slot) {
	return new ASTORE(slot);
    }
}
"
org.apache.xml.utils.synthetic.reflection.Member,4,1,0,6,4,6,4,2,4,2.0,4,0.0,0,0.0,0.5,0,0,0.0,1,1.0,0,"
package org.apache.xml.utils.synthetic.reflection;

import org.apache.xml.utils.synthetic.SynthesisException;


public interface Member
{

  
  public abstract org.apache.xml.utils.synthetic.Class getDeclaringClass();

  
  public abstract int getModifiers();

  
  public abstract void setDeclaringClass(
    org.apache.xml.utils.synthetic.Class declaringClass)
      throws SynthesisException;

  
  public abstract void setModifiers(int modifiers) throws SynthesisException;
}
"
org.apache.xalan.xsltc.runtime.MessageHandler,2,1,0,1,4,1,1,0,2,2.0,9,0.0,0,0.0,0.75,0,0,3.5,1,0.5,0,"

package org.apache.xalan.xsltc.runtime;

public class MessageHandler {
    public void displayMessage(String msg) {
	System.err.println(msg);
    }
}
"
org.apache.xalan.xsltc.compiler.util.MethodGenerator,26,4,6,136,47,287,121,15,26,0.978461538,414,1.0,1,0.795081967,0.161538462,1,2,13.92307692,4,1.3077,0,"

package org.apache.xalan.xsltc.compiler.util;

import org.apache.bcel.generic.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.Template;

public class MethodGenerator extends MethodGen
    implements org.apache.xalan.xsltc.compiler.Constants {
    protected static final int INVALID_INDEX   = -1;
    
    private static final String START_ELEMENT_SIG   
	= ""("" + STRING_SIG + "")V"";
    private static final String END_ELEMENT_SIG     
	= START_ELEMENT_SIG;
    
    private InstructionList _mapTypeSub;
	
    private static final int DOM_INDEX       = 1;
    private static final int ITERATOR_INDEX  = 2;
    private static final int HANDLER_INDEX   = 3;

    private Instruction       _iloadCurrent;
    private Instruction       _istoreCurrent;
    private final Instruction _astoreHandler;
    private final Instruction _aloadHandler;
    private final Instruction _astoreIterator;
    private final Instruction _aloadIterator;
    private final Instruction _aloadDom;
    private final Instruction _astoreDom;
    
    private final Instruction _startElement;
    private final Instruction _endElement;
    private final Instruction _startDocument;
    private final Instruction _endDocument;
    private final Instruction _attribute;
    private final Instruction _namespace;

    private final Instruction _setStartNode;
    private final Instruction _reset;
    private final Instruction _nextNode;

    private SlotAllocator _slotAllocator;
    private boolean _allocatorInit = false;
    
    public MethodGenerator(int access_flags, Type return_type,
			   Type[] arg_types, String[] arg_names,
			   String method_name, String class_name,
			   InstructionList il, ConstantPoolGen cpg) {
	super(access_flags, return_type, arg_types, arg_names, method_name, 
	      class_name, il, cpg);
	
	_astoreHandler  = new ASTORE(HANDLER_INDEX);
	_aloadHandler   = new ALOAD(HANDLER_INDEX);
	_astoreIterator = new ASTORE(ITERATOR_INDEX);
	_aloadIterator  = new ALOAD(ITERATOR_INDEX);
	_aloadDom       = new ALOAD(DOM_INDEX);
	_astoreDom      = new ASTORE(DOM_INDEX);
	
	final int startElement =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""startElement"",
				      START_ELEMENT_SIG);
	_startElement = new INVOKEINTERFACE(startElement, 2);
	
	final int endElement =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""endElement"",
				      END_ELEMENT_SIG);
	_endElement = new INVOKEINTERFACE(endElement, 2);

	final int attribute =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""attribute"", 
				      ""(""
				      + STRING_SIG
				      + STRING_SIG
				      + "")V"");
	_attribute = new INVOKEINTERFACE(attribute, 3);

	final int namespace =
	    cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
				      ""namespace"", 
				      ""(""
				      + STRING_SIG
				      + STRING_SIG
				      + "")V"");
	_namespace = new INVOKEINTERFACE(namespace, 3);
	
	int index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
					      ""startDocument"",
					      ""()V"");
	_startDocument = new INVOKEINTERFACE(index, 1);
	
	index = cpg.addInterfaceMethodref(TRANSLET_OUTPUT_INTERFACE,
					  ""endDocument"",
					  ""()V"");
	_endDocument = new INVOKEINTERFACE(index, 1);
	
	
	index = cpg.addInterfaceMethodref(NODE_ITERATOR,
					  SET_START_NODE,
					  SET_START_NODE_SIG);
	_setStartNode = new INVOKEINTERFACE(index, 2);

	index = cpg.addInterfaceMethodref(NODE_ITERATOR,
					  ""reset"", ""()""+NODE_ITERATOR_SIG);
	_reset = new INVOKEINTERFACE(index, 1);
	
	index = cpg.addInterfaceMethodref(NODE_ITERATOR, NEXT, NEXT_SIG);
	_nextNode = new INVOKEINTERFACE(index, 1);
	
	_slotAllocator = new SlotAllocator();
	_slotAllocator.initialize(getLocalVariables());
	_allocatorInit = true;
    }

    
    public LocalVariableGen addLocalVariable(String name, Type type,
					     InstructionHandle start,
					     InstructionHandle end) 
    {
	return (_allocatorInit) ? addLocalVariable2(name, type, start) 
	    : super.addLocalVariable(name, type, start, end);
    }
    
    public LocalVariableGen addLocalVariable2(String name, Type type,
					      InstructionHandle start) 
    {
	return super.addLocalVariable(name, type,
				      _slotAllocator.allocateSlot(type),
				      start, null);
    }

    public void removeLocalVariable(LocalVariableGen lvg) {
	_slotAllocator.releaseSlot(lvg);
	super.removeLocalVariable(lvg);
    }

    public Instruction loadDOM() {
	return _aloadDom;
    }

    public Instruction storeDOM() {
	return _astoreDom;
    }
    
    public Instruction storeHandler() {
	return _astoreHandler;
    }

    public Instruction loadHandler() {
	return _aloadHandler;
    }

    public Instruction storeIterator() {
	return _astoreIterator;
    }
    
    public Instruction loadIterator() {
	return _aloadIterator;
    }
    
    public final Instruction setStartNode() {
	return _setStartNode;
    }

    public final Instruction reset() {
	return _reset;
    }
    
    public final Instruction nextNode() {
	return _nextNode;
    }
    
    public final Instruction startElement() {
	return _startElement;
    }

    public final Instruction endElement() {
	return _endElement;
    }

    public final Instruction startDocument() {
	return _startDocument;
    }

    public final Instruction endDocument() {
	return _endDocument;
    }

    public final Instruction attribute() {
	return _attribute;
    }

    public final Instruction namespace() {
	return _namespace;
    }

    public Instruction loadCurrentNode() {
	if (_iloadCurrent == null) {
	    int idx = getLocalIndex(""current"");
	    if (idx > 0)
		_iloadCurrent = new ILOAD(idx);
	    else
		_iloadCurrent = new ICONST(0);
	}
	return _iloadCurrent;
    }

    public Instruction storeCurrentNode() {
	return _istoreCurrent != null
	    ? _istoreCurrent
	    : (_istoreCurrent = new ISTORE(getLocalIndex(""current"")));
    }

    
    public Instruction loadContextNode() {
	return loadCurrentNode();
    }

    public Instruction storeContextNode() {
	return storeCurrentNode();
    }

    public int getLocalIndex(String name) {
	return getLocalVariable(name).getIndex();
    }

    public LocalVariableGen getLocalVariable(String name) {
	final LocalVariableGen[] vars = getLocalVariables();
	for (int i = 0; i < vars.length; i++)
	    if (vars[i].getName().equals(name))
		return vars[i];
	return null;	
    }

    public void setMaxLocals() {
	
	
	int maxLocals = super.getMaxLocals();
	int prevLocals = maxLocals;

	
	final LocalVariableGen[] localVars = super.getLocalVariables();
	if (localVars != null) {
	    if (localVars.length > maxLocals)
		maxLocals = localVars.length;
	}

	
	if (maxLocals < 5) maxLocals = 5;

	super.setMaxLocals(maxLocals);
    }

}
"
org.apache.xpath.patterns.NodeTestFilter,1,1,0,1,1,0,0,1,1,2.0,1,0.0,0,0.0,1.0,0,0,0.0,1,1.0,0,"
package org.apache.xpath.patterns;


public interface NodeTestFilter
{

  
  void setNodeTest(NodeTest nodeTest);
}
"
org.apache.xalan.xsltc.compiler.LangCall,4,4,0,19,17,0,0,19,4,0.666666667,84,1.0,2,0.96969697,0.375,3,8,19.5,2,1.0,0,"

package org.apache.xalan.xsltc.compiler;

import java.util.Vector;

import org.apache.xalan.xsltc.compiler.util.Type;
import org.apache.bcel.generic.*;
import org.apache.xalan.xsltc.compiler.util.*;

final class LangCall extends FunctionCall {
    private Expression _lang;
    private Type _langType;

    
    public LangCall(QName fname, Vector arguments) {
	super(fname, arguments);
	_lang = argument(0);
    }

    
    public Type typeCheck(SymbolTable stable) throws TypeCheckError {
	_langType = _lang.typeCheck(stable);
	if (!(_langType instanceof StringType)) {
	    _lang = new CastExpr(_lang, Type.String);
	}
	return Type.Boolean;
    }

    
    public Type getType() {
	return(Type.Boolean);
    }

    
    public void translate(ClassGenerator classGen,
			  MethodGenerator methodGen) {
	final ConstantPoolGen cpg = classGen.getConstantPool();
	final InstructionList il = methodGen.getInstructionList();

	final int tst = cpg.addMethodref(BASIS_LIBRARY_CLASS,
					 ""testLanguage"",
					 ""(""+STRING_SIG+DOM_INTF_SIG+""I)Z"");
	_lang.translate(classGen,methodGen);
	il.append(methodGen.loadDOM());
	if (classGen instanceof FilterGenerator)
	    il.append(new ILOAD(1));
	else
	    il.append(methodGen.loadContextNode());
	il.append(new INVOKESTATIC(tst));
    }
}
"
org.apache.xalan.xsltc.dom.FilterIterator,9,2,0,5,24,0,1,4,9,0.625,106,1.0,2,0.555555556,0.288888889,1,5,10.44444444,3,1.2222,0,"

package org.apache.xalan.xsltc.dom;

import org.apache.xalan.xsltc.NodeIterator;
import org.apache.xalan.xsltc.runtime.BasisLibrary;

public final class FilterIterator extends NodeIteratorBase {
    private NodeIterator _source;
    private final Filter _filter;
    private final boolean _isReverse;
	
    public FilterIterator(NodeIterator source, Filter filter) {
	_source = source;
	_filter = filter;
	_isReverse = source.isReverse();
    }

    public boolean isReverse() {
	return _isReverse;
    }

    public void setRestartable(boolean isRestartable) {
	_isRestartable = isRestartable;
	_source.setRestartable(isRestartable);
    }

    public NodeIterator cloneIterator() {
	try {
	    final FilterIterator clone = (FilterIterator)super.clone();
	    clone.setRestartable(false);
	    clone._source = _source.cloneIterator();
	    return clone.reset();
	}
	catch (CloneNotSupportedException e) {
	    BasisLibrary.runTimeError(BasisLibrary.ITERATOR_CLONE_ERR,
				      e.toString());
	    return null;
	}
    }
    
    public NodeIterator reset() {
	_source.reset();
	return resetPosition();
    }
    
    public int next() {
	int node;
	while ((node = _source.next()) != END) {
	    if (_filter.test(node)) {
		return returnNode(node);
	    }
	}
	return END;
    }

    public NodeIterator setStartNode(int node) {
	if (_isRestartable) {
	    _source.setStartNode(_startNode = node); 
	    return resetPosition();
	}
	return this;
    }

    public void setMark() {
	_source.setMark();
    }

    public void gotoMark() {
	_source.gotoMark();
    }

}
"
org.apache.xalan.xsltc.compiler.RelativePathPattern,1,5,3,7,2,0,6,1,0,2.0,4,0.0,0,1.0,1.0,0,0,3.0,0,0.0,0,"

package org.apache.xalan.xsltc.compiler;

abstract class RelativePathPattern extends LocationPathPattern {}
"
org.apache.xpath.axes.AxesWalker,27,4,2,21,53,257,8,15,23,0.807692308,451,0.625,4,0.747572816,0.138888889,1,4,15.40740741,5,1.5926,1,"
package org.apache.xpath.axes;

import java.util.Vector;

import javax.xml.transform.TransformerException;
import org.apache.xml.dtm.DTM;
import org.apache.xml.dtm.DTMAxisTraverser;
import org.apache.xml.dtm.DTMIterator;
import org.apache.xpath.Expression;
import org.apache.xpath.ExpressionOwner;
import org.apache.xpath.XPathContext;
import org.apache.xpath.XPathVisitor;
import org.apache.xpath.compiler.Compiler;
import org.apache.xpath.patterns.NodeTest;

import org.apache.xpath.res.XPATHErrorResources;
import org.apache.xalan.res.XSLMessages;


public class AxesWalker extends PredicatedNodeTest
        implements Cloneable, PathComponent, ExpressionOwner
{
  
  
  public AxesWalker(LocPathIterator locPathIterator, int axis)
  {
    super( locPathIterator );
    m_axis = axis;
  }
  
  public final WalkingIterator wi()
  {
    return (WalkingIterator)m_lpi;
  }

  
  public void init(Compiler compiler, int opPos, int stepType)
          throws javax.xml.transform.TransformerException
  {

    initPredicateInfo(compiler, opPos);

    
  }

  
  public Object clone() throws CloneNotSupportedException
  {
    
    
    AxesWalker clone = (AxesWalker) super.clone();

    

    

    return clone;
  }
  
  
  AxesWalker cloneDeep(WalkingIterator cloneOwner, Vector cloneList)
     throws CloneNotSupportedException
  {
    AxesWalker clone = findClone(this, cloneList);
    if(null != clone)
      return clone;
    clone = (AxesWalker)this.clone();
    clone.setLocPathIterator(cloneOwner);
    if(null != cloneList)
    {
      cloneList.addElement(this);
      cloneList.addElement(clone);
    }
    
    if(wi().m_lastUsedWalker == this)
      cloneOwner.m_lastUsedWalker = clone;
      
    if(null != m_nextWalker)
      clone.m_nextWalker = m_nextWalker.cloneDeep(cloneOwner, cloneList);
      
    
    
    if(null != cloneList)
    {
      if(null != m_prevWalker)
        clone.m_prevWalker = m_prevWalker.cloneDeep(cloneOwner, cloneList);
    }
    else
    {
      if(null != m_nextWalker)
        clone.m_nextWalker.m_prevWalker = clone;
    }
    return clone;
  }
  
  
  static AxesWalker findClone(AxesWalker key, Vector cloneList)
  {
    if(null != cloneList)
    {
      
      int n = cloneList.size();
      for (int i = 0; i < n; i+=2) 
      {
        if(key == cloneList.elementAt(i))
          return (AxesWalker)cloneList.elementAt(i+1);
      }
    }
    return null;    
  }
  
  
  public void detach()
  { 
  	m_currentNode = DTM.NULL;
  	m_dtm = null;
  	m_isFresh = true;
  	m_root = DTM.NULL;
  }
  
  

  
  public int getRoot()
  {
    return m_root;
  }
  
  
  public int getAnalysisBits()
  {
  	int axis = getAxis();
  	int bit = WalkerFactory.getAnalysisBitFromAxes(axis);
  	return bit;
  }

  
  public void setRoot(int root)
  {
    
    XPathContext xctxt = wi().getXPathContext();
    m_dtm = xctxt.getDTM(root);
    m_traverser = m_dtm.getAxisTraverser(m_axis);
    m_isFresh = true;
    m_foundLast = false;
    m_root = root;
    m_currentNode = root;

    if (DTM.NULL == root)
    {
      throw new RuntimeException(
        XSLMessages.createXPATHMessage(XPATHErrorResources.ER_SETTING_WALKER_ROOT_TO_NULL, null)); 
 !!!! Error! Setting the root of a walker to null!!!"");
    }

    resetProximityPositions();
  }

  
  public final int getCurrentNode()
  {
    return m_currentNode;
  }

  
  public void setNextWalker(AxesWalker walker)
  {
    m_nextWalker = walker;
  }

  
  public AxesWalker getNextWalker()
  {
    return m_nextWalker;
  }

  
  public void setPrevWalker(AxesWalker walker)
  {
    m_prevWalker = walker;
  }

  
  public AxesWalker getPrevWalker()
  {
    return m_prevWalker;
  }

  
  private int returnNextNode(int n)
  {

    return n;
  }

  
  protected int getNextNode()
  {
    if (m_foundLast)
      return DTM.NULL;

    if (m_isFresh)
    {
      m_currentNode = m_traverser.first(m_root);
      m_isFresh = false;
    }
    
    
umbering24.xsl fails if I don't do this.  I think 
    
    else if(DTM.NULL != m_currentNode) 
    {
      m_currentNode = m_traverser.next(m_root, m_currentNode);
    }

    if (DTM.NULL == m_currentNode)
      this.m_foundLast = true;

    return m_currentNode;
  }

  
  public int nextNode()
  {
    int nextNode = DTM.NULL;
    AxesWalker walker = wi().getLastUsedWalker();

    while (true)
    {
      if (null == walker)
        break;

      nextNode = walker.getNextNode();

      if (DTM.NULL == nextNode)
      {

        walker = walker.m_prevWalker;
      }
      else
      {
        if (walker.acceptNode(nextNode) != DTMIterator.FILTER_ACCEPT)
        {
          continue;
        }

        if (null == walker.m_nextWalker)
        {
          wi().setLastUsedWalker(walker);

          
          break;
        }
        else
        {
          AxesWalker prev = walker;

          walker = walker.m_nextWalker;

          walker.setRoot(nextNode);

          walker.m_prevWalker = prev;

          continue;
        }
      }  
    }  

    return nextNode;
  }

  

  
  public int getLastPos(XPathContext xctxt)
  {

    int pos = getProximityPosition();
    
    AxesWalker walker;

    try
    {
      walker = (AxesWalker) clone();
    }
    catch (CloneNotSupportedException cnse)
    {
      return -1;
    }

    walker.setPredicateCount(walker.getPredicateCount() - 1);
    walker.setNextWalker(null);
    walker.setPrevWalker(null);

    WalkingIterator lpi = wi();
    AxesWalker savedWalker = lpi.getLastUsedWalker();

    try
    {
      lpi.setLastUsedWalker(walker);

      int next;

      while (DTM.NULL != (next = walker.nextNode()))
      {
        pos++;
      }

      
    }
    finally
    {
      lpi.setLastUsedWalker(savedWalker);
    }

    
    return pos;
  }
  
  
  
  
  private DTM m_dtm;
  
  
  public void setDefaultDTM(DTM dtm)
  {
    m_dtm = dtm;
  }
  
  
  public DTM getDTM(int node)
  {
    
    return wi().getXPathContext().getDTM(node);
  }
  
  
  public boolean isDocOrdered()
  {
    return true;
  }
  
  
  public int getAxis()
  {
    return m_axis;
  }
  
  
  public void callVisitors(ExpressionOwner owner, XPathVisitor visitor)
  {
  	if(visitor.visitStep(owner, this))
  	{
  		callPredicateVisitors(visitor);
  		if(null != m_nextWalker)
  		{
  			m_nextWalker.callVisitors(this, visitor);
  		}
  	}
  }
  
  
  public Expression getExpression()
  {
    return m_nextWalker;
  }

  
  public void setExpression(Expression exp)
  {
  	exp.exprSetParent(this);
  	m_nextWalker = (AxesWalker)exp;
  }
  
    
    public boolean deepEquals(Expression expr)
    {
      if (!super.deepEquals(expr))
                return false;

      AxesWalker walker = (AxesWalker)expr;
      if(this.m_axis != walker.m_axis)
      	return false;

      return true;
    }

  
  transient int m_root = DTM.NULL;

  
  private transient int m_currentNode = DTM.NULL;
  
  
  transient boolean m_isFresh;

  
  protected AxesWalker m_nextWalker;
  
  
  AxesWalker m_prevWalker;
  
  
  protected int m_axis = -1;

  
  protected DTMAxisTraverser m_traverser; 

}
"
